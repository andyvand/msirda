/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// void __stdcall RtlCaptureContext(PCONTEXT ContextRecord);
// WORD __stdcall RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash);
// int __stdcall RtlQueryEnvironmentVariable(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpCallbackMayRunLong(_DWORD); weak
// int __stdcall TpAllocIoCompletion(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpAllocWait(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpAllocTimer(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpAllocWork(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpSimpleTryPost(_DWORD, _DWORD, _DWORD); weak
// int __stdcall TpAllocCleanupGroup(_DWORD); weak
// int __stdcall TpQueryPoolStackInformation(_DWORD, _DWORD); weak
// int __stdcall TpSetPoolStackInformation(_DWORD, _DWORD); weak
// int __stdcall TpSetPoolMinThreads(_DWORD, _DWORD); weak
// int __stdcall TpAllocPool(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtCreateEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, EVENT_TYPE EventType, BOOLEAN InitialState);
// NTSTATUS __stdcall NtDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle, HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess, ULONG Attributes, ULONG Options);
// NTSTATUS __stdcall RtlConvertSidToUnicodeString(PUNICODE_STRING UnicodeString, PSID Sid, BOOLEAN AllocateString);
// NTSTATUS __stdcall NtNotifyChangeKey(HANDLE KeyHandle, HANDLE EventHandle, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG NotifyFilter, BOOLEAN WatchSubtree, PVOID Buffer, ULONG BufferLength, BOOLEAN Asynchronous);
// void __stdcall RtlRunOnceInitialize(PRTL_RUN_ONCE RunOnce);
// NTSTATUS __stdcall NtResetEvent(HANDLE EventHandle, PULONG PreviousState);
// BOOLEAN __stdcall RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// int __stdcall RtlOpenCurrentUser(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtQueryInstallUILanguage(PLANGID LanguageId);
// int __stdcall RtlpConvertCultureNamesToLCIDs(_DWORD, _DWORD); weak
// int __stdcall RtlpConvertLCIDsToCultureNames(_DWORD, _DWORD); weak
// BOOLEAN EtwEventEnabled(REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor);
// int __stdcall RtlSetProcessPreferredUILanguages(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall RtlExpandEnvironmentStrings_U(PVOID Environment, PUNICODE_STRING Source, PUNICODE_STRING Destination, PULONG Length);
// NTSTATUS __stdcall RtlUnicodeStringToInteger(PCUNICODE_STRING String, ULONG Base, PULONG Value);
// int __stdcall RtlLCIDToCultureName(_DWORD, _DWORD); weak
// NTSTATUS __stdcall RtlIdnToUnicode(ULONG Flags, PCWSTR SourceString, LONG SourceStringLength, PWSTR DestinationString, PLONG DestinationStringLength);
// NTSTATUS __stdcall RtlIdnToNameprepUnicode(ULONG Flags, PCWSTR SourceString, LONG SourceStringLength, PWSTR DestinationString, PLONG DestinationStringLength);
// NTSTATUS __stdcall RtlIdnToAscii(ULONG Flags, PCWSTR SourceString, LONG SourceStringLength, PWSTR DestinationString, PLONG DestinationStringLength);
// NTSTATUS __stdcall RtlIsNormalizedString(ULONG NormForm, PCWSTR SourceString, LONG SourceStringLength, PBOOLEAN Normalized);
// NTSTATUS __stdcall RtlNormalizeString(ULONG NormForm, PCWSTR SourceString, LONG SourceStringLength, PWSTR DestinationString, PLONG DestinationStringLength);
// NTSTATUS __stdcall RtlIntegerToUnicodeString(ULONG Value, ULONG Base, PUNICODE_STRING String);
// NTSTATUS __stdcall NtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus);
// wchar_t *__cdecl _wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count);
// int __cdecl _wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
// int __stdcall RtlQueryThreadProfiling(_DWORD, _DWORD); weak
// int __stdcall RtlDisableThreadProfiling(_DWORD); weak
// int __stdcall RtlEnableThreadProfiling(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall RtlSetExtendedFeaturesMask(PCONTEXT_EX ContextEx, DWORD64 FeatureMask);
// DWORD64 __stdcall RtlGetExtendedFeaturesMask(PCONTEXT_EX ContextEx);
// PVOID __stdcall RtlLocateExtendedFeature(PCONTEXT_EX ContextEx, DWORD FeatureId, PDWORD Length);
// int __stdcall RtlCopyContext(_DWORD, _DWORD, _DWORD); weak
// DWORD64 __stdcall RtlGetEnabledExtendedFeatures(DWORD64 FeatureMask);
// DWORD __stdcall RtlGetExtendedContextLength(DWORD ContextFlags, PDWORD ContextLength);
// DWORD __stdcall RtlInitializeExtendedContext(PVOID Context, DWORD ContextFlags, PCONTEXT_EX *ContextEx);
// PCONTEXT __stdcall RtlLocateLegacyContext(PCONTEXT_EX ContextEx, PDWORD Length);
// NTSTATUS __stdcall NtRaiseException(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context, BOOLEAN SearchFrames);
// int __stdcall EtwEventWriteNoRegistration(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlRegisterWait(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlSetIoCompletionCallback(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlQueueWorkItem(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlDeregisterWait(_DWORD); weak
// NTSTATUS __stdcall NtOpenEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall NtResetWriteWatch(HANDLE ProcessHandle, PVOID BaseAddress, ULONG RegionSize);
// NTSTATUS __stdcall NtGetWriteWatch(HANDLE ProcessHandle, ULONG Flags, PVOID BaseAddress, ULONG RegionSize, PULONG Buffer, PULONG BufferEntries, PULONG Granularity);
// NTSTATUS __stdcall NtMapUserPhysicalPagesScatter(PVOID *BaseAddresses, PULONG NumberOfPages, PULONG PageFrameNumbers);
// NTSTATUS __stdcall NtMapUserPhysicalPages(PVOID BaseAddress, PULONG NumberOfPages, PULONG PageFrameNumbers);
// NTSTATUS __stdcall NtFreeUserPhysicalPages(HANDLE ProcessHandle, PULONG NumberOfPages, PULONG PageFrameNumbers);
// NTSTATUS __stdcall NtAllocateUserPhysicalPages(HANDLE ProcessHandle, PULONG NumberOfPages, PULONG PageFrameNumbers);
// NTSTATUS __stdcall NtUnlockVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, PULONG LockSize, ULONG LockType);
// NTSTATUS __stdcall NtLockVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, PULONG LockSize, ULONG LockType);
// NTSTATUS __stdcall RtlOemStringToUnicodeString(PUNICODE_STRING DestinationString, POEM_STRING SourceString, BOOLEAN AllocateDestinationString);
// int __stdcall RtlSetEnvironmentStrings(_DWORD, _DWORD); weak
// int __stdcall CsrCaptureMessageBuffer(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlComputeImportTableHash(_DWORD, _DWORD, _DWORD); weak
// void *__cdecl _bsearch(const void *Key, const void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// int __stdcall RtlEncodeSystemPointer(_DWORD); weak
// int __stdcall RtlFindCharInUnicodeString(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlNtPathNameToDosPathName(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NtApphelpCacheControl(_DWORD, _DWORD); weak
// ULONG __stdcall RtlRandom(PULONG Seed);
// int __stdcall CsrCaptureMessageMultiUnicodeStringsInPlace(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlFindActivationContextSectionGuid(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlFindActivationContextSectionString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOLEAN __stdcall RtlDoesFileExists_U(PWSTR FileName);
// int __stdcall RtlCreateActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// ULONG _DbgPrintEx(ULONG ComponentId, ULONG Level, PCH Format, ...);
// int __stdcall RtlImageNtHeaderEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlSetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlQueryActivationContextApplicationSettings(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlGetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlQueryInformationActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlMultiAppendUnicodeStringBuffer(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlpEnsureBufferSize(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlpApplyLengthFunction(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlDeactivateActivationContext(_DWORD, _DWORD); weak
// int __stdcall RtlActivateActivationContext(_DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlZombifyActivationContext(_DWORD); weak
// void __stdcall RtlReleaseActivationContext(HANDLE hActCtx);
// void __stdcall RtlAddRefActivationContext(HANDLE hActCtx);
// NTSTATUS __stdcall NtSetInformationJobObject(HANDLE JobHandle, ULONG JobInformationClass, PVOID JobInformation, ULONG JobInformationLength);
// int __stdcall NtCreateJobSet(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtQueryInformationJobObject(HANDLE JobHandle, ULONG JobInfoClass, PVOID JobInformation, ULONG JobInformationLength, PULONG ReturnLength);
// NTSTATUS __stdcall NtTerminateJobObject(HANDLE JobHandle, NTSTATUS ExitStatus);
// NTSTATUS __stdcall NtAssignProcessToJobObject(HANDLE JobHandle, HANDLE ProcessHandle);
// NTSTATUS __stdcall NtOpenJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall NtCreateJobObject(PHANDLE JobHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// int __cdecl _tolower(int C);
// __int32 __cdecl _atol(const char *Str);
// int __cdecl _isdigit(int C);
// int __cdecl _toupper(int C);
// ULONG __stdcall RtlGetCurrentDirectory_U(ULONG MaximumLength, PWSTR Buffer);
// void __stdcall RtlCopyLuid(PLUID DestinationLuid, PLUID SourceLuid);
// void __stdcall RtlFreeOemString(POEM_STRING OemString);
// NTSTATUS __stdcall RtlCreateEnvironment(BOOLEAN Inherit, PVOID *Environment);
// int __stdcall RtlCreateEnvironmentEx(_DWORD, _DWORD, _DWORD); weak
// void __stdcall RtlDestroyEnvironment(PVOID Environment);
// NTSTATUS __stdcall NtQueryEvent(HANDLE EventHandle, EVENT_INFORMATION_CLASS EventInformationClass, PVOID EventInformation, ULONG EventInformationLength, PULONG ResultLength);
// int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// PDEBUG_BUFFER __stdcall RtlCreateQueryDebugBuffer(ULONG Size, BOOLEAN EventPair);
// NTSTATUS __stdcall RtlQueryProcessDebugInformation(ULONG ProcessId, ULONG DebugInfoClassMask, PDEBUG_BUFFER DebugBuffer);
// NTSTATUS __stdcall RtlDestroyQueryDebugBuffer(PDEBUG_BUFFER DebugBuffer);
// NTSTATUS __stdcall NtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG ZeroBits, ULONG CommitSize, PLARGE_INTEGER SectionOffset, PULONG ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Protect);
// NTSTATUS __stdcall NtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress);
// int __stdcall RtlFreeUserStack(_DWORD); weak
// int __stdcall RtlProcessFlsData(_DWORD); weak
// int __stdcall RtlAllocateActivationContextStack(_DWORD); weak
// int __stdcall RtlFreeActivationContextStack(_DWORD); weak
// int __stdcall RtlCreateUserStack(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall TpCaptureCaller(_DWORD); weak
// NTSTATUS __stdcall NtSetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
// NTSTATUS __stdcall NtGetContextThread(HANDLE ThreadHandle, PCONTEXT Context);
// NTSTATUS __stdcall RtlAllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY IdentifierAuthority, CHAR SubAuthorityCount, ULONG SubAuthority0, ULONG SubAuthority1, ULONG SubAuthority2, ULONG SubAuthority3, ULONG SubAuthority4, ULONG SubAuthority5, ULONG SubAuthority6, ULONG SubAuthority7, PSID *Sid);
// void __stdcall RtlFreeSid(PSID Sid);
// NTSTATUS __stdcall NtSignalAndWaitForSingleObject(HANDLE HandleToSignal, HANDLE HandleToWait, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// DWORD __stdcall RtlRunOnceComplete(PRTL_RUN_ONCE RunOnce, DWORD Flags, PVOID Context);
// DWORD __stdcall RtlRunOnceBeginInitialize(PRTL_RUN_ONCE RunOnce, DWORD Flags, PVOID *Context);
// DWORD __stdcall RtlRunOnceExecuteOnce(PRTL_RUN_ONCE RunOnce, PRTL_RUN_ONCE_INIT_FN InitFn, PVOID Parameter, PVOID *Context);
// int __stdcall RtlSleepConditionVariableSRW(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlSleepConditionVariableCS(_DWORD, _DWORD, _DWORD); weak
// int __stdcall NtOpenPrivateNamespace(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NtCreatePrivateNamespace(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NtDeletePrivateNamespace(_DWORD); weak
// int __stdcall RtlInitializeSRWLock(_DWORD); weak
// int __stdcall RtlAddIntegrityLabelToBoundaryDescriptor(_DWORD, _DWORD); weak
// int __stdcall RtlAddSIDToBoundaryDescriptor(_DWORD, _DWORD); weak
// int __stdcall RtlCreateBoundaryDescriptor(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtProtectVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, PULONG ProtectSize, ULONG NewProtect, PULONG OldProtect);
// int __stdcall NtReplacePartitionUnit(_DWORD, _DWORD, _DWORD); weak
// LONG __stdcall RtlCompareUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// void __stdcall RtlRaiseStatus(NTSTATUS Status);
// NTSTATUS __stdcall NtQueryInformationToken(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);
// NTSTATUS __stdcall RtlInitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY IdentifierAuthority, CHAR SubAuthorityCount);
// PULONG __stdcall RtlSubAuthoritySid(PSID Sid, ULONG SubAuthority);
// int __stdcall LdrLoadDll(_DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall LdrGetProcedureAddress(PVOID ModuleImageBase, PANSI_STRING ProcedureName, ULONG ProcedureOrdinal, PVOID *ProcedureAddress);
// NTSTATUS __stdcall LdrUnloadDll(PVOID DllImageBase);
// NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path, PRTL_QUERY_REGISTRY_TABLE QueryTable, PVOID Context, PVOID Environment);
// int __stdcall NtQuerySystemInformationEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlGetNativeSystemInformation(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlDecodeSystemPointer(_DWORD); weak
// ULONG __stdcall RtlxAnsiStringToUnicodeSize(PCANSI_STRING AnsiString);
// BOOLEAN NtIsSystemResumeAutomatic(void);
// NTSTATUS __stdcall NtGetDevicePowerState(HANDLE Device, DEVICE_POWER_STATE *State);
// NTSTATUS __stdcall NtSetThreadExecutionState(EXECUTION_STATE esFlags, EXECUTION_STATE *PreviousFlags);
// NTSTATUS __stdcall NtInitiatePowerAction(POWER_ACTION SystemAction, SYSTEM_POWER_STATE MinSystemState, ULONG Flags, BOOLEAN Asynchronous);
// NTSTATUS __stdcall NtPowerInformation(POWER_INFORMATION_LEVEL InformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// NTSTATUS __stdcall NtSetVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG BufferLength, FS_INFORMATION_CLASS VolumeInformationClass);
// NTSTATUS __stdcall RtlQueryEnvironmentVariable_U(PVOID Environment, PUNICODE_STRING Name, PUNICODE_STRING Value);
// ULONG __stdcall RtlGetFullPathName_U(WCHAR *dosname, ULONG size, WCHAR *buf, WCHAR **shortname);
// BOOLEAN __stdcall RtlIsNameLegalDOS8Dot3(PUNICODE_STRING Name, POEM_STRING OemName, PBOOLEAN NameContainsSpaces);
// int __stdcall RtlGetCurrentProcessorNumberEx(_DWORD); weak
// NTSTATUS __stdcall NtOpenThreadToken(HANDLE ThreadHandle, ACCESS_MASK DesiredAccess, BOOLEAN OpenAsSelf, PHANDLE TokenHandle);
// NTSTATUS __stdcall NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength);
// int __stdcall LdrLoadAlternateResourceModuleEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall LdrLoadAlternateResourceModule(_DWORD, _DWORD); weak
// int __stdcall LdrpResGetMappingSize(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall LdrRscIsTypeExist(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall LdrFindResource_U(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __strcmpi(const char *, const char *);
// int __stdcall RtlAcquireSRWLockShared(_DWORD); weak
// int __stdcall RtlReleaseSRWLockShared(_DWORD); weak
// char *__cdecl _strchr(const char *Str, int Val);
// NTSTATUS __stdcall RtlInitAnsiStringEx(PANSI_STRING DestinationString, PCSZ SourceString);
// void __stdcall RtlCreateUnicodeString(PUNICODE_STRING AllocatedString, PCWSTR SourceString);
// WCHAR __stdcall RtlUpcaseUnicodeChar(WCHAR SourceCharacter);
// unsigned __int32 __cdecl _wcstoul(const wchar_t *Str, wchar_t **EndPtr, int Radix);
// int __stdcall LdrGetFileNameFromLoadAsDataTable(_DWORD, _DWORD); weak
// wchar_t *__cdecl _wcsrchr(const wchar_t *Str, wchar_t Ch);
// NTSTATUS __stdcall NtQueryVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, ULONG MemoryInformationLength, PULONG ReturnLength);
// int __stdcall RtlCultureNameToLCID(_DWORD, _DWORD); weak
// int __stdcall LdrResFindResourceDirectory(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall LdrResFindResource(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall LdrpResGetResourceDirectory(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// PVOID __stdcall RtlImageDirectoryEntryToData(PVOID ImageBase, BOOLEAN MappedAsImage, USHORT DirectoryEntry, PULONG Size);
// int __stdcall LdrResGetRCConfig(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall RtlVerifyVersionInfo(PRTL_OSVERSIONINFOEXW VersionInfo, ULONG TypeMask, ULONGLONG ConditionMask);
// BOOLEAN __stdcall RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType);
// int __stdcall RtlLcidToLocaleName(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlGetUILanguageInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtCreateMailslotFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG CreateOptions, ULONG Unknown, ULONG MaxMessageSize, PLARGE_INTEGER ReadTimeout);
// LARGE_INTEGER __stdcall RtlExtendedLargeIntegerDivide(LARGE_INTEGER Dividend, ULONG Divisor, PULONG Remainder);
// int __cdecl __stricmp(const char *, const char *);
// int __stdcall RtlEncodePointer(_DWORD); weak
// int __stdcall RtlAcquireSRWLockExclusive(_DWORD); weak
// int __stdcall RtlReleaseSRWLockExclusive(_DWORD); weak
// int __stdcall LdrQueryImageFileExecutionOptions(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// PIMAGE_NT_HEADERS __stdcall RtlImageNtHeader(PVOID ImageBase);
// int __stdcall RtlSetUserValueHeap(_DWORD, _DWORD, _DWORD, _DWORD); weak
// PVOID __stdcall RtlReAllocateHeap(HANDLE HeapHandle, ULONG Flags, PVOID Address, ULONG Size);
// int __stdcall RtlAllocateHandle(_DWORD, _DWORD); weak
// int __stdcall RtlFreeHandle(_DWORD, _DWORD); weak
// int __stdcall RtlDeregisterSecureMemoryCacheCallback(_DWORD); weak
// int __stdcall RtlRegisterSecureMemoryCacheCallback(_DWORD); weak
// ULONG __stdcall RtlCompactHeap(HANDLE HeapHandle, ULONG Flags);
// ULONG __stdcall RtlSizeHeap(HANDLE HeapHandle, ULONG Flags, PVOID Address);
// int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOLEAN __stdcall RtlLockHeap(HANDLE HeapHandle);
// int __stdcall RtlIsValidHandle(_DWORD, _DWORD); weak
// BOOLEAN __stdcall RtlUnlockHeap(HANDLE HeapHandle);
// NTSTATUS __stdcall NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
// void __stdcall RtlInitString(PSTRING DestinationString, PCSZ SourceString);
// int __stdcall NtSetSystemEnvironmentValueEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall RtlGUIDFromString(PUNICODE_STRING GuidString, GUID *Guid);
// int __stdcall NtQuerySystemEnvironmentValueEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtFlushBuffersFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);
// _DWORD __stdcall RtlGetLastNtStatus(); weak
// int __stdcall RtlDosPathNameToNtPathName_U_WithStatus(_DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOLEAN __stdcall RtlEqualSid(PSID Sid1, PSID Sid2);
// NTSTATUS __stdcall RtlQueryInformationAcl(PACL Acl, PVOID AclInformation, ULONG Length, ACL_INFORMATION_CLASS AclInformationClass);
// NTSTATUS __stdcall RtlGetAce(PACL Acl, ULONG AceIndex, PVOID *Ace);
// NTSTATUS __stdcall NtRaiseHardError(NTSTATUS Status, ULONG NumberOfArguments, ULONG StringArgumentsMask, PULONG Arguments, ULONG MessageBoxType, PULONG MessageBoxResult);
// NTSTATUS __stdcall NtQueryVolumeInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID VolumeInformation, ULONG VolumeInformationLength, FS_INFORMATION_CLASS VolumeInformationClass);
// int __stdcall LdrAddRefDll(_DWORD, _DWORD); weak
// int __stdcall NtCreateKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// ULONG __stdcall RtlDetermineDosPathNameType_U(PWSTR Path);
// int __cdecl __vsnwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, va_list Args);
// NTSTATUS __stdcall RtlUnicodeStringToOemString(POEM_STRING DestinationString, PUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString);
// int __stdcall RtlWow64EnableFsRedirection(_DWORD); weak
// NTSTATUS __stdcall NtCancelIoFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock);
// int __stdcall NtCancelSynchronousIoFile(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtNotifyChangeDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_NOTIFY_INFORMATION Buffer, ULONG BufferLength, ULONG NotifyFilter, BOOLEAN WatchSubtree);
// int __fastcall RtlActivateActivationContextUnsafeFast(_DWORD, _DWORD); weak
// int __thiscall RtlDeactivateActivationContextUnsafeFast(_DWORD); weak
// NTSTATUS __stdcall NtQueryDirectoryFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass, BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan);
// NTSTATUS __stdcall NtWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// _DWORD __stdcall RtlGetThreadErrorMode(); weak
// int __stdcall RtlSetThreadErrorMode(_DWORD, _DWORD); weak
// int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD); weak
// NTSTATUS __stdcall NtOpenProcessToken(HANDLE ProcessHandle, ACCESS_MASK DesiredAccess, PHANDLE TokenHandle);
// DWORD __stdcall RtlNtStatusToDosErrorNoTeb(NTSTATUS StatusCode);
// int __stdcall EtwEventRegister(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall EtwEventWrite(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall EtwEventUnregister(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER SectionSize, ULONG Protect, ULONG Attributes, HANDLE FileHandle);
// NTSTATUS __stdcall RtlGetVersion(PRTL_OSVERSIONINFOW lpVersionInformation);
// int __stdcall RtlQueryElevationFlags(_DWORD); weak
// NTSTATUS __stdcall NtSetInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength);
// NTSTATUS __stdcall RtlCharToInteger(PCSZ String, ULONG Base, PULONG Value);
// int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD); weak
// int __stdcall CsrCaptureMessageString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall CsrFreeCaptureBuffer(_DWORD); weak
// ULONG RtlGetLongestNtPathLength(void);
// BOOLEAN __stdcall RtlEqualString(const STRING *String1, const STRING *String2, BOOLEAN CaseInSensitive);
// void __stdcall RtlFreeAnsiString(PANSI_STRING AnsiString);
// void __stdcall RtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
// BOOLEAN __stdcall RtlDosPathNameToNtPathName_U(PWSTR dosname, PUNICODE_STRING ntname, PWSTR *shortname, PCURDIR nah);
// NTSTATUS __stdcall NtLockFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PULARGE_INTEGER LockOffset, PULARGE_INTEGER LockLength, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock);
// NTSTATUS __stdcall NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
// int __stdcall RtlIsTextUnicode(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName);
// NTSTATUS __stdcall NtEnumerateKey(HANDLE KeyHandle, ULONG Index, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG KeyInformationLength, PULONG ResultLength);
// int __stdcall RtlFormatCurrentUserKeyPath(_DWORD); weak
// NTSTATUS __stdcall RtlAppendUnicodeToString(PUNICODE_STRING Destination, PCWSTR Source);
// NTSTATUS __stdcall RtlAppendUnicodeStringToString(PUNICODE_STRING Destination, PCUNICODE_STRING Source);
// BOOLEAN __stdcall RtlPrefixUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// int __stdcall CsrVerifyRegion(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtAllocateVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, ULONG ZeroBits, PULONG AllocationSize, ULONG AllocationType, ULONG Protect);
// NTSTATUS __stdcall NtWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
// NTSTATUS __stdcall NtFreeVirtualMemory(HANDLE ProcessHandle, PVOID *BaseAddress, PULONG FreeSize, ULONG FreeType);
// NTSTATUS __stdcall NtUnlockFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PULARGE_INTEGER LockOffset, PULARGE_INTEGER LockLength, ULONG Key);
// NTSTATUS __stdcall NtEnumerateValueKey(HANDLE KeyHandle, ULONG Index, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG KeyValueInformationLength, PULONG ResultLength);
// NTSTATUS __stdcall RtlMultiByteToUnicodeSize(PULONG UnicodeSize, PCHAR MbString, ULONG MbSize);
// NTSTATUS __stdcall RtlUnicodeToMultiByteN(PCHAR MbString, ULONG MbSize, PULONG ResultSize, PWCHAR UnicodeString, ULONG UnicodeSize);
// NTSTATUS __stdcall RtlMultiByteToUnicodeN(PWCHAR UnicodeString, ULONG UnicodeSize, PULONG ResultSize, PCHAR MbString, ULONG MbSize);
// int __stdcall RtlQueryAtomInAtomTable(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtQueryInformationAtom(USHORT Atom, ATOM_INFORMATION_CLASS AtomInformationClass, PVOID AtomInformation, ULONG AtomInformationLength, PULONG ReturnLength);
// int __stdcall RtlDeleteAtomFromAtomTable(_DWORD, _DWORD); weak
// NTSTATUS __stdcall NtDeleteAtom(USHORT Atom);
// int __stdcall RtlLookupAtomInAtomTable(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtFindAtom(PWSTR String, ULONG StringLength, PUSHORT Atom);
// int __stdcall RtlAddAtomToAtomTable(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtAddAtom(PWSTR String, ULONG StringLength, PUSHORT Atom);
// int __stdcall RtlCreateAtomTable(_DWORD, _DWORD); weak
// int __stdcall RtlDestroyAtomTable(_DWORD); weak
// int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlReleaseRelativeName(_DWORD); weak
// BOOLEAN __stdcall RtlEqualUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// ULONG __stdcall RtlIsDosDeviceName_U(PWSTR DeviceName);
// NTSTATUS __stdcall NtFlushInstructionCache(HANDLE ProcessHandle, PVOID BaseAddress, ULONG FlushSize);
// NTSTATUS __stdcall NtQueryInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength, PULONG ReturnLength);
// _DWORD __stdcall CsrGetProcessId(); weak
// NTSTATUS __stdcall NtOpenProcess(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PCLIENT_ID ClientId);
// NTSTATUS __stdcall NtSetSystemTime(PLARGE_INTEGER NewTime, PLARGE_INTEGER OldTime);
// int __stdcall RtlReleasePrivilege(_DWORD); weak
// int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlCutoverTimeToSystemTime(_DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtSetSystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength);
// BOOLEAN __stdcall RtlTimeFieldsToTime(PTIME_FIELDS TimeFields, PLARGE_INTEGER Time);
// void __stdcall RtlTimeToTimeFields(PLARGE_INTEGER Time, PTIME_FIELDS TimeFields);
// NTSTATUS __stdcall NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
// int __cdecl __wcsicmp(const wchar_t *, const wchar_t *);
// BOOLEAN __stdcall RtlPrefixString(PSTRING String1, PSTRING String2, BOOLEAN CaseInSensitive);
// wchar_t *__cdecl _wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// wchar_t *__cdecl _wcschr(const wchar_t *Str, wchar_t Ch);
// BOOLEAN __stdcall RtlCreateUnicodeStringFromAsciiz(PUNICODE_STRING Destination, PCSZ Source);
// void __stdcall RtlInitAnsiString(PANSI_STRING DestinationString, PCSZ SourceString);
// NTSTATUS __stdcall RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString, PCANSI_STRING SourceString, BOOLEAN AllocateDestinationString);
// NTSTATUS __stdcall RtlInitUnicodeStringEx(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// ULONG __stdcall RtlxUnicodeStringToAnsiSize(PUNICODE_STRING UnicodeString);
// NTSTATUS __stdcall RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString, PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString);
// void __stdcall RtlEnterCriticalSection(PRTL_CRITICAL_SECTION CriticalSectionObject);
// void __stdcall RtlLeaveCriticalSection(PRTL_CRITICAL_SECTION CriticalSectionObject);
// ULONG __stdcall RtlNtStatusToDosError(NTSTATUS NtStatus);
// int __stdcall RtlDnsHostNameToComputerName(_DWORD, _DWORD, _DWORD); weak
// void __stdcall RtlFreeUnicodeString(PUNICODE_STRING UnicodeString);
// NTSTATUS __stdcall RtlUnicodeToMultiByteSize(PULONG MbSize, PWCHAR UnicodeString, ULONG UnicodeSize);
// size_t __cdecl _wcscspn(const wchar_t *Str, const wchar_t *Control);
// void *__cdecl _memmove(void *Dst, const void *Src, size_t Size);
// int __cdecl __memicmp(const void *, const void *, unsigned int);
// NTSTATUS __stdcall NtCreateKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class, ULONG CreateOptions, PULONG Disposition);
// NTSTATUS __stdcall NtSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
// NTSTATUS __stdcall NtFlushKey(HANDLE KeyHandle);
// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// NTSTATUS __stdcall NtOpenKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall NtQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG KeyValueInformationLength, PULONG ResultLength);
// NTSTATUS __stdcall NtClose(HANDLE Handle);
// NTSTATUS __stdcall RtlDeleteCriticalSection(PRTL_CRITICAL_SECTION CriticalSectionObject);
// NTSTATUS __stdcall RtlInitializeCriticalSection(PRTL_CRITICAL_SECTION CriticalSectionObject);
// int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtSetInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass);
// NTSTATUS __stdcall NtSetSecurityObject(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall NtSetEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PFILE_FULL_EA_INFORMATION Buffer, ULONG BufferLength);
// NTSTATUS __stdcall NtQuerySecurityObject(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG SecurityDescriptorLength, PULONG ReturnLength);
// ULONG __stdcall RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor);
// NTSTATUS __stdcall NtQueryEaFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PFILE_FULL_EA_INFORMATION Buffer, ULONG BufferLength, BOOLEAN ReturnSingleEntry, PFILE_GET_EA_INFORMATION EaList, ULONG EaListLength, PULONG EaIndex, BOOLEAN RestartScan);
// NTSTATUS __stdcall NtQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass);
// NTSTATUS __stdcall NtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
// int __cdecl __wcsnicmp(const wchar_t *, const wchar_t *, size_t);
// NTSTATUS __stdcall NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// NTSTATUS __stdcall NtFsControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG FsControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// int __stdcall RtlSetLastWin32Error(_DWORD); weak
// PVOID __stdcall RtlAllocateHeap(HANDLE HeapHandle, ULONG Flags, ULONG Size);
// NTSTATUS __stdcall RtlCreateAcl(PACL Acl, ULONG AclLength, USHORT AclRevision);
// NTSTATUS __stdcall RtlAddAccessAllowedAce(PACL Acl, USHORT AceRevision, ACCESS_MASK AccessMask, PSID Sid);
// NTSTATUS __stdcall RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// NTSTATUS __stdcall RtlSetOwnerSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID Owner, BOOLEAN OwnerDefaulted);
// NTSTATUS __stdcall RtlSetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID Group, BOOLEAN GroupDefaulted);
// NTSTATUS __stdcall RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// BOOLEAN __stdcall RtlFreeHeap(HANDLE HeapHandle, ULONG Flags, PVOID Address);
// int __stdcall RtlInitializeExceptionChain(_DWORD); weak
// NTSTATUS __stdcall NtOpenDirectoryObject(PHANDLE DirectoryHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// NTSTATUS __stdcall NtQuerySymbolicLinkObject(HANDLE SymbolicLinkHandle, PUNICODE_STRING TargetName, PULONG ReturnLength);
// NTSTATUS __stdcall NtOpenSymbolicLinkObject(PHANDLE SymbolicLinkHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// wchar_t *__cdecl _wcspbrk(const wchar_t *Str, const wchar_t *Control);
// void __stdcall RtlDestroyProcessParameters(PRTL_USER_PROCESS_PARAMETERS ProcessParameters);
// int __stdcall RtlCreateProcessParametersEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtResumeThread(HANDLE ThreadHandle, PULONG PreviousSuspendCount);
// int __stdcall LdrQueryImageFileKeyOption(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NtCreateUserProcess(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlGetFullPathName_UstrEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall RtlDecodePointer(_DWORD); weak
// int __stdcall RtlKnownExceptionFilter(_DWORD); weak
// int __stdcall CsrClientConnectToServer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtWaitForMultipleObjects(ULONG HandleCount, PHANDLE Handles, WAIT_TYPE WaitType, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// NTSTATUS NtYieldExecution(void);
// void __stdcall RtlRaiseException(PEXCEPTION_RECORD ExceptionRecord);
// NTSTATUS __stdcall NtRequestWaitReplyPort(HANDLE PortHandle, PPORT_MESSAGE RequestMessage, PPORT_MESSAGE ReplyMessage);
// ULONG __stdcall RtlDestroyHeap(HANDLE HeapHandle);
// HANDLE __stdcall RtlCreateHeap(ULONG Flags, PVOID BaseAddress, ULONG SizeToReserve, ULONG SizeToCommit, PVOID Unknown, PRTL_HEAP_DEFINITION Definition);
// NTSTATUS __stdcall NtConnectPort(PHANDLE PortHandle, PUNICODE_STRING PortName, PSECURITY_QUALITY_OF_SERVICE SecurityQos, PPORT_SECTION_WRITE WriteSection, PPORT_SECTION_READ ReadSection, PULONG MaxMessageSize, PVOID ConnectData, PULONG ConnectDataLength);
// int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtQueryKey(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation, ULONG KeyInformationLength, PULONG ResultLength);
// int __stdcall NtOpenKeyEx(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NtOpenKeyTransactedEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOLEAN __stdcall RtlValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptorInput, ULONG SecurityDescriptorLength, SECURITY_INFORMATION RequiredInformation);
// NTSTATUS __stdcall NtDeleteKey(HANDLE KeyHandle);
// NTSTATUS __stdcall NtLoadKey(POBJECT_ATTRIBUTES KeyObjectAttributes, POBJECT_ATTRIBUTES FileObjectAttributes);
// NTSTATUS __stdcall NtUnloadKey(POBJECT_ATTRIBUTES KeyObjectAttributes);
// NTSTATUS __stdcall NtNotifyChangeMultipleKeys(HANDLE KeyHandle, ULONG Flags, POBJECT_ATTRIBUTES KeyObjectAttributes, HANDLE EventHandle, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG NotifyFilter, BOOLEAN WatchSubtree, PVOID Buffer, ULONG BufferLength, BOOLEAN Asynchronous);
// NTSTATUS __stdcall NtRestoreKey(HANDLE KeyHandle, HANDLE FileHandle, ULONG Flags);
// int __stdcall NtSaveKeyEx(_DWORD, _DWORD, _DWORD); weak
// ULONG __stdcall RtlLengthSid(PSID Sid);
// int __stdcall RtlMakeSelfRelativeSD(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtDuplicateToken(HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, BOOLEAN EffectiveOnly, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle);
// int __stdcall RtlWerpReportException(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall RtlTryAcquirePebLock(); weak
// void RtlReleasePebLock(void);
// NTSTATUS __stdcall NtClearEvent(HANDLE EventHandle);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// int __stdcall LdrUnlockLoaderLock(_DWORD, _DWORD); weak
// int __thiscall LdrLockLoaderLock(_DWORD, _DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtAccessCheck(PSECURITY_DESCRIPTOR SecurityDescriptor, HANDLE TokenHandle, ACCESS_MASK DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, PULONG PrivilegeSetLength, PACCESS_MASK GrantedAccess, PBOOLEAN AccessStatus);
// ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, ULONG TypeMask, UCHAR Condition);
// int __stdcall RtlExitUserThread(_DWORD); weak
// int __stdcall RtlExitUserProcess(_DWORD); weak
// NTSTATUS __stdcall NtWriteVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferLength, PULONG ReturnLength);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// DWORD __stdcall GetLastError();
// void __stdcall SetLastError(DWORD dwErrCode);
void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// void __stdcall Sleep(DWORD dwMilliseconds);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
LSTATUS __stdcall RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile);
ULONG __stdcall LocalBaseRegLoadKey(PVOID Address, int a2, int a3);
BOOL __stdcall InitAtomTable(DWORD nSize);
HANDLE __stdcall CreateEventExWStub(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// HANDLE __stdcall CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
signed int __stdcall sub_77E00074(int a1, int a2, int a3);
signed int __cdecl DtcGetTransactionManagerExW(unsigned __int16 *a1, unsigned __int16 *a2, const struct _GUID *a3, unsigned __int32 a4, void *a5, void **a6);
signed int __stdcall sub_77E000D9(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E00155(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// char *__cdecl _strlwr(char *String);
// char *__cdecl strncat(char *Dest, const char *Source, size_t Count);
int __stdcall LookupHandlerByName(const char *a1, const struct _DLOAD_PROCNAME_MAP *a2);
char **__stdcall FindDll(const char *Source);
int __stdcall DelayLoadFailureHook(char *a1, char *a2);
int __stdcall LookupHandler(char *Source, char *); // idb
signed int __stdcall FveCloseVolume(int a1);
signed int __stdcall KccGetFailureCache(unsigned __int32 a1, struct _DS_REPL_KCC_DSA_FAILURESW **a2);
signed int __stdcall RasSetDeviceConfigInfo(int a1, int a2, int a3, int a4);
const unsigned __int16 *__stdcall MapSpnServiceClass(unsigned __int16 *); // idb
HRESULT __stdcall PSPropertyBag_WriteLONG(IPropertyBag *propBag, LPCWSTR propName, LONG value);
signed int __stdcall GetServerEapAuthRequestPacket(int a1, int a2, int a3);
signed int __stdcall FmsDeactivateFonts(int a1, int a2, int a3, int a4);
signed int __stdcall RegWdQueryW(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall Urlmon_CleanIETldListCache();
signed int __stdcall SHGetUserPicturePathEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_77E0A94D(int a1, int a2, int a3);
signed int __stdcall UrlmonCreateInstance(const struct _GUID *a1, struct IUnknown *a2, const struct _GUID *a3, void **a4);
BOOL __stdcall EnumSystemLanguageGroupsWStub(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);
// BOOL __stdcall EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);
int __stdcall ReOpenFile(int, int, ULONG ShareAccess, HANDLE FileHandle); // idb
BOOL __stdcall WriteFileGatherStub(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
BOOL __stdcall ReadFileScatterStub(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);
BOOL __stdcall SetFileValidDataStub(HANDLE hFile, LONGLONG ValidDataLength);
// BOOL __stdcall SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength);
HANDLE __stdcall SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo);
signed int __stdcall BaseInitAppcompatCacheSupport();
signed int __stdcall BasepShimCacheInitTempDirs();
BOOL __stdcall SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);
BOOL __stdcall ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill);
signed int __stdcall ScrollConsoleScreenBufferInternal(int a1, int a2, int a3, int a4, int a5, char a6);
BOOL __stdcall HeapLockStub(HANDLE hHeap);
// BOOL __stdcall HeapLock(HANDLE hHeap);
BOOL __stdcall HeapUnlockStub(HANDLE hHeap);
// BOOL __stdcall HeapUnlock(HANDLE hHeap);
BOOL __stdcall HeapWalkStub(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry);
// BOOL __stdcall HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry);
int __stdcall LocalOpenPerformanceText(int a1, int a2, int a3);
BOOL __stdcall SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags);
UINT __stdcall GetSystemWindowsDirectoryAStub(LPSTR lpBuffer, UINT uSize);
UINT __stdcall GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
int __stdcall GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, int); // idb
int __stdcall CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, int, int, int); // idb
int __stdcall DeleteFileTransactedW(LPCWSTR lpFileName, int); // idb
HANDLE __stdcall CreateWaitableTimerExWStub(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
__int16 __stdcall GetMaximumProcessorGroupCount();
int __stdcall SetThreadGroupAffinity(HANDLE ThreadHandle, PVOID, int); // idb
BOOL __stdcall GetLogicalProcessorInformationStub(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
// BOOL __stdcall GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);
int __stdcall RegDeleteTreeW(HKEY hKey, PCWSTR SourceString); // idb
HANDLE __stdcall CreateSemaphoreExWStub(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
signed int __stdcall CalcClientTimeZoneIdAndBias(int a1, int a2);
signed int __stdcall SetClientTimeZoneInformation(int a1);
signed int __stdcall SetClientDynamicTimeZoneInformation(int a1);
signed int __stdcall CsrBasepSetClientTimeZoneInformation(int a1, int a2, int a3);
BOOL __stdcall FindNextVolumeWStub(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
BOOL __stdcall FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
HANDLE __stdcall FindFirstVolumeWStub(LPWSTR lpszVolumeName, DWORD cchBufferLength);
HANDLE __stdcall FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength);
BOOL __stdcall FindVolumeCloseStub(HANDLE hFindVolume);
BOOL __stdcall FindVolumeClose(HANDLE hFindVolume);
ULONG __stdcall LocalOpenCurrentConfig(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);
HANDLE __stdcall CreateNamedPipeWStub(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE __stdcall CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL __stdcall ConnectNamedPipeStub(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);
DWORD __stdcall GetDynamicTimeZoneInformationStub(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
// DWORD __stdcall GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
BOOL __stdcall EnumUILanguagesWStub(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam);
// BOOL __stdcall EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam);
int __stdcall loc_77E12EFA(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
// UINT __stdcall GetErrorMode();
HANDLE __stdcall OpenPrivateNamespaceW(int a1, HANDLE Handle);
BOOL __stdcall SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds);
DWORD __stdcall GetLogicalDriveStringsWStub(DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD __stdcall GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer);
int __stdcall GetSystemDefaultLocaleNameStub(LPWSTR lpLocaleName, int cchLocaleName);
// int __stdcall GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName);
int __stdcall BuildSubSysCommandLine(int, int, int, int, PUNICODE_STRING UnicodeString); // idb
LSTATUS __stdcall RegFlushKey(HKEY hKey);
ULONG __stdcall LocalBaseRegFlushKey(HANDLE KeyHandle);
int __stdcall WerpHeapGetBlockFromFreeList(struct _WER_HEAP_MAIN_HEADER *a1, unsigned __int32 a2);
PTP_POOL __stdcall CreateThreadpoolStub(PVOID reserved);
PTP_POOL __stdcall CreateThreadpool(PVOID reserved);
BOOL __stdcall SetThreadpoolThreadMinimumStub(PTP_POOL ptpp, DWORD cthrdMic);
BOOL __stdcall SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic);
PTP_IO __stdcall CreateThreadpoolIoStub(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
PTP_IO __stdcall CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
BOOLEAN __stdcall BasepTpIoFinalizationCallback(int a1, PVOID Address);
HANDLE __stdcall CreateActCtxA(PCACTCTXA pActCtx);
int __stdcall sub_77E13B12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
// void __userpurge sub_77E13B3A(int a1@<eax>, int a2@<ebx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
signed int __stdcall _DeleteElement(struct _WER_PEB_HEADER_BLOCK *a1, struct _WER_GATHER *a2, struct _WER_GATHER *a3);
int __stdcall WerpHeapFree(struct _WER_HEAP_MAIN_HEADER *, void *); // idb
BOOL __stdcall sub_77E13D4A(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
BOOL __stdcall GetDiskFreeSpaceWStub(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// BOOL __stdcall GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
int __stdcall WerpRegisterRestart(unsigned __int16 *, int); // idb
HRESULT __stdcall RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags);
BOOL __stdcall GetFileMUIPathStub(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator);
// BOOL __stdcall GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator);
char __stdcall BasepAddPrefixAlias(int a1, int a2, char a3);
int __stdcall BasepFindPrefixAlias(PCUNICODE_STRING String2); // idb
HANDLE __stdcall CreatePrivateNamespaceW(int a1, int a2, HANDLE Handle);
char __stdcall ClosePrivateNamespace(HANDLE Handle, char a2);
int __stdcall BasepFindPrefixAliasByHandle(int a1);
HANDLE __stdcall RegisterWaitForSingleObjectEx(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
LSTATUS __stdcall RegDisablePredefinedCacheEx();
PTP_WAIT __stdcall CreateThreadpoolWaitStub(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
PTP_WAIT __stdcall CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
HANDLE __stdcall CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);
HANDLE __stdcall CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
int __stdcall RegGetValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, int, int, void *Dst, size_t Size); // idb
int __stdcall QueryValueInternalA(HKEY hKey, LPCSTR lpValueName, int, int, LPBYTE lpData, DWORD Type); // idb
HANDLE __stdcall CreateEventExAStub(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// HANDLE __stdcall CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
DWORD __stdcall WTSGetActiveConsoleSessionId();
// void __usercall sub_77E1463A(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4@<ebp>, int a5@<esi>);
BOOL __stdcall GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation);
signed int __stdcall GetNLSVersionHelper(int a1, int a2, int a3);
BOOL __stdcall SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout);
DWORD __stdcall GetActiveProcessorCount(WORD GroupNumber);
signed int __stdcall GetProcessorGroupInformation(int a1, int a2);
// BOOL __stdcall GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength);
DWORD __stdcall QueryDosDeviceWStub(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);
// DWORD __stdcall QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);
int __stdcall BasepDisableLocalFileBuffering(HANDLE FileHandle); // idb
int __stdcall BasepRemoteIsSMBv1(HANDLE FileHandle); // idb
int __stdcall BasepEnableRemotePrefetch(HANDLE FileHandle); // idb
LSTATUS __stdcall RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
int __stdcall LocalBaseRegSetKeySecurity(HANDLE Handle, SECURITY_INFORMATION RequiredInformation, int); // idb
BOOL __stdcall GetQueuedCompletionStatusStub(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// BOOL __stdcall GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
BOOL __stdcall PostQueuedCompletionStatusStub(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
HANDLE __stdcall OpenFileById(int a1, int a2, HANDLE FileHandle, ULONG ShareAccess, int a5, int a6);
DWORD __stdcall GetFinalPathNameByHandleWStub(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
// DWORD __stdcall GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
SIZE_T __stdcall VirtualQueryExStub(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// SIZE_T __stdcall VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
BOOL __stdcall CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent);
BOOL __stdcall SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);
void __stdcall DisablePredefinedHandleTableInternal(unsigned int a1);
void __stdcall DisablePredefinedHandleTableForIndex(int a1);
int __stdcall GetLocaleInfoExStub(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// int __stdcall GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData);
LPVOID __stdcall CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);
int __stdcall BaseInitializeFiberContext(int a1, int a2, int a3, int a4);
void __stdcall __noreturn BaseFiberStart();
LPVOID __stdcall ConvertThreadToFiber(LPVOID lpParameter);
LPVOID __stdcall ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags);
void __stdcall DeleteFiber(LPVOID lpFiber);
BOOL __stdcall ConvertFiberToThread();
// int __stdcall LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags);
int __stdcall LCIDToLocaleNameStub(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags);
BOOL __stdcall GetSystemPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// BOOL __stdcall GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
int __stdcall ResolveLocaleNameStub(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName);
// int __stdcall ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName);
BOOL __stdcall IsNLSDefinedStringStub(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr);
// BOOL __stdcall IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr);
signed int __stdcall SortIsDefinedString(int a1, int a2, int a3, void *a4, signed int a5);
signed int __fastcall IsSortingCodePointDefined(signed int *a1, int a2);
BOOL __stdcall TerminateJobObject(HANDLE hJob, UINT uExitCode);
HANDLE __stdcall CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
BOOL __stdcall SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength);
NTSTATUS __stdcall BaseGetNamedObjectDirectory(int a1);
BOOL __stdcall RemoveDirectoryWStub(LPCWSTR lpPathName);
// BOOL __stdcall RemoveDirectoryW(LPCWSTR lpPathName);
BOOL __stdcall CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
BOOL __stdcall AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess);
BOOL __stdcall UnregisterWaitExStub(HANDLE WaitHandle, HANDLE CompletionEvent);
// BOOL __stdcall UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);
BOOL __stdcall ChangeTimerQueueTimerStub(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// BOOL __stdcall ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
HANDLE __stdcall CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HANDLE __stdcall CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
DWORD __stdcall GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
NTSTATUS __stdcall BaseDllReadSectionNames(int a1);
BOOL __stdcall DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize);
BOOL __stdcall TzSpecificLocalTimeToSystemTimeStub(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
// BOOL __stdcall TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
int __stdcall BasepTpIoCallback(int a1, int a2, int a3, int a4, int a5);
BOOL __stdcall TrySubmitThreadpoolCallbackStub(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
BOOL __stdcall TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
BOOL __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
int __stdcall K32GetModuleInformation(HANDLE ProcessHandle, int Buffer, int, int); // idb
int __stdcall K32GetMappedFileNameA(HANDLE ProcessHandle, PVOID BaseAddress, LPSTR lpMultiByteStr, int cbMultiByte); // idb
unsigned int __stdcall K32GetMappedFileNameW(HANDLE ProcessHandle, PVOID BaseAddress, void *Dst, int a4);
BOOL __stdcall GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize);
BOOL __stdcall GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags);
int __stdcall K32GetPerformanceInfo(int, ULONG SystemInformationLength); // idb
int __stdcall SetProcessDEPPolicy(int ProcessInformation); // idb
HRESULT __stdcall StringCbCopyW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc);
HRESULT __stdcall StringCbCatW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc);
HANDLE __stdcall CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags);
BOOL __stdcall AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid);
int __stdcall BaseDllReadSection(STRING *String1); // idb
int __stdcall RegDeleteKeyExInternalW(HANDLE, int, int, int, int); // idb
ULONG __stdcall LocalBaseRegDeleteKeyEx(HANDLE a1, HANDLE KeyHandle, int a3, int a4, int a5);
LSTATUS __stdcall RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
DWORD __stdcall GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
BOOL __stdcall CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
BOOL __stdcall GetStringTypeAStub(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
signed int __stdcall NullTerminateRegMultiSzString(int a1, int *a2, unsigned int a3, signed int a4, char a5);
// HANDLE __stdcall CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
HANDLE __stdcall CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);
// int __stdcall GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue);
void __stdcall OutputDebugStringWStub(LPCWSTR lpOutputString);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
signed int __stdcall BasepUnicodeToAnsi(PCWSTR a1, CHAR *a2, unsigned int *a3, int a4);
HANDLE __stdcall FindFirstChangeNotificationWStub(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
// HANDLE __stdcall FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
BOOL __stdcall FindNextChangeNotificationStub(HANDLE hChangeHandle);
// BOOL __stdcall FindNextChangeNotification(HANDLE hChangeHandle);
NTSTATUS __stdcall BaseDllAppendNullToResultBuffer(int a1);
ULONG __stdcall MapSAToRpcSA(int a1, int a2);
BOOL __stdcall GetExitCodeThreadStub(HANDLE hThread, LPDWORD lpExitCode);
// BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);
UINT __stdcall GetTempFileNameWStub(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
// int __stdcall BaseGetProcessExePath(_DWORD, _DWORD); weak
// int __stdcall BaseReleaseProcessExePath(_DWORD, _DWORD); weak
ATOM __stdcall AddAtomA(LPCSTR lpString);
int __stdcall GetLocaleNullStringFromArrayInPoolTestArray(int a1, int a2, unsigned int a3);
BOOL __stdcall LocalFileTimeToFileTimeStub(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
// BOOL __stdcall LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
DWORD __stdcall GetCurrentDirectoryAStub(DWORD nBufferLength, LPSTR lpBuffer);
// DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
// void __userpurge sub_77E176F2(int a1@<eax>, int a2@<ebp>, int a3@<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13);
BOOL __stdcall SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);
BOOL __stdcall SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags);
DWORD __stdcall GetProcessVersionStub(DWORD ProcessId);
BOOL __stdcall GetHandleInformationImplementation(HANDLE hObject, LPDWORD lpdwFlags);
// BOOL __stdcall GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags);
HRESULT __stdcall WerSetFlags(DWORD dwFlags);
signed int __stdcall WerpSetFlags(int a1);
NTSTATUS __stdcall BaseDllAppendStringToResultBuffer(int a1, int a2, int a3, char a4);
NTSTATUS __stdcall BaseDllAppendBufferToResultBuffer(int a1, PCHAR MbString, ULONG MbSize, ULONG UnicodeSize, char a5);
UINT __stdcall GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
UINT __stdcall GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
DWORD __stdcall GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);
ULONG __stdcall MapSDToRpcSD(PSECURITY_DESCRIPTOR SecurityDescriptor, int a2);
LSTATUS __stdcall RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor);
ULONG __stdcall LocalBaseRegGetKeySecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, int a3);
BOOL __stdcall VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
SIZE_T __stdcall HeapCompactStub(HANDLE hHeap, DWORD dwFlags);
// SIZE_T __stdcall HeapCompact(HANDLE hHeap, DWORD dwFlags);
DWORD __stdcall GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
// errno_t __cdecl wcsncpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src, rsize_t MaxCount);
NTSTATUS __stdcall BaseDllFindKeyword(STRING *String1);
HANDLE __stdcall CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
HANDLE __stdcall OpenSemaphoreWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// HANDLE __stdcall OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
BOOL __stdcall FlushFileBuffersImplementation(HANDLE hFile);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
int __stdcall BaseFormatTimeOut(int a1, unsigned int a2);
BOOL __stdcall WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
int __stdcall BaseDllFindIniFileNameMapping(PCUNICODE_STRING String2, int, int); // idb
BOOL __stdcall FlushViewOfFileStub(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
// BOOL __stdcall FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);
ATOM __stdcall GlobalAddAtomA(LPCSTR lpString);
LSTATUS __stdcall RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// UINT __stdcall GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
BOOL __stdcall FindCloseChangeNotificationStub(HANDLE hChangeHandle);
// BOOL __stdcall FindCloseChangeNotification(HANDLE hChangeHandle);
UINT __stdcall GetDriveTypeAStub(LPCSTR lpRootPathName);
// UINT __stdcall GetDriveTypeA(LPCSTR lpRootPathName);
BOOL __stdcall SetHandleInformationImplementation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);
// BOOL __stdcall SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);
BOOL __stdcall VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize);
BOOL __stdcall IsBadWritePtr(LPVOID lp, UINT_PTR ucb);
HANDLE __stdcall CreateIoCompletionPortStub(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// HANDLE __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
LPSTR __stdcall lstrcpynStub(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
// LPSTR __stdcall lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
DWORD __stdcall QueueUserAPCStub(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
// DWORD __stdcall QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);
int __thiscall CreateThreadpoolCleanupGroup(void *this);
PTP_WORK __stdcall CreateThreadpoolWorkStub(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
PTP_WORK __stdcall CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
DWORD __stdcall ExpandEnvironmentStringsAStub(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
// DWORD __stdcall ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
BOOL __stdcall GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType);
BOOL __stdcall GetCPInfoExWStub(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx);
// BOOL __stdcall GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx);
int __stdcall K32GetModuleBaseNameW(HANDLE hProcess, int Buffer, LPVOID lpBuffer, int); // idb
int __stdcall K32GetModuleBaseNameA(HANDLE hProcess, int Buffer, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr); // idb
int __stdcall IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar);
LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
int __stdcall lstrcmpStub(LPCSTR lpString1, LPCSTR lpString2);
int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
DWORD __stdcall VerLanguageNameWStub(DWORD wLang, LPWSTR szLang, DWORD cchLang);
// DWORD __stdcall VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang);
BOOL __stdcall GetFileAttributesExAStub(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// BOOL __stdcall GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
BOOL __stdcall SetFileAttributesAStub(LPCSTR lpFileName, DWORD dwFileAttributes);
// BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);
BOOL __stdcall CallbackMayRunLongStub(PTP_CALLBACK_INSTANCE pci);
BOOL __stdcall CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci);
DWORD __stdcall GetTimeZoneInformationStub(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL __stdcall GlobalMemoryStatusExStub(LPMEMORYSTATUSEX lpBuffer);
DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
BOOL __stdcall IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax);
void __stdcall RtlUnwindStub(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
LSTATUS __stdcall RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
BOOL __stdcall SetFileInformationByHandleStub(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
// BOOL __stdcall SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
int __stdcall BaseRegNotifyClassKey(HANDLE, int, int, ULONG NotifyFilter, BOOLEAN WatchSubtree, BOOLEAN Asynchronous); // idb
// int __stdcall BaseRegGetBestAncestor(int, int, int, POBJECT_ATTRIBUTES ObjectAttributes); idb
int __stdcall BasepCopyFileExW(const WCHAR *a1, const WCHAR *a2, int a3, int a4, int a5, __int64 a6, int a7, int a8, int a9);
int __stdcall BasepCopyCheckNoBuffering();
int __stdcall BasepSelectReadyChunk(int *a1, unsigned int a2, int a3);
NTSTATUS __stdcall BasepProcessNameGrafting(HANDLE FileHandle, int a2, int a3, int a4, PVOID FileInformation, int a6);
_DWORD __stdcall BaseCopyStream(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __stdcall BasepRemoteFile(HANDLE FileHandle); // idb
void __stdcall BasepCopyAdjustChunkSize(int a1, unsigned __int64 a2, int a3);
int __stdcall BasepCopyGetChunkInfo(int a1, int a2);
int __stdcall BasepCheckCopyChunkFile(HANDLE hDevice, HANDLE FileHandle, int); // idb
int __stdcall BasepCopyEncryption(int, int, PHANDLE FileHandle, POBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, int, int, int, int, int, int); // idb
BOOL __stdcall CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags);
BOOL __stdcall SetFileAttributesWStub(LPCWSTR lpFileName, DWORD dwFileAttributes);
// BOOL __stdcall SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
ULONG __stdcall LocalOpenUsers(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);
int __stdcall GetLocaleInfoAStub(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
ULONG __stdcall LocalOpenCurrentUserLocalSettings(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);
int __stdcall RegisterConsoleIME(int a1, int a2);
PTP_TIMER __stdcall CreateThreadpoolTimerStub(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
PTP_TIMER __stdcall CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
int __stdcall GetStringFromArrayInPool(int a1, int a2, int a3);
BOOL __stdcall SystemTimeToTzSpecificLocalTimeStub(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// BOOL __stdcall SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
int __stdcall BaseRegCreateMultipartKey(HANDLE Handle, int, PUNICODE_STRING Class, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int, int, int, int, int); // idb
// wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
DWORD __stdcall GetProcessIdStub(HANDLE Process);
// BOOL __stdcall GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);
BOOL __stdcall UnregisterWait(HANDLE WaitHandle);
int __stdcall K32QueryWorkingSetEx(HANDLE ProcessHandle, PVOID MemoryInformation, ULONG MemoryInformationLength); // idb
int __stdcall LocalBaseRegDeleteValue(HANDLE KeyHandle, PUNICODE_STRING ValueName); // idb
LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);
// BOOL __stdcall CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
BOOL __stdcall CreateTimerQueueTimerStub(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
BOOL __stdcall DeleteTimerQueueTimerStub(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
BOOL __stdcall GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength);
int __stdcall BasepGetVolumeNameForVolumeMountPoint(LPCWSTR lpRootPathName, PWSTR dosname, int, int); // idb
BOOL __stdcall GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// BOOL __stdcall Wow64DisableWow64FsRedirection(PVOID *OldValue);
BOOL __stdcall Wow64DisableWow64FsRedirectionStub(PVOID *OldValue);
HANDLE __stdcall PowerCreateRequest(PREASON_CONTEXT Context);
signed int __stdcall BasePrepareReasonContext(int a1, int a2);
BOOL __stdcall PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
int __stdcall GetNumberFormatWStub(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
BOOL __stdcall SetFileTimeStub(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
// BOOL __stdcall SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime);
BOOL __stdcall PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);
BOOL __stdcall GetStringTypeExWStub(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// DWORD __stdcall GetProcessVersion(DWORD ProcessId);
void __stdcall GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo);
DWORD __stdcall GetSystemInfoInternal(int a1, int a2, int a3);
void __stdcall AddRefActCtx(HANDLE hActCtx);
BOOL __stdcall BasepSxsIsStatusResourceNotFound(int a1);
BOOL __stdcall Module32NextW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
LPVOID __stdcall VirtualAllocExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPVOID __stdcall VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
BOOL __stdcall ReadProcessMemoryStub(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
BOOL __stdcall VirtualFreeExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
int __stdcall FindModule(HANDLE ProcessHandle, int Buffer, LPVOID lpBuffer); // idb
BOOL __stdcall DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime);
int __stdcall K32GetModuleFileNameExW(HANDLE hProcess, int Buffer, LPVOID lpBuffer, int); // idb
BOOL __stdcall Module32FirstW(HANDLE hSnapshot, LPMODULEENTRY32W lpme);
NTSTATUS __stdcall ThpCopyAnsiToUnicode(int a1, PCSZ SourceString, __int16 a3);
int __stdcall K32EnumProcessModules(HANDLE ProcessHandle, int, int, int); // idb
int __stdcall EnumProcessModulesInternal(HANDLE ProcessHandle, int, int, int, int); // idb
signed int __stdcall BaseDllReadWriteIniFile(char a1, char a2, char a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall BaseDllCaptureIniFileParameters(char a1, int a2, char a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __stdcall BaseDllIniFileNameLength(char a1, unsigned int *a2);
char __stdcall BaseDllGetApplicationName(int a1, int a2, int a3);
NTSTATUS __stdcall BaseDllReadWriteIniFileViaMapping(PCUNICODE_STRING String2);
int __stdcall BaseDllFindVarNameMapping(int, PCUNICODE_STRING String2); // idb
char __stdcall BaseDllGetVariableName(int a1, int a2, int a3);
int __stdcall BaseDllReadVariableValue(int a1, int a2, int a3, UNICODE_STRING *a4);
int __stdcall BaseDllOpenMappingTarget(int, int, PCUNICODE_STRING, char, PHANDLE); // idb
signed int __stdcall BaseDllOpenIniFileOnDisk(int a1);
int __stdcall BaseDllReadWriteIniFileOnDisk(STRING *String1); // idb
NTSTATUS __stdcall BaseDllCloseIniFileOnDisk(int a1);
signed int __stdcall BaseDllAdvanceTextPointer(int a1, signed int a2);
int __stdcall BaseDllFindSection(STRING *String1); // idb
int __stdcall BaseDllReadKeywordValue(STRING *String1); // idb
DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
// errno_t __cdecl strncpy_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
ATOM __stdcall FindAtomA(LPCSTR lpString);
UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
UINT __stdcall GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault);
UINT __stdcall GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
int __stdcall RegLoadMUIStringW(HKEY hKey, LPCWSTR lpValueName, void *Dst, size_t, int, int, int); // idb
// BOOL __stdcall LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut);
BOOL __stdcall GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus);
// HANDLE __stdcall CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
LSTATUS __stdcall RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
int __stdcall SbpGetShimData(int, int, void *Dst, int); // idb
int __stdcall SbpMergeApphackContexts(int, int, int, int, ULONG); // idb
int __stdcall SbpQueryContexts(int, int, int, int, int, ULONG Size); // idb
int __stdcall KeyStateListInit(int a1);
BOOL __stdcall SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages);
int __stdcall BaseCheckRunApp(HANDLE SectionHandle, int, int, PVOID Environment, int, int, int, int, int, int, int, int, PVOID Address); // idb
NTSTATUS __stdcall sub_77E1EE20(HANDLE SectionHandle, int a2, int a3, PVOID Environment, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, PVOID BaseAddress);
NTSTATUS __stdcall BasepGetApphelpCheckRunAppProc(int a1);
NTSTATUS __stdcall RtlUnicodeStringInit(PUNICODE_STRING DestinationString, NTSTRSAFE_PCWSTR pszSrc);
// signed int __userpurge sub_77E1F095@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __int16 a4);
NTSTATUS __stdcall sub_77E1F10B(NTSTRSAFE_PCWSTR pszSrc, int a2, NTSTRSAFE_PCWSTR a3, __int16 a4, int a5);
NTSTATUS __stdcall RtlUnicodeStringInitEx(PUNICODE_STRING DestinationString, NTSTRSAFE_PCWSTR pszSrc, ULONG dwFlags);
BOOLEAN __stdcall KeyStateListDestroy(PVOID Address);
void __stdcall OutputDebugStringAStub(LPCSTR lpOutputString);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
void __stdcall RaiseExceptionStub(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
SIZE_T __stdcall GlobalSize(HGLOBAL hMem);
HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
int __stdcall InternalGetAtomName(NTSTATUS NtStatus, int a2, int Atom, void *Dst, ULONG Size);
UINT __stdcall GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL __stdcall SetPriorityClassStub(HANDLE hProcess, DWORD dwPriorityClass);
// BOOL __stdcall SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);
LSTATUS __stdcall RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult);
signed int __stdcall RemoveCtrlHandler(int a1);
BOOL __stdcall FreeResourceStub(HGLOBAL hResData);
// BOOL __stdcall FreeResource(HGLOBAL hResData);
int __stdcall ByteMatchGetEOFData(DWORD NumberOfBytesRead, LPVOID lpBuffer, int); // idb
int __stdcall ByteMatchGetAppendedData(DWORD NumberOfBytesRead, LONG lDistanceToMove, LPVOID lpBuffer, int); // idb
UINT __stdcall _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes);
LONG __stdcall _llseek(HFILE hFile, LONG lOffset, int iOrigin);
BOOL __stdcall GetSystemTimeAdjustmentStub(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);
// BOOL __stdcall GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
BOOL __stdcall SetFilePointerExStub(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
signed int __stdcall BasepSkipSetupShims();
BOOL __stdcall GetProcessTimesStub(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// BOOL __stdcall GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// BOOL __stdcall GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule);
BOOL __stdcall GetModuleHandleExAStub(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule);
NTSTATUS __stdcall ThpCreateRawSnap(ULONG FreeSize, ULONG ProcessId, PVOID *BaseAddress, int a4, int a5, int a6, int a7, int a8, int a9);
HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
NTSTATUS __stdcall ThpAllocateSnapshotSection(PHANDLE SectionHandle, PVOID *BaseAddress, POBJECT_ATTRIBUTES ObjectAttributes, int a4, ULONG ViewSize, int a6, int a7);
int __stdcall ThpProcessToSnap(char a1, int a2, int a3, int a4, int a5, int a6, int a7);
// errno_t __cdecl wcscpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
int __stdcall LocalOpenPerformanceData(int a1, int a2, int a3);
BOOL __stdcall VirtualLock(LPVOID lpAddress, SIZE_T dwSize);
LPVOID __stdcall LockResourceStub(HGLOBAL hResData);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
ULONG __stdcall ClosePredefinedHandle(unsigned int a1);
void __stdcall FreeLibraryAndExitThreadStub(HMODULE hLibModule, DWORD dwExitCode);
// void __stdcall FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
HFILE __stdcall _lclose(HFILE hFile);
BOOLEAN __stdcall FreePredefinedHandleUnit(PVOID Address);
int __stdcall RemoveUnitFromList(int a1, int a2);
SIZE_T __stdcall LocalSize(HLOCAL hMem);
BOOL __stdcall SetConsoleTitleW(LPCWSTR lpConsoleTitle);
int __stdcall SetConsoleTitleInternal(void *Src, int, char); // idb
DWORD __stdcall GetFileSizeStub(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// DWORD __stdcall SleepEx(DWORD dwMilliseconds, BOOL bAlertable);
DWORD __stdcall SleepExStub(DWORD dwMilliseconds, BOOL bAlertable);
signed int __stdcall OpenConsoleW(PCWSTR SourceString, int a2, int a3, int a4);
int __stdcall OpenConsoleWInternal(int a1, int a2, int a3, int a4, int a5);
BOOL __stdcall SetEnvironmentStringsWStub(LPWCH NewEnvironment);
// BOOL __stdcall SetEnvironmentStringsW(LPWCH NewEnvironment);
// UINT __stdcall GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
UINT __stdcall GetWindowsDirectoryWStub(LPWSTR lpBuffer, UINT uSize);
BOOL __stdcall GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize);
NTSTATUS __stdcall BasepGetValueFromReg(PCWSTR SourceString, int a2, int a3, int a4);
NTSTATUS __stdcall GetNameFromValue(int a1, PCWSTR SourceString, void *Dst, int a4);
int __stdcall NullTerminateRegExpandSzString(HKEY hKey, LPCWSTR lpValueName, int, int, int, ULONG Flags, int, char); // idb
// int __stdcall _ExpandRegString(LPWSTR lpDst, DWORD nSize, int, char); idb
HANDLE __stdcall CreateFileMappingWStub(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
DWORD __stdcall GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);
DWORD __stdcall GetShortPathNameWStub(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);
signed int __stdcall IsShortName_U(int a1, signed int a2);
BOOL __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
ULONG __stdcall RegCreateKeyExInternalW(int a1, int a2, int a3, int SourceString, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a7, int a8, int a9, int a10);
LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
HANDLE __stdcall CreateEventAStub(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
BOOL __stdcall GetComputerNameExWStub(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);
// BOOL __stdcall GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);
// int __stdcall CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2);
int __stdcall CompareStringAStub(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2);
// DWORD __stdcall ResumeThread(HANDLE hThread);
DWORD __stdcall ResumeThreadStub(HANDLE hThread);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
BOOL __stdcall DeleteFileWStub(LPCWSTR lpFileName);
BOOL __stdcall GetFileTimeStub(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// BOOL __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
NTSTATUS __stdcall InitSecurityAcls(PSECURITY_DESCRIPTOR *a1);
ULONG __stdcall LocalOpenClassesRoot(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);
ULONG __stdcall OpenClassesRootInternal(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle, int a4);
int __stdcall OpenCombinedClassesRoot(ACCESS_MASK DesiredAccess, PHANDLE KeyHandle, int); // idb
signed int __stdcall WerpAcquirePebLock();
struct _PEB *__stdcall WerpCurrentPeb(); // idb
int __stdcall WerpValidatePebHeader(struct _WER_PEB_HEADER_BLOCK *a1);
// int __cdecl wcsncmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
signed int __stdcall WerpInitPEBStore();
int __stdcall WerpCheckOkToRegister(); // idb
signed int __stdcall WerpRegisterMemoryBlock(PVOID pvAddress, DWORD dwSize);
HRESULT __stdcall WerRegisterMemoryBlock(PVOID pvAddress, DWORD dwSize);
int __stdcall WerpValidateHeapSignature(struct _WER_HEAP_MAIN_HEADER *a1);
int __stdcall WerpHeapLock(struct _WER_HEAP_MAIN_HEADER *); // idb
int __stdcall WerpHeapUnLock(struct _WER_HEAP_MAIN_HEADER *); // idb
signed int __stdcall _FindMemBlockByAddress(void *a1, struct _WER_GATHER **a2, struct _WER_GATHER **a3);
int __stdcall WerpGetHeapHandle();
signed int __stdcall WerpUnregisterMemoryBlock(PVOID pvAddress);
__int32 __stdcall WerpHeapAddBlockToTail(struct _WER_HEAP_MAIN_HEADER *, struct _WER_HEAP_BLOCK_HEADER *); // idb
signed int __stdcall WerpAddGatherToPEB(struct _WER_GATHER *a1);
int __stdcall WerpHeapAlloc(struct _WER_HEAP_MAIN_HEADER *a1, unsigned __int32 a2);
signed int __stdcall StringCchCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3);
signed int __stdcall WerpHeapCreate(struct _WER_HEAP_MAIN_HEADER *Dst);
void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
int __stdcall lstrcmpiAStub(LPCSTR lpString1, LPCSTR lpString2);
int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
BOOL __stdcall QueryPerformanceFrequencyStub(LARGE_INTEGER *lpFrequency);
// BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);
LCID __stdcall LocaleNameToLCIDStub(LPCWSTR lpName, DWORD dwFlags);
// LCID __stdcall LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags);
BOOL __stdcall GetThreadPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// BOOL __stdcall GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// LANGID __stdcall GetUserDefaultUILanguage();
BOOL __stdcall HeapDestroyStub(HANDLE hHeap);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
BOOL __stdcall SetEndOfFileStub(HANDLE hFile);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
BOOL __stdcall TerminateProcessStub(HANDLE hProcess, UINT uExitCode);
BOOL __stdcall VirtualProtectStub(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
BOOL __stdcall QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired);
BOOL __stdcall SetThreadStackGuaranteeStub(PULONG StackSizeInBytes);
// BOOL __stdcall SetThreadStackGuarantee(PULONG StackSizeInBytes);
HANDLE __stdcall CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);
BOOL __stdcall HeapValidateStub(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
BOOL __stdcall SetThreadLocaleStub(LCID Locale);
// BOOL __stdcall SetThreadLocale(LCID Locale);
ATOM __stdcall AddAtomW(LPCWSTR lpString);
int __stdcall InternalDeleteAtom(int, USHORT Atom); // idb
ATOM __stdcall DeleteAtom(ATOM nAtom);
WORD __stdcall RtlCaptureStackBackTraceStub(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash);
BOOL __stdcall GetFileAttributesExWStub(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// BOOL __stdcall GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
ULONG __stdcall LocalBaseRegCreateKey(int a1, PCUNICODE_STRING Source, int a3, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a6, int a7, int a8, int a9);
// HANDLE __stdcall CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
HANDLE __stdcall CreateMutexWStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
BOOL __stdcall ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
BOOL __stdcall FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);
// BOOL __stdcall GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
BOOL __stdcall GetOverlappedResultStub(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
void __stdcall RegCreateKeyExInternalA(int a1, PCSZ Source, int a3, int a4, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a7, int a8, int a9, int a10);
char __stdcall EnumSubtreeStateClear(PVOID *a1);
void *__stdcall EnumStateClear(void *Dst);
int __stdcall StateObjectListAdd(int a1, int a2);
NTSTATUS __stdcall EnumStateSetLimits(void *Dst, int a2, int a3, int a4, int a5);
void __stdcall EnumTableGetNextEnum(void *a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall EnumStateGetNextEnum(void *Dst, int, int, int, int, int, int); // idb
signed int __stdcall EnumStateChooseNext(int a1, int a2, int a3, int a4, int a5, int a6);
NTSTATUS __stdcall EnumClassKey(HANDLE KeyHandle, int a2);
signed int __stdcall EnumTableGetKeyState(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall EnumTableFindKeyState(int a1, int a2, int a3);
signed int __stdcall EnumTableAddKey(int a1, void *a2, int a3, int a4, int a5);
int __stdcall EnumStateInit(void *Dst, HANDLE KeyHandle, int, int, HANDLE SourceHandle); // idb
BOOLEAN __stdcall EnumStateDestroy(PVOID Address);
signed int __stdcall EnumSubtreeStateCopyKeyInfo(int a1, int a2, int a3, unsigned int a4, int a5);
signed int __stdcall EnumStateCompareSubtrees(int a1, int a2, int a3);
BOOL __stdcall CancelIoExStub(HANDLE hFile, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped);
LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
NTSTATUS __stdcall RtlStringCchCopyW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc);
BOOL __stdcall DeleteFileAStub(LPCSTR lpFileName);
// BOOL __stdcall DeleteFileA(LPCSTR lpFileName);
// DWORD __stdcall SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD __stdcall SearchPathWStub(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
HRSRC __stdcall FindResourceExWStub(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
DWORD __stdcall ExpandEnvironmentStringsWStub(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
signed int __stdcall NullTerminateRegSzString(int a1, int *a2, unsigned int a3, signed int a4, char a5);
HMODULE __stdcall LoadLibraryExAStub(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
BOOL __stdcall SetThreadPriorityStub(HANDLE hThread, int nPriority);
int __stdcall LoadStringBaseExWStub(int a1, int a2, int a3, int a4, int a5);
// int __stdcall LoadStringBaseExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
BOOL __stdcall IsValidLocaleStub(LCID Locale, DWORD dwFlags);
// BOOL __stdcall IsValidLocale(LCID Locale, DWORD dwFlags);
LCID __stdcall ConvertDefaultLocaleStub(LCID Locale);
// LCID __stdcall ConvertDefaultLocale(LCID Locale);
int __stdcall LocalBaseRegQueryInfoKey(HANDLE KeyHandle, int, int, int, int, int, int, int, int, int); // idb
NTSTATUS __stdcall QueryKeyInfo(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, int a3, ULONG KeyInformationLength, int a5, __int16 a6);
LSTATUS __stdcall RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// BOOL __stdcall IsDBCSLeadByte(BYTE TestChar);
HANDLE __stdcall OpenEventWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// HANDLE __stdcall OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
int __stdcall LocalBaseRegEnumValue(PVOID, ULONG Index, int, int, int, int, int); // idb
void __stdcall ValStateRelease(PVOID Address);
LSTATUS __stdcall RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
BOOLEAN __stdcall BaseRegReleaseKeySemantics(int a1);
LSTATUS __stdcall RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous);
HMODULE __stdcall LoadLibraryExWStub(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
ULONG __stdcall LocalBaseRegEnumKey(int a1, ULONG Index, int a3, int a4, int a5);
LSTATUS __stdcall RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
BOOL __stdcall SetProcessShutdownParametersStub(DWORD dwLevel, DWORD dwFlags);
// BOOL __stdcall SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags);
BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
int __stdcall CompareStringOrdinalStub(LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase);
// int __stdcall CompareStringOrdinal(LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase);
BOOL __stdcall DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
HANDLE __stdcall OpenEventAStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
BOOL __stdcall IsWow64ProcessStub(HANDLE hProcess, PBOOL Wow64Process);
BOOL __stdcall IsDBCSLeadByteStub(BYTE TestChar);
DWORD __stdcall GetLogicalDrives();
HANDLE __stdcall OpenProcessStub(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
BOOL __stdcall GetModuleHandleExWStub(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
DWORD __stdcall SizeofResourceStub(HMODULE hModule, HRSRC hResInfo);
BOOL __stdcall SetWaitableTimerStub(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
// BOOL __stdcall SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);
int __stdcall InternalInitAtomTable(int a1);
__int16 __stdcall InternalAddAtom(int a1, char a2, PCSZ SourceString);
LPVOID __stdcall LocalLockStub(HLOCAL hMem);
// LPVOID __stdcall LocalLock(HLOCAL hMem);
BOOL __stdcall LocalUnlockStub(HLOCAL hMem);
// BOOL __stdcall LocalUnlock(HLOCAL hMem);
HANDLE __stdcall CreateActCtxW(PCACTCTXW pActCtx);
NTSTATUS __stdcall BasepCreateActCtx(char a1, int a2, wchar_t *a3);
int __stdcall CsrBasepCreateActCtx(const void *a1);
NTSTATUS __stdcall BasepSxsCreateStreams(int a1, ACCESS_MASK DesiredAccess, int a3, int a4, int a5, int a6, int a7, int a8, int a9, PHANDLE FileHandle, int a11, PHANDLE a12, ULONG Length, int a14, PHANDLE a15, int a16, int a17, int a18);
int __stdcall BasepSxsIsStatusFileNotFoundEtc(NTSTATUS StatusCode); // idb
LSTATUS __stdcall RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult);
int __stdcall QueryFullProcessImageNameW(HANDLE ProcessHandle, HANDLE HeapHandle, void *Dst, int); // idb
// int __stdcall BaseDllMapResourceIdW(_DWORD); weak
int __stdcall BasepSxsCreateResourceStream(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8);
// int __stdcall LdrResSearchResource(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int swprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, ...);
BOOL __stdcall ReleaseSemaphoreStub(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
BOOL __stdcall sub_77E26B22(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
BOOL __stdcall CancelWaitableTimerStub(HANDLE hTimer);
// BOOL __stdcall CancelWaitableTimer(HANDLE hTimer);
int __stdcall BasepSxsActivationContextNotification(int, int, PVOID BaseAddress, int, int, int); // idb
// NTSTATUS __stdcall NtClose(HANDLE Handle);
// NTSTATUS __stdcall NtUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress);
ATOM __stdcall GlobalAddAtomW(LPCWSTR lpString);
int __stdcall BasepSxsCreateFileStream(ACCESS_MASK DesiredAccess, int, PHANDLE FileHandle, int); // idb
// NTSTATUS __stdcall NtQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass);
HLOCAL __stdcall LocalReAllocStub(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
// HLOCAL __stdcall LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
void __stdcall ReleaseActCtx(HANDLE hActCtx);
int __stdcall RegKrnGetClassesEnumTableAddressInternal();
void __stdcall EnumTableRemoveKey(int a1, int a2, int a3);
signed int __stdcall BaseRegOpenClassKeyFromLocation(int a1, void *a2, int a3, int a4, char a5, char a6, int a7, int a8);
int __stdcall BaseRegGetKeySemantics(HANDLE KeyHandle, PCUNICODE_STRING Source, int); // idb
NTSTATUS __stdcall BaseRegTranslateToMachineClassKey(int a1, PUNICODE_STRING DestinationString, int a3);
int __stdcall KeySemanticsRemovePrefix(int a1, int a2, char a3);
__int16 __stdcall BaseRegCchSpecialKeyLen(int a1, unsigned __int16 a2, int a3);
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
int __stdcall BaseRegOpenClassKey(HANDLE KeyHandle, PCUNICODE_STRING Source, int, int, int, int); // idb
int __stdcall BaseRegGetUserPrefixLength(int a1);
NTSTATUS __stdcall BaseRegTranslateToUserClassKey(int a1, PUNICODE_STRING Destination, int a3);
NTSTATUS __stdcall BaseRegConstructUserClassPrefix(int a1, PUNICODE_STRING DestinationString);
int __stdcall BaseRegGetUserAndMachineClass(int, HANDLE KeyHandle, int, int, int); // idb
void __stdcall SortGetSortKey(int a1, int a2, void *a3, signed int a4, void *a5, int a6, int a7, int a8);
signed int __stdcall CheckEnumFlags(int a1, int a2);
int __stdcall GetRcConfig(int a1, int a2, int a3);
int __stdcall EnumResourceNamesInternal(int, PWCHAR UnicodeString, int, int, char, unsigned __int32, int); // idb
BOOL __stdcall EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
int __stdcall GetResourceDirectory(PVOID ImageBase, int, char, PULONG Size, int); // idb
int __stdcall EnumFindResource(int a1, int a2, int a3, unsigned __int16 a4, __int16 a5, int a6);
// int __stdcall LdrFindResourceEx_U(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
NTSTATUS __stdcall ConsoleOpenWaitEvent(int a1, int a2, PHANDLE EventHandle);
BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
int __stdcall CmdBatNotification(int a1);
PRTL_USER_PROCESS_PARAMETERS __stdcall SetUpHandles(int a1);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
ATOM __stdcall FindAtomW(LPCWSTR lpString);
// NTSTATUS __stdcall NtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
DWORD __stdcall GetThreadIdStub(HANDLE Thread);
// DWORD __stdcall GetThreadId(HANDLE Thread);
DWORD __stdcall GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer);
BOOL __stdcall SetEnvironmentVariableAStub(LPCSTR lpName, LPCSTR lpValue);
// BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);
int __stdcall MoveFileWithProgressTransactedW(PWSTR dosname, PWSTR DeviceName, int, int, int, int); // idb
BOOL __stdcall MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
// BOOL __stdcall MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
DWORD __stdcall FormatMessageWStub(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
int __stdcall BasepNotifyLoadStringResource(HINSTANCE hModule, unsigned int, unsigned __int16 *, int); // idb
int __stdcall RealWerpNotifyLoadStringResource(HINSTANCE hModule, unsigned int, unsigned __int16 *, unsigned __int32); // idb
int __stdcall RealWerpNotifyLoadStringResourceEx(HINSTANCE hModule, unsigned int, unsigned __int16 *, unsigned __int32, void **); // idb
signed int __thiscall FSPErrorMessages::CMessageMapper::NotifyLoadStringResource(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, unsigned int a3, const unsigned __int16 *a4, unsigned __int32 a5, void **a6);
// DWORD __stdcall GetProcessId(HANDLE Process);
signed int __thiscall FSPErrorMessages::CMessageMapper::GetModuleFileNameFromHandleNoLock(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, LPWSTR lpFilename, unsigned __int32 nSize);
int __thiscall FSPErrorMessages::CConfig::OpenMachineKey(PHANDLE KeyHandle); // idb
FSPErrorMessages::CConfig *__thiscall FSPErrorMessages::CConfig::CConfig(FSPErrorMessages::CConfig *this);
signed int __thiscall FSPErrorMessages::CMessageMapper::LazyInitialize(FSPErrorMessages::CMessageMapper *this);
NTSTATUS __thiscall FSPErrorMessages::CConfig::~CConfig(FSPErrorMessages::CConfig *this);
int __thiscall FSPErrorMessages::CConfig::IsDisabled(FSPErrorMessages::CConfig *this); // idb
int __stdcall FSPErrorMessages::CConfig::GetDisabledValueFromKey(void *KeyHandle);
__int32 __stdcall FSPErrorMessages::ReadDwordFromRegistry(HANDLE KeyHandle, PCWSTR SourceString, const unsigned __int16 *, unsigned __int32 *); // idb
void FSPErrorMessages::CMessageMapper::DumpTrace(FSPErrorMessages::CMessageMapper *this, const char *Format, ...); // idb
CHAR *__stdcall K32GetDeviceDriverBaseNameW(int ImageBase, LPWSTR lpWideCharStr, SIZE_T uBytes);
LPVOID __stdcall MapViewOfFileStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
signed int __stdcall StringCchCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4);
UINT __stdcall GetSystemDirectoryAStub(LPSTR lpBuffer, UINT uSize);
UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
BOOL __stdcall SetCurrentDirectoryAStub(LPCSTR lpPathName);
// BOOL __stdcall SetCurrentDirectoryA(LPCSTR lpPathName);
__int16 __stdcall InternalFindAtom(int a1, char a2, PCSZ SourceString);
ATOM __stdcall GlobalFindAtomW(LPCWSTR lpString);
int __stdcall GetThreadPriorityStub(HANDLE hThread);
// int __stdcall GetThreadPriority(HANDLE hThread);
unsigned int __stdcall IsThreadAFiber();
int __stdcall StateObjectListRemove(int a1, int a2);
int __stdcall StateObjectListFind(int a1, int a2);
BOOL __stdcall StateObjectListIsEmpty(int a1);
int __stdcall LocalBaseRegSetValue(HANDLE, PUNICODE_STRING ValueName, ULONG Type, PVOID Data, ULONG DataSize); // idb
LSTATUS __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
BOOL __stdcall GetDiskFreeSpaceExWStub(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// BOOL __stdcall GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
BOOL __stdcall QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags);
BOOL __stdcall CreateDirectoryWStub(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL __stdcall GetVersionExWStub(LPOSVERSIONINFOW lpVersionInformation);
BOOL __stdcall GetFileSizeExStub(HANDLE hFile, PLARGE_INTEGER lpFileSize);
BOOL __stdcall FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
int __stdcall GetFileInformationByHandleEx(HANDLE FileHandle, int, PVOID FileInformation, ULONG FileInformationLength); // idb
LONG __stdcall InterlockedExchangeAddStub(volatile LONG *Addend, LONG Value);
BOOL __stdcall GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);
BOOL __stdcall GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
BOOL __stdcall FindNextFileWStub(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
BOOL __stdcall ReadFileImplementation(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
// HANDLE __stdcall CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred);
HGLOBAL __stdcall LoadResourceStub(HMODULE hModule, HRSRC hResInfo);
int __stdcall CompareStringWStub(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
int __stdcall lstrlenStub(LPCSTR lpString);
// int __stdcall lstrlenA(LPCSTR lpString);
HGLOBAL __stdcall GlobalAllocStub(UINT uFlags, SIZE_T dwBytes);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
HGLOBAL __stdcall GlobalFreeStub(HGLOBAL hMem);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// int __stdcall BaseDllFreeResourceId(_DWORD); weak
BOOL __stdcall GlobalUnlock(HGLOBAL hMem);
LPVOID __stdcall GlobalLock(HGLOBAL hMem);
PVOID __stdcall BasepMapModuleHandle(void *a1, char a2);
ULONG __stdcall BaseDllMapResourceIdA(ULONG Value);
HRSRC __stdcall FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage);
HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// int __stdcall GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
// int __fastcall InternalLcidToName(_DWORD, _DWORD); weak
int __stdcall GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
HGLOBAL __stdcall GlobalHandle(LPCVOID pMem);
LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
BOOL __stdcall FindNextFileAStub(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
void __stdcall NlsAnsiToUnicode(int a1, int a2, int a3, INT piResult, int a5, int a6);
int __stdcall NlsUnicodeToAnsi(int, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte); // idb
int __stdcall NlsGetACPFromLocale(char a1, int a2);
// int __fastcall GetCPHashNode(_DWORD, _DWORD); weak
HRESULT UIntPtrToInt(UINT_PTR uOperand, INT *piResult);
// int __stdcall SpecialMBToWC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber);
// void __userpurge sub_77E2AB12(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8);
DWORD __stdcall VerLanguageNameAStub(DWORD wLang, LPSTR szLang, DWORD cchLang);
// DWORD __stdcall VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang);
int __stdcall lstrcmpiWStub(LPCWSTR lpString1, LPCWSTR lpString2);
// int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
void __stdcall GetLocalTimeStub(LPSYSTEMTIME lpSystemTime);
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// int __stdcall NlsValidateLocale(_DWORD, _DWORD); weak
int __stdcall NlsPadIntToUnicodeString(ULONG Value, ULONG Base, int, int, int); // idb
int __stdcall NlsCopyUnicodeString(STRSAFE_LPWSTR *ppszDestEnd, size_t *pcchRemaining, STRSAFE_LPCWSTR pszSrc); // idb
HRESULT __stdcall StringCchCopyExW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc, STRSAFE_LPWSTR *ppszDestEnd, size_t *pcchRemaining, DWORD dwFlags);
signed int __fastcall sub_77E2ADA2(unsigned int a1, int a2, int a3, unsigned int a4, __int16 a5);
// int __stdcall GetCalendar(_DWORD, _DWORD); weak
int __stdcall DoFormatDate(int a1, char a2, int a3, wchar_t *a4, wchar_t *a5, unsigned int a6, int a7, int a8, signed int a9, int a10);
signed int __stdcall NlsInsertBidiMark(int a1, char a2, int a3);
int __stdcall DoFormatTime(int a1, int a2, signed __int16 *a3, wchar_t *a4, int a5);
int __stdcall GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
int __stdcall GetTimeFormatWorker(int a1, int a2, int a3, signed __int16 *a4, wchar_t *a5, int a6);
BOOL __stdcall IsValidTime(int a1);
int __stdcall GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
size_t __stdcall sub_77E2B342(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
size_t __stdcall GetDateFormatWorker(int a1, int a2, int a3, int a4, wchar_t *a5, int a6, unsigned int a7);
signed int __stdcall HaveEraRanges(int a1, int a2);
signed int __stdcall IsValidDate(int a1);
// int __stdcall GetLocaleInfoHelper(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __thiscall SortNlsStrLenW(void *this);
__int16 __stdcall IsValidCalendarType(int a1, int a2);
int __stdcall GetLocaleNullStringFromArrayInPool(int a1, int a2, int a3);
// int __stdcall NlsIsUserDefaultLocale(_DWORD); weak
// int __stdcall GetUserInfoWord(_DWORD, _DWORD, _DWORD); weak
BOOL __stdcall IsHebrewCustomLocale(int a1);
BOOL __stdcall DeviceIoControlImplementation(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
DWORD __stdcall K32GetDeviceDriverBaseNameA(LPVOID ImageBase, LPSTR lpFilename, DWORD nSize);
signed int __stdcall FindDeviceDriver(int a1, void *a2);
BOOL __stdcall K32EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded);
BOOL __stdcall InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context);
// BOOL __stdcall ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId);
BOOL __stdcall ProcessIdToSessionIdStub(DWORD dwProcessId, DWORD *pSessionId);
DWORD __stdcall WaitForMultipleObjectsExImplementation(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
// DWORD __stdcall WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
BOOL __stdcall ResetEventStub(HANDLE hEvent);
// BOOL __stdcall ResetEvent(HANDLE hEvent);
BOOL __stdcall SetEventStub(HANDLE hEvent);
// BOOL __stdcall SetEvent(HANDLE hEvent);
DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// int __stdcall lstrlenW(LPCWSTR lpString);
int __stdcall lstrlenWStub(LPCWSTR lpString);
BOOL __stdcall GetFileInformationByHandleStub(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
BOOL __stdcall FileTimeToSystemTimeStub(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// BOOL __stdcall FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
BOOL __stdcall FileTimeToLocalFileTimeStub(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// BOOL __stdcall FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
int __stdcall WriteConsoleInternal(int, void *Src, int, int, char); // idb
UINT __stdcall GetConsoleCP();
BOOL __stdcall WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
HANDLE __stdcall FindFirstFileAStub(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);
void __stdcall SwitchToFiber(LPVOID lpFiber);
int __stdcall _ResourceCallEnumLangRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4, int a5, int a6);
int __stdcall _ResourceCallEnumNameRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4, int a5);
int __stdcall _ResourceCallEnumTypeRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3, int a4);
void __stdcall SleepStub(DWORD dwMilliseconds);
// DWORD __stdcall GetTickCount();
BOOL __stdcall ReleaseMutexStub(HANDLE hMutex);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
DWORD __stdcall WaitForSingleObjectExImplementation(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// DWORD __stdcall WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand);
LONG __stdcall InterlockedExchangeAdd(volatile LONG *Addend, LONG Value);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
LONG __stdcall InterlockedIncrementStub(volatile LONG *lpAddend);
BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
LONG __stdcall InterlockedDecrementStub(volatile LONG *lpAddend);
// void __stdcall SetLastError(DWORD dwErrCode);
LONG __stdcall InterlockedCompareExchangeStub(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// DWORD __stdcall GetCurrentThreadId();
BOOL __stdcall QueryPerformanceCounterStub(LARGE_INTEGER *lpPerformanceCount);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
LPVOID __stdcall VirtualAllocStub(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
LONG __stdcall InterlockedExchangeStub(volatile LONG *Target, LONG Value);
// DWORD __stdcall GetLastError();
void __stdcall BasepAdjustObjectAttributesForPrivateNamespace(int a1);
// _DWORD __stdcall KernelBaseGetGlobalData(); idb
signed int __stdcall Basep8BitStringToDynamicUnicodeString(int a1, PCSZ SourceString);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
HLOCAL __stdcall WTSFreeMemory(HLOCAL hMem);
HLOCAL __stdcall LocalAllocStub(UINT uFlags, SIZE_T uBytes);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// HANDLE __stdcall GetCurrentProcess();
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
FARPROC __stdcall GetProcAddressStub(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
HMODULE __stdcall GetModuleHandleWStub(LPCWSTR lpModuleName);
BOOL __stdcall _BaseDllInitialize(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
bool __stdcall RegKrnInitialize(int a1, int a2, int a3);
BOOL __stdcall BaseDllInitialize(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
char __thiscall ConDllInitialize(int this, int a2, int a3);
int __stdcall RegKrnGetGlobalState();
int __stdcall MapPredefinedHandleInternal(int, int, PHANDLE KeyHandle, int); // idb
ULONG __stdcall LocalBaseRegOpenKey(HANDLE KeyHandle, PCUNICODE_STRING Source, int a3, int a4, ULONG ResultLength, int a6);
LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LSTATUS __stdcall RegOpenKeyExInternalW(HKEY hKey, int a2, int a3, int a4, ULONG ResultLength, int a6);
int __stdcall MapPredefinedRegistryHandleToIndex(unsigned int a1);
// _DWORD __stdcall RtlGetCurrentTransaction(); idb
// int __stdcall RtlSetCurrentTransaction(_DWORD); weak
int __stdcall LocalBaseRegQueryValue(HANDLE, PUNICODE_STRING ValueName, int, int, int, int); // idb
LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
void __stdcall CLOSE_LOCAL_HANDLE_INTERNAL(int a1, PVOID Address);
ULONG __stdcall LocalBaseRegCloseKey(int *a1);
ULONG __stdcall BaseRegCloseKeyInternal(int *a1);
LSTATUS __stdcall RegCloseKey(HKEY hKey);
void __stdcall PoolPerAppKeyStateInternal();
// void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
DWORD __stdcall GetEnvironmentVariableAStub(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
// DWORD __stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
DWORD __stdcall GetModuleFileNameAStub(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// DWORD __stdcall GetCurrentProcessId();
HANDLE __stdcall CreateEventWStub(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
HANDLE __stdcall CreateMutexAStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
LPVOID __stdcall MapViewOfFileExStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
// LPVOID __stdcall MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress);
void __stdcall GetSystemTimeAsFileTimeStub(LPFILETIME lpSystemTimeAsFileTime);
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
void __stdcall DereferenceHandleUnit(PVOID Address);
BOOL __stdcall DuplicateHandleImplementation(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
HMODULE __stdcall GetModuleHandleAStub(LPCSTR lpModuleName);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LSTATUS __stdcall RegOpenKeyExInternalA(HKEY hKey, int a2, int a3, int a4, ULONG ResultLength, int a6);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
BOOL __stdcall DisableThreadLibraryCallsStub(HMODULE hLibModule);
// signed int __userpurge sub_77E2DB49@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
void __stdcall GetSystemInfoStub(LPSYSTEM_INFO lpSystemInfo);
HANDLE __stdcall CreateThreadStub(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
ULONG __stdcall LocalOpenLocalMachine(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);
// BOOL __stdcall IsWow64Process(HANDLE hProcess, PBOOL Wow64Process);
BOOL __stdcall GetVersionExAStub(LPOSVERSIONINFOA lpVersionInformation);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
BOOL __stdcall InitializeCriticalSectionExStub(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
// BOOL __stdcall InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
BOOL __stdcall IsTerminalServerCompatible();
NTSTATUS __stdcall ConnectConsoleInternal(int a1, int a2, int a3);
bool __stdcall BasepInitComputerNameCache();
char __stdcall InitializeRegTermsrvFpns(int a1, int a2);
char __stdcall BaseNlsSortingDllInitialize(int a1);
BOOL __stdcall InitializeRegWow64Flags();
__int32 __stdcall RealWerpInitializeMessageMapping();
__int32 __stdcall FSPErrorMessages::CMessageMapper::StaticInitialize(); // idb
__int32 __thiscall FSPErrorMessages::CMessageMapper::MustSucceedInit(PRTL_CRITICAL_SECTION CriticalSectionObject); // idb
void __stdcall GetStartupInfoWStub(LPSTARTUPINFOW lpStartupInfo);
signed int __stdcall PredefinedHandleTableCriticalSectionInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context);
// UINT __stdcall GetOEMCP();
ULONG *__stdcall BaseDllInitializeMemoryManager();
BOOL __stdcall ConsoleApp();
int __stdcall InitExeName();
int __stdcall InitializeCtrlHandling();
signed int __stdcall BaseDllInitializeIniFileMappings(int a1);
int *__stdcall BasepInitializePrefixDatabase();
int __stdcall BasepInitWER();
char __stdcall SetUpConsoleInfo(int a1, int a2);
ULONG __stdcall ParseReserved(wchar_t *Str, wchar_t *SubStr);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// _DWORD __stdcall _DllMainCRTStartupForGS2(_DWORD, _DWORD, _DWORD); weak
void __cdecl __security_init_cookie();
signed int __stdcall GetPerUserWindowsDirectory(WCHAR *a1, unsigned int a2, int a3);
int __stdcall IsTSAppCompatEnabled(int a1);
void *__stdcall InitializeConsoleConnectionInfo(void *Dst);
void *__stdcall SetUpAppName(int a1, void *Dst, int a3, void *a4);
PVOID __stdcall AllocatePredefinedHandleUnit(int a1);
// BOOL __stdcall CloseHandle(HANDLE hObject);
HANDLE __stdcall CreateFileWImplementation(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
const UNICODE_STRING *__stdcall BaseIsThisAConsoleName(int a1, int a2);
BOOL __stdcall InitializeCriticalSectionAndSpinCountStub(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
BOOL __stdcall SystemTimeToFileTimeStub(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
void __stdcall GetSystemTimeStub(LPSYSTEMTIME lpSystemTime);
HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
DWORD __stdcall GetFullPathNameAStub(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
int __stdcall IsRegTSAppCompatEnabled(int a1);
int __stdcall BasepProbeForDllManifest(HMODULE a1, const WCHAR *a2, int a3);
// UINT __stdcall GetDriveTypeW(LPCWSTR lpRootPathName);
UINT __stdcall GetDriveTypeWStub(LPCWSTR lpRootPathName);
// HANDLE __stdcall OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// HANDLE __userpurge BaseThreadInitThunk@<eax>(int (__cdecl *a1)(_DWORD)@<edx>, int a2@<ecx>, DWORD a3, BOOL a4, const CHAR *a5);
HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
UINT __stdcall GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
UINT __stdcall GetSystemDirectoryWStub(LPWSTR lpBuffer, UINT uSize);
UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);
UINT __stdcall GetSystemWindowsDirectoryWStub(LPWSTR lpBuffer, UINT uSize);
// HRSRC __stdcall FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
int __stdcall BasepInitializeTermsrvFpns();
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
int __stdcall WideCharToMultiByteStub(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
int __stdcall MultiByteToWideCharStub(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
DWORD __stdcall GetModuleFileNameWStub(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
BOOL __stdcall FreeLibraryStub(HMODULE hLibModule);
HANDLE __stdcall HeapCreateStub(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
signed int __stdcall RestrictArguments(int a1, int a2, int a3, int a4);
void *__stdcall ZeroDataOnFailure(int a1, void *Dst, size_t Size, int a4);
int __stdcall RegGetValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, int, LPDWORD lpType, void *Dst, size_t Size); // idb
signed int __stdcall RestrictRegType(unsigned __int16 a1, int a2, unsigned int a3, signed int a4);
// int __stdcall FixRegData(HKEY hKey, LPCWSTR lpValueName, int, int, int, int, ULONG Flags, int, char); idb
int __stdcall QueryValueInternalW(HKEY hKey, LPCWSTR lpValueName, int, LPDWORD lpType, LPBYTE lpData, ULONG Flags); // idb
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
DWORD __stdcall FlsAllocStub(PFLS_CALLBACK_FUNCTION lpCallback);
// DWORD __stdcall FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);
void __stdcall LoadAppInitDlls();
int __stdcall BasepIsServiceSidBlocked(int a1);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// BOOL __stdcall AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
int __stdcall BasepFillUEFInfo(LPCVOID lpAddress, int); // idb
BOOL __stdcall SetEnvironmentVariableWStub(LPCWSTR lpName, LPCWSTR lpValue);
// BOOL __stdcall SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
BOOL __stdcall HeapSetInformationStub(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
// BOOL __stdcall HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
// DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD __stdcall GetFullPathNameWStub(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// _DWORD _SEH_epilog4_GS(); weak
BOOL __stdcall UnmapViewOfFileStub(LPCVOID lpBaseAddress);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
LPVOID __stdcall TlsGetValueStub(DWORD dwTlsIndex);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
BOOL __stdcall TlsSetValueStub(DWORD dwTlsIndex, LPVOID lpTlsValue);
ULONG __stdcall BaseSetLastNTError(NTSTATUS NtStatus);
int __stdcall GetLocaleInfoWStub(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
int __stdcall SortCompareString(int a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall LongCompareString(int a1);
// HANDLE __stdcall GetProcessHeap();
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
int __stdcall GetCasingInfo(int a1, int a2);
int __stdcall GetSortTablesInfo(int a1, int a2);
PVOID __stdcall CreateSortNode();
int __stdcall SortGetHandle(STRSAFE_LPCWSTR, int, int); // idb
// int __stdcall InternalSortGetHandle(int, STRSAFE_LPCWSTR, int, STRSAFE_LPCWSTR pszSrc, int); idb
int __stdcall MakeSortNode(int, STRSAFE_LPCWSTR pszSrc, int); // idb
int __fastcall NlsCompareInvariantNoCase(unsigned __int16 *a1, unsigned __int16 *a2, int a3, int a4);
void *__stdcall GetSortkeyInfo(int a1, int a2);
int __cdecl CompareLocales(const void *a1, const void *a2);
// BOOL __stdcall DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// UINT __stdcall SetErrorMode(UINT uMode);
UINT __stdcall SetErrorModeStub(UINT uMode);
DWORD __fastcall CheckElevationEnabled(int a1, int a2, int a3);
signed int __stdcall GetDefaultSortTablesInfo(int a1, int a2);
signed int __stdcall GetDefaultCasingInfo(int a1, int a2);
signed int __stdcall GetCTypeInfo(int a1, int a2);
int __stdcall GetDefaultSortFileMapping(LPCWSTR lpFileName, int); // idb
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
// int __usercall sub_77E30675@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
DWORD __stdcall SetFilePointerStub(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL __stdcall IsCombiningJamo(unsigned __int16 a1);
// DWORD __stdcall GetFileAttributesW(LPCWSTR lpFileName);
// _DWORD __stdcall FindLFNorSFN_U(_DWORD, _DWORD, _DWORD, _DWORD); weak
PWSTR __stdcall SkipPathTypeIndicator_U(PWSTR Path);
NTSTATUS __stdcall BaseFormatObjectAttributes(int a1, int a2, int a3, int a4);
int __stdcall CreateProcessInternalW(void *a1, _DWORD a2, const wchar_t *a3, int a4, int a5, int a6, unsigned int a7, int a8, const WCHAR *a9, int a10, int a11, _DWORD a12);
// int __stdcall BaseGetProcessDllPath(_DWORD, _DWORD, _DWORD); weak
PRTL_USER_PROCESS_PARAMETERS __stdcall BasepCreateProcessParameters(int a1, NTSTATUS NtStatus, int a3, int a4, int a5, int a6, int a7, int a8);
// int __stdcall BaseReleaseProcessDllPath(_DWORD, _DWORD); weak
int __stdcall BasepCheckForInvalidPathSeparator(wchar_t *Str); // idb
// BOOL __stdcall IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
int __stdcall BasepIsRemovableMedia(HANDLE FileHandle, int); // idb
NTSTATUS __stdcall BasepSxsCloseHandles(int a1);
NTSTATUS __stdcall BasepGetPreferExternalManifestConfig(int a1);
signed int __stdcall BasepCheckWinSaferRestrictions(void *a1, int a2, int a3);
int __stdcall BasepIsProcessAllowed(int a1);
int __stdcall BasepCheckWebBladeHashes(int a1);
BOOL __stdcall BasepCheckImageVersion(unsigned int a1, unsigned int a2);
unsigned int __stdcall BasepGetTempPathW(int a1, int a2, WCHAR *buf);
signed int __stdcall IsShimInfrastructureDisabled();
int __stdcall BaseCheckAppcompatCacheEx(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int, int, int); // idb
int __stdcall BasepShimCacheLookup(PCWSTR SourceString, int, int, int, int); // idb
PCWSTR __stdcall BasepShimCacheSearch(PCWSTR SourceString, int a2, int a3, int a4, int a5);
int __stdcall BasepShimCacheCheckBypass(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int, int); // idb
int __stdcall sub_77E32585(PVOID Environment, int, int); // idb
int __stdcall BasepInitUserTempPath(PUNICODE_STRING ntname); // idb
int __stdcall BasepCheckStringPrefixUnicode(int SourceCharacter, int a2, int a3);
void __stdcall BasepFreeAppCompatData(PVOID Address, PVOID a2, PVOID a3);
__int16 __stdcall BasepGetExeType(int a1, int a2, int a3, int a4);
NTSTATUS sub_77E32826();
signed int __stdcall BasepQueryAppCompat(void *a1, int a2, int a3, int a4, void *a5, const WCHAR *a6, void *a7, int a8, int a9, int a10, int a11, int a12, int a13, void *a14, int a15, int a16, int a17);
signed int __stdcall BasepCheckBadapp(void *a1, void *a2, const WCHAR *a3, void *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, void *a12, int a13, int a14, int a15);
int __stdcall BasepCsrCaptureSxsMessage(int a1, int a2);
PHANDLE __stdcall BasepConstructSxsCreateProcessMessage(int a1, int a2, HANDLE FileHandle, int a4, int a5, int a6, ULONG Size, int a8, char a9, int a10, int a11, int a12, int Buffer, int a14, int a15, int a16, int a17, void *Dst, PHANDLE a19);
int __stdcall BasepGetDisableLocalOverrideConfig(LONG Exchange); // idb
char __stdcall BasepReleaseSxsCreateProcessUtilityStruct(int a1);
signed int __stdcall SbpIsTraceEnabled();
signed int __stdcall SbpDeriveVirtualOsVersionBasedOnEnvionmentVariable(wchar_t *a1, unsigned int a2, int a3, int a4, int a5);
signed int __stdcall BasepPrepareSwitchContext(int a1);
NTSTATUS __stdcall SbPrepareSwitchContext(int a1, ULONG a2);
NTSTATUS __stdcall SbpCreateSwitchContext(int a1, unsigned __int16 a2, unsigned __int16 a3, ULONG a4);
signed int __stdcall ULongAdd(unsigned __int32 a1, unsigned __int32 a2, unsigned __int32 *a3);
int __stdcall BasepGetAppCompatData(LONG_PTR lParam, int, int, int, int, int, char, int, int, int, int, int, int, int); // idb
int __thiscall BaseGenerateAppCompatData(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
NTSTATUS __stdcall BasepGetApphelpCreateAppcompatDataProc(int a1);
signed int __stdcall SbGetContextDetailsById(signed int a1, int a2);
unsigned int __stdcall BaseCheckElevation(HANDLE ProcessHandle, LONG_PTR lParam, int a3, int a4, char a5, int a6, int a7, char a8, int a9, int a10, int a11);
int __stdcall BaseCheckDetectionMethods(LONG_PTR lParam, int, int, int, int, char, int, int, int); // idb
int __stdcall BasepConvertFusionRunLevel(int a1, int a2, int a3);
NTSTATUS __stdcall BaseElevationPostProcessing(char a1, int ProcessInformation, HANDLE ProcessHandle);
int __stdcall BasepCheckCacheExcludeCustom(PCWSTR SourceString); // idb
int __stdcall BasepCheckCacheExcludeList(const WCHAR *a1);
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
HANDLE __stdcall FindFirstFileWStub(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
NTSTATUS __stdcall ConsoleClientCallServer(PPORT_MESSAGE RequestMessage, int a2, int a3, int a4);
signed int __fastcall SetTEBLangID(int a1);
signed int __stdcall GetConsoleLangId(int a1);
// BOOL __stdcall FindClose(HANDLE hFindFile);
DWORD __stdcall GetFileAttributesWStub(LPCWSTR lpFileName);
BOOL __stdcall FindCloseStub(HANDLE hFindFile);
DWORD __stdcall GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);
signed int __stdcall IsLongName_U(int a1, signed int a2);
DWORD __stdcall GetLongPathNameWStub(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);
UINT __stdcall GetConsoleOutputCP();
HANDLE __stdcall OpenFileMappingWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
signed int __stdcall SetCtrlHandler(int a1);
NTSTATUS RtlSIZETAdd(SIZE_T Augend, SIZE_T Addend, SIZE_T *pResult);
NTSTATUS RtlULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult);
BOOL __stdcall TlsFreeStub(DWORD dwTlsIndex);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
DWORD __stdcall GetEnvironmentVariableWStub(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
int __stdcall LCMapStringWStub(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
HANDLE __stdcall OpenThreadStub(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// HANDLE __stdcall OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);
// int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
int __stdcall lstrcmpWStub(LPCWSTR lpString1, LPCWSTR lpString2);
BOOL __stdcall GetStringTypeWStub(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// BOOL __stdcall GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
signed int __stdcall BasepFindActCtxSection_CheckAndConvertParameters(int a1, int a2, int a3);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WriteFileImplementation(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
int __stdcall InstallDetect(LONG_PTR lParam, int, int); // idb
int __stdcall InstallDetectInternal(int, int, int, LONG_PTR lParam); // idb
int __stdcall ByteMatch(DWORD a1, int a2, int a3);
int __stdcall TestStringTableEntry(HRSRC hResInfo, int); // idb
signed int __stdcall TestResourceDataMatchEntry(int a1, int a2);
signed int __stdcall LoadImageMappings(int a1);
int __stdcall SXSManifest(int, int, LONG_PTR lParam); // idb
signed int __stdcall LoadImageFile(int a1);
signed int __stdcall Load32BitPEHeaders(int a1);
int __stdcall ByteMatchGetSection(int, char *Str2, int, int); // idb
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
int __stdcall StringTable(HRSRC hResInfo, int, int); // idb
int __stdcall ResourceDataMatch(int a1, int a2, int a3);
int __stdcall ByteMatchGetAppendedDataOffset(int a1, int a2);
int __stdcall NonInstallerDefault(int a1, int a2, int a3);
BOOL __stdcall FreeImageInfo(int a1);
signed int __stdcall TestByteMatchEntry(int a1, unsigned int a2, int a3);
BOOL __stdcall GetExitCodeProcessImplementation(HANDLE hProcess, LPDWORD lpExitCode);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
LONG __stdcall CompareFileTimeStub(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// LONG __stdcall CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// BOOL __stdcall GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
BOOL __stdcall GetVolumeInformationWStub(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
int __stdcall GetVolumeNameForRoot(PWSTR dosname, int, int); // idb
BOOL __stdcall GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength);
int __stdcall GetVolumePathNameInternalW(int, LPCWSTR lpFileName, int, int); // idb
BOOL __stdcall GetVolumePathNameWStub(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength);
int __stdcall BasepGetVolumeNameFromReparsePoint(LPCWSTR lpFileName, void *Dst, int, int); // idb
DWORD __stdcall GetFileTypeImplementation(HANDLE hFile);
// DWORD __stdcall GetFileType(HANDLE hFile);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
BOOL __stdcall VirtualFreeStub(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
ULONG __stdcall LocalOpenCurrentUser(int a1, int a2, int a3);
BOOL __stdcall FreeEnvironmentStringsWStub(LPWCH);
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
HANDLE __stdcall FindFirstFileExWStub(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// HANDLE __stdcall FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
BOOL __stdcall SetCurrentDirectoryWStub(LPCWSTR lpPathName);
// BOOL __stdcall SetCurrentDirectoryW(LPCWSTR lpPathName);
DWORD __stdcall GetFileAttributesAStub(LPCSTR lpFileName);
// DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName);
BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
SIZE_T __stdcall VirtualQueryStub(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
PVOID __stdcall FlsGetValueStub(DWORD dwFlsIndex);
// PVOID __stdcall FlsGetValue(DWORD dwFlsIndex);
BOOL __stdcall FlsSetValueStub(DWORD dwFlsIndex, PVOID lpFlsData);
// BOOL __stdcall FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData);
BOOL __stdcall GetCPInfoStub(UINT CodePage, LPCPINFO lpCPInfo);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
HANDLE __stdcall GetStdHandleStub(DWORD nStdHandle);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
UINT __stdcall SetHandleCount(UINT uNumber);
// HANDLE __stdcall OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
HANDLE __stdcall OpenMutexWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
int __stdcall StateObjectInit(int a1, int a2);
int __stdcall StateObjectListInit(int a1, int a2);
BOOL __stdcall ClassesEnumTableInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context);
NTSTATUS __stdcall EnumTableInit(int a1);
// BOOL __stdcall FlsFree(DWORD dwFlsIndex);
BOOL __stdcall FlsFreeStub(DWORD dwFlsIndex);
BOOL __stdcall FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
signed int __stdcall BasepFindActCtxSectionString(int a1, int a2, int a3, int a4, int a5);
DWORD __stdcall GetCurrentDirectoryWStub(DWORD nBufferLength, LPWSTR lpBuffer);
// DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
signed int __stdcall BasepFindActCtxSection_FillOutReturnData(char a1, int a2, int a3);
BOOL __stdcall IsValidCodePageStub(UINT CodePage);
// BOOL __stdcall IsValidCodePage(UINT CodePage);
bool __stdcall CleanupClassesEnumTable(int a1);
void __stdcall EnumTableClear(int a1, int a2);
int __stdcall StateObjectListClear(int a1, void (__stdcall *a2)(_DWORD));
NTSTATUS __stdcall BasepUnInitComputerNameCache();
bool __stdcall CleanupPredefinedHandlesTable();
void __thiscall FSPErrorMessages::CMessageMapper::Reset(FSPErrorMessages::CMessageMapper *__hidden this); // idb
void __stdcall RealWerpCleanupMessageMapping();
void __stdcall FSPErrorMessages::CMessageMapper::StaticCleanup(); // idb
void __thiscall FSPErrorMessages::CMessageMapper::MustSucceedCleanup(PRTL_CRITICAL_SECTION CriticalSectionObject); // idb
signed int __stdcall CleanupPerAppKey();
void __stdcall ExitProcessStub(int a1);
BOOL __stdcall TerminateThreadStub(HANDLE hThread, DWORD dwExitCode);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// _DWORD __stdcall GetThreadUILanguage(); idb
PVOID __stdcall ConsoleAllocateCaptureBuffer(unsigned int a1, unsigned int a2);
NTSTATUS __stdcall ConsoleConnect(const void *a1, int a2, int a3);
NTSTATUS __stdcall RtlStringCchCopyNW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc, size_t cchSrc);
// signed int __userpurge sub_77E3C090@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
NTSTATUS RtlStringCchPrintfW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszFormat, ...);
int __stdcall VerifyConsoleIoHandle(int a1);
BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
LANGID __stdcall SetThreadUILanguage(LANGID LangId);
int __stdcall ResetThreadUIPreferredLanguage();
BOOLEAN __stdcall ConsoleFreeCaptureBuffer(PVOID Address);
int __stdcall ConsoleCaptureMessageBuffer(int, void *Src, size_t Size, int); // idb
DWORD __stdcall GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize);
size_t __stdcall GetConsoleTitleInternal(int a1, size_t cbDest, char a3, char a4);
NTSTATUS __stdcall RtlStringCbCopyW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc);
BOOL __stdcall NeedCurrentDirectoryForExePathWStub(LPCWSTR ExeName);
// BOOL __stdcall NeedCurrentDirectoryForExePathW(LPCWSTR ExeName);
int __stdcall SetConsoleInputExeNameW(void *Src); // idb
signed int __stdcall CloseConsoleHandle(int a1);
signed int __stdcall DuplicateConsoleHandle(int a1, int a2, char a3, int a4);
HRESULT StringCbPrintfW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszFormat, ...);
int __stdcall IsSystemLUID();
int __stdcall QueryActCtxSettingsW(int, int, PCWSTR SourceString, int, int, int, int); // idb
BOOL __stdcall FreeEnvironmentStringsAStub(LPCH);
// BOOL __stdcall FreeEnvironmentStringsA(LPCH);
int __stdcall CreateProcessInternalA(int, ULONG, ULONG Flags, int, int, int, int, int, ULONG, int, int, int); // idb
BOOL __stdcall GetUILanguageInfoStub(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes);
// BOOL __stdcall GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes);
DWORD __stdcall GetPriorityClassStub(HANDLE hProcess);
// DWORD __stdcall GetPriorityClass(HANDLE hProcess);
BOOL __stdcall CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
int __stdcall BasepOfShareToWin32Share(char a1);
// PVOID __stdcall RtlAllocateHeap(HANDLE HeapHandle, ULONG Flags, ULONG Size);
// NTSTATUS __stdcall RtlAppendUnicodeToString(PUNICODE_STRING Destination, PWSTR Source);
// BOOLEAN __stdcall RtlDoesFileExists_U(PWSTR FileName);
HFILE __stdcall OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
int __stdcall BasepSxsCreateProcessCsrMessage(int, int, int, int, int, int, PHANDLE FileHandle, int, PHANDLE, int, PHANDLE, int, int Buffer, void *Dst); // idb
NTSTATUS __stdcall BasepSxsGetProcessImageBaseAddress(int a1, int Buffer);
// NTSTATUS __stdcall NtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferLength, PULONG ReturnLength);
NTSTATUS __stdcall BasepCheckDotLocalExists(int a1, int a2);
// BOOLEAN __stdcall RtlFreeHeap(HANDLE HeapHandle, ULONG Flags, PVOID Address);
// DWORD __stdcall RtlNtStatusToDosErrorNoTeb(NTSTATUS StatusCode);
int __stdcall EnumTableGetRootState(int a1, int a2);
int __stdcall EnumTableUpdateRootState(int, void *Dst, int, int); // idb
signed int __stdcall EnumStateCopy(int a1, int a2);
BOOL __stdcall SetNamedPipeHandleStateStub(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
// BOOL __stdcall SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);
BOOL __stdcall DisconnectNamedPipeStub(HANDLE hNamedPipe);
// BOOL __stdcall DisconnectNamedPipe(HANDLE hNamedPipe);
BOOL __stdcall EnumDateFormatsExExStub(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);
// BOOL __stdcall EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);
BOOL __stdcall EnumTimeFormatsExStub(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);
// BOOL __stdcall EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);
BOOL __stdcall IsValidLocaleNameStub(LPCWSTR lpLocaleName);
// BOOL __stdcall IsValidLocaleName(LPCWSTR lpLocaleName);
int __stdcall FindNLSStringExStub(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
// int __stdcall FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
int __stdcall FindFirstIndexOfString(int a1, int a2);
BOOL __stdcall IsValidCalId(unsigned int a1);
BOOL __stdcall EnumCalendarInfoExExStub(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam);
// BOOL __stdcall EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam);
signed int __stdcall GetCalendarSupportedDateRange(unsigned int a1, int a2, int a3);
signed int __stdcall GetGregorianSupportedDateRange(int a1, int a2);
signed int __stdcall ConvertSystemTimeToCalDateTime(int a1, unsigned int a2, int a3);
signed int __stdcall ConvertSystemTimeToGregorianDateTime(int a1, int a2, void *a3);
int __stdcall ConvertNLSDayOfWeekToWin32DayOfWeek(unsigned int a1);
int __stdcall GetCalendarMonthsInYear(unsigned int a1, int a2, int a3);
int __stdcall GetGregorianMonthsInYear(int a1, int a2);
signed int __stdcall CopyCalDateTime(void *a1, const void *a2);
signed int __stdcall IsValidGregorianTime(int a1, int a2);
signed int __stdcall IsValidCalDateTime(int a1, int a2);
signed int __stdcall IsValidGregorianDateTime(int a1, int a2, int a3);
unsigned int __stdcall GetGregorianDayOfWeekHelper(int a1);
int __stdcall GetAbsoluteDateFromGregorian(unsigned int a1, int a2, int a3);
signed int __stdcall UpdateCalendarDayOfWeek(int a1);
signed int __stdcall UpdateGregorianDayOfWeek(int a1);
signed int __stdcall GetCalendarDateFormatEx(int a1, int a2, int a3, void *a4, wchar_t *a5, int a6);
int __stdcall NlsValidateNamedLocale(int a1);
int __stdcall IsGregorianLeapYear(int a1, int a2);
signed int __stdcall IsValidGregorianYear(int a1, int a2);
signed int __stdcall IsValidGregorianMonthAndDay(unsigned int a1, int a2, int a3, int a4);
int __stdcall GetCalendarDateFormat(LCID Locale, int a2, int a3, void *a4, wchar_t *a5, int a6);
signed int __stdcall AdjustCalendarDate(int a1, int a2, int a3);
int __stdcall AdjustMonthsInTwelveMonthCalendars(int a1, int a2);
int __thiscall GetCalendarDaysInMonth(void *this, int a2, unsigned int a3, unsigned int a4, int a5);
signed int __stdcall GetGregorianDaysInMonth(int a1, unsigned int a2, int a3);
BOOL __stdcall NlsGregorianLeapYear(unsigned int a1);
signed int __stdcall GetCalendarDifferenceInDays(const void *a1, int a2, int a3);
int __stdcall GetGregorianDifferenceInDays(int a1, int a2);
// _DWORD __stdcall AdjustGregorianDays(_DWORD, _DWORD); weak
int __stdcall GetGregorianFromAbsoluteDate(signed int a1, void *a2);
BOOL __stdcall IsTimeZoneRedirectionEnabled();
int __stdcall GetNumberFormatExStub(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
int __stdcall K32QueryWorkingSet(HANDLE ProcessHandle, PVOID MemoryInformation, ULONG MemoryInformationLength); // idb
int __stdcall SetFileCompletionNotificationModes(HANDLE FileHandle, int FileInformation); // idb
BOOL __stdcall GetSystemTimes(LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
DWORD __stdcall GetProcessIdOfThreadStub(HANDLE Thread);
// DWORD __stdcall GetProcessIdOfThread(HANDLE Thread);
BOOL __stdcall EnumUILanguagesProcW(LPWSTR Str, LONG_PTR a2);
int __stdcall GetInstalledMUILanguages(HMODULE hModule, int); // idb
int __stdcall EnumResourceLanguagesInternal(int, PWCHAR UnicodeString, int, int, int, char, int, char); // idb
BOOL __stdcall EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam);
BOOL __stdcall EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
BOOL __stdcall GetDiskFreeSpaceAStub(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
// BOOL __stdcall GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
int __stdcall LCMapStringAStub(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
int __stdcall BaseDllWriteSection(STRING *String1); // idb
BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
// int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD); weak
// wchar_t *__cdecl _ui64tow(unsigned __int64 Val, wchar_t *DstBuf, int Radix);
int __stdcall NlsPadInt64ToUnicodeStr(unsigned __int64 Val, int, int, int, int); // idb
int __stdcall DoFormatDuration(unsigned __int64 a1, int a2, int a3, int a4);
int __stdcall GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration);
int __stdcall GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration);
int __stdcall GetDurationFormatWorker(int a1, int a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8);
BOOL __stdcall GetVolumeInformationByHandleWStub(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
// BOOL __stdcall GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
HRESULT __stdcall GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags);
int __stdcall WerpGetRecoveryRoutine(HANDLE hProcess, void *Dst); // idb
HRESULT __stdcall WerGetFlags(HANDLE hProcess, PDWORD pdwFlags);
signed int __stdcall WerpGetFlags(HANDLE hProcess, PDWORD pdwFlags);
BOOL __stdcall BasepIsDebugPortPresent();
signed int __stdcall WerpReportExceptionInProcessContext(int a1);
int __stdcall CheckForReadOnlyResourceFilter(int a1);
int __stdcall CheckForReadOnlyResource(int a1, int a2);
BOOL __stdcall GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry);
int __stdcall BasepIsKernelDebuggerPresent();
int __stdcall __noreturn WerpReportFaultInternal(int a1, int a2);
LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
signed int __stdcall BasepReportFault(int a1, int a2);
signed int __stdcall WerpReportFault(int a1, int a2);
int __stdcall MapReturnCode(__int32 a1);
BOOL __stdcall FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData);
void *__stdcall BasepInitializeFindFileHandle(int a1);
HANDLE __stdcall FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags);
int __stdcall GetStringScripts(int, int, int, unsigned __int16 *, unsigned int); // idb
HRESULT __stdcall UnregisterApplicationRecoveryCallback();
HRESULT __stdcall UnregisterApplicationRestart();
BOOL __stdcall InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);
BOOL __stdcall InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext);
signed int __stdcall WerpRegisterRecovery(int a1, int a2, int a3, int a4);
HRESULT __stdcall RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags);
HANDLE __stdcall CreateMutexExWStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// HANDLE __stdcall CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
int __stdcall CompareStringExStub(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
// int __stdcall CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
BOOL __stdcall SetSystemTime(const SYSTEMTIME *lpSystemTime);
// _DWORD __stdcall InvalidateTzSpecificCache(); idb
BOOL __stdcall DefineDosDeviceWStub(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath);
// BOOL __stdcall DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath);
BOOL __stdcall CreatePipeStub(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
// BOOL __stdcall CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
BOOL __stdcall CancelIo(HANDLE hFile);
int __fastcall NlsConvertIntegerToHexStringW(unsigned int a1, int a2, unsigned int a3, unsigned int a4);
BOOL __stdcall DeleteTimerQueueExStub(HANDLE TimerQueue, HANDLE CompletionEvent);
// BOOL __stdcall DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent);
DWORD __stdcall SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
DWORD __stdcall SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor);
BOOL __stdcall BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags);
int __stdcall BasepCopyFileCallback(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8);
// errno_t __cdecl wcscat_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src);
BOOL __stdcall ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
int __stdcall BasepSetFileEncryptionCompression(int, PHANDLE FileHandle, int, int, int, int, char); // idb
int __stdcall BasepCopyAlternateDataStreams(HANDLE FileHandle, HANDLE, char); // idb
int __stdcall BasepCopySecurityInformation(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8, char a9, int a10, int a11);
NTSTATUS __stdcall BasepCopyCreatorOwnerACE(PACL Acl, PSID Sid1, PSID a3);
int __stdcall BaseDllReadVariableNames(int a1, int a2);
BOOL __stdcall SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);
BOOL __stdcall FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
signed int __stdcall FillConsoleOutput(int a1, __int16 a2, int a3, int a4, int a5, int a6);
__int16 __stdcall GetCurrentExeName(void *Dst, int a2);
BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
int __stdcall ReadConsoleInternal(int, int, int, int, int, char, int, void *Src); // idb
int __stdcall BasepProcessInvalidImage(int, HANDLE TokenHandle, LPCWSTR lpFileName, int, NTSTATUS NtStatus, int, int, int, int, int, int, ULONG MessageBoxResult, int, int, PUNICODE_STRING UnicodeString, PANSI_STRING DestinationString, PCUNICODE_STRING SourceString, int, PVOID Address, int, int); // idb
signed int __stdcall BaseIsDosApplication(int a1, int a2);
signed int __stdcall BaseCheckVDMp(int a1, const WCHAR *a2, wchar_t *a3, const WCHAR *a4, int a5, int a6, int a7, int a8, int a9, void *a10);
BOOL __stdcall GetDiskFreeSpaceExAStub(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// BOOL __stdcall GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
LSTATUS __stdcall RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
ULONG __stdcall LocalBaseRegSaveKeyEx(int a1, HANDLE FileHandle, int a3, int a4);
BOOL __stdcall MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
int __stdcall MoveFileWithProgressTransactedA(const char *a1, const char *a2, int a3, int a4, int a5, int a6);
HWND __stdcall GetConsoleWindow();
BOOL __stdcall IsProcessInJobStub(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);
HRESULT __stdcall WerUnregisterMemoryBlock(PVOID pvAddress);
LSTATUS __stdcall RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags);
ULONG __stdcall LocalBaseRegRestoreKey(HANDLE KeyHandle, HANDLE Handle, ULONG Flags);
int __stdcall ValStateGetPhysicalIndexFromLogical(int a1, int a2, int a3, int a4, int a5);
NTSTATUS __stdcall BaseRegGetClassKeyValueState(PVOID Address, int a2, int a3);
NTSTATUS __stdcall ValStateSetPhysicalIndexFromLogical(ULONG Index, int a2);
int __stdcall KeyStateGetValueState(HANDLE KeyHandle, int); // idb
int __stdcall ValStateInitialize(int, HANDLE KeyHandle); // idb
BOOL __stdcall EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam);
BOOL __stdcall EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
int __stdcall EnumResourceTypesInternal(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3, char a4, SIZE_T pResult, char a6);
int __stdcall WerpGetHeaderFromProcess(HANDLE hProcess, struct _WER_PEB_HEADER_BLOCK *lpBuffer);
signed int __stdcall WerpGetPebFromProcess(HANDLE ProcessHandle, struct _PEB *lpBuffer);
void __stdcall __noreturn DefaultHandler(int a1);
signed int __stdcall CtrlRoutine(int a1);
HRESULT __stdcall GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags);
int __stdcall WerpGetRestartCommandLine(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags);
BOOLEAN __stdcall BasepFreePrefixAlias(PVOID Address);
int __fastcall NlsCompareRgWChar(int a1, int a2, int a3);
BOOL __stdcall ReadFileExStub(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// BOOL __stdcall ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
BOOL __stdcall WriteFileExStub(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// BOOL __stdcall WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
char __stdcall SkipUnsortable(int *a1, int a2);
int __stdcall FindNLSStringStub(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound);
// int __stdcall FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound);
int __stdcall SortFindString(int a1, int a2, int a3, signed int a4, int a5, signed int a6, int a7, int a8, int a9);
int __stdcall FindLastIndexOfString(PVOID Address, int); // idb
int __fastcall NlsCountOfWCharsWithinRange(unsigned __int16 *a1, unsigned int a2, int a3, unsigned __int16 a4, unsigned __int16 a5, int a6, signed int a7);
BOOL __stdcall PulseEventStub(HANDLE hEvent);
// BOOL __stdcall PulseEvent(HANDLE hEvent);
int __stdcall WerpNotifyUseStringResource(struct tagWerStringResourceData *a1);
int __stdcall RealWerpNotifyUseStringResource(struct tagWerStringResourceData *); // idb
signed int __thiscall FSPErrorMessages::CMessageMapper::NotifyUseStringResource(FSPErrorMessages::CMessageMapper *this, struct tagWerStringResourceData *a2);
int __stdcall K32GetProcessMemoryInfo(HANDLE ProcessHandle, int, int); // idb
DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
BOOL __stdcall GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
NTSTATUS __stdcall ClassKeyCountSubKeys(int a1, int a2, HANDLE a3, int a4, int a5);
NTSTATUS __stdcall GetSubKeyCount(HANDLE KeyHandle, int a2);
BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
DWORD __stdcall GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);
PCUNICODE_STRING __stdcall BaseDllReadApplicationVariables(int a1, int a2);
LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
// int __cdecl _wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
BOOL __stdcall IsDBCSLeadByteExStub(UINT CodePage, BYTE TestChar);
// BOOL __stdcall IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar);
int __stdcall GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue);
// BOOL __stdcall GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
int __stdcall BaseDllReadKeywordNames(STRING *String1); // idb
int __stdcall K32GetModuleFileNameExA(HANDLE hProcess, int Buffer, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr); // idb
BOOL __stdcall K32EnumProcesses(DWORD *lpidProcess, DWORD cb, LPDWORD lpcbNeeded);
BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
int __stdcall BaseDllCalculateDeleteLength(int a1);
BOOL __stdcall MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
BOOL __stdcall IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax);
bool __stdcall BasepShimCacheRemoveEntry(PCWSTR SourceString, int a2);
int __stdcall FoldStringWStub(DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// int __stdcall FoldStringW(DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
int __stdcall GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate);
int __stdcall GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime);
int __stdcall ConverStringWithHeapAlloc(PWCHAR UnicodeString, int, ULONG ResultSize); // idb
BOOL __stdcall EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam);
BOOL __stdcall EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
size_t __stdcall QueryRegValue(HANDLE KeyHandle, PCWSTR SourceString, int a3, size_t Size, int a5, int a6);
// int __stdcall OpenRegKey(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
GEOID __stdcall GetUserGeoID(GEOCLASS GeoClass);
// __int32 __cdecl _wtol(const wchar_t *Str);
DWORD __stdcall GetProcessHeapsStub(DWORD NumberOfHeaps, PHANDLE ProcessHeaps);
// DWORD __stdcall GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps);
DWORD __stdcall GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize);
UINT __stdcall GetWindowsDirectoryAStub(LPSTR lpBuffer, UINT uSize);
// UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
BOOL __stdcall EnumSystemLocalesAStub(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags);
// BOOL __stdcall EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags);
LPWSTR __stdcall lstrcpynWStub(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
// LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
DWORD __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
BOOL __stdcall EnumDateFormatsWStub(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags);
// BOOL __stdcall EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumTimeFormatsWStub(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags);
// BOOL __stdcall EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
// int __stdcall Internal_EnumCalendarInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
BOOL __stdcall WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);
// LANGID __stdcall GetUserDefaultLangID();
BOOL __stdcall UnlockFileStub(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);
// BOOL __stdcall UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);
BOOL __stdcall LockFileStub(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
// BOOL __stdcall LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
UINT __stdcall GlobalFlags(HGLOBAL hMem);
char __stdcall BaseDllGetVariableValue(ULONG ResultSize, int a2, int a3, int a4);
int __stdcall BaseDllWriteKeywordValue(STRING *String1, int); // idb
NTSTATUS __stdcall BaseDllModifyMappedFile(int a1, void *Dst, int a3, void *Src, size_t Size);
BOOL __stdcall TermsrvAppInstallMode();
BOOL __stdcall LockFileExStub(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);
BOOL __stdcall UnlockFileExStub(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);
BOOL __stdcall CreateDirectoryAStub(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
ATOM __stdcall GlobalFindAtomA(LPCSTR lpString);
DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);
UINT __stdcall GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
int __stdcall PrivCopyFileExW(const WCHAR *a1, const WCHAR *a2, int a3, int a4, int a5, int a6);
LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);
DWORD __stdcall SuspendThreadStub(HANDLE hThread);
// DWORD __stdcall SuspendThread(HANDLE hThread);
// int __stdcall GetUserInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
BOOL __stdcall GetTimeZoneInformationForYearStub(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi);
// BOOL __stdcall GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi);
BOOL __stdcall GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes);
UINT __stdcall GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize);
int __stdcall GetDigitRange(unsigned __int16 *a1, int a2);
int __stdcall BasepCheckAppCompat(HANDLE FileHandle, int, int, int); // idb
DWORD __stdcall CheckElevation(LPCWSTR lpFileName, int a2, int a3, int a4, int a5);
int __stdcall BasepCheckFusion(int, PVOID pvBuffer); // idb
// NTSTATUS __stdcall NtCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER SectionSize, ULONG Protect, ULONG Attributes, HANDLE FileHandle);
BOOL __stdcall WriteProcessMemoryStub(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
BOOL __stdcall GetUserPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// BOOL __stdcall GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
BOOL __stdcall EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam);
BOOL __stdcall Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL __stdcall Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
int __stdcall BaseRegMapClassRegistrationKey(int, int, HANDLE Handle, int, int, int, PHANDLE KeyHandle, int, int); // idb
int __stdcall BaseRegOpenClassKeyRoot(int, PHANDLE KeyHandle, PUNICODE_STRING DestinationString, int, int); // idb
NTSTATUS __stdcall LUAIsElevatedToken(HANDLE TokenHandle, int a2, ULONG ReturnLength);
int __thiscall BasepCheckForElevatedCaller(void *this, HANDLE TokenHandle, int a3, int a4);
signed int __stdcall LUAShouldElevate(unsigned int a1, unsigned int a2, int a3);
NTSTATUS __stdcall LUAGetUserType(HANDLE TokenHandle, ULONG a2);
NTSTATUS __stdcall LUAIsUIAToken(HANDLE TokenHandle, ULONG ReturnLength);
BOOL __stdcall SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);
DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);
bool __stdcall BaseUpdateAppcompatCache(PCWSTR SourceString, int a2, int a3);
char __stdcall BaseQueryModuleData(PCWSTR SourceString, int a2, int a3, int a4, int a5, int a6, int a7);
char __stdcall BasepQueryModuleData(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
NTSTATUS __stdcall BasepGetApphelpQueryModuleDataProc(int a1);
EXECUTION_STATE __stdcall SetThreadExecutionState(EXECUTION_STATE esFlags);
DWORD __stdcall FormatMessageAStub(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// _DWORD __cdecl _local_unwind4(_DWORD, _DWORD, _DWORD); weak
// int __fastcall _EH4_CallFilterFunc(_DWORD, _DWORD); weak
// int __fastcall _EH4_TransferToHandler(_DWORD, _DWORD); weak
// int __thiscall _EH4_GlobalUnwind(PVOID TargetFrame); idb
// _DWORD __stdcall _EH4_LocalUnwind(_DWORD, _DWORD); weak
// LONG __usercall sub_77E4A5FF@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_77E4A610(int a1@<ebp>);
int __thiscall nullsub_1(_DWORD); // weak
// BOOL __stdcall SetLocalTime(const SYSTEMTIME *lpSystemTime);
UINT __stdcall LocalFlags(HLOCAL hMem);
HLOCAL __stdcall LocalHandle(LPCVOID pMem);
INT __stdcall LZStart();
// HANDLE __stdcall CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
char __stdcall BasepLoadAppInitDlls(HKEY hKey);
int __stdcall ResetAccessDate(HANDLE hFile); // idb
signed int __stdcall ComputeRemainingSize(int a1, int a2);
signed int __stdcall ComputeRequestSize(int a1, unsigned int a2, int a3);
int __stdcall ReportTransfer(int a1, int a2, unsigned int a3);
int __stdcall BackupReadBuffer(int, size_t Size); // idb
int __stdcall BackupReadStream(HANDLE hFile, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead); // idb
signed int __stdcall BackupTestRestartStream(int a1);
BOOL __stdcall BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext);
signed int __stdcall BackupWriteHeader(int a1, int a2, unsigned int a3);
int __stdcall BackupWriteSparse(int, DWORD nNumberOfBytesToWrite, int); // idb
int __stdcall BackupWriteStream(HANDLE FileHandle, DWORD nNumberOfBytesToWrite, int); // idb
int __stdcall BackupWriteAlternateData(int, DWORD nNumberOfBytesToWrite, int); // idb
BOOL __stdcall BasepIsDataAttribute(unsigned int a1, int a2);
PVOID __stdcall BackupAlloc(ULONG Size);
int __stdcall GrowBuffer(int, ULONG Size); // idb
char __stdcall FreeBuffer(int a1);
BOOLEAN __stdcall FreeContext(int a1);
PVOID __stdcall AllocContext(ULONG Size);
int __stdcall BackupGetSparseMap(HANDLE hFile, int, int); // idb
int __stdcall BackupReadData(HANDLE hFile, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead); // idb
int __stdcall BackupReadAlternateData(HANDLE FileHandle, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead); // idb
int __stdcall BackupReadEaData(HANDLE FileHandle, int FileInformation, size_t Size); // idb
int __stdcall BackupReadObjectId(HANDLE FileHandle, int, size_t Size); // idb
int __stdcall BackupReadTxFsData(HANDLE FileHandle, int, size_t Size); // idb
int __stdcall BackupReadReparseData(HANDLE FileHandle, int, size_t Size); // idb
int __stdcall BackupReadSecurityData(HANDLE Handle, int, ULONG ReturnLength); // idb
BOOL __stdcall BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext);
int __stdcall BackupWriteBuffer(size_t Size, int); // idb
int __stdcall BackupWriteEaData(HANDLE FileHandle, size_t Size, int); // idb
int __stdcall BackupWriteReparseData(HANDLE FileHandle, size_t Size, int); // idb
int __stdcall BackupWriteObjectId(HANDLE FileHandle, size_t Size, int); // idb
int __stdcall BackupWriteTxFsData(HANDLE FileHandle, size_t Size, int); // idb
int __stdcall BackupWriteSecurityData(HANDLE Handle, size_t Size, SECURITY_INFORMATION SecurityInformation); // idb
int __stdcall BackupWriteLinkData(HANDLE FileHandle, size_t Size, int); // idb
BOOL __stdcall BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext);
int __stdcall NotifySoundSentry();
BOOL __stdcall BeepImplementation(DWORD dwFreq, DWORD dwDuration);
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult);
NTSTATUS __stdcall BasepGetNameFromReg(PCWSTR SourceString, int a2, int a3, int a4);
BOOLEAN __stdcall BaseConvertCharFree(PVOID Address);
NTSTATUS __stdcall BaseSetNameInReg(PCWSTR SourceString, PCWSTR a2, PVOID Data);
NTSTATUS __stdcall BaseSetMultiNameInReg(PCWSTR SourceString, PCWSTR a2, PVOID Data, ULONG DataSize);
signed int __stdcall BasepGetMultiValueAddr(const unsigned __int16 *a1, unsigned int a2, int a3, int a4);
int __stdcall BaseGetMultiValueIndex(int, void *, int); // idb
signed int __stdcall BaseRemoveMultiValue(const unsigned __int16 *a1, unsigned int a2, int a3);
int __stdcall BaseAddMultiValue(int, int, wchar_t *Src, int); // idb
int __stdcall BaseValidateNetbiosName(ULONG MbSize); // idb
signed int __stdcall BaseValidateFQDnsName(int a1);
int __stdcall BaseSetNetbiosName(PVOID Data); // idb
int __stdcall BaseSetDnsName(PCWSTR SourceString); // idb
int __stdcall BaseSetDnsDomain(PVOID Data); // idb
ULONG __stdcall BaseEnumAltDnsFQHostnames(int a1, int a2);
BOOL __stdcall SetComputerNameW(LPCWSTR lpComputerName);
BOOL __stdcall SetComputerNameA(LPCSTR lpComputerName);
BOOL __stdcall DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize);
int __stdcall BasepGetComputerNameFromNtPath(PSTRING String2, int, int, int); // idb
DWORD __thiscall BaseMultiByteToWideCharWithAlloc(ULONG this, LPCSTR lpMultiByteStr, int a3);
NTSTATUS __stdcall BaseCreateMultiValue(PCWSTR SourceString, PCWSTR a2, void *Src);
NTSTATUS __stdcall BaseAddMultiNameInReg(PCWSTR SourceString, PCWSTR a2, wchar_t *Src);
int __stdcall BaseRemoveMultiNameFromReg(PCWSTR SourceString, PCWSTR, void *); // idb
PVOID __stdcall BasepGetNameNonVolatileFromReg(int a1);
PVOID __stdcall BasepGetComputerNameExWRtlAlloc(COMPUTER_NAME_FORMAT NameType);
PVOID __stdcall BasepGetNameNonVolatile(wchar_t *Src);
PVOID __stdcall BasepGetLatestName(wchar_t *Src);
signed int __stdcall BaseValidateDns(void *a1, int a2);
signed int __stdcall BaseValidateDnsHostname(void *a1);
// _DWORD __stdcall BaseValidateDnsDomain(_DWORD); weak
wchar_t *__stdcall BaseParseDnsName(wchar_t *Str, int a2);
int __stdcall BaseSetAltNetBiosName(ULONG MbSize); // idb
int __stdcall BaseSetAltDnsFQHostname(wchar_t *Src); // idb
int __stdcall BaseIsAltDnsFQHostname(void *); // idb
int __stdcall BaseRemoveAltNetBiosName(void *); // idb
int __stdcall BaseIsNetBiosNameInUse(wchar_t *); // idb
BOOL __stdcall SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer);
BOOL __stdcall SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer);
ULONG __stdcall AddLocalAlternateComputerNameW(LPCWSTR Hostname, int a2);
DWORD __thiscall AddLocalAlternateComputerNameA(ULONG this, LPCSTR lpMultiByteStr, int a3);
ULONG __stdcall RemoveLocalAlternateComputerNameW(LPCWSTR Hostname, int a2);
DWORD __thiscall RemoveLocalAlternateComputerNameA(ULONG this, LPCSTR lpMultiByteStr, int a3);
DWORD __stdcall SetLocalPrimaryComputerNameW(wchar_t *Str, PVOID a2);
DWORD __thiscall SetLocalPrimaryComputerNameA(ULONG this, LPCSTR lpMultiByteStr, PVOID a3);
ULONG __stdcall EnumerateLocalComputerNamesW(int a1, int a2, void *Dst, int a4);
int __stdcall EnumerateLocalComputerNamesA(int, int, LPSTR lpMultiByteStr, int); // idb
LONG __stdcall LZCopy(INT hfSource, INT hfDest);
LONG __stdcall CopyLZFile(INT hfSource, INT hfDest);
DWORD __stdcall GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, int a5);
DWORD __stdcall GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, int a5);
int __stdcall BasepSetMiniVersionForCreate(unsigned __int16 a1);
__int16 __stdcall BasepGetMiniVersionForCreate();
char __stdcall DTZItoRTL_DTZI(int a1, int a2);
BOOL __stdcall SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation);
BOOL __stdcall SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation);
HANDLE __stdcall ProcessIdToHandle(HANDLE ProcessHandle);
BOOL __stdcall DebugActiveProcess(DWORD dwProcessId);
BOOL __stdcall DebugBreakProcess(HANDLE Process);
BOOL __stdcall DebugSetProcessKillOnExit(BOOL KillOnExit);
BOOL __stdcall Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry);
PVOID __stdcall SaveThreadHandle(int a1, int a2, int a3);
PVOID __stdcall SaveProcessHandle(int a1, int a2);
PVOID __stdcall MarkThreadHandle(int a1);
PVOID __stdcall MarkProcessHandle(int a1);
char __stdcall RemoveHandles(int a1, int a2);
char __stdcall CloseAllProcessHandles(int a1);
BOOL __stdcall WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);
BOOL __stdcall ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus);
BOOL __stdcall DebugActiveProcessStop(DWORD dwProcessId);
int __stdcall RemoveDirectoryTransactedW(LPCWSTR lpPathName, int); // idb
BOOL __stdcall CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL __stdcall RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction);
int __stdcall CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int); // idb
BOOL __stdcall CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
int __stdcall CreateDirectoryTransactedA(int, int, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int); // idb
UINT __stdcall GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
UINT __stdcall GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
NTSTATUS __stdcall BaseDllCheckKeyNotEmpty(void *a1, UNICODE_STRING *a2);
signed int __stdcall BaseVerifyFileName(int a1, int a2);
signed int __stdcall BaseVerifyMappingTarget(int a1, int a2);
int __stdcall BaseDllReadApplicationNames(int a1);
NTSTATUS __stdcall BaseDllWriteVariableValue(ULONG ResultSize, int a2, int a3, PUNICODE_STRING ValueName);
int __stdcall BaseDllDeleteApplicationVariables(ULONG a1, int a2);
int __stdcall BaseDllWriteApplicationVariables(ULONG ResultSize, int); // idb
DWORD __stdcall GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
BOOL __stdcall WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
BOOL __stdcall WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
DWORD __stdcall GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
BOOL __stdcall GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
BOOL __stdcall GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
BOOL __stdcall WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
BOOL __stdcall WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
BOOL __stdcall WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
DWORD __stdcall GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize);
BOOL __stdcall WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString);
BOOL __stdcall WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString);
BOOL __stdcall DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath);
DWORD __stdcall QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax);
int __stdcall BaseWriteErrorElevationRequiredEvent();
int __stdcall DelayLoad_SetLastNtStatusAndWin32Error();
int __stdcall SetFileIoOverlappedRange(HANDLE FileHandle, int, int); // idb
BOOL __stdcall SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode);
DWORD __stdcall GetThreadErrorMode();
int __stdcall BasepIoCompletion(PVOID Address, int, int); // idb
int __stdcall BasepIoCompletionSimple(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3);
int __stdcall FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, int); // idb
int __stdcall FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, int); // idb
int __stdcall BasepBuildNameFromComponentsW(int, int, int, void *Dst); // idb
NTSTATUS __stdcall FindParent(void *a1, char a2, int a3, PVOID *a4);
int __stdcall FindFirstFileNameW(PWSTR dosname, int, int, void *Dst); // idb
int __stdcall FindNextFileNameW(int, int, void *Dst); // idb
int __stdcall FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, int); // idb
int __stdcall FindFirstFileNameTransactedW(PWSTR dosname, int, int, void *Dst, int); // idb
BOOL __stdcall CancelSynchronousIo(HANDLE hThread);
BOOLEAN __stdcall Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection);
BOOL __stdcall SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
BOOL __stdcall GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests);
BOOL __stdcall SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName);
BOOL __stdcall SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName);
HANDLE __stdcall CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred);
int __stdcall SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, int); // idb
int __stdcall BasepMoveFileCopyProgress(int, int, int, int, int, int, int, int, int, int, int, HANDLE hFile, int); // idb
int __stdcall BasepNotifyTrackingService(PHANDLE FileHandle, int, int, PSTRING String2); // idb
NTSTATUS __stdcall BasepOpenFileForMove(int a1, int a2, int a3, PHANDLE FileHandle, POBJECT_ATTRIBUTES ObjectAttributes, int a6, int a7, ULONG OpenOptions);
bool __stdcall PrivMoveFileIdentityW(int a1, int a2, char a3);
DWORD __stdcall GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh);
PVOID __stdcall GetFullPath(LPCWSTR lpFileName);
int __stdcall SetFileAttributesTransactedA(int, DWORD dwFileAttributes, int); // idb
int __stdcall GetFileAttributesTransactedA(int, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, int); // idb
BOOL __stdcall DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction);
DWORD __stdcall GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, int a3);
DWORD __stdcall GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh);
int __stdcall CreateSymbolicLinkW(PWSTR dosname, PWSTR Path, int FileInformation); // idb
int __stdcall BasepMoveFileDelayed(int a1, int a2, int a3, char a4, ULONG a5);
DWORD __stdcall GetCompressedFileSizeTransactedA(int a1, LPDWORD lpFileSizeHigh, int a3);
char __stdcall CreateSymbolicLinkTransactedW(PWSTR dosname, PWSTR Path, int FileInformation, int a4);
char __stdcall CreateSymbolicLinkA(int a1, int a2, int FileInformation);
char __stdcall CreateSymbolicLinkTransactedA(int a1, int a2, int FileInformation, int a4);
BOOL __stdcall MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction);
int __stdcall MoveFileTransactedW(PWSTR dosname, PWSTR DeviceName, int, int, int, int); // idb
BOOL __stdcall MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
DWORD __stdcall LoadDuplicateEncryptionInfoFile(int a1, int a2, int a3, int a4, int a5);
int __stdcall BasepChecksum(int a1, int a2);
signed int __stdcall BasepCreateDispositionToWin32(int a1, int a2);
int __stdcall CheckAllowDecryptedRemoteDestinationPolicy();
NTSTATUS __stdcall BaseMarkFileForDelete(HANDLE FileHandle, int a2);
int __stdcall CopyReparsePoint(HANDLE FileHandle, HANDLE, HANDLE Event); // idb
int __stdcall CopyNameGraftNow(HANDLE FileHandle, int, LPCWSTR lpszVolumeMountPoint, int, int, int, int, int, HANDLE Event); // idb
int __stdcall BasepOpenRestartableFile(HANDLE hTemplateFile, LPCWSTR lpFileName, int, char, int, int, int, DWORD dwFlagsAndAttributes, int); // idb
int __stdcall BasepCopyCompression(HANDLE, HANDLE FileHandle, int InputBuffer, int OutputBuffer, char, int, HANDLE Event, int); // idb
int __stdcall CreateFileTransactedA(int, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, int, int, int); // idb
BOOL __stdcall ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
int __stdcall CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, int); // idb
BOOL __stdcall CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags);
int __stdcall CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, int); // idb
DWORD __stdcall GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize);
BOOL __stdcall SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize);
DWORD __stdcall GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize);
BOOL __stdcall SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize);
SIZE_T __stdcall LocalCompact(UINT uMinFree);
void __stdcall GlobalFix(HGLOBAL hMem);
void __stdcall GlobalUnfix(HGLOBAL hMem);
LPVOID __stdcall GlobalWire(HGLOBAL hMem);
BOOL __stdcall GlobalUnWire(HGLOBAL hMem);
BOOL __stdcall AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
BOOL __stdcall RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
UINT __stdcall EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize);
HRESULT __stdcall StringCbCopyNExW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_PCNZWCH pszSrc, size_t cbToCopy, STRSAFE_LPWSTR *ppszDestEnd, size_t *pcbRemaining, DWORD dwFlags);
HFILE __stdcall _lopen(LPCSTR lpPathName, int iReadWrite);
HFILE __stdcall _lcreat(LPCSTR lpPathName, int iAttribute);
UINT __stdcall _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes);
SIZE_T __stdcall LocalShrink(HLOCAL hMem, UINT cbNewSize);
BOOL __stdcall GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout);
int __stdcall LoadStringBaseW(int a1, int a2, int a3, int a4);
// HRESULT SIZETMult(SIZE_T Multiplicand, SIZE_T Multiplier, SIZE_T *pResult);
BOOL __stdcall sub_77E6DAE0(unsigned __int16 a1);
signed int __stdcall ReturnMem16Data(int a1, int a2, int a3);
BOOL __stdcall UTRegister(HANDLE hModule, LPCSTR lpsz16BitDLL, LPCSTR lpszInitName, LPCSTR lpszProcName, UT32PROC *ppfn32Thunk, FARPROC pfnUT32Callback, LPVOID lpBuff);
int __stdcall SetDllDirectoryW(wchar_t *Str); // idb
int __stdcall SetDllDirectoryA(char *Str); // idb
unsigned int __stdcall GetDllDirectoryW(int a1, void *Dst);
DWORD __stdcall GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
BOOL __stdcall SetSearchPathMode(DWORD Flags);
BOOL __stdcall EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
BOOL __stdcall EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam);
BOOL __stdcall EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);
BOOL __stdcall EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam);
HANDLE __stdcall CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
int __stdcall NpGetUserNamep(int, int, HANDLE TokenHandle); // idb
BOOL __stdcall GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize);
BOOL __stdcall GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances);
int __stdcall GetInterruptTime(int a1);
BOOL __stdcall CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut);
BOOL __stdcall WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut);
BOOL __stdcall GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength);
BOOL __stdcall GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId);
BOOL __stdcall GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId);
BOOL __stdcall GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId);
BOOL __stdcall GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId);
BOOL __stdcall GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize);
BOOL __stdcall CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut);
BOOL __stdcall SetNamedPipeAttribute(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, SIZE_T AttributeValueLength);
BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber);
int __stdcall GetNumaProcessorNodeEx(ULONG ReturnLength, int); // idb
BOOL __stdcall GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask);
BOOL __stdcall GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes);
int __stdcall GetNumaProximityNodeEx(ULONG ReturnLength, int); // idb
int __stdcall GetNumaNodeNumberFromHandle(HANDLE FileHandle, int); // idb
BOOL __stdcall GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber);
BOOL __stdcall GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask);
BOOL __stdcall GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes);
int __stdcall GetNumaProximityNode(ULONG ReturnLength, int); // idb
BOOL __stdcall CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal);
BOOL __stdcall SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName);
BOOL __stdcall CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal);
BOOL __stdcall SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName);
BOOL __stdcall SetSystemPowerState(BOOL fSuspend, BOOL fForce);
BOOL __stdcall GetDevicePowerState(HANDLE hDevice, BOOL *pfOn);
BOOL __stdcall IsSystemResumeAutomatic();
BOOL __stdcall RequestWakeupLatency(LATENCY_TIME latency);
UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow);
void __stdcall FatalExit(int ExitCode);
DEP_SYSTEM_POLICY_TYPE __stdcall GetSystemDEPPolicy();
BOOL __stdcall GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength);
__int16 __stdcall GetActiveProcessorGroupCount();
DWORD __stdcall GetMaximumProcessorCount(WORD GroupNumber);
BOOL __stdcall IsBadHugeReadPtr(const void *lp, UINT_PTR ucb);
BOOL __stdcall IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb);
BOOL __stdcall GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags);
int __stdcall GetProcessGroupAffinity(HANDLE ProcessHandle, ULONG ReturnLength, PVOID ProcessInformation); // idb
BOOL __stdcall SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask);
BOOL __stdcall GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost);
BOOL __stdcall GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters);
BOOL __stdcall GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount);
int __stdcall GetProcessDEPPolicy(HANDLE ProcessHandle, int, int); // idb
int __stdcall GetProcessUserModeExceptionPolicy(int a1);
BOOL __stdcall GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed);
DWORD __stdcall LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock);
NTSTATUS __stdcall RtlStringCchCatW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc);
NTSTATUS __stdcall BasepSaveAppCertRegistryValue(int a1, int SourceString, LPCWSTR lpLibFileName);
NTSTATUS __stdcall BasepConfigureAppCertDlls(int a1, int a2, LPCWSTR lpLibFileName, int a4, int a5, int a6);
int __stdcall ReplacePartitionUnit(PCWSTR, PCWSTR SourceString, int); // idb
int __stdcall DosPathToSessionPathW(int, void *lp, LPVOID); // idb
int __stdcall DosPathToSessionPathA(int, void *lp, LPVOID); // idb
HANDLE __stdcall CreateFileMappingNumaWStub(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred);
HANDLE __stdcall CreateMutexExAStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
HANDLE __stdcall CreateRemoteThreadStub(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
BOOL __stdcall DeleteVolumeMountPointWStub(LPCWSTR lpszVolumeMountPoint);
BOOL __stdcall EnumCalendarInfoExWStub(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);
BOOL __stdcall EnumCalendarInfoWStub(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
BOOL __stdcall EnumDateFormatsExWStub(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumLanguageGroupLocalesWStub(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam);
BOOL __stdcall EnumSystemCodePagesWStub(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags);
BOOL __stdcall EnumSystemLocalesExStub(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved);
BOOL __stdcall EnumSystemLocalesWStub(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);
HANDLE __stdcall FindFirstFileExAStub(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
HANDLE __stdcall FindFirstChangeNotificationAStub(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
int __stdcall FindStringOrdinalStub(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase);
BOOL __stdcall GetComputerNameExAStub(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize);
int __stdcall GetCurrencyFormatWStub(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);
BOOL __stdcall GetNamedPipeAttributeStub(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, PSIZE_T AttributeValueLength);
BOOL __stdcall GetNamedPipeClientComputerNameWStub(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength);
DWORD __stdcall GetLongPathNameAStub(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer);
BOOL __stdcall GetProcessPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
BOOL __stdcall GetQueuedCompletionStatusExStub(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable);
BOOL __stdcall GetThreadPriorityBoostStub(HANDLE hThread, PBOOL pDisablePriorityBoost);
BOOL __stdcall HeapQueryInformationStub(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength);
BOOL __stdcall HeapSummaryStub(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary);
BOOL __stdcall IsValidLanguageGroupStub(LGRPID LanguageGroup, DWORD dwFlags);
LPVOID __stdcall MapViewOfFileExNumaStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
BOOL __stdcall NeedCurrentDirectoryForExePathAStub(LPCSTR ExeName);
HANDLE __stdcall OpenWaitableTimerWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName);
BOOL __stdcall RemoveDirectoryAStub(LPCSTR lpPathName);
BOOL __stdcall SetCalendarInfoWStub(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData);
BOOL __stdcall SetLocaleInfoWStub(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
BOOL __stdcall SetLocalTimeStub(const SYSTEMTIME *lpSystemTime);
BOOL __stdcall SetStdHandleStub(DWORD nStdHandle, HANDLE hHandle);
BOOL __stdcall SetStdHandleExStub(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue);
BOOL __stdcall SetThreadPriorityBoostStub(HANDLE hThread, BOOL bDisablePriorityBoost);
BOOL __stdcall TransactNamedPipeStub(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
LPVOID __stdcall VirtualAllocExNumaStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
BOOL __stdcall VirtualProtectExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
BOOL __stdcall WaitNamedPipeWStub(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
BOOL __stdcall Wow64RevertWow64FsRedirectionStub(PVOID OlValue);
BOOL __stdcall SetThreadpoolStackInformationStub(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
BOOL __stdcall QueryThreadpoolStackInformationStub(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
BOOL __stdcall SetProcessAffinityUpdateModeStub(HANDLE hProcess, DWORD dwFlags);
BOOL __stdcall QueryProcessAffinityUpdateModeStub(HANDLE hProcess, LPDWORD lpdwFlags);
int __stdcall NlsEventDataDescCreateStub(int a1, int a2, int a3, int a4);
int __stdcall NlsWriteEtwEventStub(int a1, int a2, int a3, int a4, int a5);
void __stdcall FatalAppExitAStub(UINT uAction, LPCSTR lpMessageText);
void __stdcall FatalAppExitWStub(UINT uAction, LPCWSTR lpMessageText);
int __stdcall GetCurrencyFormatExStub(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);
int __stdcall GetEraNameCountedStringStub(int a1, int a2, int a3, int a4);
BOOL __stdcall GetFileMUIInfoStub(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo);
DWORD __stdcall GetFinalPathNameByHandleAStub(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
int __stdcall GetUserDefaultLocaleNameStub(LPWSTR lpLocaleName, int cchLocaleName);
int __stdcall LCMapStringExStub(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
BOOLEAN __stdcall NotifyMountMgrStub(PWSTR dosname, PCWSTR SourceString, int a3);
BOOL __stdcall PeekNamedPipeStub(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
void __stdcall RtlCaptureContextStub(PCONTEXT ContextRecord);
void *__stdcall RtlFillMemoryStub(void *Dst, size_t Size, int Val);
HANDLE __stdcall CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags);
BOOL __stdcall AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel);
HANDLE __stdcall CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);
HANDLE __stdcall OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);
int __stdcall QueryFullProcessImageNameA(HANDLE ProcessHandle, HANDLE, LPSTR lpMultiByteStr, int); // idb
HANDLE __stdcall OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
HANDLE __stdcall OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName);
signed int __stdcall IsCallerAdminOrSystem();
signed int __stdcall SetTermsrvAppInstallMode(int a1);
int __stdcall RegKrnSetTermSrvHooksAndFlags(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall GetCompatFlags();
NTSTATUS __stdcall GetRegistryExtensionFlags(int a1);
BOOL __stdcall SetThreadContext(HANDLE hThread, const CONTEXT *lpContext);
BOOL __stdcall Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext);
DWORD __stdcall Wow64SuspendThread(HANDLE hThread);
BOOL __stdcall GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending);
int __stdcall GetThreadGroupAffinity(HANDLE ThreadHandle, PVOID ThreadInformation); // idb
int __stdcall SetThreadIdealProcessorEx(HANDLE ThreadHandle, int ThreadInformation, int); // idb
int __stdcall GetThreadIdealProcessorEx(HANDLE ThreadHandle, PVOID ThreadInformation); // idb
BOOL __stdcall Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL __stdcall Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL __stdcall Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID, ULONG_PTR th32HeapID);
BOOL __stdcall Heap32Next(LPHEAPENTRY32 lphe);
BOOL __stdcall Toolhelp32ReadProcessMemory(DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T *lpNumberOfBytesRead);
BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL __stdcall Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
signed int __stdcall ConvertWin32FHToDos(int a1);
int __stdcall ConvertDosFHToWin32(unsigned int a1);
INT __stdcall LZInit(INT hfSource);
LONG __stdcall LZSeek(INT hFile, LONG lOffset, INT iOrigin);
INT __stdcall LZRead(INT hFile, CHAR *lpBuffer, INT cbRead);
void __stdcall LZCloseFile(unsigned int a1);
void __stdcall LZClose(INT hFile);
INT __stdcall GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer);
INT __stdcall GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer);
int __stdcall LZCreateFileW(wchar_t *pszSrc, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, wchar_t *pszDest); // idb
INT __stdcall LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
INT __stdcall LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
int __stdcall sub_77E71FDD(int, int, PCWSTR SourceString, int, int, int); // idb
BOOL __stdcall ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);
BOOL __stdcall SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);
BOOL __stdcall EscapeCommFunction(HANDLE hFile, DWORD dwFunc);
BOOL __stdcall GetCommMask(HANDLE hFile, LPDWORD lpEvtMask);
BOOL __stdcall GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat);
BOOL __stdcall GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp);
BOOL __stdcall GetCommState(HANDLE hFile, LPDCB lpDCB);
BOOL __stdcall GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
BOOL __stdcall PurgeComm(HANDLE hFile, DWORD dwFlags);
BOOL __stdcall SetCommMask(HANDLE hFile, DWORD dwEvtMask);
BOOL __stdcall SetCommState(HANDLE hFile, LPDCB lpDCB);
BOOL __stdcall SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
BOOL __stdcall TransmitCommChar(HANDLE hFile, char cChar);
BOOL __stdcall WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped);
int __stdcall sub_77E72ECA(int, int, void *Src, ULONG Size, PUNICODE_STRING DestinationString, int); // idb
int __stdcall GetFriendlyUi(PCWSTR Path, PVOID); // idb
BOOL __stdcall CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
BOOL __stdcall CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
BOOL __stdcall GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
BOOL __stdcall GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
BOOL __stdcall SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
BOOL __stdcall SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
BOOL __stdcall ClearCommBreak(HANDLE hFile);
BOOL __stdcall GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
BOOL __stdcall SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize);
signed int __stdcall GetNextVDMCommand(int a1);
NTSTATUS __stdcall ExitVDM(int a1, int a2);
int __stdcall SetVDMCurrentDirectories(size_t Size, void *Src); // idb
size_t __stdcall GetVDMCurrentDirectories(int a1, void *Dst);
int __stdcall RegisterWowExec(int a1);
signed int __stdcall BaseUpdateVDMEntry(int a1, int a2, int a3, int a4);
int __stdcall BaseCheckForVDM(HANDLE EventHandle, int); // idb
int __stdcall BaseDestroyVDMEnvironment(PANSI_STRING AnsiString, int); // idb
int __stdcall BaseGetEnvNameType_U(wchar_t *, size_t); // idb
DWORD __stdcall GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, int a4);
DWORD __stdcall GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, int a4);
signed int __stdcall VDMOperationStarted(int a1);
NTSTATUS __stdcall BaseGetVdmLuid(HANDLE TokenHandle, int a2);
int __stdcall BaseCreateVDMEnvironment(int, PANSI_STRING DestinationString, PCUNICODE_STRING SourceString); // idb
BOOL __stdcall GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType);
int __stdcall BaseCheckVDM(int, PCWSTR SourceString, int, int, int, int, int, int, ULONG MessageBoxResult, int); // idb
int __stdcall BaseGetVdmConfigInfo(int, int, int, PUNICODE_STRING UnicodeString, int); // idb
BOOL __stdcall FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint);
BOOL __stdcall DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint);
HANDLE __stdcall FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength);
BOOL __stdcall FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength);
int __stdcall FindNextVolumeMountPointHelper(int, void *Dst, int, ULONG FileInformationLength); // idb
HANDLE __stdcall FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);
int __stdcall IsThisAVolumeName(DWORD BytesReturned, int); // idb
BOOL __stdcall FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);
BOOL __stdcall GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength);
int __stdcall SetVolumeNameForRoot(HANDLE hDevice, PCWSTR SourceString); // idb
BOOL __stdcall SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
BOOL __stdcall GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength);
HANDLE __stdcall FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
BOOL __stdcall FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
BOOL __stdcall SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName);
BOOL __stdcall GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// signed int __usercall sub_77E76911@<eax>(int a1@<eax>, int a2@<edi>);
// int __usercall sub_77E76A88@<eax>(int result@<eax>);
// signed int __usercall sub_77E76A9E@<eax>(unsigned int a1@<eax>, int a2@<ecx>);
// signed int __usercall sub_77E76B6A@<eax>(char a1@<al>, int a2@<esi>);
// signed int __userpurge sub_77E76BAD@<eax>(int *a1@<eax>, int *a2, int a3);
// signed int __userpurge sub_77E76C56@<eax>(int *a1@<eax>, int *a2, int a3);
int __stdcall sub_77E76D2B(int, int, PCWSTR SourceString, int, int, int); // idb
signed int __thiscall sub_77E76D9B(int this, int a2, int a3);
BOOL __stdcall BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
BOOL __stdcall BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB);
BOOL __stdcall BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
BOOL __stdcall BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB);
ULONG __stdcall BasepDoTapeOperation(HANDLE FileHandle, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
DWORD __stdcall SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate);
DWORD __stdcall GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh);
DWORD __stdcall PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate);
DWORD __stdcall EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate);
DWORD __stdcall CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize);
DWORD __stdcall WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate);
DWORD __stdcall GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation);
DWORD __stdcall SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation);
DWORD __stdcall GetTapeStatus(HANDLE hDevice);
HANDLE __stdcall OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
BOOL __stdcall QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength);
BOOL __stdcall CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);
HANDLE __stdcall CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName);
HANDLE __stdcall OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
int __stdcall CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int); // idb
BOOL __stdcall CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
int __stdcall CreateHardLinkTransactedA(int, int, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int); // idb
int __stdcall GetHandleContext(int a1);
int __stdcall CreateSocketHandle();
BOOL __stdcall ZombifyActCtx(HANDLE hActCtx);
int __stdcall BasepRegenerateActCtxWithLanguage(int a1, LANGID a2, int a3);
BOOL __stdcall FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData);
BOOL __stdcall SdbIsValidQueryResultLight(int a1);
char __stdcall BasepQueryModuleDataEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall SetComPlusPackageInstallStatus(int SystemInformation); // idb
int __stdcall GetComPlusPackageInstallStatus();
signed int __stdcall BaseCleanupAppcompatCacheSupport(int a1);
int __stdcall BaseDumpAppcompatCache();
signed int __stdcall BaseFlushAppcompatCache();
int __stdcall BaseCheckAppcompatCache(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int); // idb
NTSTATUS __stdcall BasepGetApphelpParseModuleDataProc(int a1);
NTSTATUS __stdcall BaseRevertToSelf(int a1);
void __stdcall BaseRestoreImpersonation(int ThreadInformation);
int __cdecl pfnWebBladeHashCompare(const void *a1, const void *a2);
void __stdcall ApplicationRecoveryFinished(BOOL bSuccess);
HRESULT __stdcall ApplicationRecoveryInProgress(PBOOL pbCancelled);
int __stdcall WerpInitiateRemoteRecovery(int a1);
HRESULT __stdcall WerRegisterFile(PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags);
HRESULT __stdcall WerUnregisterFile(PCWSTR pwzFilePath);
HRESULT __stdcall WerRegisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext);
HRESULT __stdcall WerUnregisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext);
int __stdcall WerpNotifyLoadStringResource(HINSTANCE a1, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4);
int __stdcall WerpNotifyLoadStringResourceEx(HINSTANCE a1, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4, void **a5);
int __stdcall WerpStringLookup(unsigned __int16 *a1, void **a2);
int __stdcall QueryThreadCycleTime(HANDLE ThreadHandle, int); // idb
int __stdcall QueryProcessCycleTime(HANDLE ProcessHandle, int); // idb
int __stdcall QueryIdleProcessorCycleTime(PULONG ReturnLength, PVOID SystemInformation); // idb
BOOL __stdcall QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);
BOOL __stdcall QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime);
BOOL __stdcall SetEnvironmentStringsA(LPCH NewEnvironment);
BOOL __stdcall SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags);
BOOL __stdcall GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags);
BOOL __stdcall AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);
int __stdcall AllocateUserPhysicalPagesNuma(HANDLE ProcessHandle, PULONG NumberOfPages, PULONG PageFrameNumbers, int); // idb
BOOL __stdcall FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);
BOOL __stdcall MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);
BOOL __stdcall MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);
UINT __stdcall GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, PULONG lpdwGranularity);
UINT __stdcall ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize);
SIZE_T __stdcall GetLargePageMinimum();
BOOL __stdcall QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState);
BOOL __stdcall DeleteTimerQueue(HANDLE TimerQueue);
BOOL __stdcall CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer);
signed int __stdcall SignalStartWerSvc();
NTSTATUS __stdcall WaitForWerSvc();
void __stdcall RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags);
BOOL __stdcall InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength);
BOOL __stdcall CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source);
signed int __stdcall GetEnabledXStateFeatures();
PVOID __stdcall LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length);
BOOL __stdcall GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask);
BOOL __stdcall SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask);
DWORD __stdcall EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle);
DWORD __stdcall DisableThreadProfiling(HANDLE PerformanceDataHandle);
DWORD __stdcall QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled);
DWORD __stdcall ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData);
// int __userpurge sub_77E78D02@<eax>(int a1@<ecx>, int a2@<ebx>, void *a3@<edi>, unsigned int Size, int a5, __int16 a6);
int __stdcall IsResUpdateAllowable(struct _UPDATEDATA *, const unsigned __int16 *, unsigned __int16); // idb
void __stdcall FreeOne(PVOID Address); // idb
void __stdcall FreeStrings(struct _UPDATEDATA *); // idb
void __stdcall FreeData(struct _UPDATEDATA *); // idb
int __stdcall UpdateRCManifestID(unsigned __int32 *, unsigned __int32, unsigned __int32 *, unsigned __int32, const unsigned __int16 *, int, unsigned __int32 *); // idb
int __stdcall UpdateRCManifestName(unsigned __int16 *Dst, __int32, const unsigned __int16 *, __int32, const unsigned __int16 *Src, int, unsigned __int32 *); // idb
int __stdcall InternalUpdateRCManifest(struct _RC_CONFIG *, unsigned __int32, struct _RC_CONFIG *, const unsigned __int16 *Src, int, int); // idb
int __stdcall UpdateRCManifest(HGLOBAL hMem, const unsigned __int16 *Src, int); // idb
struct MY_STRING *__stdcall AddStringOrID(wchar_t *Str2, struct _UPDATEDATA *); // idb
int __stdcall DeleteResourceFromList(struct _UPDATEDATA *, HGLOBAL hMem, PVOID Address, PVOID, int, int, int); // idb
int __stdcall InsertResourceIntoLangList(struct _UPDATEDATA *, PVOID Address, PVOID, struct _RESTYPE *, struct _RESNAME *, int, int, int, void *); // idb
LONG __stdcall FilePos(HFILE hFile);
LONG __stdcall MuMoveFilePos(HFILE hFile, LONG lOffset);
UINT __stdcall MuWrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes);
UINT __stdcall MuRead(HFILE hFile, unsigned __int8 *lpBuffer, UINT uBytes);
int __stdcall MuCopy(HFILE, HFILE hFile, UINT uBytes); // idb
void __stdcall SetResdata(struct _IMAGE_RESOURCE_DATA_ENTRY *, unsigned __int32, unsigned __int32); // idb
void __stdcall SetRestab(struct _IMAGE_RESOURCE_DIRECTORY *, __int32, unsigned __int16, unsigned __int16); // idb
struct _IMAGE_SECTION_HEADER *__stdcall FindSection(struct _IMAGE_SECTION_HEADER *, struct _IMAGE_SECTION_HEADER *, char *); // idb
int __stdcall AssignResourceToSection(struct _RESNAME **a1, unsigned __int32 a2, unsigned __int32 a3, __int32 a4, __int32 *a5);
int __stdcall WriteResSection(struct _UPDATEDATA *a1, HFILE hFile, unsigned __int32 a3, unsigned __int32 a4, struct _RESNAME *a5);
int __stdcall PatchDebug<_IMAGE_NT_HEADERS>(HFILE hFile, HFILE, int, int, int, int, int, int, int, int); // idb
int __stdcall PatchDebug<_IMAGE_NT_HEADERS64>(HFILE hFile, HFILE, int, int, int, int, int, int, int, int); // idb
int __stdcall PatchRVAs<_IMAGE_NT_HEADERS>(HFILE hFile, HFILE, int, int, int, CHAR); // idb
int __stdcall PatchRVAs<_IMAGE_NT_HEADERS64>(HFILE hFile, HFILE, int, int, int, CHAR); // idb
HRESULT __stdcall StringCchCopyA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszSrc);
HRESULT __stdcall StringCchLengthW(STRSAFE_PCNZWCH psz, size_t cchMax, size_t *pcchLength);
int __stdcall AddResource(PVOID Address, PVOID a2, unsigned __int16 a3, struct _UPDATEDATA *a4, HGLOBAL hMem, void *a6, unsigned __int32 a7);
size_t __stdcall PEWriteResource<_IMAGE_NT_HEADERS>(HFILE a1, HFILE hFile, LONG lOffset, struct _UPDATEDATA *a4, int a5);
size_t __stdcall PEWriteResource<_IMAGE_NT_HEADERS64>(HFILE a1, HFILE hFile, LONG lOffset, struct _UPDATEDATA *a4, int a5);
BOOL __stdcall UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);
BOOL __stdcall UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);
BOOL __stdcall EnumLangsFunc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam);
size_t __stdcall PEWriteResFile(HFILE hFile, HFILE a2, LONG lOffset, struct _UPDATEDATA *a4);
DWORD __stdcall WriteResFile(HGLOBAL hMem, unsigned __int16 *a2);
BOOL __stdcall EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard);
BOOL __stdcall EnumNamesFunc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam);
BOOL __stdcall EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard);
BOOL __stdcall EnumTypesFunc(HMODULE hModule, LPWSTR lpType, LONG_PTR lParam);
HANDLE __stdcall BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources);
HANDLE __stdcall BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources);
void __cdecl __report_gsfailure();
int __cdecl __security_init_cookie_ex(int a1);
signed int __thiscall IsCalendarLeapYear(void *this, int a2, int a3, int a4);
int __stdcall IsCalendarLeapMonth(int a1, unsigned int a2, int a3, int a4);
signed int __thiscall IsCalendarLeapDay(void *this, int a2, unsigned int a3, unsigned int a4, int a5, int a6);
BOOL __stdcall ConvertCalDateTimeToSystemTime(const void *a1, int a2);
signed int __stdcall CompareCalendarDates(int a1, int a2, int a3);
signed int __thiscall GetCalendarDaysInYear(void *this, int a2, int a3, int a4);
int __stdcall GetCalendarDayOfYear(int a1);
signed int __stdcall GetMinSupportedCalendarYear(int a1);
unsigned int __stdcall GetFirstDayWeekOfYear(int a1, int a2);
signed int __stdcall GetWeekOfYearFullDays(int a1, int a2, int a3, signed int a4);
signed int __stdcall GetCalendarWeekNumber(int a1, unsigned int a2, int a3, int a4);
BOOL __stdcall EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);
BOOL __stdcall EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags);
BOOL __stdcall EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);
BOOL __stdcall EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam);
BOOL __stdcall EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam);
BOOL __stdcall EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags);
int __stdcall GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId);
BOOL __stdcall SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData);
BOOL __stdcall SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData);
int __stdcall GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency);
int __stdcall FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
BOOL __stdcall GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx);
int __stdcall GetGeoLCID(int a1, __int16 a2);
BOOL __stdcall EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc);
BOOL __stdcall SetUserGeoID(GEOID GeoId);
int __stdcall GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId);
__int16 __stdcall GetLocaleWordFromArrayInPoolUseDefault(int a1, int a2, signed int a3, __int16 a4);
signed int __stdcall IsValidCalendar(unsigned int a1);
unsigned __int16 __stdcall GetCalendarYear(int a1, int a2, unsigned int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8);
signed int __stdcall GetUmAlQuraDate(int a1);
signed int __stdcall GetHijriDate(int a1, int a2);
signed int __stdcall GetHebrewDate(int a1, int a2);
signed int __stdcall NumberToHebrewLetter(unsigned int a1, int a2, signed int a3);
int __stdcall GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
int __stdcall GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar);
int __stdcall GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);
BOOL __stdcall VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts);
int __stdcall NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength);
BOOL __stdcall IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength);
int __stdcall IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar);
int __stdcall IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar);
int __stdcall IsMSSigned(HMODULE hModule, int, char); // idb
int __stdcall ValidateFileSignature(HMODULE hModule, int, int, char); // idb
NTSTATUS __stdcall sub_77E8055A(PCWSTR SourceString, PVOID Address);
// NTSTATUS __userpurge sub_77E805FE@<eax>(int a1@<eax>, int a2, void *Dst);
NTSTATUS __thiscall sub_77E80646(PVOID Address, int a2);
signed int __stdcall Internal_AllowTestSign(int a1);
BOOL __stdcall SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages);
int __stdcall MuiEtwGetStringFromMultiString(STRSAFE_PCNZWCH psz, int); // idb
// NTSTATUS __userpurge Internal_NotifyUILanguageChange@<eax>(int a1@<ebp>, int a2, const WCHAR *a3, const wchar_t *a4, int a5, REGHANDLE a6, char a7, int a8);
signed int __stdcall sub_77E81EEE(DWORD dwFlags, const WCHAR *a2, int a3, REGHANDLE a4, char a5, int a6);
BOOL __stdcall NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn);
signed int __stdcall GetHebrewSupportedDateRange(int a1, int a2);
signed int __stdcall IsValidHebrewYear(int a1, int a2);
int __stdcall GetHebrewDaysInYearHelper(int a1);
signed int __stdcall GetHebrewDaysInYear(int a1, int a2);
signed int __stdcall IsHebrewLeapYear(int a1, int a2);
int __stdcall GetHebrewMonthsInYear(int a1, int a2);
int __stdcall GetLunarMonthDay(int a1, int a2);
int __stdcall GetDayDifference(int a1, unsigned int a2, int a3, unsigned int a4, int a5);
signed int __stdcall HebrewToGregorian(int a1);
signed int __stdcall GregorianToHebrew(int a1);
signed int __stdcall IsValidHebrewMonth(unsigned int a1, int a2, int a3);
signed int __stdcall GetHebrewDaysInMonth(unsigned int a1, int a2, int a3);
int __stdcall IsHebrewLeapMonth(unsigned int a1, int a2, int a3);
int __stdcall HebrewToAbsolute(const void *a1);
signed int __stdcall AbsoluteToHebrew(signed int a1, int a2);
BOOL __stdcall ConvertHebrewDateTimeToSystemTime(const void *a1, int a2);
signed int __stdcall ConvertSystemTimeToHebrewDateTime(int a1, void *a2);
signed int __stdcall IsValidHebrewDay(unsigned int a1, unsigned int a2, int a3, int a4);
unsigned int __stdcall GetHebrewDayOfWeekHelper(const void *a1);
signed int __stdcall IsValidHebrewDateTime(int a1, int a2, int a3);
int __stdcall GetHebrewDayOfYear(int a1);
signed int __stdcall UpdateHebrewDayOfWeek(int a1);
int __stdcall IsHebrewLeapDay(unsigned int a1, unsigned int a2, int a3, int a4);
signed int __stdcall AdjustHebrewDays(int a1, int a2);
int __stdcall GetHebrewDifferenceInDays(const void *a1, const void *a2);
signed int __stdcall AdjustHebrewYears(int a1, int a2);
signed int __stdcall AdjustHebrewMonths(int a1, int a2);
int __stdcall IsGregorianLeapMonth(int a1, int a2, int a3);
signed int __stdcall IsGregorianLeapDay(unsigned int a1, int a2, int a3, int a4);
signed int __stdcall ConvertGregorianDateTimeToSystemTime(int a1, int a2);
signed int __stdcall GetGregorianWeekOfYearFullDays(int a1, int a2, signed int a3, signed int a4);
int __stdcall GetGregorianDayOfYear(int a1);
signed int __stdcall GetGregorianDaysInYear(int a1, int a2);
signed int __stdcall GetUmAlQuraSupportedDateRange(int a1, int a2);
signed int __stdcall IsValidUmAlQuraEra(int a1);
signed int __stdcall IsValidUmAlQuraYear(int a1, int a2);
signed int __stdcall IsValidUmAlQuraMonth(int a1, int a2, int a3);
signed int __stdcall GetUmAlQuraDaysInMonth(int a1, int a2, int a3);
int __stdcall GetUmAlQuraDaysInYearHelper(int a1);
signed int __stdcall GetUmAlQuraDaysInYear(int a1, int a2);
signed int __stdcall IsUmAlQuraLeapYear(int a1, int a2);
int __stdcall IsUmAlQuraLeapMonth(int a1, int a2, int a3);
signed int __stdcall GregorianToUmAlQura(int a1);
signed int __stdcall UmAlQuraToGregorian(int a1);
BOOL __stdcall ConvertUmAlQuraDateTimeToSystemTime(const void *a1, int a2);
signed int __stdcall ConvertSystemTimeToUmAlQuraDateTime(int a1, void *a2);
int __stdcall GetUmAlQuraMonthsInYear(int a1, int a2);
signed int __stdcall IsValidUmAlQuraDay(unsigned int a1, int a2, int a3, int a4);
int __stdcall IsUmAlQuraLeapDay(unsigned int a1, int a2, int a3, int a4);
signed int __stdcall UmAlQuraToAbsolute(const void *a1);
signed int __stdcall AbsoluteToUmAlQura(signed int a1, int a2);
unsigned int __stdcall GetUmAlQuraDayOfWeekHelper(const void *a1);
signed int __stdcall IsValidUmAlQuraDateTime(int a1, int a2, int a3);
signed int __stdcall UpdateUmAlQuraDayOfWeek(int a1);
signed int __stdcall AdjustUmAlQuraDays(int a1, int a2);
int __stdcall GetUmAlQuraDifferenceInDays(const void *a1, const void *a2);
signed int __stdcall AdjustUmAlQuraMonths(int a1, int a2);
int __stdcall GetUmAlQuraDayOfYear(int a1);
signed int __stdcall AdjustUmAlQuraYears(int a1, int a2);
signed __int16 __stdcall GetMaxEras(int a1);
signed int __stdcall GetGregBasedSupportedDateRange(int a1, int a2, int a3);
int __stdcall GetEraOffsets(int a1, int a2, unsigned int a3, int a4);
int __stdcall GetGregorianYear(int a1, int a2, int a3);
signed int __stdcall UpdateGregBasedYearAndEra(unsigned int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, int a5);
int __stdcall IsValidJapanDate(unsigned int a1, int a2, int a3, int a4, int a5);
int __stdcall IsValidGregBasedDate(int a1, unsigned int a2, int a3, int a4, int a5, int a6);
int __thiscall IsGregBasedLeapYear(void *this, int a2, int a3, int a4);
int __stdcall IsGregBasedLeapMonth(int a1, int a2, int a3, int a4);
int __thiscall IsGregBasedLeapDay(void *this, int a2, unsigned int a3, int a4, int a5, int a6);
signed int __stdcall ConvertSystemTimeToGregBasedDateTime(int a1, void *a2);
signed int __thiscall GetGregBasedDaysInYear(void *this, int a2, int a3, int a4);
signed int __stdcall ConvertGregBasedToGregDateTime(int a1, int a2);
int __thiscall GetGregBasedDaysInMonth(void *this, int a2, int a3, int a4, int a5);
int __stdcall GetGregBasedMonthsInYear(int a1, int a2, int a3);
signed int __stdcall UpdateGregBasedDayOfWeek(int a1);
signed int __stdcall ConvertGregBasedDateTimeToSysTime(int a1, int a2);
int __stdcall GetGregBasedDifferenceInDays(int a1, int a2);
signed int __stdcall GetGregBasedDayOfYear(int a1);
signed int __stdcall IsValidGregBasedDateTime(int a1, int a2, int a3);
signed int __stdcall AdjustGregBasedDateTime(int a1, int a2, int a3);
signed int __stdcall OpenRegistryInternationalKey(int a1, int a2);
signed int __stdcall GetHijriSupportedDateRange(int a1, int a2);
signed int __stdcall IsValidHijriYear(int a1, int a2);
signed int __stdcall IsValidHijriMonth(unsigned int a1, int a2, int a3);
BOOL __stdcall NlsHijriLeapYear(int a1);
signed int __stdcall GetAdvanceHijriDate(int a1);
unsigned int __stdcall DaysUpToHijriYear(int a1);
signed int __stdcall IsHijriLeapYear(int a1, int a2);
int __stdcall IsHijriLeapMonth(unsigned int a1, int a2, int a3);
unsigned int __stdcall HijriToAbsolute(int a1);
signed int __stdcall ConvertHijriDateTimeToSystemTime(int a1, int a2);
int __stdcall GetHijriMonthsInYear(int a1, int a2);
unsigned int __stdcall GetHijriDayOfWeekHelper(int a1);
signed int __stdcall GetHijriDaysInMonth(unsigned int a1, int a2, int a3);
int __stdcall GetHijriDaysInYearHelper(int a1);
signed int __stdcall GetHijriDaysInYear(int a1, int a2);
unsigned int __stdcall GetHijriDifferenceInDays(int a1, int a2);
signed int __stdcall AbsoluteToHijri(int a1, int a2, int a3);
signed int __stdcall ConvertSystemTimeToHijriDateTimeEx(int a1, int a2, int a3);
signed int __stdcall ConvertSystemTimeToHijriDateTime(int a1, int a2);
signed int __stdcall AdjustHijriMonths(int a1, int a2);
signed int __stdcall IsValidHijriDay(unsigned int a1, unsigned int a2, int a3, int a4);
signed int __stdcall IsValidHijriDateTime(int a1, int a2, int a3);
signed int __stdcall GetHijriDayOfYear(int a1);
signed int __stdcall UpdateHijriDayOfWeek(int a1);
int __stdcall IsHijriLeapDay(unsigned int a1, unsigned int a2, int a3, int a4);
signed int __stdcall AdjustHijriDays(int a1, int a2);
signed int __stdcall AdjustHijriYears(int a1, int a2);
BOOL __stdcall GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation);
BOOLEAN __stdcall SortCloseHandle(PVOID Address);
__int16 __stdcall GetOldHangulWeight(int a1, int a2);
signed int __stdcall GetGraphemeStartPositions(int a1, int a2, int a3, int a4);
int __stdcall MapCase(int a1, int a2, int a3, int a4, int a5);
int __stdcall MapIsLetter(__int16 a1);
int __stdcall MapIsWordBreak(__int16 a1);
signed int __stdcall MapTitleCase(__int16 *a1, signed int a2, int a3, signed int a4, int a5, int a6);
signed int __stdcall SortChangeCase(int a1, int a2, int a3, signed int a4, int a5, int a6, int a7, int a8);
int __stdcall UpdateJamoState(int a1, int a2, int a3);
int __stdcall GetJamoComposition(unsigned __int16 **a1, unsigned int a2, int a3, int a4);
int __stdcall MapOldHangulSortKey(int a1, int a2, unsigned int a3, int a4, int a5);
BOOLEAN __stdcall InternalSortCloseHandle(PVOID Address);
int __stdcall LookupHandlerByOrdinal(unsigned __int32 a1, const struct _DLOAD_ORDINAL_MAP *a2);
BOOL __stdcall WTSSetListenerSecurityA(HANDLE hServer, PVOID pReserved, DWORD Reserved, LPSTR pListenerName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL __stdcall WTSGetListenerSecurityA(HANDLE hServer, PVOID pReserved, DWORD Reserved, LPSTR pListenerName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded);
BOOL __stdcall WTSQuerySessionInformationA(HANDLE hServer, DWORD SessionId, WTS_INFO_CLASS WTSInfoClass, LPSTR *ppBuffer, DWORD *pBytesReturned);
BOOL __stdcall WTSFreeMemoryExW(WTS_TYPE_CLASS WTSTypeClass, PVOID pMemory, ULONG NumberOfEntries);
int __stdcall sub_77E85B8D(int a1, int a2, int a3, int a4, int a5);
BOOL __stdcall WTSEnumerateSessionsW(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFOW *ppSessionInfo, DWORD *pCount);
HANDLE __stdcall WTSOpenServerA(LPSTR pServerName);
BOOL __stdcall WTSQueryUserToken(ULONG SessionId, PHANDLE phToken);
BOOL __stdcall WTSSendMessageA(HANDLE hServer, DWORD SessionId, LPSTR pTitle, DWORD TitleLength, LPSTR pMessage, DWORD MessageLength, DWORD Style, DWORD Timeout, DWORD *pResponse, BOOL bWait);
int __stdcall DebugTest(unsigned __int16 a1, char *a2);
signed int __stdcall sub_77E85C2A(int a1, int a2);
signed int __stdcall sub_77E85C47(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall MFCreateVideoPresenter2(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E85C81(int a1);
signed int __stdcall FmsMapGdiLogicalFont(int a1, int a2, int a3);
signed int __stdcall sub_77E85CBB(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E85D35(int a1, int a2);
signed int __stdcall sub_77E85D4F(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E85D69(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall sub_77E85D8E(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E85DA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall sub_77E85DC2(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __stdcall sub_77E85DE7(unsigned __int16 a1);
signed int __stdcall sub_77E85E08(int a1, int a2, int a3);
unsigned int __stdcall sub_77E85E1A(unsigned int a1);
int __stdcall sub_77E85E60(int, void *Dst, int, int, int); // idb
int __stdcall sub_77E85EC2(int, int, void *Dst); // idb
signed int __cdecl sub_77E85F48(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __cdecl sub_77E85F5D(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
char __stdcall IsAnimationsEnabled();
char __stdcall IsPalette(int a1);
int __stdcall FaxStartMessagesEnum(int a1, int a2, int a3);
DWORD __stdcall WlanExtractPsdIEDataList(HANDLE hClientHandle, DWORD dwIeDataSize, const PBYTE pRawIeData, LPCWSTR strFormat, PVOID pReserved, PWLAN_RAW_DATA_LIST *ppPsdIEDataList);
signed int __stdcall sub_77E860B8(int a1, int a2, int a3, int a4);
int __stdcall sub_77E860C3(int a1, int a2, int a3);
MMRESULT __stdcall mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId);
signed int __stdcall sub_77E860F9(int a1, int a2, int a3, int a4, int a5, char a6);
signed int __stdcall sub_77E8612A(int a1, int a2, int a3, int a4, int a5);
HANDLE __stdcall FindFirstUrlCacheEntryExA(LPCSTR lpszUrlSearchPattern, DWORD dwFlags, DWORD dwFilter, GROUPID GroupId, LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo, LPDWORD lpcbEntryInfo, LPVOID lpGroupAttributes, LPDWORD lpcbGroupAttributes, LPVOID lpReserved);
void __stdcall FXSAPIFree();
int __stdcall sub_77E861C4(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E861E6(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall sub_77E86203(int a1, int a2);
signed int __stdcall sub_77E86223(int a1, int a2);
signed int __stdcall sub_77E86240(int a1, int a2, int a3);
signed int __stdcall sub_77E86269(int a1, int a2);
signed int __stdcall sub_77E86289(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E862A6(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E862C3(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E862E3(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall sub_77E86392(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E863AD(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E863C8(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E863DF(int a1, int a2, int a3);
signed int __stdcall sub_77E863FC(int a1, int a2, int a3);
signed int __stdcall sub_77E86415(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E8642C(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall sub_77E86443(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall sub_77E8645A(int a1, int a2, int a3);
signed int __stdcall sub_77E86471(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall sub_77E8649B(int a1, int a2, int a3);
signed int __stdcall sub_77E864B8(int a1, int a2, int a3);
signed int __stdcall sub_77E864D2(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8650E(int a1, int a2);
signed int __stdcall sub_77E86530(int a1, int a2);
signed int __stdcall sub_77E8654D(int a1, int a2, int a3);
signed int __stdcall sub_77E86579(int a1, int a2, int a3);
signed int __stdcall sub_77E865A0(int a1, int a2, int a3);
signed int __stdcall sub_77E865C2(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86619(int a1, int a2, int a3);
signed int __stdcall sub_77E86639(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86656(int a1, int a2, int a3);
int __stdcall sub_77E86678(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_77E8669C(int a1, int a2, int a3, int a4);
int __stdcall sub_77E866B6(int a1, int a2, int a3, int a4, int a5, int a6);
DWORD __stdcall MprAdminConnectionEnum(RAS_SERVER_HANDLE hRasServer, DWORD dwLevel, LPBYTE *lplpbBuffer, DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries, LPDWORD lpdwResumeHandle);
signed int __stdcall sub_77E866F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __stdcall sub_77E8670A(int a1, int a2, int a3);
INT __stdcall WSCInstallNameSpaceEx(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId, LPBLOB lpProviderSpecific);
void __stdcall InitializeIpForwardEntry(PMIB_IPFORWARD_ROW2 Row);
int __stdcall GetElementMacro(int a1);
signed int __stdcall sub_77E867D7(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86801(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8682B(int a1, int a2, int a3);
signed int __stdcall sub_77E8685F(int a1, int a2, int a3);
signed int __stdcall sub_77E8688C(int a1, int a2, int a3);
signed int __stdcall sub_77E868B6(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall sub_77E86901(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86935(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86959(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall RsopFileAccessCheckInternal(unsigned __int16 *a1, void *a2, unsigned __int32 a3, unsigned __int32 *a4, int *a5);
signed int __stdcall sub_77E86988(int a1, int a2, int a3, int a4);
int __stdcall sub_77E869AC(int a1, int a2);
BOOL __stdcall sub_77E869C6(unsigned int a1);
BOOL __stdcall sub_77E869DD(int a1);
signed int __stdcall sub_77E869F9(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86A16(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86A3F(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86A63(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86A87(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall RegisterExtendedControls();
signed int __stdcall sub_77E86AD2(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86AEF(int a1, int a2, int a3);
signed int __stdcall sub_77E86B19(int a1, int a2, int a3);
signed int __stdcall sub_77E86B37(int a1, int a2);
signed int __stdcall sub_77E86B54(int a1, int a2);
signed int __stdcall sub_77E86B7F(int a1, int a2, int a3);
signed int __stdcall sub_77E86B9A(int a1, int a2);
signed int __stdcall sub_77E86BB3(int a1, int a2, int a3, int a4);
signed int __stdcall DeleteBrowserEmulationUserData(int a1);
signed int __stdcall sub_77E86C23(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E86C3E(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall SetConsoleMaximumWindowSize(int a1, int a2);
SECURITY_STATUS __stdcall SspiDecryptAuthIdentity(PSEC_WINNT_AUTH_IDENTITY_OPAQUE EncryptedAuthData);
int __stdcall sub_77E86CDB(int a1, int a2);
int __stdcall sub_77E86CFC(int a1, int a2);
__int64 __stdcall sub_77E86D22(int a1);
int __stdcall sub_77E86D4B(int a1);
HRESULT __stdcall IERegisterXMLNS(LPCWSTR lpszURI, GUID clsid, BOOL fMachine);
int __stdcall sub_77E86DB3(int a1, int a2);
int __stdcall sub_77E86DD6(int a1, int a2, int a3);
int __stdcall sub_77E86DF2(int a1, int a2);
signed int __stdcall sub_77E86E08(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86E2D(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E86E54(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86E79(int a1, int a2, int a3, int a4);
int __cdecl sub_77E86EA0(int a1);
int __cdecl sub_77E86EB9(int a1);
int __stdcall sub_77E86ED4(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E86EF1(int a1, int a2, int a3, int a4);
int __stdcall sub_77E86F12(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_77E86F28(int a1, int a2, int a3);
int __stdcall sub_77E86F44(int, int, int, int, int, void *Dst, int); // idb
signed int __stdcall sub_77E86F81(int a1, int a2, int a3);
signed int __stdcall sub_77E86FA2(int a1, int a2, int a3, int a4);
int __stdcall sub_77E86FC3(int a1, int a2, int a3);
int __stdcall sub_77E86FE2(int a1, int a2, int a3);
int __stdcall sub_77E87005(int a1, int a2, int a3);
int __stdcall sub_77E87021(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E87039(int a1, int a2, int a3, int a4);
unsigned int __stdcall sub_77E8705B(int a1);
unsigned int __stdcall sub_77E87075(int a1);
unsigned int __stdcall sub_77E870A8(int a1, int a2);
int __stdcall sub_77E870D3(int, int, void *Dst); // idb
int __stdcall sub_77E87104(int, int, int, void *Dst, int, int); // idb
int __stdcall sub_77E8715D(int a1, int a2);
signed int __stdcall sub_77E87189(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E871A2(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E871BB(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E871D6(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E871F1(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E87249(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8726C(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E8728F(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_77E872A8(void *a1, int a2, int a3);
int __stdcall sub_77E87301(int a1, int a2);
signed int __stdcall sub_77E8731D(int a1, int a2);
signed int __stdcall sub_77E87340(int a1, int a2);
signed int __stdcall sub_77E87359(int a1, int a2);
int __stdcall sub_77E87372(int a1, int a2);
signed int __stdcall sub_77E87392(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E873AB(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
signed int __stdcall FmsInitializeEnumerator(int a1, int a2);
signed int __stdcall sub_77E873F2(int a1, int a2, int a3);
int __stdcall sub_77E87414(int a1, int a2, int a3);
signed int __stdcall SfpDeleteCatalog(int a1, int a2);
signed int __stdcall sub_77E874A5(int a1);
PCCERT_CONTEXT __stdcall CryptUIDlgSelectCertificateFromStore(HCERTSTORE hCertStore, HWND hwnd, LPCWSTR pwszTitle, LPCWSTR pwszDisplayString, DWORD dwDontUseColumn, DWORD dwFlags, void *pvReserved);
int __stdcall DrawShadowTextEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int __stdcall sub_77E87503(int a1, int a2, int a3, int a4);
signed int __stdcall IsDeviceVirtual(int a1, int a2, int a3);
int __stdcall sub_77E87550(int a1);
signed int __stdcall SspiUpdateCredentials(int a1, int a2, int a3, int a4);
RPC_STATUS __stdcall RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE Binding, RPC_CSTR ServerPrincName, unsigned __int32 AuthnLevel, unsigned __int32 AuthnSvc, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, unsigned __int32 AuthzSvc, RPC_SECURITY_QOS *SecurityQos);
signed int __stdcall sub_77E876D0(int a1, int a2);
void __stdcall sub_77E876F6(DWORD dwExceptionCode);
signed int __stdcall sub_77E8771B(int a1);
signed int __stdcall sub_77E87739(int a1);
RPC_STATUS __stdcall RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE Binding, RPC_CSTR ServerPrincName, unsigned __int32 AuthnLevel, unsigned __int32 AuthnSvc, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, unsigned __int32 AuthzSvc);
signed int __stdcall sub_77E877F6(int a1, int a2, int a3);
int __stdcall sub_77E87811(int a1, int a2, int a3, int a4);
int __stdcall sub_77E8782B(int a1, int a2, int a3);
int __stdcall sub_77E87848(int a1, int a2, int a3);
signed int __stdcall sub_77E87889(int a1, int a2);
signed int __stdcall sub_77E878A8(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E878C6(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E878DF(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8791F(int a1, int a2);
signed int __stdcall sub_77E8793A(int a1, int a2);
__int64 __stdcall sub_77E87957(int a1, __int64 a2);
int __stdcall sub_77E8796B(int, void *Dst, size_t Size); // idb
int __stdcall sub_77E8798E(int, void *Dst); // idb
HRESULT __stdcall PSPropertyBag_ReadSHORT(IPropertyBag *propBag, LPCWSTR propName, SHORT *value);
signed int __stdcall sub_77E879E7(int a1, int a2, int a3);
signed int __stdcall sub_77E87A01(int a1, int a2, int a3);
signed int __stdcall sub_77E87A1D(int a1, int a2, int a3);
signed int __stdcall sub_77E87A40(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E87A4B(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E87A69(int a1, int a2);
signed int __stdcall sub_77E87A87(int a1, int a2, int a3);
__int16 __stdcall sub_77E87AA5(int a1, __int16 a2);
signed int __stdcall sub_77E87AC8(int a1, int a2);
double __stdcall sub_77E87AE2(int a1, double a2);
signed int __stdcall sub_77E87AF3(int a1, int a2, int a3);
signed int __stdcall sub_77E87B0E(int a1, int a2, int a3);
signed int __stdcall sub_77E87B2F(int a1, int a2, int a3);
signed int __stdcall sub_77E87B59(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall sub_77E87B72(int a1, int a2, int a3, int a4);
int __stdcall sub_77E87B95(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E87BB5(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall PSGetValueAndPath(int a1, int a2, int a3, int a4, int a5, int a6);
HRESULT __stdcall PSPropertyBag_ReadType(IPropertyBag *propBag, LPCWSTR propName, VARIANT *var, VARTYPE type);
HRESULT __stdcall PSPropertyBag_ReadStr(IPropertyBag *propBag, LPCWSTR propName, LPWSTR value, int characterCount);
HRESULT __stdcall PSPropertyBag_ReadPOINTS(IPropertyBag *propBag, LPCWSTR propName, POINTS *value);
HRESULT __stdcall PSPropertyBag_ReadRECTL(IPropertyBag *propBag, LPCWSTR propName, RECTL *value);
HRESULT __stdcall PSPropertyBag_ReadPOINTL(IPropertyBag *propBag, LPCWSTR propName, POINTL *value);
signed int __stdcall sub_77E87CA0(int a1, int a2, int a3);
signed int __stdcall sub_77E87CC3(int a1, int a2, void *a3);
signed int __stdcall FveGetStatus(int a1, int a2);
signed int __stdcall ComPlusEnableRemoteAccess(int a1);
signed int __stdcall CLSIDFromStringByBitness(int a1, int a2, int a3);
signed int __stdcall sub_77E87DE1(int a1, int a2);
signed int __stdcall ActivatorUpdateForIsRouterChanges(struct ISimpleTableDispenser *a1, int a2);
signed int __stdcall sub_77E87E14(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E87E2D(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E87E53(int a1, int a2, int a3);
signed int __stdcall sub_77E87E7E(int a1, int a2, int a3);
signed int __stdcall sub_77E87EA4(int a1, int a2);
int __stdcall sub_77E87ECD(int a1, int a2, int a3);
int __stdcall sub_77E87EE3(int a1, int a2, int a3, int a4);
unsigned int __stdcall sub_77E87EF9(int a1, int a2);
signed int __stdcall IEWSChangeNotify(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E87F62(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E87F88(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall MapUriToBrowserEmulationState(int a1, int a2, int a3);
signed int __stdcall MapBrowserEmulationModeToUserAgent(int a1, int a2);
int __stdcall sub_77E88024(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E88047(int a1, int a2);
signed int __stdcall sub_77E88091(int a1, int a2, int a3);
signed int __stdcall sub_77E880A8(int a1, int a2);
int __stdcall sub_77E880BF(int a1, int a2);
int __stdcall sub_77E880DD(int a1);
__int32 __stdcall WasDTCInstalledBySQL(); // idb
signed int __stdcall KccUnInitializeWait(unsigned __int32 a1);
signed int __stdcall sub_77E8815A(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E8818E(int a1, int a2, int a3);
signed int __stdcall sub_77E881A9(int a1, int a2, int a3);
INSTALLUILEVEL __stdcall MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND *phWnd);
signed int __stdcall sub_77E881D8(int a1, int a2);
signed int __stdcall sub_77E881FF(int a1);
HRESULT __stdcall MFShutdown();
signed int __stdcall sub_77E88223(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
HRESULT __stdcall MFCreateVideoSampleFromSurface(IUnknown *pUnkSurface, IMFSample **ppSample);
signed int __stdcall sub_77E8825B(int a1, int a2);
HRESULT __stdcall MFConvertToFP16Array(WORD *pDest, const float *pSrc, DWORD dwCount);
HRESULT __stdcall MFTUnregisterLocal(IClassFactory *pClassFactory);
HRESULT __stdcall MFBeginRegisterWorkQueueWithMMCSS(DWORD dwWorkQueueId, LPCWSTR wszClass, DWORD dwTaskId, IMFAsyncCallback *pDoneCallback, IUnknown *pDoneState);
HRESULT __stdcall MFBeginCreateFile(MF_FILE_ACCESSMODE AccessMode, MF_FILE_OPENMODE OpenMode, MF_FILE_FLAGS fFlags, LPCWSTR pwszFilePath, IMFAsyncCallback *pCallback, IUnknown *pState, IUnknown **ppCancelCookie);
LONGLONG __stdcall MFllMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d);
HRESULT __stdcall MFTRegister(CLSID clsidMFT, GUID guidCategory, LPWSTR pszName, UINT32 Flags, UINT32 cInputTypes, MFT_REGISTER_TYPE_INFO *pInputTypes, UINT32 cOutputTypes, MFT_REGISTER_TYPE_INFO *pOutputTypes, IMFAttributes *pAttributes);
HRESULT __stdcall MFTGetInfo(CLSID clsidMFT, LPWSTR *pszName, MFT_REGISTER_TYPE_INFO **ppInputTypes, UINT32 *pcInputTypes, MFT_REGISTER_TYPE_INFO **ppOutputTypes, UINT32 *pcOutputTypes, IMFAttributes **ppAttributes);
HRESULT __stdcall MFTEnumEx(GUID guidCategory, UINT32 Flags, const MFT_REGISTER_TYPE_INFO *pInputType, const MFT_REGISTER_TYPE_INFO *pOutputType, IMFActivate ***pppMFTActivate, UINT32 *pnumMFTActivate);
HRESULT __stdcall MFTRegisterLocalByCLSID(const IID *const clisdMFT, const GUID *const guidCategory, LPCWSTR pszName, UINT32 Flags, UINT32 cInputTypes, const MFT_REGISTER_TYPE_INFO *pInputTypes, UINT32 cOutputTypes, const MFT_REGISTER_TYPE_INFO *pOutputTypes);
HRESULT __stdcall MFCalculateBitmapImageSize(const BITMAPINFOHEADER *pBMIH, UINT32 cbBufSize, UINT32 *pcbImageSize, BOOL *pbKnown);
HRESULT __stdcall MFCreateAttributes(IMFAttributes **ppMFAttributes, UINT32 cInitialSize);
HRESULT __stdcall MFCreateVideoMediaTypeFromVideoInfoHeader2(const KS_VIDEOINFOHEADER2 *pVideoInfoHeader, DWORD cbVideoInfoHeader, QWORD AdditionalVideoFlags, const GUID *pSubtype, IMFVideoMediaType **ppIVideoMediaType);
HRESULT __stdcall MFCreateVideoMediaTypeFromBitMapInfoHeader(const BITMAPINFOHEADER *pbmihBitMapInfoHeader, DWORD dwPixelAspectRatioX, DWORD dwPixelAspectRatioY, MFVideoInterlaceMode InterlaceMode, QWORD VideoFlags, QWORD qwFramesPerSecondNumerator, QWORD qwFramesPerSecondDenominator, DWORD dwMaxBitRate, IMFVideoMediaType **ppIVideoMediaType);
HRESULT __stdcall MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(const BITMAPINFOHEADER *pbmihBitMapInfoHeader, UINT32 cbBitMapInfoHeader, DWORD dwPixelAspectRatioX, DWORD dwPixelAspectRatioY, MFVideoInterlaceMode InterlaceMode, QWORD VideoFlags, DWORD dwFramesPerSecondNumerator, DWORD dwFramesPerSecondDenominator, DWORD dwMaxBitRate, IMFVideoMediaType **ppIVideoMediaType);
signed int __stdcall sub_77E8835F(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8837C(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8839B(int a1, int a2, int a3);
signed int __stdcall sub_77E883C4(int a1, int a2, int a3);
int __stdcall sub_77E883F0(int, LPFILETIME lpFileTime); // idb
BOOL __stdcall CredPackAuthenticationBufferW(DWORD dwFlags, LPWSTR pszUserName, LPWSTR pszPassword, PBYTE pPackedCredentials, DWORD *pcbPackedCredentials);
int __stdcall sub_77E88464(int, int, void *Dst); // idb
int __stdcall UpdatePanningFeedback(HWND, __int32, __int32, int); // idb
int __stdcall sub_77E88499(int, int, int, void *Dst); // idb
int __stdcall sub_77E884CE(int, int, int, int, void *Dst); // idb
__int64 __stdcall sub_77E88510(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_77E88528(int a1, int a2, int a3);
int __stdcall sub_77E88548(int a1, int a2, int a3, int a4);
int __stdcall sub_77E88568(int a1, int a2, int a3);
int __stdcall FXSAPIInitialize();
int __stdcall sub_77E88632(int a1, int a2, int a3);
signed int __stdcall sub_77E88643(int a1, int a2, int a3);
int __stdcall sub_77E88664(unsigned __int16 *, unsigned __int16 *, unsigned int, int); // idb
signed int __stdcall RsopAccessCheckByTypeInternal(void *a1, void *a2, void *a3, unsigned __int32 a4, struct _OBJECT_TYPE_LIST *a5, unsigned __int32 a6, struct _GENERIC_MAPPING *a7, struct _PRIVILEGE_SET *a8, unsigned __int32 *a9, unsigned __int32 *a10, int *a11);
signed int __stdcall sub_77E886C9(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall sub_77E886E4(int a1, int a2, int a3);
signed int __stdcall GdipCreateHICONFromBitmap(int a1, int a2);
signed int __stdcall sub_77E8871A(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall sub_77E88735(int a1, int a2, int a3);
signed int __stdcall sub_77E88750(int a1, int a2, int a3, int a4);
signed int __stdcall sub_77E8878C(int a1, int a2);
signed int __stdcall sub_77E887A7(int a1);
signed int __stdcall sub_77E887D8(int a1, int a2, int a3);
signed int __stdcall GdipAddPathBezierI(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
signed int __stdcall sub_77E88801(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall sub_77E8881C(int a1, int a2);
signed int __stdcall sub_77E88838(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall GdipDrawImageRectRect(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
signed int __stdcall GdipGraphicsClear(int a1, int a2);
int __stdcall FaxGetInstallType(int a1, int a2, int a3, int a4);
signed int __stdcall FaxSetSenderInformation(int a1);
int __stdcall FaxGetExtensionDataW(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall FmsGetFilteredFontList(int a1, int a2, int a3);
signed int __stdcall FmsGetFontProperty(int a1, int a2, int a3, int a4, int a5);
int __stdcall FmsGetGdiLogicalFont(int, int, int, void *Dst, void *, int); // idb
int __stdcall FmsGetGDILogFont(int, int, int, void *Dst, void *); // idb
signed int __stdcall FmsToggleOnDesignAxis(int a1, int a2, int a3, int a4, int a5);
HRESULT __stdcall MFCreateVideoMixerAndPresenter(IUnknown *pMixerOwner, IUnknown *pPresenterOwner, const IID *const riidMixer, void **ppvVideoMixer, const IID *const riidPresenter, void **ppvVideoPresenter);
signed int __stdcall sub_77E88A36(int a1, int a2);
JET_ERR __stdcall JetRetrieveColumns(JET_SESID sesid, JET_TABLEID tableid, JET_RETRIEVECOLUMN *pretrievecolumn, unsigned __int32 cretrievecolumn);
signed int __stdcall sub_77E88A58(int a1, int a2, int a3);
signed int __stdcall CreateDUIWrapperEx(int a1, int a2, int a3);
signed int __stdcall CreateDUIWrapperFromResource(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall CreateDUIWrapper(int a1, int a2);
int __stdcall MultiByteToUnicode(int a1, int a2, int a3);
signed int __stdcall UiaOnGetObject(int a1, int a2, int a3, int a4, int a5);
unsigned __int32 __stdcall ComSvcsExceptionFilter(struct _EXCEPTION_POINTERS *, const unsigned __int16 *, const unsigned __int16 *); // idb
int __stdcall FaxSendDocumentExA(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall sub_77E88BA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
BOOL __stdcall FaxGetPageData(HANDLE FaxHandle, DWORD JobId, LPBYTE *Buffer, LPDWORD BufferSize, LPDWORD ImageWidth, LPDWORD ImageHeight);
BOOL __stdcall CredUnPackAuthenticationBufferW(DWORD dwFlags, PVOID pAuthBuffer, DWORD cbAuthBuffer, LPWSTR pszUserName, DWORD *pcchMaxUserName, LPWSTR pszDomainName, DWORD *pcchMaxDomainName, LPWSTR pszPassword, DWORD *pcchMaxPassword);
signed int __stdcall ComSvcsLogError(signed int a1, int a2, int a3, int a4);
int __stdcall GetMTAThreadPoolMetrics(struct MTA_METRICS *); // idb
signed int __cdecl GetObjectContext(struct IObjectContext **a1);
signed int __stdcall GetDefaultPartitionForCurrentUser(int a1);
signed int __stdcall GetDefaultPartitionForSid(int a1, int a2);
signed int __stdcall ComPlusRemoteAccessEnabled(int a1);
signed int __stdcall InprocServer32FromString(int a1, int a2, int a3, int a4, int a5);
signed int __stdcall ServerGetApplicationType(struct ISimpleTableDispenser *a1, const struct _GUID *a2, enum __MIDL___MIDL_itf_registrar_0000_0000_0001 *a3);
signed int __stdcall SysprepComplus2();
signed int __stdcall GetTrkSvrObject(int a1, int a2);
signed int __stdcall LsaIAuditReplay(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __stdcall sub_77E88D8D(int a1, int a2);
signed int __stdcall sub_77E88DAD(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
signed int __stdcall sub_77E88E0D(int a1, int a2, int a3);
BOOL __stdcall ConvertSecurityDescriptorToStringSecurityDescriptorA(PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD RequestedStringSDRevision, SECURITY_INFORMATION SecurityInformation, LPSTR *StringSecurityDescriptor, PULONG StringSecurityDescriptorLen);
int __stdcall sub_77E88F1E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __stdcall sub_77E88F45(int a1, int a2, int a3);
int __stdcall sub_77E88F74(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall sub_77E88F9B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int __stdcall sub_77E88FC2(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_77E88FDF(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_77E89000(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_77E8900D(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_77E89066(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __stdcall sub_77E890BD(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_77E890E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __stdcall sub_77E8915E(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall sub_77E8917D(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_77E8919C(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_77E8927B(int a1, int a2, int a3, int a4);
int __stdcall sub_77E89298(int a1, int a2, int a3, int a4, int a5);
int __stdcall StmCoalesceChunks(int a1, int a2, int a3);
int __stdcall sub_77E892C1(int a1, int a2, int a3, int a4);
int __stdcall EnableScheduledDiagnostics(int a1);
int __stdcall sub_77E89324(int a1, int a2);
int __stdcall sub_77E89353(int a1, int a2);
int __stdcall sub_77E8937B(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_77E8941A(int a1, int a2);
int __stdcall sub_77E89484(int a1, int a2, int a3, int a4, int a5);
unsigned int __stdcall GenerateActionQueue(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __stdcall ProcessActionQueue(int a1, int a2, int a3, int a4, int a5);
BOOL __stdcall FaxPrintCoverPageA(const FAX_CONTEXT_INFOA *FaxContextInfo, const FAX_COVERPAGE_INFOA *CoverPageInfo);
LSTATUS __stdcall RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
ULONG __stdcall RegDeleteKeyExInternalA(int a1, PCSZ Source, int a3, int a4, int a5);
LSTATUS __stdcall DeleteAllKeyValues(HKEY hKey);
int __stdcall RegDeleteTreeA(HKEY hKey, PCSZ Source); // idb
HANDLE *__stdcall RegKrnGetAppKeyEventAddressInternal();
LSTATUS __stdcall RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile);
LSTATUS __stdcall RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey);
LSTATUS __stdcall RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey);
LSTATUS __stdcall RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory);
LSTATUS __stdcall RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags);
LSTATUS __stdcall RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
int __stdcall RemapPredefinedHandleInternal(int, HANDLE SourceHandle); // idb
signed int __stdcall CleanupPredefinedHandles();
int __stdcall OpenPredefinedKeyForSpecialAccess(int, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle); // idb
BOOL __stdcall ProcessAppKeyEventInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context);
int __cdecl _except_handler4(int, PVOID TargetFrame, int); // idb
// NTSTATUS __stdcall NtSetInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG FileInformationLength, FILE_INFORMATION_CLASS FileInformationClass);
// int __cdecl _wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// int __stdcall DbgUiDebugActiveProcess(_DWORD); weak
// _DWORD __stdcall DbgUiConnectToDbg(); idb
// int __stdcall DbgUiIssueRemoteBreakin(_DWORD); weak
// int __stdcall NtSetInformationDebugObject(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall DbgUiGetThreadDebugObject(); idb
// int __stdcall DbgUiConvertStateChangeStructure(_DWORD, _DWORD); weak
// int __stdcall DbgUiWaitStateChange(_DWORD, _DWORD); weak
// int __stdcall DbgUiContinue(_DWORD, _DWORD); weak
// int __stdcall DbgUiStopDebugging(_DWORD); weak
// NTSTATUS __stdcall NtReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
// NTSTATUS __stdcall NtWaitForSingleObject(HANDLE Handle, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
// int __cdecl _vsnwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, va_list Args);
// errno_t __cdecl strncat_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
// errno_t __cdecl strcpy_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// NTSTATUS __stdcall NtMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle, PVOID *BaseAddress, ULONG ZeroBits, ULONG CommitSize, PLARGE_INTEGER SectionOffset, PULONG ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Protect);
// ULONG DbgPrintEx(ULONG ComponentId, ULONG Level, PCH Format, ...);
// int __stdcall RtlReadThreadProfilingData(_DWORD, _DWORD, _DWORD); weak
// NTSTATUS __stdcall NtTerminateProcess(HANDLE ProcessHandle, NTSTATUS ExitStatus);
// int __stdcall RtlUnhandledExceptionFilter(_DWORD); weak
// wchar_t *__cdecl _wcslwr(wchar_t *String);
BOOL __stdcall SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
BOOL __stdcall QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);
int __stdcall BasepTpIoCleanupCallback(int a1, int a2);
int __stdcall SbpDeriveVirtualOsVersionOnFastPath(int a1, int a2, int a3, int a4, const void *a5);
int __stdcall SbpRetrieveCompatibilityManifest(HANDLE hActCtx, int); // idb
int __stdcall SbpDeriveVirtualOsVersionBasedOnManifest(HANDLE hActCtx, int, int, int, int); // idb
signed int __stdcall SbGetContextDetailsByGuid(const void *a1, int a2);
int __stdcall SbGetContextDetailsByName(wchar_t *Str1, int); // idb
signed int __stdcall SbpIsValidPlatformGuid(const void *a1);
signed int __fastcall NlsConvertStringToIntegerW(int a1, int a2, signed int a3, unsigned int *a4);
NTSTATUS __stdcall SetRegValue(HANDLE KeyHandle, PCWSTR SourceString, PVOID Data, ULONG DataSize);
NTSTATUS __stdcall NlsConvertIntegerToString(ULONG Value, ULONG Base, int a3, STRSAFE_LPWSTR pszDest, size_t cchDest);
int __stdcall BasepAnsiStringToDynamicUnicodeString(PUNICODE_STRING DestinationString, int); // idb
signed int __stdcall BaseVerifyUnicodeString(int a1);
signed int __stdcall BasepAllocateActivationContextActivationBlock(int a1, int a2, int a3, int a4);
BOOLEAN __stdcall BasepFreeActivationContextActivationBlock(PVOID Address);
void __stdcall __noreturn BaseExitThreadPoolThread(int a1);
int __stdcall BaseCreateThreadPoolThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, int); // idb
int __stdcall IsThisARootDirectory(HANDLE FileHandle, int); // idb
signed int __stdcall BasepIsRealtimeAllowed(char a1, signed int a2);
void *__stdcall GetExtents(HANDLE hDevice);
BOOLEAN __stdcall NotifyMountMgr(PWSTR dosname, PCWSTR SourceString, int a3);
int __stdcall DeleteVolumeNameForRoot(PVOID Address); // idb
BOOL __stdcall DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint);
int __stdcall IsDiskOnCluster(int a1);
int __stdcall IsVolumeOnCluster(LPCWSTR lpFileName, int); // idb
DWORD __stdcall GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer);
// _DWORD __stdcall BaseInvalidateDllSearchPathCache(); idb
// _DWORD __stdcall BaseInvalidateProcessSearchPathCache(); idb
// BOOL __stdcall EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);
// BOOL __stdcall EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
// BOOL __stdcall EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags);
// BOOL __stdcall EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam);
// BOOL __stdcall EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags);
// BOOL __stdcall EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved);
// BOOL __stdcall EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);
// LPVOID __stdcall MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred);
// LPVOID __stdcall VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
// int __stdcall GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);
// int __stdcall GetEraNameCountedString(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName);
// int __stdcall Internal_EnumTimeFormats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall Internal_EnumDateFormats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall Internal_EnumSystemLanguageGroups(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall Internal_EnumLanguageGroupLocales(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall Internal_EnumUILanguages(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall Internal_EnumSystemCodePages(_DWORD, _DWORD, _DWORD); weak
// int __stdcall CheckGroupPolicyEnabled(_DWORD, _DWORD); weak
// int __stdcall GetStringTableEntry(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GetPtrCalData(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall GetPtrCalDataArray(_DWORD, _DWORD, _DWORD); weak
NTSTATUS __stdcall BasepUpdateProcessParametersFlags(HANDLE ProcessHandle, char Buffer, int a3);
int __stdcall GetExeName(const char *a1, char a2, int a3);
int __stdcall AddConsoleAliasInternal(int, __int16, void *, __int16, void *, int); // idb
BOOL __stdcall AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName);
BOOL __stdcall AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName);
int __stdcall GetConsoleAliasInternal(void *, int, int, int, void *, int); // idb
DWORD __stdcall GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName);
DWORD __stdcall GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName);
int __stdcall GetConsoleAliasesLengthInternal(void *Src, int); // idb
DWORD __stdcall GetConsoleAliasesLengthA(LPSTR ExeName);
int __stdcall GetConsoleAliasExesLengthInternal(char a1);
DWORD __stdcall GetConsoleAliasExesLengthW();
DWORD __stdcall GetConsoleAliasExesLengthA();
size_t __stdcall GetConsoleAliasExesInternal(void *Dst, int a2, char a3);
DWORD __stdcall GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength);
BOOLEAN __stdcall ExpungeConsoleCommandHistoryInternal(void *Src, int a2);
BOOLEAN __stdcall ExpungeConsoleCommandHistoryA(void *Src);
signed int __stdcall SetConsoleNumberOfCommandsInternal(int a1, void *a2, char a3);
signed int __stdcall SetConsoleNumberOfCommandsA(int a1, void *a2);
int __stdcall GetConsoleCommandHistoryLengthInternal(void *Src, int); // idb
int __stdcall GetConsoleCommandHistoryLengthA(void *Src); // idb
BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle);
int __stdcall GetConsoleInputExeNameW(int, void *Dst); // idb
size_t __stdcall GetConsoleAliasesInternal(int a1, unsigned __int32 a2, void *a3, int a4);
DWORD __stdcall GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName);
DWORD __stdcall GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName);
size_t __stdcall GetConsoleCommandHistoryInternal(int a1, unsigned __int32 a2, void *a3, int a4);
size_t __stdcall GetConsoleCommandHistoryW(int a1, unsigned __int32 a2, void *a3);
size_t __stdcall GetConsoleCommandHistoryA(int a1, unsigned __int32 a2, void *a3);
int __stdcall GetConsoleInputExeNameA(USHORT a1, CHAR *a2);
int __stdcall SetConsoleInputExeNameA(PCSZ SourceString); // idb
NTSTATUS __stdcall RtlStringCchCopyA(char *pszDest, size_t cchDest, const char *pszSrc);
size_t __stdcall GetConsoleOriginalTitleA(int a1, size_t cbDest);
DWORD __stdcall GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize);
DWORD __stdcall GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize);
signed int __stdcall FreeConsoleInternal();
NTSTATUS __stdcall AttachConsoleInternal(HANDLE ProcessHandle, int a2);
BOOL __stdcall FreeConsole();
NTSTATUS __stdcall AllocConsoleInternal(int a1);
BOOL __stdcall AllocConsole();
BOOL __stdcall AttachConsole(DWORD dwProcessId);
HANDLE __stdcall GetConsoleInputWaitHandle();
signed int __stdcall GetConsoleHandleInformation(int a1, int a2);
signed int __stdcall SetConsoleHandleInformation(int a1, int a2, int a3);
BOOL __stdcall ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
signed int __stdcall SetConsoleCursor(int a1, int a2);
int __stdcall ShowConsoleCursor(int a1, int a2);
int __stdcall ConsoleMenuControl(int a1, int a2, int a3);
signed int __stdcall SetConsolePaletteInternal(int a1, int a2, int a3);
BOOL __stdcall SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions);
signed int __stdcall RegisterConsoleVDM(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
signed int __stdcall GetConsoleHardwareState(int a1, int a2, int a3);
signed int __stdcall SetConsoleHardwareState(int a1, int a2, int a3);
BOOL __stdcall GetConsoleDisplayMode(LPDWORD lpModeFlags);
int __stdcall SetConsoleKeyShortcuts(int, char, void *Src, int); // idb
signed int __stdcall SetConsoleMenuClose(int a1);
signed int __stdcall SetConsolePalette(int a1, int a2, int a3);
bool __stdcall GetConsoleInput(int a1, void *a2, unsigned int a3, int a4, __int16 a5, char a6);
BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
BOOL __stdcall PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
BOOL __stdcall ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
bool __stdcall ReadConsoleInputExA(int a1, void *a2, unsigned int a3, int a4, __int16 a5);
bool __stdcall ReadConsoleInputExW(int a1, void *a2, unsigned int a3, int a4, __int16 a5);
int __stdcall WriteConsoleInputInternal(int, void *Src, int, int, char, char); // idb
BOOL __stdcall WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);
void *__stdcall CopyRectangle(void *Src, __int16 a2, int a3, void *Dst, int a5, int a6);
signed int __stdcall ReadConsoleOutputInternal(int a1, void *a2, int a3, int a4, int a5, char a6);
BOOL __stdcall ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
BOOL __stdcall ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);
int __stdcall WriteConsoleOutputString(int, void *Src, int, int, int, int, int); // idb
BOOL __stdcall WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
BOOL __stdcall WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
BOOL __stdcall WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);
BOOL __stdcall FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
BOOL __stdcall FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);
HANDLE __stdcall CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData);
signed int __stdcall InvalidateConsoleDIBits(int a1, int a2);
signed int __stdcall WriteConsoleOutputInternal(int a1, void *a2, unsigned int a3, int a4, int a5, char a6);
BOOL __stdcall WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
BOOL __stdcall WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);
bool __stdcall ReadConsoleOutputString(int a1, void *Dst, int a3, int a4, int a5, int a6, int a7);
BOOL __stdcall ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
BOOL __stdcall ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);
BOOL __stdcall ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);
NTSTATUS __stdcall SetLastConsoleEventActiveInternal();
NTSTATUS __stdcall SetLastConsoleEventActive();
int __stdcall GetNumberOfConsoleFonts();
BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);
COORD __stdcall GetLargestConsoleWindowSize(HANDLE hConsoleOutput);
BOOL __stdcall SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);
BOOL __stdcall GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);
BOOL __stdcall GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);
BOOL __stdcall GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons);
COORD __stdcall GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont);
BOOL __stdcall GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId);
BOOL __stdcall SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);
BOOL __stdcall FlushConsoleInputBuffer(HANDLE hConsoleInput);
BOOL __stdcall SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);
BOOL __stdcall SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo);
BOOL __stdcall SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow);
BOOL __stdcall ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill);
signed int __stdcall SetConsoleFont(int a1, int a2);
signed int __stdcall SetConsoleIcon(int a1);
BOOL __stdcall SetConsoleCP(UINT wCodePageID);
int __stdcall SetConsoleOutputCPInternal(int a1);
BOOL __stdcall SetConsoleOutputCP(UINT wCodePageID);
DWORD __stdcall GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount);
BOOL __stdcall GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
BOOL __stdcall SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);
int __stdcall GetConsoleFontInfo(int, char, int, void *Dst); // idb
BOOL __stdcall GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
BOOL __stdcall SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
int __stdcall GetConsoleKeyboardLayoutNameWorker(char *pszDest, size_t cchDest, int); // idb
int __stdcall GetConsoleKeyboardLayoutNameA(char *pszDest); // idb
int __stdcall GetConsoleKeyboardLayoutNameW(char *pszDest); // idb
BOOL __stdcall GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont);
signed int __stdcall GetConsoleNlsMode(int a1, int a2);
signed int __stdcall SetConsoleNlsMode(int a1, int a2);
signed int __stdcall GetConsoleCharType(int a1, int a2, int a3);
signed int __stdcall SetConsoleCursorMode(int a1, int a2, int a3);
signed int __stdcall GetConsoleCursorMode(int a1, int a2, int a3);
signed int __stdcall RegisterConsoleOS2(int a1);
signed int __stdcall SetConsoleOS2OemFormat(int a1);
int __stdcall SetConsoleLocalEUDC(int, __int16, int, void *Src); // idb
signed int __stdcall VDMConsoleOperation(unsigned int a1, int a2);
NTSTATUS __stdcall ConsoleClientCleanup(int a1);
HLOCAL __stdcall InitGlobalBuffers(int a1, SIZE_T dwBytes, int a3);
HLOCAL __stdcall InitGlobalBuffersEx();
HLOCAL __stdcall FreeGlobalBuffers(HLOCAL hMem);
int __stdcall lz_CopyFile(HFILE hFile, HFILE, int); // idb
int __stdcall ExpandOrCopyFile(HFILE hFile, HFILE, int); // idb
int __stdcall GetHdr(int, HFILE hFile, int); // idb
BOOL __stdcall IsCompressed(int a1);
int __stdcall LZDecode(HFILE hFile, HFILE, int, char, int, int); // idb
int __stdcall ExtractFileNameW(int a1);
int __stdcall ExtractFileName(int a1);
int __stdcall ExtractExtensionW(int a1);
int __stdcall ExtractExtension(int a1);
WCHAR __stdcall MakeCompressedNameW(wchar_t *Dst, rsize_t SizeInWords);
CHAR __stdcall MakeCompressedName(LPCSTR lpString, rsize_t SizeInBytes);
int __stdcall MakeExpandedName(int a1, unsigned __int8 a2);
int __stdcall CopyDateTimeStamp(HANDLE hFile, HANDLE); // idb
int __stdcall ReadInBuf(int, HFILE hFile, int); // idb
int __stdcall WriteOutBuf(char, HFILE hFile, int); // idb
int __stdcall LZIsCharLowerA(BYTE TestChar); // idb
int __stdcall LZIsCharUpperA(BYTE TestChar); // idb
int __stdcall LZCharNextA(BYTE *a1);
int __stdcall K32EmptyWorkingSet(HANDLE ProcessHandle); // idb
int __stdcall K32GetDeviceDriverFileNameA(int, void *Dst, int); // idb
HLOCAL __stdcall K32GetDeviceDriverFileNameW(int a1, LPWSTR lpWideCharStr, SIZE_T uBytes);
BOOL __stdcall K32EnumPageFilesW(PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine, LPVOID pContext);
int __stdcall CallBackConvertToAscii(int, int, LPCWSTR lpWideCharStr); // idb
BOOL __stdcall K32EnumPageFilesA(PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine, LPVOID pContext);
int __stdcall K32EnumProcessModulesEx(HANDLE ProcessHandle, int, int, int, int); // idb
int __stdcall K32InitializeProcessForWsWatch(HANDLE ProcessHandle); // idb
int __stdcall GetWsChangesInternal(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength); // idb
int __stdcall K32GetWsChanges(HANDLE ProcessHandle, PVOID ProcessInformation, ULONG ProcessInformationLength); // idb
int __stdcall K32GetWsChangesEx(HANDLE ProcessHandle, PVOID ProcessInformation, PULONG ReturnLength); // idb
unsigned int __stdcall K32GetProcessImageFileNameW(HANDLE ProcessHandle, void *Dst, int a3);
unsigned int __stdcall K32GetProcessImageFileNameA(HANDLE ProcessHandle, LPSTR lpMultiByteStr, int cbMultiByte);
__int16 __stdcall KeySemanticsGetSid(int a1, int a2);
NTSTATUS __stdcall GetFixedKeyInfo(HANDLE KeyHandle, HANDLE a2, int a3, int a4, int a5, int a6, int a7);
NTSTATUS __stdcall BaseRegMapClassOnAccessDenied(int a1, PHANDLE KeyHandle, PUNICODE_STRING DestinationString, int a4, int a5);
signed int __stdcall ExtractClassKey(HANDLE *a1, int a2, int a3);
NTSTATUS __stdcall CreateMultipartUserClassKey(HANDLE a1, int a2);
ULONG __stdcall LocalBaseRegUnLoadKey(void *a1, int a2);
int __stdcall CombineKeyInfo(int a1, int a2, int a3, int a4, int a5);
int __stdcall LocalOpenPerformanceNlsText(int a1, int a2, int a3);
signed int __stdcall SfpInstallCatalog(int a1, int a2, int a3);
BOOLEAN __stdcall ValStateReleaseValues(PVOID Address, int a2);
signed int __stdcall ValStateAddValueToSortedValues(int a1, int a2);
NTSTATUS __stdcall EnumerateValue(HANDLE KeyHandle, ULONG Index, PVOID KeyValueInformation, ULONG KeyValueInformationLength, int a5);
NTSTATUS __stdcall ValStateUpdate(ULONG Index);
int __stdcall BasepSxsOverrideStreamToMessageStream(int a1, int a2);
NTSTATUS __stdcall SetFilePointerFromBegin(HANDLE FileHandle, int a2);
NTSTATUS __stdcall ReadFileSync(HANDLE FileHandle, PVOID Buffer, ULONG Length, int a4);
NTSTATUS __stdcall BasepSxsCreateResourceStreamFromFileHandle(int a1, ULONG Length, PHANDLE FileHandle, int a4);
BOOL __stdcall SXSEnumProc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam);
PVOID __stdcall WerpGetLastError();
signed int StringCchPrintfW(wchar_t *Dest, unsigned int a2, wchar_t *Format, ...);
signed int __stdcall GetCrashVerticalPaths(HANDLE hProcess, void *a2, wchar_t *Dest, unsigned __int32 a4, wchar_t *a5, unsigned __int32 a6, LPWSTR lpBuffer, UINT uSize);
int __stdcall StartCrashVertical(HANDLE ProcessHandle, void *a2, void **a3);
const unsigned __int16 *__stdcall WerpPathTail(LPCWSTR lpString); // idb
signed int __stdcall ERROR_HR_FROM_WIN32(__int32 a1);
signed int __stdcall StringCchVPrintfA(char *Dest, unsigned int a2, const char *Format, va_list Args);
void DbgPrintOut(int a1, char *Format, ...);
int __stdcall WerpIsProtectedProcess(HANDLE ProcessHandle); // idb
int __stdcall WerpIsProcessInAeDebugExclusionList(HANDLE ProcessHandle); // idb
int __stdcall WerpGetDebugger(HANDLE ProcessHandle, unsigned __int16 *, unsigned int, int, int); // idb
signed int __stdcall WerpLaunchAeDebug(void *a1, void *a2, char *a3, const void *a4, WCHAR *a5, int a6);
signed int __stdcall GetNtdllFunction(LPCSTR lpProcName, void **a2);
int __stdcall WerpNtWow64QueryInformationProcess64(void *a1, enum _PROCESSINFOCLASS a2, void *a3, unsigned __int32 a4, unsigned __int32 *a5);
int __stdcall WerpNtWow64ReadVirtualMemory64(void *a1, unsigned __int64 a2, void *a3, unsigned __int64 a4, unsigned __int64 *a5);
signed int __stdcall _FindFileByPath(wchar_t *Str2, struct _WER_GATHER **a2, struct _WER_GATHER **a3);
signed int __stdcall WerpUnregisterFile(PCWSTR pwzFilePath);
signed int __stdcall WerpRegisterFile(PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags);
signed int __stdcall WerpGetPeb32FromProcess(HANDLE ProcessHandle, struct _PEB32 *lpBuffer);
int __stdcall WerpGetPeb64FromProcess(void *a1, struct _PEB64 *a2);
signed int __stdcall WerpGetRecoveryInfoForSelf(struct _WER_RECOVERY_INFO **a1);
signed int __stdcall WerpRecoveryInProgress(int a1);
void __stdcall WerpRecoveryFinished(int a1);
signed int __stdcall WerpAddRuntimeDllToPEB(struct _WER_RUNTIME_DLL *a1, int *a2);
signed int __stdcall WerpRegisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext);
signed int __stdcall WerpUnregisterRuntimeExceptionModule(const unsigned __int16 *a1, int a2);
signed int __stdcall WerpInitiateRecovery(struct _WER_RECOVERY_INFO *a1);
signed int __stdcall WerpRecoveryInvokedRemotely();
int __stdcall RealWerpStringLookup(unsigned __int16 *, void **); // idb
struct Node *__thiscall FSPErrorMessages::CMessageMapper::Lookup(FSPErrorMessages::CMessageMapper *this, const unsigned __int16 *a2, void **a3);
void __thiscall FSPErrorMessages::CMessageMapper::ResetAndDisable(FSPErrorMessages::CMessageMapper *__hidden this); // idb
int __stdcall HashStringToDwordCaseInsensitive(const unsigned __int16 *a1);
int __stdcall FSPErrorMessages::CMessageMapper::ReportMessage(struct tagWerpMessageId *a2, unsigned __int32 a3, const unsigned __int16 *a4);
int __stdcall FSPErrorMessages::CMessageMapper::ReportMessageText(const unsigned __int16 *a2, unsigned __int32 a3);
__int32 __stdcall FSPErrorMessages::CMessageMapper::GetModuleTimeStampFromFileNameNoLock(LPCWSTR lpLibFileName, unsigned __int32 *a3);
signed int __stdcall FSPErrorMessages::CMessageMapper::GetModuleVersionFromFileNameNoLock(LPCWSTR lpLibFileName, unsigned __int32 *a3, unsigned __int32 *a4);
signed int __stdcall StringCchCatW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3);
signed int __stdcall StringCbLengthA(const char *a1, unsigned int a2, unsigned int *a3);
__int32 __thiscall FSPErrorMessages::CMessageMapper::PopulateModuleInformation(FSPErrorMessages::CMessageMapper *this, wchar_t *Str, unsigned __int32, struct tagWerpMessageId *); // idb
signed int __thiscall FSPErrorMessages::CMessageMapper::ReportMessageFromText(FSPErrorMessages::CMessageMapper *this, LONG Exchange, unsigned __int32 a3);
signed int __thiscall FSPErrorMessages::CMessageMapper::ReportMessageFromStringId(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, unsigned __int32 a3, unsigned __int32 a4);
void __thiscall FSPErrorMessages::CMessageTagCache::Init(FSPErrorMessages::CMessageTagCache *this, void *); // idb
void __thiscall FSPErrorMessages::CMessageTagCache::Free(FSPErrorMessages::CMessageTagCache *this, void *); // idb
void __thiscall FSPErrorMessages::CMessageTagCache::InsertNode(FSPErrorMessages::CMessageTagCache *this, unsigned __int32, struct Node *); // idb
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::LookupNodeByMessageTag(FSPErrorMessages::CMessageTagCache *this, unsigned __int32, struct FSPErrorMessages::MessageTag *); // idb
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::LookupNodeByMessage(FSPErrorMessages::CMessageTagCache *this, unsigned __int32, const unsigned __int16 *); // idb
void __stdcall FSPErrorMessages::CMessageTagCache::ProcessCRLFs(const unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int32 a4);
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::Lookup(FSPErrorMessages::CMessageTagCache *this, const unsigned __int16 *a2, void **a3);
int __thiscall FSPErrorMessages::CMessageTagCache::LookupTag(FSPErrorMessages::CMessageTagCache *this, LPCWSTR lpString, struct FSPErrorMessages::MessageTag *); // idb
void FSPErrorMessages::CMessageTagCache::DumpTrace(FSPErrorMessages::CMessageTagCache *this, const char *Format, ...); // idb
int __thiscall FSPErrorMessages::CMessageTagCache::ReclaimMemory(FSPErrorMessages::CMessageTagCache *this); // idb
void *__thiscall FSPErrorMessages::CMessageTagCache::Alloc(FSPErrorMessages::CMessageTagCache *this, ULONG Size); // idb
signed int __thiscall FSPErrorMessages::CMessageTagCache::Insert(FSPErrorMessages::CMessageTagCache *this, struct FSPErrorMessages::MessageTag *a2, const unsigned __int16 *a3, void **a4);
FSPErrorMessages::CMessageHashVectorBuilder *__thiscall FSPErrorMessages::CMessageHashVectorBuilder::CMessageHashVectorBuilder(FSPErrorMessages::CMessageHashVectorBuilder *this);
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetPrintfFormatStringLength(const unsigned __int16 *lpString);
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetMessageHashVectorSize(unsigned __int32 a2);
unsigned __int32 __stdcall FSPErrorMessages::HashStringToDword(LPCWSTR lpString, const unsigned __int16 *, unsigned int); // idb
int __stdcall FSPErrorMessages::HashStringToWord(FSPErrorMessages *this, const unsigned __int16 *a2, unsigned int a3);
int __thiscall FSPErrorMessages::CMessageHashVector::Match(FSPErrorMessages::CMessageHashVector *this, const unsigned __int16 *lpString);
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetStartIndexHash(const unsigned __int16 *Str);
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetEndIndexHash(const unsigned __int16 *Str);
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetCombinedIndexHash(const unsigned __int16 *a2);
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::Construct(const unsigned __int16 *Str, unsigned __int32 a3, struct FSPErrorMessages::CMessageHashVector *a4);
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetFormatStringLength(const unsigned __int16 *a2);
signed int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::NormalizeString(const unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int32 a4);
int __stdcall FSPErrorMessages::CConfig::GetCurrentUserSID(struct _UNICODE_STRING *UnicodeString);
int __stdcall FSPErrorMessages::LocalDuplicateTokenEx(HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, unsigned __int32, struct _SECURITY_ATTRIBUTES *, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle, void **); // idb
// int __usercall FSPErrorMessages::CConfig::IsSetupInProgress@<eax>(FSPErrorMessages::CConfig *this@<ecx>, unsigned __int32 *a2@<esi>);
int __stdcall FSPErrorMessages::CConfig::GetTracingEnabledValueFromKey(void *KeyHandle);
unsigned __int32 __stdcall FSPErrorMessages::CConfig::GetHeapSizeFromKey(void *KeyHandle);
int __thiscall FSPErrorMessages::CConfig::OpenPerUserKey(FSPErrorMessages::CConfig *__hidden this); // idb
int __stdcall FSPErrorMessages::LocalDuplicateToken(FSPErrorMessages *this, void *a2, enum _SECURITY_IMPERSONATION_LEVEL NewTokenHandle, void **a4);
bool __stdcall FSPErrorMessages::CConfig::CheckTokenMembership(void *a2, void *a3, int *a4);
int FSPErrorMessages::CConfig::IsInteractiveUser();
unsigned __int32 __thiscall FSPErrorMessages::CConfig::GetHeapSize(FSPErrorMessages::CConfig *this); // idb
void __stdcall FSPErrorMessages::CConfig::GetAppName(unsigned __int16 *a2);
int FSPErrorMessages::CConfig::IsRestrictedProcess();
int FSPErrorMessages::CConfig::IsTracedProcess();
int __thiscall FSPErrorMessages::CConfig::IsTracingEnabled(FSPErrorMessages::CConfig *this); // idb
void __thiscall FSPErrorMessages::CResourceModuleInfoTable::Init(FSPErrorMessages::CResourceModuleInfoTable *this, void *); // idb
int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Lookup(FSPErrorMessages::CResourceModuleInfoTable *this, const unsigned __int16 *lpString, unsigned int *a3, struct FSPErrorMessages::CResourceModuleInfoTable::Bucket **a4);
signed int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Deintern(FSPErrorMessages::CResourceModuleInfoTable *this, const unsigned __int16 *a2);
signed int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Intern(FSPErrorMessages::CResourceModuleInfoTable *this, LPCWSTR lpString, const unsigned __int16 **a3);
// void __stdcall DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);
// BOOL __stdcall UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize);
// BOOL __stdcall InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize);
// BOOL __stdcall GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost);
// BOOL __stdcall SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost);
// BOOL __stdcall SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags);
// BOOL __stdcall QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags);
// BOOL __stdcall HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength);
// BOOL __stdcall HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary);
// BOOL __stdcall VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// HANDLE __stdcall CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// HANDLE __stdcall OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName);
// HANDLE __stdcall FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// HANDLE __stdcall FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
// BOOL __stdcall RemoveDirectoryA(LPCSTR lpPathName);
// DWORD __stdcall GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
// BOOL __stdcall GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable);
// int __stdcall FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase);
// BOOL __stdcall TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut);
// BOOL __stdcall GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength);
// BOOL __stdcall GetNamedPipeAttribute(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, PSIZE_T AttributeValueLength);
// BOOL __stdcall PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);
// BOOL __stdcall NeedCurrentDirectoryForExePathA(LPCSTR ExeName);
// BOOL __stdcall Wow64RevertWow64FsRedirection(PVOID OlValue);
// void __stdcall FatalAppExitA(UINT uAction, LPCSTR lpMessageText);
// void __stdcall FatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
// BOOL __stdcall GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize);
// BOOL __stdcall GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// BOOL __stdcall IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags);
// BOOL __stdcall SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData);
// BOOL __stdcall SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
// int __stdcall NlsEventDataDescCreate(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NlsWriteEtwEvent(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// BOOL __stdcall GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo);
// int __stdcall LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam);
// BOOL __stdcall SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue);
// BOOL __stdcall Beep(DWORD dwFreq, DWORD dwDuration);
// ULONG DbgPrint(PCH Format, ...);
// int __stdcall NtRemoveProcessDebug(_DWORD, _DWORD); weak
// errno_t __cdecl strcat_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// int __cdecl _strnicmp(const char *Str1, const char *Str2, size_t MaxCount);
// int __cdecl _vsnprintf(char *Dest, size_t Count, const char *Format, va_list Args);
// int __stdcall WerReportSQMEvent(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall WinSqmIsOptedIn(); idb

//-------------------------------------------------------------------------
// Data declarations

// extern int RtlGetLengthWithoutLastFullDosOrNtPathElement; weak
// extern BOOLEAN *NlsMbCodePageTag;
int g_DllMap = 259; // weak
char *off_77E081D0 = "aclui.dll"; // weak
int CurrentConfigStringKey = 8913032; // weak
char byte_77E154AE[5] = { '', '', '', '', '' }; // weak
_UNKNOWN _BaseFiberStart; // weak
_UNKNOWN loc_77E16708; // weak
int BaseDllIniSoftwareKeyPath = 3538996; // weak
int BaseDllIniDefaultUserKeyPath = 3145774; // weak
_UNKNOWN loc_77E17A7E; // weak
_UNKNOWN loc_77E17A97; // weak
_UNKNOWN loc_77E17AA1; // weak
_UNKNOWN loc_77E17B4B; // weak
_UNKNOWN loc_77E18103; // weak
_UNKNOWN loc_77E1821B; // weak
_UNKNOWN loc_77E18228; // weak
_UNKNOWN loc_77E18267; // weak
_UNKNOWN loc_77E183B8; // weak
_UNKNOWN loc_77E183CC; // weak
OBJECT_ATTRIBUTES ObjectAttributes = { 24u, NULL, &dword_77E1963C, 64u, NULL, NULL }; // idb
LSA_UNICODE_STRING ValueName = { 58u, 60u, L"CopyFileBufferedSynchronousIo" }; // idb
OBJECT_ATTRIBUTES stru_77E19804 = { 24u, NULL, &aXz, 64u, NULL, NULL }; // idb
LSA_UNICODE_STRING stru_77E1981C = { 34u, 36u, L"CopyFileChunkSize" }; // idb
LSA_UNICODE_STRING stru_77E19824 = { 46u, 48u, L"CopyFileOverlappedCount" }; // idb
int UserStringKey = 1835036; // weak
int pDigitRanges[29] =
{
  3735600,
  107546208,
  116983536,
  158271846,
  166660582,
  175049318,
  183438054,
  191826790,
  200215526,
  208604262,
  216992998,
  225381734,
  240717392,
  249106128,
  254349088,
  273223744,
  278466704,
  401151968,
  404297744,
  424614214,
  465116080,
  474553408,
  475602000,
  2787747360,
  2832836816,
  2835982592,
  2858003024,
  4279893776,
  2425393296
}; // weak
_UNKNOWN loc_77E1DEA7; // weak
char byte_77E1E0E2 = '\0'; // weak
int ByteMatchAppendedDataInstallers = 0; // weak
int ByteMatchEOFInstallers = 0; // weak
_UNKNOWN loc_77E2021C; // weak
_UNKNOWN loc_77E2022D; // weak
char byte_77E20489[5] = { '', '', '', '', '' }; // weak
const UNICODE_STRING ConsoleInput = { 12u, 14u, L"CONIN$" }; // idb
const UNICODE_STRING ConsoleOutput = { 14u, 16u, L"CONOUT$" }; // idb
int IllegalMask[] = { 4294967295 }; // weak
int ClassesStringKey = 4456516; // weak
_UNKNOWN loc_77E23830; // weak
_UNKNOWN loc_77E24AAC; // weak
int SxsPolicySuffix = 1048590; // weak
int SxsManifestSuffix = 1310738; // weak
const UNICODE_STRING gMachineClassesName = { 68u, 68u, L"\\Registry\\Machine\\Software\\Classes" }; // idb
_UNKNOWN loc_77E27CEF; // weak
_UNKNOWN loc_77E2A7FB; // weak
int MachineStringKey = 2228258; // weak
const UNICODE_STRING BaseConsoleInput = { 12u, 14u, L"CONIN$" }; // idb
const UNICODE_STRING BaseConsoleOutput = { 14u, 16u, L"CONOUT$" }; // idb
const UNICODE_STRING BaseConsoleGeneric = { 6u, 8u, L"CON" }; // idb
const WCHAR Src = 0u; // idb
int (*pSortTblPtrs)[30] = &SortTblPtrs; // weak
_UNKNOWN loc_77E315C1; // weak
struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority = { { 0u, 0u, 0u, 0u, 0u, 5u } }; // idb
OBJECT_ATTRIBUTES stru_77E31FC0 = { 24u, NULL, &dword_77E3B698, 64u, NULL, NULL }; // idb
LSA_UNICODE_STRING stru_77E31FD8 = { 36u, 38u, L"TransparentEnabled" }; // idb
OBJECT_ATTRIBUTES stru_77E31FE0 = { 24u, NULL, &dword_77E3B6A0, 64u, NULL, NULL }; // idb
int dword_77E31FF8 = 1703960; // weak
STRING ProcedureName = { 18u, 19u, "SaferIdentifyLevel" }; // idb
STRING stru_77E32008 = { 26u, 27u, "SaferComputeTokenFromLevel" }; // idb
STRING stru_77E32010 = { 15u, 16u, "SaferCloseLevel" }; // idb
STRING stru_77E32018 = { 24u, 25u, "SaferRecordEventLogEntry" }; // idb
LSA_UNICODE_STRING stru_77E32020 = { 38u, 40u, L"AuthenticodeEnabled" }; // idb
LSA_UNICODE_STRING BaseTmpVariableName = { 6u, 8u, L"TMP" }; // idb
LSA_UNICODE_STRING stru_77E32578 = { 28u, 30u, L"__COMPAT_LAYER" }; // idb
int SbSupportedOsList[] = { 0 }; // weak
int dword_77E33608[5] = { 3791721559, 1136989510, 2365652645, 4040418286, 6 }; // weak
wchar_t *off_77E3361C = L"windows vista"; // weak
int dword_77E33D98 = 2883626; // weak
int o_1_a_87_s_0_tpsig2_8 = 10223770; // weak
OBJECT_ATTRIBUTES stru_77E34554 = { 24u, NULL, &dword_77E3456C, 64u, NULL, NULL }; // idb
OBJECT_ATTRIBUTES stru_77E34738 = { 24u, NULL, &dword_77E34618, 64u, NULL, NULL }; // idb
OBJECT_ATTRIBUTES stru_77E34750 = { 24u, NULL, &dword_77E34620, 64u, NULL, NULL }; // idb
OBJECT_ATTRIBUTES stru_77E34768 = { 24u, NULL, &dword_77E34780, 64u, NULL, NULL }; // idb
const UNICODE_STRING stru_77E34AFC = { 42u, 44u, L"\\system32\\apphelp.dll" }; // idb
STRING stru_77E34B04 = { 20u, 21u, "ApphelpCheckRunAppEx" }; // idb
STRING stru_77E34B0C = { 24u, 25u, "ApphelpQueryModuleDataEx" }; // idb
STRING stru_77E34B14 = { 22u, 23u, "ApphelpParseModuleData" }; // idb
STRING stru_77E34B1C = { 26u, 27u, "ApphelpCreateAppcompatData" }; // idb
STRING stru_77E34B24 = { 17u, 18u, "SdbInitDatabaseEx" }; // idb
STRING stru_77E34B2C = { 18u, 19u, "SdbReleaseDatabase" }; // idb
STRING stru_77E34B34 = { 22u, 23u, "SdbUnpackAppCompatData" }; // idb
STRING stru_77E34B3C = { 15u, 16u, "SdbQueryContext" }; // idb
int (__stdcall *g_Methods)(int, int, LONG_PTR lParam) = &SXSManifest; // weak
char *ByteMatchSectionInstallers = ".data"; // weak
int StringTableInstallers[3] = { 1, 3, 0 }; // weak
int ResourceDataMatchInstallers = 10; // weak
int SXSManifestInstallers[] = { 13 }; // weak
char *off_77E3CB3C = "JR.Inno.Setup"; // weak
wchar_t *off_77E3CB40 = L"JR.Inno.Setup"; // weak
_UNKNOWN locret_77E3E51F; // weak
int GregorianDaysToMonth365[] = { 0 }; // weak
_UNKNOWN loc_77E3E850; // weak
int GregorianDaysToMonth366[] = { 0 }; // weak
int DaysPerYear = 365; // weak
int DaysPer4Years = 1461; // weak
int DaysPer100Years = 36524; // weak
int DaysPer400Years = 146097; // weak
const UNICODE_STRING BaseDotComSuffixName = { 8u, 10u, L".com" }; // idb
const UNICODE_STRING BaseDotPifSuffixName = { 8u, 10u, L".pif" }; // idb
const UNICODE_STRING BaseDotExeSuffixName = { 8u, 10u, L".exe" }; // idb
wchar_t a_pif[5] = L".pif"; // weak
char byte_77E44AB6[5] = { '', '', '', '', '' }; // weak
_UNKNOWN loc_77E4540E; // weak
_UNKNOWN loc_77E4544A; // weak
_UNKNOWN loc_77E45453; // weak
_UNKNOWN loc_77E4546C; // weak
int pXWDrop = 3320054726; // weak
_UNKNOWN loc_77E45480; // weak
int pXWSeparator = 4294902527; // weak
_UNKNOWN loc_77E45558; // weak
_UNKNOWN loc_77E4654B; // weak
_UNKNOWN loc_77E46565; // weak
_UNKNOWN loc_77E46597; // weak
_UNKNOWN loc_77E465AF; // weak
_UNKNOWN loc_77E49499; // weak
_UNKNOWN loc_77E4953C; // weak
_UNKNOWN loc_77E49553; // weak
_UNKNOWN loc_77E4955D; // weak
_UNKNOWN loc_77E49565; // weak
_UNKNOWN loc_77E49566; // weak
_UNKNOWN loc_77E49572; // weak
char byte_77E4A160[5] = { '', '', '', '', '' }; // weak
_UNKNOWN loc_77E4A61D; // weak
_UNKNOWN loc_77E4AF90; // weak
wchar_t asc_77E4FB2C[3] = L" :"; // weak
LSA_UNICODE_STRING BaseUserProfileVariableName = { 22u, 24u, L"USERPROFILE" }; // idb
LSA_UNICODE_STRING BaseTempVariableName = { 8u, 10u, L"TEMP" }; // idb
LSA_UNICODE_STRING stru_77E5121C = { 22u, 24u, L"OptionValue" }; // idb
LSA_UNICODE_STRING stru_77E51224 = { 32u, 34u, L"DisableAppCompat" }; // idb
LSA_UNICODE_STRING stru_77E5122C = { 26u, 28u, L"DisableEngine" }; // idb
struct _RTL_QUERY_REGISTRY_TABLE BasepAppCertTable =
{
  &BasepConfigureAppCertDlls,
  1u,
  L"AppCertDlls",
  &BasepAppCertDllsList,
  0u,
  NULL,
  0u
}; // idb
LSA_UNICODE_STRING stru_77E5190C = { 22u, 24u, L"OptionValue" }; // idb
LSA_UNICODE_STRING stru_77E52390 = { 16u, 18u, L"HOMEPATH" }; // idb
LSA_UNICODE_STRING stru_77E52398 = { 18u, 20u, L"HOMEDRIVE" }; // idb
char *off_77E52440 = "TermsrvGetComputerName"; // weak
int off_77E52444[] = { 2011850740 }; // weak
int WebBladeDisallowedHashes[92] =
{
  3072396816,
  3723629117,
  222477238,
  4214108550,
  1382502161,
  2533552926,
  4016617081,
  3406720348,
  2156107043,
  3352311459,
  1989266573,
  4180757101,
  2011439908,
  3685026360,
  2857357047,
  1572820851,
  2661540653,
  1066774353,
  3269505886,
  2926603150,
  3450010418,
  3586538169,
  983633553,
  1045297145,
  577236027,
  2714937340,
  2801901366,
  3170960999,
  2608946764,
  2880889575,
  1541510073,
  2191960999,
  851204687,
  1200535223,
  2571553890,
  3075075887,
  292143442,
  429214117,
  1295384035,
  3233631052,
  2112856917,
  1911993518,
  327384936,
  3799058066,
  2901858142,
  3117309084,
  914897271,
  2412602456,
  1702525036,
  2215168527,
  3102156177,
  531348033,
  3047885427,
  2783549577,
  920635408,
  2932617211,
  2292343427,
  2014203808,
  2511647741,
  438989748,
  2578643587,
  101817967,
  3786147973,
  2021060352,
  1958643617,
  1021914892,
  1959743733,
  2343097598,
  1222031268,
  1299980964,
  3295465521,
  3822067393,
  225194151,
  3245159411,
  1257403908,
  3314131104,
  3613189034,
  418514587,
  3793113599,
  502224256,
  406522556,
  2240122182,
  3458012108,
  63386706,
  2457000385,
  416693608,
  320511139,
  2278293299,
  3742852322,
  1499506042,
  4104539273,
  3698972241
}; // weak
int StorageServerDisallowedHashes[32] =
{
  922942743,
  351679215,
  1850036637,
  1300049427,
  2960895546,
  3371912743,
  3512827249,
  2022582646,
  1702525036,
  2215168527,
  3102156177,
  531348033,
  2538628210,
  2619184716,
  1641273268,
  1506500410,
  3437561990,
  2241162621,
  1170296089,
  1555021926,
  378125710,
  1021604317,
  2468941933,
  4234759801,
  1562723480,
  4194502315,
  3455192425,
  2377983911,
  1718774518,
  94903051,
  3711621654,
  3612228991
}; // weak
int ComputeServerDisallowedHashes[76] =
{
  3072396816,
  3723629117,
  222477238,
  4214108550,
  922942743,
  351679215,
  1850036637,
  1300049427,
  2156107043,
  3352311459,
  1989266573,
  4180757101,
  2661540653,
  1066774353,
  3269505886,
  2926603150,
  2960895546,
  3371912743,
  3512827249,
  2022582646,
  2608946764,
  2880889575,
  1541510073,
  2191960999,
  851204687,
  1200535223,
  2571553890,
  3075075887,
  2112856917,
  1911993518,
  327384936,
  3799058066,
  2901858142,
  3117309084,
  914897271,
  2412602456,
  1702525036,
  2215168527,
  3102156177,
  531348033,
  2538628210,
  2619184716,
  1641273268,
  1506500410,
  3047885427,
  2783549577,
  920635408,
  2932617211,
  2292343427,
  2014203808,
  2511647741,
  438989748,
  3437561990,
  2241162621,
  1170296089,
  1555021926,
  378125710,
  1021604317,
  2468941933,
  4234759801,
  1562723480,
  4194502315,
  3455192425,
  2377983911,
  225194151,
  3245159411,
  1257403908,
  3314131104,
  3742852322,
  1499506042,
  4104539273,
  3698972241,
  1718774518,
  94903051,
  3711621654,
  3612228991
}; // weak
_UNKNOWN loc_77E5549B; // weak
_UNKNOWN loc_77E570FC; // weak
_UNKNOWN loc_77E57103; // weak
_UNKNOWN loc_77E5AA9C; // weak
int dword_77E5C984 = 1441812; // weak
_UNKNOWN loc_77E5D758; // weak
_UNKNOWN loc_77E5F2DB; // weak
_UNKNOWN loc_77E5F8F5; // weak
_UNKNOWN loc_77E6103C; // weak
int mwStreamList[] = { 3 }; // weak
char N2C[] = { '0' }; // weak
int g_ulDelayLoad_Win32Error = 1285; // weak
int g_lDelayLoad_NtStatus = 3221226514; // weak
char HebrewTable[] = { '\a' }; // weak
char byte_77E61C99[] = { '\x03' }; // weak
char LunarMonthLen[] = { '\0' }; // weak
__int16 YearsInfo[] = { 746 }; // weak
__int16 word_77E6222A[] = { 1900 }; // weak
__int16 word_77E6222C[] = { 4 }; // weak
__int16 word_77E6222E[] = { 30 }; // weak
int dword_77E62654[] = { 917509 }; // weak
int HijriMonthDays = 0; // weak
int pSurrogateDigitRanges[5] = { 3755466702, 3756122072, 3756777442, 3757432812, 3758088182 }; // weak
GUID GUID_NULL = { 0u, 0u, 0u, { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } };
wchar_t aA[3] = L"A:"; // weak
int MS_Windows_UAC_Provider[4] = { 3881140841, 1189953445, 1849445791, 1440623912 }; // weak
int UACUnhandledErrorElevationRequired[3] = { 268435457, 65538, 0 }; // weak
OBJECT_ATTRIBUTES stru_77E6C570 = { 24u, NULL, &aXz_0, 64u, NULL, NULL }; // idb
LSA_UNICODE_STRING stru_77E6C588 = { 78u, 80u, L"CopyFileAllowDecryptedRemoteDestination" }; // idb
char algn_77E6F353[5] = { '', '', '', '', '' }; // weak
int *off_77E7DF80[2] = { &dword_77EA6800, &dword_77EA6850 }; // weak
int NLS_ETW_EVENT_POLICY_NO_GEO_ID_CHANGE[3] = { 268436957, 2236675, 0 }; // weak
int NLS_ETW_EVENT_SET_USER_GEO_ID[3] = { 268438458, 2302212, 0 }; // weak
const EVENT_DESCRIPTOR MUI_ETW_EVENT_CALLBACK_DLL_LOAD_FAILURE = { 2001u, 0u, 17u, 2u, 31u, 30u, 4611686018427387904ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_CALLBACK_FUNCTION_NOT_FOUND = { 2002u, 0u, 17u, 2u, 31u, 30u, 4611686018427387904ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_CALLBACK_DLL_NOT_SIGNED = { 2003u, 0u, 17u, 2u, 31u, 30u, 4611686018427387904ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_CALLBACK_DLL_NOT_FOUND = { 2004u, 0u, 17u, 2u, 31u, 30u, 4611686018427387904ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_NOTIFY_INIT_INFO = { 3000u, 0u, 16u, 4u, 30u, 30u, 9223372036854775808ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_NOTIFY_CALLBACK_RETURN_INFO = { 3002u, 0u, 16u, 4u, 31u, 30u, 9223372036854775808ui64 }; // idb
int MUI_ETW_PROVIDER[5] = { 2829185782, 1172939066, 422903473, 4066287190, 2425393296 }; // weak
const EVENT_DESCRIPTOR MUI_ETW_EVENT_NOTIFY_ERROR = { 2000u, 0u, 16u, 2u, 31u, 30u, 9223372036854775808ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_NOTIFY_START = { 3010u, 0u, 18u, 4u, 35u, 31u, 2305843009213693952ui64 }; // idb
const EVENT_DESCRIPTOR MUI_ETW_EVENT_NOTIFY_END = { 3011u, 0u, 18u, 4u, 36u, 31u, 2305843009213693952ui64 }; // idb
const PROPERTYKEY PKEY_Null = { { 0u, 0u, 0u, { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } }, 0u };
char byte_77E8AAC0[5] = { '', '', '', '', '' }; // weak
__int16 word_77E90984[] = { 26 }; // weak
__int16 word_77E90988[] = { 52 }; // weak
__int16 word_77E9098C[] = { 16 }; // weak
int dword_77E91D24 = 11665584; // weak
int dword_77E91D2C = 12845250; // weak
int dword_77E91FA8 = 9306252; // weak
int dword_77E91FB0 = 10485918; // weak
LSA_UNICODE_STRING stru_77E91FB8 = { 16u, 18u, L"Debugger" }; // idb
int dword_77E91FC0 = 2359330; // weak
LSA_UNICODE_STRING stru_77E91FC8 = { 36u, 38u, L"LaunchNonProtected" }; // idb
LSA_UNICODE_STRING stru_77E91FD0 = { 8u, 10u, L"Auto" }; // idb
wchar_t *off_77E95240[3] = { L"windbg.exe", L"cdb.exe", L"ntsd.exe" }; // weak
wchar_t *off_77E952AC[5] =
{
  L"iexplore.exe",
  L"explorer.exe",
  L"outlook.exe",
  L"wmplayer.exe",
  L"winmail.exe"
}; // weak
GUID stru_77EA5F18 = { 400079046u, 18401u, 19485u, { 175u, 156u, 111u, 194u, 6u, 170u, 172u, 81u } }; // weak
__int16 ExeNameLength = 0; // weak
__int16 StartDirLength = 0; // weak
char ExeNameInitialized = '\0'; // weak
PULONG SystemRangeStart = NULL; // idb
HANDLE BaseHeap = NULL; // idb
int g_fLemStaticInitialized = 0; // weak
int AllocatedHandlerListLength = 0; // weak
SIZE_T HandlerListLength = 0u; // idb
int (__stdcall *pfnDuplicateEncryptionInfoFile)(int, int, int, int, int) = &LoadDuplicateEncryptionInfoFile; // weak
volatile LONG BaseLocalAtomTable = 0; // idb
HANDLE InputWaitHandle = (HANDLE)0xFFFFFFFF; // idb
volatile LONG BaseAnsiStartupInfo = 0; // idb
struct _RTL_CRITICAL_SECTION ExeNameCriticalSection = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int (__stdcall *UserWaitForInputIdleRoutine)(_DWORD, _DWORD) = NULL; // weak
volatile LONG gApphelpGlobals = 0; // idb
volatile LONG dword_77EA6060 = 0; // idb
volatile LONG dword_77EA6064 = 0; // idb
int dword_77EA6068 = 0; // weak
volatile LONG dword_77EA606C = 0; // idb
volatile LONG dword_77EA6070 = 0; // idb
volatile LONG dword_77EA6074 = 0; // idb
volatile LONG dword_77EA6078 = 0; // idb
volatile LONG dword_77EA607C = 0; // idb
uintptr_t __security_cookie = 3141592654u;
int __security_cookie_complement = 1153374641; // weak
int SingleHandler = 0; // weak
int BaseDllIniFileMapping = 0; // weak
int BaseStaticServerData = 0; // weak
int BaseHeapHandleTablePtr = 0; // weak
PVOID HandlerList = NULL; // idb
__int16 ExeNameBuffer[] = { 0 }; // weak
int BasepAppCertDllsList = 0; // weak
struct _RTL_CRITICAL_SECTION DllLock = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int BasePrefixList = 0; // weak
int dword_77EA62DC = 0; // weak
_UNKNOWN FSPErrorMessages::CMessageMapper::ms_instance; // weak
__int16 StartDirBuffer[] = { 0 }; // weak
int BasePrefixLastHint = 0; // weak
char BaseUsePrivateNamespaces = '\0'; // weak
char BasepAllowResourceConversion = '\x01'; // weak
char gbConsoleApp = '\0'; // weak
int dword_77EA6544 = 1073741824; // weak
int dword_77EA6548 = 1; // weak
int dword_77EA654C = 3221225506; // weak
int dword_77EA6550 = 4294967295; // weak
int dword_77EA6554 = 4294967295; // weak
PVOID gpwzComputerNameCache = NULL; // idb
int gcComputerNameCacheSize = 0; // weak
int dword_77EA6564 = 0; // weak
int dword_77EA6568 = 0; // weak
int dword_77EA656C = 0; // weak
ULONG Seed = 0u; // idb
volatile LONG dword_77EA6574 = 0; // idb
int dword_77EA6578 = 0; // weak
int BasepCurrentTopLevelFilter = 0; // weak
HANDLE ConsolePortHeap = NULL; // idb
int ConsolePortMemoryRemoteDelta = 0; // weak
PVOID dword_77EA6590 = NULL; // idb
PVOID dword_77EA6594 = NULL; // idb
PVOID dword_77EA6598 = NULL; // idb
PVOID ProcedureAddress = NULL; // idb
struct _RTL_CRITICAL_SECTION gComputerNameCacheUpdateCR = { NULL, 0, 0, NULL, NULL, 0u }; // idb
struct _RTL_CRITICAL_SECTION PredefinedHandleTableCriticalSection = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int gClassesEnumTable[18] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int SortTblPtrs[30] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int g_RegKrnGlobalState[36] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
volatile LONG dword_77EA672C = 0; // idb
HANDLE Handle = NULL; // idb
int dword_77EA6738 = 0; // weak
ULONG LockFileKey = 1u; // idb
volatile LONG dword_77EA676C = 4294967295; // idb
int gsrwlAppCert = 0; // weak
volatile LONG Destination = 0; // idb
volatile LONG dword_77EA6778 = 0; // idb
union _RTL_RUN_ONCE gClassesEnumTableInit = { NULL }; // idb
volatile LONG g_Initialized = 0; // idb
union _RTL_RUN_ONCE PredefinedHandleTableCriticalSectionInit = { NULL }; // idb
union _RTL_RUN_ONCE g_ProcessAppKeyEventInit = { NULL }; // idb
int BasepUEFLock = 0; // weak
BOOL g_Win64Registry = 0; // idb
int BasePrivatenamespaceLock = 0; // weak
volatile LONG BaseNamedObjectDirectory = 0; // idb
volatile LONG BasepFilterInfo = 0; // idb
HANDLE ConsoleLpcHandle = NULL; // idb
struct _SID_IDENTIFIER_AUTHORITY BasepNtIdentifierAuthority = { { 0u, 0u, 0u, 0u, 0u, 5u } }; // idb
LSA_UNICODE_STRING gustrSystemdriveTemp = { 0u, 0u, NULL }; // idb
LSA_UNICODE_STRING gustrWindowsTemp = { 0u, 0u, NULL }; // idb
struct _IO_STATUS_BLOCK LocalIoStatusBlock = { { 0 }, 0u }; // idb
int pfnTermsrvGetWindowsDirectoryA = 0; // weak
int pfnTermsrvGetWindowsDirectoryW = 0; // weak
int pfnTermsrvConvertSysRootToUserDir = 0; // weak
int (__stdcall *gpTermsrvLogInstallIniFile)(_DWORD) = NULL; // weak
int (__stdcall *gpTermsrvCORIniFile)(_DWORD) = NULL; // weak
int (__stdcall *gpTermsrvBuildIniFileName)(_DWORD, _DWORD) = NULL; // weak
int (__stdcall *gpTermsrvAdjustPhyMemLimits)(_DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *gpTermsrvGetComputerName)(_DWORD, _DWORD) = NULL; // weak
int dword_77EA6800 = 0; // weak
int dword_77EA6804 = 0; // weak
int dword_77EA680C = 0; // weak
int dword_77EA6850 = 0; // weak
__int16 word_77EA68DC = 0; // weak
__int16 word_77EA68E0 = 0; // weak
__int16 word_77EA68E4 = 0; // weak
__int16 word_77EA68E8 = 0; // weak
int dword_77EA68EC = 0; // weak
int dword_77EA68F0 = 0; // weak
int dword_77EA68F4 = 0; // weak
int dword_77EA68F8 = 0; // weak
int dword_77EA68FC = 0; // weak
int dword_77EA6900 = 0; // weak
int dword_77EA6904 = 0; // weak
int dword_77EA6908 = 0; // weak
__int16 word_77EA690C = 0; // weak
int dword_77EA6910 = 0; // weak
int dword_77EA6914 = 0; // weak
__int16 word_77EA6918 = 0; // weak
int PredefinedHandleTable[] = { 0 }; // weak
int dword_77EA6B24[] = { 0 }; // weak
int (__stdcall *off_77EA6B28)(int, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle) = &LocalOpenClassesRoot; // weak
char byte_77EA6B2C[] = { '\0' }; // weak
OBJECT_ATTRIBUTES stru_77EA6BC0 = { 24u, NULL, &dword_77EA67F8, 64u, NULL, NULL }; // idb
int dword_77EA6BD8 = 0; // weak
int dword_77EA6BDC = 0; // weak
int dword_77EA6BE0 = 0; // weak
int dword_77EA6BE4 = 1; // weak
int (__cdecl *pfnWowGlobalFreeHook)(_DWORD) = NULL; // weak
char BasepBlockedServiceSids[] = { '\x06' }; // weak
int dword_77EA6BF4[] = { 80 }; // weak
int dword_77EA6BF8[] = { 123231216 }; // weak
int dword_77EA6BFC[] = { 2592883651 }; // weak
int dword_77EA6C00[] = { 3715271367 }; // weak
int dword_77EA6C04[] = { 3753151631 }; // weak
int dword_77EA6C08[] = { 4175906628 }; // weak
int dword_77EA6C0C[] = { 0 }; // weak
int dword_77EA6C10[] = { 0 }; // weak
volatile LONG dword_77EA6C80 = 4294967295; // idb
int (__stdcall *dword_77EA6C84)(_DWORD) = NULL; // weak
int dword_77EA6C88 = 0; // weak
HANDLE g_ProcessAppKeyEvent = NULL; // idb
char BasepAlreadyHadHardError = '\0'; // weak
int dword_77EA6C94[] = { 3 }; // weak
wchar_t *off_77EA6C9C = L"PATH"; // weak
LSA_UNICODE_STRING stru_77EA6CD0 = { 20u, 22u, L"ShimEnable" }; // idb
LPCCH pchPad = "PADDINGXXPADDING"; // idb
LPCCH pchZero = &dword_77E61C18; // idb
wchar_t *off_77EA6CF0 = L"Classes\\"; // idb
wchar_t *off_77EA6CF4 = L"Software\\Classes\\"; // idb
wchar_t *off_77EA6CF8 = L"\\Registry\\Machine\\Software"; // idb
int dword_77EA6D00 = 0; // weak
int dword_77EA6D04 = 0; // weak
int BaseLZTableLock[2] = { 0, 0 }; // weak
wchar_t Dst = 0u; // idb
int dword_77EA6F1C = 0; // weak
int rghLZFileTable[] = { 0 }; // weak
int fhWin32File[] = { 0 }; // weak
int dword_77EA6FA0 = 0; // weak
wchar_t Str1 = 0u; // idb
HMODULE hModule = NULL; // idb
volatile LONG FSPErrorMessages::g_pwszWMREscalatedMessageBuffer = 0; // idb
int (__stdcall *gpTermsrvUpdateAllUserMenu)(_DWORD) = NULL; // weak
int LastConsoleEventActive = 0; // weak


//----- (77DE1E10) --------------------------------------------------------
void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
{
  LONG v1; // esi@1
  PRTL_USER_PROCESS_PARAMETERS v2; // edi@1
  int v3; // eax@2
  bool v4; // zf@7
  STRING v5; // [sp+Ch] [bp-1Ch]@5
  STRING DestinationString; // [sp+14h] [bp-14h]@3
  STRING AnsiString; // [sp+1Ch] [bp-Ch]@4
  NTSTATUS Status; // [sp+24h] [bp-4h]@3

  v1 = BaseAnsiStartupInfo;
  v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  if ( BaseAnsiStartupInfo )
    goto LABEL_7;
  v3 = KernelBaseGetGlobalData();
  v1 = (LONG)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 0x44u);
  if ( v1 )
  {
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_DWORD *)(v1 + 12) = 0;
    *(_DWORD *)v1 = 68;
    *(_DWORD *)(v1 + 16) = *(_DWORD *)&v2[1].Reserved1[4];
    *(_DWORD *)(v1 + 20) = *(_DWORD *)&v2[1].Reserved1[8];
    *(_DWORD *)(v1 + 24) = *(_DWORD *)&v2[1].Reserved1[12];
    *(_DWORD *)(v1 + 28) = v2[1].Reserved2[0];
    *(_DWORD *)(v1 + 32) = v2[1].Reserved2[1];
    *(_DWORD *)(v1 + 36) = v2[1].Reserved2[2];
    *(_DWORD *)(v1 + 40) = v2[1].Reserved2[3];
    *(_DWORD *)(v1 + 44) = v2[1].Reserved2[4];
    *(_WORD *)(v1 + 48) = LOWORD(v2[1].Reserved2[5]);
    *(_WORD *)(v1 + 50) = v2[1].CommandLine.Length;
    *(_DWORD *)(v1 + 52) = v2[1].CommandLine.Buffer;
    *(_DWORD *)(v1 + 56) = v2->Reserved2[2];
    *(_DWORD *)(v1 + 60) = v2->Reserved2[3];
    *(_DWORD *)(v1 + 64) = v2->Reserved2[4];
    Status = RtlUnicodeStringToAnsiString(&DestinationString, &v2[1].ImagePathName, 1u);
    if ( Status >= 0 )
    {
      *(_DWORD *)(v1 + 4) = DestinationString.Buffer;
      Status = RtlUnicodeStringToAnsiString(&AnsiString, (PCUNICODE_STRING)&v2[1].Reserved2[8], 1u);
      if ( Status >= 0 )
      {
        *(_DWORD *)(v1 + 8) = AnsiString.Buffer;
        Status = RtlUnicodeStringToAnsiString(&v5, (PCUNICODE_STRING)&v2[1].Reserved2[6], 1u);
        if ( Status >= 0 )
        {
          *(_DWORD *)(v1 + 12) = v5.Buffer;
          if ( !InterlockedCompareExchange(&BaseAnsiStartupInfo, v1, 0) )
            goto LABEL_7;
          goto LABEL_15;
        }
        RtlFreeAnsiString(&AnsiString);
      }
      RtlFreeAnsiString(&DestinationString);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v1);
  }
  else
  {
    Status = -1073741801;
  }
  RtlRaiseStatus(Status);
LABEL_15:
  RtlFreeAnsiString(&v5);
  RtlFreeAnsiString(&AnsiString);
  RtlFreeAnsiString(&DestinationString);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v1);
  v1 = BaseAnsiStartupInfo;
LABEL_7:
  lpStartupInfo->cb = *(_DWORD *)v1;
  lpStartupInfo->lpReserved = *(LPSTR *)(v1 + 4);
  lpStartupInfo->lpDesktop = *(LPSTR *)(v1 + 8);
  lpStartupInfo->lpTitle = *(LPSTR *)(v1 + 12);
  lpStartupInfo->dwX = *(_DWORD *)(v1 + 16);
  lpStartupInfo->dwY = *(_DWORD *)(v1 + 20);
  lpStartupInfo->dwXSize = *(_DWORD *)(v1 + 24);
  lpStartupInfo->dwYSize = *(_DWORD *)(v1 + 28);
  lpStartupInfo->dwXCountChars = *(_DWORD *)(v1 + 32);
  lpStartupInfo->dwYCountChars = *(_DWORD *)(v1 + 36);
  lpStartupInfo->dwFillAttribute = *(_DWORD *)(v1 + 40);
  lpStartupInfo->dwFlags = *(_DWORD *)(v1 + 44);
  v4 = (lpStartupInfo->dwFlags & 0x700) == 0;
  lpStartupInfo->wShowWindow = *(_WORD *)(v1 + 48);
  lpStartupInfo->cbReserved2 = *(_WORD *)(v1 + 50);
  lpStartupInfo->lpReserved2 = *(LPBYTE *)(v1 + 52);
  if ( v4 )
  {
    lpStartupInfo->hStdInput = (HANDLE)-1;
    lpStartupInfo->hStdOutput = (HANDLE)-1;
    lpStartupInfo->hStdError = (HANDLE)-1;
  }
  else
  {
    lpStartupInfo->hStdInput = *(HANDLE *)(v1 + 56);
    lpStartupInfo->hStdOutput = *(HANDLE *)(v1 + 60);
    lpStartupInfo->hStdError = *(HANDLE *)(v1 + 64);
  }
}

//----- (77DE204D) --------------------------------------------------------
BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
  return CreateProcessInternalW(
           0,
           lpApplicationName,
           lpCommandLine,
           (int)lpProcessAttributes,
           (int)lpThreadAttributes,
           bInheritHandles,
           dwCreationFlags,
           (int)lpEnvironment,
           lpCurrentDirectory,
           (int)lpStartupInfo,
           (int)lpProcessInformation,
           0);
}

//----- (77DE2082) --------------------------------------------------------
BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
  return CreateProcessInternalA(
           0,
           (ULONG)lpApplicationName,
           (ULONG)lpCommandLine,
           (int)lpProcessAttributes,
           (int)lpThreadAttributes,
           bInheritHandles,
           dwCreationFlags,
           (int)lpEnvironment,
           (ULONG)lpCurrentDirectory,
           (int)lpStartupInfo,
           (int)lpProcessInformation,
           0);
}

//----- (77DE2251) --------------------------------------------------------
LSTATUS __stdcall RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
{
  int v3; // eax@2
  LSTATUS v4; // ebx@2
  NTSTATUS v5; // eax@3
  ULONG v6; // eax@10
  int v7; // esi@12
  int v8; // edi@12
  int v9; // eax@12
  UNICODE_STRING DestinationString; // [sp+10h] [bp-40h]@3
  UNICODE_STRING v12; // [sp+18h] [bp-38h]@6
  LSTATUS v13; // [sp+20h] [bp-30h]@16
  PVOID Address; // [sp+28h] [bp-28h]@2
  int v15; // [sp+2Ch] [bp-24h]@1
  int v16; // [sp+30h] [bp-20h]@1
  int (__stdcall *v17)(unsigned int, UNICODE_STRING *, UNICODE_STRING *); // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@16

  v15 = 0;
  v16 = 0;
  v17 = *(int (__stdcall **)(unsigned int, UNICODE_STRING *, UNICODE_STRING *))(RegKrnGetGlobalState() + 112);
  if ( hKey != HKEY_PERFORMANCE_DATA )
  {
    v3 = RegKrnGetGlobalState();
    v4 = (*(int (__stdcall **)(HKEY, PVOID *, int *, int *))(v3 + 176))(hKey, &Address, &v15, &v16);
    if ( !v4 )
    {
      v5 = RtlInitUnicodeStringEx(&DestinationString, lpSubKey);
      if ( v5 < 0 )
        goto LABEL_20;
      if ( DestinationString.Length > 0u )
        DestinationString.Length += 2;
      v5 = RtlInitUnicodeStringEx(&v12, lpFile);
      if ( v5 < 0 )
      {
LABEL_20:
        v6 = RtlNtStatusToDosError(v5);
      }
      else
      {
        if ( v12.Length > 0u )
          v12.Length += 2;
        if ( (unsigned __int8)Address & 1 )
        {
          if ( v17 )
          {
            ms_exc.registration.TryLevel = 0;
            v4 = v17((unsigned int)Address & 0xFFFFFFFE, &DestinationString, &v12);
            v13 = v4;
            ms_exc.registration.TryLevel = -2;
          }
          goto LABEL_12;
        }
        v6 = LocalBaseRegLoadKey(Address, (int)&DestinationString, (int)&v12);
      }
      v4 = v6;
    }
LABEL_12:
    v7 = v16;
    v8 = v15;
    v9 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v9 + 168))(v8, v7);
    return v4;
  }
  return 6;
}

//----- (77DE2341) --------------------------------------------------------
ULONG __stdcall LocalBaseRegLoadKey(PVOID Address, int a2, int a3)
{
  int v3; // edx@3
  unsigned __int16 v4; // cx@4
  int v5; // edx@7
  unsigned __int16 v6; // cx@8
  int v7; // edi@10
  int v8; // ST00_4@16
  NTSTATUS v9; // edi@19
  OBJECT_ATTRIBUTES KeyObjectAttributes; // [sp+Ch] [bp-48h]@16
  OBJECT_ATTRIBUTES FileObjectAttributes; // [sp+24h] [bp-30h]@19
  int v13; // [sp+3Ch] [bp-18h]@16
  void *v14; // [sp+40h] [bp-14h]@23
  void *v15; // [sp+44h] [bp-10h]@18
  int v16; // [sp+4Ch] [bp-8h]@16
  void *v17; // [sp+50h] [bp-4h]@17
  PVOID Addressa; // [sp+5Ch] [bp+8h]@17

  if ( !Address )
    return 87;
  if ( !a3 )
    return 87;
  v3 = *(_DWORD *)(a3 + 4);
  if ( !v3 )
    return 87;
  v4 = *(_WORD *)a3;
  if ( !*(_WORD *)a3 || v4 & 1 || *(_WORD *)(v3 + 2 * ((unsigned int)v4 >> 1) - 2) )
    return 87;
  v5 = a2;
  if ( !a2 )
    goto LABEL_21;
  v6 = *(_WORD *)a2;
  if ( !*(_WORD *)a2 )
    return 87;
  if ( v6 & 1 )
    return 87;
  v7 = *(_DWORD *)(a2 + 4);
  if ( v7 )
  {
    if ( *(_WORD *)(v7 + 2 * ((unsigned int)v6 >> 1) - 2) )
      return 87;
  }
  if ( v6 > 0u )
  {
    *(_WORD *)a2 = v6 - 2;
    goto LABEL_14;
  }
LABEL_21:
  v5 = 0;
LABEL_14:
  if ( *(_WORD *)a3 > 0u )
    *(_WORD *)a3 -= 2;
  KeyObjectAttributes.RootDirectory = Address;
  v8 = *(_DWORD *)(a3 + 4);
  KeyObjectAttributes.Length = 24;
  KeyObjectAttributes.Attributes = 64;
  KeyObjectAttributes.ObjectName = (PUNICODE_STRING)v5;
  KeyObjectAttributes.SecurityDescriptor = 0;
  KeyObjectAttributes.SecurityQualityOfService = 0;
  if ( !(unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(v8, &v16, 0, &v13) )
    return 87;
  Addressa = v17;
  if ( (_WORD)v13 )
  {
    v16 = v13;
    v17 = v14;
  }
  else
  {
    v15 = 0;
  }
  FileObjectAttributes.RootDirectory = v15;
  FileObjectAttributes.ObjectName = (PUNICODE_STRING)&v16;
  FileObjectAttributes.Length = 24;
  FileObjectAttributes.Attributes = 64;
  FileObjectAttributes.SecurityDescriptor = 0;
  FileObjectAttributes.SecurityQualityOfService = 0;
  v9 = NtLoadKey(&KeyObjectAttributes, &FileObjectAttributes);
  RtlReleaseRelativeName(&v13);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Addressa);
  return RtlNtStatusToDosError(v9);
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);

//----- (77DE2493) --------------------------------------------------------
BOOL __stdcall InitAtomTable(DWORD nSize)
{
  LONG v1; // ecx@0
  DWORD v2; // eax@2
  LONG Exchange; // [sp+0h] [bp-4h]@1

  Exchange = v1;
  if ( BaseLocalAtomTable )
    return 1;
  v2 = nSize;
  if ( nSize < 4 || nSize > 0x1FF )
    v2 = 37;
  Exchange = 0;
  if ( RtlCreateAtomTable(v2, &Exchange) >= 0 )
  {
    if ( InterlockedCompareExchange(&BaseLocalAtomTable, Exchange, 0) )
      RtlDestroyAtomTable(Exchange);
    return 1;
  }
  return 0;
}
// 77DE14E0: using guessed type int __stdcall RtlCreateAtomTable(_DWORD, _DWORD);
// 77DE14E4: using guessed type int __stdcall RtlDestroyAtomTable(_DWORD);

//----- (77DE24F0) --------------------------------------------------------
HANDLE __stdcall CreateEventExWStub(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateEventExW(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
}

//----- (77E00074) --------------------------------------------------------
signed int __stdcall sub_77E00074(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147467259;
}

//----- (77E00099) --------------------------------------------------------
signed int __cdecl DtcGetTransactionManagerExW(unsigned __int16 *a1, unsigned __int16 *a2, const struct _GUID *a3, unsigned __int32 a4, void *a5, void **a6)
{
  if ( a6 )
    *a6 = 0;
  return -2147024770;
}

//----- (77E000D9) --------------------------------------------------------
signed int __stdcall sub_77E000D9(int a1, int a2, int a3, int a4)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147467259;
}

//----- (77E00155) --------------------------------------------------------
signed int __stdcall sub_77E00155(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a8 = 0;
  return -2147467259;
}

//----- (77E00194) --------------------------------------------------------
int __stdcall LookupHandlerByName(const char *a1, const struct _DLOAD_PROCNAME_MAP *a2)
{
  int v2; // ebx@1
  int v3; // ecx@1
  const char *v4; // edi@3
  int v5; // eax@3
  int v6; // esi@3
  bool v7; // cf@4
  const char v8; // dl@6
  int v9; // edx@8
  int v11; // [sp+4h] [bp-4h]@1
  const struct _DLOAD_PROCNAME_MAP *v12; // [sp+14h] [bp+Ch]@2

  v2 = 0;
  v3 = *(_DWORD *)a2 - 1;
  v11 = 0;
  if ( v3 >= 0 )
  {
    v12 = (const struct _DLOAD_PROCNAME_MAP *)*((_DWORD *)a2 + 1);
    do
    {
      v4 = a1;
      v5 = (v3 + v2) / 2;
      v6 = *((_DWORD *)v12 + 2 * v5);
      while ( 1 )
      {
        v7 = (const unsigned __int8)*v4 < *(_BYTE *)v6;
        if ( *v4 != *(_BYTE *)v6 )
          break;
        if ( !*v4 )
          goto LABEL_8;
        v8 = v4[1];
        v7 = (unsigned __int8)v8 < *(_BYTE *)(v6 + 1);
        if ( v8 != *(_BYTE *)(v6 + 1) )
          break;
        v4 += 2;
        v6 += 2;
        if ( !v8 )
        {
LABEL_8:
          v9 = 0;
          goto LABEL_9;
        }
      }
      v9 = -v7 - (v7 - 1);
LABEL_9:
      if ( v9 < 0 )
      {
        v3 = v5 - 1;
      }
      else
      {
        if ( v9 <= 0 )
          return *((_DWORD *)v12 + 2 * v5 + 1);
        v2 = v5 + 1;
      }
    }
    while ( v3 >= v2 );
  }
  return v11;
}

//----- (77E00213) --------------------------------------------------------
char **__stdcall FindDll(const char *Source)
{
  int v1; // edi@3
  int v2; // eax@4
  char *v3; // esi@4
  char *v4; // ecx@4
  bool v5; // cf@5
  unsigned __int8 v6; // dl@7
  int v7; // ecx@9
  int v9; // [sp+Ch] [bp-114h]@1
  int v10; // [sp+10h] [bp-110h]@3
  char Dest; // [sp+14h] [bp-10Ch]@1
  char Dst; // [sp+15h] [bp-10Bh]@1

  v9 = 0;
  Dest = 0;
  memset(&Dst, 0, 0x104u);
  if ( !Source || strlen(Source) > 0x104 )
    return 0;
  strncat(&Dest, Source, 0x104u);
  _strlwr(&Dest);
  v1 = g_DllMap - 1;
  v10 = 0;
  if ( g_DllMap - 1 < 0 )
    return (char **)v9;
  while ( 1 )
  {
    v2 = (v1 + v10) / 2;
    v3 = (&off_77E081D0)[12 * v2];
    v4 = &Dest;
    while ( 1 )
    {
      v5 = (unsigned __int8)*v4 < (unsigned __int8)*v3;
      if ( *v4 != *v3 )
        break;
      if ( !*v4 )
        goto LABEL_9;
      v6 = v4[1];
      v5 = v6 < (unsigned __int8)v3[1];
      if ( v6 != v3[1] )
        break;
      v4 += 2;
      v3 += 2;
      if ( !v6 )
      {
LABEL_9:
        v7 = 0;
        goto LABEL_10;
      }
    }
    v7 = -v5 - (v5 - 1);
LABEL_10:
    if ( v7 < 0 )
    {
      v1 = v2 - 1;
      goto LABEL_13;
    }
    if ( v7 <= 0 )
      return &(&off_77E081D0)[12 * v2];
    v10 = v2 + 1;
LABEL_13:
    if ( v1 < v10 )
      return (char **)v9;
  }
}
// 77E00308: using guessed type int g_DllMap;
// 77E081D0: using guessed type char *off_77E081D0;

//----- (77E0031C) --------------------------------------------------------
int __stdcall DelayLoadFailureHook(char *a1, char *a2)
{
  return LookupHandler(a1, a2);
}

//----- (77E00329) --------------------------------------------------------
int __stdcall LookupHandler(char *Source, char *a2)
{
  int v2; // esi@1
  char **v3; // eax@1
  int v4; // eax@4
  const struct _DLOAD_ORDINAL_MAP *v6; // eax@7

  v2 = 0;
  v3 = FindDll(Source);
  if ( v3 )
  {
    if ( (unsigned int)a2 & 0xFFFF0000 && v3[1] )
    {
      v4 = LookupHandlerByName(a2, (const struct _DLOAD_PROCNAME_MAP *)v3[1]);
    }
    else
    {
      v6 = (const struct _DLOAD_ORDINAL_MAP *)v3[2];
      if ( !v6 )
        return v2;
      v4 = LookupHandlerByOrdinal((unsigned __int32)a2, v6);
    }
    v2 = v4;
  }
  return v2;
}

//----- (77E01146) --------------------------------------------------------
signed int __stdcall FveCloseVolume(int a1)
{
  return -2147024769;
}

//----- (77E01C62) --------------------------------------------------------
signed int __stdcall KccGetFailureCache(unsigned __int32 a1, struct _DS_REPL_KCC_DSA_FAILURESW **a2)
{
  return 127;
}

//----- (77E02812) --------------------------------------------------------
signed int __stdcall RasSetDeviceConfigInfo(int a1, int a2, int a3, int a4)
{
  return 127;
}

//----- (77E02CE5) --------------------------------------------------------
const unsigned __int16 *__stdcall MapSpnServiceClass(unsigned __int16 *a1)
{
  return 0;
}

//----- (77E04A47) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_WriteLONG(IPropertyBag *propBag, LPCWSTR propName, LONG value)
{
  return -2147024769;
}

//----- (77E04F8A) --------------------------------------------------------
signed int __stdcall GetServerEapAuthRequestPacket(int a1, int a2, int a3)
{
  return 127;
}

//----- (77E05B30) --------------------------------------------------------
signed int __stdcall FmsDeactivateFonts(int a1, int a2, int a3, int a4)
{
  return -2147024769;
}

//----- (77E05FE4) --------------------------------------------------------
signed int __stdcall RegWdQueryW(int a1, int a2, int a3, int a4, int a5)
{
  return 127;
}

//----- (77E06D1D) --------------------------------------------------------
signed int __stdcall Urlmon_CleanIETldListCache()
{
  return -2147467259;
}

//----- (77E0801C) --------------------------------------------------------
signed int __stdcall SHGetUserPicturePathEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return -2147024769;
}

//----- (77E0A94D) --------------------------------------------------------
int __stdcall sub_77E0A94D(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  return 0;
}

//----- (77E10DCD) --------------------------------------------------------
signed int __stdcall UrlmonCreateInstance(const struct _GUID *a1, struct IUnknown *a2, const struct _GUID *a3, void **a4)
{
  return -2147221231;
}

//----- (77E11A45) --------------------------------------------------------
BOOL __stdcall EnumSystemLanguageGroupsWStub(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
{
  return EnumSystemLanguageGroupsW(lpLanguageGroupEnumProc, dwFlags, lParam);
}

//----- (77E11A5D) --------------------------------------------------------
int __stdcall ReOpenFile(int a1, int a2, ULONG ShareAccess, HANDLE FileHandle)
{
  unsigned int v4; // esi@2
  unsigned int v5; // edi@3
  int v6; // edi@4
  int v7; // esi@4
  NTSTATUS v8; // eax@6
  int result; // eax@7
  unsigned int v10; // esi@12
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-34h]@4
  int v12; // [sp+18h] [bp-1Ch]@6
  unsigned int v13; // [sp+1Ch] [bp-18h]@5
  char v14; // [sp+20h] [bp-14h]@5
  char v15; // [sp+21h] [bp-13h]@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+24h] [bp-10h]@6
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-8h]@4

  if ( (a1 & 0x10000003) == 3 )
  {
    BaseSetLastNTError(-1073741816);
    result = -1;
  }
  else
  {
    v4 = (unsigned int)FileHandle;
    if ( (unsigned __int16)FileHandle & 0x7FB7 )
    {
      BaseSetLastNTError(-1073741811);
    }
    else
    {
      v5 = (unsigned int)FileHandle & 0x200000 | 4 * ((unsigned int)FileHandle & 0x100000) | ~((unsigned int)FileHandle >> 25) & 0x20 | (((unsigned int)FileHandle & 0x2000000 | (((unsigned int)FileHandle & 0x10000000 | (((unsigned int)FileHandle & 0x8000000 | (((unsigned int)FileHandle & 0x20000000 | ((unsigned int)FileHandle >> 4) & 0x8000000) >> 1)) >> 8)) >> 6)) >> 11);
      if ( (unsigned int)FileHandle & 0x4000000 )
      {
        v5 |= 0x1000u;
        a2 |= 0x10000u;
      }
      v6 = v5 | 0x40;
      RtlInitUnicodeString(&DestinationString, &Src);
      ObjectAttributes.RootDirectory = (HANDLE)a1;
      ObjectAttributes.Attributes = ~(unsigned __int8)(v4 >> 18) & 0x40;
      ObjectAttributes.ObjectName = &DestinationString;
      v7 = v4 & 0x1F0000;
      ObjectAttributes.Length = 24;
      ObjectAttributes.SecurityDescriptor = 0;
      if ( v7 & 0x100000 )
      {
        v10 = v7 & 0xFFEFFFFF;
        if ( v10 & 0x40000 )
        {
          v14 = 1;
          v10 &= 0xFFFBFFFF;
        }
        else
        {
          v14 = 0;
        }
        if ( v10 & 0x80000 )
        {
          v15 = 1;
          v10 &= 0xFFF7FFFF;
        }
        else
        {
          v15 = 0;
        }
        v13 = v10 >> 16;
      }
      else
      {
        v14 = 1;
        v13 = 2;
        v15 = 1;
      }
      v12 = 12;
      ObjectAttributes.SecurityQualityOfService = &v12;
      v8 = NtCreateFile(&FileHandle, a2 | 0x100080, &ObjectAttributes, &IoStatusBlock, 0, 0, ShareAccess, 1u, v6, 0, 0);
      if ( v8 >= 0 )
      {
        RtlSetLastWin32Error(0);
        return (int)FileHandle;
      }
      BaseSetLastNTError(v8);
    }
    result = -1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E11B95) --------------------------------------------------------
BOOL __stdcall WriteFileGatherStub(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
{
  return WriteFileGather(hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
}

//----- (77E11BAD) --------------------------------------------------------
BOOL __stdcall ReadFileScatterStub(HANDLE hFile, FILE_SEGMENT_ELEMENT *aSegmentArray, DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
{
  return ReadFileScatter(hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
}

//----- (77E11BC5) --------------------------------------------------------
BOOL __stdcall SetFileValidDataStub(HANDLE hFile, LONGLONG ValidDataLength)
{
  return SetFileValidData(hFile, ValidDataLength);
}

//----- (77E11CF4) --------------------------------------------------------
HANDLE __stdcall SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
{
  BOOL v6; // eax@1

  v6 = CreateTimerQueueTimer((PHANDLE)&PreferIo, TimerQueue, Callback, Parameter, DueTime, Period, PreferIo != 0);
  return (HANDLE)(v6 != 0 ? PreferIo : 0);
}

//----- (77E11D2A) --------------------------------------------------------
signed int __stdcall BaseInitAppcompatCacheSupport()
{
  BasepShimCacheInitTempDirs();
  return 1;
}

//----- (77E11D38) --------------------------------------------------------
signed int __stdcall BasepShimCacheInitTempDirs()
{
  UINT v0; // eax@1
  const wchar_t *v1; // edx@3
  unsigned int v2; // eax@6
  const wchar_t *v3; // ecx@6
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-228h]@5
  LSA_UNICODE_STRING Value; // [sp+14h] [bp-220h]@5
  WCHAR Buffer[260]; // [sp+1Ch] [bp-218h]@1
  int pszSrc; // [sp+224h] [bp-10h]@1
  int v9; // [sp+228h] [bp-Ch]@1
  int v10; // [sp+22Ch] [bp-8h]@1

  pszSrc = *(_DWORD *)L"\\TEMP";
  v9 = *(_DWORD *)L"\u5400\u4500\u4d00\u5000";
  v10 = *(_DWORD *)L"TEMP";
  v0 = GetWindowsDirectoryW(Buffer, 0x104u);
  if ( v0 && v0 < 0x104 )
  {
    v1 = (const wchar_t *)&pszSrc;
    if ( Buffer[v0 - 1] == 92 )
      v1 = (const wchar_t *)((char *)&pszSrc + 2);
    StringCchCopyW(&Buffer[v0], 260 - v0, v1);
    RtlDosPathNameToNtPathName_U(Buffer, &gustrWindowsTemp, 0, 0);
  }
  RtlInitUnicodeString(&DestinationString, L"SystemDrive");
  Value.Length = 0;
  Value.Buffer = Buffer;
  Value.MaximumLength = 520;
  if ( RtlQueryEnvironmentVariable_U(0, &DestinationString, &Value) >= 0 )
  {
    v2 = (unsigned int)Value.Length >> 1;
    v3 = (const wchar_t *)&pszSrc;
    if ( v2 && *((_WORD *)&Value.Buffer + v2 + 1) == 92 )
      v3 = (const wchar_t *)((char *)&pszSrc + 2);
    StringCchCopyW(&Buffer[v2], 260 - v2, v3);
    RtlDosPathNameToNtPathName_U(Buffer, &gustrSystemdriveTemp, 0, 0);
  }
  return 1;
}
// 77E11E64: using guessed type wchar_t aTemp_0[6];
// 77E11D38: using guessed type WCHAR Buffer[260];

//----- (77E11E94) --------------------------------------------------------
BOOL __stdcall SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
{
  BOOL result; // eax@2
  ULONG v3; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v6; // [sp+28h] [bp-7Ch]@1
  COORD v7; // [sp+2Ch] [bp-78h]@1

  v6 = hConsoleOutput;
  v7 = dwCursorPosition;
  ConsoleClientCallServer(&RequestMessage, 0, 22, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E11EEA) --------------------------------------------------------
BOOL __stdcall ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
{
  return ScrollConsoleScreenBufferInternal(
           (int)hConsoleOutput,
           (int)lpScrollRectangle,
           (int)lpClipRectangle,
           *(_DWORD *)&dwDestinationOrigin,
           (int)lpFill,
           1);
}

//----- (77E11F0E) --------------------------------------------------------
signed int __stdcall ScrollConsoleScreenBufferInternal(int a1, int a2, int a3, int a4, int a5, char a6)
{
  int v6; // ecx@1
  signed int result; // eax@4
  int v8; // ecx@6
  int v9; // eax@6
  ULONG v10; // eax@7
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@3
  int v13; // [sp+28h] [bp-7Ch]@1
  int v14; // [sp+2Ch] [bp-78h]@1
  int v15; // [sp+30h] [bp-74h]@1
  int v16; // [sp+34h] [bp-70h]@6
  int v17; // [sp+38h] [bp-6Ch]@6
  int v18; // [sp+3Ch] [bp-68h]@2
  int v19; // [sp+40h] [bp-64h]@3
  int v20; // [sp+44h] [bp-60h]@3
  char v21; // [sp+48h] [bp-5Ch]@1

  v13 = a1;
  v21 = a6;
  v6 = *(_DWORD *)a2;
  v15 = *(_DWORD *)(a2 + 4);
  v14 = v6;
  if ( a3 )
  {
    v8 = *(_DWORD *)a3;
    v9 = *(_DWORD *)(a3 + 4);
    v18 = 1;
    v16 = v8;
    v17 = v9;
  }
  else
  {
    v18 = 0;
  }
  v20 = *(_DWORD *)a5;
  v19 = a4;
  ConsoleClientCallServer(&RequestMessage, 0, 25, 36);
  if ( NtStatus < 0 )
  {
    v10 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v10);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E11FB8) --------------------------------------------------------
BOOL __stdcall HeapLockStub(HANDLE hHeap)
{
  return HeapLock(hHeap);
}

//----- (77E11FD0) --------------------------------------------------------
BOOL __stdcall HeapUnlockStub(HANDLE hHeap)
{
  return HeapUnlock(hHeap);
}

//----- (77E11FE8) --------------------------------------------------------
BOOL __stdcall HeapWalkStub(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
{
  return HeapWalk(hHeap, lpEntry);
}

//----- (77E12069) --------------------------------------------------------
int __stdcall LocalOpenPerformanceText(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = -2147483568;
  return 0;
}

//----- (77E12082) --------------------------------------------------------
BOOL __stdcall SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
{
  int v4; // eax@1
  NTSTATUS v5; // esi@1
  BOOL result; // eax@1
  char v7; // [sp+4h] [bp-8h]@1

  v4 = BaseFormatTimeOut((int)&v7, dwMilliseconds);
  v5 = RtlSleepConditionVariableSRW(ConditionVariable, SRWLock, v4, Flags);
  BaseSetLastNTError(v5);
  result = 0;
  if ( v5 >= 0 )
    LOBYTE(result) = v5 != 258;
  return result;
}
// 77DE1244: using guessed type int __stdcall RtlSleepConditionVariableSRW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E120C7) --------------------------------------------------------
UINT __stdcall GetSystemWindowsDirectoryAStub(LPSTR lpBuffer, UINT uSize)
{
  return GetSystemWindowsDirectoryA(lpBuffer, uSize);
}

//----- (77E120D4) --------------------------------------------------------
UINT __stdcall GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
{
  int v2; // esi@1
  int v3; // eax@1
  int v4; // esi@3
  int v5; // eax@3
  unsigned __int16 v7; // [sp+4h] [bp-Ch]@3
  __int16 v8; // [sp+6h] [bp-Ah]@3
  LPSTR v9; // [sp+8h] [bp-8h]@3
  ULONG MbSize; // [sp+Ch] [bp-4h]@1

  v2 = KernelBaseGetGlobalData() + 52;
  v3 = KernelBaseGetGlobalData();
  if ( RtlUnicodeToMultiByteSize(&MbSize, *(PWCHAR *)(v3 + 56), *(_WORD *)(v2 + 2)) < 0 )
    return 0;
  if ( (unsigned __int16)uSize >= (unsigned __int16)MbSize )
  {
    v8 = uSize;
    v9 = lpBuffer;
    v4 = KernelBaseGetGlobalData() + 52;
    v5 = KernelBaseGetGlobalData();
    if ( (*(int (__stdcall **)(unsigned __int16 *, int, _DWORD))(v5 + 28))(&v7, v4, 0) >= 0 )
      return v7;
    return 0;
  }
  return MbSize;
}

//----- (77E1214D) --------------------------------------------------------
BOOL __stdcall GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, int a4)
{
  BOOL v5; // [sp+10h] [bp-1Ch]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v5 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      v5 = GetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v5 = 0;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E121DE) --------------------------------------------------------
int __stdcall CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, int a8, int a9, int a10)
{
  HANDLE v11; // [sp+10h] [bp-1Ch]@6

  if ( a10 )
  {
    RtlSetLastWin32Error(87);
    return -1;
  }
  if ( a8 == -1 || !a8 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a8);
  if ( a9 )
  {
    a8 = (unsigned __int16)BasepGetMiniVersionForCreate();
    BasepSetMiniVersionForCreate(*(_WORD *)a9);
  }
  v11 = CreateFileW(
          lpFileName,
          dwDesiredAccess,
          dwShareMode,
          lpSecurityAttributes,
          dwCreationDisposition,
          dwFlagsAndAttributes,
          hTemplateFile);
  RtlSetCurrentTransaction(0);
  if ( a9 )
    BasepSetMiniVersionForCreate(a8);
  return (int)v11;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E122A2) --------------------------------------------------------
BOOL __stdcall DeleteFileTransactedW(LPCWSTR lpFileName, int a2)
{
  BOOL v3; // [sp+10h] [bp-1Ch]@4

  if ( a2 != -1 && a2 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v3 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a2);
      v3 = DeleteFileW(lpFileName);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v3 = 0;
  }
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E1232E) --------------------------------------------------------
HANDLE __stdcall CreateWaitableTimerExWStub(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateWaitableTimerExW(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
}

//----- (77E12364) --------------------------------------------------------
__int16 __stdcall GetMaximumProcessorGroupCount()
{
  signed int v0; // eax@1
  __int16 v1; // si@2
  char v3; // [sp+0h] [bp-8h]@1
  PVOID Address; // [sp+4h] [bp-4h]@1

  v0 = GetProcessorGroupInformation((int)&Address, (int)&v3);
  if ( v0 )
  {
    v1 = *((_WORD *)Address + 4);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    LOWORD(v0) = v1;
  }
  return v0;
}

//----- (77E123C9) --------------------------------------------------------
int __stdcall SetThreadGroupAffinity(HANDLE ThreadHandle, PVOID a2, int a3)
{
  NTSTATUS v3; // eax@2
  int v4; // edi@5
  int result; // eax@6
  char ThreadInformation; // [sp+Ch] [bp-10h]@2
  int v7; // [sp+10h] [bp-Ch]@5
  int v8; // [sp+14h] [bp-8h]@5

  if ( a3 && (v3 = NtQueryInformationThread(ThreadHandle, ThreadGroupInformation, &ThreadInformation, 0xCu, 0), v3 < 0)
    || (v3 = NtSetInformationThread(ThreadHandle, ThreadGroupInformation, a2, 0xCu), v3 < 0) )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    if ( a3 )
    {
      *(_DWORD *)a3 = *(_DWORD *)&ThreadInformation;
      v4 = a3 + 4;
      *(_DWORD *)v4 = v7;
      *(_DWORD *)(v4 + 4) = v8;
    }
    result = 1;
  }
  return result;
}

//----- (77E1243B) --------------------------------------------------------
BOOL __stdcall GetLogicalProcessorInformationStub(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
{
  return GetLogicalProcessorInformation(Buffer, ReturnedLength);
}

//----- (77E12465) --------------------------------------------------------
int __stdcall RegDeleteTreeW(HKEY hKey, PCWSTR SourceString)
{
  PPEB v2; // eax@1
  PVOID v3; // eax@1
  PVOID v4; // ebx@1
  char v5; // al@5
  PVOID v6; // esi@6
  signed int v7; // esi@10
  int result; // eax@11
  LSTATUS v9; // eax@13
  const WCHAR *v10; // eax@14
  LSTATUS v11; // eax@15
  PUNICODE_STRING v12; // edi@17
  bool v13; // zf@17
  bool v14; // sf@17
  const WCHAR *v15; // ST1C_4@24
  UNICODE_STRING *v16; // ST18_4@24
  char v17; // al@24
  int v18; // esi@32
  DWORD cchName; // [sp+Ch] [bp-18h]@13
  PVOID Address; // [sp+10h] [bp-14h]@2
  PUNICODE_STRING AllocatedString; // [sp+14h] [bp-10h]@6
  PUNICODE_STRING UnicodeString; // [sp+18h] [bp-Ch]@6
  HKEY phkResult; // [sp+1Ch] [bp-8h]@7
  int v24; // [sp+20h] [bp-4h]@1
  LSTATUS SourceStringa; // [sp+30h] [bp+Ch]@7

  v2 = NtCurrentTeb()->ProcessEnvironmentBlock;
  v24 = 0;
  v3 = RtlAllocateHeap(v2->Reserved4[1], 0, 0x1800u);
  v4 = v3;
  if ( v3 )
  {
    memset(v3, 0, 0x1800u);
    Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x202u);
    if ( Address )
    {
      if ( SourceString
        && *SourceString
        && (RtlCreateUnicodeString((PUNICODE_STRING)((char *)v4 + 4), SourceString), !v5) )
      {
        SourceStringa = 8;
      }
      else
      {
        *(_DWORD *)v4 = hKey;
        AllocatedString = (PUNICODE_STRING)((char *)v4 + 16);
        v6 = v4;
        UnicodeString = (PUNICODE_STRING)((char *)v4 + 4);
        do
        {
          SourceStringa = RegOpenKeyExW(*(HKEY *)v6, *((LPCWSTR *)v6 + 2), 0, 0x2000000u, &phkResult);
          if ( SourceStringa )
            break;
          cchName = 257;
          v9 = RegEnumKeyExW(phkResult, 0, (LPWSTR)Address, &cchName, 0, 0, 0, 0);
          SourceStringa = v9;
          if ( v9 == 259 )
          {
            v10 = (const WCHAR *)*((_DWORD *)v6 + 2);
            if ( v10 )
              v11 = RegDeleteKeyExW(*(HKEY *)v6, v10, 0, 0);
            else
              v11 = DeleteAllKeyValues(hKey);
            SourceStringa = v11;
            RegCloseKey(phkResult);
            if ( SourceStringa )
              break;
            v12 = UnicodeString;
            RtlFreeUnicodeString(UnicodeString);
            v13 = v24 == 0;
            v14 = v24 < 0;
            *(_DWORD *)&v12->Length = 0;
            v12->Buffer = 0;
            if ( !v14 && !v13 )
            {
              RegCloseKey(*(HKEY *)v6);
              *(_DWORD *)v6 = 0;
            }
            --v24;
            UnicodeString = (PUNICODE_STRING)((char *)UnicodeString - 12);
            AllocatedString = (PUNICODE_STRING)((char *)AllocatedString - 12);
            v6 = (char *)v6 - 12;
          }
          else
          {
            if ( v9 )
            {
              RegCloseKey(phkResult);
              break;
            }
            if ( v24 >= 511
              || (v15 = (const WCHAR *)Address,
                  v16 = AllocatedString,
                  *((_WORD *)Address + cchName) = 0,
                  RtlCreateUnicodeString(v16, v15),
                  !v17) )
            {
              RegCloseKey(phkResult);
              SourceStringa = 8;
              break;
            }
            ++v24;
            UnicodeString = (PUNICODE_STRING)((char *)UnicodeString + 12);
            v6 = (char *)v6 + 12;
            AllocatedString = (PUNICODE_STRING)((char *)AllocatedString + 12);
            *(_DWORD *)v6 = phkResult;
          }
        }
        while ( v24 >= 0 );
        if ( v24 > 0 )
        {
          v18 = (int)((char *)v4 + 12 * v24);
          do
          {
            RtlFreeUnicodeString((PUNICODE_STRING)(v18 + 4));
            RegCloseKey(*(HKEY *)v18);
            --v24;
            v18 -= 12;
          }
          while ( v24 > 0 );
        }
        RtlFreeUnicodeString((PUNICODE_STRING)((char *)v4 + 4));
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      v7 = SourceStringa;
    }
    else
    {
      v7 = 8;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    result = v7;
  }
  else
  {
    result = 8;
  }
  return result;
}

//----- (77E12644) --------------------------------------------------------
HANDLE __stdcall CreateSemaphoreExWStub(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateSemaphoreExW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
}

//----- (77E12671) --------------------------------------------------------
signed int __stdcall CalcClientTimeZoneIdAndBias(int a1, int a2)
{
  int v2; // ebx@1
  signed int v3; // esi@1
  __int64 v4; // rax@1
  int v6; // eax@7
  __int64 v7; // rdi@7
  int v8; // ebx@7
  __int64 v9; // rax@7
  int v10; // eax@12
  int v11; // [sp+Ch] [bp-50h]@3
  int v12; // [sp+10h] [bp-4Ch]@3
  int v13; // [sp+14h] [bp-48h]@3
  int v14; // [sp+18h] [bp-44h]@3
  int v15; // [sp+1Ch] [bp-40h]@3
  int v16; // [sp+20h] [bp-3Ch]@3
  int v17; // [sp+24h] [bp-38h]@3
  int v18; // [sp+28h] [bp-34h]@3
  struct _SYSTEMTIME SystemTime; // [sp+2Ch] [bp-30h]@3
  __int64 v20; // [sp+3Ch] [bp-20h]@3
  __int64 v21; // [sp+44h] [bp-18h]@6
  __int64 v22; // [sp+4Ch] [bp-10h]@1
  struct _FILETIME FileTime; // [sp+54h] [bp-8h]@3
  int v24; // [sp+64h] [bp+8h]@7

  v2 = a1;
  v3 = 0;
  v4 = 600000000i64 * *(_DWORD *)a1;
  v22 = 600000000i64 * *(_DWORD *)a1;
  if ( !*(_WORD *)(a1 + 70) || !*(_WORD *)(a1 + 154) )
    goto LABEL_14;
  GetSystemTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, &FileTime);
  v15 = *(_DWORD *)(a1 + 68);
  v16 = *(_DWORD *)(a1 + 72);
  v17 = *(_DWORD *)(a1 + 76);
  v18 = *(_DWORD *)(a1 + 80);
  v11 = *(_DWORD *)(a1 + 152);
  v12 = *(_DWORD *)(a1 + 156);
  v13 = *(_DWORD *)(a1 + 160);
  v14 = *(_DWORD *)(a1 + 164);
  if ( !(unsigned __int8)RtlCutoverTimeToSystemTime(&v15, &v20, &FileTime, 1)
    || !(unsigned __int8)RtlCutoverTimeToSystemTime(&v11, &v21, &FileTime, 1) )
  {
    BaseSetLastNTError(-1073741811);
    return -1;
  }
  v6 = 60 * *(_DWORD *)(a1 + 84);
  v24 = v6;
  v7 = v22 + v21 + 10000000i64 * v6;
  v8 = 60 * *(_DWORD *)(v2 + 168);
  v9 = v22 + v20 + 10000000i64 * v8;
  if ( v7 >= v9 )
  {
    if ( *(_QWORD *)&FileTime >= v9
      && (signed __int32)FileTime.dwHighDateTime <= SHIDWORD(v7)
      && ((signed __int32)FileTime.dwHighDateTime < SHIDWORD(v7) || FileTime.dwLowDateTime < (unsigned int)v7) )
      goto LABEL_12;
LABEL_19:
    v3 = 2;
    v10 = v8;
    goto LABEL_13;
  }
  if ( *(_QWORD *)&FileTime >= v7
    && (signed __int32)FileTime.dwHighDateTime <= SHIDWORD(v9)
    && ((signed __int32)FileTime.dwHighDateTime < SHIDWORD(v9) || FileTime.dwLowDateTime < (unsigned int)v9) )
    goto LABEL_19;
LABEL_12:
  v10 = v24;
  v3 = 1;
LABEL_13:
  v4 = v22 + 10000000i64 * v10;
LABEL_14:
  *(_DWORD *)a2 = v4;
  *(_DWORD *)(a2 + 8) = HIDWORD(v4);
  *(_DWORD *)(a2 + 4) = HIDWORD(v4);
  return v3;
}
// 77DE153C: using guessed type int __stdcall RtlCutoverTimeToSystemTime(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E12715) --------------------------------------------------------
signed int __stdcall SetClientTimeZoneInformation(int a1)
{
  __int16 v1; // cx@1
  int v3; // [sp+8h] [bp-1B4h]@1
  char v4; // [sp+Ch] [bp-1B0h]@1
  __int16 v5; // [sp+4Ch] [bp-170h]@1
  __int16 v6; // [sp+4Eh] [bp-16Eh]@1
  __int16 v7; // [sp+50h] [bp-16Ch]@1
  __int16 v8; // [sp+52h] [bp-16Ah]@1
  __int16 v9; // [sp+54h] [bp-168h]@1
  __int16 v10; // [sp+56h] [bp-166h]@1
  __int16 v11; // [sp+58h] [bp-164h]@1
  __int16 v12; // [sp+5Ah] [bp-162h]@1
  int v13; // [sp+5Ch] [bp-160h]@1
  char v14; // [sp+60h] [bp-15Ch]@1
  __int16 v15; // [sp+A0h] [bp-11Ch]@1
  __int16 v16; // [sp+A2h] [bp-11Ah]@1
  __int16 v17; // [sp+A4h] [bp-118h]@1
  __int16 v18; // [sp+A6h] [bp-116h]@1
  __int16 v19; // [sp+A8h] [bp-114h]@1
  __int16 v20; // [sp+AAh] [bp-112h]@1
  __int16 v21; // [sp+ACh] [bp-110h]@1
  __int16 v22; // [sp+AEh] [bp-10Eh]@1
  int v23; // [sp+B0h] [bp-10Ch]@1
  __int16 v24; // [sp+B4h] [bp-108h]@1
  char v25; // [sp+1B4h] [bp-8h]@1

  v3 = *(_DWORD *)a1;
  v13 = *(_DWORD *)(a1 + 84);
  v23 = *(_DWORD *)(a1 + 168);
  qmemcpy(&v4, (const void *)(a1 + 4), 0x40u);
  qmemcpy(&v14, (const void *)(a1 + 88), 0x40u);
  v5 = *(_WORD *)(a1 + 68);
  v6 = *(_WORD *)(a1 + 70);
  v12 = *(_WORD *)(a1 + 72);
  v7 = *(_WORD *)(a1 + 74);
  v8 = *(_WORD *)(a1 + 76);
  v9 = *(_WORD *)(a1 + 78);
  v10 = *(_WORD *)(a1 + 80);
  v11 = *(_WORD *)(a1 + 82);
  v15 = *(_WORD *)(a1 + 152);
  v16 = *(_WORD *)(a1 + 154);
  v22 = *(_WORD *)(a1 + 156);
  v17 = *(_WORD *)(a1 + 158);
  v18 = *(_WORD *)(a1 + 160);
  v19 = *(_WORD *)(a1 + 162);
  v1 = *(_WORD *)(a1 + 164);
  v21 = *(_WORD *)(a1 + 166);
  v24 = 0;
  v20 = v1;
  v25 = 1;
  return SetClientDynamicTimeZoneInformation((int)&v3);
}

//----- (77E1285E) --------------------------------------------------------
signed int __stdcall SetClientDynamicTimeZoneInformation(int a1)
{
  int v1; // eax@1
  signed int v2; // eax@1
  signed int result; // eax@2
  ULONG v4; // eax@4
  char v5; // [sp+0h] [bp-Ch]@1

  v1 = CalcClientTimeZoneIdAndBias(a1, (int)&v5);
  v2 = CsrBasepSetClientTimeZoneInformation(a1, (int)&v5, v1);
  if ( v2 < 0 )
  {
    v4 = RtlNtStatusToDosError(v2);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E12893) --------------------------------------------------------
signed int __stdcall CsrBasepSetClientTimeZoneInformation(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@2
  signed int result; // eax@2
  char v6; // [sp+Ch] [bp-E4h]@2
  char v7; // [sp+34h] [bp-BCh]@2
  int v8; // [sp+38h] [bp-B8h]@2
  int v9; // [sp+3Ch] [bp-B4h]@2
  int v10; // [sp+40h] [bp-B0h]@2
  int v11; // [sp+44h] [bp-ACh]@2
  int v12; // [sp+48h] [bp-A8h]@2

  v3 = CsrAllocateCaptureBuffer(1, 432);
  if ( v3 )
  {
    CsrCaptureMessageBuffer(v3, a1, 432, &v7);
    v8 = 432;
    v12 = a3;
    v9 = *(_DWORD *)a2;
    v10 = *(_DWORD *)(a2 + 4);
    v11 = *(_DWORD *)(a2 + 8);
    v4 = CsrClientCallServer(&v6, v3, 65558, 24);
    CsrFreeCaptureBuffer(v3);
    result = v4;
  }
  else
  {
    result = -1073741801;
  }
  return result;
}
// 77DE1134: using guessed type int __stdcall CsrCaptureMessageBuffer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E12951) --------------------------------------------------------
BOOL __stdcall FindNextVolumeWStub(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
{
  return FindNextVolumeW(hFindVolume, lpszVolumeName, cchBufferLength);
}

//----- (77E1295E) --------------------------------------------------------
BOOL __stdcall FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
{
  HANDLE v3; // edi@1
  int v4; // esi@1
  HANDLE v5; // ebx@1
  bool v6; // zf@1
  char *v7; // ecx@2
  size_t v8; // eax@7
  __int16 v10; // dx@10
  int v11; // eax@10
  int v12; // ebx@12
  int v13; // ebx@29
  int v14; // esi@30
  __int16 v15; // cx@32
  int v16; // eax@32
  int v17; // edx@34
  UNICODE_STRING String1; // [sp+Ch] [bp-18h]@29
  UNICODE_STRING String2; // [sp+14h] [bp-10h]@51
  int v20; // [sp+1Ch] [bp-8h]@12
  int v21; // [sp+20h] [bp-4h]@1
  HANDLE hFindVolumea; // [sp+2Ch] [bp+8h]@3

  v3 = hFindVolume;
  v4 = 0;
  v5 = 0;
  v21 = 0;
  v6 = *((_DWORD *)hFindVolume + 1) == 0;
  if ( *((_DWORD *)hFindVolume + 1) <= 0u )
    goto LABEL_6;
  v7 = (char *)hFindVolume + 8;
  while ( 1 )
  {
    hFindVolumea = v7;
    if ( *(_DWORD *)v7 )
      break;
LABEL_4:
    ++v4;
    v7 += 24;
    v21 = v4;
    if ( (unsigned int)v4 >= *((_DWORD *)v3 + 1) )
      goto LABEL_5;
  }
  v10 = *((_WORD *)v7 + 2);
  v11 = (int)((char *)v3 + *(_DWORD *)v7);
  if ( v10 != 96 && (v10 != 98 || *(_WORD *)(v11 + 96) != 92)
    || *(_WORD *)v11 != 92
    || (v12 = *(_WORD *)(v11 + 2), v20 = v12, (_WORD)v12 != 63) && (_WORD)v12 != 92
    || *(_WORD *)(v11 + 4) != 63
    || *(_WORD *)(v11 + 6) != 92
    || *(_WORD *)(v11 + 8) != 86
    || *(_WORD *)(v11 + 10) != 111
    || *(_WORD *)(v11 + 12) != 108
    || *(_WORD *)(v11 + 14) != 117
    || *(_WORD *)(v11 + 16) != 109
    || *(_WORD *)(v11 + 18) != 101
    || *(_WORD *)(v11 + 20) != 123
    || *(_WORD *)(v11 + 38) != 45
    || *(_WORD *)(v11 + 48) != 45
    || *(_WORD *)(v11 + 58) != 45
    || *(_WORD *)(v11 + 68) != 45
    || *(_WORD *)(v11 + 94) != 125
    || v10 != 96
    || (_WORD)v20 != 63 )
  {
    *(_DWORD *)v7 = 0;
    goto LABEL_4;
  }
  String1.MaximumLength = *((_WORD *)v7 + 10);
  String1.Length = String1.MaximumLength;
  v13 = v4 + 1;
  String1.Buffer = (PWCH)((char *)v3 + *((_DWORD *)v7 + 4));
  if ( (unsigned int)(v4 + 1) < *((_DWORD *)v3 + 1) )
  {
    v14 = (int)((char *)v3 + 24 * v13 + 8);
    do
    {
      if ( *(_DWORD *)v14 )
      {
        if ( (v15 = *(_WORD *)(v14 + 4), v16 = (int)((char *)v3 + *(_DWORD *)v14), v15 != 96)
          && (v15 != 98 || *(_WORD *)(v16 + 96) != 92)
          || *(_WORD *)v16 != 92
          || (v17 = *(_WORD *)(v16 + 2), v20 = v17, (_WORD)v17 != 63) && (_WORD)v17 != 92
          || *(_WORD *)(v16 + 4) != 63
          || *(_WORD *)(v16 + 6) != 92
          || *(_WORD *)(v16 + 8) != 86
          || *(_WORD *)(v16 + 10) != 111
          || *(_WORD *)(v16 + 12) != 108
          || *(_WORD *)(v16 + 14) != 117
          || *(_WORD *)(v16 + 16) != 109
          || *(_WORD *)(v16 + 18) != 101
          || *(_WORD *)(v16 + 20) != 123
          || *(_WORD *)(v16 + 38) != 45
          || *(_WORD *)(v16 + 48) != 45
          || *(_WORD *)(v16 + 58) != 45
          || *(_WORD *)(v16 + 68) != 45
          || *(_WORD *)(v16 + 94) != 125
          || v15 != 96
          || (_WORD)v20 != 63
          || (String2.MaximumLength = *(_WORD *)(v14 + 20),
              String2.Length = String2.MaximumLength,
              String2.Buffer = (PWCH)((char *)v3 + *(_DWORD *)(v14 + 16)),
              RtlEqualUnicodeString(&String1, &String2, 1u)) )
          *(_DWORD *)v14 = 0;
      }
      ++v13;
      v14 += 24;
    }
    while ( (unsigned int)v13 < *((_DWORD *)v3 + 1) );
    v4 = v21;
  }
LABEL_5:
  v5 = hFindVolumea;
  v6 = v4 == *((_DWORD *)v3 + 1);
LABEL_6:
  if ( v6 )
  {
    RtlSetLastWin32Error(18);
  }
  else
  {
    v8 = *((_WORD *)v5 + 2);
    if ( 2 * cchBufferLength >= v8 + 4 )
    {
      memcpy(lpszVolumeName, (char *)v3 + *(_DWORD *)v5, v8);
      lpszVolumeName[1] = 92;
      lpszVolumeName[(unsigned int)*((_WORD *)v5 + 2) >> 1] = 92;
      lpszVolumeName[((unsigned int)*((_WORD *)v5 + 2) >> 1) + 1] = 0;
      *(_DWORD *)v5 = 0;
      return 1;
    }
    RtlSetLastWin32Error(206);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E12BFD) --------------------------------------------------------
HANDLE __stdcall FindFirstVolumeWStub(LPWSTR lpszVolumeName, DWORD cchBufferLength)
{
  return FindFirstVolumeW(lpszVolumeName, cchBufferLength);
}

//----- (77E12C0A) --------------------------------------------------------
HANDLE __stdcall FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
{
  HANDLE result; // eax@1
  int v3; // eax@2
  PVOID v4; // eax@2
  DWORD *v5; // esi@2
  BOOL v6; // eax@3
  bool i; // zf@3
  int v8; // eax@10
  char InBuffer; // [sp+4h] [bp-24h]@2
  int v10; // [sp+1Ch] [bp-Ch]@4
  DWORD BytesReturned; // [sp+20h] [bp-8h]@3
  HANDLE hDevice; // [sp+24h] [bp-4h]@1

  result = CreateFileW(L"\\\\.\\MountPointManager", 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  hDevice = result;
  if ( result != (HANDLE)-1 )
  {
    memset(&InBuffer, 0, 0x18u);
    v3 = KernelBaseGetGlobalData();
    v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 0x20u);
    v5 = (DWORD *)v4;
    if ( v4 )
    {
      v6 = DeviceIoControl(hDevice, 0x6D0008u, &InBuffer, 0x18u, v4, 0x20u, &BytesReturned, 0);
      for ( i = v6 == 0; ; i = v6 == 0 )
      {
        v10 = v6;
        if ( !i || GetLastError() != 234 )
          break;
        BytesReturned = *v5;
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
        v8 = KernelBaseGetGlobalData();
        v5 = (DWORD *)RtlAllocateHeap(
                        NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                        *(_DWORD *)(v8 + 44),
                        BytesReturned);
        if ( !v5 )
          goto LABEL_12;
        v6 = DeviceIoControl(hDevice, 0x6D0008u, &InBuffer, 0x18u, v5, BytesReturned, &BytesReturned, 0);
      }
      CloseHandle(hDevice);
      if ( v10 && FindNextVolumeW(v5, lpszVolumeName, cchBufferLength) )
        return v5;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
    }
    else
    {
LABEL_12:
      CloseHandle(hDevice);
      RtlSetLastWin32Error(8);
    }
    result = (HANDLE)-1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E12D3E) --------------------------------------------------------
BOOL __stdcall FindVolumeCloseStub(HANDLE hFindVolume)
{
  return FindVolumeClose(hFindVolume);
}

//----- (77E12D4B) --------------------------------------------------------
BOOL __stdcall FindVolumeClose(HANDLE hFindVolume)
{
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, hFindVolume);
  return 1;
}

//----- (77E12D89) --------------------------------------------------------
ULONG __stdcall LocalOpenCurrentConfig(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  NTSTATUS v3; // eax@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-18h]@1

  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&CurrentConfigStringKey;
  v3 = NtOpenKey(KeyHandle, DesiredAccess, &ObjectAttributes);
  return RtlNtStatusToDosError(v3);
}
// 77E12DCC: using guessed type int CurrentConfigStringKey;

//----- (77E12E67) --------------------------------------------------------
HANDLE __stdcall CreateNamedPipeWStub(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  return CreateNamedPipeW(
           lpName,
           dwOpenMode,
           dwPipeMode,
           nMaxInstances,
           nOutBufferSize,
           nInBufferSize,
           nDefaultTimeOut,
           lpSecurityAttributes);
}

//----- (77E12E7F) --------------------------------------------------------
BOOL __stdcall ConnectNamedPipeStub(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
{
  return ConnectNamedPipe(hNamedPipe, lpOverlapped);
}

//----- (77E12EAF) --------------------------------------------------------
DWORD __stdcall GetDynamicTimeZoneInformationStub(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
{
  return GetDynamicTimeZoneInformation(pTimeZoneInformation);
}

//----- (77E12EE2) --------------------------------------------------------
BOOL __stdcall EnumUILanguagesWStub(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
{
  return EnumUILanguagesW(lpUILanguageEnumProc, dwFlags, lParam);
}

//----- (77E12F72) --------------------------------------------------------
HANDLE __stdcall OpenPrivateNamespaceW(int a1, HANDLE Handle)
{
  int v2; // eax@1
  UNICODE_STRING DestinationString; // [sp+0h] [bp-8h]@1

  v2 = RtlInitUnicodeStringEx(&DestinationString, (PCWSTR)Handle);
  if ( v2 < 0 || (v2 = NtOpenPrivateNamespace(&Handle, 0x2000000, 0, a1), v2 < 0) )
  {
    BaseSetLastNTError(v2);
  }
  else
  {
    if ( BasepAddPrefixAlias((int)&DestinationString, (int)Handle, 0) )
      return Handle;
    NtClose(Handle);
    BaseSetLastNTError(-1073741635);
  }
  return 0;
}
// 77DE124C: using guessed type int __stdcall NtOpenPrivateNamespace(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E12FCC) --------------------------------------------------------
BOOL __stdcall SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
{
  int v3; // eax@1
  NTSTATUS v4; // esi@1
  BOOL result; // eax@1
  char v6; // [sp+4h] [bp-8h]@1

  v3 = BaseFormatTimeOut((int)&v6, dwMilliseconds);
  v4 = RtlSleepConditionVariableCS(ConditionVariable, CriticalSection, v3);
  BaseSetLastNTError(v4);
  result = 0;
  if ( v4 >= 0 )
    LOBYTE(result) = v4 != 258;
  return result;
}
// 77DE1248: using guessed type int __stdcall RtlSleepConditionVariableCS(_DWORD, _DWORD, _DWORD);

//----- (77E1305F) --------------------------------------------------------
DWORD __stdcall GetLogicalDriveStringsWStub(DWORD nBufferLength, LPWSTR lpBuffer)
{
  return GetLogicalDriveStringsW(nBufferLength, lpBuffer);
}

//----- (77E130A2) --------------------------------------------------------
int __stdcall GetSystemDefaultLocaleNameStub(LPWSTR lpLocaleName, int cchLocaleName)
{
  return GetSystemDefaultLocaleName(lpLocaleName, cchLocaleName);
}

//----- (77E131DB) --------------------------------------------------------
int __stdcall BuildSubSysCommandLine(int a1, int SourceString, int a3, int a4, PUNICODE_STRING UnicodeString)
{
  NTSTATUS v5; // eax@1
  int v6; // eax@5
  int v7; // eax@6
  NTSTATUS v8; // esi@7
  NTSTATUS v9; // eax@10
  NTSTATUS v11; // eax@20
  UNICODE_STRING DestinationString; // [sp+4h] [bp-28h]@2
  UNICODE_STRING v13; // [sp+Ch] [bp-20h]@3
  UNICODE_STRING v14; // [sp+14h] [bp-18h]@1
  UNICODE_STRING Source; // [sp+1Ch] [bp-10h]@1
  LSA_UNICODE_STRING Destination; // [sp+24h] [bp-8h]@4

  v14.Length = 8;
  v14.MaximumLength = 10;
  v14.Buffer = L" /C ";
  v5 = RtlInitUnicodeStringEx(&Source, (PCWSTR)SourceString);
  if ( v5 < 0
    || (v5 = RtlInitUnicodeStringEx(&DestinationString, (PCWSTR)a3), v5 < 0)
    || (v5 = RtlInitUnicodeStringEx(&v13, (PCWSTR)a4), v5 < 0) )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  Destination.Length = 0;
  if ( a1 )
  {
    if ( a1 == 2 )
      v6 = *(_DWORD *)&Source + *(_DWORD *)&v13 + *(_DWORD *)&DestinationString + *(_DWORD *)&v14 + 4;
    else
      v6 = *(_DWORD *)&Source + *(_DWORD *)&v13 + 4;
  }
  else
  {
    v6 = *(_DWORD *)&v13 + *(_DWORD *)&Source + 8;
  }
  Destination.MaximumLength = v6;
  v7 = KernelBaseGetGlobalData();
  Destination.Buffer = (PWCH)RtlAllocateHeap(
                               NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                               *(_DWORD *)(v7 + 44),
                               Destination.MaximumLength);
  if ( !Destination.Buffer )
  {
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  v8 = RtlAppendUnicodeStringToString(&Destination, &Source);
  if ( v8 < 0 )
    goto LABEL_27;
  v8 = RtlAppendUnicodeToString(&Destination, L" ");
  if ( v8 < 0 )
    goto LABEL_27;
  if ( !a1 )
  {
    v9 = RtlAppendUnicodeToString(&Destination, L"\"");
    goto LABEL_11;
  }
  if ( a1 != 2 )
    goto LABEL_12;
  v11 = RtlAppendUnicodeStringToString(&Destination, &DestinationString);
  v8 = v11;
  if ( v11 >= 0 )
  {
    v9 = RtlAppendUnicodeStringToString(&Destination, &v14);
LABEL_11:
    v8 = v9;
    if ( v9 >= 0 )
    {
LABEL_12:
      v8 = RtlAppendUnicodeStringToString(&Destination, &v13);
      if ( v8 >= 0 )
      {
        if ( a1 || (v8 = RtlAppendUnicodeToString(&Destination, L"\""), v8 >= 0) )
        {
          RtlFreeUnicodeString(UnicodeString);
          *UnicodeString = Destination;
          return 1;
        }
      }
      goto LABEL_27;
    }
  }
LABEL_27:
  RtlFreeUnicodeString(&Destination);
  BaseSetLastNTError(v8);
  return 0;
}
// 77E13324: using guessed type wchar_t aC_0[5];

//----- (77E133B0) --------------------------------------------------------
LSTATUS __stdcall RegFlushKey(HKEY hKey)
{
  int (__stdcall *v1)(_DWORD); // edi@1
  HKEY v2; // esi@4
  int v3; // eax@4
  LSTATUS v4; // esi@4
  int v5; // edi@7
  int v6; // ebx@7
  int v7; // eax@7
  LSTATUS result; // eax@7
  int v9; // [sp+18h] [bp-20h]@1
  int v10; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@12

  v9 = 0;
  v10 = 0;
  v1 = *(int (__stdcall **)(_DWORD))(RegKrnGetGlobalState() + 88);
  if ( hKey == HKEY_PERFORMANCE_DATA || hKey == HKEY_PERFORMANCE_TEXT || hKey == HKEY_PERFORMANCE_NLSTEXT )
  {
    result = 0;
  }
  else
  {
    v2 = hKey;
    v3 = RegKrnGetGlobalState();
    v4 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v3 + 176))(v2, &hKey, &v9, &v10);
    if ( !v4 )
    {
      if ( (unsigned __int8)hKey & 1 )
      {
        if ( v1 )
        {
          ms_exc.registration.TryLevel = 0;
          v4 = v1((unsigned int)hKey & 0xFFFFFFFE);
          ms_exc.registration.TryLevel = -2;
        }
      }
      else
      {
        v4 = LocalBaseRegFlushKey(hKey);
      }
    }
    v5 = v10;
    v6 = v9;
    v7 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v7 + 168))(v6, v5);
    result = v4;
  }
  return result;
}

//----- (77E13461) --------------------------------------------------------
ULONG __stdcall LocalBaseRegFlushKey(HANDLE KeyHandle)
{
  NTSTATUS v1; // eax@4
  ULONG result; // eax@4

  if ( KeyHandle == (HANDLE)-2147483644 || KeyHandle == (HANDLE)-2147483568 || KeyHandle == (HANDLE)-2147483552 )
  {
    result = 0;
  }
  else
  {
    v1 = NtFlushKey(KeyHandle);
    result = RtlNtStatusToDosError(v1);
  }
  return result;
}

//----- (77E134C3) --------------------------------------------------------
int __stdcall WerpHeapGetBlockFromFreeList(struct _WER_HEAP_MAIN_HEADER *a1, unsigned __int32 a2)
{
  struct _WER_HEAP_BLOCK_HEADER *v2; // esi@1
  int result; // eax@1
  int v4; // eax@2
  unsigned int v5; // edx@3
  unsigned int v6; // ecx@3
  int v7; // eax@8

  v2 = 0;
  result = *((_DWORD *)a1 + 17) | *((_DWORD *)a1 + 16);
  if ( *((_QWORD *)a1 + 8) )
  {
    v4 = *((_DWORD *)a1 + 16);
    if ( v4 )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v4 + 16);
        v6 = *(_DWORD *)(v4 + 20);
        if ( v5 == a2 && !v6 )
          break;
        if ( __PAIR__(v6, v5) > a2 && (!v2 || __PAIR__(v6, v5) < *((_QWORD *)v2 + 2)) )
          v2 = (struct _WER_HEAP_BLOCK_HEADER *)v4;
        v4 = *(_DWORD *)(v4 + 4);
        if ( !v4 )
          goto LABEL_6;
      }
      v2 = (struct _WER_HEAP_BLOCK_HEADER *)v4;
LABEL_6:
      if ( v2 )
      {
        if ( *(_DWORD *)v2 )
          *(_DWORD *)(*(_DWORD *)v2 + 4) = *((_DWORD *)v2 + 1);
        v7 = *((_DWORD *)v2 + 1);
        if ( v7 )
          *(_DWORD *)v7 = *(_DWORD *)v2;
        if ( *((struct _WER_HEAP_BLOCK_HEADER **)a1 + 16) == v2 )
          *((_QWORD *)a1 + 8) = *((_DWORD *)v2 + 1);
        memset(*((void **)v2 + 2), 0, *((_DWORD *)v2 + 4));
      }
    }
    result = (int)v2;
  }
  return result;
}

//----- (77E13549) --------------------------------------------------------
PTP_POOL __stdcall CreateThreadpoolStub(PVOID reserved)
{
  return CreateThreadpool(reserved);
}

//----- (77E13556) --------------------------------------------------------
PTP_POOL __stdcall CreateThreadpool(PVOID reserved)
{
  int v1; // eax@1
  PTP_POOL result; // eax@2

  v1 = TpAllocPool(&reserved, reserved);
  if ( v1 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v1);
    result = 0;
  }
  else
  {
    result = (PTP_POOL)reserved;
  }
  return result;
}
// 77DE103C: using guessed type int __stdcall TpAllocPool(_DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E1357C) --------------------------------------------------------
BOOL __stdcall SetThreadpoolThreadMinimumStub(PTP_POOL ptpp, DWORD cthrdMic)
{
  return SetThreadpoolThreadMinimum(ptpp, cthrdMic);
}

//----- (77E13589) --------------------------------------------------------
BOOL __stdcall SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
{
  int v2; // eax@1
  BOOL result; // eax@2

  v2 = TpSetPoolMinThreads(ptpp, cthrdMic);
  if ( v2 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1038: using guessed type int __stdcall TpSetPoolMinThreads(_DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E135C0) --------------------------------------------------------
PTP_IO __stdcall CreateThreadpoolIoStub(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  return CreateThreadpoolIo(fl, pfnio, pv, pcbe);
}

//----- (77E135CD) --------------------------------------------------------
PTP_IO __stdcall CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  PTP_WIN32_IO_CALLBACK v4; // edi@1
  PVOID v5; // eax@2
  PVOID v6; // ebx@2
  int v7; // eax@8
  PTP_IO result; // eax@16
  int v9; // [sp+10h] [bp-4Ch]@4
  int v10; // [sp+14h] [bp-48h]@11
  int v11; // [sp+18h] [bp-44h]@5
  int (__stdcall *v12)(int, int); // [sp+1Ch] [bp-40h]@6
  int v13; // [sp+20h] [bp-3Ch]@11
  int v14; // [sp+24h] [bp-38h]@11
  BOOLEAN (__stdcall *v15)(int, PVOID); // [sp+28h] [bp-34h]@5
  int v16; // [sp+2Ch] [bp-30h]@11
  int v17; // [sp+30h] [bp-2Ch]@11
  int v18; // [sp+34h] [bp-28h]@11
  int v19; // [sp+38h] [bp-24h]@2
  PVOID Address; // [sp+3Ch] [bp-20h]@1
  struct _TP_IO *v21; // [sp+40h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@2

  Address = 0;
  v21 = 0;
  v4 = pfnio;
  if ( pfnio )
  {
    ms_exc.registration.TryLevel = 0;
    v19 = 1;
    v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x10u);
    v6 = v5;
    Address = v5;
    if ( v5 )
    {
      *(_DWORD *)v5 = pfnio;
      if ( pcbe )
      {
        qmemcpy(&v9, pcbe, 0x28u);
        v4 = pfnio;
      }
      else
      {
        v9 = 3;
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v17 = 1;
        v18 = 40;
      }
      *((_DWORD *)v5 + 1) = v15;
      v15 = BasepTpIoFinalizationCallback;
      if ( v11 && v12 )
      {
        *((_DWORD *)v5 + 2) = v12;
        v12 = BasepTpIoCleanupCallback;
      }
      else
      {
        *((_DWORD *)v5 + 2) = 0;
      }
      *(_DWORD *)v5 = v4;
      *((_DWORD *)v5 + 3) = pv;
      v7 = TpAllocIoCompletion(&v21, fl, BasepTpIoCallback, v5, &v9);
      if ( v7 < 0 )
      {
        v21 = 0;
        RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v7);
      }
    }
    else
    {
      RtlSetLastWin32ErrorAndNtStatusFromNtStatus(-1073741801);
    }
    ms_exc.registration.TryLevel = -2;
    v19 = 0;
    if ( v19 || !v21 )
    {
      if ( v6 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
    result = v21;
  }
  else
  {
    SetLastError(0x57u);
    RaiseException(0xC000000D, 0, 0, 0);
    result = 0;
  }
  return result;
}
// 77DE1018: using guessed type int __stdcall TpAllocIoCompletion(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E136D1) --------------------------------------------------------
BOOLEAN __stdcall BasepTpIoFinalizationCallback(int a1, PVOID Address)
{
  int (__stdcall *v2)(_DWORD, _DWORD); // esi@1
  int v3; // edi@1
  BOOLEAN result; // al@1

  v2 = (int (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)Address + 1);
  v3 = *((_DWORD *)Address + 3);
  result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v2 )
    result = v2(a1, v3);
  return result;
}

//----- (77E137E5) --------------------------------------------------------
HANDLE __stdcall CreateActCtxA(PCACTCTXA pActCtx)
{
  ULONG v1; // edi@2
  unsigned int v2; // eax@2
  int v3; // ecx@3
  char v4; // bl@4
  int v5; // eax@12
  NTSTATUS v6; // eax@12
  ULONG v7; // eax@19
  int v9; // eax@44
  CHAR *v10; // [sp-10h] [bp-278h]@50
  int v11; // [sp-Ch] [bp-274h]@50
  PCACTCTXA v12; // [sp-8h] [bp-270h]@50
  ULONG v13; // [sp-4h] [bp-26Ch]@50
  ACTCTXW v14; // [sp+Ch] [bp-25Ch]@1
  STRING DestinationString; // [sp+2Ch] [bp-23Ch]@12
  int v16; // [sp+34h] [bp-234h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+38h] [bp-230h]@1
  struct _TEB *v18; // [sp+40h] [bp-228h]@1
  ULONG v19; // [sp+44h] [bp-224h]@1
  HANDLE v20; // [sp+48h] [bp-220h]@1
  LSA_UNICODE_STRING v21; // [sp+4Ch] [bp-21Ch]@1
  NTSTATUS NtStatus; // [sp+54h] [bp-214h]@1
  char v23; // [sp+58h] [bp-210h]@44

  v20 = (HANDLE)-1;
  UnicodeString.Length = 0;
  v14.cbSize = 32;
  memset(&v14.dwFlags, 0, 0x1Cu);
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  v21.Length = 0;
  *(_DWORD *)&v21.MaximumLength = 0;
  HIWORD(v21.Buffer) = 0;
  NtStatus = 0;
  v19 = 0;
  v18 = NtCurrentTeb();
  if ( !pActCtx
    || (v1 = pActCtx->cbSize,
        v2 = (unsigned int)((char *)&pActCtx->cbSize + pActCtx->cbSize),
        (unsigned int)&pActCtx->wProcessorArchitecture > v2) )
  {
    v13 = pActCtx->cbSize;
    v12 = pActCtx;
    v11 = (int)"CreateActCtxA";
    v10 = "SXS: %s() Null %p or size 0x%lx too small\n";
    goto LABEL_52;
  }
  v3 = pActCtx->dwFlags;
  v16 = v3;
  v14.dwFlags = v3;
  if ( v3 & 0xFFFFFF00
    || (v4 = v3, v3 & 1) && (unsigned int)&pActCtx->wLangId > v2
    || v3 & 2 && (unsigned int)&pActCtx->lpAssemblyDirectory > v2
    || v3 & 4 && (unsigned int)&pActCtx->lpResourceName > v2
    || v3 & 8 && (unsigned int)&pActCtx->lpApplicationName > v2
    || v3 & 0x20 && (unsigned int)&pActCtx->hModule > v2
    || v14.dwFlags & 0x80 && (unsigned int)&pActCtx[1] > v2 )
  {
    v13 = v1;
    v12 = (PCACTCTXA)v16;
    v11 = (int)"CreateActCtxA";
    v10 = "SXS: %s() Bad flags/size 0x%lx/0x%lx\n";
LABEL_52:
    _DbgPrintEx(0x33u, 0, v10, v11, v12, v13);
    goto LABEL_53;
  }
  if ( pActCtx->lpSource )
  {
    RtlInitAnsiString(&DestinationString, pActCtx->lpSource);
    v5 = KernelBaseGetGlobalData();
    v6 = (*(int (__stdcall **)(LSA_UNICODE_STRING *, STRING *, signed int))(v5 + 24))(
           &UnicodeString,
           &DestinationString,
           1);
    NtStatus = v6;
    if ( v6 < 0 )
    {
      if ( v6 == -2147483643 )
        NtStatus = -1073741562;
      goto LABEL_22;
    }
    v4 = LOBYTE(v14.dwFlags);
    v14.lpSource = UnicodeString.Buffer;
  }
  else
  {
    if ( !(v14.dwFlags & 0x80) )
    {
LABEL_53:
      NtStatus = -1073741811;
      goto LABEL_22;
    }
    v14.lpSource = 0;
  }
  if ( v4 & 1 )
    v14.wProcessorArchitecture = pActCtx->wProcessorArchitecture;
  if ( v4 & 2 )
    v14.wLangId = pActCtx->wLangId;
  if ( v4 < 0 )
    v14.hModule = pActCtx->hModule;
  if ( !(v4 & 4) )
  {
LABEL_18:
    if ( v4 & 8 )
    {
      v7 = BaseDllMapResourceIdA((ULONG)pActCtx->lpResourceName);
      v19 = v7;
      if ( v7 == -1 )
      {
        _DbgPrintEx(0x33u, 0, "SXS: %s() BaseDllMapResourceIdA failed\n", "CreateActCtxA");
LABEL_49:
        NtStatus = *(_DWORD *)&v18->Reserved3[1412];
        goto LABEL_22;
      }
      v14.lpResourceName = (LPCWSTR)v7;
    }
    v20 = CreateActCtxW(&v14);
    if ( v20 != (HANDLE)-1 )
      goto LABEL_22;
    goto LABEL_49;
  }
  RtlInitAnsiString(&DestinationString, pActCtx->lpAssemblyDirectory);
  v21.MaximumLength = 522;
  v21.Buffer = (PWCH)&v23;
  v9 = KernelBaseGetGlobalData();
  NtStatus = (*(int (__stdcall **)(LSA_UNICODE_STRING *, STRING *, _DWORD))(v9 + 24))(&v21, &DestinationString, 0);
  if ( NtStatus == -2147483643 )
    NtStatus = -1073741562;
  if ( (NtStatus & 0xC0000000) != -1073741824 )
  {
    v4 = LOBYTE(v14.dwFlags);
    v14.lpAssemblyDirectory = v21.Buffer;
    goto LABEL_18;
  }
LABEL_22:
  if ( UnicodeString.Buffer )
    RtlFreeUnicodeString(&UnicodeString);
  if ( v21.Buffer && (char *)v21.Buffer != &v23 )
    RtlFreeUnicodeString(&v21);
  BaseDllFreeResourceId(v19);
  if ( v20 == (HANDLE)-1 )
    BaseSetLastNTError(NtStatus);
  return v20;
}
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);

//----- (77E13B12) --------------------------------------------------------
#error "77E13B34: positive sp value has been found (funcsize=10)"

//----- (77E13B3A) --------------------------------------------------------
void __userpurge sub_77E13B3A(int a1@<eax>, int a2@<ebx>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  JUMPOUT(a1, a2, &loc_77E315C1);
  JUMPOUT(&loc_77E5D758);
}

//----- (77E13BF2) --------------------------------------------------------
signed int __stdcall _DeleteElement(struct _WER_PEB_HEADER_BLOCK *a1, struct _WER_GATHER *a2, struct _WER_GATHER *a3)
{
  int v3; // eax@5
  signed int v4; // esi@6
  signed int result; // eax@8

  if ( a1 && a2 )
  {
    InterlockedDecrement((volatile LONG *)a1 + 544);
    if ( a3 )
    {
      *(_DWORD *)a3 = *(_DWORD *)a2;
      *((_DWORD *)a3 + 1) = *((_DWORD *)a2 + 1);
    }
    else
    {
      *((_DWORD *)a1 + 538) = *(_DWORD *)a2;
      *((_DWORD *)a1 + 539) = *((_DWORD *)a2 + 1);
    }
    v3 = WerpGetHeapHandle();
    if ( v3 )
    {
      v4 = WerpHeapFree((struct _WER_HEAP_MAIN_HEADER *)v3, (void *)a2) != 0 ? 0 : -2147467259;
      if ( v4 < 0 )
        DbgPrintOut(0, "WerpHeapFree failed with 0x%x", v4);
      else
        v4 = 0;
    }
    else
    {
      v4 = -2147467259;
    }
    result = v4;
  }
  else
  {
    DbgPrintOut(0, "_DeleteElementInvalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E13C6B) --------------------------------------------------------
int __stdcall WerpHeapFree(struct _WER_HEAP_MAIN_HEADER *a1, void *a2)
{
  char *v2; // eax@4
  int v3; // ecx@11
  signed int v5; // [sp+10h] [bp-1Ch]@12

  if ( !a1 || !a2 )
  {
    DbgPrintOut(0, "Invalid arguments");
    SetLastError(0x57u);
    return 0;
  }
  if ( !WerpHeapLock(a1) )
  {
    DbgPrintOut(0, "Failed to lock the heap");
    return 0;
  }
  v2 = (char *)a2 - 32;
  if ( *((void **)a2 - 6) == a2 )
  {
    if ( *(_DWORD *)v2 )
      *(_DWORD *)(*(_DWORD *)v2 + 4) = *((_DWORD *)v2 + 1);
    if ( *((_DWORD *)v2 + 1) )
      **((_DWORD **)v2 + 1) = *(_DWORD *)v2;
    if ( v2 == *((char **)a1 + 8) )
    {
      *((_DWORD *)a1 + 8) = *((_DWORD *)v2 + 1);
      *((_DWORD *)a1 + 9) = 0;
    }
    if ( v2 == *((char **)a1 + 10) )
    {
      *((_DWORD *)a1 + 10) = *(_DWORD *)v2;
      *((_DWORD *)a1 + 11) = 0;
    }
    *((_DWORD *)v2 + 6) = 0;
    v3 = *((_DWORD *)a1 + 16);
    *((_DWORD *)v2 + 1) = v3;
    if ( v3 )
      *(_DWORD *)v3 = v2;
    *(_DWORD *)v2 = 0;
    *((_DWORD *)a1 + 16) = v2;
    *((_DWORD *)a1 + 17) = 0;
    v5 = 1;
  }
  else
  {
    DbgPrintOut(0, "Invalid block passed");
    SetLastError(0x57u);
    v5 = 0;
  }
  WerpHeapUnLock(a1);
  return v5;
}

//----- (77E13D4A) --------------------------------------------------------
BOOL __stdcall sub_77E13D4A(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
{
  return GetDiskFreeSpaceWStub(
           lpRootPathName,
           lpSectorsPerCluster,
           lpBytesPerSector,
           lpNumberOfFreeClusters,
           lpTotalNumberOfClusters);
}

//----- (77E13D4C) --------------------------------------------------------
BOOL __stdcall GetDiskFreeSpaceWStub(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
{
  return GetDiskFreeSpaceW(
           lpRootPathName,
           lpSectorsPerCluster,
           lpBytesPerSector,
           lpNumberOfFreeClusters,
           lpTotalNumberOfClusters);
}

//----- (77E13D96) --------------------------------------------------------
int __stdcall WerpRegisterRestart(unsigned __int16 *a1, int a2)
{
  struct _PEB *v2; // esi@1
  PVOID v3; // esi@4
  signed int v5; // [sp+10h] [bp-1Ch]@2

  v2 = WerpCurrentPeb();
  if ( v2 )
  {
    v5 = WerpInitPEBStore();
    if ( v5 < 0 )
    {
      DbgPrintOut(0, "WerpInitPEBStore failed");
      return v5;
    }
    if ( WerpAcquirePebLock() >= 0 )
    {
      v3 = v2[1].Reserved9[8];
      if ( v3 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v3) >= 0 )
      {
        if ( a1 )
        {
          if ( wcslen(a1) >= 0x400 )
          {
            DbgPrintOut(0, "Too long restart command line passed");
            v5 = -2147024809;
          }
          else
          {
            v5 = StringCchCopyW((unsigned __int16 *)v3 + 20, 0x400u, a1);
            *((_DWORD *)v3 + 9) = v5 >= 0;
            *((_DWORD *)v3 + 8) = a2;
          }
        }
        else
        {
          *((_DWORD *)v3 + 9) = 0;
          *((_WORD *)v3 + 20) = 0;
        }
      }
      else
      {
        DbgPrintOut(0, "Invalid PEB entry");
      }
      RtlReleasePebLock();
      return v5;
    }
    DbgPrintOut(0, "Unable to get the peb lock");
  }
  else
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
  }
  return -2147467259;
}

//----- (77E13E7D) --------------------------------------------------------
HRESULT __stdcall RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
{
  unsigned __int16 *v2; // eax@1

  v2 = (unsigned __int16 *)pwzCommandline;
  if ( !pwzCommandline )
    v2 = (unsigned __int16 *)&Src;
  return WerpRegisterRestart(v2, dwFlags);
}

//----- (77E13EBB) --------------------------------------------------------
BOOL __stdcall GetFileMUIPathStub(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
{
  return GetFileMUIPath(
           dwFlags,
           pcwszFilePath,
           pwszLanguage,
           pcchLanguage,
           pwszFileMUIPath,
           pcchFileMUIPath,
           pululEnumerator);
}

//----- (77E13F40) --------------------------------------------------------
char __stdcall BasepAddPrefixAlias(int a1, int a2, char a3)
{
  __int16 v3; // cx@1
  PVOID v4; // esi@3
  __int16 v5; // ax@4
  PVOID v6; // eax@4
  int v7; // eax@6

  v3 = *(_WORD *)a1;
  if ( (unsigned int)*(_WORD *)a1 + 2 < *(_WORD *)a1 || v3 & 1 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x18u);
  if ( !v4 )
  {
LABEL_9:
    BaseSetLastNTError(-1073741670);
    return 0;
  }
  v5 = *(_WORD *)a1 + 2;
  *((_WORD *)v4 + 4) = v5;
  *((_WORD *)v4 + 5) = v5;
  v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((_WORD *)v4 + 4));
  *((_DWORD *)v4 + 3) = v6;
  if ( !v6 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    goto LABEL_9;
  }
  memcpy(v6, *(const void **)(a1 + 4), *(_WORD *)a1);
  *(_WORD *)(*((_DWORD *)v4 + 3) + 2 * ((unsigned int)*((_WORD *)v4 + 4) >> 1) - 2) = 92;
  RtlAcquireSRWLockExclusive(&BasePrivatenamespaceLock);
  if ( !BasepFindPrefixAlias((PCUNICODE_STRING)v4 + 1) )
  {
    *((_DWORD *)v4 + 4) = a2;
    *((_BYTE *)v4 + 20) = a3;
    v7 = dword_77EA62DC;
    *(_DWORD *)v4 = &BasePrefixList;
    *((_DWORD *)v4 + 1) = v7;
    *(_DWORD *)v7 = v4;
    dword_77EA62DC = (int)v4;
    BaseUsePrivateNamespaces = 1;
    RtlReleaseSRWLockExclusive(&BasePrivatenamespaceLock);
    return 1;
  }
  RtlReleaseSRWLockExclusive(&BasePrivatenamespaceLock);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)v4 + 3));
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
  BaseSetLastNTError(-1073741635);
  return 0;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA62DC: using guessed type int dword_77EA62DC;
// 77EA6530: using guessed type char BaseUsePrivateNamespaces;
// 77EA6794: using guessed type int BasePrivatenamespaceLock;

//----- (77E1403B) --------------------------------------------------------
int __stdcall BasepFindPrefixAlias(PCUNICODE_STRING String2)
{
  int i; // esi@2
  int result; // eax@4

  if ( !BasePrefixLastHint || RtlCompareUnicodeString((PCUNICODE_STRING)(BasePrefixLastHint + 8), String2, 1u) )
  {
    for ( i = BasePrefixList; ; i = *(_DWORD *)i )
    {
      if ( (int *)i == &BasePrefixList )
        return 0;
      if ( !RtlCompareUnicodeString((PCUNICODE_STRING)(i + 8), String2, 1u) )
        break;
    }
    BasePrefixLastHint = i;
    result = i;
  }
  else
  {
    result = BasePrefixLastHint;
  }
  return result;
}
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA652C: using guessed type int BasePrefixLastHint;

//----- (77E14077) --------------------------------------------------------
HANDLE __stdcall CreatePrivateNamespaceW(int a1, int a2, HANDLE Handle)
{
  int v3; // eax@1
  char v5; // [sp+0h] [bp-24h]@4
  UNICODE_STRING DestinationString; // [sp+18h] [bp-Ch]@1
  int v7; // [sp+20h] [bp-4h]@4

  v3 = RtlInitUnicodeStringEx(&DestinationString, (PCWSTR)Handle);
  if ( v3 < 0 )
    goto LABEL_15;
  if ( a1 && *(_DWORD *)(a1 + 8) )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v3 = BaseFormatObjectAttributes((int)&v5, a1, 0, (int)&v7);
  if ( v3 < 0 || (v3 = NtCreatePrivateNamespace(&Handle, 0x2000000, v7, a2), v3 < 0) )
  {
LABEL_15:
    BaseSetLastNTError(v3);
  }
  else
  {
    if ( BasepAddPrefixAlias((int)&DestinationString, (int)Handle, 1) )
      return Handle;
    NtDeletePrivateNamespace(Handle);
    NtClose(Handle);
    BaseSetLastNTError(-1073741635);
  }
  return 0;
}
// 77DE1250: using guessed type int __stdcall NtCreatePrivateNamespace(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1254: using guessed type int __stdcall NtDeletePrivateNamespace(_DWORD);

//----- (77E140FC) --------------------------------------------------------
char __stdcall ClosePrivateNamespace(HANDLE Handle, char a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  char result; // al@3

  RtlAcquireSRWLockExclusive(&BasePrivatenamespaceLock);
  v2 = BasepFindPrefixAliasByHandle((int)Handle);
  v3 = (void *)v2;
  if ( v2 )
  {
    if ( a2 & 1 )
    {
      if ( *(_BYTE *)(v2 + 20) )
        NtDeletePrivateNamespace(Handle);
    }
    NtClose(Handle);
    BasepFreePrefixAlias(v3);
    RtlReleaseSRWLockExclusive(&BasePrivatenamespaceLock);
    result = 1;
  }
  else
  {
    RtlReleaseSRWLockExclusive(&BasePrivatenamespaceLock);
    BaseSetLastNTError(-1073741816);
    result = 0;
  }
  return result;
}
// 77DE1254: using guessed type int __stdcall NtDeletePrivateNamespace(_DWORD);
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77EA6794: using guessed type int BasePrivatenamespaceLock;

//----- (77E1414E) --------------------------------------------------------
int __stdcall BasepFindPrefixAliasByHandle(int a1)
{
  int result; // eax@1

  result = BasePrefixLastHint;
  if ( !BasePrefixLastHint || *(_DWORD *)(BasePrefixLastHint + 16) != a1 )
  {
    for ( result = BasePrefixList; ; result = *(_DWORD *)result )
    {
      if ( (int *)result == &BasePrefixList )
        return 0;
      if ( *(_DWORD *)(result + 16) == a1 )
        break;
    }
    BasePrefixLastHint = result;
  }
  return result;
}
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA652C: using guessed type int BasePrefixLastHint;

//----- (77E141CD) --------------------------------------------------------
HANDLE __stdcall RegisterWaitForSingleObjectEx(HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
{
  BOOL v5; // eax@1
  HANDLE phNewWaitObject; // [sp+0h] [bp-4h]@1

  phNewWaitObject = 0;
  v5 = RegisterWaitForSingleObject(&phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
  return (HANDLE)(v5 != 0 ? (unsigned int)phNewWaitObject : 0);
}

//----- (77E14207) --------------------------------------------------------
LSTATUS __stdcall RegDisablePredefinedCacheEx()
{
  int v0; // eax@1
  NTSTATUS v1; // eax@1

  v0 = RegKrnGetGlobalState();
  v1 = (*(int (__stdcall **)(_DWORD))(v0 + 172))(0);
  return RtlNtStatusToDosError(v1);
}

//----- (77E1423F) --------------------------------------------------------
PTP_WAIT __stdcall CreateThreadpoolWaitStub(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  return CreateThreadpoolWait(pfnwa, pv, pcbe);
}

//----- (77E1424C) --------------------------------------------------------
PTP_WAIT __stdcall CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  int v3; // eax@1
  PTP_WAIT result; // eax@2

  v3 = TpAllocWait(&pcbe, pfnwa, pv, pcbe);
  if ( v3 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v3);
    result = 0;
  }
  else
  {
    result = (PTP_WAIT)pcbe;
  }
  return result;
}
// 77DE101C: using guessed type int __stdcall TpAllocWait(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E142EA) --------------------------------------------------------
HANDLE __stdcall CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
{
  DWORD v3; // eax@1

  v3 = 0;
  if ( bManualReset )
    v3 = 1;
  return CreateWaitableTimerExA(lpTimerAttributes, lpTimerName, v3, 0x1F0003u);
}

//----- (77E14314) --------------------------------------------------------
HANDLE __stdcall CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  HANDLE v4; // esi@3
  HANDLE result; // eax@4
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpTimerName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpTimerName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v4 = CreateWaitableTimerExW(lpTimerAttributes, UnicodeString.Buffer, dwFlags, dwDesiredAccess);
  if ( lpTimerName )
    RtlFreeUnicodeString(&UnicodeString);
  return v4;
}

//----- (77E14359) --------------------------------------------------------
int __stdcall RegGetValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, int a4, int a5, void *Dst, size_t Size)
{
  size_t v7; // edi@1
  int v8; // ebx@4
  int v9; // esi@4

  v7 = Size;
  if ( Dst && Size )
    Size = *(_DWORD *)Size;
  else
    Size = 0;
  v8 = a4;
  v9 = RestrictArguments((int)hKey, a4, (int)Dst, v7);
  if ( !v9 )
  {
    if ( lpSubKey && *lpSubKey )
    {
      v9 = RegOpenKeyExA(hKey, lpSubKey, 0, 1u, &hKey);
      if ( !v9 )
      {
        v9 = QueryValueInternalA(hKey, lpValueName, v8, a5, (LPBYTE)Dst, v7);
        RegCloseKey(hKey);
      }
    }
    else
    {
      v9 = QueryValueInternalA(hKey, lpValueName, v8, a5, (LPBYTE)Dst, v7);
    }
  }
  ZeroDataOnFailure(v8, Dst, Size, v9);
  return v9;
}

//----- (77E143F3) --------------------------------------------------------
int __stdcall QueryValueInternalA(HKEY hKey, LPCSTR lpValueName, int a3, int a4, LPBYTE lpData, DWORD Type)
{
  DWORD v6; // esi@1
  ULONG v7; // ebx@2
  DWORD *v8; // edi@3
  int v9; // eax@5
  signed int v10; // eax@5
  int v12; // [sp+Ch] [bp-4h]@1

  v6 = Type;
  v12 = 0;
  if ( lpData )
    v7 = *(_DWORD *)Type;
  else
    v7 = 0;
  v8 = (DWORD *)a4;
  if ( !a4 )
    v8 = &Type;
  if ( !Type )
    v6 = (DWORD)&v12;
  v9 = RegQueryValueExA(hKey, lpValueName, 0, v8, lpData, (LPDWORD)v6);
  v10 = FixRegData(hKey, (LPCWSTR)lpValueName, a3, (int)v8, (int)lpData, v6 != (_DWORD)&v12 ? v6 : 0, v7, v9, 1);
  return RestrictRegType(a3, *v8, *(_DWORD *)v6, v10);
}

//----- (77E14470) --------------------------------------------------------
HANDLE __stdcall CreateEventExAStub(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateEventExA(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
}

//----- (77E144DD) --------------------------------------------------------
DWORD __stdcall WTSGetActiveConsoleSessionId()
{
  return v7FFE02D8;
}

//----- (77E1463A) --------------------------------------------------------
void __usercall sub_77E1463A(int a1@<eax>, int a2@<edx>, char a3@<cl>, int a4@<ebp>, int a5@<esi>)
{
  int v5; // edi@1
  int v6; // eax@1
  char v7; // cl@4
  bool v8; // zf@7

  v5 = *(_DWORD *)(a4 - 3520);
  v6 = a1 + 1;
  ++*(_DWORD *)(a4 - 3524);
  ++*(_DWORD *)(a4 - 3520);
  *(_BYTE *)v5 = a3 & 0x3F;
  if ( a2 & 1 )
    *(_BYTE *)v6 = 32;
  while ( a2 > 0 )
  {
    v7 = *(_BYTE *)a5 - *(_BYTE *)(a4 - 3464) + 2;
    if ( a2 & 1 )
      *(_BYTE *)v6++ |= v7;
    else
      *(_BYTE *)v6 = 16 * v7;
    a5 += 2;
    JUMPOUT(*(_WORD *)(a4 - 3468), 0, &loc_77E570FC);
    --a2;
  }
  *(_BYTE *)v6 = -2 - *(_BYTE *)(a4 - 3472);
  v8 = *(_WORD *)(a4 - 3468) == 0;
  *(_DWORD *)(a4 - 3528) = v6 + 1;
  JUMPOUT(v8, &loc_77E27CEF);
  JUMPOUT(&loc_77E57103);
}

//----- (77E1488E) --------------------------------------------------------
BOOL __stdcall GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
{
  int v3; // eax@1
  BOOL result; // eax@3

  v3 = NlsValidateLocale(&Locale, 0);
  if ( lpVersionInformation && v3 )
  {
    result = GetNLSVersionHelper(Function, v3, (int)lpVersionInformation);
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);

//----- (77E148C9) --------------------------------------------------------
signed int __stdcall GetNLSVersionHelper(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edx@4

  v3 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 != 12 && v3 != 32 )
  {
    SetLastError(0x7Au);
    return 0;
  }
  if ( a1 != 1 )
  {
    SetLastError(0x3ECu);
    return 0;
  }
  if ( (*(_DWORD *)a2 >> 16) & 0xF )
    v4 = *(_DWORD *)a2;
  else
    v4 = *(_DWORD *)(*(_DWORD *)(a2 + 16) + 232);
  *(_DWORD *)(a3 + 8) = 393473;
  *(_DWORD *)(a3 + 4) = 393473;
  if ( v3 == 32 )
  {
    *(_DWORD *)(a3 + 16) = 0;
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a3 + 24) = 0;
    *(_DWORD *)(a3 + 12) = v4;
    *(_DWORD *)(a3 + 28) = 0;
  }
  return 1;
}

//----- (77E1493D) --------------------------------------------------------
BOOL __stdcall SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
{
  DWORD v2; // eax@1
  NTSTATUS v3; // eax@3
  BOOL result; // eax@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-10h]@3
  DWORD v6; // [sp+8h] [bp-8h]@3
  int v7; // [sp+Ch] [bp-4h]@2

  v2 = -1;
  if ( lReadTimeout == -1 )
  {
    v7 = -1;
  }
  else
  {
    v2 = -10000 * lReadTimeout;
    v7 = -10000i64 * (unsigned __int64)lReadTimeout >> 32;
  }
  v6 = v2;
  lReadTimeout = (DWORD)&v6;
  v3 = NtSetInformationFile(hMailslot, &IoStatusBlock, &lReadTimeout, 4u, FileMailslotSetInformation);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E14996) --------------------------------------------------------
DWORD __stdcall GetActiveProcessorCount(WORD GroupNumber)
{
  DWORD result; // eax@1
  PVOID v2; // esi@2
  int v3; // ecx@3
  char *v4; // eax@4
  char v5; // [sp+0h] [bp-8h]@1
  PVOID Address; // [sp+4h] [bp-4h]@1
  int GroupNumbera; // [sp+10h] [bp+8h]@3

  result = GetProcessorGroupInformation((int)&Address, (int)&v5);
  if ( result )
  {
    v2 = Address;
    if ( GroupNumber == -1 )
    {
      v3 = *((_WORD *)Address + 5);
      GroupNumbera = 0;
      if ( *((_WORD *)Address + 5) )
      {
        v4 = (char *)Address + 33;
        do
        {
          LOWORD(GroupNumbera) = (unsigned __int8)*v4 + (_WORD)GroupNumbera;
          v4 += 44;
          --v3;
        }
        while ( v3 );
      }
    }
    else if ( GroupNumber >= *((_WORD *)Address + 5) )
    {
      GroupNumbera = 0;
      RtlSetLastWin32Error(87);
    }
    else
    {
      GroupNumbera = *((_BYTE *)Address + 44 * GroupNumber + 33);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
    result = (unsigned __int16)GroupNumbera;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E14A04) --------------------------------------------------------
signed int __stdcall GetProcessorGroupInformation(int a1, int a2)
{
  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *v2; // esi@3
  ULONG v3; // ecx@5
  ULONG Size; // [sp+0h] [bp-4h]@1

  Size = 0;
  if ( GetLogicalProcessorInformationEx(RelationGroup, 0, &Size) )
  {
    RtlSetLastWin32Error(13);
    return 0;
  }
  if ( GetLastError() != 122 )
    return 0;
  v2 = (struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *)RtlAllocateHeap(
                                                            NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                                            0,
                                                            Size);
  if ( v2 )
  {
    if ( GetLogicalProcessorInformationEx(RelationGroup, v2, &Size) )
    {
      v3 = Size;
      *(_DWORD *)a1 = v2;
      *(_DWORD *)a2 = v3;
      return 1;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E14A8C) --------------------------------------------------------
DWORD __stdcall QueryDosDeviceWStub(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
{
  return QueryDosDeviceW(lpDeviceName, lpTargetPath, ucchMax);
}

//----- (77E14AEF) --------------------------------------------------------
BOOL __stdcall BasepDisableLocalFileBuffering(HANDLE FileHandle)
{
  BOOL v1; // ebx@1
  HANDLE v2; // eax@1
  NTSTATUS v3; // eax@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-18h]@1
  int v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+18h] [bp-Ch]@1
  HANDLE hObject; // [sp+1Ch] [bp-8h]@1
  DWORD NumberOfBytesTransferred; // [sp+20h] [bp-4h]@1

  IoStatusBlock.u.Status = 0;
  IoStatusBlock.Information = 0;
  v6 = 0;
  v7 = 0;
  v1 = 1;
  NumberOfBytesTransferred = 0;
  v2 = CreateEventA(0, 1, 0, 0);
  hObject = v2;
  if ( v2 )
  {
    IoStatusBlock.u.Status = 259;
    v3 = NtFsControlFile(
           FileHandle,
           v2,
           0,
           (PVOID)(((unsigned __int8)v2 & 1) == 0 ? (unsigned int)&IoStatusBlock : 0),
           &IoStatusBlock,
           0x140390u,
           0,
           0,
           0,
           0);
    if ( v3 < 0 )
    {
      v1 = 0;
    }
    else if ( v3 == 259 )
    {
      v1 = GetOverlappedResult(FileHandle, (LPOVERLAPPED)&IoStatusBlock, &NumberOfBytesTransferred, 1);
    }
    if ( hObject )
      CloseHandle(hObject);
  }
  else
  {
    v1 = 0;
  }
  return v1;
}

//----- (77E14B80) --------------------------------------------------------
int __stdcall BasepRemoteIsSMBv1(HANDLE FileHandle)
{
  signed int v1; // esi@1
  char FileInformation; // [sp+4h] [bp-74h]@1
  int v4; // [sp+8h] [bp-70h]@2
  __int16 v5; // [sp+Ch] [bp-6Ch]@3

  v1 = 0;
  if ( GetFileInformationByHandleEx(FileHandle, 13, &FileInformation, 0x74u) && v4 == 0x20000 && v5 == 1 )
    v1 = 1;
  return v1;
}

//----- (77E14C8A) --------------------------------------------------------
int __stdcall BasepEnableRemotePrefetch(HANDLE FileHandle)
{
  HANDLE v1; // eax@1
  NTSTATUS v2; // eax@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-20h]@1
  int v5; // [sp+14h] [bp-18h]@1
  int v6; // [sp+18h] [bp-14h]@1
  HANDLE hObject; // [sp+1Ch] [bp-10h]@1
  DWORD NumberOfBytesTransferred; // [sp+20h] [bp-Ch]@1
  int v9; // [sp+24h] [bp-8h]@1
  char InputBuffer; // [sp+28h] [bp-4h]@1
  char v11; // [sp+29h] [bp-3h]@1

  IoStatusBlock.u.Status = 0;
  IoStatusBlock.Information = 0;
  v5 = 0;
  v6 = 0;
  NumberOfBytesTransferred = 0;
  v9 = 0;
  InputBuffer = 7;
  v11 = 22;
  v1 = CreateEventA(0, 1, 0, 0);
  hObject = v1;
  if ( v1 )
  {
    IoStatusBlock.u.Status = 259;
    v2 = NtFsControlFile(
           FileHandle,
           v1,
           0,
           (PVOID)(((unsigned __int8)v1 & 1) == 0 ? (unsigned int)&IoStatusBlock : 0),
           &IoStatusBlock,
           0x1401C4u,
           &InputBuffer,
           2u,
           0,
           0);
    if ( v2 >= 0 )
    {
      if ( v2 == 259 )
        v9 = GetOverlappedResult(FileHandle, (LPOVERLAPPED)&IoStatusBlock, &NumberOfBytesTransferred, 1);
      else
        v9 = 1;
    }
    if ( hObject )
      CloseHandle(hObject);
  }
  return v9;
}

//----- (77E14D38) --------------------------------------------------------
LSTATUS __stdcall RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
  int (__stdcall *v3)(_DWORD, _DWORD, _DWORD); // ebx@1
  HKEY v4; // esi@11
  int v5; // eax@11
  signed int v6; // esi@11
  int v7; // esi@21
  int v8; // edi@21
  int v9; // eax@21
  LSTATUS result; // eax@21
  NTSTATUS v11; // eax@35
  PVOID Address; // [sp+10h] [bp-48h]@16
  int v13; // [sp+20h] [bp-38h]@35
  int v14; // [sp+24h] [bp-34h]@35
  int v15; // [sp+28h] [bp-30h]@1
  int v16; // [sp+2Ch] [bp-2Ch]@1
  HKEY v17; // [sp+30h] [bp-28h]@1
  int v18; // [sp+34h] [bp-24h]@1
  HANDLE Handle; // [sp+38h] [bp-20h]@1
  LSTATUS v20; // [sp+3Ch] [bp-1Ch]@11
  CPPEH_RECORD ms_exc; // [sp+40h] [bp-18h]@26

  v17 = 0;
  Handle = 0;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v3 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 108);
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  if ( hKey == HKEY_CLASSES_ROOT )
  {
    v18 = 1;
  }
  else if ( hKey != HKEY_CURRENT_USER
         && hKey != HKEY_LOCAL_MACHINE
         && hKey != HKEY_PERFORMANCE_TEXT
         && hKey != HKEY_PERFORMANCE_NLSTEXT
         && hKey != HKEY_USERS
         && hKey != HKEY_CURRENT_CONFIG
         && hKey != HKEY_DYN_DATA
         && hKey != HKEY_CURRENT_USER_LOCAL_SETTINGS )
  {
    goto LABEL_11;
  }
  if ( !(SecurityInformation & 8) )
  {
LABEL_11:
    v4 = hKey;
    v5 = RegKrnGetGlobalState();
    v20 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v5 + 176))(v4, &hKey, &v15, &v16);
    v6 = 0x2000000;
    goto LABEL_12;
  }
  v6 = 50331648;
  if ( SecurityInformation & 4 )
  {
    v6 = 50593792;
  }
  else if ( SecurityInformation & 1 )
  {
    v6 = 50855936;
  }
  result = OpenPredefinedKeyForSpecialAccess((int)hKey, v6, (PHANDLE)&hKey);
  v20 = result;
  if ( !result )
  {
    v17 = hKey;
LABEL_12:
    if ( !v20 )
    {
      if ( (unsigned __int8)hKey & 1 || !((unsigned __int8)hKey & 2) && !v18 )
      {
LABEL_16:
        Address = 0;
        v20 = MapSDToRpcSD(pSecurityDescriptor, (int)&Address);
        if ( !v20 )
        {
          if ( (unsigned __int8)hKey & 1 )
          {
            if ( v3 )
            {
              ms_exc.registration.TryLevel = 0;
              v20 = v3((unsigned int)hKey & 0xFFFFFFFE, SecurityInformation, &Address);
              ms_exc.registration.TryLevel = -2;
            }
          }
          else
          {
            v20 = LocalBaseRegSetKeySecurity(hKey, SecurityInformation, (int)&Address);
          }
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
          if ( Handle )
            NtClose(Handle);
        }
        goto LABEL_20;
      }
      v11 = BaseRegGetUserAndMachineClass(0, hKey, v6, (int)&v14, (int)&v13);
      if ( v11 >= 0 )
      {
        if ( v14 && v13 )
        {
          Handle = (HANDLE)v14;
          if ( (HKEY)v14 == hKey )
            Handle = (HANDLE)v13;
          hKey = (HKEY)v14;
          if ( !v18 )
            hKey = (HKEY)v13;
        }
        goto LABEL_16;
      }
      v20 = RtlNtStatusToDosError(v11);
    }
LABEL_20:
    if ( v17 )
      RegCloseKey(v17);
    v7 = v16;
    v8 = v15;
    v9 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v9 + 168))(v8, v7);
    result = v20;
  }
  return result;
}

//----- (77E14EC1) --------------------------------------------------------
int __stdcall LocalBaseRegSetKeySecurity(HANDLE Handle, SECURITY_INFORMATION RequiredInformation, int a3)
{
  signed int v3; // ebx@7
  void (__stdcall *v5)(_DWORD, _DWORD, _DWORD); // [sp+4h] [bp-4h]@1

  v5 = *(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 24);
  if ( a3 && *(_DWORD *)a3 )
  {
    if ( Handle == (HANDLE)-2147483644 || Handle == (HANDLE)-2147483568 || Handle == (HANDLE)-2147483552 )
    {
      v3 = -1073741816;
    }
    else
    {
      if ( !RtlValidRelativeSecurityDescriptor(*(PSECURITY_DESCRIPTOR *)a3, *(_DWORD *)(a3 + 4), RequiredInformation) )
      {
        v3 = -1073741811;
        return RtlNtStatusToDosError(v3);
      }
      v3 = NtSetSecurityObject(Handle, RequiredInformation, *(PSECURITY_DESCRIPTOR *)a3);
    }
    if ( v3 >= 0 )
    {
      if ( v5 )
        v5(Handle, RequiredInformation, *(_DWORD *)a3);
    }
    return RtlNtStatusToDosError(v3);
  }
  return 87;
}

//----- (77E14F50) --------------------------------------------------------
BOOL __stdcall GetQueuedCompletionStatusStub(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
{
  return GetQueuedCompletionStatus(
           CompletionPort,
           lpNumberOfBytesTransferred,
           lpCompletionKey,
           lpOverlapped,
           dwMilliseconds);
}

//----- (77E14F68) --------------------------------------------------------
BOOL __stdcall PostQueuedCompletionStatusStub(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
{
  return PostQueuedCompletionStatus(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
}

//----- (77E14FB3) --------------------------------------------------------
HANDLE __stdcall OpenFileById(int a1, int a2, HANDLE FileHandle, ULONG ShareAccess, int a5, int a6)
{
  int v6; // ecx@3
  signed __int16 v7; // ax@4
  unsigned int v8; // eax@5
  HANDLE v9; // ecx@5
  NTSTATUS v10; // eax@8
  signed __int16 v12; // [sp-4h] [bp-30h]@4
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-28h]@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-10h]@8
  __int16 v15; // [sp+24h] [bp-8h]@5
  __int16 v16; // [sp+26h] [bp-6h]@5
  int v17; // [sp+28h] [bp-4h]@4

  if ( !a2 || *(_DWORD *)a2 < 0x18u )
    goto LABEL_11;
  v6 = *(_DWORD *)(a2 + 4);
  if ( v6 )
  {
    if ( v6 == 1 )
    {
      v17 = a2 + 8;
      v7 = 16;
      v12 = 16;
      goto LABEL_5;
    }
LABEL_11:
    RtlSetLastWin32Error(87);
    return (HANDLE)-1;
  }
  v17 = a2 + 8;
  v7 = 8;
  v12 = 8;
LABEL_5:
  v15 = v7;
  v16 = v12;
  ObjectAttributes.RootDirectory = (HANDLE)a1;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&v15;
  ObjectAttributes.Length = 24;
  v8 = ~((unsigned int)a6 >> 25) & 0x20 | ((a6 & 0x2000000 | ((a6 & 0x10000000 | ((a6 & 0x8000000 | ((a6 & 0x20000000 | ((unsigned int)a6 >> 4) & 0x8000000) >> 1)) >> 8)) >> 6)) >> 11);
  v9 = FileHandle;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  if ( a6 & 0x4000000 )
  {
    v8 |= 0x1000u;
    v9 = (HANDLE)((unsigned int)FileHandle | 0x10000);
  }
  if ( a6 & 0x200000 )
    v8 |= 0x200000u;
  if ( a6 & 0x100000 )
    v8 |= 0x400000u;
  v10 = NtCreateFile(
          &FileHandle,
          (unsigned int)v9 | 0x100080,
          &ObjectAttributes,
          &IoStatusBlock,
          0,
          0,
          ShareAccess,
          1u,
          v8 | 0x2000,
          0,
          0);
  if ( v10 < 0 )
  {
    FileHandle = (HANDLE)-1;
    BaseSetLastNTError(v10);
  }
  return FileHandle;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E150DB) --------------------------------------------------------
DWORD __stdcall GetFinalPathNameByHandleWStub(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
{
  return GetFinalPathNameByHandleW(hFile, lpszFilePath, cchFilePath, dwFlags);
}

//----- (77E150F3) --------------------------------------------------------
SIZE_T __stdcall VirtualQueryExStub(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
{
  return VirtualQueryEx(hProcess, lpAddress, lpBuffer, dwLength);
}

//----- (77E1510B) --------------------------------------------------------
BOOL __stdcall CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
{
  PBOOL v2; // esi@2
  NTSTATUS v3; // eax@3

  if ( hProcess && (v2 = pbDebuggerPresent) != 0 )
  {
    v3 = NtQueryInformationProcess(hProcess, ProcessDebugPort, &hProcess, 4u, 0);
    if ( v3 >= 0 )
    {
      *v2 = hProcess != 0;
      return 1;
    }
    BaseSetLastNTError(v3);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1515D) --------------------------------------------------------
BOOL __stdcall SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
{
  BOOL v2; // esi@1
  NTSTATUS v3; // eax@1
  DWORD SystemInformation; // [sp+4h] [bp-8h]@1
  char v6; // [sp+8h] [bp-4h]@1

  SystemInformation = dwTimeAdjustment;
  v6 = bTimeAdjustmentDisabled;
  v2 = 1;
  v3 = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)28, &SystemInformation, 8u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    v2 = 0;
  }
  return v2;
}

//----- (77E151BE) --------------------------------------------------------
void __stdcall DisablePredefinedHandleTableInternal(unsigned int a1)
{
  unsigned int v1; // edi@1
  int v2; // eax@4

  v1 = 0;
  RtlRunOnceExecuteOnce(
    &PredefinedHandleTableCriticalSectionInit,
    (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
    0,
    0);
  RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
  if ( a1 )
  {
    v2 = MapPredefinedRegistryHandleToIndex(a1);
    DisablePredefinedHandleTableForIndex(v2);
  }
  else
  {
    do
      DisablePredefinedHandleTableForIndex(v1++);
    while ( v1 < 0xA );
  }
  RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
}

//----- (77E1520C) --------------------------------------------------------
void __stdcall DisablePredefinedHandleTableForIndex(int a1)
{
  int v1; // esi@1
  int v2; // ebx@5

  v1 = 4 * a1;
  if ( byte_77EA6B2C[16 * a1] != 1 )
  {
    if ( PredefinedHandleTable[v1] )
    {
      LocalBaseRegCloseKey(&PredefinedHandleTable[v1]);
      v2 = dword_77EA6B24[v1];
      if ( !*(_DWORD *)(v2 + 4) )
      {
        dword_77EA6B24[v1] = RemoveUnitFromList(v2, dword_77EA6B24[v1]);
        FreePredefinedHandleUnit((PVOID)v2);
      }
    }
    PredefinedHandleTable[v1] = 0;
    byte_77EA6B2C[v1 * 4] = 1;
  }
}
// 77EA6B20: using guessed type int PredefinedHandleTable[];
// 77EA6B24: using guessed type int dword_77EA6B24[];

//----- (77E152A6) --------------------------------------------------------
int __stdcall GetLocaleInfoExStub(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
{
  return GetLocaleInfoEx(lpLocaleName, LCType, lpLCData, cchData);
}

//----- (77E152DE) --------------------------------------------------------
LPVOID __stdcall CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
{
  NTSTATUS v5; // eax@2
  int v6; // eax@3
  PVOID v7; // esi@3
  NTSTATUS v8; // eax@4
  int v9; // ecx@5
  char v11; // [sp+8h] [bp-18h]@4
  int v12; // [sp+10h] [bp-10h]@5
  int v13; // [sp+14h] [bp-Ch]@5
  int v14; // [sp+18h] [bp-8h]@5
  int v15; // [sp+1Ch] [bp-4h]@1

  v15 = 0;
  if ( dwFlags & 0xFFFFFFFE )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v5 = RtlAllocateActivationContextStack(&v15);
  if ( v5 < 0 )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  v6 = KernelBaseGetGlobalData();
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 0x2F4u);
  if ( v7 )
  {
    v8 = RtlCreateUserStack(
           dwStackCommitSize,
           dwStackReserveSize,
           0,
           *(_DWORD *)(BaseStaticServerData + 300),
           *(_DWORD *)(BaseStaticServerData + 316),
           &v11);
    if ( v8 >= 0 )
    {
      memset((char *)v7 + 20, 0, 0x2CCu);
      *(_DWORD *)v7 = lpParameter;
      *((_DWORD *)v7 + 2) = v12;
      *((_DWORD *)v7 + 3) = v13;
      v9 = v14;
      *((_DWORD *)v7 + 1) = -1;
      *((_DWORD *)v7 + 4) = v9;
      *((_DWORD *)v7 + 184) = 0;
      *((_DWORD *)v7 + 186) = 0;
      *((_DWORD *)v7 + 187) = 0;
      *((_WORD *)v7 + 376) = 0;
      *((_DWORD *)v7 + 185) = v15;
      *((_DWORD *)v7 + 5) = (dwFlags & 1) != 0 ? 0x10008 : 0;
      BaseInitializeFiberContext((int)((char *)v7 + 20), (int)lpParameter, (int)lpStartAddress, v12);
      return v7;
    }
    BaseSetLastNTError(v8);
    RtlFreeActivationContextStack(v15);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  }
  else
  {
    RtlFreeActivationContextStack(v15);
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1214: using guessed type int __stdcall RtlAllocateActivationContextStack(_DWORD);
// 77DE1218: using guessed type int __stdcall RtlFreeActivationContextStack(_DWORD);
// 77DE121C: using guessed type int __stdcall RtlCreateUserStack(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E153E3) --------------------------------------------------------
int __stdcall BaseInitializeFiberContext(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int result; // eax@3

  *(_DWORD *)(a1 + 176) = a3;
  v4 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 164) = a2;
  *(_DWORD *)(a1 + 148) = 32;
  *(_DWORD *)(a1 + 152) = 32;
  *(_DWORD *)(a1 + 200) = 32;
  *(_DWORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = 56;
  *(_DWORD *)(a1 + 188) = 24;
  *(_DWORD *)a1 = 65543;
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->Reserved2[0] & 8 )
    v5 = 4 * (__rdtsc() % (*(_DWORD *)(BaseStaticServerData + 300) >> 3));
  else
    v5 = 0;
  result = a4 - v5 - 8;
  *(_DWORD *)(a1 + 196) = result;
  *(_DWORD *)result = BaseFiberStart;
  *(_DWORD *)a1 |= v4;
  if ( v4 == 65544 )
  {
    *(_DWORD *)(a1 + 28) = 639;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = 0xFFFF;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 52) = 0;
    if ( v7FFE027A )
      *(_DWORD *)(a1 + 20) = 8064;
  }
  return result;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E15497) --------------------------------------------------------
void __stdcall __noreturn BaseFiberStart()
{
  char v0; // [sp+0h] [bp-8h]@1

  RtlInitializeExceptionChain(&v0);
  ((void (__stdcall *)())_BaseFiberStart)();
  __debugbreak();
  JUMPOUT(*(_DWORD *)byte_77E154AE);
}
// 77DE1634: using guessed type int __stdcall RtlInitializeExceptionChain(_DWORD);

//----- (77E1552C) --------------------------------------------------------
LPVOID __stdcall ConvertThreadToFiber(LPVOID lpParameter)
{
  return ConvertThreadToFiberEx(lpParameter, 0);
}

//----- (77E15544) --------------------------------------------------------
LPVOID __stdcall ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
{
  struct _TEB *v2; // esi@2
  int v3; // eax@3
  LPVOID result; // eax@3

  if ( dwFlags & 0xFFFFFFFE )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v2 = NtCurrentTeb();
  if ( BYTE2(v2[1].ProcessEnvironmentBlock) & 4 )
  {
    RtlSetLastWin32Error(1280);
    return 0;
  }
  v3 = KernelBaseGetGlobalData();
  result = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 0x2F4u);
  if ( !result )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  *(_DWORD *)result = lpParameter;
  *((_DWORD *)result + 2) = v2->Reserved1[1];
  *((_DWORD *)result + 3) = v2->Reserved1[2];
  *((_DWORD *)result + 4) = *(_DWORD *)&v2->Reserved3[1948];
  *((_DWORD *)result + 1) = v2->Reserved1[0];
  *((_DWORD *)result + 186) = v2[1].Reserved1[7];
  *((_DWORD *)result + 187) = v2->Reserved5[24];
  *((_WORD *)result + 376) = HIWORD(v2[1].ProcessEnvironmentBlock) & 0x200;
  *((_DWORD *)result + 185) = v2->Reserved2[93];
  *((_DWORD *)result + 5) = 65543;
  if ( dwFlags & 1 )
    *((_DWORD *)result + 5) = 65551;
  *((_DWORD *)result + 184) = 0;
  HIWORD(v2[1].ProcessEnvironmentBlock) |= 4u;
  v2->Reserved1[4] = result;
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E15620) --------------------------------------------------------
void __stdcall DeleteFiber(LPVOID lpFiber)
{
  struct _TEB *v1; // eax@1
  void *v2; // eax@3
  PVOID Address; // [sp+10h] [bp-1Ch]@3

  v1 = NtCurrentTeb();
  if ( BYTE2(v1[1].ProcessEnvironmentBlock) & 4 && v1->Reserved1[4] == lpFiber )
  {
    RtlExitUserThread(1);
    WerUnregisterMemoryBlock(lpFiber);
  }
  else
  {
    RtlFreeUserStack(*((_DWORD *)lpFiber + 4));
    v2 = (void *)*((_DWORD *)lpFiber + 186);
    Address = v2;
    if ( v2 )
    {
      RtlProcessFlsData(v2);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
    RtlFreeActivationContextStack(*((_DWORD *)lpFiber + 185));
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpFiber);
  }
}
// 77DE120C: using guessed type int __stdcall RtlFreeUserStack(_DWORD);
// 77DE1210: using guessed type int __stdcall RtlProcessFlsData(_DWORD);
// 77DE1218: using guessed type int __stdcall RtlFreeActivationContextStack(_DWORD);
// 77DE170C: using guessed type int __stdcall RtlExitUserThread(_DWORD);

//----- (77E156B9) --------------------------------------------------------
BOOL __stdcall ConvertFiberToThread()
{
  struct _TEB *v0; // eax@1
  void *v1; // ecx@2
  BOOL result; // eax@2

  v0 = NtCurrentTeb();
  if ( BYTE2(v0[1].ProcessEnvironmentBlock) & 4 )
  {
    HIWORD(v0[1].ProcessEnvironmentBlock) &= 0xFFFBu;
    v1 = v0->Reserved1[4];
    v0->Reserved1[4] = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(1281);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1570F) --------------------------------------------------------
int __stdcall LCIDToLocaleNameStub(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
{
  return LCIDToLocaleName(Locale, lpName, cchName, dwFlags);
}

//----- (77E1571C) --------------------------------------------------------
BOOL __stdcall GetSystemPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
{
  return GetSystemPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
}

//----- (77E15734) --------------------------------------------------------
int __stdcall ResolveLocaleNameStub(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
{
  return ResolveLocaleName(lpNameToResolve, lpLocaleName, cchLocaleName);
}

//----- (77E157B2) --------------------------------------------------------
BOOL __stdcall IsNLSDefinedStringStub(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
{
  return IsNLSDefinedString(Function, dwFlags, lpVersionInformation, lpString, cchStr);
}

//----- (77E157CA) --------------------------------------------------------
signed int __stdcall SortIsDefinedString(int a1, int a2, int a3, void *a4, signed int a5)
{
  int v5; // eax@1

  v5 = a5;
  if ( a5 && a4 )
  {
    if ( !a3 )
    {
      if ( a5 <= -1 )
        v5 = SortNlsStrLenW(a4);
      if ( a2 == 1 )
        return IsSortingCodePointDefined((signed int *)a4, v5);
    }
    SetLastError(0x3ECu);
  }
  else
  {
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E15813) --------------------------------------------------------
signed int __fastcall IsSortingCodePointDefined(signed int *a1, int a2)
{
  int v2; // esi@5
  unsigned __int16 v3; // dx@6
  signed int v4; // eax@6
  signed int result; // eax@12
  int v6; // eax@34
  bool v7; // cf@34
  bool v8; // zf@34
  int v9; // eax@41
  int v10; // eax@44
  int v11; // [sp+10h] [bp-4h]@4

  if ( (*pSortTblPtrs)[27] && (*pSortTblPtrs)[28] && (*pSortTblPtrs)[11] )
  {
    v11 = (int)((char *)a1 + 2 * a2);
    if ( (unsigned int)a1 < v11 )
    {
      v2 = (int)((char *)a1 + 2);
      do
      {
        v3 = *(_WORD *)a1;
        v4 = *(_WORD *)a1;
        if ( *(_BYTE *)((*pSortTblPtrs)[11] + 4 * v4 + 1) )
        {
          if ( v3 >= 0xE000u && v3 <= 0xF8FFu || v3 >= 0xDB80u && v3 <= 0xDBFFu || v3 >= 0xDC00u && v3 <= 0xDFFFu )
            goto LABEL_23;
          if ( v3 >= 0xD800u && v3 <= 0xDBFFu )
          {
            if ( v2 >= (unsigned int)v11 || *(_WORD *)v2 < 0xDC00u || *(_WORD *)v2 > 0xDFFFu )
              goto LABEL_23;
            a1 = (signed int *)((char *)a1 + 2);
            v2 += 2;
          }
        }
        else
        {
          if ( v4 > 8207 )
          {
            if ( v4 > 12689 )
            {
              if ( v4 < 65024 )
                goto LABEL_23;
              if ( v4 <= 65039 )
                goto LABEL_11;
              v10 = v4 - 65529;
              v7 = (unsigned int)v10 < 4;
              v8 = v10 == 4;
            }
            else
            {
              if ( v4 >= 12688 )
                goto LABEL_11;
              if ( v4 < 8234 )
                goto LABEL_23;
              if ( v4 <= 8238 )
                goto LABEL_11;
              if ( v4 <= 8287 )
                goto LABEL_23;
              if ( v4 <= 8292 )
                goto LABEL_11;
              v9 = v4 - 8298;
              v7 = (unsigned int)v9 < 5;
              v8 = v9 == 5;
            }
            goto LABEL_45;
          }
          if ( v4 >= 8204 )
            goto LABEL_11;
          if ( v4 > 1600 )
          {
            if ( v4 == 3788 || v4 == 6150 )
              goto LABEL_11;
            v6 = v4 - 6155;
            v7 = (unsigned int)v6 < 2;
            v8 = v6 == 2;
LABEL_45:
            if ( !v7 && !v8 )
              goto LABEL_23;
            goto LABEL_11;
          }
          if ( v4 != 1600 && *(_WORD *)a1 && v4 != 173 && v4 != 847 )
            goto LABEL_23;
        }
LABEL_11:
        a1 = (signed int *)((char *)a1 + 2);
        v2 += 2;
      }
      while ( (unsigned int)a1 < v11 );
    }
    result = 1;
  }
  else
  {
    SetLastError(2u);
LABEL_23:
    result = 0;
  }
  return result;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E158B9) --------------------------------------------------------
BOOL __stdcall TerminateJobObject(HANDLE hJob, UINT uExitCode)
{
  BOOL v2; // esi@1
  NTSTATUS v3; // eax@1

  v2 = 1;
  v3 = NtTerminateJobObject(hJob, uExitCode);
  if ( v3 < 0 )
  {
    v2 = 0;
    BaseSetLastNTError(v3);
  }
  return v2;
}

//----- (77E15925) --------------------------------------------------------
HANDLE __stdcall CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
{
  NTSTATUS v2; // eax@2
  HANDLE result; // eax@7
  char v4; // [sp+0h] [bp-24h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-Ch]@2
  HANDLE JobHandle; // [sp+20h] [bp-4h]@4

  if ( lpName )
  {
    RtlInitUnicodeString(&DestinationString, lpName);
    v2 = BaseFormatObjectAttributes((int)&v4, (int)lpJobAttributes, (int)&DestinationString, (int)&lpName);
  }
  else
  {
    v2 = BaseFormatObjectAttributes((int)&v4, (int)lpJobAttributes, 0, (int)&lpName);
  }
  if ( v2 < 0 || (v2 = NtCreateJobObject(&JobHandle, 0x1F001Fu, (POBJECT_ATTRIBUTES)lpName), v2 < 0) )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    if ( v2 == 0x40000000 )
      RtlSetLastWin32Error(183);
    else
      RtlSetLastWin32Error(0);
    result = JobHandle;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E15999) --------------------------------------------------------
BOOL __stdcall SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
{
  bool v4; // zf@3
  LPVOID v5; // esi@5
  NTSTATUS v6; // esi@7
  char Dst; // [sp+Ch] [bp-78h]@5
  char v9; // [sp+1Ch] [bp-68h]@5
  int v10; // [sp+30h] [bp-54h]@14
  int v11; // [sp+7Ch] [bp-8h]@1
  int v12; // [sp+80h] [bp-4h]@1

  v12 = -1073741823;
  v11 = 1;
  if ( JobObjectInformationClass == 2 )
  {
    v4 = cbJobObjectInformationLength == 48;
LABEL_4:
    if ( !v4 )
    {
      BaseSetLastNTError(-1073741820);
      return 0;
    }
    v5 = &Dst;
    memcpy(&Dst, lpJobObjectInformation, cbJobObjectInformationLength);
    if ( !(v9 & 0x20) )
      goto LABEL_6;
    if ( v10 != 32 )
    {
      if ( v10 == 64 )
      {
        v10 = 1;
        goto LABEL_6;
      }
      if ( v10 == 128 )
      {
        v10 = 3;
        goto LABEL_6;
      }
      if ( v10 == 256 )
      {
        v10 = 4;
        goto LABEL_6;
      }
      if ( v10 == 0x4000 )
      {
        v10 = 5;
        goto LABEL_6;
      }
      if ( v10 == 0x8000 )
      {
        v10 = 6;
        goto LABEL_6;
      }
    }
    v10 = 2;
LABEL_6:
    if ( v9 & 1 )
    {
      v12 = 14;
      v12 = RtlAcquirePrivilege(&v12, 1, 0, &lpJobObjectInformation);
    }
    goto LABEL_7;
  }
  if ( JobObjectInformationClass == 9 )
  {
    v4 = cbJobObjectInformationLength == 112;
    goto LABEL_4;
  }
  v5 = lpJobObjectInformation;
LABEL_7:
  v6 = NtSetInformationJobObject(hJob, JobObjectInformationClass, v5, cbJobObjectInformationLength);
  if ( v12 >= 0 )
  {
    RtlReleasePrivilege(lpJobObjectInformation);
    lpJobObjectInformation = 0;
  }
  if ( v6 < 0 )
  {
    v11 = 0;
    BaseSetLastNTError(v6);
  }
  return v11;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E15A51) --------------------------------------------------------
NTSTATUS __stdcall BaseGetNamedObjectDirectory(int a1)
{
  NTSTATUS result; // eax@2
  NTSTATUS v2; // esi@19
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-34h]@7
  int v4; // [sp+1Ch] [bp-1Ch]@4
  int v5; // [sp+20h] [bp-18h]@4
  int ThreadInformation; // [sp+24h] [bp-14h]@19
  HANDLE Handle; // [sp+28h] [bp-10h]@21
  HANDLE DirectoryHandle; // [sp+2Ch] [bp-Ch]@7
  NTSTATUS v9; // [sp+30h] [bp-8h]@7
  HANDLE TokenHandle; // [sp+34h] [bp-4h]@6

  if ( BaseNamedObjectDirectory )
  {
    *(_DWORD *)a1 = BaseNamedObjectDirectory;
    return 0;
  }
  v4 = *(_DWORD *)(BaseStaticServerData + 16);
  v5 = *(_DWORD *)(BaseStaticServerData + 20);
  if ( !(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved2[0] & 2)
    || (result = BaseVerifyUnicodeString((int)&v4), result >= 0) )
  {
    if ( NtCurrentTeb()[1].Reserved1[1] )
    {
      result = NtOpenThreadToken((HANDLE)0xFFFFFFFE, 4u, 1u, &TokenHandle);
      if ( result < 0 )
        return result;
      ThreadInformation = 0;
      v2 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &ThreadInformation, 4u);
      if ( v2 < 0 )
      {
        NtClose(TokenHandle);
        return v2;
      }
    }
    else
    {
      TokenHandle = 0;
    }
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v4;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v9 = NtOpenDirectoryObject(&DirectoryHandle, 0xFu, &ObjectAttributes);
    if ( v9 >= 0
      || (v9 = NtOpenDirectoryObject(&Handle, 2u, &ObjectAttributes), v9 >= 0)
      && (ObjectAttributes.RootDirectory = Handle,
          ObjectAttributes.Length = 24,
          ObjectAttributes.Attributes = 64,
          ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E5C984,
          ObjectAttributes.SecurityDescriptor = 0,
          ObjectAttributes.SecurityQualityOfService = 0,
          v9 = NtOpenDirectoryObject(&DirectoryHandle, 0xFu, &ObjectAttributes),
          NtClose(Handle),
          v9 >= 0) )
    {
      if ( InterlockedCompareExchange(&BaseNamedObjectDirectory, (LONG)DirectoryHandle, 0) )
        NtClose(DirectoryHandle);
      *(_DWORD *)a1 = BaseNamedObjectDirectory;
    }
    if ( TokenHandle )
    {
      NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &TokenHandle, 4u);
      NtClose(TokenHandle);
    }
    result = v9;
  }
  return result;
}
// 77E5C984: using guessed type int dword_77E5C984;
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E15A7A) --------------------------------------------------------
BOOL __stdcall RemoveDirectoryWStub(LPCWSTR lpPathName)
{
  return RemoveDirectoryW(lpPathName);
}

//----- (77E15ABF) --------------------------------------------------------
BOOL __stdcall CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
  return CreateProcessInternalW(
           hToken,
           lpApplicationName,
           lpCommandLine,
           (int)lpProcessAttributes,
           (int)lpThreadAttributes,
           bInheritHandles,
           dwCreationFlags,
           (int)lpEnvironment,
           lpCurrentDirectory,
           (int)lpStartupInfo,
           (int)lpProcessInformation,
           0);
}

//----- (77E15BDE) --------------------------------------------------------
BOOL __stdcall AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
{
  BOOL v2; // esi@1
  NTSTATUS v3; // eax@1

  v2 = 1;
  v3 = NtAssignProcessToJobObject(hJob, hProcess);
  if ( v3 < 0 )
  {
    v2 = 0;
    BaseSetLastNTError(v3);
  }
  return v2;
}

//----- (77E15C12) --------------------------------------------------------
BOOL __stdcall UnregisterWaitExStub(HANDLE WaitHandle, HANDLE CompletionEvent)
{
  return UnregisterWaitEx(WaitHandle, CompletionEvent);
}

//----- (77E15C2A) --------------------------------------------------------
BOOL __stdcall ChangeTimerQueueTimerStub(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
{
  return ChangeTimerQueueTimer(TimerQueue, Timer, DueTime, Period);
}

//----- (77E15C42) --------------------------------------------------------
HANDLE __stdcall CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  HANDLE v4; // esi@2
  HANDLE result; // eax@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName) )
  {
    v4 = CreateMailslotW(UnicodeString.Buffer, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
    RtlFreeUnicodeString(&UnicodeString);
    result = v4;
  }
  else
  {
    result = (HANDLE)-1;
  }
  return result;
}

//----- (77E15C87) --------------------------------------------------------
HANDLE __stdcall CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  NTSTATUS v4; // eax@5
  NTSTATUS v5; // edi@5
  HANDLE result; // eax@8
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-38h]@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-20h]@5
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-18h]@1
  LARGE_INTEGER ReadTimeout; // [sp+2Ch] [bp-10h]@4
  PWSTR shortname; // [sp+34h] [bp-8h]@1
  HANDLE FileHandle; // [sp+38h] [bp-4h]@5
  PWCH lpNamea; // [sp+44h] [bp+8h]@2

  RtlInitUnicodeString(&DestinationString, lpName);
  if ( RtlDosPathNameToNtPathName_U((PWSTR)lpName, &DestinationString, &shortname, 0) )
  {
    lpNamea = DestinationString.Buffer;
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( lpSecurityAttributes )
    {
      ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
      if ( lpSecurityAttributes->bInheritHandle )
        ObjectAttributes.Attributes = 66;
    }
    if ( lReadTimeout == -1 )
      ReadTimeout = (LARGE_INTEGER)-1i64;
    else
      ReadTimeout = (LARGE_INTEGER)(-10000i64 * lReadTimeout);
    v4 = NtCreateMailslotFile(
           &FileHandle,
           0x80140000,
           &ObjectAttributes,
           &IoStatusBlock,
           2u,
           0,
           nMaxMessageSize,
           &ReadTimeout);
    v5 = v4;
    if ( v4 == -1073741637 || v4 == -1073741808 )
      v5 = -1073741773;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpNamea);
    if ( v5 < 0 )
    {
      BaseSetLastNTError(v5);
      result = (HANDLE)-1;
    }
    else
    {
      result = FileHandle;
    }
  }
  else
  {
    RtlSetLastWin32Error(3);
    result = (HANDLE)-1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E15D9E) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
{
  return GetPrivateProfileStringW(0, 0, 0, lpszReturnBuffer, nSize, lpFileName);
}

//----- (77E15DCA) --------------------------------------------------------
NTSTATUS __stdcall BaseDllReadSectionNames(int a1)
{
  NTSTATUS result; // eax@1

  while ( 1 )
  {
    result = BaseDllAdvanceTextPointer(a1, 1);
    if ( result != 261 )
      break;
    result = BaseDllAppendStringToResultBuffer(a1, *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 164), 1);
    if ( result < 0 )
      return result;
  }
  if ( result == -2147483622 )
    result = 0;
  return result;
}

//----- (77E15E04) --------------------------------------------------------
BOOL __stdcall DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
{
  NTSTATUS v3; // eax@1
  unsigned int v4; // edi@2
  BOOL result; // eax@3
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-34h]@1
  unsigned __int16 v7; // [sp+10h] [bp-2Ch]@1
  __int16 v8; // [sp+12h] [bp-2Ah]@1
  void *Src; // [sp+14h] [bp-28h]@1
  __int16 v10; // [sp+18h] [bp-24h]@1

  v10 = 0;
  Src = &v10;
  v7 = 0;
  v8 = 32;
  RtlInitUnicodeString(&DestinationString, Hostname);
  v3 = RtlDnsHostNameToComputerName(&v7, &DestinationString, 0);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    v4 = (unsigned int)v7 >> 1;
    if ( *nSize < v4 + 1 )
    {
      BaseSetLastNTError(-2147483643);
      result = 0;
    }
    else
    {
      memcpy(ComputerName, Src, v7);
      ComputerName[v4] = 0;
      result = 1;
    }
    *nSize = (unsigned int)v7 >> 1;
  }
  return result;
}
// 77DE1598: using guessed type int __stdcall RtlDnsHostNameToComputerName(_DWORD, _DWORD, _DWORD);

//----- (77E15EA3) --------------------------------------------------------
BOOL __stdcall TzSpecificLocalTimeToSystemTimeStub(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
{
  return TzSpecificLocalTimeToSystemTime(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
}

//----- (77E15EBB) --------------------------------------------------------
int __stdcall BasepTpIoCallback(int a1, int a2, int a3, int a4, int a5)
{
  ULONG v5; // eax@2

  if ( *(_DWORD *)a4 < 0 )
    v5 = RtlNtStatusToDosError(*(_DWORD *)a4);
  else
    v5 = 0;
  return (*(int (__stdcall **)(int, _DWORD, int, ULONG, _DWORD, int))a2)(
           a1,
           *(_DWORD *)(a2 + 12),
           a3,
           v5,
           *(_DWORD *)(a4 + 4),
           a5);
}

//----- (77E15EEF) --------------------------------------------------------
BOOL __stdcall TrySubmitThreadpoolCallbackStub(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  return TrySubmitThreadpoolCallback(pfns, pv, pcbe);
}

//----- (77E15EFC) --------------------------------------------------------
BOOL __stdcall TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  int v3; // eax@1
  BOOL result; // eax@2

  v3 = TpSimpleTryPost(pfns, pv, pcbe);
  if ( v3 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1028: using guessed type int __stdcall TpSimpleTryPost(_DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E15F9B) --------------------------------------------------------
BOOL __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
{
  NTSTATUS v5; // eax@1
  BOOL result; // eax@2
  DWORD ThreadInformation; // [sp+0h] [bp-20h]@1
  DWORD v8; // [sp+4h] [bp-1Ch]@2
  DWORD v9; // [sp+8h] [bp-18h]@2
  DWORD v10; // [sp+Ch] [bp-14h]@2
  DWORD v11; // [sp+10h] [bp-10h]@2
  DWORD v12; // [sp+14h] [bp-Ch]@2
  DWORD v13; // [sp+18h] [bp-8h]@2
  DWORD v14; // [sp+1Ch] [bp-4h]@2

  v5 = NtQueryInformationThread(hThread, ThreadTimes, &ThreadInformation, 0x20u, 0);
  if ( v5 < 0 )
  {
    BaseSetLastNTError(v5);
    result = 0;
  }
  else
  {
    lpCreationTime->dwLowDateTime = ThreadInformation;
    lpCreationTime->dwHighDateTime = v8;
    lpExitTime->dwLowDateTime = v9;
    lpExitTime->dwHighDateTime = v10;
    lpKernelTime->dwLowDateTime = v11;
    lpKernelTime->dwHighDateTime = v12;
    lpUserTime->dwLowDateTime = v13;
    lpUserTime->dwHighDateTime = v14;
    result = 1;
  }
  return result;
}

//----- (77E16002) --------------------------------------------------------
int __stdcall K32GetModuleInformation(HANDLE ProcessHandle, int Buffer, int a3, int a4)
{
  char v5; // [sp+10h] [bp-A0h]@2
  int v6; // [sp+2Ch] [bp-84h]@3
  int v7; // [sp+30h] [bp-80h]@3
  int v8; // [sp+88h] [bp-28h]@3
  int v9; // [sp+8Ch] [bp-24h]@3
  int v10; // [sp+90h] [bp-20h]@3
  CPPEH_RECORD ms_exc; // [sp+98h] [bp-18h]@3

  if ( (unsigned int)a4 < 0xC )
  {
    SetLastError(0x7Au);
  }
  else if ( FindModule(ProcessHandle, Buffer, &v5) )
  {
    v8 = Buffer;
    v9 = v7;
    v10 = v6;
    *(_DWORD *)a3 = Buffer;
    *(_DWORD *)(a3 + 4) = v9;
    *(_DWORD *)(a3 + 8) = v10;
    ms_exc.registration.TryLevel = -2;
    return 1;
  }
  return 0;
}

//----- (77E1609C) --------------------------------------------------------
int __stdcall K32GetMappedFileNameA(HANDLE ProcessHandle, PVOID BaseAddress, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int v4; // esi@1
  HLOCAL v5; // eax@1
  const WCHAR *v6; // ebx@1
  int v7; // eax@2
  int result; // eax@5
  int cbMultiBytea; // [sp+20h] [bp+14h]@2

  v4 = cbMultiByte;
  v5 = LocalAlloc(0, 2 * cbMultiByte);
  v6 = (const WCHAR *)v5;
  if ( v5 )
  {
    v7 = K32GetMappedFileNameW(ProcessHandle, BaseAddress, v5, cbMultiByte);
    cbMultiBytea = v7;
    if ( v7 < (unsigned int)v4 )
      ++v7;
    if ( !WideCharToMultiByte(0, 0, v6, v7, lpMultiByteStr, v4, 0, 0) )
      cbMultiBytea = 0;
    LocalFree((HLOCAL)v6);
    result = cbMultiBytea;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E16101) --------------------------------------------------------
unsigned int __stdcall K32GetMappedFileNameW(HANDLE ProcessHandle, PVOID BaseAddress, void *Dst, int a4)
{
  NTSTATUS v4; // eax@2
  unsigned int v5; // esi@3
  unsigned int v6; // edi@3
  size_t v7; // edi@5
  DWORD v9; // ST14_4@9
  ULONG ReturnLength; // [sp+4h] [bp-218h]@2
  unsigned __int16 MemoryInformation; // [sp+8h] [bp-214h]@2
  void *Src; // [sp+Ch] [bp-210h]@5

  if ( !a4 )
  {
    SetLastError(0x7Au);
    return 0;
  }
  v4 = NtQueryVirtualMemory(ProcessHandle, BaseAddress, MemorySectionName, &MemoryInformation, 0x210u, &ReturnLength);
  if ( v4 < 0 )
  {
    v9 = RtlNtStatusToDosError(v4);
    SetLastError(v9);
    return 0;
  }
  v5 = (unsigned int)MemoryInformation >> 1;
  v6 = (unsigned int)MemoryInformation >> 1;
  if ( a4 < v5 + 1 )
  {
    v6 = a4 - 1;
    v5 = a4;
    SetLastError(0x7Au);
  }
  else
  {
    SetLastError(0);
  }
  v7 = 2 * v6;
  memcpy(Dst, Src, v7);
  *(_WORD *)((char *)Dst + v7) = 0;
  return v5;
}

//----- (77E161AF) --------------------------------------------------------
BOOL __stdcall GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
{
  return GetProcessWorkingSetSizeEx(
           hProcess,
           lpMinimumWorkingSetSize,
           lpMaximumWorkingSetSize,
           (PDWORD)&lpMaximumWorkingSetSize);
}

//----- (77E161CF) --------------------------------------------------------
BOOL __stdcall GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
{
  BOOL v4; // esi@1
  NTSTATUS v5; // eax@1
  char ProcessInformation; // [sp+4h] [bp-38h]@1
  ULONG_PTR v8; // [sp+Ch] [bp-30h]@2
  ULONG_PTR v9; // [sp+10h] [bp-2Ch]@2
  DWORD v10; // [sp+34h] [bp-8h]@2

  v4 = 1;
  v5 = NtQueryInformationProcess(hProcess, ProcessQuotaLimits, &ProcessInformation, 0x38u, 0);
  if ( v5 < 0 )
  {
    v4 = 0;
    BaseSetLastNTError(v5);
  }
  else
  {
    *lpMinimumWorkingSetSize = v8;
    *lpMaximumWorkingSetSize = v9;
    *Flags = v10;
  }
  return v4;
}

//----- (77E1621F) --------------------------------------------------------
int __stdcall K32GetPerformanceInfo(int a1, ULONG SystemInformationLength)
{
  NTSTATUS v2; // eax@2
  PVOID v3; // eax@12
  int v4; // esi@12
  int v5; // edi@12
  DWORD v6; // eax@13
  ULONG v7; // edx@15
  int v8; // edx@19
  int v9; // ecx@19
  DWORD v10; // eax@21
  int result; // eax@13
  DWORD v12; // eax@22
  SIZE_T v13; // [sp-10h] [bp-1B4h]@5
  char v14; // [sp+0h] [bp-1A4h]@3
  int v15; // [sp+2Ch] [bp-178h]@19
  int v16; // [sp+30h] [bp-174h]@19
  int v17; // [sp+34h] [bp-170h]@19
  int v18; // [sp+38h] [bp-16Ch]@19
  int v19; // [sp+70h] [bp-134h]@19
  int v20; // [sp+74h] [bp-130h]@19
  char v21; // [sp+148h] [bp-5Ch]@4
  int v22; // [sp+15Ch] [bp-48h]@19
  char SystemInformation; // [sp+16Ch] [bp-38h]@2
  int v24; // [sp+174h] [bp-30h]@19
  int v25; // [sp+178h] [bp-2Ch]@19
  NTSTATUS NtStatus; // [sp+198h] [bp-Ch]@7
  PVOID hMem; // [sp+19Ch] [bp-8h]@6
  ULONG ReturnLength; // [sp+1A0h] [bp-4h]@7
  signed int SystemInformationLengtha; // [sp+1B0h] [bp+Ch]@5
  ULONG SystemInformationLengthb; // [sp+1B0h] [bp+Ch]@12

  if ( SystemInformationLength < 0x38 )
  {
    v10 = RtlNtStatusToDosError(-1073741820);
    SetLastError(v10);
    result = 0;
  }
  else
  {
    v2 = NtQuerySystemInformation(0, &SystemInformation, 0x2Cu, 0);
    if ( v2 < 0
      || (v2 = NtQuerySystemInformation(SystemPerformanceInformation, &v14, 0x148u, 0), v2 < 0)
      || (v2 = NtQuerySystemInformation(SystemProcessInformation|0x10, &v21, 0x24u, 0), v2 < 0) )
    {
      v6 = RtlNtStatusToDosError(v2);
      SetLastError(v6);
      result = 0;
    }
    else
    {
      v13 = 4096;
      for ( SystemInformationLengtha = 4096; ; v13 = SystemInformationLengtha )
      {
        hMem = LocalAlloc(0, v13);
        if ( !hMem )
        {
          v12 = RtlNtStatusToDosError(-1073741670);
LABEL_24:
          SetLastError(v12);
          return 0;
        }
        NtStatus = NtQuerySystemInformation(SystemProcessInformation, hMem, SystemInformationLengtha, &ReturnLength);
        if ( NtStatus >= 0 )
          break;
        LocalFree(hMem);
        if ( NtStatus != -1073741820 )
        {
          v12 = RtlNtStatusToDosError(NtStatus);
          goto LABEL_24;
        }
        if ( ReturnLength <= SystemInformationLengtha )
          SystemInformationLengtha += 4096;
        else
          SystemInformationLengtha = ReturnLength;
      }
      SystemInformationLengthb = 0;
      v3 = hMem;
      v4 = 0;
      v5 = 0;
      while ( ReturnLength > 0xB8 )
      {
        v7 = *(_DWORD *)v3;
        ++SystemInformationLengthb;
        v4 += *((_DWORD *)v3 + 1);
        v5 += *((_DWORD *)v3 + 19);
        if ( !*(_DWORD *)v3 || v7 > ReturnLength )
          break;
        ReturnLength -= v7;
        v3 = (char *)v3 + *(_DWORD *)v3;
      }
      LocalFree(hMem);
      v8 = v19;
      *(_DWORD *)(a1 + 4) = v16;
      *(_DWORD *)(a1 + 8) = v17;
      *(_DWORD *)(a1 + 12) = v18;
      *(_DWORD *)(a1 + 16) = v25;
      *(_DWORD *)(a1 + 20) = v15;
      *(_DWORD *)(a1 + 24) = v22;
      v9 = v20;
      *(_DWORD *)(a1 + 36) = v20;
      *(_DWORD *)(a1 + 40) = v24;
      *(_DWORD *)a1 = 56;
      *(_DWORD *)(a1 + 28) = v9 + v8;
      *(_DWORD *)(a1 + 32) = v8;
      *(_DWORD *)(a1 + 44) = v5;
      *(_DWORD *)(a1 + 48) = SystemInformationLengthb;
      *(_DWORD *)(a1 + 52) = v4;
      result = 1;
    }
  }
  return result;
}

//----- (77E163F0) --------------------------------------------------------
int __stdcall SetProcessDEPPolicy(int ProcessInformation)
{
  char v1; // al@1
  NTSTATUS v2; // eax@4

  v1 = ProcessInformation;
  if ( ProcessInformation & 0xFFFFFFFC )
  {
    BaseSetLastNTError(-1073741811);
  }
  else
  {
    if ( ProcessInformation & 1 )
    {
      ProcessInformation = 9;
      if ( v1 & 2 )
        ProcessInformation = 13;
    }
    else
    {
      if ( ProcessInformation & 2 )
      {
        BaseSetLastNTError(-1073741776);
        return 0;
      }
      ProcessInformation = 2;
    }
    v2 = NtSetInformationProcess((HANDLE)0xFFFFFFFF, ProcessExecuteFlags, &ProcessInformation, 4u);
    if ( v2 >= 0 )
      return 1;
    BaseSetLastNTError(v2);
  }
  return 0;
}

//----- (77E16467) --------------------------------------------------------
HRESULT __stdcall StringCbCopyW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc)
{
  int v3; // edx@1
  HRESULT result; // eax@1

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || (unsigned int)v3 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    result = sub_77E2DB49((int)pszSrc, v3, (int)pszDest, 0, 2147483646);
  return result;
}

//----- (77E16591) --------------------------------------------------------
HRESULT __stdcall StringCbCatW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc)
{
  size_t v3; // edx@1
  HRESULT result; // eax@1
  int v5; // ecx@4
  size_t v6; // esi@4
  STRSAFE_LPWSTR v7; // eax@4
  HRESULT cbDesta; // [sp+14h] [bp+Ch]@4

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || v3 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result < 0 )
  {
    v5 = 0;
  }
  else
  {
    cbDesta = 0;
    v5 = 0;
    v6 = v3;
    v7 = pszDest;
    if ( !v3 )
      goto LABEL_18;
    do
    {
      if ( !*v7 )
        break;
      ++v7;
      --v6;
    }
    while ( v6 );
    if ( v6 )
      v5 = v3 - v6;
    else
LABEL_18:
      cbDesta = -2147024809;
    result = cbDesta;
  }
  if ( result >= 0 )
    result = sub_77E2DB49((int)pszSrc, v3 - v5, (int)&pszDest[v5], 0, 0x7FFFFFFF);
  return result;
}

//----- (77E1674B) --------------------------------------------------------
HANDLE __stdcall CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
{
  NTSTATUS v2; // eax@1
  HANDLE result; // eax@2
  UNICODE_STRING DestinationString; // [sp+0h] [bp-8h]@1

  v2 = RtlInitUnicodeStringEx(&DestinationString, Name);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = (HANDLE)RtlCreateBoundaryDescriptor(&DestinationString, Flags);
  }
  return result;
}
// 77DE1264: using guessed type int __stdcall RtlCreateBoundaryDescriptor(_DWORD, _DWORD);

//----- (77E1677D) --------------------------------------------------------
BOOL __stdcall AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = RtlAddSIDToBoundaryDescriptor(BoundaryDescriptor, RequiredSid);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1260: using guessed type int __stdcall RtlAddSIDToBoundaryDescriptor(_DWORD, _DWORD);

//----- (77E16814) --------------------------------------------------------
int __stdcall BaseDllReadSection(STRING *String1)
{
  int result; // eax@1
  int v2; // eax@4
  PCHAR v3; // eax@9
  int v4; // ecx@9
  int v5; // eax@16
  int v6; // ecx@16

  for ( result = BaseDllFindSection(String1);
        result >= 0;
        result = BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   *(_DWORD *)&String1[17].Length,
                   (int)String1[21].Buffer,
                   1) )
  {
    result = BaseDllAdvanceTextPointer((int)String1, 3);
    if ( result != 261 )
    {
      if ( result == -2147483622 )
        result = 0;
      return result;
    }
    v2 = (int)String1[16].Buffer;
    if ( v2 || *(_DWORD *)&String1[21].Length )
    {
      result = BaseDllAppendStringToResultBuffer((int)String1, v2, *(_DWORD *)&String1[21].Length, 0);
      if ( result < 0 )
        return result;
      result = BaseDllAppendBufferToResultBuffer(
                 (int)String1,
                 (PCHAR)(BYTE1(String1->Buffer) == 0 ? (unsigned int)"=" : 0),
                 BYTE1(String1->Buffer) != 0 ? (unsigned int)L"=" : 0,
                 1u,
                 0);
      if ( result < 0 )
        return result;
    }
    if ( String1[1].Buffer[25] )
    {
      v3 = String1[21].Buffer;
      v4 = *((_DWORD *)v3 + 1);
      while ( *(_WORD *)v3 && *(_WORD *)v4 <= 0x20u )
      {
        v4 += 2;
        *((_DWORD *)String1[21].Buffer + 1) = v4;
        *(_WORD *)String1[21].Buffer -= 2;
        *((_WORD *)String1[21].Buffer + 1) -= 2;
        v3 = String1[21].Buffer;
      }
    }
    else
    {
      v5 = *(_DWORD *)&String1[17].Length;
      v6 = *(_DWORD *)(v5 + 4);
      while ( *(_WORD *)v5 && *(_BYTE *)v6 <= 0x20u )
      {
        ++v6;
        *(_DWORD *)(*(_DWORD *)&String1[17].Length + 4) = v6;
        --**(_WORD **)&String1[17].Length;
        --*(_WORD *)(*(_DWORD *)&String1[17].Length + 2);
        v5 = *(_DWORD *)&String1[17].Length;
      }
    }
  }
  return result;
}

//----- (77E168FA) --------------------------------------------------------
int __stdcall RegDeleteKeyExInternalW(HANDLE a1, int SourceString, int a3, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edi@1
  HANDLE v7; // esi@3
  int v8; // eax@4
  int v9; // esi@4
  NTSTATUS v10; // eax@5
  ULONG v11; // eax@7
  int v12; // edi@9
  int v13; // ebx@9
  int v14; // eax@9
  unsigned int v16; // esi@16
  int (__stdcall *v17)(_DWORD, _DWORD); // eax@16
  bool v18; // al@19
  int v19; // ecx@21
  signed int v20; // [sp-4h] [bp-48h]@13
  UNICODE_STRING KeyHandle; // [sp+10h] [bp-34h]@5
  int v22; // [sp+18h] [bp-2Ch]@26
  int v23; // [sp+20h] [bp-24h]@1
  int v24; // [sp+24h] [bp-20h]@1
  int v25; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@26

  v24 = 0;
  v25 = 0;
  v5 = RegKrnGetGlobalState();
  v6 = *(_DWORD *)(v5 + 96);
  v23 = *(_DWORD *)(v5 + 96);
  if ( !SourceString || a4 )
  {
    v20 = 87;
  }
  else
  {
    v7 = a1;
    if ( a1 != (HANDLE)-2147483644 )
    {
      v8 = RegKrnGetGlobalState();
      v9 = (*(int (__stdcall **)(HANDLE, HANDLE *, int *, int *))(v8 + 176))(v7, &a1, &v24, &v25);
      if ( v9 )
      {
LABEL_9:
        v12 = v25;
        v13 = v24;
        v14 = RegKrnGetGlobalState();
        (*(void (__stdcall **)(int, int))(v14 + 168))(v13, v12);
        return v9;
      }
      v10 = RtlInitUnicodeStringEx(&KeyHandle, (PCWSTR)SourceString);
      if ( v10 < 0 )
      {
        v11 = RtlNtStatusToDosError(v10);
        goto LABEL_8;
      }
      KeyHandle.Length += 2;
      if ( !((unsigned __int8)a1 & 1) )
      {
        v11 = LocalBaseRegDeleteKeyEx(a1, &KeyHandle, a3, 0, a5);
LABEL_8:
        v9 = v11;
        goto LABEL_9;
      }
      if ( !v6 )
        goto LABEL_9;
      SourceString = 0;
      v16 = (unsigned int)a1 & 0xFFFFFFFE;
      v17 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
      v18 = v17 && !v17(v16, &SourceString) && SourceString == 6;
      v19 = a3;
      if ( !(a3 & 0x300) )
      {
        if ( !v18 )
          goto LABEL_25;
        v19 = a3 | 0x200;
      }
      if ( v18 )
      {
LABEL_26:
        ms_exc.registration.TryLevel = 0;
        v9 = ((int (__stdcall *)(unsigned int, UNICODE_STRING *, int, _DWORD))v23)(
               (unsigned int)a1 & 0xFFFFFFFE,
               &KeyHandle,
               v19,
               0);
        v22 = v9;
        ms_exc.registration.TryLevel = -2;
        goto LABEL_9;
      }
LABEL_25:
      v19 &= 0xFFFFFCFF;
      goto LABEL_26;
    }
    v20 = 6;
  }
  return v20;
}

//----- (77E169E1) --------------------------------------------------------
ULONG __stdcall LocalBaseRegDeleteKeyEx(HANDLE a1, HANDLE KeyHandle, int a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned __int16 v6; // ax@1
  int v7; // ecx@2
  bool v8; // zf@6
  int v9; // edi@6
  NTSTATUS v10; // eax@9
  int v11; // edi@10
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-24h]@8
  int v14; // [sp+20h] [bp-Ch]@1
  int v15; // [sp+24h] [bp-8h]@1
  void (__stdcall *v16)(HANDLE); // [sp+28h] [bp-4h]@1

  v5 = (int)KeyHandle;
  v14 = *(_DWORD *)KeyHandle;
  v15 = *((_DWORD *)KeyHandle + 1);
  v16 = *(void (__stdcall **)(HANDLE))(RegKrnGetGlobalState() + 12);
  v6 = *(_WORD *)v5;
  if ( *(_WORD *)v5 >= 2u )
  {
    v7 = *(_DWORD *)(v5 + 4);
    if ( v7 )
    {
      if ( !(v6 & 1) && !*(_WORD *)(v7 + 2 * ((unsigned int)v6 >> 1) - 2) && !a4 )
      {
        v8 = ((unsigned __int8)a1 & 2) == 0;
        v9 = a5;
        *(_WORD *)v5 = v6 - 2;
        if ( !v8 || *(_BYTE *)(RegKrnGetGlobalState() + 36) & 2 && ExtractClassKey(&a1, v5, v9) )
        {
          v11 = BaseRegOpenClassKey(a1, (PCUNICODE_STRING)v5, 0, a3 & 0x300 | 0x2000000, (int)&KeyHandle, v9);
          if ( v11 < 0 )
          {
LABEL_14:
            *(_DWORD *)v5 = v14;
            *(_DWORD *)(v5 + 4) = v15;
            return RtlNtStatusToDosError(v11);
          }
        }
        else
        {
          ObjectAttributes.RootDirectory = a1;
          ObjectAttributes.Length = 24;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.ObjectName = (PUNICODE_STRING)v5;
          ObjectAttributes.SecurityDescriptor = 0;
          ObjectAttributes.SecurityQualityOfService = 0;
          if ( v9 )
            v10 = NtOpenKeyTransacted(&KeyHandle, a3 & 0x300 | 0x10000, &ObjectAttributes, v9);
          else
            v10 = NtOpenKey(&KeyHandle, a3 & 0x300 | 0x10000, &ObjectAttributes);
          v11 = v10;
        }
        if ( v16 )
          v16(KeyHandle);
        if ( v11 >= 0 )
        {
          v11 = NtDeleteKey(KeyHandle);
          NtClose(KeyHandle);
        }
        goto LABEL_14;
      }
    }
  }
  return 87;
}
// 77DE1694: using guessed type int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E16AE4) --------------------------------------------------------
LSTATUS __stdcall RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
{
  int v4; // eax@1

  v4 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCWSTR, REGSAM, DWORD, _DWORD))(v4 + 204))(
           hKey,
           lpSubKey,
           samDesired,
           Reserved,
           0);
}

//----- (77E16B23) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
  DWORD v4; // esi@1
  signed int v5; // eax@1
  DWORD result; // eax@2

  v4 = nSize;
  v5 = BaseDllReadWriteIniFile(1, 0, 1, (int)lpFileName, (int)lpAppName, 0, (int)lpReturnedString, (int)&nSize);
  if ( v5 < 0 )
  {
    JUMPOUT(v5, -2147483643, &loc_77E46597);
    if ( v5 == -1073741701 )
      RtlSetLastWin32Error(13);
    else
      BaseSetLastNTError(v5);
    result = 0;
  }
  else
  {
    RtlSetLastWin32Error(0);
    result = nSize - 1;
  }
  JUMPOUT(result, v4, &loc_77E465AF);
  lpReturnedString[result] = 0;
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E16C07) --------------------------------------------------------
BOOL __stdcall CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
{
  return CopyFileExW(lpExistingFileName, lpNewFileName, 0, 0, 0, bFailIfExists != 0);
}

//----- (77E16C4D) --------------------------------------------------------
BOOL __stdcall GetStringTypeAStub(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
  return GetStringTypeA(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

//----- (77E16C99) --------------------------------------------------------
signed int __stdcall NullTerminateRegMultiSzString(int a1, int *a2, unsigned int a3, signed int a4, char a5)
{
  bool v5; // zf@18
  int v6; // edx@21
  unsigned int v7; // esi@1
  int v8; // ecx@2
  int v9; // edi@3
  int v10; // eax@3
  signed int v11; // edx@4
  bool v12; // zf@6
  signed int v13; // esi@8
  unsigned int v14; // edi@11
  int v15; // eax@12
  bool v17; // zf@31
  int v18; // [sp+8h] [bp-4h]@1
  int v19; // [sp+14h] [bp+8h]@9

  v7 = (a5 == 0) + 1;
  v18 = (a5 == 0) + 1;
  if ( a4 )
  {
    if ( a4 != 234 )
      return a4;
    goto LABEL_15;
  }
  v8 = a1;
  if ( !a1 )
  {
LABEL_15:
    *a2 += 2 * v7;
    return a4;
  }
  v9 = a3 / v7;
  v10 = *a2 / v7;
  if ( (unsigned int)v10 >= 2 )
  {
    v11 = 0;
    if ( a5 )
    {
      if ( !*(_BYTE *)(v10 + a1 - 2) )
      {
        v12 = *(_BYTE *)(v10 + a1 - 1) == 0;
        goto LABEL_7;
      }
      v17 = *(_BYTE *)(v10 + a1 - 1) == 0;
    }
    else
    {
      if ( !*(_WORD *)(a1 + 2 * v10 - 4) )
      {
        v12 = *(_WORD *)(a1 + 2 * v10 - 2) == 0;
LABEL_7:
        LOBYTE(v11) = !v12;
LABEL_8:
        v13 = v11;
        goto LABEL_9;
      }
      v17 = *(_WORD *)(a1 + 2 * v10 - 2) == 0;
    }
    LOBYTE(v11) = !v17;
    ++v11;
    goto LABEL_8;
  }
  v13 = 1;
  if ( a5 )
  {
    if ( v10 == 1 )
    {
      v5 = *(_BYTE *)a1 == 0;
LABEL_19:
      if ( v5 )
        goto LABEL_9;
      goto LABEL_28;
    }
  }
  else if ( v10 == 1 )
  {
    v5 = *(_WORD *)a1 == 0;
    goto LABEL_19;
  }
LABEL_28:
  v13 = 2;
LABEL_9:
  v19 = v13 + v10;
  if ( v13 + v10 > (unsigned int)v9 || v13 + v10 < (unsigned int)v10 )
  {
    a4 = 234;
  }
  else
  {
    v14 = 0;
    if ( (unsigned int)v13 > 0 )
    {
      v6 = v8 + 2 * v10;
      do
      {
        if ( a5 )
          *(_BYTE *)(v14 + v10 + v8) = 0;
        else
          *(_WORD *)v6 = 0;
        ++v14;
        v6 += 2;
      }
      while ( v14 < v13 );
    }
  }
  v15 = v18 * v19;
  if ( *a2 > (unsigned int)(v18 * v19) )
    v15 = *a2;
  *a2 = v15;
  return a4;
}

//----- (77E16E96) --------------------------------------------------------
HANDLE __stdcall CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
{
  DWORD v3; // eax@1

  v3 = 0;
  if ( bManualReset )
    v3 = 1;
  return CreateWaitableTimerExW(lpTimerAttributes, lpTimerName, v3, 0x1F0003u);
}

//----- (77E16F02) --------------------------------------------------------
void __stdcall OutputDebugStringWStub(LPCWSTR lpOutputString)
{
  OutputDebugStringW(lpOutputString);
}

//----- (77E16F1A) --------------------------------------------------------
BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
{
  WCHAR *v2; // esi@1
  signed int v3; // edi@2
  int v5; // eax@6
  DWORD v6; // [sp+Ch] [bp-28h]@1
  WCHAR Buffer; // [sp+10h] [bp-24h]@1

  v2 = &Buffer;
  v6 = 16;
  if ( !GetComputerNameW(&Buffer, &v6) )
  {
    if ( GetLastError() == 111 )
    {
      v5 = KernelBaseGetGlobalData();
      v2 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), 2 * v6);
      if ( v2 )
      {
        if ( GetComputerNameW(v2, &v6) )
          goto LABEL_2;
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
      }
      else
      {
        RtlSetLastWin32Error(8);
      }
    }
    return 0;
  }
LABEL_2:
  v3 = BasepUnicodeToAnsi(v2, lpBuffer, (unsigned int *)nSize, 111);
  if ( v2 != &Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E16F82) --------------------------------------------------------
signed int __stdcall BasepUnicodeToAnsi(PCWSTR a1, CHAR *a2, unsigned int *a3, int a4)
{
  NTSTATUS v4; // eax@1
  ULONG v5; // edi@3
  unsigned int v6; // eax@4
  NTSTATUS v7; // eax@7
  signed int result; // eax@8
  UNICODE_STRING SourceString; // [sp+4h] [bp-10h]@1
  STRING DestinationString; // [sp+Ch] [bp-8h]@1

  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v4 = RtlInitUnicodeStringEx(&SourceString, a1);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    *a3 = 0;
    result = 0;
  }
  else
  {
    if ( (_BYTE)NlsMbCodePageTag )
      v5 = RtlxUnicodeStringToAnsiSize(&SourceString);
    else
      v5 = ((unsigned int)SourceString.Length + 2) >> 1;
    v6 = *a3;
    if ( v5 > *a3 )
    {
      RtlSetLastWin32Error(a4);
      *a3 = v5;
    }
    else
    {
      DestinationString.MaximumLength = -1;
      if ( v6 <= 0xFFFF )
        DestinationString.MaximumLength = v6;
      DestinationString.Length = 0;
      DestinationString.Buffer = a2;
      v7 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0);
      if ( v7 >= 0 )
      {
        *a3 = DestinationString.Length;
        return 1;
      }
      BaseSetLastNTError(v7);
      *a3 = 0;
    }
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E17019) --------------------------------------------------------
HANDLE __stdcall FindFirstChangeNotificationWStub(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
{
  return FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);
}

//----- (77E17031) --------------------------------------------------------
BOOL __stdcall FindNextChangeNotificationStub(HANDLE hChangeHandle)
{
  return FindNextChangeNotification(hChangeHandle);
}

//----- (77E17071) --------------------------------------------------------
NTSTATUS __stdcall BaseDllAppendNullToResultBuffer(int a1)
{
  return BaseDllAppendBufferToResultBuffer(a1, 0, 0, 0, 1);
}

//----- (77E170A6) --------------------------------------------------------
ULONG __stdcall MapSAToRpcSA(int a1, int a2)
{
  void *v2; // ecx@1
  ULONG result; // eax@2

  *(_DWORD *)(a2 + 4) = 0;
  v2 = *(void **)(a1 + 4);
  if ( v2 )
  {
    result = MapSDToRpcSD(v2, a2 + 4);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    result = 0;
  }
  if ( !result )
  {
    *(_DWORD *)a2 = *(_DWORD *)a1;
    *(_BYTE *)(a2 + 16) = *(_BYTE *)(a1 + 8);
  }
  return result;
}

//----- (77E17131) --------------------------------------------------------
BOOL __stdcall GetExitCodeThreadStub(HANDLE hThread, LPDWORD lpExitCode)
{
  return GetExitCodeThread(hThread, lpExitCode);
}

//----- (77E17149) --------------------------------------------------------
UINT __stdcall GetTempFileNameWStub(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
{
  return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
}

//----- (77E17445) --------------------------------------------------------
ATOM __stdcall AddAtomA(LPCSTR lpString)
{
  return InternalAddAtom(1, 0, lpString);
}

//----- (77E17652) --------------------------------------------------------
int __stdcall GetLocaleNullStringFromArrayInPoolTestArray(int a1, int a2, unsigned int a3)
{
  int result; // eax@1

  result = a1;
  if ( a2 )
  {
    if ( a3 < *(_WORD *)(a1 + 2 * a2) )
      result = a1 + 2 * *(_DWORD *)(a1 + 2 * (a2 + 2 * a3) + 2) + 2;
  }
  return result;
}

//----- (77E176A2) --------------------------------------------------------
BOOL __stdcall LocalFileTimeToFileTimeStub(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
{
  return LocalFileTimeToFileTime(lpLocalFileTime, lpFileTime);
}

//----- (77E176BA) --------------------------------------------------------
DWORD __stdcall GetCurrentDirectoryAStub(DWORD nBufferLength, LPSTR lpBuffer)
{
  return GetCurrentDirectoryA(nBufferLength, lpBuffer);
}

//----- (77E176F2) --------------------------------------------------------
void __userpurge sub_77E176F2(int a1@<eax>, int a2@<ebp>, int a3@<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13)
{
  JUMPOUT(a1, a3, &loc_77E5AA9C);
  *(_WORD *)(a2 - 52) += 2;
  JUMPOUT(&loc_77E23830);
}

//----- (77E17709) --------------------------------------------------------
BOOL __stdcall SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
{
  return SetProcessWorkingSetSizeEx(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, 0);
}

//----- (77E17727) --------------------------------------------------------
BOOL __stdcall SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
{
  int v4; // edi@3
  signed int v5; // esi@3
  int ProcessInformation; // [sp+8h] [bp-40h]@1
  char Dst; // [sp+Ch] [bp-3Ch]@1
  SIZE_T v9; // [sp+10h] [bp-38h]@3
  SIZE_T v10; // [sp+14h] [bp-34h]@3
  DWORD v11; // [sp+38h] [bp-10h]@3
  int v12; // [sp+40h] [bp-8h]@1
  int v13; // [sp+44h] [bp-4h]@1
  BOOL dwMinimumWorkingSetSizea; // [sp+54h] [bp+Ch]@3

  v12 = 33;
  v13 = 14;
  ProcessInformation = 0;
  memset(&Dst, 0, 0x34u);
  if ( dwMinimumWorkingSetSize && dwMaximumWorkingSetSize )
  {
    v10 = dwMaximumWorkingSetSize;
    v11 = Flags;
    v9 = dwMinimumWorkingSetSize;
    v4 = RtlAcquirePrivilege(&v12, 2, 0, &dwMaximumWorkingSetSize);
    v5 = NtSetInformationProcess(hProcess, ProcessQuotaLimits, &ProcessInformation, 0x38u);
    dwMinimumWorkingSetSizea = v5 >= 0;
    if ( v4 >= 0 )
    {
      RtlReleasePrivilege(dwMaximumWorkingSetSize);
      dwMaximumWorkingSetSize = 0;
    }
  }
  else
  {
    v5 = -1073741811;
    dwMinimumWorkingSetSizea = 0;
  }
  if ( !dwMinimumWorkingSetSizea )
    BaseSetLastNTError(v5);
  return dwMinimumWorkingSetSizea;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E17845) --------------------------------------------------------
DWORD __stdcall GetProcessVersionStub(DWORD ProcessId)
{
  return GetProcessVersion(ProcessId);
}

//----- (77E17863) --------------------------------------------------------
BOOL __stdcall GetHandleInformationImplementation(HANDLE hObject, LPDWORD lpdwFlags)
{
  PVOID v2; // eax@1
  BOOL result; // eax@5

  v2 = hObject;
  if ( hObject == (HANDLE)-12 )
  {
    v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hObject == (HANDLE)-11 )
  {
    v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hObject == (HANDLE)-10 )
  {
    v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v2 & 0x10000003) == 3 )
    result = GetConsoleHandleInformation((int)v2, (int)lpdwFlags);
  else
    result = GetHandleInformation(v2, lpdwFlags);
  return result;
}

//----- (77E178B4) --------------------------------------------------------
HRESULT __stdcall WerSetFlags(DWORD dwFlags)
{
  return WerpSetFlags(dwFlags);
}

//----- (77E178C1) --------------------------------------------------------
signed int __stdcall WerpSetFlags(int a1)
{
  struct _PEB *v1; // esi@1
  PVOID v2; // esi@4
  signed int v4; // [sp+10h] [bp-1Ch]@2

  v1 = WerpCurrentPeb();
  if ( v1 )
  {
    v4 = WerpInitPEBStore();
    if ( v4 < 0 )
    {
      DbgPrintOut(0, "WerpInitPEBStore failed");
      return v4;
    }
    if ( WerpAcquirePebLock() >= 0 )
    {
      v2 = v1[1].Reserved9[8];
      if ( v2 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v2) >= 0 )
      {
        *((_DWORD *)v2 + 545) = a1;
        v4 = 0;
      }
      else
      {
        DbgPrintOut(0, "Invalid PEB entry");
      }
      RtlReleasePebLock();
      return v4;
    }
    DbgPrintOut(0, "Unable to get the peb lock");
  }
  else
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
  }
  return -2147467259;
}

//----- (77E1796D) --------------------------------------------------------
NTSTATUS __stdcall BaseDllAppendStringToResultBuffer(int a1, int a2, int a3, char a4)
{
  JUMPOUT(a2, 0, &loc_77E17A7E);
  JUMPOUT(a3, 0, &loc_77E17A97);
  return BaseDllAppendBufferToResultBuffer(a1, *(PCHAR *)(a2 + 4), 0, *(_WORD *)a2, a4);
}

//----- (77E179A4) --------------------------------------------------------
NTSTATUS __stdcall BaseDllAppendBufferToResultBuffer(int a1, PCHAR MbString, ULONG MbSize, ULONG UnicodeSize, char a5)
{
  PCHAR v5; // edi@1
  ULONG v6; // eax@3
  int v7; // edx@4
  unsigned int v8; // ecx@4
  int v9; // eax@10
  NTSTATUS result; // eax@14
  ULONG v11; // eax@17
  ULONG v12; // edi@17
  int v13; // edx@18
  int v14; // ecx@32
  signed int v15; // [sp+38h] [bp-4h]@1

  v5 = MbString;
  v15 = 0;
  if ( !MbString )
  {
    if ( !MbSize )
      goto LABEL_9;
    v11 = UnicodeSize;
    v12 = UnicodeSize;
    if ( !*(_BYTE *)(a1 + 5) )
    {
      result = RtlUnicodeToMultiByteSize(&UnicodeSize, (PWCHAR)MbSize, 2 * UnicodeSize);
      if ( result < 0 )
        return result;
      v11 = UnicodeSize;
    }
    v13 = *(_DWORD *)(a1 + 76);
    JUMPOUT(v13 + v11, *(_DWORD *)(a1 + 80), &loc_77E4654B);
    if ( !v11 )
      goto LABEL_9;
    if ( *(_BYTE *)(a1 + 5) )
    {
      memcpy((void *)(*(_DWORD *)(a1 + 88) + 2 * v13), (const void *)MbSize, 2 * v11);
      goto LABEL_8;
    }
    result = RtlUnicodeToMultiByteN(
               (PCHAR)(v13 + *(_DWORD *)(a1 + 84)),
               v11,
               (PULONG)&MbString,
               (PWCHAR)MbSize,
               2 * v12);
LABEL_26:
    if ( result < 0 )
      return result;
    goto LABEL_8;
  }
  if ( MbSize )
    return -1073741811;
  v6 = UnicodeSize;
  MbSize = UnicodeSize;
  if ( *(_BYTE *)(a1 + 5) )
  {
    result = RtlMultiByteToUnicodeSize(&UnicodeSize, MbString, UnicodeSize);
    if ( result < 0 )
      return result;
    v6 = UnicodeSize >> 1;
    UnicodeSize >>= 1;
  }
  v7 = *(_DWORD *)(a1 + 76);
  v8 = *(_DWORD *)(a1 + 80);
  if ( v7 + v6 >= v8 )
  {
    v14 = v8 - v7;
    v15 = -2147483643;
    if ( !v14 )
      goto LABEL_9;
    v6 = v14 - 1;
    UnicodeSize = v14 - 1;
  }
  if ( v6 )
  {
    if ( !*(_BYTE *)(a1 + 5) )
    {
      memcpy((void *)(v7 + *(_DWORD *)(a1 + 84)), v5, v6);
LABEL_8:
      *(_DWORD *)(a1 + 76) += UnicodeSize;
      goto LABEL_9;
    }
    result = RtlMultiByteToUnicodeN((PWCHAR)(*(_DWORD *)(a1 + 88) + 2 * v7), 2 * v6, (PULONG)&MbString, v5, MbSize);
    goto LABEL_26;
  }
LABEL_9:
  if ( !a5 )
    return v15;
  v9 = *(_DWORD *)(a1 + 76);
  if ( (unsigned int)(v9 + 1) < *(_DWORD *)(a1 + 80) )
  {
    if ( *(_BYTE *)(a1 + 5) )
      *(_WORD *)(*(_DWORD *)(a1 + 88) + 2 * v9) = 0;
    else
      *(_BYTE *)(v9 + *(_DWORD *)(a1 + 84)) = 0;
    ++*(_DWORD *)(a1 + 76);
    return v15;
  }
  return -2147483643;
}

//----- (77E17BDD) --------------------------------------------------------
UINT __stdcall GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
{
  DWORD v4; // eax@1
  NTSTATUS v5; // esi@2
  STRING DestinationString; // [sp+0h] [bp-218h]@2
  UNICODE_STRING SourceString; // [sp+8h] [bp-210h]@2
  ULONG Value; // [sp+10h] [bp-208h]@1
  WCHAR ReturnedString; // [sp+14h] [bp-204h]@1

  Value = 0;
  v4 = GetPrivateProfileStringW(lpAppName, lpKeyName, 0, &ReturnedString, 0x100u, lpFileName);
  if ( v4 )
  {
    SourceString.Length = 2 * v4;
    SourceString.MaximumLength = 2 * v4 + 2;
    SourceString.Buffer = &ReturnedString;
    v5 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 1u);
    if ( v5 < 0
      || (v5 = RtlCharToInteger(DestinationString.Buffer, 0, &Value), RtlFreeAnsiString(&DestinationString), v5 < 0) )
      BaseSetLastNTError(v5);
    else
      RtlSetLastWin32Error(0);
  }
  else
  {
    Value = nDefault;
  }
  return Value;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E17CAE) --------------------------------------------------------
UINT __stdcall GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
{
  return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, 0);
}

//----- (77E17CCC) --------------------------------------------------------
DWORD __stdcall GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
{
  return GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, 0);
}

//----- (77E17D02) --------------------------------------------------------
ULONG __stdcall MapSDToRpcSD(PSECURITY_DESCRIPTOR SecurityDescriptor, int a2)
{
  ULONG v2; // edi@2
  PVOID v3; // eax@3
  int v4; // eax@4
  int v5; // ST04_4@5
  NTSTATUS v6; // eax@5
  signed int v8; // [sp-4h] [bp-Ch]@8

  if ( RtlValidSecurityDescriptor(SecurityDescriptor) )
  {
    v2 = RtlLengthSecurityDescriptor(SecurityDescriptor);
    if ( *(_DWORD *)a2 )
    {
      v4 = a2 + 4;
      if ( *(_DWORD *)(a2 + 4) >= v2 )
        goto LABEL_5;
    }
    else
    {
      v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
      *(_DWORD *)a2 = v3;
      if ( v3 )
      {
        v4 = a2 + 4;
        *(_DWORD *)(a2 + 4) = v2;
LABEL_5:
        v5 = *(_DWORD *)a2;
        *(_DWORD *)(a2 + 8) = v2;
        v6 = RtlMakeSelfRelativeSD(SecurityDescriptor, v5, v4);
        return RtlNtStatusToDosError(v6);
      }
    }
    v8 = 14;
  }
  else
  {
    v8 = 87;
  }
  return v8;
}
// 77DE16C4: using guessed type int __stdcall RtlMakeSelfRelativeSD(_DWORD, _DWORD, _DWORD);

//----- (77E17D7E) --------------------------------------------------------
LSTATUS __stdcall RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
{
  signed int v4; // edi@1
  HKEY v5; // esi@12
  int v6; // eax@12
  LSTATUS v7; // ebx@12
  signed int v8; // esi@12
  HKEY v9; // ecx@12
  int v10; // esi@22
  int v11; // edi@22
  int v12; // eax@22
  NTSTATUS v14; // eax@25
  LSTATUS v15; // [sp-4h] [bp-6Ch]@33
  void *Src; // [sp+10h] [bp-58h]@47
  size_t Size; // [sp+14h] [bp-54h]@47
  int v18; // [sp+18h] [bp-50h]@47
  void *Dst; // [sp+1Ch] [bp-4Ch]@17
  size_t v20; // [sp+20h] [bp-48h]@17
  int v21; // [sp+24h] [bp-44h]@17
  LSTATUS v22; // [sp+28h] [bp-40h]@47
  int v23; // [sp+30h] [bp-38h]@25
  int v24; // [sp+34h] [bp-34h]@25
  int v25; // [sp+38h] [bp-30h]@1
  int v26; // [sp+3Ch] [bp-2Ch]@1
  void (__stdcall *v27)(void *); // [sp+40h] [bp-28h]@1
  int (__stdcall *v28)(unsigned int, SECURITY_INFORMATION, void **, void **); // [sp+44h] [bp-24h]@1
  HKEY v29; // [sp+48h] [bp-20h]@1
  HANDLE Handle; // [sp+4Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@47

  v4 = 0;
  v29 = 0;
  Handle = 0;
  v25 = 0;
  v26 = 0;
  v28 = *(int (__stdcall **)(unsigned int, SECURITY_INFORMATION, void **, void **))(RegKrnGetGlobalState() + 104);
  v27 = *(void (__stdcall **)(void *))(RegKrnGetGlobalState() + 136);
  if ( hKey == HKEY_PERFORMANCE_DATA )
  {
    v15 = 6;
  }
  else
  {
    if ( lpcbSecurityDescriptor )
    {
      if ( hKey == HKEY_CLASSES_ROOT )
      {
        v4 = 1;
      }
      else if ( hKey != HKEY_CURRENT_USER
             && hKey != HKEY_LOCAL_MACHINE
             && hKey != HKEY_PERFORMANCE_TEXT
             && hKey != HKEY_PERFORMANCE_NLSTEXT
             && hKey != HKEY_USERS
             && hKey != HKEY_CURRENT_CONFIG
             && hKey != HKEY_DYN_DATA
             && hKey != HKEY_CURRENT_USER_LOCAL_SETTINGS )
      {
        goto LABEL_12;
      }
      if ( SecurityInformation & 8 )
      {
        v8 = 0x1000000;
        if ( SecurityInformation & 7 )
          v8 = 16908288;
        v7 = OpenPredefinedKeyForSpecialAccess((int)hKey, v8, (PHANDLE)&hKey);
        if ( v7 )
          return v7;
        v9 = hKey;
        v29 = hKey;
LABEL_13:
        if ( !v7 )
        {
          if ( !((unsigned __int8)v9 & 1) && ((unsigned __int8)v9 & 2 || v4) )
          {
            v14 = BaseRegGetUserAndMachineClass(0, v9, v8, (int)&v24, (int)&v23);
            if ( v14 < 0 )
            {
              v7 = RtlNtStatusToDosError(v14);
              goto LABEL_20;
            }
            if ( v24 && (v9 = (HKEY)v23) != 0 )
            {
              Handle = (HANDLE)v24;
              if ( (HKEY)v24 == hKey )
                Handle = (HANDLE)v23;
              if ( v4 )
                v9 = (HKEY)v24;
              hKey = v9;
            }
            else
            {
              v9 = hKey;
            }
          }
          Dst = pSecurityDescriptor;
          v20 = *lpcbSecurityDescriptor;
          v21 = 0;
          if ( (unsigned __int8)v9 & 1 )
          {
            if ( v28 )
            {
              Src = 0;
              Size = 0;
              v18 = 0;
              ms_exc.registration.TryLevel = 0;
              v7 = v28((unsigned int)v9 & 0xFFFFFFFE, SecurityInformation, &Dst, &Src);
              v22 = v7;
              ms_exc.registration.TryLevel = -2;
              if ( !v7 )
              {
                if ( Size <= v20 && Src )
                  memcpy(Dst, Src, Size);
                else
                  v7 = 1783;
              }
              v20 = Size;
              if ( Src && v27 )
                v27(Src);
              if ( (!v7 || v7 == 234) && v20 > 0x7FFF0000
                || !v7 && pSecurityDescriptor && !RtlValidSecurityDescriptor(pSecurityDescriptor) )
              {
                v7 = 13;
                goto LABEL_20;
              }
            }
          }
          else
          {
            v7 = LocalBaseRegGetKeySecurity(v9, SecurityInformation, (int)&Dst);
          }
          *lpcbSecurityDescriptor = v20;
        }
LABEL_20:
        if ( Handle )
          NtClose(Handle);
        if ( v29 )
          RegCloseKey(v29);
        v10 = v26;
        v11 = v25;
        v12 = RegKrnGetGlobalState();
        (*(void (__stdcall **)(int, int))(v12 + 168))(v11, v10);
        return v7;
      }
LABEL_12:
      v5 = hKey;
      v6 = RegKrnGetGlobalState();
      v7 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v6 + 176))(v5, &hKey, &v25, &v26);
      v8 = 0x2000000;
      v9 = hKey;
      goto LABEL_13;
    }
    v15 = 87;
  }
  return v15;
}

//----- (77E17EF1) --------------------------------------------------------
ULONG __stdcall LocalBaseRegGetKeySecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, int a3)
{
  PVOID v3; // ebx@4
  NTSTATUS v4; // eax@5
  ULONG v5; // eax@6
  ULONG result; // eax@10
  NTSTATUS v7; // eax@14
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-28h]@14
  UNICODE_STRING DestinationString; // [sp+1Ch] [bp-10h]@14
  ULONG ReturnLength; // [sp+24h] [bp-8h]@1
  HANDLE KeyHandle; // [sp+28h] [bp-4h]@1
  HANDLE Handlea; // [sp+34h] [bp+8h]@7

  ReturnLength = 0;
  KeyHandle = 0;
  if ( Handle == (HANDLE)-2147483644 || Handle == (HANDLE)-2147483568 || Handle == (HANDLE)-2147483552 )
  {
    RtlInitUnicodeStringEx(
      &DestinationString,
      L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v7 = NtOpenKey(&KeyHandle, (RequestedInformation & 8 | 0x10) << 21, &ObjectAttributes);
    if ( v7 < 0 )
    {
      result = RtlNtStatusToDosError(v7);
      *(_DWORD *)(a3 + 4) = 0;
      *(_DWORD *)(a3 + 8) = 0;
      return result;
    }
    Handle = KeyHandle;
  }
  v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(_DWORD *)(a3 + 4));
  if ( v3 )
  {
    v4 = NtQuerySecurityObject(Handle, RequestedInformation, v3, *(_DWORD *)(a3 + 4), &ReturnLength);
    if ( v4 < 0 )
      v5 = RtlNtStatusToDosError(v4);
    else
      v5 = MapSDToRpcSD(v3, a3);
    Handlea = (HANDLE)v5;
    if ( v5 )
    {
      *(_DWORD *)(a3 + 4) = ReturnLength;
      *(_DWORD *)(a3 + 8) = 0;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  }
  else
  {
    Handlea = (HANDLE)14;
  }
  if ( KeyHandle )
    NtClose(KeyHandle);
  return (ULONG)Handlea;
}

//----- (77E17FDA) --------------------------------------------------------
BOOL __stdcall VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
{
  UCHAR v3; // cl@1
  struct _OSVERSIONINFOEXW VersionInformation; // [sp+0h] [bp-120h]@1

  VersionInformation.dwMajorVersion = lpVersionInformation->dwMajorVersion;
  VersionInformation.dwMinorVersion = lpVersionInformation->dwMinorVersion;
  VersionInformation.dwBuildNumber = lpVersionInformation->dwBuildNumber;
  VersionInformation.dwPlatformId = lpVersionInformation->dwPlatformId;
  VersionInformation.wServicePackMajor = lpVersionInformation->wServicePackMajor;
  VersionInformation.wServicePackMinor = lpVersionInformation->wServicePackMinor;
  VersionInformation.wSuiteMask = lpVersionInformation->wSuiteMask;
  v3 = lpVersionInformation->wProductType;
  VersionInformation.wReserved = lpVersionInformation->wReserved;
  VersionInformation.dwOSVersionInfoSize = 284;
  VersionInformation.wProductType = v3;
  return VerifyVersionInfoW(&VersionInformation, dwTypeMask, dwlConditionMask);
}

//----- (77E1807B) --------------------------------------------------------
SIZE_T __stdcall HeapCompactStub(HANDLE hHeap, DWORD dwFlags)
{
  return HeapCompact(hHeap, dwFlags);
}

//----- (77E18093) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
{
  int v6; // eax@21
  const unsigned __int16 *v7; // ebx@1
  int v8; // esi@1
  DWORD v9; // edi@2
  signed int v10; // eax@2
  NTSTATUS v11; // edx@2

  v7 = lpDefault;
  v8 = 0;
  if ( !lpDefault )
    v7 = &Src;
  v9 = nSize;
  lpDefault = (LPCWSTR)nSize;
  v10 = BaseDllReadWriteIniFile(
          1,
          0,
          0,
          (int)lpFileName,
          (int)lpAppName,
          (int)lpKeyName,
          (int)lpReturnedString,
          (int)&lpDefault);
  v11 = v10;
  nSize = v10;
  if ( v10 < 0 )
  {
    if ( v10 == -2147483643 )
    {
      if ( lpAppName && lpKeyName )
      {
        if ( v9 >= 1 )
          v8 = v9 - 1;
      }
      else if ( v9 >= 2 )
      {
        v8 = v9 - 2;
        lpReturnedString[v9 - 1] = 0;
      }
    }
    else
    {
      v8 = wcslen(v7);
      if ( v8 )
      {
        v6 = (int)&v7[v8 - 1];
        do
        {
          if ( *(_WORD *)v6 != 32 )
            break;
          --v8;
          v6 -= 2;
        }
        while ( v8 );
      }
      if ( !v9 )
      {
        BaseSetLastNTError(v11);
        return 0;
      }
      if ( v8 >= v9 )
        v8 = v9 - 1;
      wcsncpy_s(lpReturnedString, v9, v7, v8);
    }
  }
  else
  {
    RtlSetLastWin32Error(0);
    v8 = (int)((char *)lpDefault - 1);
  }
  if ( v8 >= v9 )
  {
    if ( v9 )
      lpReturnedString[v9 - 1] = 0;
  }
  else
  {
    lpReturnedString[v8] = 0;
  }
  if ( (nSize & 0x80000000) != 0 )
    BaseSetLastNTError(nSize);
  else
    RtlSetLastWin32Error(0);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1818B) --------------------------------------------------------
NTSTATUS __stdcall BaseDllFindKeyword(STRING *String1)
{
  int v1; // edi@1
  signed int i; // eax@1
  char v3; // al@4
  const STRING *v4; // eax@6
  BOOLEAN v5; // al@7
  signed int v6; // esi@8
  NTSTATUS result; // eax@11
  const UNICODE_STRING *v8; // ST04_4@20
  PCUNICODE_STRING v9; // [sp+Ch] [bp-8h]@14
  int v10; // [sp+10h] [bp-4h]@3

  v1 = (int)String1;
  for ( i = BaseDllAdvanceTextPointer((int)String1, 2); ; i = BaseDllAdvanceTextPointer(v1, 2) )
  {
    if ( i != 261 )
      return -1073741772;
    v10 = 0;
    if ( *(_DWORD *)(v1 + 132) )
    {
      v3 = BaseDllGetVariableName(v1, (int)&String1, 0);
      goto LABEL_5;
    }
    if ( !*(_BYTE *)(v1 + 5) )
      break;
    v3 = BaseDllGetVariableName(v1, 0, (int)&v9);
LABEL_5:
    if ( !v3 )
      return -1073741811;
LABEL_6:
    v4 = *(const STRING **)(v1 + 132);
    if ( v4 || !*(_BYTE *)(v1 + 5) )
      v5 = RtlEqualString(String1, v4, 1u);
    else
      v5 = RtlEqualUnicodeString(v9, *(PCUNICODE_STRING *)(v1 + 168), 1u);
    v6 = v5 != 0 ? 0 : 261;
    if ( v10 )
      RtlFreeAnsiString(*(PANSI_STRING *)(v1 + 132));
    if ( v6 != 261 )
      return v6;
  }
  if ( BaseDllGetVariableName(v1, (int)&String1, 0) )
  {
    v8 = *(const UNICODE_STRING **)(v1 + 168);
    *(_DWORD *)(v1 + 132) = v1 + 112;
    result = RtlUnicodeStringToAnsiString((PANSI_STRING)(v1 + 112), v8, 1u);
    if ( result < 0 )
      return result;
    v10 = 1;
    goto LABEL_6;
  }
  return -1073741811;
}

//----- (77E18566) --------------------------------------------------------
HANDLE __stdcall CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  HANDLE v6; // esi@3
  HANDLE result; // eax@4
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v6 = CreateSemaphoreExW(
         lpSemaphoreAttributes,
         lInitialCount,
         lMaximumCount,
         UnicodeString.Buffer,
         dwFlags,
         dwDesiredAccess);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v6;
}

//----- (77E185AB) --------------------------------------------------------
HANDLE __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
{
  return CreateSemaphoreExA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, 0, 0x1F0003u);
}

//----- (77E185DF) --------------------------------------------------------
HANDLE __stdcall OpenSemaphoreWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
  return OpenSemaphoreW(dwDesiredAccess, bInheritHandle, lpName);
}

//----- (77E185F7) --------------------------------------------------------
BOOL __stdcall FlushFileBuffersImplementation(HANDLE hFile)
{
  PVOID v1; // eax@1
  BOOL result; // eax@5

  v1 = hFile;
  if ( hFile == (HANDLE)-12 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hFile == (HANDLE)-11 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hFile == (HANDLE)-10 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v1 & 0x10000003) == 3 )
    result = FlushConsoleInputBuffer(v1);
  else
    result = FlushFileBuffers(v1);
  return result;
}

//----- (77E18678) --------------------------------------------------------
int __stdcall BaseFormatTimeOut(int a1, unsigned int a2)
{
  int result; // eax@2

  if ( a2 == -1 )
  {
    result = 0;
  }
  else
  {
    *(_QWORD *)a1 = -10000i64 * a2;
    result = a1;
  }
  return result;
}

//----- (77E18711) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
{
  signed int v4; // eax@1
  BOOL result; // eax@2

  v4 = BaseDllReadWriteIniFile(
         1,
         1,
         0,
         (int)lpFileName,
         (int)lpAppName,
         (int)lpKeyName,
         lpKeyName != 0 ? (unsigned int)lpString : 0,
         0);
  if ( v4 < 0 )
  {
    if ( v4 == -1073741701 )
      RtlSetLastWin32Error(13);
    else
      BaseSetLastNTError(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1876B) --------------------------------------------------------
int __stdcall BaseDllFindIniFileNameMapping(PCUNICODE_STRING String2, int a2, int a3)
{
  int (__stdcall *v3)(_DWORD, _DWORD); // ebx@1
  int v4; // eax@4
  PPEB v5; // edi@6
  int i; // esi@6
  int result; // eax@15
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-234h]@1
  LSA_UNICODE_STRING v9; // [sp+14h] [bp-22Ch]@2
  int v10; // [sp+1Ch] [bp-224h]@1
  UNICODE_STRING v11; // [sp+20h] [bp-220h]@9
  PCUNICODE_STRING String1; // [sp+28h] [bp-218h]@1
  int v13; // [sp+2Ch] [bp-214h]@1
  char v14; // [sp+30h] [bp-210h]@19

  String1 = (PCUNICODE_STRING)a2;
  v10 = a3;
  v3 = *(int (__stdcall **)(_DWORD, _DWORD))(KernelBaseGetGlobalData() + 100);
  *(_DWORD *)a3 = 0;
  v13 = -1073741772;
  RtlInitUnicodeString(&DestinationString, L"win.ini");
  if ( v3 && v3(&v14, 260) )
    RtlInitUnicodeString(&v9, (PCWSTR)&v14);
  else
    RtlInitUnicodeString(&v9, &Src);
  if ( String2->Buffer != String1->Buffer )
  {
    v4 = KernelBaseGetGlobalData();
    if ( !RtlPrefixUnicodeString((PCUNICODE_STRING)(v4 + 52), String2, 1u)
      && RtlEqualUnicodeString(String1, &DestinationString, 1u)
      && (!(v7FFE02D0 & 0x10) || !RtlPrefixUnicodeString(&v9, String2, 1u)) )
      return v13;
  }
  v5 = NtCurrentTeb()->ProcessEnvironmentBlock;
  for ( i = *(_DWORD *)BaseDllIniFileMapping; ; i = *(_DWORD *)i )
  {
    if ( !i )
      goto LABEL_13;
    if ( v5->Reserved2[0] & 2 )
    {
      result = BaseVerifyFileName(i, (int)&v11);
      v13 = result;
      if ( result < 0 )
        return result;
    }
    else
    {
      *(_DWORD *)&v11.Length = *(_DWORD *)(i + 4);
      v11.Buffer = *(PWCH *)(i + 8);
    }
    if ( RtlEqualUnicodeString(String1, &v11, 1u) )
      break;
  }
  v13 = 0;
  if ( i )
  {
LABEL_14:
    *(_DWORD *)v10 = i;
    return v13;
  }
LABEL_13:
  i = *(_DWORD *)(BaseDllIniFileMapping + 4);
  if ( !(v5->Reserved2[0] & 2) )
    goto LABEL_14;
  if ( !i )
    goto LABEL_14;
  v13 = BaseVerifyFileName(i, 0);
  if ( v13 >= 0 )
    goto LABEL_14;
  return v13;
}
// 77EA6090: using guessed type int BaseDllIniFileMapping;

//----- (77E189A3) --------------------------------------------------------
BOOL __stdcall FlushViewOfFileStub(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
{
  return FlushViewOfFile(lpBaseAddress, dwNumberOfBytesToFlush);
}

//----- (77E189F6) --------------------------------------------------------
ATOM __stdcall GlobalAddAtomA(LPCSTR lpString)
{
  return InternalAddAtom(0, 0, lpString);
}

//----- (77E18A10) --------------------------------------------------------
LSTATUS __stdcall RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  HKEY v8; // esi@6
  int v9; // eax@6
  DWORD v10; // eax@11
  ULONG v11; // eax@20
  DWORD v12; // eax@21
  NTSTATUS v13; // eax@24
  BYTE *v14; // eax@29
  LPDWORD v15; // esi@38
  NTSTATUS v16; // eax@38
  int v17; // esi@45
  int v18; // edi@45
  int v19; // eax@45
  unsigned int v21; // edi@65
  int (__stdcall *v22)(_DWORD, _DWORD); // eax@65
  PVOID v23; // eax@69
  int v24; // eax@70
  PVOID v25; // eax@91
  int v26; // eax@93
  STRING DestinationString; // [sp+10h] [bp-70h]@38
  UNICODE_STRING SourceString; // [sp+18h] [bp-68h]@1
  ULONG v29; // [sp+20h] [bp-60h]@17
  int v30; // [sp+34h] [bp-4Ch]@1
  int v31; // [sp+38h] [bp-48h]@1
  ULONG ResultSize; // [sp+3Ch] [bp-44h]@24
  unsigned int v33; // [sp+40h] [bp-40h]@65
  ULONG MbSize; // [sp+44h] [bp-3Ch]@1
  int (__stdcall *v35)(unsigned int, DWORD, UNICODE_STRING *, int *, PVOID, ULONG *, int *); // [sp+48h] [bp-38h]@1
  int v36; // [sp+4Ch] [bp-34h]@12
  PWCHAR UnicodeString; // [sp+50h] [bp-30h]@1
  void *Src; // [sp+54h] [bp-2Ch]@1
  int v39; // [sp+58h] [bp-28h]@13
  ULONG Size; // [sp+5Ch] [bp-24h]@12
  LSTATUS v41; // [sp+60h] [bp-20h]@6
  char v42; // [sp+67h] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+68h] [bp-18h]@70

  SourceString.Length = 0;
  *(_DWORD *)&SourceString.MaximumLength = 0;
  HIWORD(SourceString.Buffer) = 0;
  UnicodeString = 0;
  v42 = 0;
  MbSize = 0;
  v30 = 0;
  Src = 0;
  v31 = 0;
  v35 = *(int (__stdcall **)(unsigned int, DWORD, UNICODE_STRING *, int *, PVOID, ULONG *, int *))(RegKrnGetGlobalState()
                                                                                                 + 72);
  if ( lpReserved || lpData && !lpcbData || !lpcchValueName || !lpValueName )
    return 87;
  v8 = hKey;
  v9 = RegKrnGetGlobalState();
  v41 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v9 + 176))(v8, &hKey, &v30, &v31);
  if ( !v41 )
  {
    SourceString.Length = 0;
    if ( 2 * *lpcchValueName + 2 > 0xFFFE )
      SourceString.MaximumLength = -2;
    else
      SourceString.MaximumLength = 2 * (*(_WORD *)lpcchValueName + 1);
    SourceString.Buffer = (PWCH)RtlAllocateHeap(
                                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                  0,
                                  SourceString.MaximumLength);
    if ( SourceString.Buffer )
    {
      if ( lpcbData )
        v10 = *lpcbData;
      else
        v10 = 0;
      Size = v10;
      v36 = 0;
      lpReserved = (LPDWORD)v10;
      if ( !((unsigned __int8)hKey & 1) )
      {
        v41 = LocalBaseRegEnumValue(hKey, dwIndex, (int)&SourceString, (int)&v39, (int)lpData, (int)&Size, (int)&v36);
LABEL_14:
        if ( v41 && v41 != 234 || !lpcbData || v39 != 1 && v39 != 2 && v39 != 7 )
        {
LABEL_30:
          if ( !v41 || v41 == 234 )
          {
            if ( lpcbData )
              *lpcbData = Size;
            if ( lpType )
              *lpType = v39;
          }
          if ( !v41 )
          {
            if ( SourceString.Length >= 2u )
              SourceString.Length -= 2;
            v15 = lpcchValueName;
            DestinationString.MaximumLength = *(_WORD *)lpcchValueName;
            DestinationString.Buffer = lpValueName;
            v16 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0);
            if ( v16 < 0 )
              v41 = RtlNtStatusToDosError(v16);
            else
              *v15 = DestinationString.Length;
          }
          goto LABEL_40;
        }
        lpReserved = (LPDWORD)Size;
        v29 = *lpcbData;
        UnicodeString = (PWCHAR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
        if ( !UnicodeString )
        {
          v41 = 8;
          v12 = MbSize;
LABEL_26:
          Size = v12;
          if ( lpData )
          {
            if ( *lpcbData > v12 && v12 > 0 )
            {
              v14 = &lpData[v12];
              if ( *(v14 - 1) )
                *v14 = 0;
            }
          }
          goto LABEL_30;
        }
        v36 = 0;
        if ( !((unsigned __int8)hKey & 1) )
        {
          v41 = LocalBaseRegEnumValue(
                  hKey,
                  dwIndex,
                  (int)&SourceString,
                  (int)&v39,
                  (int)UnicodeString,
                  (int)&Size,
                  (int)&v36);
LABEL_20:
          v11 = Size;
          if ( Size > (unsigned int)lpReserved )
            v11 = (ULONG)lpReserved;
          RtlUnicodeToMultiByteSize(&MbSize, UnicodeString, v11);
          v12 = MbSize;
          if ( MbSize > *lpcbData && lpData )
            v41 = 234;
          if ( !v41 && lpData )
          {
            ResultSize = 0;
            v13 = RtlUnicodeToMultiByteN((PCHAR)lpData, v29, &ResultSize, UnicodeString, (ULONG)lpReserved);
            if ( v13 < 0 )
              v41 = RtlNtStatusToDosError(v13);
            v12 = ResultSize;
            MbSize = ResultSize;
          }
          goto LABEL_26;
        }
        if ( !v35 )
          goto LABEL_20;
        if ( v42 )
        {
          v25 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size + 2);
          Src = v25;
          if ( !v25 )
          {
            v41 = 8;
            goto LABEL_20;
          }
          ms_exc.registration.TryLevel = 2;
          v26 = v35((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &SourceString, &v39, v25, &Size, &v36);
          v41 = v26;
          ms_exc.registration.TryLevel = -2;
          if ( v26 && v26 != 234 || Size <= 0x7FFF0000 )
          {
            if ( !v26 )
            {
              if ( (v39 == 1 || v39 == 7 || v39 == 2) && Size >= 2 )
                Size -= 2;
              if ( Size > (unsigned int)lpReserved )
                v41 = 13;
              else
                memcpy(UnicodeString, Src, Size);
            }
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
            Src = 0;
            goto LABEL_20;
          }
        }
        else
        {
          ms_exc.registration.TryLevel = 3;
          v41 = v35((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &SourceString, &v39, UnicodeString, &Size, &v36);
          ms_exc.registration.TryLevel = -2;
          if ( v41 && v41 != 234 || Size <= 0x7FFF0000 )
            goto LABEL_20;
        }
        goto LABEL_75;
      }
      if ( !v35 )
        goto LABEL_14;
      v33 = 0;
      v21 = (unsigned int)hKey & 0xFFFFFFFE;
      v22 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
      if ( !v22 || v22(v21, &v33) || v33 >= 5 && v33 <= 0xA )
      {
        v42 = 0;
        ms_exc.registration.TryLevel = 1;
        v41 = v35((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &SourceString, &v39, lpData, &Size, &v36);
        ms_exc.registration.TryLevel = -2;
        if ( v41 && v41 != 234 || Size <= 0x7FFF0000 )
          goto LABEL_14;
LABEL_75:
        v41 = 13;
        goto LABEL_40;
      }
      v42 = 1;
      v23 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size + 2);
      Src = v23;
      if ( v23 )
      {
        ms_exc.registration.TryLevel = 0;
        v24 = v35((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &SourceString, &v39, v23, &Size, &v36);
        v41 = v24;
        ms_exc.registration.TryLevel = -2;
        if ( v24 && v24 != 234 || Size <= 0x7FFF0000 )
        {
          if ( !v24 )
          {
            if ( (v39 == 1 || v39 == 7 || v39 == 2) && Size >= 2 )
              Size -= 2;
            if ( Size > (unsigned int)lpReserved )
              v41 = 13;
            else
              memcpy(lpData, Src, Size);
          }
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
          Src = 0;
          goto LABEL_14;
        }
        goto LABEL_75;
      }
    }
    v41 = 8;
  }
LABEL_40:
  if ( SourceString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, SourceString.Buffer);
  if ( UnicodeString )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, UnicodeString);
  if ( Src )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
  v17 = v31;
  v18 = v30;
  v19 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v19 + 168))(v18, v17);
  return v41;
}

//----- (77E18D63) --------------------------------------------------------
BOOL __stdcall FindCloseChangeNotificationStub(HANDLE hChangeHandle)
{
  return FindCloseChangeNotification(hChangeHandle);
}

//----- (77E18E60) --------------------------------------------------------
UINT __stdcall GetDriveTypeAStub(LPCSTR lpRootPathName)
{
  return GetDriveTypeA(lpRootPathName);
}

//----- (77E18E78) --------------------------------------------------------
BOOL __stdcall SetHandleInformationImplementation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
{
  PVOID v3; // eax@1
  BOOL result; // eax@5

  v3 = hObject;
  if ( hObject == (HANDLE)-12 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hObject == (HANDLE)-11 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hObject == (HANDLE)-10 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v3 & 0x10000003) == 3 )
    result = SetConsoleHandleInformation((int)v3, dwMask, dwFlags);
  else
    result = SetHandleInformation(v3, dwMask, dwFlags);
  return result;
}

//----- (77E18ECC) --------------------------------------------------------
BOOL __stdcall VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
{
  BOOL v2; // esi@1
  NTSTATUS v3; // eax@1

  v2 = 1;
  v3 = NtUnlockVirtualMemory((HANDLE)0xFFFFFFFF, &lpAddress, &dwSize, 1u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    v2 = 0;
  }
  return v2;
}

//----- (77E18F00) --------------------------------------------------------
BOOL __stdcall IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
{
  int v2; // esi@1
  unsigned int v3; // ecx@4
  UINT_PTR ucba; // [sp+38h] [bp+Ch]@3
  int ucbb; // [sp+38h] [bp+Ch]@4

  v2 = *(_DWORD *)(BaseStaticServerData + 300);
  if ( !ucb )
    return 0;
  if ( lp )
  {
    ucba = (UINT_PTR)((char *)lp + ucb - 1);
    if ( ucba >= (unsigned int)lp )
    {
      *(_BYTE *)lp = *(_BYTE *)lp;
      v3 = (unsigned int)lp & ~(v2 - 1);
      ucbb = ~(v2 - 1) & ucba;
      while ( v3 != ucbb )
      {
        v3 += v2;
        *(_BYTE *)v3 = *(_BYTE *)v3;
      }
      return 0;
    }
  }
  return 1;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E18F99) --------------------------------------------------------
HANDLE __stdcall CreateIoCompletionPortStub(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
{
  return CreateIoCompletionPort(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
}

//----- (77E18FB1) --------------------------------------------------------
LPSTR __stdcall lstrcpynStub(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
{
  return lstrcpynA(lpString1, lpString2, iMaxLength);
}

//----- (77E18FC9) --------------------------------------------------------
DWORD __stdcall QueueUserAPCStub(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
{
  return QueueUserAPC(pfnAPC, hThread, dwData);
}

//----- (77E18FE8) --------------------------------------------------------
int __thiscall CreateThreadpoolCleanupGroup(void *this)
{
  int v1; // eax@1
  int result; // eax@2
  int v3; // [sp+0h] [bp-4h]@1

  v3 = (int)this;
  v1 = TpAllocCleanupGroup(&v3);
  if ( v1 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v1);
    result = 0;
  }
  else
  {
    result = v3;
  }
  return result;
}
// 77DE102C: using guessed type int __stdcall TpAllocCleanupGroup(_DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E19012) --------------------------------------------------------
PTP_WORK __stdcall CreateThreadpoolWorkStub(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  return CreateThreadpoolWork(pfnwk, pv, pcbe);
}

//----- (77E1901F) --------------------------------------------------------
PTP_WORK __stdcall CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  int v3; // eax@1
  PTP_WORK result; // eax@2

  v3 = TpAllocWork(&pcbe, pfnwk, pv, pcbe);
  if ( v3 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v3);
    result = 0;
  }
  else
  {
    result = (PTP_WORK)pcbe;
  }
  return result;
}
// 77DE1024: using guessed type int __stdcall TpAllocWork(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E1904B) --------------------------------------------------------
DWORD __stdcall ExpandEnvironmentStringsAStub(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
{
  return ExpandEnvironmentStringsA(lpSrc, lpDst, nSize);
}

//----- (77E1906B) --------------------------------------------------------
BOOL __stdcall GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
{
  return RtlGetProductInfo(
           dwOSMajorVersion,
           dwOSMinorVersion,
           dwSpMajorVersion,
           dwSpMinorVersion,
           pdwReturnedProductType) != 0;
}

//----- (77E19097) --------------------------------------------------------
BOOL __stdcall GetCPInfoExWStub(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
{
  return GetCPInfoExW(CodePage, dwFlags, lpCPInfoEx);
}

//----- (77E190AF) --------------------------------------------------------
int __stdcall K32GetModuleBaseNameW(HANDLE hProcess, int Buffer, LPVOID lpBuffer, int a4)
{
  int result; // eax@1
  unsigned int v5; // edi@2
  unsigned int v6; // esi@2
  char v7; // [sp+0h] [bp-78h]@1
  unsigned __int16 v8; // [sp+2Ch] [bp-4Ch]@2
  LPCVOID lpBaseAddress; // [sp+30h] [bp-48h]@3

  result = FindModule(hProcess, Buffer, &v7);
  if ( result )
  {
    v5 = 2 * a4;
    v6 = v8 + 2;
    if ( 2 * a4 < v6 )
      v6 = 2 * a4;
    result = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, v6, 0);
    if ( result )
    {
      if ( v6 == v8 + 2 )
        v6 -= 2;
      if ( v6 >= v5 )
      {
        if ( v5 )
          *((_WORD *)lpBuffer + (v5 >> 1) - 1) = 0;
      }
      else
      {
        *((_WORD *)lpBuffer + (v6 >> 1)) = 0;
      }
      result = v6 >> 1;
    }
  }
  return result;
}

//----- (77E1912B) --------------------------------------------------------
int __stdcall K32GetModuleBaseNameA(HANDLE hProcess, int Buffer, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr)
{
  int v4; // esi@1
  HLOCAL v5; // eax@1
  int v6; // eax@2
  int v7; // edi@2
  int result; // eax@5
  const WCHAR *lpWideCharStra; // [sp+1Ch] [bp+14h]@1

  v4 = (int)lpWideCharStr;
  v5 = LocalAlloc(0, 2 * (_DWORD)lpWideCharStr);
  lpWideCharStra = (const WCHAR *)v5;
  if ( v5 )
  {
    v6 = K32GetModuleBaseNameW(hProcess, Buffer, v5, v4);
    v7 = v6;
    if ( v6 < (unsigned int)v4 )
      ++v6;
    if ( !WideCharToMultiByte(0, 0, lpWideCharStra, v6, lpMultiByteStr, v4, 0, 0) )
      v7 = 0;
    LocalFree((HLOCAL)lpWideCharStra);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E19195) --------------------------------------------------------
int __stdcall IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
{
  NTSTATUS v5; // eax@2
  ULONG v7; // ST10_4@7

  if ( dwFlags & 0xFFFFFFFC )
  {
    RtlSetLastWin32Error(1004);
  }
  else
  {
    v5 = RtlIdnToAscii(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, (PLONG)&cchASCIIChar);
    if ( v5 >= 0 )
      return cchASCIIChar;
    v7 = RtlNtStatusToDosError(v5);
    RtlSetLastWin32Error(v7);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E191D7) --------------------------------------------------------
LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
{
  LPCWSTR v2; // ecx@1
  LPWSTR v3; // edx@1
  const WCHAR v4; // ax@2

  v2 = lpString2;
  v3 = lpString1;
  do
  {
    v4 = *v2;
    *v3 = *v2;
    ++v2;
    ++v3;
  }
  while ( v4 );
  return lpString1;
}

//----- (77E19231) --------------------------------------------------------
int __stdcall lstrcmpStub(LPCSTR lpString1, LPCSTR lpString2)
{
  return lstrcmpA(lpString1, lpString2);
}

//----- (77E1923E) --------------------------------------------------------
int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = CompareStringA(0x400u, 0x40000000u, lpString1, -1, lpString2, -1);
  if ( v2 || (v2 = CompareStringA(0x800u, 0x40000000u, lpString1, -1, lpString2, -1)) != 0 )
  {
    result = v2 - 2;
  }
  else if ( lpString1 )
  {
    if ( lpString2 )
      result = strcmp(lpString1, lpString2);
    else
      result = 1;
  }
  else
  {
    result = -(lpString2 != 0);
  }
  return result;
}

//----- (77E19279) --------------------------------------------------------
DWORD __stdcall VerLanguageNameWStub(DWORD wLang, LPWSTR szLang, DWORD cchLang)
{
  return VerLanguageNameW(wLang, szLang, cchLang);
}

//----- (77E19291) --------------------------------------------------------
BOOL __stdcall GetFileAttributesExAStub(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
{
  return GetFileAttributesExA(lpFileName, fInfoLevelId, lpFileInformation);
}

//----- (77E192A9) --------------------------------------------------------
BOOL __stdcall SetFileAttributesAStub(LPCSTR lpFileName, DWORD dwFileAttributes)
{
  return SetFileAttributesA(lpFileName, dwFileAttributes);
}

//----- (77E192C1) --------------------------------------------------------
BOOL __stdcall CallbackMayRunLongStub(PTP_CALLBACK_INSTANCE pci)
{
  return CallbackMayRunLong(pci);
}

//----- (77E192CE) --------------------------------------------------------
BOOL __stdcall CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
{
  int v1; // eax@1
  BOOL result; // eax@2

  v1 = TpCallbackMayRunLong(pci);
  if ( v1 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1014: using guessed type int __stdcall TpCallbackMayRunLong(_DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E192F0) --------------------------------------------------------
DWORD __stdcall GetTimeZoneInformationStub(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
{
  return GetTimeZoneInformation(lpTimeZoneInformation);
}

//----- (77E19308) --------------------------------------------------------
BOOL __stdcall GlobalMemoryStatusExStub(LPMEMORYSTATUSEX lpBuffer)
{
  return GlobalMemoryStatusEx(lpBuffer);
}

//----- (77E19318) --------------------------------------------------------
DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
{
  return BasepGetTempPathW(0, nBufferLength, lpBuffer);
}

//----- (77E19333) --------------------------------------------------------
BOOL __stdcall IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
{
  LPCSTR v2; // eax@2
  const CHAR *i; // [sp+10h] [bp-1Ch]@3

  if ( !ucchMax )
    return 0;
  v2 = lpsz;
  if ( lpsz )
  {
    for ( i = lpsz; *v2 && i != &lpsz[ucchMax - 1]; v2 = i )
      ++i;
    return 0;
  }
  return 1;
}

//----- (77E193A2) --------------------------------------------------------
void __stdcall RtlUnwindStub(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue)
{
  RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

//----- (77E193B3) --------------------------------------------------------
LSTATUS __stdcall RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
  DWORD v12; // eax@44
  NTSTATUS v13; // eax@47
  LPDWORD v14; // edi@2
  HKEY v15; // esi@3
  int v16; // eax@3
  UNICODE_STRING *v17; // ebx@10
  LPDWORD v18; // esi@19
  PFILETIME v19; // eax@34
  int v20; // esi@37
  int v21; // edi@37
  int v22; // eax@37
  int v24; // eax@55
  unsigned int v25; // esi@72
  int (__stdcall *v26)(_DWORD, _DWORD); // eax@72
  __int16 v27; // [sp+10h] [bp-74h]@10
  __int16 v28; // [sp+12h] [bp-72h]@10
  int v29; // [sp+14h] [bp-70h]@10
  STRING DestinationString; // [sp+18h] [bp-6Ch]@45
  int v31; // [sp+20h] [bp-64h]@1
  DWORD v32; // [sp+24h] [bp-60h]@1
  UNICODE_STRING SourceString; // [sp+28h] [bp-5Ch]@1
  int v34; // [sp+34h] [bp-50h]@1
  int v35; // [sp+38h] [bp-4Ch]@1
  UNICODE_STRING *v36; // [sp+3Ch] [bp-48h]@10
  int (__stdcall *v37)(unsigned int, UNICODE_STRING *, int *, int *, unsigned int *, int *, int *, int *, DWORD *, int *); // [sp+40h] [bp-44h]@1
  int v38; // [sp+44h] [bp-40h]@1
  int v39; // [sp+48h] [bp-3Ch]@1
  int v40; // [sp+4Ch] [bp-38h]@1
  DWORD v41; // [sp+50h] [bp-34h]@1
  int v42; // [sp+54h] [bp-30h]@1
  int v43; // [sp+58h] [bp-2Ch]@1
  int v44; // [sp+5Ch] [bp-28h]@1
  unsigned int v45; // [sp+60h] [bp-24h]@1
  int v46; // [sp+64h] [bp-20h]@1
  LSTATUS v47; // [sp+68h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+6Ch] [bp-18h]@55

  v40 = 0;
  v44 = 0;
  v39 = 0;
  v46 = 0;
  v43 = 0;
  v31 = 0;
  v32 = 0;
  v34 = 0;
  v35 = 0;
  v45 = 0;
  v41 = 0;
  v42 = 0;
  v38 = 0;
  SourceString.Length = 0;
  *(_DWORD *)&SourceString.MaximumLength = 0;
  HIWORD(SourceString.Buffer) = 0;
  v37 = *(int (__stdcall **)(unsigned int, UNICODE_STRING *, int *, int *, unsigned int *, int *, int *, int *, DWORD *, int *))(RegKrnGetGlobalState() + 76);
  if ( lpReserved )
    return 87;
  v14 = lpcchClass;
  if ( lpClass )
  {
    if ( !lpcchClass )
      return 87;
  }
  v15 = hKey;
  v16 = RegKrnGetGlobalState();
  v47 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v16 + 176))(v15, &hKey, &v34, &v35);
  if ( !v47 )
  {
    if ( !lpClass && v14 )
      *v14 = 0;
    if ( lpcbMaxClassLen )
      v42 = (int)&v45;
    if ( lpcbSecurityDescriptor )
      v38 = (int)&v41;
    if ( lpClass && *v14 )
    {
      v17 = &SourceString;
      v36 = &SourceString;
      SourceString.Buffer = (PWCH)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x208u);
      if ( !SourceString.Buffer )
      {
        v47 = 14;
        goto LABEL_36;
      }
      SourceString.Length = 0;
      SourceString.MaximumLength = 520;
    }
    else
    {
      v17 = (UNICODE_STRING *)&v27;
      v36 = (UNICODE_STRING *)&v27;
      v27 = 0;
      v28 = 0;
      v29 = 0;
    }
    if ( !((unsigned __int8)hKey & 1) )
    {
      v47 = LocalBaseRegQueryInfoKey(
              hKey,
              (int)v17,
              (int)&v40,
              (int)&v44,
              v42,
              (int)&v39,
              (int)&v46,
              (int)&v43,
              v38,
              (int)&v31);
      goto LABEL_13;
    }
    if ( !v37 )
    {
LABEL_13:
      v44 = (unsigned int)v44 >> 1;
      if ( v42 )
        v45 >>= 1;
      v46 = (unsigned int)v46 >> 1;
      if ( v17->Length >= 2u )
        v17->Length -= 2;
      if ( !v47 && lpClass )
      {
        v18 = lpcchClass;
        v12 = *lpcchClass;
        if ( *lpcchClass )
        {
          DestinationString.MaximumLength = -1;
          if ( v12 <= 0xFFFF )
            DestinationString.MaximumLength = v12;
          DestinationString.Buffer = lpClass;
          v13 = RtlUnicodeStringToAnsiString(&DestinationString, v17, 0);
          *v18 = DestinationString.Length;
          v47 = RtlNtStatusToDosError(v13);
          goto LABEL_21;
        }
      }
      else
      {
        v18 = lpcchClass;
      }
      if ( v18 )
      {
        if ( v17->Length )
          *v18 = (unsigned int)v17->Length >> 1;
        else
          *v18 = 0;
      }
LABEL_21:
      if ( lpcSubKeys )
        *lpcSubKeys = v40;
      if ( lpcbMaxSubKeyLen )
        *lpcbMaxSubKeyLen = v44;
      if ( lpcbMaxClassLen )
        *lpcbMaxClassLen = v45;
      if ( lpcValues )
        *lpcValues = v39;
      if ( lpcbMaxValueNameLen )
        *lpcbMaxValueNameLen = v46;
      if ( lpcbMaxValueLen )
        *lpcbMaxValueLen = v43;
      if ( lpcbSecurityDescriptor )
        *lpcbSecurityDescriptor = v41;
      v19 = lpftLastWriteTime;
      if ( lpftLastWriteTime )
      {
        lpftLastWriteTime->dwLowDateTime = v31;
        v19->dwHighDateTime = v32;
      }
      goto LABEL_36;
    }
    v42 = (int)&v45;
    ms_exc.registration.TryLevel = 0;
    v24 = v37((unsigned int)hKey & 0xFFFFFFFE, v17, &v40, &v44, &v45, &v39, &v46, &v43, &v41, &v31);
    v47 = v24;
    ms_exc.registration.TryLevel = -2;
    if ( (v24 && v24 != 234 || (unsigned int)v44 <= 0x7FFF0000)
      && (v24 && v24 != 234 || v45 <= 0x7FFF0000)
      && (v24 && v24 != 234 || (unsigned int)v46 <= 0x7FFF0000)
      && (v24 && v24 != 234 || (unsigned int)v43 <= 0x7FFF0000)
      && (v24 && v24 != 234 || v41 <= 0x7FFF0000) )
    {
      if ( !v24 )
      {
        lpReserved = 0;
        v25 = (unsigned int)hKey & 0xFFFFFFFE;
        v26 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
        if ( v26 )
        {
          if ( !v26(v25, &lpReserved) && ((unsigned int)lpReserved < 5 || (unsigned int)lpReserved > 0xA) )
          {
            v46 *= 2;
            v43 *= 2;
          }
        }
      }
      goto LABEL_13;
    }
    v47 = 13;
  }
LABEL_36:
  if ( SourceString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, SourceString.Buffer);
  v20 = v35;
  v21 = v34;
  v22 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v22 + 168))(v21, v20);
  return v47;
}

//----- (77E19599) --------------------------------------------------------
BOOL __stdcall SetFileInformationByHandleStub(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
{
  return SetFileInformationByHandle(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
}

//----- (77E198A1) --------------------------------------------------------
int __stdcall BaseRegNotifyClassKey(HANDLE a1, int a2, int a3, ULONG NotifyFilter, BOOLEAN WatchSubtree, BOOLEAN Asynchronous)
{
  int result; // eax@1
  int v7; // esi@2
  HANDLE v8; // eax@3
  NTSTATUS v9; // eax@7
  OBJECT_ATTRIBUTES KeyObjectAttributes; // [sp+Ch] [bp-1DCh]@2
  UNICODE_STRING Source; // [sp+24h] [bp-1C4h]@1
  int v12; // [sp+2Ch] [bp-1BCh]@1
  int v13; // [sp+30h] [bp-1B8h]@1
  int v14; // [sp+34h] [bp-1B4h]@1
  int v15; // [sp+38h] [bp-1B0h]@1
  char *v16; // [sp+3Ch] [bp-1ACh]@1
  int v17; // [sp+40h] [bp-1A8h]@2
  PIO_STATUS_BLOCK IoStatusBlock; // [sp+44h] [bp-1A4h]@1
  HANDLE EventHandle; // [sp+48h] [bp-1A0h]@1
  HANDLE KeyHandle; // [sp+4Ch] [bp-19Ch]@1
  HANDLE Handle; // [sp+50h] [bp-198h]@2
  HANDLE v22; // [sp+54h] [bp-194h]@2
  char v23; // [sp+58h] [bp-190h]@1
  char Dst; // [sp+59h] [bp-18Fh]@1

  EventHandle = (HANDLE)a2;
  IoStatusBlock = (PIO_STATUS_BLOCK)a3;
  v13 = 0;
  v14 = 0;
  Source.Length = 0;
  *(_DWORD *)&Source.MaximumLength = 0;
  HIWORD(Source.Buffer) = 0;
  KeyHandle = a1;
  v23 = 0;
  memset(&Dst, 0, 0x189u);
  v12 = 0;
  v16 = &v23;
  v15 = 394;
  result = BaseRegGetKeySemantics(a1, &Source, (int)&v12);
  if ( result < 0 )
    return result;
  Handle = 0;
  v22 = 0;
  v17 = 0;
  KeyObjectAttributes.ObjectName = 0;
  v7 = BaseRegGetUserAndMachineClass((int)&v12, a1, 16, (int)&Handle, (int)&v22);
  if ( v7 >= 0 )
  {
    v8 = Handle;
    if ( !WatchSubtree )
    {
      if ( Handle )
      {
        if ( v22 )
          goto LABEL_6;
      }
      else
      {
        v8 = v22;
      }
      v9 = NtNotifyChangeKey(v8, EventHandle, 0, 0, IoStatusBlock, NotifyFilter, 0, 0, 0, Asynchronous);
LABEL_8:
      v7 = v9;
      goto LABEL_9;
    }
LABEL_6:
    v7 = BaseRegGetBestAncestor((int)&v12, (int)Handle, (int)v22, &KeyObjectAttributes);
    v17 = KeyObjectAttributes.ObjectName != 0;
    if ( v7 < 0 )
      goto LABEL_9;
    v9 = NtNotifyChangeMultipleKeys(
           KeyHandle,
           1u,
           &KeyObjectAttributes,
           EventHandle,
           0,
           0,
           IoStatusBlock,
           NotifyFilter,
           WatchSubtree,
           0,
           0,
           Asynchronous);
    goto LABEL_8;
  }
LABEL_9:
  if ( Handle && Handle != KeyHandle )
    NtClose(Handle);
  if ( v22 && v22 != KeyHandle )
    NtClose(v22);
  if ( v17 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, KeyObjectAttributes.ObjectName);
  return v7;
}

//----- (77E19B5E) --------------------------------------------------------
int __stdcall BasepCopyFileExW(const WCHAR *a1, const WCHAR *a2, int a3, int a4, int a5, __int64 a6, int a7, int a8, int a9)
{
  int v9; // esi@1
  int v10; // eax@7
  int v11; // ecx@9
  DWORD v12; // esi@9
  DWORD v13; // edi@9
  NTSTATUS v14; // eax@18
  ULONG v15; // esi@27
  int v16; // eax@35
  PVOID v17; // edi@38
  __int64 *v18; // esi@38
  PVOID v20; // eax@69
  signed int v21; // eax@77
  NTSTATUS v22; // eax@88
  unsigned int v23; // eax@90
  __int16 v24; // si@90
  HANDLE v25; // eax@110
  void *v26; // esi@110
  int v27; // esi@123
  int v28; // eax@134
  unsigned __int8 v29; // cf@134
  int v30; // eax@134
  HANDLE v31; // esi@145
  HANDLE v32; // eax@157
  int v33; // ST30_4@162
  int v34; // ST2C_4@162
  int v35; // ST20_4@162
  int v36; // eax@162
  struct _TEB *v37; // eax@163
  char FileInformation; // [sp+10h] [bp-3ACh]@21
  __int64 v39; // [sp+18h] [bp-3A4h]@25
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+28h] [bp-394h]@87
  __int64 v41; // [sp+40h] [bp-37Ch]@25
  int v42; // [sp+48h] [bp-374h]@25
  int v43; // [sp+4Ch] [bp-370h]@25
  int v44; // [sp+50h] [bp-36Ch]@25
  int v45; // [sp+54h] [bp-368h]@25
  int v46; // [sp+58h] [bp-364h]@25
  int v47; // [sp+5Ch] [bp-360h]@25
  int v48; // [sp+60h] [bp-35Ch]@22
  int v49; // [sp+64h] [bp-358h]@34
  int v50; // [sp+68h] [bp-354h]@34
  int v51; // [sp+6Ch] [bp-350h]@34
  int v52; // [sp+70h] [bp-34Ch]@116
  int v53; // [sp+74h] [bp-348h]@116
  int v54; // [sp+80h] [bp-33Ch]@23
  char VolumeInformation; // [sp+88h] [bp-334h]@18
  int v56; // [sp+8Ch] [bp-330h]@19
  char v57; // [sp+90h] [bp-32Ch]@13
  int v58; // [sp+94h] [bp-328h]@35
  DWORD v59; // [sp+98h] [bp-324h]@153
  int v60; // [sp+9Ch] [bp-320h]@153
  DWORD NumberOfBytesWritten; // [sp+A0h] [bp-31Ch]@150
  int v62; // [sp+A4h] [bp-318h]@1
  int v63; // [sp+A8h] [bp-314h]@1
  DWORD v64; // [sp+ACh] [bp-310h]@9
  DWORD v65; // [sp+B0h] [bp-30Ch]@9
  char v66; // [sp+B4h] [bp-308h]@35
  ULONG Flags; // [sp+B8h] [bp-304h]@27
  __int16 Buffer; // [sp+BCh] [bp-300h]@35
  __int16 v69; // [sp+BEh] [bp-2FEh]@116
  int v70; // [sp+C0h] [bp-2FCh]@73
  int v71; // [sp+C4h] [bp-2F8h]@116
  int v72; // [sp+C8h] [bp-2F4h]@116
  int v73; // [sp+CCh] [bp-2F0h]@116
  int v74; // [sp+D0h] [bp-2ECh]@116
  __int64 v75; // [sp+D4h] [bp-2E8h]@116
  __int64 v76; // [sp+DCh] [bp-2E0h]@74
  int v77; // [sp+E4h] [bp-2D8h]@86
  int v78; // [sp+E8h] [bp-2D4h]@86
  unsigned int v79; // [sp+ECh] [bp-2D0h]@86
  int v80; // [sp+F4h] [bp-2C8h]@23
  int v81; // [sp+F8h] [bp-2C4h]@90
  int v82; // [sp+FCh] [bp-2C0h]@1
  int v83; // [sp+100h] [bp-2BCh]@1
  int v84; // [sp+104h] [bp-2B8h]@1
  int v85; // [sp+108h] [bp-2B4h]@1
  int v86; // [sp+10Ch] [bp-2B0h]@9
  __int64 v87; // [sp+110h] [bp-2ACh]@72
  DWORD NumberOfBytesRead; // [sp+118h] [bp-2A4h]@148
  int v89; // [sp+11Ch] [bp-2A0h]@1
  int v90; // [sp+120h] [bp-29Ch]@1
  int v91; // [sp+124h] [bp-298h]@1
  DWORD nNumberOfBytesToRead; // [sp+128h] [bp-294h]@145
  ULONG Size; // [sp+12Ch] [bp-290h]@26
  HANDLE Handle; // [sp+130h] [bp-28Ch]@88
  unsigned __int16 v95; // [sp+134h] [bp-288h]@87
  unsigned __int16 v96; // [sp+136h] [bp-286h]@87
  char *v97; // [sp+138h] [bp-284h]@87
  LPCWSTR lpFileName; // [sp+13Ch] [bp-280h]@1
  HANDLE v99; // [sp+140h] [bp-27Ch]@90
  unsigned int v100; // [sp+144h] [bp-278h]@38
  DWORD dwShareMode; // [sp+148h] [bp-274h]@10
  LPCWSTR lpszVolumeMountPoint; // [sp+14Ch] [bp-270h]@1
  PVOID v103; // [sp+150h] [bp-26Ch]@38
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+154h] [bp-268h]@18
  ULONG CreateOptions; // [sp+15Ch] [bp-260h]@87
  int v106; // [sp+160h] [bp-25Ch]@1
  char v107; // [sp+166h] [bp-256h]@38
  char v108; // [sp+167h] [bp-255h]@38
  __int64 *v109; // [sp+168h] [bp-254h]@1
  DWORD dwDesiredAccess; // [sp+16Ch] [bp-250h]@10
  PVOID Address; // [sp+170h] [bp-24Ch]@1
  HANDLE FileHandle; // [sp+174h] [bp-248h]@1
  DWORD dwFlagsAndAttributes; // [sp+178h] [bp-244h]@9
  int v114; // [sp+17Ch] [bp-240h]@1
  NTSTATUS NtStatus; // [sp+180h] [bp-23Ch]@13
  HANDLE hObject; // [sp+184h] [bp-238h]@1
  int v117; // [sp+188h] [bp-234h]@77
  CPPEH_RECORD ms_exc; // [sp+3A4h] [bp-18h]@4

  lpFileName = a1;
  lpszVolumeMountPoint = a2;
  v91 = a3;
  v83 = a4;
  v89 = a5;
  v62 = a7;
  v63 = a8;
  v9 = a9;
  hObject = (HANDLE)-1;
  FileHandle = (HANDLE)-1;
  v114 = 0;
  v82 = 0;
  v85 = 0;
  v106 = 0;
  Address = 0;
  v109 = 0;
  v90 = 0;
  v84 = 0;
  if ( a6 & 0xFFFFE7F0 || HIDWORD(a6) & 0xFFFFF80F )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  LODWORD(a6) = HIDWORD(a6) | a6;
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return 0;
  }
  RtlSetCurrentTransaction(v9);
  ms_exc.registration.TryLevel = 0;
  if ( !(a6 & 0x1000) && BasepCopyCheckNoBuffering() )
    LODWORD(a6) = a6 | 0x1000;
  if ( a6 & 2 )
  {
    LODWORD(a6) = a6 & 0xFFFFEFFF;
    v10 = 0;
    dword_77EA6544 = 0;
  }
  else
  {
    v10 = dword_77EA6544;
  }
  if ( a6 & 0x180 )
    v90 = 0x2000000;
  v11 = a6 & 0x20;
  v12 = (v11 | ((a6 & 0xFC | 0xFFFFFFF8) << 9)) << 19;
  v64 = (v11 | ((a6 & 0xFC | 0xFFFFFFF8) << 9)) << 19;
  dwFlagsAndAttributes = ((a6 & 0x1000) << 17) | v90 | v10 | 0x8200000;
  v86 = 0;
  v13 = 5;
  v65 = 5;
LABEL_10:
  while ( 2 )
  {
    dwDesiredAccess = v12;
    dwShareMode = v13;
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            hObject = CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, 0, 3u, dwFlagsAndAttributes, 0);
            if ( hObject == (HANDLE)-1 )
              break;
            if ( v86 )
              goto LABEL_170;
            v86 = 1;
            NtStatus = BasepProcessNameGrafting(
                         hObject,
                         (int)&v82,
                         (int)&v85,
                         (int)&v106,
                         &v57,
                         ((unsigned int)a6 >> 11) & 1);
            if ( NtStatus < 0 )
            {
              CloseHandle(hObject);
              hObject = (HANDLE)-1;
              BaseSetLastNTError(NtStatus);
              goto LABEL_46;
            }
            if ( v82 )
            {
              v25 = CreateEventW(0, 0, 0, 0);
              v26 = v25;
              if ( v25 )
              {
                NtStatus = CopyNameGraftNow(
                             hObject,
                             (int)lpFileName,
                             lpszVolumeMountPoint,
                             (unsigned __int8)(BYTE4(a6) & 0x80) != 0 ? 0x4001 : 0,
                             v91,
                             v83,
                             v89,
                             (int)&a6,
                             v25);
                CloseHandle(v26);
                CloseHandle(hObject);
                hObject = (HANDLE)-1;
                v114 = NtStatus != 0;
              }
              else
              {
                CloseHandle(hObject);
                hObject = (HANDLE)-1;
              }
              goto LABEL_46;
            }
            if ( v85 )
            {
LABEL_170:
              if ( a6 & 2 || dwFlagsAndAttributes & 0x20000000 )
                goto LABEL_21;
              v14 = NtQueryVolumeInformationFile(
                      hObject,
                      &IoStatusBlock,
                      &VolumeInformation,
                      8u,
                      FileFsDeviceInformation);
              NtStatus = v14;
              if ( v14 < 0 )
                goto LABEL_68;
              if ( !(v56 & 0x10) || v56 & 0x1000 )
              {
                if ( !(dwFlagsAndAttributes & 0x40000000) )
                  goto LABEL_21;
                CloseHandle(hObject);
                hObject = (HANDLE)-1;
                dwFlagsAndAttributes &= 0xBFFFFFFF;
                dword_77EA6544 = 0;
              }
              else
              {
                if ( dwFlagsAndAttributes & 0x40000000 )
                {
                  BasepDisableLocalFileBuffering(hObject);
                  BasepEnableRemotePrefetch(hObject);
LABEL_21:
                  v14 = NtQueryInformationFile(
                          hObject,
                          &IoStatusBlock,
                          &FileInformation,
                          0x18u,
                          FileStandardInformation);
                  NtStatus = v14;
                  if ( v14 < 0
                    || (v14 = NtQueryInformationFile(hObject, &IoStatusBlock, &v48, 0x28u, FileBasicInformation),
                        NtStatus = v14,
                        v14 < 0) )
                  {
LABEL_68:
                    BaseSetLastNTError(v14);
                    goto LABEL_46;
                  }
                  v80 = v54;
                  if ( v91 || v89 )
                  {
                    v41 = v39;
                    v42 = 0;
                    v43 = 0;
                    v44 = 0;
                    v45 = v89;
                    v46 = v83;
                    v47 = v91;
                    v109 = &v41;
                  }
                  Size = 4096;
                  do
                  {
                    Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
                    v15 = Size;
                    Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, Size);
                    if ( !Address )
                    {
                      BaseSetLastNTError(-1073741801);
                      goto LABEL_46;
                    }
                    NtStatus = NtQueryInformationFile(hObject, &IoStatusBlock, Address, v15 - 2, FileStreamInformation);
                    if ( NtStatus < 0 )
                    {
                      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                      Address = 0;
                      Size *= 2;
                    }
                    else if ( !IoStatusBlock.Information )
                    {
                      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                      Address = 0;
                    }
                  }
                  while ( NtStatus == -2147483643 || NtStatus == -1073741789 );
                  if ( v91 || a6 & 2 )
                  {
                    if ( a6 & 2 )
                    {
                      Buffer = 31387;
                      v69 = 56;
                      v71 = v48;
                      v72 = v49;
                      v73 = v52;
                      v74 = v53;
                      v75 = v39;
                      v76 = v39;
                      v70 = 0;
                      v79 = 0;
                      v77 = 0;
                      v78 = 0;
                    }
                    v20 = Address;
                    if ( Address )
                    {
                      v87 = 0i64;
                      while ( 1 )
                      {
                        v103 = v20;
                        v87 += *((_QWORD *)v20 + 1);
                        ++v70;
                        if ( !*(_DWORD *)v20 )
                          break;
                        v20 = (char *)v20 + *(_DWORD *)v20;
                      }
                      v41 = v87;
                      v76 = v87;
                      --v70;
                    }
                  }
                  v48 = 0;
                  v49 = 0;
                  v50 = 0;
                  v51 = 0;
                  v54 = 0;
                  if ( a6 & 2 && (v76 < 0x80000 || v80 & 0x10) )
                    LODWORD(a6) = a6 & 0xFFFFFFFD;
                  v16 = BaseCopyStream(
                          lpFileName,
                          hObject,
                          dwDesiredAccess,
                          lpszVolumeMountPoint,
                          0,
                          &v39,
                          &a6,
                          &FileHandle,
                          &v66,
                          &v109,
                          &Buffer,
                          v106,
                          v58,
                          &v84);
                  v114 = v16;
                  if ( !v106 )
                  {
LABEL_36:
                    if ( v114 )
                      goto LABEL_37;
                    goto LABEL_46;
                  }
                  if ( v16 )
                  {
LABEL_37:
                    if ( !Address )
                    {
LABEL_42:
                      if ( v114 )
                      {
                        if ( a6 & 2 )
                        {
                          SetFilePointer(hObject, 0, 0, 0);
                          v31 = FileHandle;
                          SetFilePointer(FileHandle, 0, 0, 0);
                          nNumberOfBytesToRead = 56;
                          if ( (unsigned int)(((unsigned __int64)(v39 - 1) >> 32) - 1) <= 0
                            && (unsigned int)(v39 - 1) <= 0x36 )
                            nNumberOfBytesToRead = v39;
                          v114 = ReadFile(hObject, &Buffer, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
                          if ( !v114
                            || NumberOfBytesRead != nNumberOfBytesToRead
                            || (v114 = WriteFile(v31, &Buffer, NumberOfBytesRead, &NumberOfBytesWritten, 0)) == 0
                            || NumberOfBytesRead != NumberOfBytesWritten
                            || NumberOfBytesRead < 0x38
                            && (v59 = NumberOfBytesWritten,
                                v60 = 0,
                                NtStatus = NtSetInformationFile(v31, &IoStatusBlock, &v59, 8u, FileEndOfFileInformation),
                                NtStatus < 0) )
                          {
                            BaseMarkFileForDelete(v31, 0);
                            v114 = 0;
                          }
                        }
                        if ( v114 )
                        {
                          NtStatus = NtSetInformationFile(FileHandle, &IoStatusBlock, &v48, 0x28u, FileBasicInformation);
                          if ( NtStatus == -1073741757 )
                          {
                            CloseHandle(FileHandle);
                            FileHandle = (HANDLE)-1;
                            CreateOptions = 128;
                            if ( v106 )
                              CreateOptions = 2097280;
                            v32 = CreateFileW(lpszVolumeMountPoint, 0x100u, 0, 0, 3u, CreateOptions | v90, 0);
                            FileHandle = v32;
                            if ( v32 != (HANDLE)-1 )
                              NtSetInformationFile(v32, &IoStatusBlock, &v48, 0x28u, FileBasicInformation);
                          }
                        }
                      }
                      goto LABEL_46;
                    }
                    v100 = 0;
                    v107 = 0;
                    v108 = 0;
                    v17 = Address;
                    v103 = Address;
                    v18 = v109;
                    while ( 2 )
                    {
                      NtStatus = 0;
                      if ( *((_DWORD *)v17 + 1) <= 2u || *((_WORD *)v17 + 13) == 58 )
                      {
LABEL_41:
                        if ( !*(_DWORD *)v17 )
                          goto LABEL_42;
                        v17 = (char *)v17 + *(_DWORD *)v17;
                        v103 = v17;
                        continue;
                      }
                      break;
                    }
                    ++v100;
                    if ( v114 == 2 && v18 )
                    {
                      if ( v100 >= v79 )
                      {
                        v29 = __CFADD__(v77, *((_DWORD *)v18 + 2));
                        *((_DWORD *)v18 + 2) += v77;
                        v30 = v78;
                      }
                      else
                      {
                        v28 = *((_DWORD *)v17 + 2);
                        v29 = __CFADD__(v28, *((_DWORD *)v18 + 2));
                        *((_DWORD *)v18 + 2) += v28;
                        v30 = *((_DWORD *)v17 + 3);
                      }
                      *((_DWORD *)v18 + 3) += v30 + v29;
                    }
                    if ( !v107 )
                    {
                      v107 = 1;
                      v21 = NtQueryVolumeInformationFile(
                              FileHandle,
                              &IoStatusBlock,
                              &v117,
                              0x218u,
                              FileFsAttributeInformation);
                      NtStatus = v21;
                      if ( v21 >= 0 )
                      {
                        if ( v117 & 0x40000 )
                        {
                          v21 = NtQueryVolumeInformationFile(
                                  hObject,
                                  &IoStatusBlock,
                                  &v117,
                                  0x218u,
                                  FileFsAttributeInformation);
                          NtStatus = v21;
                        }
                        if ( v21 >= 0 )
                        {
                          if ( v117 & 0x40000 )
                          {
                            v108 = 1;
                            goto LABEL_83;
                          }
                          if ( v21 >= 0 )
                          {
                            v21 = -1073741637;
                            NtStatus = -1073741637;
                          }
                        }
                      }
                      if ( a6 & 0x7F0 )
                      {
                        v33 = (int)FileHandle;
                        v34 = (int)hObject;
                        v35 = (int)v109;
                        v36 = RtlNtStatusToDosError(v21);
                        if ( !BasepCopyFileCallback(1, v36, v35, 0, 2, v34, v33, 0) )
                        {
                          v37 = NtCurrentTeb();
                          if ( v37 )
                            NtStatus = *(_DWORD *)&v37->Reserved3[1412];
                          else
                            NtStatus = -1073741811;
                          v114 = 0;
                          v17 = v103;
                          goto LABEL_94;
                        }
                      }
LABEL_83:
                      NtStatus = 0;
                      v18 = v109;
                    }
                    if ( v114 == 1 || v114 == 2 && v79 == v100 )
                    {
                      if ( v114 != 2 )
                      {
                        v79 = v100;
                        v77 = 0;
                        v78 = 0;
                      }
                      v97 = (char *)v17 + 24;
                      v95 = *((_WORD *)v17 + 2);
                      v96 = v95;
                      ObjectAttributes.Length = 24;
                      ObjectAttributes.RootDirectory = hObject;
                      ObjectAttributes.Attributes = 0;
                      ObjectAttributes.ObjectName = (PUNICODE_STRING)&v95;
                      ObjectAttributes.SecurityDescriptor = 0;
                      ObjectAttributes.SecurityQualityOfService = 0;
                      CreateOptions = 36;
                      if ( v106 )
                        CreateOptions = 2097188;
                      v22 = NtCreateFile(
                              &Handle,
                              0x80100000,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              0,
                              0,
                              1u,
                              1u,
                              CreateOptions,
                              0,
                              0);
                      NtStatus = v22;
                      if ( v22 == -1073741757 )
                      {
                        v22 = NtCreateFile(
                                &Handle,
                                0x80100000,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                0,
                                0,
                                3u,
                                1u,
                                CreateOptions,
                                0,
                                0);
                        NtStatus = v22;
                      }
                      if ( v22 >= 0 )
                      {
                        v23 = (unsigned int)&v97[2 * ((unsigned int)v95 >> 1)];
                        v24 = *(_WORD *)v23;
                        *(_WORD *)v23 = 0;
                        v99 = 0;
                        v81 = a6 & 0xFFFFEFFE;
                        v114 = BaseCopyStream(
                                 lpFileName,
                                 Handle,
                                 dwDesiredAccess,
                                 v97,
                                 FileHandle,
                                 (char *)v17 + 8,
                                 &v81,
                                 &v99,
                                 &v66,
                                 &v109,
                                 &Buffer,
                                 v106,
                                 v58,
                                 &v84);
                        *(_WORD *)&v97[2 * ((unsigned int)v95 >> 1)] = v24;
                        NtClose(Handle);
                        if ( v99 )
                        {
                          if ( v114 )
                            NtStatus = NtSetInformationFile(v99, &IoStatusBlock, &v48, 0x28u, FileBasicInformation);
                          NtClose(v99);
                        }
LABEL_94:
                        v18 = v109;
                      }
                    }
                    if ( NtStatus < 0 )
                    {
                      v114 = 0;
                      BaseSetLastNTError(NtStatus);
                    }
                    if ( !v114 )
                    {
                      if ( v108 )
                      {
                        BaseMarkFileForDelete(FileHandle, 0);
                        goto LABEL_42;
                      }
                      NtStatus = 0;
                      v114 = 1;
                    }
                    goto LABEL_41;
                  }
                  if ( GetLastError() == 80 && a6 & 1 )
                    goto LABEL_36;
                  v27 = v80 & 1;
                  if ( !(v80 & 1) )
                    BaseMarkFileForDelete(FileHandle, 128);
                  if ( FileHandle != (HANDLE)-1 )
                  {
                    CloseHandle(FileHandle);
                    FileHandle = (HANDLE)-1;
                  }
                  if ( v27 )
                  {
                    SetFileAttributesW(lpszVolumeMountPoint, 0x80u);
                    DeleteFileW(lpszVolumeMountPoint);
                  }
                  if ( hObject != (HANDLE)-1 )
                  {
                    CloseHandle(hObject);
                    hObject = (HANDLE)-1;
                  }
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                  Address = 0;
                  dwFlagsAndAttributes &= 0xFFDFFFFF;
                  v106 = 0;
                  v13 = v65;
                  v12 = v64;
                  goto LABEL_10;
                }
                CloseHandle(hObject);
                hObject = (HANDLE)-1;
                dwFlagsAndAttributes |= 0x40000000u;
                dword_77EA6544 = 0x40000000;
              }
            }
            else
            {
              dwFlagsAndAttributes &= 0xFFDFFFFF;
              CloseHandle(hObject);
              hObject = (HANDLE)-1;
            }
          }
          if ( GetLastError() != 1314 && GetLastError() != 5 || !(dwDesiredAccess & 0x1000000) )
            break;
          dwDesiredAccess &= 0xFEFFFFFF;
        }
        if ( GetLastError() != 5 && GetLastError() != 32 || !(dwDesiredAccess & 0x40000000) )
          break;
        dwDesiredAccess &= 0xBFFFFFFF;
        if ( v12 & 0x1000000 )
          dwDesiredAccess |= 0x1000000u;
      }
      if ( dwShareMode & 2 )
        break;
      dwShareMode |= 2u;
      dwDesiredAccess = v12;
      dwFlagsAndAttributes &= 0xDFFFFFFF;
      LODWORD(a6) = a6 & 0xFFFFEFFF;
    }
    if ( dwFlagsAndAttributes & 0x200000 )
    {
      dwFlagsAndAttributes &= 0xFFDFFFFF;
      continue;
    }
    break;
  }
LABEL_46:
  ms_exc.registration.TryLevel = -2;
  *(_DWORD *)v62 = hObject;
  *(_DWORD *)v63 = FileHandle;
  RtlSetCurrentTransaction(0);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v114;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E1A625: using guessed type _DWORD __stdcall BaseCopyStream(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);
// 77EA6544: using guessed type int dword_77EA6544;

//----- (77E1A089) --------------------------------------------------------
int __stdcall BasepCopyCheckNoBuffering()
{
  ULONG ResultLength; // [sp+0h] [bp-20h]@4
  HANDLE KeyHandle; // [sp+4h] [bp-1Ch]@3
  char KeyValueInformation; // [sp+8h] [bp-18h]@4
  int v4; // [sp+Ch] [bp-14h]@7
  int v5; // [sp+10h] [bp-10h]@8
  int v6; // [sp+14h] [bp-Ch]@9

  if ( !dword_77EA6564 )
  {
    if ( NtOpenKey(&KeyHandle, 1u, &ObjectAttributes) >= 0 )
    {
      if ( NtQueryValueKey(
             KeyHandle,
             &ValueName,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength) >= 0
        && v4 == 4
        && v5 == 4
        && !v6 )
        dword_77EA6BD8 = 1;
      NtClose(KeyHandle);
    }
    dword_77EA6564 = 1;
  }
  return dword_77EA6BD8;
}
// 77EA6564: using guessed type int dword_77EA6564;
// 77EA6BD8: using guessed type int dword_77EA6BD8;

//----- (77E1A32B) --------------------------------------------------------
int __stdcall BasepSelectReadyChunk(int *a1, unsigned int a2, int a3)
{
  DWORD v3; // eax@13
  unsigned int v4; // edi@1
  DWORD v5; // esi@1
  int *v6; // edx@3
  int v7; // eax@4
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@1
  int v11; // [sp+14h] [bp-14h]@1
  HANDLE Handles; // [sp+18h] [bp-10h]@1
  int v13; // [sp+1Ch] [bp-Ch]@1
  int v14; // [sp+20h] [bp-8h]@1
  int v15; // [sp+24h] [bp-4h]@1
  unsigned int v16; // [sp+34h] [bp+Ch]@2

  v9 = 0;
  v10 = 0;
  v11 = 0;
  Handles = 0;
  v13 = 0;
  v14 = 0;
  v4 = a2;
  v5 = 0;
  v15 = 1;
  *(_DWORD *)a3 = 0;
  if ( a2 > 3 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    v16 = 0;
    if ( v4 <= 0 )
    {
LABEL_7:
      RtlSetLastWin32Error(259);
    }
    else
    {
      v6 = a1;
      do
      {
        v7 = *v6;
        if ( (int *)*v6 != v6 )
        {
          *(&v9 + v5) = v7;
          if ( *(_DWORD *)(v7 + 28) != 259 )
            goto LABEL_11;
          *(&Handles + v5++) = *(HANDLE *)(v7 + 44);
        }
        ++v16;
        v6 += 2;
      }
      while ( v16 < v4 );
      if ( !v5 )
        goto LABEL_7;
      v3 = WaitForMultipleObjects(v5, &Handles, 0, 0xFFFFFFFF);
      if ( v3 < v5 )
      {
        v5 = v3;
LABEL_11:
        *(_DWORD *)a3 = *(&v9 + v5);
        return v15;
      }
    }
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1A5E1) --------------------------------------------------------
NTSTATUS __stdcall BasepProcessNameGrafting(HANDLE FileHandle, int a2, int a3, int a4, PVOID FileInformation, int a6)
{
  NTSTATUS result; // eax@1
  int v7; // ecx@3
  int v8; // esi@9
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@1

  result = NtQueryInformationFile(FileHandle, &IoStatusBlock, FileInformation, 8u, FileAttributeTagInformation);
  if ( result < 0 )
  {
    if ( result == -1073741811 || result == -1073741822 )
    {
      result = 0;
      goto LABEL_3;
    }
  }
  else
  {
    if ( !(*(_DWORD *)FileInformation & 0x400) )
    {
LABEL_3:
      v7 = a3;
LABEL_4:
      *(_DWORD *)v7 = 1;
      return result;
    }
    v8 = *((_DWORD *)FileInformation + 1);
    if ( v8 == -1610612733 || v8 == -1610612724 && a6 )
    {
      v7 = a2;
      goto LABEL_4;
    }
  }
  return result;
}

//----- (77E1A625) --------------------------------------------------------
#error "77E1A31E: call analysis failed (funcsize=2701)"

//----- (77E1AF89) --------------------------------------------------------
int __stdcall BasepRemoteFile(HANDLE FileHandle)
{
  signed int v1; // esi@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-10h]@1
  char VolumeInformation; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v1 = 0;
  v5 = 0;
  if ( NtQueryVolumeInformationFile(FileHandle, &IoStatusBlock, &VolumeInformation, 8u, FileFsDeviceInformation) >= 0
    && v5 & 0x10 )
    v1 = 1;
  return v1;
}

//----- (77E1AFC6) --------------------------------------------------------
void __stdcall BasepCopyAdjustChunkSize(int a1, unsigned __int64 a2, int a3)
{
  signed int v3; // eax@3

  if ( a3 )
  {
    if ( a1 )
    {
      *(_DWORD *)a3 = 0x8000;
      return;
    }
    v3 = 0x80000;
    if ( !HIDWORD(a2) )
    {
      if ( (unsigned int)a2 <= 0x80000 )
      {
        v3 = 0x20000;
        if ( a2 < 0x20000 )
        {
          *(_DWORD *)a3 = a2;
          return;
        }
        goto LABEL_8;
      }
      if ( (unsigned int)a2 <= 0x200000 )
      {
        *(_DWORD *)a3 = 0x40000;
        return;
      }
      if ( a2 <= 0x800000 )
      {
LABEL_8:
        *(_DWORD *)a3 = v3;
        return;
      }
    }
    *(_DWORD *)a3 = 0x100000;
  }
}

//----- (77E1B01D) --------------------------------------------------------
int __stdcall BasepCopyGetChunkInfo(int a1, int a2)
{
  int result; // eax@2
  ULONG ResultLength; // [sp+8h] [bp-20h]@4
  HANDLE KeyHandle; // [sp+Ch] [bp-1Ch]@3
  char KeyValueInformation; // [sp+10h] [bp-18h]@4
  int v6; // [sp+14h] [bp-14h]@8
  int v7; // [sp+18h] [bp-10h]@9
  int v8; // [sp+1Ch] [bp-Ch]@10

  if ( !dword_77EA6568 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)a2 = 0;
    if ( NtOpenKey(&KeyHandle, 1u, &stru_77E19804) >= 0 )
    {
      if ( NtQueryValueKey(
             KeyHandle,
             &stru_77E1981C,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength) >= 0
        && v6 == 4
        && v7 == 4 )
        dword_77EA6BDC = v8;
      if ( NtQueryValueKey(
             KeyHandle,
             &stru_77E19824,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength) >= 0
        && v6 == 4
        && v7 == 4 )
        dword_77EA6BE0 = v8;
      NtClose(KeyHandle);
    }
    dword_77EA6568 = 1;
  }
  *(_DWORD *)a1 = dword_77EA6BDC;
  result = dword_77EA6BE0;
  *(_DWORD *)a2 = dword_77EA6BE0;
  return result;
}
// 77EA6568: using guessed type int dword_77EA6568;
// 77EA6BDC: using guessed type int dword_77EA6BDC;
// 77EA6BE0: using guessed type int dword_77EA6BE0;

//----- (77E1B068) --------------------------------------------------------
int __stdcall BasepCheckCopyChunkFile(HANDLE hDevice, HANDLE FileHandle, int a3)
{
  BOOL v3; // esi@3
  BOOL v5; // edi@12
  BOOL v6; // esi@17
  int v7; // edi@22
  DWORD v8; // esi@22
  int v9; // eax@22
  PVOID v10; // eax@22
  unsigned int v11; // edi@23
  char FileInformation; // [sp+Ch] [bp-78h]@37
  int v13; // [sp+2Ch] [bp-58h]@37
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+34h] [bp-50h]@1
  DWORD nOutBufferSize; // [sp+3Ch] [bp-48h]@22
  LPVOID lpOutBuffer; // [sp+40h] [bp-44h]@1
  char VolumeInformation; // [sp+44h] [bp-40h]@1
  int v18; // [sp+48h] [bp-3Ch]@1
  struct _OVERLAPPED Overlapped; // [sp+4Ch] [bp-38h]@1
  HANDLE v20; // [sp+60h] [bp-24h]@1
  PVOID Address; // [sp+64h] [bp-20h]@1
  HANDLE hFile; // [sp+68h] [bp-1Ch]@1
  DWORD BytesReturned; // [sp+6Ch] [bp-18h]@12
  int OutBuffer; // [sp+70h] [bp-14h]@12
  int v25; // [sp+78h] [bp-Ch]@17

  lpOutBuffer = (LPVOID)a3;
  Overlapped.Internal = 0;
  Overlapped.InternalHigh = 0;
  Overlapped.8 = 0i64;
  Overlapped.hEvent = 0;
  v20 = hDevice;
  hFile = FileHandle;
  Address = 0;
  v18 = 0;
  if ( NtQueryVolumeInformationFile(hDevice, &IoStatusBlock, &VolumeInformation, 8u, FileFsDeviceInformation) < 0
    || !(v18 & 0x10) )
    goto LABEL_3;
  if ( NtQueryVolumeInformationFile(FileHandle, &IoStatusBlock, &VolumeInformation, 8u, FileFsDeviceInformation) >= 0
    && v18 & 0x10 )
  {
    Overlapped.hEvent = CreateEventA(0, 1, 0, 0);
    if ( !Overlapped.hEvent )
      return 0;
    v5 = DeviceIoControl(hDevice, 0x140410u, 0, 0, &OutBuffer, 8u, &BytesReturned, &Overlapped);
    if ( !v5 )
    {
      if ( GetLastError() == 997 )
        v5 = GetOverlappedResult(hDevice, &Overlapped, &BytesReturned, 1);
      if ( !v5 && GetLastError() == 234 )
      {
        v6 = DeviceIoControl(hFile, 0x140410u, 0, 0, &v25, 8u, &BytesReturned, &Overlapped);
        if ( !v6 )
        {
          if ( GetLastError() == 997 )
            v6 = GetOverlappedResult(hFile, &Overlapped, &BytesReturned, 1);
          if ( !v6 && GetLastError() == 234 )
          {
            v7 = v25 + 8;
            v8 = OutBuffer + 8;
            nOutBufferSize = v25 + 8;
            v9 = KernelBaseGetGlobalData();
            v10 = RtlAllocateHeap(
                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                    *(_DWORD *)(v9 + 44),
                    v7 + v8 + 4);
            Address = v10;
            if ( v10 )
            {
              v11 = (unsigned int)((char *)v10 + v8 + 3) & 0xFFFFFFFC;
              v3 = DeviceIoControl(v20, 0x140410u, 0, 0, v10, v8, &BytesReturned, &Overlapped);
              if ( !v3 )
              {
                if ( GetLastError() == 997 )
                  v3 = GetOverlappedResult(v20, &Overlapped, &BytesReturned, 1);
                if ( !v3 )
                  goto LABEL_4;
              }
              v3 = DeviceIoControl(hFile, 0x140410u, 0, 0, (LPVOID)v11, nOutBufferSize, &BytesReturned, &Overlapped);
              if ( !v3 )
              {
                if ( GetLastError() == 997 )
                  v3 = GetOverlappedResult(hFile, &Overlapped, &BytesReturned, 1);
                if ( !v3 )
                  goto LABEL_4;
              }
              if ( *(_DWORD *)v11 == *(_DWORD *)Address
                && !__wcsnicmp((const wchar_t *)Address + 2, (const wchar_t *)(v11 + 4), *(_DWORD *)Address >> 1) )
              {
                v3 = DeviceIoControl(v20, 0x140414u, 0, 0, lpOutBuffer, 0x20u, &BytesReturned, &Overlapped);
                if ( v3 )
                  goto LABEL_44;
                if ( GetLastError() == 997 )
                  v3 = GetOverlappedResult(v20, &Overlapped, &BytesReturned, 1);
                if ( v3 )
                {
LABEL_44:
                  v3 = 0;
                  v13 = 0;
                  if ( NtQueryInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation) >= 0
                    && !(v13 & 0x4000) )
                    v3 = 1;
                }
                goto LABEL_4;
              }
            }
LABEL_3:
            v3 = 0;
LABEL_4:
            if ( Address )
              RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
            goto LABEL_5;
          }
        }
      }
    }
  }
  v3 = 0;
LABEL_5:
  if ( Overlapped.hEvent )
    CloseHandle(Overlapped.hEvent);
  return v3;
}

//----- (77E1B141) --------------------------------------------------------
int __stdcall BasepCopyEncryption(int a1, int a2, PHANDLE FileHandle, POBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, int a9, int a10, int a11, int a12, int a13, int a14)
{
  signed int v14; // esi@1
  HANDLE *v15; // esi@6
  int v17; // edx@18
  NTSTATUS v18; // edi@19
  HMODULE v19; // eax@22
  FARPROC v20; // eax@24
  FARPROC v21; // eax@27
  NTSTATUS v22; // eax@30
  int v23; // eax@48
  signed int v24; // [sp-4h] [bp-78h]@47
  char FileInformation; // [sp+10h] [bp-64h]@19
  unsigned int v26; // [sp+30h] [bp-44h]@19
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+38h] [bp-3Ch]@19
  int v28; // [sp+40h] [bp-34h]@1
  char VolumeInformation; // [sp+44h] [bp-30h]@38
  int v30; // [sp+48h] [bp-2Ch]@1
  struct _IO_STATUS_BLOCK v31; // [sp+4Ch] [bp-28h]@1
  HMODULE hModule; // [sp+54h] [bp-20h]@1
  int v33; // [sp+58h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+5Ch] [bp-18h]@1

  v33 = 0;
  v31.Information = 0;
  v14 = 0;
  hModule = 0;
  v30 = 0;
  v28 = *(_DWORD *)a14;
  ms_exc.registration.TryLevel = 0;
  a14 = a9 & 0x4000;
  if ( a9 & 0x4000 && a10 & 0x4000 && !(*(_DWORD *)a11 & 0x4000) )
  {
    if ( a9 & 0x10 && !(*(_DWORD *)a11 & 4) )
      v31.Information = 1;
  }
  else if ( !(a9 & 0x4000) && *(_DWORD *)a11 & 0x4000 && a13 & 0x200 )
  {
    v14 = 1;
  }
  if ( !v14 && !v31.Information )
  {
    v15 = FileHandle;
LABEL_7:
    if ( !a14 )
      goto LABEL_8;
    if ( *(_DWORD *)a11 & 0x4000 )
      goto LABEL_8;
    a9 = 0;
    if ( a13 & 8 )
      goto LABEL_8;
    if ( CheckAllowDecryptedRemoteDestinationPolicy() )
    {
      v30 = 0;
      if ( NtQueryVolumeInformationFile(*v15, &v31, &VolumeInformation, 8u, FileFsDeviceInformation) >= 0 )
      {
        if ( v30 & 0x10 )
          v33 = 1;
      }
    }
    if ( v33 )
      goto LABEL_8;
    if ( !v28 || !*(_DWORD *)(v28 + 28) || !(a13 & 0x10) )
    {
LABEL_53:
      if ( !v33 )
      {
        BaseMarkFileForDelete(*v15, 0);
        RtlSetLastWin32Error(6000);
        goto LABEL_9;
      }
LABEL_8:
      v33 = 1;
      goto LABEL_9;
    }
    if ( a12 & 0x20000 )
    {
      if ( a10 & 0x4000 )
      {
        v23 = 8 * ((*(_BYTE *)a11 & 4) != 0) + 9;
        goto LABEL_51;
      }
      v24 = 9;
    }
    else
    {
      v24 = 8;
    }
    v23 = v24;
LABEL_51:
    if ( BasepCopyFileCallback(0, 6000, v28, 0, v23, a1, (int)*v15, (int)&a9) )
      v33 = 1;
    goto LABEL_53;
  }
  v17 = *(_DWORD *)a11;
  v15 = FileHandle;
  if ( *(_DWORD *)a11 & 1 )
  {
    v30 = 1;
    memset(&FileInformation, 0, 0x28u);
    v26 = v17 & 0xFFFFFFFE;
    v18 = NtSetInformationFile(*FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    if ( v18 < 0 )
      goto LABEL_20;
  }
  NtClose(*FileHandle);
  *FileHandle = (HANDLE)-1;
  v19 = LoadLibraryW(L"advapi32.dll");
  hModule = v19;
  if ( !v19 )
    goto LABEL_9;
  if ( v31.Information )
  {
    v20 = GetProcAddress(v19, "EncryptFileW");
    if ( !v20 )
      goto LABEL_9;
    if ( ((int (__stdcall *)(int))v20)(a2) )
      *(_DWORD *)a11 |= 0x4000u;
  }
  else
  {
    v21 = GetProcAddress(hModule, "DecryptFileW");
    if ( !v21 )
      goto LABEL_9;
    if ( ((int (__stdcall *)(int, _DWORD))v21)(a2, 0) )
      *(_DWORD *)a11 &= 0xFFFFBFFF;
  }
  v22 = NtCreateFile(
          FileHandle,
          DesiredAccess,
          ObjectAttributes,
          &IoStatusBlock,
          0,
          (unsigned __int16)a10 & (unsigned __int16)a9 & 0x7FB7,
          ShareAccess,
          CreateDisposition,
          CreateOptions,
          0,
          0);
  if ( v22 >= 0 )
  {
    if ( !v30 )
      goto LABEL_7;
    v26 |= 1u;
    v18 = NtSetInformationFile(*FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    if ( v18 >= 0 )
      goto LABEL_7;
LABEL_20:
    BaseMarkFileForDelete(*FileHandle, 0);
    BaseSetLastNTError(v18);
    goto LABEL_9;
  }
  *FileHandle = (HANDLE)-1;
  BaseSetLastNTError(v22);
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( hModule )
    FreeLibrary(hModule);
  return v33;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1B348) --------------------------------------------------------
BOOL __stdcall CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
{
  int v6; // ST3C_4@1
  int v8; // [sp+10h] [bp-28h]@1
  HANDLE v9; // [sp+18h] [bp-20h]@1
  HANDLE hObject; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  hObject = (HANDLE)-1;
  v9 = (HANDLE)-1;
  v6 = RtlGetCurrentTransaction();
  RtlSetCurrentTransaction(0);
  ms_exc.registration.TryLevel = 0;
  v8 = BasepCopyFileExW(
         lpExistingFileName,
         lpNewFileName,
         (int)lpProgressRoutine,
         (int)lpData,
         (int)pbCancel,
         dwCopyFlags,
         (int)&hObject,
         (int)&v9,
         v6);
  ms_exc.registration.TryLevel = -2;
  RtlSetCurrentTransaction(v6);
  if ( hObject != (HANDLE)-1 )
    CloseHandle(hObject);
  if ( v9 != (HANDLE)-1 )
    CloseHandle(v9);
  return v8;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E1B3FB) --------------------------------------------------------
BOOL __stdcall SetFileAttributesWStub(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
  return SetFileAttributesW(lpFileName, dwFileAttributes);
}

//----- (77E1B413) --------------------------------------------------------
ULONG __stdcall LocalOpenUsers(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  NTSTATUS v3; // eax@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-18h]@1

  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&UserStringKey;
  v3 = NtOpenKey(KeyHandle, DesiredAccess, &ObjectAttributes);
  return RtlNtStatusToDosError(v3);
}
// 77E1B458: using guessed type int UserStringKey;

//----- (77E1B483) --------------------------------------------------------
int __stdcall GetLocaleInfoAStub(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
{
  return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
}

//----- (77E1B522) --------------------------------------------------------
ULONG __stdcall LocalOpenCurrentUserLocalSettings(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  NTSTATUS v3; // eax@1
  signed int v4; // edi@3
  ULONG result; // eax@5
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-28h]@4
  UNICODE_STRING SourceString; // [sp+20h] [bp-10h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-8h]@1

  SourceString.Length = 0;
  *(_DWORD *)&SourceString.MaximumLength = 0;
  HIWORD(SourceString.Buffer) = 0;
  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v3 = RtlFormatCurrentUserKeyPath(&SourceString);
  if ( v3 < 0 )
  {
    result = RtlNtStatusToDosError(v3);
  }
  else
  {
    DestinationString.MaximumLength = SourceString.MaximumLength + 48;
    DestinationString.Buffer = (PWCH)RtlAllocateHeap(
                                       NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                       0,
                                       (unsigned __int16)(SourceString.MaximumLength + 48));
    if ( DestinationString.Buffer )
    {
      RtlCopyUnicodeString(&DestinationString, &SourceString);
      v4 = RtlAppendUnicodeToString(&DestinationString, L"_Classes\\Local Settings");
      if ( v4 >= 0 )
      {
        ObjectAttributes.ObjectName = &DestinationString;
        ObjectAttributes.Length = 24;
        ObjectAttributes.RootDirectory = 0;
        ObjectAttributes.Attributes = 64;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        v4 = NtCreateKey(KeyHandle, DesiredAccess, &ObjectAttributes, 0, 0, 0, 0);
      }
    }
    else
    {
      v4 = -1073741670;
    }
    RtlFreeUnicodeString(&SourceString);
    RtlFreeUnicodeString(&DestinationString);
    result = RtlNtStatusToDosError(v4);
  }
  return result;
}
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);

//----- (77E1B642) --------------------------------------------------------
int __stdcall RegisterConsoleIME(int a1, int a2)
{
  RtlSetLastWin32Error(120);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1B6FE) --------------------------------------------------------
PTP_TIMER __stdcall CreateThreadpoolTimerStub(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  return CreateThreadpoolTimer(pfnti, pv, pcbe);
}

//----- (77E1B70B) --------------------------------------------------------
PTP_TIMER __stdcall CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
{
  int v3; // eax@1
  PTP_TIMER result; // eax@2

  v3 = TpAllocTimer(&pcbe, pfnti, pv, pcbe);
  if ( v3 < 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v3);
    result = 0;
  }
  else
  {
    result = (PTP_TIMER)pcbe;
  }
  return result;
}
// 77DE1020: using guessed type int __stdcall TpAllocTimer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E1B822) --------------------------------------------------------
int __stdcall GetStringFromArrayInPool(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a2 )
    result = a1 + 2 * *(_DWORD *)(a1 + 2 * (a2 + 2 * a3) + 2);
  else
    result = a1;
  return result;
}

//----- (77E1B83E) --------------------------------------------------------
BOOL __stdcall SystemTimeToTzSpecificLocalTimeStub(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
{
  return SystemTimeToTzSpecificLocalTime(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
}

//----- (77E1B8BB) --------------------------------------------------------
int __stdcall BaseRegCreateMultipartKey(HANDLE Handle, int a2, PUNICODE_STRING Class, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // eax@1
  wchar_t *v11; // esi@1
  signed int v12; // edi@1
  const wchar_t *v13; // ST18_4@1
  wchar_t *v14; // eax@1
  HANDLE v15; // ebx@4
  int v16; // eax@4
  int v17; // edi@6
  wchar_t *v18; // eax@7
  signed int v19; // eax@7
  ACCESS_MASK v20; // eax@10
  NTSTATUS v21; // eax@13
  signed int v22; // edi@14
  wchar_t *v23; // eax@22
  int v25; // edx@27
  wchar_t v26; // cx@28
  NTSTATUS v27; // eax@38
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-34h]@8
  __int16 v29; // [sp+24h] [bp-1Ch]@8
  __int16 v30; // [sp+26h] [bp-1Ah]@8
  int v31; // [sp+28h] [bp-18h]@6
  int v32; // [sp+2Ch] [bp-14h]@1
  int v33; // [sp+30h] [bp-10h]@1
  wchar_t *Str; // [sp+34h] [bp-Ch]@4
  HANDLE KeyHandle; // [sp+38h] [bp-8h]@1
  ULONG Disposition; // [sp+3Ch] [bp-4h]@1
  HANDLE Handlea; // [sp+48h] [bp+8h]@8
  int v38; // [sp+4Ch] [bp+Ch]@4

  v10 = *(_DWORD *)RegKrnGetGlobalState();
  KeyHandle = 0;
  v33 = v10;
  v11 = *(wchar_t **)(a2 + 4);
  v12 = 1;
  v13 = *(const wchar_t **)(a2 + 4);
  Disposition = 2;
  v32 = 1;
  v14 = wcschr(v13, 0x5Cu);
  if ( v14 )
  {
    do
    {
      ++v12;
      v14 = wcschr(v14 + 1, 0x5Cu);
    }
    while ( v14 );
    v32 = v12;
  }
  v38 = 0;
  v15 = Handle;
  v16 = (int)v11;
  Str = v11;
  if ( !v12 )
  {
LABEL_24:
    *(_DWORD *)a7 = v15;
    return 0;
  }
  while ( 1 )
  {
    if ( *(_WORD *)v16 == 92 && v38 != v12 - 1 )
    {
      v16 += 2;
      Str = (wchar_t *)v16;
      goto LABEL_23;
    }
    v17 = v12 - 1;
    v31 = v16;
    if ( v38 == v17 )
    {
      v25 = v16 + 2;
      do
      {
        v26 = *(_WORD *)v16;
        v16 += 2;
      }
      while ( v26 );
      v19 = v16 - v25;
    }
    else
    {
      v18 = wcschr((const wchar_t *)v16, 0x5Cu);
      v19 = (char *)v18 - (char *)Str;
    }
    v29 = 2 * (v19 >> 1);
    v30 = 2 * (v19 >> 1);
    Handlea = KeyHandle;
    ObjectAttributes.Attributes = a9;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v29;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = v15;
    ObjectAttributes.SecurityDescriptor = (PVOID)(a6 ? *(_DWORD *)(a6 + 4) : 0);
    v20 = DesiredAccess;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( a10 )
    {
      if ( v38 != v17 )
        v20 = DesiredAccess & 0x300 | 0x2000000;
      v21 = NtCreateKeyTransacted(&KeyHandle, v20, &ObjectAttributes, 0, Class, CreateOptions, a10, &Disposition);
    }
    else
    {
      if ( v38 != v17 )
        v20 = DesiredAccess & 0x300 | 0x2000000;
      v21 = NtCreateKey(&KeyHandle, v20, &ObjectAttributes, 0, Class, CreateOptions, &Disposition);
    }
    v22 = v21;
    if ( v21 >= 0 && a8 )
      *(_DWORD *)a8 = Disposition;
    if ( *(_BYTE *)(RegKrnGetGlobalState() + 36) & 1 && v22 == -1073741790 )
    {
      if ( a10 )
        v27 = NtCreateKeyTransacted(
                &KeyHandle,
                DesiredAccess & 0x1000300 | 0x2000000,
                &ObjectAttributes,
                0,
                Class,
                CreateOptions,
                a10,
                &Disposition);
      else
        v27 = NtCreateKey(
                &KeyHandle,
                DesiredAccess & 0x1000300 | 0x2000000,
                &ObjectAttributes,
                0,
                Class,
                CreateOptions,
                &Disposition);
      v22 = v27;
      if ( v27 < 0 )
        v22 = -1073741790;
      if ( a8 )
        *(_DWORD *)a8 = Disposition;
    }
    if ( v33 && v22 >= 0 && Disposition == 1 )
      ((void (__stdcall *)(HANDLE, OBJECT_ATTRIBUTES *, _DWORD, PUNICODE_STRING, ULONG))v33)(
        KeyHandle,
        &ObjectAttributes,
        0,
        Class,
        CreateOptions);
    v15 = KeyHandle;
    if ( Handlea )
      NtClose(Handlea);
    if ( v22 < 0 )
      return v22;
    v23 = wcschr(Str, 0x5Cu);
    v12 = v32;
    v16 = (int)(v23 + 1);
    Str = (wchar_t *)v16;
LABEL_23:
    ++v38;
    if ( v38 >= (unsigned int)v12 )
      goto LABEL_24;
  }
}
// 77DE13EC: using guessed type int __stdcall NtCreateKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E1BA4C) --------------------------------------------------------
BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
{
  PVOID v6; // eax@1
  NTSTATUS v7; // eax@5

  v6 = hObject;
  *phNewWaitObject = 0;
  if ( hObject == (HANDLE)-12 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hObject == (HANDLE)-11 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hObject == (HANDLE)-10 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v6 & 0x10000003) == 3 )
  {
    if ( !VerifyConsoleIoHandle((int)v6) )
    {
      BaseSetLastNTError(-1073741816);
      return 0;
    }
    v6 = GetConsoleInputWaitHandle();
  }
  v7 = RtlRegisterWait(phNewWaitObject, v6, Callback, Context, dwMilliseconds, dwFlags);
  if ( v7 >= 0 )
    return 1;
  BaseSetLastNTError(v7);
  return 0;
}
// 77DE10F8: using guessed type int __stdcall RtlRegisterWait(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E1BAC8) --------------------------------------------------------
DWORD __stdcall GetProcessIdStub(HANDLE Process)
{
  return GetProcessId(Process);
}

//----- (77E1BAE3) --------------------------------------------------------
BOOL __stdcall UnregisterWait(HANDLE WaitHandle)
{
  NTSTATUS v1; // eax@2

  if ( !WaitHandle )
  {
    RtlSetLastWin32Error(6);
    return 0;
  }
  v1 = RtlDeregisterWait(WaitHandle);
  if ( v1 == 259 || v1 < 0 )
  {
    BaseSetLastNTError(v1);
    return 0;
  }
  return 1;
}
// 77DE1104: using guessed type int __stdcall RtlDeregisterWait(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1BB17) --------------------------------------------------------
int __stdcall K32QueryWorkingSetEx(HANDLE ProcessHandle, PVOID MemoryInformation, ULONG MemoryInformationLength)
{
  NTSTATUS v3; // eax@1
  int result; // eax@2
  DWORD v5; // eax@4

  v3 = NtQueryVirtualMemory(
         ProcessHandle,
         0,
         (MEMORY_INFORMATION_CLASS)4,
         MemoryInformation,
         MemoryInformationLength,
         0);
  if ( v3 < 0 )
  {
    v5 = RtlNtStatusToDosError(v3);
    SetLastError(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E1BBB5) --------------------------------------------------------
int __stdcall LocalBaseRegDeleteValue(HANDLE KeyHandle, PUNICODE_STRING ValueName)
{
  UNICODE_STRING *v2; // esi@1
  void (__stdcall *v3)(_DWORD, _DWORD); // ecx@1
  USHORT v4; // ax@2
  HANDLE v5; // edi@5
  NTSTATUS v6; // eax@8
  NTSTATUS v8; // eax@12
  int v9; // [sp+Ch] [bp-8h]@1
  HANDLE Handle; // [sp+10h] [bp-4h]@1
  NTSTATUS ValueNamea; // [sp+20h] [bp+Ch]@8

  v2 = ValueName;
  v3 = *(void (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 16);
  v9 = 0;
  Handle = 0;
  if ( ValueName && (v4 = ValueName->Length, ValueName->Length >= 2u) && !(v4 & 1) && ValueName->Buffer
    || !ValueName->Buffer && (v4 = ValueName->Length, ValueName->Length == 2) && !ValueName->MaximumLength )
  {
    v5 = KeyHandle;
    ValueName->Length = v4 - 2;
    if ( v3 )
      v3(KeyHandle, ValueName);
    if ( (unsigned __int8)KeyHandle & 2 )
    {
      v8 = BaseRegGetUserAndMachineClass(0, KeyHandle, 0x2000000, (int)&Handle, (int)&v9);
      if ( v8 < 0 )
        return RtlNtStatusToDosError(v8);
    }
    if ( v9 && Handle )
      v5 = (HANDLE)v9;
    v6 = NtDeleteValueKey(v5, ValueName);
    ValueNamea = v6;
    if ( (unsigned __int8)KeyHandle & 2 && v6 == -1073741772 )
    {
      if ( !v9 )
        return RtlNtStatusToDosError(ValueNamea);
      if ( Handle )
        ValueNamea = NtDeleteValueKey(Handle, v2);
    }
    if ( v9 && Handle )
    {
      if ( (HANDLE)v9 == KeyHandle )
        NtClose(Handle);
      else
        NtClose((HANDLE)v9);
    }
    return RtlNtStatusToDosError(ValueNamea);
  }
  return 87;
}

//----- (77E1BC53) --------------------------------------------------------
LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
{
  int (__stdcall *v2)(_DWORD, _DWORD); // edi@1
  HKEY v3; // esi@1
  int v4; // eax@2
  LSTATUS v5; // esi@2
  NTSTATUS v6; // eax@3
  ULONG v7; // eax@5
  int v8; // edi@7
  int v9; // ebx@7
  int v10; // eax@7
  LSA_UNICODE_STRING ValueName; // [sp+10h] [bp-30h]@3
  LSTATUS v13; // [sp+18h] [bp-28h]@10
  int v14; // [sp+20h] [bp-20h]@1
  int v15; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@10

  v14 = 0;
  v15 = 0;
  v2 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 100);
  v3 = hKey;
  if ( hKey != HKEY_PERFORMANCE_DATA )
  {
    v4 = RegKrnGetGlobalState();
    v5 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v4 + 176))(v3, &hKey, &v14, &v15);
    if ( !v5 )
    {
      v6 = RtlInitUnicodeStringEx(&ValueName, lpValueName);
      if ( v6 < 0 )
      {
        v7 = RtlNtStatusToDosError(v6);
      }
      else
      {
        ValueName.Length += 2;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v2 )
          {
            ms_exc.registration.TryLevel = 0;
            v5 = v2((unsigned int)hKey & 0xFFFFFFFE, &ValueName);
            v13 = v5;
            ms_exc.registration.TryLevel = -2;
          }
          goto LABEL_7;
        }
        v7 = LocalBaseRegDeleteValue(hKey, &ValueName);
      }
      v5 = v7;
    }
LABEL_7:
    v8 = v15;
    v9 = v14;
    v10 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v10 + 168))(v9, v8);
    return v5;
  }
  return 6;
}

//----- (77E1BD25) --------------------------------------------------------
BOOL __stdcall CreateTimerQueueTimerStub(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
{
  return CreateTimerQueueTimer(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
}

//----- (77E1BD3D) --------------------------------------------------------
BOOL __stdcall DeleteTimerQueueTimerStub(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  return DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
}

//----- (77E1BD73) --------------------------------------------------------
BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb)
{
  int v2; // esi@1
  char v3; // t1@4
  unsigned int v4; // eax@4
  char v6; // t1@8
  UINT_PTR ucba; // [sp+38h] [bp+Ch]@3
  int ucbb; // [sp+38h] [bp+Ch]@4

  v2 = *(_DWORD *)(BaseStaticServerData + 300);
  if ( !ucb )
    return 0;
  if ( lp )
  {
    ucba = (UINT_PTR)((char *)lp + ucb - 1);
    if ( ucba >= (unsigned int)lp )
    {
      v3 = *(_BYTE *)lp;
      v4 = (unsigned int)lp & ~(v2 - 1);
      ucbb = ~(v2 - 1) & ucba;
      while ( v4 != ucbb )
      {
        v4 += v2;
        v6 = *(_BYTE *)v4;
      }
      return 0;
    }
  }
  return 1;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E1BE70) --------------------------------------------------------
BOOL __stdcall GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
{
  BOOL result; // eax@4

  if ( lpszVolumeMountPoint && lpszVolumeName && cchBufferLength )
  {
    result = BasepGetVolumeNameForVolumeMountPoint(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength, 0);
    if ( !result && cchBufferLength >= 1 )
      *lpszVolumeName = 0;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1BEB6) --------------------------------------------------------
int __stdcall BasepGetVolumeNameForVolumeMountPoint(LPCWSTR lpRootPathName, PWSTR dosname, int a3, int a4)
{
  int v4; // esi@1
  const wchar_t *v5; // edi@4
  NTSTATUS v6; // eax@4
  UINT v7; // ebx@6
  int v8; // eax@6
  WCHAR v10; // cx@27
  UNICODE_STRING DestinationString; // [sp+Ch] [bp-8h]@4
  int lpRootPathNamea; // [sp+1Ch] [bp+8h]@6

  v4 = 0;
  if ( !dosname || !a3 )
  {
    RtlSetLastWin32Error(87);
    return v4;
  }
  if ( a4 )
    *(_DWORD *)a4 = 1;
  v5 = lpRootPathName;
  v6 = RtlInitUnicodeStringEx(&DestinationString, lpRootPathName);
  if ( v6 < 0 )
  {
    BaseSetLastNTError(v6);
    return v4;
  }
  if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] != 92 )
  {
    BaseSetLastNTError(-1073741773);
    return v4;
  }
  v7 = GetDriveTypeW(lpRootPathName);
  lpRootPathNamea = __wcsicmp(lpRootPathName, L"\\\\");
  v8 = __wcsicmp(v5, L"\\\\?\\UNC\\");
  if ( v7 == 4 && lpRootPathNamea && v8 )
  {
    v4 = BasepGetVolumeNameFromReparsePoint(v5, dosname, a3, a4);
    if ( v4 )
      return v4;
    RtlSetLastWin32Error(87);
LABEL_34:
    if ( (unsigned int)a3 >= 1 )
      *dosname = 0;
    return v4;
  }
  if ( DestinationString.Length == 6 )
  {
    if ( DestinationString.Buffer[1] == 58 )
    {
LABEL_12:
      v4 = GetVolumeNameForRoot((PWSTR)v5, (int)dosname, a3);
      if ( v4 )
        return v4;
      if ( a4 )
        *(_DWORD *)a4 = 0;
      goto LABEL_34;
    }
  }
  else if ( DestinationString.Length == 14 && *DestinationString.Buffer == 92 && DestinationString.Buffer[1] == 92 )
  {
    v10 = DestinationString.Buffer[2];
    if ( (v10 == 46 || v10 == 63) && DestinationString.Buffer[3] == 92 && DestinationString.Buffer[5] == 58 )
    {
      v5 += 4;
      goto LABEL_12;
    }
  }
  v4 = GetVolumeNameForRoot((PWSTR)v5, (int)dosname, a3);
  if ( !v4 )
  {
    v4 = BasepGetVolumeNameFromReparsePoint(v5, dosname, a3, a4);
    if ( v4 )
      GetVolumeNameForRoot(dosname, (int)dosname, a3);
  }
  return v4;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1C029) --------------------------------------------------------
BOOL __stdcall GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
{
  int v4; // eax@53
  PVOID v5; // eax@53
  NTSTATUS v6; // eax@1
  WCHAR v7; // dx@7
  int v8; // eax@25
  PVOID v9; // eax@25
  PVOID v10; // esi@25
  unsigned __int16 v11; // ax@26
  int v12; // eax@27
  PVOID v13; // eax@27
  BOOL i; // eax@28
  DWORD v15; // eax@30
  unsigned int v16; // edx@30
  void *v17; // esi@30
  int v18; // ecx@31
  int v19; // ecx@36
  int v20; // edi@37
  int v21; // ecx@37
  BOOL v22; // edi@40
  UNICODE_STRING DestinationString; // [sp+4h] [bp-14h]@1
  DWORD BytesReturned; // [sp+Ch] [bp-Ch]@28
  ULONG Size; // [sp+10h] [bp-8h]@53
  HANDLE hDevice; // [sp+14h] [bp-4h]@26
  PVOID Address; // [sp+20h] [bp+8h]@27

  v6 = RtlInitUnicodeStringEx(&DestinationString, lpszVolumeName);
  if ( v6 < 0 )
  {
    BaseSetLastNTError(v6);
    return 0;
  }
  if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] != 92 )
  {
    BaseSetLastNTError(-1073741773);
    return 0;
  }
  if ( DestinationString.Length != 96 && (DestinationString.Length != 98 || DestinationString.Buffer[48] != 92)
    || *DestinationString.Buffer != 92
    || (v7 = DestinationString.Buffer[1], v7 != 63) && v7 != 92
    || DestinationString.Buffer[2] != 63
    || DestinationString.Buffer[3] != 92
    || DestinationString.Buffer[4] != 86
    || DestinationString.Buffer[5] != 111
    || DestinationString.Buffer[6] != 108
    || DestinationString.Buffer[7] != 117
    || DestinationString.Buffer[8] != 109
    || DestinationString.Buffer[9] != 101
    || DestinationString.Buffer[10] != 123
    || DestinationString.Buffer[19] != 45
    || DestinationString.Buffer[24] != 45
    || DestinationString.Buffer[29] != 45
    || DestinationString.Buffer[34] != 45
    || DestinationString.Buffer[47] != 125
    || DestinationString.Length != 98
    || v7 != 92 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v8 = KernelBaseGetGlobalData();
  v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44), 0x208u);
  v10 = v9;
  if ( !v9 )
  {
LABEL_57:
    RtlSetLastWin32Error(8);
    return 0;
  }
  memset(v9, 0, 0x208u);
  v11 = DestinationString.Length - 2;
  *(_WORD *)v10 = DestinationString.Length - 2;
  memcpy((char *)v10 + 2, lpszVolumeName, v11);
  *((_WORD *)v10 + 2) = 63;
  hDevice = CreateFileW(L"\\\\.\\MountPointManager", 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  if ( hDevice == (HANDLE)-1 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
    return 0;
  }
  v12 = KernelBaseGetGlobalData();
  v13 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v12 + 44), 8u);
  Address = v13;
  if ( !v13 )
  {
    CloseHandle(hDevice);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
    goto LABEL_57;
  }
  for ( i = DeviceIoControl(hDevice, 0x6D0034u, v10, 0x208u, v13, 8u, &BytesReturned, 0);
        !i;
        i = DeviceIoControl(hDevice, 0x6D0034u, v10, 0x208u, v5, Size, &BytesReturned, 0) )
  {
    if ( GetLastError() != 234 )
    {
      CloseHandle(hDevice);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
      return 0;
    }
    Size = *(_DWORD *)Address + 8;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    v4 = KernelBaseGetGlobalData();
    v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), Size);
    Address = v5;
    if ( !v5 )
    {
      CloseHandle(hDevice);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
      goto LABEL_57;
    }
  }
  CloseHandle(hDevice);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
  v15 = 0;
  v16 = 0;
  hDevice = 0;
  v17 = Address;
  if ( cchBufferLength )
  {
    v18 = (int)((char *)Address + 4);
    while ( v16 < (*(_DWORD *)v17 >> 1) - 1 )
    {
      if ( !*(_WORD *)v18
        && (hDevice = (char *)hDevice + 1, lpszVolumePathNames[v15] = 92, ++v15, v15 == cchBufferLength)
        || (lpszVolumePathNames[v15] = *(_WORD *)v18, ++v15, ++v16, v18 += 2, v15 >= cchBufferLength) )
      {
        v17 = Address;
        break;
      }
      v17 = Address;
    }
  }
  v19 = (*(_DWORD *)v17 >> 1) - 1;
  if ( v16 < v19 )
  {
    v20 = (int)((char *)v17 + 2 * v16 + 4);
    v21 = v19 - v16;
    do
    {
      if ( !*(_WORD *)v20 )
        hDevice = (char *)hDevice + 1;
      v20 += 2;
      --v21;
    }
    while ( v21 );
  }
  v22 = 0;
  if ( v15 >= cchBufferLength )
  {
    RtlSetLastWin32Error(234);
    if ( lpcchReturnLength )
      *lpcchReturnLength = (DWORD)((char *)hDevice + (*(_DWORD *)v17 >> 1));
  }
  else
  {
    lpszVolumePathNames[v15] = 0;
    v22 = 1;
    if ( lpcchReturnLength )
      *lpcchReturnLength = v15 + 1;
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v17);
  return v22;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1C2F1) --------------------------------------------------------
BOOL __stdcall Wow64DisableWow64FsRedirectionStub(PVOID *OldValue)
{
  return Wow64DisableWow64FsRedirection(OldValue);
}

//----- (77E1C2FE) --------------------------------------------------------
HANDLE __stdcall PowerCreateRequest(PREASON_CONTEXT Context)
{
  NTSTATUS v1; // eax@1
  PVOID v2; // ST10_4@4
  HANDLE v3; // eax@4
  void *OutputBuffer; // [sp+0h] [bp-8h]@1
  PVOID InputBuffer; // [sp+4h] [bp-4h]@1

  InputBuffer = 0;
  OutputBuffer = (void *)-1;
  v1 = BasePrepareReasonContext((int)Context, (int)&InputBuffer);
  if ( v1 < 0 || (v1 = NtPowerInformation(PowerRequestCreate, InputBuffer, 0x1Cu, &OutputBuffer, 4u), v1 < 0) )
    BaseSetLastNTError(v1);
  if ( InputBuffer )
  {
    v2 = InputBuffer;
    v3 = GetProcessHeap();
    HeapFree(v3, 0, v2);
  }
  return OutputBuffer;
}

//----- (77E1C35E) --------------------------------------------------------
signed int __stdcall BasePrepareReasonContext(int a1, int a2)
{
  size_t v2; // ebx@1
  ULONG v3; // ecx@1
  int v4; // eax@2
  DWORD v5; // eax@8
  PVOID v6; // eax@11
  PVOID v7; // esi@11
  int v8; // eax@14
  int v9; // ecx@15
  unsigned int v10; // eax@15
  unsigned int v11; // ebx@15
  signed int v12; // edi@16
  WCHAR Filename; // [sp+10h] [bp-20Ch]@8

  v2 = 0;
  v3 = 28;
  if ( a1 )
  {
    v4 = *(_DWORD *)(a1 + 4);
    if ( v4 >= 0 )
    {
      if ( *(_DWORD *)a1 > 0u || !(v4 & 3) || v4 & 0x7FFFFFFC )
        return -1073741811;
      if ( !(v4 & 2) )
        goto LABEL_11;
      if ( *(_DWORD *)(a1 + 12) > 0xFFFFu )
        return -1073741811;
      v5 = GetModuleFileNameW(*(HMODULE *)(a1 + 8), &Filename, 0x104u);
      if ( !v5 || v5 == 260 )
        return -1073741811;
      v2 = 2 * v5 + 2;
      v3 = ((2 * v5 + 5) & 0xFFFFFFFC) + 8 * *(_DWORD *)(a1 + 16) + 28;
    }
  }
LABEL_11:
  v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  v7 = v6;
  if ( v6 )
  {
    if ( !a1 || *(_DWORD *)(a1 + 4) & 0x80000000 )
    {
      *(_DWORD *)v6 = 0;
      *((_DWORD *)v6 + 1) = 2147483648;
      goto LABEL_16;
    }
    *(_DWORD *)v6 = *(_DWORD *)a1;
    v8 = *(_DWORD *)(a1 + 4);
    *((_DWORD *)v7 + 1) = v8;
    if ( v8 & 1 )
    {
      if ( RtlUnicodeStringInit((PUNICODE_STRING)v7 + 1, *(NTSTRSAFE_PCWSTR *)(a1 + 8)) >= 0 && *((_WORD *)v7 + 4) )
        goto LABEL_16;
    }
    else
    {
      memcpy((char *)v7 + 28, &Filename, v2);
      *((_DWORD *)v7 + 3) = (char *)v7 + 28;
      *((_WORD *)v7 + 5) = v2;
      *((_WORD *)v7 + 4) = v2 - 2;
      *((_WORD *)v7 + 8) = *(_WORD *)(a1 + 12);
      v9 = *(_DWORD *)(a1 + 16);
      v10 = (unsigned int)((char *)v7 + v2 + 31) & 0xFFFFFFFC;
      v11 = 0;
      *((_DWORD *)v7 + 5) = v9;
      *((_DWORD *)v7 + 6) = v10;
      if ( !v9 )
      {
LABEL_16:
        v12 = 0;
        *(_DWORD *)a2 = v7;
        return v12;
      }
      while ( RtlUnicodeStringInit(
                (PUNICODE_STRING)(*((_DWORD *)v7 + 6) + 8 * v11),
                *(NTSTRSAFE_PCWSTR *)(*(_DWORD *)(a1 + 20) + 4 * v11)) >= 0 )
      {
        ++v11;
        if ( v11 >= *((_DWORD *)v7 + 5) )
          goto LABEL_16;
      }
    }
    v12 = -1073741811;
  }
  else
  {
    v12 = -1073741670;
  }
  if ( v7 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  return v12;
}

//----- (77E1C4A4) --------------------------------------------------------
BOOL __stdcall PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  HANDLE InputBuffer; // [sp+0h] [bp-Ch]@1
  POWER_REQUEST_TYPE v5; // [sp+4h] [bp-8h]@1
  char v6; // [sp+8h] [bp-4h]@1

  InputBuffer = PowerRequest;
  v5 = RequestType;
  v6 = 1;
  v2 = NtPowerInformation(PowerRequestAction, &InputBuffer, 0xCu, 0, 0);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E1C4E2) --------------------------------------------------------
int __stdcall GetNumberFormatWStub(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
{
  return GetNumberFormatW(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
}

//----- (77E1C4F2) --------------------------------------------------------
BOOL __stdcall SetFileTimeStub(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
{
  return SetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
}

//----- (77E1C50A) --------------------------------------------------------
BOOL __stdcall PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  HANDLE InputBuffer; // [sp+0h] [bp-Ch]@1
  POWER_REQUEST_TYPE v5; // [sp+4h] [bp-8h]@1
  char v6; // [sp+8h] [bp-4h]@1

  InputBuffer = PowerRequest;
  v5 = RequestType;
  v6 = 0;
  v2 = NtPowerInformation(PowerRequestAction, &InputBuffer, 0xCu, 0, 0);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E1C548) --------------------------------------------------------
BOOL __stdcall GetStringTypeExWStub(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
  return GetStringTypeExW(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

//----- (77E1C56B) --------------------------------------------------------
void __stdcall GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
{
  char v1; // [sp+4h] [bp-38h]@1
  char v2; // [sp+30h] [bp-Ch]@2

  if ( RtlGetNativeSystemInformation(0, &v1, 44, 0) >= 0 && RtlGetNativeSystemInformation(1, &v2, 12, 0) >= 0 )
    GetSystemInfoInternal((int)&v1, (int)&v2, (int)lpSystemInfo);
}
// 77DE129C: using guessed type int __stdcall RtlGetNativeSystemInformation(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E1C5B4) --------------------------------------------------------
DWORD __stdcall GetSystemInfoInternal(int a1, int a2, int a3)
{
  __int16 v3; // dx@1
  __int16 v4; // cx@2
  DWORD result; // eax@4

  memset((void *)a3, 0, 0x24u);
  *(_WORD *)a3 = *(_WORD *)a2;
  *(_WORD *)(a3 + 2) = 0;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a3 + 20) = *(_BYTE *)(a1 + 40);
  *(_WORD *)(a3 + 32) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a3 + 34) = *(_WORD *)(a2 + 4);
  v3 = *(_WORD *)a2;
  if ( *(_WORD *)a2 )
  {
    if ( v3 == 6 )
    {
      *(_DWORD *)(a3 + 24) = 2200;
    }
    else if ( v3 == 9 )
    {
      *(_DWORD *)(a3 + 24) = 8664;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 0;
    }
  }
  else
  {
    v4 = *(_WORD *)(a2 + 2);
    if ( v4 == 3 )
      *(_DWORD *)(a3 + 24) = 386;
    else
      *(_DWORD *)(a3 + 24) = v4 != 4 ? 586 : 486;
  }
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a1 + 24);
  result = GetProcessVersion(0);
  if ( result < 0x30033 )
  {
    result = 0;
    *(_WORD *)(a3 + 32) = 0;
    *(_WORD *)(a3 + 34) = 0;
  }
  return result;
}

//----- (77E1C6D7) --------------------------------------------------------
void __stdcall AddRefActCtx(HANDLE hActCtx)
{
  RtlAddRefActivationContext(hActCtx);
}

//----- (77E1C74D) --------------------------------------------------------
BOOL __stdcall BasepSxsIsStatusResourceNotFound(int a1)
{
  return a1 < 0 && (a1 == -1073741687 || a1 == -1073741686 || a1 == -1073741685 || a1 == -1073741308);
}

//----- (77E1C7FC) --------------------------------------------------------
BOOL __stdcall Module32NextW(HANDLE hSnapshot, LPMODULEENTRY32W lpme)
{
  LPMODULEENTRY32W v2; // edi@1
  BOOL v3; // esi@1
  NTSTATUS v4; // eax@3
  DWORD v5; // ecx@4
  char *v6; // esi@5
  LARGE_INTEGER SectionOffset; // [sp+8h] [bp-Ch]@3
  ULONG ViewSize; // [sp+10h] [bp-4h]@3

  v2 = lpme;
  v3 = 0;
  if ( !lpme || lpme->dwSize != 1064 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lpme = 0;
  v4 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lpme,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = *(_DWORD *)&lpme->szModule[4];
  if ( v5 >= lpme->th32ProcessID )
  {
    RtlSetLastWin32Error(18);
  }
  else
  {
    v6 = (char *)&lpme[v5] + lpme->modBaseSize;
    *(_DWORD *)&lpme->szModule[4] = v5 + 1;
    qmemcpy(v2, v6, 0x428u);
    v3 = 1;
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lpme);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1C893) --------------------------------------------------------
LPVOID __stdcall VirtualAllocExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
{
  return VirtualAllocEx(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
}

//----- (77E1C8AB) --------------------------------------------------------
BOOL __stdcall ReadProcessMemoryStub(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
{
  return ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
}

//----- (77E1C8BB) --------------------------------------------------------
BOOL __stdcall VirtualFreeExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
{
  return VirtualFreeEx(hProcess, lpAddress, dwSize, dwFreeType);
}

//----- (77E1C8D3) --------------------------------------------------------
int __stdcall FindModule(HANDLE ProcessHandle, int Buffer, LPVOID lpBuffer)
{
  NTSTATUS v3; // eax@1
  int v4; // ebx@2
  int v5; // ebx@6
  int v6; // eax@7
  DWORD v8; // eax@16
  char ProcessInformation; // [sp+4h] [bp-24h]@1
  int v10; // [sp+8h] [bp-20h]@2
  int v11; // [sp+1Ch] [bp-Ch]@4
  int v12; // [sp+20h] [bp-8h]@6
  unsigned int v13; // [sp+24h] [bp-4h]@7

  v3 = NtQueryInformationProcess(ProcessHandle, 0, &ProcessInformation, 0x18u, 0);
  if ( v3 >= 0 )
  {
    v4 = v10;
    if ( !Buffer && !ReadProcessMemory(ProcessHandle, (LPCVOID)(v10 + 8), &Buffer, 4u, 0)
      || !ReadProcessMemory(ProcessHandle, (LPCVOID)(v4 + 12), &v11, 4u, 0) )
      return 0;
    if ( v11 )
    {
      v5 = v11 + 20;
      if ( !ReadProcessMemory(ProcessHandle, (LPCVOID)(v11 + 20), &v12, 4u, 0) )
        return 0;
      v6 = v12;
      v13 = 0;
      while ( v6 != v5 )
      {
        if ( !ReadProcessMemory(ProcessHandle, (LPCVOID)(v6 - 8), lpBuffer, 0x78u, 0) )
          return 0;
        if ( *((_DWORD *)lpBuffer + 6) == Buffer )
          return 1;
        ++v13;
        v6 = *((_DWORD *)lpBuffer + 2);
        v12 = *((_DWORD *)lpBuffer + 2);
        if ( v13 > 0x2710 )
          break;
      }
    }
    SetLastError(6u);
    return 0;
  }
  v8 = RtlNtStatusToDosError(v3);
  SetLastError(v8);
  return 0;
}

//----- (77E1C9A1) --------------------------------------------------------
BOOL __stdcall DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
{
  BOOL result; // eax@2
  TIME_FIELDS TimeFields; // [sp+0h] [bp-18h]@1
  LARGE_INTEGER Time; // [sp+10h] [bp-8h]@1

  TimeFields.Year = (wFatDate >> 9) + 1980;
  TimeFields.Day = wFatDate & 0x1F;
  TimeFields.Month = (wFatDate >> 5) & 0xF;
  TimeFields.Hour = wFatTime >> 11;
  TimeFields.Second = 2 * (wFatTime & 0x1F);
  TimeFields.Milliseconds = 0;
  TimeFields.Minute = (wFatTime >> 5) & 0x3F;
  if ( RtlTimeFieldsToTime(&TimeFields, &Time) )
  {
    *lpFileTime = (struct _FILETIME)Time;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  return result;
}

//----- (77E1CA2B) --------------------------------------------------------
int __stdcall K32GetModuleFileNameExW(HANDLE hProcess, int Buffer, LPVOID lpBuffer, int a4)
{
  int result; // eax@1
  unsigned int v5; // edi@2
  unsigned int v6; // esi@2
  char v7; // [sp+0h] [bp-78h]@1
  unsigned __int16 v8; // [sp+24h] [bp-54h]@2
  LPCVOID lpBaseAddress; // [sp+28h] [bp-50h]@3

  result = FindModule(hProcess, Buffer, &v7);
  if ( result )
  {
    v5 = 2 * a4;
    v6 = v8 + 2;
    if ( 2 * a4 < v6 )
      v6 = 2 * a4;
    result = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, v6, 0);
    if ( result )
    {
      if ( v6 == v8 + 2 )
        v6 -= 2;
      if ( v6 >= v5 )
      {
        if ( v5 )
          *((_WORD *)lpBuffer + (v5 >> 1) - 1) = 0;
      }
      else
      {
        *((_WORD *)lpBuffer + (v6 >> 1)) = 0;
      }
      result = v6 >> 1;
    }
  }
  return result;
}

//----- (77E1CB0C) --------------------------------------------------------
BOOL __stdcall Module32FirstW(HANDLE hSnapshot, LPMODULEENTRY32W lpme)
{
  LPMODULEENTRY32W v2; // edi@1
  NTSTATUS v3; // eax@3
  LPMODULEENTRY32W v4; // eax@4
  LARGE_INTEGER SectionOffset; // [sp+Ch] [bp-10h]@3
  ULONG ViewSize; // [sp+14h] [bp-8h]@3
  int v8; // [sp+18h] [bp-4h]@1

  v2 = lpme;
  v8 = 0;
  if ( !lpme || lpme->dwSize != 1064 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lpme = 0;
  v3 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lpme,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  v4 = lpme;
  if ( lpme->th32ProcessID )
  {
    qmemcpy(v2, (char *)lpme + lpme->modBaseSize, 0x428u);
    *(_DWORD *)&v4->szModule[4] = 1;
    v8 = 1;
  }
  else
  {
    memset(&v2->th32ModuleID, 0, v2->dwSize - 4);
    RtlSetLastWin32Error(18);
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lpme);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1CD20) --------------------------------------------------------
NTSTATUS __stdcall ThpCopyAnsiToUnicode(int a1, PCSZ SourceString, __int16 a3)
{
  STRING DestinationString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING v5; // [sp+8h] [bp-8h]@1

  v5.Buffer = (PWCH)a1;
  v5.MaximumLength = a3;
  RtlInitAnsiString(&DestinationString, SourceString);
  return RtlAnsiStringToUnicodeString(&v5, &DestinationString, 0);
}

//----- (77E1CD5C) --------------------------------------------------------
int __stdcall K32EnumProcessModules(HANDLE ProcessHandle, int a2, int a3, int a4)
{
  return EnumProcessModulesInternal(ProcessHandle, a2, a3, a4, 1);
}

//----- (77E1CD7D) --------------------------------------------------------
int __stdcall EnumProcessModulesInternal(HANDLE ProcessHandle, int a2, int a3, int a4, int a5)
{
  NTSTATUS v5; // eax@1
  unsigned int v6; // esi@5
  int v7; // eax@5
  int result; // eax@12
  DWORD v9; // eax@17
  char v10; // [sp+10h] [bp-BCh]@7
  int v11; // [sp+18h] [bp-B4h]@11
  int v12; // [sp+28h] [bp-A4h]@14
  char ProcessInformation; // [sp+88h] [bp-44h]@1
  int v14; // [sp+8Ch] [bp-40h]@2
  int Buffer; // [sp+A0h] [bp-2Ch]@3
  int v16; // [sp+A4h] [bp-28h]@4
  int v17; // [sp+B0h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+B4h] [bp-18h]@12
  int v19; // [sp+DCh] [bp+10h]@5

  v5 = NtQueryInformationProcess(ProcessHandle, 0, &ProcessInformation, 0x18u, 0);
  if ( v5 < 0 )
  {
    v9 = RtlNtStatusToDosError(v5);
  }
  else
  {
    if ( v14 )
    {
      if ( !ReadProcessMemory(ProcessHandle, (LPCVOID)(v14 + 12), &Buffer, 4u, 0) )
        return 0;
      v16 = Buffer + 20;
      if ( !ReadProcessMemory(ProcessHandle, (LPCVOID)(Buffer + 20), &v17, 4u, 0) )
        return 0;
      v6 = (unsigned int)a3 >> 2;
      v19 = 0;
      v7 = v17;
      while ( 1 )
      {
        if ( v7 == v16 )
        {
          result = 1;
          *(_DWORD *)a4 = 4 * v19;
          ms_exc.registration.TryLevel = -2;
          return result;
        }
        if ( !ReadProcessMemory(ProcessHandle, (LPCVOID)(v7 - 8), &v10, 0x78u, 0) )
          return 0;
        if ( a5 )
        {
          if ( v19 < v6 )
          {
            *(_DWORD *)(a2 + 4 * v19) = v12;
            ms_exc.registration.TryLevel = -2;
          }
          ++v19;
          if ( (unsigned int)v19 > 0x2710 )
          {
            SetLastError(6u);
            return 0;
          }
        }
        else
        {
          a5 = 1;
        }
        v7 = v11;
        v17 = v11;
      }
    }
    v9 = RtlNtStatusToDosError(-2147483635);
  }
  SetLastError(v9);
  return 0;
}

//----- (77E1CEB3) --------------------------------------------------------
signed int __stdcall BaseDllReadWriteIniFile(char a1, char a2, char a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@37
  int v9; // ecx@1
  int v10; // eax@6
  signed int result; // eax@7
  int v12; // esi@8
  NTSTATUS v13; // ebx@10
  int v14; // eax@14
  int v15; // edi@42
  PPEB v16; // eax@52
  signed int v17; // [sp-4h] [bp-FCh]@25
  PVOID Address; // [sp+10h] [bp-E8h]@2
  char v19; // [sp+14h] [bp-E4h]@44
  NTSTATUS v20; // [sp+34h] [bp-C4h]@44
  char v21; // [sp+3Ch] [bp-BCh]@44

  v9 = a6;
  if ( a3 )
    v9 = 0;
  LOBYTE(Address) = 0;
  if ( !a2 )
  {
    if ( a5 )
    {
      if ( a7 )
      {
        if ( v9 )
        {
          v10 = 1;
          goto LABEL_7;
        }
        LOBYTE(Address) = 1;
        if ( a3 )
          v17 = 6;
        else
          v17 = 4;
        goto LABEL_30;
      }
      return -1073741811;
    }
    if ( a3 || !a7 )
      return -1073741811;
    v9 = 0;
    v17 = 5;
    goto LABEL_29;
  }
  if ( a5 )
  {
    if ( !v9 )
    {
      if ( !a7 )
      {
        v17 = 8;
        goto LABEL_30;
      }
      v17 = 7;
LABEL_29:
      LOBYTE(Address) = 1;
LABEL_30:
      v10 = v17;
      goto LABEL_7;
    }
    v10 = 3 - (a7 != 0);
  }
  else
  {
    v10 = a4 != 0 ? 9 : 0;
  }
LABEL_7:
  result = BaseDllCaptureIniFileParameters(a1, v10, a2, (char)Address, a4, a5, v9, a7, a8, (int)&Address);
  if ( result >= 0 )
  {
    v12 = (int)Address;
    if ( *(_DWORD *)Address == 9 )
    {
      v15 = 0;
      if ( *((_WORD *)Address + 8) > 0x208u )
      {
        v13 = -1073741811;
      }
      else
      {
        v15 = CsrAllocateCaptureBuffer(1, *((_WORD *)Address + 9));
        if ( v15 )
        {
          CsrCaptureMessageString(v15, *(_DWORD *)(v12 + 20), *(_WORD *)(v12 + 16), *(_WORD *)(v12 + 18), &v21);
          CsrClientCallServer(&v19, v15, 65555, 8);
          v13 = v20;
        }
        else
        {
          v13 = -1073741801;
        }
      }
      CsrFreeCaptureBuffer(v15);
    }
    else if ( *((_DWORD *)Address + 2) )
    {
      v13 = BaseDllReadWriteIniFileViaMapping((PCUNICODE_STRING)Address);
    }
    else
    {
      v13 = -1073741802;
    }
    if ( v13 == -1073741802 )
      v13 = BaseDllReadWriteIniFileOnDisk((STRING *)v12);
    if ( v13 >= 0 )
    {
      v14 = *(_DWORD *)v12;
      if ( *(_DWORD *)v12 == 5 || v14 == 4 || v14 == 6 )
        v13 = BaseDllAppendNullToResultBuffer(v12);
      if ( v13 >= 0 )
        goto LABEL_58;
    }
    if ( v13 == -2147483643 )
    {
LABEL_58:
      if ( *(_BYTE *)(v12 + 4) )
      {
        v8 = KernelBaseGetGlobalData();
        ++*(_DWORD *)(v8 + 68);
      }
      else if ( a8 )
      {
        *(_DWORD *)a8 = *(_DWORD *)(v12 + 76);
      }
    }
    if ( *(_BYTE *)(v12 + 6) )
    {
      v16 = NtCurrentTeb()->ProcessEnvironmentBlock;
      if ( *(_BYTE *)(v12 + 5) )
        RtlFreeHeap(v16->Reserved4[1], 0, *(PVOID *)(v12 + 84));
      else
        RtlFreeHeap(v16->Reserved4[1], 0, *(PVOID *)(v12 + 76));
      v12 = (int)Address;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v12);
    result = v13;
  }
  return result;
}
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE145C: using guessed type int __stdcall CsrCaptureMessageString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E1D001) --------------------------------------------------------
signed int __stdcall BaseDllCaptureIniFileParameters(char a1, int a2, char a3, char a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  __int16 v10; // ax@47
  int v11; // ebx@1
  char v12; // al@3
  int v13; // ebx@4
  int v14; // esi@12
  int v15; // eax@14
  PVOID v16; // esi@14
  ULONG v17; // eax@15
  int v18; // edi@15
  int v19; // eax@17
  unsigned int v20; // edx@18
  int v21; // eax@18
  __int16 v22; // dx@20
  int v23; // ebx@24
  int v24; // ebx@25
  int v25; // ecx@26
  __int16 v26; // dx@26
  __int16 v27; // ax@26
  int v28; // ecx@29
  __int16 v29; // dx@29
  __int16 v30; // ax@29
  int v31; // eax@31
  signed int result; // eax@37
  char v33; // cl@56
  int v34; // eax@56
  int v35; // eax@57
  __int16 v36; // cx@62
  int v37; // ecx@65
  __int16 v38; // ax@67
  int v39; // ecx@69
  char v40; // al@71
  __int16 v41; // [sp+Ch] [bp-18h]@17
  __int16 v42; // [sp+Eh] [bp-16h]@17
  int v43; // [sp+10h] [bp-14h]@17
  ULONG v44; // [sp+14h] [bp-10h]@12
  int v45; // [sp+18h] [bp-Ch]@8
  int v46; // [sp+1Ch] [bp-8h]@6
  int v47; // [sp+20h] [bp-4h]@11
  int v48; // [sp+38h] [bp+14h]@17

  v11 = a5;
  if ( a5 )
  {
    if ( a1 )
    {
      do
      {
        v10 = *(_WORD *)v11;
        v11 += 2;
      }
      while ( v10 );
      v13 = (v11 - (a5 + 2)) >> 1;
    }
    else
    {
      do
        v12 = *(_BYTE *)v11++;
      while ( v12 );
      v13 = v11 - (a5 + 1);
    }
  }
  else
  {
    v13 = 0;
  }
  if ( a6 )
  {
    v46 = BaseDllIniFileNameLength(a1, (unsigned int *)&a6);
  }
  else
  {
    v46 = 0;
    a7 = 0;
  }
  if ( a7 )
    v45 = BaseDllIniFileNameLength(a1, (unsigned int *)&a7);
  else
    v45 = 0;
  if ( a8 && !a9 )
  {
    if ( a4 )
    {
      v37 = a8;
      if ( a1 )
      {
        if ( *(_WORD *)a8 )
        {
          do
          {
            do
            {
              v38 = *(_WORD *)v37;
              v37 += 2;
            }
            while ( v38 );
          }
          while ( *(_WORD *)v37 );
        }
        v39 = (v37 - a8) >> 1;
      }
      else
      {
        if ( *(_BYTE *)a8 )
        {
          do
          {
            do
              v40 = *(_BYTE *)v37++;
            while ( v40 );
          }
          while ( *(_BYTE *)v37 );
        }
        v39 = v37 - a8;
      }
      v47 = v39;
    }
    else
    {
      v34 = a8;
      if ( a1 )
      {
        do
        {
          v36 = *(_WORD *)v34;
          v34 += 2;
        }
        while ( v36 );
        v35 = (v34 - (a8 + 2)) >> 1;
      }
      else
      {
        do
          v33 = *(_BYTE *)v34++;
        while ( v33 );
        v35 = v34 - (a8 + 1);
      }
      v47 = v35;
    }
  }
  else
  {
    v47 = 0;
  }
  v44 = 2 * RtlGetLongestNtPathLength();
  v14 = v44 + 176;
  if ( !a1 )
    v14 += 2 * v13 + 2;
  v15 = KernelBaseGetGlobalData();
  v16 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          *(_DWORD *)(v15 + 44),
          v14 + 2 * (v46 + v45 + v47) + 6);
  if ( v16 )
  {
    *((_DWORD *)v16 + 3) = 0;
    *(_DWORD *)v16 = a2;
    *((_BYTE *)v16 + 4) = a3;
    *((_BYTE *)v16 + 72) = a4;
    *((_WORD *)v16 + 16) = 0;
    v17 = v44;
    *((_DWORD *)v16 + 9) = (char *)v16 + 176;
    v18 = (int)((char *)v16 + v17 + 176);
    *((_BYTE *)v16 + 5) = a1;
    *((_BYTE *)v16 + 6) = 0;
    *((_WORD *)v16 + 17) = v17;
    if ( !a5 )
    {
      RtlInitUnicodeString((PUNICODE_STRING)v16 + 3, L"win.ini");
      *((_DWORD *)v16 + 4) = *((_DWORD *)v16 + 6);
      *((_DWORD *)v16 + 5) = *((_DWORD *)v16 + 7);
      *((_DWORD *)v16 + 2) = *(_DWORD *)(BaseDllIniFileMapping + 8);
      goto LABEL_25;
    }
    *((_WORD *)v16 + 13) = 2 * v13 + 2;
    if ( a1 )
    {
      *((_WORD *)v16 + 12) = 2 * v13;
      *((_DWORD *)v16 + 7) = a5;
LABEL_18:
      v20 = *((_DWORD *)v16 + 7);
      *((_WORD *)v16 + 8) = 0;
      v21 = v20 + 2 * v13;
      if ( v13 )
      {
        v21 -= 2;
        if ( v21 > v20 )
        {
          while ( 1 )
          {
            v22 = *(_WORD *)v21;
            if ( *(_WORD *)v21 == 92 || v22 == 47 || v22 == 58 )
              break;
            v21 -= 2;
            if ( (unsigned int)v21 <= *((_DWORD *)v16 + 7) )
              goto LABEL_24;
          }
          v21 += 2;
        }
      }
LABEL_24:
      *((_DWORD *)v16 + 5) = v21;
      v23 = 2 * (v13 - ((v21 - *((_DWORD *)v16 + 7)) >> 1));
      *((_WORD *)v16 + 8) = v23;
      *((_WORD *)v16 + 9) = v23 + 2;
      BaseDllFindIniFileNameMapping((PCUNICODE_STRING)v16 + 3, (int)((char *)v16 + 16), (int)((char *)v16 + 8));
LABEL_25:
      v24 = a6;
      if ( a6 )
      {
        v25 = v46;
        v26 = 2 * v46;
        v27 = 2 * v46 + 1;
        *((_WORD *)v16 + 21) = v27;
        *((_WORD *)v16 + 29) = 2 * v27;
        if ( a1 )
        {
          *((_DWORD *)v16 + 11) = v18;
          *((_DWORD *)v16 + 15) = v24;
          *((_WORD *)v16 + 28) = v26;
          *((_WORD *)v16 + 20) = 0;
          v18 += 2 * v25 + 1;
        }
        else
        {
          *((_DWORD *)v16 + 15) = v18;
          *((_DWORD *)v16 + 11) = v24;
          *((_WORD *)v16 + 20) = v25;
          *((_WORD *)v16 + 28) = 0;
          v18 += 2 * v25 + 2;
        }
      }
      else
      {
        RtlInitAnsiString((PANSI_STRING)v16 + 5, 0);
        RtlInitUnicodeString((PUNICODE_STRING)v16 + 7, 0);
      }
      if ( a7 )
      {
        v28 = v45;
        v29 = 2 * v45;
        v30 = 2 * v45 + 1;
        *((_WORD *)v16 + 25) = v30;
        *((_WORD *)v16 + 33) = 2 * v30;
        if ( a1 )
        {
          *((_DWORD *)v16 + 17) = a7;
          *((_DWORD *)v16 + 13) = v18;
          *((_WORD *)v16 + 32) = v29;
          *((_WORD *)v16 + 24) = 0;
          v18 += 2 * v28 + 1;
        }
        else
        {
          *((_DWORD *)v16 + 13) = a7;
          *((_DWORD *)v16 + 17) = v18;
          *((_WORD *)v16 + 24) = v28;
          *((_WORD *)v16 + 32) = 0;
          v18 += 2 * v28 + 2;
        }
      }
      else
      {
        RtlInitAnsiString((PANSI_STRING)v16 + 6, 0);
        RtlInitUnicodeString((PUNICODE_STRING)v16 + 8, 0);
      }
      v31 = a8;
      if ( a8 )
      {
        if ( !*((_BYTE *)v16 + 4) )
        {
          if ( a9 )
            *((_DWORD *)v16 + 20) = *(_DWORD *)a9;
          else
            *((_DWORD *)v16 + 20) = 0;
          *((_DWORD *)v16 + 19) = 0;
          JUMPOUT(a1 != 0, &loc_77E18103);
          *((_DWORD *)v16 + 21) = v31;
          goto LABEL_36;
        }
        if ( !a1 )
        {
          *((_DWORD *)v16 + 19) = a8;
          *((_DWORD *)v16 + 20) = v47;
          *(_WORD *)v18 = 0;
          *((_DWORD *)v16 + 21) = v18;
LABEL_36:
          *((_DWORD *)v16 + 22) = 0;
LABEL_37:
          *(_DWORD *)a10 = v16;
          return 0;
        }
        *((_DWORD *)v16 + 21) = a8;
        *((_DWORD *)v16 + 22) = 2 * v47;
        *(_BYTE *)v18 = 0;
        *((_DWORD *)v16 + 19) = v18;
      }
      else
      {
        *((_DWORD *)v16 + 19) = 0;
        *((_DWORD *)v16 + 21) = 0;
        *((_DWORD *)v16 + 22) = 0;
      }
      *((_DWORD *)v16 + 20) = 0;
      goto LABEL_37;
    }
    v43 = a5;
    v42 = v13 + 1;
    v41 = v13;
    *((_DWORD *)v16 + 7) = v18;
    *((_WORD *)v16 + 12) = 0;
    v18 += 2 * v13 + 2;
    v19 = KernelBaseGetGlobalData();
    v48 = (*(int (__stdcall **)(char *, __int16 *, _DWORD))(v19 + 24))((char *)v16 + 24, &v41, 0);
    if ( v48 >= 0 )
      goto LABEL_18;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v16);
    result = v48;
  }
  else
  {
    result = -1073741801;
  }
  return result;
}
// 77EA6090: using guessed type int BaseDllIniFileMapping;

//----- (77E1D27C) --------------------------------------------------------
int __stdcall BaseDllIniFileNameLength(char a1, unsigned int *a2)
{
  unsigned int v2; // eax@1
  int result; // eax@9

  v2 = *a2;
  if ( a1 )
  {
    while ( *(_WORD *)v2 == 32 )
      v2 += 2;
    *a2 = v2;
    while ( *(_WORD *)v2 )
      v2 += 2;
    if ( v2 > *a2 )
    {
      do
        v2 -= 2;
      while ( *(_WORD *)v2 == 32 );
      v2 += 2;
    }
    result = (signed int)(v2 - *a2) >> 1;
  }
  else
  {
    while ( *(_BYTE *)v2 == 32 )
      ++v2;
    *a2 = v2;
    while ( *(_BYTE *)v2 )
      ++v2;
    if ( v2 > *a2 )
    {
      do
        --v2;
      while ( *(_BYTE *)v2 == 32 );
      ++v2;
    }
    result = v2 - *a2;
  }
  return result;
}

//----- (77E1D2BD) --------------------------------------------------------
char __stdcall BaseDllGetApplicationName(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  NTSTATUS v6; // eax@7

  v3 = a2;
  if ( a2 )
  {
    v4 = a1 + 40;
    if ( *(_WORD *)(a1 + 40) )
    {
LABEL_3:
      *(_DWORD *)v3 = v4;
      return 1;
    }
    v6 = RtlUnicodeStringToAnsiString((PANSI_STRING)(a1 + 40), (PCUNICODE_STRING)(a1 + 56), 0);
  }
  else
  {
    v3 = a3;
    if ( !a3 )
      return 0;
    v4 = a1 + 56;
    if ( *(_WORD *)(a1 + 56) )
      goto LABEL_3;
    v6 = RtlAnsiStringToUnicodeString((PUNICODE_STRING)(a1 + 56), (PCANSI_STRING)(a1 + 40), 0);
  }
  if ( v6 >= 0 )
    goto LABEL_3;
  return 0;
}

//----- (77E1D334) --------------------------------------------------------
NTSTATUS __stdcall BaseDllReadWriteIniFileViaMapping(PCUNICODE_STRING String2)
{
  ULONG v1; // esi@1
  int v2; // eax@4
  int v3; // ecx@5

  v1 = (ULONG)String2;
  if ( !*(_DWORD *)&String2->Length )
    return 0;
  if ( *(_DWORD *)&String2->Length == 5 )
    return BaseDllReadApplicationNames((int)String2);
  if ( !BaseDllGetApplicationName((int)String2, 0, (int)&String2) )
    return -1073741811;
  v2 = BaseDllFindVarNameMapping(*(_DWORD *)(v1 + 8), String2);
  if ( !v2 )
    return -1073741802;
  v3 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 == 1 )
    return BaseDllReadVariableValue(v1, v2, 0, 0);
  if ( v3 == 4 )
    return BaseDllReadVariableNames(v1, v2);
  if ( v3 == 6 )
    return (NTSTATUS)BaseDllReadApplicationVariables(v1, v2);
  if ( v3 != 2 && v3 != 3 )
  {
    if ( v3 == 7 || v3 == 8 )
      return BaseDllWriteApplicationVariables(v1, v2);
    return -1073741811;
  }
  return BaseDllWriteVariableValue(v1, v2, 0, 0);
}

//----- (77E1D39D) --------------------------------------------------------
int __stdcall BaseDllFindVarNameMapping(int a1, PCUNICODE_STRING String2)
{
  int v2; // esi@1
  PPEB v3; // edi@1
  int v4; // ebx@7
  UNICODE_STRING String1; // [sp+Ch] [bp-8h]@4

  v2 = *(_DWORD *)(a1 + 12);
  v3 = NtCurrentTeb()->ProcessEnvironmentBlock;
  while ( v2 )
  {
    if ( v3->Reserved2[0] & 2 )
    {
      if ( BaseVerifyFileName(v2, (int)&String1) < 0 )
        return 0;
    }
    else
    {
      *(_DWORD *)&String1.Length = *(_DWORD *)(v2 + 4);
      String1.Buffer = *(PWCH *)(v2 + 8);
    }
    if ( RtlEqualUnicodeString(&String1, String2, 1u) )
      return v2;
    v2 = *(_DWORD *)v2;
  }
  v4 = *(_DWORD *)(a1 + 16);
  if ( !v4 || !(v3->Reserved2[0] & 2) || BaseVerifyFileName(v4, 0) >= 0 )
    return v4;
  return 0;
}

//----- (77E1D43B) --------------------------------------------------------
char __stdcall BaseDllGetVariableName(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  NTSTATUS v6; // eax@7

  v3 = a2;
  if ( a2 )
  {
    v4 = a1 + 48;
    if ( *(_WORD *)(a1 + 48) )
    {
LABEL_3:
      *(_DWORD *)v3 = v4;
      return 1;
    }
    v6 = RtlUnicodeStringToAnsiString((PANSI_STRING)(a1 + 48), (PCUNICODE_STRING)(a1 + 64), 0);
  }
  else
  {
    v3 = a3;
    if ( !a3 )
      return 0;
    v4 = a1 + 64;
    if ( *(_WORD *)(a1 + 64) )
      goto LABEL_3;
    v6 = RtlAnsiStringToUnicodeString((PUNICODE_STRING)(a1 + 64), (PCANSI_STRING)(a1 + 48), 0);
  }
  if ( v6 >= 0 )
    goto LABEL_3;
  return 0;
}

//----- (77E1D497) --------------------------------------------------------
int __stdcall BaseDllReadVariableValue(int a1, int a2, int a3, UNICODE_STRING *a4)
{
  int v4; // esi@1
  int result; // eax@5
  NTSTATUS v6; // eax@7
  int v7; // edi@7
  PCUNICODE_STRING v8; // [sp+14h] [bp-34h]@4
  ULONG ResultLength; // [sp+18h] [bp-30h]@7
  int v10; // [sp+24h] [bp-24h]@1
  HANDLE KeyHandle; // [sp+28h] [bp-20h]@5
  PUNICODE_STRING ValueName; // [sp+2Ch] [bp-1Ch]@1
  char v13; // [sp+33h] [bp-15h]@2
  char KeyValueInformation; // [sp+34h] [bp-14h]@7

  v4 = a3;
  v10 = a1;
  ValueName = a4;
  JUMPOUT(a4, 0, &loc_77E46565);
  if ( !BaseDllGetVariableName(a1, 0, (int)&ValueName) )
    return -1073741811;
  v13 = 0;
  if ( !a3 )
  {
    v4 = BaseDllFindVarNameMapping(a2, ValueName);
    if ( !v4 )
      return -1073741802;
  }
  if ( !BaseDllGetApplicationName(a1, 0, (int)&v8) )
    return -1073741811;
  result = BaseDllOpenMappingTarget(a1, v4, v8, 0, &KeyHandle);
  if ( result >= 0 && KeyHandle != (HANDLE)-1 )
  {
    v6 = NtQueryValueKey(KeyHandle, ValueName, KeyValuePartialInformation, &KeyValueInformation, 0x10u, &ResultLength);
    v7 = v6;
    if ( v6 >= 0 )
      JUMPOUT(&loc_77E17AA1);
    JUMPOUT(v6, -2147483643, &loc_77E17B4B);
    NtClose(KeyHandle);
    result = v7;
  }
  return result;
}

//----- (77E1D574) --------------------------------------------------------
int __stdcall BaseDllOpenMappingTarget(int a1, int a2, PCUNICODE_STRING a3, char a4, PHANDLE a5)
{
  int v5; // eax@1
  unsigned int v6; // edi@1
  int v7; // esi@12
  int v8; // esi@13
  int v9; // esi@17
  int result; // eax@25
  unsigned int v11; // ecx@47
  ULONG Disposition; // [sp+8h] [bp-84h]@50
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-80h]@8
  OBJECT_ATTRIBUTES v14; // [sp+24h] [bp-68h]@50
  OBJECT_ATTRIBUTES v15; // [sp+3Ch] [bp-50h]@23
  HANDLE Handle; // [sp+54h] [bp-38h]@50
  HANDLE KeyHandle; // [sp+58h] [bp-34h]@8
  ULONG v18; // [sp+5Ch] [bp-30h]@52
  UNICODE_STRING v19; // [sp+60h] [bp-2Ch]@3
  LSA_UNICODE_STRING v20; // [sp+68h] [bp-24h]@47
  unsigned int v21; // [sp+70h] [bp-1Ch]@13
  LSA_UNICODE_STRING DestinationString; // [sp+74h] [bp-18h]@5
  LSA_UNICODE_STRING Destination; // [sp+7Ch] [bp-10h]@17
  PCUNICODE_STRING Source; // [sp+84h] [bp-8h]@9
  char v25; // [sp+8Bh] [bp-1h]@1
  int v26; // [sp+98h] [bp+Ch]@8
  int v27; // [sp+98h] [bp+Ch]@24
  char v28; // [sp+9Bh] [bp+Fh]@16

  *a5 = (HANDLE)-1;
  v5 = *(_DWORD *)(a2 + 16);
  v6 = *(_DWORD *)(a2 + 12) & 0xF0000000;
  v25 = 0;
  if ( !v5 )
    return 0;
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->Reserved2[0] & 2 )
  {
    result = BaseVerifyMappingTarget(v5, (int)&v19);
    if ( result < 0 )
      return result;
  }
  else
  {
    *(_DWORD *)&v19.Length = *(_DWORD *)(v5 + 4);
    v19.Buffer = *(PWCH *)(v5 + 8);
  }
  if ( !v19.Length )
    return 0;
  RtlInitUnicodeString(&DestinationString, 0);
  if ( (v6 & 0x80000000) == 0 )
  {
    if ( v6 & 0x40000000 )
    {
      Source = (PCUNICODE_STRING)&BaseDllIniSoftwareKeyPath;
      goto LABEL_12;
    }
    Source = 0;
  }
  else
  {
    if ( *(_BYTE *)(KernelBaseGetGlobalData() + 48) == 1 )
      return -1073741790;
    if ( RtlFormatCurrentUserKeyPath(&DestinationString) < 0
      || ((ObjectAttributes.ObjectName = &DestinationString,
           ObjectAttributes.Length = 24,
           ObjectAttributes.RootDirectory = 0,
           ObjectAttributes.Attributes = 64,
           ObjectAttributes.SecurityDescriptor = 0,
           ObjectAttributes.SecurityQualityOfService = 0,
           v26 = NtOpenKey(&KeyHandle, 0x80000000, &ObjectAttributes),
           v26 < 0) ? (RtlFreeUnicodeString(&DestinationString), RtlInitUnicodeString(&DestinationString, 0)) : (NtClose(KeyHandle), Source = &DestinationString),
          v26 < 0) )
      Source = (PCUNICODE_STRING)&BaseDllIniDefaultUserKeyPath;
  }
  if ( !Source )
  {
    v7 = 0;
    goto LABEL_13;
  }
LABEL_12:
  v7 = Source->Length + 2;
LABEL_13:
  v21 = v6 & 0x10000000;
  v8 = v19.Length + v7 + 2;
  if ( v6 & 0x10000000 )
    v8 += *(_WORD *)(a1 + 16) + 2;
  if ( a3 && v6 & 0x20000000 )
  {
    v8 += a3->Length + 2;
    v28 = 1;
  }
  else
  {
    v28 = 0;
  }
  v9 = v8 + 2;
  Destination.Buffer = (PWCH)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
  if ( Destination.Buffer )
  {
    Destination.MaximumLength = v9;
    Destination.Length = 0;
    if ( Source )
    {
      RtlAppendUnicodeStringToString(&Destination, Source);
      RtlAppendUnicodeToString(&Destination, L"\\");
      if ( Source == &DestinationString )
        RtlFreeUnicodeString(&DestinationString);
    }
    RtlAppendUnicodeStringToString(&Destination, &v19);
    if ( v21 )
    {
      RtlAppendUnicodeToString(&Destination, L"\\");
      RtlAppendUnicodeStringToString(&Destination, (PCUNICODE_STRING)(a1 + 16));
    }
    if ( v28 )
    {
      RtlAppendUnicodeToString(&Destination, L"\\");
      RtlAppendUnicodeStringToString(&Destination, a3);
    }
    v15.Length = 24;
    v15.RootDirectory = 0;
    v15.Attributes = 192;
    v15.ObjectName = &Destination;
    v15.SecurityDescriptor = 0;
    v15.SecurityQualityOfService = 0;
    if ( a4 )
    {
      while ( 1 )
      {
        v27 = NtCreateKey(a5, 0x2000Fu, &v15, 0, 0, 0, &v18);
        if ( v27 != -1073741772 )
          break;
        if ( v25 )
          break;
        v11 = Destination.Length;
        v20 = Destination;
        while ( Destination.Buffer[v11 >> 1] != 92 )
        {
          v20.Length -= 2;
          v11 = v20.Length;
        }
        v14.ObjectName = &v20;
        v14.Length = 24;
        v14.RootDirectory = 0;
        v14.Attributes = 192;
        v14.SecurityDescriptor = 0;
        v14.SecurityQualityOfService = 0;
        if ( NtCreateKey(&Handle, 0x2000Fu, &v14, 0, 0, 0, &Disposition) < 0 )
          break;
        NtClose(Handle);
        v25 = 1;
      }
    }
    else
    {
      v27 = NtOpenKey(a5, 0x80000000, &v15);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Destination.Buffer);
    result = v27;
  }
  else
  {
    if ( Source == &DestinationString )
      RtlFreeUnicodeString(&DestinationString);
    result = -1073741801;
  }
  return result;
}
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);
// 77E16BBC: using guessed type int BaseDllIniSoftwareKeyPath;
// 77E16BC4: using guessed type int BaseDllIniDefaultUserKeyPath;

//----- (77E1D771) --------------------------------------------------------
signed int __stdcall BaseDllOpenIniFileOnDisk(int a1)
{
  UNICODE_STRING *v1; // esi@1
  unsigned __int16 v2; // ax@1
  unsigned int v3; // eax@3
  PVOID v4; // esi@6
  int v5; // eax@8
  PVOID v6; // eax@8
  NTSTATUS v7; // eax@11
  NTSTATUS v8; // eax@14
  int v9; // eax@19
  bool v10; // zf@19
  PVOID *v11; // edi@19
  int v12; // eax@19
  int v13; // eax@22
  PVOID v14; // ST20_4@24
  char v15; // al@24
  PVOID v16; // ecx@24
  int v17; // eax@24
  char v18; // dl@26
  int v19; // eax@29
  int v21; // eax@41
  int v22; // eax@51
  int v23; // eax@52
  int v24; // eax@61
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-44h]@10
  LSA_UNICODE_STRING ntname; // [sp+24h] [bp-2Ch]@7
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+2Ch] [bp-24h]@11
  ULARGE_INTEGER LockOffset; // [sp+34h] [bp-1Ch]@14
  ULARGE_INTEGER LockLength; // [sp+3Ch] [bp-14h]@14
  LPWSTR FilePart; // [sp+44h] [bp-Ch]@3
  void (__stdcall *v31)(UNICODE_STRING *, int); // [sp+48h] [bp-8h]@1
  NTSTATUS v32; // [sp+4Ch] [bp-4h]@5

  v31 = *(void (__stdcall **)(UNICODE_STRING *, int))(KernelBaseGetGlobalData() + 104);
  v1 = (UNICODE_STRING *)(a1 + 32);
  *(_WORD *)(a1 + 32) = 0;
  v2 = *(_WORD *)(a1 + 24);
  if ( v2 > 2u && *(_WORD *)(*(_DWORD *)(a1 + 28) + 2) == 58
    || v2 && _wcscspn(*(const wchar_t **)(a1 + 28), L"\\/") != (unsigned int)*(_WORD *)(a1 + 24) >> 1 )
  {
    v3 = GetFullPathNameW(
           *(LPCWSTR *)(a1 + 28),
           (unsigned int)*(_WORD *)(a1 + 34) >> 1,
           *(LPWSTR *)(a1 + 36),
           &FilePart);
    if ( v3 > (unsigned int)*(_WORD *)(a1 + 34) >> 1 )
    {
      v32 = -1073741789;
    }
    else if ( v3 <= 0 )
    {
      v32 = -1073741823;
    }
    else
    {
      v1->Length = 2 * v3;
      v32 = 0;
      if ( v31 )
      {
        v22 = KernelBaseGetGlobalData();
        v31(v1, v22 + 52);
      }
    }
  }
  else if ( !gpTermsrvBuildIniFileName || (v23 = gpTermsrvBuildIniFileName(v1, a1 + 16), v32 = v23, v23 < 0) )
  {
    v21 = KernelBaseGetGlobalData();
    RtlCopyUnicodeString(v1, (PCUNICODE_STRING)(v21 + 52));
    v32 = RtlAppendUnicodeToString(v1, L"\\");
    if ( v32 >= 0 )
      v32 = RtlAppendUnicodeStringToString(v1, (PCUNICODE_STRING)(a1 + 16));
  }
  v4 = 0;
  if ( v32 < 0 )
    return v32;
  if ( !RtlDosPathNameToNtPathName_U(*(PWSTR *)(a1 + 36), &ntname, &FilePart, 0) )
  {
    v32 = -1073741766;
    goto LABEL_13;
  }
  RtlCopyUnicodeString((PUNICODE_STRING)(a1 + 32), &ntname);
  RtlFreeUnicodeString(&ntname);
  v5 = KernelBaseGetGlobalData();
  v6 = RtlAllocateHeap(
         NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
         (*(_DWORD *)(v5 + 44) + 0x80000) | 8,
         *(_WORD *)(a1 + 34) + 120);
  v4 = v6;
  if ( v6 )
  {
    *((_DWORD *)v6 + 3) = (char *)v6 + 120;
    *((_WORD *)v6 + 5) = *(_WORD *)(a1 + 34);
    RtlCopyUnicodeString((PUNICODE_STRING)v6 + 1, (PCUNICODE_STRING)(a1 + 32));
    *((_DWORD *)v4 + 4) = *(_DWORD *)(a1 + 8);
    *((_BYTE *)v4 + 24) = *(_BYTE *)(a1 + 4);
    if ( gpTermsrvCORIniFile )
      gpTermsrvCORIniFile((char *)v4 + 8);
    ObjectAttributes.ObjectName = (PUNICODE_STRING)((char *)v4 + 8);
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( *((_BYTE *)v4 + 24) )
      v7 = NtCreateFile((PHANDLE)v4 + 5, 0xC0100000, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 7u, 3u, 0x60u, 0, 0);
    else
      v7 = NtOpenFile((PHANDLE)v4 + 5, 0x80100000, &ObjectAttributes, &IoStatusBlock, 7u, 0x60u);
    v32 = v7;
LABEL_13:
    if ( v32 < 0 )
      goto LABEL_66;
    *((_BYTE *)v4 + 26) = 0;
    LockLength = (ULARGE_INTEGER)-1i64;
    LockOffset = 0i64;
    v8 = NtLockFile(
           *((HANDLE *)v4 + 5),
           0,
           0,
           0,
           &IoStatusBlock,
           &LockOffset,
           &LockLength,
           LockFileKey,
           0,
           *((_BYTE *)v4 + 24));
    v32 = v8;
    if ( v8 < 0 )
    {
      if ( v8 == -1073741637 )
        v32 = 0;
    }
    else
    {
      *((_BYTE *)v4 + 26) = 1;
    }
    if ( v32 < 0 )
      goto LABEL_66;
    v32 = NtQueryInformationFile(*((HANDLE *)v4 + 5), &IoStatusBlock, (char *)v4 + 96, 0x18u, FileStandardInformation);
    if ( v32 == -2147483643 )
      v32 = 0;
    if ( v32 < 0 )
    {
LABEL_66:
      if ( !v4 )
        return v32;
      if ( *((_BYTE *)v4 + 26) )
      {
        LockLength = (ULARGE_INTEGER)-1i64;
        LockOffset = 0i64;
        NtUnlockFile(*((HANDLE *)v4 + 5), &IoStatusBlock, &LockOffset, &LockLength, LockFileKey);
      }
      NtClose(*((HANDLE *)v4 + 5));
    }
    else
    {
      v9 = *((_DWORD *)v4 + 26);
      v10 = *((_BYTE *)v4 + 25) == 0;
      *((_DWORD *)v4 + 7) = v9;
      v11 = (PVOID *)((char *)v4 + 32);
      v12 = v9 + 4 * (!v10 + 1);
      *((_DWORD *)v4 + 9) = v12;
      *((_DWORD *)v4 + 10) = v12 + 0x100000;
      v32 = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, (PVOID *)v4 + 8, 0, (PULONG)v4 + 10, 0x2000u, 4u);
      if ( v32 >= 0 )
      {
        v32 = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, (PVOID *)v4 + 8, 0, (PULONG)v4 + 9, 0x1000u, 4u);
        if ( v32 >= 0 )
        {
          v32 = NtReadFile(*((HANDLE *)v4 + 5), 0, 0, 0, &IoStatusBlock, *v11, *((_DWORD *)v4 + 7), 0, &LockFileKey);
          if ( v32 >= 0 )
          {
            v13 = *((_DWORD *)v4 + 7);
            if ( IoStatusBlock.Information != v13 )
              v32 = -1073741807;
            if ( v32 >= 0 )
            {
              v31 = (void (__stdcall *)(UNICODE_STRING *, int))-1;
              *((_DWORD *)v4 + 11) = -1;
              v14 = *v11;
              *((_DWORD *)v4 + 12) = 0;
              v15 = RtlIsTextUnicode(v14, v13, &v31);
              v16 = *v11;
              *((_BYTE *)v4 + 25) = v15;
              JUMPOUT(v15 != 0, &loc_77E18228);
              v17 = (int)((char *)v16 + *((_DWORD *)v4 + 7));
              while ( v17 > (unsigned int)v16 )
              {
                --v17;
                v18 = *(_BYTE *)v17;
                if ( *(_BYTE *)v17 > 0x20u || v18 == 13 || v18 == 10 )
                  break;
                --*((_DWORD *)v4 + 7);
              }
              v19 = (int)((char *)v16 + *((_DWORD *)v4 + 7));
              if ( v19 > (unsigned int)v16 && *(_BYTE *)(v19 - 1) != 10 )
              {
                *(_BYTE *)v19 = 13;
                *(_BYTE *)(v19 + 1) = 10;
                v24 = *((_DWORD *)v4 + 7);
                *((_DWORD *)v4 + 11) = v24;
                v24 += 2;
                *((_DWORD *)v4 + 7) = v24;
                *((_DWORD *)v4 + 12) = v24;
              }
              *(_DWORD *)(a1 + 12) = v4;
              return v32;
            }
          }
        }
      }
      if ( *((_BYTE *)v4 + 26) )
      {
        LockLength = (ULARGE_INTEGER)-1i64;
        LockOffset = 0i64;
        NtUnlockFile(*((HANDLE *)v4 + 5), &IoStatusBlock, &LockOffset, &LockLength, LockFileKey);
      }
      NtClose(*((HANDLE *)v4 + 5));
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    return v32;
  }
  return -1073741801;
}
// 77DE1480: using guessed type int __stdcall RtlIsTextUnicode(_DWORD, _DWORD, _DWORD);
// 77EA67E8: using guessed type int (__stdcall *gpTermsrvCORIniFile)(_DWORD);
// 77EA67EC: using guessed type int (__stdcall *gpTermsrvBuildIniFileName)(_DWORD, _DWORD);

//----- (77E1DA61) --------------------------------------------------------
int __stdcall BaseDllReadWriteIniFileOnDisk(STRING *String1)
{
  PCHAR v1; // eax@4
  int v2; // eax@4
  NTSTATUS v3; // eax@6
  int v4; // eax@11
  NTSTATUS v6; // eax@8
  int v7; // eax@30
  PCHAR v8; // [sp+10h] [bp-24h]@0
  int (__stdcall *v9)(_DWORD); // [sp+14h] [bp-20h]@1
  signed int v10; // [sp+18h] [bp-1Ch]@3

  v9 = *(int (__stdcall **)(_DWORD))(KernelBaseGetGlobalData() + 108);
  if ( !LOBYTE(String1->Buffer) )
    v8 = String1[9].Buffer;
  v10 = BaseDllOpenIniFileOnDisk((int)String1);
  if ( v10 >= 0 )
  {
    v1 = String1[1].Buffer;
    String1[12].Buffer = (PCHAR)(*((_DWORD *)v1 + 8) + *((_DWORD *)v1 + 7));
    String1[11].Buffer = (PCHAR)*((_DWORD *)v1 + 8);
    JUMPOUT(v1[25], 0, &loc_77E18267);
    v2 = *(_DWORD *)&String1->Length;
    if ( *(_DWORD *)&String1->Length == 5 )
    {
      v3 = BaseDllReadSectionNames((int)String1);
    }
    else
    {
      switch ( v2 )
      {
        case 1:
          v3 = BaseDllReadKeywordValue(String1);
          break;
        case 4:
          v3 = BaseDllReadKeywordNames(String1);
          break;
        case 6:
          v3 = BaseDllReadSection(String1);
          break;
        case 2:
        case 3:
          v3 = BaseDllWriteKeywordValue(String1, 0);
          break;
        default:
          if ( v2 != 7 && v2 != 8 )
          {
            v10 = -1073741811;
            goto LABEL_8;
          }
          v3 = BaseDllWriteSection(String1);
          break;
      }
    }
    v10 = v3;
LABEL_8:
    v6 = BaseDllCloseIniFileOnDisk((int)String1);
    if ( v10 >= 0 )
      v10 = v6;
  }
  if ( !(v7FFE02D0 & 0x10) )
    goto LABEL_15;
  if ( v10 >= 0 )
    goto LABEL_11;
  v7 = *(_DWORD *)&String1->Length;
  if ( *(_DWORD *)&String1->Length != 5 && v7 != 1 && v7 != 4 && v7 != 6 )
  {
    if ( v10 < 0 )
      goto LABEL_15;
LABEL_11:
    v4 = *(_DWORD *)&String1->Length;
    if ( (*(_DWORD *)&String1->Length == 2 || v4 == 3 || v4 == 7 || v4 == 8)
      && TermsrvAppInstallMode()
      && gpTermsrvLogInstallIniFile )
      gpTermsrvLogInstallIniFile(&String1[4]);
    goto LABEL_15;
  }
  if ( v9 && v9(String1) )
    BaseDllReadWriteIniFileOnDisk(String1);
LABEL_15:
  if ( v10 == -1073741772 && !LOBYTE(String1->Buffer) && v8 )
    v10 = 0;
  return v10;
}
// 77EA67D4: using guessed type int (__stdcall *gpTermsrvLogInstallIniFile)(_DWORD);

//----- (77E1DB67) --------------------------------------------------------
NTSTATUS __stdcall BaseDllCloseIniFileOnDisk(int a1)
{
  int v1; // esi@1
  NTSTATUS v2; // eax@7
  int v4; // eax@12
  ULONG v5; // edi@12
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-1Ch]@6
  ULARGE_INTEGER LockOffset; // [sp+10h] [bp-14h]@6
  ULARGE_INTEGER LockLength; // [sp+18h] [bp-Ch]@6
  NTSTATUS v9; // [sp+20h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 12);
  v9 = 0;
  if ( v1 )
  {
    if ( *(_DWORD *)(v1 + 32) )
    {
      if ( *(_DWORD *)(v1 + 44) != -1 )
      {
        if ( *(_BYTE *)(v1 + 24) )
        {
          LockOffset = (ULARGE_INTEGER)*(_DWORD *)(v1 + 44);
          v4 = *(_DWORD *)(v1 + 44);
          v5 = *(_DWORD *)(v1 + 48) - v4;
          v9 = NtWriteFile(
                 *(HANDLE *)(v1 + 20),
                 0,
                 0,
                 0,
                 &IoStatusBlock,
                 (PVOID)(v4 + *(_DWORD *)(v1 + 32)),
                 v5,
                 (PLARGE_INTEGER)&LockOffset,
                 &LockFileKey);
          if ( v9 >= 0 )
          {
            if ( IoStatusBlock.Information == v5 )
            {
              LockLength = (ULARGE_INTEGER)*(_DWORD *)(v1 + 28);
              v9 = NtSetInformationFile(*(HANDLE *)(v1 + 20), &IoStatusBlock, &LockLength, 8u, FileEndOfFileInformation);
            }
            else
            {
              v9 = -1073741697;
            }
          }
        }
      }
      NtFreeVirtualMemory((HANDLE)0xFFFFFFFF, (PVOID *)(v1 + 32), (PULONG)(v1 + 40), 0x8000u);
      *(_DWORD *)(v1 + 40) = 0;
      *(_DWORD *)(v1 + 32) = 0;
      *(_DWORD *)(v1 + 36) = 0;
    }
    if ( *(_BYTE *)(v1 + 26) )
    {
      LockLength = (ULARGE_INTEGER)-1i64;
      LockOffset = 0i64;
      NtUnlockFile(*(HANDLE *)(v1 + 20), &IoStatusBlock, &LockOffset, &LockLength, LockFileKey);
    }
    v2 = NtClose(*(HANDLE *)(v1 + 20));
    if ( v9 >= 0 )
      v9 = v2;
    *(_DWORD *)(v1 + 20) = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v1);
  }
  return v9;
}

//----- (77E1DC16) --------------------------------------------------------
signed int __stdcall BaseDllAdvanceTextPointer(int a1, signed int a2)
{
  int v2; // esi@3
  unsigned int v3; // eax@3
  unsigned int v4; // edi@3
  unsigned int v5; // edx@6
  unsigned int v6; // ebx@6
  int i; // ecx@17
  __int16 v8; // cx@20
  unsigned int v9; // ecx@21
  int v10; // edi@22
  __int16 v11; // cx@24
  BYTE *v13; // ebx@34
  int j; // edi@44
  unsigned int v15; // [sp+0h] [bp-8h]@3
  char v16; // [sp+7h] [bp-1h]@2
  unsigned int v17; // [sp+10h] [bp+8h]@6

  if ( a2 == 3 )
  {
    a2 = 2;
    v16 = 1;
  }
  else
  {
    v16 = 0;
  }
  v2 = a1;
  v3 = *(_DWORD *)(a1 + 92);
  v4 = *(_DWORD *)(a1 + 100);
  JUMPOUT(*(_BYTE *)(*(_DWORD *)(a1 + 12) + 25) != 0, &loc_77E1821B);
  v15 = *(_DWORD *)(a1 + 100);
  if ( v3 >= v4 )
    return -2147483622;
  while ( 2 )
  {
    JUMPOUT(v3, v4, &loc_77E16708);
    do
    {
      if ( *(_BYTE *)v3 > 0x20u )
        break;
      ++v3;
    }
    while ( v3 < v4 );
    JUMPOUT(v3, v4, &loc_77E16708);
    v5 = v3;
    v17 = v3;
    v6 = 0;
    *(_DWORD *)(v2 + 96) = v3;
    while ( 1 )
    {
      if ( !v6 && *(_BYTE *)v5 == 61 )
      {
        ++v5;
        v6 = v5;
        goto LABEL_11;
      }
      if ( *(_BYTE *)v5 == 13 )
        goto LABEL_41;
      if ( *(_BYTE *)v5 == 10 )
        break;
      ++v5;
LABEL_11:
      v17 = v5;
      if ( v5 >= v4 )
        goto LABEL_12;
    }
    if ( *(_BYTE *)v5 == 13 )
    {
LABEL_41:
      ++v5;
      v17 = v5;
    }
    if ( *(_BYTE *)v5 == 10 )
    {
      ++v5;
      v17 = v5;
    }
LABEL_12:
    if ( *(_BYTE *)v3 == 59 )
    {
LABEL_25:
      v4 = v15;
      v3 = v5;
      if ( v5 >= v15 )
        return -2147483622;
      continue;
    }
    break;
  }
  if ( *(_BYTE *)v3 != 91 )
  {
    if ( !v16 && !v6 )
      goto LABEL_25;
    if ( v6 )
    {
      for ( i = v6 - 1; i > v3 && *(_BYTE *)(i - 1) <= 0x20u; --i )
        ;
      v8 = i - v3;
      *(_DWORD *)(v2 + 116) = v3;
      *(_WORD *)(v2 + 112) = v8;
      *(_DWORD *)(v2 + 132) = v2 + 112;
      *(_WORD *)(v2 + 114) = v8;
      v3 = v6;
    }
    else
    {
      *(_DWORD *)(v2 + 132) = 0;
    }
    *(_DWORD *)(v2 + 168) = 0;
    v9 = v5;
    if ( v5 > v3 )
    {
      do
      {
        v10 = v9 - 1;
        if ( *(_BYTE *)(v9 - 1) > 0x20u )
          break;
        --v9;
      }
      while ( v10 > v3 );
    }
    *(_DWORD *)(v2 + 172) = 0;
    v11 = v9 - v3;
    *(_DWORD *)(v2 + 124) = v3;
    *(_WORD *)(v2 + 120) = v11;
    *(_WORD *)(v2 + 122) = v11;
    *(_DWORD *)(v2 + 136) = v2 + 120;
    if ( a2 != 2 )
      goto LABEL_25;
LABEL_38:
    *(_DWORD *)(v2 + 92) = v5;
    JUMPOUT(loc_77E1DEA7);
  }
  for ( j = v3 + 1; j < v5 && *(_BYTE *)j <= 0x20u; ++j )
    ;
  v13 = (BYTE *)j;
  if ( j < v5 )
  {
    do
    {
      if ( *v13 == 93 )
        break;
      if ( IsDBCSLeadByte(*v13) )
        ++v13;
      v5 = v17;
      ++v13;
    }
    while ( (unsigned int)v13 < v17 );
    while ( (unsigned int)v13 > j && *(v13 - 1) <= 0x20u )
      --v13;
  }
  *(_DWORD *)(v2 + 164) = 0;
  *(_DWORD *)(v2 + 108) = j;
  *(_WORD *)(v2 + 104) = (_WORD)v13 - j;
  *(_WORD *)(v2 + 106) = (_WORD)v13 - j;
  *(_DWORD *)(v2 + 128) = v2 + 104;
  if ( a2 == 1 )
    goto LABEL_38;
  if ( a2 != 2 )
    goto LABEL_25;
  return -2147483622;
}

//----- (77E1DD45) --------------------------------------------------------
int __stdcall BaseDllFindSection(STRING *String1)
{
  int v1; // edi@1
  signed int i; // eax@1
  const STRING *v3; // eax@3
  signed int v4; // esi@3

  v1 = (int)String1;
  for ( i = BaseDllAdvanceTextPointer((int)String1, 1); i == 261; i = BaseDllAdvanceTextPointer(v1, 1) )
  {
    JUMPOUT(*(_DWORD *)(v1 + 128), 0, &loc_77E183B8);
    JUMPOUT(BaseDllGetApplicationName(v1, (int)&String1, 0), 0, &loc_77E4AF90);
    v3 = *(const STRING **)(v1 + 128);
    JUMPOUT(v3, 0, &loc_77E183CC);
    v4 = RtlEqualString(String1, v3, 1u) != 0 ? 0 : 261;
    if ( v4 != 261 )
      return v4;
  }
  return -1073741772;
}

//----- (77E1DDDA) --------------------------------------------------------
int __stdcall BaseDllReadKeywordValue(STRING *String1)
{
  int i; // eax@9
  unsigned __int16 v2; // dx@10
  __int16 v3; // cx@11
  PCHAR v4; // edx@13
  signed __int16 v5; // cx@17
  PCHAR v6; // eax@17
  int result; // eax@1
  int j; // eax@4
  unsigned __int16 v9; // dx@5
  char v10; // cl@6
  int v11; // ecx@19

  result = BaseDllFindSection(String1);
  if ( result >= 0 )
  {
    result = BaseDllFindKeyword(String1);
    if ( result >= 0 )
    {
      if ( String1[1].Buffer[25] )
      {
        for ( i = *((_DWORD *)String1[21].Buffer + 1); *(_WORD *)i <= 0x20u; *((_WORD *)String1[21].Buffer + 1) -= 2 )
        {
          v4 = String1[21].Buffer;
          if ( !*(_WORD *)v4 )
            break;
          i += 2;
          *((_DWORD *)v4 + 1) = i;
          *(_WORD *)String1[21].Buffer -= 2;
        }
        v2 = *(_WORD *)String1[21].Buffer;
        if ( v2 < 4u )
          return BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   *(_DWORD *)&String1[17].Length,
                   (int)String1[21].Buffer,
                   1);
        v3 = *(_WORD *)i;
        if ( *(_WORD *)i != *(_WORD *)(i + 2 * (((unsigned int)v2 - 2) >> 1)) || v3 != 34 && v3 != 39 )
          return BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   *(_DWORD *)&String1[17].Length,
                   (int)String1[21].Buffer,
                   1);
        *((_DWORD *)String1[21].Buffer + 1) += 2;
        v5 = -4;
        *(_WORD *)String1[21].Buffer -= 4;
        v6 = String1[21].Buffer;
      }
      else
      {
        for ( j = *(_DWORD *)(*(_DWORD *)&String1[17].Length + 4);
              *(_BYTE *)j <= 0x20u;
              --*(_WORD *)(*(_DWORD *)&String1[17].Length + 2) )
        {
          v11 = *(_DWORD *)&String1[17].Length;
          if ( !*(_WORD *)v11 )
            break;
          ++j;
          *(_DWORD *)(v11 + 4) = j;
          --**(_WORD **)&String1[17].Length;
        }
        v9 = **(_WORD **)&String1[17].Length;
        if ( v9 < 2u )
          return BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   *(_DWORD *)&String1[17].Length,
                   (int)String1[21].Buffer,
                   1);
        v10 = *(_BYTE *)j;
        if ( *(_BYTE *)j != *(_BYTE *)(v9 + j - 1) || v10 != 34 && v10 != 39 )
          return BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   *(_DWORD *)&String1[17].Length,
                   (int)String1[21].Buffer,
                   1);
        ++*(_DWORD *)(*(_DWORD *)&String1[17].Length + 4);
        v5 = -2;
        **(_WORD **)&String1[17].Length -= 2;
        v6 = *(PCHAR *)&String1[17].Length;
      }
      *((_WORD *)v6 + 1) += v5;
      return BaseDllAppendStringToResultBuffer((int)String1, *(_DWORD *)&String1[17].Length, (int)String1[21].Buffer, 1);
    }
  }
  return result;
}

//----- (77E1DFA3) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
{
  const char *v6; // ebx@1
  int v7; // edi@1
  DWORD v8; // esi@2
  signed int v9; // eax@2
  const char *v11; // eax@12
  int v12; // edx@12
  char v13; // cl@13
  DWORD v14; // ebx@33
  BYTE *v15; // esi@33
  CHAR *v16; // edi@34
  LPCSTR lpDefaulta; // [sp+1Ch] [bp+10h]@2

  v6 = lpDefault;
  v7 = 0;
  if ( !lpDefault )
    v6 = &byte_77E1E0E2;
  v8 = nSize;
  v9 = BaseDllReadWriteIniFile(
         0,
         0,
         0,
         (int)lpFileName,
         (int)lpAppName,
         (int)lpKeyName,
         (int)lpReturnedString,
         (int)&nSize);
  lpDefaulta = (LPCSTR)v9;
  if ( v9 >= 0 )
  {
    RtlSetLastWin32Error(0);
    v7 = nSize - 1;
    goto LABEL_4;
  }
  if ( v9 != -2147483643 )
  {
    v11 = v6;
    v12 = (int)(v6 + 1);
    do
      v13 = *v11++;
    while ( v13 );
    v7 = (int)&v11[-v12];
    if ( v11 != (const char *)v12 )
    {
      do
      {
        if ( v6[v7 - 1] != 32 )
          break;
        --v7;
      }
      while ( v7 );
    }
    if ( !v8 )
    {
      BaseSetLastNTError((NTSTATUS)lpDefaulta);
      return 0;
    }
    if ( v7 >= v8 )
      v7 = v8 - 1;
    strncpy_s(lpReturnedString, v8, v6, v7);
    goto LABEL_4;
  }
  if ( lpAppName && lpKeyName )
  {
    if ( v8 >= 1 )
      v7 = v8 - 1;
    goto LABEL_4;
  }
  if ( v8 < 2 )
  {
LABEL_4:
    if ( v7 >= v8 )
    {
      if ( v8 )
        lpReturnedString[v8 - 1] = 0;
    }
    else
    {
      lpReturnedString[v7] = 0;
    }
    if ( (signed int)lpDefaulta < 0 )
      BaseSetLastNTError((NTSTATUS)lpDefaulta);
    else
      RtlSetLastWin32Error(0);
    return v7;
  }
  v14 = v8 - 2;
  v15 = (BYTE *)lpReturnedString;
  lpReturnedString[v14 + 1] = 0;
  lpReturnedString[v14] = 0;
  if ( v14 )
  {
    v16 = &lpReturnedString[v14 - 1];
    while ( (unsigned int)v15 <= (unsigned int)v16 )
      v15 += (IsDBCSLeadByte(*v15) != 0) + 1;
    if ( v15 - (BYTE *)v16 == 2 )
      *v16 = 0;
  }
  BaseSetLastNTError(-2147483643);
  return v14;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E1E0E2: using guessed type char byte_77E1E0E2;

//----- (77E1E0AE) --------------------------------------------------------
ATOM __stdcall FindAtomA(LPCSTR lpString)
{
  return InternalFindAtom(1, 0, lpString);
}

//----- (77E1E0F2) --------------------------------------------------------
UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
{
  NTSTATUS v5; // eax@4
  ULONG Value; // [sp+0h] [bp-108h]@1
  CHAR ReturnedString; // [sp+4h] [bp-104h]@1

  Value = 0;
  if ( GetPrivateProfileStringA(lpAppName, lpKeyName, 0, &ReturnedString, 0x100u, lpFileName) )
  {
    v5 = RtlCharToInteger(&ReturnedString, 0, &Value);
    if ( v5 < 0 )
      BaseSetLastNTError(v5);
    else
      RtlSetLastWin32Error(0);
  }
  else
  {
    Value = nDefault;
  }
  return Value;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1E157) --------------------------------------------------------
UINT __stdcall GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
{
  return GetPrivateProfileIntA(lpAppName, lpKeyName, nDefault, 0);
}

//----- (77E1E1D9) --------------------------------------------------------
UINT __stdcall GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
{
  return InternalGetAtomName(1, 1, nAtom, lpBuffer, nSize);
}

//----- (77E1E1F9) --------------------------------------------------------
int __stdcall RegLoadMUIStringW(HKEY hKey, LPCWSTR lpValueName, void *Dst, size_t a4, int a5, int a6, int Directory)
{
  void *v7; // esi@7
  int v8; // eax@8
  ULONG v9; // eax@11
  ULONG v10; // ecx@11
  int i; // eax@14
  unsigned __int16 v12; // dx@16
  unsigned int v14; // esi@32
  WCHAR *v15; // eax@32
  const void *v16; // edi@49
  int v18; // [sp+Ch] [bp-14h]@4
  DWORD Type; // [sp+10h] [bp-10h]@8
  ULONG Size; // [sp+14h] [bp-Ch]@1
  ULONG pcchBufferOut; // [sp+18h] [bp-8h]@1
  PCWSTR SourceString; // [sp+1Ch] [bp-4h]@7
  int v23; // [sp+3Ch] [bp+1Ch]@8

  Size = 512;
  pcchBufferOut = 0;
  if ( a4 && !Dst )
    return 87;
  if ( a4 & 1 )
    return 87;
  v18 = a6 & 1;
  if ( v18 != a6 )
    return 87;
  if ( !(a6 & 1) )
    goto LABEL_58;
  if ( a5 )
    return 87;
  if ( !(a6 & 1) )
  {
LABEL_58:
    if ( a5 )
      goto LABEL_7;
    return 87;
  }
LABEL_7:
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x200u);
  SourceString = (PCWSTR)v7;
  if ( !v7 )
    return 8;
  while ( 1 )
  {
    v8 = RegGetValueW(hKey, 0, lpValueName, 268500991, &Type, v7, (size_t)&Size);
    v23 = v8;
    if ( v8 != 234 )
      break;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
    SourceString = (PCWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
    if ( !SourceString )
      return 8;
    v7 = (void *)SourceString;
  }
  if ( v8 )
    goto LABEL_27;
  if ( Type == 1 || Type == 2 )
  {
    v9 = 0;
    v10 = Size >> 1;
    if ( Size >> 1 )
    {
      do
      {
        if ( *((_WORD *)v7 + v9) == 44 )
          break;
        ++v9;
      }
      while ( v9 < v10 );
    }
    for ( i = v9 + 2; ; ++i )
    {
      if ( i < v10 )
      {
        v12 = *((_WORD *)v7 + i);
        if ( v12 >= 0x30u && v12 <= 0x39u )
          continue;
      }
      break;
    }
    if ( i < v10 )
      *((_WORD *)v7 + i) = 0;
    if ( !LoadStringByReference(5u, 0, (PCWSTR)v7, (PWSTR)Dst, a4 >> 1, (PCWSTR)Directory, &pcchBufferOut) )
    {
      if ( GetLastError() == 122 && v18 )
      {
        v14 = 2 * pcchBufferOut;
        v15 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * pcchBufferOut);
        v16 = v15;
        if ( !v15 )
        {
          v7 = (void *)SourceString;
          v23 = 8;
          goto LABEL_27;
        }
        if ( LoadStringByReference(5u, 0, SourceString, v15, v14 >> 1, (PCWSTR)Directory, &pcchBufferOut) )
        {
          memcpy(Dst, v16, a4);
          *((_WORD *)Dst + (a4 >> 1) - 1) = 0;
        }
        else
        {
          v23 = GetLastError();
        }
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v16);
        v7 = (void *)SourceString;
      }
      else
      {
        v23 = GetLastError();
      }
    }
    if ( a5 && (!v23 || v23 == 122) )
      *(_DWORD *)a5 = 2 * pcchBufferOut;
    if ( !Dst && !v23 || v23 == 122 )
      v23 = 234;
    goto LABEL_27;
  }
  v23 = 13;
LABEL_27:
  if ( v7 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  return v23;
}

//----- (77E1E361) --------------------------------------------------------
BOOL __stdcall GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
{
  NTSTATUS v1; // eax@1
  unsigned int v2; // ecx@6
  DWORD v3; // eax@7
  BOOL result; // eax@8
  BYTE v5; // al@17
  char OutputBuffer; // [sp+8h] [bp-24h]@1
  char v7; // [sp+9h] [bp-23h]@2
  char v8; // [sp+Ah] [bp-22h]@3
  unsigned int v9; // [sp+10h] [bp-1Ch]@6
  unsigned int v10; // [sp+14h] [bp-18h]@14
  DWORD v11; // [sp+1Ch] [bp-10h]@7

  v1 = NtPowerInformation(SystemBatteryState, 0, 0, &OutputBuffer, 0x20u);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    *(_DWORD *)&lpSystemPowerStatus->ACLineStatus = 0;
    lpSystemPowerStatus->BatteryLifeTime = 0;
    lpSystemPowerStatus->BatteryFullLifeTime = 0;
    lpSystemPowerStatus->ACLineStatus = 1;
    if ( v7 && !OutputBuffer )
      lpSystemPowerStatus->ACLineStatus = 0;
    if ( v8 )
      lpSystemPowerStatus->BatteryFlag |= 8u;
    if ( !v7 )
      lpSystemPowerStatus->BatteryFlag |= 0x80u;
    v2 = v9;
    lpSystemPowerStatus->BatteryLifePercent = -1;
    if ( v2 )
    {
      if ( v10 <= v2 )
        lpSystemPowerStatus->BatteryLifePercent = ((v2 >> 1) + 100 * v10) / v2;
      else
        lpSystemPowerStatus->BatteryLifePercent = 100;
      v5 = lpSystemPowerStatus->BatteryLifePercent;
      if ( v5 > 0x42u )
        lpSystemPowerStatus->BatteryFlag |= 1u;
      if ( v5 < 0x21u )
        lpSystemPowerStatus->BatteryFlag |= 2u;
    }
    v3 = v11;
    lpSystemPowerStatus->BatteryLifeTime = -1;
    lpSystemPowerStatus->BatteryFullLifeTime = -1;
    if ( v3 )
      lpSystemPowerStatus->BatteryLifeTime = v3;
    result = 1;
  }
  return result;
}

//----- (77E1E3FE) --------------------------------------------------------
HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
{
  return CreateSemaphoreExW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, 0, 0x1F0003u);
}

//----- (77E1E586) --------------------------------------------------------
LSTATUS __stdcall RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
{
  int v8; // eax@4
  LPDWORD v9; // esi@5
  USHORT v10; // ax@14
  NTSTATUS v11; // ebx@16
  int v12; // esi@19
  int v13; // edi@19
  int v14; // eax@19
  ULONG v16; // eax@32
  USHORT *v17; // ebx@34
  NTSTATUS v18; // eax@34
  int v19; // [sp+1Ch] [bp-258h]@1
  int (__stdcall *v20)(unsigned int, DWORD, UNICODE_STRING *, UNICODE_STRING *, PFILETIME); // [sp+20h] [bp-254h]@1
  int v21; // [sp+24h] [bp-250h]@1
  int v22; // [sp+28h] [bp-24Ch]@1
  USHORT *v23; // [sp+2Ch] [bp-248h]@1
  STRING DestinationString; // [sp+30h] [bp-244h]@16
  LPDWORD v25; // [sp+38h] [bp-23Ch]@1
  UNICODE_STRING SourceString; // [sp+3Ch] [bp-238h]@5
  UNICODE_STRING v27; // [sp+44h] [bp-230h]@6
  LSTATUS v28; // [sp+4Ch] [bp-228h]@4
  char v29; // [sp+50h] [bp-224h]@29
  CPPEH_RECORD ms_exc; // [sp+25Ch] [bp-18h]@30

  v22 = (int)hKey;
  v25 = lpcchName;
  v23 = (USHORT *)lpcchClass;
  v19 = 0;
  v21 = 0;
  v20 = *(int (__stdcall **)(unsigned int, DWORD, UNICODE_STRING *, UNICODE_STRING *, PFILETIME))(RegKrnGetGlobalState()
                                                                                                + 68);
  if ( !lpReserved && (!lpClass || v23) && v25 )
  {
    v8 = RegKrnGetGlobalState();
    v28 = (*(int (__stdcall **)(int, int *, int *, int *))(v8 + 176))(v22, &v22, &v19, &v21);
    if ( !v28 )
    {
      SourceString.Length = 0;
      v9 = v25;
      SourceString.MaximumLength = 2 * (*(_WORD *)v25 + 1);
      SourceString.Buffer = (PWCH)RtlAllocateHeap(
                                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                    0,
                                    SourceString.MaximumLength);
      if ( SourceString.Buffer )
      {
        v27.Length = 0;
        if ( lpClass )
        {
          v27.MaximumLength = 260;
          v27.Buffer = (PWCH)&v29;
        }
        else
        {
          v27.MaximumLength = 0;
          v27.Buffer = 0;
        }
        if ( v22 & 1 )
        {
          if ( v20 )
          {
            ms_exc.registration.TryLevel = 0;
            v28 = v20(v22 & 0xFFFFFFFE, dwIndex, &SourceString, &v27, lpftLastWriteTime);
            ms_exc.registration.TryLevel = -2;
          }
        }
        else
        {
          v28 = LocalBaseRegEnumKey(v22, dwIndex, (int)&SourceString, (int)&v27, (int)lpftLastWriteTime);
        }
        if ( v28 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, SourceString.Buffer);
        }
        else
        {
          if ( SourceString.Length >= 2u )
            SourceString.Length -= 2;
          if ( v27.Length >= 2u )
            v27.Length -= 2;
          v10 = -1;
          if ( *v9 <= 0xFFFF )
            v10 = *(_WORD *)v9;
          DestinationString.MaximumLength = v10;
          DestinationString.Buffer = lpName;
          v11 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0);
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, SourceString.Buffer);
          if ( v11 < 0 )
          {
            v16 = RtlNtStatusToDosError(v11);
          }
          else
          {
            *v25 = DestinationString.Length;
            if ( !lpClass )
            {
              if ( v23 )
                *(_DWORD *)v23 = (unsigned int)v27.Length >> 1;
              goto LABEL_19;
            }
            v17 = v23;
            DestinationString.MaximumLength = *v23;
            DestinationString.Buffer = lpClass;
            v18 = RtlUnicodeStringToAnsiString(&DestinationString, &v27, 0);
            if ( v18 >= 0 )
            {
              *(_DWORD *)v17 = DestinationString.Length;
              goto LABEL_19;
            }
            v16 = RtlNtStatusToDosError(v18);
          }
          v28 = v16;
        }
      }
      else
      {
        v28 = 8;
      }
    }
LABEL_19:
    v12 = v21;
    v13 = v19;
    v14 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v14 + 168))(v13, v12);
    return v28;
  }
  return 87;
}

//----- (77E1E8C1) --------------------------------------------------------
int __stdcall SbpGetShimData(int a1, int a2, void *Dst, int a4)
{
  int v4; // ebx@1

  v4 = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 524) == -1408373333 && *(_DWORD *)(a1 + 520) == 1500 )
    {
      v4 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))a4)(0, 0, *(_WORD *)(a1 + 1496));
      if ( v4 )
      {
        memset(Dst, 0, 0x1C8u);
        if ( !(*(int (__stdcall **)(int, int, int, void *))(a4 + 8))(v4, a2, a1, Dst) )
        {
          (*(void (__stdcall **)(int))(a4 + 4))(v4);
          v4 = 0;
        }
      }
    }
  }
  return v4;
}

//----- (77E1EA16) --------------------------------------------------------
int __stdcall SbpMergeApphackContexts(int a1, int a2, int a3, int a4, ULONG a5)
{
  bool v5; // zf@4
  PVOID v7; // esi@10
  PVOID v8; // eax@14
  int v9; // ebx@14
  unsigned __int32 v10; // edi@15
  int v11; // esi@23
  signed int v12; // [sp+8h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-18h]@1
  unsigned __int32 v14; // [sp+10h] [bp-14h]@1
  void *Src; // [sp+14h] [bp-10h]@1
  PVOID Address; // [sp+18h] [bp-Ch]@1
  unsigned __int32 v17; // [sp+1Ch] [bp-8h]@1
  ULONG Size; // [sp+20h] [bp-4h]@1

  v12 = 0;
  Address = 0;
  v13 = 0;
  Src = 0;
  v17 = 0;
  v14 = 0;
  Size = 0;
  if ( SbpQueryContexts(a1, a2, 36872, (int)&Address, (int)&v13, a5)
    && SbpQueryContexts(a1, a2, 36873, (int)&Src, (int)&v17, a5) )
  {
    if ( v13 )
    {
      v5 = v17 == 0;
    }
    else
    {
      v5 = v17 == 0;
      if ( !v17 )
      {
        v12 = 1;
        *(_DWORD *)a4 = a3;
        goto LABEL_6;
      }
    }
    v7 = (PVOID)a3;
    if ( v5 )
    {
      v9 = a3;
      goto LABEL_19;
    }
    if ( ULongAdd(v17, *(_DWORD *)(a3 + 32), &v14) >= 0
      && ULongLongToULong(16i64 * (v14 - 1), &Size) >= 0
      && ULongAdd(Size, 0x34u, &Size) >= 0 )
    {
      v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, Size);
      v9 = (int)v8;
      if ( v8 )
      {
        v10 = v17;
        *((_DWORD *)v8 + 8) = v14;
        if ( ULongLongToULong(16i64 * v10, &Size) >= 0 )
        {
          memcpy((void *)(v9 + 36), Src, Size);
          if ( ULongLongToULong(16i64 * *(_DWORD *)(a3 + 32), &Size) >= 0 )
          {
            memcpy((void *)(16 * v10 + v9 + 36), (const void *)(a3 + 36), Size);
LABEL_19:
            if ( v13 && SbpIsValidPlatformGuid(Address) )
            {
              v7 = Address;
            }
            else if ( v9 == a3 )
            {
LABEL_24:
              *(_DWORD *)a4 = v9;
              v12 = 1;
              goto LABEL_6;
            }
            *(_DWORD *)v9 = *(_DWORD *)v7;
            v11 = (int)((char *)v7 + 4);
            *(_DWORD *)(v9 + 4) = *(_DWORD *)v11;
            v11 += 4;
            *(_DWORD *)(v9 + 8) = *(_DWORD *)v11;
            *(_DWORD *)(v9 + 12) = *(_DWORD *)(v11 + 4);
            goto LABEL_24;
          }
        }
      }
    }
  }
LABEL_6:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( Src )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
  return v12;
}

//----- (77E1EABE) --------------------------------------------------------
int __stdcall SbpQueryContexts(int a1, int a2, int a3, int a4, int a5, ULONG Size)
{
  ULONG v6; // esi@1
  PVOID v7; // edi@1
  unsigned int v8; // ecx@4
  signed int v10; // [sp+Ch] [bp-8h]@1
  unsigned int v11; // [sp+10h] [bp-4h]@1

  v6 = Size;
  v10 = 0;
  v7 = 0;
  v11 = 0;
  if ( (*(int (__stdcall **)(int, int, int, _DWORD, int *))(Size + 12))(a1, a2, a3, 0, &v11)
    && (!v11
     || ULongLongToULong(16i64 * v11, &Size) >= 0
     && (v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, Size)) != 0
     && (*(int (__stdcall **)(int, int, int, PVOID, int *))(v6 + 12))(a1, a2, a3, v7, &v11)) )
  {
    v10 = 1;
  }
  else
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
    v7 = 0;
    v11 = 0;
  }
  v8 = v11;
  *(_DWORD *)a4 = v7;
  *(_DWORD *)a5 = v8;
  return v10;
}

//----- (77E1EBE7) --------------------------------------------------------
int __stdcall KeyStateListInit(int a1)
{
  int v1; // eax@1

  v1 = GetCurrentThreadId();
  StateObjectListInit(a1, v1);
  return EnumStateInit((void *)(a1 + 32), 0, 0, 1, 0);
}

//----- (77E1ED34) --------------------------------------------------------
BOOL __stdcall SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
{
  NTSTATUS v3; // eax@2
  BOOL result; // eax@4
  DWORD v5; // eax@8
  UINT v6; // [sp+4h] [bp-4h]@1

  v6 = 0;
  if ( !(dwFlags & 0x300) || pulNumLanguages )
  {
    v3 = RtlSetThreadPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
  }
  else
  {
    v6 = GetConsoleOutputCP();
    v3 = RtlSetThreadPreferredUILanguages(dwFlags | 0x8000, pwszLanguagesBuffer, &v6);
  }
  if ( v3 < 0 )
  {
    v5 = RtlNtStatusToDosError(v3);
    SetLastError(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1170: using guessed type int __stdcall RtlSetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD);

//----- (77E1ED98) --------------------------------------------------------
int __stdcall BaseCheckRunApp(HANDLE SectionHandle, int a2, int a3, PVOID Environment, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, PVOID Address)
{
  int v13; // esi@1
  int BaseAddress; // [sp+4h] [bp-4h]@1

  v13 = a6;
  BaseAddress = 1;
  if ( sub_77E1EE20(
         SectionHandle,
         a2,
         a3,
         Environment,
         a5,
         (int)&a6,
         a7,
         a8,
         a9,
         a10,
         a11,
         a12,
         (int)Address,
         (int)&Address,
         &BaseAddress) >= 0 )
  {
    if ( (!(v13 & 0x100) || a6 & 0x80000) && a6 & 0x60000 )
      sub_77E1F10B((NTSTRSAFE_PCWSTR)a3, a2, (NTSTRSAFE_PCWSTR)Address, a5, v13);
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return BaseAddress;
}

//----- (77E1EE20) --------------------------------------------------------
NTSTATUS __stdcall sub_77E1EE20(HANDLE SectionHandle, int a2, int a3, PVOID Environment, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, PVOID BaseAddress)
{
  PVOID v15; // ebx@1
  int v16; // edi@1
  int v17; // ecx@8
  int v18; // eax@9
  int v19; // eax@11
  NTSTATUS result; // eax@13
  int v21; // eax@18
  int v22; // eax@20
  int (__stdcall *v23)(int, PVOID, ULONG, int, int, int, int, int *, int *, int *, int *, int, int, int); // [sp+Ch] [bp-1Ch]@13
  int v24; // [sp+10h] [bp-18h]@1
  int v25; // [sp+14h] [bp-14h]@1
  __int16 v26; // [sp+18h] [bp-10h]@1
  __int16 v27; // [sp+1Ah] [bp-Eh]@1
  int v28; // [sp+1Ch] [bp-Ch]@1
  int v29; // [sp+20h] [bp-8h]@1
  ULONG ViewSize; // [sp+24h] [bp-4h]@1

  v15 = BaseAddress;
  v16 = a12;
  BaseAddress = 0;
  v28 = 0;
  v24 = 0;
  a12 = 0;
  v29 = 0;
  v25 = 0;
  ViewSize = 0;
  v26 = 0;
  v27 = 0;
  if ( a6 && a7 && a8 && a9 && a10 && a11 && v16 && (v17 = a13) != 0 && (v18 = a14) != 0 && v15 )
  {
    *(_DWORD *)a9 = 0;
    *(_DWORD *)a10 = 0;
    *(_DWORD *)a11 = 0;
    *(_DWORD *)v16 = 0;
    *(_DWORD *)(v16 + 4) = 0;
    *(_DWORD *)v17 = 0;
    *(_DWORD *)v18 = 0;
    v19 = a6;
    *(_DWORD *)v15 = 1;
    if ( *(_DWORD *)v19 & 0x100 )
    {
      v28 = *(_DWORD *)a7;
      v29 = *(_DWORD *)a8;
    }
    *(_DWORD *)a7 = 0;
    *(_DWORD *)a8 = 0;
    if ( !BasepSkipSetupShims() )
    {
      result = BasepGetApphelpCheckRunAppProc((int)&v23);
      if ( result < 0 )
        return result;
      if ( sub_77E32585(Environment, (int)&a12, (int)&Environment) >= 0 )
      {
        *(_DWORD *)a14 = a12;
      }
      else
      {
        a12 = (int)&v26;
        *(_DWORD *)a14 = 0;
      }
      if ( SectionHandle
        && NtMapViewOfSection(SectionHandle, (HANDLE)0xFFFFFFFF, &BaseAddress, 0, 0, 0, &ViewSize, ViewUnmap, 0, 2u) < 0 )
      {
        BaseAddress = 0;
        ViewSize = 0;
      }
      *(_DWORD *)v15 = v23(a2, BaseAddress, ViewSize, a3, a12, a5, a6, &v28, &v29, &v24, &v25, a11, v16, a13);
      v21 = v29;
      if ( v29 )
      {
        *(_DWORD *)a7 = v28;
        *(_DWORD *)a8 = v21;
      }
      v22 = v25;
      if ( v25 )
      {
        *(_DWORD *)a9 = v24;
        *(_DWORD *)a10 = v22;
      }
      if ( BaseAddress )
        NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, BaseAddress);
    }
    result = 0;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (77E1F036) --------------------------------------------------------
NTSTATUS __stdcall BasepGetApphelpCheckRunAppProc(int a1)
{
  NTSTATUS result; // eax@1
  int v2; // eax@2

  result = sub_77E32826();
  if ( result >= 0 )
  {
    v2 = RtlDecodeSystemPointer(dword_77EA6060);
    *(_DWORD *)a1 = v2;
    if ( v2 )
      result = 0;
    else
      result = -1073741823;
  }
  return result;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E1F073) --------------------------------------------------------
NTSTATUS __stdcall RtlUnicodeStringInit(PUNICODE_STRING DestinationString, NTSTRSAFE_PCWSTR pszSrc)
{
  return sub_77E1F095((int)DestinationString, 0x7FFF, (int)pszSrc, 0);
}

//----- (77E1F095) --------------------------------------------------------
signed int __userpurge sub_77E1F095@<eax>(int a1@<edx>, int a2@<ecx>, int a3@<ebx>, __int16 a4)
{
  signed int result; // eax@1
  signed int v5; // edi@4
  int v6; // esi@4
  int v7; // eax@4
  __int16 v8; // cx@8
  __int16 v9; // cx@11

  result = 0;
  if ( a1 || !(a4 & 0x100) )
  {
    *(_WORD *)a1 = 0;
    *(_WORD *)(a1 + 2) = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  if ( a3 )
  {
    v5 = 0;
    v6 = a2;
    v7 = a3;
    if ( !a2 )
      goto LABEL_19;
    do
    {
      if ( !*(_WORD *)v7 )
        break;
      v7 += 2;
      --v6;
    }
    while ( v6 );
    if ( v6 )
    {
      v8 = a2 - v6;
    }
    else
    {
LABEL_19:
      v5 = -1073741811;
      v8 = 0;
    }
    result = v5;
    if ( v5 >= 0 )
    {
      if ( a1 )
      {
        v9 = 2 * v8;
        *(_WORD *)a1 = v9;
        *(_WORD *)(a1 + 2) = v9 + 2;
        *(_DWORD *)(a1 + 4) = a3;
      }
      else
      {
        result = -1073741811;
      }
    }
  }
  return result;
}

//----- (77E1F10B) --------------------------------------------------------
NTSTATUS __stdcall sub_77E1F10B(NTSTRSAFE_PCWSTR pszSrc, int a2, NTSTRSAFE_PCWSTR a3, __int16 a4, int a5)
{
  NTSTATUS result; // eax@1
  int v6; // [sp+0h] [bp-C8h]@1
  char Dst; // [sp+4h] [bp-C4h]@1
  __int16 v8; // [sp+ACh] [bp-1Ch]@1
  int v9; // [sp+B0h] [bp-18h]@1
  UNICODE_STRING DestinationString; // [sp+B4h] [bp-14h]@1
  int v11; // [sp+BCh] [bp-Ch]@2
  UNICODE_STRING v12; // [sp+C0h] [bp-8h]@2

  v6 = 0;
  memset(&Dst, 0, 0xC4u);
  v8 = a4;
  v9 = a5;
  result = RtlUnicodeStringInit(&DestinationString, pszSrc);
  if ( result >= 0 )
  {
    v11 = a2;
    result = RtlUnicodeStringInitEx(&v12, a3, 0x100u);
    if ( result >= 0 )
      result = NtApphelpCacheControl(7, &v6);
  }
  return result;
}
// 77DE114C: using guessed type int __stdcall NtApphelpCacheControl(_DWORD, _DWORD);

//----- (77E1F184) --------------------------------------------------------
NTSTATUS __stdcall RtlUnicodeStringInitEx(PUNICODE_STRING DestinationString, NTSTRSAFE_PCWSTR pszSrc, ULONG dwFlags)
{
  PUNICODE_STRING v3; // edx@1
  NTSTATUS result; // eax@2

  v3 = DestinationString;
  if ( dwFlags & 0xFFFFE000 )
  {
    result = -1073741811;
  }
  else
  {
    result = sub_77E1F095((int)DestinationString, 0x7FFF, (int)pszSrc, dwFlags);
    if ( result >= 0 )
      return result;
  }
  if ( v3 )
  {
    v3->Buffer = 0;
    v3->Length = 0;
    v3->MaximumLength = 0;
  }
  return result;
}

//----- (77E1F1BC) --------------------------------------------------------
BOOLEAN __stdcall KeyStateListDestroy(PVOID Address)
{
  StateObjectListClear((int)Address, (void (__stdcall *)(_DWORD))EnumStateDestroy);
  EnumStateClear((char *)Address + 32);
  return RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}

//----- (77E1F1F8) --------------------------------------------------------
void __stdcall OutputDebugStringAStub(LPCSTR lpOutputString)
{
  OutputDebugStringA(lpOutputString);
}

//----- (77E1F222) --------------------------------------------------------
void __stdcall RaiseExceptionStub(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
{
  RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
}

//----- (77E1F23A) --------------------------------------------------------
SIZE_T __stdcall GlobalSize(HGLOBAL hMem)
{
  PVOID *v1; // ebx@1
  SIZE_T result; // eax@6
  ULONG v3; // eax@10
  int v4; // [sp+14h] [bp-24h]@2
  PVOID *v5; // [sp+18h] [bp-20h]@2
  SIZE_T v6; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  v6 = -1;
  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v1 = (PVOID *)hMem;
  if ( (unsigned __int8)hMem & 4 )
    goto LABEL_19;
  v5 = 0;
  v4 = 2048;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 2048, hMem, &v5, &v4) )
  {
    if ( v5 && v4 & 0x200 )
      v1 = v5;
    else
      v6 = RtlSizeHeap(BaseHeap, 1u, hMem);
  }
  if ( (unsigned __int8)v1 & 4 )
  {
LABEL_19:
    if ( (unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, v1 - 1) )
    {
      if ( *((_BYTE *)v1 - 4) & 8 )
        v3 = (ULONG)*v1;
      else
        v3 = RtlSizeHeap(BaseHeap, 1u, *v1);
      v6 = v3;
    }
    else
    {
      RtlSetLastWin32Error(6);
    }
  }
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  result = v6;
  if ( v6 == -1 )
  {
    RtlSetLastWin32Error(6);
    result = 0;
  }
  return result;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E1F350) --------------------------------------------------------
HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
{
  int v3; // eax@20
  char v4; // bl@1
  char *v5; // esi@7
  HGLOBAL v6; // ebx@9
  void *v7; // edi@9
  int v8; // eax@13
  PVOID v9; // edi@13
  __int16 v10; // ax@15
  int v12; // eax@25
  PVOID v13; // eax@25
  __int16 v14; // ax@27
  int v15; // esi@44
  ULONG v16; // ebx@45
  int v17; // eax@45
  PVOID v18; // eax@45
  HGLOBAL v19; // [sp+14h] [bp-24h]@41
  UINT v20; // [sp+18h] [bp-20h]@2
  ULONG Flags; // [sp+1Ch] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@6
  UINT uFlagsa; // [sp+48h] [bp+10h]@5

  v4 = uFlags;
  if ( !(uFlags & 0xFFFF800D) )
  {
    v20 = uFlags & 0x100;
    if ( !(uFlags & 0x100) || (uFlags & 0x80u) != 0 )
    {
      Flags = 0;
      if ( uFlags & 0x40 )
        Flags = 8;
      uFlagsa = uFlags & 2;
      if ( !(v4 & 2) )
        Flags |= 0x10u;
      RtlLockHeap(BaseHeap);
      Flags |= 1u;
      ms_exc.registration.TryLevel = 1;
      if ( (unsigned __int8)hMem & 4 )
      {
        v5 = (char *)hMem - 4;
        if ( !(unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, (char *)hMem - 4) )
        {
          RtlSetLastWin32Error(6);
          hMem = 0;
          goto LABEL_17;
        }
        if ( v4 < 0 )
        {
          v14 = *(_WORD *)v5;
          if ( v20 )
            v10 = v14 | 4;
          else
            v10 = v14 & 0xFFFB;
          goto LABEL_16;
        }
        v6 = hMem;
        v7 = *(void **)hMem;
        if ( !dwBytes )
        {
          hMem = 0;
          if ( v7 )
          {
            if ( !uFlagsa || *((_WORD *)v5 + 1) || !RtlFreeHeap(BaseHeap, Flags, v7) )
              goto LABEL_17;
            *(_DWORD *)v6 = 0;
            *(_WORD *)v5 |= 8u;
          }
          hMem = v5 + 4;
LABEL_17:
          ms_exc.registration.TryLevel = -2;
          RtlUnlockHeap(BaseHeap);
          return hMem;
        }
        Flags |= 0x300u;
        if ( v7 )
        {
          if ( uFlagsa || !*((_WORD *)v5 + 1) )
            Flags &= 0xFFFFFFEF;
          else
            Flags |= 0x10u;
          v8 = KernelBaseGetGlobalData();
          v9 = RtlReAllocateHeap(BaseHeap, Flags | (*(_DWORD *)(v8 + 44) + 0x100000), v7, dwBytes);
LABEL_14:
          if ( v9 )
          {
            *(_DWORD *)hMem = v9;
            v10 = *(_WORD *)v5 & 0xFFF7;
LABEL_16:
            *(_WORD *)v5 = v10;
            goto LABEL_17;
          }
          goto LABEL_29;
        }
        v12 = KernelBaseGetGlobalData();
        v13 = RtlAllocateHeap(BaseHeap, Flags | (*(_DWORD *)(v12 + 44) + 0x100000), dwBytes);
        v9 = v13;
        if ( v13 )
        {
          RtlSetUserValueHeap(BaseHeap, 1, v13, hMem);
          goto LABEL_14;
        }
      }
      else
      {
        if ( v4 >= 0 )
        {
          v3 = KernelBaseGetGlobalData();
          hMem = RtlReAllocateHeap(BaseHeap, Flags | (*(_DWORD *)(v3 + 44) + 0x100000) | 1, hMem, dwBytes);
          if ( hMem )
            goto LABEL_17;
LABEL_52:
          RtlSetLastWin32Error(8);
          goto LABEL_17;
        }
        if ( !uFlagsa )
          goto LABEL_17;
        v19 = hMem;
        if ( !(unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 1, hMem, &v19, 0) || v19 != hMem && Flags & 0x200 )
          goto LABEL_17;
        v15 = RtlAllocateHandle(BaseHeapHandleTablePtr, 0);
        if ( v15 )
        {
          v16 = RtlSizeHeap(BaseHeap, 1u, hMem);
          Flags |= 0x300u;
          v17 = KernelBaseGetGlobalData();
          v18 = RtlAllocateHeap(BaseHeap, Flags | (*(_DWORD *)(v17 + 44) + 0x100000), v16);
          *(_DWORD *)(v15 + 4) = v18;
          if ( v18 )
          {
            _memmove(v18, hMem, v16);
            RtlFreeHeap(BaseHeap, 1u, hMem);
            hMem = (HGLOBAL)(v15 + 4);
            *(_WORD *)(v15 + 2) = 0;
            *(_WORD *)v15 = 3;
            if ( v20 )
              *(_WORD *)v15 = 7;
            if ( (unsigned __int16)v19 & 0x2000 )
              *(_WORD *)v15 |= 0x8000u;
            RtlSetUserValueHeap(BaseHeap, 1, *(_DWORD *)(v15 + 4), hMem);
            goto LABEL_17;
          }
          *(_WORD *)v15 = 1;
          RtlFreeHandle(BaseHeapHandleTablePtr, v15);
        }
      }
LABEL_29:
      hMem = 0;
      goto LABEL_52;
    }
  }
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE137C: using guessed type int __stdcall RtlSetUserValueHeap(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1384: using guessed type int __stdcall RtlAllocateHandle(_DWORD, _DWORD);
// 77DE1388: using guessed type int __stdcall RtlFreeHandle(_DWORD, _DWORD);
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E1F4E0) --------------------------------------------------------
int __stdcall InternalGetAtomName(NTSTATUS NtStatus, int a2, int Atom, void *Dst, ULONG Size)
{
  ULONG v5; // esi@1
  int v6; // eax@4
  PVOID v7; // eax@4
  unsigned int v8; // eax@6
  const void *v9; // edi@6
  int v10; // ebx@9
  int v12; // eax@28
  NTSTATUS v13; // eax@30
  UNICODE_STRING SourceString; // [sp+8h] [bp-1Ch]@30
  STRING DestinationString; // [sp+10h] [bp-14h]@30
  int v16; // [sp+18h] [bp-Ch]@20
  size_t v17; // [sp+1Ch] [bp-8h]@6
  PVOID Address; // [sp+20h] [bp-4h]@1
  int NtStatusa; // [sp+2Ch] [bp+8h]@5

  v5 = Size;
  Address = 0;
  if ( !(_BYTE)a2 && Size > 0x7000 )
    v5 = 28672;
  if ( v5 )
  {
    if ( !(_BYTE)NtStatus )
    {
      Size = 2 * v5 + 8;
      v6 = KernelBaseGetGlobalData();
      v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), Size);
      Address = v7;
      if ( v7 )
      {
        NtStatusa = NtQueryInformationAtom(Atom, 0, v7, Size, &Size);
        if ( NtStatusa < 0 )
          goto LABEL_22;
        v8 = *((_WORD *)Address + 2);
        v17 = *((_WORD *)Address + 2);
        v9 = (char *)Address + 6;
LABEL_7:
        if ( NtStatusa >= 0 )
        {
          if ( (_BYTE)a2 )
          {
            v10 = v8 >> 1;
            if ( v9 != Dst )
              _memmove(Dst, v9, v8);
            if ( v10 < v5 )
              *((_WORD *)Dst + v10) = 0;
            goto LABEL_13;
          }
          SourceString.Length = v8;
          SourceString.MaximumLength = v8 + 2;
          DestinationString.Buffer = (PCHAR)Dst;
          DestinationString.Length = 0;
          SourceString.Buffer = (PWCH)v9;
          DestinationString.MaximumLength = v5;
          v13 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0);
          v10 = DestinationString.Length;
          NtStatusa = v13;
          if ( v13 >= 0 )
          {
LABEL_13:
            if ( Address )
              RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
            if ( NtStatusa >= 0 )
              return v10;
            BaseSetLastNTError(NtStatusa);
            return 0;
          }
        }
LABEL_22:
        v10 = a2;
        goto LABEL_13;
      }
LABEL_29:
      BaseSetLastNTError(-1073741801);
      return 0;
    }
    if ( (_BYTE)a2 )
    {
      v9 = Dst;
    }
    else
    {
      v12 = KernelBaseGetGlobalData();
      v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v12 + 44), 2 * v5);
      Address = (PVOID)v9;
      if ( !v9 )
        goto LABEL_29;
    }
    v17 = 2 * v5;
    NtStatusa = InternalInitAtomTable((int)&v16);
    if ( NtStatusa < 0 )
      goto LABEL_22;
    NtStatusa = RtlQueryAtomInAtomTable(v16, Atom, 0, 0, v9, &v17);
    v8 = v17;
    goto LABEL_7;
  }
  BaseSetLastNTError(-2147483643);
  return 0;
}
// 77DE14C0: using guessed type int __stdcall RtlQueryAtomInAtomTable(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E1F5D2) --------------------------------------------------------
UINT __stdcall GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
{
  return InternalGetAtomName(0, 1, nAtom, lpBuffer, nSize);
}

//----- (77E1F5F2) --------------------------------------------------------
BOOL __stdcall SetPriorityClassStub(HANDLE hProcess, DWORD dwPriorityClass)
{
  return SetPriorityClass(hProcess, dwPriorityClass);
}

//----- (77E1F60A) --------------------------------------------------------
LSTATUS __stdcall RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
{
  char *v4; // ebx@1
  NTSTATUS v5; // eax@4
  signed int v6; // esi@5
  LSTATUS result; // eax@16
  UNICODE_STRING SourceString; // [sp+8h] [bp-A4h]@7
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-9Ch]@10
  HANDLE TokenHandle; // [sp+28h] [bp-84h]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+2Ch] [bp-80h]@5
  PHANDLE KeyHandle; // [sp+34h] [bp-78h]@1
  ULONG ReturnLength; // [sp+38h] [bp-74h]@4
  LSA_UNICODE_STRING DestinationString; // [sp+3Ch] [bp-70h]@6
  char TokenInformation; // [sp+44h] [bp-68h]@1

  TokenHandle = hToken;
  KeyHandle = (PHANDLE)phkResult;
  v4 = &TokenInformation;
  if ( phkResult && hToken && !dwOptions )
  {
    v5 = NtQueryInformationToken(hToken, TokenUser, &TokenInformation, 0x64u, &ReturnLength);
    if ( v5 >= 0 )
      goto LABEL_5;
    result = RtlNtStatusToDosError(v5);
    if ( result == 122 )
    {
      v4 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ReturnLength);
      if ( v4 )
      {
        v6 = NtQueryInformationToken(TokenHandle, TokenUser, v4, ReturnLength, &ReturnLength);
        if ( v6 < 0 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
          return RtlNtStatusToDosError(v6);
        }
LABEL_5:
        v6 = RtlConvertSidToUnicodeString(&UnicodeString, *(PSID *)v4, 1u);
        if ( v6 >= 0 )
        {
          DestinationString.MaximumLength = UnicodeString.Length + 50;
          DestinationString.Buffer = (PWCH)RtlAllocateHeap(
                                             NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                             0,
                                             (unsigned __int16)(UnicodeString.Length + 50));
          if ( DestinationString.Buffer )
          {
            v6 = RtlInitUnicodeStringEx(&SourceString, L"\\Registry\\User\\");
            if ( v6 >= 0 )
            {
              RtlCopyUnicodeString(&DestinationString, &SourceString);
              v6 = RtlAppendUnicodeStringToString(&DestinationString, &UnicodeString);
              if ( v6 >= 0 )
              {
                v6 = RtlAppendUnicodeToString(&DestinationString, L"_Classes");
                if ( v6 >= 0 )
                {
                  ObjectAttributes.ObjectName = &DestinationString;
                  ObjectAttributes.Length = 24;
                  ObjectAttributes.RootDirectory = 0;
                  ObjectAttributes.Attributes = 64;
                  ObjectAttributes.SecurityDescriptor = 0;
                  ObjectAttributes.SecurityQualityOfService = 0;
                  v6 = NtOpenKey(KeyHandle, samDesired, &ObjectAttributes);
                }
              }
            }
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
          }
          else
          {
            v6 = -1073741801;
          }
          RtlFreeUnicodeString(&UnicodeString);
        }
        if ( v4 != &TokenInformation )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
        if ( v6 >= 0 )
          *KeyHandle = (HANDLE)((unsigned int)*KeyHandle | 2);
        return RtlNtStatusToDosError(v6);
      }
      result = 8;
    }
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E1F7CF) --------------------------------------------------------
signed int __stdcall RemoveCtrlHandler(int a1)
{
  SIZE_T v1; // eax@1
  SIZE_T v2; // edx@1
  signed int result; // eax@6

  v1 = HandlerListLength;
  v2 = 0;
  if ( HandlerListLength )
  {
    while ( *((_DWORD *)HandlerList + v2) != a1 )
    {
      ++v2;
      if ( v2 >= HandlerListLength )
        goto LABEL_9;
    }
    if ( v2 < HandlerListLength - 1 )
    {
      memmove((char *)HandlerList + 4 * v2, (char *)HandlerList + 4 * v2 + 4, 4 * (HandlerListLength - v2) - 4);
      v1 = HandlerListLength;
    }
    HandlerListLength = v1 - 1;
    result = 1;
  }
  else
  {
LABEL_9:
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E1F879) --------------------------------------------------------
BOOL __stdcall FreeResourceStub(HGLOBAL hResData)
{
  return FreeResource(hResData);
}

//----- (77E1F946) --------------------------------------------------------
int __stdcall ByteMatchGetEOFData(DWORD NumberOfBytesRead, LPVOID lpBuffer, int a3)
{
  DWORD v3; // esi@1
  signed int v4; // ebx@1

  v3 = NumberOfBytesRead;
  v4 = -1073741687;
  if ( SetFilePointerEx(*(HANDLE *)(NumberOfBytesRead + 32), (LARGE_INTEGER)-32i64, 0, 2u)
    && ReadFile(*(HANDLE *)(v3 + 32), lpBuffer, 0x20u, &NumberOfBytesRead, 0)
    && NumberOfBytesRead == 32 )
  {
    *(_DWORD *)a3 = 32;
    v4 = 0;
  }
  return v4;
}

//----- (77E1F9B0) --------------------------------------------------------
int __stdcall ByteMatchGetAppendedData(DWORD NumberOfBytesRead, LONG lDistanceToMove, LPVOID lpBuffer, int a4)
{
  DWORD v4; // esi@1
  signed int v6; // [sp+4h] [bp-4h]@1

  v4 = NumberOfBytesRead;
  v6 = -1073741687;
  if ( SetFilePointer(*(HANDLE *)(NumberOfBytesRead + 32), lDistanceToMove, 0, 0) != -1
    && ReadFile(*(HANDLE *)(v4 + 32), lpBuffer, 0x20u, &NumberOfBytesRead, 0)
    && NumberOfBytesRead == 32 )
  {
    v6 = 0;
    *(_DWORD *)a4 = 32;
  }
  return v6;
}

//----- (77E1FBB8) --------------------------------------------------------
UINT __stdcall _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
{
  UINT result; // eax@2

  if ( ReadFileImplementation((HANDLE)hFile, lpBuffer, uBytes, (LPDWORD)&uBytes, 0) )
    result = uBytes;
  else
    result = -1;
  return result;
}

//----- (77E1FBE6) --------------------------------------------------------
LONG __stdcall _llseek(HFILE hFile, LONG lOffset, int iOrigin)
{
  DWORD v3; // eax@2

  if ( !iOrigin )
  {
    v3 = 0;
    return SetFilePointer((HANDLE)hFile, lOffset, 0, v3);
  }
  if ( iOrigin == 1 )
  {
    v3 = 1;
    return SetFilePointer((HANDLE)hFile, lOffset, 0, v3);
  }
  if ( iOrigin == 2 )
  {
    v3 = 2;
    return SetFilePointer((HANDLE)hFile, lOffset, 0, v3);
  }
  return -1;
}

//----- (77E1FC18) --------------------------------------------------------
BOOL __stdcall GetSystemTimeAdjustmentStub(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
{
  return GetSystemTimeAdjustment(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
}

//----- (77E1FC72) --------------------------------------------------------
BOOL __stdcall SetFilePointerExStub(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
{
  return SetFilePointerEx(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
}

//----- (77E1FC94) --------------------------------------------------------
signed int __stdcall BasepSkipSetupShims()
{
  signed int v0; // esi@1
  ULONG ResultLength; // [sp+4h] [bp-1Ch]@5
  HANDLE KeyHandle; // [sp+8h] [bp-18h]@4
  char KeyValueInformation; // [sp+Ch] [bp-14h]@5
  int v5; // [sp+10h] [bp-10h]@6
  int v6; // [sp+14h] [bp-Ch]@7
  int v7; // [sp+18h] [bp-8h]@8

  v0 = 1;
  if ( v7FFE0268 )
  {
    v0 = 0;
  }
  else if ( NtOpenKey(&KeyHandle, 1u, &stru_77EA6BC0) >= 0 )
  {
    if ( NtQueryValueKey(
           KeyHandle,
           &stru_77EA6CD0,
           KeyValuePartialInformation,
           &KeyValueInformation,
           0x10u,
           &ResultLength) >= 0
      && v5 == 4
      && v6 == 4
      && v7 == 1 )
      v0 = 0;
    NtClose(KeyHandle);
  }
  return v0;
}

//----- (77E1FCDD) --------------------------------------------------------
BOOL __stdcall GetProcessTimesStub(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
{
  return GetProcessTimes(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
}

//----- (77E1FD0E) --------------------------------------------------------
BOOL __stdcall GetModuleHandleExAStub(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
{
  return GetModuleHandleExA(dwFlags, lpModuleName, phModule);
}

//----- (77E1FD1B) --------------------------------------------------------
NTSTATUS __stdcall ThpCreateRawSnap(ULONG FreeSize, ULONG ProcessId, PVOID *BaseAddress, int a4, int a5, int a6, int a7, int a8, int a9)
{
  PDEBUG_BUFFER v9; // eax@11
  signed int v10; // eax@1
  PVOID *v11; // esi@1
  int v12; // edi@1
  PDEBUG_BUFFER v14; // eax@22
  int v15; // eax@25
  ULONG AllocationSize; // [sp+14h] [bp-24h]@1
  ULONG ReturnLength; // [sp+18h] [bp-20h]@1
  NTSTATUS v18; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@2

  v18 = 0;
  v10 = 0x10000;
  ReturnLength = 0x10000;
  AllocationSize = 0x10000;
  v11 = BaseAddress;
  *BaseAddress = 0;
  v12 = a4;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)a7 = 0;
  if ( FreeSize & 6 )
  {
    do
    {
      ms_exc.registration.TryLevel = 0;
      AllocationSize = v10;
      v18 = NtAllocateVirtualMemory((HANDLE)0xFFFFFFFF, v11, 0, &AllocationSize, 0x1000u, 4u);
      ms_exc.registration.TryLevel = -2;
      if ( v18 < 0 )
        break;
      ReturnLength = AllocationSize;
      v18 = NtQuerySystemInformation(SystemProcessInformation, *v11, AllocationSize, &ReturnLength);
      if ( v18 == -1073741820 )
      {
        NtFreeVirtualMemory((HANDLE)0xFFFFFFFF, v11, &AllocationSize, 0x8000u);
        *v11 = 0;
        v10 = (ReturnLength + 0x1FFF) & 0xFFFFE000;
        ReturnLength = (ReturnLength + 0x1FFF) & 0xFFFFE000;
      }
      else
      {
        v10 = ReturnLength;
      }
    }
    while ( v18 == -1073741820 );
  }
  if ( FreeSize & 0x18 && v18 >= 0 )
  {
    v9 = RtlCreateQueryDebugBuffer(0, 0);
    *(_DWORD *)v12 = v9;
    if ( !v9 )
      v18 = -1073741823;
    if ( v18 >= 0 )
    {
      *(_DWORD *)a5 = *(_DWORD *)(*(_DWORD *)v12 + 4);
      *(_DWORD *)a6 = *(_DWORD *)(*(_DWORD *)v12 + 44);
      v18 = RtlQueryProcessDebugInformation(
              ProcessId,
              (FreeSize >> 3) & 1 | 4 * (FreeSize & 0x10 | 0xE0000000),
              *(PDEBUG_BUFFER *)v12);
    }
  }
  if ( !(FreeSize & 1) )
  {
LABEL_8:
    if ( v18 >= 0 )
      return v18;
    goto LABEL_14;
  }
  if ( v18 >= 0 )
  {
    v14 = RtlCreateQueryDebugBuffer(0, 0);
    *(_DWORD *)a7 = v14;
    if ( !v14 )
      v18 = -1073741823;
    if ( v18 >= 0 )
    {
      v15 = a7;
      *(_DWORD *)a8 = *(_DWORD *)(*(_DWORD *)a7 + 4);
      *(_DWORD *)a9 = *(_DWORD *)(*(_DWORD *)v15 + 44);
      v18 = RtlQueryProcessDebugInformation(ProcessId, 4u, *(PDEBUG_BUFFER *)v15);
      goto LABEL_8;
    }
  }
LABEL_14:
  if ( *v11 )
  {
    FreeSize = 0;
    NtFreeVirtualMemory((HANDLE)0xFFFFFFFF, v11, &FreeSize, 0x8000u);
    *v11 = 0;
  }
  if ( *(_DWORD *)v12 )
  {
    RtlDestroyQueryDebugBuffer(*(PDEBUG_BUFFER *)v12);
    *(_DWORD *)v12 = 0;
  }
  if ( *(_DWORD *)a7 )
  {
    RtlDestroyQueryDebugBuffer(*(PDEBUG_BUFFER *)a7);
    *(_DWORD *)a7 = 0;
  }
  return v18;
}

//----- (77E1FDF2) --------------------------------------------------------
HANDLE __stdcall CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID)
{
  bool v2; // al@16
  int v3; // eax@20
  int v4; // ecx@20
  char v5; // al@24
  NTSTATUS v6; // eax@3
  int v7; // ebx@5
  int v8; // esi@7
  int v9; // edx@7
  bool v11; // al@46
  int v12; // eax@49
  int v13; // eax@51
  int v14; // ecx@51
  bool v15; // al@55
  int v16; // [sp+10h] [bp-50h]@0
  int v17; // [sp+14h] [bp-4Ch]@0
  int v18; // [sp+18h] [bp-48h]@0
  int v19; // [sp+1Ch] [bp-44h]@3
  int v20; // [sp+20h] [bp-40h]@1
  int v21; // [sp+24h] [bp-3Ch]@3
  int v22; // [sp+28h] [bp-38h]@1
  HANDLE v23; // [sp+2Ch] [bp-34h]@1
  HANDLE Handle; // [sp+30h] [bp-30h]@1
  int v25; // [sp+34h] [bp-2Ch]@5
  PDEBUG_BUFFER DebugBuffer; // [sp+38h] [bp-28h]@1
  PVOID BaseAddress; // [sp+3Ch] [bp-24h]@1
  PDEBUG_BUFFER v28; // [sp+40h] [bp-20h]@1
  PVOID v29; // [sp+44h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+48h] [bp-18h]@3

  Handle = (HANDLE)-1;
  v23 = (HANDLE)-1;
  v29 = 0;
  DebugBuffer = 0;
  v28 = 0;
  BaseAddress = 0;
  v20 = 0;
  v22 = 0;
  if ( !th32ProcessID )
    th32ProcessID = GetCurrentProcessId();
  ms_exc.registration.TryLevel = 0;
  v6 = ThpCreateRawSnap(
         dwFlags,
         th32ProcessID,
         &v29,
         (int)&DebugBuffer,
         (int)&v20,
         (int)&v19,
         (int)&v28,
         (int)&v22,
         (int)&v21);
  if ( v6 < 0 )
    goto LABEL_36;
  if ( v22 )
  {
    v7 = (int)v28->HeapInformation;
    v25 = v7;
    v11 = v22 <= (unsigned int)v7
       && v7 + 68 >= (unsigned int)v7
       && v22 + v21 >= (unsigned int)v22
       && v7 + 68 <= (unsigned int)(v22 + v21);
    if ( !v11 )
      goto LABEL_38;
    v12 = *(_DWORD *)v7;
    v16 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 > 1u )
    {
      if ( v12 << 6 < (unsigned int)v12 )
        goto LABEL_38;
      v13 = (v12 - 1) << 6;
      v14 = v7 + 68;
      v15 = v22 <= (unsigned int)(v7 + 68)
         && v14 + v13 >= (unsigned int)v14
         && v22 + v21 >= (unsigned int)v22
         && v14 + v13 <= (unsigned int)(v22 + v21);
      if ( !v15 )
        goto LABEL_38;
    }
  }
  else
  {
    v7 = v25;
  }
  if ( v20 )
  {
    v8 = (int)DebugBuffer->ModuleInformation;
    v2 = v20 <= (unsigned int)v8
      && v8 + 288 >= (unsigned int)v8
      && v20 + v19 >= (unsigned int)v20
      && v8 + 288 <= (unsigned int)(v20 + v19);
    if ( !v2 )
      goto LABEL_38;
    v9 = *(_DWORD *)v8;
    if ( *(_DWORD *)v8 <= 1u )
      goto LABEL_8;
    if ( 288 * v9 < (unsigned int)v9 )
    {
LABEL_38:
      BaseSetLastNTError(-1073741762);
      goto LABEL_11;
    }
    v3 = 288 * (v9 - 1);
    v4 = v8 + 288;
    if ( v20 <= (unsigned int)(v8 + 288) )
    {
      if ( v3 + v4 >= (unsigned int)v4 && v20 + v19 >= (unsigned int)v20 && v3 + v4 <= (unsigned int)(v20 + v19) )
      {
        v5 = 1;
        v7 = v25;
        goto LABEL_25;
      }
      v7 = v25;
    }
    v5 = 0;
LABEL_25:
    if ( v5 )
      goto LABEL_8;
    goto LABEL_38;
  }
  v8 = v18;
  v9 = v17;
LABEL_8:
  v6 = ThpAllocateSnapshotSection(
         &Handle,
         &BaseAddress,
         (POBJECT_ATTRIBUTES)dwFlags,
         th32ProcessID,
         (ULONG)v29,
         v9,
         v16);
  if ( v6 < 0 || (v6 = ThpProcessToSnap(dwFlags, th32ProcessID, (int)BaseAddress, (int)v29, v8, (int)v28, v7), v6 < 0) )
  {
LABEL_36:
    BaseSetLastNTError(v6);
    goto LABEL_11;
  }
  v23 = Handle;
LABEL_11:
  ms_exc.registration.TryLevel = -2;
  if ( v23 != Handle )
    NtClose(Handle);
  if ( BaseAddress )
    NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, BaseAddress);
  if ( v29 )
  {
    th32ProcessID = 0;
    NtFreeVirtualMemory((HANDLE)0xFFFFFFFF, &v29, &th32ProcessID, 0x8000u);
  }
  if ( DebugBuffer )
    RtlDestroyQueryDebugBuffer(DebugBuffer);
  if ( v28 )
    RtlDestroyQueryDebugBuffer(v28);
  return v23;
}

//----- (77E1FF4C) --------------------------------------------------------
NTSTATUS __stdcall ThpAllocateSnapshotSection(PHANDLE SectionHandle, PVOID *BaseAddress, POBJECT_ATTRIBUTES ObjectAttributes, int a4, ULONG ViewSize, int a6, int a7)
{
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // esi@1
  int v10; // edx@3
  int v11; // eax@9
  NTSTATUS result; // eax@10
  HANDLE v13; // ST00_4@12
  PVOID v14; // eax@13
  char v15; // [sp+Ch] [bp-40h]@10
  int v16; // [sp+24h] [bp-28h]@21
  int v17; // [sp+28h] [bp-24h]@21
  int v18; // [sp+2Ch] [bp-20h]@21
  LARGE_INTEGER SectionOffset; // [sp+30h] [bp-1Ch]@12
  LARGE_INTEGER SectionSize; // [sp+38h] [bp-14h]@11
  int v21; // [sp+40h] [bp-Ch]@1
  int v22; // [sp+44h] [bp-8h]@1
  int v23; // [sp+48h] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v9 = 52;
  if ( (unsigned __int8)ObjectAttributes & 2 || (unsigned __int8)ObjectAttributes & 4 )
  {
    do
    {
      ++v23;
      v10 = *(_DWORD *)(v7 + ViewSize);
      v8 += *(_DWORD *)(v7 + ViewSize + 4);
      v7 += v10;
    }
    while ( v10 );
    JUMPOUT((unsigned __int8)ObjectAttributes & 2, 0, &loc_77E2021C);
    if ( (unsigned __int8)ObjectAttributes & 4 )
      v9 = 28 * v8 + 52;
  }
  if ( (unsigned __int8)ObjectAttributes & 8 )
  {
    if ( 1064 * a6 < (unsigned int)a6 || v9 + 1064 * a6 < (unsigned int)v9 )
      return -1073741453;
    v9 += 1064 * a6;
    v21 = a6;
  }
  if ( (unsigned __int8)ObjectAttributes & 1 )
  {
    if ( 16 * a7 >= (unsigned int)a7 )
    {
      v9 += 16 * a7;
      if ( v9 >= (unsigned int)a7 )
      {
        v22 = a7;
        goto LABEL_8;
      }
    }
    return -1073741453;
  }
LABEL_8:
  if ( (unsigned int)ObjectAttributes & 0x80000000 )
  {
    v17 = 0;
    v16 = 12;
    v18 = 1;
    v11 = (int)&v16;
  }
  else
  {
    v11 = 0;
  }
  result = BaseFormatObjectAttributes((int)&v15, v11, 0, (int)&ObjectAttributes);
  if ( result >= 0 )
  {
    SectionSize = (LARGE_INTEGER)(unsigned int)v9;
    result = NtCreateSection(SectionHandle, 0xF0007u, ObjectAttributes, &SectionSize, 4u, 0x8000000u, 0);
    if ( result >= 0 )
    {
      v13 = *SectionHandle;
      SectionOffset = 0i64;
      ViewSize = 0;
      result = NtMapViewOfSection(
                 v13,
                 (HANDLE)0xFFFFFFFF,
                 BaseAddress,
                 0,
                 0,
                 &SectionOffset,
                 &ViewSize,
                 ViewShare,
                 0,
                 4u);
      if ( result >= 0 )
      {
        v14 = *BaseAddress;
        *((_DWORD *)v14 + 1) = v23;
        *(_DWORD *)v14 = v22;
        *((_DWORD *)v14 + 2) = v21;
        *((_DWORD *)v14 + 3) = v8;
        result = 0;
      }
    }
  }
  return result;
}

//----- (77E2004E) --------------------------------------------------------
int __stdcall ThpProcessToSnap(char a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v7; // eax@10
  int v8; // edi@10
  int v9; // esi@11
  int v10; // ebx@1
  int v11; // esi@1
  int v12; // eax@4
  int v13; // esi@5
  unsigned int v14; // edx@5
  int v15; // ecx@6
  int v16; // esi@8
  int v18; // eax@15
  int v19; // ecx@16
  int v20; // edi@17
  int v21; // [sp+Ch] [bp-4h]@15
  int v22; // [sp+18h] [bp+8h]@4
  int v23; // [sp+20h] [bp+10h]@1
  int v24; // [sp+20h] [bp+10h]@16
  unsigned int v25; // [sp+30h] [bp+20h]@10

  v10 = a3;
  v11 = a3 + 48;
  v23 = a3 + 48;
  if ( a1 & 1 )
  {
    *(_DWORD *)(v10 + 16) = v11 - v10;
    v18 = 0;
    v21 = 0;
    if ( *(_DWORD *)v10 )
    {
      v19 = v11 + 12;
      v24 = a7 + 4;
      do
      {
        *(_DWORD *)(v19 - 8) = a2;
        *(_DWORD *)(v19 - 12) = 16;
        v20 = *(_DWORD *)v24;
        *(_DWORD *)(v19 - 4) = *(_DWORD *)v24;
        v24 += 64;
        *(_DWORD *)v19 = v20 == *(_DWORD *)(a6 + 76);
        v19 += 16;
        v18 = v21 + 1;
        v21 = v18;
      }
      while ( (unsigned int)v18 < *(_DWORD *)v10 );
    }
    v11 += 16 * v18;
    v23 = v11;
  }
  if ( a1 & 8 )
  {
    *(_DWORD *)(v10 + 24) = v11 - v10;
    v7 = 0;
    v8 = a5 + 4;
    v25 = 0;
    if ( *(_DWORD *)(v10 + 8) )
    {
      v9 = v11 + 28;
      do
      {
        *(_DWORD *)(v9 - 20) = a2;
        *(_DWORD *)(v9 - 28) = 1064;
        *(_DWORD *)v9 = *(_DWORD *)(v8 + 8);
        *(_DWORD *)(v9 - 8) = *(_DWORD *)(v8 + 8);
        ThpCopyAnsiToUnicode(v9 + 516, (PCSZ)(v8 + 28), 520);
        ThpCopyAnsiToUnicode(v9 + 4, (PCSZ)(*(_WORD *)(v8 + 26) + v8 + 28), 512);
        *(_DWORD *)(v9 - 4) = *(_DWORD *)(v8 + 12);
        *(_DWORD *)(v9 - 24) = 1;
        *(_DWORD *)(v9 - 16) = *(_WORD *)(v8 + 24);
        *(_DWORD *)(v9 - 12) = *(_WORD *)(v8 + 24);
        v8 += 284;
        v9 += 1064;
        ++v25;
        v7 = v25;
      }
      while ( v25 < *(_DWORD *)(v10 + 8) );
      v11 = v23;
    }
    v11 += 1064 * v7;
  }
  JUMPOUT(a1 & 2, 0, &loc_77E2022D);
  if ( a1 & 4 )
  {
    v22 = 0;
    *(_DWORD *)(v10 + 28) = v11 - v10;
    v12 = v11;
    do
    {
      v13 = v22 + a4;
      v14 = 0;
      if ( *(_DWORD *)(v22 + a4 + 4) )
      {
        v15 = v13 + 216;
        do
        {
          *(_DWORD *)v12 = 28;
          *(_DWORD *)(v12 + 8) = *(_DWORD *)(v15 + 4);
          *(_DWORD *)(v12 + 12) = *(_DWORD *)v15;
          *(_DWORD *)(v12 + 16) = *(_DWORD *)(v15 + 12);
          *(_DWORD *)(v12 + 20) = 0;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 24) = 0;
          v15 += 64;
          v12 += 28;
          ++v14;
        }
        while ( v14 < *(_DWORD *)(v13 + 4) );
      }
      v16 = *(_DWORD *)v13;
      v22 += v16;
    }
    while ( v16 );
  }
  return 0;
}

//----- (77E200F5) --------------------------------------------------------
BOOL __stdcall Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe)
{
  LPPROCESSENTRY32W v2; // edi@1
  NTSTATUS v3; // eax@3
  LPPROCESSENTRY32W v4; // eax@4
  LARGE_INTEGER SectionOffset; // [sp+Ch] [bp-10h]@3
  ULONG ViewSize; // [sp+14h] [bp-8h]@3
  int v8; // [sp+18h] [bp-4h]@1

  v2 = lppe;
  v8 = 0;
  if ( !lppe || lppe->dwSize != 556 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lppe = 0;
  v3 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lppe,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  v4 = lppe;
  if ( lppe->cntUsage )
  {
    qmemcpy(v2, (char *)lppe + lppe->cntThreads, 0x22Cu);
    *(_DWORD *)&v4->szExeFile[0] = 1;
    v8 = 1;
  }
  else
  {
    memset(&v2->cntUsage, 0, v2->dwSize - 4);
    RtlSetLastWin32Error(18);
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lppe);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2018A) --------------------------------------------------------
BOOL __stdcall Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe)
{
  LPPROCESSENTRY32W v2; // edi@1
  BOOL v3; // esi@1
  NTSTATUS v4; // eax@3
  DWORD v5; // ecx@4
  char *v6; // esi@5
  LARGE_INTEGER SectionOffset; // [sp+8h] [bp-Ch]@3
  ULONG ViewSize; // [sp+10h] [bp-4h]@3

  v2 = lppe;
  v3 = 0;
  if ( !lppe || lppe->dwSize != 556 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lppe = 0;
  v4 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lppe,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = *(_DWORD *)&lppe->szExeFile[0];
  if ( v5 >= lppe->cntUsage )
  {
    RtlSetLastWin32Error(18);
  }
  else
  {
    v6 = (char *)&lppe[v5] + lppe->cntThreads;
    *(_DWORD *)&lppe->szExeFile[0] = v5 + 1;
    qmemcpy(v2, v6, 0x22Cu);
    v3 = 1;
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lppe);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E20394) --------------------------------------------------------
int __stdcall LocalOpenPerformanceData(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = -2147483644;
  return 0;
}

//----- (77E203AD) --------------------------------------------------------
BOOL __stdcall VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
{
  BOOL v2; // esi@1
  NTSTATUS v3; // eax@1

  v2 = 1;
  v3 = NtLockVirtualMemory((HANDLE)0xFFFFFFFF, &lpAddress, &dwSize, 1u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    v2 = 0;
  }
  return v2;
}

//----- (77E203E9) --------------------------------------------------------
LPVOID __stdcall LockResourceStub(HGLOBAL hResData)
{
  return LockResource(hResData);
}

//----- (77E2040C) --------------------------------------------------------
ULONG __stdcall ClosePredefinedHandle(unsigned int a1)
{
  int v1; // eax@1
  int v3; // edi@5
  ULONG v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  RtlRunOnceExecuteOnce(
    &PredefinedHandleTableCriticalSectionInit,
    (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
    0,
    0);
  RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
  v1 = 4 * MapPredefinedRegistryHandleToIndex(a1);
  v5 = PredefinedHandleTable[v1];
  if ( v5 )
  {
    PredefinedHandleTable[v1] = 0;
    v3 = dword_77EA6B24[v1];
    if ( !v3 || *(_DWORD *)(v3 + 4) )
    {
      v5 = 0;
    }
    else
    {
      dword_77EA6B24[v1] = RemoveUnitFromList(v3, dword_77EA6B24[v1]);
      FreePredefinedHandleUnit((PVOID)v3);
    }
  }
  else
  {
    v4 = 0;
  }
  RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
  if ( v5 )
    v4 = LocalBaseRegCloseKey(&v5);
  return v4;
}
// 77EA6B20: using guessed type int PredefinedHandleTable[];
// 77EA6B24: using guessed type int dword_77EA6B24[];

//----- (77E20478) --------------------------------------------------------
void __stdcall __noreturn FreeLibraryAndExitThreadStub(HMODULE hLibModule, DWORD dwExitCode)
{
  FreeLibraryAndExitThread(hLibModule, dwExitCode);
  __debugbreak();
  JUMPOUT(*(_DWORD *)byte_77E20489);
}

//----- (77E20499) --------------------------------------------------------
HFILE __stdcall _lclose(HFILE hFile)
{
  return (CloseHandle((HANDLE)hFile) != 0) - 1;
}

//----- (77E20582) --------------------------------------------------------
BOOLEAN __stdcall FreePredefinedHandleUnit(PVOID Address)
{
  return RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}

//----- (77E205A7) --------------------------------------------------------
int __stdcall RemoveUnitFromList(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int i; // ecx@4

  result = a1;
  v3 = a1;
  if ( a1 == a2 )
  {
    result = *(_DWORD *)(a1 + 12);
  }
  else
  {
    for ( i = a1 + 12; *(_DWORD *)i != a2; i = *(_DWORD *)i + 12 )
      v3 = *(_DWORD *)i;
    *(_DWORD *)(v3 + 12) = *(_DWORD *)(a2 + 12);
  }
  return result;
}

//----- (77E206F2) --------------------------------------------------------
SIZE_T __stdcall LocalSize(HLOCAL hMem)
{
  PVOID *v1; // ebx@1
  ULONG v2; // eax@4
  SIZE_T result; // eax@6
  PVOID *v4; // [sp+14h] [bp-24h]@8
  int v5; // [sp+18h] [bp-20h]@1
  SIZE_T v6; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  v6 = -1;
  v5 = 0;
  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v1 = (PVOID *)hMem;
  if ( (unsigned __int8)hMem & 4 )
    goto LABEL_20;
  v4 = 0;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, v5, hMem, &v4, &v5) )
  {
    if ( v4 && v5 & 0x200 )
      v1 = v4;
    else
      v6 = RtlSizeHeap(BaseHeap, 1u, hMem);
  }
  if ( (unsigned __int8)v1 & 4 )
  {
LABEL_20:
    if ( (unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, v1 - 1) )
    {
      if ( *((_BYTE *)v1 - 4) & 8 )
        v2 = (ULONG)*v1;
      else
        v2 = RtlSizeHeap(BaseHeap, 1u, *v1);
      v6 = v2;
    }
    else
    {
      RtlSetLastWin32Error(6);
    }
  }
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  result = v6;
  if ( v6 == -1 )
  {
    RtlSetLastWin32Error(6);
    result = 0;
  }
  return result;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E20847) --------------------------------------------------------
BOOL __stdcall SetConsoleTitleW(LPCWSTR lpConsoleTitle)
{
  return SetConsoleTitleInternal((void *)lpConsoleTitle, 2 * wcslen(lpConsoleTitle), 1);
}

//----- (77E208B1) --------------------------------------------------------
int __stdcall SetConsoleTitleInternal(void *Src, int a2, char a3)
{
  PVOID v3; // esi@1
  ULONG v5; // eax@6
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@2
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@2
  size_t Size; // [sp+30h] [bp-7Ch]@1
  int v9; // [sp+34h] [bp-78h]@2
  char v10; // [sp+38h] [bp-74h]@1

  Size = a2;
  v10 = a3;
  v3 = ConsoleAllocateCaptureBuffer(1u, a2);
  if ( v3 )
  {
    ConsoleCaptureMessageBuffer((int)v3, Src, Size, (int)&v9);
    ConsoleClientCallServer(&RequestMessage, (int)v3, 37, 12);
    ConsoleFreeCaptureBuffer(v3);
    if ( NtStatus >= 0 )
      return 1;
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E20933) --------------------------------------------------------
DWORD __stdcall GetFileSizeStub(HANDLE hFile, LPDWORD lpFileSizeHigh)
{
  return GetFileSize(hFile, lpFileSizeHigh);
}

//----- (77E20956) --------------------------------------------------------
DWORD __stdcall SleepExStub(DWORD dwMilliseconds, BOOL bAlertable)
{
  return SleepEx(dwMilliseconds, bAlertable);
}

//----- (77E20963) --------------------------------------------------------
signed int __stdcall OpenConsoleW(PCWSTR SourceString, int a2, int a3, int a4)
{
  NTSTATUS v4; // eax@1
  int v5; // eax@7
  ULONG v7; // ST10_4@12
  ULONG v8; // ST10_4@13
  UNICODE_STRING String1; // [sp+10h] [bp-24h]@1
  int v10; // [sp+18h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  v4 = RtlInitUnicodeStringEx(&String1, SourceString);
  if ( v4 < 0 )
  {
    v7 = RtlNtStatusToDosError(v4);
    RtlSetLastWin32Error(v7);
LABEL_16:
    ms_exc.registration.TryLevel = -2;
    return -1;
  }
  if ( RtlEqualUnicodeString(&String1, &ConsoleInput, 1u) )
  {
    v10 = 1;
    goto LABEL_5;
  }
  if ( !RtlEqualUnicodeString(&String1, &ConsoleOutput, 1u) )
  {
    RtlSetLastWin32Error(87);
    goto LABEL_16;
  }
  v10 = 2;
LABEL_5:
  ms_exc.registration.TryLevel = -2;
  if ( a2 & 0x3FFFFFFF || a4 & 0xFFFFFFFC )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    v5 = OpenConsoleWInternal(v10, a2, a3, a4, (int)&a4);
    if ( v5 >= 0 )
      return a4;
    v8 = RtlNtStatusToDosError(v5);
    RtlSetLastWin32Error(v8);
  }
  return -1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E20A41) --------------------------------------------------------
int __stdcall OpenConsoleWInternal(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  int v7; // [sp+24h] [bp-84h]@1
  int v8; // [sp+2Ch] [bp-7Ch]@1
  int v9; // [sp+30h] [bp-78h]@1
  int v10; // [sp+34h] [bp-74h]@1
  int v11; // [sp+38h] [bp-70h]@1
  int v12; // [sp+3Ch] [bp-6Ch]@2

  v8 = a1;
  v9 = a2;
  v10 = a3;
  v11 = a4;
  ConsoleClientCallServer(&RequestMessage, 0, 0, 20);
  result = v7;
  if ( v7 >= 0 )
    *(_DWORD *)a5 = v12;
  return result;
}

//----- (77E20AA7) --------------------------------------------------------
BOOL __stdcall SetEnvironmentStringsWStub(LPWCH NewEnvironment)
{
  return SetEnvironmentStringsW(NewEnvironment);
}

//----- (77E20ACA) --------------------------------------------------------
UINT __stdcall GetWindowsDirectoryWStub(LPWSTR lpBuffer, UINT uSize)
{
  return GetWindowsDirectoryW(lpBuffer, uSize);
}

//----- (77E20AD7) --------------------------------------------------------
BOOL __stdcall GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
{
  LPDWORD v2; // edi@1
  DWORD v3; // ST18_4@1
  DWORD v4; // eax@1
  DWORD v5; // ebx@1
  BOOL result; // eax@4
  signed int v7; // eax@7
  NTSTATUS v8; // eax@9
  LPWSTR v9; // eax@11
  WCHAR v10; // cx@13
  NTSTATUS v11; // eax@16
  PVOID v12; // esi@23
  BOOL v13; // esi@42
  int v14; // eax@45
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-44h]@7
  LSA_UNICODE_STRING ValueName; // [sp+24h] [bp-2Ch]@34
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-24h]@32
  LSA_UNICODE_STRING v18; // [sp+34h] [bp-1Ch]@7
  ULONG Disposition; // [sp+3Ch] [bp-14h]@32
  int v20; // [sp+40h] [bp-10h]@16
  HANDLE KeyHandle; // [sp+44h] [bp-Ch]@1
  int v22; // [sp+48h] [bp-8h]@1
  HANDLE Handle; // [sp+4Ch] [bp-4h]@1
  BOOL nSizea; // [sp+5Ch] [bp+Ch]@15

  v2 = nSize;
  v3 = *nSize;
  Handle = 0;
  KeyHandle = 0;
  v22 = 0;
  v4 = GetEnvironmentVariableW(L"_CLUSTER_NETWORK_NAME_", lpBuffer, v3);
  v5 = v4;
  if ( !v4 )
  {
    if ( gpwzComputerNameCache )
    {
      if ( *nSize < gcComputerNameCacheSize + 1 )
      {
        *nSize = gcComputerNameCacheSize + 1;
        RtlSetLastWin32Error(111);
        result = 0;
      }
      else
      {
        *nSize = gcComputerNameCacheSize;
        memcpy(lpBuffer, gpwzComputerNameCache, 2 * gcComputerNameCacheSize + 2);
        result = 1;
      }
      return result;
    }
    if ( gpTermsrvGetComputerName )
    {
      v14 = gpTermsrvGetComputerName(lpBuffer, nSize);
      if ( v14 != 1237 )
      {
        if ( v14 == 111 )
        {
          nSizea = 0;
          goto LABEL_26;
        }
LABEL_11:
        v9 = lpBuffer;
        if ( lpBuffer && *nSize )
        {
          do
          {
            v10 = *v9;
            ++v9;
          }
          while ( v10 );
          *nSize = v9 - (lpBuffer + 1);
        }
        nSizea = 1;
        if ( dword_77EA6BE4 )
        {
          RtlEnterCriticalSection(&gComputerNameCacheUpdateCR);
          v20 = 4;
          v11 = BasepGetValueFromReg(
                  L"\\Registry\\Machine\\System\\Setup",
                  (int)L"OOBEInProgress",
                  (int)&v22,
                  (int)&v20);
          if ( v11 < 0 || !v22 )
          {
            v20 = 4;
            v11 = BasepGetValueFromReg(
                    L"\\Registry\\Machine\\System\\Setup",
                    (int)L"SystemSetupInProgress",
                    (int)&v22,
                    (int)&v20);
          }
          if ( v11 >= 0 && v22 )
            dword_77EA6BE4 = 0;
          if ( dword_77EA6BE4 && !gpwzComputerNameCache )
          {
            v12 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * *v2 + 2);
            if ( v12 )
            {
              memcpy(v12, lpBuffer, 2 * *v2);
              *((_WORD *)v12 + *v2) = 0;
              gcComputerNameCacheSize = wcslen((const unsigned __int16 *)v12);
              gpwzComputerNameCache = v12;
            }
            else
            {
              dword_77EA6BE4 = 0;
            }
          }
          RtlLeaveCriticalSection(&gComputerNameCacheUpdateCR);
        }
        goto LABEL_26;
      }
    }
    RtlInitUnicodeString(&v18, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName");
    ObjectAttributes.ObjectName = &v18;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v7 = NtOpenKey(&Handle, 0x20019u, &ObjectAttributes);
    if ( v7 == -1073741772 )
    {
      if ( lpBuffer )
        *lpBuffer = 0;
      *nSize = 0;
      goto LABEL_11;
    }
    if ( v7 >= 0 )
    {
      v8 = GetNameFromValue((int)Handle, L"ActiveComputerName", lpBuffer, (int)nSize);
      if ( v8 == -2147483643 )
      {
        RtlSetLastWin32Error(111);
        goto LABEL_41;
      }
      if ( v8 >= 0 )
        goto LABEL_11;
      v7 = GetNameFromValue((int)Handle, L"ComputerName", lpBuffer, (int)nSize);
      if ( v7 == -1073741772 )
      {
        *lpBuffer = 0;
        *nSize = 0;
        goto LABEL_11;
      }
      if ( v7 >= 0 )
      {
        RtlInitUnicodeString(&DestinationString, L"Network ComputerName");
        RtlInitUnicodeString(&v18, L"ActiveComputerName");
        ObjectAttributes.RootDirectory = Handle;
        ObjectAttributes.ObjectName = &v18;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        ObjectAttributes.Length = 24;
        ObjectAttributes.Attributes = 64;
        v7 = NtCreateKey(&KeyHandle, 0x2001Fu, &ObjectAttributes, 0, &DestinationString, 1u, &Disposition);
        if ( v7 >= 0 )
        {
          if ( Disposition != 2
            || GetNameFromValue((int)Handle, L"ActiveComputerName", lpBuffer, (int)nSize) != -1073741772 )
          {
            RtlInitUnicodeString(&ValueName, L"ComputerName");
            v7 = NtSetValueKey(KeyHandle, &ValueName, 0, 1u, lpBuffer, 2 * wcslen(lpBuffer) + 2);
            if ( v7 >= 0 )
              goto LABEL_11;
          }
          else
          {
            v7 = -1073741823;
          }
        }
      }
    }
    BaseSetLastNTError(v7);
LABEL_41:
    nSizea = 0;
LABEL_26:
    if ( Handle )
      NtClose(Handle);
    if ( KeyHandle )
      NtClose(KeyHandle);
    return nSizea;
  }
  v13 = *nSize >= v4;
  if ( *nSize < v4 )
    RtlSetLastWin32Error(111);
  *nSize = v5;
  return v13;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E20E50: using guessed type wchar_t aOobeinprogress[15];
// 77EA655C: using guessed type int gcComputerNameCacheSize;
// 77EA67F4: using guessed type int (__stdcall *gpTermsrvGetComputerName)(_DWORD, _DWORD);
// 77EA6BE4: using guessed type int dword_77EA6BE4;

//----- (77E20E73) --------------------------------------------------------
NTSTATUS __stdcall BasepGetValueFromReg(PCWSTR SourceString, int a2, int a3, int a4)
{
  char *v4; // esi@1
  unsigned int v5; // eax@4
  int v6; // eax@7
  int v8; // eax@19
  int v9; // ecx@19
  void *v10; // ebx@22
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-C4h]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+14h] [bp-BCh]@1
  LSA_UNICODE_STRING ValueName; // [sp+2Ch] [bp-A4h]@2
  PCWSTR v14; // [sp+34h] [bp-9Ch]@1
  void *Dst; // [sp+38h] [bp-98h]@1
  HANDLE KeyHandle; // [sp+3Ch] [bp-94h]@1
  ULONG ResultLength; // [sp+40h] [bp-90h]@2
  NTSTATUS v18; // [sp+44h] [bp-8Ch]@1
  char v19; // [sp+4Bh] [bp-85h]@1
  char KeyValueInformation; // [sp+4Ch] [bp-84h]@1

  v14 = (PCWSTR)a2;
  Dst = (void *)a3;
  v4 = &KeyValueInformation;
  v19 = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &DestinationString;
  v18 = NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
  if ( v18 < 0 )
    return v18;
  RtlInitUnicodeString(&ValueName, v14);
  v18 = NtQueryValueKey(KeyHandle, &ValueName, KeyValueFullInformation, &KeyValueInformation, 0x80u, &ResultLength);
  if ( v18 == -2147483643 )
  {
    v4 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ResultLength);
    if ( !v4 )
      goto LABEL_10;
    v19 = 1;
    v18 = NtQueryValueKey(KeyHandle, &ValueName, KeyValueFullInformation, v4, ResultLength, &ResultLength);
  }
  if ( v18 < 0 )
    goto LABEL_10;
  v5 = *((_DWORD *)v4 + 1);
  if ( !v5 )
    goto LABEL_25;
  if ( v5 > 2 )
  {
    if ( v5 <= 4 )
      goto LABEL_7;
    if ( v5 != 7 )
    {
      if ( v5 == 11 )
      {
LABEL_7:
        v6 = *((_DWORD *)v4 + 3);
        if ( *(_DWORD *)a4 >= (unsigned int)v6 )
        {
          memcpy(Dst, &v4[*((_DWORD *)v4 + 2)], *((_DWORD *)v4 + 3));
          v6 = *((_DWORD *)v4 + 3);
LABEL_9:
          *(_DWORD *)a4 = v6;
          goto LABEL_10;
        }
LABEL_17:
        v18 = -2147483643;
        goto LABEL_9;
      }
LABEL_25:
      v18 = -1073741595;
      goto LABEL_10;
    }
  }
  if ( *((_DWORD *)v4 + 3) >= 2u )
  {
    v8 = *((_DWORD *)v4 + 3) - (*((_DWORD *)v4 + 3) & 1);
    v9 = *((_DWORD *)v4 + 2);
    *((_DWORD *)v4 + 3) = v8;
    if ( !*(_WORD *)(&v4[v9 - 2] + v8) )
      *((_DWORD *)v4 + 3) = v8 - 2;
    v6 = *((_DWORD *)v4 + 3) + 2;
    if ( *(_DWORD *)a4 >= (unsigned int)v6 )
    {
      v10 = Dst;
      if ( Dst )
      {
        memcpy(Dst, &v4[v9], *((_DWORD *)v4 + 3));
        *(_WORD *)((char *)v10 + *((_DWORD *)v4 + 3)) = 0;
        v6 = *((_DWORD *)v4 + 3) + 2;
        goto LABEL_9;
      }
    }
    goto LABEL_17;
  }
  v18 = -1073741772;
LABEL_10:
  NtClose(KeyHandle);
  if ( v19 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
  return v18;
}

//----- (77E20FE1) --------------------------------------------------------
NTSTATUS __stdcall GetNameFromValue(int a1, PCWSTR SourceString, void *Dst, int a4)
{
  unsigned int v4; // esi@4
  int v5; // edi@6
  int v6; // eax@6
  LSA_UNICODE_STRING ValueName; // [sp+Ch] [bp-A8h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-A0h]@1
  ULONG ResultLength; // [sp+1Ch] [bp-98h]@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+20h] [bp-94h]@1
  int v12; // [sp+38h] [bp-7Ch]@1
  HANDLE KeyHandle; // [sp+3Ch] [bp-78h]@1
  NTSTATUS v14; // [sp+40h] [bp-74h]@1
  char KeyValueInformation[8]; // [sp+44h] [bp-70h]@2
  int v16; // [sp+4Ch] [bp-68h]@4
  unsigned int v17; // [sp+50h] [bp-64h]@3

  v12 = a4;
  RtlInitUnicodeString(&DestinationString, SourceString);
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.RootDirectory = (HANDLE)a1;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v14 = NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
  if ( v14 >= 0 )
  {
    RtlInitUnicodeString(&ValueName, L"ComputerName");
    v14 = NtQueryValueKey(KeyHandle, &ValueName, KeyValueFullInformation, KeyValueInformation, 0x6Cu, &ResultLength);
    NtClose(KeyHandle);
    if ( v14 >= 0 )
    {
      if ( v17 < 2 )
      {
        v14 = -1073741772;
      }
      else
      {
        v17 -= v17 & 1;
        v4 = v17;
        if ( !*(_WORD *)((char *)&v14 + v16 + v17 + 2) )
        {
          v4 = v17 - 2;
          v17 -= 2;
        }
        v5 = v12;
        v6 = (v4 >> 1) + 1;
        if ( *(_DWORD *)v12 < (unsigned int)v6 )
        {
          v14 = -2147483643;
        }
        else
        {
          memcpy(Dst, &KeyValueInformation[v16], v4);
          *(_WORD *)((char *)Dst + v4) = 0;
          v6 = wcslen((const unsigned __int16 *)Dst);
        }
        *(_DWORD *)v5 = v6;
      }
    }
  }
  return v14;
}
// 77E20FE1: using guessed type char KeyValueInformation[8];

//----- (77E21187) --------------------------------------------------------
int __stdcall NullTerminateRegExpandSzString(HKEY hKey, LPCWSTR lpValueName, int a3, int a4, int a5, ULONG Flags, int a7, char a8)
{
  unsigned int v8; // ebx@1
  int v9; // edi@2
  int v10; // eax@3
  unsigned int v11; // esi@4
  ULONG v12; // eax@8
  PVOID v14; // edi@19
  LSTATUS v15; // eax@22
  int v16; // [sp+Ch] [bp-14h]@8
  DWORD Type; // [sp+10h] [bp-10h]@22
  DWORD cbData; // [sp+14h] [bp-Ch]@19
  unsigned int v19; // [sp+18h] [bp-8h]@1
  PVOID Address; // [sp+1Ch] [bp-4h]@5

  v8 = 0;
  v19 = (a8 == 0) + 1;
  if ( a7 )
  {
    if ( a7 != 234 )
    {
      v11 = 0;
      goto LABEL_32;
    }
LABEL_31:
    v11 = v19 + *(_DWORD *)a5;
LABEL_32:
    v9 = a4;
    Address = 0;
    goto LABEL_6;
  }
  v9 = a4;
  if ( !a4 )
    goto LABEL_31;
  v8 = Flags;
  v10 = NullTerminateRegSzString(a4, (int *)a5, Flags, 0, a8);
  a7 = v10;
  if ( v10 && (v8 = 0, v10 != 234) )
    v11 = 0;
  else
    v11 = *(_DWORD *)a5;
  Address = (PVOID)a4;
LABEL_6:
  if ( !v11 )
  {
LABEL_28:
    if ( !v8 )
      return a7;
    v9 = a4;
    goto LABEL_8;
  }
  if ( v8 )
  {
LABEL_8:
    v16 = v11 / v19;
    a7 = _ExpandRegString((LPWSTR)Address, v8 / v19, (int)&v16, a8);
    v12 = v19 * v16;
    if ( v19 * v16 <= v11 )
      v12 = v11;
    *(_DWORD *)a5 = v12;
    if ( a7 )
    {
      if ( a7 == 234 && !v9 )
        a7 = 0;
    }
    else if ( v12 > Flags && v9 )
    {
      a7 = 234;
    }
    if ( Address != (PVOID)v9 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    return a7;
  }
  cbData = v11;
  v14 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v11);
  if ( !v14 )
  {
    a7 = GetLastError();
    goto LABEL_28;
  }
  if ( Address )
  {
    memcpy(v14, Address, v11 - v19);
  }
  else
  {
    if ( a8 )
      v15 = RegQueryValueExA(hKey, (LPCSTR)lpValueName, 0, &Type, (LPBYTE)v14, &cbData);
    else
      v15 = RegQueryValueExW(hKey, lpValueName, 0, &Type, (LPBYTE)v14, &cbData);
    if ( v15 || Type != *(_DWORD *)a3 || NullTerminateRegSzString((int)v14, (int *)&cbData, v11, 0, a8) )
    {
      a7 = 1003;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v14);
      v14 = 0;
    }
  }
  if ( v14 )
  {
    v8 = v11;
    v11 = cbData;
    Address = v14;
    goto LABEL_28;
  }
  return a7;
}

//----- (77E2131C) --------------------------------------------------------
HANDLE __stdcall CreateFileMappingWStub(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
{
  return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
}

//----- (77E2132C) --------------------------------------------------------
DWORD __stdcall GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
{
  int v3; // eax@15
  PWSTR v4; // eax@3
  DWORD v5; // eax@6
  unsigned int v7; // kr04_4@24
  int v8; // eax@24
  PVOID v9; // eax@24
  char *v10; // esi@25
  signed int v11; // eax@31
  int v12; // edi@34
  __int16 v13; // di@35
  HANDLE v14; // eax@35
  int v15; // edi@40
  unsigned int v16; // eax@45
  int v17; // eax@51
  PVOID v18; // eax@51
  UINT uMode; // [sp+14h] [bp-298h]@2
  unsigned int v20; // [sp+1Ch] [bp-290h]@24
  PVOID Src; // [sp+20h] [bp-28Ch]@30
  char *v22; // [sp+24h] [bp-288h]@5
  PVOID v23; // [sp+28h] [bp-284h]@1
  void *v24; // [sp+2Ch] [bp-280h]@1
  PVOID Address; // [sp+30h] [bp-27Ch]@1
  void *v26; // [sp+34h] [bp-278h]@5
  void *Dst; // [sp+38h] [bp-274h]@25
  DWORD v28; // [sp+3Ch] [bp-270h]@1
  struct _WIN32_FIND_DATAW FindFileData; // [sp+40h] [bp-26Ch]@35
  CPPEH_RECORD ms_exc; // [sp+294h] [bp-18h]@2

  v24 = lpszShortPath;
  v23 = 0;
  Address = 0;
  v28 = 0;
  if ( !lpszLongPath )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  uMode = SetErrorMode(0x8001u);
  ms_exc.registration.TryLevel = 0;
  if ( GetFileAttributesW(lpszLongPath) == -1
    && (!NtCurrentTeb()->ProcessEnvironmentBlock
     || !(*(_DWORD *)&NtCurrentTeb()->ProcessEnvironmentBlock[1].Reserved1[0] & 1)) )
  {
    v28 = 0;
    goto LABEL_10;
  }
  v4 = SkipPathTypeIndicator_U((PWSTR)lpszLongPath);
  if ( !v4 || !*v4 || !FindLFNorSFN_U(v4, &v26, &v22, 1) )
  {
    v5 = wcslen(lpszLongPath);
    v28 = v5;
    if ( cchBuffer > v5 && lpszShortPath )
    {
      if ( lpszShortPath != lpszLongPath )
        _memmove(lpszShortPath, lpszLongPath, 2 * v5 + 2);
      goto LABEL_10;
    }
    goto LABEL_17;
  }
  v7 = wcslen(lpszLongPath);
  v8 = KernelBaseGetGlobalData();
  v20 = v7 + 1;
  v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44) + 0x200000, v20 * 2);
  Address = v9;
  if ( !v9 )
    goto LABEL_50;
  StringCchCopyNW((unsigned __int16 *)v9, v7 + 1, lpszLongPath, v7 + 1);
  v26 = (char *)Address + 2 * (((_BYTE *)v26 - (_BYTE *)lpszLongPath) >> 1);
  v10 = (char *)Address + 2 * ((v22 - (char *)lpszLongPath) >> 1);
  v22 = (char *)Address + 2 * ((v22 - (char *)lpszLongPath) >> 1);
  Dst = v24;
  if ( !cchBuffer || !v24 )
    goto LABEL_30;
  if ( (unsigned int)v24 < (unsigned int)lpszLongPath )
    goto LABEL_18;
  if ( (unsigned int)v24 >= (unsigned int)&lpszLongPath[v20] )
  {
    if ( (unsigned int)v24 >= (unsigned int)lpszLongPath )
      goto LABEL_30;
LABEL_18:
    if ( (unsigned int)((char *)v24 + 2 * cchBuffer) < (unsigned int)lpszLongPath )
    {
LABEL_30:
      Src = Address;
      v28 = 0;
      while ( 1 )
      {
        v11 = ((_BYTE *)v26 - (_BYTE *)Src) >> 1;
        if ( v11 )
        {
          v28 += v11;
          if ( cchBuffer > v28 )
          {
            if ( v24 )
            {
              v12 = 2 * v11;
              _memmove(Dst, Src, 2 * v11);
              Dst = (char *)Dst + v12;
            }
          }
        }
        v13 = *(_WORD *)v10;
        *(_WORD *)v10 = 0;
        v14 = FindFirstFileW((LPCWSTR)Address, &FindFileData);
        *(_WORD *)v10 = v13;
        if ( v14 == (HANDLE)-1 )
          break;
        FindClose(v14);
        v3 = wcslen(FindFileData.cAlternateFileName);
        if ( v3 )
          v26 = FindFileData.cAlternateFileName;
        else
          v3 = (v10 - (_BYTE *)v26) >> 1;
        v28 += v3;
        if ( cchBuffer > v28 && v24 )
        {
          v15 = 2 * v3;
          _memmove(Dst, v26, 2 * v3);
          Dst = (char *)Dst + v15;
        }
        Src = v10;
        if ( !*(_WORD *)v10 || !FindLFNorSFN_U(v10, &v26, &v22, 1) )
          goto LABEL_44;
        v10 = v22;
      }
      v28 = 0;
LABEL_44:
      if ( !v28 )
        goto LABEL_10;
      v16 = wcslen((const unsigned __int16 *)Src);
      v28 += v16;
      if ( cchBuffer > v28 && v24 )
      {
        _memmove(Dst, Src, 2 * v16 + 2);
        if ( v23 )
          _memmove(v24, v23, 2 * v28 + 2);
        goto LABEL_10;
      }
LABEL_17:
      ++v28;
      goto LABEL_10;
    }
  }
  v17 = KernelBaseGetGlobalData();
  v18 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          *(_DWORD *)(v17 + 44) + 0x200000,
          2 * cchBuffer);
  v23 = v18;
  if ( v18 )
  {
    Dst = v18;
    v10 = v22;
    goto LABEL_30;
  }
LABEL_50:
  RtlSetLastWin32Error(8);
LABEL_10:
  ms_exc.registration.TryLevel = -2;
  if ( v23 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v23);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  SetErrorMode(uMode);
  return v28;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3076A: using guessed type _DWORD __stdcall FindLFNorSFN_U(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2145C) --------------------------------------------------------
DWORD __stdcall GetShortPathNameWStub(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
{
  return GetShortPathNameW(lpszLongPath, lpszShortPath, cchBuffer);
}

//----- (77E21476) --------------------------------------------------------
signed int __stdcall IsShortName_U(int a1, signed int a2)
{
  signed int v2; // edi@2
  int v3; // eax@4
  char v4; // bl@7
  __int16 v6; // [sp+4h] [bp-124h]@4
  __int16 v7; // [sp+6h] [bp-122h]@4
  int v8; // [sp+8h] [bp-120h]@4
  BYTE TestChar[4]; // [sp+Ch] [bp-11Ch]@7
  unsigned __int16 v10; // [sp+10h] [bp-118h]@4
  __int16 v11; // [sp+12h] [bp-116h]@4
  char *v12; // [sp+14h] [bp-114h]@4
  int v13; // [sp+18h] [bp-110h]@5
  int v14; // [sp+1Ch] [bp-10Ch]@6
  char v15; // [sp+20h] [bp-108h]@4

  if ( a2 > 12 )
    return 0;
  v2 = 0;
  if ( !a2 )
    return 1;
  if ( 46 != *(_WORD *)a1 )
  {
    v8 = a1;
    v7 = 2 * a2;
    v6 = 2 * a2;
    v12 = &v15;
    v10 = 0;
    v11 = 260;
    v3 = KernelBaseGetGlobalData();
    if ( (*(int (__stdcall **)(unsigned __int16 *, __int16 *, _DWORD))(v3 + 28))(&v10, &v6, 0) >= 0 )
    {
      v13 = 0;
      if ( v10 <= 0u )
        return 1;
      v14 = a2 - 1;
      while ( 1 )
      {
        v4 = v12[v2];
        TestChar[0] = v12[v2];
        if ( IsDBCSLeadByte(TestChar[0]) )
        {
          if ( !v13 && v2 >= 7 || v2 == v10 - 1 )
            return 0;
          ++v2;
          --v14;
        }
        else
        {
          if ( (unsigned __int8)v4 > 0x7Fu
            || (1 << (unsigned __int8)v4 % 32) & IllegalMask[(unsigned int)(unsigned __int8)v4 >> 5] )
            return 0;
          if ( v4 == 46 )
          {
            if ( v13 || v14 > 3 )
              return 0;
            v13 = 1;
          }
          if ( v2 >= 8 && !v13 )
            return 0;
        }
        ++v2;
        --v14;
        if ( v2 >= v10 )
          return 1;
      }
    }
    return 0;
  }
  if ( a2 == 1 || a2 == 2 && 46 == *(_WORD *)(a1 + 2) )
    return 1;
  return 0;
}
// 77E215B0: using guessed type int IllegalMask[];

//----- (77E215C5) --------------------------------------------------------
BOOL __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
{
  NTSTATUS v3; // eax@1

  v3 = RtlVerifyVersionInfo(lpVersionInformation, dwTypeMask, dwlConditionMask);
  if ( v3 == -1073741811 )
  {
    RtlSetLastWin32Error(160);
  }
  else
  {
    if ( v3 != -1073741735 )
      return 1;
    RtlSetLastWin32Error(1150);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E215FE) --------------------------------------------------------
ULONG __stdcall RegCreateKeyExInternalW(int a1, int a2, int a3, int SourceString, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a7, int a8, int a9, int a10)
{
  int v10; // edi@1
  int v11; // eax@1
  int v12; // ebx@1
  int v13; // esi@1
  int v14; // eax@7
  NTSTATUS v15; // eax@8
  int v16; // esi@16
  int v17; // edi@16
  int v18; // eax@16
  unsigned int v20; // esi@29
  int (__stdcall *v21)(_DWORD, _DWORD); // eax@29
  bool v22; // al@32
  ACCESS_MASK v23; // ecx@34
  int v24; // esi@39
  int v26; // [sp+10h] [bp-50h]@18
  UNICODE_STRING Source; // [sp+24h] [bp-3Ch]@8
  UNICODE_STRING DestinationString; // [sp+2Ch] [bp-34h]@10
  int (__stdcall *v29)(unsigned int, UNICODE_STRING *, UNICODE_STRING *, ULONG, ACCESS_MASK, int, int, int); // [sp+38h] [bp-28h]@1
  int v30; // [sp+3Ch] [bp-24h]@1
  int v31; // [sp+40h] [bp-20h]@1
  ULONG v32; // [sp+44h] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+48h] [bp-18h]@39

  v10 = 0;
  v30 = 0;
  v31 = 0;
  v11 = RegKrnGetGlobalState();
  v12 = *(_DWORD *)(v11 + 84);
  v29 = *(int (__stdcall **)(unsigned int, UNICODE_STRING *, UNICODE_STRING *, ULONG, ACCESS_MASK, int, int, int))(v11 + 84);
  v13 = a1;
  if ( a1 == -2147483644 || a1 == -2147483568 || a1 == -2147483552 )
    return 6;
  if ( a3 )
    return 87;
  if ( a2 && a8 )
  {
    v14 = RegKrnGetGlobalState();
    v32 = (*(int (__stdcall **)(int, int *, int *, int *))(v14 + 176))(v13, &a1, &v30, &v31);
    if ( v32 )
      goto LABEL_16;
    v15 = RtlInitUnicodeStringEx(&Source, (PCWSTR)a2);
    if ( v15 >= 0 )
    {
      Source.Length += 2;
      if ( !SourceString )
      {
        DestinationString.Length = 0;
        DestinationString.MaximumLength = 0;
        DestinationString.Buffer = 0;
LABEL_11:
        if ( !a7 )
        {
          SourceString = 0;
          goto LABEL_13;
        }
        v10 = (int)&v26;
        SourceString = (int)&v26;
        v32 = MapSAToRpcSA(a7, (int)&v26);
        if ( !v32 )
        {
LABEL_13:
          if ( !(a1 & 1) )
          {
            v32 = LocalBaseRegCreateKey(
                    a1,
                    &Source,
                    (int)&DestinationString,
                    CreateOptions,
                    DesiredAccess,
                    v10,
                    a8,
                    a9,
                    a10);
            goto LABEL_15;
          }
          if ( !v12 )
          {
LABEL_15:
            if ( v10 )
              RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v10 + 4));
            goto LABEL_16;
          }
          a2 = 0;
          v20 = a1 & 0xFFFFFFFE;
          v21 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
          v22 = v21 && !v21(v20, &a2) && a2 == 6;
          v23 = DesiredAccess;
          if ( !(DesiredAccess & 0x300) )
          {
            if ( !v22 )
            {
LABEL_38:
              v23 &= 0xFFFFFCFF;
LABEL_39:
              ms_exc.registration.TryLevel = 0;
              v24 = a8;
              v32 = v29(a1 & 0xFFFFFFFE, &Source, &DestinationString, CreateOptions, v23, v10, a8, a9);
              ms_exc.registration.TryLevel = -2;
              if ( !v32 )
                *(_DWORD *)v24 |= 1u;
              goto LABEL_15;
            }
            v23 = DesiredAccess | 0x200;
          }
          if ( v22 )
            goto LABEL_39;
          goto LABEL_38;
        }
LABEL_16:
        v16 = v31;
        v17 = v30;
        v18 = RegKrnGetGlobalState();
        (*(void (__stdcall **)(int, int))(v18 + 168))(v17, v16);
        return v32;
      }
      v15 = RtlInitUnicodeStringEx(&DestinationString, (PCWSTR)SourceString);
      if ( v15 >= 0 )
      {
        DestinationString.Length += 2;
        goto LABEL_11;
      }
    }
    v32 = RtlNtStatusToDosError(v15);
    goto LABEL_16;
  }
  return 1010;
}

//----- (77E21731) --------------------------------------------------------
LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
  int v9; // eax@1

  v9 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, const LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, _DWORD))(v9 + 188))(
           hKey,
           lpSubKey,
           Reserved,
           lpClass,
           dwOptions,
           samDesired,
           lpSecurityAttributes,
           phkResult,
           lpdwDisposition,
           0);
}

//----- (77E21772) --------------------------------------------------------
HANDLE __stdcall CreateEventAStub(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
{
  return CreateEventA(lpEventAttributes, bManualReset, bInitialState, lpName);
}

//----- (77E217A1) --------------------------------------------------------
BOOL __stdcall GetComputerNameExWStub(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
{
  return GetComputerNameExW(NameType, lpBuffer, nSize);
}

//----- (77E217C4) --------------------------------------------------------
int __stdcall CompareStringAStub(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
{
  return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

//----- (77E217E7) --------------------------------------------------------
DWORD __stdcall ResumeThreadStub(HANDLE hThread)
{
  return ResumeThread(hThread);
}

//----- (77E217FF) --------------------------------------------------------
BOOL __stdcall DeleteFileWStub(LPCWSTR lpFileName)
{
  return DeleteFileW(lpFileName);
}

//----- (77E2180C) --------------------------------------------------------
BOOL __stdcall GetFileTimeStub(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
{
  return GetFileTime(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
}

//----- (77E21AB4) --------------------------------------------------------
NTSTATUS __stdcall InitSecurityAcls(PSECURITY_DESCRIPTOR *a1)
{
  NTSTATUS v1; // esi@1
  ULONG v2; // eax@3
  ULONG v3; // esi@3
  PVOID v4; // eax@3
  PSID Sid; // [sp+Ch] [bp-20h]@1
  PSID v7; // [sp+10h] [bp-1Ch]@1
  PACL Acl; // [sp+14h] [bp-18h]@3
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [sp+18h] [bp-14h]@1
  struct _SID_IDENTIFIER_AUTHORITY v10; // [sp+20h] [bp-Ch]@1

  v10.Value[0] = 0;
  v10.Value[1] = 0;
  v10.Value[2] = 0;
  v10.Value[3] = 0;
  v10.Value[4] = 0;
  v10.Value[5] = 5;
  IdentifierAuthority.Value[0] = 0;
  IdentifierAuthority.Value[1] = 0;
  IdentifierAuthority.Value[2] = 0;
  IdentifierAuthority.Value[3] = 0;
  IdentifierAuthority.Value[4] = 0;
  IdentifierAuthority.Value[5] = 1;
  v7 = 0;
  Sid = 0;
  *a1 = 0;
  v1 = RtlAllocateAndInitializeSid(&IdentifierAuthority, 1, 0, 0, 0, 0, 0, 0, 0, 0, &Sid);
  if ( v1 >= 0 )
  {
    v1 = RtlAllocateAndInitializeSid(&v10, 2, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &v7);
    if ( v1 >= 0 )
    {
      Acl = (PACL)RtlLengthSid(Sid);
      v2 = RtlLengthSid(v7);
      v3 = (ULONG)(&Acl[3].AclRevision + v2);
      v4 = RtlAllocateHeap(
             NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
             0,
             (ULONG)((char *)&Acl[5].AceCount + v2));
      *a1 = v4;
      if ( v4 )
      {
        Acl = (PACL)((char *)v4 + 20);
        v1 = RtlCreateAcl((PACL)((char *)v4 + 20), v3, 2u);
        if ( v1 >= 0 )
        {
          v1 = RtlAddAccessAllowedAce(Acl, 2u, 0x3003Fu, Sid);
          if ( v1 >= 0 )
          {
            v1 = RtlAddAccessAllowedAce(Acl, 2u, 0x10000000u, v7);
            if ( v1 >= 0 )
            {
              v1 = RtlCreateSecurityDescriptor(*a1, 1u);
              if ( v1 >= 0 )
                v1 = RtlSetDaclSecurityDescriptor(*a1, 1u, Acl, 0);
            }
          }
        }
      }
      else
      {
        v1 = -1073741670;
      }
    }
  }
  if ( Sid )
    RtlFreeSid(Sid);
  if ( v7 )
    RtlFreeSid(v7);
  return v1;
}

//----- (77E21C1A) --------------------------------------------------------
ULONG __stdcall LocalOpenClassesRoot(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  return OpenClassesRootInternal(a1, DesiredAccess, KeyHandle, 0);
}

//----- (77E21C38) --------------------------------------------------------
ULONG __stdcall OpenClassesRootInternal(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle, int a4)
{
  int (__stdcall *v4)(_DWORD, _DWORD); // eax@1
  NTSTATUS v5; // ebx@2
  NTSTATUS v6; // eax@7
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-1Ch]@6
  PVOID Address; // [sp+24h] [bp-4h]@1

  Address = 0;
  v4 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 28);
  if ( v4 )
  {
    v5 = v4(DesiredAccess, KeyHandle);
  }
  else
  {
    v5 = DesiredAccess;
    *KeyHandle = 0;
  }
  if ( !*KeyHandle )
  {
    v5 = InitSecurityAcls(&Address);
    if ( v5 >= 0 )
    {
      v5 = OpenCombinedClassesRoot(DesiredAccess, KeyHandle, a4);
      if ( v5 < 0 )
      {
        ObjectAttributes.SecurityDescriptor = Address;
        ObjectAttributes.Length = 24;
        ObjectAttributes.RootDirectory = 0;
        ObjectAttributes.Attributes = 64;
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&ClassesStringKey;
        ObjectAttributes.SecurityQualityOfService = 0;
        if ( a4 )
          v6 = NtCreateKeyTransacted(KeyHandle, DesiredAccess, &ObjectAttributes, 0, 0, 0, a4, 0);
        else
          v6 = NtCreateKey(KeyHandle, DesiredAccess, &ObjectAttributes, 0, 0, 0, 0);
        v5 = v6;
      }
    }
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return RtlNtStatusToDosError(v5);
}
// 77DE13EC: using guessed type int __stdcall NtCreateKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E21CEC: using guessed type int ClassesStringKey;

//----- (77E21CF9) --------------------------------------------------------
int __stdcall OpenCombinedClassesRoot(ACCESS_MASK DesiredAccess, PHANDLE KeyHandle, int a3)
{
  int result; // eax@1
  NTSTATUS v4; // eax@4
  int v5; // ebx@5
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-28h]@3
  UNICODE_STRING SourceString; // [sp+1Ch] [bp-10h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-8h]@2

  result = RtlFormatCurrentUserKeyPath(&SourceString);
  if ( result >= 0 )
  {
    DestinationString.MaximumLength = SourceString.MaximumLength + 18;
    DestinationString.Buffer = (PWCH)RtlAllocateHeap(
                                       NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                       0,
                                       (unsigned __int16)(SourceString.MaximumLength + 18));
    if ( DestinationString.Buffer )
    {
      RtlCopyUnicodeString(&DestinationString, &SourceString);
      RtlAppendUnicodeToString(&DestinationString, L"_Classes");
      ObjectAttributes.ObjectName = &DestinationString;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( a3 )
        v4 = NtOpenKeyTransacted(KeyHandle, DesiredAccess, &ObjectAttributes, a3);
      else
        v4 = NtOpenKey(KeyHandle, DesiredAccess, &ObjectAttributes);
      v5 = v4;
      RtlFreeUnicodeString(&DestinationString);
      RtlFreeUnicodeString(&SourceString);
      if ( v5 >= 0 )
        *KeyHandle = (HANDLE)((unsigned int)*KeyHandle | 2);
      result = v5;
    }
    else
    {
      RtlFreeUnicodeString(&SourceString);
      result = -1073741670;
    }
  }
  return result;
}
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);
// 77DE1694: using guessed type int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E21EE2) --------------------------------------------------------
signed int __stdcall WerpAcquirePebLock()
{
  signed int v1; // [sp+10h] [bp-20h]@1
  signed int i; // [sp+14h] [bp-1Ch]@1

  v1 = -2147467259;
  for ( i = 0; i < 4; ++i )
  {
    if ( RtlTryAcquirePebLock() )
      return 0;
    Sleep(0xFAu);
  }
  return v1;
}
// 77DE16E0: using guessed type _DWORD __stdcall RtlTryAcquirePebLock();

//----- (77E21F49) --------------------------------------------------------
struct _PEB *__stdcall WerpCurrentPeb()
{
  return NtCurrentTeb()->ProcessEnvironmentBlock;
}

//----- (77E21FB5) --------------------------------------------------------
int __stdcall WerpValidatePebHeader(struct _WER_PEB_HEADER_BLOCK *a1)
{
  int result; // eax@2

  if ( a1 )
  {
    result = wcsncmp((const wchar_t *)a1 + 2, L"PEB_SIGNATURE", 0xEu) != 0 ? 0x80004005 : 0;
  }
  else
  {
    DbgPrintOut(0, "Invalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E2204B) --------------------------------------------------------
signed int __stdcall WerpInitPEBStore()
{
  struct _PEB *v0; // edi@1
  int v1; // edi@3
  LPVOID v3; // esi@9
  void *v4; // eax@21
  struct _PEB *v5; // [sp+10h] [bp-20h]@1
  signed int v6; // [sp+14h] [bp-1Ch]@1

  v6 = -2147467259;
  v0 = WerpCurrentPeb();
  v5 = v0;
  if ( !v0 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  v1 = (int)&v0[1].Reserved9[8];
  if ( !*(_DWORD *)v1 )
  {
    v3 = VirtualAlloc(0, 0x8D0u, 0x3000u, 4u);
    *(_DWORD *)v1 = v3;
    if ( !v3 )
    {
      DbgPrintOut(0, "VirtualAlloc failed");
      v6 = -2147024882;
      goto LABEL_7;
    }
    if ( !*((_WORD *)v3 + 1092) && WerpHeapCreate((struct _WER_HEAP_MAIN_HEADER *)((char *)v3 + 2184)) < 0 )
    {
      DbgPrintOut(0, "WerpHeapInitialize failed");
      goto LABEL_7;
    }
    if ( StringCchCopyW((unsigned __int16 *)v3 + 2, 0xEu, L"PEB_SIGNATURE") < 0 )
    {
      DbgPrintOut(0, "Could not set the peb signature");
      goto LABEL_7;
    }
    *(_DWORD *)v3 = 2256;
  }
  v6 = 0;
LABEL_7:
  if ( v6 < 0 )
  {
    v4 = v5[1].Reserved9[8];
    if ( v4 )
    {
      VirtualFree(v4, 0, 0x8000u);
      v5[1].Reserved9[8] = 0;
    }
  }
  RtlReleasePebLock();
  return v6;
}

//----- (77E220E6) --------------------------------------------------------
int __stdcall WerpCheckOkToRegister()
{
  struct _PEB *v0; // esi@1
  signed int v1; // eax@3
  PVOID v2; // esi@3
  int result; // eax@7
  signed int v4; // [sp+10h] [bp-1Ch]@6

  v0 = WerpCurrentPeb();
  if ( v0 )
  {
    if ( WerpAcquirePebLock() >= 0 )
    {
      v1 = 1;
      v2 = v0[1].Reserved9[8];
      if ( v2 )
      {
        if ( WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v2) < 0 )
        {
          DbgPrintOut(0, "WerpValidatePebHeader failed");
          v4 = 0;
          goto LABEL_7;
        }
        v1 = *((_DWORD *)v2 + 534) == 0;
      }
      v4 = v1;
LABEL_7:
      RtlReleasePebLock();
      return v4;
    }
    DbgPrintOut(0, "WerpAcquirePebLock failed");
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E2218D) --------------------------------------------------------
signed int __stdcall WerpRegisterMemoryBlock(PVOID pvAddress, DWORD dwSize)
{
  int v2; // esi@1
  int v3; // eax@7
  signed int result; // eax@12
  struct _WER_HEAP_MAIN_HEADER *v5; // [sp+14h] [bp-20h]@6
  signed int v6; // [sp+18h] [bp-1Ch]@8

  v2 = 0;
  if ( !pvAddress || !dwSize )
  {
    DbgPrintOut(0, "Invalid args passed");
    return -2147024809;
  }
  if ( dwSize > 0x10000 )
  {
    DbgPrintOut(0, "Invalid args, too  big block");
    return -2147024809;
  }
  if ( WerpCheckOkToRegister() )
  {
    if ( WerpInitPEBStore() < 0 )
    {
      DbgPrintOut(0, "WerpInitPEBStore failed");
      result = -2147467259;
    }
    else
    {
      WerpUnregisterMemoryBlock(pvAddress);
      v5 = (struct _WER_HEAP_MAIN_HEADER *)WerpGetHeapHandle();
      if ( v5 )
      {
        v3 = WerpHeapAlloc(v5, 0x30u);
        v2 = v3;
        if ( v3 )
        {
          memset((void *)v3, 0, 0x30u);
          *(_DWORD *)(v2 + 8) = 1;
          *(_QWORD *)(v2 + 24) = (signed int)pvAddress;
          *(_DWORD *)(v2 + 32) = dwSize;
          *(_DWORD *)(v2 + 40) = 0;
          *(_DWORD *)(v2 + 12) = 48;
          v6 = WerpAddGatherToPEB((struct _WER_GATHER *)v2);
        }
        else
        {
          DbgPrintOut(0, "OOM");
          v6 = -2147024882;
        }
      }
      else
      {
        DbgPrintOut(0, "WerpGetHeapHandle returned NULL");
        v6 = -2147467259;
      }
      if ( v6 < 0 )
      {
        if ( v2 )
          WerpHeapFree(v5, (void *)v2);
      }
      result = v6;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid state");
    result = -2147019873;
  }
  return result;
}

//----- (77E22281) --------------------------------------------------------
HRESULT __stdcall WerRegisterMemoryBlock(PVOID pvAddress, DWORD dwSize)
{
  return WerpRegisterMemoryBlock(pvAddress, dwSize);
}

//----- (77E2229D) --------------------------------------------------------
int __stdcall WerpValidateHeapSignature(struct _WER_HEAP_MAIN_HEADER *a1)
{
  struct _WER_HEAP_MAIN_HEADER *v1; // eax@1
  int v2; // ecx@2
  bool v3; // cf@3
  unsigned __int16 v4; // dx@5
  int v5; // eax@7
  int result; // eax@8

  v1 = a1;
  if ( a1 )
  {
    v2 = (int)L"HEAP_SIGNATURE";
    while ( 1 )
    {
      v3 = *(_WORD *)v1 < *(_WORD *)v2;
      if ( *(_WORD *)v1 != *(_WORD *)v2 )
        break;
      if ( !*(_WORD *)v1 )
        goto LABEL_7;
      v4 = *((_WORD *)v1 + 1);
      v3 = v4 < *(_WORD *)(v2 + 2);
      if ( v4 != *(_WORD *)(v2 + 2) )
        break;
      v1 = (struct _WER_HEAP_MAIN_HEADER *)((char *)v1 + 4);
      v2 += 4;
      if ( !v4 )
      {
LABEL_7:
        v5 = 0;
        goto LABEL_8;
      }
    }
    v5 = -v3 - (v3 - 1);
LABEL_8:
    result = v5 != 0 ? 0x80004005 : 0;
  }
  else
  {
    DbgPrintOut((int)a1, "Invalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E22329) --------------------------------------------------------
int __stdcall WerpHeapLock(struct _WER_HEAP_MAIN_HEADER *a1)
{
  int result; // eax@2

  if ( a1 )
  {
    result = WaitForSingleObject(*((HANDLE *)a1 + 12), 0xFA0u) == 0;
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}

//----- (77E22354) --------------------------------------------------------
int __stdcall WerpHeapUnLock(struct _WER_HEAP_MAIN_HEADER *a1)
{
  int result; // eax@2

  if ( a1 )
  {
    result = ReleaseMutex(*((HANDLE *)a1 + 12));
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}

//----- (77E22375) --------------------------------------------------------
signed int __stdcall _FindMemBlockByAddress(void *a1, struct _WER_GATHER **a2, struct _WER_GATHER **a3)
{
  struct _PEB *v3; // eax@2
  PVOID v4; // esi@2
  int v5; // ecx@4
  struct _WER_GATHER *v6; // esi@4
  signed int result; // eax@13
  signed int v8; // [sp+14h] [bp-1Ch]@1

  v8 = -2147467259;
  if ( a2 )
  {
    v3 = WerpCurrentPeb();
    v4 = v3[1].Reserved9[8];
    if ( v4 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v3[1].Reserved9[8]) >= 0 )
    {
      v5 = *((_DWORD *)v4 + 538);
      v6 = 0;
      while ( 1 )
      {
        if ( !v5 )
          goto LABEL_12;
        if ( *(_DWORD *)(v5 + 8) == 1 && *(_QWORD *)(v5 + 24) == (signed int)a1 )
          break;
        v6 = (struct _WER_GATHER *)v5;
        v5 = *(_DWORD *)v5;
      }
      if ( a3 )
        *a3 = v6;
      *a2 = (struct _WER_GATHER *)v5;
      v8 = 0;
      if ( !v5 )
      {
LABEL_12:
        v8 = -2147023728;
        goto LABEL_13;
      }
    }
    else
    {
      DbgPrintOut(0, "PEB is not initialized");
    }
LABEL_13:
    result = v8;
  }
  else
  {
    DbgPrintOut(0, "_FindMemBlockByAddressInvalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E22443) --------------------------------------------------------
int __stdcall WerpGetHeapHandle()
{
  struct _PEB *v0; // esi@1
  PVOID v1; // esi@3
  int v3; // [sp+10h] [bp-1Ch]@1

  v3 = 0;
  v0 = WerpCurrentPeb();
  if ( !v0 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return 0;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return 0;
  }
  v1 = v0[1].Reserved9[8];
  if ( v1 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v1) >= 0 )
  {
    v3 = (int)((char *)v1 + 2184);
    if ( WerpValidateHeapSignature((struct _WER_HEAP_MAIN_HEADER *)((char *)v1 + 2184)) < 0 )
    {
      DbgPrintOut(0, "Invalid Heap");
      v3 = 0;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid PEB entry");
  }
  RtlReleasePebLock();
  return v3;
}

//----- (77E224ED) --------------------------------------------------------
signed int __stdcall WerpUnregisterMemoryBlock(PVOID pvAddress)
{
  struct _PEB *v1; // esi@3
  struct _WER_PEB_HEADER_BLOCK *v2; // esi@5
  struct _WER_GATHER *v4; // [sp+10h] [bp-24h]@1
  struct _WER_GATHER *v5; // [sp+14h] [bp-20h]@1
  int v6; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@5

  v4 = 0;
  v5 = 0;
  v6 = -2147023728;
  if ( !pvAddress )
  {
    DbgPrintOut(0, "Invalid args in %s", "WerpUnregisterMemoryBlock");
    return -2147024809;
  }
  if ( !WerpCheckOkToRegister() )
  {
    DbgPrintOut(0, "Invalid state");
    return -2147019873;
  }
  v1 = WerpCurrentPeb();
  if ( !v1 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  ms_exc.registration.TryLevel = 0;
  v2 = (struct _WER_PEB_HEADER_BLOCK *)v1[1].Reserved9[8];
  if ( v2 && WerpValidatePebHeader(v2) >= 0 )
  {
    v6 = _FindMemBlockByAddress(pvAddress, &v4, &v5);
    if ( !v6 )
      v6 = _DeleteElement(v2, v4, v5);
  }
  else
  {
    DbgPrintOut(0, "PEB is not initialized");
  }
  ms_exc.registration.TryLevel = -2;
  RtlReleasePebLock();
  return v6;
}

//----- (77E225ED) --------------------------------------------------------
__int32 __stdcall WerpHeapAddBlockToTail(struct _WER_HEAP_MAIN_HEADER *a1, struct _WER_HEAP_BLOCK_HEADER *a2)
{
  *((_DWORD *)a2 + 1) = 0;
  *(_DWORD *)a2 = *((_DWORD *)a1 + 10);
  if ( !*((_QWORD *)a1 + 4) )
  {
    *((_DWORD *)a1 + 8) = a2;
    *((_DWORD *)a1 + 9) = 0;
  }
  if ( *((_QWORD *)a1 + 5) )
    *(_DWORD *)(*((_DWORD *)a1 + 10) + 4) = a2;
  *((_DWORD *)a1 + 10) = a2;
  *((_DWORD *)a1 + 11) = 0;
  return 0;
}

//----- (77E2262F) --------------------------------------------------------
signed int __stdcall WerpAddGatherToPEB(struct _WER_GATHER *a1)
{
  struct _PEB *v1; // ebx@2
  PVOID v2; // edi@4
  int v3; // eax@8
  int v4; // eax@10
  signed int result; // eax@11
  signed int v6; // [sp+10h] [bp-1Ch]@1

  v6 = -2147467259;
  if ( a1 )
  {
    v1 = WerpCurrentPeb();
    if ( v1 )
    {
      if ( WerpAcquirePebLock() >= 0 )
      {
        v2 = v1[1].Reserved9[8];
        if ( !v2 || WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v1[1].Reserved9[8]) < 0 )
        {
          DbgPrintOut(0, "Invalid PEB entry");
          goto LABEL_11;
        }
        if ( *((_DWORD *)v2 + 544) >= 0x200u )
        {
          v6 = -2147024774;
          goto LABEL_11;
        }
        if ( *((_DWORD *)a1 + 2) == 1 )
        {
          v3 = (int)((char *)v2 + 2172);
        }
        else
        {
          if ( *((_DWORD *)a1 + 2) != 2 )
            goto LABEL_10;
          v3 = (int)((char *)v2 + 2168);
        }
        *((_DWORD *)a1 + 4) = InterlockedIncrement((volatile LONG *)v3);
LABEL_10:
        v4 = (int)((char *)v2 + 2152);
        *(_DWORD *)a1 = *((_DWORD *)v2 + 538);
        *((_DWORD *)a1 + 1) = *((_DWORD *)v2 + 539);
        *(_DWORD *)v4 = a1;
        *(_DWORD *)(v4 + 4) = 0;
        InterlockedIncrement((volatile LONG *)v2 + 544);
        v6 = 0;
LABEL_11:
        RtlReleasePebLock();
        return v6;
      }
      DbgPrintOut(0, "Unable to get the peb lock");
    }
    else
    {
      DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    }
    result = -2147467259;
  }
  else
  {
    DbgPrintOut(0, "Invalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E2271D) --------------------------------------------------------
int __stdcall WerpHeapAlloc(struct _WER_HEAP_MAIN_HEADER *a1, unsigned __int32 a2)
{
  LPVOID v2; // esi@1
  unsigned __int32 v3; // edi@4
  unsigned int v4; // eax@8
  struct _SYSTEM_INFO SystemInfo; // [sp+10h] [bp-54h]@3
  char *v7; // [sp+34h] [bp-30h]@1
  int v8; // [sp+38h] [bp-2Ch]@1
  int v9; // [sp+3Ch] [bp-28h]@1
  DWORD v10; // [sp+40h] [bp-24h]@3
  int v11; // [sp+44h] [bp-20h]@1
  LPVOID v12; // [sp+48h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@5

  v2 = 0;
  v11 = 0;
  v12 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  if ( !a1 || !a2 )
  {
    DbgPrintOut(0, "Invalid arguments");
    SetLastError(0x57u);
    return 0;
  }
  memset(&SystemInfo, 0, sizeof(SystemInfo));
  GetSystemInfo(&SystemInfo);
  v10 = SystemInfo.dwPageSize;
  if ( !SystemInfo.dwPageSize )
  {
    DbgPrintOut(0, "Invalid page size, GetSystemInfo  may have failed");
    return 0;
  }
  v3 = (a2 + 39) & 0xFFFFFFF8;
  if ( !WerpHeapLock(a1) )
  {
    DbgPrintOut(0, "Failed to lock the heap");
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( *((_QWORD *)a1 + 7) )
  {
    if ( *((_QWORD *)a1 + 8) )
    {
      v2 = (LPVOID)WerpHeapGetBlockFromFreeList(a1, v3 - 32);
      v12 = v2;
      v9 = v2 != 0;
    }
    if ( !v2 )
    {
      v4 = v10 - *((_DWORD *)a1 + 14) % v10;
      if ( v4 < v3 || v4 == v10 )
      {
        v11 = 1;
      }
      else
      {
        v2 = (LPVOID)*((_DWORD *)a1 + 14);
        v12 = (LPVOID)*((_DWORD *)a1 + 14);
      }
    }
    if ( !v11 )
      goto LABEL_12;
  }
  else
  {
    v11 = 1;
  }
  v2 = VirtualAlloc(0, v3, 0x3000u, 4u);
  v12 = v2;
  if ( v2 )
  {
LABEL_12:
    if ( !v9 )
    {
      *((_QWORD *)a1 + 7) = (signed int)((char *)v2 + v3);
      *((_DWORD *)v2 + 4) = v3 - 32;
      *((_DWORD *)v2 + 5) = 0;
    }
    *((_DWORD *)v2 + 2) = (char *)v2 + 32;
    v7 = (char *)v2 + 32;
    *((_DWORD *)v2 + 6) = 1;
    WerpHeapAddBlockToTail(a1, (struct _WER_HEAP_BLOCK_HEADER *)v2);
    v8 = 1;
  }
  ms_exc.registration.TryLevel = -2;
  WerpHeapUnLock(a1);
  if ( !v8 && v2 )
  {
    if ( v11 )
      VirtualFree(v2, 0, 0x8000u);
  }
  return (int)v7;
}

//----- (77E2285A) --------------------------------------------------------
signed int __stdcall StringCchCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3)
{
  signed int result; // eax@1
  unsigned __int16 *v4; // eax@4
  signed int v5; // ebx@4
  unsigned int v6; // esi@4
  unsigned __int16 v7; // cx@6

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = a1;
    v5 = 0;
    v6 = a2;
    if ( !a2 )
      goto LABEL_15;
    do
    {
      if ( !(2147483646 - a2 + v6) )
        break;
      v7 = *(unsigned __int16 *)((char *)v4 + (char *)a3 - (char *)a1);
      if ( !v7 )
        break;
      *v4 = v7;
      ++v4;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_15:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (77E22927) --------------------------------------------------------
signed int __stdcall WerpHeapCreate(struct _WER_HEAP_MAIN_HEADER *Dst)
{
  HANDLE v1; // eax@2

  memset((void *)Dst, 0, 0x48u);
  *((_DWORD *)Dst + 8) = 0;
  *((_DWORD *)Dst + 9) = 0;
  *((_DWORD *)Dst + 10) = 0;
  *((_DWORD *)Dst + 11) = 0;
  if ( StringCchCopyW((unsigned __int16 *)Dst, 0xFu, L"HEAP_SIGNATURE") < 0 )
  {
    DbgPrintOut(0, "Could not set heap signature");
  }
  else
  {
    v1 = CreateMutexW(0, 0, 0);
    *((_QWORD *)Dst + 6) = (signed int)v1;
    if ( v1 )
      return 0;
  }
  return -2147467259;
}

//----- (77E22A08) --------------------------------------------------------
void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
{
  LPMEMORYSTATUS v1; // esi@1
  unsigned int v2; // ecx@1
  unsigned int v3; // eax@2
  unsigned __int64 v4; // rax@4
  unsigned __int64 v5; // rax@6
  unsigned int v6; // ecx@9
  unsigned __int64 v7; // rax@10
  unsigned int v8; // eax@13
  int v9; // edx@14
  unsigned __int64 v10; // rax@16
  int v11; // ecx@18
  PIMAGE_NT_HEADERS v12; // eax@18
  unsigned int v13; // ecx@20
  char Dst; // [sp+8h] [bp-6Ch]@9
  int v15; // [sp+Ch] [bp-68h]@18
  unsigned int v16; // [sp+2Ch] [bp-48h]@13
  char ProcessInformation; // [sp+34h] [bp-40h]@9
  unsigned int v18; // [sp+44h] [bp-30h]@9
  unsigned int SystemInformation; // [sp+54h] [bp-20h]@1
  unsigned int v20; // [sp+58h] [bp-1Ch]@12
  unsigned int v21; // [sp+5Ch] [bp-18h]@9
  int v22; // [sp+68h] [bp-Ch]@11
  SIZE_T *v23; // [sp+70h] [bp-4h]@5
  LPMEMORYSTATUS lpBuffera; // [sp+7Ch] [bp+8h]@6

  NtQuerySystemInformation(
    SystemExceptionInformation|SystemProcessorPerformanceInformation|SystemPerformanceInformation|0x50,
    &SystemInformation,
    0x10u,
    0);
  v1 = lpBuffer;
  lpBuffer->dwLength = 32;
  v2 = v7FFE02E8;
  if ( SystemInformation > v7FFE02E8 )
    SystemInformation = v7FFE02E8;
  v3 = 100;
  if ( SystemInformation >= 0x64 )
    v3 = 100 * (v7FFE02E8 - SystemInformation) / v7FFE02E8;
  lpBuffer->dwMemoryLoad = v3;
  v4 = v2 * (unsigned __int64)*(_DWORD *)(BaseStaticServerData + 300);
  if ( v4 >= 0xFFFFFFFF )
  {
    LODWORD(v4) = -1;
    v23 = 0;
  }
  else
  {
    v23 = (SIZE_T *)HIDWORD(v4);
  }
  lpBuffer->dwTotalPhys = v4;
  v5 = SystemInformation * (unsigned __int64)*(_DWORD *)(BaseStaticServerData + 300);
  lpBuffera = (LPMEMORYSTATUS)((char *)lpBuffer + 8);
  if ( v5 >= 0xFFFFFFFF )
  {
    LODWORD(v5) = -1;
    v23 = 0;
  }
  else
  {
    v23 = (SIZE_T *)HIDWORD(v5);
  }
  v1->dwAvailPhys = v5;
  v23 = &v1->dwAvailPhys;
  if ( gpTermsrvAdjustPhyMemLimits )
    gpTermsrvAdjustPhyMemLimits(&v1->dwTotalPhys, &v1->dwAvailPhys, *(_DWORD *)(BaseStaticServerData + 300));
  memset(&ProcessInformation, 0, 0x20u);
  memset(&Dst, 0, 0x2Cu);
  NtQueryInformationProcess((HANDLE)0xFFFFFFFF, ProcessQuotaLimits, &ProcessInformation, 0x20u, 0);
  NtQueryInformationProcess((HANDLE)0xFFFFFFFF, ProcessVmCounters, &Dst, 0x2Cu, 0);
  v6 = v21;
  if ( v21 >= v18 )
    v6 = v18;
  v7 = v6 * (unsigned __int64)*(_DWORD *)(BaseStaticServerData + 300);
  if ( HIDWORD(v7) > 0 || (unsigned int)v7 >= 0xFFFFFFFF )
  {
    LODWORD(v7) = -1;
    v22 = 0;
  }
  else
  {
    v22 = HIDWORD(v7);
  }
  v1->dwTotalPageFile = v7;
  if ( v21 < v20 )
    v21 = v20;
  v8 = v16 / *(_DWORD *)(BaseStaticServerData + 300);
  v16 = v8;
  if ( v18 < v8 )
    v18 = v8;
  v9 = v18 - v8;
  if ( v21 - v20 < v18 - v8 )
    v9 = v21 - v20;
  v10 = (unsigned int)v9 * (unsigned __int64)*(_DWORD *)(BaseStaticServerData + 300);
  if ( HIDWORD(v10) > 0 || (unsigned int)v10 >= 0xFFFFFFFF )
  {
    LODWORD(v10) = -1;
    v22 = 0;
  }
  else
  {
    v22 = HIDWORD(v10);
  }
  v1->dwAvailPageFile = v10;
  v11 = *(_DWORD *)(BaseStaticServerData + 324) - *(_DWORD *)(BaseStaticServerData + 320);
  v1->dwTotalVirtual = v11 + 1;
  v1->dwAvailVirtual = v11 + 1 - v15;
  v12 = RtlImageNtHeader(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved3[1]);
  if ( v12 && !(v12->FileHeader.Characteristics & 0x20) )
  {
    v13 = *(_DWORD *)(BaseStaticServerData + 324);
    if ( v13 > 0x7FFEFFFF )
    {
      v1->dwTotalVirtual += 2147418111 - v13;
      v1->dwAvailVirtual += 2147418111 - *(_DWORD *)(BaseStaticServerData + 324);
    }
    if ( lpBuffera->dwLength > 0x7FFFFFFF )
      lpBuffera->dwLength = 0x7FFFFFFF;
    if ( *v23 > 0x7FFFFFFF )
      *v23 = 0x7FFFFFFF;
  }
}
// 77EA6094: using guessed type int BaseStaticServerData;
// 77EA67F0: using guessed type int (__stdcall *gpTermsrvAdjustPhyMemLimits)(_DWORD, _DWORD, _DWORD);

//----- (77E22BE5) --------------------------------------------------------
int __stdcall lstrcmpiAStub(LPCSTR lpString1, LPCSTR lpString2)
{
  return lstrcmpiA(lpString1, lpString2);
}

//----- (77E22BF2) --------------------------------------------------------
int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = CompareStringA(0x400u, 0x40000001u, lpString1, -1, lpString2, -1);
  if ( v2 || (v2 = CompareStringA(0x800u, 0x40000001u, lpString1, -1, lpString2, -1)) != 0 )
  {
    result = v2 - 2;
  }
  else if ( lpString1 )
  {
    if ( lpString2 )
      result = __stricmp(lpString1, lpString2);
    else
      result = 1;
  }
  else
  {
    result = -(lpString2 != 0);
  }
  return result;
}

//----- (77E22C2A) --------------------------------------------------------
BOOL __stdcall QueryPerformanceFrequencyStub(LARGE_INTEGER *lpFrequency)
{
  return QueryPerformanceFrequency(lpFrequency);
}

//----- (77E22C5B) --------------------------------------------------------
LCID __stdcall LocaleNameToLCIDStub(LPCWSTR lpName, DWORD dwFlags)
{
  return LocaleNameToLCID(lpName, dwFlags);
}

//----- (77E22C73) --------------------------------------------------------
BOOL __stdcall GetThreadPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
{
  return GetThreadPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
}

//----- (77E22C9D) --------------------------------------------------------
BOOL __stdcall HeapDestroyStub(HANDLE hHeap)
{
  return HeapDestroy(hHeap);
}

//----- (77E22CB5) --------------------------------------------------------
BOOL __stdcall SetEndOfFileStub(HANDLE hFile)
{
  return SetEndOfFile(hFile);
}

//----- (77E22CCD) --------------------------------------------------------
BOOL __stdcall TerminateProcessStub(HANDLE hProcess, UINT uExitCode)
{
  return TerminateProcess(hProcess, uExitCode);
}

//----- (77E22CDD) --------------------------------------------------------
BOOL __stdcall VirtualProtectStub(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
{
  return VirtualProtect(lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

//----- (77E22CED) --------------------------------------------------------
BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
{
  NTSTATUS v3; // eax@1
  ULONG_PTR v4; // eax@2
  BOOL result; // eax@2
  struct _SYSTEM_INFO SystemInfo; // [sp+0h] [bp-3Ch]@2
  char ProcessInformation; // [sp+24h] [bp-18h]@1
  ULONG_PTR v8; // [sp+2Ch] [bp-10h]@2

  v3 = NtQueryInformationProcess(hProcess, 0, &ProcessInformation, 0x18u, 0);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    GetSystemInfo(&SystemInfo);
    v4 = v8;
    *lpProcessAffinityMask = v8;
    *lpSystemAffinityMask = v4 != 0 ? SystemInfo.dwActiveProcessorMask : 0;
    result = 1;
  }
  return result;
}

//----- (77E22D62) --------------------------------------------------------
BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
{
  BOOL v3; // esi@1
  NTSTATUS v4; // eax@1

  v3 = 1;
  v4 = NtFlushInstructionCache(hProcess, (PVOID)lpBaseAddress, dwSize);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    v3 = 0;
  }
  return v3;
}

//----- (77E22D8E) --------------------------------------------------------
BOOL __stdcall QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
{
  signed int v7; // esi@1
  DWORD v8; // edx@3
  unsigned int v9; // edx@6
  int v10; // eax@10
  NTSTATUS v11; // eax@12
  signed int v13; // [sp-4h] [bp-10h]@22
  BOOL v14; // [sp+8h] [bp-4h]@1

  v7 = 0;
  v14 = 0;
  if ( pcbWrittenOrRequired )
    *pcbWrittenOrRequired = 0;
  v8 = dwFlags;
  switch ( dwFlags & 3 )
  {
    case 1u:
      v8 = dwFlags | 4;
      break;
    case 2u:
      v8 = dwFlags | 8;
      break;
    case 3u:
      v8 = dwFlags | 0x10;
      break;
  }
  v9 = v8 & 0xFFFFFFFC;
  if ( v9 & 0x7FFFFFE3 )
    goto LABEL_38;
  if ( !ulInfoClass )
    goto LABEL_31;
  if ( ulInfoClass > 2 )
  {
    if ( ulInfoClass <= 4 )
    {
      if ( pvSubInstance )
        goto LABEL_9;
LABEL_29:
      BaseSetLastNTError(-1073741583);
      return v14;
    }
    if ( ulInfoClass <= 6 )
    {
      if ( !pvSubInstance )
        goto LABEL_9;
      goto LABEL_29;
    }
LABEL_31:
    BaseSetLastNTError(-1073741584);
    return v14;
  }
LABEL_9:
  if ( !pvBuffer )
  {
    if ( cbBuffer )
    {
      BaseSetLastNTError(-1073741582);
      return v14;
    }
    if ( !pcbWrittenOrRequired )
    {
      BaseSetLastNTError(-1073741581);
      return v14;
    }
  }
  v10 = v9 & 0x1C;
  if ( v9 & 0x1C )
  {
    if ( v10 == 4 )
    {
      v7 = 1;
      goto LABEL_11;
    }
    if ( v10 == 8 )
    {
      v13 = 2;
      goto LABEL_23;
    }
    if ( v10 == 16 )
    {
      v13 = 4;
LABEL_23:
      v7 = v13;
      goto LABEL_11;
    }
LABEL_38:
    BaseSetLastNTError(-1073741585);
    return v14;
  }
LABEL_11:
  if ( v9 & 0x80000000 )
    v7 |= 0x80000000;
  v11 = RtlQueryInformationActivationContext(
          v7,
          hActCtx,
          pvSubInstance,
          ulInfoClass,
          pvBuffer,
          cbBuffer,
          pcbWrittenOrRequired);
  if ( v11 >= 0 )
    v14 = 1;
  else
    BaseSetLastNTError(v11);
  return v14;
}
// 77DE117C: using guessed type int __stdcall RtlQueryInformationActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E22EAC) --------------------------------------------------------
BOOL __stdcall SetThreadStackGuaranteeStub(PULONG StackSizeInBytes)
{
  return SetThreadStackGuarantee(StackSizeInBytes);
}

//----- (77E22EC4) --------------------------------------------------------
HANDLE __stdcall CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
{
  const WCHAR *v1; // eax@2
  NTSTATUS v2; // eax@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-20h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+1Ch] [bp-8h]@3

  if ( NotificationType )
  {
    if ( NotificationType != 1 )
    {
      RtlSetLastWin32Error(87);
      return 0;
    }
    v1 = L"\\KernelObjects\\HighMemoryCondition";
  }
  else
  {
    v1 = L"\\KernelObjects\\LowMemoryCondition";
  }
  RtlInitUnicodeString(&DestinationString, v1);
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v2 = NtOpenEvent((PHANDLE)&NotificationType, 0x100001u, &ObjectAttributes);
  if ( v2 >= 0 )
    return (HANDLE)NotificationType;
  BaseSetLastNTError(v2);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E54E50: using guessed type wchar_t BasepMmHighMemoryConditionEventName[35];

//----- (77E22F75) --------------------------------------------------------
BOOL __stdcall HeapValidateStub(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
{
  return HeapValidate(hHeap, dwFlags, lpMem);
}

//----- (77E22F8D) --------------------------------------------------------
BOOL __stdcall SetThreadLocaleStub(LCID Locale)
{
  return SetThreadLocale(Locale);
}

//----- (77E22FA5) --------------------------------------------------------
ATOM __stdcall AddAtomW(LPCWSTR lpString)
{
  return InternalAddAtom(1, 1, (PCSZ)lpString);
}

//----- (77E22FBF) --------------------------------------------------------
int __stdcall InternalDeleteAtom(int a1, USHORT Atom)
{
  int v2; // eax@3

  if ( Atom >= 0xC000u )
  {
    if ( (_BYTE)a1 )
    {
      v2 = InternalInitAtomTable((int)&a1);
      if ( v2 < 0 )
        goto LABEL_8;
      v2 = RtlDeleteAtomFromAtomTable(a1, Atom);
    }
    else
    {
      v2 = NtDeleteAtom(Atom);
    }
    if ( v2 >= 0 )
      return 0;
LABEL_8:
    BaseSetLastNTError(v2);
  }
  return 0;
}
// 77DE14C8: using guessed type int __stdcall RtlDeleteAtomFromAtomTable(_DWORD, _DWORD);

//----- (77E23009) --------------------------------------------------------
ATOM __stdcall DeleteAtom(ATOM nAtom)
{
  return InternalDeleteAtom(1, nAtom);
}

//----- (77E23021) --------------------------------------------------------
WORD __stdcall RtlCaptureStackBackTraceStub(DWORD FramesToSkip, DWORD FramesToCapture, PVOID *BackTrace, PDWORD BackTraceHash)
{
  return RtlCaptureStackBackTrace(FramesToSkip, FramesToCapture, BackTrace, BackTraceHash);
}

//----- (77E2318E) --------------------------------------------------------
BOOL __stdcall GetFileAttributesExWStub(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
{
  return GetFileAttributesExW(lpFileName, fInfoLevelId, lpFileInformation);
}

//----- (77E231A6) --------------------------------------------------------
ULONG __stdcall LocalBaseRegCreateKey(int a1, PCUNICODE_STRING Source, int a3, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a6, int a7, int a8, int a9)
{
  void *v9; // eax@38
  USHORT v10; // ax@1
  PWCH v11; // ecx@2
  PUNICODE_STRING v12; // eax@6
  NTSTATUS v13; // edi@16
  int v14; // edi@17
  NTSTATUS v15; // eax@21
  ULONG result; // eax@33
  NTSTATUS i; // eax@53
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-1F4h]@18
  int v19; // [sp+24h] [bp-1DCh]@1
  WCHAR *v20; // [sp+28h] [bp-1D8h]@1
  int v21; // [sp+2Ch] [bp-1D4h]@1
  int v22; // [sp+30h] [bp-1D0h]@1
  int v23; // [sp+34h] [bp-1CCh]@1
  int v24; // [sp+38h] [bp-1C8h]@1
  char *v25; // [sp+3Ch] [bp-1C4h]@1
  int v26; // [sp+40h] [bp-1C0h]@1
  int v27; // [sp+44h] [bp-1BCh]@1
  int v28; // [sp+48h] [bp-1B8h]@1
  ULONG Disposition; // [sp+4Ch] [bp-1B4h]@21
  int v30; // [sp+50h] [bp-1B0h]@1
  int v31; // [sp+54h] [bp-1ACh]@53
  PVOID Address; // [sp+58h] [bp-1A8h]@1
  int v33; // [sp+5Ch] [bp-1A4h]@1
  int v34; // [sp+60h] [bp-1A0h]@11
  PUNICODE_STRING Class; // [sp+64h] [bp-19Ch]@1
  PUNICODE_STRING DestinationString; // [sp+68h] [bp-198h]@1
  PHANDLE KeyHandle; // [sp+6Ch] [bp-194h]@1
  HANDLE v38; // [sp+70h] [bp-190h]@1
  int v39; // [sp+74h] [bp-18Ch]@1
  HANDLE Handle; // [sp+78h] [bp-188h]@1
  char v41; // [sp+7Ch] [bp-184h]@1
  char Dst; // [sp+7Dh] [bp-183h]@1

  v38 = (HANDLE)a1;
  Class = (PUNICODE_STRING)a3;
  v28 = a6;
  KeyHandle = (PHANDLE)a7;
  v26 = a8;
  v39 = a9;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v41 = 0;
  memset(&Dst, 0, 0x17Fu);
  v19 = *(_DWORD *)&Source->Length;
  v20 = Source->Buffer;
  v27 = *(_DWORD *)RegKrnGetGlobalState();
  v33 = 1;
  v30 = 1;
  v10 = Source->Length;
  Address = 0;
  Handle = 0;
  DestinationString = 0;
  if ( v10 >= 2u
    && (v11 = Source->Buffer) != 0
    && !(v10 & 1)
    && !v11[((unsigned int)v10 >> 1) - 1]
    && KeyHandle
    && (v12 = Class) != 0
    && !(Class->Length & 1)
    && (!Class->Length || Class->Buffer) )
  {
    *KeyHandle = 0;
    Source->Length -= 2;
    if ( *Source->Buffer == 92 )
    {
      v13 = -1073741767;
    }
    else
    {
      if ( v12->Length > 0u )
        v12->Length -= 2;
      v34 = 64;
      if ( v28 && *(_BYTE *)(v28 + 16) )
        v34 = 66;
      if ( CreateOptions & 8 )
        v34 |= 0x100u;
      if ( !((unsigned __int8)v38 & 2)
        && (!(*(_BYTE *)(RegKrnGetGlobalState() + 36) & 2) || !ExtractClassKey(&v38, (int)Source, v39)) )
      {
        v21 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        Handle = v38;
        DestinationString = (PUNICODE_STRING)Source;
        goto LABEL_16;
      }
      v21 &= 0xFFFFFFDF;
      v25 = &v41;
      v24 = 384;
      v13 = BaseRegGetKeySemantics(v38, Source, (int)&v21);
      if ( v13 >= 0 )
      {
        for ( i = BaseRegMapClassRegistrationKey(
                    (int)v38,
                    (int)Source,
                    (HANDLE)CreateOptions,
                    (int)&v21,
                    (int)&v31,
                    (int)&v33,
                    &Handle,
                    (int)&DestinationString,
                    v39); ; i = BaseRegMapClassOnAccessDenied((int)&v21, &Handle, DestinationString, (int)&v33, v39) )
        {
          v13 = i;
          if ( i < 0 )
            break;
LABEL_16:
          v13 = -1073741772;
          if ( v30 )
          {
            v14 = v28;
            if ( v28 )
            {
              v9 = *(void **)(v28 + 4);
              if ( v9 )
              {
                if ( !RtlValidRelativeSecurityDescriptor(v9, *(_DWORD *)(v28 + 8), 0) )
                {
                  v13 = -1073741811;
                  break;
                }
              }
            }
            ObjectAttributes.RootDirectory = Handle;
            ObjectAttributes.Attributes = v34;
            ObjectAttributes.Length = 24;
            ObjectAttributes.ObjectName = DestinationString;
            if ( v14 )
              ObjectAttributes.SecurityDescriptor = *(PVOID *)(v14 + 4);
            else
              ObjectAttributes.SecurityDescriptor = 0;
            ObjectAttributes.SecurityQualityOfService = 0;
            if ( v39 )
              v15 = NtCreateKeyTransacted(
                      KeyHandle,
                      DesiredAccess,
                      &ObjectAttributes,
                      0,
                      Class,
                      CreateOptions,
                      v39,
                      &Disposition);
            else
              v15 = NtCreateKey(KeyHandle, DesiredAccess, &ObjectAttributes, 0, Class, CreateOptions, &Disposition);
            v13 = v15;
            if ( v27 && v15 >= 0 && Disposition == 1 )
              ((void (__stdcall *)(HANDLE, OBJECT_ATTRIBUTES *, _DWORD, PUNICODE_STRING, ULONG))v27)(
                *KeyHandle,
                &ObjectAttributes,
                0,
                Class,
                CreateOptions);
          }
          if ( !(*(_BYTE *)(RegKrnGetGlobalState() + 36) & 2) || !v30 || v13 != -1073741790 || !(v21 & 4) || !v33 )
          {
            v30 = 0;
            if ( v13 < 0 )
            {
              v13 = BaseRegCreateMultipartKey(
                      Handle,
                      (int)DestinationString,
                      Class,
                      CreateOptions,
                      DesiredAccess,
                      v28,
                      (int)KeyHandle,
                      v26,
                      v34,
                      v39);
            }
            else if ( v26 )
            {
              *(_DWORD *)v26 = Disposition;
            }
            if ( !(*(_BYTE *)(RegKrnGetGlobalState() + 36) & 2) || v13 != -1073741790 )
            {
              if ( v13 >= 0 && v21 & 4 )
                *KeyHandle = (HANDLE)((unsigned int)*KeyHandle | 2);
              break;
            }
            if ( !(v21 & 4) || !v33 )
              break;
          }
          if ( Address )
          {
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
            Address = 0;
          }
        }
      }
      if ( Handle && Handle != v38 )
        NtClose(Handle);
      if ( Address )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
    BaseRegReleaseKeySemantics((int)&v21);
    *(_DWORD *)&Source->Length = v19;
    Source->Buffer = v20;
    result = RtlNtStatusToDosError(v13);
  }
  else
  {
    result = 87;
  }
  return result;
}
// 77DE13EC: using guessed type int __stdcall NtCreateKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2349E) --------------------------------------------------------
HANDLE __stdcall CreateMutexWStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
{
  return CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
}

//----- (77E23612) --------------------------------------------------------
BOOL __stdcall ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
  HANDLE v8; // edi@3
  void (__stdcall *v9)(PVOID, PIO_STATUS_BLOCK, ULONG); // ecx@3
  void *v10; // eax@3
  NTSTATUS v11; // esi@4
  signed int v13; // eax@7
  NTSTATUS v14; // eax@15
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-10h]@15
  int v16; // [sp+14h] [bp-8h]@1
  PVOID Address; // [sp+18h] [bp-4h]@1

  Address = 0;
  v16 = 1;
  if ( !lpOverlapped )
  {
    v14 = NtNotifyChangeDirectoryFile(
            hDirectory,
            0,
            0,
            0,
            &IoStatusBlock,
            (PFILE_NOTIFY_INFORMATION)lpBuffer,
            nBufferLength,
            dwNotifyFilter,
            bWatchSubtree);
    if ( v14 == 259 )
    {
      v14 = NtWaitForSingleObject(hDirectory, 0, 0);
      if ( v14 < 0 )
      {
LABEL_20:
        BaseSetLastNTError(v14);
        return 0;
      }
      v14 = IoStatusBlock.u.Status;
    }
    if ( v14 >= 0 )
    {
      *lpBytesReturned = IoStatusBlock.Information;
      return v16;
    }
    goto LABEL_20;
  }
  if ( !lpCompletionRoutine )
  {
    v8 = lpOverlapped->hEvent;
    v9 = 0;
    v10 = (void *)(((unsigned int)lpOverlapped->hEvent & 1) == 0 ? (unsigned int)lpOverlapped : 0);
LABEL_4:
    lpOverlapped->Internal = 259;
    v11 = NtNotifyChangeDirectoryFile(
            hDirectory,
            v8,
            v9,
            v10,
            (PIO_STATUS_BLOCK)lpOverlapped,
            (PFILE_NOTIFY_INFORMATION)lpBuffer,
            nBufferLength,
            dwNotifyFilter,
            bWatchSubtree);
    if ( (v11 & 0xC0000000) != -1073741824 )
      return v16;
    if ( Address )
      BasepFreeActivationContextActivationBlock(Address);
    BaseSetLastNTError(v11);
    return 0;
  }
  v8 = 0;
  v13 = BasepAllocateActivationContextActivationBlock(3, (int)lpCompletionRoutine, (int)lpOverlapped, (int)&Address);
  if ( v13 >= 0 )
  {
    v10 = Address;
    if ( Address )
    {
      v9 = (void (__stdcall *)(PVOID, PIO_STATUS_BLOCK, ULONG))BasepIoCompletion;
    }
    else
    {
      v10 = lpCompletionRoutine;
      v9 = (void (__stdcall *)(PVOID, PIO_STATUS_BLOCK, ULONG))BasepIoCompletionSimple;
    }
    goto LABEL_4;
  }
  BaseSetLastNTError(v13);
  return 0;
}

//----- (77E23691) --------------------------------------------------------
BOOL __stdcall FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
{
  TIME_FIELDS TimeFields; // [sp+0h] [bp-18h]@2
  LARGE_INTEGER Time; // [sp+10h] [bp-8h]@1

  Time = (LARGE_INTEGER)(*(_QWORD *)lpFileTime + 19999999i64);
  if ( Time.s.HighPart > 0 || Time.s.HighPart >= 0 )
  {
    RtlTimeToTimeFields(&Time, &TimeFields);
    if ( (unsigned __int16)(TimeFields.Year - 1980) <= 0x7Fu )
    {
      *lpFatDate = TimeFields.Day | 32 * (TimeFields.Month | 16 * (TimeFields.Year - 60));
      *lpFatTime = ((unsigned __int16)TimeFields.Second >> 1) | 32 * (TimeFields.Minute | (TimeFields.Hour << 6));
      return 1;
    }
    BaseSetLastNTError(-1073741811);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E23739) --------------------------------------------------------
BOOL __stdcall GetOverlappedResultStub(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
{
  return GetOverlappedResult(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
}

//----- (77E23746) --------------------------------------------------------
LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
  int v9; // eax@1

  v9 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, const LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, _DWORD))(v9 + 184))(
           hKey,
           lpSubKey,
           Reserved,
           lpClass,
           dwOptions,
           samDesired,
           lpSecurityAttributes,
           phkResult,
           lpdwDisposition,
           0);
}

//----- (77E2377C) --------------------------------------------------------
void __stdcall RegCreateKeyExInternalA(int a1, PCSZ Source, int a3, int a4, ULONG CreateOptions, ACCESS_MASK DesiredAccess, int a7, int a8, int a9, int a10)
{
  NTSTATUS v10; // eax@18
  int v11; // eax@19
  int v12; // ebp@0
  int v13; // edi@1
  int v14; // eax@1
  int v15; // ebx@1
  int v16; // esi@1
  int v17; // eax@7
  void (__stdcall *v18)(PUNICODE_STRING); // esi@14
  int v19; // esi@16
  int v20; // edi@16
  int v21; // eax@16
  unsigned int v22; // esi@30
  int (__stdcall *v23)(_DWORD, _DWORD); // eax@30
  bool v24; // al@33
  ACCESS_MASK v25; // ecx@35
  int v26; // esi@40
  char v27; // [sp+10h] [bp-58h]@20
  STRING SourceString; // [sp+24h] [bp-44h]@18
  LSA_UNICODE_STRING Destination; // [sp+2Ch] [bp-3Ch]@8
  LSA_UNICODE_STRING DestinationString; // [sp+34h] [bp-34h]@10
  int (__stdcall *v31)(unsigned int, LSA_UNICODE_STRING *, LSA_UNICODE_STRING *, ULONG, ACCESS_MASK, int, int, int); // [sp+40h] [bp-28h]@1
  int v32; // [sp+44h] [bp-24h]@1
  int v33; // [sp+48h] [bp-20h]@1
  ULONG v34; // [sp+4Ch] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@40

  v13 = 0;
  v32 = 0;
  v33 = 0;
  v14 = RegKrnGetGlobalState();
  v15 = *(_DWORD *)(v14 + 84);
  v31 = *(int (__stdcall **)(unsigned int, LSA_UNICODE_STRING *, LSA_UNICODE_STRING *, ULONG, ACCESS_MASK, int, int, int))(v14 + 84);
  v16 = a1;
  if ( a1 != -2147483644 && a1 != -2147483568 && a1 != -2147483552 && !a3 && Source && a8 )
  {
    v17 = RegKrnGetGlobalState();
    v34 = (*(int (__stdcall **)(int, int *, int *, int *))(v17 + 176))(v16, &a1, &v32, &v33);
    if ( v34 )
    {
LABEL_16:
      v19 = v33;
      v20 = v32;
      v21 = RegKrnGetGlobalState();
      (*(void (__stdcall **)(int, int))(v21 + 168))(v20, v19);
      return;
    }
    if ( !RtlCreateUnicodeStringFromAsciiz(&Destination, Source) )
    {
      v34 = RtlNtStatusToDosError(-1073741801);
      goto LABEL_16;
    }
    Destination.Length += 2;
    if ( a4 )
    {
      v10 = RtlInitAnsiStringEx(&SourceString, (PCSZ)a4);
      if ( v10 >= 0 )
      {
        v11 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u);
        sub_77E176F2(v11, v12, 0, a1, (int)Source, a3, a4, CreateOptions, DesiredAccess, a7, a8, a9, a10);
        return;
      }
      v34 = RtlNtStatusToDosError(v10);
      RtlFreeUnicodeString(&Destination);
      goto LABEL_16;
    }
    DestinationString.Length = 0;
    DestinationString.MaximumLength = 0;
    DestinationString.Buffer = 0;
    if ( a7 )
    {
      v13 = (int)&v27;
      a4 = (int)&v27;
      v34 = MapSAToRpcSA(a7, (int)&v27);
      if ( v34 )
      {
        v18 = RtlFreeUnicodeString;
        RtlFreeUnicodeString(&DestinationString);
LABEL_15:
        v18(&Destination);
        goto LABEL_16;
      }
    }
    else
    {
      a4 = 0;
    }
    if ( !(a1 & 1) )
    {
      v34 = LocalBaseRegCreateKey(
              a1,
              &Destination,
              (int)&DestinationString,
              CreateOptions,
              DesiredAccess,
              v13,
              a8,
              a9,
              a10);
      goto LABEL_14;
    }
    if ( !v15 )
    {
LABEL_14:
      v18 = RtlFreeUnicodeString;
      RtlFreeUnicodeString(&DestinationString);
      if ( v13 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v13 + 4));
      goto LABEL_15;
    }
    Source = 0;
    v22 = a1 & 0xFFFFFFFE;
    v23 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
    v24 = v23 && !v23(v22, &Source) && Source == (PCSZ)6;
    v25 = DesiredAccess;
    if ( !(DesiredAccess & 0x300) )
    {
      if ( !v24 )
      {
LABEL_39:
        v25 &= 0xFFFFFCFF;
LABEL_40:
        ms_exc.registration.TryLevel = 0;
        v26 = a8;
        v34 = v31(a1 & 0xFFFFFFFE, &Destination, &DestinationString, CreateOptions, v25, v13, a8, a9);
        ms_exc.registration.TryLevel = -2;
        if ( !v34 )
          *(_DWORD *)v26 |= 1u;
        goto LABEL_14;
      }
      v25 = DesiredAccess | 0x200;
    }
    if ( v24 )
      goto LABEL_40;
    goto LABEL_39;
  }
}

//----- (77E238C1) --------------------------------------------------------
char __stdcall EnumSubtreeStateClear(PVOID *a1)
{
  PVOID v1; // eax@1

  v1 = *a1;
  if ( *a1 && v1 != a1 + 4 )
    LOBYTE(v1) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *a1);
  *a1 = 0;
  return (char)v1;
}

//----- (77E238E1) --------------------------------------------------------
void *__stdcall EnumStateClear(void *Dst)
{
  void *v1; // eax@1

  v1 = (void *)*((_DWORD *)Dst + 6);
  if ( v1 && *((void **)Dst + 4) != v1 || (v1 = (void *)*((_DWORD *)Dst + 5)) != 0 && *((void **)Dst + 4) != v1 )
    NtClose(v1);
  EnumSubtreeStateClear((PVOID *)Dst + 10);
  EnumSubtreeStateClear((PVOID *)Dst + 86);
  return memset(Dst, 0, 0x288u);
}

//----- (77E2394A) --------------------------------------------------------
int __stdcall StateObjectListAdd(int a1, int a2)
{
  int v2; // edx@1
  int result; // eax@1

  v2 = *(_DWORD *)(a1 + 12);
  result = a2;
  if ( v2 )
  {
    *(_DWORD *)a2 = v2;
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) = a2;
  }
  *(_DWORD *)(a1 + 12) = a2;
  *(_DWORD *)(a2 + 4) = 0;
  return result;
}

//----- (77E23970) --------------------------------------------------------
NTSTATUS __stdcall EnumStateSetLimits(void *Dst, int a2, int a3, int a4, int a5)
{
  void *v5; // esi@1
  int v6; // ecx@1
  int v7; // ecx@1
  unsigned int v8; // eax@1
  signed int v9; // eax@3
  int v10; // eax@5
  NTSTATUS result; // eax@8
  void *Dsta; // [sp+10h] [bp+8h]@1

  v5 = Dst;
  v6 = (*((_DWORD *)Dst + 3) & 1) == 1;
  Dsta = 0;
  v7 = 2 * v6 - 1;
  *(_DWORD *)a5 = v7;
  v8 = *((_DWORD *)v5 + 7);
  if ( a2 > v8 )
  {
    v9 = 1;
  }
  else if ( a2 < v8 )
  {
    v9 = -1;
  }
  else
  {
    Dsta = (void *)1;
    v9 = v7;
  }
  if ( v9 == v7 || (result = EnumStateInit(v5, *((HANDLE *)v5 + 4), v9 == -1 ? a2 : 0, v9 != -1, 0), result >= 0) )
  {
    v10 = *((_DWORD *)v5 + 7);
    *(_DWORD *)a3 = v10;
    if ( (*((_BYTE *)v5 + 12) & 6) == 6 )
    {
      if ( *((_DWORD *)v5 + 3) & 1 )
      {
        *(_DWORD *)a5 = 1;
      }
      else
      {
        result = ClassKeyCountSubKeys(*((_DWORD *)v5 + 4), *((_DWORD *)v5 + 5), *((HANDLE *)v5 + 6), 0, a3);
        if ( result < 0 )
          return result;
        if ( (unsigned int)a2 >= *(_DWORD *)a3 )
          return -2147483622;
        --*(_DWORD *)a3;
        *(_DWORD *)a5 = -1;
      }
    }
    else if ( Dsta )
    {
      result = EnumStateInit(v5, *((HANDLE *)v5 + 4), 0, 1, 0);
      if ( result < 0 )
        return result;
      *(_DWORD *)a5 = 1;
      *((_DWORD *)v5 + 3) |= 1u;
      *(_DWORD *)a3 = 0;
    }
    else
    {
      *(_DWORD *)a3 = v10 + *(_DWORD *)a5;
    }
    *(_DWORD *)a4 = a2 + *(_DWORD *)a5;
    result = 0;
  }
  return result;
}

//----- (77E23A4A) --------------------------------------------------------
void __stdcall EnumTableGetNextEnum(void *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  struct _RTL_CRITICAL_SECTION *v8; // ebx@1
  int v9; // eax@1
  void *Dst; // [sp+8h] [bp-4h]@2

  v7 = (int)a1;
  v8 = (struct _RTL_CRITICAL_SECTION *)((char *)a1 + 4);
  RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)((char *)a1 + 4));
  if ( v9 >= 0 )
  {
    if ( EnumTableGetKeyState(v7, a2, a3, (int)&a1, (int)&Dst, a7) >= 0 && a1 )
    {
      EnumStateGetNextEnum(a1, a3, a4, a5, a6, a7, (int)&a7);
      if ( Dst )
        EnumTableUpdateRootState(v7, Dst, (int)a1, a7);
      if ( a7 )
        EnumTableRemoveKey(v7, a2, 1);
    }
    RtlLeaveCriticalSection(v8);
  }
}

//----- (77E23ACD) --------------------------------------------------------
int __stdcall EnumStateGetNextEnum(void *Dst, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ebx@1
  int v8; // esi@1
  int v9; // edi@1
  int v10; // ST08_4@1
  void *v11; // ST04_4@1
  int result; // eax@1
  int v13; // ST14_4@5
  signed int v14; // esi@5

  v7 = a7;
  v8 = (int)Dst;
  v9 = a2;
  v10 = a2;
  v11 = Dst;
  *(_DWORD *)a7 = 1;
  result = EnumStateSetLimits(v11, v10, (int)&Dst, (int)&a2, (int)&a7);
  if ( result >= 0 )
  {
    result = EnumStateChooseNext(v8, v9, (int)Dst, a2, a7, (int)&a7);
    if ( result >= 0 )
    {
      if ( !*(_DWORD *)(v8 + 52) || !*(_DWORD *)(v8 + 356) )
        *(_DWORD *)v7 = 0;
      v13 = a6;
      *(_DWORD *)(v8 + 28) = v9;
      v14 = EnumSubtreeStateCopyKeyInfo(a7, a3, a4, a5, v13);
      if ( v14 >= 0 )
        EnumSubtreeStateClear((PVOID *)a7);
      result = v14;
    }
  }
  return result;
}

//----- (77E23B53) --------------------------------------------------------
signed int __stdcall EnumStateChooseNext(int a1, int a2, int a3, int a4, int a5, int a6)
{
  signed int v6; // edi@1
  int v7; // esi@2
  int v8; // ebx@2
  void *v9; // ecx@4
  void *v10; // ecx@5
  NTSTATUS v11; // eax@8
  signed int v13; // [sp+Ch] [bp-4h]@1
  signed int v14; // [sp+18h] [bp+8h]@3
  signed int v15; // [sp+28h] [bp+18h]@3

  v13 = 0;
  v6 = -2147483622;
  if ( a3 != a4 )
  {
    v7 = a1;
    v8 = a5;
    do
    {
      v14 = 0;
      v15 = 0;
      v6 = -2147483622;
      if ( v13 )
        EnumSubtreeStateClear(*(PVOID **)a6);
      v9 = *(void **)(v7 + 20);
      if ( v9 )
      {
        if ( *(_DWORD *)(v7 + 40) )
        {
          v14 = 1;
        }
        else if ( !*(_DWORD *)(v7 + 52) )
        {
          v6 = EnumClassKey(v9, v7 + 40);
          v14 = v6 >= 0;
          if ( v6 < 0 )
          {
            if ( v6 != -2147483622 )
              return v6;
            if ( v8 <= 0 )
            {
              *(_DWORD *)(v7 + 48) += v8;
              v15 = 1;
            }
            else
            {
              *(_DWORD *)(v7 + 52) = 1;
            }
          }
        }
      }
      v10 = *(void **)(v7 + 24);
      if ( v10 )
      {
        if ( *(_DWORD *)(v7 + 344) )
          goto LABEL_9;
        if ( !*(_DWORD *)(v7 + 356) )
        {
          v11 = EnumClassKey(v10, v7 + 344);
          v6 = v11;
          if ( v11 >= 0 )
            goto LABEL_9;
          if ( v11 == -2147483622 )
          {
            if ( v8 <= 0 )
            {
              *(_DWORD *)(v7 + 352) += v8;
              v15 = 1;
            }
            else
            {
              *(_DWORD *)(v7 + 356) = 1;
            }
          }
        }
      }
      if ( !v14 )
      {
        if ( !v15 )
          return v6;
        goto LABEL_14;
      }
LABEL_9:
      if ( !*(_DWORD *)(v7 + 48) && !*(_DWORD *)(v7 + 352) && v8 < 0 )
        a3 = a4 - v8;
      v6 = EnumStateCompareSubtrees(v7, v8, a6);
      if ( v6 < 0 )
      {
        *(_DWORD *)(v7 + 28) = a2;
        return v6;
      }
      v13 = 1;
LABEL_14:
      a3 += v8;
    }
    while ( a3 != a4 );
  }
  return v6;
}

//----- (77E23C1E) --------------------------------------------------------
NTSTATUS __stdcall EnumClassKey(HANDLE KeyHandle, int a2)
{
  int v2; // esi@1
  ULONG *v3; // edi@1
  ULONG *v4; // ST14_4@1
  ULONG v5; // ST04_4@1
  NTSTATUS result; // eax@1
  PVOID v7; // eax@5
  int v8; // [sp+18h] [bp+Ch]@1

  v2 = a2;
  v3 = (ULONG *)(a2 + 4);
  v4 = (ULONG *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v8 = a2 + 16;
  result = NtEnumerateKey(KeyHandle, v5, KeyNodeInformation, (PVOID)v8, 0x120u, v4);
  if ( result == -2147483643 )
  {
    v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *v3);
    v8 = (int)v7;
    if ( !v7 )
      return -1073741801;
    result = NtEnumerateKey(KeyHandle, *(_DWORD *)(v2 + 8), KeyNodeInformation, v7, *v3, v3);
  }
  if ( result >= 0 )
  {
    *(_DWORD *)v2 = v8;
    result = 0;
  }
  return result;
}

//----- (77E23C6B) --------------------------------------------------------
signed int __stdcall EnumTableGetKeyState(int a1, int a2, int a3, int a4, int a5, int a6)
{
  signed int result; // eax@3

  if ( a5 )
    *(_DWORD *)a5 = 0;
  result = EnumTableFindKeyState(a1, a2, a4);
  if ( result >= 0 )
  {
    if ( *(_BYTE *)(*(_DWORD *)a4 + 12) & 8 )
      result = EnumTableGetRootState(a1, a5);
  }
  else if ( result == -1073741772 )
  {
    result = EnumTableAddKey(a1, (void *)a2, a3, a4, a5);
    if ( result >= 0 && !*(_DWORD *)a4 )
      *(_DWORD *)a6 = 0;
  }
  return result;
}

//----- (77E23CC2) --------------------------------------------------------
signed int __stdcall EnumTableFindKeyState(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@1
  int v5; // eax@2
  signed int result; // eax@2

  v3 = GetCurrentThreadId();
  v4 = StateObjectListFind(a1 + 28, v3);
  if ( v4 )
  {
    v5 = StateObjectListFind(v4, a2);
    *(_DWORD *)a3 = v5;
    result = v5 != 0 ? 0 : -1073741772;
  }
  else
  {
    result = -1073741772;
  }
  return result;
}

//----- (77E23D06) --------------------------------------------------------
signed int __stdcall EnumTableAddKey(int a1, void *a2, int a3, int a4, int a5)
{
  int v5; // eax@9
  int v6; // eax@1
  PVOID v7; // eax@2
  int v8; // ebx@2
  int v9; // esi@3
  int v10; // ST10_4@6
  int *v12; // esi@11
  UNICODE_STRING Source; // [sp+Ch] [bp-1C0h]@3
  int SourceHandle; // [sp+14h] [bp-1B8h]@3
  int v15; // [sp+18h] [bp-1B4h]@3
  int v16; // [sp+1Ch] [bp-1B0h]@3
  int v17; // [sp+20h] [bp-1ACh]@3
  char *v18; // [sp+24h] [bp-1A8h]@3
  int v19; // [sp+28h] [bp-1A4h]@1
  int v20; // [sp+2Ch] [bp-1A0h]@1
  int v21; // [sp+30h] [bp-19Ch]@1
  HANDLE KeyHandle; // [sp+34h] [bp-198h]@1
  int v23; // [sp+38h] [bp-194h]@1
  char v24; // [sp+3Ch] [bp-190h]@3
  char Dst; // [sp+3Dh] [bp-18Fh]@3

  KeyHandle = a2;
  v20 = a4;
  v21 = a1;
  v19 = a5;
  *(_DWORD *)(RegKrnGetGlobalState() + 160) = 1;
  v6 = GetCurrentThreadId();
  v23 = StateObjectListFind(a1 + 28, v6);
  if ( !v23 )
  {
    v5 = (int)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x2A8u);
    v23 = v5;
    if ( !v5 )
      return -1073741801;
    KeyStateListInit(v5);
    StateObjectListAdd(a1 + 28, v23);
  }
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x288u);
  v8 = (int)v7;
  if ( !v7 )
    return -1073741801;
  memset(v7, 0, 0x288u);
  v15 = 0;
  v16 = 0;
  Source.Length = 0;
  *(_DWORD *)&Source.MaximumLength = 0;
  HIWORD(Source.Buffer) = 0;
  v24 = 0;
  memset(&Dst, 0, 0x189u);
  SourceHandle = 0;
  v18 = &v24;
  v17 = 394;
  v9 = BaseRegGetKeySemantics(KeyHandle, &Source, (int)&SourceHandle);
  if ( v9 < 0
    || (v9 = EnumStateInit((void *)v8, KeyHandle, a3, a3 == 0, &SourceHandle),
        BaseRegReleaseKeySemantics((int)&SourceHandle),
        v9 < 0) )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v8);
  }
  else
  {
    if ( SourceHandle & 0x10 )
    {
      v12 = (int *)v19;
      if ( EnumTableGetRootState(v21, v19) >= 0 )
        EnumStateCopy(v8, *v12);
    }
    v10 = v23;
    *(_DWORD *)v20 = v8;
    StateObjectListAdd(v10, v8);
    v9 = 0;
  }
  return v9;
}

//----- (77E23E8F) --------------------------------------------------------
int __stdcall EnumStateInit(void *Dst, HANDLE KeyHandle, int a3, int a4, HANDLE SourceHandle)
{
  void *v5; // esi@1
  int result; // eax@6
  DWORD v7; // eax@8
  int v8; // ecx@8
  bool v9; // sf@8
  HANDLE v10; // edi@14
  void *v11; // eax@14
  PVOID *v12; // [sp+Ch] [bp-18h]@2
  PVOID *v13; // [sp+10h] [bp-14h]@2
  int v14; // [sp+14h] [bp-10h]@14
  int v15; // [sp+18h] [bp-Ch]@14
  HANDLE Handle; // [sp+1Ch] [bp-8h]@1
  NTSTATUS v17; // [sp+20h] [bp-4h]@1
  HANDLE Dsta; // [sp+2Ch] [bp+8h]@14
  HANDLE SourceHandlea; // [sp+3Ch] [bp+18h]@14

  v5 = Dst;
  v17 = 0;
  Handle = 0;
  if ( !KeyHandle )
    memset(Dst, 0, 0x288u);
  v12 = (PVOID *)((char *)Dst + 40);
  EnumSubtreeStateClear((PVOID *)Dst + 10);
  v13 = (PVOID *)((char *)Dst + 344);
  EnumSubtreeStateClear((PVOID *)Dst + 86);
  *((_DWORD *)Dst + 13) = 0;
  *((_DWORD *)Dst + 89) = 0;
  *((_DWORD *)Dst + 12) = 0;
  *((_DWORD *)Dst + 88) = 0;
  if ( SourceHandle )
    StateObjectInit((int)Dst, (int)KeyHandle);
  if ( KeyHandle )
  {
    if ( SourceHandle )
    {
      *((_DWORD *)Dst + 3) ^= (*((_DWORD *)Dst + 3) ^ (*(_DWORD *)SourceHandle >> 1)) & 8;
      result = BaseRegGetUserAndMachineClass(
                 (int)SourceHandle,
                 KeyHandle,
                 0x2000000,
                 (int)((char *)Dst + 24),
                 (int)((char *)Dst + 20));
      v17 = result;
      if ( result < 0 )
        return result;
    }
    if ( !a4 )
    {
      v10 = (HANDLE)*((_DWORD *)Dst + 6);
      v11 = (void *)*((_DWORD *)Dst + 5);
      v14 = 0;
      v15 = 0;
      Dsta = v11;
      SourceHandlea = v10;
      if ( v10 != KeyHandle )
        SourceHandlea = v11;
      v17 = NtDuplicateObject((HANDLE)0xFFFFFFFF, SourceHandlea, (HANDLE)0xFFFFFFFF, &Handle, 1u, 0, 0);
      if ( v17 < 0 )
        goto LABEL_25;
      if ( SourceHandlea == Dsta )
        Dsta = Handle;
      else
        v10 = Handle;
      if ( v10 )
      {
        v17 = GetSubKeyCount(v10, (int)&v14);
        if ( v17 < 0 )
          goto LABEL_25;
      }
      if ( !Dsta )
        goto LABEL_33;
      v17 = GetSubKeyCount(Dsta, (int)&v15);
      if ( v17 < 0 )
        goto LABEL_25;
      if ( v15 )
        *((_DWORD *)v5 + 12) = v15 - 1;
      else
LABEL_33:
        *((_DWORD *)v5 + 13) = 1;
      if ( v14 )
        *((_DWORD *)v5 + 88) = v14 - 1;
      else
        *((_DWORD *)v5 + 89) = 1;
    }
  }
  v7 = GetCurrentThreadId();
  v8 = *((_DWORD *)v5 + 3);
  *((_DWORD *)v5 + 8) = v7;
  *((_DWORD *)v5 + 7) = a3;
  v9 = v17 < 0;
  *((_DWORD *)v5 + 3) = a4 & 1 | v8 & 0xFFFFFFFE | 6;
  *((_DWORD *)v5 + 4) = KeyHandle;
  if ( v9 )
  {
LABEL_25:
    EnumSubtreeStateClear(v13);
    EnumSubtreeStateClear(v12);
  }
  if ( Handle )
    NtClose(Handle);
  return v17;
}

//----- (77E23F70) --------------------------------------------------------
BOOLEAN __stdcall EnumStateDestroy(PVOID Address)
{
  EnumStateClear(Address);
  return RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}

//----- (77E24017) --------------------------------------------------------
signed int __stdcall EnumSubtreeStateCopyKeyInfo(int a1, int a2, int a3, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // eax@1
  int v7; // eax@3
  signed int result; // eax@7

  v5 = *(_DWORD *)a1;
  *(_DWORD *)a3 = **(_DWORD **)a1;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(*(_DWORD *)a1 + 8);
  v6 = *(_DWORD *)a1;
  if ( a2 != 1 )
  {
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(v6 + 20);
    if ( a4 >= 0x18 )
    {
      v7 = *(_DWORD *)(*(_DWORD *)a1 + 20) + 22;
      goto LABEL_4;
    }
    return -1073741789;
  }
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v6 + 12);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(*(_DWORD *)a1 + 16);
  *(_DWORD *)(a3 + 20) = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( a4 < 0x20 )
    return -1073741789;
  v7 = *(_DWORD *)(*(_DWORD *)a1 + 20) + *(_DWORD *)(*(_DWORD *)a1 + 16) + 30;
LABEL_4:
  *(_DWORD *)a5 = v7;
  if ( a4 < v7 )
  {
    result = -2147483643;
  }
  else
  {
    if ( a2 == 1 )
    {
      memcpy((void *)(a3 + 24), (const void *)(*(_DWORD *)a1 + 24), *(_DWORD *)(*(_DWORD *)a1 + 20));
      if ( *(_DWORD *)(*(_DWORD *)a1 + 12) >= 0 )
        memcpy(
          (void *)(a3 + *(_DWORD *)(*(_DWORD *)a1 + 12)),
          (const void *)(*(_DWORD *)(*(_DWORD *)a1 + 12) + *(_DWORD *)a1),
          *(_DWORD *)(*(_DWORD *)a1 + 16));
    }
    else
    {
      memcpy((void *)(a3 + 16), (const void *)(*(_DWORD *)a1 + 24), *(_DWORD *)(*(_DWORD *)a1 + 20));
    }
    result = 0;
  }
  return result;
}

//----- (77E24099) --------------------------------------------------------
signed int __stdcall EnumStateCompareSubtrees(int a1, int a2, int a3)
{
  PVOID *v3; // edi@1
  int v4; // eax@1
  int v5; // ebx@2
  int v6; // ecx@2
  int v7; // eax@5
  unsigned int v8; // ecx@5
  int v9; // eax@7
  LONG v11; // eax@12
  int v12; // ecx@19
  UNICODE_STRING String1; // [sp+Ch] [bp-10h]@12
  UNICODE_STRING String2; // [sp+14h] [bp-8h]@12

  v3 = (PVOID *)(a1 + 344);
  v4 = *(_DWORD *)(a1 + 344);
  if ( v4 )
  {
    v5 = a1 + 40;
    v6 = *(_DWORD *)(a1 + 40);
    if ( v6 )
    {
      String2.Buffer = (PWCH)(v4 + 24);
      String2.Length = *(_WORD *)(v4 + 20);
      String1.Buffer = (PWCH)(v6 + 24);
      String1.Length = *(_WORD *)(v6 + 20);
      v11 = a2 * RtlCompareUnicodeString(&String1, &String2, 1u);
      if ( v11 >= 0 )
      {
        if ( v11 <= 0 )
        {
          v12 = *(_DWORD *)(a1 + 352);
          if ( v12 || a2 >= 0 )
            *(_DWORD *)(a1 + 352) = a2 + v12;
          else
            *(_DWORD *)(a1 + 356) = 1;
          EnumSubtreeStateClear(v3);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a1 + 12) & 0xFFFFFFFB | 2;
          v7 = a3;
          *(_DWORD *)a3 = v5;
          goto LABEL_7;
        }
        goto LABEL_5;
      }
      v7 = a3;
      *(_DWORD *)a3 = v5;
LABEL_26:
      v8 = *(_DWORD *)(a1 + 12) & 0xFFFFFFFB | 2;
      goto LABEL_6;
    }
  }
  if ( !*(_DWORD *)(a1 + 40) )
  {
    if ( !v4 )
      return -2147483622;
    goto LABEL_5;
  }
  if ( !v4 )
  {
    v7 = a3;
    *(_DWORD *)a3 = a1 + 40;
    goto LABEL_26;
  }
LABEL_5:
  v7 = a3;
  *(_DWORD *)a3 = v3;
  v8 = *(_DWORD *)(a1 + 12) & 0xFFFFFFFD | 4;
LABEL_6:
  *(_DWORD *)(a1 + 12) = v8;
LABEL_7:
  v9 = *(_DWORD *)v7;
  if ( *(_DWORD *)(v9 + 8) || a2 >= 0 )
    *(_DWORD *)(v9 + 8) += a2;
  else
    *(_DWORD *)(v9 + 12) = 1;
  return 0;
}

//----- (77E24143) --------------------------------------------------------
BOOL __stdcall CancelIoExStub(HANDLE hFile, LPOVERLAPPED lpOverlapped)
{
  return CancelIoEx(hFile, lpOverlapped);
}

//----- (77E24168) --------------------------------------------------------
LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
{
  HKEY v6; // esi@1
  int v7; // eax@3
  DWORD v8; // esi@9
  const BYTE *v9; // eax@10
  PVOID v10; // eax@11
  NTSTATUS v11; // eax@12
  int v12; // esi@23
  int v13; // edi@23
  int v14; // eax@23
  PVOID v16; // eax@30
  DWORD v17; // eax@31
  LSTATUS v18; // [sp-4h] [bp-60h]@36
  __int16 v19; // [sp+10h] [bp-4Ch]@35
  __int16 v20; // [sp+12h] [bp-4Ah]@35
  int v21; // [sp+14h] [bp-48h]@35
  LSA_UNICODE_STRING Destination; // [sp+18h] [bp-44h]@5
  ULONG ResultSize; // [sp+24h] [bp-38h]@12
  int v24; // [sp+28h] [bp-34h]@1
  int v25; // [sp+2Ch] [bp-30h]@1
  int (__stdcall *v26)(unsigned int, PUNICODE_STRING, DWORD, DWORD, DWORD); // [sp+30h] [bp-2Ch]@1
  PUNICODE_STRING ValueName; // [sp+34h] [bp-28h]@6
  PVOID Address; // [sp+38h] [bp-24h]@1
  PVOID v29; // [sp+3Ch] [bp-20h]@1
  LSTATUS v30; // [sp+40h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@44

  v29 = 0;
  Address = 0;
  v24 = 0;
  v25 = 0;
  v26 = *(int (__stdcall **)(unsigned int, PUNICODE_STRING, DWORD, DWORD, DWORD))(RegKrnGetGlobalState() + 132);
  v6 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA )
  {
    v18 = 6;
  }
  else
  {
    if ( !Reserved )
    {
      v7 = RegKrnGetGlobalState();
      v30 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v7 + 176))(v6, &hKey, &v24, &v25);
      if ( !v30 )
      {
        if ( !lpValueName )
        {
          ValueName = (PUNICODE_STRING)&v19;
          v19 = 0;
          v20 = 0;
          v21 = 0;
          goto LABEL_7;
        }
        if ( RtlCreateUnicodeStringFromAsciiz(&Destination, lpValueName) )
        {
          ValueName = &Destination;
          Destination.Length += 2;
          if ( !Destination.Length )
          {
            v30 = 87;
            goto LABEL_21;
          }
LABEL_7:
          Reserved = (DWORD)lpData;
          if ( !lpData || dwType != 1 && dwType != 2 && dwType != 7 )
          {
            v8 = cbData;
            goto LABEL_14;
          }
          v8 = cbData;
          if ( cbData <= 0
            || (v9 = &lpData[cbData], !lpData[cbData - 1])
            || ((unsigned int)v9 ^ (unsigned int)(v9 - 1)) & 0xFFFFF000
            || *v9 )
          {
LABEL_11:
            v10 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v8);
            Address = v10;
            if ( !v10 )
            {
              v30 = 8;
LABEL_18:
              if ( v29 )
                RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v29);
              if ( Address )
                RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
              goto LABEL_21;
            }
            v11 = RtlMultiByteToUnicodeN((PWCHAR)v10, 2 * v8, &ResultSize, (PCHAR)Reserved, v8);
            if ( v11 < 0 )
            {
              v30 = RtlNtStatusToDosError(v11);
LABEL_15:
              if ( !v30 )
              {
                if ( (unsigned __int8)hKey & 1 )
                {
                  if ( v26 )
                  {
                    ms_exc.registration.TryLevel = 0;
                    v30 = v26((unsigned int)hKey & 0xFFFFFFFE, ValueName, dwType, Reserved, v8);
                    ms_exc.registration.TryLevel = -2;
                  }
                }
                else
                {
                  v30 = LocalBaseRegSetValue(hKey, ValueName, dwType, (PVOID)Reserved, v8);
                }
              }
              goto LABEL_18;
            }
            Reserved = (DWORD)Address;
            v8 = ResultSize;
LABEL_14:
            v30 = 0;
            goto LABEL_15;
          }
          v16 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, cbData + 1);
          v29 = v16;
          if ( v16 )
          {
            memcpy(v16, lpData, v8);
            v17 = (DWORD)v29;
            *((_BYTE *)v29 + v8++) = 0;
            Reserved = v17;
            goto LABEL_11;
          }
          v30 = 8;
LABEL_21:
          if ( lpValueName )
            RtlFreeUnicodeString(&Destination);
          goto LABEL_23;
        }
        v30 = RtlNtStatusToDosError(-1073741801);
      }
LABEL_23:
      v12 = v25;
      v13 = v24;
      v14 = RegKrnGetGlobalState();
      (*(void (__stdcall **)(int, int))(v14 + 168))(v13, v12);
      return v30;
    }
    v18 = 87;
  }
  return v18;
}

//----- (77E243D7) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCchCopyW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc)
{
  NTSTATUS result; // eax@1
  wchar_t *v4; // eax@4
  NTSTATUS v5; // ebx@4
  size_t v6; // esi@4
  wchar_t v7; // cx@6

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cchDest;
    if ( !cchDest )
      goto LABEL_15;
    do
    {
      if ( !(2147483646 - cchDest + v6) )
        break;
      v7 = *(wchar_t *)((char *)v4 + (char *)pszSrc - (char *)pszDest);
      if ( !v7 )
        break;
      *v4 = v7;
      ++v4;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_15:
      --v4;
      v5 = -2147483643;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (77E24492) --------------------------------------------------------
BOOL __stdcall DeleteFileAStub(LPCSTR lpFileName)
{
  return DeleteFileA(lpFileName);
}

//----- (77E244B5) --------------------------------------------------------
DWORD __stdcall SearchPathWStub(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
{
  return SearchPathW(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
}

//----- (77E244C2) --------------------------------------------------------
HRSRC __stdcall FindResourceExWStub(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
{
  return FindResourceExW(hModule, lpType, lpName, wLanguage);
}

//----- (77E244E7) --------------------------------------------------------
DWORD __stdcall ExpandEnvironmentStringsWStub(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
{
  return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);
}

//----- (77E244FB) --------------------------------------------------------
signed int __stdcall NullTerminateRegSzString(int a1, int *a2, unsigned int a3, signed int a4, char a5)
{
  unsigned int v5; // ebx@1
  int v6; // eax@3
  signed int v7; // edx@3
  bool v8; // zf@5
  int v9; // eax@8

  v5 = (a5 == 0) + 1;
  if ( a4 )
  {
    if ( a4 != 234 )
      return a4;
LABEL_16:
    *a2 += v5;
    return a4;
  }
  if ( !a1 )
    goto LABEL_16;
  v6 = *a2 / v5;
  v7 = 1;
  if ( a5 )
  {
    if ( (unsigned int)v6 < 1 )
      goto LABEL_13;
    v8 = *(_BYTE *)(v6 + a1 - 1) == 0;
  }
  else
  {
    if ( (unsigned int)v6 < 1 )
      goto LABEL_13;
    v8 = *(_WORD *)(a1 + 2 * v6 - 2) == 0;
  }
  if ( v8 )
  {
    v7 = 0;
    goto LABEL_8;
  }
LABEL_13:
  if ( v6 + 1 > a3 / v5 || v6 + 1 < (unsigned int)v6 )
  {
    a4 = 234;
  }
  else if ( a5 )
  {
    *(_BYTE *)(v6 + a1) = 0;
  }
  else
  {
    *(_WORD *)(a1 + 2 * v6) = 0;
  }
LABEL_8:
  v9 = v5 * (v7 + v6);
  if ( *a2 > (unsigned int)v9 )
    v9 = *a2;
  *a2 = v9;
  return a4;
}

//----- (77E24576) --------------------------------------------------------
HMODULE __stdcall LoadLibraryExAStub(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
  return LoadLibraryExA(lpLibFileName, hFile, dwFlags);
}

//----- (77E245D6) --------------------------------------------------------
BOOL __stdcall SetThreadPriorityStub(HANDLE hThread, int nPriority)
{
  return SetThreadPriority(hThread, nPriority);
}

//----- (77E245E3) --------------------------------------------------------
int __stdcall LoadStringBaseExWStub(int a1, int a2, int a3, int a4, int a5)
{
  return LoadStringBaseExW(a1, a2, a3, a4, a5);
}
// 77E245F0: using guessed type int __stdcall LoadStringBaseExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E245FB) --------------------------------------------------------
BOOL __stdcall IsValidLocaleStub(LCID Locale, DWORD dwFlags)
{
  return IsValidLocale(Locale, dwFlags);
}

//----- (77E24613) --------------------------------------------------------
LCID __stdcall ConvertDefaultLocaleStub(LCID Locale)
{
  return ConvertDefaultLocale(Locale);
}

//----- (77E2462B) --------------------------------------------------------
int __stdcall LocalBaseRegQueryInfoKey(HANDLE KeyHandle, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int (__stdcall *v10)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@32
  ULONG v11; // eax@39
  int v12; // eax@8
  NTSTATUS v13; // eax@8
  int v14; // esi@8
  int v15; // ebx@8
  signed int v16; // ebx@17
  int v17; // eax@20
  void *v18; // eax@20
  int result; // eax@26
  int v20; // eax@42
  int v21; // eax@57
  char SecurityDescriptor; // [sp+Ch] [bp-1C4h]@15
  ULONG v23; // [sp+20h] [bp-1B0h]@16
  int v24; // [sp+24h] [bp-1ACh]@49
  int v25; // [sp+28h] [bp-1A8h]@43
  HANDLE v26; // [sp+2Ch] [bp-1A4h]@43
  int v27; // [sp+30h] [bp-1A0h]@1
  PVOID v28; // [sp+34h] [bp-19Ch]@55
  int v29; // [sp+38h] [bp-198h]@1
  int v30; // [sp+3Ch] [bp-194h]@1
  PULONG ReturnLength; // [sp+40h] [bp-190h]@1
  int v32; // [sp+44h] [bp-18Ch]@1
  int v33; // [sp+48h] [bp-188h]@1
  int v34; // [sp+4Ch] [bp-184h]@1
  int v35; // [sp+50h] [bp-180h]@1
  PVOID v36; // [sp+54h] [bp-17Ch]@8
  int v37; // [sp+58h] [bp-178h]@1
  KEY_INFORMATION_CLASS KeyInformationClass; // [sp+5Ch] [bp-174h]@8
  HANDLE Address; // [sp+60h] [bp-170h]@8
  int v40; // [sp+64h] [bp-16Ch]@1
  HANDLE Handle; // [sp+68h] [bp-168h]@1
  char v42; // [sp+6Ch] [bp-164h]@8
  char v43; // [sp+11Ch] [bp-B4h]@8

  v40 = 0;
  v37 = 0;
  v35 = a6;
  v33 = a7;
  v29 = a4;
  v32 = a8;
  Handle = KeyHandle;
  v34 = a3;
  v27 = a5;
  ReturnLength = (PULONG)a9;
  v30 = a10;
  if ( a5 )
    v40 = a5;
  if ( a9 )
    v37 = a9;
  if ( KeyHandle != (HANDLE)-2147483644 && KeyHandle != (HANDLE)-2147483568 && KeyHandle != (HANDLE)-2147483552 )
  {
    v12 = *(_DWORD *)(a2 + 4);
    JUMPOUT(v12, 0, &loc_77E24AAC);
    KeyInformationClass = 2;
    v36 = &v42;
    Address = &v43;
    v13 = QueryKeyInfo(KeyHandle, KeyFullInformation, (int)&Address, 0xB0u, v12 != 0, *(_WORD *)(a2 + 2));
    v14 = (int)Address;
    v15 = v13;
    if ( (v13 >= 0 || v13 == -2147483643) && KeyInformationClass == 2 )
      *(_WORD *)a2 = *((_WORD *)Address + 8) + 2;
    if ( v13 < 0 )
      goto LABEL_38;
    if ( (unsigned __int8)Handle & 2 )
    {
      v15 = BaseRegGetUserAndMachineClass(0, Handle, 0x2000000, (int)&v26, (int)&v25);
      if ( v15 < 0 )
        goto LABEL_38;
      if ( v25 && v26 )
      {
        Address = v26;
        if ( (HANDLE)v25 != Handle )
          Address = (HANDLE)v25;
        v15 = QueryKeyInfo(Address, KeyInformationClass, (int)&v36, 0xB0u, 0, *(_WORD *)(a2 + 2));
        if ( v15 >= 0 )
          v15 = ClassKeyCountSubKeys((int)Handle, v25, v26, 0, (int)&v24);
        NtClose(Address);
        if ( v15 >= 0 )
        {
          v15 = KeyStateGetValueState(Handle, (int)&v28);
          if ( v15 < 0 )
            goto LABEL_38;
          if ( v28 )
            v21 = *((_DWORD *)v28 + 4);
          else
            v21 = 0;
          CombineKeyInfo(v14, (int)v36, KeyInformationClass, v24, v21);
          ValStateRelease(v28);
        }
        else
        {
          if ( v15 == -1073741772 )
            v15 = 0;
          if ( v15 == -2147483643 )
            v15 = 0;
        }
      }
    }
    if ( v15 >= 0 )
    {
      if ( v37 )
      {
        if ( NtQuerySecurityObject(Handle, 7u, &SecurityDescriptor, 0, ReturnLength) == -1073741789 )
        {
          if ( NtQuerySecurityObject(Handle, 0xFu, &SecurityDescriptor, 0, &v23) == -1073741789 )
            *ReturnLength = v23;
        }
        else
        {
          *ReturnLength = 0;
        }
      }
      v16 = 0;
      if ( KeyInformationClass == 4 )
      {
        *(_DWORD *)v34 = *(_DWORD *)(v14 + 12);
        *(_DWORD *)v29 = *(_DWORD *)(v14 + 16);
        *(_DWORD *)v35 = *(_DWORD *)(v14 + 20);
        *(_DWORD *)v33 = *(_DWORD *)(v14 + 24);
        *(_DWORD *)v32 = *(_DWORD *)(v14 + 28);
        v20 = v30;
        *(_DWORD *)v30 = *(_DWORD *)v14;
        *(_DWORD *)(v20 + 4) = *(_DWORD *)(v14 + 4);
        goto LABEL_24;
      }
      *(_DWORD *)v34 = *(_DWORD *)(v14 + 20);
      if ( v40 )
        *(_DWORD *)v27 = *(_DWORD *)(v14 + 28);
      *(_DWORD *)v29 = *(_DWORD *)(v14 + 24);
      *(_DWORD *)v35 = *(_DWORD *)(v14 + 32);
      *(_DWORD *)v33 = *(_DWORD *)(v14 + 36);
      *(_DWORD *)v32 = *(_DWORD *)(v14 + 40);
      v17 = v30;
      *(_DWORD *)v30 = *(_DWORD *)v14;
      *(_DWORD *)(v17 + 4) = *(_DWORD *)(v14 + 4);
      v18 = *(void **)(a2 + 4);
      if ( !v18 )
        goto LABEL_24;
      if ( *(_WORD *)a2 <= *(_WORD *)(a2 + 2) )
      {
        if ( *(_DWORD *)(v14 + 16) )
          memmove(v18, (const void *)(v14 + 44), *(_DWORD *)(v14 + 16));
        *(_WORD *)(*(_DWORD *)(a2 + 4) + 2 * (*(_DWORD *)(v14 + 16) >> 1)) = 0;
        v16 = 0;
        goto LABEL_24;
      }
      if ( !v18 )
      {
LABEL_24:
        if ( (char *)v14 != &v43 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v14);
        if ( v36 != &v42 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v36);
        return v16;
      }
      v11 = RtlNtStatusToDosError(-1073741789);
LABEL_40:
      v16 = v11;
      goto LABEL_24;
    }
LABEL_38:
    if ( v15 == -2147483643 )
    {
      v16 = 234;
      goto LABEL_24;
    }
    v11 = RtlNtStatusToDosError(v15);
    goto LABEL_40;
  }
  v10 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 56);
  if ( !v40 )
    v40 = (int)&v27;
  if ( !v37 )
    v37 = (int)&v34;
  if ( v10 )
    result = v10(KeyHandle, a2, 0, a3, v29, v40, v35, v33, v32, v37, v30);
  else
    result = 87;
  return result;
}

//----- (77E2489E) --------------------------------------------------------
NTSTATUS __stdcall QueryKeyInfo(HANDLE KeyHandle, KEY_INFORMATION_CLASS KeyInformationClass, int a3, ULONG KeyInformationLength, int a5, __int16 a6)
{
  NTSTATUS result; // eax@1
  ULONG v7; // ebx@5
  PVOID v8; // eax@5

  result = NtQueryKey(KeyHandle, KeyInformationClass, *(PVOID *)a3, KeyInformationLength, &KeyInformationLength);
  if ( result == -2147483643 && (!a5 || (unsigned __int16)a6 >= (unsigned int)(*(_DWORD *)(*(_DWORD *)a3 + 16) + 2)) )
  {
    v7 = KeyInformationLength;
    v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, KeyInformationLength);
    *(_DWORD *)a3 = v8;
    if ( v8 )
      result = NtQueryKey(KeyHandle, KeyFullInformation, v8, v7, &KeyInformationLength);
    else
      result = -1073741801;
  }
  return result;
}

//----- (77E248D7) --------------------------------------------------------
LSTATUS __stdcall RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
{
  int v12; // edi@1
  int (__stdcall *v13)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // ebx@1
  HKEY v14; // esi@4
  int v15; // eax@4
  LPWSTR v16; // eax@5
  LPDWORD v17; // esi@5
  PFILETIME v18; // eax@34
  int v19; // esi@36
  int v20; // edi@36
  int v21; // eax@36
  int v23; // eax@45
  unsigned int v24; // esi@62
  int (__stdcall *v25)(_DWORD, _DWORD); // eax@62
  int v26; // [sp+11Ch] [bp-58h]@1
  DWORD v27; // [sp+120h] [bp-54h]@1
  int v28; // [sp+124h] [bp-50h]@10
  LPWSTR v29; // [sp+128h] [bp-4Ch]@12
  int v30; // [sp+130h] [bp-44h]@1
  int v31; // [sp+134h] [bp-40h]@1
  int v32; // [sp+138h] [bp-3Ch]@1
  int v33; // [sp+13Ch] [bp-38h]@1
  DWORD v34; // [sp+140h] [bp-34h]@1
  int v35; // [sp+144h] [bp-30h]@1
  int v36; // [sp+148h] [bp-2Ch]@1
  int v37; // [sp+14Ch] [bp-28h]@1
  unsigned int v38; // [sp+150h] [bp-24h]@1
  int v39; // [sp+154h] [bp-20h]@1
  LSTATUS v40; // [sp+158h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+15Ch] [bp-18h]@45

  v33 = 0;
  v37 = 0;
  v32 = 0;
  v39 = 0;
  v36 = 0;
  v26 = 0;
  v27 = 0;
  v30 = 0;
  v31 = 0;
  v38 = 0;
  v34 = 0;
  v35 = 0;
  v12 = 0;
  v13 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 76);
  if ( !lpReserved && (!lpClass || lpcchClass) )
  {
    v14 = hKey;
    v15 = RegKrnGetGlobalState();
    v40 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v15 + 176))(v14, &hKey, &v30, &v31);
    if ( !v40 )
    {
      v16 = lpClass;
      v17 = lpcchClass;
      if ( !lpClass && lpcchClass )
        *lpcchClass = 0;
      if ( lpcbMaxClassLen )
        v35 = (int)&v38;
      if ( lpcbSecurityDescriptor )
        v12 = (int)&v34;
      LOWORD(v28) = 0;
      if ( v17 && *v17 )
      {
        HIWORD(v28) = 2 * *(_WORD *)v17;
        v29 = v16;
      }
      else
      {
        HIWORD(v28) = 0;
        v29 = 0;
      }
      if ( !((unsigned __int8)hKey & 1) )
      {
        v40 = LocalBaseRegQueryInfoKey(
                hKey,
                (int)&v28,
                (int)&v33,
                (int)&v37,
                v35,
                (int)&v32,
                (int)&v39,
                (int)&v36,
                v12,
                (int)&v26);
LABEL_15:
        v37 = (unsigned int)v37 >> 1;
        if ( v35 )
          v38 >>= 1;
        v39 = (unsigned int)v39 >> 1;
        if ( v17 )
        {
          if ( (_WORD)v28 )
            *v17 = (unsigned __int16)(v28 & 0xFFFE) != 0 ? ((unsigned int)(unsigned __int16)v28 >> 1) - 1 : 0;
          else
            *v17 = 0;
        }
        if ( lpcSubKeys )
          *lpcSubKeys = v33;
        if ( lpcbMaxSubKeyLen )
          *lpcbMaxSubKeyLen = v37;
        if ( lpcbMaxClassLen )
          *lpcbMaxClassLen = v38;
        if ( lpcValues )
          *lpcValues = v32;
        if ( lpcbMaxValueNameLen )
          *lpcbMaxValueNameLen = v39;
        if ( lpcbMaxValueLen )
          *lpcbMaxValueLen = v36;
        if ( lpcbSecurityDescriptor )
          *lpcbSecurityDescriptor = v34;
        v18 = lpftLastWriteTime;
        if ( lpftLastWriteTime )
        {
          lpftLastWriteTime->dwLowDateTime = v26;
          v18->dwHighDateTime = v27;
        }
        goto LABEL_36;
      }
      if ( !v13 )
        goto LABEL_15;
      v35 = (int)&v38;
      ms_exc.registration.TryLevel = 0;
      v23 = v13((unsigned int)hKey & 0xFFFFFFFE, &v28, &v33, &v37, &v38, &v32, &v39, &v36, &v34, &v26);
      v40 = v23;
      ms_exc.registration.TryLevel = -2;
      if ( (v23 && v23 != 234 || (unsigned int)v37 <= 0x7FFF0000)
        && (v23 && v23 != 234 || v38 <= 0x7FFF0000)
        && (v23 && v23 != 234 || (unsigned int)v39 <= 0x7FFF0000)
        && (v23 && v23 != 234 || (unsigned int)v36 <= 0x7FFF0000)
        && (v23 && v23 != 234 || v34 <= 0x7FFF0000) )
      {
        if ( !v23 )
        {
          lpClass = 0;
          v24 = (unsigned int)hKey & 0xFFFFFFFE;
          v25 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
          if ( v25 && !v25(v24, &lpClass) && ((unsigned int)lpClass < 5 || (unsigned int)lpClass > 0xA) )
          {
            v39 *= 2;
            v36 *= 2;
          }
          v17 = lpcchClass;
        }
        goto LABEL_15;
      }
      v40 = 13;
    }
LABEL_36:
    v19 = v31;
    v20 = v30;
    v21 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v21 + 168))(v20, v19);
    return v40;
  }
  return 87;
}

//----- (77E24B38) --------------------------------------------------------
HANDLE __stdcall OpenEventWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
  return OpenEventW(dwDesiredAccess, bInheritHandle, lpName);
}

//----- (77E24B5B) --------------------------------------------------------
int __stdcall LocalBaseRegEnumValue(PVOID a1, ULONG Index, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // esi@1
  int v8; // edi@1
  ULONG v9; // ebx@7
  PVOID v10; // eax@10
  char *v11; // edi@11
  unsigned int v12; // ecx@14
  unsigned __int16 v13; // ax@16
  NTSTATUS v15; // eax@56
  unsigned __int16 v16; // ax@64
  int (__stdcall *v17)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@67
  ULONG ResultLength; // [sp+Ch] [bp-108h]@12
  int v20; // [sp+10h] [bp-104h]@1
  int v21; // [sp+14h] [bp-100h]@1
  HANDLE KeyHandle; // [sp+18h] [bp-FCh]@1
  PVOID Address; // [sp+1Ch] [bp-F8h]@1
  int v24; // [sp+20h] [bp-F4h]@1
  PVOID v25; // [sp+24h] [bp-F0h]@1
  void *Dst; // [sp+28h] [bp-ECh]@1
  KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass; // [sp+2Ch] [bp-E8h]@7
  NTSTATUS NtStatus; // [sp+30h] [bp-E4h]@12
  char v29; // [sp+34h] [bp-E0h]@33

  v7 = a3;
  v8 = a6;
  v20 = a7;
  v21 = a4;
  Dst = (void *)a5;
  v24 = a6;
  Address = 0;
  v25 = 0;
  KeyHandle = a1;
  if ( a6 && !a5 )
    *(_DWORD *)a6 = 0;
  if ( a1 == (PVOID)-2147483644 || a1 == (PVOID)-2147483568 || a1 == (PVOID)-2147483552 )
  {
    v17 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState()
                                                                                              + 52);
    if ( v17 )
      return v17(a1, Index, v7, 0, v21, Dst, v8, v20);
    return 87;
  }
  if ( (unsigned __int8)a1 & 2 )
  {
    v15 = BaseRegGetClassKeyValueState(a1, Index, (int)&v25);
    if ( v15 < 0 )
      return RtlNtStatusToDosError(v15);
    ValStateGetPhysicalIndexFromLogical((int)v25, (int)a1, Index, (int)&KeyHandle, (int)&Index);
  }
  v9 = *(_WORD *)(v7 + 2);
  KeyValueInformationClass = v8 != 0;
  if ( v8 )
    v9 += *(_DWORD *)v8;
  if ( v9 <= 0xC4 )
  {
    v11 = &v29;
    v9 = 220;
  }
  else
  {
    v10 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9 + 24);
    Address = v10;
    if ( !v10 )
      return 14;
    v11 = (char *)v10;
  }
  NtStatus = NtEnumerateValueKey(KeyHandle, Index, KeyValueInformationClass, v11, v9, &ResultLength);
  if ( NtStatus == -2147483643
    && (KeyValueInformationClass == KeyValueBasicInformation
     && *(_WORD *)(v7 + 2) >= (unsigned int)(*((_DWORD *)v11 + 2) + 2)
     || KeyValueInformationClass == 1
     && *(_WORD *)(v7 + 2) >= (unsigned int)(*((_DWORD *)v11 + 4) + 2)
     && (!Dst || v24 && *(_DWORD *)v24 >= *((_DWORD *)v11 + 3))) )
  {
    NtStatus = ResultLength;
    v11 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ResultLength);
    if ( v11 )
    {
      NtStatus = NtEnumerateValueKey(KeyHandle, Index, KeyValueInformationClass, v11, NtStatus, &ResultLength);
      goto LABEL_13;
    }
    ValStateRelease(v25);
    return 14;
  }
LABEL_13:
  ValStateRelease(v25);
  if ( NtStatus < 0 )
    goto LABEL_45;
  v12 = *(_WORD *)(v7 + 2);
  if ( KeyValueInformationClass == KeyValueBasicInformation )
  {
    if ( v12 >= *((_DWORD *)v11 + 2) + 2 )
    {
      v16 = *((_WORD *)v11 + 4);
      *(_WORD *)v7 = v16;
      memmove(*(void **)(v7 + 4), v11 + 12, v16);
      goto LABEL_17;
    }
LABEL_37:
    NtStatus = -2147483643;
    goto LABEL_18;
  }
  if ( v12 < *((_DWORD *)v11 + 4) + 2 )
    goto LABEL_37;
  v13 = *((_WORD *)v11 + 8);
  *(_WORD *)v7 = v13;
  memmove(*(void **)(v7 + 4), v11 + 20, v13);
LABEL_17:
  *(_WORD *)(*(_DWORD *)(v7 + 4) + 2 * ((unsigned int)*(_WORD *)v7 >> 1)) = 0;
  *(_WORD *)v7 += 2;
LABEL_18:
  if ( NtStatus >= 0 )
  {
    if ( Dst )
    {
      if ( *(_DWORD *)v24 < *((_DWORD *)v11 + 3) )
        NtStatus = -2147483643;
      else
        memmove(Dst, &v11[*((_DWORD *)v11 + 2)], *((_DWORD *)v11 + 3));
    }
    if ( NtStatus >= 0 )
      goto LABEL_23;
  }
LABEL_45:
  if ( NtStatus == -2147483643 )
  {
LABEL_23:
    if ( KeyValueInformationClass )
    {
      if ( v21 )
        *(_DWORD *)v21 = *((_DWORD *)v11 + 1);
      *(_DWORD *)v24 = *((_DWORD *)v11 + 3);
    }
    else if ( v21 )
    {
      *(_DWORD *)v21 = *((_DWORD *)v11 + 1);
    }
  }
  if ( NtStatus < 0 )
  {
    if ( v20 )
      *(_DWORD *)v20 = 0;
  }
  else if ( v20 && v24 )
  {
    *(_DWORD *)v20 = *(_DWORD *)v24;
  }
  if ( Address && v11 != Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v11 != &v29 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v11);
  return RtlNtStatusToDosError(NtStatus);
}

//----- (77E24DAE) --------------------------------------------------------
void __stdcall ValStateRelease(PVOID Address)
{
  void *v1; // eax@3
  int v2; // eax@6

  if ( Address )
  {
    v1 = (void *)*((_DWORD *)Address + 1);
    if ( v1 && v1 != *(void **)Address )
      NtClose(v1);
    v2 = *((_DWORD *)Address + 2);
    if ( v2 && v2 != *(_DWORD *)Address )
      NtClose(*((HANDLE *)Address + 2));
    if ( *((_DWORD *)Address + 6) )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)Address + 6));
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
}

//----- (77E24DC9) --------------------------------------------------------
LSTATUS __stdcall RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  int (__stdcall *v8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // ebx@1
  LPWSTR v9; // edi@5
  HKEY v10; // esi@6
  int v11; // eax@6
  signed __int16 v12; // ax@8
  DWORD v13; // eax@10
  BYTE *v14; // eax@17
  int v15; // esi@25
  int v16; // edi@25
  int v17; // eax@25
  unsigned int v19; // edi@37
  int (__stdcall *v20)(_DWORD, _DWORD); // eax@37
  PVOID v21; // eax@41
  int v22; // eax@43
  int v23; // [sp+10h] [bp-44h]@7
  LPWSTR v24; // [sp+14h] [bp-40h]@9
  int v25; // [sp+20h] [bp-34h]@1
  int v26; // [sp+24h] [bp-30h]@1
  int v27; // [sp+28h] [bp-2Ch]@9
  void *Src; // [sp+2Ch] [bp-28h]@1
  int v29; // [sp+30h] [bp-24h]@12
  LSTATUS v30; // [sp+34h] [bp-20h]@6
  size_t Size; // [sp+38h] [bp-1Ch]@11
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@43

  v25 = 0;
  Src = 0;
  v26 = 0;
  v8 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 72);
  if ( lpReserved || lpData && !lpcbData )
    return 87;
  if ( !lpcchValueName )
    return 87;
  v9 = lpValueName;
  if ( !lpValueName )
    return 87;
  v10 = hKey;
  v11 = RegKrnGetGlobalState();
  v30 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v11 + 176))(v10, &hKey, &v25, &v26);
  if ( !v30 )
  {
    LOWORD(v23) = 0;
    if ( (*lpcchValueName & 0x7FFFFFFF) > 0x7FFF )
      v12 = -2;
    else
      v12 = 2 * *(_WORD *)lpcchValueName;
    HIWORD(v23) = v12;
    v24 = v9;
    v27 = 0;
    if ( lpcbData )
      v13 = *lpcbData;
    else
      v13 = 0;
    Size = v13;
    lpValueName = (LPWSTR)v13;
    if ( !((unsigned __int8)hKey & 1) )
    {
      v30 = LocalBaseRegEnumValue(hKey, dwIndex, (int)&v23, (int)&v29, (int)lpData, (int)&Size, (int)&v27);
LABEL_13:
      if ( !v30 && lpData && (v29 == 1 || v29 == 2 || v29 == 7) && Size > 2 )
      {
        v14 = &lpData[2 * (Size >> 1)];
        if ( *((_WORD *)v14 - 1) )
        {
          if ( Size + 2 <= *lpcbData )
            *(_WORD *)v14 = 0;
        }
      }
      if ( (unsigned __int16)v23 >= 2u )
        *lpcchValueName = ((unsigned int)(unsigned __int16)v23 >> 1) - 1;
      if ( lpcbData )
        *lpcbData = Size;
      if ( lpType )
        *lpType = v29;
      goto LABEL_24;
    }
    if ( !v8 )
      goto LABEL_13;
    lpReserved = 0;
    v19 = (unsigned int)hKey & 0xFFFFFFFE;
    v20 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
    if ( !v20 || v20(v19, &lpReserved) || (unsigned int)lpReserved >= 5 && (unsigned int)lpReserved <= 0xA )
    {
      ms_exc.registration.TryLevel = 1;
      v30 = v8((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &v23, &v29, lpData, &Size, &v27);
      ms_exc.registration.TryLevel = -2;
      if ( v30 && v30 != 234 || Size <= 0x7FFF0000 )
        goto LABEL_13;
    }
    else
    {
      v21 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size + 2);
      Src = v21;
      if ( !v21 )
      {
        v30 = 8;
        goto LABEL_24;
      }
      ms_exc.registration.TryLevel = 0;
      v22 = v8((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &v23, &v29, v21, &Size, &v27);
      v30 = v22;
      ms_exc.registration.TryLevel = -2;
      if ( v22 && v22 != 234 || Size <= 0x7FFF0000 )
      {
        if ( !v22 )
        {
          if ( (v29 == 1 || v29 == 7 || v29 == 2) && Size >= 2 )
            Size -= 2;
          if ( Size > (unsigned int)lpValueName )
            v30 = 13;
          else
            memcpy(lpData, Src, Size);
        }
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
        Src = 0;
        goto LABEL_13;
      }
    }
    v30 = 13;
  }
LABEL_24:
  if ( Src )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
  v15 = v26;
  v16 = v25;
  v17 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v17 + 168))(v16, v15);
  return v30;
}

//----- (77E24F88) --------------------------------------------------------
BOOLEAN __stdcall BaseRegReleaseKeySemantics(int a1)
{
  BOOLEAN result; // al@1

  result = a1;
  if ( *(_BYTE *)a1 & 0x20 )
    result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(a1 + 16));
  return result;
}

//----- (77E250C4) --------------------------------------------------------
LSTATUS __stdcall RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
{
  int v5; // ebx@0
  int v6; // edi@0
  LSTATUS v7; // esi@1
  int v8; // eax@4
  LSTATUS v9; // ebx@4
  int v10; // eax@7
  int v11; // edi@9
  int v12; // ebx@9
  int v13; // eax@9
  LSTATUS result; // eax@9
  int v15; // eax@15
  int v16; // eax@16
  HANDLE KeyHandle; // [sp+4h] [bp-Ch]@4
  int v19; // [sp+8h] [bp-8h]@1
  int v20; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  v19 = 0;
  v20 = 0;
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  if ( fAsynchronous && !hEvent )
    return 87;
  v8 = RegKrnGetGlobalState();
  v9 = (*(int (__stdcall **)(HKEY, HANDLE *, int *, int *, int, int))(v8 + 176))(hKey, &KeyHandle, &v19, &v20, v6, v5);
  if ( v9 )
  {
    v15 = RegKrnGetGlobalState();
    (*(void (**)(void))(v15 + 168))();
    result = v9;
  }
  else if ( (unsigned __int8)KeyHandle & 1 )
  {
    v16 = RegKrnGetGlobalState();
    (*(void (**)(void))(v16 + 168))();
    result = 6;
  }
  else
  {
    if ( (unsigned __int8)KeyHandle & 2 )
      v10 = BaseRegNotifyClassKey(
              KeyHandle,
              (int)hEvent,
              (int)&LocalIoStatusBlock,
              dwNotifyFilter,
              bWatchSubtree,
              fAsynchronous);
    else
      v10 = NtNotifyChangeKey(
              KeyHandle,
              hEvent,
              0,
              0,
              &LocalIoStatusBlock,
              dwNotifyFilter,
              bWatchSubtree,
              0,
              0,
              fAsynchronous);
    if ( v10 < 0 && v10 != 259 )
      v7 = RtlNtStatusToDosError(v10);
    v11 = v20;
    v12 = v19;
    v13 = RegKrnGetGlobalState();
    (*(void (__cdecl **)(int, int))(v13 + 168))(v12, v11);
    result = v7;
  }
  return result;
}
// 77E250C4: could not find valid save-restore pair for ebx
// 77E250C4: could not find valid save-restore pair for edi

//----- (77E25189) --------------------------------------------------------
HMODULE __stdcall LoadLibraryExWStub(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
{
  return LoadLibraryExW(lpLibFileName, hFile, dwFlags);
}

//----- (77E25199) --------------------------------------------------------
ULONG __stdcall LocalBaseRegEnumKey(int a1, ULONG Index, int a3, int a4, int a5)
{
  int v5; // eax@20
  void *v6; // eax@20
  NTSTATUS v7; // eax@20
  int v8; // eax@1
  char *v9; // esi@4
  void *v10; // ecx@8
  unsigned __int16 v11; // ax@11
  unsigned __int16 v13; // ax@27
  int v14; // eax@31
  void *v15; // eax@31
  NTSTATUS v16; // eax@31
  int (__stdcall *v17)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@35
  signed int v19; // [sp+Ch] [bp-13Ch]@4
  int KeyInformationClass; // [sp+14h] [bp-134h]@4
  ULONG ResultLength; // [sp+1Ch] [bp-12Ch]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-128h]@5
  char KeyInformation; // [sp+24h] [bp-124h]@4

  v8 = a1;
  ResultLength = 0;
  if ( a1 == -2147483644 || a1 == -2147483568 || a1 == -2147483552 )
  {
    v17 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 48);
    if ( v17 )
      return v17(a1, Index, a3, 0, a4, a5);
    return 87;
  }
  v9 = &KeyInformation;
  v19 = 0;
  KeyInformationClass = *(_DWORD *)(a4 + 4) != 0;
  if ( !(a1 & 2) )
    goto LABEL_5;
  v5 = RegKrnGetGlobalState();
  v6 = (void *)(*(int (**)(void))(v5 + 164))();
  EnumTableGetNextEnum(v6, a1, Index, KeyInformationClass, (int)&KeyInformation, 288, (int)&ResultLength);
  NtStatus = v7;
  if ( v7 >= 0 && !ResultLength )
  {
    v8 = a1;
LABEL_5:
    NtStatus = NtEnumerateKey(
                 (HANDLE)v8,
                 Index,
                 (KEY_INFORMATION_CLASS)KeyInformationClass,
                 &KeyInformation,
                 0x120u,
                 &ResultLength);
    goto LABEL_6;
  }
  v19 = 1;
LABEL_6:
  if ( NtStatus != -2147483643 )
    goto LABEL_7;
  NtStatus = ResultLength;
  v9 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ResultLength);
  if ( !v9 )
    return 14;
  if ( v19 )
  {
    v14 = RegKrnGetGlobalState();
    v15 = (void *)(*(int (**)(void))(v14 + 164))();
    EnumTableGetNextEnum(v15, a1, Index, KeyInformationClass, (int)v9, NtStatus, (int)&ResultLength);
  }
  else
  {
    v16 = NtEnumerateKey((HANDLE)a1, Index, (KEY_INFORMATION_CLASS)KeyInformationClass, v9, NtStatus, &ResultLength);
  }
  NtStatus = v16;
LABEL_7:
  if ( NtStatus >= 0 )
  {
    v10 = *(void **)(a3 + 4);
    if ( KeyInformationClass )
    {
      if ( v10
        && *(_WORD *)(a3 + 2) >= (unsigned int)(*((_DWORD *)v9 + 5) + 2)
        && *(_DWORD *)(a4 + 4)
        && *(_WORD *)(a4 + 2) >= (unsigned int)(*((_DWORD *)v9 + 4) + 2) )
      {
        v13 = *((_WORD *)v9 + 10);
        *(_WORD *)a3 = v13;
        memmove(v10, v9 + 24, v13);
        *(_WORD *)(*(_DWORD *)(a3 + 4) + 2 * ((unsigned int)*(_WORD *)a3 >> 1)) = 0;
        *(_WORD *)a3 += 2;
        *(_WORD *)a4 = *((_WORD *)v9 + 8);
        memmove(*(void **)(a4 + 4), &v9[*((_DWORD *)v9 + 3)], *((_DWORD *)v9 + 4));
        *(_WORD *)(*(_DWORD *)(a4 + 4) + 2 * ((unsigned int)*(_WORD *)a4 >> 1)) = 0;
        *(_WORD *)a4 += 2;
LABEL_12:
        if ( a5 )
        {
          *(_DWORD *)a5 = *(_DWORD *)v9;
          *(_DWORD *)(a5 + 4) = *((_DWORD *)v9 + 1);
        }
        goto LABEL_13;
      }
    }
    else if ( v10 && *(_WORD *)(a3 + 2) >= (unsigned int)(*((_DWORD *)v9 + 3) + 2) )
    {
      v11 = *((_WORD *)v9 + 6);
      *(_WORD *)a3 = v11;
      memmove(v10, v9 + 16, v11);
      *(_WORD *)(*(_DWORD *)(a3 + 4) + 2 * ((unsigned int)*(_WORD *)a3 >> 1)) = 0;
      *(_WORD *)a3 += 2;
      goto LABEL_12;
    }
    NtStatus = -2147483643;
    goto LABEL_12;
  }
LABEL_13:
  if ( v9 != &KeyInformation )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
  return RtlNtStatusToDosError(NtStatus);
}

//----- (77E252E7) --------------------------------------------------------
LSTATUS __stdcall RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
{
  int (__stdcall *v8)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // ebx@1
  LPWSTR v9; // edi@2
  HKEY v10; // esi@4
  int v11; // eax@4
  signed __int16 v12; // ax@6
  __int16 v13; // ax@8
  int v14; // esi@17
  int v15; // edi@17
  int v16; // eax@17
  LSTATUS result; // eax@17
  int v18; // [sp+10h] [bp-38h]@5
  LPWSTR v19; // [sp+14h] [bp-34h]@7
  int v20; // [sp+18h] [bp-30h]@7
  LPWSTR v21; // [sp+1Ch] [bp-2Ch]@8
  int v22; // [sp+24h] [bp-24h]@1
  int v23; // [sp+28h] [bp-20h]@1
  LSTATUS v24; // [sp+2Ch] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@28

  v22 = 0;
  v23 = 0;
  v8 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 68);
  if ( lpReserved || (v9 = lpClass) != 0 && !lpcchClass || !lpcchName )
  {
    result = 87;
  }
  else
  {
    v10 = hKey;
    v11 = RegKrnGetGlobalState();
    v24 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v11 + 176))(v10, &hKey, &v22, &v23);
    if ( !v24 )
    {
      LOWORD(v18) = 0;
      if ( (*lpcchName & 0x7FFFFFFF) > 0x7FFF )
        v12 = -2;
      else
        v12 = 2 * *(_WORD *)lpcchName;
      HIWORD(v18) = v12;
      v19 = lpName;
      LOWORD(v20) = 0;
      if ( v9 )
      {
        v13 = 2 * *(_WORD *)lpcchClass;
        v21 = v9;
      }
      else
      {
        v13 = 0;
        v21 = 0;
      }
      HIWORD(v20) = v13;
      if ( (unsigned __int8)hKey & 1 )
      {
        if ( v8 )
        {
          ms_exc.registration.TryLevel = 0;
          v24 = v8((unsigned int)hKey & 0xFFFFFFFE, dwIndex, &v18, &v20, lpftLastWriteTime);
          ms_exc.registration.TryLevel = -2;
        }
      }
      else
      {
        v24 = LocalBaseRegEnumKey((int)hKey, dwIndex, (int)&v18, (int)&v20, (int)lpftLastWriteTime);
      }
      if ( (unsigned __int16)v18 >= 2u )
        LOWORD(v18) = v18 - 2;
      if ( (unsigned __int16)v20 >= 2u )
        LOWORD(v20) = v20 - 2;
      if ( !v24 )
        *lpcchName = (unsigned int)(unsigned __int16)v18 >> 1;
      if ( lpcchClass )
        *lpcchClass = (unsigned int)(unsigned __int16)v20 >> 1;
    }
    v14 = v23;
    v15 = v22;
    v16 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v16 + 168))(v15, v14);
    result = v24;
  }
  return result;
}

//----- (77E25421) --------------------------------------------------------
BOOL __stdcall SetProcessShutdownParametersStub(DWORD dwLevel, DWORD dwFlags)
{
  return SetProcessShutdownParameters(dwLevel, dwFlags);
}

//----- (77E25475) --------------------------------------------------------
BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
{
  NTSTATUS v2; // eax@2

  if ( hActCtx == (HANDLE)-1 )
  {
    BaseSetLastNTError(-1073741811);
  }
  else
  {
    v2 = RtlActivateActivationContext(0, hActCtx, lpCookie);
    if ( v2 >= 0 )
      return 1;
    BaseSetLastNTError(v2);
  }
  return 0;
}
// 77DE1198: using guessed type int __stdcall RtlActivateActivationContext(_DWORD, _DWORD, _DWORD);

//----- (77E254DA) --------------------------------------------------------
int __stdcall CompareStringOrdinalStub(LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, BOOL bIgnoreCase)
{
  return CompareStringOrdinal(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
}

//----- (77E254F2) --------------------------------------------------------
BOOL __stdcall DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
{
  signed int v2; // eax@1
  BOOL result; // eax@3

  v2 = 0;
  if ( dwFlags & 0xFFFFFFFE )
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  else
  {
    if ( dwFlags & 1 )
      v2 = 1;
    RtlDeactivateActivationContext(v2, ulCookie);
    result = 1;
  }
  return result;
}
// 77DE1194: using guessed type int __stdcall RtlDeactivateActivationContext(_DWORD, _DWORD);

//----- (77E25526) --------------------------------------------------------
HANDLE __stdcall OpenEventAStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
{
  return OpenEventA(dwDesiredAccess, bInheritHandle, lpName);
}

//----- (77E2553E) --------------------------------------------------------
BOOL __stdcall IsWow64ProcessStub(HANDLE hProcess, PBOOL Wow64Process)
{
  return IsWow64Process(hProcess, Wow64Process);
}

//----- (77E2554E) --------------------------------------------------------
BOOL __stdcall IsDBCSLeadByteStub(BYTE TestChar)
{
  return IsDBCSLeadByte(TestChar);
}

//----- (77E25565) --------------------------------------------------------
DWORD __stdcall GetLogicalDrives()
{
  NTSTATUS v0; // eax@1
  DWORD result; // eax@3
  DWORD ProcessInformation; // [sp+0h] [bp-24h]@1

  v0 = NtQueryInformationProcess((HANDLE)0xFFFFFFFF, ProcessDeviceMap, &ProcessInformation, 0x24u, 0);
  if ( v0 < 0 )
  {
    BaseSetLastNTError(v0);
    result = 0;
  }
  else
  {
    if ( !ProcessInformation )
      RtlSetLastWin32Error(0);
    result = ProcessInformation;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E255AF) --------------------------------------------------------
HANDLE __stdcall OpenProcessStub(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
  return OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
}

//----- (77E255C7) --------------------------------------------------------
BOOL __stdcall GetModuleHandleExWStub(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
{
  return GetModuleHandleExW(dwFlags, lpModuleName, phModule);
}

//----- (77E255DF) --------------------------------------------------------
HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
  return FindResourceExW(hModule, lpType, lpName, 0);
}

//----- (77E255FD) --------------------------------------------------------
DWORD __stdcall SizeofResourceStub(HMODULE hModule, HRSRC hResInfo)
{
  return SizeofResource(hModule, hResInfo);
}

//----- (77E2560D) --------------------------------------------------------
BOOL __stdcall SetWaitableTimerStub(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
{
  return SetWaitableTimer(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
}

//----- (77E25625) --------------------------------------------------------
int __stdcall InternalInitAtomTable(int a1)
{
  int result; // eax@2
  LONG v2; // esi@5
  LONG Exchange; // [sp+0h] [bp-4h]@1

  Exchange = BaseLocalAtomTable;
  if ( BaseLocalAtomTable )
    goto LABEL_2;
  result = RtlCreateAtomTable(0, &Exchange);
  if ( result >= 0 )
  {
    v2 = InterlockedCompareExchange(&BaseLocalAtomTable, Exchange, 0);
    if ( v2 )
    {
      RtlDestroyAtomTable(Exchange);
      Exchange = v2;
    }
LABEL_2:
    *(_DWORD *)a1 = Exchange;
    result = 0;
  }
  return result;
}
// 77DE14E0: using guessed type int __stdcall RtlCreateAtomTable(_DWORD, _DWORD);
// 77DE14E4: using guessed type int __stdcall RtlDestroyAtomTable(_DWORD);

//----- (77E25674) --------------------------------------------------------
__int16 __stdcall InternalAddAtom(int a1, char a2, PCSZ SourceString)
{
  __int16 result; // ax@1
  LSA_UNICODE_STRING *v4; // esi@3
  int v5; // eax@3
  int v6; // eax@6
  STRING DestinationString; // [sp+10h] [bp-34h]@11
  LSA_UNICODE_STRING UnicodeString; // [sp+18h] [bp-2Ch]@3
  int v9; // [sp+24h] [bp-20h]@4
  LSA_UNICODE_STRING *v10; // [sp+28h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@2

  result = (signed __int16)SourceString;
  if ( (unsigned int)SourceString <= 0xFFFF )
  {
    SourceString = (PCSZ)(unsigned __int16)SourceString;
    if ( (unsigned __int16)SourceString < 0xC000u )
      return result;
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( a2 )
  {
    v4 = &UnicodeString;
    v10 = &UnicodeString;
    RtlInitUnicodeString(&UnicodeString, (PCWSTR)SourceString);
    v5 = 0;
  }
  else
  {
    RtlInitAnsiString(&DestinationString, SourceString);
    v4 = &UnicodeString;
    v10 = &UnicodeString;
    v5 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  }
  v9 = v5;
  ms_exc.registration.TryLevel = -2;
  if ( v5 < 0 )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  SourceString = 0;
  ms_exc.registration.TryLevel = 1;
  if ( !(_BYTE)a1 )
  {
    v6 = NtAddAtom(v4->Buffer, v4->Length, (PUSHORT)&SourceString);
LABEL_8:
    if ( v6 >= 0 )
      goto LABEL_9;
    goto LABEL_17;
  }
  v6 = InternalInitAtomTable((int)&a1);
  if ( v6 >= 0 )
  {
    v6 = RtlAddAtomToAtomTable(a1, v4->Buffer, &SourceString);
    goto LABEL_8;
  }
LABEL_17:
  BaseSetLastNTError(v6);
  SourceString = 0;
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( !a2 && v4 == &UnicodeString )
    RtlFreeUnicodeString(v4);
  return (signed __int16)SourceString;
}
// 77DE14D8: using guessed type int __stdcall RtlAddAtomToAtomTable(_DWORD, _DWORD, _DWORD);

//----- (77E257BD) --------------------------------------------------------
LPVOID __stdcall LocalLockStub(HLOCAL hMem)
{
  return LocalLock(hMem);
}

//----- (77E257D5) --------------------------------------------------------
BOOL __stdcall LocalUnlockStub(HLOCAL hMem)
{
  return LocalUnlock(hMem);
}

//----- (77E257ED) --------------------------------------------------------
HANDLE __stdcall CreateActCtxW(PCACTCTXW pActCtx)
{
  ULONG v1; // edi@2
  unsigned int v2; // eax@2
  DWORD v3; // ecx@3
  int v4; // ebx@14
  USHORT v5; // ax@16
  PWSTR v6; // ebx@23
  ULONG v7; // eax@28
  WCHAR *v8; // eax@31
  int v9; // ecx@31
  __int16 v10; // cx@33
  int v11; // eax@37
  int v12; // eax@42
  WCHAR *v13; // eax@45
  WCHAR *v14; // eax@50
  __int16 *v15; // eax@55
  unsigned int v17; // eax@75
  unsigned int v18; // ecx@76
  int v19; // eax@97
  ULONG v20; // eax@105
  ULONG v21; // eax@109
  void *v22; // eax@113
  __int16 *v23; // eax@119
  int v24; // edx@119
  unsigned __int16 v25; // ax@124
  __int16 v26; // cx@124
  int v27; // eax@124
  __int16 v28; // ax@127
  int v29; // eax@127
  unsigned int v30; // eax@134
  unsigned int v31; // ebx@134
  ULONG v32; // esi@134
  void *v33; // ecx@136
  size_t v34; // ebx@137
  PVOID v35; // ST0C_4@139
  int v36; // eax@139
  PVOID i; // eax@134
  WCHAR *v38; // esi@140
  int v39; // eax@144
  int v40; // eax@152
  size_t *v41; // esi@153
  int v42; // eax@153
  int v43; // eax@153
  __int16 v44; // ax@156
  ULONG v45; // eax@168
  CHAR *v46; // [sp-10h] [bp-37Ch]@115
  ULONG v47; // [sp-Ch] [bp-378h]@27
  CHAR *v48; // [sp-Ch] [bp-378h]@93
  int v49; // [sp-Ch] [bp-378h]@115
  WCHAR *v50; // [sp-8h] [bp-374h]@27
  int v51; // [sp-8h] [bp-374h]@93
  void *v52; // [sp-8h] [bp-374h]@115
  PCWSTR v53; // [sp-4h] [bp-370h]@93
  ULONG v54; // [sp-4h] [bp-370h]@115
  LSA_UNICODE_STRING v55; // [sp+Ch] [bp-360h]@176
  LSA_UNICODE_STRING v56; // [sp+14h] [bp-358h]@178
  LSA_UNICODE_STRING UnicodeString; // [sp+1Ch] [bp-350h]@175
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-348h]@119
  PPEB v59; // [sp+2Ch] [bp-340h]@1
  int v60; // [sp+30h] [bp-33Ch]@1
  PCACTCTXW v61; // [sp+34h] [bp-338h]@1
  int v62; // [sp+38h] [bp-334h]@1
  DWORD v63; // [sp+3Ch] [bp-330h]@3
  PVOID Address; // [sp+40h] [bp-32Ch]@1
  void *v65; // [sp+44h] [bp-328h]@1
  int v66; // [sp+48h] [bp-324h]@1
  int v67; // [sp+4Ch] [bp-320h]@1
  DWORD v68; // [sp+50h] [bp-31Ch]@1
  WCHAR *dosname; // [sp+54h] [bp-318h]@14
  USHORT v70; // [sp+58h] [bp-314h]@17
  LANGID v71; // [sp+5Ah] [bp-312h]@95
  PWSTR Path; // [sp+5Ch] [bp-310h]@23
  int v73; // [sp+60h] [bp-30Ch]@38
  PCWSTR SourceString; // [sp+64h] [bp-308h]@96
  HMODULE hModule; // [sp+68h] [bp-304h]@19
  void *Dst; // [sp+6Ch] [bp-300h]@6
  unsigned int v77; // [sp+70h] [bp-2FCh]@7
  void *v78; // [sp+74h] [bp-2F8h]@4
  LONG Exchange; // [sp+78h] [bp-2F4h]@1
  int v80; // [sp+7Ch] [bp-2F0h]@1
  __int16 *v81; // [sp+80h] [bp-2ECh]@56
  __int16 *v82; // [sp+84h] [bp-2E8h]@55
  __int16 *v83; // [sp+88h] [bp-2E4h]@55
  unsigned int v84; // [sp+8Ch] [bp-2E0h]@119
  unsigned int v85; // [sp+90h] [bp-2DCh]@57
  __int16 v86; // [sp+9Eh] [bp-2CEh]@1
  int v87; // [sp+A0h] [bp-2CCh]@1
  void *Src; // [sp+A4h] [bp-2C8h]@27
  LPWSTR lpFilename; // [sp+A8h] [bp-2C4h]@27
  WCHAR *v90; // [sp+ACh] [bp-2C0h]@27
  unsigned int v91; // [sp+B0h] [bp-2BCh]@27
  unsigned int v92; // [sp+B4h] [bp-2B8h]@27
  __int16 v93; // [sp+C2h] [bp-2AAh]@1
  int v94; // [sp+C4h] [bp-2A8h]@1
  WCHAR *v95; // [sp+C8h] [bp-2A4h]@31
  WCHAR *v96; // [sp+CCh] [bp-2A0h]@31
  __int16 *v97; // [sp+D0h] [bp-29Ch]@31
  unsigned int v98; // [sp+D4h] [bp-298h]@31
  unsigned int v99; // [sp+D8h] [bp-294h]@31
  __int16 v100; // [sp+E6h] [bp-286h]@1
  __int16 v101; // [sp+E8h] [bp-284h]@119
  __int16 v102; // [sp+168h] [bp-204h]@31
  WCHAR buf; // [sp+268h] [bp-104h]@27

  LOWORD(v94) = 0;
  v65 = (void *)-1;
  v67 = 32;
  memset(&v68, 0, 0x1Cu);
  memset((char *)&v94 + 2, 0, 0x20u);
  v100 = 0;
  LOWORD(v87) = 0;
  memset((char *)&v87 + 2, 0, 0x20u);
  v93 = 0;
  LOWORD(v80) = 0;
  memset((char *)&v80 + 2, 0, 0x20u);
  v61 = pActCtx;
  v62 = 0;
  Exchange = 0;
  Address = 0;
  v59 = 0;
  v86 = 0;
  v60 = 0;
  v66 = 0;
  if ( !pActCtx
    || (v1 = pActCtx->cbSize,
        v2 = (unsigned int)((char *)&pActCtx->cbSize + pActCtx->cbSize),
        (unsigned int)&pActCtx->wProcessorArchitecture > v2) )
  {
    v54 = pActCtx->cbSize;
    v52 = (void *)pActCtx;
    v49 = (int)"CreateActCtxW";
    v46 = "SXS: %s() Null %p or size 0x%lx too small\n";
    goto LABEL_173;
  }
  v3 = pActCtx->dwFlags;
  v63 = v3;
  v68 = v3;
  if ( v3 & 0xFFFFFF00
    || (v78 = (void *)(v3 & 1)) != 0 && (unsigned int)&pActCtx->wLangId > v2
    || v68 & 2 && (unsigned int)&pActCtx->lpAssemblyDirectory > v2
    || (Dst = (void *)(v68 & 4)) != 0 && (unsigned int)&pActCtx->lpResourceName > v2
    || (v77 = v68 & 8) != 0 && (unsigned int)&pActCtx->lpApplicationName > v2
    || v68 & 0x20 && (unsigned int)&pActCtx->hModule > v2
    || v68 & 0x80 && (unsigned int)&pActCtx[1] > v2 )
  {
    v54 = v1;
    v52 = (void *)v63;
    v49 = (int)"CreateActCtxW";
    v46 = "SXS: %s() Bad flags/size 0x%lx/0x%lx\n";
    goto LABEL_173;
  }
  if ( v68 & 0x40 && (v68 & 0x80 || v77) )
    goto LABEL_88;
  if ( v68 & 0x10 )
  {
    v59 = NtCurrentTeb()->ProcessEnvironmentBlock;
    if ( v59[1].AtlThunkSListPtr )
    {
      v4 = -1072365554;
      goto LABEL_44;
    }
  }
  v4 = (int)pActCtx->lpSource;
  dosname = (WCHAR *)v4;
  if ( !v4 && !(v68 & 0x80) && !Dst )
    goto LABEL_88;
  if ( v78 )
  {
    v5 = pActCtx->wProcessorArchitecture;
    if ( v5 != -1 && v5 )
    {
      v53 = (PCWSTR)pActCtx->wProcessorArchitecture;
      v51 = (int)"CreateActCtxW";
      v48 = "SXS: %s() bad wProcessorArchitecture 0x%x\n";
      goto LABEL_94;
    }
  }
  else
  {
    v5 = 0;
    v68 |= 1u;
  }
  v70 = v5;
  if ( v68 & 2 )
    v71 = pActCtx->wLangId;
  if ( v68 & 0x80 )
    hModule = pActCtx->hModule;
  v77 = v68 & 0x20;
  if ( v68 & 0x20 )
    SourceString = pActCtx->lpApplicationName;
  if ( !v4 && v68 & 0x80 )
  {
    lpFilename = &buf;
    v90 = &buf;
    Src = &buf;
    buf = 0;
    v87 = 0x1000000;
    v91 = 256;
    v92 = 256;
    v17 = GetModuleFileNameW(hModule, &buf, 0x80u);
    if ( !v17 )
      goto LABEL_59;
    while ( 1 )
    {
      v18 = v91;
      if ( v17 < v91 >> 1 )
        break;
      v19 = 4 * v17 + 2;
      if ( (unsigned int)v19 > 0xFFFE )
        goto LABEL_120;
      if ( v19 > v91 )
      {
        if ( RtlpEnsureBufferSize(0, &lpFilename, v19) < 0 )
          goto LABEL_141;
        v18 = v91;
      }
      Src = lpFilename;
      HIWORD(v87) = v91;
      v17 = GetModuleFileNameW(hModule, lpFilename, v18 >> 1);
      if ( !v17 )
        goto LABEL_59;
    }
    LOWORD(v87) = 2 * v17;
    dosname = (WCHAR *)Src;
    v66 = 1;
  }
  if ( v68 & 4 )
  {
    v6 = (PWSTR)v61->lpAssemblyDirectory;
    Path = (PWSTR)v61->lpAssemblyDirectory;
  }
  else
  {
    v6 = Path;
  }
  if ( v68 & 0x40 )
  {
    if ( !v6 )
    {
      v96 = (WCHAR *)&v102;
      v97 = &v102;
      v95 = (WCHAR *)&v102;
      v98 = 256;
      v99 = 256;
      v102 = 0;
      v94 = 0x1000000;
      if ( (unsigned int)*(_WORD *)(KernelBaseGetGlobalData() + 52) + 2 <= 0xFFFE )
      {
        if ( *(_WORD *)(KernelBaseGetGlobalData() + 52) + (unsigned int)(unsigned __int16)v94 + 2 > v98 )
        {
          v40 = KernelBaseGetGlobalData();
          if ( RtlpEnsureBufferSize(0, &v96, *(_WORD *)(v40 + 52) + (unsigned __int16)v94 + 2) < 0 )
            goto LABEL_141;
        }
        v95 = v96;
        v41 = (size_t *)(KernelBaseGetGlobalData() + 52);
        v42 = KernelBaseGetGlobalData();
        _memmove(&v95[(unsigned int)(unsigned __int16)v94 >> 1], *(const void **)(v42 + 56), *(_WORD *)v41);
        HIWORD(v94) = v94 + *(_WORD *)(KernelBaseGetGlobalData() + 52) + 2;
        LOWORD(v94) = *(_WORD *)(KernelBaseGetGlobalData() + 52) + v94;
        v95[(unsigned int)(unsigned __int16)v94 >> 1] = 0;
        v43 = (unsigned __int16)v94 + 16;
        if ( (unsigned int)v43 <= 0xFFFE )
        {
          if ( v43 <= v98 || RtlpEnsureBufferSize(0, &v96, (unsigned __int16)v94 + 16) >= 0 )
          {
            v95 = v96;
            _memmove(&v96[(unsigned int)(unsigned __int16)v94 >> 1], L"\\WinSxs", 0xEu);
            v44 = v94 + 16;
            LOWORD(v94) = v94 + 14;
            HIWORD(v94) = v44;
LABEL_34:
            v68 |= 4u;
            v95[(unsigned int)(unsigned __int16)v94 >> 1] = 0;
            Path = v95;
            goto LABEL_35;
          }
          goto LABEL_141;
        }
      }
LABEL_120:
      v4 = -1073741562;
      goto LABEL_59;
    }
    goto LABEL_35;
  }
  if ( !(v68 & 4) )
  {
    if ( !v66 )
    {
      lpFilename = &buf;
      v90 = &buf;
      Src = &buf;
      buf = 0;
      v87 = 0x1000000;
      v50 = &buf;
      v91 = 256;
      v92 = 256;
      v47 = 256;
      while ( 1 )
      {
        v7 = RtlGetFullPathName_U(dosname, v47, v50, 0);
        if ( !v7 )
          goto LABEL_141;
        if ( v7 <= v91 )
        {
          LOWORD(v87) = v7;
          dosname = (WCHAR *)Src;
          break;
        }
        v39 = v7 + 2;
        if ( (unsigned int)v39 > 0xFFFE )
          goto LABEL_120;
        if ( v39 > v91 && RtlpEnsureBufferSize(0, &lpFilename, v39) < 0 )
          goto LABEL_141;
        v50 = lpFilename;
        v47 = v91;
        Src = lpFilename;
        HIWORD(v87) = v91;
      }
    }
    v8 = (WCHAR *)&v102;
    v97 = &v102;
    v95 = (WCHAR *)&v102;
    v102 = 0;
    v94 = 0x1000000;
    v9 = (unsigned __int16)v87 + 2;
    v96 = (WCHAR *)&v102;
    v98 = 256;
    v99 = 256;
    if ( (unsigned int)v9 <= 0xFFFE )
    {
      if ( (unsigned int)v9 <= 0x100 )
        goto LABEL_33;
      if ( RtlpEnsureBufferSize(0, &v96, (unsigned __int16)v87 + 2) >= 0 )
      {
        v8 = v96;
LABEL_33:
        v95 = v8;
        _memmove(&v8[(unsigned int)(unsigned __int16)v94 >> 1], Src, (unsigned __int16)v87);
        v10 = v94 + v87 + 2;
        LOWORD(v94) = v94 + v87;
        HIWORD(v94) = v10;
        v95[(unsigned int)(unsigned __int16)v94 >> 1] = 0;
        v4 = RtlpApplyLengthFunction(0, 36, &v94, RtlGetLengthWithoutLastFullDosOrNtPathElement);
        if ( v4 < 0 )
          goto LABEL_59;
        goto LABEL_34;
      }
LABEL_141:
      v4 = -1073741801;
      goto LABEL_59;
    }
    goto LABEL_120;
  }
  if ( !v6 || !*v6 )
  {
    v53 = v6;
    v51 = (int)"CreateActCtxW";
    v48 = "SXS: %s() Bad lpAssemblyDirectory %ls\n";
    goto LABEL_94;
  }
  v20 = RtlDetermineDosPathNameType_U(v6);
  if ( v20 != 1 && v20 != 2 && v20 != 6 )
    goto LABEL_174;
  if ( !dosname )
  {
    if ( !v77 )
    {
      v78 = L"Application.Manifest";
LABEL_134:
      v30 = wcslen(v6);
      v77 = v30;
      v66 = v6[v30 - 1] != 92;
      v31 = wcslen((const unsigned __int16 *)v78);
      v32 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
      v63 = v66 != 0;
      for ( i = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v32, 2 * (v77 + v31 + v63) + 2);
            ;
            i = RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  *(_DWORD *)(v36 + 44),
                  2 * (v77 + v63) + 42) )
      {
        v38 = (WCHAR *)i;
        Address = i;
        if ( !i )
          break;
        memcpy(i, Path, 2 * v77);
        Dst = &v38[v77];
        if ( v66 )
        {
          v33 = Dst;
          Dst = (char *)Dst + 2;
          *(_WORD *)v33 = 92;
        }
        v34 = 2 * v31;
        memcpy(Dst, v78, v34);
        *(_WORD *)((char *)Dst + v34) = 0;
        if ( RtlDoesFileExists_U(v38) || v78 != v81 )
        {
          dosname = v38;
          goto LABEL_35;
        }
        v31 = 20;
        v35 = NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1];
        v78 = L"Application.Manifest";
        RtlFreeHeap(v35, 0, v38);
        v36 = KernelBaseGetGlobalData();
      }
      goto LABEL_141;
    }
    if ( SourceString && *SourceString )
    {
      RtlInitUnicodeString(&DestinationString, SourceString);
      v23 = &v101;
      v83 = &v101;
      v81 = &v101;
      v101 = 0;
      v80 = 0x800000;
      v24 = DestinationString.Length + 2;
      v82 = &v101;
      v84 = 128;
      v85 = 128;
      if ( (unsigned int)v24 > 0xFFFE )
        goto LABEL_120;
      if ( (unsigned int)v24 > 0x80 )
      {
        if ( RtlpEnsureBufferSize(0, &v82, DestinationString.Length + 2) < 0 )
          goto LABEL_141;
        v23 = v82;
      }
      v81 = v23;
      _memmove(&v23[(unsigned int)(unsigned __int16)v80 >> 1], DestinationString.Buffer, DestinationString.Length);
      v25 = v80 + DestinationString.Length;
      v26 = v80 + DestinationString.Length + 2;
      LOWORD(v80) = v25;
      HIWORD(v80) = v26;
      v81[(unsigned int)v25 >> 1] = 0;
      v27 = (unsigned __int16)v80 + 20;
      if ( (unsigned int)v27 > 0xFFFE )
        goto LABEL_120;
      if ( v27 > v84 && RtlpEnsureBufferSize(0, &v82, (unsigned __int16)v80 + 20) < 0 )
        goto LABEL_141;
      v81 = v82;
      _memmove(&v82[(unsigned int)(unsigned __int16)v80 >> 1], L".Manifest", 0x12u);
      v28 = v80;
      LOWORD(v80) = v80 + 18;
      HIWORD(v80) = v28 + 20;
      v81[(unsigned int)(unsigned __int16)v80 >> 1] = 0;
      v29 = (unsigned __int16)v80 + 4;
      if ( (unsigned int)v29 > 0xFFFE )
        goto LABEL_120;
      if ( v29 > v84 && RtlpEnsureBufferSize(0, &v82, (unsigned __int16)v80 + 4) < 0 )
        goto LABEL_141;
      HIWORD(v80) = v84;
      v81 = v82;
      v82[(unsigned int)(unsigned __int16)v80 >> 1] = 0;
      v22 = v81;
      goto LABEL_114;
    }
    v53 = SourceString;
    v51 = (int)"CreateActCtxW";
    v48 = "SXS: %s() Bad lpApplication name '%ls'\n";
LABEL_94:
    _DbgPrintEx(0x33u, 0, v48, v51, v53);
    goto LABEL_174;
  }
  v21 = RtlDetermineDosPathNameType_U(dosname);
  if ( v21 != 1 && v21 != 2 && v21 != 6 )
  {
    if ( v21 == 5 )
    {
      v22 = dosname;
LABEL_114:
      v78 = v22;
      goto LABEL_134;
    }
    v54 = v21;
    v52 = dosname;
    v49 = (int)"CreateActCtxW";
    v46 = "SXS: %s() Bad lpSource PathType %ls, 0x%lx\n";
LABEL_173:
    _DbgPrintEx(0x33u, 0, v46, v49, v52, v54);
    goto LABEL_174;
  }
LABEL_35:
  if ( v68 & 8 )
  {
    if ( v61->lpResourceName )
    {
      v11 = BaseDllMapResourceIdW(v61->lpResourceName);
      v62 = v11;
      if ( v11 == -1 )
      {
        _DbgPrintEx(0x33u, 0, "SXS: %s() BaseDllMapResourceIdW failed\n", "CreateActCtxW");
        v4 = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
        goto LABEL_59;
      }
      v73 = v11;
      goto LABEL_39;
    }
    _DbgPrintEx(0x33u, 0, "SXS: %s() ACTCTX_FLAG_RESOURCE_NAME_VALID set but lpResourceName == 0\n", "CreateActCtxW");
LABEL_174:
    v4 = -1073741811;
    goto LABEL_59;
  }
  v60 = 1;
LABEL_39:
  v4 = BasepCreateActCtx(v60, (int)&v67, (wchar_t *)&Exchange);
  if ( v4 < 0 )
    goto LABEL_59;
  if ( !Exchange )
  {
LABEL_88:
    v4 = -1073741811;
    goto LABEL_44;
  }
  if ( v68 & 0x10 )
  {
    if ( !v59[1].AtlThunkSListPtr && !InterlockedCompareExchange((volatile LONG *)&v59[1].AtlThunkSListPtr, Exchange, 0) )
    {
      v65 = 0;
      goto LABEL_43;
    }
    v4 = -1072365554;
  }
  else
  {
    v12 = RtlCreateActivationContext(0, Exchange, 0, BasepSxsActivationContextNotification, 0, &v65);
    v4 = v12;
    if ( v12 >= 0 )
    {
LABEL_43:
      Exchange = 0;
      v4 = 0;
      goto LABEL_44;
    }
    if ( v12 == -1073741772
      || v12 == -1073741687
      || v12 == -1073741686
      || v12 == -1073741685
      || v12 == -1073741308
      || v12 == -1072365566
      || v12 == -1072365564
      || v12 == -1073741809 )
      v45 = 2;
    else
      v45 = 0;
    _DbgPrintEx(0x33u, v45, "SXS: RtlCreateActivationContext() failed 0x%08lx\n", v4);
    v65 = (void *)-1;
  }
LABEL_59:
  if ( Exchange )
    NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, (PVOID)Exchange);
LABEL_44:
  BaseDllFreeResourceId(v62);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    v65 = (void *)-1;
  }
  v13 = (WCHAR *)v97;
  if ( v96 )
  {
    if ( (__int16 *)v96 != v97 )
    {
      UnicodeString.Buffer = v96;
      RtlFreeUnicodeString(&UnicodeString);
      v13 = (WCHAR *)v97;
    }
    v96 = v13;
    v98 = v99;
  }
  v95 = v13;
  if ( v13 )
    *v13 = 0;
  LOWORD(v94) = 0;
  HIWORD(v94) = v99;
  v14 = v90;
  if ( lpFilename )
  {
    if ( lpFilename != v90 )
    {
      v55.Buffer = lpFilename;
      RtlFreeUnicodeString(&v55);
      v14 = v90;
    }
    lpFilename = v14;
    v91 = v92;
  }
  Src = v14;
  if ( v14 )
    *v14 = 0;
  LOWORD(v87) = 0;
  HIWORD(v87) = v92;
  v15 = v83;
  if ( v82 )
  {
    if ( v82 != v83 )
    {
      v56.Buffer = (PWCH)v82;
      RtlFreeUnicodeString(&v56);
      v15 = v83;
    }
    v82 = v15;
    v84 = v85;
  }
  v81 = v15;
  if ( v15 )
    *v15 = 0;
  LOWORD(v80) = 0;
  HIWORD(v80) = v85;
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v65;
}
// 77DE1164: using guessed type int __stdcall RtlCreateActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1184: using guessed type int __stdcall RtlpEnsureBufferSize(_DWORD, _DWORD, _DWORD);
// 77DE1188: using guessed type int RtlGetLengthWithoutLastFullDosOrNtPathElement;
// 77DE118C: using guessed type int __stdcall RtlpApplyLengthFunction(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E26A4E: using guessed type int __stdcall BaseDllMapResourceIdW(_DWORD);
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);
// 77E5403C: using guessed type wchar_t aWinsxs[8];
// 77E5404C: using guessed type wchar_t ManifestDefaultName[21];

//----- (77E25D33) --------------------------------------------------------
NTSTATUS __stdcall BasepCreateActCtx(char a1, int a2, wchar_t *a3)
{
  ULONG v3; // eax@92
  bool v4; // zf@1
  __int16 v5; // ax@1
  int v6; // eax@2
  NTSTATUS v7; // edi@2
  const WCHAR *v8; // eax@10
  unsigned int v9; // ecx@15
  int v10; // eax@17
  HANDLE *v11; // eax@19
  int v12; // eax@23
  signed int v13; // eax@34
  int *v14; // ecx@35
  NTSTATUS v15; // eax@36
  int v16; // eax@50
  __int16 *v17; // eax@62
  __int16 *v18; // eax@67
  __int16 *v19; // eax@72
  __int16 *v20; // eax@77
  NTSTATUS v22; // eax@106
  PVOID v23; // eax@107
  NTSTATUS v24; // eax@121
  ULONG v25; // eax@163
  ULONG v26; // eax@177
  CHAR *v27; // [sp-Ch] [bp-534h]@165
  int v28; // [sp-8h] [bp-530h]@165
  NTSTATUS v29; // [sp-4h] [bp-52Ch]@165
  char FileInformation; // [sp+Ch] [bp-51Ch]@47
  int v31; // [sp+1Ch] [bp-50Ch]@48
  int v32; // [sp+20h] [bp-508h]@48
  int v33; // [sp+34h] [bp-4F4h]@1
  int v34; // [sp+38h] [bp-4F0h]@1
  int v35; // [sp+3Ch] [bp-4ECh]@1
  int v36; // [sp+40h] [bp-4E8h]@1
  int v37; // [sp+44h] [bp-4E4h]@1
  int v38; // [sp+48h] [bp-4E0h]@1
  int v39; // [sp+4Ch] [bp-4DCh]@1
  int v40; // [sp+50h] [bp-4D8h]@1
  int v41; // [sp+54h] [bp-4D4h]@1
  int v42; // [sp+58h] [bp-4D0h]@1
  int v43; // [sp+5Ch] [bp-4CCh]@1
  int v44; // [sp+60h] [bp-4C8h]@1
  LSA_UNICODE_STRING v45; // [sp+64h] [bp-4C4h]@96
  LSA_UNICODE_STRING v46; // [sp+6Ch] [bp-4BCh]@98
  LSA_UNICODE_STRING v47; // [sp+74h] [bp-4B4h]@97
  LSA_UNICODE_STRING UnicodeString; // [sp+7Ch] [bp-4ACh]@95
  __int16 *v49; // [sp+84h] [bp-4A4h]@1
  __int16 *v50; // [sp+88h] [bp-4A0h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8Ch] [bp-49Ch]@44
  LSA_UNICODE_STRING v52; // [sp+94h] [bp-494h]@31
  LSA_UNICODE_STRING v53; // [sp+9Ch] [bp-48Ch]@31
  int v54; // [sp+A4h] [bp-484h]@31
  int v55; // [sp+A8h] [bp-480h]@31
  int v56; // [sp+ACh] [bp-47Ch]@1
  LSA_UNICODE_STRING *v57; // [sp+B0h] [bp-478h]@1
  __int64 *v58; // [sp+B4h] [bp-474h]@1
  __int16 *v59; // [sp+B8h] [bp-470h]@1
  __int16 *v60; // [sp+BCh] [bp-46Ch]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+C0h] [bp-468h]@44
  int v62; // [sp+D8h] [bp-450h]@1
  int v63; // [sp+DCh] [bp-44Ch]@2
  ULONG ViewSize; // [sp+E0h] [bp-448h]@1
  int v65; // [sp+E4h] [bp-444h]@1
  int v66; // [sp+E8h] [bp-440h]@1
  LSA_UNICODE_STRING v67; // [sp+ECh] [bp-43Ch]@22
  LSA_UNICODE_STRING v68; // [sp+F4h] [bp-434h]@22
  int v69; // [sp+FCh] [bp-42Ch]@26
  int v70; // [sp+100h] [bp-428h]@26
  int v71; // [sp+104h] [bp-424h]@127
  int v72; // [sp+108h] [bp-420h]@1
  LSA_UNICODE_STRING v73; // [sp+10Ch] [bp-41Ch]@1
  int v74; // [sp+114h] [bp-414h]@1
  int v75; // [sp+118h] [bp-410h]@1
  int v76; // [sp+11Ch] [bp-40Ch]@1
  LSA_UNICODE_STRING v77; // [sp+120h] [bp-408h]@1
  int v78; // [sp+128h] [bp-400h]@1
  HANDLE v79; // [sp+12Ch] [bp-3FCh]@1
  int v80; // [sp+130h] [bp-3F8h]@1
  HANDLE SectionHandle; // [sp+134h] [bp-3F4h]@1
  int v82; // [sp+138h] [bp-3F0h]@1
  __int64 v83; // [sp+13Ch] [bp-3ECh]@1
  PHANDLE v84; // [sp+144h] [bp-3E4h]@1
  int *v85; // [sp+148h] [bp-3E0h]@1
  PHANDLE v86; // [sp+14Ch] [bp-3DCh]@1
  PVOID v87; // [sp+150h] [bp-3D8h]@1
  HANDLE FileHandle; // [sp+154h] [bp-3D4h]@1
  PVOID v89; // [sp+158h] [bp-3D0h]@1
  wchar_t *v90; // [sp+15Ch] [bp-3CCh]@1
  PVOID BaseAddress; // [sp+160h] [bp-3C8h]@18
  int Dst; // [sp+164h] [bp-3C4h]@1
  __int16 v93; // [sp+168h] [bp-3C0h]@1
  __int16 v94; // [sp+16Ch] [bp-3BCh]@5
  __int16 v95; // [sp+16Eh] [bp-3BAh]@5
  PVOID v96; // [sp+170h] [bp-3B8h]@5
  int v97; // [sp+174h] [bp-3B4h]@36
  char v98; // [sp+19Ch] [bp-38Ch]@36
  int v99; // [sp+1A0h] [bp-388h]@41
  int v100; // [sp+1A4h] [bp-384h]@41
  LSA_UNICODE_STRING DestinationString; // [sp+1C4h] [bp-364h]@7
  LSA_UNICODE_STRING v102; // [sp+1CCh] [bp-35Ch]@139
  int v103; // [sp+1D4h] [bp-354h]@48
  int v104; // [sp+1D8h] [bp-350h]@48
  int v105; // [sp+1DCh] [bp-34Ch]@6
  wchar_t *v106; // [sp+1E0h] [bp-348h]@12
  __int16 v107; // [sp+204h] [bp-324h]@1
  __int16 v108; // [sp+206h] [bp-322h]@1
  __int16 *v109; // [sp+208h] [bp-320h]@1
  WCHAR *v110; // [sp+20Ch] [bp-31Ch]@1
  __int16 *v111; // [sp+210h] [bp-318h]@1
  int v112; // [sp+214h] [bp-314h]@1
  int v113; // [sp+218h] [bp-310h]@1
  __int16 v114; // [sp+228h] [bp-300h]@1
  __int16 v115; // [sp+22Ah] [bp-2FEh]@1
  __int16 *v116; // [sp+22Ch] [bp-2FCh]@1
  WCHAR *v117; // [sp+230h] [bp-2F8h]@1
  __int16 *v118; // [sp+234h] [bp-2F4h]@1
  int v119; // [sp+238h] [bp-2F0h]@1
  int v120; // [sp+23Ch] [bp-2ECh]@1
  __int16 v121; // [sp+24Ch] [bp-2DCh]@1
  __int16 v122; // [sp+24Eh] [bp-2DAh]@1
  __int16 *v123; // [sp+250h] [bp-2D8h]@1
  WCHAR *v124; // [sp+254h] [bp-2D4h]@1
  __int16 *v125; // [sp+258h] [bp-2D0h]@1
  int v126; // [sp+25Ch] [bp-2CCh]@1
  int v127; // [sp+260h] [bp-2C8h]@1
  __int16 v128; // [sp+270h] [bp-2B8h]@1
  __int16 v129; // [sp+272h] [bp-2B6h]@1
  __int16 *v130; // [sp+274h] [bp-2B4h]@1
  WCHAR *v131; // [sp+278h] [bp-2B0h]@1
  __int16 *v132; // [sp+27Ch] [bp-2ACh]@1
  int v133; // [sp+280h] [bp-2A8h]@1
  int v134; // [sp+284h] [bp-2A4h]@1
  char v135; // [sp+294h] [bp-294h]@1
  __int16 v136; // [sp+314h] [bp-214h]@1
  __int16 v137; // [sp+394h] [bp-194h]@1
  __int16 v138; // [sp+414h] [bp-114h]@1
  __int16 v139; // [sp+494h] [bp-94h]@1
  wchar_t v140; // [sp+514h] [bp-14h]@25

  v90 = a3;
  v57 = &v73;
  v58 = (__int64 *)&v77;
  v59 = &v114;
  v60 = &v128;
  v79 = 0;
  v80 = 0;
  SectionHandle = 0;
  v82 = 0;
  v83 = 0i64;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v44 = 0;
  v75 = 1;
  v76 = 1;
  v49 = &v121;
  v50 = &v107;
  v89 = &v135;
  v85 = 0;
  v56 = 0;
  ViewSize = 0;
  v86 = 0;
  v84 = 0;
  v62 = 0;
  FileHandle = 0;
  v65 = 0;
  v78 = 64;
  v87 = 0;
  v74 = 0;
  v66 = 0;
  v72 = 0;
  memset(&Dst, 0, 0xA0u);
  v117 = (WCHAR *)&v136;
  v118 = &v136;
  v116 = &v136;
  v136 = 0;
  v114 = 0;
  v115 = 128;
  v119 = 128;
  v120 = 128;
  v131 = (WCHAR *)&v137;
  v132 = &v137;
  v130 = &v137;
  v77.Buffer = 0;
  v137 = 0;
  v128 = 0;
  v129 = 128;
  v124 = (WCHAR *)&v138;
  v125 = &v138;
  v123 = &v138;
  v138 = 0;
  v121 = 0;
  v122 = 128;
  v110 = (WCHAR *)&v139;
  v111 = &v139;
  v109 = &v139;
  v4 = (*(_BYTE *)(a2 + 4) & 2) == 0;
  v139 = 0;
  v107 = 0;
  v108 = 128;
  v5 = *(_WORD *)(a2 + 12);
  v133 = 128;
  v134 = 128;
  v126 = 128;
  v127 = 128;
  v112 = 128;
  v113 = 128;
  v93 = v5;
  if ( !v4 )
  {
    v7 = RtlGetThreadPreferredUILanguages(72, &v71, 0, &v74);
    if ( v7 >= 0 )
    {
      if ( v71 )
      {
        v87 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v74);
        if ( !v87 )
        {
          v7 = -1073741801;
          goto LABEL_111;
        }
        v7 = RtlGetThreadPreferredUILanguages(72, &v71, v87, &v74);
        if ( v7 < 0 )
          goto LABEL_111;
      }
      SetThreadUILanguage(*(_WORD *)(a2 + 14));
      v66 = 1;
      goto LABEL_2;
    }
LABEL_111:
    if ( v83 && !v72 )
      v83 = (unsigned int)v83 & 0xFFFFFFFC;
    goto LABEL_54;
  }
LABEL_2:
  v6 = RtlGetThreadPreferredUILanguages(56, &v63, &v135, &v78);
  v7 = v6;
  if ( v6 == -1073741789 )
  {
    v89 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v78);
    if ( !v89 )
    {
      v7 -= 12;
      goto LABEL_52;
    }
    v7 = RtlGetThreadPreferredUILanguages(56, &v63, v89, &v78);
    if ( v7 < 0 )
      goto LABEL_52;
  }
  else
  {
    if ( v6 < 0 )
      goto LABEL_52;
    if ( !v63 )
      v89 = 0;
  }
  v96 = v89;
  v95 = 2 * v78;
  v94 = 2 * v78;
  if ( *(_DWORD *)(a2 + 20) & 0xFFFF0000 )
    v105 = -1;
  else
    v105 = *(_DWORD *)(a2 + 20);
  RtlInitUnicodeString(&DestinationString, *(PCWSTR *)(a2 + 16));
  if ( DestinationString.Length
    && ((DestinationString.Length & 0xFFFEu) >= (DestinationString.MaximumLength & 0xFFFEu)
     || DestinationString.Buffer[(unsigned int)DestinationString.Length >> 1]) )
  {
    _DbgPrintEx(0x33u, 0, "SXS: %s() AssemblyDirectory is not null terminated\n", "BasepCreateActCtx");
LABEL_216:
    v7 = -1073741811;
    goto LABEL_52;
  }
  v8 = *(const WCHAR **)(a2 + 8);
  if ( !v8 || !*v8 )
  {
    _DbgPrintEx(0x33u, 0, "SXS: %s() empty lpSource %ls\n", "BasepCreateActCtx", *(_DWORD *)(a2 + 8));
    goto LABEL_216;
  }
  v80 = -1;
  v4 = (*(_BYTE *)(a2 + 4) & 0x40) == 0;
  v106 = v90;
  if ( !v4 )
  {
    Dst = 8;
    RtlInitUnicodeString(&v102, v8);
LABEL_42:
    if ( Dst & 8 )
    {
LABEL_49:
      if ( *(_DWORD *)&NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved1[8] & 0x8000 )
        Dst |= 0x80u;
      v16 = CsrBasepCreateActCtx(&Dst);
      v7 = v16;
      if ( v16 >= 0 )
      {
        v7 = 0;
        goto LABEL_52;
      }
      if ( v16 == -1073741790
        || v16 == -1073741772
        || v16 == -1073741687
        || v16 == -1073741686
        || v16 == -1073741685
        || v16 == -1073741308
        || v16 == -1072365566
        || v16 == -1072365564
        || v16 == -1073741809 )
        v25 = 2;
      else
        v25 = 0;
      v29 = v7;
      v28 = (int)"BasepCreateActCtx";
      v27 = "SXS: %s() Calling csrss server failed. Status = 0x%x\n";
      goto LABEL_166;
    }
    if ( v79 )
    {
      FileHandle = v79;
LABEL_46:
      if ( !BasepIsRemovableMedia(FileHandle, 0) )
      {
        Dst |= 0x40u;
        v7 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
        if ( v7 < 0 )
          goto LABEL_52;
        v103 = v31;
        v104 = v32;
      }
      goto LABEL_49;
    }
    ObjectAttributes.ObjectName = &v77;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v7 = NtOpenFile(&FileHandle, 0x120089u, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u);
    if ( v7 >= 0 )
    {
      v65 = 1;
      goto LABEL_46;
    }
    goto LABEL_140;
  }
  RtlInitUnicodeString(&v73, v8);
  RtlDetermineDosPathNameType_U(*(PWSTR *)(a2 + 8));
  v7 = RtlDosPathNameToNtPathName_U_WithStatus(v73.Buffer, &v77, 0, 0);
  if ( v7 < 0 )
    goto LABEL_52;
  v90 = _wcsrchr(v73.Buffer, 0x2Eu);
  if ( *(_BYTE *)(a2 + 4) & 0x80 )
  {
    v9 = *(_DWORD *)(a2 + 28);
    v79 = 0;
    SectionHandle = 0;
    v83 = v9;
    v62 = 1;
    v75 = 0;
    v76 = 0;
    goto LABEL_16;
  }
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &v77;
  v7 = NtOpenFile(&v79, 0x1200A9u, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u);
  if ( v7 < 0 )
  {
LABEL_140:
    if ( v7 != -1073741772
      && v7 != -1073741687
      && v7 != -1073741686
      && v7 != -1073741685
      && v7 != -1073741308
      && v7 != -1072365566
      && v7 != -1072365564
      && v7 != -1073741809 )
      _DbgPrintEx(0x33u, 0, "SXS: %s() NtOpenFile(%wZ) failed\n", "BasepCreateActCtx", ObjectAttributes.ObjectName);
    goto LABEL_52;
  }
  if ( v90 && (!__wcsicmp(v90, L".dll") || !__wcsicmp(v90, L".exe")) )
  {
    v24 = NtCreateSection(&SectionHandle, 4u, 0, 0, 2u, 0x1000000u, v79);
    v7 = v24;
    if ( v24 < 0 )
    {
      if ( v24 != -1073741701 && v24 != -1073741521 && v24 != -1073741520 && v24 != -1073741519 && v24 != -1073740966 )
      {
        if ( v24 == -1073741772
          || v24 == -1073741687
          || v24 == -1073741686
          || v24 == -1073741685
          || v24 == -1073741308
          || v24 == -1072365566
          || v24 == -1072365564
          || v24 == -1073741809 )
          v25 = 2;
        else
          v25 = 0;
        v29 = v7;
        v28 = (int)"BasepCreateActCtx";
        v27 = "SXS: %s() NtCreateSection() failed. Status = 0x%x\n";
        goto LABEL_166;
      }
      v7 = 0;
    }
    else
    {
      v72 = 1;
    }
  }
  if ( !SectionHandle )
    v7 = NtCreateSection(&SectionHandle, 4u, 0, 0, 2u, 0x8000000u, v79);
  if ( v7 < 0 )
  {
    if ( v7 == -1073741760 )
      goto LABEL_16;
    if ( v7 == -1073741772
      || v7 == -1073741687
      || v7 == -1073741686
      || v7 == -1073741685
      || v7 == -1073741308
      || v7 == -1072365566
      || v7 == -1072365564
      || v7 == -1073741809 )
      v25 = 2;
    else
      v25 = 0;
    v29 = v7;
    v28 = (int)"BasepCreateActCtx";
    v27 = "SXS: %s() NtCreateSection() failed. Status = 0x%x.\n";
LABEL_166:
    _DbgPrintEx(0x33u, v25, v27, v28, v29);
    goto LABEL_52;
  }
  BaseAddress = 0;
  v22 = NtMapViewOfSection(SectionHandle, (HANDLE)0xFFFFFFFF, &BaseAddress, 0, 0, 0, &ViewSize, ViewShare, 0, 2u);
  v7 = v22;
  if ( v22 < 0 )
  {
    if ( v22 != -1073741801 )
    {
      if ( v22 == -1073741772
        || v22 == -1073741687
        || v22 == -1073741686
        || v22 == -1073741685
        || v22 == -1073741308
        || v22 == -1072365566
        || v22 == -1072365564
        || v22 == -1073741809 )
        v26 = 2;
      else
        v26 = 0;
      _DbgPrintEx(0x33u, v26, "SXS: %s() NtMapViewOfSection failed\n", "BasepCreateActCtx");
      goto LABEL_52;
    }
    NtClose(SectionHandle);
    SectionHandle = 0;
  }
  else
  {
    v23 = BaseAddress;
    HIDWORD(v83) = 0;
    if ( !v72 )
      v23 = (PVOID)((unsigned int)BaseAddress | 1);
    LODWORD(v83) = v23;
  }
LABEL_16:
  if ( v83 )
  {
    v10 = RtlImageNtHeaderEx(v62, v83 & 0xFFFFFFFC, ViewSize, 0, &v56);
    v7 = v10;
    if ( v10 >= 0 )
    {
      BaseAddress = (PVOID)1;
LABEL_19:
      v84 = &v79;
      v11 = (HANDLE *)&v33;
      goto LABEL_20;
    }
    if ( v10 != -1073741701 )
      goto LABEL_52;
    BaseAddress = 0;
  }
  else
  {
    BaseAddress = (PVOID)(*(_DWORD *)(a2 + 20) != 0);
    if ( BaseAddress )
      goto LABEL_19;
  }
  v84 = 0;
  v11 = &v79;
LABEL_20:
  v86 = v11;
  v76 = 0;
  if ( BaseAddress )
  {
    if ( !(*(_BYTE *)(a2 + 4) & 8) )
    {
      v7 = -1073741686;
      goto LABEL_52;
    }
  }
  else if ( *(_DWORD *)(a2 + 20) )
  {
    v7 = -1073741701;
    goto LABEL_52;
  }
  v67 = v73;
  v4 = (*(_BYTE *)(a2 + 4) & 8) == 0;
  v68.Length = 0;
  v68.MaximumLength = 0;
  v68.Buffer = 0;
  if ( !v4 )
  {
    v12 = *(_DWORD *)(a2 + 20);
    if ( v12 & 0xFFFF0000 )
    {
      RtlInitUnicodeString(&v68, *(PCWSTR *)(a2 + 20));
    }
    else if ( v12 != 1 )
    {
      swprintf_s(&v140, 8u, L".%lu", *(_DWORD *)(a2 + 20));
      v68.Length = 2 * wcslen(&v140);
      v68.MaximumLength = 16;
      v68.Buffer = &v140;
    }
  }
  v69 = SxsPolicySuffix;
  v70 = (int)L".Config";
  if ( v90 && !__wcsicmp(v90, L".Manifest") )
  {
    v67.Length -= 18;
    v85 = (int *)18;
  }
  v7 = RtlMultiAppendUnicodeStringBuffer(&v114, 3, &v67);
  if ( v7 >= 0 )
  {
    v67 = v77;
    v67.Length = v77.Length - (_WORD)v85;
    v7 = RtlMultiAppendUnicodeStringBuffer(&v128, 3, &v67);
    if ( v7 >= 0 )
    {
      if ( !BaseAddress )
        goto LABEL_223;
      v52 = v73;
      v53 = v68;
      v54 = SxsManifestSuffix;
      v55 = (int)L".Manifest";
      v7 = RtlMultiAppendUnicodeStringBuffer(&v121, 3, &v52);
      if ( v7 < 0 )
        goto LABEL_52;
      v52 = v77;
      v7 = RtlMultiAppendUnicodeStringBuffer(&v107, 3, &v52);
      if ( v7 < 0 )
        goto LABEL_52;
      if ( a1 & 1 )
        v13 = 0;
      else
LABEL_223:
        v13 = 1;
      v14 = (int *)&v49;
      if ( !BaseAddress )
        v14 = (int *)&v57;
      v85 = v14;
      v15 = BasepSxsCreateStreams(
              0,
              0x1200A9u,
              0,
              0,
              0,
              0,
              0,
              0,
              v13 != 0 ? (unsigned int)v14 : 0,
              v86,
              BaseAddress != 0 ? (unsigned int)&v57 : 0,
              v84,
              *(_DWORD *)(a2 + 20),
              *(_DWORD *)(a2 + 20) == 1 ? (unsigned int)&v59 : 0,
              (PHANDLE)(*(_DWORD *)(a2 + 20) == 1 ? (unsigned int)&v39 : 0),
              (int)&Dst,
              (int)&v97,
              *(_DWORD *)(a2 + 20) == 1 ? (unsigned int)&v98 : 0);
      v7 = v15;
      if ( Dst )
      {
        if ( !(Dst & 2) && BasepSxsIsStatusFileNotFoundEtc(v15) )
          v7 = 0;
        if ( v7 >= 0 )
        {
          if ( *(_DWORD *)(a2 + 20) != 1 )
          {
            v99 = *(_DWORD *)v59;
            v100 = *((_DWORD *)v59 + 1);
          }
          goto LABEL_42;
        }
      }
      else if ( v15 >= 0 )
      {
        goto LABEL_92;
      }
      if ( v7 != -1073741772
        && v7 != -1073741687
        && v7 != -1073741686
        && v7 != -1073741685
        && v7 != -1073741308
        && v7 != -1072365566
        && v7 != -1072365564
        && v7 != -1073741809 )
      {
        v3 = 0;
        goto LABEL_93;
      }
LABEL_92:
      v3 = 2;
LABEL_93:
      _DbgPrintEx(0x33u, v3, "SXS: %s() BasepSxsCreateStreams() failed\n", "BasepCreateActCtx");
      goto LABEL_52;
    }
  }
LABEL_52:
  if ( v66 )
    RtlSetThreadPreferredUILanguages(8, v87, &v71);
  if ( v75 )
    goto LABEL_111;
LABEL_54:
  if ( v76 )
    BasepSxsCloseHandles((int)&v79);
  if ( v86 )
    BasepSxsCloseHandles((int)v86);
  if ( v84 && v75 )
    BasepSxsCloseHandles((int)v84);
  BasepSxsCloseHandles((int)&v39);
  if ( v65 && FileHandle )
    NtClose(FileHandle);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v77.Buffer);
  v17 = v118;
  if ( v117 )
  {
    if ( (__int16 *)v117 != v118 )
    {
      v46.Buffer = v117;
      RtlFreeUnicodeString(&v46);
      v17 = v118;
    }
    v117 = (WCHAR *)v17;
    v119 = v120;
  }
  v116 = v17;
  if ( v17 )
    *v17 = 0;
  v114 = 0;
  v115 = v120;
  v18 = v132;
  if ( v131 )
  {
    if ( (__int16 *)v131 != v132 )
    {
      v45.Buffer = v131;
      RtlFreeUnicodeString(&v45);
      v18 = v132;
    }
    v131 = (WCHAR *)v18;
    v133 = v134;
  }
  v130 = v18;
  if ( v18 )
    *v18 = 0;
  v128 = 0;
  v129 = v134;
  v19 = v125;
  if ( v124 )
  {
    if ( (__int16 *)v124 != v125 )
    {
      v47.Buffer = v124;
      RtlFreeUnicodeString(&v47);
      v19 = v125;
    }
    v124 = (WCHAR *)v19;
    v126 = v127;
  }
  v123 = v19;
  if ( v19 )
    *v19 = 0;
  v121 = 0;
  v122 = v127;
  v20 = v111;
  if ( v110 )
  {
    if ( (__int16 *)v110 != v111 )
    {
      UnicodeString.Buffer = v110;
      RtlFreeUnicodeString(&UnicodeString);
      v20 = v111;
    }
    v110 = (WCHAR *)v20;
    v112 = v113;
  }
  v109 = v20;
  if ( v20 )
    *v20 = 0;
  v107 = 0;
  v108 = v113;
  if ( v89 && v89 != &v135 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v89);
  if ( v87 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v87);
  return v7;
}
// 77DE116C: using guessed type int __stdcall RtlImageNtHeaderEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1170: using guessed type int __stdcall RtlSetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD);
// 77DE1178: using guessed type int __stdcall RtlGetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1180: using guessed type int __stdcall RtlMultiAppendUnicodeStringBuffer(_DWORD, _DWORD, _DWORD);
// 77DE13D0: using guessed type int __stdcall RtlDosPathNameToNtPathName_U_WithStatus(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E26858: using guessed type int SxsPolicySuffix;
// 77E26860: using guessed type wchar_t a_config[8];
// 77E26A54: using guessed type int SxsManifestSuffix;

//----- (77E2676F) --------------------------------------------------------
int __stdcall CsrBasepCreateActCtx(const void *a1)
{
  char v1; // al@1
  int v2; // eax@1
  int v3; // esi@1
  ULONG v5; // eax@12
  char *v6; // [sp+8h] [bp-FCh]@1
  char *v7; // [sp+Ch] [bp-F8h]@1
  char *v8; // [sp+10h] [bp-F4h]@1
  unsigned int v9; // [sp+14h] [bp-F0h]@1
  char *v10; // [sp+18h] [bp-ECh]@1
  int v11; // [sp+1Ch] [bp-E8h]@1
  char v12; // [sp+20h] [bp-E4h]@2
  char v13; // [sp+48h] [bp-BCh]@1
  char v14; // [sp+50h] [bp-B4h]@1
  char v15; // [sp+5Ch] [bp-A8h]@1
  char v16; // [sp+84h] [bp-80h]@1
  char v17; // [sp+A8h] [bp-5Ch]@1
  char v18; // [sp+B0h] [bp-54h]@1

  v11 = 0;
  v1 = *(_DWORD *)a1 & 8;
  qmemcpy(&v13, a1, 0xA0u);
  v6 = &v15;
  v7 = &v16;
  v8 = &v17;
  v9 = v1 != 0 ? (unsigned int)&v18 : 0;
  v10 = &v14;
  v2 = CsrCaptureMessageMultiUnicodeStringsInPlace(&v11, 5, &v6);
  v3 = v2;
  if ( v2 < 0 )
  {
    if ( v2 == -1073741772
      || v2 == -1073741687
      || v2 == -1073741686
      || v2 == -1073741685
      || v2 == -1073741308
      || v2 == -1072365566 )
      v5 = 2;
    else
      v5 = 0;
    _DbgPrintEx(0x33u, v5, "SXS: %s() CsrCaptureMessageMultiUnicodeStringsInPlace failed\n", "CsrBasepCreateActCtx");
  }
  else
  {
    v3 = CsrClientCallServer(&v12, v11, 268501015, 160);
  }
  if ( v11 )
    CsrFreeCaptureBuffer(v11);
  return v3;
}
// 77DE1154: using guessed type int __stdcall CsrCaptureMessageMultiUnicodeStringsInPlace(_DWORD, _DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E26875) --------------------------------------------------------
NTSTATUS __stdcall BasepSxsCreateStreams(int a1, ACCESS_MASK DesiredAccess, int a3, int a4, int a5, int a6, int a7, int a8, int a9, PHANDLE FileHandle, int a11, PHANDLE a12, ULONG Length, int a14, PHANDLE a15, int a16, int a17, int a18)
{
  NTSTATUS v18; // edi@1
  char v19; // bl@1
  NTSTATUS v20; // esi@2
  int v21; // eax@6
  NTSTATUS v23; // eax@16
  int v24; // eax@17
  NTSTATUS v25; // eax@25
  int v26; // eax@30
  int v27; // [sp+Ch] [bp-4h]@1

  v18 = 0;
  v19 = 1;
  v27 = 0;
  if ( a3 )
  {
    BasepSxsOverrideStreamToMessageStream(a3, a17);
    v19 = 0;
    goto LABEL_8;
  }
  v20 = BasepGetPreferExternalManifestConfig((int)&v27);
  if ( v20 >= 0 )
  {
    if ( v27 )
    {
      if ( a9 )
      {
        v25 = BasepSxsCreateFileStream(DesiredAccess, a9, FileHandle, a17);
        v20 = v25;
        if ( v25 >= 0 )
          goto LABEL_8;
        if ( !BasepSxsIsStatusFileNotFoundEtc(v25) )
          return v20;
        v18 = v20;
      }
      if ( !a11 )
        return v20;
      if ( *((_QWORD *)a12 + 2) )
        v26 = BasepSxsCreateResourceStream(a11, (int)a12, Length, a5, a6, a7, a8, a17);
      else
        v26 = BasepSxsCreateResourceStreamFromFileHandle(a11, Length, a12, a17);
      v20 = v26;
      if ( v26 < 0 )
      {
        v24 = BasepSxsIsStatusResourceNotFound(v26);
        goto LABEL_18;
      }
    }
    else
    {
      if ( a11 )
      {
        if ( *((_QWORD *)a12 + 2) )
          v21 = BasepSxsCreateResourceStream(a11, (int)a12, Length, a5, a6, a7, a8, a17);
        else
          v21 = BasepSxsCreateResourceStreamFromFileHandle(a11, Length, a12, a17);
        v20 = v21;
        if ( v21 >= 0 )
          goto LABEL_8;
        if ( !BasepSxsIsStatusResourceNotFound(v21) )
          return v20;
        v18 = v20;
      }
      if ( !a9 )
        return v20;
      v23 = BasepSxsCreateFileStream(DesiredAccess, a9, FileHandle, a17);
      v20 = v23;
      if ( v23 < 0 )
      {
        v24 = BasepSxsIsStatusFileNotFoundEtc(v23);
LABEL_18:
        if ( v24 && v18 )
          v20 = v18;
        return v20;
      }
    }
LABEL_8:
    *(_DWORD *)a16 |= 1u;
    if ( a4 )
    {
      BasepSxsOverrideStreamToMessageStream(a4, a18);
    }
    else
    {
      if ( !v19 || !a14 )
        goto LABEL_11;
      v20 = BasepSxsCreateFileStream(DesiredAccess, a14, a15, a18);
      if ( v20 < 0 )
        return v20;
    }
    *(_DWORD *)a16 |= 2u;
LABEL_11:
    v20 = 0;
  }
  return v20;
}

//----- (77E26913) --------------------------------------------------------
int __stdcall BasepSxsIsStatusFileNotFoundEtc(NTSTATUS StatusCode)
{
  int result; // eax@2
  DWORD v2; // eax@8

  result = 0;
  if ( StatusCode < 0 )
  {
    if ( StatusCode == -1073741766
      || StatusCode == -1073741772
      || StatusCode == -1073741809
      || (v2 = RtlNtStatusToDosErrorNoTeb(StatusCode), v2 == 2)
      || v2 == 3
      || v2 == 53
      || v2 == 67 )
      result = 1;
  }
  return result;
}

//----- (77E2693C) --------------------------------------------------------
LSTATUS __stdcall RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
{
  NTSTATUS v2; // eax@2
  LSTATUS result; // eax@2

  if ( phkResult )
  {
    v2 = RtlOpenCurrentUser(samDesired, phkResult);
    result = RtlNtStatusToDosError(v2);
  }
  else
  {
    result = 87;
  }
  return result;
}
// 77DE105C: using guessed type int __stdcall RtlOpenCurrentUser(_DWORD, _DWORD);

//----- (77E26967) --------------------------------------------------------
int __stdcall QueryFullProcessImageNameW(HANDLE ProcessHandle, HANDLE HeapHandle, void *Dst, int a4)
{
  int v4; // esi@1
  PPEB v5; // ecx@4
  void *v6; // edi@4
  ULONG v7; // ebx@4
  int v8; // eax@4
  PVOID v9; // eax@4
  PVOID v10; // edi@4
  signed int v11; // eax@5
  unsigned int v12; // eax@7
  signed int v14; // [sp+Ch] [bp-4h]@1
  HANDLE HeapHandlea; // [sp+1Ch] [bp+Ch]@4

  v14 = 0;
  v4 = (unsigned __int8)HeapHandle & 1;
  if ( (unsigned int)HeapHandle & 0xFFFFFFFE || (v4 - 1) & v4 )
  {
    BaseSetLastNTError(-1073741584);
  }
  else if ( *(_DWORD *)a4 > 0x7FFFFFFBu )
  {
    BaseSetLastNTError(-1073741811);
  }
  else
  {
    v5 = NtCurrentTeb()->ProcessEnvironmentBlock;
    v6 = v5->Reserved4[1];
    HeapHandlea = v5->Reserved4[1];
    v7 = 2 * *(_DWORD *)a4 + 8;
    v8 = KernelBaseGetGlobalData();
    v9 = RtlAllocateHeap(v6, *(_DWORD *)(v8 + 44), v7);
    v10 = v9;
    if ( v9 )
    {
      v11 = NtQueryInformationProcess(ProcessHandle, (PROCESSINFOCLASS)(v4 != 0 ? 27 : 43), v9, v7, 0);
      if ( v11 == -1073741820 )
        v11 = -1073741789;
      if ( v11 < 0 )
      {
        BaseSetLastNTError(v11);
      }
      else
      {
        memcpy(Dst, *((const void **)v10 + 1), *(_WORD *)v10);
        v12 = (unsigned int)*(_WORD *)v10 >> 1;
        if ( v12 >= *(_DWORD *)a4 )
        {
          BaseSetLastNTError(-1073741789);
        }
        else
        {
          *((_WORD *)Dst + v12) = 0;
          *(_DWORD *)a4 = v12;
          v14 = 1;
        }
      }
      RtlFreeHeap(HeapHandlea, 0, v10);
    }
    else
    {
      BaseSetLastNTError(-1073741801);
    }
  }
  return v14;
}

//----- (77E26A61) --------------------------------------------------------
int __stdcall BasepSxsCreateResourceStream(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8)
{
  int result; // eax@2
  int v9; // eax@3
  unsigned int v10; // ecx@3
  int v11; // ecx@5
  int v12; // [sp+8h] [bp-14h]@1
  int v13; // [sp+Ch] [bp-10h]@1
  int v14; // [sp+10h] [bp-Ch]@1
  unsigned int v15; // [sp+14h] [bp-8h]@1
  int v16; // [sp+18h] [bp-4h]@1

  v12 = 24;
  v13 = 0;
  v14 = 0;
  v16 = 0;
  v15 = 0;
  if ( a4 && a3 == 1 )
  {
    v10 = a7;
    if ( !a7 )
      return -1073741687;
    v9 = a8;
    *(_DWORD *)(a8 + 24) = a5;
    *(_DWORD *)(a8 + 28) = a6;
  }
  else
  {
    v13 = a3;
    result = LdrResSearchResource(*(_DWORD *)(a2 + 16), &v12, 3, 304, &v16, &v15, 0, 0);
    if ( result < 0 )
      return result;
    v9 = a8;
    *(_DWORD *)(a8 + 24) = v16;
    v10 = v15;
    *(_DWORD *)(a8 + 28) = 0;
  }
  *(_DWORD *)(v9 + 32) = v10;
  if ( v10 > 0x800000 )
  {
    result = -1072365534;
  }
  else
  {
    *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(v9 + 12) = *(_DWORD *)a2;
    *(_BYTE *)(v9 + 1) = 1;
    *(_BYTE *)v9 = 1;
    v11 = *(_DWORD *)a1;
    *(_DWORD *)(v9 + 4) = **(_DWORD **)a1;
    *(_DWORD *)(v9 + 8) = *(_DWORD *)(v11 + 4);
    *(_BYTE *)(v9 + 2) = 1;
    result = 0;
  }
  return result;
}
// 77E26B04: using guessed type int __stdcall LdrResSearchResource(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E26B1A) --------------------------------------------------------
BOOL __stdcall ReleaseSemaphoreStub(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
{
  return ReleaseSemaphore(hSemaphore, lReleaseCount, lpPreviousCount);
}

//----- (77E26B22) --------------------------------------------------------
BOOL __stdcall sub_77E26B22(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
{
  return ReleaseSemaphore(hSemaphore, lReleaseCount, lpPreviousCount);
}

//----- (77E26B32) --------------------------------------------------------
BOOL __stdcall CancelWaitableTimerStub(HANDLE hTimer)
{
  return CancelWaitableTimer(hTimer);
}

//----- (77E26B4A) --------------------------------------------------------
int __stdcall BasepSxsActivationContextNotification(int a1, int a2, PVOID BaseAddress, int a4, int a5, int a6)
{
  int result; // eax@2

  if ( a1 == 1 )
  {
    result = NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, BaseAddress);
  }
  else
  {
    result = a6;
    *(_BYTE *)a6 = 1;
  }
  return result;
}

//----- (77E26D31) --------------------------------------------------------
ATOM __stdcall GlobalAddAtomW(LPCWSTR lpString)
{
  return InternalAddAtom(0, 1, (PCSZ)lpString);
}

//----- (77E26D4B) --------------------------------------------------------
int __stdcall BasepSxsCreateFileStream(ACCESS_MASK DesiredAccess, int a2, PHANDLE FileHandle, int a4)
{
  NTSTATUS v4; // eax@2
  signed int v5; // edi@2
  PHANDLE v6; // edx@6
  int v7; // ecx@7
  unsigned int v8; // ecx@7
  NTSTATUS v10; // eax@9
  NTSTATUS v11; // eax@12
  char FileInformation; // [sp+Ch] [bp-38h]@2
  unsigned int v13; // [sp+14h] [bp-30h]@5
  int v14; // [sp+18h] [bp-2Ch]@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+24h] [bp-20h]@9
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+3Ch] [bp-8h]@2

  if ( *FileHandle
    || (ObjectAttributes.ObjectName = *(PUNICODE_STRING *)(a2 + 4),
        ObjectAttributes.Length = 24,
        ObjectAttributes.RootDirectory = 0,
        ObjectAttributes.Attributes = 64,
        ObjectAttributes.SecurityDescriptor = 0,
        ObjectAttributes.SecurityQualityOfService = 0,
        v10 = NtOpenFile(FileHandle, DesiredAccess, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u),
        v5 = v10,
        v10 >= 0) )
  {
    v4 = NtQueryInformationFile(*FileHandle, &IoStatusBlock, &FileInformation, 0x18u, FileStandardInformation);
    v5 = v4;
    if ( v4 < 0 )
    {
      DbgPrintEx(0x33u, 0, "SXS: %s() NtQueryInformationFile failed. Status = 0x%x\n", "BasepSxsCreateFileStream", v4);
    }
    else if ( v14 >= 0 && (v14 > 0 || v13 > 0x800000) )
    {
      v5 = -1072365534;
    }
    else
    {
      v6 = FileHandle + 2;
      if ( !FileHandle[2] )
      {
        v11 = NtCreateSection(FileHandle + 2, 4u, 0, 0, 2u, 0x8000000u, *FileHandle);
        v5 = v11;
        if ( v11 < 0 )
        {
          DbgPrintEx(0x33u, 0, "SXS: %s() NtCreateSection() failed. Status = 0x%x\n", "BasepSxsCreateFileStream", v11);
          return v5;
        }
        v6 = FileHandle + 2;
      }
      *(_DWORD *)(a4 + 12) = *FileHandle;
      *(_BYTE *)(a4 + 1) = 1;
      *(_BYTE *)a4 = 1;
      v7 = *(_DWORD *)a2;
      *(_DWORD *)(a4 + 4) = **(_DWORD **)a2;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(v7 + 4);
      *(_BYTE *)(a4 + 2) = 3;
      *(_DWORD *)(a4 + 16) = *v6;
      v8 = v13;
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 32) = v8;
      v5 = 0;
    }
  }
  else if ( v10 != -1073741772
         && v10 != -1073741687
         && v10 != -1073741686
         && v10 != -1073741685
         && v10 != -1073741308
         && v10 != -1072365566
         && v10 != -1073741809 )
  {
    DbgPrintEx(
      0x33u,
      0,
      "SXS: %s() NtOpenFile(%wZ) failed. Status = 0x%x\n",
      "BasepSxsCreateFileStream",
      ObjectAttributes.ObjectName,
      v10);
  }
  return v5;
}

//----- (77E26F37) --------------------------------------------------------
HLOCAL __stdcall LocalReAllocStub(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
{
  return LocalReAlloc(hMem, uBytes, uFlags);
}

//----- (77E26F4F) --------------------------------------------------------
void __stdcall ReleaseActCtx(HANDLE hActCtx)
{
  RtlReleaseActivationContext(hActCtx);
}

//----- (77E26FAB) --------------------------------------------------------
int __stdcall RegKrnGetClassesEnumTableAddressInternal()
{
  RtlRunOnceExecuteOnce(&gClassesEnumTableInit, (PRTL_RUN_ONCE_INIT_FN)ClassesEnumTableInitFn, 0, 0);
  return (int)gClassesEnumTable;
}
// 77EA65D8: using guessed type int gClassesEnumTable[18];

//----- (77E26FE4) --------------------------------------------------------
void __stdcall EnumTableRemoveKey(int a1, int a2, int a3)
{
  int v3; // eax@8
  int v4; // eax@1
  int v5; // eax@2
  int v6; // eax@4

  RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4));
  if ( v4 >= 0 )
  {
    v5 = *(_DWORD *)(a1 + 40);
    if ( v5 )
    {
      if ( a3 != 1 || (v3 = GetCurrentThreadId(), (v5 = StateObjectListFind(a1 + 28, v3)) != 0) )
      {
        v6 = StateObjectListRemove(v5, a2);
        if ( v6 )
          EnumStateDestroy((PVOID)v6);
      }
    }
    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4));
  }
}

//----- (77E27037) --------------------------------------------------------
signed int __stdcall BaseRegOpenClassKeyFromLocation(int a1, void *a2, int a3, int a4, char a5, char a6, int a7, int a8)
{
  int v8; // eax@1
  USHORT v9; // si@1
  __int16 v10; // si@3
  int v11; // esi@3
  int v12; // eax@7
  int v13; // eax@9
  int v15; // eax@19
  int v16; // esi@20
  int v17; // eax@21
  ULONG ResultLength; // [sp+8h] [bp-254h]@28
  int KeyInformation; // [sp+Ch] [bp-250h]@28
  int v20; // [sp+10h] [bp-24Ch]@1
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-248h]@3
  int v22; // [sp+1Ch] [bp-240h]@1
  int v23; // [sp+20h] [bp-23Ch]@6
  HANDLE KeyHandle; // [sp+24h] [bp-238h]@1
  int v25; // [sp+28h] [bp-234h]@8
  HANDLE v26; // [sp+2Ch] [bp-230h]@7
  int v27; // [sp+30h] [bp-22Ch]@8
  int v28; // [sp+34h] [bp-228h]@7
  int v29; // [sp+38h] [bp-224h]@8
  int v30; // [sp+3Ch] [bp-220h]@8
  PVOID Address; // [sp+40h] [bp-21Ch]@2
  int v32; // [sp+44h] [bp-218h]@1
  int v33; // [sp+48h] [bp-214h]@1
  NTSTATUS v34; // [sp+4Ch] [bp-210h]@1
  char v35; // [sp+50h] [bp-20Ch]@2
  unsigned int v36; // [sp+270h] [bp+14h]@3
  int v37; // [sp+270h] [bp+14h]@4

  KeyHandle = a2;
  v20 = a3;
  v33 = a7;
  v22 = a1;
  v8 = *(_DWORD *)(a1 + 16);
  v32 = a8;
  v9 = *(_WORD *)v8 + 128;
  v34 = -1073741772;
  if ( v9 > 0x208u )
  {
    Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
    if ( !Address )
      return -1073741801;
  }
  else
  {
    Address = &v35;
  }
  DestinationString.MaximumLength = v9;
  v10 = a4;
  v36 = a4 & 0xFFFFFCFF;
  v11 = v10 & 0x300;
  DestinationString.Buffer = (PWCH)Address;
  if ( g_Win64Registry
    && !v11
    && NtQueryKey(KeyHandle, KeyHandleTagsInformation, &KeyInformation, 4u, &ResultLength) >= 0 )
    v11 = KeyInformation & 0x300;
  v37 = v11 | v36;
  if ( !(a5 & 2) )
  {
LABEL_11:
    if ( a5 & 1 )
    {
      if ( v34 >= 0 )
        goto LABEL_25;
      if ( *(_BYTE *)v22 & 2 )
      {
        v26 = KeyHandle;
        v28 = 32 * (a6 & 8 | 2);
        v15 = v20;
      }
      else
      {
        v34 = BaseRegTranslateToMachineClassKey(v22, &DestinationString, (int)&v23);
        if ( v34 < 0 )
          goto LABEL_13;
        v28 = 32 * (a6 & 8 | 2);
        v26 = 0;
        v15 = (int)&DestinationString;
      }
      v16 = a6 & 0xC;
      v27 = v15;
      v30 = 0;
      v29 = 0;
      v25 = 24;
      if ( v32 )
        v17 = NtOpenKeyTransactedEx(v33, v37, &v25, v16, v32);
      else
        v17 = NtOpenKeyEx(v33, v37, &v25, v16);
      v34 = v17;
      if ( v17 < 0 )
        goto LABEL_13;
    }
    if ( v34 < 0 )
      goto LABEL_13;
LABEL_25:
    *(_DWORD *)v33 |= 2u;
    goto LABEL_13;
  }
  if ( *(_BYTE *)v22 & 1 )
  {
    v26 = KeyHandle;
    v28 = 32 * (a6 & 8 | 2);
    v12 = v20;
    goto LABEL_8;
  }
  v34 = BaseRegTranslateToUserClassKey(v22, &DestinationString, (int)&v23);
  if ( v34 >= 0 )
  {
    v28 = 32 * (a6 & 8 | 2);
    v26 = 0;
    v12 = (int)&DestinationString;
LABEL_8:
    v27 = v12;
    v30 = 0;
    v29 = 0;
    v25 = 24;
    if ( v32 )
      v13 = NtOpenKeyTransactedEx(v33, v37, &v25, a6 & 0xC, v32);
    else
      v13 = NtOpenKeyEx(v33, v37, &v25, a6 & 0xC);
    v34 = v13;
    goto LABEL_11;
  }
LABEL_13:
  if ( Address != &v35 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v34;
}
// 77DE169C: using guessed type int __stdcall NtOpenKeyEx(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE16A0: using guessed type int __stdcall NtOpenKeyTransactedEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E271C7) --------------------------------------------------------
int __stdcall BaseRegGetKeySemantics(HANDLE KeyHandle, PCUNICODE_STRING Source, int a3)
{
  int v3; // edi@1
  PVOID v4; // esi@1
  ULONG *v5; // ebx@1
  ULONG v6; // eax@1
  unsigned int v7; // eax@3
  USHORT v8; // bx@11
  int v9; // eax@13
  unsigned __int16 v10; // ax@15
  LSA_UNICODE_STRING Destination; // [sp+Ch] [bp-Ch]@8
  unsigned int v13; // [sp+14h] [bp-4h]@1
  int v14; // [sp+28h] [bp+10h]@2

  v3 = a3;
  v4 = *(PVOID *)(a3 + 16);
  v5 = (ULONG *)(a3 + 12);
  v6 = *(_DWORD *)(a3 + 12) - 2;
  v13 = v6;
  *(_DWORD *)(a3 + 12) = v6;
  if ( KeyHandle )
  {
    v14 = NtQueryKey(KeyHandle, KeyNameInformation, v4, v6, v5);
    if ( v14 == -1073741444 )
      v14 = 0;
    *v5 += Source->Length + 4;
    v7 = *v5;
    if ( v14 < 0 )
    {
      if ( v14 == -2147483643 )
      {
        v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
        if ( !v4 )
          return -1073741801;
        v14 = NtQueryKey(KeyHandle, KeyNameInformation, v4, *v5, v5);
        if ( v14 == -1073741444 )
          v14 = 0;
      }
      if ( v14 < 0 )
      {
        if ( v4 != *(PVOID *)(v3 + 16) )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
        return v14;
      }
    }
    else
    {
      if ( **(_DWORD **)(v3 + 16) > v13 )
        return -2147483643;
      if ( v13 >= v7 )
        goto LABEL_6;
      v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *v5);
      if ( !v4 )
        return -1073741801;
      memcpy((char *)v4 + 4, (const void *)(*(_DWORD *)(v3 + 16) + 4), **(_DWORD **)(v3 + 16));
      *(_DWORD *)v4 = **(_DWORD **)(v3 + 16);
    }
  }
  else
  {
    *((_WORD *)v4 + 2) = 0;
    **(_DWORD **)(a3 + 16) = 0;
    *v5 = 8;
  }
LABEL_6:
  if ( v4 != (PVOID)-4 )
  {
    if ( v4 != *(PVOID *)(v3 + 16) )
      *(_DWORD *)v3 |= 0x20u;
    *(_DWORD *)(v3 + 16) = v4;
    *((_WORD *)v4 + (*(_DWORD *)v4 >> 1) + 2) = 92;
    *((_WORD *)v4 + (*(_DWORD *)v4 >> 1) + 3) = 0;
    RtlInitUnicodeStringEx(&Destination, (PCWSTR)v4 + 2);
    *(_DWORD *)v4 = Destination.Length;
    Destination.MaximumLength += Source->Length + 2;
    RtlAppendUnicodeStringToString(&Destination, Source);
    if ( Destination.Length < 0x2Cu )
      return 0;
    if ( Destination.Buffer[((unsigned int)Destination.Length >> 1) - 1] == 92 )
      Destination.Length -= 2;
    v8 = Destination.Length;
    *(_DWORD *)v4 = Destination.Length;
    *((_WORD *)v4 + ((unsigned int)v8 >> 1) + 2) = 0;
    if ( (unsigned __int8)KeyHandle & 2 )
      *(_DWORD *)v3 |= 4u;
    v9 = *((_WORD *)v4 + 12);
    if ( v9 == 77 )
    {
LABEL_14:
      Destination.Length = 68;
      if ( RtlEqualUnicodeString(&Destination, &gMachineClassesName, 1u) )
      {
        *(_DWORD *)v3 |= 2u;
        Destination.Length = v8;
        v10 = 34;
LABEL_16:
        *(_WORD *)(v3 + 6) = 2 * v10;
        *(_WORD *)(v3 + 4) = v10;
        if ( (unsigned int)(unsigned __int16)(2 * v10) < *(_DWORD *)v4 )
          *(_WORD *)(v3 + 4) = v10 + 1;
        BaseRegCchSpecialKeyLen((int)&Destination, v10, v3);
        if ( !(*(_DWORD *)v3 & 0x10) )
        {
          *(_DWORD *)v3 |= 8u;
          *(_WORD *)(v3 + 10) = *(_WORD *)v4 - *(_WORD *)(v3 + 8) - *(_WORD *)(v3 + 6) - 2;
        }
        return 0;
      }
      return 0;
    }
    if ( v9 != 85 )
    {
      if ( v9 == 109 )
        goto LABEL_14;
      if ( v9 != 117 )
        return 0;
    }
    v10 = BaseRegGetUserPrefixLength((int)&Destination);
    if ( v10 )
    {
      *(_DWORD *)v3 |= 1u;
      goto LABEL_16;
    }
    return 0;
  }
  return -1073741816;
}

//----- (77E2735D) --------------------------------------------------------
NTSTATUS __stdcall BaseRegTranslateToMachineClassKey(int a1, PUNICODE_STRING DestinationString, int a3)
{
  UNICODE_STRING Source; // [sp+0h] [bp-10h]@1
  UNICODE_STRING SourceString; // [sp+8h] [bp-8h]@1

  RtlInitUnicodeStringEx(&SourceString, L"\\Registry\\Machine\\Software\\Classes");
  KeySemanticsRemovePrefix(a1, (int)&Source, 1);
  RtlCopyUnicodeString(DestinationString, &SourceString);
  *(_WORD *)a3 = 68;
  return RtlAppendUnicodeStringToString(DestinationString, &Source);
}

//----- (77E273FB) --------------------------------------------------------
int __stdcall KeySemanticsRemovePrefix(int a1, int a2, char a3)
{
  int v3; // esi@3
  int result; // eax@4

  v3 = a3 & 1 && *(_WORD *)(*(_DWORD *)(a1 + 16) + 2 * *(_WORD *)(a1 + 4) + 4);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 16) + 2 * (*(_WORD *)(a1 + 4) - (v3 != 0)) + 4;
  result = *(_DWORD *)(a1 + 16);
  *(_WORD *)a2 = *(_WORD *)result + 2 * ((v3 != 0) - *(_WORD *)(a1 + 4));
  return result;
}

//----- (77E2745F) --------------------------------------------------------
__int16 __stdcall BaseRegCchSpecialKeyLen(int a1, unsigned __int16 a2, int a3)
{
  __int16 result; // ax@2

  if ( *(_WORD *)a1 >> 1 == a2 )
  {
    *(_DWORD *)a3 |= 0x10u;
    result = a2;
  }
  else
  {
    result = (signed int)((char *)wcsrchr((const wchar_t *)(*(_DWORD *)(a1 + 4) + 2 * a2), 0x5Cu) - *(_DWORD *)(a1 + 4)) >> 1;
    *(_WORD *)(a3 + 8) = result - a2;
  }
  return result;
}

//----- (77E2757A) --------------------------------------------------------
int __stdcall BaseRegOpenClassKey(HANDLE KeyHandle, PCUNICODE_STRING Source, int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  signed int v7; // esi@2
  int v8; // [sp+Ch] [bp-1A4h]@1
  int v9; // [sp+10h] [bp-1A0h]@1
  int v10; // [sp+14h] [bp-19Ch]@1
  int v11; // [sp+18h] [bp-198h]@1
  char *v12; // [sp+1Ch] [bp-194h]@1
  int v13; // [sp+20h] [bp-190h]@1
  int v14; // [sp+24h] [bp-18Ch]@1
  char v15; // [sp+28h] [bp-188h]@1
  char Dst; // [sp+29h] [bp-187h]@1

  v14 = a5;
  v13 = a6;
  v15 = 0;
  memset(&Dst, 0, 0x181u);
  v9 = 0;
  v10 = 0;
  v8 = 0;
  v12 = &v15;
  v11 = 386;
  result = BaseRegGetKeySemantics(KeyHandle, Source, (int)&v8);
  if ( result >= 0 )
  {
    v7 = BaseRegOpenClassKeyFromLocation((int)&v8, KeyHandle, (int)Source, a4, 3, a3, v14, v13);
    BaseRegReleaseKeySemantics((int)&v8);
    result = v7;
  }
  return result;
}

//----- (77E27697) --------------------------------------------------------
int __stdcall BaseRegGetUserPrefixLength(int a1)
{
  int v1; // esi@1
  unsigned __int16 v2; // dx@3
  __int16 v3; // ax@4
  int result; // eax@9
  UNICODE_STRING DestinationString; // [sp+8h] [bp-18h]@8
  UNICODE_STRING String1; // [sp+10h] [bp-10h]@1
  UNICODE_STRING String2; // [sp+18h] [bp-8h]@1
  signed int v8; // [sp+28h] [bp+8h]@3

  v1 = a1;
  *(_DWORD *)&String2.Length = *(_DWORD *)a1;
  String2.Buffer = *(PWCH *)(a1 + 4);
  RtlInitUnicodeStringEx(&String1, L"\\Registry\\User");
  if ( String2.Length <= String1.Length )
  {
    result = 0;
  }
  else
  {
    String2.Length = String1.Length;
    if ( RtlEqualUnicodeString(&String1, &String2, 1u) )
    {
      v2 = *(_WORD *)a1 >> 1;
      v8 = 15;
      if ( v2 > 0xFu )
      {
        do
        {
          v3 = *(_WORD *)(*(_DWORD *)(v1 + 4) + 2 * (unsigned __int16)v8);
          if ( v3 == 92 )
            break;
          if ( v3 == 95 )
          {
            RtlInitUnicodeStringEx(&DestinationString, L"_Classes");
            String2.Length = DestinationString.Length;
            String2.Buffer = (PWCH)(*(_DWORD *)(v1 + 4) + 2 * (unsigned __int16)v8);
            if ( !RtlEqualUnicodeString(&String2, &DestinationString, 1u) )
              break;
            return (unsigned __int16)v8 + 8;
          }
          ++v8;
        }
        while ( (unsigned __int16)v8 < v2 );
      }
    }
    result = 0;
  }
  return result;
}

//----- (77E277A2) --------------------------------------------------------
NTSTATUS __stdcall BaseRegTranslateToUserClassKey(int a1, PUNICODE_STRING Destination, int a3)
{
  NTSTATUS result; // eax@1
  UNICODE_STRING Source; // [sp+4h] [bp-8h]@1

  KeySemanticsRemovePrefix(a1, (int)&Source, 1);
  result = BaseRegConstructUserClassPrefix(a1, Destination);
  if ( result >= 0 )
  {
    *(_WORD *)a3 = Destination->Length;
    result = RtlAppendUnicodeStringToString(Destination, &Source);
  }
  return result;
}

//----- (77E277E6) --------------------------------------------------------
NTSTATUS __stdcall BaseRegConstructUserClassPrefix(int a1, PUNICODE_STRING DestinationString)
{
  NTSTATUS result; // eax@2
  UNICODE_STRING v3; // [sp+0h] [bp-10h]@8
  UNICODE_STRING SourceString; // [sp+8h] [bp-8h]@2

  if ( !(*(_BYTE *)a1 & 1) )
  {
    result = RtlFormatCurrentUserKeyPath(&SourceString);
    if ( result < 0 )
      return result;
    RtlCopyUnicodeString(DestinationString, &SourceString);
    RtlFreeUnicodeString(&SourceString);
    goto LABEL_4;
  }
  KeySemanticsGetSid(a1, (int)&SourceString);
  RtlInitUnicodeStringEx(&v3, L"\\Registry\\User");
  RtlCopyUnicodeString(DestinationString, &v3);
  result = RtlAppendUnicodeStringToString(DestinationString, &SourceString);
  if ( result >= 0 )
LABEL_4:
    result = RtlAppendUnicodeToString(DestinationString, L"_Classes");
  return result;
}
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);

//----- (77E2783C) --------------------------------------------------------
int __stdcall BaseRegGetUserAndMachineClass(int a1, HANDLE KeyHandle, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@1
  int result; // eax@2
  char v9; // al@4
  int v10; // [sp+Ch] [bp-1B4h]@1
  int v11; // [sp+10h] [bp-1B0h]@1
  int v12; // [sp+14h] [bp-1ACh]@1
  int v13; // [sp+18h] [bp-1A8h]@1
  char *v14; // [sp+1Ch] [bp-1A4h]@1
  int v15; // [sp+20h] [bp-1A0h]@1
  UNICODE_STRING Source; // [sp+24h] [bp-19Ch]@1
  int v17; // [sp+2Ch] [bp-194h]@1
  char v18; // [sp+30h] [bp-190h]@1
  char Dst; // [sp+31h] [bp-18Fh]@1

  v10 = 0;
  v17 = a1;
  v15 = a5;
  v5 = a4;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  Source.Length = 0;
  *(_DWORD *)&Source.MaximumLength = 0;
  HIWORD(Source.Buffer) = 0;
  v18 = 0;
  memset(&Dst, 0, 0x189u);
  *(_DWORD *)a4 = 0;
  v6 = v15;
  v7 = v17;
  *(_DWORD *)v15 = 0;
  if ( !v7 )
  {
    v10 &= 0xFFFFFFDF;
    v14 = &v18;
    v13 = 394;
    result = BaseRegGetKeySemantics(KeyHandle, &Source, (int)&v10);
    if ( result < 0 )
      return result;
    v7 = (int)&v10;
  }
  v9 = 2;
  if ( *(_BYTE *)v7 & 2 )
  {
    *(_DWORD *)a4 = KeyHandle;
    v5 = v6;
  }
  else
  {
    *(_DWORD *)v6 = KeyHandle;
    v9 = 1;
  }
  BaseRegOpenClassKeyFromLocation(v7, KeyHandle, (int)&Source, a3 & 0x1000300 | 0x2000000, v9, 0, v5, 0);
  if ( !v17 )
    BaseRegReleaseKeySemantics((int)&v10);
  return 0;
}

//----- (77E27A15) --------------------------------------------------------
void __stdcall SortGetSortKey(int a1, int a2, void *a3, signed int a4, void *a5, int a6, int a7, int a8)
{
  int v8; // eax@71
  int v9; // edi@71
  int v10; // ecx@71
  unsigned __int16 v11; // cx@73
  int v12; // edi@73
  int v13; // eax@74
  unsigned __int16 v14; // bx@74
  unsigned int v15; // eax@78
  int v16; // ebx@80
  int v17; // edx@84
  signed int v18; // edi@85
  unsigned int v19; // eax@85
  signed __int16 v20; // cx@94
  int v21; // eax@95
  signed int v22; // edi@96
  int v23; // ecx@98
  int v24; // edx@99
  PPEB v25; // eax@102
  PPEB v26; // eax@105
  int v27; // ebp@0
  int v28; // esi@1
  int v29; // eax@2
  int v30; // ebx@9
  int v31; // edi@16
  char *v32; // esi@16
  int v33; // ecx@25
  int v34; // esi@25
  int v35; // edi@27
  unsigned __int16 v36; // bx@27
  int v37; // ecx@28
  int v38; // eax@28
  unsigned __int8 v39; // dl@29
  int v40; // edi@32
  __int16 v41; // cx@32
  int v42; // eax@32
  int v43; // ecx@32
  char v44; // al@35
  int v45; // edx@36
  char v46; // al@38
  int v47; // edx@39
  bool v48; // zf@39
  void *v49; // esi@42
  char *v50; // ebx@42
  PVOID k; // eax@43
  int v52; // edi@45
  int v53; // esi@45
  int v54; // esi@46
  int v55; // edi@47
  int v56; // edx@47
  int v57; // esi@47
  int v58; // esi@48
  unsigned int v59; // eax@49
  int v60; // eax@53
  unsigned int v61; // ecx@53
  int v62; // edi@66
  __int16 v63; // ax@66
  int v64; // ecx@66
  char v65; // al@66
  char v66; // al@67
  unsigned int v67; // ecx@106
  int v68; // eax@106
  signed __int16 v69; // bx@116
  char v70; // al@116
  int v71; // edi@117
  int v72; // ecx@117
  char v73; // al@120
  int v74; // eax@121
  int v75; // edx@123
  int v76; // esi@123
  int v77; // eax@130
  int v78; // eax@134
  unsigned int v79; // eax@136
  int v80; // ecx@140
  int v81; // eax@144
  unsigned __int16 v82; // di@145
  int v83; // edi@146
  int v84; // ebx@147
  int v85; // eax@147
  int v86; // ebx@151
  int l; // edi@159
  int v88; // eax@167
  int v89; // edx@168
  int v90; // eax@169
  int v91; // edi@170
  int v92; // ecx@171
  __int16 v93; // bx@171
  int v94; // edi@171
  char v95; // bl@172
  char v96; // cl@174
  int v97; // edi@175
  unsigned int v98; // eax@175
  __int16 v99; // dx@178
  int v100; // ecx@178
  char v101; // cl@179
  char v102; // al@181
  char v103; // al@182
  int v104; // edi@184
  unsigned int v105; // edx@185
  int v106; // edx@187
  __int16 v107; // cx@190
  char v108; // dl@190
  int v109; // ecx@192
  int v110; // eax@192
  int v111; // ecx@192
  int v112; // ecx@196
  char v113; // al@198
  char v114; // al@201
  int v115; // ebx@247
  int v116; // eax@247
  signed int v117; // eax@220
  int v118; // esi@222
  int v119; // edx@223
  char *v120; // ecx@224
  int v121; // eax@224
  int v122; // edx@225
  int v123; // eax@234
  int v124; // eax@235
  int v125; // ecx@241
  int v126; // eax@242
  int v127; // eax@245
  int v128; // ecx@251
  int v129; // edi@253
  int v130; // ebx@255
  int v131; // edx@256
  int v132; // eax@256
  int v133; // edx@259
  int v134; // ebx@264
  int v135; // eax@264
  int v136; // ecx@271
  int v137; // eax@275
  int v138; // edi@277
  int v139; // edx@278
  int v140; // eax@278
  int v141; // edx@282
  int v142; // edi@287
  int v143; // ebx@288
  int v144; // eax@288
  int v145; // ecx@295
  int v146; // eax@299
  int v147; // edi@301
  int v148; // edx@302
  int v149; // eax@302
  int v150; // edx@306
  int v151; // edi@311
  int v152; // ebx@312
  int v153; // eax@312
  int v154; // ecx@320
  int v155; // eax@324
  int v156; // edi@326
  int v157; // edx@327
  int v158; // eax@327
  int v159; // edx@331
  int v160; // edi@336
  int v161; // ebx@337
  int v162; // eax@337
  int v163; // ecx@344
  int v164; // eax@348
  int v165; // edi@350
  int v166; // edx@351
  int v167; // eax@351
  int v168; // edx@355
  int v169; // edi@360
  int v170; // ebx@361
  int v171; // eax@361
  int v172; // edi@368
  int v173; // edx@369
  int v174; // eax@369
  int v175; // edx@373
  int v176; // edi@378
  int v177; // edx@379
  int v178; // eax@379
  int v179; // eax@382
  unsigned int v180; // ecx@382
  unsigned __int8 v181; // al@398
  unsigned __int8 v182; // al@401
  int v183; // edi@404
  __int16 v184; // ax@404
  unsigned __int8 v185; // al@405
  char v186; // al@407
  unsigned __int8 v187; // al@410
  unsigned __int8 v188; // al@415
  unsigned int v189; // edx@419
  unsigned __int8 v190; // bl@420
  unsigned __int8 v191; // bl@423
  unsigned __int8 v192; // cl@427
  unsigned __int8 v193; // cl@430
  int v194; // edi@440
  char v195; // cl@441
  int v196; // eax@441
  unsigned __int8 v197; // dl@441
  int v198; // ecx@441
  char v199; // dl@441
  int v200; // edi@442
  int v201; // ecx@442
  __int16 v202; // ax@442
  unsigned __int8 v203; // bl@444
  unsigned __int8 v204; // bl@447
  unsigned int i; // ecx@450
  signed int v206; // eax@456
  int v207; // ecx@458
  char *v208; // edx@459
  int v209; // edi@459
  int v210; // eax@460
  int j; // ecx@460
  DWORD v212; // [sp-4h] [bp-E30h]@0
  PVOID v213; // [sp-4h] [bp-E30h]@165
  int v214; // [sp+10h] [bp-E1Ch]@440
  unsigned int v215; // [sp+14h] [bp-E18h]@1
  unsigned __int8 v216; // [sp+18h] [bp-E14h]@440
  char v217; // [sp+19h] [bp-E13h]@441
  unsigned __int8 v218; // [sp+1Ah] [bp-E12h]@441
  char v219; // [sp+1Fh] [bp-E0Dh]@190
  int v220; // [sp+24h] [bp-E08h]@15
  char v221; // [sp+28h] [bp-E04h]@17
  int v222; // [sp+2Ch] [bp-E00h]@25
  int v223; // [sp+30h] [bp-DFCh]@25
  int v224; // [sp+34h] [bp-DF8h]@25
  int v225; // [sp+38h] [bp-DF4h]@25
  int v226; // [sp+3Ch] [bp-DF0h]@25
  int v227; // [sp+40h] [bp-DECh]@14
  PVOID Address; // [sp+44h] [bp-DE8h]@16
  unsigned int v229; // [sp+48h] [bp-DE4h]@25
  int v230; // [sp+4Ch] [bp-DE0h]@25
  int v231; // [sp+50h] [bp-DDCh]@25
  unsigned int v232; // [sp+54h] [bp-DD8h]@25
  unsigned int v233; // [sp+5Ch] [bp-DD0h]@14
  int v234; // [sp+60h] [bp-DCCh]@16
  int v235; // [sp+64h] [bp-DC8h]@25
  unsigned int v236; // [sp+68h] [bp-DC4h]@25
  int v237; // [sp+6Ch] [bp-DC0h]@25
  int v238; // [sp+70h] [bp-DBCh]@25
  int v239; // [sp+74h] [bp-DB8h]@25
  int v240; // [sp+7Ch] [bp-DB0h]@29
  int v241; // [sp+84h] [bp-DA8h]@25
  unsigned __int8 v242; // [sp+8Bh] [bp-DA1h]@116
  int v243; // [sp+8Ch] [bp-DA0h]@1
  int v244; // [sp+90h] [bp-D9Ch]@27
  int v245; // [sp+94h] [bp-D98h]@116
  int v246; // [sp+98h] [bp-D94h]@45
  int v247; // [sp+9Ch] [bp-D90h]@73
  int v248; // [sp+A0h] [bp-D8Ch]@73
  int v249; // [sp+A4h] [bp-D88h]@42
  char v250; // [sp+A8h] [bp-D84h]@16
  void *v251; // [sp+E24h] [bp-8h]@102
  int v252; // [sp+E28h] [bp-4h]@102
  int savedregs; // [sp+E2Ch] [bp+0h]@102

  v28 = a1;
  v243 = a1;
  v215 = (unsigned int)a3;
  if ( !a1 )
    goto LABEL_162;
  v29 = a4;
  if ( !a4 || a6 < 0 || !a3 || a6 && !a5 )
    goto LABEL_162;
  if ( a3 == a5 )
    goto LABEL_162;
  if ( a4 <= -1 )
    v29 = SortNlsStrLenW(a3) + 1;
  v30 = a2;
  if ( a2 & 0xE7FCEFC0
    || (unsigned __int8)a2 & (unsigned __int8)((a2 & 0xE2) - 1) & 0x22
    || (unsigned __int8)a2 & (unsigned __int8)((a2 & 0xF1) - 1) & 0x11 )
  {
    SetLastError(0x3ECu);
    return;
  }
  if ( !(a2 & 0x8000000) )
  {
    v28 = *(_DWORD *)(a1 + 276);
    v243 = *(_DWORD *)(a1 + 276);
  }
  v233 = (unsigned int)((char *)a3 + 2 * v29);
  v227 = *(_DWORD *)(v28 + 240) & 1;
  if ( !(*pSortTblPtrs)[11] )
  {
    SetLastError(2u);
    return;
  }
  v220 = (*pSortTblPtrs)[14];
  if ( v29 > 64 )
  {
    if ( (unsigned int)v29 <= 0x25ED097 )
    {
      v31 = 3 * v29;
      v25 = NtCurrentTeb()->ProcessEnvironmentBlock;
      savedregs = 18 * v31;
      v252 = 8;
      v251 = v25->Reserved4[1];
      v234 = v31;
      v32 = (char *)RtlAllocateHeap(v251, 8u, 18 * v31);
      Address = v32;
      if ( v32 )
        goto LABEL_17;
      savedregs = 14;
LABEL_209:
      SetLastError(v212);
      return;
    }
LABEL_162:
    savedregs = 87;
    goto LABEL_209;
  }
  v31 = 192;
  v32 = &v250;
  v234 = 192;
  Address = &v250;
LABEL_17:
  v221 = -1;
  switch ( v30 & 0x30001 )
  {
    case 1:
      v221 = -25;
      break;
    case 65536:
      v221 = -33;
      break;
    case 65537:
      v221 = -57;
      break;
    case 131072:
      v221 = -2;
      break;
    case 131073:
      v221 = -26;
      break;
    case 196608:
      v221 = -34;
      break;
    case 196609:
      v221 = -58;
      break;
  }
  v33 = (int)&v32[8 * v31];
  v230 = v31 + v33;
  v237 = v31 + v33;
  v222 = a2 & 0x1000;
  v223 = a2 & 4;
  v226 = a2 & 8;
  v224 = a2 & 0x10;
  v241 = 0;
  v235 = (int)v32;
  v34 = v215;
  v229 = v33;
  v231 = v31 + v33 + v31;
  v232 = v231 + 4 * v31;
  v236 = v33;
  v238 = v31 + v33 + v31;
  v239 = v231 + 4 * v31;
  v225 = a2 & 0x20;
  while ( 1 )
  {
    if ( v34 >= v233 )
    {
      if ( !a6 )
      {
        v75 = a2;
        v76 = v235 - (_DWORD)Address;
        if ( !(a2 & 2) )
        {
          v77 = v236 - 1;
          if ( *(_DWORD *)(v243 + 228) == 1 )
          {
            for ( i = v229; i <= v77 && *(_BYTE *)i <= 2u; ++i )
              ;
            v78 = v77 - i;
          }
          else
          {
            while ( v77 >= v229 && *(_BYTE *)v77 <= 2u )
              --v77;
            v78 = v77 - v229;
          }
          v76 += v78 + 1;
        }
        if ( (v75 & 0x20001) != 131073 )
        {
          v79 = v237;
          do
            --v79;
          while ( v79 >= v230 && *(_BYTE *)v79 <= 2u );
          v76 += v79 - v230 + 1;
        }
        if ( v231 < (unsigned int)v238 )
        {
          if ( a2 & 2 )
          {
            v206 = 2;
            v76 += 2;
          }
          else
          {
            v206 = 0;
          }
          v207 = v238 - 1;
          if ( v206 < 4 )
          {
            v208 = (char *)&pXWDrop + v206;
            v247 = v231 - v207;
            v209 = v207 + v234 * v206;
            do
            {
              v210 = v209 + v247;
              for ( j = v209; j >= (unsigned int)v210; --j )
              {
                if ( *(_BYTE *)j != *v208 )
                  break;
              }
              v209 += v234;
              ++v208;
              v76 += j - v210 + 2;
            }
            while ( (signed int)v208 < (signed int)&loc_77E45480 );
          }
        }
        if ( Address != &v250 && Address )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        return;
      }
      v49 = a5;
      v50 = (char *)Address;
      v249 = (int)((char *)a5 + a6);
      if ( a6 < v235 - (signed int)Address + 5 )
        goto LABEL_211;
      for ( k = Address; (unsigned int)k < v235; k = (char *)k + 1 )
      {
        *(_BYTE *)v49 = *(_BYTE *)k;
        v49 = (char *)v49 + 1;
      }
      v52 = a2;
      *(_BYTE *)v49 = 1;
      v53 = (int)((char *)v49 + 1);
      v246 = a2 & 2;
      if ( a2 & 2 )
      {
LABEL_46:
        *(_BYTE *)v53 = 1;
        v54 = v53 + 1;
        if ( (v52 & 0x20001) == 131073 )
          goto LABEL_47;
        v67 = v237;
        v68 = v230;
        do
          --v67;
        while ( v67 >= v230 && *(_BYTE *)v67 <= 2u );
        if ( v249 - v54 > (signed int)(v67 - v230 + 3) )
        {
          while ( v68 <= v67 )
            *(_BYTE *)v54++ = *(_BYTE *)v68++;
LABEL_47:
          v55 = v231;
          v56 = v238;
          *(_BYTE *)v54 = 1;
          v57 = v54 + 1;
          if ( v55 < (unsigned int)v56 )
          {
            v117 = 0;
            if ( v246 )
            {
              if ( v249 - v57 <= 4 )
              {
                if ( v50 == &v250 || !v50 )
                  goto LABEL_208;
                v213 = v50;
                goto LABEL_207;
              }
              *(_BYTE *)v57 = -1;
              v118 = v57 + 1;
              *(_BYTE *)v118 = 2;
              v57 = v118 + 1;
              v117 = 2;
            }
            v119 = v56 - 1;
            if ( v117 < 4 )
            {
              v120 = (char *)&pXWSeparator + v117;
              v121 = v119 + v234 * v117;
              v247 = v55 - v119;
              v246 = (char *)&pXWDrop - (char *)&pXWSeparator;
              v245 = v121;
              while ( 1 )
              {
                v122 = v121 + v247;
                for ( l = v121; l >= (unsigned int)v122; --l )
                {
                  if ( *(_BYTE *)l != v120[v246] )
                    break;
                }
                if ( v249 - v57 <= l - v122 + 2 )
                  goto LABEL_469;
                while ( v122 <= (unsigned int)l )
                  *(_BYTE *)v57++ = *(_BYTE *)v122++;
                *(_BYTE *)v57 = *v120;
                v121 = v234 + v245;
                ++v57;
                ++v120;
                v245 += v234;
                if ( (signed int)v120 >= (signed int)&loc_77E45558 )
                {
                  v50 = (char *)Address;
                  break;
                }
              }
            }
          }
          *(_BYTE *)v57 = 1;
          v58 = v57 + 1;
          if ( v223 )
            goto LABEL_51;
          v59 = v232;
          if ( v249 - v58 >= (signed int)(v239 - v232 + 1) )
          {
            while ( v59 < v239 )
              *(_BYTE *)v58++ = *(_BYTE *)v59++;
LABEL_51:
            *(_BYTE *)v58 = 0;
            if ( v50 != &v250 && v50 )
            {
              v26 = NtCurrentTeb()->ProcessEnvironmentBlock;
              savedregs = (int)v50;
              v252 = 0;
              RtlFreeHeap(v26->Reserved4[1], 0, v50);
            }
            return;
          }
          if ( v50 == &v250 || !v50 )
          {
LABEL_208:
            v212 = 122;
            goto LABEL_209;
          }
          v213 = v50;
LABEL_207:
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v213);
          goto LABEL_208;
        }
LABEL_211:
        if ( v50 == &v250 || !v50 )
          goto LABEL_208;
        v213 = v50;
        goto LABEL_207;
      }
      v60 = v236 - 1;
      v61 = v229;
      if ( *(_DWORD *)(v243 + 228) == 1 )
      {
        while ( v61 <= v60 && *(_BYTE *)v61 <= 2u )
          ++v61;
        if ( v249 - v53 > (signed int)(v60 - v61 + 4) )
        {
          while ( v60 >= v61 )
            *(_BYTE *)v53++ = *(_BYTE *)v60--;
          goto LABEL_59;
        }
      }
      else
      {
        while ( v60 >= v229 && *(_BYTE *)v60 <= 2u )
          --v60;
        if ( v249 - v53 > (signed int)(v60 - v229 + 4) )
        {
          while ( v61 <= v60 )
            *(_BYTE *)v53++ = *(_BYTE *)v61++;
LABEL_59:
          v50 = (char *)Address;
          goto LABEL_46;
        }
      }
LABEL_469:
      if ( Address == &v250 || !Address )
        goto LABEL_208;
      v213 = Address;
      goto LABEL_207;
    }
    v35 = *(_DWORD *)(v243 + 224);
    v36 = *(_WORD *)v34;
    v244 = v35;
    if ( v35 )
    {
      v37 = (*pSortTblPtrs)[11];
      v38 = v37 + 4 * ((v36 & 0xFF) + *(_DWORD *)(v35 + 4 * ((unsigned int)v36 >> 8)));
    }
    else
    {
      v37 = (*pSortTblPtrs)[11];
      v38 = v37 + 4 * v36;
    }
    v39 = *(_BYTE *)(v38 + 1);
    v240 = v38;
    if ( v39 > 0xCu )
      break;
    if ( (signed int)v39 > 4 )
    {
      if ( v39 != 5 )
      {
        if ( v39 == 6 )
        {
          if ( v222 )
            goto LABEL_65;
          if ( (unsigned __int16)(-1 - ((unsigned int)(v235 - (_DWORD)Address) >> 1)) <= 1u )
            v20 = 2;
          else
            v20 = -1 - ((unsigned int)(v235 - (_DWORD)Address) >> 1);
          v21 = v239;
          *(_BYTE *)v239 = HIBYTE(v20);
          *(_BYTE *)(v21 + 1) = v20;
          if ( v225 && ((v203 = *(_BYTE *)(v240 + 1), v203 <= 0x14u) || v203 == 41) )
            v22 = 2;
          else
            v22 = *(_BYTE *)(v240 + 2);
          if ( v224 && ((v204 = *(_BYTE *)(v240 + 1), v204 <= 0x14u) || v204 == 41) )
            v23 = 2;
          else
            v23 = *(_BYTE *)(v240 + 3) & 0x3F;
          v24 = (v23 | 8 * v22) + (unsigned __int16)(*(_BYTE *)v240 << 8);
          *(_BYTE *)(v21 + 2) = BYTE1(v24);
          *(_BYTE *)(v21 + 3) = v24;
          v239 = v21 + 4;
          goto LABEL_40;
        }
        if ( (signed int)v39 <= 6 || (signed int)v39 > 12 )
          goto LABEL_40;
LABEL_65:
        if ( v223 )
          goto LABEL_40;
        v62 = v240;
        v63 = *(_WORD *)v240;
        v64 = v235;
        *(_BYTE *)v235 = *(_WORD *)v240 >> 8;
        *(_BYTE *)(v64 + 1) = v63;
        LOBYTE(v63) = *(_BYTE *)(v62 + 2);
        v235 = v64 + 2;
        *(_BYTE *)v236 = v63;
        v65 = v221 & *(_BYTE *)(v62 + 3);
LABEL_67:
        v66 = v65 & 0x3F;
        goto LABEL_68;
      }
      v109 = v235;
      v110 = v240;
      *(_BYTE *)v235 = -3;
      *(_BYTE *)(v109 + 1) = -1;
      LOWORD(v110) = *(_BYTE *)(v110 + 2) | (unsigned __int16)(*(_BYTE *)v110 << 8);
      *(_BYTE *)(v109 + 2) = BYTE1(v110);
      *(_BYTE *)(v109 + 3) = v110;
      v111 = v109 + 4;
      goto LABEL_193;
    }
    if ( v39 == 4 )
    {
      if ( v36 >= 0x1160u || (v194 = MapOldHangulSortKey(v243, v34, v233, (int)&v214, (int)&v216), v194 <= 0) )
      {
        v200 = v240;
        v201 = v235;
        v202 = *(_BYTE *)(v240 + 2) | (unsigned __int16)(*(_BYTE *)v240 << 8);
        *(_BYTE *)v235 = HIBYTE(v202);
        *(_BYTE *)(v201 + 1) = v202;
        *(_BYTE *)v236 = 2;
        v65 = *(_BYTE *)(v200 + 3);
        v235 = v201 + 2;
        goto LABEL_67;
      }
      v195 = v214;
      v196 = v235;
      *(_BYTE *)v235 = BYTE1(v214);
      *(_BYTE *)(v196 + 1) = v195;
      v197 = v216;
      v198 = v196 + 2;
      *(_BYTE *)v198 = (unsigned __int16)(v216 | 0xFF00) >> 8;
      LOBYTE(v196) = v217;
      ++v198;
      *(_BYTE *)v198 = v197;
      v199 = v196;
      ++v198;
      *(_BYTE *)v198 = (unsigned __int16)(v196 | 0xFF00) >> 8;
      LOWORD(v196) = v218 | 0xFF00;
      ++v198;
      *(_BYTE *)v198++ = v199;
      *(_BYTE *)v198++ = BYTE1(v196);
      *(_BYTE *)v198 = v196;
      v111 = v198 + 1;
      v34 = v34 + 2 * v194 - 2;
LABEL_193:
      *(_BYTE *)v236 = 2;
      *(_BYTE *)v237 = 2;
      v235 = v111;
      goto LABEL_69;
    }
    if ( v39 == 1 )
    {
      v112 = v236;
      if ( v236 <= v229 )
      {
        if ( v225 && (v39 <= 0x14u || v39 == 41) )
          v114 = 2;
        else
          v114 = *(_BYTE *)(v240 + 2);
        *(_BYTE *)v236 = v114;
        v236 = v112 + 1;
      }
      else
      {
        if ( v225 && (v39 <= 0x14u || v39 == 41) )
          v113 = 2;
        else
          v113 = *(_BYTE *)(v240 + 2);
        *(_BYTE *)(v236 - 1) += v113;
      }
      goto LABEL_40;
    }
    if ( v39 == 2 )
    {
      v88 = v240;
      if ( v39 == 2 )
      {
        v89 = v220;
        do
        {
          v90 = v88 + 2;
          if ( v35 )
          {
            v189 = *(_WORD *)(v89 + 4 * *(_WORD *)v90);
            v91 = (unsigned __int8)v189 + *(_DWORD *)(v35 + 4 * (v189 >> 8));
            v89 = v220;
          }
          else
          {
            v91 = *(_WORD *)(v89 + 4 * *(_WORD *)v90);
          }
          v92 = v37 + 4 * v91;
          v93 = *(_WORD *)v92;
          v245 = *(_WORD *)v92;
          v94 = v235;
          *(_BYTE *)v235 = HIBYTE(v93);
          *(_BYTE *)(v94 + 1) = v245;
          v235 = v94 + 2;
          if ( v225 && ((v190 = *(_BYTE *)(v92 + 1), v190 <= 0x14u) || v190 == 41) )
            v95 = 2;
          else
            v95 = *(_BYTE *)(v92 + 2);
          v48 = v224 == 0;
          *(_BYTE *)v236 = v95;
          if ( v48 || (v191 = *(_BYTE *)(v92 + 1), v191 > 0x14u) && v191 != 41 )
            v96 = *(_BYTE *)(v92 + 3) & 0x3F;
          else
            v96 = 2;
          v97 = v237;
          ++v236;
          ++v237;
          *(_BYTE *)v97 = v221 & v96;
          v35 = *(_DWORD *)(v243 + 224);
          v98 = *(_WORD *)(v89 + 4 * *(_WORD *)v90 + 2);
          v37 = (*pSortTblPtrs)[11];
          if ( v35 )
            v88 = v37 + 4 * ((unsigned __int8)v98 + *(_DWORD *)(v35 + 4 * (v98 >> 8)));
          else
            v88 = v37 + 4 * v98;
        }
        while ( *(_BYTE *)(v88 + 1) == 2 );
      }
      v99 = *(_WORD *)v88;
      v100 = v235;
      *(_BYTE *)v235 = *(_WORD *)v88 >> 8;
      *(_BYTE *)(v100 + 1) = v99;
      v235 = v100 + 2;
      if ( v225 && ((v192 = *(_BYTE *)(v88 + 1), v192 <= 0x14u) || v192 == 41) )
        v101 = 2;
      else
        v101 = *(_BYTE *)(v88 + 2);
      v48 = v224 == 0;
      *(_BYTE *)v236 = v101;
      if ( !v48 )
      {
        v193 = *(_BYTE *)(v88 + 1);
        if ( v193 <= 0x14u || v193 == 41 )
        {
LABEL_412:
          v103 = 2;
LABEL_183:
          v66 = v221 & v103;
LABEL_68:
          *(_BYTE *)v237 = v66;
LABEL_69:
          ++v236;
          ++v237;
          goto LABEL_40;
        }
      }
      v102 = *(_BYTE *)(v88 + 3);
LABEL_182:
      v103 = v102 & 0x3F;
      goto LABEL_183;
    }
    if ( v39 == 3 )
    {
      v242 = *(_BYTE *)v240;
      v69 = -1;
      v70 = v221 & *(_BYTE *)(v240 + 3) | 0xC4;
      v245 = 0xFFFF;
      if ( v242 > 1u )
      {
        v71 = v238;
        v69 = v242 | 0x2200;
        *(_BYTE *)v238 = v70 & 0xC6;
        v72 = v234;
        *(_BYTE *)(v71 + v234) = 3;
        *(_BYTE *)(v71 + 2 * v72) = v70 & 0xE4;
        goto LABEL_118;
      }
      v104 = v34 - 2;
      v246 = v34 - 2;
      if ( v34 - 2 >= v215 )
      {
        while ( 1 )
        {
          v105 = *(_WORD *)v104;
          if ( v244 )
          {
            v105 = *(_DWORD *)(v244 + 4 * (v105 >> 8)) + (unsigned __int8)v105;
            v104 = v246;
          }
          v106 = *(_DWORD *)(v37 + 4 * v105);
          if ( BYTE1(v106) < 3u )
          {
            if ( BYTE1(v106) == 2 )
              goto LABEL_414;
          }
          else
          {
            if ( BYTE1(v106) != 3 )
            {
              v69 = v106;
              break;
            }
            if ( (unsigned __int8)v106 > 1u )
            {
              v107 = (unsigned __int8)v106;
              v71 = v238;
              v108 = v221 & BYTE3(v106) | 0xC4;
              v69 = v107 | 0x2200;
              *(_BYTE *)v238 = v108 & 0xC6;
              v72 = v234;
              v219 = v108;
              v48 = v242 == 0;
              *(_BYTE *)(v71 + 2 * v234) = v108 & 0xE4;
              if ( v48 )
              {
                v70 = v219;
                *(_BYTE *)(v71 + v72) = 4;
              }
              else
              {
                v69 &= 0xFF87u;
                *(_BYTE *)(v71 + v72) = 5;
              }
LABEL_118:
              *(_BYTE *)(3 * v72 + v71) = v70 & 0xC5;
              v238 = v71 + 1;
              break;
            }
          }
          v104 -= 2;
          v246 = v104;
          if ( v104 < v215 )
          {
LABEL_414:
            v69 = v245;
            break;
          }
        }
      }
      if ( v225 && ((v188 = *(_BYTE *)(v240 + 1), v188 <= 0x14u) || v188 == 41) )
        v73 = 2;
      else
        v73 = *(_BYTE *)(v240 + 2);
      *(_BYTE *)v236 = v73;
      *(_BYTE *)v237 = 2;
      v74 = v235;
      *(_BYTE *)v235 = HIBYTE(v69);
      *(_BYTE *)(v74 + 1) = v69;
      v235 = v74 + 2;
      if ( v69 != -1 )
        goto LABEL_69;
    }
LABEL_40:
    v34 += 2;
  }
  if ( *(_DWORD *)(v243 + 232) )
  {
    v82 = 0;
    v123 = (unsigned __int8)(((unsigned __int8)(v39 - 3) != 0 ? *(_BYTE *)(v240 + 3) : 0) & 0xC0) - 64;
    v247 = 0;
    v241 = 0;
    if ( !v123 )
      goto LABEL_238;
    v124 = v123 - 64;
    if ( v124 )
    {
      if ( v124 != 64 )
      {
LABEL_237:
        v39 = *(_BYTE *)(v240 + 1);
        goto LABEL_31;
      }
      v86 = v243;
      v244 = *(_DWORD *)(v243 + 272);
      if ( *(_WORD *)(*(_DWORD *)(v243 + 244) + 20) > 0u )
      {
        v128 = *(_DWORD *)(v243 + 236);
        if ( v34 + 2 * (8 - (unsigned int)(v128 == 0)) <= v233 )
        {
          v247 = NlsCountOfWCharsWithinRange(
                   (unsigned __int16 *)v34,
                   v233,
                   8,
                   *(_WORD *)(*(_DWORD *)(v243 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v243 + 244) + 6),
                   v128,
                   0);
          if ( v247 >= 8 )
          {
            v129 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 20) - 1;
            v249 = 0;
            v248 = 0;
            if ( *(_DWORD *)(v86 + 236) && v34 + 16 < v233 )
            {
              v130 = *(_DWORD *)(v86 + 224);
              if ( v130 )
              {
                v131 = (*pSortTblPtrs)[11];
                v132 = *(_DWORD *)(v130 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
              }
              else
              {
                v131 = (*pSortTblPtrs)[11];
                v132 = *(_WORD *)v34;
              }
              v246 = *(_DWORD *)(v131 + 4 * v132);
              v133 = v130 ? *(_DWORD *)(v131
                                      + 4
                                      * (*(_DWORD *)(v130 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                       + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v131 + 4 * *(_WORD *)(v34 + 2));
              if ( !((v246 ^ v133) & 0xE7FFFFFF) )
                v249 = 1;
            }
            if ( v129 >= 0 )
            {
              while ( 1 )
              {
                v134 = (v129 + v248) / 2;
                v135 = NlsCompareRgWChar(v34 + 2 * v249, v244 + 20 * v134, 8);
                if ( !v135 )
                  break;
                if ( v135 >= 0 )
                  v248 = v134 + 1;
                else
                  v129 = v134 - 1;
                if ( v248 > v129 )
                  goto LABEL_269;
              }
              v241 = v249;
              v240 = 20 * v134 + v244 + 16;
              v34 += 2 * v249 + 14;
              goto LABEL_237;
            }
LABEL_269:
            v86 = v243;
            v82 = 0;
          }
        }
      }
      v245 = *(_DWORD *)(v86 + 268);
      if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 18) > v82 )
      {
        v136 = *(_DWORD *)(v86 + 236);
        if ( v34 + 2 * (7 - (unsigned int)(v136 == 0)) <= v233 )
        {
          if ( !v247 )
            v247 = NlsCountOfWCharsWithinRange(
                     (unsigned __int16 *)v34,
                     v233,
                     7,
                     *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
                     v136,
                     0);
          if ( v247 >= 7 )
          {
            v137 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 18) - 1;
            v246 = 0;
            v249 = 0;
            v248 = v137;
            if ( *(_DWORD *)(v86 + 236) && v34 + 14 < v233 )
            {
              v138 = *(_DWORD *)(v86 + 224);
              if ( v138 )
              {
                v139 = (*pSortTblPtrs)[11];
                v140 = *(_DWORD *)(v138 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
              }
              else
              {
                v139 = (*pSortTblPtrs)[11];
                v140 = *(_WORD *)v34;
              }
              v244 = *(_DWORD *)(v139 + 4 * v140);
              v141 = v138 ? *(_DWORD *)(v139
                                      + 4
                                      * (*(_DWORD *)(v138 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                       + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v139 + 4 * *(_WORD *)(v34 + 2));
              if ( !((v244 ^ v141) & 0xE7FFFFFF) )
                v246 = 1;
            }
            v82 = 0;
            if ( v248 >= 0 )
            {
              v142 = v246;
              do
              {
                v143 = (v249 + v248) / 2;
                v144 = NlsCompareRgWChar(v34 + 2 * v142, v245 + 20 * v143, 7);
                if ( !v144 )
                {
                  v241 = v142;
                  JUMPOUT(&loc_77E4546C);
                }
                if ( v144 >= 0 )
                  v249 = v143 + 1;
                else
                  v248 = v143 - 1;
              }
              while ( v249 <= v248 );
              v86 = v243;
              v82 = 0;
            }
          }
        }
      }
      v246 = *(_DWORD *)(v86 + 264);
      if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 16) <= v82 )
        goto LABEL_319;
      v145 = *(_DWORD *)(v86 + 236);
      if ( v34 + 2 * (6 - (unsigned int)(v145 == 0)) > v233 )
        goto LABEL_319;
      if ( !v247 )
        v247 = NlsCountOfWCharsWithinRange(
                 (unsigned __int16 *)v34,
                 v233,
                 6,
                 *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
                 *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
                 v145,
                 0);
      if ( v247 < 6 )
        goto LABEL_319;
      v146 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 16) - 1;
      v244 = 0;
      v249 = 0;
      v248 = v146;
      if ( *(_DWORD *)(v86 + 236) && v34 + 12 < v233 )
      {
        v147 = *(_DWORD *)(v86 + 224);
        if ( v147 )
        {
          v148 = (*pSortTblPtrs)[11];
          v149 = *(_DWORD *)(v147 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
        }
        else
        {
          v148 = (*pSortTblPtrs)[11];
          v149 = *(_WORD *)v34;
        }
        v245 = *(_DWORD *)(v148 + 4 * v149);
        v150 = v147 ? *(_DWORD *)(v148
                                + 4
                                * (*(_DWORD *)(v147 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                 + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v148 + 4 * *(_WORD *)(v34 + 2));
        if ( !((v245 ^ v150) & 0xE7FFFFFF) )
          v244 = 1;
      }
      v82 = 0;
      if ( v248 < 0 )
        goto LABEL_319;
      v151 = v244;
      do
      {
        v152 = (v249 + v248) / 2;
        v153 = NlsCompareRgWChar(v34 + 2 * v151, v246 + 16 * v152, 6);
        if ( !v153 )
        {
          v241 = v151;
          JUMPOUT(&loc_77E4546C);
        }
        if ( v153 >= 0 )
          v249 = v152 + 1;
        else
          v248 = v152 - 1;
      }
      while ( v249 <= v248 );
      v82 = 0;
    }
    v86 = v243;
LABEL_319:
    v246 = *(_DWORD *)(v86 + 260);
    if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 14) > v82 )
    {
      v154 = *(_DWORD *)(v86 + 236);
      if ( v34 + 2 * (5 - (unsigned int)(v154 == 0)) <= v233 )
      {
        if ( !v247 )
          v247 = NlsCountOfWCharsWithinRange(
                   (unsigned __int16 *)v34,
                   v233,
                   5,
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
                   v154,
                   0);
        if ( v247 >= 5 )
        {
          v155 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 14) - 1;
          v244 = 0;
          v249 = 0;
          v248 = v155;
          if ( *(_DWORD *)(v86 + 236) && v34 + 10 < v233 )
          {
            v156 = *(_DWORD *)(v86 + 224);
            if ( v156 )
            {
              v157 = (*pSortTblPtrs)[11];
              v158 = *(_DWORD *)(v156 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
            }
            else
            {
              v157 = (*pSortTblPtrs)[11];
              v158 = *(_WORD *)v34;
            }
            v245 = *(_DWORD *)(v157 + 4 * v158);
            v159 = v156 ? *(_DWORD *)(v157
                                    + 4
                                    * (*(_DWORD *)(v156 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                     + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v157 + 4 * *(_WORD *)(v34 + 2));
            if ( !((v245 ^ v159) & 0xE7FFFFFF) )
              v244 = 1;
          }
          v82 = 0;
          if ( v248 >= 0 )
          {
            v160 = v244;
            do
            {
              v161 = (v249 + v248) / 2;
              v162 = NlsCompareRgWChar(v34 + 2 * v160, v246 + 16 * v161, 5);
              if ( !v162 )
              {
                v241 = v160;
                JUMPOUT(&loc_77E4546C);
              }
              if ( v162 >= 0 )
                v249 = v161 + 1;
              else
                v248 = v161 - 1;
            }
            while ( v249 <= v248 );
            v86 = v243;
            v82 = 0;
          }
        }
      }
    }
    v246 = *(_DWORD *)(v86 + 256);
    if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 12) <= v82 )
      goto LABEL_239;
    v163 = *(_DWORD *)(v86 + 236);
    if ( v34 + 2 * (4 - (unsigned int)(v163 == 0)) > v233 )
      goto LABEL_239;
    if ( !v247 )
      v247 = NlsCountOfWCharsWithinRange(
               (unsigned __int16 *)v34,
               v233,
               4,
               *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
               *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
               v163,
               0);
    if ( v247 < 4 )
      goto LABEL_239;
    v164 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 12) - 1;
    v244 = 0;
    v249 = 0;
    v248 = v164;
    if ( *(_DWORD *)(v86 + 236) && v34 + 8 < v233 )
    {
      v165 = *(_DWORD *)(v86 + 224);
      if ( v165 )
      {
        v166 = (*pSortTblPtrs)[11];
        v167 = *(_DWORD *)(v165 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
      }
      else
      {
        v166 = (*pSortTblPtrs)[11];
        v167 = *(_WORD *)v34;
      }
      v245 = *(_DWORD *)(v166 + 4 * v167);
      v168 = v165 ? *(_DWORD *)(v166
                              + 4
                              * (*(_DWORD *)(v165 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                               + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v166 + 4 * *(_WORD *)(v34 + 2));
      if ( !((v245 ^ v168) & 0xE7FFFFFF) )
        v244 = 1;
    }
    v82 = 0;
    if ( v248 < 0 )
      goto LABEL_239;
    v169 = v244;
    do
    {
      v170 = (v249 + v248) / 2;
      v171 = NlsCompareRgWChar(v34 + 2 * v169, v246 + 12 * v170, 4);
      if ( !v171 )
      {
        v241 = v169;
        JUMPOUT(&loc_77E4546C);
      }
      if ( v171 >= 0 )
        v249 = v170 + 1;
      else
        v248 = v170 - 1;
    }
    while ( v249 <= v248 );
    v82 = 0;
LABEL_238:
    v86 = v243;
LABEL_239:
    v246 = *(_DWORD *)(v86 + 252);
    if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 10) > v82 )
    {
      v80 = *(_DWORD *)(v86 + 236);
      if ( v34 + 2 * (3 - (unsigned int)(v80 == 0)) <= v233 )
      {
        if ( !v247 )
          v247 = NlsCountOfWCharsWithinRange(
                   (unsigned __int16 *)v34,
                   v233,
                   3,
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
                   v80,
                   0);
        if ( v247 >= 3 )
        {
          v81 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 10) - 1;
          v244 = 0;
          v249 = 0;
          v248 = v81;
          if ( *(_DWORD *)(v86 + 236) && v34 + 6 < v233 )
          {
            v172 = *(_DWORD *)(v86 + 224);
            if ( v172 )
            {
              v173 = (*pSortTblPtrs)[11];
              v174 = *(_DWORD *)(v172 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
            }
            else
            {
              v173 = (*pSortTblPtrs)[11];
              v174 = *(_WORD *)v34;
            }
            v245 = *(_DWORD *)(v173 + 4 * v174);
            v175 = v172 ? *(_DWORD *)(v173
                                    + 4
                                    * (*(_DWORD *)(v172 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                     + (*(_WORD *)(v34 + 2) & 0xFF))) : *(_DWORD *)(v173 + 4 * *(_WORD *)(v34 + 2));
            if ( !((v245 ^ v175) & 0xE7FFFFFF) )
              v244 = 1;
          }
          v82 = 0;
          if ( v248 >= 0 )
          {
            v83 = v244;
            do
            {
              v84 = (v249 + v248) / 2;
              v85 = NlsCompareRgWChar(v34 + 2 * v83, v246 + 12 * v84, 3);
              if ( !v85 )
              {
                v241 = v83;
                JUMPOUT(&loc_77E4546C);
              }
              if ( v85 >= 0 )
                v249 = v84 + 1;
              else
                v248 = v84 - 1;
            }
            while ( v249 <= v248 );
            v86 = v243;
            v82 = 0;
          }
        }
      }
    }
    v244 = *(_DWORD *)(v86 + 248);
    if ( *(_WORD *)(*(_DWORD *)(v86 + 244) + 8) > v82 )
    {
      v125 = *(_DWORD *)(v86 + 236);
      if ( v34 + 2 * (2 - (unsigned int)(v125 == 0)) <= v233 )
      {
        v126 = v247;
        if ( !v247 )
          v126 = NlsCountOfWCharsWithinRange(
                   (unsigned __int16 *)v34,
                   v233,
                   2,
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v86 + 244) + 6),
                   v125,
                   0);
        if ( v126 >= 2 )
        {
          v127 = *(_WORD *)(*(_DWORD *)(v86 + 244) + 8) - 1;
          v247 = 0;
          v249 = 0;
          v248 = v127;
          if ( *(_DWORD *)(v86 + 236) && v34 + 4 < v233 )
          {
            v176 = *(_DWORD *)(v86 + 224);
            if ( v176 )
            {
              v177 = (*pSortTblPtrs)[11];
              v178 = *(_DWORD *)(v176 + 4 * ((unsigned int)*(_WORD *)v34 >> 8)) + (*(_WORD *)v34 & 0xFF);
            }
            else
            {
              v177 = (*pSortTblPtrs)[11];
              v178 = *(_WORD *)v34;
            }
            v179 = *(_DWORD *)(v177 + 4 * v178);
            v180 = *(_WORD *)(v34 + 2);
            if ( v176 )
              v180 = *(_DWORD *)(v176 + 4 * (v180 >> 8)) + (unsigned __int8)v180;
            if ( !((v179 ^ *(_DWORD *)(v177 + 4 * v180)) & 0xE7FFFFFF) )
              v247 = 1;
          }
          if ( v248 >= 0 )
          {
            v115 = (v249 + v248) / 2;
            v116 = NlsCompareRgWChar(v34 + 2 * v247, v244 + 8 * v115, 2);
            JUMPOUT(v116, 0, &loc_77E45453);
            JUMPOUT(v116 >= 0, &loc_77E4544A);
            v248 = v115 - 1;
            JUMPOUT(loc_77E4540E);
          }
        }
      }
    }
    goto LABEL_237;
  }
LABEL_31:
  if ( v39 != 13 || !v226 )
    goto LABEL_479;
  v11 = *(_WORD *)v34;
  v248 = 0;
  v247 = 0;
  v246 = 0;
  v12 = (int)pDigitRanges;
  v249 = 55;
  if ( v11 < 0xDC00u || v11 > 0xDFFFu || v34 <= v215 )
    goto LABEL_74;
  if ( *(_WORD *)(v34 - 2) != -10187 )
    goto LABEL_479;
  v12 = (int)pSurrogateDigitRanges;
  v249 = 9;
  do
  {
LABEL_74:
    v13 = (v249 + v246) >> 1;
    v14 = *(_WORD *)(v12 + 2 * v13);
    if ( v11 == v14 )
      break;
    if ( v11 >= v14 )
      v246 = v13 + 1;
    else
      v249 = v13 - 1;
  }
  while ( v246 <= v249 );
  v15 = v12 + 2 * (v13 & 0xFFFFFFFE);
  if ( *(_WORD *)v15 > v11 || *(_WORD *)(v15 + 2) < v11 )
    v16 = 0;
  else
    v16 = *(_WORD *)v15;
  v249 = v16;
  if ( !(_WORD)v16 )
  {
LABEL_479:
    v40 = v240;
    v41 = *(_WORD *)v240;
    v42 = v235;
    *(_BYTE *)v235 = *(_WORD *)v240 >> 8;
    *(_BYTE *)(v42 + 1) = v41;
    v43 = v42 + 2;
    v235 = v42 + 2;
    if ( (unsigned __int8)(v39 + 87) <= 6u || v227 && (unsigned __int8)(v39 + 64) <= 0x2Fu )
    {
      *(_BYTE *)v43 = *(_BYTE *)(v40 + 2);
      v43 = v42 + 3;
      v235 = v42 + 3;
    }
    else
    {
      if ( v225 && ((v181 = *(_BYTE *)(v40 + 1), v181 <= 0x14u) || v181 == 41) )
        v44 = 2;
      else
        v44 = *(_BYTE *)(v40 + 2);
      v45 = v236++;
      *(_BYTE *)v45 = v44;
    }
    if ( v224 && ((v182 = *(_BYTE *)(v40 + 1), v182 <= 0x14u) || v182 == 41) )
      v46 = 2;
    else
      v46 = *(_BYTE *)(v240 + 3) & 0x3F;
    v47 = v237++;
    v48 = v241 == 0;
    *(_BYTE *)v47 = v221 & v46;
    if ( !v48 )
    {
      v183 = v240;
      v184 = *(_WORD *)v240;
      *(_BYTE *)v43 = *(_WORD *)v240 >> 8;
      *(_BYTE *)(v43 + 1) = v184;
      v235 = v43 + 2;
      if ( v225 && ((v185 = *(_BYTE *)(v183 + 1), v185 <= 0x14u) || v185 == 41) )
        v186 = 2;
      else
        v186 = *(_BYTE *)(v183 + 2);
      v48 = v224 == 0;
      *(_BYTE *)v236 = v186;
      if ( !v48 )
      {
        v187 = *(_BYTE *)(v183 + 1);
        if ( v187 <= 0x14u || v187 == 41 )
          goto LABEL_412;
      }
      v102 = *(_BYTE *)(v183 + 3);
      goto LABEL_182;
    }
    goto LABEL_40;
  }
  if ( (unsigned __int16)(v16 + 9216) <= 0x3FFu )
    v248 = 55349;
  while ( *(_WORD *)v34 == (_WORD)v16 )
  {
    ++v247;
    v34 += 2;
    if ( (_WORD)v248 )
    {
      if ( v34 >= v233 || *(_WORD *)v34 != (_WORD)v248 )
      {
        v34 += 2;
        break;
      }
      v34 += 2;
    }
    if ( v34 >= v233 || v247 >= 19 )
      break;
  }
  v17 = 0;
  if ( v34 < v233 )
  {
    v18 = v247;
    v19 = v34;
    if ( v247 < 19 )
    {
      while ( *(_WORD *)v19 >= (unsigned __int16)v16 && *(_WORD *)v19 - 9 <= (unsigned __int16)v249 )
      {
        ++v17;
        ++v18;
        v19 += 2;
        if ( (_WORD)v248 )
        {
          if ( v19 >= v233 || *(_WORD *)v19 != (_WORD)v248 )
            break;
          v19 += 2;
        }
        if ( v19 >= v233 || v18 >= 19 )
          break;
        LOWORD(v16) = v249;
      }
    }
  }
  v8 = v235;
  v9 = v236;
  *(_BYTE *)v235 = 13;
  ++v8;
  *(_BYTE *)v8++ = 2;
  *(_BYTE *)v8 = v17 + 2;
  v10 = v240;
  *(_BYTE *)v9 = *(_BYTE *)(v240 + 2);
  sub_77E1463A(v8, v17, v221 & *(_BYTE *)(v10 + 3), v27, v34);
}
// 77E1BB40: using guessed type int pDigitRanges[29];
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];
// 77E4547C: using guessed type int pXWDrop;
// 77E45554: using guessed type int pXWSeparator;
// 77E62690: using guessed type int pSurrogateDigitRanges[5];

//----- (77E27F09) --------------------------------------------------------
signed int __stdcall CheckEnumFlags(int a1, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)a1;
  if ( ~((a2 != 0 ? 4 : 0) | 0x1B) & *(_DWORD *)a1 )
    return 0;
  if ( !(v2 & 0x17) )
    *(_DWORD *)a1 = v2 | 3;
  if ( v2 & 2 && v2 & 4 )
    return 0;
  if ( !(v2 & 0x10) )
    return 1;
  if ( !(v2 & 7) )
  {
    *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFEF | 1;
    return 1;
  }
  return 0;
}

//----- (77E27F51) --------------------------------------------------------
int __stdcall GetRcConfig(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a2 )
  {
    result = LdrResGetRCConfig(a1, 0, a3, 0, 1);
    if ( result == -1073020925 )
      result = -1073741701;
  }
  else
  {
    result = LdrResGetRCConfig(a1, 0, a3, 0x2000, 1);
  }
  return result;
}
// 77DE1338: using guessed type int __stdcall LdrResGetRCConfig(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E27F7E) --------------------------------------------------------
int __stdcall EnumResourceNamesInternal(int a1, PWCHAR UnicodeString, int a3, int a4, char a5, unsigned __int32 pResult, int a7)
{
  DWORD v7; // edx@58
  DWORD v8; // ecx@61
  int v9; // edi@1
  int v10; // esi@1
  PVOID v11; // eax@3
  __int16 v12; // bx@6
  int v13; // eax@10
  int v14; // eax@19
  unsigned __int32 v15; // edi@26
  unsigned __int32 v16; // esi@27
  int v17; // esi@40
  void *v18; // edi@42
  int v19; // eax@51
  NTSTATUS v21; // eax@110
  unsigned __int16 v22; // ax@130
  unsigned __int16 v23; // ax@135
  int v24; // esi@143
  unsigned __int32 v25; // edi@143
  int v26; // esi@146
  unsigned __int32 v27; // edi@147
  unsigned int v28; // eax@151
  PVOID v29; // edi@163
  int v30; // esi@166
  unsigned __int32 v31; // edi@166
  unsigned __int32 v32; // edi@170
  unsigned int v33; // eax@174
  int v34; // eax@181
  unsigned __int16 v35; // ax@190
  unsigned __int16 v36; // ax@195
  NTSTATUS v37; // [sp-18h] [bp-C0h]@0
  ULONG v38; // [sp+14h] [bp-94h]@1
  ULONG Flags; // [sp+18h] [bp-90h]@84
  ULONG v40; // [sp+1Ch] [bp-8Ch]@160
  ULONG ResultSize; // [sp+20h] [bp-88h]@1
  unsigned __int32 v42; // [sp+24h] [bp-84h]@17
  unsigned __int32 v43; // [sp+28h] [bp-80h]@13
  DWORD v44; // [sp+2Ch] [bp-7Ch]@67
  ULONG Size; // [sp+30h] [bp-78h]@1
  ULONG v46; // [sp+34h] [bp-74h]@1
  int v47; // [sp+38h] [bp-70h]@1
  int v48; // [sp+3Ch] [bp-6Ch]@1
  PVOID v49; // [sp+40h] [bp-68h]@1
  int v50; // [sp+44h] [bp-64h]@2
  PWCHAR v51; // [sp+48h] [bp-60h]@1
  unsigned __int32 v52; // [sp+4Ch] [bp-5Ch]@29
  unsigned __int32 v53; // [sp+50h] [bp-58h]@89
  int v54; // [sp+54h] [bp-54h]@17
  int v55; // [sp+58h] [bp-50h]@13
  int v56; // [sp+5Ch] [bp-4Ch]@1
  PVOID Address; // [sp+60h] [bp-48h]@1
  unsigned __int32 v58; // [sp+64h] [bp-44h]@1
  unsigned __int32 v59; // [sp+68h] [bp-40h]@1
  unsigned int v60; // [sp+6Ch] [bp-3Ch]@30
  PVOID ImageBase; // [sp+70h] [bp-38h]@10
  PVOID v62; // [sp+74h] [bp-34h]@3
  PVOID v63; // [sp+78h] [bp-30h]@1
  int v64; // [sp+7Ch] [bp-2Ch]@46
  ULONG v65; // [sp+80h] [bp-28h]@13
  int v66; // [sp+84h] [bp-24h]@1
  void *Dst; // [sp+88h] [bp-20h]@1
  int v68; // [sp+8Ch] [bp-1Ch]@26
  CPPEH_RECORD ms_exc; // [sp+90h] [bp-18h]@26
  int savedregs; // [sp+A8h] [bp+0h]@68

  v9 = 0;
  v59 = 0;
  v58 = 0;
  v63 = 0;
  Dst = 0;
  v51 = 0;
  v46 = 0;
  Size = 0;
  Address = 0;
  ResultSize = 0;
  v49 = 0;
  v38 = 0;
  v56 = 0;
  v66 = ((unsigned int)a5 >> 3) & 1;
  v48 = 0;
  v47 = 0;
  v10 = ~(unsigned __int8)((unsigned int)a5 >> 4) & 1;
  if ( !CheckEnumFlags((int)&a5, 0) || (v50 = BaseDllMapResourceIdW(UnicodeString), v50 == -1) )
    JUMPOUT(&loc_77E49566);
  v11 = BasepMapModuleHandle((void *)a1, 1);
  v62 = v11;
  if ( v10 && GetRcConfig((int)v11, v66, (int)&v48) >= 0 )
    JUMPOUT(LdrRscIsTypeExist(v48, v50, 0, &v47), 0, &loc_77E49565);
  v12 = a5;
  *(_DWORD *)&a5 = a5 & 2;
  if ( a5 )
  {
    if ( v48
      && *(_BYTE *)(v48 + 16) & 1
      && ((JUMPOUT(v47 & 0x20000, 0, &loc_77E49553), (_WORD)pResult) ? (v13 = LdrLoadAlternateResourceModuleEx(
                                                                                v62,
                                                                                pResult,
                                                                                &ImageBase,
                                                                                0,
                                                                                128)) : (v13 = LdrLoadAlternateResourceModule(
                                                                                                 v62,
                                                                                                 &ImageBase)),
          v13 >= 0) )
    {
      if ( v66 && LdrpResGetMappingSize(ImageBase, &v55, 256, 1) < 0 )
        v55 = 0;
      v9 = GetResourceDirectory(ImageBase, v55, v12, &v65, (int)&v43);
      if ( v9 >= 0 )
        v9 = EnumFindResource((int)ImageBase, v50, 0, 0, v12 | 0x200, (int)&v58);
    }
    else
    {
      v9 = -1073020927;
    }
  }
  if ( v12 & 1 )
  {
    JUMPOUT(v47 & 0x40000, 0, &loc_77E49572);
    if ( v66 && LdrpResGetMappingSize(v62, &v54, 256, 1) < 0 )
      v54 = 0;
    v56 = GetResourceDirectory(v62, v54, v12, &v65, (int)&v42);
    if ( v56 >= 0 )
      v56 = EnumFindResource((int)v62, v50, 0, 0, v12 | 0x200, (int)&v59);
  }
  v14 = 0;
  if ( v12 & 1 )
  {
    if ( a5 && v9 < 0 )
      JUMPOUT(v56, 0, &loc_77E4955D);
    if ( v12 & 1 && ~(_BYTE)v12 & 2 )
      JUMPOUT(v56, 0, &loc_77E4955D);
  }
  if ( ~(_BYTE)v12 & 1 && a5 && v9 < 0 )
    v14 = v9;
  JUMPOUT(v14, 0, &loc_77E49565);
  v68 = 1;
  ms_exc.registration.TryLevel = 1;
  v15 = v58;
  if ( v58 )
  {
    if ( v66
      && (ULongAdd(v58, 0x10u, &pResult) < 0
       || v15 + 16 < ((unsigned int)ImageBase & 0xFFFFFFFC)
       || v15 + 16 > ((unsigned int)ImageBase & 0xFFFFFFFC) + v55) )
      goto LABEL_124;
    v53 = v15 + 16;
  }
  v16 = v59;
  if ( v59 )
  {
    if ( v66
      && (ULongAdd(v59, 0x10u, &pResult) < 0
       || v16 + 16 < ((unsigned int)v62 & 0xFFFFFFFC)
       || v16 + 16 > ((unsigned int)v62 & 0xFFFFFFFC) + v54) )
    {
LABEL_124:
      BaseSetLastNTError(-1073741701);
LABEL_87:
      v68 = 0;
      goto LABEL_76;
    }
    v52 = v16 + 16;
  }
  v65 = 0;
  v60 = 0;
  if ( v66 )
  {
    if ( v15 )
    {
      v22 = *(_WORD *)(v15 + 12);
      if ( v22 )
      {
        if ( SIZETMult(v22, 8u, &pResult) < 0
          || v15 + pResult < ((unsigned int)ImageBase & 0xFFFFFFFC)
          || v15 + pResult > ((unsigned int)ImageBase & 0xFFFFFFFC) + v55 )
          goto LABEL_124;
      }
    }
    if ( v16 )
    {
      v23 = *(_WORD *)(v16 + 12);
      if ( v23 )
      {
        if ( SIZETMult(v23, 8u, &pResult) < 0
          || v16 + pResult < ((unsigned int)v62 & 0xFFFFFFFC)
          || v16 + pResult > ((unsigned int)v62 & 0xFFFFFFFC) + v54 )
          goto LABEL_124;
      }
    }
  }
  v56 = a7 & 1;
  if ( !(a7 & 1) )
    goto LABEL_32;
  if ( (unsigned int)UnicodeString & 0xFFFF0000 )
  {
    v21 = ConverStringWithHeapAlloc(UnicodeString, (int)&Address, (ULONG)&ResultSize);
    if ( v21 >= 0 )
      goto LABEL_53;
LABEL_140:
    BaseSetLastNTError(v21);
    goto LABEL_87;
  }
  Address = UnicodeString;
  while ( 1 )
  {
LABEL_32:
    if ( (!v15 || v65 >= *(_WORD *)(v15 + 12)) && (!v16 || v60 >= *(_WORD *)(v16 + 12)) )
    {
LABEL_72:
      if ( !v68 )
        goto LABEL_76;
      v65 = 0;
      v60 = 0;
      if ( v66 )
      {
        if ( v15 )
        {
          v35 = *(_WORD *)(v15 + 14);
          if ( v35 )
          {
            if ( SIZETMult(v35, 8u, &pResult) < 0
              || v15 + 16 < ((unsigned int)ImageBase & 0xFFFFFFFC)
              || v15 + 16 > ((unsigned int)ImageBase & 0xFFFFFFFC) + v55 )
              goto LABEL_124;
          }
        }
        if ( v16 )
        {
          v36 = *(_WORD *)(v16 + 14);
          if ( v36 )
          {
            if ( SIZETMult(v36, 8u, &pResult) < 0
              || v16 + 16 < ((unsigned int)v62 & 0xFFFFFFFC)
              || v16 + 16 > ((unsigned int)v62 & 0xFFFFFFFC) + v54 )
              goto LABEL_124;
          }
        }
      }
      while ( 1 )
      {
        if ( (!v15 || v65 >= *(_WORD *)(v15 + 14)) && (!v16 || v60 >= *(_WORD *)(v16 + 14)) )
          goto LABEL_76;
        v7 = v15 && v65 < *(_WORD *)(v15 + 14) ? *(_WORD *)v53 : -1;
        v8 = v16 && v60 < *(_WORD *)(v16 + 14) ? *(_WORD *)v52 : -1;
        if ( v7 == -1 )
          break;
        if ( v8 == -1 )
        {
          if ( v7 == -1 )
            break;
          v64 = 1;
        }
        else
        {
          v64 = 1;
          if ( (signed int)(v7 - v8) > 0 )
            goto LABEL_64;
          if ( v7 == v8 )
            v64 = 3;
        }
LABEL_65:
        if ( v64 & 1 )
        {
          v44 = v7;
          v53 += 8;
          ++v65;
        }
        if ( v64 & 2 )
        {
          v44 = v8;
          v52 += 8;
          ++v60;
        }
        savedregs = a4;
        ms_exc.registration.TryLevel = v44;
        if ( v56 )
          ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)Address;
        else
          ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)UnicodeString;
        if ( !_ResourceCallEnumNameRoutine(
                (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a3,
                a1,
                (int)ms_exc.registration.ScopeTable,
                ms_exc.registration.TryLevel,
                savedregs) )
        {
          BaseSetLastNTError(-1073020921);
          v68 = 0;
          goto LABEL_76;
        }
        v16 = v59;
        v15 = v58;
      }
      if ( v8 == -1 )
        goto LABEL_76;
LABEL_64:
      v64 = 2;
      goto LABEL_65;
    }
    if ( v15 && v65 < *(_WORD *)(v15 + 12) )
      break;
    if ( v63 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v63);
      v63 = 0;
      goto LABEL_165;
    }
LABEL_37:
    if ( v16 && v60 < *(_WORD *)(v16 + 12) )
    {
      if ( v66 )
      {
        v30 = *(_DWORD *)v52 & 0x7FFFFFFF;
        v31 = v42;
        if ( ULongAdd(v42, v30, &pResult) < 0
          || v30 + v31 < ((unsigned int)v62 & 0xFFFFFFFC)
          || v30 + v31 > ((unsigned int)v62 & 0xFFFFFFFC) + v54 )
          goto LABEL_124;
      }
      v17 = v42 + (*(_DWORD *)v52 & 0x7FFFFFFF);
      a7 = v42 + (*(_DWORD *)v52 & 0x7FFFFFFF);
      if ( v66 )
      {
        v32 = *(_WORD *)v17;
        if ( ULongAdd(v32, 1u, &pResult) < 0 )
          goto LABEL_153;
        if ( SIZETMult(pResult, 2u, &pResult) < 0 )
          goto LABEL_153;
        if ( v32 + v65 < (v65 & 0xFFFFFFFC) )
          goto LABEL_153;
        if ( v32 + v65 > (v65 & 0xFFFFFFFC) + 260 )
          goto LABEL_153;
        v33 = v17 + pResult + 2;
        if ( v33 < ((unsigned int)v62 & 0xFFFFFFFC) || v33 > ((unsigned int)v62 & 0xFFFFFFFC) + v54 )
          goto LABEL_153;
      }
      if ( 2 * (unsigned int)*(_WORD *)v17 + 2 >= Size )
      {
        if ( Dst )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
          Dst = 0;
          v17 = a7;
        }
        if ( v66 && ULongAdd(pResult, 0x40u, &pResult) < 0 )
          goto LABEL_153;
        Size = (2 * *(_WORD *)v17 + 64) & 0xFFFFFFC0;
        Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        Dst = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, Size);
        if ( !Dst )
          goto LABEL_154;
        v17 = a7;
      }
      v18 = Dst;
      memcpy(Dst, (const void *)(v17 + 2), 2 * *(_WORD *)v17);
      *((_WORD *)v18 + *(_WORD *)v17) = 0;
      goto LABEL_43;
    }
    if ( Dst )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
      Dst = 0;
LABEL_43:
      v15 = v58;
      v16 = v59;
    }
    if ( !v63 )
      goto LABEL_45;
    if ( Dst )
    {
      v64 = 1;
      v34 = wcscmp((const unsigned __int16 *)v63, (const unsigned __int16 *)Dst);
      if ( v34 > 0 )
        goto LABEL_46;
      if ( !v34 )
        v64 = 3;
    }
    else
    {
      if ( !v63 )
      {
LABEL_45:
        if ( !Dst )
          goto LABEL_72;
LABEL_46:
        v64 = 2;
        goto LABEL_47;
      }
      v64 = 1;
    }
LABEL_47:
    if ( v64 & 1 )
    {
      v51 = (PWCHAR)v63;
      v53 += 8;
      ++v65;
    }
    if ( v64 & 2 )
    {
      v51 = (PWCHAR)Dst;
      v52 += 8;
      ++v60;
    }
    if ( v56 )
    {
      v21 = ConverStringWithHeapAlloc(v51, (int)&v49, (ULONG)&v38);
      if ( v21 < 0 )
        goto LABEL_140;
      v19 = _ResourceCallEnumNameRoutine(
              (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a3,
              a1,
              (int)Address,
              (int)v49,
              a4);
    }
    else
    {
      v19 = _ResourceCallEnumNameRoutine(
              (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a3,
              a1,
              (int)UnicodeString,
              (int)v51,
              a4);
    }
    if ( !v19 )
    {
      BaseSetLastNTError(-1073020921);
      goto LABEL_87;
    }
LABEL_53:
    v15 = v58;
    v16 = v59;
  }
  if ( v66 )
  {
    v24 = *(_DWORD *)v53 & 0x7FFFFFFF;
    v25 = v43;
    if ( ULongAdd(v43, v24, &pResult) < 0
      || v24 + v25 < ((unsigned int)ImageBase & 0xFFFFFFFC)
      || v24 + v25 > ((unsigned int)ImageBase & 0xFFFFFFFC) + v55 )
      goto LABEL_124;
  }
  v26 = v43 + (*(_DWORD *)v53 & 0x7FFFFFFF);
  a7 = v43 + (*(_DWORD *)v53 & 0x7FFFFFFF);
  if ( v66 )
  {
    v27 = *(_WORD *)v26;
    if ( ULongAdd(v27, 1u, &pResult) < 0 )
      goto LABEL_153;
    if ( SIZETMult(pResult, 2u, &pResult) < 0 )
      goto LABEL_153;
    if ( v27 + v65 < (v65 & 0xFFFFFFFC) )
      goto LABEL_153;
    if ( v27 + v65 > (v65 & 0xFFFFFFFC) + 260 )
      goto LABEL_153;
    v28 = v26 + pResult + 2;
    if ( v28 < ((unsigned int)ImageBase & 0xFFFFFFFC) || v28 > ((unsigned int)ImageBase & 0xFFFFFFFC) + v55 )
      goto LABEL_153;
  }
  if ( 2 * (unsigned int)*(_WORD *)v26 + 2 < v46 )
  {
LABEL_163:
    v29 = v63;
    memcpy(v63, (const void *)(v26 + 2), 2 * *(_WORD *)v26);
    *((_WORD *)v29 + *(_WORD *)v26) = 0;
LABEL_165:
    v15 = v58;
    v16 = v59;
    goto LABEL_37;
  }
  if ( v63 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v63);
    v63 = 0;
    v26 = a7;
  }
  if ( !v66 || ULongAdd(pResult, 0x40u, &pResult) >= 0 )
  {
    v46 = (2 * *(_WORD *)v26 + 64) & 0xFFFFFFC0;
    v40 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v63 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v40, v46);
    if ( !v63 )
      goto LABEL_154;
    v26 = a7;
    goto LABEL_163;
  }
LABEL_153:
  v37 = -1073741701;
LABEL_154:
  BaseSetLastNTError(v37);
  v68 = 0;
LABEL_76:
  ms_exc.registration.TryLevel = 0;
  BaseDllFreeResourceId(v50);
  if ( v63 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v63);
    v63 = 0;
  }
  if ( Dst )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
    Dst = 0;
  }
  if ( (unsigned int)Address & 0xFFFF0000 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    Address = 0;
  }
  if ( v49 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v49);
    Address = 0;
  }
  ms_exc.registration.TryLevel = -2;
  return v68;
}
// 77DE12DC: using guessed type int __stdcall LdrLoadAlternateResourceModuleEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E0: using guessed type int __stdcall LdrLoadAlternateResourceModule(_DWORD, _DWORD);
// 77DE12E4: using guessed type int __stdcall LdrpResGetMappingSize(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E8: using guessed type int __stdcall LdrRscIsTypeExist(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E26A4E: using guessed type int __stdcall BaseDllMapResourceIdW(_DWORD);
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);

//----- (77E282ED) --------------------------------------------------------
BOOL __stdcall EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  return EnumResourceNamesInternal((int)hModule, (PWCHAR)lpType, (int)lpEnumFunc, lParam, dwFlags, LangId, 0);
}

//----- (77E2833D) --------------------------------------------------------
int __stdcall GetResourceDirectory(PVOID ImageBase, int a2, char a3, PULONG Size, int a5)
{
  PVOID v5; // ebx@1
  int v6; // edi@2
  PVOID v7; // eax@4
  int result; // eax@4

  v5 = ImageBase;
  if ( !ImageBase )
    goto LABEL_12;
  v6 = a5;
  if ( !a5 )
    goto LABEL_12;
  if ( !(a3 & 8) )
  {
    v7 = RtlImageDirectoryEntryToData(ImageBase, 1u, 2u, Size);
    *(_DWORD *)v6 = v7;
    return v7 != 0 ? 0 : -1073741687;
  }
  if ( a2 )
  {
    result = LdrpResGetResourceDirectory(ImageBase, a2, 4096, a5, &ImageBase);
    if ( result == -1073741686 )
      result = LdrpResGetResourceDirectory(v5, a2, 0, v6, &ImageBase);
  }
  else
  {
LABEL_12:
    result = -1073741811;
  }
  return result;
}
// 77DE1330: using guessed type int __stdcall LdrpResGetResourceDirectory(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2838E) --------------------------------------------------------
int __stdcall EnumFindResource(int a1, int a2, int a3, unsigned __int16 a4, __int16 a5, int a6)
{
  signed int v6; // eax@1
  int result; // eax@8
  int v8; // [sp+4h] [bp-Ch]@6
  int v9; // [sp+8h] [bp-8h]@10
  int v10; // [sp+Ch] [bp-4h]@13

  v6 = 0;
  if ( a1 && a6 )
  {
    if ( a5 & 0x700 )
    {
      if ( a5 & 8 )
      {
        result = LdrResFindResourceDirectory(a1, a2, a3, a6, 0, 0, 16);
      }
      else
      {
        if ( !(a5 & 0x100) )
        {
          v8 = a2;
          if ( a5 & 0x200 )
          {
            v6 = 1;
          }
          else
          {
            v9 = a3;
            v6 = 2;
          }
        }
        result = LdrFindResourceEx_U(18, a1, &v8, v6, a6);
      }
    }
    else if ( a5 & 8 )
    {
      result = LdrResFindResource(a1, a2, a3, a4, a6, 0, 0, 0, 20);
    }
    else
    {
      v8 = a2;
      v9 = a3;
      v10 = a4;
      result = LdrFindResourceEx_U(20, a1, &v8, 3, a6);
    }
  }
  else
  {
    result = -1073741811;
  }
  return result;
}
// 77DE1324: using guessed type int __stdcall LdrResFindResourceDirectory(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1328: using guessed type int __stdcall LdrResFindResource(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E283FC: using guessed type int __stdcall LdrFindResourceEx_U(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2856A) --------------------------------------------------------
NTSTATUS __stdcall ConsoleOpenWaitEvent(int a1, int a2, PHANDLE EventHandle)
{
  NTSTATUS result; // eax@1
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-230h]@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-228h]@3
  wchar_t pszDest; // [sp+28h] [bp-210h]@1

  result = RtlStringCchPrintfW(&pszDest, 0x105u, L"\\RPC Control\\ConsoleEvent-0x%p-%ws", a1, a2);
  if ( result >= 0 )
  {
    RtlInitUnicodeString(&DestinationString, &pszDest);
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 128;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    result = NtCreateEvent(EventHandle, 0x100000u, &ObjectAttributes, 0, 0);
  }
  return result;
}

//----- (77E28645) --------------------------------------------------------
BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
{
  NTSTATUS v5; // eax@1
  BOOL result; // eax@2
  ULONG v7; // eax@4

  v5 = WriteConsoleInternal(
         (int)hConsoleOutput,
         (void *)lpBuffer,
         nNumberOfCharsToWrite,
         (int)lpNumberOfCharsWritten,
         1);
  if ( v5 < 0 )
  {
    v7 = RtlNtStatusToDosError(v5);
    RtlSetLastWin32Error(v7);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2867A) --------------------------------------------------------
int __stdcall CmdBatNotification(int a1)
{
  int result; // eax@1
  char v2; // [sp+0h] [bp-E4h]@2
  int v3; // [sp+28h] [bp-BCh]@1
  int v4; // [sp+2Ch] [bp-B8h]@2

  result = (int)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  v3 = result;
  if ( result != -1 )
  {
    v4 = a1;
    result = CsrClientCallServer(&v2, 0, 268501008, 8);
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2871F) --------------------------------------------------------
PRTL_USER_PROCESS_PARAMETERS __stdcall SetUpHandles(int a1)
{
  PRTL_USER_PROCESS_PARAMETERS result; // eax@3
  PRTL_USER_PROCESS_PARAMETERS v2; // eax@6
  PRTL_USER_PROCESS_PARAMETERS v3; // eax@7

  if ( *(_DWORD *)(a1 + 36) & 0x200 )
  {
    v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
    v2[1].Reserved2[4] = (unsigned int)v2[1].Reserved2[4] & 0xFFFFFDFF;
  }
  if ( *(_DWORD *)(a1 + 36) & 0x400 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
    v3[1].Reserved2[4] = (unsigned int)v3[1].Reserved2[4] & 0xFFFFFBFF;
  }
  result = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  result->Reserved2[0] = *(PVOID *)a1;
  if ( !(*(_DWORD *)(a1 + 36) & 0x100) )
  {
    SetStdHandle(0xFFFFFFF6, *(HANDLE *)(a1 + 8));
    SetStdHandle(0xFFFFFFF5, *(HANDLE *)(a1 + 12));
    result = (PRTL_USER_PROCESS_PARAMETERS)SetStdHandle(0xFFFFFFF4, *(HANDLE *)(a1 + 16));
  }
  return result;
}

//----- (77E2878F) --------------------------------------------------------
ATOM __stdcall FindAtomW(LPCWSTR lpString)
{
  return InternalFindAtom(1, 1, (PCSZ)lpString);
}

//----- (77E28852) --------------------------------------------------------
DWORD __stdcall GetThreadIdStub(HANDLE Thread)
{
  return GetThreadId(Thread);
}

//----- (77E28BE6) --------------------------------------------------------
DWORD __stdcall GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
{
  LPSTR v2; // esi@1
  signed int v3; // ebx@1
  DWORD v4; // edi@1
  STRING DestinationString; // [sp+Ch] [bp-10h]@1
  char SourceString[4]; // [sp+14h] [bp-8h]@1
  DWORD v8; // [sp+18h] [bp-4h]@1
  void *Dst; // [sp+28h] [bp+Ch]@1

  v2 = lpBuffer;
  v3 = 0;
  strcpy(SourceString, "A:\\");
  v8 = 0;
  Dst = 0;
  RtlInitAnsiString(&DestinationString, SourceString);
  v4 = GetLogicalDrives();
  do
  {
    *DestinationString.Buffer = v3 + 65;
    if ( (1 << v3) & v4 )
    {
      v8 += DestinationString.MaximumLength;
      if ( v8 >= (unsigned __int16)nBufferLength )
      {
        Dst = (void *)1;
      }
      else
      {
        memcpy(v2, DestinationString.Buffer, DestinationString.MaximumLength);
        v2 += DestinationString.MaximumLength;
        *v2 = 0;
      }
    }
    ++v3;
  }
  while ( v3 < 26 );
  if ( Dst )
    ++v8;
  return v8;
}

//----- (77E28C4B) --------------------------------------------------------
BOOL __stdcall SetEnvironmentVariableAStub(LPCSTR lpName, LPCSTR lpValue)
{
  return SetEnvironmentVariableA(lpName, lpValue);
}

//----- (77E28C63) --------------------------------------------------------
int __stdcall MoveFileWithProgressTransactedW(PWSTR dosname, PWSTR DeviceName, int a3, int a4, int a5, int a6)
{
  signed int v6; // eax@5
  PVOID v7; // esi@11
  PVOID v9; // eax@45
  WCHAR *v10; // esi@45
  NTSTATUS v11; // esi@63
  char v12; // [sp+10h] [bp-A8h]@57
  char v13; // [sp+30h] [bp-88h]@58
  int v14; // [sp+38h] [bp-80h]@60
  int v15; // [sp+3Ch] [bp-7Ch]@60
  int v16; // [sp+40h] [bp-78h]@60
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+44h] [bp-74h]@5
  NTSTATUS v18; // [sp+5Ch] [bp-5Ch]@12
  ULONG v19; // [sp+60h] [bp-58h]@45
  ULONG Flags; // [sp+64h] [bp-54h]@11
  int FileInformation; // [sp+68h] [bp-50h]@6
  int v22; // [sp+6Ch] [bp-4Ch]@40
  PVOID Address; // [sp+70h] [bp-48h]@11
  int v24; // [sp+74h] [bp-44h]@60
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+78h] [bp-40h]@5
  LSA_UNICODE_STRING ntname; // [sp+80h] [bp-38h]@1
  HANDLE hObject; // [sp+88h] [bp-30h]@60
  HANDLE v28; // [sp+8Ch] [bp-2Ch]@4
  LSA_UNICODE_STRING DestinationString; // [sp+90h] [bp-28h]@1
  HANDLE FileHandle; // [sp+98h] [bp-20h]@1
  char v31; // [sp+9Eh] [bp-1Ah]@3
  unsigned __int8 v32; // [sp+9Fh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+A0h] [bp-18h]@1

  FileHandle = (HANDLE)-1;
  v32 = 0;
  DestinationString.Buffer = 0;
  ntname.Buffer = 0;
  ms_exc.registration.TryLevel = 0;
  if ( DeviceName && RtlIsDosDeviceName_U(DeviceName) )
  {
    BaseSetLastNTError(-1073741771);
    goto LABEL_14;
  }
  v31 = a5 & 1;
  if ( !RtlDosPathNameToNtPathName_U(dosname, &ntname, 0, 0) )
    goto LABEL_22;
  v28 = (HANDLE)(a5 & 4);
  if ( a5 & 4 && a5 & 0x10 )
  {
    BaseSetLastNTError(-1073741811);
    goto LABEL_14;
  }
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v6 = NtOpenFile(&FileHandle, 0x110080u, &ObjectAttributes, &IoStatusBlock, 7u, ((a5 & 8 | 0x10080u) >> 2) | 0x200000);
  if ( v6 < 0 )
  {
    if ( v28 && (v6 == -1073741757 || v6 == -1073741772 || v6 == -1073741766) )
    {
      FileHandle = (HANDLE)-1;
      goto LABEL_8;
    }
    if ( v6 != -1073741811 )
      goto LABEL_19;
  }
  else
  {
    v6 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 8u, FileAttributeTagInformation);
    if ( v6 < 0 )
    {
      if ( v6 != -1073741822 && v6 != -1073741811 )
        goto LABEL_20;
      if ( v6 < 0 )
        goto LABEL_8;
    }
    if ( !(FileInformation & 0x400) || v22 == -1610612733 || v22 == -1610612724 )
      goto LABEL_8;
    NtClose(FileHandle);
    FileHandle = (HANDLE)-1;
  }
  v6 = NtOpenFile(&FileHandle, 0x110000u, &ObjectAttributes, &IoStatusBlock, 3u, (a5 & 8 | 0x10080u) >> 2);
LABEL_19:
  if ( v6 < 0 )
  {
LABEL_20:
    BaseSetLastNTError(v6);
    goto LABEL_14;
  }
LABEL_8:
  if ( !v28 || DeviceName )
  {
    if ( RtlDosPathNameToNtPathName_U(DeviceName, &DestinationString, 0, 0) )
      goto LABEL_10;
LABEL_22:
    BaseSetLastNTError(-1073741766);
    goto LABEL_14;
  }
  RtlInitUnicodeString(&DestinationString, 0);
LABEL_10:
  if ( v28 )
  {
    if ( v31 && DestinationString.Length )
    {
      v19 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
      v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v19, DestinationString.Length + 2);
      v10 = (WCHAR *)v9;
      if ( !v9 )
        goto LABEL_46;
      *(_WORD *)v9 = 33;
      memcpy((char *)v9 + 2, DestinationString.Buffer, DestinationString.Length);
      DestinationString.Length += 2;
      DestinationString.MaximumLength += 2;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
      DestinationString.Buffer = v10;
    }
    if ( RtlDetermineDosPathNameType_U(dosname) == 1 || a5 & 2 )
    {
      v6 = -1073741811;
      goto LABEL_20;
    }
    v6 = BasepMoveFileDelayed((int)&ntname, (int)&DestinationString, 2, 0, a6);
    if ( v6 == -1073741772 )
    {
      v6 = BasepMoveFileDelayed((int)&ntname, (int)&DestinationString, 1, 1, a6);
      if ( v6 == -1073741670 )
        v6 = BasepMoveFileDelayed((int)&ntname, (int)&DestinationString, 2, 1, a6);
    }
    if ( v6 < 0 )
      goto LABEL_20;
LABEL_13:
    v32 = 1;
    goto LABEL_14;
  }
  Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, DestinationString.Length + 16);
  Address = v7;
  if ( !v7 )
  {
LABEL_46:
    BaseSetLastNTError(-1073741801);
    goto LABEL_14;
  }
  memcpy((char *)v7 + 12, DestinationString.Buffer, DestinationString.Length);
  *(_BYTE *)v7 = v31;
  *((_DWORD *)v7 + 1) = 0;
  *((_DWORD *)v7 + 2) = DestinationString.Length;
  v18 = NtSetInformationFile(
          FileHandle,
          &IoStatusBlock,
          v7,
          DestinationString.Length + 16,
          (FILE_INFORMATION_CLASS)((a5 & 0x10 | 0xA0u) >> 4));
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  v6 = v18;
  if ( v18 >= 0 )
    goto LABEL_13;
  if ( v18 != -1073741612 && v18 != -1072103368 || !(a5 & 2) )
    goto LABEL_20;
  if ( NtQueryInformationFile(FileHandle, &IoStatusBlock, &v12, 0x28u, FileBasicInformation) >= 0 && v13 & 0x10 )
  {
    BaseSetLastNTError(-1073741638);
    goto LABEL_14;
  }
  NtClose(FileHandle);
  FileHandle = (HANDLE)-1;
  v28 = (HANDLE)-1;
  hObject = (HANDLE)-1;
  v24 = RtlGetCurrentTransaction();
  v14 = a5;
  v15 = a3;
  v16 = a4;
  RtlSetCurrentTransaction(0);
  ms_exc.registration.TryLevel = 1;
  v32 = BasepCopyFileExW(
          dosname,
          DeviceName,
          (int)BasepMoveFileCopyProgress,
          (int)&v14,
          0,
          (v31 == 0) | 0x804i64,
          (int)&v28,
          (int)&hObject,
          v24);
  ms_exc.registration.TryLevel = 0;
  RtlSetCurrentTransaction(v24);
  if ( !v32 )
    goto LABEL_68;
  if ( v28 != (HANDLE)-1 )
  {
    if ( hObject != (HANDLE)-1 )
    {
      v11 = BasepNotifyTrackingService(&v28, (int)&ObjectAttributes, (int)hObject, (PSTRING)&DestinationString);
      if ( v11 < 0 )
      {
        if ( a5 & 0x20 )
        {
          if ( hObject != (HANDLE)-1 )
            CloseHandle(hObject);
          hObject = (HANDLE)-1;
          DeleteFileW(DeviceName);
          v32 = 0;
          BaseSetLastNTError(v11);
        }
      }
    }
LABEL_68:
    if ( v28 != (HANDLE)-1 )
    {
      CloseHandle(v28);
      v28 = (HANDLE)-1;
    }
  }
  if ( hObject != (HANDLE)-1 )
  {
    CloseHandle(hObject);
    hObject = (HANDLE)-1;
  }
  if ( v32 && !DeleteFileW(dosname) )
  {
    SetFileAttributesW(dosname, 0x80u);
    DeleteFileW(dosname);
  }
LABEL_14:
  ms_exc.registration.TryLevel = -2;
  if ( FileHandle != (HANDLE)-1 )
    NtClose(FileHandle);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
  return v32;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E28E9C) --------------------------------------------------------
BOOL __stdcall MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
{
  return MoveFileWithProgressTransactedW(
           (PWSTR)lpExistingFileName,
           (PWSTR)lpNewFileName,
           (int)lpProgressRoutine,
           (int)lpData,
           dwFlags,
           0);
}

//----- (77E28EE0) --------------------------------------------------------
DWORD __stdcall FormatMessageWStub(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
{
  return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
}

//----- (77E28F09) --------------------------------------------------------
int __stdcall BasepNotifyLoadStringResource(HINSTANCE hModule, unsigned int a2, unsigned __int16 *a3, int a4)
{
  unsigned __int32 v4; // eax@3
  signed int v6; // [sp-4h] [bp-4h]@2

  if ( !a4 )
  {
    v6 = 4;
LABEL_3:
    v4 = v6;
    return RealWerpNotifyLoadStringResource(hModule, a2, a3, v4);
  }
  if ( *(_DWORD *)a4 & 0x800 )
  {
    v6 = 2;
    goto LABEL_3;
  }
  if ( *(_DWORD *)a4 & 0x1000 )
  {
    v4 = 1;
    return RealWerpNotifyLoadStringResource(hModule, a2, a3, v4);
  }
  return -2147024809;
}

//----- (77E28F30) --------------------------------------------------------
int __stdcall RealWerpNotifyLoadStringResource(HINSTANCE hModule, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4)
{
  DWORD v4; // esi@1
  int v5; // edi@1

  v4 = GetLastError();
  v5 = RealWerpNotifyLoadStringResourceEx(hModule, a2, a3, a4, 0);
  SetLastError(v4);
  return v5;
}

//----- (77E28F66) --------------------------------------------------------
int __stdcall RealWerpNotifyLoadStringResourceEx(HINSTANCE hModule, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4, void **a5)
{
  DWORD v5; // esi@1
  signed int v6; // edi@1

  v5 = GetLastError();
  v6 = FSPErrorMessages::CMessageMapper::NotifyLoadStringResource(
         (FSPErrorMessages::CMessageMapper *)&FSPErrorMessages::CMessageMapper::ms_instance,
         hModule,
         a2,
         a3,
         a4,
         a5);
  SetLastError(v5);
  return v6;
}

//----- (77E28FA2) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::NotifyLoadStringResource(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, unsigned int a3, const unsigned __int16 *a4, unsigned __int32 a5, void **a6)
{
  HANDLE v6; // eax@4
  DWORD v7; // eax@4
  FSPErrorMessages::CMessageMapper *v8; // esi@1
  signed int result; // eax@2
  signed int v10; // edi@6
  signed int v11; // eax@7
  signed int v12; // ST18_4@8
  HANDLE v13; // eax@8
  DWORD v14; // ST08_4@8
  signed int v15; // eax@11
  signed int v16; // ST18_4@12
  unsigned __int16 *v17; // ST10_4@12
  HANDLE v18; // eax@12
  DWORD v19; // ST08_4@12
  WCHAR *v20; // [sp+10h] [bp-240h]@11
  unsigned int v21; // [sp+14h] [bp-23Ch]@11
  unsigned __int32 v22; // [sp+18h] [bp-238h]@11
  FSPErrorMessages::CMessageMapper *v23; // [sp+1Ch] [bp-234h]@1
  void **v24; // [sp+20h] [bp-230h]@1
  unsigned __int16 *v25; // [sp+24h] [bp-22Ch]@1
  int v26; // [sp+28h] [bp-228h]@6
  WCHAR Filename; // [sp+2Ch] [bp-224h]@6
  char Dst; // [sp+2Eh] [bp-222h]@6
  CPPEH_RECORD ms_exc; // [sp+238h] [bp-18h]@7

  v8 = this;
  v23 = this;
  v25 = (unsigned __int16 *)a4;
  v24 = a6;
  if ( *((_DWORD *)this + 9) == 1 )
  {
    result = -2146951860;
  }
  else
  {
    if ( a6 )
      *a6 = 0;
    Filename = 0;
    memset(&Dst, 0, 0x206u);
    v10 = FSPErrorMessages::CMessageMapper::GetModuleFileNameFromHandleNoLock(v8, hModule, &Filename, 0x104u);
    v26 = v10;
    if ( v10 < 0 )
    {
      FSPErrorMessages::CMessageMapper::LazyInitialize(v8);
      v6 = GetCurrentProcess();
      v7 = GetProcessId(v6);
      FSPErrorMessages::CMessageMapper::DumpTrace(
        v8,
        "LOAD: GETMODULEFILENAME failed PID=%ld | stringID=%ld | str=%S | flags=%d | hr = %X\n",
        v7,
        a3,
        a4,
        a5,
        v10);
      result = v10;
    }
    else
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)v8);
      ms_exc.registration.TryLevel = 0;
      v11 = FSPErrorMessages::CMessageMapper::LazyInitialize(v8);
      v26 = v11;
      if ( v11 >= 0 )
      {
        v20 = &Filename;
        v21 = a3;
        v22 = a5;
        v15 = FSPErrorMessages::CMessageTagCache::Insert(
                *((FSPErrorMessages::CMessageTagCache **)v8 + 10),
                (struct FSPErrorMessages::MessageTag *)&v20,
                v25,
                v24);
        v26 = v15;
        if ( v15 >= 0 )
        {
          v26 = 0;
        }
        else
        {
          v16 = v15;
          v17 = v25;
          v18 = GetCurrentProcess();
          v19 = GetProcessId(v18);
          FSPErrorMessages::CMessageMapper::DumpTrace(
            v8,
            "LOAD: INS failed PID=%ld | stringID=%ld | str=%S | flags=%d | hr = %X\n",
            v19,
            a3,
            v17,
            a5,
            v16);
        }
      }
      else
      {
        v12 = v11;
        v13 = GetCurrentProcess();
        v14 = GetProcessId(v13);
        FSPErrorMessages::CMessageMapper::DumpTrace(
          v8,
          "LOAD: INIT failed PID=%ld | stringID=%ld | str=%S | flags=%d | hr = %X\n",
          v14,
          a3,
          a4,
          a5,
          v12);
      }
      ms_exc.registration.TryLevel = -2;
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)v8);
      result = v26;
    }
  }
  return result;
}

//----- (77E29014) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::GetModuleFileNameFromHandleNoLock(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, LPWSTR lpFilename, unsigned __int32 nSize)
{
  DWORD v4; // eax@7
  signed int v5; // esi@4
  HANDLE v7; // eax@8
  NTSTATUS v8; // eax@8
  int v9; // [sp+8h] [bp-214h]@1
  int v10; // [sp+Ch] [bp-210h]@1
  char MemoryInformation; // [sp+10h] [bp-20Ch]@8
  unsigned __int16 *v12; // [sp+14h] [bp-208h]@9
  unsigned int v13; // [sp+20Ch] [bp-10h]@8
  MEMORY_INFORMATION_CLASS v14; // [sp+210h] [bp-Ch]@8
  char *v15; // [sp+214h] [bp-8h]@8
  ULONG v16; // [sp+218h] [bp-4h]@8
  ULONG *savedregs; // [sp+21Ch] [bp+0h]@8

  v10 = 0;
  LdrLockLoaderLock(this, 2, &v9, &v10);
  if ( v9 == 2 )
    JUMPOUT(*(_DWORD *)loc_77E12EFA);
  if ( (unsigned __int8)hModule & 1 )
  {
    savedregs = 0;
    v16 = 520;
    v15 = &MemoryInformation;
    v14 = 2;
    v13 = (unsigned int)hModule & 0xFFFFFFFC;
    v7 = GetCurrentProcess();
    v8 = NtQueryVirtualMemory(v7, (PVOID)v13, v14, v15, v16, savedregs);
    if ( !v8 )
    {
      v5 = StringCchCopyNW(lpFilename, nSize, v12, nSize - 1);
      if ( v5 < 0 )
        goto LABEL_5;
      goto LABEL_4;
    }
    v4 = v8 | 0x10000000;
LABEL_13:
    v5 = v4;
    goto LABEL_5;
  }
  if ( !GetModuleFileNameW(hModule, lpFilename, nSize) )
  {
    v4 = GetLastError();
    if ( (signed int)v4 > 0 )
      v4 = (unsigned __int16)v4 | 0x80070000;
    goto LABEL_13;
  }
LABEL_4:
  v5 = 0;
LABEL_5:
  LdrUnlockLoaderLock(0, v10);
  return v5;
}
// 77DE16F8: using guessed type int __stdcall LdrUnlockLoaderLock(_DWORD, _DWORD);
// 77DE16FC: using guessed type int __thiscall LdrLockLoaderLock(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2909D) --------------------------------------------------------
int __thiscall FSPErrorMessages::CConfig::OpenMachineKey(PHANDLE KeyHandle)
{
  PHANDLE v1; // esi@1
  int result; // eax@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-20h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+20h] [bp-8h]@2

  v1 = KeyHandle;
  if ( !*KeyHandle
    && (RtlInitUnicodeString(
          &DestinationString,
          L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\Windows Error Reporting\\WMR"),
        ObjectAttributes.ObjectName = &DestinationString,
        ObjectAttributes.Length = 24,
        ObjectAttributes.RootDirectory = 0,
        ObjectAttributes.Attributes = 64,
        ObjectAttributes.SecurityDescriptor = 0,
        ObjectAttributes.SecurityQualityOfService = 0,
        NtOpenKey(v1, 1u, &ObjectAttributes)) )
  {
    *v1 = 0;
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E2918F) --------------------------------------------------------
FSPErrorMessages::CConfig *__thiscall FSPErrorMessages::CConfig::CConfig(FSPErrorMessages::CConfig *this)
{
  FSPErrorMessages::CConfig *result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  return result;
}

//----- (77E2919E) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::LazyInitialize(FSPErrorMessages::CMessageMapper *this)
{
  FSPErrorMessages::CMessageMapper *v1; // esi@1
  signed int v2; // ebx@3
  SIZE_T v4; // eax@6
  HANDLE v5; // eax@6
  FSPErrorMessages::CMessageTagCache *v6; // eax@8
  DWORD v7; // eax@11
  HANDLE v8; // eax@16
  HANDLE v9; // eax@17
  DWORD v10; // eax@17
  char v11; // [sp+8h] [bp-41Ch]@1
  unsigned __int16 v12; // [sp+10h] [bp-414h]@17
  __int16 v13; // [sp+216h] [bp-20Eh]@17
  WCHAR Buffer; // [sp+218h] [bp-20Ch]@11

  v1 = this;
  FSPErrorMessages::CConfig::CConfig((FSPErrorMessages::CConfig *)&v11);
  if ( *((_DWORD *)v1 + 7) == 1 )
  {
    v2 = 0;
    goto LABEL_4;
  }
  *((_DWORD *)v1 + 9) = FSPErrorMessages::CConfig::IsDisabled((FSPErrorMessages::CConfig *)&v11);
  if ( *((_DWORD *)v1 + 9) == 1 )
  {
    v2 = -2146951860;
    goto LABEL_4;
  }
  v4 = FSPErrorMessages::CConfig::GetHeapSize((FSPErrorMessages::CConfig *)&v11);
  v2 = 0;
  v5 = HeapCreate(1u, 0, v4);
  *((_DWORD *)v1 + 6) = v5;
  if ( !v5 )
  {
LABEL_7:
    v2 = -2147024882;
    goto LABEL_4;
  }
  v6 = (FSPErrorMessages::CMessageTagCache *)RtlAllocateHeap(v5, 0, 0xC54u);
  *((_DWORD *)v1 + 10) = v6;
  if ( !v6 )
  {
    FSPErrorMessages::CMessageMapper::ResetAndDisable(v1);
    goto LABEL_7;
  }
  FSPErrorMessages::CMessageTagCache::Init(v6, *((void **)v1 + 6));
  if ( FSPErrorMessages::CConfig::IsTracingEnabled((FSPErrorMessages::CConfig *)&v11) )
  {
    v7 = GetEnvironmentVariableW(L"APPDATA", &Buffer, 0x104u);
    if ( !v7 || v7 >= 0x104 )
      v7 = GetTempPathW(0x104u, &Buffer);
    if ( v7 - 1 <= 0x102 && StringCchCatW(&Buffer, 0x104u, L"\\wmrtrace.dmp") >= 0 )
    {
      v8 = CreateFileW(&Buffer, 0x40000000u, 7u, 0, 4u, 0x80u, 0);
      *((_DWORD *)v1 + 11) = v8;
      if ( v8 )
      {
        SetFilePointer(v8, 0, 0, 2u);
        FSPErrorMessages::CConfig::GetAppName(&v12);
        v13 = 0;
        v9 = GetCurrentProcess();
        v10 = GetProcessId(v9);
        FSPErrorMessages::CMessageMapper::DumpTrace(v1, "INIT: PID %ld is %S\n", v10, &v12);
      }
    }
  }
  *((_DWORD *)v1 + 7) = 1;
LABEL_4:
  FSPErrorMessages::CConfig::~CConfig((FSPErrorMessages::CConfig *)&v11);
  return v2;
}

//----- (77E2920D) --------------------------------------------------------
NTSTATUS __thiscall FSPErrorMessages::CConfig::~CConfig(FSPErrorMessages::CConfig *this)
{
  FSPErrorMessages::CConfig *v1; // esi@1
  NTSTATUS result; // eax@1
  void *v3; // esi@3

  v1 = this;
  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
    result = NtClose(*(HANDLE *)this);
  v3 = (void *)*((_DWORD *)v1 + 1);
  if ( v3 )
    result = NtClose(v3);
  return result;
}

//----- (77E29235) --------------------------------------------------------
int __thiscall FSPErrorMessages::CConfig::IsDisabled(FSPErrorMessages::CConfig *this)
{
  FSPErrorMessages::CConfig *v1; // edi@1
  int result; // eax@3
  DWORDLONG v3; // rax@8
  int Dst; // [sp+Ch] [bp-120h]@1
  char v5; // [sp+126h] [bp-6h]@1

  v1 = this;
  memset(&Dst, 0, 0x11Cu);
  Dst = 284;
  v5 = 1;
  if ( (!FSPErrorMessages::CConfig::OpenMachineKey((PHANDLE)v1)
     || FSPErrorMessages::CConfig::GetDisabledValueFromKey(*(void **)v1) != 1)
    && (!FSPErrorMessages::CConfig::OpenPerUserKey(v1)
     || FSPErrorMessages::CConfig::GetDisabledValueFromKey(*((void **)v1 + 1)) != 1)
    && WinSqmIsOptedIn()
    && (v3 = VerSetConditionMask(0i64, 0x80u, 1u), VerifyVersionInfoW((LPOSVERSIONINFOEXW)&Dst, 0x80u, v3))
    && FSPErrorMessages::CConfig::IsRestrictedProcess() != 1
    && FSPErrorMessages::CConfig::IsInteractiveUser() )
    result = FSPErrorMessages::CConfig::IsSetupInProgress(v1, (unsigned __int32 *)0x80) == 1;
  else
    result = 1;
  return result;
}

//----- (77E292AC) --------------------------------------------------------
int __stdcall FSPErrorMessages::CConfig::GetDisabledValueFromKey(void *KeyHandle)
{
  int result; // eax@2
  unsigned __int32 *savedregs; // [sp+0h] [bp+0h]@0

  if ( FSPErrorMessages::ReadDwordFromRegistry(KeyHandle, L"Disable", (const unsigned __int16 *)&KeyHandle, savedregs) < 0 )
    result = 0;
  else
    result = KeyHandle != 0;
  return result;
}

//----- (77E292ED) --------------------------------------------------------
__int32 __stdcall FSPErrorMessages::ReadDwordFromRegistry(HANDLE KeyHandle, PCWSTR SourceString, const unsigned __int16 *a3, unsigned __int32 *a4)
{
  __int32 result; // eax@1
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-24h]@1
  ULONG ResultLength; // [sp+10h] [bp-1Ch]@1
  char KeyValueInformation; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@2
  int v9; // [sp+20h] [bp-Ch]@3

  *(_DWORD *)a3 = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  ResultLength = 0;
  result = NtQueryValueKey(
             KeyHandle,
             &DestinationString,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x13u,
             &ResultLength);
  if ( result >= 0 && v8 == 4 )
  {
    *(_DWORD *)a3 = v9;
    result = 0;
  }
  return result;
}

//----- (77E29445) --------------------------------------------------------
void FSPErrorMessages::CMessageMapper::DumpTrace(FSPErrorMessages::CMessageMapper *this, const char *Format, ...)
{
  signed int v2; // eax@3
  DWORD NumberOfBytesWritten; // [sp+4h] [bp-408h]@5
  char Buffer; // [sp+8h] [bp-404h]@3
  va_list va; // [sp+41Ch] [bp+10h]@1

  va_start(va, Format);
  if ( *((_DWORD *)this + 11) )
  {
    v2 = StringCchVPrintfA(&Buffer, 0x400u, Format, va);
    if ( (v2 >= 0 || v2 == -2147024774) && StringCbLengthA(&Buffer, 0x400u, (unsigned int *)&NumberOfBytesWritten) >= 0 )
    {
      if ( NumberOfBytesWritten )
        WriteFile(*((HANDLE *)this + 11), &Buffer, NumberOfBytesWritten + 1, &NumberOfBytesWritten, 0);
    }
  }
}

//----- (77E29489) --------------------------------------------------------
CHAR *__stdcall K32GetDeviceDriverBaseNameW(int ImageBase, LPWSTR lpWideCharStr, SIZE_T uBytes)
{
  CHAR *result; // eax@1
  const CHAR *v4; // ebx@1
  int v5; // eax@2
  CHAR *v6; // esi@2

  result = (CHAR *)LocalAlloc(0, uBytes);
  v4 = result;
  if ( result )
  {
    v5 = K32GetDeviceDriverBaseNameA((LPVOID)ImageBase, result, uBytes);
    v6 = (CHAR *)v5;
    if ( !v5 )
      goto LABEL_11;
    if ( v5 < uBytes )
      ++v5;
    if ( !MultiByteToWideChar(0, 0, v4, v5, lpWideCharStr, uBytes) )
LABEL_11:
      v6 = 0;
    LocalFree((HLOCAL)v4);
    result = v6;
  }
  return result;
}

//----- (77E294EB) --------------------------------------------------------
LPVOID __stdcall MapViewOfFileStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
{
  return MapViewOfFile(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
}

//----- (77E294FB) --------------------------------------------------------
signed int __stdcall StringCchCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4)
{
  signed int result; // eax@1

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( a4 > 0x7FFFFFFE )
    {
      result = -2147024809;
      *a1 = 0;
    }
    else
    {
      result = sub_77E2DB49((int)a3, a2, (int)a1, 0, a4);
    }
  }
  return result;
}

//----- (77E2958F) --------------------------------------------------------
UINT __stdcall GetSystemDirectoryAStub(LPSTR lpBuffer, UINT uSize)
{
  return GetSystemDirectoryA(lpBuffer, uSize);
}

//----- (77E2959C) --------------------------------------------------------
UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // eax@3
  unsigned __int16 v6; // [sp+4h] [bp-Ch]@3
  __int16 v7; // [sp+6h] [bp-Ah]@3
  LPSTR v8; // [sp+8h] [bp-8h]@3
  ULONG MbSize; // [sp+Ch] [bp-4h]@1

  v2 = KernelBaseGetGlobalData();
  v3 = v2 + 60;
  if ( RtlUnicodeToMultiByteSize(&MbSize, *(PWCHAR *)(v2 + 64), *(_WORD *)(v2 + 62)) >= 0 )
  {
    if ( (unsigned __int16)uSize < (unsigned __int16)MbSize )
      return MbSize;
    v7 = uSize;
    v8 = lpBuffer;
    v4 = KernelBaseGetGlobalData();
    if ( (*(int (__stdcall **)(unsigned __int16 *, int, _DWORD))(v4 + 28))(&v6, v3, 0) >= 0 )
      return v6;
  }
  return 0;
}

//----- (77E29607) --------------------------------------------------------
BOOL __stdcall SetCurrentDirectoryAStub(LPCSTR lpPathName)
{
  return SetCurrentDirectoryA(lpPathName);
}

//----- (77E2961F) --------------------------------------------------------
__int16 __stdcall InternalFindAtom(int a1, char a2, PCSZ SourceString)
{
  __int16 result; // ax@1
  LSA_UNICODE_STRING *v4; // esi@3
  int v5; // eax@3
  int v6; // eax@7
  STRING DestinationString; // [sp+10h] [bp-34h]@11
  LSA_UNICODE_STRING UnicodeString; // [sp+18h] [bp-2Ch]@3
  int v9; // [sp+24h] [bp-20h]@4
  LSA_UNICODE_STRING *v10; // [sp+28h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@2

  result = (signed __int16)SourceString;
  if ( (unsigned int)SourceString <= 0xFFFF )
  {
    SourceString = (PCSZ)(unsigned __int16)SourceString;
    if ( (unsigned __int16)SourceString < 0xC000u )
      return result;
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( a2 )
  {
    v4 = &UnicodeString;
    v10 = &UnicodeString;
    RtlInitUnicodeString(&UnicodeString, (PCWSTR)SourceString);
    v5 = 0;
  }
  else
  {
    RtlInitAnsiString(&DestinationString, SourceString);
    v4 = &UnicodeString;
    v10 = &UnicodeString;
    v5 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  }
  v9 = v5;
  ms_exc.registration.TryLevel = -2;
  if ( v5 < 0 )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  SourceString = 0;
  ms_exc.registration.TryLevel = 1;
  if ( (_BYTE)a1 )
  {
    v6 = InternalInitAtomTable((int)&a1);
    if ( v6 < 0 )
    {
LABEL_16:
      BaseSetLastNTError(v6);
      SourceString = 0;
      goto LABEL_9;
    }
    v6 = RtlLookupAtomInAtomTable(a1, v4->Buffer, &SourceString);
LABEL_8:
    if ( v6 >= 0 )
      goto LABEL_9;
    goto LABEL_16;
  }
  if ( v4->Length )
  {
    v6 = NtFindAtom(v4->Buffer, v4->Length, (PUSHORT)&SourceString);
    goto LABEL_8;
  }
  RtlSetLastWin32Error(123);
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( !a2 && v4 == &UnicodeString )
    RtlFreeUnicodeString(v4);
  return (signed __int16)SourceString;
}
// 77DE14D0: using guessed type int __stdcall RtlLookupAtomInAtomTable(_DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E296F5) --------------------------------------------------------
ATOM __stdcall GlobalFindAtomW(LPCWSTR lpString)
{
  return InternalFindAtom(0, 1, (PCSZ)lpString);
}

//----- (77E2970F) --------------------------------------------------------
int __stdcall GetThreadPriorityStub(HANDLE hThread)
{
  return GetThreadPriority(hThread);
}

//----- (77E29727) --------------------------------------------------------
unsigned int __stdcall IsThreadAFiber()
{
  return ((unsigned int)HIWORD(NtCurrentTeb()[1].ProcessEnvironmentBlock) >> 2) & 1;
}

//----- (77E29740) --------------------------------------------------------
int __stdcall StateObjectListRemove(int a1, int a2)
{
  int v2; // ecx@3
  int result; // eax@1

  result = StateObjectListFind(a1, a2);
  if ( result )
  {
    v2 = *(_DWORD *)result;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)result;
    if ( v2 )
      *(_DWORD *)(v2 + 4) = 0;
  }
  return result;
}

//----- (77E29764) --------------------------------------------------------
int __stdcall StateObjectListFind(int a1, int a2)
{
  int v2; // eax@9
  int v3; // ecx@9
  int i; // esi@1

  for ( i = *(_DWORD *)(a1 + 12); ; i = *(_DWORD *)i )
  {
    if ( !i )
      return 0;
    if ( a2 == *(_DWORD *)(i + 8) )
      break;
  }
  if ( i != *(_DWORD *)(a1 + 12) )
  {
    v2 = *(_DWORD *)(i + 4);
    v3 = *(_DWORD *)i;
    if ( v2 )
      *(_DWORD *)v2 = v3;
    if ( v3 )
      *(_DWORD *)(v3 + 4) = v2;
    StateObjectListAdd(a1, i);
  }
  return i;
}

//----- (77E297F8) --------------------------------------------------------
BOOL __stdcall StateObjectListIsEmpty(int a1)
{
  return *(_DWORD *)(a1 + 12) == 0;
}

//----- (77E29811) --------------------------------------------------------
int __stdcall LocalBaseRegSetValue(HANDLE a1, PUNICODE_STRING ValueName, ULONG Type, PVOID Data, ULONG DataSize)
{
  UNICODE_STRING *v5; // edi@1
  int (__stdcall *v6)(_DWORD, _DWORD, _DWORD, _DWORD); // eax@1
  USHORT v7; // cx@2
  NTSTATUS v9; // eax@22
  NTSTATUS v10; // esi@31
  int (__stdcall *v11)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@46
  signed int v12; // [sp-4h] [bp-24h]@25
  void (__stdcall *v13)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  HANDLE Handle; // [sp+14h] [bp-Ch]@1
  PVOID Address; // [sp+18h] [bp-8h]@1
  HANDLE KeyHandle; // [sp+1Ch] [bp-4h]@5
  NTSTATUS ValueNamea; // [sp+2Ch] [bp+Ch]@14

  Address = 0;
  v13 = *(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 8);
  v5 = ValueName;
  v6 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 32);
  v14 = 0;
  Handle = 0;
  if ( (!ValueName || (v7 = ValueName->Length, ValueName->Length & 1) || v7 && !ValueName->Buffer)
    && (ValueName->Buffer || (v7 = ValueName->Length, ValueName->Length != 2) || ValueName->MaximumLength) )
  {
    v12 = 87;
  }
  else
  {
    KeyHandle = a1;
    if ( v7 > 0u )
      ValueName->Length = v7 - 2;
    if ( a1 == (HANDLE)-2147483644 || a1 == (HANDLE)-2147483568 || a1 == (HANDLE)-2147483552 )
    {
      v11 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 40);
      if ( v11 )
        return v11(a1, ValueName->Buffer, 0, Type, Data, DataSize);
      v12 = 6;
    }
    else
    {
      if ( v13 && v6 )
      {
        if ( v6(a1, ValueName, Type, &Address) < 0 )
        {
          Address = 0;
        }
        else
        {
          Data = (char *)Address + 12;
          DataSize = *((_DWORD *)Address + 2);
        }
        v13(a1, ValueName, 0, Type, Data, DataSize);
      }
      if ( Address )
      {
        v10 = NtSetValueKey(a1, ValueName, 0, Type, Data, DataSize);
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        return RtlNtStatusToDosError(v10);
      }
      if ( (unsigned __int8)a1 & 2 )
      {
        v9 = BaseRegGetUserAndMachineClass(0, KeyHandle, 0x2000000, (int)&Handle, (int)&v14);
        if ( v9 < 0 )
          return RtlNtStatusToDosError(v9);
      }
      if ( v14 && Handle )
        KeyHandle = (HANDLE)v14;
      ValueNamea = NtSetValueKey(KeyHandle, ValueName, 0, Type, Data, DataSize);
      if ( v14 && Handle )
      {
        if ( (HANDLE)v14 == a1 )
          NtClose(Handle);
        else
          NtClose((HANDLE)v14);
      }
      if ( !(*(_BYTE *)(RegKrnGetGlobalState() + 36) & 1) )
        return RtlNtStatusToDosError(ValueNamea);
      if ( ValueNamea != -1073741790 )
        return RtlNtStatusToDosError(ValueNamea);
      if ( KeyHandle != Handle )
        return RtlNtStatusToDosError(ValueNamea);
      if ( !((unsigned __int8)a1 & 2) )
        return RtlNtStatusToDosError(ValueNamea);
      if ( CreateMultipartUserClassKey(a1, (int)&KeyHandle) >= 0 )
      {
        ValueNamea = NtSetValueKey(KeyHandle, v5, 0, Type, Data, DataSize);
        NtClose(KeyHandle);
        if ( ValueNamea >= 0 )
          return RtlNtStatusToDosError(ValueNamea);
      }
      v12 = 5;
    }
  }
  return v12;
}

//----- (77E2990C) --------------------------------------------------------
LSTATUS __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
{
  size_t v6; // esi@25
  const BYTE *v7; // eax@25
  DWORD v8; // edi@28
  PVOID v9; // eax@28
  PVOID v10; // ebx@28
  HKEY v11; // esi@5
  int v12; // eax@5
  DWORD v13; // ebx@6
  DWORD v14; // eax@6
  unsigned int v15; // kr00_4@11
  NTSTATUS v16; // eax@12
  ULONG v17; // eax@14
  int v18; // esi@17
  int v19; // edi@17
  int v20; // eax@17
  int (__stdcall *v22)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@35
  LSA_UNICODE_STRING ValueName; // [sp+10h] [bp-38h]@11
  int v25; // [sp+1Ch] [bp-2Ch]@1
  int v26; // [sp+20h] [bp-28h]@1
  int (__stdcall *v27)(unsigned int, LSA_UNICODE_STRING *, DWORD, const BYTE *, DWORD); // [sp+24h] [bp-24h]@1
  PVOID Address; // [sp+28h] [bp-20h]@1
  LSTATUS v29; // [sp+2Ch] [bp-1Ch]@5
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@34

  v25 = 0;
  v26 = 0;
  Address = 0;
  v27 = *(int (__stdcall **)(unsigned int, LSA_UNICODE_STRING *, DWORD, const BYTE *, DWORD))(RegKrnGetGlobalState()
                                                                                            + 132);
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  if ( hKey == HKEY_PERFORMANCE_TEXT || hKey == HKEY_PERFORMANCE_NLSTEXT )
  {
    v22 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 40);
    if ( v22 )
      return v22(hKey, lpValueName, Reserved, dwType, lpData, cbData);
    return 6;
  }
  if ( Reserved )
    return 87;
  v11 = hKey;
  v12 = RegKrnGetGlobalState();
  v29 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v12 + 176))(v11, &hKey, &v25, &v26);
  if ( !v29 )
  {
    v13 = cbData;
    v14 = cbData >> 1;
    if ( !(cbData & 1) && (dwType == 1 || dwType == 2 || dwType == 7) )
    {
      if ( lpData )
      {
        if ( v14 > 0 )
        {
          v6 = 2 * v14;
          v7 = &lpData[2 * v14];
          if ( *((_WORD *)v7 - 1) )
          {
            if ( !(((unsigned int)v7 ^ (unsigned int)(v7 - 2)) & 0xFFFFF000) && !*(_WORD *)v7 )
            {
              v8 = cbData + 2;
              v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, cbData + 2);
              v10 = v9;
              Address = v9;
              if ( !v9 )
              {
                v29 = 8;
                goto LABEL_16;
              }
              memcpy(v9, lpData, v6);
              *(_WORD *)((char *)v10 + v6) = 0;
              v13 = v8;
              lpData = (const BYTE *)Address;
            }
          }
        }
      }
    }
    if ( lpValueName && (v15 = wcslen(lpValueName), ValueName.Length = 2 * v15, 2 * v15 != (unsigned __int16)(2 * v15)) )
    {
      v29 = 87;
    }
    else
    {
      v16 = RtlInitUnicodeStringEx(&ValueName, lpValueName);
      if ( v16 < 0 )
      {
        v17 = RtlNtStatusToDosError(v16);
      }
      else
      {
        ValueName.Length += 2;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v27 )
          {
            ms_exc.registration.TryLevel = 0;
            v29 = v27((unsigned int)hKey & 0xFFFFFFFE, &ValueName, dwType, lpData, v13);
            ms_exc.registration.TryLevel = -2;
          }
          goto LABEL_16;
        }
        v17 = LocalBaseRegSetValue(hKey, &ValueName, dwType, (PVOID)lpData, v13);
      }
      v29 = v17;
    }
  }
LABEL_16:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  v18 = v26;
  v19 = v25;
  v20 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v20 + 168))(v19, v18);
  return v29;
}

//----- (77E29A59) --------------------------------------------------------
BOOL __stdcall GetDiskFreeSpaceExWStub(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
  return GetDiskFreeSpaceExW(
           lpDirectoryName,
           lpFreeBytesAvailableToCaller,
           lpTotalNumberOfBytes,
           lpTotalNumberOfFreeBytes);
}

//----- (77E29A71) --------------------------------------------------------
BOOL __stdcall QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = RtlQueueWorkItem(Function, Context, Flags);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1100: using guessed type int __stdcall RtlQueueWorkItem(_DWORD, _DWORD, _DWORD);

//----- (77E29A99) --------------------------------------------------------
BOOL __stdcall CreateDirectoryWStub(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  return CreateDirectoryW(lpPathName, lpSecurityAttributes);
}

//----- (77E29AB1) --------------------------------------------------------
BOOL __stdcall GetVersionExWStub(LPOSVERSIONINFOW lpVersionInformation)
{
  return GetVersionExW(lpVersionInformation);
}

//----- (77E29AC1) --------------------------------------------------------
BOOL __stdcall GetFileSizeExStub(HANDLE hFile, PLARGE_INTEGER lpFileSize)
{
  return GetFileSizeEx(hFile, lpFileSize);
}

//----- (77E29AD1) --------------------------------------------------------
BOOL __stdcall FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
{
  BOOL v5; // edi@1
  NTSTATUS v6; // eax@2
  int Dst; // [sp+4h] [bp-44h]@2
  int v9; // [sp+44h] [bp-4h]@1

  v5 = 0;
  v9 = 0;
  if ( BasepFindActCtxSection_CheckAndConvertParameters(dwFlags, (int)ReturnedData, (int)&v9) )
  {
    memset(&Dst, 0, 0x40u);
    Dst = 64;
    v6 = RtlFindActivationContextSectionGuid(v9, lpExtensionGuid, ulSectionId, lpGuidToFind, &Dst);
    if ( v6 >= 0 )
    {
      if ( BasepFindActCtxSection_FillOutReturnData(dwFlags, (int)ReturnedData, (int)&Dst) )
        v5 = 1;
    }
    else
    {
      BaseSetLastNTError(v6);
    }
  }
  return v5;
}
// 77DE1158: using guessed type int __stdcall RtlFindActivationContextSectionGuid(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E29B38) --------------------------------------------------------
int __stdcall GetFileInformationByHandleEx(HANDLE FileHandle, int a2, PVOID FileInformation, ULONG FileInformationLength)
{
  ULONG v4; // ecx@1
  signed int v5; // edx@1
  FILE_INFORMATION_CLASS v6; // eax@4
  NTSTATUS v7; // eax@8
  signed int v9; // [sp-4h] [bp-14h]@20
  signed int v10; // [sp-4h] [bp-14h]@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@1

  v4 = 8;
  v5 = 0;
  LOBYTE(IoStatusBlock.Information) = 0;
  if ( a2 <= 8 )
  {
    if ( a2 == 8 )
    {
      v6 = 28;
      v10 = 16;
      goto LABEL_5;
    }
    if ( !a2 )
    {
      v6 = 4;
      v10 = 40;
LABEL_5:
      v4 = v10;
      goto LABEL_6;
    }
    if ( a2 == 1 )
    {
      v6 = 5;
      v10 = 24;
      goto LABEL_5;
    }
    if ( a2 == 2 )
    {
      v9 = 9;
      goto LABEL_23;
    }
    if ( a2 == 7 )
    {
      v6 = 22;
      v10 = 32;
      goto LABEL_5;
    }
LABEL_32:
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( a2 == 9 )
  {
    v9 = 35;
LABEL_23:
    v6 = v9;
    goto LABEL_6;
  }
  if ( a2 == 10 )
  {
    v6 = 37;
    v4 = 112;
    v5 = 1;
    LOBYTE(IoStatusBlock.Information) = 0;
    goto LABEL_6;
  }
  if ( a2 != 11 )
  {
    if ( a2 == 13 )
    {
      v6 = 55;
      v10 = 116;
      goto LABEL_5;
    }
    goto LABEL_32;
  }
  v6 = 37;
  v5 = 1;
  v4 = 112;
  LOBYTE(IoStatusBlock.Information) = 1;
LABEL_6:
  if ( v4 > FileInformationLength )
  {
    RtlSetLastWin32Error(24);
    return 0;
  }
  if ( v5 )
  {
    v7 = NtQueryDirectoryFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           FileInformation,
           FileInformationLength,
           v6,
           0,
           0,
           LOBYTE(IoStatusBlock.Information));
    if ( v7 == 259 )
    {
      v7 = NtWaitForSingleObject(FileHandle, 0, 0);
      if ( v7 < 0 )
        goto LABEL_26;
      v7 = IoStatusBlock.u.Status;
    }
  }
  else
  {
    v7 = NtQueryInformationFile(FileHandle, &IoStatusBlock, FileInformation, FileInformationLength, v6);
  }
  if ( v7 < 0 )
  {
LABEL_26:
    BaseSetLastNTError(v7);
    return 0;
  }
  if ( a2 != 7 || IoStatusBlock.Information )
    return 1;
  BaseSetLastNTError(-1073741807);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E29BB0) --------------------------------------------------------
LONG __stdcall InterlockedExchangeAddStub(volatile LONG *Addend, LONG Value)
{
  return InterlockedExchangeAdd(Addend, Value);
}

//----- (77E29BC0) --------------------------------------------------------
BOOL __stdcall GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
{
  BOOL result; // eax@2
  struct _CONSOLE_SCREEN_BUFFER_INFOEX ConsoleScreenBufferInfoEx; // [sp+0h] [bp-60h]@1

  ConsoleScreenBufferInfoEx.cbSize = 96;
  if ( GetConsoleScreenBufferInfoEx(hConsoleOutput, &ConsoleScreenBufferInfoEx) )
  {
    lpConsoleScreenBufferInfo->dwSize = ConsoleScreenBufferInfoEx.dwSize;
    lpConsoleScreenBufferInfo->dwCursorPosition = ConsoleScreenBufferInfoEx.dwCursorPosition;
    lpConsoleScreenBufferInfo->wAttributes = ConsoleScreenBufferInfoEx.wAttributes;
    *(_DWORD *)&lpConsoleScreenBufferInfo->srWindow.Left = *(_DWORD *)&ConsoleScreenBufferInfoEx.srWindow.Left;
    *(_DWORD *)&lpConsoleScreenBufferInfo->srWindow.Right = *(_DWORD *)&ConsoleScreenBufferInfoEx.srWindow.Right;
    lpConsoleScreenBufferInfo->dwMaximumWindowSize = ConsoleScreenBufferInfoEx.dwMaximumWindowSize;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E29BEE) --------------------------------------------------------
BOOL __stdcall GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
{
  __int16 v2; // dx@6
  SHORT v3; // cx@6
  __int16 v4; // ax@6
  ULONG v5; // ST0C_4@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@2
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@2
  HANDLE v9; // [sp+2Ch] [bp-7Ch]@2
  COORD v10; // [sp+30h] [bp-78h]@6
  COORD v11; // [sp+34h] [bp-74h]@6
  __int16 v12; // [sp+38h] [bp-70h]@6
  int v13; // [sp+3Ah] [bp-6Eh]@6
  int v14; // [sp+3Eh] [bp-6Ah]@6
  COORD v15; // [sp+42h] [bp-66h]@6
  WORD v16; // [sp+46h] [bp-62h]@6
  int v17; // [sp+48h] [bp-60h]@6
  char v18; // [sp+4Ch] [bp-5Ch]@6

  if ( lpConsoleScreenBufferInfoEx->cbSize != 96 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v9 = hConsoleOutput;
  ConsoleClientCallServer(&RequestMessage, 0, 11, 96);
  if ( NtStatus < 0 )
  {
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
    return 0;
  }
  v2 = v14;
  v3 = v13;
  lpConsoleScreenBufferInfoEx->dwSize = v10;
  lpConsoleScreenBufferInfoEx->dwCursorPosition = v11;
  lpConsoleScreenBufferInfoEx->wAttributes = HIWORD(v13);
  v4 = v12;
  lpConsoleScreenBufferInfoEx->srWindow.Left = v12;
  lpConsoleScreenBufferInfoEx->srWindow.Right = v2 + v4 - 1;
  lpConsoleScreenBufferInfoEx->srWindow.Bottom = v3 + HIWORD(v14) - 1;
  lpConsoleScreenBufferInfoEx->dwMaximumWindowSize = v15;
  lpConsoleScreenBufferInfoEx->wPopupAttributes = v16;
  lpConsoleScreenBufferInfoEx->bFullscreenSupported = v17;
  lpConsoleScreenBufferInfoEx->srWindow.Top = v3;
  qmemcpy(lpConsoleScreenBufferInfoEx->ColorTable, &v18, sizeof(lpConsoleScreenBufferInfoEx->ColorTable));
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E29C5E) --------------------------------------------------------
BOOL __stdcall FindNextFileWStub(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
{
  return FindNextFileW(hFindFile, lpFindFileData);
}

//----- (77E29C76) --------------------------------------------------------
BOOL __stdcall ReadFileImplementation(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
{
  LPDWORD v5; // edi@1
  PVOID v6; // esi@3
  BOOL result; // eax@7

  v5 = lpNumberOfBytesRead;
  if ( lpNumberOfBytesRead )
    *lpNumberOfBytesRead = 0;
  v6 = hFile;
  if ( hFile == (HANDLE)-12 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hFile == (HANDLE)-11 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hFile == (HANDLE)-10 )
  {
    v6 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v6 & 0x10000003) == 3 )
  {
    if ( ReadConsoleA(v6, lpBuffer, nNumberOfBytesToRead, v5, 0) )
    {
      if ( !GetConsoleMode(v6, (LPDWORD)&lpNumberOfBytesRead) )
        lpNumberOfBytesRead = 0;
      if ( (unsigned __int8)lpNumberOfBytesRead & 1 )
      {
        if ( *(_BYTE *)lpBuffer == 26 )
          *v5 = 0;
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = ReadFile(v6, lpBuffer, nNumberOfBytesToRead, v5, lpOverlapped);
  }
  return result;
}

//----- (77E29D1E) --------------------------------------------------------
HANDLE __stdcall CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
{
  HANDLE result; // eax@2
  HANDLE v7; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v7 = CreateFileMappingNumaW(
         hFile,
         lpFileMappingAttributes,
         flProtect,
         dwMaximumSizeHigh,
         dwMaximumSizeLow,
         UnicodeString.Buffer,
         0xFFFFFFFF);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v7;
}

//----- (77E29D82) --------------------------------------------------------
HGLOBAL __stdcall LoadResourceStub(HMODULE hModule, HRSRC hResInfo)
{
  return LoadResource(hModule, hResInfo);
}

//----- (77E2A12A) --------------------------------------------------------
int __stdcall CompareStringWStub(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
{
  return CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

//----- (77E2A142) --------------------------------------------------------
int __stdcall lstrlenStub(LPCSTR lpString)
{
  return lstrlenA(lpString);
}

//----- (77E2A235) --------------------------------------------------------
HGLOBAL __stdcall GlobalAllocStub(UINT uFlags, SIZE_T dwBytes)
{
  return GlobalAlloc(uFlags, dwBytes);
}

//----- (77E2A24D) --------------------------------------------------------
HGLOBAL __stdcall GlobalFreeStub(HGLOBAL hMem)
{
  HGLOBAL result; // eax@2

  if ( !pfnWowGlobalFreeHook || (result = (HGLOBAL)pfnWowGlobalFreeHook(hMem)) != 0 )
    result = GlobalFree(hMem);
  return result;
}
// 77EA6BE8: using guessed type int (__cdecl *pfnWowGlobalFreeHook)(_DWORD);

//----- (77E2A293) --------------------------------------------------------
BOOL __stdcall GlobalUnlock(HGLOBAL hMem)
{
  char *v1; // esi@2
  __int16 v2; // ax@3
  BOOL v4; // [sp+14h] [bp-1Ch]@1

  v4 = 1;
  if ( (unsigned __int8)hMem & 4 )
  {
    RtlLockHeap(BaseHeap);
    v1 = (char *)hMem - 4;
    if ( !(unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, (char *)hMem - 4) )
    {
      RtlSetLastWin32Error(6);
      goto LABEL_7;
    }
    v2 = *((_WORD *)v1 + 1);
    *((_WORD *)v1 + 1) = v2 - 1;
    if ( v2 )
    {
      if ( *((_WORD *)v1 + 1) )
      {
LABEL_7:
        RtlUnlockHeap(BaseHeap);
        return v4;
      }
      RtlSetLastWin32Error(0);
    }
    else
    {
      ++*((_WORD *)v1 + 1);
      RtlSetLastWin32Error(158);
    }
    v4 = 0;
    goto LABEL_7;
  }
  return v4;
}
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E2A345) --------------------------------------------------------
LPVOID __stdcall GlobalLock(HGLOBAL hMem)
{
  PULONG v1; // eax@7
  HGLOBAL v2; // ebx@1
  int v3; // esi@2
  __int16 v4; // ax@4
  LPVOID result; // eax@5
  void *v6; // [sp+14h] [bp-1Ch]@3

  v2 = hMem;
  if ( (unsigned __int8)hMem & 4 )
  {
    RtlLockHeap(BaseHeap);
    v3 = (int)((char *)v2 - 4);
    if ( (unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, (char *)v2 - 4) )
    {
      v6 = *(void **)v2;
      if ( *(_DWORD *)v2 )
      {
        v4 = *(_WORD *)(v3 + 2);
        *(_WORD *)(v3 + 2) = v4 + 1;
        if ( v4 == 255 )
          --*(_WORD *)(v3 + 2);
      }
      else
      {
        RtlSetLastWin32Error(157);
      }
    }
    else
    {
      RtlSetLastWin32Error(6);
      v6 = 0;
    }
    RtlUnlockHeap(BaseHeap);
    result = v6;
  }
  else
  {
    v1 = SystemRangeStart;
    if ( !SystemRangeStart )
    {
      NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)50, &hMem, 4u, SystemRangeStart);
      v1 = (PULONG)hMem;
      SystemRangeStart = (PULONG)hMem;
    }
    if ( v2 >= v1 || IsBadReadPtr(v2, 1u) )
    {
      RtlSetLastWin32Error(6);
      result = 0;
    }
    else
    {
      result = v2;
    }
  }
  return result;
}
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E2A42A) --------------------------------------------------------
PVOID __stdcall BasepMapModuleHandle(void *a1, char a2)
{
  PVOID result; // eax@3

  if ( a1 )
  {
    if ( (unsigned __int8)a1 & 3 )
      result = (PVOID)(a2 != 0 ? (unsigned int)a1 : 0);
    else
      result = a1;
  }
  else
  {
    result = NtCurrentTeb()->ProcessEnvironmentBlock->Reserved3[1];
  }
  return result;
}

//----- (77E2A456) --------------------------------------------------------
ULONG __stdcall BaseDllMapResourceIdA(ULONG Value)
{
  signed int v1; // eax@4
  PWCH i; // esi@9
  ULONG v3; // eax@1
  STRING DestinationString; // [sp+10h] [bp-3Ch]@8
  LSA_UNICODE_STRING UnicodeString; // [sp+18h] [bp-34h]@8
  int v7; // [sp+20h] [bp-2Ch]@8
  int v8; // [sp+28h] [bp-24h]@9
  PWCH v9; // [sp+2Ch] [bp-20h]@10
  ULONG v10; // [sp+30h] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  v3 = Value;
  if ( Value < 0x10000 )
    goto LABEL_2;
  if ( *(_BYTE *)Value == 35 )
  {
    v1 = RtlCharToInteger((PCSZ)(Value + 1), 0xAu, &Value);
    v10 = Value;
    if ( v1 >= 0 )
    {
      if ( !(Value & 0xFFFF0000) )
        goto LABEL_3;
      if ( v1 >= 0 )
        v1 = -1073741811;
    }
LABEL_16:
    BaseSetLastNTError(v1);
    v10 = -1;
    goto LABEL_3;
  }
  RtlInitAnsiString(&DestinationString, (PCSZ)Value);
  v1 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  v7 = v1;
  if ( v1 < 0 )
    goto LABEL_16;
  ms_exc.registration.TryLevel = 1;
  v8 = 1;
  for ( i = UnicodeString.Buffer; ; ++i )
  {
    v9 = i;
    if ( !*i )
      break;
    *i = RtlUpcaseUnicodeChar(*i);
  }
  ms_exc.registration.TryLevel = 0;
  v8 = 0;
  v3 = (ULONG)UnicodeString.Buffer;
LABEL_2:
  v10 = v3;
LABEL_3:
  ms_exc.registration.TryLevel = -2;
  return v10;
}

//----- (77E2A4BD) --------------------------------------------------------
HRSRC __stdcall __noreturn FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
{
  PVOID v4; // eax@3
  HRSRC result; // eax@5
  ULONG v6; // [sp+10h] [bp-30h]@1
  ULONG v7; // [sp+14h] [bp-2Ch]@1
  int v8; // [sp+18h] [bp-28h]@3
  HRSRC v9; // [sp+20h] [bp-20h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@1

  v9 = 0;
  v7 = 0;
  ms_exc.registration.TryLevel = 1;
  v6 = BaseDllMapResourceIdA((ULONG)lpType);
  if ( v6 == -1 || (v7 = BaseDllMapResourceIdA((ULONG)lpName), v7 == -1) )
  {
    NtStatus = -1073741811;
  }
  else
  {
    v8 = wLanguage;
    v9 = 0;
    v4 = BasepMapModuleHandle(hModule, 1);
    NtStatus = LdrFindResource_U(v4, &v6, 3, &v9);
  }
  ms_exc.registration.TryLevel = 0;
  BaseDllFreeResourceId(v6);
  BaseDllFreeResourceId(v7);
  ms_exc.registration.TryLevel = -2;
  if ( NtStatus < 0 )
  {
    BaseSetLastNTError(NtStatus);
    result = 0;
  }
  else
  {
    result = v9;
  }
  return result;
}
// 77DE12EC: using guessed type int __stdcall LdrFindResource_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);

//----- (77E2A585) --------------------------------------------------------
HRSRC __stdcall __noreturn FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
{
  FindResourceExA(hModule, lpType, lpName, 0);
}

//----- (77E2A5CF) --------------------------------------------------------
int __stdcall GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
{
  const WCHAR *v6; // eax@1
  int result; // eax@2

  v6 = (const WCHAR *)InternalLcidToName(Locale, 0);
  if ( v6 )
  {
    result = GetNumberFormatEx(v6, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}
// 77E2A5C4: using guessed type int __fastcall InternalLcidToName(_DWORD, _DWORD);

//----- (77E2A604) --------------------------------------------------------
HGLOBAL __stdcall GlobalHandle(LPCVOID pMem)
{
  int v2; // [sp+14h] [bp-20h]@1
  LPCVOID v3; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v3 = 0;
  v2 = 2049;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 2049, pMem, &v3, &v2) )
  {
    if ( !v3 || !(v2 & 0x200) )
      v3 = pMem;
  }
  else
  {
    RtlSetLastWin32Error(6);
  }
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  return (HGLOBAL)v3;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2A6C7) --------------------------------------------------------
LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
{
  LPCSTR v2; // ecx@1
  LPSTR v3; // edx@1
  const CHAR v4; // al@2

  v2 = lpString2;
  v3 = lpString1;
  do
  {
    v4 = *v2;
    *v3++ = *v2++;
  }
  while ( v4 );
  return lpString1;
}

//----- (77E2A721) --------------------------------------------------------
BOOL __stdcall FindNextFileAStub(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
{
  return FindNextFileA(hFindFile, lpFindFileData);
}

//----- (77E2A739) --------------------------------------------------------
LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2)
{
  unsigned int v2; // edx@1
  LPSTR v3; // edi@1
  LPSTR result; // eax@1
  CHAR v5; // cl@2

  v2 = strlen(lpString2) + 1;
  v3 = lpString1 - 1;
  result = lpString1;
  do
    v5 = (v3++)[1];
  while ( v5 );
  qmemcpy(v3, lpString2, v2);
  return result;
}

//----- (77E2A7A9) --------------------------------------------------------
void __stdcall NlsAnsiToUnicode(int a1, int a2, int a3, INT piResult, int a5, int a6)
{
  int v6; // eax@1
  char v7; // cl@3
  int v8; // ebx@5
  void *v9; // esi@5
  int v10; // eax@8
  int v11; // ecx@10
  int v12; // eax@17

  v6 = a3;
  if ( a3 )
  {
    if ( piResult >= 0 )
      goto LABEL_23;
    do
      v7 = *(_BYTE *)v6++;
    while ( v7 );
    if ( UIntPtrToInt(v6 - (a3 + 1) + 1, &piResult) < 0 )
    {
      RtlSetLastWin32Error(87);
    }
    else
    {
LABEL_23:
      v8 = a5;
      v9 = *(void **)a5;
      if ( *(_DWORD *)a5 && piResult <= 127 )
      {
        if ( piResult )
        {
          v10 = SpecialMBToWC(a1, a2, a3, piResult, v9, 127);
          if ( v10 && v10 <= 127 )
          {
            *((_WORD *)v9 + v10) = 0;
            v11 = a6;
            *(_DWORD *)v8 = v9;
            *(_DWORD *)v11 = v10;
          }
          else
          {
            if ( v9 != *(void **)v8 )
            {
              if ( v9 )
                RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
            }
            RtlSetLastWin32Error(87);
          }
        }
        else
        {
          *(_WORD *)v9 = 0;
          v12 = a6;
          *(_DWORD *)v8 = v9;
          *(_DWORD *)v12 = 0;
        }
      }
      else
      {
        sub_77E2AB12((int)NtCurrentTeb()->ProcessEnvironmentBlock, piResult, a1, a2, a3, piResult, a5, a6);
      }
    }
  }
  else
  {
    *(_DWORD *)a5 = 0;
    *(_DWORD *)a6 = 0;
  }
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2A8F0: using guessed type int __stdcall SpecialMBToWC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2A844) --------------------------------------------------------
int __stdcall NlsUnicodeToAnsi(int a1, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte)
{
  return WideCharToMultiByte(*(_DWORD *)a1, 0, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, 0, 0);
}

//----- (77E2A86D) --------------------------------------------------------
int __stdcall NlsGetACPFromLocale(char a1, int a2)
{
  int v2; // eax@2
  int v3; // eax@3
  int v5; // [sp+0h] [bp-4h]@1

  v5 = 0;
  if ( a2 & 0x60000000 )
    return *(_DWORD *)(KernelBaseGetGlobalData() + 148);
  v2 = NlsValidateLocale(&a1, 0);
  if ( !v2 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v3 = *(_DWORD *)(v2 + 16);
  if ( !*(_WORD *)(v3 + 110) )
    return *(_DWORD *)(KernelBaseGetGlobalData() + 148);
  if ( GetCPHashNode(*(_WORD *)(v3 + 110), &v5) )
  {
    if ( !v5 )
      RtlSetLastWin32Error(87);
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2A8C2: using guessed type int __fastcall GetCPHashNode(_DWORD, _DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);

//----- (77E2A8CD) --------------------------------------------------------
HRESULT UIntPtrToInt(UINT_PTR uOperand, INT *piResult)
{
  HRESULT result; // eax@2

  if ( uOperand > 0x7FFFFFFF )
  {
    *piResult = -1;
    result = -2147024362;
  }
  else
  {
    *piResult = uOperand;
    result = 0;
  }
  return result;
}

//----- (77E2A8FB) --------------------------------------------------------
int __stdcall GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
{
  int v6; // eax@1
  int v7; // eax@5
  const NUMBERFMTA *v8; // esi@7
  int v9; // ST08_4@7
  int v10; // eax@7
  int v11; // eax@8
  int v13; // esi@28
  char v14; // [sp+10h] [bp-238h]@7
  PVOID Address; // [sp+1Ch] [bp-22Ch]@7
  PVOID v16; // [sp+20h] [bp-228h]@7
  char v17; // [sp+28h] [bp-220h]@5
  const NUMBERFMTA *v18; // [sp+2Ch] [bp-21Ch]@1
  int v19; // [sp+30h] [bp-218h]@1
  NUMBERFMTW *v20; // [sp+34h] [bp-214h]@1
  int cchWideChar; // [sp+38h] [bp-210h]@10
  LPWSTR v22; // [sp+3Ch] [bp-20Ch]@10
  LPCWSTR v23; // [sp+40h] [bp-208h]@5
  char v24; // [sp+44h] [bp-204h]@5
  WCHAR NumberStr; // [sp+144h] [bp-104h]@10

  v18 = lpFormat;
  v20 = 0;
  v6 = NlsGetACPFromLocale(Locale, dwFlags);
  v19 = v6;
  if ( !v6 || cchNumber < 0 || !lpNumberStr && cchNumber || lpValue == lpNumberStr )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v23 = (LPCWSTR)&v24;
  NlsAnsiToUnicode(v6, 0, (int)lpValue, -1, (int)&v23, (int)&v17);
  if ( !v7 )
    return 0;
  if ( v18 )
  {
    qmemcpy(&v14, v18, 0x18u);
    v8 = v18;
    v9 = (int)v18->lpDecimalSep;
    Address = 0;
    v16 = 0;
    NlsAnsiToUnicode(v19, 0, v9, -1, (int)&Address, (int)&v17);
    if ( v10 )
    {
      NlsAnsiToUnicode(v19, 0, (int)v8->lpThousandSep, -1, (int)&v16, (int)&v17);
      if ( v11 )
      {
        v20 = (NUMBERFMTW *)&v14;
        goto LABEL_10;
      }
    }
    if ( (char *)v23 != &v24 && v23 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v23);
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    return 0;
  }
LABEL_10:
  v22 = &NumberStr;
  cchWideChar = GetNumberFormatW(Locale, dwFlags, v23, v20, &NumberStr, 128);
  if ( !cchWideChar )
  {
    while ( GetLastError() == 122 && v22 == &NumberStr )
    {
      RtlSetLastWin32Error(0);
      v13 = GetNumberFormatW(Locale, dwFlags, v23, v20, 0, 0);
      if ( v13 )
      {
        v22 = (LPWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v13);
        if ( !v22 )
        {
          RtlSetLastWin32Error(14);
          cchWideChar = 0;
          break;
        }
      }
      cchWideChar = GetNumberFormatW(Locale, dwFlags, v23, v20, v22, v13);
      if ( cchWideChar )
        break;
    }
  }
  if ( (char *)v23 != &v24 && v23 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v23);
  if ( v18 )
  {
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( v16 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v16);
  }
  if ( cchWideChar > 0 )
    cchWideChar = NlsUnicodeToAnsi(v19, v22, cchWideChar, lpNumberStr, cchNumber);
  if ( v22 != &NumberStr )
  {
    if ( v22 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v22);
  }
  return cchWideChar;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2AB12) --------------------------------------------------------
void __userpurge sub_77E2AB12(int a1@<eax>, int a2@<ecx>, int a3, int a4, int a5, int a6, int a7, int a8)
{
  JUMPOUT(RtlAllocateHeap(*(HANDLE *)(a1 + 24), 8u, 2 * a2 + 2), 0, &loc_77E2A7FB);
  JUMPOUT(&loc_77E5549B);
}

//----- (77E2AB36) --------------------------------------------------------
DWORD __stdcall VerLanguageNameAStub(DWORD wLang, LPSTR szLang, DWORD cchLang)
{
  return VerLanguageNameA(wLang, szLang, cchLang);
}

//----- (77E2ABE7) --------------------------------------------------------
int __stdcall lstrcmpiWStub(LPCWSTR lpString1, LPCWSTR lpString2)
{
  return lstrcmpiW(lpString1, lpString2);
}

//----- (77E2ABFF) --------------------------------------------------------
void __stdcall GetLocalTimeStub(LPSYSTEMTIME lpSystemTime)
{
  GetLocalTime(lpSystemTime);
}

//----- (77E2AC22) --------------------------------------------------------
int __stdcall NlsPadIntToUnicodeString(ULONG Value, ULONG Base, int a3, int a4, int a5)
{
  unsigned int v5; // eax@2
  int result; // eax@4
  LSA_UNICODE_STRING String; // [sp+8h] [bp-8Ch]@1
  char v8; // [sp+10h] [bp-84h]@1

  String.MaximumLength = 128;
  String.Buffer = (PWCH)&v8;
  String.Length = 128;
  if ( RtlIntegerToUnicodeString(Value, Base, &String) < 0 )
  {
    result = 0;
  }
  else
  {
    v5 = (unsigned int)String.Length >> 1;
    while ( v5 < a3 && *(_DWORD *)a5 )
    {
      **(_WORD **)a4 = 48;
      *(_DWORD *)a4 += 2;
      ++v5;
      --*(_DWORD *)a5;
    }
    result = NlsCopyUnicodeString((STRSAFE_LPWSTR *)a4, (size_t *)a5, String.Buffer) != 0;
  }
  return result;
}

//----- (77E2ACB5) --------------------------------------------------------
BOOL __stdcall NlsCopyUnicodeString(STRSAFE_LPWSTR *ppszDestEnd, size_t *pcchRemaining, STRSAFE_LPCWSTR pszSrc)
{
  return StringCchCopyExW(*ppszDestEnd, *pcchRemaining, pszSrc, ppszDestEnd, pcchRemaining, 0) >= 0;
}

//----- (77E2ACE2) --------------------------------------------------------
HRESULT __stdcall StringCchCopyExW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc, STRSAFE_LPWSTR *ppszDestEnd, size_t *pcchRemaining, DWORD dwFlags)
{
  int v6; // edx@0
  wchar_t *v7; // edi@1
  int v8; // ecx@1
  signed int v9; // esi@1
  size_t v10; // ebx@2
  size_t v12; // [sp+8h] [bp-4h]@2

  v7 = pszDest;
  v9 = sub_77E2ADA2(cchDest, v6, (int)pszDest, 0x7FFFFFFFu, dwFlags);
  if ( v9 < 0 )
    return v9;
  v10 = v8;
  pszDest = v7;
  v12 = v8;
  if ( dwFlags & 0x100 && !pszSrc )
    pszSrc = &Src;
  v9 = 0;
  if ( dwFlags & 0xFFFFE000 )
  {
    v9 = -2147024809;
    if ( v8 )
      *v7 = 0;
  }
  else if ( v8 )
  {
    pszDest = 0;
    v9 = sub_77E2DB49((int)pszSrc, v8, (int)v7, (int)&pszDest, 2147483646);
    v10 -= (unsigned int)pszDest;
    pszDest = &v7[(_DWORD)pszDest];
    v12 = v10;
    if ( v9 >= 0 )
    {
      if ( dwFlags & 0x200 && v10 > 1 && 2 * v10 > 2 )
        memset(pszDest + 1, (unsigned __int8)dwFlags, 2 * v10 - 2);
      goto LABEL_7;
    }
    v8 = cchDest;
  }
  else
  {
    if ( !*pszSrc )
    {
LABEL_7:
      if ( ppszDestEnd )
        *ppszDestEnd = pszDest;
      if ( pcchRemaining )
        *pcchRemaining = v10;
      return v9;
    }
    v9 = v7 != 0 ? -2147024774 : -2147024809;
  }
  if ( dwFlags & 0x1C00 && v8 )
  {
    sub_77E78D02(0, (int)&v12, v7, 2 * v8, (int)&pszDest, dwFlags);
    v10 = v12;
  }
  if ( v9 >= 0 || v9 == -2147024774 )
    goto LABEL_7;
  return v9;
}

//----- (77E2ADA2) --------------------------------------------------------
signed int __fastcall sub_77E2ADA2(unsigned int a1, int a2, int a3, unsigned int a4, __int16 a5)
{
  signed int result; // eax@1

  result = 0;
  if ( a5 & 0x100 )
  {
    if ( a3 || !a1 )
    {
LABEL_3:
      if ( a1 <= a4 )
        return result;
      return -2147024809;
    }
  }
  else if ( a1 )
  {
    goto LABEL_3;
  }
  return -2147024809;
}

//----- (77E2ADDA) --------------------------------------------------------
int __stdcall DoFormatDate(int a1, char a2, int a3, wchar_t *a4, wchar_t *a5, unsigned int a6, int a7, int a8, signed int a9, int a10)
{
  int v10; // eax@16
  int v11; // eax@17
  signed __int16 v12; // ax@19
  STRSAFE_LPWSTR v13; // ecx@23
  int v14; // esi@27
  int v15; // edi@28
  int v16; // eax@28
  int v17; // eax@30
  signed int v18; // esi@34
  wchar_t *v19; // ebx@1
  wchar_t v20; // ax@1
  int v21; // edi@1
  signed int v22; // eax@6
  int v23; // eax@8
  STRSAFE_LPWSTR v24; // eax@11
  bool v26; // zf@36
  int v27; // eax@42
  int v28; // eax@44
  signed int v29; // esi@50
  unsigned __int16 v30; // ax@54
  STRSAFE_LPWSTR v31; // ecx@61
  const wchar_t *v32; // eax@69
  int v33; // eax@73
  unsigned int v34; // eax@74
  int v35; // eax@78
  signed int v36; // esi@79
  int v37; // eax@81
  int v38; // eax@82
  int v39; // eax@89
  const wchar_t *v40; // eax@99
  int v41; // eax@104
  wchar_t v42; // dx@109
  wchar_t *v43; // ecx@109
  int v44; // edx@115
  int v45; // [sp-14h] [bp-64h]@13
  int v46; // [sp-Ch] [bp-5Ch]@13
  int v47; // [sp-8h] [bp-58h]@13
  int v48; // [sp-8h] [bp-58h]@16
  int v49; // [sp-8h] [bp-58h]@17
  int v50; // [sp-8h] [bp-58h]@74
  int v51; // [sp-8h] [bp-58h]@89
  int v52; // [sp-4h] [bp-54h]@13
  int v53; // [sp-4h] [bp-54h]@16
  unsigned int v54; // [sp-4h] [bp-54h]@17
  int v55; // [sp-4h] [bp-54h]@89
  signed int v56; // [sp+14h] [bp-3Ch]@1
  signed __int16 v57; // [sp+18h] [bp-38h]@0
  int v58; // [sp+1Ch] [bp-34h]@1
  STRSAFE_LPCWSTR pszSrc; // [sp+20h] [bp-30h]@28
  int v60; // [sp+24h] [bp-2Ch]@1
  int v61; // [sp+28h] [bp-28h]@1
  int v62; // [sp+2Ch] [bp-24h]@1
  size_t pcchRemaining; // [sp+30h] [bp-20h]@1
  STRSAFE_LPWSTR ppszDestEnd; // [sp+34h] [bp-1Ch]@1
  wchar_t v65; // [sp+38h] [bp-18h]@74

  v19 = a4;
  v61 = a1;
  ppszDestEnd = a5;
  v20 = *a4;
  v62 = a7;
  v21 = a3;
  v60 = 0;
  v58 = 0;
  v56 = 0;
  pcchRemaining = 256;
  if ( !v20 )
    goto LABEL_11;
  while ( v20 != 39 )
  {
    if ( v20 == 77 )
    {
      ++v19;
      v18 = 0;
      v26 = *v19 == 77;
      pszSrc = 0;
      if ( v26 )
      {
        do
        {
          ++v18;
          ++v19;
        }
        while ( *v19 == 77 );
        pszSrc = (STRSAFE_LPCWSTR)v18;
      }
      if ( v56 )
      {
        if ( v18 < 3 && !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
          return 0;
        v56 = 0;
      }
      else if ( !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
      {
        return 0;
      }
      if ( v18 >= 0 && v18 <= 1 )
      {
        if ( a6 != 8 )
        {
          v52 = (int)&pcchRemaining;
          v47 = (int)&ppszDestEnd;
          v27 = *(_WORD *)(v21 + 2);
          v46 = v18 + 1;
          goto LABEL_62;
        }
        v50 = (int)&v65;
        v34 = *(_WORD *)(v21 + 2);
        goto LABEL_98;
      }
      v14 = *(_WORD *)(v21 + 2) - 1;
      if ( !*(_DWORD *)(v62 + 32) )
      {
        v15 = *(_DWORD *)(v61 + 16);
        v16 = *(_DWORD *)(v61 + 24);
        if ( pszSrc == (STRSAFE_LPCWSTR)2 )
        {
          v11 = GetLocaleNullStringFromArrayInPool(v16, *(_DWORD *)(v15 + 200), v14);
          v54 = v14;
          v49 = *(_DWORD *)(v15 + 208);
        }
        else
        {
          v11 = GetLocaleNullStringFromArrayInPool(v16, *(_DWORD *)(v15 + 196), v14);
          v54 = v14;
          v49 = *(_DWORD *)(v15 + 204);
        }
        pszSrc = (STRSAFE_LPCWSTR)v11;
        v17 = GetLocaleNullStringFromArrayInPoolTestArray(*(_DWORD *)(v61 + 24), v49, v54);
        if ( v17 && *(_WORD *)v17 )
        {
          if ( v60 )
          {
LABEL_119:
            pszSrc = (STRSAFE_LPCWSTR)v17;
          }
          else
          {
            v42 = *v19;
            v43 = v19;
            if ( *v19 )
            {
              while ( v42 != 103 && v42 != 121 )
              {
                if ( v42 == 100 )
                {
                  v44 = 0;
                  if ( *v43 != 100 )
                    break;
                  do
                  {
                    ++v44;
                    ++v43;
                  }
                  while ( *v43 == 100 );
                  if ( v44 != 1 && v44 != 2 )
                    break;
                  goto LABEL_119;
                }
                ++v43;
                v42 = *v43;
                if ( !*v43 )
                  break;
              }
            }
          }
        }
        if ( !NlsCopyUnicodeString(&ppszDestEnd, &pcchRemaining, pszSrc) )
          return 0;
        v21 = a3;
        goto LABEL_43;
      }
      if ( a6 == 8 && !a10 && v14 >= 6 )
        v14 = *(_WORD *)(v21 + 2);
      v41 = *(_DWORD *)(KernelBaseGetGlobalData() + 116);
      if ( pszSrc == (STRSAFE_LPCWSTR)2 )
        v40 = (const wchar_t *)GetLocaleNullStringFromArrayInPool(v41, *(_DWORD *)(v62 + 36), v14);
      else
        v40 = (const wchar_t *)GetLocaleNullStringFromArrayInPool(v41, *(_DWORD *)(v62 + 32), v14);
LABEL_107:
      v28 = NlsCopyUnicodeString(&ppszDestEnd, &pcchRemaining, v40);
      goto LABEL_45;
    }
    if ( v20 == 100 )
    {
      if ( !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
        return 0;
      ++v19;
      v22 = 0;
      if ( *v19 != 100 )
      {
LABEL_7:
        v60 = 1;
        if ( a6 != 8 )
        {
          v23 = NlsPadIntToUnicodeString(*(_WORD *)(v21 + 6), 0xAu, v22 + 1, (int)&ppszDestEnd, (int)&pcchRemaining);
          goto LABEL_9;
        }
        if ( !NumberToHebrewLetter(*(_WORD *)(v21 + 6), (int)&v65, 10) )
          return 0;
        v32 = &v65;
LABEL_70:
        v23 = NlsCopyUnicodeString(&ppszDestEnd, &pcchRemaining, v32);
LABEL_9:
        if ( !v23 )
          return 0;
        goto LABEL_10;
      }
      do
      {
        ++v19;
        ++v22;
      }
      while ( *v19 == 100 );
      if ( v22 < 0 )
        goto LABEL_129;
      if ( v22 <= 1 )
        goto LABEL_7;
      if ( v22 == 2 )
      {
        v60 = 0;
        if ( !*(_DWORD *)(v62 + 28) )
        {
          v53 = *(_WORD *)(v21 + 4);
          v10 = v61;
          v48 = *(_DWORD *)(*(_DWORD *)(v61 + 16) + 192);
LABEL_69:
          v32 = (const wchar_t *)GetLocaleNullStringFromArrayInPool(*(_DWORD *)(v10 + 24), v48, v53);
          goto LABEL_70;
        }
        v39 = KernelBaseGetGlobalData();
        v55 = *(_WORD *)(v21 + 4);
        v51 = *(_DWORD *)(v62 + 28);
      }
      else
      {
LABEL_129:
        v60 = 0;
        if ( !*(_DWORD *)(v62 + 24) )
        {
          v53 = *(_WORD *)(v21 + 4);
          v10 = v61;
          v48 = *(_DWORD *)(*(_DWORD *)(v61 + 16) + 188);
          goto LABEL_69;
        }
        v39 = KernelBaseGetGlobalData();
        v55 = *(_WORD *)(v21 + 4);
        v51 = *(_DWORD *)(v62 + 24);
      }
      v32 = (const wchar_t *)GetLocaleNullStringFromArrayInPool(*(_DWORD *)(v39 + 116), v51, v55);
      goto LABEL_70;
    }
    if ( v20 == 103 )
    {
      if ( !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
        return 0;
      do
        ++v19;
      while ( *v19 == 103 );
      if ( a6 == 1 )
      {
        v35 = *(_DWORD *)(v61 + 24) + 2 * *(_DWORD *)(*(_DWORD *)(v61 + 16) + 264) + 2;
LABEL_87:
        if ( !NlsCopyUnicodeString(&ppszDestEnd, &pcchRemaining, (STRSAFE_LPCWSTR)v35) )
          return 0;
        v60 = 0;
        goto LABEL_10;
      }
      v36 = 1;
      if ( HaveEraRanges(a6, v62) )
      {
        if ( a8 )
        {
          v37 = v58;
          if ( v58 )
            goto LABEL_84;
          v38 = KernelBaseGetGlobalData();
          v57 = GetCalendarYear(
                  (int)&v58,
                  0,
                  a6,
                  v62,
                  *(_DWORD *)(v38 + 116),
                  *(_WORD *)v21,
                  *(_WORD *)(v21 + 2),
                  *(_WORD *)(v21 + 6));
          if ( v58 )
          {
            v37 = v58;
LABEL_84:
            v36 = *(_WORD *)(v37 + 2);
          }
        }
        else
        {
          v36 = a9;
        }
      }
      v35 = GetEraNameCountedString(a6, v62, v36, 0) + 2;
      goto LABEL_87;
    }
    if ( v20 == 121 )
    {
      if ( !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
        return 0;
      ++v19;
      v29 = 0;
      while ( *v19 == 121 )
      {
        ++v29;
        ++v19;
      }
      if ( !HaveEraRanges(a6, v62) || !a8 )
      {
        v30 = *(_WORD *)v21;
        goto LABEL_55;
      }
      if ( !v58 )
      {
        v33 = KernelBaseGetGlobalData();
        v30 = GetCalendarYear(
                (int)&v58,
                0,
                a6,
                v62,
                *(_DWORD *)(v33 + 116),
                *(_WORD *)v21,
                *(_WORD *)(v21 + 2),
                *(_WORD *)(v21 + 6));
LABEL_55:
        v57 = v30;
      }
      if ( a6 != 8 )
      {
        if ( v29 >= 0 && v29 <= 1 )
        {
          v52 = (int)&pcchRemaining;
          v47 = (int)&ppszDestEnd;
          v46 = v29 + 1;
          v45 = (unsigned __int16)v57 % 100;
        }
        else
        {
          v52 = (int)&pcchRemaining;
          v47 = (int)&ppszDestEnd;
          v27 = (unsigned __int16)v57;
          v46 = 2;
LABEL_62:
          v45 = v27;
        }
        v28 = NlsPadIntToUnicodeString(v45, 0xAu, v46, v47, v52);
LABEL_45:
        if ( !v28 )
          return 0;
LABEL_43:
        v60 = 0;
        goto LABEL_10;
      }
      v50 = (int)&v65;
      v34 = (unsigned __int16)v57;
LABEL_98:
      if ( !NumberToHebrewLetter(v34, v50, 10) )
        return 0;
      v40 = &v65;
      goto LABEL_107;
    }
    if ( pcchRemaining <= 1 )
      return 0;
    v31 = ppszDestEnd;
    ++ppszDestEnd;
    ++v19;
    --pcchRemaining;
    *v31 = v20;
LABEL_10:
    v20 = *v19;
    if ( !*v19 )
      goto LABEL_11;
  }
  if ( !NlsInsertBidiMark((int)&ppszDestEnd, a2, (int)&pcchRemaining) )
    return 0;
  ++v19;
  v12 = *v19;
  if ( *v19 == 1489 && ((*(_WORD *)v61 & 0x3FF) == 13 || a6 == 8) && v19[1] == 39 && v19[2] == 77 )
    v56 = 1;
  if ( v12 )
  {
    while ( 1 )
    {
      if ( v12 == 39 )
      {
        ++v19;
        if ( *v19 != 39 )
          goto LABEL_10;
        if ( pcchRemaining <= 1 )
          return 0;
        v12 = 39;
      }
      else if ( pcchRemaining <= 1 )
      {
        return 0;
      }
      v13 = ppszDestEnd;
      ++ppszDestEnd;
      ++v19;
      --pcchRemaining;
      *v13 = v12;
      v12 = *v19;
      if ( !*v19 )
        goto LABEL_10;
    }
  }
LABEL_11:
  v24 = ppszDestEnd;
  *ppszDestEnd = 0;
  return v24 - a5 + 1;
}
// 77E8B84B: using guessed type int __stdcall GetEraNameCountedString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2AECF) --------------------------------------------------------
signed int __stdcall NlsInsertBidiMark(int a1, char a2, int a3)
{
  signed __int16 v3; // si@3

  if ( !(a2 & 0x30) )
    return 1;
  if ( *(_DWORD *)a3 > 1u )
  {
    v3 = 8207;
    if ( !(a2 & 0x20) )
      v3 = 8206;
    **(_WORD **)a1 = v3;
    *(_DWORD *)a1 += 2;
    --*(_DWORD *)a3;
    return 1;
  }
  return 0;
}

//----- (77E2B01D) --------------------------------------------------------
int __stdcall DoFormatTime(int a1, int a2, signed __int16 *a3, wchar_t *a4, int a5)
{
  int v5; // eax@10
  bool v7; // zf@15
  ULONG v8; // eax@15
  signed __int16 v9; // ax@16
  int v10; // ecx@23
  int v11; // eax@24
  int v12; // eax@30
  signed __int16 *v13; // esi@1
  wchar_t v14; // ax@1
  STRSAFE_LPWSTR v15; // edi@1
  signed __int16 *v16; // edx@1
  int v17; // eax@7
  int v18; // edi@44
  STRSAFE_LPWSTR v19; // ecx@61
  int j; // ecx@62
  signed __int16 v21; // ax@71
  int v22; // ecx@71
  signed __int16 v23; // ax@85
  STRSAFE_LPWSTR v24; // ecx@90
  wchar_t *v25; // edi@92
  STRSAFE_LPWSTR v26; // edx@97
  int i; // ecx@98
  wchar_t *v28; // edi@102
  signed __int16 v29; // ax@104
  int v30; // ecx@104
  STRSAFE_LPWSTR v31; // edx@116
  int v32; // [sp-8h] [bp-D8h]@15
  int v33; // [sp-4h] [bp-D4h]@15
  signed int v34; // [sp+18h] [bp-B8h]@1
  wchar_t *v35; // [sp+1Ch] [bp-B4h]@1
  int k; // [sp+20h] [bp-B0h]@1
  STRSAFE_LPWSTR ppszDestEnd; // [sp+24h] [bp-ACh]@1
  size_t pcchRemaining; // [sp+28h] [bp-A8h]@1
  wchar_t pszSrc; // [sp+2Ch] [bp-A4h]@49

  k = 0;
  v13 = a3;
  pcchRemaining = 256;
  v34 = 256;
  v14 = *a3;
  v15 = a4;
  ppszDestEnd = a4;
  v35 = a4;
  v16 = a3;
  if ( v14 )
  {
    while ( 1 )
    {
      if ( v14 == 39 )
      {
        ++v13;
        v9 = *v13;
        if ( *v13 )
        {
          while ( 1 )
          {
            if ( v9 == 39 )
            {
              ++v13;
              if ( *v13 != 39 )
                goto LABEL_34;
              if ( pcchRemaining <= 1 )
                return 0;
              v9 = 39;
            }
            else if ( pcchRemaining <= 1 )
            {
              return 0;
            }
            ++v13;
            *v15 = v9;
            v9 = *v13;
            ++v15;
            --pcchRemaining;
            ppszDestEnd = v15;
            if ( !v9 )
              goto LABEL_34;
          }
        }
        goto LABEL_35;
      }
      if ( v14 == 72 )
        break;
      if ( v14 == 104 )
      {
        LOWORD(v8) = *(_WORD *)(a2 + 8);
        if ( !(a5 & 8) )
        {
          LOWORD(v8) = (unsigned __int16)v8 % 12;
          if ( !(_WORD)v8 )
            LOWORD(v8) = 12;
        }
        ++v13;
        v10 = 0;
        while ( *v13 == 104 )
        {
          ++v10;
          ++v13;
        }
        while ( k > 0 )
        {
          if ( pcchRemaining <= 1 )
            return 0;
          --k;
          *v15 = 32;
          ++v15;
          --pcchRemaining;
          ppszDestEnd = v15;
        }
        v7 = v10 == 0;
        v33 = (int)&pcchRemaining;
        v8 = (unsigned __int16)v8;
        v32 = (int)&ppszDestEnd;
LABEL_29:
        if ( v7 )
          v12 = NlsPadIntToUnicodeString(v8, 0xAu, 1, v32, v33);
        else
          v12 = NlsPadIntToUnicodeString(v8, 0xAu, 2, v32, v33);
        goto LABEL_31;
      }
      if ( v14 == 109 )
      {
        ++v13;
        v11 = 0;
        while ( *v13 == 109 )
        {
          ++v11;
          ++v13;
        }
        if ( a5 & 1 )
        {
          for ( i = 0; v16 != v13; ++v16 )
          {
            if ( *v16 == 39 )
            {
              i = i == 0;
            }
            else if ( i )
            {
              v28 = v35;
              ++v35;
              --v34;
              *v28 = *v16;
            }
          }
          v29 = *v13;
          v30 = 0;
          k = 0;
          if ( *v13 )
          {
            while ( 1 )
            {
              if ( *v16 == 39 )
                v30 = v30 == 0;
              if ( !v30 )
              {
                if ( v29 == 32 )
                {
                  ++k;
                }
                else if ( v29 == 104 || v29 == 72 || v29 == 116 )
                {
                  goto LABEL_77;
                }
              }
              ++v13;
              v29 = *v13;
              if ( !*v13 )
                goto LABEL_77;
            }
          }
          goto LABEL_77;
        }
        while ( k > 0 )
        {
          if ( pcchRemaining <= 1 )
            return 0;
          v31 = ppszDestEnd;
          --k;
          ++ppszDestEnd;
          --pcchRemaining;
          *v31 = 32;
        }
        v7 = v11 == 0;
        v33 = (int)&pcchRemaining;
        v32 = (int)&ppszDestEnd;
        v8 = *(_WORD *)(a2 + 10);
        goto LABEL_29;
      }
      if ( v14 == 115 )
      {
        ++v13;
        v17 = 0;
        while ( *v13 == 115 )
        {
          ++v17;
          ++v13;
        }
        if ( a5 & 3 )
        {
          for ( j = 0; v16 != v13; ++v16 )
          {
            if ( *v16 == 39 )
            {
              j = j == 0;
            }
            else if ( j )
            {
              v25 = v35;
              ++v35;
              --v34;
              *v25 = *v16;
            }
          }
          v21 = *v13;
          v22 = 0;
          for ( k = 0; *v13; v21 = *v13 )
          {
            if ( *v16 == 39 )
              v22 = v22 == 0;
            if ( !v22 )
            {
              if ( v21 == 32 )
              {
                ++k;
              }
              else if ( v21 == 104 || v21 == 72 || v21 == 116 || v21 == 109 )
              {
                break;
              }
            }
            ++v13;
          }
LABEL_77:
          ppszDestEnd = v35;
          pcchRemaining = v34;
          goto LABEL_34;
        }
        while ( k > 0 )
        {
          if ( pcchRemaining <= 1 )
            return 0;
          v26 = ppszDestEnd;
          --k;
          ++ppszDestEnd;
          --pcchRemaining;
          *v26 = 32;
        }
        v7 = v17 == 0;
        v33 = (int)&pcchRemaining;
        v32 = (int)&ppszDestEnd;
        v8 = *(_WORD *)(a2 + 12);
        goto LABEL_29;
      }
      if ( v14 == 116 )
      {
        ++v13;
        v18 = 0;
        while ( *v13 == 116 )
        {
          ++v18;
          ++v13;
        }
        while ( k > 0 )
        {
          if ( pcchRemaining <= 1 )
            return 0;
          v19 = ppszDestEnd;
          --k;
          ++ppszDestEnd;
          --pcchRemaining;
          *v19 = 32;
        }
        if ( a5 & 4 )
        {
          ppszDestEnd = v35;
          pcchRemaining = v34;
          v16 = v13;
          while ( 1 )
          {
            v23 = *v13;
            if ( !*v13 || v23 == 104 || v23 == 72 || v23 == 109 || v23 == 115 )
              break;
            ++v13;
          }
          goto LABEL_34;
        }
        if ( !GetLocaleInfoHelper(a1, a5 & 0x80000000 | (41 - (*(_WORD *)(a2 + 8) < 0xCu)), &pszSrc, 80) )
          pszSrc = 0;
        if ( pszSrc )
        {
          if ( v18 )
          {
            v12 = NlsCopyUnicodeString(&ppszDestEnd, &pcchRemaining, &pszSrc);
LABEL_31:
            if ( !v12 )
              return 0;
          }
          else
          {
            if ( pcchRemaining <= 1 )
              return 0;
            v24 = ppszDestEnd;
            ++ppszDestEnd;
            --pcchRemaining;
            *v24 = pszSrc;
          }
          v35 = ppszDestEnd;
          v34 = pcchRemaining;
        }
        else
        {
          ppszDestEnd = v35;
          pcchRemaining = v34;
        }
        v16 = v13;
        goto LABEL_34;
      }
      if ( pcchRemaining <= 1 )
        return 0;
      *v15 = v14;
      ++v13;
      --pcchRemaining;
      ppszDestEnd = v15 + 1;
LABEL_34:
      v14 = *v13;
      v15 = ppszDestEnd;
      if ( !*v13 )
        goto LABEL_35;
    }
    ++v13;
    v5 = 0;
    while ( *v13 == 72 )
    {
      ++v5;
      ++v13;
    }
    while ( k > 0 )
    {
      if ( pcchRemaining <= 1 )
        return 0;
      --k;
      *v15 = 32;
      ++v15;
      --pcchRemaining;
      ppszDestEnd = v15;
    }
    v7 = v5 == 0;
    v33 = (int)&pcchRemaining;
    v32 = (int)&ppszDestEnd;
    v8 = *(_WORD *)(a2 + 8);
    goto LABEL_29;
  }
LABEL_35:
  *v15 = 0;
  return v15 - a4 + 1;
}
// 77E2B6CD: using guessed type int __stdcall GetLocaleInfoHelper(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2B0D0) --------------------------------------------------------
int __stdcall GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
{
  int v6; // edi@1
  signed __int16 *v7; // esi@4

  v6 = NlsValidateLocale(&Locale, 0);
  if ( !v6
    || cchTime < 0
    || !lpTimeStr && cchTime
    || (v7 = (signed __int16 *)lpFormat) != 0 && SortNlsStrLenW((void *)lpFormat) >= 256 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(dwFlags & 0x3FFFFFF0) && (!v7 || !(dwFlags & 0x80000000)) )
      return GetTimeFormatWorker(v6, dwFlags, (int)lpTime, v7, lpTimeStr, cchTime);
    RtlSetLastWin32Error(1004);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);

//----- (77E2B155) --------------------------------------------------------
int __stdcall GetTimeFormatWorker(int a1, int a2, int a3, signed __int16 *a4, wchar_t *a5, int a6)
{
  signed __int16 *v6; // edi@1
  int v7; // eax@4
  int v8; // esi@4
  int v10; // [sp-8h] [bp-2CCh]@14
  struct _SYSTEMTIME SystemTime; // [sp+Ch] [bp-2B8h]@3
  STRSAFE_LPWSTR pszDest; // [sp+1Ch] [bp-2A8h]@1
  wchar_t pszSrc; // [sp+20h] [bp-2A4h]@4
  char v14; // [sp+220h] [bp-A4h]@13
  char v15; // [sp+222h] [bp-A2h]@20

  v6 = a4;
  pszDest = a5;
  if ( !a4 )
  {
    if ( a2 & 3 )
    {
      if ( !(a2 & 0x80000000) && NlsIsUserDefaultLocale(a1) && GetUserInfo(a1, 666, &v14, 80, a4) )
      {
LABEL_20:
        v6 = (signed __int16 *)&v15;
        goto LABEL_2;
      }
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 280);
    }
    else
    {
      if ( !(a2 & 0x80000000) && NlsIsUserDefaultLocale(a1) && GetUserInfo(a1, 504, &v14, 80, 0) )
        goto LABEL_20;
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 88);
    }
    v6 = (signed __int16 *)(GetStringFromArrayInPool(*(_DWORD *)(a1 + 24), v10, 0) + 2);
  }
LABEL_2:
  if ( a3 )
  {
    SystemTime.wHour = *(_WORD *)(a3 + 8);
    SystemTime.wMinute = *(_WORD *)(a3 + 10);
    SystemTime.wSecond = *(_WORD *)(a3 + 12);
    SystemTime.wMilliseconds = *(_WORD *)(a3 + 14);
    if ( !IsValidTime((int)&SystemTime) )
    {
LABEL_23:
      RtlSetLastWin32Error(87);
      return 0;
    }
  }
  else
  {
    GetLocalTime(&SystemTime);
  }
  v7 = DoFormatTime(a1, (int)&SystemTime, v6, &pszSrc, a2);
  v8 = v7;
  if ( !a6 || !pszDest )
    return v8;
  if ( a6 < v7 )
  {
    RtlSetLastWin32Error(122);
    return 0;
  }
  if ( !v7 )
    goto LABEL_23;
  if ( StringCchCopyW(pszDest, v7, &pszSrc) >= 0 )
    return v8;
  RtlSetLastWin32Error(14);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2B941: using guessed type int __stdcall NlsIsUserDefaultLocale(_DWORD);
// 77E48D11: using guessed type int __stdcall GetUserInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2B23C) --------------------------------------------------------
BOOL __stdcall IsValidTime(int a1)
{
  return *(_WORD *)(a1 + 8) <= 0x17u
      && *(_WORD *)(a1 + 10) <= 0x3Bu
      && *(_WORD *)(a1 + 12) <= 0x3Bu
      && *(_WORD *)(a1 + 14) <= 0x3E7u;
}

//----- (77E2B2B2) --------------------------------------------------------
int __stdcall GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
{
  int v6; // edi@1
  int v7; // esi@4

  v6 = NlsValidateLocale(&Locale, 0);
  if ( !v6
    || cchDate < 0
    || !lpDateStr && cchDate
    || (v7 = (int)lpFormat) != 0 && SortNlsStrLenW((void *)lpFormat) >= 256 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(dwFlags & 0x3FFFFF80)
      && !((unsigned __int8)dwFlags & (unsigned __int8)((dwFlags & 0xF0) - 1) & 0x70)
      && (!v7 || !(dwFlags & 0x8000000B)) )
      return GetDateFormatWorker(v6, dwFlags, (int)lpDate, v7, lpDateStr, cchDate, 0);
    RtlSetLastWin32Error(1004);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);

//----- (77E2B342) --------------------------------------------------------
size_t __stdcall sub_77E2B342(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return GetDateFormatWorker(a1, a2, a3, a4, (wchar_t *)a5, a6, a7);
}

//----- (77E2B347) --------------------------------------------------------
size_t __stdcall GetDateFormatWorker(int a1, int a2, int a3, int a4, wchar_t *a5, int a6, unsigned int a7)
{
  int v7; // eax@36
  int v8; // eax@37
  int v9; // eax@37
  int v10; // edi@38
  unsigned int v11; // eax@4
  int v12; // esi@11
  WORD v13; // cx@13
  int v14; // eax@20
  size_t v15; // esi@20
  char v16; // dl@23
  int v18; // eax@44
  __int16 v19; // ax@46
  int v20; // eax@51
  signed int v21; // eax@57
  bool v22; // zf@62
  signed int v23; // edi@75
  signed int i; // ecx@81
  wchar_t *v25; // eax@82
  int v26; // [sp+14h] [bp-2CCh]@1
  struct _SYSTEMTIME SystemTime; // [sp+18h] [bp-2C8h]@13
  int v28; // [sp+28h] [bp-2B8h]@1
  int v29; // [sp+2Ch] [bp-2B4h]@1
  int v30; // [sp+30h] [bp-2B0h]@1
  int v31; // [sp+34h] [bp-2ACh]@3
  int v32; // [sp+38h] [bp-2A8h]@1
  wchar_t pszSrc[256]; // [sp+3Ch] [bp-2A4h]@20
  __int16 v34; // [sp+23Ch] [bp-A4h]@40

  v29 = 0;
  v30 = 0;
  v32 = 0;
  v28 = 0;
  v26 = 0;
  if ( !(a2 & 0x80000000) )
  {
    if ( NlsIsUserDefaultLocale(a1) )
    {
      v32 = 1;
      if ( GetUserInfoWord(a1, 1398, &v31) )
      {
        v11 = (unsigned __int16)IsValidCalendarType(a1, (unsigned __int16)v31);
        v28 = (unsigned __int16)v11;
        if ( !(a2 & 4) )
        {
          if ( a7 )
            goto LABEL_8;
          a7 = v11;
        }
      }
    }
  }
  if ( !a7 )
  {
    if ( !(a2 & 4)
      || (v19 = GetLocaleWordFromArrayInPoolUseDefault(
                  *(_DWORD *)(a1 + 24),
                  *(_DWORD *)(*(_DWORD *)(a1 + 16) + 124),
                  1,
                  0),
          a7 = (unsigned __int16)v19,
          !v19) )
      a7 = *(_WORD *)(*(_DWORD *)(a1 + 24) + 2 * *(_DWORD *)(*(_DWORD *)(a1 + 16) + 124) + 2);
  }
LABEL_8:
  if ( a7 != v28 )
    v32 = 0;
  v31 = GetCalendar(a1, a7);
  if ( !v31 )
    goto LABEL_48;
  if ( a4 )
  {
    v12 = a4;
  }
  else
  {
    v7 = a2 & 0xB;
    if ( (unsigned int)v7 > 1 )
    {
      if ( v7 == 2 )
      {
        v18 = KernelBaseGetGlobalData();
        v9 = GetStringFromArrayInPool(*(_DWORD *)(v18 + 116), *(_DWORD *)(v31 + 12), 0);
        v30 = 32;
      }
      else
      {
        if ( v7 != 8 )
        {
          RtlSetLastWin32Error(1004);
          return 0;
        }
        v20 = KernelBaseGetGlobalData();
        v9 = GetStringFromArrayInPool(*(_DWORD *)(v20 + 116), *(_DWORD *)(v31 + 8), 0);
        v30 = 4102;
      }
    }
    else
    {
      v8 = KernelBaseGetGlobalData();
      v9 = GetStringFromArrayInPool(*(_DWORD *)(v8 + 116), *(_DWORD *)(v31 + 4), 0);
      v30 = 31;
    }
    v10 = v9;
    if ( !(a2 & 4) || a7 == 1 || !*(_WORD *)v9 || (v12 = v9 + 2, v9 == -2) )
    {
      if ( !v32 || (GetLocaleInfoHelper(a1, v30, &v34, 80), v12 = (int)&v34, !v34) )
      {
        if ( *(_WORD *)v10 )
        {
          v12 = v10 + 2;
        }
        else
        {
          GetLocaleInfoHelper(a1, v30 | 0x80000000, &v34, 80);
          v12 = (int)&v34;
        }
      }
    }
  }
  if ( a3 )
  {
    SystemTime.wYear = *(_WORD *)a3;
    SystemTime.wMonth = *(_WORD *)(a3 + 2);
    v13 = *(_WORD *)(a3 + 4);
    SystemTime.wDay = *(_WORD *)(a3 + 6);
    SystemTime.wHour = 0;
    SystemTime.wMinute = 0;
    SystemTime.wSecond = 0;
    SystemTime.wMilliseconds = 0;
    SystemTime.wDayOfWeek = v13;
    if ( !IsValidDate((int)&SystemTime) )
      goto LABEL_48;
  }
  else
  {
    GetLocalTime(&SystemTime);
  }
  if ( a7 == 6 )
  {
    v21 = GetHijriDate((int)&SystemTime, a2);
    goto LABEL_58;
  }
  if ( a7 == 8 )
  {
    v21 = GetHebrewDate((int)&SystemTime, (int)&v29);
    goto LABEL_58;
  }
  if ( a7 == 23 )
  {
    v21 = GetUmAlQuraDate((int)&SystemTime);
LABEL_58:
    if ( v21 )
      goto LABEL_17;
LABEL_48:
    RtlSetLastWin32Error(87);
    return 0;
  }
LABEL_17:
  if ( a2 & 0x40 )
  {
    a2 |= 0x10u;
    if ( GetLocaleInfoHelper(a1, 536871024, &v26, 2) )
    {
      if ( v26 == 1 )
      {
        if ( (*(_WORD *)a1 & 0x3FF) == 13 )
        {
          if ( v30 == 31 )
          {
            v22 = a7 == 8;
            goto LABEL_71;
          }
        }
        else if ( a7 != 1 && a7 != 6 && a7 != 23 && a7 != 10 && a7 != 11 )
        {
          v22 = a7 == 12;
LABEL_71:
          if ( !v22 )
            goto LABEL_20;
          goto LABEL_72;
        }
LABEL_72:
        a2 |= 0x20u;
        goto LABEL_20;
      }
    }
  }
LABEL_20:
  v14 = DoFormatDate(a1, a2, (int)&SystemTime, (wchar_t *)v12, pszSrc, a7, v31, 1, 0, v29);
  v15 = v14;
  if ( !a6 )
    return v15;
  if ( a6 < v14 )
  {
    RtlSetLastWin32Error(122);
    return 0;
  }
  if ( !v14 )
    goto LABEL_48;
  v16 = a2;
  if ( a2 & 0x40 )
  {
    if ( a7 == 8 )
      goto LABEL_75;
    if ( a7 == 1 )
    {
      if ( (*(_WORD *)a1 & 0x3FF) != 13 )
      {
        if ( !IsHebrewCustomLocale(a1) )
          goto LABEL_28;
        v16 = a2;
      }
LABEL_75:
      v23 = 0;
      v29 = 8207;
      v32 = 8206;
      if ( (signed int)v15 > 0 )
      {
        while ( (unsigned int)pszSrc[v23] - 1425 > 0x63 )
        {
          ++v23;
          if ( v23 >= (signed int)v15 )
            goto LABEL_80;
        }
        v29 = 8206;
        v32 = 8207;
      }
LABEL_80:
      if ( (v16 & 0x20) != v23 < (signed int)v15 )
      {
        for ( i = 0; i < (signed int)v15; ++i )
        {
          v25 = &pszSrc[i];
          if ( *v25 == (_WORD)v29 )
            *v25 = v32;
        }
      }
      goto LABEL_28;
    }
  }
LABEL_28:
  if ( StringCchCopyW(a5, v15, pszSrc) >= 0 )
    return v15;
  RtlSetLastWin32Error(14);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2ADCF: using guessed type int __stdcall GetCalendar(_DWORD, _DWORD);
// 77E2B6CD: using guessed type int __stdcall GetLocaleInfoHelper(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E2B941: using guessed type int __stdcall NlsIsUserDefaultLocale(_DWORD);
// 77E2B94C: using guessed type int __stdcall GetUserInfoWord(_DWORD, _DWORD, _DWORD);
// 77E2B347: using guessed type wchar_t pszSrc[256];

//----- (77E2B61F) --------------------------------------------------------
signed int __stdcall HaveEraRanges(int a1, int a2)
{
  signed int result; // eax@1

  result = 0;
  if ( *(_DWORD *)(a2 + 20) || a1 == 3 )
    result = 1;
  return result;
}

//----- (77E2B65F) --------------------------------------------------------
signed int __stdcall IsValidDate(int a1)
{
  signed int result; // eax@2
  TIME_FIELDS TimeFields; // [sp+4h] [bp-18h]@1
  LARGE_INTEGER Time; // [sp+14h] [bp-8h]@1

  TimeFields.Year = *(_WORD *)a1;
  TimeFields.Month = *(_WORD *)(a1 + 2);
  TimeFields.Day = *(_WORD *)(a1 + 6);
  TimeFields.Hour = 0;
  TimeFields.Minute = 0;
  TimeFields.Second = 0;
  TimeFields.Milliseconds = 0;
  if ( RtlTimeFieldsToTime(&TimeFields, &Time) )
  {
    RtlTimeToTimeFields(&Time, &TimeFields);
    *(_WORD *)(a1 + 4) = TimeFields.Weekday;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E2B7FC) --------------------------------------------------------
int __thiscall SortNlsStrLenW(void *this)
{
  void *i; // eax@1

  for ( i = this; *(_WORD *)i; i = (char *)i + 2 )
  {
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
    i = (char *)i + 2;
    if ( !*(_WORD *)i )
      break;
  }
  return ((_BYTE *)i - (_BYTE *)this) >> 1;
}

//----- (77E2B886) --------------------------------------------------------
__int16 __stdcall IsValidCalendarType(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1

  v2 = *(_DWORD *)(a1 + 24) + 2 * *(_DWORD *)(*(_DWORD *)(a1 + 16) + 124);
  v3 = v2 + 2 * *(_WORD *)v2;
  while ( 1 )
  {
    v2 += 2;
    if ( v2 > (unsigned int)v3 )
      break;
    if ( a2 == *(_WORD *)v2 )
      return *(_WORD *)v2;
  }
  return 0;
}

//----- (77E2B917) --------------------------------------------------------
int __stdcall GetLocaleNullStringFromArrayInPool(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a2 )
    result = a1 + 2 * *(_DWORD *)(a1 + 2 * (a2 + 2 * a3) + 2) + 2;
  else
    result = a1;
  return result;
}

//----- (77E2B957) --------------------------------------------------------
BOOL __stdcall IsHebrewCustomLocale(int a1)
{
  int v2; // [sp+0h] [bp-20h]@4

  return *(_DWORD *)(a1 + 28) && GetLocaleInfoHelper(a1, 88, &v2, 16) && v2 & 0x800;
}
// 77E2B6CD: using guessed type int __stdcall GetLocaleInfoHelper(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2BA35) --------------------------------------------------------
BOOL __stdcall DeviceIoControlImplementation(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
{
  DWORD v8; // esi@1
  int v10; // eax@7

  v8 = dwIoControlCode;
  if ( dwIoControlCode != 2967560 && dwIoControlCode != 477192 && dwIoControlCode != 589856
    || NtCurrentTeb()->ProcessEnvironmentBlock->SessionId == v7FFE02D8 )
    return DeviceIoControl(
             hDevice,
             v8,
             lpInBuffer,
             nInBufferSize,
             lpOutBuffer,
             nOutBufferSize,
             lpBytesReturned,
             lpOverlapped);
  v10 = IsTSAppCompatEnabled((int)&dwIoControlCode);
  if ( v10 >= 0 )
  {
    if ( dwIoControlCode && !IsCallerAdminOrSystem() )
    {
      BaseSetLastNTError(-1073741790);
      return 0;
    }
    return DeviceIoControl(
             hDevice,
             v8,
             lpInBuffer,
             nInBufferSize,
             lpOutBuffer,
             nOutBufferSize,
             lpBytesReturned,
             lpOverlapped);
  }
  BaseSetLastNTError(v10);
  return 0;
}

//----- (77E2BA87) --------------------------------------------------------
DWORD __stdcall K32GetDeviceDriverBaseNameA(LPVOID ImageBase, LPSTR lpFilename, DWORD nSize)
{
  DWORD result; // eax@1
  unsigned int v4; // eax@2
  int v5; // esi@2
  int v6; // edi@2
  char v7; // [sp+4h] [bp-120h]@1
  unsigned __int16 v8; // [sp+1Eh] [bp-106h]@2
  char Src[256]; // [sp+20h] [bp-104h]@2

  result = FindDeviceDriver((int)ImageBase, &v7);
  if ( result )
  {
    v4 = strlen(&Src[v8]);
    v5 = v4 + 1;
    v6 = v4 + 1;
    if ( nSize < v4 + 1 )
      v6 = nSize;
    memcpy(lpFilename, &Src[v8], v6);
    if ( v6 == v5 )
      --v6;
    result = v6;
  }
  return result;
}
// 77E2BA87: using guessed type char Src[256];

//----- (77E2BB12) --------------------------------------------------------
signed int __stdcall FindDeviceDriver(int a1, void *a2)
{
  HLOCAL i; // eax@1
  void *v3; // ebx@2
  NTSTATUS v4; // eax@3
  unsigned int v5; // esi@3
  SIZE_T v6; // esi@5
  unsigned int v7; // eax@7
  int v8; // ecx@8
  DWORD v10; // eax@16
  ULONG ReturnLength; // [sp+Ch] [bp-Ch]@3
  NTSTATUS NtStatus; // [sp+10h] [bp-8h]@3
  ULONG SystemInformationLength; // [sp+14h] [bp-4h]@1

  SystemInformationLength = 1312;
  for ( i = LocalAlloc(0, 0x520u); ; i = LocalAlloc(0, v6) )
  {
    v3 = i;
    if ( !i )
    {
      SetLastError(0x5AAu);
      return 0;
    }
    v4 = NtQuerySystemInformation(
           SystemProcessorPerformanceInformation|SystemTimeOfDayInformation,
           i,
           SystemInformationLength,
           &ReturnLength);
    v5 = *(_DWORD *)v3;
    NtStatus = v4;
    if ( v4 >= 0 )
      break;
    LocalFree(v3);
    if ( NtStatus != -1073741820 )
    {
      v10 = RtlNtStatusToDosError(NtStatus);
LABEL_18:
      SetLastError(v10);
      return 0;
    }
    v6 = 284 * v5 + 4;
    if ( v6 <= SystemInformationLength )
    {
      v10 = RtlNtStatusToDosError(-1073741820);
      goto LABEL_18;
    }
    SystemInformationLength = v6;
  }
  v7 = 0;
  if ( !v5 )
  {
LABEL_15:
    LocalFree(v3);
    SetLastError(6u);
    return 0;
  }
  v8 = (int)((char *)v3 + 12);
  while ( *(_DWORD *)v8 != a1 )
  {
    ++v7;
    v8 += 284;
    if ( v7 >= v5 )
      goto LABEL_15;
  }
  qmemcpy(a2, (char *)v3 + 284 * v7 + 4, 0x11Cu);
  LocalFree(v3);
  return 1;
}

//----- (77E2BBF6) --------------------------------------------------------
BOOL __stdcall K32EnumDeviceDrivers(LPVOID *lpImageBase, DWORD cb, LPDWORD lpcbNeeded)
{
  int v3; // edi@11
  SIZE_T i; // ebx@1
  HLOCAL v5; // esi@2
  unsigned int v6; // edi@3
  unsigned int j; // ecx@4
  DWORD v9; // eax@14
  ULONG ReturnLength; // [sp+10h] [bp-2Ch]@3
  NTSTATUS v11; // [sp+1Ch] [bp-20h]@3
  HLOCAL hMem; // [sp+20h] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@7

  for ( i = 1312; ; i = v3 )
  {
    v5 = LocalAlloc(0, i);
    hMem = v5;
    if ( !v5 )
    {
      SetLastError(0x5AAu);
      return 0;
    }
    v11 = NtQuerySystemInformation(
            SystemProcessorPerformanceInformation|SystemTimeOfDayInformation,
            v5,
            i,
            &ReturnLength);
    v6 = *(_DWORD *)v5;
    if ( v11 >= 0 )
      break;
    LocalFree(v5);
    if ( v11 != -1073741820 )
    {
      v9 = RtlNtStatusToDosError(v11);
LABEL_16:
      SetLastError(v9);
      return 0;
    }
    v3 = 284 * v6 + 4;
    if ( v3 <= i )
    {
      v9 = RtlNtStatusToDosError(-1073741820);
      goto LABEL_16;
    }
  }
  for ( j = 0; j < v6 && j != cb >> 2; ++j )
  {
    ms_exc.registration.TryLevel = 0;
    lpImageBase[j] = (LPVOID)*((_DWORD *)v5 + 71 * j + 3);
    ms_exc.registration.TryLevel = -2;
  }
  *lpcbNeeded = 4 * v6;
  ms_exc.registration.TryLevel = -2;
  LocalFree(v5);
  return 1;
}

//----- (77E2BCBD) --------------------------------------------------------
BOOL __stdcall InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
{
  return (RtlRunOnceExecuteOnce(InitOnce, (PRTL_RUN_ONCE_INIT_FN)InitFn, Parameter, Context) & 0x80000000) == 0;
}

//----- (77E2BD40) --------------------------------------------------------
BOOL __stdcall ProcessIdToSessionIdStub(DWORD dwProcessId, DWORD *pSessionId)
{
  return ProcessIdToSessionId(dwProcessId, pSessionId);
}

//----- (77E2BDA0) --------------------------------------------------------
DWORD __stdcall WaitForMultipleObjectsExImplementation(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
{
  int v5; // eax@12
  DWORD v6; // edi@1
  char *v7; // ebx@2
  PPEB v8; // eax@3
  int *v9; // esi@4
  int v10; // ecx@4
  DWORD v11; // esi@9
  PVOID v13; // ecx@15
  char v14; // [sp+8h] [bp-20h]@2
  DWORD nCounta; // [sp+30h] [bp+8h]@3
  const HANDLE *lpHandlesa; // [sp+34h] [bp+Ch]@3

  v6 = nCount;
  if ( nCount > 8 )
  {
    v5 = KernelBaseGetGlobalData();
    v7 = (char *)RtlAllocateHeap(
                   NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                   *(_DWORD *)(v5 + 44),
                   4 * nCount);
    if ( !v7 )
    {
      BaseSetLastNTError(-1073741801);
      return -1;
    }
  }
  else
  {
    v7 = &v14;
  }
  memcpy(v7, lpHandles, 4 * nCount);
  v8 = NtCurrentTeb()->ProcessEnvironmentBlock;
  nCounta = 0;
  lpHandlesa = (const HANDLE *)v8;
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = (int *)&v7[4 * nCounta];
      v10 = *v9;
      if ( *v9 == -12 )
      {
        v13 = v8->ProcessParameters->Reserved2[4];
        goto LABEL_18;
      }
      if ( v10 == -11 )
        break;
      if ( v10 == -10 )
      {
        v13 = v8->ProcessParameters->Reserved2[2];
LABEL_18:
        *v9 = (int)v13;
      }
      if ( (*v9 & 0x10000003) == 3 )
      {
        if ( VerifyConsoleIoHandle(*v9) )
          *v9 = (int)GetConsoleInputWaitHandle();
        v8 = (PPEB)lpHandlesa;
      }
      ++nCounta;
      if ( nCounta >= v6 )
        goto LABEL_9;
    }
    v13 = v8->ProcessParameters->Reserved2[3];
    goto LABEL_18;
  }
LABEL_9:
  v11 = WaitForMultipleObjectsEx(v6, (const HANDLE *)v7, bWaitAll, dwMilliseconds, bAlertable);
  if ( v7 != &v14 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  return v11;
}

//----- (77E2BE54) --------------------------------------------------------
BOOL __stdcall ResetEventStub(HANDLE hEvent)
{
  return ResetEvent(hEvent);
}

//----- (77E2BE6C) --------------------------------------------------------
BOOL __stdcall SetEventStub(HANDLE hEvent)
{
  return SetEvent(hEvent);
}

//----- (77E2BE84) --------------------------------------------------------
DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
{
  return WaitForMultipleObjectsExImplementation(nCount, lpHandles, bWaitAll, dwMilliseconds, 0);
}

//----- (77E2BEB0) --------------------------------------------------------
int __stdcall lstrlenWStub(LPCWSTR lpString)
{
  return lstrlenW(lpString);
}

//----- (77E2BEBD) --------------------------------------------------------
BOOL __stdcall GetFileInformationByHandleStub(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
{
  return GetFileInformationByHandle(hFile, lpFileInformation);
}

//----- (77E2BED5) --------------------------------------------------------
BOOL __stdcall FileTimeToSystemTimeStub(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
{
  return FileTimeToSystemTime(lpFileTime, lpSystemTime);
}

//----- (77E2BEED) --------------------------------------------------------
BOOL __stdcall FileTimeToLocalFileTimeStub(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
{
  return FileTimeToLocalFileTime(lpFileTime, lpLocalFileTime);
}

//----- (77E2BF05) --------------------------------------------------------
int __stdcall WriteConsoleInternal(int a1, void *Src, int a3, int a4, char a5)
{
  PVOID v5; // esi@1
  int v6; // eax@2
  unsigned int v7; // eax@8
  struct _PORT_MESSAGE RequestMessage; // [sp+14h] [bp-BCh]@5
  int v10; // [sp+34h] [bp-9Ch]@6
  int v11; // [sp+3Ch] [bp-94h]@2
  char Dst; // [sp+40h] [bp-90h]@4
  int v13; // [sp+90h] [bp-40h]@4
  size_t Size; // [sp+94h] [bp-3Ch]@3
  char v15; // [sp+9Ch] [bp-34h]@4
  char v16; // [sp+9Dh] [bp-33h]@3
  CPPEH_RECORD ms_exc; // [sp+B8h] [bp-18h]@4

  v5 = 0;
  if ( !NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
    return -1073741816;
  v11 = a1;
  v6 = a3;
  if ( a5 )
    v6 = 2 * a3;
  Size = v6;
  v16 = a5;
  if ( (unsigned int)v6 > 0x50 )
  {
    v5 = ConsoleAllocateCaptureBuffer(1u, v6);
    if ( !v5 )
      return -1073741801;
    ConsoleCaptureMessageBuffer((int)v5, Src, Size, (int)&v13);
    v15 = 0;
  }
  else
  {
    v13 = (int)&Dst;
    ms_exc.registration.TryLevel = 0;
    memcpy(&Dst, Src, v6);
    ms_exc.registration.TryLevel = -2;
    v15 = 1;
  }
  ConsoleClientCallServer(&RequestMessage, (int)v5, 30, 104);
  if ( v5 )
    ConsoleFreeCaptureBuffer(v5);
  if ( v10 >= 0 && a4 )
  {
    v7 = Size;
    *(_DWORD *)a4 = Size;
    if ( a5 )
      *(_DWORD *)a4 = v7 >> 1;
  }
  return v10;
}

//----- (77E2BFE1) --------------------------------------------------------
UINT __stdcall GetConsoleCP()
{
  UINT result; // eax@2
  ULONG v1; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  UINT v4; // [sp+28h] [bp-7Ch]@2
  int v5; // [sp+2Ch] [bp-78h]@1

  v5 = 0;
  ConsoleClientCallServer(&RequestMessage, 0, 60, 8);
  if ( NtStatus < 0 )
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  else
  {
    result = v4;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2C02D) --------------------------------------------------------
BOOL __stdcall WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
{
  NTSTATUS v5; // eax@1
  BOOL result; // eax@2
  ULONG v7; // eax@4

  v5 = WriteConsoleInternal(
         (int)hConsoleOutput,
         (void *)lpBuffer,
         nNumberOfCharsToWrite,
         (int)lpNumberOfCharsWritten,
         0);
  if ( v5 < 0 )
  {
    v7 = RtlNtStatusToDosError(v5);
    RtlSetLastWin32Error(v7);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2C063) --------------------------------------------------------
HANDLE __stdcall FindFirstFileAStub(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
{
  return FindFirstFileA(lpFileName, lpFindFileData);
}

//----- (77E2C080) --------------------------------------------------------
int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator)
{
  unsigned __int64 v3; // rax@3
  unsigned __int64 v4; // rax@4
  int result; // eax@5
  int v6; // eax@7
  unsigned __int64 v7; // rax@8
  unsigned __int64 v8; // rax@9
  unsigned __int64 v9; // rax@12
  unsigned __int64 v10; // rax@13
  unsigned __int64 v11; // rax@16
  unsigned __int64 v12; // rax@19
  unsigned __int64 v13; // rax@22
  unsigned __int64 v14; // rax@23
  unsigned __int64 v15; // rax@26
  unsigned __int64 v16; // rax@29

  if ( nNumber < 0 )
  {
    v6 = -nNumber;
    if ( nNumerator < 0 )
    {
      v9 = (unsigned int)-nNumerator * (unsigned __int64)(unsigned int)v6;
      if ( nDenominator < 0 )
      {
        v12 = (unsigned int)(-nDenominator >> 1) + v9;
        if ( HIDWORD(v12) < -nDenominator )
        {
          result = -(signed int)(v12 / (unsigned int)-nDenominator);
          if ( result < 1 || result == 0 )
            return result;
        }
      }
      else
      {
        v10 = (unsigned int)(nDenominator >> 1) + v9;
        if ( HIDWORD(v10) < nDenominator )
        {
          result = v10 / (unsigned int)nDenominator;
          if ( result >= 0 )
            return result;
        }
      }
    }
    else
    {
      v7 = (unsigned int)nNumerator * (unsigned __int64)(unsigned int)v6;
      if ( nDenominator < 0 )
      {
        v11 = (unsigned int)(-nDenominator >> 1) + v7;
        if ( HIDWORD(v11) < -nDenominator )
        {
          result = v11 / (unsigned int)-nDenominator;
          if ( result >= 0 )
            return result;
        }
      }
      else
      {
        v8 = (unsigned int)(nDenominator >> 1) + v7;
        if ( HIDWORD(v8) < nDenominator )
        {
          result = -(signed int)(v8 / (unsigned int)nDenominator);
          if ( result < 1 || result == 0 )
            return result;
        }
      }
    }
    return -1;
  }
  if ( nNumerator < 0 )
  {
    v13 = (unsigned int)-nNumerator * (unsigned __int64)(unsigned int)nNumber;
    if ( nDenominator >= 0 )
    {
      v14 = (unsigned int)(nDenominator >> 1) + v13;
      if ( HIDWORD(v14) < nDenominator )
      {
        result = -(signed int)(v14 / (unsigned int)nDenominator);
        if ( result < 1 || result == 0 )
          return result;
      }
      return -1;
    }
    v15 = (unsigned int)(-nDenominator >> 1) + v13;
    if ( HIDWORD(v15) >= -nDenominator )
      return -1;
    result = v15 / (unsigned int)-nDenominator;
    if ( result >= 0 )
      return result;
    return -1;
  }
  v3 = (unsigned int)nNumerator * (unsigned __int64)(unsigned int)nNumber;
  if ( nDenominator < 0 )
  {
    v16 = (unsigned int)(-nDenominator >> 1) + v3;
    if ( HIDWORD(v16) < -nDenominator )
    {
      result = -(signed int)(v16 / (unsigned int)-nDenominator);
      if ( result < 1 || result == 0 )
        return result;
    }
    return -1;
  }
  v4 = (unsigned int)(nDenominator >> 1) + v3;
  if ( HIDWORD(v4) >= nDenominator || (result = v4 / (unsigned int)nDenominator, result < 0) )
    result = -1;
  return result;
}

//----- (77E2C1A0) --------------------------------------------------------
void __stdcall SwitchToFiber(LPVOID lpFiber)
{
  int v1; // ebx@0
  int v2; // ebp@0
  int v3; // edi@0
  int v4; // esi@0
  __int16 v5; // fps@0
  struct _TEB *v6; // edx@1
  PVOID v7; // eax@1
  PVOID v8; // ebx@4
  PVOID v9; // esi@4
  void *v11; // ebx@4
  int v12; // ebx@4
  void *v13; // edi@4
  int v14; // edi@10
  int v15; // esi@10
  int v16; // ebp@10
  int v17; // ebx@10
  void *retaddr; // [sp+0h] [bp+0h]@4

  v6 = NtCurrentTeb();
  v7 = v6->Reserved1[4];
  *((_DWORD *)v7 + 46) = v1;
  *((_DWORD *)v7 + 44) = v3;
  *((_DWORD *)v7 + 45) = v4;
  *((_DWORD *)v7 + 50) = v2;
  if ( *((_DWORD *)v7 + 5) == 65551 )
  {
    *((_WORD *)v7 + 26) = v5;
    if ( v7FFE027A == 1 )
      *((_DWORD *)v7 + 10) = _mm_getcsr();
  }
  *((_DWORD *)v7 + 54) = &retaddr;
  *((_DWORD *)v7 + 186) = v6[1].Reserved1[7];
  *((_DWORD *)v7 + 185) = v6->Reserved2[93];
  v8 = v6->Reserved1[2];
  v9 = v6->Reserved5[24];
  *((_DWORD *)v7 + 1) = v6->Reserved1[0];
  *((_DWORD *)v7 + 3) = v8;
  *((_DWORD *)v7 + 187) = v9;
  _ECX = lpFiber;
  v6->Reserved1[4] = lpFiber;
  v11 = (void *)*((_DWORD *)lpFiber + 2);
  v6->Reserved1[0] = (PVOID)*((_DWORD *)lpFiber + 1);
  v6->Reserved1[1] = v11;
  v12 = *((_DWORD *)lpFiber + 4);
  v13 = (void *)*((_DWORD *)lpFiber + 187);
  v6->Reserved1[2] = (PVOID)*((_DWORD *)lpFiber + 3);
  *(_DWORD *)&v6->Reserved3[1948] = v12;
  v6->Reserved5[24] = v13;
  BYTE3(v6[1].ProcessEnvironmentBlock) &= 0xFDu;
  LOBYTE(v12) = *((_BYTE *)lpFiber + 753);
  v6->Reserved2[93] = (PVOID)*((_DWORD *)lpFiber + 185);
  BYTE3(v6[1].ProcessEnvironmentBlock) |= v12;
  if ( *((_DWORD *)lpFiber + 5) == 65551 )
  {
    if ( (unsigned __int16)*((_DWORD *)v7 + 13) != *((_WORD *)lpFiber + 26)
      || (unsigned __int16)*((_DWORD *)v7 + 12) != *((_WORD *)lpFiber + 24) )
    {
      *((_WORD *)lpFiber + 28) = -1;
      __asm { fldenv  byte ptr [ecx+30h] }
    }
    if ( v7FFE027A == 1 )
      _mm_setcsr(*((_DWORD *)lpFiber + 10));
  }
  v14 = *((_DWORD *)lpFiber + 44);
  v15 = *((_DWORD *)lpFiber + 45);
  v16 = *((_DWORD *)lpFiber + 50);
  v17 = *((_DWORD *)lpFiber + 46);
  v6[1].Reserved1[7] = (PVOID)*((_DWORD *)lpFiber + 186);
}

//----- (77E2C2C0) --------------------------------------------------------
int __stdcall _ResourceCallEnumLangRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4, int a5, int a6)
{
  return a1(a2, a3, a4, a5, a6);
}

//----- (77E2C2E4) --------------------------------------------------------
int __stdcall _ResourceCallEnumNameRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD), int a2, int a3, int a4, int a5)
{
  return a1(a2, a3, a4, a5);
}

//----- (77E2C304) --------------------------------------------------------
int __stdcall _ResourceCallEnumTypeRoutine(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3, int a4)
{
  return a1(a2, a3, a4);
}

//----- (77E2C326) --------------------------------------------------------
void __stdcall SleepStub(DWORD dwMilliseconds)
{
  Sleep(dwMilliseconds);
}

//----- (77E2C352) --------------------------------------------------------
BOOL __stdcall ReleaseMutexStub(HANDLE hMutex)
{
  return ReleaseMutex(hMutex);
}

//----- (77E2C370) --------------------------------------------------------
DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
{
  return WaitForSingleObjectExImplementation(hHandle, dwMilliseconds, 0);
}

//----- (77E2C390) --------------------------------------------------------
DWORD __stdcall WaitForSingleObjectExImplementation(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
{
  PVOID v3; // eax@1
  HANDLE v4; // esi@4

  v3 = hHandle;
  if ( hHandle == (HANDLE)-12 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hHandle == (HANDLE)-11 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hHandle == (HANDLE)-10 )
  {
    v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  v4 = v3;
  if ( ((unsigned int)v3 & 0x10000003) == 3 && VerifyConsoleIoHandle((int)v3) )
    v4 = GetConsoleInputWaitHandle();
  return WaitForSingleObjectEx(v4, dwMilliseconds, bAlertable);
}

//----- (77E2C3F0) --------------------------------------------------------
LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend)
{
  return _InterlockedIncrement(lpAddend);
}

//----- (77E2C404) --------------------------------------------------------
LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend)
{
  return _InterlockedDecrement(lpAddend);
}

//----- (77E2C418) --------------------------------------------------------
LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value)
{
  LONG result; // eax@1

  result = *Target;
  do
    result = _InterlockedCompareExchange(Target, Value, result);
  while ( result != Value );
  return result;
}

//----- (77E2C42C) --------------------------------------------------------
LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand)
{
  return _InterlockedCompareExchange(Destination, Exchange, Comperand);
}

//----- (77E2C440) --------------------------------------------------------
LONG __stdcall InterlockedExchangeAdd(volatile LONG *Addend, LONG Value)
{
  return _InterlockedExchangeAdd(Addend, Value);
}

//----- (77E2C460) --------------------------------------------------------
LONG __stdcall InterlockedIncrementStub(volatile LONG *lpAddend)
{
  return InterlockedIncrement(lpAddend);
}

//----- (77E2C470) --------------------------------------------------------
BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
  return RtlFreeHeap(hHeap, dwFlags, lpMem);
}

//----- (77E2C490) --------------------------------------------------------
LONG __stdcall InterlockedDecrementStub(volatile LONG *lpAddend)
{
  return InterlockedDecrement(lpAddend);
}

//----- (77E2C4AB) --------------------------------------------------------
LONG __stdcall InterlockedCompareExchangeStub(volatile LONG *Destination, LONG Exchange, LONG Comperand)
{
  return InterlockedCompareExchange(Destination, Exchange, Comperand);
}

//----- (77E2C4D2) --------------------------------------------------------
BOOL __stdcall QueryPerformanceCounterStub(LARGE_INTEGER *lpPerformanceCount)
{
  return QueryPerformanceCounter(lpPerformanceCount);
}

//----- (77E2C4EA) --------------------------------------------------------
LPVOID __stdcall VirtualAllocStub(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
{
  return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

//----- (77E2C502) --------------------------------------------------------
LONG __stdcall InterlockedExchangeStub(volatile LONG *Target, LONG Value)
{
  return InterlockedExchange(Target, Value);
}

//----- (77E2C51D) --------------------------------------------------------
void __stdcall BasepAdjustObjectAttributesForPrivateNamespace(int a1)
{
  int v1; // eax@3
  int i; // edi@11

  if ( BaseUsePrivateNamespaces && *(_DWORD *)(a1 + 8) && *(_DWORD *)(a1 + 4) )
  {
    RtlAcquireSRWLockShared(&BasePrivatenamespaceLock);
    if ( BasePrefixLastHint
      && RtlPrefixUnicodeString((PCUNICODE_STRING)(BasePrefixLastHint + 8), *(PCUNICODE_STRING *)(a1 + 8), 1u)
      && (v1 = BasePrefixLastHint) != 0 )
    {
LABEL_4:
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v1 + 16);
      *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) += 2 * ((unsigned int)*(_WORD *)(v1 + 8) >> 1);
      **(_WORD **)(a1 + 8) -= *(_WORD *)(v1 + 8);
      *(_WORD *)(*(_DWORD *)(a1 + 8) + 2) -= *(_WORD *)(v1 + 8);
    }
    else
    {
      for ( i = BasePrefixList; (int *)i != &BasePrefixList; i = *(_DWORD *)i )
      {
        if ( RtlPrefixUnicodeString((PCUNICODE_STRING)(i + 8), *(PCUNICODE_STRING *)(a1 + 8), 1u) )
        {
          BasePrefixLastHint = i;
          v1 = i;
          if ( !i )
            break;
          goto LABEL_4;
        }
      }
    }
    RtlReleaseSRWLockShared(&BasePrivatenamespaceLock);
  }
}
// 77DE12F8: using guessed type int __stdcall RtlAcquireSRWLockShared(_DWORD);
// 77DE12FC: using guessed type int __stdcall RtlReleaseSRWLockShared(_DWORD);
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA652C: using guessed type int BasePrefixLastHint;
// 77EA6530: using guessed type char BaseUsePrivateNamespaces;
// 77EA6794: using guessed type int BasePrivatenamespaceLock;

//----- (77E2C555) --------------------------------------------------------
signed int __stdcall Basep8BitStringToDynamicUnicodeString(int a1, PCSZ SourceString)
{
  int v2; // eax@2
  NTSTATUS v3; // eax@2
  STRING DestinationString; // [sp+0h] [bp-8h]@1

  if ( RtlInitAnsiStringEx(&DestinationString, SourceString) < 0 )
    goto LABEL_11;
  v2 = KernelBaseGetGlobalData();
  v3 = (*(int (__stdcall **)(int, STRING *, signed int))(v2 + 24))(a1, &DestinationString, 1);
  if ( v3 >= 0 )
    return 1;
  if ( v3 == -2147483643 )
LABEL_11:
    RtlSetLastWin32Error(206);
  else
    BaseSetLastNTError(v3);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2CCAC) --------------------------------------------------------
HLOCAL __stdcall WTSFreeMemory(HLOCAL hMem)
{
  return LocalFree(hMem);
}

//----- (77E2CD16) --------------------------------------------------------
HLOCAL __stdcall LocalAllocStub(UINT uFlags, SIZE_T uBytes)
{
  return LocalAlloc(uFlags, uBytes);
}

//----- (77E2CD44) --------------------------------------------------------
FARPROC __stdcall GetProcAddressStub(HMODULE hModule, LPCSTR lpProcName)
{
  return GetProcAddress(hModule, lpProcName);
}

//----- (77E2CD5C) --------------------------------------------------------
HMODULE __stdcall GetModuleHandleWStub(LPCWSTR lpModuleName)
{
  return GetModuleHandleW(lpModuleName);
}

//----- (77E2CD69) --------------------------------------------------------
#error "77E151A2: positive sp value has been found (funcsize=47)"

//----- (77E2CDF1) --------------------------------------------------------
bool __stdcall RegKrnInitialize(int a1, int a2, int a3)
{
  int v4; // eax@15
  int v5; // eax@17

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      if ( !g_Initialized )
        InitializeRegWow64Flags();
      InterlockedIncrement(&g_Initialized);
    }
    else if ( a2 == 3 && dword_77EA6738 )
    {
      return CleanupClassesEnumTable(1);
    }
    return 1;
  }
  InterlockedDecrement(&g_Initialized);
  if ( g_Initialized )
    return 1;
  if ( a3 || CleanupPredefinedHandles() )
  {
    if ( Handle )
    {
      NtClose(Handle);
      Handle = 0;
    }
    LOBYTE(v4) = CleanupPredefinedHandlesTable();
    if ( v4 )
    {
      if ( CleanupPerAppKey() )
      {
        LOBYTE(v5) = CleanupClassesEnumTable(0);
        if ( v5 )
          return 1;
      }
    }
  }
  return 0;
}
// 77EA6738: using guessed type int dword_77EA6738;

//----- (77E2CE1F) --------------------------------------------------------
BOOL __stdcall BaseDllInitialize(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  if ( fdwReason == 1 )
    _DllMainCRTStartupForGS2(hinstDLL, 1, lpReserved);
  return _BaseDllInitialize(hinstDLL, fdwReason, lpReserved);
}
// 77E2E685: using guessed type _DWORD __stdcall _DllMainCRTStartupForGS2(_DWORD, _DWORD, _DWORD);

//----- (77E2CE39) --------------------------------------------------------
char __thiscall ConDllInitialize(int this, int a2, int a3)
{
  NTSTATUS v4; // eax@9
  char v5; // [sp+7h] [bp-629h]@9
  char Dst; // [sp+8h] [bp-628h]@7
  void *v7; // [sp+Ch] [bp-624h]@13
  char v8; // [sp+FCh] [bp-534h]@11

  if ( a2 != 1 )
  {
    if ( a2 != 2 || !gbConsoleApp )
      return 1;
    goto LABEL_4;
  }
  if ( RtlInitializeCriticalSection(&DllLock) >= 0 )
  {
    InitializeConsoleConnectionInfo(&Dst);
    InitializeCtrlHandling();
    v4 = ConnectConsoleInternal(a3, (int)&Dst, (int)&v5);
    this = 0;
    if ( v4 >= 0 )
    {
      if ( v5 || !v8 )
        return 1;
      if ( !NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
        SetUpHandles((int)&Dst);
      InputWaitHandle = v7;
LABEL_4:
      SetTEBLangID(this);
      return 1;
    }
    _DbgPrintEx(0x70u, 1u, "ConnectConsoleInternal failed with Status 0x%x\n", v4);
  }
  return 0;
}
// 77EA6541: using guessed type char gbConsoleApp;

//----- (77E2CE9A) --------------------------------------------------------
int __stdcall RegKrnGetGlobalState()
{
  return (int)g_RegKrnGlobalState;
}
// 77EA6698: using guessed type int g_RegKrnGlobalState[36];

//----- (77E2CEA5) --------------------------------------------------------
int __stdcall MapPredefinedHandleInternal(int a1, int a2, PHANDLE KeyHandle, int a4)
{
  int v4; // eax@10
  HKEY v5; // esi@10
  int v6; // ecx@1
  int v7; // ebx@1
  int v9; // esi@11
  int v10; // esi@13
  HKEY *v11; // edi@14
  int v12; // ebx@16
  PVOID v13; // eax@24
  int v14; // eax@25
  HKEY v15; // eax@27
  int v17; // [sp+Ch] [bp-4h]@1
  int v18; // [sp+24h] [bp+14h]@12
  int v19; // [sp+24h] [bp+14h]@13

  v6 = a1;
  v7 = a4;
  *KeyHandle = 0;
  v17 = 0;
  *(_DWORD *)a4 = 0;
  if ( a1 == -1 || !a1 )
    return 6;
  if ( a1 >= 0 || (v9 = MapPredefinedRegistryHandleToIndex(a1), v9 == -1) )
  {
    if ( a2 )
      *(_DWORD *)a2 = v6;
    return 0;
  }
  v18 = RtlRunOnceExecuteOnce(
          &PredefinedHandleTableCriticalSectionInit,
          (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
          0,
          0);
  RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
  if ( v18 < 0 )
    return 8;
  v19 = RtlGetCurrentTransaction();
  RtlSetCurrentTransaction(0);
  v10 = 4 * v9;
  if ( byte_77EA6B2C[v10 * 4] == 1 )
  {
    v4 = (*(int (__stdcall **)(int, ACCESS_MASK, PHANDLE))((char *)&off_77EA6B28 + v10 * 4))(0, 0x2000000u, KeyHandle);
    v5 = (HKEY)*KeyHandle;
    v17 = v4;
  }
  else
  {
    v11 = (HKEY *)&PredefinedHandleTable[v10];
    if ( PredefinedHandleTable[v10] )
    {
      *(_DWORD *)v7 = dword_77EA6B24[v10];
    }
    else
    {
      v17 = (*(int (__stdcall **)(int, ACCESS_MASK, PHANDLE))((char *)&off_77EA6B28 + v10 * 4))(
              0,
              0x2000000u,
              (PHANDLE)&PredefinedHandleTable[v10]);
      if ( !v17 && *v11 )
      {
        v13 = AllocatePredefinedHandleUnit((int)&PredefinedHandleTable[v10]);
        *(_DWORD *)v7 = v13;
        if ( v13 )
        {
          *(_DWORD *)v13 = *v11;
          v14 = *(_DWORD *)v7;
          *(_DWORD *)(v14 + 12) = dword_77EA6B24[v10];
          dword_77EA6B24[v10] = v14;
        }
        else
        {
          v15 = *v11;
          if ( *v11 != HKEY_CLASSES_ROOT
            && v15 != HKEY_CURRENT_USER
            && v15 != HKEY_LOCAL_MACHINE
            && v15 != HKEY_PERFORMANCE_DATA
            && v15 != HKEY_PERFORMANCE_TEXT
            && v15 != HKEY_PERFORMANCE_NLSTEXT
            && v15 != HKEY_USERS
            && v15 != HKEY_CURRENT_CONFIG
            && v15 != HKEY_DYN_DATA
            && v15 != HKEY_CURRENT_USER_LOCAL_SETTINGS )
            RegCloseKey(*v11);
          *v11 = 0;
          v17 = 8;
        }
      }
    }
    v12 = *(_DWORD *)v7;
    v5 = *v11;
    if ( v12 )
      ++*(_DWORD *)(v12 + 4);
  }
  RtlSetCurrentTransaction(v19);
  RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
  if ( !v17 && a2 )
    *(_DWORD *)a2 = v5;
  return v17;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);
// 77EA6B20: using guessed type int PredefinedHandleTable[];
// 77EA6B24: using guessed type int dword_77EA6B24[];
// 77EA6B28: using guessed type int (__stdcall *off_77EA6B28)(int, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);

//----- (77E2CEF0) --------------------------------------------------------
ULONG __stdcall LocalBaseRegOpenKey(HANDLE KeyHandle, PCUNICODE_STRING Source, int a3, int a4, ULONG ResultLength, int a6)
{
  int v6; // esi@1
  int v7; // ebx@4
  int v8; // edi@5
  int v9; // edi@7
  int v10; // eax@8
  int v11; // edi@9
  ULONG result; // eax@13
  NTSTATUS v13; // eax@28
  char KeyInformation; // [sp+10h] [bp-68h]@16
  int v15; // [sp+24h] [bp-54h]@17
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+38h] [bp-40h]@5
  int v17; // [sp+50h] [bp-28h]@1
  PWCH v18; // [sp+54h] [bp-24h]@1
  int (__stdcall *v19)(int, int, OBJECT_ATTRIBUTES *); // [sp+5Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+60h] [bp-18h]@5

  v6 = (int)Source;
  v17 = *(_DWORD *)&Source->Length;
  v18 = Source->Buffer;
  v19 = *(int (__stdcall **)(int, int, OBJECT_ATTRIBUTES *))(RegKrnGetGlobalState() + 4);
  if ( *(_WORD *)v6 >= 2u && !(*(_WORD *)v6 & 1) && *(_DWORD *)(v6 + 4) && (v7 = ResultLength) != 0 )
  {
    *(_DWORD *)ResultLength = 0;
    ms_exc.registration.TryLevel = -2;
    *(_WORD *)v6 -= 2;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = KeyHandle;
    v8 = a3;
    ObjectAttributes.Attributes = 32 * (a3 & 8 | 2);
    ObjectAttributes.ObjectName = (PUNICODE_STRING)v6;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( (unsigned __int8)KeyHandle & 2
      || *(_BYTE *)(RegKrnGetGlobalState() + 36) & 2 && ExtractClassKey(&KeyHandle, v6, a6) )
    {
      v11 = BaseRegOpenClassKey(KeyHandle, (PCUNICODE_STRING)v6, v8, a4, v7, a6);
    }
    else
    {
      v9 = v8 & 0xC;
      if ( a6 )
        v10 = NtOpenKeyTransactedEx(v7, a4, &ObjectAttributes, v9, a6);
      else
        v10 = NtOpenKeyEx(v7, a4, &ObjectAttributes, v9);
      v11 = v10;
      if ( v10 == 1073741846 )
      {
        v11 = NtQueryKey(*(HANDLE *)v7, KeyCachedInformation, &KeyInformation, 0x28u, &ResultLength);
        NtClose(*(HANDLE *)v7);
        if ( v11 >= 0 )
          *(_DWORD *)v7 = v15;
      }
    }
    ResultLength = RtlNtStatusToDosError(v11);
    if ( v11 == -1073741790 && *(_BYTE *)(RegKrnGetGlobalState() + 36) & 1 )
    {
      if ( (unsigned __int8)KeyHandle & 2 )
      {
        v13 = BaseRegOpenClassKey(KeyHandle, (PCUNICODE_STRING)v6, a3, a4 & 0x1000300 | 0x2000000, v7, a6);
      }
      else if ( a6 )
      {
        v13 = NtOpenKeyTransacted(v7, a4 & 0x1000300 | 0x2000000, &ObjectAttributes, a6);
      }
      else
      {
        v13 = NtOpenKey((PHANDLE)v7, a4 & 0x1000300 | 0x2000000, &ObjectAttributes);
      }
      v11 = v13;
      if ( v13 < 0 )
        v11 = -1073741790;
      ResultLength = RtlNtStatusToDosError(v11);
    }
    if ( !((unsigned __int8)KeyHandle & 2) && v11 < 0 && v19 )
    {
      if ( v19(v7, a4, &ObjectAttributes) )
        ResultLength = RtlNtStatusToDosError(0);
    }
    *(_DWORD *)v6 = v17;
    *(_DWORD *)(v6 + 4) = v18;
    result = ResultLength;
  }
  else
  {
    result = 87;
  }
  return result;
}
// 77DE1694: using guessed type int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE169C: using guessed type int __stdcall NtOpenKeyEx(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE16A0: using guessed type int __stdcall NtOpenKeyTransactedEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2D021) --------------------------------------------------------
LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
  int v5; // eax@1

  v5 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY, _DWORD))(v5 + 196))(
           hKey,
           lpSubKey,
           ulOptions,
           samDesired,
           phkResult,
           0);
}

//----- (77E2D04B) --------------------------------------------------------
LSTATUS __stdcall RegOpenKeyExInternalW(HKEY hKey, int a2, int a3, int a4, ULONG ResultLength, int a6)
{
  HKEY v6; // eax@1
  ULONG v7; // edx@4
  const WCHAR *v8; // edi@5
  HKEY v9; // esi@14
  int v10; // eax@14
  int v11; // esi@14
  NTSTATUS v12; // eax@15
  ULONG v13; // eax@17
  int v14; // edi@19
  int v15; // ebx@19
  int v16; // eax@19
  LSTATUS result; // eax@19
  HKEY v18; // esi@30
  int v19; // eax@30
  unsigned int v20; // esi@36
  int (__stdcall *v21)(_DWORD, _DWORD); // eax@36
  bool v22; // al@39
  int v23; // ecx@41
  UNICODE_STRING Source; // [sp+10h] [bp-38h]@15
  int v26; // [sp+18h] [bp-30h]@46
  WCHAR SourceString[2]; // [sp+20h] [bp-28h]@21
  int (__stdcall *v28)(unsigned int, UNICODE_STRING *, int, int, ULONG); // [sp+24h] [bp-24h]@1
  int v29; // [sp+28h] [bp-20h]@1
  int v30; // [sp+2Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@46

  v29 = 0;
  v30 = 0;
  v28 = *(int (__stdcall **)(unsigned int, UNICODE_STRING *, int, int, ULONG))(RegKrnGetGlobalState() + 92);
  v6 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA || hKey == HKEY_PERFORMANCE_TEXT || hKey == HKEY_PERFORMANCE_NLSTEXT )
    return 6;
  v7 = ResultLength;
  if ( !ResultLength )
    return 87;
  *(_DWORD *)ResultLength = 0;
  v8 = (const WCHAR *)a2;
  if ( !a2 )
  {
    *(_DWORD *)SourceString = 0;
    v8 = SourceString;
  }
  if ( v6 != HKEY_CLASSES_ROOT
    && v6 != HKEY_CURRENT_USER
    && v6 != HKEY_LOCAL_MACHINE
    && v6 != HKEY_USERS
    && v6 != HKEY_CURRENT_CONFIG
    && v6 != HKEY_DYN_DATA
    && v6 != HKEY_CURRENT_USER_LOCAL_SETTINGS
    || a4 & 0x300
    || v8 && *v8 )
  {
    if ( !v8 )
    {
      v11 = 1010;
      goto LABEL_19;
    }
    v9 = v6;
    v10 = RegKrnGetGlobalState();
    v11 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v10 + 176))(v9, &hKey, &v29, &v30);
    if ( v11 )
      goto LABEL_19;
    v12 = RtlInitUnicodeStringEx(&Source, v8);
    if ( v12 < 0 )
    {
      v13 = RtlNtStatusToDosError(v12);
      goto LABEL_18;
    }
    Source.Length += 2;
    if ( !((unsigned __int8)hKey & 1) )
    {
      v13 = LocalBaseRegOpenKey(hKey, &Source, a3, a4, ResultLength, a6);
LABEL_18:
      v11 = v13;
      goto LABEL_19;
    }
    if ( !v28 )
      goto LABEL_19;
    a2 = 0;
    v20 = (unsigned int)hKey & 0xFFFFFFFE;
    v21 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
    v22 = v21 && !v21(v20, &a2) && a2 == 6;
    v23 = a4;
    if ( !(a4 & 0x300) )
    {
      if ( !v22 )
      {
LABEL_45:
        v23 &= 0xFFFFFCFF;
LABEL_46:
        ms_exc.registration.TryLevel = 0;
        v11 = v28((unsigned int)hKey & 0xFFFFFFFE, &Source, a3, v23, ResultLength);
        v26 = v11;
        ms_exc.registration.TryLevel = -2;
        if ( !v11 )
          *(_DWORD *)ResultLength |= 1u;
        goto LABEL_19;
      }
      v23 = a4 | 0x200;
    }
    if ( v22 )
      goto LABEL_46;
    goto LABEL_45;
  }
  if ( v6 == HKEY_CLASSES_ROOT )
  {
LABEL_32:
    *(_DWORD *)v7 = v6;
    v11 = 0;
    goto LABEL_19;
  }
  result = RegCloseKey(v6);
  if ( !result )
  {
    v18 = hKey;
    v19 = RegKrnGetGlobalState();
    v11 = (*(int (__stdcall **)(HKEY, _DWORD, int *, int *))(v19 + 176))(v18, 0, &v29, &v30);
    if ( !v11 )
    {
      v6 = hKey;
      v7 = ResultLength;
      goto LABEL_32;
    }
LABEL_19:
    v14 = v30;
    v15 = v29;
    v16 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v16 + 168))(v15, v14);
    result = v11;
  }
  return result;
}

//----- (77E2D199) --------------------------------------------------------
int __stdcall MapPredefinedRegistryHandleToIndex(unsigned int a1)
{
  signed int v2; // [sp-4h] [bp-4h]@5

  if ( a1 < 0x80000000 )
    return -1;
  if ( a1 <= 0x80000004 )
    return a1 & 0x7FFFFFFF;
  if ( a1 == -2147483643 )
  {
    v2 = 7;
  }
  else
  {
    if ( a1 != -2147483642 )
    {
      if ( a1 == -2147483641 )
        return 9;
      if ( a1 == -2147483568 )
        return 5;
      if ( a1 == -2147483552 )
        return 6;
      return -1;
    }
    v2 = 8;
  }
  return v2;
}

//----- (77E2D2DD) --------------------------------------------------------
int __stdcall LocalBaseRegQueryValue(HANDLE a1, PUNICODE_STRING ValueName, int a3, int a4, int a5, int a6)
{
  int (__stdcall *v6)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // eax@37
  NTSTATUS v7; // eax@56
  int v8; // edx@2
  HANDLE v9; // eax@17
  ULONG v10; // ebx@19
  HANDLE i; // [sp-18h] [bp-E8h]@16
  UNICODE_STRING *v13; // [sp-14h] [bp-E4h]@16
  int v14; // [sp-10h] [bp-E0h]@16
  char *v15; // [sp-Ch] [bp-DCh]@16
  ULONG *v17; // [sp-4h] [bp-D4h]@16
  ULONG Size; // [sp+18h] [bp-B8h]@16
  int v19; // [sp+1Ch] [bp-B4h]@1
  int v20; // [sp+20h] [bp-B0h]@2
  int v21; // [sp+24h] [bp-ACh]@1
  HANDLE Handle; // [sp+28h] [bp-A8h]@1
  HANDLE KeyHandle; // [sp+2Ch] [bp-A4h]@1
  void *Dst; // [sp+30h] [bp-A0h]@1
  ULONG KeyValueInformationLength; // [sp+34h] [bp-9Ch]@15
  NTSTATUS NtStatus; // [sp+38h] [bp-98h]@17
  char KeyValueInformation; // [sp+3Ch] [bp-94h]@15
  unsigned int v28; // [sp+44h] [bp-8Ch]@48

  v19 = a3;
  Dst = (void *)a4;
  v21 = 0;
  Handle = 0;
  KeyHandle = a1;
  if ( !ValueName )
    goto LABEL_79;
  v8 = ValueName->Length;
  v20 = v8;
  if ( !(_WORD)v8 || v8 & 1 )
    goto LABEL_79;
  if ( !ValueName->Buffer )
  {
LABEL_53:
    if ( ValueName->Length == 2 && !ValueName->MaximumLength )
      goto LABEL_8;
    return 87;
  }
  if ( !a5 || !a6 || !v19 )
  {
LABEL_79:
    if ( ValueName->Buffer )
      return 87;
    goto LABEL_53;
  }
LABEL_8:
  if ( a5 && !Dst )
    *(_DWORD *)a5 = 0;
  if ( a1 == (HANDLE)-2147483644 || a1 == (HANDLE)-2147483568 || a1 == (HANDLE)-2147483552 )
  {
    v6 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 60);
    if ( v6 )
      return v6(a1, ValueName, 0, v19, Dst, a5, a6);
    return 87;
  }
  if ( ValueName->Length > 0u )
    ValueName->Length -= 2;
  v20 = a5 != 0 ? 2 : 0;
  KeyValueInformationLength = (ULONG)&KeyValueInformation;
  if ( (unsigned __int8)a1 & 2 )
  {
    v7 = BaseRegGetUserAndMachineClass(0, a1, 0x2000000, (int)&Handle, (int)&v21);
    if ( v7 < 0 )
      return RtlNtStatusToDosError(v7);
    if ( v21 && Handle )
      KeyHandle = (HANDLE)v21;
  }
  v17 = &Size;
  v15 = &KeyValueInformation;
  v14 = a5 != 0 ? 2 : 0;
  v13 = ValueName;
  for ( i = KeyHandle; ; i = Handle )
  {
    NtStatus = NtQueryValueKey(i, v13, (KEY_VALUE_INFORMATION_CLASS)v14, v15, 0x90u, v17);
    v9 = Handle;
    if ( !v21 || !Handle || KeyHandle == Handle || NtStatus != -1073741772 )
      break;
    v17 = &Size;
    v15 = &KeyValueInformation;
    v14 = v20;
    KeyHandle = Handle;
    v13 = ValueName;
  }
  if ( NtStatus != -2147483643 )
    goto LABEL_19;
  if ( !Dst )
  {
    NtStatus = 0;
LABEL_19:
    v10 = KeyValueInformationLength;
    goto LABEL_20;
  }
  if ( v20 != 2 || *(_DWORD *)a5 < v28 )
    goto LABEL_19;
  KeyValueInformationLength = Size;
  v10 = (ULONG)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
  if ( !v10 )
    return 14;
  NtStatus = NtQueryValueKey(
               KeyHandle,
               ValueName,
               KeyValuePartialInformation,
               (PVOID)v10,
               KeyValueInformationLength,
               &Size);
  v9 = Handle;
LABEL_20:
  if ( v21 && v9 )
  {
    if ( (HANDLE)v21 == a1 )
      NtClose(v9);
    else
      NtClose((HANDLE)v21);
  }
  if ( NtStatus >= 0 )
  {
    if ( Dst )
    {
      if ( *(_DWORD *)a5 < *(_DWORD *)(v10 + 8) )
        NtStatus = -2147483643;
      else
        memmove(Dst, (const void *)(v10 + 12), *(_DWORD *)(v10 + 8));
    }
    if ( NtStatus >= 0 )
      goto LABEL_80;
  }
  if ( NtStatus == -2147483643 )
  {
LABEL_80:
    if ( v20 )
    {
      if ( v19 )
        *(_DWORD *)v19 = *(_DWORD *)(v10 + 4);
      *(_DWORD *)a5 = *(_DWORD *)(v10 + 8);
    }
    else if ( v19 )
    {
      *(_DWORD *)v19 = *(_DWORD *)(v10 + 4);
    }
  }
  if ( a6 )
  {
    if ( NtStatus >= 0 && Dst )
      *(_DWORD *)a6 = *(_DWORD *)(v10 + 8);
    else
      *(_DWORD *)a6 = 0;
  }
  if ( (char *)v10 != &KeyValueInformation )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v10);
  return RtlNtStatusToDosError(NtStatus);
}

//----- (77E2D507) --------------------------------------------------------
LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  int (__stdcall *v6)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // edi@1
  int v7; // ebx@2
  HKEY v8; // esi@4
  int v9; // eax@4
  NTSTATUS v10; // eax@5
  LPDWORD v11; // esi@6
  unsigned int v12; // eax@14
  int v13; // esi@19
  int v14; // edi@19
  int v15; // eax@19
  LSA_UNICODE_STRING ValueName; // [sp+10h] [bp-3Ch]@5
  int v18; // [sp+1Ch] [bp-30h]@1
  int v19; // [sp+20h] [bp-2Ch]@1
  int v20; // [sp+24h] [bp-28h]@6
  int v21; // [sp+28h] [bp-24h]@1
  int v22; // [sp+2Ch] [bp-20h]@7
  LSTATUS v23; // [sp+30h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@31

  v21 = 0;
  v18 = 0;
  v19 = 0;
  v6 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 120);
  if ( !lpReserved )
  {
    v7 = (int)lpData;
    if ( !lpData || lpcbData )
    {
      v8 = hKey;
      v9 = RegKrnGetGlobalState();
      v23 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v9 + 176))(v8, &hKey, &v18, &v19);
      if ( !v23 )
      {
        v10 = RtlInitUnicodeStringEx(&ValueName, lpValueName);
        if ( v10 < 0 )
        {
          v23 = RtlNtStatusToDosError(v10);
        }
        else
        {
          ValueName.Length += 2;
          v20 = 0;
          v11 = lpcbData;
          if ( lpcbData )
            v22 = *lpcbData;
          else
            v22 = 0;
          if ( !((unsigned __int8)hKey & 1) )
          {
            v23 = LocalBaseRegQueryValue(hKey, &ValueName, (int)&v21, v7, (int)&v22, (int)&v20);
LABEL_10:
            if ( !v23 && v7 && (v21 == 1 || v21 == 2 || v21 == 7) && (unsigned int)v22 > 2 )
            {
              v12 = v7 + 2 * ((unsigned int)v22 >> 1);
              if ( *(_WORD *)(v12 - 2) )
              {
                if ( v22 + 2 <= *v11 )
                  *(_WORD *)v12 = 0;
              }
            }
            if ( v11 )
              *v11 = v22;
            if ( lpType )
              *lpType = v21;
            goto LABEL_19;
          }
          if ( !v6 )
            goto LABEL_10;
          ms_exc.registration.TryLevel = 0;
          v23 = v6((unsigned int)hKey & 0xFFFFFFFE, &ValueName, &v21, v7, &v22, &v20);
          ms_exc.registration.TryLevel = -2;
          if ( v23 && v23 != 234 || (unsigned int)v22 <= 0x7FFF0000 )
          {
            v11 = lpcbData;
            goto LABEL_10;
          }
          v23 = 13;
        }
      }
LABEL_19:
      v13 = v19;
      v14 = v18;
      v15 = RegKrnGetGlobalState();
      (*(void (__stdcall **)(int, int))(v15 + 168))(v14, v13);
      return v23;
    }
  }
  return 87;
}

//----- (77E2D641) --------------------------------------------------------
void __stdcall CLOSE_LOCAL_HANDLE_INTERNAL(int a1, PVOID Address)
{
  if ( a1 )
    LocalBaseRegCloseKey(&a1);
  if ( Address )
  {
    RtlRunOnceExecuteOnce(
      &PredefinedHandleTableCriticalSectionInit,
      (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
      0,
      0);
    RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
    DereferenceHandleUnit(Address);
    RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
  }
}

//----- (77E2D665) --------------------------------------------------------
ULONG __stdcall LocalBaseRegCloseKey(int *a1)
{
  return BaseRegCloseKeyInternal(a1);
}

//----- (77E2D672) --------------------------------------------------------
ULONG __stdcall BaseRegCloseKeyInternal(int *a1)
{
  int (__stdcall *v1)(_DWORD); // eax@9
  int v2; // eax@12
  int v3; // eax@12
  int v4; // eax@1
  NTSTATUS v5; // eax@5
  ULONG result; // eax@7

  v4 = *a1;
  if ( *a1 == -2147483644 || v4 == -2147483568 || v4 == -2147483552 )
  {
    v1 = *(int (__stdcall **)(_DWORD))(RegKrnGetGlobalState() + 44);
    if ( !v1 )
      return 0;
    result = v1(a1);
  }
  else
  {
    if ( v4 & 2 )
    {
      v2 = RegKrnGetGlobalState();
      v3 = (*(int (**)(void))(v2 + 164))();
      EnumTableRemoveKey(v3, *a1, 2);
    }
    v5 = NtClose((HANDLE)*a1);
    if ( v5 >= 0 )
    {
      *a1 = 0;
      return 0;
    }
    result = RtlNtStatusToDosError(v5);
  }
  return result;
}

//----- (77E2D6C5) --------------------------------------------------------
LSTATUS __stdcall RegCloseKey(HKEY hKey)
{
  int (__stdcall *v1)(_DWORD); // ecx@1
  LSTATUS v2; // esi@13
  int v3; // eax@13

  v1 = *(int (__stdcall **)(_DWORD))(RegKrnGetGlobalState() + 80);
  if ( !hKey )
    return 6;
  if ( hKey == HKEY_CLASSES_ROOT
    || hKey == HKEY_CURRENT_USER
    || hKey == HKEY_LOCAL_MACHINE
    || hKey == HKEY_PERFORMANCE_DATA
    || hKey == HKEY_PERFORMANCE_TEXT
    || hKey == HKEY_PERFORMANCE_NLSTEXT
    || hKey == HKEY_USERS
    || hKey == HKEY_CURRENT_CONFIG
    || hKey == HKEY_DYN_DATA
    || hKey == HKEY_CURRENT_USER_LOCAL_SETTINGS )
    return ClosePredefinedHandle((unsigned int)hKey);
  if ( !((unsigned __int8)hKey & 1) )
  {
    v2 = LocalBaseRegCloseKey((int *)&hKey);
    v3 = RegKrnGetGlobalState();
    (*(void (**)(void))(v3 + 152))();
    return v2;
  }
  if ( !v1 )
    return 87;
  hKey = (HKEY)((unsigned int)hKey & 0xFFFFFFFE);
  return v1(&hKey);
}

//----- (77E2D7A1) --------------------------------------------------------
void __stdcall PoolPerAppKeyStateInternal()
{
  char EventInformation; // [sp+4h] [bp-8h]@3
  int v1; // [sp+8h] [bp-4h]@4

  if ( dword_77EA672C )
  {
    RtlRunOnceExecuteOnce(&g_ProcessAppKeyEventInit, (PRTL_RUN_ONCE_INIT_FN)ProcessAppKeyEventInitFn, 0, 0);
    if ( NtQueryEvent(g_ProcessAppKeyEvent, 0, &EventInformation, 8u, 0) >= 0 && v1 == 1 )
    {
      NtResetEvent(g_ProcessAppKeyEvent, 0);
      InterlockedCompareExchange(&dword_77EA672C, 0, 1);
    }
  }
}

//----- (77E2D7F2) --------------------------------------------------------
DWORD __stdcall GetEnvironmentVariableAStub(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
{
  return GetEnvironmentVariableA(lpName, lpBuffer, nSize);
}

//----- (77E2D80A) --------------------------------------------------------
DWORD __stdcall GetModuleFileNameAStub(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
{
  return GetModuleFileNameA(hModule, lpFilename, nSize);
}

//----- (77E2D86C) --------------------------------------------------------
HANDLE __stdcall CreateEventWStub(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
{
  return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
}

//----- (77E2D884) --------------------------------------------------------
HANDLE __stdcall CreateMutexAStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
{
  return CreateMutexA(lpMutexAttributes, bInitialOwner, lpName);
}

//----- (77E2D89C) --------------------------------------------------------
LPVOID __stdcall MapViewOfFileExStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
{
  return MapViewOfFileEx(
           hFileMappingObject,
           dwDesiredAccess,
           dwFileOffsetHigh,
           dwFileOffsetLow,
           dwNumberOfBytesToMap,
           lpBaseAddress);
}

//----- (77E2D8C6) --------------------------------------------------------
void __stdcall GetSystemTimeAsFileTimeStub(LPFILETIME lpSystemTimeAsFileTime)
{
  GetSystemTimeAsFileTime(lpSystemTimeAsFileTime);
}

//----- (77E2D913) --------------------------------------------------------
void __stdcall DereferenceHandleUnit(PVOID Address)
{
  bool v1; // zf@1

  v1 = (*((_DWORD *)Address + 1))-- == 1;
  if ( v1 && *(_DWORD *)Address != **((_DWORD **)Address + 2) )
  {
    RegCloseKey(*(HKEY *)Address);
    *(_DWORD *)(*((_DWORD *)Address + 2) + 4) = RemoveUnitFromList(
                                                  *(_DWORD *)(*((_DWORD *)Address + 2) + 4),
                                                  (int)Address);
    FreePredefinedHandleUnit(Address);
  }
}

//----- (77E2D938) --------------------------------------------------------
BOOL __stdcall DuplicateHandleImplementation(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
{
  PVOID v7; // eax@1
  signed int v9; // eax@11

  v7 = hSourceHandle;
  if ( hSourceHandle == (HANDLE)-12 )
  {
    v7 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hSourceHandle == (HANDLE)-11 )
  {
    v7 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hSourceHandle == (HANDLE)-10 )
  {
    v7 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v7 & 0x10000003) != 3 || v7 == (PVOID)-1 || v7 == (PVOID)-2 )
    return DuplicateHandle(
             hSourceProcessHandle,
             v7,
             hTargetProcessHandle,
             lpTargetHandle,
             dwDesiredAccess,
             bInheritHandle,
             dwOptions);
  if ( hSourceProcessHandle != (HANDLE)-1 || hTargetProcessHandle != (HANDLE)-1 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v9 = DuplicateConsoleHandle((int)v7, dwDesiredAccess, bInheritHandle, dwOptions);
  if ( v9 == -1 )
    return 0;
  if ( lpTargetHandle )
    *lpTargetHandle = (HANDLE)v9;
  return 1;
}

//----- (77E2D9A3) --------------------------------------------------------
HMODULE __stdcall GetModuleHandleAStub(LPCSTR lpModuleName)
{
  return GetModuleHandleA(lpModuleName);
}

//----- (77E2D9CD) --------------------------------------------------------
LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
  int v5; // eax@1

  v5 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY, _DWORD))(v5 + 192))(
           hKey,
           lpSubKey,
           ulOptions,
           samDesired,
           phkResult,
           0);
}

//----- (77E2D9F7) --------------------------------------------------------
LSTATUS __stdcall RegOpenKeyExInternalA(HKEY hKey, int a2, int a3, int a4, ULONG ResultLength, int a6)
{
  HKEY v6; // eax@1
  const char *v7; // edi@5
  HKEY v8; // esi@13
  int v9; // eax@13
  ULONG v10; // esi@13
  int v11; // edi@18
  int v12; // ebx@18
  int v13; // eax@18
  LSTATUS result; // eax@18
  HKEY v15; // esi@32
  int v16; // eax@32
  unsigned int v17; // esi@37
  int (__stdcall *v18)(_DWORD, _DWORD); // eax@37
  bool v19; // al@40
  int v20; // ecx@42
  LSA_UNICODE_STRING Destination; // [sp+10h] [bp-38h]@14
  ULONG v23; // [sp+18h] [bp-30h]@47
  int (__stdcall *v24)(unsigned int, LSA_UNICODE_STRING *, int, int, ULONG); // [sp+20h] [bp-28h]@1
  int v25; // [sp+24h] [bp-24h]@1
  int v26; // [sp+28h] [bp-20h]@1
  char Source; // [sp+2Fh] [bp-19h]@25
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@47

  v25 = 0;
  v26 = 0;
  v24 = *(int (__stdcall **)(unsigned int, LSA_UNICODE_STRING *, int, int, ULONG))(RegKrnGetGlobalState() + 92);
  v6 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA || hKey == HKEY_PERFORMANCE_TEXT || hKey == HKEY_PERFORMANCE_NLSTEXT )
    return 6;
  if ( !ResultLength )
    return 87;
  v7 = (const char *)a2;
  if ( !a2 )
  {
    Source = 0;
    v7 = &Source;
  }
  if ( hKey != HKEY_CLASSES_ROOT
    && hKey != HKEY_CURRENT_USER
    && hKey != HKEY_LOCAL_MACHINE
    && hKey != HKEY_USERS
    && hKey != HKEY_CURRENT_CONFIG
    && hKey != HKEY_DYN_DATA
    && hKey != HKEY_CURRENT_USER_LOCAL_SETTINGS
    || a4 & 0x300
    || v7 && *v7 )
  {
    if ( !v7 )
    {
      v10 = 1010;
      goto LABEL_18;
    }
    v8 = hKey;
    v9 = RegKrnGetGlobalState();
    v10 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v9 + 176))(v8, &hKey, &v25, &v26);
    if ( v10 )
    {
LABEL_18:
      v11 = v26;
      v12 = v25;
      v13 = RegKrnGetGlobalState();
      (*(void (__stdcall **)(int, int))(v13 + 168))(v12, v11);
      return v10;
    }
    if ( !RtlCreateUnicodeStringFromAsciiz(&Destination, v7) )
    {
      v10 = RtlNtStatusToDosError(-1073741801);
      goto LABEL_18;
    }
    Destination.Length += 2;
    if ( !((unsigned __int8)hKey & 1) )
    {
      v10 = LocalBaseRegOpenKey(hKey, &Destination, a3, a4, ResultLength, a6);
LABEL_17:
      RtlFreeUnicodeString(&Destination);
      goto LABEL_18;
    }
    if ( !v24 )
      goto LABEL_17;
    a2 = 0;
    v17 = (unsigned int)hKey & 0xFFFFFFFE;
    v18 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 140);
    v19 = v18 && !v18(v17, &a2) && a2 == 6;
    v20 = a4;
    if ( !(a4 & 0x300) )
    {
      if ( !v19 )
      {
LABEL_46:
        v20 &= 0xFFFFFCFF;
LABEL_47:
        ms_exc.registration.TryLevel = 0;
        v10 = v24((unsigned int)hKey & 0xFFFFFFFE, &Destination, a3, v20, ResultLength);
        v23 = v10;
        ms_exc.registration.TryLevel = -2;
        if ( !v10 )
          *(_DWORD *)ResultLength |= 1u;
        goto LABEL_17;
      }
      v20 = a4 | 0x200;
    }
    if ( v19 )
      goto LABEL_47;
    goto LABEL_46;
  }
  if ( hKey == HKEY_CLASSES_ROOT )
  {
LABEL_34:
    *(_DWORD *)ResultLength = v6;
    v10 = 0;
    goto LABEL_18;
  }
  result = RegCloseKey(hKey);
  if ( !result )
  {
    v15 = hKey;
    v16 = RegKrnGetGlobalState();
    v10 = (*(int (__stdcall **)(HKEY, _DWORD, int *, int *))(v16 + 176))(v15, 0, &v25, &v26);
    if ( v10 )
      goto LABEL_18;
    v6 = hKey;
    goto LABEL_34;
  }
  return result;
}

//----- (77E2DB3C) --------------------------------------------------------
BOOL __stdcall DisableThreadLibraryCallsStub(HMODULE hLibModule)
{
  return DisableThreadLibraryCalls(hLibModule);
}

//----- (77E2DB49) --------------------------------------------------------
signed int __userpurge sub_77E2DB49@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // edi@1

  v5 = a1;
  v6 = a2;
  result = 0;
  v8 = 0;
  if ( !a2 )
    goto LABEL_12;
  do
  {
    if ( !a5 )
      break;
    if ( !*(_WORD *)v5 )
      break;
    *(_WORD *)a3 = *(_WORD *)v5;
    a3 += 2;
    v5 += 2;
    --v6;
    --a5;
    ++v8;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_12:
    a3 -= 2;
    --v8;
    result = -2147024774;
  }
  *(_WORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = v8;
  return result;
}

//----- (77E2DBAD) --------------------------------------------------------
LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  WCHAR *v6; // ecx@30
  NTSTATUS v7; // eax@40
  int v8; // eax@1
  int (__stdcall *v9)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // edi@1
  HKEY v10; // esi@4
  int v11; // eax@4
  NTSTATUS v12; // eax@5
  LPDWORD *v13; // esi@7
  int v14; // esi@18
  int v15; // edi@18
  int v16; // eax@18
  STRING SourceString; // [sp+10h] [bp-58h]@5
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-50h]@1
  int v20; // [sp+24h] [bp-44h]@1
  int v21; // [sp+2Ch] [bp-3Ch]@1
  int v22; // [sp+30h] [bp-38h]@1
  ULONG ResultSize; // [sp+34h] [bp-34h]@40
  PWCHAR UnicodeString; // [sp+38h] [bp-30h]@1
  ULONG MbSize; // [sp+3Ch] [bp-2Ch]@1
  int v26; // [sp+40h] [bp-28h]@9
  int v27; // [sp+44h] [bp-24h]@1
  ULONG Size; // [sp+48h] [bp-20h]@8
  LSTATUS v29; // [sp+4Ch] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@59

  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v27 = 0;
  UnicodeString = 0;
  MbSize = 0;
  v21 = 0;
  v22 = 0;
  v8 = RegKrnGetGlobalState();
  v9 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v8 + 120);
  v20 = *(_DWORD *)(v8 + 120);
  if ( lpReserved || lpData && !lpcbData )
    return 87;
  v10 = hKey;
  v11 = RegKrnGetGlobalState();
  v29 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v11 + 176))(v10, &hKey, &v21, &v22);
  if ( !v29 )
  {
    v12 = RtlInitAnsiStringEx(&SourceString, lpValueName);
    if ( v12 >= 0 )
    {
      v12 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u);
      if ( v12 >= 0 )
      {
        DestinationString.Length += 2;
        v13 = (LPDWORD *)lpcbData;
        if ( lpcbData )
          Size = *lpcbData;
        else
          Size = 0;
        v26 = 0;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v9 )
          {
            ms_exc.registration.TryLevel = 0;
            v29 = v9((unsigned int)hKey & 0xFFFFFFFE, &DestinationString, &v27, lpData, &Size, &v26);
            ms_exc.registration.TryLevel = -2;
            if ( (!v29 || v29 == 234) && Size > 0x7FFF0000 )
            {
LABEL_62:
              v29 = 13;
              goto LABEL_17;
            }
          }
        }
        else
        {
          v29 = LocalBaseRegQueryValue(hKey, &DestinationString, (int)&v27, (int)lpData, (int)&Size, (int)&v26);
        }
        if ( v29 && v29 != 234 || !lpData && !v13 || v27 != 1 && v27 != 2 && v27 != 7 )
        {
LABEL_13:
          if ( lpType )
            *lpType = v27;
          if ( v13 )
            *v13 = (LPDWORD)Size;
          goto LABEL_17;
        }
        lpValueName = (LPCSTR)Size;
        if ( v13 )
          lpReserved = *v13;
        else
          lpReserved = 0;
        v6 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
        UnicodeString = v6;
        if ( !v6 )
        {
          v29 = 8;
LABEL_42:
          Size = MbSize;
          if ( lpData && (unsigned int)*v13 > MbSize && MbSize > 0 && lpData[MbSize - 1] )
            lpData[MbSize] = 0;
          goto LABEL_13;
        }
        v26 = 0;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v9 )
          {
            ms_exc.registration.TryLevel = 1;
            v29 = v9((unsigned int)hKey & 0xFFFFFFFE, &DestinationString, &v27, v6, &Size, &v26);
            ms_exc.registration.TryLevel = -2;
          }
        }
        else
        {
          DestinationString.Length += 2;
          v29 = LocalBaseRegQueryValue(hKey, &DestinationString, (int)&v27, (int)v6, (int)&Size, (int)&v26);
        }
        if ( v29 && v29 != 234 || Size <= 0x7FFF0000 )
        {
          if ( v29 )
          {
            MbSize = Size;
          }
          else
          {
            RtlUnicodeToMultiByteSize(&MbSize, UnicodeString, Size);
            if ( v13 && MbSize > (unsigned int)*v13 && lpData )
              v29 = 234;
          }
          if ( !v29 && lpData )
          {
            ResultSize = 0;
            v7 = RtlUnicodeToMultiByteN(
                   (PCHAR)lpData,
                   (ULONG)lpReserved,
                   &ResultSize,
                   UnicodeString,
                   (ULONG)lpValueName);
            if ( v7 < 0 )
              v29 = RtlNtStatusToDosError(v7);
            MbSize = ResultSize;
          }
          goto LABEL_42;
        }
        goto LABEL_62;
      }
    }
    v29 = RtlNtStatusToDosError(v12);
  }
LABEL_17:
  if ( UnicodeString )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, UnicodeString);
  RtlFreeUnicodeString(&DestinationString);
  v14 = v22;
  v15 = v21;
  v16 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v16 + 168))(v15, v14);
  return v29;
}

//----- (77E2DD15) --------------------------------------------------------
HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName)
{
  int v2; // eax@5
  CHAR *v3; // eax@5
  void *v4; // edi@5
  UINT v5; // eax@6
  HMODULE v6; // esi@8

  if ( !lpLibFileName )
    return LoadLibraryExA(lpLibFileName, 0, 0);
  if ( __strcmpi(lpLibFileName, "twain_32.dll") )
    return LoadLibraryExA(lpLibFileName, 0, 0);
  v2 = KernelBaseGetGlobalData();
  v3 = (CHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v2 + 44), 0x104u);
  v4 = v3;
  if ( !v3 )
    return LoadLibraryExA(lpLibFileName, 0, 0);
  v5 = GetWindowsDirectoryA(v3, 0xF7u);
  if ( !v5
    || v5 >= 0xF7
    || (strncat_s((char *)v4, 0x104u, "\\twain_32.dll", 0xDu), (v6 = LoadLibraryA((LPCSTR)v4)) == 0) )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    return LoadLibraryExA(lpLibFileName, 0, 0);
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
  return v6;
}

//----- (77E2DD62) --------------------------------------------------------
void __stdcall GetSystemInfoStub(LPSYSTEM_INFO lpSystemInfo)
{
  GetSystemInfo(lpSystemInfo);
}

//----- (77E2DD72) --------------------------------------------------------
HANDLE __stdcall CreateThreadStub(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
  return CreateRemoteThreadEx(
           (HANDLE)0xFFFFFFFF,
           lpThreadAttributes,
           dwStackSize,
           lpStartAddress,
           lpParameter,
           dwCreationFlags,
           0,
           lpThreadId);
}

//----- (77E2DDB1) --------------------------------------------------------
ULONG __stdcall LocalOpenLocalMachine(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  NTSTATUS v3; // eax@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-18h]@1

  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&MachineStringKey;
  v3 = NtOpenKey(KeyHandle, DesiredAccess, &ObjectAttributes);
  return RtlNtStatusToDosError(v3);
}
// 77E2DDF4: using guessed type int MachineStringKey;

//----- (77E2DE30) --------------------------------------------------------
BOOL __stdcall GetVersionExAStub(LPOSVERSIONINFOA lpVersionInformation)
{
  return GetVersionExA(lpVersionInformation);
}

//----- (77E2DE48) --------------------------------------------------------
BOOL __stdcall InitializeCriticalSectionExStub(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
{
  return InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);
}

//----- (77E2DE7C) --------------------------------------------------------
BOOL __stdcall IsTerminalServerCompatible()
{
  PIMAGE_NT_HEADERS v0; // eax@1

  v0 = RtlImageNtHeader(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved3[1]);
  return v0 && v0->OptionalHeader.DllCharacteristics & 0x8000;
}

//----- (77E2E19B) --------------------------------------------------------
NTSTATUS __stdcall ConnectConsoleInternal(int a1, int a2, int a3)
{
  NTSTATUS v3; // edi@3
  int v4; // ST10_4@7
  HANDLE Handles; // [sp+Ch] [bp-234h]@12
  HANDLE v7; // [sp+10h] [bp-230h]@12
  int v8; // [sp+14h] [bp-22Ch]@1
  int v9; // [sp+18h] [bp-228h]@3
  HANDLE Handle; // [sp+1Ch] [bp-224h]@11
  int v11; // [sp+20h] [bp-220h]@3
  HANDLE v12; // [sp+24h] [bp-21Ch]@5
  char v13; // [sp+28h] [bp-218h]@3
  char v14; // [sp+29h] [bp-217h]@3
  char v15; // [sp+2Ah] [bp-216h]@3
  char v16; // [sp+2Bh] [bp-215h]@3
  int v17; // [sp+2Ch] [bp-214h]@7
  wchar_t pszDest; // [sp+30h] [bp-210h]@2

  v8 = a3;
  if ( *(_BYTE *)(a2 + 244) )
    RtlStringCchCopyNW(
      &pszDest,
      0x105u,
      (const wchar_t *)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters[1].Reserved2[9],
      (unsigned int)LOWORD(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters[1].Reserved2[8]) >> 1);
  v13 = *(_BYTE *)(a2 + 244);
  v15 = 0;
  v14 = 0;
  v16 = 0;
  v11 = (int)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  v9 = 540;
  v3 = CsrClientConnectToServer(a1, 2, &v11, &v9, v8);
  if ( v3 < 0 )
    return v3;
  if ( v13 )
  {
    if ( v12 )
    {
      v3 = ConsoleOpenWaitEvent(v11, (int)&pszDest, &Handle);
      if ( v3 >= 0 )
      {
        Handles = Handle;
        v7 = v12;
        v3 = NtWaitForMultipleObjects(2u, &Handles, WaitAny, 0, 0);
        if ( v3 == 1 )
          v3 = -1073741823;
        NtClose(Handle);
      }
      NtClose(v12);
    }
    if ( v3 >= 0 )
    {
      v4 = v11;
      *(_DWORD *)(a2 + 252) = v17;
      v3 = ConsoleConnect((const void *)a2, (int)&pszDest, v4);
    }
    return v3;
  }
  return 0;
}
// 77DE1670: using guessed type int __stdcall CsrClientConnectToServer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2E2B4) --------------------------------------------------------
bool __stdcall BasepInitComputerNameCache()
{
  return RtlInitializeCriticalSection(&gComputerNameCacheUpdateCR) >= 0;
}

//----- (77E2E2CE) --------------------------------------------------------
char __stdcall InitializeRegTermsrvFpns(int a1, int a2)
{
  char v2; // bl@1
  int v4; // eax@5
  __int16 v5; // si@5
  HMODULE v6; // eax@9
  HMODULE v7; // esi@9
  int v8; // edi@10
  int v9; // ebx@10
  int v10; // ST30_4@10
  int v11; // ST34_4@10
  int v12; // ST38_4@10
  int v13; // ST3C_4@10
  int v14; // eax@10
  int v15; // [sp+20h] [bp+8h]@10
  int v16; // [sp+24h] [bp+Ch]@10

  v2 = 0;
  if ( IsTerminalServerCompatible() || !IsRegTSAppCompatEnabled(a1) )
    return 0;
  v4 = GetCompatFlags();
  v5 = v4;
  *(_DWORD *)a2 = v4;
  if ( IsSystemLUID() )
  {
    if ( (v5 & 0x2008) == 8200 )
      goto LABEL_9;
    return 0;
  }
  if ( (v5 & 0x108) == 264 )
    return 0;
LABEL_9:
  v6 = LoadLibraryA("tsappcmp.dll");
  v7 = v6;
  if ( v6 )
  {
    v8 = (int)GetProcAddress(v6, "TermsrvCreateRegEntry");
    v9 = (int)GetProcAddress(v7, "TermsrvOpenRegEntry");
    v10 = (int)GetProcAddress(v7, "TermsrvSetValueKey");
    v11 = (int)GetProcAddress(v7, "TermsrvDeleteKey");
    v12 = (int)GetProcAddress(v7, "TermsrvDeleteValue");
    v13 = (int)GetProcAddress(v7, "TermsrvRestoreKey");
    v16 = (int)GetProcAddress(v7, "TermsrvSetKeySecurity");
    v15 = (int)GetProcAddress(v7, "TermsrvOpenUserClasses");
    v14 = (int)GetProcAddress(v7, "TermsrvGetPreSetValue");
    RegKrnSetTermSrvHooksAndFlags(v8, v9, v10, v11, v12, v13, v16, v15, v14);
    v2 = 1;
  }
  return v2;
}

//----- (77E2E2F4) --------------------------------------------------------
char __stdcall BaseNlsSortingDllInitialize(int a1)
{
  if ( a1 == 1 )
    memset(SortTblPtrs, 0, 0x74u);
  return 1;
}
// 77EA6620: using guessed type int SortTblPtrs[30];

//----- (77E2E31B) --------------------------------------------------------
BOOL __stdcall InitializeRegWow64Flags()
{
  HANDLE v0; // eax@1
  BOOL result; // eax@1

  v0 = GetCurrentProcess();
  result = IsWow64Process(v0, &g_Win64Registry);
  if ( !result )
    g_Win64Registry = 0;
  return result;
}

//----- (77E2E339) --------------------------------------------------------
__int32 __stdcall RealWerpInitializeMessageMapping()
{
  __int32 result; // eax@1

  result = FSPErrorMessages::CMessageMapper::StaticInitialize();
  g_fLemStaticInitialized = 1;
  return result;
}
// 77EA6014: using guessed type int g_fLemStaticInitialized;

//----- (77E2E34E) --------------------------------------------------------
__int32 __stdcall FSPErrorMessages::CMessageMapper::StaticInitialize()
{
  return FSPErrorMessages::CMessageMapper::MustSucceedInit((PRTL_CRITICAL_SECTION)&FSPErrorMessages::CMessageMapper::ms_instance);
}

//----- (77E2E35A) --------------------------------------------------------
__int32 __thiscall FSPErrorMessages::CMessageMapper::MustSucceedInit(PRTL_CRITICAL_SECTION CriticalSectionObject)
{
  PRTL_CRITICAL_SECTION v1; // esi@1

  v1 = CriticalSectionObject;
  CriticalSectionObject[1].DebugInfo = 0;
  CriticalSectionObject[1].LockCount = 0;
  CriticalSectionObject[1].RecursionCount = 0;
  CriticalSectionObject[1].LockSemaphore = 0;
  CriticalSectionObject[1].OwningThread = HANDLE_FLAG_INHERIT;
  RtlInitializeCriticalSection(CriticalSectionObject);
  v1[1].OwningThread = 0;
  v1[1].RecursionCount = 1;
  return 0;
}

//----- (77E2E38D) --------------------------------------------------------
void __stdcall GetStartupInfoWStub(LPSTARTUPINFOW lpStartupInfo)
{
  GetStartupInfoW(lpStartupInfo);
}

//----- (77E2E39D) --------------------------------------------------------
signed int __stdcall PredefinedHandleTableCriticalSectionInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context)
{
  RtlInitializeCriticalSection(&PredefinedHandleTableCriticalSection);
  return 1;
}

//----- (77E2E3BE) --------------------------------------------------------
ULONG *__stdcall BaseDllInitializeMemoryManager()
{
  int v0; // eax@1
  int v1; // ST0C_4@1
  ULONG *result; // eax@1
  ULONG *v3; // [sp+10h] [bp-4h]@1

  v0 = KernelBaseGetGlobalData();
  v1 = *(_DWORD *)(v0 + 84);
  v3 = *(ULONG **)(v0 + 88);
  BaseHeap = *(HANDLE *)(v0 + 80);
  result = (ULONG *)v1;
  BaseHeapHandleTablePtr = v1;
  if ( !SystemRangeStart )
  {
    result = v3;
    SystemRangeStart = v3;
  }
  return result;
}
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E2E402) --------------------------------------------------------
BOOL __stdcall ConsoleApp()
{
  HMODULE v0; // eax@1
  PIMAGE_NT_HEADERS v1; // eax@1

  v0 = GetModuleHandleW(0);
  v1 = RtlImageNtHeader(v0);
  return v1 && v1->OptionalHeader.Subsystem == 3;
}

//----- (77E2E42C) --------------------------------------------------------
int __stdcall InitExeName()
{
  PPEB v0; // edi@2
  PVOID v1; // eax@2
  __int16 v2; // si@2
  __int16 v3; // si@2
  int result; // eax@2

  if ( !ExeNameInitialized )
  {
    RtlInitializeCriticalSection(&ExeNameCriticalSection);
    ExeNameInitialized = 1;
    v0 = NtCurrentTeb()->ProcessEnvironmentBlock;
    v1 = v0->Ldr->Reserved2[1];
    ExeNameLength = *((_WORD *)v1 + 22) >> 1;
    v2 = ExeNameLength;
    memcpy(ExeNameBuffer, *((const void **)v1 + 12), *((_WORD *)v1 + 22));
    ExeNameBuffer[(unsigned __int16)v2] = 0;
    StartDirLength = LOWORD(v0->ProcessParameters->Reserved2[5]) >> 1;
    v3 = StartDirLength;
    memcpy(StartDirBuffer, v0->ProcessParameters->Reserved2[6], LOWORD(v0->ProcessParameters->Reserved2[5]));
    result = (unsigned __int16)v3;
    StartDirBuffer[(unsigned __int16)v3] = 0;
  }
  return result;
}
// 77EA6000: using guessed type __int16 ExeNameLength;
// 77EA6002: using guessed type __int16 StartDirLength;
// 77EA6004: using guessed type char ExeNameInitialized;
// 77EA60A0: using guessed type __int16 ExeNameBuffer[];
// 77EA6320: using guessed type __int16 StartDirBuffer[];

//----- (77E2E4C7) --------------------------------------------------------
int __stdcall InitializeCtrlHandling()
{
  HandlerListLength = 1;
  AllocatedHandlerListLength = 1;
  HandlerList = &SingleHandler;
  SingleHandler = RtlEncodePointer(DefaultHandler);
  return 0;
}
// 77DE1368: using guessed type int __stdcall RtlEncodePointer(_DWORD);
// 77EA6018: using guessed type int AllocatedHandlerListLength;
// 77EA6088: using guessed type int SingleHandler;

//----- (77E2E4F6) --------------------------------------------------------
signed int __stdcall BaseDllInitializeIniFileMappings(int a1)
{
  PPEB v1; // ecx@1
  int v2; // eax@1
  signed int result; // eax@2

  v1 = NtCurrentTeb()->ProcessEnvironmentBlock;
  v2 = *(_DWORD *)(a1 + 384);
  BaseDllIniFileMapping = *(_DWORD *)(a1 + 384);
  if ( !(v1->Reserved2[0] & 2) || (unsigned __int8)CsrVerifyRegion(v2, 16) )
    result = 0;
  else
    result = -1073741790;
  return result;
}
// 77DE149C: using guessed type int __stdcall CsrVerifyRegion(_DWORD, _DWORD);
// 77EA6090: using guessed type int BaseDllIniFileMapping;

//----- (77E2E527) --------------------------------------------------------
int *__stdcall BasepInitializePrefixDatabase()
{
  int *result; // eax@1

  RtlInitializeSRWLock(&BasePrivatenamespaceLock);
  result = &BasePrefixList;
  dword_77EA62DC = (int)&BasePrefixList;
  BasePrefixList = (int)&BasePrefixList;
  return result;
}
// 77DE1258: using guessed type int __stdcall RtlInitializeSRWLock(_DWORD);
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA62DC: using guessed type int dword_77EA62DC;
// 77EA6794: using guessed type int BasePrivatenamespaceLock;

//----- (77E2E547) --------------------------------------------------------
int __stdcall BasepInitWER()
{
  int result; // eax@1

  result = KernelBaseGetGlobalData();
  *(_DWORD *)(result + 112) = BasepNotifyLoadStringResource;
  return result;
}

//----- (77E2E569) --------------------------------------------------------
char __stdcall SetUpConsoleInfo(int a1, int a2)
{
  int v2; // eax@14
  __int16 v3; // cx@15
  DWORD v4; // eax@1
  ULONG v5; // eax@3
  ULONG v6; // eax@9
  bool v7; // zf@9
  struct _STARTUPINFOW StartupInfo; // [sp+8h] [bp-44h]@1

  GetStartupInfoW(&StartupInfo);
  v4 = StartupInfo.dwFlags;
  *(_DWORD *)(a2 + 60) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 36) = v4;
  *(_DWORD *)(a2 + 240) = GetOEMCP();
  if ( !StartupInfo.lpTitle )
    StartupInfo.lpTitle = L"Command Prompt";
  if ( a1 )
  {
    RtlStringCchCopyW((wchar_t *)(a1 + 260), 0x105u, StartupInfo.lpTitle);
    v2 = a1 + 260;
    do
    {
      v3 = *(_WORD *)v2;
      v2 += 2;
    }
    while ( v3 );
    *(_DWORD *)(a1 + 256) = 2 * ((v2 - (a1 + 262)) >> 1);
  }
  LOBYTE(v5) = LOBYTE(StartupInfo.dwFlags);
  if ( StartupInfo.dwFlags & 1 )
    *(_WORD *)(a2 + 44) = StartupInfo.wShowWindow;
  if ( v5 & 0x10 )
    *(_WORD *)(a2 + 40) = LOWORD(StartupInfo.dwFillAttribute);
  if ( v5 & 8 )
  {
    *(_WORD *)(a2 + 48) = LOWORD(StartupInfo.dwXCountChars);
    *(_WORD *)(a2 + 50) = LOWORD(StartupInfo.dwYCountChars);
  }
  if ( v5 & 2 )
  {
    *(_WORD *)(a2 + 52) = LOWORD(StartupInfo.dwXSize);
    *(_WORD *)(a2 + 54) = LOWORD(StartupInfo.dwYSize);
  }
  if ( v5 & 4 )
  {
    *(_WORD *)(a2 + 56) = LOWORD(StartupInfo.dwX);
    LOBYTE(v5) = LOBYTE(StartupInfo.dwY);
    *(_WORD *)(a2 + 58) = LOWORD(StartupInfo.dwY);
  }
  if ( StartupInfo.lpReserved )
  {
    v6 = ParseReserved(StartupInfo.lpReserved, L"dde.");
    v7 = (StartupInfo.dwFlags & 0x200) == 0;
    *(_DWORD *)(a2 + 20) = v6;
    if ( v7 )
      v5 = ParseReserved(StartupInfo.lpReserved, L"hotkey.");
    else
      v5 = (ULONG)StartupInfo.hStdInput;
    *(_DWORD *)(a2 + 32) = v5;
  }
  return v5;
}
// 77E5E460: using guessed type wchar_t aCommandPrompt[15];

//----- (77E2E63B) --------------------------------------------------------
ULONG __stdcall ParseReserved(wchar_t *Str, wchar_t *SubStr)
{
  wchar_t *v2; // eax@1
  const WCHAR *v4; // eax@3
  const WCHAR *i; // esi@3
  const WCHAR v6; // di@6
  LSA_UNICODE_STRING DestinationString; // [sp+0h] [bp-Ch]@6
  ULONG Value; // [sp+8h] [bp-4h]@1

  Value = 0;
  v2 = wcsstr(Str, SubStr);
  if ( v2 )
  {
    v4 = &v2[wcslen(SubStr)];
    for ( i = v4; *i >= 0x30u; ++i )
    {
      if ( *i > 0x39u )
        break;
    }
    v6 = *i;
    *i = 0;
    RtlInitUnicodeString(&DestinationString, v4);
    *i = v6;
    RtlUnicodeStringToInteger(&DestinationString, 0, &Value);
  }
  return Value;
}

//----- (77E2E6A1) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  uintptr_t v0; // eax@1

  v0 = __security_cookie;
  if ( !__security_cookie || __security_cookie == -1153374642 )
  {
    __security_init_cookie_ex((int)&__security_cookie);
    v0 = __security_cookie;
  }
  __security_cookie_complement = ~v0;
}
// 77EA6084: using guessed type int __security_cookie_complement;

//----- (77E2E6C6) --------------------------------------------------------
signed int __stdcall GetPerUserWindowsDirectory(WCHAR *a1, unsigned int a2, int a3)
{
  signed int result; // eax@1
  bool v4; // zf@10
  unsigned __int16 v5; // ax@10
  LSA_UNICODE_STRING Destination; // [sp+4h] [bp-14h]@9
  LSA_UNICODE_STRING Value; // [sp+Ch] [bp-Ch]@8
  int v8; // [sp+14h] [bp-4h]@1

  *(_DWORD *)a3 = 0;
  result = IsTSAppCompatEnabled((int)&v8);
  if ( result >= 0 )
  {
    if ( !v8 || IsSystemLUID() )
    {
      result = 0;
    }
    else if ( a2 >= 0x104 )
    {
      Value.Length = 0;
      Value.MaximumLength = 502;
      Value.Buffer = a1;
      result = RtlQueryEnvironmentVariable_U(0, &stru_77E52398, &Value);
      if ( result >= 0 )
      {
        Destination.MaximumLength = 2 * a2;
        Value.MaximumLength -= Value.Length;
        Destination.Length = Value.Length;
        Value.Buffer += (unsigned int)Value.Length >> 1;
        Value.Length = 0;
        Destination.Buffer = a1;
        result = RtlQueryEnvironmentVariable_U(0, &stru_77E52390, &Value);
        if ( result >= 0 )
        {
          v4 = (_WORD)Value.Length + (_WORD)Destination.Length == 0;
          v5 = Value.Length + Destination.Length;
          Destination.Length += Value.Length;
          if ( !v4 && Destination.Buffer[((unsigned int)v5 >> 1) - 1] != 92 )
            RtlAppendUnicodeToString(&Destination, L"\\");
          RtlAppendUnicodeToString(&Destination, L"WINDOWS");
          *(_DWORD *)a3 = (unsigned int)Destination.Length >> 1;
          result = 0;
        }
      }
    }
    else
    {
      result = -1073741811;
    }
  }
  return result;
}

//----- (77E2E6F8) --------------------------------------------------------
int __stdcall IsTSAppCompatEnabled(int a1)
{
  int v1; // eax@3
  struct _OSVERSIONINFOW VersionInformation; // [sp+4h] [bp-120h]@1
  int v4; // [sp+11Ch] [bp-8h]@2

  VersionInformation.dwOSVersionInfoSize = 284;
  v1 = GetVersionExW(&VersionInformation) && v4 & 0x10 && !(v4 & 0x100) && (BYTE2(v4) == 2 || BYTE2(v4) == 3);
  *(_DWORD *)a1 = v1;
  return 0;
}

//----- (77E2E74F) --------------------------------------------------------
void *__stdcall InitializeConsoleConnectionInfo(void *Dst)
{
  char v1; // al@1
  bool v2; // zf@1
  PRTL_USER_PROCESS_PARAMETERS v3; // eax@1
  PRTL_USER_PROCESS_PARAMETERS v4; // eax@2

  memset(Dst, 0, 0x624u);
  *((_BYTE *)Dst + 245) = 1;
  v1 = ConsoleApp();
  gbConsoleApp = v1;
  *((_BYTE *)Dst + 244) = v1;
  v2 = v1 == 0;
  v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  if ( v2 )
    goto LABEL_11;
  v2 = v3->Reserved2[0] == (PVOID)-1;
  v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  if ( v2 )
  {
    v4->Reserved2[0] = 0;
    *((_BYTE *)Dst + 244) = 0;
    goto LABEL_5;
  }
  v2 = v4->Reserved2[0] == (PVOID)-2;
  v3 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  if ( v2 )
  {
LABEL_11:
    v3->Reserved2[0] = 0;
    goto LABEL_5;
  }
  if ( v3->Reserved2[0] == (PVOID)-3 )
  {
    NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] = 0;
    *((_BYTE *)Dst + 245) = 0;
  }
LABEL_5:
  InitExeName();
  SetUpConsoleInfo(
    NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] == 0 ? (unsigned int)Dst : 0,
    (int)Dst);
  *((_DWORD *)Dst + 261) = 522;
  *((_DWORD *)Dst + 196) = 256;
  return SetUpAppName((int)((char *)Dst + 1044), (char *)Dst + 1048, (int)((char *)Dst + 784), (char *)Dst + 788);
}
// 77EA6541: using guessed type char gbConsoleApp;

//----- (77E2E826) --------------------------------------------------------
void *__stdcall SetUpAppName(int a1, void *Dst, int a3, void *a4)
{
  int v4; // eax@1
  int v5; // edi@2
  int v6; // eax@2
  int v7; // edi@3
  void *result; // eax@3

  *(_DWORD *)a1 -= 2;
  v4 = 2 * (unsigned __int16)StartDirLength;
  if ( (unsigned int)v4 > *(_DWORD *)a1 )
    v4 = *(_DWORD *)a1;
  v5 = v4 + 2;
  memcpy(Dst, StartDirBuffer, v4 + 2);
  *(_DWORD *)a1 = v5;
  *(_DWORD *)a3 -= 2;
  v6 = 2 * (unsigned __int16)ExeNameLength;
  if ( (unsigned int)v6 > *(_DWORD *)a3 )
    v6 = *(_DWORD *)a3;
  v7 = v6 + 2;
  result = memcpy(a4, ExeNameBuffer, v6 + 2);
  *(_DWORD *)a3 = v7;
  return result;
}
// 77EA6000: using guessed type __int16 ExeNameLength;
// 77EA6002: using guessed type __int16 StartDirLength;
// 77EA60A0: using guessed type __int16 ExeNameBuffer[];
// 77EA6320: using guessed type __int16 StartDirBuffer[];

//----- (77E2E8DF) --------------------------------------------------------
PVOID __stdcall AllocatePredefinedHandleUnit(int a1)
{
  PVOID result; // eax@1

  result = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x10u);
  if ( result )
  {
    *(_DWORD *)result = 0;
    *((_DWORD *)result + 1) = 0;
    *((_DWORD *)result + 3) = 0;
    *((_DWORD *)result + 2) = a1;
  }
  return result;
}

//----- (77E2E955) --------------------------------------------------------
HANDLE __stdcall CreateFileWImplementation(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
  NTSTATUS v7; // eax@1
  const UNICODE_STRING *v8; // eax@2
  HANDLE result; // eax@3
  int v10; // ecx@5
  UNICODE_STRING DestinationString; // [sp+0h] [bp-8h]@1

  v7 = RtlInitUnicodeStringEx(&DestinationString, lpFileName);
  if ( v7 < 0 )
  {
    BaseSetLastNTError(v7);
    result = (HANDLE)-1;
  }
  else
  {
    v8 = BaseIsThisAConsoleName((int)&DestinationString, dwDesiredAccess);
    if ( v8 )
    {
      v10 = 0;
      if ( lpSecurityAttributes )
        v10 = lpSecurityAttributes->bInheritHandle;
      result = (HANDLE)OpenConsoleW(v8->Buffer, dwDesiredAccess, v10, 3);
    }
    else
    {
      result = CreateFileW(
                 lpFileName,
                 dwDesiredAccess,
                 dwShareMode,
                 lpSecurityAttributes,
                 dwCreationDisposition,
                 dwFlagsAndAttributes,
                 hTemplateFile);
    }
  }
  return result;
}

//----- (77E2E9B3) --------------------------------------------------------
const UNICODE_STRING *__stdcall BaseIsThisAConsoleName(int a1, int a2)
{
  int v2; // eax@2
  __int16 v3; // dx@2
  __int16 v4; // ax@2
  unsigned int v5; // eax@4
  UNICODE_STRING String1; // [sp+10h] [bp-24h]@4
  const UNICODE_STRING *v8; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@5

  v8 = 0;
  if ( *(_WORD *)a1 )
  {
    v2 = *(_DWORD *)(a1 + 4);
    v3 = *(_WORD *)v2;
    v4 = *(_WORD *)(v2 + 2 * ((*(_WORD *)a1 - 1) >> 1));
    if ( v3 == 99 || v3 == 67 || v3 == 92 || v4 == 110 || v4 == 78 || v4 == 58 || v4 == 36 )
    {
      *(_DWORD *)&String1.Length = *(_DWORD *)a1;
      String1.Buffer = *(PWCH *)(a1 + 4);
      v5 = RtlIsDosDeviceName_U(String1.Buffer);
      if ( v5 )
      {
        String1.Buffer = (PWCH)((char *)String1.Buffer + (v5 >> 16));
        String1.Length = v5;
        String1.MaximumLength = v5 + 2;
      }
      v8 = 0;
      ms_exc.registration.TryLevel = 0;
      if ( !RtlEqualUnicodeString(&String1, &BaseConsoleInput, 1u) )
      {
        if ( RtlEqualUnicodeString(&String1, &BaseConsoleOutput, 1u) )
          goto LABEL_18;
        if ( !RtlEqualUnicodeString(&String1, &BaseConsoleGeneric, 1u) )
        {
LABEL_8:
          ms_exc.registration.TryLevel = -2;
          return v8;
        }
        if ( (a2 & 0xC0000000) != 0x80000000 )
        {
          if ( (a2 & 0xC0000000) != 0x40000000 )
            goto LABEL_8;
LABEL_18:
          v8 = &BaseConsoleOutput;
          goto LABEL_8;
        }
      }
      v8 = &BaseConsoleInput;
      goto LABEL_8;
    }
  }
  return v8;
}

//----- (77E2EAD1) --------------------------------------------------------
BOOL __stdcall InitializeCriticalSectionAndSpinCountStub(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
{
  return InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
}

//----- (77E2EAF4) --------------------------------------------------------
BOOL __stdcall SystemTimeToFileTimeStub(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
{
  return SystemTimeToFileTime(lpSystemTime, lpFileTime);
}

//----- (77E2EB01) --------------------------------------------------------
void __stdcall GetSystemTimeStub(LPSYSTEMTIME lpSystemTime)
{
  GetSystemTime(lpSystemTime);
}

//----- (77E2EB11) --------------------------------------------------------
HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
  HANDLE v7; // esi@2
  HANDLE result; // eax@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpFileName) )
  {
    v7 = CreateFileWImplementation(
           UnicodeString.Buffer,
           dwDesiredAccess,
           dwShareMode,
           lpSecurityAttributes,
           dwCreationDisposition,
           dwFlagsAndAttributes,
           hTemplateFile);
    RtlFreeUnicodeString(&UnicodeString);
    result = v7;
  }
  else
  {
    result = (HANDLE)-1;
  }
  return result;
}

//----- (77E2EB6A) --------------------------------------------------------
DWORD __stdcall GetFullPathNameAStub(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
{
  return GetFullPathNameA(lpFileName, nBufferLength, lpBuffer, lpFilePart);
}

//----- (77E2EBB0) --------------------------------------------------------
int __stdcall IsRegTSAppCompatEnabled(int a1)
{
  PVOID v1; // ebx@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-2Ch]@3
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-14h]@1
  ULONG ResultLength; // [sp+2Ch] [bp-Ch]@4
  int v6; // [sp+30h] [bp-8h]@1
  HANDLE KeyHandle; // [sp+34h] [bp-4h]@1

  KeyHandle = 0;
  v6 = 0;
  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server");
  v1 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x224u);
  if ( DestinationString.Buffer )
  {
    if ( !v1 )
      return v6;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = &DestinationString;
    if ( NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes) >= 0 )
    {
      RtlInitUnicodeString(&DestinationString, L"TSAppCompat");
      if ( NtQueryValueKey(KeyHandle, &DestinationString, KeyValuePartialInformation, v1, 0x224u, &ResultLength) >= 0
        && *((_DWORD *)v1 + 1) == 4
        && *((_DWORD *)v1 + 3) )
        v6 = 1;
      RtlInitUnicodeString(&DestinationString, L"TSUserEnabled");
      if ( NtQueryValueKey(KeyHandle, &DestinationString, KeyValuePartialInformation, v1, 0x224u, &ResultLength) < 0
        || *((_DWORD *)v1 + 1) != 4 )
        *(_BYTE *)a1 = 0;
      else
        *(_BYTE *)a1 = *((_BYTE *)v1 + 12);
      NtClose(KeyHandle);
    }
  }
  if ( v1 )
  {
    memset(v1, 0, 0x224u);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
  }
  return v6;
}

//----- (77E2ED93) --------------------------------------------------------
int __stdcall BasepProbeForDllManifest(HMODULE a1, const WCHAR *a2, int a3)
{
  HANDLE v3; // eax@4
  int result; // eax@2
  ACTCTXW pActCtx; // [sp+4h] [bp-24h]@1
  int v6; // [sp+24h] [bp-4h]@1

  pActCtx.cbSize = 32;
  memset(&pActCtx.dwFlags, 0, 0x1Cu);
  v6 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    result = LdrResFindResourceDirectory(a1, 24, 2, &v6, 0, 0, 16);
    if ( result >= 0 )
    {
      pActCtx.lpSource = a2;
      pActCtx.dwFlags = 136;
      pActCtx.lpResourceName = (LPCWSTR)2;
      pActCtx.hModule = a1;
      v3 = CreateActCtxW(&pActCtx);
      if ( v3 == (HANDLE)-1 )
      {
        result = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
      }
      else
      {
        *(_DWORD *)a3 = v3;
        result = 0;
      }
    }
  }
  else
  {
    result = -1073741811;
  }
  return result;
}
// 77DE1324: using guessed type int __stdcall LdrResFindResourceDirectory(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E2EDF2) --------------------------------------------------------
UINT __stdcall GetDriveTypeWStub(LPCWSTR lpRootPathName)
{
  return GetDriveTypeW(lpRootPathName);
}

//----- (77E2EE0A) --------------------------------------------------------
HANDLE __userpurge BaseThreadInitThunk@<eax>(int (__cdecl *a1)(_DWORD)@<edx>, int a2@<ecx>, DWORD a3, BOOL a4, const CHAR *a5)
{
  int v5; // eax@2
  HANDLE result; // eax@2

  if ( a2 )
  {
    if ( !(v7FFE02D0 & 0x10) || (result = (HANDLE)BasepInitializeTermsrvFpns(), (signed int)result >= 0) )
      result = 0;
  }
  else
  {
    v5 = a1(a3);
    RtlExitUserThread(v5);
    result = OpenFileMappingA(a3, a4, a5);
  }
  return result;
}
// 77DE170C: using guessed type int __stdcall RtlExitUserThread(_DWORD);

//----- (77E2EE28) --------------------------------------------------------
HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
{
  HANDLE result; // eax@2
  HANDLE v4; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v4 = OpenFileMappingW(dwDesiredAccess, bInheritHandle, UnicodeString.Buffer);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v4;
}

//----- (77E2EE78) --------------------------------------------------------
UINT __stdcall GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
{
  size_t *v2; // esi@2
  int v3; // eax@2
  UINT result; // eax@2

  if ( 2 * uSize < (unsigned int)*(_WORD *)(KernelBaseGetGlobalData() + 52) + 2 )
  {
    result = ((unsigned int)*(_WORD *)(KernelBaseGetGlobalData() + 52) >> 1) + 1;
  }
  else
  {
    v2 = (size_t *)(KernelBaseGetGlobalData() + 52);
    v3 = KernelBaseGetGlobalData();
    memcpy(lpBuffer, *(const void **)(v3 + 56), *(_WORD *)v2);
    lpBuffer[(unsigned int)*(_WORD *)(KernelBaseGetGlobalData() + 52) >> 1] = 0;
    result = (unsigned int)*(_WORD *)(KernelBaseGetGlobalData() + 52) >> 1;
  }
  return result;
}

//----- (77E2EEE7) --------------------------------------------------------
UINT __stdcall GetSystemDirectoryWStub(LPWSTR lpBuffer, UINT uSize)
{
  return GetSystemDirectoryW(lpBuffer, uSize);
}

//----- (77E2EEF4) --------------------------------------------------------
UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
{
  int v2; // eax@1
  int v3; // esi@1
  unsigned int v4; // eax@1
  UINT result; // eax@2

  v2 = KernelBaseGetGlobalData();
  v3 = v2 + 60;
  v4 = *(_WORD *)(v2 + 60);
  if ( 2 * uSize < v4 + 2 )
  {
    result = (v4 >> 1) + 1;
  }
  else
  {
    memcpy(lpBuffer, *(const void **)(v3 + 4), v4);
    lpBuffer[(unsigned int)*(_WORD *)v3 >> 1] = 0;
    result = (unsigned int)*(_WORD *)v3 >> 1;
  }
  return result;
}

//----- (77E2EF43) --------------------------------------------------------
UINT __stdcall GetSystemWindowsDirectoryWStub(LPWSTR lpBuffer, UINT uSize)
{
  return GetSystemWindowsDirectoryW(lpBuffer, uSize);
}

//----- (77E2EF81) --------------------------------------------------------
int __stdcall BasepInitializeTermsrvFpns()
{
  int result; // eax@2
  HMODULE v1; // edi@7
  int v2; // esi@9
  FARPROC v3; // eax@10
  int v4; // ecx@10
  int v5; // [sp+4h] [bp-4h]@5

  if ( IsTerminalServerCompatible() || IsSystemLUID() )
    return 0;
  result = IsTSAppCompatEnabled((int)&v5);
  if ( result < 0 )
    return result;
  if ( !v5 )
    return 0;
  v1 = LoadLibraryW(L"tsappcmp.dll");
  if ( v1 )
  {
    v2 = 0;
    do
    {
      v3 = GetProcAddress(v1, (&off_77E52440)[v2 * 4]);
      v4 = off_77E52444[v2];
      v2 += 2;
      *(_DWORD *)v4 = v3;
    }
    while ( v2 != 24 );
    *(_DWORD *)(KernelBaseGetGlobalData() + 96) = pfnTermsrvGetWindowsDirectoryA;
    *(_DWORD *)(KernelBaseGetGlobalData() + 100) = pfnTermsrvGetWindowsDirectoryW;
    *(_DWORD *)(KernelBaseGetGlobalData() + 104) = pfnTermsrvConvertSysRootToUserDir;
    return 0;
  }
  return *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
}
// 77E52440: using guessed type char *off_77E52440;
// 77E52444: using guessed type int off_77E52444[];
// 77EA67C8: using guessed type int pfnTermsrvGetWindowsDirectoryA;
// 77EA67CC: using guessed type int pfnTermsrvGetWindowsDirectoryW;
// 77EA67D0: using guessed type int pfnTermsrvConvertSysRootToUserDir;

//----- (77E2EFAA) --------------------------------------------------------
int __stdcall WideCharToMultiByteStub(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar)
{
  return WideCharToMultiByte(
           CodePage,
           dwFlags,
           lpWideCharStr,
           cchWideChar,
           lpMultiByteStr,
           cbMultiByte,
           lpDefaultChar,
           lpUsedDefaultChar);
}

//----- (77E2EFB7) --------------------------------------------------------
int __stdcall MultiByteToWideCharStub(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
{
  return MultiByteToWideChar(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
}

//----- (77E2EFE5) --------------------------------------------------------
DWORD __stdcall GetModuleFileNameWStub(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
{
  return GetModuleFileNameW(hModule, lpFilename, nSize);
}

//----- (77E2EFF2) --------------------------------------------------------
HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName)
{
  return LoadLibraryExW(lpLibFileName, 0, 0);
}

//----- (77E2F017) --------------------------------------------------------
BOOL __stdcall FreeLibraryStub(HMODULE hLibModule)
{
  return FreeLibrary(hLibModule);
}

//----- (77E2F024) --------------------------------------------------------
HANDLE __stdcall HeapCreateStub(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
{
  return HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

//----- (77E2F047) --------------------------------------------------------
signed int __stdcall RestrictArguments(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@7

  if ( a1 && (_WORD)a2 && ((unsigned __int16)a2 == 0xFFFF || !(a2 & 4) || a2 & 0x10000000) && (!a3 || a4) )
    result = 0;
  else
    result = 87;
  return result;
}

//----- (77E2F08D) --------------------------------------------------------
void *__stdcall ZeroDataOnFailure(int a1, void *Dst, size_t Size, int a4)
{
  void *result; // eax@1

  result = 0;
  if ( a4 && a1 & 0x20000000 && Size > 0 )
    result = memset(Dst, 0, Size);
  return result;
}

//----- (77E2F0AF) --------------------------------------------------------
int __stdcall RegGetValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, int a4, LPDWORD lpType, void *Dst, size_t Size)
{
  size_t v7; // edi@1
  int v8; // ebx@4
  int v9; // esi@4

  v7 = Size;
  if ( Dst && Size )
    Size = *(_DWORD *)Size;
  else
    Size = 0;
  v8 = a4;
  v9 = RestrictArguments((int)hKey, a4, (int)Dst, v7);
  if ( !v9 )
  {
    if ( lpSubKey && *lpSubKey )
    {
      v9 = RegOpenKeyExW(hKey, lpSubKey, 0, 1u, &hKey);
      if ( !v9 )
      {
        v9 = QueryValueInternalW(hKey, lpValueName, v8, lpType, (LPBYTE)Dst, v7);
        RegCloseKey(hKey);
      }
    }
    else
    {
      v9 = QueryValueInternalW(hKey, lpValueName, v8, lpType, (LPBYTE)Dst, v7);
    }
  }
  ZeroDataOnFailure(v8, Dst, Size, v9);
  return v9;
}

//----- (77E2F122) --------------------------------------------------------
signed int __stdcall RestrictRegType(unsigned __int16 a1, int a2, unsigned int a3, signed int a4)
{
  bool v4; // zf@5
  signed int result; // eax@1
  bool v6; // cf@9
  bool v7; // zf@9

  result = a4;
  if ( a4 && a4 != 234 )
    return result;
  if ( !a2 )
  {
    v4 = (a1 & 1) == 0;
LABEL_14:
    if ( !v4 )
      return result;
    return 1630;
  }
  if ( a2 == 1 )
  {
    v4 = (a1 & 2) == 0;
    goto LABEL_14;
  }
  if ( a2 == 2 )
  {
    v4 = (a1 & 4) == 0;
    goto LABEL_14;
  }
  if ( a2 != 3 )
  {
    if ( a2 == 4 )
    {
      v4 = (a1 & 0x10) == 0;
      goto LABEL_14;
    }
    if ( a2 == 7 )
    {
      v4 = (a1 & 0x20) == 0;
      goto LABEL_14;
    }
    if ( a2 == 11 )
    {
      v4 = (a1 & 0x40) == 0;
      goto LABEL_14;
    }
    if ( a1 == 0xFFFF )
      return result;
    return 1630;
  }
  if ( !(a1 & 8) )
    return 1630;
  if ( a1 == 72 )
  {
    v6 = a3 < 8;
    v7 = a3 == 8;
  }
  else
  {
    if ( a1 != 24 )
      return result;
    v6 = a3 < 4;
    v7 = a3 == 4;
  }
  if ( !v6 && !v7 )
    result = 1629;
  return result;
}

//----- (77E2F175) --------------------------------------------------------
int __stdcall QueryValueInternalW(HKEY hKey, LPCWSTR lpValueName, int a3, LPDWORD lpType, LPBYTE lpData, ULONG Flags)
{
  ULONG v6; // esi@1
  DWORD *v7; // edi@3
  int v8; // eax@6
  signed int v9; // eax@6
  DWORD cbData; // [sp+Ch] [bp-4h]@1

  v6 = Flags;
  cbData = 0;
  if ( lpData )
    Flags = *(_DWORD *)Flags;
  else
    Flags = 0;
  v7 = lpType;
  if ( !lpType )
    v7 = (DWORD *)&lpType;
  if ( !v6 )
    v6 = (ULONG)&cbData;
  v8 = RegQueryValueExW(hKey, lpValueName, 0, v7, lpData, (LPDWORD)v6);
  v9 = FixRegData(hKey, lpValueName, a3, (int)v7, (int)lpData, v6 != (_DWORD)&cbData ? v6 : 0, Flags, v8, 0);
  return RestrictRegType(a3, *v7, *(_DWORD *)v6, v9);
}

//----- (77E2F239) --------------------------------------------------------
DWORD __stdcall FlsAllocStub(PFLS_CALLBACK_FUNCTION lpCallback)
{
  return FlsAlloc(lpCallback);
}

//----- (77E2F251) --------------------------------------------------------
void __stdcall LoadAppInitDlls()
{
  int Dst; // [sp+4h] [bp-10h]@6
  size_t Size; // [sp+8h] [bp-Ch]@6
  int v2; // [sp+Ch] [bp-8h]@3
  HKEY phkResult; // [sp+10h] [bp-4h]@5

  if ( !v7FFE02EC
    && !(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved2[0] & 2)
    && (!BasepIsServiceSidBlocked((int)&v2) || !v2)
    && !RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows",
          0,
          0x20019u,
          &phkResult) )
  {
    Size = 4;
    if ( !RegGetValueW(phkResult, 0, L"LoadAppInit_DLLs", 16, 0, &Dst, (size_t)&Size) )
    {
      if ( Dst )
        BasepLoadAppInitDlls(phkResult);
    }
    RegCloseKey(phkResult);
  }
}

//----- (77E2F36F) --------------------------------------------------------
int __stdcall BasepIsServiceSidBlocked(int a1)
{
  HANDLE v1; // eax@1
  PVOID v2; // eax@3
  ACL *v3; // edi@3
  unsigned int v4; // esi@4
  char SecurityDescriptor; // [sp+4h] [bp-84h]@9
  GENERIC_MAPPING GenericMapping; // [sp+18h] [bp-70h]@9
  DWORD PrivilegeSetLength; // [sp+28h] [bp-60h]@9
  PVOID Address; // [sp+2Ch] [bp-5Ch]@3
  BOOL AccessStatus; // [sp+30h] [bp-58h]@1
  DWORD GrantedAccess; // [sp+34h] [bp-54h]@1
  int v12; // [sp+38h] [bp-50h]@1
  int v13; // [sp+3Ch] [bp-4Ch]@1
  HANDLE TokenHandle; // [sp+40h] [bp-48h]@1
  HANDLE DuplicateTokenHandle; // [sp+44h] [bp-44h]@1
  PSID pSid; // [sp+48h] [bp-40h]@1
  struct _PRIVILEGE_SET PrivilegeSet; // [sp+4Ch] [bp-3Ch]@9

  v13 = a1;
  GrantedAccess = 0;
  AccessStatus = 0;
  DuplicateTokenHandle = 0;
  TokenHandle = 0;
  v12 = 0;
  pSid = 0;
  v1 = GetCurrentProcess();
  if ( OpenProcessToken(v1, 0xAu, &TokenHandle) )
  {
    if ( DuplicateToken(TokenHandle, SecurityImpersonation, &DuplicateTokenHandle) )
    {
      v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x148u);
      v3 = (ACL *)v2;
      Address = v2;
      if ( v2 )
      {
        RtlCreateAcl((PACL)v2, 0x148u, 2u);
        v4 = 0;
        while ( 1 )
        {
          if ( pSid )
          {
            FreeSid(pSid);
            pSid = 0;
          }
          if ( !AllocateAndInitializeSid(
                  &BasepNtIdentifierAuthority,
                  BasepBlockedServiceSids[v4 * 4],
                  dword_77EA6BF4[v4],
                  dword_77EA6BF8[v4],
                  dword_77EA6BFC[v4],
                  dword_77EA6C00[v4],
                  dword_77EA6C04[v4],
                  dword_77EA6C08[v4],
                  dword_77EA6C0C[v4],
                  dword_77EA6C10[v4],
                  &pSid) )
            break;
          RtlAddAccessAllowedAce(v3, 2u, 1u, pSid);
          v4 += 9;
          if ( v4 >= 36 )
          {
            RtlCreateSecurityDescriptor(&SecurityDescriptor, 1u);
            RtlSetOwnerSecurityDescriptor(&SecurityDescriptor, pSid, 0);
            RtlSetGroupSecurityDescriptor(&SecurityDescriptor, pSid, 0);
            RtlSetDaclSecurityDescriptor(&SecurityDescriptor, 1u, v3, 0);
            GenericMapping.GenericWrite = 0x20000;
            GenericMapping.GenericExecute = 0x20000;
            GenericMapping.GenericRead = 131073;
            GenericMapping.GenericAll = 2031617;
            PrivilegeSetLength = 56;
            if ( AccessCheck(
                   &SecurityDescriptor,
                   DuplicateTokenHandle,
                   1u,
                   &GenericMapping,
                   &PrivilegeSet,
                   &PrivilegeSetLength,
                   &GrantedAccess,
                   &AccessStatus) )
            {
              *(_DWORD *)v13 = AccessStatus && GrantedAccess == 1;
              v12 = 1;
            }
            break;
          }
        }
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      }
    }
  }
  if ( pSid )
    FreeSid(pSid);
  if ( DuplicateTokenHandle )
    CloseHandle(DuplicateTokenHandle);
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  return v12;
}
// 77EA6BF4: using guessed type int dword_77EA6BF4[];
// 77EA6BF8: using guessed type int dword_77EA6BF8[];
// 77EA6BFC: using guessed type int dword_77EA6BFC[];
// 77EA6C00: using guessed type int dword_77EA6C00[];
// 77EA6C04: using guessed type int dword_77EA6C04[];
// 77EA6C08: using guessed type int dword_77EA6C08[];
// 77EA6C0C: using guessed type int dword_77EA6C0C[];
// 77EA6C10: using guessed type int dword_77EA6C10[];

//----- (77E2F5AB) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
  LPTOP_LEVEL_EXCEPTION_FILTER v1; // esi@1
  volatile LONG v2; // ebx@4
  int v3; // esi@9
  const void *v4; // eax@9
  LONG (__stdcall *v5)(struct _EXCEPTION_POINTERS *); // esi@9
  int v7; // eax@12
  LONG v8; // eax@12
  int v9; // [sp+8h] [bp-220h]@2
  int lpTopLevelExceptionFiltera; // [sp+230h] [bp+8h]@5

  v1 = lpTopLevelExceptionFilter;
  if ( !lpTopLevelExceptionFilter )
    goto LABEL_21;
  if ( !BasepFillUEFInfo(lpTopLevelExceptionFilter, (int)&v9) )
    v1 = 0;
  if ( v1 )
  {
    v2 = BasepFilterInfo;
    if ( !BasepFilterInfo )
    {
      v7 = KernelBaseGetGlobalData();
      v8 = (LONG)RtlAllocateHeap(
                   NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                   *(_DWORD *)(v7 + 44) + 2883584,
                   0x440u);
      v2 = v8;
      if ( v8 )
      {
        if ( InterlockedCompareExchange(&BasepFilterInfo, v8, 0) )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v2);
          v2 = BasepFilterInfo;
        }
      }
      else
      {
        v1 = 0;
      }
    }
  }
  else
  {
LABEL_21:
    v2 = 0;
  }
  lpTopLevelExceptionFiltera = RtlEncodePointer(v1);
  RtlAcquireSRWLockExclusive(&BasepUEFLock);
  if ( v1 )
  {
    qmemcpy((void *)v2, &v9, 0x220u);
    if ( *(_DWORD *)(v2 + 8) & 0x1040000 )
    {
      if ( *(_DWORD *)(v2 + 16) )
        *(_DWORD *)(v2 + 16) = v2 + 20;
    }
  }
  v3 = BasepCurrentTopLevelFilter;
  BasepCurrentTopLevelFilter = lpTopLevelExceptionFiltera;
  RtlReleaseSRWLockExclusive(&BasepUEFLock);
  v4 = (const void *)RtlDecodePointer(v3);
  v5 = (LONG (__stdcall *)(struct _EXCEPTION_POINTERS *))v4;
  if ( v4 && !BasepFillUEFInfo(v4, 0) )
    v5 = 0;
  return v5;
}
// 77DE1368: using guessed type int __stdcall RtlEncodePointer(_DWORD);
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77DE1668: using guessed type int __stdcall RtlDecodePointer(_DWORD);
// 77EA657C: using guessed type int BasepCurrentTopLevelFilter;
// 77EA678C: using guessed type int BasepUEFLock;

//----- (77E2F670) --------------------------------------------------------
int __stdcall BasepFillUEFInfo(LPCVOID lpAddress, int a2)
{
  DWORD v2; // eax@5
  int v3; // ecx@5
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+8h] [bp-2Ch]@1
  char MemoryInformation; // [sp+24h] [bp-10h]@4
  int v7; // [sp+30h] [bp-4h]@5

  if ( VirtualQuery(lpAddress, &Buffer, 0x1Cu) && Buffer.AllocationProtect & 0xF0 )
  {
    if ( !a2 )
      return 1;
    if ( NtQueryVirtualMemory(
           (HANDLE)0xFFFFFFFF,
           (PVOID)lpAddress,
           MemoryBasicVlmInformation,
           &MemoryInformation,
           0x10u,
           0) >= 0 )
    {
      v2 = Buffer.Type;
      *(_DWORD *)a2 = Buffer.AllocationBase;
      v3 = v7;
      *(_DWORD *)(a2 + 8) = v2;
      *(_DWORD *)(a2 + 4) = v3;
      if ( v2 & 0x1040000 )
      {
        if ( NtQueryVirtualMemory((HANDLE)0xFFFFFFFF, (PVOID)lpAddress, MemorySectionName, (PVOID)(a2 + 12), 0x212u, 0) < 0 )
        {
          *(_DWORD *)(a2 + 16) = 0;
          *(_WORD *)(a2 + 12) = 0;
          *(_WORD *)(a2 + 14) = 0;
        }
      }
      return 1;
    }
  }
  return 0;
}

//----- (77E2F74C) --------------------------------------------------------
BOOL __stdcall SetEnvironmentVariableWStub(LPCWSTR lpName, LPCWSTR lpValue)
{
  return SetEnvironmentVariableW(lpName, lpValue);
}

//----- (77E2F764) --------------------------------------------------------
BOOL __stdcall HeapSetInformationStub(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
{
  return HeapSetInformation(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
}

//----- (77E2F787) --------------------------------------------------------
DWORD __stdcall GetFullPathNameWStub(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
{
  return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
}

//----- (77E2F7EC) --------------------------------------------------------
BOOL __stdcall UnmapViewOfFileStub(LPCVOID lpBaseAddress)
{
  return UnmapViewOfFile(lpBaseAddress);
}

//----- (77E2F810) --------------------------------------------------------
LPVOID __stdcall TlsGetValueStub(DWORD dwTlsIndex)
{
  return TlsGetValue(dwTlsIndex);
}

//----- (77E2F833) --------------------------------------------------------
BOOL __stdcall TlsSetValueStub(DWORD dwTlsIndex, LPVOID lpTlsValue)
{
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (77E2F840) --------------------------------------------------------
ULONG __stdcall BaseSetLastNTError(NTSTATUS NtStatus)
{
  ULONG v1; // esi@1

  v1 = RtlNtStatusToDosError(NtStatus);
  RtlSetLastWin32Error(v1);
  return v1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E2F879) --------------------------------------------------------
int __stdcall GetLocaleInfoWStub(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
{
  return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);
}

//----- (77E2F891) --------------------------------------------------------
int __stdcall SortCompareString(int a1, unsigned int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  unsigned int v9; // ebx@3
  int v11; // [sp+10h] [bp-90h]@7
  unsigned int v12; // [sp+14h] [bp-8Ch]@11
  unsigned int v13; // [sp+18h] [bp-88h]@11
  unsigned int v14; // [sp+1Ch] [bp-84h]@11
  unsigned int v15; // [sp+20h] [bp-80h]@11
  unsigned int v16; // [sp+24h] [bp-7Ch]@11
  unsigned int v17; // [sp+28h] [bp-78h]@11
  unsigned int v18; // [sp+2Ch] [bp-74h]@11
  int v19; // [sp+30h] [bp-70h]@11
  int v20; // [sp+34h] [bp-6Ch]@11
  int v21; // [sp+38h] [bp-68h]@7
  int v22; // [sp+3Ch] [bp-64h]@7
  int v23; // [sp+40h] [bp-60h]@11
  int v24; // [sp+44h] [bp-5Ch]@7
  int v25; // [sp+48h] [bp-58h]@8
  unsigned int v26; // [sp+4Ch] [bp-54h]@7
  int v27; // [sp+54h] [bp-4Ch]@7
  int v28; // [sp+58h] [bp-48h]@11
  int v29; // [sp+64h] [bp-3Ch]@11
  int v30; // [sp+68h] [bp-38h]@9
  int v31; // [sp+6Ch] [bp-34h]@10
  unsigned int v32; // [sp+70h] [bp-30h]@7
  int v33; // [sp+78h] [bp-28h]@9
  int v34; // [sp+7Ch] [bp-24h]@11
  int v35; // [sp+88h] [bp-18h]@11
  int v36; // [sp+8Ch] [bp-14h]@11
  int v37; // [sp+90h] [bp-10h]@11
  int v38; // [sp+94h] [bp-Ch]@11

  v8 = a1;
  if ( !a3 || !a5 )
  {
    SetLastError(0x57u);
    return 0;
  }
  v9 = a2;
  if ( a2 & 0xA7FCEFC0
    || (unsigned __int8)a2 & (unsigned __int8)((a2 & 0xE2) - 1) & 0x22
    || (unsigned __int8)a2 & (unsigned __int8)((a2 & 0xF1) - 1) & 0x11 )
  {
    SetLastError(0x3ECu);
    return 0;
  }
  if ( !(a2 & 0x8000000) )
    v8 = *(_DWORD *)(a1 + 276);
  v11 = v8;
  v22 = *(_DWORD *)(v8 + 240) & 1;
  v32 = a2 & 0x10000000;
  v26 = a2 & 0x10000000;
  v21 = 0;
  v24 = a3;
  v27 = a3;
  if ( a4 >= 0 )
  {
    v21 = 1;
    v25 = a3 + 2 * a4;
  }
  else
  {
    v25 = -1;
    v26 = 1;
  }
  v30 = a5;
  v33 = a5;
  if ( a6 >= 0 )
  {
    v21 = 1;
    v31 = a5 + 2 * a6;
  }
  else
  {
    v31 = -1;
    v32 = 1;
  }
  v14 = (a2 >> 1) & 1;
  v13 = (a2 >> 2) & 1;
  v15 = (a2 >> 2) & 1;
  v23 = -1;
  v12 = (a2 >> 12) & 1;
  v16 = (a2 >> 4) & 1;
  v17 = (a2 >> 5) & 1;
  v18 = (a2 >> 3) & 1;
  v28 = 0;
  v34 = 0;
  v37 = 0;
  v38 = 0;
  v29 = 0;
  v35 = 0;
  v19 = 0;
  v20 = 0;
  v36 = 196;
  if ( a2 & 1 )
    v23 = -402653185;
  if ( a2 & 2 )
    v23 &= 0xFF00FFFF;
  else
    v36 = ((*(_DWORD *)(v8 + 228) != 0) + 1) | 0xF4;
  if ( v9 & 0x10000 )
    v23 &= 0xDFFFFFFF;
  if ( v9 & 0x20000 )
  {
    v23 &= 0xFEFFFFFF;
    if ( a2 & 1 )
      v36 &= 0xFFFFFFFB;
  }
  return LongCompareString((int)&v11);
}

//----- (77E2FA2E) --------------------------------------------------------
int __stdcall LongCompareString(int a1)
{
  __int16 v1; // cx@81
  unsigned __int8 v2; // al@89
  char v3; // cl@89
  char v4; // cl@89
  int v5; // eax@90
  bool v6; // zf@101
  unsigned __int8 v7; // al@107
  char v8; // cl@107
  char v9; // cl@107
  int v10; // eax@108
  int v11; // eax@120
  unsigned int v12; // eax@121
  __int16 v13; // ax@122
  signed int v14; // eax@125
  unsigned __int8 v15; // al@128
  unsigned __int8 v16; // cl@128
  int v17; // edx@129
  char v18; // al@130
  char v19; // cl@132
  char v20; // al@134
  char v21; // cl@136
  unsigned __int8 v22; // al@137
  int v23; // eax@138
  unsigned int v24; // eax@139
  __int16 v25; // ax@140
  int v26; // eax@142
  unsigned int v27; // eax@143
  __int16 v28; // ax@144
  unsigned __int8 v29; // al@149
  int v30; // ecx@152
  int v31; // edx@158
  char v32; // cl@159
  char v33; // al@161
  bool v34; // zf@174
  int v35; // eax@176
  unsigned int v36; // eax@177
  __int16 v37; // ax@178
  signed int v38; // eax@187
  bool v39; // zf@188
  int v40; // eax@190
  unsigned int v41; // eax@191
  __int16 v42; // ax@192
  int v43; // eax@199
  unsigned int v44; // eax@200
  __int16 v45; // ax@201
  int v46; // edi@207
  unsigned int v47; // eax@207
  unsigned int v48; // eax@208
  unsigned int v49; // eax@209
  int v50; // eax@211
  unsigned int v51; // eax@212
  __int16 v52; // ax@213
  __int16 v53; // ax@234
  int v54; // eax@235
  unsigned int v55; // eax@236
  __int16 v56; // ax@237
  int v57; // eax@238
  int v58; // eax@239
  unsigned int v59; // eax@240
  __int16 v60; // ax@246
  int v61; // esi@257
  unsigned __int16 v62; // ax@260
  int v63; // eax@264
  int v64; // eax@265
  int v65; // eax@268
  int v66; // eax@269
  unsigned int v67; // eax@272
  unsigned int v68; // eax@280
  __int16 v69; // dx@289
  int v70; // ecx@290
  int v71; // eax@290
  int v72; // eax@291
  int v73; // ecx@291
  int v74; // eax@302
  unsigned int v75; // eax@303
  __int16 v76; // ax@304
  int v77; // eax@310
  unsigned int v78; // eax@311
  __int16 v79; // ax@312
  unsigned int v80; // eax@317
  int v81; // ecx@318
  int v82; // ebx@326
  unsigned int v83; // eax@326
  unsigned int v84; // eax@327
  unsigned int v85; // eax@328
  int v86; // esi@1
  int v87; // eax@5
  int i; // ecx@5
  unsigned int v89; // eax@9
  unsigned int v90; // edi@9
  int v91; // edi@10
  int v92; // ebx@15
  int v93; // edx@29
  unsigned int v94; // eax@29
  int v95; // eax@30
  int v96; // edx@33
  unsigned int v97; // eax@33
  int v98; // eax@34
  int v99; // edx@36
  int v100; // edx@37
  int v101; // eax@41
  unsigned __int8 v102; // dl@46
  __int16 v103; // ax@47
  __int16 v104; // cx@47
  int v105; // edx@50
  int v106; // ecx@51
  bool v107; // cf@63
  int result; // eax@64
  __int16 v109; // dx@66
  __int16 v110; // dx@68
  __int16 v111; // dx@70
  __int16 v112; // dx@72
  __int16 v113; // dx@74
  __int16 v114; // dx@76
  __int16 v115; // dx@78
  unsigned __int8 v116; // al@347
  unsigned __int8 v117; // al@349
  unsigned __int8 v118; // al@351
  unsigned __int8 v119; // al@353
  unsigned int v120; // eax@355
  int v121; // ecx@360
  unsigned int v122; // eax@360
  int v123; // eax@361
  int v124; // eax@362
  bool v125; // cf@391
  int v126; // ecx@395
  bool v127; // sf@421
  unsigned __int8 v128; // of@421
  int v129; // eax@345
  unsigned int v130; // ecx@429
  int v131; // ecx@431
  int v132; // edx@433
  unsigned int v133; // eax@433
  int v134; // ecx@435
  unsigned int v135; // eax@435
  int v136; // eax@437
  int v137; // eax@440
  int v138; // eax@445
  unsigned int v139; // edx@446
  int v140; // ecx@450
  int v141; // edx@452
  unsigned int v142; // eax@452
  int v143; // ecx@454
  unsigned int v144; // eax@454
  int v145; // eax@459
  int v146; // eax@466
  unsigned int v147; // edx@467
  int v148; // ecx@471
  int v149; // edx@473
  unsigned int v150; // eax@473
  int v151; // ecx@475
  unsigned int v152; // eax@475
  int v153; // eax@480
  int v154; // eax@487
  unsigned int v155; // edx@488
  int v156; // edx@494
  unsigned int v157; // eax@494
  int v158; // ecx@496
  unsigned int v159; // eax@496
  int v160; // eax@501
  int v161; // eax@508
  unsigned int v162; // edx@509
  int v163; // edx@515
  unsigned int v164; // eax@515
  int v165; // ecx@517
  unsigned int v166; // eax@517
  int v167; // eax@522
  int v168; // eax@529
  unsigned int v169; // edx@530
  int v170; // edx@536
  unsigned int v171; // eax@536
  int v172; // ecx@538
  unsigned int v173; // eax@538
  int v174; // eax@543
  int v175; // eax@550
  unsigned int v176; // edx@551
  int v177; // edx@557
  int v178; // ecx@557
  unsigned int v179; // eax@557
  unsigned int v180; // eax@559
  int v181; // eax@564
  int v182; // eax@574
  unsigned int v183; // edx@575
  int v184; // ecx@577
  int v185; // edx@579
  unsigned int v186; // eax@579
  int v187; // ecx@581
  unsigned int v188; // eax@581
  int v189; // eax@583
  int v190; // eax@586
  int v191; // eax@591
  unsigned int v192; // edx@592
  int v193; // ecx@596
  int v194; // edx@598
  unsigned int v195; // eax@598
  int v196; // ecx@600
  unsigned int v197; // eax@600
  int v198; // eax@605
  int v199; // eax@612
  unsigned int v200; // edx@613
  int v201; // ecx@617
  int v202; // edx@619
  unsigned int v203; // eax@619
  int v204; // ecx@621
  unsigned int v205; // eax@621
  int v206; // eax@626
  int v207; // eax@633
  unsigned int v208; // edx@634
  int v209; // edx@640
  unsigned int v210; // eax@640
  int v211; // ecx@642
  unsigned int v212; // eax@642
  int v213; // eax@647
  int v214; // eax@654
  unsigned int v215; // edx@655
  int v216; // edx@661
  unsigned int v217; // eax@661
  int v218; // ecx@663
  unsigned int v219; // eax@663
  int v220; // eax@668
  int v221; // eax@675
  unsigned int v222; // edx@676
  int v223; // edx@682
  unsigned int v224; // eax@682
  int v225; // ecx@684
  unsigned int v226; // eax@684
  int v227; // eax@689
  int v228; // eax@696
  unsigned int v229; // edx@697
  int v230; // edx@703
  int v231; // ecx@703
  unsigned int v232; // eax@703
  unsigned int v233; // eax@705
  int v234; // eax@710
  unsigned __int8 v235; // al@740
  unsigned __int8 v236; // cl@740
  unsigned __int8 v237; // al@743
  unsigned __int8 v238; // cl@743
  int v239; // eax@747
  int v240; // eax@748
  int v241; // ecx@751
  unsigned int v242; // eax@751
  int v243; // eax@753
  int v244; // eax@755
  int v245; // eax@758
  int v246; // eax@759
  int v247; // eax@760
  __int16 v248; // ax@760
  unsigned int v249; // eax@761
  int v250; // eax@764
  int v251; // eax@765
  __int16 v252; // ax@765
  unsigned int v253; // eax@766
  int v254; // edx@770
  int v255; // ecx@771
  unsigned int v256; // eax@772
  unsigned int v257; // ecx@774
  __int16 v258; // cx@782
  unsigned __int8 v259; // al@793
  unsigned __int8 v260; // cl@796
  unsigned __int8 v261; // al@799
  unsigned __int8 v262; // cl@802
  int v263; // eax@807
  int v264; // eax@808
  int v265; // edx@809
  int v266; // ecx@810
  unsigned int v267; // eax@811
  unsigned int v268; // ecx@813
  __int16 v269; // cx@821
  int v270; // eax@830
  int v271; // edx@832
  unsigned __int8 v272; // cl@833
  unsigned __int8 v273; // al@836
  unsigned __int8 v274; // cl@836
  unsigned __int8 v275; // al@839
  unsigned __int8 v276; // cl@839
  unsigned __int8 v277; // al@842
  unsigned __int8 v278; // cl@842
  unsigned __int8 v279; // al@852
  unsigned __int8 v280; // cl@852
  int v281; // eax@855
  int v282; // edx@859
  signed __int16 v283; // cx@861
  int v284; // ecx@862
  __int16 v285; // ax@866
  int v286; // eax@867
  unsigned int v287; // ecx@870
  signed __int16 v288; // cx@872
  int v289; // ecx@873
  int v290; // eax@879
  __int16 v291; // ax@879
  unsigned int v292; // eax@880
  int v293; // eax@885
  int v294; // edx@889
  signed __int16 v295; // cx@891
  int v296; // ecx@892
  __int16 v297; // ax@896
  int v298; // eax@897
  unsigned int v299; // ecx@907
  int v300; // eax@908
  int v301; // eax@909
  __int16 v302; // ax@909
  unsigned int v303; // eax@910
  int v304; // eax@917
  int v305; // edx@919
  bool v306; // zf@83
  int v307; // eax@926
  int v308; // eax@931
  signed int v310; // [sp+Ch] [bp-28h]@282
  int v311; // [sp+Ch] [bp-28h]@435
  int v312; // [sp+Ch] [bp-28h]@454
  int v313; // [sp+Ch] [bp-28h]@475
  int v314; // [sp+Ch] [bp-28h]@496
  int v315; // [sp+Ch] [bp-28h]@517
  int v316; // [sp+Ch] [bp-28h]@538
  int v317; // [sp+Ch] [bp-28h]@559
  int v318; // [sp+Ch] [bp-28h]@581
  int v319; // [sp+Ch] [bp-28h]@600
  int v320; // [sp+Ch] [bp-28h]@621
  int v321; // [sp+Ch] [bp-28h]@642
  int v322; // [sp+Ch] [bp-28h]@663
  int v323; // [sp+Ch] [bp-28h]@684
  int v324; // [sp+Ch] [bp-28h]@705
  signed int v325; // [sp+10h] [bp-24h]@274
  int v326; // [sp+10h] [bp-24h]@280
  int v327; // [sp+10h] [bp-24h]@431
  int v328; // [sp+10h] [bp-24h]@450
  int v329; // [sp+10h] [bp-24h]@471
  int v330; // [sp+10h] [bp-24h]@492
  int v331; // [sp+10h] [bp-24h]@513
  int v332; // [sp+10h] [bp-24h]@534
  int v333; // [sp+10h] [bp-24h]@555
  int v334; // [sp+10h] [bp-24h]@577
  int v335; // [sp+10h] [bp-24h]@596
  int v336; // [sp+10h] [bp-24h]@617
  int v337; // [sp+10h] [bp-24h]@638
  int v338; // [sp+10h] [bp-24h]@659
  int v339; // [sp+10h] [bp-24h]@680
  int v340; // [sp+10h] [bp-24h]@701
  signed __int16 v341; // [sp+14h] [bp-20h]@260
  int v342; // [sp+14h] [bp-20h]@440
  int v343; // [sp+14h] [bp-20h]@459
  int v344; // [sp+14h] [bp-20h]@480
  int v345; // [sp+14h] [bp-20h]@501
  int v346; // [sp+14h] [bp-20h]@522
  int v347; // [sp+14h] [bp-20h]@543
  int v348; // [sp+14h] [bp-20h]@555
  int v349; // [sp+14h] [bp-20h]@586
  int v350; // [sp+14h] [bp-20h]@605
  int v351; // [sp+14h] [bp-20h]@626
  int v352; // [sp+14h] [bp-20h]@647
  int v353; // [sp+14h] [bp-20h]@668
  int v354; // [sp+14h] [bp-20h]@689
  int v355; // [sp+14h] [bp-20h]@701
  signed int v356; // [sp+14h] [bp-20h]@771
  signed int v357; // [sp+14h] [bp-20h]@810
  signed __int16 v358; // [sp+18h] [bp-1Ch]@260
  signed int v359; // [sp+18h] [bp-1Ch]@431
  signed int v360; // [sp+18h] [bp-1Ch]@450
  signed int v361; // [sp+18h] [bp-1Ch]@471
  signed int v362; // [sp+18h] [bp-1Ch]@492
  signed int v363; // [sp+18h] [bp-1Ch]@513
  signed int v364; // [sp+18h] [bp-1Ch]@534
  signed int v365; // [sp+18h] [bp-1Ch]@555
  signed int v366; // [sp+18h] [bp-1Ch]@577
  signed int v367; // [sp+18h] [bp-1Ch]@596
  signed int v368; // [sp+18h] [bp-1Ch]@617
  signed int v369; // [sp+18h] [bp-1Ch]@638
  signed int v370; // [sp+18h] [bp-1Ch]@659
  signed int v371; // [sp+18h] [bp-1Ch]@680
  signed int v372; // [sp+18h] [bp-1Ch]@701
  signed int v373; // [sp+1Ch] [bp-18h]@260
  int v374; // [sp+1Ch] [bp-18h]@428
  int v375; // [sp+1Ch] [bp-18h]@445
  int v376; // [sp+1Ch] [bp-18h]@466
  int v377; // [sp+1Ch] [bp-18h]@487
  int v378; // [sp+1Ch] [bp-18h]@508
  int v379; // [sp+1Ch] [bp-18h]@529
  int v380; // [sp+1Ch] [bp-18h]@550
  int v381; // [sp+1Ch] [bp-18h]@574
  int v382; // [sp+1Ch] [bp-18h]@591
  int v383; // [sp+1Ch] [bp-18h]@612
  int v384; // [sp+1Ch] [bp-18h]@633
  int v385; // [sp+1Ch] [bp-18h]@654
  int v386; // [sp+1Ch] [bp-18h]@675
  int v387; // [sp+1Ch] [bp-18h]@696
  unsigned __int16 v388; // [sp+20h] [bp-14h]@260
  int v389; // [sp+20h] [bp-14h]@771
  int v390; // [sp+20h] [bp-14h]@810
  signed int v391; // [sp+24h] [bp-10h]@260
  int v392; // [sp+28h] [bp-Ch]@272
  unsigned __int16 v393; // [sp+2Ch] [bp-8h]@260
  int v394; // [sp+2Ch] [bp-8h]@411
  int v395; // [sp+2Ch] [bp-8h]@414
  int v396; // [sp+2Ch] [bp-8h]@774
  int v397; // [sp+2Ch] [bp-8h]@813
  char v398; // [sp+31h] [bp-3h]@89
  char v399; // [sp+31h] [bp-3h]@107
  unsigned __int8 v400; // [sp+32h] [bp-2h]@89
  unsigned __int8 v401; // [sp+32h] [bp-2h]@107
  unsigned __int8 v402; // [sp+32h] [bp-2h]@133
  char v403; // [sp+32h] [bp-2h]@155
  unsigned __int8 v404; // [sp+33h] [bp-1h]@41
  char v405; // [sp+33h] [bp-1h]@854
  char v406; // [sp+33h] [bp-1h]@884
  int v407; // [sp+3Ch] [bp+8h]@429
  int v408; // [sp+3Ch] [bp+8h]@431
  int v409; // [sp+3Ch] [bp+8h]@446
  int v410; // [sp+3Ch] [bp+8h]@450
  int v411; // [sp+3Ch] [bp+8h]@467
  int v412; // [sp+3Ch] [bp+8h]@471
  int v413; // [sp+3Ch] [bp+8h]@488
  int v414; // [sp+3Ch] [bp+8h]@492
  int v415; // [sp+3Ch] [bp+8h]@509
  int v416; // [sp+3Ch] [bp+8h]@513
  int v417; // [sp+3Ch] [bp+8h]@530
  int v418; // [sp+3Ch] [bp+8h]@534
  int v419; // [sp+3Ch] [bp+8h]@551
  int v420; // [sp+3Ch] [bp+8h]@564
  int v421; // [sp+3Ch] [bp+8h]@575
  int v422; // [sp+3Ch] [bp+8h]@577
  int v423; // [sp+3Ch] [bp+8h]@592
  int v424; // [sp+3Ch] [bp+8h]@596
  int v425; // [sp+3Ch] [bp+8h]@613
  int v426; // [sp+3Ch] [bp+8h]@617
  int v427; // [sp+3Ch] [bp+8h]@634
  int v428; // [sp+3Ch] [bp+8h]@638
  int v429; // [sp+3Ch] [bp+8h]@655
  int v430; // [sp+3Ch] [bp+8h]@659
  int v431; // [sp+3Ch] [bp+8h]@676
  int v432; // [sp+3Ch] [bp+8h]@680
  int v433; // [sp+3Ch] [bp+8h]@697
  int v434; // [sp+3Ch] [bp+8h]@710
  char v435; // [sp+3Fh] [bp+Bh]@153
  unsigned __int8 v436; // [sp+3Fh] [bp+Bh]@37
  unsigned __int8 v437; // [sp+3Fh] [bp+Bh]@884

  v86 = a1;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 232) && !*(_DWORD *)(a1 + 28) && !*(_DWORD *)(a1 + 32) )
  {
    if ( *(_DWORD *)(a1 + 40) )
    {
      while ( !*(_DWORD *)(a1 + 60) || **(_WORD **)(a1 + 68) )
      {
        if ( *(_DWORD *)(a1 + 68) >= *(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 96) && !**(_WORD **)(a1 + 104) )
          break;
        v80 = *(_DWORD *)(a1 + 104);
        if ( v80 >= *(_DWORD *)(a1 + 92) )
          break;
        v81 = *(_DWORD *)(a1 + 68);
        if ( *(_WORD *)v81 != *(_WORD *)v80 )
          break;
        *(_DWORD *)(a1 + 68) = v81 + 2;
        *(_DWORD *)(a1 + 104) = v80 + 2;
      }
      if ( (*(_DWORD *)(a1 + 60) && !**(_WORD **)(a1 + 68) || *(_DWORD *)(a1 + 68) >= *(_DWORD *)(a1 + 56))
        && (*(_DWORD *)(a1 + 96) && !**(_WORD **)(a1 + 104) || *(_DWORD *)(a1 + 104) >= *(_DWORD *)(a1 + 92)) )
        return 2;
    }
    else
    {
      v87 = *(_DWORD *)(a1 + 68);
      for ( i = *(_DWORD *)(a1 + 104); *(_WORD *)v87 && *(_WORD *)v87 == *(_WORD *)i; i += 16 )
      {
        v109 = *(_WORD *)(v87 + 2);
        if ( !v109 || v109 != *(_WORD *)(i + 2) )
        {
          v87 += 2;
          i += 2;
          break;
        }
        v110 = *(_WORD *)(v87 + 4);
        if ( !v110 || v110 != *(_WORD *)(i + 4) )
        {
          v87 += 4;
          i += 4;
          break;
        }
        v111 = *(_WORD *)(v87 + 6);
        if ( !v111 || v111 != *(_WORD *)(i + 6) )
        {
          v87 += 6;
          i += 6;
          break;
        }
        v112 = *(_WORD *)(v87 + 8);
        if ( !v112 || v112 != *(_WORD *)(i + 8) )
        {
          v87 += 8;
          i += 8;
          break;
        }
        v113 = *(_WORD *)(v87 + 10);
        if ( !v113 || v113 != *(_WORD *)(i + 10) )
        {
          v87 += 10;
          i += 10;
          break;
        }
        v114 = *(_WORD *)(v87 + 12);
        if ( !v114 || v114 != *(_WORD *)(i + 12) )
        {
          v87 += 12;
          i += 12;
          break;
        }
        v115 = *(_WORD *)(v87 + 14);
        if ( !v115 || v115 != *(_WORD *)(i + 14) )
        {
          v87 += 14;
          i += 14;
          break;
        }
        v87 += 16;
      }
      *(_DWORD *)(a1 + 68) = v87;
      *(_DWORD *)(a1 + 104) = i;
      if ( *(_WORD *)v87 == *(_WORD *)i )
        return 2;
    }
    v89 = *(_DWORD *)(a1 + 68);
    v90 = *(_DWORD *)(a1 + 52);
    if ( v89 > v90 && IsCombiningJamo(*(_WORD *)(v89 - 2)) )
    {
      v129 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 68) = v90;
      *(_DWORD *)(a1 + 104) = v129;
    }
  }
  *(_DWORD *)(a1 + 76) = -1;
  *(_DWORD *)(a1 + 112) = -1;
  v91 = a1 + 52;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  if ( *(_DWORD *)(a1 + 72)
    || (!*(_DWORD *)(a1 + 60) || **(_WORD **)(a1 + 68)) && *(_DWORD *)(a1 + 68) < *(_DWORD *)(a1 + 56) )
    *(_WORD *)(a1 + 82) = **(_WORD **)(a1 + 68);
  v92 = a1 + 88;
  if ( *(_DWORD *)(a1 + 108)
    || (!*(_DWORD *)(a1 + 96) || **(_WORD **)(a1 + 104)) && *(_DWORD *)(a1 + 104) < *(_DWORD *)(a1 + 92) )
    *(_WORD *)(a1 + 118) = **(_WORD **)(a1 + 104);
  while ( 1 )
  {
    while ( 1 )
    {
      if ( !*(_DWORD *)(v86 + 72)
        && (*(_DWORD *)(v86 + 60) && !**(_WORD **)(v86 + 68) || *(_DWORD *)(v86 + 68) >= *(_DWORD *)(v86 + 56))
        || !*(_DWORD *)(v86 + 108)
        && (*(_DWORD *)(v86 + 96) && !**(_WORD **)(v86 + 104) || *(_DWORD *)(v86 + 104) >= *(_DWORD *)(v86 + 92)) )
      {
        if ( *(_DWORD *)(v86 + 72)
          || (!*(_DWORD *)(v86 + 60) || **(_WORD **)(v86 + 68)) && *(_DWORD *)(v86 + 68) < *(_DWORD *)(v86 + 56) )
        {
          if ( !*(_DWORD *)(v86 + 32) )
          {
            while ( 1 )
            {
              if ( !*(_DWORD *)(v86 + 72)
                && (*(_DWORD *)(v86 + 60) && !**(_WORD **)(v86 + 68) || *(_DWORD *)(v86 + 68) >= *(_DWORD *)(v86 + 56)) )
                goto LABEL_255;
              v82 = *(_DWORD *)(*(_DWORD *)v86 + 224);
              v83 = *(_WORD *)(v86 + 82);
              v84 = v82 ? *(_DWORD *)((*pSortTblPtrs)[11]
                                    + 4 * (*(_DWORD *)(v82 + 4 * (v83 >> 8)) + (unsigned __int8)v83)) : *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v83);
              v85 = v84 >> 8;
              if ( !(_BYTE)v85 )
                break;
              if ( (_BYTE)v85 != 1 )
              {
                if ( (_BYTE)v85 == 6 )
                {
                  v306 = *(_DWORD *)(v86 + 8) == 0;
                }
                else
                {
                  if ( (unsigned __int8)v85 <= 6u || (unsigned __int8)v85 > 0xCu )
                    return 3;
                  v306 = *(_DWORD *)(v86 + 16) == 0;
                }
LABEL_119:
                if ( v306 )
                  return 3;
                goto LABEL_120;
              }
              if ( !*(_DWORD *)(v86 + 12) && !*(_DWORD *)(v86 + 24) && *(_BYTE *)(v86 + 124) & 3 )
                return 3;
LABEL_120:
              v11 = *(_DWORD *)(v86 + 72);
              if ( v11 > 0 )
              {
                v307 = v11 - 1;
                *(_DWORD *)(v86 + 72) = v307;
                v13 = *(_WORD *)(v91 + 2 * v307 + 12);
              }
              else
              {
                *(_DWORD *)(v86 + 68) += 2;
                v12 = *(_DWORD *)(v86 + 68);
                if ( v12 >= *(_DWORD *)(v86 + 56) )
                  v13 = 0;
                else
                  v13 = *(_WORD *)v12;
              }
              *(_WORD *)(v86 + 82) = v13;
            }
            if ( !*(_DWORD *)(v86 + 36) )
              goto LABEL_120;
            v306 = *(_WORD *)(v86 + 82) == 0;
            goto LABEL_119;
          }
          LOWORD(v120) = *(_WORD *)(v86 + 82);
          if ( (_WORD)v120 != **(_WORD **)(v86 + 68) )
            return 3;
          if ( !*(_DWORD *)(v86 + 12) && !*(_DWORD *)(v86 + 24) && *(_BYTE *)(v86 + 124) & 3 )
          {
            v305 = *(_DWORD *)(*(_DWORD *)v86 + 224);
            v120 = (unsigned __int16)v120;
            if ( v305 )
              v120 = *(_DWORD *)(v305 + 4 * (v120 >> 8)) + (unsigned __int8)v120;
            if ( *(_WORD *)((*pSortTblPtrs)[11] + 4 * v120) >> 8 == 1 )
              return 3;
          }
          goto LABEL_255;
        }
        if ( *(_DWORD *)(v86 + 108) )
          goto LABEL_207;
        if ( *(_DWORD *)(v86 + 96) && !**(_WORD **)(v86 + 104) || *(_DWORD *)(v86 + 104) >= *(_DWORD *)(v86 + 92) )
        {
LABEL_255:
          if ( !*(_DWORD *)(v86 + 32) )
          {
            result = *(_DWORD *)(v86 + 128);
            if ( result )
              return result;
            v61 = *(_DWORD *)(v86 + 132);
            if ( v61 )
              return v61;
          }
          return 2;
        }
        while ( 1 )
        {
          if ( !*(_DWORD *)(v86 + 108)
            && (*(_DWORD *)(v86 + 96) && !**(_WORD **)(v86 + 104) || *(_DWORD *)(v86 + 104) >= *(_DWORD *)(v86 + 92)) )
            goto LABEL_255;
LABEL_207:
          v46 = *(_DWORD *)(*(_DWORD *)v86 + 224);
          v47 = *(_WORD *)(v86 + 118);
          v48 = v46 ? *(_DWORD *)((*pSortTblPtrs)[11] + 4 * (*(_DWORD *)(v46 + 4 * (v47 >> 8)) + (unsigned __int8)v47)) : *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v47);
          v49 = v48 >> 8;
          if ( !(_BYTE)v49 )
            break;
          if ( (_BYTE)v49 != 1 )
          {
            if ( (_BYTE)v49 == 6 )
            {
              v6 = *(_DWORD *)(v86 + 8) == 0;
            }
            else
            {
              if ( (unsigned __int8)v49 <= 6u || (unsigned __int8)v49 > 0xCu )
                return 1;
              v6 = *(_DWORD *)(v86 + 16) == 0;
            }
LABEL_220:
            if ( v6 )
              return 1;
            goto LABEL_211;
          }
          if ( !*(_DWORD *)(v86 + 12) && !*(_DWORD *)(v86 + 24) && *(_BYTE *)(v86 + 124) & 3 )
            return 1;
LABEL_211:
          v50 = *(_DWORD *)(v86 + 108);
          if ( v50 > 0 )
          {
            v308 = v50 - 1;
            *(_DWORD *)(v86 + 108) = v308;
            v52 = *(_WORD *)(v92 + 2 * v308 + 12);
          }
          else
          {
            *(_DWORD *)(v86 + 104) += 2;
            v51 = *(_DWORD *)(v86 + 104);
            if ( v51 < *(_DWORD *)(v86 + 92) )
              v52 = *(_WORD *)v51;
            else
              v52 = 0;
          }
          *(_WORD *)(v86 + 118) = v52;
        }
        if ( !*(_DWORD *)(v86 + 36) )
          goto LABEL_211;
        v6 = *(_WORD *)(v86 + 118) == 0;
        goto LABEL_220;
      }
      if ( *(_DWORD *)(v86 + 76) == -1 )
      {
        v93 = *(_DWORD *)(*(_DWORD *)v86 + 224);
        v94 = *(_WORD *)(v86 + 82);
        if ( v93 )
          v95 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * (*(_DWORD *)(v93 + 4 * (v94 >> 8)) + (unsigned __int8)v94));
        else
          v95 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v94);
        *(_DWORD *)(v86 + 76) = v95;
      }
      if ( *(_DWORD *)(v86 + 112) == -1 )
      {
        v96 = *(_DWORD *)(*(_DWORD *)v86 + 224);
        v97 = *(_WORD *)(v86 + 118);
        if ( v96 )
          v98 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * (*(_DWORD *)(v96 + 4 * (v97 >> 8)) + (unsigned __int8)v97));
        else
          v98 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v97);
        *(_DWORD *)(v86 + 112) = v98;
      }
      v99 = *(_DWORD *)v86;
      if ( *(_DWORD *)(*(_DWORD *)v86 + 232) )
      {
        v394 = 0;
        if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 77) - 3) != 0 ? *(_BYTE *)(v86 + 79) : 0) & 0xC0) != 64 )
        {
          if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 77) - 3) != 0 ? *(_BYTE *)(v86 + 79) : 0) & 0xC0) != 128 )
          {
            if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 77) - 3) != 0 ? *(_BYTE *)(v86 + 79) : 0) & 0xC0) != 192 )
              goto LABEL_414;
            v374 = *(_DWORD *)(v99 + 272);
            if ( *(_WORD *)(*(_DWORD *)(v99 + 244) + 20) )
            {
              v407 = *(_DWORD *)(v99 + 236);
              v130 = *(_DWORD *)(v86 + 56);
              if ( *(_DWORD *)(v86 + 68) + 2 * (8 - (unsigned int)(v407 == 0)) <= v130 )
              {
                v394 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(v86 + 68),
                         v130,
                         8,
                         *(_WORD *)(*(_DWORD *)(v99 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v99 + 244) + 6),
                         v407,
                         *(_DWORD *)(v86 + 60));
                if ( v394 >= 8 )
                {
                  v131 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                  v359 = 0;
                  v327 = 0;
                  v408 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                  if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 9 )
                  {
                    v132 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                    v133 = **(_WORD **)(v86 + 68);
                    if ( v132 )
                      v133 = *(_DWORD *)(v132 + 4 * (v133 >> 8)) + (unsigned __int8)v133;
                    v134 = (*pSortTblPtrs)[11];
                    v311 = *(_DWORD *)(v134 + 4 * v133);
                    v135 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                    if ( v132 )
                    {
                      v135 = *(_DWORD *)(v132 + 4 * (v135 >> 8)) + (unsigned __int8)v135;
                      v134 = (*pSortTblPtrs)[11];
                    }
                    v136 = v311 ^ *(_DWORD *)(v134 + 4 * v135);
                    v131 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                    if ( !(v136 & 0xE7FFFFFF) )
                      v359 = 1;
                  }
                  if ( v131 >= 0 )
                  {
                    while ( 1 )
                    {
                      v342 = (v327 + v408) / 2;
                      v137 = NlsCompareRgWChar(2 * v359 + *(_DWORD *)(v86 + 68), v374 + 20 * v342, 8);
                      if ( !v137 )
                        break;
                      if ( v137 >= 0 )
                        v327 = v342 + 1;
                      else
                        v408 = v342 - 1;
                      if ( v327 > v408 )
                        goto LABEL_445;
                    }
                    *(_DWORD *)(v86 + 76) = *(_DWORD *)(20 * v342 + v374 + 16);
                    if ( !v359 )
                      *(_DWORD *)(v86 + 68) += 14;
LABEL_414:
                    *(_DWORD *)(v86 + 76) &= 0x3FFFFFFFu;
                    v395 = 0;
                    if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 113) - 3) != 0 ? *(_BYTE *)(v86 + 115) : 0) & 0xC0) != 64 )
                    {
                      if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 113) - 3) != 0 ? *(_BYTE *)(v86 + 115) : 0) & 0xC0) != 128 )
                      {
                        if ( (unsigned __int8)(((unsigned __int8)(*(_BYTE *)(v86 + 113) - 3) != 0 ? *(_BYTE *)(v86 + 115) : 0) & 0xC0) != 192 )
                        {
LABEL_417:
                          *(_DWORD *)(v86 + 112) &= 0x3FFFFFFFu;
                          goto LABEL_37;
                        }
                        v182 = *(_DWORD *)v86;
                        v381 = *(_DWORD *)(*(_DWORD *)v86 + 272);
                        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) )
                        {
                          v421 = *(_DWORD *)(v182 + 236);
                          v183 = *(_DWORD *)(v86 + 92);
                          if ( *(_DWORD *)(v86 + 104) + 2 * (8 - (unsigned int)(v421 == 0)) <= v183 )
                          {
                            v395 = NlsCountOfWCharsWithinRange(
                                     *(unsigned __int16 **)(v86 + 104),
                                     v183,
                                     8,
                                     *(_WORD *)(*(_DWORD *)(v182 + 244) + 4),
                                     *(_WORD *)(*(_DWORD *)(v182 + 244) + 6),
                                     v421,
                                     *(_DWORD *)(v86 + 96));
                            if ( v395 >= 8 )
                            {
                              v184 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                              v366 = 0;
                              v334 = 0;
                              v422 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                              if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 9 )
                              {
                                v185 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                                v186 = **(_WORD **)(v86 + 104);
                                if ( v185 )
                                  v186 = *(_DWORD *)(v185 + 4 * (v186 >> 8)) + (unsigned __int8)v186;
                                v187 = (*pSortTblPtrs)[11];
                                v318 = *(_DWORD *)(v187 + 4 * v186);
                                v188 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                                if ( v185 )
                                {
                                  v188 = *(_DWORD *)(v185 + 4 * (v188 >> 8)) + (unsigned __int8)v188;
                                  v187 = (*pSortTblPtrs)[11];
                                }
                                v189 = v318 ^ *(_DWORD *)(v187 + 4 * v188);
                                v184 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 20) - 1;
                                if ( !(v189 & 0xE7FFFFFF) )
                                  v366 = 1;
                              }
                              if ( v184 >= 0 )
                              {
                                while ( 1 )
                                {
                                  v349 = (v334 + v422) / 2;
                                  v190 = NlsCompareRgWChar(2 * v366 + *(_DWORD *)(v86 + 104), v381 + 20 * v349, 8);
                                  if ( !v190 )
                                    break;
                                  if ( v190 >= 0 )
                                    v334 = v349 + 1;
                                  else
                                    v422 = v349 - 1;
                                  if ( v334 > v422 )
                                    goto LABEL_591;
                                }
                                *(_DWORD *)(v86 + 112) = *(_DWORD *)(20 * v349 + v381 + 16);
                                if ( !v366 )
                                  *(_DWORD *)(v86 + 104) += 14;
                                goto LABEL_417;
                              }
                            }
                          }
                        }
LABEL_591:
                        v191 = *(_DWORD *)v86;
                        v382 = *(_DWORD *)(*(_DWORD *)v86 + 268);
                        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) )
                        {
                          v423 = *(_DWORD *)(v191 + 236);
                          v192 = *(_DWORD *)(v86 + 92);
                          if ( *(_DWORD *)(v86 + 104) + 2 * (7 - (unsigned int)(v423 == 0)) <= v192 )
                          {
                            if ( !v395 )
                              v395 = NlsCountOfWCharsWithinRange(
                                       *(unsigned __int16 **)(v86 + 104),
                                       v192,
                                       7,
                                       *(_WORD *)(*(_DWORD *)(v191 + 244) + 4),
                                       *(_WORD *)(*(_DWORD *)(v191 + 244) + 6),
                                       v423,
                                       *(_DWORD *)(v86 + 96));
                            if ( v395 >= 7 )
                            {
                              v193 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                              v367 = 0;
                              v335 = 0;
                              v424 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                              if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 8 )
                              {
                                v194 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                                v195 = **(_WORD **)(v86 + 104);
                                if ( v194 )
                                  v195 = *(_DWORD *)(v194 + 4 * (v195 >> 8)) + (unsigned __int8)v195;
                                v196 = (*pSortTblPtrs)[11];
                                v319 = *(_DWORD *)(v196 + 4 * v195);
                                v197 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                                if ( v194 )
                                {
                                  v197 = *(_DWORD *)(v194 + 4 * (v197 >> 8)) + (unsigned __int8)v197;
                                  v196 = (*pSortTblPtrs)[11];
                                }
                                v306 = ((v319 ^ *(_DWORD *)(v196 + 4 * v197)) & 0xE7FFFFFF) == 0;
                                v193 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                                if ( v306 )
                                  v367 = 1;
                              }
                              if ( v193 >= 0 )
                              {
                                while ( 1 )
                                {
                                  v350 = (v335 + v424) / 2;
                                  v198 = NlsCompareRgWChar(2 * v367 + *(_DWORD *)(v86 + 104), v382 + 20 * v350, 7);
                                  if ( !v198 )
                                    break;
                                  if ( v198 >= 0 )
                                    v335 = v350 + 1;
                                  else
                                    v424 = v350 - 1;
                                  if ( v335 > v424 )
                                    goto LABEL_612;
                                }
                                *(_DWORD *)(v86 + 112) = *(_DWORD *)(20 * v350 + v382 + 16);
                                if ( !v367 )
                                  *(_DWORD *)(v86 + 104) += 12;
                                goto LABEL_417;
                              }
                            }
                          }
                        }
LABEL_612:
                        v199 = *(_DWORD *)v86;
                        v383 = *(_DWORD *)(*(_DWORD *)v86 + 264);
                        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) )
                        {
                          v425 = *(_DWORD *)(v199 + 236);
                          v200 = *(_DWORD *)(v86 + 92);
                          if ( *(_DWORD *)(v86 + 104) + 2 * (6 - (unsigned int)(v425 == 0)) <= v200 )
                          {
                            if ( !v395 )
                              v395 = NlsCountOfWCharsWithinRange(
                                       *(unsigned __int16 **)(v86 + 104),
                                       v200,
                                       6,
                                       *(_WORD *)(*(_DWORD *)(v199 + 244) + 4),
                                       *(_WORD *)(*(_DWORD *)(v199 + 244) + 6),
                                       v425,
                                       *(_DWORD *)(v86 + 96));
                            if ( v395 >= 6 )
                            {
                              v201 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                              v368 = 0;
                              v336 = 0;
                              v426 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                              if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 7 )
                              {
                                v202 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                                v203 = **(_WORD **)(v86 + 104);
                                if ( v202 )
                                  v203 = *(_DWORD *)(v202 + 4 * (v203 >> 8)) + (unsigned __int8)v203;
                                v204 = (*pSortTblPtrs)[11];
                                v320 = *(_DWORD *)(v204 + 4 * v203);
                                v205 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                                if ( v202 )
                                {
                                  v205 = *(_DWORD *)(v202 + 4 * (v205 >> 8)) + (unsigned __int8)v205;
                                  v204 = (*pSortTblPtrs)[11];
                                }
                                v306 = ((v320 ^ *(_DWORD *)(v204 + 4 * v205)) & 0xE7FFFFFF) == 0;
                                v201 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                                if ( v306 )
                                  v368 = 1;
                              }
                              if ( v201 >= 0 )
                              {
                                while ( 1 )
                                {
                                  v351 = (v336 + v426) / 2;
                                  v206 = NlsCompareRgWChar(2 * v368 + *(_DWORD *)(v86 + 104), v383 + 16 * v351, 6);
                                  if ( !v206 )
                                    break;
                                  if ( v206 >= 0 )
                                    v336 = v351 + 1;
                                  else
                                    v426 = v351 - 1;
                                  if ( v336 > v426 )
                                    goto LABEL_633;
                                }
                                *(_DWORD *)(v86 + 112) = *(_DWORD *)(16 * v351 + v383 + 12);
                                if ( !v368 )
                                  *(_DWORD *)(v86 + 104) += 10;
                                goto LABEL_417;
                              }
                            }
                          }
                        }
                      }
LABEL_633:
                      v207 = *(_DWORD *)v86;
                      v384 = *(_DWORD *)(*(_DWORD *)v86 + 260);
                      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 14) )
                      {
                        v427 = *(_DWORD *)(v207 + 236);
                        v208 = *(_DWORD *)(v86 + 92);
                        if ( *(_DWORD *)(v86 + 104) + 2 * (5 - (unsigned int)(v427 == 0)) <= v208 )
                        {
                          if ( !v395 )
                            v395 = NlsCountOfWCharsWithinRange(
                                     *(unsigned __int16 **)(v86 + 104),
                                     v208,
                                     5,
                                     *(_WORD *)(*(_DWORD *)(v207 + 244) + 4),
                                     *(_WORD *)(*(_DWORD *)(v207 + 244) + 6),
                                     v427,
                                     *(_DWORD *)(v86 + 96));
                          if ( v395 >= 5 )
                          {
                            v369 = 0;
                            v337 = 0;
                            v428 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 14) - 1;
                            if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 6 )
                            {
                              v209 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                              v210 = **(_WORD **)(v86 + 104);
                              if ( v209 )
                                v210 = *(_DWORD *)(v209 + 4 * (v210 >> 8)) + (unsigned __int8)v210;
                              v211 = (*pSortTblPtrs)[11];
                              v321 = *(_DWORD *)(v211 + 4 * v210);
                              v212 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                              if ( v209 )
                              {
                                v212 = *(_DWORD *)(v209 + 4 * (v212 >> 8)) + (unsigned __int8)v212;
                                v211 = (*pSortTblPtrs)[11];
                              }
                              if ( !((v321 ^ *(_DWORD *)(v211 + 4 * v212)) & 0xE7FFFFFF) )
                                v369 = 1;
                            }
                            if ( v428 >= 0 )
                            {
                              while ( 1 )
                              {
                                v352 = (v337 + v428) / 2;
                                v213 = NlsCompareRgWChar(2 * v369 + *(_DWORD *)(v86 + 104), v384 + 16 * v352, 5);
                                if ( !v213 )
                                  break;
                                if ( v213 >= 0 )
                                  v337 = v352 + 1;
                                else
                                  v428 = v352 - 1;
                                if ( v337 > v428 )
                                  goto LABEL_654;
                              }
                              *(_DWORD *)(v86 + 112) = *(_DWORD *)(16 * v352 + v384 + 12);
                              if ( !v369 )
                                *(_DWORD *)(v86 + 104) += 8;
                              goto LABEL_417;
                            }
                          }
                        }
                      }
LABEL_654:
                      v214 = *(_DWORD *)v86;
                      v385 = *(_DWORD *)(*(_DWORD *)v86 + 256);
                      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 12) )
                      {
                        v429 = *(_DWORD *)(v214 + 236);
                        v215 = *(_DWORD *)(v86 + 92);
                        if ( *(_DWORD *)(v86 + 104) + 2 * (4 - (unsigned int)(v429 == 0)) <= v215 )
                        {
                          if ( !v395 )
                            v395 = NlsCountOfWCharsWithinRange(
                                     *(unsigned __int16 **)(v86 + 104),
                                     v215,
                                     4,
                                     *(_WORD *)(*(_DWORD *)(v214 + 244) + 4),
                                     *(_WORD *)(*(_DWORD *)(v214 + 244) + 6),
                                     v429,
                                     *(_DWORD *)(v86 + 96));
                          if ( v395 >= 4 )
                          {
                            v370 = 0;
                            v338 = 0;
                            v430 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 12) - 1;
                            if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 5 )
                            {
                              v216 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                              v217 = **(_WORD **)(v86 + 104);
                              if ( v216 )
                                v217 = *(_DWORD *)(v216 + 4 * (v217 >> 8)) + (unsigned __int8)v217;
                              v218 = (*pSortTblPtrs)[11];
                              v322 = *(_DWORD *)(v218 + 4 * v217);
                              v219 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                              if ( v216 )
                              {
                                v219 = *(_DWORD *)(v216 + 4 * (v219 >> 8)) + (unsigned __int8)v219;
                                v218 = (*pSortTblPtrs)[11];
                              }
                              if ( !((v322 ^ *(_DWORD *)(v218 + 4 * v219)) & 0xE7FFFFFF) )
                                v370 = 1;
                            }
                            if ( v430 >= 0 )
                            {
                              while ( 1 )
                              {
                                v353 = (v338 + v430) / 2;
                                v220 = NlsCompareRgWChar(2 * v370 + *(_DWORD *)(v86 + 104), v385 + 12 * v353, 4);
                                if ( !v220 )
                                  break;
                                if ( v220 >= 0 )
                                  v338 = v353 + 1;
                                else
                                  v430 = v353 - 1;
                                if ( v338 > v430 )
                                  goto LABEL_675;
                              }
                              *(_DWORD *)(v86 + 112) = *(_DWORD *)(12 * v353 + v385 + 8);
                              if ( !v370 )
                                *(_DWORD *)(v86 + 104) += 6;
                              goto LABEL_417;
                            }
                          }
                        }
                      }
                    }
LABEL_675:
                    v221 = *(_DWORD *)v86;
                    v386 = *(_DWORD *)(*(_DWORD *)v86 + 252);
                    if ( !*(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 10) )
                      goto LABEL_696;
                    v431 = *(_DWORD *)(v221 + 236);
                    v222 = *(_DWORD *)(v86 + 92);
                    if ( *(_DWORD *)(v86 + 104) + 2 * (3 - (unsigned int)(v431 == 0)) > v222 )
                      goto LABEL_696;
                    if ( !v395 )
                      v395 = NlsCountOfWCharsWithinRange(
                               *(unsigned __int16 **)(v86 + 104),
                               v222,
                               3,
                               *(_WORD *)(*(_DWORD *)(v221 + 244) + 4),
                               *(_WORD *)(*(_DWORD *)(v221 + 244) + 6),
                               v431,
                               *(_DWORD *)(v86 + 96));
                    if ( v395 < 3 )
                      goto LABEL_696;
                    v371 = 0;
                    v339 = 0;
                    v432 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 10) - 1;
                    if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 4 )
                    {
                      v223 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                      v224 = **(_WORD **)(v86 + 104);
                      if ( v223 )
                        v224 = *(_DWORD *)(v223 + 4 * (v224 >> 8)) + (unsigned __int8)v224;
                      v225 = (*pSortTblPtrs)[11];
                      v323 = *(_DWORD *)(v225 + 4 * v224);
                      v226 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                      if ( v223 )
                      {
                        v226 = *(_DWORD *)(v223 + 4 * (v226 >> 8)) + (unsigned __int8)v226;
                        v225 = (*pSortTblPtrs)[11];
                      }
                      if ( !((v323 ^ *(_DWORD *)(v225 + 4 * v226)) & 0xE7FFFFFF) )
                        v371 = 1;
                    }
                    if ( v432 >= 0 )
                    {
                      while ( 1 )
                      {
                        v354 = (v339 + v432) / 2;
                        v227 = NlsCompareRgWChar(2 * v371 + *(_DWORD *)(v86 + 104), v386 + 12 * v354, 3);
                        if ( !v227 )
                          break;
                        if ( v227 >= 0 )
                          v339 = v354 + 1;
                        else
                          v432 = v354 - 1;
                        if ( v339 > v432 )
                          goto LABEL_696;
                      }
                      *(_DWORD *)(v86 + 112) = *(_DWORD *)(12 * v354 + v386 + 8);
                      if ( !v371 )
                        *(_DWORD *)(v86 + 104) += 4;
                    }
                    else
                    {
LABEL_696:
                      v228 = *(_DWORD *)v86;
                      v387 = *(_DWORD *)(*(_DWORD *)v86 + 248);
                      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 8) )
                      {
                        v433 = *(_DWORD *)(v228 + 236);
                        v229 = *(_DWORD *)(v86 + 92);
                        if ( *(_DWORD *)(v86 + 104) + 2 * (2 - (unsigned int)(v433 == 0)) <= v229 )
                        {
                          if ( !v395 )
                            v395 = NlsCountOfWCharsWithinRange(
                                     *(unsigned __int16 **)(v86 + 104),
                                     v229,
                                     2,
                                     *(_WORD *)(*(_DWORD *)(v228 + 244) + 4),
                                     *(_WORD *)(*(_DWORD *)(v228 + 244) + 6),
                                     v433,
                                     *(_DWORD *)(v86 + 96));
                          if ( v395 >= 2 )
                          {
                            v372 = 0;
                            v340 = 0;
                            v355 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 8) - 1;
                            if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v395 >= 3 )
                            {
                              v230 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                              v231 = (*pSortTblPtrs)[11];
                              v232 = **(_WORD **)(v86 + 104);
                              if ( v230 )
                              {
                                v232 = *(_DWORD *)(v230 + 4 * (v232 >> 8)) + (unsigned __int8)v232;
                                v231 = (*pSortTblPtrs)[11];
                              }
                              v324 = *(_DWORD *)(v231 + 4 * v232);
                              v233 = *(_WORD *)(*(_DWORD *)(v86 + 104) + 2);
                              if ( v230 )
                              {
                                v233 = *(_DWORD *)(v230 + 4 * (v233 >> 8)) + (unsigned __int8)v233;
                                v231 = (*pSortTblPtrs)[11];
                              }
                              if ( !((v324 ^ *(_DWORD *)(v231 + 4 * v233)) & 0xE7FFFFFF) )
                                v372 = 1;
                            }
                            if ( v355 >= 0 )
                            {
                              while ( 1 )
                              {
                                v434 = (v340 + v355) / 2;
                                v234 = NlsCompareRgWChar(2 * v372 + *(_DWORD *)(v86 + 104), v387 + 8 * v434, 2);
                                if ( !v234 )
                                  break;
                                if ( v234 >= 0 )
                                  v340 = v434 + 1;
                                else
                                  v355 = v434 - 1;
                                if ( v340 > v355 )
                                  goto LABEL_417;
                              }
                              *(_DWORD *)(v86 + 112) = *(_DWORD *)(v387 + 8 * v434 + 4);
                              if ( !v372 )
                                *(_DWORD *)(v86 + 104) += 2;
                            }
                          }
                        }
                      }
                    }
                    goto LABEL_417;
                  }
                }
              }
            }
LABEL_445:
            v138 = *(_DWORD *)v86;
            v375 = *(_DWORD *)(*(_DWORD *)v86 + 268);
            if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) )
            {
              v409 = *(_DWORD *)(v138 + 236);
              v139 = *(_DWORD *)(v86 + 56);
              if ( *(_DWORD *)(v86 + 68) + 2 * (7 - (unsigned int)(v409 == 0)) <= v139 )
              {
                if ( !v394 )
                  v394 = NlsCountOfWCharsWithinRange(
                           *(unsigned __int16 **)(v86 + 68),
                           v139,
                           7,
                           *(_WORD *)(*(_DWORD *)(v138 + 244) + 4),
                           *(_WORD *)(*(_DWORD *)(v138 + 244) + 6),
                           v409,
                           *(_DWORD *)(v86 + 60));
                if ( v394 >= 7 )
                {
                  v140 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                  v360 = 0;
                  v328 = 0;
                  v410 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                  if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 8 )
                  {
                    v141 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                    v142 = **(_WORD **)(v86 + 68);
                    if ( v141 )
                      v142 = *(_DWORD *)(v141 + 4 * (v142 >> 8)) + (unsigned __int8)v142;
                    v143 = (*pSortTblPtrs)[11];
                    v312 = *(_DWORD *)(v143 + 4 * v142);
                    v144 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                    if ( v141 )
                    {
                      v144 = *(_DWORD *)(v141 + 4 * (v144 >> 8)) + (unsigned __int8)v144;
                      v143 = (*pSortTblPtrs)[11];
                    }
                    v306 = ((v312 ^ *(_DWORD *)(v143 + 4 * v144)) & 0xE7FFFFFF) == 0;
                    v140 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 18) - 1;
                    if ( v306 )
                      v360 = 1;
                  }
                  if ( v140 >= 0 )
                  {
                    while ( 1 )
                    {
                      v343 = (v328 + v410) / 2;
                      v145 = NlsCompareRgWChar(2 * v360 + *(_DWORD *)(v86 + 68), v375 + 20 * v343, 7);
                      if ( !v145 )
                        break;
                      if ( v145 >= 0 )
                        v328 = v343 + 1;
                      else
                        v410 = v343 - 1;
                      if ( v328 > v410 )
                        goto LABEL_466;
                    }
                    *(_DWORD *)(v86 + 76) = *(_DWORD *)(20 * v343 + v375 + 16);
                    if ( !v360 )
                      *(_DWORD *)(v86 + 68) += 12;
                    goto LABEL_414;
                  }
                }
              }
            }
LABEL_466:
            v146 = *(_DWORD *)v86;
            v376 = *(_DWORD *)(*(_DWORD *)v86 + 264);
            if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) )
            {
              v411 = *(_DWORD *)(v146 + 236);
              v147 = *(_DWORD *)(v86 + 56);
              if ( *(_DWORD *)(v86 + 68) + 2 * (6 - (unsigned int)(v411 == 0)) <= v147 )
              {
                if ( !v394 )
                  v394 = NlsCountOfWCharsWithinRange(
                           *(unsigned __int16 **)(v86 + 68),
                           v147,
                           6,
                           *(_WORD *)(*(_DWORD *)(v146 + 244) + 4),
                           *(_WORD *)(*(_DWORD *)(v146 + 244) + 6),
                           v411,
                           *(_DWORD *)(v86 + 60));
                if ( v394 >= 6 )
                {
                  v148 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                  v361 = 0;
                  v329 = 0;
                  v412 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                  if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 7 )
                  {
                    v149 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                    v150 = **(_WORD **)(v86 + 68);
                    if ( v149 )
                      v150 = *(_DWORD *)(v149 + 4 * (v150 >> 8)) + (unsigned __int8)v150;
                    v151 = (*pSortTblPtrs)[11];
                    v313 = *(_DWORD *)(v151 + 4 * v150);
                    v152 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                    if ( v149 )
                    {
                      v152 = *(_DWORD *)(v149 + 4 * (v152 >> 8)) + (unsigned __int8)v152;
                      v151 = (*pSortTblPtrs)[11];
                    }
                    v306 = ((v313 ^ *(_DWORD *)(v151 + 4 * v152)) & 0xE7FFFFFF) == 0;
                    v148 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 16) - 1;
                    if ( v306 )
                      v361 = 1;
                  }
                  if ( v148 >= 0 )
                  {
                    while ( 1 )
                    {
                      v344 = (v329 + v412) / 2;
                      v153 = NlsCompareRgWChar(2 * v361 + *(_DWORD *)(v86 + 68), v376 + 16 * v344, 6);
                      if ( !v153 )
                        break;
                      if ( v153 >= 0 )
                        v329 = v344 + 1;
                      else
                        v412 = v344 - 1;
                      if ( v329 > v412 )
                        goto LABEL_487;
                    }
                    *(_DWORD *)(v86 + 76) = *(_DWORD *)(16 * v344 + v376 + 12);
                    if ( !v361 )
                      *(_DWORD *)(v86 + 68) += 10;
                    goto LABEL_414;
                  }
                }
              }
            }
          }
LABEL_487:
          v154 = *(_DWORD *)v86;
          v377 = *(_DWORD *)(*(_DWORD *)v86 + 260);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 14) )
          {
            v413 = *(_DWORD *)(v154 + 236);
            v155 = *(_DWORD *)(v86 + 56);
            if ( *(_DWORD *)(v86 + 68) + 2 * (5 - (unsigned int)(v413 == 0)) <= v155 )
            {
              if ( !v394 )
                v394 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(v86 + 68),
                         v155,
                         5,
                         *(_WORD *)(*(_DWORD *)(v154 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v154 + 244) + 6),
                         v413,
                         *(_DWORD *)(v86 + 60));
              if ( v394 >= 5 )
              {
                v362 = 0;
                v330 = 0;
                v414 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 14) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 6 )
                {
                  v156 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                  v157 = **(_WORD **)(v86 + 68);
                  if ( v156 )
                    v157 = *(_DWORD *)(v156 + 4 * (v157 >> 8)) + (unsigned __int8)v157;
                  v158 = (*pSortTblPtrs)[11];
                  v314 = *(_DWORD *)(v158 + 4 * v157);
                  v159 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                  if ( v156 )
                  {
                    v159 = *(_DWORD *)(v156 + 4 * (v159 >> 8)) + (unsigned __int8)v159;
                    v158 = (*pSortTblPtrs)[11];
                  }
                  if ( !((v314 ^ *(_DWORD *)(v158 + 4 * v159)) & 0xE7FFFFFF) )
                    v362 = 1;
                }
                if ( v414 >= 0 )
                {
                  while ( 1 )
                  {
                    v345 = (v330 + v414) / 2;
                    v160 = NlsCompareRgWChar(2 * v362 + *(_DWORD *)(v86 + 68), v377 + 16 * v345, 5);
                    if ( !v160 )
                      break;
                    if ( v160 >= 0 )
                      v330 = v345 + 1;
                    else
                      v414 = v345 - 1;
                    if ( v330 > v414 )
                      goto LABEL_508;
                  }
                  *(_DWORD *)(v86 + 76) = *(_DWORD *)(16 * v345 + v377 + 12);
                  if ( !v362 )
                    *(_DWORD *)(v86 + 68) += 8;
                  goto LABEL_414;
                }
              }
            }
          }
LABEL_508:
          v161 = *(_DWORD *)v86;
          v378 = *(_DWORD *)(*(_DWORD *)v86 + 256);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 12) )
          {
            v415 = *(_DWORD *)(v161 + 236);
            v162 = *(_DWORD *)(v86 + 56);
            if ( *(_DWORD *)(v86 + 68) + 2 * (4 - (unsigned int)(v415 == 0)) <= v162 )
            {
              if ( !v394 )
                v394 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(v86 + 68),
                         v162,
                         4,
                         *(_WORD *)(*(_DWORD *)(v161 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v161 + 244) + 6),
                         v415,
                         *(_DWORD *)(v86 + 60));
              if ( v394 >= 4 )
              {
                v363 = 0;
                v331 = 0;
                v416 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 12) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 5 )
                {
                  v163 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                  v164 = **(_WORD **)(v86 + 68);
                  if ( v163 )
                    v164 = *(_DWORD *)(v163 + 4 * (v164 >> 8)) + (unsigned __int8)v164;
                  v165 = (*pSortTblPtrs)[11];
                  v315 = *(_DWORD *)(v165 + 4 * v164);
                  v166 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                  if ( v163 )
                  {
                    v166 = *(_DWORD *)(v163 + 4 * (v166 >> 8)) + (unsigned __int8)v166;
                    v165 = (*pSortTblPtrs)[11];
                  }
                  if ( !((v315 ^ *(_DWORD *)(v165 + 4 * v166)) & 0xE7FFFFFF) )
                    v363 = 1;
                }
                if ( v416 >= 0 )
                {
                  while ( 1 )
                  {
                    v346 = (v331 + v416) / 2;
                    v167 = NlsCompareRgWChar(2 * v363 + *(_DWORD *)(v86 + 68), v378 + 12 * v346, 4);
                    if ( !v167 )
                      break;
                    if ( v167 >= 0 )
                      v331 = v346 + 1;
                    else
                      v416 = v346 - 1;
                    if ( v331 > v416 )
                      goto LABEL_529;
                  }
                  *(_DWORD *)(v86 + 76) = *(_DWORD *)(12 * v346 + v378 + 8);
                  if ( !v363 )
                    *(_DWORD *)(v86 + 68) += 6;
                  goto LABEL_414;
                }
              }
            }
          }
        }
LABEL_529:
        v168 = *(_DWORD *)v86;
        v379 = *(_DWORD *)(*(_DWORD *)v86 + 252);
        if ( !*(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 10) )
          goto LABEL_550;
        v417 = *(_DWORD *)(v168 + 236);
        v169 = *(_DWORD *)(v86 + 56);
        if ( *(_DWORD *)(v86 + 68) + 2 * (3 - (unsigned int)(v417 == 0)) > v169 )
          goto LABEL_550;
        if ( !v394 )
          v394 = NlsCountOfWCharsWithinRange(
                   *(unsigned __int16 **)(v86 + 68),
                   v169,
                   3,
                   *(_WORD *)(*(_DWORD *)(v168 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v168 + 244) + 6),
                   v417,
                   *(_DWORD *)(v86 + 60));
        if ( v394 < 3 )
          goto LABEL_550;
        v364 = 0;
        v332 = 0;
        v418 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 10) - 1;
        if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 4 )
        {
          v170 = *(_DWORD *)(*(_DWORD *)v86 + 224);
          v171 = **(_WORD **)(v86 + 68);
          if ( v170 )
            v171 = *(_DWORD *)(v170 + 4 * (v171 >> 8)) + (unsigned __int8)v171;
          v172 = (*pSortTblPtrs)[11];
          v316 = *(_DWORD *)(v172 + 4 * v171);
          v173 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
          if ( v170 )
          {
            v173 = *(_DWORD *)(v170 + 4 * (v173 >> 8)) + (unsigned __int8)v173;
            v172 = (*pSortTblPtrs)[11];
          }
          if ( !((v316 ^ *(_DWORD *)(v172 + 4 * v173)) & 0xE7FFFFFF) )
            v364 = 1;
        }
        if ( v418 >= 0 )
        {
          while ( 1 )
          {
            v347 = (v332 + v418) / 2;
            v174 = NlsCompareRgWChar(2 * v364 + *(_DWORD *)(v86 + 68), v379 + 12 * v347, 3);
            if ( !v174 )
              break;
            if ( v174 >= 0 )
              v332 = v347 + 1;
            else
              v418 = v347 - 1;
            if ( v332 > v418 )
              goto LABEL_550;
          }
          *(_DWORD *)(v86 + 76) = *(_DWORD *)(12 * v347 + v379 + 8);
          if ( !v364 )
            *(_DWORD *)(v86 + 68) += 4;
        }
        else
        {
LABEL_550:
          v175 = *(_DWORD *)v86;
          v380 = *(_DWORD *)(*(_DWORD *)v86 + 248);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 8) )
          {
            v419 = *(_DWORD *)(v175 + 236);
            v176 = *(_DWORD *)(v86 + 56);
            if ( *(_DWORD *)(v86 + 68) + 2 * (2 - (unsigned int)(v419 == 0)) <= v176 )
            {
              if ( !v394 )
                v394 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(v86 + 68),
                         v176,
                         2,
                         *(_WORD *)(*(_DWORD *)(v175 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v175 + 244) + 6),
                         v419,
                         *(_DWORD *)(v86 + 60));
              if ( v394 >= 2 )
              {
                v365 = 0;
                v333 = 0;
                v348 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v86 + 244) + 8) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v86 + 236) && v394 >= 3 )
                {
                  v177 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                  v178 = (*pSortTblPtrs)[11];
                  v179 = **(_WORD **)(v86 + 68);
                  if ( v177 )
                  {
                    v179 = *(_DWORD *)(v177 + 4 * (v179 >> 8)) + (unsigned __int8)v179;
                    v178 = (*pSortTblPtrs)[11];
                  }
                  v317 = *(_DWORD *)(v178 + 4 * v179);
                  v180 = *(_WORD *)(*(_DWORD *)(v86 + 68) + 2);
                  if ( v177 )
                  {
                    v180 = *(_DWORD *)(v177 + 4 * (v180 >> 8)) + (unsigned __int8)v180;
                    v178 = (*pSortTblPtrs)[11];
                  }
                  if ( !((v317 ^ *(_DWORD *)(v178 + 4 * v180)) & 0xE7FFFFFF) )
                    v365 = 1;
                }
                if ( v348 >= 0 )
                {
                  while ( 1 )
                  {
                    v420 = (v333 + v348) / 2;
                    v181 = NlsCompareRgWChar(2 * v365 + *(_DWORD *)(v86 + 68), v380 + 8 * v420, 2);
                    if ( !v181 )
                      break;
                    if ( v181 >= 0 )
                      v333 = v420 + 1;
                    else
                      v348 = v420 - 1;
                    if ( v333 > v348 )
                      goto LABEL_414;
                  }
                  *(_DWORD *)(v86 + 76) = *(_DWORD *)(v380 + 8 * v420 + 4);
                  if ( !v365 )
                    *(_DWORD *)(v86 + 68) += 2;
                }
              }
            }
          }
        }
        goto LABEL_414;
      }
LABEL_37:
      v100 = *(_DWORD *)(v86 + 76) >> 8;
      v436 = v100;
      if ( (_BYTE)v100 != 5
        && (unsigned __int8)(v100 + 87) > 6u
        && (!*(_DWORD *)(v86 + 44) || (unsigned __int8)(v100 + 64) > 0x2Fu)
        || (_BYTE)v100 == 1 && *(_DWORD *)(v86 + 24) )
        *(_DWORD *)(v86 + 76) &= *(_DWORD *)(v86 + 48);
      v101 = *(_DWORD *)(v86 + 112) >> 8;
      v404 = v101;
      if ( (_BYTE)v101 != 5
        && (unsigned __int8)(v101 + 87) > 6u
        && (!*(_DWORD *)(v86 + 44) || (unsigned __int8)(v101 + 64) > 0x2Fu)
        || (_BYTE)v101 == 1 && *(_DWORD *)(v86 + 24) )
        *(_DWORD *)(v86 + 112) &= *(_DWORD *)(v86 + 48);
      if ( (_BYTE)v100 != 13 || !*(_DWORD *)(v86 + 28) )
        break;
      v391 = 0;
      v373 = 0;
      v358 = 0;
      v341 = 0;
      v393 = GetDigitRange(*(unsigned __int16 **)(v86 + 68), *(_DWORD *)v91 < *(_DWORD *)(v86 + 68));
      v62 = GetDigitRange(*(unsigned __int16 **)(v86 + 104), *(_DWORD *)v92 < *(_DWORD *)(v86 + 104));
      v388 = v62;
      if ( !v393 || !v62 )
      {
        result = 0;
        goto LABEL_424;
      }
      if ( (unsigned __int16)(v393 + 9216) <= 0x3FFu )
        v358 = -10187;
      if ( (unsigned __int16)(v62 + 9216) <= 0x3FFu )
        v341 = -10187;
      do
      {
        v63 = *(_DWORD *)(v86 + 68);
        if ( *(_WORD *)v63 != v393 )
          break;
        ++v391;
        v64 = v63 + 2;
        *(_DWORD *)(v86 + 68) = v64;
        if ( v358 )
        {
          if ( (unsigned int)v64 >= *(_DWORD *)(v86 + 56) || *(_WORD *)v64 != v358 )
          {
            *(_DWORD *)(v86 + 68) = v64 + 2;
            break;
          }
          *(_DWORD *)(v86 + 68) = v64 + 2;
        }
      }
      while ( *(_DWORD *)(v86 + 68) < *(_DWORD *)(v86 + 56) && v391 < 19 );
      do
      {
        v65 = *(_DWORD *)(v86 + 104);
        if ( *(_WORD *)v65 != v388 )
          break;
        ++v373;
        v66 = v65 + 2;
        *(_DWORD *)(v86 + 104) = v66;
        if ( v341 )
        {
          if ( (unsigned int)v66 >= *(_DWORD *)(v86 + 92) || *(_WORD *)v66 != v341 )
          {
            *(_DWORD *)(v86 + 104) = v66 + 2;
            break;
          }
          *(_DWORD *)(v86 + 104) = v66 + 2;
        }
      }
      while ( *(_DWORD *)(v86 + 104) < *(_DWORD *)(v86 + 92) && v373 < 19 );
      v67 = *(_DWORD *)(v86 + 68);
      v392 = 0;
      if ( v67 < *(_DWORD *)(v86 + 56) && v391 < 19 )
      {
        v325 = v391;
        while ( *(_WORD *)v67 >= v393 && *(_WORD *)v67 - 9 <= v393 )
        {
          ++v392;
          ++v325;
          v67 += 2;
          if ( v358 )
          {
            if ( v67 >= *(_DWORD *)(v86 + 56) || *(_WORD *)v67 != v358 )
              break;
            v67 += 2;
          }
          if ( v67 >= *(_DWORD *)(v86 + 56) || v325 >= 19 )
            break;
        }
      }
      v68 = *(_DWORD *)(v86 + 104);
      v326 = 0;
      if ( v68 < *(_DWORD *)(v86 + 92) && v373 < 19 )
      {
        v310 = v373;
        while ( *(_WORD *)v68 >= v388 && *(_WORD *)v68 - 9 <= v388 )
        {
          ++v326;
          ++v310;
          v68 += 2;
          if ( v341 )
          {
            if ( v68 >= *(_DWORD *)(v86 + 92) || *(_WORD *)v68 != v341 )
              break;
            v68 += 2;
          }
          if ( v68 >= *(_DWORD *)(v86 + 92) || v310 >= 19 )
            break;
        }
      }
      if ( v392 != v326 )
      {
        v126 = 0;
        v128 = __OFSUB__(v392, v326);
        v127 = v392 - v326 < 0;
LABEL_422:
        LOBYTE(v126) = !(v127 ^ v128);
        goto LABEL_423;
      }
      v69 = 0;
      if ( v392 > 0 )
      {
        while ( 1 )
        {
          v70 = *(_DWORD *)(v86 + 104);
          v71 = v388 + **(_WORD **)(v86 + 68) - *(_WORD *)v70 - v393;
          if ( v71 )
            break;
          v72 = *(_DWORD *)(v86 + 68) + 2;
          v73 = v70 + 2;
          *(_DWORD *)(v86 + 68) = v72;
          *(_DWORD *)(v86 + 104) = v73;
          if ( v358 )
            *(_DWORD *)(v86 + 68) = v72 + 2;
          v69 = 0;
          if ( v341 )
            *(_DWORD *)(v86 + 104) = v73 + 2;
          --v392;
          if ( v392 <= 0 )
            goto LABEL_294;
        }
        v126 = 0;
        v128 = 0;
        v127 = v71 < 0;
        goto LABEL_422;
      }
LABEL_294:
      if ( v391 == v373 )
      {
        if ( v393 != v388 )
        {
          if ( !*(_DWORD *)(v86 + 12) )
          {
            if ( *(_BYTE *)(v86 + 124) & 3 )
            {
              v235 = *(_BYTE *)(v86 + 78);
              v236 = *(_BYTE *)(v86 + 114);
              if ( v235 != v236 )
              {
                *(_DWORD *)(v86 + 128) = v235 < v236 ? 1 : 3;
                *(_DWORD *)(v86 + 124) &= 0xFFFFFF0A;
              }
            }
          }
          if ( *(_BYTE *)(v86 + 124) & 4 )
          {
            v237 = *(_BYTE *)(v86 + 79) & 0x3F;
            v238 = *(_BYTE *)(v86 + 115) & 0x3F;
            if ( v237 != v238 )
            {
              *(_DWORD *)(v86 + 128) = v237 < v238 ? 1 : 3;
              *(_DWORD *)(v86 + 124) &= 0xFFFFFF0B;
            }
          }
        }
        *(_DWORD *)(v86 + 112) = -1;
        *(_DWORD *)(v86 + 76) = -1;
        if ( v358 != v69 )
          *(_DWORD *)(v86 + 68) -= 2;
        if ( v341 != v69 )
          *(_DWORD *)(v86 + 104) -= 2;
        *(_DWORD *)(v86 + 68) -= 2;
        *(_DWORD *)(v86 + 104) -= 2;
        if ( *(_DWORD *)(v86 + 72)
          || (!*(_DWORD *)(v86 + 60) || **(_WORD **)(v86 + 68)) && *(_DWORD *)(v86 + 68) < *(_DWORD *)(v86 + 56) )
        {
          v74 = *(_DWORD *)(v86 + 72);
          if ( v74 > 0 )
          {
            v239 = v74 - 1;
            *(_DWORD *)(v86 + 72) = v239;
            v76 = *(_WORD *)(v91 + 2 * v239 + 12);
          }
          else
          {
            *(_DWORD *)(v86 + 68) += 2;
            v75 = *(_DWORD *)(v86 + 68);
            if ( v75 >= *(_DWORD *)(v86 + 56) )
              v76 = 0;
            else
              v76 = *(_WORD *)v75;
          }
          *(_WORD *)(v86 + 82) = v76;
        }
        if ( *(_DWORD *)(v86 + 108)
          || (!*(_DWORD *)(v86 + 96) || **(_WORD **)(v86 + 104)) && *(_DWORD *)(v86 + 104) < *(_DWORD *)(v86 + 92) )
        {
          v77 = *(_DWORD *)(v86 + 108);
          if ( v77 > 0 )
          {
            v240 = v77 - 1;
            *(_DWORD *)(v86 + 108) = v240;
            v79 = *(_WORD *)(v92 + 2 * v240 + 12);
          }
          else
          {
            *(_DWORD *)(v86 + 104) += 2;
            v78 = *(_DWORD *)(v86 + 104);
            if ( v78 >= *(_DWORD *)(v86 + 92) )
              v79 = 0;
            else
              v79 = *(_WORD *)v78;
          }
          *(_WORD *)(v86 + 118) = v79;
        }
      }
      else
      {
        v126 = v391 < v373;
LABEL_423:
        result = 2 * v126 + 1;
LABEL_424:
        if ( !result )
          break;
        if ( result != 2 )
          return result;
      }
    }
    v102 = v436;
    if ( *(_DWORD *)(v86 + 76) == *(_DWORD *)(v86 + 112) && (v436 < 2u || v436 > 6u) )
      break;
    v103 = *(_WORD *)(v86 + 76);
    v104 = *(_WORD *)(v86 + 112);
    *(_WORD *)(v86 + 80) = v103;
    *(_WORD *)(v86 + 116) = v104;
    if ( v103 == v104 )
    {
      if ( (unsigned __int8)(v436 - 2) > 0xAu )
        goto LABEL_149;
      v102 = v436;
    }
    if ( v102 <= 0xCu )
    {
      if ( v102 )
      {
        if ( v102 != 1 )
        {
          if ( v102 != 2 )
          {
            if ( v102 == 4 )
            {
              GetOldHangulWeight(*(_DWORD *)v86, v86 + 52);
              goto LABEL_49;
            }
            if ( v102 == 6 )
            {
              v38 = *(_DWORD *)(v86 + 8);
            }
            else
            {
              if ( v102 <= 6u )
                goto LABEL_49;
              v38 = *(_DWORD *)(v86 + 16);
            }
            goto LABEL_188;
          }
          v241 = *(_DWORD *)(*(_DWORD *)v86 + 224);
          v242 = *(_WORD *)(v86 + 82);
          if ( v241 )
            v242 = *(_DWORD *)(v241 + 4 * (v242 >> 8)) + (unsigned __int8)v242;
          *(_DWORD *)(v86 + 76) = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v242);
          v243 = 4 * *(_WORD *)(v86 + 78);
          *(_WORD *)(v86 + 66) = *(_WORD *)(v243 + (*pSortTblPtrs)[14]);
          *(_WORD *)(v86 + 64) = *(_WORD *)((*pSortTblPtrs)[14] + v243 + 2);
          *(_DWORD *)(v86 + 72) = 2;
LABEL_190:
          *(_DWORD *)(v86 + 76) = -1;
          v40 = *(_DWORD *)(v86 + 72);
          if ( v40 > 0 )
          {
            v244 = v40 - 1;
            *(_DWORD *)(v86 + 72) = v244;
            v42 = *(_WORD *)(v91 + 2 * v244 + 12);
          }
          else
          {
            *(_DWORD *)(v86 + 68) += 2;
            v41 = *(_DWORD *)(v86 + 68);
            if ( v41 >= *(_DWORD *)(v86 + 56) )
              v42 = 0;
            else
              v42 = *(_WORD *)v41;
          }
          *(_WORD *)(v86 + 82) = v42;
          goto LABEL_49;
        }
        if ( *(_DWORD *)(v86 + 12) )
          goto LABEL_190;
        v39 = *(_DWORD *)(v86 + 24) == 0;
      }
      else
      {
        if ( !*(_WORD *)(v86 + 82) && *(_DWORD *)(v86 + 36) )
          goto LABEL_49;
        v38 = 1;
LABEL_188:
        v39 = v38 == 0;
      }
      if ( v39 )
        goto LABEL_49;
      goto LABEL_190;
    }
LABEL_49:
    if ( v404 > 0xCu )
      goto LABEL_50;
    if ( v404 )
    {
      if ( v404 == 1 )
      {
        if ( *(_DWORD *)(v86 + 12) )
          goto LABEL_176;
        v34 = *(_DWORD *)(v86 + 24) == 0;
        goto LABEL_175;
      }
      if ( v404 == 2 )
      {
        v121 = *(_DWORD *)(*(_DWORD *)v86 + 224);
        v122 = *(_WORD *)(v86 + 118);
        if ( v121 )
          v122 = *(_DWORD *)(v121 + 4 * (v122 >> 8)) + (unsigned __int8)v122;
        *(_DWORD *)(v86 + 112) = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v122);
        v123 = 4 * *(_WORD *)(v86 + 114);
        *(_WORD *)(v86 + 102) = *(_WORD *)(v123 + (*pSortTblPtrs)[14]);
        *(_WORD *)(v86 + 100) = *(_WORD *)((*pSortTblPtrs)[14] + v123 + 2);
        *(_DWORD *)(v86 + 108) = 2;
LABEL_176:
        *(_DWORD *)(v86 + 112) = -1;
        v35 = *(_DWORD *)(v86 + 108);
        if ( v35 > 0 )
        {
          v124 = v35 - 1;
          *(_DWORD *)(v86 + 108) = v124;
          v37 = *(_WORD *)(v92 + 2 * v124 + 12);
        }
        else
        {
          *(_DWORD *)(v86 + 104) += 2;
          v36 = *(_DWORD *)(v86 + 104);
          if ( v36 >= *(_DWORD *)(v86 + 92) )
            v37 = 0;
          else
            v37 = *(_WORD *)v36;
        }
        *(_WORD *)(v86 + 118) = v37;
        goto LABEL_50;
      }
      if ( v404 == 4 )
      {
        GetOldHangulWeight(*(_DWORD *)v86, v86 + 88);
        goto LABEL_50;
      }
      if ( v404 == 6 )
      {
        v14 = *(_DWORD *)(v86 + 8);
      }
      else
      {
        if ( v404 <= 6u )
          goto LABEL_50;
        v14 = *(_DWORD *)(v86 + 16);
      }
    }
    else
    {
      if ( !*(_WORD *)(v86 + 118) && *(_DWORD *)(v86 + 36) )
        goto LABEL_50;
      v14 = 1;
    }
    v34 = v14 == 0;
LABEL_175:
    if ( !v34 )
      goto LABEL_176;
LABEL_50:
    v105 = *(_DWORD *)(v86 + 76);
    if ( v105 != -1 )
    {
      v106 = *(_DWORD *)(v86 + 112);
      if ( v106 != -1 )
      {
        if ( v436 == 1 )
        {
          if ( *(_BYTE *)(v86 + 124) & 3 )
          {
            if ( *(_DWORD *)(v86 + 32) )
              return 3;
            *(_DWORD *)(v86 + 128) = 3;
            *(_DWORD *)(v86 + 124) &= 0xFFFFFF0A;
          }
          goto LABEL_199;
        }
        if ( v436 == 3 )
        {
          v7 = *(_BYTE *)(v86 + 76);
          v8 = *(_BYTE *)(v86 + 79);
          *(_DWORD *)(v86 + 84) = 0;
          v9 = v8 & 0x3F;
          v401 = v7;
          v399 = v9;
          if ( v7 > 1u )
          {
            *(_WORD *)(v86 + 80) = v7 | 0x2200;
            *(_BYTE *)(v86 + 84) = v9 & 0xC6;
            *(_BYTE *)(v86 + 86) = v9 & 0xE4;
            v10 = 0;
            *(_BYTE *)(v86 + 85) = 3;
            goto LABEL_109;
          }
          v254 = *(_DWORD *)(v86 + 68);
          v10 = 0xFFFF;
          if ( (unsigned int)(v254 - 2) >= *(_DWORD *)v91 )
          {
            v255 = *(_DWORD *)(*(_DWORD *)v86 + 224);
            v356 = 2;
            v389 = v254 - 2;
            while ( 1 )
            {
              v256 = *(_WORD *)v389;
              if ( v255 )
                v256 = *(_DWORD *)(v255 + 4 * (v256 >> 8)) + (unsigned __int8)v256;
              v10 = *(_DWORD *)(v86 + 48) & *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v256);
              v257 = (unsigned int)v10 >> 8;
              HIWORD(v396) = HIWORD(v10);
              if ( BYTE1(v10) >= 3u )
              {
                if ( BYTE1(v10) != 3 )
                {
                  *(_WORD *)(v86 + 80) = v10;
                  break;
                }
                if ( (unsigned __int8)v10 > 1u )
                {
                  v258 = (unsigned __int8)v10 | 0x2200;
                  *(_BYTE *)(v86 + 84) = BYTE3(v10) & 6;
                  LOWORD(v396) = (unsigned __int8)v10 | 0x2200;
                  *(_BYTE *)(v86 + 86) = BYTE3(v10) & 0x24;
                  if ( !v401 )
                  {
                    *(_BYTE *)(v86 + 87) = BYTE3(v10) & 5;
                    v10 = v396;
                    *(_WORD *)(v86 + 80) = v258;
                    *(_BYTE *)(v86 + 85) = 4;
                    goto LABEL_786;
                  }
                  v10 = v396;
                  *(_WORD *)(v86 + 80) = v396 & 0xFF87;
                  v9 = v399;
                  *(_BYTE *)(v86 + 85) = 5;
LABEL_109:
                  *(_BYTE *)(v86 + 87) = v9 & 0xC5;
                  break;
                }
                v10 = 0xFFFF;
              }
              else
              {
                v10 = 0xFFFF;
                if ( (_BYTE)v257 == 2 )
                  break;
              }
              v356 += 2;
              v389 -= 2;
              if ( (unsigned int)(*(_DWORD *)(v86 + 68) - v356) < *(_DWORD *)v91 )
                break;
              v255 = *(_DWORD *)(*(_DWORD *)v86 + 224);
            }
          }
          if ( v401 <= 1u )
          {
LABEL_786:
            if ( v10 != 0xFFFF )
              goto LABEL_111;
            *(_DWORD *)(v86 + 84) = 0;
            *(_WORD *)(v86 + 80) = -1;
            *(_DWORD *)(v86 + 76) = 0xFFFF;
          }
          else
          {
LABEL_111:
            *(_WORD *)(v86 + 76) = *(_WORD *)(v86 + 80);
            *(_BYTE *)(v86 + 79) = 2;
          }
          if ( v404 == 6 )
          {
            if ( !*(_DWORD *)(v86 + 4) && !*(_DWORD *)(v86 + 8) )
              goto LABEL_203;
          }
          else if ( v404 == 3 )
          {
            goto LABEL_56;
          }
          if ( *(_DWORD *)(v86 + 84) )
          {
            if ( *(_DWORD *)(v86 + 32) )
              return 3;
            if ( *(_BYTE *)(v86 + 124) & 0xF0 )
            {
              *(_DWORD *)(v86 + 128) = 3;
              *(_DWORD *)(v86 + 124) &= 0xFFFFFF0F;
            }
          }
          goto LABEL_56;
        }
        if ( v436 == 5 )
        {
          if ( v105 == v106 )
          {
            v246 = *(_DWORD *)(v86 + 72);
            if ( v246 <= 0 )
            {
              *(_DWORD *)(v86 + 68) += 2;
              v249 = *(_DWORD *)(v86 + 68);
              if ( v249 >= *(_DWORD *)(v86 + 56) )
                v248 = 0;
              else
                v248 = *(_WORD *)v249;
            }
            else
            {
              v247 = v246 - 1;
              *(_DWORD *)(v86 + 72) = v247;
              v248 = *(_WORD *)(v91 + 2 * v247 + 12);
            }
            *(_WORD *)(v86 + 82) = v248;
            v250 = *(_DWORD *)(v86 + 108);
            if ( v250 <= 0 )
            {
              *(_DWORD *)(v86 + 104) += 2;
              v253 = *(_DWORD *)(v86 + 104);
              if ( v253 >= *(_DWORD *)(v86 + 92) )
                v252 = 0;
              else
                v252 = *(_WORD *)v253;
            }
            else
            {
              v251 = v250 - 1;
              *(_DWORD *)(v86 + 108) = v251;
              v252 = *(_WORD *)(v92 + 2 * v251 + 12);
            }
            *(_WORD *)(v86 + 118) = v252;
            *(_DWORD *)(v86 + 76) = -1;
            *(_DWORD *)(v86 + 112) = -1;
          }
          else if ( v404 == 5 )
          {
            v1 = *(_BYTE *)(v86 + 114);
            *(_WORD *)(v86 + 80) = (*(_BYTE *)(v86 + 76) << 8) | *(_BYTE *)(v86 + 78);
            *(_WORD *)(v86 + 116) = v1 | (*(_BYTE *)(v86 + 112) << 8);
          }
          else
          {
            *(_WORD *)(v86 + 80) = -513;
          }
        }
        else if ( v436 == 6 && !*(_DWORD *)(v86 + 4) && v404 != 6 )
        {
          if ( *(_DWORD *)(v86 + 32) )
            return 3;
          *(_DWORD *)(v86 + 132) = 3;
          *(_DWORD *)(v86 + 8) = 1;
LABEL_199:
          v43 = *(_DWORD *)(v86 + 72);
          if ( v43 > 0 )
          {
            v245 = v43 - 1;
            *(_DWORD *)(v86 + 72) = v245;
            v45 = *(_WORD *)(v91 + 2 * v245 + 12);
          }
          else
          {
            *(_DWORD *)(v86 + 68) += 2;
            v44 = *(_DWORD *)(v86 + 68);
            if ( v44 >= *(_DWORD *)(v86 + 56) )
              v45 = 0;
            else
              v45 = *(_WORD *)v44;
          }
          *(_WORD *)(v86 + 82) = v45;
LABEL_203:
          *(_DWORD *)(v86 + 76) = -1;
          goto LABEL_56;
        }
LABEL_56:
        if ( v404 == 1 )
        {
          if ( *(_BYTE *)(v86 + 124) & 3 )
          {
            if ( *(_DWORD *)(v86 + 32) )
              return 1;
            *(_DWORD *)(v86 + 128) = 1;
            *(_DWORD *)(v86 + 124) &= 0xFFFFFF0A;
          }
          goto LABEL_142;
        }
        if ( v404 != 3 )
        {
          if ( v404 == 5 )
          {
            if ( v436 != 5 )
              *(_WORD *)(v86 + 116) = -513;
            goto LABEL_60;
          }
          if ( v404 == 6 && !*(_DWORD *)(v86 + 4) )
          {
            if ( v436 == 6 )
            {
              v15 = *(_BYTE *)(v86 + 76);
              v16 = *(_BYTE *)(v86 + 112);
              if ( v15 == v16 )
              {
                v17 = *(_DWORD *)(v86 + 24);
                if ( v17 && ((v259 = *(_BYTE *)(v86 + 77), v259 <= 0x14u) || v259 == 41) )
                  v18 = 2;
                else
                  v18 = *(_BYTE *)(v86 + 78);
                if ( *(_DWORD *)(v86 + 20) && ((v260 = *(_BYTE *)(v86 + 77), v260 <= 0x14u) || v260 == 41) )
                  v19 = 2;
                else
                  v19 = *(_BYTE *)(v86 + 79) & 0x3F;
                v402 = v19 + 8 * v18;
                if ( v17 && ((v261 = *(_BYTE *)(v86 + 113), v261 <= 0x14u) || v261 == 41) )
                  v20 = 2;
                else
                  v20 = *(_BYTE *)(v86 + 114);
                if ( *(_DWORD *)(v86 + 20) && ((v262 = *(_BYTE *)(v86 + 113), v262 <= 0x14u) || v262 == 41) )
                  v21 = 2;
                else
                  v21 = *(_BYTE *)(v86 + 115) & 0x3F;
                v22 = v21 + 8 * v20;
                if ( v402 == v22 )
                {
LABEL_138:
                  v23 = *(_DWORD *)(v86 + 72);
                  if ( v23 > 0 )
                  {
                    v263 = v23 - 1;
                    *(_DWORD *)(v86 + 72) = v263;
                    v25 = *(_WORD *)(v91 + 2 * v263 + 12);
                  }
                  else
                  {
                    *(_DWORD *)(v86 + 68) += 2;
                    v24 = *(_DWORD *)(v86 + 68);
                    if ( v24 >= *(_DWORD *)(v86 + 56) )
                      v25 = 0;
                    else
                      v25 = *(_WORD *)v24;
                  }
                  *(_WORD *)(v86 + 82) = v25;
                  *(_DWORD *)(v86 + 76) = -1;
LABEL_142:
                  v26 = *(_DWORD *)(v86 + 108);
                  if ( v26 > 0 )
                  {
                    v264 = v26 - 1;
                    *(_DWORD *)(v86 + 108) = v264;
                    v28 = *(_WORD *)(v92 + 2 * v264 + 12);
                  }
                  else
                  {
                    *(_DWORD *)(v86 + 104) += 2;
                    v27 = *(_DWORD *)(v86 + 104);
                    if ( v27 >= *(_DWORD *)(v86 + 92) )
                      v28 = 0;
                    else
                      v28 = *(_WORD *)v27;
                  }
                  *(_WORD *)(v86 + 118) = v28;
                  *(_DWORD *)(v86 + 112) = -1;
                  goto LABEL_60;
                }
                if ( *(_DWORD *)(v86 + 32) )
                  return 3;
                v125 = v402 < v22;
              }
              else
              {
                if ( *(_DWORD *)(v86 + 32) )
                  return 3;
                v125 = v15 < v16;
              }
              *(_DWORD *)(v86 + 8) = 1;
              *(_DWORD *)(v86 + 132) = v125 ? 1 : 3;
              goto LABEL_138;
            }
            if ( *(_DWORD *)(v86 + 32) )
              return 3;
            *(_DWORD *)(v86 + 132) = 1;
            *(_DWORD *)(v86 + 8) = 1;
            goto LABEL_142;
          }
          goto LABEL_60;
        }
        v2 = *(_BYTE *)(v86 + 112);
        v3 = *(_BYTE *)(v86 + 115);
        *(_DWORD *)(v86 + 120) = 0;
        v4 = v3 & 0x3F;
        v400 = v2;
        v398 = v4;
        if ( v2 > 1u )
        {
          *(_WORD *)(v86 + 116) = v2 | 0x2200;
          *(_BYTE *)(v86 + 120) = v4 & 0xC6;
          *(_BYTE *)(v86 + 122) = v4 & 0xE4;
          v5 = 0;
          *(_BYTE *)(v86 + 121) = 3;
          goto LABEL_91;
        }
        v265 = *(_DWORD *)(v86 + 104);
        v5 = 0xFFFF;
        if ( (unsigned int)(v265 - 2) >= *(_DWORD *)v92 )
        {
          v266 = *(_DWORD *)(*(_DWORD *)v86 + 224);
          v357 = 2;
          v390 = v265 - 2;
          while ( 1 )
          {
            v267 = *(_WORD *)v390;
            if ( v266 )
              v267 = *(_DWORD *)(v266 + 4 * (v267 >> 8)) + (unsigned __int8)v267;
            v5 = *(_DWORD *)(v86 + 48) & *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v267);
            v268 = (unsigned int)v5 >> 8;
            HIWORD(v397) = HIWORD(v5);
            if ( BYTE1(v5) >= 3u )
            {
              if ( BYTE1(v5) != 3 )
              {
                *(_WORD *)(v86 + 116) = v5;
                break;
              }
              if ( (unsigned __int8)v5 > 1u )
              {
                v269 = (unsigned __int8)v5 | 0x2200;
                *(_BYTE *)(v86 + 120) = BYTE3(v5) & 6;
                LOWORD(v397) = (unsigned __int8)v5 | 0x2200;
                *(_BYTE *)(v86 + 122) = BYTE3(v5) & 0x24;
                if ( !v400 )
                {
                  *(_BYTE *)(v86 + 123) = BYTE3(v5) & 5;
                  v5 = v397;
                  *(_WORD *)(v86 + 116) = v269;
                  *(_BYTE *)(v86 + 121) = 4;
                  goto LABEL_825;
                }
                v5 = v397;
                *(_WORD *)(v86 + 116) = v397 & 0xFF87;
                v4 = v398;
                *(_BYTE *)(v86 + 121) = 5;
LABEL_91:
                *(_BYTE *)(v86 + 123) = v4 & 0xC5;
                break;
              }
              v5 = 0xFFFF;
            }
            else
            {
              v5 = 0xFFFF;
              if ( (_BYTE)v268 == 2 )
                break;
            }
            v357 += 2;
            v390 -= 2;
            if ( (unsigned int)(*(_DWORD *)(v86 + 104) - v357) < *(_DWORD *)v92 )
              break;
            v266 = *(_DWORD *)(*(_DWORD *)v86 + 224);
          }
        }
        if ( v400 > 1u )
        {
LABEL_93:
          *(_WORD *)(v86 + 112) = *(_WORD *)(v86 + 116);
          *(_BYTE *)(v86 + 115) = 2;
          goto LABEL_94;
        }
LABEL_825:
        if ( v5 != 0xFFFF )
          goto LABEL_93;
        *(_DWORD *)(v86 + 120) = 0;
        *(_WORD *)(v86 + 116) = -1;
        *(_DWORD *)(v86 + 112) = 0xFFFF;
LABEL_94:
        if ( v436 != 6 )
          goto LABEL_934;
        if ( *(_DWORD *)(v86 + 4) )
        {
LABEL_96:
          if ( !*(_DWORD *)(v86 + 120) )
            goto LABEL_60;
          if ( *(_DWORD *)(v86 + 32) )
            return 3;
          if ( !(*(_BYTE *)(v86 + 124) & 0xF0) )
            goto LABEL_60;
          *(_DWORD *)(v86 + 128) = 1;
LABEL_100:
          *(_DWORD *)(v86 + 124) &= 0xFFFFFF0F;
          goto LABEL_60;
        }
        if ( *(_DWORD *)(v86 + 76) != -1 )
        {
LABEL_934:
          if ( v436 != 3 )
            goto LABEL_96;
          v270 = *(_DWORD *)(v86 + 84);
          if ( v270 != *(_DWORD *)(v86 + 120) )
          {
            if ( *(_DWORD *)(v86 + 32) )
              return 3;
            v271 = *(_DWORD *)(v86 + 124);
            if ( !(v271 & 0x10) || (v272 = *(_BYTE *)(v86 + 120), (_BYTE)v270 == v272) )
            {
              if ( v271 & 0x20 && (v273 = *(_BYTE *)(v86 + 85), v274 = *(_BYTE *)(v86 + 121), v273 != v274) )
              {
                *(_DWORD *)(v86 + 128) = v273 < v274 ? 1 : 3;
                *(_DWORD *)(v86 + 124) &= 0xFFFFFF1F;
              }
              else if ( v271 & 0x40 && (v275 = *(_BYTE *)(v86 + 86), v276 = *(_BYTE *)(v86 + 122), v275 != v276) )
              {
                *(_DWORD *)(v86 + 128) = v275 < v276 ? 1 : 3;
                *(_DWORD *)(v86 + 124) &= 0xFFFFFF3F;
              }
              else if ( (char)v271 < 0 )
              {
                v277 = *(_BYTE *)(v86 + 87);
                v278 = *(_BYTE *)(v86 + 123);
                if ( v277 != v278 )
                {
                  *(_DWORD *)(v86 + 128) = v277 < v278 ? 1 : 3;
                  *(_DWORD *)(v86 + 124) &= 0xFFFFFF7F;
                }
              }
              goto LABEL_60;
            }
            *(_DWORD *)(v86 + 128) = (unsigned __int8)v270 < v272 ? 1 : 3;
            goto LABEL_100;
          }
LABEL_60:
          if ( *(_DWORD *)(v86 + 76) != -1 && *(_DWORD *)(v86 + 112) != -1 )
          {
            if ( *(_WORD *)(v86 + 80) != *(_WORD *)(v86 + 116) )
            {
              v107 = *(_WORD *)(v86 + 80) < *(_WORD *)(v86 + 116);
              return v107 ? 1 : 3;
            }
            v29 = v436;
            if ( v436 == 4 )
            {
              if ( v404 != v436 )
                goto LABEL_150;
              if ( *(_DWORD *)(v86 + 84) != *(_DWORD *)(v86 + 120) )
              {
                v107 = *(_DWORD *)(v86 + 84) < *(_DWORD *)(v86 + 120);
                return v107 ? 1 : 3;
              }
            }
LABEL_149:
            v29 = v436;
            if ( (unsigned __int8)(v436 + 87) <= 6u )
              goto LABEL_852;
LABEL_150:
            if ( *(_DWORD *)(v86 + 44) && (unsigned __int8)(v29 + 64) <= 0x2Fu )
            {
LABEL_852:
              v279 = *(_BYTE *)(v86 + 78);
              v280 = *(_BYTE *)(v86 + 114);
              v107 = v279 < v280;
              if ( v279 != v280 )
                return v107 ? 1 : 3;
            }
            if ( *(_BYTE *)(v86 + 124) & 3 )
            {
              v30 = *(_DWORD *)(v86 + 24);
              if ( v30 && ((v116 = *(_BYTE *)(v86 + 77), v116 <= 0x14u) || v116 == 41) )
                v435 = 2;
              else
                v435 = *(_BYTE *)(v86 + 78);
              if ( v30 && ((v117 = *(_BYTE *)(v86 + 113), v117 <= 0x14u) || v117 == 41) )
                v403 = 2;
              else
                v403 = *(_BYTE *)(v86 + 114);
              if ( v435 != v403 )
              {
                v405 = 0;
                while ( 1 )
                {
                  v281 = *(_DWORD *)(v86 + 72);
                  if ( !v281
                    && (*(_DWORD *)(v86 + 60) && !**(_WORD **)(v86 + 68)
                     || *(_DWORD *)(v86 + 68) >= *(_DWORD *)(v86 + 56)) )
                    break;
                  v282 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                  if ( v282 )
                  {
                    if ( v281 <= 0 )
                    {
                      v284 = *(_DWORD *)(v86 + 68) + 2;
                      v283 = (unsigned int)v284 >= *(_DWORD *)(v86 + 56) ? 0 : *(_WORD *)v284;
                    }
                    else
                    {
                      v283 = *(_WORD *)(v91 + 2 * v281 + 10);
                    }
                    if ( v281 <= 0 )
                    {
                      v286 = *(_DWORD *)(v86 + 68) + 2;
                      if ( (unsigned int)v286 >= *(_DWORD *)(v86 + 56) )
                        LOBYTE(v285) = 0;
                      else
                        v285 = *(_WORD *)v286;
                    }
                    else
                    {
                      v285 = *(_WORD *)(v91 + 2 * v281 + 10);
                    }
                    v287 = *(_DWORD *)((*pSortTblPtrs)[11]
                                     + 4
                                     * (*(_DWORD *)(v282 + 4 * ((unsigned int)(unsigned __int16)v283 >> 8))
                                      + (unsigned __int8)v285));
                    v281 = *(_DWORD *)(v86 + 72);
                  }
                  else
                  {
                    if ( v281 <= 0 )
                    {
                      v289 = *(_DWORD *)(v86 + 68) + 2;
                      v288 = (unsigned int)v289 >= *(_DWORD *)(v86 + 56) ? 0 : *(_WORD *)v289;
                    }
                    else
                    {
                      v288 = *(_WORD *)(v91 + 2 * v281 + 10);
                    }
                    v287 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * (unsigned __int16)v288);
                  }
                  if ( BYTE1(v287) != 1 )
                    break;
                  if ( v281 <= 0 )
                  {
                    *(_DWORD *)(v86 + 68) += 2;
                    v292 = *(_DWORD *)(v86 + 68);
                    if ( v292 >= *(_DWORD *)(v86 + 56) )
                      v291 = 0;
                    else
                      v291 = *(_WORD *)v292;
                  }
                  else
                  {
                    v290 = v281 - 1;
                    *(_DWORD *)(v86 + 72) = v290;
                    v291 = *(_WORD *)(v91 + 2 * v290 + 12);
                  }
                  v405 += v287 >> 16;
                  *(_WORD *)(v86 + 82) = v291;
                }
                v437 = v405 + v435;
                v406 = 0;
                while ( 1 )
                {
                  v293 = *(_DWORD *)(v86 + 108);
                  if ( !v293
                    && (*(_DWORD *)(v86 + 96) && !**(_WORD **)(v86 + 104)
                     || *(_DWORD *)(v86 + 104) >= *(_DWORD *)(v86 + 92)) )
                    break;
                  v294 = *(_DWORD *)(*(_DWORD *)v86 + 224);
                  if ( v294 )
                  {
                    if ( v293 <= 0 )
                    {
                      v296 = *(_DWORD *)(v86 + 104) + 2;
                      v295 = (unsigned int)v296 >= *(_DWORD *)(v86 + 92) ? 0 : *(_WORD *)v296;
                    }
                    else
                    {
                      v295 = *(_WORD *)(v92 + 2 * v293 + 10);
                    }
                    if ( v293 <= 0 )
                    {
                      v298 = *(_DWORD *)(v86 + 104) + 2;
                      if ( (unsigned int)v298 >= *(_DWORD *)(v86 + 92) )
                        LOBYTE(v297) = 0;
                      else
                        v297 = *(_WORD *)v298;
                    }
                    else
                    {
                      v297 = *(_WORD *)(v92 + 2 * v293 + 10);
                    }
                    v293 = *(_DWORD *)(v294 + 4 * ((unsigned int)(unsigned __int16)v295 >> 8)) + (unsigned __int8)v297;
                  }
                  else
                  {
                    if ( v293 <= 0 )
                    {
                      v293 = *(_DWORD *)(v86 + 104) + 2;
                      LOWORD(v293) = (unsigned int)v293 >= *(_DWORD *)(v86 + 92) ? 0 : *(_WORD *)v293;
                    }
                    else
                    {
                      LOWORD(v293) = *(_WORD *)(v92 + 2 * v293 + 10);
                    }
                    v293 = (unsigned __int16)v293;
                  }
                  v299 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v293);
                  if ( *(_WORD *)((*pSortTblPtrs)[11] + 4 * v293) >> 8 != 1 )
                    break;
                  v300 = *(_DWORD *)(v86 + 108);
                  if ( v300 <= 0 )
                  {
                    *(_DWORD *)(v86 + 104) += 2;
                    v303 = *(_DWORD *)(v86 + 104);
                    if ( v303 >= *(_DWORD *)(v86 + 92) )
                      v302 = 0;
                    else
                      v302 = *(_WORD *)v303;
                  }
                  else
                  {
                    v301 = v300 - 1;
                    *(_DWORD *)(v86 + 108) = v301;
                    v302 = *(_WORD *)(v92 + 2 * v301 + 12);
                  }
                  v406 += v299 >> 16;
                  *(_WORD *)(v86 + 118) = v302;
                }
                if ( v437 != v406 + v403 )
                {
                  if ( *(_DWORD *)(v86 + 32) )
                    return 1;
                  *(_DWORD *)(v86 + 128) = v437 < (unsigned __int8)(v406 + v403) ? 1 : 3;
                  *(_DWORD *)(v86 + 124) &= 0xFFFFFF0A;
                }
              }
            }
            if ( *(_BYTE *)(v86 + 124) & 4 )
            {
              v31 = *(_DWORD *)(v86 + 20);
              if ( v31 && ((v118 = *(_BYTE *)(v86 + 77), v118 <= 0x14u) || v118 == 41) )
                v32 = 2;
              else
                v32 = *(_BYTE *)(v86 + 79) & 0x3F;
              if ( v31 && ((v119 = *(_BYTE *)(v86 + 113), v119 <= 0x14u) || v119 == 41) )
                v33 = 2;
              else
                v33 = *(_BYTE *)(v86 + 115) & 0x3F;
              if ( v32 != v33 )
              {
                if ( *(_DWORD *)(v86 + 32) )
                  return 1;
                *(_DWORD *)(v86 + 128) = (unsigned __int8)v32 < (unsigned __int8)v33 ? 1 : 3;
                *(_DWORD *)(v86 + 124) &= 0xFFFFFF0B;
              }
            }
LABEL_235:
            v54 = *(_DWORD *)(v86 + 72);
            if ( v54 > 0 )
            {
              v304 = v54 - 1;
              *(_DWORD *)(v86 + 72) = v304;
              v56 = *(_WORD *)(v91 + 2 * v304 + 12);
            }
            else
            {
              *(_DWORD *)(v86 + 68) += 2;
              v55 = *(_DWORD *)(v86 + 68);
              if ( v55 >= *(_DWORD *)(v86 + 56) )
                v56 = 0;
              else
                v56 = *(_WORD *)v55;
            }
            *(_WORD *)(v86 + 82) = v56;
            v57 = *(_DWORD *)(v86 + 108);
            if ( v57 <= 0 )
            {
              *(_DWORD *)(v86 + 104) += 2;
              v59 = *(_DWORD *)(v86 + 104);
              if ( v59 >= *(_DWORD *)(v86 + 92) )
                v53 = 0;
              else
                v53 = *(_WORD *)v59;
            }
            else
            {
              v58 = v57 - 1;
              *(_DWORD *)(v86 + 108) = v58;
              v53 = *(_WORD *)(v92 + 2 * v58 + 12);
            }
            *(_WORD *)(v86 + 118) = v53;
            *(_DWORD *)(v86 + 76) = -1;
            *(_DWORD *)(v86 + 112) = -1;
          }
        }
      }
    }
  }
  if ( !*(_DWORD *)(v86 + 36) )
    goto LABEL_235;
  v60 = *(_WORD *)(v86 + 82);
  if ( v60 )
  {
    if ( *(_WORD *)(v86 + 118) )
      goto LABEL_235;
  }
  if ( v60 == *(_WORD *)(v86 + 118) )
    goto LABEL_235;
  return 2 * (*(_WORD *)(v86 + 82) != 0) + 1;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E2FD9F) --------------------------------------------------------
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  HRESULT result; // eax@1

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    result = sub_77E2DB49((int)pszSrc, cchDest, (int)pszDest, 0, 2147483646);
  return result;
}

//----- (77E2FDDB) --------------------------------------------------------
int __stdcall GetCasingInfo(int a1, int a2)
{
  int v2; // eax@1
  size_t v3; // ecx@1
  void *v4; // eax@1
  int v5; // esi@2
  int result; // eax@3

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)a1 + 4;
  *(_DWORD *)(a2 + 212) = v2 + 2 * *(_WORD *)(v2 + 2) + 4;
  v4 = _bsearch((const void *)(a2 + 8), *(const void **)(a1 + 72), v3, 0x44u, CompareLocales);
  if ( v4 )
    v5 = *(_DWORD *)a1 + 2 * *(_DWORD *)v4;
  else
    v5 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 216) = v5 + 4;
  result = v5 + 2 * *(_WORD *)(v5 + 2) + 4;
  *(_DWORD *)(a2 + 220) = result;
  return result;
}

//----- (77E2FE49) --------------------------------------------------------
int __stdcall GetSortTablesInfo(int a1, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  int result; // eax@4
  int v7; // eax@13
  int v8; // eax@14
  int v9; // eax@15
  int v10; // eax@16
  int v11; // esi@20
  int v12; // [sp+Ch] [bp-Ch]@1
  int v13; // [sp+10h] [bp-8h]@1
  unsigned __int16 *v14; // [sp+14h] [bp-4h]@1
  unsigned __int16 *v15; // [sp+20h] [bp+8h]@1
  int v16; // [sp+24h] [bp+Ch]@1
  int v17; // [sp+24h] [bp+Ch]@4

  v2 = a1;
  v15 = *(unsigned __int16 **)(a1 + 48);
  v3 = *(_DWORD *)(v2 + 64);
  v13 = *(_DWORD *)(v2 + 20);
  v4 = *(_DWORD *)(v2 + 60);
  v14 = *(unsigned __int16 **)(v2 + 52);
  v5 = a2;
  v12 = *(_DWORD *)(v2 + 12);
  v16 = *(_DWORD *)(v2 + 8);
  if ( v16 )
  {
    while ( NlsCompareInvariantNoCase((unsigned __int16 *)(v5 + 8), v15, 32, 1) )
    {
      --v16;
      v15 += 32;
      if ( !v16 )
        goto LABEL_4;
    }
    *(_DWORD *)(v5 + 228) = 1;
  }
LABEL_4:
  result = v13;
  v17 = v13;
  if ( v13 )
  {
    while ( 1 )
    {
      result = NlsCompareInvariantNoCase((unsigned __int16 *)(v5 + 8), (unsigned __int16 *)(v4 + 24), 32, 1);
      if ( !result )
        break;
      --v17;
      v4 += 88;
      if ( !v17 )
        goto LABEL_7;
    }
    *(_DWORD *)(v5 + 232) = 1;
    *(_DWORD *)(v5 + 244) = v4;
    if ( *(_WORD *)(v4 + 8) )
      *(_DWORD *)(v5 + 248) = v3 + 2 * *(_DWORD *)v4;
    v7 = 4 * *(_WORD *)(v4 + 8);
    if ( *(_WORD *)(v4 + 10) > 0u )
      *(_DWORD *)(v5 + 252) = v3 + 2 * (v7 + *(_DWORD *)v4);
    v8 = 6 * *(_WORD *)(v4 + 10) + v7;
    if ( *(_WORD *)(v4 + 12) > 0u )
      *(_DWORD *)(v5 + 256) = v3 + 2 * (v8 + *(_DWORD *)v4);
    v9 = 6 * *(_WORD *)(v4 + 12) + v8;
    if ( *(_WORD *)(v4 + 14) > 0u )
      *(_DWORD *)(v5 + 260) = v3 + 2 * (v9 + *(_DWORD *)v4);
    v10 = v9 + 8 * *(_WORD *)(v4 + 14);
    if ( *(_WORD *)(v4 + 16) > 0u )
      *(_DWORD *)(v5 + 264) = v3 + 2 * (v10 + *(_DWORD *)v4);
    result = v10 + 8 * *(_WORD *)(v4 + 16);
    if ( *(_WORD *)(v4 + 18) > 0u )
      *(_DWORD *)(v5 + 268) = v3 + 2 * (result + *(_DWORD *)v4);
    if ( *(_WORD *)(v4 + 20) > 0u )
    {
      result = v3 + 2 * (result + *(_DWORD *)v4 + 10 * *(_WORD *)(v4 + 18));
      *(_DWORD *)(v5 + 272) = result;
    }
  }
LABEL_7:
  if ( *(_DWORD *)(v5 + 232) )
  {
    v11 = v12;
    while ( v11 )
    {
      result = NlsCompareInvariantNoCase((unsigned __int16 *)(v5 + 8), v14, 32, 1);
      if ( !result )
      {
        *(_DWORD *)(v5 + 236) = 1;
        return result;
      }
      --v11;
      v14 += 32;
    }
  }
  return result;
}

//----- (77E2FEEC) --------------------------------------------------------
PVOID __stdcall CreateSortNode()
{
  return RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0x11Cu);
}

//----- (77E2FF0B) --------------------------------------------------------
int __stdcall SortGetHandle(STRSAFE_LPCWSTR a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = InternalSortGetHandle((int)SortTblPtrs, a1, a2, L"sortdefault.nls", a3);
  if ( result )
  {
    *(_DWORD *)result = 1;
    *(_DWORD *)(result + 180) = *(_DWORD *)(a2 + 8);
    v4 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(result + 280) = 0;
    *(_DWORD *)(result + 184) = v4;
    *(_DWORD *)(result + 192) = SortChangeCase;
    *(_DWORD *)(result + 196) = SortCompareString;
    *(_DWORD *)(result + 200) = SortFindString;
    *(_DWORD *)(result + 188) = SortGetSortKey;
    *(_DWORD *)(result + 204) = SortIsDefinedString;
  }
  return result;
}
// 77EA6620: using guessed type int SortTblPtrs[30];

//----- (77E30006) --------------------------------------------------------
int __stdcall MakeSortNode(int a1, STRSAFE_LPCWSTR pszSrc, int a3)
{
  int v3; // esi@3
  int v5; // eax@12

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 100) + 4) != *(_DWORD *)(a3 + 4) || **(_DWORD **)(a1 + 108) != *(_DWORD *)(a3 + 8) )
  {
    SetLastError(0x57u);
  }
  else
  {
    v3 = (int)CreateSortNode();
    if ( v3 )
    {
      if ( StringCchCopyW((STRSAFE_LPWSTR)(v3 + 8), 0x55u, pszSrc) >= 0 )
      {
        GetSortkeyInfo(a1, v3);
        GetSortTablesInfo(a1, v3);
        GetCasingInfo(a1, v3);
        if ( NlsCompareInvariantNoCase((unsigned __int16 *)pszSrc, L"tr-TR", 6, 1) )
        {
          if ( NlsCompareInvariantNoCase((unsigned __int16 *)pszSrc, L"az-Latn-AZ", 11, 1) )
          {
            if ( !NlsCompareInvariantNoCase((unsigned __int16 *)pszSrc, L"zh", 2, 0)
              || !NlsCompareInvariantNoCase((unsigned __int16 *)pszSrc, L"ja-JP_radstr", 13, 0) )
              *(_DWORD *)(v3 + 240) |= 1u;
LABEL_9:
            *(_DWORD *)(v3 + 276) = v3;
            return v3;
          }
          v5 = MakeSortNode(a1, L"az-Latn-AZ_turkic", a3);
        }
        else
        {
          v5 = MakeSortNode(a1, L"tr-TR_turkic", a3);
        }
        *(_DWORD *)(v3 + 276) = v5;
        if ( v5 )
          return v3;
        goto LABEL_9;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v3);
    }
  }
  return 0;
}
// 77E300DC: using guessed type wchar_t aJaJp_radstr[13];
// 77E300F8: using guessed type wchar_t aZh[3];
// 77E30100: using guessed type wchar_t aAzLatnAz[11];
// 77E30118: using guessed type wchar_t aTrTr[6];
// 77E5AA00: using guessed type wchar_t aTrTr_turkic[13];

//----- (77E30129) --------------------------------------------------------
int __fastcall NlsCompareInvariantNoCase(unsigned __int16 *a1, unsigned __int16 *a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned __int16 v5; // si@3
  unsigned __int16 v6; // ax@4
  int result; // eax@7

  v4 = a3;
  while ( v4 > 0 )
  {
    v5 = *a1;
    if ( !*a1 )
      break;
    v6 = *a2;
    if ( !*a2 )
      break;
    if ( (unsigned __int16)(v5 - 65) <= 0x19u )
      v5 |= 0x20u;
    if ( (unsigned __int16)(v6 - 65) <= 0x19u )
      v6 |= 0x20u;
    result = v5 - v6;
    if ( result )
      return result;
    --v4;
    ++a1;
    ++a2;
  }
  if ( (a4 || v4) && (*a1 || *a2) )
    result = 2 * (*a1 != 0) - 1;
  else
    result = 0;
  return result;
}

//----- (77E30188) --------------------------------------------------------
void *__stdcall GetSortkeyInfo(int a1, int a2)
{
  void *result; // eax@1

  result = _bsearch((const void *)(a2 + 8), *(const void **)(a1 + 68), *(_DWORD *)(a1 + 24), 0x44u, CompareLocales);
  if ( result )
  {
    result = (void *)(*(_DWORD *)(a1 + 44) + 4 * *(_DWORD *)result);
    *(_DWORD *)(a2 + 224) = result;
  }
  else
  {
    *(_DWORD *)(a2 + 224) = 0;
  }
  return result;
}

//----- (77E301CA) --------------------------------------------------------
int __cdecl CompareLocales(const void *a1, const void *a2)
{
  return NlsCompareInvariantNoCase((unsigned __int16 *)a1, (unsigned __int16 *)a2 + 2, 32, 1);
}

//----- (77E30228) --------------------------------------------------------
UINT __stdcall SetErrorModeStub(UINT uMode)
{
  return SetErrorMode(uMode);
}

//----- (77E3023B) --------------------------------------------------------
DWORD __fastcall CheckElevationEnabled(int a1, int a2, int a3)
{
  NTSTATUS v3; // eax@1
  int v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  v3 = RtlQueryElevationFlags(&v5);
  if ( v3 >= 0 )
  {
    *(_DWORD *)a3 = v5 & 1;
    v3 = 0;
  }
  return RtlNtStatusToDosErrorNoTeb(v3);
}
// 77DE1448: using guessed type int __stdcall RtlQueryElevationFlags(_DWORD);

//----- (77E3027D) --------------------------------------------------------
signed int __stdcall GetDefaultSortTablesInfo(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edx@3
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // edx@7
  int v8; // ecx@7
  int v9; // ecx@9
  int v10; // edx@9
  int v11; // ecx@11
  int v12; // edx@11
  int v13; // edx@12
  int v14; // edi@12
  int v15; // ecx@12
  int v16; // ecx@12
  int v17; // edx@13
  int v18; // ecx@15
  int v19; // edx@15
  int v20; // ecx@17
  int v21; // edx@17
  int v22; // ecx@19

  v2 = *(_DWORD *)a2;
  v3 = a2 + 4;
  *(_DWORD *)(a1 + 104) = *(_DWORD *)a2;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 108) = v3;
    v3 += 2 * ((unsigned int)(8 * v2) >> 1);
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 0;
  }
  v4 = *(_DWORD *)v3;
  *(_DWORD *)(a1 + 96) = *(_DWORD *)v3;
  if ( v4 )
    *(_DWORD *)(a1 + 100) = v3 + 4;
  else
    *(_DWORD *)(a1 + 100) = 0;
  v5 = v3 + 8 * *(_DWORD *)(a1 + 96) + 4;
  v6 = *(_DWORD *)v5;
  if ( *(_DWORD *)v5 )
  {
    *(_DWORD *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 48) = v5 + 4;
  }
  v7 = v5 + (v6 << 6) + 4;
  v8 = *(_DWORD *)v7;
  if ( *(_DWORD *)v7 )
  {
    *(_DWORD *)(a1 + 12) = v8;
    *(_DWORD *)(a1 + 52) = v7 + 4;
  }
  v9 = v7 + (v8 << 6) + 4;
  v10 = *(_DWORD *)v9;
  if ( *(_DWORD *)v9 )
  {
    *(_DWORD *)(a1 + 16) = v10;
    *(_DWORD *)(a1 + 56) = v9 + 4;
  }
  v11 = v9 + 4 * v10 + 4;
  v12 = *(_DWORD *)v11;
  if ( *(_DWORD *)v11 )
  {
    *(_DWORD *)(a1 + 20) = v12;
    v13 = 88 * v12;
    *(_DWORD *)(a1 + 60) = v11 + 4;
    v14 = v13 + v11 + 4;
    v15 = v13 + v11 + 4;
    *(_DWORD *)(a1 + 64) = v14;
    v16 = v14
        + 2
        * (*(_DWORD *)(v15 - 88)
         + 10 * (*(_WORD *)(v15 - 68) + *(_WORD *)(v15 - 70))
         + 6 * (*(_WORD *)(v15 - 76) + *(_WORD *)(v15 - 78))
         + 4 * (*(_WORD *)(v15 - 80) + 2 * (*(_WORD *)(v15 - 72) + *(_WORD *)(v15 - 74))));
  }
  else
  {
    v16 = v11 + 4;
  }
  v17 = *(_WORD *)v16;
  if ( *(_WORD *)v16 )
  {
    *(_DWORD *)(a1 + 32) = v17;
    *(_DWORD *)(a1 + 84) = v16 + 4;
  }
  v18 = v16 + 2 * v17 + 4;
  v19 = *(_WORD *)v18;
  if ( *(_WORD *)v18 )
  {
    *(_DWORD *)(a1 + 36) = v19;
    *(_DWORD *)(a1 + 88) = v18 + 4;
  }
  v20 = v18 + 8 * v19 + 4;
  v21 = *(_WORD *)v20;
  if ( *(_WORD *)v20 )
  {
    *(_DWORD *)(a1 + 40) = v21;
    *(_DWORD *)(a1 + 92) = v20 + 4;
  }
  v22 = v20 + 8 * v21 + 4;
  if ( *(_DWORD *)v22 )
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)v22;
    *(_DWORD *)(a1 + 68) = v22 + 4;
  }
  return 1;
}

//----- (77E303C6) --------------------------------------------------------
signed int __stdcall GetDefaultCasingInfo(int a1, int a2)
{
  size_t v2; // ST08_4@1
  unsigned int v3; // edx@1
  void *v4; // eax@1
  int v5; // eax@2

  v2 = *(_DWORD *)a2;
  v3 = a2 + 4 + 2 * ((unsigned int)(68 * *(_DWORD *)a2) >> 1);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 72) = a2 + 4;
  *(_DWORD *)a1 = v3;
  v4 = _bsearch(L"linguistic_casing", (const void *)(a2 + 4), v2, 0x44u, CompareLocales);
  if ( v4 )
    v5 = *(_DWORD *)a1 + 2 * *(_DWORD *)v4;
  else
    v5 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = v5;
  return 1;
}
// 77E3041C: using guessed type wchar_t aLinguistic_cas[18];

//----- (77E30445) --------------------------------------------------------
signed int __stdcall GetCTypeInfo(int a1, int a2)
{
  *(_DWORD *)(a1 + 76) = a2 + 4;
  *(_DWORD *)(a1 + 80) = *(_WORD *)(a2 + 2) + a2 + 2;
  return 1;
}

//----- (77E3046D) --------------------------------------------------------
int __stdcall GetDefaultSortFileMapping(LPCWSTR lpFileName, int a2)
{
  signed int v2; // esi@1
  HANDLE v3; // eax@1
  void *v4; // ebx@1
  HANDLE v5; // eax@2
  void *v6; // edi@2
  LPVOID v7; // eax@3
  int result; // eax@5

  v2 = 0;
  v3 = CreateFileW(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v4 = v3;
  if ( v3 == (HANDLE)-1 )
  {
    result = 0;
  }
  else
  {
    v5 = CreateFileMappingW(v3, 0, 2u, 0, 0, 0);
    v6 = v5;
    if ( v5 )
    {
      v7 = MapViewOfFile(v5, 4u, 0, 0, 0);
      if ( v7 )
      {
        *(_DWORD *)a2 = v7;
        v2 = 1;
      }
      CloseHandle(v6);
      CloseHandle(v4);
      result = v2;
    }
    else
    {
      CloseHandle(v4);
      result = 0;
    }
  }
  return result;
}

//----- (77E30619) --------------------------------------------------------
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPWSTR v4; // ebx@3
  STRSAFE_LPWSTR v5; // ecx@4

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  v4 = pszDest;
  if ( result < 0 )
  {
    v5 = 0;
  }
  else
  {
    result = sub_77E30675((int)pszDest, cchDest, (int)&pszDest);
    v5 = pszDest;
  }
  if ( result >= 0 )
    result = sub_77E2DB49((int)pszSrc, cchDest - (_DWORD)v5, (int)&v4[(_DWORD)v5], 0, 0x7FFFFFFF);
  return result;
}

//----- (77E30675) --------------------------------------------------------
int __usercall sub_77E30675@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int v3; // esi@1
  int result; // eax@1
  int v5; // ecx@1

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( !a2 )
    goto LABEL_11;
  do
  {
    if ( !*(_WORD *)v3 )
      break;
    v3 += 2;
    --a2;
  }
  while ( a2 );
  if ( !a2 )
LABEL_11:
    result = -2147024809;
  JUMPOUT(a3, 0, nullsub_1);
  if ( result < 0 )
  {
    *(_DWORD *)a3 = 0;
    result = nullsub_1(v5);
  }
  else
  {
    *(_DWORD *)a3 = v5 - a2;
  }
  return result;
}
// 77E5598D: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (77E306BD) --------------------------------------------------------
DWORD __stdcall SetFilePointerStub(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
{
  return SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
}

//----- (77E306E1) --------------------------------------------------------
BOOL __stdcall IsCombiningJamo(unsigned __int16 a1)
{
  return a1 >= 0x1100u && a1 <= 0x115Au || a1 >= 0x115Fu && a1 <= 0x11A2u || (unsigned __int16)(a1 - 4520) <= 0x51u;
}

//----- (77E307F4) --------------------------------------------------------
PWSTR __stdcall SkipPathTypeIndicator_U(PWSTR Path)
{
  signed int v1; // edi@5
  WCHAR v2; // ax@6
  PWSTR v3; // esi@1
  ULONG v4; // eax@1
  int v5; // eax@2
  int v7; // eax@12
  int v8; // eax@13
  int v9; // eax@14

  v3 = Path;
  v4 = RtlDetermineDosPathNameType_U(Path) - 1;
  if ( !v4 )
  {
LABEL_5:
    v1 = 2;
    v3 = Path + 2;
    if ( !__wcsnicmp(Path + 2, L"?\\UNC", 5u) )
      v3 = Path + 8;
    do
    {
      v2 = *v3;
      if ( !*v3 )
        break;
      if ( v2 == 92 || v2 == 47 )
        --v1;
      ++v3;
    }
    while ( v1 );
    return v3;
  }
  v5 = v4 - 1;
  if ( !v5 )
    return Path + 3;
  v7 = v5 - 1;
  if ( !v7 )
    return Path + 2;
  v8 = v7 - 1;
  if ( !v8 )
    return Path + 1;
  v9 = v8 - 1;
  if ( v9 )
  {
    if ( v9 != 1 )
      return 0;
    goto LABEL_5;
  }
  return v3;
}

//----- (77E30821) --------------------------------------------------------
NTSTATUS __stdcall BaseFormatObjectAttributes(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@5
  int v5; // edi@5
  int v6; // eax@8
  int v7; // eax@8
  void (__stdcall *v8)(_DWORD); // eax@8
  int v9; // esi@1
  NTSTATUS result; // eax@3

  v9 = 0;
  if ( a2 )
  {
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a2 + 8) != 0 ? 2 : 0;
  }
  else
  {
    if ( !a3 )
    {
LABEL_3:
      *(_DWORD *)a4 = v9;
      return 0;
    }
    v5 = 0;
    v4 = 0;
  }
  if ( !a3 )
  {
    a2 = 0;
    goto LABEL_8;
  }
  result = BaseGetNamedObjectDirectory((int)&a2);
  if ( result >= 0 )
  {
    v5 |= 0x80u;
LABEL_8:
    v9 = a1;
    v6 = a2;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 4) = v6;
    v7 = a3;
    *(_DWORD *)a1 = 24;
    *(_DWORD *)(a1 + 12) = v5;
    *(_DWORD *)(a1 + 8) = v7;
    *(_DWORD *)(a1 + 16) = v4;
    v8 = *(void (__stdcall **)(_DWORD))(KernelBaseGetGlobalData() + 92);
    if ( v8 )
      v8(a1);
    goto LABEL_3;
  }
  return result;
}

//----- (77E30852) --------------------------------------------------------
int __stdcall CreateProcessInternalW(void *a1, _DWORD a2, const wchar_t *a3, int a4, int a5, int a6, unsigned int a7, int a8, const WCHAR *a9, int a10, int a11, _DWORD a12)
{
  unsigned int v12; // eax@134
  const wchar_t *v13; // esi@134
  const wchar_t v15; // ax@146
  STRSAFE_LPCWSTR v16; // esi@149
  PVOID v17; // eax@150
  wchar_t *v18; // edi@150
  STRSAFE_LPCWSTR v19; // esi@151
  STRSAFE_LPCWSTR v20; // eax@163
  const wchar_t v21; // di@165
  DWORD v22; // eax@167
  DWORD v23; // eax@169
  unsigned int v24; // eax@183
  int v25; // edx@183
  unsigned int i; // ecx@183
  HMODULE v27; // eax@199
  PIMAGE_NT_HEADERS v28; // eax@199
  _WORD v29; // cx@4
  HANDLE v30; // ecx@20
  int v31; // edi@23
  NTSTATUS v32; // eax@25
  HANDLE v33; // eax@29
  PVOID v34; // edi@37
  DWORD v35; // eax@38
  DWORD v36; // esi@38
  DWORD v37; // eax@40
  int v38; // eax@44
  ULONG v39; // eax@67
  PRTL_USER_PROCESS_PARAMETERS v40; // eax@69
  struct _RTL_USER_PROCESS_PARAMETERS *v41; // esi@69
  int v42; // edi@70
  int v43; // edi@71
  int v44; // eax@76
  unsigned int v45; // eax@107
  NTSTATUS v46; // edi@107
  int v47; // eax@115
  NTSTATUS v48; // esi@115
  HANDLE v49; // eax@116
  int v50; // esi@118
  NTSTATUS v51; // eax@207
  int v52; // esi@226
  _DWORD v53; // eax@227
  NTSTATUS v54; // eax@271
  _BYTE v55; // al@284
  int v56; // edi@296
  int v57; // esi@299
  WCHAR *v58; // esi@319
  DWORD v59; // eax@321
  PVOID v60; // eax@323
  const WCHAR *v61; // edi@323
  DWORD v62; // eax@324
  signed int v63; // eax@344
  char v64; // [sp+10h] [bp-648h]@45
  char v65; // [sp+28h] [bp-630h]@44
  ULONG v66; // [sp+40h] [bp-618h]@27
  PVOID v67; // [sp+48h] [bp-610h]@58
  int v68; // [sp+6Ch] [bp-5ECh]@34
  struct _TEB *v69; // [sp+84h] [bp-5D4h]@323
  PIMAGE_NT_HEADERS v70; // [sp+88h] [bp-5D0h]@199
  int v71; // [sp+8Ch] [bp-5CCh]@226
  struct _TEB *v72; // [sp+90h] [bp-5C8h]@367
  struct _TEB *v73; // [sp+94h] [bp-5C4h]@157
  struct _TEB *v74; // [sp+98h] [bp-5C0h]@172
  struct _TEB *v75; // [sp+9Ch] [bp-5BCh]@126
  struct _TEB *v76; // [sp+A0h] [bp-5B8h]@319
  struct _TEB *v77; // [sp+A4h] [bp-5B4h]@209
  struct _TEB *v78; // [sp+ACh] [bp-5ACh]@363
  PVOID *v79; // [sp+B0h] [bp-5A8h]@183
  struct _TEB *v80; // [sp+B4h] [bp-5A4h]@143
  struct _TEB *v81; // [sp+B8h] [bp-5A0h]@281
  struct _TEB *v82; // [sp+BCh] [bp-59Ch]@128
  ULONG Arguments; // [sp+C0h] [bp-598h]@305
  struct _TEB *v84; // [sp+C8h] [bp-590h]@37
  WCHAR *v85; // [sp+CCh] [bp-58Ch]@134
  struct _TEB *v86; // [sp+D0h] [bp-588h]@365
  struct _TEB *v87; // [sp+D4h] [bp-584h]@304
  struct _TEB *v88; // [sp+D8h] [bp-580h]@209
  struct _TEB *v89; // [sp+DCh] [bp-57Ch]@297
  struct _TEB *v90; // [sp+E0h] [bp-578h]@234
  PRTL_USER_PROCESS_PARAMETERS v91; // [sp+E4h] [bp-574h]@69
  struct _TEB *v92; // [sp+E8h] [bp-570h]@150
  int v93; // [sp+ECh] [bp-56Ch]@320
  int v94; // [sp+F0h] [bp-568h]@19
  int v95; // [sp+100h] [bp-558h]@71
  unsigned __int16 v96; // [sp+104h] [bp-554h]@73
  unsigned __int16 v97; // [sp+106h] [bp-552h]@73
  unsigned int v98; // [sp+10Eh] [bp-54Ah]@92
  unsigned __int16 v99; // [sp+110h] [bp-548h]@87
  int v100; // [sp+120h] [bp-538h]@1
  HANDLE v101; // [sp+124h] [bp-534h]@1
  int v102; // [sp+128h] [bp-530h]@110
  PVOID v103; // [sp+12Ch] [bp-52Ch]@110
  unsigned __int16 v104; // [sp+130h] [bp-528h]@110
  unsigned __int16 v105; // [sp+132h] [bp-526h]@110
  unsigned int v106; // [sp+134h] [bp-524h]@110
  int v107; // [sp+138h] [bp-520h]@110
  int v108; // [sp+140h] [bp-518h]@282
  int v109; // [sp+144h] [bp-514h]@282
  DWORD v110; // [sp+148h] [bp-510h]@38
  unsigned int v111; // [sp+14Ch] [bp-50Ch]@184
  int v112; // [sp+150h] [bp-508h]@45
  int v113; // [sp+154h] [bp-504h]@1
  ULONG ReturnLength; // [sp+158h] [bp-500h]@142
  int v115; // [sp+15Ch] [bp-4FCh]@1
  int v116; // [sp+160h] [bp-4F8h]@336
  ULONG MessageBoxResult; // [sp+164h] [bp-4F4h]@305
  ULONG v118; // [sp+168h] [bp-4F0h]@319
  STRING AnsiString; // [sp+16Ch] [bp-4ECh]@4
  int v120; // [sp+174h] [bp-4E4h]@44
  UNICODE_STRING SourceString; // [sp+178h] [bp-4E0h]@4
  int v122; // [sp+180h] [bp-4D8h]@46
  ULONG v123; // [sp+184h] [bp-4D4h]@67
  int TokenInformation; // [sp+188h] [bp-4D0h]@142
  DWORD v125; // [sp+18Ch] [bp-4CCh]@40
  int v126; // [sp+190h] [bp-4C8h]@86
  LPWSTR FilePart; // [sp+194h] [bp-4C4h]@4
  ULONG v128; // [sp+198h] [bp-4C0h]@323
  ULONG v129; // [sp+19Ch] [bp-4BCh]@37
  BOOL Result; // [sp+1A4h] [bp-4B4h]@31
  unsigned int v131; // [sp+1A8h] [bp-4B0h]@299
  int v132; // [sp+1ACh] [bp-4ACh]@137
  ULONG Flags; // [sp+1B0h] [bp-4A8h]@172
  int v134; // [sp+1B4h] [bp-4A4h]@118
  int v135; // [sp+1B8h] [bp-4A0h]@53
  int v136; // [sp+1BCh] [bp-49Ch]@129
  void *v137; // [sp+1C0h] [bp-498h]@53
  void *v138; // [sp+1C4h] [bp-494h]@58
  void *v139; // [sp+1C8h] [bp-490h]@71
  int v140; // [sp+1DCh] [bp-47Ch]@92
  int v141; // [sp+1E0h] [bp-478h]@83
  int v142; // [sp+1E4h] [bp-474h]@93
  int v143; // [sp+1E8h] [bp-470h]@93
  int v144; // [sp+1F0h] [bp-468h]@75
  int v145; // [sp+1F4h] [bp-464h]@75
  int v146; // [sp+1F8h] [bp-460h]@75
  unsigned int v147; // [sp+200h] [bp-458h]@183
  int v148; // [sp+204h] [bp-454h]@183
  int v149; // [sp+208h] [bp-450h]@4
  int v150; // [sp+20Ch] [bp-44Ch]@4
  int v151; // [sp+210h] [bp-448h]@4
  int v152; // [sp+214h] [bp-444h]@1
  int v153; // [sp+218h] [bp-440h]@92
  int v154; // [sp+21Ch] [bp-43Ch]@19
  int v155; // [sp+220h] [bp-438h]@93
  int v156; // [sp+224h] [bp-434h]@232
  void *v157; // [sp+228h] [bp-430h]@232
  LPCWSTR lpFileName; // [sp+22Ch] [bp-42Ch]@1
  int v159; // [sp+230h] [bp-428h]@4
  PVOID v160; // [sp+234h] [bp-424h]@4
  int v161; // [sp+238h] [bp-420h]@4
  int v162; // [sp+23Ch] [bp-41Ch]@83
  ULONG BufferLength; // [sp+240h] [bp-418h]@4
  int v164; // [sp+244h] [bp-414h]@4
  char v165[4]; // [sp+248h] [bp-410h]@4
  ULONG v166; // [sp+24Ch] [bp-40Ch]@51
  int v167; // [sp+250h] [bp-408h]@60
  unsigned int v168; // [sp+254h] [bp-404h]@1
  HANDLE v169; // [sp+258h] [bp-400h]@296
  PVOID BaseAddress; // [sp+25Ch] [bp-3FCh]@195
  int v171; // [sp+260h] [bp-3F8h]@1
  int v172; // [sp+264h] [bp-3F4h]@4
  DWORD v173; // [sp+268h] [bp-3F0h]@159
  HANDLE v174; // [sp+26Ch] [bp-3ECh]@4
  int v175; // [sp+270h] [bp-3E8h]@1
  char v176[4]; // [sp+274h] [bp-3E4h]@4
  PVOID v177; // [sp+278h] [bp-3E0h]@4
  int v178; // [sp+27Ch] [bp-3DCh]@51
  LSA_UNICODE_STRING v179; // [sp+280h] [bp-3D8h]@4
  UNICODE_STRING DestinationString; // [sp+288h] [bp-3D0h]@66
  STRSAFE_LPCWSTR v181; // [sp+290h] [bp-3C8h]@149
  PVOID v182; // [sp+294h] [bp-3C4h]@4
  int v183; // [sp+298h] [bp-3C0h]@4
  int v184; // [sp+29Ch] [bp-3BCh]@1
  PVOID Environment; // [sp+2A0h] [bp-3B8h]@1
  char v186[4]; // [sp+2A4h] [bp-3B4h]@4
  PVOID v187; // [sp+2A8h] [bp-3B0h]@4
  char v188[4]; // [sp+2ACh] [bp-3ACh]@4
  size_t v189; // [sp+2B0h] [bp-3A8h]@320
  PPEB v190; // [sp+2B4h] [bp-3A4h]@4
  int v191; // [sp+2B8h] [bp-3A0h]@4
  PVOID Buffer; // [sp+2BCh] [bp-39Ch]@4
  LPWSTR lpBuffer; // [sp+2C0h] [bp-398h]@4
  int v194; // [sp+2C4h] [bp-394h]@1
  int v195; // [sp+2C8h] [bp-390h]@4
  PVOID v196; // [sp+2CCh] [bp-38Ch]@4
  PVOID v197; // [sp+2D0h] [bp-388h]@4
  NTSTATUS ExitStatus; // [sp+2D4h] [bp-384h]@4
  PVOID v199; // [sp+2D8h] [bp-380h]@1
  unsigned int v200; // [sp+2DCh] [bp-37Ch]@70
  LSA_UNICODE_STRING UnicodeString; // [sp+2E0h] [bp-378h]@1
  ULONG Size; // [sp+2E8h] [bp-370h]@150
  HANDLE v203; // [sp+2ECh] [bp-36Ch]@4
  LPCWSTR lpPath; // [sp+2F0h] [bp-368h]@1
  int v205; // [sp+2F4h] [bp-364h]@1
  int ProcessInformation; // [sp+2F8h] [bp-360h]@88
  PVOID Address; // [sp+2FCh] [bp-35Ch]@4
  int v208; // [sp+300h] [bp-358h]@1
  HANDLE TokenHandle; // [sp+304h] [bp-354h]@1
  HANDLE v210; // [sp+308h] [bp-350h]@4
  char v211; // [sp+30Dh] [bp-34Bh]@60
  char v212; // [sp+30Eh] [bp-34Ah]@256
  char v213; // [sp+30Fh] [bp-349h]@162
  STRSAFE_LPCWSTR v214; // [sp+310h] [bp-348h]@1
  HANDLE ThreadHandle; // [sp+314h] [bp-344h]@4
  NTSTATUS v216; // [sp+318h] [bp-340h]@76
  int v217; // [sp+31Ch] [bp-33Ch]@4
  int v218; // [sp+320h] [bp-338h]@1
  HANDLE Handle; // [sp+324h] [bp-334h]@4
  char v220; // [sp+32Bh] [bp-32Dh]@4
  STRSAFE_LPCWSTR pszSrc; // [sp+32Ch] [bp-32Ch]@1
  char v222; // [sp+331h] [bp-327h]@4
  char v223; // [sp+332h] [bp-326h]@60
  char Str[5]; // [sp+333h] [bp-325h]@1
  HANDLE ProcessHandle; // [sp+338h] [bp-320h]@4
  char v226; // [sp+33Eh] [bp-31Ah]@4
  char v227; // [sp+33Fh] [bp-319h]@14
  int v228; // [sp+340h] [bp-318h]@19
  int v229; // [sp+344h] [bp-314h]@1
  char Dst; // [sp+348h] [bp-310h]@4
  int v231; // [sp+448h] [bp-210h]@102
  NTSTATUS NtStatus; // [sp+468h] [bp-1F0h]@102
  HANDLE v233; // [sp+470h] [bp-1E8h]@93
  HANDLE v234; // [sp+474h] [bp-1E4h]@93
  int v235; // [sp+478h] [bp-1E0h]@93
  int v236; // [sp+47Ch] [bp-1DCh]@93
  unsigned int v237; // [sp+480h] [bp-1D8h]@93
  signed int v238; // [sp+484h] [bp-1D4h]@98
  int v239; // [sp+488h] [bp-1D0h]@346
  signed int v240; // [sp+48Ch] [bp-1CCh]@346
  _DWORD v241; // [sp+490h] [bp-1C8h]@87
  int v242; // [sp+494h] [bp-1C4h]@92
  _DWORD v243; // [sp+4F8h] [bp-160h]@107
  _DWORD v244; // [sp+504h] [bp-154h]@110
  _DWORD v245; // [sp+510h] [bp-148h]@107
  int v246; // [sp+518h] [bp-140h]@93
  int v247; // [sp+51Ch] [bp-13Ch]@93
  int v248; // [sp+520h] [bp-138h]@93
  _WORD v249; // [sp+524h] [bp-134h]@93
  int v250; // [sp+528h] [bp-130h]@70
  int v251; // [sp+52Ch] [bp-12Ch]@19
  int v252; // [sp+530h] [bp-128h]@70
  PWCH v253; // [sp+534h] [bp-124h]@70
  int v254; // [sp+538h] [bp-120h]@19
  int v255; // [sp+53Ch] [bp-11Ch]@19
  int v256; // [sp+540h] [bp-118h]@19
  int *v257; // [sp+544h] [bp-114h]@19
  int v258; // [sp+548h] [bp-110h]@19
  int v259; // [sp+54Ch] [bp-10Ch]@19
  int v260; // [sp+550h] [bp-108h]@19
  int *v261; // [sp+554h] [bp-104h]@19
  int v262; // [sp+558h] [bp-100h]@19
  int v263; // [sp+55Ch] [bp-FCh]@275
  int v264; // [sp+560h] [bp-F8h]@275
  int v265; // [sp+564h] [bp-F4h]@275
  int v266; // [sp+568h] [bp-F0h]@275
  CPPEH_RECORD ms_exc; // [sp+640h] [bp-18h]@23

  TokenHandle = a1;
  *(_DWORD *)&Str[1] = a2;
  pszSrc = a3;
  v113 = a4;
  v115 = a5;
  v205 = a8;
  lpFileName = a9;
  v152 = a10;
  v194 = a11;
  v229 = 0;
  v214 = 0;
  v171 = 0;
  v184 = 0;
  v218 = 0;
  v208 = 0;
  Environment = 0;
  v199 = 0;
  v175 = 0;
  lpPath = 0;
  UnicodeString.Length = 0;
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  v100 = 0;
  memset(&v101, 0, 0x1Cu);
  v168 = 0;
  if ( !a2 && !a3 )
  {
    BaseSetLastNTError(-1073741776);
    return 0;
  }
  if ( !v194 || !v152 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v210 = 0;
  Handle = 0;
  v203 = 0;
  ProcessHandle = 0;
  ThreadHandle = 0;
  v195 = 0;
  Address = 0;
  v196 = 0;
  v191 = 0;
  v183 = 0;
  v160 = 0;
  FilePart = 0;
  lpBuffer = 0;
  v177 = 0;
  v179.Buffer = 0;
  Str[0] = 0;
  v220 = 0;
  v226 = 0;
  v222 = 0;
  v174 = 0;
  v197 = 0;
  Buffer = 0;
  BufferLength = 0;
  v187 = 0;
  v161 = 0;
  v182 = 0;
  v172 = 0;
  *(_DWORD *)v188 = 0;
  *(_DWORD *)v176 = 0;
  v164 = 0;
  *(_DWORD *)v165 = 0;
  *(_DWORD *)v186 = 0;
  ExitStatus = 0;
  v217 = 0;
  v159 = 0;
  v149 = 0;
  v150 = 0;
  v151 = 0;
  AnsiString.Buffer = 0;
  SourceString.Buffer = 0;
  memset(&Dst, 0, 0x100u);
  v190 = NtCurrentTeb()->ProcessEnvironmentBlock;
  v29 = a7;
  if ( (a7 & 0x18) == 24 )
    goto LABEL_376;
  if ( !(a7 & 0x800) )
  {
    if ( !(a7 & 0x1000) && *(_BYTE *)(BaseStaticServerData + 1872) )
    {
      v29 = a7 | 0x800;
      a7 |= 0x800u;
    }
    goto LABEL_8;
  }
  if ( a7 & 0x1000 )
  {
LABEL_376:
    RtlSetLastWin32Error(87);
    return 0;
  }
LABEL_8:
  if ( v29 & 0x40 )
  {
    v227 = 1;
  }
  else if ( v29 & 0x4000 )
  {
    v227 = 5;
  }
  else if ( v29 & 0x20 )
  {
    v227 = 2;
  }
  else if ( v29 & 0x8000 )
  {
    v227 = 6;
  }
  else if ( (char)v29 < 0 )
  {
    v227 = 3;
  }
  else if ( v29 & 0x100 )
  {
    v227 = (BasepIsRealtimeAllowed(0, TokenHandle != 0) != 0) + 3;
  }
  else
  {
    v227 = 0;
  }
  a7 &= 0xFFFF3E1F;
  if ( a7 & 0x40000 )
    v217 = 64;
  if ( a7 & 0x1000000 )
    v217 |= 1u;
  if ( a7 & 0x10000 )
    v217 |= 0x100u;
  if ( a7 & 3 )
  {
    v54 = DbgUiConnectToDbg();
    if ( v54 < 0 )
    {
      BaseSetLastNTError(v54);
      return 0;
    }
    v195 = DbgUiGetThreadDebugObject();
    if ( a7 & 2 )
      v217 |= 2u;
  }
  v251 = 131077;
  v254 = 0;
  v255 = 65539;
  v256 = 8;
  v258 = 0;
  v257 = &v154;
  v259 = 6;
  v260 = 48;
  v262 = 0;
  v261 = &v94;
  v228 = 3;
  if ( v195 )
  {
    v263 = 393217;
    v264 = 4;
    v266 = 0;
    v265 = v195;
    v228 = 4;
  }
  v30 = TokenHandle;
  if ( TokenHandle )
  {
    *(&v251 + 4 * v228) = 393218;
    *(&v252 + 4 * v228) = 4;
    *(&v254 + 4 * v228) = 0;
    (&v253)[8 * v228++] = (PWCH)v30;
  }
  if ( v227 )
  {
    *(&v251 + 4 * v228) = 131080;
    *(&v252 + 4 * v228) = 1;
    *(&v254 + 4 * v228) = 0;
    (&v253)[8 * v228++] = (PWCH)&v227;
  }
  if ( a7 & 0x4000000 )
  {
    v132 = 1;
    *(&v251 + 4 * v228) = 131081;
    *(&v252 + 4 * v228) = 4;
    *(&v254 + 4 * v228) = 0;
    (&v253)[8 * v228++] = (PWCH)&v132;
  }
  ms_exc.registration.TryLevel = 0;
  v31 = v194;
  *(_DWORD *)v194 = 0;
  v31 += 4;
  *(_DWORD *)v31 = 0;
  v31 += 4;
  *(_DWORD *)v31 = 0;
  *(_DWORD *)(v31 + 4) = 0;
  if ( v205 && !(a7 & 0x400) )
  {
    v32 = RtlCreateEnvironmentEx(v205, &Environment, 1);
    if ( v32 < 0 )
    {
      BaseSetLastNTError(v32);
      _local_unwind4(&__security_cookie, &ms_exc.registration, -2);
      return 0;
    }
    v205 = (int)Environment;
    a7 |= 0x400u;
  }
  qmemcpy(&v66, (const void *)v152, 0x44u);
  if ( a7 & 0x80000 )
  {
    if ( v66 != 72 )
    {
      BaseSetLastNTError(-1073741811);
      goto LABEL_239;
    }
    v52 = *(_DWORD *)(v152 + 68);
    v71 = v52;
    if ( v52 )
    {
      v53 = KernelBaseGetGlobalData();
      v38 = (*(int (__stdcall **)(int, _DWORD, int *, HANDLE *, int *, int *, signed int))(v53 + 40))(
              v52,
              0,
              &v159,
              &v174,
              &v250,
              &v228,
              15);
      if ( v38 < 0 )
        goto LABEL_248;
    }
  }
  if ( !(a7 & 0x800) )
  {
    v33 = v174;
    if ( !v174 )
      v33 = (HANDLE)-1;
    if ( IsProcessInJob(v33, 0, &Result) && Result )
      a7 = a7 & 0xFFFFEFFF | 0x800;
  }
  if ( v68 & 0x100 && v68 & 0x600 )
    v68 &= 0xFFFFFEFF;
  if ( lpFileName )
  {
    v129 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v84 = NtCurrentTeb();
    v34 = RtlAllocateHeap(v84->ProcessEnvironmentBlock->Reserved4[1], v129, 0x20Au);
    v160 = v34;
    if ( !v34 )
    {
LABEL_279:
      BaseSetLastNTError(-1073741801);
      goto LABEL_239;
    }
    v35 = GetFullPathNameW(lpFileName, 0x103u, (LPWSTR)v34, &FilePart);
    v36 = v35;
    v110 = v35;
    if ( v35 >= 0x104 )
      goto LABEL_377;
    if ( !v35 )
      goto LABEL_239;
    v37 = GetFileAttributesW((LPCWSTR)v34);
    v125 = v37;
    if ( v37 == -1 || !(v37 & 0x10) )
    {
LABEL_377:
      RtlSetLastWin32Error(267);
      goto LABEL_239;
    }
    if ( *((_WORD *)v34 + v36 - 1) != 92 )
    {
      *((_WORD *)v34 + v36) = 92;
      v110 = v36 + 1;
      *((_WORD *)v34 + v36 + 1) = 0;
    }
  }
  v38 = BaseFormatObjectAttributes((int)&v65, v113, 0, (int)&v120);
  if ( v38 < 0 )
    goto LABEL_248;
  v38 = BaseFormatObjectAttributes((int)&v64, v115, 0, (int)&v112);
  if ( v38 < 0 )
    goto LABEL_248;
  v122 = v228;
  while ( 1 )
  {
    v228 = v122;
    if ( Address )
    {
      v75 = NtCurrentTeb();
      RtlFreeHeap(v75->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      Address = 0;
    }
    if ( v199 )
    {
      v82 = NtCurrentTeb();
      RtlFreeHeap(v82->ProcessEnvironmentBlock->Reserved4[1], 0, v199);
      v199 = 0;
    }
    RtlFreeUnicodeString(&UnicodeString);
    if ( v197 )
    {
      v81 = NtCurrentTeb();
      RtlFreeHeap(v81->ProcessEnvironmentBlock->Reserved4[1], 0, v197);
      v197 = 0;
    }
    if ( Handle )
    {
      v216 = NtClose(Handle);
      Handle = 0;
    }
    v178 = 0;
    v166 = 0;
    if ( a6 )
      v217 |= 4u;
    else
      v217 &= 0xFFFFFFFB;
    memset(&v135, 0, 0x48u);
    v135 = 72;
    LOBYTE(v137) = (unsigned __int8)v137 | 2;
    if ( !v208 && !a6 && !(v68 & 0x100) && !v174 && !(a7 & 0x8000018) )
    {
      v148 = 3;
      v24 = (v147 & 0xFFFFFFFD | 1) & 0xFFFFFFE3;
      v147 = (v147 & 0xFFFFFFFD | 1) & 0xFFFFFFE3;
      v25 = (int)&v190->ProcessParameters->Reserved2[2];
      v79 = &v190->ProcessParameters->Reserved2[2];
      for ( i = 0; ; ++i )
      {
        v111 = i;
        if ( i >= 3 )
          break;
        if ( (*(_DWORD *)(v25 + 4 * i) & 0x10000003) == 3 )
        {
          v24 ^= ((unsigned __int8)v24 ^ (unsigned __int8)(v24 | 4 * (1 << i))) & 0x1C;
          v147 = v24;
        }
      }
      *(&v250 + 4 * v228 + 1) = 131082;
      *(&v250 + 4 * v228 + 2) = 8;
      *(&v250 + 4 * (v228 + 1)) = 0;
      *(&v250 + 4 * v228++ + 3) = (int)&v147;
    }
    if ( v183 )
    {
      *(&v250 + 4 * v228 + 1) = 131079;
      *(&v250 + 4 * v228 + 2) = 8;
      *(&v250 + 4 * (v228 + 1)) = 0;
      *(&v250 + 4 * v228++ + 3) = (int)&v108;
      v108 = 1;
      v109 = v183;
    }
    if ( !(a7 & 3) || v190->Reserved1[1] )
    {
      if ( !v222 )
        goto LABEL_58;
      v222 = 0;
      v55 = BYTE1(v137) & 0xFD | 1;
    }
    else
    {
      v55 = BYTE1(v137) & 0xFE | 2;
    }
    BYTE1(v137) = v55;
LABEL_58:
    LOBYTE(v137) = (unsigned __int8)v137 | 1;
    HIWORD(v137) = 0x2000;
    v138 = (void *)129;
    if ( !v67 )
      v67 = v190->ProcessParameters[1].Reserved2[9];
    v223 = 0;
    v211 = 0;
    v167 = 1;
    if ( !*(_DWORD *)&Str[1] )
    {
      Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
      v74 = NtCurrentTeb();
      Address = RtlAllocateHeap(v74->ProcessEnvironmentBlock->Reserved4[1], Flags, 0x208u);
      if ( !Address )
        goto LABEL_279;
      v173 = 0;
      v20 = pszSrc;
      *(_DWORD *)&Str[1] = pszSrc;
      v214 = pszSrc;
      v16 = pszSrc;
      v181 = pszSrc;
      if ( *pszSrc != 34 )
      {
        v213 = 1;
        goto LABEL_175;
      }
      v213 = 0;
      v16 = pszSrc + 1;
      v181 = pszSrc + 1;
      *(_DWORD *)&Str[1] = pszSrc + 1;
      while ( 1 )
      {
        if ( !*v16 )
          goto LABEL_165;
        if ( *v16 == 34 )
          break;
        ++v16;
        v181 = v16;
        v214 = v16;
      }
      v214 = v16;
      v167 = 0;
      while ( 1 )
      {
LABEL_165:
        v21 = *v214;
        v171 = *v214;
        *v214 = 0;
        if ( lpPath )
        {
          BaseReleaseProcessExePath(lpPath, v175);
          lpPath = 0;
        }
        lpPath = (LPCWSTR)BaseGetProcessExePath(*(_DWORD *)&Str[1], &v175);
        if ( !lpPath )
          goto LABEL_287;
        v22 = SearchPathW(lpPath, *(LPCWSTR *)&Str[1], L".exe", 0x104u, (LPWSTR)Address, 0);
        ReturnLength = v22;
        if ( v22 )
        {
          if ( v22 >= 0x104 )
          {
            BaseSetLastNTError(-1073741562);
          }
          else
          {
            v23 = GetFileAttributesW((LPCWSTR)Address);
            v125 = v23;
            if ( v23 != -1 )
            {
              if ( !(v23 & 0x10) )
              {
                *v214 = v21;
                *(_DWORD *)&Str[1] = Address;
                goto LABEL_63;
              }
              BaseSetLastNTError(-1073741638);
            }
          }
        }
        if ( !v173 )
          v173 = GetLastError();
        *v214 = v21;
        if ( !*v16 || !v213 )
        {
          RtlSetLastWin32Error(v173);
          goto LABEL_239;
        }
        ++v16;
        v181 = v16;
        v214 = v16;
        v223 = 1;
        v167 = 0;
        v20 = pszSrc;
LABEL_175:
        *(_DWORD *)&Str[1] = v20;
        while ( 1 )
        {
          v15 = *v16;
          if ( !*v16 )
            break;
          if ( v15 == 32 || v15 == 9 )
          {
            v214 = v16;
            goto LABEL_165;
          }
          ++v16;
          v181 = v16;
          v214 = v16;
        }
      }
    }
    if ( !pszSrc || !*pszSrc )
    {
      v211 = 1;
      pszSrc = *(STRSAFE_LPCWSTR *)&Str[1];
    }
LABEL_63:
    if ( v223 || v211 )
    {
      Size = 2 * wcslen(pszSrc) + 6;
      v92 = NtCurrentTeb();
      v17 = RtlAllocateHeap(v92->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
      v18 = (wchar_t *)v17;
      v197 = v17;
      if ( v17 )
      {
        StringCbCopyW((STRSAFE_LPWSTR)v17, Size, L"\"");
        v19 = v214;
        if ( v223 )
        {
          v171 = *v214;
          *v214 = 0;
        }
        StringCbCatW(v18, Size, pszSrc);
        StringCbCatW(v18, Size, L"\"");
        if ( v223 )
        {
          *v19 = v171;
          StringCbCatW(v18, Size, v19);
        }
        pszSrc = v18;
      }
    }
    if ( !RtlDosPathNameToNtPathName_U(*(PWSTR *)&Str[1], &UnicodeString, 0, 0) )
    {
      RtlSetLastWin32Error(3);
      goto LABEL_239;
    }
    v38 = RtlInitUnicodeStringEx(&DestinationString, *(PCWSTR *)&Str[1]);
    if ( v38 < 0 )
      goto LABEL_248;
    v39 = RtlDetermineDosPathNameType_U(*(PWSTR *)&Str[1]);
    v123 = v39;
    if ( v39 != 2 && v39 != 6 && v39 != 7 && v39 != 1 || BasepCheckForInvalidPathSeparator(*(wchar_t **)&Str[1]) )
    {
      v156 = 0;
      v157 = 0;
      v38 = RtlGetFullPathName_UstrEx(&DestinationString, 0, &v156, 0, 0, 0, &v123, 0);
      if ( v38 < 0 )
        goto LABEL_248;
      DestinationString = *(UNICODE_STRING *)&v156;
      v199 = v157;
      v157 = 0;
    }
    v40 = BasepCreateProcessParameters(
            *(int *)&Str[1],
            (NTSTATUS)DestinationString.Buffer,
            (int)v160,
            (int)pszSrc,
            v205,
            (int)&v66,
            a7,
            a6);
    v41 = v40;
    v91 = v40;
    if ( !v40 )
      goto LABEL_239;
    v253 = UnicodeString.Buffer;
    v252 = UnicodeString.Length;
    v250 = 16 * v228 + 4;
    v42 = NtCreateUserProcess(
            &ProcessHandle,
            &ThreadHandle,
            0x2000000,
            0x2000000,
            v120,
            v112,
            v217,
            1,
            v40,
            &v135,
            &v250);
    v200 = v42;
    RtlDestroyProcessParameters(v41);
    if ( v42 >= 0 )
      goto LABEL_71;
    ProcessHandle = 0;
    ThreadHandle = 0;
    if ( !v136 )
      goto LABEL_238;
    if ( v136 == 1 )
    {
      if ( !RtlIsDosDeviceName_U(*(PWSTR *)&Str[1]) )
      {
LABEL_238:
        BaseSetLastNTError(v42);
        goto LABEL_239;
      }
      RtlSetLastWin32Error(1200);
      goto LABEL_239;
    }
    if ( v136 == 2 )
    {
      Handle = v137;
      if ( v42 == -1073741790 )
      {
        RtlSetLastWin32Error(5);
        goto LABEL_239;
      }
      if ( v226 )
        goto LABEL_238;
      if ( v42 == -1073741521 )
      {
        if ( UnicodeString.Length >= 8u )
        {
          v12 = (unsigned int)UnicodeString.Length >> 1;
          v13 = &UnicodeString.Buffer[v12 - 4];
          v85 = &UnicodeString.Buffer[v12 - 4];
          if ( !__wcsnicmp(v13, L".bat", 4u) || !__wcsnicmp(v13, L".cmd", 4u) )
          {
            v220 = 1;
            return sub_77E13B12(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
          }
        }
      }
      else if ( v226 )
      {
        goto LABEL_238;
      }
      if ( !(a7 & 0x2000000) )
      {
        v212 = 1;
        if ( v42 != -1073741541 )
        {
          if ( v42 == -1073741521 )
          {
            if ( !BaseIsDosApplication((int)&UnicodeString, -1073741521) )
              goto LABEL_259;
          }
          else if ( v42 <= -1073741521 || v42 > -1073741519 && v42 != -1073741209 )
          {
LABEL_259:
            v212 = 0;
          }
        }
        if ( v212 )
        {
          v38 = BasepCheckWinSaferRestrictions(TokenHandle, *(int *)&Str[1], (int)Handle);
          v126 = v38;
          if ( v38 < 0 )
            goto LABEL_248;
        }
      }
      v229 = BasepProcessInvalidImage(
               v42,
               TokenHandle,
               DestinationString.Buffer,
               (int)&Str[1],
               (NTSTATUS)&pszSrc,
               (int)lpFileName,
               (int)&a7,
               (int)&a6,
               (int)&UnicodeString,
               (int)Str,
               (int)&v205,
               (ULONG)&v66,
               (int)&v231,
               (int)&v184,
               &v179,
               &AnsiString,
               &SourceString,
               (int)&v218,
               &v208,
               (int)&v183,
               (int)&v210);
      if ( !v229 )
        goto LABEL_121;
      v49 = v210;
      if ( v210 )
        goto LABEL_117;
      goto LABEL_127;
    }
    if ( v136 == 3 )
      goto LABEL_307;
    if ( v136 == 4 )
      break;
    if ( v136 == 5 )
    {
      v169 = v137;
      v56 = (int)v196;
      if ( !v196 )
      {
        v89 = NtCurrentTeb();
        v56 = (int)RtlAllocateHeap(v89->ProcessEnvironmentBlock->Reserved4[1], 0, 0x20Au);
        v196 = (PVOID)v56;
        if ( !v56 )
        {
          v216 = NtClose(v169);
LABEL_287:
          RtlSetLastWin32Error(8);
          goto LABEL_239;
        }
      }
      v57 = LdrQueryImageFileKeyOption(v169, L"Debugger", 1, v56, 520, &v131);
      v216 = NtClose(v169);
      if ( v57 >= 0 && v131 >= 2 && *(_WORD *)v56 )
      {
        *(_WORD *)(v56 + 520) = 0;
        if ( !BuildSubSysCommandLine(3, v56, 0, (int)pszSrc, &v179) )
          goto LABEL_239;
        pszSrc = v179.Buffer;
        *(_DWORD *)&Str[1] = 0;
      }
      else
      {
        v87 = NtCurrentTeb();
        RtlFreeHeap(v87->ProcessEnvironmentBlock->Reserved4[1], 0, v196);
        v196 = 0;
        v222 = 1;
      }
    }
    else
    {
LABEL_71:
      v43 = (int)v138;
      Handle = v138;
      v203 = v139;
      if ( v95 == 2 || v95 == 3 )
      {
        if ( !BasepCheckImageVersion(v97, v96) )
          goto LABEL_307;
        if ( (unsigned __int8)v137 & 8 )
        {
          v149 = v144;
          v150 = v145;
          v151 = v146;
        }
        v44 = BasepCheckWebBladeHashes(v43);
        v216 = v44;
        if ( v44 == -1073741790 )
        {
          RtlSetLastWin32Error(1277);
          goto LABEL_239;
        }
        if ( v44 < 0 )
        {
          RtlSetLastWin32Error(1278);
          goto LABEL_239;
        }
        v38 = BasepIsProcessAllowed(*(int *)&Str[1]);
        if ( v38 < 0 )
          goto LABEL_248;
        if ( !Str[0] && a7 & 0x800 )
          a7 &= 0xFFFFF7FF;
        if ( v208 )
        {
          v210 = ProcessHandle;
          if ( !BaseUpdateVDMEntry(1, (int)&v210, v184, v208) )
          {
            v210 = 0;
            goto LABEL_239;
          }
          v218 |= 2u;
        }
        v162 = v141;
        if ( Str[0] )
        {
          v116 = 2;
          NtWriteVirtualMemory(ProcessHandle, (PVOID)(v141 + 180), &v116, 4u, 0);
        }
        if ( v226
          || a7 & 0x2000000
          || (v38 = BasepCheckWinSaferRestrictions(TokenHandle, *(int *)&Str[1], (int)Handle), v126 = v38, v38 >= 0) )
        {
          memset(&v241, 0, 0x88u);
          switch ( v99 )
          {
            case 0x14Cu:
              ProcessInformation = 0;
              break;
            case 0x200u:
              ProcessInformation = 6;
              break;
            case 0x8664u:
              ProcessInformation = 9;
              break;
            default:
              DbgPrint("Kernel32: No mapping for ImageInformation.Machine == %04x\n", v99);
              ProcessInformation = 0xFFFF;
              break;
          }
          if ( !((unsigned __int8)v137 & 1) )
          {
            if ( !v226
              && !BasepQueryAppCompat(
                    v203,
                    (int)&v94,
                    ((unsigned int)(unsigned __int8)v137 >> 1) & 1,
                    ProcessInformation,
                    Handle,
                    UnicodeString.Buffer,
                    (void *)v205,
                    (int)&v182,
                    (int)&v172,
                    (int)&v187,
                    (int)&v161,
                    (int)v176,
                    (int)&v164,
                    v186,
                    (int)&v178,
                    (int)&v166,
                    (int)&v168) )
              goto LABEL_239;
            v153 = v140;
            v242 = v140;
            v38 = (int)BasepConstructSxsCreateProcessMessage(
                         (int)&UnicodeString,
                         (int)&DestinationString,
                         Handle,
                         (int)ProcessHandle,
                         (int)v203,
                         v178,
                         v166,
                         ((unsigned int)(unsigned __int8)v137 >> 2) & 1,
                         v176[0],
                         (int)v187,
                         v161,
                         (v98 >> 9) & 1,
                         v162,
                         v149,
                         v150,
                         v151,
                         (int)&v153,
                         &v241,
                         (PHANDLE)&Dst);
            if ( v38 < 0 )
              goto LABEL_248;
          }
          v248 = v143;
          v246 = v141;
          v247 = v142;
          v233 = ProcessHandle;
          v234 = ThreadHandle;
          v235 = v154;
          v236 = v155;
          v249 = ProcessInformation;
          v237 = a7 & 0xFFFFFFFC;
          if ( v95 == 2 || Str[0] )
          {
            v233 = (HANDLE)((unsigned int)ProcessHandle | 2);
            v27 = GetModuleHandleA(0);
            v28 = RtlImageNtHeader(v27);
            v70 = v28;
            if ( v28 )
            {
              if ( v28->OptionalHeader.Subsystem == 2 )
                v233 = (HANDLE)((unsigned int)v233 | 1);
            }
          }
          if ( TokenHandle )
          {
            v38 = NtQueryInformationToken(TokenHandle, TokenSessionId, &TokenInformation, 4u, &ReturnLength);
            if ( v38 < 0 )
              goto LABEL_248;
            v80 = NtCurrentTeb();
            if ( TokenInformation != v80->ProcessEnvironmentBlock->SessionId )
              v234 = (HANDLE)((unsigned int)v234 | 1);
          }
          if ( v68 & 0x40 )
            v233 = (HANDLE)((unsigned int)v233 | 1);
          if ( v68 & 0x80 )
            v233 = (HANDLE)((unsigned int)v233 & 0xFFFFFFFE);
          v238 = v208;
          if ( v208 )
          {
            v63 = (signed int)(v184 ? 0 : v190->ProcessParameters->Reserved2[0]);
            v240 = v63;
            v239 = v184;
          }
          else if ( v183 )
          {
            v238 = 128;
          }
          if ( (unsigned __int8)v137 & 1 )
            v234 = (HANDLE)((unsigned int)v234 | 2);
          v38 = BasepCsrCaptureSxsMessage((int)&v241, (int)&v191);
          v200 = v38;
          if ( v38 >= 0 )
          {
            CsrClientCallServer(&v231, v191, 0x10000, 184);
            if ( NtStatus < 0 )
            {
              BaseSetLastNTError(NtStatus);
              ExitStatus = NtStatus;
              goto LABEL_239;
            }
            if ( (unsigned __int8)v137 & 1
              || (v153 = v242, v242 == v140)
              || (v38 = BasepUpdateProcessParametersFlags(ProcessHandle, v242, (int)&v135), v200 = v38, v38 >= 0) )
            {
              if ( !v220 && !(v159 & 2) )
              {
                *(_DWORD *)v188 |= 1u;
                v45 = BaseCheckElevation(
                        ProcessHandle,
                        (LONG_PTR)DestinationString.Buffer,
                        (int)v188,
                        v164,
                        v165[0],
                        (int)&v243,
                        (int)&v245,
                        v186[0],
                        (int)TokenHandle,
                        0,
                        0);
                v46 = v45;
                v200 = v45;
                if ( (v45 & 0x80000000) != 0 )
                {
                  if ( v45 == -1073740756 && !(v159 & 1) )
                    BaseWriteErrorElevationRequiredEvent();
                  BaseSetLastNTError(v46);
                  ExitStatus = v46;
                  goto LABEL_239;
                }
              }
              if ( !((unsigned __int8)v137 & 1) )
              {
                BasepGetAppCompatData(
                  (LONG_PTR)DestinationString.Buffer,
                  (int)v188,
                  v164,
                  *(int *)v165,
                  (int)&v243,
                  (int)&v245,
                  v186[0],
                  (int)&v94,
                  ((unsigned int)(unsigned __int8)v137 >> 1) & 1,
                  ProcessInformation,
                  (int)&v182,
                  (int)&v172,
                  (int)&Buffer,
                  (int)&BufferLength);
                if ( Buffer )
                {
                  BaseAddress = 0;
                  Size = BufferLength;
                  v38 = NtAllocateVirtualMemory(ProcessHandle, &BaseAddress, 0, &Size, 0x1000u, 4u);
                  if ( v38 < 0 )
                    goto LABEL_248;
                  v38 = NtWriteVirtualMemory(ProcessHandle, BaseAddress, Buffer, BufferLength, 0);
                  if ( v38 < 0 )
                    goto LABEL_248;
                  v38 = NtWriteVirtualMemory(ProcessHandle, (PVOID)(v162 + 488), &BaseAddress, 4u, 0);
                  v200 = v38;
                  if ( v38 < 0 )
                    goto LABEL_248;
                }
                v100 = *(_DWORD *)&Str[1];
                v102 = v162;
                v101 = ProcessHandle;
                v103 = Buffer;
                v104 = v97;
                v105 = v96;
                v107 = (int)&v244;
                v106 = (v168 >> 6) & 1;
                BasepPrepareSwitchContext((int)&v100);
              }
              if ( v220
                || (unsigned __int8)v137 & 1
                || (v38 = BaseElevationPostProcessing(v188[0], ProcessInformation, ProcessHandle), v200 = v38, v38 >= 0) )
              {
                if ( !(a7 & 4) )
                {
                  v47 = NtResumeThread(ThreadHandle, 0);
                  v48 = v47;
                  v200 = v47;
                  if ( v47 < 0 )
                  {
                    BaseSetLastNTError(v47);
                    ExitStatus = v48;
                    goto LABEL_239;
                  }
                }
                v49 = v210;
LABEL_117:
                v229 = 1;
                if ( v218 )
                  v218 |= 8u;
                ms_exc.registration.TryLevel = 2;
                v134 = 1;
                v50 = v194;
                if ( v49 )
                {
                  if ( v208 == 32 )
                  {
                    *(_DWORD *)v194 = (unsigned int)v49 | 2;
                    if ( v218 & 4 )
                    {
                      v154 = 0;
                      v155 = 0;
                    }
                  }
                  else
                  {
                    *(_DWORD *)v194 = (unsigned int)v49 | 1;
                  }
                  if ( ProcessHandle )
                    v216 = NtClose(ProcessHandle);
                }
                else
                {
                  *(_DWORD *)v194 = ProcessHandle;
                }
                *(_DWORD *)(v50 + 4) = ThreadHandle;
                *(_DWORD *)(v50 + 8) = v154;
                *(_DWORD *)(v50 + 12) = v155;
                ProcessHandle = 0;
                ThreadHandle = 0;
                ms_exc.registration.TryLevel = 1;
                v134 = 0;
                if ( v134 )
                {
                  NtClose(ProcessHandle);
                  v216 = NtClose(ThreadHandle);
                  ProcessHandle = 0;
                  ThreadHandle = 0;
                  if ( v218 )
                    v218 &= 0xFFFFFFF7;
                }
                ms_exc.registration.TryLevel = 0;
                goto LABEL_121;
              }
              ExitStatus = v38;
            }
          }
        }
LABEL_248:
        BaseSetLastNTError(v38);
        goto LABEL_239;
      }
      if ( v95 != 7 )
      {
        RtlSetLastWin32Error(129);
        goto LABEL_239;
      }
      v118 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
      v76 = NtCurrentTeb();
      v58 = (WCHAR *)RtlAllocateHeap(v76->ProcessEnvironmentBlock->Reserved4[1], v118, 0x20Eu);
      lpBuffer = v58;
      if ( !v58 )
        goto LABEL_279;
      v189 = 520;
      v93 = RegGetValueW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Posix", L"ExePath", 2, 0, v58, (size_t)&v189);
      if ( v93 )
      {
        v59 = GetEnvironmentVariableW(L"SystemRoot", v58, 0xF1u);
        v189 = v59;
        if ( v59 >= 0xF1 || !v59 )
          goto LABEL_378;
        v128 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        v69 = NtCurrentTeb();
        v60 = RtlAllocateHeap(v69->ProcessEnvironmentBlock->Reserved4[1], v128, 0x410u);
        v61 = (const WCHAR *)v60;
        v177 = v60;
        if ( !v60 )
          goto LABEL_279;
        v58 = lpBuffer;
        RtlStringCchPrintfW((wchar_t *)v60, 0x208u, L"%s;%s\\system32", lpBuffer, lpBuffer);
        v62 = SearchPathW(v61, L"posix.exe", 0, 0x104u, v58, 0);
        v189 = v62;
        if ( v62 >= 0x104 || !v62 )
        {
LABEL_378:
          BaseSetLastNTError(-1073741565);
          goto LABEL_239;
        }
      }
      RtlStringCchCatW(v58, 0x107u, L" /P");
      if ( !BuildSubSysCommandLine(2, (int)v58, *(int *)&Str[1], (int)pszSrc, &v179) )
        goto LABEL_239;
      pszSrc = v179.Buffer;
      *(_DWORD *)&Str[1] = 0;
      if ( v195 )
        NtRemoveProcessDebug(ProcessHandle, v195);
      NtTerminateProcess(ProcessHandle, ExitStatus);
      NtWaitForSingleObject(ProcessHandle, 0, 0);
      NtClose(ProcessHandle);
      ProcessHandle = 0;
      NtClose(ThreadHandle);
      ThreadHandle = 0;
      NtClose(v203);
      v203 = 0;
      v216 = NtClose(Handle);
      Handle = 0;
LABEL_127:
      v226 = 1;
    }
  }
  MessageBoxResult = 6;
  Arguments = (ULONG)&UnicodeString;
  NtRaiseHardError(1073741859, 1u, 1u, &Arguments, 1u, &MessageBoxResult);
  if ( v190->Reserved9[32] > (PVOID)3 )
  {
    RtlSetLastWin32Error(216);
    goto LABEL_239;
  }
LABEL_307:
  RtlSetLastWin32Error(193);
LABEL_239:
  v229 = 0;
LABEL_121:
  ms_exc.registration.TryLevel = -2;
  if ( v196 )
  {
    v78 = NtCurrentTeb();
    RtlFreeHeap(v78->ProcessEnvironmentBlock->Reserved4[1], 0, v196);
  }
  if ( v199 )
  {
    v90 = NtCurrentTeb();
    RtlFreeHeap(v90->ProcessEnvironmentBlock->Reserved4[1], 0, v199);
  }
  RtlFreeUnicodeString(&UnicodeString);
  if ( !v208 )
    BasepReleaseSxsCreateProcessUtilityStruct((int)&Dst);
  if ( Environment )
  {
    RtlDestroyEnvironment(Environment);
    v216 = v51;
  }
  if ( v197 )
  {
    v73 = NtCurrentTeb();
    RtlFreeHeap(v73->ProcessEnvironmentBlock->Reserved4[1], 0, v197);
  }
  v88 = NtCurrentTeb();
  RtlFreeHeap(v88->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  v77 = NtCurrentTeb();
  RtlFreeHeap(v77->ProcessEnvironmentBlock->Reserved4[1], 0, v160);
  if ( lpBuffer )
  {
    v86 = NtCurrentTeb();
    RtlFreeHeap(v86->ProcessEnvironmentBlock->Reserved4[1], 0, lpBuffer);
  }
  if ( v177 )
  {
    v72 = NtCurrentTeb();
    RtlFreeHeap(v72->ProcessEnvironmentBlock->Reserved4[1], 0, v177);
  }
  if ( Handle )
    v216 = NtClose(Handle);
  if ( v203 )
    v216 = NtClose(v203);
  if ( ThreadHandle )
  {
    if ( v195 )
      NtRemoveProcessDebug(ProcessHandle, v195);
    NtTerminateProcess(ProcessHandle, ExitStatus);
    NtWaitForSingleObject(ProcessHandle, 0, 0);
    v216 = NtClose(ThreadHandle);
  }
  if ( ProcessHandle )
    v216 = NtClose(ProcessHandle);
  BasepFreeAppCompatData(Buffer, v187, v182);
  RtlFreeUnicodeString(&v179);
  if ( AnsiString.Buffer || SourceString.Buffer )
    BaseDestroyVDMEnvironment(&AnsiString, (int)&SourceString);
  if ( v218 )
  {
    if ( !(v218 & 8) )
    {
      BaseUpdateVDMEntry(0, (int)&v184, v218, v208);
      if ( v210 )
        v216 = NtClose(v210);
    }
  }
  if ( lpPath )
    BaseReleaseProcessExePath(lpPath, v175);
  if ( v191 )
  {
    CsrFreeCaptureBuffer(v191);
    v191 = 0;
  }
  return v229;
}
// 77E30852: too many cbuild loops
// 77DE11E4: using guessed type int __stdcall RtlCreateEnvironmentEx(_DWORD, _DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77DE165C: using guessed type int __stdcall LdrQueryImageFileKeyOption(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1660: using guessed type int __stdcall NtCreateUserProcess(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1664: using guessed type int __stdcall RtlGetFullPathName_UstrEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E13B12: using guessed type int __stdcall sub_77E13B12(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E172E2: using guessed type int __stdcall BaseGetProcessExePath(_DWORD, _DWORD);
// 77E172FA: using guessed type int __stdcall BaseReleaseProcessExePath(_DWORD, _DWORD);
// 77E4A16C: using guessed type _DWORD __cdecl _local_unwind4(_DWORD, _DWORD, _DWORD);
// 77E5DE80: using guessed type wchar_t aDebugger[9];
// 77E956A4: using guessed type int __stdcall NtRemoveProcessDebug(_DWORD, _DWORD);
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E31624) --------------------------------------------------------
PRTL_USER_PROCESS_PARAMETERS __stdcall BasepCreateProcessParameters(int a1, NTSTATUS NtStatus, int a3, int a4, int a5, int a6, int a7, int a8)
{
  PRTL_USER_PROCESS_PARAMETERS v8; // eax@37
  PRTL_USER_PROCESS_PARAMETERS v9; // eax@39
  PPEB v10; // ebx@1
  NTSTATUS v11; // eax@14
  PRTL_USER_PROCESS_PARAMETERS result; // eax@31
  UNICODE_STRING v13; // [sp+10h] [bp-68h]@2
  UNICODE_STRING v14; // [sp+18h] [bp-60h]@3
  UNICODE_STRING v15; // [sp+20h] [bp-58h]@4
  UNICODE_STRING v16; // [sp+28h] [bp-50h]@7
  UNICODE_STRING v17; // [sp+30h] [bp-48h]@14
  UNICODE_STRING v18; // [sp+38h] [bp-40h]@10
  UNICODE_STRING DestinationString; // [sp+40h] [bp-38h]@12
  __int16 v20; // [sp+48h] [bp-30h]@13
  __int16 v21; // [sp+4Ah] [bp-2Eh]@13
  int v22; // [sp+4Ch] [bp-2Ch]@13
  int v23; // [sp+50h] [bp-28h]@1
  PCWSTR SourceString; // [sp+58h] [bp-20h]@1
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters; // [sp+5Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+60h] [bp-18h]@17
  int NtStatusa; // [sp+84h] [bp+Ch]@2
  UNICODE_STRING *v28; // [sp+88h] [bp+10h]@8

  ProcessParameters = 0;
  v10 = NtCurrentTeb()->ProcessEnvironmentBlock;
  SourceString = (PCWSTR)BaseGetProcessDllPath(NtStatus, a5, &v23);
  if ( !SourceString )
  {
    NtStatusa = -1073741801;
    goto LABEL_28;
  }
  NtStatusa = RtlInitUnicodeStringEx(&v13, (PCWSTR)NtStatus);
  if ( NtStatusa >= 0 )
  {
    NtStatusa = RtlInitUnicodeStringEx(&v14, SourceString);
    if ( NtStatusa >= 0 )
      NtStatusa = RtlInitUnicodeStringEx(&v15, (PCWSTR)a4);
  }
  if ( NtStatusa >= 0 )
  {
    if ( a3 )
    {
      NtStatusa = RtlInitUnicodeStringEx(&v16, (PCWSTR)a3);
      if ( NtStatusa < 0 )
        goto LABEL_28;
      v28 = &v16;
    }
    else
    {
      v28 = 0;
    }
    if ( *(_DWORD *)(a6 + 8) )
    {
      NtStatusa = RtlInitUnicodeStringEx(&v18, *(PCWSTR *)(a6 + 8));
      if ( NtStatusa < 0 )
        goto LABEL_28;
    }
    else
    {
      RtlInitUnicodeStringEx(&v18, &Src);
    }
    if ( *(_DWORD *)(a6 + 4) )
    {
      NtStatusa = RtlInitUnicodeStringEx(&DestinationString, *(PCWSTR *)(a6 + 4));
      if ( NtStatusa < 0 )
        goto LABEL_28;
    }
    else
    {
      RtlInitUnicodeStringEx(&DestinationString, &Src);
    }
    v22 = *(_DWORD *)(a6 + 52);
    v20 = *(_WORD *)(a6 + 50);
    v21 = v20;
    if ( *(_DWORD *)(a6 + 12) )
      v11 = RtlInitUnicodeStringEx(&v17, *(PCWSTR *)(a6 + 12));
    else
      v11 = RtlInitUnicodeStringEx(&v17, (PCWSTR)a1);
    NtStatusa = v11;
    if ( v11 >= 0 )
    {
      NtStatusa = RtlCreateProcessParametersEx(
                    &ProcessParameters,
                    &v13,
                    &v14,
                    v28,
                    &v15,
                    a5,
                    &v17,
                    &v18,
                    &DestinationString,
                    &v20,
                    1);
      if ( NtStatusa >= 0 )
      {
        ms_exc.registration.TryLevel = 0;
        *(_DWORD *)&ProcessParameters[1].Reserved1[4] = *(_DWORD *)(a6 + 16);
        *(_DWORD *)&ProcessParameters[1].Reserved1[8] = *(_DWORD *)(a6 + 20);
        *(_DWORD *)&ProcessParameters[1].Reserved1[12] = *(_DWORD *)(a6 + 24);
        ProcessParameters[1].Reserved2[0] = *(PVOID *)(a6 + 28);
        ProcessParameters[1].Reserved2[1] = *(PVOID *)(a6 + 32);
        ProcessParameters[1].Reserved2[2] = *(PVOID *)(a6 + 36);
        ProcessParameters[1].Reserved2[3] = *(PVOID *)(a6 + 40);
        ProcessParameters[1].Reserved2[4] = *(PVOID *)(a6 + 44);
        ProcessParameters[1].Reserved2[5] = (PVOID)*(_WORD *)(a6 + 48);
        if ( *(_DWORD *)(a6 + 44) & 0x700 )
        {
          ProcessParameters->Reserved2[2] = *(PVOID *)(a6 + 56);
          ProcessParameters->Reserved2[3] = *(PVOID *)(a6 + 60);
          ProcessParameters->Reserved2[4] = *(PVOID *)(a6 + 64);
        }
        if ( a7 & 8 )
        {
          ProcessParameters->Reserved2[0] = (PVOID)-1;
        }
        else if ( a7 & 0x10 )
        {
          ProcessParameters->Reserved2[0] = (PVOID)-2;
        }
        else if ( a7 & 0x8000000 )
        {
          ProcessParameters->Reserved2[0] = (PVOID)-3;
        }
        else
        {
          ProcessParameters->Reserved2[0] = v10->ProcessParameters->Reserved2[0];
          if ( !(*(_DWORD *)(a6 + 44) & 0x700) )
          {
            if ( a8 && (v8 = v10->ProcessParameters, !((unsigned int)v8[1].Reserved2[4] & 0x200))
              || (v8 = v10->ProcessParameters, ((unsigned int)v8->Reserved2[2] & 0x10000003) == 3) )
              ProcessParameters->Reserved2[2] = v8->Reserved2[2];
            if ( a8 && (v9 = v10->ProcessParameters, !((unsigned int)v9[1].Reserved2[4] & 0x400))
              || (v9 = v10->ProcessParameters, ((unsigned int)v9->Reserved2[3] & 0x10000003) == 3) )
              ProcessParameters->Reserved2[3] = v9->Reserved2[3];
            if ( a8 || ((unsigned int)v10->ProcessParameters->Reserved2[4] & 0x10000003) == 3 )
              ProcessParameters->Reserved2[4] = v10->ProcessParameters->Reserved2[4];
          }
        }
        if ( a7 & 0x200 && !(a7 & 0x10) )
          ProcessParameters->Reserved2[1] = (PVOID)((unsigned int)ProcessParameters->Reserved2[1] | 1);
        *(_DWORD *)&ProcessParameters->Reserved1[8] |= *(_DWORD *)&v10->ProcessParameters->Reserved1[8] & 0x100;
        if ( a7 & 0x10000000 )
          *(_DWORD *)&ProcessParameters->Reserved1[8] |= 2u;
        if ( a7 & 0x20000000 )
          *(_DWORD *)&ProcessParameters->Reserved1[8] |= 4u;
        if ( a7 & 0x40000000 )
          *(_DWORD *)&ProcessParameters->Reserved1[8] |= 8u;
        ms_exc.registration.TryLevel = -2;
      }
    }
  }
LABEL_28:
  if ( SourceString )
    BaseReleaseProcessDllPath(SourceString, v23);
  if ( NtStatusa < 0 )
  {
    if ( ProcessParameters )
      RtlDestroyProcessParameters(ProcessParameters);
    BaseSetLastNTError(NtStatusa);
    result = 0;
  }
  else
  {
    result = ProcessParameters;
  }
  return result;
}
// 77DE164C: using guessed type int __stdcall RtlCreateProcessParametersEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E31619: using guessed type int __stdcall BaseGetProcessDllPath(_DWORD, _DWORD, _DWORD);
// 77E31899: using guessed type int __stdcall BaseReleaseProcessDllPath(_DWORD, _DWORD);

//----- (77E318A4) --------------------------------------------------------
int __stdcall BasepCheckForInvalidPathSeparator(wchar_t *Str)
{
  wchar_t *i; // eax@1
  int v2; // eax@4
  __int16 v3; // cx@4

  for ( i = _wcspbrk(Str, L"\\/"); ; i = _wcspbrk((const wchar_t *)(v2 + 2), L"\\/") )
  {
    if ( !i )
      return 0;
    if ( *i == 47 )
      return 1;
    v2 = (int)(i + 1);
    v3 = *(_WORD *)v2;
    if ( !*(_WORD *)v2 )
      return 0;
    if ( v3 == 92 || v3 == 47 )
      break;
  }
  return 1;
}

//----- (77E31909) --------------------------------------------------------
int __stdcall BasepIsRemovableMedia(HANDLE FileHandle, int a2)
{
  int result; // eax@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-10h]@1
  unsigned int VolumeInformation; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@2

  if ( NtQueryVolumeInformationFile(FileHandle, &IoStatusBlock, &VolumeInformation, 8u, FileFsDeviceInformation) < 0 )
    goto LABEL_14;
  result = v5 & 1;
  if ( !a2 )
    result |= v5 & 0x10;
  if ( !result
    && VolumeInformation >= 2
    && (VolumeInformation <= 3 || (VolumeInformation == 18 || VolumeInformation == 20) && !a2) )
LABEL_14:
    result = 1;
  return result;
}

//----- (77E3196C) --------------------------------------------------------
NTSTATUS __stdcall BasepSxsCloseHandles(int a1)
{
  NTSTATUS result; // eax@3

  if ( *(_DWORD *)a1 )
    NtClose(*(HANDLE *)a1);
  if ( *(_DWORD *)(a1 + 8) )
    NtClose(*(HANDLE *)(a1 + 8));
  result = *(_DWORD *)(a1 + 20) | *(_DWORD *)(a1 + 16);
  if ( *(_QWORD *)(a1 + 16) )
    result = NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, *(PVOID *)(a1 + 16));
  return result;
}

//----- (77E319A0) --------------------------------------------------------
NTSTATUS __stdcall BasepGetPreferExternalManifestConfig(int a1)
{
  NTSTATUS v1; // ebx@1
  signed int v2; // esi@1
  NTSTATUS v3; // eax@2
  NTSTATUS v4; // eax@3
  bool v5; // zf@4
  LONG v7; // eax@17
  ULONG ResultLength; // [sp+Ch] [bp-40h]@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-3Ch]@2
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-24h]@2
  HANDLE KeyHandle; // [sp+30h] [bp-1Ch]@1
  char KeyValueInformation; // [sp+34h] [bp-18h]@3
  int v13; // [sp+38h] [bp-14h]@13
  int v14; // [sp+3Ch] [bp-10h]@14
  LONG Exchange; // [sp+40h] [bp-Ch]@15

  v1 = 0;
  *(_DWORD *)a1 = 0;
  v2 = dword_77EA6C80;
  KeyHandle = 0;
  if ( dword_77EA6C80 == -1 )
  {
    RtlInitUnicodeString(
      &DestinationString,
      L"\\Registry\\MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\SideBySide");
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = &DestinationString;
    v3 = NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
    v1 = v3;
    if ( v3 < 0 )
    {
      if ( v3 == -1073741772 )
      {
LABEL_6:
        v1 = 0;
        goto LABEL_7;
      }
      v5 = v3 == -1073741766;
LABEL_5:
      if ( !v5 )
        goto LABEL_7;
      goto LABEL_6;
    }
    RtlInitUnicodeString(&DestinationString, L"PreferExternalManifest");
    v4 = NtQueryValueKey(
           KeyHandle,
           &DestinationString,
           KeyValuePartialInformation,
           &KeyValueInformation,
           0x14u,
           &ResultLength);
    v1 = v4;
    if ( v4 < 0 )
    {
      v5 = v4 == -1073741772;
      goto LABEL_5;
    }
    if ( v13 != 4 || v14 != 4 || (v2 = Exchange, Exchange == -1) )
      v2 = 1;
    v7 = InterlockedCompareExchange(&dword_77EA6C80, v2, -1);
    if ( v7 != -1 )
      v2 = v7;
  }
  *(_DWORD *)a1 = v2;
LABEL_7:
  if ( KeyHandle )
    NtClose(KeyHandle);
  return v1;
}

//----- (77E31B43) --------------------------------------------------------
signed int __stdcall BasepCheckWinSaferRestrictions(void *a1, int a2, int a3)
{
  int v3; // edi@1
  NTSTATUS v4; // esi@8
  signed int result; // eax@24
  NTSTATUS v6; // edi@63
  NTSTATUS v7; // edi@69
  int v8; // eax@76
  DWORD v9; // eax@89
  ULONG v10; // [sp+Ch] [bp-284h]@69
  ULONG ReturnLength; // [sp+10h] [bp-280h]@26
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+14h] [bp-27Ch]@79
  UNICODE_STRING Source; // [sp+2Ch] [bp-264h]@75
  int v14; // [sp+34h] [bp-25Ch]@42
  int v15; // [sp+38h] [bp-258h]@65
  ULONG ResultLength; // [sp+3Ch] [bp-254h]@32
  HANDLE KeyHandle; // [sp+40h] [bp-250h]@30
  LSA_UNICODE_STRING Destination; // [sp+44h] [bp-24Ch]@76
  int v19; // [sp+4Ch] [bp-244h]@1
  int v20; // [sp+50h] [bp-240h]@1
  HANDLE v21; // [sp+54h] [bp-23Ch]@15
  HANDLE v22; // [sp+58h] [bp-238h]@18
  int v23; // [sp+5Ch] [bp-234h]@17
  HANDLE Handle; // [sp+60h] [bp-230h]@31
  PVOID ModuleImageBase; // [sp+64h] [bp-22Ch]@42
  HANDLE TokenHandle; // [sp+68h] [bp-228h]@1
  HANDLE ThreadInformation; // [sp+6Ch] [bp-224h]@1
  char v28; // [sp+73h] [bp-21Dh]@31
  int Dst; // [sp+74h] [bp-21Ch]@17
  int v30; // [sp+78h] [bp-218h]@17
  int v31; // [sp+7Ch] [bp-214h]@17
  int v32; // [sp+80h] [bp-210h]@17
  int v33; // [sp+E0h] [bp-1B0h]@17
  void *TokenInformation; // [sp+E4h] [bp-1ACh]@26
  char v35; // [sp+16Ch] [bp-124h]@69
  int v36; // [sp+170h] [bp-120h]@70
  int v37; // [sp+174h] [bp-11Ch]@71
  unsigned int v38; // [sp+178h] [bp-118h]@72
  char Sid; // [sp+1BCh] [bp-D4h]@27
  char KeyValueInformation; // [sp+23Ch] [bp-54h]@32
  int v41; // [sp+240h] [bp-50h]@33
  int v42; // [sp+244h] [bp-4Ch]@34
  unsigned int v43; // [sp+248h] [bp-48h]@35

  v3 = a2;
  v19 = a2;
  v20 = a3;
  TokenHandle = 0;
  ThreadInformation = 0;
  if ( a2 && *(_WORD *)a2 )
  {
    if ( dword_77EA6554 != -2 )
    {
      RtlAcquireSRWLockExclusive(&gsrwlAppCert);
      if ( dword_77EA6554 )
      {
        if ( dword_77EA6554 == -2 )
        {
LABEL_59:
          v4 = 0;
          goto LABEL_24;
        }
        if ( a1 )
        {
          v21 = a1;
LABEL_16:
          if ( dword_77EA6554 != -1 )
            goto LABEL_17;
          if ( NtQueryInformationToken(v21, TokenUser, &TokenInformation, 0x88u, &ReturnLength) < 0
            || (RtlInitializeSid(&Sid, &IdentifierAuthority, 1),
                *RtlSubAuthoritySid(&Sid, 0) = 18,
                !RtlEqualSid(TokenInformation, &Sid))
            && (*RtlSubAuthoritySid(&Sid, 0) = 19, !RtlEqualSid(TokenInformation, &Sid))
            && (*RtlSubAuthoritySid(&Sid, 0) = 20, !RtlEqualSid(TokenInformation, &Sid)) )
          {
            if ( NtOpenKey(&KeyHandle, 3u, &stru_77E31FC0) < 0
              || (v7 = NtQueryValueKey(KeyHandle, &stru_77E5190C, KeyValuePartialInformation, &v35, 0x50u, &v10),
                  NtClose(KeyHandle),
                  v7 < 0)
              || v36 != 4
              || v37 != 4
              || v38 <= 0 )
            {
              v28 = 0;
              if ( NtOpenKey(&Handle, 1u, &stru_77E31FE0) >= 0 )
              {
                if ( NtQueryValueKey(
                       Handle,
                       &stru_77E31FD8,
                       KeyValuePartialInformation,
                       &KeyValueInformation,
                       0x50u,
                       &ResultLength) >= 0
                  && v41 == 4
                  && v42 == 4
                  && v43 > 0 )
                  v28 = 1;
                if ( NtQueryValueKey(
                       Handle,
                       &stru_77E32020,
                       KeyValuePartialInformation,
                       &KeyValueInformation,
                       0x50u,
                       &ResultLength) >= 0
                  && v41 == 4
                  && v42 == 4
                  && v43 > 0 )
                  dword_77EA6C88 = 8;
                NtClose(Handle);
                if ( v28 )
                  goto LABEL_96;
              }
              if ( RtlFormatCurrentUserKeyPath(&Source) >= 0 )
              {
                Destination.Length = 0;
                Destination.MaximumLength = Source.Length + 120;
                v8 = KernelBaseGetGlobalData();
                Destination.Buffer = (PWCH)RtlAllocateHeap(
                                             NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                             *(_DWORD *)(v8 + 44),
                                             Destination.MaximumLength);
                if ( Destination.Buffer )
                {
                  if ( RtlAppendUnicodeStringToString(&Destination, &Source) >= 0
                    && RtlAppendUnicodeToString(
                         &Destination,
                         L"\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers") >= 0 )
                  {
                    ObjectAttributes.ObjectName = &Destination;
                    ObjectAttributes.Length = 24;
                    ObjectAttributes.RootDirectory = 0;
                    ObjectAttributes.Attributes = 64;
                    ObjectAttributes.SecurityDescriptor = 0;
                    ObjectAttributes.SecurityQualityOfService = 0;
                    if ( NtOpenKey(&Handle, 1u, &ObjectAttributes) >= 0
                      && NtQueryValueKey(
                           Handle,
                           &stru_77E31FD8,
                           KeyValuePartialInformation,
                           &KeyValueInformation,
                           0x50u,
                           &ResultLength) >= 0
                      && v41 == 4
                      && v42 == 4
                      && v43 > 0 )
                      v28 = 1;
                  }
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Destination.Buffer);
                }
                RtlFreeUnicodeString(&Source);
                if ( v28 )
                {
LABEL_96:
                  v14 = 4096;
                  if ( LdrLoadDll(0, &v14, &dword_77E31FF8, &ModuleImageBase) < 0 )
                  {
                    v4 = -1073741511;
                    dword_77EA6554 = 0;
                  }
                  else
                  {
                    if ( LdrGetProcedureAddress(ModuleImageBase, &ProcedureName, 0, &ProcedureAddress) >= 0
                      && ProcedureAddress
                      && LdrGetProcedureAddress(ModuleImageBase, &stru_77E32010, 0, &dword_77EA6598) >= 0
                      && dword_77EA6598
                      && LdrGetProcedureAddress(ModuleImageBase, &stru_77E32008, 0, &dword_77EA6594) >= 0
                      && dword_77EA6594
                      && LdrGetProcedureAddress(ModuleImageBase, &stru_77E32018, 0, &dword_77EA6590) >= 0
                      && dword_77EA6590 )
                    {
                      v3 = v19;
                      dword_77EA6554 = (int)ModuleImageBase;
LABEL_17:
                      memset(&Dst, 0, 0x70u);
                      v30 = dword_77EA6C88 | 5;
                      v32 = v20;
                      Dst = 112;
                      v31 = v3;
                      v33 = 2;
                      v4 = -1073741790;
                      if ( ((int (__stdcall *)(signed int, int *, int *, _DWORD))ProcedureAddress)(
                             1,
                             &Dst,
                             &v23,
                             L"IGNORESRPV2") )
                      {
                        v22 = 0;
                        if ( ((int (__stdcall *)(int, HANDLE, HANDLE *, signed int, _DWORD))dword_77EA6594)(
                               v23,
                               v21,
                               &v22,
                               1,
                               0) )
                        {
                          if ( v22 )
                          {
                            ((void (__stdcall *)(int, int, _DWORD))dword_77EA6590)(v23, v3, 0);
                            NtClose(v22);
                            v4 = -1073740959;
                          }
                          else
                          {
                            v4 = 0;
                          }
                        }
                        else
                        {
                          v9 = GetLastError();
                          v20 = v9;
                          if ( v9 == 1260 || v9 == 786 )
                          {
                            ((void (__stdcall *)(int, int, _DWORD))dword_77EA6590)(v23, v19, 0);
                            v4 = v20 != 786 ? -1073740959 : -1073740942;
                          }
                        }
                        ((void (__stdcall *)(int))dword_77EA6598)(v23);
                      }
                      goto LABEL_22;
                    }
                    LdrUnloadDll(ModuleImageBase);
                    dword_77EA6554 = 0;
                    v4 = -1073741511;
                  }
LABEL_22:
                  if ( TokenHandle )
                    NtClose(TokenHandle);
                  goto LABEL_24;
                }
              }
            }
            dword_77EA6554 = -2;
          }
          v4 = 0;
          goto LABEL_22;
        }
        if ( NtCurrentTeb()[1].Reserved1[1] )
          v4 = NtOpenThreadToken((HANDLE)0xFFFFFFFE, 0x2000000u, 1u, &ThreadInformation);
        else
          v4 = -1073741700;
        if ( v4 == -1073741700 )
        {
          ThreadInformation = 0;
        }
        else
        {
          if ( v4 < 0 )
            goto LABEL_24;
          v15 = 0;
          v4 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &v15, 4u);
          if ( v4 < 0 )
          {
            NtClose(ThreadInformation);
            ThreadInformation = 0;
            goto LABEL_24;
          }
        }
        v4 = NtOpenProcessToken((HANDLE)0xFFFFFFFF, 0xAu, &TokenHandle);
        if ( v4 == -1073741790 )
          v4 = NtOpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle);
        if ( v4 < 0 )
          TokenHandle = 0;
        if ( ThreadInformation )
        {
          v6 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &ThreadInformation, 4u);
          NtClose(ThreadInformation);
          ThreadInformation = 0;
          if ( v6 < 0 )
          {
            v4 = v6;
            goto LABEL_22;
          }
        }
        if ( v4 >= 0 )
        {
          v3 = v19;
          v21 = TokenHandle;
          goto LABEL_16;
        }
        if ( dword_77EA6554 == -1 )
        {
          dword_77EA6554 = -2;
          goto LABEL_59;
        }
      }
      else
      {
        v4 = -1073741511;
      }
LABEL_24:
      RtlReleaseSRWLockExclusive(&gsrwlAppCert);
      return v4;
    }
    result = 0;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}
// 77EA659C: invalid function type has been ignored
// 77EA6594: invalid function type has been ignored
// 77EA6598: invalid function type has been ignored
// 77EA6590: invalid function type has been ignored
// 77DE1288: using guessed type int __stdcall LdrLoadDll(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);
// 77E31D30: using guessed type wchar_t aIgnoresrpv2[12];
// 77E31FF8: using guessed type int dword_77E31FF8;
// 77EA6554: using guessed type int dword_77EA6554;
// 77EA6770: using guessed type int gsrwlAppCert;
// 77EA6C88: using guessed type int dword_77EA6C88;

//----- (77E3202D) --------------------------------------------------------
int __stdcall BasepIsProcessAllowed(int a1)
{
  int result; // eax@3
  const WCHAR *v2; // ebx@5
  int v3; // eax@15
  WCHAR *v4; // eax@15
  UINT v5; // eax@17
  HMODULE v6; // eax@21
  int v7; // eax@24
  NTSTATUS v8; // eax@29
  int v9; // esi@34
  signed int v10; // ebx@34
  int v11; // eax@35
  int i; // esi@39
  HANDLE KeyHandle; // [sp+Ch] [bp-8h]@7
  int v14; // [sp+10h] [bp-4h]@5

  while ( !dword_77EA656C )
  {
    v14 = 0;
    v2 = 0;
    RtlAcquireSRWLockExclusive(&gsrwlAppCert);
    if ( dword_77EA656C )
      goto LABEL_12;
    if ( v7FFE02D0 & 0x40 )
    {
      v3 = KernelBaseGetGlobalData();
      v4 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 0x20Au);
      v2 = v4;
      if ( v4 )
      {
        v5 = GetSystemDirectoryW(v4, 0xF6u);
        if ( v5 && v5 <= 0xF6 )
        {
          if ( v2[v5 - 1] != 92 )
            v2[v5++] = 92;
          qmemcpy((void *)&v2[v5], L"EmbdTrst.DLL", 0x1Au);
          v6 = LoadLibraryW(v2);
          if ( !v6 || (dword_77EA6C84 = (int (__stdcall *)(_DWORD))GetProcAddress(v6, "ImageOkToRunOnEmbeddedNT")) == 0 )
            v14 = -1073741823;
        }
        else
        {
          v14 = -1073741823;
        }
      }
      else
      {
        v14 = -1073741801;
      }
LABEL_23:
      if ( v2 )
      {
        v7 = KernelBaseGetGlobalData();
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), (PVOID)v2);
      }
LABEL_13:
      if ( v14 < 0 )
        goto LABEL_10;
      goto LABEL_8;
    }
    if ( NtOpenKey(&KeyHandle, 1u, &stru_77E34554) >= 0 )
    {
      NtClose(KeyHandle);
      v8 = RtlQueryRegistryValues(2u, L"Session Manager", &BasepAppCertTable, 0, 0);
      v14 = v8;
      if ( v8 < 0 )
      {
        if ( v8 == -1073741772 )
        {
          v14 = 0;
          goto LABEL_23;
        }
        goto LABEL_13;
      }
    }
LABEL_8:
    if ( dword_77EA6C84 || (int *)BasepAppCertDllsList != &BasepAppCertDllsList )
    {
      dword_77EA6548 = 1;
      goto LABEL_11;
    }
LABEL_10:
    dword_77EA6548 = 0;
    dword_77EA654C = v14;
LABEL_11:
    dword_77EA656C = 1;
LABEL_12:
    RtlReleaseSRWLockExclusive(&gsrwlAppCert);
  }
  if ( dword_77EA6548 )
  {
    v14 = 0;
    if ( dword_77EA6C84 )
    {
      result = dword_77EA6C84(a1);
    }
    else
    {
      v9 = BasepAppCertDllsList;
      v10 = 2;
      while ( (int *)v9 != &BasepAppCertDllsList )
      {
        v11 = (*(int (__stdcall **)(int, signed int))(v9 + 16))(a1, 1);
        if ( v11 < 0 )
        {
          v14 = v11;
          v10 = 3;
        }
        v9 = *(_DWORD *)v9;
      }
      for ( i = BasepAppCertDllsList; (int *)i != &BasepAppCertDllsList; i = *(_DWORD *)i )
        (*(void (__stdcall **)(int, signed int))(i + 16))(a1, v10);
      result = v14;
    }
  }
  else
  {
    result = dword_77EA654C;
  }
  return result;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77E515B4: using guessed type wchar_t aEmbdtrst_dll[13];
// 77EA62A0: using guessed type int BasepAppCertDllsList;
// 77EA6548: using guessed type int dword_77EA6548;
// 77EA654C: using guessed type int dword_77EA654C;
// 77EA656C: using guessed type int dword_77EA656C;
// 77EA6770: using guessed type int gsrwlAppCert;
// 77EA6C84: using guessed type int (__stdcall *dword_77EA6C84)(_DWORD);

//----- (77E32062) --------------------------------------------------------
int __stdcall BasepCheckWebBladeHashes(int a1)
{
  int result; // eax@2
  int v2; // esi@4
  void *v3; // eax@6
  char Key; // [sp+0h] [bp-14h]@4

  if ( v7FFE02D0 & 0x6C00 )
  {
    v2 = RtlComputeImportTableHash(a1, &Key, 1);
    if ( v2 >= 0 )
    {
      if ( v7FFE02D0 & 0x4000 )
      {
        v3 = _bsearch(&Key, ComputeServerDisallowedHashes, 0x13u, 0x10u, pfnWebBladeHashCompare);
      }
      else if ( v7FFE02D0 & 0x2000 )
      {
        v3 = _bsearch(&Key, StorageServerDisallowedHashes, 8u, 0x10u, pfnWebBladeHashCompare);
      }
      else
      {
        v3 = _bsearch(&Key, WebBladeDisallowedHashes, 0x17u, 0x10u, pfnWebBladeHashCompare);
      }
      if ( v3 )
        v2 = -1073741790;
    }
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77DE1138: using guessed type int __stdcall RtlComputeImportTableHash(_DWORD, _DWORD, _DWORD);
// 77E54AB0: using guessed type int WebBladeDisallowedHashes[92];
// 77E54C20: using guessed type int StorageServerDisallowedHashes[32];
// 77E54CA0: using guessed type int ComputeServerDisallowedHashes[76];

//----- (77E3209C) --------------------------------------------------------
BOOL __stdcall BasepCheckImageVersion(unsigned int a1, unsigned int a2)
{
  return a1 >= 3 && (a1 != 3 || a2 >= 0xA) && a1 <= v7FFE026C && (a1 != v7FFE026C || a2 <= v7FFE0270);
}

//----- (77E320DD) --------------------------------------------------------
unsigned int __stdcall BasepGetTempPathW(int a1, int a2, WCHAR *buf)
{
  ULONG v3; // ebx@1
  int v4; // eax@1
  WCHAR *v5; // esi@3
  unsigned int v6; // eax@3
  unsigned int v7; // eax@6
  int v8; // ecx@6
  WCHAR *v9; // edx@8
  int v11; // eax@21
  LSA_UNICODE_STRING Value; // [sp+10h] [bp-30h]@1
  unsigned int v13; // [sp+18h] [bp-28h]@6
  PWCH v14; // [sp+1Ch] [bp-24h]@3
  unsigned int v15; // [sp+20h] [bp-20h]@2
  char v16; // [sp+27h] [bp-19h]@2
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@2

  v3 = 2 * a2;
  Value.Length = 0;
  Value.MaximumLength = 261;
  v4 = KernelBaseGetGlobalData();
  Value.Buffer = (PWCH)RtlAllocateHeap(
                         NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                         *(_DWORD *)(v4 + 44),
                         0x105u);
  if ( Value.Buffer )
  {
    v15 = 0;
    ms_exc.registration.TryLevel = 0;
    v16 = 0;
    if ( RtlQueryEnvironmentVariable_U(0, &BaseTmpVariableName, &Value) >= 0
      || RtlQueryEnvironmentVariable_U(0, &BaseTempVariableName, &Value) >= 0
      || RtlQueryEnvironmentVariable_U(0, &BaseUserProfileVariableName, &Value) >= 0 )
    {
      v5 = Value.Buffer;
      v14 = Value.Buffer;
      v6 = Value.Length;
    }
    else
    {
      v11 = KernelBaseGetGlobalData();
      v5 = *(WCHAR **)(v11 + 56);
      v14 = *(PWCH *)(v11 + 56);
      v6 = *(_WORD *)(KernelBaseGetGlobalData() + 52);
    }
    if ( v5[(v6 >> 1) - 1] != 92 )
      v16 = 1;
    v7 = RtlGetFullPathName_U(v5, v3, buf, 0);
    v13 = v7;
    v8 = v7 >> 1;
    if ( v7 && v7 < v3 )
    {
      v9 = &buf[v8];
      if ( *(v9 - 1) == 92 )
      {
LABEL_11:
        v15 = v8;
LABEL_12:
        ms_exc.registration.TryLevel = -2;
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Value.Buffer);
        return v15;
      }
      if ( v7 + 2 < v3 )
      {
        *v9 = 92;
        v9[1] = 0;
        v8 = (v7 + 2) >> 1;
        goto LABEL_11;
      }
      v7 += 4;
    }
    else if ( v16 )
    {
      v7 += 2;
      v13 = v7;
    }
    v15 = v7 >> 1;
    goto LABEL_12;
  }
  BaseSetLastNTError(-1073741801);
  return 0;
}

//----- (77E3220E) --------------------------------------------------------
signed int __stdcall IsShimInfrastructureDisabled()
{
  signed int result; // eax@1
  NTSTATUS v1; // esi@19
  ULONG ResultLength; // [sp+0h] [bp-24h]@9
  NTSTATUS v3; // [sp+4h] [bp-20h]@9
  HANDLE KeyHandle; // [sp+8h] [bp-1Ch]@4
  char KeyValueInformation; // [sp+Ch] [bp-18h]@9
  int v6; // [sp+10h] [bp-14h]@10
  int v7; // [sp+14h] [bp-10h]@11
  int v8; // [sp+18h] [bp-Ch]@12

  result = dword_77EA6550;
  if ( dword_77EA6550 != 1 && dword_77EA6550 )
  {
    if ( NtOpenKey(&KeyHandle, 1u, &stru_77E34738) >= 0
      && (v3 = NtQueryValueKey(
                 KeyHandle,
                 &stru_77E5121C,
                 KeyValuePartialInformation,
                 &KeyValueInformation,
                 0x14u,
                 &ResultLength),
          NtClose(KeyHandle),
          v3 >= 0)
      && v6 == 4
      && v7 == 4
      && v8
      || NtOpenKey(&KeyHandle, 1u, &stru_77E34750) >= 0
      && (v3 = NtQueryValueKey(
                 KeyHandle,
                 &stru_77E51224,
                 KeyValuePartialInformation,
                 &KeyValueInformation,
                 0x14u,
                 &ResultLength),
          NtClose(KeyHandle),
          v3 >= 0)
      && v6 == 4
      && v7 == 4
      && v8
      || NtOpenKey(&KeyHandle, 1u, &stru_77E34768) >= 0
      && (v1 = NtQueryValueKey(
                 KeyHandle,
                 &stru_77E5122C,
                 KeyValuePartialInformation,
                 &KeyValueInformation,
                 0x14u,
                 &ResultLength),
          NtClose(KeyHandle),
          v1 >= 0)
      && v6 == 4
      && v7 == 4
      && v8 )
    {
      result = 1;
      dword_77EA6550 = 1;
    }
    else
    {
      dword_77EA6550 = 0;
      result = 0;
    }
  }
  return result;
}
// 77EA6550: using guessed type int dword_77EA6550;

//----- (77E32243) --------------------------------------------------------
int __stdcall BaseCheckAppcompatCacheEx(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@3

  v6 = a4;
  if ( a4 )
    a4 = *(_DWORD *)a4;
  else
    a4 = 0;
  v7 = BasepShimCacheLookup(SourceString, (int)FileHandle, (int)&a4, a5, a6);
  if ( !v7 )
    a4 |= 1u;
  if ( BasepShimCacheCheckBypass(SourceString, FileHandle, Environment, 1, (int)&a4) )
  {
    v7 = 0;
    a4 |= 2u;
  }
  if ( v6 )
    *(_DWORD *)v6 = a4;
  return v7;
}

//----- (77E322AB) --------------------------------------------------------
int __stdcall BasepShimCacheLookup(PCWSTR SourceString, int a2, int a3, int a4, int a5)
{
  HANDLE v5; // esi@1
  signed int v6; // esi@5
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-2Ch]@11
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+20h] [bp-14h]@11
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-Ch]@11
  HANDLE hObject; // [sp+30h] [bp-4h]@1

  hObject = (HANDLE)-1;
  v5 = (HANDLE)a2;
  if ( a2 == -1 )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    if ( NtOpenFile(&hObject, 0x100081u, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u) < 0 )
      goto LABEL_10;
    v5 = hObject;
  }
  if ( BasepShimCacheSearch(SourceString, (int)v5, a3, a4, a5) )
  {
    if ( BasepCheckCacheExcludeList(SourceString) && BasepCheckCacheExcludeCustom(SourceString) )
    {
      v6 = 1;
      goto LABEL_6;
    }
    BasepShimCacheRemoveEntry(SourceString, (int)v5);
  }
LABEL_10:
  v6 = 0;
LABEL_6:
  if ( hObject != (HANDLE)-1 )
    CloseHandle(hObject);
  return v6;
}

//----- (77E32316) --------------------------------------------------------
PCWSTR __stdcall BasepShimCacheSearch(PCWSTR SourceString, int a2, int a3, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@8
  int v8; // edi@14
  int v9; // ecx@18
  int v10; // esi@19
  ULONG v11; // eax@25
  int v13; // [sp+Ch] [bp-D0h]@1
  char Dst; // [sp+10h] [bp-CCh]@1
  char v15; // [sp+9Ch] [bp-40h]@9
  int v16; // [sp+A0h] [bp-3Ch]@13
  int v17; // [sp+A4h] [bp-38h]@6
  LSA_UNICODE_STRING DestinationString; // [sp+A8h] [bp-34h]@6
  unsigned int v19; // [sp+B0h] [bp-2Ch]@7
  int v20; // [sp+B4h] [bp-28h]@7
  int v21; // [sp+D4h] [bp-8h]@1
  int v22; // [sp+D8h] [bp-4h]@3
  PCWSTR SourceStringa; // [sp+E4h] [bp+8h]@9
  int v24; // [sp+F4h] [bp+18h]@5

  v13 = 0;
  memset(&Dst, 0, 0xC4u);
  v5 = a4;
  v6 = a5;
  v21 = 0;
  if ( !a4 || *(_DWORD *)a4 <= 0u || (v22 = 1, !a5) )
    v22 = 0;
  if ( a3 )
    v24 = *(_DWORD *)a3;
  else
    v24 = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  v17 = a2;
  if ( v22 )
  {
    v19 = *(_DWORD *)a4;
    v20 = v6;
  }
  v7 = NtApphelpCacheControl(0, &v13);
  if ( v7 < 0 || (SourceStringa = (PCWSTR)1, !(v15 & 1)) )
    SourceStringa = 0;
  if ( v24 & 0x80 )
  {
    v8 = v7 < 0 || !(v15 & 4) || v16 & 0x100;
    v9 = v7 >= 0 && v15 & 4 && v16 & 0x200;
    v10 = v7FFE03C8 == -1;
    if ( v7FFE03C8 == -1 || v8 && v7FFE03C8 != 0 && !v9 )
    {
      if ( !Seed )
        Seed = GetTickCount();
      v11 = RtlRandom(&Seed);
      if ( v10 || v11 < v7FFE03C8 )
      {
        v24 |= 0x40u;
        v21 = 1;
      }
    }
    v5 = a4;
  }
  if ( SourceStringa )
  {
    if ( v21 )
    {
      v24 |= 2u;
      SourceStringa = 0;
    }
    if ( SourceStringa && v19 > 0 )
    {
      if ( v22 )
        v24 |= 0x100u;
      else
        v24 |= 0x200u;
    }
  }
  if ( v5 )
    *(_DWORD *)v5 = v19;
  if ( a3 )
    *(_DWORD *)a3 = v24;
  return SourceStringa;
}
// 77DE114C: using guessed type int __stdcall NtApphelpCacheControl(_DWORD, _DWORD);

//----- (77E324A6) --------------------------------------------------------
int __stdcall BasepShimCacheCheckBypass(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@2
  unsigned int v7; // esi@5
  int v8; // eax@6
  WCHAR SourceCharacter[2]; // [sp+8h] [bp-28h]@5
  LSA_UNICODE_STRING *v11; // [sp+Ch] [bp-24h]@5
  LSA_UNICODE_STRING *v12; // [sp+10h] [bp-20h]@5
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-1Ch]@5
  LSA_UNICODE_STRING Value; // [sp+1Ch] [bp-14h]@10
  LSA_UNICODE_STRING UnicodeString; // [sp+24h] [bp-Ch]@3
  int v16; // [sp+2Ch] [bp-4h]@1

  v16 = 0;
  v5 = a5;
  if ( a5 )
    v6 = *(_DWORD *)a5;
  else
    v6 = 0;
  UnicodeString.Length = 0;
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  if ( FileHandle != (HANDLE)-1 && BasepIsRemovableMedia(FileHandle, 0) )
  {
    v16 = 1;
    v6 |= 8u;
  }
  else
  {
    BasepInitUserTempPath(&UnicodeString);
    RtlInitUnicodeString(&DestinationString, SourceString);
    v7 = 0;
    *(_DWORD *)SourceCharacter = &gustrWindowsTemp;
    v11 = &UnicodeString;
    v12 = &gustrSystemdriveTemp;
    while ( 1 )
    {
      v8 = *(_DWORD *)&SourceCharacter[2 * v7];
      if ( *(_DWORD *)(v8 + 4) )
      {
        if ( BasepCheckStringPrefixUnicode(v8, (int)&DestinationString, 1) )
          break;
      }
      ++v7;
      if ( v7 >= 3 )
        goto LABEL_8;
    }
    v16 = 1;
    v6 |= 0x10u;
LABEL_8:
    RtlFreeUnicodeString(&UnicodeString);
    v5 = a5;
  }
  if ( a4 )
  {
    Value.Buffer = 0;
    Value.Length = 0;
    Value.MaximumLength = 0;
    if ( RtlQueryEnvironmentVariable_U(Environment, &stru_77E32578, &Value) == -1073741789 )
    {
      v6 |= 4u;
      v16 = 1;
    }
  }
  if ( v5 )
    *(_DWORD *)v5 = v6;
  return v16;
}

//----- (77E32585) --------------------------------------------------------
int __stdcall sub_77E32585(PVOID Environment, int a2, int a3)
{
  int v3; // edi@1
  unsigned int v4; // ebx@1
  LSA_UNICODE_STRING *v5; // esi@3
  PVOID v7; // eax@17
  WCHAR *v8; // esi@19
  LSA_UNICODE_STRING *v9; // edi@19
  LSA_UNICODE_STRING Name; // [sp+8h] [bp-58h]@1
  int v11; // [sp+10h] [bp-50h]@1
  int v12; // [sp+14h] [bp-4Ch]@1
  __int16 v13; // [sp+18h] [bp-48h]@1
  __int16 v14; // [sp+1Ah] [bp-46h]@1
  int v15; // [sp+1Ch] [bp-44h]@1
  int v16; // [sp+20h] [bp-40h]@1
  int v17; // [sp+24h] [bp-3Ch]@1
  __int16 v18; // [sp+28h] [bp-38h]@1
  __int16 v19; // [sp+2Ah] [bp-36h]@1
  int v20; // [sp+2Ch] [bp-34h]@1
  int v21; // [sp+30h] [bp-30h]@1
  int v22; // [sp+34h] [bp-2Ch]@1
  __int16 v23; // [sp+38h] [bp-28h]@1
  __int16 v24; // [sp+3Ah] [bp-26h]@1
  int v25; // [sp+3Ch] [bp-24h]@1
  int v26; // [sp+40h] [bp-20h]@1
  int v27; // [sp+44h] [bp-1Ch]@1
  LSA_UNICODE_STRING v28; // [sp+48h] [bp-18h]@23
  LSA_UNICODE_STRING Value; // [sp+50h] [bp-10h]@4
  int v30; // [sp+58h] [bp-8h]@3
  NTSTATUS v31; // [sp+5Ch] [bp-4h]@4

  Name.Length = 32;
  Name.MaximumLength = 34;
  Name.Buffer = L"SHIM_DEBUG_LEVEL";
  v11 = 0;
  v12 = 0;
  v13 = 26;
  v14 = 28;
  v15 = (int)L"SHIM_FILE_LOG";
  v16 = 0;
  v17 = 0;
  v18 = 28;
  v19 = 30;
  v20 = (int)L"__COMPAT_LAYER";
  v21 = 0;
  v22 = 0;
  v23 = 34;
  v24 = 36;
  v25 = (int)L"__PROCESS_HISTORY";
  v26 = 0;
  v27 = 0;
  v3 = a2;
  v4 = 0;
  if ( a2 && a3 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)a3 = 0;
    v5 = &Name;
    v30 = 4;
    do
    {
      Value.Buffer = 0;
      Value.MaximumLength = 0;
      Value.Length = 0;
      v31 = RtlQueryEnvironmentVariable_U(Environment, v5, &Value);
      if ( v31 == -1073741789 )
      {
        v4 += Value.Length + v5->Length + 4;
        v5[1].MaximumLength = Value.Length + 2;
      }
      v5 += 2;
      --v30;
    }
    while ( v30 );
    if ( v4 )
      v4 += 2;
    else
      v31 = -1073741772;
    *(_DWORD *)a3 = v4;
    if ( v31 == -1073741772 )
    {
LABEL_9:
      if ( v31 >= 0 )
        return v31;
LABEL_10:
      *(_DWORD *)a3 = 0;
      if ( v4 )
      {
        if ( *(_DWORD *)v3 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)v3);
          *(_DWORD *)v3 = 0;
        }
      }
      return v31;
    }
    if ( v4 )
    {
      v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
      *(_DWORD *)a2 = v7;
      if ( !v7 )
      {
        v31 = -1073741801;
        goto LABEL_10;
      }
      v8 = (WCHAR *)v7;
      v9 = &Name;
      v30 = 4;
      do
      {
        if ( v9[1].MaximumLength )
        {
          Value.Length = 0;
          Value.Buffer = v8;
          Value.MaximumLength = v4;
          v31 = RtlAppendUnicodeStringToString(&Value, v9);
          if ( v31 >= 0 )
          {
            v31 = RtlAppendUnicodeToString(&Value, L"=");
            if ( v31 >= 0 )
            {
              v28.Buffer = &v8[(unsigned int)Value.Length >> 1];
              v28.MaximumLength = v4 - Value.Length;
              v31 = RtlQueryEnvironmentVariable_U(Environment, v9, &v28);
              if ( v31 >= 0 )
              {
                v4 -= v28.Length + Value.Length;
                if ( v4 >= 4 )
                {
                  v8[(Value.Length + (unsigned int)v28.Length) >> 1] = 0;
                  v4 -= 2;
                  v8 += (v28.Length + (unsigned int)Value.Length + 2) >> 1;
                }
              }
            }
          }
        }
        v9 += 2;
        --v30;
      }
      while ( v30 );
      if ( v4 < 2 )
      {
        v3 = a2;
        goto LABEL_9;
      }
      memset(v8, 0, v4);
      v3 = a2;
    }
    v31 = 0;
    goto LABEL_9;
  }
  return -1073741811;
}
// 77E3269C: using guessed type wchar_t a__process_hist[18];
// 77E326C0: using guessed type wchar_t aShim_file_log[14];
// 77E326DC: using guessed type wchar_t aShim_debug_lev[17];
// 77E32700: using guessed type wchar_t a__compat_layer[15];

//----- (77E32723) --------------------------------------------------------
int __stdcall BasepInitUserTempPath(PUNICODE_STRING ntname)
{
  int v1; // ebx@1
  unsigned int v2; // eax@1
  WCHAR dosname; // [sp+Ch] [bp-20Ch]@1

  v1 = 0;
  v2 = BasepGetTempPathW(1, 260, &dosname);
  if ( v2 && v2 < 0x104 )
    v1 = RtlDosPathNameToNtPathName_U(&dosname, ntname, 0, 0);
  return v1;
}

//----- (77E327A5) --------------------------------------------------------
int __stdcall BasepCheckStringPrefixUnicode(int SourceCharacter, int a2, int a3)
{
  unsigned int v3; // ebx@1
  WCHAR *v5; // esi@6
  int v6; // edi@6
  unsigned int v7; // ebx@6
  WCHAR v8; // ax@8
  int v9; // ecx@8
  int v10; // edi@12
  WCHAR v11; // ax@13
  __int16 v12; // cx@13
  int SourceCharactera; // [sp+14h] [bp+8h]@8
  int v14; // [sp+18h] [bp+Ch]@9

  v3 = *(_WORD *)SourceCharacter;
  if ( *(_WORD *)a2 < v3 || !*(_WORD *)SourceCharacter )
    return 0;
  v5 = *(WCHAR **)(SourceCharacter + 4);
  v6 = *(_DWORD *)(a2 + 4);
  v7 = v3 >> 1;
  if ( a3 )
  {
    while ( v7 )
    {
      v8 = *v5;
      v9 = *(_WORD *)v6;
      --v7;
      ++v5;
      v6 += 2;
      SourceCharactera = v9;
      if ( v8 != (_WORD)v9 )
      {
        v14 = RtlUpcaseUnicodeChar(v8);
        if ( (_WORD)v14 != RtlUpcaseUnicodeChar(SourceCharactera) )
          return 0;
      }
    }
    return 1;
  }
  if ( v7 )
  {
    v10 = v6 - (_DWORD)v5;
    while ( 1 )
    {
      v11 = *v5;
      v12 = *(WCHAR *)((char *)v5 + v10);
      --v7;
      ++v5;
      if ( v11 != v12 )
        break;
      if ( !v7 )
        return 1;
    }
    return 0;
  }
  return 1;
}

//----- (77E327CF) --------------------------------------------------------
void __stdcall BasepFreeAppCompatData(PVOID Address, PVOID a2, PVOID a3)
{
  int v3; // eax@5
  int v4; // eax@6
  int v5; // eax@7

  if ( Address )
  {
    v3 = KernelBaseGetGlobalData();
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), Address);
  }
  if ( a2 )
  {
    v5 = KernelBaseGetGlobalData();
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), a2);
  }
  if ( a3 )
  {
    v4 = KernelBaseGetGlobalData();
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), a3);
  }
}

//----- (77E32803) --------------------------------------------------------
__int16 __stdcall BasepGetExeType(int a1, int a2, int a3, int a4)
{
  __int16 result; // ax@2

  if ( a1 )
    result = *(_WORD *)(a1 + 32);
  else
    result = 0;
  *(_WORD *)a4 = result;
  return result;
}

//----- (77E32826) --------------------------------------------------------
NTSTATUS sub_77E32826()
{
  NTSTATUS v0; // edi@2
  LONG v2; // eax@20
  LONG v3; // eax@20
  LONG v4; // eax@20
  LONG v5; // eax@20
  LONG v6; // eax@20
  LONG v7; // eax@20
  LONG v8; // eax@20
  LONG v9; // [sp-Ch] [bp-24Ch]@6
  PVOID v10; // [sp+8h] [bp-238h]@14
  PVOID v11; // [sp+Ch] [bp-234h]@13
  PVOID v12; // [sp+10h] [bp-230h]@15
  PVOID v13; // [sp+14h] [bp-22Ch]@18
  PVOID ProcedureAddress; // [sp+18h] [bp-228h]@12
  PVOID v15; // [sp+1Ch] [bp-224h]@16
  PVOID v16; // [sp+20h] [bp-220h]@19
  PVOID v17; // [sp+24h] [bp-21Ch]@17
  LSA_UNICODE_STRING Destination; // [sp+28h] [bp-218h]@8
  PVOID ModuleImageBase; // [sp+30h] [bp-210h]@1
  char v20; // [sp+34h] [bp-20Ch]@8

  ModuleImageBase = 0;
  if ( gApphelpGlobals != 1 )
  {
    if ( gApphelpGlobals == -1 )
    {
      v0 = -1073741823;
    }
    else if ( 2 * wcslen((const unsigned __int16 *)0x7FFE0030) + 44 > 0x208 )
    {
      v0 = -1073741789;
    }
    else
    {
      Destination.MaximumLength = 520;
      Destination.Buffer = (PWCH)&v20;
      Destination.Length = 0;
      v0 = RtlAppendUnicodeToString(&Destination, (PCWSTR)0x7FFE0030);
      if ( v0 >= 0 )
      {
        v0 = RtlAppendUnicodeStringToString(&Destination, &stru_77E34AFC);
        if ( v0 >= 0 )
        {
          v0 = LdrLoadDll(0, 0, &Destination, &ModuleImageBase);
          if ( v0 >= 0 )
          {
            v0 = LdrAddRefDll(1, ModuleImageBase);
            if ( v0 >= 0 )
            {
              v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B04, 0, &ProcedureAddress);
              if ( v0 >= 0 )
              {
                v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B0C, 0, &v11);
                if ( v0 >= 0 )
                {
                  v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B14, 0, &v10);
                  if ( v0 >= 0 )
                  {
                    v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B1C, 0, &v12);
                    if ( v0 >= 0 )
                    {
                      v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B24, 0, &v15);
                      if ( v0 >= 0 )
                      {
                        v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B2C, 0, &v17);
                        if ( v0 >= 0 )
                        {
                          v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B34, 0, &v13);
                          if ( v0 >= 0 )
                          {
                            v0 = LdrGetProcedureAddress(ModuleImageBase, &stru_77E34B3C, 0, &v16);
                            if ( v0 >= 0 )
                            {
                              v2 = RtlEncodeSystemPointer(ProcedureAddress);
                              InterlockedCompareExchange(&dword_77EA6060, v2, 0);
                              v3 = RtlEncodeSystemPointer(v11);
                              InterlockedCompareExchange(&dword_77EA6064, v3, 0);
                              v4 = RtlEncodeSystemPointer(v12);
                              InterlockedCompareExchange(&dword_77EA606C, v4, 0);
                              v5 = RtlEncodeSystemPointer(v15);
                              InterlockedCompareExchange(&dword_77EA6070, v5, 0);
                              v6 = RtlEncodeSystemPointer(v17);
                              InterlockedCompareExchange(&dword_77EA6074, v6, 0);
                              v7 = RtlEncodeSystemPointer(v13);
                              InterlockedCompareExchange(&dword_77EA6078, v7, 0);
                              v8 = RtlEncodeSystemPointer(v16);
                              InterlockedCompareExchange(&dword_77EA607C, v8, 0);
                              v9 = 1;
                              goto LABEL_21;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v9 = -1;
LABEL_21:
    InterlockedCompareExchange(&gApphelpGlobals, v9, 0);
    return v0;
  }
  return 0;
}
// 77DE1140: using guessed type int __stdcall RtlEncodeSystemPointer(_DWORD);
// 77DE1288: using guessed type int __stdcall LdrLoadDll(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13E8: using guessed type int __stdcall LdrAddRefDll(_DWORD, _DWORD);

//----- (77E3286A) --------------------------------------------------------
signed int __stdcall BasepQueryAppCompat(void *a1, int a2, int a3, int a4, void *a5, const WCHAR *a6, void *a7, int a8, int a9, int a10, int a11, int a12, int a13, void *a14, int a15, int a16, int a17)
{
  signed int v17; // eax@1
  signed int result; // eax@2
  int v19; // [sp+8h] [bp-4h]@1

  v19 = 0;
  BasepFreeAppCompatData(0, *(PVOID *)a10, *(PVOID *)a8);
  *(_DWORD *)a8 = 0;
  *(_DWORD *)a10 = 0;
  BasepGetExeType(a2, a3, a4, (int)&v19);
  v17 = BasepCheckBadapp(a1, a5, a6, a7, v19, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
  if ( v17 < 0 )
  {
    if ( v17 == -1073741790 )
      RtlSetLastWin32Error(1223);
    else
      BaseSetLastNTError(v17);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E328E3) --------------------------------------------------------
signed int __stdcall BasepCheckBadapp(void *a1, void *a2, const WCHAR *a3, void *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, void *a12, int a13, int a14, int a15)
{
  PVOID v15; // ST30_4@10
  int v16; // ST24_4@10
  int v17; // ST1C_4@10
  int v18; // ST18_4@10
  PVOID v19; // eax@1
  int v20; // eax@2
  unsigned int v21; // ecx@2
  signed int v23; // [sp+24h] [bp-1F0h]@1
  int v24; // [sp+28h] [bp-1ECh]@1
  HANDLE FileHandle; // [sp+2Ch] [bp-1E8h]@1
  PVOID Address; // [sp+30h] [bp-1E4h]@1
  PCWSTR SourceString; // [sp+34h] [bp-1E0h]@1
  int v28; // [sp+38h] [bp-1DCh]@1
  int v29; // [sp+3Ch] [bp-1D8h]@1
  int v30; // [sp+40h] [bp-1D4h]@1
  int v31; // [sp+44h] [bp-1D0h]@1
  int v32; // [sp+48h] [bp-1CCh]@1
  char Dst; // [sp+4Ch] [bp-1C8h]@1

  FileHandle = a2;
  SourceString = a3;
  v30 = a6;
  v31 = a7;
  v28 = a9;
  Address = a12;
  v23 = 0;
  v29 = 128;
  v32 = 0;
  memset(&Dst, 0, 0x1C4u);
  *(_DWORD *)a6 = 0;
  *(_DWORD *)v31 = 0;
  *(_DWORD *)a8 = 0;
  *(_DWORD *)v28 = 0;
  *(_DWORD *)a10 = 0;
  v19 = Address;
  *(_DWORD *)a11 = 0;
  *(_DWORD *)(a11 + 4) = 0;
  *(_DWORD *)v19 = 0;
  *(_DWORD *)a13 = 0;
  v24 = 456;
  *(_DWORD *)a14 = 0;
  if ( IsShimInfrastructureDisabled() )
    return 0;
  v20 = BaseCheckAppcompatCacheEx(SourceString, FileHandle, a4, (int)&v29, (int)&v24, (int)&v32);
  v21 = v29;
  if ( !v20 )
    goto LABEL_10;
  if ( v29 & 0x100 )
  {
    *(_DWORD *)v30 = &v32;
    *(_DWORD *)v31 = v24;
    goto LABEL_10;
  }
  if ( v29 & 0x200 )
  {
LABEL_10:
    v15 = Address;
    v16 = v28;
    v17 = v31;
    *(_DWORD *)a13 = 1;
    v18 = v30;
    *(_DWORD *)a14 = (v21 >> 3) & 1;
    if ( !BaseCheckRunApp(a1, (int)FileHandle, (int)SourceString, a4, a5, v21, v18, v17, a8, v16, a10, a11, v15) )
      v23 = -1073741790;
    if ( *(int **)v30 == &v32 )
    {
      *(_DWORD *)v30 = 0;
      *(_DWORD *)v31 = 0;
    }
  }
  if ( a15 )
    *(_DWORD *)a15 = v29;
  return v23;
}

//----- (77E32A8F) --------------------------------------------------------
int __stdcall BasepCsrCaptureSxsMessage(int a1, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  signed int v4; // [sp-8h] [bp-20h]@4
  int *v5; // [sp-4h] [bp-1Ch]@4
  int v6; // [sp+4h] [bp-14h]@7
  int v7; // [sp+8h] [bp-10h]@4
  int v8; // [sp+Ch] [bp-Ch]@4
  int v9; // [sp+10h] [bp-8h]@4
  int v10; // [sp+14h] [bp-4h]@5

  result = 0;
  *(_DWORD *)a2 = 0;
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 && !(v3 & 0x20) )
  {
    if ( v3 & 0x40 )
    {
      v7 = a1 + 12;
      v8 = a1 + 20;
      v9 = a1 + 96;
      v5 = &v7;
      v4 = 4;
    }
    else
    {
      v6 = a1 + 12;
      v7 = a1 + 52;
      v8 = a1 + 88;
      v9 = a1 + 96;
      v5 = &v6;
      v4 = 5;
    }
    v10 = a1 + 128;
    result = CsrCaptureMessageMultiUnicodeStringsInPlace(a2, v4, v5);
  }
  return result;
}
// 77DE1154: using guessed type int __stdcall CsrCaptureMessageMultiUnicodeStringsInPlace(_DWORD, _DWORD, _DWORD);

//----- (77E32AE5) --------------------------------------------------------
PHANDLE __stdcall BasepConstructSxsCreateProcessMessage(int a1, int a2, HANDLE FileHandle, int a4, int a5, int a6, ULONG Size, int a8, char a9, int a10, int a11, int a12, int Buffer, int a14, int a15, int a16, int a17, void *Dst, PHANDLE a19)
{
  PHANDLE v19; // esi@1
  void *v20; // edi@1
  int v21; // ebx@1
  int v22; // eax@11
  bool v23; // zf@11
  int v24; // ebx@12
  PVOID v25; // eax@14
  __int16 v26; // bx@16
  int v27; // esi@17
  int v29; // ebx@26
  PVOID v30; // eax@29
  int *v31; // ecx@31
  int v32; // eax@31
  int v33; // edx@31
  int v34; // ecx@32
  unsigned int v35; // edx@33
  int v36; // eax@47
  int v37; // edx@52
  HANDLE v38; // [sp+Ch] [bp-60h]@1
  int v39; // [sp+10h] [bp-5Ch]@1
  int v40; // [sp+14h] [bp-58h]@1
  int v41; // [sp+18h] [bp-54h]@1
  int v42; // [sp+1Ch] [bp-50h]@1
  int v43; // [sp+20h] [bp-4Ch]@1
  PHANDLE v44; // [sp+24h] [bp-48h]@1
  PHANDLE v45; // [sp+28h] [bp-44h]@1
  PHANDLE v46; // [sp+2Ch] [bp-40h]@1
  PHANDLE v47; // [sp+30h] [bp-3Ch]@1
  PHANDLE v48; // [sp+34h] [bp-38h]@1
  int v49; // [sp+38h] [bp-34h]@39
  int v50; // [sp+3Ch] [bp-30h]@52
  int v51; // [sp+40h] [bp-2Ch]@52
  int v52; // [sp+44h] [bp-28h]@52
  int v53; // [sp+48h] [bp-24h]@1
  PHANDLE v54; // [sp+4Ch] [bp-20h]@1
  int v55; // [sp+50h] [bp-1Ch]@1
  int v56; // [sp+54h] [bp-18h]@1
  int v57; // [sp+58h] [bp-14h]@1
  PHANDLE v58; // [sp+5Ch] [bp-10h]@1
  int v59; // [sp+60h] [bp-Ch]@1
  int v60; // [sp+64h] [bp-8h]@1
  LONG Exchange; // [sp+68h] [bp-4h]@1

  v19 = a19;
  v44 = a19 + 12;
  v53 = (int)(a19 + 12);
  v48 = a19 + 48;
  v58 = a19 + 48;
  v45 = a19 + 21;
  v57 = (int)(a19 + 21);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  v42 = 0;
  v43 = 0;
  v20 = Dst;
  v46 = a19 + 30;
  v55 = a2;
  v21 = a1;
  v47 = a19 + 39;
  v56 = a1;
  v54 = a19 + 39;
  v60 = 0;
  v59 = 0;
  Exchange = 0;
  memset(Dst, 0, 0x88u);
  memset(v19, 0, 0x100u);
  *((_DWORD *)v20 + 27) = 0;
  a19 = (PHANDLE)BasepGetDisableLocalOverrideConfig((LONG)&Exchange);
  if ( (signed int)a19 >= 0 )
  {
    if ( a12 )
    {
      *(_DWORD *)v20 |= 0x20u;
      v27 = a17;
      goto LABEL_22;
    }
    a19 = (PHANDLE)BasepGetPreferExternalManifestConfig((int)&v60);
    if ( (signed int)a19 >= 0 )
    {
      if ( v60 || a8 )
        goto LABEL_59;
      if ( !a6 )
        Size = BasepIsRemovableMedia(FileHandle, 0);
      if ( Size || v7FFE02EC )
      {
LABEL_59:
        v19[17] = (HANDLE)(*(_WORD *)a2 + 20);
        v19[26] = (HANDLE)(*(_WORD *)a2 + 16);
        v19[35] = (HANDLE)(*(_WORD *)a2 + 2);
        v19[44] = (HANDLE)(*(_WORD *)a1 + 20);
        v19[53] = (HANDLE)(*(_WORD *)a1 + 16);
        Size = 0;
        v29 = 0;
        while ( 1 )
        {
          a19 = (PHANDLE)RtlSIZETAdd(Size, (SIZE_T)(&v44)[v29][5], &Size);
          if ( (signed int)a19 < 0 )
            break;
          ++v29;
          if ( v29 == 5 )
          {
            v30 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
            v19[57] = v30;
            if ( !v30 )
              return (PHANDLE)-1073741801;
            Size = 0;
            do
            {
              v31 = (int *)&(&v44)[Size];
              v32 = *v31;
              v33 = *(_DWORD *)(*v31 + 20);
              if ( Size )
                v34 = *(_DWORD *)(*(v31 - 1) + 8) + *(_DWORD *)(*(v31 - 1) + 20);
              else
                v34 = (int)v19[57];
              v35 = v33 & 0xFFFFFFFE;
              if ( v35 > 0xFFFE )
                v35 = 65534;
              if ( v35 < 2 )
              {
                v34 = v32 + 32;
                v35 = 2;
              }
              *(_DWORD *)(v32 + 8) = v34;
              *(_DWORD *)(v32 + 16) = v35;
              *(_DWORD *)(v32 + 12) = v34;
              *(_DWORD *)(v32 + 20) = v35;
              *(_DWORD *)(v32 + 4) = v34;
              if ( v34 )
                *(_WORD *)v34 = 0;
              ++Size;
              v23 = Size == 5;
              *(_WORD *)v32 = 0;
              *(_WORD *)(v32 + 2) = v35;
            }
            while ( !v23 );
            v39 = a4;
            v38 = FileHandle;
            v40 = a5;
            if ( a10 )
            {
              v37 = *(_DWORD *)a2;
              v50 = *(_DWORD *)(a2 + 4);
              v49 = v37;
              v51 = a10;
              v52 = a11;
            }
            a19 = (PHANDLE)BasepSxsCreateProcessCsrMessage(
                             a10 != 0 ? (unsigned int)&v49 : 0,
                             0,
                             a14,
                             a15,
                             a16,
                             (int)&v53,
                             v19,
                             (int)&v55,
                             &v38,
                             (int)&v57,
                             v19 + 6,
                             (int)(v19 + 30),
                             Buffer,
                             v20);
            if ( (signed int)a19 >= 0 )
              goto LABEL_12;
            return a19;
          }
        }
      }
      else
      {
        if ( a10 )
        {
          *((_DWORD *)v20 + 8) = a10;
          v36 = a11;
          *((_DWORD *)v20 + 9) = 0;
          *((_DWORD *)v20 + 10) = v36;
        }
        *((_DWORD *)v20 + 5) = *(_DWORD *)a1;
        *((_DWORD *)v20 + 6) = *(_DWORD *)(a1 + 4);
        *((_DWORD *)v20 + 3) = *(_DWORD *)a2;
        v22 = *(_DWORD *)(a2 + 4);
        *(_DWORD *)v20 |= 0x40u;
        v23 = Exchange == 1;
        *((_DWORD *)v20 + 4) = v22;
        *((_DWORD *)v20 + 2) = FileHandle;
        *((_DWORD *)v20 + 16) = a14;
        *((_DWORD *)v20 + 17) = a15;
        *((_DWORD *)v20 + 18) = a16;
        if ( v23 )
          *(_DWORD *)v20 |= 0x200u;
LABEL_12:
        v24 = (int)(v19 + 61);
        a19 = (PHANDLE)RtlGetThreadPreferredUILanguages(65544, v19 + 62, v19[60], v19 + 61);
        if ( (signed int)a19 >= 0 )
        {
          if ( !v19[62] )
            goto LABEL_60;
          v25 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * *(_DWORD *)v24);
          v19[60] = v25;
          if ( !v25 )
            return (PHANDLE)-1073741801;
          a19 = (PHANDLE)RtlGetThreadPreferredUILanguages(65544, v19 + 62, v25, v19 + 61);
          if ( (signed int)a19 >= 0 )
          {
LABEL_60:
            v26 = *(_WORD *)v24;
            v19[59] = v19[60];
            v26 *= 2;
            v23 = a8 == 0;
            *((_WORD *)v19 + 116) = v26;
            *((_WORD *)v19 + 117) = v26;
            *((_DWORD *)v20 + 24) = v19[58];
            *((_DWORD *)v20 + 25) = v19[59];
            if ( !v23 )
              *(_DWORD *)v20 |= 0x80u;
            v27 = a17;
            if ( *(_BYTE *)v20 & 1 )
              *(_DWORD *)a17 |= 0x2000u;
            if ( a9 & 1 )
              *(_DWORD *)v20 |= 0x10u;
            if ( *(_BYTE *)v20 & 0x41 )
              RtlInitUnicodeString(
                (PUNICODE_STRING)v20 + 16,
                L"-----------------------------------------------------------");
            v21 = a1;
LABEL_22:
            if ( a8 )
            {
              *(_DWORD *)v27 |= 0x8000u;
            }
            else if ( *(_BYTE *)v20 & 0x41 )
            {
LABEL_24:
              *((_DWORD *)v20 + 1) = *(_DWORD *)v27;
              return a19;
            }
            if ( Exchange != 1 )
            {
              a19 = (PHANDLE)BasepCheckDotLocalExists(v21, (int)&v59);
              if ( (signed int)a19 < 0 )
                return a19;
              if ( v59 )
                *(_DWORD *)v27 |= 0x1000u;
            }
            goto LABEL_24;
          }
        }
      }
    }
  }
  return a19;
}
// 77DE1178: using guessed type int __stdcall RtlGetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E32DA5) --------------------------------------------------------
int __stdcall BasepGetDisableLocalOverrideConfig(LONG Exchange)
{
  LONG v1; // ebx@1
  int v2; // edi@1
  int v4; // eax@4
  LONG v5; // eax@7

  v1 = Exchange;
  *(_DWORD *)Exchange = 0;
  v2 = 0;
  Exchange = dword_77EA676C;
  if ( dword_77EA676C == -1 )
  {
    v4 = LdrQueryImageFileExecutionOptions(0, L"DisableLocalOverride", 4, &Exchange, 4, 0);
    v2 = v4;
    if ( v4 == -1073741772 )
    {
      v2 = 0;
    }
    else
    {
      if ( v4 < 0 )
        return v2;
      if ( Exchange != -1 )
        goto LABEL_7;
    }
    Exchange = 0;
LABEL_7:
    v5 = InterlockedCompareExchange(&dword_77EA676C, Exchange, -1);
    if ( v5 != -1 )
      Exchange = v5;
  }
  *(_DWORD *)v1 = Exchange;
  return v2;
}
// 77DE1374: using guessed type int __stdcall LdrQueryImageFileExecutionOptions(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E34BA8: using guessed type wchar_t aDisablelocalov[21];

//----- (77E32DDA) --------------------------------------------------------
char __stdcall BasepReleaseSxsCreateProcessUtilityStruct(int a1)
{
  int v1; // edi@1
  int v2; // eax@2
  void *v3; // edi@4
  int v4; // esi@7
  PWCH *v5; // ebx@8
  int v6; // eax@12
  int v8; // [sp+8h] [bp-1Ch]@1
  int v9; // [sp+Ch] [bp-18h]@1
  int v10; // [sp+10h] [bp-14h]@1
  int v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+18h] [bp-Ch]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+1Ch] [bp-8h]@17
  unsigned int v14; // [sp+2Ch] [bp+8h]@6

  v1 = a1;
  v8 = a1 + 48;
  v9 = a1 + 84;
  v10 = a1 + 120;
  v11 = a1 + 156;
  v12 = a1 + 192;
  BasepSxsCloseHandles(a1);
  BasepSxsCloseHandles(a1 + 24);
  if ( *(_DWORD *)(a1 + 228) )
  {
    v14 = 0;
    do
    {
      v4 = *(&v8 + v14);
      if ( v4 )
      {
        v5 = (PWCH *)(v4 + 8);
        if ( v4 != -8 && *v5 )
        {
          if ( *v5 != *(PWCH *)(v4 + 12) )
          {
            UnicodeString.Buffer = *v5;
            RtlFreeUnicodeString(&UnicodeString);
          }
          *v5 = *(PWCH *)(v4 + 12);
          *(_DWORD *)(v4 + 16) = *(_DWORD *)(v4 + 20);
        }
        v6 = *(_DWORD *)(v4 + 12);
        *(_DWORD *)(v4 + 4) = v6;
        if ( v6 )
          *(_WORD *)v6 = 0;
        *(_WORD *)v4 = 0;
        *(_WORD *)(v4 + 2) = *(_WORD *)(v4 + 20);
      }
      ++v14;
    }
    while ( v14 < 5 );
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v1 + 228));
  }
  v2 = *(_DWORD *)(v1 + 240);
  if ( v2 )
    LOBYTE(v2) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v1 + 240));
  v3 = *(void **)(v1 + 252);
  if ( v3 )
    LOBYTE(v2) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  return v2;
}

//----- (77E32FCD) --------------------------------------------------------
signed int __stdcall SbpIsTraceEnabled()
{
  signed int v0; // esi@1
  int v2; // [sp+8h] [bp-68h]@1
  __int16 v3; // [sp+Ch] [bp-64h]@1
  char v4; // [sp+4Ch] [bp-24h]@1

  qmemcpy(&v4, L"SB_ENABLE_TRACE", 0x20u);
  v0 = 0;
  if ( RtlQueryEnvironmentVariable(0, &v4, 15, &v3, 32, &v2) >= 0 && (unsigned int)(v2 + 1) < 0x20 && v3 == 49 )
    v0 = 1;
  return v0;
}
// 77DE1010: using guessed type int __stdcall RtlQueryEnvironmentVariable(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E33020: using guessed type wchar_t aSb_enable_trac[16];

//----- (77E33045) --------------------------------------------------------
signed int __stdcall SbpDeriveVirtualOsVersionBasedOnEnvionmentVariable(wchar_t *a1, unsigned int a2, int a3, int a4, int a5)
{
  signed int v5; // esi@2
  int v7; // eax@6
  int v8; // edx@6
  int v9; // [sp+Ch] [bp-34h]@1
  int v10; // [sp+10h] [bp-30h]@1
  int v11; // [sp+14h] [bp-2Ch]@1
  wchar_t *Str1; // [sp+18h] [bp-28h]@1
  int v13; // [sp+1Ch] [bp-24h]@1
  char v14; // [sp+20h] [bp-20h]@1

  v13 = 0;
  v11 = a3;
  qmemcpy(&v14, L"SB_VIRTUAL_OS", 0x1Cu);
  v10 = a5;
  *(_WORD *)a4 = 0;
  *(_WORD *)a5 = 0;
  Str1 = a1;
  if ( RtlQueryEnvironmentVariable(0, &v14, 13, a1, a2, &v9) >= 0
    && v9 + 1 < a2
    && (v5 = 1, SbGetContextDetailsByName(Str1, (int)&v13)) )
  {
    v7 = v13;
    v8 = v10;
    *(_WORD *)a4 = *(_WORD *)(v13 + 20);
    *(_WORD *)v8 = *(_WORD *)(v7 + 22);
    *(_DWORD *)v11 = v7 + 4;
  }
  else
  {
    v5 = 0;
  }
  return v5;
}
// 77DE1010: using guessed type int __stdcall RtlQueryEnvironmentVariable(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E330BC: using guessed type wchar_t aSb_virtual_os[14];

//----- (77E330DD) --------------------------------------------------------
signed int __stdcall BasepPrepareSwitchContext(int a1)
{
  signed int v1; // ebx@1
  int v3; // [sp+8h] [bp-10h]@1
  int v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+10h] [bp-8h]@1
  int v6; // [sp+14h] [bp-4h]@1

  v1 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 12) )
    {
      v3 = RtlDecodeSystemPointer(dword_77EA6070);
      v4 = RtlDecodeSystemPointer(dword_77EA6074);
      v5 = RtlDecodeSystemPointer(dword_77EA6078);
      v6 = RtlDecodeSystemPointer(dword_77EA607C);
    }
    if ( SbPrepareSwitchContext(a1, (ULONG)&v3) >= 0 )
      v1 = 1;
  }
  return v1;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E33122) --------------------------------------------------------
NTSTATUS __stdcall SbPrepareSwitchContext(int a1, ULONG a2)
{
  int v2; // eax@2
  NTSTATUS result; // eax@5
  signed int v4; // ebx@6
  unsigned __int16 v5; // cx@9
  unsigned __int16 v6; // ax@9
  int v7; // eax@12
  int v8; // eax@18
  int v9; // [sp+Ch] [bp-174h]@1
  int v10; // [sp+10h] [bp-170h]@1
  int v11; // [sp+14h] [bp-16Ch]@1
  int v12; // [sp+18h] [bp-168h]@1
  int v13; // [sp+1Ch] [bp-164h]@1
  struct _OSVERSIONINFOW VersionInformation; // [sp+20h] [bp-160h]@1
  char v15; // [sp+13Ch] [bp-44h]@6

  VersionInformation.dwOSVersionInfoSize = 0;
  memset(&VersionInformation.dwMajorVersion, 0, 0x118u);
  v12 = 0;
  v10 = 0;
  v9 = 0;
  v13 = 0;
  v11 = 0;
  if ( a1 && (v2 = *(_DWORD *)(a1 + 4)) != 0 && v2 != -1 )
  {
    if ( v7FFE03CC & 1 )
    {
      result = RtlGetVersion(&VersionInformation);
      if ( result >= 0 )
      {
        v4 = SbpDeriveVirtualOsVersionBasedOnEnvionmentVariable((wchar_t *)&v15, 0x20u, (int)&v12, (int)&v10, (int)&v9);
        if ( v4
          || *(_WORD *)(a1 + 16) != VersionInformation.dwMajorVersion
          || *(_WORD *)(a1 + 18) != VersionInformation.dwMinorVersion )
        {
          v7 = *(_DWORD *)(a1 + 24);
          if ( *(_WORD *)v7
            && (*(_WORD *)v7 == -1 ? (v8 = SbpDeriveVirtualOsVersionBasedOnManifest(
                                             *(HANDLE *)a1,
                                             (int)&VersionInformation,
                                             (int)&v13,
                                             (int)&v11,
                                             v4 != 0 ? v12 : 0)) : (v8 = SbpDeriveVirtualOsVersionOnFastPath(
                                                                           v7,
                                                                           (int)&VersionInformation,
                                                                           (int)&v13,
                                                                           (int)&v11,
                                                                           (const void *)(v4 != 0 ? v12 : 0))),
                v8) )
          {
            v6 = v11;
            v5 = v13;
          }
          else if ( v4 )
          {
            v5 = v10;
            v6 = v9;
          }
          else
          {
            v5 = *(_WORD *)(a1 + 16);
            v6 = *(_WORD *)(a1 + 18);
          }
        }
        else
        {
          v5 = LOWORD(VersionInformation.dwMajorVersion);
          v6 = LOWORD(VersionInformation.dwMinorVersion);
        }
        result = SbpCreateSwitchContext(a1, v5, v6, a2);
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E33237) --------------------------------------------------------
NTSTATUS __stdcall SbpCreateSwitchContext(int a1, unsigned __int16 a2, unsigned __int16 a3, ULONG a4)
{
  int v4; // eax@22
  unsigned __int16 v5; // ax@1
  int v6; // esi@4
  int v7; // eax@5
  int v8; // esi@5
  unsigned int v9; // eax@7
  signed int v10; // eax@11
  PVOID v11; // esi@11
  char *v12; // edi@11
  __int64 Buffer; // [sp+Ch] [bp-24Ch]@1
  int v15; // [sp+14h] [bp-244h]@1
  int v16; // [sp+18h] [bp-240h]@11
  int v17; // [sp+1Ch] [bp-23Ch]@11
  int v18; // [sp+20h] [bp-238h]@11
  int v19; // [sp+24h] [bp-234h]@11
  int v20; // [sp+2Ch] [bp-22Ch]@1
  ULONG AllocationSize; // [sp+30h] [bp-228h]@1
  int v22; // [sp+34h] [bp-224h]@1
  unsigned __int32 v23; // [sp+38h] [bp-220h]@1
  int v24; // [sp+3Ch] [bp-21Ch]@1
  int v25; // [sp+40h] [bp-218h]@1
  ULONG v26; // [sp+44h] [bp-214h]@1
  PVOID BaseAddress; // [sp+48h] [bp-210h]@1
  ULONG BufferLength; // [sp+4Ch] [bp-20Ch]@1
  NTSTATUS v29; // [sp+50h] [bp-208h]@1
  PVOID Address; // [sp+54h] [bp-204h]@1
  int v31; // [sp+58h] [bp-200h]@1
  char v32; // [sp+5Ch] [bp-1FCh]@1
  int v33; // [sp+220h] [bp-38h]@1
  char Dst; // [sp+224h] [bp-34h]@1
  int v35; // [sp+228h] [bp-30h]@5
  int v36; // [sp+22Ch] [bp-2Ch]@5

  v26 = a4;
  v29 = -1073741823;
  BufferLength = 0;
  v23 = 0;
  AllocationSize = 0;
  BaseAddress = 0;
  v33 = 0;
  memset(&Dst, 0, 0x30u);
  Buffer = 0i64;
  memset(&v15, 0, 0x18u);
  Address = 0;
  v25 = 0;
  v31 = 0;
  memset(&v32, 0, 0x1C4u);
  v20 = *(_DWORD *)(a1 + 8);
  v24 = 0;
  v22 = 0;
  SbGetContextDetailsById(1, (int)&v24);
  SbGetContextDetailsById(0, (int)&v22);
  v5 = *(_WORD *)(v24 + 20);
  if ( a2 <= v5 && (a2 != v5 || a3 < *(_WORD *)(v24 + 22)) )
    v6 = v22 + 4;
  else
    v6 = v24 + 4;
  v7 = *(_DWORD *)(a1 + 12);
  v33 = *(_DWORD *)v6;
  v8 = v6 + 4;
  *(_DWORD *)&Dst = *(_DWORD *)v8;
  v8 += 4;
  v35 = *(_DWORD *)v8;
  v36 = *(_DWORD *)(v8 + 4);
  if ( !v7 )
  {
    Address = &v33;
LABEL_7:
    v9 = *((_DWORD *)Address + 8);
    if ( (v9 <= 1 || ULongLongToULong(16i64 * (v9 - 1), &BufferLength) >= 0)
      && ULongAdd(BufferLength, 0x58u, &v23) >= 0
      && ULongAdd(BufferLength, 0x34u, &BufferLength) >= 0 )
    {
      AllocationSize = v23;
      v29 = NtAllocateVirtualMemory(*(HANDLE *)(a1 + 4), &BaseAddress, 0, &AllocationSize, 0x1000u, 4u);
      if ( v29 >= 0 )
      {
        ++Buffer;
        v10 = SbpIsTraceEnabled();
        v17 = 0;
        v18 = 0;
        v11 = Address;
        v16 = v10;
        v19 = *(_DWORD *)(a1 + 20);
        v12 = (char *)Address + 16;
        *(_DWORD *)v12 = *(_DWORD *)Address;
        v11 = (char *)v11 + 4;
        v12 += 4;
        *(_DWORD *)v12 = *(_DWORD *)v11;
        v11 = (char *)v11 + 4;
        v12 += 4;
        *(_DWORD *)v12 = *(_DWORD *)v11;
        *((_DWORD *)v12 + 1) = *((_DWORD *)v11 + 1);
        v15 = 1;
        v29 = NtWriteVirtualMemory(*(HANDLE *)(a1 + 4), BaseAddress, &Buffer, 0x20u, 0);
        if ( v29 >= 0 )
        {
          v29 = NtWriteVirtualMemory(*(HANDLE *)(a1 + 4), (char *)BaseAddress + 32, Address, BufferLength, 0);
          if ( v29 >= 0 )
          {
            v29 = NtWriteVirtualMemory(*(HANDLE *)(a1 + 4), (PVOID)(v20 + 568), &BaseAddress, 4u, 0);
            if ( v29 >= 0 )
              *(_DWORD *)(a1 + 28) = BaseAddress;
          }
        }
      }
    }
    goto LABEL_15;
  }
  v4 = SbpGetShimData(v7, *(_DWORD *)a1, &v31, v26);
  v25 = v4;
  if ( !v4 )
    return v29;
  if ( SbpMergeApphackContexts(v4, (int)&v31, (int)&v33, (int)&Address, v26) )
    goto LABEL_7;
LABEL_15:
  if ( v25 )
    (*(void (__stdcall **)(int))(v26 + 4))(v25);
  if ( Address && Address != &v33 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v29;
}

//----- (77E334C6) --------------------------------------------------------
signed int __stdcall ULongAdd(unsigned __int32 a1, unsigned __int32 a2, unsigned __int32 *a3)
{
  signed int result; // eax@2

  if ( a1 + a2 < a1 )
  {
    *a3 = -1;
    result = -2147024362;
  }
  else
  {
    *a3 = a1 + a2;
    result = 0;
  }
  return result;
}

//----- (77E334EB) --------------------------------------------------------
int __stdcall BasepGetAppCompatData(LONG_PTR lParam, int a2, int a3, int a4, int a5, int a6, char a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  int v14; // ebx@1
  int v15; // edx@2
  int v16; // ecx@2
  void *v17; // ecx@2
  int v18; // eax@5
  int result; // eax@6
  int v20; // [sp+8h] [bp-10h]@1
  int v21; // [sp+Ch] [bp-Ch]@1
  int v22; // [sp+10h] [bp-8h]@1
  int v23; // [sp+14h] [bp-4h]@1

  v14 = 0;
  v23 = 1;
  v20 = 0;
  v22 = 0;
  v21 = 6;
  if ( IsShimInfrastructureDisabled() )
    goto LABEL_16;
  BasepGetExeType(a8, a9, a10, (int)&v22);
  if ( CheckElevationEnabled(v16, v15, (int)&v23) || !v23 )
  {
    *(_DWORD *)a2 = 2;
    BaseCheckDetectionMethods(lParam, a2, a3, a5, a6, a7, 1, (int)&v20, (int)&v21);
  }
  if ( *(_BYTE *)a2 & 4 )
    v14 = 1;
  v18 = BaseGenerateAppCompatData(v17, v22, v14, a11, a12, a13, a14);
  if ( v18 >= 0 )
  {
LABEL_16:
    result = 1;
  }
  else
  {
    if ( v18 == -1073741790 )
      RtlSetLastWin32Error(1223);
    else
      BaseSetLastNTError(v18);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E33577) --------------------------------------------------------
int __thiscall BaseGenerateAppCompatData(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  void *v8; // [sp+0h] [bp-4h]@1

  v8 = this;
  if ( BasepGetApphelpCreateAppcompatDataProc((int)&v8) >= 0 )
    ((void (__stdcall *)(int, int, int, int, int, int))v8)(a2, a3, a4, a5, a6, a7);
  return 0;
}

//----- (77E335AA) --------------------------------------------------------
NTSTATUS __stdcall BasepGetApphelpCreateAppcompatDataProc(int a1)
{
  NTSTATUS result; // eax@1
  int v2; // eax@2

  result = sub_77E32826();
  if ( result >= 0 )
  {
    v2 = RtlDecodeSystemPointer(dword_77EA606C);
    *(_DWORD *)a1 = v2;
    if ( v2 )
      result = 0;
    else
      result = -1073741823;
  }
  return result;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E335DF) --------------------------------------------------------
signed int __stdcall SbGetContextDetailsById(signed int a1, int a2)
{
  signed int result; // eax@1

  result = 0;
  if ( a1 < 2 )
  {
    *(_DWORD *)a2 = &SbSupportedOsList[7 * a1];
    result = 1;
  }
  return result;
}
// 77E33604: using guessed type int SbSupportedOsList[];

//----- (77E33679) --------------------------------------------------------
unsigned int __stdcall BaseCheckElevation(HANDLE ProcessHandle, LONG_PTR lParam, int a3, int a4, char a5, int a6, int a7, char a8, int a9, int a10, int a11)
{
  int v11; // esi@1
  int v12; // edi@1
  int v13; // eax@1
  unsigned int v14; // eax@2
  void *v15; // ecx@6
  NTSTATUS v17; // eax@23
  int v18; // [sp+Ch] [bp-14h]@1
  HANDLE v19; // [sp+10h] [bp-10h]@1
  int v20; // [sp+14h] [bp-Ch]@1
  HANDLE Handle; // [sp+18h] [bp-8h]@1
  unsigned int v22; // [sp+1Ch] [bp-4h]@1

  v20 = 0;
  Handle = 0;
  v19 = 0;
  v11 = 1;
  v12 = 1;
  v18 = 6;
  v13 = RtlQueryElevationFlags(&v22);
  if ( v13 < 0 )
  {
    v22 = v13;
  }
  else
  {
    v14 = (v22 >> 2) & 1;
    v11 = v22 & 1;
    v22 = 0;
    v12 = v14;
  }
  if ( (v22 & 0x80000000) == 0 && v11 )
  {
    *(_DWORD *)a3 |= 2u;
    if ( a5 & 2 )
      *(_DWORD *)a3 |= 8u;
    v22 = BaseCheckDetectionMethods(lParam, a3, a4, a6, a7, a8, v12, (int)&v20, (int)&v18);
    if ( (v22 & 0x80000000) == 0 )
    {
      if ( a5 & 1 )
        *(_DWORD *)a3 &= 0xFFFFFFFD;
      if ( a5 & 4 && !v20 )
        v20 = 1;
      if ( *(_BYTE *)a3 & 1 && v20 )
      {
        if ( a9 )
        {
          Handle = (HANDLE)a9;
LABEL_24:
          v22 = BasepCheckForElevatedCaller(v15, Handle, a3, (int)&v20);
          goto LABEL_11;
        }
        v17 = NtOpenProcessToken(ProcessHandle, 8u, &Handle);
        v22 = v17;
        if ( v17 >= 0 )
          goto LABEL_24;
        if ( v17 == -1073741790 )
        {
          if ( BaseRevertToSelf((int)&v19) < 0 || !v19 )
            goto LABEL_35;
          v22 = NtOpenProcessToken(ProcessHandle, 8u, &Handle);
          BaseRestoreImpersonation((int)v19);
        }
        if ( (v22 & 0x80000000) == 0 )
          goto LABEL_24;
LABEL_35:
        Handle = 0;
        goto LABEL_11;
      }
    }
  }
LABEL_11:
  if ( v19 )
    NtClose(v19);
  if ( Handle && Handle != (HANDLE)a9 )
    NtClose(Handle);
  if ( a10 )
    *(_DWORD *)a10 = v20;
  if ( a11 )
    *(_DWORD *)a11 = v18;
  return v22;
}
// 77DE1448: using guessed type int __stdcall RtlQueryElevationFlags(_DWORD);

//----- (77E33763) --------------------------------------------------------
int __stdcall BaseCheckDetectionMethods(LONG_PTR lParam, int a2, int a3, int a4, int a5, char a6, int a7, int a8, int a9)
{
  unsigned int v10; // ecx@11
  int v11; // [sp+8h] [bp-8h]@1
  unsigned int v12; // [sp+Ch] [bp-4h]@1

  v11 = 0;
  v12 = 0;
  if ( a3 )
  {
    v10 = 0;
    while ( v10 >= 3 && v10 - 16 > 2 || !((1 << v10) & a3) )
    {
      ++v10;
      if ( v10 >= 0x13 )
        goto LABEL_2;
    }
    v12 = v10;
    goto LABEL_18;
  }
LABEL_2:
  a3 = 0;
  BasepConvertFusionRunLevel(a4, (int)&v12, (int)&a3);
  if ( a3 )
  {
    *(_DWORD *)a9 = 2;
    *(_DWORD *)a2 &= 0xFFFFFFF5;
    goto LABEL_4;
  }
  if ( !a7 )
    goto LABEL_4;
  if ( a6 & 6 )
  {
    if ( a6 & 2 )
    {
      *(_DWORD *)a2 |= 4u;
      v12 = 2;
    }
LABEL_18:
    *(_DWORD *)a9 = 0;
    goto LABEL_4;
  }
  if ( a6 & 1 )
  {
    *(_DWORD *)a9 = 1;
    goto LABEL_22;
  }
  v11 = InstallDetect(lParam, a5, (int)&a3);
  if ( v11 >= 0 && a3 )
  {
    *(_DWORD *)a9 = 3;
LABEL_22:
    *(_DWORD *)a2 |= 4u;
    v12 = 2;
  }
LABEL_4:
  *(_DWORD *)a8 = v12;
  return v11;
}

//----- (77E337BF) --------------------------------------------------------
int __stdcall BasepConvertFusionRunLevel(int a1, int a2, int a3)
{
  int result; // eax@2
  unsigned int v4; // ecx@9

  *(_DWORD *)a3 = 0;
  if ( *(_DWORD *)(a1 + 4) == 1 )
  {
    result = a2;
    *(_DWORD *)a2 = 0;
  }
  else if ( *(_DWORD *)(a1 + 4) == 2 )
  {
    result = a2;
    *(_DWORD *)a2 = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 4) - 3;
    if ( *(_DWORD *)(a1 + 4) != 3 )
      return result;
    result = a2;
    *(_DWORD *)a2 = 2;
  }
  if ( *(_DWORD *)(a1 + 8) )
  {
    v4 = *(_DWORD *)result;
    if ( *(_DWORD *)result < 0x10u || v4 >= 0x13 )
      v4 += 16;
    *(_DWORD *)result = v4;
  }
  *(_DWORD *)a3 = 1;
  return result;
}

//----- (77E337F8) --------------------------------------------------------
NTSTATUS __stdcall BaseElevationPostProcessing(char a1, int ProcessInformation, HANDLE ProcessHandle)
{
  NTSTATUS result; // eax@1

  result = 0;
  if ( a1 & 2 && (!(_WORD)ProcessInformation || (_WORD)ProcessInformation == 10) )
  {
    ProcessInformation = 1;
    result = NtSetInformationProcess(ProcessHandle, ProcessTokenVirtualizationEnabled, &ProcessInformation, 4u);
  }
  return result;
}

//----- (77E3387B) --------------------------------------------------------
int __stdcall BasepCheckCacheExcludeCustom(PCWSTR SourceString)
{
  PVOID v1; // esi@4
  __int16 v2; // ax@6
  int v3; // eax@6
  unsigned __int16 v4; // ax@8
  __int16 v5; // cx@8
  NTSTATUS v6; // eax@8
  NTSTATUS v8; // eax@21
  LSA_UNICODE_STRING UnicodeString; // [sp+Ch] [bp-270h]@28
  __int16 v10; // [sp+14h] [bp-268h]@1
  __int16 v11; // [sp+16h] [bp-266h]@1
  int v12; // [sp+18h] [bp-264h]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+1Ch] [bp-260h]@8
  HANDLE KeyHandle; // [sp+34h] [bp-248h]@1
  int v15; // [sp+38h] [bp-244h]@1
  int v16; // [sp+3Ch] [bp-240h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+40h] [bp-23Ch]@1
  HANDLE Handle; // [sp+48h] [bp-234h]@1
  int v19; // [sp+4Ch] [bp-230h]@1
  __int16 *v20; // [sp+50h] [bp-22Ch]@6
  WCHAR *v21; // [sp+54h] [bp-228h]@6
  __int16 *v22; // [sp+58h] [bp-224h]@6
  unsigned int v23; // [sp+5Ch] [bp-220h]@6
  int v24; // [sp+60h] [bp-21Ch]@6
  __int16 v25; // [sp+6Eh] [bp-20Eh]@1
  __int16 Dst; // [sp+70h] [bp-20Ch]@6

  LOWORD(v19) = 0;
  memset((char *)&v19 + 2, 0, 0x20u);
  v25 = 0;
  v10 = 4;
  v11 = 6;
  v12 = (int)L"\\/";
  KeyHandle = 0;
  v15 = 0;
  Handle = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  if ( RtlFindCharInUnicodeString(1, &DestinationString, &v10, &v16) >= 0
    && (unsigned int)(unsigned __int16)v16 + 2 < DestinationString.Length )
  {
    DestinationString.Buffer += ((unsigned int)(unsigned __int16)v16 >> 1) + 1;
    DestinationString.Length += -2 - v16;
    DestinationString.MaximumLength += -2 - v16;
  }
  v1 = NtCurrentTeb()[1].Reserved1[1];
  Handle = (HANDLE)dword_77EA6778;
  if ( v1 || !dword_77EA6778 )
  {
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&o_1_a_87_s_0_tpsig2_8;
    v8 = NtOpenKey(&Handle, 8u, &ObjectAttributes);
    if ( v8 < 0 )
    {
      Handle = 0;
      v15 = v8 == -1073741772;
      goto LABEL_12;
    }
    if ( !v1 && InterlockedCompareExchange(&dword_77EA6778, (LONG)Handle, 0) )
    {
      NtClose(Handle);
      Handle = (HANDLE)dword_77EA6778;
    }
  }
  v21 = (WCHAR *)&Dst;
  v23 = 520;
  v24 = 520;
  v19 = 34078720;
  v22 = &Dst;
  Dst = 0;
  v20 = &Dst;
  _memmove(&Dst, L"Custom\\", 0xEu);
  v2 = v19;
  LOWORD(v19) = v19 + 14;
  HIWORD(v19) = v2 + 16;
  v20[(unsigned int)(unsigned __int16)v19 >> 1] = 0;
  v3 = DestinationString.Length + (unsigned __int16)v19 + 2;
  if ( (unsigned int)v3 <= 0xFFFE
    && (v3 <= v23 || RtlpEnsureBufferSize(0, &v21, DestinationString.Length + (unsigned __int16)v19 + 2) >= 0) )
  {
    v20 = (__int16 *)v21;
    _memmove(&v21[(unsigned int)(unsigned __int16)v19 >> 1], DestinationString.Buffer, DestinationString.Length);
    v4 = DestinationString.Length + v19;
    v5 = DestinationString.Length + v19 + 2;
    LOWORD(v19) = v4;
    HIWORD(v19) = v5;
    v20[(unsigned int)v4 >> 1] = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    ObjectAttributes.RootDirectory = Handle;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v19;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    v6 = NtOpenKey(&KeyHandle, 0x101u, &ObjectAttributes);
    if ( v6 < 0 )
      v15 = v6 == -1073741772;
  }
  if ( Handle && Handle != (HANDLE)dword_77EA6778 )
    NtClose(Handle);
LABEL_12:
  if ( KeyHandle )
    NtClose(KeyHandle);
  if ( v21 && (__int16 *)v21 != v22 )
  {
    UnicodeString.Buffer = v21;
    RtlFreeUnicodeString(&UnicodeString);
  }
  if ( v22 )
    *v22 = 0;
  return v15;
}
// 77DE1144: using guessed type int __stdcall RtlFindCharInUnicodeString(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1184: using guessed type int __stdcall RtlpEnsureBufferSize(_DWORD, _DWORD, _DWORD);
// 77E33B54: using guessed type wchar_t aCustom[8];
// 77E34050: using guessed type int o_1_a_87_s_0_tpsig2_8;

//----- (77E33B69) --------------------------------------------------------
int __stdcall BasepCheckCacheExcludeList(const WCHAR *a1)
{
  PVOID v1; // ecx@1
  NTSTATUS v2; // eax@3
  WCHAR *v3; // eax@8
  int v5; // eax@19
  unsigned __int16 v6; // ax@21
  __int16 v7; // cx@21
  int v8; // eax@21
  __int16 v9; // ax@23
  NTSTATUS v10; // eax@23
  int v11; // eax@35
  USHORT v12; // cx@38
  LSA_UNICODE_STRING v13; // [sp+Ch] [bp-4BCh]@42
  ULONG ResultLength; // [sp+14h] [bp-4B4h]@39
  LSA_UNICODE_STRING v15; // [sp+18h] [bp-4B0h]@41
  PCWSTR SourceString; // [sp+20h] [bp-4A8h]@1
  PVOID v17; // [sp+24h] [bp-4A4h]@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+28h] [bp-4A0h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+40h] [bp-488h]@35
  LSA_UNICODE_STRING UnicodeString; // [sp+48h] [bp-480h]@1
  int v21; // [sp+50h] [bp-478h]@1
  HANDLE KeyHandle; // [sp+54h] [bp-474h]@1
  HANDLE Handle; // [sp+58h] [bp-470h]@1
  char KeyValueInformation; // [sp+5Ch] [bp-46Ch]@39
  LSA_UNICODE_STRING ValueName; // [sp+6Ch] [bp-45Ch]@1
  WCHAR *v26; // [sp+74h] [bp-454h]@1
  __int16 *v27; // [sp+78h] [bp-450h]@1
  unsigned int v28; // [sp+7Ch] [bp-44Ch]@1
  int v29; // [sp+80h] [bp-448h]@1
  int v30; // [sp+90h] [bp-438h]@1
  __int16 *v31; // [sp+94h] [bp-434h]@1
  WCHAR *v32; // [sp+98h] [bp-430h]@1
  __int16 *v33; // [sp+9Ch] [bp-42Ch]@1
  unsigned int v34; // [sp+A0h] [bp-428h]@1
  int v35; // [sp+A4h] [bp-424h]@1
  __int16 v36; // [sp+B4h] [bp-414h]@1
  __int16 v37; // [sp+2BCh] [bp-20Ch]@1

  SourceString = a1;
  UnicodeString.Length = 0;
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  v27 = &v36;
  ValueName.Buffer = (PWCH)&v36;
  v26 = (WCHAR *)&v36;
  v36 = 0;
  ValueName.Length = 0;
  ValueName.MaximumLength = 520;
  v28 = 520;
  v29 = 520;
  v32 = (WCHAR *)&v37;
  v34 = 520;
  v33 = &v37;
  v35 = 520;
  v31 = &v37;
  Handle = 0;
  KeyHandle = 0;
  v37 = 0;
  v30 = 34078720;
  v1 = NtCurrentTeb()[1].Reserved1[1];
  v21 = 0;
  v17 = v1;
  Handle = (HANDLE)Destination;
  if ( !v1 && Destination )
  {
LABEL_3:
    ObjectAttributes.RootDirectory = Handle;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E33D98;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v2 = NtOpenKey(&KeyHandle, 0x101u, &ObjectAttributes);
    if ( v2 >= 0 )
    {
      RtlInitUnicodeString(&DestinationString, SourceString);
      ValueName.Length = 0;
      v11 = DestinationString.Length + 2;
      if ( (unsigned int)v11 <= 0xFFFE
        && (v11 <= v28 || RtlpEnsureBufferSize(0, &v26, DestinationString.Length + 2) >= 0) )
      {
        ValueName.Buffer = v26;
        _memmove(&v26[(unsigned int)ValueName.Length >> 1], DestinationString.Buffer, DestinationString.Length);
        v12 = ValueName.Length + DestinationString.Length + 2;
        ValueName.Length += DestinationString.Length;
        ValueName.MaximumLength = v12;
        ValueName.Buffer[(unsigned int)ValueName.Length >> 1] = 0;
        if ( RtlNtPathNameToDosPathName(0, &ValueName, 0, 0) >= 0 )
          v21 = NtQueryValueKey(
                  KeyHandle,
                  &ValueName,
                  KeyValuePartialInformation,
                  &KeyValueInformation,
                  0x10u,
                  &ResultLength) == -1073741772;
      }
    }
    else
    {
      KeyHandle = 0;
      v21 = v2 == -1073741772;
    }
    goto LABEL_5;
  }
  if ( RtlFormatCurrentUserKeyPath(&UnicodeString) >= 0 )
  {
    LOWORD(v30) = 0;
    v5 = UnicodeString.Length + 2;
    if ( (unsigned int)v5 <= 0xFFFE && (v5 <= v34 || RtlpEnsureBufferSize(0, &v32, UnicodeString.Length + 2) >= 0) )
    {
      v31 = (__int16 *)v32;
      _memmove(&v32[(unsigned int)(unsigned __int16)v30 >> 1], UnicodeString.Buffer, UnicodeString.Length);
      v6 = UnicodeString.Length + v30;
      v7 = UnicodeString.Length + v30 + 2;
      LOWORD(v30) = v6;
      HIWORD(v30) = v7;
      v31[(unsigned int)v6 >> 1] = 0;
      v8 = (unsigned __int16)v30 + 92;
      if ( (unsigned int)v8 <= 0xFFFE && (v8 <= v34 || RtlpEnsureBufferSize(0, &v32, (unsigned __int16)v30 + 92) >= 0) )
      {
        v31 = (__int16 *)v32;
        _memmove(
          &v32[(unsigned int)(unsigned __int16)v30 >> 1],
          L"\\Software\\Microsoft\\Windows NT\\CurrentVersion",
          0x5Au);
        v9 = v30;
        LOWORD(v30) = v30 + 90;
        HIWORD(v30) = v9 + 92;
        v31[(unsigned int)(unsigned __int16)v30 >> 1] = 0;
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&v30;
        ObjectAttributes.Length = 24;
        ObjectAttributes.RootDirectory = 0;
        ObjectAttributes.Attributes = 64;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        v10 = NtOpenKey(&Handle, 8u, &ObjectAttributes);
        if ( v10 < 0 )
        {
          Handle = 0;
          v21 = v10 == -1073741772;
          goto LABEL_7;
        }
        if ( !v17 && InterlockedCompareExchange(&Destination, (LONG)Handle, 0) )
        {
          NtClose(Handle);
          Handle = (HANDLE)Destination;
        }
        goto LABEL_3;
      }
    }
  }
LABEL_5:
  if ( Handle && Handle != (HANDLE)Destination )
    NtClose(Handle);
LABEL_7:
  if ( KeyHandle )
    NtClose(KeyHandle);
  RtlFreeUnicodeString(&UnicodeString);
  v3 = (WCHAR *)v27;
  if ( v26 )
  {
    if ( (__int16 *)v26 != v27 )
    {
      v15.Buffer = v26;
      RtlFreeUnicodeString(&v15);
      v3 = (WCHAR *)v27;
    }
    v26 = v3;
    v28 = v29;
  }
  ValueName.Buffer = v3;
  if ( v3 )
    *v3 = 0;
  ValueName.Length = 0;
  ValueName.MaximumLength = v29;
  if ( v32 && (__int16 *)v32 != v33 )
  {
    v13.Buffer = v32;
    RtlFreeUnicodeString(&v13);
  }
  if ( v33 )
    *v33 = 0;
  return v21;
}
// 77DE1148: using guessed type int __stdcall RtlNtPathNameToDosPathName(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1184: using guessed type int __stdcall RtlpEnsureBufferSize(_DWORD, _DWORD, _DWORD);
// 77DE148C: using guessed type int __stdcall RtlFormatCurrentUserKeyPath(_DWORD);
// 77E33D98: using guessed type int dword_77E33D98;
// 77E33F68: using guessed type wchar_t aSoftwareMicros[46];

//----- (77E34104) --------------------------------------------------------
HANDLE __stdcall FindFirstFileWStub(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
{
  return FindFirstFileW(lpFileName, lpFindFileData);
}

//----- (77E34BD7) --------------------------------------------------------
NTSTATUS __stdcall ConsoleClientCallServer(PPORT_MESSAGE RequestMessage, int a2, int a3, int a4)
{
  NTSTATUS result; // eax@3
  int v5; // edx@7
  int v6; // ecx@7
  int v7; // eax@9
  int v8; // edx@11
  int v9; // edi@11
  int v10; // ecx@13
  char *v11; // ecx@14

  if ( ConsoleLpcHandle )
  {
    *(_DWORD *)&RequestMessage->MessageType = 0;
    *(_DWORD *)&RequestMessage[1].DataSize = 0;
    *(_DWORD *)&RequestMessage->DataSize = (a4 | (a4 << 16)) + 2883600;
    *(_DWORD *)&RequestMessage[1].MessageType = a3;
    if ( a2 )
    {
      *(_DWORD *)&RequestMessage[1].DataSize = a2 + ConsolePortMemoryRemoteDelta;
      *(_DWORD *)(a2 + 12) = 0;
      v5 = *(_DWORD *)(a2 + 8);
      v6 = a2 + 16;
      while ( v5 )
      {
        v7 = *(_DWORD *)v6;
        --v5;
        v6 += 4;
        if ( v7 )
        {
          *(_DWORD *)v7 += ConsolePortMemoryRemoteDelta;
          *(_DWORD *)(v6 - 4) = v7 - (_DWORD)RequestMessage;
        }
      }
    }
    result = NtRequestWaitReplyPort(ConsoleLpcHandle, RequestMessage, RequestMessage);
    if ( a2 )
    {
      *(_DWORD *)&RequestMessage[1].DataSize -= ConsolePortMemoryRemoteDelta;
      v8 = a2 + 16;
      v9 = *(_DWORD *)(a2 + 8);
      while ( v9 )
      {
        v10 = *(_DWORD *)v8;
        --v9;
        v8 += 4;
        if ( v10 )
        {
          v11 = (char *)RequestMessage + v10;
          *(_DWORD *)(v8 - 4) = v11;
          *(_DWORD *)v11 -= ConsolePortMemoryRemoteDelta;
        }
      }
    }
    if ( result < 0 )
      RequestMessage[1].ClientId.UniqueProcess = (HANDLE)result;
  }
  else
  {
    result = -1073741816;
    RequestMessage[1].ClientId.UniqueProcess = (HANDLE)-1073741816;
  }
  return result;
}
// 77EA6584: using guessed type int ConsolePortMemoryRemoteDelta;

//----- (77E34C42) --------------------------------------------------------
signed int __fastcall SetTEBLangID(int a1)
{
  signed int result; // eax@1
  int v2; // [sp+0h] [bp-4h]@1

  v2 = a1;
  result = GetConsoleLangId((int)&v2);
  if ( result )
    result = SetThreadLocale((unsigned __int16)v2);
  return result;
}

//----- (77E34C60) --------------------------------------------------------
signed int __stdcall GetConsoleLangId(int a1)
{
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  int v3; // [sp+24h] [bp-84h]@1
  __int16 v4; // [sp+2Ch] [bp-7Ch]@4

  ConsoleClientCallServer(&RequestMessage, 0, 76, 2);
  if ( v3 >= 0 )
  {
    *(_WORD *)a1 = v4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E34CCC) --------------------------------------------------------
DWORD __stdcall GetFileAttributesWStub(LPCWSTR lpFileName)
{
  return GetFileAttributesW(lpFileName);
}

//----- (77E34CDC) --------------------------------------------------------
BOOL __stdcall FindCloseStub(HANDLE hFindFile)
{
  return FindClose(hFindFile);
}

//----- (77E34CE9) --------------------------------------------------------
DWORD __stdcall GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
{
  int v3; // eax@35
  PVOID v4; // eax@35
  PWSTR v5; // eax@3
  unsigned int v6; // kr04_4@6
  int v7; // eax@6
  int v8; // esi@6
  const WCHAR *v9; // eax@6
  const WCHAR *v10; // ebx@6
  int v11; // ebx@7
  const void *v12; // edi@12
  signed int v13; // eax@14
  int v14; // esi@17
  __int16 v15; // si@18
  HANDLE v16; // eax@18
  int v17; // eax@19
  int v18; // esi@23
  unsigned int v19; // eax@38
  DWORD v21; // eax@51
  UINT uMode; // [sp+18h] [bp-298h]@2
  PVOID Address; // [sp+20h] [bp-290h]@1
  int v24; // [sp+28h] [bp-288h]@5
  void *v25; // [sp+2Ch] [bp-284h]@13
  void *Src; // [sp+30h] [bp-280h]@1
  LPCWSTR lpFileName; // [sp+34h] [bp-27Ch]@1
  void *v28; // [sp+38h] [bp-278h]@5
  void *v29; // [sp+3Ch] [bp-274h]@7
  DWORD v30; // [sp+40h] [bp-270h]@1
  struct _WIN32_FIND_DATAW FindFileData; // [sp+44h] [bp-26Ch]@18
  CPPEH_RECORD ms_exc; // [sp+298h] [bp-18h]@2

  Src = (void *)lpszShortPath;
  v30 = 0;
  Address = 0;
  lpFileName = 0;
  if ( !lpszShortPath )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  uMode = SetErrorMode(0x8001u);
  ms_exc.registration.TryLevel = 0;
  if ( GetFileAttributesW(lpszShortPath) != -1 )
  {
    v5 = SkipPathTypeIndicator_U((PWSTR)lpszShortPath);
    if ( !v5 || !*v5 || !FindLFNorSFN_U(v5, &v28, &v24, 0) )
    {
      v21 = wcslen(lpszShortPath);
      v30 = v21;
      if ( cchBuffer > v21 && lpszLongPath )
      {
        if ( lpszLongPath != lpszShortPath )
          _memmove(lpszLongPath, lpszShortPath, 2 * v21 + 2);
      }
      else
      {
        v30 = v21 + 1;
      }
      goto LABEL_41;
    }
    v6 = wcslen(lpszShortPath);
    v7 = KernelBaseGetGlobalData();
    v8 = 2 * (v6 + 1);
    v9 = (const WCHAR *)RtlAllocateHeap(
                          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                          *(_DWORD *)(v7 + 44) + 0x200000,
                          v8);
    v10 = v9;
    lpFileName = v9;
    if ( !v9 )
      goto LABEL_49;
    _memmove((void *)v9, Src, v8);
    v28 = (void *)&v10[((_BYTE *)v28 - (_BYTE *)Src) >> 1];
    v11 = (int)&v10[(v24 - (signed int)Src) >> 1];
    v24 = v11;
    v29 = lpszLongPath;
    if ( !cchBuffer || !lpszLongPath )
      goto LABEL_12;
    if ( lpszLongPath >= Src )
    {
      if ( (char *)lpszLongPath < (char *)Src + v8 )
      {
LABEL_35:
        v3 = KernelBaseGetGlobalData();
        v4 = RtlAllocateHeap(
               NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
               *(_DWORD *)(v3 + 44) + 0x200000,
               2 * cchBuffer);
        v12 = v4;
        Address = v4;
        if ( v4 )
        {
          v29 = v4;
          v11 = v24;
LABEL_13:
          v25 = (void *)lpFileName;
          while ( 1 )
          {
            v13 = ((_BYTE *)v28 - (_BYTE *)v25) >> 1;
            v30 += v13;
            if ( v13 && cchBuffer > v30 && Src )
            {
              v14 = 2 * v13;
              _memmove(v29, v25, 2 * v13);
              v29 = (char *)v29 + v14;
            }
            v15 = *(_WORD *)v11;
            *(_WORD *)v11 = 0;
            v16 = FindFirstFileW(lpFileName, &FindFileData);
            *(_WORD *)v11 = v15;
            if ( v16 == (HANDLE)-1 )
              break;
            FindClose(v16);
            v17 = wcslen(FindFileData.cFileName);
            if ( v17 )
              v28 = FindFileData.cFileName;
            else
              v17 = (v11 - (signed int)v28) >> 1;
            v30 += v17;
            if ( cchBuffer > v30 && lpszLongPath )
            {
              v18 = 2 * v17;
              _memmove(v29, v28, 2 * v17);
              v29 = (char *)v29 + v18;
            }
            v25 = (void *)v11;
            if ( !*(_WORD *)v11 || !FindLFNorSFN_U(v11, &v28, &v24, 0) )
              goto LABEL_37;
            v11 = v24;
          }
          v30 = 0;
LABEL_37:
          if ( v30 )
          {
            v19 = wcslen((const unsigned __int16 *)v25);
            v30 += v19;
            if ( cchBuffer > v30 && lpszLongPath )
            {
              _memmove(v29, v25, 2 * v19 + 2);
              if ( v12 )
                _memmove(lpszLongPath, v12, 2 * v30 + 2);
            }
            else
            {
              ++v30;
            }
          }
          goto LABEL_41;
        }
LABEL_49:
        RtlSetLastWin32Error(8);
        goto LABEL_41;
      }
      if ( lpszLongPath >= Src )
      {
LABEL_12:
        v12 = 0;
        goto LABEL_13;
      }
    }
    if ( &lpszLongPath[cchBuffer] < Src )
      goto LABEL_12;
    goto LABEL_35;
  }
LABEL_41:
  ms_exc.registration.TryLevel = -2;
  if ( lpFileName )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpFileName);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  SetErrorMode(uMode);
  return v30;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3076A: using guessed type _DWORD __stdcall FindLFNorSFN_U(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E34F99) --------------------------------------------------------
signed int __stdcall IsLongName_U(int a1, signed int a2)
{
  signed int v2; // edx@4
  signed int v3; // eax@4
  int v4; // esi@5
  signed int result; // eax@9

  if ( a2 && a2 <= 12 && 46 != *(_WORD *)a1 )
  {
    v2 = 0;
    v3 = 0;
    if ( a2 > 0 )
    {
      v4 = a2 - 1;
      do
      {
        if ( 46 == *(_WORD *)(a1 + 2 * v3) )
        {
          if ( v2 || v4 > 3 )
            goto LABEL_15;
          v2 = 1;
        }
        if ( v3 >= 8 && !v2 )
          goto LABEL_15;
        ++v3;
        --v4;
      }
      while ( v3 < a2 );
    }
    result = 0;
  }
  else
  {
LABEL_15:
    result = 1;
  }
  return result;
}

//----- (77E34FF9) --------------------------------------------------------
DWORD __stdcall GetLongPathNameWStub(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
{
  return GetLongPathNameW(lpszShortPath, lpszLongPath, cchBuffer);
}

//----- (77E35153) --------------------------------------------------------
UINT __stdcall GetConsoleOutputCP()
{
  ULONG v0; // eax@4
  UINT result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  UINT v4; // [sp+28h] [bp-7Ch]@2
  int v5; // [sp+2Ch] [bp-78h]@1

  v5 = 1;
  ConsoleClientCallServer(&RequestMessage, 0, 60, 8);
  if ( NtStatus < 0 )
  {
    v0 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v0);
    result = 0;
  }
  else
  {
    result = v4;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E351A2) --------------------------------------------------------
HANDLE __stdcall OpenFileMappingWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
  return OpenFileMappingW(dwDesiredAccess, bInheritHandle, lpName);
}

//----- (77E351FE) --------------------------------------------------------
signed int __stdcall SetCtrlHandler(int a1)
{
  SIZE_T v1; // eax@1
  PVOID v2; // esi@4
  ULONG Size; // [sp+4h] [bp-4h]@2

  v1 = HandlerListLength;
  if ( HandlerListLength != AllocatedHandlerListLength )
  {
LABEL_7:
    *((_DWORD *)HandlerList + v1) = a1;
    ++HandlerListLength;
    return 1;
  }
  if ( RtlSIZETAdd(HandlerListLength, 2u, &Size) >= 0 && RtlULongLongToULong(4i64 * Size, &Size) >= 0 )
  {
    v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
    if ( v2 )
    {
      memcpy(v2, HandlerList, 4 * HandlerListLength);
      if ( HandlerList != &SingleHandler )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, HandlerList);
      AllocatedHandlerListLength += 2;
      v1 = HandlerListLength;
      HandlerList = v2;
      goto LABEL_7;
    }
  }
  RtlSetLastWin32Error(8);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6018: using guessed type int AllocatedHandlerListLength;
// 77EA6088: using guessed type int SingleHandler;

//----- (77E352BF) --------------------------------------------------------
NTSTATUS RtlSIZETAdd(SIZE_T Augend, SIZE_T Addend, SIZE_T *pResult)
{
  NTSTATUS result; // eax@2

  if ( Augend + Addend < Augend )
  {
    *pResult = -1;
    result = -1073741675;
  }
  else
  {
    *pResult = Augend + Addend;
    result = 0;
  }
  return result;
}

//----- (77E352E4) --------------------------------------------------------
NTSTATUS RtlULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult)
{
  NTSTATUS result; // eax@2

  if ( ullOperand > 0xFFFFFFFF )
  {
    *pulResult = -1;
    result = -1073741675;
  }
  else
  {
    *pulResult = ullOperand;
    result = 0;
  }
  return result;
}

//----- (77E35311) --------------------------------------------------------
BOOL __stdcall TlsFreeStub(DWORD dwTlsIndex)
{
  return TlsFree(dwTlsIndex);
}

//----- (77E35329) --------------------------------------------------------
DWORD __stdcall GetEnvironmentVariableWStub(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
{
  return GetEnvironmentVariableW(lpName, lpBuffer, nSize);
}

//----- (77E35344) --------------------------------------------------------
int __stdcall LCMapStringWStub(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (77E35351) --------------------------------------------------------
HANDLE __stdcall OpenThreadStub(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
{
  return OpenThread(dwDesiredAccess, bInheritHandle, dwThreadId);
}

//----- (77E353D9) --------------------------------------------------------
int __stdcall lstrcmpWStub(LPCWSTR lpString1, LPCWSTR lpString2)
{
  return lstrcmpW(lpString1, lpString2);
}

//----- (77E353E6) --------------------------------------------------------
BOOL __stdcall GetStringTypeWStub(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
  return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
}

//----- (77E35414) --------------------------------------------------------
signed int __stdcall BasepFindActCtxSection_CheckAndConvertParameters(int a1, int a2, int a3)
{
  signed int v3; // esi@1
  int v4; // ecx@1
  int v6; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v6 = 0;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  if ( !a2 )
    goto LABEL_18;
  if ( !a3 )
    goto LABEL_18;
  v4 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 < 0x24u || a1 & 0xFFFFFFF8 )
    goto LABEL_18;
  if ( a1 & 1 )
  {
    if ( a2 + 36 > (unsigned int)(a2 + v4) )
      goto LABEL_18;
    v3 = 1;
  }
  if ( a1 & 2 )
  {
    if ( a2 + 44 > (unsigned int)(a2 + v4) )
      goto LABEL_18;
    v3 |= 2u;
  }
  if ( a1 & 4 )
  {
    if ( a2 + 64 <= (unsigned int)(a2 + v4) )
    {
      v3 |= 4u;
      goto LABEL_12;
    }
LABEL_18:
    _DbgPrintEx(
      0x33u,
      0,
      "SXS: Invalid parameter(s) passed to FindActCtxSection*()\n   dwFlags = 0x%08lx\n   ReturnedData = %p\n      ->cbSize = %u\n",
      a1,
      a2,
      a2 != 0 ? v4 : 0);
    RtlSetLastWin32Error(87);
    return v6;
  }
LABEL_12:
  *(_DWORD *)a3 = v3;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3555E) --------------------------------------------------------
int __stdcall InstallDetect(LONG_PTR lParam, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@2

  result = -1073741811;
  if ( lParam )
  {
    v4 = a3;
    if ( a3 )
    {
      result = InstallDetectInternal(lParam, a2, 0, (LONG_PTR)&lParam);
      if ( result >= 0 )
        *(_DWORD *)v4 = lParam == 1;
    }
  }
  return result;
}

//----- (77E355A0) --------------------------------------------------------
int __stdcall InstallDetectInternal(int a1, int a2, int a3, LONG_PTR lParam)
{
  int v5; // [sp+10h] [bp-54h]@1
  char Dst; // [sp+14h] [bp-50h]@1
  int v7; // [sp+30h] [bp-34h]@1
  int v8; // [sp+44h] [bp-20h]@8
  int v9; // [sp+48h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@3
  int i; // [sp+6Ch] [bp+8h]@1

  memset(&Dst, 0, 0x34u);
  v9 = -1073741823;
  v5 = a1;
  v7 = -1;
  for ( i = 0; (unsigned int)i < 5; ++i )
  {
    ms_exc.registration.TryLevel = 0;
    if ( (*(&g_Methods + 26 * i))((int)&v5, a2, lParam) >= 0 && *(_DWORD *)lParam )
    {
      if ( a3 )
        *(_DWORD *)a3 = i;
      v9 = 0;
      ms_exc.registration.TryLevel = -2;
      break;
    }
    ms_exc.registration.TryLevel = -2;
  }
  if ( v8 )
    FreeImageInfo((int)&v5);
  return v9;
}
// 77E35610: using guessed type int (__stdcall *g_Methods)(int, int, LONG_PTR lParam);

//----- (77E35839) --------------------------------------------------------
int __stdcall ByteMatch(DWORD a1, int a2, int a3)
{
  int v3; // esi@9
  unsigned int v4; // edi@9
  int v5; // esi@14
  unsigned int v6; // edi@14
  unsigned int v7; // edi@1
  char **v8; // esi@2
  LONG lDistanceToMove; // [sp+8h] [bp-30h]@2
  DWORD NumberOfBytesRead; // [sp+Ch] [bp-2Ch]@1
  int v12; // [sp+10h] [bp-28h]@2
  char Buffer; // [sp+14h] [bp-24h]@8

  v7 = 0;
  NumberOfBytesRead = a1;
  *(_DWORD *)a3 = 0;
  if ( LoadImageFile(a1) )
  {
    lDistanceToMove = 0;
    v12 = 0;
    v8 = &ByteMatchSectionInstallers;
    do
    {
      if ( ByteMatchGetSection(NumberOfBytesRead, *v8, (int)&lDistanceToMove, (int)&v12) >= 0
        && TestByteMatchEntry(lDistanceToMove, v12, (int)v8) )
        goto LABEL_10;
      v7 += 20;
      v8 += 5;
    }
    while ( v7 < 0x14 );
    if ( ByteMatchGetAppendedDataOffset(NumberOfBytesRead, (int)&lDistanceToMove) < 0 )
      return 0;
    if ( ByteMatchGetAppendedData(NumberOfBytesRead, lDistanceToMove, &Buffer, (int)&v12) >= 0 )
    {
      v3 = (int)&ByteMatchAppendedDataInstallers;
      v4 = 0;
      while ( !TestByteMatchEntry((int)&Buffer, v12, v3) )
      {
        v4 += 20;
        v3 += 20;
        if ( v4 >= 0xDC )
          goto LABEL_13;
      }
      goto LABEL_10;
    }
LABEL_13:
    if ( ByteMatchGetEOFData(NumberOfBytesRead, &Buffer, (int)&v12) >= 0 )
    {
      v5 = (int)&ByteMatchEOFInstallers;
      v6 = 0;
      while ( !TestByteMatchEntry((int)&Buffer, v12, v5) )
      {
        v6 += 20;
        v5 += 20;
        if ( v6 >= 0x28 )
          return 0;
      }
LABEL_10:
      *(_DWORD *)a3 = 1;
      return 0;
    }
  }
  return 0;
}
// 77E1FA40: using guessed type int ByteMatchAppendedDataInstallers;
// 77E1FB80: using guessed type int ByteMatchEOFInstallers;
// 77E358D0: using guessed type char *ByteMatchSectionInstallers;

//----- (77E35BB9) --------------------------------------------------------
int __stdcall TestStringTableEntry(HRSRC hResInfo, int a2)
{
  HRSRC v2; // esi@1
  HRSRC v3; // eax@1
  DWORD v4; // ebx@2
  HGLOBAL v5; // eax@2
  int v6; // ebx@2
  unsigned int v7; // ecx@4
  unsigned int v8; // edx@6
  int v9; // ecx@10
  const wchar_t *v10; // eax@10
  signed int v12; // [sp+8h] [bp-4h]@1
  HRSRC hResInfoa; // [sp+14h] [bp+8h]@1

  v12 = 0;
  v2 = hResInfo;
  v3 = FindResourceExW(*((HMODULE *)hResInfo + 9), (LPCWSTR)6, (LPCWSTR)*(_WORD *)a2, *(_WORD *)(a2 + 8));
  hResInfoa = v3;
  if ( v3 )
  {
    v4 = SizeofResource(*((HMODULE *)v2 + 9), v3);
    v5 = LoadResource(*((HMODULE *)v2 + 9), hResInfoa);
    v6 = (int)((char *)v5 + v4);
    if ( v5 )
    {
      if ( (unsigned int)v5 < v6 )
      {
        v7 = *((_DWORD *)v2 + 1);
        if ( (unsigned int)v5 > v7 && v6 < v7 + *((_DWORD *)v2 + 11) )
        {
          v8 = 0;
          do
          {
            if ( v8 >= *(_DWORD *)(a2 + 4) )
              break;
            v5 = (char *)v5 + 2 * *(_WORD *)v5 + 2;
            ++v8;
          }
          while ( (unsigned int)v5 < v6 );
          if ( (unsigned int)v5 < v6 )
          {
            v9 = *(_WORD *)v5;
            v10 = (const wchar_t *)((char *)v5 + 2);
            if ( v9 )
            {
              if ( (unsigned int)&v10[v9] < v6
                && v9 == *(_DWORD *)(a2 + 12)
                && !_wcsnicmp(v10, *(const wchar_t **)(a2 + 16), *(_DWORD *)(a2 + 12)) )
                v12 = 1;
            }
          }
        }
      }
    }
  }
  return v12;
}

//----- (77E35C59) --------------------------------------------------------
signed int __stdcall TestResourceDataMatchEntry(int a1, int a2)
{
  HRSRC v2; // eax@1
  const char *v4; // eax@3
  unsigned int v5; // edx@4
  int v6; // ecx@5
  int v7; // edx@6
  int v8; // edx@7
  int v9; // [sp+8h] [bp-4h]@1

  v9 = 0;
  v2 = FindResourceExW(*(HMODULE *)(a1 + 36), *(LPCWSTR *)a2, *(LPCWSTR *)(a2 + 4), 0);
  if ( v2 )
  {
    v4 = (const char *)LoadResource(*(HMODULE *)(a1 + 36), v2);
    if ( v4 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      if ( (unsigned int)v4 > v5 )
      {
        v6 = *(_DWORD *)(a2 + 12);
        if ( (unsigned int)&v4[v6 - v5] < *(_DWORD *)(a1 + 44) )
        {
          v7 = *(_DWORD *)(a2 + 8);
          if ( v7 )
          {
            v8 = v7 - 1;
            if ( !v8 && v6 )
            {
              while ( !(*(_BYTE *)(*(_DWORD *)(a2 + 16) + v8) & v4[v8]) )
              {
                ++v8;
                if ( v8 >= (unsigned int)v6 )
                  return v9;
              }
              return 1;
            }
          }
          else if ( !memcmp(v4, *(const char **)(a2 + 16), v6) )
          {
            return 1;
          }
        }
      }
    }
  }
  return v9;
}

//----- (77E35C90) --------------------------------------------------------
signed int __stdcall LoadImageMappings(int a1)
{
  signed int v1; // edi@1
  HANDLE v2; // eax@1
  HMODULE v3; // eax@2

  v1 = 0;
  v2 = CreateFileW(*(LPCWSTR *)a1, 0x80000000, 5u, 0, 3u, 0x80u, 0);
  *(_DWORD *)(a1 + 32) = v2;
  if ( v2 != (HANDLE)-1
    && (v3 = LoadLibraryExW(*(LPCWSTR *)a1, 0, 0x20u), (*(_DWORD *)(a1 + 36) = v3) != 0)
    && VirtualQuery(v3, (PMEMORY_BASIC_INFORMATION)(a1 + 4), 0x1Cu) == 28 )
  {
    v1 = 1;
    *(_DWORD *)(a1 + 52) = 1;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 36) )
      FreeLibrary(*(HMODULE *)(a1 + 36));
    if ( *(_DWORD *)(a1 + 32) != -1 )
    {
      CloseHandle(*(HANDLE *)(a1 + 32));
      *(_DWORD *)(a1 + 32) = -1;
    }
  }
  return v1;
}

//----- (77E35D02) --------------------------------------------------------
int __stdcall SXSManifest(int a1, int a2, LONG_PTR lParam)
{
  unsigned int v3; // edi@1
  size_t v4; // eax@4
  signed int v6; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v6 = 0;
  *(_DWORD *)lParam = 0;
  if ( a2 )
  {
    if ( *(_WORD *)a2 )
    {
      do
      {
        if ( v6 )
          break;
        v4 = SXSManifestInstallers[v3 / 2];
        if ( 2 * v4 <= *(_WORD *)a2 && !_wcsnicmp(*(const wchar_t **)(a2 + 4), (&off_77E3CB40)[v3], v4) )
        {
          *(_DWORD *)lParam = 1;
          v6 = 1;
        }
        v3 += 6;
      }
      while ( v3 < 48 );
    }
  }
  else if ( LoadImageFile(a1) && !EnumResourceNamesW(*(HMODULE *)(a1 + 36), (LPCWSTR)0x18, SXSEnumProc, lParam) )
  {
    GetLastError();
  }
  return 0;
}
// 77E3CB38: using guessed type int SXSManifestInstallers[];
// 77E3CB40: using guessed type wchar_t *off_77E3CB40;

//----- (77E35D55) --------------------------------------------------------
signed int __stdcall LoadImageFile(int a1)
{
  signed int v1; // edi@1

  v1 = 0;
  if ( !*(_DWORD *)(a1 + 48) && (*(_DWORD *)(a1 + 52) || LoadImageMappings(a1) && Load32BitPEHeaders(a1)) )
  {
    v1 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 48) = 1;
    if ( *(_DWORD *)(a1 + 52) )
      FreeImageInfo(a1);
  }
  return v1;
}

//----- (77E35D9C) --------------------------------------------------------
signed int __stdcall Load32BitPEHeaders(int a1)
{
  int v1; // ecx@1
  signed int result; // eax@1
  int v3; // esi@2
  int v4; // ecx@3

  v1 = *(_DWORD *)(a1 + 4);
  result = 0;
  if ( *(_WORD *)v1 == 23117 )
  {
    v3 = *(_DWORD *)(v1 + 60);
    if ( v3 > 0 )
    {
      v4 = v3 + v1;
      if ( *(_DWORD *)v4 == 17744 && *(_WORD *)(v4 + 4) == 332 )
      {
        *(_DWORD *)(a1 + 40) = v4;
        result = 1;
        *(_DWORD *)(a1 + 44) = *(_DWORD *)(v4 + 80);
      }
    }
  }
  return result;
}

//----- (77E35DE4) --------------------------------------------------------
int __stdcall ByteMatchGetSection(int a1, char *Str2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  unsigned int v6; // ebx@1
  int v7; // ecx@1
  int v8; // edi@1
  unsigned int v10; // eax@5
  signed int v11; // [sp+Ch] [bp-4h]@1
  int v12; // [sp+18h] [bp+8h]@1

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 40);
  v6 = *(_WORD *)(v5 + 6);
  v7 = *(_DWORD *)(a1 + 40);
  v12 = 0;
  v11 = -1073741687;
  v8 = *(_WORD *)(v5 + 20) + v7 + 24;
  if ( *(_WORD *)(v5 + 6) )
  {
    while ( strncmp((const char *)v8, Str2, strlen(Str2)) )
    {
      v8 += 40;
      ++v12;
      if ( v12 >= v6 )
        return v11;
    }
    v10 = *(_DWORD *)(v8 + 12);
    if ( v10 < *(_DWORD *)(v4 + 44) )
    {
      v11 = 0;
      *(_DWORD *)a3 = v10 + *(_DWORD *)(v4 + 4);
      *(_DWORD *)a4 = *(_DWORD *)(v4 + 44) - *(_DWORD *)(v8 + 12);
    }
  }
  return v11;
}

//----- (77E35E5A) --------------------------------------------------------
int __stdcall StringTable(HRSRC hResInfo, int a2, int a3)
{
  unsigned int v3; // edi@1
  int v4; // esi@2

  v3 = 0;
  *(_DWORD *)a3 = 0;
  if ( LoadImageFile((int)hResInfo) )
  {
    v4 = (int)StringTableInstallers;
    while ( !TestStringTableEntry(hResInfo, v4) )
    {
      v3 += 20;
      v4 += 20;
      if ( v3 >= 0xF0 )
        return 0;
    }
    *(_DWORD *)a3 = 1;
  }
  return 0;
}
// 77E35EA8: using guessed type int StringTableInstallers[3];

//----- (77E35FEF) --------------------------------------------------------
int __stdcall ResourceDataMatch(int a1, int a2, int a3)
{
  unsigned int v3; // edi@1
  int v4; // esi@2

  v3 = 0;
  *(_DWORD *)a3 = 0;
  if ( LoadImageFile(a1) )
  {
    v4 = (int)&ResourceDataMatchInstallers;
    while ( !TestResourceDataMatchEntry(a1, v4) )
    {
      v3 += 20;
      v4 += 20;
      if ( v3 >= 0x28 )
        return 0;
    }
    *(_DWORD *)a3 = 1;
  }
  return 0;
}
// 77E36038: using guessed type int ResourceDataMatchInstallers;

//----- (77E3607B) --------------------------------------------------------
int __stdcall ByteMatchGetAppendedDataOffset(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  void *v5; // ST00_4@1
  int v6; // ebx@1
  int v7; // eax@3
  LARGE_INTEGER FileSize; // [sp+Ch] [bp-10h]@1
  int v10; // [sp+14h] [bp-8h]@1
  unsigned int v11; // [sp+18h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 40);
  v3 = *(_WORD *)(v2 + 6);
  v4 = *(_WORD *)(v2 + 20) + *(_DWORD *)(a1 + 40) + 24;
  v5 = *(void **)(a1 + 32);
  v6 = 0;
  v10 = -1073741687;
  v11 = 0;
  if ( GetFileSizeEx(v5, &FileSize) )
  {
    if ( v3 )
    {
      v7 = v4 + 20;
      do
      {
        if ( *(_DWORD *)v7 > v11 )
        {
          v6 = *(_DWORD *)(v7 - 4);
          v11 = *(_DWORD *)v7;
        }
        v7 += 40;
        --v3;
      }
      while ( v3 );
    }
    if ( FileSize.s.HighPart >= 0 && (FileSize.s.HighPart > 0 || v6 + v11 + 64 < FileSize.s.LowPart) )
    {
      v10 = 0;
      *(_DWORD *)a2 = v6 + v11;
    }
  }
  return v10;
}

//----- (77E360FE) --------------------------------------------------------
int __stdcall NonInstallerDefault(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 2;
  return 0;
}

//----- (77E36141) --------------------------------------------------------
BOOL __stdcall FreeImageInfo(int a1)
{
  BOOL result; // eax@3

  if ( *(_DWORD *)(a1 + 36) )
    FreeLibrary(*(HMODULE *)(a1 + 36));
  result = *(_DWORD *)(a1 + 32);
  if ( result != -1 )
  {
    result = CloseHandle(*(HANDLE *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = -1;
  }
  *(_DWORD *)(a1 + 52) = 0;
  return result;
}

//----- (77E36177) --------------------------------------------------------
signed int __stdcall TestByteMatchEntry(int a1, unsigned int a2, int a3)
{
  int v3; // edx@1
  unsigned int v4; // ebx@1
  int v6; // [sp+4h] [bp-4h]@1
  int v7; // [sp+18h] [bp+10h]@2

  v3 = a3;
  v6 = 0;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 < *(_DWORD *)(a3 + 8) )
  {
    v7 = v4 + *(_DWORD *)(a3 + 12);
    while ( v7 <= a2 )
    {
      if ( !memcmp((const char *)(v4 + a1), *(const char **)(v3 + 16), *(_DWORD *)(v3 + 12)) )
        return 1;
      ++v4;
      ++v7;
      if ( v4 >= *(_DWORD *)(v3 + 8) )
        return v6;
    }
  }
  return v6;
}

//----- (77E36205) --------------------------------------------------------
BOOL __stdcall GetExitCodeProcessImplementation(HANDLE hProcess, LPDWORD lpExitCode)
{
  BOOL result; // eax@2
  DWORD v3; // esi@4

  if ( GetExitCodeProcess(hProcess, lpExitCode) || (v3 = GetLastError(), BaseCheckForVDM(hProcess, (int)lpExitCode)) )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E36236) --------------------------------------------------------
LONG __stdcall CompareFileTimeStub(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
{
  return CompareFileTime(lpFileTime1, lpFileTime2);
}

//----- (77E36259) --------------------------------------------------------
BOOL __stdcall GetVolumeInformationWStub(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
{
  return GetVolumeInformationW(
           lpRootPathName,
           lpVolumeNameBuffer,
           nVolumeNameSize,
           lpVolumeSerialNumber,
           lpMaximumComponentLength,
           lpFileSystemFlags,
           lpFileSystemNameBuffer,
           nFileSystemNameSize);
}

//----- (77E3648C) --------------------------------------------------------
int __stdcall GetVolumeNameForRoot(PWSTR dosname, int a2, int a3)
{
  int v3; // eax@18
  PVOID v4; // eax@18
  unsigned int v5; // ebx@22
  int v6; // ecx@23
  __int16 v7; // dx@24
  int v8; // eax@24
  __int16 v9; // dx@29
  void *v10; // ebx@47
  PWCH v11; // ecx@2
  WCHAR *v12; // eax@2
  unsigned int v13; // eax@5
  NTSTATUS v14; // esi@6
  BOOL v15; // esi@7
  PPEB v16; // eax@7
  int v18; // eax@11
  WCHAR *v19; // eax@11
  int v20; // eax@12
  PVOID v21; // ebx@12
  int v22; // eax@13
  PVOID v23; // edi@13
  HANDLE v24; // eax@14
  ULONG v25; // eax@49
  HANDLE i; // [sp-28h] [bp-278h]@15
  void *v27; // [sp-20h] [bp-270h]@15
  DWORD v28; // [sp-1Ch] [bp-26Ch]@15
  void *v29; // [sp-18h] [bp-268h]@15
  DWORD v30; // [sp-14h] [bp-264h]@15
  DWORD *v31; // [sp-10h] [bp-260h]@15
  void *v32; // [sp-Ch] [bp-25Ch]@58
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-24Ch]@6
  __int16 v34; // [sp+Ch] [bp-244h]@24
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+14h] [bp-23Ch]@6
  void *Dst; // [sp+2Ch] [bp-224h]@1
  ULONG Size; // [sp+30h] [bp-220h]@7
  unsigned int v38; // [sp+34h] [bp-21Ch]@20
  HANDLE hDevice; // [sp+38h] [bp-218h]@6
  LSA_UNICODE_STRING ntname; // [sp+3Ch] [bp-214h]@1
  int OutBuffer; // [sp+44h] [bp-20Ch]@7

  Dst = (void *)a2;
  if ( !RtlDosPathNameToNtPathName_U(dosname, &ntname, 0, 0) )
  {
    RtlSetLastWin32Error(3);
    return 0;
  }
  v11 = ntname.Buffer;
  v12 = &ntname.Buffer[((unsigned int)ntname.Length >> 1) - 1];
  if ( *v12 == 92 )
  {
    *v12 = 0;
    v11 = ntname.Buffer;
    ntname.Length -= 2;
  }
  if ( ntname.Length >= 4u )
  {
    v13 = (unsigned int)ntname.Length >> 1;
    if ( v11[v13 - 1] == 58 )
      ntname.Buffer[((unsigned int)ntname.Length >> 1) - 2] = _toupper(v11[v13 - 2]);
  }
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v14 = NtOpenFile(&hDevice, 0x100080u, &ObjectAttributes, &IoStatusBlock, 3u, 0x10u);
  if ( v14 < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    v25 = RtlNtStatusToDosError(v14);
    RtlSetLastWin32Error(v25);
    return 0;
  }
  v15 = DeviceIoControl(hDevice, 0x4D0008u, 0, 0, &OutBuffer, 0x208u, &Size, 0);
  NtClose(hDevice);
  v16 = NtCurrentTeb()->ProcessEnvironmentBlock;
  if ( !v15 )
  {
    RtlFreeHeap(v16->Reserved4[1], 0, ntname.Buffer);
    return 0;
  }
  RtlFreeHeap(v16->Reserved4[1], 0, ntname.Buffer);
  ntname.Length = OutBuffer;
  ntname.MaximumLength = OutBuffer + 2;
  v18 = KernelBaseGetGlobalData();
  v19 = (WCHAR *)RtlAllocateHeap(
                   NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                   *(_DWORD *)(v18 + 44),
                   ntname.MaximumLength);
  ntname.Buffer = v19;
  if ( !v19 )
    goto LABEL_53;
  memcpy(v19, (char *)&OutBuffer + 2, (unsigned __int16)OutBuffer);
  ntname.Buffer[(unsigned int)ntname.Length >> 1] = 0;
  v20 = KernelBaseGetGlobalData();
  v21 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          *(_DWORD *)(v20 + 44),
          ntname.Length + 24);
  if ( !v21 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
LABEL_53:
    RtlSetLastWin32Error(8);
    return 0;
  }
  memset(v21, 0, 0x18u);
  *((_DWORD *)v21 + 4) = 24;
  *((_WORD *)v21 + 10) = ntname.Length;
  memcpy((char *)v21 + 24, ntname.Buffer, ntname.Length);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
  v22 = KernelBaseGetGlobalData();
  v23 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v22 + 44), 0x20u);
  if ( !v23 )
  {
LABEL_55:
    RtlSetLastWin32Error(8);
LABEL_56:
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v21);
    return 0;
  }
  v24 = CreateFileW(L"\\\\.\\MountPointManager", 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  hDevice = v24;
  if ( v24 == (HANDLE)-1 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v23);
    goto LABEL_56;
  }
  v31 = &Size;
  v30 = 32;
  v29 = v23;
  v28 = ntname.Length + 24;
  v27 = v21;
  for ( i = v24; ; i = hDevice )
  {
    v38 = DeviceIoControl(i, 0x6D0008u, v27, v28, v29, v30, v31, 0);
    if ( v38 || GetLastError() != 234 )
      break;
    Size = *(_DWORD *)v23;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v23);
    v3 = KernelBaseGetGlobalData();
    v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), Size);
    v23 = v4;
    if ( !v4 )
    {
      CloseHandle(hDevice);
      goto LABEL_55;
    }
    v31 = &Size;
    v30 = Size;
    v29 = v4;
    v28 = ntname.Length + 24;
    v27 = v21;
  }
  CloseHandle(hDevice);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v21);
  if ( v38 )
  {
    v38 = 0;
    v5 = *((_DWORD *)v23 + 1);
    if ( v5 )
    {
      v6 = (int)((char *)v23 + 8);
      while ( 1 )
      {
        v7 = *(_WORD *)(v6 + 4);
        v8 = (int)((char *)v23 + *(_DWORD *)v6);
        v34 = v7;
        if ( (v7 == 96 || v7 == 98 && *(_WORD *)(v8 + 96) == 92) && *(_WORD *)v8 == 92 )
        {
          v9 = *(_WORD *)(v8 + 2);
          if ( (v9 == 63 || v9 == 92)
            && *(_WORD *)(v8 + 4) == 63
            && *(_WORD *)(v8 + 6) == 92
            && *(_WORD *)(v8 + 8) == 86
            && *(_WORD *)(v8 + 10) == 111
            && *(_WORD *)(v8 + 12) == 108
            && *(_WORD *)(v8 + 14) == 117
            && *(_WORD *)(v8 + 16) == 109
            && *(_WORD *)(v8 + 18) == 101
            && *(_WORD *)(v8 + 20) == 123
            && *(_WORD *)(v8 + 38) == 45
            && *(_WORD *)(v8 + 48) == 45
            && *(_WORD *)(v8 + 58) == 45
            && *(_WORD *)(v8 + 68) == 45
            && *(_WORD *)(v8 + 94) == 125
            && v34 == 96
            && v9 == 63 )
            break;
        }
        ++v38;
        v6 += 24;
        if ( v38 >= v5 )
          goto LABEL_62;
      }
      if ( (unsigned int)(2 * a3) >= 0x64 )
      {
        v10 = Dst;
        memcpy(Dst, (const void *)v8, 0x60u);
        *((_WORD *)v10 + 1) = 92;
        *((_WORD *)v10 + 48) = 92;
        *((_WORD *)v10 + 49) = 0;
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v23);
        return 1;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v23);
      RtlSetLastWin32Error(206);
      return 0;
    }
LABEL_62:
    v32 = v23;
  }
  else
  {
    v32 = v23;
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v32);
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3677C) --------------------------------------------------------
BOOL __stdcall GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
{
  return GetVolumePathNameInternalW(0, lpszFileName, (int)lpszVolumePathName, cchBufferLength);
}

//----- (77E3679A) --------------------------------------------------------
int __stdcall GetVolumePathNameInternalW(int a1, LPCWSTR lpFileName, int a3, int a4)
{
  DWORD v4; // eax@5
  DWORD v5; // esi@6
  int v6; // eax@6
  WCHAR *v7; // eax@6
  int v8; // eax@10
  PVOID v9; // eax@10
  const WCHAR *v10; // esi@12
  NTSTATUS v11; // eax@12
  UINT v12; // ebx@14
  int v13; // edi@14
  int v14; // eax@14
  __int16 v15; // bx@15
  LPWSTR v16; // edi@21
  unsigned int v17; // eax@24
  unsigned int v18; // ebx@36
  LPWSTR v19; // ST14_4@39
  WCHAR v21; // ax@62
  WCHAR v22; // cx@66
  WCHAR v23; // ax@69
  WCHAR v24; // cx@77
  PVOID v25; // ebx@90
  int v26; // ebx@98
  unsigned __int16 v27; // bx@99
  ULONG v28; // esi@99
  int v29; // eax@101
  PVOID v30; // esi@101
  int v31; // ST10_4@103
  WCHAR *v32; // eax@106
  LSA_UNICODE_STRING v33; // [sp+10h] [bp-48h]@99
  void *Dst; // [sp+18h] [bp-40h]@1
  UNICODE_STRING v35; // [sp+1Ch] [bp-3Ch]@12
  LPCWSTR v36; // [sp+24h] [bp-34h]@1
  LPWSTR FilePart; // [sp+28h] [bp-30h]@1
  int v38; // [sp+2Ch] [bp-2Ch]@12
  LPWSTR lpBuffer; // [sp+30h] [bp-28h]@6
  LSA_UNICODE_STRING DestinationString; // [sp+34h] [bp-24h]@8
  PVOID Address; // [sp+3Ch] [bp-1Ch]@10
  CHAR RootPathName[2]; // [sp+40h] [bp-18h]@74
  __int16 v43; // [sp+42h] [bp-16h]@85
  __int16 v44; // [sp+44h] [bp-14h]@85
  __int16 v45; // [sp+46h] [bp-12h]@85

  v36 = lpFileName;
  Dst = (void *)a3;
  FilePart = 0;
  if ( (unsigned int)a1 >= 0x40 )
  {
    RtlSetLastWin32Error(161);
    return 0;
  }
  if ( !lpFileName || !a3 || !a4 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  *(_WORD *)a3 = 0;
  v4 = GetFullPathNameW(lpFileName, 0, 0, 0);
  if ( v4 )
  {
    v5 = v4 + 10;
    v6 = KernelBaseGetGlobalData();
    v7 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 2 * v5);
    lpBuffer = v7;
    if ( v7 )
    {
      memset(v7, 0, 2 * v5);
      if ( !GetFullPathNameW(v36, v5, lpBuffer, &FilePart) )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpBuffer);
        return 0;
      }
      RtlInitUnicodeString(&DestinationString, lpBuffer);
      if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] != 92 )
      {
        DestinationString.Length += 2;
        DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] = 92;
        DestinationString.Buffer[(unsigned int)DestinationString.Length >> 1] = 0;
      }
      v8 = KernelBaseGetGlobalData();
      v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44), 0x4000u);
      Address = v9;
      if ( v9 )
      {
        memset(v9, 0, 0x4000u);
        FilePart = 0;
        v36 = 0;
        while ( 1 )
        {
          v10 = DestinationString.Buffer;
          v38 = 1;
          v11 = RtlInitUnicodeStringEx(&v35, DestinationString.Buffer);
          if ( v11 < 0 )
          {
            BaseSetLastNTError(v11);
LABEL_54:
            v15 = 0;
            goto LABEL_21;
          }
          if ( v35.Buffer[((unsigned int)v35.Length >> 1) - 1] != 92 )
          {
            BaseSetLastNTError(-1073741773);
            goto LABEL_54;
          }
          v12 = GetDriveTypeW(v10);
          v13 = __wcsicmp(v10, L"\\\\");
          v14 = __wcsicmp(v10, L"\\\\?\\UNC\\");
          if ( v12 == 4 )
          {
            v15 = 0;
            if ( v13 && v14 )
            {
              if ( BasepGetVolumeNameFromReparsePoint(v10, Address, 0x2000, (int)&v38) )
                goto LABEL_33;
              RtlSetLastWin32Error(87);
              goto LABEL_83;
            }
          }
          else
          {
            v15 = 0;
          }
          if ( v35.Length == 6 )
          {
            if ( v35.Buffer[1] != 58 )
              goto LABEL_18;
          }
          else
          {
            if ( v35.Length != 14
              || *v35.Buffer != 92
              || v35.Buffer[1] != 92
              || (v24 = v35.Buffer[2], v24 != 46) && v24 != 63
              || v35.Buffer[3] != 92
              || v35.Buffer[5] != 58 )
            {
LABEL_18:
              if ( GetVolumeNameForRoot((PWSTR)v10, (int)Address, 0x2000) )
                goto LABEL_33;
              if ( BasepGetVolumeNameFromReparsePoint(v10, Address, 0x2000, (int)&v38) )
              {
                GetVolumeNameForRoot((PWSTR)Address, (int)Address, 0x2000);
LABEL_33:
                v16 = lpBuffer;
LABEL_34:
                RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                if ( v38 || FilePart )
                {
                  if ( DestinationString.Length < 2u )
                  {
                    v18 = 0;
                  }
                  else
                  {
                    v18 = (unsigned int)DestinationString.Length >> 1;
                    if ( v18 )
                    {
                      if ( v18 + 1 > a4 )
                      {
                        v32 = &DestinationString.Buffer[v18 - 1];
                        if ( *v32 == 92 )
                        {
                          *v32 = 0;
                          DestinationString.Length -= 2;
                          --v18;
                        }
                      }
                    }
                  }
                  if ( 2 * a4 >= (unsigned int)DestinationString.Length + 2 )
                  {
                    memcpy(Dst, DestinationString.Buffer, DestinationString.Length);
                    v19 = lpBuffer;
                    *((_WORD *)Dst + v18) = 0;
                    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v19);
                    return 1;
                  }
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpBuffer);
                  RtlSetLastWin32Error(206);
                }
                else
                {
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v16);
                }
                return 0;
              }
              goto LABEL_20;
            }
            v10 += 4;
          }
          if ( GetVolumeNameForRoot((PWSTR)v10, (int)Address, 0x2000) )
            goto LABEL_33;
          v38 = 0;
LABEL_83:
          *(_WORD *)Address = 0;
LABEL_20:
          if ( !v38 && GetLastError() == 5 )
            v38 = 1;
LABEL_21:
          v16 = lpBuffer;
          if ( *(_WORD *)Address != v15 )
          {
            if ( *lpBuffer != 92
              || lpBuffer[1] != 92
              || ((v21 = lpBuffer[2], v21 == 46) || v21 == 63) && lpBuffer[3] == 92 && lpBuffer[5] == 58 )
            {
              v22 = lpBuffer[1];
              if ( v22 == 58 )
              {
                *(_WORD *)RootPathName = *lpBuffer;
              }
              else
              {
                if ( *lpBuffer != 92
                  || v22 != 92
                  || (v23 = lpBuffer[2], v23 != 46) && v23 != 63
                  || lpBuffer[3] != 92
                  || lpBuffer[5] != 58 )
                {
LABEL_90:
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v16);
                  v25 = Address;
                  if ( *(_WORD *)Address != 92
                    || *((_WORD *)Address + 1) != 63
                    || *((_WORD *)Address + 2) != 63
                    || *((_WORD *)Address + 3) != 92 )
                  {
                    RtlInitUnicodeString(&DestinationString, (PCWSTR)Address);
                    RtlInitUnicodeString(&v33, L"\\\\?\\GLOBALROOT");
                    v27 = DestinationString.Length + v33.Length;
                    v35.Length = DestinationString.Length + v33.Length;
                    v28 = (unsigned __int16)(DestinationString.Length + v33.Length + 2);
                    if ( v28 < DestinationString.Length + (unsigned int)v33.Length
                      || (unsigned __int16)(DestinationString.Length + v33.Length + 2) < v27 )
                    {
                      RtlSetLastWin32Error(111);
                      return 0;
                    }
                    v29 = KernelBaseGetGlobalData();
                    v30 = RtlAllocateHeap(
                            NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                            *(_DWORD *)(v29 + 44),
                            v28);
                    if ( !v30 )
                    {
                      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                      goto LABEL_50;
                    }
                    memcpy(v30, v33.Buffer, v33.Length);
                    memcpy((char *)v30 + v33.Length, DestinationString.Buffer, DestinationString.Length);
                    v31 = (int)Dst;
                    *((_WORD *)v30 + ((unsigned int)v27 >> 1)) = 0;
                    v26 = GetVolumePathNameInternalW(a1 + 1, (LPCWSTR)v30, v31, a4);
                    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v30);
                  }
                  else
                  {
                    if ( *((_WORD *)Address + 4) && *((_WORD *)Address + 5) == 58 )
                    {
                      RtlInitUnicodeString(&DestinationString, (PCWSTR)Address);
                      _memmove(v25, (char *)v25 + 8, DestinationString.Length - 6);
                    }
                    else
                    {
                      *((_WORD *)Address + 1) = 92;
                    }
                    v26 = GetVolumePathNameInternalW(a1 + 1, (LPCWSTR)Address, (int)Dst, a4);
                  }
                  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                  return v26;
                }
                *(_WORD *)RootPathName = lpBuffer[4];
              }
              v43 = 58;
              v44 = 92;
              v45 = 0;
              if ( GetDriveTypeA(RootPathName) != 4 )
                goto LABEL_90;
            }
          }
          if ( !v38 && FilePart )
          {
            *FilePart = (unsigned __int16)v36;
            RtlInitUnicodeString(&DestinationString, v16);
            goto LABEL_34;
          }
          if ( DestinationString.Length <= 2u )
            goto LABEL_34;
          v17 = ((unsigned int)DestinationString.Length >> 1) - 2;
          if ( (unsigned int)DestinationString.Length >> 1 != 2 )
          {
            do
            {
              if ( DestinationString.Buffer[v17] == 92 )
                break;
              --v17;
            }
            while ( v17 );
          }
          if ( !v17 )
            goto LABEL_34;
          if ( v38 )
          {
            FilePart = &DestinationString.Buffer[v17 + 1];
            v36 = (LPCWSTR)*FilePart;
            *FilePart = 0;
          }
          else
          {
            DestinationString.Buffer[v17 + 1] = 0;
          }
          RtlInitUnicodeString(&DestinationString, v16);
        }
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpBuffer);
    }
LABEL_50:
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E36A9F) --------------------------------------------------------
BOOL __stdcall GetVolumePathNameWStub(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
{
  return GetVolumePathNameW(lpszFileName, lpszVolumePathName, cchBufferLength);
}

//----- (77E36AAF) --------------------------------------------------------
int __stdcall BasepGetVolumeNameFromReparsePoint(LPCWSTR lpFileName, void *Dst, int cchFilePath, int a4)
{
  HANDLE v4; // eax@4
  int v6; // eax@16
  PVOID v7; // eax@16
  unsigned __int16 v8; // cx@23
  PVOID v9; // edi@25
  __int16 v10; // cx@27
  __int16 v11; // di@27
  __int16 v12; // dx@31
  HANDLE v13; // eax@51
  DWORD v14; // eax@55
  DWORD BytesReturned; // [sp+14h] [bp-30h]@7
  PVOID Address; // [sp+18h] [bp-2Ch]@16
  HANDLE hObject; // [sp+1Ch] [bp-28h]@4
  int v18; // [sp+20h] [bp-24h]@1
  char OutBuffer; // [sp+24h] [bp-20h]@7

  v18 = 1;
  if ( Dst && (unsigned int)cchFilePath >= 1 )
    *(_WORD *)Dst = 0;
  v4 = CreateFileW(lpFileName, 0, 3u, 0, 3u, 0x2200080u, (HANDLE)0xFFFFFFFF);
  hObject = v4;
  if ( v4 != (HANDLE)-1 )
  {
    if ( a4 )
      *(_DWORD *)a4 = 1;
    if ( !DeviceIoControl(v4, 0x900A8u, 0, 0, &OutBuffer, 0x1Cu, &BytesReturned, 0) && GetLastError() != 234 )
    {
      v18 = 0;
LABEL_10:
      if ( hObject != (HANDLE)-1 )
        CloseHandle(hObject);
      return v18;
    }
    RtlSetLastWin32Error(0);
    v6 = KernelBaseGetGlobalData();
    v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 0x4000u);
    Address = v7;
    if ( !v7 )
    {
      RtlSetLastWin32Error(8);
LABEL_18:
      v18 = 0;
      goto LABEL_19;
    }
    if ( !DeviceIoControl(hObject, 0x900A8u, 0, 0, v7, 0x4000u, &BytesReturned, 0) )
      goto LABEL_18;
    if ( *(_DWORD *)Address == -1610612733 )
    {
      v8 = *((_WORD *)Address + 5);
      if ( 2 * cchFilePath < (unsigned int)v8 + 2
        || v8 <= 0u
        || (v9 = Address, memcpy(Dst, (char *)Address + *((_WORD *)Address + 4) + 16, v8), (unsigned int)cchFilePath < 2) )
      {
        RtlSetLastWin32Error(206);
        goto LABEL_18;
      }
      v10 = *((_WORD *)Dst + 1);
      *((_WORD *)Dst + 1) = 92;
      *((_WORD *)Dst + ((unsigned int)*((_WORD *)v9 + 5) >> 1)) = 0;
      v11 = *((_WORD *)v9 + 5);
      if ( v11 != 96 && (v11 != 98 || *((_WORD *)Dst + 48) != 92)
        || *(_WORD *)Dst != 92
        || (v12 = *((_WORD *)Dst + 1), v12 != 63) && v12 != 92
        || *((_WORD *)Dst + 2) != 63
        || *((_WORD *)Dst + 3) != 92
        || *((_WORD *)Dst + 4) != 86
        || *((_WORD *)Dst + 5) != 111
        || *((_WORD *)Dst + 6) != 108
        || *((_WORD *)Dst + 7) != 117
        || *((_WORD *)Dst + 8) != 109
        || *((_WORD *)Dst + 9) != 101
        || *((_WORD *)Dst + 10) != 123
        || *((_WORD *)Dst + 19) != 45
        || *((_WORD *)Dst + 24) != 45
        || *((_WORD *)Dst + 29) != 45
        || *((_WORD *)Dst + 34) != 45
        || *((_WORD *)Dst + 47) != 125
        || v11 != 98
        || v12 != 92 )
      {
        *((_WORD *)Dst + 1) = v10;
        RtlSetLastWin32Error(87);
        goto LABEL_18;
      }
LABEL_19:
      if ( Address )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      goto LABEL_10;
    }
    if ( *(_DWORD *)Address != -1610612724 )
      goto LABEL_18;
    CloseHandle(hObject);
    v13 = CreateFileW(lpFileName, 0, 3u, 0, 3u, 0x2000080u, (HANDLE)0xFFFFFFFF);
    hObject = v13;
    if ( v13 == (HANDLE)-1 )
    {
      if ( a4 )
        *(_DWORD *)a4 = 0;
    }
    else
    {
      v14 = GetFinalPathNameByHandleW(v13, (LPWSTR)Dst, cchFilePath, 0);
      if ( v14 )
      {
        if ( v14 <= cchFilePath && v14 >= 4 )
        {
          if ( *(_WORD *)Dst == 92
            && *((_WORD *)Dst + 1) == 92
            && *((_WORD *)Dst + 2) == 63
            && *((_WORD *)Dst + 3) == 92 )
            *((_WORD *)Dst + 1) = 63;
          RtlSetLastWin32Error(87);
          goto LABEL_54;
        }
        RtlSetLastWin32Error(206);
      }
      *(_WORD *)Dst = 0;
    }
LABEL_54:
    v18 = 0;
    goto LABEL_19;
  }
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E36B6C) --------------------------------------------------------
DWORD __stdcall GetFileTypeImplementation(HANDLE hFile)
{
  PVOID v1; // eax@1
  DWORD result; // eax@6

  v1 = hFile;
  if ( !hFile )
    goto LABEL_16;
  if ( hFile == (HANDLE)-12 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hFile == (HANDLE)-11 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hFile == (HANDLE)-10 )
  {
    v1 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  if ( ((unsigned int)v1 & 0x10000003) != 3 )
    return GetFileType(v1);
  if ( VerifyConsoleIoHandle((int)v1) )
  {
    result = 2;
  }
  else
  {
LABEL_16:
    BaseSetLastNTError(-1073741816);
    result = 0;
  }
  return result;
}

//----- (77E36BCD) --------------------------------------------------------
BOOL __stdcall VirtualFreeStub(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
{
  return VirtualFree(lpAddress, dwSize, dwFreeType);
}

//----- (77E36C43) --------------------------------------------------------
ULONG __stdcall LocalOpenCurrentUser(int a1, int a2, int a3)
{
  NTSTATUS v3; // eax@1

  v3 = RtlOpenCurrentUser(a2, a3);
  return RtlNtStatusToDosError(v3);
}
// 77DE105C: using guessed type int __stdcall RtlOpenCurrentUser(_DWORD, _DWORD);

//----- (77E36C64) --------------------------------------------------------
BOOL __stdcall FreeEnvironmentStringsWStub(LPWCH a1)
{
  return FreeEnvironmentStringsW(a1);
}

//----- (77E36C8E) --------------------------------------------------------
HANDLE __stdcall FindFirstFileExWStub(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
{
  return FindFirstFileExW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
}

//----- (77E36CA6) --------------------------------------------------------
BOOL __stdcall SetCurrentDirectoryWStub(LPCWSTR lpPathName)
{
  return SetCurrentDirectoryW(lpPathName);
}

//----- (77E36CBE) --------------------------------------------------------
DWORD __stdcall GetFileAttributesAStub(LPCSTR lpFileName)
{
  return GetFileAttributesA(lpFileName);
}

//----- (77E36CD6) --------------------------------------------------------
BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature)
{
  BOOL result; // eax@2

  if ( ProcessorFeature >= 0x40 )
    result = 0;
  else
    result = *(_BYTE *)(ProcessorFeature + 2147353204);
  return result;
}

//----- (77E36CF7) --------------------------------------------------------
SIZE_T __stdcall VirtualQueryStub(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
{
  return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

//----- (77E36D07) --------------------------------------------------------
PVOID __stdcall FlsGetValueStub(DWORD dwFlsIndex)
{
  return FlsGetValue(dwFlsIndex);
}

//----- (77E36D1F) --------------------------------------------------------
BOOL __stdcall FlsSetValueStub(DWORD dwFlsIndex, PVOID lpFlsData)
{
  return FlsSetValue(dwFlsIndex, lpFlsData);
}

//----- (77E38F37) --------------------------------------------------------
BOOL __stdcall GetCPInfoStub(UINT CodePage, LPCPINFO lpCPInfo)
{
  return GetCPInfo(CodePage, lpCPInfo);
}

//----- (77E38F4F) --------------------------------------------------------
HANDLE __stdcall GetStdHandleStub(DWORD nStdHandle)
{
  return GetStdHandle(nStdHandle);
}

//----- (77E38F79) --------------------------------------------------------
UINT __stdcall SetHandleCount(UINT uNumber)
{
  return uNumber;
}

//----- (77E38F95) --------------------------------------------------------
HANDLE __stdcall OpenMutexWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
  return OpenMutexW(dwDesiredAccess, bInheritHandle, lpName);
}

//----- (77E3B7E7) --------------------------------------------------------
int __stdcall StateObjectInit(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  result = a2;
  *(_DWORD *)(a1 + 8) = a2;
  return result;
}

//----- (77E3B807) --------------------------------------------------------
int __stdcall StateObjectListInit(int a1, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = StateObjectInit(a1, a2);
  *(_DWORD *)(v3 + 12) = 0;
  return result;
}

//----- (77E3B825) --------------------------------------------------------
BOOL __stdcall ClassesEnumTableInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context)
{
  return EnumTableInit((int)gClassesEnumTable) >= 0;
}
// 77EA65D8: using guessed type int gClassesEnumTable[18];

//----- (77E3B840) --------------------------------------------------------
NTSTATUS __stdcall EnumTableInit(int a1)
{
  NTSTATUS result; // eax@1

  StateObjectListInit(a1 + 28, 0);
  *(_BYTE *)a1 = 0;
  result = RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4));
  *(_BYTE *)a1 = result >= 0;
  return result;
}

//----- (77E3B87D) --------------------------------------------------------
BOOL __stdcall FlsFreeStub(DWORD dwFlsIndex)
{
  return FlsFree(dwFlsIndex);
}

//----- (77E3B88A) --------------------------------------------------------
BOOL __stdcall FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
{
  BOOL v5; // esi@1
  int v6; // eax@1
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-8h]@2

  v5 = 0;
  v6 = 0;
  if ( lpStringToFind )
  {
    RtlInitUnicodeString(&DestinationString, lpStringToFind);
    v6 = (int)&DestinationString;
  }
  if ( BasepFindActCtxSectionString(dwFlags, (int)lpExtensionGuid, ulSectionId, v6, (int)ReturnedData) )
    v5 = 1;
  return v5;
}

//----- (77E3B8D0) --------------------------------------------------------
signed int __stdcall BasepFindActCtxSectionString(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // edi@1
  NTSTATUS v6; // eax@2
  int Dst; // [sp+4h] [bp-44h]@2
  int v9; // [sp+44h] [bp-4h]@1

  v5 = 0;
  v9 = 0;
  if ( BasepFindActCtxSection_CheckAndConvertParameters(a1, a5, (int)&v9) )
  {
    memset(&Dst, 0, 0x40u);
    Dst = 64;
    v6 = RtlFindActivationContextSectionString(v9, a2, a3, a4, &Dst);
    if ( v6 < 0 )
    {
      BaseSetLastNTError(v6);
    }
    else if ( BasepFindActCtxSection_FillOutReturnData(a1, a5, (int)&Dst) )
    {
      v5 = 1;
    }
  }
  return v5;
}
// 77DE115C: using guessed type int __stdcall RtlFindActivationContextSectionString(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E3B947) --------------------------------------------------------
DWORD __stdcall GetCurrentDirectoryWStub(DWORD nBufferLength, LPWSTR lpBuffer)
{
  return GetCurrentDirectoryW(nBufferLength, lpBuffer);
}

//----- (77E3B95F) --------------------------------------------------------
signed int __stdcall BasepFindActCtxSection_FillOutReturnData(char a1, int a2, int a3)
{
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a3 + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a3 + 24);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a3 + 28);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a3 + 32);
  if ( a2 + 40 <= (unsigned int)(a2 + *(_DWORD *)a2) )
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a3 + 36);
  if ( a1 & 2 )
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a3 + 40);
  if ( a1 & 4 )
  {
    *(_DWORD *)(a2 + 44) = *(_DWORD *)(a3 + 44);
    *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(a3 + 52);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(a3 + 56);
    *(_DWORD *)(a2 + 60) = *(_DWORD *)(a3 + 60);
  }
  return 1;
}

//----- (77E3B9CD) --------------------------------------------------------
BOOL __stdcall IsValidCodePageStub(UINT CodePage)
{
  return IsValidCodePage(CodePage);
}

//----- (77E3BA79) --------------------------------------------------------
bool __stdcall CleanupClassesEnumTable(int a1)
{
  int v1; // eax@1
  int v2; // edi@1

  RtlRunOnceExecuteOnce(&gClassesEnumTableInit, (PRTL_RUN_ONCE_INIT_FN)ClassesEnumTableInitFn, 0, 0);
  EnumTableClear((int)gClassesEnumTable, (a1 == 0) + 1);
  v2 = v1;
  if ( !a1 )
    RtlRunOnceInitialize(&gClassesEnumTableInit);
  return v2 >= 0;
}
// 77EA65D8: using guessed type int gClassesEnumTable[18];

//----- (77E3BACA) --------------------------------------------------------
void __stdcall EnumTableClear(int a1, int a2)
{
  int v2; // eax@10
  int v3; // eax@13
  int v4; // ebx@13

  if ( a2 == 2 || (RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4)), v2 >= 0) )
  {
    if ( a2 == 1 )
    {
      v3 = GetCurrentThreadId();
      v4 = StateObjectListRemove(a1 + 28, v3);
      if ( StateObjectListIsEmpty(a1 + 28) )
        *(_DWORD *)(RegKrnGetGlobalState() + 160) = 0;
      if ( v4 )
        KeyStateListDestroy((PVOID)v4);
    }
    else
    {
      StateObjectListClear(a1 + 28, (void (__stdcall *)(_DWORD))KeyStateListDestroy);
      *(_DWORD *)(RegKrnGetGlobalState() + 160) = 0;
    }
    if ( a2 != 2 )
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4));
    if ( *(_BYTE *)a1 )
    {
      if ( a2 != 1 )
        RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(a1 + 4));
    }
  }
}

//----- (77E3BB43) --------------------------------------------------------
int __stdcall StateObjectListClear(int a1, void (__stdcall *a2)(_DWORD))
{
  int result; // eax@1
  int v3; // eax@2

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 12);
    if ( !result )
      break;
    v3 = StateObjectListRemove(a1, *(_DWORD *)(result + 8));
    a2(v3);
  }
  return result;
}

//----- (77E3BB61) --------------------------------------------------------
NTSTATUS __stdcall BasepUnInitComputerNameCache()
{
  if ( gpwzComputerNameCache )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, gpwzComputerNameCache);
    gpwzComputerNameCache = 0;
  }
  return RtlDeleteCriticalSection(&gComputerNameCacheUpdateCR);
}

//----- (77E3BB7F) --------------------------------------------------------
bool __stdcall CleanupPredefinedHandlesTable()
{
  NTSTATUS v0; // edi@1

  RtlRunOnceExecuteOnce(
    &PredefinedHandleTableCriticalSectionInit,
    (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
    0,
    0);
  v0 = RtlDeleteCriticalSection(&PredefinedHandleTableCriticalSection);
  RtlRunOnceInitialize(&PredefinedHandleTableCriticalSectionInit);
  return v0 >= 0;
}

//----- (77E3BBBB) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageMapper::Reset(FSPErrorMessages::CMessageMapper *this)
{
  FSPErrorMessages::CMessageMapper *v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  *((_DWORD *)this + 10) = 0;
  v2 = (void *)*((_DWORD *)this + 6);
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 7) = 0;
  if ( v2 )
  {
    HeapDestroy(v2);
    *((_DWORD *)v1 + 6) = 0;
  }
}

//----- (77E3BBE4) --------------------------------------------------------
void __stdcall RealWerpCleanupMessageMapping()
{
  FSPErrorMessages::CMessageMapper::Reset((FSPErrorMessages::CMessageMapper *)&FSPErrorMessages::CMessageMapper::ms_instance);
  FSPErrorMessages::CMessageMapper::StaticCleanup();
}

//----- (77E3BBEE) --------------------------------------------------------
void __stdcall FSPErrorMessages::CMessageMapper::StaticCleanup()
{
  FSPErrorMessages::CMessageMapper::MustSucceedCleanup((PRTL_CRITICAL_SECTION)&FSPErrorMessages::CMessageMapper::ms_instance);
}

//----- (77E3BBF8) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageMapper::MustSucceedCleanup(PRTL_CRITICAL_SECTION CriticalSectionObject)
{
  PRTL_CRITICAL_SECTION v1; // esi@1

  v1 = CriticalSectionObject;
  if ( CriticalSectionObject[1].RecursionCount )
  {
    RtlDeleteCriticalSection(CriticalSectionObject);
    v1[1].RecursionCount = 0;
  }
  v1[1].LockCount = 0;
}

//----- (77E3BC79) --------------------------------------------------------
signed int __stdcall CleanupPerAppKey()
{
  if ( g_ProcessAppKeyEvent )
  {
    NtClose(g_ProcessAppKeyEvent);
    g_ProcessAppKeyEvent = 0;
  }
  RtlRunOnceInitialize(&g_ProcessAppKeyEventInit);
  return 1;
}

//----- (77E3BC9C) --------------------------------------------------------
void __stdcall ExitProcessStub(int a1)
{
  RtlExitUserProcess(a1);
  JUMPOUT(byte_77E4A160);
}
// 77DE1710: using guessed type int __stdcall RtlExitUserProcess(_DWORD);

//----- (77E3BCB9) --------------------------------------------------------
BOOL __stdcall TerminateThreadStub(HANDLE hThread, DWORD dwExitCode)
{
  return TerminateThread(hThread, dwExitCode);
}

//----- (77E3BCDC) --------------------------------------------------------
PVOID __stdcall ConsoleAllocateCaptureBuffer(unsigned int a1, unsigned int a2)
{
  PVOID v2; // eax@7
  PVOID v3; // esi@7
  PVOID result; // eax@8

  if ( ConsolePortHeap )
  {
    if ( a2 < 0x7FFFFFEC
      && a1 <= 0x1FFFFFFF
      && a2 < 0x10000
      && 4 * a1 < 2147483628 - a2
      && a1 + 1 < (2147483628 - a2 - 4 * a1) / 3
      && (v2 = RtlAllocateHeap(ConsolePortHeap, 0, (7 * a1 + a2 + 19) & 0xFFFFFFFC), (v3 = v2) != 0) )
    {
      *((_DWORD *)v2 + 2) = 0;
      *(_DWORD *)v2 = (7 * a1 + a2 + 19) & 0xFFFFFFFC;
      memset((char *)v2 + 16, 0, 4 * a1);
      *((_DWORD *)v3 + 3) = (char *)v3 + 4 * a1 + 16;
      result = v3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E3BDB6) --------------------------------------------------------
NTSTATUS __stdcall ConsoleConnect(const void *a1, int a2, int a3)
{
  NTSTATUS result; // eax@1
  NTSTATUS v4; // ebx@2
  PVOID v5; // ebx@7
  PVOID v6; // ST1C_4@8
  ULONG MaxMessageSize; // [sp+8h] [bp-308h]@4
  struct _PORT_SECTION_READ ReadSection; // [sp+Ch] [bp-304h]@3
  struct _SECURITY_QUALITY_OF_SERVICE SecurityQos; // [sp+18h] [bp-2F8h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-2ECh]@4
  struct _PORT_SECTION_WRITE WriteSection; // [sp+2Ch] [bp-2E4h]@3
  ULONG ConnectDataLength; // [sp+44h] [bp-2CCh]@3
  PVOID Address; // [sp+48h] [bp-2C8h]@7
  LARGE_INTEGER SectionSize; // [sp+4Ch] [bp-2C4h]@2
  int ProcessInformation; // [sp+54h] [bp-2BCh]@1
  HANDLE SectionHandle; // [sp+58h] [bp-2B8h]@2
  const void *v17; // [sp+5Ch] [bp-2B4h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+60h] [bp-2B0h]@8
  NTSTATUS v19; // [sp+80h] [bp-290h]@8
  void *v20; // [sp+88h] [bp-288h]@8
  wchar_t pszDest; // [sp+100h] [bp-210h]@3

  v17 = a1;
  ProcessInformation = a3;
  result = NtSetInformationProcess((HANDLE)0xFFFFFFFF, ProcessConsoleHostProcess, &ProcessInformation, 4u);
  if ( result >= 0 )
  {
    SectionSize = (LARGE_INTEGER)0x10000i64;
    v4 = NtCreateSection(&SectionHandle, 6u, 0, &SectionSize, 4u, 0x8000000u, 0);
    if ( v4 < 0 )
      goto LABEL_12;
    WriteSection.SectionHandle = SectionHandle;
    WriteSection.ViewSize = SectionSize.s.LowPart;
    SecurityQos.ImpersonationLevel = 2;
    SecurityQos.ContextTrackingMode = 1;
    SecurityQos.EffectiveOnly = 1;
    WriteSection.Length = 24;
    WriteSection.SectionOffset = 0;
    WriteSection.ViewBase = 0;
    WriteSection.TargetViewBase = 0;
    ReadSection.Length = 12;
    ReadSection.ViewSize = 0;
    ReadSection.ViewBase = 0;
    ConnectDataLength = 0;
    v4 = RtlStringCchPrintfW(&pszDest, 0x105u, L"\\RPC Control\\ConsoleLPC-0x%p-%ws", ProcessInformation, a2);
    if ( v4 < 0 )
      goto LABEL_12;
    RtlInitUnicodeString(&DestinationString, &pszDest);
    v4 = NtConnectPort(
           &ConsoleLpcHandle,
           &DestinationString,
           &SecurityQos,
           &WriteSection,
           &ReadSection,
           &MaxMessageSize,
           0,
           &ConnectDataLength);
    NtClose(SectionHandle);
    if ( v4 < 0 )
    {
      _DbgPrintEx(0x70u, 1u, "NtConnectPort %ws failed with Status 0x%x\n", DestinationString.Buffer, v4);
    }
    else
    {
      ConsolePortMemoryRemoteDelta = WriteSection.TargetViewBase - WriteSection.ViewBase;
      ConsolePortHeap = RtlCreateHeap(0x8000u, WriteSection.ViewBase, WriteSection.ViewSize, 0, 0, 0);
      if ( !ConsolePortHeap )
        goto LABEL_17;
      if ( !v17 )
        goto LABEL_9;
      v5 = ConsoleAllocateCaptureBuffer(1u, 0x624u);
      Address = v5;
      if ( !v5 )
      {
LABEL_17:
        v4 = -1073741801;
        goto LABEL_12;
      }
      CsrAllocateMessagePointer(v5, 1572, &v20);
      qmemcpy(v20, v17, 0x624u);
      ConsoleClientCallServer(&RequestMessage, (int)v5, 83, 4);
      v6 = Address;
      v4 = v19;
      qmemcpy((void *)v17, v20, 0x624u);
      ConsoleFreeCaptureBuffer(v6);
    }
LABEL_9:
    if ( v4 >= 0 )
      return v4;
LABEL_12:
    ConsoleClientCleanup(0);
    return v4;
  }
  return result;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);
// 77EA6584: using guessed type int ConsolePortMemoryRemoteDelta;

//----- (77E3C047) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCchCopyNW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc, size_t cchSrc)
{
  NTSTATUS result; // eax@1

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    if ( cchSrc > 0x7FFFFFFE )
    {
      result = -1073741811;
      *pszDest = 0;
    }
    else
    {
      result = sub_77E3C090((int)pszSrc, cchDest, (int)pszDest, 0, cchSrc);
    }
  }
  return result;
}

//----- (77E3C090) --------------------------------------------------------
signed int __userpurge sub_77E3C090@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // edi@1

  v5 = a1;
  v6 = a2;
  result = 0;
  v8 = 0;
  if ( !a2 )
    goto LABEL_12;
  do
  {
    if ( !a5 )
      break;
    if ( !*(_WORD *)v5 )
      break;
    *(_WORD *)a3 = *(_WORD *)v5;
    a3 += 2;
    v5 += 2;
    --v6;
    --a5;
    ++v8;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_12:
    a3 -= 2;
    --v8;
    result = -2147483643;
  }
  *(_WORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = v8;
  return result;
}

//----- (77E3C0EB) --------------------------------------------------------
NTSTATUS RtlStringCchPrintfW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszFormat, ...)
{
  NTSTATUS result; // eax@1
  size_t v4; // esi@4
  NTSTATUS v5; // ebx@4
  int v6; // eax@4
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, pszFormat);
  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v4 = cchDest - 1;
    v5 = 0;
    v6 = __vsnwprintf(pszDest, cchDest - 1, pszFormat, va);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147483643;
    }
    else if ( v6 != v4 )
    {
      return v5;
    }
    pszDest[v4] = 0;
    return v5;
  }
  return result;
}

//----- (77E3C162) --------------------------------------------------------
int __stdcall VerifyConsoleIoHandle(int a1)
{
  ULONG v2; // eax@6
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@2
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@2
  int v5; // [sp+28h] [bp-7Ch]@3
  int v6; // [sp+2Ch] [bp-78h]@1

  v6 = a1;
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
  {
    ConsoleClientCallServer(&RequestMessage, 0, 35, 8);
    if ( NtStatus >= 0 )
      return v5;
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C1C8) --------------------------------------------------------
BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
{
  BOOL result; // eax@2
  ULONG v3; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  HANDLE v6; // [sp+2Ch] [bp-7Ch]@1
  DWORD v7; // [sp+30h] [bp-78h]@2

  v6 = hConsoleHandle;
  ConsoleClientCallServer(&RequestMessage, 0, 8, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    *lpMode = v7;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C222) --------------------------------------------------------
BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
{
  ULONG v2; // eax@4
  BOOL result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v6; // [sp+28h] [bp-7Ch]@1
  DWORD v7; // [sp+2Ch] [bp-78h]@1

  v6 = hConsoleHandle;
  v7 = dwMode;
  ConsoleClientCallServer(&RequestMessage, 0, 17, 8);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C278) --------------------------------------------------------
LANGID __stdcall SetThreadUILanguage(LANGID LangId)
{
  LANGID v1; // si@1
  int v2; // eax@2
  DWORD v3; // edi@2
  NTSTATUS v5; // eax@13
  int v6; // [sp+Ch] [bp-2Ch]@11
  int v7; // [sp+10h] [bp-28h]@11
  char v8; // [sp+14h] [bp-24h]@12
  __int16 v9; // [sp+1Eh] [bp-1Ah]@13
  __int16 v10; // [sp+20h] [bp-18h]@13

  v1 = 0;
  if ( !LangId )
  {
    v2 = ResetThreadUIPreferredLanguage();
    v3 = RtlNtStatusToDosError(v2);
    v1 = GetThreadUILanguage();
    goto LABEL_3;
  }
  if ( LangId == 1024 || LangId == 2048 || LangId == 3072 || LangId == 5120 || LangId == 4096 )
  {
    v3 = 50;
LABEL_3:
    if ( !v3 )
      goto LABEL_4;
LABEL_18:
    v1 = GetThreadUILanguage();
    goto LABEL_5;
  }
  v7 = 0;
  v6 = LangId;
  if ( !NlsValidateLocale(&v6, 0) )
  {
    v3 = 2;
    goto LABEL_18;
  }
  if ( NlsConvertIntegerToHexStringW(LangId, 1, (unsigned int)&v8, 5u) != 1 )
    goto LABEL_17;
  v9 = 0;
  v10 = 0;
  v5 = RtlSetThreadPreferredUILanguages(4, &v8, &v7);
  v3 = RtlNtStatusToDosError(v5);
  if ( v3 )
    goto LABEL_18;
  if ( v7 != 1 )
    goto LABEL_17;
  v1 = LangId;
LABEL_4:
  if ( !v1 )
  {
LABEL_17:
    v3 = 1359;
    goto LABEL_18;
  }
LABEL_5:
  SetLastError(v3);
  return v1;
}
// 77DE1170: using guessed type int __stdcall RtlSetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);

//----- (77E3C2E4) --------------------------------------------------------
int __stdcall ResetThreadUIPreferredLanguage()
{
  char *v0; // esi@1
  int v1; // eax@1
  unsigned int v3; // ebx@10
  PVOID v4; // eax@10
  unsigned int v5; // [sp+Ch] [bp-220h]@1
  UINT v6; // [sp+10h] [bp-21Ch]@1
  int v7; // [sp+14h] [bp-218h]@1
  unsigned int v8; // [sp+18h] [bp-214h]@1
  int v9; // [sp+1Ch] [bp-210h]@1
  char Address; // [sp+20h] [bp-20Ch]@1

  v5 = 0;
  v7 = 0;
  v6 = 0;
  v0 = &Address;
  v8 = 260;
  v1 = RtlGetThreadPreferredUILanguages(64, &v7, &Address, &v8);
  v9 = v1;
  if ( v1 == -1073741789 )
  {
    if ( v8 > 0x104 )
    {
      v3 = v8;
      v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v8);
      v0 = (char *)v4;
      if ( !v4 )
        return v9;
      v5 = v3;
      v9 = RtlGetThreadPreferredUILanguages(64, &v7, v4, &v5);
    }
  }
  else if ( v1 >= 0 )
  {
    v0 = &Address;
  }
  if ( v0 )
  {
    if ( v9 >= 0 )
    {
      v6 = GetConsoleOutputCP();
      RtlSetThreadPreferredUILanguages(33024, 0, &v6);
      v9 = RtlSetThreadPreferredUILanguages(8, v0, &v7);
    }
    if ( v0 != &Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v0);
  }
  return v9;
}
// 77DE1170: using guessed type int __stdcall RtlSetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD);
// 77DE1178: using guessed type int __stdcall RtlGetThreadPreferredUILanguages(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E3C3BF) --------------------------------------------------------
BOOLEAN __stdcall ConsoleFreeCaptureBuffer(PVOID Address)
{
  return RtlFreeHeap(ConsolePortHeap, 0, Address);
}

//----- (77E3C40E) --------------------------------------------------------
int __stdcall ConsoleCaptureMessageBuffer(int a1, void *Src, size_t Size, int a4)
{
  int result; // eax@1

  result = CsrAllocateMessagePointer(a1, Size, a4);
  if ( Src )
  {
    if ( Size )
      result = (int)memmove(*(void **)a4, Src, Size);
  }
  return result;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);

//----- (77E3C438) --------------------------------------------------------
DWORD __stdcall GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
{
  return GetConsoleTitleInternal((int)lpConsoleTitle, nSize, 1, 0);
}

//----- (77E3C455) --------------------------------------------------------
size_t __stdcall GetConsoleTitleInternal(int a1, size_t cbDest, char a3, char a4)
{
  PVOID v4; // edi@2
  ULONG v6; // eax@10
  struct _PORT_MESSAGE RequestMessage; // [sp+18h] [bp-BCh]@3
  NTSTATUS NtStatus; // [sp+38h] [bp-9Ch]@3
  size_t Size; // [sp+40h] [bp-94h]@2
  wchar_t *pszSrc; // [sp+44h] [bp-90h]@3
  char v11; // [sp+48h] [bp-8Ch]@2
  char v12; // [sp+49h] [bp-8Bh]@2
  CPPEH_RECORD ms_exc; // [sp+BCh] [bp-18h]@4

  if ( !cbDest )
    return 0;
  Size = cbDest;
  v11 = a3;
  v12 = a4;
  v4 = ConsoleAllocateCaptureBuffer(1u, cbDest);
  if ( !v4 )
    return 0;
  ConsoleCaptureMessageBuffer((int)v4, 0, Size, (int)&pszSrc);
  ConsoleClientCallServer(&RequestMessage, (int)v4, 36, 12);
  if ( NtStatus < 0 )
  {
    ConsoleFreeCaptureBuffer(v4);
    v6 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v6);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( a3 )
    RtlStringCbCopyW((wchar_t *)a1, cbDest, pszSrc);
  else
    RtlStringCchCopyA((char *)a1, cbDest, (const char *)pszSrc);
  ms_exc.registration.TryLevel = -2;
  ConsoleFreeCaptureBuffer(v4);
  return Size;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C539) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCbCopyW(wchar_t *pszDest, size_t cbDest, const wchar_t *pszSrc)
{
  size_t v3; // ecx@1
  NTSTATUS result; // eax@1
  wchar_t *v5; // eax@4
  NTSTATUS v6; // ebx@4
  size_t v7; // esi@4
  int v8; // edi@5
  wchar_t v9; // cx@7

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || v3 > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v5 = pszDest;
    v6 = 0;
    v7 = cbDest >> 1;
    if ( !v3 )
      goto LABEL_16;
    v8 = 2147483646 - v3;
    do
    {
      if ( !(v8 + v7) )
        break;
      v9 = *(wchar_t *)((char *)v5 + (char *)pszSrc - (char *)pszDest);
      if ( !v9 )
        break;
      *v5 = v9;
      ++v5;
      --v7;
    }
    while ( v7 );
    if ( !v7 )
    {
LABEL_16:
      --v5;
      v6 = -2147483643;
    }
    *v5 = 0;
    result = v6;
  }
  return result;
}

//----- (77E3C5AD) --------------------------------------------------------
BOOL __stdcall NeedCurrentDirectoryForExePathWStub(LPCWSTR ExeName)
{
  return NeedCurrentDirectoryForExePathW(ExeName);
}

//----- (77E3C5C5) --------------------------------------------------------
int __stdcall SetConsoleInputExeNameW(void *Src)
{
  unsigned int v1; // eax@1
  unsigned int v2; // esi@1
  int result; // eax@3

  v1 = wcslen((const unsigned __int16 *)Src);
  v2 = v1;
  if ( v1 && v1 < 0x100 )
  {
    RtlEnterCriticalSection(&ExeNameCriticalSection);
    memcpy(ExeNameBuffer, Src, 2 * v2);
    ExeNameLength = v2;
    RtlLeaveCriticalSection(&ExeNameCriticalSection);
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6000: using guessed type __int16 ExeNameLength;
// 77EA60A0: using guessed type __int16 ExeNameBuffer[];

//----- (77E3C681) --------------------------------------------------------
signed int __stdcall CloseConsoleHandle(int a1)
{
  signed int result; // eax@2
  ULONG v2; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@1

  v5 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 34, 4);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C723) --------------------------------------------------------
signed int __stdcall DuplicateConsoleHandle(int a1, int a2, char a3, int a4)
{
  ULONG v5; // ST0C_4@9
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@3
  int v8; // [sp+28h] [bp-7Ch]@3
  int v9; // [sp+2Ch] [bp-78h]@3
  char v10; // [sp+30h] [bp-74h]@3
  int v11; // [sp+34h] [bp-70h]@3
  int v12; // [sp+38h] [bp-6Ch]@4

  if ( a4 & 0xFFFFFFFC || !(a4 & 2) && a2 & 0x3FFFFFFF )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    v11 = a4;
    v9 = a2;
    v8 = a1;
    v10 = a3;
    ConsoleClientCallServer(&RequestMessage, 0, 31, 20);
    if ( NtStatus >= 0 )
      return v12;
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
  }
  return -1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3C798) --------------------------------------------------------
HRESULT StringCbPrintfW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszFormat, ...)
{
  size_t v3; // ecx@1
  HRESULT result; // eax@1
  int v5; // esi@4
  HRESULT v6; // ebx@4
  int v7; // eax@4
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, pszFormat);
  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || v3 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v5 = v3 - 1;
    v6 = 0;
    v7 = __vsnwprintf(pszDest, v3 - 1, pszFormat, va);
    if ( v7 < 0 || v7 > (unsigned int)v5 )
    {
      v6 = -2147024774;
    }
    else if ( v7 != v5 )
    {
      return v6;
    }
    pszDest[v5] = 0;
    return v6;
  }
  return result;
}

//----- (77E3C842) --------------------------------------------------------
int __stdcall IsSystemLUID()
{
  NTSTATUS v0; // esi@2
  int result; // eax@4
  ULONG ReturnLength; // [sp+0h] [bp-44h]@2
  HANDLE TokenHandle; // [sp+4h] [bp-40h]@1
  char TokenInformation; // [sp+8h] [bp-3Ch]@2
  int v5; // [sp+10h] [bp-34h]@3
  int v6; // [sp+14h] [bp-30h]@7

  result = 1;
  if ( NtOpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) >= 0 )
  {
    v0 = NtQueryInformationToken(TokenHandle, TokenStatistics, &TokenInformation, 0x38u, &ReturnLength);
    NtClose(TokenHandle);
    if ( v0 >= 0 && (v5 != 999 || v6) )
      result = 0;
  }
  return result;
}

//----- (77E3C8B1) --------------------------------------------------------
int __stdcall QueryActCtxSettingsW(int a1, int a2, PCWSTR SourceString, int a4, int a5, int a6, int a7)
{
  NTSTATUS v7; // eax@7
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-14h]@15
  LSA_UNICODE_STRING String2; // [sp+10h] [bp-Ch]@15
  int v11; // [sp+18h] [bp-4h]@1

  v11 = 0;
  if ( a7 )
    *(_DWORD *)a7 = 0;
  if ( a1 )
  {
    BaseSetLastNTError(-1073741585);
  }
  else if ( a4 )
  {
    if ( a6 && !a5 )
    {
      BaseSetLastNTError(-1073741811);
    }
    else if ( SourceString
           && (RtlInitUnicodeString(&DestinationString, SourceString),
               RtlInitUnicodeString(&String2, L"http://schemas.microsoft.com/SMI/2005/WindowsSettings"),
               RtlCompareUnicodeString(&DestinationString, &String2, 0)) )
    {
      BaseSetLastNTError(-1073741583);
    }
    else
    {
      v7 = RtlQueryActivationContextApplicationSettings(0, a2, 0, a4, a5, a6, a7);
      if ( v7 >= 0 )
        v11 = 1;
      else
        BaseSetLastNTError(v7);
    }
  }
  else
  {
    BaseSetLastNTError(-1073741582);
  }
  return v11;
}
// 77DE1174: using guessed type int __stdcall RtlQueryActivationContextApplicationSettings(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E3C92A) --------------------------------------------------------
BOOL __stdcall FreeEnvironmentStringsAStub(LPCH a1)
{
  return FreeEnvironmentStringsA(a1);
}

//----- (77E3C954) --------------------------------------------------------
int __stdcall CreateProcessInternalA(int a1, ULONG a2, ULONG Flags, int a4, int a5, int a6, int a7, int a8, ULONG a9, int a10, int a11, int a12)
{
  int result; // eax@2
  const char *v13; // eax@9
  int *v14; // edi@13
  int v15; // eax@18
  int v16; // eax@22
  int v17; // eax@24
  WCHAR *v18; // eax@24
  int v19; // eax@30
  int v20; // eax@32
  WCHAR *v21; // eax@32
  int v22; // eax@37
  int v23; // eax@39
  WCHAR *v24; // eax@39
  int v25; // [sp+10h] [bp-98h]@3
  WCHAR *v26; // [sp+14h] [bp-94h]@3
  WCHAR *v27; // [sp+18h] [bp-90h]@3
  WCHAR *v28; // [sp+1Ch] [bp-8Ch]@3
  int v29; // [sp+54h] [bp-54h]@4
  LSA_UNICODE_STRING v30; // [sp+58h] [bp-50h]@3
  LSA_UNICODE_STRING v31; // [sp+60h] [bp-48h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+68h] [bp-40h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+70h] [bp-38h]@24
  STRING AnsiString; // [sp+78h] [bp-30h]@18
  int *v35; // [sp+80h] [bp-28h]@3
  int v36; // [sp+88h] [bp-20h]@18
  int v37; // [sp+8Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+90h] [bp-18h]@5

  v37 = 0;
  if ( Flags )
  {
    result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)Flags);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;
  }
  v31.Length = 0;
  v31.MaximumLength = 0;
  v31.Buffer = 0;
  v30.Length = 0;
  v30.MaximumLength = 0;
  v30.Buffer = 0;
  qmemcpy(&v25, (const void *)a10, 0x44u);
  v35 = &v25;
  v25 = 72;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if ( a7 & 0x80000 )
    v29 = *(_DWORD *)(a10 + 68);
  else
    v29 = 0;
  ms_exc.registration.TryLevel = 1;
  if ( a2 && !Basep8BitStringToDynamicUnicodeString((int)&v31, (PCSZ)a2)
    || a9 && !Basep8BitStringToDynamicUnicodeString((int)&v30, (PCSZ)a9) )
    goto LABEL_15;
  v13 = *(const char **)(a10 + 4);
  if ( v13 )
  {
    ms_exc.registration.TryLevel = 2;
    v15 = RtlInitAnsiStringEx(&AnsiString, v13);
    v36 = v15;
    ms_exc.registration.TryLevel = 1;
    if ( v15 < 0 )
      goto LABEL_19;
    if ( (_BYTE)NlsMbCodePageTag )
      LOWORD(v16) = RtlxAnsiStringToUnicodeSize(&AnsiString);
    else
      v16 = 2 * AnsiString.Length + 2;
    DestinationString.MaximumLength = v16;
    v17 = KernelBaseGetGlobalData();
    v18 = (WCHAR *)RtlAllocateHeap(
                     NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                     *(_DWORD *)(v17 + 44),
                     DestinationString.MaximumLength);
    v26 = v18;
    if ( !v18 )
      goto LABEL_25;
    DestinationString.Buffer = v18;
    v15 = RtlAnsiStringToUnicodeString(&DestinationString, &AnsiString, 0);
    v36 = v15;
    if ( v15 < 0 )
      goto LABEL_19;
  }
  if ( *(_DWORD *)(a10 + 8) )
  {
    v15 = RtlInitAnsiStringEx(&AnsiString, *(PCSZ *)(a10 + 8));
    v36 = v15;
    if ( v15 < 0 )
      goto LABEL_19;
    if ( (_BYTE)NlsMbCodePageTag )
      LOWORD(v19) = RtlxAnsiStringToUnicodeSize(&AnsiString);
    else
      v19 = 2 * AnsiString.Length + 2;
    DestinationString.MaximumLength = v19;
    v20 = KernelBaseGetGlobalData();
    v21 = (WCHAR *)RtlAllocateHeap(
                     NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                     *(_DWORD *)(v20 + 44),
                     DestinationString.MaximumLength);
    v27 = v21;
    if ( !v21 )
      goto LABEL_25;
    DestinationString.Buffer = v21;
    v15 = RtlAnsiStringToUnicodeString(&DestinationString, &AnsiString, 0);
    v36 = v15;
    if ( v15 < 0 )
    {
LABEL_19:
      BaseSetLastNTError(v15);
LABEL_15:
      v37 = 0;
      ms_exc.registration.TryLevel = 0;
      goto LABEL_13;
    }
  }
  if ( *(_DWORD *)(a10 + 12) )
  {
    v15 = RtlInitAnsiStringEx(&AnsiString, *(PCSZ *)(a10 + 12));
    v36 = v15;
    if ( v15 >= 0 )
    {
      if ( (_BYTE)NlsMbCodePageTag )
        LOWORD(v22) = RtlxAnsiStringToUnicodeSize(&AnsiString);
      else
        v22 = 2 * AnsiString.Length + 2;
      DestinationString.MaximumLength = v22;
      v23 = KernelBaseGetGlobalData();
      v24 = (WCHAR *)RtlAllocateHeap(
                       NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                       *(_DWORD *)(v23 + 44),
                       DestinationString.MaximumLength);
      v28 = v24;
      if ( v24 )
      {
        DestinationString.Buffer = v24;
        v15 = RtlAnsiStringToUnicodeString(&DestinationString, &AnsiString, 0);
        v36 = v15;
        if ( v15 >= 0 )
          goto LABEL_12;
        goto LABEL_19;
      }
LABEL_25:
      BaseSetLastNTError(-1073741801);
      goto LABEL_15;
    }
    goto LABEL_19;
  }
LABEL_12:
  ms_exc.registration.TryLevel = 0;
  v37 = CreateProcessInternalW(
          (void *)a1,
          v31.Buffer,
          UnicodeString.Buffer,
          a4,
          a5,
          a6,
          a7,
          a8,
          v30.Buffer,
          (int)&v25,
          a11,
          a12);
LABEL_13:
  ms_exc.registration.TryLevel = -2;
  RtlFreeUnicodeString(&UnicodeString);
  RtlFreeUnicodeString(&v31);
  RtlFreeUnicodeString(&v30);
  v14 = v35;
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v35[1]);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v14[2]);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v14[3]);
  return v37;
}

//----- (77E3D19F) --------------------------------------------------------
BOOL __stdcall GetUILanguageInfoStub(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
{
  return GetUILanguageInfo(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
}

//----- (77E3D1B7) --------------------------------------------------------
DWORD __stdcall GetPriorityClassStub(HANDLE hProcess)
{
  return GetPriorityClass(hProcess);
}

//----- (77E3D1CF) --------------------------------------------------------
BOOL __stdcall CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  PVOID v3; // esi@1
  NTSTATUS v4; // eax@5
  int v5; // eax@7
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-54h]@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-3Ch]@5
  LSA_UNICODE_STRING ntname; // [sp+30h] [bp-34h]@3
  LSA_UNICODE_STRING v10; // [sp+38h] [bp-2Ch]@3
  PVOID Address; // [sp+40h] [bp-24h]@1
  HANDLE FileHandle; // [sp+44h] [bp-20h]@1
  unsigned __int8 v13; // [sp+4Bh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@3

  v3 = 0;
  Address = 0;
  FileHandle = (HANDLE)-1;
  v13 = 0;
  if ( !lpFileName || !lpExistingFileName )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  ntname.Buffer = 0;
  v10.Buffer = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !RtlDosPathNameToNtPathName_U((PWSTR)lpExistingFileName, &ntname, 0, 0) )
    goto LABEL_29;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  if ( lpSecurityAttributes )
    ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
  v4 = NtOpenFile(&FileHandle, 0x100100u, &ObjectAttributes, &IoStatusBlock, 7u, 0x204020u);
  if ( v4 < 0 )
  {
LABEL_21:
    BaseSetLastNTError(v4);
    goto LABEL_10;
  }
  if ( RtlDosPathNameToNtPathName_U((PWSTR)lpFileName, &v10, 0, 0) )
  {
    v5 = KernelBaseGetGlobalData();
    v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), v10.Length + 16);
    Address = v3;
    if ( v3 )
    {
      _memmove((char *)v3 + 12, v10.Buffer, v10.Length);
      *(_BYTE *)v3 = 0;
      *((_DWORD *)v3 + 1) = 0;
      *((_DWORD *)v3 + 2) = v10.Length;
      v4 = NtSetInformationFile(FileHandle, &IoStatusBlock, v3, v10.Length + 16, FileLinkInformation);
      if ( v4 >= 0 )
      {
        v13 = 1;
        goto LABEL_10;
      }
      goto LABEL_21;
    }
    RtlSetLastWin32Error(8);
  }
  else
  {
LABEL_29:
    RtlSetLastWin32Error(3);
  }
LABEL_10:
  ms_exc.registration.TryLevel = -2;
  if ( v3 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( FileHandle != (HANDLE)-1 )
    NtClose(FileHandle);
  if ( v10.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10.Buffer);
  if ( ntname.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
  return v13;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3D3C0) --------------------------------------------------------
int __stdcall BasepOfShareToWin32Share(char a1)
{
  int v1; // eax@1
  signed int v3; // [sp-4h] [bp-4h]@6

  v1 = a1 & 0x70;
  if ( v1 == 48 )
  {
    v3 = 2;
  }
  else
  {
    if ( v1 == 32 )
      return 1;
    if ( v1 != 64 )
      return v1 != 16 ? 3 : 0;
    v3 = 3;
  }
  return v3;
}

//----- (77E3D607) --------------------------------------------------------
HFILE __stdcall OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
{
  DWORD v3; // edi@2
  __int16 v4; // dx@3
  int v5; // ecx@3
  DWORD v6; // eax@5
  DWORD v7; // eax@7
  HANDLE v8; // eax@11
  void *v9; // esi@11
  DWORD v11; // eax@23
  DWORD v12; // eax@32
  signed int v13; // esi@33
  NTSTATUS v14; // esi@37
  NTSTATUS v15; // edi@42
  BOOL v16; // eax@48
  char *v17; // esi@48
  char *v18; // edi@48
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+10h] [bp-ECh]@42
  STRING DestinationString; // [sp+18h] [bp-E4h]@36
  struct _FILETIME LastWriteTime; // [sp+20h] [bp-DCh]@48
  DWORD dwShareMode; // [sp+28h] [bp-D4h]@3
  LPOFSTRUCT v23; // [sp+2Ch] [bp-D0h]@1
  unsigned int VolumeInformation; // [sp+30h] [bp-CCh]@42
  char v25; // [sp+34h] [bp-C8h]@46
  LPSTR FilePart; // [sp+38h] [bp-C4h]@5
  int v27; // [sp+3Ch] [bp-C0h]@2
  DWORD dwCreationDisposition; // [sp+40h] [bp-BCh]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+44h] [bp-B8h]@1
  ULONG Arguments; // [sp+4Ch] [bp-B0h]@1
  ULONG MessageBoxResult; // [sp+50h] [bp-ACh]@3
  HANDLE hObject; // [sp+54h] [bp-A8h]@1
  char v33; // [sp+58h] [bp-A4h]@1
  __int16 v34; // [sp+5Ch] [bp-A0h]@52
  __int16 v35; // [sp+5Eh] [bp-9Eh]@53
  char v36; // [sp+60h] [bp-9Ch]@54
  CPPEH_RECORD ms_exc; // [sp+E4h] [bp-18h]@1

  UnicodeString.Buffer = (PWCH)lpFileName;
  v23 = lpReOpenBuff;
  Arguments = 0;
  qmemcpy(&v33, lpReOpenBuff, 0x88u);
  hObject = (HANDLE)-1;
  ms_exc.registration.TryLevel = 0;
  RtlSetLastWin32Error(0);
  if ( uStyle & 0x100 )
  {
    if ( GetFullPathNameA((LPCSTR)UnicodeString.Buffer, 0x7Fu, lpReOpenBuff->szPathName, &FilePart) <= 0x7F )
    {
      lpReOpenBuff->cBytes = -120;
      lpReOpenBuff->fFixedDisk = 1;
      lpReOpenBuff->nErrCode = 0;
      lpReOpenBuff->Reserved1 = 0;
      lpReOpenBuff->Reserved2 = 0;
      hObject = 0;
      goto LABEL_13;
    }
LABEL_14:
    RtlSetLastWin32Error(13);
    goto LABEL_56;
  }
  v3 = (uStyle & 1) != 0 ? 0x40000000 : 2147483648;
  v27 = (uStyle & 1) != 0 ? 0x40000000 : 2147483648;
  if ( uStyle & 2 )
  {
    v3 |= 0xC0000000;
    v27 = v3;
  }
  dwShareMode = BasepOfShareToWin32Share(uStyle);
  dwCreationDisposition = 3;
  MessageBoxResult = v4 & 0x1000;
  if ( v4 & 0x1000 )
  {
    dwCreationDisposition = 2;
    v3 = v5;
    v27 = v5;
  }
  if ( !(v4 & 0x8000) )
  {
    v6 = SearchPathA(0, (LPCSTR)UnicodeString.Buffer, 0, 0x7Fu, lpReOpenBuff->szPathName, &FilePart);
    if ( v6 > 0x7F )
      goto LABEL_14;
    if ( !v6 )
    {
      Arguments = 1;
      v7 = GetFullPathNameA((LPCSTR)UnicodeString.Buffer, 0x7Fu, lpReOpenBuff->szPathName, &FilePart);
      if ( !v7 || v7 > 0x7F )
        goto LABEL_14;
    }
  }
  if ( uStyle & 0x4000 && !MessageBoxResult )
  {
    if ( !Arguments )
    {
      v11 = GetFileAttributesA(lpReOpenBuff->szPathName);
      if ( v11 != -1 )
      {
        if ( v11 & 0x10 )
        {
          RtlSetLastWin32Error(5);
          goto LABEL_56;
        }
        goto LABEL_26;
      }
    }
    RtlSetLastWin32Error(2);
LABEL_56:
    hObject = (HANDLE)-1;
    goto LABEL_13;
  }
  if ( uStyle & 0x200 )
  {
    if ( DeleteFileA(lpReOpenBuff->szPathName) )
    {
      lpReOpenBuff->nErrCode = 0;
      lpReOpenBuff->cBytes = -120;
      hObject = HANDLE_FLAG_INHERIT;
      goto LABEL_13;
    }
    lpReOpenBuff->nErrCode = 2;
    goto LABEL_56;
  }
  while ( 1 )
  {
    v8 = CreateFileA(lpReOpenBuff->szPathName, v3, dwShareMode, 0, dwCreationDisposition, 0, 0);
    v9 = v8;
    hObject = v8;
    if ( v8 != (HANDLE)-1 )
      break;
    if ( uStyle & 0x2000 && !(GetErrorMode() & 0x8000) && !(RtlGetThreadErrorMode() & 0x40) )
    {
      v12 = GetLastError();
      if ( v12 == 2 )
      {
        v13 = -1073741809;
      }
      else
      {
        if ( v12 != 3 )
          goto LABEL_13;
        v13 = -1073741766;
      }
      RtlInitAnsiString(&DestinationString, lpReOpenBuff->szPathName);
      if ( RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u) >= 0 )
      {
        Arguments = (ULONG)&UnicodeString;
        v14 = NtRaiseHardError(v13 | 0x10000000, 1u, 1u, &Arguments, 3u, &MessageBoxResult);
        RtlFreeUnicodeString(&UnicodeString);
        if ( v14 >= 0 && MessageBoxResult == 7 )
          continue;
      }
    }
    goto LABEL_13;
  }
  if ( uStyle & 0x4000 )
  {
    CloseHandle(v8);
LABEL_26:
    hObject = HANDLE_FLAG_INHERIT;
    lpReOpenBuff->cBytes = -120;
    goto LABEL_13;
  }
  v15 = NtQueryVolumeInformationFile(v8, &IoStatusBlock, &VolumeInformation, 8u, FileFsDeviceInformation);
  if ( v15 < 0 )
  {
    CloseHandle(v9);
    BaseSetLastNTError(v15);
    goto LABEL_56;
  }
  if ( VolumeInformation < 7 || VolumeInformation > 8 )
    lpReOpenBuff->fFixedDisk = 0;
  else
    lpReOpenBuff->fFixedDisk = ~v25 & 1;
  v16 = GetFileTime(v9, 0, 0, &LastWriteTime);
  v17 = (char *)&lpReOpenBuff->Reserved1;
  v18 = (char *)&lpReOpenBuff->Reserved2;
  if ( !v16 || !FileTimeToDosDateTime(&LastWriteTime, &lpReOpenBuff->Reserved1, &lpReOpenBuff->Reserved2) )
  {
    *(_WORD *)v17 = 0;
    *(_WORD *)v18 = 0;
  }
  lpReOpenBuff->cBytes = -120;
  if ( uStyle & 0x400 && (v34 != *(_WORD *)v17 || v35 != *(_WORD *)v18 || strcmp(&v36, lpReOpenBuff->szPathName)) )
  {
    qmemcpy(lpReOpenBuff, &v33, 0x88u);
    CloseHandle(hObject);
    goto LABEL_56;
  }
LABEL_13:
  ms_exc.registration.TryLevel = -2;
  lpReOpenBuff->nErrCode = GetLastError();
  return (HFILE)hObject;
}
// 77DE141C: using guessed type _DWORD __stdcall RtlGetThreadErrorMode();
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3D7BF) --------------------------------------------------------
int __stdcall BasepSxsCreateProcessCsrMessage(int a1, int a2, int a3, int a4, int a5, int a6, PHANDLE FileHandle, int a8, PHANDLE a9, int a10, PHANDLE a11, int a12, int Buffer, void *Dst)
{
  int v14; // eax@1
  int v15; // ebx@1
  int v16; // eax@2
  int v17; // eax@4
  int v19; // eax@13
  int v20; // ebx@15
  int v21; // eax@19
  int v22; // ecx@19
  int v23; // [sp+8h] [bp-20h]@2
  int v24; // [sp+Ch] [bp-1Ch]@2
  int v25; // [sp+10h] [bp-18h]@2
  int v26; // [sp+14h] [bp-14h]@2
  int v27; // [sp+18h] [bp-10h]@1
  int v28; // [sp+1Ch] [bp-Ch]@1
  int v29; // [sp+20h] [bp-8h]@1
  int v30; // [sp+24h] [bp-4h]@1

  v27 = *(_DWORD *)a6;
  v28 = *(_DWORD *)(a6 + 4);
  v14 = *(_DWORD *)(a10 + 4);
  v29 = *(_DWORD *)a10;
  v30 = v14;
  memset(Dst, 0, 0x88u);
  v15 = BasepSxsGetProcessImageBaseAddress((int)a9, Buffer);
  if ( v15 >= 0 )
  {
    v16 = *(_DWORD *)a8;
    v23 = **(_DWORD **)a8;
    v24 = *(_DWORD *)(v16 + 4);
    v25 = SxsManifestSuffix;
    v26 = (int)L".Manifest";
    v15 = RtlMultiAppendUnicodeStringBuffer(*(_DWORD *)a6, 2, &v23);
    if ( v15 >= 0 )
    {
      v25 = SxsPolicySuffix;
      v26 = (int)L".Config";
      v15 = RtlMultiAppendUnicodeStringBuffer(*(_DWORD *)a10, 2, &v23);
      if ( v15 >= 0 )
      {
        v17 = *(_DWORD *)(a8 + 4);
        v23 = *(_DWORD *)v17;
        v24 = *(_DWORD *)(v17 + 4);
        v25 = SxsManifestSuffix;
        v26 = (int)L".Manifest";
        v15 = RtlMultiAppendUnicodeStringBuffer(*(_DWORD *)(a6 + 4), 2, &v23);
        if ( v15 >= 0 )
        {
          v25 = SxsPolicySuffix;
          v26 = (int)L".Config";
          v15 = RtlMultiAppendUnicodeStringBuffer(*(_DWORD *)(a10 + 4), 2, &v23);
          if ( v15 >= 0 )
          {
            v15 = BasepSxsCreateStreams(
                    0,
                    0x1200A9u,
                    a1,
                    a2,
                    1,
                    a3,
                    a4,
                    a5,
                    (int)&v27,
                    FileHandle,
                    a8,
                    a9,
                    1u,
                    (int)&v29,
                    a11,
                    (int)Dst,
                    (int)((char *)Dst + 8),
                    (int)((char *)Dst + 48));
            if ( BasepSxsIsStatusFileNotFoundEtc(v15) || BasepSxsIsStatusResourceNotFound(v15) )
              v15 = 0;
            if ( v15 >= 0 )
            {
              if ( *(_DWORD *)Dst )
              {
                *(_WORD *)a12 = 0;
                v19 = **(_WORD **)a8 + 2;
                if ( (unsigned int)v19 > 0xFFFE )
                  return -1073741562;
                v20 = a12 + 8;
                if ( (a12 == -8 || (unsigned int)v19 > *(_DWORD *)(a12 + 16))
                  && RtlpEnsureBufferSize(0, a12 + 8, **(_WORD **)a8 + 2) < 0 )
                  return -1073741801;
                v21 = *(_DWORD *)v20;
                *(_DWORD *)(a12 + 4) = *(_DWORD *)v20;
                _memmove(
                  (void *)(v21 + 2 * ((unsigned int)*(_WORD *)a12 >> 1)),
                  *(const void **)(*(_DWORD *)a8 + 4),
                  **(_WORD **)a8);
                v22 = *(_DWORD *)(a12 + 4);
                *(_WORD *)(a12 + 2) = *(_WORD *)a12 + **(_WORD **)a8 + 2;
                *(_WORD *)a12 += **(_WORD **)a8;
                *(_WORD *)(v22 + 2 * ((unsigned int)*(_WORD *)a12 >> 1)) = 0;
                v15 = RtlpApplyLengthFunction(0, 36, a12, RtlGetLengthWithoutLastFullDosOrNtPathElement);
                if ( v15 < 0 )
                  return v15;
                *(_WORD *)(*(_DWORD *)(a12 + 4) + 2 * ((unsigned int)*(_WORD *)a12 >> 1)) = 0;
                *((_DWORD *)Dst + 22) = *(_DWORD *)a12;
                *((_DWORD *)Dst + 23) = *(_DWORD *)(a12 + 4);
              }
              v15 = 0;
            }
          }
        }
      }
    }
  }
  return v15;
}
// 77DE1180: using guessed type int __stdcall RtlMultiAppendUnicodeStringBuffer(_DWORD, _DWORD, _DWORD);
// 77DE1184: using guessed type int __stdcall RtlpEnsureBufferSize(_DWORD, _DWORD, _DWORD);
// 77DE1188: using guessed type int RtlGetLengthWithoutLastFullDosOrNtPathElement;
// 77DE118C: using guessed type int __stdcall RtlpApplyLengthFunction(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E26858: using guessed type int SxsPolicySuffix;
// 77E26860: using guessed type wchar_t a_config[8];
// 77E26A54: using guessed type int SxsManifestSuffix;

//----- (77E3D93A) --------------------------------------------------------
NTSTATUS __stdcall BasepSxsGetProcessImageBaseAddress(int a1, int Buffer)
{
  NTSTATUS result; // eax@1
  int v3; // eax@2

  result = NtReadVirtualMemory(*(HANDLE *)(a1 + 4), (PVOID)(Buffer + 8), &Buffer, 4u, 0);
  if ( result >= 0 )
  {
    v3 = Buffer;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = v3;
    result = 0;
  }
  return result;
}

//----- (77E3D9AD) --------------------------------------------------------
NTSTATUS __stdcall BasepCheckDotLocalExists(int a1, int a2)
{
  USHORT v2; // ax@1
  PVOID v3; // esi@2
  NTSTATUS v4; // edi@3
  LSA_UNICODE_STRING Destination; // [sp+4h] [bp-8h]@2

  v2 = *(_WORD *)a1;
  if ( *(_WORD *)a1 > 0xFFF1u )
  {
    v4 = -1073741562;
  }
  else
  {
    Destination.Length = *(_WORD *)a1;
    Destination.MaximumLength = v2 + 14;
    v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (unsigned __int16)(v2 + 14));
    if ( v3 )
    {
      memcpy(v3, *(const void **)(a1 + 4), *(_WORD *)a1);
      Destination.Buffer = (PWCH)v3;
      v4 = RtlAppendUnicodeToString(&Destination, L".Local");
      if ( v4 >= 0 )
      {
        *((_WORD *)v3 + ((unsigned int)Destination.Length >> 1)) = 0;
        *(_DWORD *)a2 = RtlDoesFileExists_U((PWSTR)v3);
      }
    }
    else
    {
      v4 = -1073741801;
    }
    if ( v3 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  }
  return v4;
}

//----- (77E3DABB) --------------------------------------------------------
int __stdcall EnumTableGetRootState(int a1, int a2)
{
  int v2; // eax@1

  v2 = GetCurrentThreadId();
  *(_DWORD *)a2 = StateObjectListFind(a1 + 28, v2) + 32;
  return 0;
}

//----- (77E3DB56) --------------------------------------------------------
int __stdcall EnumTableUpdateRootState(int a1, void *Dst, int a3, int a4)
{
  int result; // eax@2

  if ( a4 )
    result = EnumStateInit(Dst, 0, 0, 1, 0);
  else
    result = EnumStateCopy((int)Dst, a3);
  if ( result < 0 )
    result = (int)EnumStateClear(Dst);
  return result;
}

//----- (77E3DB81) --------------------------------------------------------
signed int __stdcall EnumStateCopy(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // edx@4
  int v7; // eax@4
  PVOID v8; // edi@4
  PVOID v10; // eax@19
  const void **v11; // [sp+Ch] [bp-Ch]@4
  PVOID Address; // [sp+10h] [bp-8h]@4
  signed int v13; // [sp+14h] [bp-4h]@1
  void *v14; // [sp+24h] [bp+Ch]@3

  v2 = a2;
  v13 = 0;
  v3 = a1;
  *(_DWORD *)(v3 + 12) ^= (*(_DWORD *)(a2 + 12) ^ *(_DWORD *)(a1 + 12)) & 1;
  *(_DWORD *)(v3 + 12) ^= ((unsigned __int8)*(_DWORD *)(v3 + 12) ^ (unsigned __int8)*(_DWORD *)(a2 + 12)) & 6;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  v4 = *(_DWORD *)(a1 + 40);
  if ( v4 && v4 != a1 + 56 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(a1 + 40));
    *(_DWORD *)(a1 + 40) = 0;
    v3 = a1;
  }
  v14 = (void *)(v3 + 344);
  v5 = *(_DWORD *)(v3 + 344);
  if ( v5 && v5 != v3 + 360 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v3 + 344));
    *(_DWORD *)v14 = 0;
    v3 = a1;
  }
  v6 = v3 + 40;
  qmemcpy((void *)(v3 + 40), (const void *)(v2 + 40), 0x130u);
  v11 = (const void **)(v2 + 344);
  qmemcpy(v14, (const void *)(v2 + 344), 0x130u);
  v7 = *(_DWORD *)(v2 + 40);
  v8 = 0;
  Address = 0;
  if ( v7 && v7 != v2 + 56 )
  {
    v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(_DWORD *)(v2 + 44));
    if ( !v8 )
      v13 = -1073741801;
    *(_DWORD *)(a1 + 40) = v8;
    memcpy(v8, *(const void **)(v2 + 40), *(_DWORD *)(v2 + 44));
  }
  else if ( *(_DWORD *)v6 )
  {
    *(_DWORD *)v6 = a1 + 56;
  }
  if ( *v11 && *v11 != (const void *)(v2 + 360) )
  {
    v10 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(_DWORD *)(v2 + 348));
    Address = v10;
    if ( !v10 )
      v13 = -1073741801;
    *(_DWORD *)v14 = v10;
    memcpy(v10, *v11, *(_DWORD *)(v2 + 348));
  }
  else if ( *(_DWORD *)v14 )
  {
    *(_DWORD *)v14 = a1 + 360;
  }
  if ( v13 < 0 )
  {
    if ( v8 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return v13;
}

//----- (77E3DCC5) --------------------------------------------------------
BOOL __stdcall SetNamedPipeHandleStateStub(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
{
  return SetNamedPipeHandleState(hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
}

//----- (77E3DCDD) --------------------------------------------------------
BOOL __stdcall DisconnectNamedPipeStub(HANDLE hNamedPipe)
{
  return DisconnectNamedPipe(hNamedPipe);
}

//----- (77E3DD84) --------------------------------------------------------
BOOL __stdcall EnumDateFormatsExExStub(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
{
  return EnumDateFormatsExEx(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
}

//----- (77E3DD9C) --------------------------------------------------------
BOOL __stdcall EnumTimeFormatsExStub(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
{
  return EnumTimeFormatsEx(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
}

//----- (77E3DDB4) --------------------------------------------------------
BOOL __stdcall IsValidLocaleNameStub(LPCWSTR lpLocaleName)
{
  return IsValidLocaleName(lpLocaleName);
}

//----- (77E3DE18) --------------------------------------------------------
int __stdcall FindNLSStringExStub(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
{
  return FindNLSStringEx(
           lpLocaleName,
           dwFindNLSStringFlags,
           lpStringSource,
           cchSource,
           lpStringValue,
           cchValue,
           pcchFound,
           lpVersionInformation,
           lpReserved,
           lParam);
}

//----- (77E3DE6A) --------------------------------------------------------
int __stdcall FindFirstIndexOfString(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  unsigned int v4; // eax@2
  signed __int16 v5; // bx@3
  unsigned int v6; // eax@4
  int v7; // ecx@7
  unsigned int *v8; // eax@7
  int v9; // eax@8
  int result; // eax@9
  int v11; // ecx@13
  unsigned int v12; // eax@13
  int v13; // eax@18
  unsigned int v14; // edx@19
  int v15; // edx@21
  int v16; // ecx@23
  int v17; // eax@24
  int v18; // edx@24
  int v19; // ecx@27
  int v20; // edi@32
  int v21; // eax@32
  int v22; // eax@38
  unsigned int v23; // edx@39
  int v24; // edx@43
  int v25; // ecx@45
  int v26; // eax@46
  int v27; // edx@46
  int v28; // ecx@51
  int v29; // edi@56
  int v30; // eax@56
  int v31; // eax@62
  unsigned int v32; // edx@63
  int v33; // edx@67
  int v34; // ecx@69
  int v35; // eax@70
  int v36; // edx@70
  int v37; // ecx@75
  int v38; // edi@80
  int v39; // eax@80
  int v40; // eax@86
  unsigned int v41; // edx@87
  int v42; // edx@91
  int v43; // ecx@93
  int v44; // eax@94
  int v45; // edx@94
  int v46; // ecx@99
  int v47; // edi@104
  int v48; // eax@104
  int v49; // eax@110
  unsigned int v50; // edx@111
  int v51; // edi@115
  int v52; // ecx@115
  int v53; // edi@117
  int v54; // ecx@117
  int v55; // edx@118
  int v56; // eax@118
  int v57; // edx@123
  int v58; // edi@128
  int v59; // eax@128
  int v60; // eax@134
  unsigned int v61; // edx@135
  int v62; // edi@139
  int v63; // ecx@139
  int v64; // edi@141
  int v65; // ecx@141
  int v66; // edx@142
  int v67; // eax@142
  int v68; // edx@147
  int v69; // edi@152
  int v70; // eax@152
  int v71; // eax@158
  unsigned int v72; // edx@159
  int v73; // edi@163
  int v74; // eax@163
  int v75; // edi@165
  int v76; // ecx@165
  int v77; // edx@166
  int v78; // eax@166
  int v79; // edx@171
  int v80; // edi@176
  int v81; // eax@176
  unsigned __int16 *v82; // [sp+8h] [bp-28h]@15
  int v83; // [sp+Ch] [bp-24h]@1
  int v84; // [sp+10h] [bp-20h]@18
  int v85; // [sp+10h] [bp-20h]@50
  int v86; // [sp+10h] [bp-20h]@74
  int v87; // [sp+10h] [bp-20h]@98
  int v88; // [sp+10h] [bp-20h]@122
  int v89; // [sp+10h] [bp-20h]@146
  int v90; // [sp+10h] [bp-20h]@170
  int v91; // [sp+14h] [bp-1Ch]@26
  int v92; // [sp+14h] [bp-1Ch]@38
  int v93; // [sp+14h] [bp-1Ch]@62
  int v94; // [sp+14h] [bp-1Ch]@86
  int v95; // [sp+14h] [bp-1Ch]@110
  int v96; // [sp+14h] [bp-1Ch]@134
  int v97; // [sp+14h] [bp-1Ch]@158
  signed int v98; // [sp+18h] [bp-18h]@21
  int v99; // [sp+18h] [bp-18h]@43
  int v100; // [sp+18h] [bp-18h]@67
  int v101; // [sp+18h] [bp-18h]@91
  int v102; // [sp+18h] [bp-18h]@115
  int v103; // [sp+18h] [bp-18h]@139
  int v104; // [sp+18h] [bp-18h]@163
  int v105; // [sp+1Ch] [bp-14h]@21
  signed int v106; // [sp+1Ch] [bp-14h]@43
  signed int v107; // [sp+1Ch] [bp-14h]@67
  signed int v108; // [sp+1Ch] [bp-14h]@91
  signed int v109; // [sp+1Ch] [bp-14h]@115
  signed int v110; // [sp+1Ch] [bp-14h]@139
  signed int v111; // [sp+1Ch] [bp-14h]@163
  unsigned __int16 *v112; // [sp+20h] [bp-10h]@7
  int v113; // [sp+24h] [bp-Ch]@21
  int v114; // [sp+24h] [bp-Ch]@43
  int v115; // [sp+24h] [bp-Ch]@67
  int v116; // [sp+24h] [bp-Ch]@91
  int v117; // [sp+24h] [bp-Ch]@115
  int v118; // [sp+24h] [bp-Ch]@139
  int v119; // [sp+24h] [bp-Ch]@163
  int v120; // [sp+28h] [bp-8h]@19
  int v121; // [sp+28h] [bp-8h]@23
  int v122; // [sp+28h] [bp-8h]@39
  int v123; // [sp+28h] [bp-8h]@45
  int v124; // [sp+28h] [bp-8h]@63
  int v125; // [sp+28h] [bp-8h]@69
  int v126; // [sp+28h] [bp-8h]@87
  int v127; // [sp+28h] [bp-8h]@93
  int v128; // [sp+28h] [bp-8h]@111
  int v129; // [sp+28h] [bp-8h]@135
  int v130; // [sp+28h] [bp-8h]@159
  int v131; // [sp+2Ch] [bp-4h]@15

  v2 = a1;
  v3 = a1 + 52;
  v83 = *(_DWORD *)(a1 + 52);
  SkipUnsortable((int *)a1, a1 + 88);
  if ( *(_DWORD *)(v2 + 104) >= *(_DWORD *)(v2 + 92) )
  {
    *(_DWORD *)(a1 + 136) = 0;
    result = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 68);
    *(_DWORD *)v3 = v4;
    if ( v4 < *(_DWORD *)(a1 + 56) )
    {
      v5 = 255;
      while ( 1 )
      {
        *(_DWORD *)(v2 + 68) = *(_DWORD *)v3;
        *(_DWORD *)(v2 + 104) = *(_DWORD *)(v2 + 88);
        SkipUnsortable((int *)v2, v3);
        v6 = *(_DWORD *)(v2 + 68);
        if ( v6 >= *(_DWORD *)(v2 + 56) )
          goto LABEL_9;
        *(_DWORD *)v3 = v6;
        if ( LongCompareString(v2) == 2 )
        {
          *(_DWORD *)(v2 + 136) = (*(_DWORD *)(v2 + 68) - v83) >> 1;
          return (*(_DWORD *)v3 - v83) >> 1;
        }
        if ( a2 )
          goto LABEL_9;
        v7 = *(_DWORD *)v2;
        *(_DWORD *)(v2 + 68) = *(_DWORD *)v3;
        v8 = *(unsigned int **)(a1 + 68);
        v112 = *(unsigned __int16 **)(a1 + 68);
        if ( *(_DWORD *)(v7 + 232) )
          break;
LABEL_8:
        v9 = (int)((char *)v8 + 2);
        *(_DWORD *)v3 = v9;
        if ( (unsigned int)v9 >= *(_DWORD *)(v2 + 56) )
          goto LABEL_9;
      }
      *(_WORD *)(a1 + 82) = *(_WORD *)v8;
      v11 = *(_DWORD *)(*(_DWORD *)v2 + 224);
      v12 = *(_WORD *)v8;
      if ( v11 )
        v12 = *(_DWORD *)(v11 + 4 * (v12 >> 8)) + (unsigned __int8)v12;
      v131 = 0;
      *(_DWORD *)(a1 + 76) = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v12);
      v82 = v112;
      if ( (unsigned __int8)(*(_BYTE *)(a1 + 79) & ((unsigned __int8)(*(_BYTE *)(a1 + 77) - 3) != 0 ? v5 : 0) & 0xC0) != 64 )
      {
        if ( (unsigned __int8)(*(_BYTE *)(a1 + 79) & ((unsigned __int8)(*(_BYTE *)(a1 + 77) - 3) != 0 ? v5 : 0) & 0xC0) != 128 )
        {
          if ( (unsigned __int8)(*(_BYTE *)(a1 + 79) & ((unsigned __int8)(*(_BYTE *)(a1 + 77) - 3) != 0 ? v5 : 0) & 0xC0) != 192 )
          {
LABEL_186:
            v8 = (unsigned int *)v112;
            goto LABEL_8;
          }
          v13 = *(_DWORD *)v2;
          v84 = *(_DWORD *)(*(_DWORD *)v2 + 272);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 20) )
          {
            v120 = *(_DWORD *)(v13 + 236);
            v14 = *(_DWORD *)(a1 + 56);
            if ( (unsigned int)&v112[8 - (v120 == 0)] <= v14 )
            {
              v131 = NlsCountOfWCharsWithinRange(
                       v112,
                       v14,
                       8,
                       *(_WORD *)(*(_DWORD *)(v13 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v13 + 244) + 6),
                       v120,
                       *(_DWORD *)(a1 + 60));
              if ( v131 >= 8 )
              {
                v15 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 20) - 1;
                v98 = 0;
                v105 = 0;
                v113 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 20) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v2 + 236) && v131 >= 9 )
                {
                  v16 = *(_DWORD *)(a1 + 68);
                  v121 = *(_DWORD *)(*(_DWORD *)v2 + 224);
                  if ( v121 )
                  {
                    v17 = *(_DWORD *)(v121 + 4 * ((unsigned int)*(_WORD *)v16 >> 8))
                        + (unsigned __int16)(v5 & *(_WORD *)v16);
                    v18 = (*pSortTblPtrs)[11];
                    v2 = a1;
                  }
                  else
                  {
                    v18 = (*pSortTblPtrs)[11];
                    v17 = *(_WORD *)v16;
                  }
                  v91 = *(_DWORD *)(v18 + 4 * v17);
                  if ( v121 )
                  {
                    v2 = a1;
                    v19 = *(_DWORD *)(v18
                                    + 4
                                    * (*(_DWORD *)(v121 + 4 * ((unsigned int)*(_WORD *)(v16 + 2) >> 8))
                                     + (unsigned __int16)(v5 & *(_WORD *)(v16 + 2))));
                  }
                  else
                  {
                    v19 = *(_DWORD *)(v18 + 4 * *(_WORD *)(v16 + 2));
                  }
                  v15 = v113;
                  if ( !((v91 ^ v19) & 0xE7FFFFFF) )
                    v98 = 1;
                }
                if ( v15 >= 0 )
                {
                  while ( 1 )
                  {
                    v20 = (v105 + v113) / 2;
                    v21 = NlsCompareRgWChar(2 * v98 + *(_DWORD *)(a1 + 68), v84 + 20 * v20, 8);
                    if ( !v21 )
                      break;
                    if ( v21 >= 0 )
                      v105 = v20 + 1;
                    else
                      v113 = v20 - 1;
                    if ( v105 > v113 )
                    {
                      v2 = a1;
                      goto LABEL_38;
                    }
                  }
                  *(_DWORD *)(a1 + 76) = *(_DWORD *)(20 * v20 + v84 + 16);
                  if ( !v98 )
                    *(_DWORD *)(a1 + 68) += 14;
                  goto LABEL_184;
                }
              }
            }
          }
LABEL_38:
          v22 = *(_DWORD *)v2;
          v92 = *(_DWORD *)(*(_DWORD *)v2 + 268);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 18) )
          {
            v122 = *(_DWORD *)(v22 + 236);
            v23 = *(_DWORD *)(a1 + 56);
            if ( *(_DWORD *)(a1 + 68) + 2 * (7 - (unsigned int)(v122 == 0)) <= v23 )
            {
              if ( !v131 )
                v131 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(a1 + 68),
                         v23,
                         7,
                         *(_WORD *)(*(_DWORD *)(v22 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v22 + 244) + 6),
                         v122,
                         *(_DWORD *)(a1 + 60));
              if ( v131 >= 7 )
              {
                v24 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 18) - 1;
                v106 = 0;
                v99 = 0;
                v114 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 18) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v2 + 236) && v131 >= 8 )
                {
                  v25 = *(_DWORD *)(a1 + 68);
                  v123 = *(_DWORD *)(*(_DWORD *)v2 + 224);
                  if ( v123 )
                  {
                    v26 = *(_DWORD *)(v123 + 4 * ((unsigned int)*(_WORD *)v25 >> 8))
                        + (unsigned __int16)(v5 & *(_WORD *)v25);
                    v27 = (*pSortTblPtrs)[11];
                    v2 = a1;
                  }
                  else
                  {
                    v27 = (*pSortTblPtrs)[11];
                    v26 = *(_WORD *)v25;
                  }
                  v85 = *(_DWORD *)(v27 + 4 * v26);
                  if ( v123 )
                  {
                    v2 = a1;
                    v28 = *(_DWORD *)(v27
                                    + 4
                                    * (*(_DWORD *)(v123 + 4 * ((unsigned int)*(_WORD *)(v25 + 2) >> 8))
                                     + (unsigned __int16)(v5 & *(_WORD *)(v25 + 2))));
                  }
                  else
                  {
                    v28 = *(_DWORD *)(v27 + 4 * *(_WORD *)(v25 + 2));
                  }
                  v24 = v114;
                  if ( !((v85 ^ v28) & 0xE7FFFFFF) )
                    v106 = 1;
                }
                if ( v24 >= 0 )
                {
                  while ( 1 )
                  {
                    v29 = (v99 + v114) / 2;
                    v30 = NlsCompareRgWChar(2 * v106 + *(_DWORD *)(a1 + 68), v92 + 20 * v29, 7);
                    if ( !v30 )
                      break;
                    if ( v30 >= 0 )
                      v99 = v29 + 1;
                    else
                      v114 = v29 - 1;
                    if ( v99 > v114 )
                    {
                      v2 = a1;
                      goto LABEL_62;
                    }
                  }
                  *(_DWORD *)(a1 + 76) = *(_DWORD *)(20 * v29 + v92 + 16);
                  if ( !v106 )
                    *(_DWORD *)(a1 + 68) += 12;
                  goto LABEL_184;
                }
              }
            }
          }
LABEL_62:
          v31 = *(_DWORD *)v2;
          v93 = *(_DWORD *)(*(_DWORD *)v2 + 264);
          if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 16) )
          {
            v124 = *(_DWORD *)(v31 + 236);
            v32 = *(_DWORD *)(a1 + 56);
            if ( *(_DWORD *)(a1 + 68) + 2 * (6 - (unsigned int)(v124 == 0)) <= v32 )
            {
              if ( !v131 )
                v131 = NlsCountOfWCharsWithinRange(
                         *(unsigned __int16 **)(a1 + 68),
                         v32,
                         6,
                         *(_WORD *)(*(_DWORD *)(v31 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v31 + 244) + 6),
                         v124,
                         *(_DWORD *)(a1 + 60));
              if ( v131 >= 6 )
              {
                v33 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 16) - 1;
                v107 = 0;
                v100 = 0;
                v115 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 16) - 1;
                if ( *(_DWORD *)(*(_DWORD *)v2 + 236) && v131 >= 7 )
                {
                  v34 = *(_DWORD *)(a1 + 68);
                  v125 = *(_DWORD *)(*(_DWORD *)v2 + 224);
                  if ( v125 )
                  {
                    v35 = *(_DWORD *)(v125 + 4 * ((unsigned int)*(_WORD *)v34 >> 8))
                        + (unsigned __int16)(v5 & *(_WORD *)v34);
                    v36 = (*pSortTblPtrs)[11];
                    v2 = a1;
                  }
                  else
                  {
                    v36 = (*pSortTblPtrs)[11];
                    v35 = *(_WORD *)v34;
                  }
                  v86 = *(_DWORD *)(v36 + 4 * v35);
                  if ( v125 )
                  {
                    v2 = a1;
                    v37 = *(_DWORD *)(v36
                                    + 4
                                    * (*(_DWORD *)(v125 + 4 * ((unsigned int)*(_WORD *)(v34 + 2) >> 8))
                                     + (unsigned __int16)(v5 & *(_WORD *)(v34 + 2))));
                  }
                  else
                  {
                    v37 = *(_DWORD *)(v36 + 4 * *(_WORD *)(v34 + 2));
                  }
                  v33 = v115;
                  if ( !((v86 ^ v37) & 0xE7FFFFFF) )
                    v107 = 1;
                }
                if ( v33 >= 0 )
                {
                  while ( 1 )
                  {
                    v38 = (v100 + v115) / 2;
                    v39 = NlsCompareRgWChar(2 * v107 + *(_DWORD *)(a1 + 68), v93 + 16 * v38, 6);
                    if ( !v39 )
                      break;
                    if ( v39 >= 0 )
                      v100 = v38 + 1;
                    else
                      v115 = v38 - 1;
                    if ( v100 > v115 )
                    {
                      v2 = a1;
                      goto LABEL_86;
                    }
                  }
                  *(_DWORD *)(a1 + 76) = *(_DWORD *)(16 * v38 + v93 + 12);
                  if ( !v107 )
                    *(_DWORD *)(a1 + 68) += 10;
                  goto LABEL_184;
                }
              }
            }
          }
        }
LABEL_86:
        v40 = *(_DWORD *)v2;
        v94 = *(_DWORD *)(*(_DWORD *)v2 + 260);
        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 14) )
        {
          v126 = *(_DWORD *)(v40 + 236);
          v41 = *(_DWORD *)(a1 + 56);
          if ( *(_DWORD *)(a1 + 68) + 2 * (5 - (unsigned int)(v126 == 0)) <= v41 )
          {
            if ( !v131 )
              v131 = NlsCountOfWCharsWithinRange(
                       *(unsigned __int16 **)(a1 + 68),
                       v41,
                       5,
                       *(_WORD *)(*(_DWORD *)(v40 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v40 + 244) + 6),
                       v126,
                       *(_DWORD *)(a1 + 60));
            if ( v131 >= 5 )
            {
              v42 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 14) - 1;
              v108 = 0;
              v101 = 0;
              v116 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 14) - 1;
              if ( *(_DWORD *)(*(_DWORD *)v2 + 236) && v131 >= 6 )
              {
                v43 = *(_DWORD *)(a1 + 68);
                v127 = *(_DWORD *)(*(_DWORD *)v2 + 224);
                if ( v127 )
                {
                  v44 = *(_DWORD *)(v127 + 4 * ((unsigned int)*(_WORD *)v43 >> 8))
                      + (unsigned __int16)(v5 & *(_WORD *)v43);
                  v45 = (*pSortTblPtrs)[11];
                  v2 = a1;
                }
                else
                {
                  v45 = (*pSortTblPtrs)[11];
                  v44 = *(_WORD *)v43;
                }
                v87 = *(_DWORD *)(v45 + 4 * v44);
                if ( v127 )
                {
                  v2 = a1;
                  v46 = *(_DWORD *)(v45
                                  + 4
                                  * (*(_DWORD *)(v127 + 4 * ((unsigned int)*(_WORD *)(v43 + 2) >> 8))
                                   + (unsigned __int16)(v5 & *(_WORD *)(v43 + 2))));
                }
                else
                {
                  v46 = *(_DWORD *)(v45 + 4 * *(_WORD *)(v43 + 2));
                }
                v42 = v116;
                if ( !((v87 ^ v46) & 0xE7FFFFFF) )
                  v108 = 1;
              }
              if ( v42 >= 0 )
              {
                while ( 1 )
                {
                  v47 = (v101 + v116) / 2;
                  v48 = NlsCompareRgWChar(2 * v108 + *(_DWORD *)(a1 + 68), v94 + 16 * v47, 5);
                  if ( !v48 )
                    break;
                  if ( v48 >= 0 )
                    v101 = v47 + 1;
                  else
                    v116 = v47 - 1;
                  if ( v101 > v116 )
                  {
                    v2 = a1;
                    goto LABEL_110;
                  }
                }
                *(_DWORD *)(a1 + 76) = *(_DWORD *)(16 * v47 + v94 + 12);
                if ( !v108 )
                  *(_DWORD *)(a1 + 68) += 8;
                goto LABEL_184;
              }
            }
          }
        }
LABEL_110:
        v49 = *(_DWORD *)v2;
        v95 = *(_DWORD *)(*(_DWORD *)v2 + 256);
        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 12) )
        {
          v128 = *(_DWORD *)(v49 + 236);
          v50 = *(_DWORD *)(a1 + 56);
          if ( *(_DWORD *)(a1 + 68) + 2 * (4 - (unsigned int)(v128 == 0)) <= v50 )
          {
            if ( !v131 )
              v131 = NlsCountOfWCharsWithinRange(
                       *(unsigned __int16 **)(a1 + 68),
                       v50,
                       4,
                       *(_WORD *)(*(_DWORD *)(v49 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v49 + 244) + 6),
                       v128,
                       *(_DWORD *)(a1 + 60));
            if ( v131 >= 4 )
            {
              v51 = *(_DWORD *)v2;
              v52 = *(_WORD *)(*(_DWORD *)(v51 + 244) + 12) - 1;
              v109 = 0;
              v102 = 0;
              v117 = *(_WORD *)(*(_DWORD *)(v51 + 244) + 12) - 1;
              if ( *(_DWORD *)(v51 + 236) && v131 >= 5 )
              {
                v53 = *(_DWORD *)(v51 + 224);
                v54 = *(_DWORD *)(a1 + 68);
                if ( v53 )
                {
                  v55 = (*pSortTblPtrs)[11];
                  v56 = *(_DWORD *)(v53 + 4 * ((unsigned int)*(_WORD *)v54 >> 8))
                      + (unsigned __int16)(v5 & *(_WORD *)v54);
                  v5 = 255;
                }
                else
                {
                  v55 = (*pSortTblPtrs)[11];
                  v56 = *(_WORD *)v54;
                }
                v88 = *(_DWORD *)(v55 + 4 * v56);
                v57 = v53 ? *(_DWORD *)(v55
                                      + 4
                                      * (*(_DWORD *)(v53 + 4 * ((unsigned int)*(_WORD *)(v54 + 2) >> 8))
                                       + (unsigned __int16)(v5 & *(_WORD *)(v54 + 2)))) : *(_DWORD *)(v55 + 4 * *(_WORD *)(v54 + 2));
                v52 = v117;
                if ( !((v88 ^ v57) & 0xE7FFFFFF) )
                  v109 = 1;
              }
              if ( v52 >= 0 )
              {
                while ( 1 )
                {
                  v58 = (v102 + v117) / 2;
                  v59 = NlsCompareRgWChar(2 * v109 + *(_DWORD *)(a1 + 68), v95 + 12 * v58, 4);
                  if ( !v59 )
                    break;
                  if ( v59 >= 0 )
                    v102 = v58 + 1;
                  else
                    v117 = v58 - 1;
                  if ( v102 > v117 )
                    goto LABEL_133;
                }
                *(_DWORD *)(a1 + 76) = *(_DWORD *)(12 * v58 + v95 + 8);
                if ( !v109 )
                  *(_DWORD *)(a1 + 68) += 6;
                goto LABEL_184;
              }
LABEL_133:
              v2 = a1;
            }
          }
        }
      }
      v60 = *(_DWORD *)v2;
      v96 = *(_DWORD *)(*(_DWORD *)v2 + 252);
      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 10) )
      {
        v129 = *(_DWORD *)(v60 + 236);
        v61 = *(_DWORD *)(a1 + 56);
        if ( *(_DWORD *)(a1 + 68) + 2 * (3 - (unsigned int)(v129 == 0)) <= v61 )
        {
          if ( !v131 )
            v131 = NlsCountOfWCharsWithinRange(
                     *(unsigned __int16 **)(a1 + 68),
                     v61,
                     3,
                     *(_WORD *)(*(_DWORD *)(v60 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v60 + 244) + 6),
                     v129,
                     *(_DWORD *)(a1 + 60));
          if ( v131 >= 3 )
          {
            v62 = *(_DWORD *)v2;
            v63 = *(_WORD *)(*(_DWORD *)(v62 + 244) + 10) - 1;
            v110 = 0;
            v103 = 0;
            v118 = *(_WORD *)(*(_DWORD *)(v62 + 244) + 10) - 1;
            if ( *(_DWORD *)(v62 + 236) && v131 >= 4 )
            {
              v64 = *(_DWORD *)(v62 + 224);
              v65 = *(_DWORD *)(a1 + 68);
              if ( v64 )
              {
                v66 = (*pSortTblPtrs)[11];
                v67 = *(_DWORD *)(v64 + 4 * ((unsigned int)*(_WORD *)v65 >> 8)) + (unsigned __int16)(v5 & *(_WORD *)v65);
                v5 = 255;
              }
              else
              {
                v66 = (*pSortTblPtrs)[11];
                v67 = *(_WORD *)v65;
              }
              v89 = *(_DWORD *)(v66 + 4 * v67);
              v68 = v64 ? *(_DWORD *)(v66
                                    + 4
                                    * (*(_DWORD *)(v64 + 4 * ((unsigned int)*(_WORD *)(v65 + 2) >> 8))
                                     + (unsigned __int16)(v5 & *(_WORD *)(v65 + 2)))) : *(_DWORD *)(v66
                                                                                                  + 4 * *(_WORD *)(v65 + 2));
              v63 = v118;
              if ( !((v89 ^ v68) & 0xE7FFFFFF) )
                v110 = 1;
            }
            if ( v63 >= 0 )
            {
              while ( 1 )
              {
                v69 = (v103 + v118) / 2;
                v70 = NlsCompareRgWChar(2 * v110 + *(_DWORD *)(a1 + 68), v96 + 12 * v69, 3);
                if ( !v70 )
                  break;
                if ( v70 >= 0 )
                  v103 = v69 + 1;
                else
                  v118 = v69 - 1;
                if ( v103 > v118 )
                  goto LABEL_157;
              }
              *(_DWORD *)(a1 + 76) = *(_DWORD *)(12 * v69 + v96 + 8);
              if ( !v110 )
                *(_DWORD *)(a1 + 68) += 4;
              goto LABEL_184;
            }
LABEL_157:
            v2 = a1;
          }
        }
      }
      v71 = *(_DWORD *)v2;
      v97 = *(_DWORD *)(*(_DWORD *)v2 + 248);
      if ( !*(_WORD *)(*(_DWORD *)(*(_DWORD *)v2 + 244) + 8) )
        goto LABEL_186;
      v130 = *(_DWORD *)(v71 + 236);
      v72 = *(_DWORD *)(a1 + 56);
      if ( *(_DWORD *)(a1 + 68) + 2 * (2 - (unsigned int)(v130 == 0)) > v72 )
        goto LABEL_186;
      if ( !v131 )
        v131 = NlsCountOfWCharsWithinRange(
                 *(unsigned __int16 **)(a1 + 68),
                 v72,
                 2,
                 *(_WORD *)(*(_DWORD *)(v71 + 244) + 4),
                 *(_WORD *)(*(_DWORD *)(v71 + 244) + 6),
                 v130,
                 *(_DWORD *)(a1 + 60));
      if ( v131 < 2 )
        goto LABEL_186;
      v73 = *(_DWORD *)v2;
      v74 = *(_WORD *)(*(_DWORD *)(v73 + 244) + 8) - 1;
      v111 = 0;
      v104 = 0;
      v119 = *(_WORD *)(*(_DWORD *)(v73 + 244) + 8) - 1;
      if ( *(_DWORD *)(v73 + 236) && v131 >= 3 )
      {
        v75 = *(_DWORD *)(v73 + 224);
        v76 = *(_DWORD *)(a1 + 68);
        if ( v75 )
        {
          v77 = (*pSortTblPtrs)[11];
          v78 = *(_DWORD *)(v75 + 4 * ((unsigned int)*(_WORD *)v76 >> 8)) + (unsigned __int16)(v5 & *(_WORD *)v76);
          v5 = 255;
        }
        else
        {
          v77 = (*pSortTblPtrs)[11];
          v78 = *(_WORD *)v76;
        }
        v90 = *(_DWORD *)(v77 + 4 * v78);
        v79 = v75 ? *(_DWORD *)(v77
                              + 4
                              * (*(_DWORD *)(v75 + 4 * ((unsigned int)*(_WORD *)(v76 + 2) >> 8))
                               + (unsigned __int16)(v5 & *(_WORD *)(v76 + 2)))) : *(_DWORD *)(v77
                                                                                            + 4 * *(_WORD *)(v76 + 2));
        v74 = v119;
        if ( !((v90 ^ v79) & 0xE7FFFFFF) )
          v111 = 1;
      }
      if ( v74 < 0 )
        goto LABEL_185;
      while ( 1 )
      {
        v80 = (v104 + v119) / 2;
        v81 = NlsCompareRgWChar(2 * v111 + *(_DWORD *)(a1 + 68), v97 + 8 * v80, 2);
        if ( !v81 )
          break;
        if ( v81 >= 0 )
          v104 = v80 + 1;
        else
          v119 = v80 - 1;
        if ( v104 > v119 )
          goto LABEL_185;
      }
      *(_DWORD *)(a1 + 76) = *(_DWORD *)(v97 + 8 * v80 + 4);
      if ( !v111 )
        *(_DWORD *)(a1 + 68) += 2;
LABEL_184:
      v112 = *(unsigned __int16 **)(a1 + 68);
      *(_DWORD *)(a1 + 68) = v82;
LABEL_185:
      v2 = a1;
      goto LABEL_186;
    }
LABEL_9:
    SetLastError(0);
    result = -1;
  }
  return result;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E3DF45) --------------------------------------------------------
BOOL __stdcall IsValidCalId(unsigned int a1)
{
  return a1 && (a1 <= 0xC || a1 == 23);
}

//----- (77E3DF6A) --------------------------------------------------------
BOOL __stdcall EnumCalendarInfoExExStub(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
{
  return EnumCalendarInfoExEx(pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
}

//----- (77E3DF82) --------------------------------------------------------
signed int __stdcall GetCalendarSupportedDateRange(unsigned int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // edx@3
  int v5; // ecx@3

  v3 = 0;
  if ( a2 && a3 && IsValidCalId(a1) )
  {
    *(_DWORD *)a2 = v5;
    *(_DWORD *)v4 = v5;
    if ( (unsigned int)v5 <= 7 )
    {
      if ( v5 != 7 )
      {
        if ( !v5 )
          return v3;
        if ( (unsigned int)v5 <= 2 )
          return GetGregorianSupportedDateRange(a2, v4);
        if ( (unsigned int)v5 > 5 )
        {
          if ( v5 != 6 )
            return v3;
          return GetHijriSupportedDateRange(a2, v4);
        }
      }
      return GetGregBasedSupportedDateRange(v5, a2, v4);
    }
    if ( v5 == 8 )
      return GetHebrewSupportedDateRange(a2, v4);
    if ( (unsigned int)v5 <= 8 )
      return v3;
    if ( (unsigned int)v5 > 0xC )
    {
      if ( v5 != 23 )
        return v3;
      return GetUmAlQuraSupportedDateRange(a2, v4);
    }
    return GetGregorianSupportedDateRange(a2, v4);
  }
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3DFEF) --------------------------------------------------------
signed int __stdcall GetGregorianSupportedDateRange(int a1, int a2)
{
  signed int result; // eax@1

  result = 1;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = 9999;
  *(_DWORD *)(a2 + 12) = 12;
  *(_DWORD *)(a2 + 16) = 31;
  *(_DWORD *)(a2 + 20) = 5;
  *(_DWORD *)(a2 + 24) = 23;
  *(_DWORD *)(a2 + 28) = 59;
  *(_DWORD *)(a2 + 32) = 59;
  *(_DWORD *)(a2 + 36) = 9999999;
  return result;
}

//----- (77E3E059) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToCalDateTime(int a1, unsigned int a2, int a3)
{
  void *v3; // edx@3
  int v4; // ecx@3
  signed int result; // eax@8

  if ( !a3 || !a1 || !IsValidCalId(a2) )
    goto LABEL_11;
  *(_DWORD *)v3 = v4;
  if ( (unsigned int)v4 <= 7 )
  {
    if ( v4 != 7 )
    {
      if ( !v4 )
        goto LABEL_11;
      if ( (unsigned int)v4 <= 2 )
        return ConvertSystemTimeToGregorianDateTime(a1, v4, v3);
      if ( (unsigned int)v4 > 5 )
      {
        if ( v4 == 6 )
          return ConvertSystemTimeToHijriDateTime(a1, (int)v3);
LABEL_11:
        RtlSetLastWin32Error(87);
        return 0;
      }
    }
    return ConvertSystemTimeToGregBasedDateTime(a1, v3);
  }
  if ( v4 == 8 )
  {
    result = ConvertSystemTimeToHebrewDateTime(a1, v3);
  }
  else
  {
    if ( (unsigned int)v4 <= 8 )
      goto LABEL_11;
    if ( (unsigned int)v4 <= 0xC )
      return ConvertSystemTimeToGregorianDateTime(a1, v4, v3);
    if ( v4 != 23 )
      goto LABEL_11;
    result = ConvertSystemTimeToUmAlQuraDateTime(a1, v3);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3E0BC) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToGregorianDateTime(int a1, int a2, void *a3)
{
  int v3; // ecx@1
  signed int v4; // edi@1
  int v6; // [sp+4h] [bp-28h]@1
  int v7; // [sp+8h] [bp-24h]@1
  int v8; // [sp+Ch] [bp-20h]@1
  int v9; // [sp+10h] [bp-1Ch]@1
  int v10; // [sp+14h] [bp-18h]@1
  int v11; // [sp+18h] [bp-14h]@1
  int v12; // [sp+1Ch] [bp-10h]@1
  int v13; // [sp+20h] [bp-Ch]@1
  int v14; // [sp+24h] [bp-8h]@1
  int v15; // [sp+28h] [bp-4h]@1

  v6 = a2;
  v8 = *(_WORD *)a1;
  v9 = *(_WORD *)(a1 + 2);
  v10 = *(_WORD *)(a1 + 6);
  v12 = *(_WORD *)(a1 + 8);
  v13 = *(_WORD *)(a1 + 10);
  v14 = *(_WORD *)(a1 + 12);
  v3 = 10000 * *(_WORD *)(a1 + 14);
  v11 = *(_WORD *)(a1 + 4);
  v4 = 0;
  v7 = 1;
  v15 = v3;
  if ( IsValidGregorianDateTime((int)&v6, (int)&a2, 1) )
  {
    if ( CopyCalDateTime(a3, &v6) )
      v4 = 1;
  }
  else
  {
    SetLastError(0x57u);
  }
  return v4;
}

//----- (77E3E14D) --------------------------------------------------------
int __stdcall ConvertNLSDayOfWeekToWin32DayOfWeek(unsigned int a1)
{
  int result; // eax@2

  if ( a1 > 6 )
  {
    RtlSetLastWin32Error(87);
    result = -1;
  }
  else
  {
    result = a1 != 6 ? a1 + 1 : 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3E2D5) --------------------------------------------------------
int __stdcall GetCalendarMonthsInYear(unsigned int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@6

  if ( !IsValidCalId(a1) )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( (unsigned int)v3 > 7 )
  {
    if ( v3 == 8 )
    {
      result = GetHebrewMonthsInYear(a2, a3);
    }
    else
    {
      if ( (unsigned int)v3 <= 8 )
        return 0;
      if ( (unsigned int)v3 <= 0xC )
        return GetGregorianMonthsInYear(a2, a3);
      if ( v3 != 23 )
        return 0;
      result = GetUmAlQuraMonthsInYear(a2, a3);
    }
  }
  else
  {
    if ( v3 != 7 )
    {
      if ( !v3 )
        return 0;
      if ( (unsigned int)v3 <= 2 )
        return GetGregorianMonthsInYear(a2, a3);
      if ( (unsigned int)v3 > 5 )
      {
        if ( v3 == 6 )
          return GetHijriMonthsInYear(a2, a3);
        return 0;
      }
    }
    result = GetGregBasedMonthsInYear(v3, a2, a3);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3E31F) --------------------------------------------------------
int __stdcall GetGregorianMonthsInYear(int a1, int a2)
{
  return IsValidGregorianYear(a1, a2) != 0 ? 0xC : 0;
}

//----- (77E3E33F) --------------------------------------------------------
signed int __stdcall CopyCalDateTime(void *a1, const void *a2)
{
  signed int result; // eax@3

  if ( a1 && a2 )
  {
    qmemcpy(a1, a2, 0x28u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E3E36B) --------------------------------------------------------
signed int __stdcall IsValidGregorianTime(int a1, int a2)
{
  signed int v2; // esi@1

  v2 = 1;
  if ( *(_DWORD *)(a1 + 24) > 0x17u )
    v2 = 0;
  if ( *(_DWORD *)(a1 + 28) > 0x3Bu )
    v2 = 0;
  if ( *(_DWORD *)(a1 + 32) > 0x3Bu )
    v2 = 0;
  if ( *(_DWORD *)(a1 + 36) > 0x98967Fu )
    v2 = 0;
  if ( !v2 )
    SetLastError(0x57u);
  return v2;
}

//----- (77E3E3B6) --------------------------------------------------------
signed int __stdcall IsValidCalDateTime(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@3

  v2 = 0;
  if ( a1 && a2 )
  {
    v3 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 > 7u )
    {
      if ( v3 == 8 )
        return IsValidHebrewDateTime(a1, a2, 1);
      if ( v3 > 8 )
      {
        if ( v3 <= 0xC )
          return IsValidGregorianDateTime(a1, a2, 1);
        if ( v3 == 23 )
          return IsValidUmAlQuraDateTime(a1, a2, 1);
      }
    }
    else
    {
      if ( *(_DWORD *)a1 == 7 )
        return IsValidGregBasedDateTime(a1, a2, 1);
      if ( !v3 )
        goto LABEL_12;
      if ( v3 <= 2 )
        return IsValidGregorianDateTime(a1, a2, 1);
      if ( v3 <= 5 )
        return IsValidGregBasedDateTime(a1, a2, 1);
      if ( v3 == 6 )
        return IsValidHijriDateTime(a1, a2, 1);
    }
LABEL_12:
    RtlSetLastWin32Error(87);
    return v2;
  }
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3E41F) --------------------------------------------------------
signed int __stdcall IsValidGregorianDateTime(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // edi@7

  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(a1 + 4) != 1 )
  {
    SetLastError(0x57u);
    return 0;
  }
  if ( (unsigned int)(v3 - 1) > 0x270E )
  {
    SetLastError(0x120u);
  }
  else if ( IsValidGregorianMonthAndDay(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), v3, a2)
         && IsValidGregorianTime(a1, a2) )
  {
    if ( !a3 )
      return 1;
    v4 = *(_DWORD *)(a1 + 20);
    if ( v4 == -1 || v4 == GetGregorianDayOfWeekHelper(a1) )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E3E49D) --------------------------------------------------------
unsigned int __stdcall GetGregorianDayOfWeekHelper(int a1)
{
  unsigned int result; // eax@2

  if ( a1 )
    result = (GetAbsoluteDateFromGregorian(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16)) + 1) % 7u;
  else
    result = -1;
  return result;
}

//----- (77E3E4CE) --------------------------------------------------------
int __stdcall GetAbsoluteDateFromGregorian(unsigned int a1, int a2, int a3)
{
  signed int v3; // ecx@2
  int v4; // eax@2
  int v5; // esi@2

  if ( a1 & 3 || !(a1 % 0x64) && a1 % 0x190 )
  {
    v3 = a1 - 1;
    v4 = (signed int)(a1 - 1) / 400;
    v5 = *(_DWORD *)((char *)&locret_77E3E51F + 4 * a2 + 1);
  }
  else
  {
    v3 = a1 - 1;
    v4 = (signed int)(a1 - 1) / 400;
    v5 = *((_DWORD *)&loc_77E3E850 + a2);
  }
  return 365 * v3 + v4 + v5 - v3 / 100 + a3 + v3 / 4 - 1;
}

//----- (77E3E55D) --------------------------------------------------------
signed int __stdcall UpdateCalendarDayOfWeek(int a1)
{
  int v1; // esi@1
  unsigned int v2; // eax@2

  v1 = 0;
  if ( a1 )
  {
    v2 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 > 7u )
    {
      if ( v2 == 8 )
        return UpdateHebrewDayOfWeek(a1);
      if ( v2 > 8 )
      {
        if ( v2 <= 0xC )
          return UpdateGregorianDayOfWeek(a1);
        if ( v2 == 23 )
          return UpdateUmAlQuraDayOfWeek(a1);
      }
    }
    else
    {
      if ( *(_DWORD *)a1 == 7 )
        return UpdateGregBasedDayOfWeek(a1);
      if ( !v2 )
        goto LABEL_11;
      if ( v2 <= 2 )
        return UpdateGregorianDayOfWeek(a1);
      if ( v2 <= 5 )
        return UpdateGregBasedDayOfWeek(a1);
      if ( v2 == 6 )
        return UpdateHijriDayOfWeek(a1);
    }
LABEL_11:
    RtlSetLastWin32Error(87);
    return v1;
  }
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3E5B0) --------------------------------------------------------
signed int __stdcall UpdateGregorianDayOfWeek(int a1)
{
  int v1; // esi@1
  signed int result; // eax@1

  v1 = a1;
  result = IsValidGregorianDateTime(a1, (int)&a1, 0);
  if ( result )
  {
    result = GetGregorianDayOfWeekHelper(v1);
    if ( result != -1 )
    {
      *(_DWORD *)(v1 + 20) = result;
      result = 1;
    }
  }
  return result;
}

//----- (77E3E5E4) --------------------------------------------------------
signed int __stdcall GetCalendarDateFormatEx(int a1, int a2, int a3, void *a4, wchar_t *a5, int a6)
{
  int v6; // eax@21
  int v7; // eax@24
  int v8; // eax@24
  signed int v9; // edi@24
  int v10; // eax@26
  int v11; // eax@30
  int v12; // ebx@3
  int v13; // ebx@13
  wchar_t *v14; // eax@15
  signed int v15; // ST20_4@16
  unsigned int v16; // ST14_4@16
  int v17; // eax@16
  int v19; // eax@38
  signed int v20; // [sp-4h] [bp-2E0h]@30
  char v21; // [sp+Ch] [bp-2D0h]@1
  int v22; // [sp+10h] [bp-2CCh]@1
  __int16 v23; // [sp+14h] [bp-2C8h]@16
  __int16 v24; // [sp+16h] [bp-2C6h]@16
  __int16 v25; // [sp+18h] [bp-2C4h]@16
  __int16 v26; // [sp+1Ah] [bp-2C2h]@16
  __int16 v27; // [sp+1Ch] [bp-2C0h]@16
  __int16 v28; // [sp+1Eh] [bp-2BEh]@16
  __int16 v29; // [sp+20h] [bp-2BCh]@16
  __int16 v30; // [sp+22h] [bp-2BAh]@16
  int v31; // [sp+24h] [bp-2B8h]@1
  STRSAFE_LPWSTR pszDest; // [sp+28h] [bp-2B4h]@1
  unsigned __int16 v33; // [sp+2Ch] [bp-2B0h]@25
  int v34; // [sp+30h] [bp-2ACh]@25
  int v35; // [sp+34h] [bp-2A8h]@3
  wchar_t pszSrc; // [sp+38h] [bp-2A4h]@16
  char v37; // [sp+238h] [bp-A4h]@29

  v31 = 0;
  v22 = 0;
  pszDest = a5;
  if ( !IsValidCalDateTime(a3, (int)&v21) )
    return 0;
  if ( *(_DWORD *)a3 == 8 )
    v31 = IsHebrewLeapYear(*(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 4));
  v12 = NlsValidateNamedLocale(a1);
  v35 = v12;
  if ( !v12 || a6 < 0 || !pszDest && a6 || a4 && SortNlsStrLenW(a4) >= 256 || !IsValidCalendarType(v12, *(_DWORD *)a3) )
    goto LABEL_33;
  if ( a2 & 0x3FFFFFC4 || (unsigned __int8)a2 & (unsigned __int8)((a2 & 0xF0) - 1) & 0x70 || a4 && a2 & 0x8000000B )
    goto LABEL_42;
  v13 = GetCalendar(v12, *(_DWORD *)a3);
  if ( !v13 )
  {
LABEL_33:
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( a4 )
  {
    v14 = (wchar_t *)a4;
    goto LABEL_16;
  }
  v6 = a2 & 0xB;
  if ( (unsigned int)v6 <= 1 )
  {
    v11 = KernelBaseGetGlobalData();
    v8 = GetStringFromArrayInPool(*(_DWORD *)(v11 + 116), *(_DWORD *)(v13 + 4), 0);
    v20 = 31;
  }
  else
  {
    if ( v6 != 2 )
    {
      if ( v6 == 8 )
      {
        v7 = KernelBaseGetGlobalData();
        v8 = GetStringFromArrayInPool(*(_DWORD *)(v7 + 116), *(_DWORD *)(v13 + 8), 0);
        v9 = 4102;
        goto LABEL_25;
      }
LABEL_42:
      RtlSetLastWin32Error(1004);
      return 0;
    }
    v19 = KernelBaseGetGlobalData();
    v8 = GetStringFromArrayInPool(*(_DWORD *)(v19 + 116), *(_DWORD *)(v13 + 12), 0);
    v20 = 32;
  }
  v9 = v20;
LABEL_25:
  v34 = v8;
  if ( GetUserInfoWord(v35, 1398, &v33) )
    v10 = (unsigned __int16)IsValidCalendarType(v35, v33);
  else
    v10 = v22;
  if ( !(a2 & 0x80000000) && *(_DWORD *)a3 == v10 )
    goto LABEL_29;
  if ( !*(_WORD *)v34 )
  {
    v9 |= 0x80000000;
LABEL_29:
    GetLocaleInfoHelper(v35, v9, &v37, 80);
    v14 = (wchar_t *)&v37;
    goto LABEL_16;
  }
  v14 = (wchar_t *)(v34 + 2);
LABEL_16:
  v23 = *(_WORD *)(a3 + 8);
  v15 = *(_DWORD *)(a3 + 4);
  v24 = *(_WORD *)(a3 + 12);
  v25 = *(_WORD *)(a3 + 20);
  v26 = *(_WORD *)(a3 + 16);
  v16 = *(_DWORD *)a3;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v17 = DoFormatDate(v35, a2, (int)&v23, v14, &pszSrc, v16, v13, 0, v15, v31);
  if ( a6 < v17 )
  {
    RtlSetLastWin32Error(122);
    return 0;
  }
  if ( !v17 )
    goto LABEL_33;
  if ( StringCchCopyW(pszDest, v17, &pszSrc) >= 0 )
    return 1;
  RtlSetLastWin32Error(14);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2ADCF: using guessed type int __stdcall GetCalendar(_DWORD, _DWORD);
// 77E2B6CD: using guessed type int __stdcall GetLocaleInfoHelper(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E2B94C: using guessed type int __stdcall GetUserInfoWord(_DWORD, _DWORD, _DWORD);

//----- (77E3E791) --------------------------------------------------------
int __stdcall NlsValidateNamedLocale(int a1)
{
  return GetNamedLocaleHashNode(a1, 0);
}
// 77E3FC4E: using guessed type int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD);

//----- (77E3E7A9) --------------------------------------------------------
int __stdcall IsGregorianLeapYear(int a1, int a2)
{
  int result; // eax@3

  result = 0;
  if ( IsValidGregorianYear(a1, a2) )
  {
    SetLastError(0);
    if ( !(a1 & 3) && (a1 % 0x64u || !(a1 % 0x190u)) )
      result = 1;
  }
  return result;
}

//----- (77E3E7DB) --------------------------------------------------------
signed int __stdcall IsValidGregorianYear(int a1, int a2)
{
  signed int result; // eax@1

  result = 1;
  if ( a2 == 1 )
  {
    if ( (unsigned int)(a1 - 1) <= 0x270E )
      return result;
    SetLastError(0x120u);
  }
  else
  {
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E3E805) --------------------------------------------------------
signed int __stdcall IsValidGregorianMonthAndDay(unsigned int a1, int a2, int a3, int a4)
{
  signed int v4; // edi@1
  bool v5; // zf@2
  int *v6; // eax@2

  v4 = 1;
  if ( (unsigned int)(a2 - 1) > 0xB )
    goto LABEL_9;
  v5 = IsGregorianLeapYear(a3, 1) == 0;
  v6 = &GregorianDaysToMonth366[a2];
  if ( v5 )
    v6 = &GregorianDaysToMonth365[a2];
  if ( a1 > *v6 - *(v6 - 1) )
  {
LABEL_9:
    v4 = 0;
    SetLastError(0x57u);
  }
  return v4;
}
// 77E3E524: using guessed type int GregorianDaysToMonth365[];
// 77E3E854: using guessed type int GregorianDaysToMonth366[];

//----- (77E3E88D) --------------------------------------------------------
int __stdcall GetCalendarDateFormat(LCID Locale, int a2, int a3, void *a4, wchar_t *a5, int a6)
{
  int result; // eax@1
  WCHAR Name; // [sp+Ch] [bp-B0h]@1

  result = LCIDToLocaleName(Locale, &Name, 85, 0);
  if ( result )
    result = GetCalendarDateFormatEx((int)&Name, a2, a3, a4, a5, a6);
  return result;
}

//----- (77E3E8F0) --------------------------------------------------------
signed int __stdcall AdjustCalendarDate(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  signed int result; // eax@1
  unsigned int v6; // eax@3
  int v8; // ecx@14
  unsigned int v9; // eax@15
  unsigned int v10; // eax@20
  int v11; // [sp-4h] [bp-Ch]@41

  v3 = a1;
  v4 = 0;
  result = IsValidCalDateTime(a1, (int)&a1);
  if ( result )
  {
    if ( a2 == 1 )
    {
      v6 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 <= 7u )
      {
        if ( *(_DWORD *)v3 != 7 )
        {
          if ( !v6 )
            goto LABEL_26;
          if ( v6 <= 2 )
            return AdjustMonthsInTwelveMonthCalendars(v3, 12 * a3);
          if ( v6 > 5 )
          {
            if ( v6 == 6 )
              return AdjustHijriYears(v3, a3);
            goto LABEL_26;
          }
        }
        v11 = 12 * a3;
        return AdjustGregBasedDateTime(v3, 2, v11);
      }
      if ( v6 == 8 )
        return AdjustHebrewYears(v3, a3);
      if ( v6 > 8 )
      {
        if ( v6 <= 0xC )
          return AdjustMonthsInTwelveMonthCalendars(v3, 12 * a3);
        if ( v6 == 23 )
          return AdjustUmAlQuraYears(v3, a3);
      }
LABEL_26:
      RtlSetLastWin32Error(87);
      return v4;
    }
    if ( a2 != 2 )
    {
      if ( a2 == 3 )
      {
        v8 = 7 * a3;
      }
      else
      {
        if ( a2 != 4 )
          return v4;
        v8 = a3;
      }
      v9 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 <= 7u )
      {
        if ( *(_DWORD *)v3 != 7 )
        {
          if ( !v9 )
            goto LABEL_26;
          if ( v9 <= 2 )
            return AdjustGregorianDays(v3, v8);
          if ( v9 > 5 )
          {
            if ( v9 == 6 )
              return AdjustHijriDays(v3, v8);
            goto LABEL_26;
          }
        }
        return AdjustGregBasedDateTime(v3, 4, v8);
      }
      if ( v9 == 8 )
        return AdjustHebrewDays(v3, v8);
      if ( v9 <= 8 )
        goto LABEL_26;
      if ( v9 > 0xC )
      {
        if ( v9 == 23 )
          return AdjustUmAlQuraDays(v3, v8);
        goto LABEL_26;
      }
      return AdjustGregorianDays(v3, v8);
    }
    v10 = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 <= 7u )
    {
      if ( *(_DWORD *)v3 != 7 )
      {
        if ( !v10 )
          goto LABEL_26;
        if ( v10 <= 2 )
          return AdjustMonthsInTwelveMonthCalendars(v3, a3);
        if ( v10 > 5 )
        {
          if ( v10 == 6 )
            return AdjustHijriMonths(v3, a3);
          goto LABEL_26;
        }
      }
      v11 = a3;
      return AdjustGregBasedDateTime(v3, 2, v11);
    }
    if ( v10 == 8 )
      return AdjustHebrewMonths(v3, a3);
    if ( v10 <= 8 )
      goto LABEL_26;
    if ( v10 > 0xC )
    {
      if ( v10 == 23 )
        return AdjustUmAlQuraMonths(v3, a3);
      goto LABEL_26;
    }
    return AdjustMonthsInTwelveMonthCalendars(v3, a3);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3EC1C: using guessed type _DWORD __stdcall AdjustGregorianDays(_DWORD, _DWORD);

//----- (77E3E9B2) --------------------------------------------------------
int __stdcall AdjustMonthsInTwelveMonthCalendars(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@2
  int v4; // eax@2
  int v5; // ecx@2
  void *v6; // ecx@3
  unsigned int v7; // edi@3
  int v8; // eax@3
  unsigned int v9; // ebx@4
  int v10; // eax@4
  signed __int64 v12; // rax@12
  signed __int64 v13; // rt2@12
  int v14; // [sp+4h] [bp-2Ch]@6
  int v15; // [sp+8h] [bp-28h]@6
  unsigned int v16; // [sp+Ch] [bp-24h]@6
  unsigned int v17; // [sp+10h] [bp-20h]@6
  int v18; // [sp+14h] [bp-1Ch]@6
  int v19; // [sp+1Ch] [bp-14h]@6
  int v20; // [sp+20h] [bp-10h]@6
  int v21; // [sp+24h] [bp-Ch]@6
  int v22; // [sp+28h] [bp-8h]@6
  int v23; // [sp+2Ch] [bp-4h]@1
  int v24; // [sp+38h] [bp+8h]@2

  v23 = 0;
  v2 = a1;
  if ( !a1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 8);
  v24 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(v2 + 12);
  v5 = a2 + v4 - 1;
  if ( v5 >= 0 )
  {
    v12 = v5;
    v6 = (void *)12;
    v13 = v12 % 12;
    v8 = v12 / 12;
    v7 = v13 + 1;
  }
  else
  {
    v6 = (void *)12;
    v7 = (a2 + v4) % 12 + 12;
    v8 = (a2 + v4 - 12) / 12;
  }
  v9 = v8 + v3;
  v10 = GetCalendarDaysInMonth(v6, *(_DWORD *)v2, v7, v9, *(_DWORD *)(v2 + 4));
  if ( !v10 )
  {
    RtlSetLastWin32Error(288);
    return 0;
  }
  if ( v24 > v10 )
    v24 = v10;
  v14 = *(_DWORD *)v2;
  v15 = *(_DWORD *)(v2 + 4);
  v18 = v24;
  v19 = *(_DWORD *)(v2 + 24);
  v20 = *(_DWORD *)(v2 + 28);
  v21 = *(_DWORD *)(v2 + 32);
  v22 = *(_DWORD *)(v2 + 36);
  v16 = v9;
  v17 = v7;
  if ( !UpdateCalendarDayOfWeek((int)&v14) )
    return 0;
  if ( IsValidCalDateTime((int)&v14, (int)&a2) )
  {
    if ( CopyCalDateTime((void *)v2, &v14) )
      v23 = 1;
  }
  return v23;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3EAA0) --------------------------------------------------------
int __thiscall GetCalendarDaysInMonth(void *this, int a2, unsigned int a3, unsigned int a4, int a5)
{
  int v5; // esi@1

  v5 = 0;
  if ( (unsigned int)a2 > 7 )
  {
    if ( a2 == 8 )
      return GetHebrewDaysInMonth(a3, a4, a5);
    if ( (unsigned int)a2 > 8 )
    {
      if ( (unsigned int)a2 <= 0xC )
        return GetGregorianDaysInMonth(a3, a4, a5);
      if ( a2 == 23 )
        return GetUmAlQuraDaysInMonth(a3, a4, a5);
    }
LABEL_8:
    RtlSetLastWin32Error(87);
    return v5;
  }
  if ( a2 == 7 )
    return GetGregBasedDaysInMonth(this, a2, a3, a4, a5);
  if ( !a2 )
    goto LABEL_8;
  if ( (unsigned int)a2 > 2 )
  {
    if ( (unsigned int)a2 > 5 )
    {
      if ( a2 == 6 )
        return GetHijriDaysInMonth(a3, a4, a5);
      goto LABEL_8;
    }
    return GetGregBasedDaysInMonth(this, a2, a3, a4, a5);
  }
  return GetGregorianDaysInMonth(a3, a4, a5);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3EAED) --------------------------------------------------------
signed int __stdcall GetGregorianDaysInMonth(int a1, unsigned int a2, int a3)
{
  signed int result; // eax@1
  BOOL v4; // eax@3
  int *v5; // ecx@3

  result = IsValidGregorianYear(a2, a3);
  if ( result )
  {
    if ( (unsigned int)(a1 - 1) > 0xB )
    {
      SetLastError(0x57u);
      result = 0;
    }
    else
    {
      v4 = NlsGregorianLeapYear(a2);
      v5 = &GregorianDaysToMonth366[a1];
      if ( !v4 )
        v5 = &GregorianDaysToMonth365[a1];
      result = *v5 - *(v5 - 1);
    }
  }
  return result;
}
// 77E3E524: using guessed type int GregorianDaysToMonth365[];
// 77E3E854: using guessed type int GregorianDaysToMonth366[];

//----- (77E3EB3A) --------------------------------------------------------
BOOL __stdcall NlsGregorianLeapYear(unsigned int a1)
{
  return !(a1 & 3) && (a1 % 0x64 || !(a1 % 0x190));
}

//----- (77E3EB54) --------------------------------------------------------
signed int __stdcall GetCalendarDifferenceInDays(const void *a1, int a2, int a3)
{
  int v3; // esi@1
  unsigned int v4; // eax@4
  unsigned int v5; // eax@9
  signed int result; // eax@11
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v3 = a3;
  if ( a3 )
  {
    if ( IsValidCalDateTime((int)a1, (int)&a3) && IsValidCalDateTime(a2, (int)&a3) )
    {
      v4 = *(_DWORD *)a1;
      if ( *(_DWORD *)a1 == *(_DWORD *)a2 )
      {
        if ( v4 > 7 )
        {
          if ( v4 == 8 )
          {
            v5 = GetHebrewDifferenceInDays(a1, (const void *)a2);
            goto LABEL_10;
          }
          if ( v4 > 8 )
          {
            if ( v4 <= 0xC )
              goto LABEL_9;
            if ( v4 == 23 )
            {
              v5 = GetUmAlQuraDifferenceInDays(a1, (const void *)a2);
              goto LABEL_10;
            }
          }
        }
        else
        {
          if ( v4 == 7 )
            goto LABEL_29;
          if ( !v4 )
            goto LABEL_15;
          if ( v4 <= 2 )
          {
LABEL_9:
            v5 = GetGregorianDifferenceInDays((int)a1, a2);
LABEL_10:
            *(_DWORD *)v3 = v5;
            return 1;
          }
          if ( v4 <= 5 )
          {
LABEL_29:
            v5 = GetGregBasedDifferenceInDays((int)a1, a2);
            goto LABEL_10;
          }
          if ( v4 == 6 )
          {
            v5 = GetHijriDifferenceInDays((int)a1, a2);
            goto LABEL_10;
          }
        }
LABEL_15:
        RtlSetLastWin32Error(87);
        return v7;
      }
      RtlSetLastWin32Error(87);
    }
    result = 0;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3EBE6) --------------------------------------------------------
int __stdcall GetGregorianDifferenceInDays(int a1, int a2)
{
  int v2; // esi@1

  v2 = GetAbsoluteDateFromGregorian(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  return GetAbsoluteDateFromGregorian(*(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), *(_DWORD *)(a2 + 16)) - v2;
}

//----- (77E3EC93) --------------------------------------------------------
int __stdcall GetGregorianFromAbsoluteDate(signed int a1, void *a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  signed int v4; // ecx@2
  int v5; // eax@2
  signed int v6; // ecx@2
  int v7; // eax@2
  signed int v8; // ecx@3
  int v9; // edx@3
  int v10; // eax@4
  int v11; // ecx@6
  int v13; // [sp+Ch] [bp-2Ch]@7
  int v14; // [sp+10h] [bp-28h]@7
  int v15; // [sp+14h] [bp-24h]@7
  int v16; // [sp+18h] [bp-20h]@7
  int v17; // [sp+1Ch] [bp-1Ch]@7
  unsigned int v18; // [sp+20h] [bp-18h]@8
  int v19; // [sp+24h] [bp-14h]@7
  int v20; // [sp+28h] [bp-10h]@7
  int v21; // [sp+2Ch] [bp-Ch]@7
  int v22; // [sp+30h] [bp-8h]@7
  int v23; // [sp+34h] [bp-4h]@1

  v23 = 0;
  v2 = a1 / DaysPer400Years;
  v3 = (a1 - a1 / DaysPer400Years * DaysPer400Years) / DaysPer100Years;
  if ( v3 == 4 )
    v3 = 3;
  v4 = a1 - a1 / DaysPer400Years * DaysPer400Years - v3 * DaysPer100Years;
  v5 = v4 / DaysPer4Years;
  v6 = v4 - v4 / DaysPer4Years * DaysPer4Years;
  a1 = v5;
  v7 = v6 / DaysPerYear;
  if ( v6 / DaysPerYear == 4 )
    v7 = 3;
  v8 = v6 - v7 * DaysPerYear;
  v9 = v7 + 4 * (a1 + 25 * (v3 + 4 * v2)) + 1;
  if ( v7 != 3 || a1 == 24 && v3 != 3 )
  {
    v10 = v8 >> 5;
    do
      ++v10;
    while ( v8 >= GregorianDaysToMonth365[v10] );
    v11 = v8 - *(_DWORD *)((char *)&locret_77E3E51F + 4 * v10 + 1);
  }
  else
  {
    v10 = v8 >> 5;
    do
      ++v10;
    while ( v8 >= GregorianDaysToMonth366[v10] );
    v11 = v8 - *((_DWORD *)&loc_77E3E850 + v10);
  }
  v16 = v10;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v13 = 1;
  v14 = 1;
  v17 = v11 + 1;
  v15 = v9;
  if ( IsValidGregorianDateTime((int)&v13, (int)&a1, 0) )
  {
    v18 = GetGregorianDayOfWeekHelper((int)&v13);
    if ( CopyCalDateTime(a2, &v13) )
      v23 = 1;
  }
  return v23;
}
// 77E3E524: using guessed type int GregorianDaysToMonth365[];
// 77E3E854: using guessed type int GregorianDaysToMonth366[];
// 77E3ED88: using guessed type int DaysPerYear;
// 77E3ED8C: using guessed type int DaysPer4Years;
// 77E3ED90: using guessed type int DaysPer100Years;
// 77E3ED94: using guessed type int DaysPer400Years;

//----- (77E3ED9D) --------------------------------------------------------
BOOL __stdcall IsTimeZoneRedirectionEnabled()
{
  return *(_DWORD *)(BaseStaticServerData + 2332) != -1;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E3EF9A) --------------------------------------------------------
int __stdcall GetNumberFormatExStub(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
{
  return GetNumberFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
}

//----- (77E3F067) --------------------------------------------------------
int __stdcall K32QueryWorkingSet(HANDLE ProcessHandle, PVOID MemoryInformation, ULONG MemoryInformationLength)
{
  NTSTATUS v3; // eax@1
  int result; // eax@2
  DWORD v5; // eax@4

  v3 = NtQueryVirtualMemory(ProcessHandle, 0, MemoryWorkingSetList, MemoryInformation, MemoryInformationLength, 0);
  if ( v3 < 0 )
  {
    v5 = RtlNtStatusToDosError(v3);
    SetLastError(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E3F095) --------------------------------------------------------
int __stdcall SetFileCompletionNotificationModes(HANDLE FileHandle, int FileInformation)
{
  NTSTATUS v2; // eax@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-8h]@3

  if ( FileInformation & 0xFC )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(FileInformation & 3) )
      return 1;
    FileInformation = (unsigned __int8)FileInformation;
    v2 = NtSetInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 4u, FileIoCompletionNotificationInformation);
    if ( v2 >= 0 )
      return 1;
    BaseSetLastNTError(v2);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3F0DD) --------------------------------------------------------
BOOL __stdcall GetSystemTimes(LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
{
  signed int v3; // ebx@1
  ULONG v4; // esi@2
  int v5; // eax@2
  PVOID v6; // eax@2
  int v7; // ecx@6
  DWORD v8; // edx@6
  DWORD v9; // esi@6
  PVOID v10; // eax@7
  unsigned __int64 v11; // kr00_8@8
  int v12; // ecx@11
  DWORD v13; // edx@11
  DWORD v14; // esi@11
  char *v15; // eax@12
  unsigned __int64 v16; // kr08_8@13
  int v17; // ecx@16
  DWORD v18; // edx@16
  DWORD v19; // esi@16
  char *v20; // eax@17
  unsigned __int64 v21; // kr10_8@18
  int v22; // eax@21
  char SystemInformation; // [sp+Ch] [bp-34h]@1
  char v25; // [sp+34h] [bp-Ch]@2
  ULONG ReturnLength; // [sp+38h] [bp-8h]@3
  PVOID Address; // [sp+3Ch] [bp-4h]@2

  v3 = NtQuerySystemInformation(0, &SystemInformation, 0x2Cu, 0);
  if ( v3 >= 0 )
  {
    v4 = 48 * v25;
    v5 = KernelBaseGetGlobalData();
    v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), v4);
    Address = v6;
    if ( v6 )
    {
      v3 = NtQuerySystemInformation(SystemProcessorPerformanceInformation, v6, v4, &ReturnLength);
      if ( v3 >= 0 )
      {
        if ( ReturnLength == v4 )
        {
          if ( lpIdleTime )
          {
            v7 = v25;
            v8 = 0;
            v9 = 0;
            if ( v25 > 0 )
            {
              v10 = Address;
              do
              {
                v11 = *(_QWORD *)v10 + __PAIR__(v9, v8);
                v9 = v11 >> 32;
                v8 = v11;
                v10 = (char *)v10 + 48;
                --v7;
              }
              while ( v7 );
            }
            lpIdleTime->dwLowDateTime = v8;
            lpIdleTime->dwHighDateTime = v9;
          }
          if ( lpKernelTime )
          {
            v12 = v25;
            v13 = 0;
            v14 = 0;
            if ( v25 > 0 )
            {
              v15 = (char *)Address + 8;
              do
              {
                v16 = *(_QWORD *)v15 + __PAIR__(v14, v13);
                v14 = v16 >> 32;
                v13 = v16;
                v15 += 48;
                --v12;
              }
              while ( v12 );
            }
            lpKernelTime->dwLowDateTime = v13;
            lpKernelTime->dwHighDateTime = v14;
          }
          if ( lpUserTime )
          {
            v17 = v25;
            v18 = 0;
            v19 = 0;
            if ( v25 > 0 )
            {
              v20 = (char *)Address + 16;
              do
              {
                v21 = *(_QWORD *)v20 + __PAIR__(v19, v18);
                v19 = v21 >> 32;
                v18 = v21;
                v20 += 48;
                --v17;
              }
              while ( v17 );
            }
            lpUserTime->dwLowDateTime = v18;
            lpUserTime->dwHighDateTime = v19;
          }
          v3 = 0;
        }
        else
        {
          v3 = -1073741595;
        }
      }
      v22 = KernelBaseGetGlobalData();
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v22 + 44), Address);
      if ( v3 >= 0 )
        return 1;
    }
    else
    {
      v3 = -1073741801;
    }
  }
  BaseSetLastNTError(v3);
  return 0;
}

//----- (77E3F20B) --------------------------------------------------------
DWORD __stdcall GetProcessIdOfThreadStub(HANDLE Thread)
{
  return GetProcessIdOfThread(Thread);
}

//----- (77E3F266) --------------------------------------------------------
BOOL __stdcall EnumUILanguagesProcW(LPWSTR Str, LONG_PTR a2)
{
  __int16 v2; // di@3
  unsigned int v3; // ecx@4
  PVOID v5; // eax@9

  if ( Str && a2 )
  {
    v2 = _wcstoul(Str, 0, 16);
    if ( v2 )
    {
      v3 = *(_DWORD *)(a2 + 4);
      if ( *(_DWORD *)a2 < v3 )
      {
LABEL_5:
        *(_WORD *)(*(_DWORD *)(a2 + 8) + 2 * (*(_DWORD *)a2)++) = v2;
        return 1;
      }
      v5 = RtlReAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(a2 + 8), 2 * v3 + 64);
      if ( v5 )
      {
        *(_DWORD *)(a2 + 4) += 32;
        *(_DWORD *)(a2 + 8) = v5;
        goto LABEL_5;
      }
      BaseSetLastNTError(-1073741801);
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}

//----- (77E3F2C4) --------------------------------------------------------
int __stdcall GetInstalledMUILanguages(HMODULE hModule, int a2)
{
  int v2; // esi@1
  wchar_t *v3; // eax@5
  HANDLE v4; // edi@6
  unsigned int v6; // ecx@12
  PVOID v7; // ebx@16
  unsigned int v8; // eax@19
  unsigned int v9; // edi@20
  int v10; // esi@24
  size_t v11; // kr00_4@26
  int v12; // eax@27
  LPCWSTR v13; // edi@28
  __int16 v14; // ax@29
  wchar_t *v15; // eax@32
  int v16; // eax@33
  PVOID v17; // eax@35
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-AA0h]@11
  ULONG ReturnLength; // [sp+14h] [bp-A98h]@21
  size_t v20; // [sp+18h] [bp-A94h]@26
  __int16 v21; // [sp+1Ch] [bp-A90h]@11
  int v22; // [sp+20h] [bp-A8Ch]@1
  void *Src; // [sp+24h] [bp-A88h]@18
  LPCWSTR lpFileName; // [sp+28h] [bp-A84h]@1
  PVOID BaseAddress; // [sp+2Ch] [bp-A80h]@1
  char Dst; // [sp+30h] [bp-A7Ch]@6
  WCHAR SourceString; // [sp+5Ch] [bp-A50h]@11
  WCHAR Buffer; // [sp+280h] [bp-82Ch]@23
  WCHAR TargetPath; // [sp+690h] [bp-41Ch]@25
  WCHAR Filename[260]; // [sp+898h] [bp-214h]@4
  int DeviceName; // [sp+AA0h] [bp-Ch]@24
  wchar_t v32; // [sp+AA4h] [bp-8h]@24

  lpFileName = 0;
  v2 = a2;
  BaseAddress = hModule;
  v22 = a2;
  if ( !hModule || !a2 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  if ( (unsigned __int8)hModule & 3 )
  {
    if ( LdrGetFileNameFromLoadAsDataTable(hModule, &Src) >= 0 )
    {
      v8 = wcslen((const unsigned __int16 *)Src);
      if ( v8 < 0x104 )
      {
        v9 = v8;
        memcpy(Filename, Src, 2 * v8);
        Filename[v9] = 0;
        goto LABEL_5;
      }
    }
  }
  else if ( GetModuleFileNameW(hModule, Filename, 0x104u) )
  {
LABEL_5:
    v3 = _wcsrchr(Filename, 0x5Cu) + 1;
    *v3 = 42;
    v3[1] = 0;
    lpFileName = Filename;
    goto LABEL_6;
  }
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0x218u);
  if ( !v7 )
  {
LABEL_17:
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  if ( NtQueryVirtualMemory((HANDLE)0xFFFFFFFF, BaseAddress, MemorySectionName, v7, 0x218u, &ReturnLength) >= 0 )
  {
    lpFileName = (LPCWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, *(_WORD *)v7);
    if ( !lpFileName )
      goto LABEL_17;
    Buffer = 0;
    if ( GetLogicalDriveStringsW(0x207u, &Buffer) )
    {
      DeviceName = *(_DWORD *)L" :";
      v32 = asc_77E4FB2C[2];
      v10 = 0;
      BaseAddress = &Buffer;
      do
      {
        LOWORD(DeviceName) = *(_WORD *)BaseAddress;
        if ( QueryDosDeviceW((LPCWSTR)&DeviceName, &TargetPath, 0x104u) )
        {
          v11 = wcslen(&TargetPath);
          v20 = v11;
          if ( v11 >= 0x104 )
            goto LABEL_37;
          v12 = __wcsnicmp(*((const wchar_t **)v7 + 1), &TargetPath, v11);
          v10 = v12 == 0;
          if ( !v12 )
          {
            v13 = lpFileName;
            memcpy((void *)lpFileName, &DeviceName, 2 * wcslen((const unsigned __int16 *)&DeviceName));
            memcpy(
              (void *)&v13[wcslen((const unsigned __int16 *)&DeviceName)],
              (const void *)(2 * v20 + *((_DWORD *)v7 + 1)),
              *(_WORD *)v7 - 2 * v20);
          }
        }
        do
        {
          v14 = *(_WORD *)BaseAddress;
          BaseAddress = (char *)BaseAddress + 2;
        }
        while ( v14 );
      }
      while ( !v10 && *(_WORD *)BaseAddress );
    }
    v15 = _wcsrchr(lpFileName, 0x5Cu);
    if ( !v15 )
    {
LABEL_37:
      BaseSetLastNTError(-1073741672);
      return 0;
    }
    v16 = (int)(v15 + 1);
    *(_WORD *)v16 = 42;
    *(_WORD *)(v16 + 2) = 0;
  }
  v2 = v22;
LABEL_6:
  memset(&Dst, 0, 0x250u);
  v4 = FindFirstFileW(lpFileName, (LPWIN32_FIND_DATAW)&Dst);
  if ( v4 != (HANDLE)-1 )
  {
    while ( 1 )
    {
      if ( Dst & 0x10 )
      {
        RtlInitUnicodeString(&DestinationString, &SourceString);
        if ( (unsigned __int8)RtlCultureNameToLCID(&DestinationString, &v21) )
        {
          v6 = *(_DWORD *)(v2 + 4);
          if ( *(_DWORD *)v2 >= v6 )
          {
            v17 = RtlReAllocateHeap(
                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                    0,
                    *(PVOID *)(v2 + 8),
                    2 * v6 + 64);
            if ( !v17 )
            {
              BaseSetLastNTError(-1073741801);
              FindClose(v4);
              return 0;
            }
            *(_DWORD *)(v2 + 4) += 32;
            *(_DWORD *)(v2 + 8) = v17;
          }
          *(_WORD *)(*(_DWORD *)(v2 + 8) + 2 * (*(_DWORD *)v2)++) = v21;
        }
      }
      if ( !FindNextFileW(v4, (LPWIN32_FIND_DATAW)&Dst) )
      {
        FindClose(v4);
        return 1;
      }
    }
  }
  return 0;
}
// 77DE1314: using guessed type int __stdcall LdrGetFileNameFromLoadAsDataTable(_DWORD, _DWORD);
// 77DE1320: using guessed type int __stdcall RtlCultureNameToLCID(_DWORD, _DWORD);
// 77E4FB2C: using guessed type wchar_t asc_77E4FB2C[3];
// 77E3F2C4: using guessed type WCHAR Filename[260];

//----- (77E3F4CE) --------------------------------------------------------
int __stdcall EnumResourceLanguagesInternal(int a1, PWCHAR UnicodeString, int a3, int a4, int a5, char a6, int a7, char a8)
{
  int v8; // eax@60
  WCHAR *v9; // edi@3
  int v10; // eax@6
  unsigned __int16 v11; // di@12
  int v12; // esi@20
  unsigned int i; // eax@21
  unsigned __int32 v14; // esi@35
  int v15; // edi@36
  int v16; // eax@40
  unsigned int j; // ecx@40
  int v18; // esi@52
  unsigned __int16 v20; // ax@100
  int v21; // eax@107
  int v22; // [sp+10h] [bp-1A8h]@33
  char v23; // [sp+14h] [bp-1A4h]@58
  unsigned int v24; // [sp+18h] [bp-1A0h]@22
  int v25; // [sp+1Ch] [bp-19Ch]@57
  ULONG v26; // [sp+20h] [bp-198h]@1
  int v27; // [sp+24h] [bp-194h]@36
  ULONG ResultSize; // [sp+28h] [bp-190h]@1
  unsigned int v29; // [sp+30h] [bp-188h]@41
  int v30; // [sp+34h] [bp-184h]@1
  int v31; // [sp+38h] [bp-180h]@2
  int v32; // [sp+3Ch] [bp-17Ch]@3
  int v33; // [sp+40h] [bp-178h]@58
  unsigned __int32 v34; // [sp+44h] [bp-174h]@34
  int v35; // [sp+48h] [bp-170h]@1
  int v36; // [sp+4Ch] [bp-16Ch]@1
  PWCHAR v37; // [sp+50h] [bp-168h]@1
  int v38; // [sp+54h] [bp-164h]@1
  int v39; // [sp+58h] [bp-160h]@1
  int v40; // [sp+5Ch] [bp-15Ch]@1
  SIZE_T pResult; // [sp+60h] [bp-158h]@1
  int v42; // [sp+64h] [bp-154h]@33
  unsigned int v43; // [sp+68h] [bp-150h]@1
  LONG_PTR lParam; // [sp+6Ch] [bp-14Ch]@1
  int v45; // [sp+70h] [bp-148h]@1
  PVOID Address; // [sp+74h] [bp-144h]@1
  int v47; // [sp+78h] [bp-140h]@4
  int v48; // [sp+7Ch] [bp-13Ch]@4
  int v49; // [sp+80h] [bp-138h]@1
  PVOID v50; // [sp+84h] [bp-134h]@1
  PVOID v51; // [sp+88h] [bp-130h]@1
  PVOID ImageBase; // [sp+8Ch] [bp-12Ch]@4
  ULONG Size; // [sp+90h] [bp-128h]@12
  int v54; // [sp+94h] [bp-124h]@4
  NTSTATUS NtStatus; // [sp+98h] [bp-120h]@6
  __int16 v56[130]; // [sp+9Ch] [bp-11Ch]@23
  CPPEH_RECORD ms_exc; // [sp+1A0h] [bp-18h]@4

  v49 = a1;
  v30 = (int)UnicodeString;
  v37 = (PWCHAR)a3;
  v39 = a4;
  v43 = 0;
  lParam = 0;
  v45 = 0;
  Address = 0;
  v36 = 0;
  v40 = ((unsigned int)a6 >> 3) & 1;
  v50 = 0;
  ResultSize = 0;
  v51 = 0;
  v26 = 0;
  pResult = ~(unsigned __int8)((unsigned int)a6 >> 4) & 1;
  v35 = 0;
  v38 = 0;
  if ( !CheckEnumFlags((int)&a6, 1) )
    goto LABEL_67;
  v31 = BaseDllMapResourceIdW(UnicodeString);
  if ( v31 == -1 )
    goto LABEL_67;
  v9 = v37;
  v32 = BaseDllMapResourceIdW(v37);
  if ( v32 == -1 )
  {
    BaseDllFreeResourceId(v31);
LABEL_67:
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v54 = 1;
  v48 = 0;
  v47 = 0;
  ms_exc.registration.TryLevel = 0;
  ImageBase = BasepMapModuleHandle((void *)v49, 1);
  if ( a8 & 1 )
  {
    if ( (unsigned int)UnicodeString & 0xFFFF0000 )
    {
      NtStatus = ConverStringWithHeapAlloc(UnicodeString, (int)&v50, (ULONG)&ResultSize);
      if ( NtStatus < 0 )
        goto LABEL_71;
    }
    else
    {
      v50 = UnicodeString;
    }
    if ( (unsigned int)v9 & 0xFFFF0000 )
    {
      NtStatus = ConverStringWithHeapAlloc(v9, (int)&v51, (ULONG)&v26);
      if ( NtStatus < 0 )
        goto LABEL_71;
    }
    else
    {
      v51 = v9;
    }
  }
  if ( pResult )
  {
    v10 = GetRcConfig((int)ImageBase, v40, (int)&v35);
    NtStatus = v10;
    if ( v10 < 0 )
    {
      if ( v10 == -1073741701 )
        goto LABEL_71;
    }
    else
    {
      NtStatus = LdrRscIsTypeExist(v35, v31, 0, &v38);
      if ( NtStatus < 0 )
      {
LABEL_71:
        v54 = 0;
        goto LABEL_45;
      }
    }
  }
  if ( !(a6 & 6) )
    goto LABEL_30;
  if ( !v35 || !(*(_BYTE *)(v35 + 16) & 1) )
  {
    NtStatus = -1073020927;
    goto LABEL_91;
  }
  if ( v38 & 0x20000 )
  {
    NtStatus = -1073741686;
LABEL_91:
    v47 = 0;
    goto LABEL_30;
  }
  lParam = 0;
  Size = 0;
  v11 = a7;
  if ( !(_WORD)a7 )
  {
    Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0x40u);
    if ( !Address )
    {
      NtStatus = -1073741801;
      goto LABEL_71;
    }
    v45 = 32;
    EnumUILanguagesW(EnumUILanguagesProcW, 0, (LONG_PTR)&lParam);
    while ( 1 )
    {
      if ( v36 )
        GetInstalledMUILanguages((HMODULE)ImageBase, (int)&lParam);
      if ( !lParam )
      {
        *(_WORD *)Address = GetUserDefaultUILanguage();
LABEL_84:
        lParam = 1;
      }
LABEL_18:
      if ( Size < lParam )
        break;
      if ( v36 || a6 & 4 || v11 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        Address = 0;
        goto LABEL_30;
      }
      v36 = 1;
    }
    if ( v11 )
      v12 = v11;
    else
      v12 = *((_WORD *)Address + Size);
    for ( i = 0; ; ++i )
    {
      v24 = i;
      if ( i >= v43 )
        break;
      if ( v56[i] == (_WORD)v12 )
        goto LABEL_24;
    }
    NtStatus = LdrLoadAlternateResourceModuleEx(ImageBase, v12, &v25, 0, 128);
    if ( NtStatus < 0 )
    {
      NtStatus = -1073020927;
    }
    else
    {
      v33 = (unsigned __int16)v12;
      NtStatus = EnumFindResource(v25, v31, v32, v12, a6, (int)&v23);
      if ( NtStatus >= 0 )
      {
        v47 = 1;
        v56[v43++] = v12;
        v8 = a8 & 1 ? _ResourceCallEnumLangRoutine(
                        (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v39,
                        v49,
                        (int)v50,
                        (int)v51,
                        v12,
                        a5) : _ResourceCallEnumLangRoutine(
                                (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v39,
                                v49,
                                v30,
                                (int)v37,
                                v12,
                                a5);
        if ( !v8 )
        {
          NtStatus = -1073020921;
          goto LABEL_71;
        }
      }
    }
LABEL_24:
    ++Size;
    goto LABEL_18;
  }
  if ( !(a6 & 4) || sub_77E6DAE0(a7) )
    goto LABEL_84;
  NtStatus = -1073020927;
LABEL_30:
  if ( !(a6 & 1) )
    goto LABEL_45;
  if ( !(v38 & 0x40000) )
  {
    if ( v40 )
    {
      NtStatus = LdrpResGetMappingSize(ImageBase, &v42, 256, 1);
      if ( NtStatus < 0 )
        v42 = 0;
    }
    NtStatus = GetResourceDirectory(ImageBase, v42, a6, &Size, (int)&v22);
    if ( NtStatus < 0 )
      goto LABEL_45;
    NtStatus = EnumFindResource((int)ImageBase, v31, v32, 0, a6 | 0x400, (int)&v34);
    if ( NtStatus < 0 )
      goto LABEL_45;
    ms_exc.registration.TryLevel = 1;
    v14 = v34;
    if ( v40
      && (ULongAdd(v34, 0x10u, &pResult) < 0
       || v14 + 16 < ((unsigned int)ImageBase & 0xFFFFFFFC)
       || v14 + 16 > v42 + ((unsigned int)ImageBase & 0xFFFFFFFC)) )
      goto LABEL_125;
    v15 = v14 + 16;
    v27 = v14 + 16;
    if ( *(_WORD *)(v14 + 12) )
    {
      NtStatus = -1073741701;
      goto LABEL_44;
    }
    if ( v40
      && (v20 = *(_WORD *)(v14 + 14)) != 0
      && (SIZETMult(v20, 8u, &pResult) < 0
       || v14 + pResult < ((unsigned int)ImageBase & 0xFFFFFFFC)
       || v14 + pResult > v42 + ((unsigned int)ImageBase & 0xFFFFFFFC)) )
    {
LABEL_125:
      BaseSetLastNTError(-1073741701);
    }
    else
    {
      Size = 0;
      while ( 2 )
      {
        if ( Size >= *(_WORD *)(v14 + 14) )
          goto LABEL_44;
        v16 = *(_WORD *)v15;
        for ( j = 0; ; ++j )
        {
          v29 = j;
          if ( j >= v43 )
            break;
          if ( v56[j] == (_WORD)v16 )
            goto LABEL_43;
        }
        v48 = 1;
        if ( a8 & 1 )
          v21 = _ResourceCallEnumLangRoutine(
                  (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v39,
                  v49,
                  (int)v50,
                  (int)v51,
                  v16,
                  a5);
        else
          v21 = _ResourceCallEnumLangRoutine(
                  (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v39,
                  v49,
                  v30,
                  (int)v37,
                  v16,
                  a5);
        if ( v21 )
        {
          v14 = v34;
LABEL_43:
          v15 += 8;
          v27 = v15;
          ++Size;
          continue;
        }
        break;
      }
      NtStatus = -1073020921;
    }
    v54 = 0;
LABEL_44:
    ms_exc.registration.TryLevel = 0;
    goto LABEL_45;
  }
  NtStatus = -1073741686;
  v48 = 0;
LABEL_45:
  ms_exc.registration.TryLevel = -2;
  BaseDllFreeResourceId(v31);
  BaseDllFreeResourceId(v32);
  if ( Address )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    Address = 0;
  }
  if ( (unsigned int)v50 & 0xFFFF0000 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v50);
  if ( (unsigned int)v51 & 0xFFFF0000 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v51);
  if ( a6 & 1 && a6 & 6 && !v47 && !v48 || ~a6 & 1 && a6 & 6 && !v47 )
  {
    v18 = 0;
  }
  else
  {
    if ( !(a6 & 1) || a6 & 6 || v48 )
      v18 = v54;
    else
      v18 = 0;
    if ( v18 )
      NtStatus = 0;
  }
  BaseSetLastNTError(NtStatus);
  return v18;
}
// 77DE12DC: using guessed type int __stdcall LdrLoadAlternateResourceModuleEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E4: using guessed type int __stdcall LdrpResGetMappingSize(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E8: using guessed type int __stdcall LdrRscIsTypeExist(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E26A4E: using guessed type int __stdcall BaseDllMapResourceIdW(_DWORD);
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);
// 77E3F4CE: using guessed type __int16 var_11C[130];

//----- (77E3F956) --------------------------------------------------------
BOOL __stdcall EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceLanguagesExW(hModule, lpType, lpName, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E3F97C) --------------------------------------------------------
BOOL __stdcall EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  return EnumResourceLanguagesInternal(
           (int)hModule,
           (PWCHAR)lpType,
           (int)lpName,
           (int)lpEnumFunc,
           lParam,
           dwFlags,
           LangId,
           0);
}

//----- (77E3F9C0) --------------------------------------------------------
BOOL __stdcall GetDiskFreeSpaceAStub(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
{
  return GetDiskFreeSpaceA(
           lpRootPathName,
           lpSectorsPerCluster,
           lpBytesPerSector,
           lpNumberOfFreeClusters,
           lpTotalNumberOfClusters);
}

//----- (77E3F9D8) --------------------------------------------------------
int __stdcall LCMapStringAStub(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
{
  return LCMapStringA(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (77E3FB3C) --------------------------------------------------------
int __stdcall BaseDllWriteSection(STRING *String1)
{
  int v1; // edi@1
  int result; // eax@3
  size_t v3; // eax@8
  PCHAR v4; // eax@13
  PCHAR v5; // eax@18
  PVOID v6; // esi@20
  int v7; // eax@23
  __int16 v8; // cx@24
  int v9; // eax@29
  char v10; // cl@30
  int v11; // eax@33
  int v12; // eax@35
  int v13; // ecx@37
  int v14; // edx@37
  unsigned int v15; // ecx@37
  int v16; // eax@37
  int v17; // eax@40
  int v18; // ecx@41
  __int16 v19; // dx@43
  int v20; // eax@44
  int v21; // ecx@48
  int v22; // edx@48
  int v23; // edi@48
  int v24; // eax@48
  int v25; // eax@51
  int v26; // ecx@52
  char v27; // dl@54
  int v28; // eax@55
  NTSTATUS v29; // edi@57
  int v30; // [sp+Ch] [bp-24h]@11
  int v31; // [sp+10h] [bp-20h]@28
  int v32; // [sp+14h] [bp-1Ch]@9
  int v33; // [sp+18h] [bp-18h]@22
  int v34; // [sp+1Ch] [bp-14h]@6
  int v35; // [sp+20h] [bp-10h]@22
  void *Dst; // [sp+24h] [bp-Ch]@5
  size_t Size; // [sp+28h] [bp-8h]@1
  char v38; // [sp+2Fh] [bp-1h]@11

  v1 = (int)String1;
  Size = 0;
  if ( BaseDllFindSection(String1) >= 0 )
  {
    if ( *(_DWORD *)&String1->Length == 8 )
      v4 = *(PCHAR *)&String1[12].Length;
    else
      v4 = String1[11].Buffer;
    Dst = v4;
    do
      result = BaseDllAdvanceTextPointer((int)String1, (*(_DWORD *)&String1->Length == 8) + 2);
    while ( result == 261 );
    if ( result != -2147483622 )
      return result;
    v5 = String1[11].Buffer - (PCHAR)Dst;
    v38 = 0;
    v30 = (int)v5;
  }
  else
  {
    if ( *(_DWORD *)&String1->Length == 8 )
      return 0;
    Dst = String1[12].Buffer;
    if ( String1[1].Buffer[25] )
    {
      if ( !BaseDllGetApplicationName((int)String1, 0, (int)&v34) )
        return -1073741811;
      v3 = *(_WORD *)v34 + 8;
    }
    else
    {
      if ( !BaseDllGetApplicationName((int)String1, (int)&v32, 0) )
        return -1073741811;
      v3 = *(_WORD *)v32 + 4;
    }
    Size = v3;
    v38 = 1;
    v30 = 0;
  }
  if ( *(_DWORD *)&String1->Length == 8 )
  {
    v6 = 0;
  }
  else
  {
    if ( String1[1].Buffer[25] )
    {
      if ( !BaseDllGetVariableValue((ULONG)String1, 0, (int)&v33, (int)&v35) )
        return -1073741811;
      v7 = v33;
      Size += v35 - 2;
      while ( *(_WORD *)v7 )
      {
        do
        {
          v8 = *(_WORD *)v7;
          v7 += 2;
        }
        while ( v8 );
        Size += 2;
      }
    }
    else
    {
      if ( !BaseDllGetVariableValue((ULONG)String1, (int)&v31, 0, (int)&v35) )
        return -1073741811;
      v9 = v31;
      Size += v35 - 1;
      while ( *(_BYTE *)v9 )
      {
        do
          v10 = *(_BYTE *)v9++;
        while ( v10 );
        ++Size;
      }
    }
    v11 = KernelBaseGetGlobalData();
    v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v11 + 44), Size + 2);
    if ( !v6 )
      return -1073741801;
    v12 = (int)v6;
    if ( String1[1].Buffer[25] )
    {
      if ( v38 )
      {
        v13 = v34;
        *(_WORD *)v6 = 91;
        v14 = *(_DWORD *)(v13 + 4);
        v15 = (unsigned int)*(_WORD *)v13 >> 1;
        v16 = (int)((char *)v6 + 2);
        if ( v15 )
        {
          do
          {
            --v15;
            *(_WORD *)v16 = *(_WORD *)v14;
            v16 += 2;
            v14 += 2;
          }
          while ( v15 );
          v1 = (int)String1;
        }
        *(_WORD *)v16 = 93;
        v17 = v16 + 2;
        *(_WORD *)v17 = 13;
        v17 += 2;
        *(_WORD *)v17 = 10;
        v12 = v17 + 2;
      }
      v18 = v33;
      while ( *(_WORD *)v18 )
      {
        while ( 1 )
        {
          v19 = *(_WORD *)v18;
          *(_WORD *)v12 = *(_WORD *)v18;
          if ( !v19 )
            break;
          v18 += 2;
          v12 += 2;
        }
        *(_WORD *)v12 = 13;
        v18 += 2;
        v20 = v12 + 2;
        *(_WORD *)v20 = 10;
        v12 = v20 + 2;
      }
    }
    else
    {
      if ( v38 )
      {
        v21 = v32;
        *(_BYTE *)v6 = 91;
        v22 = *(_DWORD *)(v21 + 4);
        v23 = *(_WORD *)v21;
        v24 = (int)((char *)v6 + 1);
        while ( v23 )
        {
          --v23;
          *(_BYTE *)v24++ = *(_BYTE *)v22++;
        }
        v1 = (int)String1;
        *(_BYTE *)v24 = 93;
        v25 = v24 + 1;
        *(_BYTE *)v25++ = 13;
        *(_BYTE *)v25 = 10;
        v12 = v25 + 1;
      }
      v26 = v31;
      while ( *(_BYTE *)v26 )
      {
        while ( 1 )
        {
          v27 = *(_BYTE *)v26;
          *(_BYTE *)v12 = *(_BYTE *)v26;
          if ( !v27 )
            break;
          ++v26;
          ++v12;
        }
        *(_BYTE *)v12 = 13;
        ++v26;
        v28 = v12 + 1;
        *(_BYTE *)v28 = 10;
        v12 = v28 + 1;
      }
    }
  }
  v29 = BaseDllModifyMappedFile(v1, Dst, v30, v6, Size);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
  return v29;
}

//----- (77E3FB8D) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
{
  signed int v4; // eax@1
  BOOL result; // eax@2

  v4 = BaseDllReadWriteIniFile(
         0,
         1,
         0,
         (int)lpFileName,
         (int)lpAppName,
         (int)lpKeyName,
         lpKeyName != 0 ? (unsigned int)lpString : 0,
         0);
  if ( v4 < 0 )
  {
    if ( v4 == -1073741701 )
      RtlSetLastWin32Error(13);
    else
      BaseSetLastNTError(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3FCA1) --------------------------------------------------------
int __stdcall NlsPadInt64ToUnicodeStr(unsigned __int64 Val, int a2, int a3, int a4, int a5)
{
  int v5; // esi@3
  wchar_t *v6; // eax@4
  wchar_t *v7; // edx@4
  int v8; // edi@5
  wchar_t v9; // cx@6
  int v10; // eax@7
  int v11; // esi@8
  int v12; // esi@14
  unsigned int v14; // ecx@27
  void *v15; // esi@27
  unsigned __int8 v16; // cf@28
  unsigned int v17; // ecx@28
  int v18; // edi@28
  int i; // ecx@28
  int v20; // [sp+8h] [bp-8Ch]@1
  int v21; // [sp+Ch] [bp-88h]@1
  wchar_t DstBuf[64]; // [sp+10h] [bp-84h]@4

  v20 = 0;
  v21 = a4;
  if ( (unsigned int)a2 >= 0x16 && (unsigned int)a2 > 0x40 )
  {
    RtlSetLastWin32Error(87);
    return -1;
  }
  if ( a3 )
    v5 = 7;
  else
    v5 = a2;
  v6 = _ui64tow(Val, &DstBuf[v5], 10);
  v7 = v6;
  if ( v6 )
  {
    v8 = (int)(v6 + 1);
    do
    {
      v9 = *v6;
      ++v6;
    }
    while ( v9 );
    v10 = (signed int)((char *)v6 - v8) >> 1;
    if ( v10 < (unsigned int)v5 )
    {
      v11 = v5 - v10;
      v10 += v11;
      do
      {
        --v7;
        --v11;
        *v7 = 48;
      }
      while ( v11 );
    }
    if ( a3 )
    {
      if ( (unsigned int)a2 >= 7 )
      {
        v14 = a2 - 7;
        v15 = &v7[v10];
        if ( a2 != 7 )
        {
          v16 = v14 & 1;
          v17 = v14 >> 1;
          memset32(v15, 3145776, v17);
          v18 = (int)((char *)v15 + 4 * v17);
          for ( i = v16; i; --i )
          {
            *(_WORD *)v18 = 48;
            v18 += 2;
          }
          v15 = (char *)v15 + 2 * (a2 - 7);
        }
        *(_WORD *)v15 = 0;
      }
      else
      {
        *(&v7[a2 - 7] + v10) = 0;
      }
    }
    while ( *v7 )
    {
      if ( v21 )
      {
        if ( a5 <= 0 )
          goto LABEL_21;
        v12 = v21;
        --a5;
        v21 += 2;
        *(_WORD *)v12 = *v7;
      }
      ++v7;
      ++v20;
    }
    if ( !v21 )
      return v20;
    if ( a5 > 0 )
    {
      *(_WORD *)v21 = 0;
      return v20;
    }
LABEL_21:
    RtlSetLastWin32Error(122);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return -1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3FCA1: using guessed type wchar_t DstBuf[64];

//----- (77E3FE67) --------------------------------------------------------
int __stdcall DoFormatDuration(unsigned __int64 a1, int a2, int a3, int a4)
{
  bool v4; // cf@38
  unsigned __int64 v5; // rcx@38
  signed int v6; // eax@39
  __int64 v7; // rdi@42
  unsigned __int64 v8; // rax@48
  int v9; // eax@51
  int v10; // ebx@1
  signed __int16 v11; // di@1
  int v12; // edx@1
  int v13; // ecx@1
  signed __int16 v14; // ax@2
  int v15; // eax@4
  int v16; // eax@5
  int v17; // eax@6
  int v18; // eax@7
  int v19; // eax@8
  int v21; // ebx@68
  signed __int16 v22; // ax@68
  unsigned int v23; // [sp+Ch] [bp-10h]@44
  signed __int16 v24; // [sp+Ch] [bp-10h]@1
  signed __int16 v25; // [sp+10h] [bp-Ch]@43
  unsigned int v26; // [sp+14h] [bp-8h]@1
  int v27; // [sp+18h] [bp-4h]@1
  int v28; // [sp+30h] [bp+14h]@1

  v27 = 0;
  v26 = 0;
  v10 = a2;
  v11 = *(_WORD *)a2;
  v12 = a4 != 0 ? a3 : 0;
  v13 = a2;
  v28 = a4 != 0 ? a3 : 0;
  v24 = *(_WORD *)a2;
  if ( *(_WORD *)a2 )
  {
    v14 = *(_WORD *)a2;
    while ( v14 != 100 )
    {
      v15 = (unsigned __int16)v14 - 39;
      if ( !v15 )
      {
        do
          v13 += 2;
        while ( *(_WORD *)v13 && *(_WORD *)v13 != 39 );
        goto LABEL_11;
      }
      v16 = v15 - 33;
      if ( v16 )
      {
        v17 = v16 - 30;
        if ( !v17 )
        {
          v26 |= 1u;
          goto LABEL_11;
        }
        v18 = v17 - 2;
        if ( v18 )
        {
          v19 = v18 - 5;
          if ( v19 )
          {
            if ( v19 == 6 )
              v26 |= 2u;
          }
          else
          {
            v26 |= 4u;
          }
          goto LABEL_11;
        }
      }
      v26 |= 8u;
LABEL_11:
      v13 += 2;
      v14 = *(_WORD *)v13;
      if ( !*(_WORD *)v13 )
        goto LABEL_12;
    }
    v26 |= 0x10u;
LABEL_12:
    while ( v11 != 39 )
    {
      if ( v11 == 72 )
        goto LABEL_82;
      if ( v11 == 100 )
      {
        v5 = 864000000000i64;
        goto LABEL_63;
      }
      if ( v11 == 102 )
      {
        v5 = 1i64;
        if ( v26 >= 2 )
        {
          HIDWORD(v7) = 10000000;
LABEL_64:
          LODWORD(v7) = 0;
          goto LABEL_43;
        }
LABEL_63:
        HIDWORD(v7) = 0;
        goto LABEL_64;
      }
      if ( v11 == 104 )
      {
LABEL_82:
        v5 = 36000000000i64;
        v6 = v26 < 0x10 ? 0 : 24;
      }
      else
      {
        if ( v11 == 109 )
        {
          v4 = v26 < 8;
          v5 = 600000000i64;
        }
        else
        {
          if ( v11 != 115 )
          {
            if ( v12 )
            {
              if ( v27 >= a4 )
                goto LABEL_30;
              *(_WORD *)v12 = v11;
              v12 += 2;
              v28 = v12;
            }
            ++v27;
            a2 = v10 + 2;
            goto LABEL_23;
          }
          v4 = v26 < 4;
          v5 = 10000000i64;
        }
        v6 = v4 ? 0 : 60;
      }
      LODWORD(v7) = (unsigned __int64)v6 >> 32;
      HIDWORD(v7) = v6;
LABEL_43:
      v25 = v24;
      if ( v24 == 72 )
        v25 = 104;
      v23 = 0;
      while ( *(_WORD *)a2 == v25 || v25 == 104 && *(_WORD *)a2 == 72 )
      {
        ++v23;
        a2 += 2;
      }
      v8 = a1 / v5;
      if ( v7 )
        v8 %= __PAIR__((unsigned int)v7, HIDWORD(v7));
      if ( v23 <= 9 || v25 != 102 )
        v9 = NlsPadInt64ToUnicodeStr(v8, v23, v25 == 102, v28, v28 != 0 ? a4 - v27 : 0);
      else
        v9 = NlsPadInt64ToUnicodeStr(v8, 9, 1, v28, v28 != 0 ? a4 - v27 : 0);
      if ( v9 < 0 )
        return 0;
      v27 += v9;
      if ( v28 )
      {
        if ( v27 >= a4 )
          goto LABEL_30;
        v28 += 2 * v9;
      }
      v12 = v28;
LABEL_23:
      v10 = a2;
      v24 = *(_WORD *)a2;
      if ( !*(_WORD *)a2 )
        goto LABEL_32;
      v11 = *(_WORD *)a2;
    }
    v21 = v10 + 2;
    v22 = *(_WORD *)v21;
    if ( *(_WORD *)v21 )
    {
      while ( v22 != 39 )
      {
        if ( v12 )
        {
          if ( v27 >= a4 )
            goto LABEL_30;
LABEL_77:
          *(_WORD *)v12 = v22;
          v12 += 2;
          v28 = v12;
        }
LABEL_78:
        v21 += 2;
        v22 = *(_WORD *)v21;
        ++v27;
        a2 = v21;
        if ( !*(_WORD *)v21 )
          goto LABEL_23;
      }
      v21 += 2;
      a2 = v21;
      if ( *(_WORD *)v21 != 39 )
        goto LABEL_23;
      if ( !v12 )
        goto LABEL_78;
      if ( v27 >= a4 )
        goto LABEL_30;
      v22 = 39;
      goto LABEL_77;
    }
  }
LABEL_32:
  if ( !v12 )
    return v27 + 1;
  if ( v27 < a4 )
  {
    *(_WORD *)v12 = 0;
    return v27 + 1;
  }
LABEL_30:
  RtlSetLastWin32Error(122);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E3FFB2) --------------------------------------------------------
int __stdcall GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
{
  const WCHAR *v7; // eax@1
  int result; // eax@2

  v7 = (const WCHAR *)InternalLcidToName(Locale, 0);
  if ( v7 )
  {
    result = GetDurationFormatEx(v7, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}
// 77E2A5C4: using guessed type int __fastcall InternalLcidToName(_DWORD, _DWORD);

//----- (77E3FFED) --------------------------------------------------------
int __stdcall GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
{
  int v7; // eax@1

  v7 = GetNamedLocaleHashNode(lpLocaleName, 0);
  if ( !v7 || cchDuration < 0 || !lpDurationStr && cchDuration || lpDuration && ullDuration )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(dwFlags & 0xBFFFFFFF) && (!lpFormat || !(dwFlags & 0x80000000)) )
      return GetDurationFormatWorker(
               v7,
               dwFlags,
               (int)lpDuration,
               ullDuration,
               HIDWORD(ullDuration),
               (int)lpFormat,
               (int)lpDurationStr,
               cchDuration);
    RtlSetLastWin32Error(1004);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3FC4E: using guessed type int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD);

//----- (77E40065) --------------------------------------------------------
int __stdcall GetDurationFormatWorker(int a1, int a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8)
{
  unsigned int v8; // ebx@2
  unsigned int v9; // esi@2
  int v10; // eax@3

  if ( a3 )
  {
    v8 = (10000000 * (unsigned __int64)*(_WORD *)(a3 + 14) / 0x3E8
        + 10000000
        * (*(_WORD *)(a3 + 12) + 60 * (*(_WORD *)(a3 + 10) + 60 * (*(_WORD *)(a3 + 8) + 24i64 * *(_WORD *)(a3 + 6))))) >> 32;
    v9 = 10000000 * (unsigned __int64)*(_WORD *)(a3 + 14) / 0x3E8
       + 10000000
       * (*(_WORD *)(a3 + 12) + 60 * (*(_WORD *)(a3 + 10) + 60 * (*(_WORD *)(a3 + 8) + 24 * *(_WORD *)(a3 + 6))));
  }
  else
  {
    v8 = a5;
    v9 = a4;
  }
  v10 = a6;
  if ( !a6 )
    v10 = GetLocaleNullStringFromArrayInPool(*(_DWORD *)(a1 + 24), *(_DWORD *)(*(_DWORD *)(a1 + 16) + 104), 0);
  return DoFormatDuration(__PAIR__(v8, v9), v10, a7, a8);
}

//----- (77E40179) --------------------------------------------------------
BOOL __stdcall GetVolumeInformationByHandleWStub(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
{
  return GetVolumeInformationByHandleW(
           hFile,
           lpVolumeNameBuffer,
           nVolumeNameSize,
           lpVolumeSerialNumber,
           lpMaximumComponentLength,
           lpFileSystemFlags,
           lpFileSystemNameBuffer,
           nFileSystemNameSize);
}

//----- (77E40204) --------------------------------------------------------
HRESULT __stdcall GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
{
  HRESULT v5; // edi@3
  HRESULT result; // eax@4
  char Dst; // [sp+4h] [bp-40h]@1
  int v8; // [sp+Ch] [bp-38h]@7
  void *v9; // [sp+14h] [bp-30h]@8
  DWORD v10; // [sp+3Ch] [bp-8h]@10
  DWORD v11; // [sp+40h] [bp-4h]@12

  memset(&Dst, 0, 0x40u);
  if ( hProcess && pRecoveryCallback )
  {
    v5 = WerpGetRecoveryRoutine(hProcess, &Dst);
    if ( v5 >= 0 )
    {
      *pRecoveryCallback = (APPLICATION_RECOVERY_CALLBACK)RtlDecodeSystemPointer(v8);
      if ( ppvParameter )
        *ppvParameter = v9;
      if ( pdwPingInterval )
        *pdwPingInterval = v10;
      if ( pdwFlags )
        *pdwFlags = v11;
    }
    result = v5;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E40255) --------------------------------------------------------
int __stdcall WerpGetRecoveryRoutine(HANDLE hProcess, void *Dst)
{
  LPVOID v2; // eax@3
  LPVOID v3; // ebx@3
  int result; // eax@9
  int v5; // [sp+14h] [bp-1Ch]@4

  if ( hProcess && Dst )
  {
    v2 = VirtualAlloc(0, 0x8D0u, 0x1000u, 4u);
    v3 = v2;
    if ( v2 )
    {
      memset(v2, 0, 0x8D0u);
      memset(Dst, 0, 0x40u);
      v5 = WerpGetHeaderFromProcess(hProcess, (struct _WER_PEB_HEADER_BLOCK *)v3);
      if ( v5 >= 0 )
      {
        if ( *((_QWORD *)v3 + 262) )
          qmemcpy(Dst, (char *)v3 + 2088, 0x40u);
        else
          v5 = -2147023728;
      }
    }
    else
    {
      DbgPrintOut(0, "OOM");
      v5 = -2147024882;
    }
    if ( v3 )
      VirtualFree(v3, 0, 0x8000u);
    result = v5;
  }
  else
  {
    DbgPrintOut(0, "Invalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E40322) --------------------------------------------------------
HRESULT __stdcall WerGetFlags(HANDLE hProcess, PDWORD pdwFlags)
{
  return WerpGetFlags(hProcess, pdwFlags);
}

//----- (77E4032F) --------------------------------------------------------
signed int __stdcall WerpGetFlags(HANDLE hProcess, PDWORD pdwFlags)
{
  signed int result; // eax@4
  int v3; // [sp+10h] [bp-8F0h]@3
  int v4; // [sp+14h] [bp-8ECh]@1
  char Dst; // [sp+18h] [bp-8E8h]@1
  DWORD v6; // [sp+898h] [bp-68h]@6
  CPPEH_RECORD ms_exc; // [sp+8E8h] [bp-18h]@6

  v4 = 0;
  memset(&Dst, 0, 0x8CCu);
  if ( hProcess && pdwFlags )
  {
    v3 = WerpGetHeaderFromProcess(hProcess, (struct _WER_PEB_HEADER_BLOCK *)&v4);
    if ( v3 >= 0 )
    {
      *pdwFlags = v6;
      v3 = 0;
      ms_exc.registration.TryLevel = -2;
    }
    result = v3;
  }
  else
  {
    DbgPrintOut(0, "Invalid params");
    result = -2147024809;
  }
  return result;
}

//----- (77E403C1) --------------------------------------------------------
BOOL __stdcall BasepIsDebugPortPresent()
{
  int ProcessInformation; // [sp+0h] [bp-4h]@1

  ProcessInformation = 0;
  return NtQueryInformationProcess((HANDLE)0xFFFFFFFF, ProcessDebugPort, &ProcessInformation, 4u, 0) >= 0
      && ProcessInformation;
}

//----- (77E403F4) --------------------------------------------------------
signed int __stdcall WerpReportExceptionInProcessContext(int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( **(_DWORD **)a1 == -1073741571 )
    result = 0;
  return result;
}

//----- (77E40449) --------------------------------------------------------
int __stdcall CheckForReadOnlyResourceFilter(int a1)
{
  int result; // eax@2

  if ( BasepAllowResourceConversion )
    result = CheckForReadOnlyResource(a1, 0);
  else
    result = 0;
  return result;
}
// 77EA6540: using guessed type char BasepAllowResourceConversion;

//----- (77E4046E) --------------------------------------------------------
int __stdcall CheckForReadOnlyResource(int a1, int a2)
{
  _DWORD *v2; // eax@2
  unsigned int v4; // eax@10
  char MemoryInformation; // [sp+10h] [bp-54h]@7
  PVOID ImageBase; // [sp+14h] [bp-50h]@10
  int v7; // [sp+24h] [bp-40h]@8
  int v8; // [sp+28h] [bp-3Ch]@9
  ULONG OldProtect; // [sp+2Ch] [bp-38h]@19
  ULONG ProtectSize; // [sp+30h] [bp-34h]@19
  unsigned int v11; // [sp+38h] [bp-2Ch]@10
  int v12; // [sp+3Ch] [bp-28h]@8
  ULONG Size; // [sp+40h] [bp-24h]@10
  int v14; // [sp+44h] [bp-20h]@10
  PVOID BaseAddress; // [sp+48h] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@10
  signed int v17; // [sp+6Ch] [bp+8h]@9

  if ( a2 & 0xFFFFFFFE )
    return 0;
  v2 = *(_DWORD **)a1;
  if ( **(_DWORD **)a1 != -1073741819 )
    return 0;
  if ( v2[5] != 1 )
    return 0;
  if ( v2[4] < 2u )
    return 0;
  BaseAddress = (PVOID)v2[6];
  if ( NtQueryVirtualMemory((HANDLE)0xFFFFFFFF, BaseAddress, 0, &MemoryInformation, 0x1Cu, 0) < 0 )
    return 0;
  v12 = 0;
  if ( v7 == 2 )
  {
    v17 = 0;
    if ( v8 == 0x1000000 )
    {
      ms_exc.registration.TryLevel = 0;
      v4 = (unsigned int)RtlImageDirectoryEntryToData(ImageBase, 1u, 2u, &Size);
      v11 = v4;
      v14 = 0;
      ms_exc.registration.TryLevel = -2;
      if ( !v4 || (unsigned int)BaseAddress < v4 || (unsigned int)BaseAddress >= v4 + Size )
        goto LABEL_18;
    }
    else if ( v8 != 0x40000 || !(a2 & 1) )
    {
LABEL_18:
      if ( v17 )
      {
        ProtectSize = 1;
        if ( NtProtectVirtualMemory((HANDLE)0xFFFFFFFF, &BaseAddress, &ProtectSize, 8u, &OldProtect) >= 0 )
          v12 = -1;
      }
      return v12;
    }
    v17 = 1;
    goto LABEL_18;
  }
  return v12;
}

//----- (77E404C9) --------------------------------------------------------
BOOL __stdcall GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  DWORD ThreadInformation; // [sp+0h] [bp-Ch]@1
  int v6; // [sp+4h] [bp-8h]@2
  DWORD v7; // [sp+8h] [bp-4h]@2

  ThreadInformation = dwSelector;
  v3 = NtQueryInformationThread(hThread, ThreadDescriptorTableEntry, &ThreadInformation, 0xCu, 0);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    *(_DWORD *)&lpSelectorEntry->LimitLow = v6;
    lpSelectorEntry->HighWord.Bits.BaseHi = v7;
    result = 1;
  }
  return result;
}

//----- (77E4054F) --------------------------------------------------------
int __stdcall BasepIsKernelDebuggerPresent()
{
  int v0; // esi@1
  char SystemInformation; // [sp+8h] [bp-4h]@1
  char v3; // [sp+9h] [bp-3h]@1

  SystemInformation = 0;
  v3 = 0;
  v0 = 0;
  if ( NtQuerySystemInformation(SystemExceptionInformation|SystemPerformanceInformation, &SystemInformation, 2u, 0) >= 0 )
    v0 = SystemInformation && !v3;
  return v0;
}

//----- (77E40593) --------------------------------------------------------
int __stdcall __noreturn WerpReportFaultInternal(int a1, int a2)
{
  LPVOID v2; // esi@1
  HANDLE v3; // eax@2
  LPVOID v4; // eax@3
  HANDLE v5; // edi@4
  HANDLE v6; // ST0C_4@4
  DWORD v7; // eax@4
  int v8; // eax@4
  DWORD v9; // eax@6
  HANDLE v11; // ST10_4@23
  HANDLE v12; // eax@23
  struct _SECURITY_ATTRIBUTES EventAttributes; // [sp+10h] [bp-44h]@1
  HANDLE Handles; // [sp+1Ch] [bp-38h]@6
  HANDLE v15; // [sp+20h] [bp-34h]@6
  struct _WER_RECOVERY_INFO *v16; // [sp+24h] [bp-30h]@1
  LPVOID v17; // [sp+28h] [bp-2Ch]@1
  __int32 v18; // [sp+2Ch] [bp-28h]@1
  HANDLE Handle; // [sp+30h] [bp-24h]@1
  HANDLE v20; // [sp+34h] [bp-20h]@1
  HANDLE hHandle; // [sp+38h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@1

  v20 = 0;
  v2 = 0;
  v17 = 0;
  v18 = -2147467259;
  Handle = 0;
  hHandle = 0;
  v16 = 0;
  ms_exc.registration.TryLevel = 0;
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.bInheritHandle = 1;
  Handle = CreateEventW(&EventAttributes, 1, 0, 0);
  if ( !Handle )
  {
    DbgPrintOut(0, "CreateEvent failed");
    goto LABEL_8;
  }
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.bInheritHandle = 1;
  v3 = CreateFileMappingW((HANDLE)0xFFFFFFFF, &EventAttributes, 4u, 0, 0xD0u, 0);
  v20 = v3;
  if ( !v3 )
  {
    DbgPrintOut(0, "CreateFileMapping failed");
    goto LABEL_8;
  }
  v4 = MapViewOfFile(v3, 6u, 0, 0, 0);
  v2 = v4;
  v17 = v4;
  if ( !v4 )
  {
    DbgPrintOut(0, "MapViewOfFile failed");
    goto LABEL_8;
  }
  memset(v4, 0, 0xD0u);
  *(_DWORD *)v2 = 208;
  *((_DWORD *)v2 + 1) = GetCurrentProcessId();
  *((_DWORD *)v2 + 2) = GetCurrentThreadId();
  v5 = Handle;
  *((_QWORD *)v2 + 23) = (signed int)Handle;
  *((_DWORD *)v2 + 44) = -2147467259;
  *((_QWORD *)v2 + 21) = a1;
  v6 = v20;
  v7 = GetCurrentProcessId();
  v8 = RtlWerpReportException(v7, v6, 0, &hHandle);
  if ( v8 < 0 )
  {
    DbgPrintOut(0, "RtlWerpReportException failed with status code :%d. Will try to launch the process directly", v8);
    if ( **(_DWORD **)a1 == -1073741571 )
    {
      v18 = -2147024846;
      goto LABEL_8;
    }
    v11 = v20;
    v12 = GetCurrentProcess();
    if ( StartCrashVertical(v12, v11, &hHandle) < 0 || !hHandle )
    {
      DbgPrintOut(0, "StartCrashVertial failed");
      goto LABEL_8;
    }
  }
  else if ( !hHandle )
  {
    v18 = 327683;
    goto LABEL_8;
  }
  Handles = hHandle;
  v15 = v5;
  v9 = WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF);
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( WerpGetRecoveryInfoForSelf(&v16) >= 0 )
      {
        WerpInitiateRecovery(v16);
        WaitForSingleObject(hHandle, 0xFFFFFFFF);
      }
    }
    else
    {
      DbgPrintOut(0, "WaitForMultipleObjects returned with %d", v9);
    }
  }
  v18 = *((_DWORD *)v2 + 44);
LABEL_8:
  ms_exc.registration.TryLevel = -2;
  if ( Handle )
  {
    NtClose(Handle);
    Handle = 0;
  }
  if ( v2 )
  {
    UnmapViewOfFile(v2);
    v17 = 0;
  }
  if ( v20 )
  {
    NtClose(v20);
    v20 = 0;
  }
  if ( hHandle )
    NtClose(hHandle);
  return MapReturnCode(v18);
}
// 77DE16DC: using guessed type int __stdcall RtlWerpReportException(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E40709) --------------------------------------------------------
LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  int v1; // ebx@1
  PEXCEPTION_RECORD v2; // eax@1
  int v3; // edi@5
  int v4; // ecx@9
  LONG result; // eax@12
  signed int v6; // eax@21
  signed int v7; // esi@21
  LPVOID v8; // eax@38
  ULONG *v9; // eax@43
  int v10; // ecx@45
  ULONG v11; // eax@55
  char JobInformation; // [sp+10h] [bp-6Ch]@19
  int v13; // [sp+20h] [bp-5Ch]@20
  ULONG Arguments; // [sp+40h] [bp-3Ch]@43
  ULONG v15; // [sp+44h] [bp-38h]@43
  int v16; // [sp+48h] [bp-34h]@48
  ULONG v17; // [sp+4Ch] [bp-30h]@51
  LONG v18; // [sp+50h] [bp-2Ch]@2
  int v19; // [sp+54h] [bp-28h]@1
  int v20; // [sp+58h] [bp-24h]@1
  ULONG MessageBoxResult; // [sp+5Ch] [bp-20h]@1
  LPVOID lpAddress; // [sp+60h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+64h] [bp-18h]@36
  struct _EXCEPTION_POINTERS *ExceptionInfoa; // [sp+84h] [bp+8h]@21

  MessageBoxResult = 6;
  lpAddress = 0;
  v20 = 0;
  v19 = 0;
  v1 = (int)ExceptionInfo;
  v2 = ExceptionInfo->ExceptionRecord;
  if ( ExceptionInfo->ExceptionRecord->ExceptionFlags & 0x10 )
    return 0;
  v18 = 1;
  if ( v2->ExceptionCode == -1073740791 && (BasepIsKernelDebuggerPresent() || BasepIsDebugPortPresent()) )
  {
    DbgPrint("\r\nSTATUS_STACK_BUFFER_OVERRUN encountered\r\n");
    __debugbreak();
    ms_exc.registration.TryLevel = -2;
  }
  if ( CheckForReadOnlyResourceFilter((int)ExceptionInfo) == -1 )
    return -1;
  if ( BasepIsDebugPortPresent() )
    return 0;
  RtlAcquireSRWLockExclusive(&BasepUEFLock);
  v3 = RtlDecodePointer(BasepCurrentTopLevelFilter);
  if ( v3
    && BasepFillUEFInfo((LPCVOID)v3, BasepFilterInfo + 544)
    && *(_DWORD *)BasepFilterInfo == *(_DWORD *)(BasepFilterInfo + 544)
    && *(_DWORD *)(BasepFilterInfo + 4) == *(_DWORD *)(BasepFilterInfo + 548)
    && (v4 = *(_DWORD *)(BasepFilterInfo + 8), v4 == *(_DWORD *)(BasepFilterInfo + 552))
    && (!(v4 & 0x1040000)
     || RtlEqualUnicodeString((PCUNICODE_STRING)(BasepFilterInfo + 12), (PCUNICODE_STRING)(BasepFilterInfo + 556), 1u)) )
  {
    RtlReleaseSRWLockExclusive(&BasepUEFLock);
    result = ((int (__stdcall *)(struct _EXCEPTION_POINTERS *))v3)(ExceptionInfo);
    if ( result == 1 || result == -1 )
      return result;
    if ( !result && BasepIsDebugPortPresent() )
      return 0;
  }
  else
  {
    RtlReleaseSRWLockExclusive(&BasepUEFLock);
  }
  if ( RtlKnownExceptionFilter(ExceptionInfo) == -1 )
    return -1;
  if ( GetErrorMode() & 2
    || RtlGetThreadErrorMode() & 0x20
    || NtQueryInformationJobObject(0, 2u, &JobInformation, 0x30u, 0) >= 0 && v13 & 0x400 )
    return 1;
  ExceptionInfoa = 0;
  v6 = BasepReportFault(v1, 1);
  v7 = v6;
  if ( v6 == 8 || v6 == 6 && BasepIsDebugPortPresent() )
    return 0;
  if ( v7 != 4 )
    goto LABEL_24;
  v8 = VirtualAlloc(0, 0x24Au, 0x1000u, 4u);
  lpAddress = v8;
  if ( !v8 )
    return 0;
  if ( WerpGetDebugger((HANDLE)0xFFFFFFFF, (unsigned __int16 *)v8, 0x125u, (int)&v20, (int)&v19) >= 0
    && *(_WORD *)lpAddress )
    ExceptionInfoa = (struct _EXCEPTION_POINTERS *)1;
  if ( !v20 )
  {
    v9 = *(ULONG **)v1;
    Arguments = **(_DWORD **)v1;
    v15 = v9[3];
    if ( *v9 == -1073741818 )
    {
      if ( v9[4] >= 3 )
      {
        v10 = v9[7];
LABEL_48:
        v16 = v10;
        goto LABEL_50;
      }
    }
    else if ( v9[4] >= 1 )
    {
      v10 = v9[5];
      goto LABEL_48;
    }
    v16 = 0;
LABEL_50:
    if ( v9[4] < 2 )
      v17 = 0;
    else
      v17 = v9[6];
    if ( !ExceptionInfoa || BasepAlreadyHadHardError )
      v11 = 1;
    else
      v11 = 2;
    if ( (NtRaiseHardError(-805306044, 4u, 0, &Arguments, v11, &MessageBoxResult) & 0xC0000000) == -1073741824 )
      MessageBoxResult = 6;
  }
  if ( ExceptionInfoa && (MessageBoxResult == 3 || v20) )
  {
    if ( BasepAlreadyHadHardError )
      goto LABEL_67;
    if ( !*(_BYTE *)(KernelBaseGetGlobalData() + 48) )
    {
      if ( WerpLaunchAeDebug(
             (void *)0xFFFFFFFF,
             (void *)0xFFFFFFFE,
             *(char **)v1,
             *(const void **)(v1 + 4),
             (WCHAR *)lpAddress,
             v19) < 0 )
        BasepAlreadyHadHardError = 1;
      v18 = 0;
      goto LABEL_25;
    }
  }
LABEL_24:
  if ( BasepAlreadyHadHardError )
LABEL_67:
    NtTerminateProcess((HANDLE)0xFFFFFFFF, **(_DWORD **)v1);
LABEL_25:
  if ( lpAddress )
    VirtualFree(lpAddress, 0, 0x8000u);
  return v18;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77DE141C: using guessed type _DWORD __stdcall RtlGetThreadErrorMode();
// 77DE1668: using guessed type int __stdcall RtlDecodePointer(_DWORD);
// 77DE166C: using guessed type int __stdcall RtlKnownExceptionFilter(_DWORD);
// 77EA657C: using guessed type int BasepCurrentTopLevelFilter;
// 77EA678C: using guessed type int BasepUEFLock;
// 77EA6C90: using guessed type char BasepAlreadyHadHardError;

//----- (77E408E1) --------------------------------------------------------
signed int __stdcall BasepReportFault(int a1, int a2)
{
  signed int result; // eax@2

  if ( WerpReportExceptionInProcessContext(a1) )
    result = WerpReportFault(a1, 1);
  else
    result = 8;
  return result;
}

//----- (77E40909) --------------------------------------------------------
signed int __stdcall WerpReportFault(int a1, int a2)
{
  signed int v2; // edi@1
  signed int result; // eax@10

  v2 = 0;
  if ( a1 )
  {
    if ( InterlockedCompareExchange(&dword_77EA6574, 1, 0) )
    {
      v2 = 1;
      do
        Sleep(0x3E8u);
      while ( InterlockedCompareExchange(&dword_77EA6574, 1, 0) );
    }
    if ( dword_77EA6578 > 0 )
    {
      result = 8;
    }
    else
    {
      if ( !v2 )
        WerpReportFaultInternal(a1, a2);
      result = 8;
      if ( a2 & 1 )
        ++dword_77EA6578;
    }
    dword_77EA6574 = 0;
  }
  else
  {
    DbgPrintOut(0, "WerpReportFault Invalid params passed");
    result = 3;
  }
  return result;
}
// 77EA6578: using guessed type int dword_77EA6578;

//----- (77E4096F) --------------------------------------------------------
int __stdcall MapReturnCode(__int32 a1)
{
  if ( a1 == -2146893978 )
    return 3;
  if ( a1 == -2146893977 || !a1 )
    return 0;
  if ( a1 == 327680 )
    return 6;
  if ( a1 == 327681 )
    return 0;
  return 2 * (a1 != 327683) + 2;
}

//----- (77E40A1E) --------------------------------------------------------
BOOL __stdcall FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
{
  int v2; // esi@1
  BOOL result; // eax@2
  int v4; // esi@4

  v2 = *((_DWORD *)hFindStream + 2);
  if ( v2 == *((_DWORD *)hFindStream + 3) + *((_DWORD *)hFindStream + 1) )
  {
    BaseSetLastNTError(-1073741807);
    result = 0;
  }
  else
  {
    *(_DWORD *)lpFindStreamData = *(_DWORD *)(v2 + 8);
    *((_DWORD *)lpFindStreamData + 1) = *(_DWORD *)(v2 + 12);
    memcpy((char *)lpFindStreamData + 8, (const void *)(v2 + 24), *(_DWORD *)(v2 + 4));
    *((_WORD *)lpFindStreamData + (*(_DWORD *)(v2 + 4) >> 1) + 4) = 0;
    v4 = *(_DWORD *)v2;
    if ( v4 )
      *((_DWORD *)hFindStream + 2) += v4;
    else
      *((_DWORD *)hFindStream + 2) = *((_DWORD *)hFindStream + 3) + *((_DWORD *)hFindStream + 1);
    result = 1;
  }
  return result;
}

//----- (77E40A50) --------------------------------------------------------
void *__stdcall BasepInitializeFindFileHandle(int a1)
{
  int v1; // eax@1
  PVOID v2; // eax@1
  void *v3; // esi@1

  v1 = KernelBaseGetGlobalData();
  v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v1 + 44) + 786432, 0x34u);
  v3 = v2;
  if ( v2 )
  {
    *(_DWORD *)v2 = a1;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
    *((_DWORD *)v2 + 3) = 0;
    *((_DWORD *)v2 + 4) = 0;
    if ( RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)((char *)v2 + 28)) < 0 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
      v3 = 0;
    }
  }
  return v3;
}

//----- (77E40AE0) --------------------------------------------------------
HANDLE __stdcall FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
{
  __int16 v4; // si@1
  HANDLE *v5; // edi@1
  ULONG v6; // esi@9
  PVOID v7; // eax@9
  NTSTATUS v8; // eax@10
  HANDLE v9; // esi@13
  int v10; // eax@14
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-54h]@4
  LSA_UNICODE_STRING ntname; // [sp+28h] [bp-3Ch]@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+30h] [bp-34h]@4
  ULONG Size; // [sp+38h] [bp-2Ch]@1
  HANDLE FileHandle; // [sp+3Ch] [bp-28h]@1
  NTSTATUS NtStatus; // [sp+40h] [bp-24h]@4
  HANDLE *v18; // [sp+44h] [bp-20h]@1
  PVOID Address; // [sp+48h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@4

  v4 = 0;
  Address = 0;
  Size = 32;
  FileHandle = 0;
  v5 = 0;
  v18 = 0;
  if ( InfoLevel || dwFlags )
  {
    RtlSetLastWin32Error(87);
    return (HANDLE)-1;
  }
  if ( !RtlDosPathNameToNtPathName_U((PWSTR)lpFileName, &ntname, 0, 0) )
  {
    RtlSetLastWin32Error(3);
    return (HANDLE)-1;
  }
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ms_exc.registration.TryLevel = 0;
  NtStatus = NtCreateFile(&FileHandle, 0x100080u, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 3u, 1u, 0x200020u, 0, 0);
  if ( !NtStatus )
  {
    v5 = (HANDLE *)BasepInitializeFindFileHandle((int)FileHandle);
    v18 = v5;
    if ( v5 )
    {
      FileHandle = 0;
      do
      {
        if ( Address )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        v6 = Size;
        v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
        Address = v7;
        if ( !v7 )
        {
          NtStatus = -1073741670;
          v5 = v18;
          goto LABEL_16;
        }
        v5 = v18;
        v8 = NtQueryInformationFile(*v18, &IoStatusBlock, v7, v6, FileStreamInformation);
        NtStatus = v8;
        Size = 2 * v6;
      }
      while ( v8 == -2147483643 );
      if ( !v8 )
      {
        if ( IoStatusBlock.Information )
        {
          v5[1] = Address;
          v5[3] = (HANDLE)IoStatusBlock.Information;
          v5[4] = (HANDLE)IoStatusBlock.Information;
          Address = 0;
          v9 = v5[1];
          *(_DWORD *)lpFindStreamData = *((_DWORD *)v9 + 2);
          *((_DWORD *)lpFindStreamData + 1) = *((_DWORD *)v9 + 3);
          memcpy((char *)lpFindStreamData + 8, (char *)v9 + 24, *((_DWORD *)v9 + 1));
          *((_WORD *)lpFindStreamData + (*((_DWORD *)v9 + 1) >> 1) + 4) = 0;
          if ( *(_DWORD *)v9 )
            v10 = (int)((char *)v5[1] + *(_DWORD *)v9);
          else
            v10 = (int)((char *)v5[1] + IoStatusBlock.Information);
          v5[2] = (HANDLE)v10;
        }
        else
        {
          NtStatus = -1073741807;
        }
      }
LABEL_16:
      v4 = 0;
    }
    else
    {
      NtStatus = -1073741670;
    }
  }
  ms_exc.registration.TryLevel = -2;
  if ( (_WORD)ntname.Length != v4 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    v5 = v18;
  }
  if ( NtStatus )
  {
    BaseSetLastNTError(NtStatus);
    if ( FileHandle )
      NtClose(FileHandle);
    if ( Address )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      v5 = v18;
    }
    if ( v5 )
      FindClose(v5);
    v5 = (HANDLE *)-1;
    v18 = (HANDLE *)-1;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E40CA0) --------------------------------------------------------
int __stdcall GetStringScripts(int a1, int a2, int a3, unsigned __int16 *a4, unsigned int a5)
{
  int v5; // edi@1
  unsigned int v6; // ebx@1
  int v7; // esi@2
  int v8; // ecx@8
  int v9; // edi@8
  int v10; // eax@10
  int v11; // edx@10
  int v12; // eax@19
  unsigned int v13; // ecx@23
  unsigned int v14; // eax@23
  int v15; // esi@24
  unsigned int v16; // eax@25
  unsigned int v17; // ecx@25
  int v18; // esi@28
  int result; // eax@32
  int v20; // eax@34
  unsigned __int16 *v21; // ecx@36
  int v22; // eax@48
  unsigned __int16 v23; // dx@48
  int v24; // esi@53
  unsigned int v25; // [sp+8h] [bp-18h]@1
  unsigned int v26; // [sp+Ch] [bp-14h]@1
  unsigned __int64 v27; // [sp+10h] [bp-10h]@1
  int v28; // [sp+18h] [bp-8h]@1
  int v29; // [sp+1Ch] [bp-4h]@1
  int v30; // [sp+2Ch] [bp+Ch]@8

  v5 = 0;
  v6 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0i64;
  v29 = *(_DWORD *)(KernelBaseGetGlobalData() + 136);
  v28 = *(_DWORD *)(KernelBaseGetGlobalData() + 140);
  if ( a1 && a1 != 1 )
  {
    RtlSetLastWin32Error(1004);
    result = 0;
  }
  else
  {
    v7 = a2;
    if ( !a2 || a3 < -1 || (a5 & 0x80000000) != 0 || (signed int)a5 > 0 && !a4 )
    {
      RtlSetLastWin32Error(87);
      goto LABEL_57;
    }
LABEL_7:
    if ( a3 > 0 || a3 == -1 && *(_WORD *)v7 )
    {
      v8 = *(_WORD *)v7;
      v30 = 0;
      v9 = v29;
      if ( (unsigned int)(v8 - 55296) <= 0x3FF && (a3 > 1 || a3 == -1) )
      {
        v22 = v7 + 2;
        v23 = *(_WORD *)(v7 + 2);
        if ( v23 >= 0xDC00u && v23 <= 0xDFFFu )
        {
          v7 += 2;
          v8 = *(_WORD *)v22 + ((v8 - 55287) << 10);
          if ( a3 != -1 )
            --a3;
        }
      }
      if ( v29 < 0 )
        goto LABEL_52;
      while ( 1 )
      {
        v10 = (v9 + v30) / 2;
        v11 = v28 + 24 * v10;
        if ( *(_DWORD *)v11 <= (unsigned int)v8 )
        {
          if ( *(_DWORD *)(v11 + 4) >= (unsigned int)v8 )
          {
            v12 = v28 + 24 * v10;
            v25 |= *(_DWORD *)(v12 + 8);
            v26 |= *(_DWORD *)(v12 + 12);
            v27 |= *(_QWORD *)(v12 + 16);
LABEL_13:
            if ( v30 > v9 )
LABEL_52:
              LODWORD(v27) = v27 | 0x1000;
            if ( a3 != -1 )
              --a3;
            v6 = v25;
            v7 += 2;
            v5 = 0;
            goto LABEL_7;
          }
          v30 = v10 + 1;
        }
        else
        {
          v9 = v10 - 1;
        }
        if ( v30 > v9 )
          goto LABEL_13;
      }
    }
    if ( !(a1 & 1) )
      v6 &= 0x7FFFEFFFu;
    v13 = v26;
    v14 = v6;
    if ( __PAIR__(v6, v26) )
    {
      do
      {
        v15 = ((__PAIR__(v13, v14) - 1) >> 32) - 1;
        v14 &= v14 - 1;
        v13 &= v15;
        ++v5;
      }
      while ( v13 | v14 );
    }
    v17 = HIDWORD(v27);
    v16 = v27;
    if ( v27 )
    {
      do
      {
        v24 = ((__PAIR__(v17, v16) - 1) >> 32) - 1;
        v16 &= v16 - 1;
        v17 &= v24;
        ++v5;
      }
      while ( v17 | v16 );
    }
    if ( a4 && a5 )
    {
      v18 = 0;
      while ( v26 | v6 || v27 )
      {
        if ( v6 & 1 )
        {
          v20 = KernelBaseGetGlobalData();
          if ( StringCchCopyNW(a4, a5, (const unsigned __int16 *)(v18 + *(_DWORD *)(v20 + 144)), 4u) < 0 )
            goto LABEL_56;
          a5 -= 4;
          a4 += 4;
          if ( (signed int)a5 > 0 )
          {
            v21 = a4;
            ++a4;
            --a5;
            *v21 = 59;
          }
        }
        v6 = __PAIR__(v26, v6) >> 1;
        v26 >>= 1;
        if ( v27 & 1 )
          v26 |= 0x80000000;
        v27 >>= 1;
        v18 += 8;
      }
      if ( (signed int)a5 >= 1 )
      {
        *a4 = 0;
        goto LABEL_32;
      }
LABEL_56:
      RtlSetLastWin32Error(122);
LABEL_57:
      result = 0;
    }
    else
    {
LABEL_32:
      result = 5 * v5 + 1;
    }
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E40EDF) --------------------------------------------------------
HRESULT __stdcall UnregisterApplicationRecoveryCallback()
{
  return WerpRegisterRecovery(0, 0, 0, 0);
}

//----- (77E40EF0) --------------------------------------------------------
HRESULT __stdcall UnregisterApplicationRestart()
{
  return WerpRegisterRestart(0, 0);
}

//----- (77E40F0D) --------------------------------------------------------
BOOL __stdcall InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
{
  DWORD v3; // eax@1
  BOOL result; // eax@2

  v3 = RtlRunOnceComplete(lpInitOnce, dwFlags, lpContext);
  if ( (v3 & 0x80000000) != 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E40F35) --------------------------------------------------------
BOOL __stdcall InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
{
  DWORD v4; // eax@1
  BOOL result; // eax@2

  v4 = RtlRunOnceBeginInitialize(lpInitOnce, dwFlags, lpContext);
  if ( (v4 & 0x80000000) != 0 )
  {
    BaseSetLastNTError(v4);
    result = 0;
  }
  else
  {
    *fPending = v4 == 259;
    result = 1;
  }
  return result;
}

//----- (77E40F7D) --------------------------------------------------------
signed int __stdcall WerpRegisterRecovery(int a1, int a2, int a3, int a4)
{
  struct _PEB *v4; // edi@2
  PVOID v5; // esi@5
  int v6; // eax@7
  HANDLE v7; // eax@8
  HANDLE v8; // eax@10
  HANDLE v9; // eax@12
  struct _SECURITY_ATTRIBUTES EventAttributes; // [sp+10h] [bp-28h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@5

  v12 = -2147467259;
  EventAttributes.nLength = 0;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.bInheritHandle = 0;
  if ( !WerpCheckOkToRegister() )
  {
    DbgPrintOut(0, "Invalid state");
    return -2147019873;
  }
  v4 = WerpCurrentPeb();
  if ( !v4 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  if ( WerpInitPEBStore() < 0 )
  {
    DbgPrintOut(0, "WerpInitPEBStore failed");
    return -2147467259;
  }
  ms_exc.registration.TryLevel = 0;
  v5 = v4[1].Reserved9[8];
  if ( v5 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v4[1].Reserved9[8]) >= 0 )
  {
    *((_DWORD *)v5 + 522) = 64;
    *((_DWORD *)v5 + 524) = RtlEncodeSystemPointer(a1);
    *((_DWORD *)v5 + 525) = 0;
    v6 = (int)((char *)v5 + 2104);
    *(_DWORD *)v6 = a2;
    *(_DWORD *)(v6 + 4) = 0;
    *(_DWORD *)v6 = a2;
    *(_DWORD *)(v6 + 4) = 0;
    *((_DWORD *)v5 + 536) = a3;
    *((_DWORD *)v5 + 537) = a4;
    EventAttributes.nLength = 12;
    EventAttributes.lpSecurityDescriptor = 0;
    EventAttributes.bInheritHandle = 1;
    if ( (*((_QWORD *)v5 + 264)
       || (v7 = CreateEventW(&EventAttributes, 0, 0, 0), *((_DWORD *)v5 + 528) = v7, *((_DWORD *)v5 + 529) = 0, v7))
      && (*((_QWORD *)v5 + 265)
       || (v8 = CreateEventW(&EventAttributes, 1, 0, 0), *((_DWORD *)v5 + 530) = v8, *((_DWORD *)v5 + 531) = 0, v8))
      && (*((_QWORD *)v5 + 266)
       || (v9 = CreateEventW(&EventAttributes, 1, 0, 0), *((_DWORD *)v5 + 532) = v9, *((_DWORD *)v5 + 533) = 0, v9)) )
      v12 = 0;
    else
      DbgPrintOut(0, "Unable to create the m_hAliveEvent event");
  }
  else
  {
    DbgPrintOut(0, "Invalid PEB entry");
  }
  ms_exc.registration.TryLevel = -2;
  RtlReleasePebLock();
  return v12;
}
// 77DE1140: using guessed type int __stdcall RtlEncodeSystemPointer(_DWORD);

//----- (77E41152) --------------------------------------------------------
HRESULT __stdcall RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
{
  int v4; // eax@1
  HRESULT result; // eax@4

  v4 = dwPingInterval;
  if ( pRecoveyCallback && dwPingInterval <= 0x493E0 )
  {
    if ( !dwPingInterval )
      v4 = 5000;
    result = WerpRegisterRecovery((int)pRecoveyCallback, (int)pvParameter, v4, dwFlags);
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (77E4118E) --------------------------------------------------------
HANDLE __stdcall CreateMutexExWStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateMutexExW(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
}

//----- (77E411C8) --------------------------------------------------------
int __stdcall CompareStringExStub(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
{
  return CompareStringEx(
           lpLocaleName,
           dwCmpFlags,
           lpString1,
           cchCount1,
           lpString2,
           cchCount2,
           lpVersionInformation,
           lpReserved,
           lParam);
}

//----- (77E4122C) --------------------------------------------------------
BOOL __stdcall SetSystemTime(const SYSTEMTIME *lpSystemTime)
{
  CSHORT v1; // cx@1
  char v2; // bl@1
  int v3; // esi@2
  TIME_FIELDS TimeFields; // [sp+8h] [bp-1Ch]@1
  LARGE_INTEGER Time; // [sp+18h] [bp-Ch]@1
  int v7; // [sp+20h] [bp-4h]@2

  TimeFields.Year = lpSystemTime->wYear;
  TimeFields.Month = lpSystemTime->wMonth;
  TimeFields.Day = lpSystemTime->wDay;
  TimeFields.Hour = lpSystemTime->wHour;
  TimeFields.Minute = lpSystemTime->wMinute;
  v1 = lpSystemTime->wSecond;
  TimeFields.Milliseconds = lpSystemTime->wMilliseconds;
  v2 = 1;
  TimeFields.Second = v1;
  if ( !RtlTimeFieldsToTime(&TimeFields, &Time) )
  {
    v3 = -1073741811;
LABEL_5:
    v2 = 0;
    BaseSetLastNTError(v3);
    goto LABEL_4;
  }
  lpSystemTime = (const SYSTEMTIME *)12;
  v3 = RtlAcquirePrivilege(&lpSystemTime, 1, 0, &v7);
  if ( v3 < 0 )
    goto LABEL_5;
  v3 = NtSetSystemTime(&Time, 0);
  RtlReleasePrivilege(v7);
  if ( v3 < 0 )
    goto LABEL_5;
LABEL_4:
  InvalidateTzSpecificCache();
  return (unsigned __int8)v2;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E41346) --------------------------------------------------------
BOOL __stdcall DefineDosDeviceWStub(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
{
  return DefineDosDeviceW(dwFlags, lpDeviceName, lpTargetPath);
}

//----- (77E4135E) --------------------------------------------------------
BOOL __stdcall CreatePipeStub(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
{
  return CreatePipe(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
}

//----- (77E41376) --------------------------------------------------------
BOOL __stdcall CancelIo(HANDLE hFile)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-8h]@1

  v1 = NtCancelIoFile(hFile, &IoStatusBlock);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E41456) --------------------------------------------------------
int __fastcall NlsConvertIntegerToHexStringW(unsigned int a1, int a2, unsigned int a3, unsigned int a4)
{
  int i; // eax@3
  int v5; // esi@4
  int result; // eax@7

  if ( a3 && a4 >= 2 )
  {
    *(_WORD *)(a3 + 2 * a4 - 2) = 0;
    for ( i = a3 + 2 * a4 - 4; i >= a3; a1 >>= 4 )
    {
      v5 = a1 & 0xF;
      if ( v5 >= 10 )
        v5 = v5 + (a2 != 0 ? 65 : 97) - 10;
      else
        LOWORD(v5) = v5 + 48;
      *(_WORD *)i = v5;
      i -= 2;
    }
    result = a1 <= 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E4150F) --------------------------------------------------------
BOOL __stdcall DeleteTimerQueueExStub(HANDLE TimerQueue, HANDLE CompletionEvent)
{
  return DeleteTimerQueueEx(TimerQueue, CompletionEvent);
}

//----- (77E41527) --------------------------------------------------------
DWORD __stdcall SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
{
  DWORD result; // eax@1
  int v7; // eax@6
  signed int v8; // ebx@6
  WCHAR *v9; // eax@6
  void *v10; // esi@6
  DWORD v11; // eax@7
  NTSTATUS v12; // eax@9
  ULONG v13; // ST08_4@11
  LPSTR v14; // ebx@11
  LPSTR *v15; // ebx@12
  int v16; // eax@31
  WCHAR *v17; // eax@31
  DWORD v18; // eax@33
  LSA_UNICODE_STRING v19; // [sp+0h] [bp-28h]@5
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-20h]@1
  LSA_UNICODE_STRING v21; // [sp+10h] [bp-18h]@3
  int v22; // [sp+18h] [bp-10h]@1
  ULONG v23; // [sp+1Ch] [bp-Ch]@14
  LPWSTR *v24; // [sp+20h] [bp-8h]@1
  ULONG MbSize; // [sp+24h] [bp-4h]@9

  v24 = (LPWSTR *)(lpFilePart != 0 ? (unsigned int)&v22 : 0);
  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpFileName);
  if ( !result )
    return result;
  if ( lpExtension )
  {
    if ( !Basep8BitStringToDynamicUnicodeString((int)&v21, lpExtension) )
    {
      RtlFreeUnicodeString(&UnicodeString);
      return 0;
    }
  }
  else
  {
    v21.Buffer = 0;
  }
  if ( !lpPath )
  {
    v19.Buffer = 0;
    goto LABEL_6;
  }
  if ( !Basep8BitStringToDynamicUnicodeString((int)&v19, lpPath) )
  {
    if ( lpExtension )
      RtlFreeUnicodeString(&v21);
    RtlFreeUnicodeString(&UnicodeString);
    return 0;
  }
LABEL_6:
  v7 = KernelBaseGetGlobalData();
  v8 = nBufferLength;
  v9 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  *(_DWORD *)(v7 + 44),
                  2 * nBufferLength);
  v10 = v9;
  if ( !v9 )
  {
    BaseSetLastNTError(-1073741801);
    lpFileName = (LPCSTR)((unsigned int)v10 & (unsigned int)lpFileName);
    goto LABEL_17;
  }
  v11 = SearchPathW(v19.Buffer, UnicodeString.Buffer, v21.Buffer, v8, v9, v24);
  lpFileName = (LPCSTR)v11;
  if ( v11 > v8 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
    v16 = KernelBaseGetGlobalData();
    v17 = (WCHAR *)RtlAllocateHeap(
                     NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                     *(_DWORD *)(v16 + 44),
                     2 * (_DWORD)lpFileName);
    v10 = v17;
    if ( !v17 )
    {
      BaseSetLastNTError(-1073741801);
      goto LABEL_17;
    }
    v18 = SearchPathW(v19.Buffer, UnicodeString.Buffer, v21.Buffer, (DWORD)lpFileName, v17, v24);
    lpFileName = (LPCSTR)v18;
    if ( !v18 )
      goto LABEL_16;
    v12 = RtlUnicodeToMultiByteSize((PULONG)&lpFileName, (PWCHAR)v10, 2 * v18);
    if ( v12 >= 0 )
    {
      ++lpFileName;
      goto LABEL_16;
    }
    goto LABEL_21;
  }
  if ( v11 )
  {
    v12 = RtlUnicodeToMultiByteSize(&MbSize, (PWCHAR)v10, 2 * v11);
    if ( v12 < 0 )
      goto LABEL_21;
    if ( (signed int)MbSize >= v8 )
    {
      lpFileName = (LPCSTR)(MbSize + 1);
      goto LABEL_16;
    }
    v13 = v8 - 1;
    v14 = lpBuffer;
    v12 = RtlUnicodeToMultiByteN(lpBuffer, v13, &MbSize, (PWCHAR)v10, 2 * (_DWORD)lpFileName);
    if ( v12 < 0 )
      goto LABEL_21;
    v14[MbSize] = 0;
    v15 = lpFilePart;
    lpFileName = (LPCSTR)MbSize;
    if ( lpFilePart )
    {
      if ( !v22 )
      {
        *lpFilePart = 0;
        goto LABEL_16;
      }
      v23 = (v22 - (signed int)v10) >> 1;
      v12 = RtlUnicodeToMultiByteSize(&v23, (PWCHAR)v10, 2 * v23);
      if ( v12 >= 0 )
      {
        *v15 = &lpBuffer[v23];
        goto LABEL_16;
      }
LABEL_21:
      BaseSetLastNTError(v12);
      lpFileName = 0;
      goto LABEL_16;
    }
  }
LABEL_16:
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
LABEL_17:
  if ( lpExtension )
    RtlFreeUnicodeString(&v21);
  if ( lpPath )
    RtlFreeUnicodeString(&v19);
  RtlFreeUnicodeString(&UnicodeString);
  return (DWORD)lpFileName;
}

//----- (77E416AA) --------------------------------------------------------
DWORD __stdcall SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
{
  NTSTATUS v2; // eax@1
  DWORD v3; // esi@2

  v2 = NtSetInformationThread(hThread, ThreadIdealProcessor, &dwIdealProcessor, 4u);
  if ( v2 < 0 )
  {
    v3 = -1;
    BaseSetLastNTError(v2);
  }
  else
  {
    v3 = v2;
  }
  return v3;
}

//----- (77E41724) --------------------------------------------------------
BOOL __stdcall BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = RtlSetIoCompletionCallback(FileHandle, Function, Flags);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE10FC: using guessed type int __stdcall RtlSetIoCompletionCallback(_DWORD, _DWORD, _DWORD);

//----- (77E4174C) --------------------------------------------------------
int __stdcall BasepCopyFileCallback(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8)
{
  int *v8; // edi@4
  int result; // eax@1
  int v10; // [sp+0h] [bp-38h]@0
  int v11; // [sp+10h] [bp-28h]@5
  int v12; // [sp+14h] [bp-24h]@5
  int v13; // [sp+18h] [bp-20h]@6
  int v14; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@6
  int v16; // [sp+4Ch] [bp+14h]@6

  result = a1;
  v14 = a1;
  if ( a3 && *(_DWORD *)(a3 + 28) )
  {
    v8 = a4;
    if ( !a4 )
    {
      v8 = &v11;
      v11 = 0;
      v12 = 0;
    }
    v16 = RtlGetCurrentTransaction();
    RtlSetCurrentTransaction(0);
    ms_exc.registration.TryLevel = 0;
    v13 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, int, int, _DWORD, int, int, int, _DWORD, int))(a3 + 28))(
            *(_DWORD *)a3,
            *(_DWORD *)(a3 + 4),
            *(_DWORD *)(a3 + 8),
            *(_DWORD *)(a3 + 12),
            *(_DWORD *)a3,
            *(_DWORD *)(a3 + 4),
            *v8,
            v8[1],
            *(_DWORD *)(a3 + 16),
            a5,
            a6,
            a7,
            *(_DWORD *)(a3 + 24),
            v10);
    ms_exc.registration.TryLevel = -2;
    RtlSetCurrentTransaction(v16);
    if ( a8 )
      *(_DWORD *)a8 = 0;
    if ( !v13 )
      return 1;
    if ( v13 == 1 )
    {
      if ( a8 )
        *(_DWORD *)a8 = 1;
    }
    else if ( v13 != 2 )
    {
      if ( v13 != 3 )
      {
        if ( !a1 )
          RtlSetLastWin32Error(a2);
        return v14;
      }
      *(_DWORD *)(a3 + 28) = 0;
      return 1;
    }
    RtlSetLastWin32Error(a2);
    return 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E417C0) --------------------------------------------------------
BOOL __stdcall ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
{
  signed int v6; // eax@8
  signed int v7; // eax@27
  void *v8; // edi@29
  HANDLE v9; // ebx@30
  DWORD v10; // eax@33
  unsigned int v11; // ebx@33
  PVOID v12; // edi@37
  PVOID v13; // ebx@38
  char v15; // [sp+10h] [bp-358h]@20
  int v16; // [sp+30h] [bp-338h]@27
  char v17; // [sp+38h] [bp-330h]@73
  int v18; // [sp+3Ch] [bp-32Ch]@74
  char FileInformation; // [sp+40h] [bp-328h]@16
  int v20; // [sp+48h] [bp-320h]@21
  int v21; // [sp+4Ch] [bp-31Ch]@21
  int v22; // [sp+50h] [bp-318h]@21
  int v23; // [sp+54h] [bp-314h]@21
  int v24; // [sp+58h] [bp-310h]@21
  int v25; // [sp+5Ch] [bp-30Ch]@21
  int v26; // [sp+60h] [bp-308h]@18
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+68h] [bp-300h]@7
  LSA_UNICODE_STRING v28; // [sp+80h] [bp-2E8h]@9
  ULONG v29; // [sp+88h] [bp-2E0h]@36
  ULONG v30; // [sp+8Ch] [bp-2DCh]@37
  OBJECT_ATTRIBUTES v31; // [sp+90h] [bp-2D8h]@10
  int v32; // [sp+A8h] [bp-2C0h]@23
  ULONG Flags; // [sp+ACh] [bp-2BCh]@30
  int v34; // [sp+B0h] [bp-2B8h]@1
  PVOID v35; // [sp+B4h] [bp-2B4h]@1
  PVOID v36; // [sp+B8h] [bp-2B0h]@1
  int v37; // [sp+BCh] [bp-2ACh]@1
  int v38; // [sp+C0h] [bp-2A8h]@1
  int v39; // [sp+C4h] [bp-2A4h]@1
  PVOID Address; // [sp+C8h] [bp-2A0h]@1
  int v41; // [sp+CCh] [bp-29Ch]@1
  PWSTR v42; // [sp+D0h] [bp-298h]@1
  LPCWSTR lpString; // [sp+D4h] [bp-294h]@1
  PVOID v44; // [sp+D8h] [bp-290h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+DCh] [bp-28Ch]@1
  unsigned int v46; // [sp+E4h] [bp-284h]@30
  LSA_UNICODE_STRING ntname; // [sp+E8h] [bp-280h]@6
  ACCESS_MASK DesiredAccess; // [sp+F0h] [bp-278h]@7
  LPCWSTR lpFileName; // [sp+F4h] [bp-274h]@1
  int v50; // [sp+F8h] [bp-270h]@13
  PWSTR dosname; // [sp+FCh] [bp-26Ch]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+100h] [bp-268h]@7
  HANDLE Handle; // [sp+108h] [bp-260h]@1
  HANDLE FileHandle; // [sp+10Ch] [bp-25Ch]@1
  int v55; // [sp+110h] [bp-258h]@7
  int VolumeInformation; // [sp+114h] [bp-254h]@22
  wchar_t Dst; // [sp+32Ch] [bp-3Ch]@33
  CPPEH_RECORD ms_exc; // [sp+350h] [bp-18h]@6

  lpString = lpReplacedFileName;
  dosname = (PWSTR)lpReplacementFileName;
  v42 = (PWSTR)lpBackupFileName;
  FileHandle = (HANDLE)-1;
  Handle = (HANDLE)-1;
  v34 = 0;
  Address = 0;
  v35 = 0;
  v44 = 0;
  v36 = 0;
  v38 = 0;
  v41 = 0;
  v37 = 0;
  lpFileName = 0;
  v39 = 0;
  RtlInitUnicodeString(&DestinationString, 0);
  if ( !lpReplacedFileName || !dosname || lpExclude || lpReserved || dwReplaceFlags & 0xFFFFFFF8 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    ms_exc.registration.TryLevel = 0;
    RtlInitUnicodeString(&ntname, 0);
    if ( !RtlDosPathNameToNtPathName_U((PWSTR)lpReplacedFileName, &ntname, 0, 0) )
      goto LABEL_45;
    Address = ntname.Buffer;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = &ntname;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    DesiredAccess = -2129592320;
    v55 = NtOpenFile(&FileHandle, 0x81110000, &ObjectAttributes, &IoStatusBlock, 7u, 0x200060u);
    if ( v55 < 0 )
    {
      DesiredAccess = -2146369536;
      v6 = NtOpenFile(&FileHandle, 0x80110000, &ObjectAttributes, &IoStatusBlock, 7u, 0x200060u);
      v55 = v6;
      if ( v6 < 0 )
      {
LABEL_59:
        BaseSetLastNTError(v6);
        goto LABEL_42;
      }
    }
    if ( !RtlDosPathNameToNtPathName_U(dosname, &v28, 0, 0) )
    {
LABEL_45:
      RtlSetLastWin32Error(3);
      goto LABEL_42;
    }
    v35 = v28.Buffer;
    v31.Length = 24;
    v31.RootDirectory = 0;
    v31.Attributes = 64;
    v31.ObjectName = &v28;
    v31.SecurityDescriptor = 0;
    v31.SecurityQualityOfService = 0;
    if ( DesiredAccess & 0x1000000 )
    {
      v50 = -1055588352;
      v55 = NtOpenFile(&Handle, 0xC1150000, &v31, &IoStatusBlock, 0, 0x60u);
    }
    else
    {
      v55 = -1073741790;
    }
    if ( v55 < 0 )
    {
      v50 = -1072365568;
      v55 = NtOpenFile(&Handle, 0xC0150000, &v31, &IoStatusBlock, 0, 0x60u);
    }
    if ( v55 == -1073741790 )
    {
      if ( dwReplaceFlags & 6 )
      {
        v50 = -1072627712;
        v55 = NtOpenFile(&Handle, 0xC0110000, &v31, &IoStatusBlock, 0, 0x60u);
      }
      if ( v55 == -1073741790 )
      {
        if ( dwReplaceFlags & 2 )
        {
          v50 = -2146107392;
          v55 = NtOpenFile(&Handle, 0x80150000, &v31, &IoStatusBlock, 0, 0x60u);
        }
        if ( v55 == -1073741790 && dwReplaceFlags & 2 )
        {
          v50 = -2146369536;
          v55 = NtOpenFile(&Handle, 0x80110000, &v31, &IoStatusBlock, 0, 0x60u);
        }
      }
    }
    if ( v55 < 0 )
    {
      BaseSetLastNTError(v55);
      goto LABEL_42;
    }
    while ( 1 )
    {
      v6 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
      v55 = v6;
      if ( v6 < 0 )
      {
        if ( !(dwReplaceFlags & 2) )
          goto LABEL_59;
        v38 = 1;
        goto LABEL_22;
      }
      if ( v37 || !(v26 & 0x400) )
        break;
      v37 = 1;
      v6 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &v17, 8u, FileAttributeTagInformation);
      v55 = v6;
      if ( v6 < 0 )
        goto LABEL_59;
      if ( v18 & 0x20000000 )
      {
        if ( v6 < 0 )
          goto LABEL_59;
        RtlSetLastWin32Error(1464);
        goto LABEL_42;
      }
      NtClose(FileHandle);
      FileHandle = (HANDLE)-1;
      v6 = NtOpenFile(&FileHandle, DesiredAccess, &ObjectAttributes, &IoStatusBlock, 7u, 0x60u);
      v55 = v6;
      if ( v6 < 0 )
        goto LABEL_59;
    }
    if ( v26 & 1 )
    {
      v6 = -1073741790;
      v55 = -1073741790;
      goto LABEL_59;
    }
    v6 = NtQueryInformationFile(Handle, &IoStatusBlock, &v15, 0x28u, FileBasicInformation);
    v55 = v6;
    if ( v6 < 0 )
    {
      if ( !(dwReplaceFlags & 2) )
        goto LABEL_59;
      v41 = 1;
    }
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v6 = NtSetInformationFile(Handle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    v55 = v6;
    if ( v6 < 0 && !(dwReplaceFlags & 2) )
      goto LABEL_59;
LABEL_22:
    v6 = NtQueryVolumeInformationFile(Handle, &IoStatusBlock, &VolumeInformation, 0x218u, FileFsAttributeInformation);
    v55 = v6;
    if ( v6 < 0 )
    {
      if ( !(dwReplaceFlags & 2) )
        goto LABEL_59;
    }
    else
    {
      v32 = 0;
      if ( !BasepCopySecurityInformation(
              (int)lpString,
              (int)FileHandle,
              DesiredAccess,
              (int)dosname,
              (int)Handle,
              v50,
              0xCu,
              0,
              VolumeInformation,
              (int)&v32,
              1) )
        goto LABEL_42;
    }
    if ( BasepCopyAlternateDataStreams(FileHandle, Handle, (dwReplaceFlags >> 1) & 1) )
    {
      if ( v38
        || (v41 ? (v7 = -1) : (v7 = v16),
            BasepSetFileEncryptionCompression(
              (int)FileHandle,
              &Handle,
              (int)&v31,
              (int)dosname,
              v26,
              v7,
              (dwReplaceFlags >> 1) & 1)) )
      {
        v8 = v42;
        if ( v42 )
        {
          lpFileName = v42;
        }
        else
        {
          v9 = (HANDLE)-1;
          v46 = 0;
          dosname = (PWSTR)(2 * lstrlenW(lpString) + 32);
          Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
          v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, (ULONG)dosname);
          lpFileName = (LPCWSTR)v8;
          if ( !v8 )
            goto LABEL_87;
          while ( v9 == (HANDLE)-1 )
          {
            if ( v46 >= 0x10 )
              goto LABEL_87;
            v10 = GetTickCount();
            swprintf_s(&Dst, 0x10u, L"~RF%4x.TMP", v46 + v10);
            v11 = (unsigned int)dosname >> 1;
            wcscpy_s((wchar_t *)v8, (unsigned int)dosname >> 1, lpString);
            wcscat_s((wchar_t *)v8, v11, &Dst);
            v9 = CreateFileW((LPCWSTR)v8, 0x40010000u, 0, 0, 1u, 0x102u, 0);
            ++v46;
          }
          CloseHandle(v9);
        }
        if ( !RtlDosPathNameToNtPathName_U((PWSTR)v8, &DestinationString, 0, 0) )
          goto LABEL_45;
        v29 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        v44 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v29, DestinationString.Length + 16);
        if ( v44 )
        {
          v30 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
          v12 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v30, ntname.Length + 16);
          v36 = v12;
          if ( !v12 )
          {
            RtlSetLastWin32Error(1176);
            goto LABEL_42;
          }
          v13 = v44;
          *(_BYTE *)v44 = 1;
          *((_DWORD *)v13 + 1) = 0;
          *((_DWORD *)v13 + 2) = DestinationString.Length;
          memcpy((char *)v13 + 12, DestinationString.Buffer, DestinationString.Length);
          v55 = NtSetInformationFile(
                  FileHandle,
                  &IoStatusBlock,
                  v13,
                  DestinationString.Length + 16,
                  FileRenameInformation);
          if ( v55 >= 0 )
          {
            *(_BYTE *)v12 = 1;
            *((_DWORD *)v12 + 1) = 0;
            *((_DWORD *)v12 + 2) = ntname.Length;
            memcpy((char *)v12 + 12, ntname.Buffer, ntname.Length);
            v55 = NtSetInformationFile(Handle, &IoStatusBlock, v12, ntname.Length + 16, FileRenameInformation);
            if ( v55 < 0 )
            {
              v55 = NtSetInformationFile(FileHandle, &IoStatusBlock, v12, ntname.Length + 16, FileRenameInformation);
              if ( v55 >= 0 )
                RtlSetLastWin32Error(1176);
              else
                RtlSetLastWin32Error(1177);
              v39 = 1;
            }
            else
            {
              if ( dwReplaceFlags & 1 )
                NtFlushBuffersFile(FileHandle, &IoStatusBlock);
              v34 = 1;
            }
            goto LABEL_42;
          }
        }
LABEL_87:
        RtlSetLastWin32Error(1175);
        goto LABEL_42;
      }
    }
LABEL_42:
    ms_exc.registration.TryLevel = -2;
    if ( FileHandle != (HANDLE)-1 )
      NtClose(FileHandle);
    if ( Handle != (HANDLE)-1 )
      NtClose(Handle);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v35);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v36);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v44);
    if ( lpFileName && lpFileName != v42 && !v39 )
    {
      DeleteFileW(lpFileName);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpFileName);
    }
  }
  return v34;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E41F54) --------------------------------------------------------
int __stdcall BasepSetFileEncryptionCompression(int a1, PHANDLE FileHandle, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // ecx@2
  int v8; // eax@3
  HMODULE v10; // eax@18
  FARPROC v11; // eax@19
  int v12; // eax@23
  HMODULE v13; // eax@31
  FARPROC v14; // eax@32
  int v15; // eax@37
  void *v16; // eax@41
  signed int v17; // [sp+14h] [bp-58h]@1
  HANDLE v18; // [sp+18h] [bp-54h]@1
  int v19; // [sp+1Ch] [bp-50h]@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+20h] [bp-4Ch]@23
  int v21; // [sp+28h] [bp-44h]@3
  int v22; // [sp+2Ch] [bp-40h]@3
  HMODULE hLibModule; // [sp+30h] [bp-3Ch]@1
  int v24; // [sp+34h] [bp-38h]@1
  POBJECT_ATTRIBUTES ObjectAttributes; // [sp+38h] [bp-34h]@1
  int v26; // [sp+3Ch] [bp-30h]@23
  char FileInformation; // [sp+40h] [bp-2Ch]@37
  char InputBuffer; // [sp+48h] [bp-24h]@41
  CPPEH_RECORD ms_exc; // [sp+54h] [bp-18h]@2

  v18 = (HANDLE)a1;
  ObjectAttributes = (POBJECT_ATTRIBUTES)a3;
  hLibModule = (HMODULE)-1;
  v17 = 0;
  v24 = 0;
  if ( a6 == -1 )
    v24 = 1;
  ms_exc.registration.TryLevel = 0;
  v7 = a5 & 0x4000;
  v19 = a5 & 0x800;
  if ( v24 )
  {
    v21 = v7 == 0;
    v22 = v19 == 0;
    v8 = v7 == 0;
  }
  else
  {
    v8 = a6 & 0x4000;
    v21 = a6 & 0x4000;
    v22 = a6 & 0x800;
  }
  if ( !v7 )
    goto LABEL_5;
  if ( v8 )
  {
    if ( v7 )
      goto LABEL_6;
LABEL_5:
    if ( !v8 )
      goto LABEL_6;
    NtClose(*FileHandle);
    *FileHandle = (HANDLE)-1;
    v13 = LoadLibraryW(L"advapi32.dll");
    hLibModule = v13;
    if ( v13 )
    {
      v14 = GetProcAddress(v13, "DecryptFileW");
      if ( v14 )
      {
        if ( ((int (__stdcall *)(int, _DWORD))v14)(a4, 0) )
        {
          v21 = 0;
          goto LABEL_23;
        }
      }
    }
LABEL_22:
    if ( !(a7 & 1) )
      goto LABEL_9;
    goto LABEL_23;
  }
  NtClose(*FileHandle);
  *FileHandle = (HANDLE)-1;
  v10 = LoadLibraryW(L"advapi32.dll");
  hLibModule = v10;
  if ( !v10 )
    goto LABEL_22;
  v11 = GetProcAddress(v10, "EncryptFileW");
  if ( !v11 || !((int (__stdcall *)(int))v11)(a4) )
    goto LABEL_22;
  v22 = 0;
LABEL_23:
  v12 = NtOpenFile(FileHandle, 0xC0150000, ObjectAttributes, &IoStatusBlock, 0, 0x60u);
  v26 = v12;
  if ( v12 == -1073741790 )
  {
    if ( a7 & 1 )
    {
      v12 = NtOpenFile(FileHandle, 0x80150000, ObjectAttributes, &IoStatusBlock, 0, 0x60u);
      v26 = v12;
    }
    if ( v12 == -1073741790 && a7 & 1 )
    {
      v12 = NtOpenFile(FileHandle, 0x80110000, ObjectAttributes, &IoStatusBlock, 0, 0x60u);
      v26 = v12;
    }
  }
  if ( v12 < 0 )
  {
    BaseSetLastNTError(v12);
    goto LABEL_9;
  }
  v8 = v21;
LABEL_6:
  if ( !v19 )
  {
LABEL_7:
    if ( !v22 || v8 )
      goto LABEL_8;
    v18 = 0;
    v16 = &v18;
    goto LABEL_42;
  }
  if ( v22 )
  {
    if ( v19 )
      goto LABEL_8;
    goto LABEL_7;
  }
  v15 = NtQueryInformationFile(v18, &IoStatusBlock, &FileInformation, 0x10u, FileCompressionInformation);
  v26 = v15;
  if ( v15 < 0 )
  {
    if ( !v24 )
      goto LABEL_39;
    goto LABEL_8;
  }
  v16 = &InputBuffer;
LABEL_42:
  v15 = NtFsControlFile(*FileHandle, 0, 0, 0, &IoStatusBlock, 0x9C040u, v16, 2u, 0, 0);
  v26 = v15;
  if ( !v24 && v15 < 0 )
  {
LABEL_39:
    if ( !(a7 & 1) )
    {
      BaseSetLastNTError(v15);
      goto LABEL_9;
    }
  }
LABEL_8:
  v17 = 1;
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( hLibModule != (HMODULE)-1 && hLibModule )
    FreeLibrary(hLibModule);
  return v17;
}

//----- (77E42021) --------------------------------------------------------
int __stdcall BasepCopyAlternateDataStreams(HANDLE FileHandle, HANDLE a2, char a3)
{
  PVOID v3; // eax@2
  int v4; // esi@2
  signed int v5; // eax@3
  ULONG v7; // esi@24
  PVOID v8; // eax@24
  PVOID v9; // edi@33
  signed int v10; // ebx@33
  unsigned int v11; // eax@34
  __int16 v12; // ax@39
  bool v13; // zf@41
  unsigned int v14; // eax@44
  __int16 v15; // di@44
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-7Ch]@39
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-64h]@3
  unsigned __int16 v18; // [sp+30h] [bp-5Ch]@39
  __int16 v19; // [sp+32h] [bp-5Ah]@39
  int v20; // [sp+34h] [bp-58h]@39
  PVOID v21; // [sp+38h] [bp-54h]@34
  int v22; // [sp+3Ch] [bp-50h]@1
  int v23; // [sp+40h] [bp-4Ch]@1
  int v24; // [sp+44h] [bp-48h]@1
  int v25; // [sp+48h] [bp-44h]@1
  ULONG v26; // [sp+4Ch] [bp-40h]@24
  ULONG Flags; // [sp+50h] [bp-3Ch]@2
  int v28; // [sp+54h] [bp-38h]@1
  int v29; // [sp+58h] [bp-34h]@3
  PVOID Address; // [sp+5Ch] [bp-30h]@1
  int v31; // [sp+60h] [bp-2Ch]@8
  HANDLE Handle; // [sp+64h] [bp-28h]@1
  PVOID v33; // [sp+68h] [bp-24h]@1
  HANDLE v34; // [sp+6Ch] [bp-20h]@1
  ULONG Size; // [sp+70h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+74h] [bp-18h]@1

  Handle = (HANDLE)-1;
  v34 = (HANDLE)-1;
  v28 = 0;
  Address = 0;
  v33 = 0;
  v22 = 1;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  ms_exc.registration.TryLevel = 0;
  Size = 4096;
  while ( 1 )
  {
    Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, Size);
    v4 = (int)v3;
    Address = v3;
    if ( !v3 )
      break;
    v5 = NtQueryInformationFile(FileHandle, &IoStatusBlock, v3, Size, FileStreamInformation);
    v29 = v5;
    if ( v5 < 0 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      v4 = 0;
      Address = 0;
      Size *= 2;
      v5 = v29;
    }
    if ( v5 != -2147483643 && v5 != -1073741789 )
      goto LABEL_6;
  }
  v5 = -1073741801;
LABEL_6:
  if ( v4 )
  {
    if ( v5 >= 0 )
    {
      while ( 1 )
      {
        v31 = v4;
        if ( *(_DWORD *)(v4 + 4) <= 2u || *(_WORD *)(v4 + 26) == 58 )
        {
          if ( !*(_DWORD *)v4 )
            goto LABEL_11;
          goto LABEL_15;
        }
        if ( !v33 )
        {
          Size = 4096;
          while ( 1 )
          {
            v26 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
            v7 = Size;
            v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v26, Size);
            v33 = v8;
            if ( !v8 )
              break;
            v5 = NtQueryInformationFile(a2, &IoStatusBlock, v8, v7 - 2, FileStreamInformation);
            v29 = v5;
            if ( v5 < 0 )
            {
              RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v33);
              v33 = 0;
              Size *= 2;
              v5 = v29;
            }
            if ( v5 != -2147483643 && v5 != -1073741789 )
              goto LABEL_30;
          }
          v5 = -1073741801;
LABEL_30:
          if ( !v33 || v5 < 0 )
            goto LABEL_20;
          v4 = v31;
        }
        v9 = v33;
        v10 = 1;
        while ( 1 )
        {
          v21 = v9;
          v11 = *((_DWORD *)v9 + 1);
          if ( *(_DWORD *)(v4 + 4) == v11 && !__wcsnicmp((const wchar_t *)(v4 + 24), (const wchar_t *)v9 + 12, v11 >> 1) )
            break;
          if ( !*(_DWORD *)v9 )
            goto LABEL_38;
          v9 = (char *)v9 + *(_DWORD *)v9;
        }
        v10 = 0;
LABEL_38:
        if ( v10 != 1 )
          goto LABEL_48;
        v20 = v4 + 24;
        v12 = *(_WORD *)(v4 + 4);
        v18 = v12;
        v19 = v12;
        ObjectAttributes.Length = 24;
        ObjectAttributes.RootDirectory = FileHandle;
        ObjectAttributes.Attributes = 0;
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&v18;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        v5 = NtOpenFile(&Handle, 0x80100000, &ObjectAttributes, &IoStatusBlock, 7u, 0x24u);
        if ( v5 >= 0 )
          break;
        if ( !(a3 & 1) )
          goto LABEL_21;
        v13 = *(_DWORD *)v4 == 0;
LABEL_42:
        if ( v13 )
          goto LABEL_11;
LABEL_15:
        v4 += *(_DWORD *)v4;
      }
      v14 = v20 + 2 * ((unsigned int)v18 >> 1);
      v15 = *(_WORD *)v14;
      *(_WORD *)v14 = 0;
      v34 = (HANDLE)-1;
      if ( !BaseCopyStream(0, Handle, -2146435072, v20, a2, v4 + 8, &v22, &v34, &v23, &v24, 0, 0, 0, &v25) )
      {
        *(_WORD *)(v20 + 2 * ((unsigned int)v18 >> 1)) = v15;
        if ( !(a3 & 1) )
          goto LABEL_12;
      }
      *(_WORD *)(v20 + 2 * ((unsigned int)v18 >> 1)) = v15;
      NtClose(Handle);
      Handle = (HANDLE)-1;
      if ( v34 != (HANDLE)-1 )
      {
        NtClose(v34);
        v34 = (HANDLE)-1;
      }
LABEL_48:
      v13 = *(_DWORD *)v4 == 0;
      goto LABEL_42;
    }
  }
  else if ( v5 == -1073741811 || v5 == -1073741822 )
  {
    goto LABEL_11;
  }
LABEL_20:
  if ( a3 & 1 )
  {
LABEL_11:
    v28 = 1;
    goto LABEL_12;
  }
LABEL_21:
  BaseSetLastNTError(v5);
LABEL_12:
  ms_exc.registration.TryLevel = -2;
  if ( Handle != (HANDLE)-1 )
    NtClose(Handle);
  if ( v34 != (HANDLE)-1 )
    NtClose(v34);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v33);
  return v28;
}
// 77E1A625: using guessed type _DWORD __stdcall BaseCopyStream(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E42176) --------------------------------------------------------
int __stdcall BasepCopySecurityInformation(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8, char a9, int a10, int a11)
{
  HMODULE v11; // eax@14
  HMODULE v12; // esi@14
  FARPROC v13; // edi@15
  FARPROC v14; // eax@15
  int v15; // esi@18
  int v16; // eax@32
  int v18; // [sp+4h] [bp-30h]@1
  int v19; // [sp+8h] [bp-2Ch]@1
  int v20; // [sp+Ch] [bp-28h]@1
  HMODULE hLibModule; // [sp+10h] [bp-24h]@1
  HLOCAL v22; // [sp+14h] [bp-20h]@1
  PSID Sid1; // [sp+18h] [bp-1Ch]@1
  int v24; // [sp+1Ch] [bp-18h]@1
  int v25; // [sp+20h] [bp-14h]@1
  PSID v26; // [sp+24h] [bp-10h]@1
  HLOCAL hMem; // [sp+28h] [bp-Ch]@1
  PACL Acl; // [sp+2Ch] [bp-8h]@1
  unsigned __int8 v29; // [sp+33h] [bp-1h]@1
  FARPROC v30; // [sp+44h] [bp+10h]@15
  FARPROC v31; // [sp+50h] [bp+1Ch]@15

  v29 = 0;
  Acl = 0;
  v24 = 0;
  Sid1 = 0;
  v19 = 0;
  v26 = 0;
  hMem = 0;
  v22 = 0;
  hLibModule = 0;
  v25 = 0;
  v18 = 0;
  v20 = 0;
  if ( !a1 || !a4 )
  {
    v29 = 1;
    goto LABEL_34;
  }
  if ( !(a9 & 8) )
  {
    if ( !BasepCopyFileCallback(1, 50, a8, 0, 16, a2, a5, a10) )
      goto LABEL_34;
    goto LABEL_57;
  }
  if ( a7 & 4 && (!(a3 & 0x80000000) || !(a6 & 0x40000)) )
  {
    a7 &= 0xFFFFFFFB;
    if ( !BasepCopyFileCallback(1, 5, a8, 0, 13, a2, a5, a10) )
      goto LABEL_34;
  }
  if ( a7 & 3 && (!(a3 & 0x80000000) || !(a6 & 0x80000)) )
  {
    a7 &= 0xFFFFFFFC;
    if ( !BasepCopyFileCallback(1, 5, a8, 0, 14, a2, a5, a10) )
      goto LABEL_34;
  }
  if ( a7 & 8 && (!(a3 & 0x1000000) || !(a6 & 0x1000000)) )
  {
    a7 &= 0xFFFFFFF7;
    if ( !BasepCopyFileCallback(1, 1314, a8, 0, 15, a2, a5, a10) )
      goto LABEL_34;
  }
  if ( !a7 )
  {
LABEL_57:
    v29 = 1;
    goto LABEL_34;
  }
  if ( a11 )
    v20 = 1;
  v11 = LoadLibraryW(L"advapi32.dll");
  v12 = v11;
  hLibModule = v11;
  if ( v11 )
  {
    v13 = GetProcAddress(v11, "GetSecurityInfo");
    v30 = GetProcAddress(v12, "SetSecurityInfo");
    v14 = GetProcAddress(v12, "GetSecurityDescriptorControl");
    v31 = v14;
    if ( v13 && v14 && v30 )
    {
      v15 = ((int (__stdcall *)(int, signed int, unsigned int, PSID *, int *, PACL *, int *, HLOCAL *))v13)(
              a2,
              1,
              a7 | v20,
              &Sid1,
              &v19,
              &Acl,
              &v24,
              &hMem);
      if ( v15 )
      {
        if ( RtlGetLastNtStatus() == -1073741637 && BasepCopyFileCallback(1, 50, a8, 0, 16, a2, a5, a10) )
        {
LABEL_33:
          v29 = 1;
          goto LABEL_34;
        }
        RtlSetLastWin32Error(v15);
      }
      else
      {
        if ( !Acl )
          a7 &= 0xFFFFFFFB;
        if ( !v24 )
          a7 &= 0xFFFFFFF7;
        if ( !(a7 & 0xC) || ((int (__stdcall *)(HLOCAL, int *, int *))v31)(hMem, &v25, &v18) )
        {
          if ( a7 & 4 )
          {
            a7 |= v25 & 0x1000 ? 0x80000000 : 0x20000000u;
            if ( a11 )
            {
              if ( ((int (__stdcall *)(int, signed int, signed int, PSID *, _DWORD, _DWORD, _DWORD, HLOCAL *))v13)(
                     a5,
                     1,
                     1,
                     &v26,
                     0,
                     0,
                     0,
                     &v22) )
                v26 = 0;
              BasepCopyCreatorOwnerACE(Acl, Sid1, v26);
            }
          }
          if ( a7 & 8 )
          {
            if ( v25 & 0x2000 )
              a7 |= 0x40000000u;
            else
              a7 |= 0x10000000u;
          }
          if ( a7 )
          {
            while ( 1 )
            {
              v16 = ((int (__stdcall *)(int, signed int, unsigned int, PSID, int, PACL, int))v30)(
                      a5,
                      1,
                      a7,
                      Sid1,
                      v19,
                      Acl,
                      v24);
              if ( !v16 )
                break;
              if ( a7 & 3 )
              {
                if ( !BasepCopyFileCallback(1, v16, a8, 0, 19, a2, a5, a10) )
                  goto LABEL_34;
                a7 &= 0xFFFFFFFC;
              }
              else
              {
                if ( !BasepCopyFileCallback(1, v16, a8, 0, 16, a2, a5, a10) )
                  goto LABEL_34;
                a7 = 0;
              }
              if ( !a7 )
                goto LABEL_33;
            }
          }
          goto LABEL_33;
        }
      }
    }
    else
    {
      RtlSetLastWin32Error(1154);
    }
    *(_DWORD *)a10 = 1;
  }
  else
  {
    *(_DWORD *)a10 = 1;
  }
LABEL_34:
  if ( hMem )
    LocalFree(hMem);
  if ( v22 )
    LocalFree(v22);
  if ( hLibModule )
    FreeLibrary(hLibModule);
  return v29;
}
// 77DE13CC: using guessed type _DWORD __stdcall RtlGetLastNtStatus();
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E423DF) --------------------------------------------------------
NTSTATUS __stdcall BasepCopyCreatorOwnerACE(PACL Acl, PSID Sid1, PSID a3)
{
  ULONG v3; // eax@9
  NTSTATUS v4; // esi@5
  unsigned int AclInformation; // [sp+Ch] [bp-10h]@7
  PVOID Ace; // [sp+18h] [bp-4h]@1
  PSID v8; // [sp+2Ch] [bp+10h]@8

  Ace = 0;
  if ( Sid1 && Acl )
  {
    if ( a3 && RtlEqualSid(a3, Sid1) )
    {
      v4 = 0;
    }
    else
    {
      v4 = RtlQueryInformationAcl(Acl, &AclInformation, 0xCu, AclSizeInformation);
      if ( v4 >= 0 )
      {
        v8 = 0;
        if ( AclInformation > 0 )
        {
          v3 = 0;
          do
          {
            v4 = RtlGetAce(Acl, v3, &Ace);
            if ( v4 < 0 )
              break;
            if ( !*(_BYTE *)Ace && RtlEqualSid(Sid1, (char *)Ace + 8) && *((_DWORD *)Ace + 1) == 2032127 )
            {
              if ( *((_BYTE *)Ace + 1) & 0x10 )
                *((_BYTE *)Ace + 1) &= 0xEFu;
              return v4;
            }
            v8 = (char *)v8 + 1;
            v3 = (unsigned __int16)v8;
          }
          while ( (unsigned __int16)v8 < AclInformation );
        }
      }
    }
  }
  else
  {
    v4 = -1073741811;
  }
  return v4;
}

//----- (77E42461) --------------------------------------------------------
int __stdcall BaseDllReadVariableNames(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@3
  int result; // eax@6
  NTSTATUS i; // eax@8
  ULONG ResultLength; // [sp+Ch] [bp-228h]@8
  __int16 v7; // [sp+10h] [bp-224h]@11
  __int16 v8; // [sp+12h] [bp-222h]@11
  char *v9; // [sp+14h] [bp-220h]@11
  int v10; // [sp+18h] [bp-21Ch]@18
  int v11; // [sp+1Ch] [bp-218h]@20
  int v12; // [sp+20h] [bp-214h]@1
  HANDLE KeyHandle; // [sp+24h] [bp-210h]@6
  ULONG Index; // [sp+28h] [bp-20Ch]@1
  PCUNICODE_STRING v15; // [sp+2Ch] [bp-208h]@5
  char KeyValueInformation; // [sp+30h] [bp-204h]@8
  __int16 v17; // [sp+38h] [bp-1FCh]@11
  char v18; // [sp+3Ch] [bp-1F8h]@11

  v12 = a1;
  v2 = *(_DWORD *)(a2 + 12);
  Index = (ULONG)NtCurrentTeb()->ProcessEnvironmentBlock;
  while ( v2 )
  {
    if ( *(_BYTE *)(Index + 3) & 2 )
    {
      result = BaseVerifyFileName(v2, (int)&v10);
      if ( result < 0 )
        return result;
    }
    else
    {
      v10 = *(_DWORD *)(v2 + 4);
      v11 = *(_DWORD *)(v2 + 8);
    }
    result = BaseDllAppendStringToResultBuffer(v12, 0, (int)&v10, 1);
    if ( result < 0 )
      return result;
    v2 = *(_DWORD *)v2;
  }
  v3 = *(_DWORD *)(a2 + 16);
  if ( v3 )
  {
    if ( !(*(_BYTE *)(Index + 3) & 2) || (result = BaseVerifyFileName(v3, 0), result >= 0) )
    {
      if ( BaseDllGetApplicationName(v12, 0, (int)&v15) )
      {
        result = BaseDllOpenMappingTarget(v12, v3, v15, 0, &KeyHandle);
        if ( result >= 0 && KeyHandle != (HANDLE)-1 )
        {
          Index = 0;
          for ( i = NtEnumerateValueKey(KeyHandle, 0, 0, &KeyValueInformation, 0x200u, &ResultLength);
                ;
                i = NtEnumerateValueKey(KeyHandle, Index, 0, &KeyValueInformation, 0x200u, &ResultLength) )
          {
            v15 = (PCUNICODE_STRING)i;
            if ( i == -2147483622 )
            {
              NtClose(KeyHandle);
              return 0;
            }
            if ( (signed int)v15 < 0 )
              break;
            v9 = &v18;
            v7 = v17;
            v8 = v17;
            v15 = (PCUNICODE_STRING)BaseDllAppendStringToResultBuffer(v12, 0, (int)&v7, 1);
            if ( (signed int)v15 < 0 )
              break;
            ++Index;
          }
          NtClose(KeyHandle);
          result = (int)v15;
        }
      }
      else
      {
        result = -1073741811;
      }
    }
  }
  else
  {
    result = -1073741802;
  }
  return result;
}

//----- (77E4260D) --------------------------------------------------------
BOOL __stdcall SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
{
  ULONG v2; // eax@2
  BOOL result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v6; // [sp+28h] [bp-7Ch]@1
  WORD v7; // [sp+2Ch] [bp-78h]@1

  v6 = hConsoleOutput;
  v7 = wAttributes;
  ConsoleClientCallServer(&RequestMessage, 0, 26, 8);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E42678) --------------------------------------------------------
BOOL __stdcall FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
{
  return FillConsoleOutput(
           (int)hConsoleOutput,
           wAttribute,
           nLength,
           3,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfAttrsWritten);
}

//----- (77E4269C) --------------------------------------------------------
signed int __stdcall FillConsoleOutput(int a1, __int16 a2, int a3, int a4, int a5, int a6)
{
  bool v6; // sf@1
  signed int result; // eax@2
  ULONG v8; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  int v11; // [sp+2Ch] [bp-7Ch]@1
  int v12; // [sp+30h] [bp-78h]@1
  int v13; // [sp+34h] [bp-74h]@1
  __int16 v14; // [sp+38h] [bp-70h]@1
  int v15; // [sp+3Ch] [bp-6Ch]@1

  v11 = a1;
  v15 = a3;
  v13 = a4;
  v14 = a2;
  v12 = a5;
  ConsoleClientCallServer(&RequestMessage, 0, 7, 20);
  v6 = NtStatus < 0;
  *(_DWORD *)a6 = v15;
  if ( v6 )
  {
    v8 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v8);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E42710) --------------------------------------------------------
__int16 __stdcall GetCurrentExeName(void *Dst, int a2)
{
  __int16 result; // ax@4

  if ( ExeNameInitialized )
  {
    RtlEnterCriticalSection(&ExeNameCriticalSection);
    if ( a2 > (unsigned int)(unsigned __int16)ExeNameLength )
      LOWORD(a2) = ExeNameLength;
    memcpy(Dst, ExeNameBuffer, 2 * (unsigned __int16)a2);
    RtlLeaveCriticalSection(&ExeNameCriticalSection);
    result = a2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77EA6000: using guessed type __int16 ExeNameLength;
// 77EA6004: using guessed type char ExeNameInitialized;
// 77EA60A0: using guessed type __int16 ExeNameBuffer[];

//----- (77E42776) --------------------------------------------------------
BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
{
  __int16 v5; // ax@1
  NTSTATUS v6; // eax@1
  NTSTATUS v7; // esi@1
  ULONG v8; // eax@2
  BOOL result; // eax@3
  char Dst; // [sp+10h] [bp-54h]@1

  v5 = GetCurrentExeName(&Dst, 40);
  v6 = ReadConsoleInternal(
         (int)hConsoleInput,
         (int)lpBuffer,
         nNumberOfCharsToRead,
         (int)lpNumberOfCharsRead,
         (int)pInputControl,
         1,
         (unsigned __int16)v5,
         &Dst);
  v7 = v6;
  result = 1;
  if ( v6 < 0 )
  {
    v8 = RtlNtStatusToDosError(v6);
    RtlSetLastWin32Error(v8);
    if ( v7 != -1073741536 )
      result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E427C7) --------------------------------------------------------
int __stdcall ReadConsoleInternal(int a1, int a2, int a3, int a4, int a5, char a6, int a7, void *Src)
{
  signed __int16 v8; // ax@1
  int v9; // eax@3
  int v10; // esi@8
  size_t v11; // eax@10
  int result; // eax@16
  unsigned int v13; // eax@25
  signed int v14; // [sp+20h] [bp-C4h]@5
  PVOID Address; // [sp+24h] [bp-C0h]@3
  struct _PORT_MESSAGE RequestMessage; // [sp+28h] [bp-BCh]@13
  int v17; // [sp+48h] [bp-9Ch]@24
  int v18; // [sp+50h] [bp-94h]@1
  __int16 v19; // [sp+54h] [bp-90h]@2
  char Dst; // [sp+56h] [bp-8Eh]@2
  void *v21; // [sp+A8h] [bp-3Ch]@4
  size_t Size; // [sp+ACh] [bp-38h]@2
  size_t v23; // [sp+B0h] [bp-34h]@2
  int v24; // [sp+B4h] [bp-30h]@5
  int v25; // [sp+B8h] [bp-2Ch]@5
  int v26; // [sp+BCh] [bp-28h]@5
  char v27; // [sp+C0h] [bp-24h]@1
  CPPEH_RECORD ms_exc; // [sp+CCh] [bp-18h]@5

  v18 = a1;
  v27 = a6;
  v8 = a7;
  if ( (unsigned __int16)a7 > 0x28u )
    v8 = 40;
  v19 = v8;
  memcpy(&Dst, Src, 2 * (unsigned __int16)v8);
  Size = 2 * a3;
  v23 = 2 * a3;
  if ( (unsigned int)(2 * a3) <= 0x50 )
  {
    v21 = &Dst;
    Address = 0;
  }
  else
  {
    v9 = (int)ConsoleAllocateCaptureBuffer(1u, 2 * a3);
    Address = (PVOID)v9;
    if ( !v9 )
      return -1073741801;
    ConsoleCaptureMessageBuffer(v9, 0, v23, (int)&v21);
  }
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v14 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( a6 && a5 && NtCurrentTeb()->ProcessEnvironmentBlock->Reserved9[32] >= (PVOID)4 && (v10 = a5, *(_DWORD *)a5 == 16) )
  {
    if ( *(_DWORD *)(a5 + 4) > (unsigned int)a3 )
    {
      v14 = -1073741811;
    }
    else
    {
      v11 = 2 * *(_DWORD *)(a5 + 4);
      v24 = 2 * *(_DWORD *)(a5 + 4);
      if ( *(_DWORD *)(a5 + 4) )
        memcpy(v21, (const void *)a2, v11);
      v25 = *(_DWORD *)(a5 + 8);
    }
  }
  else
  {
    v10 = 0;
  }
  ms_exc.registration.TryLevel = -2;
  if ( v14 < 0 && v10 )
  {
    if ( Address )
      ConsoleFreeCaptureBuffer(Address);
    result = v14;
  }
  else
  {
    ConsoleClientCallServer(&RequestMessage, (int)Address, 29, 116);
    if ( v17 >= 0 )
    {
      v13 = Size;
      *(_DWORD *)a4 = Size;
      if ( a6 )
      {
        *(_DWORD *)a4 = v13 >> 1;
        if ( v10 )
          *(_DWORD *)(v10 + 12) = v26;
      }
      memcpy((void *)a2, v21, Size);
    }
    if ( Address )
      ConsoleFreeCaptureBuffer(Address);
    result = v17;
    if ( v17 == 257 )
    {
      NtYieldExecution();
      result = -1073741536;
    }
  }
  return result;
}

//----- (77E42A0F) --------------------------------------------------------
int __stdcall BasepProcessInvalidImage(int a1, HANDLE TokenHandle, LPCWSTR lpFileName, int a4, NTSTATUS NtStatus, int a6, int a7, int a8, int a9, int a10, int a11, ULONG MessageBoxResult, int a13, int a14, PUNICODE_STRING UnicodeString, PANSI_STRING DestinationString, PCUNICODE_STRING SourceString, int a18, PVOID Address, int a20, int a21)
{
  int v22; // eax@13
  int v23; // eax@17
  WCHAR *v24; // eax@17
  DWORD v25; // eax@17
  DWORD v26; // esi@17
  size_t v27; // esi@19
  int v28; // eax@19
  wchar_t *v29; // eax@19
  NTSTATUS v30; // ebx@21
  DWORD v31; // eax@38
  NTSTATUS v32; // ebx@40
  int v33; // eax@45
  int v34; // ecx@46
  __int16 v35; // ax@46
  int v36; // eax@46
  int v37; // eax@47
  __int16 v38; // ax@57
  UNICODE_STRING v39; // [sp+Ch] [bp-20h]@24
  ULONG ReturnLength; // [sp+14h] [bp-18h]@13
  int v41; // [sp+18h] [bp-14h]@38
  int v42; // [sp+1Ch] [bp-10h]@38
  int TokenInformation; // [sp+20h] [bp-Ch]@13
  int v44; // [sp+24h] [bp-8h]@1
  int v45; // [sp+28h] [bp-4h]@1
  HANDLE TokenHandlea; // [sp+38h] [bp+Ch]@17
  NTSTATUS NtStatusa; // [sp+44h] [bp+18h]@21
  int NtStatusb; // [sp+44h] [bp+18h]@45
  PVOID Addressa; // [sp+7Ch] [bp+50h]@19

  v45 = 0;
  v44 = 1;
  if ( !TokenHandle
    || a1 != -1073741541
    && a1 != -1073741520
    && a1 != -1073741519
    && (a1 != -1073741521 || !BaseIsDosApplication(a9, -1073741521)) )
    goto LABEL_69;
  v22 = NtQueryInformationToken(TokenHandle, TokenSessionId, &TokenInformation, 4u, &ReturnLength);
  if ( v22 < 0 )
  {
LABEL_14:
    BaseSetLastNTError(v22);
    return 0;
  }
  if ( TokenInformation == NtCurrentTeb()->ProcessEnvironmentBlock->SessionId )
  {
LABEL_69:
    if ( a1 == -1073741541 )
      goto LABEL_53;
    if ( a1 != -1073741521 )
    {
      if ( a1 == -1073741520 )
        goto LABEL_53;
      if ( a1 != -1073741519 )
      {
        switch ( a1 )
        {
          case -1073741209:
            RtlSetLastWin32Error(4350);
            break;
          case -1073740966:
            RtlSetLastWin32Error(216);
            break;
          case -1073740760:
            RtlSetLastWin32Error(577);
            break;
          default:
            BaseSetLastNTError(a1);
            break;
        }
        return 0;
      }
      if ( !(*(_DWORD *)a7 & 0x2000) )
      {
        v45 |= 1u;
        *(_BYTE *)a10 = 1;
        v31 = CheckElevation(lpFileName, (int)&v45, (int)TokenHandle, (int)&v41, (int)&v42);
        if ( v31 )
        {
LABEL_54:
          RtlSetLastWin32Error(v31);
          return 0;
        }
        if ( !BaseCreateVDMEnvironment(*(_DWORD *)a11, DestinationString, SourceString) )
          return 0;
        v32 = NtStatus;
        while ( 1 )
        {
          v33 = (*(_DWORD *)a7 & 0x800) != 0 ? 64 : 32;
          *(_DWORD *)Address = v33;
          NtStatusb = BaseCheckVDM(
                        v33,
                        *(PCWSTR *)a4,
                        *(_DWORD *)v32,
                        a6,
                        (int)DestinationString,
                        a13,
                        a14,
                        *(_DWORD *)a7,
                        MessageBoxResult,
                        (int)TokenHandle);
          if ( NtStatusb >= 0 )
            break;
          BaseSetLastNTError(NtStatusb);
          if ( NtStatusb == -1073740780 || *(_DWORD *)Address != 32 || GetLastError() != 5 )
            return 0;
          *(_DWORD *)a7 |= 0x800u;
        }
        v34 = a13;
        v35 = *(_WORD *)(a13 + 138);
        v36 = (v35 & 7) - 1;
        if ( !v36 )
        {
          *(_DWORD *)a18 = 1;
          if ( !BaseGetVdmConfigInfo(*(_DWORD *)v32, *(_DWORD *)a14, *(_DWORD *)Address, UnicodeString, a20) )
          {
            BaseSetLastNTError(-1073741519);
            return 0;
          }
          *(_DWORD *)v32 = UnicodeString->Buffer;
          *(_DWORD *)a4 = 0;
          *(_DWORD *)a7 = *(_DWORD *)a7 & 0xFFFFFFE7 | 0x8000000;
          *(_DWORD *)(MessageBoxResult + 44) |= 0x40u;
          goto LABEL_64;
        }
        goto LABEL_47;
      }
    }
    v44 = BaseIsDosApplication(a9, a1);
    if ( !v44 )
    {
      RtlSetLastWin32Error(193);
      return 0;
    }
LABEL_53:
    v45 |= 1u;
    *(_DWORD *)Address = 16;
    v31 = CheckElevation(lpFileName, (int)&v45, (int)TokenHandle, (int)&v41, (int)&v42);
    if ( v31 )
      goto LABEL_54;
    if ( !BaseCreateVDMEnvironment(*(_DWORD *)a11, DestinationString, SourceString) )
      return 0;
    v22 = BaseCheckVDM(
            v44 | *(_DWORD *)Address,
            *(PCWSTR *)a4,
            *(_DWORD *)NtStatus,
            a6,
            (int)DestinationString,
            a13,
            a14,
            *(_DWORD *)a7,
            MessageBoxResult,
            0);
    if ( v22 < 0 )
      goto LABEL_14;
    v34 = a13;
    v38 = *(_WORD *)(a13 + 138);
    v36 = (v38 & 7) - 1;
    if ( !v36 )
    {
      *(_DWORD *)a18 = 1;
      if ( *(_BYTE *)a7 & 8 )
      {
        RtlSetLastWin32Error(5);
        return 0;
      }
      if ( !BaseGetVdmConfigInfo(*(_DWORD *)NtStatus, *(_DWORD *)a14, *(_DWORD *)Address, UnicodeString, a20) )
      {
        BaseSetLastNTError(a1);
        return 0;
      }
      *(_DWORD *)NtStatus = UnicodeString->Buffer;
      *(_DWORD *)a4 = 0;
LABEL_64:
      --*(_DWORD *)a20;
      if ( !*(_DWORD *)a21 )
      {
        *(_DWORD *)a8 = 0;
        *(_DWORD *)a11 = SourceString->Buffer;
      }
      return 1;
    }
LABEL_47:
    v37 = v36 - 1;
    if ( !v37 )
    {
      RtlSetLastWin32Error(21);
      return 0;
    }
    if ( v37 == 2 )
    {
      *(_DWORD *)a18 = 4;
      *(_DWORD *)a21 = *(_DWORD *)(v34 + 52);
    }
    goto LABEL_64;
  }
  v23 = KernelBaseGetGlobalData();
  v24 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v23 + 44), 0x208u);
  TokenHandlea = v24;
  v25 = GetEnvironmentVariableW(L"SystemRoot", v24, 0xEFu);
  v26 = v25;
  if ( v25 >= 0xEF || !v25 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, TokenHandlea);
    BaseSetLastNTError(-1073741565);
    return 0;
  }
  RtlStringCchCatW((wchar_t *)TokenHandlea, 0x104u, L"\\system32\\csrstub.exe");
  v27 = v26 + 281;
  v28 = KernelBaseGetGlobalData();
  v29 = (wchar_t *)RtlAllocateHeap(
                     NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                     *(_DWORD *)(v28 + 44),
                     2 * v27);
  Addressa = v29;
  if ( !v29 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, TokenHandlea);
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  v30 = NtStatus;
  NtStatusa = RtlStringCchPrintfW(v29, v27, L"%ws %d -P %ws", TokenHandlea, *(_DWORD *)a7, *(_DWORD *)NtStatus);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, TokenHandlea);
  if ( NtStatusa < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Addressa);
LABEL_23:
    BaseSetLastNTError(NtStatusa);
    return 0;
  }
  NtStatusa = RtlInitUnicodeStringEx(&v39, (PCWSTR)Addressa);
  if ( NtStatusa < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Addressa);
    goto LABEL_23;
  }
  RtlFreeUnicodeString(UnicodeString);
  *UnicodeString = v39;
  *(_DWORD *)v30 = v39.Buffer;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)a7 = *(_DWORD *)a7 & 0x404 | 0xC000000;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E42A7A) --------------------------------------------------------
signed int __stdcall BaseIsDosApplication(int a1, int a2)
{
  USHORT v2; // cx@1
  USHORT v3; // cx@3
  USHORT v4; // cx@5
  signed int result; // eax@6
  signed int v6; // [sp-8h] [bp-14h]@10
  UNICODE_STRING String1; // [sp+4h] [bp-8h]@1

  v2 = *(_WORD *)a1;
  String1.Length = BaseDotComSuffixName.Length;
  if ( v2 < BaseDotComSuffixName.Length )
  {
    result = 0;
  }
  else
  {
    String1.Buffer = (PWCH)(*(_DWORD *)(a1 + 4) + 2 * ((v2 - (unsigned int)BaseDotComSuffixName.Length) >> 1));
    if ( RtlEqualUnicodeString(&String1, &BaseDotComSuffixName, 1u) )
    {
      v6 = 2;
    }
    else
    {
      v3 = *(_WORD *)a1;
      String1.Length = BaseDotPifSuffixName.Length;
      if ( v3 < BaseDotPifSuffixName.Length )
        return 0;
      String1.Buffer = (PWCH)(*(_DWORD *)(a1 + 4) + 2 * ((v3 - (unsigned int)BaseDotPifSuffixName.Length) >> 1));
      if ( !RtlEqualUnicodeString(&String1, &BaseDotPifSuffixName, 1u) )
      {
        v4 = *(_WORD *)a1;
        String1.Length = BaseDotExeSuffixName.Length;
        if ( v4 >= BaseDotExeSuffixName.Length )
        {
          String1.Buffer = (PWCH)(*(_DWORD *)(a1 + 4) + 2 * ((v4 - (unsigned int)BaseDotExeSuffixName.Length) >> 1));
          return RtlEqualUnicodeString(&String1, &BaseDotExeSuffixName, 1u) != 0;
        }
        return 0;
      }
      v6 = 3;
    }
    result = v6;
  }
  return result;
}

//----- (77E42B69) --------------------------------------------------------
signed int __stdcall BaseCheckVDMp(int a1, const WCHAR *a2, wchar_t *a3, const WCHAR *a4, int a5, int a6, int a7, int a8, int a9, void *a10)
{
  PPEB v10; // ecx@7
  unsigned int v11; // eax@20
  PVOID v12; // eax@20
  const WCHAR *v13; // edi@20
  void *v14; // eax@23
  void *v15; // eax@27
  void *v16; // eax@33
  DWORD v17; // eax@38
  PCHAR v18; // eax@41
  int v19; // ecx@42
  LPCWSTR v20; // eax@48
  LPCWSTR v21; // edx@48
  const WCHAR v22; // cx@49
  int v23; // edi@50
  wchar_t *i; // ecx@51
  const unsigned __int16 v25; // ax@52
  wchar_t v26; // ax@54
  wchar_t v27; // ax@63
  wchar_t v28; // ax@69
  wchar_t v29; // ax@72
  int v30; // edi@82
  const wchar_t *v31; // edi@84
  wchar_t *v32; // eax@84
  DWORD v33; // eax@86
  unsigned int v34; // eax@88
  wchar_t *v35; // eax@93
  STRSAFE_LPWSTR v36; // ecx@94
  wchar_t v37; // ax@95
  DWORD v38; // eax@101
  unsigned int v39; // eax@105
  unsigned int v40; // eax@105
  DWORD v41; // eax@114
  __int16 v42; // ax@123
  __int16 v43; // ax@124
  int v44; // esi@126
  int v45; // eax@128
  int v46; // edx@129
  __int16 v47; // cx@130
  int v48; // eax@131
  int v49; // edi@133
  const WCHAR *v50; // eax@134
  unsigned int v51; // ecx@137
  unsigned __int16 v52; // ax@137
  const WCHAR *v53; // eax@146
  const WCHAR *v54; // eax@149
  const WCHAR *v55; // esi@152
  __int16 v56; // ax@160
  NTSTATUS v57; // eax@191
  struct _LUID SourceLuid; // [sp+10h] [bp-2E8h]@156
  int v60; // [sp+18h] [bp-2E0h]@1
  int v61; // [sp+1Ch] [bp-2DCh]@20
  PCHAR v62; // [sp+20h] [bp-2D8h]@41
  DWORD cchBuffer; // [sp+24h] [bp-2D4h]@20
  wchar_t *v64; // [sp+28h] [bp-2D0h]@1
  int v65; // [sp+2Ch] [bp-2CCh]@133
  int v66; // [sp+30h] [bp-2C8h]@80
  int v67; // [sp+34h] [bp-2C4h]@79
  DWORD dwFlags; // [sp+38h] [bp-2C0h]@25
  PVOID Address; // [sp+3Ch] [bp-2BCh]@1
  LPCWSTR lpFileName; // [sp+40h] [bp-2B8h]@1
  HANDLE TokenHandle; // [sp+44h] [bp-2B4h]@1
  PVOID v72; // [sp+48h] [bp-2B0h]@3
  int v73; // [sp+4Ch] [bp-2ACh]@41
  int v74; // [sp+50h] [bp-2A8h]@1
  STRING v75; // [sp+54h] [bp-2A4h]@3
  STRING AnsiString; // [sp+5Ch] [bp-29Ch]@3
  STRING v77; // [sp+64h] [bp-294h]@3
  STRING v78; // [sp+6Ch] [bp-28Ch]@3
  STRSAFE_LPWSTR v79; // [sp+74h] [bp-284h]@1
  STRING v80; // [sp+78h] [bp-280h]@3
  STRING OemString; // [sp+80h] [bp-278h]@3
  STRING v82; // [sp+88h] [bp-270h]@3
  LPCWSTR lpszLongPath; // [sp+90h] [bp-268h]@1
  LPWSTR lpBuffer; // [sp+94h] [bp-264h]@3
  unsigned int v85; // [sp+98h] [bp-260h]@38
  STRSAFE_LPWSTR pszDest; // [sp+9Ch] [bp-25Ch]@3
  int v87; // [sp+A0h] [bp-258h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+A4h] [bp-254h]@40
  int v89; // [sp+ACh] [bp-24Ch]@158
  char v90; // [sp+B3h] [bp-245h]@4
  int v91; // [sp+B4h] [bp-244h]@137
  wchar_t *v92; // [sp+B8h] [bp-240h]@51
  unsigned int v93; // [sp+BCh] [bp-23Ch]@20
  NTSTATUS v94; // [sp+C0h] [bp-238h]@1
  WCHAR Buffer[262]; // [sp+C4h] [bp-234h]@105
  int pszSrc; // [sp+2D0h] [bp-28h]@1
  int v97; // [sp+2D4h] [bp-24h]@1
  wchar_t v98; // [sp+2D8h] [bp-20h]@1
  CPPEH_RECORD ms_exc; // [sp+2E0h] [bp-18h]@6
  unsigned int v100; // [sp+300h] [bp+8h]@3

  lpszLongPath = a2;
  v64 = a3;
  lpFileName = a4;
  v74 = a5;
  v60 = a7;
  v87 = a9;
  TokenHandle = a10;
  v94 = -1073741823;
  Address = 0;
  pszSrc = *(_DWORD *)L".pif";
  v97 = *(_DWORD *)L"\u7000\u6900\u6600";
  v98 = a_pif[4];
  v79 = 0;
  if ( !a5 || *(_WORD *)a5 > 0x8000u )
  {
    BaseSetLastNTError(-1073741811);
    return -1073741811;
  }
  v72 = 0;
  OemString.Buffer = 0;
  v80.Buffer = 0;
  v82.Buffer = 0;
  v78.Buffer = 0;
  AnsiString.Buffer = 0;
  v77.Buffer = 0;
  v75.Buffer = 0;
  pszDest = 0;
  lpBuffer = 0;
  v100 = a1 & 0xFFFFFFF0;
  if ( !NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] || (v90 = 0, a8 & 0x10) )
    v90 = 1;
  ms_exc.registration.TryLevel = 0;
  if ( v100 == 16 )
  {
    v10 = NtCurrentTeb()->ProcessEnvironmentBlock;
    if ( a9 && *(_DWORD *)(a9 + 44) & 0x100 )
    {
      *(_DWORD *)(a6 + 56) = *(_DWORD *)(a9 + 56);
      *(_DWORD *)(a6 + 60) = *(_DWORD *)(a9 + 60);
      *(_DWORD *)(a6 + 64) = *(_DWORD *)(a9 + 64);
    }
    else
    {
      *(_DWORD *)(a6 + 56) = v10->ProcessParameters->Reserved2[2];
      *(_DWORD *)(a6 + 60) = v10->ProcessParameters->Reserved2[3];
      *(_DWORD *)(a6 + 64) = v10->ProcessParameters->Reserved2[4];
      if ( (unsigned int)v10->ProcessParameters[1].Reserved2[4] & 0x600 )
      {
        v14 = *(void **)(a6 + 56);
        if ( v14 && ((unsigned int)v14 & 0x10000003) != 3 && !GetHandleInformation(v14, &dwFlags) )
          *(_DWORD *)(a6 + 56) = 0;
        v15 = *(void **)(a6 + 60);
        if ( v15 && ((unsigned int)v15 & 0x10000003) != 3 && !GetHandleInformation(v15, &dwFlags) )
        {
          if ( *(_DWORD *)(a6 + 64) == *(_DWORD *)(a6 + 60) )
            *(_DWORD *)(a6 + 64) = 0;
          *(_DWORD *)(a6 + 60) = 0;
        }
        v16 = *(void **)(a6 + 64);
        if ( v16
          && v16 != *(void **)(a6 + 60)
          && ((unsigned int)v16 & 0x10000003) != 3
          && !GetHandleInformation(v16, &dwFlags) )
          *(_DWORD *)(a6 + 64) = 0;
      }
    }
    if ( (*(_DWORD *)(a6 + 56) & 0x10000003) == 3 )
      *(_DWORD *)(a6 + 56) = 0;
    if ( (*(_DWORD *)(a6 + 60) & 0x10000003) == 3 )
      *(_DWORD *)(a6 + 60) = 0;
    if ( (*(_DWORD *)(a6 + 64) & 0x10000003) == 3 )
      *(_DWORD *)(a6 + 64) = 0;
  }
  if ( v100 == 64 )
    v90 = 1;
  while ( *lpszLongPath == 32 || *lpszLongPath == 9 )
    ++lpszLongPath;
  v11 = wcslen(lpszLongPath);
  v93 = v11;
  cchBuffer = v11 + 261;
  v61 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v12 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v61 + 0x200000, 2 * cchBuffer);
  v13 = (const WCHAR *)v12;
  v72 = v12;
  if ( !v12 )
    goto LABEL_21;
  v17 = GetShortPathNameW(lpszLongPath, (LPWSTR)v12, cchBuffer);
  v85 = v17;
  if ( !v17 || v17 > cchBuffer )
  {
    v94 = -1073741767;
    goto LABEL_197;
  }
  RtlInitUnicodeString(&DestinationString, v13);
  v94 = RtlUnicodeStringToOemString(&v80, &DestinationString, 1u);
  if ( v94 < 0 )
    goto LABEL_197;
  v85 = v80.Length;
  v18 = v80.Buffer;
  v62 = v80.Buffer;
  v73 = 1;
  while ( 1 )
  {
    v19 = v85--;
    if ( !v19 || *v18 == 46 )
      break;
    if ( *v18 == 92 )
      v73 = 1;
    else
      ++v73;
    ++v18;
    v62 = v18;
  }
  v20 = lpszLongPath;
  v21 = lpszLongPath + 1;
  do
  {
    v22 = *v20;
    ++v20;
  }
  while ( v22 );
  v23 = v20 - v21;
  v93 = v20 - v21;
  if ( 34 == *v64 )
  {
    i = v64 + 1;
    v92 = v64 + 1;
    do
    {
      v25 = *i;
      if ( !*i )
        break;
      ++i;
      v92 = i;
    }
    while ( 34 != v25 );
  }
  else
  {
    if ( v23 <= wcslen(v64) && !__wcsnicmp(lpszLongPath, v64, v23) )
    {
      i = &v64[v23];
      goto LABEL_58;
    }
    for ( i = v64; ; ++i )
    {
      v92 = i;
      v27 = *i;
      if ( !*i || v27 != 32 && v27 != 9 )
        break;
    }
    if ( *i == 34 )
    {
      ++i;
      v92 = i;
      do
      {
        v28 = *i;
        if ( !*i )
          break;
        ++i;
        v92 = i;
      }
      while ( v28 != 34 );
    }
    else
    {
      while ( 1 )
      {
        v29 = *i;
        if ( !*i || v29 == 32 || v29 == 9 )
          break;
        ++i;
        v92 = i;
      }
    }
  }
  while ( 1 )
  {
    v26 = *i;
    if ( !*i || 32 != v26 && 9 != v26 )
      break;
    ++i;
LABEL_58:
    v92 = i;
  }
  v85 = wcslen(i);
  DestinationString.Length = 2 * v85;
  DestinationString.MaximumLength = 2 * v85 + 2;
  DestinationString.Buffer = i;
  v94 = RtlUnicodeStringToOemString(&OemString, &DestinationString, 1u);
  if ( v94 < 0 )
    goto LABEL_197;
  if ( OemString.Length >= (unsigned int)(128 - v73) )
    goto LABEL_78;
  v67 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  pszDest = (STRSAFE_LPWSTR)RtlAllocateHeap(
                              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                              v67 + 0x200000,
                              0x208u);
  if ( !pszDest )
    goto LABEL_21;
  v66 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  lpBuffer = (LPWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v66 + 0x200000, 0x208u);
  if ( !lpBuffer )
    goto LABEL_21;
  if ( v100 == 32 )
  {
    StringCchCopyW(pszDest, 0x104u, L"wowexec.pif");
    v30 = 0;
    v93 = 0;
LABEL_91:
    v92 = _wcsrchr(pszDest, 0x5Cu);
    if ( !v92 )
      v92 = _wcsrchr(pszDest, 0x3Au);
    v35 = v92;
    ++v92;
    if ( v35 )
    {
      v36 = pszDest;
      while ( 1 )
      {
        v37 = *v92;
        if ( !*v92 || v37 == 32 || v37 == 9 )
          break;
        v36[v30++] = v37;
        v93 = v30;
        ++v92;
      }
      v36[v30] = 0;
    }
    if ( !v30 )
    {
LABEL_103:
      *lpBuffer = 0;
      goto LABEL_104;
    }
    v38 = SearchPathW(0, pszDest, (LPCWSTR)&pszSrc, 0x104u, lpBuffer, 0);
    v93 = v38;
    if ( v38 < 0x104 )
    {
      if ( v38 )
        goto LABEL_104;
      goto LABEL_103;
    }
LABEL_21:
    v94 = -1073741801;
    goto LABEL_197;
  }
  if ( v93 >= 0x104 )
    goto LABEL_78;
  v31 = pszDest;
  StringCchCopyW(pszDest, 0x104u, lpszLongPath);
  v32 = _wcsrchr(v31, 0x2Eu);
  v92 = v32;
  if ( !v32 || (unsigned int)(v31 - v32 + 260) < 5 )
    goto LABEL_78;
  StringCbCopyW(v32, 0xAu, (STRSAFE_LPCWSTR)&pszSrc);
  v33 = GetFileAttributesW(v31);
  v93 = v33;
  if ( v33 == -1 || v33 & 0x10 )
  {
    v30 = 0;
    v93 = 0;
  }
  else
  {
    v34 = wcslen(v31);
    v30 = v34 + 1;
    v93 = v34 + 1;
    StringCchCopyNW(lpBuffer, 0x104u, pszDest, v34 + 1);
  }
  if ( !v30 )
    goto LABEL_91;
LABEL_104:
  if ( lpFileName )
  {
    v41 = GetFullPathNameW(lpFileName, 0x105u, Buffer, 0);
    v85 = v41;
    if ( v41 )
    {
      if ( v41 > 0x105 )
        goto LABEL_197;
      v41 = GetShortPathNameW(Buffer, Buffer, 0x105u);
      v85 = v41;
    }
    if ( v41 > 0x105 )
      goto LABEL_197;
    if ( v41 )
    {
      DestinationString.Buffer = Buffer;
      DestinationString.Length = 2 * v41;
      DestinationString.MaximumLength = 522;
    }
    else
    {
      RtlInitUnicodeString(&DestinationString, lpFileName);
    }
    v94 = RtlUnicodeStringToAnsiString(&v82, &DestinationString, 1u);
    if ( v94 < 0 )
      goto LABEL_197;
    if ( v82.Length - 2 > 64 )
      goto LABEL_78;
  }
  else
  {
    v39 = RtlGetCurrentDirectory_U(0x20Au, Buffer);
    v85 = v39;
    Buffer[v39 >> 1] = 0;
    v40 = GetShortPathNameW(Buffer, Buffer, 0x105u);
    v85 = v40;
    if ( v40 > 0x105 )
      goto LABEL_197;
    if ( v40 )
    {
      DestinationString.Length = 2 * v40;
      DestinationString.Buffer = Buffer;
      DestinationString.MaximumLength = 522;
    }
    else
    {
      RtlInitUnicodeString(&DestinationString, Buffer);
      v40 = (unsigned int)DestinationString.Length >> 1;
      v85 = (unsigned int)DestinationString.Length >> 1;
    }
    v94 = v40 - 2 > 0x40 ? -1073741811 : RtlUnicodeStringToAnsiString(&v82, &DestinationString, 1u);
    if ( v94 < 0 )
      goto LABEL_197;
  }
  v42 = *v82.Buffer;
  if ( *v82.Buffer > 90 )
    v43 = v42 - 97;
  else
    v43 = v42 - 65;
  *(_WORD *)(a6 + 136) = v43;
  v44 = v87;
  if ( v87 && *(_DWORD *)(v87 + 44) & 0x200 )
  {
    v45 = *(_DWORD *)(v87 + 4);
    if ( v45 )
    {
      v46 = v45 + 2;
      do
      {
        v47 = *(_WORD *)v45;
        v45 += 2;
      }
      while ( v47 );
      v48 = (v45 - v46) >> 1;
    }
    else
    {
      v48 = 0;
    }
    v49 = 2 * v48 + 42;
    v65 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v79 = (STRSAFE_LPWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v65 + 0x200000, v49);
    if ( v79 )
    {
      v50 = *(const WCHAR **)(v44 + 4);
      if ( !v50 )
        v50 = &Src;
      StringCbPrintfW(v79, v49, L"hotkey.%u %s", *(_DWORD *)(v44 + 56), v50);
      *(_DWORD *)(v44 + 44) &= 0xFFFFFDFF;
      *(_DWORD *)(v44 + 56) = 0;
      *(_DWORD *)(v44 + 4) = v79;
    }
  }
  v91 = 2;
  v51 = ((v80.Length + 4) & 0xFFFFFFFC) + ((OemString.Length + 6) & 0xFFFFFFFC);
  v93 = ((v80.Length + 4) & 0xFFFFFFFC) + ((OemString.Length + 6) & 0xFFFFFFFC);
  v52 = *(_WORD *)v74;
  if ( *(_WORD *)v74 )
  {
    v91 = 3;
    v51 += (v52 + 3) & 0xFFFFFFFC;
    v93 = v51;
  }
  if ( v82.Length )
  {
    ++v91;
    v93 = ((v82.Length + 4) & 0xFFFFFFFC) + v51;
  }
  if ( lpBuffer && *lpBuffer )
  {
    ++v91;
    RtlInitUnicodeString(&DestinationString, lpBuffer);
    v94 = RtlUnicodeStringToAnsiString(&AnsiString, &DestinationString, 1u);
    if ( v94 < 0 )
      goto LABEL_197;
    v93 += (AnsiString.Length + 4) & 0xFFFFFFFC;
  }
  if ( !v44 )
    goto LABEL_155;
  v93 += 68;
  ++v91;
  v53 = *(const WCHAR **)(v44 + 8);
  if ( v53 )
  {
    ++v91;
    RtlInitUnicodeString(&DestinationString, v53);
    v94 = RtlUnicodeStringToAnsiString(&v78, &DestinationString, 1u);
    if ( v94 < 0 )
      goto LABEL_197;
    v93 += (v78.Length + 4) & 0xFFFFFFFC;
  }
  v54 = *(const WCHAR **)(v44 + 12);
  if ( v54 )
  {
    ++v91;
    RtlInitUnicodeString(&DestinationString, v54);
    v94 = RtlUnicodeStringToOemString(&v77, &DestinationString, 1u);
    if ( v94 < 0 )
      goto LABEL_197;
    v93 += (v77.Length + 4) & 0xFFFFFFFC;
  }
  v55 = *(const WCHAR **)(v44 + 4);
  if ( !v55 )
  {
LABEL_155:
    if ( !TokenHandle )
      goto LABEL_158;
    ++v91;
    if ( BaseGetVdmLuid(TokenHandle, (int)&SourceLuid) >= 0 )
    {
      v93 += 8;
LABEL_158:
      v89 = CsrAllocateCaptureBuffer(v91, v93);
      if ( v89 )
      {
        CsrAllocateMessagePointer(v89, (OemString.Length + 6) & 0xFFFFFFFC, a6 + 76);
        _memmove(*(void **)(a6 + 76), OemString.Buffer, OemString.Length);
        *(_BYTE *)(OemString.Length + *(_DWORD *)(a6 + 76)) = 13;
        *(_BYTE *)(OemString.Length + *(_DWORD *)(a6 + 76) + 1) = 10;
        *(_BYTE *)(OemString.Length + *(_DWORD *)(a6 + 76) + 2) = 0;
        *(_WORD *)(a6 + 128) = OemString.Length + 3;
        CsrAllocateMessagePointer(v89, (v80.Length + 4) & 0xFFFFFFFC, a6 + 80);
        _memmove(*(void **)(a6 + 80), v80.Buffer, v80.Length);
        *(_BYTE *)(v80.Length + *(_DWORD *)(a6 + 80)) = 0;
        *(_WORD *)(a6 + 130) = v80.Length + 1;
        if ( AnsiString.Buffer )
        {
          CsrAllocateMessagePointer(v89, (AnsiString.Length + 4) & 0xFFFFFFFC, a6 + 84);
          _memmove(*(void **)(a6 + 84), AnsiString.Buffer, AnsiString.Length);
          *(_BYTE *)(AnsiString.Length + *(_DWORD *)(a6 + 84)) = 0;
          *(_WORD *)(a6 + 132) = AnsiString.Length + 1;
          v56 = 0;
        }
        else
        {
          v56 = 0;
          *(_WORD *)(a6 + 132) = 0;
          *(_DWORD *)(a6 + 84) = 0;
        }
        if ( *(_WORD *)v74 == v56 )
        {
          *(_DWORD *)(a6 + 96) = 0;
          *(_DWORD *)(a6 + 92) = 0;
        }
        else
        {
          CsrAllocateMessagePointer(v89, (*(_WORD *)v74 + 3) & 0xFFFFFFFC, a6 + 92);
          _memmove(*(void **)(a6 + 92), *(const void **)(v74 + 4), *(_WORD *)v74);
          *(_DWORD *)(a6 + 96) = *(_WORD *)v74;
          v56 = 0;
        }
        if ( (_WORD)v82.Length == v56 )
        {
          *(_DWORD *)(a6 + 88) = 0;
          *(_WORD *)(a6 + 134) = 0;
        }
        else
        {
          CsrAllocateMessagePointer(v89, (v82.Length + 4) & 0xFFFFFFFC, a6 + 88);
          _memmove(*(void **)(a6 + 88), v82.Buffer, v82.Length);
          *(_BYTE *)(v82.Length + *(_DWORD *)(a6 + 88)) = 0;
          *(_WORD *)(a6 + 134) = v82.Length + 1;
        }
        if ( v87 )
        {
          CsrAllocateMessagePointer(v89, 68, a6 + 100);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 16) = *(_DWORD *)(v87 + 16);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 20) = *(_DWORD *)(v87 + 20);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 24) = *(_DWORD *)(v87 + 24);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 28) = *(_DWORD *)(v87 + 28);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 32) = *(_DWORD *)(v87 + 32);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 36) = *(_DWORD *)(v87 + 36);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 40) = *(_DWORD *)(v87 + 40);
          *(_DWORD *)(*(_DWORD *)(a6 + 100) + 44) = *(_DWORD *)(v87 + 44);
          *(_WORD *)(*(_DWORD *)(a6 + 100) + 48) = *(_WORD *)(v87 + 48);
          **(_DWORD **)(a6 + 100) = 68;
        }
        else
        {
          *(_DWORD *)(a6 + 100) = 0;
        }
        if ( v78.Buffer )
        {
          CsrAllocateMessagePointer(v89, (v78.Length + 4) & 0xFFFFFFFC, a6 + 104);
          _memmove(*(void **)(a6 + 104), v78.Buffer, v78.Length);
          *(_BYTE *)(v78.Length + *(_DWORD *)(a6 + 104)) = 0;
          *(_DWORD *)(a6 + 108) = v78.Length + 1;
        }
        else
        {
          *(_DWORD *)(a6 + 104) = 0;
          *(_DWORD *)(a6 + 108) = 0;
        }
        if ( v77.Buffer )
        {
          CsrAllocateMessagePointer(v89, (v77.Length + 4) & 0xFFFFFFFC, a6 + 112);
          _memmove(*(void **)(a6 + 112), v77.Buffer, v77.Length);
          *(_BYTE *)(v77.Length + *(_DWORD *)(a6 + 112)) = 0;
          *(_DWORD *)(a6 + 116) = v77.Length + 1;
        }
        else
        {
          *(_DWORD *)(a6 + 112) = 0;
          *(_DWORD *)(a6 + 116) = 0;
        }
        if ( v75.Buffer )
        {
          CsrAllocateMessagePointer(v89, (v75.Length + 4) & 0xFFFFFFFC, a6 + 120);
          _memmove(*(void **)(a6 + 120), v75.Buffer, v75.Length);
          *(_BYTE *)(v75.Length + *(_DWORD *)(a6 + 120)) = 0;
          *(_DWORD *)(a6 + 124) = v75.Length + 1;
        }
        else
        {
          *(_DWORD *)(a6 + 120) = 0;
          *(_DWORD *)(a6 + 124) = 0;
        }
        if ( TokenHandle )
        {
          CsrAllocateMessagePointer(v89, 8, a6 + 140);
          RtlCopyLuid(*(PLUID *)(a6 + 140), &SourceLuid);
        }
        else
        {
          *(_DWORD *)(a6 + 140) = 0;
        }
        if ( v100 == 32 )
        {
          *(_DWORD *)(a6 + 44) = -1;
        }
        else if ( v90 )
        {
          *(_DWORD *)(a6 + 44) = 0;
        }
        else
        {
          *(_DWORD *)(a6 + 44) = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
        }
        *(_WORD *)(a6 + 138) = 0;
        *(_DWORD *)(a6 + 48) = v100;
        *(_DWORD *)(a6 + 68) = GetConsoleCP();
        *(_DWORD *)(a6 + 72) = a8;
        v94 = CsrClientCallServer(a6, v89, 268500997, 104);
        if ( v94 != -1073741790 || *(_DWORD *)(a6 + 108) )
        {
          CsrFreeCaptureBuffer(v89);
          v57 = 0;
          if ( v94 < 0 || *(_DWORD *)(a6 + 32) < 0 )
            v57 = *(_DWORD *)(a6 + 32);
          else
            *(_DWORD *)v60 = *(_DWORD *)(a6 + 40);
          v94 = v57;
        }
        else
        {
          CsrFreeCaptureBuffer(v89);
        }
        goto LABEL_197;
      }
      goto LABEL_21;
    }
LABEL_78:
    v94 = -1073741811;
    goto LABEL_197;
  }
  ++v91;
  RtlInitUnicodeString(&DestinationString, v55);
  v94 = RtlUnicodeStringToAnsiString(&v75, &DestinationString, 1u);
  if ( v94 >= 0 )
  {
    v93 += (v75.Length + 4) & 0xFFFFFFFC;
    goto LABEL_155;
  }
LABEL_197:
  ms_exc.registration.TryLevel = -2;
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( pszDest )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, pszDest);
  if ( lpBuffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpBuffer);
  if ( OemString.Buffer )
    RtlFreeOemString(&OemString);
  if ( v80.Buffer )
    RtlFreeOemString(&v80);
  if ( AnsiString.Buffer )
    RtlFreeAnsiString(&AnsiString);
  if ( v82.Buffer )
    RtlFreeAnsiString(&v82);
  if ( v78.Buffer )
    RtlFreeAnsiString(&v78);
  if ( v77.Buffer )
    RtlFreeAnsiString(&v77);
  if ( v75.Buffer )
    RtlFreeAnsiString(&v75);
  if ( v72 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v72);
  if ( v79 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v79);
  return v94;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E43D3C: using guessed type wchar_t a_pif[5];
// 77E42B69: using guessed type WCHAR Buffer[262];

//----- (77E43D83) --------------------------------------------------------
BOOL __stdcall GetDiskFreeSpaceExAStub(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
  return GetDiskFreeSpaceExA(
           lpDirectoryName,
           lpFreeBytesAvailableToCaller,
           lpTotalNumberOfBytes,
           lpTotalNumberOfFreeBytes);
}

//----- (77E43E19) --------------------------------------------------------
LSTATUS __stdcall RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
{
  int (__stdcall *v4)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx@1
  HKEY v5; // esi@1
  int v6; // eax@2
  NTSTATUS v7; // eax@3
  int v8; // esi@7
  int v9; // esi@11
  int v10; // edi@11
  int v11; // eax@11
  ULONG v13; // eax@19
  char v14; // [sp+10h] [bp-44h]@19
  UNICODE_STRING FileHandle; // [sp+24h] [bp-30h]@3
  int v16; // [sp+30h] [bp-24h]@1
  int v17; // [sp+34h] [bp-20h]@1
  LSTATUS v18; // [sp+38h] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@16

  v16 = 0;
  v17 = 0;
  v4 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 128);
  v5 = hKey;
  if ( hKey != HKEY_PERFORMANCE_DATA )
  {
    v6 = RegKrnGetGlobalState();
    v18 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v6 + 176))(v5, &hKey, &v16, &v17);
    if ( !v18 )
    {
      v7 = RtlInitUnicodeStringEx(&FileHandle, lpFile);
      if ( v7 < 0 )
      {
        v18 = RtlNtStatusToDosError(v7);
      }
      else
      {
        if ( FileHandle.Length > 0u )
          FileHandle.Length += 2;
        if ( !lpSecurityAttributes )
        {
          v8 = 0;
          lpFile = 0;
LABEL_8:
          if ( (unsigned __int8)hKey & 1 )
          {
            if ( v4 )
            {
              ms_exc.registration.TryLevel = 0;
              v18 = v4((unsigned int)hKey & 0xFFFFFFFE, &FileHandle, v8, Flags);
              ms_exc.registration.TryLevel = -2;
            }
          }
          else
          {
            v18 = LocalBaseRegSaveKeyEx((int)hKey, &FileHandle, v8, Flags);
          }
          if ( v8 )
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v8 + 4));
          goto LABEL_11;
        }
        v8 = (int)&v14;
        lpFile = (LPCWSTR)&v14;
        v13 = MapSAToRpcSA((int)lpSecurityAttributes, (int)&v14);
        v18 = v13;
        if ( !v13 )
          goto LABEL_8;
      }
    }
LABEL_11:
    v9 = v17;
    v10 = v16;
    v11 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v11 + 168))(v10, v9);
    return v18;
  }
  return 6;
}

//----- (77E43F09) --------------------------------------------------------
ULONG __stdcall LocalBaseRegSaveKeyEx(int a1, HANDLE FileHandle, int a3, int a4)
{
  HANDLE v4; // edi@2
  unsigned __int16 v5; // ax@4
  int v6; // ebx@7
  PVOID v7; // edi@9
  int v8; // ebx@13
  ULONG result; // eax@17
  void *v10; // eax@20
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-38h]@11
  int v12; // [sp+24h] [bp-20h]@8
  void *v13; // [sp+28h] [bp-1Ch]@23
  void *v14; // [sp+2Ch] [bp-18h]@10
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+34h] [bp-10h]@13
  int v16; // [sp+3Ch] [bp-8h]@8
  PVOID Address; // [sp+40h] [bp-4h]@9

  if ( !a1 )
    goto LABEL_28;
  v4 = FileHandle;
  if ( !FileHandle )
    goto LABEL_28;
  if ( !*((_DWORD *)FileHandle + 1) )
    goto LABEL_28;
  v5 = *(_WORD *)FileHandle;
  if ( *(_WORD *)FileHandle & 1 )
    goto LABEL_28;
  if ( v5 > 0u )
    *(_WORD *)FileHandle = v5 - 2;
  if ( ((v6 = a3) == 0
     || (v10 = *(void **)(a3 + 4)) != 0 && RtlValidRelativeSecurityDescriptor(v10, *(_DWORD *)(a3 + 8), 0))
    && (unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(*((_DWORD *)v4 + 1), &v16, 0, &v12) )
  {
    v7 = Address;
    if ( (_WORD)v12 )
    {
      v16 = v12;
      Address = v13;
    }
    else
    {
      v14 = 0;
    }
    ObjectAttributes.RootDirectory = v14;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v16;
    if ( v6 )
      ObjectAttributes.SecurityDescriptor = *(PVOID *)(v6 + 4);
    else
      ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v8 = NtCreateFile(&FileHandle, 0x40100000u, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 1u, 2u, 0x4020u, 0, 0);
    RtlReleaseRelativeName(&v12);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
    if ( v8 >= 0 )
    {
      if ( a1 & 2 )
        v8 = -1073741811;
      else
        v8 = NtSaveKeyEx(a1, FileHandle, a4);
      NtClose(FileHandle);
    }
    result = RtlNtStatusToDosError(v8);
  }
  else
  {
LABEL_28:
    result = 87;
  }
  return result;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);
// 77DE16BC: using guessed type int __stdcall NtSaveKeyEx(_DWORD, _DWORD, _DWORD);

//----- (77E44050) --------------------------------------------------------
BOOL __stdcall MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
{
  return MoveFileWithProgressTransactedA(
           lpExistingFileName,
           lpNewFileName,
           (int)lpProgressRoutine,
           (int)lpData,
           dwFlags,
           0);
}

//----- (77E44074) --------------------------------------------------------
int __stdcall MoveFileWithProgressTransactedA(const char *a1, const char *a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@4
  LSA_UNICODE_STRING v8; // [sp+0h] [bp-10h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, a1) )
  {
    if ( !a2 )
    {
      v8.Buffer = 0;
      goto LABEL_4;
    }
    if ( Basep8BitStringToDynamicUnicodeString((int)&v8, a2) )
    {
LABEL_4:
      v6 = MoveFileWithProgressTransactedW(UnicodeString.Buffer, v8.Buffer, a3, a4, a5, a6);
      RtlFreeUnicodeString(&UnicodeString);
      RtlFreeUnicodeString(&v8);
      return v6;
    }
    RtlFreeUnicodeString(&UnicodeString);
  }
  return 0;
}

//----- (77E440EA) --------------------------------------------------------
HWND __stdcall GetConsoleWindow()
{
  HWND result; // eax@2
  ULONG v1; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HWND v4; // [sp+28h] [bp-7Ch]@2

  ConsoleClientCallServer(&RequestMessage, 0, 67, 4);
  if ( NtStatus < 0 )
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  else
  {
    result = v4;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E44132) --------------------------------------------------------
BOOL __stdcall IsProcessInJobStub(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
{
  return IsProcessInJob(ProcessHandle, JobHandle, Result);
}

//----- (77E44184) --------------------------------------------------------
HRESULT __stdcall WerUnregisterMemoryBlock(PVOID pvAddress)
{
  return WerpUnregisterMemoryBlock(pvAddress);
}

//----- (77E441A9) --------------------------------------------------------
LSTATUS __stdcall RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
{
  HKEY v3; // esi@1
  int v4; // eax@2
  LSTATUS v5; // ebx@2
  NTSTATUS v6; // eax@3
  ULONG v7; // eax@7
  int v8; // esi@9
  int v9; // edi@9
  int v10; // eax@9
  UNICODE_STRING Handle; // [sp+10h] [bp-34h]@3
  LSTATUS v13; // [sp+18h] [bp-2Ch]@12
  int v14; // [sp+20h] [bp-24h]@1
  int v15; // [sp+24h] [bp-20h]@1
  int (__stdcall *v16)(unsigned int, UNICODE_STRING *, DWORD); // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@12

  v14 = 0;
  v15 = 0;
  v16 = *(int (__stdcall **)(unsigned int, UNICODE_STRING *, DWORD))(RegKrnGetGlobalState() + 124);
  v3 = hKey;
  if ( hKey != HKEY_PERFORMANCE_DATA )
  {
    v4 = RegKrnGetGlobalState();
    v5 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v4 + 176))(v3, &hKey, &v14, &v15);
    if ( !v5 )
    {
      v6 = RtlInitUnicodeStringEx(&Handle, lpFile);
      if ( v6 < 0 )
      {
        v7 = RtlNtStatusToDosError(v6);
      }
      else
      {
        if ( Handle.Length > 0u )
          Handle.Length += 2;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v16 )
          {
            ms_exc.registration.TryLevel = 0;
            v5 = v16((unsigned int)hKey & 0xFFFFFFFE, &Handle, dwFlags);
            v13 = v5;
            ms_exc.registration.TryLevel = -2;
          }
          goto LABEL_9;
        }
        v7 = LocalBaseRegRestoreKey(hKey, &Handle, dwFlags);
      }
      v5 = v7;
    }
LABEL_9:
    v8 = v15;
    v9 = v14;
    v10 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v10 + 168))(v9, v8);
    return v5;
  }
  return 6;
}

//----- (77E44279) --------------------------------------------------------
ULONG __stdcall LocalBaseRegRestoreKey(HANDLE KeyHandle, HANDLE Handle, ULONG Flags)
{
  int v3; // edx@3
  unsigned __int16 v4; // cx@4
  PVOID v5; // edi@8
  int v6; // esi@10
  ULONG result; // eax@16
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-48h]@10
  int v9; // [sp+1Ch] [bp-30h]@7
  void *v10; // [sp+20h] [bp-2Ch]@19
  void *v11; // [sp+24h] [bp-28h]@9
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+2Ch] [bp-20h]@10
  UNICODE_STRING Source; // [sp+34h] [bp-18h]@20
  int v14; // [sp+3Ch] [bp-10h]@7
  PVOID Address; // [sp+40h] [bp-Ch]@8
  void (__stdcall *v16)(HANDLE, HANDLE, ULONG); // [sp+44h] [bp-8h]@1
  HANDLE FileHandle; // [sp+48h] [bp-4h]@10

  v16 = *(void (__stdcall **)(HANDLE, HANDLE, ULONG))(RegKrnGetGlobalState() + 20);
  if ( !KeyHandle )
    goto LABEL_25;
  if ( !Handle )
    goto LABEL_25;
  v3 = *((_DWORD *)Handle + 1);
  if ( !v3 )
    goto LABEL_25;
  v4 = *(_WORD *)Handle;
  if ( *(_WORD *)Handle & 1 )
    goto LABEL_25;
  if ( v4 > 0u )
    *(_WORD *)Handle = v4 - 2;
  if ( (unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(v3, &v14, 0, &v9) )
  {
    v5 = Address;
    if ( (_WORD)v9 )
    {
      v14 = v9;
      Address = v10;
    }
    else
    {
      v11 = 0;
    }
    ObjectAttributes.RootDirectory = v11;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v14;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v6 = NtOpenFile(&FileHandle, 0x80100000, &ObjectAttributes, &IoStatusBlock, 1u, 0x20u);
    RtlReleaseRelativeName(&v9);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
    if ( v6 >= 0 )
    {
      if ( (unsigned __int8)KeyHandle & 2 )
      {
        Source.Length = 0;
        Source.MaximumLength = 0;
        Source.Buffer = 0;
        v6 = BaseRegOpenClassKey(KeyHandle, &Source, 0, 0x2000000, (int)&Handle, 0);
        if ( v6 >= 0 )
        {
          v6 = NtRestoreKey(Handle, FileHandle, Flags);
          NtClose(Handle);
        }
      }
      else
      {
        v6 = NtRestoreKey(KeyHandle, FileHandle, Flags);
      }
      NtClose(FileHandle);
      if ( v6 >= 0 && !(Flags & 1) )
      {
        if ( v16 )
          v16(KeyHandle, FileHandle, Flags);
      }
    }
    result = RtlNtStatusToDosError(v6);
  }
  else
  {
LABEL_25:
    result = 87;
  }
  return result;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);

//----- (77E443D8) --------------------------------------------------------
int __stdcall ValStateGetPhysicalIndexFromLogical(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a5 = *(_DWORD *)(8 * a3 + *(_DWORD *)(a1 + 24));
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 24) + 8 * a3 + 4) )
      result = *(_DWORD *)(a1 + 4);
    else
      result = *(_DWORD *)(a1 + 8);
    *(_DWORD *)a4 = result;
  }
  else
  {
    *(_DWORD *)a5 = a3;
    result = a4;
    *(_DWORD *)a4 = a2;
  }
  return result;
}

//----- (77E44401) --------------------------------------------------------
NTSTATUS __stdcall BaseRegGetClassKeyValueState(PVOID Address, int a2, int a3)
{
  NTSTATUS v3; // esi@1
  PVOID v4; // edi@2

  v3 = KeyStateGetValueState(Address, (int)&Address);
  if ( v3 >= 0 )
  {
    v4 = Address;
    v3 = ValStateSetPhysicalIndexFromLogical((ULONG)Address, a2);
    if ( v3 < 0 )
      ValStateRelease(v4);
    else
      *(_DWORD *)a3 = v4;
  }
  return v3;
}

//----- (77E44442) --------------------------------------------------------
NTSTATUS __stdcall ValStateSetPhysicalIndexFromLogical(ULONG Index, int a2)
{
  NTSTATUS result; // eax@1
  unsigned int v3; // ecx@5

  result = 0;
  if ( Index )
  {
    if ( (unsigned int)a2 < *(_DWORD *)(Index + 16) )
    {
      v3 = *(_DWORD *)(Index + 12);
      if ( a2 < v3 || a2 > v3 + 1 || a2 == v3 && !(*(_BYTE *)(Index + 20) & 1) )
      {
        result = ValStateUpdate(Index);
        if ( result >= 0 )
          *(_DWORD *)(Index + 20) &= 0xFFFFFFFE;
      }
    }
    else
    {
      *(_DWORD *)(Index + 20) |= 2u;
      result = -2147483622;
    }
  }
  return result;
}

//----- (77E4445F) --------------------------------------------------------
int __stdcall KeyStateGetValueState(HANDLE KeyHandle, int a2)
{
  return ValStateInitialize(a2, KeyHandle);
}

//----- (77E44478) --------------------------------------------------------
int __stdcall ValStateInitialize(int a1, HANDLE KeyHandle)
{
  NTSTATUS v2; // edi@1
  PVOID v4; // esi@7
  HANDLE v5; // eax@12
  HANDLE Handle; // [sp+Ch] [bp-8h]@1
  int v7; // [sp+10h] [bp-4h]@1

  v7 = 0;
  Handle = 0;
  v2 = BaseRegGetUserAndMachineClass(0, KeyHandle, 0x2000000, (int)&Handle, (int)&v7);
  if ( v2 < 0 )
    return v2;
  if ( !v7 || !Handle )
  {
    *(_DWORD *)a1 = 0;
    return 0;
  }
  v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x20u);
  if ( v4 )
  {
    memset(v4, 0, 0x1Cu);
    *((_DWORD *)v4 + 1) = v7;
    v5 = Handle;
    *((_DWORD *)v4 + 5) |= 1u;
    *((_DWORD *)v4 + 2) = v5;
    *(_DWORD *)v4 = KeyHandle;
    v2 = ValStateUpdate((ULONG)v4);
    if ( v2 < 0 )
      ValStateRelease(v4);
    else
      *(_DWORD *)a1 = v4;
    return v2;
  }
  if ( (HANDLE)v7 == KeyHandle )
    NtClose(Handle);
  else
    NtClose((HANDLE)v7);
  return -1073741801;
}

//----- (77E444E7) --------------------------------------------------------
BOOL __stdcall EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceTypesExW(hModule, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E44507) --------------------------------------------------------
BOOL __stdcall EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  return EnumResourceTypesInternal(
           (int)hModule,
           (int (__stdcall *)(_DWORD, _DWORD, _DWORD))lpEnumFunc,
           lParam,
           dwFlags,
           LangId,
           0);
}

//----- (77E4452B) --------------------------------------------------------
int __stdcall EnumResourceTypesInternal(int a1, int (__stdcall *a2)(_DWORD, _DWORD, _DWORD), int a3, char a4, SIZE_T pResult, char a6)
{
  int v6; // edi@1
  int v7; // ebx@1
  int v8; // esi@1
  int v9; // esi@7
  NTSTATUS v10; // eax@11
  unsigned __int32 v11; // esi@32
  void *v12; // edi@38
  int v13; // eax@48
  unsigned __int32 v14; // edi@52
  signed int v15; // ecx@60
  signed int v16; // edx@65
  int v18; // eax@91
  unsigned __int32 v19; // esi@108
  unsigned __int32 v20; // esi@114
  unsigned __int16 v21; // ax@119
  unsigned __int16 v22; // ax@124
  int v23; // esi@131
  unsigned __int32 v24; // ebx@131
  unsigned __int32 v25; // esi@134
  unsigned __int32 v26; // edi@135
  unsigned int v27; // eax@139
  PVOID v28; // ebx@151
  int v29; // esi@153
  unsigned __int32 v30; // ebx@153
  unsigned __int32 v31; // edi@157
  unsigned int v32; // eax@161
  int v33; // eax@169
  NTSTATUS v34; // eax@192
  unsigned __int16 v35; // ax@196
  unsigned __int16 v36; // ax@201
  ULONG ResultSize; // [sp+14h] [bp-90h]@1
  ULONG Flags; // [sp+18h] [bp-8Ch]@36
  ULONG v39; // [sp+1Ch] [bp-88h]@148
  int v40; // [sp+20h] [bp-84h]@74
  int v41; // [sp+24h] [bp-80h]@1
  ULONG Size; // [sp+28h] [bp-7Ch]@1
  unsigned __int32 v43; // [sp+2Ch] [bp-78h]@9
  ULONG v44; // [sp+30h] [bp-74h]@1
  unsigned __int32 v45; // [sp+34h] [bp-70h]@97
  PVOID v46; // [sp+38h] [bp-6Ch]@1
  PWCHAR UnicodeString; // [sp+3Ch] [bp-68h]@1
  int v48; // [sp+40h] [bp-64h]@4
  int v49; // [sp+44h] [bp-60h]@1
  unsigned __int32 v50; // [sp+48h] [bp-5Ch]@22
  unsigned __int32 v51; // [sp+4Ch] [bp-58h]@113
  int v52; // [sp+50h] [bp-54h]@9
  int v53; // [sp+54h] [bp-50h]@95
  PVOID v54; // [sp+58h] [bp-4Ch]@91
  unsigned int v55; // [sp+5Ch] [bp-48h]@23
  int v56; // [sp+60h] [bp-44h]@1
  unsigned __int32 v57; // [sp+64h] [bp-40h]@1
  PVOID ImageBase; // [sp+68h] [bp-3Ch]@2
  unsigned __int32 v59; // [sp+6Ch] [bp-38h]@1
  PVOID Address; // [sp+70h] [bp-34h]@1
  int v61; // [sp+74h] [bp-30h]@41
  ULONG v62; // [sp+78h] [bp-2Ch]@9
  void *Dst; // [sp+7Ch] [bp-28h]@1
  unsigned int v64; // [sp+80h] [bp-24h]@1
  NTSTATUS NtStatus; // [sp+84h] [bp-20h]@175
  int v66; // [sp+88h] [bp-1Ch]@19
  CPPEH_RECORD ms_exc; // [sp+8Ch] [bp-18h]@19

  v6 = 0;
  v59 = 0;
  v57 = 0;
  Address = 0;
  Dst = 0;
  UnicodeString = 0;
  v46 = 0;
  ResultSize = 0;
  v44 = 0;
  Size = 0;
  v7 = 0;
  v8 = ((unsigned int)a4 >> 3) & 1;
  v64 = ((unsigned int)a4 >> 3) & 1;
  v49 = 0;
  v56 = 0;
  v41 = ~(unsigned __int8)((unsigned int)a4 >> 4) & 1;
  if ( !CheckEnumFlags((int)&a4, 0) )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  ImageBase = BasepMapModuleHandle((void *)a1, 1);
  if ( v41 )
    GetRcConfig((int)ImageBase, v8, (int)&v49);
  v48 = a4 & 2;
  if ( a4 & 2 )
  {
    if ( v49
      && *(_BYTE *)(v49 + 16) & 1
      && (!(_WORD)pResult ? (v18 = LdrLoadAlternateResourceModule(ImageBase, &v54)) : (v18 = LdrLoadAlternateResourceModuleEx(
                                                                                               ImageBase,
                                                                                               pResult,
                                                                                               &v54,
                                                                                               0,
                                                                                               128)),
          v18 >= 0) )
    {
      if ( v8 && LdrpResGetMappingSize(v54, &v53, 256, 1) < 0 )
        v53 = 0;
      v6 = GetResourceDirectory(v54, v53, a4, &v62, (int)&v45);
      if ( v6 >= 0 )
        v57 = v45;
    }
    else
    {
      v6 = -1073020927;
    }
  }
  v9 = a4 & 1;
  if ( a4 & 1 )
  {
    if ( v64 && LdrpResGetMappingSize(ImageBase, &v52, 256, 0) < 0 )
      v52 = 0;
    v7 = GetResourceDirectory(ImageBase, v52, a4, &v62, (int)&v43);
    if ( v7 >= 0 )
      v59 = v43;
  }
  v10 = 0;
  if ( v9 && (v48 && v6 < 0 && v7 < 0 || v9 && ~a4 & 2 && v7 < 0) )
    v10 = v7;
  if ( ~a4 & 1 && v48 && v6 < 0 )
    v10 = v6;
  if ( v10 < 0 )
  {
    BaseSetLastNTError(v10);
    return 0;
  }
  v66 = 1;
  ms_exc.registration.TryLevel = 1;
  if ( v57 )
  {
    if ( v64 )
    {
      v19 = v57;
      if ( ULongAdd(v57, 0x10u, &pResult) < 0
        || v19 + 16 < ((unsigned int)v54 & 0xFFFFFFFC)
        || v19 + 16 > v53 + ((unsigned int)v54 & 0xFFFFFFFC) )
        goto LABEL_111;
    }
    v51 = v57 + 16;
  }
  if ( v59 )
  {
    if ( v64 )
    {
      v20 = v59;
      if ( ULongAdd(v59, 0x10u, &pResult) < 0
        || v20 + 16 < ((unsigned int)ImageBase & 0xFFFFFFFC)
        || v20 + 16 > v52 + ((unsigned int)ImageBase & 0xFFFFFFFC) )
      {
LABEL_111:
        BaseSetLastNTError(-1073741701);
        goto LABEL_112;
      }
    }
    v50 = v59 + 16;
  }
  v62 = 0;
  v55 = 0;
  if ( v64 )
  {
    if ( v57 )
    {
      v21 = *(_WORD *)(v57 + 12);
      if ( v21 )
      {
        if ( SIZETMult(v21, 8u, &pResult) < 0
          || pResult + v57 < ((unsigned int)v54 & 0xFFFFFFFC)
          || pResult + v57 > v53 + ((unsigned int)v54 & 0xFFFFFFFC) )
          goto LABEL_111;
      }
    }
    if ( v59 )
    {
      v22 = *(_WORD *)(v59 + 12);
      if ( v22 )
      {
        if ( SIZETMult(v22, 8u, &pResult) < 0
          || pResult + v59 < ((unsigned int)ImageBase & 0xFFFFFFFC)
          || pResult + v59 > v52 + ((unsigned int)ImageBase & 0xFFFFFFFC) )
          goto LABEL_111;
      }
    }
  }
  while ( 1 )
  {
    if ( (!v57 || v62 >= *(_WORD *)(v57 + 12)) && (!v59 || v55 >= *(_WORD *)(v59 + 12)) )
    {
LABEL_79:
      if ( !v66 )
        goto LABEL_80;
      v62 = 0;
      v55 = 0;
      if ( v64 )
      {
        if ( v57 )
        {
          v35 = *(_WORD *)(v57 + 14);
          if ( v35 )
          {
            if ( SIZETMult(v35, 8u, &pResult) < 0
              || v57 + pResult < ((unsigned int)v54 & 0xFFFFFFFC)
              || v57 + pResult > v53 + ((unsigned int)v54 & 0xFFFFFFFC) )
              goto LABEL_111;
          }
        }
        if ( v59 )
        {
          v36 = *(_WORD *)(v59 + 14);
          if ( v36 )
          {
            if ( SIZETMult(v36, 8u, &pResult) < 0
              || v59 + pResult < ((unsigned int)ImageBase & 0xFFFFFFFC)
              || v59 + pResult > v52 + ((unsigned int)ImageBase & 0xFFFFFFFC) )
              goto LABEL_111;
          }
        }
      }
      v14 = v59;
      while ( 1 )
      {
        if ( (!v57 || v62 >= *(_WORD *)(v57 + 14)) && (!v14 || v55 >= *(_WORD *)(v14 + 14)) )
          goto LABEL_80;
        if ( v57 && v62 < *(_WORD *)(v57 + 14) )
          v16 = *(_WORD *)v51;
        else
          v16 = -1;
        if ( v14 && v55 < *(_WORD *)(v14 + 14) )
          v15 = *(_WORD *)v50;
        else
          v15 = -1;
        if ( v16 != -1 )
        {
          if ( v15 != -1 )
          {
            v61 = 1;
            if ( v16 - v15 <= 0 )
            {
              if ( v16 == v15 )
                v61 = 3;
              goto LABEL_72;
            }
            goto LABEL_71;
          }
          if ( v16 != -1 )
          {
            v61 = 1;
            goto LABEL_72;
          }
        }
        if ( v15 == -1 )
          goto LABEL_80;
LABEL_71:
        v61 = 2;
LABEL_72:
        if ( v61 & 1 )
        {
          v40 = v16;
          v51 += 8;
          ++v62;
        }
        if ( v61 & 2 )
        {
          v40 = v15;
          v50 += 8;
          ++v55;
        }
        if ( !v41 || !v49 )
          goto LABEL_77;
        v56 = 0;
        NtStatus = LdrRscIsTypeExist(v49, v40, 0, &v56);
        if ( NtStatus >= 0 )
        {
          if ( v56 & 0x40000 && v56 & 0x20000 || v56 & 0x40000 && !(a4 & 6) )
          {
            NtStatus = -1073020925;
            goto LABEL_227;
          }
          if ( v56 & 0x20000 && !(a4 & 1) )
            NtStatus = -1073020925;
          if ( NtStatus >= 0 )
          {
LABEL_77:
            if ( !_ResourceCallEnumTypeRoutine(a2, a1, v40, a3) )
            {
              BaseSetLastNTError(-1073020921);
              goto LABEL_178;
            }
          }
          else
          {
LABEL_227:
            if ( v64 )
              goto LABEL_189;
            NtStatus = 0;
          }
        }
        else if ( v64 )
        {
          NtStatus = -1073020925;
          goto LABEL_178;
        }
      }
    }
    if ( v57 && v62 < *(_WORD *)(v57 + 12) )
      break;
    if ( Address )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      Address = 0;
    }
LABEL_29:
    if ( v59 && v55 < *(_WORD *)(v59 + 12) )
    {
      if ( v64 )
      {
        v29 = *(_DWORD *)v50 & 0x7FFFFFFF;
        v30 = v43;
        if ( ULongAdd(v43, v29, &pResult) < 0
          || v29 + v30 < ((unsigned int)ImageBase & 0xFFFFFFFC)
          || v29 + v30 > v52 + ((unsigned int)ImageBase & 0xFFFFFFFC) )
          goto LABEL_111;
      }
      v11 = v43 + (*(_DWORD *)v50 & 0x7FFFFFFF);
      v48 = v43 + (*(_DWORD *)v50 & 0x7FFFFFFF);
      if ( v64 )
      {
        v31 = *(_WORD *)v11;
        if ( ULongAdd(v31, 1u, &pResult) < 0 )
          goto LABEL_141;
        if ( SIZETMult(pResult, 2u, &pResult) < 0 )
          goto LABEL_141;
        if ( v31 + v62 < (v62 & 0xFFFFFFFC) )
          goto LABEL_141;
        if ( v31 + v62 > (v62 & 0xFFFFFFFC) + 260 )
          goto LABEL_141;
        v32 = v11 + pResult + 2;
        if ( v32 < ((unsigned int)ImageBase & 0xFFFFFFFC) || v32 > v52 + ((unsigned int)ImageBase & 0xFFFFFFFC) )
          goto LABEL_141;
      }
      if ( 2 * (unsigned int)*(_WORD *)v11 + 2 >= Size )
      {
        if ( Dst )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
          Dst = 0;
          v11 = v48;
        }
        if ( v64 && ULongAdd(pResult, 0x40u, &pResult) < 0 )
          goto LABEL_141;
        Size = (2 * *(_WORD *)v11 + 64) & 0xFFFFFFC0;
        Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        Dst = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, Size);
        if ( !Dst )
          goto LABEL_149;
        v11 = v48;
      }
      v12 = Dst;
      memcpy(Dst, (const void *)(v11 + 2), 2 * *(_WORD *)v11);
      *((_WORD *)v12 + *(_WORD *)v11) = 0;
    }
    else if ( Dst )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
      Dst = 0;
    }
    if ( Address )
    {
      if ( Dst )
      {
        v61 = 1;
        v33 = wcscmp((const unsigned __int16 *)Address, (const unsigned __int16 *)Dst);
        if ( v33 <= 0 )
        {
          if ( !v33 )
            v61 = 3;
          goto LABEL_42;
        }
        goto LABEL_41;
      }
      if ( Address )
      {
        v61 = 1;
        goto LABEL_42;
      }
    }
    if ( !Dst )
      goto LABEL_79;
LABEL_41:
    v61 = 2;
LABEL_42:
    if ( v61 & 1 )
    {
      UnicodeString = (PWCHAR)Address;
      v51 += 8;
      ++v62;
    }
    if ( v61 & 2 )
    {
      UnicodeString = (PWCHAR)Dst;
      v50 += 8;
      ++v55;
    }
    if ( !v41 || !v49 )
      goto LABEL_47;
    v56 = 0;
    NtStatus = LdrRscIsTypeExist(v49, UnicodeString, 0, &v56);
    if ( NtStatus >= 0 )
    {
      if ( v56 & 0x40000 && v56 & 0x20000 || v56 & 0x40000 && !(a4 & 6) )
      {
        NtStatus = -1073020925;
        goto LABEL_188;
      }
      if ( v56 & 0x20000 && !(a4 & 1) )
        NtStatus = -1073020925;
      if ( NtStatus >= 0 )
      {
LABEL_47:
        if ( a6 & 1 )
        {
          v34 = ConverStringWithHeapAlloc(UnicodeString, (int)&v46, (ULONG)&ResultSize);
          NtStatus = v34;
          if ( v34 < 0 )
          {
            BaseSetLastNTError(v34);
            goto LABEL_112;
          }
          v13 = _ResourceCallEnumTypeRoutine(a2, a1, (int)v46, a3);
        }
        else
        {
          v13 = _ResourceCallEnumTypeRoutine(a2, a1, (int)UnicodeString, a3);
        }
        if ( !v13 )
        {
          BaseSetLastNTError(-1073020921);
LABEL_112:
          v66 = 0;
          goto LABEL_80;
        }
      }
      else
      {
LABEL_188:
        if ( v64 )
        {
LABEL_189:
          BaseSetLastNTError(NtStatus);
          goto LABEL_178;
        }
        NtStatus = 0;
      }
    }
    else if ( v64 )
    {
      NtStatus = -1073020925;
LABEL_178:
      v66 = 0;
      goto LABEL_80;
    }
  }
  if ( v64 )
  {
    v23 = *(_DWORD *)v51 & 0x7FFFFFFF;
    v24 = v45;
    if ( ULongAdd(v45, v23, &pResult) < 0
      || v23 + v24 < ((unsigned int)v54 & 0xFFFFFFFC)
      || v23 + v24 > v53 + ((unsigned int)v54 & 0xFFFFFFFC) )
      goto LABEL_111;
  }
  v25 = v45 + (*(_DWORD *)v51 & 0x7FFFFFFF);
  v48 = v45 + (*(_DWORD *)v51 & 0x7FFFFFFF);
  if ( v64 )
  {
    v26 = *(_WORD *)v25;
    if ( ULongAdd(v26, 1u, &pResult) < 0 )
      goto LABEL_141;
    if ( SIZETMult(pResult, 2u, &pResult) < 0 )
      goto LABEL_141;
    if ( v26 + v62 < (v62 & 0xFFFFFFFC) )
      goto LABEL_141;
    if ( v26 + v62 > (v62 & 0xFFFFFFFC) + 260 )
      goto LABEL_141;
    v27 = v25 + pResult + 2;
    if ( v27 < ((unsigned int)v54 & 0xFFFFFFFC) || v27 > v53 + ((unsigned int)v54 & 0xFFFFFFFC) )
      goto LABEL_141;
  }
  if ( 2 * (unsigned int)*(_WORD *)v25 + 2 < v44 )
    goto LABEL_151;
  if ( Address )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    Address = 0;
    v25 = v48;
  }
  if ( v64 && ULongAdd(pResult, 0x40u, &pResult) < 0 )
  {
LABEL_141:
    BaseSetLastNTError(-1073741701);
    goto LABEL_142;
  }
  v44 = (2 * *(_WORD *)v25 + 64) & 0xFFFFFFC0;
  v39 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v39, v44);
  if ( Address )
  {
    v25 = v48;
LABEL_151:
    v28 = Address;
    memcpy(Address, (const void *)(v25 + 2), 2 * *(_WORD *)v25);
    *((_WORD *)v28 + *(_WORD *)v25) = 0;
    goto LABEL_29;
  }
LABEL_149:
  BaseSetLastNTError(-1073741801);
LABEL_142:
  v66 = 0;
LABEL_80:
  ms_exc.registration.TryLevel = 0;
  if ( Address )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    Address = 0;
  }
  if ( Dst )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
    Dst = 0;
  }
  if ( v46 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v46);
    v46 = 0;
  }
  ms_exc.registration.TryLevel = -2;
  return v66;
}
// 77DE12DC: using guessed type int __stdcall LdrLoadAlternateResourceModuleEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E0: using guessed type int __stdcall LdrLoadAlternateResourceModule(_DWORD, _DWORD);
// 77DE12E4: using guessed type int __stdcall LdrpResGetMappingSize(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE12E8: using guessed type int __stdcall LdrRscIsTypeExist(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E44962) --------------------------------------------------------
int __stdcall WerpGetHeaderFromProcess(HANDLE hProcess, struct _WER_PEB_HEADER_BLOCK *lpBuffer)
{
  HANDLE v2; // eax@3
  signed int v3; // esi@7
  LPCVOID v4; // eax@8
  int v5; // ecx@9
  int result; // eax@11
  int v7; // esi@25
  char v8; // [sp+Ch] [bp-81Ch]@1
  char v9; // [sp+Dh] [bp-81Bh]@1
  const void *v10; // [sp+364h] [bp-4C4h]@20
  int v11; // [sp+368h] [bp-4C0h]@20
  _BYTE Buffer[328]; // [sp+38Ch] [bp-49Ch]@1
  LPCVOID lpBaseAddress; // [sp+5BCh] [bp-26Ch]@8
  char v14; // [sp+5D4h] [bp-254h]@1
  char Dst; // [sp+5D5h] [bp-253h]@1
  const void *v16; // [sp+804h] [bp-24h]@22
  int v17; // [sp+81Ch] [bp-Ch]@1
  BOOL v18; // [sp+820h] [bp-8h]@1
  BOOL Wow64Process; // [sp+824h] [bp-4h]@1

  Buffer[0] = 0;
  memset(&Buffer[1], 0, 0x247u);
  v14 = 0;
  memset(&Dst, 0, 0x247u);
  v8 = 0;
  memset(&v9, 0, 0x37Fu);
  v18 = 0;
  v17 = 0;
  Wow64Process = 0;
  if ( !hProcess || !lpBuffer )
  {
    DbgPrintOut(0, "Invalid arguments");
    return -2147024809;
  }
  v2 = GetCurrentProcess();
  if ( !IsWow64Process(v2, &Wow64Process) )
    Wow64Process = 0;
  if ( Wow64Process )
  {
    if ( !IsWow64Process(hProcess, &v18) )
      v18 = 0;
    v17 = v18 == 0;
  }
  if ( v18 )
  {
    result = WerpGetPeb32FromProcess(hProcess, (struct _PEB32 *)&v14);
    if ( result < 0 )
      return result;
    v4 = v16;
LABEL_9:
    v5 = 0;
    goto LABEL_10;
  }
  if ( !Wow64Process || !v17 )
  {
    v3 = WerpGetPebFromProcess(hProcess, (struct _PEB *)Buffer);
    if ( v3 < 0 )
    {
LABEL_19:
      DbgPrintOut(0, "Failed to read the peb from the process");
      return v3;
    }
    v4 = lpBaseAddress;
    goto LABEL_9;
  }
  v3 = WerpGetPeb64FromProcess(hProcess, (struct _PEB64 *)&v8);
  if ( v3 < 0 )
    goto LABEL_19;
  v4 = v10;
  v5 = v11;
LABEL_10:
  if ( !(v5 | (unsigned int)v4) )
    return -2147023728;
  if ( Wow64Process && v17 )
  {
    v7 = WerpNtWow64ReadVirtualMemory64(hProcess, __PAIR__(v5, (unsigned int)v4), (void *)lpBuffer, 0x8D0ui64, 0);
    if ( (v7 & 0xC0000000) == -1073741824 )
    {
      DbgPrintOut(0, "WerpNtWow64ReadVirtualMemory64 failed while trying to read PebBaseAddress");
      return v7 | 0x10000000;
    }
    goto LABEL_30;
  }
  if ( ReadProcessMemory(hProcess, v4, (LPVOID)lpBuffer, 0x8D0u, 0) )
  {
LABEL_30:
    if ( WerpValidatePebHeader(lpBuffer) >= 0 )
    {
      result = 0;
      *((_WORD *)lpBuffer + 1043) = 0;
    }
    else
    {
      DbgPrintOut(0, "WerpValidatePebHeader failed");
      result = -2147467259;
    }
    return result;
  }
  DbgPrintOut(0, "ReadProcessMemory failed while trying to read PebBaseAddress");
  result = GetLastError();
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (77E44A43) --------------------------------------------------------
signed int __stdcall WerpGetPebFromProcess(HANDLE ProcessHandle, struct _PEB *lpBuffer)
{
  signed int result; // eax@6
  char ProcessInformation; // [sp+4h] [bp-18h]@3
  LPCVOID lpBaseAddress; // [sp+8h] [bp-14h]@4

  if ( ProcessHandle && lpBuffer )
  {
    if ( NtQueryInformationProcess(ProcessHandle, 0, &ProcessInformation, 0x18u, 0) < 0 )
    {
      DbgPrintOut(0, "NtQueryInformationProcess failed");
      result = -2147024890;
    }
    else if ( lpBaseAddress )
    {
      if ( ReadProcessMemory(ProcessHandle, lpBaseAddress, lpBuffer, 0x248u, 0) )
      {
        result = 0;
      }
      else
      {
        DbgPrintOut(0, "ReadProcessMemory failed while trying to read PebBaseAddress");
        result = GetLastError();
        if ( result > 0 )
          result = (unsigned __int16)result | 0x80070000;
      }
    }
    else
    {
      DbgPrintOut(0, "No PEB for process");
      result = -2147467259;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid arg");
    result = -2147024809;
  }
  return result;
}

//----- (77E44AAA) --------------------------------------------------------
void __stdcall __noreturn DefaultHandler(int a1)
{
  RtlExitUserProcess(-1073741510);
  __debugbreak();
  JUMPOUT(*(_DWORD *)byte_77E44AB6);
}
// 77DE1710: using guessed type int __stdcall RtlExitUserProcess(_DWORD);

//----- (77E44ABB) --------------------------------------------------------
signed int __stdcall CtrlRoutine(int a1)
{
  int v1; // esi@1
  SIZE_T i; // eax@4
  int v3; // edi@6
  int v4; // eax@26
  EXCEPTION_RECORD ExceptionRecord; // [sp+10h] [bp-70h]@20
  int v7; // [sp+60h] [bp-20h]@3
  SIZE_T v8; // [sp+64h] [bp-1Ch]@5
  CPPEH_RECORD ms_exc; // [sp+68h] [bp-18h]@3

  SetThreadPriority((HANDLE)0xFFFFFFFE, 2);
  v1 = a1 & 0x7FFFFFFF;
  if ( (a1 & 0x7FFFFFFFu) <= 1 )
    goto LABEL_19;
  if ( v1 == 2 )
    goto LABEL_3;
  if ( v1 == 3 )
  {
LABEL_17:
    if ( !LastConsoleEventActive )
    {
      while ( 1 )
      {
        RtlExitUserThread(0);
LABEL_19:
        if ( !NtCurrentTeb()->ProcessEnvironmentBlock->BeingDebugged )
          break;
        ExceptionRecord.ExceptionCode = v1 != 0 ? 1073807368 : 1073807365;
        v1 = 0;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionRecord = 0;
        ExceptionRecord.ExceptionAddress = DefaultHandler;
        ExceptionRecord.NumberParameters = 0;
        ms_exc.registration.TryLevel = 0;
        RtlRaiseException(&ExceptionRecord);
        ms_exc.registration.TryLevel = -2;
      }
    }
    goto LABEL_3;
  }
  if ( v1 == 4 )
  {
    RtlExitUserProcess(-1073741510);
    goto LABEL_17;
  }
  if ( ((unsigned int)v1 <= 4 || (unsigned int)v1 > 6) && (unsigned int)v1 >= 7 )
    return -1073741823;
LABEL_3:
  RtlEnterCriticalSection(&DllLock);
  v7 = 0;
  ms_exc.registration.TryLevel = 2;
  if ( v1 || !((unsigned int)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[1] & 1) )
  {
    for ( i = HandlerListLength; ; i = v3 )
    {
      v8 = i;
      if ( !i )
        break;
      v3 = i - 1;
      if ( i == 1 && a1 & 0x80000000 && (v1 == 5 || v1 == 6) )
        break;
      v4 = RtlDecodePointer(*((_DWORD *)HandlerList + i - 1));
      if ( ((int (__stdcall *)(int))v4)(v1) )
      {
        if ( (unsigned int)v1 >= 2 && ((unsigned int)v1 <= 3 || (unsigned int)v1 > 4 && (unsigned int)v1 <= 6) )
          v7 = v1;
        break;
      }
    }
  }
  ms_exc.registration.TryLevel = -2;
  RtlLeaveCriticalSection(&DllLock);
  return v7;
}
// 77DE1668: using guessed type int __stdcall RtlDecodePointer(_DWORD);
// 77DE170C: using guessed type int __stdcall RtlExitUserThread(_DWORD);
// 77DE1710: using guessed type int __stdcall RtlExitUserProcess(_DWORD);
// 77EA6FEC: using guessed type int LastConsoleEventActive;

//----- (77E44B89) --------------------------------------------------------
HRESULT __stdcall GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
{
  return WerpGetRestartCommandLine(hProcess, pwzCommandline, pcchSize, pdwFlags);
}

//----- (77E44B96) --------------------------------------------------------
int __stdcall WerpGetRestartCommandLine(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
{
  int result; // eax@4
  unsigned int v5; // kr00_4@13
  DWORD v6; // ebx@13
  signed int v7; // eax@16
  char Dst; // [sp+10h] [bp-8D4h]@1
  DWORD v9; // [sp+30h] [bp-8B4h]@12
  int v10; // [sp+34h] [bp-8B0h]@9
  unsigned __int16 v11; // [sp+38h] [bp-8ACh]@13

  memset(&Dst, 0, 0x8D0u);
  if ( !pcchSize )
    goto LABEL_7;
  if ( !pwzCommandline )
  {
    if ( !*pcchSize )
      goto LABEL_4;
LABEL_7:
    DbgPrintOut(0, " Invalid arg in %s", "WerpGetRestartCommandLine");
    return -2147024809;
  }
  *pwzCommandline = 0;
LABEL_4:
  result = WerpGetHeaderFromProcess(hProcess, (struct _WER_PEB_HEADER_BLOCK *)&Dst);
  if ( result < 0 )
    return result;
  if ( !v10 )
  {
    *pcchSize = 0;
    return -2147023728;
  }
  if ( pdwFlags )
    *pdwFlags = v9;
  v5 = wcslen(&v11);
  v6 = v5 + 1;
  if ( *pcchSize < v5 + 1 )
  {
    *pcchSize = v6;
    return pwzCommandline != 0 ? 0x8007007A : 0;
  }
  if ( !v5 )
  {
    *pwzCommandline = 0;
    goto LABEL_19;
  }
  v7 = StringCchCopyW(pwzCommandline, *pcchSize, &v11);
  if ( v7 >= 0 )
  {
LABEL_19:
    *pcchSize = v6;
    return 0;
  }
  DbgPrintOut(0, "StringCchCopy failed with 0x%x", v7);
  return -2147467259;
}

//----- (77E44C1C) --------------------------------------------------------
BOOLEAN __stdcall BasepFreePrefixAlias(PVOID Address)
{
  int v1; // eax@1
  int v2; // ecx@1

  BasePrefixLastHint = 0;
  v1 = *(_DWORD *)Address;
  v2 = *((_DWORD *)Address + 1);
  *(_DWORD *)v2 = *(_DWORD *)Address;
  *(_DWORD *)(v1 + 4) = v2;
  if ( (int *)BasePrefixList == &BasePrefixList )
    BaseUsePrivateNamespaces = 0;
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)Address + 3));
  return RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}
// 77EA62D8: using guessed type int BasePrefixList;
// 77EA652C: using guessed type int BasePrefixLastHint;
// 77EA6530: using guessed type char BaseUsePrivateNamespaces;

//----- (77E45426) --------------------------------------------------------
int __fastcall NlsCompareRgWChar(int a1, int a2, int a3)
{
  int result; // eax@2

  while ( a3 > 0 )
  {
    result = *(_WORD *)a1 - *(_WORD *)a2;
    if ( *(_WORD *)a1 != *(_WORD *)a2 )
      return result;
    a1 += 2;
    a2 += 2;
    --a3;
  }
  return 0;
}

//----- (77E455CD) --------------------------------------------------------
BOOL __stdcall ReadFileExStub(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
  return ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
}

//----- (77E455E5) --------------------------------------------------------
BOOL __stdcall WriteFileExStub(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
{
  return WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
}

//----- (77E45609) --------------------------------------------------------
char __stdcall SkipUnsortable(int *a1, int a2)
{
  bool v2; // zf@10
  int v3; // esi@1
  int v4; // eax@1
  int *v5; // edx@2
  signed __int16 v6; // bx@2
  int v7; // edi@3
  unsigned __int16 *v8; // ecx@3
  unsigned int v9; // eax@3
  unsigned int v10; // eax@4
  int v11; // edx@18
  unsigned int v12; // eax@18
  int v13; // edi@23
  unsigned int v14; // edx@24
  int v15; // ecx@26
  int v16; // edi@28
  int v17; // ecx@28
  int v18; // eax@29
  int v19; // edx@29
  int v20; // ecx@32
  int v21; // edi@37
  int v22; // eax@37
  int v23; // eax@42
  unsigned __int16 *v24; // edi@43
  unsigned int v25; // edx@43
  int v26; // ecx@47
  int v27; // edi@49
  int v28; // ecx@49
  int v29; // eax@50
  int v30; // edx@50
  int v31; // ecx@55
  int v32; // edi@60
  int v33; // eax@60
  int v34; // eax@65
  unsigned __int16 *v35; // edi@66
  unsigned int v36; // edx@66
  int v37; // ecx@70
  int v38; // edi@72
  int v39; // ecx@72
  int v40; // eax@73
  int v41; // edx@73
  int v42; // ecx@78
  int v43; // edi@83
  int v44; // eax@83
  int v45; // eax@88
  unsigned __int16 *v46; // edi@89
  unsigned int v47; // edx@89
  int v48; // ecx@93
  int v49; // edi@95
  int v50; // ecx@95
  int v51; // eax@96
  int v52; // edx@96
  int v53; // ecx@101
  int v54; // edi@106
  int v55; // eax@106
  int v56; // eax@111
  unsigned __int16 *v57; // edi@112
  unsigned int v58; // edx@112
  int v59; // ecx@116
  int v60; // edi@118
  int v61; // ecx@118
  int v62; // edx@119
  int v63; // eax@119
  int v64; // edx@124
  int v65; // edi@129
  int v66; // eax@129
  int v67; // eax@134
  unsigned __int16 *v68; // edi@135
  unsigned int v69; // edx@135
  int v70; // ecx@139
  int v71; // edi@141
  int v72; // ecx@141
  int v73; // edx@142
  int v74; // eax@142
  int v75; // edx@147
  int v76; // edi@152
  int v77; // eax@152
  unsigned __int16 *v78; // edi@158
  unsigned int v79; // edx@158
  int v80; // ecx@162
  int v81; // edi@164
  int v82; // ecx@164
  int v83; // edx@165
  int v84; // eax@165
  unsigned int v85; // ecx@170
  int v86; // edx@170
  int v87; // edi@175
  int v88; // eax@175
  unsigned __int16 *v90; // [sp+4h] [bp-24h]@17
  unsigned __int16 *v91; // [sp+8h] [bp-20h]@20
  unsigned __int16 *v92; // [sp+Ch] [bp-1Ch]@17
  int v93; // [sp+10h] [bp-18h]@111
  int v94; // [sp+10h] [bp-18h]@146
  int v95; // [sp+10h] [bp-18h]@157
  int v96; // [sp+14h] [bp-14h]@23
  int v97; // [sp+14h] [bp-14h]@123
  int v98; // [sp+14h] [bp-14h]@134
  int v99; // [sp+18h] [bp-10h]@42
  int v100; // [sp+18h] [bp-10h]@65
  int v101; // [sp+18h] [bp-10h]@88
  signed int v102; // [sp+18h] [bp-10h]@116
  int v103; // [sp+18h] [bp-10h]@139
  int v104; // [sp+18h] [bp-10h]@162
  signed int v105; // [sp+1Ch] [bp-Ch]@26
  int v106; // [sp+1Ch] [bp-Ch]@47
  int v107; // [sp+1Ch] [bp-Ch]@70
  int v108; // [sp+1Ch] [bp-Ch]@93
  int v109; // [sp+1Ch] [bp-Ch]@116
  signed int v110; // [sp+1Ch] [bp-Ch]@139
  signed int v111; // [sp+1Ch] [bp-Ch]@162
  int v112; // [sp+20h] [bp-8h]@26
  signed int v113; // [sp+20h] [bp-8h]@47
  signed int v114; // [sp+20h] [bp-8h]@70
  signed int v115; // [sp+20h] [bp-8h]@93
  int v116; // [sp+24h] [bp-4h]@24
  int v117; // [sp+24h] [bp-4h]@26
  int v118; // [sp+24h] [bp-4h]@43
  int v119; // [sp+24h] [bp-4h]@47
  int v120; // [sp+24h] [bp-4h]@66
  int v121; // [sp+24h] [bp-4h]@70
  int v122; // [sp+24h] [bp-4h]@89
  int v123; // [sp+24h] [bp-4h]@93
  int v124; // [sp+24h] [bp-4h]@112
  int v125; // [sp+24h] [bp-4h]@116
  int v126; // [sp+24h] [bp-4h]@135
  int v127; // [sp+24h] [bp-4h]@139
  int v128; // [sp+24h] [bp-4h]@158
  int v129; // [sp+24h] [bp-4h]@162
  int v130; // [sp+34h] [bp+Ch]@20
  int v131; // [sp+34h] [bp+Ch]@169

  v3 = a2;
  v4 = *(_DWORD *)(a2 + 16);
  if ( (unsigned int)v4 < *(_DWORD *)(a2 + 4) )
  {
    v5 = a1;
    v6 = 255;
    while ( 1 )
    {
      v7 = *(_DWORD *)(*v5 + 224);
      v8 = *(unsigned __int16 **)(v3 + 16);
      v9 = *v8;
      if ( v7 )
      {
        v10 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * (*(_DWORD *)(v7 + 4 * (v9 >> 8)) + (unsigned __int8)v9));
        v5 = a1;
      }
      else
      {
        v10 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v9);
      }
      v4 = v10 >> 8;
      if ( (_BYTE)v4 )
        break;
      if ( v5[9] )
      {
        v2 = *v8 == 0;
LABEL_12:
        if ( v2 )
          return v4;
      }
LABEL_189:
      *(_DWORD *)(v3 + 16) += 2;
      v4 = *(_DWORD *)(v3 + 16);
      if ( (unsigned int)v4 >= *(_DWORD *)(v3 + 4) )
        return v4;
    }
    if ( (_BYTE)v4 == 1 )
    {
      if ( !v5[3] && !v5[6] )
        return v4;
      v4 = *v5;
      v90 = *(unsigned __int16 **)(v3 + 16);
      v92 = *(unsigned __int16 **)(v3 + 16);
      if ( !*(_DWORD *)(*v5 + 232) )
        goto LABEL_185;
      *(_WORD *)(v3 + 30) = *v8;
      v11 = *(_DWORD *)(*v5 + 224);
      v12 = *v8;
      if ( v11 )
        v12 = *(_DWORD *)(v11 + 4 * (v12 >> 8)) + (unsigned __int8)v12;
      *(_DWORD *)(v3 + 24) = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v12);
      v91 = v8;
      v130 = 0;
      if ( (unsigned __int8)(*(_BYTE *)(v3 + 27) & ((unsigned __int8)(*(_BYTE *)(v3 + 25) - 3) != 0 ? v6 : 0) & 0xC0) != 64 )
      {
        if ( (unsigned __int8)(*(_BYTE *)(v3 + 27) & ((unsigned __int8)(*(_BYTE *)(v3 + 25) - 3) != 0 ? v6 : 0) & 0xC0) != 128 )
        {
          LOBYTE(v4) = (*(_BYTE *)(v3 + 27) & ((unsigned __int8)(*(_BYTE *)(v3 + 25) - 3) != 0 ? v6 : 0) & 0xC0) + 64;
          if ( (unsigned __int8)(*(_BYTE *)(v3 + 27) & ((unsigned __int8)(*(_BYTE *)(v3 + 25) - 3) != 0 ? v6 : 0) & 0xC0) != 192 )
            goto LABEL_184;
          v13 = *a1;
          v96 = *(_DWORD *)(*a1 + 272);
          if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 20) )
          {
            v116 = *(_DWORD *)(v13 + 236);
            v14 = *(_DWORD *)(v3 + 4);
            if ( (unsigned int)&v8[8 - (v116 == 0)] <= v14 )
            {
              v130 = NlsCountOfWCharsWithinRange(
                       v8,
                       v14,
                       8,
                       *(_WORD *)(*(_DWORD *)(v13 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v13 + 244) + 6),
                       v116,
                       *(_DWORD *)(v3 + 8));
              if ( v130 >= 8 )
              {
                v15 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 20) - 1;
                v105 = 0;
                v112 = 0;
                v117 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 20) - 1;
                if ( *(_DWORD *)(*a1 + 236) && v130 >= 9 )
                {
                  v16 = *(_DWORD *)(*a1 + 224);
                  v17 = *(_DWORD *)(v3 + 16);
                  if ( v16 )
                  {
                    v18 = *(_DWORD *)(v16 + 4 * ((unsigned int)*(_WORD *)v17 >> 8))
                        + (unsigned __int16)(v6 & *(_WORD *)v17);
                    v19 = (*pSortTblPtrs)[11];
                  }
                  else
                  {
                    v19 = (*pSortTblPtrs)[11];
                    v18 = *(_WORD *)v17;
                  }
                  v20 = v16 ? *(_DWORD *)(v19
                                        + 4
                                        * (*(_DWORD *)(v16 + 4 * ((unsigned int)*(_WORD *)(v17 + 2) >> 8))
                                         + (unsigned __int16)(v6 & *(_WORD *)(v17 + 2)))) : *(_DWORD *)(v19 + 4 * *(_WORD *)(v17 + 2));
                  v2 = ((*(_DWORD *)(v19 + 4 * v18) ^ v20) & 0xE7FFFFFF) == 0;
                  v15 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 20) - 1;
                  if ( v2 )
                    v105 = 1;
                }
                if ( v15 >= 0 )
                {
                  while ( 1 )
                  {
                    v21 = (v112 + v117) / 2;
                    v22 = NlsCompareRgWChar(2 * v105 + *(_DWORD *)(v3 + 16), v96 + 20 * v21, 8);
                    if ( !v22 )
                      break;
                    if ( v22 >= 0 )
                      v112 = v21 + 1;
                    else
                      v117 = v21 - 1;
                    if ( v112 > v117 )
                      goto LABEL_42;
                  }
                  *(_DWORD *)(v3 + 24) = *(_DWORD *)(20 * v21 + v96 + 16);
                  if ( !v105 )
                    *(_DWORD *)(v3 + 16) += 14;
LABEL_183:
                  v92 = *(unsigned __int16 **)(v3 + 16);
                  LOBYTE(v4) = (_BYTE)v91;
                  *(_DWORD *)(v3 + 16) = v91;
LABEL_184:
                  v8 = v92;
                  v5 = a1;
LABEL_185:
                  if ( v90 != v8 )
                    return v4;
                  goto LABEL_189;
                }
              }
            }
          }
LABEL_42:
          v23 = *a1;
          v99 = *(_DWORD *)(*a1 + 268);
          if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 18) )
          {
            v24 = *(unsigned __int16 **)(v3 + 16);
            v118 = *(_DWORD *)(v23 + 236);
            v25 = *(_DWORD *)(v3 + 4);
            if ( (unsigned int)&v24[7 - (v118 == 0)] <= v25 )
            {
              if ( !v130 )
                v130 = NlsCountOfWCharsWithinRange(
                         v24,
                         v25,
                         7,
                         *(_WORD *)(*(_DWORD *)(v23 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v23 + 244) + 6),
                         v118,
                         *(_DWORD *)(v3 + 8));
              if ( v130 >= 7 )
              {
                v26 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 18) - 1;
                v113 = 0;
                v106 = 0;
                v119 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 18) - 1;
                if ( *(_DWORD *)(*a1 + 236) && v130 >= 8 )
                {
                  v27 = *(_DWORD *)(*a1 + 224);
                  v28 = *(_DWORD *)(v3 + 16);
                  if ( v27 )
                  {
                    v29 = *(_DWORD *)(v27 + 4 * ((unsigned int)*(_WORD *)v28 >> 8))
                        + (unsigned __int16)(v6 & *(_WORD *)v28);
                    v30 = (*pSortTblPtrs)[11];
                  }
                  else
                  {
                    v30 = (*pSortTblPtrs)[11];
                    v29 = *(_WORD *)v28;
                  }
                  v31 = v27 ? *(_DWORD *)(v30
                                        + 4
                                        * (*(_DWORD *)(v27 + 4 * ((unsigned int)*(_WORD *)(v28 + 2) >> 8))
                                         + (unsigned __int16)(v6 & *(_WORD *)(v28 + 2)))) : *(_DWORD *)(v30 + 4 * *(_WORD *)(v28 + 2));
                  v2 = ((*(_DWORD *)(v30 + 4 * v29) ^ v31) & 0xE7FFFFFF) == 0;
                  v26 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 18) - 1;
                  if ( v2 )
                    v113 = 1;
                }
                if ( v26 >= 0 )
                {
                  while ( 1 )
                  {
                    v32 = (v106 + v119) / 2;
                    v33 = NlsCompareRgWChar(2 * v113 + *(_DWORD *)(v3 + 16), v99 + 20 * v32, 7);
                    if ( !v33 )
                      break;
                    if ( v33 >= 0 )
                      v106 = v32 + 1;
                    else
                      v119 = v32 - 1;
                    if ( v106 > v119 )
                      goto LABEL_65;
                  }
                  *(_DWORD *)(v3 + 24) = *(_DWORD *)(20 * v32 + v99 + 16);
                  if ( !v113 )
                    *(_DWORD *)(v3 + 16) += 12;
                  goto LABEL_183;
                }
              }
            }
          }
LABEL_65:
          v34 = *a1;
          v100 = *(_DWORD *)(*a1 + 264);
          if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 16) )
          {
            v35 = *(unsigned __int16 **)(v3 + 16);
            v120 = *(_DWORD *)(v34 + 236);
            v36 = *(_DWORD *)(v3 + 4);
            if ( (unsigned int)&v35[6 - (v120 == 0)] <= v36 )
            {
              if ( !v130 )
                v130 = NlsCountOfWCharsWithinRange(
                         v35,
                         v36,
                         6,
                         *(_WORD *)(*(_DWORD *)(v34 + 244) + 4),
                         *(_WORD *)(*(_DWORD *)(v34 + 244) + 6),
                         v120,
                         *(_DWORD *)(v3 + 8));
              if ( v130 >= 6 )
              {
                v37 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 16) - 1;
                v114 = 0;
                v107 = 0;
                v121 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 16) - 1;
                if ( *(_DWORD *)(*a1 + 236) && v130 >= 7 )
                {
                  v38 = *(_DWORD *)(*a1 + 224);
                  v39 = *(_DWORD *)(v3 + 16);
                  if ( v38 )
                  {
                    v40 = *(_DWORD *)(v38 + 4 * ((unsigned int)*(_WORD *)v39 >> 8))
                        + (unsigned __int16)(v6 & *(_WORD *)v39);
                    v41 = (*pSortTblPtrs)[11];
                  }
                  else
                  {
                    v41 = (*pSortTblPtrs)[11];
                    v40 = *(_WORD *)v39;
                  }
                  v42 = v38 ? *(_DWORD *)(v41
                                        + 4
                                        * (*(_DWORD *)(v38 + 4 * ((unsigned int)*(_WORD *)(v39 + 2) >> 8))
                                         + (unsigned __int16)(v6 & *(_WORD *)(v39 + 2)))) : *(_DWORD *)(v41 + 4 * *(_WORD *)(v39 + 2));
                  v2 = ((*(_DWORD *)(v41 + 4 * v40) ^ v42) & 0xE7FFFFFF) == 0;
                  v37 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 16) - 1;
                  if ( v2 )
                    v114 = 1;
                }
                if ( v37 >= 0 )
                {
                  while ( 1 )
                  {
                    v43 = (v107 + v121) / 2;
                    v44 = NlsCompareRgWChar(2 * v114 + *(_DWORD *)(v3 + 16), v100 + 16 * v43, 6);
                    if ( !v44 )
                      break;
                    if ( v44 >= 0 )
                      v107 = v43 + 1;
                    else
                      v121 = v43 - 1;
                    if ( v107 > v121 )
                      goto LABEL_88;
                  }
                  *(_DWORD *)(v3 + 24) = *(_DWORD *)(16 * v43 + v100 + 12);
                  if ( !v114 )
                    *(_DWORD *)(v3 + 16) += 10;
                  goto LABEL_183;
                }
              }
            }
          }
        }
LABEL_88:
        v45 = *a1;
        v101 = *(_DWORD *)(*a1 + 260);
        if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 14) )
        {
          v46 = *(unsigned __int16 **)(v3 + 16);
          v122 = *(_DWORD *)(v45 + 236);
          v47 = *(_DWORD *)(v3 + 4);
          if ( (unsigned int)&v46[5 - (v122 == 0)] <= v47 )
          {
            if ( !v130 )
              v130 = NlsCountOfWCharsWithinRange(
                       v46,
                       v47,
                       5,
                       *(_WORD *)(*(_DWORD *)(v45 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v45 + 244) + 6),
                       v122,
                       *(_DWORD *)(v3 + 8));
            if ( v130 >= 5 )
            {
              v48 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 14) - 1;
              v115 = 0;
              v108 = 0;
              v123 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 14) - 1;
              if ( *(_DWORD *)(*a1 + 236) && v130 >= 6 )
              {
                v49 = *(_DWORD *)(*a1 + 224);
                v50 = *(_DWORD *)(v3 + 16);
                if ( v49 )
                {
                  v51 = *(_DWORD *)(v49 + 4 * ((unsigned int)*(_WORD *)v50 >> 8))
                      + (unsigned __int16)(v6 & *(_WORD *)v50);
                  v52 = (*pSortTblPtrs)[11];
                }
                else
                {
                  v52 = (*pSortTblPtrs)[11];
                  v51 = *(_WORD *)v50;
                }
                v53 = v49 ? *(_DWORD *)(v52
                                      + 4
                                      * (*(_DWORD *)(v49 + 4 * ((unsigned int)*(_WORD *)(v50 + 2) >> 8))
                                       + (unsigned __int16)(v6 & *(_WORD *)(v50 + 2)))) : *(_DWORD *)(v52 + 4 * *(_WORD *)(v50 + 2));
                v2 = ((*(_DWORD *)(v52 + 4 * v51) ^ v53) & 0xE7FFFFFF) == 0;
                v48 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 14) - 1;
                if ( v2 )
                  v115 = 1;
              }
              if ( v48 >= 0 )
              {
                while ( 1 )
                {
                  v54 = (v108 + v123) / 2;
                  v55 = NlsCompareRgWChar(2 * v115 + *(_DWORD *)(v3 + 16), v101 + 16 * v54, 5);
                  if ( !v55 )
                    break;
                  if ( v55 >= 0 )
                    v108 = v54 + 1;
                  else
                    v123 = v54 - 1;
                  if ( v108 > v123 )
                    goto LABEL_111;
                }
                *(_DWORD *)(v3 + 24) = *(_DWORD *)(16 * v54 + v101 + 12);
                if ( !v115 )
                  *(_DWORD *)(v3 + 16) += 8;
                goto LABEL_183;
              }
            }
          }
        }
LABEL_111:
        v56 = *a1;
        v93 = *(_DWORD *)(*a1 + 256);
        if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 12) )
        {
          v57 = *(unsigned __int16 **)(v3 + 16);
          v124 = *(_DWORD *)(v56 + 236);
          v58 = *(_DWORD *)(v3 + 4);
          if ( (unsigned int)&v57[4 - (v124 == 0)] <= v58 )
          {
            if ( !v130 )
              v130 = NlsCountOfWCharsWithinRange(
                       v57,
                       v58,
                       4,
                       *(_WORD *)(*(_DWORD *)(v56 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v56 + 244) + 6),
                       v124,
                       *(_DWORD *)(v3 + 8));
            if ( v130 >= 4 )
            {
              v59 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 12) - 1;
              v102 = 0;
              v109 = 0;
              v125 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 12) - 1;
              if ( *(_DWORD *)(*a1 + 236) && v130 >= 5 )
              {
                v60 = *(_DWORD *)(*a1 + 224);
                v61 = *(_DWORD *)(v3 + 16);
                if ( v60 )
                {
                  v62 = (*pSortTblPtrs)[11];
                  v63 = *(_DWORD *)(v60 + 4 * ((unsigned int)*(_WORD *)v61 >> 8))
                      + (unsigned __int16)(v6 & *(_WORD *)v61);
                  v6 = 255;
                }
                else
                {
                  v62 = (*pSortTblPtrs)[11];
                  v63 = *(_WORD *)v61;
                }
                v97 = *(_DWORD *)(v62 + 4 * v63);
                v64 = v60 ? *(_DWORD *)(v62
                                      + 4
                                      * (*(_DWORD *)(v60 + 4 * ((unsigned int)*(_WORD *)(v61 + 2) >> 8))
                                       + (unsigned __int16)(v6 & *(_WORD *)(v61 + 2)))) : *(_DWORD *)(v62 + 4 * *(_WORD *)(v61 + 2));
                v59 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 12) - 1;
                if ( !((v97 ^ v64) & 0xE7FFFFFF) )
                  v102 = 1;
              }
              if ( v59 >= 0 )
              {
                while ( 1 )
                {
                  v65 = (v109 + v125) / 2;
                  v66 = NlsCompareRgWChar(2 * v102 + *(_DWORD *)(v3 + 16), v93 + 12 * v65, 4);
                  if ( !v66 )
                    break;
                  if ( v66 >= 0 )
                    v109 = v65 + 1;
                  else
                    v125 = v65 - 1;
                  if ( v109 > v125 )
                    goto LABEL_134;
                }
                *(_DWORD *)(v3 + 24) = *(_DWORD *)(12 * v65 + v93 + 8);
                if ( !v102 )
                  *(_DWORD *)(v3 + 16) += 6;
                goto LABEL_183;
              }
            }
          }
        }
      }
LABEL_134:
      v67 = *a1;
      v98 = *(_DWORD *)(*a1 + 252);
      if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 10) )
      {
        v68 = *(unsigned __int16 **)(v3 + 16);
        v126 = *(_DWORD *)(v67 + 236);
        v69 = *(_DWORD *)(v3 + 4);
        if ( (unsigned int)&v68[3 - (v126 == 0)] <= v69 )
        {
          if ( !v130 )
            v130 = NlsCountOfWCharsWithinRange(
                     v68,
                     v69,
                     3,
                     *(_WORD *)(*(_DWORD *)(v67 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v67 + 244) + 6),
                     v126,
                     *(_DWORD *)(v3 + 8));
          if ( v130 >= 3 )
          {
            v70 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 10) - 1;
            v110 = 0;
            v103 = 0;
            v127 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 10) - 1;
            if ( *(_DWORD *)(*a1 + 236) && v130 >= 4 )
            {
              v71 = *(_DWORD *)(*a1 + 224);
              v72 = *(_DWORD *)(v3 + 16);
              if ( v71 )
              {
                v73 = (*pSortTblPtrs)[11];
                v74 = *(_DWORD *)(v71 + 4 * ((unsigned int)*(_WORD *)v72 >> 8)) + (unsigned __int16)(v6 & *(_WORD *)v72);
                v6 = 255;
              }
              else
              {
                v73 = (*pSortTblPtrs)[11];
                v74 = *(_WORD *)v72;
              }
              v94 = *(_DWORD *)(v73 + 4 * v74);
              v75 = v71 ? *(_DWORD *)(v73
                                    + 4
                                    * (*(_DWORD *)(v71 + 4 * ((unsigned int)*(_WORD *)(v72 + 2) >> 8))
                                     + (unsigned __int16)(v6 & *(_WORD *)(v72 + 2)))) : *(_DWORD *)(v73
                                                                                                  + 4 * *(_WORD *)(v72 + 2));
              v70 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 10) - 1;
              if ( !((v94 ^ v75) & 0xE7FFFFFF) )
                v110 = 1;
            }
            if ( v70 >= 0 )
            {
              while ( 1 )
              {
                v76 = (v103 + v127) / 2;
                v77 = NlsCompareRgWChar(2 * v110 + *(_DWORD *)(v3 + 16), v98 + 12 * v76, 3);
                if ( !v77 )
                  break;
                if ( v77 >= 0 )
                  v103 = v76 + 1;
                else
                  v127 = v76 - 1;
                if ( v103 > v127 )
                  goto LABEL_157;
              }
              *(_DWORD *)(v3 + 24) = *(_DWORD *)(12 * v76 + v98 + 8);
              if ( !v110 )
                *(_DWORD *)(v3 + 16) += 4;
              goto LABEL_183;
            }
          }
        }
      }
LABEL_157:
      v4 = *a1;
      v95 = *(_DWORD *)(*a1 + 248);
      if ( *(_WORD *)(*(_DWORD *)(*a1 + 244) + 8) )
      {
        v78 = *(unsigned __int16 **)(v3 + 16);
        v128 = *(_DWORD *)(v4 + 236);
        v79 = *(_DWORD *)(v3 + 4);
        if ( (unsigned int)&v78[2 - (v128 == 0)] <= v79 )
        {
          if ( !v130 )
          {
            v4 = NlsCountOfWCharsWithinRange(
                   v78,
                   v79,
                   2,
                   *(_WORD *)(*(_DWORD *)(v4 + 244) + 4),
                   *(_WORD *)(*(_DWORD *)(v4 + 244) + 6),
                   v128,
                   *(_DWORD *)(v3 + 8));
            v130 = v4;
          }
          if ( v130 >= 2 )
          {
            v4 = *a1;
            v80 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 8) - 1;
            v111 = 0;
            v104 = 0;
            v129 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 8) - 1;
            if ( *(_DWORD *)(*a1 + 236) && v130 >= 3 )
            {
              v81 = *(_DWORD *)(v4 + 224);
              v82 = *(_DWORD *)(v3 + 16);
              if ( v81 )
              {
                v83 = (*pSortTblPtrs)[11];
                v84 = *(_DWORD *)(v81 + 4 * ((unsigned int)*(_WORD *)v82 >> 8)) + (unsigned __int16)(v6 & *(_WORD *)v82);
                v6 = 255;
              }
              else
              {
                v83 = (*pSortTblPtrs)[11];
                v84 = *(_WORD *)v82;
              }
              v131 = *(_DWORD *)(v83 + 4 * v84);
              if ( v81 )
              {
                v85 = *(_WORD *)(v82 + 2);
                v4 = v85 >> 8;
                v86 = *(_DWORD *)(v83 + 4 * (*(_DWORD *)(v81 + 4 * (v85 >> 8)) + (unsigned __int8)v85));
              }
              else
              {
                v4 = *(_WORD *)(v82 + 2);
                v86 = *(_DWORD *)(v83 + 4 * v4);
              }
              v80 = *(_WORD *)(*(_DWORD *)(*a1 + 244) + 8) - 1;
              if ( !((v131 ^ v86) & 0xE7FFFFFF) )
                v111 = 1;
            }
            if ( v80 >= 0 )
            {
              while ( 1 )
              {
                v87 = (v104 + v129) / 2;
                v88 = NlsCompareRgWChar(2 * v111 + *(_DWORD *)(v3 + 16), v95 + 8 * v87, 2);
                if ( !v88 )
                  break;
                if ( v88 >= 0 )
                  v104 = v87 + 1;
                else
                  v129 = v87 - 1;
                LOBYTE(v4) = v129;
                if ( v104 > v129 )
                  goto LABEL_184;
              }
              *(_DWORD *)(v3 + 24) = *(_DWORD *)(v95 + 8 * v87 + 4);
              if ( !v111 )
                *(_DWORD *)(v3 + 16) += 2;
              goto LABEL_183;
            }
          }
        }
      }
      goto LABEL_184;
    }
    if ( (_BYTE)v4 == 6 )
    {
      v2 = v5[2] == 0;
    }
    else
    {
      LOBYTE(v4) = v4 - 7;
      if ( (unsigned __int8)v4 > 5u )
        return v4;
      v2 = v5[4] == 0;
    }
    goto LABEL_12;
  }
  return v4;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E45696) --------------------------------------------------------
int __stdcall FindNLSStringStub(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
{
  return FindNLSString(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
}

//----- (77E456C3) --------------------------------------------------------
int __stdcall SortFindString(int a1, int a2, int a3, signed int a4, int a5, signed int a6, int a7, int a8, int a9)
{
  int v9; // eax@48
  int v10; // ecx@1
  int v11; // ebx@5
  unsigned int v12; // ebx@27
  int result; // eax@28
  int v14; // eax@33
  int v15; // [sp+14h] [bp-94h]@1
  int Address; // [sp+18h] [bp-90h]@14
  int v17; // [sp+1Ch] [bp-8Ch]@18
  unsigned int v18; // [sp+20h] [bp-88h]@18
  unsigned int v19; // [sp+24h] [bp-84h]@18
  unsigned int v20; // [sp+28h] [bp-80h]@18
  unsigned int v21; // [sp+2Ch] [bp-7Ch]@18
  unsigned int v22; // [sp+30h] [bp-78h]@18
  int v23; // [sp+34h] [bp-74h]@18
  int v24; // [sp+38h] [bp-70h]@18
  int v25; // [sp+3Ch] [bp-6Ch]@18
  int v26; // [sp+40h] [bp-68h]@11
  int v27; // [sp+44h] [bp-64h]@14
  int v28; // [sp+48h] [bp-60h]@18
  int v29; // [sp+4Ch] [bp-5Ch]@14
  int v30; // [sp+50h] [bp-58h]@15
  int v31; // [sp+54h] [bp-54h]@14
  int v32; // [sp+5Ch] [bp-4Ch]@14
  int v33; // [sp+6Ch] [bp-3Ch]@18
  int v34; // [sp+70h] [bp-38h]@16
  int v35; // [sp+74h] [bp-34h]@17
  int v36; // [sp+78h] [bp-30h]@14
  int v37; // [sp+80h] [bp-28h]@16
  int v38; // [sp+90h] [bp-18h]@18
  int v39; // [sp+94h] [bp-14h]@18
  int v40; // [sp+98h] [bp-10h]@18
  int v41; // [sp+9Ch] [bp-Ch]@18
  int v42; // [sp+A0h] [bp-8h]@47

  v10 = a5;
  v15 = a1;
  if ( a4 < -1 || !a3 || a6 < -1 || !a5 )
  {
    SetLastError(0x57u);
    return -1;
  }
  v11 = a2;
  if ( !(a2 & 0xF00000) )
    v11 = a2 | 0x400000;
  if ( v11 & 0xF70CFFC8
    || v11 & ((v11 & 0xFFF00000) - 1) & 0xF00000
    || (unsigned __int8)v11 & (unsigned __int8)((v11 & 0xE2) - 1) & 0x22
    || (unsigned __int8)v11 & (unsigned __int8)((v11 & 0xF1) - 1) & 0x11 )
  {
LABEL_42:
    SetLastError(0x3ECu);
    return -1;
  }
  if ( a4 != -1 || a6 != -1 )
  {
    v26 = 1;
    if ( a4 != -1 )
      goto LABEL_12;
  }
  else
  {
    v26 = 0;
  }
  v14 = SortNlsStrLenW((void *)a3);
  v10 = a5;
  a4 = v14;
LABEL_12:
  if ( a6 == -1 )
  {
    v9 = SortNlsStrLenW((void *)v10);
    v10 = a5;
    a6 = v9;
  }
  if ( !(v11 & 0x8000000) )
    v15 = *(_DWORD *)(a1 + 276);
  Address = v15;
  v27 = *(_DWORD *)(v15 + 240) & 1;
  v36 = 0;
  v31 = 0;
  v29 = a3;
  v32 = a3;
  if ( a4 < 0 )
  {
    v30 = -1;
    v31 = 1;
  }
  else
  {
    v30 = a3 + 2 * a4;
  }
  v34 = v10;
  v37 = v10;
  if ( a6 < 0 )
  {
    v35 = -1;
    v36 = 1;
  }
  else
  {
    v35 = v10 + 2 * a6;
  }
  v28 = -1;
  v19 = ((unsigned int)v11 >> 1) & 1;
  v18 = ((unsigned int)v11 >> 2) & 1;
  v20 = ((unsigned int)v11 >> 2) & 1;
  v21 = ((unsigned int)v11 >> 4) & 1;
  v22 = ((unsigned int)v11 >> 5) & 1;
  v40 = 0;
  v41 = 0;
  v33 = 0;
  v38 = 0;
  v17 = 0;
  v23 = 0;
  v24 = 1;
  v25 = 1;
  v39 = 196;
  if ( v11 & 1 )
    v28 = -402653185;
  if ( v11 & 2 )
    v28 &= 0xFF00FFFF;
  else
    v39 = 245;
  if ( v11 & 0x10000 )
    v28 &= 0xDFFFFFFF;
  if ( v11 & 0x20000 )
  {
    v28 &= 0xFEFFFFFF;
    if ( v11 & 1 )
      v39 &= 0xFFFFFFFB;
  }
  v12 = v11 & 0xF7FCFFC8;
  if ( v12 == 0x100000 )
  {
    result = FindFirstIndexOfString((int)&Address, 1);
    goto LABEL_29;
  }
  if ( v12 == 0x200000 )
  {
    result = FindLastIndexOfString(&Address, 1);
    goto LABEL_29;
  }
  if ( v12 == 0x400000 )
  {
    result = FindFirstIndexOfString((int)&Address, 0);
    goto LABEL_29;
  }
  if ( v12 != 0x800000 )
    goto LABEL_42;
  result = FindLastIndexOfString(&Address, 0);
LABEL_29:
  if ( result != -1 )
  {
    if ( a7 )
      *(_DWORD *)a7 = v42 - result;
  }
  return result;
}

//----- (77E4593B) --------------------------------------------------------
int __stdcall FindLastIndexOfString(PVOID Address, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@1
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // eax@1
  int v7; // ebx@2
  int v8; // eax@4
  PVOID v9; // eax@9
  int v10; // ebx@11
  unsigned int v11; // eax@12
  int v12; // edi@13
  int v14; // eax@18
  int v15; // eax@19
  int v16; // [sp+Ch] [bp-8h]@1
  unsigned int v17; // [sp+10h] [bp-4h]@1
  PVOID Addressa; // [sp+1Ch] [bp+8h]@1

  v2 = (int)Address;
  v3 = *((_DWORD *)Address + 17);
  Addressa = 0;
  v17 = v3;
  v4 = v2 + 52;
  v5 = *(_DWORD *)(v2 + 52);
  v16 = *(_DWORD *)(v2 + 52);
  SkipUnsortable((int *)v2, v2 + 88);
  v6 = *(_DWORD *)(v2 + 56);
  if ( *(_DWORD *)(v2 + 104) >= *(_DWORD *)(v2 + 92) )
  {
    v14 = (v6 - v5) >> 1;
    *(_DWORD *)(v2 + 136) = v14;
    v12 = v14;
  }
  else
  {
    v7 = (v6 - *(_DWORD *)v4) >> 1;
    if ( !v7 || !*(_DWORD *)(*(_DWORD *)v2 + 232) )
    {
      v8 = v6 - 2;
      goto LABEL_5;
    }
    v15 = (int)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 4 * v7 + 4);
    Addressa = (PVOID)v15;
    if ( v15 )
    {
      if ( GetGraphemeStartPositions(v2, v2 + 52, v15, v7) )
      {
        v9 = Addressa;
        v7 = *(_DWORD *)Addressa;
LABEL_16:
        v8 = *((_DWORD *)v9 + v7);
LABEL_5:
        *(_DWORD *)v4 = v8;
      }
      while ( *(_DWORD *)v4 >= v17 )
      {
        *(_DWORD *)(v2 + 68) = *(_DWORD *)v4;
        *(_DWORD *)(v2 + 104) = *(_DWORD *)(v2 + 88);
        if ( LongCompareString(v2) == 2 )
        {
          v10 = *(_DWORD *)(v2 + 68);
          *(_DWORD *)(v2 + 136) = (*(_DWORD *)(v2 + 68) - v16) >> 1;
          if ( !a2
            || (SkipUnsortable((int *)v2, v2 + 52),
                v11 = *(_DWORD *)(v2 + 68),
                *(_DWORD *)(v2 + 68) = v10,
                v11 >= *(_DWORD *)(v2 + 56)) )
          {
            v12 = (*(_DWORD *)v4 - v16) >> 1;
            goto LABEL_14;
          }
          break;
        }
        --v7;
        if ( v7 <= 0 )
          break;
        v9 = Addressa;
        if ( Addressa )
          goto LABEL_16;
        *(_DWORD *)v4 -= 2;
      }
      SetLastError(0);
    }
    else
    {
      SetLastError(8u);
    }
    v12 = -1;
LABEL_14:
    if ( Addressa )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Addressa);
  }
  return v12;
}

//----- (77E45B63) --------------------------------------------------------
int __fastcall NlsCountOfWCharsWithinRange(unsigned __int16 *a1, unsigned int a2, int a3, unsigned __int16 a4, unsigned __int16 a5, int a6, signed int a7)
{
  unsigned __int16 *v7; // eax@1
  unsigned __int16 v8; // si@5

  v7 = a1;
  if ( a6 )
    ++a3;
  if ( !a2 )
    a7 = 1;
  for ( ; a3 > 0; --a3 )
  {
    if ( (unsigned int)v7 >= a2 )
      break;
    v8 = *v7;
    if ( !*v7 )
    {
      if ( a7 )
        break;
    }
    if ( v8 > a5 )
      break;
    if ( v8 < a4 )
      break;
    ++v7;
  }
  return v7 - a1;
}

//----- (77E45BBC) --------------------------------------------------------
BOOL __stdcall PulseEventStub(HANDLE hEvent)
{
  return PulseEvent(hEvent);
}

//----- (77E45BD4) --------------------------------------------------------
int __stdcall WerpNotifyUseStringResource(struct tagWerStringResourceData *a1)
{
  return RealWerpNotifyUseStringResource(a1);
}

//----- (77E45BE1) --------------------------------------------------------
int __stdcall RealWerpNotifyUseStringResource(struct tagWerStringResourceData *a1)
{
  DWORD v1; // esi@1
  signed int v2; // edi@1

  v1 = GetLastError();
  v2 = FSPErrorMessages::CMessageMapper::NotifyUseStringResource(
         (FSPErrorMessages::CMessageMapper *)&FSPErrorMessages::CMessageMapper::ms_instance,
         a1);
  SetLastError(v1);
  return v2;
}

//----- (77E45C11) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::NotifyUseStringResource(FSPErrorMessages::CMessageMapper *this, struct tagWerStringResourceData *a2)
{
  FSPErrorMessages::CMessageMapper *v2; // esi@1
  signed int result; // eax@2
  signed int v4; // ST20_4@4
  LONG v5; // ecx@5
  unsigned __int32 v6; // [sp-4h] [bp-34h]@7

  v2 = this;
  if ( *((_DWORD *)this + 9) == 1 )
  {
    result = -2146951860;
  }
  else
  {
    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)this);
    v4 = FSPErrorMessages::CMessageMapper::LazyInitialize(v2);
    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)v2);
    result = v4;
    if ( v4 >= 0 )
    {
      v5 = *((_DWORD *)a2 + 1);
      if ( v5 )
      {
        v6 = *((_DWORD *)a2 + 2);
        if ( v5 & 0xFFFF0000 )
          result = FSPErrorMessages::CMessageMapper::ReportMessageFromText(v2, v5, v6);
        else
          result = FSPErrorMessages::CMessageMapper::ReportMessageFromStringId(
                     v2,
                     *(HINSTANCE *)a2,
                     (unsigned __int16)v5,
                     v6);
      }
      else
      {
        result = 1;
      }
    }
  }
  return result;
}

//----- (77E45C69) --------------------------------------------------------
int __stdcall K32GetProcessMemoryInfo(HANDLE ProcessHandle, int a2, int a3)
{
  NTSTATUS v3; // eax@3
  int result; // eax@5
  DWORD v5; // ST14_4@7
  DWORD v6; // eax@10
  char ProcessInformation; // [sp+4h] [bp-30h]@3
  int v8; // [sp+Ch] [bp-28h]@4
  int v9; // [sp+10h] [bp-24h]@4
  int v10; // [sp+14h] [bp-20h]@4
  int v11; // [sp+18h] [bp-1Ch]@4
  int v12; // [sp+1Ch] [bp-18h]@4
  int v13; // [sp+20h] [bp-14h]@4
  int v14; // [sp+24h] [bp-10h]@4
  int v15; // [sp+28h] [bp-Ch]@4
  int v16; // [sp+2Ch] [bp-8h]@4
  int v17; // [sp+30h] [bp-4h]@11

  if ( !a2 )
  {
    v5 = RtlNtStatusToDosError(-1073741811);
    SetLastError(v5);
    return 0;
  }
  if ( (unsigned int)a3 < 0x28 )
  {
    SetLastError(0x7Au);
    return 0;
  }
  v3 = NtQueryInformationProcess(ProcessHandle, ProcessVmCounters, &ProcessInformation, 0x30u, 0);
  if ( v3 < 0 )
  {
    v6 = RtlNtStatusToDosError(v3);
    SetLastError(v6);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = 4 * ((unsigned int)a3 >= 0x2C) + 40;
    *(_DWORD *)(a2 + 4) = v8;
    *(_DWORD *)(a2 + 8) = v9;
    *(_DWORD *)(a2 + 12) = v10;
    *(_DWORD *)(a2 + 16) = v11;
    *(_DWORD *)(a2 + 20) = v12;
    *(_DWORD *)(a2 + 24) = v13;
    *(_DWORD *)(a2 + 28) = v14;
    *(_DWORD *)(a2 + 32) = v15;
    *(_DWORD *)(a2 + 36) = v16;
    if ( (unsigned int)a3 >= 0x2C )
      *(_DWORD *)(a2 + 40) = v17;
    result = 1;
  }
  return result;
}

//----- (77E45D06) --------------------------------------------------------
DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
{
  NTSTATUS v2; // edi@1
  DWORD_PTR v3; // esi@3
  char ThreadInformation; // [sp+8h] [bp-20h]@1
  DWORD_PTR v6; // [sp+18h] [bp-10h]@3
  DWORD_PTR v7; // [sp+24h] [bp-4h]@2

  v2 = NtQueryInformationThread(hThread, 0, &ThreadInformation, 0x1Cu, 0);
  if ( v2 < 0 || (v7 = dwThreadAffinityMask, v2 = NtSetInformationThread(hThread, ThreadAffinityMask, &v7, 4u), v2 < 0) )
  {
    v3 = 0;
    goto LABEL_6;
  }
  v3 = v6;
  TpCaptureCaller(2);
  if ( !v3 )
LABEL_6:
    BaseSetLastNTError(v2);
  return v3;
}
// 77DE1220: using guessed type int __stdcall TpCaptureCaller(_DWORD);

//----- (77E45D7A) --------------------------------------------------------
BOOL __stdcall GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
{
  BOOL result; // eax@2
  DWORD v9; // edi@3
  int v10; // eax@15
  NTSTATUS v11; // eax@15
  int v12; // eax@21
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-44h]@2
  char v14; // [sp+18h] [bp-3Ch]@21
  __int16 v15; // [sp+1Ah] [bp-3Ah]@3
  LPSTR v16; // [sp+1Ch] [bp-38h]@3
  char v17; // [sp+20h] [bp-34h]@15
  __int16 v18; // [sp+22h] [bp-32h]@3
  LPSTR v19; // [sp+24h] [bp-30h]@3
  UNICODE_STRING v20; // [sp+28h] [bp-2Ch]@3
  LSA_UNICODE_STRING DestinationString; // [sp+30h] [bp-24h]@3
  int v22; // [sp+38h] [bp-1Ch]@5
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@3
  LPCSTR lpRootPathNamea; // [sp+5Ch] [bp+8h]@19
  DWORD nVolumeNameSizea; // [sp+64h] [bp+10h]@13

  if ( !lpRootPathName )
    lpRootPathName = "\\";
  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpRootPathName);
  if ( result )
  {
    DestinationString.Buffer = 0;
    v20.Buffer = 0;
    DestinationString.MaximumLength = 0;
    v20.MaximumLength = 0;
    v16 = lpVolumeNameBuffer;
    v9 = nVolumeNameSize;
    v15 = nVolumeNameSize + 1;
    v19 = lpFileSystemNameBuffer;
    v18 = nFileSystemNameSize + 1;
    ms_exc.registration.TryLevel = 0;
    if ( (!lpVolumeNameBuffer
       || (DestinationString.MaximumLength = 2 * (nVolumeNameSize + 1),
           lpRootPathNamea = *(LPCSTR *)(KernelBaseGetGlobalData() + 44),
           (DestinationString.Buffer = (PWCH)RtlAllocateHeap(
                                               NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                               (ULONG)lpRootPathNamea,
                                               DestinationString.MaximumLength)) != 0))
      && (!lpFileSystemNameBuffer
       || (v20.MaximumLength = 2 * v18,
           nVolumeNameSizea = *(_DWORD *)(KernelBaseGetGlobalData() + 44),
           (v20.Buffer = (PWCH)RtlAllocateHeap(
                                 NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                 nVolumeNameSizea,
                                 v20.MaximumLength)) != 0)) )
    {
      v22 = GetVolumeInformationW(
              UnicodeString.Buffer,
              DestinationString.Buffer,
              v9,
              lpVolumeSerialNumber,
              lpMaximumComponentLength,
              lpFileSystemFlags,
              v20.Buffer,
              nFileSystemNameSize);
      if ( !v22 )
        goto LABEL_8;
      if ( !lpVolumeNameBuffer
        || (RtlInitUnicodeString(&DestinationString, DestinationString.Buffer),
            v12 = KernelBaseGetGlobalData(),
            v11 = (*(int (__stdcall **)(char *, LSA_UNICODE_STRING *, _DWORD))(v12 + 28))(&v14, &DestinationString, 0),
            v11 >= 0) )
      {
        if ( !lpFileSystemNameBuffer )
          goto LABEL_8;
        RtlInitUnicodeString(&v20, v20.Buffer);
        v10 = KernelBaseGetGlobalData();
        v11 = (*(int (__stdcall **)(char *, UNICODE_STRING *, _DWORD))(v10 + 28))(&v17, &v20, 0);
        if ( v11 >= 0 )
          goto LABEL_8;
      }
      BaseSetLastNTError(v11);
    }
    else
    {
      RtlSetLastWin32Error(8);
    }
    v22 = 0;
LABEL_8:
    ms_exc.registration.TryLevel = -2;
    if ( DestinationString.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    if ( v20.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v20.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v22;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E4613C) --------------------------------------------------------
NTSTATUS __stdcall ClassKeyCountSubKeys(int a1, int a2, HANDLE a3, int a4, int a5)
{
  int v5; // ebx@1
  HANDLE v6; // eax@3
  NTSTATUS result; // eax@5
  int v8; // ecx@12
  NTSTATUS v9; // eax@27
  int v10; // eax@28
  LONG v11; // ebx@31
  int v12; // eax@38
  int v13; // [sp+Ch] [bp-2A4h]@1
  int v14; // [sp+14h] [bp-29Ch]@33
  int Dst; // [sp+13Ch] [bp-174h]@1
  int v16; // [sp+144h] [bp-16Ch]@32
  UNICODE_STRING String1; // [sp+26Ch] [bp-44h]@31
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+274h] [bp-3Ch]@5
  __int16 v19; // [sp+28Ch] [bp-24h]@1
  __int16 v20; // [sp+28Eh] [bp-22h]@1
  int v21; // [sp+290h] [bp-20h]@1
  UNICODE_STRING String2; // [sp+294h] [bp-1Ch]@1
  HANDLE v23; // [sp+29Ch] [bp-14h]@2
  HANDLE KeyHandle; // [sp+2A0h] [bp-10h]@1
  int v25; // [sp+2A4h] [bp-Ch]@1
  int v26; // [sp+2A8h] [bp-8h]@1
  NTSTATUS v27; // [sp+2ACh] [bp-4h]@1
  int v28; // [sp+2BCh] [bp+Ch]@1
  HANDLE v29; // [sp+2C0h] [bp+10h]@7

  v5 = a2;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v27 = 0;
  KeyHandle = 0;
  v28 = a2 != 0;
  v26 = 0;
  v25 = 0;
  String2.Buffer = (PWCH)(a3 != 0);
  memset(&Dst, 0, 0x130u);
  memset(&v13, 0, 0x130u);
  if ( v28 && v5 == a1 )
  {
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v19;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = (HANDLE)v5;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    result = NtOpenKey(&KeyHandle, 9u, &ObjectAttributes);
    v27 = result;
    if ( result < 0 )
      return result;
    v23 = KeyHandle;
  }
  else
  {
    v23 = (HANDLE)v5;
  }
  v6 = a3;
  if ( String2.Buffer && a3 == (HANDLE)a1 )
  {
    ObjectAttributes.RootDirectory = a3;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v19;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    result = NtOpenKey(&KeyHandle, 9u, &ObjectAttributes);
    v27 = result;
    if ( result < 0 )
      return result;
    v6 = KeyHandle;
  }
  v29 = v6;
  if ( v28 )
  {
    v27 = GetSubKeyCount(v23, (int)&v25);
    if ( v27 < 0 )
      goto LABEL_14;
    v28 = v25 != 0;
  }
  if ( String2.Buffer )
  {
    v27 = GetSubKeyCount(v29, (int)&v26);
    if ( v27 < 0 )
      goto LABEL_14;
    String2.Buffer = (PWCH)(v26 != 0);
  }
  if ( v28 )
  {
    if ( String2.Buffer )
    {
      *(_DWORD *)a5 = 0;
      while ( 1 )
      {
        if ( !Dst )
        {
          v9 = EnumClassKey(v23, (int)&Dst);
          if ( v9 < 0 )
            break;
        }
        v10 = v13;
        if ( !v13 )
        {
          v9 = EnumClassKey(v29, (int)&v13);
          if ( v9 < 0 )
          {
            if ( v9 == -2147483622 )
            {
              v12 = v25;
              goto LABEL_41;
            }
            goto LABEL_42;
          }
          v10 = v13;
        }
        String2.Buffer = (PWCH)(v10 + 24);
        String2.Length = *(_WORD *)(v10 + 20);
        String1.Buffer = (PWCH)(Dst + 24);
        String1.Length = *(_WORD *)(Dst + 20);
        v11 = RtlCompareUnicodeString(&String1, &String2, 1u);
        if ( v11 > 0 || (EnumSubtreeStateClear((PVOID *)&Dst), ++v16, --v25, v11 >= 0) )
        {
          EnumSubtreeStateClear((PVOID *)&v13);
          ++v14;
          --v26;
        }
        ++*(_DWORD *)a5;
        if ( a4 && *(_DWORD *)a5 > (unsigned int)a4 )
          goto LABEL_43;
      }
      if ( v9 == -2147483622 )
      {
        v12 = v26;
LABEL_41:
        *(_DWORD *)a5 += v12;
        v27 = 0;
        goto LABEL_43;
      }
LABEL_42:
      v27 = v9;
LABEL_43:
      EnumSubtreeStateClear((PVOID *)&Dst);
      EnumSubtreeStateClear((PVOID *)&v13);
      goto LABEL_14;
    }
    v8 = v25;
  }
  else
  {
    v8 = v26;
  }
  *(_DWORD *)a5 = v8;
  v27 = 0;
LABEL_14:
  if ( KeyHandle )
    NtClose(KeyHandle);
  return v27;
}

//----- (77E46251) --------------------------------------------------------
NTSTATUS __stdcall GetSubKeyCount(HANDLE KeyHandle, int a2)
{
  NTSTATUS result; // eax@1
  int v3; // [sp+4h] [bp-30h]@1
  char v4; // [sp+8h] [bp-2Ch]@1

  *(_DWORD *)a2 = 0;
  v3 = (int)&v4;
  result = QueryKeyInfo(KeyHandle, KeyCachedInformation, (int)&v3, 0x28u, 0, 0);
  if ( result >= 0 )
    *(_DWORD *)a2 = *(_DWORD *)(v3 + 12);
  return result;
}

//----- (77E462A5) --------------------------------------------------------
BOOL __stdcall Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
  BOOL v2; // ebx@3
  BOOL result; // eax@3
  PROCESSENTRY32W pe; // [sp+4h] [bp-230h]@3

  if ( lppe && lppe->dwSize >= 0x128 )
  {
    pe.dwSize = 556;
    v2 = Process32FirstW(hSnapshot, &pe);
    WideCharToMultiByte(0, 0, pe.szExeFile, -1, lppe->szExeFile, 260, 0, 0);
    lppe->cntUsage = pe.cntUsage;
    lppe->th32ProcessID = pe.th32ProcessID;
    lppe->th32DefaultHeapID = pe.th32DefaultHeapID;
    lppe->th32ModuleID = pe.th32ModuleID;
    lppe->cntThreads = pe.cntThreads;
    lppe->th32ParentProcessID = pe.th32ParentProcessID;
    lppe->pcPriClassBase = pe.pcPriClassBase;
    lppe->dwFlags = pe.dwFlags;
    result = v2;
  }
  else
  {
    BaseSetLastNTError(-1073741820);
    result = 0;
  }
  return result;
}

//----- (77E4636D) --------------------------------------------------------
BOOL __stdcall Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
{
  BOOL v2; // ebx@3
  BOOL result; // eax@3
  PROCESSENTRY32W pe; // [sp+4h] [bp-230h]@3

  if ( lppe && lppe->dwSize >= 0x128 )
  {
    pe.dwSize = 556;
    v2 = Process32NextW(hSnapshot, &pe);
    WideCharToMultiByte(0, 0, pe.szExeFile, -1, lppe->szExeFile, 260, 0, 0);
    lppe->cntUsage = pe.cntUsage;
    lppe->th32ProcessID = pe.th32ProcessID;
    lppe->th32DefaultHeapID = pe.th32DefaultHeapID;
    lppe->th32ModuleID = pe.th32ModuleID;
    lppe->cntThreads = pe.cntThreads;
    lppe->th32ParentProcessID = pe.th32ParentProcessID;
    lppe->pcPriClassBase = pe.pcPriClassBase;
    lppe->dwFlags = pe.dwFlags;
    result = v2;
  }
  else
  {
    BaseSetLastNTError(-1073741820);
    result = 0;
  }
  return result;
}

//----- (77E46469) --------------------------------------------------------
DWORD __stdcall GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
{
  return GetPrivateProfileSectionW(lpAppName, lpReturnedString, nSize, 0);
}

//----- (77E4649C) --------------------------------------------------------
PCUNICODE_STRING __stdcall BaseDllReadApplicationVariables(int a1, int a2)
{
  PPEB v2; // eax@1
  int v3; // esi@1
  int v4; // ebx@3
  PCUNICODE_STRING result; // eax@6
  NTSTATUS i; // eax@12
  int v7; // eax@15
  ULONG ResultLength; // [sp+Ch] [bp-22Ch]@12
  __int16 v9; // [sp+10h] [bp-228h]@15
  __int16 v10; // [sp+12h] [bp-226h]@15
  char *v11; // [sp+14h] [bp-224h]@15
  int v12; // [sp+18h] [bp-220h]@1
  int v13; // [sp+1Ch] [bp-21Ch]@21
  int v14; // [sp+20h] [bp-218h]@21
  int v15; // [sp+24h] [bp-214h]@1
  ULONG Index; // [sp+28h] [bp-210h]@1
  HANDLE Handle; // [sp+2Ch] [bp-20Ch]@6
  PCUNICODE_STRING v18; // [sp+30h] [bp-208h]@5
  char KeyValueInformation; // [sp+34h] [bp-204h]@12
  __int16 v20; // [sp+3Ch] [bp-1FCh]@15
  char v21; // [sp+40h] [bp-1F8h]@15

  v15 = a1;
  v2 = NtCurrentTeb()->ProcessEnvironmentBlock;
  v3 = *(_DWORD *)(a2 + 12);
  v12 = a2;
  Index = (ULONG)v2;
  while ( v3 )
  {
    if ( *(_BYTE *)(Index + 3) & 2 )
    {
      result = (PCUNICODE_STRING)BaseVerifyFileName(v3, (int)&v13);
      if ( (signed int)result < 0 )
        return result;
    }
    else
    {
      v13 = *(_DWORD *)(v3 + 4);
      v14 = *(_DWORD *)(v3 + 8);
    }
    if ( (_WORD)v13 )
    {
      result = (PCUNICODE_STRING)BaseDllReadVariableValue(v15, a2, v3, (UNICODE_STRING *)&v13);
      if ( (signed int)result < 0 && result != (PCUNICODE_STRING)-1073741772 && result != (PCUNICODE_STRING)-1073741788 )
        return result;
    }
    v3 = *(_DWORD *)v3;
  }
  v4 = *(_DWORD *)(a2 + 16);
  if ( v4 )
  {
    if ( !(*(_BYTE *)(Index + 3) & 2) || (result = (PCUNICODE_STRING)BaseVerifyFileName(v4, 0), (signed int)result >= 0) )
    {
      if ( BaseDllGetApplicationName(v15, 0, (int)&v18) )
      {
        result = (PCUNICODE_STRING)BaseDllOpenMappingTarget(v15, v4, v18, 0, &Handle);
        if ( (signed int)result >= 0 && Handle != (HANDLE)-1 )
        {
          Index = 0;
          for ( i = NtEnumerateValueKey(Handle, 0, 0, &KeyValueInformation, 0x200u, &ResultLength);
                ;
                i = NtEnumerateValueKey(Handle, Index, 0, &KeyValueInformation, 0x200u, &ResultLength) )
          {
            v18 = (PCUNICODE_STRING)i;
            if ( i == -2147483622 )
            {
              NtClose(Handle);
              return 0;
            }
            if ( (signed int)v18 < 0 )
              break;
            v11 = &v21;
            v9 = v20;
            v10 = v20;
            v7 = BaseDllReadVariableValue(v15, v12, 0, (UNICODE_STRING *)&v9);
            v18 = (PCUNICODE_STRING)v7;
            if ( v7 < 0 && v7 != -1073741772 && v7 != -1073741788 )
              break;
            ++Index;
          }
          NtClose(Handle);
          result = v18;
        }
      }
      else
      {
        result = (PCUNICODE_STRING)-1073741811;
      }
    }
  }
  else
  {
    result = (PCUNICODE_STRING)-1073741802;
  }
  return result;
}

//----- (77E46774) --------------------------------------------------------
LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
{
  LPCWSTR v2; // eax@1
  const WCHAR v3; // cx@2
  unsigned int v4; // ebx@3
  LPWSTR v5; // edi@3
  LPWSTR result; // eax@3
  WCHAR v7; // cx@4

  v2 = lpString2;
  do
  {
    v3 = *v2;
    ++v2;
  }
  while ( v3 );
  v4 = (char *)v2 - (char *)lpString2;
  v5 = lpString1 - 1;
  result = lpString1;
  do
  {
    v7 = v5[1];
    ++v5;
  }
  while ( v7 );
  qmemcpy(v5, lpString2, v4);
  return result;
}

//----- (77E468F6) --------------------------------------------------------
BOOL __stdcall IsDBCSLeadByteExStub(UINT CodePage, BYTE TestChar)
{
  return IsDBCSLeadByteEx(CodePage, TestChar);
}

//----- (77E46945) --------------------------------------------------------
int __stdcall GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
{
  char *v6; // edi@10
  int i; // eax@10
  int v8; // esi@11
  int v10; // esi@27
  int v11; // eax@31
  char Address; // [sp+18h] [bp-104h]@10

  if ( cchData < 0 || !lpCalData && cchData )
    goto LABEL_18;
  if ( CalType & 0x10000000 || (CalType & 0xFFFFFFF) >= 0x38 )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  if ( CalType & 0x20000000 )
  {
    if ( !lpCalData && !cchData && lpValue )
      goto LABEL_10;
    goto LABEL_18;
  }
  if ( lpValue || !lpCalData && cchData )
  {
LABEL_18:
    RtlSetLastWin32Error(87);
    return 0;
  }
LABEL_10:
  v6 = &Address;
  for ( i = GetCalendarInfoW(
              Locale,
              Calendar,
              CalType,
              (LPWSTR)(lpCalData != 0 ? (unsigned int)&Address : 0),
              lpCalData != 0 ? 0x80 : 0,
              lpValue);
        ;
        i = GetCalendarInfoW(
              Locale,
              Calendar,
              CalType,
              (LPWSTR)(lpCalData != 0 ? (unsigned int)v6 : 0),
              lpCalData != 0 ? v10 : 0,
              0) )
  {
    v8 = i;
    if ( i || lpValue || GetLastError() != 122 || v6 != &Address )
      break;
    RtlSetLastWin32Error(0);
    v10 = GetCalendarInfoW(Locale, Calendar, CalType, 0, 0, 0);
    if ( v10 )
    {
      v6 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v10);
      if ( !v6 )
      {
        RtlSetLastWin32Error(14);
        return 0;
      }
    }
  }
  if ( v8 > 0 )
  {
    if ( CalType & 0x20000000 )
    {
      v8 *= 2;
    }
    else
    {
      v11 = NlsGetACPFromLocale(Locale, CalType);
      if ( v11 )
      {
        v8 = NlsUnicodeToAnsi(v11, (LPCWSTR)v6, v8, lpCalData, cchData);
      }
      else
      {
        RtlSetLastWin32Error(87);
        v8 = 0;
      }
    }
  }
  if ( v6 != &Address )
  {
    if ( v6 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E46C00) --------------------------------------------------------
int __stdcall BaseDllReadKeywordNames(STRING *String1)
{
  int result; // eax@1

  for ( result = BaseDllFindSection(String1);
        result >= 0;
        result = BaseDllAppendStringToResultBuffer(
                   (int)String1,
                   (int)String1[16].Buffer,
                   *(_DWORD *)&String1[21].Length,
                   1) )
  {
    result = BaseDllAdvanceTextPointer((int)String1, 2);
    if ( result != 261 )
    {
      if ( result == -2147483622 )
        result = 0;
      return result;
    }
  }
  return result;
}

//----- (77E46CC2) --------------------------------------------------------
int __stdcall K32GetModuleFileNameExA(HANDLE hProcess, int Buffer, LPSTR lpMultiByteStr, LPCWSTR lpWideCharStr)
{
  int v4; // esi@1
  HLOCAL v5; // eax@1
  int v6; // eax@2
  int v7; // edi@2
  int result; // eax@5
  const WCHAR *lpWideCharStra; // [sp+1Ch] [bp+14h]@1

  v4 = (int)lpWideCharStr;
  v5 = LocalAlloc(0, 2 * (_DWORD)lpWideCharStr);
  lpWideCharStra = (const WCHAR *)v5;
  if ( v5 )
  {
    v6 = K32GetModuleFileNameExW(hProcess, Buffer, v5, v4);
    v7 = v6;
    if ( v6 < (unsigned int)v4 )
      ++v6;
    if ( !WideCharToMultiByte(0, 0, lpWideCharStra, v6, lpMultiByteStr, v4, 0, 0) )
      v7 = 0;
    LocalFree((HLOCAL)lpWideCharStra);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E46D2C) --------------------------------------------------------
BOOL __stdcall K32EnumProcesses(DWORD *lpidProcess, DWORD cb, LPDWORD lpcbNeeded)
{
  HLOCAL i; // ebx@1
  NTSTATUS v4; // eax@3
  int v5; // edx@6
  DWORD v6; // esi@6
  int v7; // ecx@9
  DWORD v9; // eax@12
  NTSTATUS NtStatus; // [sp+18h] [bp-24h]@3
  SIZE_T SystemInformationLength; // [sp+20h] [bp-1Ch]@1

  SystemInformationLength = 0x8000;
  for ( i = LocalAlloc(0, 0x8000u); ; i = LocalAlloc(0, SystemInformationLength) )
  {
    if ( !i )
      return 0;
    v4 = NtQuerySystemInformation(SystemProcessInformation, i, SystemInformationLength, 0);
    NtStatus = v4;
    if ( v4 != -1073741820 )
      break;
    LocalFree(i);
    SystemInformationLength += 0x8000;
  }
  if ( v4 < 0 )
  {
    LocalFree(i);
    v9 = RtlNtStatusToDosError(NtStatus);
    SetLastError(v9);
    return 0;
  }
  v5 = 0;
  v6 = 0;
  do
  {
    if ( v6 < cb >> 2 )
      lpidProcess[v6++] = *(_DWORD *)((char *)i + v5 + 68);
    v7 = *(_DWORD *)((char *)i + v5);
    v5 += v7;
  }
  while ( v7 );
  *lpcbNeeded = 4 * v6;
  LocalFree(i);
  return 1;
}

//----- (77E46E12) --------------------------------------------------------
BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
{
  BOOL result; // eax@1
  BOOL v4; // edi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@2
  LSA_UNICODE_STRING v6; // [sp+8h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&v6, lpExistingFileName);
  if ( result )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpNewFileName) )
    {
      v4 = CopyFileExW(v6.Buffer, UnicodeString.Buffer, 0, 0, 0, bFailIfExists != 0);
      RtlFreeUnicodeString(&UnicodeString);
    }
    else
    {
      v4 = 0;
    }
    RtlFreeUnicodeString(&v6);
    result = v4;
  }
  return result;
}

//----- (77E46EE1) --------------------------------------------------------
int __stdcall BaseDllCalculateDeleteLength(int a1)
{
  int v1; // ecx@2

  if ( *(_BYTE *)(*(_DWORD *)(a1 + 12) + 25) )
    v1 = *(_DWORD *)(a1 + 168);
  else
    v1 = *(_DWORD *)(a1 + 132);
  return *(_DWORD *)(a1 + 92) - *(_DWORD *)(v1 + 4);
}

//----- (77E46F8E) --------------------------------------------------------
BOOL __stdcall MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
  return MoveFileWithProgressW(lpExistingFileName, lpNewFileName, 0, 0, 2u);
}

//----- (77E47000) --------------------------------------------------------
BOOL __stdcall IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
{
  LPCWSTR v2; // eax@2
  const WCHAR *i; // [sp+10h] [bp-1Ch]@3

  if ( !ucchMax )
    return 0;
  v2 = lpsz;
  if ( lpsz )
  {
    for ( i = lpsz; *v2 && i != &lpsz[ucchMax - 1]; v2 = i )
      ++i;
    return 0;
  }
  return 1;
}

//----- (77E470B5) --------------------------------------------------------
bool __stdcall BasepShimCacheRemoveEntry(PCWSTR SourceString, int a2)
{
  HANDLE v2; // eax@1
  int v4; // esi@6
  int v5; // [sp+4h] [bp-ECh]@1
  char Dst; // [sp+8h] [bp-E8h]@1
  int v7; // [sp+94h] [bp-5Ch]@6
  HANDLE v8; // [sp+9Ch] [bp-54h]@6
  LSA_UNICODE_STRING DestinationString; // [sp+A0h] [bp-50h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+CCh] [bp-24h]@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+D4h] [bp-1Ch]@2
  HANDLE FileHandle; // [sp+ECh] [bp-4h]@1

  v5 = 0;
  memset(&Dst, 0, 0xC4u);
  FileHandle = (HANDLE)-1;
  RtlInitUnicodeString(&DestinationString, SourceString);
  v2 = (HANDLE)a2;
  if ( a2 == -1 )
  {
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( NtOpenFile(&FileHandle, 0x100081u, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u) < 0 )
      return 0;
    v2 = FileHandle;
  }
  v8 = v2;
  v7 = 9;
  v4 = NtApphelpCacheControl(1, &v5);
  if ( FileHandle != (HANDLE)-1 )
    CloseHandle(FileHandle);
  return v4 >= 0;
}
// 77DE114C: using guessed type int __stdcall NtApphelpCacheControl(_DWORD, _DWORD);

//----- (77E47155) --------------------------------------------------------
int __stdcall FoldStringWStub(DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  return FoldStringW(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (77E4716D) --------------------------------------------------------
int __stdcall GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
{
  int v6; // eax@1
  int v7; // eax@7
  WCHAR *v8; // edi@8
  int i; // eax@8
  int v10; // esi@9
  int v12; // esi@28
  char v13; // [sp+Ch] [bp-214h]@7
  LPSTR lpMultiByteStr; // [sp+10h] [bp-210h]@1
  int v15; // [sp+14h] [bp-20Ch]@1
  LPCWSTR v16; // [sp+18h] [bp-208h]@7
  char v17; // [sp+1Ch] [bp-204h]@7
  WCHAR DateStr; // [sp+11Ch] [bp-104h]@8

  lpMultiByteStr = lpDateStr;
  v6 = NlsGetACPFromLocale(Locale, dwFlags);
  v15 = v6;
  if ( !v6 || cchDate < 0 || !lpDateStr && cchDate )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( dwFlags & 0x3FFFFF80
    || (unsigned __int8)dwFlags & (unsigned __int8)((dwFlags & 0xF0) - 1) & 0x70
    || dwFlags & 0x30 && *(_DWORD *)v6 != 1255 && *(_DWORD *)v6 != 1256 )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  v16 = (LPCWSTR)&v17;
  NlsAnsiToUnicode(v6, 0, (int)lpFormat, -1, (int)&v16, (int)&v13);
  if ( !v7 )
    return 0;
  v8 = &DateStr;
  for ( i = GetDateFormatW(Locale, dwFlags, lpDate, v16, &DateStr, 128);
        ;
        i = GetDateFormatW(Locale, dwFlags, lpDate, v16, v8, v12) )
  {
    v10 = i;
    if ( i || GetLastError() != 122 || v8 != &DateStr )
      break;
    RtlSetLastWin32Error(0);
    v12 = GetDateFormatW(Locale, dwFlags, lpDate, v16, 0, 0);
    if ( v12 )
    {
      v8 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v12);
      if ( !v8 )
      {
        if ( (char *)v16 != &v17 && v16 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v16);
        RtlSetLastWin32Error(14);
        return 0;
      }
    }
  }
  if ( (char *)v16 != &v17 && v16 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v16);
  if ( v10 > 0 )
    v10 = NlsUnicodeToAnsi(v15, v8, v10, lpMultiByteStr, cchDate);
  if ( v8 != &DateStr )
  {
    if ( v8 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
  }
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E472B9) --------------------------------------------------------
int __stdcall GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
{
  int v6; // eax@1
  int v7; // eax@4
  WCHAR *v8; // edi@5
  int i; // eax@5
  int v10; // esi@6
  int v12; // esi@20
  char v13; // [sp+Ch] [bp-214h]@4
  LPSTR lpMultiByteStr; // [sp+10h] [bp-210h]@1
  int v15; // [sp+14h] [bp-20Ch]@1
  LPCWSTR v16; // [sp+18h] [bp-208h]@4
  char v17; // [sp+1Ch] [bp-204h]@4
  WCHAR TimeStr; // [sp+11Ch] [bp-104h]@5

  lpMultiByteStr = lpTimeStr;
  v6 = NlsGetACPFromLocale(Locale, dwFlags);
  v15 = v6;
  if ( !v6 || cchTime < 0 || !lpTimeStr && cchTime )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v16 = (LPCWSTR)&v17;
  NlsAnsiToUnicode(v6, 0, (int)lpFormat, -1, (int)&v16, (int)&v13);
  if ( !v7 )
    return 0;
  v8 = &TimeStr;
  for ( i = GetTimeFormatW(Locale, dwFlags, lpTime, v16, &TimeStr, 128);
        ;
        i = GetTimeFormatW(Locale, dwFlags, lpTime, v16, v8, v12) )
  {
    v10 = i;
    if ( i || GetLastError() != 122 || v8 != &TimeStr )
      break;
    RtlSetLastWin32Error(0);
    v12 = GetTimeFormatW(Locale, dwFlags, lpTime, v16, 0, 0);
    if ( v12 )
    {
      v8 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v12);
      if ( !v8 )
      {
        if ( (char *)v16 != &v17 && v16 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v16);
        RtlSetLastWin32Error(14);
        return 0;
      }
    }
  }
  if ( (char *)v16 != &v17 && v16 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v16);
  if ( v10 > 0 )
    v10 = NlsUnicodeToAnsi(v15, v8, v10, lpMultiByteStr, cchTime);
  if ( v8 != &TimeStr )
  {
    if ( v8 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
  }
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E474DC) --------------------------------------------------------
int __stdcall ConverStringWithHeapAlloc(PWCHAR UnicodeString, int a2, ULONG ResultSize)
{
  PWCHAR v3; // eax@1
  ULONG v4; // edi@2
  WCHAR v5; // cx@3
  int v6; // eax@4
  int v7; // eax@6
  PVOID v8; // eax@6
  int result; // eax@8

  v3 = UnicodeString;
  if ( UnicodeString && (v4 = ResultSize) != 0 )
  {
    do
    {
      v5 = *v3;
      ++v3;
    }
    while ( v5 );
    v6 = v3 - (UnicodeString + 1) + 1;
    ResultSize = v6;
    if ( *(_DWORD *)v4 >= (unsigned int)v6 )
    {
      if ( *(_DWORD *)a2 )
        return RtlUnicodeToMultiByteN(*(PCHAR *)a2, *(_DWORD *)v4, &ResultSize, UnicodeString, 2 * v6);
    }
    else
    {
      if ( *(_DWORD *)a2 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)a2);
        *(_DWORD *)a2 = 0;
        v6 = ResultSize;
      }
      *(_DWORD *)v4 = v6 + 16;
      v7 = KernelBaseGetGlobalData();
      v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), *(_DWORD *)v4);
      *(_DWORD *)a2 = v8;
      if ( v8 )
      {
        v6 = ResultSize;
        return RtlUnicodeToMultiByteN(*(PCHAR *)a2, *(_DWORD *)v4, &ResultSize, UnicodeString, 2 * v6);
      }
    }
    result = -1073741801;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (77E4757C) --------------------------------------------------------
BOOL __stdcall EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceNamesExA(hModule, lpType, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E4759F) --------------------------------------------------------
BOOL __stdcall EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  ULONG v6; // eax@1
  ULONG v7; // esi@1
  int v8; // edi@2
  BOOL result; // eax@2

  v6 = BaseDllMapResourceIdA((ULONG)lpType);
  v7 = v6;
  if ( v6 == -1 )
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  else
  {
    v8 = EnumResourceNamesInternal((int)hModule, (PWCHAR)v6, (int)lpEnumFunc, lParam, dwFlags, LangId, 1);
    BaseDllFreeResourceId(v7);
    result = v8;
  }
  return result;
}
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);

//----- (77E47633) --------------------------------------------------------
size_t __stdcall QueryRegValue(HANDLE KeyHandle, PCWSTR SourceString, int a3, size_t Size, int a5, int a6)
{
  int v6; // esi@2
  PVOID v7; // esi@5
  unsigned int v8; // eax@6
  size_t result; // eax@10
  PVOID v10; // eax@15
  PCWSTR v11; // ST14_4@17
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-Ch]@2
  PVOID Address; // [sp+14h] [bp-4h]@1

  Address = 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  v6 = a3;
  memset(*(void **)a3, 0, Size);
  Size = NtQueryValueKey(
           KeyHandle,
           &DestinationString,
           KeyValueFullInformation,
           *(PVOID *)v6,
           Size,
           (PULONG)&SourceString);
  if ( Size == -2147483643 && a6 )
  {
    v10 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, (ULONG)SourceString);
    Address = v10;
    if ( !v10 )
      return -1073741801;
    v11 = SourceString;
    *(_DWORD *)v6 = v10;
    memset(v10, 0, (size_t)v11);
    Size = NtQueryValueKey(
             KeyHandle,
             &DestinationString,
             KeyValueFullInformation,
             *(PVOID *)v6,
             (ULONG)SourceString,
             (PULONG)&SourceString);
    *(_DWORD *)a6 = 1;
  }
  if ( a5 && *(_DWORD *)(*(_DWORD *)v6 + 4) != a5 )
    Size = -1073741492;
  v7 = *(PVOID *)v6;
  if ( *((_DWORD *)v7 + 1) == 1 )
  {
    v8 = *((_DWORD *)v7 + 3);
    if ( v8 & 1 || v8 < 2 || *(_WORD *)((char *)v7 + 2 * (v8 >> 1) + *((_DWORD *)v7 + 2) - 2) )
      Size = -1073741492;
  }
  if ( (Size & 0x80000000) != 0 )
  {
    if ( a6 && *(_DWORD *)a6 )
    {
      if ( Address )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      *(_DWORD *)a6 = 0;
    }
    result = Size;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E476F8) --------------------------------------------------------
GEOID __stdcall GetUserGeoID(GEOCLASS GeoClass)
{
  __int32 v1; // edi@1
  const WCHAR *v2; // esi@3
  unsigned int v3; // eax@6
  size_t v4; // eax@7
  int v6; // [sp+8h] [bp-2C0h]@5
  HANDLE Handle; // [sp+Ch] [bp-2BCh]@1
  char v8; // [sp+10h] [bp-2B8h]@5
  wchar_t pszDest; // [sp+224h] [bp-A4h]@8

  Handle = 0;
  v1 = -1;
  if ( GeoClass == 14 )
  {
    v2 = L"Region";
  }
  else
  {
    if ( GeoClass != 16 )
      return v1;
    v2 = L"Nation";
  }
  if ( !OpenRegKey(&Handle, 0, L"Control Panel\\International\\Geo", 131097, 1) )
  {
    v6 = (int)&v8;
    if ( (QueryRegValue(Handle, v2, (int)&v6, 0x214u, 1, 0) & 0x80000000) == 0 )
    {
      v3 = *(_DWORD *)(v6 + 12);
      if ( v3 > 2 )
      {
        v4 = v3 >> 1;
        if ( v4 > 0x50 )
          v4 = 80;
        StringCchCopyW(&pszDest, v4, (STRSAFE_LPCWSTR)(v6 + *(_DWORD *)(v6 + 8)));
        v1 = _wtol(&pszDest);
      }
    }
    if ( Handle )
      NtClose(Handle);
    return v1;
  }
  RtlSetLastWin32Error(1009);
  return -1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E475E0: using guessed type wchar_t aControlPanelIn[32];
// 77E476ED: using guessed type int __stdcall OpenRegKey(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E61C68: using guessed type wchar_t aRegion[7];

//----- (77E477FC) --------------------------------------------------------
DWORD __stdcall GetProcessHeapsStub(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
{
  return GetProcessHeaps(NumberOfHeaps, ProcessHeaps);
}

//----- (77E47826) --------------------------------------------------------
DWORD __stdcall GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
{
  return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, 0);
}

//----- (77E4785A) --------------------------------------------------------
UINT __stdcall GetWindowsDirectoryAStub(LPSTR lpBuffer, UINT uSize)
{
  return GetWindowsDirectoryA(lpBuffer, uSize);
}

//----- (77E47992) --------------------------------------------------------
BOOL __stdcall EnumSystemLocalesAStub(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
{
  return EnumSystemLocalesA(lpLocaleEnumProc, dwFlags);
}

//----- (77E479E0) --------------------------------------------------------
LPWSTR __stdcall lstrcpynWStub(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
{
  return lstrcpynW(lpString1, lpString2, iMaxLength);
}

//----- (77E47A18) --------------------------------------------------------
DWORD __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
  PVOID v4; // eax@2
  int v5; // esi@6
  DWORD v6; // eax@7
  int v8; // [sp+10h] [bp-48h]@1
  int v9; // [sp+14h] [bp-44h]@1
  char v10; // [sp+18h] [bp-40h]@1
  char v11; // [sp+34h] [bp-24h]@6
  DWORD v12; // [sp+3Ch] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+40h] [bp-18h]@2
  HANDLE hObjectToWaitOna; // [sp+64h] [bp+Ch]@5

  v8 = 36;
  v9 = 1;
  memset(&v10, 0, 0x1Cu);
  if ( bAlertable )
    RtlActivateActivationContextUnsafeFast(&v8, 0);
  ms_exc.registration.TryLevel = 0;
  v4 = hObjectToWaitOn;
  if ( hObjectToWaitOn == (HANDLE)-12 )
  {
    v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[4];
  }
  else if ( hObjectToWaitOn == (HANDLE)-11 )
  {
    v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[3];
  }
  else if ( hObjectToWaitOn == (HANDLE)-10 )
  {
    v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[2];
  }
  hObjectToWaitOna = v4;
  if ( ((unsigned int)v4 & 0x10000003) == 3 && VerifyConsoleIoHandle((int)v4) )
    hObjectToWaitOna = GetConsoleInputWaitHandle();
  v5 = BaseFormatTimeOut((int)&v11, dwMilliseconds);
  while ( 1 )
  {
    v6 = NtSignalAndWaitForSingleObject(hObjectToSignal, hObjectToWaitOna, bAlertable, (PLARGE_INTEGER)v5);
    v12 = v6;
    if ( (v6 & 0x80000000) != 0 )
      break;
    if ( !bAlertable || v6 != 257 )
      goto LABEL_9;
  }
  BaseSetLastNTError(v6);
  v12 = -1;
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( bAlertable )
    RtlDeactivateActivationContextUnsafeFast(&v8);
  return v12;
}
// 77DE140C: using guessed type int __fastcall RtlActivateActivationContextUnsafeFast(_DWORD, _DWORD);
// 77DE1410: using guessed type int __thiscall RtlDeactivateActivationContextUnsafeFast(_DWORD);

//----- (77E47B02) --------------------------------------------------------
BOOL __stdcall EnumDateFormatsWStub(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
{
  return EnumDateFormatsW(lpDateFmtEnumProc, Locale, dwFlags);
}

//----- (77E47B1A) --------------------------------------------------------
BOOL __stdcall EnumTimeFormatsWStub(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
{
  return EnumTimeFormatsW(lpTimeFmtEnumProc, Locale, dwFlags);
}

//----- (77E47B32) --------------------------------------------------------
BOOL __stdcall EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
{
  int v4; // eax@1
  BOOL result; // eax@3

  v4 = NlsValidateLocale(&Locale, 0);
  if ( CalType & 0x10000000 || (CalType & 0xFFFFFFF) >= 0x38 )
  {
    RtlSetLastWin32Error(1004);
    result = 0;
  }
  else
  {
    result = Internal_EnumCalendarInfo(lpCalInfoEnumProc, v4, Calendar, CalType, 0, 0, 0, 0);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E47B80: using guessed type int __stdcall Internal_EnumCalendarInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E47BA6) --------------------------------------------------------
BOOL __stdcall WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
{
  return WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, 0);
}

//----- (77E47BE3) --------------------------------------------------------
BOOL __stdcall UnlockFileStub(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
{
  return UnlockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
}

//----- (77E47BFB) --------------------------------------------------------
BOOL __stdcall LockFileStub(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
{
  return LockFile(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
}

//----- (77E47C13) --------------------------------------------------------
UINT __stdcall GlobalFlags(HGLOBAL hMem)
{
  HGLOBAL v1; // ebx@1
  int v2; // esi@2
  __int16 v3; // cx@3
  int v4; // ecx@3
  __int16 v5; // ax@3
  int v7; // [sp+14h] [bp-24h]@9
  void *v8; // [sp+18h] [bp-20h]@9
  int v9; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  v9 = 0x8000;
  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v1 = hMem;
  if ( (unsigned __int8)hMem & 4 )
    goto LABEL_21;
  v8 = 0;
  v7 = 2048;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 2048, hMem, &v8, &v7) )
  {
    if ( v8 && v7 & 0x200 )
      v1 = v8;
    else
      v9 = 0;
  }
  if ( (unsigned __int8)v1 & 4 )
  {
LABEL_21:
    v2 = (int)((char *)v1 - 4);
    if ( (unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, (char *)v1 - 4) )
    {
      v3 = *(_WORD *)(v2 + 2);
      v4 = (unsigned __int8)v3;
      v9 = v4;
      v5 = *(_WORD *)v2;
      if ( *(_WORD *)v2 & 8 )
      {
        v4 |= 0x4000u;
        v9 = v4;
      }
      if ( v5 & 4 )
        v9 = v4 | 0x100;
      if ( v5 & 0x8000 )
        v9 |= 0x2000u;
    }
  }
  if ( v9 == 0x8000 )
    RtlSetLastWin32Error(6);
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  return v9;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E47CEF) --------------------------------------------------------
char __stdcall BaseDllGetVariableValue(ULONG ResultSize, int a2, int a3, int a4)
{
  ULONG v4; // esi@12
  unsigned int v5; // eax@12
  ULONG v6; // eax@13
  int v7; // ecx@15
  int v8; // edi@1
  ULONG v9; // esi@2
  ULONG v10; // eax@2
  WCHAR *v11; // ecx@3
  int v12; // eax@4
  ULONG v13; // ST10_4@5
  ULONG v14; // eax@6
  int v15; // ecx@6
  int v16; // ecx@7
  int v17; // eax@7
  char result; // al@9
  CHAR *v19; // edx@17
  int v20; // ecx@18
  ULONG v21; // ST10_4@19
  WCHAR *v22; // ST00_4@19
  int v23; // eax@21

  v8 = a2;
  if ( a2 )
  {
    v9 = ResultSize;
    v10 = *(_DWORD *)(ResultSize + 80);
    if ( v10 )
    {
LABEL_7:
      v16 = *(_DWORD *)(v9 + 76);
      v17 = v10 + 1;
LABEL_8:
      *(_DWORD *)v8 = v16;
      *(_DWORD *)a4 = v17;
      return 1;
    }
    v11 = *(WCHAR **)(ResultSize + 84);
    if ( !v11 || (v12 = *(_DWORD *)(ResultSize + 88)) == 0 )
    {
      v7 = a4;
      result = 1;
      *(_DWORD *)a2 = &byte_77E1E0E2;
      *(_DWORD *)v7 = 1;
      return result;
    }
    v13 = *(_DWORD *)(ResultSize + 88);
    *(_DWORD *)(ResultSize + 80) = v12;
    if ( RtlUnicodeToMultiByteN(*(PCHAR *)(v9 + 76), *(_DWORD *)(v9 + 80), &ResultSize, v11, v13) >= 0 )
    {
      v14 = ResultSize;
      v15 = *(_DWORD *)(v9 + 76);
      *(_DWORD *)(v9 + 80) = ResultSize;
      *(_BYTE *)(v14 + v15) = 0;
      v10 = ResultSize;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = a3;
    if ( a3 )
    {
      v4 = ResultSize;
      v5 = *(_DWORD *)(ResultSize + 88);
      if ( v5 )
      {
        v6 = v5 >> 1;
      }
      else
      {
        v19 = *(CHAR **)(ResultSize + 76);
        if ( !v19 || (v20 = *(_DWORD *)(ResultSize + 80)) == 0 )
        {
          v23 = a4;
          *(_DWORD *)a3 = &Src;
          *(_DWORD *)v23 = 2;
          return 1;
        }
        v21 = *(_DWORD *)(ResultSize + 80);
        v22 = *(WCHAR **)(ResultSize + 84);
        *(_DWORD *)(ResultSize + 88) = 2 * v20;
        if ( RtlMultiByteToUnicodeN(v22, 2 * v20, &ResultSize, v19, v21) < 0 )
          return 0;
        ResultSize >>= 1;
        *(_WORD *)(*(_DWORD *)(v4 + 84) + 2 * ResultSize) = 0;
        v6 = ResultSize;
      }
      v16 = *(_DWORD *)(v4 + 84);
      v17 = 2 * v6 + 2;
      goto LABEL_8;
    }
  }
  return 0;
}
// 77E1E0E2: using guessed type char byte_77E1E0E2;

//----- (77E47E57) --------------------------------------------------------
int __stdcall BaseDllWriteKeywordValue(STRING *String1, int a2)
{
  size_t v2; // eax@29
  int v3; // ecx@36
  int v4; // edx@36
  unsigned int v5; // ecx@36
  int i; // eax@36
  int v7; // eax@38
  int v8; // edx@40
  unsigned int j; // ecx@40
  unsigned int v10; // ecx@43
  int k; // edx@43
  int v12; // eax@49
  size_t v13; // edx@49
  ULONG v14; // esi@1
  NTSTATUS v15; // edi@1
  size_t v16; // eax@9
  int v17; // eax@15
  PVOID v18; // edi@15
  int v19; // eax@16
  unsigned int v20; // edx@19
  int v21; // eax@19
  int result; // eax@21
  int v23; // edx@22
  int l; // ecx@22
  NTSTATUS v25; // esi@26
  int v26; // ecx@55
  const void *v27; // edx@55
  unsigned int v28; // ecx@55
  int v29; // eax@55
  int v30; // eax@58
  PCHAR v31; // eax@59
  int v32; // eax@62
  int v33; // [sp-8h] [bp-3Ch]@62
  int v34; // [sp-4h] [bp-38h]@62
  int v35; // [sp+Ch] [bp-28h]@12
  int v36; // [sp+10h] [bp-24h]@8
  int v37; // [sp+14h] [bp-20h]@52
  int v38; // [sp+18h] [bp-1Ch]@32
  int v39; // [sp+1Ch] [bp-18h]@30
  int v40; // [sp+20h] [bp-14h]@28
  void *Dst; // [sp+24h] [bp-10h]@6
  int v42; // [sp+28h] [bp-Ch]@12
  size_t Size; // [sp+2Ch] [bp-8h]@1
  char v44; // [sp+33h] [bp-1h]@2
  char String1_3; // [sp+3Fh] [bp+Bh]@10

  Size = 0;
  v14 = (ULONG)String1;
  v15 = BaseDllFindSection(String1);
  if ( v15 < 0 )
  {
    if ( *(_DWORD *)&String1->Length == 3 )
      return 0;
    Dst = String1[12].Buffer;
    if ( String1[1].Buffer[25] )
    {
      if ( !BaseDllGetApplicationName((int)String1, 0, (int)&v40) )
        return -1073741811;
      v2 = *(_WORD *)v40 + 8;
    }
    else
    {
      if ( !BaseDllGetApplicationName((int)String1, (int)&v37, 0) )
        return -1073741811;
      v2 = *(_WORD *)v37 + 4;
    }
    Size = v2;
    v44 = 1;
  }
  else
  {
    v44 = 0;
    v15 = BaseDllFindKeyword(String1);
  }
  if ( v15 < 0 )
  {
    if ( *(_DWORD *)&String1->Length != 3 )
    {
      if ( !v44 )
        Dst = String1[11].Buffer;
      if ( String1[1].Buffer[25] )
      {
        if ( !BaseDllGetVariableName((int)String1, 0, (int)&v39) )
          return -1073741811;
        v16 = Size + *(_WORD *)v39 + 6;
      }
      else
      {
        if ( !BaseDllGetVariableName((int)String1, (int)&v36, 0) )
          return -1073741811;
        v16 = Size + *(_WORD *)v36 + 3;
      }
      Size = v16;
      String1_3 = 1;
      goto LABEL_11;
    }
    return 0;
  }
  if ( String1[1].Buffer[25] )
  {
    if ( *(_DWORD *)&String1->Length == 3 )
    {
      v30 = BaseDllCalculateDeleteLength((int)String1);
      return BaseDllModifyMappedFile(
               (int)String1,
               *(void **)(*(_DWORD *)&String1[21].Length + 4),
               v30,
               (void *)v13,
               v13);
    }
    v31 = String1[21].Buffer;
  }
  else
  {
    if ( *(_DWORD *)&String1->Length == 3 )
    {
      v12 = BaseDllCalculateDeleteLength((int)String1);
      return BaseDllModifyMappedFile((int)String1, *((void **)String1[16].Buffer + 1), v12, (void *)v13, v13);
    }
    v31 = *(PCHAR *)&String1[17].Length;
  }
  Dst = (void *)*((_DWORD *)v31 + 1);
  String1_3 = 0;
LABEL_11:
  if ( !*(_BYTE *)(*(_DWORD *)(v14 + 12) + 25) )
  {
    if ( BaseDllGetVariableValue(v14, (int)&v35, 0, (int)&v42) )
    {
      --v42;
      if ( Size )
      {
        Size += v42;
        goto LABEL_15;
      }
      v34 = v42;
      v32 = *(_DWORD *)(v14 + 136);
      v33 = v35;
      return BaseDllModifyMappedFile(v14, *(void **)(v32 + 4), *(_WORD *)v32, (void *)v33, v34);
    }
    return -1073741811;
  }
  if ( !BaseDllGetVariableValue(v14, 0, (int)&v38, (int)&v42) )
    return -1073741811;
  v42 -= 2;
  if ( !Size )
  {
    v34 = v42;
    v32 = *(_DWORD *)(v14 + 172);
    v33 = v38;
    return BaseDllModifyMappedFile(v14, *(void **)(v32 + 4), *(_WORD *)v32, (void *)v33, v34);
  }
  Size += v42;
LABEL_15:
  v17 = KernelBaseGetGlobalData();
  v18 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v17 + 44), Size + 2);
  if ( v18 )
  {
    v19 = (int)v18;
    if ( *(_BYTE *)(*(_DWORD *)(v14 + 12) + 25) )
    {
      if ( v44 )
      {
        v3 = v40;
        *(_WORD *)v18 = 91;
        v4 = *(_DWORD *)(v3 + 4);
        v5 = (unsigned int)*(_WORD *)v3 >> 1;
        for ( i = (int)((char *)v18 + 2); v5; v4 += 2 )
        {
          --v5;
          *(_WORD *)i = *(_WORD *)v4;
          i += 2;
        }
        *(_WORD *)i = 93;
        v7 = i + 2;
        *(_WORD *)v7 = 13;
        v7 += 2;
        *(_WORD *)v7 = 10;
        v19 = v7 + 2;
      }
      if ( String1_3 )
      {
        v8 = *(_DWORD *)(v39 + 4);
        for ( j = (unsigned int)*(_WORD *)v39 >> 1; j; v8 += 2 )
        {
          --j;
          *(_WORD *)v19 = *(_WORD *)v8;
          v19 += 2;
        }
        *(_WORD *)v19 = 61;
        v19 += 2;
      }
      v10 = (unsigned int)v42 >> 1;
      for ( k = v38; v10; k += 2 )
      {
        --v10;
        *(_WORD *)v19 = *(_WORD *)k;
        v19 += 2;
      }
      if ( String1_3 )
      {
        *(_WORD *)v19 = 13;
        *(_WORD *)(v19 + 2) = 10;
      }
    }
    else
    {
      if ( v44 )
      {
        v26 = v37;
        *(_BYTE *)v18 = 91;
        v27 = *(const void **)(v26 + 4);
        v28 = *(_WORD *)v26;
        qmemcpy((char *)v18 + 1, v27, v28);
        v29 = (int)((char *)v18 + v28 + 1);
        *(_BYTE *)v29++ = 93;
        *(_BYTE *)v29++ = 13;
        *(_BYTE *)v29 = 10;
        v19 = v29 + 1;
      }
      if ( String1_3 )
      {
        v20 = *(_WORD *)v36;
        qmemcpy((void *)v19, *(const void **)(v36 + 4), v20);
        v21 = v19 + v20;
        *(_BYTE *)v21 = 61;
        v19 = v21 + 1;
      }
      v23 = v42;
      for ( l = v35; v23; ++l )
      {
        --v23;
        *(_BYTE *)v19++ = *(_BYTE *)l;
      }
      if ( String1_3 )
      {
        *(_BYTE *)v19 = 13;
        *(_BYTE *)(v19 + 1) = 10;
      }
    }
    v25 = BaseDllModifyMappedFile(v14, Dst, 0, v18, Size);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v18);
    result = v25;
  }
  else
  {
    result = -1073741801;
  }
  return result;
}

//----- (77E47FD9) --------------------------------------------------------
NTSTATUS __stdcall BaseDllModifyMappedFile(int a1, void *Dst, int a3, void *Src, size_t Size)
{
  unsigned int v5; // ecx@1
  int v6; // esi@1
  int v7; // eax@1
  size_t v8; // edi@1
  int v9; // ebx@2
  int v10; // eax@7
  int v11; // ecx@9
  int v12; // esi@11
  int v13; // ebx@11
  NTSTATUS result; // eax@13
  int v15; // [sp+10h] [bp+8h]@2

  v5 = Size;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 12);
  v8 = Size + *(_DWORD *)(v7 + 28) - a3;
  if ( v8 <= *(_DWORD *)(v7 + 36) )
  {
LABEL_2:
    v15 = (int)((char *)Dst - *(_DWORD *)(*(_DWORD *)(a1 + 12) + 32));
    v9 = v5 + *(_DWORD *)(v6 + 100) - (_DWORD)Dst - a3;
    if ( a3 > v5 )
    {
      _memmove(Dst, Src, v5);
      _memmove((char *)Dst + Size, (char *)Dst + a3, v9 - Size);
    }
    else
    {
      if ( !v5 )
        return 0;
      if ( a3 >= v5 )
      {
        v9 = v5;
      }
      else
      {
        _memmove((char *)Dst + v5 - a3, Dst, *(_DWORD *)(v6 + 100) - (_DWORD)Dst);
        v5 = Size;
      }
      _memmove(Dst, Src, v5);
    }
    v10 = *(_DWORD *)(v6 + 12);
    if ( *(_DWORD *)(v10 + 28) != v8 )
      *(_DWORD *)(v10 + 28) = v8;
    v11 = *(_DWORD *)(v6 + 12);
    if ( (unsigned int)v15 < *(_DWORD *)(v11 + 44) )
      *(_DWORD *)(v11 + 44) = v15;
    v12 = *(_DWORD *)(v6 + 12);
    v13 = v15 + v9;
    if ( (unsigned int)v13 > *(_DWORD *)(v12 + 48) )
      *(_DWORD *)(v12 + 48) = v13;
    return 0;
  }
  if ( v8 <= *(_DWORD *)(v7 + 40) )
  {
    *(_DWORD *)(v7 + 36) = v8;
    result = NtAllocateVirtualMemory(
               (HANDLE)0xFFFFFFFF,
               (PVOID *)(*(_DWORD *)(a1 + 12) + 32),
               0,
               (PULONG)(*(_DWORD *)(a1 + 12) + 36),
               0x1000u,
               4u);
    if ( result >= 0 )
    {
      v5 = Size;
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 28) = v8;
      goto LABEL_2;
    }
  }
  else
  {
    result = -2147483643;
  }
  return result;
}

//----- (77E480CB) --------------------------------------------------------
BOOL __stdcall TermsrvAppInstallMode()
{
  return *(_BYTE *)(BaseStaticServerData + 1884) != 0;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E4816D) --------------------------------------------------------
BOOL __stdcall LockFileExStub(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
{
  return LockFileEx(hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
}

//----- (77E48185) --------------------------------------------------------
BOOL __stdcall UnlockFileExStub(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
{
  return UnlockFileEx(hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
}

//----- (77E4819D) --------------------------------------------------------
BOOL __stdcall CreateDirectoryAStub(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  return CreateDirectoryA(lpPathName, lpSecurityAttributes);
}

//----- (77E481B5) --------------------------------------------------------
ATOM __stdcall GlobalFindAtomA(LPCSTR lpString)
{
  return InternalFindAtom(0, 0, lpString);
}

//----- (77E4820C) --------------------------------------------------------
DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
{
  DWORD v2; // ebx@1
  int v3; // eax@1
  PVOID v4; // eax@1
  int v5; // eax@3
  int v6; // edi@3
  int v8; // eax@7
  PVOID v9; // eax@7
  unsigned __int16 v10; // [sp+8h] [bp-10h]@3
  __int16 v11; // [sp+Ah] [bp-Eh]@3
  LPSTR v12; // [sp+Ch] [bp-Ch]@3
  unsigned __int16 v13; // [sp+10h] [bp-8h]@2
  PVOID Address; // [sp+12h] [bp-6h]@1

  v2 = nBufferLength;
  LOWORD(Address) = 2 * nBufferLength + 2;
  v3 = KernelBaseGetGlobalData();
  v4 = RtlAllocateHeap(
         NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
         *(_DWORD *)(v3 + 44),
         (unsigned __int16)Address);
  *(PVOID *)((char *)&Address + 2) = v4;
  if ( !v4 )
  {
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  v13 = 2 * GetTempPathW(((unsigned int)(unsigned __int16)Address - 2) >> 1, (LPWSTR)v4);
  if ( v13 <= (unsigned __int16)((_WORD)Address - 2) )
    goto LABEL_3;
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&Address + 2));
  v8 = KernelBaseGetGlobalData();
  v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44), v13 + 2);
  *(PVOID *)((char *)&Address + 2) = v9;
  if ( v9 )
  {
    v13 = 2 * GetTempPathW((unsigned int)v13 >> 1, (LPWSTR)v9);
    v6 = RtlUnicodeToMultiByteSize(&nBufferLength, *(PWCHAR *)((char *)&Address + 2), v13);
    if ( v6 < 0 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&Address + 2));
LABEL_13:
      BaseSetLastNTError(v6);
      return 0;
    }
    if ( v2 <= nBufferLength )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&Address + 2));
      return nBufferLength + 1;
    }
LABEL_3:
    v12 = lpBuffer;
    v11 = v2 + 1;
    v5 = KernelBaseGetGlobalData();
    v6 = (*(int (__stdcall **)(unsigned __int16 *, unsigned __int16 *, _DWORD))(v5 + 28))(&v10, &v13, 0);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&Address + 2));
    if ( v6 >= 0 )
      return v10;
    goto LABEL_13;
  }
  BaseSetLastNTError(-1073741801);
  return 0;
}

//----- (77E483FA) --------------------------------------------------------
UINT __stdcall GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
{
  int v4; // eax@3
  WCHAR *v5; // eax@3
  UINT v6; // edi@3
  UINT v7; // esi@4
  int v8; // eax@5
  NTSTATUS v9; // eax@5
  char v11; // [sp+0h] [bp-20h]@5
  __int16 v12; // [sp+2h] [bp-1Eh]@5
  LPSTR v13; // [sp+4h] [bp-1Ch]@5
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-18h]@2
  LSA_UNICODE_STRING v15; // [sp+10h] [bp-10h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-8h]@3

  if ( !Basep8BitStringToDynamicUnicodeString((int)&v15, lpPathName) )
    return 0;
  if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpPrefixString) )
  {
    RtlFreeUnicodeString(&v15);
    return 0;
  }
  DestinationString.MaximumLength = 520;
  v4 = KernelBaseGetGlobalData();
  v5 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  *(_DWORD *)(v4 + 44),
                  DestinationString.MaximumLength);
  v6 = 0;
  DestinationString.Buffer = v5;
  if ( v5 )
  {
    v7 = GetTempFileNameW(v15.Buffer, UnicodeString.Buffer, uUnique, v5);
    if ( v7 )
    {
      RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
      v13 = lpTempFileName;
      v12 = 260;
      v8 = KernelBaseGetGlobalData();
      v9 = (*(int (__stdcall **)(char *, LSA_UNICODE_STRING *, _DWORD))(v8 + 28))(&v11, &DestinationString, 0);
      if ( v9 < 0 )
      {
        BaseSetLastNTError(v9);
        v7 = 0;
      }
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    v6 = v7;
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  RtlFreeUnicodeString(&UnicodeString);
  RtlFreeUnicodeString(&v15);
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E48675) --------------------------------------------------------
int __stdcall PrivCopyFileExW(const WCHAR *a1, const WCHAR *a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  __int64 v7; // ST14_8@2
  int result; // eax@8
  int v9; // [sp+10h] [bp-24h]@2
  HANDLE v10; // [sp+14h] [bp-20h]@1
  HANDLE hObject; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@2
  int v13; // [sp+50h] [bp+1Ch]@2

  hObject = (HANDLE)-1;
  v10 = (HANDLE)-1;
  v6 = a6;
  if ( a6 & 1 && a6 & 0x200 )
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  else
  {
    v13 = RtlGetCurrentTransaction();
    RtlSetCurrentTransaction(0);
    ms_exc.registration.TryLevel = 0;
    HIDWORD(v7) = v6 & 0xFFFFE7F0;
    LODWORD(v7) = v6 & 0x180F;
    v9 = BasepCopyFileExW(a1, a2, a3, a4, a5, v7, (int)&hObject, (int)&v10, v13);
    ms_exc.registration.TryLevel = -2;
    RtlSetCurrentTransaction(v13);
    if ( hObject != (HANDLE)-1 )
      CloseHandle(hObject);
    if ( v10 != (HANDLE)-1 )
      CloseHandle(v10);
    result = v9;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E4873B) --------------------------------------------------------
LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
{
  int (__stdcall *v2)(_DWORD, _DWORD); // edi@1
  HKEY v3; // esi@1
  int v4; // eax@2
  LSTATUS v5; // esi@2
  int v6; // edi@7
  int v7; // ebx@7
  int v8; // eax@7
  LSTATUS result; // eax@7
  LSA_UNICODE_STRING Destination; // [sp+10h] [bp-30h]@3
  LSTATUS v11; // [sp+18h] [bp-28h]@10
  int v12; // [sp+20h] [bp-20h]@1
  int v13; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@10

  v12 = 0;
  v13 = 0;
  v2 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 100);
  v3 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA )
  {
    result = 6;
  }
  else
  {
    v4 = RegKrnGetGlobalState();
    v5 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v4 + 176))(v3, &hKey, &v12, &v13);
    if ( !v5 )
    {
      if ( RtlCreateUnicodeStringFromAsciiz(&Destination, lpValueName) )
      {
        Destination.Length += 2;
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v2 )
          {
            ms_exc.registration.TryLevel = 0;
            v5 = v2((unsigned int)hKey & 0xFFFFFFFE, &Destination);
            v11 = v5;
            ms_exc.registration.TryLevel = -2;
          }
        }
        else
        {
          v5 = LocalBaseRegDeleteValue(hKey, &Destination);
        }
        RtlFreeUnicodeString(&Destination);
      }
      else
      {
        v5 = RtlNtStatusToDosError(-1073741801);
      }
    }
    v6 = v13;
    v7 = v12;
    v8 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v8 + 168))(v7, v6);
    result = v5;
  }
  return result;
}

//----- (77E48C8C) --------------------------------------------------------
BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtGetContextThread(hThread, lpContext);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E48CB1) --------------------------------------------------------
DWORD __stdcall SuspendThreadStub(HANDLE hThread)
{
  return SuspendThread(hThread);
}

//----- (77E48D23) --------------------------------------------------------
BOOL __stdcall GetTimeZoneInformationForYearStub(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
{
  return GetTimeZoneInformationForYear(wYear, pdtzi, ptzi);
}

//----- (77E48DB8) --------------------------------------------------------
BOOL __stdcall GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
{
  unsigned __int8 v1; // al@49
  HANDLE v2; // eax@52
  PVOID v3; // eax@52
  PVOID v4; // ecx@53
  UINT v5; // eax@2
  DWORD v6; // ebx@2
  ULONG v7; // ST0C_4@3
  HANDLE v8; // eax@3
  PVOID v9; // eax@3
  UINT v10; // eax@4
  int v11; // esi@5
  unsigned int v12; // ebx@5
  int v13; // esi@10
  unsigned __int8 v14; // al@14
  HANDLE v15; // eax@16
  PVOID v16; // eax@16
  PVOID v17; // ecx@17
  int v18; // edx@20
  int v19; // eax@22
  unsigned __int16 v20; // ax@29
  int v21; // eax@32
  int *v22; // ecx@41
  void *v23; // eax@41
  int *v24; // eax@41
  void *v25; // ST10_4@42
  HANDLE v26; // eax@42
  int *v27; // ecx@42
  void *v28; // eax@42
  int *v29; // ecx@43
  void *v30; // ST10_4@44
  HANDLE v31; // eax@44
  PVOID v32; // ST10_4@46
  HANDLE v33; // eax@46
  struct _MEMORYSTATUSEX Buffer; // [sp+8h] [bp-60h]@37
  ULONGLONG v36; // [sp+48h] [bp-20h]@1
  int *v37; // [sp+50h] [bp-18h]@1
  PVOID Address; // [sp+54h] [bp-14h]@1
  int *v39; // [sp+58h] [bp-10h]@1
  PVOID v40; // [sp+5Ch] [bp-Ch]@1
  PVOID v41; // [sp+60h] [bp-8h]@1
  int v42; // [sp+64h] [bp-4h]@1

  v40 = &v39;
  v39 = (int *)&v39;
  Address = &v37;
  v37 = (int *)&v37;
  v36 = 0i64;
  v42 = 0;
  v41 = 0;
  if ( !TotalMemoryInKilobytes )
  {
    RtlSetLastWin32Error(87);
    goto LABEL_41;
  }
  v5 = GetSystemFirmwareTable(0x52534D42u, 0, 0, 0);
  v6 = v5;
  if ( v5 )
  {
    v7 = v5;
    v8 = GetProcessHeap();
    v9 = RtlAllocateHeap(v8, 8u, v7);
    v41 = v9;
    if ( v9 )
    {
      v10 = GetSystemFirmwareTable(0x52534D42u, 0, v9, v6);
      if ( v10 )
      {
        v11 = (int)((char *)v41 + 8);
        v12 = (unsigned int)((char *)v41 + v10);
        while ( v11 < v12 )
        {
          if ( v11 + 4 > v12 )
            goto LABEL_24;
          if ( *(_BYTE *)v11 == 16 )
          {
            v1 = *(_BYTE *)(v11 + 1);
            if ( v1 < 6u || v11 + (unsigned int)v1 > v12 )
              goto LABEL_24;
            if ( *(_BYTE *)(v11 + 5) == 3 )
            {
              v2 = GetProcessHeap();
              v3 = RtlAllocateHeap(v2, 8u, 0xCu);
              if ( !v3 )
                goto LABEL_41;
              *((_WORD *)v3 + 4) = *(_WORD *)(v11 + 2);
              v4 = v40;
              *(_DWORD *)v3 = &v39;
              *((_DWORD *)v3 + 1) = v4;
              *(_DWORD *)v4 = v3;
              v40 = v3;
            }
          }
          if ( *(_BYTE *)v11 == 17 )
          {
            v14 = *(_BYTE *)(v11 + 1);
            if ( v14 < 0x15u || v11 + (unsigned int)v14 > v12 )
              goto LABEL_24;
            v15 = GetProcessHeap();
            v16 = RtlAllocateHeap(v15, 8u, 0xCu);
            if ( !v16 )
              goto LABEL_41;
            *((_WORD *)v16 + 5) = *(_WORD *)(v11 + 12);
            *((_WORD *)v16 + 4) = *(_WORD *)(v11 + 4);
            v17 = Address;
            *(_DWORD *)v16 = &v37;
            *((_DWORD *)v16 + 1) = v17;
            *(_DWORD *)v17 = v16;
            Address = v16;
          }
          v13 = *(_BYTE *)(v11 + 1) + v11;
          if ( v13 >= v12 )
            goto LABEL_24;
          do
          {
            if ( !*(_WORD *)v13 )
              break;
            ++v13;
          }
          while ( v13 < v12 );
          v11 = v13 + 2;
        }
        if ( v11 == v12 && !*(_WORD *)(v11 - 2) )
        {
          v18 = (int)v37;
          if ( (int **)v37 != &v37 )
          {
            do
            {
              v19 = (int)v39;
              if ( (int **)v39 != &v39 )
              {
                do
                {
                  if ( *(_WORD *)(v18 + 8) == *(_WORD *)(v19 + 8) )
                    break;
                  v19 = *(_DWORD *)v19;
                }
                while ( (int **)v19 != &v39 );
                if ( (int **)v19 != &v39 )
                {
                  v20 = *(_WORD *)(v18 + 10);
                  if ( v20 == -1 )
                  {
                    v42 = 0;
                    goto LABEL_24;
                  }
                  if ( v20 )
                  {
                    if ( *(_WORD *)(v18 + 10) & 0x8000 )
                      v21 = v20 & 0x7FFF;
                    else
                      v21 = v20 << 10;
                    v42 = 1;
                    v36 += (unsigned int)v21;
                  }
                }
              }
              v18 = *(_DWORD *)v18;
            }
            while ( (int **)v18 != &v37 );
            if ( !v42 )
              goto LABEL_41;
            if ( v36 )
            {
              Buffer.dwLength = 64;
              if ( !GlobalMemoryStatusEx(&Buffer) )
              {
                v42 = 0;
                goto LABEL_41;
              }
              if ( HIDWORD(Buffer.ullTotalPhys) >> 10 < HIDWORD(v36)
                || HIDWORD(Buffer.ullTotalPhys) >> 10 <= HIDWORD(v36)
                && (unsigned int)(Buffer.ullTotalPhys >> 10) <= (unsigned int)v36 )
                goto LABEL_41;
              v42 = 0;
            }
          }
        }
LABEL_24:
        RtlSetLastWin32Error(13);
        goto LABEL_41;
      }
    }
  }
LABEL_41:
  v22 = (int *)Address;
  v23 = (void *)*((_DWORD *)Address + 1);
  Address = v23;
  *(_DWORD *)v23 = &v37;
  v24 = v22;
  if ( (int **)v22 != &v37 )
  {
    do
    {
      v25 = v24;
      v26 = GetProcessHeap();
      RtlFreeHeap(v26, 0, v25);
      v27 = (int *)Address;
      v28 = (void *)*((_DWORD *)Address + 1);
      Address = v28;
      *(_DWORD *)v28 = &v37;
      v24 = v27;
    }
    while ( (int **)v27 != &v37 );
  }
  while ( 1 )
  {
    v29 = (int *)v40;
    v40 = (PVOID)*((_DWORD *)v40 + 1);
    *(_DWORD *)v40 = &v39;
    if ( (int **)v29 == &v39 )
      break;
    v30 = v29;
    v31 = GetProcessHeap();
    RtlFreeHeap(v31, 0, v30);
  }
  if ( v41 )
  {
    v32 = v41;
    v33 = GetProcessHeap();
    RtlFreeHeap(v33, 0, v32);
    if ( v42 )
      *TotalMemoryInKilobytes = v36;
  }
  return v42;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E49020) --------------------------------------------------------
UINT __stdcall GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
{
  int v4; // eax@1
  PVOID v5; // eax@1
  PVOID v6; // esi@1
  NTSTATUS v7; // eax@2
  ULONG ReturnLength; // [sp+14h] [bp-24h]@1
  UINT v10; // [sp+18h] [bp-20h]@1
  NTSTATUS NtStatus; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  NtStatus = 0;
  ReturnLength = 0;
  v10 = 0;
  v4 = KernelBaseGetGlobalData();
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), BufferSize + 16);
  v6 = v5;
  ms_exc.registration.TryLevel = 0;
  if ( v5 )
  {
    *(_DWORD *)v5 = FirmwareTableProviderSignature;
    *((_DWORD *)v5 + 2) = FirmwareTableID;
    *((_DWORD *)v5 + 3) = BufferSize;
    *((_DWORD *)v5 + 1) = 1;
    v7 = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)76, v5, BufferSize + 16, &ReturnLength);
    NtStatus = v7;
    if ( v7 >= 0 || v7 == -1073741789 )
      v10 = *((_DWORD *)v6 + 3);
    if ( v7 >= 0 && pFirmwareTableBuffer )
    {
      ms_exc.registration.TryLevel = 1;
      memcpy(pFirmwareTableBuffer, (char *)v6 + 16, *((_DWORD *)v6 + 3));
      ms_exc.registration.TryLevel = 0;
      NtStatus = 0;
    }
  }
  else
  {
    NtStatus = -1073741670;
  }
  ms_exc.registration.TryLevel = -2;
  if ( v6 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
  BaseSetLastNTError(NtStatus);
  return v10;
}

//----- (77E4913D) --------------------------------------------------------
int __stdcall GetDigitRange(unsigned __int16 *a1, int a2)
{
  unsigned __int16 v2; // dx@1
  int v3; // ebx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@2
  unsigned __int16 v7; // di@2
  unsigned int v8; // ecx@6
  int result; // eax@6

  v2 = *a1;
  v3 = 0;
  v4 = (int)pDigitRanges;
  v5 = 55;
  if ( *a1 >= 0xDC00u && v2 <= 0xDFFFu && a2 )
  {
    if ( *(a1 - 1) != -10187 )
      return 0;
    v4 = (int)pSurrogateDigitRanges;
    v5 = 9;
  }
  do
  {
    v6 = (v5 + v3) >> 1;
    v7 = *(_WORD *)(v4 + 2 * v6);
    if ( v2 == v7 )
      break;
    if ( v2 >= v7 )
      v3 = v6 + 1;
    else
      v5 = v6 - 1;
  }
  while ( v3 <= v5 );
  v8 = v4 + 2 * (v6 & 0xFFFFFFFE);
  result = *(_WORD *)v8;
  if ( (unsigned __int16)result > v2 || *(_WORD *)(v8 + 2) < v2 )
    return 0;
  return result;
}
// 77E1BB40: using guessed type int pDigitRanges[29];
// 77E62690: using guessed type int pSurrogateDigitRanges[5];

//----- (77E491DE) --------------------------------------------------------
int __stdcall BasepCheckAppCompat(HANDLE FileHandle, int a2, int a3, int a4)
{
  signed int v4; // esi@5
  char Dst; // [sp+10h] [bp-23Ch]@1
  __int16 v7; // [sp+3Ch] [bp-210h]@1
  int v8; // [sp+3Eh] [bp-20Eh]@1
  int v9; // [sp+42h] [bp-20Ah]@1
  int v10; // [sp+46h] [bp-206h]@1
  __int16 v11; // [sp+4Ah] [bp-202h]@1
  int v12; // [sp+4Ch] [bp-200h]@1
  int v13; // [sp+50h] [bp-1FCh]@1
  int v14; // [sp+54h] [bp-1F8h]@1
  int v15; // [sp+58h] [bp-1F4h]@1
  int v16; // [sp+5Ch] [bp-1F0h]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+60h] [bp-1ECh]@1
  PVOID v18; // [sp+68h] [bp-1E4h]@1
  int v19; // [sp+6Ch] [bp-1E0h]@1
  int v20; // [sp+70h] [bp-1DCh]@1
  PVOID v21; // [sp+74h] [bp-1D8h]@1
  int v22; // [sp+78h] [bp-1D4h]@1
  int v23; // [sp+7Ch] [bp-1D0h]@1
  int v24; // [sp+80h] [bp-1CCh]@1
  char v25; // [sp+84h] [bp-1C8h]@1

  v13 = a3;
  v16 = a4;
  UnicodeString.Length = 0;
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v23 = 0;
  memset(&Dst, 0, 0x2Cu);
  v15 = 0;
  v21 = 0;
  v19 = 0;
  v18 = 0;
  v12 = 0;
  v14 = 0;
  v22 = 0;
  v24 = 0;
  memset(&v25, 0, 0x1C4u);
  v20 = 456;
  if ( !IsShimInfrastructureDisabled() )
  {
    if ( !(unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(a2, &UnicodeString, 0, &v7) )
    {
      v4 = -1073741766;
      goto LABEL_6;
    }
    JUMPOUT(
      BaseCheckAppcompatCacheEx(UnicodeString.Buffer, FileHandle, 0, (int)&v22, (int)&v20, (int)&v24),
      0,
      &loc_77E49499);
    if ( v22 & 0x100 )
    {
      v21 = &v24;
      v19 = v20;
      JUMPOUT(&loc_77E49499);
    }
    JUMPOUT(v22 & 0x200, 0, &loc_77E49499);
  }
  v4 = 0;
LABEL_6:
  BasepFreeAppCompatData(0, v18, v21);
  JUMPOUT(v23, 0, &loc_77E4953C);
  RtlReleaseRelativeName(&v7);
  RtlFreeUnicodeString(&UnicodeString);
  return v4;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);

//----- (77E49377) --------------------------------------------------------
DWORD __stdcall CheckElevation(LPCWSTR lpFileName, int a2, int a3, int a4, int a5)
{
  DWORD v5; // esi@1
  HANDLE v6; // ebx@1
  unsigned int v7; // eax@2
  char pvBuffer; // [sp+Ch] [bp-1Ch]@3
  int v10; // [sp+18h] [bp-10h]@1
  char v11[4]; // [sp+1Ch] [bp-Ch]@1
  char v12[4]; // [sp+24h] [bp-4h]@1

  v5 = 0;
  v10 = 0;
  *(_DWORD *)v11 = 0;
  *(_DWORD *)v12 = 0;
  v6 = CreateFileW(lpFileName, 0x80000000, 5u, 0, 3u, 0x80u, 0);
  if ( v6 == (HANDLE)-1 )
  {
    v5 = GetLastError();
  }
  else
  {
    v7 = BasepCheckAppCompat(v6, (int)lpFileName, (int)&v10, (int)v12);
    if ( (v7 & 0x80000000) != 0
      || (v7 = BasepCheckFusion((int)lpFileName, &pvBuffer), (v7 & 0x80000000) != 0)
      || (v7 = BaseCheckElevation(
                 (HANDLE)0xFFFFFFFF,
                 (LONG_PTR)lpFileName,
                 a2,
                 v10,
                 v11[0],
                 (int)&pvBuffer,
                 0,
                 v12[0],
                 a3,
                 a4,
                 a5),
          (v7 & 0x80000000) != 0) )
      v5 = RtlNtStatusToDosErrorNoTeb(v7);
    CloseHandle(v6);
  }
  return v5;
}

//----- (77E4941B) --------------------------------------------------------
int __stdcall BasepCheckFusion(int a1, PVOID pvBuffer)
{
  PVOID v2; // esi@1
  signed int v3; // ebx@1
  HANDLE v4; // edi@1
  bool v6; // zf@15
  bool v7; // sf@15
  unsigned __int8 v8; // of@15
  ACTCTXW pActCtx; // [sp+1D4h] [bp-20h]@1

  v2 = pvBuffer;
  memset(&pActCtx.dwFlags, 0, 0x1Cu);
  pActCtx.lpSource = (LPCWSTR)a1;
  v3 = 0;
  *(_DWORD *)pvBuffer = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 2) = 0;
  pActCtx.cbSize = 32;
  pActCtx.lpResourceName = (LPCWSTR)1;
  pActCtx.dwFlags = 8;
  v4 = CreateActCtxW(&pActCtx);
  if ( v4 == (HANDLE)-1 )
  {
    v3 = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
    if ( v3 <= -1073741701 )
    {
      if ( v3 == -1073741701 || v3 == -1073741811 || v3 == -1073741801 )
        return 0;
      if ( v3 <= -1073741774 )
        return v3;
      v8 = __OFSUB__(v3, -1073741772);
      v6 = v3 == -1073741772;
      v7 = v3 + 1073741772 < 0;
    }
    else
    {
      if ( v3 < -1073741687 )
        return v3;
      if ( v3 <= -1073741685 )
        return 0;
      if ( v3 <= -1072365568 )
        return v3;
      v8 = __OFSUB__(v3, -1072365566);
      v6 = v3 == -1072365566;
      v7 = v3 + 1072365566 < 0;
    }
    if ( !((unsigned __int8)(v7 ^ v8) | v6) )
      return v3;
    return 0;
  }
  if ( !QueryActCtxW(0x80000000, v4, 0, 5u, v2, 0xCu, (SIZE_T *)&pvBuffer) )
    v3 = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
  ReleaseActCtx(v4);
  return v3;
}

//----- (77E49657) --------------------------------------------------------
BOOL __stdcall WriteProcessMemoryStub(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
{
  return WriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

//----- (77E49667) --------------------------------------------------------
BOOL __stdcall GetUserPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
{
  return GetUserPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
}

//----- (77E49698) --------------------------------------------------------
BOOL __stdcall EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceNamesExW(hModule, lpType, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E496BB) --------------------------------------------------------
BOOL __stdcall Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte)
{
  LPTHREADENTRY32 v2; // edi@1
  NTSTATUS v3; // eax@3
  LPTHREADENTRY32 v4; // eax@4
  LARGE_INTEGER SectionOffset; // [sp+Ch] [bp-10h]@3
  ULONG ViewSize; // [sp+14h] [bp-8h]@3
  int v8; // [sp+18h] [bp-4h]@1

  v2 = lpte;
  v8 = 0;
  if ( !lpte || lpte->dwSize != 28 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lpte = 0;
  v3 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lpte,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  v4 = lpte;
  if ( lpte->th32OwnerProcessID )
  {
    qmemcpy(v2, (char *)lpte + lpte[1].dwSize, 0x1Cu);
    v4[1].tpBasePri = 1;
    v8 = 1;
  }
  else
  {
    memset(&v2->cntUsage, 0, v2->dwSize - 4);
    RtlSetLastWin32Error(18);
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lpte);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E4974B) --------------------------------------------------------
BOOL __stdcall Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte)
{
  LPTHREADENTRY32 v2; // edi@1
  BOOL v3; // esi@1
  NTSTATUS v4; // eax@3
  DWORD v5; // ecx@4
  char *v6; // esi@5
  LARGE_INTEGER SectionOffset; // [sp+8h] [bp-Ch]@3
  ULONG ViewSize; // [sp+10h] [bp-4h]@3

  v2 = lpte;
  v3 = 0;
  if ( !lpte || lpte->dwSize != 28 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lpte = 0;
  v4 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lpte,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = lpte[1].tpBasePri;
  if ( v5 >= lpte->th32OwnerProcessID )
  {
    RtlSetLastWin32Error(18);
  }
  else
  {
    v6 = (char *)&lpte[v5] + lpte[1].dwSize;
    lpte[1].tpBasePri = v5 + 1;
    qmemcpy(v2, v6, 0x1Cu);
    v3 = 1;
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lpte);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E4993A) --------------------------------------------------------
int __stdcall BaseRegMapClassRegistrationKey(int a1, int a2, HANDLE Handle, int a4, int a5, int a6, PHANDLE KeyHandle, int a8, int a9)
{
  int v9; // esi@1
  int v10; // ebx@1
  int result; // eax@1
  int v12; // esi@4
  int v13; // eax@7
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-8h]@3

  v9 = a4;
  v10 = 1;
  result = BaseRegOpenClassKeyFromLocation(a4, (void *)a1, a2, 0x2000000, 2, (char)Handle, (int)&Handle, a9);
  if ( result >= 0 )
  {
    v10 = 0;
    NtClose(Handle);
  }
  else if ( result != -1073741772 )
  {
    return result;
  }
  DestinationString.MaximumLength = **(_WORD **)(v9 + 16) + 128;
  DestinationString.Buffer = (PWCH)RtlAllocateHeap(
                                     NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                     0,
                                     DestinationString.MaximumLength);
  if ( DestinationString.Buffer )
  {
    v12 = BaseRegOpenClassKeyRoot(v9, KeyHandle, &DestinationString, v10, a9);
    if ( v12 < 0 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
      result = v12;
    }
    else
    {
      if ( *(_DWORD *)a6 )
      {
        if ( !v10 )
          *(_DWORD *)a6 = 0;
      }
      v13 = a5;
      *(_QWORD *)a5 = DestinationString;
      *(_DWORD *)a8 = v13;
      result = 0;
    }
  }
  else
  {
    result = -1073741801;
  }
  return result;
}

//----- (77E499F3) --------------------------------------------------------
int __stdcall BaseRegOpenClassKeyRoot(int a1, PHANDLE KeyHandle, PUNICODE_STRING DestinationString, int a4, int a5)
{
  PUNICODE_STRING v5; // ebx@1
  WCHAR *v6; // eax@1
  NTSTATUS v7; // eax@3
  int v8; // esi@4
  unsigned __int16 v9; // si@5
  NTSTATUS v10; // eax@6
  WCHAR *v11; // eax@8
  int result; // eax@11
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-2Ch]@5
  __int16 v14; // [sp+20h] [bp-14h]@5
  PWCH v15; // [sp+24h] [bp-10h]@5
  UNICODE_STRING SourceString; // [sp+28h] [bp-Ch]@2
  int v17; // [sp+30h] [bp-4h]@3
  int v18; // [sp+3Ch] [bp+8h]@7
  PUNICODE_STRING DestinationStringa; // [sp+44h] [bp+10h]@1

  v5 = DestinationString;
  v6 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  0,
                  DestinationString->MaximumLength);
  DestinationStringa = (PUNICODE_STRING)v6;
  if ( v6 )
  {
    SourceString.Buffer = v6;
    SourceString.MaximumLength = v5->MaximumLength;
    if ( a4 )
      v7 = BaseRegTranslateToMachineClassKey(a1, &SourceString, (int)&v17);
    else
      v7 = BaseRegTranslateToUserClassKey(a1, &SourceString, (int)&v17);
    v8 = v7;
    if ( v7 < 0 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationStringa);
      result = v8;
    }
    else
    {
      v9 = v17;
      v15 = SourceString.Buffer;
      ObjectAttributes.ObjectName = (PUNICODE_STRING)&v14;
      v14 = v17;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( a5 )
        v10 = NtOpenKeyTransacted(KeyHandle, 0x2000000, &ObjectAttributes, a5);
      else
        v10 = NtOpenKey(KeyHandle, 0x2000000u, &ObjectAttributes);
      v18 = v10;
      if ( v10 >= 0 )
      {
        SourceString.Length -= v9;
        v11 = &SourceString.Buffer[(unsigned int)v9 >> 1];
        SourceString.Buffer = v11;
        if ( 92 == *v11 )
        {
          SourceString.Length -= 2;
          SourceString.Buffer = v11 + 1;
        }
        RtlCopyUnicodeString(v5, &SourceString);
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationStringa);
      result = v18;
    }
  }
  else
  {
    result = -1073741670;
  }
  return result;
}
// 77DE1694: using guessed type int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E49B43) --------------------------------------------------------
NTSTATUS __stdcall LUAIsElevatedToken(HANDLE TokenHandle, int a2, ULONG ReturnLength)
{
  ULONG v3; // ebx@1
  NTSTATUS result; // eax@1
  int v5; // [sp+Ch] [bp-8h]@6
  int TokenInformation; // [sp+10h] [bp-4h]@1

  v3 = ReturnLength;
  *(_DWORD *)ReturnLength = 1;
  *(_DWORD *)a2 = 0;
  TokenInformation = 1;
  result = NtQueryInformationToken(TokenHandle, TokenElevationType, &TokenInformation, 4u, &ReturnLength);
  if ( result >= 0 )
  {
    if ( TokenInformation == 2
      || TokenInformation == 1
      && (*(_DWORD *)v3 = 0,
          result = NtQueryInformationToken(TokenHandle, TokenElevation, &v5, 4u, &ReturnLength),
          result >= 0 && v5) )
      *(_DWORD *)a2 = 1;
  }
  return result;
}

//----- (77E49BD2) --------------------------------------------------------
int __thiscall BasepCheckForElevatedCaller(void *this, HANDLE TokenHandle, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@2
  void *v6; // [sp+0h] [bp-4h]@1

  v6 = this;
  result = LUAGetUserType(TokenHandle, (ULONG)&TokenHandle);
  if ( result >= 0 )
  {
    v5 = a4;
    result = LUAShouldElevate((unsigned int)TokenHandle, *(_DWORD *)a4, (int)&v6);
    if ( v6 )
    {
      result = -1073740756;
    }
    else
    {
      if ( !TokenHandle
        || TokenHandle == HANDLE_FLAG_INHERIT && *(_DWORD *)v5
        || (unsigned int)((char *)TokenHandle - 16) <= 2 )
        *(_DWORD *)a3 &= 0xFFFFFFFD;
      *(_DWORD *)v5 = 0;
    }
  }
  return result;
}

//----- (77E49C22) --------------------------------------------------------
signed int __stdcall LUAShouldElevate(unsigned int a1, unsigned int a2, int a3)
{
  signed int v3; // ebx@8
  int v4; // esi@1
  int v5; // edi@1
  signed int v7; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  v4 = a1;
  v5 = a2;
  if ( a2 >= 3 )
    v5 = a2 - 16;
  if ( a1 >= 3 )
    v4 = a1 - 16;
  if ( !v4 )
    goto LABEL_4;
  if ( v4 != 1 )
  {
    if ( v4 != 2 )
    {
      v7 = -1073741637;
      goto LABEL_5;
    }
    v3 = v5 == 2;
    goto LABEL_9;
  }
  v3 = 1;
  if ( v5 == 1 || v5 == 2 )
  {
LABEL_9:
    *(_DWORD *)a3 = v3;
    goto LABEL_5;
  }
LABEL_4:
  *(_DWORD *)a3 = 0;
LABEL_5:
  if ( a2 - 16 <= 2 && a1 - 16 > 2 )
    *(_DWORD *)a3 = 1;
  return v7;
}

//----- (77E49C86) --------------------------------------------------------
NTSTATUS __stdcall LUAGetUserType(HANDLE TokenHandle, ULONG a2)
{
  unsigned int v2; // eax@10
  NTSTATUS v3; // edi@2
  ULONG v4; // esi@3
  ULONG ReturnLength; // [sp+8h] [bp-Ch]@2
  int v7; // [sp+Ch] [bp-8h]@2
  HANDLE Handle; // [sp+10h] [bp-4h]@1

  Handle = 0;
  if ( TokenHandle )
  {
LABEL_2:
    v3 = LUAIsElevatedToken(TokenHandle, (int)&v7, (ULONG)&ReturnLength);
    if ( v3 >= 0 )
    {
      v4 = a2;
      *(_DWORD *)a2 = v7 ? 0 : (ReturnLength == 0) + 1;
      v3 = LUAIsUIAToken(TokenHandle, (ULONG)&a2);
      if ( v3 >= 0 )
      {
        if ( a2 )
        {
          v2 = *(_DWORD *)v4;
          if ( *(_DWORD *)v4 < 0x10u || v2 >= 0x13 )
            v2 += 16;
          *(_DWORD *)v4 = v2;
        }
      }
    }
    if ( Handle )
      NtClose(Handle);
    return v3;
  }
  v3 = NtOpenThreadToken((HANDLE)0xFFFFFFFE, 8u, 0, &TokenHandle);
  if ( v3 == -1073741700 )
    v3 = NtOpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle);
  if ( v3 >= 0 )
  {
    Handle = TokenHandle;
    goto LABEL_2;
  }
  return v3;
}

//----- (77E49CF5) --------------------------------------------------------
NTSTATUS __stdcall LUAIsUIAToken(HANDLE TokenHandle, ULONG ReturnLength)
{
  ULONG v2; // esi@1
  NTSTATUS result; // eax@1

  v2 = ReturnLength;
  *(_DWORD *)ReturnLength = 0;
  ReturnLength = 4;
  result = NtQueryInformationToken(TokenHandle, TokenUIAccess, &TokenHandle, 4u, &ReturnLength);
  if ( result >= 0 )
    *(_DWORD *)v2 = TokenHandle != 0;
  return result;
}

//----- (77E49D33) --------------------------------------------------------
BOOL __stdcall SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  bDisablePriorityBoost = bDisablePriorityBoost != 0;
  v2 = NtSetInformationProcess(hProcess, ProcessPriorityBoost, &bDisablePriorityBoost, 4u);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E49DA6) --------------------------------------------------------
DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
{
  unsigned int v3; // esi@3
  int v4; // eax@5
  NTSTATUS v5; // eax@5
  int v6; // esi@6
  void *v7; // edi@6
  DWORD result; // eax@17
  PVOID v9; // eax@20
  __int16 v10; // [sp+10h] [bp-250h]@5
  PVOID v11; // [sp+14h] [bp-24Ch]@5
  DWORD v12; // [sp+18h] [bp-248h]@3
  int v13; // [sp+1Ch] [bp-244h]@20
  void *Dst; // [sp+20h] [bp-240h]@1
  STRING AnsiString; // [sp+24h] [bp-23Ch]@2
  LSA_UNICODE_STRING UnicodeString; // [sp+2Ch] [bp-234h]@2
  DWORD v17; // [sp+34h] [bp-22Ch]@2
  PVOID Address; // [sp+38h] [bp-228h]@1
  WCHAR szShortPath; // [sp+3Ch] [bp-224h]@3
  CPPEH_RECORD ms_exc; // [sp+248h] [bp-18h]@2

  Dst = lpszShortPath;
  Address = 0;
  if ( lpszLongPath )
  {
    AnsiString.Buffer = 0;
    UnicodeString.Buffer = 0;
    v17 = 0;
    ms_exc.registration.TryLevel = 0;
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszLongPath) )
    {
      Address = &szShortPath;
      v3 = GetShortPathNameW(UnicodeString.Buffer, &szShortPath, 0x104u);
      v12 = v3;
      if ( v3 >= 0x104 )
      {
        v13 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v13 + 0x200000, 2 * v12);
        Address = v9;
        if ( v9 )
        {
          v3 = GetShortPathNameW(UnicodeString.Buffer, (LPWSTR)v9, v12);
        }
        else
        {
          v3 = 0;
          RtlSetLastWin32Error(8);
        }
      }
      if ( v3 )
      {
        UnicodeString.MaximumLength = 2 * v3 + 2;
        v11 = Address;
        v10 = 2 * v3;
        v4 = KernelBaseGetGlobalData();
        v5 = (*(int (__stdcall **)(STRING *, __int16 *, signed int))(v4 + 28))(&AnsiString, &v10, 1);
        if ( v5 < 0 )
        {
          BaseSetLastNTError(v5);
          v17 = 0;
        }
        else
        {
          v6 = AnsiString.Length;
          v17 = AnsiString.Length;
          v7 = Dst;
          if ( Dst && cchBuffer > AnsiString.Length )
          {
            _memmove(Dst, AnsiString.Buffer, AnsiString.Length);
            *((_BYTE *)v7 + v6) = 0;
          }
          else
          {
            v17 = AnsiString.Length + 1;
          }
        }
      }
    }
    ms_exc.registration.TryLevel = -2;
    if ( UnicodeString.Buffer )
      RtlFreeUnicodeString(&UnicodeString);
    if ( AnsiString.Buffer )
      RtlFreeAnsiString(&AnsiString);
    if ( Address )
    {
      if ( Address != &szShortPath )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
    result = v17;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E49F3F) --------------------------------------------------------
bool __stdcall BaseUpdateAppcompatCache(PCWSTR SourceString, int a2, int a3)
{
  bool result; // al@2

  if ( a3 )
    result = BasepShimCacheRemoveEntry(SourceString, a2);
  else
    result = 0;
  return result;
}

//----- (77E49F59) --------------------------------------------------------
char __stdcall BaseQueryModuleData(PCWSTR SourceString, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [sp+Ch] [bp-1E0h]@1
  int v9; // [sp+10h] [bp-1DCh]@2
  int v10; // [sp+14h] [bp-1D8h]@1
  int v11; // [sp+18h] [bp-1D4h]@1
  int v12; // [sp+1Ch] [bp-1D0h]@1
  int v13; // [sp+20h] [bp-1CCh]@2

  v11 = a5;
  v12 = a6;
  v10 = a7;
  v8 = 456;
  if ( IsShimInfrastructureDisabled() )
    return 0;
  if ( !BaseCheckAppcompatCacheEx(SourceString, (HANDLE)0xFFFFFFFF, 0, (int)&v9, (int)&v8, (int)&v13) )
    return BasepQueryModuleData((int)SourceString, a2, a3, a4, v11, v12, v10);
  if ( !(v9 & 0x100) )
  {
    if ( v9 & 0x200 )
      return BasepQueryModuleData((int)SourceString, a2, a3, a4, v11, v12, v10);
    return 0;
  }
  if ( !SdbIsValidQueryResultLight((int)&v13) )
    return BasepQueryModuleData((int)SourceString, a2, a3, a4, v11, v12, v10);
  return BasepQueryModuleDataEx((int)SourceString, a2, a3, a4, v11, v12, v10, (int)&v13);
}

//----- (77E4A006) --------------------------------------------------------
char __stdcall BasepQueryModuleData(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  char result; // al@4
  int (__stdcall *v9)(int, int, int, int, int, int, int); // [sp+4h] [bp-4h]@2

  v7 = 0;
  if ( BasepSkipSetupShims() )
  {
    result = 0;
  }
  else
  {
    if ( BasepGetApphelpQueryModuleDataProc((int)&v9) >= 0 )
      v7 = v9(a1, a2, a3, a4, a5, a6, a7);
    result = v7;
  }
  return result;
}

//----- (77E4A04F) --------------------------------------------------------
NTSTATUS __stdcall BasepGetApphelpQueryModuleDataProc(int a1)
{
  NTSTATUS result; // eax@1
  int v2; // eax@2

  result = sub_77E32826();
  if ( result >= 0 )
  {
    v2 = RtlDecodeSystemPointer(dword_77EA6064);
    *(_DWORD *)a1 = v2;
    if ( v2 )
      result = 0;
    else
      result = -1073741823;
  }
  return result;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E4A0AD) --------------------------------------------------------
EXECUTION_STATE __stdcall SetThreadExecutionState(EXECUTION_STATE esFlags)
{
  NTSTATUS v1; // eax@1
  EXECUTION_STATE result; // eax@2
  EXECUTION_STATE PreviousFlags; // [sp+0h] [bp-4h]@1

  PreviousFlags = 0;
  v1 = NtSetThreadExecutionState(esFlags, &PreviousFlags);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    result = PreviousFlags;
  }
  return result;
}

//----- (77E4A0D8) --------------------------------------------------------
DWORD __stdcall FormatMessageAStub(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
{
  return FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
}

//----- (77E4A5FF) --------------------------------------------------------
LONG __usercall sub_77E4A5FF@<eax>(int a1@<ebp>)
{
  struct _EXCEPTION_POINTERS *v1; // eax@1

  v1 = *(struct _EXCEPTION_POINTERS **)(a1 - 20);
  *(_DWORD *)(a1 - 28) = v1->ExceptionRecord->ExceptionCode;
  return UnhandledExceptionFilter(v1);
}

//----- (77E4A610) --------------------------------------------------------
void __usercall __noreturn sub_77E4A610(int a1@<ebp>)
{
  RtlExitUserProcess(*(_DWORD *)(a1 - 28));
  __debugbreak();
  JUMPOUT(loc_77E4A61D);
}
// 77DE1710: using guessed type int __stdcall RtlExitUserProcess(_DWORD);

//----- (77E62D74) --------------------------------------------------------
UINT __stdcall LocalFlags(HLOCAL hMem)
{
  HLOCAL v1; // ebx@1
  int v2; // esi@8
  __int16 v3; // cx@9
  int v4; // ecx@9
  __int16 v5; // ax@9
  int v7; // [sp+14h] [bp-24h]@2
  void *v8; // [sp+18h] [bp-20h]@2
  int v9; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  v9 = 0x8000;
  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v1 = hMem;
  if ( (unsigned __int8)hMem & 4 )
    goto LABEL_18;
  v8 = 0;
  v7 = 0;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 0, hMem, &v8, &v7) )
  {
    if ( v8 && v7 & 0x200 )
      v1 = v8;
    else
      v9 = 0;
  }
  if ( (unsigned __int8)v1 & 4 )
  {
LABEL_18:
    v2 = (int)((char *)v1 - 4);
    if ( (unsigned __int8)RtlIsValidHandle(BaseHeapHandleTablePtr, (char *)v1 - 4) )
    {
      v3 = *(_WORD *)(v2 + 2);
      v4 = (unsigned __int8)v3;
      v9 = v4;
      v5 = *(_WORD *)v2;
      if ( *(_WORD *)v2 & 8 )
        v9 = v4 | 0x4000;
      if ( v5 & 4 )
        v9 |= 0xF00u;
    }
  }
  if ( v9 == 0x8000 )
    RtlSetLastWin32Error(6);
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  return v9;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE13A4: using guessed type int __stdcall RtlIsValidHandle(_DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6098: using guessed type int BaseHeapHandleTablePtr;

//----- (77E62EB5) --------------------------------------------------------
HLOCAL __stdcall LocalHandle(LPCVOID pMem)
{
  int v2; // [sp+14h] [bp-20h]@1
  LPCVOID v3; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@1

  RtlLockHeap(BaseHeap);
  ms_exc.registration.TryLevel = 1;
  v3 = 0;
  if ( (unsigned __int8)RtlGetUserInfoHeap(BaseHeap, 1, pMem, &v3, &v2) )
  {
    if ( !v3 || !(v2 & 0x200) )
      v3 = pMem;
  }
  else
  {
    RtlSetLastWin32Error(6);
  }
  ms_exc.registration.TryLevel = -2;
  RtlUnlockHeap(BaseHeap);
  return (HLOCAL)v3;
}
// 77DE139C: using guessed type int __stdcall RtlGetUserInfoHeap(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E62F95) --------------------------------------------------------
INT __stdcall LZStart()
{
  return 1;
}

//----- (77E62FA9) --------------------------------------------------------
char __stdcall BasepLoadAppInitDlls(HKEY hKey)
{
  int i; // eax@4
  char *v2; // eax@7
  PVOID v3; // esi@11
  const WCHAR *j; // ecx@16
  int Dst; // [sp+Ch] [bp-118h]@1
  HKEY v7; // [sp+10h] [bp-114h]@1
  DWORD dwFlags; // [sp+14h] [bp-110h]@1
  ULONG Size; // [sp+18h] [bp-10Ch]@1
  PVOID Address; // [sp+1Ch] [bp-108h]@4
  char v11; // [sp+20h] [bp-104h]@4

  v7 = hKey;
  dwFlags = 0;
  Size = 4;
  if ( !RegGetValueW(hKey, 0, L"RequireSignedAppInit_DLLs", 16, 0, &Dst, (size_t)&Size) && Dst )
    dwFlags = 128;
  Address = &v11;
  Size = 256;
  for ( i = RegGetValueW(hKey, 0, L"AppInit_DLLs", 2, 0, &v11, (size_t)&Size);
        i == 234;
        i = RegGetValueW(v7, 0, L"AppInit_DLLs", 2, 0, v2, (size_t)&Size) )
  {
    if ( Address != &v11 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    v2 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
    Address = v2;
    if ( !v2 )
      return (char)v2;
  }
  if ( !i )
  {
    v3 = Address;
    while ( 1 )
    {
      while ( *(_WORD *)v3 == 32 || *(_WORD *)v3 == 44 )
        v3 = (char *)v3 + 2;
      if ( !*(_WORD *)v3 )
        break;
      for ( j = (const WCHAR *)v3; *(_WORD *)v3 != 32; v3 = (char *)v3 + 2 )
      {
        if ( *(_WORD *)v3 == 44 )
          break;
        if ( !*(_WORD *)v3 )
          goto LABEL_22;
      }
      if ( *(_WORD *)v3 )
      {
        *(_WORD *)v3 = 0;
        v3 = (char *)v3 + 2;
      }
LABEL_22:
      LoadLibraryExW(j, 0, dwFlags);
    }
  }
  v2 = &v11;
  if ( Address != &v11 )
    LOBYTE(v2) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return (char)v2;
}

//----- (77E631A1) --------------------------------------------------------
int __stdcall ResetAccessDate(HANDLE hFile)
{
  int result; // eax@3
  FILETIME CreationTime; // [sp+0h] [bp-8h]@1

  CreationTime.dwLowDateTime = -1;
  CreationTime.dwHighDateTime = -1;
  if ( hFile )
  {
    if ( hFile != (HANDLE)-1 )
      result = SetFileTime(hFile, &CreationTime, &CreationTime, &CreationTime);
  }
  return result;
}

//----- (77E631D3) --------------------------------------------------------
signed int __stdcall ComputeRemainingSize(int a1, int a2)
{
  __int64 v2; // rcx@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@2
  __int64 v5; // kr00_8@3
  unsigned int v6; // edx@3
  unsigned int v7; // ecx@3
  signed int result; // eax@5

  HIDWORD(v2) = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 8);
  if ( SHIDWORD(v2) < 0
    || (v4 = *(_DWORD *)(a1 + 1068), (signed __int64)(__PAIR__(HIDWORD(v2), v3) + *(_DWORD *)(a1 + 1068)) < v4) )
  {
    RtlSetLastWin32Error(13);
    result = 0;
  }
  else
  {
    v5 = v4 - *(_QWORD *)(a1 + 1056);
    LODWORD(v2) = v5;
    v6 = (__PAIR__(HIDWORD(v5), v3) + v2) >> 32;
    v7 = v3 + v5;
    if ( *(_DWORD *)a1 == 9 )
    {
      v6 = (__PAIR__(v6, v7) - 8) >> 32;
      v7 -= 8;
    }
    *(_DWORD *)a2 = v7;
    *(_DWORD *)(a2 + 4) = v6;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6324E) --------------------------------------------------------
signed int __stdcall ComputeRequestSize(int a1, unsigned int a2, int a3)
{
  signed int result; // eax@1
  unsigned int v4; // eax@2
  __int64 v5; // [sp+0h] [bp-8h]@1

  result = ComputeRemainingSize(a1, (int)&v5);
  if ( result )
  {
    v4 = a2;
    if ( a2 >= v5 )
      v4 = v5;
    else
      HIDWORD(v5) = 0;
    *(_DWORD *)a3 = v4;
    result = 1;
  }
  return result;
}

//----- (77E63294) --------------------------------------------------------
int __stdcall ReportTransfer(int a1, int a2, unsigned int a3)
{
  int result; // eax@1

  *(_QWORD *)(a1 + 1056) += a3;
  result = a2;
  **(_DWORD **)(a2 + 4) += a3;
  *(_DWORD *)(result + 8) -= a3;
  *(_DWORD *)result += a3;
  return result;
}

//----- (77E632C0) --------------------------------------------------------
int __stdcall BackupReadBuffer(int a1, size_t Size)
{
  int v2; // edi@1

  v2 = Size;
  ComputeRequestSize(a1, *(_DWORD *)(Size + 8), (int)&Size);
  memcpy(*(void **)v2, (const void *)(*(_DWORD *)(a1 + 1056) + *(_DWORD *)(a1 + 1084) - *(_DWORD *)(a1 + 1068)), Size);
  return ReportTransfer(a1, v2, Size);
}

//----- (77E6330F) --------------------------------------------------------
int __stdcall BackupReadStream(HANDLE hFile, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead)
{
  int v3; // esi@1
  int v4; // edi@2
  int v5; // ecx@2
  int v6; // edx@2
  int v7; // eax@2
  int v8; // ecx@2
  int v10; // edx@6
  int v11; // edi@9
  BOOL v12; // eax@9
  LONG DistanceToMoveHigh; // [sp+10h] [bp-4h]@2
  HANDLE hFilea; // [sp+1Ch] [bp+8h]@9

  v3 = NumberOfBytesRead;
  if ( *(_BYTE *)(NumberOfBytesRead + 1096) )
  {
    v4 = *(_DWORD *)(NumberOfBytesRead + 1084) + *(_DWORD *)(NumberOfBytesRead + 1092);
    v5 = *(_DWORD *)(v4 + 8);
    v6 = *(_DWORD *)(v4 + 12);
    *(_DWORD *)(NumberOfBytesRead + 4) = 8;
    *(_DWORD *)(v3 + 8) = v5 + 8;
    *(_DWORD *)v3 = 9;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 1068) = 28;
    *(_DWORD *)(v3 + 12) = __CFADD__(v5, 8) + v6;
    v7 = v3 + 1048;
    *(_DWORD *)v7 = *(_DWORD *)v4;
    *(_DWORD *)(v7 + 4) = *(_DWORD *)(v4 + 4);
    v8 = *(_DWORD *)(v3 + 1048);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)(v3 + 1052);
    DistanceToMoveHigh = 0;
    *(_DWORD *)(v3 + 20) = v8;
    *(_BYTE *)(v3 + 1096) = 0;
    DistanceToMoveHigh = *(_DWORD *)(v4 + 4);
    if ( SetFilePointer(hFile, *(_DWORD *)v4, &DistanceToMoveHigh, 0) != *(_DWORD *)v4
      || DistanceToMoveHigh != *(_DWORD *)(v4 + 4) )
    {
      *(_BYTE *)(v3 + 1119) = 1;
      return 0;
    }
    return 1;
  }
  v10 = *(_DWORD *)(NumberOfBytesRead + 1060);
  if ( v10 <= 0 && (v10 < 0 || *(_DWORD *)(NumberOfBytesRead + 1056) < *(_DWORD *)(NumberOfBytesRead + 1068)) )
    return 1;
  v11 = nNumberOfBytesToRead;
  ComputeRequestSize(NumberOfBytesRead, *(_DWORD *)(nNumberOfBytesToRead + 8), (int)&nNumberOfBytesToRead);
  v12 = ReadFile(hFile, *(LPVOID *)v11, nNumberOfBytesToRead, &NumberOfBytesRead, 0);
  hFilea = (HANDLE)v12;
  if ( NumberOfBytesRead )
  {
    ReportTransfer(v3, v11, NumberOfBytesRead);
  }
  else if ( v12 && nNumberOfBytesToRead )
  {
    RtlSetLastWin32Error(1117);
    hFilea = 0;
  }
  return (int)hFilea;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E63431) --------------------------------------------------------
signed int __stdcall BackupTestRestartStream(int a1)
{
  signed int result; // eax@1
  int v2; // edx@3
  int v3; // eax@3
  int v4; // ecx@3
  int v5; // eax@9
  __int64 v6; // [sp+4h] [bp-8h]@1

  result = ComputeRemainingSize(a1, (int)&v6);
  if ( result )
  {
    if ( !v6 )
    {
      v2 = *(_DWORD *)(a1 + 1088);
      v3 = a1 + 1092;
      v4 = *(_DWORD *)(a1 + 1092);
      if ( v4 != v2 && !*(_BYTE *)(a1 + 1096) )
        *(_DWORD *)v3 = v4 + 16;
      if ( *(_DWORD *)v3 == v2 )
      {
        if ( !*(_BYTE *)(a1 + 1097) )
        {
          v5 = *(_DWORD *)(a1 + 1072);
          if ( v5 )
          {
            if ( v5 != -1 )
            {
              CloseHandle(*(HANDLE *)(a1 + 1072));
              *(_DWORD *)(a1 + 1072) = -1;
            }
          }
        }
        *(_DWORD *)(a1 + 1068) = 0;
        *(_BYTE *)(a1 + 1117) = 1;
        *(_BYTE *)(a1 + 1096) = 1;
        *(_DWORD *)(a1 + 1056) = 0;
        *(_DWORD *)(a1 + 1060) = 0;
        if ( !*(_BYTE *)(a1 + 1118) )
        {
          ++*(_DWORD *)(a1 + 1064);
          *(_DWORD *)a1 = mwStreamList[*(_DWORD *)(a1 + 1064)];
          *(_BYTE *)(a1 + 1116) = 0;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 1096) = 1;
        *(_DWORD *)(a1 + 1068) = 0;
        *(_DWORD *)(a1 + 1056) = 0;
        *(_DWORD *)(a1 + 1060) = 0;
      }
    }
    result = 1;
  }
  return result;
}
// 77E614DC: using guessed type int mwStreamList[];

//----- (77E6350E) --------------------------------------------------------
BOOL __stdcall BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
{
  int v6; // esi@1
  int v7; // edx@4
  DWORD v8; // ebx@8
  LONG v9; // edi@8
  signed __int64 v10; // rax@13
  DWORD v11; // ecx@14
  int v12; // eax@14
  unsigned __int64 v13; // kr08_8@17
  HANDLE v14; // eax@19
  unsigned __int64 v15; // kr10_8@25
  unsigned __int8 v16; // cf@25
  LONG v18; // [sp+8h] [bp-14h]@21
  __int64 v19; // [sp+Ch] [bp-10h]@7
  unsigned __int64 v20; // [sp+14h] [bp-8h]@1
  HANDLE hFilea; // [sp+24h] [bp+8h]@21
  BOOL lpContexta; // [sp+38h] [bp+1Ch]@10

  v6 = (int)*lpContext;
  *lpdwHighByteSeeked = 0;
  v20 = 0i64;
  *lpdwLowByteSeeked = 0;
  if ( v6 == -1 )
    return 0;
  if ( !v6 )
    return 0;
  if ( *(_BYTE *)(v6 + 1117) )
    return 0;
  v7 = *(_DWORD *)(v6 + 1060);
  if ( v7 <= 0 && (v7 < 0 || *(_DWORD *)(v6 + 1056) < *(_DWORD *)(v6 + 1068)) )
    return 0;
  if ( !ComputeRemainingSize(v6, (int)&v19) )
    return 0;
  v8 = dwLowBytesToSeek;
  v9 = dwHighBytesToSeek & 0x7FFFFFFF;
  if ( (signed __int64)__PAIR__(dwHighBytesToSeek & 0x7FFFFFFF, dwLowBytesToSeek) > v19 )
  {
    v9 = HIDWORD(v19);
    v8 = v19;
  }
  lpContexta = 1;
  if ( *(_DWORD *)v6 == 1 || *(_DWORD *)v6 == 4 )
    goto LABEL_19;
  if ( *(_DWORD *)v6 == 9 )
  {
    v10 = *(_QWORD *)(v6 + 1056);
    if ( v10 < 8 )
    {
      v11 = 8 - v10;
      v12 = -(((unsigned int)v10 > 8) + HIDWORD(v10));
      v20 = __PAIR__(v12, v11);
      if ( v12 > v9 || v12 >= v9 && v11 >= v8 )
      {
        v8 = 0;
        v9 = 0;
      }
      else
      {
        v13 = __PAIR__(v9, v8) - __PAIR__(v12, v11);
        v9 = (__PAIR__(v9, v8) - __PAIR__((unsigned int)v12, v11)) >> 32;
        v8 = v13;
      }
    }
LABEL_19:
    v14 = hFile;
    if ( *(_DWORD *)v6 != 1 )
      v14 = *(HANDLE *)(v6 + 1072);
    hFilea = v14;
    v19 = SetFilePointer(v14, 0, (PLONG)&v19 + 1, 1u);
    v18 = v9;
    SetFilePointer(hFilea, v8, &v18, 1u);
  }
  if ( dwHighBytesToSeek != v9 || dwLowBytesToSeek != v8 )
    lpContexta = 0;
  v15 = v20 + __PAIR__(v9, v8);
  v16 = __CFADD__(v20 + v8, *(_DWORD *)(v6 + 1056));
  *(_DWORD *)(v6 + 1056) += v20 + v8;
  *(_DWORD *)(v6 + 1060) += HIDWORD(v15) + v16;
  *lpdwLowByteSeeked = v15;
  *lpdwHighByteSeeked = HIDWORD(v15);
  if ( !BackupTestRestartStream(v6) )
    lpContexta = 0;
  if ( !lpContexta )
    RtlSetLastWin32Error(25);
  return lpContexta;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E63684) --------------------------------------------------------
signed int __stdcall BackupWriteHeader(int a1, int a2, unsigned int a3)
{
  int v3; // edx@1
  unsigned int v4; // edi@1
  bool v5; // cf@1
  int v6; // ecx@1
  size_t v7; // edi@1
  bool v8; // zf@11
  signed int result; // eax@15

  v3 = *(_DWORD *)(a1 + 1060);
  v4 = *(_DWORD *)(a1 + 1056);
  v5 = a3 < v4;
  v6 = a3 - v4;
  v7 = *(_DWORD *)(a2 + 8);
  if ( v5 + v3 > 0 || v5 + v3 >= 0 && v7 >= v6 )
    v7 = v6;
  if ( v7 >= 0x214 || v3 > 0 || v3 >= 0 && 532 - v7 < *(_DWORD *)(a1 + 1056) || v3 < 0 )
  {
    result = 0;
  }
  else
  {
    if ( v3 <= 0 )
      v8 = *(_DWORD *)(a1 + 1056) == 0;
    memcpy((void *)(a1 + *(_DWORD *)(a1 + 1056)), *(const void **)a2, v7);
    ReportTransfer(a1, a2, v7);
    if ( *(_DWORD *)(a1 + 1056) == a3 && !*(_DWORD *)(a1 + 1060) )
      *(_DWORD *)(a1 + 1068) = a3;
    result = 1;
  }
  return result;
}

//----- (77E63732) --------------------------------------------------------
int __stdcall BackupWriteSparse(int a1, DWORD nNumberOfBytesToWrite, int a3)
{
  int v3; // esi@1
  LONG v4; // ecx@2
  LONG v5; // eax@2
  int v6; // eax@3
  int result; // eax@7
  int v8; // eax@11
  int v9; // edi@15
  int v10; // eax@17
  BOOL v11; // ebx@19
  LONG DistanceToMoveHigh; // [sp+Ch] [bp-8h]@2
  DWORD NumberOfBytesWritten; // [sp+10h] [bp-4h]@19

  v3 = nNumberOfBytesToWrite;
  if ( *(_BYTE *)(nNumberOfBytesToWrite + 1096) )
  {
    v4 = *(_DWORD *)(nNumberOfBytesToWrite + 20);
    *(_DWORD *)(nNumberOfBytesToWrite + 1048) = *(_DWORD *)(nNumberOfBytesToWrite + 20);
    v5 = *(_DWORD *)(v3 + 24);
    *(_DWORD *)(v3 + 1052) = v5;
    DistanceToMoveHigh = v5;
    if ( *(_BYTE *)(v3 + 1097) )
      v6 = *(_DWORD *)(v3 + 1072);
    else
      v6 = a1;
    if ( SetFilePointer((HANDLE)v6, v4, &DistanceToMoveHigh, 0) != *(_DWORD *)(v3 + 1048)
      || DistanceToMoveHigh != *(_DWORD *)(v3 + 1052) )
      return 0;
    if ( *(_DWORD *)(v3 + 8) == 8 && !*(_DWORD *)(v3 + 12) )
    {
      if ( *(_BYTE *)(v3 + 1097) )
        v8 = *(_DWORD *)(v3 + 1072);
      else
        v8 = a1;
      SetEndOfFile((HANDLE)v8);
    }
    *(_BYTE *)(v3 + 1096) = 0;
  }
  v9 = a3;
  result = ComputeRequestSize(v3, *(_DWORD *)(a3 + 8), (int)&nNumberOfBytesToWrite);
  if ( result )
  {
    if ( *(_BYTE *)(v3 + 1097) )
      v10 = *(_DWORD *)(v3 + 1072);
    else
      v10 = a1;
    v11 = WriteFile((HANDLE)v10, *(LPCVOID *)v9, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
    ReportTransfer(v3, v9, NumberOfBytesWritten);
    result = v11;
  }
  return result;
}

//----- (77E63819) --------------------------------------------------------
int __stdcall BackupWriteStream(HANDLE FileHandle, DWORD nNumberOfBytesToWrite, int a3)
{
  int v3; // esi@1
  LONG v4; // eax@4
  int v5; // edi@6
  int result; // eax@6
  BOOL v7; // ebx@7
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-14h]@3
  int v9; // [sp+14h] [bp-Ch]@4
  LONG DistanceToMoveHigh; // [sp+18h] [bp-8h]@4
  DWORD NumberOfBytesWritten; // [sp+1Ch] [bp-4h]@7

  v3 = nNumberOfBytesToWrite;
  if ( *(_BYTE *)(nNumberOfBytesToWrite + 1117) )
  {
    if ( *(_BYTE *)(nNumberOfBytesToWrite + 4) & 8 )
    {
      NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x900C4u, 0, 0, 0, 0);
    }
    else
    {
      v4 = *(_DWORD *)(nNumberOfBytesToWrite + 8);
      DistanceToMoveHigh = *(_DWORD *)(nNumberOfBytesToWrite + 12);
      SetFilePointer(FileHandle, v4, &DistanceToMoveHigh, 0);
      SetEndOfFile(FileHandle);
      v9 = 0;
      DistanceToMoveHigh = 0;
      SetFilePointer(FileHandle, 0, &DistanceToMoveHigh, 0);
    }
    *(_BYTE *)(v3 + 1117) = 0;
  }
  v5 = a3;
  result = ComputeRequestSize(v3, *(_DWORD *)(a3 + 8), (int)&nNumberOfBytesToWrite);
  if ( result )
  {
    v7 = WriteFile(FileHandle, *(LPCVOID *)v5, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
    ReportTransfer(v3, v5, NumberOfBytesWritten);
    result = v7;
  }
  return result;
}

//----- (77E638CD) --------------------------------------------------------
int __stdcall BackupWriteAlternateData(int a1, DWORD nNumberOfBytesToWrite, int a3)
{
  DWORD v3; // esi@1
  __int16 v4; // ax@2
  DWORD v5; // edi@2
  void *v6; // eax@2
  NTSTATUS v7; // eax@6
  void *v9; // ST04_4@10
  void *v10; // eax@11
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-28h]@6
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+24h] [bp-10h]@6
  __int16 v13; // [sp+2Ch] [bp-8h]@2
  __int16 v14; // [sp+2Eh] [bp-6h]@2
  DWORD v15; // [sp+30h] [bp-4h]@2
  DWORD nNumberOfBytesToWritea; // [sp+40h] [bp+Ch]@2

  v3 = nNumberOfBytesToWrite;
  if ( *(_BYTE *)(nNumberOfBytesToWrite + 1117) )
  {
    v4 = *(_WORD *)(nNumberOfBytesToWrite + 16);
    v13 = v4;
    v14 = v4;
    v5 = nNumberOfBytesToWrite + 1072;
    v15 = nNumberOfBytesToWrite + 20;
    v6 = *(void **)(nNumberOfBytesToWrite + 1072);
    nNumberOfBytesToWritea = 0;
    if ( v6 != (void *)-1 )
    {
      CloseHandle(v6);
      *(_DWORD *)v5 = -1;
      *(_BYTE *)(v3 + 1097) = 0;
    }
    if ( *(_DWORD *)(v3 + 1120) & 0x400 )
      nNumberOfBytesToWritea = 0x200000;
    ObjectAttributes.RootDirectory = (HANDLE)a1;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v13;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v7 = NtCreateFile(
           (PHANDLE)(v3 + 1072),
           0x100002u,
           &ObjectAttributes,
           &IoStatusBlock,
           0,
           0x80u,
           7u,
           5u,
           nNumberOfBytesToWritea | 0x4020,
           0,
           0);
    if ( v7 < 0 )
    {
      BaseSetLastNTError(v7);
LABEL_8:
      *(_BYTE *)(v3 + 1119) = 1;
      return 0;
    }
    if ( *(_BYTE *)(v3 + 4) & 8 )
    {
      v9 = *(void **)v5;
      *(_BYTE *)(v3 + 1097) = 1;
      NtFsControlFile(v9, 0, 0, 0, &IoStatusBlock, 0x900C4u, 0, 0, 0, 0);
    }
  }
  v10 = *(void **)(v3 + 1072);
  if ( v10 == (void *)-1 )
    goto LABEL_8;
  return BackupWriteStream(v10, v3, a3);
}

//----- (77E639D1) --------------------------------------------------------
BOOL __stdcall BasepIsDataAttribute(unsigned int a1, int a2)
{
  return a1 > 0xC && !__wcsnicmp((const wchar_t *)(a2 + 2 * ((a1 - 12) >> 1)), L":$DATA", 6u);
}

//----- (77E63A1D) --------------------------------------------------------
PVOID __stdcall BackupAlloc(ULONG Size)
{
  int v1; // eax@1

  v1 = KernelBaseGetGlobalData();
  return RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v1 + 44) + 0x40000, Size);
}

//----- (77E63A4F) --------------------------------------------------------
int __stdcall GrowBuffer(int a1, ULONG Size)
{
  PVOID v2; // eax@2
  PVOID v3; // ebx@2

  if ( *(_DWORD *)(a1 + 4) < Size )
  {
    v2 = BackupAlloc(Size);
    v3 = v2;
    if ( !v2 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    memcpy(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
    FreePredefinedHandleUnit(*(PVOID *)(a1 + 8));
    *(_DWORD *)(a1 + 8) = v3;
    *(_DWORD *)(a1 + 4) = Size;
  }
  *(_DWORD *)a1 = Size;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E63AA7) --------------------------------------------------------
char __stdcall FreeBuffer(int a1)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 8);
  if ( v1 )
  {
    LOBYTE(v1) = FreePredefinedHandleUnit(*(PVOID *)(a1 + 8));
    *(_DWORD *)(a1 + 8) = 0;
  }
  return v1;
}

//----- (77E63ACB) --------------------------------------------------------
BOOLEAN __stdcall FreeContext(int a1)
{
  int v1; // esi@1
  void *v2; // edi@2
  BOOLEAN result; // al@5

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 != -1 )
  {
    FreeBuffer(v1 + 1076);
    FreeBuffer(v1 + 1104);
    ResetAccessDate(*(HANDLE *)(v1 + 1072));
    v2 = *(void **)(v1 + 1072);
    if ( v2 )
    {
      if ( v2 != (void *)-1 )
        CloseHandle(v2);
    }
    result = FreePredefinedHandleUnit((PVOID)v1);
    *(_DWORD *)a1 = -1;
  }
  return result;
}

//----- (77E63B28) --------------------------------------------------------
PVOID __stdcall AllocContext(ULONG Size)
{
  PVOID v1; // eax@1
  PVOID v2; // esi@1

  v1 = BackupAlloc(0x468u);
  v2 = v1;
  if ( !v1 )
    goto LABEL_10;
  memset(v1, 0, 0x468u);
  *((_BYTE *)v2 + 1117) = 1;
  if ( Size && !GrowBuffer((int)((char *)v2 + 1076), Size) )
  {
    FreePredefinedHandleUnit(v2);
    v2 = 0;
  }
  if ( !v2 )
LABEL_10:
    RtlSetLastWin32Error(8);
  return v2;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E63B8D) --------------------------------------------------------
int __stdcall BackupGetSparseMap(HANDLE hFile, int a2, int a3)
{
  DWORD v3; // eax@1
  int v4; // eax@2
  ULONG v5; // ST24_4@2
  void *v6; // ST20_4@2
  NTSTATUS v7; // eax@2
  int i; // eax@1
  int v9; // ecx@13
  int v10; // eax@16
  int result; // eax@16
  int v12; // eax@17
  __int64 InputBuffer; // [sp+Ch] [bp-28h]@1
  DWORD v14; // [sp+14h] [bp-20h]@1
  DWORD FileSizeHigh; // [sp+18h] [bp-1Ch]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-18h]@2
  unsigned __int64 v17; // [sp+24h] [bp-10h]@1
  ULONG Size; // [sp+2Ch] [bp-8h]@1
  char v19; // [sp+33h] [bp-1h]@1

  Size = 4096;
  v19 = 0;
  InputBuffer = 0i64;
  *(_DWORD *)(a2 + 1088) = 0;
  *(_DWORD *)(a2 + 1092) = 0;
  *(_BYTE *)(a2 + 1096) = 0;
  v3 = GetFileSize(hFile, &FileSizeHigh);
  v14 = v3;
  v17 = __PAIR__(FileSizeHigh, v3);
  for ( i = GrowBuffer(a2 + 1076, 0x1000u); i; i = GrowBuffer(a2 + 1076, Size) )
  {
    v4 = *(_DWORD *)(a2 + 1088);
    v5 = *(_DWORD *)(a2 + 1080) - v4;
    v6 = (void *)(v4 + *(_DWORD *)(a2 + 1084));
    IoStatusBlock.Information = 0;
    v7 = NtFsControlFile(hFile, 0, 0, 0, &IoStatusBlock, 0x940CFu, &InputBuffer, 0x10u, v6, v5);
    if ( v7 != -2147483643 && v7 < 0 )
      goto LABEL_6;
    if ( !IoStatusBlock.Information )
    {
      v19 = 1;
LABEL_6:
      if ( Size >= 0x10 )
        goto LABEL_10;
      goto LABEL_7;
    }
    *(_DWORD *)(a2 + 1088) += IoStatusBlock.Information;
    v12 = *(_DWORD *)(a2 + 1088) + *(_DWORD *)(a2 + 1084) - 16;
    InputBuffer = *(_QWORD *)v12;
    InputBuffer += *(_QWORD *)(v12 + 8);
    if ( (unsigned int)(*(_DWORD *)(a2 + 1088) + 16) <= *(_DWORD *)(a2 + 1080) )
      goto LABEL_10;
LABEL_7:
    Size += 4096;
  }
  *(_DWORD *)(a2 + 1088) = 0;
LABEL_10:
  if ( (v19 && v17 || *(_DWORD *)(a2 + 1088) >= 0x10u)
    && ((v9 = *(_DWORD *)(a2 + 1084), v19) || *(_QWORD *)v9 || *(_QWORD *)(v9 + 8) != v17) )
  {
    *(_DWORD *)(a2 + 1088) += 16;
    v10 = *(_DWORD *)(a2 + 1088) + v9 - 16;
    *(_QWORD *)v10 = v17;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_BYTE *)(a2 + 1096) = 1;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a2 + 1088) = 0;
    result = 0;
  }
  return result;
}

//----- (77E63D12) --------------------------------------------------------
int __stdcall BackupReadData(HANDLE hFile, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead)
{
  int v3; // eax@2
  DWORD v5; // eax@5
  DWORD v6; // [sp+8h] [bp-8h]@5
  DWORD FileSizeHigh; // [sp+Ch] [bp-4h]@5

  if ( *(_BYTE *)(NumberOfBytesRead + 1117) )
  {
    v3 = *(_DWORD *)(NumberOfBytesRead + 1120);
    if ( !(v3 & 0x4000) && !(v3 & 0x10) )
    {
      v5 = GetFileSize(hFile, &FileSizeHigh);
      v6 = v5;
      if ( __PAIR__(FileSizeHigh, v5) )
      {
        if ( v5 == -1 && GetLastError() )
          return 0;
        *(_DWORD *)NumberOfBytesRead = 1;
        *(_DWORD *)(NumberOfBytesRead + 4) = 0;
        *(_DWORD *)(NumberOfBytesRead + 16) = 0;
        *(_DWORD *)(NumberOfBytesRead + 1068) = 20;
        *(_BYTE *)(NumberOfBytesRead + 1117) = 0;
        if ( BackupGetSparseMap(hFile, NumberOfBytesRead, nNumberOfBytesToRead) )
        {
          *(_DWORD *)(NumberOfBytesRead + 8) = 0;
          *(_DWORD *)(NumberOfBytesRead + 12) = 0;
          *(_DWORD *)(NumberOfBytesRead + 4) = 8;
        }
        else
        {
          *(_DWORD *)(NumberOfBytesRead + 8) = v6;
          *(_DWORD *)(NumberOfBytesRead + 12) = FileSizeHigh;
          FileSizeHigh = 0;
          SetFilePointer(hFile, 0, (PLONG)&FileSizeHigh, 0);
        }
      }
    }
    return 1;
  }
  return BackupReadStream(hFile, NumberOfBytesRead, nNumberOfBytesToRead);
}

//----- (77E63DE1) --------------------------------------------------------
int __stdcall BackupReadAlternateData(HANDLE FileHandle, DWORD NumberOfBytesRead, DWORD nNumberOfBytesToRead)
{
  int v3; // eax@2
  ULONG *v5; // edi@6
  int i; // eax@6
  NTSTATUS v7; // eax@9
  int v8; // ecx@15
  int v9; // eax@15
  int v10; // eax@15
  int v11; // eax@17
  void *v12; // ecx@20
  int v13; // edi@21
  signed int v14; // ecx@21
  bool v15; // zf@21
  void *v16; // ST0C_4@31
  int v17; // edi@34
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-28h]@23
  struct _IO_STATUS_BLOCK v19; // [sp+24h] [bp-10h]@23
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+2Ch] [bp-8h]@9

  if ( *(_BYTE *)(NumberOfBytesRead + 1117) )
  {
    v3 = *(_DWORD *)(NumberOfBytesRead + 1120);
    if ( v3 & 0x4000 && !(v3 & 0x10) )
      return 1;
    if ( !*(_BYTE *)(NumberOfBytesRead + 1116) )
    {
      v5 = (ULONG *)(NumberOfBytesRead + 1104);
      for ( i = GrowBuffer(NumberOfBytesRead + 1104, 0x400u); i; i = GrowBuffer(NumberOfBytesRead + 1104, 2 * *v5) )
      {
        v7 = NtQueryInformationFile(
               FileHandle,
               &IoStatusBlock,
               *(PVOID *)(NumberOfBytesRead + 1112),
               *v5,
               FileStreamInformation);
        if ( v7 >= 0 && IoStatusBlock.Information )
        {
          *(_DWORD *)(NumberOfBytesRead + 1100) = 0;
          *(_BYTE *)(NumberOfBytesRead + 1116) = 1;
          goto LABEL_15;
        }
        if ( v7 != -2147483643 && v7 != -1073741789 )
          return 1;
      }
      return 0;
    }
LABEL_15:
    v8 = *(_DWORD *)(NumberOfBytesRead + 1100);
    v9 = *(_DWORD *)(NumberOfBytesRead + 1112);
    *(_DWORD *)(NumberOfBytesRead + 1072) = -1;
    v10 = v8 + v9;
    *(_BYTE *)(NumberOfBytesRead + 1117) = 0;
    if ( *(_DWORD *)(v10 + 4) >= 4u && *(_WORD *)(v10 + 26) == 58 )
    {
      v11 = *(_DWORD *)v10;
      if ( !v11 )
        return 1;
      *(_DWORD *)(NumberOfBytesRead + 1100) = v8 + v11;
    }
    *(_DWORD *)(NumberOfBytesRead + 8) = 1;
    return 1;
  }
  v12 = *(void **)(NumberOfBytesRead + 1072);
  if ( v12 == (void *)-1 )
  {
    v13 = *(_DWORD *)(NumberOfBytesRead + 1100) + *(_DWORD *)(NumberOfBytesRead + 1112);
    *(_DWORD *)(NumberOfBytesRead + 8) = 0;
    *(_DWORD *)(NumberOfBytesRead + 12) = 0;
    v14 = 0;
    v15 = (*(_DWORD *)(NumberOfBytesRead + 1120) & 0x400) == 0;
    LOWORD(IoStatusBlock.u.Status) = *(_WORD *)(v13 + 4);
    HIWORD(IoStatusBlock.u.Pointer) = IoStatusBlock.u.Status;
    IoStatusBlock.Information = v13 + 24;
    if ( !v15 )
      v14 = 0x200000;
    ObjectAttributes.RootDirectory = FileHandle;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&IoStatusBlock;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( NtOpenFile((PHANDLE)(NumberOfBytesRead + 1072), 0x100001u, &ObjectAttributes, &v19, 7u, v14 | 0x4020) >= 0 )
    {
      if ( LockFile(*(HANDLE *)(NumberOfBytesRead + 1072), 0, 0, 0xFFFFFFFF, 0xFFFFFFFF) )
      {
        *(_DWORD *)(NumberOfBytesRead + 4) = 0;
        *(_DWORD *)(NumberOfBytesRead + 16) = *(_DWORD *)(v13 + 4);
        *(_DWORD *)(NumberOfBytesRead + 1068) = *(_DWORD *)(v13 + 4) + 20;
        memcpy((void *)(NumberOfBytesRead + 20), (const void *)(v13 + 24), *(_DWORD *)(v13 + 4));
        if ( *(_DWORD *)v13 )
        {
          *(_DWORD *)(NumberOfBytesRead + 1100) += *(_DWORD *)v13;
          *(_BYTE *)(NumberOfBytesRead + 1118) = 1;
        }
        if ( BasepIsDataAttribute(*(_DWORD *)(v13 + 4), v13 + 24) )
        {
          v16 = *(void **)(NumberOfBytesRead + 1072);
          *(_DWORD *)NumberOfBytesRead = 4;
          if ( BackupGetSparseMap(v16, NumberOfBytesRead, nNumberOfBytesToRead) )
          {
            *(_DWORD *)(NumberOfBytesRead + 8) = 0;
            *(_DWORD *)(NumberOfBytesRead + 12) = 0;
            *(_DWORD *)(NumberOfBytesRead + 4) = 8;
          }
          else
          {
            *(_DWORD *)(NumberOfBytesRead + 8) = GetFileSize(
                                                   *(HANDLE *)(NumberOfBytesRead + 1072),
                                                   (LPDWORD)(NumberOfBytesRead + 12));
          }
        }
        return 1;
      }
    }
    else
    {
      *(_DWORD *)(NumberOfBytesRead + 1100) += *(_DWORD *)v13;
      if ( *(_DWORD *)v13 )
      {
        *(_DWORD *)(NumberOfBytesRead + 8) = 1;
        *(_BYTE *)(NumberOfBytesRead + 1118) = 1;
      }
    }
    RtlSetLastWin32Error(32);
    return 0;
  }
  v17 = *(_DWORD *)(NumberOfBytesRead + 1060);
  if ( v17 <= 0 && (v17 < 0 || *(_DWORD *)(NumberOfBytesRead + 1056) < *(_DWORD *)(NumberOfBytesRead + 1068))
    || *(_DWORD *)NumberOfBytesRead != 4 && *(_DWORD *)NumberOfBytesRead != 9 )
    return 1;
  return BackupReadStream(v12, NumberOfBytesRead, nNumberOfBytesToRead);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E64069) --------------------------------------------------------
int __stdcall BackupReadEaData(HANDLE FileHandle, int FileInformation, size_t Size)
{
  int v3; // esi@1
  ULONG *v4; // edi@2
  NTSTATUS v5; // eax@3
  ULONG_PTR v6; // ecx@4
  int result; // eax@8
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-8h]@3

  v3 = FileInformation;
  if ( *(_BYTE *)(FileInformation + 1117) )
  {
    v4 = (ULONG *)(FileInformation + 1076);
    while ( 1 )
    {
      v5 = NtQueryEaFile(FileHandle, &IoStatusBlock, *(PFILE_FULL_EA_INFORMATION *)(v3 + 1084), *v4, 0, 0, 0, 0, 1u);
      if ( v5 >= 0 )
      {
        v6 = IoStatusBlock.Information;
        if ( IoStatusBlock.Information )
          break;
      }
      if ( v5 != -2147483643 && v5 != -1073741789
        || NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 4u, FileEaInformation) < 0 )
        return 1;
      result = GrowBuffer(v3 + 1076, (unsigned int)(5 * FileInformation) >> 2);
      if ( !result )
      {
        *(_BYTE *)(v3 + 1119) = 1;
        return result;
      }
    }
    *(_BYTE *)(v3 + 1116) = 1;
    *(_DWORD *)v3 = 2;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 16) = 0;
    *(_DWORD *)(v3 + 1068) = 20;
    *(_DWORD *)(v3 + 8) = v6;
    *(_DWORD *)(v3 + 12) = 0;
    *(_BYTE *)(v3 + 1117) = 0;
  }
  else if ( *(_QWORD *)(FileInformation + 1056) >= (signed __int64)*(_DWORD *)(FileInformation + 1068) )
  {
    BackupReadBuffer(FileInformation, Size);
  }
  return 1;
}

//----- (77E64157) --------------------------------------------------------
int __stdcall BackupReadObjectId(HANDLE FileHandle, int a2, size_t Size)
{
  int result; // eax@2
  ULONG_PTR v4; // eax@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-8h]@4

  if ( *(_BYTE *)(a2 + 1117) )
  {
    result = GrowBuffer(a2 + 1076, 0x400u);
    if ( !result )
    {
      *(_BYTE *)(a2 + 1119) = 1;
      return result;
    }
    if ( NtFsControlFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           0x9009Cu,
           0,
           0,
           *(PVOID *)(a2 + 1084),
           *(_DWORD *)(a2 + 1076)) >= 0 )
    {
      v4 = IoStatusBlock.Information;
      *(_BYTE *)(a2 + 1116) = 1;
      *(_DWORD *)a2 = 7;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 1068) = 20;
      *(_DWORD *)(a2 + 8) = v4;
      *(_DWORD *)(a2 + 12) = 0;
      *(_BYTE *)(a2 + 1117) = 0;
    }
  }
  else if ( *(_QWORD *)(a2 + 1056) >= (signed __int64)*(_DWORD *)(a2 + 1068) )
  {
    BackupReadBuffer(a2, Size);
  }
  return 1;
}

//----- (77E64211) --------------------------------------------------------
int __stdcall BackupReadTxFsData(HANDLE FileHandle, int a2, size_t Size)
{
  ULONG *v3; // edi@2
  NTSTATUS v5; // eax@5
  ULONG_PTR v6; // eax@14
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-8h]@5

  if ( *(_BYTE *)(a2 + 1117) )
  {
    v3 = (ULONG *)(a2 + 1076);
    if ( !GrowBuffer(a2 + 1076, 0x400u) )
    {
LABEL_3:
      *(_BYTE *)(a2 + 1119) = 1;
      return 0;
    }
    v5 = NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x901F8u, 0, 0, *(PVOID *)(a2 + 1084), *v3);
    if ( v5 == -2147483643 )
    {
      if ( !GrowBuffer(a2 + 1076, **(_DWORD **)(a2 + 1084) - *v3) )
        goto LABEL_3;
      v5 = NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x901F8u, 0, 0, *(PVOID *)(a2 + 1084), *v3);
    }
    if ( v5 != -2145845207 && v5 != -1073741808 && v5 != -1073741822 && v5 != -1073741637 )
    {
      if ( v5 < 0 )
      {
        BaseSetLastNTError(v5);
        return 0;
      }
      v6 = IoStatusBlock.Information;
      *(_BYTE *)(a2 + 1116) = 1;
      *(_DWORD *)a2 = 10;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 1068) = 20;
      *(_DWORD *)(a2 + 8) = v6;
      *(_DWORD *)(a2 + 12) = 0;
      *(_BYTE *)(a2 + 1117) = 0;
    }
  }
  else if ( *(_QWORD *)(a2 + 1056) >= (signed __int64)*(_DWORD *)(a2 + 1068) )
  {
    BackupReadBuffer(a2, Size);
  }
  return 1;
}

//----- (77E64336) --------------------------------------------------------
int __stdcall BackupReadReparseData(HANDLE FileHandle, int a2, size_t Size)
{
  int result; // eax@2
  ULONG v4; // ST24_4@4
  void *v5; // ST20_4@4
  NTSTATUS v6; // eax@4
  int v7; // eax@12
  bool v8; // zf@12
  int v9; // eax@12
  __int64 v10; // rax@13
  int v11; // eax@15
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@4

  if ( !(*(_DWORD *)(a2 + 1120) & 0x400) )
    return 1;
  if ( *(_BYTE *)(a2 + 1117) )
  {
    v4 = *(_DWORD *)(a2 + 1076);
    v5 = *(void **)(a2 + 1084);
    HIWORD(IoStatusBlock.Information) = 0x4000;
    v6 = NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x900A8u, 0, 0, v5, v4);
    if ( v6 == -2147483643 || v6 == -1073741789 )
    {
      if ( !HIWORD(IoStatusBlock.Information) )
        HIWORD(IoStatusBlock.Information) = 0x4000;
      result = GrowBuffer(a2 + 1076, HIWORD(IoStatusBlock.Information));
      if ( !result )
      {
        *(_BYTE *)(a2 + 1119) = 1;
        return result;
      }
      v6 = NtFsControlFile(
             FileHandle,
             0,
             0,
             0,
             &IoStatusBlock,
             0x900A8u,
             0,
             0,
             *(PVOID *)(a2 + 1084),
             *(_DWORD *)(a2 + 1076));
    }
    if ( v6 >= 0 )
    {
      v7 = *(_DWORD *)(a2 + 1084);
      *(_BYTE *)(a2 + 1116) = 1;
      *(_DWORD *)a2 = 8;
      *(_DWORD *)(a2 + 4) = 0;
      *(_DWORD *)(a2 + 16) = 0;
      *(_DWORD *)(a2 + 1068) = 20;
      v8 = (*(_DWORD *)v7 & 0x80000000) == 0;
      v9 = *(_WORD *)(v7 + 4);
      if ( v8 )
        LODWORD(v10) = v9 + 24;
      else
        LODWORD(v10) = v9 + 8;
      v10 = (signed int)v10;
      *(_DWORD *)(a2 + 8) = v10;
      LODWORD(v10) = IoStatusBlock.Information;
      *(_DWORD *)(a2 + 12) = HIDWORD(v10);
      if ( *(_DWORD *)(a2 + 8) > (unsigned int)v10 )
      {
        *(_DWORD *)(a2 + 8) = v11;
        *(_DWORD *)(a2 + 12) = 0;
      }
      *(_BYTE *)(a2 + 1117) = 0;
    }
  }
  else if ( *(_QWORD *)(a2 + 1056) >= (signed __int64)*(_DWORD *)(a2 + 1068) )
  {
    BackupReadBuffer(a2, Size);
  }
  return 1;
}

//----- (77E64474) --------------------------------------------------------
int __stdcall BackupReadSecurityData(HANDLE Handle, int a2, ULONG ReturnLength)
{
  int result; // eax@2
  size_t *v4; // edi@4
  NTSTATUS v5; // eax@5
  void *v6; // ST10_4@14
  ULONG v7; // eax@14

  if ( *(_BYTE *)(ReturnLength + 12) )
  {
    if ( *(_BYTE *)(a2 + 1117) )
    {
      v4 = (size_t *)(a2 + 1076);
      while ( 1 )
      {
        memset(*(void **)(a2 + 1084), 0, *v4);
        v5 = NtQuerySecurityObject(Handle, 0x1Fu, *(PSECURITY_DESCRIPTOR *)(a2 + 1084), *v4, &ReturnLength);
        if ( v5 >= 0 )
          break;
        if ( v5 != -2147483643 && v5 != -1073741789 )
          v5 = NtQuerySecurityObject(Handle, 7u, *(PSECURITY_DESCRIPTOR *)(a2 + 1084), *v4, &ReturnLength);
        if ( v5 >= 0 )
          break;
        if ( v5 != -2147483643 && v5 != -1073741789 )
          goto LABEL_17;
        result = GrowBuffer(a2 + 1076, ReturnLength);
        if ( !result )
          return result;
      }
      v6 = *(void **)(a2 + 1084);
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)(a2 + 1116) = 1;
      *(_DWORD *)a2 = 3;
      *(_DWORD *)(a2 + 4) = 2;
      *(_DWORD *)(a2 + 1068) = 20;
      v7 = RtlLengthSecurityDescriptor(v6);
      *(_DWORD *)(a2 + 12) = 0;
      *(_DWORD *)(a2 + 8) = v7;
      *(_BYTE *)(a2 + 1117) = 0;
    }
    else if ( *(_QWORD *)(a2 + 1056) >= (signed __int64)*(_DWORD *)(a2 + 1068) )
    {
      BackupReadBuffer(a2, ReturnLength);
    }
LABEL_17:
    result = 1;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E64586) --------------------------------------------------------
BOOL __stdcall BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
{
  DWORD v7; // esi@1
  BOOL v8; // ebx@1
  int v10; // eax@13
  NTSTATUS v11; // eax@22
  int v12; // eax@25
  unsigned int v13; // edx@33
  unsigned int v14; // eax@33
  unsigned int v15; // edi@33
  unsigned __int64 v16; // kr00_8@36
  size_t v17; // edi@37
  char FileInformation; // [sp+Ch] [bp-40h]@22
  int v19; // [sp+2Ch] [bp-20h]@23
  void *Dst; // [sp+34h] [bp-18h]@1
  LPDWORD v21; // [sp+38h] [bp-14h]@1
  DWORD v22; // [sp+3Ch] [bp-10h]@1
  char v23; // [sp+40h] [bp-Ch]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+44h] [bp-8h]@22

  v23 = bProcessSecurity;
  v7 = (DWORD)*lpContext;
  Dst = lpBuffer;
  v8 = 0;
  v22 = nNumberOfBytesToRead;
  v21 = lpNumberOfBytesRead;
  if ( bAbort )
  {
    if ( !v7 )
      return 1;
LABEL_3:
    ResetAccessDate(hFile);
    FreeContext((int)lpContext);
    return 1;
  }
  *lpNumberOfBytesRead = 0;
  if ( v7 == -1 || !nNumberOfBytesToRead )
    return 1;
  if ( v7 )
  {
    if ( !mwStreamList[*(_DWORD *)(v7 + 1064)] )
      goto LABEL_3;
  }
  else
  {
    v7 = (DWORD)AllocContext(0x400u);
    if ( !v7 )
      return v8;
    v11 = NtQueryInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    if ( v11 < 0 )
    {
      BaseSetLastNTError(v11);
      return 0;
    }
    *(_DWORD *)(v7 + 1120) = v19;
  }
  *lpContext = (LPVOID)v7;
  do
  {
    if ( *(_BYTE *)(v7 + 1117) )
    {
      *(_DWORD *)(v7 + 8) = 0;
      *(_DWORD *)(v7 + 12) = 0;
      *(_DWORD *)(v7 + 1056) = 0;
      *(_DWORD *)(v7 + 1060) = 0;
      *(_DWORD *)(v7 + 1092) = 0;
      *(_DWORD *)(v7 + 1088) = 0;
      *(_BYTE *)(v7 + 1118) = 0;
    }
    v10 = *(_DWORD *)(v7 + 1064);
    v8 = 1;
    if ( mwStreamList[v10] == 1 )
    {
      v12 = BackupReadData(hFile, v7, (DWORD)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 2 )
    {
      v12 = BackupReadEaData(hFile, v7, (size_t)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 3 )
    {
      v12 = BackupReadSecurityData(hFile, v7, (ULONG)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 4 )
    {
      v12 = BackupReadAlternateData(hFile, v7, (DWORD)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 7 )
    {
      v12 = BackupReadObjectId(hFile, v7, (size_t)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 8 )
    {
      v12 = BackupReadReparseData(hFile, v7, (size_t)&Dst);
      goto LABEL_32;
    }
    if ( mwStreamList[v10] == 10 )
    {
      v12 = BackupReadTxFsData(hFile, v7, (size_t)&Dst);
LABEL_32:
      v8 = v12;
      goto LABEL_33;
    }
    *(_DWORD *)(v7 + 1064) = v10 + 1;
    *(_BYTE *)(v7 + 1117) = 1;
LABEL_33:
    v13 = *(_DWORD *)(v7 + 1060);
    v14 = *(_DWORD *)(v7 + 1068);
    v15 = *(_DWORD *)(v7 + 1056);
    if ( (signed int)v13 <= 0 && ((v13 & 0x80000000) != 0 || v15 < v14) )
    {
      v16 = v14 - __PAIR__(v13, v15);
      if ( (signed __int64)v16 >= v22 )
        v17 = v22;
      else
        v17 = v16;
      memcpy(Dst, (const void *)(v7 + *(_DWORD *)(v7 + 1056)), v17);
      ReportTransfer(v7, (int)&Dst, v17);
    }
    if ( *(_QWORD *)(v7 + 1056) >= (signed __int64)*(_DWORD *)(v7 + 1068) && !BackupTestRestartStream(v7) )
      return 0;
    if ( !v8 )
      return v8;
  }
  while ( mwStreamList[*(_DWORD *)(v7 + 1064)] && v22 );
  if ( !*v21 )
  {
    ResetAccessDate(hFile);
    FreeContext((int)lpContext);
  }
  return v8;
}
// 77E614DC: using guessed type int mwStreamList[];

//----- (77E647E4) --------------------------------------------------------
int __stdcall BackupWriteBuffer(size_t Size, int a2)
{
  int v2; // esi@1
  int result; // eax@4
  int v4; // edi@7
  __int64 v5; // [sp+4h] [bp-8h]@8

  v2 = Size;
  if ( *(_BYTE *)(Size + 1117) )
  {
    *(_BYTE *)(Size + 1117) = 0;
    if ( *(_DWORD *)(v2 + 12) )
    {
      RtlSetLastWin32Error(13);
      return 0;
    }
    if ( (signed __int64)*(_DWORD *)(v2 + 1076) < *(_QWORD *)(v2 + 8) && !GrowBuffer(v2 + 1076, *(_DWORD *)(v2 + 8)) )
      return 0;
  }
  v4 = a2;
  if ( ComputeRequestSize(v2, *(_DWORD *)(a2 + 8), (int)&Size)
    && (memcpy(
          (void *)(*(_DWORD *)(v2 + 1056) + *(_DWORD *)(v2 + 1084) - *(_DWORD *)(v2 + 1068)),
          *(const void **)v4,
          Size),
        ReportTransfer(v2, v4, Size),
        ComputeRemainingSize(v2, (int)&v5)) )
  {
    if ( v5 )
      result = 2;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6489C) --------------------------------------------------------
int __stdcall BackupWriteEaData(HANDLE FileHandle, size_t Size, int a3)
{
  int v3; // eax@1
  NTSTATUS v5; // eax@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@5

  v3 = BackupWriteBuffer(Size, a3) - 1;
  if ( v3 )
  {
    if ( v3 == 1 )
      return 1;
  }
  else
  {
    v5 = NtSetEaFile(FileHandle, &IoStatusBlock, *(PFILE_FULL_EA_INFORMATION *)(Size + 1084), *(_DWORD *)(Size + 8));
    if ( v5 >= 0 )
      return 1;
    BaseSetLastNTError(v5);
  }
  return 0;
}

//----- (77E648E7) --------------------------------------------------------
int __stdcall BackupWriteReparseData(HANDLE FileHandle, size_t Size, int a3)
{
  int v3; // eax@1
  NTSTATUS v5; // eax@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@5

  v3 = BackupWriteBuffer(Size, a3) - 1;
  if ( v3 )
  {
    if ( v3 == 1 )
      return 1;
  }
  else
  {
    *(_DWORD *)(Size + 1120) |= 0x400u;
    v5 = NtFsControlFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           0x900A4u,
           *(PVOID *)(Size + 1084),
           *(_DWORD *)(Size + 8),
           0,
           0);
    if ( v5 >= 0 )
      return 1;
    BaseSetLastNTError(v5);
  }
  return 0;
}

//----- (77E6494A) --------------------------------------------------------
int __stdcall BackupWriteObjectId(HANDLE FileHandle, size_t Size, int a3)
{
  int v3; // eax@1
  NTSTATUS v5; // eax@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@4

  v3 = BackupWriteBuffer(Size, a3) - 1;
  if ( v3 )
  {
    if ( v3 != 1 )
      return 0;
  }
  else
  {
    memset((void *)(*(_DWORD *)(Size + 1084) + 16), 0, 0x30u);
    v5 = NtFsControlFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           0x90098u,
           *(PVOID *)(Size + 1084),
           *(_DWORD *)(Size + 8),
           0,
           0);
    if ( v5 < 0 )
      BaseSetLastNTError(v5);
  }
  return 1;
}

//----- (77E649B8) --------------------------------------------------------
int __stdcall BackupWriteTxFsData(HANDLE FileHandle, size_t Size, int a3)
{
  int v3; // eax@1
  NTSTATUS v5; // eax@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@4

  v3 = BackupWriteBuffer(Size, a3) - 1;
  if ( v3 )
  {
    if ( v3 != 1 )
      return 0;
  }
  else
  {
    v5 = NtFsControlFile(
           FileHandle,
           0,
           0,
           0,
           &IoStatusBlock,
           0x90200u,
           *(PVOID *)(Size + 1084),
           *(_DWORD *)(Size + 8),
           0,
           0);
    if ( v5 < 0 )
      BaseSetLastNTError(v5);
  }
  return 1;
}

//----- (77E64A11) --------------------------------------------------------
int __stdcall BackupWriteSecurityData(HANDLE Handle, size_t Size, SECURITY_INFORMATION SecurityInformation)
{
  int v3; // eax@1
  int result; // eax@3
  __int16 v5; // ax@6
  int v6; // eax@12
  NTSTATUS v7; // ebx@14
  NTSTATUS v8; // eax@19
  signed int SecurityInformationa; // [sp+18h] [bp+10h]@6

  v3 = BackupWriteBuffer(Size, SecurityInformation) - 1;
  if ( v3 )
  {
    if ( v3 != 1 )
      return 0;
    return 1;
  }
  if ( !*(_BYTE *)(SecurityInformation + 12) )
    return 1;
  v5 = *(_WORD *)(*(_DWORD *)(Size + 1084) + 2);
  SecurityInformationa = 3;
  if ( v5 & 4 )
    SecurityInformationa = 7;
  if ( v5 & 0x10 )
    SecurityInformationa |= 0x18u;
  if ( *(_WORD *)(*(_DWORD *)(Size + 1084) + 2) & 0x400 )
    *(_WORD *)(*(_DWORD *)(Size + 1084) + 2) |= 0x100u;
  v6 = *(_DWORD *)(Size + 1084);
  if ( *(_WORD *)(v6 + 2) & 0x800 )
    *(_WORD *)(v6 + 2) |= 0x200u;
  v7 = NtSetSecurityObject(Handle, SecurityInformationa, *(PSECURITY_DESCRIPTOR *)(Size + 1084));
  if ( v7 >= 0 )
    goto LABEL_25;
  if ( SecurityInformationa & 8 )
    NtSetSecurityObject(Handle, 8u, *(PSECURITY_DESCRIPTOR *)(Size + 1084));
  if ( SecurityInformationa & 4 )
    v7 = NtSetSecurityObject(Handle, 4u, *(PSECURITY_DESCRIPTOR *)(Size + 1084));
  v8 = NtSetSecurityObject(Handle, 3u, *(PSECURITY_DESCRIPTOR *)(Size + 1084));
  if ( v7 >= 0 && (v7 = v8, v8 >= 0) )
  {
LABEL_25:
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v7);
    result = 0;
  }
  return result;
}

//----- (77E64B07) --------------------------------------------------------
int __stdcall BackupWriteLinkData(HANDLE FileHandle, size_t Size, int a3)
{
  int v3; // eax@1
  int v5; // eax@3
  int v6; // edi@3
  size_t v7; // ebx@3
  PVOID v8; // esi@8
  signed __int16 v9; // bx@11
  signed int v10; // ebx@13
  bool v11; // zf@13
  NTSTATUS v12; // edi@15
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-Ch]@8
  int v14; // [sp+Ch] [bp-4h]@10
  int v15; // [sp+20h] [bp+10h]@3

  v3 = BackupWriteBuffer(Size, a3) - 1;
  if ( v3 )
    return v3 == 1;
  v15 = 0;
  v5 = *(_DWORD *)(Size + 1084);
  v6 = 0;
  v7 = 2;
  while ( *(_WORD *)v5 )
  {
    if ( *(_WORD *)v5 == 92 )
    {
      ++v15;
      v6 = v5;
      v7 = 0;
    }
    v5 += 2;
    v7 += 2;
  }
  IoStatusBlock.Information = v7 + 16;
  v8 = BackupAlloc(v7 + 16);
  if ( !v8 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  v14 = v6 + 2;
  memcpy((char *)v8 + 12, (const void *)(v6 + 2), v7);
  *((_DWORD *)v8 + 2) = v7 - 2;
  if ( v15 <= 1 )
  {
    v9 = *(_WORD *)v6;
    v6 = v14;
  }
  else
  {
    v9 = 92;
  }
  *(_WORD *)v6 = 0;
  *((_DWORD *)v8 + 1) = CreateFileW(*(LPCWSTR *)(Size + 1084), 0xC0000000, 7u, 0, 3u, 0x2000080u, 0);
  *(_WORD *)v6 = v9;
  v10 = 1;
  v11 = *((_DWORD *)v8 + 1) == -1;
  *(_BYTE *)v8 = 1;
  if ( v11 )
  {
    RtlSetLastWin32Error(2);
  }
  else
  {
    v12 = NtSetInformationFile(FileHandle, &IoStatusBlock, v8, IoStatusBlock.Information, FileLinkInformation);
    CloseHandle(*((HANDLE *)v8 + 1));
    *((_DWORD *)v8 + 1) = -1;
    if ( v12 >= 0 )
    {
      if ( IoStatusBlock.Information == 3 )
        RtlSetLastWin32Error(183);
      else
        RtlSetLastWin32Error(0);
      goto LABEL_21;
    }
    BaseSetLastNTError(v12);
  }
  v10 = 0;
LABEL_21:
  FreePredefinedHandleUnit(v8);
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E64C40) --------------------------------------------------------
BOOL __stdcall BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
{
  LPVOID *v7; // ebx@1
  DWORD v8; // esi@1
  BOOL v9; // edi@1
  int v11; // eax@14
  unsigned int v12; // eax@15
  int v13; // eax@29
  int v14; // eax@30
  SECURITY_INFORMATION SecurityInformation; // [sp+Ch] [bp-18h]@1
  LPDWORD v16; // [sp+10h] [bp-14h]@1
  unsigned int v17; // [sp+14h] [bp-10h]@1
  char v18; // [sp+18h] [bp-Ch]@1
  __int64 v19; // [sp+1Ch] [bp-8h]@25

  v7 = lpContext;
  v8 = (DWORD)*lpContext;
  SecurityInformation = (SECURITY_INFORMATION)lpBuffer;
  v9 = 0;
  v17 = nNumberOfBytesToWrite;
  v16 = lpNumberOfBytesWritten;
  v18 = bProcessSecurity;
  if ( bAbort )
  {
    if ( v8 )
      FreeContext((int)lpContext);
    return 1;
  }
  *lpNumberOfBytesWritten = 0;
  if ( v8 == -1 )
    return 1;
  if ( v8 || (v8 = (DWORD)AllocContext(0)) != 0 )
  {
    *v7 = (LPVOID)v8;
    while ( 1 )
    {
      if ( !*(_DWORD *)(v8 + 1068) )
      {
        *(_BYTE *)(v8 + 1118) = 1;
        *(_BYTE *)(v8 + 1117) = 1;
        BackupWriteHeader(v8, (int)&SecurityInformation, 0x14u);
      }
      if ( !v17 )
        return 1;
      if ( *(_DWORD *)(v8 + 1068) == 20 )
      {
        v11 = *(_DWORD *)(v8 + 16);
        if ( v11 )
        {
          v12 = v11 + 20;
          if ( v12 < 0x14 || !BackupWriteHeader(v8, (int)&SecurityInformation, v12) )
          {
            RtlSetLastWin32Error(13);
            return 0;
          }
          if ( !v17 && (*(_DWORD *)v8 != 4 || (signed __int64)*(_DWORD *)(v8 + 1068) < *(_QWORD *)(v8 + 1056)) )
            return 1;
        }
        if ( *(_DWORD *)(v8 + 1068) == 20 && *(_DWORD *)v8 == 9 )
        {
          BackupWriteHeader(v8, (int)&SecurityInformation, 0x1Cu);
          if ( !v17 && *(_DWORD *)(v8 + 1068) == 20 )
            return 1;
        }
      }
      if ( !ComputeRequestSize(v8, v17, (int)&lpBuffer) || !ComputeRemainingSize(v8, (int)&v19) )
        return 0;
      if ( !*(_BYTE *)(v8 + 1119) || v19 )
      {
        v13 = *(_DWORD *)v8 - 1;
        *(_BYTE *)(v8 + 1119) = 0;
        switch ( v13 )
        {
          case 8:
            v14 = BackupWriteSparse((int)hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 0:
            v14 = BackupWriteStream(hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 3:
            v14 = BackupWriteAlternateData((int)hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 1:
            v14 = BackupWriteEaData(hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 6:
            v14 = BackupWriteObjectId(hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 9:
            v14 = BackupWriteTxFsData(hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 7:
            v14 = BackupWriteReparseData(hFile, v8, (int)&SecurityInformation);
            goto LABEL_31;
          case 2:
            v14 = BackupWriteSecurityData(hFile, v8, (SECURITY_INFORMATION)&SecurityInformation);
            goto LABEL_31;
          case 4:
            v14 = BackupWriteLinkData(hFile, v8, (int)&SecurityInformation);
LABEL_31:
            v9 = v14;
            break;
          default:
            RtlSetLastWin32Error(13);
            v9 = 0;
            break;
        }
        if ( !BackupTestRestartStream(v8) )
          return 0;
      }
      else
      {
        ReportTransfer(v8, (int)&SecurityInformation, (unsigned int)lpBuffer);
      }
      if ( !v9 )
        return v9;
      if ( !v17 )
      {
        if ( !*v16 )
          FreeContext((int)lpContext);
        return v9;
      }
    }
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E64EAE) --------------------------------------------------------
int __stdcall NotifySoundSentry()
{
  int result; // eax@1
  char v1; // [sp+0h] [bp-E4h]@4
  DWORD ModeFlags; // [sp+28h] [bp-BCh]@1

  result = GetConsoleDisplayMode(&ModeFlags);
  if ( !result )
    ModeFlags = 0;
  if ( !ModeFlags )
    result = CsrClientCallServer(&v1, 0, 65554, 4);
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E64F09) --------------------------------------------------------
BOOL __stdcall BeepImplementation(DWORD dwFreq, DWORD dwDuration)
{
  NotifySoundSentry();
  return Beep(dwFreq, dwDuration);
}

//----- (77E64F1E) --------------------------------------------------------
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ullOperand > 0xFFFFFFFF )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ullOperand;
    result = 0;
  }
  return result;
}

//----- (77E64F50) --------------------------------------------------------
NTSTATUS __stdcall BasepGetNameFromReg(PCWSTR SourceString, int a2, int a3, int a4)
{
  int v4; // esi@1
  NTSTATUS result; // eax@1
  unsigned int v6; // ecx@1

  v4 = a4;
  a4 = 2 * *(_DWORD *)a4;
  result = BasepGetValueFromReg(SourceString, a2, a3, (int)&a4);
  v6 = (unsigned int)a4 >> 1;
  *(_DWORD *)v4 = (unsigned int)a4 >> 1;
  if ( result >= 0 )
  {
    if ( !v6 || *(_WORD *)(a3 + 2 * v6 - 2) )
      result = -1073741595;
    else
      *(_DWORD *)v4 = v6 - 1;
  }
  return result;
}

//----- (77E64FA0) --------------------------------------------------------
BOOLEAN __stdcall BaseConvertCharFree(PVOID Address)
{
  BOOLEAN result; // al@2

  if ( Address )
    result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return result;
}

//----- (77E64FCB) --------------------------------------------------------
NTSTATUS __stdcall BaseSetNameInReg(PCWSTR SourceString, PCWSTR a2, PVOID Data)
{
  NTSTATUS result; // eax@1
  NTSTATUS v4; // esi@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-2Ch]@1
  LSA_UNICODE_STRING ValueName; // [sp+20h] [bp-14h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-Ch]@1
  HANDLE KeyHandle; // [sp+30h] [bp-4h]@1

  KeyHandle = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = NtOpenKey(&KeyHandle, 0x2001Fu, &ObjectAttributes);
  if ( result >= 0 )
  {
    RtlInitUnicodeString(&ValueName, a2);
    v4 = NtSetValueKey(KeyHandle, &ValueName, 0, 1u, Data, 2 * wcslen((const unsigned __int16 *)Data) + 2);
    if ( v4 >= 0 )
      NtFlushKey(KeyHandle);
    NtClose(KeyHandle);
    result = v4;
  }
  return result;
}

//----- (77E65077) --------------------------------------------------------
NTSTATUS __stdcall BaseSetMultiNameInReg(PCWSTR SourceString, PCWSTR a2, PVOID Data, ULONG DataSize)
{
  NTSTATUS result; // eax@1
  NTSTATUS v5; // edi@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-2Ch]@1
  LSA_UNICODE_STRING ValueName; // [sp+20h] [bp-14h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-Ch]@1
  HANDLE KeyHandle; // [sp+30h] [bp-4h]@1

  KeyHandle = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = NtCreateKey(&KeyHandle, 0x2001Fu, &ObjectAttributes, 0, 0, 0, 0);
  if ( result >= 0 )
  {
    RtlInitUnicodeString(&ValueName, a2);
    v5 = NtSetValueKey(KeyHandle, &ValueName, 0, 7u, Data, DataSize);
    if ( v5 >= 0 )
      NtFlushKey(KeyHandle);
    NtClose(KeyHandle);
    result = v5;
  }
  return result;
}

//----- (77E65111) --------------------------------------------------------
signed int __stdcall BasepGetMultiValueAddr(const unsigned __int16 *a1, unsigned int a2, int a3, int a4)
{
  const unsigned __int16 *v4; // ecx@1
  unsigned int v5; // ebx@1
  int v6; // edx@1
  signed int result; // eax@4

  v4 = a1;
  v5 = 0;
  v6 = 0;
  if ( a2 )
  {
    while ( *v4 )
    {
      v6 += wcslen(v4) + 1;
      ++v5;
      v4 += wcslen(v4) + 1;
      if ( v5 >= a2 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = 0;
    if ( *v4 )
    {
      *(_DWORD *)a3 = v4;
      *(_DWORD *)a4 = v6;
      return result;
    }
  }
  return 1168;
}

//----- (77E65183) --------------------------------------------------------
int __stdcall BaseGetMultiValueIndex(int a1, void *a2, int a3)
{
  signed int v3; // ebx@1
  unsigned int v4; // edi@1
  char v6; // [sp+Ch] [bp-Ch]@3
  int v7; // [sp+10h] [bp-8h]@1
  void *v8; // [sp+14h] [bp-4h]@1

  v8 = 0;
  v3 = 0;
  v4 = 0;
  v7 = 0;
  do
  {
    if ( v7 )
      break;
    v3 = BasepGetMultiValueAddr((const unsigned __int16 *)a1, v4, (int)&v8, (int)&v6);
    if ( !v3
      && wcslen((const unsigned __int16 *)v8) == wcslen((const unsigned __int16 *)a2)
      && !__memicmp(v8, a2, 2 * wcslen((const unsigned __int16 *)a2)) )
    {
      v7 = 1;
      *(_DWORD *)a3 = v4;
    }
    ++v4;
  }
  while ( !v3 );
  return v3;
}

//----- (77E65233) --------------------------------------------------------
signed int __stdcall BaseRemoveMultiValue(const unsigned __int16 *a1, unsigned int a2, int a3)
{
  signed int v3; // ebx@1
  signed int v4; // eax@2
  int v6; // [sp+Ch] [bp-10h]@1
  void *Src; // [sp+10h] [bp-Ch]@1
  void *Dst; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  Src = 0;
  Dst = 0;
  v6 = 0;
  v9 = 0;
  v3 = BasepGetMultiValueAddr(a1, a2, (int)&Dst, (int)&v6);
  if ( !v3 )
  {
    v4 = BasepGetMultiValueAddr(a1, a2 + 1, (int)&Src, (int)&v9);
    v3 = v4;
    if ( v4 )
    {
      if ( v4 == 1168 )
      {
        *(_DWORD *)a3 += -1 - wcslen((const unsigned __int16 *)Dst);
        a1[*(_DWORD *)a3] = 0;
        v3 = 0;
      }
    }
    else
    {
      _memmove(Dst, Src, 2 * (*(_DWORD *)a3 - v9));
      *(_DWORD *)a3 += v6 - v9;
      a1[*(_DWORD *)a3] = 0;
    }
  }
  return v3;
}

//----- (77E652E9) --------------------------------------------------------
int __stdcall BaseAddMultiValue(int a1, int a2, wchar_t *Src, int a4)
{
  wcscpy_s((wchar_t *)(a1 + 2 * a4), a2 - a4, Src);
  *(_WORD *)(a1 + 2 * (a4 + wcslen(Src)) + 2) = 0;
  return 0;
}

//----- (77E65335) --------------------------------------------------------
int __stdcall BaseValidateNetbiosName(ULONG MbSize)
{
  ULONG v1; // ebx@1
  size_t v2; // edi@1
  int result; // eax@7

  v1 = MbSize;
  v2 = wcslen((const unsigned __int16 *)MbSize);
  if ( RtlUnicodeToMultiByteSize(&MbSize, (PWCHAR)MbSize, 2 * v2) >= 0
    && MbSize
    && MbSize <= 0xF
    && _wcscspn(
         (const wchar_t *)v1,
         L"\"/\\[]:|<>+=;,?\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F") >= v2
    && *(_WORD *)v1 != 32
    && *(_WORD *)(2 * v2 + v1 - 2) != 32 )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E653AF) --------------------------------------------------------
signed int __stdcall BaseValidateFQDnsName(int a1)
{
  HMODULE v1; // eax@1
  HMODULE v2; // esi@1
  signed int result; // eax@3
  FARPROC v4; // eax@4
  int v5; // edi@6

  v1 = LoadLibraryW(L"DNSAPI.DLL");
  v2 = v1;
  if ( !v1 )
  {
    RtlSetLastWin32Error(1157);
    return 0;
  }
  v4 = GetProcAddress(v1, "DnsValidateName_W");
  if ( !v4 )
  {
    FreeLibrary(v2);
    RtlSetLastWin32Error(1154);
    return 0;
  }
  v5 = ((int (__stdcall *)(int, signed int))v4)(a1, 2);
  FreeLibrary(v2);
  if ( v5 && v5 != 9556 )
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E65426) --------------------------------------------------------
int __stdcall BaseSetNetbiosName(PVOID Data)
{
  NTSTATUS v2; // eax@3

  if ( !BaseValidateNetbiosName((ULONG)Data) )
    return 0;
  v2 = BaseSetNameInReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName",
         L"ComputerName",
         Data);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    return 0;
  }
  return 1;
}

//----- (77E65465) --------------------------------------------------------
int __stdcall BaseSetDnsName(PCWSTR SourceString)
{
  HMODULE v1; // eax@1
  HMODULE v2; // esi@1
  FARPROC v4; // eax@3
  int v5; // edi@5
  int v6; // eax@7
  int v7; // esi@12
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-10h]@11
  LSA_UNICODE_STRING UnicodeString; // [sp+Ch] [bp-8h]@11

  v1 = LoadLibraryW(L"DNSAPI.DLL");
  v2 = v1;
  if ( !v1 )
    return 0;
  v4 = GetProcAddress(v1, "DnsValidateName_W");
  if ( !v4 )
  {
    FreeLibrary(v2);
    return 0;
  }
  v5 = ((int (__stdcall *)(PCWSTR, signed int))v4)(SourceString, 3);
  FreeLibrary(v2);
  if ( v5 && v5 != 9556 )
  {
    v6 = -1073741811;
LABEL_8:
    BaseSetLastNTError(v6);
    return 0;
  }
  v6 = BaseSetNameInReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
         L"NV Hostname",
         (PVOID)SourceString);
  if ( v6 < 0 )
    goto LABEL_8;
  RtlInitUnicodeString(&DestinationString, SourceString);
  v6 = RtlDnsHostNameToComputerName(&UnicodeString, &DestinationString, 1);
  if ( v6 < 0 )
    goto LABEL_8;
  v7 = BaseSetNetbiosName(UnicodeString.Buffer);
  RtlFreeUnicodeString(&UnicodeString);
  return v7 != 0;
}
// 77DE1598: using guessed type int __stdcall RtlDnsHostNameToComputerName(_DWORD, _DWORD, _DWORD);

//----- (77E65521) --------------------------------------------------------
int __stdcall BaseSetDnsDomain(PVOID Data)
{
  int v1; // edi@1
  HMODULE v2; // eax@2
  HMODULE v3; // esi@2
  FARPROC v5; // eax@4
  signed int v6; // eax@9

  v1 = 0;
  if ( *(_WORD *)Data )
  {
    v2 = LoadLibraryW(L"DNSAPI.DLL");
    v3 = v2;
    if ( !v2 )
      return 0;
    v5 = GetProcAddress(v2, "DnsValidateName_W");
    if ( !v5 )
    {
      FreeLibrary(v3);
      return 0;
    }
    v1 = ((int (__stdcall *)(PVOID, _DWORD))v5)(Data, 0);
    FreeLibrary(v3);
  }
  if ( v1 && v1 != 9556 )
  {
    v6 = -1073741811;
LABEL_11:
    BaseSetLastNTError(v6);
    return 0;
  }
  v6 = BaseSetNameInReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
         L"NV Domain",
         Data);
  if ( v6 < 0 )
    goto LABEL_11;
  return 1;
}

//----- (77E655A8) --------------------------------------------------------
ULONG __stdcall BaseEnumAltDnsFQHostnames(int a1, int a2)
{
  signed int v2; // eax@1

  v2 = BasepGetNameFromReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
         (int)L"AlternateComputerNames",
         a1,
         a2);
  if ( v2 == -1073741772 )
  {
    v2 = 0;
    if ( a1 && *(_DWORD *)a2 > 0u )
    {
      *(_WORD *)a1 = 0;
      *(_DWORD *)a2 = 0;
    }
    else
    {
      *(_DWORD *)a2 = 1;
      v2 = -2147483643;
    }
  }
  return RtlNtStatusToDosError(v2);
}

//----- (77E655FD) --------------------------------------------------------
BOOL __stdcall SetComputerNameW(LPCWSTR lpComputerName)
{
  LPCWSTR v1; // edi@1
  size_t v2; // ebx@1
  NTSTATUS v3; // eax@9
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-2Ch]@7
  LSA_UNICODE_STRING ValueName; // [sp+24h] [bp-14h]@9
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-Ch]@7
  HANDLE KeyHandle; // [sp+34h] [bp-4h]@1

  KeyHandle = 0;
  v1 = lpComputerName;
  v2 = wcslen(lpComputerName);
  if ( RtlUnicodeToMultiByteSize((PULONG)&lpComputerName, (PWCHAR)lpComputerName, 2 * v2) >= 0
    && lpComputerName
    && (unsigned int)lpComputerName <= 0xF
    && _wcscspn(
         v1,
         L"\"/\\[]:|<>+=;,?\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F") >= v2
    && *v1 != 32
    && v1[v2 - 1] != 32 )
  {
    RtlInitUnicodeString(
      &DestinationString,
      L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName");
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    if ( NtOpenKey(&KeyHandle, 0x2001Fu, &ObjectAttributes) == -1073741772 )
    {
      RtlSetLastWin32Error(31);
    }
    else
    {
      RtlInitUnicodeString(&ValueName, L"ComputerName");
      v3 = NtSetValueKey(KeyHandle, &ValueName, 0, 1u, (PVOID)v1, 2 * wcslen(v1) + 2);
      if ( v3 >= 0 )
      {
        NtFlushKey(KeyHandle);
        NtClose(KeyHandle);
        return 1;
      }
      BaseSetLastNTError(v3);
      NtClose(KeyHandle);
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6573F) --------------------------------------------------------
BOOL __stdcall SetComputerNameA(LPCSTR lpComputerName)
{
  unsigned int v1; // eax@1
  NTSTATUS v2; // eax@3
  BOOL v3; // esi@5
  STRING DestinationString; // [sp+0h] [bp-10h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@3

  v1 = strlen(lpComputerName);
  if ( v1 && v1 <= 0xF )
  {
    RtlInitAnsiString(&DestinationString, lpComputerName);
    v2 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
    if ( v2 >= 0 )
    {
      v3 = SetComputerNameW(UnicodeString.Buffer);
      RtlFreeUnicodeString(&UnicodeString);
      return v3;
    }
    BaseSetLastNTError(v2);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E657B3) --------------------------------------------------------
BOOL __stdcall DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
{
  int v3; // ebx@2
  BOOL result; // eax@8
  LSA_UNICODE_STRING Destination; // [sp+Ch] [bp-3Ch]@1
  UNICODE_STRING SourceString; // [sp+14h] [bp-34h]@2
  STRING DestinationString; // [sp+1Ch] [bp-2Ch]@3
  __int16 v8; // [sp+24h] [bp-24h]@2

  if ( RtlCreateUnicodeStringFromAsciiz(&Destination, Hostname) )
  {
    v8 = 0;
    SourceString.Buffer = (PWCH)&v8;
    SourceString.Length = 0;
    SourceString.MaximumLength = 32;
    v3 = RtlDnsHostNameToComputerName(&SourceString, &Destination, 0);
    if ( v3 >= 0 )
    {
      DestinationString.Length = 0;
      DestinationString.MaximumLength = *(_WORD *)nSize;
      DestinationString.Buffer = ComputerName;
      v3 = RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0);
      if ( v3 >= 0 )
        *nSize = DestinationString.Length;
    }
    RtlFreeUnicodeString(&Destination);
  }
  else
  {
    v3 = -1073741801;
  }
  if ( v3 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}
// 77DE1598: using guessed type int __stdcall RtlDnsHostNameToComputerName(_DWORD, _DWORD, _DWORD);

//----- (77E65873) --------------------------------------------------------
int __stdcall BasepGetComputerNameFromNtPath(PSTRING String2, int a2, int a3, int a4)
{
  char *v4; // eax@3
  int v5; // esi@3
  PCHAR v6; // ebx@5
  WCHAR *v8; // eax@14
  NTSTATUS v9; // eax@20
  void *v10; // ebx@25
  NTSTATUS v12; // ebx@30
  unsigned int v13; // kr00_4@34
  char *v14; // ecx@39
  unsigned int v15; // edi@40
  USHORT v16; // cx@44
  unsigned int v17; // ebx@44
  LPDWORD v18; // edi@46
  void *v19; // esi@48
  LSA_UNICODE_STRING v20; // [sp+Ch] [bp-68Ch]@25
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+14h] [bp-684h]@25
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+2Ch] [bp-66Ch]@20
  STRING v23; // [sp+34h] [bp-664h]@1
  LPDWORD nSize; // [sp+3Ch] [bp-65Ch]@1
  void *Dst; // [sp+40h] [bp-658h]@1
  struct _STRING String1; // [sp+44h] [bp-654h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+4Ch] [bp-64Ch]@1
  HANDLE FileHandle; // [sp+54h] [bp-644h]@1
  int v29; // [sp+58h] [bp-640h]@1
  int FileInformation; // [sp+5Ch] [bp-63Ch]@20
  char v31; // [sp+62h] [bp-636h]@23
  __int16 OutputBuffer; // [sp+274h] [bp-424h]@30
  __int16 v33; // [sp+276h] [bp-422h]@36
  char v34; // [sp+278h] [bp-420h]@37
  WCHAR TargetPath; // [sp+480h] [bp-218h]@8
  __int16 v36; // [sp+4B4h] [bp-1E4h]@12
  __int16 v37; // [sp+4B6h] [bp-1E2h]@13
  wchar_t Str; // [sp+4B8h] [bp-1E0h]@14
  _DWORD DeviceName[2]; // [sp+68Ch] [bp-Ch]@1
  wchar_t v40; // [sp+690h] [bp-8h]@1

  FileHandle = (HANDLE)a2;
  Dst = (void *)a3;
  nSize = (LPDWORD)a4;
  String1.Length = 16;
  String1.MaximumLength = 18;
  DeviceName[0] = *(_DWORD *)L"A:";
  v23.Length = 8;
  v23.MaximumLength = 10;
  v40 = aA[2];
  v29 = 161;
  String1.Buffer = (PCHAR)L"\\??\\UNC\\";
  v23.Buffer = (PCHAR)L"\\??\\";
  RtlInitUnicodeString(&DestinationString, 0);
  if ( RtlPrefixString(&String1, String2, 1u) )
  {
    if ( String2->Length <= String1.Length )
      return v29;
    v4 = &String2->Buffer[2 * ((unsigned int)String1.Length >> 1)];
    v5 = String2->Length - String1.Length;
    goto LABEL_24;
  }
  if ( !RtlPrefixString(&v23, String2, 1u) )
    return 161;
  v6 = String2->Buffer;
  if ( *((_WORD *)v6 + 5) != 58 )
    return 161;
  LOWORD(DeviceName[0]) = *((_WORD *)v6 + 4);
  if ( (unsigned __int16)(LOWORD(DeviceName[0]) - 97) <= 0x19u )
    LOWORD(DeviceName[0]) -= 32;
  if ( !QueryDosDeviceW((LPCWSTR)DeviceName, &TargetPath, 0x105u) )
    return GetLastError();
  if ( &TargetPath == _wcsstr(&TargetPath, L"\\Device\\LanmanRedirector\\;")
    && LOWORD(DeviceName[0]) == v36
    && 58 == v37 )
  {
    v8 = _wcschr(&Str, 0x5Cu);
    DestinationString.Buffer = v8;
    if ( v8 )
    {
      v4 = (char *)(v8 + 1);
      DestinationString.Buffer = (PWCH)v4;
      v5 = 2 * (261 - ((v4 - (char *)&TargetPath) >> 1));
      goto LABEL_39;
    }
  }
  if ( &TargetPath == _wcsstr(&TargetPath, L"\\Device\\Harddisk")
    || &TargetPath == _wcsstr(&TargetPath, L"\\Device\\CdRom")
    || &TargetPath == _wcsstr(&TargetPath, L"\\Device\\Floppy") )
  {
    if ( GetComputerNameW((LPWSTR)Dst, nSize) )
      return 0;
    return GetLastError();
  }
  if ( &TargetPath != _wcsstr(&TargetPath, L"\\Device\\WinDfs\\") )
    return v29;
  v9 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x218u, FileNameInformation);
  if ( v9 < 0 )
    return RtlNtStatusToDosError(v9);
  v5 = FileInformation;
  v4 = &v31;
LABEL_24:
  DestinationString.Buffer = (PWCH)v4;
  if ( FileHandle == (HANDLE)-1 )
    goto LABEL_39;
  FileHandle = (HANDLE)-1;
  v10 = v4 - 2;
  RtlInitUnicodeString(&v20, L"\\Dfs");
  ObjectAttributes.ObjectName = &v20;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v9 = NtCreateFile(&FileHandle, 0x100000u, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 7u, 3u, 0xA0u, 0, 0);
  if ( v9 < 0 )
    return RtlNtStatusToDosError(v9);
  if ( 92 != *(_WORD *)v10 )
  {
    NtClose(FileHandle);
    return 161;
  }
  v12 = NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x600C0u, v10, v5 + 2, &OutputBuffer, 0x20Au);
  NtClose(FileHandle);
  if ( v12 >= 0 )
  {
    if ( OutputBuffer )
    {
      v13 = wcslen((const unsigned __int16 *)&OutputBuffer);
      if ( 2 * v13 < 6 || 92 != OutputBuffer || 92 != v33 )
        return 161;
      v4 = &v34;
      DestinationString.Buffer = (PWCH)&v34;
      v5 = 2 * v13 - 4;
      goto LABEL_39;
    }
  }
  else if ( v12 != -1073741772 )
  {
    return RtlNtStatusToDosError(v12);
  }
  v4 = (char *)DestinationString.Buffer;
LABEL_39:
  v14 = v4;
  if ( v5 )
  {
    v15 = 0;
    do
    {
      if ( *(_WORD *)v14 == 92 )
        break;
      if ( 46 == *(_WORD *)v14 )
        return 161;
      v14 += 2;
      v15 += 2;
    }
    while ( v15 < v5 );
  }
  v16 = (_WORD)v14 - (_WORD)v4;
  v17 = v16;
  DestinationString.MaximumLength = v16;
  DestinationString.Length = v16;
  if ( v16 < (unsigned int)v5 && v16 <= 0x1Eu )
  {
    v18 = nSize;
    if ( (unsigned int)v16 + 2 <= 2 * *nSize )
    {
      v19 = Dst;
      memcpy(Dst, v4, v16);
      v29 = 0;
      *v18 = v17 >> 1;
      *((_WORD *)v19 + (v17 >> 1)) = 0;
    }
    else
    {
      v29 = 111;
    }
  }
  return v29;
}
// 77E65DC8: using guessed type wchar_t a__[5];
// 77E65DD4: using guessed type wchar_t a__Unc[9];
// 77E65DE8: using guessed type wchar_t aA[3];

//----- (77E65DF3) --------------------------------------------------------
DWORD __thiscall BaseMultiByteToWideCharWithAlloc(ULONG this, LPCSTR lpMultiByteStr, int a3)
{
  DWORD result; // eax@2
  unsigned int v4; // kr00_4@3
  int v5; // eax@5
  WCHAR *v6; // eax@5
  ULONG Size; // [sp+0h] [bp-4h]@1

  Size = this;
  if ( !lpMultiByteStr )
  {
    *(_DWORD *)a3 = 0;
    return 0;
  }
  v4 = strlen(lpMultiByteStr);
  if ( ULongLongToULong(2i64 * (v4 + 1), &Size) < 0 )
    return 13;
  v5 = KernelBaseGetGlobalData();
  v6 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), Size);
  *(_DWORD *)a3 = v6;
  if ( !v6 )
    return 8;
  if ( MultiByteToWideChar(0, 0, lpMultiByteStr, v4 + 1, v6, v4 + 1) )
    result = 0;
  else
    result = GetLastError();
  return result;
}
// 77E65DF3: could not find valid save-restore pair for esi

//----- (77E65E89) --------------------------------------------------------
NTSTATUS __stdcall BaseCreateMultiValue(PCWSTR SourceString, PCWSTR a2, void *Src)
{
  unsigned int v3; // esi@1
  int v4; // eax@1
  PVOID v5; // esi@1
  NTSTATUS v6; // edi@2
  void *v7; // eax@3
  __int16 v8; // cx@4

  v3 = wcslen((const unsigned __int16 *)Src);
  v4 = KernelBaseGetGlobalData();
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), 2 * v3 + 4);
  if ( v5 )
  {
    v7 = Src;
    do
    {
      v8 = *(_WORD *)v7;
      v7 = (char *)v7 + 2;
    }
    while ( v8 );
    memcpy(v5, Src, 2 * (((_BYTE *)v7 - ((_BYTE *)Src + 2)) >> 1));
    *((_WORD *)v5 + wcslen((const unsigned __int16 *)Src)) = 0;
    *((_WORD *)v5 + wcslen((const unsigned __int16 *)Src) + 1) = 0;
    v6 = BaseSetMultiNameInReg(SourceString, a2, v5, 2 * wcslen((const unsigned __int16 *)Src) + 4);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  }
  else
  {
    v6 = -1073741801;
  }
  return v6;
}

//----- (77E65F74) --------------------------------------------------------
NTSTATUS __stdcall BaseAddMultiNameInReg(PCWSTR SourceString, PCWSTR a2, wchar_t *Src)
{
  PVOID v3; // edi@1
  int v4; // esi@1
  NTSTATUS v5; // eax@1
  NTSTATUS v6; // ebx@1
  int v7; // eax@4
  int v9; // [sp+Ch] [bp-8h]@8
  int v10; // [sp+10h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v10 = 0;
  v5 = BasepGetNameFromReg(SourceString, (int)a2, 0, (int)&v10);
  v6 = v5;
  if ( v5 == -1073741275 || v5 == -1073741772 )
    return BaseCreateMultiValue(SourceString, a2, Src);
  if ( v5 != -2147483643 )
    goto LABEL_7;
  v4 = wcslen(Src) + v10 + 1;
  v7 = KernelBaseGetGlobalData();
  v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), 2 * v4);
  if ( v3 )
  {
    v6 = BasepGetNameFromReg(SourceString, (int)a2, (int)v3, (int)&v10);
LABEL_7:
    if ( v6 >= 0 && BaseGetMultiValueIndex((int)v3, Src, (int)&v9) && !BaseAddMultiValue((int)v3, v4, Src, v10) )
      v6 = BaseSetMultiNameInReg(SourceString, a2, v3, 2 * (v10 + wcslen(Src)) + 4);
    goto LABEL_11;
  }
  v6 = -1073741801;
LABEL_11:
  if ( v3 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  return v6;
}

//----- (77E6609A) --------------------------------------------------------
int __stdcall BaseRemoveMultiNameFromReg(PCWSTR SourceString, PCWSTR a2, void *a3)
{
  signed int v3; // esi@1
  int v4; // eax@2
  int v5; // edi@2
  signed int v7; // [sp+8h] [bp-Ch]@1
  int v8; // [sp+Ch] [bp-8h]@1
  int v9; // [sp+10h] [bp-4h]@1

  v8 = 0;
  v9 = 0;
  v7 = 0;
  v3 = BasepGetNameFromReg(SourceString, (int)a2, 0, (int)&v9);
  if ( v3 == -2147483643 )
  {
    v4 = KernelBaseGetGlobalData();
    v5 = (int)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), 2 * v9);
    if ( v5 )
    {
      v3 = BasepGetNameFromReg(SourceString, (int)a2, v5, (int)&v9);
      if ( !RtlNtStatusToDosError(v3) )
      {
        do
        {
          if ( BaseGetMultiValueIndex(v5, a3, (int)&v8) )
            break;
          v7 = 1;
        }
        while ( !BaseRemoveMultiValue((const unsigned __int16 *)v5, v8, (int)&v9) );
        if ( v7 )
          v3 = BaseSetMultiNameInReg(SourceString, a2, (PVOID)v5, 2 * v9 + 2);
        else
          v3 = -1073741275;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v5);
    }
    else
    {
      v3 = -1073741801;
    }
  }
  return v3;
}

//----- (77E66187) --------------------------------------------------------
PVOID __stdcall BasepGetNameNonVolatileFromReg(int a1)
{
  PVOID v1; // ebx@1
  const WCHAR *v3; // esi@8
  int v4; // edi@8
  NTSTATUS v5; // eax@11
  int v6; // eax@12
  int v7; // [sp+Ch] [bp-4h]@1

  v1 = 0;
  v7 = 0;
  if ( a1 )
  {
    if ( a1 == 1 )
    {
LABEL_9:
      v3 = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
      v4 = (int)L"NV Hostname";
      goto LABEL_11;
    }
    if ( a1 == 2 )
    {
LABEL_8:
      v3 = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
      v4 = (int)L"NV Domain";
      goto LABEL_11;
    }
    if ( a1 != 4 )
    {
      if ( a1 != 5 )
      {
        if ( a1 != 6 )
          return 0;
        goto LABEL_8;
      }
      goto LABEL_9;
    }
  }
  v3 = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
  v4 = (int)L"ComputerName";
LABEL_11:
  v5 = BasepGetNameFromReg(v3, v4, 0, (int)&v7);
  if ( v5 == -2147483643 )
  {
    v6 = KernelBaseGetGlobalData();
    v1 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 2 * v7);
    if ( !v1 )
      return 0;
    v5 = BasepGetNameFromReg(v3, v4, (int)v1, (int)&v7);
  }
  if ( v5 < 0 )
  {
    if ( v1 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
    return 0;
  }
  return v1;
}

//----- (77E66249) --------------------------------------------------------
PVOID __stdcall BasepGetComputerNameExWRtlAlloc(COMPUTER_NAME_FORMAT NameType)
{
  PVOID v1; // esi@1
  int v2; // eax@3
  DWORD nSize; // [sp+4h] [bp-4h]@1

  v1 = 0;
  nSize = 0;
  if ( !GetComputerNameExW(NameType, 0, &nSize) && GetLastError() == 234 )
  {
    v2 = KernelBaseGetGlobalData();
    v1 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v2 + 44), 2 * nSize);
    if ( v1 )
    {
      if ( !GetComputerNameExW(NameType, (LPWSTR)v1, &nSize) )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
        v1 = 0;
      }
    }
  }
  return v1;
}

//----- (77E662CD) --------------------------------------------------------
PVOID __stdcall BasepGetNameNonVolatile(wchar_t *Src)
{
  void *v1; // edi@1
  int v2; // eax@7
  wchar_t *v3; // eax@12
  wchar_t v4; // cx@13
  unsigned int v5; // eax@16
  rsize_t v6; // esi@21
  int v7; // eax@21
  wchar_t *v8; // eax@21
  int v10; // [sp+8h] [bp-8h]@1
  PVOID Address; // [sp+Ch] [bp-4h]@7
  wchar_t *Srca; // [sp+18h] [bp+8h]@7

  v1 = 0;
  v10 = 0;
  if ( (signed int)Src < 0 )
    return v1;
  if ( (signed int)Src <= 2 )
    return BasepGetNameNonVolatileFromReg((int)Src);
  if ( Src != (wchar_t *)3 )
  {
    if ( (signed int)Src <= 3 )
      return v1;
    if ( (signed int)Src > 6 )
    {
      if ( Src != (wchar_t *)7 )
        return v1;
      goto LABEL_7;
    }
    return BasepGetNameNonVolatileFromReg((int)Src);
  }
LABEL_7:
  Srca = (wchar_t *)BasepGetNameNonVolatile((wchar_t *)1);
  v2 = BasepGetNameNonVolatile((wchar_t *)2);
  v1 = (void *)v2;
  Address = (PVOID)v2;
  if ( Srca )
  {
    if ( !v2 )
    {
      Address = BasepGetComputerNameExWRtlAlloc(ComputerNameDnsDomain);
      v1 = Address;
    }
  }
  else
  {
    if ( !v2 )
      return v1;
    Srca = (wchar_t *)BasepGetComputerNameExWRtlAlloc(ComputerNameDnsHostname);
  }
  v3 = Srca;
  if ( Srca )
  {
    do
    {
      v4 = *v3;
      ++v3;
    }
    while ( v4 );
    v10 = v3 - (Srca + 1);
  }
  if ( v1 && (v5 = wcslen((const unsigned __int16 *)v1)) != 0 && v10 )
  {
    if ( v5 == 1 && *(_WORD *)v1 == 46 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
      v5 = 0;
      Address = 0;
    }
    v6 = v5 + v10 + 2;
    v7 = KernelBaseGetGlobalData();
    v8 = (wchar_t *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), 2 * v6);
    v1 = v8;
    if ( v8 )
    {
      wcscpy_s(v8, v6, Srca);
      wcscat_s((wchar_t *)v1, v6, L".");
      if ( Address )
        wcscat_s((wchar_t *)v1, v6, (const wchar_t *)Address);
    }
    if ( Srca )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Srca);
  }
  else
  {
    v1 = Srca;
  }
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v1;
}

//----- (77E66460) --------------------------------------------------------
PVOID __stdcall BasepGetLatestName(wchar_t *Src)
{
  PVOID result; // eax@1

  result = BasepGetNameNonVolatile(Src);
  if ( result )
  {
    if ( *(_WORD *)result )
      return result;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, result);
  }
  return BasepGetComputerNameExWRtlAlloc((COMPUTER_NAME_FORMAT)Src);
}

//----- (77E6649B) --------------------------------------------------------
signed int __stdcall BaseValidateDns(void *a1, int a2)
{
  PVOID v2; // edi@1
  wchar_t *v3; // ebx@1
  rsize_t v4; // esi@14
  int v5; // eax@14
  signed int v7; // [sp+Ch] [bp-10h]@1
  PVOID Address; // [sp+10h] [bp-Ch]@1
  wchar_t *Src; // [sp+14h] [bp-8h]@1
  signed int v10; // [sp+18h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  Src = 0;
  Address = 0;
  v7 = 0;
  v10 = 1;
  if ( a2 )
  {
    if ( a2 == 1 )
    {
      v2 = a1;
      Src = (wchar_t *)BasepGetLatestName((wchar_t *)1);
      Address = Src;
    }
    else
    {
      RtlSetLastWin32Error(1359);
      v10 = 0;
    }
  }
  else
  {
    Src = (wchar_t *)a1;
    v2 = BasepGetLatestName((wchar_t *)2);
    Address = v2;
  }
  if ( !a1 )
  {
    RtlSetLastWin32Error(87);
    v10 = 0;
  }
  if ( v10 && v2 )
  {
    if ( 46 != *(_WORD *)v2 || *((_WORD *)v2 + 1) )
      v7 = 1;
    if ( Src )
    {
      v4 = wcslen((const unsigned __int16 *)v2) + wcslen(Src) + v7 + 1;
      v5 = KernelBaseGetGlobalData();
      v3 = (wchar_t *)RtlAllocateHeap(
                        NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                        *(_DWORD *)(v5 + 44),
                        2 * v4);
      if ( !v3 )
      {
        RtlSetLastWin32Error(8);
        v10 = 0;
      }
      if ( v10 )
      {
        wcscpy_s(v3, v4, Src);
        if ( 46 != *(_WORD *)v2 || *((_WORD *)v2 + 1) )
          wcscat_s(v3, v4, L".");
        wcscat_s(v3, v4, (const wchar_t *)v2);
        if ( !BaseValidateFQDnsName((int)v3) )
        {
          RtlSetLastWin32Error(87);
          v10 = 0;
        }
      }
    }
  }
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v3 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6662C) --------------------------------------------------------
signed int __stdcall BaseValidateDnsHostname(void *a1)
{
  return BaseValidateDns(a1, 0);
}

//----- (77E6665C) --------------------------------------------------------
wchar_t *__stdcall BaseParseDnsName(wchar_t *Str, int a2)
{
  wchar_t *result; // eax@2
  size_t v3; // eax@3
  size_t v4; // ebx@3
  unsigned int v5; // esi@4
  int v6; // eax@8
  wchar_t *v7; // edi@8
  rsize_t v8; // esi@9
  rsize_t v9; // [sp-Ch] [bp-10h]@9

  if ( Str )
  {
    v3 = _wcscspn(Str, L".");
    v4 = v3;
    if ( a2 )
    {
      if ( v3 == wcslen(Str) )
        v5 = 0;
      else
        v5 = wcslen(Str) - v4 - 1;
    }
    else
    {
      v5 = v3;
    }
    v6 = KernelBaseGetGlobalData();
    result = (wchar_t *)RtlAllocateHeap(
                          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                          *(_DWORD *)(v6 + 44),
                          2 * v5 + 2);
    v7 = result;
    if ( result )
    {
      v9 = v5;
      v8 = v5 + 1;
      if ( a2 )
        wcsncpy_s(result, v8, &Str[v4 + 1], v9);
      else
        wcsncpy_s(result, v8, Str, v9);
      result = v7;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E66713) --------------------------------------------------------
int __stdcall BaseSetAltNetBiosName(ULONG MbSize)
{
  NTSTATUS v2; // eax@4

  if ( !BaseValidateNetbiosName(MbSize) )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v2 = BaseAddMultiNameInReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
         L"OptionalNames",
         (wchar_t *)MbSize);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    return 0;
  }
  return 1;
}

//----- (77E66757) --------------------------------------------------------
int __stdcall BaseSetAltDnsFQHostname(wchar_t *Src)
{
  NTSTATUS v1; // eax@1
  int result; // eax@2

  v1 = BaseAddMultiNameInReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
         L"AlternateComputerNames",
         Src);
  if ( v1 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  return result;
}

//----- (77E66788) --------------------------------------------------------
int __stdcall BaseIsAltDnsFQHostname(void *a1)
{
  int v1; // ebx@1
  int v2; // eax@2
  PVOID v3; // eax@2
  NTSTATUS v4; // eax@3
  int v6; // [sp+Ch] [bp-Ch]@4
  PVOID Address; // [sp+10h] [bp-8h]@2
  int v8; // [sp+14h] [bp-4h]@1

  v1 = 0;
  v8 = 0;
  if ( BasepGetNameFromReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
         (int)L"AlternateComputerNames",
         0,
         (int)&v8) == -2147483643 )
  {
    v2 = KernelBaseGetGlobalData();
    v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v2 + 44), 2 * v8);
    Address = v3;
    if ( v3 )
    {
      v4 = BasepGetNameFromReg(
             L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
             (int)L"AlternateComputerNames",
             (int)v3,
             (int)&v8);
      if ( !RtlNtStatusToDosError(v4) )
        v1 = BaseGetMultiValueIndex((int)Address, a1, (int)&v6) == 0;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
  }
  return v1;
}

//----- (77E66830) --------------------------------------------------------
int __stdcall BaseRemoveAltNetBiosName(void *a1)
{
  NTSTATUS v1; // eax@1
  int result; // eax@2

  v1 = BaseRemoveMultiNameFromReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
         L"OptionalNames",
         a1);
  if ( v1 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  return result;
}

//----- (77E66861) --------------------------------------------------------
int __stdcall BaseIsNetBiosNameInUse(wchar_t *a1)
{
  NTSTATUS v1; // eax@1
  ULONG v2; // eax@1
  int v3; // eax@2
  PVOID v4; // eax@2
  NTSTATUS v6; // eax@4
  unsigned int v7; // edi@8
  signed int v8; // esi@9
  int v9; // eax@12
  WCHAR *v10; // eax@12
  char v11; // [sp+Ch] [bp-20h]@9
  int v12; // [sp+10h] [bp-1Ch]@1
  int v13; // [sp+14h] [bp-18h]@1
  LPCWSTR Hostname; // [sp+18h] [bp-14h]@1
  int v15; // [sp+1Ch] [bp-10h]@1
  LPWSTR ComputerName; // [sp+20h] [bp-Ch]@1
  PVOID Address; // [sp+24h] [bp-8h]@1
  DWORD nSize; // [sp+28h] [bp-4h]@1

  Address = 0;
  v15 = 0;
  Hostname = 0;
  ComputerName = 0;
  nSize = 0;
  v12 = 0;
  v13 = 1;
  v1 = BasepGetNameFromReg(
         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
         (int)L"AlternateComputerNames",
         0,
         (int)&v15);
  v2 = RtlNtStatusToDosError(v1);
  if ( v2 == 234 )
  {
    v3 = KernelBaseGetGlobalData();
    v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 2 * v15);
    Address = v4;
    if ( !v4 )
    {
      RtlSetLastWin32Error(8);
      return 1;
    }
    v6 = BasepGetNameFromReg(
           L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
           (int)L"AlternateComputerNames",
           (int)v4,
           (int)&v15);
    v2 = RtlNtStatusToDosError(v6);
  }
  if ( v2 )
    goto LABEL_24;
  if ( !Address )
    return 0;
  v7 = 0;
  do
  {
    v8 = BasepGetMultiValueAddr((const unsigned __int16 *)Address, v7, (int)&Hostname, (int)&v11);
    if ( v8 )
      goto LABEL_20;
    if ( DnsHostnameToComputerNameW(Hostname, ComputerName, &nSize) )
      goto LABEL_31;
    v8 = GetLastError();
    if ( v8 == 234 )
    {
      ++nSize;
      v9 = KernelBaseGetGlobalData();
      v10 = (WCHAR *)RtlAllocateHeap(
                       NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                       *(_DWORD *)(v9 + 44),
                       2 * nSize);
      ComputerName = v10;
      if ( !v10 )
      {
        v8 = 8;
        goto LABEL_20;
      }
      if ( DnsHostnameToComputerNameW(Hostname, v10, &nSize) )
        v8 = 0;
      else
        v8 = GetLastError();
    }
    if ( !v8 )
    {
LABEL_31:
      if ( !__wcsicmp(ComputerName, a1) )
        v12 = 1;
    }
LABEL_20:
    ++v7;
  }
  while ( !v8 );
  if ( v8 == 1168 )
    v13 = v12;
  else
    v13 = 1;
LABEL_24:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( ComputerName )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ComputerName);
  return v13;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E66A17) --------------------------------------------------------
BOOL __stdcall SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
{
  BOOL result; // eax@2
  size_t v3; // eax@3
  int v4; // eax@13

  if ( !lpBuffer )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v3 = wcslen(lpBuffer);
  if ( v3 && (*lpBuffer == 32 || lpBuffer[v3 - 1] == 32)
    || _wcscspn(
         lpBuffer,
         L"\"/\\[]:|<>+=;,?\x01\x02\x03\x04\x05\x06\a\b\t\n\v\f\r\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F") < v3 )
    goto LABEL_10;
  if ( NameType == 4 )
  {
    result = BaseSetNetbiosName((PVOID)lpBuffer);
  }
  else
  {
    if ( NameType == 5 )
    {
      if ( !BaseValidateDnsHostname((void *)lpBuffer) )
        return 0;
      v4 = BaseSetDnsName(lpBuffer);
    }
    else
    {
      if ( NameType != 6 )
      {
LABEL_10:
        RtlSetLastWin32Error(87);
        return 0;
      }
      if ( !BaseValidateDnsDomain(lpBuffer) )
        return 0;
      v4 = BaseSetDnsDomain((PVOID)lpBuffer);
    }
    if ( !v4 )
      return 0;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E66644: using guessed type _DWORD __stdcall BaseValidateDnsDomain(_DWORD);

//----- (77E66AC1) --------------------------------------------------------
BOOL __stdcall SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  BOOL v4; // esi@3
  STRING DestinationString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@1

  RtlInitAnsiString(&DestinationString, lpBuffer);
  v2 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  if ( v2 >= 0 )
  {
    v4 = SetComputerNameExW(NameType, UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v4;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E66B18) --------------------------------------------------------
ULONG __stdcall AddLocalAlternateComputerNameW(LPCWSTR Hostname, int a2)
{
  NTSTATUS v2; // eax@4
  ULONG v3; // edi@4
  int v4; // eax@7
  WCHAR *v5; // esi@7
  ULONG result; // eax@14
  DWORD nSize; // [sp+8h] [bp-4h]@1

  nSize = 0;
  if ( Hostname && !a2 && BaseValidateFQDnsName((int)Hostname) )
  {
    v2 = BaseAddMultiNameInReg(
           L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
           L"AlternateComputerNames",
           (wchar_t *)Hostname);
    v3 = RtlNtStatusToDosError(v2);
    if ( !v3 && !DnsHostnameToComputerNameW(Hostname, 0, &nSize) )
    {
      v3 = GetLastError();
      if ( v3 == 234 )
      {
        ++nSize;
        v4 = KernelBaseGetGlobalData();
        v5 = (WCHAR *)RtlAllocateHeap(
                        NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                        *(_DWORD *)(v4 + 44),
                        2 * nSize);
        if ( v5 )
        {
          if ( DnsHostnameToComputerNameW(Hostname, v5, &nSize) && BaseSetAltNetBiosName((ULONG)v5) )
            v3 = 0;
          else
            v3 = GetLastError();
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
        }
        else
        {
          v3 = 8;
        }
      }
    }
    result = v3;
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E66C03) --------------------------------------------------------
DWORD __thiscall AddLocalAlternateComputerNameA(ULONG this, LPCSTR lpMultiByteStr, int a3)
{
  DWORD result; // eax@2
  DWORD v4; // esi@3
  PVOID Address; // [sp+0h] [bp-4h]@1

  Address = 0;
  if ( lpMultiByteStr )
  {
    v4 = BaseMultiByteToWideCharWithAlloc(this, lpMultiByteStr, (int)&Address);
    if ( !v4 )
      v4 = AddLocalAlternateComputerNameW((LPCWSTR)Address, a3);
    BaseConvertCharFree(Address);
    result = v4;
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E66C4C) --------------------------------------------------------
ULONG __stdcall RemoveLocalAlternateComputerNameW(LPCWSTR Hostname, int a2)
{
  NTSTATUS v2; // eax@3
  ULONG v3; // esi@3
  int v4; // eax@6
  WCHAR *v5; // edi@6
  ULONG result; // eax@14
  DWORD nSize; // [sp+8h] [bp-4h]@1

  nSize = 0;
  if ( a2 || !Hostname )
  {
    result = 87;
  }
  else
  {
    v2 = BaseRemoveMultiNameFromReg(
           L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\DnsCache\\Parameters",
           L"AlternateComputerNames",
           (void *)Hostname);
    v3 = RtlNtStatusToDosError(v2);
    if ( !v3 && !DnsHostnameToComputerNameW(Hostname, 0, &nSize) )
    {
      v3 = GetLastError();
      if ( v3 == 234 )
      {
        ++nSize;
        v4 = KernelBaseGetGlobalData();
        v5 = (WCHAR *)RtlAllocateHeap(
                        NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                        *(_DWORD *)(v4 + 44),
                        2 * nSize);
        if ( v5 )
        {
          if ( DnsHostnameToComputerNameW(Hostname, v5, &nSize)
            && (BaseIsNetBiosNameInUse(v5) || BaseRemoveAltNetBiosName(v5)) )
            v3 = 0;
          else
            v3 = GetLastError();
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
        }
        else
        {
          v3 = 8;
        }
      }
    }
    result = v3;
  }
  return result;
}

//----- (77E66D37) --------------------------------------------------------
DWORD __thiscall RemoveLocalAlternateComputerNameA(ULONG this, LPCSTR lpMultiByteStr, int a3)
{
  DWORD result; // eax@2
  DWORD v4; // esi@3
  PVOID Address; // [sp+0h] [bp-4h]@1

  Address = 0;
  if ( lpMultiByteStr )
  {
    v4 = BaseMultiByteToWideCharWithAlloc(this, lpMultiByteStr, (int)&Address);
    if ( !v4 )
      v4 = RemoveLocalAlternateComputerNameW((LPCWSTR)Address, a3);
    BaseConvertCharFree(Address);
    result = v4;
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E66D80) --------------------------------------------------------
DWORD __stdcall SetLocalPrimaryComputerNameW(wchar_t *Str, PVOID a2)
{
  DWORD v2; // edi@1
  int v4; // eax@12
  WCHAR *v5; // edi@12
  PVOID v6; // eax@19
  int v7; // eax@27
  WCHAR *v8; // ebx@27
  wchar_t *v9; // eax@35
  void *v10; // ebx@35
  DWORD v11; // [sp+Ch] [bp-10h]@1
  DWORD nSize; // [sp+10h] [bp-Ch]@1
  PVOID v13; // [sp+14h] [bp-8h]@1
  PVOID Address; // [sp+18h] [bp-4h]@1
  PVOID v15; // [sp+28h] [bp+Ch]@12
  PVOID v16; // [sp+28h] [bp+Ch]@19

  v2 = 0;
  nSize = 0;
  v11 = 0;
  Address = BaseParseDnsName(Str, 0);
  v13 = BaseParseDnsName(Str, 1);
  if ( !Str || a2 )
    return 87;
  if ( !BaseIsAltDnsFQHostname(Str) )
  {
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( v13 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
    return 87;
  }
  if ( !GetComputerNameExW(ComputerNamePhysicalNetBIOS, 0, &nSize) )
  {
    v2 = GetLastError();
    if ( v2 == 234 )
    {
      v4 = KernelBaseGetGlobalData();
      v5 = (WCHAR *)RtlAllocateHeap(
                      NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                      *(_DWORD *)(v4 + 44),
                      2 * nSize);
      v15 = v5;
      if ( v5 )
      {
        if ( GetComputerNameExW(ComputerNamePhysicalNetBIOS, v5, &nSize) && BaseSetAltNetBiosName((ULONG)v5) )
          v2 = 0;
        else
          v2 = GetLastError();
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v15);
      }
      else
      {
        v2 = 8;
      }
    }
  }
  v6 = BasepGetNameNonVolatile((wchar_t *)4);
  v16 = v6;
  if ( v6 )
  {
    if ( BaseSetAltNetBiosName((ULONG)v6) )
      v2 = 0;
    else
      v2 = GetLastError();
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v16);
  }
  if ( !v2 )
  {
    if ( !GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, 0, &v11) )
    {
      v2 = GetLastError();
      if ( v2 == 234 )
      {
        v7 = KernelBaseGetGlobalData();
        v8 = (WCHAR *)RtlAllocateHeap(
                        NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                        *(_DWORD *)(v7 + 44),
                        2 * v11);
        if ( !v8 )
        {
          v2 = 8;
          goto LABEL_45;
        }
        if ( GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, v8, &v11) && BaseSetAltDnsFQHostname(v8) )
          v2 = 0;
        else
          v2 = GetLastError();
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
      }
      if ( v2 )
        goto LABEL_45;
    }
    v9 = (wchar_t *)BasepGetNameNonVolatile((wchar_t *)7);
    v10 = v9;
    if ( !v9
      || (BaseSetAltDnsFQHostname(v9) ? (v2 = 0) : (v2 = GetLastError()),
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10),
          !v2) )
    {
      if ( SetComputerNameExW(ComputerNamePhysicalDnsHostname, (LPCWSTR)Address) || (v2 = GetLastError()) == 0 )
      {
        if ( SetComputerNameExW(ComputerNamePhysicalDnsDomain, (LPCWSTR)v13) || (v2 = GetLastError()) == 0 )
          v2 = RemoveLocalAlternateComputerNameW(Str, 0);
      }
    }
  }
LABEL_45:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v13 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
  return v2;
}

//----- (77E6700C) --------------------------------------------------------
DWORD __thiscall SetLocalPrimaryComputerNameA(ULONG this, LPCSTR lpMultiByteStr, PVOID a3)
{
  DWORD result; // eax@2
  DWORD v4; // esi@3
  PVOID Address; // [sp+0h] [bp-4h]@1

  Address = 0;
  if ( lpMultiByteStr )
  {
    v4 = BaseMultiByteToWideCharWithAlloc(this, lpMultiByteStr, (int)&Address);
    if ( !v4 )
      v4 = SetLocalPrimaryComputerNameW((wchar_t *)Address, a3);
    BaseConvertCharFree(Address);
    result = v4;
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E67055) --------------------------------------------------------
ULONG __stdcall EnumerateLocalComputerNamesW(int a1, int a2, void *Dst, int a4)
{
  ULONG v4; // ebx@1
  int v5; // esi@5
  int v6; // eax@8
  PVOID v7; // edi@8
  DWORD v8; // eax@11
  DWORD v9; // eax@12
  int v10; // esi@23
  DWORD nSize; // [sp+4h] [bp-4h]@1

  v4 = 0;
  nSize = 0;
  if ( __PAIR__((unsigned int)a2, a1) <= 2 )
  {
    if ( a1 )
    {
      if ( a1 == 1 )
      {
        if ( a4 && (Dst || *(_DWORD *)a4 <= 0u) )
          return BaseEnumAltDnsFQHostnames((int)Dst, a4);
      }
      else if ( a1 == 2 )
      {
        v5 = a4;
        if ( a4 )
        {
          if ( Dst || *(_DWORD *)a4 <= 0u )
          {
            nSize = *(_DWORD *)a4;
            v6 = KernelBaseGetGlobalData();
            v7 = RtlAllocateHeap(
                   NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                   *(_DWORD *)(v6 + 44),
                   2 * *(_DWORD *)v5);
            if ( v7 )
            {
              if ( !GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, (LPWSTR)v7, &nSize)
                && (v8 = GetLastError(), (v4 = v8) != 0) )
              {
                if ( v8 == 234 )
                {
                  a4 = 0;
                  v4 = BaseEnumAltDnsFQHostnames(0, (int)&a4);
                  if ( !v4 )
                    v4 = 234;
                  *(_DWORD *)v5 = nSize + a4;
                }
              }
              else
              {
                a4 = *(_DWORD *)v5 - nSize - 1;
                v4 = BaseEnumAltDnsFQHostnames((int)((char *)v7 + 2 * nSize + 2), (int)&a4);
                v9 = a4 + nSize + 1;
                *(_DWORD *)v5 = v9;
                if ( !v4 )
                  memcpy(Dst, v7, 2 * v9 + 2);
              }
              RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
              return v4;
            }
            return 8;
          }
        }
      }
    }
    else
    {
      v10 = a4;
      if ( a4 )
      {
        if ( *(_DWORD *)a4 )
          nSize = *(_DWORD *)a4 - 1;
        else
          nSize = 0;
        if ( GetComputerNameExW(ComputerNamePhysicalDnsFullyQualified, (LPWSTR)Dst, &nSize) )
        {
          if ( Dst )
            *((_WORD *)Dst + nSize + 1) = 0;
          else
            v4 = 31;
        }
        else
        {
          v4 = GetLastError();
        }
        *(_DWORD *)v10 = nSize + 1;
        return v4;
      }
    }
    return 87;
  }
  return 87;
}

//----- (77E671F7) --------------------------------------------------------
int __stdcall EnumerateLocalComputerNamesA(int a1, int a2, LPSTR lpMultiByteStr, int a4)
{
  int v4; // esi@1
  PVOID v5; // ebx@1
  int v7; // eax@10
  int v8; // [sp+20h] [bp+14h]@4

  v4 = a4;
  v5 = 0;
  if ( !a4 )
    return 87;
  if ( !lpMultiByteStr )
  {
    if ( *(_DWORD *)a4 <= 0u )
    {
LABEL_4:
      v8 = EnumerateLocalComputerNamesW(a1, a2, v5, a4);
      if ( !v8 && !WideCharToMultiByte(0, 0, (LPCWSTR)v5, *(_DWORD *)v4 + 1, lpMultiByteStr, *(_DWORD *)v4 + 1, 0, 0) )
        v8 = GetLastError();
      goto LABEL_7;
    }
    return 87;
  }
  v7 = KernelBaseGetGlobalData();
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), 2 * *(_DWORD *)a4);
  if ( v5 )
    goto LABEL_4;
  v8 = 8;
LABEL_7:
  if ( v5 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  return v8;
}

//----- (77E672AB) --------------------------------------------------------
LONG __stdcall LZCopy(INT hfSource, INT hfDest)
{
  void *v2; // esi@2
  LPVOID v4; // eax@4
  int v5; // edi@7
  int v6; // ebx@7
  HLOCAL v7; // eax@9
  int v8; // esi@9
  int v9; // ecx@11
  int v10; // eax@11
  int v11; // eax@11
  int v12; // ecx@11
  int v13; // eax@11
  LONG v14; // edi@11

  if ( hfSource < 1024 )
  {
    v6 = ConvertDosFHToWin32(hfDest);
    v5 = ConvertDosFHToWin32(hfSource);
  }
  else
  {
    v2 = *(void **)&stru_77EA5F18.Data4[4 * hfSource];
    if ( !v2 )
      return -1;
    v4 = GlobalLock(v2);
    if ( !v4 )
      return -6;
    v5 = *(_DWORD *)v4;
    v6 = ConvertDosFHToWin32(hfDest);
    GlobalUnlock(v2);
  }
  v7 = InitGlobalBuffersEx();
  v8 = (int)v7;
  if ( !v7 )
    return -5;
  v9 = *((_DWORD *)v7 + 1);
  v10 = *((_DWORD *)v7 + 11);
  *(_DWORD *)(v8 + 28) = 0;
  *(_DWORD *)(v8 + 40) = 0;
  v11 = v9 + v10 + 1;
  v12 = *(_DWORD *)(v8 + 48);
  *(_DWORD *)(v8 + 8) = v11;
  *(_DWORD *)(v8 + 12) = v11;
  v13 = *(_DWORD *)(v8 + 16);
  *(_DWORD *)(v8 + 20) = v13 + v12;
  *(_DWORD *)(v8 + 24) = v13;
  v14 = ExpandOrCopyFile(v5, v6, v8);
  if ( v14 == 1 )
    v14 = *(_DWORD *)(v8 + 40);
  FreeGlobalBuffers((HLOCAL)v8);
  return v14;
}
// 77EA5F18: using guessed type GUID;

//----- (77E67361) --------------------------------------------------------
LONG __stdcall CopyLZFile(INT hfSource, INT hfDest)
{
  return LZCopy(hfSource, hfDest);
}

//----- (77E67371) --------------------------------------------------------
DWORD __stdcall GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, int a5)
{
  DWORD v6; // [sp+10h] [bp-1Ch]@4

  if ( a5 != -1 && a5 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v6 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a5);
      v6 = GetFullPathNameA(lpFileName, nBufferLength, lpBuffer, lpFilePart);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v6 = 0;
  }
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E67419) --------------------------------------------------------
DWORD __stdcall GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, int a5)
{
  DWORD v6; // [sp+10h] [bp-1Ch]@4

  if ( a5 != -1 && a5 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v6 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a5);
      v6 = GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v6 = 0;
  }
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E674C1) --------------------------------------------------------
int __stdcall BasepSetMiniVersionForCreate(unsigned __int16 a1)
{
  int result; // eax@1

  result = a1;
  NtCurrentTeb()->Reserved2[103] = (PVOID)a1;
  return result;
}

//----- (77E674E0) --------------------------------------------------------
__int16 __stdcall BasepGetMiniVersionForCreate()
{
  return LOWORD(NtCurrentTeb()->Reserved2[103]);
}

//----- (77E674F3) --------------------------------------------------------
char __stdcall DTZItoRTL_DTZI(int a1, int a2)
{
  char result; // al@1

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a2 + 168) = *(_DWORD *)(a1 + 168);
  qmemcpy((void *)(a2 + 4), (const void *)(a1 + 4), 0x40u);
  qmemcpy((void *)(a2 + 88), (const void *)(a1 + 88), 0x40u);
  *(_WORD *)(a2 + 68) = *(_WORD *)(a1 + 68);
  *(_WORD *)(a2 + 70) = *(_WORD *)(a1 + 70);
  *(_WORD *)(a2 + 82) = *(_WORD *)(a1 + 72);
  *(_WORD *)(a2 + 72) = *(_WORD *)(a1 + 74);
  *(_WORD *)(a2 + 74) = *(_WORD *)(a1 + 76);
  *(_WORD *)(a2 + 76) = *(_WORD *)(a1 + 78);
  *(_WORD *)(a2 + 78) = *(_WORD *)(a1 + 80);
  *(_WORD *)(a2 + 80) = *(_WORD *)(a1 + 82);
  *(_WORD *)(a2 + 152) = *(_WORD *)(a1 + 152);
  *(_WORD *)(a2 + 154) = *(_WORD *)(a1 + 154);
  *(_WORD *)(a2 + 166) = *(_WORD *)(a1 + 156);
  *(_WORD *)(a2 + 156) = *(_WORD *)(a1 + 158);
  *(_WORD *)(a2 + 158) = *(_WORD *)(a1 + 160);
  *(_WORD *)(a2 + 160) = *(_WORD *)(a1 + 162);
  *(_WORD *)(a2 + 162) = *(_WORD *)(a1 + 164);
  *(_WORD *)(a2 + 164) = *(_WORD *)(a1 + 166);
  qmemcpy((void *)(a2 + 172), (const void *)(a1 + 172), 0x100u);
  result = *(_BYTE *)(a1 + 428);
  *(_BYTE *)(a2 + 428) = result;
  return result;
}

//----- (77E67604) --------------------------------------------------------
BOOL __stdcall SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
{
  int v1; // edx@1
  signed int v2; // esi@2
  __int16 v3; // ax@3
  NTSTATUS v4; // eax@3
  int SystemInformation; // [sp+4h] [bp-B0h]@3
  char v7; // [sp+8h] [bp-ACh]@3
  __int16 v8; // [sp+48h] [bp-6Ch]@3
  __int16 v9; // [sp+4Ah] [bp-6Ah]@3
  __int16 v10; // [sp+4Ch] [bp-68h]@3
  __int16 v11; // [sp+4Eh] [bp-66h]@3
  __int16 v12; // [sp+50h] [bp-64h]@3
  __int16 v13; // [sp+52h] [bp-62h]@3
  __int16 v14; // [sp+54h] [bp-60h]@3
  __int16 v15; // [sp+56h] [bp-5Eh]@3
  int v16; // [sp+58h] [bp-5Ch]@3
  char v17; // [sp+5Ch] [bp-58h]@3
  __int16 v18; // [sp+9Ch] [bp-18h]@3
  __int16 v19; // [sp+9Eh] [bp-16h]@3
  __int16 v20; // [sp+A0h] [bp-14h]@3
  __int16 v21; // [sp+A2h] [bp-12h]@3
  __int16 v22; // [sp+A4h] [bp-10h]@3
  __int16 v23; // [sp+A6h] [bp-Eh]@3
  __int16 v24; // [sp+A8h] [bp-Ch]@3
  __int16 v25; // [sp+AAh] [bp-Ah]@3
  int v26; // [sp+ACh] [bp-8h]@3

  if ( IsTimeZoneRedirectionEnabled() )
  {
    v2 = SetClientTimeZoneInformation(v1);
  }
  else
  {
    SystemInformation = *(_DWORD *)v1;
    v16 = *(_DWORD *)(v1 + 84);
    v26 = *(_DWORD *)(v1 + 168);
    v3 = *(_WORD *)(v1 + 68);
    qmemcpy(&v7, (const void *)(v1 + 4), 0x40u);
    qmemcpy(&v17, (const void *)(v1 + 88), 0x40u);
    v8 = v3;
    v9 = *(_WORD *)(v1 + 70);
    v15 = *(_WORD *)(v1 + 72);
    v10 = *(_WORD *)(v1 + 74);
    v11 = *(_WORD *)(v1 + 76);
    v12 = *(_WORD *)(v1 + 78);
    v13 = *(_WORD *)(v1 + 80);
    v14 = *(_WORD *)(v1 + 82);
    v18 = *(_WORD *)(v1 + 152);
    v19 = *(_WORD *)(v1 + 154);
    v25 = *(_WORD *)(v1 + 156);
    v20 = *(_WORD *)(v1 + 158);
    v21 = *(_WORD *)(v1 + 160);
    v22 = *(_WORD *)(v1 + 162);
    v23 = *(_WORD *)(v1 + 164);
    v24 = *(_WORD *)(v1 + 166);
    v4 = NtSetSystemInformation(
           SystemProcessorPerformanceInformation|SystemProcessInformation|0x50,
           &SystemInformation,
           0xACu);
    if ( v4 >= 0 )
    {
      v2 = 1;
    }
    else
    {
      BaseSetLastNTError(v4);
      v2 = 0;
    }
  }
  InvalidateTzSpecificCache();
  return v2;
}

//----- (77E6773D) --------------------------------------------------------
BOOL __stdcall SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
{
  signed int v1; // esi@2
  NTSTATUS v2; // eax@3
  char SystemInformation; // [sp+4h] [bp-1B4h]@1

  DTZItoRTL_DTZI((int)lpTimeZoneInformation, (int)&SystemInformation);
  if ( IsTimeZoneRedirectionEnabled() )
  {
    v1 = SetClientDynamicTimeZoneInformation((int)&SystemInformation);
  }
  else
  {
    v2 = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)102, &SystemInformation, 0x1B0u);
    if ( v2 >= 0 )
    {
      v1 = 1;
    }
    else
    {
      BaseSetLastNTError(v2);
      v1 = 0;
    }
  }
  InvalidateTzSpecificCache();
  return v1;
}

//----- (77E677B6) --------------------------------------------------------
HANDLE __stdcall ProcessIdToHandle(HANDLE ProcessHandle)
{
  HANDLE v1; // eax@1
  NTSTATUS v2; // eax@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-20h]@3
  CLIENT_ID ClientId; // [sp+18h] [bp-8h]@3

  v1 = ProcessHandle;
  if ( ProcessHandle == (HANDLE)-1 )
    v1 = (HANDLE)CsrGetProcessId();
  ClientId.UniqueProcess = v1;
  ClientId.UniqueThread = 0;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v2 = NtOpenProcess(&ProcessHandle, 0xC3Au, &ObjectAttributes, &ClientId);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    ProcessHandle = 0;
  }
  return ProcessHandle;
}
// 77DE1524: using guessed type _DWORD __stdcall CsrGetProcessId();

//----- (77E6781C) --------------------------------------------------------
BOOL __stdcall DebugActiveProcess(DWORD dwProcessId)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2
  BOOL v3; // esi@3
  NTSTATUS v4; // edi@4

  v1 = DbgUiConnectToDbg();
  if ( v1 >= 0 )
  {
    result = (BOOL)ProcessIdToHandle((HANDLE)dwProcessId);
    v3 = result;
    if ( result )
    {
      v4 = DbgUiDebugActiveProcess(result);
      NtClose((HANDLE)v3);
      if ( v4 >= 0 )
      {
        result = 1;
      }
      else
      {
        BaseSetLastNTError(v4);
        result = 0;
      }
    }
  }
  else
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  return result;
}
// 77E8A190: using guessed type int __stdcall DbgUiDebugActiveProcess(_DWORD);

//----- (77E6786F) --------------------------------------------------------
BOOL __stdcall DebugBreakProcess(HANDLE Process)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2

  v1 = DbgUiIssueRemoteBreakin(Process);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77E8A1A6: using guessed type int __stdcall DbgUiIssueRemoteBreakin(_DWORD);

//----- (77E67896) --------------------------------------------------------
BOOL __stdcall DebugSetProcessKillOnExit(BOOL KillOnExit)
{
  int v1; // ecx@0
  int v2; // eax@1
  NTSTATUS v4; // eax@4
  int v5; // [sp+0h] [bp-4h]@1

  v5 = v1;
  v2 = DbgUiGetThreadDebugObject();
  if ( !v2 )
  {
    BaseSetLastNTError(-1073741816);
    return 0;
  }
  v5 = KillOnExit != 0;
  v4 = NtSetInformationDebugObject(v2, 1, &v5, 4, 0);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  return 1;
}
// 77E8A1B1: using guessed type int __stdcall NtSetInformationDebugObject(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E678E1) --------------------------------------------------------
BOOL __stdcall Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
{
  BaseSetLastNTError(-1073741637);
  return 0;
}

//----- (77E678F5) --------------------------------------------------------
PVOID __stdcall SaveThreadHandle(int a1, int a2, int a3)
{
  PVOID result; // eax@1

  result = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x18u);
  if ( result )
  {
    *((_DWORD *)result + 2) = 0;
    *((_DWORD *)result + 1) = a3;
    *((_DWORD *)result + 3) = a1;
    *((_DWORD *)result + 4) = a2;
    *((_BYTE *)result + 20) = 0;
    *(_DWORD *)result = NtCurrentTeb()->Reserved5[2];
    NtCurrentTeb()->Reserved5[2] = result;
  }
  return result;
}

//----- (77E67953) --------------------------------------------------------
PVOID __stdcall SaveProcessHandle(int a1, int a2)
{
  PVOID result; // eax@1

  result = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x18u);
  if ( result )
  {
    *((_DWORD *)result + 1) = 0;
    *((_DWORD *)result + 4) = 0;
    *((_DWORD *)result + 2) = a2;
    *((_DWORD *)result + 3) = a1;
    *((_BYTE *)result + 20) = 0;
    *(_DWORD *)result = NtCurrentTeb()->Reserved5[2];
    NtCurrentTeb()->Reserved5[2] = result;
  }
  return result;
}

//----- (77E679AF) --------------------------------------------------------
PVOID __stdcall MarkThreadHandle(int a1)
{
  PVOID result; // eax@1

  for ( result = NtCurrentTeb()->Reserved5[2]; result; result = *(PVOID *)result )
  {
    if ( *((_DWORD *)result + 4) == a1 )
    {
      *((_BYTE *)result + 20) = 1;
      return result;
    }
  }
  return result;
}

//----- (77E679DF) --------------------------------------------------------
PVOID __stdcall MarkProcessHandle(int a1)
{
  PVOID result; // eax@1

  for ( result = NtCurrentTeb()->Reserved5[2]; result; result = *(PVOID *)result )
  {
    if ( *((_DWORD *)result + 3) == a1 && !*((_DWORD *)result + 4) )
    {
      *((_BYTE *)result + 20) = 1;
      return result;
    }
  }
  return result;
}

//----- (77E67A15) --------------------------------------------------------
char __stdcall RemoveHandles(int a1, int a2)
{
  char *v2; // edi@1
  int i; // esi@2
  int v4; // eax@5

  v2 = (char *)&NtCurrentTeb()->Reserved5[2];
LABEL_2:
  for ( i = *(_DWORD *)v2; i; i = *(_DWORD *)i )
  {
    if ( *(_BYTE *)(i + 20) )
    {
      if ( *(_DWORD *)(i + 12) == a2 || (v4 = *(_DWORD *)(i + 16), v4 == a1) )
      {
        if ( *(_DWORD *)(i + 4) )
          CloseHandle(*(HANDLE *)(i + 4));
        if ( *(_DWORD *)(i + 8) )
          CloseHandle(*(HANDLE *)(i + 8));
        *(_DWORD *)v2 = *(_DWORD *)i;
        LOBYTE(v4) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)i);
        goto LABEL_2;
      }
    }
    v2 = (char *)i;
  }
  return v4;
}

//----- (77E67A8B) --------------------------------------------------------
char __stdcall CloseAllProcessHandles(int a1)
{
  char *v1; // edi@1
  int i; // esi@2
  int v3; // eax@3

  v1 = (char *)&NtCurrentTeb()->Reserved5[2];
LABEL_2:
  for ( i = *(_DWORD *)v1; i; i = *(_DWORD *)i )
  {
    v3 = *(_DWORD *)(i + 12);
    if ( v3 == a1 )
    {
      if ( *(_DWORD *)(i + 4) )
        CloseHandle(*(HANDLE *)(i + 4));
      if ( *(_DWORD *)(i + 8) )
        CloseHandle(*(HANDLE *)(i + 8));
      *(_DWORD *)v1 = *(_DWORD *)i;
      LOBYTE(v3) = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)i);
      goto LABEL_2;
    }
    v1 = (char *)i;
  }
  return v3;
}

//----- (77E67AF3) --------------------------------------------------------
BOOL __stdcall WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
{
  int v2; // esi@1
  NTSTATUS v3; // eax@2
  char v5; // [sp+4h] [bp-68h]@2
  char v6; // [sp+64h] [bp-8h]@1

  v2 = BaseFormatTimeOut((int)&v6, dwMilliseconds);
  do
  {
    do
      v3 = DbgUiWaitStateChange(&v5, v2);
    while ( v3 == 257 );
  }
  while ( v3 == 192 );
  if ( v3 < 0 && v3 != 1073807362 )
    goto LABEL_21;
  if ( v3 == 258 )
  {
    RtlSetLastWin32Error(121);
    return 0;
  }
  v3 = DbgUiConvertStateChangeStructure(&v5, lpDebugEvent);
  if ( v3 < 0 )
  {
LABEL_21:
    BaseSetLastNTError(v3);
    return 0;
  }
  switch ( lpDebugEvent->dwDebugEventCode )
  {
    case 2u:
      SaveThreadHandle(
        lpDebugEvent->dwProcessId,
        lpDebugEvent->dwThreadId,
        lpDebugEvent->u.Exception.ExceptionRecord.ExceptionCode);
      break;
    case 3u:
      SaveProcessHandle(lpDebugEvent->dwProcessId, lpDebugEvent->u.Exception.ExceptionRecord.ExceptionFlags);
      SaveThreadHandle(
        lpDebugEvent->dwProcessId,
        lpDebugEvent->dwThreadId,
        (int)&lpDebugEvent->u.Exception.ExceptionRecord.ExceptionRecord->ExceptionCode);
      break;
    case 4u:
      MarkThreadHandle(lpDebugEvent->dwThreadId);
      break;
    case 5u:
      MarkThreadHandle(lpDebugEvent->dwThreadId);
      MarkProcessHandle(lpDebugEvent->dwProcessId);
      break;
    case 1u:
    case 6u:
    case 7u:
    case 8u:
    case 9u:
      return 1;
    default:
      return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E8A1C7: using guessed type int __stdcall DbgUiConvertStateChangeStructure(_DWORD, _DWORD);
// 77E8A1D2: using guessed type int __stdcall DbgUiWaitStateChange(_DWORD, _DWORD);

//----- (77E67BD9) --------------------------------------------------------
BOOL __stdcall ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  DWORD v5; // [sp+8h] [bp-8h]@1
  DWORD v6; // [sp+Ch] [bp-4h]@1

  v5 = dwProcessId;
  v6 = dwThreadId;
  v3 = DbgUiContinue(&v5, dwContinueStatus);
  if ( v3 >= 0 )
  {
    RemoveHandles(dwThreadId, dwProcessId);
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}
// 77E8A1DD: using guessed type int __stdcall DbgUiContinue(_DWORD, _DWORD);

//----- (77E67C1D) --------------------------------------------------------
BOOL __stdcall DebugActiveProcessStop(DWORD dwProcessId)
{
  HANDLE v1; // esi@1
  int v3; // edi@3

  v1 = ProcessIdToHandle((HANDLE)dwProcessId);
  if ( !v1 )
    return 0;
  CloseAllProcessHandles(dwProcessId);
  v3 = DbgUiStopDebugging(v1);
  NtClose(v1);
  if ( v3 < 0 )
  {
    RtlSetLastWin32Error(5);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E8A1E8: using guessed type int __stdcall DbgUiStopDebugging(_DWORD);

//----- (77E67C69) --------------------------------------------------------
BOOL __stdcall RemoveDirectoryTransactedW(LPCWSTR lpPathName, int a2)
{
  BOOL v3; // [sp+10h] [bp-1Ch]@4

  if ( a2 != -1 && a2 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v3 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a2);
      v3 = RemoveDirectoryW(lpPathName);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v3 = 0;
  }
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E67D09) --------------------------------------------------------
BOOL __stdcall CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  NTSTATUS v4; // eax@6
  NTSTATUS v5; // esi@16
  PWCH v6; // edi@21
  DWORD v7; // eax@28
  int v8; // eax@39
  PVOID v9; // eax@39
  int v10; // eax@70
  PVOID v11; // eax@70
  NTSTATUS v12; // edi@73
  int v13; // edx@75
  LPWSTR v14; // edi@78
  WCHAR v15; // cx@85
  int v16; // eax@103
  unsigned int v17; // eax@105
  PVOID v18; // ecx@106
  const WCHAR *v19; // ST30_4@107
  ULONG v20; // ST2C_4@111
  ULONG v21; // edi@116
  int v22; // eax@117
  const WCHAR *v23; // eax@117
  LPCWSTR i; // edi@126
  ACCESS_MASK v25; // eax@128
  int v26; // ecx@129
  char FileInformation; // [sp+8h] [bp-2E8h]@9
  ULONG FileAttributes; // [sp+28h] [bp-2C8h]@9
  ULONG v29; // [sp+30h] [bp-2C0h]@35
  int v30; // [sp+34h] [bp-2BCh]@116
  int v31; // [sp+38h] [bp-2B8h]@132
  int v32; // [sp+3Ch] [bp-2B4h]@1
  int v33; // [sp+40h] [bp-2B0h]@127
  __int16 v34; // [sp+44h] [bp-2ACh]@78
  LPWSTR FilePart; // [sp+48h] [bp-2A8h]@28
  unsigned __int16 v36; // [sp+4Ch] [bp-2A4h]@127
  unsigned __int16 v37; // [sp+4Eh] [bp-2A2h]@127
  LPCWSTR v38; // [sp+50h] [bp-2A0h]@127
  int v39; // [sp+54h] [bp-29Ch]@19
  void *v40; // [sp+5Ch] [bp-294h]@34
  UNICODE_STRING String1; // [sp+64h] [bp-28Ch]@1
  int v42; // [sp+6Ch] [bp-284h]@1
  HANDLE v43; // [sp+70h] [bp-280h]@127
  int v44; // [sp+74h] [bp-27Ch]@1
  void *v45; // [sp+7Ch] [bp-274h]@5
  int v46; // [sp+84h] [bp-26Ch]@1
  int v47; // [sp+88h] [bp-268h]@1
  UNICODE_STRING String2; // [sp+8Ch] [bp-264h]@19
  UNICODE_STRING DestinationString; // [sp+94h] [bp-25Ch]@103
  int j; // [sp+9Ch] [bp-254h]@50
  HANDLE v51; // [sp+A0h] [bp-250h]@132
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+A4h] [bp-24Ch]@6
  ACCESS_MASK DesiredAccess; // [sp+BCh] [bp-234h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+C0h] [bp-230h]@6
  HANDLE Handle; // [sp+C8h] [bp-228h]@53
  PVOID Dst; // [sp+CCh] [bp-224h]@21
  ULONG Size; // [sp+D0h] [bp-220h]@35
  char v58; // [sp+D7h] [bp-219h]@1
  LPCWSTR lpFileName; // [sp+D8h] [bp-218h]@1
  PVOID Address; // [sp+DCh] [bp-214h]@3
  HANDLE FileHandle; // [sp+E0h] [bp-210h]@6
  NTSTATUS NtStatus; // [sp+E4h] [bp-20Ch]@6
  __int16 v63[258]; // [sp+E8h] [bp-208h]@129

  lpFileName = lpNewDirectory;
  DesiredAccess = (ACCESS_MASK)lpSecurityAttributes;
  v46 = 0;
  v47 = 0;
  v58 = 0;
  v32 = 0;
  v42 = 0;
  if ( !(unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(lpTemplateDirectory, &String1, 0, &v44) )
  {
    RtlSetLastWin32Error(3);
    return 0;
  }
  Address = String1.Buffer;
  if ( (_WORD)v44 )
    String1 = *(UNICODE_STRING *)&v44;
  else
    v45 = 0;
  ObjectAttributes.RootDirectory = v45;
  ObjectAttributes.ObjectName = &String1;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v4 = NtOpenFile(&FileHandle, 0x89u, &ObjectAttributes, &IoStatusBlock, 3u, 0x204001u);
  NtStatus = v4;
  if ( v4 >= 0 )
  {
    FileAttributes = 128;
    NtStatus = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    if ( NtStatus < 0 )
      goto LABEL_143;
    if ( !(FileAttributes & 0x400) )
      goto LABEL_19;
    NtStatus = NtQueryInformationFile(FileHandle, &IoStatusBlock, &v46, 8u, FileAttributeTagInformation);
    if ( NtStatus < 0 )
    {
LABEL_143:
      RtlReleaseRelativeName(&v44);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
LABEL_62:
      CloseHandle(FileHandle);
      goto LABEL_114;
    }
    if ( v47 == -1610612733 || v47 == -1610612724 )
    {
      v58 = 1;
      goto LABEL_19;
    }
    CloseHandle(FileHandle);
  }
  else if ( v4 != -1073741811 )
  {
    RtlReleaseRelativeName(&v44);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
LABEL_114:
    BaseSetLastNTError(NtStatus);
    return 0;
  }
  v5 = NtOpenFile(&FileHandle, 0x89u, &ObjectAttributes, &IoStatusBlock, 3u, 0x4001u);
  if ( v5 < 0 )
  {
    RtlReleaseRelativeName(&v44);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    BaseSetLastNTError(v5);
    return 0;
  }
LABEL_19:
  if ( !(unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(lpFileName, &String2, 0, &v39) )
  {
    RtlReleaseRelativeName(&v44);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    NtClose(FileHandle);
    RtlSetLastWin32Error(3);
    return 0;
  }
  v6 = String2.Buffer;
  Dst = String2.Buffer;
  if ( RtlEqualUnicodeString(&String1, &String2, 1u) )
  {
    RtlReleaseRelativeName(&v44);
    RtlReleaseRelativeName(&v39);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
    NtClose(FileHandle);
    RtlSetLastWin32Error(123);
    return 0;
  }
  RtlReleaseRelativeName(&v44);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( String2.Length > 0x1F0u
    && (*lpFileName != 92 || lpFileName[1] != 92 || lpFileName[2] != 63 || lpFileName[3] != 92) )
  {
    v7 = GetFullPathNameW(lpFileName, 0, 0, &FilePart);
    if ( !v7 || v7 + 12 > 0x104 )
    {
      RtlReleaseRelativeName(&v39);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
      CloseHandle(FileHandle);
      RtlSetLastWin32Error(206);
      return 0;
    }
  }
  if ( (_WORD)v39 )
    String2 = *(UNICODE_STRING *)&v39;
  else
    v40 = 0;
  Address = 0;
  Size = 0;
  NtStatus = NtQueryInformationFile(FileHandle, &IoStatusBlock, &v29, 4u, FileEaInformation);
  if ( NtStatus < 0 )
  {
    RtlReleaseRelativeName(&v39);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
    goto LABEL_62;
  }
  if ( v29 )
  {
    Size = v29;
    while ( 1 )
    {
      Size *= 2;
      v8 = KernelBaseGetGlobalData();
      v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44), Size);
      Address = v9;
      if ( !v9 )
        break;
      NtStatus = NtQueryEaFile(FileHandle, &IoStatusBlock, (PFILE_FULL_EA_INFORMATION)v9, Size, 0, 0, 0, 0, 1u);
      if ( NtStatus < 0 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        Address = 0;
        IoStatusBlock.Information = 0;
      }
      if ( NtStatus != -2147483643 && NtStatus != -1073741789 )
      {
        Size = IoStatusBlock.Information;
        goto LABEL_45;
      }
    }
    RtlReleaseRelativeName(&v39);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
    CloseHandle(FileHandle);
    goto LABEL_72;
  }
LABEL_45:
  ObjectAttributes.RootDirectory = v40;
  ObjectAttributes.ObjectName = &String2;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  if ( DesiredAccess )
    ObjectAttributes.SecurityDescriptor = *(PVOID *)(DesiredAccess + 4);
  DesiredAccess = 1048961;
  if ( FileAttributes & 0x400 )
    DesiredAccess = 1048963;
  FileAttributes &= 0xFFFFFBFF;
  if ( v47 == -1610612724 )
  {
    j = 35;
    NtStatus = RtlAcquirePrivilege(&j, 1, 0, &v42);
    if ( NtStatus < 0 )
    {
      RtlReleaseRelativeName(&v39);
      goto LABEL_60;
    }
  }
  NtStatus = NtCreateFile(
               &Handle,
               DesiredAccess,
               &ObjectAttributes,
               &IoStatusBlock,
               0,
               FileAttributes,
               3u,
               2u,
               0x204021u,
               Address,
               Size);
  if ( v47 == -1610612724 )
    RtlReleasePrivilege(v42);
  if ( NtStatus < 0 && (NtStatus == -1073741811 || NtStatus == -1073741790) )
  {
    if ( v58 )
    {
      RtlReleaseRelativeName(&v39);
LABEL_60:
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
      if ( Address )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      goto LABEL_62;
    }
    NtStatus = NtCreateFile(
                 &Handle,
                 0x100181u,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 0,
                 FileAttributes,
                 3u,
                 2u,
                 0x4021u,
                 Address,
                 Size);
  }
  RtlReleaseRelativeName(&v39);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( NtStatus < 0 )
  {
    NtClose(FileHandle);
    if ( RtlIsDosDeviceName_U((PWSTR)lpFileName) )
      NtStatus = -1073741565;
    goto LABEL_114;
  }
  if ( !v58 )
  {
    v21 = 4096;
    v30 = 4096;
    while ( 1 )
    {
      v22 = KernelBaseGetGlobalData();
      v23 = (const WCHAR *)RtlAllocateHeap(
                             NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                             *(_DWORD *)(v22 + 44),
                             v21);
      lpFileName = v23;
      if ( !v23 )
        break;
      NtStatus = NtQueryInformationFile(FileHandle, &IoStatusBlock, (PVOID)v23, v21, FileStreamInformation);
      if ( NtStatus < 0 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpFileName);
        lpFileName = 0;
        v21 *= 2;
      }
      if ( NtStatus != -2147483643 && NtStatus != -1073741789 )
        goto LABEL_124;
    }
    BaseMarkFileForDelete(Handle, FileAttributes);
    BaseSetLastNTError(-1073741801);
LABEL_124:
    if ( NtStatus >= 0 && IoStatusBlock.Information )
    {
      for ( i = lpFileName; ; i = (LPCWSTR)((char *)i + *(_DWORD *)i) )
      {
        v38 = i + 12;
        v33 = 0;
        v36 = i[2];
        v37 = v36;
        ObjectAttributes.RootDirectory = FileHandle;
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&v36;
        ObjectAttributes.Length = 24;
        ObjectAttributes.Attributes = 0;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        if ( NtCreateFile(&v43, 0x80100000, &ObjectAttributes, &IoStatusBlock, 0, 0, 1u, 1u, 0x20u, 0, 0) >= 0 )
        {
          v25 = 0;
          DesiredAccess = (unsigned int)v36 >> 1;
          if ( DesiredAccess )
          {
            v26 = (char *)v38 - (char *)v63;
            for ( j = (char *)v38 - (char *)v63; ; v26 = j )
            {
              v63[v25] = *(__int16 *)((char *)&v63[v25] + v26);
              ++v25;
              if ( v25 >= DesiredAccess )
                break;
            }
          }
          v63[v25] = 0;
          v51 = 0;
          v31 = 0;
          BaseCopyStream(0, v43, -2146435072, v63, Handle, i + 4, &v31, &v51, &v30, &v32, 0, 0, 0, &v33);
          NtClose(v43);
          if ( v51 )
            NtClose(v51);
        }
        if ( !*(_DWORD *)i )
          break;
      }
    }
    if ( lpFileName )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpFileName);
    NtClose(FileHandle);
    if ( Handle )
      NtClose(Handle);
    return 1;
  }
  v10 = KernelBaseGetGlobalData();
  v11 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v10 + 44), 0x4000u);
  Size = (ULONG)v11;
  if ( !v11 )
  {
    NtClose(FileHandle);
    NtClose(Handle);
LABEL_72:
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  v12 = NtFsControlFile(FileHandle, 0, 0, 0, &IoStatusBlock, 0x900A8u, 0, 0, v11, 0x4000u);
  if ( v12 < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)Size);
    NtClose(FileHandle);
    NtClose(Handle);
    BaseSetLastNTError(v12);
    return 0;
  }
  v13 = *(_DWORD *)Size;
  if ( *(_DWORD *)Size == -1610612733 )
  {
    v34 = *(_WORD *)(Size + 10);
    v14 = (LPWSTR)(*(_WORD *)(Size + 8) + Size + 16);
  }
  else
  {
    if ( v13 != -1610612724 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)Size);
      NtClose(FileHandle);
      NtClose(Handle);
      BaseSetLastNTError(-1073741773);
      return 0;
    }
    v14 = FilePart;
  }
  if ( v13 != -1610612733
    || v34 != 96 && (v34 != 98 || v14[48] != 92)
    || *v14 != 92
    || (v15 = v14[1], v15 != 63) && v15 != 92
    || v14[2] != 63
    || v14[3] != 92
    || v14[4] != 86
    || v14[5] != 111
    || v14[6] != 108
    || v14[7] != 117
    || v14[8] != 109
    || v14[9] != 101
    || v14[10] != 123
    || v14[19] != 45
    || v14[24] != 45
    || v14[29] != 45
    || v14[34] != 45
    || v14[47] != 125
    || v34 != 98
    || v15 != 63 )
  {
    v20 = *(_WORD *)(Size + 4) + 8;
    lpFileName = (LPCWSTR)1;
    NtStatus = NtFsControlFile(Handle, 0, 0, 0, &IoStatusBlock, 0x900A4u, (PVOID)Size, v20, 0, 0);
  }
  else
  {
    NtStatus = RtlInitUnicodeStringEx(&DestinationString, lpFileName);
    v16 = KernelBaseGetGlobalData();
    Dst = RtlAllocateHeap(
            NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
            *(_DWORD *)(v16 + 44),
            DestinationString.Length + 4);
    if ( Dst )
    {
      if ( NtStatus >= 0 )
      {
        memcpy(Dst, DestinationString.Buffer, DestinationString.Length);
        *((_WORD *)Dst + ((unsigned int)DestinationString.Length >> 1)) = 0;
        v17 = (unsigned int)DestinationString.Length >> 1;
        if ( DestinationString.Buffer[v17 - 1] != 92 )
        {
          v18 = Dst;
          *(_WORD *)((char *)Dst + v17 * 2) = 92;
          *((_WORD *)v18 + ((unsigned int)DestinationString.Length >> 1) + 1) = 0;
        }
        v19 = (const WCHAR *)Dst;
        v14[1] = 92;
        lpFileName = (LPCWSTR)SetVolumeMountPointW(v19, v14);
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
        v14[1] = 63;
        goto LABEL_112;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
      BaseSetLastNTError(NtStatus);
    }
    else
    {
      RtlSetLastWin32Error(8);
    }
    lpFileName = 0;
  }
LABEL_112:
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)Size);
  NtClose(FileHandle);
  NtClose(Handle);
  if ( !lpFileName )
    return 0;
  if ( NtStatus < 0 )
    goto LABEL_114;
  return 1;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E1A625: using guessed type _DWORD __stdcall BaseCopyStream(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E67D09: using guessed type __int16 var_208[258];

//----- (77E68AD1) --------------------------------------------------------
BOOL __stdcall RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
{
  BOOL result; // eax@1
  int v3; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpPathName);
  if ( result )
  {
    v3 = RemoveDirectoryTransactedW(UnicodeString.Buffer, (int)hTransaction);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E68B0C) --------------------------------------------------------
BOOL __stdcall CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int a4)
{
  BOOL v4; // eax@6
  BOOL v6; // [sp+10h] [bp-1Ch]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v6 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      if ( lpTemplateDirectory )
        v4 = CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
      else
        v4 = CreateDirectoryW(lpNewDirectory, lpSecurityAttributes);
      v6 = v4;
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v6 = 0;
  }
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E68BC1) --------------------------------------------------------
BOOL __stdcall CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  BOOL v4; // edi@5
  LSA_UNICODE_STRING v5; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@3

  if ( !Basep8BitStringToDynamicUnicodeString((int)&v5, lpTemplateDirectory) )
    return 0;
  if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpNewDirectory) )
  {
    RtlFreeUnicodeString(&UnicodeString);
    return 0;
  }
  v4 = CreateDirectoryExW(v5.Buffer, UnicodeString.Buffer, lpSecurityAttributes);
  RtlFreeUnicodeString(&UnicodeString);
  RtlFreeUnicodeString(&v5);
  return v4;
}

//----- (77E68C2A) --------------------------------------------------------
int __stdcall CreateDirectoryTransactedA(int a1, int a2, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int a4)
{
  int result; // eax@1
  int v5; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING v7; // [sp+8h] [bp-8h]@4

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a2);
  if ( result )
  {
    if ( a1 )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&v7, (PCSZ)a1) )
      {
        v5 = 0;
LABEL_6:
        RtlFreeUnicodeString(&UnicodeString);
        return v5;
      }
    }
    else
    {
      v7.Buffer = 0;
    }
    v5 = CreateDirectoryTransactedW(v7.Buffer, UnicodeString.Buffer, lpSecurityAttributes, a4);
    if ( a1 )
      RtlFreeUnicodeString(&v7);
    goto LABEL_6;
  }
  return result;
}

//----- (77E68C9C) --------------------------------------------------------
UINT __stdcall GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
{
  return InternalGetAtomName(0, 0, nAtom, lpBuffer, nSize);
}

//----- (77E68CBC) --------------------------------------------------------
UINT __stdcall GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
{
  return InternalGetAtomName(1, 0, nAtom, lpBuffer, nSize);
}

//----- (77E68CDC) --------------------------------------------------------
NTSTATUS __stdcall BaseDllCheckKeyNotEmpty(void *a1, UNICODE_STRING *a2)
{
  NTSTATUS result; // eax@1
  NTSTATUS v3; // edi@2
  ULONG ResultLength; // [sp+0h] [bp-34h]@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-30h]@1
  HANDLE KeyHandle; // [sp+1Ch] [bp-18h]@1
  char KeyValueInformation; // [sp+20h] [bp-14h]@2

  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.RootDirectory = a1;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = a2;
  result = NtOpenKey(&KeyHandle, 0x80000000, &ObjectAttributes);
  if ( result >= 0 )
  {
    v3 = NtEnumerateValueKey(KeyHandle, 0, 0, &KeyValueInformation, 0x10u, &ResultLength);
    if ( v3 == -2147483643 )
      v3 = 0;
    NtClose(KeyHandle);
    result = v3;
  }
  return result;
}

//----- (77E68D6A) --------------------------------------------------------
signed int __stdcall BaseVerifyFileName(int a1, int a2)
{
  signed int v2; // edi@1
  signed int result; // eax@2

  v2 = 0;
  if ( (unsigned __int8)CsrVerifyRegion(a1, 20) )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 8);
      v2 = BaseVerifyUnicodeString(a2);
    }
    result = v2;
  }
  else
  {
    result = -1073741790;
  }
  return result;
}
// 77DE149C: using guessed type int __stdcall CsrVerifyRegion(_DWORD, _DWORD);

//----- (77E68DB1) --------------------------------------------------------
signed int __stdcall BaseVerifyMappingTarget(int a1, int a2)
{
  signed int v2; // edi@1
  signed int result; // eax@2

  v2 = 0;
  if ( (unsigned __int8)CsrVerifyRegion(a1, 12) )
  {
    if ( a2 )
    {
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 8);
      v2 = BaseVerifyUnicodeString(a2);
    }
    result = v2;
  }
  else
  {
    result = -1073741790;
  }
  return result;
}
// 77DE149C: using guessed type int __stdcall CsrVerifyRegion(_DWORD, _DWORD);

//----- (77E68DF8) --------------------------------------------------------
int __stdcall BaseDllReadApplicationNames(int a1)
{
  PPEB v1; // edi@1
  int i; // esi@1
  int result; // eax@3
  int v4; // esi@9
  int v5; // esi@13
  NTSTATUS j; // eax@18
  NTSTATUS v7; // eax@20
  NTSTATUS v8; // edi@20
  int v9; // [sp+10h] [bp-220h]@3
  int v10; // [sp+14h] [bp-21Ch]@5
  ULONG ResultLength; // [sp+18h] [bp-218h]@18
  __int16 v12; // [sp+1Ch] [bp-214h]@20
  __int16 v13; // [sp+1Eh] [bp-212h]@20
  char *v14; // [sp+20h] [bp-210h]@20
  ULONG Index; // [sp+24h] [bp-20Ch]@18
  HANDLE KeyHandle; // [sp+28h] [bp-208h]@16
  char KeyInformation; // [sp+2Ch] [bp-204h]@18
  __int16 v18; // [sp+38h] [bp-1F8h]@20
  char v19; // [sp+3Ch] [bp-1F4h]@20

  v1 = NtCurrentTeb()->ProcessEnvironmentBlock;
  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12); i; i = *(_DWORD *)i )
  {
    if ( v1->Reserved2[0] & 2 )
    {
      result = BaseVerifyFileName(i, (int)&v9);
      if ( result < 0 )
        return result;
    }
    else
    {
      v9 = *(_DWORD *)(i + 4);
      v10 = *(_DWORD *)(i + 8);
    }
    result = BaseDllAppendStringToResultBuffer(a1, 0, (int)&v9, 1);
    if ( result < 0 )
      return result;
  }
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16);
  if ( v4 )
  {
    if ( !(v1->Reserved2[0] & 2) || (result = BaseVerifyFileName(v4, 0), result >= 0) )
    {
      v5 = *(_DWORD *)(v4 + 16);
      if ( !(v1->Reserved2[0] & 2) || !v5 || (result = BaseVerifyFileName(v5, 0), result >= 0) )
      {
        result = BaseDllOpenMappingTarget(a1, v5, 0, 0, &KeyHandle);
        if ( result >= 0 && KeyHandle != (HANDLE)-1 )
        {
          Index = 0;
          for ( j = NtEnumerateKey(KeyHandle, 0, 0, &KeyInformation, 0x200u, &ResultLength);
                ;
                j = NtEnumerateKey(KeyHandle, Index, 0, &KeyInformation, 0x200u, &ResultLength) )
          {
            v8 = j;
            if ( j == -2147483622 )
            {
LABEL_26:
              NtClose(KeyHandle);
              return 0;
            }
            if ( j < 0 )
              break;
            v14 = &v19;
            v12 = v18;
            v13 = v18;
            v7 = BaseDllCheckKeyNotEmpty(KeyHandle, (UNICODE_STRING *)&v12);
            v8 = 0;
            if ( v7 < 0 )
            {
              if ( v7 != -2147483622 )
                goto LABEL_26;
            }
            else
            {
              v8 = BaseDllAppendStringToResultBuffer(a1, 0, (int)&v12, 1);
            }
            if ( v8 < 0 )
              break;
            ++Index;
          }
          NtClose(KeyHandle);
          result = v8;
        }
      }
    }
  }
  else
  {
    result = -1073741802;
  }
  return result;
}

//----- (77E68FE3) --------------------------------------------------------
NTSTATUS __stdcall BaseDllWriteVariableValue(ULONG ResultSize, int a2, int a3, PUNICODE_STRING ValueName)
{
  ULONG v4; // esi@1
  NTSTATUS result; // eax@3
  NTSTATUS v6; // eax@11
  NTSTATUS v7; // esi@17
  ULONG ResultLength; // [sp+Ch] [bp-28h]@11
  PVOID Data; // [sp+10h] [bp-24h]@19
  int v10; // [sp+14h] [bp-20h]@1
  HANDLE KeyHandle; // [sp+18h] [bp-1Ch]@9
  ULONG DataSize; // [sp+1Ch] [bp-18h]@1
  char KeyValueInformation; // [sp+20h] [bp-14h]@11
  int v14; // [sp+24h] [bp-10h]@13

  v4 = (ULONG)ValueName;
  v10 = a3;
  DataSize = (ULONG)ValueName;
  if ( !ValueName )
  {
    if ( !BaseDllGetVariableName(ResultSize, (int)ValueName, (int)&DataSize) )
      return -1073741811;
    v4 = DataSize;
  }
  if ( !v10 )
  {
    v10 = BaseDllFindVarNameMapping(a2, (PCUNICODE_STRING)v4);
    if ( !v10 )
      return -1073741802;
  }
  if ( !BaseDllGetApplicationName(ResultSize, 0, (int)&DataSize) )
    return -1073741811;
  result = BaseDllOpenMappingTarget(ResultSize, v10, (PCUNICODE_STRING)DataSize, 1, &KeyHandle);
  if ( result >= 0 && KeyHandle != (HANDLE)-1 )
  {
    v6 = NtQueryValueKey(KeyHandle, (PUNICODE_STRING)v4, 0, &KeyValueInformation, 0x10u, &ResultLength);
    if ( v6 < 0 && v6 != -2147483643 || v14 == 1 )
    {
      if ( *(_DWORD *)ResultSize == 2 || *(_DWORD *)ResultSize == 7 )
      {
        if ( BaseDllGetVariableValue(ResultSize, 0, (int)&Data, (int)&DataSize) )
          v7 = NtSetValueKey(KeyHandle, (PUNICODE_STRING)v4, 0, 1u, Data, DataSize);
        else
          v7 = -1073741811;
      }
      else
      {
        v7 = NtDeleteValueKey(KeyHandle, (PUNICODE_STRING)v4);
        if ( v7 == -1073741772 )
          v7 = 0;
      }
      NtClose(KeyHandle);
      if ( v7 >= 0 && *(_BYTE *)(v10 + 12) & 1 )
        return -1073741802;
      result = v7;
    }
    else
    {
      NtClose(KeyHandle);
      result = -1073741788;
    }
  }
  return result;
}

//----- (77E69139) --------------------------------------------------------
int __stdcall BaseDllDeleteApplicationVariables(ULONG a1, int a2)
{
  PPEB v2; // ebx@1
  int i; // esi@1
  int result; // eax@4
  int v5; // edi@10
  NTSTATUS v6; // esi@18
  ULONG ResultLength; // [sp+Ch] [bp-224h]@18
  LSA_UNICODE_STRING ValueName; // [sp+10h] [bp-220h]@19
  PCUNICODE_STRING v9; // [sp+18h] [bp-218h]@14
  LSA_UNICODE_STRING v10; // [sp+1Ch] [bp-214h]@3
  ULONG ResultSize; // [sp+24h] [bp-20Ch]@1
  HANDLE KeyHandle; // [sp+28h] [bp-208h]@16
  char KeyValueInformation; // [sp+2Ch] [bp-204h]@18
  USHORT v14; // [sp+34h] [bp-1FCh]@19
  char v15; // [sp+38h] [bp-1F8h]@19

  ResultSize = a1;
  v2 = NtCurrentTeb()->ProcessEnvironmentBlock;
  for ( i = *(_DWORD *)(a2 + 12); i; i = *(_DWORD *)i )
  {
    if ( v2->Reserved2[0] & 2 )
    {
      result = BaseVerifyFileName(i, (int)&v10);
      if ( result < 0 )
        return result;
    }
    else
    {
      *(_DWORD *)&v10.Length = *(_DWORD *)(i + 4);
      v10.Buffer = *(PWCH *)(i + 8);
    }
    if ( v10.Length )
    {
      result = BaseDllWriteVariableValue(ResultSize, a2, i, &v10);
      if ( result < 0 && result != -1073741802 )
        return result;
    }
  }
  v5 = *(_DWORD *)(a2 + 16);
  if ( v5 )
  {
    if ( !(v2->Reserved2[0] & 2) || (result = BaseVerifyFileName(v5, 0), result >= 0) )
    {
      if ( BaseDllGetApplicationName(ResultSize, 0, (int)&v9) )
      {
        result = BaseDllOpenMappingTarget(ResultSize, v5, v9, 1, &KeyHandle);
        if ( result >= 0 && KeyHandle != (HANDLE)-1 )
        {
          do
          {
            v6 = NtEnumerateValueKey(KeyHandle, 0, 0, &KeyValueInformation, 0x200u, &ResultLength);
            if ( v6 < 0 )
              break;
            ValueName.Buffer = (PWCH)&v15;
            ValueName.Length = v14;
            ValueName.MaximumLength = v14;
            v6 = NtDeleteValueKey(KeyHandle, &ValueName);
            if ( v6 == -1073741772 )
              v6 = 0;
          }
          while ( v6 >= 0 );
          if ( v6 == -2147483622 )
            v6 = 0;
          NtClose(KeyHandle);
          result = v6;
        }
      }
      else
      {
        result = -1073741811;
      }
    }
  }
  else
  {
    result = -1073741802;
  }
  return result;
}

//----- (77E692E1) --------------------------------------------------------
int __stdcall BaseDllWriteApplicationVariables(ULONG ResultSize, int a2)
{
  int result; // eax@2
  const void *v3; // ebx@3
  unsigned int v4; // edi@4
  int v5; // eax@7
  const void *v6; // eax@11
  const void *v7; // ecx@24
  int v8; // eax@24
  int v9; // ecx@28
  int v10; // ST50_4@38
  int v11; // eax@38
  const void *v12; // ecx@51
  int v13; // eax@51
  int v14; // ecx@55
  int v15; // eax@65
  int v16; // eax@65
  int Size; // [sp+20h] [bp-3Ch]@38
  const void *Src; // [sp+24h] [bp-38h]@19
  int v19; // [sp+28h] [bp-34h]@9
  NTSTATUS v20; // [sp+2Ch] [bp-30h]@0
  PVOID v21; // [sp+30h] [bp-2Ch]@9
  int v22; // [sp+34h] [bp-28h]@38
  PVOID Address; // [sp+38h] [bp-24h]@9
  PVOID Dst; // [sp+3Ch] [bp-20h]@7
  unsigned int v25; // [sp+40h] [bp-1Ch]@12
  int v26; // [sp+40h] [bp-1Ch]@24
  unsigned int v27; // [sp+40h] [bp-1Ch]@39
  int v28; // [sp+40h] [bp-1Ch]@51

  if ( *(_DWORD *)ResultSize == 8 )
  {
    result = BaseDllDeleteApplicationVariables(ResultSize, a2);
  }
  else
  {
    v3 = *(const void **)(ResultSize + 76);
    if ( v3 && (v4 = *(_DWORD *)(ResultSize + 80)) != 0
      || (v3 = *(const void **)(ResultSize + 84)) != 0 && (v4 = *(_DWORD *)(ResultSize + 88)) != 0 )
    {
      v5 = KernelBaseGetGlobalData();
      Dst = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), v4);
      if ( Dst )
      {
        Address = 0;
        _memmove(Dst, v3, v4);
        v21 = Dst;
        v19 = 0;
LABEL_10:
        if ( v4 )
        {
          v6 = v21;
          if ( *(_BYTE *)(ResultSize + 5) )
          {
            v25 = v4 >> 1;
            while ( v25 )
            {
              if ( !*(_WORD *)v6 || *(_WORD *)v6 > 0x20u )
              {
                if ( v25 && *(_WORD *)v6 )
                {
                  Src = v6;
                  *(_DWORD *)(ResultSize + 68) = v6;
                  while ( v25 )
                  {
                    if ( *(_WORD *)v6 == 61 )
                    {
                      if ( v25 )
                      {
                        v7 = v6;
                        v8 = (int)((char *)v6 + 2);
                        v26 = v25 - 1;
                        while ( (unsigned int)v7 > *(_DWORD *)(ResultSize + 68) && *((_WORD *)v7 - 1) <= 0x20u )
                          v7 = (char *)v7 - 2;
                        v9 = (int)((char *)v7 - *(_DWORD *)(ResultSize + 68));
                        *(_WORD *)(ResultSize + 64) = v9;
                        if ( (_WORD)v9 )
                        {
                          *(_WORD *)(ResultSize + 66) = v9 + 2;
                          while ( v26 && *(_WORD *)v8 == 32 )
                          {
                            --v26;
                            v8 += 2;
                          }
                          *(_DWORD *)(ResultSize + 84) = v8;
                          while ( v26 )
                          {
                            if ( !*(_WORD *)v8 )
                            {
                              if ( !v26 )
                                goto LABEL_74;
                              *(_DWORD *)(ResultSize + 88) = (unsigned __int16)(v8 - *(_WORD *)(ResultSize + 84));
                              v10 = v26 - 1;
                              v11 = v8 + 2;
                              Size = v11 - (_DWORD)Src;
                              v21 = (PVOID)v11;
                              v4 = 2 * v10;
                              v22 = 2 * v10;
                              goto LABEL_69;
                            }
                            --v26;
                            v8 += 2;
                          }
                        }
                      }
                      goto LABEL_74;
                    }
                    --v25;
                    v6 = (char *)v6 + 2;
                  }
                }
                break;
              }
              --v25;
              v6 = (char *)v6 + 2;
            }
          }
          else
          {
            v27 = v4;
            while ( v27 )
            {
              if ( !*(_BYTE *)v6 || *(_BYTE *)v6 > 0x20u )
              {
                if ( v27 && *(_BYTE *)v6 )
                {
                  Src = v6;
                  *(_DWORD *)(ResultSize + 52) = v6;
                  while ( v27 )
                  {
                    if ( *(_BYTE *)v6 == 61 )
                    {
                      if ( v27 )
                      {
                        v12 = v6;
                        v13 = (int)((char *)v6 + 1);
                        v28 = v27 - 1;
                        while ( (unsigned int)v12 > *(_DWORD *)(ResultSize + 52) && *((char *)v12 - 1) <= 0x20u )
                          v12 = (char *)v12 - 1;
                        v14 = (int)((char *)v12 - *(_DWORD *)(ResultSize + 52));
                        *(_WORD *)(ResultSize + 48) = v14;
                        if ( (_WORD)v14 )
                        {
                          *(_WORD *)(ResultSize + 50) = v14 + 1;
                          while ( v28 && *(_BYTE *)v13 == 32 )
                          {
                            --v28;
                            ++v13;
                          }
                          *(_DWORD *)(ResultSize + 76) = v13;
                          while ( v28 )
                          {
                            if ( !*(_BYTE *)v13 )
                            {
                              if ( !v28 )
                                goto LABEL_74;
                              *(_DWORD *)(ResultSize + 80) = (unsigned __int16)(v13 - *(_WORD *)(ResultSize + 76));
                              v15 = v13 + 1;
                              Size = v15 - (_DWORD)Src;
                              v21 = (PVOID)v15;
                              v22 = v28 - 1;
                              *(_WORD *)(ResultSize + 66) = 2 * *(_WORD *)(ResultSize + 50);
                              *(_WORD *)(ResultSize + 64) = 0;
                              v16 = KernelBaseGetGlobalData();
                              Address = RtlAllocateHeap(
                                          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                          *(_DWORD *)(v16 + 44),
                                          *(_WORD *)(ResultSize + 66) + 2 * *(_DWORD *)(ResultSize + 80) + 2);
                              if ( !Address )
                              {
                                v20 = -1073741801;
                                goto LABEL_74;
                              }
                              *(_DWORD *)(ResultSize + 68) = Address;
                              *(_DWORD *)(ResultSize + 84) = (char *)Address + *(_WORD *)(ResultSize + 66);
                              v4 = v28 - 1;
LABEL_69:
                              v20 = BaseDllWriteVariableValue(ResultSize, a2, 0, 0);
                              if ( Address )
                              {
                                RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
                                Address = 0;
                                RtlInitUnicodeString((PUNICODE_STRING)(ResultSize + 64), 0);
                                *(_DWORD *)(ResultSize + 84) = 0;
                                *(_DWORD *)(ResultSize + 88) = 0;
                                v4 = v22;
                              }
                              if ( v20 < 0 )
                              {
                                if ( v20 != -1073741802 )
                                  goto LABEL_74;
                                _memmove((char *)Dst + v19, Src, Size);
                                v19 += Size;
                                v20 = 0;
                              }
                              goto LABEL_10;
                            }
                            --v28;
                            ++v13;
                          }
                        }
                      }
                      goto LABEL_74;
                    }
                    --v27;
                    v6 = (char *)v6 + 1;
                  }
                }
                break;
              }
              --v27;
              v6 = (char *)v6 + 1;
            }
          }
        }
LABEL_74:
        if ( v19 )
        {
          *(_BYTE *)(ResultSize + 6) = 1;
          if ( *(_BYTE *)(ResultSize + 5) )
          {
            *(_DWORD *)(ResultSize + 84) = Dst;
            *(_DWORD *)(ResultSize + 88) = v19;
          }
          else
          {
            *(_DWORD *)(ResultSize + 76) = Dst;
            *(_DWORD *)(ResultSize + 80) = v19;
          }
          Dst = 0;
        }
        if ( Address )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        if ( Dst )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
        result = v20;
      }
      else
      {
        result = -1073741801;
      }
    }
    else
    {
      result = -1073741811;
    }
  }
  return result;
}

//----- (77E6972D) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
{
  unsigned int v4; // esi@1
  signed int v5; // eax@1
  DWORD result; // eax@5

  v4 = nSize;
  v5 = BaseDllReadWriteIniFile(0, 0, 1, (int)lpFileName, (int)lpAppName, 0, (int)lpReturnedString, (int)&nSize);
  if ( v5 >= 0 )
  {
    RtlSetLastWin32Error(0);
    result = nSize - 1;
  }
  else
  {
    if ( v5 != -2147483643 )
    {
      if ( v5 == -1073741701 )
        RtlSetLastWin32Error(13);
      else
        BaseSetLastNTError(v5);
      goto LABEL_5;
    }
    if ( v4 < 2 )
    {
LABEL_5:
      result = 0;
      goto LABEL_6;
    }
    result = v4 - 2;
    lpReturnedString[v4 - 1] = 0;
  }
LABEL_6:
  if ( result >= v4 )
  {
    if ( v4 > 0 )
      lpReturnedString[v4 - 1] = 0;
  }
  else
  {
    lpReturnedString[result] = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E697B1) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
{
  signed int v3; // eax@1
  BOOL result; // eax@2

  v3 = BaseDllReadWriteIniFile(0, 1, 1, (int)lpFileName, (int)lpAppName, 0, (int)lpString, 0);
  if ( v3 < 0 )
  {
    if ( v3 == -1073741701 )
      RtlSetLastWin32Error(13);
    else
      BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E697F9) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
{
  signed int v3; // eax@1
  BOOL result; // eax@2

  v3 = BaseDllReadWriteIniFile(1, 1, 1, (int)lpFileName, (int)lpAppName, 0, (int)lpString, 0);
  if ( v3 < 0 )
  {
    if ( v3 == -1073741701 )
      RtlSetLastWin32Error(13);
    else
      BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E69841) --------------------------------------------------------
DWORD __stdcall GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
{
  return GetPrivateProfileStringA(0, 0, 0, lpszReturnBuffer, nSize, lpFileName);
}

//----- (77E69862) --------------------------------------------------------
BOOL __stdcall GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
{
  BOOL result; // eax@2
  char *v6; // esi@4
  UINT v7; // ebx@8
  CHAR v8; // al@9
  unsigned __int8 v9; // cl@9
  int v10; // esi@9
  char v11; // al@10
  char v12; // cl@12
  char v13; // al@12
  unsigned __int8 v14; // dl@12
  char v15; // al@13
  char v16; // cl@15
  LPVOID v17; // eax@16
  BOOL v18; // [sp+10h] [bp-114h]@7
  PVOID Address; // [sp+14h] [bp-110h]@4
  LPVOID v20; // [sp+18h] [bp-10Ch]@1
  char v21; // [sp+1Fh] [bp-105h]@8
  char v22; // [sp+20h] [bp-104h]@6

  v20 = lpStruct;
  if ( uSizeStruct > 0x7FFFFFFA )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( 2 * uSizeStruct + 10 <= 0x100 )
  {
    Address = 0;
    v6 = &v22;
  }
  else
  {
    result = (BOOL)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * uSizeStruct + 10);
    v6 = (char *)result;
    Address = (PVOID)result;
    if ( !result )
      return result;
  }
  v18 = 0;
  if ( GetPrivateProfileStringA(lpszSection, lpszKey, 0, v6, 2 * uSizeStruct + 10, szFile) == 2 * uSizeStruct + 2 )
  {
    v7 = uSizeStruct + 1;
    v21 = 0;
    if ( uSizeStruct != -1 )
    {
      while ( 1 )
      {
        v8 = *v6;
        v9 = *v6 - 48;
        v10 = (int)(v6 + 1);
        v11 = v9 > 9u ? (v8 - 7) & 0xF : v8 - 48;
        v12 = v11;
        v13 = *(_BYTE *)v10;
        v14 = *(_BYTE *)v10 - 48;
        v6 = (char *)(v10 + 1);
        v15 = v14 > 9u ? (v13 - 7) & 0xF : v13 - 48;
        v16 = v15 | 16 * v12;
        if ( v7 == 1 )
          break;
        v21 += v16;
        v17 = v20;
        v20 = (char *)v20 + 1;
        --v7;
        *(_BYTE *)v17 = v16;
        if ( !v7 )
          goto LABEL_22;
      }
      if ( v21 == v16 )
        v18 = 1;
      else
        RtlSetLastWin32Error(13);
    }
  }
  else
  {
    RtlSetLastWin32Error(24);
  }
LABEL_22:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v18;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E699DE) --------------------------------------------------------
BOOL __stdcall GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
{
  DWORD v5; // esi@1
  BOOL result; // eax@2
  WCHAR *v7; // ebx@5
  UINT v8; // edi@7
  char v9; // dl@7
  WCHAR v10; // ax@8
  int v11; // ebx@8
  char v12; // al@9
  __int16 v13; // cx@13
  char v14; // cl@14
  char v15; // al@16
  LPVOID v16; // ecx@17
  BOOL v17; // [sp+14h] [bp-210h]@6
  LPVOID v18; // [sp+18h] [bp-20Ch]@1
  PVOID Address; // [sp+1Ch] [bp-208h]@5
  WCHAR ReturnedString; // [sp+20h] [bp-204h]@5

  v18 = lpStruct;
  v5 = 2 * uSizeStruct + 10;
  if ( v5 < uSizeStruct )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( v5 > 0x200 || 2 * v5 > 0x200 )
  {
    result = (BOOL)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v5);
    v7 = (WCHAR *)result;
    Address = (PVOID)result;
    if ( !result )
      return result;
  }
  else
  {
    Address = 0;
    v7 = &ReturnedString;
  }
  v17 = 0;
  if ( GetPrivateProfileStringW(lpszSection, lpszKey, 0, v7, v5, szFile) == 2 * uSizeStruct + 2 )
  {
    v8 = uSizeStruct + 1;
    v9 = 0;
    if ( uSizeStruct != -1 )
    {
      while ( 1 )
      {
        v10 = *v7;
        v11 = (int)(v7 + 1);
        v12 = (unsigned __int16)(v10 - 48) > 9u ? (v10 - 7) & 0xF : v10 - 48;
        v13 = *(_WORD *)v11;
        v7 = (WCHAR *)(v11 + 2);
        v14 = (unsigned __int16)(v13 - 48) > 9u ? (v13 - 7) & 0xF : v13 - 48;
        v15 = v14 | 16 * v12;
        if ( v8 == 1 )
          break;
        v16 = v18;
        v9 += v15;
        v18 = (char *)v18 + 1;
        --v8;
        *(_BYTE *)v16 = v15;
        if ( !v8 )
          goto LABEL_23;
      }
      if ( v9 == v15 )
        v17 = 1;
      else
        RtlSetLastWin32Error(13);
    }
  }
  else
  {
    RtlSetLastWin32Error(24);
  }
LABEL_23:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v17;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E69B5C) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
{
  LPVOID v5; // edi@1
  char v6; // bl@1
  UINT v8; // ecx@3
  char *v9; // esi@6
  unsigned __int8 v10; // dl@9
  int v11; // eax@9
  char v12; // cl@10
  int v13; // eax@10
  int v14; // eax@12
  BOOL v15; // esi@12
  PVOID Address; // [sp+14h] [bp-108h]@6
  char v17; // [sp+18h] [bp-104h]@8

  v5 = lpStruct;
  v6 = 0;
  if ( !lpStruct )
    return WritePrivateProfileStringA(lpszSection, lpszKey, 0, szFile);
  v8 = 2 * uSizeStruct + 3;
  if ( v8 < uSizeStruct )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( v8 <= 0x100 )
  {
    Address = 0;
    v9 = &v17;
  }
  else
  {
    v9 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * uSizeStruct + 3);
    Address = v9;
    if ( !v9 )
      return 0;
  }
  v10 = 0;
  v11 = (int)v9;
  if ( uSizeStruct )
  {
    do
    {
      v10 += *(_BYTE *)v5;
      v12 = *(_BYTE *)v5;
      *(_BYTE *)v11 = N2C[(unsigned int)*(_BYTE *)v5 >> 4];
      v5 = (char *)v5 + 1;
      v13 = v11 + 1;
      *(_BYTE *)v13 = N2C[v12 & 0xF];
      v11 = v13 + 1;
      --uSizeStruct;
    }
    while ( uSizeStruct );
    v6 = 0;
  }
  *(_BYTE *)v11 = N2C[(unsigned int)v10 >> 4];
  v14 = v11 + 1;
  *(_BYTE *)v14 = N2C[v10 & 0xF];
  *(_BYTE *)(v14 + 1) = v6;
  v15 = WritePrivateProfileStringA(lpszSection, lpszKey, v9, szFile);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v15;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E69C9F) --------------------------------------------------------
BOOL __stdcall WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
{
  LPVOID v5; // edi@1
  UINT v7; // eax@3
  char *v8; // esi@6
  unsigned __int8 v9; // dl@9
  int i; // eax@9
  char v11; // cl@10
  int v12; // eax@10
  int v13; // eax@11
  BOOL v14; // esi@11
  PVOID Address; // [sp+14h] [bp-208h]@6
  char v16; // [sp+18h] [bp-204h]@8

  v5 = lpStruct;
  if ( !lpStruct )
    return WritePrivateProfileStringW(lpszSection, lpszKey, 0, szFile);
  v7 = 2 * uSizeStruct + 3;
  if ( v7 < uSizeStruct )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( 2 * v7 <= 0x200 )
  {
    Address = 0;
    v8 = &v16;
  }
  else
  {
    v8 = (char *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v7);
    Address = v8;
    if ( !v8 )
      return 0;
  }
  v9 = 0;
  for ( i = (int)v8; uSizeStruct; --uSizeStruct )
  {
    v9 += *(_BYTE *)v5;
    v11 = *(_BYTE *)v5;
    *(_WORD *)i = N2C[(unsigned int)*(_BYTE *)v5 >> 4];
    v5 = (char *)v5 + 1;
    v12 = i + 2;
    *(_WORD *)v12 = N2C[v11 & 0xF];
    i = v12 + 2;
  }
  *(_WORD *)i = N2C[(unsigned int)v9 >> 4];
  v13 = i + 2;
  *(_WORD *)v13 = N2C[v9 & 0xF];
  *(_WORD *)(v13 + 2) = 0;
  v14 = WritePrivateProfileStringW(lpszSection, lpszKey, (LPCWSTR)v8, szFile);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v14;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E69DF1) --------------------------------------------------------
BOOL __stdcall WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
{
  return WritePrivateProfileStringA(lpAppName, lpKeyName, lpString, 0);
}

//----- (77E69E0F) --------------------------------------------------------
DWORD __stdcall GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
{
  return GetPrivateProfileSectionA(lpAppName, lpReturnedString, nSize, 0);
}

//----- (77E69E2D) --------------------------------------------------------
BOOL __stdcall WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
{
  return WritePrivateProfileSectionA(lpAppName, lpString, 0);
}

//----- (77E69E48) --------------------------------------------------------
BOOL __stdcall WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
{
  return WritePrivateProfileSectionW(lpAppName, lpString, 0);
}

//----- (77E69E63) --------------------------------------------------------
BOOL __stdcall DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
{
  BOOL result; // eax@1
  BOOL v4; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING v6; // [sp+8h] [bp-8h]@4

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpDeviceName);
  if ( result )
  {
    if ( lpTargetPath )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&v6, lpTargetPath) )
      {
        v4 = 0;
LABEL_6:
        RtlFreeUnicodeString(&UnicodeString);
        return v4;
      }
    }
    else
    {
      v6.Buffer = 0;
    }
    v4 = DefineDosDeviceW(dwFlags, UnicodeString.Buffer, v6.Buffer);
    if ( lpTargetPath )
      RtlFreeUnicodeString(&v6);
    goto LABEL_6;
  }
  return result;
}

//----- (77E69ED2) --------------------------------------------------------
DWORD __stdcall QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
{
  int v3; // ebx@1
  const WCHAR *v5; // esi@4
  int v6; // eax@6
  PVOID v7; // eax@6
  DWORD v8; // eax@9
  unsigned int v9; // esi@11
  int v10; // eax@17
  NTSTATUS v11; // eax@17
  int v12; // [sp+Ch] [bp-24h]@17
  char *v13; // [sp+10h] [bp-20h]@16
  unsigned __int16 v14; // [sp+14h] [bp-1Ch]@14
  __int16 v15; // [sp+16h] [bp-1Ah]@14
  CHAR *v16; // [sp+18h] [bp-18h]@14
  LSA_UNICODE_STRING UnicodeString; // [sp+1Ch] [bp-14h]@1
  DWORD v18; // [sp+24h] [bp-Ch]@9
  PVOID Address; // [sp+28h] [bp-8h]@6
  int v20; // [sp+2Ch] [bp-4h]@1
  LPCSTR lpDeviceNamea; // [sp+38h] [bp+8h]@12

  UnicodeString.Length = 0;
  *(_DWORD *)&UnicodeString.MaximumLength = 0;
  v3 = 0;
  HIWORD(UnicodeString.Buffer) = 0;
  v20 = 0;
  if ( lpDeviceName )
  {
    if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpDeviceName) )
      return 0;
    v5 = UnicodeString.Buffer;
  }
  else
  {
    v5 = 0;
  }
  v6 = KernelBaseGetGlobalData();
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 2 * ucchMax);
  Address = v7;
  if ( !v7 )
  {
    RtlSetLastWin32Error(8);
    if ( UnicodeString.Buffer )
      RtlFreeUnicodeString(&UnicodeString);
    return 0;
  }
  v8 = QueryDosDeviceW(v5, (LPWSTR)v7, ucchMax);
  v18 = v8;
  if ( v8 )
    v3 = v8 - 1;
  v9 = 0;
  if ( v3 )
  {
    while ( 1 )
    {
      lpDeviceNamea = (LPCSTR)32766;
      if ( v3 - v9 < 0x7FFE )
        lpDeviceNamea = (LPCSTR)(unsigned __int16)(v3 - v9);
      v16 = &lpTargetPath[v20];
      v14 = 0;
      v15 = -1;
      if ( ucchMax - v20 <= 0xFFFF )
        v15 = ucchMax - v20;
      v13 = (char *)Address + 2 * v9;
      while ( 1 )
      {
        LOWORD(v12) = 2 * (_WORD)lpDeviceNamea;
        HIWORD(v12) = 2 * (_WORD)lpDeviceNamea + 2;
        v10 = KernelBaseGetGlobalData();
        v11 = (*(int (__stdcall **)(unsigned __int16 *, int *, _DWORD))(v10 + 28))(&v14, &v12, 0);
        if ( v11 != -1073741584 )
          break;
        LOWORD(lpDeviceNamea) = (unsigned __int16)lpDeviceNamea >> 1;
      }
      if ( v11 < 0 )
        break;
      v20 += v14;
      v9 += (unsigned __int16)lpDeviceNamea;
      if ( v9 >= v3 )
        goto LABEL_23;
    }
    BaseSetLastNTError(v11);
    v18 = 0;
  }
LABEL_23:
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( UnicodeString.Buffer )
    RtlFreeUnicodeString(&UnicodeString);
  return v18;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6A048) --------------------------------------------------------
int __stdcall BaseWriteErrorElevationRequiredEvent()
{
  int result; // eax@1
  int v1; // [sp+0h] [bp-8h]@1
  int v2; // [sp+4h] [bp-4h]@2

  result = EtwEventRegister(MS_Windows_UAC_Provider, 0, 0, &v1);
  if ( !result )
  {
    EtwEventWrite(v1, v2, UACUnhandledErrorElevationRequired, 0, 0);
    result = EtwEventUnregister(v1, v2);
  }
  return result;
}
// 77DE1430: using guessed type int __stdcall EtwEventRegister(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1434: using guessed type int __stdcall EtwEventWrite(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1438: using guessed type int __stdcall EtwEventUnregister(_DWORD, _DWORD);
// 77E6A088: using guessed type int MS_Windows_UAC_Provider[4];
// 77E6A098: using guessed type int UACUnhandledErrorElevationRequired[3];

//----- (77E6A0AD) --------------------------------------------------------
int __stdcall DelayLoad_SetLastNtStatusAndWin32Error()
{
  return RtlSetLastWin32ErrorAndNtStatusFromNtStatus(-1073740782);
}
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E6A0BE) --------------------------------------------------------
int __stdcall SetFileIoOverlappedRange(HANDLE FileHandle, int a2, int a3)
{
  NTSTATUS v4; // eax@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-10h]@4
  int FileInformation; // [sp+8h] [bp-8h]@4
  int v7; // [sp+Ch] [bp-4h]@4

  if ( (unsigned int)a3 < 0x14 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v7 = a3;
  FileInformation = a2;
  v4 = NtSetInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 8u, FileIoStatusBlockRangeInformation);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6A110) --------------------------------------------------------
BOOL __stdcall SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
{
  BOOL result; // eax@2
  signed int v3; // eax@3
  NTSTATUS v4; // eax@9
  DWORD v5; // eax@12

  if ( dwNewMode & 0xFFFF7FFC )
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  else
  {
    v3 = 0;
    if ( dwNewMode & 1 )
      v3 = 16;
    if ( dwNewMode & 2 )
      v3 |= 0x20u;
    if ( dwNewMode & 0x8000 )
      v3 |= 0x40u;
    v4 = RtlSetThreadErrorMode(v3, &dwNewMode);
    if ( v4 >= 0 )
    {
      if ( lpOldMode )
      {
        v5 = 0;
        if ( dwNewMode & 0x10 )
          v5 = 1;
        if ( dwNewMode & 0x20 )
          v5 |= 2u;
        if ( dwNewMode & 0x40 )
          v5 |= 0x8000u;
        *lpOldMode = v5;
      }
      result = 1;
    }
    else
    {
      BaseSetLastNTError(v4);
      result = 0;
    }
  }
  return result;
}
// 77DE1420: using guessed type int __stdcall RtlSetThreadErrorMode(_DWORD, _DWORD);

//----- (77E6A196) --------------------------------------------------------
DWORD __stdcall GetThreadErrorMode()
{
  char v0; // cl@1
  DWORD result; // eax@1

  v0 = RtlGetThreadErrorMode();
  result = 0;
  if ( v0 & 0x10 )
    result = 1;
  if ( v0 & 0x20 )
    result |= 2u;
  if ( v0 & 0x40 )
    result |= 0x8000u;
  return result;
}
// 77DE141C: using guessed type _DWORD __stdcall RtlGetThreadErrorMode();

//----- (77E6A1BE) --------------------------------------------------------
int __stdcall BasepIoCompletion(PVOID Address, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@4
  void (__stdcall *v5)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx@4
  int v7; // [sp+0h] [bp-50h]@0
  int v8; // [sp+10h] [bp-40h]@1
  int v9; // [sp+14h] [bp-3Ch]@1
  char v10; // [sp+18h] [bp-38h]@1
  ULONG v11; // [sp+34h] [bp-1Ch]@2
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@6
  int v13; // [sp+5Ch] [bp+Ch]@2

  v8 = 36;
  v9 = 1;
  memset(&v10, 0, 0x1Cu);
  v3 = a2;
  if ( (*(_DWORD *)a2 & 0xC0000000) == -1073741824 )
  {
    v11 = RtlNtStatusToDosError(*(_DWORD *)a2);
    v13 = 0;
  }
  else
  {
    v11 = 0;
    v13 = *(_DWORD *)(a2 + 4);
  }
  v4 = *((_DWORD *)Address + 3);
  v5 = (void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*((_DWORD *)Address + 1);
  if ( !(*(_BYTE *)Address & 1) )
    BasepFreeActivationContextActivationBlock(Address);
  RtlActivateActivationContextUnsafeFast(&v8, v4);
  ms_exc.registration.TryLevel = 0;
  v5(v11, v13, v3, v7);
  ms_exc.registration.TryLevel = -2;
  return RtlDeactivateActivationContextUnsafeFast(&v8);
}
// 77DE140C: using guessed type int __fastcall RtlActivateActivationContextUnsafeFast(_DWORD, _DWORD);
// 77DE1410: using guessed type int __thiscall RtlDeactivateActivationContextUnsafeFast(_DWORD);

//----- (77E6A281) --------------------------------------------------------
int __stdcall BasepIoCompletionSimple(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3)
{
  ULONG v3; // eax@2
  int v4; // ecx@2

  if ( (*(_DWORD *)a2 & 0xC0000000) == -1073741824 )
  {
    v3 = RtlNtStatusToDosError(*(_DWORD *)a2);
    v4 = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a2 + 4);
    v3 = 0;
  }
  return a1(v3, v4, a2);
}

//----- (77E6A2B9) --------------------------------------------------------
int __stdcall FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, int a7)
{
  HANDLE v8; // [sp+10h] [bp-1Ch]@5

  if ( a7 == -1 || !a7 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a7);
  v8 = FindFirstFileExA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
  RtlSetCurrentTransaction(0);
  return (int)v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6A361) --------------------------------------------------------
int __stdcall FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, int a7)
{
  HANDLE v8; // [sp+10h] [bp-1Ch]@5

  if ( a7 == -1 || !a7 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a7);
  v8 = FindFirstFileExW(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
  RtlSetCurrentTransaction(0);
  return (int)v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6A409) --------------------------------------------------------
int __stdcall BasepBuildNameFromComponentsW(int a1, int a2, int a3, void *Dst)
{
  int v4; // edx@1
  unsigned int v5; // esi@1
  int v6; // eax@1
  int result; // eax@3
  signed int v8; // [sp+8h] [bp-4h]@1
  bool v9; // [sp+17h] [bp+Bh]@1

  v4 = a1;
  v8 = 0;
  v5 = *(_DWORD *)a1;
  v9 = *(_DWORD *)a1 == 2;
  v6 = *(_DWORD *)(a2 + 16) + (v5 >> 1) + (v9 == 0) + 1;
  if ( (unsigned int)v6 > *(_DWORD *)a3 )
    v8 = -2147483643;
  *(_DWORD *)a3 = v6;
  result = v8;
  if ( v8 >= 0 )
  {
    memcpy(Dst, (const void *)(v4 + 4), v5);
    if ( !v9 )
    {
      *(_WORD *)((char *)Dst + v5) = 92;
      v5 += 2;
    }
    memcpy((char *)Dst + v5, (const void *)(a2 + 20), 2 * *(_DWORD *)(a2 + 16));
    *(_WORD *)((char *)Dst + 2 * *(_DWORD *)(a2 + 16) + v5) = 0;
    result = v8;
  }
  return result;
}

//----- (77E6A4A2) --------------------------------------------------------
NTSTATUS __stdcall FindParent(void *a1, char a2, int a3, PVOID *a4)
{
  PVOID *v4; // ebx@2
  ULONG v5; // edi@5
  PVOID v6; // eax@5
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-50h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-38h]@1
  __int16 v10; // [sp+30h] [bp-30h]@1
  __int16 v11; // [sp+32h] [bp-2Eh]@1
  char *v12; // [sp+34h] [bp-2Ch]@1
  PVOID Address; // [sp+38h] [bp-28h]@1
  ULONG Size; // [sp+3Ch] [bp-24h]@1
  NTSTATUS v15; // [sp+40h] [bp-20h]@1
  HANDLE FileHandle; // [sp+44h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+48h] [bp-18h]@1

  FileHandle = (HANDLE)-1;
  Address = 0;
  Size = 512;
  ms_exc.registration.TryLevel = 0;
  v12 = &a2;
  v11 = 8;
  v10 = 8;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = a1;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&v10;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v15 = NtCreateFile(&FileHandle, 0x100080u, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 0, 1u, 0x2020u, 0, 0);
  if ( v15 >= 0 )
  {
    v4 = a4;
    while ( 1 )
    {
      if ( *v4 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *v4);
      v5 = Size;
      v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
      *v4 = v6;
      if ( !v6 )
        break;
      v15 = NtQueryInformationFile(FileHandle, &IoStatusBlock, v6, v5, FileNameInformation);
      Size = 2 * v5;
      if ( v15 != -2147483643 )
        goto LABEL_8;
    }
    v15 = -1073741670;
  }
LABEL_8:
  ms_exc.registration.TryLevel = -2;
  if ( FileHandle != (HANDLE)-1 )
    NtClose(FileHandle);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v15;
}

//----- (77E6A5F1) --------------------------------------------------------
int __stdcall FindFirstFileNameW(PWSTR dosname, int a2, int a3, void *Dst)
{
  HANDLE *v4; // esi@1
  PVOID v6; // eax@12
  ULONG *v7; // edi@12
  NTSTATUS v8; // eax@14
  HANDLE v9; // edi@18
  int v10; // edi@19
  int v11; // eax@21
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-54h]@6
  LSA_UNICODE_STRING ntname; // [sp+28h] [bp-3Ch]@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+30h] [bp-34h]@6
  ULONG Size; // [sp+38h] [bp-2Ch]@1
  HANDLE FileHandle; // [sp+3Ch] [bp-28h]@1
  HANDLE *v17; // [sp+40h] [bp-24h]@1
  NTSTATUS NtStatus; // [sp+44h] [bp-20h]@6
  PVOID Address; // [sp+48h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+4Ch] [bp-18h]@6

  Address = 0;
  Size = 96;
  FileHandle = (HANDLE)-1;
  v4 = 0;
  v17 = 0;
  if ( a2 )
  {
    RtlSetLastWin32Error(87);
    return -1;
  }
  if ( !RtlDosPathNameToNtPathName_U(dosname, &ntname, 0, 0) )
  {
    RtlSetLastWin32Error(3);
    return -1;
  }
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ms_exc.registration.TryLevel = 0;
  NtStatus = NtCreateFile(&FileHandle, 0x100080u, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 7u, 1u, 0x200020u, 0, 0);
  if ( !NtStatus )
  {
    v4 = (HANDLE *)BasepInitializeFindFileHandle((int)FileHandle);
    v17 = v4;
    if ( v4 )
    {
      FileHandle = 0;
      do
      {
        if ( Address )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
        v7 = (ULONG *)v6;
        Address = v6;
        if ( !v6 )
        {
          NtStatus = -1073741670;
          v4 = v17;
          goto LABEL_24;
        }
        v4 = v17;
        v8 = NtQueryInformationFile(*v17, &IoStatusBlock, v6, Size, FileHardLinkInformation);
        NtStatus = v8;
        Size = *v7;
      }
      while ( v8 == -2147483643 );
      if ( !v8 )
      {
        if ( IoStatusBlock.Information )
        {
          v4[1] = Address;
          v4[3] = (HANDLE)IoStatusBlock.Information;
          v4[4] = (HANDLE)IoStatusBlock.Information;
          Address = 0;
          v9 = v4[1];
          NtStatus = FindParent(*v4, *((_DWORD *)v9 + 4), *((_DWORD *)v9 + 5), &Address);
          if ( NtStatus >= 0 )
          {
            v10 = (int)((char *)v9 + 8);
            NtStatus = BasepBuildNameFromComponentsW((int)Address, v10, a3, Dst);
            if ( NtStatus >= 0 )
            {
              if ( *(_DWORD *)v10 <= 0u )
                v11 = (int)((char *)v4[1] + IoStatusBlock.Information);
              else
                v11 = (int)((char *)v4[1] + *(_DWORD *)v10 + 8);
              v4[2] = (HANDLE)v11;
            }
          }
        }
        else
        {
          NtStatus = -1073741807;
        }
      }
    }
    else
    {
      NtStatus = -1073741670;
    }
  }
LABEL_24:
  ms_exc.registration.TryLevel = -2;
  if ( ntname.Length )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    v4 = v17;
  }
  if ( Address )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    v4 = v17;
  }
  if ( NtStatus )
  {
    BaseSetLastNTError(NtStatus);
    if ( FileHandle != (HANDLE)-1 )
      NtClose(FileHandle);
    if ( v4 )
      FindClose(v4);
    v4 = (HANDLE *)-1;
    v17 = (HANDLE *)-1;
  }
  return (int)v4;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6A841) --------------------------------------------------------
int __stdcall FindNextFileNameW(int a1, int a2, void *Dst)
{
  int v3; // edi@1
  int v5; // eax@4
  int v6; // edi@7
  PVOID Address; // [sp+8h] [bp-4h]@1

  Address = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 == *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 4) )
  {
    BaseSetLastNTError(-1073741807);
    return 0;
  }
  v5 = FindParent(*(void **)a1, *(_DWORD *)(v3 + 8), *(_DWORD *)(v3 + 12), &Address);
  if ( v5 < 0 || (v5 = BasepBuildNameFromComponentsW((int)Address, v3, a2, Dst), v5 < 0) )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  v6 = *(_DWORD *)v3;
  if ( v6 )
    *(_DWORD *)(a1 + 8) += v6;
  else
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 4);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return 1;
}

//----- (77E6A8D5) --------------------------------------------------------
int __stdcall FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, int a5)
{
  HANDLE v6; // [sp+10h] [bp-1Ch]@5

  if ( a5 == -1 || !a5 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a5);
  v6 = FindFirstStreamW(lpFileName, InfoLevel, lpFindStreamData, dwFlags);
  RtlSetCurrentTransaction(0);
  return (int)v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6A979) --------------------------------------------------------
int __stdcall FindFirstFileNameTransactedW(PWSTR dosname, int a2, int a3, void *Dst, int a5)
{
  int v6; // [sp+10h] [bp-1Ch]@5

  if ( a5 == -1 || !a5 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a5);
  v6 = FindFirstFileNameW(dosname, a2, a3, Dst);
  RtlSetCurrentTransaction(0);
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6AA19) --------------------------------------------------------
BOOL __stdcall CancelSynchronousIo(HANDLE hThread)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2
  char v3; // [sp+0h] [bp-8h]@1

  v1 = NtCancelSynchronousIoFile(hThread, 0, &v3);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1404: using guessed type int __stdcall NtCancelSynchronousIoFile(_DWORD, _DWORD, _DWORD);

//----- (77E6AA49) --------------------------------------------------------
BOOLEAN __stdcall Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
{
  NTSTATUS v1; // eax@1
  BOOLEAN result; // al@2

  v1 = RtlWow64EnableFsRedirection(Wow64FsEnableRedirection);
  if ( v1 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  return result;
}
// 77DE13FC: using guessed type int __stdcall RtlWow64EnableFsRedirection(_DWORD);

//----- (77E6AA70) --------------------------------------------------------
BOOL __stdcall SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
{
  NTSTATUS v6; // eax@1
  DWORD FileInformation; // [sp+8h] [bp-1Ch]@1
  DWORD v9; // [sp+Ch] [bp-18h]@10
  char v10; // [sp+10h] [bp-14h]@10
  char v11; // [sp+11h] [bp-13h]@10
  unsigned int v12; // [sp+14h] [bp-10h]@4
  DWORD v13; // [sp+18h] [bp-Ch]@14
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-8h]@1

  v6 = NtQueryInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x14u, FileSfioReserveInformation);
  if ( v6 < 0 )
    goto LABEL_2;
  if ( !v12 )
  {
    *lpTransferSize = 0;
    *lpNumOutstandingRequests = 0;
    RtlSetLastWin32Error(1);
    return 0;
  }
  FileInformation = nBytesPerPeriod / v12;
  if ( !(nBytesPerPeriod / v12) && nBytesPerPeriod )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v9 = nPeriodMilliseconds;
  v11 = bDiscardable;
  v10 = 1;
  v6 = NtSetInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x14u, FileSfioReserveInformation);
  if ( v6 < 0 )
    goto LABEL_2;
  if ( nBytesPerPeriod )
  {
    v6 = NtQueryInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x14u, FileSfioReserveInformation);
    if ( v6 >= 0 )
    {
      *lpTransferSize = v12;
      *lpNumOutstandingRequests = v13;
      return 1;
    }
LABEL_2:
    BaseSetLastNTError(v6);
    return 0;
  }
  *lpTransferSize = 0;
  *lpNumOutstandingRequests = 0;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6AB46) --------------------------------------------------------
BOOL __stdcall GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
{
  NTSTATUS v6; // eax@1
  BOOL result; // eax@2
  DWORD v8; // eax@3
  DWORD v9; // edx@3
  int FileInformation; // [sp+0h] [bp-1Ch]@1
  DWORD v11; // [sp+4h] [bp-18h]@3
  unsigned __int8 v12; // [sp+9h] [bp-13h]@3
  DWORD v13; // [sp+Ch] [bp-10h]@3
  DWORD v14; // [sp+10h] [bp-Ch]@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+14h] [bp-8h]@1

  v6 = NtQueryInformationFile(hFile, &IoStatusBlock, &FileInformation, 0x14u, FileSfioReserveInformation);
  if ( v6 >= 0 )
  {
    v8 = v13;
    v9 = v14;
    *lpTransferSize = v13;
    *lpNumOutstandingRequests = v9;
    *lpPeriodMilliseconds = v11;
    *lpBytesPerPeriod = v8 * FileInformation;
    *pDiscardable = v12;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v6);
    result = 0;
  }
  return result;
}

//----- (77E6ABA9) --------------------------------------------------------
BOOL __stdcall SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
{
  ULONG v3; // edi@6
  int v4; // eax@8
  PVOID v5; // esi@8
  LPCWSTR v6; // eax@10
  const WCHAR v7; // cx@11
  unsigned int v8; // eax@12
  NTSTATUS v9; // edi@12
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-8h]@12

  if ( ((unsigned int)hFile & 0x10000003) == 3 )
  {
    BaseSetLastNTError(-1073741816);
    return 0;
  }
  if ( !lpShortName )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( wcslen(lpShortName) )
    v3 = 2 * wcslen(lpShortName) + 6;
  else
    v3 = 8;
  v4 = KernelBaseGetGlobalData();
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), v3);
  if ( !v5 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  v6 = lpShortName;
  do
  {
    v7 = *v6;
    ++v6;
  }
  while ( v7 );
  v8 = 2 * (v6 - (lpShortName + 1));
  *(_DWORD *)v5 = v8;
  wcscpy_s((wchar_t *)v5 + 2, (v8 >> 1) + 1, lpShortName);
  v9 = NtSetInformationFile(hFile, &IoStatusBlock, v5, v3, FileShortNameInformation);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  if ( v9 < 0 )
  {
    BaseSetLastNTError(v9);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6ACB2) --------------------------------------------------------
BOOL __stdcall SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
{
  BOOL result; // eax@1
  BOOL v3; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpShortName);
  if ( result )
  {
    v3 = SetFileShortNameW(hFile, UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E6ACED) --------------------------------------------------------
HANDLE __stdcall CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
{
  HANDLE result; // eax@2
  HANDLE v8; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v8 = CreateFileMappingNumaW(
         hFile,
         lpFileMappingAttributes,
         flProtect,
         dwMaximumSizeHigh,
         dwMaximumSizeLow,
         UnicodeString.Buffer,
         nndPreferred);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v8;
}

//----- (77E6AD49) --------------------------------------------------------
BOOL __stdcall SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, int a3)
{
  BOOL v4; // [sp+10h] [bp-1Ch]@4

  if ( a3 != -1 && a3 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v4 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a3);
      v4 = SetFileAttributesW(lpFileName, dwFileAttributes);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v4 = 0;
  }
  return v4;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6ADF1) --------------------------------------------------------
int __stdcall BasepMoveFileCopyProgress(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, HANDLE hFile, int a13)
{
  int v13; // esi@1
  int result; // eax@7
  int v15; // ST44_4@8
  int v16; // [sp+0h] [bp-2Ch]@0
  int v17; // [sp+64h] [bp+38h]@8

  v13 = a13;
  if ( *(_BYTE *)a13 & 8 && !a10 && a7 == a5 && a8 == a6 )
    FlushFileBuffers(hFile);
  if ( *(_DWORD *)(a13 + 4) )
  {
    v17 = RtlGetCurrentTransaction();
    RtlSetCurrentTransaction(0);
    v15 = (*(int (__stdcall **)(int, int, int, int, int, int, int, int, int, int, int, HANDLE, _DWORD, int))(v13 + 4))(
            a1,
            a2,
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10,
            a11,
            hFile,
            *(_DWORD *)(v13 + 8),
            v16);
    RtlSetCurrentTransaction(v17);
    result = v15;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6AEB9) --------------------------------------------------------
int __stdcall BasepNotifyTrackingService(PHANDLE FileHandle, int a2, int a3, PSTRING String2)
{
  int v4; // edi@6
  unsigned int v5; // edx@11
  POBJECT_ATTRIBUTES v6; // eax@13
  char v8; // [sp+10h] [bp-1B8h]@10
  unsigned int v9; // [sp+30h] [bp-198h]@11
  LSA_UNICODE_STRING DestinationString; // [sp+38h] [bp-190h]@3
  int v11; // [sp+40h] [bp-188h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+44h] [bp-184h]@7
  POBJECT_ATTRIBUTES ObjectAttributes; // [sp+4Ch] [bp-17Ch]@1
  STRING v14; // [sp+50h] [bp-178h]@3
  NTSTATUS v15; // [sp+58h] [bp-170h]@1
  char v16; // [sp+5Ch] [bp-16Ch]@3
  WCHAR SourceString; // [sp+160h] [bp-68h]@1
  int FileInformation; // [sp+180h] [bp-48h]@7
  int v19; // [sp+184h] [bp-44h]@2
  char Dst[40]; // [sp+188h] [bp-40h]@6
  CPPEH_RECORD ms_exc; // [sp+1B0h] [bp-18h]@1

  ObjectAttributes = (POBJECT_ATTRIBUTES)a2;
  v15 = 0;
  ms_exc.registration.TryLevel = 0;
  v11 = 16;
  if ( BasepGetComputerNameFromNtPath(String2, a3, (int)&SourceString, (int)&v11) )
  {
    v19 = 0;
  }
  else
  {
    v14.Length = 0;
    v14.MaximumLength = 260;
    v14.Buffer = &v16;
    RtlInitUnicodeString(&DestinationString, &SourceString);
    v15 = RtlUnicodeStringToOemString(&v14, &DestinationString, 0);
    if ( v15 < 0 )
      return v15;
    if ( v14.Length > 0x1Eu )
      return -2147483643;
    v4 = v14.Length;
    memcpy(Dst, v14.Buffer, v14.Length);
    Dst[v4] = 0;
    v19 = v14.Length + 1;
  }
  FileInformation = a3;
  v15 = NtSetInformationFile(*FileHandle, &IoStatusBlock, &FileInformation, 0x2Cu, FileTrackingInformation);
  if ( v15 == -1073741790 )
  {
    CloseHandle(*FileHandle);
    v15 = NtOpenFile(FileHandle, 0x100180u, ObjectAttributes, &IoStatusBlock, 7u, 0x20u);
    if ( v15 >= 0 )
    {
      v15 = NtQueryInformationFile(*FileHandle, &IoStatusBlock, &v8, 0x28u, FileBasicInformation);
      if ( v15 >= 0 )
      {
        v5 = v9;
        v14.Buffer = (PCHAR)v9;
        memset(&v8, 0, 0x28u);
        v9 = v5 & 0xFFFFFFFE;
        v15 = NtSetInformationFile(*FileHandle, &IoStatusBlock, &v8, 0x28u, FileBasicInformation);
        if ( v15 >= 0 )
        {
          v15 = NtOpenFile((PHANDLE)&ObjectAttributes, 0x40100000u, ObjectAttributes, &IoStatusBlock, 7u, 0x20u);
          if ( v15 < 0
            || (NtClose(*FileHandle),
                v6 = ObjectAttributes,
                *FileHandle = ObjectAttributes,
                v15 = NtSetInformationFile(v6, &IoStatusBlock, &FileInformation, 0x2Cu, FileTrackingInformation),
                v15 < 0) )
          {
            v9 = (unsigned int)v14.Buffer;
            NtSetInformationFile(*FileHandle, &IoStatusBlock, &v8, 0x28u, FileBasicInformation);
          }
        }
      }
    }
    else
    {
      *FileHandle = (HANDLE)-1;
    }
  }
  return v15;
}
// 77E6AEB9: using guessed type char Dst[40];

//----- (77E6B131) --------------------------------------------------------
NTSTATUS __stdcall BasepOpenFileForMove(int a1, int a2, int a3, PHANDLE FileHandle, POBJECT_ATTRIBUTES ObjectAttributes, int a6, int a7, ULONG OpenOptions)
{
  NTSTATUS v8; // eax@6
  NTSTATUS v9; // eax@9
  NTSTATUS v10; // eax@8
  int v12; // [sp+10h] [bp-40h]@1
  int v13; // [sp+14h] [bp-3Ch]@4
  void *v14; // [sp+18h] [bp-38h]@5
  int FileInformation; // [sp+20h] [bp-30h]@9
  int v16; // [sp+24h] [bp-2Ch]@14
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-28h]@6
  int v18; // [sp+30h] [bp-20h]@1
  NTSTATUS v19; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1
  ULONG OpenOptionsa; // [sp+74h] [bp+24h]@6

  v19 = 0;
  v18 = 0;
  ms_exc.registration.TryLevel = 0;
  *(_WORD *)(a2 + 2) = 0;
  *(_WORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a3 = 0;
  if ( !(unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(a1, a2, 0, &v12) )
  {
    v19 = -1073741766;
    goto LABEL_17;
  }
  v18 = 1;
  *(_DWORD *)a3 = *(_DWORD *)(a2 + 4);
  if ( (_WORD)v12 )
  {
    *(_DWORD *)a2 = v12;
    *(_DWORD *)(a2 + 4) = v13;
  }
  else
  {
    v14 = 0;
  }
  ObjectAttributes->Length = 24;
  ObjectAttributes->RootDirectory = v14;
  ObjectAttributes->Attributes = 64;
  ObjectAttributes->ObjectName = (PUNICODE_STRING)a2;
  ObjectAttributes->SecurityDescriptor = 0;
  ObjectAttributes->SecurityQualityOfService = 0;
  OpenOptionsa = OpenOptions | 0x4020;
  v8 = NtOpenFile(FileHandle, a6 | 0x100080, ObjectAttributes, &IoStatusBlock, a7 | 3, OpenOptionsa | 0x200000);
  v19 = v8;
  if ( v8 >= 0 )
  {
    v9 = NtQueryInformationFile(*FileHandle, &IoStatusBlock, &FileInformation, 8u, FileAttributeTagInformation);
    v19 = v9;
    if ( v9 < 0 && v9 != -1073741822 && v9 != -1073741811 || v19 < 0 || !(FileInformation & 0x400) || v16 == -1610612733 )
      goto LABEL_17;
    NtClose(*FileHandle);
    *FileHandle = (HANDLE)-1;
    v10 = NtOpenFile(FileHandle, a6 | 0x100000, ObjectAttributes, &IoStatusBlock, a7 | 5, OpenOptionsa);
  }
  else
  {
    if ( v8 != -1073741811 )
      goto LABEL_17;
    v10 = NtOpenFile(FileHandle, a6 | 0x100000, ObjectAttributes, &IoStatusBlock, a7 | 3, OpenOptionsa);
  }
  v19 = v10;
LABEL_17:
  ms_exc.registration.TryLevel = -2;
  if ( v18 )
    RtlReleaseRelativeName(&v12);
  return v19;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);

//----- (77E6B2E1) --------------------------------------------------------
bool __stdcall PrivMoveFileIdentityW(int a1, int a2, char a3)
{
  NTSTATUS v3; // eax@3
  NTSTATUS v4; // eax@16
  NTSTATUS v5; // eax@36
  OBJECT_ATTRIBUTES v7; // [sp+10h] [bp-D4h]@16
  int FileInformation; // [sp+28h] [bp-BCh]@27
  int v9; // [sp+2Ch] [bp-B8h]@28
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+50h] [bp-94h]@3
  int v11; // [sp+68h] [bp-7Ch]@28
  int v12; // [sp+6Ch] [bp-78h]@28
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+90h] [bp-54h]@27
  int v14; // [sp+98h] [bp-4Ch]@1
  int v15; // [sp+9Ch] [bp-48h]@1
  struct _STRING String2; // [sp+A0h] [bp-44h]@1
  int v17; // [sp+A8h] [bp-3Ch]@14
  PVOID Address; // [sp+ACh] [bp-38h]@1
  int v19; // [sp+B0h] [bp-34h]@1
  PVOID v20; // [sp+B4h] [bp-30h]@1
  char v21; // [sp+BBh] [bp-29h]@1
  HANDLE FileHandle; // [sp+BCh] [bp-28h]@1
  HANDLE Handle; // [sp+C0h] [bp-24h]@1
  NTSTATUS NtStatus; // [sp+C4h] [bp-20h]@1
  NTSTATUS v25; // [sp+C8h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+CCh] [bp-18h]@1
  int v27; // [sp+ECh] [bp+8h]@14

  v25 = 0;
  NtStatus = 0;
  Handle = (HANDLE)-1;
  FileHandle = (HANDLE)-1;
  v14 = 0;
  v15 = 0;
  Address = 0;
  String2.Length = 0;
  String2.MaximumLength = 0;
  String2.Buffer = 0;
  v20 = 0;
  v21 = 1;
  ms_exc.registration.TryLevel = 0;
  v19 = 130;
  if ( a3 & 1 )
    v19 = 65666;
  while ( 1 )
  {
    v3 = BasepOpenFileForMove(a1, (int)&v14, (int)&Address, &Handle, &ObjectAttributes, v19, 7, 0x400000u);
    v25 = v3;
    if ( v3 >= 0 )
      break;
    if ( !(v19 & 2) || !(a3 & 2) )
    {
      if ( v3 < 0 )
        goto LABEL_41;
      break;
    }
    if ( Address )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      Address = 0;
    }
    if ( Handle != (HANDLE)-1 )
    {
      NtClose(Handle);
      Handle = (HANDLE)-1;
    }
    v19 &= 0xFFFFFFFD;
    if ( NtStatus >= 0 )
      NtStatus = v25;
    v25 = 0;
  }
  v17 = 256;
  v27 = v19 & 2;
  if ( v19 & 2 )
    v17 = 258;
  while ( 1 )
  {
    v4 = BasepOpenFileForMove(a2, (int)&String2, (int)&v20, &FileHandle, &v7, v27 | 0x100, 7, 0x400000u);
    v25 = v4;
    if ( v4 >= 0 )
      break;
    if ( !(v17 & 2) || !(a3 & 2) )
    {
      if ( v4 < 0 )
        goto LABEL_41;
      break;
    }
    if ( v20 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v20);
      v20 = 0;
    }
    if ( FileHandle != (HANDLE)-1 )
    {
      NtClose(FileHandle);
      FileHandle = (HANDLE)-1;
    }
    v17 &= 0xFFFFFFFD;
    if ( NtStatus >= 0 )
      NtStatus = v25;
    v25 = 0;
  }
  v25 = NtQueryInformationFile(Handle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
  if ( v25 >= 0 )
  {
    memset(&v11, 0, 0x28u);
    v11 = FileInformation;
    v12 = v9;
    v25 = NtSetInformationFile(FileHandle, &IoStatusBlock, &v11, 0x28u, FileBasicInformation);
  }
  if ( v25 < 0 )
  {
    if ( !(a3 & 2) )
      goto LABEL_41;
    if ( NtStatus >= 0 )
      NtStatus = v25;
    v25 = 0;
  }
  if ( v17 & 2 )
  {
    if ( v27 )
    {
      v5 = BasepNotifyTrackingService(&Handle, (int)&ObjectAttributes, (int)FileHandle, &String2);
      v25 = v5;
      if ( v5 < 0 )
      {
        if ( a3 & 2 )
        {
          if ( NtStatus >= 0 )
            NtStatus = v5;
          v25 = 0;
        }
      }
    }
  }
LABEL_41:
  ms_exc.registration.TryLevel = -2;
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v20 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v20);
  if ( v25 >= 0 && a3 & 1 )
    v25 = NtSetInformationFile(Handle, &IoStatusBlock, &v21, 1u, FileDispositionInformation);
  if ( FileHandle != (HANDLE)-1 )
    NtClose(FileHandle);
  if ( Handle != (HANDLE)-1 )
    NtClose(Handle);
  if ( v25 >= 0 )
  {
    if ( NtStatus < 0 )
      BaseSetLastNTError(NtStatus);
  }
  else
  {
    BaseSetLastNTError(v25);
  }
  return v25 >= 0;
}

//----- (77E6B5D9) --------------------------------------------------------
DWORD __stdcall GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
{
  DWORD result; // eax@2
  PVOID v3; // ebx@3
  NTSTATUS v4; // edi@6
  DWORD v5; // esi@9
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-54h]@6
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-4Ch]@6
  int v8; // [sp+24h] [bp-34h]@1
  void *v9; // [sp+28h] [bp-30h]@4
  void *v10; // [sp+2Ch] [bp-2Ch]@5
  int v11; // [sp+34h] [bp-24h]@1
  PVOID Address; // [sp+38h] [bp-20h]@3
  LPDWORD v13; // [sp+3Ch] [bp-1Ch]@1
  HANDLE FileHandle; // [sp+40h] [bp-18h]@6
  DWORD FileInformation; // [sp+44h] [bp-14h]@8
  DWORD v16; // [sp+48h] [bp-10h]@11

  v13 = lpFileSizeHigh;
  if ( (unsigned __int8)RtlDosPathNameToRelativeNtPathName_U(lpFileName, &v11, 0, &v8) )
  {
    v3 = Address;
    if ( (_WORD)v8 )
    {
      v11 = v8;
      Address = v9;
    }
    else
    {
      v10 = 0;
    }
    ObjectAttributes.RootDirectory = v10;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v11;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v4 = NtOpenFile(&FileHandle, 0x80u, &ObjectAttributes, &IoStatusBlock, 7u, 0x4000u);
    RtlReleaseRelativeName(&v8);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
    if ( v4 >= 0 )
    {
      if ( NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x10u, FileCompressionInformation) >= 0 )
      {
        NtClose(FileHandle);
        if ( v13 )
          *v13 = v16;
        if ( FileInformation == -1 )
          RtlSetLastWin32Error(0);
        result = FileInformation;
      }
      else
      {
        v5 = GetFileSize(FileHandle, v13);
        NtClose(FileHandle);
        result = v5;
      }
    }
    else
    {
      BaseSetLastNTError(v4);
      result = -1;
    }
  }
  else
  {
    RtlSetLastWin32Error(3);
    result = -1;
  }
  return result;
}
// 77DE14E8: using guessed type int __stdcall RtlDosPathNameToRelativeNtPathName_U(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE14EC: using guessed type int __stdcall RtlReleaseRelativeName(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6B711) --------------------------------------------------------
PVOID __stdcall GetFullPath(LPCWSTR lpFileName)
{
  PVOID v1; // edi@1
  DWORD v2; // esi@1
  LPWSTR FilePart; // [sp+Ch] [bp-4h]@1

  v1 = 0;
  FilePart = 0;
  v2 = GetFullPathNameW(lpFileName, 0, 0, &FilePart);
  if ( v2 )
  {
    v1 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * v2);
    if ( !v1 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    if ( !GetFullPathNameW(lpFileName, v2, (LPWSTR)v1, &FilePart) )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
      v1 = 0;
    }
  }
  return v1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6B794) --------------------------------------------------------
int __stdcall SetFileAttributesTransactedA(int a1, DWORD dwFileAttributes, int a3)
{
  int result; // eax@1
  int v4; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1);
  if ( result )
  {
    v4 = SetFileAttributesTransactedW(UnicodeString.Buffer, dwFileAttributes, a3);
    RtlFreeUnicodeString(&UnicodeString);
    result = v4;
  }
  return result;
}

//----- (77E6B7D2) --------------------------------------------------------
int __stdcall GetFileAttributesTransactedA(int a1, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, int a4)
{
  int result; // eax@1
  int v5; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1);
  if ( result )
  {
    v5 = GetFileAttributesTransactedW(UnicodeString.Buffer, fInfoLevelId, lpFileInformation, a4);
    RtlFreeUnicodeString(&UnicodeString);
    result = v5;
  }
  return result;
}

//----- (77E6B813) --------------------------------------------------------
BOOL __stdcall DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
{
  BOOL result; // eax@1
  int v3; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpFileName);
  if ( result )
  {
    v3 = DeleteFileTransactedW(UnicodeString.Buffer, (int)hTransaction);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E6B84E) --------------------------------------------------------
DWORD __stdcall GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, int a3)
{
  DWORD v4; // [sp+10h] [bp-1Ch]@5

  if ( a3 == -1 || !a3 )
  {
    RtlSetLastWin32Error(6700);
    return -1;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return -1;
  }
  RtlSetCurrentTransaction(a3);
  v4 = GetCompressedFileSizeW(lpFileName, lpFileSizeHigh);
  RtlSetCurrentTransaction(0);
  return v4;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6B8E9) --------------------------------------------------------
DWORD __stdcall GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
{
  DWORD result; // eax@2
  DWORD v3; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpFileName) )
  {
    v3 = GetCompressedFileSizeW(UnicodeString.Buffer, lpFileSizeHigh);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (77E6B929) --------------------------------------------------------
BOOL __stdcall CreateSymbolicLinkW(PWSTR dosname, PWSTR Path, int FileInformation)
{
  PVOID v3; // esi@1
  WCHAR *v4; // edi@2
  int v5; // eax@4
  PVOID v7; // eax@24
  __int16 v8; // ax@26
  unsigned int v9; // eax@27
  ULONG v10; // esi@27
  int v11; // eax@27
  PWSTR v12; // eax@31
  WCHAR v13; // dx@32
  unsigned __int16 v14; // ax@33
  unsigned __int16 v15; // ax@33
  NTSTATUS v16; // eax@36
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-4Ch]@35
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+24h] [bp-34h]@35
  LSA_UNICODE_STRING v19; // [sp+2Ch] [bp-2Ch]@1
  LSA_UNICODE_STRING ntname; // [sp+34h] [bp-24h]@1
  int v21; // [sp+3Ch] [bp-1Ch]@3
  int v22; // [sp+40h] [bp-18h]@4
  ULONG InputBufferLength; // [sp+44h] [bp-14h]@27
  int v24; // [sp+48h] [bp-10h]@1
  PVOID Address; // [sp+4Ch] [bp-Ch]@1
  HANDLE Handle; // [sp+50h] [bp-8h]@1
  char v27; // [sp+57h] [bp-1h]@1

  Handle = (HANDLE)-1;
  v3 = 0;
  v19.Length = 0;
  v19.MaximumLength = 0;
  v19.Buffer = 0;
  ntname.Length = 0;
  ntname.MaximumLength = 0;
  ntname.Buffer = 0;
  v27 = 0;
  Address = 0;
  v24 = 0;
  if ( dosname && (v4 = Path) != 0 && (v21 = FileInformation & 1, v21 == FileInformation) )
  {
    RtlSetLastWin32Error(0);
    v22 = 35;
    v5 = RtlAcquirePrivilege(&v22, 1, 0, &v24);
    if ( v5 >= 0 )
    {
      switch ( RtlDetermineDosPathNameType_U(Path) )
      {
        case 1u:
        case 2u:
        case 6u:
        case 7u:
          v27 = 0;
          goto LABEL_8;
        case 3u:
          v7 = GetFullPath(Path);
          Address = v7;
          if ( !v7 )
            break;
          Path = (PWSTR)v7;
          v27 = 0;
          v4 = (WCHAR *)v7;
          goto LABEL_8;
        case 0u:
        case 4u:
        case 5u:
          v27 = 1;
          ntname.Buffer = Path;
          v8 = wcslen(Path);
          ntname.MaximumLength = 2 * v8;
          ntname.Length = 2 * v8;
          goto LABEL_27;
        default:
LABEL_8:
          if ( !RtlDosPathNameToNtPathName_U(v4, &ntname, 0, 0) )
            goto LABEL_9;
LABEL_27:
          v9 = wcslen(v4);
          v10 = ntname.Length + 2 * v9 + 20;
          InputBufferLength = ntname.Length + 2 * v9 + 20;
          v11 = KernelBaseGetGlobalData();
          v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v11 + 44), v10);
          if ( !v3 )
          {
            RtlSetLastWin32Error(8);
            break;
          }
          memset(v3, 0, 0x18u);
          if ( v27 )
            *((_DWORD *)v3 + 4) |= 1u;
          *((_WORD *)v3 + 2) = InputBufferLength - 8;
          *((_WORD *)v3 + 6) = 0;
          v12 = Path;
          *(_DWORD *)v3 = -1610612724;
          do
          {
            v13 = *v12;
            ++v12;
          }
          while ( v13 );
          v14 = 2 * (v12 - (Path + 1));
          *((_WORD *)v3 + 7) = v14;
          memcpy((char *)v3 + 20, Path, v14);
          v15 = *((_WORD *)v3 + 7);
          *((_WORD *)v3 + 4) = v15;
          *((_WORD *)v3 + 5) = ntname.Length;
          memcpy((char *)v3 + v15 + 20, ntname.Buffer, ntname.Length);
          if ( !RtlDosPathNameToNtPathName_U(dosname, &v19, 0, 0) )
          {
            RtlSetLastWin32Error(3);
            break;
          }
          ObjectAttributes.ObjectName = &v19;
          ObjectAttributes.Length = 24;
          ObjectAttributes.RootDirectory = 0;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0;
          ObjectAttributes.SecurityQualityOfService = 0;
          v5 = NtCreateFile(
                 &Handle,
                 0x110100u,
                 &ObjectAttributes,
                 &IoStatusBlock,
                 0,
                 0x80u,
                 0,
                 2u,
                 v21 != 0 ? 2097185 : 2097248,
                 0,
                 0);
          if ( v5 < 0 )
            goto LABEL_5;
          v16 = NtFsControlFile(Handle, 0, 0, 0, &IoStatusBlock, 0x900A4u, v3, InputBufferLength, 0, 0);
          if ( v16 < 0 )
          {
            BaseSetLastNTError(v16);
            BYTE3(FileInformation) = 1;
            NtSetInformationFile(Handle, &IoStatusBlock, (char *)&FileInformation + 3, 1u, FileDispositionInformation);
          }
          break;
      }
    }
    else
    {
LABEL_5:
      BaseSetLastNTError(v5);
    }
  }
  else
  {
LABEL_9:
    RtlSetLastWin32Error(87);
  }
  if ( v24 )
    RtlReleasePrivilege(v24);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v3 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
  if ( !v27 && ntname.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
  if ( v19.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v19.Buffer);
  if ( Handle != (HANDLE)-1 )
    NtClose(Handle);
  return GetLastError() == 0;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6BC41) --------------------------------------------------------
int __stdcall BasepMoveFileDelayed(int a1, int a2, int a3, char a4, ULONG a5)
{
  int result; // eax@5
  int v6; // eax@12
  PVOID v7; // eax@12
  char *v8; // esi@14
  int v9; // esi@14
  int v10; // eax@18
  PVOID v11; // eax@18
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-E8h]@1
  LSA_UNICODE_STRING v13; // [sp+14h] [bp-E0h]@2
  HANDLE SystemInformation; // [sp+1Ch] [bp-D8h]@14
  LSA_UNICODE_STRING *v15; // [sp+20h] [bp-D4h]@14
  int *v16; // [sp+24h] [bp-D0h]@14
  PVOID v17; // [sp+28h] [bp-CCh]@14
  ULONG v18; // [sp+2Ch] [bp-C8h]@14
  int v19; // [sp+30h] [bp-C4h]@14
  PVOID v20; // [sp+34h] [bp-C0h]@14
  ULONG v21; // [sp+38h] [bp-BCh]@14
  char v22; // [sp+3Ch] [bp-B8h]@14
  char v23; // [sp+3Dh] [bp-B7h]@14
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+40h] [bp-B4h]@4
  ULONG v25; // [sp+58h] [bp-9Ch]@1
  PVOID v26; // [sp+5Ch] [bp-98h]@12
  ULONG v27; // [sp+60h] [bp-94h]@1
  HANDLE KeyHandle; // [sp+64h] [bp-90h]@5
  PVOID Address; // [sp+68h] [bp-8Ch]@1
  ULONG Size; // [sp+6Ch] [bp-88h]@1
  wchar_t pszDest; // [sp+70h] [bp-84h]@3

  Size = a5;
  v25 = 0;
  Address = 0;
  v27 = 0;
  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager");
  if ( a3 == 1 )
  {
    RtlInitUnicodeString(&v13, L"PendingFileRenameOperations");
  }
  else
  {
    RtlStringCchPrintfW(&pszDest, 0x40u, L"PendingFileRenameOperations%d", a3);
    RtlInitUnicodeString(&v13, &pszDest);
  }
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 192;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  if ( Size )
    result = NtCreateKeyTransacted(&KeyHandle, -1073741824, &ObjectAttributes, 0, 0, 0, Size, 0);
  else
    result = NtCreateKey(&KeyHandle, 0xC0000000, &ObjectAttributes, 0, 0, 0, 0);
  if ( result == -1073741790 )
  {
    if ( Size )
      result = NtCreateKeyTransacted(&KeyHandle, -1073741824, &ObjectAttributes, 0, 0, 4, Size, 0);
    else
      result = NtCreateKey(&KeyHandle, 0xC0000000, &ObjectAttributes, 0, 0, 4u, 0);
  }
  if ( result >= 0 )
  {
    Size = *(_WORD *)a1 + *(_WORD *)a2 + 6;
    v6 = KernelBaseGetGlobalData();
    v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), Size);
    v26 = v7;
    if ( v7 )
    {
      memcpy(v7, *(const void **)(a1 + 4), *(_WORD *)a1);
      v8 = (char *)v26 + *(_WORD *)a1;
      *v8++ = 0;
      *v8++ = 0;
      memcpy(v8, *(const void **)(a2 + 4), *(_WORD *)a2);
      v9 = (int)&v8[*(_WORD *)a2];
      *(_BYTE *)v9++ = 0;
      *(_BYTE *)v9++ = 0;
      *(_BYTE *)v9 = 0;
      *(_BYTE *)(v9 + 1) = 0;
      SystemInformation = KeyHandle;
      v15 = &v13;
      v16 = (int *)&v25;
      v20 = v26;
      v21 = Size;
      v22 = a4;
      v19 = 7;
      v23 = 1;
      v17 = 0;
      v18 = 0;
      Size = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)110, &SystemInformation, 0x24u);
      if ( Size == -1073741789 )
      {
        while ( 1 )
        {
          if ( v25 <= v27 )
          {
            Size = -1073741823;
            goto LABEL_23;
          }
          if ( Address )
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
          v27 = v25;
          v10 = KernelBaseGetGlobalData();
          v11 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v10 + 44), v27);
          Address = v11;
          if ( !v11 )
            break;
          v17 = v11;
          v18 = v27;
          Size = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)110, &SystemInformation, 0x24u);
          if ( Size != -1073741789 )
            goto LABEL_23;
        }
        Size = -1073741670;
LABEL_23:
        if ( Address )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v26);
    }
    else
    {
      Size = -1073741670;
    }
    NtClose(KeyHandle);
    result = Size;
  }
  return result;
}
// 77DE13EC: using guessed type int __stdcall NtCreateKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E6BFE8: using guessed type wchar_t aPendingfiler_0[28];

//----- (77E6C0AB) --------------------------------------------------------
DWORD __stdcall GetCompressedFileSizeTransactedA(int a1, LPDWORD lpFileSizeHigh, int a3)
{
  DWORD result; // eax@2
  DWORD v4; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1) )
  {
    v4 = GetCompressedFileSizeTransactedW(UnicodeString.Buffer, lpFileSizeHigh, a3);
    RtlFreeUnicodeString(&UnicodeString);
    result = v4;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (77E6C0EE) --------------------------------------------------------
char __stdcall CreateSymbolicLinkTransactedW(PWSTR dosname, PWSTR Path, int FileInformation, int a4)
{
  char v5; // [sp+13h] [bp-19h]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v5 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      v5 = CreateSymbolicLinkW(dosname, Path, FileInformation);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v5 = 0;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6C199) --------------------------------------------------------
char __stdcall CreateSymbolicLinkA(int a1, int a2, int FileInformation)
{
  char v3; // bl@6
  LSA_UNICODE_STRING v5; // [sp+0h] [bp-10h]@4
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@3

  if ( a1 && a2 )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1) )
    {
      if ( Basep8BitStringToDynamicUnicodeString((int)&v5, (PCSZ)a2) )
      {
        v3 = CreateSymbolicLinkW(UnicodeString.Buffer, v5.Buffer, FileInformation);
        RtlFreeUnicodeString(&v5);
        RtlFreeUnicodeString(&UnicodeString);
        return v3;
      }
      RtlFreeUnicodeString(&UnicodeString);
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6C216) --------------------------------------------------------
char __stdcall CreateSymbolicLinkTransactedA(int a1, int a2, int FileInformation, int a4)
{
  char v4; // bl@6
  LSA_UNICODE_STRING v6; // [sp+0h] [bp-10h]@4
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@3

  if ( a1 && a2 )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1) )
    {
      if ( Basep8BitStringToDynamicUnicodeString((int)&v6, (PCSZ)a2) )
      {
        v4 = CreateSymbolicLinkTransactedW(UnicodeString.Buffer, v6.Buffer, FileInformation, a4);
        RtlFreeUnicodeString(&v6);
        RtlFreeUnicodeString(&UnicodeString);
        return v4;
      }
      RtlFreeUnicodeString(&UnicodeString);
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6C296) --------------------------------------------------------
BOOL __stdcall MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
{
  int v7; // [sp+10h] [bp-1Ch]@5

  if ( hTransaction == (HANDLE)-1 || !hTransaction )
  {
    RtlSetLastWin32Error(6700);
    return 0;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return 0;
  }
  RtlSetCurrentTransaction(hTransaction);
  v7 = MoveFileWithProgressTransactedA(
         lpExistingFileName,
         lpNewFileName,
         (int)lpProgressRoutine,
         (int)lpData,
         dwFlags,
         (int)hTransaction);
  RtlSetCurrentTransaction(0);
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6C339) --------------------------------------------------------
int __stdcall MoveFileTransactedW(PWSTR dosname, PWSTR DeviceName, int a3, int a4, int a5, int a6)
{
  int v7; // [sp+10h] [bp-1Ch]@5

  if ( a6 == -1 || !a6 )
  {
    RtlSetLastWin32Error(6700);
    return 0;
  }
  if ( RtlGetCurrentTransaction() )
  {
    RtlSetLastWin32Error(6725);
    return 0;
  }
  RtlSetCurrentTransaction(a6);
  v7 = MoveFileWithProgressTransactedW(dosname, DeviceName, a3, a4, a5, a6);
  RtlSetCurrentTransaction(0);
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6C3D9) --------------------------------------------------------
BOOL __stdcall MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
{
  return MoveFileWithProgressA(lpExistingFileName, lpNewFileName, 0, 0, 2u);
}

//----- (77E6C3F8) --------------------------------------------------------
DWORD __stdcall LoadDuplicateEncryptionInfoFile(int a1, int a2, int a3, int a4, int a5)
{
  HMODULE v5; // eax@1
  HMODULE v6; // edi@1
  DWORD result; // eax@2
  int (__stdcall *v8)(int, int, int, int, int); // esi@3

  v5 = LoadLibraryW(L"advapi32.dll");
  v6 = v5;
  if ( v5 )
  {
    v8 = (int (__stdcall *)(int, int, int, int, int))GetProcAddress(v5, "DuplicateEncryptionInfoFile");
    if ( v8 )
    {
      LdrAddRefDll(1, v6);
      pfnDuplicateEncryptionInfoFile = v8;
      result = v8(a1, a2, a3, a4, a5);
    }
    else
    {
      result = GetLastError();
    }
  }
  else
  {
    result = GetLastError();
  }
  return result;
}
// 77DE13E8: using guessed type int __stdcall LdrAddRefDll(_DWORD, _DWORD);
// 77EA6020: using guessed type int (__stdcall *pfnDuplicateEncryptionInfoFile)(int, int, int, int, int);

//----- (77E6C459) --------------------------------------------------------
int __stdcall BasepChecksum(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@2
  unsigned int v4; // ecx@3

  v2 = 0;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      --a2;
      v4 = *(_WORD *)v3 + v2;
      v3 += 2;
      v2 = (v4 >> 16) + (unsigned __int16)v4;
    }
    while ( a2 );
  }
  return (unsigned __int16)(v2 + HIWORD(v2));
}

//----- (77E6C497) --------------------------------------------------------
signed int __stdcall BasepCreateDispositionToWin32(int a1, int a2)
{
  switch ( a1 )
  {
    case 1:
      *(_DWORD *)a2 = 3;
      break;
    case 2:
      *(_DWORD *)a2 = 1;
      break;
    case 3:
      *(_DWORD *)a2 = 4;
      break;
    default:
      if ( a1 != 5 )
        return -1073741811;
      *(_DWORD *)a2 = 2;
      break;
  }
  return 0;
}

//----- (77E6C4E7) --------------------------------------------------------
int __stdcall CheckAllowDecryptedRemoteDestinationPolicy()
{
  ULONG ResultLength; // [sp+0h] [bp-20h]@3
  HANDLE KeyHandle; // [sp+4h] [bp-1Ch]@2
  char KeyValueInformation; // [sp+8h] [bp-18h]@3
  int v4; // [sp+Ch] [bp-14h]@4
  int v5; // [sp+10h] [bp-10h]@5
  int v6; // [sp+14h] [bp-Ch]@6

  if ( !dword_77EA6D04 )
  {
    if ( NtOpenKey(&KeyHandle, 1u, &stru_77E6C570) >= 0 )
    {
      if ( NtQueryValueKey(
             KeyHandle,
             &stru_77E6C588,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0x14u,
             &ResultLength) >= 0
        && v4 == 4
        && v5 == 4
        && v6 == 1 )
        dword_77EA6D00 = 1;
      NtClose(KeyHandle);
    }
    dword_77EA6D04 = 1;
  }
  return dword_77EA6D00;
}
// 77EA6D00: using guessed type int dword_77EA6D00;
// 77EA6D04: using guessed type int dword_77EA6D04;

//----- (77E6C595) --------------------------------------------------------
NTSTATUS __stdcall BaseMarkFileForDelete(HANDLE FileHandle, int a2)
{
  char v2; // al@1
  char FileInformation; // [sp+0h] [bp-30h]@2
  int v5; // [sp+20h] [bp-10h]@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-8h]@2

  v2 = a2;
  if ( !a2 )
  {
    v5 &= a2;
    NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    v2 = v5;
  }
  if ( v2 & 1 )
  {
    memset(&FileInformation, 0, 0x28u);
    v5 = 128;
    NtSetInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
  }
  BYTE3(a2) = 1;
  return NtSetInformationFile(FileHandle, &IoStatusBlock, (char *)&a2 + 3, 1u, FileDispositionInformation);
}

//----- (77E6C60D) --------------------------------------------------------
int __stdcall CopyReparsePoint(HANDLE FileHandle, HANDLE a2, HANDLE Event)
{
  int v3; // eax@1
  PVOID v4; // eax@1
  NTSTATUS v6; // eax@4
  NTSTATUS v7; // edi@10
  NTSTATUS v8; // eax@11
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-Ch]@3
  PVOID Address; // [sp+10h] [bp-4h]@1
  NTSTATUS FileHandlea; // [sp+1Ch] [bp+8h]@3

  v3 = KernelBaseGetGlobalData();
  v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), 0x4000u);
  Address = v4;
  if ( !v4 )
  {
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  FileHandlea = NtFsControlFile(FileHandle, Event, 0, 0, &IoStatusBlock, 0x900A8u, 0, 0, v4, 0x4000u);
  if ( FileHandlea == 259 )
  {
    do
    {
      do
      {
        v6 = NtWaitForSingleObject(Event, 1u, 0);
        FileHandlea = v6;
      }
      while ( v6 == 257 );
      if ( v6 >= 0 )
        FileHandlea = IoStatusBlock.u.Status;
    }
    while ( FileHandlea == 257 );
  }
  if ( FileHandlea < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    BaseSetLastNTError(FileHandlea);
    return 0;
  }
  v7 = NtFsControlFile(a2, Event, 0, 0, &IoStatusBlock, 0x900A4u, Address, *((_WORD *)Address + 2) + 8, 0, 0);
  if ( v7 == 259 )
  {
    do
    {
      do
      {
        v8 = NtWaitForSingleObject(Event, 1u, 0);
        v7 = v8;
      }
      while ( v8 == 257 );
      if ( v8 >= 0 )
        v7 = IoStatusBlock.u.Status;
    }
    while ( v7 == 257 );
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v7 < 0 )
  {
    BaseSetLastNTError(v7);
    return 0;
  }
  return 1;
}

//----- (77E6C745) --------------------------------------------------------
int __stdcall CopyNameGraftNow(HANDLE FileHandle, int a2, LPCWSTR lpszVolumeMountPoint, int a4, int a5, int a6, int a7, int a8, HANDLE Event)
{
  int v9; // eax@1
  NTSTATUS v11; // eax@3
  PVOID v12; // ebx@11
  NTSTATUS v13; // eax@12
  int v14; // eax@23
  int v15; // eax@25
  int v16; // eax@26
  PWCH v17; // eax@32
  WCHAR v18; // cx@43
  int FileInformation; // [sp+10h] [bp-9Ch]@34
  int v20; // [sp+14h] [bp-98h]@35
  int v21; // [sp+18h] [bp-94h]@35
  int v22; // [sp+1Ch] [bp-90h]@35
  int v23; // [sp+30h] [bp-7Ch]@35
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+38h] [bp-74h]@25
  int v25; // [sp+50h] [bp-5Ch]@23
  struct _IO_STATUS_BLOCK v26; // [sp+54h] [bp-58h]@28
  UNICODE_STRING String2; // [sp+5Ch] [bp-50h]@9
  PVOID Address; // [sp+64h] [bp-48h]@1
  ULONG_PTR v29; // [sp+68h] [bp-44h]@1
  PVOID v30; // [sp+6Ch] [bp-40h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+70h] [bp-3Ch]@11
  int v32; // [sp+78h] [bp-34h]@1
  UNICODE_STRING String1; // [sp+7Ch] [bp-30h]@3
  int v34; // [sp+84h] [bp-28h]@1
  PVOID OutputBuffer; // [sp+88h] [bp-24h]@1
  HANDLE hObject; // [sp+8Ch] [bp-20h]@1
  NTSTATUS NtStatus; // [sp+90h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+94h] [bp-18h]@3

  NtStatus = 0;
  v32 = 0;
  hObject = (HANDLE)-1;
  Address = 0;
  v30 = 0;
  v29 = 0;
  v34 = 0;
  v9 = KernelBaseGetGlobalData();
  OutputBuffer = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v9 + 44), 0x4000u);
  if ( !OutputBuffer )
  {
    BaseSetLastNTError(-1073741801);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  v11 = RtlDosPathNameToNtPathName_U_WithStatus(a2, &String1, 0, 0);
  if ( v11 < 0
    || (Address = String1.Buffer,
        v11 = RtlDosPathNameToNtPathName_U_WithStatus(lpszVolumeMountPoint, &String2, 0, 0),
        v11 < 0) )
  {
    if ( v11 == -1073741801 || v11 == -1073741670 )
      BaseSetLastNTError(v11);
    else
      RtlSetLastWin32Error(3);
    goto LABEL_8;
  }
  v30 = String2.Buffer;
  if ( RtlEqualUnicodeString(&String1, &String2, 1u) )
  {
LABEL_8:
    hObject = (HANDLE)-1;
    goto LABEL_39;
  }
  v12 = OutputBuffer;
  NtStatus = NtFsControlFile(FileHandle, Event, 0, 0, &IoStatusBlock, 0x900A8u, 0, 0, OutputBuffer, 0x4000u);
  if ( NtStatus == 259 )
  {
    do
    {
      v13 = NtWaitForSingleObject(Event, 1u, 0);
      NtStatus = v13;
      if ( v13 != 257 && v13 >= 0 )
        NtStatus = IoStatusBlock.u.Status;
    }
    while ( NtStatus == 257 );
  }
  if ( NtStatus < 0 )
    goto LABEL_17;
  if ( *(_DWORD *)v12 != -1610612733 )
  {
    if ( *(_DWORD *)v12 != -1610612724 )
    {
      BaseSetLastNTError(-1073741773);
      goto LABEL_39;
    }
    v25 = 35;
    v14 = RtlAcquirePrivilege(&v25, 1, 0, &v34);
    NtStatus = v14;
    if ( v14 < 0 )
      goto LABEL_24;
  }
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &String2;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v15 = *(_DWORD *)a8;
  if ( a4 & 1 )
    v16 = ~(_BYTE)v15 & 1 | 2;
  else
    v16 = 2 * (v15 & 1);
  NtStatus = NtCreateFile(&hObject, 0xC0000000, &ObjectAttributes, &v26, 0, 0, 3u, v16, a4 | 0x200000, 0, 0);
  if ( NtStatus < 0 )
  {
    hObject = (HANDLE)-1;
LABEL_17:
    BaseSetLastNTError(NtStatus);
    goto LABEL_39;
  }
  v29 = v26.Information;
  if ( String1.Length == 96 )
  {
    v17 = String1.Buffer;
  }
  else
  {
    if ( String1.Length != 98 )
      goto LABEL_33;
    v17 = String1.Buffer;
    if ( String1.Buffer[48] != 92 )
      goto LABEL_33;
  }
  if ( *v17 != 92
    || (v18 = v17[1], v18 != 63) && v18 != 92
    || v17[2] != 63
    || v17[3] != 92
    || v17[4] != 86
    || v17[5] != 111
    || v17[6] != 108
    || v17[7] != 117
    || v17[8] != 109
    || v17[9] != 101
    || v17[10] != 123
    || v17[19] != 45
    || v17[24] != 45
    || v17[29] != 45
    || v17[34] != 45
    || v17[47] != 125 )
  {
LABEL_33:
    v14 = NtFsControlFile(
            hObject,
            0,
            0,
            0,
            &IoStatusBlock,
            0x900A4u,
            OutputBuffer,
            *((_WORD *)OutputBuffer + 2) + 8,
            0,
            0);
    NtStatus = v14;
    if ( v14 < 0 )
    {
LABEL_24:
      BaseSetLastNTError(v14);
      goto LABEL_39;
    }
LABEL_34:
    v14 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
    NtStatus = v14;
    if ( v14 >= 0 )
    {
      FileInformation = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      NtStatus = NtSetInformationFile(hObject, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
      if ( NtStatus == -1073741757 )
      {
        CloseHandle(hObject);
        NtStatus = NtCreateFile(&hObject, 0x100u, &ObjectAttributes, &v26, 0, 0, 0, 1u, a4 | 0x200000, 0, 0);
        if ( NtStatus >= 0 )
          NtStatus = NtSetInformationFile(hObject, &IoStatusBlock, &FileInformation, 0x28u, FileBasicInformation);
      }
      v32 = 1;
      goto LABEL_39;
    }
    goto LABEL_24;
  }
  if ( RtlGetCurrentTransaction() )
  {
    BaseSetLastNTError(-1073741637);
  }
  else if ( SetVolumeMountPointW(lpszVolumeMountPoint, (LPCWSTR)OutputBuffer + 8) )
  {
    goto LABEL_34;
  }
LABEL_39:
  ms_exc.registration.TryLevel = -2;
  if ( hObject != (HANDLE)-1 )
    CloseHandle(hObject);
  if ( v34 )
    RtlReleasePrivilege(v34);
  if ( NtStatus < 0 && v29 == 2 )
    DeleteFileW(lpszVolumeMountPoint);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v30);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, OutputBuffer);
  return v32;
}
// 77DE13D0: using guessed type int __stdcall RtlDosPathNameToNtPathName_U_WithStatus(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6CBB9) --------------------------------------------------------
int __stdcall BasepOpenRestartableFile(HANDLE hTemplateFile, LPCWSTR lpFileName, int a3, char a4, int a5, int a6, int a7, DWORD dwFlagsAndAttributes, int a9)
{
  int v9; // esi@1
  HANDLE v10; // eax@3
  int v11; // eax@17
  int v12; // eax@18
  int v13; // ecx@18
  int v15; // [sp+0h] [bp-74h]@0
  __int16 Buffer; // [sp+10h] [bp-64h]@4
  __int16 v17; // [sp+12h] [bp-62h]@7
  int v18; // [sp+14h] [bp-60h]@12
  int v19; // [sp+18h] [bp-5Ch]@13
  int v20; // [sp+1Ch] [bp-58h]@14
  int v21; // [sp+20h] [bp-54h]@15
  int v22; // [sp+24h] [bp-50h]@16
  int v23; // [sp+28h] [bp-4Ch]@10
  int v24; // [sp+2Ch] [bp-48h]@11
  int v25; // [sp+30h] [bp-44h]@8
  int v26; // [sp+34h] [bp-40h]@9
  int v27; // [sp+38h] [bp-3Ch]@18
  int v28; // [sp+3Ch] [bp-38h]@18
  int v29; // [sp+40h] [bp-34h]@18
  int v30; // [sp+44h] [bp-30h]@17
  int v31; // [sp+48h] [bp-2Ch]@24
  int v32; // [sp+4Ch] [bp-28h]@1
  DWORD NumberOfBytesRead; // [sp+50h] [bp-24h]@1
  int v34; // [sp+54h] [bp-20h]@24
  int v35; // [sp+58h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+5Ch] [bp-18h]@1
  DWORD dwFlagsAndAttributesa; // [sp+98h] [bp+24h]@1

  v9 = *(_DWORD *)a7;
  v32 = *(_DWORD *)a7;
  v35 = 1;
  NumberOfBytesRead = 0;
  ms_exc.registration.TryLevel = 0;
  dwFlagsAndAttributesa = dwFlagsAndAttributes | 0x8000000;
  if ( a9 )
    dwFlagsAndAttributesa |= 0x200000u;
  v10 = CreateFileW(lpFileName, 0xC0010000, 3u, 0, 3u, dwFlagsAndAttributesa, hTemplateFile);
  *(_DWORD *)a3 = v10;
  if ( v10 == (HANDLE)-1 )
    goto LABEL_21;
  v35 = ReadFile(v10, &Buffer, 0x38u, &NumberOfBytesRead, 0);
  if ( !v35 || NumberOfBytesRead != 56 )
  {
    if ( a4 & 1 )
    {
      RtlSetLastWin32Error(183);
      v35 = 0;
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if ( Buffer != 31387
    || v17 != 56
    || v25 != *(_DWORD *)(a5 + 32)
    || v26 != *(_DWORD *)(a5 + 36)
    || v23 != *(_DWORD *)(a5 + 24)
    || v24 != *(_DWORD *)(a5 + 28)
    || v18 != *(_DWORD *)(a5 + 4)
    || v19 != *(_DWORD *)(a5 + 8)
    || v20 != *(_DWORD *)(a5 + 12)
    || v21 != *(_DWORD *)(a5 + 16)
    || v22 != *(_DWORD *)(a5 + 20)
    || (v11 = BasepChecksum((int)&Buffer, 26), v30 != v11) )
  {
    if ( a4 & 1 )
    {
      v35 = 0;
      RtlSetLastWin32Error(183);
      goto LABEL_40;
    }
LABEL_39:
    v35 = 1;
    CloseHandle(*(HANDLE *)a3);
    *(_DWORD *)a3 = -1;
    goto LABEL_40;
  }
  v12 = v29;
  *(_DWORD *)(a5 + 48) = v29;
  v13 = v27;
  *(_DWORD *)(a5 + 40) = v27;
  *(_DWORD *)(a5 + 44) = v28;
  if ( v12 )
  {
    if ( v9 )
    {
      *(_DWORD *)(v9 + 8) = *(_DWORD *)a6;
      *(_DWORD *)(v9 + 12) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(v9 + 16) = v29;
      if ( *(_DWORD *)(v9 + 28) )
      {
        v31 = RtlGetCurrentTransaction();
        RtlSetCurrentTransaction(0);
        ms_exc.registration.TryLevel = 1;
        v34 = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, signed int, signed int, HANDLE, _DWORD, _DWORD, int))(v9 + 28))(
                *(_DWORD *)v9,
                *(_DWORD *)(v9 + 4),
                *(_DWORD *)(v9 + 8),
                *(_DWORD *)(v9 + 12),
                *(_DWORD *)a6,
                *(_DWORD *)(a6 + 4),
                *(_DWORD *)(v9 + 8),
                *(_DWORD *)(v9 + 12),
                1,
                1,
                hTemplateFile,
                *(_DWORD *)a3,
                *(_DWORD *)(v9 + 24),
                v15);
        ms_exc.registration.TryLevel = 0;
        RtlSetCurrentTransaction(v31);
      }
      else
      {
        v34 = 0;
      }
      if ( v34 == 1 || *(_DWORD *)(v9 + 20) && **(_DWORD **)(v9 + 20) )
      {
        BaseMarkFileForDelete(*(HANDLE *)a3, 0);
      }
      else if ( v34 != 2 )
      {
        if ( v34 == 3 )
          *(_DWORD *)a7 = 0;
        goto LABEL_32;
      }
      BaseSetLastNTError(-1073741248);
      v35 = 0;
      goto LABEL_40;
    }
LABEL_32:
    v35 = 2;
    goto LABEL_40;
  }
  if ( v9 )
  {
    *(_DWORD *)(v9 + 8) = v13;
    *(_DWORD *)(v9 + 12) = v28;
  }
LABEL_21:
  v35 = 1;
LABEL_40:
  ms_exc.registration.TryLevel = -2;
  if ( !v35 && *(_DWORD *)a3 != -1 )
  {
    CloseHandle(*(HANDLE *)a3);
    *(_DWORD *)a3 = -1;
  }
  return v35;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6CE75) --------------------------------------------------------
int __stdcall BasepCopyCompression(HANDLE a1, HANDLE FileHandle, int InputBuffer, int OutputBuffer, char a5, int a6, HANDLE Event, int a8)
{
  int v8; // edi@1
  int v9; // eax@5
  NTSTATUS v11; // eax@18
  int v12; // [sp-1Ch] [bp-58h]@13
  int v13; // [sp-18h] [bp-54h]@13
  int v14; // [sp-10h] [bp-4Ch]@13
  int v15; // [sp-Ch] [bp-48h]@13
  int v16; // [sp-8h] [bp-44h]@13
  int v17; // [sp-4h] [bp-40h]@13
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+10h] [bp-2Ch]@4
  int v19; // [sp+18h] [bp-24h]@1
  int v20; // [sp+1Ch] [bp-20h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  v8 = *(_DWORD *)a8;
  v19 = *(_DWORD *)a8;
  v20 = 0;
  a8 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( !(InputBuffer & 0x800) )
  {
    if ( OutputBuffer & 0x800 && a6 & 0x200 )
    {
      InputBuffer = 0;
      NtStatus = NtFsControlFile(FileHandle, Event, 0, 0, &IoStatusBlock, 0x9C040u, &InputBuffer, 4u, 0, 0);
      if ( NtStatus < 0 )
      {
        v9 = RtlNtStatusToDosError(NtStatus);
        if ( !BasepCopyFileCallback(1, v9, v8, 0, 5, (int)a1, (int)FileHandle, (int)&a8) )
        {
          BaseMarkFileForDelete(FileHandle, 0);
          BaseSetLastNTError(NtStatus);
          goto LABEL_11;
        }
        NtStatus = 0;
      }
      if ( NtStatus == 259 )
        WaitForSingleObject(Event, 0xFFFFFFFF);
    }
    goto LABEL_10;
  }
  if ( a5 & 0x10 )
  {
    if ( OutputBuffer & 0x800 )
      goto LABEL_10;
    v11 = NtFsControlFile(a1, Event, 0, 0, &IoStatusBlock, 0x9003Cu, 0, 0, &OutputBuffer, 2u);
    NtStatus = v11;
    if ( v11 >= 0 )
    {
      if ( v11 == 259 )
        WaitForSingleObject(Event, 0xFFFFFFFF);
      NtStatus = NtFsControlFile(FileHandle, Event, 0, 0, &IoStatusBlock, 0x9C040u, &OutputBuffer, 2u, 0, 0);
      if ( NtStatus < 0 && 1 != (_WORD)OutputBuffer )
      {
        OutputBuffer = 1;
        NtStatus = NtFsControlFile(FileHandle, Event, 0, 0, &IoStatusBlock, 0x9C040u, &OutputBuffer, 2u, 0, 0);
      }
      if ( NtStatus == 259 )
        WaitForSingleObject(Event, 0xFFFFFFFF);
    }
    if ( NtStatus >= 0 )
      goto LABEL_10;
    a8 = 0;
    v17 = (int)&a8;
    v16 = (int)FileHandle;
    v15 = (int)a1;
    v14 = 6;
    v13 = v19;
    v12 = RtlNtStatusToDosError(NtStatus);
  }
  else
  {
    v17 = (int)&a8;
    v16 = (int)FileHandle;
    v15 = (int)a1;
    v14 = 5;
    v13 = v8;
    v12 = 50;
  }
  if ( BasepCopyFileCallback(1, v12, v13, 0, v14, v15, v16, v17) )
  {
LABEL_10:
    v20 = 1;
    goto LABEL_11;
  }
  if ( a8 )
    BaseMarkFileForDelete(FileHandle, 0);
LABEL_11:
  ms_exc.registration.TryLevel = -2;
  return v20;
}

//----- (77E6D069) --------------------------------------------------------
int __stdcall CreateFileTransactedA(int a1, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, int a8, int a9, int a10)
{
  int result; // eax@2
  int v11; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1) )
  {
    v11 = CreateFileTransactedW(
            UnicodeString.Buffer,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile,
            a8,
            a9,
            a10);
    RtlFreeUnicodeString(&UnicodeString);
    result = v11;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (77E6D0C1) --------------------------------------------------------
BOOL __stdcall ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
{
  BOOL v6; // ebx@1
  LSA_UNICODE_STRING v8; // [sp+8h] [bp-18h]@6
  LSA_UNICODE_STRING v9; // [sp+10h] [bp-10h]@7
  LSA_UNICODE_STRING UnicodeString; // [sp+18h] [bp-8h]@9

  v6 = 0;
  if ( !lpReplacedFileName || !lpReplacementFileName || lpExclude || lpReserved || dwReplaceFlags & 0xFFFFFFF8 )
  {
    RtlSetLastWin32Error(87);
  }
  else if ( Basep8BitStringToDynamicUnicodeString((int)&v8, lpReplacedFileName) )
  {
    if ( !Basep8BitStringToDynamicUnicodeString((int)&v9, lpReplacementFileName) )
    {
LABEL_15:
      RtlFreeUnicodeString(&v8);
      return v6;
    }
    if ( lpBackupFileName )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpBackupFileName) )
      {
LABEL_14:
        RtlFreeUnicodeString(&v9);
        goto LABEL_15;
      }
    }
    else
    {
      UnicodeString.Buffer = 0;
    }
    v6 = ReplaceFileW(v8.Buffer, v9.Buffer, UnicodeString.Buffer, dwReplaceFlags, 0, 0);
    if ( lpBackupFileName )
      RtlFreeUnicodeString(&UnicodeString);
    goto LABEL_14;
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6D17F) --------------------------------------------------------
BOOL __stdcall CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, int a7)
{
  BOOL v8; // [sp+10h] [bp-1Ch]@4

  if ( a7 != -1 && a7 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v8 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a7);
      v8 = CopyFileExW(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v8 = 0;
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6D231) --------------------------------------------------------
BOOL __stdcall CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
{
  BOOL result; // eax@1
  BOOL v7; // edi@4
  LSA_UNICODE_STRING v8; // [sp+0h] [bp-10h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpExistingFileName);
  if ( result )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&v8, lpNewFileName) )
    {
      v7 = CopyFileExW(UnicodeString.Buffer, v8.Buffer, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
      RtlFreeUnicodeString(&v8);
    }
    else
    {
      v7 = 0;
    }
    RtlFreeUnicodeString(&UnicodeString);
    result = v7;
  }
  return result;
}

//----- (77E6D299) --------------------------------------------------------
BOOL __stdcall CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, int a7)
{
  BOOL v8; // [sp+10h] [bp-1Ch]@4

  if ( a7 != -1 && a7 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v8 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a7);
      v8 = CopyFileExA(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v8 = 0;
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E6D349) --------------------------------------------------------
DWORD __stdcall GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
{
  int v5; // eax@4
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-28h]@4
  LSA_UNICODE_STRING GuidString; // [sp+10h] [bp-20h]@4
  DWORD v8; // [sp+18h] [bp-18h]@6
  GUID Guid; // [sp+1Ch] [bp-14h]@4

  if ( !lpName )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  RtlInitUnicodeString(&DestinationString, lpName);
  RtlInitUnicodeString(&GuidString, lpGuid);
  v5 = RtlGUIDFromString(&GuidString, &Guid);
  if ( v5 < 0 || (v8 = nSize, v5 = NtQuerySystemEnvironmentValueEx(&DestinationString, &Guid, pBuffer, &v8, 0), v5 < 0) )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  return v8;
}
// 77DE13BC: using guessed type int __stdcall NtQuerySystemEnvironmentValueEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6D3DD) --------------------------------------------------------
BOOL __stdcall SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
{
  int v5; // eax@4
  LSA_UNICODE_STRING GuidString; // [sp+8h] [bp-24h]@4
  LSA_UNICODE_STRING DestinationString; // [sp+10h] [bp-1Ch]@4
  GUID Guid; // [sp+18h] [bp-14h]@4

  if ( !lpName )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  RtlInitUnicodeString(&DestinationString, lpName);
  RtlInitUnicodeString(&GuidString, lpGuid);
  v5 = RtlGUIDFromString(&GuidString, &Guid);
  if ( v5 < 0 || (v5 = NtSetSystemEnvironmentValueEx(&DestinationString, &Guid, pValue, nSize, 1), v5 < 0) )
  {
    BaseSetLastNTError(v5);
    return 0;
  }
  return 1;
}
// 77DE13B4: using guessed type int __stdcall NtSetSystemEnvironmentValueEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6D46A) --------------------------------------------------------
DWORD __stdcall GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
{
  NTSTATUS v4; // eax@1
  NTSTATUS v6; // esi@4
  DWORD v7; // edi@6
  STRING SourceString; // [sp+8h] [bp-20h]@4
  struct _STRING DestinationString; // [sp+10h] [bp-18h]@1
  LSA_UNICODE_STRING v10; // [sp+18h] [bp-10h]@4
  LSA_UNICODE_STRING UnicodeString; // [sp+20h] [bp-8h]@1

  RtlInitString(&DestinationString, lpName);
  v4 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  RtlInitString(&SourceString, lpGuid);
  v6 = RtlAnsiStringToUnicodeString(&v10, &SourceString, 1u);
  if ( v6 < 0 )
  {
    RtlFreeUnicodeString(&UnicodeString);
    BaseSetLastNTError(v6);
    return 0;
  }
  v7 = GetFirmwareEnvironmentVariableW(UnicodeString.Buffer, v10.Buffer, pBuffer, nSize);
  RtlFreeUnicodeString(&UnicodeString);
  RtlFreeUnicodeString(&v10);
  return v7;
}

//----- (77E6D4FD) --------------------------------------------------------
BOOL __stdcall SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
{
  NTSTATUS v4; // eax@1
  NTSTATUS v6; // esi@4
  BOOL v7; // edi@6
  STRING SourceString; // [sp+8h] [bp-20h]@4
  struct _STRING DestinationString; // [sp+10h] [bp-18h]@1
  LSA_UNICODE_STRING v10; // [sp+18h] [bp-10h]@4
  LSA_UNICODE_STRING UnicodeString; // [sp+20h] [bp-8h]@1

  RtlInitString(&DestinationString, lpName);
  v4 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  RtlInitString(&SourceString, lpGuid);
  v6 = RtlAnsiStringToUnicodeString(&v10, &SourceString, 1u);
  if ( v6 < 0 )
  {
    RtlFreeUnicodeString(&UnicodeString);
    BaseSetLastNTError(v6);
    return 0;
  }
  v7 = SetFirmwareEnvironmentVariableW(UnicodeString.Buffer, v10.Buffer, pValue, nSize);
  RtlFreeUnicodeString(&UnicodeString);
  RtlFreeUnicodeString(&v10);
  return v7;
}

//----- (77E6D5A6) --------------------------------------------------------
SIZE_T __stdcall LocalCompact(UINT uMinFree)
{
  return RtlCompactHeap(BaseHeap, 0);
}

//----- (77E6D5BC) --------------------------------------------------------
void __stdcall GlobalFix(HGLOBAL hMem)
{
  if ( hMem != (HGLOBAL)-1 )
    GlobalLock(hMem);
}

//----- (77E6D5D6) --------------------------------------------------------
void __stdcall GlobalUnfix(HGLOBAL hMem)
{
  if ( hMem != (HGLOBAL)-1 )
    GlobalUnlock(hMem);
}

//----- (77E6D5F0) --------------------------------------------------------
LPVOID __stdcall GlobalWire(HGLOBAL hMem)
{
  return GlobalLock(hMem);
}

//----- (77E6D600) --------------------------------------------------------
BOOL __stdcall GlobalUnWire(HGLOBAL hMem)
{
  return GlobalUnlock(hMem);
}

//----- (77E6D610) --------------------------------------------------------
BOOL __stdcall AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2

  v1 = RtlRegisterSecureMemoryCacheCallback(pfnCallBack);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1390: using guessed type int __stdcall RtlRegisterSecureMemoryCacheCallback(_DWORD);

//----- (77E6D638) --------------------------------------------------------
BOOL __stdcall RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
{
  return (unsigned __int8)RtlDeregisterSecureMemoryCacheCallback(pfnCallBack);
}
// 77DE138C: using guessed type int __stdcall RtlDeregisterSecureMemoryCacheCallback(_DWORD);

//----- (77E6D652) --------------------------------------------------------
UINT __stdcall EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
{
  int v3; // eax@1
  PVOID v4; // eax@1
  PVOID v5; // esi@1
  NTSTATUS v6; // eax@2
  ULONG ReturnLength; // [sp+18h] [bp-24h]@1
  UINT v9; // [sp+1Ch] [bp-20h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  NtStatus = 0;
  ReturnLength = 0;
  v9 = 0;
  v3 = KernelBaseGetGlobalData();
  v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), BufferSize + 16);
  v5 = v4;
  ms_exc.registration.TryLevel = 0;
  if ( v4 )
  {
    *(_DWORD *)v4 = FirmwareTableProviderSignature;
    *((_DWORD *)v4 + 2) = 0;
    *((_DWORD *)v4 + 3) = BufferSize;
    *((_DWORD *)v4 + 1) = 0;
    v6 = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)76, v4, BufferSize + 16, &ReturnLength);
    NtStatus = v6;
    if ( v6 >= 0 || v6 == -1073741789 )
      v9 = *((_DWORD *)v5 + 3);
    if ( v6 >= 0 && pFirmwareTableEnumBuffer )
    {
      ms_exc.registration.TryLevel = 1;
      memcpy(pFirmwareTableEnumBuffer, (char *)v5 + 16, *((_DWORD *)v5 + 3));
      ms_exc.registration.TryLevel = 0;
      NtStatus = 0;
    }
  }
  else
  {
    NtStatus = -1073741670;
  }
  ms_exc.registration.TryLevel = -2;
  if ( v5 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  BaseSetLastNTError(NtStatus);
  return v9;
}

//----- (77E6D795) --------------------------------------------------------
HRESULT __stdcall StringCbCopyNExW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_PCNZWCH pszSrc, size_t cbToCopy, STRSAFE_LPWSTR *ppszDestEnd, size_t *pcbRemaining, DWORD dwFlags)
{
  size_t v7; // ebx@1
  signed int v8; // edx@1
  signed int v9; // eax@1
  signed int v10; // esi@8
  STRSAFE_LPWSTR v11; // edi@9
  int v12; // eax@9
  size_t v13; // ebx@24
  size_t v14; // eax@26
  size_t v16; // [sp+Ch] [bp-8h]@9
  STRSAFE_LPWSTR v17; // [sp+10h] [bp-4h]@9

  v7 = cbDest >> 1;
  v8 = 0;
  v9 = 0;
  if ( dwFlags & 0x100 )
  {
    if ( !pszDest && v7 )
      goto LABEL_7;
LABEL_6:
    if ( v7 <= 0x7FFFFFFF )
      goto LABEL_8;
    goto LABEL_7;
  }
  v9 = 0;
  if ( v7 )
    goto LABEL_6;
LABEL_7:
  v9 = -2147024809;
LABEL_8:
  v10 = v9;
  if ( v9 < 0 )
    return v10;
  v11 = pszDest;
  v12 = cbToCopy >> 1;
  v17 = pszDest;
  v16 = cbDest >> 1;
  if ( cbToCopy >> 1 < 0x7FFFFFFF )
  {
    if ( dwFlags & 0x100 && !pszSrc )
    {
      pszSrc = &Src;
      v12 = 0;
    }
  }
  else
  {
    v8 = -2147024809;
  }
  v10 = v8;
  if ( v8 < 0 )
  {
    if ( v7 )
      *pszDest = 0;
  }
  else
  {
    if ( dwFlags & 0xFFFFE000 )
    {
      v10 = -2147024809;
      if ( v7 )
        *pszDest = 0;
      goto LABEL_31;
    }
    if ( v7 )
    {
      cbToCopy = 0;
      v10 = sub_77E2DB49((int)pszSrc, cbDest >> 1, (int)pszDest, (int)&cbToCopy, v12);
      v13 = v7 - cbToCopy;
      v11 = &pszDest[cbToCopy];
      v17 = &pszDest[cbToCopy];
      v16 = v13;
      if ( v10 < 0 )
        goto LABEL_31;
      if ( dwFlags & 0x200 )
      {
        v14 = (cbDest & 1) + 2 * v13;
        if ( v14 > 2 )
          memset(v11 + 1, (unsigned __int8)dwFlags, v14 - 2);
      }
    }
    else if ( v12 && *pszSrc )
    {
      if ( !pszDest )
      {
        v10 = -2147024809;
        goto LABEL_31;
      }
      v10 = -2147024774;
    }
  }
  if ( v10 >= 0 )
  {
LABEL_36:
    if ( ppszDestEnd )
      *ppszDestEnd = v11;
    if ( pcbRemaining )
      *pcbRemaining = (cbDest & 1) + 2 * v16;
    return v10;
  }
LABEL_31:
  if ( dwFlags & 0x1C00 && cbDest )
  {
    sub_77E78D02(0, (int)&v16, pszDest, cbDest, (int)&v17, dwFlags);
    v11 = v17;
  }
  if ( v10 >= 0 || v10 == -2147024774 )
    goto LABEL_36;
  return v10;
}

//----- (77E6D926) --------------------------------------------------------
HFILE __stdcall _lopen(LPCSTR lpPathName, int iReadWrite)
{
  DWORD v2; // esi@1
  int v3; // eax@3

  RtlSetLastWin32Error(0);
  v2 = (iReadWrite & 1) != 0 ? 0x40000000 : 2147483648;
  if ( iReadWrite & 2 )
    v2 |= 0xC0000000;
  v3 = BasepOfShareToWin32Share(iReadWrite);
  return (HFILE)CreateFileA(lpPathName, v2, v3, 0, 3u, 0, 0);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6D979) --------------------------------------------------------
HFILE __stdcall _lcreat(LPCSTR lpPathName, int iAttribute)
{
  RtlSetLastWin32Error(0);
  return (HFILE)CreateFileA(lpPathName, 0xC0000000, 3u, 0, 2u, iAttribute & 0x7FB7, 0);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6D9AD) --------------------------------------------------------
UINT __stdcall _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
{
  BOOL v3; // eax@2
  UINT result; // eax@5

  if ( uBytes )
  {
    v3 = WriteFileImplementation((HANDLE)hFile, lpBuffer, uBytes, (LPDWORD)&uBytes, 0);
  }
  else
  {
    uBytes = 0;
    v3 = SetEndOfFile((HANDLE)hFile);
  }
  if ( v3 )
    result = uBytes;
  else
    result = -1;
  return result;
}

//----- (77E6D9EF) --------------------------------------------------------
SIZE_T __stdcall LocalShrink(HLOCAL hMem, UINT cbNewSize)
{
  return RtlCompactHeap(BaseHeap, 0);
}

//----- (77E6DA05) --------------------------------------------------------
BOOL __stdcall GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
{
  NTSTATUS v5; // eax@1
  BOOL result; // eax@2
  LONGLONG v7; // rax@12
  DWORD FileInformation; // [sp+0h] [bp-20h]@1
  DWORD v9; // [sp+8h] [bp-18h]@6
  DWORD v10; // [sp+Ch] [bp-14h]@8
  __int64 v11; // [sp+10h] [bp-10h]@10
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-8h]@1

  v5 = NtQueryInformationFile(hMailslot, &IoStatusBlock, &FileInformation, 0x18u, FileMailslotQueryInformation);
  if ( v5 >= 0 )
  {
    if ( lpMaxMessageSize )
      *lpMaxMessageSize = FileInformation;
    if ( lpNextSize )
      *lpNextSize = v9;
    if ( lpMessageCount )
      *lpMessageCount = v10;
    if ( lpReadTimeout )
    {
      if ( v11 == -1 )
      {
        *lpReadTimeout = -1;
      }
      else
      {
        v7 = RtlExtendedLargeIntegerDivide((LARGE_INTEGER)-v11, 0x2710u, 0).QuadPart;
        if ( HIDWORD(v7) )
          *lpReadTimeout = -2;
        else
          *lpReadTimeout = v7;
      }
    }
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v5);
    result = 0;
  }
  return result;
}

//----- (77E6DAA1) --------------------------------------------------------
int __stdcall LoadStringBaseW(int a1, int a2, int a3, int a4)
{
  return LoadStringBaseExW(a1, a2, a3, a4, 0);
}
// 77E245F0: using guessed type int __stdcall LoadStringBaseExW(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E6DAE0) --------------------------------------------------------
BOOL __stdcall sub_77E6DAE0(unsigned __int16 a1)
{
  char v2; // [sp+4h] [bp-C0h]@1
  __int16 v3; // [sp+6h] [bp-BEh]@1
  __int16 *v4; // [sp+8h] [bp-BCh]@1
  int v5; // [sp+Ch] [bp-B8h]@1
  __int16 v6; // [sp+10h] [bp-B4h]@1
  char Dst; // [sp+12h] [bp-B2h]@1

  v6 = 0;
  v5 = 0;
  memset(&Dst, 0, 0xACu);
  v4 = &v6;
  v3 = 174;
  return RtlLcidToLocaleName(a1, &v2, 2, 0) >= 0 && RtlGetUILanguageInfo(8, &v6, 0, 0, &v5) >= 0 && v5 & 0x20;
}
// 77DE1344: using guessed type int __stdcall RtlLcidToLocaleName(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1348: using guessed type int __stdcall RtlGetUILanguageInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E6DB8D) --------------------------------------------------------
signed int __stdcall ReturnMem16Data(int a1, int a2, int a3)
{
  return 0x2000;
}

//----- (77E6DB9A) --------------------------------------------------------
BOOL __stdcall UTRegister(HANDLE hModule, LPCSTR lpsz16BitDLL, LPCSTR lpszInitName, LPCSTR lpszProcName, UT32PROC *ppfn32Thunk, FARPROC pfnUT32Callback, LPVOID lpBuff)
{
  BOOL result; // eax@3

  if ( CompareStringA(0x7Fu, 1u, lpsz16BitDLL, -1, "mem16.dll", -1) != 2
    || CompareStringA(0x7Fu, 1u, lpszProcName, -1, "GetMemory", -1) != 2 )
  {
    result = 0;
  }
  else
  {
    *ppfn32Thunk = (UT32PROC)ReturnMem16Data;
    result = 1;
  }
  return result;
}

//----- (77E6DC03) --------------------------------------------------------
int __stdcall SetDllDirectoryW(wchar_t *Str)
{
  char v2; // al@5
  int v3; // eax@8
  int v4; // eax@8
  int v5; // eax@8
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@8
  LSA_UNICODE_STRING AllocatedString; // [sp+8h] [bp-8h]@5

  if ( Str )
  {
    if ( _wcschr(Str, 0x3Bu) )
    {
      RtlSetLastWin32Error(87);
      return 0;
    }
    RtlCreateUnicodeString(&AllocatedString, Str);
    if ( !v2 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
  }
  else
  {
    RtlInitUnicodeString(&AllocatedString, 0);
  }
  BaseInvalidateDllSearchPathCache();
  v3 = KernelBaseGetGlobalData();
  RtlAcquireSRWLockExclusive(*(_DWORD *)(v3 + 12));
  v4 = *(_DWORD *)(KernelBaseGetGlobalData() + 8);
  *(_DWORD *)&UnicodeString.Length = *(_DWORD *)v4;
  UnicodeString.Buffer = *(PWCH *)(v4 + 4);
  *(_QWORD *)*(_DWORD *)(KernelBaseGetGlobalData() + 8) = AllocatedString;
  v5 = KernelBaseGetGlobalData();
  RtlReleaseSRWLockExclusive(*(_DWORD *)(v5 + 12));
  RtlFreeUnicodeString(&UnicodeString);
  return 1;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6DCAC) --------------------------------------------------------
int __stdcall SetDllDirectoryA(char *Str)
{
  int v2; // eax@5
  int v3; // eax@7
  int v4; // eax@10
  int v5; // eax@10
  int v6; // eax@10
  STRING v7; // [sp+0h] [bp-18h]@5
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-10h]@10
  LSA_UNICODE_STRING DestinationString; // [sp+10h] [bp-8h]@7

  if ( Str )
  {
    if ( _strchr(Str, 59) )
    {
      RtlSetLastWin32Error(87);
      return 0;
    }
    v2 = RtlInitAnsiStringEx(&v7, Str);
    if ( v2 < 0
      || (v3 = KernelBaseGetGlobalData(),
          v2 = (*(int (__stdcall **)(LSA_UNICODE_STRING *, STRING *, signed int))(v3 + 24))(&DestinationString, &v7, 1),
          v2 < 0) )
    {
      BaseSetLastNTError(v2);
      return 0;
    }
  }
  else
  {
    RtlInitUnicodeString(&DestinationString, 0);
  }
  BaseInvalidateDllSearchPathCache();
  v4 = KernelBaseGetGlobalData();
  RtlAcquireSRWLockExclusive(*(_DWORD *)(v4 + 12));
  v5 = *(_DWORD *)(KernelBaseGetGlobalData() + 8);
  *(_DWORD *)&UnicodeString.Length = *(_DWORD *)v5;
  UnicodeString.Buffer = *(PWCH *)(v5 + 4);
  *(_QWORD *)*(_DWORD *)(KernelBaseGetGlobalData() + 8) = DestinationString;
  v6 = KernelBaseGetGlobalData();
  RtlReleaseSRWLockExclusive(*(_DWORD *)(v6 + 12));
  RtlFreeUnicodeString(&UnicodeString);
  return 1;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6DD76) --------------------------------------------------------
unsigned int __stdcall GetDllDirectoryW(int a1, void *Dst)
{
  int v2; // eax@1
  unsigned int v3; // esi@2
  size_t *v4; // esi@5
  int v5; // eax@5
  int v6; // eax@6

  v2 = KernelBaseGetGlobalData();
  RtlAcquireSRWLockShared(*(_DWORD *)(v2 + 12));
  if ( 2 * a1 >= (unsigned int)**(_WORD **)(KernelBaseGetGlobalData() + 8) + 2 )
  {
    v4 = *(size_t **)(KernelBaseGetGlobalData() + 8);
    v5 = KernelBaseGetGlobalData();
    memcpy(Dst, *(const void **)(*(_DWORD *)(v5 + 8) + 4), *(_WORD *)v4);
    v3 = (unsigned int)**(_WORD **)(KernelBaseGetGlobalData() + 8) >> 1;
    *((_WORD *)Dst + v3) = 0;
  }
  else
  {
    v3 = ((unsigned int)**(_WORD **)(KernelBaseGetGlobalData() + 8) + 2) >> 1;
    if ( (unsigned int)(2 * a1) >= 2 && Dst )
      *(_WORD *)Dst = 0;
  }
  v6 = KernelBaseGetGlobalData();
  RtlReleaseSRWLockShared(*(_DWORD *)(v6 + 12));
  return v3;
}
// 77DE12F8: using guessed type int __stdcall RtlAcquireSRWLockShared(_DWORD);
// 77DE12FC: using guessed type int __stdcall RtlReleaseSRWLockShared(_DWORD);

//----- (77E6DE14) --------------------------------------------------------
DWORD __stdcall GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@2
  int v7; // eax@2
  NTSTATUS v8; // edi@2
  int v9; // eax@5
  __int16 v11; // [sp+Ch] [bp-8h]@1
  __int16 v12; // [sp+Eh] [bp-6h]@1
  LPSTR v13; // [sp+10h] [bp-4h]@1

  v11 = 0;
  v12 = nBufferLength;
  v13 = lpBuffer;
  v2 = KernelBaseGetGlobalData();
  RtlAcquireSRWLockShared(*(_DWORD *)(v2 + 12));
  v3 = *(_DWORD *)(KernelBaseGetGlobalData() + 8);
  v4 = KernelBaseGetGlobalData();
  v5 = (*(int (__stdcall **)(int))(v4 + 36))(v3);
  if ( v5 > nBufferLength )
  {
    v8 = 0;
    if ( lpBuffer )
      *lpBuffer = 0;
  }
  else
  {
    v6 = *(_DWORD *)(KernelBaseGetGlobalData() + 8);
    v7 = KernelBaseGetGlobalData();
    v8 = (*(int (__stdcall **)(__int16 *, int, _DWORD))(v7 + 28))(&v11, v6, 0);
    --v5;
  }
  v9 = KernelBaseGetGlobalData();
  RtlReleaseSRWLockShared(*(_DWORD *)(v9 + 12));
  if ( v8 < 0 )
  {
    BaseSetLastNTError(v8);
    v5 = 0;
    if ( lpBuffer )
      *lpBuffer = 0;
  }
  return v5;
}
// 77DE12F8: using guessed type int __stdcall RtlAcquireSRWLockShared(_DWORD);
// 77DE12FC: using guessed type int __stdcall RtlReleaseSRWLockShared(_DWORD);

//----- (77E6DEAD) --------------------------------------------------------
BOOL __stdcall SetSearchPathMode(DWORD Flags)
{
  DWORD v1; // ebx@1
  int v3; // eax@9
  BOOL v4; // esi@11
  int v5; // eax@13

  v1 = Flags;
  if ( Flags & 0xFFFE7FFE )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  if ( Flags & 1 )
  {
    if ( v1 & 0x10000 )
    {
LABEL_5:
      BaseSetLastNTError(-1073741811);
      return 0;
    }
  }
  else if ( !(v1 & 0x10000) || Flags & 0x8000 )
  {
    goto LABEL_5;
  }
  BaseInvalidateProcessSearchPathCache();
  v3 = KernelBaseGetGlobalData();
  RtlAcquireSRWLockExclusive(*(_DWORD *)(v3 + 20));
  if ( !(**(_DWORD **)(KernelBaseGetGlobalData() + 16) & 0x8000) || Flags & 0x8000 )
  {
    **(_DWORD **)(KernelBaseGetGlobalData() + 16) = Flags;
    v4 = 1;
  }
  else
  {
    BaseSetLastNTError(-1073741790);
    v4 = 0;
  }
  v5 = KernelBaseGetGlobalData();
  RtlReleaseSRWLockExclusive(*(_DWORD *)(v5 + 20));
  return v4;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);

//----- (77E6DF52) --------------------------------------------------------
BOOL __stdcall EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  return EnumResourceTypesInternal(
           (int)hModule,
           (int (__stdcall *)(_DWORD, _DWORD, _DWORD))lpEnumFunc,
           lParam,
           dwFlags,
           LangId,
           1);
}

//----- (77E6DF76) --------------------------------------------------------
BOOL __stdcall EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceTypesExA(hModule, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E6DF96) --------------------------------------------------------
BOOL __stdcall EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
{
  ULONG v7; // edi@1
  BOOL result; // eax@2
  int v9; // eax@3
  int v10; // esi@3
  int v11; // ebx@5

  v7 = BaseDllMapResourceIdA((ULONG)lpType);
  if ( v7 == -1 )
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  else
  {
    v9 = BaseDllMapResourceIdA((ULONG)lpName);
    v10 = v9;
    if ( v9 == -1 )
    {
      BaseDllFreeResourceId(v7);
      BaseSetLastNTError(-1073741811);
      result = 0;
    }
    else
    {
      v11 = EnumResourceLanguagesInternal((int)hModule, (PWCHAR)v7, v9, (int)lpEnumFunc, lParam, dwFlags, LangId, 1);
      BaseDllFreeResourceId(v7);
      BaseDllFreeResourceId(v10);
      result = v11;
    }
  }
  return result;
}
// 77E2A270: using guessed type int __stdcall BaseDllFreeResourceId(_DWORD);

//----- (77E6E012) --------------------------------------------------------
BOOL __stdcall EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
{
  return EnumResourceLanguagesExA(hModule, lpType, lpName, lpEnumFunc, lParam, 3u, 0);
}

//----- (77E6E038) --------------------------------------------------------
HANDLE __stdcall CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  HANDLE result; // eax@2
  HANDLE v9; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName) )
  {
    v9 = CreateNamedPipeW(
           UnicodeString.Buffer,
           dwOpenMode,
           dwPipeMode,
           nMaxInstances,
           nOutBufferSize,
           nInBufferSize,
           nDefaultTimeOut,
           lpSecurityAttributes);
    RtlFreeUnicodeString(&UnicodeString);
    result = v9;
  }
  else
  {
    result = (HANDLE)-1;
  }
  return result;
}

//----- (77E6E08A) --------------------------------------------------------
int __stdcall NpGetUserNamep(int a1, int a2, HANDLE TokenHandle)
{
  HMODULE v3; // eax@1
  HMODULE v4; // esi@1
  FARPROC v6; // ebx@5
  FARPROC v7; // edi@7
  NTSTATUS v8; // eax@9
  NTSTATUS v9; // esi@9
  int v10; // edi@17
  int v11; // esi@19
  NTSTATUS v12; // esi@20
  void (*v13)(void); // [sp+4h] [bp-Ch]@3
  HANDLE v14; // [sp+8h] [bp-8h]@1
  HMODULE hLibModule; // [sp+Ch] [bp-4h]@1

  v14 = TokenHandle;
  v3 = LoadLibraryW(L"advapi32.dll");
  v4 = v3;
  hLibModule = v3;
  if ( !v3 )
    return 0;
  v13 = (void (*)(void))GetProcAddress(v3, "RevertToSelf");
  if ( !v13 )
  {
    FreeLibrary(v4);
    return 0;
  }
  v6 = GetProcAddress(v4, "GetUserNameW");
  if ( !v6 )
  {
    FreeLibrary(v4);
    return 0;
  }
  v7 = GetProcAddress(v4, "ImpersonateNamedPipeClient");
  if ( !v7 )
  {
    FreeLibrary(v4);
    return 0;
  }
  v8 = NtOpenThreadToken((HANDLE)0xFFFFFFFE, 4u, 1u, &TokenHandle);
  v9 = v8;
  if ( v8 < 0 && v8 != -1073741700 )
  {
LABEL_14:
    FreeLibrary(hLibModule);
    return 0;
  }
  if ( !((int (__stdcall *)(int))v7)(a1) )
  {
    if ( v9 >= 0 )
      CloseHandle(TokenHandle);
    goto LABEL_14;
  }
  v10 = ((int (__stdcall *)(int, HANDLE *))v6)(a2, &v14);
  if ( v9 >= 0 )
  {
    v12 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &TokenHandle, 4u);
    CloseHandle(TokenHandle);
    if ( v12 < 0 )
    {
      BaseSetLastNTError(v12);
      v11 = 0;
      goto LABEL_22;
    }
  }
  else
  {
    v13();
  }
  v11 = v10;
LABEL_22:
  FreeLibrary(hLibModule);
  return v11;
}

//----- (77E6E1AC) --------------------------------------------------------
BOOL __stdcall GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
{
  NTSTATUS v7; // eax@2
  BOOL result; // eax@3
  LONGLONG v9; // rax@16
  char v10; // [sp+Ch] [bp-40h]@6
  DWORD v11; // [sp+18h] [bp-34h]@7
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+34h] [bp-18h]@2
  __int64 v13; // [sp+3Ch] [bp-10h]@12
  DWORD FileInformation; // [sp+44h] [bp-8h]@2
  int v15; // [sp+48h] [bp-4h]@4

  if ( lpState )
  {
    v7 = NtQueryInformationFile(hNamedPipe, &IoStatusBlock, &FileInformation, 8u, FilePipeInformation);
    if ( v7 < 0 )
    {
LABEL_3:
      BaseSetLastNTError(v7);
      return 0;
    }
    *lpState = (v15 != 0) | (FileInformation != 0 ? 2 : 0);
  }
  if ( lpCurInstances )
  {
    v7 = NtQueryInformationFile(hNamedPipe, &IoStatusBlock, &v10, 0x28u, FilePipeLocalInformation);
    if ( v7 < 0 )
      goto LABEL_3;
    if ( v11 < 0xFF )
      *lpCurInstances = v11;
    else
      *lpCurInstances = 255;
  }
  if ( lpMaxCollectionCount || lpCollectDataTimeout )
  {
    v7 = NtQueryInformationFile(hNamedPipe, &IoStatusBlock, &v13, 0x10u, FilePipeRemoteInformation);
    if ( v7 < 0 )
      goto LABEL_3;
    if ( lpMaxCollectionCount )
      *lpMaxCollectionCount = FileInformation;
    if ( lpCollectDataTimeout )
    {
      v9 = RtlExtendedLargeIntegerDivide((LARGE_INTEGER)-v13, 0x2710u, 0).QuadPart;
      if ( HIDWORD(v9) )
        *lpCollectDataTimeout = -2;
      else
        *lpCollectDataTimeout = v9;
    }
  }
  if ( lpUserName )
    result = NpGetUserNamep((int)hNamedPipe, (int)lpUserName, (HANDLE)nMaxUserNameSize);
  else
    result = 1;
  return result;
}

//----- (77E6E2A9) --------------------------------------------------------
BOOL __stdcall GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
{
  NTSTATUS v5; // eax@1
  BOOL result; // eax@2
  int FileInformation; // [sp+0h] [bp-30h]@1
  DWORD v8; // [sp+8h] [bp-28h]@10
  DWORD v9; // [sp+10h] [bp-20h]@8
  DWORD v10; // [sp+18h] [bp-18h]@6
  int v11; // [sp+24h] [bp-Ch]@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-8h]@1

  v5 = NtQueryInformationFile(hNamedPipe, &IoStatusBlock, &FileInformation, 0x28u, FilePipeLocalInformation);
  if ( v5 >= 0 )
  {
    if ( lpFlags )
      *lpFlags = v11 & 1 | 4 * (FileInformation & 3);
    if ( lpOutBufferSize )
      *lpOutBufferSize = v10;
    if ( lpInBufferSize )
      *lpInBufferSize = v9;
    if ( lpMaxInstances )
    {
      if ( v8 < 0xFF )
        *lpMaxInstances = v8;
      else
        *lpMaxInstances = 255;
    }
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v5);
    result = 0;
  }
  return result;
}

//----- (77E6E32B) --------------------------------------------------------
int __stdcall GetInterruptTime(int a1)
{
  int result; // eax@1

  result = a1;
  do
  {
    *(_DWORD *)(a1 + 4) = v7FFE000C;
    *(_DWORD *)a1 = v7FFE0008;
  }
  while ( *(_DWORD *)(a1 + 4) != v7FFE0010 );
  return result;
}

//----- (77E6E358) --------------------------------------------------------
BOOL __stdcall CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
{
  void *v7; // edx@1
  HANDLE v8; // esi@14
  BOOL v9; // edi@15
  struct _SECURITY_ATTRIBUTES *i; // [sp-1Ch] [bp-38h]@5
  void *v12; // [sp-10h] [bp-2Ch]@5
  __int64 v13; // [sp+0h] [bp-1Ch]@3
  __int64 v14; // [sp+8h] [bp-14h]@9
  DWORD Mode; // [sp+10h] [bp-Ch]@1
  DWORD v16; // [sp+14h] [bp-8h]@1
  char v17; // [sp+1Ah] [bp-2h]@3
  char v18; // [sp+1Bh] [bp-1h]@1

  v7 = 0;
  v18 = 0;
  Mode = 2;
  v16 = 0;
  if ( nTimeOut && nTimeOut != -1 )
  {
    v17 = 1;
    GetInterruptTime((int)&v13);
  }
  else
  {
    v17 = 0;
  }
  v12 = v7;
  for ( i = (struct _SECURITY_ATTRIBUTES *)v7; ; i = 0 )
  {
    v8 = CreateFileW(lpNamedPipeName, 0xC0000000, 3u, i, 3u, 0x80u, v12);
    if ( v8 != (HANDLE)-1 )
      break;
    if ( v18 || GetLastError() != 231 )
      return 0;
    WaitNamedPipeW(lpNamedPipeName, nTimeOut - v16);
    if ( v17 )
    {
      GetInterruptTime((int)&v14);
      v16 = (v14 - v13) / 10000;
      if ( v16 >= nTimeOut )
        v18 = 1;
    }
    if ( !nTimeOut )
      v18 = 1;
    v12 = 0;
  }
  v9 = SetNamedPipeHandleState(v8, &Mode, 0, 0);
  if ( v9 == 1 )
    v9 = TransactNamedPipe(v8, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, 0);
  CloseHandle(v8);
  return v9;
}

//----- (77E6E466) --------------------------------------------------------
BOOL __stdcall WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
{
  BOOL result; // eax@1
  BOOL v3; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpNamedPipeName);
  if ( result )
  {
    v3 = WaitNamedPipeW(UnicodeString.Buffer, nTimeOut);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E6E4A1) --------------------------------------------------------
BOOL __stdcall GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
{
  NTSTATUS v4; // eax@5
  LSA_UNICODE_STRING DestinationString; // [sp+10h] [bp-238h]@5
  STRING AnsiString; // [sp+18h] [bp-230h]@5
  int v7; // [sp+20h] [bp-228h]@10
  WCHAR SourceString; // [sp+24h] [bp-224h]@4
  CPPEH_RECORD ms_exc; // [sp+230h] [bp-18h]@7

  if ( ClientComputerNameLength < 1 )
  {
    RtlSetLastWin32Error(122);
    return 0;
  }
  if ( !GetNamedPipeClientComputerNameW(Pipe, &SourceString, 0x208u) )
    return 0;
  RtlInitUnicodeString(&DestinationString, &SourceString);
  v4 = RtlUnicodeStringToAnsiString(&AnsiString, &DestinationString, 1u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( !*AnsiString.Buffer )
  {
    *ClientComputerName = 0;
LABEL_12:
    v7 = 1;
    goto LABEL_13;
  }
  if ( ClientComputerNameLength >= (unsigned int)AnsiString.Length + 1 )
  {
    ClientComputerName[AnsiString.Length] = 0;
    memcpy(ClientComputerName, AnsiString.Buffer, AnsiString.Length);
    goto LABEL_12;
  }
  RtlSetLastWin32Error(122);
  v7 = 0;
LABEL_13:
  ms_exc.registration.TryLevel = -2;
  RtlFreeAnsiString(&AnsiString);
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6E5B9) --------------------------------------------------------
BOOL __stdcall GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
{
  UINT_PTR AttributeValueLength; // [sp+0h] [bp-4h]@1

  AttributeValueLength = 4;
  return GetNamedPipeAttribute(
           Pipe,
           PipeConnectionAttribute,
           "ClientProcessId",
           ClientProcessId,
           (PSIZE_T)&AttributeValueLength);
}

//----- (77E6E5F5) --------------------------------------------------------
BOOL __stdcall GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
{
  UINT_PTR AttributeValueLength; // [sp+0h] [bp-4h]@1

  AttributeValueLength = 4;
  return GetNamedPipeAttribute(
           Pipe,
           PipeConnectionAttribute,
           "ClientSessionId",
           ClientSessionId,
           (PSIZE_T)&AttributeValueLength);
}

//----- (77E6E631) --------------------------------------------------------
BOOL __stdcall GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
{
  UINT_PTR AttributeValueLength; // [sp+0h] [bp-4h]@1

  AttributeValueLength = 4;
  return GetNamedPipeAttribute(Pipe, 0, "ServerProcessId", ServerProcessId, (PSIZE_T)&AttributeValueLength);
}

//----- (77E6E66D) --------------------------------------------------------
BOOL __stdcall GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
{
  UINT_PTR AttributeValueLength; // [sp+0h] [bp-4h]@1

  AttributeValueLength = 4;
  return GetNamedPipeAttribute(Pipe, 0, "ServerSessionId", ServerSessionId, (PSIZE_T)&AttributeValueLength);
}

//----- (77E6E6A9) --------------------------------------------------------
BOOL __stdcall GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
{
  BOOL result; // eax@4
  int v8; // eax@6
  WCHAR *v9; // eax@6
  BOOL v10; // esi@8
  NTSTATUS v11; // eax@9
  STRING v12; // [sp+4h] [bp-10h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-8h]@5

  if ( lpUserName )
  {
    v12.Buffer = lpUserName;
    v12.MaximumLength = nMaxUserNameSize;
    if ( (unsigned __int16)nMaxUserNameSize < nMaxUserNameSize
      || (DestinationString.MaximumLength = 2 * nMaxUserNameSize,
          (unsigned __int16)(2 * nMaxUserNameSize) < nMaxUserNameSize) )
    {
      RtlSetLastWin32Error(87);
      return 0;
    }
    v8 = KernelBaseGetGlobalData();
    v9 = (WCHAR *)RtlAllocateHeap(
                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                    *(_DWORD *)(v8 + 44),
                    DestinationString.MaximumLength);
    DestinationString.Buffer = v9;
    if ( !v9 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    v10 = GetNamedPipeHandleStateW(
            hNamedPipe,
            lpState,
            lpCurInstances,
            lpMaxCollectionCount,
            lpCollectDataTimeout,
            v9,
            (unsigned int)DestinationString.MaximumLength >> 1);
    if ( v10 )
    {
      RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
      v11 = RtlUnicodeStringToAnsiString(&v12, &DestinationString, 0);
      if ( v11 < 0 )
      {
        BaseSetLastNTError(v11);
        v10 = 0;
      }
    }
    if ( DestinationString.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    result = v10;
  }
  else
  {
    result = GetNamedPipeHandleStateW(
               hNamedPipe,
               lpState,
               lpCurInstances,
               lpMaxCollectionCount,
               lpCollectDataTimeout,
               0,
               0);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6E7A4) --------------------------------------------------------
BOOL __stdcall CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
{
  BOOL result; // eax@1
  BOOL v8; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpNamedPipeName);
  if ( result )
  {
    v8 = CallNamedPipeW(
           UnicodeString.Buffer,
           lpInBuffer,
           nInBufferSize,
           lpOutBuffer,
           nOutBufferSize,
           lpBytesRead,
           nTimeOut);
    RtlFreeUnicodeString(&UnicodeString);
    result = v8;
  }
  return result;
}

//----- (77E6E7EE) --------------------------------------------------------
BOOL __stdcall SetNamedPipeAttribute(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, SIZE_T AttributeValueLength)
{
  BOOL result; // eax@4
  SIZE_T v6; // ebx@8
  size_t v7; // esi@8
  PVOID v8; // eax@8
  void *v9; // edi@8
  NTSTATUS v10; // eax@12
  BOOL v11; // esi@13
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-8h]@12
  PIPE_ATTRIBUTE_TYPE AttributeTypea; // [sp+14h] [bp+Ch]@5
  SIZE_T AttributeValueLengtha; // [sp+20h] [bp+18h]@8

  if ( AttributeType )
  {
    if ( AttributeType == 1 )
    {
      AttributeTypea = 1114164;
    }
    else
    {
      if ( AttributeType != 2 )
      {
        RtlSetLastWin32Error(87);
        return 0;
      }
      AttributeTypea = 1114172;
    }
  }
  else
  {
    AttributeTypea = 1114156;
  }
  v6 = AttributeValueLength;
  v7 = strlen(AttributeName) + 1;
  AttributeValueLengtha = v7 + AttributeValueLength;
  v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, AttributeValueLengtha);
  v9 = v8;
  if ( v8 )
  {
    memcpy(v8, AttributeName, v7);
    if ( v6 )
      memcpy((char *)v9 + v7, AttributeValue, v6);
    v10 = NtFsControlFile(Pipe, 0, 0, 0, &IoStatusBlock, AttributeTypea, v9, AttributeValueLengtha, 0, 0);
    if ( v10 >= 0 )
    {
      v11 = 1;
    }
    else
    {
      BaseSetLastNTError(v10);
      v11 = 0;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
    result = v11;
  }
  else
  {
    RtlSetLastWin32Error(8);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6E8E2) --------------------------------------------------------
BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
{
  NTSTATUS v1; // eax@1
  ULONG SystemInformation; // [sp+0h] [bp-Ch]@1
  ULONG ReturnLength; // [sp+8h] [bp-4h]@1

  v1 = NtQuerySystemInformation(
         SystemRegistryQuotaInformation|SystemPerformanceInformation|0x10,
         &SystemInformation,
         8u,
         &ReturnLength);
  if ( v1 < 0 )
  {
    BaseSetLastNTError(v1);
    return 0;
  }
  if ( ReturnLength < 4 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  *HighestNodeNumber = SystemInformation;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6E92E) --------------------------------------------------------
int __stdcall GetNumaProcessorNodeEx(ULONG ReturnLength, int a2)
{
  ULONG v2; // esi@1
  unsigned __int16 v3; // bx@3
  NTSTATUS v4; // eax@4
  signed __int64 v5; // rax@6
  int v6; // ecx@6
  int v7; // ecx@7
  unsigned int SystemInformation; // [sp+Ch] [bp-108h]@4
  int v10; // [sp+14h] [bp-100h]@8
  __int16 v11[126]; // [sp+18h] [bp-FCh]@7

  v2 = ReturnLength;
  if ( *(_WORD *)ReturnLength >= 1u || *(_BYTE *)(ReturnLength + 2) >= 0x20u || (v3 = 0, *(_BYTE *)(ReturnLength + 3)) )
  {
LABEL_10:
    *(_WORD *)a2 = -1;
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = NtQuerySystemInformation(
         SystemRegistryQuotaInformation|SystemPerformanceInformation|0x10,
         &SystemInformation,
         0x108u,
         &ReturnLength);
  if ( v4 < 0 )
  {
    *(_WORD *)a2 = -1;
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = 1i64 << *(_BYTE *)(v2 + 2);
  v6 = 0;
  while ( 1 )
  {
    v7 = 6 * v6;
    if ( v11[v7] == *(_WORD *)v2 )
    {
      if ( (unsigned int)v5 & *(int *)((char *)&v10 + v7 * 2) )
        break;
    }
    ++v3;
    v6 = v3;
    if ( v3 > SystemInformation )
      goto LABEL_10;
  }
  *(_WORD *)a2 = v3;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E6E92E: using guessed type __int16 var_FC[126];

//----- (77E6E9EA) --------------------------------------------------------
BOOL __stdcall GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
{
  NTSTATUS v2; // eax@1
  char *v4; // esi@6
  char *v5; // edi@6
  unsigned int SystemInformation; // [sp+0h] [bp-10Ch]@1
  char v7[256]; // [sp+8h] [bp-104h]@6
  ULONG ReturnLength; // [sp+108h] [bp-4h]@1

  v2 = NtQuerySystemInformation(
         SystemRegistryQuotaInformation|SystemPerformanceInformation|0x10,
         &SystemInformation,
         0x108u,
         &ReturnLength);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    return 0;
  }
  if ( Node > SystemInformation )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = &v7[12 * Node];
  ProcessorMask->Mask = *(_DWORD *)v4;
  v4 += 4;
  v5 = (char *)&ProcessorMask->Group;
  *(_DWORD *)v5 = *(_DWORD *)v4;
  *((_DWORD *)v5 + 1) = *((_DWORD *)v4 + 1);
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E6E9EA: using guessed type char var_104[256];

//----- (77E6EA51) --------------------------------------------------------
BOOL __stdcall GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
{
  NTSTATUS v2; // eax@1
  int v4; // edx@6
  unsigned int SystemInformation; // [sp+0h] [bp-10Ch]@1
  int v6; // [sp+8h] [bp-104h]@6
  int v7[63]; // [sp+Ch] [bp-100h]@6
  ULONG ReturnLength; // [sp+108h] [bp-4h]@1

  v2 = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)60, &SystemInformation, 0x108u, &ReturnLength);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    return 0;
  }
  if ( Node > SystemInformation )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = *(&v6 + 2 * Node);
  *((_DWORD *)AvailableBytes + 1) = v7[2 * Node];
  *(_DWORD *)AvailableBytes = v4;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E6EA51: using guessed type int var_100[63];

//----- (77E6EABA) --------------------------------------------------------
int __stdcall GetNumaProximityNodeEx(ULONG ReturnLength, int a2)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2
  ULONG SystemInformation; // [sp+0h] [bp-8h]@1
  __int16 v5; // [sp+4h] [bp-4h]@3

  SystemInformation = ReturnLength;
  v2 = NtQuerySystemInformation(SystemRegistryQuotaInformation|0x40, &SystemInformation, 8u, &ReturnLength);
  if ( v2 >= 0 )
  {
    *(_WORD *)a2 = v5;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6EAFD) --------------------------------------------------------
int __stdcall GetNumaNodeNumberFromHandle(HANDLE FileHandle, int a2)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+0h] [bp-8h]@1

  v2 = NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileHandle, 2u, FileNumaNodeInformation);
  if ( v2 >= 0 )
  {
    *(_WORD *)a2 = (_WORD)FileHandle;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6EB3D) --------------------------------------------------------
BOOL __stdcall GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
{
  UCHAR v2; // bl@1
  BOOL result; // eax@2
  ULONG ReturnLength; // [sp+4h] [bp-4h]@3

  v2 = Processor;
  if ( Processor < 0x20u )
  {
    RtlGetCurrentProcessorNumberEx(&ReturnLength);
    BYTE2(ReturnLength) = v2;
    result = GetNumaProcessorNodeEx((ULONG)&ReturnLength, (int)&Processor);
    *NodeNumber = Processor;
  }
  else
  {
    *NodeNumber = -1;
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE12CC: using guessed type int __stdcall RtlGetCurrentProcessorNumberEx(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6EB8A) --------------------------------------------------------
BOOL __stdcall GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
{
  BOOL result; // eax@1
  __int16 v3; // [sp+4h] [bp-14h]@2
  struct _GROUP_AFFINITY v4; // [sp+8h] [bp-10h]@1

  result = GetNumaNodeProcessorMaskEx(Node, &v4);
  if ( result )
  {
    RtlGetCurrentProcessorNumberEx(&v3);
    if ( v4.Group == v3 )
      *(_DWORD *)ProcessorMask = v4.Mask;
    else
      *(_DWORD *)ProcessorMask = 0;
    *((_DWORD *)ProcessorMask + 1) = 0;
    result = 1;
  }
  return result;
}
// 77DE12CC: using guessed type int __stdcall RtlGetCurrentProcessorNumberEx(_DWORD);

//----- (77E6EBEF) --------------------------------------------------------
BOOL __stdcall GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
{
  return GetNumaAvailableMemoryNodeEx(Node, AvailableBytes);
}

//----- (77E6EC0E) --------------------------------------------------------
int __stdcall GetNumaProximityNode(ULONG ReturnLength, int a2)
{
  int result; // eax@1

  result = GetNumaProximityNodeEx(ReturnLength, (int)&ReturnLength);
  if ( result )
    *(_BYTE *)a2 = ReturnLength;
  return result;
}

//----- (77E6EC34) --------------------------------------------------------
BOOL __stdcall CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
{
  STRING *v5; // esi@1
  BOOLEAN v6; // bl@8
  int v7; // esi@10
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-2Ch]@8
  PBOOL v10; // [sp+14h] [bp-24h]@1
  PBOOL v11; // [sp+18h] [bp-20h]@1
  unsigned __int16 v12; // [sp+1Ch] [bp-1Ch]@7
  __int16 v13; // [sp+1Eh] [bp-1Ah]@7
  void *Src; // [sp+20h] [bp-18h]@7
  BOOLEAN NameContainsSpaces; // [sp+27h] [bp-11h]@8
  char v16; // [sp+28h] [bp-10h]@7

  v10 = pbNameContainsSpaces;
  v5 = 0;
  v11 = pbNameLegal;
  if ( !lpName || !pbNameLegal || !lpOemName && OemNameSize || OemNameSize > 0xFFFF )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( lpOemName )
  {
    v12 = 0;
    v13 = 12;
    Src = &v16;
    v5 = (STRING *)&v12;
  }
  RtlInitUnicodeString(&DestinationString, lpName);
  v6 = RtlIsNameLegalDOS8Dot3(&DestinationString, v5, &NameContainsSpaces);
  if ( !v6 )
  {
LABEL_15:
    *v11 = v6;
    return 1;
  }
  if ( !v5 )
  {
LABEL_13:
    if ( v10 )
      *v10 = NameContainsSpaces;
    goto LABEL_15;
  }
  v7 = v12;
  if ( OemNameSize >= (unsigned int)v12 + 1 )
  {
    memcpy(lpOemName, Src, v12);
    lpOemName[v7] = 0;
    goto LABEL_13;
  }
  RtlSetLastWin32Error(122);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6ED1C) --------------------------------------------------------
BOOL __stdcall SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
{
  void *v2; // esi@1
  PVOID v4; // esi@24
  NTSTATUS v5; // eax@25
  NTSTATUS v6; // [sp-4h] [bp-288h]@26
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+10h] [bp-274h]@15
  ULONG Flags; // [sp+18h] [bp-26Ch]@24
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+1Ch] [bp-268h]@15
  __int16 v10; // [sp+34h] [bp-250h]@1
  __int16 v11; // [sp+36h] [bp-24Eh]@1
  LSA_UNICODE_STRING ntname; // [sp+38h] [bp-24Ch]@9
  PVOID Address; // [sp+40h] [bp-244h]@12
  PVOID v14; // [sp+44h] [bp-240h]@21
  ULONG Size; // [sp+48h] [bp-23Ch]@22
  LSA_UNICODE_STRING DestinationString; // [sp+4Ch] [bp-238h]@2
  NTSTATUS v17; // [sp+54h] [bp-230h]@15
  int v18; // [sp+58h] [bp-22Ch]@1
  HANDLE FileHandle; // [sp+5Ch] [bp-228h]@15
  WCHAR szVolumeName; // [sp+60h] [bp-224h]@5
  CPPEH_RECORD ms_exc; // [sp+26Ch] [bp-18h]@21

  v2 = (void *)lpRootPathName;
  v18 = 0;
  v10 = 92;
  v11 = 0;
  if ( lpVolumeName )
  {
    RtlInitUnicodeString(&DestinationString, lpVolumeName);
  }
  else
  {
    DestinationString.Length = 0;
    DestinationString.MaximumLength = 0;
    DestinationString.Buffer = 0;
  }
  if ( !lpRootPathName )
    goto LABEL_36;
  if ( GetVolumeNameForVolumeMountPointW(lpRootPathName, &szVolumeName, 0x104u) )
  {
    v2 = &szVolumeName;
    goto LABEL_9;
  }
  if ( !lpRootPathName )
LABEL_36:
    v2 = &v10;
LABEL_9:
  if ( !RtlDosPathNameToNtPathName_U((PWSTR)v2, &ntname, 0, 0) )
  {
    RtlSetLastWin32Error(3);
    return 0;
  }
  Address = ntname.Buffer;
  if ( ntname.Buffer[((unsigned int)ntname.Length >> 1) - 1] != 92 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    BaseSetLastNTError(-1073741773);
    return 0;
  }
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v17 = NtOpenFile(&FileHandle, 0x100002u, &ObjectAttributes, &IoStatusBlock, 3u, 0x20u);
  if ( v17 < 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    goto LABEL_17;
  }
  if ( !IsThisARootDirectory(FileHandle, 0) )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    NtClose(FileHandle);
    RtlSetLastWin32Error(144);
    return 0;
  }
  NtClose(FileHandle);
  ntname.Length -= 2;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.ObjectName = &ntname;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v17 = NtOpenFile(&FileHandle, 0x100002u, &ObjectAttributes, &IoStatusBlock, 3u, 0x20u);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( v17 < 0 )
  {
LABEL_17:
    BaseSetLastNTError(v17);
    return 0;
  }
  v14 = 0;
  ms_exc.registration.TryLevel = 0;
  v18 = 1;
  if ( DestinationString.Length )
    Size = DestinationString.Length + 6;
  else
    Size = 8;
  Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, Size);
  v14 = v4;
  if ( v4 )
  {
    memcpy((char *)v4 + 4, DestinationString.Buffer, DestinationString.Length);
    *(_DWORD *)v4 = DestinationString.Length;
    v5 = NtSetVolumeInformationFile(FileHandle, &IoStatusBlock, v4, Size, FileFsLabelInformation);
    if ( v5 >= 0 )
      goto LABEL_29;
    v6 = v5;
  }
  else
  {
    v6 = -1073741801;
  }
  v18 = 0;
  BaseSetLastNTError(v6);
LABEL_29:
  ms_exc.registration.TryLevel = -2;
  NtClose(FileHandle);
  if ( v4 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v14);
  return v18;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6F091) --------------------------------------------------------
BOOL __stdcall CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
{
  BOOL v5; // esi@7
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@6

  if ( lpName && pbNameLegal && (lpOemName || !OemNameSize) && OemNameSize <= 0xFFFF )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName) )
    {
      v5 = CheckNameLegalDOS8Dot3W(UnicodeString.Buffer, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
      RtlFreeUnicodeString(&UnicodeString);
      return v5;
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6F100) --------------------------------------------------------
BOOL __stdcall SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
{
  BOOL result; // eax@3
  BOOL v3; // esi@7
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@3
  LSA_UNICODE_STRING v5; // [sp+8h] [bp-8h]@6

  if ( !lpRootPathName )
    lpRootPathName = "\\";
  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpRootPathName);
  if ( result )
  {
    if ( lpVolumeName )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&v5, lpVolumeName) )
      {
        v3 = 0;
LABEL_8:
        RtlFreeUnicodeString(&UnicodeString);
        return v3;
      }
    }
    else
    {
      v5.Buffer = 0;
    }
    v3 = SetVolumeLabelW(UnicodeString.Buffer, v5.Buffer);
    if ( lpVolumeName )
      RtlFreeUnicodeString(&v5);
    goto LABEL_8;
  }
  return result;
}

//----- (77E6F179) --------------------------------------------------------
BOOL __stdcall SetSystemPowerState(BOOL fSuspend, BOOL fForce)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtInitiatePowerAction(
         (POWER_ACTION)(3 - (fSuspend != 0)),
         (SYSTEM_POWER_STATE)(fSuspend != 0 ? 2 : 5),
         fForce != 1,
         0);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F1C2) --------------------------------------------------------
BOOL __stdcall GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  DEVICE_POWER_STATE State; // [sp+0h] [bp-4h]@1

  State = 0;
  v2 = NtGetDevicePowerState(hDevice, &State);
  if ( v2 >= 0 )
  {
    result = 1;
    *pfOn = State == 1 || State == PowerDeviceUnspecified;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F20B) --------------------------------------------------------
BOOL __stdcall IsSystemResumeAutomatic()
{
  return NtIsSystemResumeAutomatic();
}

//----- (77E6F21A) --------------------------------------------------------
BOOL __stdcall RequestWakeupLatency(LATENCY_TIME latency)
{
  BaseSetLastNTError(-1073741822);
  return 0;
}

//----- (77E6F22E) --------------------------------------------------------
UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
{
  __int16 v2; // bx@1
  UINT v3; // esi@1
  UINT result; // eax@2
  DWORD v5; // eax@10
  int v6; // eax@11
  signed int v7; // [sp-4h] [bp-90h]@9
  int Dst; // [sp+Ch] [bp-80h]@6
  int v9; // [sp+38h] [bp-54h]@6
  __int16 v10; // [sp+3Ch] [bp-50h]@6
  char *v11; // [sp+50h] [bp-3Ch]@4
  char v12; // [sp+54h] [bp-38h]@2
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+74h] [bp-18h]@6
  int Value; // [sp+84h] [bp-8h]@3
  ULONG_PTR Size; // [sp+88h] [bp-4h]@2
  DWORD uCmdShowa; // [sp+98h] [bp+Ch]@3

  v2 = uCmdShow;
  v3 = 0;
  if ( (uCmdShow & 0x80000000) == 0 )
  {
    uCmdShowa = 0;
  }
  else
  {
    Size = 32;
    result = InitializeProcThreadAttributeList((LPPROC_THREAD_ATTRIBUTE_LIST)&v12, 1u, 0, &Size);
    if ( !result )
      return result;
    uCmdShowa = 0x80000;
    Value = 1;
    if ( !UpdateProcThreadAttribute((LPPROC_THREAD_ATTRIBUTE_LIST)&v12, 0, 0x60001u, &Value, 4u, 0, 0) )
      goto LABEL_17;
    v11 = &v12;
  }
  memset(&Dst, 0, 0x44u);
  v9 = 1;
  v10 = v2;
  Dst = 4 * (uCmdShowa != 0) + 68;
  if ( CreateProcessA(0, (LPSTR)lpCmdLine, 0, 0, 0, uCmdShowa, 0, 0, (LPSTARTUPINFOA)&Dst, &ProcessInformation) )
  {
    if ( UserWaitForInputIdleRoutine )
      UserWaitForInputIdleRoutine(ProcessInformation.hProcess, 30000);
    NtClose(ProcessInformation.hProcess);
    NtClose(ProcessInformation.hThread);
    v7 = 33;
    goto LABEL_16;
  }
  v5 = GetLastError() - 2;
  if ( !v5 )
  {
    v7 = 2;
    goto LABEL_16;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v7 = 3;
    goto LABEL_16;
  }
  if ( v6 == 190 )
  {
    v7 = 11;
LABEL_16:
    v3 = v7;
  }
LABEL_17:
  if ( uCmdShowa & 0x80000 )
    DeleteProcThreadAttributeList((LPPROC_THREAD_ATTRIBUTE_LIST)&v12);
  return v3;
}
// 77EA6058: using guessed type int (__stdcall *UserWaitForInputIdleRoutine)(_DWORD, _DWORD);

//----- (77E6F344) --------------------------------------------------------
void __stdcall __noreturn FatalExit(int ExitCode)
{
  RtlExitUserProcess(ExitCode);
  __debugbreak();
  JUMPOUT(*(_DWORD *)algn_77E6F353);
}
// 77DE1710: using guessed type int __stdcall RtlExitUserProcess(_DWORD);

//----- (77E6F358) --------------------------------------------------------
DEP_SYSTEM_POLICY_TYPE __stdcall GetSystemDEPPolicy()
{
  DEP_SYSTEM_POLICY_TYPE v0; // ecx@0
  DEP_SYSTEM_POLICY_TYPE result; // eax@7

  if ( v7FFE02D5 )
  {
    if ( v7FFE02D5 == 1 )
    {
      result = 1;
    }
    else
    {
      if ( v7FFE02D5 == 2 )
        return 2;
      if ( v7FFE02D5 == 3 )
        return 3;
      result = v0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E6F38F) --------------------------------------------------------
BOOL __stdcall GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
{
  NTSTATUS v4; // eax@4

  if ( !ReturnedLength )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = NtQuerySystemInformationEx(108, &Group, 2, Buffer, *ReturnedLength, ReturnedLength);
  if ( v4 == -1073741820 )
    v4 = -1073741789;
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  return 1;
}
// 77DE1298: using guessed type int __stdcall NtQuerySystemInformationEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6F3DD) --------------------------------------------------------
__int16 __stdcall GetActiveProcessorGroupCount()
{
  signed int v0; // eax@1
  __int16 v1; // si@2
  char v3; // [sp+0h] [bp-8h]@1
  PVOID Address; // [sp+4h] [bp-4h]@1

  v0 = GetProcessorGroupInformation((int)&Address, (int)&v3);
  if ( v0 )
  {
    v1 = *((_WORD *)Address + 5);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    LOWORD(v0) = v1;
  }
  return v0;
}

//----- (77E6F41F) --------------------------------------------------------
DWORD __stdcall GetMaximumProcessorCount(WORD GroupNumber)
{
  DWORD result; // eax@1
  PVOID v2; // esi@2
  int v3; // ecx@6
  char *v4; // eax@7
  char v5; // [sp+0h] [bp-8h]@1
  PVOID Address; // [sp+4h] [bp-4h]@1
  int GroupNumbera; // [sp+10h] [bp+8h]@4

  result = GetProcessorGroupInformation((int)&Address, (int)&v5);
  if ( result )
  {
    v2 = Address;
    if ( GroupNumber == -1 )
    {
      v3 = *((_WORD *)Address + 5);
      GroupNumbera = 0;
      if ( *((_WORD *)Address + 5) )
      {
        v4 = (char *)Address + 32;
        do
        {
          LOWORD(GroupNumbera) = (unsigned __int8)*v4 + (_WORD)GroupNumbera;
          v4 += 44;
          --v3;
        }
        while ( v3 );
      }
    }
    else if ( GroupNumber < *((_WORD *)Address + 5) )
    {
      GroupNumbera = *((_BYTE *)Address + 44 * GroupNumber + 32);
    }
    else
    {
      GroupNumbera = 0;
      RtlSetLastWin32Error(87);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
    result = (unsigned __int16)GroupNumbera;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6F4B1) --------------------------------------------------------
BOOL __stdcall IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
{
  return IsBadReadPtr(lp, ucb);
}

//----- (77E6F4C1) --------------------------------------------------------
BOOL __stdcall IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
{
  return IsBadWritePtr(lp, ucb);
}

//----- (77E6F4D1) --------------------------------------------------------
BOOL __stdcall GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
{
  BOOL result; // eax@2
  char v3; // [sp+8h] [bp-E4h]@1
  NTSTATUS NtStatus; // [sp+28h] [bp-C4h]@1
  DWORD v5; // [sp+30h] [bp-BCh]@3
  DWORD v6; // [sp+34h] [bp-B8h]@3

  CsrClientCallServer(&v3, 0, 65549, 8);
  if ( NtStatus >= 0 )
  {
    *lpdwLevel = v5;
    *lpdwFlags = v6;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(NtStatus);
    result = 0;
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E6F544) --------------------------------------------------------
int __stdcall GetProcessGroupAffinity(HANDLE ProcessHandle, ULONG ReturnLength, PVOID ProcessInformation)
{
  ULONG v3; // esi@1
  NTSTATUS v4; // eax@1
  int result; // eax@5

  v3 = ReturnLength;
  v4 = NtQueryInformationProcess(
         ProcessHandle,
         ProcessGroupInformation,
         ProcessInformation,
         2 * *(_WORD *)ReturnLength,
         &ReturnLength);
  if ( v4 >= 0 || v4 == -1073741789 )
    *(_WORD *)v3 = ReturnLength >> 1;
  if ( v4 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v4);
    result = 0;
  }
  return result;
}

//----- (77E6F593) --------------------------------------------------------
BOOL __stdcall SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtSetInformationProcess(hProcess, ProcessAffinityMask, &dwProcessAffinityMask, 4u);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F5C3) --------------------------------------------------------
BOOL __stdcall GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtQueryInformationProcess(hProcess, ProcessPriorityBoost, &hProcess, 4u, 0);
  if ( v2 >= 0 )
  {
    *pDisablePriorityBoost = (BOOL)hProcess;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F5FD) --------------------------------------------------------
BOOL __stdcall GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtQueryInformationProcess(hProcess, ProcessIoCounters, lpIoCounters, 0x30u, 0);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F62E) --------------------------------------------------------
BOOL __stdcall GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtQueryInformationProcess(hProcess, ProcessHandleCount, &hProcess, 4u, 0);
  if ( v2 >= 0 )
  {
    *pdwHandleCount = (DWORD)hProcess;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F668) --------------------------------------------------------
int __stdcall GetProcessDEPPolicy(HANDLE ProcessHandle, int a2, int a3)
{
  NTSTATUS v3; // eax@1
  int result; // eax@2
  unsigned int v5; // eax@3
  signed int v6; // ecx@3

  v3 = NtQueryInformationProcess(ProcessHandle, ProcessExecuteFlags, &ProcessHandle, 4u, 0);
  if ( v3 >= 0 )
  {
    v5 = (unsigned int)ProcessHandle;
    v6 = 0;
    if ( !((unsigned __int8)ProcessHandle & 2) )
    {
      v6 = 1;
      if ( (unsigned __int8)ProcessHandle & 4 )
        v6 = 3;
    }
    *(_DWORD *)a2 = v6;
    *(_DWORD *)a3 = (v5 >> 3) & 1;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}

//----- (77E6F6BB) --------------------------------------------------------
int __stdcall GetProcessUserModeExceptionPolicy(int a1)
{
  BaseSetLastNTError(-1073741637);
  return 0;
}

//----- (77E6F6CF) --------------------------------------------------------
BOOL __stdcall GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  DWORD SystemInformation; // [sp+0h] [bp-Ch]@1
  DWORD v5; // [sp+4h] [bp-8h]@6

  v2 = NtQuerySystemInformation(SystemRegistryQuotaInformation, &SystemInformation, 0xCu, 0);
  if ( v2 >= 0 )
  {
    if ( pdwQuotaAllowed )
      *pdwQuotaAllowed = SystemInformation;
    if ( pdwQuotaUsed )
      *pdwQuotaUsed = v5;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E6F719) --------------------------------------------------------
DWORD __stdcall LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
{
  LPVOID v2; // esi@1
  PVOID v3; // eax@3
  DWORD v4; // eax@5
  size_t v5; // edi@7
  CHAR *v6; // eax@7
  CHAR *v7; // eax@8
  CHAR *v8; // eax@8
  ULONG v10; // esi@19
  HANDLE v11; // eax@20
  DWORD v12; // esi@22
  DWORD v13; // eax@28
  int v14; // eax@29
  int Dst; // [sp+10h] [bp-A0h]@7
  int v17; // [sp+3Ch] [bp-74h]@7
  __int16 v18; // [sp+40h] [bp-70h]@7
  struct _TEB *v19; // [sp+54h] [bp-5Ch]@24
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+58h] [bp-58h]@8
  STRING SourceString; // [sp+68h] [bp-48h]@14
  struct _TEB *v22; // [sp+70h] [bp-40h]@26
  LSA_UNICODE_STRING DestinationString; // [sp+74h] [bp-3Ch]@18
  ULONG v24; // [sp+7Ch] [bp-34h]@7
  ULONG Flags; // [sp+80h] [bp-30h]@3
  int v26; // [sp+88h] [bp-28h]@1
  size_t Size; // [sp+8Ch] [bp-24h]@7
  void *Src; // [sp+90h] [bp-20h]@3
  LPSTR lpCommandLine; // [sp+94h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+98h] [bp-18h]@3
  LPVOID lpParameterBlocka; // [sp+BCh] [bp+Ch]@5

  v26 = 0;
  v2 = lpParameterBlock;
  if ( !*((_DWORD *)lpParameterBlock + 3) && **((_WORD **)lpParameterBlock + 2) == 2 )
  {
    lpCommandLine = 0;
    Src = 0;
    ms_exc.registration.TryLevel = 1;
    Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, 0x104u);
    Src = v3;
    if ( !v3 )
      goto LABEL_37;
    v4 = SearchPathA(0, lpModuleName, ".exe", 0x104u, (LPSTR)v3, 0);
    lpParameterBlocka = (LPVOID)v4;
    if ( !v4 || v4 >= 0x104 )
    {
      if ( RtlInitAnsiStringEx(&SourceString, lpModuleName) >= 0
        && RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u) >= 0 )
      {
        v10 = RtlDetermineDosPathNameType_U(DestinationString.Buffer);
        RtlFreeUnicodeString(&DestinationString);
        if ( v10 != 5 )
        {
          v11 = CreateFileA(lpModuleName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
          if ( v11 == (HANDLE)-1 )
          {
            v12 = GetLastError();
            _local_unwind4(&__security_cookie, &ms_exc.registration, -2);
            return v12;
          }
          CloseHandle(v11);
        }
      }
      _local_unwind4(&__security_cookie, &ms_exc.registration, -2);
      return 2;
    }
    memset(&Dst, 0, 0x44u);
    Dst = 68;
    v17 = 1;
    v18 = *(_WORD *)(*((_DWORD *)v2 + 2) + 2);
    Size = **((_BYTE **)v2 + 1);
    v24 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
    v5 = (size_t)((char *)lpParameterBlocka + Size);
    v6 = (CHAR *)RtlAllocateHeap(
                   NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                   v24,
                   (ULONG)((char *)lpParameterBlocka + Size + 2));
    lpCommandLine = v6;
    if ( v6 )
    {
      memcpy(v6, Src, (size_t)lpParameterBlocka);
      v7 = (char *)lpParameterBlocka + (_DWORD)lpCommandLine;
      *v7 = 32;
      memcpy(v7 + 1, (const void *)(*((_DWORD *)v2 + 1) + 1), Size);
      v8 = lpCommandLine;
      lpCommandLine[v5 + 1] = 0;
      v26 = CreateProcessA((LPCSTR)Src, v8, 0, 0, 0, 0, *(LPVOID *)v2, 0, (LPSTARTUPINFOA)&Dst, &ProcessInformation);
    }
    else
    {
LABEL_37:
      RtlSetLastWin32Error(8);
    }
    ms_exc.registration.TryLevel = 0;
    if ( Src )
    {
      v19 = NtCurrentTeb();
      RtlFreeHeap(v19->ProcessEnvironmentBlock->Reserved4[1], 0, Src);
    }
    if ( lpCommandLine )
    {
      v22 = NtCurrentTeb();
      RtlFreeHeap(v22->ProcessEnvironmentBlock->Reserved4[1], 0, lpCommandLine);
    }
    ms_exc.registration.TryLevel = -2;
    if ( v26 )
    {
      if ( UserWaitForInputIdleRoutine )
        UserWaitForInputIdleRoutine(ProcessInformation.hProcess, 30000);
      NtClose(ProcessInformation.hProcess);
      NtClose(ProcessInformation.hThread);
      return 33;
    }
    v13 = GetLastError() - 2;
    if ( v13 )
    {
      v14 = v13 - 1;
      if ( !v14 )
        return 3;
      if ( v14 == 190 )
        return 11;
      return 0;
    }
    return 2;
  }
  BaseSetLastNTError(-1073741811);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E4A16C: using guessed type _DWORD __cdecl _local_unwind4(_DWORD, _DWORD, _DWORD);
// 77EA6058: using guessed type int (__stdcall *UserWaitForInputIdleRoutine)(_DWORD, _DWORD);

//----- (77E6FA2D) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCchCatW(wchar_t *pszDest, size_t cchDest, const wchar_t *pszSrc)
{
  size_t v3; // ecx@1
  NTSTATUS result; // eax@1
  NTSTATUS v5; // ebx@5
  size_t v6; // edx@5
  wchar_t *v7; // eax@5
  size_t v8; // edx@13
  wchar_t *v9; // eax@13
  NTSTATUS v10; // ebx@13
  size_t v11; // edi@14
  char *v12; // esi@14
  wchar_t v13; // cx@16

  v3 = 0;
  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v5 = 0;
    v6 = cchDest;
    v7 = pszDest;
    if ( !cchDest )
      goto LABEL_23;
    do
    {
      if ( !*v7 )
        break;
      ++v7;
      --v6;
    }
    while ( v6 );
    if ( v6 )
      v3 = cchDest - v6;
    else
LABEL_23:
      v5 = -1073741811;
    result = v5;
  }
  if ( result >= 0 )
  {
    v8 = cchDest - v3;
    v9 = &pszDest[v3];
    v10 = 0;
    if ( cchDest == v3 )
      goto LABEL_24;
    v11 = v8 - cchDest + v3 + 0x7FFFFFFF;
    v12 = (char *)((char *)pszSrc - (char *)v9);
    do
    {
      if ( !v11 )
        break;
      v13 = *(wchar_t *)((char *)v9 + (_DWORD)v12);
      if ( !v13 )
        break;
      *v9 = v13;
      ++v9;
      --v8;
      --v11;
    }
    while ( v8 );
    if ( !v8 )
    {
LABEL_24:
      --v9;
      v10 = -2147483643;
    }
    *v9 = 0;
    result = v10;
  }
  return result;
}

//----- (77E6FACF) --------------------------------------------------------
NTSTATUS __stdcall BasepSaveAppCertRegistryValue(int a1, int SourceString, LPCWSTR lpLibFileName)
{
  NTSTATUS result; // eax@1
  int i; // esi@2
  int v5; // eax@6
  PVOID v6; // eax@6
  PVOID v7; // esi@6
  int v8; // eax@8
  HMODULE v9; // eax@9
  HMODULE v10; // edi@9
  FARPROC v11; // eax@10
  int v12; // eax@11
  int v13; // ecx@11
  int v14; // eax@12
  int v15; // ecx@12
  UNICODE_STRING String2; // [sp+0h] [bp-8h]@1

  result = RtlInitUnicodeStringEx(&String2, (PCWSTR)SourceString);
  if ( result >= 0 )
  {
    for ( i = *(_DWORD *)a1; i != a1; i = *(_DWORD *)i )
    {
      if ( !RtlCompareUnicodeString((PCUNICODE_STRING)(i + 8), &String2, 1u) )
        goto LABEL_13;
    }
    v5 = KernelBaseGetGlobalData();
    v6 = RtlAllocateHeap(
           NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
           *(_DWORD *)(v5 + 44),
           String2.MaximumLength + 20);
    v7 = v6;
    if ( !v6 )
      return -1073741801;
    *((_DWORD *)v6 + 1) = v6;
    *(_DWORD *)v6 = v6;
    *((_DWORD *)v6 + 3) = (char *)v6 + 20;
    *((_WORD *)v6 + 4) = String2.Length;
    *((_WORD *)v6 + 5) = String2.MaximumLength;
    memcpy((char *)v6 + 20, String2.Buffer, String2.MaximumLength);
    v8 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)v7 = a1;
    *((_DWORD *)v7 + 1) = v8;
    *(_DWORD *)v8 = v7;
    *(_DWORD *)(a1 + 4) = v7;
    if ( lpLibFileName && (v9 = LoadLibraryW(lpLibFileName), (v10 = v9) != 0) )
    {
      v11 = GetProcAddress(v9, "CreateProcessNotify");
      *((_DWORD *)v7 + 4) = v11;
      if ( !v11 )
      {
        v12 = *(_DWORD *)v7;
        v13 = *((_DWORD *)v7 + 1);
        *(_DWORD *)v13 = *(_DWORD *)v7;
        *(_DWORD *)(v12 + 4) = v13;
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
        FreeLibrary(v10);
      }
    }
    else
    {
      v14 = *(_DWORD *)v7;
      v15 = *((_DWORD *)v7 + 1);
      *(_DWORD *)v15 = *(_DWORD *)v7;
      *(_DWORD *)(v14 + 4) = v15;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
    }
LABEL_13:
    result = 0;
  }
  return result;
}

//----- (77E6FC0D) --------------------------------------------------------
NTSTATUS __stdcall BasepConfigureAppCertDlls(int a1, int a2, LPCWSTR lpLibFileName, int a4, int a5, int a6)
{
  return BasepSaveAppCertRegistryValue(a6, a1, lpLibFileName);
}

//----- (77E6FC29) --------------------------------------------------------
int __stdcall ReplacePartitionUnit(PCWSTR a1, PCWSTR SourceString, int a3)
{
  NTSTATUS v3; // eax@1
  int result; // eax@2
  LSA_UNICODE_STRING v5; // [sp+4h] [bp-10h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, SourceString);
  RtlInitUnicodeString(&v5, a1);
  v3 = NtReplacePartitionUnit(&v5, &DestinationString, a3);
  if ( v3 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}
// 77DE1270: using guessed type int __stdcall NtReplacePartitionUnit(_DWORD, _DWORD, _DWORD);

//----- (77E6FC76) --------------------------------------------------------
int __stdcall DosPathToSessionPathW(int a1, void *lp, LPVOID a3)
{
  signed int v3; // esi@2
  size_t v4; // esi@7
  wchar_t *v5; // edi@7

  if ( *(_BYTE *)(BaseStaticServerData + 2336) == 1 )
    v3 = 0;
  else
    v3 = a1 != 0 ? 30 : 10;
  if ( !lp || IsBadReadPtr(lp, 2u) || IsBadWritePtr(a3, 4u) )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = v3 + wcslen((const unsigned __int16 *)lp) + 13;
  v5 = (wchar_t *)LocalAlloc(0, 2 * v4);
  if ( !v5 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  if ( *(_BYTE *)(BaseStaticServerData + 2336) == 1 )
  {
    swprintf_s(v5, v4, L"%ws", lp);
  }
  else if ( a1 )
  {
    swprintf_s(v5, v4, L"%ws%u\\DosDevices\\%ws", L"GLOBALROOT\\Sessions\\", a1, lp);
  }
  else
  {
    swprintf_s(v5, v4, L"%ws\\DosDevices\\%ws", L"GLOBALROOT", lp);
  }
  *(_DWORD *)a3 = v5;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E6FDD0: using guessed type wchar_t aGlobalrootSess[21];
// 77E6FE24: using guessed type wchar_t aGlobalroot[11];
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E6FE69) --------------------------------------------------------
int __stdcall DosPathToSessionPathA(int a1, void *lp, LPVOID a3)
{
  int v3; // eax@4
  int v4; // esi@6
  NTSTATUS v5; // eax@7
  unsigned int v6; // kr00_4@9
  char *v7; // eax@9
  char *v8; // edi@9
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@4
  STRING DestinationString; // [sp+18h] [bp-2Ch]@4
  int v12; // [sp+20h] [bp-24h]@4
  PCWSTR SourceString; // [sp+28h] [bp-1Ch]@6
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@4

  if ( !lp || IsBadReadPtr(lp, 1u) || IsBadWritePtr(a3, 4u) )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    ms_exc.registration.TryLevel = 0;
    RtlInitAnsiString(&DestinationString, (PCSZ)lp);
    v3 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
    v12 = v3;
    ms_exc.registration.TryLevel = -2;
    if ( v3 >= 0 )
    {
      v4 = DosPathToSessionPathW(a1, UnicodeString.Buffer, &SourceString);
      RtlFreeUnicodeString(&UnicodeString);
      if ( v4 )
      {
        RtlInitUnicodeString(&UnicodeString, SourceString);
        v5 = RtlUnicodeStringToAnsiString(&DestinationString, &UnicodeString, 1u);
        if ( v5 >= 0 )
        {
          v6 = strlen(DestinationString.Buffer);
          v7 = (char *)LocalAlloc(0, v6 + 1);
          v8 = v7;
          if ( v7 )
          {
            strcpy_s(v7, v6 + 1, DestinationString.Buffer);
            *(_DWORD *)a3 = v8;
            LocalFree((HLOCAL)SourceString);
            RtlFreeAnsiString(&DestinationString);
            return 1;
          }
          LocalFree((HLOCAL)SourceString);
          RtlFreeAnsiString(&DestinationString);
          RtlSetLastWin32Error(8);
        }
        else
        {
          BaseSetLastNTError(v5);
          LocalFree((HLOCAL)SourceString);
        }
      }
    }
    else
    {
      BaseSetLastNTError(v3);
    }
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E6FFEB) --------------------------------------------------------
HANDLE __stdcall CreateFileMappingNumaWStub(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
{
  return CreateFileMappingNumaW(
           hFile,
           lpFileMappingAttributes,
           flProtect,
           dwMaximumSizeHigh,
           dwMaximumSizeLow,
           lpName,
           nndPreferred);
}

//----- (77E6FFFB) --------------------------------------------------------
HANDLE __stdcall CreateMutexExAStub(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
{
  return CreateMutexExA(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
}

//----- (77E7000B) --------------------------------------------------------
HANDLE __stdcall CreateRemoteThreadStub(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
  return CreateRemoteThreadEx(
           hProcess,
           lpThreadAttributes,
           dwStackSize,
           lpStartAddress,
           lpParameter,
           dwCreationFlags,
           0,
           lpThreadId);
}

//----- (77E7003F) --------------------------------------------------------
BOOL __stdcall DeleteVolumeMountPointWStub(LPCWSTR lpszVolumeMountPoint)
{
  return DeleteVolumeMountPointW(lpszVolumeMountPoint);
}

//----- (77E7004F) --------------------------------------------------------
BOOL __stdcall EnumCalendarInfoExWStub(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
{
  return EnumCalendarInfoExW(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
}

//----- (77E7005F) --------------------------------------------------------
BOOL __stdcall EnumCalendarInfoWStub(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
{
  return EnumCalendarInfoW(lpCalInfoEnumProc, Locale, Calendar, CalType);
}

//----- (77E7006F) --------------------------------------------------------
BOOL __stdcall EnumDateFormatsExWStub(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
{
  return EnumDateFormatsExW(lpDateFmtEnumProcEx, Locale, dwFlags);
}

//----- (77E7007F) --------------------------------------------------------
BOOL __stdcall EnumLanguageGroupLocalesWStub(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
{
  return EnumLanguageGroupLocalesW(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
}

//----- (77E7008F) --------------------------------------------------------
BOOL __stdcall EnumSystemCodePagesWStub(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
{
  return EnumSystemCodePagesW(lpCodePageEnumProc, dwFlags);
}

//----- (77E7009F) --------------------------------------------------------
BOOL __stdcall EnumSystemLocalesExStub(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
{
  return EnumSystemLocalesEx(lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
}

//----- (77E700AF) --------------------------------------------------------
BOOL __stdcall EnumSystemLocalesWStub(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
{
  return EnumSystemLocalesW(lpLocaleEnumProc, dwFlags);
}

//----- (77E700BF) --------------------------------------------------------
HANDLE __stdcall FindFirstFileExAStub(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
{
  return FindFirstFileExA(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
}

//----- (77E700CF) --------------------------------------------------------
HANDLE __stdcall FindFirstChangeNotificationAStub(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
{
  return FindFirstChangeNotificationA(lpPathName, bWatchSubtree, dwNotifyFilter);
}

//----- (77E700DF) --------------------------------------------------------
int __stdcall FindStringOrdinalStub(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
{
  return FindStringOrdinal(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
}

//----- (77E700EF) --------------------------------------------------------
BOOL __stdcall GetComputerNameExAStub(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
{
  return GetComputerNameExA(NameType, lpBuffer, nSize);
}

//----- (77E700FF) --------------------------------------------------------
int __stdcall GetCurrencyFormatWStub(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
{
  return GetCurrencyFormatW(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
}

//----- (77E7010F) --------------------------------------------------------
BOOL __stdcall GetNamedPipeAttributeStub(HANDLE Pipe, PIPE_ATTRIBUTE_TYPE AttributeType, PSTR AttributeName, PVOID AttributeValue, PSIZE_T AttributeValueLength)
{
  return GetNamedPipeAttribute(Pipe, AttributeType, AttributeName, AttributeValue, AttributeValueLength);
}

//----- (77E7011F) --------------------------------------------------------
BOOL __stdcall GetNamedPipeClientComputerNameWStub(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
{
  return GetNamedPipeClientComputerNameW(Pipe, ClientComputerName, ClientComputerNameLength);
}

//----- (77E7012F) --------------------------------------------------------
DWORD __stdcall GetLongPathNameAStub(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
{
  return GetLongPathNameA(lpszShortPath, lpszLongPath, cchBuffer);
}

//----- (77E7013F) --------------------------------------------------------
BOOL __stdcall GetProcessPreferredUILanguagesStub(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
{
  return GetProcessPreferredUILanguages(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
}

//----- (77E7014F) --------------------------------------------------------
BOOL __stdcall GetQueuedCompletionStatusExStub(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
{
  return GetQueuedCompletionStatusEx(
           CompletionPort,
           lpCompletionPortEntries,
           ulCount,
           ulNumEntriesRemoved,
           dwMilliseconds,
           fAlertable);
}

//----- (77E7015F) --------------------------------------------------------
BOOL __stdcall GetThreadPriorityBoostStub(HANDLE hThread, PBOOL pDisablePriorityBoost)
{
  return GetThreadPriorityBoost(hThread, pDisablePriorityBoost);
}

//----- (77E7016F) --------------------------------------------------------
BOOL __stdcall HeapQueryInformationStub(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
{
  return HeapQueryInformation(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
}

//----- (77E7017F) --------------------------------------------------------
BOOL __stdcall HeapSummaryStub(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
{
  return HeapSummary(hHeap, dwFlags, lpSummary);
}

//----- (77E7018F) --------------------------------------------------------
BOOL __stdcall IsValidLanguageGroupStub(LGRPID LanguageGroup, DWORD dwFlags)
{
  return IsValidLanguageGroup(LanguageGroup, dwFlags);
}

//----- (77E7019F) --------------------------------------------------------
LPVOID __stdcall MapViewOfFileExNumaStub(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
{
  return MapViewOfFileExNuma(
           hFileMappingObject,
           dwDesiredAccess,
           dwFileOffsetHigh,
           dwFileOffsetLow,
           dwNumberOfBytesToMap,
           lpBaseAddress,
           nndPreferred);
}

//----- (77E701AF) --------------------------------------------------------
BOOL __stdcall NeedCurrentDirectoryForExePathAStub(LPCSTR ExeName)
{
  return NeedCurrentDirectoryForExePathA(ExeName);
}

//----- (77E701BF) --------------------------------------------------------
HANDLE __stdcall OpenWaitableTimerWStub(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
{
  return OpenWaitableTimerW(dwDesiredAccess, bInheritHandle, lpTimerName);
}

//----- (77E701CF) --------------------------------------------------------
BOOL __stdcall RemoveDirectoryAStub(LPCSTR lpPathName)
{
  return RemoveDirectoryA(lpPathName);
}

//----- (77E701DF) --------------------------------------------------------
BOOL __stdcall SetCalendarInfoWStub(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
{
  return SetCalendarInfoW(Locale, Calendar, CalType, lpCalData);
}

//----- (77E701F9) --------------------------------------------------------
BOOL __stdcall SetLocaleInfoWStub(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
{
  return SetLocaleInfoW(Locale, LCType, lpLCData);
}

//----- (77E70209) --------------------------------------------------------
BOOL __stdcall SetLocalTimeStub(const SYSTEMTIME *lpSystemTime)
{
  return SetLocalTime(lpSystemTime);
}

//----- (77E70219) --------------------------------------------------------
BOOL __stdcall SetStdHandleStub(DWORD nStdHandle, HANDLE hHandle)
{
  return SetStdHandle(nStdHandle, hHandle);
}

//----- (77E70229) --------------------------------------------------------
BOOL __stdcall SetStdHandleExStub(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
{
  return SetStdHandleEx(nStdHandle, hHandle, phPrevValue);
}

//----- (77E70239) --------------------------------------------------------
BOOL __stdcall SetThreadPriorityBoostStub(HANDLE hThread, BOOL bDisablePriorityBoost)
{
  return SetThreadPriorityBoost(hThread, bDisablePriorityBoost);
}

//----- (77E70249) --------------------------------------------------------
BOOL __stdcall TransactNamedPipeStub(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
{
  return TransactNamedPipe(
           hNamedPipe,
           lpInBuffer,
           nInBufferSize,
           lpOutBuffer,
           nOutBufferSize,
           lpBytesRead,
           lpOverlapped);
}

//----- (77E70259) --------------------------------------------------------
LPVOID __stdcall VirtualAllocExNumaStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
{
  return VirtualAllocExNuma(hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
}

//----- (77E70269) --------------------------------------------------------
BOOL __stdcall VirtualProtectExStub(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
{
  return VirtualProtectEx(hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
}

//----- (77E70279) --------------------------------------------------------
BOOL __stdcall WaitNamedPipeWStub(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
{
  return WaitNamedPipeW(lpNamedPipeName, nTimeOut);
}

//----- (77E70289) --------------------------------------------------------
BOOL __stdcall Wow64RevertWow64FsRedirectionStub(PVOID OlValue)
{
  return Wow64RevertWow64FsRedirection(OlValue);
}

//----- (77E70299) --------------------------------------------------------
BOOL __stdcall SetThreadpoolStackInformationStub(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
{
  return SetThreadpoolStackInformation(ptpp, ptpsi);
}

//----- (77E702A9) --------------------------------------------------------
BOOL __stdcall QueryThreadpoolStackInformationStub(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
{
  return QueryThreadpoolStackInformation(ptpp, ptpsi);
}

//----- (77E702B9) --------------------------------------------------------
BOOL __stdcall SetProcessAffinityUpdateModeStub(HANDLE hProcess, DWORD dwFlags)
{
  return SetProcessAffinityUpdateMode(hProcess, dwFlags);
}

//----- (77E702C9) --------------------------------------------------------
BOOL __stdcall QueryProcessAffinityUpdateModeStub(HANDLE hProcess, LPDWORD lpdwFlags)
{
  return QueryProcessAffinityUpdateMode(hProcess, lpdwFlags);
}

//----- (77E702D9) --------------------------------------------------------
int __stdcall NlsEventDataDescCreateStub(int a1, int a2, int a3, int a4)
{
  return NlsEventDataDescCreate(a1, a2, a3, a4);
}
// 77E9564C: using guessed type int __stdcall NlsEventDataDescCreate(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E702E9) --------------------------------------------------------
int __stdcall NlsWriteEtwEventStub(int a1, int a2, int a3, int a4, int a5)
{
  return NlsWriteEtwEvent(a1, a2, a3, a4, a5);
}
// 77E95657: using guessed type int __stdcall NlsWriteEtwEvent(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7030B) --------------------------------------------------------
void __stdcall FatalAppExitAStub(UINT uAction, LPCSTR lpMessageText)
{
  FatalAppExitA(uAction, lpMessageText);
}

//----- (77E7031B) --------------------------------------------------------
void __stdcall FatalAppExitWStub(UINT uAction, LPCWSTR lpMessageText)
{
  FatalAppExitW(uAction, lpMessageText);
}

//----- (77E7032B) --------------------------------------------------------
int __stdcall GetCurrencyFormatExStub(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
{
  return GetCurrencyFormatEx(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
}

//----- (77E7033B) --------------------------------------------------------
int __stdcall GetEraNameCountedStringStub(int a1, int a2, int a3, int a4)
{
  return GetEraNameCountedString(a1, a2, a3, a4);
}
// 77E8B84B: using guessed type int __stdcall GetEraNameCountedString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7034B) --------------------------------------------------------
BOOL __stdcall GetFileMUIInfoStub(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
{
  return GetFileMUIInfo(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
}

//----- (77E7035B) --------------------------------------------------------
DWORD __stdcall GetFinalPathNameByHandleAStub(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
{
  return GetFinalPathNameByHandleA(hFile, lpszFilePath, cchFilePath, dwFlags);
}

//----- (77E7036B) --------------------------------------------------------
int __stdcall GetUserDefaultLocaleNameStub(LPWSTR lpLocaleName, int cchLocaleName)
{
  return GetUserDefaultLocaleName(lpLocaleName, cchLocaleName);
}

//----- (77E7037B) --------------------------------------------------------
int __stdcall LCMapStringExStub(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
{
  return LCMapStringEx(
           lpLocaleName,
           dwMapFlags,
           lpSrcStr,
           cchSrc,
           lpDestStr,
           cchDest,
           lpVersionInformation,
           lpReserved,
           lParam);
}

//----- (77E7038B) --------------------------------------------------------
BOOLEAN __stdcall NotifyMountMgrStub(PWSTR dosname, PCWSTR SourceString, int a3)
{
  return NotifyMountMgr(dosname, SourceString, a3);
}

//----- (77E7039B) --------------------------------------------------------
BOOL __stdcall PeekNamedPipeStub(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
{
  return PeekNamedPipe(hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
}

//----- (77E703AB) --------------------------------------------------------
void __stdcall RtlCaptureContextStub(PCONTEXT ContextRecord)
{
  RtlCaptureContext(ContextRecord);
}

//----- (77E703BC) --------------------------------------------------------
void *__stdcall RtlFillMemoryStub(void *Dst, size_t Size, int Val)
{
  return memset(Dst, Val, Size);
}

//----- (77E703DB) --------------------------------------------------------
HANDLE __stdcall CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
{
  void *v2; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( Name )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, Name) )
    {
      v2 = (void *)RtlCreateBoundaryDescriptor(&UnicodeString, Flags);
      RtlFreeUnicodeString(&UnicodeString);
      return v2;
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}
// 77DE1264: using guessed type int __stdcall RtlCreateBoundaryDescriptor(_DWORD, _DWORD);

//----- (77E7042C) --------------------------------------------------------
BOOL __stdcall AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = RtlAddIntegrityLabelToBoundaryDescriptor(BoundaryDescriptor, IntegrityLabel);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE125C: using guessed type int __stdcall RtlAddIntegrityLabelToBoundaryDescriptor(_DWORD, _DWORD);

//----- (77E70457) --------------------------------------------------------
HANDLE __stdcall CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
{
  HANDLE v3; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpAliasPrefix )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpAliasPrefix) )
    {
      v3 = CreatePrivateNamespaceW((int)lpPrivateNamespaceAttributes, (int)lpBoundaryDescriptor, UnicodeString.Buffer);
      RtlFreeUnicodeString(&UnicodeString);
      return v3;
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}

//----- (77E704A9) --------------------------------------------------------
HANDLE __stdcall OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
{
  HANDLE v2; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpAliasPrefix )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpAliasPrefix) )
    {
      v2 = OpenPrivateNamespaceW((int)lpBoundaryDescriptor, UnicodeString.Buffer);
      RtlFreeUnicodeString(&UnicodeString);
      return v2;
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}

//----- (77E704F8) --------------------------------------------------------
int __stdcall QueryFullProcessImageNameA(HANDLE ProcessHandle, HANDLE a2, LPSTR lpMultiByteStr, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // eax@4
  const WCHAR *v7; // edi@4
  int v8; // eax@7
  signed int v10; // [sp+Ch] [bp-8h]@1
  PVOID HeapHandle; // [sp+10h] [bp-4h]@4

  v4 = a4;
  v5 = *(_DWORD *)a4;
  v10 = 0;
  if ( *(_DWORD *)a4 <= 0x7FFFFFFFu )
  {
    HeapHandle = NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1];
    a4 = *(_DWORD *)a4;
    v6 = KernelBaseGetGlobalData();
    v7 = (const WCHAR *)RtlAllocateHeap(HeapHandle, *(_DWORD *)(v6 + 44), 2 * v5);
    if ( v7 )
    {
      if ( QueryFullProcessImageNameW(ProcessHandle, a2, (void *)v7, (int)&a4) )
      {
        v8 = WideCharToMultiByte(0, 0, v7, a4 + 1, lpMultiByteStr, *(_DWORD *)v4, 0, 0);
        if ( v8 )
        {
          *(_DWORD *)v4 = v8 - 1;
          v10 = 1;
        }
      }
      RtlFreeHeap(HeapHandle, 0, (PVOID)v7);
    }
    else
    {
      BaseSetLastNTError(-1073741801);
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return v10;
}

//----- (77E705A5) --------------------------------------------------------
HANDLE __stdcall OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
{
  HANDLE v3; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName) )
    {
      v3 = OpenSemaphoreW(dwDesiredAccess, bInheritHandle, UnicodeString.Buffer);
      RtlFreeUnicodeString(&UnicodeString);
      return v3;
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}

//----- (77E705F7) --------------------------------------------------------
HANDLE __stdcall OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
{
  HANDLE v3; // esi@3
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpTimerName )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpTimerName) )
    {
      v3 = OpenWaitableTimerW(dwDesiredAccess, bInheritHandle, UnicodeString.Buffer);
      RtlFreeUnicodeString(&UnicodeString);
      return v3;
    }
  }
  else
  {
    BaseSetLastNTError(-1073741811);
  }
  return 0;
}

//----- (77E70649) --------------------------------------------------------
signed int __stdcall IsCallerAdminOrSystem()
{
  HMODULE v0; // eax@1
  NTSTATUS v1; // eax@3
  signed int v2; // edi@6
  ULONG v3; // ST28_4@8
  NTSTATUS v4; // eax@13
  ULONG v5; // ST28_4@18
  HMODULE hLibModule; // [sp+8h] [bp-1Ch]@1
  FARPROC v8; // [sp+Ch] [bp-18h]@2
  int v9; // [sp+10h] [bp-14h]@4
  PSID Sid; // [sp+14h] [bp-10h]@1
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [sp+18h] [bp-Ch]@1

  Sid = 0;
  IdentifierAuthority.Value[0] = 0;
  IdentifierAuthority.Value[1] = 0;
  IdentifierAuthority.Value[2] = 0;
  IdentifierAuthority.Value[3] = 0;
  IdentifierAuthority.Value[4] = 0;
  IdentifierAuthority.Value[5] = 5;
  v0 = LoadLibraryW(L"advapi32.dll");
  hLibModule = v0;
  if ( v0 )
  {
    v8 = GetProcAddress(v0, "CheckTokenMembership");
    if ( !v8 )
      goto LABEL_19;
    v1 = RtlAllocateAndInitializeSid(&IdentifierAuthority, 2, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &Sid);
    if ( v1 < 0 )
    {
      v3 = RtlNtStatusToDosError(v1);
      RtlSetLastWin32Error(v3);
    }
    else if ( ((int (__stdcall *)(_DWORD, PSID, int *))v8)(0, Sid, &v9) )
    {
      if ( v9 )
      {
        RtlSetLastWin32Error(0);
        v2 = 1;
        goto LABEL_10;
      }
      RtlSetLastWin32Error(5);
    }
    v2 = 0;
LABEL_10:
    if ( Sid )
    {
      RtlFreeSid(Sid);
      Sid = 0;
    }
    if ( v2 )
      goto LABEL_20;
    v4 = RtlAllocateAndInitializeSid(&IdentifierAuthority, 1, 0x12u, 0, 0, 0, 0, 0, 0, 0, &Sid);
    if ( v4 < 0 )
    {
      v5 = RtlNtStatusToDosError(v4);
      RtlSetLastWin32Error(v5);
    }
    else if ( ((int (__stdcall *)(_DWORD, PSID, int *))v8)(0, Sid, &v9) )
    {
      if ( v9 )
      {
        RtlSetLastWin32Error(0);
        v2 = 1;
LABEL_20:
        FreeLibrary(hLibModule);
        goto LABEL_22;
      }
      RtlSetLastWin32Error(5);
    }
LABEL_19:
    v2 = 0;
    goto LABEL_20;
  }
  v2 = 0;
LABEL_22:
  if ( Sid )
    RtlFreeSid(Sid);
  return v2;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7079F) --------------------------------------------------------
signed int __stdcall SetTermsrvAppInstallMode(int a1)
{
  signed int result; // eax@2
  int v2; // eax@3
  ULONG v3; // eax@4
  NTSTATUS v4; // eax@6
  ULONG v5; // eax@7
  HMODULE v6; // eax@9
  int v7; // [sp+0h] [bp-E8h]@3
  char v8; // [sp+4h] [bp-E4h]@6
  int v9; // [sp+2Ch] [bp-BCh]@6

  if ( !(v7FFE02D0 & 0x10) )
    return 0;
  v2 = IsTSAppCompatEnabled((int)&v7);
  if ( v2 < 0 )
  {
    v3 = RtlNtStatusToDosError(v2);
    RtlSetLastWin32Error(v3);
    return 0;
  }
  if ( !v7 )
    return 0;
  v9 = a1;
  v4 = CsrClientCallServer(&v8, 0, 65557, 4);
  if ( v4 >= 0 )
  {
    if ( gpTermsrvUpdateAllUserMenu )
      goto LABEL_16;
    v6 = LoadLibraryW(L"tsappcmp.dll");
    if ( v6 )
      gpTermsrvUpdateAllUserMenu = (int (__stdcall *)(_DWORD))GetProcAddress(v6, "TermsrvUpdateAllUserMenu");
    if ( gpTermsrvUpdateAllUserMenu )
LABEL_16:
      gpTermsrvUpdateAllUserMenu(a1 != 1);
    result = 1;
  }
  else
  {
    v5 = RtlNtStatusToDosError(v4);
    RtlSetLastWin32Error(v5);
    result = 0;
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6FE8: using guessed type int (__stdcall *gpTermsrvUpdateAllUserMenu)(_DWORD);

//----- (77E70892) --------------------------------------------------------
int __stdcall RegKrnSetTermSrvHooksAndFlags(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int result; // eax@1

  result = RegKrnGetGlobalState();
  *(_DWORD *)result = a1;
  *(_DWORD *)(result + 4) = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a5;
  *(_DWORD *)(result + 20) = a6;
  *(_DWORD *)(result + 24) = a7;
  *(_DWORD *)(result + 28) = a8;
  *(_DWORD *)(result + 32) = a9;
  return result;
}

//----- (77E708DA) --------------------------------------------------------
int __stdcall GetCompatFlags()
{
  PRTL_USER_PROCESS_PARAMETERS v0; // esi@1
  const wchar_t *v1; // ST10_4@1
  wchar_t *v2; // eax@1
  const wchar_t *v3; // eax@2
  wchar_t *v4; // eax@4
  PVOID v5; // edi@6
  PVOID v6; // eax@8
  PVOID v7; // esi@11
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-244h]@10
  int v10; // [sp+24h] [bp-22Ch]@1
  HANDLE KeyHandle; // [sp+28h] [bp-228h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-224h]@1
  PVOID Address; // [sp+34h] [bp-21Ch]@6
  ULONG Size; // [sp+38h] [bp-218h]@6
  PVOID KeyValueInformation; // [sp+3Ch] [bp-214h]@8
  wchar_t Dst; // [sp+40h] [bp-210h]@4

  KeyHandle = 0;
  DestinationString.Buffer = 0;
  v0 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters;
  v1 = v0->ImagePathName.Buffer;
  v10 = 0;
  v2 = _wcsrchr(v1, 0x5Cu);
  if ( v2 )
    v3 = v2 + 1;
  else
    v3 = v0->ImagePathName.Buffer;
  wcscpy_s(&Dst, 0x105u, v3);
  v4 = _wcsrchr(&Dst, 0x2Eu);
  if ( v4 )
    *v4 = 0;
  DestinationString.Buffer = 0;
  Size = 2 * wcslen(&Dst) + 216;
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
  Address = v5;
  if ( v5 )
  {
    wcscpy_s(
      (wchar_t *)v5,
      Size >> 1,
      L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Applications\\");
    wcscat_s((wchar_t *)v5, Size >> 1, &Dst);
    RtlInitUnicodeString(&DestinationString, (PCWSTR)v5);
  }
  v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x224u);
  KeyValueInformation = v6;
  if ( DestinationString.Buffer )
  {
    if ( v6 )
    {
      ObjectAttributes.ObjectName = &DestinationString;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes) >= 0 )
      {
        RtlInitUnicodeString(&DestinationString, L"Flags");
        v7 = KeyValueInformation;
        if ( NtQueryValueKey(
               KeyHandle,
               &DestinationString,
               KeyValuePartialInformation,
               KeyValueInformation,
               0x224u,
               &Size) >= 0
          && *((_DWORD *)v7 + 1) == 4 )
          v10 = *((_DWORD *)v7 + 3);
        NtClose(KeyHandle);
      }
    }
  }
  if ( Address )
  {
    memset(Address, 0, DestinationString.MaximumLength);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  if ( KeyValueInformation )
  {
    memset(KeyValueInformation, 0, 0x224u);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, KeyValueInformation);
  }
  return v10;
}

//----- (77E70C1B) --------------------------------------------------------
NTSTATUS __stdcall GetRegistryExtensionFlags(int a1)
{
  NTSTATUS result; // eax@1
  PVOID v2; // edi@2
  int v3; // esi@4
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-34h]@1
  LSA_UNICODE_STRING ValueName; // [sp+20h] [bp-1Ch]@3
  LSA_UNICODE_STRING DestinationString; // [sp+28h] [bp-14h]@1
  int v7; // [sp+30h] [bp-Ch]@1
  HANDLE KeyHandle; // [sp+34h] [bp-8h]@1
  ULONG KeyValueInformationLength; // [sp+38h] [bp-4h]@2

  v7 = *(_DWORD *)(RegKrnGetGlobalState() + 36);
  RtlInitUnicodeString(
    &DestinationString,
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server");
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = NtOpenKey(&KeyHandle, 1u, &ObjectAttributes);
  if ( result >= 0 )
  {
    KeyValueInformationLength = 20;
    v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x14u);
    if ( v2 )
    {
      RtlInitUnicodeString(&ValueName, L"RegistryExtensionFlags");
      if ( NtQueryValueKey(
             KeyHandle,
             &ValueName,
             KeyValuePartialInformation,
             v2,
             KeyValueInformationLength,
             &KeyValueInformationLength) < 0 )
        v3 = v7;
      else
        v3 = *((_DWORD *)v2 + 3);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
      if ( a1 & 0x20000 )
        v3 &= 0xFFFFFFFD;
      if ( a1 & 0x10000 )
        v3 &= 0xFFFFFFFE;
      *(_DWORD *)(RegKrnGetGlobalState() + 36) = v3;
    }
    result = NtClose(KeyHandle);
  }
  return result;
}

//----- (77E70DE3) --------------------------------------------------------
BOOL __stdcall SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtSetContextThread(hThread, (PCONTEXT)lpContext);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E70E0E) --------------------------------------------------------
BOOL __stdcall Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
{
  BaseSetLastNTError(-1073741822);
  return 0;
}

//----- (77E70E22) --------------------------------------------------------
DWORD __stdcall Wow64SuspendThread(HANDLE hThread)
{
  BaseSetLastNTError(-1073741822);
  return -1;
}

//----- (77E70E37) --------------------------------------------------------
BOOL __stdcall GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2

  v2 = NtQueryInformationThread(hThread, ThreadIsIoPending, &hThread, 4u, 0);
  if ( v2 >= 0 )
  {
    *lpIOIsPending = hThread != 0;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E70E76) --------------------------------------------------------
int __stdcall GetThreadGroupAffinity(HANDLE ThreadHandle, PVOID ThreadInformation)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2

  v2 = NtQueryInformationThread(ThreadHandle, ThreadGroupInformation, ThreadInformation, 0xCu, 0);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E70EA7) --------------------------------------------------------
int __stdcall SetThreadIdealProcessorEx(HANDLE ThreadHandle, int ThreadInformation, int a3)
{
  NTSTATUS v3; // eax@1
  int result; // eax@2

  ThreadInformation = *(_DWORD *)ThreadInformation;
  v3 = NtSetInformationThread(ThreadHandle, ThreadIdealProcessorEx, &ThreadInformation, 4u);
  if ( v3 >= 0 )
  {
    if ( a3 )
      *(_DWORD *)a3 = ThreadInformation;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}

//----- (77E70EEB) --------------------------------------------------------
int __stdcall GetThreadIdealProcessorEx(HANDLE ThreadHandle, PVOID ThreadInformation)
{
  NTSTATUS v3; // eax@5

  if ( ThreadHandle == (HANDLE)-2 )
  {
    *(_DWORD *)ThreadInformation = NtCurrentTeb()->Reserved5[23];
    *((_BYTE *)ThreadInformation + 3) = 0;
    return 1;
  }
  v3 = NtQueryInformationThread(ThreadHandle, ThreadIdealProcessorEx, ThreadInformation, 4u, 0);
  if ( v3 >= 0 )
    return 1;
  BaseSetLastNTError(v3);
  return 0;
}

//----- (77E70F37) --------------------------------------------------------
BOOL __stdcall Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl)
{
  LPHEAPLIST32 v2; // edi@1
  NTSTATUS v3; // eax@3
  LPHEAPLIST32 v4; // eax@5
  char *v5; // esi@7
  int v6; // edi@7
  LARGE_INTEGER SectionOffset; // [sp+Ch] [bp-10h]@3
  ULONG ViewSize; // [sp+14h] [bp-8h]@3
  int v10; // [sp+18h] [bp-4h]@1

  v2 = lphl;
  v10 = 0;
  if ( !lphl || lphl->dwSize != 16 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lphl = 0;
  v3 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lphl,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  v4 = lphl;
  if ( lphl->dwSize )
  {
    v5 = (char *)lphl + lphl[1].dwSize;
    v2->dwSize = *(_DWORD *)v5;
    v5 += 4;
    v6 = (int)&v2->th32ProcessID;
    *(_DWORD *)v6 = *(_DWORD *)v5;
    v5 += 4;
    v6 += 4;
    *(_DWORD *)v6 = *(_DWORD *)v5;
    *(_DWORD *)(v6 + 4) = *((_DWORD *)v5 + 1);
    v10 = 1;
    v4[2].dwSize = 1;
  }
  else
  {
    memset(&v2->th32ProcessID, 0, v2->dwSize - 4);
    RtlSetLastWin32Error(18);
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lphl);
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E70FE1) --------------------------------------------------------
BOOL __stdcall Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl)
{
  LPHEAPLIST32 v2; // edi@1
  BOOL v3; // esi@1
  NTSTATUS v4; // eax@3
  SIZE_T v5; // ecx@5
  char *v6; // esi@6
  int v7; // edi@6
  LARGE_INTEGER SectionOffset; // [sp+8h] [bp-Ch]@3
  ULONG ViewSize; // [sp+10h] [bp-4h]@3

  v2 = lphl;
  v3 = 0;
  if ( !lphl || lphl->dwSize != 16 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  SectionOffset = 0i64;
  ViewSize = 0;
  lphl = 0;
  v4 = NtMapViewOfSection(
         hSnapshot,
         (HANDLE)0xFFFFFFFF,
         (PVOID *)&lphl,
         0,
         0,
         &SectionOffset,
         &ViewSize,
         ViewShare,
         0,
         4u);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = lphl[2].dwSize;
  if ( v5 >= lphl->dwSize )
  {
    RtlSetLastWin32Error(18);
  }
  else
  {
    v6 = (char *)&lphl[v5] + lphl[1].dwSize;
    lphl[2].dwSize = v5 + 1;
    v2->dwSize = *(_DWORD *)v6;
    v6 += 4;
    v7 = (int)&v2->th32ProcessID;
    *(_DWORD *)v7 = *(_DWORD *)v6;
    v6 += 4;
    v7 += 4;
    *(_DWORD *)v7 = *(_DWORD *)v6;
    *(_DWORD *)(v7 + 4) = *((_DWORD *)v6 + 1);
    v3 = 1;
  }
  NtUnmapViewOfSection((HANDLE)0xFFFFFFFF, lphl);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E71079) --------------------------------------------------------
BOOL __stdcall Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID, ULONG_PTR th32HeapID)
{
  LPHEAPENTRY32 v3; // esi@1
  PDEBUG_BUFFER v4; // eax@4
  PDEBUG_BUFFER v5; // ebx@4
  unsigned int v6; // edi@5
  unsigned int v7; // eax@12
  int v8; // edx@13
  unsigned int v9; // ecx@18
  int v10; // eax@21
  unsigned int v11; // edx@24
  int v12; // eax@25
  unsigned int v13; // eax@29
  int v14; // ecx@30
  int v15; // edx@34
  int v16; // edi@35
  __int16 v17; // cx@39
  ULONG v19; // [sp+Ch] [bp-14h]@5
  BOOL v20; // [sp+10h] [bp-10h]@1
  struct _DEBUG_BUFFER *v21; // [sp+14h] [bp-Ch]@4
  unsigned int v22; // [sp+18h] [bp-8h]@5
  signed int v23; // [sp+1Ch] [bp-4h]@5
  unsigned int v24; // [sp+1Ch] [bp-4h]@12
  ULONG lphea; // [sp+28h] [bp+8h]@3
  LPHEAPENTRY32 lpheb; // [sp+28h] [bp+8h]@14

  v20 = 0;
  v3 = lphe;
  if ( !lphe || lphe->dwSize != 36 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  lphea = 0x400000;
  while ( 1 )
  {
    v4 = RtlCreateQueryDebugBuffer(lphea, 0);
    v5 = v4;
    v21 = v4;
    if ( !v4 )
    {
      BaseSetLastNTError(-1073741823);
      return 0;
    }
    v6 = (unsigned int)v4->SectionBase;
    v22 = (unsigned int)v4->SectionBase;
    v19 = v4->SectionSize;
    v23 = RtlQueryProcessDebugInformation(th32ProcessID, 0x14u, v4);
    if ( v23 != -1073741801 )
      break;
    if ( 2 * lphea <= lphea )
    {
      v23 = -1073741789;
      break;
    }
    lphea *= 2;
    RtlDestroyQueryDebugBuffer(v5);
  }
  if ( v23 >= 0 )
  {
    v7 = (unsigned int)v5->HeapInformation;
    v24 = v7;
    if ( v6 > v7 )
      goto LABEL_16;
    v8 = v7 + 68;
    if ( v7 + 68 < v7 )
      goto LABEL_16;
    lpheb = (LPHEAPENTRY32)(v6 + v19);
    if ( v6 + v19 < v6 || v8 > v6 + v19 )
      goto LABEL_16;
    v9 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 > 1u )
    {
      if ( v9 << 6 < v9 )
        goto LABEL_16;
      if ( v22 > v8 )
        goto LABEL_16;
      v10 = v8 + ((v9 - 1) << 6);
      if ( v10 < (unsigned int)v8 || v10 > (unsigned int)lpheb )
        goto LABEL_16;
      v7 = v24;
    }
    v11 = 0;
    if ( v9 )
    {
      v12 = v7 + 4;
      while ( *(_DWORD *)v12 != th32HeapID )
      {
        ++v11;
        v12 += 64;
        if ( v11 >= v9 )
          goto LABEL_48;
      }
      v13 = *(_DWORD *)(v12 + 60);
      if ( v22 > v13 )
        goto LABEL_16;
      v14 = v13 + 16;
      if ( v13 + 16 < v13 )
        goto LABEL_16;
      if ( v14 > (unsigned int)lpheb )
      {
        v5 = v21;
LABEL_16:
        RtlDestroyQueryDebugBuffer(v5);
LABEL_17:
        BaseSetLastNTError(-1073741762);
        return 0;
      }
      v3->dwResvd = 0;
      v3->dwLockCount = 0;
      v3->th32ProcessID = th32ProcessID;
      v3->th32HeapID = th32HeapID;
      v3->hHandle = (HANDLE)th32HeapID;
      if ( *(_BYTE *)(v13 + 4) & 2 )
      {
        v15 = (v11 << 6) + v24 + 12;
        while ( 1 )
        {
          v16 = *(_DWORD *)(v14 - 4) + *(_WORD *)v15;
          ++v3->dwResvd;
          v13 += 16;
          v14 += 16;
          v3->dwAddress = v16;
          if ( v22 > v13 || v14 < v13 || v14 > (unsigned int)lpheb )
            break;
          if ( !(*(_BYTE *)(v14 - 12) & 2) )
            goto LABEL_39;
        }
        RtlDestroyQueryDebugBuffer(v21);
        goto LABEL_17;
      }
LABEL_39:
      v17 = *(_WORD *)(v13 + 4);
      if ( v17 & 0xF1 || *(_WORD *)(v13 + 4) & 0x200 )
      {
        v3->dwFlags = 1;
      }
      else if ( v17 & 0x20 )
      {
        v3->dwFlags = 4;
      }
      else if ( *(_WORD *)(v13 + 4) & 0x100 )
      {
        v3->dwFlags = 2;
      }
      v5 = v21;
      v3->dwBlockSize = *(_DWORD *)v13;
      v20 = 1;
    }
LABEL_48:
    RtlDestroyQueryDebugBuffer(v5);
    return v20;
  }
  RtlDestroyQueryDebugBuffer(v5);
  BaseSetLastNTError(v23);
  return 0;
}

//----- (77E71264) --------------------------------------------------------
BOOL __stdcall Heap32Next(LPHEAPENTRY32 lphe)
{
  LPHEAPENTRY32 v1; // esi@1
  PDEBUG_BUFFER v2; // eax@4
  ULONG v3; // ebx@5
  signed int v4; // edi@5
  unsigned int v5; // ecx@12
  int v6; // edx@13
  int v7; // ebx@14
  unsigned int v8; // edi@18
  int v9; // eax@21
  unsigned int v10; // ebx@24
  int v11; // eax@25
  DWORD v12; // eax@30
  int v13; // edx@30
  int v14; // ecx@31
  int v15; // edi@32
  __int16 v16; // ax@43
  int v18; // [sp+10h] [bp-Ch]@14
  unsigned int Size; // [sp+14h] [bp-8h]@3
  ULONG Sizea; // [sp+14h] [bp-8h]@35
  unsigned int v21; // [sp+18h] [bp-4h]@5
  LPHEAPENTRY32 lphea; // [sp+24h] [bp+8h]@4

  v1 = lphe;
  if ( !lphe || lphe->dwSize != 36 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
  Size = 0x400000;
  while ( 1 )
  {
    v2 = RtlCreateQueryDebugBuffer(Size, 0);
    lphea = (LPHEAPENTRY32)v2;
    if ( !v2 )
    {
      BaseSetLastNTError(-1073741823);
      return 0;
    }
    v3 = v2->SectionSize;
    v21 = (unsigned int)v2->SectionBase;
    v4 = RtlQueryProcessDebugInformation(v1->th32ProcessID, 0x14u, v2);
    if ( v4 != -1073741801 )
      break;
    if ( 2 * Size <= Size )
    {
      v4 = -1073741789;
      break;
    }
    Size *= 2;
    RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
  }
  if ( v4 < 0 )
  {
    RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
    BaseSetLastNTError(v4);
    return 0;
  }
  v5 = lphea[1].dwLockCount;
  if ( v21 > v5 || (v6 = v5 + 68, v5 + 68 < v5) || (v7 = v21 + v3, v18 = v7, v7 < v21) || v6 > (unsigned int)v7 )
  {
    RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
LABEL_17:
    BaseSetLastNTError(-1073741762);
    return 0;
  }
  v8 = *(_DWORD *)v5;
  if ( *(_DWORD *)v5 > 1u )
  {
    if ( v8 << 6 < v8 || v21 > v6 || (v9 = v6 + ((v8 - 1) << 6), v9 < (unsigned int)v6) || v9 > (unsigned int)v7 )
    {
LABEL_23:
      RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
      goto LABEL_17;
    }
  }
  v10 = 0;
  if ( !v8 )
    goto LABEL_29;
  v11 = v5 + 4;
  do
  {
    if ( *(_DWORD *)v11 == v1->th32HeapID )
      break;
    ++v10;
    v11 += 64;
  }
  while ( v10 < v8 );
  if ( v10 >= v8 || (++v1->dwResvd, v12 = v1->dwResvd, v13 = v5 + (v10 << 6), v12 >= *(_DWORD *)(v13 + 28)) )
  {
LABEL_29:
    RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
    RtlSetLastWin32Error(18);
    return 0;
  }
  v14 = *(_DWORD *)(v13 + 64) + 16 * v12;
  if ( v21 > v14 )
    goto LABEL_23;
  v15 = v14 + 16;
  if ( v14 + 16 < (unsigned int)v14 || v15 > (unsigned int)v18 )
    goto LABEL_23;
  if ( *(_BYTE *)(v14 + 4) & 2 )
  {
    Sizea = v14 + 16;
    while ( 1 )
    {
      v1->dwAddress = *(_DWORD *)(v15 - 4) + *(_WORD *)(v13 + 12);
      if ( v12 >= *(_DWORD *)(lphea[1].dwLockCount + (v10 << 6) + 28) )
        goto LABEL_29;
      ++v12;
      v14 += 16;
      v15 = Sizea + 16;
      v1->dwResvd = v12;
      Sizea += 16;
      if ( v21 > v14 || v15 < (unsigned int)v14 || v15 > (unsigned int)v18 )
        goto LABEL_23;
      if ( !(*(_BYTE *)(v15 - 12) & 2) )
        goto LABEL_43;
    }
  }
  v1->dwAddress += v1->dwBlockSize;
LABEL_43:
  v1->dwBlockSize = *(_DWORD *)v14;
  v16 = *(_WORD *)(v14 + 4);
  if ( v16 & 0xF1 || *(_WORD *)(v14 + 4) & 0x200 )
  {
    v1->dwFlags = 1;
  }
  else if ( v16 & 0x20 )
  {
    v1->dwFlags = 4;
  }
  else if ( *(_WORD *)(v14 + 4) & 0x100 )
  {
    v1->dwFlags = 2;
  }
  RtlDestroyQueryDebugBuffer((PDEBUG_BUFFER)lphea);
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E71469) --------------------------------------------------------
BOOL __stdcall Toolhelp32ReadProcessMemory(DWORD th32ProcessID, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T cbRead, SIZE_T *lpNumberOfBytesRead)
{
  BOOL result; // eax@1
  BOOL v6; // esi@1
  BOOL v7; // edi@2

  result = (BOOL)OpenProcess(0x10u, 0, th32ProcessID);
  v6 = result;
  if ( result )
  {
    v7 = ReadProcessMemory((HANDLE)result, lpBaseAddress, lpBuffer, cbRead, lpNumberOfBytesRead);
    CloseHandle((HANDLE)v6);
    result = v7;
  }
  return result;
}

//----- (77E714A9) --------------------------------------------------------
BOOL __stdcall Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
  BOOL v2; // ebx@3
  BOOL result; // eax@3
  MODULEENTRY32W me; // [sp+8h] [bp-42Ch]@3

  if ( lpme && lpme->dwSize >= 0x224 )
  {
    me.dwSize = 1064;
    v2 = Module32FirstW(hSnapshot, &me);
    WideCharToMultiByte(0, 0, me.szExePath, -1, lpme->szExePath, 260, 0, 0);
    WideCharToMultiByte(0, 0, me.szModule, -1, lpme->szModule, 256, 0, 0);
    lpme->th32ModuleID = me.th32ModuleID;
    lpme->th32ProcessID = me.th32ProcessID;
    lpme->GlblcntUsage = me.GlblcntUsage;
    lpme->ProccntUsage = me.ProccntUsage;
    lpme->modBaseAddr = me.modBaseAddr;
    lpme->modBaseSize = me.modBaseSize;
    lpme->hModule = me.hModule;
    result = v2;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E71592) --------------------------------------------------------
BOOL __stdcall Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme)
{
  BOOL v2; // ebx@3
  BOOL result; // eax@3
  MODULEENTRY32W me; // [sp+8h] [bp-42Ch]@3

  if ( lpme && lpme->dwSize >= 0x224 )
  {
    me.dwSize = 1064;
    v2 = Module32NextW(hSnapshot, &me);
    WideCharToMultiByte(0, 0, me.szModule, -1, lpme->szModule, 256, 0, 0);
    WideCharToMultiByte(0, 0, me.szExePath, -1, lpme->szExePath, 260, 0, 0);
    lpme->th32ModuleID = me.th32ModuleID;
    lpme->GlblcntUsage = me.GlblcntUsage;
    lpme->ProccntUsage = me.ProccntUsage;
    lpme->modBaseAddr = me.modBaseAddr;
    lpme->modBaseSize = me.modBaseSize;
    lpme->hModule = me.hModule;
    result = v2;
  }
  else
  {
    RtlSetLastWin32Error(13);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E71672) --------------------------------------------------------
signed int __stdcall ConvertWin32FHToDos(int a1)
{
  signed int v1; // esi@1

  RtlAcquireSRWLockExclusive(BaseLZTableLock);
  v1 = 0;
  do
  {
    if ( !fhWin32File[v1] )
      break;
    ++v1;
  }
  while ( v1 < 16 );
  if ( v1 >= 16 )
    v1 = -5;
  else
    fhWin32File[v1] = a1;
  RtlReleaseSRWLockExclusive(BaseLZTableLock);
  return v1;
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77EA6D08: using guessed type int BaseLZTableLock[2];
// 77EA6F60: using guessed type int fhWin32File[];

//----- (77E716BF) --------------------------------------------------------
int __stdcall ConvertDosFHToWin32(unsigned int a1)
{
  int result; // eax@2

  if ( a1 > 0xF || (result = fhWin32File[a1]) == 0 )
    result = a1;
  return result;
}
// 77EA6F60: using guessed type int fhWin32File[];

//----- (77E716E2) --------------------------------------------------------
INT __stdcall LZInit(INT hfSource)
{
  signed int v2; // eax@7
  int v3; // ecx@7
  signed int v4; // edi@12
  HGLOBAL v5; // eax@12
  void *v6; // esi@12
  INT v7; // edi@14
  LPVOID v8; // eax@15
  signed int v9; // [sp-Ch] [bp-2Ch]@13
  int v10; // [sp+4h] [bp-1Ch]@1
  int v11; // [sp+8h] [bp-18h]@1
  char v12; // [sp+10h] [bp-10h]@5
  int v13; // [sp+14h] [bp-Ch]@18
  int v14; // [sp+18h] [bp-8h]@18

  v10 = 0;
  if ( GetHdr((int)&v11, hfSource, (int)&v10) != 1 )
  {
    if ( v10 >= 14 )
      return -1;
    goto LABEL_22;
  }
  if ( IsCompressed((int)&v11) == 1 )
  {
    if ( v12 != 65 )
      return -8;
    RtlAcquireSRWLockExclusive(BaseLZTableLock);
    v2 = dword_77EA6F1C;
    v3 = dword_77EA6F1C;
    while ( rghLZFileTable[v2] )
    {
      ++v2;
      dword_77EA6F1C = v2;
      if ( v2 >= 16 )
      {
        v2 = 0;
        dword_77EA6F1C = 0;
      }
      if ( v2 == v3 )
      {
        v7 = -5;
        goto LABEL_21;
      }
    }
    v4 = v2;
    v5 = GlobalAlloc(0x42u, 0x30u);
    v6 = v5;
    if ( v5 )
    {
      v8 = GlobalLock(v5);
      if ( v8 )
      {
        *(_DWORD *)v8 = hfSource;
        *((_BYTE *)v8 + 4) = v12;
        *((_WORD *)v8 + 3) = 0;
        *((_DWORD *)v8 + 2) = v13;
        *((_DWORD *)v8 + 3) = v14;
        *((_DWORD *)v8 + 10) = 0;
        *((_DWORD *)v8 + 11) = 0;
        rghLZFileTable[v4] = (int)v6;
        GlobalUnlock(v6);
        ++dword_77EA6F1C;
        if ( dword_77EA6F1C >= 16 )
          dword_77EA6F1C = 0;
        v7 = v4 + 1024;
        goto LABEL_21;
      }
      GlobalFree(v6);
      v9 = -6;
    }
    else
    {
      v9 = -5;
    }
    v7 = v9;
LABEL_21:
    RtlReleaseSRWLockExclusive(BaseLZTableLock);
    return v7;
  }
LABEL_22:
  if ( _llseek(hfSource, 0, 0) )
    return -1;
  return ConvertWin32FHToDos(hfSource);
}
// 77DE136C: using guessed type int __stdcall RtlAcquireSRWLockExclusive(_DWORD);
// 77DE1370: using guessed type int __stdcall RtlReleaseSRWLockExclusive(_DWORD);
// 77EA6D08: using guessed type int BaseLZTableLock[2];
// 77EA6F1C: using guessed type int dword_77EA6F1C;
// 77EA6F20: using guessed type int rghLZFileTable[];

//----- (77E7182E) --------------------------------------------------------
LONG __stdcall LZSeek(INT hFile, LONG lOffset, INT iOrigin)
{
  int v3; // eax@3
  void *v5; // edi@4
  LPVOID v6; // eax@4
  int v7; // esi@4
  bool v8; // sf@12
  LONG v9; // esi@12
  void *v11; // [sp-4h] [bp-Ch]@12

  if ( (unsigned int)hFile <= 0x40F )
  {
    if ( hFile < 1024 )
    {
      v3 = ConvertDosFHToWin32(hFile);
      return _llseek(v3, lOffset, iOrigin);
    }
    v5 = *(void **)&stru_77EA5F18.Data4[4 * hFile];
    v6 = GlobalLock(*(HGLOBAL *)&stru_77EA5F18.Data4[4 * hFile]);
    v7 = 0;
    if ( !v6 )
      return -6;
    if ( iOrigin )
    {
      if ( iOrigin == 1 )
      {
        v7 = *((_DWORD *)v6 + 10);
      }
      else
      {
        if ( iOrigin != 2 )
        {
          v11 = v5;
          goto LABEL_15;
        }
        v7 = *((_DWORD *)v6 + 2);
      }
    }
    v8 = lOffset + v7 < 0;
    v9 = lOffset + v7;
    v11 = v5;
    if ( !v8 )
    {
      *((_DWORD *)v6 + 10) = v9;
      GlobalUnlock(v5);
      return v9;
    }
LABEL_15:
    GlobalUnlock(v11);
    return -7;
  }
  return -1;
}
// 77EA5F18: using guessed type GUID stru_77EA5F18;

//----- (77E718B5) --------------------------------------------------------
INT __stdcall LZRead(INT hFile, CHAR *lpBuffer, INT cbRead)
{
  int v4; // eax@6
  LPVOID v5; // eax@7
  LPVOID v6; // edi@7
  int v7; // esi@9
  HLOCAL v8; // eax@10
  INT v9; // esi@12
  int v10; // ecx@14
  int v11; // eax@14
  int v12; // eax@14
  int v13; // ecx@14
  int v14; // eax@14
  int v15; // ebx@15
  __int16 v16; // cx@15
  int v17; // eax@15
  int v18; // edx@21
  int v19; // ecx@22
  int v20; // edx@22
  CHAR v21; // dl@28
  CHAR *v22; // ebx@28
  int v23; // edx@32
  int v24; // ebx@32
  int v25; // ecx@34
  int v26; // eax@37
  int v27; // edx@37
  bool v28; // sf@37
  unsigned __int8 v29; // of@37
  int v30; // ebx@37
  int v31; // ebx@40
  int v32; // eax@44
  signed int v34; // [sp-4h] [bp-24h]@11
  HGLOBAL hMem; // [sp+Ch] [bp-14h]@7
  INT v36; // [sp+10h] [bp-10h]@1
  int v37; // [sp+14h] [bp-Ch]@15
  int v38; // [sp+18h] [bp-8h]@26
  CHAR *v39; // [sp+1Ch] [bp-4h]@18
  INT hFilea; // [sp+28h] [bp+8h]@16
  CHAR *lpBuffera; // [sp+2Ch] [bp+Ch]@23

  v36 = 0;
  if ( (unsigned int)hFile > 0x40F )
    return -1;
  if ( cbRead < 0 )
    return -7;
  if ( hFile < 1024 )
  {
    v4 = ConvertDosFHToWin32(hFile);
    return _lread(v4, lpBuffer, cbRead);
  }
  hMem = *(HGLOBAL *)&stru_77EA5F18.Data4[4 * hFile];
  v5 = GlobalLock(*(HGLOBAL *)&stru_77EA5F18.Data4[4 * hFile]);
  v6 = v5;
  if ( !v5 )
    return -6;
  v7 = *((_DWORD *)v5 + 11);
  if ( !v7 )
  {
    v8 = InitGlobalBuffers(1024, 0x1080u, 1026);
    v7 = (int)v8;
    *((_DWORD *)v6 + 11) = v8;
    if ( !v8 )
    {
      v34 = -5;
LABEL_12:
      v9 = v34;
LABEL_13:
      GlobalUnlock(hMem);
      return v9;
    }
    v10 = *((_DWORD *)v8 + 1);
    v11 = *((_DWORD *)v8 + 11);
    *(_DWORD *)(v7 + 28) = 0;
    v12 = v10 + v11 + 1;
    v13 = *(_DWORD *)(v7 + 48);
    *(_DWORD *)(v7 + 8) = v12;
    *(_DWORD *)(v7 + 12) = v12;
    v14 = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 40) = 0;
    *(_DWORD *)(v7 + 20) = v14 + v13;
    *(_DWORD *)(v7 + 24) = v14;
  }
  v15 = *(_DWORD *)(v7 + 20) - *(_DWORD *)(v7 + 16);
  v16 = *((_WORD *)v6 + 3);
  v17 = *(_DWORD *)(v7 + 40) + *(_DWORD *)(v7 + 16) - *(_DWORD *)(v7 + 24);
  v37 = *(_DWORD *)(v7 + 20) - *(_DWORD *)(v7 + 16);
  if ( v16 & 1 )
  {
    hFilea = *((_DWORD *)v6 + 10) < v17;
  }
  else
  {
    *((_WORD *)v6 + 3) = v16 | 1;
    hFilea = 1;
  }
  v39 = lpBuffer;
  if ( cbRead > 0 )
  {
    while ( 1 )
    {
      v18 = *((_DWORD *)v6 + 10);
      if ( v18 >= *((_DWORD *)v6 + 2) )
        break;
      v19 = *(_DWORD *)(v7 + 24) - *(_DWORD *)(v7 + 16);
      v20 = v18 - v17;
      if ( v20 >= v15 )
        lpBuffera = (CHAR *)-1;
      else
        lpBuffera = (CHAR *)v20;
      if ( (signed int)lpBuffera >= 0 )
      {
        v38 = 0;
        while ( (signed int)lpBuffera < v19 && cbRead > 0 )
        {
          v21 = lpBuffera[*(_DWORD *)(v7 + 16)];
          v22 = v39++;
          ++lpBuffera;
          ++v38;
          --cbRead;
          *v22 = v21;
        }
        *((_DWORD *)v6 + 10) += v38;
        v36 += v38;
      }
      if ( cbRead <= 0 )
        break;
      v23 = *((_DWORD *)v6 + 10);
      v24 = *((_DWORD *)v6 + 2);
      if ( v23 < v24 )
      {
        if ( hFilea )
        {
          v25 = v23 - *(_DWORD *)(v7 + 32);
          if ( v23 - *(_DWORD *)(v7 + 32) < 0 )
            v25 = 0;
        }
        else
        {
          v25 = v17 + v37 + v19 - *(_DWORD *)(v7 + 32);
        }
        v26 = v23 + cbRead;
        v27 = v24 - 1;
        v29 = __OFSUB__(v26, v24 - 1);
        v28 = v26 - (v24 - 1) < 0;
        v30 = v26;
        if ( !(v28 ^ v29) )
          v30 = v27;
        if ( v25 >= v30 )
        {
          v31 = v26;
          if ( v26 >= v27 )
            v31 = v27;
        }
        else
        {
          v31 = v25;
        }
        *(_DWORD *)(v7 + 24) = *(_DWORD *)(v7 + 16);
        if ( *((_BYTE *)v6 + 4) != 65 )
        {
          v32 = -8;
LABEL_49:
          v9 = v32;
          goto LABEL_13;
        }
        v32 = LZDecode(*(_DWORD *)v6, -2, v31, hFilea, 1, v7);
        if ( v32 < 0 )
          goto LABEL_49;
        if ( *(_DWORD *)(v7 + 24) - *(_DWORD *)(v7 + 16) <= 0
          || (v17 = *(_DWORD *)(v7 + 40) - (*(_DWORD *)(v7 + 24) - *(_DWORD *)(v7 + 16)), *(_DWORD *)(v7 + 40) < v31) )
        {
          v34 = -3;
          goto LABEL_12;
        }
        hFilea = 0;
      }
      v15 = v37;
    }
  }
  GlobalUnlock(hMem);
  return v36;
}
// 77EA5F18: using guessed type GUID stru_77EA5F18;

//----- (77E71AC3) --------------------------------------------------------
void __stdcall LZCloseFile(unsigned int a1)
{
  int v1; // eax@3
  char *v2; // eax@5
  void *v3; // edi@5
  HANDLE *v4; // eax@5
  HANDLE *v5; // esi@5
  void *v6; // esi@6

  if ( a1 <= 0x40F )
  {
    if ( (signed int)a1 >= 1024 )
    {
      v2 = (char *)&stru_77EA5F18.Data4[4 * a1];
      v3 = *(void **)v2;
      *(_DWORD *)v2 = 0;
      v4 = (HANDLE *)GlobalLock(v3);
      v5 = v4;
      if ( v4 )
      {
        CloseHandle(*v4);
        v6 = v5[11];
        if ( v6 )
          FreeGlobalBuffers(v6);
        GlobalUnlock(v3);
        GlobalFree(v3);
      }
    }
    else
    {
      v1 = ConvertDosFHToWin32(a1);
      CloseHandle((HANDLE)v1);
      if ( (signed int)a1 < 16 )
        fhWin32File[a1] = 0;
    }
  }
}
// 77EA5F18: using guessed type GUID stru_77EA5F18;
// 77EA6F60: using guessed type int fhWin32File[];

//----- (77E71B3B) --------------------------------------------------------
void __stdcall LZClose(INT hFile)
{
  int v1; // eax@3
  char *v2; // eax@5
  void *v3; // edi@5
  HFILE *v4; // eax@5
  HFILE *v5; // esi@5
  void *v6; // esi@6

  if ( (unsigned int)hFile <= 0x40F )
  {
    if ( hFile >= 1024 )
    {
      v2 = (char *)&stru_77EA5F18.Data4[4 * hFile];
      v3 = *(void **)v2;
      *(_DWORD *)v2 = 0;
      v4 = (HFILE *)GlobalLock(v3);
      v5 = v4;
      if ( v4 )
      {
        _lclose(*v4);
        v6 = (void *)v5[11];
        if ( v6 )
          FreeGlobalBuffers(v6);
        GlobalUnlock(v3);
        GlobalFree(v3);
      }
    }
    else
    {
      v1 = ConvertDosFHToWin32(hFile);
      _lclose(v1);
      if ( hFile < 16 )
        fhWin32File[hFile] = 0;
    }
  }
}
// 77EA5F18: using guessed type GUID stru_77EA5F18;
// 77EA6F60: using guessed type int fhWin32File[];

//----- (77E71BB3) --------------------------------------------------------
INT __stdcall GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer)
{
  HFILE v2; // eax@1
  HFILE v3; // edi@1
  int v5; // [sp+Ch] [bp-A8h]@3
  int v6; // [sp+10h] [bp-A4h]@1
  struct _OFSTRUCT ReOpenBuff; // [sp+14h] [bp-A0h]@1
  int v8; // [sp+9Ch] [bp-18h]@3
  int v9; // [sp+A5h] [bp-Fh]@9

  v6 = 0;
  v2 = OpenFile(lpszSource, &ReOpenBuff, 0);
  v3 = v2;
  if ( v2 == -1 )
    return -7;
  v5 = GetHdr((int)&v8, v2, (int)&v6);
  if ( v5 != 1 && v6 >= 14 )
  {
    _lclose(v3);
    return -7;
  }
  _lclose(v3);
  if ( RtlStringCchCopyA(lpszBuffer, 0x104u, lpszSource) < 0 )
    return -7;
  if ( v5 == 1 && IsCompressed((int)&v8) == 1 )
    MakeExpandedName((int)lpszBuffer, v9);
  return 1;
}

//----- (77E71C6F) --------------------------------------------------------
INT __stdcall GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer)
{
  INT v3; // ebx@3
  CHAR *v4; // eax@6
  char v5; // cl@7
  STRING DestinationString; // [sp+8h] [bp-11Ch]@1
  UNICODE_STRING SourceString; // [sp+10h] [bp-114h]@1
  CHAR szSource; // [sp+18h] [bp-10Ch]@1
  _BYTE v10[3]; // [sp+19h] [bp-10Bh]@8

  SourceString.Buffer = lpszSource;
  SourceString.Length = 2 * wcslen(lpszSource);
  SourceString.MaximumLength = SourceString.Length + 2;
  DestinationString.Buffer = &szSource;
  DestinationString.MaximumLength = 260;
  if ( RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0) < 0 )
    return -5;
  v3 = GetExpandedNameA(&szSource, (LPSTR)lpszBuffer);
  if ( v3 != -1 )
  {
    v3 = RtlStringCchCopyA(&szSource, 0x106u, (const char *)lpszBuffer);
    if ( v3 < 0 )
      return -7;
    v4 = &szSource;
    do
      v5 = *v4++;
    while ( v5 );
    DestinationString.Length = (_WORD)v4 - (unsigned int)v10;
    DestinationString.MaximumLength = (_WORD)v4 - (unsigned int)v10 + 1;
    SourceString.Buffer = lpszBuffer;
    SourceString.MaximumLength = 260;
    if ( RtlAnsiStringToUnicodeString(&SourceString, &DestinationString, 0) < 0 )
      return -5;
  }
  return v3;
}

//----- (77E71D94) --------------------------------------------------------
int __stdcall LZCreateFileW(wchar_t *pszSrc, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, wchar_t *pszDest)
{
  int result; // eax@2
  HANDLE v6; // ebx@3
  signed int v7; // esi@8
  INT v8; // edi@11

  if ( RtlStringCchCopyW(&Dst, 0x106u, pszSrc) >= 0 )
  {
    v6 = CreateFileW(&Dst, dwDesiredAccess, dwShareMode, 0, dwCreationDisposition, 0x80u, 0);
    if ( v6 != (HANDLE)-1
      || GetLastError() == 2
      && (MakeCompressedNameW(&Dst, 0x106u),
          v6 = CreateFileW(&Dst, dwDesiredAccess, dwShareMode, 0, dwCreationDisposition, 0x80u, 0),
          v6 != (HANDLE)-1) )
    {
      if ( dwCreationDisposition == 3 )
      {
        v8 = LZInit((INT)v6);
        if ( v8 < 0 )
          CloseHandle(v6);
        if ( pszDest && RtlStringCchCopyW(pszDest, 0x104u, &Dst) < 0 )
          result = -7;
        else
          result = v8;
      }
      else
      {
        v7 = ConvertWin32FHToDos((int)v6);
        if ( v7 == -5 )
          CloseHandle(v6);
        result = v7;
      }
    }
    else
    {
      result = -1;
    }
  }
  else
  {
    result = -7;
  }
  return result;
}

//----- (77E71E69) --------------------------------------------------------
INT __stdcall LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
  int v4; // esi@3
  signed int v5; // edi@8
  char pszDest; // [sp+Ch] [bp-10Ch]@1

  if ( RtlStringCchCopyA(&pszDest, 0x106u, lpFileName) < 0 )
    return -7;
  v4 = OpenFile(&pszDest, lpReOpenBuf, wStyle);
  if ( v4 == -1 )
  {
    if ( lpReOpenBuf->nErrCode != 2 )
      return -1;
    MakeCompressedName(&pszDest, 0x106u);
    v4 = OpenFile(&pszDest, lpReOpenBuf, wStyle);
    if ( v4 == -1 )
      return -1;
  }
  if ( wStyle & 0xFF0F )
  {
    v5 = ConvertWin32FHToDos(v4);
    if ( v5 != -5 )
      return v5;
    goto LABEL_11;
  }
  v5 = LZInit(v4);
  if ( v5 < 0 )
LABEL_11:
    _lclose(v4);
  return v5;
}

//----- (77E71F36) --------------------------------------------------------
INT __stdcall LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle)
{
  INT result; // eax@2
  STRING DestinationString; // [sp+4h] [bp-118h]@1
  UNICODE_STRING SourceString; // [sp+Ch] [bp-110h]@1
  CHAR FileName; // [sp+14h] [bp-108h]@1

  SourceString.Buffer = lpFileName;
  SourceString.Length = 2 * wcslen(lpFileName);
  SourceString.MaximumLength = SourceString.Length + 2;
  DestinationString.Buffer = &FileName;
  DestinationString.MaximumLength = 260;
  if ( RtlUnicodeStringToAnsiString(&DestinationString, &SourceString, 0) >= 0 )
    result = LZOpenFileA(&FileName, lpReOpenBuf, wStyle);
  else
    result = -5;
  return result;
}

//----- (77E71FDD) --------------------------------------------------------
int __stdcall sub_77E71FDD(int a1, int a2, PCWSTR SourceString, int a4, int a5, int a6)
{
  LSA_UNICODE_STRING DestinationString; // [sp+8h] [bp-10h]@1
  LSA_UNICODE_STRING String2; // [sp+10h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, *(PCWSTR *)(a5 + 4));
  RtlInitUnicodeString(&String2, SourceString);
  if ( RtlEqualUnicodeString(&DestinationString, &String2, 1u) )
    *(_DWORD *)a5 = 1;
  return 0;
}

//----- (77E72027) --------------------------------------------------------
BOOL __stdcall ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
{
  HANDLE v3; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v5; // esi@3
  char v6; // cl@9
  char v7; // cl@26
  int OutputBuffer; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  DWORD v10; // [sp+10h] [bp-18h]@1
  DWORD v11; // [sp+14h] [bp-14h]@1
  int v12; // [sp+18h] [bp-10h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-Ch]@3
  HANDLE hObject; // [sp+24h] [bp-4h]@1

  OutputBuffer = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v3 = CreateEventA(0, 1, 0, 0);
  hObject = v3;
  if ( v3 )
  {
    v5 = NtDeviceIoControlFile(hFile, v3, 0, 0, &IoStatusBlock, 0x1B006Cu, 0, 0, &OutputBuffer, 0x14u);
    if ( v5 == 259 )
    {
      v5 = NtWaitForSingleObject(v3, 0, 0);
      if ( v5 >= 0 )
        v5 = IoStatusBlock.u.Status;
    }
    if ( (v5 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v3);
      BaseSetLastNTError(v5);
      result = 0;
    }
    else
    {
      if ( lpStat )
      {
        v6 = v9;
        if ( v9 & 1 )
          lpStat->fReserved |= 1u;
        else
          lpStat->fReserved &= 0xFFFFFFFE;
        if ( v6 & 2 )
          lpStat->fReserved |= 2u;
        else
          lpStat->fReserved &= 0xFFFFFFFD;
        if ( v6 & 4 )
          lpStat->fReserved |= 4u;
        else
          lpStat->fReserved &= 0xFFFFFFFB;
        if ( v6 & 8 )
          lpStat->fReserved |= 8u;
        else
          lpStat->fReserved &= 0xFFFFFFF7;
        if ( v6 & 0x10 )
          lpStat->fReserved |= 0x10u;
        else
          lpStat->fReserved &= 0xFFFFFFEF;
        lpStat->fReserved = lpStat->fReserved & 0xFFFFFF9F | 32 * (v12 & 1 | 2 * (BYTE1(v12) & 1));
        lpStat->cbInQue = v10;
        lpStat->cbOutQue = v11;
      }
      if ( lpErrors )
      {
        v7 = OutputBuffer;
        *lpErrors = 0;
        if ( v7 & 1 )
          *lpErrors = 16;
        if ( v7 & 2 )
          *lpErrors |= 8u;
        if ( v7 & 4 )
          *lpErrors |= 2u;
        if ( v7 & 8 )
          *lpErrors |= 1u;
        if ( v7 & 0x10 )
          *lpErrors |= 4u;
      }
      CloseHandle(hObject);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7216F) --------------------------------------------------------
BOOL __stdcall SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
{
  HANDLE v4; // ebx@6
  NTSTATUS v5; // edi@7
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-10h]@7
  DWORD InputBuffer; // [sp+10h] [bp-8h]@1
  DWORD v8; // [sp+14h] [bp-4h]@1

  InputBuffer = 0;
  v8 = 0;
  if ( dwOutQueue != -1 && 2 * (dwOutQueue >> 1) != dwOutQueue || dwInQueue != -1 && 2 * (dwInQueue >> 1) != dwInQueue )
  {
    RtlSetLastWin32Error(13);
    return 0;
  }
  InputBuffer = dwInQueue;
  v8 = dwOutQueue;
  v4 = CreateEventA(0, 1, 0, 0);
  if ( !v4 )
    return 0;
  v5 = NtDeviceIoControlFile(hFile, v4, 0, 0, &IoStatusBlock, 0x1B0008u, &InputBuffer, 8u, 0, 0);
  if ( v5 == 259 )
  {
    v5 = NtWaitForSingleObject(v4, 0, 0);
    if ( v5 >= 0 )
      v5 = IoStatusBlock.u.Status;
  }
  if ( (v5 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(v4);
    BaseSetLastNTError(v5);
    return 0;
  }
  CloseHandle(v4);
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E72238) --------------------------------------------------------
BOOL __stdcall EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
{
  ULONG v2; // edi@2
  HANDLE v3; // ebx@11
  NTSTATUS v4; // edi@12
  BOOL result; // eax@17
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-8h]@12

  switch ( dwFunc )
  {
    case 1u:
      v2 = 1769528;
      goto LABEL_11;
    case 2u:
      v2 = 1769532;
      goto LABEL_11;
    case 3u:
      v2 = 1769520;
      goto LABEL_11;
    case 4u:
      v2 = 1769524;
      goto LABEL_11;
    case 5u:
      v2 = 1769508;
      goto LABEL_11;
    case 6u:
      v2 = 1769512;
      goto LABEL_11;
    case 7u:
      v2 = 1769516;
      goto LABEL_11;
    case 8u:
      v2 = 1769488;
      goto LABEL_11;
    case 9u:
      v2 = 1769492;
LABEL_11:
      v3 = CreateEventA(0, 1, 0, 0);
      if ( !v3 )
        goto LABEL_19;
      v4 = NtDeviceIoControlFile(hFile, v3, 0, 0, &IoStatusBlock, v2, 0, 0, 0, 0);
      if ( v4 == 259 )
      {
        v4 = NtWaitForSingleObject(v3, 0, 0);
        if ( v4 >= 0 )
          v4 = IoStatusBlock.u.Status;
      }
      if ( (v4 & 0xC0000000) == -1073741824 )
      {
        CloseHandle(v3);
        BaseSetLastNTError(v4);
LABEL_19:
        result = 0;
      }
      else
      {
        CloseHandle(v3);
        result = 1;
      }
      return result;
    default:
      RtlSetLastWin32Error(87);
      goto LABEL_19;
  }
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E72335) --------------------------------------------------------
BOOL __stdcall GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
{
  HANDLE v2; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v4; // edi@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@3

  v2 = CreateEventA(0, 1, 0, 0);
  if ( v2 )
  {
    v4 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B0040u, 0, 0, lpEvtMask, 4u);
    if ( v4 == 259 )
    {
      v4 = NtWaitForSingleObject(v2, 0, 0);
      if ( v4 >= 0 )
        v4 = IoStatusBlock.u.Status;
    }
    if ( (v4 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v2);
      BaseSetLastNTError(v4);
      result = 0;
    }
    else
    {
      CloseHandle(v2);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E723BE) --------------------------------------------------------
BOOL __stdcall GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
{
  HANDLE v2; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v4; // edi@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@3

  v2 = CreateEventA(0, 1, 0, 0);
  if ( v2 )
  {
    v4 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B0068u, 0, 0, lpModemStat, 4u);
    if ( v4 == 259 )
    {
      v4 = NtWaitForSingleObject(v2, 0, 0);
      if ( v4 >= 0 )
        v4 = IoStatusBlock.u.Status;
    }
    if ( (v4 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v2);
      BaseSetLastNTError(v4);
      result = 0;
    }
    else
    {
      CloseHandle(v2);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E72447) --------------------------------------------------------
BOOL __stdcall GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
{
  bool v2; // zf@1
  HANDLE v3; // ebx@3
  NTSTATUS v5; // edi@5
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-Ch]@5
  size_t Size; // [sp+14h] [bp-4h]@1

  v2 = lpCommProp->dwProvSpec1 == -415435474;
  Size = 64;
  if ( v2 )
    Size = lpCommProp->wPacketLength;
  memset(lpCommProp, 0, Size);
  v3 = CreateEventA(0, 1, 0, 0);
  if ( !v3 )
    return 0;
  v5 = NtDeviceIoControlFile(hFile, v3, 0, 0, &IoStatusBlock, 0x1B0074u, 0, 0, lpCommProp, Size);
  if ( v5 == 259 )
  {
    v5 = NtWaitForSingleObject(v3, 0, 0);
    if ( v5 >= 0 )
      v5 = IoStatusBlock.u.Status;
  }
  if ( (v5 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(v3);
    BaseSetLastNTError(v5);
    return 0;
  }
  CloseHandle(v3);
  return 1;
}

//----- (77E724F4) --------------------------------------------------------
BOOL __stdcall GetCommState(HANDLE hFile, LPDCB lpDCB)
{
  LPDCB v2; // esi@1
  HANDLE v3; // eax@1
  NTSTATUS v5; // ebx@16
  int v6; // edx@22
  int v7; // eax@26
  int v8; // eax@38
  int v9; // eax@39
  int v10; // eax@40
  unsigned int v11; // eax@43
  unsigned int v12; // eax@50
  HANDLE v13; // ST24_4@54
  int v14; // [sp+8h] [bp-2Ch]@16
  int v15; // [sp+Ch] [bp-28h]@26
  WORD v16; // [sp+10h] [bp-24h]@54
  WORD v17; // [sp+14h] [bp-20h]@54
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-1Ch]@3
  char v19; // [sp+20h] [bp-14h]@11
  char v20; // [sp+21h] [bp-13h]@16
  char v21; // [sp+23h] [bp-11h]@16
  char v22; // [sp+24h] [bp-10h]@16
  char v23; // [sp+25h] [bp-Fh]@16
  DWORD OutputBuffer; // [sp+28h] [bp-Ch]@3
  HANDLE Handle; // [sp+2Ch] [bp-8h]@1
  NTSTATUS v26; // [sp+30h] [bp-4h]@3

  v2 = lpDCB;
  memset(lpDCB, 0, 0x1Cu);
  v2->fDummy2 |= 1u;
  v2->DCBlength = 28;
  v3 = CreateEventA(0, 1, 0, 0);
  Handle = v3;
  if ( !v3 )
    return 0;
  v26 = NtDeviceIoControlFile(hFile, v3, 0, 0, &IoStatusBlock, 0x1B0050u, 0, 0, &OutputBuffer, 4u);
  if ( v26 == 259 )
  {
    v26 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v26 >= 0 )
      v26 = IoStatusBlock.u.Status;
  }
  if ( (v26 & 0xC0000000) == -1073741824 )
    goto LABEL_57;
  v2->BaudRate = OutputBuffer;
  v26 = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B0054u, 0, 0, &lpDCB, 3u);
  if ( v26 == 259 )
  {
    v26 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v26 >= 0 )
      v26 = IoStatusBlock.u.Status;
  }
  if ( (v26 & 0xC0000000) == -1073741824 )
    goto LABEL_57;
  v2->Parity = BYTE1(lpDCB);
  v2->ByteSize = BYTE2(lpDCB);
  v2->StopBits = (unsigned __int8)lpDCB;
  v26 = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B0058u, 0, 0, &v19, 6u);
  if ( v26 == 259 )
  {
    v26 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v26 >= 0 )
      v26 = IoStatusBlock.u.Status;
  }
  if ( (v26 & 0xC0000000) == -1073741824 )
  {
LABEL_57:
    CloseHandle(Handle);
    BaseSetLastNTError(v26);
    return 0;
  }
  v2->XonChar = v22;
  v2->XoffChar = v23;
  v2->ErrorChar = v20;
  v2->EofChar = v19;
  v2->EvtChar = v21;
  v5 = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B0060u, 0, 0, &v14, 0x10u);
  if ( v5 == 259 )
  {
    v5 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v5 >= 0 )
      v5 = IoStatusBlock.u.Status;
  }
  if ( (v5 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(Handle);
    BaseSetLastNTError(v5);
    return 0;
  }
  v6 = v14;
  if ( v14 & 8 )
    v2->fDummy2 |= 4u;
  if ( v6 & 0x10 )
    v2->fDummy2 |= 8u;
  v7 = v15;
  if ( v15 & 1 )
    v2->fDummy2 |= 0x100u;
  if ( v7 & 2 )
    v2->fDummy2 |= 0x200u;
  if ( v7 & 8 )
    v2->fDummy2 |= 0x800u;
  if ( v7 & 4 )
    v2->fDummy2 |= 0x400u;
  if ( v7 & 0x80000000 )
    v2->fDummy2 |= 0x80u;
  if ( v6 & 0x80000000 )
    v2->fDummy2 |= 0x4000u;
  v8 = v7 & 0xC0;
  if ( !v8 )
  {
    v2->fDummy2 &= 0xFFFFCFFF;
    goto LABEL_47;
  }
  v9 = v8 - 64;
  if ( !v9 )
  {
    v11 = v2->fDummy2 & 0xFFFFDFFF | 0x1000;
    goto LABEL_45;
  }
  v10 = v9 - 64;
  if ( !v10 )
  {
    v11 = v2->fDummy2 & 0xFFFFEFFF | 0x2000;
LABEL_45:
    v2->fDummy2 = v11;
    goto LABEL_47;
  }
  if ( v10 == 64 )
    v2->fDummy2 |= 0x3000u;
LABEL_47:
  if ( !(v6 & 3) )
  {
    v2->fDummy2 &= 0xFFFFFFCF;
    goto LABEL_54;
  }
  if ( (v6 & 3) == 1 )
  {
    v12 = v2->fDummy2 & 0xFFFFFFDF | 0x10;
    goto LABEL_52;
  }
  if ( (v6 & 3) == 2 )
  {
    v12 = v2->fDummy2 & 0xFFFFFFEF | 0x20;
LABEL_52:
    v2->fDummy2 = v12;
  }
LABEL_54:
  v13 = Handle;
  v2->fDummy2 ^= (v6 ^ v2->fDummy2) & 0x40;
  v2->XonLim = v16;
  v2->XoffLim = v17;
  CloseHandle(v13);
  return 1;
}

//----- (77E727BB) --------------------------------------------------------
BOOL __stdcall GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
{
  HANDLE v2; // edi@1
  NTSTATUS v4; // eax@3
  DWORD OutputBuffer; // [sp+8h] [bp-1Ch]@3
  DWORD v6; // [sp+Ch] [bp-18h]@8
  DWORD v7; // [sp+10h] [bp-14h]@8
  DWORD v8; // [sp+14h] [bp-10h]@8
  DWORD v9; // [sp+18h] [bp-Ch]@8
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-8h]@3

  v2 = CreateEventA(0, 1, 0, 0);
  if ( !v2 )
    return 0;
  v4 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B0020u, 0, 0, &OutputBuffer, 0x14u);
  if ( v4 == 259 )
  {
    v4 = NtWaitForSingleObject(v2, 0, 0);
    if ( v4 >= 0 )
      v4 = IoStatusBlock.u.Status;
  }
  if ( (v4 & 0xC0000000) == -1073741824 )
  {
    BaseSetLastNTError(v4);
    CloseHandle(v2);
    return 0;
  }
  CloseHandle(v2);
  lpCommTimeouts->ReadIntervalTimeout = OutputBuffer;
  lpCommTimeouts->ReadTotalTimeoutMultiplier = v6;
  lpCommTimeouts->ReadTotalTimeoutConstant = v7;
  lpCommTimeouts->WriteTotalTimeoutMultiplier = v8;
  lpCommTimeouts->WriteTotalTimeoutConstant = v9;
  return 1;
}

//----- (77E7285E) --------------------------------------------------------
BOOL __stdcall PurgeComm(HANDLE hFile, DWORD dwFlags)
{
  HANDLE v2; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v4; // edi@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@3

  v2 = CreateEventA(0, 1, 0, 0);
  if ( v2 )
  {
    v4 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B004Cu, &dwFlags, 4u, 0, 0);
    if ( v4 == 259 )
    {
      v4 = NtWaitForSingleObject(v2, 0, 0);
      if ( v4 >= 0 )
        v4 = IoStatusBlock.u.Status;
    }
    if ( (v4 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v2);
      BaseSetLastNTError(v4);
      result = 0;
    }
    else
    {
      CloseHandle(v2);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E72900) --------------------------------------------------------
BOOL __stdcall SetCommMask(HANDLE hFile, DWORD dwEvtMask)
{
  DWORD v2; // edi@1
  HANDLE v4; // ebx@3
  NTSTATUS v5; // edi@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@4

  v2 = dwEvtMask;
  if ( dwEvtMask & 0xFFFFE000 )
  {
    RtlSetLastWin32Error(13);
    return 0;
  }
  v4 = CreateEventA(0, 1, 0, 0);
  if ( !v4 )
    return 0;
  dwEvtMask = v2;
  v5 = NtDeviceIoControlFile(hFile, v4, 0, 0, &IoStatusBlock, 0x1B0044u, &dwEvtMask, 4u, 0, 0);
  if ( v5 == 259 )
  {
    v5 = NtWaitForSingleObject(v4, 0, 0);
    if ( v5 >= 0 )
      v5 = IoStatusBlock.u.Status;
  }
  if ( (v5 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(v4);
    BaseSetLastNTError(v5);
    return 0;
  }
  CloseHandle(v4);
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E729A0) --------------------------------------------------------
BOOL __stdcall SetCommState(HANDLE hFile, LPDCB lpDCB)
{
  HANDLE v2; // eax@2
  NTSTATUS v3; // edi@3
  unsigned int v5; // edx@10
  BYTE v6; // al@10
  char v7; // al@10
  int v8; // ecx@10
  int v9; // eax@10
  int v10; // eax@11
  int v11; // eax@12
  int v12; // eax@18
  int v13; // eax@19
  DWORD v14; // eax@45
  NTSTATUS v15; // esi@58
  struct _DCB DCB; // [sp+Ch] [bp-48h]@1
  int v17; // [sp+28h] [bp-2Ch]@1
  int v18; // [sp+2Ch] [bp-28h]@1
  int v19; // [sp+30h] [bp-24h]@1
  int v20; // [sp+34h] [bp-20h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+38h] [bp-1Ch]@3
  char v22; // [sp+40h] [bp-14h]@10
  char v23; // [sp+41h] [bp-13h]@10
  char v24; // [sp+42h] [bp-12h]@10
  char v25; // [sp+43h] [bp-11h]@10
  char v26; // [sp+44h] [bp-10h]@10
  char v27; // [sp+45h] [bp-Fh]@10
  DWORD InputBuffer; // [sp+48h] [bp-Ch]@3
  HANDLE Handle; // [sp+4Ch] [bp-8h]@2
  BYTE v30; // [sp+50h] [bp-4h]@10
  BYTE v31; // [sp+51h] [bp-3h]@10
  BYTE v32; // [sp+52h] [bp-2h]@10
  NTSTATUS lpDCBa; // [sp+60h] [bp+Ch]@49

  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  if ( !GetCommState(hFile, &DCB) )
    return 0;
  v2 = CreateEventA(0, 1, 0, 0);
  Handle = v2;
  if ( !v2 )
    return 0;
  InputBuffer = lpDCB->BaudRate;
  v3 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B0004u, &InputBuffer, 4u, 0, 0);
  if ( v3 == 259 )
  {
    v3 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v3 >= 0 )
      v3 = IoStatusBlock.u.Status;
  }
  if ( (v3 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(Handle);
    BaseSetLastNTError(v3);
    return 0;
  }
  v5 = lpDCB->fDummy2;
  v30 = lpDCB->StopBits;
  v6 = lpDCB->Parity;
  v18 &= 0xFFFFFF3F;
  v31 = v6;
  v32 = lpDCB->ByteSize;
  InputBuffer = lpDCB->BaudRate;
  v26 = lpDCB->XonChar;
  v27 = lpDCB->XoffChar;
  v7 = lpDCB->ErrorChar;
  v23 = v7;
  v24 = v7;
  v22 = lpDCB->EofChar;
  v8 = (v5 >> 12) & 3;
  v25 = lpDCB->EvtChar;
  v9 = (v5 >> 12) & 3;
  if ( v9 )
  {
    v10 = v9 - 1;
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        if ( v11 != 1 )
        {
LABEL_14:
          SetCommState(hFile, &DCB);
          CloseHandle(Handle);
          BaseSetLastNTError(-1073741811);
          return 0;
        }
        v18 |= 0xC0u;
      }
      else
      {
        v18 |= 0x80u;
      }
    }
    else
    {
      v18 |= 0x40u;
    }
  }
  v17 &= 0xFFFFFFFC;
  v12 = (v5 >> 4) & 3;
  if ( v12 )
  {
    v13 = v12 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        goto LABEL_14;
      v17 |= 2u;
    }
    else
    {
      v17 |= 1u;
    }
  }
  if ( v5 & 0x40 )
    v17 |= 0x40u;
  if ( v5 & 4 )
    v17 |= 8u;
  if ( v5 & 8 )
    v17 |= 0x10u;
  if ( v5 & 0x100 )
    v18 |= 1u;
  if ( v5 & 0x200 )
    v18 |= 2u;
  if ( v5 & 0x800 )
    v18 |= 8u;
  if ( v5 & 0x400 )
    v18 |= 4u;
  if ( (v5 & 0x80u) != 0 )
    v18 |= 0x80000000;
  if ( v5 & 0x4000 )
    v17 |= 0x80000000;
  if ( v8 == 1 )
  {
    EscapeCommFunction(hFile, 3u);
  }
  else if ( !v8 )
  {
    EscapeCommFunction(hFile, 4u);
  }
  v14 = (lpDCB->fDummy2 >> 4) & 3;
  if ( v14 == 1 )
  {
    EscapeCommFunction(hFile, 5u);
  }
  else if ( !v14 )
  {
    EscapeCommFunction(hFile, 6u);
  }
  v19 = lpDCB->XonLim;
  v20 = lpDCB->XoffLim;
  lpDCBa = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B000Cu, &v30, 3u, 0, 0);
  if ( lpDCBa == 259 )
  {
    lpDCBa = NtWaitForSingleObject(Handle, 0, 0);
    if ( lpDCBa >= 0 )
      lpDCBa = IoStatusBlock.u.Status;
  }
  if ( (lpDCBa & 0xC0000000) == -1073741824 )
    goto LABEL_66;
  lpDCBa = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B005Cu, &v22, 6u, 0, 0);
  if ( lpDCBa == 259 )
  {
    lpDCBa = NtWaitForSingleObject(Handle, 0, 0);
    if ( lpDCBa >= 0 )
      lpDCBa = IoStatusBlock.u.Status;
  }
  if ( (lpDCBa & 0xC0000000) == -1073741824 )
  {
LABEL_66:
    CloseHandle(Handle);
    SetCommState(hFile, &DCB);
    BaseSetLastNTError(lpDCBa);
    return 0;
  }
  v15 = NtDeviceIoControlFile(hFile, Handle, 0, 0, &IoStatusBlock, 0x1B0064u, &v17, 0x10u, 0, 0);
  if ( v15 == 259 )
  {
    v15 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v15 >= 0 )
      v15 = IoStatusBlock.u.Status;
  }
  if ( (v15 & 0xC0000000) == -1073741824 )
  {
    CloseHandle(Handle);
    SetCommState(hFile, &DCB);
    BaseSetLastNTError(v15);
    return 0;
  }
  CloseHandle(Handle);
  return 1;
}

//----- (77E72CBB) --------------------------------------------------------
BOOL __stdcall SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
{
  DWORD v2; // eax@1
  HANDLE v3; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v5; // edi@3
  DWORD InputBuffer; // [sp+8h] [bp-1Ch]@1
  DWORD v7; // [sp+Ch] [bp-18h]@1
  DWORD v8; // [sp+10h] [bp-14h]@1
  DWORD v9; // [sp+14h] [bp-10h]@1
  DWORD v10; // [sp+18h] [bp-Ch]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+1Ch] [bp-8h]@3

  InputBuffer = lpCommTimeouts->ReadIntervalTimeout;
  v7 = lpCommTimeouts->ReadTotalTimeoutMultiplier;
  v8 = lpCommTimeouts->ReadTotalTimeoutConstant;
  v2 = lpCommTimeouts->WriteTotalTimeoutConstant;
  v9 = lpCommTimeouts->WriteTotalTimeoutMultiplier;
  v10 = v2;
  v3 = CreateEventA(0, 1, 0, 0);
  if ( v3 )
  {
    v5 = NtDeviceIoControlFile(hFile, v3, 0, 0, &IoStatusBlock, 0x1B001Cu, &InputBuffer, 0x14u, 0, 0);
    if ( v5 == 259 )
    {
      v5 = NtWaitForSingleObject(v3, 0, 0);
      if ( v5 >= 0 )
        v5 = IoStatusBlock.u.Status;
    }
    if ( (v5 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v3);
      BaseSetLastNTError(v5);
      result = 0;
    }
    else
    {
      CloseHandle(v3);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E72D66) --------------------------------------------------------
BOOL __stdcall TransmitCommChar(HANDLE hFile, char cChar)
{
  HANDLE v2; // ebx@1
  BOOL result; // eax@2
  NTSTATUS v4; // edi@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@3

  v2 = CreateEventA(0, 1, 0, 0);
  if ( v2 )
  {
    v4 = NtDeviceIoControlFile(hFile, v2, 0, 0, &IoStatusBlock, 0x1B0018u, &cChar, 1u, 0, 0);
    if ( v4 == 259 )
    {
      v4 = NtWaitForSingleObject(v2, 0, 0);
      if ( v4 >= 0 )
        v4 = IoStatusBlock.u.Status;
    }
    if ( (v4 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v2);
      BaseSetLastNTError(v4);
      result = 0;
    }
    else
    {
      CloseHandle(v2);
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E72DF0) --------------------------------------------------------
BOOL __stdcall WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
{
  void *v3; // ST10_4@2
  HANDLE v4; // ST08_4@2
  NTSTATUS v5; // eax@2
  BOOL result; // eax@4
  HANDLE v7; // ebx@6
  NTSTATUS v8; // edi@7
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@7

  if ( !lpOverlapped )
  {
    v7 = CreateEventA(0, 1, 0, 0);
    if ( v7 )
    {
      v8 = NtDeviceIoControlFile(hFile, v7, 0, 0, &IoStatusBlock, 0x1B0048u, 0, 0, lpEvtMask, 4u);
      if ( v8 == 259 )
      {
        v8 = NtWaitForSingleObject(v7, 0, 0);
        if ( v8 >= 0 )
          v8 = IoStatusBlock.u.Status;
      }
      CloseHandle(v7);
      if ( (v8 & 0xC0000000) != -1073741824 )
        return 1;
      BaseSetLastNTError(v8);
    }
    return 0;
  }
  v3 = (void *)(((unsigned int)lpOverlapped->hEvent & 1) == 0 ? (unsigned int)lpOverlapped : 0);
  v4 = lpOverlapped->hEvent;
  lpOverlapped->Internal = 259;
  v5 = NtDeviceIoControlFile(hFile, v4, 0, v3, (PIO_STATUS_BLOCK)lpOverlapped, 0x1B0048u, 0, 0, lpEvtMask, 4u);
  if ( (v5 & 0xC0000000) == -1073741824 || v5 == 259 )
  {
    BaseSetLastNTError(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E72ECA) --------------------------------------------------------
int __stdcall sub_77E72ECA(int a1, int a2, void *Src, ULONG Size, PUNICODE_STRING DestinationString, int a6)
{
  int result; // eax@2
  int v7; // eax@3
  WCHAR *v8; // eax@3

  if ( a2 == 1 )
  {
    RtlInitUnicodeString(DestinationString, 0);
    v7 = KernelBaseGetGlobalData();
    v8 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), Size);
    DestinationString->Buffer = v8;
    if ( v8 )
    {
      memcpy(v8, Src, Size);
      DestinationString->Length = Size - 2;
      DestinationString->MaximumLength = Size;
      result = 0;
    }
    else
    {
      result = -1073741670;
    }
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (77E72F3C) --------------------------------------------------------
int __stdcall GetFriendlyUi(PCWSTR Path, PVOID a2)
{
  int result; // eax@1
  HMODULE v3; // edi@1
  FARPROC v4; // esi@2
  FARPROC v5; // eax@2
  int v6; // eax@7
  ULONG v7; // esi@8
  const unsigned __int16 *v8; // esi@10
  NTSTATUS v9; // eax@18
  PVOID v10; // esi@25
  int v11; // eax@28
  struct _RTL_QUERY_REGISTRY_TABLE QueryTable; // [sp+10h] [bp-7Ch]@1
  int Context; // [sp+48h] [bp-44h]@1
  PCWSTR v14; // [sp+4Ch] [bp-40h]@1
  struct _TEB *v15; // [sp+50h] [bp-3Ch]@23
  HMODULE hLibModule; // [sp+54h] [bp-38h]@1
  FARPROC v17; // [sp+58h] [bp-34h]@2
  ULONG Flags; // [sp+5Ch] [bp-30h]@9
  int v19; // [sp+60h] [bp-2Ch]@13
  FARPROC v20; // [sp+64h] [bp-28h]@2
  FARPROC v21; // [sp+68h] [bp-24h]@2
  unsigned int v22; // [sp+6Ch] [bp-20h]@6
  PVOID Address; // [sp+70h] [bp-1Ch]@6
  CPPEH_RECORD ms_exc; // [sp+74h] [bp-18h]@2

  memset(&QueryTable.Flags, 0, 0x34u);
  Context = 0;
  v14 = Path;
  QueryTable.QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE)sub_77E71FDD;
  QueryTable.Flags = 4;
  result = (int)LoadLibraryW(L"cfgmgr32.dll");
  v3 = (HMODULE)result;
  hLibModule = (HMODULE)result;
  if ( result )
  {
    ms_exc.registration.TryLevel = 0;
    v4 = GetProcAddress((HMODULE)result, "CM_Get_Device_ID_List_SizeW");
    v21 = GetProcAddress(v3, "CM_Get_Device_ID_ListW");
    v20 = GetProcAddress(v3, "CM_Locate_DevNodeW");
    v5 = GetProcAddress(v3, "CM_Open_DevNode_Key");
    v17 = v5;
    if ( v4 )
    {
      if ( v21 )
      {
        if ( v20 )
        {
          if ( v5 )
          {
            Address = 0;
            if ( !((int (__stdcall *)(unsigned int *, _DWORD, signed int))v4)(&v22, L"MODEM", 2) )
            {
              v6 = v22 + 2;
              if ( v22 + 2 > v22 )
              {
                v7 = 2 * v6;
                if ( v6 < (unsigned int)(2 * v6) )
                {
                  Flags = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
                  Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], Flags, v7);
                }
              }
              v8 = (const unsigned __int16 *)Address;
              if ( Address )
              {
                ms_exc.registration.TryLevel = 1;
                if ( !((int (__stdcall *)(_DWORD, PVOID, unsigned int, signed int))v21)(L"modem", Address, v22, 2) )
                {
                  while ( *v8 )
                  {
                    v19 = 0;
                    if ( !((int (__stdcall *)(int *, const unsigned __int16 *, _DWORD))v20)(&v19, v8, 0)
                      && !((int (__stdcall *)(int, signed int, _DWORD, _DWORD, PCWSTR *, signed int))v17)(
                            v19,
                            983103,
                            0,
                            0,
                            &Path,
                            1) )
                    {
                      Context = 0;
                      QueryTable.Name = L"FriendlyName";
                      if ( RtlQueryRegistryValues(0x40000000u, Path, &QueryTable, &Context, 0) >= 0 && Context )
                      {
                        QueryTable.QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE)sub_77E72ECA;
                        QueryTable.Name = L"ConfigDialog";
                        v9 = RtlQueryRegistryValues(0x40000000u, Path, &QueryTable, a2, 0);
                        QueryTable.QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE)sub_77E71FDD;
                        if ( v9 < 0 )
                        {
                          BaseSetLastNTError(v9);
                          CloseHandle((HANDLE)Path);
                          return _local_unwind4(&__security_cookie, &ms_exc.registration, -2);
                        }
                        CloseHandle((HANDLE)Path);
                        if ( *((_DWORD *)a2 + 1) )
                          return _local_unwind4(&__security_cookie, &ms_exc.registration, -2);
                      }
                      else
                      {
                        CloseHandle((HANDLE)Path);
                      }
                    }
                    v8 += wcslen(v8) + 1;
                  }
                }
                ms_exc.registration.TryLevel = 0;
                v15 = NtCurrentTeb();
                RtlFreeHeap(v15->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
              }
            }
          }
        }
      }
    }
    ms_exc.registration.TryLevel = -2;
    result = FreeLibrary(hLibModule);
  }
  v10 = a2;
  if ( !*((_DWORD *)a2 + 1) )
  {
    QueryTable.Name = 0;
    if ( RtlQueryRegistryValues(4u, L"SERIALCOMM", &QueryTable, &Context, 0) >= 0 && Context )
    {
      v11 = KernelBaseGetGlobalData();
      result = (int)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v11 + 44), 0x1Au);
      *((_DWORD *)v10 + 1) = result;
      if ( result )
      {
        *((_WORD *)v10 + 1) = 26;
        *(_WORD *)v10 = 24;
        qmemcpy((void *)result, L"serialui.dll", 0x1Au);
      }
      else
      {
        result = BaseSetLastNTError(-1073741670);
      }
    }
    else
    {
      result = RtlSetLastWin32Error(87);
    }
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E4A16C: using guessed type _DWORD __cdecl _local_unwind4(_DWORD, _DWORD, _DWORD);
// 77E73234: using guessed type wchar_t aSerialui_dll[13];
// 77E73250: using guessed type wchar_t aConfigdialog[13];
// 77E7326C: using guessed type wchar_t aFriendlyname[13];
// 77E73288: using guessed type wchar_t aModem_0[6];
// 77E73294: using guessed type wchar_t aModem[6];

//----- (77E73305) --------------------------------------------------------
BOOL __stdcall CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
{
  HMODULE v3; // eax@2
  FARPROC v4; // eax@3
  DWORD v5; // eax@4
  __int16 v7; // [sp+10h] [bp-2Ch]@1
  int v8; // [sp+12h] [bp-2Ah]@1
  __int16 v9; // [sp+16h] [bp-26h]@1
  HMODULE hLibModule; // [sp+18h] [bp-24h]@1
  int v11; // [sp+1Ch] [bp-20h]@1
  DWORD v12; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v11 = 1;
  hLibModule = 0;
  v12 = 0;
  GetFriendlyUi(lpszName, &v7);
  ms_exc.registration.TryLevel = 0;
  if ( !*(int *)((char *)&v8 + 2) )
    goto LABEL_8;
  v3 = LoadLibraryW(*(LPCWSTR *)((char *)&v8 + 2));
  hLibModule = v3;
  if ( !v3 )
  {
    v12 = GetLastError();
LABEL_8:
    v11 = 0;
    goto LABEL_9;
  }
  v4 = GetProcAddress(v3, "drvCommConfigDialogW");
  if ( v4 )
  {
    v5 = ((int (__stdcall *)(LPCWSTR, HWND, LPCOMMCONFIG))v4)(lpszName, hWnd, lpCC);
  }
  else
  {
    v11 = 0;
    v5 = GetLastError();
  }
  v12 = v5;
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( *(int *)((char *)&v8 + 2) )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&v8 + 2));
  if ( hLibModule )
    FreeLibrary(hLibModule);
  if ( v12 )
  {
    RtlSetLastWin32Error(v12);
    v11 = 0;
  }
  return v11;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E73419) --------------------------------------------------------
BOOL __stdcall CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  STRING SourceString; // [sp+10h] [bp-2Ch]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@3
  int v7; // [sp+20h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@4

  v3 = RtlInitAnsiStringEx(&SourceString, lpszName);
  if ( v3 < 0 || (v3 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u), v3 < 0) )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = 0;
    v7 = CommConfigDialogW(DestinationString.Buffer, hWnd, lpCC);
    ms_exc.registration.TryLevel = -2;
    RtlFreeUnicodeString(&DestinationString);
    result = v7;
  }
  return result;
}

//----- (77E734B1) --------------------------------------------------------
BOOL __stdcall GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
{
  HMODULE v3; // eax@2
  FARPROC v4; // eax@3
  __int16 v6; // [sp+10h] [bp-2Ch]@1
  int v7; // [sp+12h] [bp-2Ah]@1
  __int16 v8; // [sp+16h] [bp-26h]@1
  HMODULE hLibModule; // [sp+18h] [bp-24h]@1
  int v10; // [sp+1Ch] [bp-20h]@1
  DWORD v11; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  v6 = 0;
  v7 = 0;
  v8 = 0;
  v10 = 1;
  hLibModule = 0;
  v11 = 0;
  GetFriendlyUi(lpszName, &v6);
  ms_exc.registration.TryLevel = 0;
  if ( *(int *)((char *)&v7 + 2) )
  {
    v3 = LoadLibraryW(*(LPCWSTR *)((char *)&v7 + 2));
    hLibModule = v3;
    if ( v3 )
    {
      v4 = GetProcAddress(v3, "drvGetDefaultCommConfigW");
      if ( v4 )
      {
        v11 = ((int (__stdcall *)(LPCWSTR, LPCOMMCONFIG, LPDWORD))v4)(lpszName, lpCC, lpdwSize);
        goto LABEL_7;
      }
    }
    v11 = GetLastError();
  }
  v10 = 0;
LABEL_7:
  ms_exc.registration.TryLevel = -2;
  if ( *(int *)((char *)&v7 + 2) )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&v7 + 2));
  if ( hLibModule )
    FreeLibrary(hLibModule);
  if ( v11 )
  {
    RtlSetLastWin32Error(v11);
    v10 = 0;
  }
  return v10;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E735C1) --------------------------------------------------------
BOOL __stdcall GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  STRING SourceString; // [sp+10h] [bp-2Ch]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@3
  int v7; // [sp+20h] [bp-1Ch]@4
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@4

  v3 = RtlInitAnsiStringEx(&SourceString, lpszName);
  if ( v3 < 0 || (v3 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u), v3 < 0) )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = 0;
    v7 = GetDefaultCommConfigW(DestinationString.Buffer, lpCC, lpdwSize);
    ms_exc.registration.TryLevel = -2;
    RtlFreeUnicodeString(&DestinationString);
    result = v7;
  }
  return result;
}

//----- (77E73659) --------------------------------------------------------
BOOL __stdcall SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
{
  HMODULE v3; // eax@2
  FARPROC v4; // eax@3
  DWORD v5; // eax@4
  __int16 v7; // [sp+10h] [bp-2Ch]@1
  int v8; // [sp+12h] [bp-2Ah]@1
  __int16 v9; // [sp+16h] [bp-26h]@1
  HMODULE hLibModule; // [sp+18h] [bp-24h]@1
  int v11; // [sp+1Ch] [bp-20h]@1
  DWORD v12; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1

  v7 = 0;
  v8 = 0;
  v9 = 0;
  v11 = 1;
  hLibModule = 0;
  v12 = 0;
  GetFriendlyUi(lpszName, &v7);
  ms_exc.registration.TryLevel = 0;
  if ( !*(int *)((char *)&v8 + 2) )
    goto LABEL_8;
  v3 = LoadLibraryW(*(LPCWSTR *)((char *)&v8 + 2));
  hLibModule = v3;
  if ( !v3 )
  {
    v12 = GetLastError();
LABEL_8:
    v11 = 0;
    goto LABEL_9;
  }
  v4 = GetProcAddress(v3, "drvSetDefaultCommConfigW");
  if ( v4 )
  {
    v5 = ((int (__stdcall *)(LPCWSTR, LPCOMMCONFIG, DWORD))v4)(lpszName, lpCC, dwSize);
  }
  else
  {
    v11 = 0;
    v5 = GetLastError();
  }
  v12 = v5;
LABEL_9:
  ms_exc.registration.TryLevel = -2;
  if ( *(int *)((char *)&v8 + 2) )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&v8 + 2));
  if ( hLibModule )
    FreeLibrary(hLibModule);
  if ( v12 )
  {
    RtlSetLastWin32Error(v12);
    v11 = 0;
  }
  return v11;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E73771) --------------------------------------------------------
BOOL __stdcall SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  STRING SourceString; // [sp+10h] [bp-2Ch]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@3
  int v7; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@4

  v7 = 1;
  v3 = RtlInitAnsiStringEx(&SourceString, lpszName);
  if ( v3 < 0 || (v3 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u), v3 < 0) )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    ms_exc.registration.TryLevel = 0;
    v7 = SetDefaultCommConfigW(DestinationString.Buffer, lpCC, dwSize);
    ms_exc.registration.TryLevel = -2;
    RtlFreeUnicodeString(&DestinationString);
    result = v7;
  }
  return result;
}

//----- (77E73811) --------------------------------------------------------
BOOL __stdcall ClearCommBreak(HANDLE hFile)
{
  return EscapeCommFunction(hFile, 9u);
}

//----- (77E73829) --------------------------------------------------------
BOOL __stdcall GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
{
  HANDLE v3; // esi@1
  NTSTATUS v5; // eax@3
  DWORD v6; // eax@7
  NTSTATUS v7; // ebx@25
  HANDLE v8; // ST24_4@31
  HANDLE v9; // [sp-8h] [bp-20h]@22
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-10h]@3
  DWORD OutputBuffer; // [sp+10h] [bp-8h]@3
  HANDLE hObject; // [sp+14h] [bp-4h]@1

  v3 = CreateEventA(0, 1, 0, 0);
  hObject = v3;
  if ( !v3 )
    return 0;
  v5 = NtDeviceIoControlFile(hCommDev, v3, 0, 0, &IoStatusBlock, 0x1B0080u, 0, 0, &OutputBuffer, 4u);
  if ( v5 == 259 )
  {
    v5 = NtWaitForSingleObject(v3, 0, 0);
    if ( v5 >= 0 )
      v5 = IoStatusBlock.u.Status;
  }
  if ( (v5 & 0xC0000000) == -1073741824 )
  {
    v6 = 0;
    OutputBuffer = 0;
  }
  else
  {
    v6 = OutputBuffer;
  }
  if ( !v6 )
  {
    CloseHandle(v3);
    if ( lpdwSize )
    {
      if ( *lpdwSize < 0x34 )
      {
        BaseSetLastNTError(-1073741811);
        *lpdwSize = 52;
        return 0;
      }
      *lpdwSize = 52;
      if ( lpCC )
      {
        lpCC->wVersion = 1;
        lpCC->dwProviderSubType = 1;
        lpCC->dwSize = 52;
        lpCC->wReserved = 0;
        lpCC->dwProviderOffset = 0;
        lpCC->dwProviderSize = 0;
        lpCC->wcProviderData[0] = 0;
        return GetCommState(hCommDev, &lpCC->dcb);
      }
      return 1;
    }
LABEL_17:
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  if ( !lpdwSize )
  {
    CloseHandle(v3);
    goto LABEL_17;
  }
  if ( *lpdwSize < 0x34 )
  {
    CloseHandle(v3);
    BaseSetLastNTError(-1073741811);
    *lpdwSize = OutputBuffer;
    return 0;
  }
  if ( !lpCC )
  {
    v8 = hObject;
    *lpdwSize = v6;
    CloseHandle(v8);
    return 1;
  }
  lpCC->wVersion = 1;
  lpCC->dwProviderSubType = 6;
  if ( *lpdwSize >= v6 )
  {
    *lpdwSize = v6;
    v7 = NtDeviceIoControlFile(hCommDev, hObject, 0, 0, &IoStatusBlock, 0x1B0084u, 0, 0, lpCC, v6);
    if ( v7 == 259 )
    {
      v7 = NtWaitForSingleObject(hObject, 0, 0);
      if ( v7 >= 0 )
        v7 = IoStatusBlock.u.Status;
    }
    v9 = hObject;
    if ( (v7 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(hObject);
      BaseSetLastNTError(v7);
      return 0;
    }
  }
  else
  {
    v9 = hObject;
    lpCC->dwProviderOffset = 0;
    lpCC->dwProviderSize = 0;
    lpCC->wcProviderData[0] = 0;
    *lpdwSize = 52;
  }
  CloseHandle(v9);
  return GetCommState(hCommDev, &lpCC->dcb);
}

//----- (77E739E1) --------------------------------------------------------
BOOL __stdcall SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
{
  LPCOMMCONFIG v3; // edi@1
  HANDLE v4; // ebx@2
  NTSTATUS v6; // edi@4
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+Ch] [bp-8h]@4

  v3 = lpCC;
  if ( lpCC->dwProviderOffset )
  {
    v4 = CreateEventA(0, 1, 0, 0);
    if ( !v4 )
      return 0;
    v6 = NtDeviceIoControlFile(hCommDev, v4, 0, 0, &IoStatusBlock, 0x1B0088u, lpCC, dwSize, 0, 0);
    if ( v6 == 259 )
    {
      v6 = NtWaitForSingleObject(v4, 0, 0);
      if ( v6 >= 0 )
        v6 = IoStatusBlock.u.Status;
    }
    if ( (v6 & 0xC0000000) == -1073741824 )
    {
      CloseHandle(v4);
      BaseSetLastNTError(v6);
      return 0;
    }
    CloseHandle(v4);
    v3 = lpCC;
  }
  return SetCommState(hCommDev, &v3->dcb);
}

//----- (77E73A7B) --------------------------------------------------------
signed int __stdcall GetNextVDMCommand(int a1)
{
  NTSTATUS v1; // eax@2
  unsigned __int16 v3; // bx@4
  int v4; // eax@7
  unsigned __int32 v5; // ebx@7
  unsigned int v6; // eax@9
  NTSTATUS v7; // edi@14
  void *v8; // eax@19
  unsigned __int16 v9; // dx@29
  int v10; // ecx@29
  unsigned __int16 v11; // di@29
  unsigned int v12; // eax@29
  signed int v13; // ebx@29
  unsigned __int32 v14; // ecx@37
  int v15; // ecx@45
  int v16; // ecx@48
  int v17; // ecx@51
  unsigned __int32 v18; // ebx@54
  unsigned __int16 v19; // ax@58
  unsigned __int16 v20; // ax@61
  int v21; // eax@64
  unsigned __int16 v22; // ax@67
  int v23; // eax@70
  int v24; // eax@73
  int v25; // eax@76
  int v26; // eax@82
  void *v27; // eax@96
  signed __int16 v28; // ax@108
  NTSTATUS v29; // [sp+1Ch] [bp-104h]@80
  unsigned __int32 v30; // [sp+20h] [bp-100h]@7
  char v31; // [sp+24h] [bp-FCh]@2
  NTSTATUS v32; // [sp+44h] [bp-DCh]@15
  PVOID Dst; // [sp+4Ch] [bp-D4h]@3
  PVOID v34; // [sp+50h] [bp-D0h]@26
  HANDLE Handle; // [sp+54h] [bp-CCh]@29
  int v36; // [sp+58h] [bp-C8h]@110
  int v37; // [sp+5Ch] [bp-C4h]@110
  int v38; // [sp+60h] [bp-C0h]@110
  int v39; // [sp+64h] [bp-BCh]@110
  int v40; // [sp+68h] [bp-B8h]@110
  int v41; // [sp+6Ch] [bp-B4h]@29
  void *v42; // [sp+70h] [bp-B0h]@56
  void *v43; // [sp+74h] [bp-ACh]@59
  void *v44; // [sp+78h] [bp-A8h]@62
  void *v45; // [sp+7Ch] [bp-A4h]@43
  void *Src; // [sp+80h] [bp-A0h]@13
  size_t Size; // [sp+84h] [bp-9Ch]@7
  void *v48; // [sp+88h] [bp-98h]@70
  void *v49; // [sp+8Ch] [bp-94h]@46
  size_t v50; // [sp+90h] [bp-90h]@29
  void *v51; // [sp+94h] [bp-8Ch]@49
  size_t v52; // [sp+98h] [bp-88h]@29
  void *v53; // [sp+9Ch] [bp-84h]@7
  size_t v54; // [sp+A0h] [bp-80h]@29
  __int16 v55; // [sp+A4h] [bp-7Ch]@110
  unsigned __int16 v56; // [sp+A6h] [bp-7Ah]@29
  unsigned __int16 v57; // [sp+A8h] [bp-78h]@29
  unsigned __int16 v58; // [sp+AAh] [bp-76h]@29
  unsigned __int16 v59; // [sp+ACh] [bp-74h]@29
  int v60; // [sp+AEh] [bp-72h]@7
  CPPEH_RECORD ms_exc; // [sp+108h] [bp-18h]@19

  if ( !a1 )
  {
    v1 = CsrClientCallServer(&v31, 0, 65545, 4);
    if ( v1 >= 0 )
      return (signed int)Dst;
    goto LABEL_112;
  }
  v3 = *(_WORD *)(a1 + 152);
  if ( !v3 )
    return *(_BYTE *)(BaseStaticServerData + 1873);
  if ( *(_WORD *)(a1 + 152) & 0xD000 )
  {
    memset(&Dst, 0, 0x68u);
    Dst = *(PVOID *)a1;
    v4 = *(_DWORD *)(a1 + 48);
    Size = *(_DWORD *)(a1 + 48);
    v53 = *(void **)(a1 + 136);
    LOWORD(v60) = v3;
    v5 = 0;
    v30 = 0;
    if ( *(_DWORD *)(a1 + 44) )
    {
      if ( v4 )
        v6 = (v4 + 3) & 0xFFFFFFFC;
      else
        v6 = 4;
      v5 = CsrAllocateCaptureBuffer(1, v6);
      v30 = v5;
      if ( !v5 )
      {
LABEL_12:
        BaseSetLastNTError(-1073741801);
        return 0;
      }
      CsrAllocateMessagePointer(v5, *(_DWORD *)(a1 + 48), &Src);
      _memmove(Src, *(const void **)(a1 + 44), *(_DWORD *)(a1 + 48));
    }
    v7 = CsrClientCallServer(&v31, v5, 268500999, 104);
    if ( v7 < 0 || (v7 = v32, v32 < 0) )
    {
      if ( v5 )
        CsrFreeCaptureBuffer(v5);
LABEL_18:
      BaseSetLastNTError(v7);
      return 0;
    }
    ms_exc.registration.TryLevel = 0;
    v8 = *(void **)(a1 + 44);
    if ( v8 )
      _memmove(v8, Src, *(_DWORD *)(a1 + 48));
    ms_exc.registration.TryLevel = -2;
    *(_DWORD *)a1 = Dst;
    *(_DWORD *)(a1 + 48) = Size;
    if ( v5 )
      CsrFreeCaptureBuffer(v5);
    return 1;
  }
  if ( v3 == 16 || v3 == 32 )
  {
    Dst = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
    v34 = (PVOID)v3;
    v1 = CsrClientCallServer(&v31, 0, 268501003, 8);
    if ( v1 < 0 )
    {
LABEL_112:
      BaseSetLastNTError(v1);
      return 0;
    }
    return 1;
  }
  v34 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  if ( v3 & 0x100 )
    Dst = *(PVOID *)a1;
  else
    Dst = 0;
  v57 = *(_WORD *)(a1 + 146);
  v58 = *(_WORD *)(a1 + 148);
  v9 = *(_WORD *)(a1 + 144);
  v56 = v9;
  v10 = *(_DWORD *)(a1 + 48);
  Size = *(_DWORD *)(a1 + 48);
  v41 = *(_DWORD *)(a1 + 8);
  LOWORD(v60) = v3;
  Handle = 0;
  v50 = *(_DWORD *)(a1 + 124);
  v52 = *(_DWORD *)(a1 + 132);
  v54 = *(_DWORD *)(a1 + 140);
  v11 = *(_WORD *)(a1 + 150);
  v59 = *(_WORD *)(a1 + 150);
  v12 = 68;
  v30 = 68;
  v13 = 1;
  if ( v9 )
  {
    v12 = ((v9 + 3) & 0xFFFFFFFC) + 68;
    v30 = ((v9 + 3) & 0xFFFFFFFC) + 68;
    v13 = 2;
  }
  if ( *(_WORD *)(a1 + 146) )
  {
    v12 += (v57 + 3) & 0xFFFFFFFC;
    v30 = v12;
    ++v13;
  }
  if ( *(_WORD *)(a1 + 148) )
  {
    v12 += (v58 + 3) & 0xFFFFFFFC;
    v30 = v12;
    ++v13;
  }
  if ( *(_DWORD *)(a1 + 44) )
  {
    ++v13;
    if ( v10 )
      v14 = (v10 + 3) & 0xFFFFFFFC;
    else
      v14 = 4;
    if ( ULongAdd(v12, v14, &v30) < 0 )
    {
      BaseSetLastNTError(-1073741675);
      return 0;
    }
    v12 = v30;
  }
  if ( v11 )
  {
    v12 += (v11 + 3) & 0xFFFFFFFC;
    ++v13;
  }
  else
  {
    v45 = 0;
  }
  v15 = *(_DWORD *)(a1 + 124);
  if ( v15 )
  {
    v12 += (v15 + 3) & 0xFFFFFFFC;
    ++v13;
  }
  else
  {
    v49 = 0;
  }
  v16 = *(_DWORD *)(a1 + 132);
  if ( v16 )
  {
    v12 += (v16 + 3) & 0xFFFFFFFC;
    ++v13;
  }
  else
  {
    v51 = 0;
  }
  v17 = *(_DWORD *)(a1 + 140);
  if ( v17 )
  {
    v12 += (v17 + 3) & 0xFFFFFFFC;
    ++v13;
  }
  else
  {
    v53 = 0;
  }
  v18 = CsrAllocateCaptureBuffer(v13, v12);
  v30 = v18;
  if ( !v18 )
    goto LABEL_12;
  if ( *(_DWORD *)(a1 + 28) )
    CsrAllocateMessagePointer(v18, *(_WORD *)(a1 + 144), &v42);
  else
    v42 = 0;
  v19 = *(_WORD *)(a1 + 146);
  if ( v19 )
    CsrAllocateMessagePointer(v18, v19, &v43);
  else
    v43 = 0;
  v20 = *(_WORD *)(a1 + 148);
  if ( v20 )
    CsrAllocateMessagePointer(v18, v20, &v44);
  else
    v44 = 0;
  v21 = *(_DWORD *)(a1 + 48);
  if ( v21 )
    CsrAllocateMessagePointer(v18, v21, &Src);
  else
    Src = 0;
  v22 = *(_WORD *)(a1 + 150);
  if ( v22 )
    CsrAllocateMessagePointer(v18, v22, &v45);
  else
    v45 = 0;
  CsrAllocateMessagePointer(v18, 68, &v48);
  v23 = *(_DWORD *)(a1 + 124);
  if ( v23 )
    CsrAllocateMessagePointer(v18, v23, &v49);
  else
    v49 = 0;
  v24 = *(_DWORD *)(a1 + 132);
  if ( v24 )
    CsrAllocateMessagePointer(v18, v24, &v51);
  else
    v51 = 0;
  v25 = *(_DWORD *)(a1 + 140);
  if ( v25 )
    CsrAllocateMessagePointer(v18, v25, &v53);
  else
    v53 = 0;
  while ( 1 )
  {
    v26 = CsrClientCallServer(&v31, v30, 268500999, 104);
    if ( !Handle )
      break;
    v29 = NtWaitForSingleObject(Handle, 0, 0);
    if ( v29 )
    {
      CsrFreeCaptureBuffer(v30);
      BaseSetLastNTError(v29);
      return 0;
    }
    LOWORD(v60) = v60 | 8;
    v41 = 0;
  }
  v7 = v26;
  if ( v26 < 0 || (v7 = v32, v32 < 0) )
  {
    if ( v7 == -1073741811 )
    {
      *(_WORD *)(a1 + 144) = v56;
      *(_WORD *)(a1 + 146) = v57;
      *(_WORD *)(a1 + 148) = v58;
      *(_DWORD *)(a1 + 48) = Size;
      *(_WORD *)(a1 + 150) = v59;
      *(_DWORD *)(a1 + 124) = v50;
      *(_DWORD *)(a1 + 132) = v52;
      *(_DWORD *)(a1 + 140) = v54;
    }
    else
    {
      *(_WORD *)(a1 + 144) = 0;
      *(_WORD *)(a1 + 146) = 0;
      *(_WORD *)(a1 + 148) = 0;
      *(_DWORD *)(a1 + 48) = 0;
      *(_WORD *)(a1 + 150) = 0;
      *(_DWORD *)(a1 + 124) = 0;
      *(_DWORD *)(a1 + 132) = 0;
      *(_DWORD *)(a1 + 140) = 0;
    }
    CsrFreeCaptureBuffer(v30);
    goto LABEL_18;
  }
  ms_exc.registration.TryLevel = 2;
  if ( *(_WORD *)(a1 + 144) )
    _memmove(*(void **)(a1 + 28), v42, v56);
  if ( *(_WORD *)(a1 + 146) )
    _memmove(*(void **)(a1 + 32), v43, v57);
  if ( *(_WORD *)(a1 + 148) )
    _memmove(*(void **)(a1 + 36), v44, v58);
  v27 = *(void **)(a1 + 44);
  if ( v27 )
    _memmove(v27, Src, Size);
  if ( *(_WORD *)(a1 + 150) )
    _memmove(*(void **)(a1 + 40), v45, v59);
  if ( v60 & 0x200 )
    _memmove((void *)(a1 + 52), v48, 0x44u);
  if ( *(_DWORD *)(a1 + 124) )
  {
    _memmove(*(void **)(a1 + 120), v49, v50);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 120);
  }
  if ( *(_DWORD *)(a1 + 132) )
  {
    _memmove(*(void **)(a1 + 128), v51, v52);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 128);
  }
  if ( *(_DWORD *)(a1 + 140) )
  {
    _memmove(*(void **)(a1 + 136), v53, v54);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a1 + 136);
  }
  *(_WORD *)(a1 + 144) = v56;
  *(_WORD *)(a1 + 146) = v57;
  *(_WORD *)(a1 + 148) = v58;
  *(_DWORD *)(a1 + 48) = Size;
  v28 = 512;
  if ( !(v60 & 0x200) )
    v28 = 0;
  *(_WORD *)(a1 + 152) = v28;
  *(_WORD *)(a1 + 154) = v55;
  *(_DWORD *)(a1 + 16) = v36;
  *(_DWORD *)(a1 + 20) = v37;
  *(_DWORD *)(a1 + 24) = v38;
  *(_DWORD *)a1 = Dst;
  *(_DWORD *)(a1 + 12) = v39;
  *(_WORD *)(a1 + 150) = v59;
  *(_DWORD *)(a1 + 124) = v50;
  *(_DWORD *)(a1 + 132) = v52;
  *(_DWORD *)(a1 + 140) = v54;
  *(_DWORD *)(a1 + 4) = v40;
  *(_BYTE *)(a1 + 156) = BYTE2(v60);
  ms_exc.registration.TryLevel = 1;
  CsrFreeCaptureBuffer(v30);
  ms_exc.registration.TryLevel = -2;
  return 1;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E742E9) --------------------------------------------------------
NTSTATUS __stdcall ExitVDM(int a1, int a2)
{
  NTSTATUS result; // eax@1
  char v3; // [sp+0h] [bp-E4h]@1
  PVOID v4; // [sp+28h] [bp-BCh]@1
  int v5; // [sp+2Ch] [bp-B8h]@1
  HANDLE Handle; // [sp+30h] [bp-B4h]@1

  v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  Handle = 0;
  v5 = a1 != 0 ? a2 : 0;
  result = CsrClientCallServer(&v3, 0, 268501000, 12);
  if ( result >= 0 )
  {
    if ( Handle )
      result = NtClose(Handle);
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7436C) --------------------------------------------------------
int __stdcall SetVDMCurrentDirectories(size_t Size, void *Src)
{
  int v3; // eax@6
  NTSTATUS v4; // esi@9
  int v6; // [sp+18h] [bp-100h]@6
  char v7; // [sp+1Ch] [bp-FCh]@9
  int v8; // [sp+3Ch] [bp-DCh]@10
  PVOID v9; // [sp+44h] [bp-D4h]@1
  void *Dst; // [sp+48h] [bp-D0h]@8
  size_t v11; // [sp+4Ch] [bp-CCh]@8
  CPPEH_RECORD ms_exc; // [sp+100h] [bp-18h]@8

  v9 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  if ( v9 == (PVOID)-1 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  if ( Size && Src )
  {
    v3 = CsrAllocateCaptureBuffer(1, Size);
    v6 = v3;
    if ( !v3 )
    {
      BaseSetLastNTError(-1073741801);
      return 0;
    }
    CsrAllocateMessagePointer(v3, Size, &Dst);
    v11 = Size;
    ms_exc.registration.TryLevel = 1;
    _memmove(Dst, Src, Size);
    ms_exc.registration.TryLevel = 0;
    ms_exc.registration.TryLevel = -2;
    v4 = CsrClientCallServer(&v7, v6, 268501006, 12);
    CsrFreeCaptureBuffer(v6);
    if ( v4 < 0 || v8 < 0 )
    {
      BaseSetLastNTError(v4);
      return 0;
    }
  }
  return 1;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E744ED) --------------------------------------------------------
size_t __stdcall GetVDMCurrentDirectories(int a1, void *Dst)
{
  NTSTATUS v3; // eax@9
  size_t v4; // [sp+14h] [bp-104h]@6
  int v5; // [sp+18h] [bp-100h]@5
  char v6; // [sp+1Ch] [bp-FCh]@9
  NTSTATUS v7; // [sp+3Ch] [bp-DCh]@9
  PVOID v8; // [sp+44h] [bp-D4h]@1
  void *Src; // [sp+48h] [bp-D0h]@7
  size_t Size; // [sp+4Ch] [bp-CCh]@7
  CPPEH_RECORD ms_exc; // [sp+100h] [bp-18h]@3

  v8 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  if ( v8 == (PVOID)-1 )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( !a1 || !Dst )
  {
    Size = 0;
    Src = 0;
    v5 = 0;
    goto LABEL_9;
  }
  v5 = CsrAllocateCaptureBuffer(1, a1);
  if ( v5 )
  {
    CsrAllocateMessagePointer(v5, a1, &Src);
    Size = a1;
LABEL_9:
    v7 = -1;
    v3 = CsrClientCallServer(&v6, v5, 268501007, 12);
    if ( v7 == -1 )
      Size = 0;
    if ( v3 < 0 || (v3 = v7, v7 < 0) )
    {
      BaseSetLastNTError(v3);
    }
    else
    {
      ms_exc.registration.TryLevel = 1;
      _memmove(Dst, Src, Size);
      ms_exc.registration.TryLevel = 0;
    }
    v4 = Size;
    goto LABEL_16;
  }
  BaseSetLastNTError(-1073741801);
  v4 = 0;
LABEL_16:
  ms_exc.registration.TryLevel = -2;
  if ( v5 )
    CsrFreeCaptureBuffer(v5);
  return v4;
}
// 77DE11F0: using guessed type int __stdcall CsrAllocateMessagePointer(_DWORD, _DWORD, _DWORD);
// 77DE1458: using guessed type int __stdcall CsrAllocateCaptureBuffer(_DWORD, _DWORD);
// 77DE1460: using guessed type int __stdcall CsrFreeCaptureBuffer(_DWORD);
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E74695) --------------------------------------------------------
int __stdcall RegisterWowExec(int a1)
{
  char v2; // [sp+0h] [bp-E4h]@1
  int v3; // [sp+28h] [bp-BCh]@1
  PVOID v4; // [sp+2Ch] [bp-B8h]@1

  v3 = a1;
  v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  return CsrClientCallServer(&v2, 0, 268501009, 8);
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E746F1) --------------------------------------------------------
signed int __stdcall BaseUpdateVDMEntry(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@14
  char v5; // [sp+Ch] [bp-E4h]@10
  NTSTATUS NtStatus; // [sp+2Ch] [bp-C4h]@11
  int v7; // [sp+34h] [bp-BCh]@3
  int v8; // [sp+38h] [bp-B8h]@10
  PVOID v9; // [sp+3Ch] [bp-B4h]@6
  int v10; // [sp+40h] [bp-B0h]@3
  int v11; // [sp+44h] [bp-ACh]@13
  __int16 v12; // [sp+48h] [bp-A8h]@10
  __int16 v13; // [sp+4Ah] [bp-A6h]@4

  if ( a1 )
  {
    if ( a1 == 1 )
    {
      v10 = *(_DWORD *)a2;
      v7 = a3;
    }
  }
  else
  {
    v7 = *(_DWORD *)a2;
    v13 = a3;
  }
  if ( a4 == 32 )
  {
    v9 = (PVOID)-1;
  }
  else if ( v7 )
  {
    v9 = 0;
  }
  else
  {
    v9 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
  }
  v8 = a4;
  v12 = a1;
  if ( CsrClientCallServer(&v5, 0, 268500998, 24) < 0 || NtStatus < 0 )
  {
    BaseSetLastNTError(NtStatus);
    result = 0;
  }
  else
  {
    if ( a1 == 1 )
      *(_DWORD *)a2 = v11;
    result = 1;
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E747DA) --------------------------------------------------------
int __stdcall BaseCheckForVDM(HANDLE EventHandle, int a2)
{
  int result; // eax@2
  char EventInformation; // [sp+8h] [bp-ECh]@1
  char v4; // [sp+10h] [bp-E4h]@3
  PVOID v5; // [sp+38h] [bp-BCh]@3
  HANDLE v6; // [sp+3Ch] [bp-B8h]@3
  int v7; // [sp+40h] [bp-B4h]@4

  if ( NtQueryEvent(EventHandle, 0, &EventInformation, 8u, 0) < 0
    || (v5 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0],
        v6 = EventHandle,
        CsrClientCallServer(&v4, 0, 268501002, 12) < 0) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = v7;
    result = 1;
  }
  return result;
}
// 77DE15D8: using guessed type int __stdcall CsrClientCallServer(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E74868) --------------------------------------------------------
int __stdcall BaseDestroyVDMEnvironment(PANSI_STRING AnsiString, int a2)
{
  if ( AnsiString->Buffer )
    RtlFreeAnsiString(AnsiString);
  if ( *(_DWORD *)(a2 + 4) )
    RtlDestroyEnvironment(*(PVOID *)(a2 + 4));
  return 1;
}

//----- (77E7489A) --------------------------------------------------------
int __stdcall BaseGetEnvNameType_U(wchar_t *a1, size_t a2)
{
  int v2; // edi@1
  const wchar_t **v3; // esi@1
  signed int v5; // [sp+Ch] [bp-4h]@1

  v5 = 1;
  v2 = 0;
  v3 = (const wchar_t **)&off_77EA6C9C;
  while ( *(v3 - 1) != (const wchar_t *)a2 || __wcsnicmp(*v3, a1, a2) )
  {
    v3 += 3;
    ++v2;
    if ( (signed int)v3 >= (signed int)&pchPad )
      return v5;
  }
  return dword_77EA6C94[3 * v2];
}
// 77EA6C94: using guessed type int dword_77EA6C94[];
// 77EA6C9C: using guessed type wchar_t *off_77EA6C9C;

//----- (77E748F5) --------------------------------------------------------
DWORD __stdcall GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, int a4)
{
  DWORD v5; // [sp+10h] [bp-1Ch]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v5 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      v5 = GetLongPathNameA(lpszShortPath, lpszLongPath, cchBuffer);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v5 = 0;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E74999) --------------------------------------------------------
DWORD __stdcall GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, int a4)
{
  DWORD v5; // [sp+10h] [bp-1Ch]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v5 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      v5 = GetLongPathNameW(lpszShortPath, lpszLongPath, cchBuffer);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v5 = 0;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E74A41) --------------------------------------------------------
signed int __stdcall VDMOperationStarted(int a1)
{
  return BaseUpdateVDMEntry(2, 0, 0, a1);
}

//----- (77E74A5D) --------------------------------------------------------
NTSTATUS __stdcall BaseGetVdmLuid(HANDLE TokenHandle, int a2)
{
  NTSTATUS result; // eax@1
  int v3; // eax@2
  PVOID v4; // edi@2
  NTSTATUS v5; // esi@4
  ULONG ReturnLength; // [sp+4h] [bp-4h]@1

  result = NtQueryInformationToken(TokenHandle, TokenStatistics, 0, 0, &ReturnLength);
  if ( result == -1073741789 )
  {
    v3 = KernelBaseGetGlobalData();
    v4 = RtlAllocateHeap(
           NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
           *(_DWORD *)(v3 + 44) + 0x200000,
           ReturnLength);
    if ( v4 )
    {
      v5 = NtQueryInformationToken(TokenHandle, TokenStatistics, v4, ReturnLength, &ReturnLength);
      if ( v5 >= 0 )
      {
        if ( a2 )
        {
          *(_DWORD *)a2 = *((_DWORD *)v4 + 2);
          *(_DWORD *)(a2 + 4) = *((_DWORD *)v4 + 3);
        }
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
      result = v5;
    }
    else
    {
      result = -1073741789;
    }
  }
  return result;
}

//----- (77E74AFB) --------------------------------------------------------
int __stdcall BaseCreateVDMEnvironment(int a1, PANSI_STRING DestinationString, PCUNICODE_STRING SourceString)
{
  PCUNICODE_STRING v3; // edi@2
  NTSTATUS v4; // eax@4
  PVOID v5; // eax@7
  __int16 v6; // cx@8
  PVOID v7; // ebx@15
  int v8; // esi@15
  int v9; // edx@18
  unsigned __int16 v10; // ax@18
  __int16 v11; // ax@26
  unsigned __int16 v12; // ax@29
  int v13; // esi@33
  int v14; // eax@34
  const unsigned __int16 v15; // ax@36
  const unsigned __int16 v16; // ax@40
  unsigned int v17; // kr04_4@43
  int v18; // edi@43
  DWORD v19; // eax@43
  int v20; // edi@51
  DWORD v21; // eax@52
  int v22; // esi@55
  int v23; // edi@60
  DWORD v24; // eax@61
  int v25; // esi@68
  PVOID *v26; // esi@68
  NTSTATUS v27; // eax@68
  NTSTATUS v28; // edi@71
  int Size; // [sp+10h] [bp-3Ch]@10
  signed int v31; // [sp+14h] [bp-38h]@1
  LPWSTR lpszShortPath; // [sp+18h] [bp-34h]@1
  int v33; // [sp+1Ch] [bp-30h]@7
  PVOID Environment; // [sp+20h] [bp-2Ch]@1
  LPCWSTR lpszLongPath; // [sp+24h] [bp-28h]@35
  int v36; // [sp+28h] [bp-24h]@15
  LPWSTR v37; // [sp+2Ch] [bp-20h]@15
  char *v38; // [sp+30h] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@3

  Environment = 0;
  lpszShortPath = 0;
  v31 = 0;
  if ( !DestinationString || (v3 = SourceString) == 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  ms_exc.registration.TryLevel = 0;
  if ( a1 )
  {
    Environment = (PVOID)a1;
  }
  else
  {
    v4 = RtlCreateEnvironment(1u, &Environment);
    if ( v4 < 0 )
    {
      BaseSetLastNTError(v4);
      Environment = 0;
      goto LABEL_74;
    }
  }
  v33 = 0;
  v5 = Environment;
  v38 = (char *)Environment;
  while ( 1 )
  {
    v6 = *(_WORD *)v5;
    v5 = (char *)v5 + 2;
    v38 = (char *)v5;
    if ( !v6 && !*(_WORD *)v5 )
      break;
    ++v33;
  }
  Size = 2 * (v33 + 2) + 520;
  if ( (unsigned int)Size > 0xFFFF )
  {
    BaseSetLastNTError(-1073741823);
    goto LABEL_74;
  }
  lpszShortPath = (LPWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
  if ( !lpszShortPath )
  {
    BaseSetLastNTError(-1073741670);
    goto LABEL_74;
  }
  v36 = 258;
  v7 = Environment;
  v38 = (char *)Environment;
  v8 = (int)lpszShortPath;
  v37 = lpszShortPath;
  while ( *(_WORD *)v7 )
  {
    if ( *(_WORD *)v7 == 61 )
    {
      v9 = (int)((char *)v7 + 2);
      v10 = *((_WORD *)v7 + 1);
      if ( (v10 >= 0x41u && v10 <= 0x5Au || v10 >= 0x61u && v10 <= 0x7Au)
        && *((_WORD *)v7 + 2) == 58
        && *((_WORD *)v7 + 3) == 61
        && wcslen((const unsigned __int16 *)v7) >= 7 )
      {
        if ( !*((_WORD *)v7 + 7) )
        {
          v11 = *((_WORD *)v7 + 6);
          if ( (v11 == 92 || v11 == 47) && *((_WORD *)v7 + 5) == 58 )
          {
            if ( (v12 = *((_WORD *)v7 + 4), v12 >= 0x41u) && v12 <= 0x5Au || v12 >= 0x61u && v12 <= 0x7Au )
            {
              do
              {
LABEL_40:
                v16 = *(_WORD *)v7;
                *(_WORD *)v8 = *(_WORD *)v7;
                v8 += 2;
                v37 = (LPWSTR)v8;
                v7 = (char *)v7 + 2;
                v38 = (char *)v7;
              }
              while ( v16 );
              goto LABEL_67;
            }
          }
        }
        *(_WORD *)v8 = 61;
        v13 = v8 + 2;
        v37 = (LPWSTR)v13;
        v38 = (char *)v7 + 2;
        *(_WORD *)v13 = *(_WORD *)v9;
        v13 += 2;
        v37 = (LPWSTR)v13;
        v38 = (char *)v7 + 4;
        *(_WORD *)v13 = *((_WORD *)v7 + 2);
        v13 += 2;
        v37 = (LPWSTR)v13;
        v38 = (char *)v7 + 6;
        *(_WORD *)v13 = *((_WORD *)v7 + 3);
        v8 = v13 + 2;
        v37 = (LPWSTR)v8;
        v7 = (char *)v7 + 8;
        v38 = (char *)(v9 + 6);
LABEL_43:
        v17 = wcslen((const unsigned __int16 *)v7);
        v18 = v17 + 1;
        v19 = GetShortPathNameW((LPCWSTR)v7, (LPWSTR)v8, v17 + 1 + v36);
        if ( !v19 || v19 >= v18 + v36 )
        {
          _memmove((void *)v8, v7, 2 * v18);
          v19 = v17;
        }
        v8 += 2 * v19 + 2;
        v37 = (LPWSTR)v8;
        v7 = (char *)v7 + 2 * v18;
        v38 = (char *)v7;
        if ( v19 > v18 )
          v36 += v18 - v19;
        goto LABEL_67;
      }
      v14 = 1;
    }
    else
    {
      lpszLongPath = (LPCWSTR)v7;
      do
      {
        v15 = *(_WORD *)v7;
        if ( !*(_WORD *)v7 )
          break;
        *(_WORD *)v8 = v15;
        v8 += 2;
        v37 = (LPWSTR)v8;
        v7 = (char *)v7 + 2;
        v38 = (char *)v7;
      }
      while ( v15 != 61 );
      v14 = BaseGetEnvNameType_U((wchar_t *)lpszLongPath, (((_BYTE *)v7 - (_BYTE *)lpszLongPath) >> 1) - 1);
    }
    if ( v14 == 1 )
      goto LABEL_40;
    if ( v14 == 2 )
      goto LABEL_43;
LABEL_48:
    lpszLongPath = (LPCWSTR)v7;
    while ( *(_WORD *)v7 )
    {
      if ( *(_WORD *)v7 == 59 )
      {
        v20 = ((_BYTE *)v7 - (_BYTE *)lpszLongPath) >> 1;
        if ( v20 )
        {
          *(_WORD *)v7 = 0;
          v21 = GetShortPathNameW(lpszLongPath, (LPWSTR)v8, v20 + v36 + 1);
          if ( !v21 || v21 > v20 + v36 )
          {
            _memmove((void *)v8, lpszLongPath, 2 * v20);
            v21 = v20;
          }
          v22 = v8 + 2 * v21;
          *(_WORD *)v7 = 59;
          *(_WORD *)v22 = 59;
          v8 = v22 + 2;
          v37 = (LPWSTR)v8;
          v7 = (char *)v7 + 2;
          v38 = (char *)v7;
          if ( v21 > v20 )
            v36 += v20 - v21;
        }
        while ( *(_WORD *)v7 == 59 )
        {
          *(_WORD *)v8 = 59;
          v8 += 2;
          v37 = (LPWSTR)v8;
          v7 = (char *)v7 + 2;
          v38 = (char *)v7;
        }
        goto LABEL_48;
      }
      v7 = (char *)v7 + 2;
      v38 = (char *)v7;
    }
    v23 = ((_BYTE *)v7 - (_BYTE *)lpszLongPath) >> 1;
    if ( v23 )
    {
      v24 = GetShortPathNameW(lpszLongPath, (LPWSTR)v8, v23 + v36 + 1);
      if ( !v24 || v24 > v23 )
      {
        _memmove((void *)v8, lpszLongPath, 2 * v23);
        v24 = v23;
      }
      v8 += 2 * v24;
      v37 = (LPWSTR)v8;
      if ( v24 > v23 )
        v36 += v23 - v24;
    }
    *(_WORD *)v8 = *(_WORD *)v7;
    v8 += 2;
    v37 = (LPWSTR)v8;
    v7 = (char *)v7 + 2;
    v38 = (char *)v7;
LABEL_67:
    v3 = SourceString;
  }
  *(_WORD *)v8 = 0;
  v25 = v8 + 2;
  v37 = (LPWSTR)v25;
  LOWORD(v25) = v25 - (_WORD)lpszShortPath;
  v3->Length = v25;
  v3->MaximumLength = v25;
  v26 = (PVOID *)&v3->Buffer;
  v27 = RtlCreateEnvironmentEx(lpszShortPath, &v3->Buffer, 0);
  if ( v27 >= 0 )
  {
    v28 = RtlUnicodeStringToAnsiString(DestinationString, v3, 1u);
    if ( v28 >= 0 )
    {
      v31 = 1;
    }
    else
    {
      RtlDestroyEnvironment(*v26);
      BaseSetLastNTError(v28);
    }
  }
  else
  {
    BaseSetLastNTError(v27);
  }
LABEL_74:
  ms_exc.registration.TryLevel = -2;
  if ( !a1 && Environment )
    RtlDestroyEnvironment(Environment);
  if ( lpszShortPath )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, lpszShortPath);
  if ( !v31 )
  {
    *(_DWORD *)&SourceString->Length = 0;
    SourceString->Buffer = 0;
    *(_DWORD *)&DestinationString->Length = 0;
    DestinationString->Buffer = 0;
  }
  return v31;
}
// 77DE11E4: using guessed type int __stdcall RtlCreateEnvironmentEx(_DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E74F61) --------------------------------------------------------
BOOL __stdcall GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
{
  BOOL result; // eax@1
  BOOL v3; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpApplicationName);
  if ( result )
  {
    v3 = GetBinaryTypeW(UnicodeString.Buffer, lpBinaryType);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E74F9C) --------------------------------------------------------
int __stdcall BaseCheckVDM(int a1, PCWSTR SourceString, int a3, int a4, int a5, int a6, int a7, int a8, ULONG MessageBoxResult, int a10)
{
  int v10; // esi@1
  signed int v11; // eax@1
  signed int v12; // edi@1
  int v13; // ST24_4@2
  int v14; // ebx@2
  ULONG Arguments; // [sp+Ch] [bp-10h]@5
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-8h]@5

  v10 = MessageBoxResult;
  v11 = BaseCheckVDMp(a1, SourceString, (wchar_t *)a3, (const WCHAR *)a4, a5, a6, a7, a8, MessageBoxResult, (void *)a10);
  v12 = v11;
  if ( v11 == -1073741790 )
  {
    v13 = a10;
    v14 = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters[1].Reserved2[9];
    v12 = BaseCheckVDMp(a1, SourceString, (wchar_t *)a3, (const WCHAR *)a4, a5, a6, a7, a8, v10, (void *)v13);
    if ( v12 < 0 )
      *(_DWORD *)(v10 + 8) = v14;
  }
  else if ( v11 == -1073740780 )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    Arguments = (ULONG)&DestinationString;
    NtRaiseHardError(-1073740780, 1u, 1u, &Arguments, 1u, &MessageBoxResult);
  }
  return v12;
}

//----- (77E75055) --------------------------------------------------------
int __stdcall BaseGetVdmConfigInfo(int a1, int a2, int a3, PUNICODE_STRING UnicodeString, int a5)
{
  UINT v5; // eax@1
  signed int v6; // ecx@1
  const WCHAR *v7; // eax@4
  const WCHAR *v8; // eax@10
  int result; // eax@13
  wchar_t pszDest; // [sp+8h] [bp-61Ch]@6
  WCHAR Buffer; // [sp+418h] [bp-20Ch]@1

  RtlFreeUnicodeString(UnicodeString);
  *(_DWORD *)a5 = 0x1000000;
  v5 = GetSystemDirectoryW(&Buffer, 0x104u);
  v6 = 0;
  if ( v5 && v5 < 0x104 )
  {
    if ( a2 )
    {
      v7 = L"-w";
      if ( a3 == 16 )
        v7 = &Src;
      StringCbPrintfW(&pszDest, 0x410u, L"\"%s\\ntvdm.exe\" -i%lx %s%c", &Buffer, a2, v7, a3 != 64 ? 32 : 115);
      goto LABEL_13;
    }
    if ( a3 == 64 )
    {
      v6 = 115;
    }
    else if ( a3 == 16 )
    {
      v8 = &Src;
      goto LABEL_12;
    }
    v8 = L"-w";
LABEL_12:
    StringCbPrintfW(&pszDest, 0x410u, L"\"%s\\ntvdm.exe\"  %s%c", &Buffer, v8, v6);
LABEL_13:
    RtlCreateUnicodeString(UnicodeString, &pszDest);
    return (unsigned __int8)result;
  }
  RtlSetLastWin32Error(123);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E751BC: using guessed type wchar_t aW[3];

//----- (77E751C7) --------------------------------------------------------
BOOL __stdcall FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
{
  BOOL v1; // edi@3
  BOOL result; // eax@5

  if ( hFindVolumeMountPoint != (HANDLE)-1 && hFindVolumeMountPoint )
  {
    v1 = CloseHandle(*(HANDLE *)hFindVolumeMountPoint);
    if ( v1 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, hFindVolumeMountPoint);
    result = v1;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75215) --------------------------------------------------------
BOOL __stdcall DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
{
  BOOL result; // eax@1
  BOOL v2; // esi@2
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszVolumeMountPoint);
  if ( result )
  {
    v2 = DeleteVolumeMountPointW(UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v2;
  }
  return result;
}

//----- (77E7524D) --------------------------------------------------------
HANDLE __stdcall FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
{
  unsigned int v2; // esi@1
  WCHAR *v3; // eax@1
  int v4; // eax@5
  NTSTATUS v5; // eax@5
  unsigned __int16 v7; // [sp+10h] [bp-2Ch]@1
  __int16 v8; // [sp+12h] [bp-2Ah]@1
  LPSTR v9; // [sp+14h] [bp-28h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@1
  HANDLE v11; // [sp+20h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1
  LPSTR lpszVolumeNamea; // [sp+44h] [bp+8h]@1
  DWORD cchBufferLengtha; // [sp+48h] [bp+Ch]@1

  v9 = lpszVolumeName;
  v2 = cchBufferLength;
  v7 = cchBufferLength - 1;
  v8 = cchBufferLength;
  DestinationString.Buffer = 0;
  DestinationString.Length = 0;
  DestinationString.MaximumLength = 0;
  ms_exc.registration.TryLevel = 0;
  lpszVolumeNamea = (LPSTR)(unsigned __int16)(2 * cchBufferLength);
  cchBufferLengtha = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v3 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  cchBufferLengtha,
                  (unsigned __int16)lpszVolumeNamea);
  DestinationString.Buffer = v3;
  if ( !v3 )
  {
    RtlSetLastWin32Error(8);
LABEL_3:
    v11 = (HANDLE)-1;
    goto LABEL_11;
  }
  DestinationString.MaximumLength = (unsigned __int16)lpszVolumeNamea;
  v11 = FindFirstVolumeW(v3, v2);
  if ( v11 != (HANDLE)-1 )
  {
    RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
    v4 = KernelBaseGetGlobalData();
    v5 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v4 + 28))(&v7, &DestinationString, 0);
    if ( v5 < 0 )
    {
      BaseSetLastNTError(v5);
      goto LABEL_3;
    }
    if ( v7 >= v2 )
    {
      BaseSetLastNTError(-2147483643);
      goto LABEL_3;
    }
    v9[v7] = 0;
  }
LABEL_11:
  ms_exc.registration.TryLevel = -2;
  if ( DestinationString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
  return v11;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75379) --------------------------------------------------------
BOOL __stdcall FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
{
  unsigned int v3; // esi@1
  WCHAR *v4; // eax@1
  int v5; // eax@5
  NTSTATUS v6; // eax@5
  unsigned __int16 v8; // [sp+10h] [bp-2Ch]@1
  __int16 v9; // [sp+12h] [bp-2Ah]@1
  LPSTR v10; // [sp+14h] [bp-28h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@1
  int v12; // [sp+20h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1
  LPSTR lpszVolumeNamea; // [sp+48h] [bp+Ch]@1
  DWORD cchBufferLengtha; // [sp+4Ch] [bp+10h]@1

  v10 = lpszVolumeName;
  v3 = cchBufferLength;
  v8 = cchBufferLength - 1;
  v9 = cchBufferLength;
  DestinationString.Buffer = 0;
  DestinationString.Length = 0;
  DestinationString.MaximumLength = 0;
  ms_exc.registration.TryLevel = 0;
  lpszVolumeNamea = (LPSTR)(unsigned __int16)(2 * cchBufferLength);
  cchBufferLengtha = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v4 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  cchBufferLengtha,
                  (unsigned __int16)lpszVolumeNamea);
  DestinationString.Buffer = v4;
  if ( !v4 )
  {
    RtlSetLastWin32Error(8);
LABEL_3:
    v12 = 0;
    goto LABEL_11;
  }
  DestinationString.MaximumLength = (unsigned __int16)lpszVolumeNamea;
  v12 = FindNextVolumeW(hFindVolume, v4, v3);
  if ( v12 )
  {
    RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
    v5 = KernelBaseGetGlobalData();
    v6 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v5 + 28))(&v8, &DestinationString, 0);
    if ( v6 < 0 )
    {
      BaseSetLastNTError(v6);
      goto LABEL_3;
    }
    if ( v8 >= v3 )
    {
      BaseSetLastNTError(-2147483643);
      goto LABEL_3;
    }
    v10[v8] = 0;
  }
LABEL_11:
  ms_exc.registration.TryLevel = -2;
  if ( DestinationString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
  return v12;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E754A1) --------------------------------------------------------
int __stdcall FindNextVolumeMountPointHelper(int a1, void *Dst, int a3, ULONG FileInformationLength)
{
  int v4; // esi@1
  int v5; // esi@8
  NTSTATUS v6; // eax@6
  NTSTATUS v7; // esi@14
  int v8; // eax@17
  PVOID v9; // esi@17
  __int16 v10; // di@20
  __int16 v11; // dx@24
  int v12; // eax@50
  PVOID v13; // esi@50
  int result; // eax@57
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-5Ch]@12
  char FileInformation; // [sp+24h] [bp-44h]@6
  int v17; // [sp+28h] [bp-40h]@8
  int v18; // [sp+2Ch] [bp-3Ch]@8
  int v19; // [sp+30h] [bp-38h]@8
  int v20; // [sp+34h] [bp-34h]@6
  int v21; // [sp+38h] [bp-30h]@6
  int v22; // [sp+3Ch] [bp-2Ch]@6
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+40h] [bp-28h]@6
  __int16 v24; // [sp+48h] [bp-20h]@12
  __int16 v25; // [sp+4Ah] [bp-1Eh]@12
  char *v26; // [sp+4Ch] [bp-1Ch]@12
  __int16 v27; // [sp+50h] [bp-18h]@6
  __int16 v28; // [sp+52h] [bp-16h]@6
  int *v29; // [sp+54h] [bp-14h]@6
  DWORD BytesReturned; // [sp+58h] [bp-10h]@18
  int v31; // [sp+5Ch] [bp-Ch]@12
  int v32; // [sp+60h] [bp-8h]@1
  HANDLE FileHandle; // [sp+64h] [bp-4h]@14
  ULONG FileInformationLengtha; // [sp+7Ch] [bp+14h]@51

  v4 = a1;
  v32 = 0;
  if ( a1 == -1 || !a1 || !Dst || !a3 )
  {
    RtlSetLastWin32Error(87);
    goto LABEL_60;
  }
  while ( 1 )
  {
    if ( FileInformationLength )
    {
      v21 = 0;
      v22 = 0;
      v28 = 12;
      v27 = 12;
      v29 = &v20;
      FileInformationLength = 0;
      v20 = -1610612733;
      v6 = NtQueryDirectoryFile(
             *(HANDLE *)v4,
             0,
             0,
             0,
             &IoStatusBlock,
             &FileInformation,
             0x10u,
             FileReparsePointInformation,
             1u,
             (PUNICODE_STRING)&v27,
             0);
    }
    else
    {
      if ( *(_DWORD *)(v4 + 16) )
      {
        v5 = v4 + 8;
        *(_DWORD *)&FileInformation = *(_DWORD *)v5;
        v5 += 4;
        v17 = *(_DWORD *)v5;
        v5 += 4;
        v18 = *(_DWORD *)v5;
        v19 = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(a1 + 16) = 0;
        v4 = a1;
        goto LABEL_11;
      }
      v6 = NtQueryDirectoryFile(
             *(HANDLE *)v4,
             0,
             0,
             0,
             &IoStatusBlock,
             &FileInformation,
             0x10u,
             FileReparsePointInformation,
             1u,
             0,
             0);
    }
    if ( v6 < 0 )
    {
      if ( v6 == -1073741809 )
        BaseSetLastNTError(-2147483642);
      else
        BaseSetLastNTError(v6);
      goto LABEL_60;
    }
LABEL_11:
    if ( v18 != -1610612733 )
    {
      RtlSetLastWin32Error(18);
      goto LABEL_60;
    }
    v24 = 8;
    v25 = 8;
    v26 = &FileInformation;
    ObjectAttributes.RootDirectory = *(HANDLE *)v4;
    ObjectAttributes.ObjectName = (PUNICODE_STRING)&v24;
    ObjectAttributes.Length = 24;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v31 = 17;
    if ( RtlAcquirePrivilege(&v31, 1, 0, &v32) < 0 )
      v32 = 0;
    v7 = NtOpenFile(&FileHandle, 0x100000u, &ObjectAttributes, &IoStatusBlock, 7u, 0x206000u);
    if ( v32 )
      RtlReleasePrivilege(v32);
    if ( v7 < 0 )
    {
      BaseSetLastNTError(v7);
      goto LABEL_60;
    }
    v8 = KernelBaseGetGlobalData();
    v9 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v8 + 44), 0x4000u);
    if ( !v9 )
      goto LABEL_49;
    if ( !DeviceIoControl(FileHandle, 0x900A8u, 0, 0, v9, 0x4000u, &BytesReturned, 0) || *(_DWORD *)v9 != -1610612733 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
      CloseHandle(FileHandle);
      goto LABEL_60;
    }
    v10 = *((_WORD *)v9 + 5);
    if ( (v10 == 96 || v10 == 98 && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 112) == 92)
      && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 16) == 92 )
    {
      v11 = *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 18);
      if ( (v11 == 63 || v11 == 92)
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 20) == 63
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 22) == 92
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 24) == 86
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 26) == 111
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 28) == 108
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 30) == 117
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 32) == 109
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 34) == 101
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 36) == 123
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 54) == 45
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 64) == 45
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 74) == 45
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 84) == 45
        && *(_WORD *)((char *)v9 + *((_WORD *)v9 + 4) + 110) == 125
        && v10 == 98
        && v11 == 63 )
        break;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
    CloseHandle(FileHandle);
    v4 = a1;
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
  v12 = KernelBaseGetGlobalData();
  v13 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v12 + 44), 2 * a3 + 2);
  if ( !v13 )
  {
LABEL_49:
    CloseHandle(FileHandle);
    RtlSetLastWin32Error(8);
    goto LABEL_60;
  }
  FileInformationLengtha = NtQueryInformationFile(FileHandle, &IoStatusBlock, v13, 2 * a3 + 2, FileNameInformation);
  if ( (FileInformationLengtha & 0x80000000) == 0 )
  {
    if ( (unsigned int)(*(_DWORD *)v13 - 2) > *(_DWORD *)v13 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
      CloseHandle(FileHandle);
      RtlSetLastWin32Error(111);
      goto LABEL_60;
    }
    memcpy(Dst, (char *)v13 + 6, *(_DWORD *)v13 - 2);
    *((_WORD *)Dst + (*(_DWORD *)v13 >> 1) - 1) = 92;
    *((_WORD *)Dst + (*(_DWORD *)v13 >> 1)) = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
    CloseHandle(FileHandle);
    result = 1;
  }
  else
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
    CloseHandle(FileHandle);
    if ( FileInformationLengtha == -2147483643 )
    {
      *(_DWORD *)(a1 + 8) = *(_DWORD *)&FileInformation;
      *(_DWORD *)(a1 + 12) = v17;
      *(_DWORD *)(a1 + 16) = v18;
      *(_DWORD *)(a1 + 20) = v19;
    }
    BaseSetLastNTError(FileInformationLengtha);
LABEL_60:
    result = 0;
  }
  return result;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75858) --------------------------------------------------------
HANDLE __stdcall FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
{
  HANDLE result; // eax@3
  NTSTATUS v4; // eax@4
  int v5; // eax@10
  int v6; // eax@11
  int v7; // eax@14
  PVOID v8; // esi@14
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-18h]@10
  UNICODE_STRING SourceString; // [sp+Ch] [bp-10h]@4
  LSA_UNICODE_STRING Destination; // [sp+14h] [bp-8h]@11
  HANDLE lpszRootPathNamea; // [sp+24h] [bp+8h]@13

  if ( !lpszRootPathName )
    goto LABEL_2;
  v4 = RtlInitUnicodeStringEx(&SourceString, lpszRootPathName);
  if ( v4 < 0 )
  {
    BaseSetLastNTError(v4);
    return (HANDLE)-1;
  }
  if ( SourceString.Buffer[((unsigned int)SourceString.Length >> 1) - 1] != 92 )
    goto LABEL_22;
  if ( GetDriveTypeW(lpszRootPathName) == 4 )
  {
LABEL_2:
    RtlSetLastWin32Error(87);
    return (HANDLE)-1;
  }
  RtlInitUnicodeString(&DestinationString, L"$Extend\\$Reparse:$R:$INDEX_ALLOCATION");
  v5 = DestinationString.Length + SourceString.Length + 2;
  if ( (unsigned int)v5 > 0xFFFF )
  {
LABEL_22:
    BaseSetLastNTError(-1073741773);
    return (HANDLE)-1;
  }
  Destination.MaximumLength = DestinationString.Length + SourceString.Length + 2;
  Destination.Length = 0;
  v6 = KernelBaseGetGlobalData();
  Destination.Buffer = (PWCH)RtlAllocateHeap(
                               NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                               *(_DWORD *)(v6 + 44),
                               Destination.MaximumLength);
  if ( !Destination.Buffer )
  {
    RtlSetLastWin32Error(8);
    return (HANDLE)-1;
  }
  RtlCopyUnicodeString(&Destination, &SourceString);
  RtlAppendUnicodeStringToString(&Destination, &DestinationString);
  Destination.Buffer[(unsigned int)Destination.Length >> 1] = 0;
  lpszRootPathNamea = CreateFileW(Destination.Buffer, 0x80000000, 1u, 0, 3u, 0x2020000u, 0);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Destination.Buffer);
  result = (HANDLE)-1;
  if ( lpszRootPathNamea != (HANDLE)-1 )
  {
    v7 = KernelBaseGetGlobalData();
    v8 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v7 + 44), 0x18u);
    if ( !v8 )
    {
      CloseHandle(lpszRootPathNamea);
      RtlSetLastWin32Error(8);
      return (HANDLE)-1;
    }
    memset(v8, 0, 0x18u);
    *(_DWORD *)v8 = lpszRootPathNamea;
    if ( !FindNextVolumeMountPointHelper((int)v8, lpszVolumeMountPoint, cchBufferLength, 1u) )
    {
      CloseHandle(*(HANDLE *)v8);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
      return (HANDLE)-1;
    }
    result = v8;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75A51) --------------------------------------------------------
int __stdcall IsThisAVolumeName(DWORD BytesReturned, int a2)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2
  int v4; // eax@5
  PVOID v5; // esi@5
  HANDLE v6; // edi@11
  signed int v7; // edi@12
  bool v8; // al@15
  char OutBuffer; // [sp+0h] [bp-28h]@14
  int v10; // [sp+4h] [bp-24h]@15
  UNICODE_STRING DestinationString; // [sp+20h] [bp-8h]@1

  v2 = RtlInitUnicodeStringEx(&DestinationString, (PCWSTR)BytesReturned);
  if ( v2 >= 0 )
  {
    if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] == 92 )
      DestinationString.Length -= 2;
    v4 = KernelBaseGetGlobalData();
    v5 = RtlAllocateHeap(
           NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
           *(_DWORD *)(v4 + 44),
           DestinationString.Length + 24);
    if ( v5 )
    {
      memset(v5, 0, 0x18u);
      *((_DWORD *)v5 + 4) = 24;
      *((_WORD *)v5 + 10) = DestinationString.Length;
      memcpy((char *)v5 + 24, DestinationString.Buffer, DestinationString.Length);
      if ( DestinationString.Length >= 4u && DestinationString.Buffer[1] == 92 )
        *(_WORD *)((char *)v5 + *((_DWORD *)v5 + 4) + 2) = 63;
      v6 = CreateFileW(L"\\\\.\\MountPointManager", 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
      if ( v6 == (HANDLE)-1 )
      {
        v7 = 0;
      }
      else
      {
        if ( DeviceIoControl(v6, 0x6D0008u, v5, DestinationString.Length + 24, &OutBuffer, 0x20u, &BytesReturned, 0) )
          v8 = v10 != 0;
        else
          v8 = GetLastError() == 234;
        *(_BYTE *)a2 = v8;
        CloseHandle(v6);
        v7 = 1;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
      result = v7;
    }
    else
    {
      RtlSetLastWin32Error(8);
      result = 0;
    }
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75B9F) --------------------------------------------------------
BOOL __stdcall FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
{
  return FindNextVolumeMountPointHelper((int)hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength, 0);
}

//----- (77E75BBD) --------------------------------------------------------
BOOL __stdcall GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
{
  BOOL result; // eax@1
  WCHAR *v4; // eax@2
  int v5; // eax@6
  NTSTATUS v6; // eax@6
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@1
  unsigned __int16 v8; // [sp+18h] [bp-2Ch]@2
  __int16 v9; // [sp+1Ah] [bp-2Ah]@2
  LPSTR v10; // [sp+1Ch] [bp-28h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+20h] [bp-24h]@2
  int v12; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@2
  LPSTR lpszVolumeNamea; // [sp+50h] [bp+Ch]@2

  v12 = 0;
  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszVolumeMountPoint);
  if ( result )
  {
    v10 = lpszVolumeName;
    v8 = cchBufferLength - 1;
    v9 = cchBufferLength;
    DestinationString.Buffer = 0;
    DestinationString.Length = 0;
    DestinationString.MaximumLength = 0;
    ms_exc.registration.TryLevel = 0;
    lpszVolumeNamea = *(LPSTR *)(KernelBaseGetGlobalData() + 44);
    v4 = (WCHAR *)RtlAllocateHeap(
                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                    (ULONG)lpszVolumeNamea,
                    (unsigned __int16)(2 * cchBufferLength));
    DestinationString.Buffer = v4;
    if ( !v4 )
    {
      RtlSetLastWin32Error(8);
LABEL_4:
      v12 = 0;
      goto LABEL_12;
    }
    DestinationString.MaximumLength = 2 * cchBufferLength;
    v12 = GetVolumeNameForVolumeMountPointW(UnicodeString.Buffer, v4, cchBufferLength);
    if ( v12 )
    {
      RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
      v5 = KernelBaseGetGlobalData();
      v6 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v5 + 28))(
             &v8,
             &DestinationString,
             0);
      if ( v6 < 0 )
      {
        BaseSetLastNTError(v6);
        goto LABEL_4;
      }
      if ( v8 >= cchBufferLength )
      {
        BaseSetLastNTError(-2147483643);
        goto LABEL_4;
      }
      v10[v8] = 0;
    }
LABEL_12:
    ms_exc.registration.TryLevel = -2;
    if ( DestinationString.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v12;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E75D09) --------------------------------------------------------
int __stdcall SetVolumeNameForRoot(HANDLE hDevice, PCWSTR SourceString)
{
  int v2; // eax@1
  PVOID v3; // ebx@1
  int result; // eax@2
  ULONG v5; // edi@3
  int v6; // eax@3
  PVOID v7; // eax@3
  PVOID v8; // esi@3
  BOOL v9; // edi@7
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-Ch]@3
  DWORD BytesReturned; // [sp+Ch] [bp-4h]@9
  HANDLE hDevicea; // [sp+18h] [bp+8h]@6

  v2 = KernelBaseGetGlobalData();
  v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v2 + 44), 0x1Eu);
  if ( v3 )
  {
    qmemcpy(v3, L"\\DosDevices\\", 0x18u);
    *((_WORD *)v3 + 12) = _toupper(*(_WORD *)hDevice);
    *((_WORD *)v3 + 13) = 58;
    *((_WORD *)v3 + 14) = 0;
    RtlInitUnicodeString(&DestinationString, SourceString);
    DestinationString.Length -= 2;
    v5 = DestinationString.Length + 36;
    v6 = KernelBaseGetGlobalData();
    v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), v5);
    v8 = v7;
    if ( v7 )
    {
      *(_WORD *)v7 = 8;
      *((_WORD *)v7 + 1) = 28;
      *((_WORD *)v7 + 2) = 36;
      *((_WORD *)v7 + 3) = DestinationString.Length;
      memcpy((char *)v7 + 8, v3, 0x1Cu);
      memcpy((char *)v8 + *((_WORD *)v8 + 2), DestinationString.Buffer, *((_WORD *)v8 + 3));
      *(_WORD *)((char *)v8 + *((_WORD *)v8 + 2) + 2) = 63;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
      hDevicea = CreateFileW(L"\\\\.\\MountPointManager", 0xC0000000, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
      if ( hDevicea == (HANDLE)-1 )
      {
        v9 = 0;
      }
      else
      {
        v9 = DeviceIoControl(hDevicea, 0x6DC000u, v8, v5, 0, 0, &BytesReturned, 0);
        CloseHandle(hDevicea);
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
      result = v9;
    }
    else
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
      RtlSetLastWin32Error(8);
      result = 0;
    }
  }
  else
  {
    RtlSetLastWin32Error(8);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E61B5C: using guessed type wchar_t aDosdevices[13];

//----- (77E75EA0) --------------------------------------------------------
BOOL __stdcall SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
{
  LPCWSTR v2; // ebx@1
  NTSTATUS v3; // eax@5
  WCHAR v4; // dx@17
  WCHAR v6; // cx@43
  HANDLE v7; // eax@49
  __int16 v8; // bx@54
  int v9; // eax@54
  WCHAR *v10; // eax@58
  WCHAR v11; // cx@59
  int v12; // esi@60
  int v13; // eax@66
  PVOID v14; // eax@66
  PVOID v15; // esi@66
  BOOL v16; // edi@68
  DWORD BytesReturned; // [sp+Ch] [bp-438h]@1
  LPCWSTR lpFileName; // [sp+10h] [bp-434h]@1
  UNICODE_STRING DestinationString; // [sp+14h] [bp-430h]@1
  HANDLE hObject; // [sp+1Ch] [bp-428h]@50
  DWORD v21; // [sp+20h] [bp-424h]@1
  UNICODE_STRING v22; // [sp+24h] [bp-420h]@1
  _BYTE RootPathName[521]; // [sp+2Fh] [bp-415h]@1
  WCHAR FileName; // [sp+238h] [bp-20Ch]@53
  __int16 v25; // [sp+23Ah] [bp-20Ah]@60

  BytesReturned = 0;
  v2 = lpszVolumeMountPoint;
  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v22.Length = 0;
  *(_DWORD *)&v22.MaximumLength = 0;
  lpFileName = lpszVolumeMountPoint;
  v21 = (DWORD)lpszVolumeName;
  RootPathName[0] = 0;
  HIWORD(v22.Buffer) = 0;
  if ( !lpszVolumeMountPoint || !lpszVolumeName )
    goto LABEL_62;
  if ( GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint, (LPWSTR)&RootPathName[1], 0x104u)
    || GetLastError() == 206 )
  {
    RtlSetLastWin32Error(145);
    return 0;
  }
  v3 = RtlInitUnicodeStringEx(&DestinationString, lpszVolumeMountPoint);
  if ( v3 < 0 || (v3 = RtlInitUnicodeStringEx(&v22, (PCWSTR)v21), v3 < 0) )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  if ( !DestinationString.Length || !v22.Length )
    goto LABEL_62;
  if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] != 92
    || v22.Buffer[((unsigned int)v22.Length >> 1) - 1] != 92 )
  {
    BaseSetLastNTError(-1073741773);
    return 0;
  }
  if ( v22.Length != 96 && (v22.Length != 98 || v22.Buffer[48] != 92) )
    goto LABEL_62;
  if ( *v22.Buffer != 92 )
    goto LABEL_62;
  v4 = v22.Buffer[1];
  if ( v4 != 63 && v4 != 92 )
    goto LABEL_62;
  if ( v22.Buffer[2] != 63
    || v22.Buffer[3] != 92
    || v22.Buffer[4] != 86
    || v22.Buffer[5] != 111
    || v22.Buffer[6] != 108
    || v22.Buffer[7] != 117
    || v22.Buffer[8] != 109
    || v22.Buffer[9] != 101
    || v22.Buffer[10] != 123
    || v22.Buffer[19] != 45
    || v22.Buffer[24] != 45
    || v22.Buffer[29] != 45
    || v22.Buffer[34] != 45
    || v22.Buffer[47] != 125
    || v22.Length != 98
    || v4 != 92 )
    goto LABEL_62;
  if ( !IsThisAVolumeName(v21, (int)RootPathName) )
    return 0;
  if ( !RootPathName[0] )
    goto LABEL_62;
  if ( DestinationString.Length == 6 )
  {
    if ( DestinationString.Buffer[1] == 58 )
      return SetVolumeNameForRoot((HANDLE)v2, (PCWSTR)v21);
  }
  else if ( DestinationString.Length == 14 && *DestinationString.Buffer == 92 && DestinationString.Buffer[1] == 92 )
  {
    v6 = DestinationString.Buffer[2];
    if ( (v6 == 46 || v6 == 63) && DestinationString.Buffer[3] == 92 && DestinationString.Buffer[5] == 58 )
    {
      v2 = lpszVolumeMountPoint + 4;
      return SetVolumeNameForRoot((HANDLE)v2, (PCWSTR)v21);
    }
  }
  if ( GetDriveTypeW(lpszVolumeMountPoint) != 3 )
  {
LABEL_62:
    RtlSetLastWin32Error(87);
    return 0;
  }
  v7 = CreateFileW(L"\\\\.\\MountPointManager", 0xC0000000, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  if ( v7 == (HANDLE)-1 )
    return 0;
  CloseHandle(v7);
  hObject = CreateFileW(lpFileName, 0xC0000000, 3u, 0, 3u, 0x2200080u, (HANDLE)0xFFFFFFFF);
  if ( hObject == (HANDLE)-1 )
    return 0;
  if ( GetVolumePathNameW(lpFileName, (LPWSTR)&RootPathName[1], 0x104u) == 1 )
  {
    if ( RootPathName != (_BYTE *)-1 && &FileName )
    {
      v8 = 0;
      v9 = BasepGetVolumeNameForVolumeMountPoint((LPCWSTR)&RootPathName[1], &FileName, 260, 0);
      if ( !v9 )
        FileName = 0;
    }
    else
    {
      RtlSetLastWin32Error(87);
      v9 = 0;
      v8 = 0;
    }
    if ( v9 == 1 )
    {
      v10 = &FileName;
      do
      {
        v11 = *v10;
        ++v10;
      }
      while ( v11 != v8 );
      v12 = IsVolumeOnCluster(&FileName, ((char *)v10 - (char *)&v25) >> 1);
      if ( v12 != IsVolumeOnCluster(v22.Buffer, (unsigned int)v22.Length >> 1) )
      {
        CloseHandle(hObject);
        goto LABEL_62;
      }
      RtlSetLastWin32Error(0);
    }
  }
  v13 = KernelBaseGetGlobalData();
  v14 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v13 + 44), 0x4000u);
  v15 = v14;
  if ( !v14 )
  {
    CloseHandle(hObject);
    RtlSetLastWin32Error(8);
    return 0;
  }
  memset(v14, 0, 0x4000u);
  *(_DWORD *)v15 = -1610612733;
  *((_WORD *)v15 + 2) = 2 * v22.Length + 12;
  *((_WORD *)v15 + 3) = 0;
  *((_WORD *)v15 + 4) = 0;
  *((_WORD *)v15 + 5) = v22.Length;
  memcpy((char *)v15 + 16, v22.Buffer, v22.Length);
  *((_WORD *)v15 + 9) = 63;
  *((_WORD *)v15 + 6) = *((_WORD *)v15 + 5) + 2;
  *((_WORD *)v15 + 7) = v22.Length;
  memcpy((char *)v15 + *((_WORD *)v15 + 5) + 18, (char *)v15 + 16, v22.Length);
  v16 = DeviceIoControl(hObject, 0x900A4u, v15, *((_WORD *)v15 + 2) + 8, 0, 0, &BytesReturned, 0);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v15);
  CloseHandle(hObject);
  if ( v16 )
    NotifyMountMgr((PWSTR)lpFileName, (PCWSTR)v21, 1);
  return v16;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7638E) --------------------------------------------------------
BOOL __stdcall GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
{
  BOOL result; // eax@1
  WCHAR *v4; // eax@2
  int v5; // eax@6
  NTSTATUS v6; // eax@6
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@1
  unsigned __int16 v8; // [sp+18h] [bp-2Ch]@2
  __int16 v9; // [sp+1Ah] [bp-2Ah]@2
  LPSTR v10; // [sp+1Ch] [bp-28h]@2
  LSA_UNICODE_STRING DestinationString; // [sp+20h] [bp-24h]@2
  int v12; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@2
  LPSTR lpszVolumePathNamea; // [sp+50h] [bp+Ch]@2

  v12 = 0;
  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszFileName);
  if ( result )
  {
    v10 = lpszVolumePathName;
    v8 = cchBufferLength - 1;
    v9 = cchBufferLength;
    DestinationString.Buffer = 0;
    DestinationString.Length = 0;
    DestinationString.MaximumLength = 0;
    ms_exc.registration.TryLevel = 0;
    lpszVolumePathNamea = *(LPSTR *)(KernelBaseGetGlobalData() + 44);
    v4 = (WCHAR *)RtlAllocateHeap(
                    NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                    (ULONG)lpszVolumePathNamea,
                    (unsigned __int16)(2 * cchBufferLength));
    DestinationString.Buffer = v4;
    if ( !v4 )
    {
      RtlSetLastWin32Error(8);
LABEL_4:
      v12 = 0;
      goto LABEL_12;
    }
    DestinationString.MaximumLength = 2 * cchBufferLength;
    v12 = GetVolumePathNameW(UnicodeString.Buffer, v4, cchBufferLength);
    if ( v12 )
    {
      RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
      v5 = KernelBaseGetGlobalData();
      v6 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v5 + 28))(
             &v8,
             &DestinationString,
             0);
      if ( v6 < 0 )
      {
        BaseSetLastNTError(v6);
        goto LABEL_4;
      }
      if ( v8 >= cchBufferLength )
      {
        BaseSetLastNTError(-2147483643);
        goto LABEL_4;
      }
      v10[v8] = 0;
    }
LABEL_12:
    ms_exc.registration.TryLevel = -2;
    if ( DestinationString.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v12;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E764D9) --------------------------------------------------------
HANDLE __stdcall FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
{
  WCHAR *v4; // eax@3
  int v5; // eax@7
  NTSTATUS v6; // eax@7
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@1
  unsigned __int16 v8; // [sp+18h] [bp-2Ch]@3
  __int16 v9; // [sp+1Ah] [bp-2Ah]@3
  LPSTR v10; // [sp+1Ch] [bp-28h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+20h] [bp-24h]@3
  HANDLE v12; // [sp+28h] [bp-1Ch]@5
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@3
  LPSTR lpszVolumeMountPointa; // [sp+50h] [bp+Ch]@3

  if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszRootPathName) )
    return (HANDLE)-1;
  v10 = lpszVolumeMountPoint;
  v8 = cchBufferLength - 1;
  v9 = cchBufferLength;
  DestinationString.Buffer = 0;
  DestinationString.Length = 0;
  DestinationString.MaximumLength = 0;
  ms_exc.registration.TryLevel = 0;
  lpszVolumeMountPointa = *(LPSTR *)(KernelBaseGetGlobalData() + 44);
  v4 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  (ULONG)lpszVolumeMountPointa,
                  (unsigned __int16)(2 * cchBufferLength));
  DestinationString.Buffer = v4;
  if ( !v4 )
  {
    RtlSetLastWin32Error(8);
LABEL_5:
    v12 = (HANDLE)-1;
    goto LABEL_13;
  }
  DestinationString.MaximumLength = 2 * cchBufferLength;
  v12 = FindFirstVolumeMountPointW(UnicodeString.Buffer, v4, cchBufferLength);
  if ( v12 != (HANDLE)-1 )
  {
    RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
    v5 = KernelBaseGetGlobalData();
    v6 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v5 + 28))(&v8, &DestinationString, 0);
    if ( v6 < 0 )
    {
      BaseSetLastNTError(v6);
      goto LABEL_5;
    }
    if ( v8 >= cchBufferLength )
    {
      BaseSetLastNTError(-2147483643);
      goto LABEL_5;
    }
    v10[v8] = 0;
  }
LABEL_13:
  ms_exc.registration.TryLevel = -2;
  if ( DestinationString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
  RtlFreeUnicodeString(&UnicodeString);
  return v12;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E76629) --------------------------------------------------------
BOOL __stdcall FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
{
  unsigned int v3; // esi@1
  WCHAR *v4; // eax@1
  int v5; // eax@5
  NTSTATUS v6; // eax@5
  unsigned __int16 v8; // [sp+10h] [bp-2Ch]@1
  __int16 v9; // [sp+12h] [bp-2Ah]@1
  LPSTR v10; // [sp+14h] [bp-28h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-24h]@1
  int v12; // [sp+20h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1
  LPSTR lpszVolumeMountPointa; // [sp+48h] [bp+Ch]@1
  DWORD cchBufferLengtha; // [sp+4Ch] [bp+10h]@1

  v10 = lpszVolumeMountPoint;
  v3 = cchBufferLength;
  v8 = cchBufferLength - 1;
  v9 = cchBufferLength;
  DestinationString.Buffer = 0;
  DestinationString.Length = 0;
  DestinationString.MaximumLength = 0;
  ms_exc.registration.TryLevel = 0;
  lpszVolumeMountPointa = (LPSTR)(unsigned __int16)(2 * cchBufferLength);
  cchBufferLengtha = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
  v4 = (WCHAR *)RtlAllocateHeap(
                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                  cchBufferLengtha,
                  (unsigned __int16)lpszVolumeMountPointa);
  DestinationString.Buffer = v4;
  if ( !v4 )
  {
    RtlSetLastWin32Error(8);
LABEL_3:
    v12 = 0;
    goto LABEL_11;
  }
  DestinationString.MaximumLength = (unsigned __int16)lpszVolumeMountPointa;
  v12 = FindNextVolumeMountPointW(hFindVolumeMountPoint, v4, v3);
  if ( v12 )
  {
    RtlInitUnicodeString(&DestinationString, DestinationString.Buffer);
    v5 = KernelBaseGetGlobalData();
    v6 = (*(int (__stdcall **)(unsigned __int16 *, LSA_UNICODE_STRING *, _DWORD))(v5 + 28))(&v8, &DestinationString, 0);
    if ( v6 < 0 )
    {
      BaseSetLastNTError(v6);
      goto LABEL_3;
    }
    if ( v8 >= v3 )
    {
      BaseSetLastNTError(-2147483643);
      goto LABEL_3;
    }
    v10[v8] = 0;
  }
LABEL_11:
  ms_exc.registration.TryLevel = -2;
  if ( DestinationString.Buffer )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
  return v12;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E76751) --------------------------------------------------------
BOOL __stdcall SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
{
  BOOL result; // eax@1
  BOOL v3; // edi@4
  LSA_UNICODE_STRING v4; // [sp+0h] [bp-10h]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@1

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszVolumeMountPoint);
  if ( result )
  {
    if ( Basep8BitStringToDynamicUnicodeString((int)&v4, lpszVolumeName) )
    {
      v3 = SetVolumeMountPointW(UnicodeString.Buffer, v4.Buffer);
      RtlFreeUnicodeString(&v4);
    }
    else
    {
      v3 = 0;
    }
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  return result;
}

//----- (77E767AD) --------------------------------------------------------
BOOL __stdcall GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
{
  BOOL result; // eax@1
  DWORD v5; // edi@2
  __int16 v6; // si@2
  WCHAR *v7; // eax@3
  BOOL v8; // edi@7
  int v9; // eax@12
  NTSTATUS v10; // eax@12
  DWORD v11; // ecx@17
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@1
  unsigned __int16 v13; // [sp+18h] [bp-2Ch]@12
  __int16 v14; // [sp+1Ah] [bp-2Ah]@2
  LPCH v15; // [sp+1Ch] [bp-28h]@2
  __int16 v16; // [sp+20h] [bp-24h]@10
  __int64 v17; // [sp+22h] [bp-22h]@2
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@2

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszVolumeName);
  if ( result )
  {
    v15 = lpszVolumePathNames;
    v5 = cchBufferLength;
    v14 = cchBufferLength;
    *(_DWORD *)((char *)&v17 + 2) = 0;
    ms_exc.registration.TryLevel = 0;
    v6 = 2 * cchBufferLength;
    LODWORD(v17) = (unsigned __int16)(2 * cchBufferLength);
    if ( 2 * (_WORD)cchBufferLength )
    {
      lpszVolumePathNames = *(LPCH *)(KernelBaseGetGlobalData() + 44);
      v7 = (WCHAR *)RtlAllocateHeap(
                      NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                      (ULONG)lpszVolumePathNames,
                      (unsigned __int16)v17);
      *(_DWORD *)((char *)&v17 + 2) = v7;
      if ( !v7 )
      {
        RtlSetLastWin32Error(8);
        goto LABEL_5;
      }
    }
    else
    {
      v7 = 0;
      *(_DWORD *)((char *)&v17 + 2) = 0;
    }
    v8 = GetVolumePathNamesForVolumeNameW(UnicodeString.Buffer, v7, v5, (PDWORD)&lpszVolumeName);
    *(_DWORD *)((char *)&v17 + 6) = v8;
    if ( v8 )
    {
      v16 = 2 * (_WORD)lpszVolumeName;
    }
    else
    {
      if ( GetLastError() != 234 )
      {
LABEL_20:
        ms_exc.registration.TryLevel = -2;
        if ( *(_DWORD *)((char *)&v17 + 2) )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)((char *)&v17 + 2));
        RtlFreeUnicodeString(&UnicodeString);
        return *(_DWORD *)((char *)&v17 + 6);
      }
      v16 = v6;
    }
    v9 = KernelBaseGetGlobalData();
    v10 = (*(int (__stdcall **)(unsigned __int16 *, __int16 *, _DWORD))(v9 + 28))(&v13, &v16, 0);
    if ( v10 >= 0 || v10 == -2147483643 )
    {
      if ( lpcchReturnLength )
      {
        if ( v8 )
          v11 = v13;
        else
          v11 = 2 * (_DWORD)lpszVolumeName;
        *lpcchReturnLength = v11;
      }
      goto LABEL_20;
    }
    BaseSetLastNTError(v10);
LABEL_5:
    *(_DWORD *)((char *)&v17 + 6) = 0;
    goto LABEL_20;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E76911) --------------------------------------------------------
signed int __usercall sub_77E76911@<eax>(int a1@<eax>, int a2@<edi>)
{
  int *v2; // esi@1
  int v3; // ST10_4@7
  char v5; // al@9
  int v6; // ST10_4@11
  char v7; // bl@12
  char v8; // al@13
  int v9; // ST10_4@14
  char k; // al@22
  char j; // al@27
  char v12; // bl@34
  int i; // [sp+Ch] [bp-8h]@1
  char v14; // [sp+12h] [bp-2h]@9
  char v15; // [sp+13h] [bp-1h]@9

  v2 = *(int **)a2;
  for ( i = a1; ; a1 = i )
  {
    v12 = *(_BYTE *)a1;
    if ( !*(_BYTE *)a1 )
      break;
    if ( v12 == 35 )
    {
      *(_DWORD *)(a2 + 8) = v2;
      *(_DWORD *)(a2 + 12) = v2;
      for ( j = *(_BYTE *)v2; j && _isdigit(j); j = **(_BYTE **)(a2 + 12) )
        ++*(_DWORD *)(a2 + 12);
      --*(_DWORD *)(a2 + 12);
      v2 = *(int **)(a2 + 12);
      if ( *(_DWORD *)(a2 + 8) > (unsigned int)v2 )
        return 0;
      goto LABEL_32;
    }
    if ( v12 == 42 )
    {
      *(_DWORD *)(a2 + 8) = v2;
      *(_DWORD *)(a2 + 12) = v2;
      for ( k = *(_BYTE *)v2; k && k != 32; k = **(_BYTE **)(a2 + 12) )
        ++*(_DWORD *)(a2 + 12);
      --*(_DWORD *)(a2 + 12);
      v2 = *(int **)(a2 + 12);
LABEL_32:
      v2 = (int *)((char *)v2 + 1);
      goto LABEL_33;
    }
    if ( v12 == 64 )
    {
      if ( !*(_BYTE *)v2 )
        return 0;
      *(_DWORD *)(a2 + 12) = v2;
      *(_DWORD *)(a2 + 8) = v2;
      goto LABEL_32;
    }
    if ( v12 != 91 )
    {
      if ( !*(_BYTE *)v2 )
        return 0;
      v3 = _toupper(*(_BYTE *)v2);
      if ( v3 != _toupper(v12) )
        return 0;
      goto LABEL_32;
    }
    ++i;
    v15 = *(_BYTE *)i;
    v5 = *(_BYTE *)v2;
    v14 = *(_BYTE *)v2;
    if ( *(_BYTE *)v2 && v5 != 32 && (v6 = _toupper(v5), v6 == _toupper(v15)) )
    {
      v7 = v15;
      if ( v15 != 93 )
      {
        v8 = v14;
        do
        {
          v9 = _toupper(v8);
          if ( _toupper(v7) != v9 )
            return 0;
          v2 = (int *)((char *)v2 + 1);
          ++i;
          v7 = *(_BYTE *)i;
          v8 = *(_BYTE *)v2;
        }
        while ( *(_BYTE *)i != 93 );
      }
    }
    else if ( v15 != 93 )
    {
      do
        ++i;
      while ( *(_BYTE *)i != 93 );
    }
LABEL_33:
    ++i;
  }
  *(_DWORD *)(a2 + 4) = v2;
  return 1;
}

//----- (77E76A88) --------------------------------------------------------
int __usercall sub_77E76A88@<eax>(int result@<eax>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(result + 4);
  *(_DWORD *)result = v1;
  while ( *(_BYTE *)v1 == 32 )
  {
    ++*(_DWORD *)result;
    v1 = *(_DWORD *)result;
  }
  return result;
}

//----- (77E76A9E) --------------------------------------------------------
signed int __usercall sub_77E76A9E@<eax>(unsigned int a1@<eax>, int a2@<ecx>)
{
  bool v2; // zf@8

  if ( a1 > 0x6E )
  {
    if ( a1 > 0x960 )
    {
      if ( a1 != 4800 )
      {
        if ( a1 != 9600 )
        {
          v2 = a1 == 19200;
LABEL_29:
          if ( v2 )
          {
            *(_DWORD *)a2 = 19200;
            return 1;
          }
          goto LABEL_30;
        }
        goto LABEL_13;
      }
LABEL_32:
      *(_DWORD *)a2 = 4800;
      return 1;
    }
    if ( a1 == 2400 )
      goto LABEL_25;
    if ( a1 == 150 )
    {
LABEL_24:
      *(_DWORD *)a2 = 150;
      return 1;
    }
    if ( a1 != 300 )
    {
      if ( a1 != 600 )
      {
        if ( a1 == 1200 )
        {
LABEL_21:
          *(_DWORD *)a2 = 1200;
          return 1;
        }
LABEL_30:
        *(_DWORD *)a2 = a1;
        return 1;
      }
LABEL_22:
      *(_DWORD *)a2 = 600;
      return 1;
    }
LABEL_23:
    *(_DWORD *)a2 = 300;
    return 1;
  }
  if ( a1 == 110 )
  {
LABEL_14:
    *(_DWORD *)a2 = 110;
    return 1;
  }
  if ( a1 <= 0x18 )
  {
    if ( a1 != 24 )
    {
      if ( a1 != 11 )
      {
        if ( a1 != 12 )
        {
          if ( a1 != 15 )
          {
            v2 = a1 == 19;
            goto LABEL_29;
          }
          goto LABEL_24;
        }
        goto LABEL_21;
      }
      goto LABEL_14;
    }
LABEL_25:
    *(_DWORD *)a2 = 2400;
    return 1;
  }
  if ( a1 == 30 )
    goto LABEL_23;
  if ( a1 == 48 )
    goto LABEL_32;
  if ( a1 == 60 )
    goto LABEL_22;
  if ( a1 != 96 )
    goto LABEL_30;
LABEL_13:
  *(_DWORD *)a2 = 9600;
  return 1;
}

//----- (77E76B6A) --------------------------------------------------------
signed int __usercall sub_77E76B6A@<eax>(char a1@<al>, int a2@<esi>)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  int v5; // eax@4

  v2 = _tolower(a1) - 101;
  if ( v2 )
  {
    v3 = v2 - 8;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          if ( v5 != 4 )
            return 0;
          *(_BYTE *)a2 = 4;
        }
        else
        {
          *(_BYTE *)a2 = 1;
        }
      }
      else
      {
        *(_BYTE *)a2 = 0;
      }
    }
    else
    {
      *(_BYTE *)a2 = 3;
    }
  }
  else
  {
    *(_BYTE *)a2 = 2;
  }
  return 1;
}

//----- (77E76BAD) --------------------------------------------------------
signed int __userpurge sub_77E76BAD@<eax>(int *a1@<eax>, int *a2, int a3)
{
  int *v3; // edi@1
  signed int result; // eax@4

  v3 = a1;
  if ( _tolower(*(_BYTE *)a1) == 111 && _tolower(*((_BYTE *)v3 + 1)) == 110 && a2 == (int *)((char *)v3 + 1) )
  {
    result = 1;
    *(_BYTE *)a3 = 1;
    return result;
  }
  if ( _tolower(*(_BYTE *)v3) == 111
    && _tolower(*((_BYTE *)v3 + 1)) == 102
    && _tolower(*((_BYTE *)v3 + 2)) == 102
    && a2 == (int *)((char *)v3 + 2) )
  {
    *(_BYTE *)a3 = 0;
    return 1;
  }
  if ( _tolower(*(_BYTE *)v3) == 104 && _tolower(*((_BYTE *)v3 + 1)) == 115 && a2 == (int *)((char *)v3 + 2) )
  {
    *(_BYTE *)a3 = 2;
    return 1;
  }
  return 0;
}

//----- (77E76C56) --------------------------------------------------------
signed int __userpurge sub_77E76C56@<eax>(int *a1@<eax>, int *a2, int a3)
{
  int *v3; // edi@1
  signed int result; // eax@4

  v3 = a1;
  if ( _tolower(*(_BYTE *)a1) == 111 && _tolower(*((_BYTE *)v3 + 1)) == 110 && a2 == (int *)((char *)v3 + 1) )
  {
    result = 1;
    *(_BYTE *)a3 = 1;
    return result;
  }
  if ( _tolower(*(_BYTE *)v3) == 111
    && _tolower(*((_BYTE *)v3 + 1)) == 102
    && _tolower(*((_BYTE *)v3 + 2)) == 102
    && a2 == (int *)((char *)v3 + 2) )
  {
    *(_BYTE *)a3 = 0;
    return 1;
  }
  if ( _tolower(*(_BYTE *)v3) == 104 && _tolower(*((_BYTE *)v3 + 1)) == 115 && a2 == (int *)((char *)v3 + 2) )
  {
    *(_BYTE *)a3 = 2;
    return 1;
  }
  if ( _tolower(*(_BYTE *)v3) == 116 && _tolower(*((_BYTE *)v3 + 1)) == 103 && a2 == (int *)((char *)v3 + 2) )
  {
    *(_BYTE *)a3 = 3;
    return 1;
  }
  return 0;
}

//----- (77E76D2B) --------------------------------------------------------
int __stdcall sub_77E76D2B(int a1, int a2, PCWSTR SourceString, int a4, int a5, int a6)
{
  LSA_UNICODE_STRING DestinationString; // [sp+0h] [bp-10h]@1
  STRING AnsiString; // [sp+8h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, SourceString);
  if ( RtlUnicodeStringToAnsiString(&AnsiString, &DestinationString, 1u) >= 0 )
  {
    if ( sub_77E76911((int)AnsiString.Buffer, a6) )
    {
      sub_77E76A88(a6);
      if ( sub_77E76911((int)":", a6) )
        sub_77E76A88(a6);
    }
    RtlFreeAnsiString(&AnsiString);
  }
  return 0;
}

//----- (77E76D9B) --------------------------------------------------------
signed int __thiscall sub_77E76D9B(int this, int a2, int a3)
{
  int v3; // esi@1
  __int32 v4; // eax@2
  __int32 v6; // eax@11
  __int32 v7; // eax@20
  signed int v8; // eax@28
  int v9; // eax@33
  __int32 v10; // eax@36
  __int32 v11; // eax@42
  __int32 v12; // eax@51
  struct _RTL_QUERY_REGISTRY_TABLE QueryTable; // [sp+Ch] [bp-94h]@1
  int v14; // [sp+44h] [bp-5Ch]@56
  int v15; // [sp+48h] [bp-58h]@68
  int v16; // [sp+4Ch] [bp-54h]@1
  int v17; // [sp+50h] [bp-50h]@1
  int v18; // [sp+54h] [bp-4Ch]@1
  int v19; // [sp+58h] [bp-48h]@1
  int v20; // [sp+5Ch] [bp-44h]@2
  int v21; // [sp+60h] [bp-40h]@1
  int v22; // [sp+64h] [bp-3Ch]@1
  int v23; // [sp+68h] [bp-38h]@2
  int v24; // [sp+6Ch] [bp-34h]@2
  int v25; // [sp+70h] [bp-30h]@2
  int v26; // [sp+74h] [bp-2Ch]@1
  int v27; // [sp+78h] [bp-28h]@1
  int v28; // [sp+7Ch] [bp-24h]@1
  int v29; // [sp+80h] [bp-20h]@1
  int v30; // [sp+84h] [bp-1Ch]@1
  char v31; // [sp+8Ah] [bp-16h]@15
  char v32; // [sp+8Bh] [bp-15h]@7
  int v33; // [sp+8Ch] [bp-14h]@1
  int v34; // [sp+90h] [bp-10h]@1
  char *Str; // [sp+94h] [bp-Ch]@1
  int *v36; // [sp+98h] [bp-8h]@1
  unsigned __int8 v37; // [sp+9Dh] [bp-3h]@2
  unsigned __int8 v38; // [sp+9Eh] [bp-2h]@2
  char v39; // [sp+9Fh] [bp-1h]@18

  Str = 0;
  v36 = 0;
  v21 = 0;
  v17 = 0;
  v22 = 0;
  v16 = 0;
  v18 = 0;
  v28 = 0;
  v29 = 0;
  v19 = 0;
  v30 = 0;
  v27 = 0;
  v26 = 0;
  v34 = this;
  v33 = this;
  memset(&QueryTable.Flags, 0, 0x34u);
  QueryTable.EntryContext = &v33;
  QueryTable.QueryRoutine = (PRTL_QUERY_REGISTRY_ROUTINE)sub_77E76D2B;
  RtlQueryRegistryValues(4u, L"SERIALCOMM", &QueryTable, 0, 0);
  v3 = (int)"#";
  if ( sub_77E76911((int)"#", (int)&v33) )
  {
    v28 = 1;
    v29 = 1;
    v30 = 1;
    v27 = 1;
    v26 = 1;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v38 = 1;
    v37 = 1;
    v4 = _atol(Str);
    if ( !sub_77E76A9E(v4, (int)&v20) )
      return 0;
    v21 = 1;
    sub_77E76A88((int)&v33);
    if ( !sub_77E76911((int)",", (int)&v33) )
      goto LABEL_32;
    sub_77E76A88((int)&v33);
    if ( !sub_77E76911((int)",", (int)&v33) && sub_77E76911((int)"@", (int)&v33) )
    {
      if ( !sub_77E76B6A(*Str, (int)&v32) )
        return 0;
      v16 = 1;
      sub_77E76A88((int)&v33);
      v3 = (int)"#";
    }
    if ( !sub_77E76911((int)",", (int)&v33) )
      goto LABEL_32;
    sub_77E76A88((int)&v33);
    if ( sub_77E76911(v3, (int)&v33) )
    {
      v6 = _atol(Str);
      if ( v6 != 5 && v6 != 6 && v6 != 7 && v6 != 8 )
        return 0;
      v31 = v6;
      v17 = 1;
      sub_77E76A88((int)&v33);
    }
    if ( !sub_77E76911((int)",", (int)&v33) )
      goto LABEL_32;
    sub_77E76A88((int)&v33);
    if ( sub_77E76911((int)"1.5", (int)&v33) )
    {
      v39 = 1;
    }
    else
    {
      if ( !sub_77E76911(v3, (int)&v33) )
        goto LABEL_25;
      v7 = _atol(Str) - 1;
      if ( v7 )
      {
        if ( v7 != 1 )
          return 0;
        v39 = 2;
      }
      else
      {
        v39 = 0;
      }
    }
    v22 = 1;
    sub_77E76A88((int)&v33);
LABEL_25:
    if ( !sub_77E76911((int)",", (int)&v33) )
      goto LABEL_32;
    sub_77E76A88((int)&v33);
    if ( sub_77E76911((int)"x", (int)&v33) )
    {
      v24 = 0;
      v25 = 0;
      v28 = 1;
      v29 = 1;
      v30 = 1;
      v27 = 1;
      v26 = 1;
      v23 = 1;
      v38 = 1;
      v37 = 1;
    }
    else
    {
      v8 = sub_77E76911((int)"p", (int)&v33);
      v28 = 1;
      v29 = 1;
      v30 = 1;
      v27 = 1;
      v26 = 1;
      if ( !v8 )
      {
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v38 = 1;
        v37 = 1;
LABEL_32:
        if ( *(_BYTE *)v33 )
          return 0;
LABEL_33:
        v9 = a2;
        *(_DWORD *)(a2 + 4) = v20;
        goto LABEL_85;
      }
      v23 = 0;
      v24 = 1;
      v25 = 1;
      v38 = 2;
      v37 = 2;
    }
    sub_77E76A88((int)&v33);
    goto LABEL_32;
  }
  if ( !*(_BYTE *)v33 )
  {
    v9 = a2;
    goto LABEL_93;
  }
  do
  {
    if ( sub_77E76911((int)"BAUD=#", (int)&v33) )
    {
      v10 = _atol(Str);
      if ( !sub_77E76A9E(v10, (int)&v20) )
        return 0;
      v21 = 1;
      goto LABEL_81;
    }
    if ( !sub_77E76911((int)"PARITY=@", (int)&v33) )
    {
      if ( sub_77E76911((int)"DATA=#", (int)&v33) )
      {
        v11 = _atol(Str);
        if ( v11 != 5 && v11 != 6 && v11 != 7 && v11 != 8 )
          return 0;
        v31 = v11;
        v17 = 1;
      }
      else
      {
        if ( sub_77E76911((int)"STOP=1.5", (int)&v33) )
        {
          v39 = 1;
        }
        else
        {
          if ( !sub_77E76911((int)"STOP=#", (int)&v33) )
          {
            if ( sub_77E76911((int)"TO=ON", (int)&v33) )
            {
              v18 = 1;
              v14 = 1;
            }
            else if ( sub_77E76911((int)"TO=OFF", (int)&v33) )
            {
              v18 = 1;
              v14 = 0;
            }
            else if ( sub_77E76911((int)"XON=ON", (int)&v33) )
            {
              v28 = 1;
              v23 = 1;
            }
            else if ( sub_77E76911((int)"XON=OFF", (int)&v33) )
            {
              v28 = 1;
              v23 = 0;
            }
            else if ( sub_77E76911((int)"ODSR=ON", (int)&v33) )
            {
              v29 = 1;
              v24 = 1;
            }
            else if ( sub_77E76911((int)"ODSR=OFF", (int)&v33) )
            {
              v29 = 1;
              v24 = 0;
            }
            else if ( sub_77E76911((int)"IDSR=ON", (int)&v33) )
            {
              v19 = 1;
              v15 = 1;
            }
            else if ( sub_77E76911((int)"IDSR=OFF", (int)&v33) )
            {
              v19 = 1;
              v15 = 0;
            }
            else if ( sub_77E76911((int)"OCTS=ON", (int)&v33) )
            {
              v30 = 1;
              v25 = 1;
            }
            else if ( sub_77E76911((int)"OCTS=OFF", (int)&v33) )
            {
              v30 = 1;
              v25 = 0;
            }
            else if ( sub_77E76911((int)"DTR=*", (int)&v33) )
            {
              if ( !sub_77E76BAD((int *)Str, v36, (int)&v38) )
                return 0;
              v27 = 1;
            }
            else
            {
              if ( !sub_77E76911((int)"RTS=*", (int)&v33) || !sub_77E76C56((int *)Str, v36, (int)&v37) )
                return 0;
              v26 = 1;
            }
            goto LABEL_81;
          }
          v12 = _atol(Str) - 1;
          if ( v12 )
          {
            if ( v12 != 1 )
              return 0;
            v39 = 2;
          }
          else
          {
            v39 = 0;
          }
        }
        v22 = 1;
      }
LABEL_81:
      sub_77E76A88((int)&v33);
      continue;
    }
    if ( !sub_77E76B6A(*Str, (int)&v32) )
      return 0;
    v16 = 1;
    sub_77E76A88((int)&v33);
  }
  while ( *(_BYTE *)v33 );
  if ( v21 )
    goto LABEL_33;
  v9 = a2;
LABEL_85:
  if ( v17 )
    *(_BYTE *)(v9 + 18) = v31;
  if ( v22 )
  {
    *(_BYTE *)(v9 + 20) = v39;
    goto LABEL_94;
  }
  if ( v21 && v20 == 110 )
  {
    *(_BYTE *)(v9 + 20) = 2;
    goto LABEL_94;
  }
LABEL_93:
  *(_BYTE *)(v9 + 20) = 0;
LABEL_94:
  if ( v16 )
    *(_BYTE *)(v9 + 19) = v32;
  if ( v28 )
  {
    if ( v23 )
      *(_DWORD *)(v9 + 8) |= 0x300u;
    else
      *(_DWORD *)(v9 + 8) &= 0xFFFFFCFF;
  }
  if ( v30 )
  {
    if ( v25 )
      *(_DWORD *)(v9 + 8) |= 4u;
    else
      *(_DWORD *)(v9 + 8) &= 0xFFFFFFFB;
  }
  if ( v29 )
  {
    if ( v24 )
      *(_DWORD *)(v9 + 8) |= 8u;
    else
      *(_DWORD *)(v9 + 8) &= 0xFFFFFFF7;
  }
  if ( v19 )
  {
    if ( v15 )
      *(_DWORD *)(v9 + 8) |= 0x40u;
    else
      *(_DWORD *)(v9 + 8) &= 0xFFFFFFBF;
  }
  if ( v27 )
    *(_DWORD *)(v9 + 8) ^= (*(_DWORD *)(v9 + 8) ^ 16 * v38) & 0x30;
  if ( v26 )
    *(_DWORD *)(v9 + 8) ^= (*(_DWORD *)(v9 + 8) ^ (v37 << 12)) & 0x3000;
  if ( v18 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 12) = 0;
    if ( v14 )
      *(_DWORD *)(a3 + 16) = 60000;
    else
      *(_DWORD *)(a3 + 16) = 0;
  }
  return 1;
}

//----- (77E77477) --------------------------------------------------------
BOOL __stdcall BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
{
  BOOL result; // eax@2

  if ( sub_77E76D9B((int)lpDef, (int)lpDCB, (int)lpCommTimeouts) )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E774A6) --------------------------------------------------------
BOOL __stdcall BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
{
  BOOL result; // eax@2
  char v3; // [sp+0h] [bp-14h]@1

  if ( sub_77E76D9B((int)lpDef, (int)lpDCB, (int)&v3) )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E774D9) --------------------------------------------------------
BOOL __stdcall BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  BOOL v5; // esi@3
  LSA_UNICODE_STRING DestinationString; // [sp+0h] [bp-10h]@1
  STRING AnsiString; // [sp+8h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, lpDef);
  v3 = RtlUnicodeStringToAnsiString(&AnsiString, &DestinationString, 1u);
  if ( v3 >= 0 )
  {
    v5 = BuildCommDCBAndTimeoutsA(AnsiString.Buffer, lpDCB, lpCommTimeouts);
    RtlFreeAnsiString(&AnsiString);
    result = v5;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}

//----- (77E77533) --------------------------------------------------------
BOOL __stdcall BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
{
  NTSTATUS v2; // eax@1
  BOOL result; // eax@2
  BOOL v4; // esi@3
  LSA_UNICODE_STRING DestinationString; // [sp+0h] [bp-10h]@1
  STRING AnsiString; // [sp+8h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, lpDef);
  v2 = RtlUnicodeStringToAnsiString(&AnsiString, &DestinationString, 1u);
  if ( v2 >= 0 )
  {
    v4 = BuildCommDCBA(AnsiString.Buffer, lpDCB);
    RtlFreeAnsiString(&AnsiString);
    result = v4;
  }
  else
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  return result;
}

//----- (77E7758A) --------------------------------------------------------
ULONG __stdcall BasepDoTapeOperation(HANDLE FileHandle, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength)
{
  HANDLE v6; // edi@1
  ULONG result; // eax@2
  NTSTATUS v8; // esi@3
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-8h]@3

  v6 = CreateEventA(0, 0, 0, 0);
  if ( v6 )
  {
    v8 = NtDeviceIoControlFile(
           FileHandle,
           v6,
           0,
           0,
           &IoStatusBlock,
           IoControlCode,
           InputBuffer,
           InputBufferLength,
           OutputBuffer,
           OutputBufferLength);
    if ( v8 == 259 )
    {
      WaitForSingleObject(v6, 0xFFFFFFFF);
      v8 = IoStatusBlock.u.Status;
    }
    CloseHandle(v6);
    if ( v8 >= 0 )
      result = 0;
    else
      result = BaseSetLastNTError(v8);
  }
  else
  {
    result = GetLastError();
  }
  return result;
}

//----- (77E77600) --------------------------------------------------------
DWORD __stdcall SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
{
  DWORD InputBuffer; // [sp+0h] [bp-18h]@1
  DWORD v8; // [sp+4h] [bp-14h]@1
  DWORD v9; // [sp+8h] [bp-10h]@1
  DWORD v10; // [sp+Ch] [bp-Ch]@1
  char v11; // [sp+10h] [bp-8h]@1

  InputBuffer = dwPositionMethod;
  v8 = dwPartition;
  v9 = dwOffsetLow;
  v10 = dwOffsetHigh;
  v11 = bImmediate;
  return BasepDoTapeOperation(hDevice, 0x1F4010u, &InputBuffer, 0x18u, 0, 0);
}

//----- (77E77646) --------------------------------------------------------
DWORD __stdcall GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
{
  DWORD result; // eax@1
  DWORD InputBuffer; // [sp+0h] [bp-10h]@1
  DWORD v7; // [sp+4h] [bp-Ch]@2
  DWORD v8; // [sp+8h] [bp-8h]@2
  DWORD v9; // [sp+Ch] [bp-4h]@2

  InputBuffer = dwPositionType;
  result = BasepDoTapeOperation(hDevice, 0x1F400Cu, &InputBuffer, 0x10u, &InputBuffer, 0x10u);
  if ( result )
  {
    *lpdwPartition = 0;
    *lpdwOffsetLow = 0;
    *lpdwOffsetHigh = 0;
  }
  else
  {
    *lpdwPartition = v7;
    *lpdwOffsetLow = v8;
    *lpdwOffsetHigh = v9;
  }
  return result;
}

//----- (77E776A2) --------------------------------------------------------
DWORD __stdcall PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
{
  DWORD InputBuffer; // [sp+0h] [bp-8h]@1
  char v5; // [sp+4h] [bp-4h]@1

  InputBuffer = dwOperation;
  v5 = bImmediate;
  return BasepDoTapeOperation(hDevice, 0x1F4004u, &InputBuffer, 8u, 0, 0);
}

//----- (77E776D5) --------------------------------------------------------
DWORD __stdcall EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
{
  DWORD InputBuffer; // [sp+0h] [bp-8h]@1
  char v5; // [sp+4h] [bp-4h]@1

  InputBuffer = dwEraseType;
  v5 = bImmediate;
  return BasepDoTapeOperation(hDevice, 0x1FC000u, &InputBuffer, 8u, 0, 0);
}

//----- (77E77708) --------------------------------------------------------
DWORD __stdcall CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
{
  DWORD InputBuffer; // [sp+0h] [bp-Ch]@1
  DWORD v6; // [sp+4h] [bp-8h]@1
  DWORD v7; // [sp+8h] [bp-4h]@1

  InputBuffer = dwPartitionMethod;
  v6 = dwCount;
  v7 = dwSize;
  return BasepDoTapeOperation(hDevice, 0x1FC028u, &InputBuffer, 0xCu, 0, 0);
}

//----- (77E77742) --------------------------------------------------------
DWORD __stdcall WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
{
  DWORD InputBuffer; // [sp+0h] [bp-Ch]@1
  DWORD v6; // [sp+4h] [bp-8h]@1
  char v7; // [sp+8h] [bp-4h]@1

  InputBuffer = dwTapemarkType;
  v6 = dwTapemarkCount;
  v7 = bImmediate;
  return BasepDoTapeOperation(hDevice, 0x1FC008u, &InputBuffer, 0xCu, 0, 0);
}

//----- (77E7777C) --------------------------------------------------------
DWORD __stdcall GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
{
  LPDWORD v5; // ecx@4
  ULONG v6; // [sp-14h] [bp-14h]@5
  LPVOID v7; // [sp-8h] [bp-8h]@5

  if ( !dwOperation )
  {
    v5 = lpdwSize;
    if ( *lpdwSize >= 0x20 )
    {
      v7 = lpTapeInformation;
      v6 = 2048028;
      return BasepDoTapeOperation(hDevice, v6, 0, 0, v7, 0x20u);
    }
LABEL_7:
    *v5 = 32;
    return 234;
  }
  if ( dwOperation != 1 )
    return 1;
  v5 = lpdwSize;
  if ( *lpdwSize < 0x20 )
    goto LABEL_7;
  v7 = lpTapeInformation;
  v6 = 2048020;
  return BasepDoTapeOperation(hDevice, v6, 0, 0, v7, 0x20u);
}

//----- (77E777D8) --------------------------------------------------------
DWORD __stdcall SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
{
  ULONG v4; // [sp-14h] [bp-14h]@4
  LPVOID v5; // [sp-10h] [bp-10h]@4
  ULONG v6; // [sp-Ch] [bp-Ch]@4

  if ( dwOperation )
  {
    if ( dwOperation != 1 )
      return 1;
    v6 = 8;
    v5 = lpTapeInformation;
    v4 = 2080792;
  }
  else
  {
    v6 = 4;
    v5 = lpTapeInformation;
    v4 = 2048032;
  }
  return BasepDoTapeOperation(hDevice, v4, v5, v6, 0, 0);
}

//----- (77E77819) --------------------------------------------------------
DWORD __stdcall GetTapeStatus(HANDLE hDevice)
{
  return BasepDoTapeOperation(hDevice, 0x1F4024u, 0, 0, 0, 0);
}

//----- (77E7783A) --------------------------------------------------------
HANDLE __stdcall OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
{
  NTSTATUS v4; // eax@4
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-24h]@6
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-Ch]@4
  HANDLE JobHandle; // [sp+20h] [bp-4h]@6

  if ( !lpName )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  RtlInitUnicodeString(&DestinationString, lpName);
  v4 = BaseGetNamedObjectDirectory((int)&lpName);
  if ( v4 < 0
    || (ObjectAttributes.RootDirectory = (HANDLE)lpName,
        ObjectAttributes.SecurityDescriptor = 0,
        ObjectAttributes.SecurityQualityOfService = 0,
        ObjectAttributes.Attributes = bInheritHandle != 0 ? 2 : 0,
        ObjectAttributes.ObjectName = &DestinationString,
        ObjectAttributes.Length = 24,
        BasepAdjustObjectAttributesForPrivateNamespace((int)&ObjectAttributes),
        v4 = NtOpenJobObject(&JobHandle, dwDesiredAccess, &ObjectAttributes),
        v4 < 0) )
  {
    BaseSetLastNTError(v4);
    return 0;
  }
  return JobHandle;
}

//----- (77E778C5) --------------------------------------------------------
BOOL __stdcall QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
{
  bool v5; // zf@2
  LPVOID v6; // esi@3
  BOOL v8; // ebx@8
  NTSTATUS v9; // eax@8
  char JobInformation; // [sp+8h] [bp-70h]@3
  int v11; // [sp+2Ch] [bp-4Ch]@11

  if ( JobObjectInformationClass == 2 )
  {
    v5 = cbJobObjectInformationLength == 48;
  }
  else
  {
    if ( JobObjectInformationClass != 9 )
    {
      v6 = lpJobObjectInformation;
      goto LABEL_8;
    }
    v5 = cbJobObjectInformationLength == 112;
  }
  v6 = &JobInformation;
  if ( !v5 )
  {
    BaseSetLastNTError(-1073741820);
    return 0;
  }
LABEL_8:
  v8 = 1;
  v9 = NtQueryInformationJobObject(hJob, JobObjectInformationClass, v6, cbJobObjectInformationLength, lpReturnLength);
  if ( v9 >= 0 )
  {
    if ( v6 != &JobInformation )
      return v8;
    if ( v11 == 1 )
    {
      v11 = 64;
      goto LABEL_23;
    }
    if ( v11 != 2 )
    {
      if ( v11 == 3 )
      {
        v11 = 128;
        goto LABEL_23;
      }
      if ( v11 == 4 )
      {
        v11 = 256;
        goto LABEL_23;
      }
      if ( v11 == 5 )
      {
        v11 = 0x4000;
        goto LABEL_23;
      }
      if ( v11 == 6 )
      {
        v11 = 0x8000;
LABEL_23:
        memcpy(lpJobObjectInformation, &JobInformation, cbJobObjectInformationLength);
        return v8;
      }
    }
    v11 = 32;
    goto LABEL_23;
  }
  v8 = 0;
  BaseSetLastNTError(v9);
  return v8;
}

//----- (77E77990) --------------------------------------------------------
BOOL __stdcall CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = NtCreateJobSet(NumJob, UserJobSet, Flags);
  if ( v3 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  return result;
}
// 77DE11AC: using guessed type int __stdcall NtCreateJobSet(_DWORD, _DWORD, _DWORD);

//----- (77E779BE) --------------------------------------------------------
HANDLE __stdcall CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
{
  HANDLE result; // eax@2
  HANDLE v3; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v3 = CreateJobObjectW(lpJobAttributes, UnicodeString.Buffer);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v3;
}

//----- (77E77A0B) --------------------------------------------------------
HANDLE __stdcall OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
{
  HANDLE result; // eax@2
  HANDLE v4; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@2

  if ( lpName )
  {
    result = (HANDLE)Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpName);
    if ( !result )
      return result;
  }
  else
  {
    UnicodeString.Buffer = 0;
  }
  v4 = OpenJobObjectW(dwDesiredAccess, bInheritHandle, UnicodeString.Buffer);
  if ( lpName )
    RtlFreeUnicodeString(&UnicodeString);
  return v4;
}

//----- (77E77A5B) --------------------------------------------------------
BOOL __stdcall CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int a4)
{
  BOOL v5; // [sp+10h] [bp-1Ch]@4

  if ( a4 != -1 && a4 )
  {
    if ( RtlGetCurrentTransaction() )
    {
      RtlSetLastWin32Error(6725);
      v5 = 0;
    }
    else
    {
      RtlSetCurrentTransaction(a4);
      v5 = CreateHardLinkW(lpFileName, lpExistingFileName, lpSecurityAttributes);
      RtlSetCurrentTransaction(0);
    }
  }
  else
  {
    RtlSetLastWin32Error(6700);
    v5 = 0;
  }
  return v5;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E77B01) --------------------------------------------------------
BOOL __stdcall CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
  BOOL result; // eax@1
  BOOL v4; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING v6; // [sp+8h] [bp-8h]@4

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpFileName);
  if ( result )
  {
    if ( lpExistingFileName )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&v6, lpExistingFileName) )
      {
        v4 = 0;
LABEL_6:
        RtlFreeUnicodeString(&UnicodeString);
        return v4;
      }
    }
    else
    {
      v6.Buffer = 0;
    }
    v4 = CreateHardLinkW(UnicodeString.Buffer, v6.Buffer, lpSecurityAttributes);
    if ( lpExistingFileName )
      RtlFreeUnicodeString(&v6);
    goto LABEL_6;
  }
  return result;
}

//----- (77E77B70) --------------------------------------------------------
int __stdcall CreateHardLinkTransactedA(int a1, int a2, LPSECURITY_ATTRIBUTES lpSecurityAttributes, int a4)
{
  int result; // eax@1
  int v5; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING v7; // [sp+8h] [bp-8h]@4

  result = Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, (PCSZ)a1);
  if ( result )
  {
    if ( a2 )
    {
      if ( !Basep8BitStringToDynamicUnicodeString((int)&v7, (PCSZ)a2) )
      {
        v5 = 0;
LABEL_6:
        RtlFreeUnicodeString(&UnicodeString);
        return v5;
      }
    }
    else
    {
      v7.Buffer = 0;
    }
    v5 = CreateHardLinkTransactedW(UnicodeString.Buffer, v7.Buffer, lpSecurityAttributes, a4);
    if ( a2 )
      RtlFreeUnicodeString(&v7);
    goto LABEL_6;
  }
  return result;
}

//----- (77E77BE2) --------------------------------------------------------
int __stdcall GetHandleContext(int a1)
{
  RtlSetLastWin32Error(120);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E77BF4) --------------------------------------------------------
int __stdcall CreateSocketHandle()
{
  RtlSetLastWin32Error(120);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E77C04) --------------------------------------------------------
BOOL __stdcall ZombifyActCtx(HANDLE hActCtx)
{
  NTSTATUS v1; // eax@1
  BOOL result; // eax@2

  v1 = RtlZombifyActivationContext(hActCtx);
  if ( v1 >= 0 )
  {
    result = 1;
  }
  else
  {
    BaseSetLastNTError(v1);
    result = 0;
  }
  return result;
}
// 77DE119C: using guessed type int __stdcall RtlZombifyActivationContext(_DWORD);

//----- (77E77C2C) --------------------------------------------------------
int __stdcall BasepRegenerateActCtxWithLanguage(int a1, LANGID a2, int a3)
{
  int v3; // ebx@3
  PVOID v4; // eax@5
  wchar_t *v5; // eax@9
  HANDLE v6; // eax@14
  ACTCTXW pActCtx; // [sp+Ch] [bp-34h]@1
  int v9; // [sp+2Ch] [bp-14h]@3
  int v10; // [sp+30h] [bp-10h]@3
  int v11; // [sp+34h] [bp-Ch]@11
  PVOID Address; // [sp+38h] [bp-8h]@1
  ULONG Size; // [sp+3Ch] [bp-4h]@1

  pActCtx.cbSize = 32;
  memset(&pActCtx.dwFlags, 0, 0x1Cu);
  Size = 0;
  Address = 0;
  if ( a3 && (*(_DWORD *)a3 = 0, a1 != -1) )
  {
    v9 = 1;
    v10 = 0;
    v3 = RtlQueryInformationActivationContext(0, a1, &v9, 3, 0, 0, &Size);
    if ( v3 != -1073741789 )
      return v3;
    if ( !Size )
      return v3;
    v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
    Address = v4;
    if ( !v4 )
      return v3;
    v3 = RtlQueryInformationActivationContext(0, a1, &v9, 3, v4, Size, &Size);
    if ( v3 >= 0 )
    {
      if ( a1 == -4 )
      {
        pActCtx.dwFlags |= 0x40u;
        pActCtx.lpSource = (LPCWSTR)*((_DWORD *)Address + 16);
      }
      else
      {
        pActCtx.lpSource = (LPCWSTR)*((_DWORD *)Address + 17);
        v5 = _wcsrchr(*((const wchar_t **)Address + 17), 0x2Eu);
        if ( !v5 || __wcsicmp(v5, L".Manifest") )
        {
          v3 = RtlQueryInformationActivationContext(0, a1, 0, 7, &v11, 4, &Size);
          if ( v3 < 0 )
            goto LABEL_18;
          if ( v11 )
          {
            pActCtx.dwFlags |= 8u;
            pActCtx.lpResourceName = (LPCWSTR)(unsigned __int16)v11;
          }
        }
      }
      pActCtx.dwFlags |= 2u;
      pActCtx.wLangId = a2;
      v6 = CreateActCtxW(&pActCtx);
      if ( v6 == (HANDLE)-1 )
      {
        v3 = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
      }
      else
      {
        *(_DWORD *)a3 = v6;
        v3 = 0;
      }
    }
  }
  else
  {
    v3 = -1073741811;
  }
LABEL_18:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v3;
}
// 77DE117C: using guessed type int __stdcall RtlQueryInformationActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E77DA5) --------------------------------------------------------
BOOL __stdcall FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
{
  int v5; // esi@1
  BOOL v6; // edi@1
  char v8; // [sp+8h] [bp-8h]@2

  v5 = 0;
  v6 = 0;
  if ( lpStringToFind )
  {
    if ( !Basep8BitStringToDynamicUnicodeString((int)&v8, lpStringToFind) )
      return v6;
    v5 = (int)&v8;
  }
  if ( BasepFindActCtxSectionString(dwFlags, (int)lpExtensionGuid, ulSectionId, v5, (int)ReturnedData) )
    v6 = 1;
  if ( v5 )
    RtlFreeUnicodeString((PUNICODE_STRING)v5);
  return v6;
}

//----- (77E77DFB) --------------------------------------------------------
BOOL __stdcall SdbIsValidQueryResultLight(int a1)
{
  return a1 && *(_DWORD *)(a1 + 168) <= 0x10u && *(_DWORD *)(a1 + 172) <= 8u;
}

//----- (77E77E29) --------------------------------------------------------
char __stdcall BasepQueryModuleDataEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  char v8; // bl@1
  char result; // al@2
  int (__stdcall *v10)(int, int, int, int, int, int, int, int); // [sp+4h] [bp-4h]@3

  v8 = 0;
  if ( BasepSkipSetupShims() )
  {
    result = 0;
  }
  else
  {
    if ( BasepGetApphelpParseModuleDataProc((int)&v10) >= 0 )
      v8 = v10(a1, a2, a3, a4, a5, a6, a7, a8);
    result = v8;
  }
  return result;
}

//----- (77E77E75) --------------------------------------------------------
int __stdcall SetComPlusPackageInstallStatus(int SystemInformation)
{
  NTSTATUS v2; // eax@4

  if ( SystemInformation & 0xFFFFFFFE )
  {
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  v2 = NtSetSystemInformation(
         SystemExceptionInformation|SystemProcessorPerformanceInformation|SystemPerformanceInformation|0x10,
         &SystemInformation,
         4u);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    return 0;
  }
  return 1;
}

//----- (77E77EB2) --------------------------------------------------------
int __stdcall GetComPlusPackageInstallStatus()
{
  int SystemInformation; // [sp+0h] [bp-4h]@1

  SystemInformation = v7FFE02E0;
  if ( v7FFE02E0 == -1
    && NtQuerySystemInformation(
         SystemExceptionInformation|SystemProcessorPerformanceInformation|SystemPerformanceInformation|0x10,
         &SystemInformation,
         4u,
         0) < 0 )
    SystemInformation = 0;
  return SystemInformation;
}

//----- (77E77EE7) --------------------------------------------------------
signed int __stdcall BaseCleanupAppcompatCacheSupport(int a1)
{
  RtlFreeUnicodeString(&gustrWindowsTemp);
  RtlFreeUnicodeString(&gustrSystemdriveTemp);
  return 1;
}

//----- (77E77F0A) --------------------------------------------------------
int __stdcall BaseDumpAppcompatCache()
{
  return NtApphelpCacheControl(4, 0);
}
// 77DE114C: using guessed type int __stdcall NtApphelpCacheControl(_DWORD, _DWORD);

//----- (77E77F1A) --------------------------------------------------------
signed int __stdcall BaseFlushAppcompatCache()
{
  signed int result; // eax@1

  result = IsCallerAdminOrSystem();
  if ( result )
    result = NtApphelpCacheControl(3, 0) >= 0;
  return result;
}
// 77DE114C: using guessed type int __stdcall NtApphelpCacheControl(_DWORD, _DWORD);

//----- (77E77F3D) --------------------------------------------------------
int __stdcall BaseCheckAppcompatCache(PCWSTR SourceString, HANDLE FileHandle, PVOID Environment, int a4)
{
  int v4; // ebx@1
  int v5; // esi@4

  v4 = a4;
  if ( a4 )
    a4 = *(_DWORD *)a4;
  else
    a4 = 0;
  v5 = BasepShimCacheLookup(SourceString, (int)FileHandle, (int)&a4, 0, 0);
  if ( !v5 )
    goto LABEL_16;
  if ( a4 & 0x200 )
    v5 = 0;
  if ( !v5 )
LABEL_16:
    a4 |= 1u;
  if ( BasepShimCacheCheckBypass(SourceString, FileHandle, Environment, 1, (int)&a4) )
  {
    v5 = 0;
    a4 |= 2u;
  }
  if ( v4 )
    *(_DWORD *)v4 = a4;
  return v5;
}

//----- (77E77FB6) --------------------------------------------------------
NTSTATUS __stdcall BasepGetApphelpParseModuleDataProc(int a1)
{
  NTSTATUS result; // eax@1
  int v2; // eax@2

  result = sub_77E32826();
  if ( result >= 0 )
  {
    v2 = RtlDecodeSystemPointer(dword_77EA6068);
    *(_DWORD *)a1 = v2;
    if ( v2 )
      result = 0;
    else
      result = -1073741823;
  }
  return result;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);
// 77EA6068: using guessed type int dword_77EA6068;

//----- (77E77FEB) --------------------------------------------------------
NTSTATUS __stdcall BaseRevertToSelf(int a1)
{
  NTSTATUS v1; // ebx@1
  int ThreadInformation; // [sp+Ch] [bp-8h]@1
  HANDLE TokenHandle; // [sp+10h] [bp-4h]@1

  v1 = 0;
  TokenHandle = 0;
  ThreadInformation = 0;
  *(_DWORD *)a1 = 0;
  if ( NtCurrentTeb()[1].Reserved1[1] )
  {
    v1 = NtOpenThreadToken((HANDLE)0xFFFFFFFE, 0x2000004u, 1u, &TokenHandle);
    if ( v1 >= 0 )
    {
      v1 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &ThreadInformation, 4u);
      if ( v1 >= 0 )
      {
        *(_DWORD *)a1 = TokenHandle;
        TokenHandle = 0;
      }
    }
    if ( TokenHandle )
      NtClose(TokenHandle);
  }
  return v1;
}

//----- (77E78065) --------------------------------------------------------
void __stdcall BaseRestoreImpersonation(int ThreadInformation)
{
  NTSTATUS v1; // eax@2

  if ( ThreadInformation )
  {
    v1 = NtSetInformationThread((HANDLE)0xFFFFFFFE, ThreadImpersonationToken, &ThreadInformation, 4u);
    if ( v1 < 0 )
      RtlRaiseStatus(v1);
  }
}

//----- (77E78094) --------------------------------------------------------
int __cdecl pfnWebBladeHashCompare(const void *a1, const void *a2)
{
  return memcmp((const char *)a1, (const char *)a2, 16);
}

//----- (77E780B8) --------------------------------------------------------
void __stdcall ApplicationRecoveryFinished(BOOL bSuccess)
{
  WerpRecoveryFinished(bSuccess);
}

//----- (77E780C8) --------------------------------------------------------
HRESULT __stdcall ApplicationRecoveryInProgress(PBOOL pbCancelled)
{
  return WerpRecoveryInProgress((int)pbCancelled);
}

//----- (77E780D8) --------------------------------------------------------
int __stdcall WerpInitiateRemoteRecovery(int a1)
{
  WerpRecoveryInvokedRemotely();
  return 0;
}

//----- (77E780E7) --------------------------------------------------------
HRESULT __stdcall WerRegisterFile(PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags)
{
  return WerpRegisterFile(pwzFile, regFileType, dwFlags);
}

//----- (77E780F7) --------------------------------------------------------
HRESULT __stdcall WerUnregisterFile(PCWSTR pwzFilePath)
{
  return WerpUnregisterFile(pwzFilePath);
}

//----- (77E78107) --------------------------------------------------------
HRESULT __stdcall WerRegisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext)
{
  return WerpRegisterRuntimeExceptionModule(pwszOutOfProcessCallbackDll, pContext);
}

//----- (77E78117) --------------------------------------------------------
HRESULT __stdcall WerUnregisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext)
{
  return WerpUnregisterRuntimeExceptionModule(pwszOutOfProcessCallbackDll, (int)pContext);
}

//----- (77E78127) --------------------------------------------------------
int __stdcall WerpNotifyLoadStringResource(HINSTANCE a1, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4)
{
  return RealWerpNotifyLoadStringResource(a1, a2, a3, a4);
}

//----- (77E78141) --------------------------------------------------------
int __stdcall WerpNotifyLoadStringResourceEx(HINSTANCE a1, unsigned int a2, unsigned __int16 *a3, unsigned __int32 a4, void **a5)
{
  return RealWerpNotifyLoadStringResourceEx(a1, a2, a3, a4, a5);
}

//----- (77E78151) --------------------------------------------------------
int __stdcall WerpStringLookup(unsigned __int16 *a1, void **a2)
{
  return RealWerpStringLookup(a1, a2);
}

//----- (77E78161) --------------------------------------------------------
int __stdcall QueryThreadCycleTime(HANDLE ThreadHandle, int a2)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2
  int ThreadInformation; // [sp+0h] [bp-10h]@1
  int v5; // [sp+4h] [bp-Ch]@2

  v2 = NtQueryInformationThread(ThreadHandle, ThreadCycleTime, &ThreadInformation, 0x10u, 0);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = ThreadInformation;
    *(_DWORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}

//----- (77E781A4) --------------------------------------------------------
int __stdcall QueryProcessCycleTime(HANDLE ProcessHandle, int a2)
{
  NTSTATUS v2; // eax@1
  int result; // eax@2
  int ProcessInformation; // [sp+0h] [bp-10h]@1
  int v5; // [sp+4h] [bp-Ch]@2

  v2 = NtQueryInformationProcess(ProcessHandle, ProcessCycleTime, &ProcessInformation, 0x10u, 0);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = ProcessInformation;
    *(_DWORD *)(a2 + 4) = v5;
    result = 1;
  }
  return result;
}

//----- (77E781E7) --------------------------------------------------------
int __stdcall QueryIdleProcessorCycleTime(PULONG ReturnLength, PVOID SystemInformation)
{
  NTSTATUS v2; // eax@1
  int result; // eax@3

  v2 = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)83, SystemInformation, *ReturnLength, ReturnLength);
  if ( v2 < 0 && SystemInformation )
  {
    BaseSetLastNTError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E7821D) --------------------------------------------------------
BOOL __stdcall QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@3

  v3 = NtQuerySystemInformationEx(83, &Group, 2, ProcessorIdleCycleTime, *BufferLength, BufferLength);
  if ( v3 < 0 && ProcessorIdleCycleTime )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1298: using guessed type int __stdcall NtQuerySystemInformationEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E78259) --------------------------------------------------------
BOOL __stdcall QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
{
  BOOL result; // eax@7

  if ( UnbiasedTime )
  {
    do
    {
      while ( v7FFE000C != v7FFE0010 )
        _mm_pause();
    }
    while ( v7FFE03B0 != v7FFE03B0 || v7FFE03B4 != v7FFE03B4 );
    *UnbiasedTime = v7FFE0008 - v7FFE03B0;
    result = 1;
  }
  else
  {
    BaseSetLastNTError(-1073741811);
    result = 0;
  }
  return result;
}
// 77E78259: could not find valid save-restore pair for edi
// 77E78259: could not find valid save-restore pair for esi

//----- (77E782D0) --------------------------------------------------------
BOOL __stdcall SetEnvironmentStringsA(LPCH NewEnvironment)
{
  LPCH v1; // eax@1
  LPCH v2; // esi@1
  int v3; // edx@1
  char v4; // cl@2
  char v5; // cl@7
  int v6; // edi@8
  int v8; // esi@11
  int v9; // esi@13
  STRING SourceString; // [sp+Ch] [bp-10h]@12
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-8h]@12

  v1 = NewEnvironment;
  v2 = NewEnvironment;
  v3 = (int)(NewEnvironment + 1);
  do
    v4 = *v1++;
  while ( v4 );
  while ( 1 )
  {
    v6 = (int)&v1[-v3];
    if ( v1 == (LPCH)v3 || !_strchr(v2 + 1, 61) )
      goto LABEL_9;
    v2 += v6 + 1;
    if ( !*v2 )
      break;
    v1 = v2;
    v3 = (int)(v2 + 1);
    do
      v5 = *v1++;
    while ( v5 );
  }
  v8 = v2 - NewEnvironment + 1;
  if ( (unsigned int)v8 > 0x7FFF
    || (SourceString.Length = v8,
        SourceString.Buffer = NewEnvironment,
        RtlOemStringToUnicodeString(&DestinationString, &SourceString, 1u) < 0)
    || (v9 = RtlSetEnvironmentStrings(DestinationString.Buffer, DestinationString.Length),
        RtlFreeUnicodeString(&DestinationString),
        v9 < 0) )
  {
LABEL_9:
    BaseSetLastNTError(-1073741811);
    return 0;
  }
  return 1;
}
// 77DE1130: using guessed type int __stdcall RtlSetEnvironmentStrings(_DWORD, _DWORD);

//----- (77E7837C) --------------------------------------------------------
BOOL __stdcall SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
{
  NTSTATUS v3; // eax@11
  char SystemInformation; // [sp+0h] [bp-24h]@11
  SIZE_T v6; // [sp+Ch] [bp-18h]@11
  SIZE_T v7; // [sp+10h] [bp-14h]@11
  int v8; // [sp+20h] [bp-4h]@3

  if ( Flags & 0xFFFFFFF0 )
  {
    BaseSetLastNTError(-1073741811);
  }
  else
  {
    v8 = 0;
    if ( Flags & 4 )
      v8 = 4;
    if ( Flags & 8 )
      v8 |= 8u;
    if ( Flags & 1 )
      v8 |= 1u;
    if ( Flags & 2 )
      v8 |= 2u;
    v6 = MinimumFileCacheSize;
    v7 = MaximumFileCacheSize;
    v3 = NtSetSystemInformation((SYSTEM_INFORMATION_CLASS)81, &SystemInformation, 0x24u);
    if ( v3 >= 0 )
      return 1;
    BaseSetLastNTError(v3);
  }
  return 0;
}

//----- (77E783EF) --------------------------------------------------------
BOOL __stdcall GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
{
  NTSTATUS v3; // eax@1
  char v4; // al@2
  DWORD v5; // edx@2
  BOOL result; // eax@6
  char SystemInformation; // [sp+0h] [bp-24h]@1
  int v8; // [sp+Ch] [bp-18h]@2
  int v9; // [sp+10h] [bp-14h]@2
  DWORD v10; // [sp+20h] [bp-4h]@2

  v3 = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)81, &SystemInformation, 0x24u, 0);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    *lpMinimumFileCacheSize = v8 * *(_DWORD *)(BaseStaticServerData + 300);
    *lpMaximumFileCacheSize = v9 * *(_DWORD *)(BaseStaticServerData + 300);
    v4 = v10;
    v5 = 0;
    *lpFlags = v10;
    if ( v4 & 4 )
      v5 = 4;
    if ( v4 & 1 )
      v5 |= 1u;
    *lpFlags = v5;
    result = 1;
  }
  return result;
}
// 77EA6094: using guessed type int BaseStaticServerData;

//----- (77E78463) --------------------------------------------------------
BOOL __stdcall AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = NtAllocateUserPhysicalPages(hProcess, NumberOfPages, PageArray);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E78491) --------------------------------------------------------
int __stdcall AllocateUserPhysicalPagesNuma(HANDLE ProcessHandle, PULONG NumberOfPages, PULONG PageFrameNumbers, int Node)
{
  NTSTATUS v4; // esi@4
  int v6; // [sp+Ch] [bp-1Ch]@3
  struct _GROUP_AFFINITY ProcessorMask; // [sp+18h] [bp-10h]@2

  if ( Node == -1
    || GetNumaNodeProcessorMaskEx(Node, &ProcessorMask)
    && SetThreadGroupAffinity((HANDLE)0xFFFFFFFE, &ProcessorMask, (int)&v6) )
  {
    v4 = NtAllocateUserPhysicalPages(ProcessHandle, NumberOfPages, PageFrameNumbers);
    if ( Node != -1 )
      SetThreadGroupAffinity((HANDLE)0xFFFFFFFE, &v6, 0);
    if ( v4 >= 0 )
      return 1;
    BaseSetLastNTError(v4);
  }
  return 0;
}

//----- (77E7851D) --------------------------------------------------------
BOOL __stdcall FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = NtFreeUserPhysicalPages(hProcess, NumberOfPages, PageArray);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E7854B) --------------------------------------------------------
BOOL __stdcall MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = NtMapUserPhysicalPages(VirtualAddress, (PULONG)NumberOfPages, PageArray);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E78579) --------------------------------------------------------
BOOL __stdcall MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2

  v3 = NtMapUserPhysicalPagesScatter(VirtualAddresses, (PULONG)NumberOfPages, PageArray);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E785A7) --------------------------------------------------------
UINT __stdcall GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, PULONG lpdwGranularity)
{
  NTSTATUS v6; // eax@1
  UINT result; // eax@2

  v6 = NtGetWriteWatch(
         (HANDLE)0xFFFFFFFF,
         dwFlags,
         lpBaseAddress,
         dwRegionSize,
         (PULONG)lpAddresses,
         lpdwCount,
         lpdwGranularity);
  if ( v6 < 0 )
  {
    BaseSetLastNTError(v6);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E785E0) --------------------------------------------------------
UINT __stdcall ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
{
  NTSTATUS v2; // eax@1
  UINT result; // eax@2

  v2 = NtResetWriteWatch((HANDLE)0xFFFFFFFF, lpBaseAddress, dwRegionSize);
  if ( v2 < 0 )
  {
    BaseSetLastNTError(v2);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7860D) --------------------------------------------------------
SIZE_T __stdcall GetLargePageMinimum()
{
  return v7FFE0244;
}

//----- (77E78618) --------------------------------------------------------
BOOL __stdcall QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
{
  NTSTATUS v2; // eax@4
  BOOL result; // eax@6
  char EventInformation; // [sp+4h] [bp-8h]@4
  int v5; // [sp+8h] [bp-4h]@6

  if ( ResourceNotificationHandle && ResourceNotificationHandle != (HANDLE)-1 && ResourceState )
  {
    v2 = NtQueryEvent(ResourceNotificationHandle, 0, &EventInformation, 8u, 0);
    if ( v2 >= 0 )
    {
      result = 1;
      *ResourceState = v5 == 1;
      return result;
    }
    BaseSetLastNTError(v2);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E78675) --------------------------------------------------------
BOOL __stdcall DeleteTimerQueue(HANDLE TimerQueue)
{
  BOOL result; // eax@2

  if ( DeleteTimerQueueEx(TimerQueue, 0) )
  {
    result = 1;
  }
  else
  {
    GetLastError();
    result = 0;
  }
  return result;
}

//----- (77E7869D) --------------------------------------------------------
BOOL __stdcall CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
{
  BOOL result; // eax@2

  if ( DeleteTimerQueueTimer(TimerQueue, Timer, 0) )
  {
    result = 1;
  }
  else
  {
    GetLastError();
    result = 0;
  }
  return result;
}

//----- (77E786C8) --------------------------------------------------------
signed int __stdcall SignalStartWerSvc()
{
  unsigned int v0; // esi@1
  signed int result; // eax@2
  __int16 v2; // [sp+8h] [bp-24h]@1
  int v3; // [sp+Ah] [bp-22h]@1
  int v4; // [sp+Eh] [bp-1Eh]@1
  int v5; // [sp+12h] [bp-1Ah]@1
  __int16 v6; // [sp+16h] [bp-16h]@1
  int v7; // [sp+18h] [bp-14h]@1
  __int16 v8; // [sp+1Ch] [bp-10h]@1
  __int16 v9; // [sp+1Eh] [bp-Eh]@1
  char v10; // [sp+20h] [bp-Ch]@1
  char v11; // [sp+21h] [bp-Bh]@1
  char v12; // [sp+22h] [bp-Ah]@1
  char v13; // [sp+23h] [bp-9h]@1
  char v14; // [sp+24h] [bp-8h]@1
  char v15; // [sp+25h] [bp-7h]@1
  char v16; // [sp+26h] [bp-6h]@1
  char v17; // [sp+27h] [bp-5h]@1

  v8 = 3156;
  v9 = 17545;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = -462492968;
  v10 = -104;
  v11 = -104;
  v12 = -113;
  v13 = -89;
  v14 = -99;
  v15 = 5;
  v16 = -98;
  v17 = 14;
  v0 = EtwEventWriteNoRegistration(&v7, &v2, 0, 0);
  if ( v0 == RtlNtStatusToDosError(-1073741054) )
  {
    result = -1073741696;
  }
  else
  {
    if ( (signed int)v0 > 0 )
      v0 = (unsigned __int16)v0 | 0xC0070000;
    result = v0;
  }
  return result;
}
// 77DE10F4: using guessed type int __stdcall EtwEventWriteNoRegistration(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E78772) --------------------------------------------------------
NTSTATUS __stdcall WaitForWerSvc()
{
  NTSTATUS result; // eax@1
  NTSTATUS v1; // esi@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+4h] [bp-2Ch]@1
  LARGE_INTEGER Timeout; // [sp+1Ch] [bp-14h]@2
  __int16 v4; // [sp+24h] [bp-Ch]@1
  __int16 v5; // [sp+26h] [bp-Ah]@1
  int v6; // [sp+28h] [bp-8h]@1
  HANDLE EventHandle; // [sp+2Ch] [bp-4h]@1

  v4 = 70;
  v5 = 72;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)&v4;
  v6 = (int)L"\\KernelObjects\\SystemErrorPortReady";
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = NtOpenEvent(&EventHandle, 0x100001u, &ObjectAttributes);
  if ( result >= 0 )
  {
    Timeout = (LARGE_INTEGER)-150000000i64;
    v1 = NtWaitForSingleObject(EventHandle, 0, &Timeout);
    NtClose(EventHandle);
    result = v1;
  }
  return result;
}
// 77E787F0: using guessed type wchar_t aKernelobjectsS[36];

//----- (77E7883D) --------------------------------------------------------
void __stdcall RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
{
  EXCEPTION_RECORD *v3; // esi@1
  struct _CONTEXT *v4; // edi@1
  NTSTATUS v5; // eax@8
  UINT v6; // ST14_4@14
  HANDLE v7; // eax@14
  int Dst; // [sp+8h] [bp-324h]@2
  int v9; // [sp+Ch] [bp-320h]@2
  void *v10; // [sp+14h] [bp-318h]@2
  ULONG MessageBoxResult; // [sp+58h] [bp-2D4h]@13
  CONTEXT ContextRecord; // [sp+5Ch] [bp-2D0h]@6
  void *retaddr; // [sp+330h] [bp+4h]@2

  v3 = pExceptionRecord;
  v4 = pContextRecord;
  if ( pExceptionRecord )
  {
    pExceptionRecord->ExceptionFlags |= 1u;
    if ( dwFlags & 1 )
      pExceptionRecord->ExceptionAddress = retaddr;
  }
  else
  {
    memset(&Dst, (int)pExceptionRecord, 0x50u);
    v3 = (EXCEPTION_RECORD *)&Dst;
    Dst = -1073740286;
    v9 = 1;
    v10 = retaddr;
  }
  if ( !pContextRecord )
  {
    memset(&ContextRecord, 0, 0x2CCu);
    v4 = &ContextRecord;
    RtlCaptureContext(&ContextRecord);
  }
  if ( SignalStartWerSvc() >= 0 && (v5 = WaitForWerSvc(), v5 >= 0) && v5 != 258 && v7FFE02F0 & 1 )
  {
    NtRaiseException(v3, v4, 0);
  }
  else
  {
    if ( !(dwFlags & 2) )
      NtRaiseHardError(v3->ExceptionCode | 0x10000000, 0, 0, 0, 1u, &MessageBoxResult);
    v6 = v3->ExceptionCode;
    v7 = GetCurrentProcess();
    TerminateProcess(v7, v6);
  }
}

//----- (77E7893F) --------------------------------------------------------
BOOL __stdcall InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
{
  DWORD v4; // edi@1
  DWORD v5; // eax@5
  PDWORD v7; // esi@7
  DWORD v8; // eax@9
  PCONTEXT_EX ContextEx; // [sp+4h] [bp-4h]@9

  v4 = ContextFlags;
  if ( (ContextFlags & 0x10000 || ContextFlags & 0x100000) && !RtlGetEnabledExtendedFeatures(0xFFFFFFFFFFFFFFFCui64) )
    v4 &= 0xFFFFFFBF;
  v5 = RtlGetExtendedContextLength(v4, &ContextFlags);
  if ( (v5 & 0x80000000) != 0 )
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v5);
    return 0;
  }
  v7 = ContextLength;
  if ( Buffer && *ContextLength >= ContextFlags )
  {
    v8 = RtlInitializeExtendedContext(Buffer, v4, &ContextEx);
    if ( (v8 & 0x80000000) == 0 )
    {
      *Context = RtlLocateLegacyContext(ContextEx, 0);
      *v7 = ContextFlags;
      return 1;
    }
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v8);
  }
  else
  {
    *ContextLength = ContextFlags;
    RtlSetLastWin32Error(122);
  }
  return 0;
}
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E789E1) --------------------------------------------------------
BOOL __stdcall CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
{
  int v3; // eax@1
  BOOL result; // eax@2

  v3 = RtlCopyContext(Destination, ContextFlags, Source);
  if ( v3 >= 0 )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v3);
    result = 0;
  }
  return result;
}
// 77DE10DC: using guessed type int __stdcall RtlCopyContext(_DWORD, _DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E78A10) --------------------------------------------------------
signed int __stdcall GetEnabledXStateFeatures()
{
  signed int result; // eax@1

  result = v7FFE03E0;
  if ( !v7FFE03E0 )
  {
    if ( v7FFE027A )
      result = 3;
    else
      result = 1;
  }
  return result;
}

//----- (77E78A38) --------------------------------------------------------
PVOID __stdcall LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
{
  ULONG v3; // eax@1
  struct _CONTEXT_EX *v4; // esi@1
  PVOID result; // eax@7

  v3 = Context->ContextFlags;
  v4 = 0;
  if ( Context->ContextFlags & 0x10000 )
  {
    if ( (v3 & 0x10040) == 65600 )
      v4 = (struct _CONTEXT_EX *)&Context[1];
    if ( !FeatureId )
    {
      if ( Length )
        *Length = 160;
      return Context->ExtendedRegisters;
    }
    if ( FeatureId == 1 )
    {
      if ( Length )
        *Length = 128;
      return &Context->ExtendedRegisters[160];
    }
    goto LABEL_23;
  }
  if ( !(v3 & 0x100000) )
    return 0;
  if ( (v3 & 0x100040) == 1048640 )
    v4 = (struct _CONTEXT_EX *)&Context[1].ExtendedRegisters[312];
  if ( FeatureId )
  {
    if ( FeatureId != 1 )
    {
LABEL_23:
      if ( v4 )
        return RtlLocateExtendedFeature(v4, FeatureId, Length);
      return 0;
    }
    if ( Length )
      *Length = 256;
    result = &Context->ExtendedRegisters[212];
  }
  else
  {
    if ( Length )
      *Length = 160;
    result = &Context->ExtendedRegisters[52];
  }
  return result;
}

//----- (77E78B00) --------------------------------------------------------
BOOL __stdcall GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
{
  ULONG v2; // eax@1
  int v3; // edi@1
  signed int v4; // esi@1
  struct _CONTEXT_EX *v5; // edx@2
  signed int v6; // ecx@4
  DWORD64 v7; // rax@12

  v2 = Context->ContextFlags;
  v3 = 0;
  v4 = 0;
  if ( Context->ContextFlags & 0x10000 )
  {
    v5 = (struct _CONTEXT_EX *)&Context[1];
    if ( (v2 & 0x10040) != 65600 )
      v5 = 0;
    v6 = 65568;
  }
  else
  {
    if ( !(v2 & 0x100000) )
    {
      RtlSetLastWin32ErrorAndNtStatusFromNtStatus(-1073741637);
      return 0;
    }
    v5 = (struct _CONTEXT_EX *)&Context[1].ExtendedRegisters[312];
    if ( (v2 & 0x100040) != 1048640 )
      v5 = 0;
    v6 = 1048584;
  }
  if ( (v6 & v2) == v6 )
  {
    v3 = 0;
    v4 = 3;
  }
  if ( v5 )
  {
    v7 = RtlGetExtendedFeaturesMask(v5);
    v4 |= v7;
    v3 = HIDWORD(v7);
  }
  *(_DWORD *)FeatureMask = v4;
  *((_DWORD *)FeatureMask + 1) = v3;
  return 1;
}
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E78B95) --------------------------------------------------------
BOOL __stdcall SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
{
  ULONG v2; // eax@1
  char *v3; // esi@1

  v2 = Context->ContextFlags;
  v3 = 0;
  if ( Context->ContextFlags & 0x10000 )
  {
    if ( (v2 & 0x10040) == 65600 )
      v3 = (char *)&Context[1];
    if ( FeatureMask & 3 )
    {
      Context->ContextFlags = v2 | 0x10020;
      if ( !v3 )
        goto LABEL_14;
      if ( *((_DWORD *)v3 + 3) < 0x2CCu )
        *((_DWORD *)v3 + 3) = 716;
    }
  }
  else
  {
    if ( !(v2 & 0x100000) )
    {
      RtlSetLastWin32ErrorAndNtStatusFromNtStatus(-1073741637);
      return 0;
    }
    if ( (v2 & 0x100040) == 1048640 )
      v3 = (char *)&Context[1].ExtendedRegisters[312];
    if ( FeatureMask & 3 )
      Context->ContextFlags = v2 | 0x100008;
  }
  if ( v3 )
    goto LABEL_17;
LABEL_14:
  if ( !(HIDWORD(FeatureMask) | FeatureMask & 0xFFFFFFFC) )
  {
    if ( !v3 )
      return 1;
LABEL_17:
    RtlSetExtendedFeaturesMask((PCONTEXT_EX)v3, FeatureMask);
    return 1;
  }
  RtlSetLastWin32ErrorAndNtStatusFromNtStatus(-1073741811);
  return 0;
}
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E78C56) --------------------------------------------------------
DWORD __stdcall EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
{
  NTSTATUS v4; // eax@1
  DWORD result; // eax@2

  v4 = RtlEnableThreadProfiling(ThreadHandle, Flags, HardwareCounters, HIDWORD(HardwareCounters), PerformanceDataHandle);
  if ( v4 >= 0 )
    result = 0;
  else
    result = RtlNtStatusToDosErrorNoTeb(v4);
  return result;
}
// 77DE10CC: using guessed type int __stdcall RtlEnableThreadProfiling(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E78C88) --------------------------------------------------------
DWORD __stdcall DisableThreadProfiling(HANDLE PerformanceDataHandle)
{
  NTSTATUS v1; // eax@1
  DWORD result; // eax@2

  v1 = RtlDisableThreadProfiling(PerformanceDataHandle);
  if ( v1 >= 0 )
    result = 0;
  else
    result = RtlNtStatusToDosErrorNoTeb(v1);
  return result;
}
// 77DE10C8: using guessed type int __stdcall RtlDisableThreadProfiling(_DWORD);

//----- (77E78CAE) --------------------------------------------------------
DWORD __stdcall QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
{
  NTSTATUS v2; // eax@1
  DWORD result; // eax@2

  v2 = RtlQueryThreadProfiling(ThreadHandle, Enabled);
  if ( v2 >= 0 )
    result = 0;
  else
    result = RtlNtStatusToDosErrorNoTeb(v2);
  return result;
}
// 77DE10C4: using guessed type int __stdcall RtlQueryThreadProfiling(_DWORD, _DWORD);

//----- (77E78CD7) --------------------------------------------------------
DWORD __stdcall ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
{
  NTSTATUS v3; // eax@1
  DWORD result; // eax@2

  v3 = RtlReadThreadProfilingData(PerformanceDataHandle, Flags, PerformanceData);
  if ( v3 >= 0 )
    result = 0;
  else
    result = RtlNtStatusToDosErrorNoTeb(v3);
  return result;
}
// 77E8A24B: using guessed type int __stdcall RtlReadThreadProfilingData(_DWORD, _DWORD, _DWORD);

//----- (77E78D02) --------------------------------------------------------
int __userpurge sub_77E78D02@<eax>(int a1@<ecx>, int a2@<ebx>, void *a3@<edi>, unsigned int Size, int a5, __int16 a6)
{
  unsigned int v6; // esi@1
  int v7; // eax@3
  int v8; // eax@8

  v6 = Size >> 1;
  if ( Size >> 1 && a6 & 0x1000 )
  {
    v7 = (int)((char *)a3 + 2 * a1);
    *(_DWORD *)a5 = v7;
    *(_DWORD *)a2 = v6 - a1;
    *(_WORD *)v7 = 0;
  }
  if ( a6 & 0x400 )
  {
    memset(a3, (unsigned __int8)a6, Size);
    if ( (_BYTE)a6 )
    {
      if ( !v6 )
        return 0;
      v8 = (int)((char *)a3 + 2 * v6 - 2);
      *(_DWORD *)a5 = v8;
      *(_DWORD *)a2 = 1;
      *(_WORD *)v8 = 0;
    }
    else
    {
      *(_DWORD *)a5 = a3;
      *(_DWORD *)a2 = v6;
    }
  }
  if ( v6 && a6 & 0x800 )
  {
    *(_DWORD *)a5 = a3;
    *(_DWORD *)a2 = v6;
    *(_WORD *)a3 = 0;
  }
  return 0;
}

//----- (77E78D99) --------------------------------------------------------
int __stdcall IsResUpdateAllowable(struct _UPDATEDATA *a1, const unsigned __int16 *a2, unsigned __int16 a3)
{
  int v3; // edx@1
  int v4; // edx@5
  bool v5; // zf@14
  int v6; // ecx@17
  int v7; // edx@19
  int v8; // edx@20
  int v9; // ecx@20
  int v10; // edx@25
  const unsigned __int16 *v11; // edi@26
  int i; // ecx@26
  unsigned int v13; // edx@29
  signed int v15; // [sp+0h] [bp-4h]@1

  v3 = *((_DWORD *)a1 + 4);
  v15 = 1;
  if ( v3 )
  {
    do
    {
      if ( !wcscmp(L"MUI", *(const unsigned __int16 **)(*(_DWORD *)(v3 + 4) + 16)) )
        break;
      v3 = *(_DWORD *)v3;
    }
    while ( v3 );
    if ( v3 )
    {
      v4 = *(_DWORD *)(v3 + 12);
      if ( v4 )
      {
        do
        {
          if ( 1 == *(_WORD *)(*(_DWORD *)(v4 + 4) + 4) )
            break;
          v4 = *(_DWORD *)v4;
        }
        while ( v4 );
        if ( v4 )
        {
          if ( *(_WORD *)(v4 + 30) != 1 || a3 && a3 != *(_WORD *)(v4 + 32) )
            return 0;
          if ( (unsigned int)a2 >= 0x10000 )
          {
            v5 = wcscmp(a2, L"MUI") == 0;
          }
          else
          {
            if ( a2 == (const unsigned __int16 *)16 )
              return v15;
            v5 = a2 == (const unsigned __int16 *)24;
          }
          if ( v5 )
            return v15;
          v6 = *(_DWORD *)(v4 + 24);
          if ( *(_BYTE *)(v6 + 16) & 2 )
            return 0;
          if ( (unsigned int)a2 >= 0x10000 )
          {
            v10 = *(_DWORD *)(v6 + 100);
            if ( v10 )
            {
              v11 = (const unsigned __int16 *)(v6 + v10);
              for ( i = *(_DWORD *)(v6 + 104) >> 1; i > 0 && *v11; i -= v13 )
              {
                if ( !wcscmp(v11, a2) )
                  return 0;
                v13 = wcslen(v11) + 1;
                if ( v13 == 1 )
                  break;
                v11 += v13;
              }
            }
          }
          else
          {
            v7 = *(_DWORD *)(v6 + 108);
            if ( v7 )
            {
              v8 = v6 + v7;
              v9 = *(_DWORD *)(v6 + 112) >> 2;
              while ( v9 > 0 )
              {
                --v9;
                if ( *(const unsigned __int16 **)v8 == a2 )
                  return 0;
                v8 += 4;
              }
            }
          }
        }
      }
    }
  }
  return v15;
}
// 77E61C40: using guessed type wchar_t aMui[4];

//----- (77E78F45) --------------------------------------------------------
void __stdcall FreeOne(PVOID Address)
{
  void *v1; // eax@1

  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)Address + 6));
  v1 = (void *)*((_DWORD *)Address + 1);
  *((_DWORD *)Address + 6) = 0;
  if ( *(_DWORD *)v1 == 2 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v1);
    *((_DWORD *)Address + 1) = 0;
  }
  if ( **((_DWORD **)Address + 3) == 2 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)Address + 3));
    *((_DWORD *)Address + 3) = 0;
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}

//----- (77E78FBF) --------------------------------------------------------
void __stdcall FreeStrings(struct _UPDATEDATA *a1)
{
  int v1; // esi@1
  int v2; // ebx@2

  v1 = *((_DWORD *)a1 + 1);
  if ( v1 )
  {
    do
    {
      v2 = *(_DWORD *)(v1 + 4);
      if ( *(_DWORD *)v1 == 1 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v1 + 16));
        *(_DWORD *)(v1 + 16) = 0;
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v1);
      v1 = v2;
    }
    while ( v2 );
  }
}

//----- (77E79019) --------------------------------------------------------
void __stdcall FreeData(struct _UPDATEDATA *a1)
{
  void *v1; // ST08_4@3
  int v2; // eax@2
  void *v3; // ST08_4@4
  int v4; // eax@5
  int v5; // esi@7
  void *v6; // ST08_4@11
  int v7; // eax@10
  void *v8; // ST08_4@12
  int v9; // eax@13
  int v10; // esi@15

  while ( 1 )
  {
    v5 = *((_DWORD *)a1 + 3);
    if ( !v5 )
      break;
    *((_DWORD *)a1 + 3) = *(_DWORD *)v5;
    while ( 1 )
    {
      v2 = *(_DWORD *)(v5 + 12);
      if ( !v2 )
        break;
      v1 = *(void **)(v5 + 12);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)v2;
      FreeOne(v1);
    }
    while ( 1 )
    {
      v4 = *(_DWORD *)(v5 + 16);
      if ( !v4 )
        break;
      v3 = *(void **)(v5 + 16);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)v4;
      FreeOne(v3);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v5);
  }
  while ( 1 )
  {
    v10 = *((_DWORD *)a1 + 4);
    if ( !v10 )
      break;
    *((_DWORD *)a1 + 4) = *(_DWORD *)v10;
    while ( 1 )
    {
      v7 = *(_DWORD *)(v10 + 12);
      if ( !v7 )
        break;
      v6 = *(void **)(v10 + 12);
      *(_DWORD *)(v10 + 12) = *(_DWORD *)v7;
      FreeOne(v6);
    }
    while ( 1 )
    {
      v9 = *(_DWORD *)(v10 + 16);
      if ( !v9 )
        break;
      v8 = *(void **)(v10 + 16);
      *(_DWORD *)(v10 + 16) = *(_DWORD *)v9;
      FreeOne(v8);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v10);
  }
  FreeStrings(a1);
}

//----- (77E790CC) --------------------------------------------------------
int __stdcall UpdateRCManifestID(unsigned __int32 *a1, unsigned __int32 a2, unsigned __int32 *a3, unsigned __int32 a4, const unsigned __int16 *a5, int a6, unsigned __int32 *a7)
{
  unsigned __int32 *v7; // esi@1
  unsigned __int32 *v8; // ebx@3
  unsigned __int32 v9; // edx@7
  unsigned __int32 v10; // eax@7
  unsigned __int32 v11; // ebx@14
  unsigned __int32 v12; // edi@22
  signed int v14; // [sp+Ch] [bp-4h]@1

  v7 = a1;
  v14 = 0;
  if ( !a1 || !a3 || (v8 = a7) == 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !a6 || a2 >= a4 )
  {
    v9 = *a7;
    v10 = a4 >> 2;
    if ( a6 )
    {
      if ( a2 < a4 + 4 )
        goto LABEL_6;
      if ( (signed int)v10 <= 0 )
        goto LABEL_29;
      do
      {
        --v10;
        if ( !v14 && *a3 >= (unsigned int)a5 )
        {
          if ( (const unsigned __int16 *)*a3 == a5 )
            return 0;
          *v7 = (unsigned __int32)a5;
          ++v7;
          v14 = 1;
          v9 += 4;
        }
        v11 = *a3;
        ++a3;
        *v7 = v11;
        ++v7;
        v9 += 4;
      }
      while ( (signed int)v10 > 0 );
      v8 = a7;
      if ( !v14 )
      {
LABEL_29:
        if ( a2 < v9 - *v8 + 4 )
          goto LABEL_6;
        *v7 = (unsigned __int32)a5;
        v9 += 4;
      }
    }
    else
    {
      while ( (signed int)v10 > 0 )
      {
        --v10;
        if ( (const unsigned __int16 *)*a3 == a5 )
        {
          ++a3;
        }
        else
        {
          if ( a2 < v9 - *v8 + 4 )
            goto LABEL_6;
          v12 = *a3;
          ++a3;
          v8 = a7;
          *v7 = v12;
          ++v7;
          v9 += 4;
        }
      }
    }
    *v8 = v9;
    return 1;
  }
LABEL_6:
  RtlSetLastWin32Error(111);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E791D3) --------------------------------------------------------
int __stdcall UpdateRCManifestName(unsigned __int16 *Dst, __int32 a2, const unsigned __int16 *a3, __int32 a4, const unsigned __int16 *Src, int a6, unsigned __int32 *a7)
{
  const unsigned __int16 *v7; // esi@2
  unsigned __int32 *v8; // edi@3
  unsigned __int32 v9; // ebx@10
  int v10; // eax@15
  size_t v11; // esi@18
  unsigned int v12; // edi@20
  int v13; // esi@21
  size_t v14; // esi@25
  unsigned int v15; // edi@31
  int v16; // esi@35
  unsigned int v18; // [sp+Ch] [bp-Ch]@10
  int v19; // [sp+10h] [bp-8h]@1
  signed int v20; // [sp+14h] [bp-4h]@1
  __int32 v21; // [sp+2Ch] [bp+14h]@10

  v20 = 0;
  v19 = 1;
  if ( !Dst )
    goto LABEL_45;
  v7 = a3;
  if ( !a3 )
    goto LABEL_45;
  v8 = a7;
  if ( !a7 || !Src )
    goto LABEL_45;
  if ( a6 && a2 < a4 )
    goto LABEL_7;
  if ( a2 < 0 || a4 < 0 )
  {
LABEL_45:
    RtlSetLastWin32Error(87);
    return 0;
  }
  v9 = *a7;
  v21 = (unsigned int)a4 >> 1;
  v18 = wcslen(Src);
  if ( !a6 )
  {
    if ( v21 > 0 )
    {
      while ( *v7 )
      {
        v15 = wcslen(v7) + 1;
        if ( v15 - v18 == 1 )
          v19 = wcscmp(v7, Src);
        if ( v19 )
        {
          v16 = 2 * v15;
          if ( v9 + 2 * v15 - *a7 > a2 )
            goto LABEL_7;
          memcpy(Dst, a3, 2 * v15);
          Dst = (unsigned __int16 *)((char *)Dst + v16);
          v9 += v16;
          a3 = (const unsigned __int16 *)((char *)a3 + v16);
        }
        else
        {
          a3 = &v7[v15];
          v19 = 1;
        }
        v21 -= v15;
        if ( v21 <= 0 )
          break;
        v7 = a3;
      }
    }
    goto LABEL_38;
  }
  if ( v21 > 0 )
  {
    while ( *v7 )
    {
      v10 = wcscmp(v7, Src);
      if ( !v10 )
        return 0;
      if ( !v20 && v10 > 0 )
      {
        v11 = 2 * wcslen(Src) + 2;
        if ( v9 + v11 - *a7 > a2 )
          goto LABEL_7;
        memcpy(Dst, Src, v11);
        Dst = (unsigned __int16 *)((char *)Dst + v11);
        v9 += v11;
        v7 = a3;
        v20 = 1;
      }
      v12 = wcslen(v7) + 1;
      if ( v12 == 1 )
        break;
      v13 = 2 * v12;
      if ( v9 + 2 * v12 - *a7 > a2 )
        goto LABEL_7;
      memcpy(Dst, a3, 2 * v12);
      v21 -= v12;
      Dst = (unsigned __int16 *)((char *)Dst + v13);
      a3 = (const unsigned __int16 *)((char *)a3 + v13);
      v9 += v13;
      if ( v21 <= 0 )
        break;
      v7 = a3;
    }
    if ( v20 )
      goto LABEL_38;
    v8 = a7;
  }
  v14 = 2 * wcslen(Src) + 2;
  if ( v9 + v14 - *v8 > a2 )
  {
LABEL_7:
    RtlSetLastWin32Error(111);
    return 0;
  }
  memcpy(Dst, Src, v14);
  Dst = (unsigned __int16 *)((char *)Dst + v14);
  v9 += v14;
LABEL_38:
  if ( v9 - *a7 + 2 <= a2 )
  {
    *Dst = 0;
    v9 += 2;
  }
  *a7 = v9;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7948D) --------------------------------------------------------
int __stdcall InternalUpdateRCManifest(struct _RC_CONFIG *a1, unsigned __int32 a2, struct _RC_CONFIG *a3, const unsigned __int16 *Src, int a5, int a6)
{
  struct _RC_CONFIG *v6; // eax@1
  struct _RC_CONFIG *v7; // ebx@2
  bool v9; // zf@7
  unsigned int v10; // esi@7
  unsigned int v11; // ecx@11
  int v12; // ST14_4@13
  struct _RC_CONFIG *v13; // esi@14
  struct _RC_CONFIG *v14; // edi@14
  unsigned int v15; // esi@17
  unsigned int v16; // ecx@23
  int v17; // ST14_4@24
  struct _RC_CONFIG *v18; // esi@25

  v6 = a1;
  if ( !a1 )
    return 0;
  v7 = a3;
  if ( !a3 )
    return 0;
  if ( a2 < 0x84 )
    goto LABEL_4;
  qmemcpy((void *)a1, (const void *)a3, 0x84u);
  *((_DWORD *)a1 + 1) = a2;
  v9 = *((_DWORD *)v7 + 17) == 0;
  v10 = 136;
  a3 = (struct _RC_CONFIG *)136;
  if ( !v9 )
  {
    *((_DWORD *)a1 + 17) = 136;
    memcpy((char *)a1 + 136, (char *)v7 + *((_DWORD *)v7 + 17), *((_DWORD *)v7 + 18));
    v6 = a1;
    v10 = ((*((_DWORD *)v7 + 18) + 7) & 0xFFFFFFF8) + 136;
    a3 = (struct _RC_CONFIG *)(((*((_DWORD *)v7 + 18) + 7) & 0xFFFFFFF8) + 136);
  }
  if ( *((_DWORD *)v7 + 19) )
  {
    *((_DWORD *)v6 + 19) = v10;
    memcpy((char *)v6 + v10, (char *)v7 + *((_DWORD *)v7 + 19), *((_DWORD *)v7 + 20));
    v10 += (*((_DWORD *)v7 + 20) + 7) & 0xFFFFFFF8;
    v6 = a1;
    a3 = (struct _RC_CONFIG *)v10;
  }
  v11 = *((_DWORD *)v6 + 1);
  if ( v10 >= v11 )
    goto LABEL_4;
  if ( a5 )
  {
    v12 = a6;
    *((_DWORD *)v6 + 21) = v10;
    if ( !UpdateRCManifestName(
            (unsigned __int16 *)((char *)v6 + v10),
            v11 - v10,
            (const unsigned __int16 *)((char *)v7 + *((_DWORD *)v7 + 21)),
            *((_DWORD *)v7 + 22),
            Src,
            v12,
            (unsigned __int32 *)&a3) )
      return 0;
    v13 = a3;
    v14 = a1;
    if ( (unsigned int)a3 >= *((_DWORD *)a1 + 1) )
      goto LABEL_4;
    v9 = a3 == *((struct _RC_CONFIG **)a1 + 21);
    *((_DWORD *)a1 + 22) = (char *)a3 - *((_DWORD *)a1 + 21);
    if ( v9 )
      *((_DWORD *)a1 + 21) = 0;
    v15 = (unsigned int)((char *)v13 + 7) & 0xFFFFFFF8;
    if ( *((_DWORD *)v7 + 23) )
    {
      *((_DWORD *)a1 + 23) = v15;
      memcpy((char *)a1 + v15, (char *)v7 + *((_DWORD *)v7 + 23), *((_DWORD *)v7 + 24));
      v15 += (*((_DWORD *)v7 + 24) + 7) & 0xFFFFFFF8;
    }
    if ( v15 >= *((_DWORD *)a1 + 1) )
    {
LABEL_4:
      RtlSetLastWin32Error(111);
      return 0;
    }
  }
  else
  {
    if ( *((_DWORD *)v7 + 21) )
    {
      *((_DWORD *)v6 + 21) = v10;
      memcpy((char *)v6 + v10, (char *)v7 + *((_DWORD *)v7 + 21), *((_DWORD *)v7 + 22));
      v10 += (*((_DWORD *)v7 + 22) + 7) & 0xFFFFFFF8;
      v6 = a1;
      a3 = (struct _RC_CONFIG *)v10;
    }
    v16 = *((_DWORD *)v6 + 1);
    if ( v10 >= v16 )
      goto LABEL_4;
    v17 = a6;
    *((_DWORD *)v6 + 23) = v10;
    if ( !UpdateRCManifestID(
            (unsigned __int32 *)((char *)v6 + v10),
            v16 - v10,
            (unsigned __int32 *)((char *)v7 + *((_DWORD *)v7 + 23)),
            *((_DWORD *)v7 + 24),
            Src,
            v17,
            (unsigned __int32 *)&a3) )
      return 0;
    v18 = a3;
    if ( (unsigned int)a3 >= *((_DWORD *)a1 + 1) )
      goto LABEL_4;
    v9 = a3 == *((struct _RC_CONFIG **)a1 + 23);
    *((_DWORD *)a1 + 24) = (char *)a3 - *((_DWORD *)a1 + 23);
    if ( v9 )
      *((_DWORD *)a1 + 23) = 0;
    v15 = (unsigned int)((char *)v18 + 3) & 0xFFFFFFFC;
    v14 = a1;
  }
  if ( *((_DWORD *)v7 + 25) )
  {
    *((_DWORD *)v14 + 25) = v15;
    memcpy((char *)v14 + v15, (char *)v7 + *((_DWORD *)v7 + 25), *((_DWORD *)v7 + 26));
    v15 += (*((_DWORD *)v7 + 26) + 7) & 0xFFFFFFF8;
  }
  if ( *((_DWORD *)v7 + 27) )
  {
    *((_DWORD *)v14 + 27) = v15;
    memcpy((char *)v14 + v15, (char *)v7 + *((_DWORD *)v7 + 27), *((_DWORD *)v7 + 28));
    v15 += (*((_DWORD *)v7 + 28) + 7) & 0xFFFFFFF8;
  }
  if ( v15 >= *((_DWORD *)v14 + 1) )
    goto LABEL_4;
  if ( *((_DWORD *)v7 + 29) )
  {
    *((_DWORD *)v14 + 29) = v15;
    memcpy((char *)v14 + v15, (char *)v7 + *((_DWORD *)v7 + 29), *((_DWORD *)v7 + 30));
    v15 += (*((_DWORD *)v7 + 30) + 7) & 0xFFFFFFF8;
  }
  if ( *((_DWORD *)v7 + 31) )
  {
    *((_DWORD *)v14 + 31) = v15;
    memcpy((char *)v14 + v15, (char *)v7 + *((_DWORD *)v7 + 31), *((_DWORD *)v7 + 32));
    v15 += (*((_DWORD *)v7 + 32) + 7) & 0xFFFFFFF8;
  }
  if ( v15 >= *((_DWORD *)v14 + 1) )
    goto LABEL_4;
  *((_DWORD *)v14 + 1) = v15;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E79720) --------------------------------------------------------
int __stdcall UpdateRCManifest(HGLOBAL hMem, const unsigned __int16 *Src, int a3)
{
  LPVOID v3; // eax@1
  int result; // eax@2
  int v5; // ecx@3
  int v6; // ebx@8
  unsigned int v7; // ecx@17
  unsigned int v8; // ecx@20
  int v9; // eax@22
  ULONG v10; // edi@24
  int v11; // eax@25
  struct _RC_CONFIG *v12; // eax@25
  struct _RC_CONFIG *v13; // esi@25
  bool v14; // zf@27
  PPEB v15; // eax@27
  PVOID Address; // [sp+4h] [bp-4h]@17
  int hMema; // [sp+10h] [bp+8h]@14

  v3 = GlobalLock(hMem);
  if ( !v3 )
    return 0;
  v5 = *((_DWORD *)v3 + 4);
  if ( !v5 )
    return 0;
  do
  {
    if ( !wcscmp(L"MUI", *(const unsigned __int16 **)(*(_DWORD *)(v5 + 4) + 16)) )
      break;
    v5 = *(_DWORD *)v5;
  }
  while ( v5 );
  if ( !v5 )
    return 0;
  v6 = *(_DWORD *)(v5 + 12);
  if ( !v6 )
    return 0;
  do
  {
    result = 1;
    if ( 1 == *(_WORD *)(*(_DWORD *)(v6 + 4) + 4) )
      break;
    v6 = *(_DWORD *)v6;
  }
  while ( v6 );
  if ( !v6 || *(_WORD *)(v6 + 30) < 1u )
    return 0;
  if ( (unsigned int)Src >= 0x10000 )
  {
    if ( !*Src )
      return result;
    hMema = 1;
  }
  else
  {
    hMema = 0;
  }
  Address = *(PVOID *)(v6 + 24);
  v7 = *((_DWORD *)Address + 1);
  if ( a3 )
  {
    if ( hMema )
    {
      if ( v7 >= v7 + 2 * wcslen(Src) + 2 )
        goto LABEL_30;
      v8 = v7 + 2 * wcslen(Src) + 2;
      if ( v8 >= v8 + 2 * wcslen(Src) + 2 )
        goto LABEL_30;
      v7 = v8 + 2 * wcslen(Src) + 2;
    }
    else
    {
      v9 = v7 + 4;
      if ( v7 >= v7 + 4 )
        goto LABEL_30;
      v7 += 8;
      if ( v9 >= (unsigned int)(v9 + 4) )
        goto LABEL_30;
    }
  }
  v10 = v7 + 70;
  if ( v7 >= v7 + 70 )
  {
LABEL_30:
    RtlSetLastWin32Error(111);
    return 0;
  }
  v11 = KernelBaseGetGlobalData();
  v12 = (struct _RC_CONFIG *)RtlAllocateHeap(
                               NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                               (*(_DWORD *)(v11 + 44) + 1835008) | 8,
                               v10);
  v13 = v12;
  if ( v12 )
  {
    v14 = InternalUpdateRCManifest(v12, v10, (struct _RC_CONFIG *)Address, Src, hMema, a3) == 0;
    v15 = NtCurrentTeb()->ProcessEnvironmentBlock;
    if ( !v14 )
    {
      RtlFreeHeap(v15->Reserved4[1], 0, Address);
      *(_DWORD *)(v6 + 24) = v13;
      *(_DWORD *)(v6 + 20) = *((_DWORD *)v13 + 1);
      return 1;
    }
    RtlFreeHeap(v15->Reserved4[1], 0, (PVOID)v13);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E61C40: using guessed type wchar_t aMui[4];

//----- (77E79914) --------------------------------------------------------
struct MY_STRING *__stdcall AddStringOrID(wchar_t *Str2, struct _UPDATEDATA *a2)
{
  int v2; // eax@2
  PVOID v3; // esi@2
  struct MY_STRING *result; // eax@2
  wchar_t *v5; // eax@4
  wchar_t *v6; // edx@4
  wchar_t v7; // cx@5
  size_t v8; // edi@7
  int v9; // esi@9
  int v10; // eax@11
  int v11; // eax@12
  unsigned __int16 v12; // di@12
  PVOID v13; // eax@12
  int v14; // eax@15
  wchar_t v15; // cx@15
  char *v16; // [sp+Ch] [bp-8h]@6
  unsigned __int16 v17; // [sp+10h] [bp-4h]@6
  unsigned __int16 v18; // [sp+10h] [bp-4h]@14

  if ( (unsigned int)Str2 >= 0x10000 )
  {
    v5 = Str2;
    v6 = Str2 + 1;
    do
    {
      v7 = *v5;
      ++v5;
    }
    while ( v7 );
    v3 = (PVOID)*((_DWORD *)a2 + 1);
    v17 = v5 - v6 + 1;
    v16 = (char *)a2 + 4;
    if ( !v3 )
      goto LABEL_23;
    v8 = (unsigned __int16)(v5 - v6 + 1);
    do
    {
      if ( !_wcsncmp(*((const wchar_t **)v3 + 4), Str2, v8) )
        break;
      v9 = (int)((char *)v3 + 4);
      v16 = (char *)v9;
      v3 = *(PVOID *)v9;
    }
    while ( v3 );
    if ( !v3 )
    {
LABEL_23:
      v10 = KernelBaseGetGlobalData();
      v3 = RtlAllocateHeap(
             NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
             (*(_DWORD *)(v10 + 44) + 1835008) | 8,
             0x14u);
      result = 0;
      if ( !v3 )
        return result;
      *(_DWORD *)v3 = 0;
      *((_DWORD *)v3 + 1) = 0;
      *((_DWORD *)v3 + 2) = 0;
      *((_DWORD *)v3 + 3) = 0;
      *((_DWORD *)v3 + 4) = 0;
      v11 = KernelBaseGetGlobalData();
      v12 = v17;
      v13 = RtlAllocateHeap(
              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
              (*(_DWORD *)(v11 + 44) + 1835008) | 8,
              2 * v17);
      *((_DWORD *)v3 + 4) = v13;
      if ( !v13 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v3);
        return 0;
      }
      *(_DWORD *)v3 = 1;
      *((_DWORD *)v3 + 2) = *(_DWORD *)a2;
      v18 = 0;
      *((_WORD *)v3 + 6) = 2 * v12 + 2;
      *((_WORD *)v3 + 7) = v12 - 1;
      do
      {
        v14 = v18;
        v15 = Str2[v14];
        if ( v15 >= 0x61u && v15 <= 0x7Au )
          v15 -= 32;
        ++v18;
        *(_WORD *)(v14 * 2 + *((_DWORD *)v3 + 4)) = v15;
      }
      while ( Str2[v14] );
      *(_DWORD *)a2 += *((_WORD *)v3 + 6);
      *((_DWORD *)v3 + 1) = 0;
      *(_DWORD *)v16 = v3;
    }
  }
  else
  {
    v2 = KernelBaseGetGlobalData();
    v3 = RtlAllocateHeap(
           NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
           (*(_DWORD *)(v2 + 44) + 1835008) | 8,
           0x14u);
    result = 0;
    if ( !v3 )
      return result;
    *(_DWORD *)v3 = 0;
    *((_DWORD *)v3 + 1) = 0;
    *((_DWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 3) = 0;
    *((_DWORD *)v3 + 4) = 0;
    *(_DWORD *)v3 = 2;
    *((_WORD *)v3 + 2) = (_WORD)Str2;
  }
  return (struct MY_STRING *)v3;
}

//----- (77E79AB0) --------------------------------------------------------
int __stdcall DeleteResourceFromList(struct _UPDATEDATA *a1, HGLOBAL hMem, PVOID Address, PVOID a4, int a5, int a6, int a7)
{
  __int16 v7; // bx@1
  char *v8; // eax@2
  PVOID v9; // esi@4
  char *v10; // edi@7
  PVOID v11; // ecx@11
  PVOID v12; // esi@16
  int v13; // ecx@16
  bool v14; // zf@25
  int v15; // eax@33
  const unsigned __int16 *v16; // eax@34
  char *v18; // [sp+8h] [bp-4h]@4
  PVOID v19; // [sp+14h] [bp+8h]@9

  v7 = 0;
  if ( a6 )
    v8 = (char *)a1 + 12;
  else
    v8 = (char *)a1 + 16;
  v9 = Address;
  v18 = v8;
  if ( *(PVOID *)v8 != Address )
  {
    do
      v8 = *(char **)v8;
    while ( *(PVOID *)v8 != Address );
    v18 = v8;
  }
  v10 = (char *)Address + 12;
  if ( !a7 )
    v10 = (char *)Address + 16;
  v19 = 0;
  if ( *(PVOID *)v10 == a4 )
    goto LABEL_40;
  do
  {
    if ( a7 )
    {
      v11 = *(PVOID *)v10;
      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)v10 + 4) + 4) == *(_WORD *)(*((_DWORD *)a4 + 1) + 4) )
      {
        v7 = 0;
        if ( !v19 )
          v19 = *(PVOID *)v10;
        if ( *((_WORD *)v11 + 15) > 1u )
          --*((_WORD *)v11 + 15);
      }
      else
      {
        v7 = 0;
      }
    }
    else
    {
      v12 = *(PVOID *)v10;
      v13 = wcscmp(
              *(const unsigned __int16 **)(*(_DWORD *)(*(_DWORD *)v10 + 4) + 16),
              *(const unsigned __int16 **)(*((_DWORD *)a4 + 1) + 16));
      v7 = 0;
      if ( !v19 )
        v19 = *(PVOID *)v10;
      if ( *((_WORD *)v12 + 15) > 1u )
        --*((_WORD *)v12 + 15);
      v9 = Address;
    }
    v10 = *(char **)v10;
  }
  while ( *(PVOID *)v10 != a4 );
  if ( v19 )
  {
    v14 = *((_WORD *)v19 + 15) == 0;
  }
  else
  {
LABEL_40:
    --*((_WORD *)a4 + 15);
    v14 = *((_WORD *)a4 + 15) == v7;
  }
  if ( v14 )
  {
    if ( a7 )
      --*((_DWORD *)v9 + 5);
    else
      --*((_DWORD *)v9 + 6);
  }
  *(_DWORD *)v10 = *(_DWORD *)a4;
  FreeOne(a4);
  if ( !*((_DWORD *)v9 + 3) && !*((_DWORD *)v9 + 4) )
  {
    *(_DWORD *)v18 = *(_DWORD *)v9;
    v15 = *((_DWORD *)v9 + 1);
    if ( a6 )
      v16 = (const unsigned __int16 *)*(_WORD *)(v15 + 4);
    else
      v16 = *(const unsigned __int16 **)(v15 + 16);
    UpdateRCManifest(hMem, v16, 0);
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
  }
  return 0;
}

//----- (77E79C18) --------------------------------------------------------
int __stdcall InsertResourceIntoLangList(struct _UPDATEDATA *a1, PVOID Address, PVOID a3, struct _RESTYPE *a4, struct _RESNAME *a5, int a6, int a7, int a8, void *a9)
{
  int v9; // eax@1
  PVOID v10; // edx@1
  int result; // eax@6
  PVOID v12; // ebx@7
  struct _RESNAME *v13; // eax@7
  char *v14; // ecx@9
  int v15; // ecx@15
  int v16; // ecx@16
  int v17; // eax@21
  struct _RESNAME *v18; // [sp+14h] [bp+10h]@14

  v9 = KernelBaseGetGlobalData();
  v10 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v9 + 44) + 1835008) | 8,
          0x24u);
  if ( v10 )
  {
    v12 = a3;
    memset(v10, 0, 0x24u);
    *((_DWORD *)v10 + 3) = Address;
    *((_DWORD *)v10 + 5) = a8;
    *((_DWORD *)v10 + 6) = a9;
    *((_WORD *)v10 + 15) = 1;
    v13 = a5;
    *((_DWORD *)v10 + 1) = a3;
    *((_WORD *)v10 + 16) = a6;
    if ( a6 >= *((_WORD *)a5 + 16) )
    {
      v18 = a5;
      do
      {
        v15 = *((_DWORD *)v13 + 1);
        if ( a7 )
          v16 = *((_WORD *)v12 + 2) == *(_WORD *)(v15 + 4);
        else
          v16 = wcscmp(*((const unsigned __int16 **)v12 + 4), *(const unsigned __int16 **)(v15 + 16)) == 0;
        if ( !v16 )
          break;
        if ( a6 <= *((_WORD *)v13 + 16) )
          break;
        ++*((_WORD *)v13 + 15);
        v18 = v13;
        v13 = *(struct _RESNAME **)v13;
      }
      while ( v13 );
      v17 = *(_DWORD *)v18;
      *(_DWORD *)v18 = v10;
      *(_DWORD *)v10 = v17;
    }
    else
    {
      *((_WORD *)v10 + 15) = *((_WORD *)a5 + 15) + 1;
      if ( a7 )
        v14 = (char *)a4 + 12;
      else
        v14 = (char *)a4 + 16;
      while ( a5 != *(struct _RESNAME **)v14 )
        v14 = *(char **)v14;
      *(_DWORD *)v10 = *(_DWORD *)v14;
      *(_DWORD *)v14 = v10;
    }
    result = 0;
  }
  else
  {
    if ( *(_DWORD *)Address == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( *(_DWORD *)a3 == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, a3);
    result = 8;
  }
  return result;
}

//----- (77E79D7C) --------------------------------------------------------
LONG __stdcall FilePos(HFILE hFile)
{
  return _llseek(hFile, 0, 1);
}

//----- (77E79D96) --------------------------------------------------------
LONG __stdcall MuMoveFilePos(HFILE hFile, LONG lOffset)
{
  return _llseek(hFile, lOffset, 0);
}

//----- (77E79DB1) --------------------------------------------------------
UINT __stdcall MuWrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
{
  UINT v3; // eax@1

  v3 = _lwrite(hFile, lpBuffer, uBytes);
  return v3 != uBytes ? v3 : 0;
}

//----- (77E79DD8) --------------------------------------------------------
UINT __stdcall MuRead(HFILE hFile, unsigned __int8 *lpBuffer, UINT uBytes)
{
  UINT v3; // eax@1

  v3 = _lread(hFile, lpBuffer, uBytes);
  return v3 != uBytes ? v3 : 0;
}

//----- (77E79DFF) --------------------------------------------------------
int __stdcall MuCopy(HFILE a1, HFILE hFile, UINT uBytes)
{
  int v3; // eax@1
  PVOID v4; // eax@1
  unsigned __int8 *v5; // ebx@1
  int result; // eax@2
  UINT v7; // edi@4
  int v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v3 = KernelBaseGetGlobalData();
  v4 = RtlAllocateHeap(
         NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
         (*(_DWORD *)(v3 + 44) + 1835008) | 8,
         0x1000u);
  v5 = (unsigned __int8 *)v4;
  if ( v4 )
  {
    memset(v4, 0, 0x1000u);
    while ( uBytes )
    {
      v7 = uBytes;
      if ( uBytes > 0x1000 )
        v7 = 4096;
      uBytes -= v7;
      if ( MuRead(a1, v5, v7) )
        break;
      v8 += v7;
      MuWrite(hFile, (LPCCH)v5, v7);
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
    result = v8;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E79EA3) --------------------------------------------------------
void __stdcall SetResdata(struct _IMAGE_RESOURCE_DATA_ENTRY *a1, unsigned __int32 a2, unsigned __int32 a3)
{
  a1->Reserved = 0;
  a1->OffsetToData = a2;
  a1->Size = a3;
  a1->CodePage = 1252;
}

//----- (77E79ECA) --------------------------------------------------------
void __stdcall SetRestab(struct _IMAGE_RESOURCE_DIRECTORY *a1, __int32 a2, unsigned __int16 a3, unsigned __int16 a4)
{
  a1->Characteristics = 0;
  a1->TimeDateStamp = a2;
  a1->MajorVersion = 4;
  a1->MinorVersion = 0;
  a1->NumberOfNamedEntries = a3;
  a1->NumberOfIdEntries = a4;
}

//----- (77E79F01) --------------------------------------------------------
struct _IMAGE_SECTION_HEADER *__stdcall FindSection(struct _IMAGE_SECTION_HEADER *a1, struct _IMAGE_SECTION_HEADER *a2, char *a3)
{
  struct _IMAGE_SECTION_HEADER *result; // eax@1

  for ( result = a1; result < a2; ++result )
  {
    if ( !strcmp((const char *)result, a3) )
      return result;
  }
  return 0;
}

//----- (77E79F4C) --------------------------------------------------------
int __stdcall AssignResourceToSection(struct _RESNAME **a1, unsigned __int32 a2, unsigned __int32 a3, __int32 a4, __int32 *a5)
{
  unsigned __int32 v5; // ecx@1
  unsigned int v6; // eax@1

  v5 = a3;
  v6 = (*((_DWORD *)*a1 + 5) + 3) & 0xFFFFFFFC;
  if ( a3 < a2 && a3 + v6 > a4 )
  {
    *a5 = a3;
    v5 = a2;
  }
  *((_DWORD *)*a1 + 2) = v5;
  *a1 = *(struct _RESNAME **)*a1;
  return v5 + v6;
}

//----- (77E79F8F) --------------------------------------------------------
int __stdcall WriteResSection(struct _UPDATEDATA *a1, HFILE hFile, unsigned __int32 a3, unsigned __int32 a4, struct _RESNAME *a5)
{
  int v5; // eax@1
  int v6; // esi@4
  unsigned __int32 v7; // ebx@7
  int v8; // edi@9
  int v9; // eax@17
  unsigned __int32 v10; // ebx@23
  int v11; // edi@25
  LONG v12; // eax@34
  unsigned int v13; // edi@34
  unsigned int v14; // ebx@36
  int v16; // [sp+Ch] [bp-Ch]@1
  signed int i; // [sp+10h] [bp-8h]@4
  signed int j; // [sp+10h] [bp-8h]@20
  int v19; // [sp+14h] [bp-4h]@1
  int v20; // [sp+14h] [bp-4h]@17

  v5 = *((_DWORD *)a1 + 4);
  v16 = 0;
  v19 = v5;
  if ( v5 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v5 + 16);
      for ( i = 1; ; i = 0 )
      {
        while ( v6 )
        {
          if ( !a5 || (struct _RESNAME *)v6 == a5 )
          {
            v7 = *(_DWORD *)(v6 + 20);
            a5 = 0;
            if ( !a4 || a4 < v7 )
              goto LABEL_34;
            MuWrite(hFile, *(LPCCH *)(v6 + 24), v7);
            v8 = -v7 & 3;
            if ( v8 )
              MuWrite(hFile, pchPad, -v7 & 3);
            v16 += v8 + v7;
            v5 = v19;
            a4 -= v7 + v8;
          }
          v6 = *(_DWORD *)v6;
        }
        if ( !i )
          break;
        v6 = *(_DWORD *)(v5 + 12);
      }
      v19 = *(_DWORD *)v5;
      if ( !*(_DWORD *)v5 )
        break;
      v5 = *(_DWORD *)v5;
    }
  }
  v9 = *((_DWORD *)a1 + 3);
  v20 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v9 + 16);
      for ( j = 1; ; j = 0 )
      {
        while ( v6 )
        {
          if ( !a5 || (struct _RESNAME *)v6 == a5 )
          {
            v10 = *(_DWORD *)(v6 + 20);
            a5 = 0;
            if ( !a4 || a4 < v10 )
              goto LABEL_34;
            MuWrite(hFile, *(LPCCH *)(v6 + 24), v10);
            v11 = -v10 & 3;
            if ( v11 )
              MuWrite(hFile, pchPad, -v10 & 3);
            v16 += v11 + v10;
            v9 = v20;
            a4 -= v10 + v11;
          }
          v6 = *(_DWORD *)v6;
        }
        if ( !j )
          break;
        v6 = *(_DWORD *)(v9 + 12);
      }
      v20 = *(_DWORD *)v9;
      if ( !*(_DWORD *)v9 )
        break;
      v9 = *(_DWORD *)v9;
    }
  }
  v6 = 0;
LABEL_34:
  v12 = FilePos(hFile);
  v13 = (~(a3 - 1) & (v12 + a3 - 1)) - v12;
  if ( (~(a3 - 1) & (v12 + a3 - 1)) != v12 )
  {
    if ( v13 >= 0x10 )
    {
      v14 = v13 >> 4;
      do
      {
        MuWrite(hFile, pchPad, 0x10u);
        v13 -= 16;
        --v14;
      }
      while ( v14 );
    }
    MuWrite(hFile, pchPad, v13);
  }
  return v6;
}

//----- (77E7A116) --------------------------------------------------------
int __stdcall PatchDebug<_IMAGE_NT_HEADERS>(HFILE hFile, HFILE a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // eax@3
  PVOID v11; // edi@3
  int v13; // ebx@7
  unsigned int v14; // esi@7
  unsigned int v15; // eax@9
  LONG v16; // eax@13
  int v17; // edi@16
  unsigned int v18; // eax@16
  int v19; // [sp+Ch] [bp-8h]@0
  const CHAR *Address; // [sp+10h] [bp-4h]@3
  int v21; // [sp+2Ch] [bp+18h]@8

  if ( a5 && *(_DWORD *)(a8 + 172) )
  {
    v10 = KernelBaseGetGlobalData();
    v11 = RtlAllocateHeap(
            NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
            (*(_DWORD *)(v10 + 44) + 1835008) | 8,
            *(_DWORD *)(a8 + 172));
    Address = (const CHAR *)v11;
    if ( !v11 )
      return 8;
    if ( !a3 )
      v19 = *(_DWORD *)a10;
    v13 = *(_DWORD *)(a7 + 168) - *(_DWORD *)(a5 + 12);
    MuMoveFilePos(hFile, v13 + *(_DWORD *)(a5 + 20));
    v14 = (unsigned int)((char *)v11 + 28 * (*(_DWORD *)(a8 + 172) / 0x1Cu));
    MuRead(hFile, (unsigned __int8 *)v11, *(_DWORD *)(a8 + 172));
    if ( a3 )
    {
      for ( ; (unsigned int)v11 < v14; *((_DWORD *)v11 - 1) += *(_DWORD *)(a4 + 20) - *(_DWORD *)(a3 + 20) )
      {
        v11 = (char *)v11 + 28;
        *((_DWORD *)v11 - 2) += *(_DWORD *)(a4 + 12) - *(_DWORD *)(a3 + 12);
      }
    }
    else
    {
      v21 = -1;
      if ( (unsigned int)v11 >= v14 )
        goto LABEL_27;
      do
      {
        v15 = *((_DWORD *)v11 + 6);
        if ( v15 >= a9 && v15 < v21 )
          v21 = *((_DWORD *)v11 + 6);
        v11 = (char *)v11 + 28;
      }
      while ( (unsigned int)v11 < v14 );
      v16 = v21;
      if ( v21 == -1 )
LABEL_27:
        v16 = _llseek(hFile, 0, 2);
      *(_DWORD *)a10 = v16;
      if ( (unsigned int)Address < v14 )
      {
        v17 = (int)(Address + 24);
        v18 = (v14 - (unsigned int)Address - 1) / 0x1C + 1;
        do
        {
          if ( *(_DWORD *)v17 >= (unsigned int)a9 )
            *(_DWORD *)v17 = v19 + *(_DWORD *)v17 - v21;
          v17 += 28;
          --v18;
        }
        while ( v18 );
      }
    }
    MuMoveFilePos(a2, v13 + *(_DWORD *)(a6 + 20));
    MuWrite(a2, Address, *(_DWORD *)(a8 + 172));
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)Address);
  }
  return 0;
}

//----- (77E7A296) --------------------------------------------------------
int __stdcall PatchDebug<_IMAGE_NT_HEADERS64>(HFILE hFile, HFILE a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // eax@3
  PVOID v11; // edi@3
  int v13; // ebx@7
  unsigned int v14; // esi@7
  unsigned int v15; // eax@9
  LONG v16; // eax@13
  int v17; // edi@16
  unsigned int v18; // eax@16
  int v19; // [sp+Ch] [bp-8h]@0
  const CHAR *Address; // [sp+10h] [bp-4h]@3
  int v21; // [sp+2Ch] [bp+18h]@8

  if ( a5 && *(_DWORD *)(a8 + 188) )
  {
    v10 = KernelBaseGetGlobalData();
    v11 = RtlAllocateHeap(
            NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
            (*(_DWORD *)(v10 + 44) + 1835008) | 8,
            *(_DWORD *)(a8 + 188));
    Address = (const CHAR *)v11;
    if ( !v11 )
      return 8;
    if ( !a3 )
      v19 = *(_DWORD *)a10;
    v13 = *(_DWORD *)(a7 + 184) - *(_DWORD *)(a5 + 12);
    MuMoveFilePos(hFile, v13 + *(_DWORD *)(a5 + 20));
    v14 = (unsigned int)((char *)v11 + 28 * (*(_DWORD *)(a8 + 188) / 0x1Cu));
    MuRead(hFile, (unsigned __int8 *)v11, *(_DWORD *)(a8 + 188));
    if ( a3 )
    {
      for ( ; (unsigned int)v11 < v14; *((_DWORD *)v11 - 1) += *(_DWORD *)(a4 + 20) - *(_DWORD *)(a3 + 20) )
      {
        v11 = (char *)v11 + 28;
        *((_DWORD *)v11 - 2) += *(_DWORD *)(a4 + 12) - *(_DWORD *)(a3 + 12);
      }
    }
    else
    {
      v21 = -1;
      if ( (unsigned int)v11 >= v14 )
        goto LABEL_27;
      do
      {
        v15 = *((_DWORD *)v11 + 6);
        if ( v15 >= a9 && v15 < v21 )
          v21 = *((_DWORD *)v11 + 6);
        v11 = (char *)v11 + 28;
      }
      while ( (unsigned int)v11 < v14 );
      v16 = v21;
      if ( v21 == -1 )
LABEL_27:
        v16 = _llseek(hFile, 0, 2);
      *(_DWORD *)a10 = v16;
      if ( (unsigned int)Address < v14 )
      {
        v17 = (int)(Address + 24);
        v18 = (v14 - (unsigned int)Address - 1) / 0x1C + 1;
        do
        {
          if ( *(_DWORD *)v17 >= (unsigned int)a9 )
            *(_DWORD *)v17 = v19 + *(_DWORD *)v17 - v21;
          v17 += 28;
          --v18;
        }
        while ( v18 );
      }
    }
    MuMoveFilePos(a2, v13 + *(_DWORD *)(a6 + 20));
    MuWrite(a2, Address, *(_DWORD *)(a8 + 188));
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)Address);
  }
  return 0;
}

//----- (77E7A416) --------------------------------------------------------
int __stdcall PatchRVAs<_IMAGE_NT_HEADERS>(HFILE hFile, HFILE a2, int a3, int a4, int a5, CHAR a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  HFILE v9; // ebx@3
  LONG v10; // esi@3
  int v11; // ecx@6
  int v12; // esi@8
  unsigned int v13; // eax@9
  int i; // ecx@9
  LONG v15; // esi@14
  CHAR Buffer; // [sp+4h] [bp-48h]@5
  int v17; // [sp+10h] [bp-3Ch]@5
  int v18; // [sp+20h] [bp-2Ch]@5
  int v19; // [sp+24h] [bp-28h]@5
  int v20; // [sp+28h] [bp-24h]@5
  CHAR v21; // [sp+2Ch] [bp-20h]@8
  int v22; // [sp+38h] [bp-14h]@9
  unsigned int v23; // [sp+3Ch] [bp-10h]@8
  unsigned int v24; // [sp+40h] [bp-Ch]@9
  int v25; // [sp+44h] [bp-8h]@6
  int v26; // [sp+48h] [bp-4h]@8
  HFILE hFilea; // [sp+54h] [bp+8h]@8

  v6 = a5;
  v7 = *(_DWORD *)(a5 + 84) - a6;
  if ( *(_DWORD *)(a5 + 84) == a6 )
  {
    result = 0;
  }
  else
  {
    v9 = hFile;
    v10 = *(_DWORD *)(a5 + 120);
    if ( v10 && (unsigned int)v10 < *(_DWORD *)(a5 + 84) )
    {
      MuMoveFilePos(hFile, v10 - v7);
      MuRead(hFile, (unsigned __int8 *)&Buffer, 0x28u);
      v17 += v7;
      v18 += v7;
      v19 += v7;
      v20 += v7;
      MuMoveFilePos(a2, v10);
      MuWrite(a2, &Buffer, 0x28u);
      v6 = a5;
    }
    v11 = *(_DWORD *)(v6 + 128);
    v25 = v11;
    if ( v11 )
    {
      if ( (unsigned int)v11 < *(_DWORD *)(v6 + 84) )
      {
        hFilea = 0;
        v26 = 0;
        MuMoveFilePos(v9, v11 - v7);
        MuRead(v9, (unsigned __int8 *)&v21, 0x14u);
        v12 = 0;
        while ( v23 )
        {
          v22 += v7;
          MuMoveFilePos(a2, v25 + v12);
          MuWrite(a2, &v21, 0x14u);
          v24 = *(_WORD *)(a5 + 6);
          v13 = 0;
          for ( i = a3 + 12; ; i += 40 )
          {
            if ( v13 >= v24 )
              return 13;
            if ( v23 >= *(_DWORD *)i && v23 < *(_DWORD *)i + *(_DWORD *)(i + 4) )
              break;
            ++v13;
          }
          v15 = v23 + *(_DWORD *)(a3 + 40 * v13 + 20) - *(_DWORD *)(a3 + 40 * v13 + 12);
          MuMoveFilePos(v9, v23 + *(_DWORD *)(a3 + 40 * v13 + 20) - *(_DWORD *)(a3 + 40 * v13 + 12) - a4);
          MuMoveFilePos(a2, v15);
          while ( 1 )
          {
            MuRead(v9, (unsigned __int8 *)&a6, 4u);
            if ( !a6 )
              break;
            if ( !(a6 & 0x80000000) )
            {
              *(_DWORD *)&a6 = v7 + a6;
              ++v26;
            }
            MuWrite(a2, &a6, 4u);
          }
          ++hFilea;
          v12 = 20 * hFilea;
          MuMoveFilePos(v9, v25 + 20 * hFilea - v7);
          MuRead(v9, (unsigned __int8 *)&v21, 0x14u);
        }
      }
    }
    result = 0;
  }
  return result;
}

//----- (77E7A5AA) --------------------------------------------------------
int __stdcall PatchRVAs<_IMAGE_NT_HEADERS64>(HFILE hFile, HFILE a2, int a3, int a4, int a5, CHAR a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int result; // eax@2
  HFILE v9; // ebx@3
  LONG v10; // esi@3
  int v11; // ecx@6
  int v12; // esi@8
  unsigned int v13; // eax@9
  int i; // ecx@9
  LONG v15; // esi@14
  CHAR Buffer; // [sp+4h] [bp-48h]@5
  int v17; // [sp+10h] [bp-3Ch]@5
  int v18; // [sp+20h] [bp-2Ch]@5
  int v19; // [sp+24h] [bp-28h]@5
  int v20; // [sp+28h] [bp-24h]@5
  CHAR v21; // [sp+2Ch] [bp-20h]@8
  int v22; // [sp+38h] [bp-14h]@9
  unsigned int v23; // [sp+3Ch] [bp-10h]@8
  unsigned int v24; // [sp+40h] [bp-Ch]@9
  int v25; // [sp+44h] [bp-8h]@6
  int v26; // [sp+48h] [bp-4h]@8
  HFILE hFilea; // [sp+54h] [bp+8h]@8

  v6 = a5;
  v7 = *(_DWORD *)(a5 + 84) - a6;
  if ( *(_DWORD *)(a5 + 84) == a6 )
  {
    result = 0;
  }
  else
  {
    v9 = hFile;
    v10 = *(_DWORD *)(a5 + 136);
    if ( v10 && (unsigned int)v10 < *(_DWORD *)(a5 + 84) )
    {
      MuMoveFilePos(hFile, v10 - v7);
      MuRead(hFile, (unsigned __int8 *)&Buffer, 0x28u);
      v17 += v7;
      v18 += v7;
      v19 += v7;
      v20 += v7;
      MuMoveFilePos(a2, v10);
      MuWrite(a2, &Buffer, 0x28u);
      v6 = a5;
    }
    v11 = *(_DWORD *)(v6 + 144);
    v25 = v11;
    if ( v11 )
    {
      if ( (unsigned int)v11 < *(_DWORD *)(v6 + 84) )
      {
        hFilea = 0;
        v26 = 0;
        MuMoveFilePos(v9, v11 - v7);
        MuRead(v9, (unsigned __int8 *)&v21, 0x14u);
        v12 = 0;
        while ( v23 )
        {
          v22 += v7;
          MuMoveFilePos(a2, v25 + v12);
          MuWrite(a2, &v21, 0x14u);
          v24 = *(_WORD *)(a5 + 6);
          v13 = 0;
          for ( i = a3 + 12; ; i += 40 )
          {
            if ( v13 >= v24 )
              return 13;
            if ( v23 >= *(_DWORD *)i && v23 < *(_DWORD *)i + *(_DWORD *)(i + 4) )
              break;
            ++v13;
          }
          v15 = v23 + *(_DWORD *)(a3 + 40 * v13 + 20) - *(_DWORD *)(a3 + 40 * v13 + 12);
          MuMoveFilePos(v9, v23 + *(_DWORD *)(a3 + 40 * v13 + 20) - *(_DWORD *)(a3 + 40 * v13 + 12) - a4);
          MuMoveFilePos(a2, v15);
          while ( 1 )
          {
            MuRead(v9, (unsigned __int8 *)&a6, 4u);
            if ( !a6 )
              break;
            if ( !(a6 & 0x80000000) )
            {
              *(_DWORD *)&a6 = v7 + a6;
              ++v26;
            }
            MuWrite(a2, &a6, 4u);
          }
          ++hFilea;
          v12 = 20 * hFilea;
          MuMoveFilePos(v9, v25 + 20 * hFilea - v7);
          MuRead(v9, (unsigned __int8 *)&v21, 0x14u);
        }
      }
    }
    result = 0;
  }
  return result;
}

//----- (77E7A741) --------------------------------------------------------
HRESULT __stdcall StringCchCopyA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPSTR v4; // eax@5
  HRESULT v5; // ebx@5
  size_t v6; // esi@5
  char v7; // cl@7

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cchDest;
    if ( !cchDest )
      goto LABEL_14;
    do
    {
      if ( !(2147483646 - cchDest + v6) )
        break;
      v7 = v4[pszSrc - pszDest];
      if ( !v7 )
        break;
      *v4++ = v7;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_14:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (77E7A7A9) --------------------------------------------------------
HRESULT __stdcall StringCchLengthW(STRSAFE_PCNZWCH psz, size_t cchMax, size_t *pcchLength)
{
  HRESULT result; // eax@3

  if ( psz && cchMax <= 0x7FFFFFFF )
    result = sub_77E30675((int)psz, cchMax, (int)pcchLength);
  else
    result = -2147024809;
  if ( result < 0 )
  {
    if ( pcchLength )
      *pcchLength = 0;
  }
  return result;
}

//----- (77E7A7E5) --------------------------------------------------------
int __stdcall AddResource(PVOID Address, PVOID a2, unsigned __int16 a3, struct _UPDATEDATA *a4, HGLOBAL hMem, void *a6, unsigned __int32 a7)
{
  int v7; // esi@1
  char *v8; // eax@2
  PVOID v9; // ebx@4
  int v10; // eax@5
  unsigned __int16 v11; // ax@6
  unsigned __int16 v12; // cx@6
  int v13; // eax@9
  int v14; // eax@17
  void (__stdcall *v15)(HANDLE, ULONG, PVOID); // esi@18
  int v17; // eax@26
  PVOID v18; // eax@26
  int v19; // edi@36
  unsigned __int16 v20; // ax@38
  unsigned __int16 v21; // cx@38
  int v22; // eax@43
  void (__stdcall *v23)(HANDLE, ULONG, PVOID); // esi@50
  int v24; // eax@66
  int v25; // eax@83
  PVOID v26; // edx@83
  const unsigned __int16 *v27; // eax@91
  PVOID v28; // [sp-4h] [bp-20h]@21
  signed int v30; // [sp+Ch] [bp-10h]@1
  void *v31; // [sp+10h] [bp-Ch]@4
  struct _RESNAME *v32; // [sp+10h] [bp-Ch]@64
  int v33; // [sp+14h] [bp-8h]@1
  int v34; // [sp+18h] [bp-4h]@1

  v33 = *(_DWORD *)Address == 2;
  v7 = 0;
  v30 = 0;
  v34 = *(_DWORD *)a2 == 2;
  if ( *(_DWORD *)Address == 2 )
    v8 = (char *)a4 + 12;
  else
    v8 = (char *)a4 + 16;
  v9 = *(PVOID *)v8;
  v31 = v8;
  while ( 1 )
  {
    if ( !v9 )
      goto LABEL_17;
    v10 = *((_DWORD *)v9 + 1);
    if ( *(_DWORD *)Address != 2 )
      break;
    v11 = *(_WORD *)(v10 + 4);
    v12 = *((_WORD *)Address + 2);
    if ( v12 == v11 )
      goto LABEL_14;
    if ( v12 < v11 )
      goto LABEL_17;
LABEL_11:
    v31 = v9;
    v9 = *(PVOID *)v9;
  }
  v13 = wcscmp(*((const unsigned __int16 **)Address + 4), *(const unsigned __int16 **)(v10 + 16));
  if ( v13 )
  {
    if ( v13 < 0 )
      goto LABEL_17;
    goto LABEL_11;
  }
LABEL_14:
  v7 = (int)((char *)v9 + 12);
  if ( *(_DWORD *)a2 != 2 )
    v7 = (int)((char *)v9 + 16);
  if ( !v7 )
  {
LABEL_17:
    v14 = KernelBaseGetGlobalData();
    v9 = RtlAllocateHeap(
           NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
           (*(_DWORD *)(v14 + 44) + 1835008) | 8,
           0x1Cu);
    if ( v9 == (PVOID)v7 )
    {
      v15 = (void (__stdcall *)(HANDLE, ULONG, PVOID))RtlFreeHeap;
      if ( *(_DWORD *)Address == 2 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
      if ( *(_DWORD *)a2 == 2 )
      {
        v28 = a2;
LABEL_22:
        v15(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v28);
      }
      return 8;
    }
    memset(v9, 0, 0x1Cu);
    v30 = 1;
    if ( v33 )
    {
      v17 = KernelBaseGetGlobalData();
      v18 = RtlAllocateHeap(
              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
              (*(_DWORD *)(v17 + 44) + 1835008) | 8,
              0x14u);
      *((_DWORD *)v9 + 1) = v18;
      if ( !v18 )
      {
        if ( *(_DWORD *)Address == 2 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        if ( *(_DWORD *)a2 == 2 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, a2);
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v9);
        return 8;
      }
      *(_DWORD *)v18 = 0;
      *((_DWORD *)v18 + 1) = 0;
      *((_DWORD *)v18 + 2) = 0;
      *((_DWORD *)v18 + 3) = 0;
      *((_DWORD *)v18 + 4) = 0;
      **((_DWORD **)v9 + 1) = 2;
      *(_WORD *)(*((_DWORD *)v9 + 1) + 4) = *((_WORD *)Address + 2);
    }
    else
    {
      *((_DWORD *)v9 + 1) = Address;
    }
    *(_DWORD *)v9 = *(_DWORD *)v31;
    *(_DWORD *)v31 = v9;
    v7 = (int)((char *)v9 + 12);
    if ( !v34 )
      v7 = (int)((char *)v9 + 16);
  }
  v19 = *(_DWORD *)v7;
  while ( 2 )
  {
    if ( !v19 )
    {
LABEL_40:
      if ( !a6 )
        goto LABEL_57;
      if ( v34 )
        ++*((_DWORD *)v9 + 5);
      else
        ++*((_DWORD *)v9 + 6);
      v25 = KernelBaseGetGlobalData();
      v26 = RtlAllocateHeap(
              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
              (*(_DWORD *)(v25 + 44) + 1835008) | 8,
              0x24u);
      if ( !v26 )
      {
        v15 = (void (__stdcall *)(HANDLE, ULONG, PVOID))RtlFreeHeap;
        if ( *(_DWORD *)Address == 2 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        if ( *(_DWORD *)a2 == 2 )
        {
          v28 = a2;
          goto LABEL_22;
        }
        return 8;
      }
      memset(v26, 0, 0x24u);
      *(_DWORD *)v26 = *(_DWORD *)v7;
      *(_DWORD *)v7 = v26;
      *((_WORD *)v26 + 15) = 1;
      *((_WORD *)v26 + 16) = a3;
      *((_DWORD *)v26 + 1) = a2;
      *((_DWORD *)v26 + 5) = a7;
      *((_DWORD *)v26 + 3) = Address;
      *((_DWORD *)v26 + 6) = a6;
      if ( v30 && hMem )
      {
        if ( v33 )
        {
          v27 = (const unsigned __int16 *)*((_WORD *)Address + 2);
        }
        else
        {
          v27 = (const unsigned __int16 *)*((_DWORD *)Address + 4);
          if ( !wcscmp(L"MUI", *((const unsigned __int16 **)Address + 4)) )
            return 0;
        }
        UpdateRCManifest(hMem, v27, 1);
      }
      return 0;
    }
    if ( v34 )
    {
      v20 = *((_WORD *)a2 + 2);
      v21 = *(_WORD *)(*(_DWORD *)(v19 + 4) + 4);
      if ( v20 == v21 )
        break;
      if ( v20 < v21 )
        goto LABEL_40;
      goto LABEL_45;
    }
    v22 = wcscmp(*((const unsigned __int16 **)a2 + 4), *(const unsigned __int16 **)(*(_DWORD *)(v19 + 4) + 16));
    if ( v22 )
    {
      if ( v22 < 0 )
        goto LABEL_40;
LABEL_45:
      v7 = v19;
      v19 = *(_DWORD *)v19;
      continue;
    }
    break;
  }
  if ( *(_WORD *)(v19 + 30) != 1 )
  {
    v32 = (struct _RESNAME *)v19;
    v19 = *(_DWORD *)v7;
    if ( !*(_DWORD *)v7 )
      goto LABEL_98;
    do
    {
      if ( v34 )
        v24 = *(_WORD *)(*(_DWORD *)(v19 + 4) + 4) == *(_WORD *)(*(_DWORD *)(*(_DWORD *)v7 + 4) + 4);
      else
        v24 = wcscmp(
                *(const unsigned __int16 **)(*(_DWORD *)(v19 + 4) + 16),
                *(const unsigned __int16 **)(*(_DWORD *)(*(_DWORD *)v7 + 4) + 16)) == 0;
      if ( !v24 )
        break;
      if ( a3 <= *(_WORD *)(v19 + 32) )
        break;
      v7 = v19;
      v19 = *(_DWORD *)v19;
    }
    while ( v19 );
    if ( !v19 || a3 != *(_WORD *)(v19 + 32) )
    {
LABEL_98:
      if ( a6 )
        return InsertResourceIntoLangList(a4, Address, a2, (struct _RESTYPE *)v9, v32, a3, v34, a7, a6);
      goto LABEL_57;
    }
    v23 = (void (__stdcall *)(HANDLE, ULONG, PVOID))RtlFreeHeap;
    if ( *(_DWORD *)Address == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( *(_DWORD *)a2 == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, a2);
    if ( !a6 )
      return DeleteResourceFromList(a4, hMem, v9, (PVOID)v19, a3, v33, v34);
    *(_DWORD *)(v19 + 20) = a7;
LABEL_79:
    v23(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v19 + 24));
    *(_DWORD *)(v19 + 24) = a6;
    return 0;
  }
  if ( a3 == *(_WORD *)(v19 + 32) )
  {
    v23 = (void (__stdcall *)(HANDLE, ULONG, PVOID))RtlFreeHeap;
    *(_DWORD *)(v19 + 20) = a7;
    if ( *(_DWORD *)Address == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( *(_DWORD *)a2 == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, a2);
    if ( !a6 )
      return DeleteResourceFromList(a4, hMem, v9, (PVOID)v19, a3, v33, v34);
    goto LABEL_79;
  }
  if ( a6 )
    return InsertResourceIntoLangList(a4, Address, a2, (struct _RESTYPE *)v9, (struct _RESNAME *)v19, a3, v34, a7, a6);
LABEL_57:
  if ( *(_DWORD *)Address == 2 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  if ( *(_DWORD *)a2 == 2 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, a2);
  return 87;
}
// 77E61C40: using guessed type wchar_t aMui[4];

//----- (77E7AD4A) --------------------------------------------------------
size_t __stdcall PEWriteResource<_IMAGE_NT_HEADERS>(HFILE a1, HFILE hFile, LONG lOffset, struct _UPDATEDATA *a4, int a5)
{
  LONG v5; // ebx@1
  int v6; // eax@3
  unsigned __int8 *v7; // esi@5
  int v8; // edi@5
  int v9; // ecx@6
  unsigned int v10; // eax@6
  int i; // ebx@11
  int v12; // eax@12
  int v13; // ecx@14
  int v14; // edx@14
  int v15; // ecx@16
  int v16; // edx@17
  int v17; // edx@18
  int v18; // eax@20
  int v19; // ecx@20
  int j; // ebx@28
  int v21; // eax@29
  int v22; // edx@31
  int v23; // ecx@33
  int v24; // edx@34
  int v25; // edx@35
  int v26; // eax@37
  int v27; // ecx@37
  struct _IMAGE_SECTION_HEADER *v28; // ebx@45
  int v29; // edx@45
  char *v30; // esi@45
  struct _IMAGE_SECTION_HEADER *v31; // edi@45
  struct _IMAGE_SECTION_HEADER *v32; // ecx@45
  unsigned __int32 v33; // ebx@47
  int k; // esi@48
  struct _IMAGE_SECTION_HEADER *v35; // eax@50
  unsigned __int32 v36; // eax@52
  int v38; // eax@63
  int m; // esi@71
  int v40; // eax@72
  struct _IMAGE_SECTION_HEADER *v41; // esi@82
  struct _IMAGE_SECTION_HEADER *v42; // edi@82
  int v43; // eax@82
  int v44; // eax@85
  unsigned int v45; // ecx@86
  int v46; // eax@91
  PVOID v47; // ebx@91
  int v48; // ecx@91
  int v49; // eax@101
  int v50; // eax@102
  int v51; // eax@109
  LONG v52; // edx@109
  signed int v53; // esi@110
  char *v54; // ecx@111
  unsigned int v55; // edx@111
  signed int v56; // esi@117
  char *v57; // ecx@118
  unsigned int v58; // edx@118
  __int16 v59; // si@122
  int v60; // eax@122
  PVOID v61; // eax@122
  unsigned int v62; // esi@123
  __int32 v63; // ebx@123
  char *v64; // ecx@123
  struct _RESNAME *v65; // eax@131
  __int32 v66; // eax@131
  LONG v67; // eax@132
  __int32 v68; // edx@132
  size_t v69; // ecx@132
  LONG v70; // eax@137
  char *v71; // ST1C_4@141
  unsigned __int32 v72; // edx@142
  STRSAFE_LPSTR v73; // eax@142
  struct _RESNAME *v74; // ecx@142
  int v75; // esi@142
  int v76; // eax@143
  struct _IMAGE_SECTION_HEADER *v77; // ecx@148
  unsigned __int32 v78; // ecx@149
  int v79; // edx@150
  struct _RESNAME *v80; // eax@150
  int v81; // et1@150
  ULONG v82; // et1@150
  int v83; // eax@150
  int v84; // edi@150
  LONG v85; // edi@153
  struct _IMAGE_RESOURCE_DIRECTORY *v86; // edi@154
  LONG v87; // esi@154
  int v88; // ebx@154
  int v89; // esi@154
  LONG v90; // eax@154
  int v91; // edi@154
  __int32 n; // eax@154
  int v93; // ecx@155
  __int32 v94; // eax@155
  struct _RESNAME *v95; // eax@155
  struct _RESNAME *v96; // edx@156
  int v97; // eax@158
  unsigned __int8 v98; // cf@159
  unsigned __int16 v99; // cx@161
  int v100; // eax@163
  struct _RESNAME *v101; // eax@166
  unsigned __int16 v102; // ST24_2@166
  int v103; // eax@167
  STRSAFE_LPSTR v104; // ecx@167
  struct _RESNAME **v105; // edx@167
  struct _RESNAME *v106; // edx@168
  struct _RESNAME *v107; // eax@172
  unsigned __int16 v108; // ST24_2@172
  int v109; // eax@173
  STRSAFE_LPSTR v110; // ecx@173
  struct _RESNAME **v111; // edx@173
  __int32 ii; // eax@176
  __int32 v113; // eax@177
  int v114; // ecx@177
  struct _RESNAME *v115; // eax@177
  struct _RESNAME *v116; // edx@178
  int v117; // eax@180
  bool v118; // cf@181
  unsigned __int16 v119; // cx@183
  int v120; // eax@185
  struct _RESNAME *v121; // eax@188
  unsigned __int16 v122; // ST24_2@188
  int v123; // eax@189
  STRSAFE_LPSTR v124; // ecx@189
  struct _RESNAME **v125; // edx@189
  struct _RESNAME *v126; // edx@190
  struct _RESNAME *v127; // eax@194
  unsigned __int16 v128; // ST24_2@194
  int v129; // eax@195
  STRSAFE_LPSTR v130; // ecx@195
  struct _RESNAME **v131; // edx@195
  unsigned int v132; // ecx@199
  int v133; // edi@199
  int jj; // ecx@199
  HFILE v135; // esi@202
  unsigned __int32 v136; // edx@204
  unsigned __int32 v137; // eax@204
  unsigned __int32 v138; // edi@204
  void *v139; // eax@207
  PVOID v140; // edi@207
  STRSAFE_LPSTR v141; // ebx@207
  LONG v142; // eax@213
  LONG v143; // eax@218
  struct _RESNAME *v144; // ST24_4@218
  LONG v145; // eax@218
  int v146; // eax@218
  LONG v147; // eax@222
  LONG v148; // eax@235
  struct _IMAGE_SECTION_HEADER *v149; // eax@237
  int v150; // eax@239
  int v151; // eax@241
  LONG v152; // ebx@247
  LONG v153; // eax@247
  unsigned __int8 v154; // [sp+Ch] [bp-258h]@1
  unsigned __int16 v155; // [sp+12h] [bp-252h]@1
  int v156; // [sp+48h] [bp-21Ch]@207
  CHAR v157[4]; // [sp+60h] [bp-204h]@109
  unsigned int v158; // [sp+B4h] [bp-1B0h]@83
  CHAR Buffer; // [sp+104h] [bp-160h]@3
  unsigned __int16 v160; // [sp+10Ah] [bp-15Ah]@95
  int v161; // [sp+110h] [bp-154h]@247
  int v162; // [sp+124h] [bp-140h]@207
  int v163; // [sp+13Ch] [bp-128h]@130
  unsigned __int32 v164; // [sp+140h] [bp-124h]@110
  int v165; // [sp+154h] [bp-110h]@143
  unsigned int v166; // [sp+158h] [bp-10Ch]@112
  char v167[16]; // [sp+17Ch] [bp-E8h]@111
  int v168; // [sp+18Ch] [bp-D8h]@212
  unsigned __int32 v169; // [sp+190h] [bp-D4h]@212
  ULONG v170; // [sp+1A4h] [bp-C0h]@238
  int v171; // [sp+1B0h] [bp-B4h]@246
  unsigned __int32 v172; // [sp+1FCh] [bp-68h]@1
  int v173; // [sp+200h] [bp-64h]@5
  int v174; // [sp+204h] [bp-60h]@85
  int v175; // [sp+208h] [bp-5Ch]@82
  int v176; // [sp+20Ch] [bp-58h]@45
  LONG v177; // [sp+210h] [bp-54h]@122
  LONG v178; // [sp+214h] [bp-50h]@1
  void *Dst; // [sp+218h] [bp-4Ch]@3
  struct _IMAGE_SECTION_HEADER *v180; // [sp+21Ch] [bp-48h]@45
  ULONG v181; // [sp+220h] [bp-44h]@45
  unsigned __int16 v182[2]; // [sp+224h] [bp-40h]@1
  struct _IMAGE_SECTION_HEADER *v183; // [sp+228h] [bp-3Ch]@5
  unsigned int v184; // [sp+22Ch] [bp-38h]@1
  STRSAFE_LPSTR pszDest; // [sp+230h] [bp-34h]@123
  int v186; // [sp+234h] [bp-30h]@1
  LONG v187; // [sp+238h] [bp-2Ch]@1
  PVOID v188; // [sp+23Ch] [bp-28h]@1
  int v189; // [sp+240h] [bp-24h]@1
  PVOID Address; // [sp+244h] [bp-20h]@123
  __int32 v191; // [sp+248h] [bp-1Ch]@48
  struct _RESNAME *v192; // [sp+24Ch] [bp-18h]@1
  unsigned __int32 v193; // [sp+250h] [bp-14h]@11
  int v194; // [sp+254h] [bp-10h]@1
  size_t Size; // [sp+258h] [bp-Ch]@2
  LONG v196; // [sp+25Ch] [bp-8h]@1
  struct _RESNAME *l; // [sp+260h] [bp-4h]@65
  HFILE hFilea; // [sp+270h] [bp+Ch]@234

  v188 = (PVOID)-1;
  v186 = -1;
  v194 = 0;
  v192 = 0;
  *(_DWORD *)v182 = 0;
  v187 = 0;
  v189 = 0;
  v184 = 0;
  v196 = 0;
  v172 = 0;
  MuMoveFilePos(a1, lOffset);
  MuRead(a1, &v154, 0xF8u);
  v5 = lOffset + 248;
  if ( ULongLongToULong(40i64 * v155, (ULONG *)&v178) < 0 )
    return 534;
  v178 += v5;
  qmemcpy(&Buffer, &v154, 0xF8u);
  v6 = KernelBaseGetGlobalData();
  Dst = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v6 + 44) + 1835008) | 8,
          40 * v155);
  if ( !Dst )
    return 8;
  v7 = (unsigned __int8 *)Dst;
  v8 = 0;
  memset(Dst, 0, 40 * v155);
  MuMoveFilePos(a1, v5);
  MuRead(a1, v7, 40 * v155);
  v183 = (struct _IMAGE_SECTION_HEADER *)&v7[40 * v155];
  v173 = 0;
  if ( (unsigned int)v7 < (unsigned int)v183 )
  {
    v9 = (int)(v7 + 20);
    v10 = (40 * (unsigned int)v155 - 1) / 0x28 + 1;
    do
    {
      if ( *(_DWORD *)v9 > (unsigned int)v8 )
        v8 = *(_DWORD *)v9 + *(_DWORD *)(v9 - 4);
      v9 += 40;
      --v10;
    }
    while ( v10 );
    v173 = v8;
  }
  v193 = 0;
  for ( i = *((_DWORD *)a4 + 4); i; i = *(_DWORD *)i )
  {
    v12 = *(_DWORD *)(i + 16);
    if ( v12 || *(_DWORD *)(i + 12) )
    {
      v13 = *(_WORD *)(*(_DWORD *)(i + 4) + 14);
      ++v187;
      ++*(_DWORD *)v182;
      v192 = (struct _RESNAME *)((char *)v192 + 2 * v13 + 2);
      v14 = 0;
      while ( v12 )
      {
        ++v184;
        if ( !v14
          || (v15 = *(_DWORD *)(v12 + 4),
              wcscmp(*(const unsigned __int16 **)(v14 + 16), *(const unsigned __int16 **)(v15 + 16))) )
        {
          v15 = *(_DWORD *)(v12 + 4);
          v16 = *(_WORD *)(v15 + 14);
          ++v189;
          v194 += 2 * v16 + 2;
        }
        v17 = *(_DWORD *)(v12 + 20);
        v12 = *(_DWORD *)v12;
        v193 += (v17 + 3) & 0xFFFFFFFC;
        v14 = v15;
      }
      v18 = *(_DWORD *)(i + 12);
      v19 = 0;
      while ( v18 )
      {
        ++v184;
        if ( !v19 || *(_WORD *)(v19 + 4) != *(_WORD *)(*(_DWORD *)(v18 + 4) + 4) )
          ++v189;
        v193 += (*(_DWORD *)(v18 + 20) + 3) & 0xFFFFFFFC;
        v19 = *(_DWORD *)(v18 + 4);
        v18 = *(_DWORD *)v18;
      }
    }
  }
  for ( j = *((_DWORD *)a4 + 3); j; j = *(_DWORD *)j )
  {
    v21 = *(_DWORD *)(j + 16);
    if ( v21 || *(_DWORD *)(j + 12) )
    {
      ++v187;
      v22 = 0;
      while ( v21 )
      {
        ++v184;
        if ( !v22
          || (v23 = *(_DWORD *)(v21 + 4),
              wcscmp(*(const unsigned __int16 **)(v22 + 16), *(const unsigned __int16 **)(v23 + 16))) )
        {
          v23 = *(_DWORD *)(v21 + 4);
          v24 = *(_WORD *)(v23 + 14);
          ++v189;
          v194 += 2 * v24 + 2;
        }
        v25 = *(_DWORD *)(v21 + 20);
        v21 = *(_DWORD *)v21;
        v193 += (v25 + 3) & 0xFFFFFFFC;
        v22 = v23;
      }
      v26 = *(_DWORD *)(j + 12);
      v27 = 0;
      while ( v26 )
      {
        ++v184;
        if ( !v27 || *(_WORD *)(v27 + 4) != *(_WORD *)(*(_DWORD *)(v26 + 4) + 4) )
          ++v189;
        v193 += (*(_DWORD *)(v26 + 20) + 3) & 0xFFFFFFFC;
        v27 = *(_DWORD *)(v26 + 4);
        v26 = *(_DWORD *)v26;
      }
    }
  }
  v28 = (struct _IMAGE_SECTION_HEADER *)Dst;
  v29 = v187 + v189 + v184 + 2 * (v187 + v184 + v189) + 2;
  v30 = (char *)v192 + 8 * v29 + (-(signed int)((char *)v192 + v194) & 3) + v194;
  v193 += (unsigned __int32)v30;
  v181 = (ULONG)((char *)v192 + 8 * v29 + (-(signed int)((char *)v192 + v194) & 3) + v194);
  v31 = FindSection((struct _IMAGE_SECTION_HEADER *)Dst, v183, ".rsrc");
  v176 = (int)v31;
  v180 = FindSection(v28, v183, ".rsrc1");
  v32 = FindSection(v28, v183, ".reloc");
  if ( !v31 )
    goto LABEL_46;
  if ( &v31[1] == v180 )
  {
    v35 = v31;
LABEL_52:
    v188 = (PVOID)(v35 - v28);
    v36 = 0x7FFFFFFF;
    Size = 0x7FFFFFFF;
    goto LABEL_53;
  }
  v35 = v31;
  if ( &v31[1] >= v183 )
    goto LABEL_52;
  v188 = (PVOID)(v31 - v28);
  if ( v32 )
    v36 = v31[1].VirtualAddress - v31->VirtualAddress;
  else
    v36 = 0x7FFFFFFF;
  Size = v36;
  if ( (unsigned int)v30 > v36 )
    return 13;
LABEL_53:
  if ( v193 <= v36 )
    goto LABEL_47;
  if ( v32 == &v31[1] )
  {
LABEL_46:
    Size = 0x7FFFFFFF;
LABEL_47:
    v33 = v196;
    goto LABEL_48;
  }
  if ( v180 )
    v32 = v180;
  v33 = v32->VirtualAddress - v31->VirtualAddress;
  v186 = ((char *)v32 - (_BYTE *)Dst) / 40;
LABEL_48:
  v191 = 0;
  v193 = (unsigned __int32)v30;
  for ( k = *((_DWORD *)a4 + 4); k; k = *(_DWORD *)k )
  {
    v38 = *(_DWORD *)(k + 16);
    if ( v38 || *(_DWORD *)(k + 12) )
    {
      l = *(struct _RESNAME **)(k + 16);
      if ( v38 )
      {
        do
          v193 = AssignResourceToSection(&l, v33, v193, Size, &v191);
        while ( l );
      }
      for ( l = *(struct _RESNAME **)(k + 12); l; v193 = AssignResourceToSection(&l, v33, v193, Size, &v191) )
        ;
    }
  }
  for ( m = *((_DWORD *)a4 + 3); m; m = *(_DWORD *)m )
  {
    v40 = *(_DWORD *)(m + 16);
    if ( v40 || *(_DWORD *)(m + 12) )
    {
      l = *(struct _RESNAME **)(m + 16);
      if ( v40 )
      {
        do
          v193 = AssignResourceToSection(&l, v33, v193, Size, &v191);
        while ( l );
      }
      for ( l = *(struct _RESNAME **)(m + 12); l; v193 = AssignResourceToSection(&l, v33, v193, Size, &v191) )
        ;
    }
  }
  if ( !v191 )
    v191 = v193;
  v41 = v183;
  v42 = (struct _IMAGE_SECTION_HEADER *)Dst;
  v43 = (int)FindSection((struct _IMAGE_SECTION_HEADER *)Dst, v183, ".debug");
  v175 = v43;
  if ( v43 && (!v158 || (struct _IMAGE_SECTION_HEADER *)v43 != &v41[-1]) )
    return 13;
  v174 = 0;
  v44 = (int)v42;
  if ( v42 < v41 )
  {
    while ( 1 )
    {
      v45 = *(_DWORD *)(v44 + 12);
      if ( v158 >= v45 && v158 < v45 + *(_DWORD *)(v44 + 16) )
        break;
      v44 += 40;
      if ( v44 >= (unsigned int)v41 )
        goto LABEL_91;
    }
    v174 = v44;
  }
LABEL_91:
  v46 = (int)FindSection(v42, v41, ".reloc");
  v47 = v188;
  v48 = v46;
  if ( v188 == (PVOID)-1 )
  {
    if ( v46 || (v46 = v175) != 0 )
      v47 = (PVOID)((v46 - (signed int)v42) / 40);
    else
      v47 = (PVOID)v160;
    ++v160;
  }
  if ( v186 == -1 )
  {
    if ( v180 )
      --v160;
    goto LABEL_109;
  }
  if ( !v180 )
  {
    if ( v48 )
    {
      v49 = v48;
    }
    else
    {
      v49 = v175;
      if ( !v175 )
      {
        v50 = v160;
        goto LABEL_105;
      }
    }
    v50 = (v49 - (signed int)v42) / 40;
LABEL_105:
    v186 = v50;
    goto LABEL_106;
  }
  v186 = v180 - v42;
  --v160;
LABEL_106:
  ++v160;
LABEL_109:
  v51 = 40 * (v160 - v155);
  v52 = *(_DWORD *)v157 - 40 * v155 - lOffset - 248;
  if ( v51 <= (unsigned int)v52 )
  {
    if ( v51 )
    {
      v56 = 0;
      do
      {
        v57 = &v167[8 * v56];
        v58 = *(_DWORD *)v57;
        if ( *(_DWORD *)v57 && v58 < *(_DWORD *)v157 )
          *(_DWORD *)v57 = v51 + v58;
        ++v56;
      }
      while ( v56 < 16 );
    }
  }
  else
  {
    v51 -= v52;
    v172 = ~(v164 - 1) & (v164 + v51 - 1);
    v53 = 0;
    do
    {
      v54 = &v167[8 * v53];
      v55 = *(_DWORD *)v54;
      if ( *(_DWORD *)v54 && v55 < v166 )
        *(_DWORD *)v54 = v51 + v55;
      ++v53;
    }
    while ( v53 < 16 );
    v166 += v51;
  }
  v59 = 40 * v160;
  v177 = v51 + v178;
  Size = 40 * v160;
  v60 = KernelBaseGetGlobalData();
  v61 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v60 + 44) + 1835008) | 8,
          v59);
  v188 = v61;
  if ( !v61 )
    goto LABEL_144;
  v62 = (unsigned int)v61;
  memset(v61, 0, Size);
  pszDest = (STRSAFE_LPSTR)(v62 + 40 * (_DWORD)v47);
  v63 = 0;
  Address = 0;
  v64 = (char *)v42;
  l = (struct _RESNAME *)v42;
  v196 = v62;
  if ( v42 >= v183 )
    goto LABEL_141;
  do
  {
    if ( (struct _IMAGE_SECTION_HEADER *)v64 != v180 )
    {
      if ( (STRSAFE_LPSTR)v62 == pszDest )
      {
        Address = (PVOID)1;
        Size = ~(v164 - 1) & (v191 + v164 - 1);
        if ( v176 )
        {
          v67 = v196;
          v68 = v191;
          qmemcpy((void *)v196, (const void *)l, 0x28u);
          v69 = Size;
          *(_DWORD *)(v67 + 16) = Size;
          *(_DWORD *)(v67 + 8) = v68;
          if ( v69 == *((_DWORD *)l + 4) )
          {
            v63 = 0;
          }
          else
          {
            v63 += (v68 + v163 - 1) & ~(v163 - 1);
            if ( (unsigned int)((char *)l + 40) < (unsigned int)v183 )
              v63 += *((_DWORD *)l + 3) - *((_DWORD *)l + 13);
          }
        }
        else
        {
          v63 = (v191 + v163 - 1) & ~(v163 - 1);
          memset((void *)v62, 0, 0x28u);
          if ( StringCchCopyA((STRSAFE_LPSTR)v62, 8u, ".rsrc") < 0 )
            goto LABEL_251;
          v65 = l;
          *(_DWORD *)(v62 + 12) = *((_DWORD *)l + 3);
          *(_DWORD *)(v62 + 20) = *((_DWORD *)v65 + 5);
          *(_DWORD *)(v62 + 16) = Size;
          v66 = v191;
          *(_DWORD *)(v62 + 36) = 1073741888;
          *(_DWORD *)(v62 + 8) = v66;
        }
        v196 += 40;
        if ( v176 )
          goto LABEL_138;
      }
      else if ( v186 == -1 || (PVOID)v62 != (char *)v188 + 40 * v186 )
      {
        if ( v62 < (unsigned int)pszDest )
        {
          v85 = v196;
          v196 += 40;
          qmemcpy((void *)v85, (const void *)l, 0x28u);
          goto LABEL_138;
        }
      }
      else
      {
        memset((void *)v62, 0, 0x28u);
        if ( StringCchCopyA((STRSAFE_LPSTR)v62, 8u, ".rsrc1") < 0 )
          goto LABEL_251;
        v77 = v180;
        if ( v180 )
        {
          v79 = v176;
          *(_DWORD *)(v62 + 12) = v180->VirtualAddress;
          v80 = l;
          *(_DWORD *)(v62 + 36) = 1073741888;
          v81 = *(_DWORD *)(v79 + 12);
          v82 = v77->VirtualAddress;
          v83 = *((_DWORD *)v80 + 3);
          v84 = v83 - *(_DWORD *)(v62 + 12);
          v63 = *((_DWORD *)pszDest + 3) + (~(v163 - 1) & (v163 + v193 - 1)) - v83;
        }
        else
        {
          v78 = v193;
          *(_DWORD *)(v62 + 12) = *((_DWORD *)l + 3);
          *(_DWORD *)(v62 + 36) = 1073741888;
          v63 = *((_DWORD *)pszDest + 3) + (~(v163 - 1) & (v163 + v78 - 1)) - *(_DWORD *)(v62 + 12);
        }
        v196 = v62 + 40;
      }
      v70 = v196 + 40;
      qmemcpy((void *)v196, (const void *)l, 0x28u);
      *(_DWORD *)(v70 - 28) += v63;
      v196 = v70;
LABEL_138:
      v62 = v196;
      goto LABEL_139;
    }
    if ( v186 == -1 && (unsigned int)(v64 + 40) < (unsigned int)v183 )
      v63 += *((_DWORD *)v64 + 3) - *((_DWORD *)v64 + 13);
LABEL_139:
    v64 = (char *)l + 40;
    l = (struct _RESNAME *)v64;
  }
  while ( (unsigned int)v64 < (unsigned int)v183 );
  if ( !Address )
  {
LABEL_141:
    v71 = pszDest;
    memset(pszDest, 0, 0x28u);
    if ( StringCchCopyA(v71, 8u, ".rsrc") < 0 )
      goto LABEL_251;
    v72 = ~(v164 - 1) & (v164 + v191 - 1);
    v73 = pszDest;
    *((_DWORD *)pszDest + 2) = v191;
    v74 = l;
    *((_DWORD *)v73 + 4) = v72;
    v75 = *((_DWORD *)v74 - 7) + (~(v163 - 1) & (*((_DWORD *)v74 - 8) + v163 - 1));
    *((_DWORD *)v73 + 9) = 1073741888;
    *((_DWORD *)v73 + 3) = v75;
  }
  v165 = ~(v163 - 1) & (*((_DWORD *)v188 + 10 * v160 - 7) + *((_DWORD *)v188 + 10 * v160 - 6) + v163 - 1);
  v76 = KernelBaseGetGlobalData();
  Address = RtlAllocateHeap(
              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
              (*(_DWORD *)(v76 + 44) + 1835008) | 8,
              v181);
  if ( !Address )
  {
LABEL_144:
    Size = 8;
    goto LABEL_251;
  }
  v86 = (struct _IMAGE_RESOURCE_DIRECTORY *)Address;
  memset(Address, 0, v181);
  v87 = v187;
  SetRestab(v86, 0, v182[0], v187 - v182[0]);
  *(_DWORD *)v182 = v86 + 1;
  v88 = (int)((char *)&v86[1] + 8 * v87);
  v89 = v88 + 8 * (v189 + 2 * v87);
  v90 = v89 + 8 * (v184 + 2 * v189);
  v196 = v90;
  v91 = v90 + 16 * v184;
  v184 = (unsigned int)((char *)v192 + v91 + v194);
  for ( n = *((_DWORD *)a4 + 4); ; n = *(_DWORD *)v191 )
  {
    v191 = n;
    if ( !n )
      break;
    v93 = *(_DWORD *)v182;
    **(_DWORD **)v182 = (v91 - (_DWORD)Address) | 0x80000000;
    v93 += 8;
    v94 = v191;
    *(_DWORD *)(v93 - 4) = (v88 - (_DWORD)Address) | 0x80000000;
    *(_DWORD *)v182 = v93;
    *(_WORD *)v91 = *(_WORD *)(*(_DWORD *)(v94 + 4) + 14);
    _wcsncpy(
      (wchar_t *)(v91 + 2),
      *(const wchar_t **)(*(_DWORD *)(v94 + 4) + 16),
      *(_WORD *)(*(_DWORD *)(v94 + 4) + 14));
    v91 += 2 * *(_WORD *)(*(_DWORD *)(v191 + 4) + 14) + 2;
    SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v88, 0, *(_WORD *)(v191 + 24), *(_WORD *)(v191 + 20));
    v95 = *(struct _RESNAME **)(v191 + 16);
    v189 = 0;
    v88 += 16;
    l = v95;
    if ( v95 )
    {
      v96 = l;
      v187 = v196 - (_DWORD)Address;
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 )
          goto LABEL_256;
        v97 = *(_DWORD *)(*((_DWORD *)v96 + 1) + 16);
        v192 = *(struct _RESNAME **)(v189 + 16);
        while ( 1 )
        {
          v98 = *(_WORD *)v192 < *(_WORD *)v97;
          if ( *(_WORD *)v192 != *(_WORD *)v97 )
            break;
          if ( !*(_WORD *)v192 )
            goto LABEL_163;
          v99 = *((_WORD *)v192 + 1);
          HIWORD(Size) = v99;
          v98 = v99 < *(_WORD *)(v97 + 2);
          if ( v99 != *(_WORD *)(v97 + 2) )
            break;
          v192 = (struct _RESNAME *)((char *)v192 + 4);
          v97 += 4;
          if ( !v99 )
          {
LABEL_163:
            v100 = 0;
            goto LABEL_165;
          }
        }
        v100 = -v98 - (v98 - 1);
LABEL_165:
        if ( v100 )
        {
LABEL_256:
          *(_DWORD *)v88 = (v91 - (_DWORD)Address) | 0x80000000;
          v101 = l;
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          *(_WORD *)v91 = *(_WORD *)(*((_DWORD *)v101 + 1) + 14);
          v88 += 8;
          _wcsncpy(
            (wchar_t *)(v91 + 2),
            *(const wchar_t **)(*((_DWORD *)v101 + 1) + 16),
            *(_WORD *)(*((_DWORD *)v101 + 1) + 14));
          v102 = *((_WORD *)l + 15);
          v91 += 2 * *(_WORD *)(*((_DWORD *)l + 1) + 14) + 2;
          v189 = *((_DWORD *)l + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v102);
          v96 = l;
          v89 += 16;
          v194 += 16;
        }
        v103 = *((_WORD *)v96 + 16);
        v104 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v103;
        *(_DWORD *)(v89 + 4) = v187;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v104 + 3) + *((_DWORD *)v96 + 2),
          *((_DWORD *)v96 + 5));
        v96 = *v105;
        v196 += 16;
        v187 += 16;
        l = v96;
      }
      while ( v96 );
    }
    v106 = *(struct _RESNAME **)(v191 + 12);
    v189 = 0;
    l = v106;
    if ( v106 )
    {
      v192 = (struct _RESNAME *)(v196 - (_DWORD)Address);
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 || *(_WORD *)(v189 + 4) != *(_WORD *)(*((_DWORD *)v106 + 1) + 4) )
        {
          v107 = l;
          *(_DWORD *)v88 = *(_WORD *)(*((_DWORD *)l + 1) + 4);
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          v108 = *((_WORD *)v107 + 15);
          v88 += 8;
          v189 = *((_DWORD *)v107 + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v108);
          v106 = l;
          v89 += 16;
          v194 += 16;
        }
        v109 = *((_WORD *)v106 + 16);
        v110 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v109;
        *(_DWORD *)(v89 + 4) = v192;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v110 + 3) + *((_DWORD *)v106 + 2),
          *((_DWORD *)v106 + 5));
        v106 = *v111;
        v196 += 16;
        v192 = (struct _RESNAME *)((char *)v192 + 16);
        l = v106;
      }
      while ( v106 );
    }
  }
  for ( ii = *((_DWORD *)a4 + 3); ; ii = *(_DWORD *)v191 )
  {
    v191 = ii;
    if ( !ii )
      break;
    v113 = v191;
    v114 = *(_DWORD *)v182;
    **(_DWORD **)v182 = *(_WORD *)(*(_DWORD *)(v191 + 4) + 4);
    v114 += 8;
    *(_DWORD *)(v114 - 4) = (v88 - (_DWORD)Address) | 0x80000000;
    *(_DWORD *)v182 = v114;
    SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v88, 0, *(_WORD *)(v113 + 24), *(_WORD *)(v113 + 20));
    v115 = *(struct _RESNAME **)(v191 + 16);
    v189 = 0;
    v88 += 16;
    l = v115;
    if ( v115 )
    {
      v116 = l;
      v187 = v196 - (_DWORD)Address;
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 )
          goto LABEL_257;
        v117 = *(_DWORD *)(*((_DWORD *)v116 + 1) + 16);
        v192 = *(struct _RESNAME **)(v189 + 16);
        while ( 1 )
        {
          v118 = *(_WORD *)v192 < *(_WORD *)v117;
          if ( *(_WORD *)v192 != *(_WORD *)v117 )
            break;
          if ( !*(_WORD *)v192 )
            goto LABEL_185;
          v119 = *((_WORD *)v192 + 1);
          HIWORD(Size) = v119;
          v118 = v119 < *(_WORD *)(v117 + 2);
          if ( v119 != *(_WORD *)(v117 + 2) )
            break;
          v192 = (struct _RESNAME *)((char *)v192 + 4);
          v117 += 4;
          if ( !v119 )
          {
LABEL_185:
            v120 = 0;
            goto LABEL_187;
          }
        }
        v120 = -v118 - (v118 - 1);
LABEL_187:
        if ( v120 )
        {
LABEL_257:
          *(_DWORD *)v88 = (v91 - (_DWORD)Address) | 0x80000000;
          v121 = l;
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          *(_WORD *)v91 = *(_WORD *)(*((_DWORD *)v121 + 1) + 14);
          v88 += 8;
          _wcsncpy(
            (wchar_t *)(v91 + 2),
            *(const wchar_t **)(*((_DWORD *)v121 + 1) + 16),
            *(_WORD *)(*((_DWORD *)v121 + 1) + 14));
          v122 = *((_WORD *)l + 15);
          v91 += 2 * *(_WORD *)(*((_DWORD *)l + 1) + 14) + 2;
          v189 = *((_DWORD *)l + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v122);
          v116 = l;
          v89 += 16;
          v194 += 16;
        }
        v123 = *((_WORD *)v116 + 16);
        v124 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v123;
        *(_DWORD *)(v89 + 4) = v187;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v124 + 3) + *((_DWORD *)v116 + 2),
          *((_DWORD *)v116 + 5));
        v116 = *v125;
        v196 += 16;
        v187 += 16;
        l = v116;
      }
      while ( v116 );
    }
    v126 = *(struct _RESNAME **)(v191 + 12);
    v189 = 0;
    l = v126;
    if ( v126 )
    {
      v192 = (struct _RESNAME *)(v196 - (_DWORD)Address);
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 || *(_WORD *)(v189 + 4) != *(_WORD *)(*((_DWORD *)v126 + 1) + 4) )
        {
          v127 = l;
          *(_DWORD *)v88 = *(_WORD *)(*((_DWORD *)l + 1) + 4);
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          v128 = *((_WORD *)v127 + 15);
          v88 += 8;
          v189 = *((_DWORD *)v127 + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v128);
          v126 = l;
          v89 += 16;
          v194 += 16;
        }
        v129 = *((_WORD *)v126 + 16);
        v130 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v129;
        *(_DWORD *)(v89 + 4) = v192;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v130 + 3) + *((_DWORD *)v126 + 2),
          *((_DWORD *)v126 + 5));
        v126 = *v131;
        v196 += 16;
        v192 = (struct _RESNAME *)((char *)v192 + 16);
        l = v126;
      }
      while ( v126 );
    }
  }
  if ( v91 < v184 )
  {
    v132 = ((v184 - v91 - 1) >> 1) + 1;
    v98 = v132 & 1;
    v132 >>= 1;
    memset((void *)v91, 0, 4 * v132);
    v133 = v91 + 4 * v132;
    for ( jj = v98; jj; --jj )
    {
      *(_WORD *)v133 = 0;
      v133 += 2;
    }
  }
  MuMoveFilePos(a1, 0);
  v135 = hFile;
  MuCopy(a1, hFile, lOffset + 248);
  MuMoveFilePos(hFile, v177);
  MuMoveFilePos(a1, v178);
  if ( (unsigned int)v177 < *(_DWORD *)v157 )
    MuCopy(a1, hFile, *(_DWORD *)v157 - v177);
  v136 = (v164 - 1) & v166;
  v137 = (v164 - 1) & (v164 - v136);
  v138 = (v164 - 1) & (v164 - v136);
  v166 += v138;
  if ( (signed int)v138 >= 16 )
  {
    hFile = v137 >> 4;
    v138 += -16 * (v137 >> 4);
    do
    {
      MuWrite(v135, pchZero, 0x10u);
      --hFile;
    }
    while ( hFile );
  }
  MuWrite(v135, pchZero, v138);
  MuMoveFilePos(a1, ~(v156 - 1) & (*(_DWORD *)v157 + v156 - 1));
  v139 = Dst;
  v162 = 0;
  v178 = 0;
  v140 = v188;
  v141 = pszDest;
  l = (struct _RESNAME *)Dst;
  while ( 2 )
  {
    if ( v139 < v183 )
    {
      if ( (struct _IMAGE_SECTION_HEADER *)l == v180 )
        l = (struct _RESNAME *)((char *)l + 40);
      if ( v140 == v141 )
      {
        v178 = 1;
        *((_DWORD *)v140 + 5) = FilePos(v135);
        v168 = *((_DWORD *)v141 + 3);
        v169 = v193;
        hFile = FilePos(v135);
        MuWrite(v135, (LPCCH)Address, v181);
        v192 = (struct _RESNAME *)WriteResSection(a4, v135, v164, *((_DWORD *)v141 + 4) - v181, 0);
        Size = FilePos(v135);
        if ( v186 == -1 )
        {
          MuMoveFilePos(v135, hFile);
          MuWrite(v135, (LPCCH)Address, v181);
          MuMoveFilePos(v135, Size);
          v142 = FilePos(a1);
          MuMoveFilePos(a1, v142 + *((_DWORD *)l + 4));
        }
        v162 += *((_DWORD *)v140 + 4);
        if ( v176 )
          goto LABEL_230;
LABEL_219:
        v140 = (char *)v140 + 40;
      }
      else
      {
        if ( v186 != -1 && v140 == (char *)v188 + 40 * v186 )
        {
          v143 = FilePos(v135);
          v144 = v192;
          *((_DWORD *)v140 + 5) = v143;
          WriteResSection(a4, v135, v164, 0xFFFFFFFF, v144);
          v145 = FilePos(v135);
          Size = v145;
          v146 = v145 - *((_DWORD *)v140 + 5);
          *((_DWORD *)v140 + 4) = v146;
          *((_DWORD *)v140 + 2) = v146;
          MuMoveFilePos(v135, hFile);
          MuWrite(v135, (LPCCH)Address, v181);
          MuMoveFilePos(v135, Size);
          v162 += *((_DWORD *)v140 + 4);
          goto LABEL_219;
        }
        if ( v140 < v141 )
        {
          if ( *((_DWORD *)l + 5) )
          {
            v177 = *((_DWORD *)l + 5);
            v147 = FilePos(v135);
            if ( v177 != v147 )
              MuMoveFilePos(v135, v172 + v177);
          }
        }
      }
      if ( *((_DWORD *)l + 5) )
      {
        *((_DWORD *)v140 + 5) = FilePos(v135);
        MuMoveFilePos(a1, *((_DWORD *)l + 5));
        MuCopy(a1, v135, *((_DWORD *)l + 4));
      }
      if ( l == (struct _RESNAME *)v174 )
        *(_DWORD *)v182 = v140;
      if ( *((_BYTE *)v140 + 36) & 0x40 )
        v162 += *((_DWORD *)v140 + 4);
LABEL_230:
      l = (struct _RESNAME *)((char *)l + 40);
      v139 = (void *)l;
      v140 = (char *)v140 + 40;
      continue;
    }
    break;
  }
  if ( v180 )
    v162 -= v180->SizeOfRawData;
  if ( !v178 )
  {
    *((_DWORD *)v141 + 5) = FilePos(v135);
    v168 = *((_DWORD *)v141 + 3);
    v169 = v193;
    hFilea = FilePos(v135);
    MuWrite(v135, (LPCCH)Address, v181);
    WriteResSection(a4, v135, v164, *((_DWORD *)v141 + 4) - v181, 0);
    Size = FilePos(v135);
    if ( v186 == -1 )
    {
      MuMoveFilePos(v135, hFilea);
      MuWrite(v135, (LPCCH)Address, v181);
      MuMoveFilePos(v135, Size);
      v148 = FilePos(a1);
      MuMoveFilePos(a1, v148 + *((_DWORD *)l + 4));
    }
    v162 += *((_DWORD *)v140 + 4);
  }
  v149 = FindSection((struct _IMAGE_SECTION_HEADER *)v188, (struct _IMAGE_SECTION_HEADER *)v188 + v160, ".reloc");
  if ( v149 )
    v170 = v149->VirtualAddress;
  MuMoveFilePos(v135, lOffset + 248);
  MuWrite(v135, (LPCCH)v188, 40 * v160);
  v196 = _llseek(v135, 0, 2);
  MuWrite(v135, 0, 0);
  v150 = (int)FindSection((struct _IMAGE_SECTION_HEADER *)v188, (struct _IMAGE_SECTION_HEADER *)v188 + v160, ".debug");
  Size = PatchDebug<_IMAGE_NT_HEADERS>(
           a1,
           v135,
           v175,
           v150,
           v174,
           *(int *)v182,
           (int)&v154,
           (int)&Buffer,
           v173,
           (int)&v196);
  if ( !Size )
  {
    if ( v176 )
      v151 = *(_DWORD *)(v176 + 16) - *((_DWORD *)v141 + 4);
    else
      v151 = *((_DWORD *)v141 + 4);
    Size = PatchRVAs<_IMAGE_NT_HEADERS>(a1, v135, (int)v188, v151, (int)&Buffer, v157[0]);
  }
  if ( v174 && !v175 && v171 )
  {
    v152 = _llseek(a1, 0, 2);
    v153 = _llseek(v135, 0, 2);
    if ( v161 )
      v161 += v153 - v196;
    MuMoveFilePos(a1, v196);
    MuCopy(a1, v135, v152 - v196);
  }
  MuMoveFilePos(v135, lOffset);
  MuWrite(v135, &Buffer, 0xF8u);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
LABEL_251:
  if ( v188 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v188);
  return Size;
}
// 77E7AD4A: using guessed type char var_E8[16];

//----- (77E7C07F) --------------------------------------------------------
size_t __stdcall PEWriteResource<_IMAGE_NT_HEADERS64>(HFILE a1, HFILE hFile, LONG lOffset, struct _UPDATEDATA *a4, int a5)
{
  LONG v5; // ebx@1
  int v6; // eax@3
  unsigned __int8 *v7; // esi@5
  int v8; // edi@5
  int v9; // ecx@6
  unsigned int v10; // eax@6
  int i; // ebx@11
  int v12; // eax@12
  int v13; // ecx@14
  int v14; // edx@14
  int v15; // ecx@16
  int v16; // edx@17
  int v17; // edx@18
  int v18; // eax@20
  int v19; // ecx@20
  int j; // ebx@28
  int v21; // eax@29
  int v22; // edx@31
  int v23; // ecx@33
  int v24; // edx@34
  int v25; // edx@35
  int v26; // eax@37
  int v27; // ecx@37
  struct _IMAGE_SECTION_HEADER *v28; // ebx@45
  int v29; // edx@45
  char *v30; // esi@45
  struct _IMAGE_SECTION_HEADER *v31; // edi@45
  struct _IMAGE_SECTION_HEADER *v32; // ecx@45
  unsigned __int32 v33; // ebx@47
  int k; // esi@48
  struct _IMAGE_SECTION_HEADER *v35; // eax@50
  unsigned __int32 v36; // eax@52
  int v38; // eax@63
  int m; // esi@71
  int v40; // eax@72
  struct _IMAGE_SECTION_HEADER *v41; // esi@82
  struct _IMAGE_SECTION_HEADER *v42; // edi@82
  int v43; // eax@82
  int v44; // eax@85
  unsigned int v45; // ecx@86
  int v46; // eax@91
  PVOID v47; // ebx@91
  int v48; // ecx@91
  int v49; // eax@101
  int v50; // eax@102
  int v51; // eax@109
  LONG v52; // edx@109
  signed int v53; // esi@110
  char *v54; // ecx@111
  unsigned int v55; // edx@111
  signed int v56; // esi@117
  char *v57; // ecx@118
  unsigned int v58; // edx@118
  __int16 v59; // si@122
  int v60; // eax@122
  PVOID v61; // eax@122
  unsigned int v62; // esi@123
  __int32 v63; // ebx@123
  char *v64; // ecx@123
  struct _RESNAME *v65; // eax@131
  __int32 v66; // eax@131
  LONG v67; // eax@132
  __int32 v68; // edx@132
  size_t v69; // ecx@132
  LONG v70; // eax@137
  char *v71; // ST1C_4@141
  unsigned __int32 v72; // edx@142
  STRSAFE_LPSTR v73; // eax@142
  struct _RESNAME *v74; // ecx@142
  int v75; // esi@142
  int v76; // eax@143
  struct _IMAGE_SECTION_HEADER *v77; // ecx@148
  unsigned __int32 v78; // ecx@149
  int v79; // edx@150
  struct _RESNAME *v80; // eax@150
  int v81; // et1@150
  ULONG v82; // et1@150
  int v83; // eax@150
  int v84; // edi@150
  LONG v85; // edi@153
  struct _IMAGE_RESOURCE_DIRECTORY *v86; // edi@154
  LONG v87; // esi@154
  int v88; // ebx@154
  int v89; // esi@154
  LONG v90; // eax@154
  int v91; // edi@154
  __int32 n; // eax@154
  int v93; // ecx@155
  __int32 v94; // eax@155
  struct _RESNAME *v95; // eax@155
  struct _RESNAME *v96; // edx@156
  int v97; // eax@158
  unsigned __int8 v98; // cf@159
  unsigned __int16 v99; // cx@161
  int v100; // eax@163
  struct _RESNAME *v101; // eax@166
  unsigned __int16 v102; // ST24_2@166
  int v103; // eax@167
  STRSAFE_LPSTR v104; // ecx@167
  struct _RESNAME **v105; // edx@167
  struct _RESNAME *v106; // edx@168
  struct _RESNAME *v107; // eax@172
  unsigned __int16 v108; // ST24_2@172
  int v109; // eax@173
  STRSAFE_LPSTR v110; // ecx@173
  struct _RESNAME **v111; // edx@173
  __int32 ii; // eax@176
  __int32 v113; // eax@177
  int v114; // ecx@177
  struct _RESNAME *v115; // eax@177
  struct _RESNAME *v116; // edx@178
  int v117; // eax@180
  bool v118; // cf@181
  unsigned __int16 v119; // cx@183
  int v120; // eax@185
  struct _RESNAME *v121; // eax@188
  unsigned __int16 v122; // ST24_2@188
  int v123; // eax@189
  STRSAFE_LPSTR v124; // ecx@189
  struct _RESNAME **v125; // edx@189
  struct _RESNAME *v126; // edx@190
  struct _RESNAME *v127; // eax@194
  unsigned __int16 v128; // ST24_2@194
  int v129; // eax@195
  STRSAFE_LPSTR v130; // ecx@195
  struct _RESNAME **v131; // edx@195
  unsigned int v132; // ecx@199
  int v133; // edi@199
  int jj; // ecx@199
  HFILE v135; // esi@202
  unsigned __int32 v136; // edx@204
  unsigned __int32 v137; // eax@204
  unsigned __int32 v138; // edi@204
  void *v139; // eax@207
  PVOID v140; // edi@207
  STRSAFE_LPSTR v141; // ebx@207
  LONG v142; // eax@213
  LONG v143; // eax@218
  struct _RESNAME *v144; // ST24_4@218
  LONG v145; // eax@218
  int v146; // eax@218
  LONG v147; // eax@222
  LONG v148; // eax@235
  struct _IMAGE_SECTION_HEADER *v149; // eax@237
  int v150; // eax@239
  int v151; // eax@241
  LONG v152; // ebx@247
  LONG v153; // eax@247
  unsigned __int8 v154; // [sp+Ch] [bp-278h]@1
  unsigned __int16 v155; // [sp+12h] [bp-272h]@1
  int v156; // [sp+48h] [bp-23Ch]@207
  CHAR v157[4]; // [sp+60h] [bp-224h]@109
  unsigned int v158; // [sp+C4h] [bp-1C0h]@83
  CHAR Buffer; // [sp+114h] [bp-170h]@3
  unsigned __int16 v160; // [sp+11Ah] [bp-16Ah]@95
  int v161; // [sp+120h] [bp-164h]@247
  int v162; // [sp+134h] [bp-150h]@207
  int v163; // [sp+14Ch] [bp-138h]@130
  unsigned __int32 v164; // [sp+150h] [bp-134h]@110
  int v165; // [sp+164h] [bp-120h]@143
  unsigned int v166; // [sp+168h] [bp-11Ch]@112
  char v167[16]; // [sp+19Ch] [bp-E8h]@111
  int v168; // [sp+1ACh] [bp-D8h]@212
  unsigned __int32 v169; // [sp+1B0h] [bp-D4h]@212
  ULONG v170; // [sp+1C4h] [bp-C0h]@238
  int v171; // [sp+1D0h] [bp-B4h]@246
  unsigned __int32 v172; // [sp+21Ch] [bp-68h]@1
  int v173; // [sp+220h] [bp-64h]@5
  int v174; // [sp+224h] [bp-60h]@85
  int v175; // [sp+228h] [bp-5Ch]@82
  int v176; // [sp+22Ch] [bp-58h]@45
  LONG v177; // [sp+230h] [bp-54h]@122
  LONG v178; // [sp+234h] [bp-50h]@1
  void *Dst; // [sp+238h] [bp-4Ch]@3
  struct _IMAGE_SECTION_HEADER *v180; // [sp+23Ch] [bp-48h]@45
  ULONG v181; // [sp+240h] [bp-44h]@45
  unsigned __int16 v182[2]; // [sp+244h] [bp-40h]@1
  struct _IMAGE_SECTION_HEADER *v183; // [sp+248h] [bp-3Ch]@5
  unsigned int v184; // [sp+24Ch] [bp-38h]@1
  STRSAFE_LPSTR pszDest; // [sp+250h] [bp-34h]@123
  int v186; // [sp+254h] [bp-30h]@1
  LONG v187; // [sp+258h] [bp-2Ch]@1
  PVOID v188; // [sp+25Ch] [bp-28h]@1
  int v189; // [sp+260h] [bp-24h]@1
  PVOID Address; // [sp+264h] [bp-20h]@123
  __int32 v191; // [sp+268h] [bp-1Ch]@48
  struct _RESNAME *v192; // [sp+26Ch] [bp-18h]@1
  unsigned __int32 v193; // [sp+270h] [bp-14h]@11
  int v194; // [sp+274h] [bp-10h]@1
  size_t Size; // [sp+278h] [bp-Ch]@2
  LONG v196; // [sp+27Ch] [bp-8h]@1
  struct _RESNAME *l; // [sp+280h] [bp-4h]@65
  HFILE hFilea; // [sp+290h] [bp+Ch]@234

  v188 = (PVOID)-1;
  v186 = -1;
  v194 = 0;
  v192 = 0;
  *(_DWORD *)v182 = 0;
  v187 = 0;
  v189 = 0;
  v184 = 0;
  v196 = 0;
  v172 = 0;
  MuMoveFilePos(a1, lOffset);
  MuRead(a1, &v154, 0x108u);
  v5 = lOffset + 264;
  if ( ULongLongToULong(40i64 * v155, (ULONG *)&v178) < 0 )
    return 534;
  v178 += v5;
  qmemcpy(&Buffer, &v154, 0x108u);
  v6 = KernelBaseGetGlobalData();
  Dst = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v6 + 44) + 1835008) | 8,
          40 * v155);
  if ( !Dst )
    return 8;
  v7 = (unsigned __int8 *)Dst;
  v8 = 0;
  memset(Dst, 0, 40 * v155);
  MuMoveFilePos(a1, v5);
  MuRead(a1, v7, 40 * v155);
  v183 = (struct _IMAGE_SECTION_HEADER *)&v7[40 * v155];
  v173 = 0;
  if ( (unsigned int)v7 < (unsigned int)v183 )
  {
    v9 = (int)(v7 + 20);
    v10 = (40 * (unsigned int)v155 - 1) / 0x28 + 1;
    do
    {
      if ( *(_DWORD *)v9 > (unsigned int)v8 )
        v8 = *(_DWORD *)v9 + *(_DWORD *)(v9 - 4);
      v9 += 40;
      --v10;
    }
    while ( v10 );
    v173 = v8;
  }
  v193 = 0;
  for ( i = *((_DWORD *)a4 + 4); i; i = *(_DWORD *)i )
  {
    v12 = *(_DWORD *)(i + 16);
    if ( v12 || *(_DWORD *)(i + 12) )
    {
      v13 = *(_WORD *)(*(_DWORD *)(i + 4) + 14);
      ++v187;
      ++*(_DWORD *)v182;
      v192 = (struct _RESNAME *)((char *)v192 + 2 * v13 + 2);
      v14 = 0;
      while ( v12 )
      {
        ++v184;
        if ( !v14
          || (v15 = *(_DWORD *)(v12 + 4),
              wcscmp(*(const unsigned __int16 **)(v14 + 16), *(const unsigned __int16 **)(v15 + 16))) )
        {
          v15 = *(_DWORD *)(v12 + 4);
          v16 = *(_WORD *)(v15 + 14);
          ++v189;
          v194 += 2 * v16 + 2;
        }
        v17 = *(_DWORD *)(v12 + 20);
        v12 = *(_DWORD *)v12;
        v193 += (v17 + 3) & 0xFFFFFFFC;
        v14 = v15;
      }
      v18 = *(_DWORD *)(i + 12);
      v19 = 0;
      while ( v18 )
      {
        ++v184;
        if ( !v19 || *(_WORD *)(v19 + 4) != *(_WORD *)(*(_DWORD *)(v18 + 4) + 4) )
          ++v189;
        v193 += (*(_DWORD *)(v18 + 20) + 3) & 0xFFFFFFFC;
        v19 = *(_DWORD *)(v18 + 4);
        v18 = *(_DWORD *)v18;
      }
    }
  }
  for ( j = *((_DWORD *)a4 + 3); j; j = *(_DWORD *)j )
  {
    v21 = *(_DWORD *)(j + 16);
    if ( v21 || *(_DWORD *)(j + 12) )
    {
      ++v187;
      v22 = 0;
      while ( v21 )
      {
        ++v184;
        if ( !v22
          || (v23 = *(_DWORD *)(v21 + 4),
              wcscmp(*(const unsigned __int16 **)(v22 + 16), *(const unsigned __int16 **)(v23 + 16))) )
        {
          v23 = *(_DWORD *)(v21 + 4);
          v24 = *(_WORD *)(v23 + 14);
          ++v189;
          v194 += 2 * v24 + 2;
        }
        v25 = *(_DWORD *)(v21 + 20);
        v21 = *(_DWORD *)v21;
        v193 += (v25 + 3) & 0xFFFFFFFC;
        v22 = v23;
      }
      v26 = *(_DWORD *)(j + 12);
      v27 = 0;
      while ( v26 )
      {
        ++v184;
        if ( !v27 || *(_WORD *)(v27 + 4) != *(_WORD *)(*(_DWORD *)(v26 + 4) + 4) )
          ++v189;
        v193 += (*(_DWORD *)(v26 + 20) + 3) & 0xFFFFFFFC;
        v27 = *(_DWORD *)(v26 + 4);
        v26 = *(_DWORD *)v26;
      }
    }
  }
  v28 = (struct _IMAGE_SECTION_HEADER *)Dst;
  v29 = v187 + v189 + v184 + 2 * (v187 + v184 + v189) + 2;
  v30 = (char *)v192 + 8 * v29 + (-(signed int)((char *)v192 + v194) & 3) + v194;
  v193 += (unsigned __int32)v30;
  v181 = (ULONG)((char *)v192 + 8 * v29 + (-(signed int)((char *)v192 + v194) & 3) + v194);
  v31 = FindSection((struct _IMAGE_SECTION_HEADER *)Dst, v183, ".rsrc");
  v176 = (int)v31;
  v180 = FindSection(v28, v183, ".rsrc1");
  v32 = FindSection(v28, v183, ".reloc");
  if ( !v31 )
    goto LABEL_46;
  if ( &v31[1] == v180 )
  {
    v35 = v31;
LABEL_52:
    v188 = (PVOID)(v35 - v28);
    v36 = 0x7FFFFFFF;
    Size = 0x7FFFFFFF;
    goto LABEL_53;
  }
  v35 = v31;
  if ( &v31[1] >= v183 )
    goto LABEL_52;
  v188 = (PVOID)(v31 - v28);
  if ( v32 )
    v36 = v31[1].VirtualAddress - v31->VirtualAddress;
  else
    v36 = 0x7FFFFFFF;
  Size = v36;
  if ( (unsigned int)v30 > v36 )
    return 13;
LABEL_53:
  if ( v193 <= v36 )
    goto LABEL_47;
  if ( v32 == &v31[1] )
  {
LABEL_46:
    Size = 0x7FFFFFFF;
LABEL_47:
    v33 = v196;
    goto LABEL_48;
  }
  if ( v180 )
    v32 = v180;
  v33 = v32->VirtualAddress - v31->VirtualAddress;
  v186 = ((char *)v32 - (_BYTE *)Dst) / 40;
LABEL_48:
  v191 = 0;
  v193 = (unsigned __int32)v30;
  for ( k = *((_DWORD *)a4 + 4); k; k = *(_DWORD *)k )
  {
    v38 = *(_DWORD *)(k + 16);
    if ( v38 || *(_DWORD *)(k + 12) )
    {
      l = *(struct _RESNAME **)(k + 16);
      if ( v38 )
      {
        do
          v193 = AssignResourceToSection(&l, v33, v193, Size, &v191);
        while ( l );
      }
      for ( l = *(struct _RESNAME **)(k + 12); l; v193 = AssignResourceToSection(&l, v33, v193, Size, &v191) )
        ;
    }
  }
  for ( m = *((_DWORD *)a4 + 3); m; m = *(_DWORD *)m )
  {
    v40 = *(_DWORD *)(m + 16);
    if ( v40 || *(_DWORD *)(m + 12) )
    {
      l = *(struct _RESNAME **)(m + 16);
      if ( v40 )
      {
        do
          v193 = AssignResourceToSection(&l, v33, v193, Size, &v191);
        while ( l );
      }
      for ( l = *(struct _RESNAME **)(m + 12); l; v193 = AssignResourceToSection(&l, v33, v193, Size, &v191) )
        ;
    }
  }
  if ( !v191 )
    v191 = v193;
  v41 = v183;
  v42 = (struct _IMAGE_SECTION_HEADER *)Dst;
  v43 = (int)FindSection((struct _IMAGE_SECTION_HEADER *)Dst, v183, ".debug");
  v175 = v43;
  if ( v43 && (!v158 || (struct _IMAGE_SECTION_HEADER *)v43 != &v41[-1]) )
    return 13;
  v174 = 0;
  v44 = (int)v42;
  if ( v42 < v41 )
  {
    while ( 1 )
    {
      v45 = *(_DWORD *)(v44 + 12);
      if ( v158 >= v45 && v158 < v45 + *(_DWORD *)(v44 + 16) )
        break;
      v44 += 40;
      if ( v44 >= (unsigned int)v41 )
        goto LABEL_91;
    }
    v174 = v44;
  }
LABEL_91:
  v46 = (int)FindSection(v42, v41, ".reloc");
  v47 = v188;
  v48 = v46;
  if ( v188 == (PVOID)-1 )
  {
    if ( v46 || (v46 = v175) != 0 )
      v47 = (PVOID)((v46 - (signed int)v42) / 40);
    else
      v47 = (PVOID)v160;
    ++v160;
  }
  if ( v186 == -1 )
  {
    if ( v180 )
      --v160;
    goto LABEL_109;
  }
  if ( !v180 )
  {
    if ( v48 )
    {
      v49 = v48;
    }
    else
    {
      v49 = v175;
      if ( !v175 )
      {
        v50 = v160;
        goto LABEL_105;
      }
    }
    v50 = (v49 - (signed int)v42) / 40;
LABEL_105:
    v186 = v50;
    goto LABEL_106;
  }
  v186 = v180 - v42;
  --v160;
LABEL_106:
  ++v160;
LABEL_109:
  v51 = 40 * (v160 - v155);
  v52 = *(_DWORD *)v157 - 40 * v155 - lOffset - 264;
  if ( v51 <= (unsigned int)v52 )
  {
    if ( v51 )
    {
      v56 = 0;
      do
      {
        v57 = &v167[8 * v56];
        v58 = *(_DWORD *)v57;
        if ( *(_DWORD *)v57 && v58 < *(_DWORD *)v157 )
          *(_DWORD *)v57 = v51 + v58;
        ++v56;
      }
      while ( v56 < 16 );
    }
  }
  else
  {
    v51 -= v52;
    v172 = ~(v164 - 1) & (v164 + v51 - 1);
    v53 = 0;
    do
    {
      v54 = &v167[8 * v53];
      v55 = *(_DWORD *)v54;
      if ( *(_DWORD *)v54 && v55 < v166 )
        *(_DWORD *)v54 = v51 + v55;
      ++v53;
    }
    while ( v53 < 16 );
    v166 += v51;
  }
  v59 = 40 * v160;
  v177 = v51 + v178;
  Size = 40 * v160;
  v60 = KernelBaseGetGlobalData();
  v61 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v60 + 44) + 1835008) | 8,
          v59);
  v188 = v61;
  if ( !v61 )
    goto LABEL_144;
  v62 = (unsigned int)v61;
  memset(v61, 0, Size);
  pszDest = (STRSAFE_LPSTR)(v62 + 40 * (_DWORD)v47);
  v63 = 0;
  Address = 0;
  v64 = (char *)v42;
  l = (struct _RESNAME *)v42;
  v196 = v62;
  if ( v42 >= v183 )
    goto LABEL_141;
  do
  {
    if ( (struct _IMAGE_SECTION_HEADER *)v64 != v180 )
    {
      if ( (STRSAFE_LPSTR)v62 == pszDest )
      {
        Address = (PVOID)1;
        Size = ~(v164 - 1) & (v191 + v164 - 1);
        if ( v176 )
        {
          v67 = v196;
          v68 = v191;
          qmemcpy((void *)v196, (const void *)l, 0x28u);
          v69 = Size;
          *(_DWORD *)(v67 + 16) = Size;
          *(_DWORD *)(v67 + 8) = v68;
          if ( v69 == *((_DWORD *)l + 4) )
          {
            v63 = 0;
          }
          else
          {
            v63 += (v68 + v163 - 1) & ~(v163 - 1);
            if ( (unsigned int)((char *)l + 40) < (unsigned int)v183 )
              v63 += *((_DWORD *)l + 3) - *((_DWORD *)l + 13);
          }
        }
        else
        {
          v63 = (v191 + v163 - 1) & ~(v163 - 1);
          memset((void *)v62, 0, 0x28u);
          if ( StringCchCopyA((STRSAFE_LPSTR)v62, 8u, ".rsrc") < 0 )
            goto LABEL_251;
          v65 = l;
          *(_DWORD *)(v62 + 12) = *((_DWORD *)l + 3);
          *(_DWORD *)(v62 + 20) = *((_DWORD *)v65 + 5);
          *(_DWORD *)(v62 + 16) = Size;
          v66 = v191;
          *(_DWORD *)(v62 + 36) = 1073741888;
          *(_DWORD *)(v62 + 8) = v66;
        }
        v196 += 40;
        if ( v176 )
          goto LABEL_138;
      }
      else if ( v186 == -1 || (PVOID)v62 != (char *)v188 + 40 * v186 )
      {
        if ( v62 < (unsigned int)pszDest )
        {
          v85 = v196;
          v196 += 40;
          qmemcpy((void *)v85, (const void *)l, 0x28u);
          goto LABEL_138;
        }
      }
      else
      {
        memset((void *)v62, 0, 0x28u);
        if ( StringCchCopyA((STRSAFE_LPSTR)v62, 8u, ".rsrc1") < 0 )
          goto LABEL_251;
        v77 = v180;
        if ( v180 )
        {
          v79 = v176;
          *(_DWORD *)(v62 + 12) = v180->VirtualAddress;
          v80 = l;
          *(_DWORD *)(v62 + 36) = 1073741888;
          v81 = *(_DWORD *)(v79 + 12);
          v82 = v77->VirtualAddress;
          v83 = *((_DWORD *)v80 + 3);
          v84 = v83 - *(_DWORD *)(v62 + 12);
          v63 = *((_DWORD *)pszDest + 3) + (~(v163 - 1) & (v163 + v193 - 1)) - v83;
        }
        else
        {
          v78 = v193;
          *(_DWORD *)(v62 + 12) = *((_DWORD *)l + 3);
          *(_DWORD *)(v62 + 36) = 1073741888;
          v63 = *((_DWORD *)pszDest + 3) + (~(v163 - 1) & (v163 + v78 - 1)) - *(_DWORD *)(v62 + 12);
        }
        v196 = v62 + 40;
      }
      v70 = v196 + 40;
      qmemcpy((void *)v196, (const void *)l, 0x28u);
      *(_DWORD *)(v70 - 28) += v63;
      v196 = v70;
LABEL_138:
      v62 = v196;
      goto LABEL_139;
    }
    if ( v186 == -1 && (unsigned int)(v64 + 40) < (unsigned int)v183 )
      v63 += *((_DWORD *)v64 + 3) - *((_DWORD *)v64 + 13);
LABEL_139:
    v64 = (char *)l + 40;
    l = (struct _RESNAME *)v64;
  }
  while ( (unsigned int)v64 < (unsigned int)v183 );
  if ( !Address )
  {
LABEL_141:
    v71 = pszDest;
    memset(pszDest, 0, 0x28u);
    if ( StringCchCopyA(v71, 8u, ".rsrc") < 0 )
      goto LABEL_251;
    v72 = ~(v164 - 1) & (v164 + v191 - 1);
    v73 = pszDest;
    *((_DWORD *)pszDest + 2) = v191;
    v74 = l;
    *((_DWORD *)v73 + 4) = v72;
    v75 = *((_DWORD *)v74 - 7) + (~(v163 - 1) & (*((_DWORD *)v74 - 8) + v163 - 1));
    *((_DWORD *)v73 + 9) = 1073741888;
    *((_DWORD *)v73 + 3) = v75;
  }
  v165 = ~(v163 - 1) & (*((_DWORD *)v188 + 10 * v160 - 7) + *((_DWORD *)v188 + 10 * v160 - 6) + v163 - 1);
  v76 = KernelBaseGetGlobalData();
  Address = RtlAllocateHeap(
              NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
              (*(_DWORD *)(v76 + 44) + 1835008) | 8,
              v181);
  if ( !Address )
  {
LABEL_144:
    Size = 8;
    goto LABEL_251;
  }
  v86 = (struct _IMAGE_RESOURCE_DIRECTORY *)Address;
  memset(Address, 0, v181);
  v87 = v187;
  SetRestab(v86, 0, v182[0], v187 - v182[0]);
  *(_DWORD *)v182 = v86 + 1;
  v88 = (int)((char *)&v86[1] + 8 * v87);
  v89 = v88 + 8 * (v189 + 2 * v87);
  v90 = v89 + 8 * (v184 + 2 * v189);
  v196 = v90;
  v91 = v90 + 16 * v184;
  v184 = (unsigned int)((char *)v192 + v91 + v194);
  for ( n = *((_DWORD *)a4 + 4); ; n = *(_DWORD *)v191 )
  {
    v191 = n;
    if ( !n )
      break;
    v93 = *(_DWORD *)v182;
    **(_DWORD **)v182 = (v91 - (_DWORD)Address) | 0x80000000;
    v93 += 8;
    v94 = v191;
    *(_DWORD *)(v93 - 4) = (v88 - (_DWORD)Address) | 0x80000000;
    *(_DWORD *)v182 = v93;
    *(_WORD *)v91 = *(_WORD *)(*(_DWORD *)(v94 + 4) + 14);
    _wcsncpy(
      (wchar_t *)(v91 + 2),
      *(const wchar_t **)(*(_DWORD *)(v94 + 4) + 16),
      *(_WORD *)(*(_DWORD *)(v94 + 4) + 14));
    v91 += 2 * *(_WORD *)(*(_DWORD *)(v191 + 4) + 14) + 2;
    SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v88, 0, *(_WORD *)(v191 + 24), *(_WORD *)(v191 + 20));
    v95 = *(struct _RESNAME **)(v191 + 16);
    v189 = 0;
    v88 += 16;
    l = v95;
    if ( v95 )
    {
      v96 = l;
      v187 = v196 - (_DWORD)Address;
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 )
          goto LABEL_256;
        v97 = *(_DWORD *)(*((_DWORD *)v96 + 1) + 16);
        v192 = *(struct _RESNAME **)(v189 + 16);
        while ( 1 )
        {
          v98 = *(_WORD *)v192 < *(_WORD *)v97;
          if ( *(_WORD *)v192 != *(_WORD *)v97 )
            break;
          if ( !*(_WORD *)v192 )
            goto LABEL_163;
          v99 = *((_WORD *)v192 + 1);
          HIWORD(Size) = v99;
          v98 = v99 < *(_WORD *)(v97 + 2);
          if ( v99 != *(_WORD *)(v97 + 2) )
            break;
          v192 = (struct _RESNAME *)((char *)v192 + 4);
          v97 += 4;
          if ( !v99 )
          {
LABEL_163:
            v100 = 0;
            goto LABEL_165;
          }
        }
        v100 = -v98 - (v98 - 1);
LABEL_165:
        if ( v100 )
        {
LABEL_256:
          *(_DWORD *)v88 = (v91 - (_DWORD)Address) | 0x80000000;
          v101 = l;
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          *(_WORD *)v91 = *(_WORD *)(*((_DWORD *)v101 + 1) + 14);
          v88 += 8;
          _wcsncpy(
            (wchar_t *)(v91 + 2),
            *(const wchar_t **)(*((_DWORD *)v101 + 1) + 16),
            *(_WORD *)(*((_DWORD *)v101 + 1) + 14));
          v102 = *((_WORD *)l + 15);
          v91 += 2 * *(_WORD *)(*((_DWORD *)l + 1) + 14) + 2;
          v189 = *((_DWORD *)l + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v102);
          v96 = l;
          v89 += 16;
          v194 += 16;
        }
        v103 = *((_WORD *)v96 + 16);
        v104 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v103;
        *(_DWORD *)(v89 + 4) = v187;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v104 + 3) + *((_DWORD *)v96 + 2),
          *((_DWORD *)v96 + 5));
        v96 = *v105;
        v196 += 16;
        v187 += 16;
        l = v96;
      }
      while ( v96 );
    }
    v106 = *(struct _RESNAME **)(v191 + 12);
    v189 = 0;
    l = v106;
    if ( v106 )
    {
      v192 = (struct _RESNAME *)(v196 - (_DWORD)Address);
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 || *(_WORD *)(v189 + 4) != *(_WORD *)(*((_DWORD *)v106 + 1) + 4) )
        {
          v107 = l;
          *(_DWORD *)v88 = *(_WORD *)(*((_DWORD *)l + 1) + 4);
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          v108 = *((_WORD *)v107 + 15);
          v88 += 8;
          v189 = *((_DWORD *)v107 + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v108);
          v106 = l;
          v89 += 16;
          v194 += 16;
        }
        v109 = *((_WORD *)v106 + 16);
        v110 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v109;
        *(_DWORD *)(v89 + 4) = v192;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v110 + 3) + *((_DWORD *)v106 + 2),
          *((_DWORD *)v106 + 5));
        v106 = *v111;
        v196 += 16;
        v192 = (struct _RESNAME *)((char *)v192 + 16);
        l = v106;
      }
      while ( v106 );
    }
  }
  for ( ii = *((_DWORD *)a4 + 3); ; ii = *(_DWORD *)v191 )
  {
    v191 = ii;
    if ( !ii )
      break;
    v113 = v191;
    v114 = *(_DWORD *)v182;
    **(_DWORD **)v182 = *(_WORD *)(*(_DWORD *)(v191 + 4) + 4);
    v114 += 8;
    *(_DWORD *)(v114 - 4) = (v88 - (_DWORD)Address) | 0x80000000;
    *(_DWORD *)v182 = v114;
    SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v88, 0, *(_WORD *)(v113 + 24), *(_WORD *)(v113 + 20));
    v115 = *(struct _RESNAME **)(v191 + 16);
    v189 = 0;
    v88 += 16;
    l = v115;
    if ( v115 )
    {
      v116 = l;
      v187 = v196 - (_DWORD)Address;
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 )
          goto LABEL_257;
        v117 = *(_DWORD *)(*((_DWORD *)v116 + 1) + 16);
        v192 = *(struct _RESNAME **)(v189 + 16);
        while ( 1 )
        {
          v118 = *(_WORD *)v192 < *(_WORD *)v117;
          if ( *(_WORD *)v192 != *(_WORD *)v117 )
            break;
          if ( !*(_WORD *)v192 )
            goto LABEL_185;
          v119 = *((_WORD *)v192 + 1);
          HIWORD(Size) = v119;
          v118 = v119 < *(_WORD *)(v117 + 2);
          if ( v119 != *(_WORD *)(v117 + 2) )
            break;
          v192 = (struct _RESNAME *)((char *)v192 + 4);
          v117 += 4;
          if ( !v119 )
          {
LABEL_185:
            v120 = 0;
            goto LABEL_187;
          }
        }
        v120 = -v118 - (v118 - 1);
LABEL_187:
        if ( v120 )
        {
LABEL_257:
          *(_DWORD *)v88 = (v91 - (_DWORD)Address) | 0x80000000;
          v121 = l;
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          *(_WORD *)v91 = *(_WORD *)(*((_DWORD *)v121 + 1) + 14);
          v88 += 8;
          _wcsncpy(
            (wchar_t *)(v91 + 2),
            *(const wchar_t **)(*((_DWORD *)v121 + 1) + 16),
            *(_WORD *)(*((_DWORD *)v121 + 1) + 14));
          v122 = *((_WORD *)l + 15);
          v91 += 2 * *(_WORD *)(*((_DWORD *)l + 1) + 14) + 2;
          v189 = *((_DWORD *)l + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v122);
          v116 = l;
          v89 += 16;
          v194 += 16;
        }
        v123 = *((_WORD *)v116 + 16);
        v124 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v123;
        *(_DWORD *)(v89 + 4) = v187;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v124 + 3) + *((_DWORD *)v116 + 2),
          *((_DWORD *)v116 + 5));
        v116 = *v125;
        v196 += 16;
        v187 += 16;
        l = v116;
      }
      while ( v116 );
    }
    v126 = *(struct _RESNAME **)(v191 + 12);
    v189 = 0;
    l = v126;
    if ( v126 )
    {
      v192 = (struct _RESNAME *)(v196 - (_DWORD)Address);
      v194 = v89 - (_DWORD)Address;
      do
      {
        if ( !v189 || *(_WORD *)(v189 + 4) != *(_WORD *)(*((_DWORD *)v126 + 1) + 4) )
        {
          v127 = l;
          *(_DWORD *)v88 = *(_WORD *)(*((_DWORD *)l + 1) + 4);
          *(_DWORD *)(v88 + 4) = v194 | 0x80000000;
          v128 = *((_WORD *)v127 + 15);
          v88 += 8;
          v189 = *((_DWORD *)v127 + 1);
          SetRestab((struct _IMAGE_RESOURCE_DIRECTORY *)v89, 0, 0, v128);
          v126 = l;
          v89 += 16;
          v194 += 16;
        }
        v129 = *((_WORD *)v126 + 16);
        v130 = pszDest;
        v194 += 8;
        *(_DWORD *)v89 = v129;
        *(_DWORD *)(v89 + 4) = v192;
        v89 += 8;
        SetResdata(
          (struct _IMAGE_RESOURCE_DATA_ENTRY *)v196,
          *((_DWORD *)v130 + 3) + *((_DWORD *)v126 + 2),
          *((_DWORD *)v126 + 5));
        v126 = *v131;
        v196 += 16;
        v192 = (struct _RESNAME *)((char *)v192 + 16);
        l = v126;
      }
      while ( v126 );
    }
  }
  if ( v91 < v184 )
  {
    v132 = ((v184 - v91 - 1) >> 1) + 1;
    v98 = v132 & 1;
    v132 >>= 1;
    memset((void *)v91, 0, 4 * v132);
    v133 = v91 + 4 * v132;
    for ( jj = v98; jj; --jj )
    {
      *(_WORD *)v133 = 0;
      v133 += 2;
    }
  }
  MuMoveFilePos(a1, 0);
  v135 = hFile;
  MuCopy(a1, hFile, lOffset + 264);
  MuMoveFilePos(hFile, v177);
  MuMoveFilePos(a1, v178);
  if ( (unsigned int)v177 < *(_DWORD *)v157 )
    MuCopy(a1, hFile, *(_DWORD *)v157 - v177);
  v136 = (v164 - 1) & v166;
  v137 = (v164 - 1) & (v164 - v136);
  v138 = (v164 - 1) & (v164 - v136);
  v166 += v138;
  if ( (signed int)v138 >= 16 )
  {
    hFile = v137 >> 4;
    v138 += -16 * (v137 >> 4);
    do
    {
      MuWrite(v135, pchZero, 0x10u);
      --hFile;
    }
    while ( hFile );
  }
  MuWrite(v135, pchZero, v138);
  MuMoveFilePos(a1, ~(v156 - 1) & (*(_DWORD *)v157 + v156 - 1));
  v139 = Dst;
  v162 = 0;
  v178 = 0;
  v140 = v188;
  v141 = pszDest;
  l = (struct _RESNAME *)Dst;
  while ( 2 )
  {
    if ( v139 < v183 )
    {
      if ( (struct _IMAGE_SECTION_HEADER *)l == v180 )
        l = (struct _RESNAME *)((char *)l + 40);
      if ( v140 == v141 )
      {
        v178 = 1;
        *((_DWORD *)v140 + 5) = FilePos(v135);
        v168 = *((_DWORD *)v141 + 3);
        v169 = v193;
        hFile = FilePos(v135);
        MuWrite(v135, (LPCCH)Address, v181);
        v192 = (struct _RESNAME *)WriteResSection(a4, v135, v164, *((_DWORD *)v141 + 4) - v181, 0);
        Size = FilePos(v135);
        if ( v186 == -1 )
        {
          MuMoveFilePos(v135, hFile);
          MuWrite(v135, (LPCCH)Address, v181);
          MuMoveFilePos(v135, Size);
          v142 = FilePos(a1);
          MuMoveFilePos(a1, v142 + *((_DWORD *)l + 4));
        }
        v162 += *((_DWORD *)v140 + 4);
        if ( v176 )
          goto LABEL_230;
LABEL_219:
        v140 = (char *)v140 + 40;
      }
      else
      {
        if ( v186 != -1 && v140 == (char *)v188 + 40 * v186 )
        {
          v143 = FilePos(v135);
          v144 = v192;
          *((_DWORD *)v140 + 5) = v143;
          WriteResSection(a4, v135, v164, 0xFFFFFFFF, v144);
          v145 = FilePos(v135);
          Size = v145;
          v146 = v145 - *((_DWORD *)v140 + 5);
          *((_DWORD *)v140 + 4) = v146;
          *((_DWORD *)v140 + 2) = v146;
          MuMoveFilePos(v135, hFile);
          MuWrite(v135, (LPCCH)Address, v181);
          MuMoveFilePos(v135, Size);
          v162 += *((_DWORD *)v140 + 4);
          goto LABEL_219;
        }
        if ( v140 < v141 )
        {
          if ( *((_DWORD *)l + 5) )
          {
            v177 = *((_DWORD *)l + 5);
            v147 = FilePos(v135);
            if ( v177 != v147 )
              MuMoveFilePos(v135, v172 + v177);
          }
        }
      }
      if ( *((_DWORD *)l + 5) )
      {
        *((_DWORD *)v140 + 5) = FilePos(v135);
        MuMoveFilePos(a1, *((_DWORD *)l + 5));
        MuCopy(a1, v135, *((_DWORD *)l + 4));
      }
      if ( l == (struct _RESNAME *)v174 )
        *(_DWORD *)v182 = v140;
      if ( *((_BYTE *)v140 + 36) & 0x40 )
        v162 += *((_DWORD *)v140 + 4);
LABEL_230:
      l = (struct _RESNAME *)((char *)l + 40);
      v139 = (void *)l;
      v140 = (char *)v140 + 40;
      continue;
    }
    break;
  }
  if ( v180 )
    v162 -= v180->SizeOfRawData;
  if ( !v178 )
  {
    *((_DWORD *)v141 + 5) = FilePos(v135);
    v168 = *((_DWORD *)v141 + 3);
    v169 = v193;
    hFilea = FilePos(v135);
    MuWrite(v135, (LPCCH)Address, v181);
    WriteResSection(a4, v135, v164, *((_DWORD *)v141 + 4) - v181, 0);
    Size = FilePos(v135);
    if ( v186 == -1 )
    {
      MuMoveFilePos(v135, hFilea);
      MuWrite(v135, (LPCCH)Address, v181);
      MuMoveFilePos(v135, Size);
      v148 = FilePos(a1);
      MuMoveFilePos(a1, v148 + *((_DWORD *)l + 4));
    }
    v162 += *((_DWORD *)v140 + 4);
  }
  v149 = FindSection((struct _IMAGE_SECTION_HEADER *)v188, (struct _IMAGE_SECTION_HEADER *)v188 + v160, ".reloc");
  if ( v149 )
    v170 = v149->VirtualAddress;
  MuMoveFilePos(v135, lOffset + 264);
  MuWrite(v135, (LPCCH)v188, 40 * v160);
  v196 = _llseek(v135, 0, 2);
  MuWrite(v135, 0, 0);
  v150 = (int)FindSection((struct _IMAGE_SECTION_HEADER *)v188, (struct _IMAGE_SECTION_HEADER *)v188 + v160, ".debug");
  Size = PatchDebug<_IMAGE_NT_HEADERS64>(
           a1,
           v135,
           v175,
           v150,
           v174,
           *(int *)v182,
           (int)&v154,
           (int)&Buffer,
           v173,
           (int)&v196);
  if ( !Size )
  {
    if ( v176 )
      v151 = *(_DWORD *)(v176 + 16) - *((_DWORD *)v141 + 4);
    else
      v151 = *((_DWORD *)v141 + 4);
    Size = PatchRVAs<_IMAGE_NT_HEADERS64>(a1, v135, (int)v188, v151, (int)&Buffer, v157[0]);
  }
  if ( v174 && !v175 && v171 )
  {
    v152 = _llseek(a1, 0, 2);
    v153 = _llseek(v135, 0, 2);
    if ( v161 )
      v161 += v153 - v196;
    MuMoveFilePos(a1, v196);
    MuCopy(a1, v135, v152 - v196);
  }
  MuMoveFilePos(v135, lOffset);
  MuWrite(v135, &Buffer, 0x108u);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Dst);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
LABEL_251:
  if ( v188 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v188);
  return Size;
}
// 77E7C07F: using guessed type char var_E8[16];

//----- (77E7D3B4) --------------------------------------------------------
BOOL __stdcall UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
{
  LPVOID v6; // eax@1
  LPVOID v7; // esi@1
  void *v8; // ebx@20
  int v9; // eax@21
  int v10; // edi@21
  PVOID v11; // eax@21
  LPCWSTR lpTypea; // [sp+18h] [bp+Ch]@15
  LPCWSTR lpNamea; // [sp+1Ch] [bp+10h]@12

  RtlSetLastWin32Error(0);
  v6 = GlobalLock(hUpdate);
  v7 = v6;
  if ( !v6 )
    goto LABEL_2;
  if ( lpData )
  {
    if ( !cb )
      goto LABEL_2;
  }
  else if ( cb )
  {
LABEL_2:
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !GlobalLock(*((HGLOBAL *)v6 + 6)) )
  {
    RtlSetLastWin32Error(1359);
    return 0;
  }
  if ( !IsResUpdateAllowable((struct _UPDATEDATA *)v7, lpType, wLanguage) )
  {
    GlobalUnlock(hUpdate);
    RtlSetLastWin32Error(50);
    return 0;
  }
  lpNamea = (LPCWSTR)AddStringOrID((wchar_t *)lpName, (struct _UPDATEDATA *)v7);
  if ( !lpNamea )
  {
    *((_DWORD *)v7 + 5) = 8;
LABEL_14:
    GlobalUnlock(hUpdate);
    RtlSetLastWin32Error(8);
    return 0;
  }
  lpTypea = (LPCWSTR)AddStringOrID((wchar_t *)lpType, (struct _UPDATEDATA *)v7);
  if ( !lpTypea )
  {
    *((_DWORD *)v7 + 5) = 8;
    if ( *(_DWORD *)lpNamea == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpNamea);
    FreeStrings((struct _UPDATEDATA *)v7);
    goto LABEL_14;
  }
  if ( !cb )
  {
    v8 = 0;
LABEL_28:
    v10 = AddResource((PVOID)lpTypea, (PVOID)lpNamea, wLanguage, (struct _UPDATEDATA *)v7, hUpdate, v8, cb);
    if ( !v10 )
    {
      GlobalUnlock(hUpdate);
      return 1;
    }
    GlobalFree(*((HGLOBAL *)v7 + 6));
    FreeData((struct _UPDATEDATA *)v7);
    GlobalUnlock(hUpdate);
    if ( v8 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v8);
    goto LABEL_32;
  }
  v9 = KernelBaseGetGlobalData();
  v10 = 8;
  v11 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], (*(_DWORD *)(v9 + 44) + 1835008) | 8, cb);
  v8 = v11;
  if ( v11 )
  {
    memcpy(v11, lpData, cb);
    goto LABEL_28;
  }
  *((_DWORD *)v7 + 5) = 8;
  if ( *(_DWORD *)lpTypea == 2 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpTypea);
  if ( *(_DWORD *)lpNamea == 2 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpNamea);
  FreeStrings((struct _UPDATEDATA *)v7);
  GlobalUnlock(hUpdate);
LABEL_32:
  RtlSetLastWin32Error(v10);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7D57C) --------------------------------------------------------
BOOL __stdcall UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
{
  void *v6; // esi@1
  void *v7; // ebx@2
  NTSTATUS v8; // eax@4
  LSA_UNICODE_STRING UnicodeString; // [sp+10h] [bp-34h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-2Ch]@3
  STRING SourceString; // [sp+20h] [bp-24h]@4
  int v13; // [sp+28h] [bp-1Ch]@5
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@3

  v6 = (void *)lpType;
  if ( lpType )
  {
    v7 = (void *)lpName;
    if ( lpName )
    {
      RtlInitUnicodeString(&DestinationString, 0);
      RtlInitUnicodeString(&UnicodeString, 0);
      ms_exc.registration.TryLevel = 0;
      if ( (unsigned int)lpType >= 0x10000 )
      {
        SourceString.Length = strlen(lpType);
        SourceString.Buffer = (PCHAR)lpType;
        v8 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u);
        if ( v8 < 0 )
        {
LABEL_5:
          BaseSetLastNTError(v8);
          v13 = 0;
LABEL_11:
          ms_exc.registration.TryLevel = -2;
          RtlFreeUnicodeString(&DestinationString);
          RtlFreeUnicodeString(&UnicodeString);
          return v13;
        }
        v6 = DestinationString.Buffer;
      }
      if ( (unsigned int)lpName >= 0x10000 )
      {
        SourceString.Length = strlen(lpName);
        SourceString.Buffer = (PCHAR)lpName;
        v8 = RtlAnsiStringToUnicodeString(&UnicodeString, &SourceString, 1u);
        if ( v8 < 0 )
          goto LABEL_5;
        v7 = UnicodeString.Buffer;
      }
      v13 = UpdateResourceW(hUpdate, (LPCWSTR)v6, (LPCWSTR)v7, wLanguage, lpData, cb);
      goto LABEL_11;
    }
  }
  BaseSetLastNTError(-1073741811);
  return 0;
}

//----- (77E7D6A9) --------------------------------------------------------
BOOL __stdcall EnumLangsFunc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam)
{
  wchar_t *v5; // esi@1
  wchar_t *v6; // edi@1
  NTSTATUS v7; // eax@1
  LONG_PTR v9; // esi@7
  DWORD v10; // edi@9
  int v11; // eax@10
  PVOID v12; // eax@10
  void *v13; // esi@10
  HGLOBAL v14; // eax@11
  LPVOID v15; // eax@12
  unsigned __int32 v16; // ST18_4@19
  LONG_PTR v17; // edi@19
  LPCWSTR v18; // [sp+Ch] [bp-10h]@1
  LPCWSTR v19; // [sp+10h] [bp-Ch]@1
  int v20; // [sp+14h] [bp-8h]@1
  PVOID Address; // [sp+18h] [bp-4h]@5
  HMODULE hModulea; // [sp+24h] [bp+8h]@11

  v5 = (wchar_t *)lpType;
  v6 = (wchar_t *)lpName;
  v20 = wLanguage;
  v18 = lpType;
  v19 = lpName;
  lpType = 0;
  v7 = LdrFindResourceEx_U(16, hModule, &v18, 3, &lpType);
  if ( v7 < 0 )
  {
    BaseSetLastNTError(v7);
    return 0;
  }
  if ( !lpType )
    return 0;
  Address = (PVOID)AddStringOrID(v5, (struct _UPDATEDATA *)lParam);
  if ( !Address )
  {
    *(_DWORD *)(lParam + 20) = 8;
    return 0;
  }
  v9 = lParam;
  lpName = (LPCWSTR)AddStringOrID(v6, (struct _UPDATEDATA *)lParam);
  if ( !lpName )
  {
    *(_DWORD *)(v9 + 20) = 8;
LABEL_14:
    if ( *(_DWORD *)Address == 2 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( lpName )
    {
      if ( *(_DWORD *)lpName == 2 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)lpName);
    }
    return 0;
  }
  v10 = SizeofResource(hModule, (HRSRC)lpType);
  if ( !v10 )
    goto LABEL_14;
  v11 = KernelBaseGetGlobalData();
  v12 = RtlAllocateHeap(
          NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
          (*(_DWORD *)(v11 + 44) + 1835008) | 8,
          v10);
  v13 = v12;
  if ( !v12 )
    goto LABEL_14;
  memset(v12, 0, v10);
  v14 = LoadResource(hModule, (HRSRC)lpType);
  hModulea = (HMODULE)v14;
  if ( !v14 || (v15 = LockResource(v14)) == 0 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
    goto LABEL_14;
  }
  memcpy(v13, v15, v10);
  FreeResource(hModulea);
  v16 = v10;
  v17 = lParam;
  if ( AddResource(Address, (PVOID)lpName, wLanguage, (struct _UPDATEDATA *)lParam, 0, v13, v16) )
  {
    *(_DWORD *)(v17 + 20) = 8;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v13);
    return 0;
  }
  return 1;
}
// 77E283FC: using guessed type int __stdcall LdrFindResourceEx_U(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7D831) --------------------------------------------------------
size_t __stdcall PEWriteResFile(HFILE hFile, HFILE a2, LONG lOffset, struct _UPDATEDATA *a4)
{
  size_t result; // eax@2
  unsigned __int8 Buffer[4]; // [sp+4h] [bp-F8h]@1
  int v6; // [sp+1Ah] [bp-E2h]@3

  MuMoveFilePos(hFile, lOffset);
  MuRead(hFile, Buffer, 0xF8u);
  if ( *(_DWORD *)Buffer == 17744 )
  {
    if ( v6 & 2 || v6 & 0x2000 )
    {
      if ( HIWORD(v6) == 523 )
      {
        result = PEWriteResource<_IMAGE_NT_HEADERS64>(hFile, a2, lOffset, a4, (int)Buffer);
      }
      else if ( HIWORD(v6) == 267 )
      {
        result = PEWriteResource<_IMAGE_NT_HEADERS>(hFile, a2, lOffset, a4, (int)Buffer);
      }
      else
      {
        result = 193;
      }
    }
    else
    {
      result = 192;
    }
  }
  else
  {
    result = 191;
  }
  return result;
}

//----- (77E7D8E5) --------------------------------------------------------
DWORD __stdcall WriteResFile(HGLOBAL hMem, unsigned __int16 *a2)
{
  LPVOID v2; // eax@1
  LPVOID v3; // ebx@1
  const WCHAR *v5; // eax@4
  signed int v6; // esi@8
  HANDLE v7; // eax@16
  HFILE v8; // esi@16
  signed int v9; // [sp-4h] [bp-68h]@7
  int lOffset; // [sp+10h] [bp-54h]@14
  UINT v11; // [sp+18h] [bp-4Ch]@10
  HFILE hFile; // [sp+1Ch] [bp-48h]@6
  __int16 Buffer; // [sp+20h] [bp-44h]@10
  int v14; // [sp+5Ch] [bp-8h]@14

  v2 = GlobalLock(hMem);
  v3 = v2;
  if ( !v2 )
    return GetLastError();
  v5 = (const WCHAR *)GlobalLock(*((HGLOBAL *)v2 + 6));
  if ( !v5 )
  {
    GlobalUnlock(hMem);
    return GetLastError();
  }
  hFile = (HFILE)CreateFileW(v5, 0x80000000, 0, 0, 3u, 0x80u, 0);
  GlobalUnlock(*((HGLOBAL *)v3 + 6));
  if ( hFile == -1 )
  {
    v9 = 110;
  }
  else
  {
    v11 = _lread(hFile, &Buffer, 0x40u);
    if ( v11 == 64 )
    {
      if ( Buffer == 23117 )
      {
        lOffset = v14;
        if ( v14 )
        {
          v7 = CreateFileW(a2, 0xC0000000, 0, 0, 2u, 0x80u, 0);
          v8 = (HFILE)v7;
          if ( v7 != (HANDLE)-1 )
          {
            v11 = PEWriteResFile(hFile, (HFILE)v7, lOffset, (struct _UPDATEDATA *)v3);
            _lclose(v8);
          }
          _lclose(hFile);
          v6 = v11;
        }
        else
        {
          _lclose(hFile);
          v6 = 193;
        }
      }
      else
      {
        _lclose(hFile);
        v6 = 191;
      }
      goto LABEL_9;
    }
    _lclose(hFile);
    v9 = 30;
  }
  v6 = v9;
LABEL_9:
  GlobalUnlock(hMem);
  return v6;
}

//----- (77E7DA0E) --------------------------------------------------------
BOOL __stdcall EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
{
  void (__stdcall *v2)(_DWORD); // edi@1
  DWORD v3; // ebx@1
  int v5; // eax@3
  DWORD v6; // esi@4
  const WCHAR *v7; // eax@6
  HRESULT v8; // eax@9
  STRSAFE_LPWSTR v9; // eax@11
  wchar_t *v10; // eax@19
  DWORD v11; // eax@24
  int v12; // edi@29
  STRSAFE_LPWSTR ppszDestEnd; // [sp+8h] [bp-21Ch]@9
  LPCWSTR lpNewFileName; // [sp+Ch] [bp-218h]@1
  int v15; // [sp+10h] [bp-214h]@3
  HGLOBAL hMem; // [sp+14h] [bp-210h]@1
  wchar_t pszDest; // [sp+18h] [bp-20Ch]@9
  __int16 v18; // [sp+1Ah] [bp-20Ah]@16
  __int16 v19; // [sp+1Ch] [bp-208h]@16

  v2 = (void (__stdcall *)(_DWORD))RtlSetLastWin32Error;
  v3 = 0;
  hMem = hUpdate;
  lpNewFileName = 0;
  RtlSetLastWin32Error(0);
  if ( !hUpdate )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v5 = (int)GlobalLock(hMem);
  v15 = v5;
  if ( fDiscard )
  {
    v6 = 0;
    goto LABEL_30;
  }
  if ( !v5 )
    return 0;
  v7 = (const WCHAR *)GlobalLock(*(HGLOBAL *)(v5 + 24));
  lpNewFileName = v7;
  if ( !v7 )
  {
    RtlSetLastWin32Error(1359);
    return 0;
  }
  v8 = StringCchCopyExW(&pszDest, 0x104u, v7, &ppszDestEnd, 0, 0);
  if ( v8 >= 0 )
  {
    v9 = ppszDestEnd;
    do
      --v9;
    while ( *v9 != 92 && v9 >= &pszDest );
    v9[1] = 0;
    if ( GetTempFileNameW(&pszDest, L"RCX", 0, &pszDest) )
    {
      v11 = WriteResFile(hMem, &pszDest);
      v6 = v11;
      if ( v11 )
      {
        v3 = v11;
LABEL_27:
        v10 = &pszDest;
        goto LABEL_28;
      }
      v10 = &pszDest;
    }
    else
    {
      if ( !GetTempPathW(0x104u, &pszDest) )
      {
        pszDest = 46;
        v18 = 92;
        v19 = 0;
      }
      if ( !GetTempFileNameW(&pszDest, L"RCX", 0, &pszDest) )
      {
        v6 = GetLastError();
        goto LABEL_29;
      }
      v6 = WriteResFile(hMem, &pszDest);
      v10 = &pszDest;
      if ( v6 )
      {
        v3 = v6;
LABEL_28:
        DeleteFileW(v10);
        goto LABEL_29;
      }
    }
    if ( MoveFileExW(v10, lpNewFileName, 3u) )
      goto LABEL_29;
    v3 = GetLastError();
    v6 = v3;
    if ( !v3 )
    {
      v3 = 1359;
      v6 = 1359;
    }
    goto LABEL_27;
  }
  v3 = (unsigned __int16)v8;
  v6 = (unsigned __int16)v8;
LABEL_29:
  v12 = v15;
  GlobalUnlock(*(HGLOBAL *)(v15 + 24));
  GlobalFree(*(HGLOBAL *)(v12 + 24));
  v2 = (void (__stdcall *)(_DWORD))RtlSetLastWin32Error;
  v5 = v15;
LABEL_30:
  if ( v5 )
  {
    if ( !lpNewFileName )
    {
      if ( !GlobalLock(*(HGLOBAL *)(v5 + 24)) )
      {
LABEL_35:
        GlobalUnlock(hMem);
        goto LABEL_36;
      }
      GlobalFree(*(HGLOBAL *)(v15 + 24));
      v5 = v15;
    }
    FreeData((struct _UPDATEDATA *)v5);
    goto LABEL_35;
  }
LABEL_36:
  GlobalFree(hMem);
  v2(v3);
  return v6 == 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7DC49) --------------------------------------------------------
BOOL __stdcall EnumNamesFunc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam)
{
  EnumResourceLanguagesExW(hModule, lpType, lpName, EnumLangsFunc, lParam, 0x10u, 0);
  return 1;
}

//----- (77E7DC74) --------------------------------------------------------
BOOL __stdcall EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
{
  return EndUpdateResourceW(hUpdate, fDiscard);
}

//----- (77E7DC84) --------------------------------------------------------
BOOL __stdcall EnumTypesFunc(HMODULE hModule, LPWSTR lpType, LONG_PTR lParam)
{
  EnumResourceNamesExW(hModule, lpType, EnumNamesFunc, lParam, 0x10u, 0);
  return 1;
}

//----- (77E7DCAC) --------------------------------------------------------
HANDLE __stdcall BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
{
  HGLOBAL v2; // eax@3
  LONG_PTR v3; // esi@5
  HRESULT v4; // eax@7
  unsigned __int32 v5; // ST14_4@9
  HGLOBAL v6; // eax@11
  wchar_t *v7; // eax@13
  HRESULT v8; // edi@15
  DWORD v9; // eax@17
  HMODULE v10; // eax@22
  HMODULE v11; // edi@22
  size_t pcchLength; // [sp+Ch] [bp-14h]@7
  SIZE_T dwBytes; // [sp+10h] [bp-10h]@1
  size_t cchDest; // [sp+14h] [bp-Ch]@1
  HGLOBAL hMem; // [sp+18h] [bp-8h]@3
  DWORD v17; // [sp+1Ch] [bp-4h]@1

  v17 = 0;
  cchDest = 0;
  dwBytes = 0;
  if ( pFileName && *pFileName )
  {
    v2 = GlobalAlloc(0x42u, 0x1Cu);
    hMem = v2;
    if ( v2 )
    {
      v3 = (LONG_PTR)GlobalLock(v2);
      if ( v3 )
      {
        v4 = StringCchLengthW(pFileName, 0x7FFFFFFFu, &pcchLength);
        if ( v4 >= 0 )
        {
          v5 = pcchLength;
          *(_DWORD *)(v3 + 20) = 0;
          if ( ULongAdd(v5, 1u, (unsigned __int32 *)&cchDest) < 0 || ULongLongToULong(2i64 * cchDest, &dwBytes) < 0 )
          {
            v17 = 534;
          }
          else
          {
            v6 = GlobalAlloc(0x42u, dwBytes);
            *(_DWORD *)(v3 + 24) = v6;
            if ( v6 )
            {
              v7 = (wchar_t *)GlobalLock(v6);
              pcchLength = (size_t)v7;
              if ( v7 )
              {
                v8 = StringCchCopyW(v7, cchDest, pFileName);
                GlobalUnlock(*(HGLOBAL *)(v3 + 24));
                if ( v8 >= 0 )
                {
                  v9 = GetFileAttributesW((LPCWSTR)pcchLength);
                  if ( v9 == -1 )
                  {
                    v17 = GetLastError();
                    if ( !v17 )
                      v17 = 2;
                  }
                  else if ( v9 & 0x17 )
                  {
                    v17 = 19;
                  }
                  else
                  {
                    v10 = LoadLibraryExW(pFileName, 0, 3u);
                    v11 = v10;
                    if ( v10 )
                    {
                      if ( !bDeleteExistingResources )
                        EnumResourceTypesExW(v10, EnumTypesFunc, v3, 0x10u, 0);
                      FreeLibrary(v11);
                      if ( !*(_DWORD *)(v3 + 20) )
                      {
                        GlobalUnlock(hMem);
                        return hMem;
                      }
                    }
                    else
                    {
                      v17 = GetLastError();
                      if ( !v17 )
                        v17 = 193;
                    }
                  }
                }
                else
                {
                  v17 = (unsigned __int16)v8;
                }
              }
              else
              {
                v17 = 8;
              }
              GlobalFree(*(HGLOBAL *)(v3 + 24));
            }
            else
            {
              v17 = 8;
            }
          }
        }
        else
        {
          v17 = (unsigned __int16)v4;
        }
        GlobalUnlock(hMem);
      }
      else
      {
        v17 = 8;
      }
      GlobalFree(hMem);
    }
    else
    {
      v17 = 8;
    }
  }
  else
  {
    v17 = 87;
  }
  RtlSetLastWin32Error(v17);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7DE79) --------------------------------------------------------
HANDLE __stdcall BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
{
  HANDLE v3; // esi@5
  LSA_UNICODE_STRING UnicodeString; // [sp+0h] [bp-8h]@4

  if ( !pFileName )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, pFileName) )
    return 0;
  v3 = BeginUpdateResourceW(UnicodeString.Buffer, bDeleteExistingResources);
  RtlFreeUnicodeString(&UnicodeString);
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7DEC1) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  int v0; // eax@0
  int v1; // edx@0
  int v2; // ecx@0
  int v3; // ebx@0
  int v4; // edi@0
  int v5; // esi@0
  unsigned int v6; // et0@1
  int vars0; // [sp+8h] [bp+0h]@0
  int retaddr; // [sp+Ch] [bp+4h]@1
  char v9; // [sp+10h] [bp+8h]@0

  dword_77EA6900 = v0;
  dword_77EA68FC = v2;
  dword_77EA68F8 = v1;
  dword_77EA68F4 = v3;
  dword_77EA68F0 = v5;
  dword_77EA68EC = v4;
  word_77EA6918 = __SS__;
  word_77EA690C = __CS__;
  word_77EA68E8 = __DS__;
  word_77EA68E4 = __ES__;
  word_77EA68E0 = __FS__;
  word_77EA68DC = __GS__;
  v6 = __readeflags();
  dword_77EA6910 = v6;
  dword_77EA6904 = vars0;
  dword_77EA6908 = retaddr;
  dword_77EA6914 = (int)&v9;
  dword_77EA680C = retaddr;
  dword_77EA6850 = 65537;
  dword_77EA6800 = -1073740791;
  dword_77EA6804 = 1;
  RtlUnhandledExceptionFilter(off_77E7DF80);
  NtTerminateProcess((HANDLE)0xFFFFFFFF, -1073740791);
}
// 77E7DF80: using guessed type int *off_77E7DF80[2];
// 77E8A261: using guessed type int __stdcall RtlUnhandledExceptionFilter(_DWORD);
// 77EA6800: using guessed type int dword_77EA6800;
// 77EA6804: using guessed type int dword_77EA6804;
// 77EA680C: using guessed type int dword_77EA680C;
// 77EA6850: using guessed type int dword_77EA6850;
// 77EA68DC: using guessed type __int16 word_77EA68DC;
// 77EA68E0: using guessed type __int16 word_77EA68E0;
// 77EA68E4: using guessed type __int16 word_77EA68E4;
// 77EA68E8: using guessed type __int16 word_77EA68E8;
// 77EA68EC: using guessed type int dword_77EA68EC;
// 77EA68F0: using guessed type int dword_77EA68F0;
// 77EA68F4: using guessed type int dword_77EA68F4;
// 77EA68F8: using guessed type int dword_77EA68F8;
// 77EA68FC: using guessed type int dword_77EA68FC;
// 77EA6900: using guessed type int dword_77EA6900;
// 77EA6904: using guessed type int dword_77EA6904;
// 77EA6908: using guessed type int dword_77EA6908;
// 77EA690C: using guessed type __int16 word_77EA690C;
// 77EA6910: using guessed type int dword_77EA6910;
// 77EA6914: using guessed type int dword_77EA6914;
// 77EA6918: using guessed type __int16 word_77EA6918;

//----- (77E7DF8D) --------------------------------------------------------
int __cdecl __security_init_cookie_ex(int a1)
{
  int result; // eax@4

  while ( v7FFE0324 != v7FFE0328 )
    _mm_pause();
  result = a1 ^ (v7FFE0004 * (v7FFE0324 << 8) + (v7FFE0320 * (unsigned __int64)v7FFE0004 >> 24));
  *(_DWORD *)a1 = result;
  if ( !result || result == -1153374642 )
    *(_DWORD *)a1 = -1153374641;
  return result;
}

//----- (77E7DFE2) --------------------------------------------------------
signed int __thiscall IsCalendarLeapYear(void *this, int a2, int a3, int a4)
{
  if ( (unsigned int)a2 <= 7 )
  {
    if ( a2 == 7 )
      return IsGregBasedLeapYear(this, a2, a3, a4);
    if ( a2 )
    {
      if ( (unsigned int)a2 > 2 )
      {
        if ( (unsigned int)a2 > 5 )
        {
          if ( a2 == 6 )
            return IsHijriLeapYear(a3, a4);
          goto LABEL_15;
        }
        return IsGregBasedLeapYear(this, a2, a3, a4);
      }
      return IsGregorianLeapYear(a3, a4);
    }
    goto LABEL_15;
  }
  if ( a2 != 8 )
  {
    if ( (unsigned int)a2 > 8 )
    {
      if ( (unsigned int)a2 > 0xC )
      {
        if ( a2 == 23 )
          return IsUmAlQuraLeapYear(a3, a4);
        goto LABEL_15;
      }
      return IsGregorianLeapYear(a3, a4);
    }
LABEL_15:
    RtlSetLastWin32Error(87);
    return 0;
  }
  return IsHebrewLeapYear(a3, a4);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E06A) --------------------------------------------------------
int __stdcall IsCalendarLeapMonth(int a1, unsigned int a2, int a3, int a4)
{
  if ( (unsigned int)a1 <= 7 )
  {
    if ( a1 == 7 )
      return IsGregBasedLeapMonth(a1, a2, a3, a4);
    if ( a1 )
    {
      if ( (unsigned int)a1 > 2 )
      {
        if ( (unsigned int)a1 > 5 )
        {
          if ( a1 == 6 )
            return IsHijriLeapMonth(a2, a3, a4);
          goto LABEL_15;
        }
        return IsGregBasedLeapMonth(a1, a2, a3, a4);
      }
      return IsGregorianLeapMonth(a2, a3, a4);
    }
    goto LABEL_15;
  }
  if ( a1 != 8 )
  {
    if ( (unsigned int)a1 > 8 )
    {
      if ( (unsigned int)a1 > 0xC )
      {
        if ( a1 == 23 )
          return IsUmAlQuraLeapMonth(a2, a3, a4);
        goto LABEL_15;
      }
      return IsGregorianLeapMonth(a2, a3, a4);
    }
LABEL_15:
    RtlSetLastWin32Error(87);
    return 0;
  }
  return IsHebrewLeapMonth(a2, a3, a4);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E101) --------------------------------------------------------
signed int __thiscall IsCalendarLeapDay(void *this, int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  if ( (unsigned int)a2 <= 7 )
  {
    if ( a2 == 7 )
      return IsGregBasedLeapDay(this, a2, a3, a4, a5, a6);
    if ( a2 )
    {
      if ( (unsigned int)a2 > 2 )
      {
        if ( (unsigned int)a2 > 5 )
        {
          if ( a2 == 6 )
            return IsHijriLeapDay(a3, a4, a5, a6);
          goto LABEL_15;
        }
        return IsGregBasedLeapDay(this, a2, a3, a4, a5, a6);
      }
      return IsGregorianLeapDay(a3, a4, a5, a6);
    }
    goto LABEL_15;
  }
  if ( a2 != 8 )
  {
    if ( (unsigned int)a2 > 8 )
    {
      if ( (unsigned int)a2 > 0xC )
      {
        if ( a2 == 23 )
          return IsUmAlQuraLeapDay(a3, a4, a5, a6);
        goto LABEL_15;
      }
      return IsGregorianLeapDay(a3, a4, a5, a6);
    }
LABEL_15:
    RtlSetLastWin32Error(87);
    return 0;
  }
  return IsHebrewLeapDay(a3, a4, a5, a6);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E1A7) --------------------------------------------------------
BOOL __stdcall ConvertCalDateTimeToSystemTime(const void *a1, int a2)
{
  int v2; // edi@1
  unsigned int v4; // eax@4

  v2 = a2;
  if ( !a2 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !IsValidCalDateTime((int)a1, (int)&a2) )
    goto LABEL_18;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 <= 7u )
  {
    if ( *(_DWORD *)a1 == 7 )
      return ConvertGregBasedDateTimeToSysTime((int)a1, v2);
    if ( v4 )
    {
      if ( v4 > 2 )
      {
        if ( v4 > 5 )
        {
          if ( v4 == 6 )
            return ConvertHijriDateTimeToSystemTime((int)a1, v2);
          goto LABEL_18;
        }
        return ConvertGregBasedDateTimeToSysTime((int)a1, v2);
      }
      return ConvertGregorianDateTimeToSystemTime((int)a1, v2);
    }
    goto LABEL_18;
  }
  if ( v4 != 8 )
  {
    if ( v4 > 8 )
    {
      if ( v4 > 0xC )
      {
        if ( v4 == 23 )
          return ConvertUmAlQuraDateTimeToSystemTime(a1, v2);
        goto LABEL_18;
      }
      return ConvertGregorianDateTimeToSystemTime((int)a1, v2);
    }
LABEL_18:
    RtlSetLastWin32Error(87);
    return 0;
  }
  return ConvertHebrewDateTimeToSystemTime(a1, v2);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E241) --------------------------------------------------------
signed int __stdcall CompareCalendarDates(int a1, int a2, int a3)
{
  int v3; // ebx@1
  signed int result; // eax@2
  unsigned int v5; // ecx@9
  unsigned int v6; // edx@9
  unsigned int v7; // ecx@11
  unsigned int v8; // edx@11
  unsigned int v9; // ecx@13
  unsigned int v10; // edx@13
  unsigned int v11; // edi@16
  unsigned int v12; // esi@16

  v3 = a3;
  if ( !a3 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !IsValidCalDateTime(a1, (int)&a3) || !IsValidCalDateTime(a2, (int)&a3) )
    return 0;
  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v5 = *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)(a2 + 4);
  result = 1;
  if ( v5 > v6 )
    goto LABEL_17;
  if ( v5 < v6 )
  {
LABEL_15:
    *(_DWORD *)v3 = -1;
    return result;
  }
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a2 + 8);
  if ( v7 > v8 )
  {
LABEL_17:
    *(_DWORD *)v3 = 1;
    return result;
  }
  if ( v7 < v8 )
    goto LABEL_15;
  v9 = *(_DWORD *)(a1 + 12);
  v10 = *(_DWORD *)(a2 + 12);
  if ( v9 > v10 )
    goto LABEL_17;
  if ( v9 < v10 )
    goto LABEL_15;
  v11 = *(_DWORD *)(a1 + 16);
  v12 = *(_DWORD *)(a2 + 16);
  if ( v11 > v12 )
    goto LABEL_17;
  *(_DWORD *)v3 = -(v11 < v12);
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E2DA) --------------------------------------------------------
signed int __thiscall GetCalendarDaysInYear(void *this, int a2, int a3, int a4)
{
  if ( (unsigned int)a2 <= 7 )
  {
    if ( a2 == 7 )
      return GetGregBasedDaysInYear(this, a2, a3, a4);
    if ( a2 )
    {
      if ( (unsigned int)a2 > 2 )
      {
        if ( (unsigned int)a2 > 5 )
        {
          if ( a2 == 6 )
            return GetHijriDaysInYear(a3, a4);
          goto LABEL_15;
        }
        return GetGregBasedDaysInYear(this, a2, a3, a4);
      }
      return GetGregorianDaysInYear(a3, a4);
    }
    goto LABEL_15;
  }
  if ( a2 != 8 )
  {
    if ( (unsigned int)a2 > 8 )
    {
      if ( (unsigned int)a2 > 0xC )
      {
        if ( a2 == 23 )
          return GetUmAlQuraDaysInYear(a3, a4);
        goto LABEL_15;
      }
      return GetGregorianDaysInYear(a3, a4);
    }
LABEL_15:
    RtlSetLastWin32Error(87);
    return 0;
  }
  return GetHebrewDaysInYear(a3, a4);
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E362) --------------------------------------------------------
int __stdcall GetCalendarDayOfYear(int a1)
{
  int result; // eax@2
  unsigned int v2; // eax@3

  if ( !a1 )
    goto LABEL_2;
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 <= 7u )
  {
    if ( *(_DWORD *)a1 == 7 )
      return GetGregBasedDayOfYear(a1);
    if ( !v2 )
      goto LABEL_2;
    if ( v2 > 2 )
    {
      if ( v2 > 5 )
      {
        if ( v2 == 6 )
          return GetHijriDayOfYear(a1);
LABEL_2:
        RtlSetLastWin32Error(87);
        return 0;
      }
      return GetGregBasedDayOfYear(a1);
    }
    return GetGregorianDayOfYear(a1);
  }
  if ( v2 == 8 )
  {
    result = GetHebrewDayOfYear(a1);
  }
  else
  {
    if ( v2 <= 8 )
      goto LABEL_2;
    if ( v2 <= 0xC )
      return GetGregorianDayOfYear(a1);
    if ( v2 != 23 )
      goto LABEL_2;
    result = GetUmAlQuraDayOfYear(a1);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E3D6) --------------------------------------------------------
signed int __stdcall GetMinSupportedCalendarYear(int a1)
{
  signed int result; // eax@2

  switch ( a1 )
  {
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
      result = 1;
      break;
    case 3:
      result = 1868;
      break;
    case 8:
      result = 5343;
      break;
    case 23:
      result = 1318;
      break;
    default:
      RtlSetLastWin32Error(87);
      result = 0;
      break;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E44A) --------------------------------------------------------
unsigned int __stdcall GetFirstDayWeekOfYear(int a1, int a2)
{
  int v2; // esi@1
  unsigned int result; // eax@2

  v2 = GetCalendarDayOfYear(a1) - 1;
  if ( UpdateCalendarDayOfWeek(a1) )
    result = (v2 + (*(_DWORD *)(a1 + 20) - v2 % 7u - a2 + 14) % 7) / 7 + 1;
  else
    result = 0;
  return result;
}

//----- (77E7E497) --------------------------------------------------------
signed int __stdcall GetWeekOfYearFullDays(int a1, int a2, int a3, signed int a4)
{
  signed int v4; // esi@1
  unsigned int v5; // edx@1
  signed int result; // eax@5
  char v7; // [sp+Ch] [bp-28h]@6

  v4 = GetCalendarDayOfYear(a1) - 1;
  UpdateCalendarDayOfWeek(a1);
  v5 = (v4 % 7 - *(_DWORD *)(a1 + 20) + a3 + 14) % 7u;
  if ( v5 && (signed int)v5 >= a4 )
    v5 -= 7;
  if ( ((v4 - v5) & 0x80000000) != 0 )
  {
    CopyCalDateTime(&v7, (const void *)a1);
    result = AdjustCalendarDate((int)&v7, 4, -1 - v4);
    if ( result )
      result = GetWeekOfYearFullDays(&v7, a2, a3, a4);
  }
  else
  {
    result = (signed int)(v4 - v5) / 7 + 1;
  }
  return result;
}

//----- (77E7E51F) --------------------------------------------------------
signed int __stdcall GetCalendarWeekNumber(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@3
  unsigned int v6; // eax@6
  unsigned int v8; // eax@8

  v4 = a2;
  if ( a2 > 6 || (unsigned int)a3 > 2 || (v5 = a4) == 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( !IsValidCalDateTime(a1, (int)&a2) )
    return 0;
  if ( a3 )
  {
    v8 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 && (v8 <= 5 || v8 == 7 || v8 - 9 <= 3) )
    {
      if ( a3 == 1 )
        v6 = GetGregorianWeekOfYearFullDays(a1, v4, 7, 365);
      else
        v6 = GetGregorianWeekOfYearFullDays(a1, v4, 4, 365);
    }
    else if ( a3 == 1 )
    {
      v6 = GetWeekOfYearFullDays(a1, 1, v4, 7);
    }
    else
    {
      v6 = GetWeekOfYearFullDays(a1, a3, v4, 4);
    }
  }
  else
  {
    v6 = GetFirstDayWeekOfYear(a1, v4);
  }
  *(_DWORD *)v5 = v6;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E5C0) --------------------------------------------------------
BOOL __stdcall EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
{
  int v4; // eax@1
  BOOL result; // eax@3

  v4 = NlsValidateLocale(&Locale, 0);
  if ( CalType & 0x10000000 || (CalType & 0xFFFFFFF) >= 0x38 )
  {
    RtlSetLastWin32Error(1004);
    result = 0;
  }
  else
  {
    result = Internal_EnumCalendarInfo(lpCalInfoEnumProcEx, v4, Calendar, CalType, 0, 1, 0, 0);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E47B80: using guessed type int __stdcall Internal_EnumCalendarInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E616) --------------------------------------------------------
BOOL __stdcall EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
{
  int v3; // eax@1
  BOOL result; // eax@2

  v3 = NlsValidateLocale(&Locale, 0);
  if ( dwFlags & 2 )
  {
    RtlSetLastWin32Error(1004);
    result = 0;
  }
  else
  {
    result = Internal_EnumTimeFormats(lpTimeFmtEnumProc, v3, dwFlags, 0, 0, 0);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E8B861: using guessed type int __stdcall Internal_EnumTimeFormats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E656) --------------------------------------------------------
BOOL __stdcall EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
{
  int v3; // eax@1

  v3 = NlsValidateLocale(&Locale, 0);
  return Internal_EnumDateFormats(lpDateFmtEnumProc, v3, dwFlags, 0, 0, 0, 0);
}
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E8B86C: using guessed type int __stdcall Internal_EnumDateFormats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E682) --------------------------------------------------------
BOOL __stdcall EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
{
  int v3; // eax@1

  v3 = NlsValidateLocale(&Locale, 0);
  return Internal_EnumDateFormats(lpDateFmtEnumProcEx, v3, dwFlags, 0, 1, 0, 0);
}
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E8B86C: using guessed type int __stdcall Internal_EnumDateFormats(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E6AF) --------------------------------------------------------
BOOL __stdcall EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
{
  return Internal_EnumSystemLanguageGroups(lpLanguageGroupEnumProc, dwFlags, lParam, 0);
}
// 77E8B877: using guessed type int __stdcall Internal_EnumSystemLanguageGroups(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E6CD) --------------------------------------------------------
BOOL __stdcall EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
{
  return Internal_EnumLanguageGroupLocales(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam, 0);
}
// 77E8B882: using guessed type int __stdcall Internal_EnumLanguageGroupLocales(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E6EE) --------------------------------------------------------
BOOL __stdcall EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
{
  return Internal_EnumUILanguages(lpUILanguageEnumProc, dwFlags, lParam, 0);
}
// 77E8B88D: using guessed type int __stdcall Internal_EnumUILanguages(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7E70C) --------------------------------------------------------
BOOL __stdcall EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
{
  return Internal_EnumSystemCodePages(lpCodePageEnumProc, dwFlags, 0);
}
// 77E8B898: using guessed type int __stdcall Internal_EnumSystemCodePages(_DWORD, _DWORD, _DWORD);

//----- (77E7E727) --------------------------------------------------------
int __stdcall GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
{
  int result; // eax@3
  WCHAR GeoData; // [sp+8h] [bp-A4h]@1
  char Dst; // [sp+Ah] [bp-A2h]@1

  GeoData = 0;
  memset(&Dst, 0, 0x9Eu);
  if ( lpGeoData || cchData <= 0 )
  {
    result = GetGeoInfoW(Location, GeoType, &GeoData, 80, LangId);
    if ( result )
      result = WideCharToMultiByte(0, 0, &GeoData, result, lpGeoData, cchData, 0, 0);
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E7BB) --------------------------------------------------------
BOOL __stdcall SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
{
  int v3; // eax@1
  int v5; // eax@4
  LPCWSTR v6; // esi@8
  BOOL v7; // edi@8
  char v8; // [sp+4h] [bp-10Ch]@4
  LPCWSTR v9; // [sp+8h] [bp-108h]@4
  char v10; // [sp+Ch] [bp-104h]@4

  v3 = NlsGetACPFromLocale(Locale, LCType);
  if ( !v3 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v9 = (LPCWSTR)&v10;
  NlsAnsiToUnicode(v3, 0, (int)lpLCData, -1, (int)&v9, (int)&v8);
  if ( !v5 )
    return 0;
  if ( (LCType & 0xFFFFFFF) >= 0x70 && (LCType & 0xFFFFFFF) < 0x1000 )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  v6 = v9;
  v7 = SetLocaleInfoW(Locale, LCType, v9);
  if ( (char *)v6 != &v10 )
  {
    if ( v6 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v6);
  }
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E882) --------------------------------------------------------
BOOL __stdcall SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
{
  int v4; // eax@1
  int v6; // eax@4
  LPCWSTR v7; // esi@5
  BOOL v8; // edi@5
  char v9; // [sp+4h] [bp-10Ch]@4
  LPCWSTR v10; // [sp+8h] [bp-108h]@4
  char v11; // [sp+Ch] [bp-104h]@4

  v4 = NlsGetACPFromLocale(Locale, CalType);
  if ( !v4 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v10 = (LPCWSTR)&v11;
  NlsAnsiToUnicode(v4, 0, (int)lpCalData, -1, (int)&v10, (int)&v9);
  if ( !v6 )
    return 0;
  v7 = v10;
  v8 = SetCalendarInfoW(Locale, Calendar, CalType, v10);
  if ( (char *)v7 != &v11 )
  {
    if ( v7 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v7);
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7E931) --------------------------------------------------------
int __stdcall GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
{
  int v6; // eax@1
  int v7; // eax@6
  const CURRENCYFMTA *v8; // esi@8
  int v9; // ST08_4@8
  int v10; // eax@8
  int v11; // eax@9
  int v12; // eax@10
  int v13; // esi@15
  char v15; // [sp+10h] [bp-240h]@8
  PVOID Address; // [sp+1Ch] [bp-234h]@8
  PVOID v17; // [sp+20h] [bp-230h]@8
  PVOID v18; // [sp+2Ch] [bp-224h]@8
  const CURRENCYFMTA *v19; // [sp+30h] [bp-220h]@1
  char v20; // [sp+34h] [bp-21Ch]@6
  int v21; // [sp+38h] [bp-218h]@1
  CURRENCYFMTW *v22; // [sp+3Ch] [bp-214h]@1
  int cchWideChar; // [sp+40h] [bp-210h]@12
  LPWSTR v24; // [sp+44h] [bp-20Ch]@12
  LPCWSTR v25; // [sp+48h] [bp-208h]@6
  char v26; // [sp+4Ch] [bp-204h]@6
  WCHAR CurrencyStr; // [sp+14Ch] [bp-104h]@12

  v19 = lpFormat;
  v22 = 0;
  v6 = NlsGetACPFromLocale(Locale, dwFlags);
  v21 = v6;
  if ( !v6 || cchCurrency < 0 || !lpCurrencyStr && cchCurrency || lpValue == lpCurrencyStr )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v25 = (LPCWSTR)&v26;
  NlsAnsiToUnicode(v6, 0, (int)lpValue, -1, (int)&v25, (int)&v20);
  if ( !v7 )
    return 0;
  if ( v19 )
  {
    qmemcpy(&v15, v19, 0x20u);
    v8 = v19;
    v9 = (int)v19->lpDecimalSep;
    Address = 0;
    v17 = 0;
    v18 = 0;
    NlsAnsiToUnicode(v21, 0, v9, -1, (int)&Address, (int)&v20);
    if ( v10 )
    {
      NlsAnsiToUnicode(v21, 0, (int)v8->lpThousandSep, -1, (int)&v17, (int)&v20);
      if ( v11 )
      {
        NlsAnsiToUnicode(v21, 0, (int)v8->lpCurrencySymbol, -1, (int)&v18, (int)&v20);
        if ( v12 )
        {
          v22 = (CURRENCYFMTW *)&v15;
          goto LABEL_12;
        }
      }
    }
    if ( (char *)v25 != &v26 && v25 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v25);
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( v17 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v17);
    return 0;
  }
LABEL_12:
  v24 = &CurrencyStr;
  cchWideChar = GetCurrencyFormatW(Locale, dwFlags, v25, v22, &CurrencyStr, 128);
  if ( !cchWideChar )
  {
    while ( GetLastError() == 122 && v24 == &CurrencyStr )
    {
      RtlSetLastWin32Error(0);
      v13 = GetCurrencyFormatW(Locale, dwFlags, v25, v22, 0, 0);
      if ( v13 )
      {
        v24 = (LPWSTR)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v13);
        if ( !v24 )
        {
          RtlSetLastWin32Error(14);
          cchWideChar = 0;
          break;
        }
      }
      cchWideChar = GetCurrencyFormatW(Locale, dwFlags, v25, v22, v24, v13);
      if ( cchWideChar )
        break;
    }
  }
  if ( (char *)v25 != &v26 && v25 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v25);
  if ( v19 )
  {
    if ( Address )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    if ( v17 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v17);
    if ( v18 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v18);
  }
  if ( cchWideChar > 0 )
    cchWideChar = NlsUnicodeToAnsi(v21, v24, cchWideChar, lpCurrencyStr, cchCurrency);
  if ( v24 != &CurrencyStr )
  {
    if ( v24 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v24);
  }
  return cchWideChar;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7ECE0) --------------------------------------------------------
int __stdcall FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
{
  int v5; // eax@5
  int v6; // eax@5
  PVOID v7; // edi@6
  int v8; // esi@9
  int i; // eax@6
  int v10; // eax@22
  int v12; // [sp+10h] [bp-20Ch]@5
  LPCWSTR v13; // [sp+14h] [bp-208h]@5
  char Dst; // [sp+18h] [bp-204h]@5
  char Address; // [sp+118h] [bp-104h]@6

  if ( cchDest < 0 || cchDest && !lpDestStr || lpSrcStr == lpDestStr )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  memset(&Dst, 0, 0x100u);
  v13 = (LPCWSTR)&Dst;
  v5 = KernelBaseGetGlobalData();
  NlsAnsiToUnicode(*(_DWORD *)(v5 + 148), 0, (int)lpSrcStr, cchSrc, (int)&v13, (int)&v12);
  if ( !v6 )
    return 0;
  v7 = &Address;
  for ( i = FoldStringW(dwMapFlags, v13, v12, (LPWSTR)&Address, 128);
        ;
        i = FoldStringW(dwMapFlags, v13, v12, (LPWSTR)v7, v8) )
  {
    v8 = i;
    if ( i || GetLastError() != 122 || v7 != &Address )
      break;
    RtlSetLastWin32Error(0);
    v8 = FoldStringW(dwMapFlags, v13, v12, 0, 0);
    if ( v8 )
    {
      v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v8);
      if ( !v7 )
      {
        if ( (char *)v13 != &Dst && v13 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v13);
        RtlSetLastWin32Error(14);
        return 0;
      }
    }
    else if ( GetLastError() )
    {
      break;
    }
  }
  if ( (char *)v13 != &Dst && v13 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v13);
  if ( v8 > 0 )
  {
    v10 = KernelBaseGetGlobalData();
    v8 = NlsUnicodeToAnsi(*(_DWORD *)(v10 + 148), (LPCWSTR)v7, v8, lpDestStr, cchDest);
  }
  if ( v7 != &Address )
  {
    if ( v7 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7EED4) --------------------------------------------------------
BOOL __stdcall GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
{
  BOOL result; // eax@2
  BOOL v4; // edi@3
  int v5; // eax@4
  struct _cpinfoexW CPInfoEx; // [sp+4h] [bp-224h]@3

  if ( lpCPInfoEx )
  {
    v4 = GetCPInfoExW(CodePage, dwFlags, &CPInfoEx);
    if ( v4 != 1
      || (v5 = KernelBaseGetGlobalData(),
          (result = NlsUnicodeToAnsi(*(_DWORD *)(v5 + 148), CPInfoEx.CodePageName, -1, lpCPInfoEx->CodePageName, 260)) != 0) )
    {
      memmove(lpCPInfoEx, &CPInfoEx, 0x18u);
      result = v4;
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7EF67) --------------------------------------------------------
int __stdcall GetGeoLCID(int a1, __int16 a2)
{
  int v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edx@2
  int v7; // edx@7
  int v8; // ecx@8

  v2 = *(_DWORD *)(KernelBaseGetGlobalData() + 120);
  v3 = *(_DWORD *)(KernelBaseGetGlobalData() + 124);
  v4 = 0;
  if ( v2 > 0 )
  {
    v5 = v3 + 4;
    while ( a1 != *(_DWORD *)v5 )
    {
      ++v4;
      v5 += 12;
      if ( v4 >= v2 )
        return 0;
    }
    v7 = v4;
    if ( v4 < v2 )
    {
      v8 = 12 * v4 + v3 + 8;
      while ( *(_DWORD *)(v8 - 4) == a1 )
      {
        if ( *(_WORD *)v8 == a2 )
          return *(_DWORD *)(12 * v7 + v3);
        ++v7;
        v8 += 12;
        if ( v7 >= v2 )
          return 0;
      }
    }
  }
  return 0;
}

//----- (77E7EFD2) --------------------------------------------------------
BOOL __stdcall EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // esi@6

  v3 = *(_DWORD *)(KernelBaseGetGlobalData() + 128);
  v4 = *(_DWORD *)(KernelBaseGetGlobalData() + 132);
  v5 = 0;
  if ( !lpGeoEnumProc || ParentGeoId )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( GeoClass != 16 )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  if ( v3 > 0 )
  {
    v6 = v4;
    do
    {
      if ( *(_DWORD *)(v6 + 52) == 16 && !lpGeoEnumProc(*(_DWORD *)v6) )
        break;
      ++v5;
      v6 += 80;
    }
    while ( v5 < v3 );
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7F041) --------------------------------------------------------
BOOL __stdcall SetUserGeoID(GEOID GeoId)
{
  int v1; // esi@1
  int v2; // edi@1
  int v4; // ecx@4
  int v5; // eax@4
  GEOID v6; // edx@5
  int v7; // edx@7
  int v8; // eax@11
  int v9; // eax@19
  char v10; // [sp+Ch] [bp-250h]@24
  char v11; // [sp+1Ch] [bp-240h]@24
  GEOID *v12; // [sp+2Ch] [bp-230h]@24
  int v13; // [sp+30h] [bp-22Ch]@24
  int v14; // [sp+34h] [bp-228h]@24
  int v15; // [sp+38h] [bp-224h]@24
  char v16; // [sp+3Ch] [bp-220h]@24
  PCWSTR SourceString; // [sp+40h] [bp-21Ch]@14
  int v18; // [sp+44h] [bp-218h]@1
  int v19; // [sp+48h] [bp-214h]@4
  HANDLE Handle; // [sp+4Ch] [bp-210h]@1
  __int16 Data; // [sp+50h] [bp-20Ch]@1
  char Dst; // [sp+52h] [bp-20Ah]@1

  Data = 0;
  Handle = 0;
  v18 = 0;
  memset(&Dst, 0, 0x206u);
  v1 = *(_DWORD *)(KernelBaseGetGlobalData() + 128);
  v2 = *(_DWORD *)(KernelBaseGetGlobalData() + 132);
  if ( CheckGroupPolicyEnabled(L"PreventGeoIdChange", 1) )
  {
    NlsWriteEtwEvent(0, 0, NLS_ETW_EVENT_POLICY_NO_GEO_ID_CHANGE, 0, 0);
    RtlSetLastWin32Error(1260);
    return 0;
  }
  v4 = v1 - 1;
  v5 = (v1 - 1) >> 1;
  v19 = 0;
  if ( v1 - 1 < 0 )
    goto LABEL_29;
  while ( 1 )
  {
    v6 = *(_DWORD *)(80 * v5 + v2);
    if ( GeoId == v6 )
      break;
    if ( GeoId >= v6 )
    {
      v7 = v5 + 1;
      v19 = v5 + 1;
    }
    else
    {
      v7 = v19;
      v4 = v5 - 1;
    }
    v5 = (v4 + v7) >> 1;
    if ( v7 > v4 )
      goto LABEL_16;
  }
  v8 = *(_DWORD *)(80 * v5 + v2 + 52) - 14;
  if ( v8 )
  {
    if ( v8 != 2 )
    {
LABEL_13:
      RtlSetLastWin32Error(1359);
      return 0;
    }
    SourceString = L"Nation";
  }
  else
  {
    SourceString = L"Region";
  }
LABEL_16:
  if ( v19 > v4 )
  {
LABEL_29:
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( OpenRegKey(&Handle, 0, L"Control Panel\\International\\Geo", 131103, 3) < 0 )
    goto LABEL_13;
  NlsConvertIntegerToString(GeoId, 0xAu, 0, (STRSAFE_LPWSTR)&Data, 0x104u);
  v9 = SortNlsStrLenW(&Data);
  if ( !SetRegValue(Handle, SourceString, &Data, 2 * v9 + 2) )
    v18 = 1;
  if ( Handle )
  {
    NtClose(Handle);
    Handle = 0;
  }
  if ( v18 )
  {
    NlsEventDataDescCreate(&v10, 1, &v16, 4);
    NlsEventDataDescCreate(&v11, 0, &Data, 520);
    v12 = &GeoId;
    v13 = 0;
    v14 = 4;
    v15 = 0;
    NlsWriteEtwEvent(0, 0, NLS_ETW_EVENT_SET_USER_GEO_ID, 3, &v10);
  }
  else
  {
    RtlSetLastWin32Error(1359);
  }
  return v18;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E475E0: using guessed type wchar_t aControlPanelIn[32];
// 77E476ED: using guessed type int __stdcall OpenRegKey(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E61C68: using guessed type wchar_t aRegion[7];
// 77E7F258: using guessed type int NLS_ETW_EVENT_POLICY_NO_GEO_ID_CHANGE[3];
// 77E7F268: using guessed type int NLS_ETW_EVENT_SET_USER_GEO_ID[3];
// 77E7F278: using guessed type wchar_t aPreventgeoidch[19];
// 77E8B8A3: using guessed type int __stdcall CheckGroupPolicyEnabled(_DWORD, _DWORD);
// 77E9564C: using guessed type int __stdcall NlsEventDataDescCreate(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E95657: using guessed type int __stdcall NlsWriteEtwEvent(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7F2A3) --------------------------------------------------------
int __stdcall GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // ecx@1
  int v10; // eax@6
  int v11; // esi@6
  GEOID v12; // edx@7
  int v13; // esi@14
  unsigned __int16 v14; // ax@25
  __int16 v15; // di@32
  int v16; // eax@34
  int v17; // esi@41
  int v18; // esi@44
  int result; // eax@45
  ULONG v20; // [sp-14h] [bp-CCh]@15
  ULONG v21; // [sp-10h] [bp-C8h]@15
  int v22; // [sp-Ch] [bp-C4h]@15
  WCHAR *v23; // [sp-8h] [bp-C0h]@15
  int v24; // [sp+10h] [bp-A8h]@1
  WCHAR LCData; // [sp+14h] [bp-A4h]@1
  char Dst; // [sp+16h] [bp-A2h]@1

  v5 = 0;
  LCData = 0;
  memset(&Dst, 0, 0x9Eu);
  v6 = *(_DWORD *)(KernelBaseGetGlobalData() + 128);
  v7 = *(_DWORD *)(KernelBaseGetGlobalData() + 132);
  v24 = LangId;
  v8 = NlsValidateLocale(&v24, 0);
  v9 = 0;
  if ( cchData < 0 || !lpGeoData && cchData > 0 || !v8 )
    goto LABEL_54;
  if ( Location == -1 )
    return 0;
  v10 = v6 - 1;
  v11 = (v6 - 1) >> 1;
  if ( v10 < 0 )
    goto LABEL_54;
  do
  {
    v12 = *(_DWORD *)(80 * v11 + v7);
    if ( Location == v12 )
      break;
    if ( Location >= v12 )
      v9 = v11 + 1;
    else
      v10 = v11 - 1;
    v11 = (v9 + v10) >> 1;
  }
  while ( v9 <= v10 );
  if ( v9 > v10 )
  {
LABEL_54:
    RtlSetLastWin32Error(87);
    return 0;
  }
  switch ( GeoType )
  {
    case 1u:
      v13 = v7 + 80 * v11;
      if ( *(_DWORD *)(v13 + 52) != 16 )
        return 0;
      v23 = &LCData;
      v22 = 0;
      v21 = 10;
      v20 = *(_DWORD *)v13;
      goto LABEL_16;
    case 2u:
      v5 = 80 * v11 + v7 + 4;
      goto LABEL_49;
    case 3u:
      v5 = 80 * v11 + v7 + 28;
      goto LABEL_49;
    case 4u:
      v5 = 80 * v11 + v7 + 60;
      goto LABEL_49;
    case 5u:
      v5 = 80 * v11 + v7 + 68;
      goto LABEL_49;
    case 6u:
      if ( !LangId )
        *(_DWORD *)&LangId = GetUserDefaultLangID();
      v24 = LangId;
      if ( !GetLocaleInfoW(LangId, 0x59u, &LCData, 80) )
      {
        v14 = LangId & 0x3FF | 0x400;
        if ( v14 != LangId )
        {
          v24 = v14;
          GetLocaleInfoW(v14, 0x59u, &LCData, 80);
        }
      }
      if ( !LCData )
        return 0;
      if ( StringCchCatW(&LCData, 0x50u, L"-") < 0
        || StringCchCatW(&LCData, 0x50u, (STRSAFE_LPCWSTR)(80 * v11 + v7 + 60)) < 0 )
        goto LABEL_31;
      _wcslwr(&LCData);
      goto LABEL_17;
    case 7u:
      v15 = LangId;
      if ( !LangId )
        v15 = GetUserDefaultLangID();
      v16 = GetGeoLCID(Location, v15);
      v24 = v16;
      if ( !v16 )
      {
        if ( (v15 & 0x3FF | 0x400) == v15 || (v16 = GetGeoLCID(Location, v15 & 0x3FF | 0x400), (v24 = v16) == 0) )
        {
          v16 = (unsigned __int16)v15;
          if ( !(v15 & 0xFC00) )
            v16 = (unsigned __int16)v15 | 0x400;
          v24 = v16;
          if ( !v16 )
            return 0;
        }
      }
      v23 = &LCData;
      v22 = 8;
      v21 = 16;
      v20 = v16;
LABEL_16:
      NlsConvertIntegerToString(v20, v21, v22, v23, 0x50u);
LABEL_17:
      v5 = (int)&LCData;
      goto LABEL_43;
    case 8u:
      goto LABEL_41;
    case 9u:
      v17 = GetStringTableEntry(Location, &LCData, 80, 6);
      if ( v17 )
        goto LABEL_42;
LABEL_41:
      v17 = GetStringTableEntry(Location, &LCData, 80, 5);
      if ( !v17 )
        goto LABEL_54;
LABEL_42:
      v5 = (int)&LCData;
      if ( !v17 )
        goto LABEL_43;
      goto LABEL_44;
    case 0xAu:
    case 0xBu:
      return 0;
    default:
      RtlSetLastWin32Error(1004);
LABEL_49:
      if ( !v5 )
        return 0;
LABEL_43:
      v17 = SortNlsStrLenW((void *)v5);
LABEL_44:
      v18 = v17 + 1;
      if ( !cchData )
        goto LABEL_45;
      if ( cchData < v18 )
      {
LABEL_31:
        RtlSetLastWin32Error(122);
        return 0;
      }
      if ( StringCchCopyNW(lpGeoData, cchData, (const unsigned __int16 *)v5, v18 - 1) < 0 )
        return 0;
LABEL_45:
      result = v18;
      break;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2AC17: using guessed type int __stdcall NlsValidateLocale(_DWORD, _DWORD);
// 77E8B8AE: using guessed type int __stdcall GetStringTableEntry(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E7F5ED) --------------------------------------------------------
__int16 __stdcall GetLocaleWordFromArrayInPoolUseDefault(int a1, int a2, signed int a3, __int16 a4)
{
  __int16 result; // ax@2

  if ( a3 < *(_WORD *)(a1 + 2 * a2) )
    result = *(_WORD *)(a1 + 2 * (a3 + a2) + 2);
  else
    result = a4;
  return result;
}

//----- (77E7F61B) --------------------------------------------------------
signed int __stdcall IsValidCalendar(unsigned int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( (a1 < 1 || a1 > 0xC) && a1 != 23 )
    result = 0;
  return result;
}

//----- (77E7F63F) --------------------------------------------------------
unsigned __int16 __stdcall GetCalendarYear(int a1, int a2, unsigned int a3, int a4, int a5, unsigned __int16 a6, unsigned __int16 a7, unsigned __int16 a8)
{
  int v8; // eax@5
  unsigned __int16 v9; // si@5
  int v10; // eax@7
  unsigned __int16 v11; // di@7
  unsigned __int16 v12; // bx@9
  int v13; // eax@9
  unsigned __int16 v14; // cx@9
  unsigned __int16 v15; // cx@11
  int v17; // [sp+8h] [bp-4h]@1
  int v18; // [sp+20h] [bp+14h]@7

  v17 = 0;
  *(_DWORD *)a1 = 0;
  if ( a3 < 3 )
    return a6;
  if ( a3 > 4 )
  {
    if ( a3 == 5 || a3 == 7 )
    {
      v8 = a5 + 2 * *(_DWORD *)(a5 + 2 * *(_DWORD *)(a4 + 20) + 2);
      v9 = a6 - *(_WORD *)(v8 + 10);
      *(_DWORD *)a1 = v8;
      if ( a2 )
        *(_WORD *)a2 = 1;
      return v9;
    }
    return a6;
  }
  v10 = GetPtrCalDataArray(a3, a5, *(_DWORD *)(a4 + 20));
  v11 = *(_WORD *)v10;
  v18 = v10 + 2;
  if ( *(_WORD *)v10 <= 0u )
    return a6;
  v9 = a6;
  do
  {
    v12 = v17 + 1;
    v13 = GetPtrCalData(a3, a5, v18, v17 + 1);
    v14 = *(_WORD *)(v13 + 4);
    if ( a6 > v14 )
      break;
    if ( a6 == v14 )
    {
      v15 = *(_WORD *)(v13 + 6);
      if ( a7 > v15 || a7 == v15 && a8 >= *(_WORD *)(v13 + 8) )
        break;
    }
    v17 = v12;
  }
  while ( v12 < v11 );
  if ( (unsigned __int16)v17 < v11 )
  {
    v9 = a6 - *(_WORD *)(v13 + 10);
    *(_DWORD *)a1 = v13;
    if ( a2 )
      *(_WORD *)a2 = v11 - v17;
  }
  return v9;
}
// 77E8B8B9: using guessed type int __stdcall GetPtrCalData(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E8B8C4: using guessed type int __stdcall GetPtrCalDataArray(_DWORD, _DWORD, _DWORD);

//----- (77E7F734) --------------------------------------------------------
signed int __stdcall GetUmAlQuraDate(int a1)
{
  signed int result; // eax@3
  char v2; // [sp+4h] [bp-28h]@1
  __int16 v3; // [sp+Ch] [bp-20h]@3
  __int16 v4; // [sp+10h] [bp-1Ch]@3
  __int16 v5; // [sp+14h] [bp-18h]@3

  if ( ConvertSystemTimeToGregorianDateTime(a1, 1, &v2) && GregorianToUmAlQura((int)&v2) )
  {
    *(_WORD *)a1 = v3;
    *(_WORD *)(a1 + 2) = v4;
    *(_WORD *)(a1 + 6) = v5;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7F785) --------------------------------------------------------
signed int __stdcall GetHijriDate(int a1, int a2)
{
  signed int result; // eax@2
  char v3; // [sp+4h] [bp-28h]@1
  __int16 v4; // [sp+Ch] [bp-20h]@2
  __int16 v5; // [sp+10h] [bp-1Ch]@2
  __int16 v6; // [sp+14h] [bp-18h]@2

  if ( ConvertSystemTimeToHijriDateTimeEx(a1, (int)&v3, a2) )
  {
    *(_WORD *)a1 = v4;
    *(_WORD *)(a1 + 2) = v5;
    *(_WORD *)(a1 + 6) = v6;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7F7CA) --------------------------------------------------------
signed int __stdcall GetHebrewDate(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ST04_4@2
  __int16 v4; // cx@2
  signed int result; // eax@2
  char v6; // [sp+4h] [bp-28h]@1
  int v7; // [sp+8h] [bp-24h]@2
  int v8; // [sp+Ch] [bp-20h]@2
  __int16 v9; // [sp+10h] [bp-1Ch]@2
  __int16 v10; // [sp+14h] [bp-18h]@2

  if ( ConvertSystemTimeToHebrewDateTime(a1, &v6) )
  {
    v2 = v8;
    v3 = v7;
    *(_WORD *)(a1 + 2) = v9;
    v4 = v10;
    *(_WORD *)a1 = v2;
    *(_WORD *)(a1 + 6) = v4;
    *(_DWORD *)a2 = IsHebrewLeapYear(v2, v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7F819) --------------------------------------------------------
signed int __stdcall NumberToHebrewLetter(unsigned int a1, int a2, signed int a3)
{
  signed int result; // eax@2
  unsigned int v4; // esi@3
  unsigned int v5; // eax@5
  signed __int16 v6; // cx@7
  __int16 v7; // ax@11
  unsigned int v8; // eax@18
  signed __int16 v9; // dx@20
  signed __int16 v10; // cx@31
  wchar_t *v11; // eax@38
  int v12; // eax@44
  int v13; // eax@46
  int v14; // ecx@48
  wchar_t v15; // [sp+8h] [bp-20h]@30
  wchar_t pszDest; // [sp+Ah] [bp-1Eh]@38
  int Dst; // [sp+Ch] [bp-1Ch]@37
  int v18; // [sp+10h] [bp-18h]@37
  int v19; // [sp+14h] [bp-14h]@37
  int v20; // [sp+18h] [bp-10h]@37
  int pszSrc; // [sp+1Ch] [bp-Ch]@5
  int v22; // [sp+20h] [bp-8h]@5

  if ( a3 > 10 )
    return 0;
  v4 = a1;
  if ( a1 > 0x1388 )
    v4 = a1 - 5000;
  pszSrc = 0;
  v22 = 0;
  v5 = v4 / 0x64;
  if ( v4 / 0x64 )
  {
    v4 %= 0x64u;
    if ( v5 <= 3 )
    {
      v6 = v22;
    }
    else
    {
      v5 -= 4;
      v6 = 1514;
      LOWORD(v22) = 1514;
      if ( v5 > 3 )
      {
        HIWORD(pszSrc) = 1514;
        v5 -= 4;
      }
    }
    if ( v5 )
    {
      v7 = v5 + 1510;
      if ( HIWORD(pszSrc) )
        LOWORD(pszSrc) = v7;
      else
        HIWORD(pszSrc) = v7;
    }
    if ( HIWORD(pszSrc) )
    {
      if ( !(_WORD)pszSrc )
      {
        LOWORD(pszSrc) = HIWORD(pszSrc);
        HIWORD(pszSrc) = v6;
        LOWORD(v22) = 0;
      }
    }
    else
    {
      LOWORD(pszSrc) = v6;
    }
  }
  v8 = v4 / 0xA;
  if ( v4 / 0xA )
  {
    v4 %= 0xAu;
    switch ( v8 )
    {
      case 1u:
        v9 = 1497;
        break;
      case 2u:
        v9 = 1499;
        break;
      case 3u:
        v9 = 1500;
        break;
      case 4u:
        v9 = 1502;
        break;
      case 5u:
        v9 = 1504;
        break;
      case 6u:
        v9 = 1505;
        break;
      case 7u:
        v9 = 1506;
        break;
      case 8u:
        v9 = 1508;
        break;
      case 9u:
        v9 = 1510;
        break;
      default:
        v9 = (unsigned int)&v15;
        break;
    }
  }
  else
  {
    v9 = 0;
  }
  v10 = v4 != 0 ? v4 + 1487 : 0;
  if ( v10 != 1492 )
    goto LABEL_34;
  if ( v9 == 1497 )
  {
    v10 = 1493;
    v9 = 1496;
LABEL_34:
    if ( v10 == 1493 && v9 == 1497 )
    {
      v10 = 1494;
      v9 = 1496;
    }
  }
  *(_DWORD *)&v15 = 0;
  Dst = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  if ( v10 )
  {
    v15 = v10;
    v11 = &pszDest;
  }
  else
  {
    v11 = &v15;
  }
  if ( v9 )
  {
    *v11 = v9;
    ++v11;
  }
  if ( StringCchCopyW(v11, 9 - (v11 - &v15), (STRSAFE_LPCWSTR)&pszSrc) >= 0
    && (SortNlsStrLenW(&v15) <= 1 ? (pszDest = v15, v15 = 39) : (v12 = SortNlsStrLenW(&pszDest),
                                                                 memmove(&Dst, &pszDest, 2 * v12),
                                                                 pszDest = 34),
        v13 = SortNlsStrLenW(&v15) - 1,
        v13 < a3 - 1) )
  {
    v14 = 0;
    while ( v13 >= 0 )
      *(_WORD *)(a2 + 2 * v14++) = *(&v15 + v13--);
    *(_WORD *)(a2 + 2 * v14) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E7FA6A) --------------------------------------------------------
int __stdcall GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
{
  int v6; // edi@1

  v6 = GetNamedLocaleHashNode(lpLocaleName, 0);
  if ( !v6 || cchTime < 0 || !lpTimeStr && cchTime || lpFormat && SortNlsStrLenW((void *)lpFormat) >= 256 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(dwFlags & 0x3FFFFFF0) && (!lpFormat || !(dwFlags & 0x80000000)) )
      return GetTimeFormatWorker(v6, dwFlags, (int)lpTime, (signed __int16 *)lpFormat, lpTimeStr, cchTime);
    RtlSetLastWin32Error(1004);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3FC4E: using guessed type int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD);

//----- (77E7FAEF) --------------------------------------------------------
int __stdcall GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
{
  unsigned int v7; // ebx@1
  int v9; // edi@8

  v7 = 0;
  if ( lpCalendar )
  {
    if ( dwFlags & 4
      || !(dwFlags & 0x40000000)
      || !NlsConvertStringToIntegerW((int)lpCalendar, 10, -1, (unsigned int *)&lpCalendar)
      || !IsValidCalendar((unsigned int)lpCalendar)
      || (v7 = 6, lpCalendar != (LPCWSTR)6) )
    {
      RtlSetLastWin32Error(87);
      return 0;
    }
  }
  v9 = GetNamedLocaleHashNode(lpLocaleName, 0);
  if ( !v9 || cchDate < 0 || !lpDateStr && cchDate || lpFormat && SortNlsStrLenW((void *)lpFormat) >= 256 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    if ( !(dwFlags & 0x3FFFFF80)
      && !((unsigned __int8)dwFlags & (unsigned __int8)((dwFlags & 0xF0) - 1) & 0x70)
      && (!lpFormat || !(dwFlags & 0x8000000B)) )
      return GetDateFormatWorker(v9, dwFlags, (int)lpDate, (int)lpFormat, lpDateStr, cchDate, v7);
    RtlSetLastWin32Error(1004);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3FC4E: using guessed type int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD);

//----- (77E7FBCA) --------------------------------------------------------
int __stdcall GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
{
  const WCHAR *v6; // eax@1
  int result; // eax@2

  v6 = (const WCHAR *)InternalLcidToName(Locale, 0);
  if ( v6 )
  {
    result = GetCurrencyFormatEx(v6, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}
// 77E2A5C4: using guessed type int __fastcall InternalLcidToName(_DWORD, _DWORD);

//----- (77E7FC06) --------------------------------------------------------
BOOL __stdcall VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
{
  LPCWSTR v6; // ecx@4
  int v7; // ebx@5
  LPCWSTR v8; // esi@6
  const WCHAR v9; // dx@9
  int v10; // eax@13
  LPCWSTR v11; // ecx@20
  unsigned __int16 v12; // di@21
  unsigned __int16 v13; // di@23
  const WCHAR v14; // di@27
  int v15; // edi@35
  LPCWSTR v16; // ecx@42
  int v17; // ecx@54
  const WCHAR v18; // ax@57
  const WCHAR v19; // ax@59
  const WCHAR v20; // ax@61

  if ( dwFlags && dwFlags != 1 )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  v6 = lpLocaleScripts;
  if ( !lpLocaleScripts )
    goto LABEL_32;
  v7 = cchLocaleScripts;
  if ( cchLocaleScripts < -1 )
    goto LABEL_32;
  v8 = lpTestScripts;
  if ( !lpTestScripts || cchTestScripts < -1 )
    goto LABEL_32;
  if ( cchLocaleScripts == -1 )
  {
    do
    {
      v9 = *v6;
      ++v6;
    }
    while ( v9 );
    v7 = v6 - (lpLocaleScripts + 1);
  }
  if ( cchTestScripts == -1 )
    cchTestScripts = wcslen(lpTestScripts);
  v10 = 0;
  if ( v7 > 0 && !lpLocaleScripts[v7 - 1] )
    --v7;
  if ( cchTestScripts > 0 && !lpTestScripts[cchTestScripts - 1] )
    --cchTestScripts;
  if ( v7 - 4 > 0 )
  {
    v11 = lpLocaleScripts + 2;
    do
    {
      v12 = *(v11 - 2);
      if ( v12 < 0x41u )
        goto LABEL_32;
      if ( v12 > 0x5Au )
        goto LABEL_32;
      v13 = *(v11 - 1);
      if ( v13 < 0x61u )
        goto LABEL_32;
      if ( v13 > 0x7Au )
        goto LABEL_32;
      if ( *v11 < 0x61u )
        goto LABEL_32;
      if ( *v11 > 0x7Au )
        goto LABEL_32;
      v14 = v11[1];
      if ( v14 < 0x61u || v14 > 0x7Au || v11[2] != 59 )
        goto LABEL_32;
      v10 += 5;
      v11 += 5;
    }
    while ( v10 < v7 - 4 );
  }
  if ( v10 < v7 )
  {
LABEL_32:
    RtlSetLastWin32Error(87);
    return 0;
  }
  while ( cchTestScripts >= 5 )
  {
    v15 = 0;
    if ( (dwFlags & 1) != 1 || *v8 != 76 || v8[1] != 97 || v8[2] != 116 || v8[3] != 110 || v8[4] != 59 )
    {
      if ( v7 <= 0 )
        goto LABEL_70;
      v16 = lpLocaleScripts + 2;
      do
      {
        if ( *v8 == *(v16 - 2) && v8[1] == *(v16 - 1) && v8[2] == *v16 && v8[3] == v16[1] && v8[4] == v16[2] )
          break;
        v15 += 5;
        v16 += 5;
      }
      while ( v15 < v7 );
      if ( v15 >= v7 )
      {
LABEL_70:
        RtlSetLastWin32Error(0);
        v17 = cchTestScripts;
        while ( v17 >= 5 )
        {
          if ( *v8 < 0x41u )
            goto LABEL_67;
          if ( *v8 > 0x5Au )
            goto LABEL_67;
          v18 = v8[1];
          if ( v18 < 0x61u )
            goto LABEL_67;
          if ( v18 > 0x7Au )
            goto LABEL_67;
          v19 = v8[2];
          if ( v19 < 0x61u )
            goto LABEL_67;
          if ( v19 > 0x7Au )
            goto LABEL_67;
          v20 = v8[3];
          if ( v20 < 0x61u || v20 > 0x7Au || v8[4] != 59 )
            goto LABEL_67;
          v17 -= 5;
          v8 += 5;
        }
        if ( v17 <= 0 )
          return 0;
LABEL_67:
        RtlSetLastWin32Error(87);
        return 0;
      }
    }
    cchTestScripts -= 5;
    v8 += 5;
  }
  if ( cchTestScripts > 0 )
    goto LABEL_32;
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7FE3A) --------------------------------------------------------
int __stdcall NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
{
  NTSTATUS v5; // eax@1
  NTSTATUS v6; // edi@1
  ULONG v7; // eax@2
  int result; // eax@6

  v5 = RtlNormalizeString(NormForm, lpSrcString, cwSrcLength, lpDstString, (PLONG)&cwDstLength);
  v6 = v5;
  if ( v5 >= 0 )
  {
    RtlSetLastWin32Error(0);
    result = cwDstLength;
  }
  else
  {
    v7 = RtlNtStatusToDosError(v5);
    RtlSetLastWin32Error(v7);
    if ( GetLastError() == 2 )
      RtlSetLastWin32Error(87);
    if ( v6 == -1073741789 || v6 == -1073740009 )
      result = -cwDstLength;
    else
      result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7FEB2) --------------------------------------------------------
BOOL __stdcall IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
{
  NTSTATUS v3; // eax@1
  ULONG v4; // eax@2
  BOOL result; // eax@4

  v3 = RtlIsNormalizedString(NormForm, lpString, cwLength, (PBOOLEAN)&cwLength + 3);
  if ( v3 >= 0 )
  {
    result = BYTE3(cwLength) == 1;
  }
  else
  {
    v4 = RtlNtStatusToDosError(v3);
    RtlSetLastWin32Error(v4);
    if ( GetLastError() == 2 )
      RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7FF04) --------------------------------------------------------
int __stdcall IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
{
  NTSTATUS v6; // eax@4
  ULONG v7; // ST10_4@5

  if ( dwFlags & 0xFFFFFFFC )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  v6 = RtlIdnToNameprepUnicode(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, (PLONG)&cchNameprepChar);
  if ( v6 < 0 )
  {
    v7 = RtlNtStatusToDosError(v6);
    RtlSetLastWin32Error(v7);
    return 0;
  }
  return cchNameprepChar;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7FF57) --------------------------------------------------------
int __stdcall IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
{
  NTSTATUS v6; // eax@4
  ULONG v7; // ST10_4@5

  if ( dwFlags & 0xFFFFFFFC )
  {
    RtlSetLastWin32Error(1004);
    return 0;
  }
  v6 = RtlIdnToUnicode(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, (PLONG)&cchUnicodeChar);
  if ( v6 < 0 )
  {
    v7 = RtlNtStatusToDosError(v6);
    RtlSetLastWin32Error(v7);
    return 0;
  }
  return cchUnicodeChar;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E7FFAA) --------------------------------------------------------
int __stdcall IsMSSigned(HMODULE hModule, int a2, char a3)
{
  FARPROC v3; // edi@2
  FARPROC v4; // eax@2
  int v5; // eax@7
  int v6; // ecx@8
  int v7; // ST04_4@11
  int v9; // [sp+Ch] [bp-8Ch]@11
  int v10; // [sp+10h] [bp-88h]@9
  int v11; // [sp+14h] [bp-84h]@9
  int v12; // [sp+18h] [bp-80h]@9
  int v13; // [sp+1Ch] [bp-7Ch]@9
  int v14; // [sp+20h] [bp-78h]@1
  int v15; // [sp+24h] [bp-74h]@1
  int v16; // [sp+28h] [bp-70h]@1
  int v17; // [sp+2Ch] [bp-6Ch]@1
  int v18; // [sp+30h] [bp-68h]@1
  int Dst; // [sp+34h] [bp-64h]@1
  int v20; // [sp+38h] [bp-60h]@6
  int v21; // [sp+3Ch] [bp-5Ch]@6
  int v22; // [sp+40h] [bp-58h]@6
  int v23; // [sp+44h] [bp-54h]@6
  int *v24; // [sp+48h] [bp-50h]@6
  int v25; // [sp+4Ch] [bp-4Ch]@6
  int v26; // [sp+50h] [bp-48h]@7
  int v27; // [sp+58h] [bp-40h]@6
  int v28; // [sp+60h] [bp-38h]@9
  int v29; // [sp+64h] [bp-34h]@9
  int v30; // [sp+68h] [bp-30h]@9
  int v31; // [sp+6Ch] [bp-2Ch]@1
  FARPROC v32; // [sp+70h] [bp-28h]@2
  FARPROC v33; // [sp+74h] [bp-24h]@2
  int v34; // [sp+78h] [bp-20h]@1
  HMODULE hLibModule; // [sp+7Ch] [bp-1Ch]@1
  FARPROC v36; // [sp+80h] [bp-18h]@2
  int v37; // [sp+84h] [bp-14h]@1
  __int16 v38; // [sp+88h] [bp-10h]@1
  __int16 v39; // [sp+8Ah] [bp-Eh]@1
  char v40; // [sp+8Ch] [bp-Ch]@1
  char v41; // [sp+8Dh] [bp-Bh]@1
  char v42; // [sp+8Eh] [bp-Ah]@1
  char v43; // [sp+8Fh] [bp-9h]@1
  char v44; // [sp+90h] [bp-8h]@1
  char v45; // [sp+91h] [bp-7h]@1
  char v46; // [sp+92h] [bp-6h]@1
  char v47; // [sp+93h] [bp-5h]@1

  v31 = a2;
  v34 = 0;
  v18 = 0;
  memset(&Dst, 0, 0x2Cu);
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v38 = -12988;
  v37 = 11191659;
  v39 = 4560;
  v40 = -116;
  v41 = -62;
  v42 = 0;
  v43 = -64;
  v44 = 79;
  v45 = -62;
  v46 = -107;
  v47 = -18;
  hLibModule = LoadLibraryW(L"crypt32.dll");
  if ( hLibModule )
  {
    v36 = GetProcAddress(hModule, "WinVerifyTrust");
    v3 = GetProcAddress(hModule, "WTHelperProvDataFromStateData");
    v33 = GetProcAddress(hModule, "WTHelperGetProvSignerFromChain");
    v4 = GetProcAddress(hLibModule, "CertVerifyCertificateChainPolicy");
    v32 = v4;
    if ( v36 )
    {
      if ( v3 )
      {
        if ( v33 )
        {
          if ( v4 )
          {
            v14 = 16;
            v27 = 16;
            v15 = v31;
            v18 = 48;
            Dst = 0;
            v20 = 0;
            v23 = 1;
            v24 = &v14;
            v21 = 2;
            v22 = 0;
            v25 = 1;
            if ( !((int (__stdcall *)(signed int, int *, int *))v36)(-1, &v37, &v18) )
            {
              v5 = ((int (__stdcall *)(int))v3)(v26);
              if ( v5 )
              {
                v6 = ((int (__stdcall *)(int, _DWORD, _DWORD, _DWORD))v33)(v5, 0, 0, 0);
                if ( v6 )
                {
                  v29 = 0;
                  v30 = 0;
                  v10 = 0;
                  v11 = 0;
                  v12 = 0;
                  v13 = 0;
                  v28 = 12;
                  if ( a3 )
                    v29 |= 0x10000u;
                  v7 = *(_DWORD *)(v6 + 40);
                  v9 = 20;
                  if ( ((int (__stdcall *)(signed int, int, int *, int *))v32)(7, v7, &v28, &v9) && !v10 )
                    v34 = 1;
                }
              }
              if ( v26 )
              {
                v25 = 2;
                ((void (__stdcall *)(_DWORD, int *, int *))v36)(0, &v37, &v18);
              }
            }
          }
        }
      }
    }
    FreeLibrary(hLibModule);
  }
  return v34;
}

//----- (77E80199) --------------------------------------------------------
BOOL __stdcall ValidateFileSignature(HMODULE hModule, int a2, int a3, char a4)
{
  void *v4; // esi@1
  FARPROC v5; // eax@3
  HLOCAL i; // eax@10
  int v7; // edi@21
  int v8; // edi@25
  SIZE_T v10; // [sp-Ch] [bp-2CCh]@16
  int *v11; // [sp-4h] [bp-2C4h]@16
  int v12; // [sp+Ch] [bp-2B4h]@10
  int *v13; // [sp+14h] [bp-2ACh]@18
  LPCWSTR v14; // [sp+18h] [bp-2A8h]@16
  void *v15; // [sp+24h] [bp-29Ch]@16
  SIZE_T v16; // [sp+28h] [bp-298h]@16
  int v17; // [sp+30h] [bp-290h]@25
  LPCWSTR v18; // [sp+34h] [bp-28Ch]@25
  HANDLE v19; // [sp+38h] [bp-288h]@25
  int v20; // [sp+3Ch] [bp-284h]@25
  int Dst; // [sp+40h] [bp-280h]@10
  int v22; // [sp+44h] [bp-27Ch]@10
  int v23; // [sp+4Ch] [bp-274h]@10
  int v24; // [sp+50h] [bp-270h]@10
  int v25; // [sp+54h] [bp-26Ch]@16
  int *v26; // [sp+58h] [bp-268h]@10
  int v27; // [sp+5Ch] [bp-264h]@10
  int v28; // [sp+68h] [bp-258h]@10
  FARPROC v29; // [sp+70h] [bp-250h]@3
  HMODULE v30; // [sp+74h] [bp-24Ch]@1
  FARPROC v31; // [sp+78h] [bp-248h]@3
  FARPROC v32; // [sp+7Ch] [bp-244h]@3
  int v33; // [sp+80h] [bp-240h]@1
  LPCWSTR lpFileName; // [sp+84h] [bp-23Ch]@1
  FARPROC v35; // [sp+88h] [bp-238h]@3
  int v36; // [sp+8Ch] [bp-234h]@16
  FARPROC v37; // [sp+90h] [bp-230h]@3
  SIZE_T uBytes; // [sp+94h] [bp-22Ch]@10
  HANDLE hObject; // [sp+98h] [bp-228h]@1
  DWORD v40; // [sp+9Ch] [bp-224h]@9
  int v41; // [sp+A0h] [bp-220h]@17
  int v42; // [sp+A4h] [bp-21Ch]@18
  int v43; // [sp+2ACh] [bp-14h]@1
  __int16 v44; // [sp+2B0h] [bp-10h]@1
  __int16 v45; // [sp+2B2h] [bp-Eh]@1
  char v46; // [sp+2B4h] [bp-Ch]@1
  char v47; // [sp+2B5h] [bp-Bh]@1
  char v48; // [sp+2B6h] [bp-Ah]@1
  char v49; // [sp+2B7h] [bp-9h]@1
  char v50; // [sp+2B8h] [bp-8h]@1
  char v51; // [sp+2B9h] [bp-7h]@1
  char v52; // [sp+2BAh] [bp-6h]@1
  char v53; // [sp+2BBh] [bp-5h]@1

  hObject = (HANDLE)-1;
  lpFileName = (LPCWSTR)a3;
  v44 = 14574;
  v4 = 0;
  v30 = hModule;
  v33 = a2;
  v43 = -145692989;
  v45 = 4561;
  v46 = -123;
  v47 = -27;
  v48 = 0;
  v49 = -64;
  v50 = 79;
  v51 = -62;
  v52 = -107;
  v53 = -18;
  if ( hModule && a2 )
  {
    v32 = GetProcAddress(hModule, "CryptCATAdminCalcHashFromFileHandle");
    v35 = GetProcAddress(hModule, "CryptCATAdminEnumCatalogFromHash");
    v31 = GetProcAddress(hModule, "CryptCATCatalogInfoFromContext");
    v37 = GetProcAddress(hModule, "WinVerifyTrust");
    v5 = GetProcAddress(hModule, "CryptCATAdminReleaseCatalogContext");
    v29 = v5;
    if ( !v32
      || !v35
      || !v31
      || !v37
      || !v5
      || (hObject = CreateFileW(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0), hObject == (HANDLE)-1) )
    {
      v40 = GetLastError();
      return v40 == 0;
    }
    memset(&Dst, 0, 0x30u);
    Dst = 48;
    v26 = &v12;
    v23 = 2;
    v24 = 0;
    v27 = 3;
    v28 = 16;
    v22 = 0;
    uBytes = 100;
    for ( i = LocalAlloc(0, 0x64u); ; i = LocalAlloc(0, uBytes) )
    {
      v4 = i;
      if ( !i )
        break;
      if ( ((int (__stdcall *)(HANDLE, SIZE_T *, HLOCAL, _DWORD))v32)(hObject, &uBytes, i, 0) )
      {
        v25 = 2;
        memset(&v12, 0, 0x24u);
        v14 = lpFileName;
        v11 = &v36;
        v12 = 36;
        v15 = v4;
        v16 = uBytes;
        v36 = 0;
        v10 = uBytes;
        while ( 1 )
        {
          v7 = ((int (__stdcall *)(int, void *, SIZE_T, _DWORD, int *))v35)(v33, v4, v10, 0, v11);
          if ( !v7 )
            goto LABEL_25;
          v41 = 524;
          if ( ((int (__stdcall *)(int, int *, _DWORD))v31)(v7, &v41, 0) )
          {
            v13 = &v42;
            v27 = 4;
            ((void (__stdcall *)(_DWORD, int *, int *))v37)(0, &v43, &Dst);
            v13 = &v42;
            v27 = 0;
            v40 = ((int (__stdcall *)(_DWORD, int *, int *))v37)(0, &v43, &Dst);
            if ( !v40 )
            {
              if ( IsMSSigned(v30, (int)&v42, a4) )
              {
                ((void (__stdcall *)(int, int, _DWORD))v29)(v33, v7, 0);
                goto LABEL_29;
              }
            }
          }
          v11 = &v36;
          v10 = uBytes;
          v36 = v7;
        }
      }
      v40 = GetLastError();
      LocalFree(v4);
      if ( v40 != 122 )
      {
        v4 = 0;
        break;
      }
    }
LABEL_25:
    v26 = &v17;
    v20 = 0;
    v8 = (int)lpFileName;
    v19 = hObject;
    v25 = 1;
    v17 = 16;
    v18 = lpFileName;
    v40 = ((int (__stdcall *)(_DWORD, int *, int *))v37)(0, &v43, &Dst);
    if ( !v40 && !IsMSSigned(v30, v8, a4) )
      v40 = 31;
  }
  else
  {
    v40 = 87;
  }
LABEL_29:
  if ( v4 )
    LocalFree(v4);
  if ( hObject != (HANDLE)-1 )
    CloseHandle(hObject);
  return v40 == 0;
}

//----- (77E8055A) --------------------------------------------------------
NTSTATUS __stdcall sub_77E8055A(PCWSTR SourceString, PVOID Address)
{
  WCHAR *v2; // ebx@1
  ULONG v3; // eax@3
  NTSTATUS v4; // edi@5
  NTSTATUS result; // eax@8
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-8h]@1

  v2 = (WCHAR *)Address;
  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  Address = 0;
  HIWORD(DestinationString.Buffer) = 0;
  if ( SourceString
    && v2
    && (v3 = RtlSizeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2), v3 != -1)
    && v3 >= 0xAA )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    v4 = RtlUnicodeStringToInteger(&DestinationString, 0x10u, (PULONG)&Address);
    if ( v4 >= 0 )
    {
      DestinationString.Length = 0;
      DestinationString.Buffer = v2;
      DestinationString.MaximumLength = 170;
      if ( !(unsigned __int8)RtlLCIDToCultureName(Address, &DestinationString) )
        v4 = -1073741823;
    }
    result = v4;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}
// 77DE1084: using guessed type int __stdcall RtlLCIDToCultureName(_DWORD, _DWORD);

//----- (77E805FE) --------------------------------------------------------
NTSTATUS __userpurge sub_77E805FE@<eax>(int a1@<eax>, int a2, void *Dst)
{
  NTSTATUS v3; // esi@1

  v3 = 0;
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 8) <= 0x24u )
      memcpy(Dst, (const void *)(a1 + 12), *(_DWORD *)(a1 + 8));
    else
      v3 = -1073741306;
  }
  else
  {
    v3 = sub_77E8055A((PCWSTR)(a1 + 12), Dst);
  }
  return v3;
}

//----- (77E80646) --------------------------------------------------------
NTSTATUS __thiscall sub_77E80646(PVOID Address, int a2)
{
  PVOID v2; // esi@1
  NTSTATUS result; // eax@2
  ULONG v4; // eax@3
  NTSTATUS v5; // eax@6
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-F8h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+24h] [bp-E0h]@1
  LSA_UNICODE_STRING ValueName; // [sp+2Ch] [bp-D8h]@1
  void *v9; // [sp+34h] [bp-D0h]@1
  ULONG ResultLength; // [sp+38h] [bp-CCh]@1
  HANDLE KeyHandle; // [sp+3Ch] [bp-C8h]@1
  NTSTATUS v12; // [sp+40h] [bp-C4h]@5
  char KeyValueInformation; // [sp+44h] [bp-C0h]@1
  char Dst; // [sp+45h] [bp-BFh]@1

  ObjectAttributes.Length = 0;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v2 = Address;
  v9 = Address;
  KeyHandle = 0;
  ResultLength = 0;
  KeyValueInformation = 0;
  memset(&Dst, 0, 0xB9u);
  ValueName.Length = 0;
  *(_DWORD *)&ValueName.MaximumLength = 0;
  HIWORD(ValueName.Buffer) = 0;
  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\NLS\\Language");
  if ( v2 && (v4 = RtlSizeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2), v4 != -1) && v4 >= 0xAC )
  {
    ObjectAttributes.ObjectName = &DestinationString;
    ObjectAttributes.Length = 24;
    ObjectAttributes.RootDirectory = 0;
    ObjectAttributes.Attributes = 64;
    ObjectAttributes.SecurityDescriptor = 0;
    ObjectAttributes.SecurityQualityOfService = 0;
    v12 = NtOpenKey(&KeyHandle, 0x20019u, &ObjectAttributes);
    if ( v12 >= 0 )
    {
      RtlInitUnicodeString(&ValueName, L"PreviousInstallLanguage");
      v5 = NtQueryValueKey(
             KeyHandle,
             &ValueName,
             KeyValuePartialInformation,
             &KeyValueInformation,
             0xBAu,
             &ResultLength);
      v12 = v5;
      if ( v5 >= 0
        || v5 == -1073741772
        && (memset(&KeyValueInformation, 0, 0xBAu),
            ResultLength = 0,
            RtlInitUnicodeString(&ValueName, L"InstallLanguage"),
            v12 = NtQueryValueKey(
                    KeyHandle,
                    &ValueName,
                    KeyValuePartialInformation,
                    &KeyValueInformation,
                    0xBAu,
                    &ResultLength),
            v12 >= 0) )
        v12 = sub_77E805FE((int)&KeyValueInformation, a2, v9);
    }
    if ( KeyHandle )
      NtClose(KeyHandle);
    result = v12;
  }
  else
  {
    result = -1073741811;
  }
  return result;
}

//----- (77E8091D) --------------------------------------------------------
signed int __stdcall Internal_AllowTestSign(int a1)
{
  NTSTATUS v2; // eax@3
  PVOID v3; // eax@5
  HMODULE v4; // eax@11
  HMODULE v5; // edi@11
  FARPROC v6; // esi@12
  FARPROC v7; // eax@12
  LSA_UNICODE_STRING DestinationString; // [sp+10h] [bp-454h]@3
  FARPROC v9; // [sp+18h] [bp-44Ch]@1
  int v10; // [sp+1Ch] [bp-448h]@1
  HMODULE hLibModule; // [sp+20h] [bp-444h]@1
  ULONG Length; // [sp+24h] [bp-440h]@1
  PVOID Address; // [sp+28h] [bp-43Ch]@1
  LSA_UNICODE_STRING Destination; // [sp+2Ch] [bp-438h]@3
  int v15; // [sp+34h] [bp-430h]@1
  NTSTATUS v16; // [sp+38h] [bp-42Ch]@3
  int v17; // [sp+3Ch] [bp-428h]@1
  __int16 v18; // [sp+40h] [bp-424h]@1
  __int16 v19; // [sp+42h] [bp-422h]@1
  char v20; // [sp+44h] [bp-420h]@1
  char v21; // [sp+45h] [bp-41Fh]@1
  char v22; // [sp+46h] [bp-41Eh]@1
  char v23; // [sp+47h] [bp-41Dh]@1
  char v24; // [sp+48h] [bp-41Ch]@1
  char v25; // [sp+49h] [bp-41Bh]@1
  char v26; // [sp+4Ah] [bp-41Ah]@1
  char v27; // [sp+4Bh] [bp-419h]@1
  char v28; // [sp+4Ch] [bp-418h]@1

  Address = &v28;
  v18 = 14574;
  v10 = a1;
  Length = 0;
  hLibModule = 0;
  v9 = 0;
  v15 = 0;
  v17 = -145692989;
  v19 = 4561;
  v20 = -123;
  v21 = -27;
  v22 = 0;
  v23 = -64;
  v24 = 79;
  v25 = -62;
  v26 = -107;
  v27 = -18;
  if ( !a1 )
    return -1073741811;
  Destination.Buffer = (PWCH)&v28;
  Destination.Length = 0;
  Destination.MaximumLength = 520;
  RtlInitUnicodeString(&DestinationString, L"%systemroot%\\system32\\ntdll.dll");
  v2 = RtlExpandEnvironmentStrings_U(0, &DestinationString, &Destination, &Length);
  v16 = v2;
  if ( v2 < 0 )
  {
    if ( v2 == -1073741789 )
    {
      v3 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, Length);
      Address = v3;
      if ( !v3 )
      {
        v16 = -1073741801;
        goto LABEL_20;
      }
      Destination.Buffer = (PWCH)v3;
      Destination.Length = 0;
      Destination.MaximumLength = Length;
      v16 = RtlExpandEnvironmentStrings_U(0, &DestinationString, &Destination, &Length);
    }
    if ( v16 < 0 )
      goto LABEL_20;
  }
  if ( Destination.Length > 1u )
  {
    _wcslwr(Destination.Buffer);
    v16 = -1073741103;
    v4 = LoadLibraryW(L"wintrust.dll");
    v5 = v4;
    hLibModule = v4;
    if ( !v4 )
      goto LABEL_20;
    v6 = GetProcAddress(v4, "CryptCATAdminAcquireContext");
    v7 = GetProcAddress(v5, "CryptCATAdminReleaseContext");
    v9 = v7;
    if ( !v6 || !v7 || !((int (__stdcall *)(int *, int *, _DWORD))v6)(&v15, &v17, 0) )
      goto LABEL_20;
    if ( (unsigned __int8)ValidateFileSignature(v5, v15, (int)Destination.Buffer, 0) )
    {
      *(_BYTE *)v10 = 0;
    }
    else
    {
      if ( !(unsigned __int8)ValidateFileSignature(v5, v15, (int)Destination.Buffer, 1) )
        goto LABEL_20;
      *(_BYTE *)v10 = 1;
    }
    v16 = 0;
    goto LABEL_20;
  }
  v16 = -1073741789;
LABEL_20:
  if ( v15 )
    ((void (__stdcall *)(int, _DWORD))v9)(v15, 0);
  if ( hLibModule )
    FreeLibrary(hLibModule);
  if ( Address )
  {
    if ( Address != &v28 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return v16;
}

//----- (77E80C25) --------------------------------------------------------
BOOL __stdcall SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
{
  NTSTATUS v3; // eax@1
  BOOL result; // eax@2
  DWORD v5; // eax@3

  v3 = RtlSetProcessPreferredUILanguages(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
  if ( v3 < 0 )
  {
    v5 = RtlNtStatusToDosError(v3);
    SetLastError(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1078: using guessed type int __stdcall RtlSetProcessPreferredUILanguages(_DWORD, _DWORD, _DWORD);

//----- (77E80C5A) --------------------------------------------------------
int __stdcall MuiEtwGetStringFromMultiString(STRSAFE_PCNZWCH psz, int a2)
{
  STRSAFE_PCNZWCH v2; // ebx@1
  int v3; // edi@1
  PVOID v4; // esi@6
  size_t v5; // edi@11
  int result; // eax@16
  int v7; // [sp+8h] [bp-Ch]@1
  size_t pcchLength; // [sp+Ch] [bp-8h]@1
  size_t cchDest; // [sp+10h] [bp-4h]@1
  signed int psza; // [sp+1Ch] [bp+8h]@1

  v2 = psz;
  v3 = a2;
  cchDest = 342;
  v7 = 0;
  pcchLength = 0;
  psza = 0;
  if ( !a2 || *(_DWORD *)a2 )
  {
    result = -1073741811;
  }
  else
  {
    if ( !v2 || !*v2 )
      cchDest = 8;
    v4 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * cchDest);
    *(_WORD *)v4 = 0;
    *(_DWORD *)a2 = v4;
    if ( v2 && *v2 )
    {
      while ( StringCchLengthW(v2, cchDest - v7, &pcchLength) >= 0
           && ((signed int)((char *)v4 - *(_DWORD *)v3) >> 1) + pcchLength + 1 <= cchDest )
      {
        v5 = 2 * pcchLength;
        memcpy(v4, v2, 2 * pcchLength + 2);
        v2 = (STRSAFE_PCNZWCH)((char *)v2 + v5 + 2);
        v4 = (char *)v4 + v5 + 2;
        v7 += pcchLength + 1;
        if ( !*v2 )
          goto LABEL_16;
        *((_WORD *)v4 - 1) = 44;
        if ( !*v2 )
          goto LABEL_16;
        v3 = a2;
      }
      psza = -2147483643;
      if ( v4 )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    }
    else
    {
      StringCchCopyW((STRSAFE_LPWSTR)v4, cchDest, L"(null)");
    }
LABEL_16:
    result = psza;
  }
  return result;
}

//----- (77E80D87) --------------------------------------------------------
NTSTATUS __userpurge Internal_NotifyUILanguageChange@<eax>(int a1@<ebp>, int a2, const WCHAR *a3, const wchar_t *a4, int a5, REGHANDLE a6, char a7, int a8)
{
  void *v8; // esi@1
  const WCHAR *v9; // edi@1
  void *v10; // edi@26
  PVOID v12; // eax@54
  int v13; // eax@76
  int v14; // eax@81
  void (__stdcall *v15)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // edi@84
  void *v16; // eax@88
  __int16 v17; // di@89
  unsigned int v18; // kr0C_4@90
  FARPROC v19; // esi@97
  FARPROC v20; // eax@97
  NTSTATUS v21; // eax@100
  PVOID v22; // eax@103
  NTSTATUS v23; // eax@106
  PVOID v24; // esi@110
  NTSTATUS v25; // eax@113
  int v26; // eax@115
  ULONG v27; // esi@116
  PVOID v28; // ST14_4@116
  PVOID v29; // eax@116
  NTSTATUS v30; // eax@118
  NTSTATUS v31; // eax@121
  PVOID v32; // eax@123
  const EVENT_DESCRIPTOR *v33; // esi@127
  int *v34; // eax@128
  char v35; // si@140
  FARPROC v36; // eax@140
  int v37; // esi@140
  int *v38; // eax@144
  int v39; // eax@153
  int *v40; // [sp-3E4h] [bp-3ECh]@88
  int v41; // [sp-3E0h] [bp-3E8h]@88
  signed int v42; // [sp-3DCh] [bp-3E4h]@88
  int v43; // [sp-3D8h] [bp-3E0h]@88
  void *v44; // [sp-3D4h] [bp-3DCh]@90
  int v45; // [sp-3D0h] [bp-3D8h]@90
  int v46; // [sp-3CCh] [bp-3D4h]@90
  int v47; // [sp-3C8h] [bp-3D0h]@90
  const unsigned __int16 *v48; // [sp-3C4h] [bp-3CCh]@90
  int v49; // [sp-3C0h] [bp-3C8h]@90
  int v50; // [sp-3BCh] [bp-3C4h]@90
  int v51; // [sp-3B8h] [bp-3C0h]@90
  int *v52; // [sp-3B4h] [bp-3BCh]@90
  int v53; // [sp-3B0h] [bp-3B8h]@90
  signed int v54; // [sp-3ACh] [bp-3B4h]@90
  int v55; // [sp-3A8h] [bp-3B0h]@90
  int v56; // [sp-3A4h] [bp-3ACh]@165
  int v57; // [sp-3A0h] [bp-3A8h]@165
  int v58; // [sp-39Ch] [bp-3A4h]@165
  int v59; // [sp-398h] [bp-3A0h]@165
  const CHAR *v60; // [sp-394h] [bp-39Ch]@165
  int v61; // [sp-390h] [bp-398h]@165
  unsigned int v62; // [sp-38Ch] [bp-394h]@165
  int v63; // [sp-388h] [bp-390h]@165
  int *v64; // [sp-384h] [bp-38Ch]@165
  int v65; // [sp-380h] [bp-388h]@165
  signed int v66; // [sp-37Ch] [bp-384h]@165
  int v67; // [sp-378h] [bp-380h]@165
  int v68; // [sp-374h] [bp-37Ch]@149
  int v69; // [sp-370h] [bp-378h]@149
  int v70; // [sp-36Ch] [bp-374h]@149
  int v71; // [sp-368h] [bp-370h]@149
  int *v72; // [sp-364h] [bp-36Ch]@149
  int v73; // [sp-360h] [bp-368h]@149
  signed int v74; // [sp-35Ch] [bp-364h]@149
  int v75; // [sp-358h] [bp-360h]@149
  const CHAR *v76; // [sp-354h] [bp-35Ch]@149
  int v77; // [sp-350h] [bp-358h]@149
  unsigned int v78; // [sp-34Ch] [bp-354h]@149
  int v79; // [sp-348h] [bp-350h]@149
  int v80; // [sp-344h] [bp-34Ch]@144
  int v81; // [sp-340h] [bp-348h]@144
  int v82; // [sp-33Ch] [bp-344h]@144
  int v83; // [sp-338h] [bp-340h]@144
  int *v84; // [sp-334h] [bp-33Ch]@144
  int v85; // [sp-330h] [bp-338h]@144
  signed int v86; // [sp-32Ch] [bp-334h]@144
  int v87; // [sp-328h] [bp-330h]@144
  const CHAR *v88; // [sp-324h] [bp-32Ch]@144
  int v89; // [sp-320h] [bp-328h]@144
  unsigned int v90; // [sp-31Ch] [bp-324h]@144
  int v91; // [sp-318h] [bp-320h]@144
  int v92; // [sp-314h] [bp-31Ch]@128
  int v93; // [sp-310h] [bp-318h]@128
  int v94; // [sp-30Ch] [bp-314h]@128
  int v95; // [sp-308h] [bp-310h]@128
  int v96; // [sp-304h] [bp-30Ch]@134
  int v97; // [sp-300h] [bp-308h]@134
  int v98; // [sp-2FCh] [bp-304h]@134
  int v99; // [sp-2F8h] [bp-300h]@134
  int v100; // [sp-2F4h] [bp-2FCh]@139
  int v101; // [sp-2F0h] [bp-2F8h]@139
  int v102; // [sp-2ECh] [bp-2F4h]@139
  int v103; // [sp-2E8h] [bp-2F0h]@139
  int v104; // [sp-2E0h] [bp-2E8h]@1
  signed int v105; // [sp-2DCh] [bp-2E4h]@100
  void *v106; // [sp-2D8h] [bp-2E0h]@100
  unsigned __int16 *v107; // [sp-2D4h] [bp-2DCh]@100
  signed int v108; // [sp-2D0h] [bp-2D8h]@100
  int v109; // [sp-2CCh] [bp-2D4h]@100
  int v110; // [sp-2C8h] [bp-2D0h]@100
  __int16 v111; // [sp-2C4h] [bp-2CCh]@56
  signed __int16 v112; // [sp-2C2h] [bp-2CAh]@56
  PVOID v113; // [sp-2C0h] [bp-2C8h]@56
  int v114; // [sp-2BCh] [bp-2C4h]@53
  ULONG v115; // [sp-2B8h] [bp-2C0h]@1
  const wchar_t *v116; // [sp-2B4h] [bp-2BCh]@1
  const wchar_t *v117; // [sp-2B0h] [bp-2B8h]@1
  ULONG v118; // [sp-2ACh] [bp-2B4h]@105
  FARPROC v119; // [sp-2A8h] [bp-2B0h]@1
  int v120; // [sp-2A4h] [bp-2ACh]@1
  int v121; // [sp-2A0h] [bp-2A8h]@1
  int v122; // [sp-29Ch] [bp-2A4h]@88
  int v123; // [sp-298h] [bp-2A0h]@1
  FARPROC v124; // [sp-294h] [bp-29Ch]@146
  void *v125; // [sp-290h] [bp-298h]@86
  ULONG v126; // [sp-28Ch] [bp-294h]@103
  PVOID v127; // [sp-288h] [bp-290h]@1
  int v128; // [sp-284h] [bp-28Ch]@2
  void *v129; // [sp-280h] [bp-288h]@1
  const unsigned __int16 *v130; // [sp-27Ch] [bp-284h]@86
  void *v131; // [sp-278h] [bp-280h]@1
  void *v132; // [sp-274h] [bp-27Ch]@1
  HMODULE v133; // [sp-270h] [bp-278h]@1
  HMODULE v134; // [sp-26Ch] [bp-274h]@1
  void *v135; // [sp-268h] [bp-270h]@1
  void *v136; // [sp-264h] [bp-26Ch]@1
  unsigned __int16 v137; // [sp-260h] [bp-268h]@64
  int v138; // [sp-25Ch] [bp-264h]@65
  void *v139; // [sp-258h] [bp-260h]@1
  int v140; // [sp-254h] [bp-25Ch]@1
  signed int v141; // [sp-250h] [bp-258h]@1
  void *v142; // [sp-24Ch] [bp-254h]@1
  unsigned __int16 v143; // [sp-248h] [bp-250h]@105
  signed __int16 v144; // [sp-246h] [bp-24Eh]@105
  int v145; // [sp-244h] [bp-24Ch]@105
  PVOID v146; // [sp-240h] [bp-248h]@1
  const CHAR *v147; // [sp-23Ch] [bp-244h]@10
  NTSTATUS v148; // [sp-238h] [bp-240h]@14
  signed int v149; // [sp-234h] [bp-23Ch]@1
  signed __int16 v150; // [sp-230h] [bp-238h]@1
  signed __int16 v151; // [sp-22Eh] [bp-236h]@1
  char v152; // [sp-22Ch] [bp-234h]@1
  char v153; // [sp-22Bh] [bp-233h]@1
  char v154; // [sp-22Ah] [bp-232h]@1
  char v155; // [sp-229h] [bp-231h]@1
  char v156; // [sp-228h] [bp-230h]@1
  char v157; // [sp-227h] [bp-22Fh]@1
  char v158; // [sp-226h] [bp-22Eh]@1
  char v159; // [sp-225h] [bp-22Dh]@1
  int v160; // [sp-224h] [bp-22Ch]@106
  unsigned int v161; // [sp-218h] [bp-220h]@107
  int v162; // [sp-214h] [bp-21Ch]@109
  unsigned int v163; // [sp-8h] [bp-10h]@1
  int v164; // [sp-4h] [bp-Ch]@1
  int v165; // [sp+0h] [bp-8h]@1
  int retaddr; // [sp+8h] [bp+0h]@1

  v164 = a1;
  v165 = retaddr;
  v163 = (unsigned int)&v164 ^ __security_cookie;
  v104 = a8;
  v8 = (void *)a4;
  v9 = a3;
  v150 = 14574;
  v117 = a3;
  v116 = a4;
  v136 = 0;
  v129 = 0;
  v132 = 0;
  v131 = 0;
  v135 = 0;
  v142 = 0;
  v120 = 0;
  v121 = 0;
  v139 = 0;
  v115 = 0;
  v134 = 0;
  v141 = 0;
  v140 = 0;
  v127 = 0;
  v146 = 0;
  v133 = 0;
  v119 = 0;
  v123 = 0;
  v149 = -145692989;
  v151 = 4561;
  v152 = -123;
  v153 = -27;
  v154 = 0;
  v155 = -64;
  v156 = 79;
  v157 = -62;
  v158 = -107;
  v159 = -18;
  if ( a5 & 0xFFFFFFFE )
    goto LABEL_14;
  v128 = (unsigned __int8)a2;
  if ( (unsigned __int8)a2 == 1 )
  {
    if ( !a3 || !a4 || !*a3 || !*a4 )
      goto LABEL_14;
    v147 = "OnMachineUILanguageSwitch";
  }
  else if ( (unsigned __int8)a2 == 2 || (unsigned __int8)a2 == 4 )
  {
    if ( a4 )
      goto LABEL_14;
    if ( !a3 )
      goto LABEL_14;
    if ( !*a3 )
      goto LABEL_14;
    RtlInitUnicodeString((PUNICODE_STRING)&v137, a3);
    if ( v137 < 2u || *(_WORD *)(v138 + 2 * ((unsigned int)v137 >> 1) + 2) )
      goto LABEL_14;
    if ( v128 == 2 )
      v147 = "OnUILanguageAdd";
    else
      v147 = "OnUILanguageRemove";
  }
  else
  {
    if ( (unsigned __int8)a2 != 8 )
    {
      if ( (unsigned __int8)a2 == 16 && !a3 && a4 && *a4 )
      {
        v147 = "OnMachineUILanguageClear";
        goto LABEL_79;
      }
      goto LABEL_14;
    }
    if ( a4 )
    {
LABEL_14:
      v148 = -1073741811;
LABEL_15:
      v141 = 1;
      goto LABEL_16;
    }
    if ( a3 )
    {
      if ( !*a3 )
        goto LABEL_14;
    }
    else
    {
      v114 = 0;
      v148 = NtQueryInstallUILanguage((PLANGID)&v114);
      if ( v148 < 0 )
        goto LABEL_15;
      v12 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0xACu);
      v127 = v12;
      if ( !v12 )
      {
LABEL_55:
        v148 = -1073741801;
        goto LABEL_15;
      }
      v113 = v12;
      v112 = 170;
      v111 = 0;
      if ( !(unsigned __int8)RtlLCIDToCultureName((unsigned __int16)v114, &v111) )
      {
        v148 = -1073741595;
        goto LABEL_15;
      }
      v136 = v113;
      v148 = RtlpConvertCultureNamesToLCIDs(v113, &v132);
      if ( v148 < 0 )
        goto LABEL_15;
      a2 |= 0x100u;
    }
    v147 = "OnMachineUILanguageInit";
  }
  if ( v9 )
  {
    if ( a2 & 0x100 )
    {
      v132 = (void *)v9;
      v13 = RtlpConvertLCIDsToCultureNames(v9, &v136);
    }
    else
    {
      v136 = (void *)v9;
      v13 = RtlpConvertCultureNamesToLCIDs(v9, &v132);
    }
    v148 = v13;
    if ( v13 < 0 )
      goto LABEL_15;
  }
LABEL_79:
  if ( v8 )
  {
    if ( a2 & 0x100 )
    {
      v131 = v8;
      v14 = RtlpConvertLCIDsToCultureNames(v8, &v129);
    }
    else
    {
      v129 = v8;
      v14 = RtlpConvertCultureNamesToLCIDs(v8, &v131);
    }
    v148 = v14;
    if ( v14 < 0 )
      goto LABEL_15;
  }
  v15 = (void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))EtwEventWrite;
  if ( a6 && EtwEventEnabled(a6, &MUI_ETW_EVENT_NOTIFY_INIT_INFO) )
  {
    v125 = 0;
    v130 = 0;
    if ( MuiEtwGetStringFromMultiString(v117, (int)&v125) >= 0 && MuiEtwGetStringFromMultiString(v116, (int)&v130) >= 0 )
    {
      v40 = &a2;
      v16 = v125;
      v41 = 0;
      v42 = 4;
      v43 = 0;
      v122 = (int)((char *)v125 + 2);
      do
      {
        v17 = *(_WORD *)v16;
        v16 = (char *)v16 + 2;
      }
      while ( v17 );
      v44 = v125;
      v46 = 2 * ((signed int)((char *)v16 - v122) >> 1) + 2;
      v45 = 0;
      v47 = 0;
      v18 = wcslen(v130);
      v15 = (void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))EtwEventWrite;
      v50 = 2 * v18 + 2;
      v49 = 0;
      v51 = 0;
      v52 = &a5;
      v53 = 0;
      v55 = 0;
      v48 = v130;
      v54 = 4;
      EtwEventWrite(a6, HIDWORD(a6), &MUI_ETW_EVENT_NOTIFY_INIT_INFO, 4, &v40);
    }
    if ( v125 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v125);
    if ( v130 )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (PVOID)v130);
  }
  v133 = LoadLibraryW(L"wintrust.dll");
  if ( !v133
    || (v19 = GetProcAddress(v133, "CryptCATAdminAcquireContext"),
        v20 = GetProcAddress(v133, "CryptCATAdminReleaseContext"),
        v119 = v20,
        !v19)
    || !v20
    || !((int (__stdcall *)(int *, signed int *, _DWORD))v19)(&v123, &v149, 0) )
  {
    v148 = -1073741595;
    goto LABEL_16;
  }
  RtlInitUnicodeString(
    (PUNICODE_STRING)&v137,
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\MUI\\CallbackDlls");
  v106 = 0;
  v109 = 0;
  v110 = 0;
  v105 = 24;
  v108 = 64;
  v107 = &v137;
  v21 = NtOpenKey(&v135, 0x20019u, (POBJECT_ATTRIBUTES)&v105);
  v148 = v21;
  if ( v21 >= 0 )
  {
    v126 = 534;
    v146 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0x216u);
    v22 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0x20Au);
    v139 = v22;
    if ( v146 && v22 )
    {
      v145 = (int)v22;
      v118 = 0;
      v143 = 0;
      v144 = 520;
      while ( 1 )
      {
        v23 = NtEnumerateKey(v135, v118, 0, &v160, 0x1FEu, (PULONG)&v120);
        v148 = v23;
        if ( v23 < 0 )
        {
          if ( v23 == -2147483622 )
            goto LABEL_102;
          goto LABEL_167;
        }
        if ( v161 + 1 > 0x1E8 )
          goto LABEL_108;
        *((_WORD *)&v164 + (v161 >> 1) - 264) = 0;
        RtlInitUnicodeString((PUNICODE_STRING)&v137, (PCWSTR)&v162);
        v109 = 0;
        v110 = 0;
        v106 = v135;
        v107 = &v137;
        v105 = 24;
        v108 = 64;
        v148 = NtOpenKey(&v142, 0x20019u, (POBJECT_ATTRIBUTES)&v105);
        if ( v148 < 0 )
          goto LABEL_167;
        RtlInitUnicodeString((PUNICODE_STRING)&v137, L"Type");
        v24 = v146;
        v148 = NtQueryValueKey(v142, (PUNICODE_STRING)&v137, KeyValuePartialInformation, v146, v126, (PULONG)&v120);
        if ( v148 < 0 || *((_DWORD *)v24 + 1) != 4 )
          goto LABEL_167;
        v121 = *((_DWORD *)v24 + 3);
        if ( v121 & v128 )
          break;
LABEL_168:
        if ( v142 )
        {
          NtClose(v142);
          v142 = 0;
        }
        if ( v134 )
        {
          LdrUnloadDll(v134);
          v134 = 0;
        }
        ++v118;
        if ( v148 == -2147483622 )
          goto LABEL_16;
      }
      RtlInitUnicodeString((PUNICODE_STRING)&v137, L"DllPath");
      v25 = NtQueryValueKey(v142, (PUNICODE_STRING)&v137, KeyValuePartialInformation, v24, v126, (PULONG)&v120);
      v148 = v25;
      if ( v25 >= 0 )
        goto LABEL_120;
      if ( v25 != -2147483643 )
        goto LABEL_119;
      v26 = *((_DWORD *)v24 + 2);
      if ( !v26 )
        goto LABEL_167;
      v27 = v26 + 2;
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v146);
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v139);
      v28 = NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1];
      v126 = v27 + 12;
      v146 = RtlAllocateHeap(v28, 8u, v27 + 12);
      v29 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, v27);
      v139 = v29;
      if ( !v146 || !v29 )
      {
LABEL_108:
        v148 = -1073741801;
        goto LABEL_167;
      }
      v30 = NtQueryValueKey(v142, (PUNICODE_STRING)&v137, KeyValuePartialInformation, v146, v126, (PULONG)&v120);
      v24 = v146;
      v148 = v30;
LABEL_119:
      if ( v148 < 0 )
      {
LABEL_167:
        v141 |= 1u;
        goto LABEL_168;
      }
LABEL_120:
      if ( *((_DWORD *)v24 + 1) != 2 )
        goto LABEL_167;
      *((_WORD *)v24 + (*((_DWORD *)v24 + 2) >> 1) + 6) = 0;
      RtlInitUnicodeString((PUNICODE_STRING)&v137, (PCWSTR)v24 + 6);
      v31 = RtlExpandEnvironmentStrings_U(0, (PUNICODE_STRING)&v137, (PUNICODE_STRING)&v143, &v115);
      v148 = v31;
      if ( v31 < 0 )
      {
        if ( v31 == -1073741789 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v139);
          v32 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, v115);
          v139 = v32;
          v145 = (int)v32;
          v31 = RtlExpandEnvironmentStrings_U(0, (PUNICODE_STRING)&v137, (PUNICODE_STRING)&v143, &v115);
          v148 = v31;
        }
        if ( v31 < 0 )
          goto LABEL_167;
      }
      *(_WORD *)(v145 + 2 * ((unsigned int)v143 >> 1)) = 0;
      _wcslwr((wchar_t *)v145);
      if ( !RtlDoesFileExists_U((PWSTR)v145) )
      {
        if ( a6 )
        {
          v33 = &MUI_ETW_EVENT_CALLBACK_DLL_NOT_FOUND;
          if ( EtwEventEnabled(a6, &MUI_ETW_EVENT_CALLBACK_DLL_NOT_FOUND) )
          {
            v93 = 0;
            v92 = v145;
            v95 = 0;
            v94 = v143 + 2;
            v34 = &v92;
            goto LABEL_129;
          }
        }
        goto LABEL_167;
      }
      if ( !(unsigned __int8)ValidateFileSignature(v133, v123, v145, a7) )
      {
        v141 |= 0x1000u;
        if ( a6 && EtwEventEnabled(a6, &MUI_ETW_EVENT_CALLBACK_DLL_NOT_SIGNED) )
        {
          v97 = 0;
          v96 = v145;
          v99 = 0;
          v98 = v143 + 2;
          v15(a6, HIDWORD(a6), &MUI_ETW_EVENT_CALLBACK_DLL_NOT_SIGNED, 1, &v96);
        }
        goto LABEL_168;
      }
      v134 = LoadLibraryW((LPCWSTR)v145);
      if ( !v134 )
      {
        if ( a6 )
        {
          v33 = &MUI_ETW_EVENT_CALLBACK_DLL_LOAD_FAILURE;
          if ( EtwEventEnabled(a6, &MUI_ETW_EVENT_CALLBACK_DLL_LOAD_FAILURE) )
          {
            v101 = 0;
            v100 = v145;
            v103 = 0;
            v102 = v143 + 2;
            v34 = &v100;
LABEL_129:
            v15(a6, HIDWORD(a6), v33, 1, v34);
          }
        }
        goto LABEL_167;
      }
      v35 = v128;
      v36 = GetProcAddress(v134, v147);
      v37 = v35 & 1;
      if ( v37 )
      {
        v122 = (int)v36;
        if ( !v36 )
        {
          if ( !a6 || !EtwEventEnabled(a6, &MUI_ETW_EVENT_CALLBACK_FUNCTION_NOT_FOUND) )
            goto LABEL_167;
          v80 = v145;
          v82 = v143 + 2;
          v84 = &v121;
          v81 = 0;
          v83 = 0;
          v85 = 0;
          v86 = 4;
          v87 = 0;
          v90 = strlen(v147) + 1;
          v88 = v147;
          v89 = 0;
          v91 = 0;
          v38 = &v80;
          goto LABEL_145;
        }
      }
      else
      {
        v124 = v36;
        if ( !v36 )
        {
          if ( !a6 || !EtwEventEnabled(a6, &MUI_ETW_EVENT_CALLBACK_FUNCTION_NOT_FOUND) )
            goto LABEL_167;
          v68 = v145;
          v70 = v143 + 2;
          v72 = &v121;
          v69 = 0;
          v71 = 0;
          v73 = 0;
          v74 = 4;
          v75 = 0;
          v78 = strlen(v147) + 1;
          v76 = v147;
          v77 = 0;
          v79 = 0;
          v38 = &v68;
LABEL_145:
          v15(a6, HIDWORD(a6), &MUI_ETW_EVENT_CALLBACK_FUNCTION_NOT_FOUND, 3, v38);
          goto LABEL_167;
        }
      }
      if ( v148 >= 0 )
      {
        if ( v121 & 0x100 )
        {
          if ( v37 )
          {
            v39 = ((int (__stdcall *)(void *, void *, int))v122)(v132, v131, a5);
          }
          else if ( v128 & 0x10 )
          {
            v39 = ((int (__stdcall *)(void *, int))v124)(v131, a5);
          }
          else
          {
            v39 = ((int (__stdcall *)(void *, int))v124)(v132, a5);
          }
        }
        else if ( v37 )
        {
          v39 = ((int (__stdcall *)(void *, void *, int))v122)(v136, v129, a5);
        }
        else if ( v128 & 0x10 )
        {
          v39 = ((int (__stdcall *)(_DWORD, _DWORD))v124)(v129, a5);
        }
        else
        {
          v39 = ((int (__stdcall *)(_DWORD, _DWORD))v124)(v136, a5);
        }
        v141 |= v39;
        v140 = v39;
        if ( a6 && EtwEventEnabled(a6, &MUI_ETW_EVENT_NOTIFY_CALLBACK_RETURN_INFO) )
        {
          v56 = v145;
          v58 = v143 + 2;
          v57 = 0;
          v59 = 0;
          v62 = strlen(v147) + 1;
          v64 = &v140;
          v60 = v147;
          v61 = 0;
          v63 = 0;
          v65 = 0;
          v66 = 4;
          v67 = 0;
          v15(a6, HIDWORD(a6), &MUI_ETW_EVENT_NOTIFY_CALLBACK_RETURN_INFO, 3, &v56);
        }
        goto LABEL_168;
      }
      goto LABEL_167;
    }
    goto LABEL_55;
  }
  if ( v21 == -1073741772 )
LABEL_102:
    v148 = 0;
LABEL_16:
  if ( v104 )
    *(_DWORD *)v104 = v141;
  if ( v135 )
  {
    NtClose(v135);
    v135 = 0;
  }
  if ( v142 )
  {
    NtClose(v142);
    v142 = 0;
  }
  if ( v146 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v146);
  if ( v139 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v139);
  v10 = v127;
  if ( v136 && v136 != (void *)v117 )
  {
    if ( v127 == v136 )
      v10 = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v136);
  }
  if ( v132 && v132 != (void *)v117 )
  {
    if ( v10 == v132 )
      v10 = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v132);
  }
  if ( v129 && v129 != (void *)v116 )
  {
    if ( v10 == v129 )
      v10 = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v129);
  }
  if ( v131 && v131 != (void *)v116 )
  {
    if ( v10 == v131 )
      v10 = 0;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v131);
  }
  if ( v10 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v10);
  if ( v123 )
    ((void (__stdcall *)(int, _DWORD))v119)(v123, 0);
  if ( v133 )
    FreeLibrary(v133);
  return v148;
}
// 77E80D87: could not find valid save-restore pair for ebp
// 77DE106C: using guessed type int __stdcall RtlpConvertCultureNamesToLCIDs(_DWORD, _DWORD);
// 77DE1070: using guessed type int __stdcall RtlpConvertLCIDsToCultureNames(_DWORD, _DWORD);
// 77DE1084: using guessed type int __stdcall RtlLCIDToCultureName(_DWORD, _DWORD);
// 77DE1434: using guessed type int __stdcall EtwEventWrite(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E81EEE) --------------------------------------------------------
signed int __stdcall sub_77E81EEE(DWORD dwFlags, const WCHAR *a2, int a3, REGHANDLE a4, char a5, int a6)
{
  int v6; // ebp@0
  PVOID v7; // ebx@4
  NTSTATUS v8; // esi@5
  const WCHAR *v9; // esi@7
  PVOID v10; // eax@8
  ULONG pulNumLanguages; // [sp+Ch] [bp-10h]@1
  ULONG pcchLanguagesBuffer; // [sp+10h] [bp-Ch]@1
  PVOID Address; // [sp+14h] [bp-8h]@1
  int v15; // [sp+18h] [bp-4h]@1
  signed int dwFlagsa; // [sp+24h] [bp+8h]@2

  pulNumLanguages = 0;
  Address = 0;
  v15 = 1;
  pcchLanguagesBuffer = 87;
  if ( dwFlags & 0x100 )
  {
    v15 = 257;
    dwFlagsa = 1028;
  }
  else
  {
    dwFlagsa = 1032;
  }
  v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 0xAEu);
  if ( !v7 )
    return -1073741801;
  v8 = sub_77E80646(v7, v15 & 0x100);
  if ( v8 >= 0 )
  {
    v9 = a2;
    if ( a2 )
      goto LABEL_18;
    v10 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * pcchLanguagesBuffer);
    v9 = (const WCHAR *)v10;
    Address = v10;
    if ( !v10 )
    {
      v8 = -1073741801;
      goto LABEL_13;
    }
    if ( GetSystemPreferredUILanguages(dwFlagsa, &pulNumLanguages, (PZZWSTR)v10, &pcchLanguagesBuffer) )
LABEL_18:
      v8 = Internal_NotifyUILanguageChange(v6, v15, v9, (const wchar_t *)v7, a3, a4, a5, a6);
    else
      v8 = -1073741595;
  }
LABEL_13:
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v8;
}

//----- (77E82010) --------------------------------------------------------
BOOL __stdcall NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
{
  int v5; // ebp@0
  NTSTATUS v6; // eax@7
  DWORD v7; // eax@18
  NTSTATUS *v9; // [sp+Ch] [bp-28h]@5
  int v10; // [sp+10h] [bp-24h]@5
  int v11; // [sp+14h] [bp-20h]@5
  int v12; // [sp+18h] [bp-1Ch]@5
  REGHANDLE RegHandle; // [sp+1Ch] [bp-18h]@1
  int v14; // [sp+24h] [bp-10h]@1
  int v15; // [sp+28h] [bp-Ch]@1
  int v16; // [sp+2Ch] [bp-8h]@1
  NTSTATUS NtStatus; // [sp+30h] [bp-4h]@1

  NtStatus = 0;
  v14 = 0;
  RegHandle = 0i64;
  v15 = 0;
  LOBYTE(v16) = 0;
  if ( EtwEventRegister(MUI_ETW_PROVIDER, 0, 0, &RegHandle) )
    RegHandle = 0i64;
  if ( RegHandle && EtwEventEnabled(RegHandle, &MUI_ETW_EVENT_NOTIFY_START) )
  {
    v9 = (NTSTATUS *)L"NotifyUILanguageChange API";
    v10 = 0;
    v11 = 54;
    v12 = 0;
    EtwEventWrite(RegHandle, HIDWORD(RegHandle), &MUI_ETW_EVENT_NOTIFY_START, 1, &v9);
  }
  if ( pcwstrNewLanguage )
  {
    v6 = RtlGetUILanguageInfo(((dwFlags & 0x100) != 0 ? 4 : 8) | 0x80, pcwstrNewLanguage, 0, 0, &v15);
    NtStatus = v6;
    if ( dwFlags & 4 )
    {
      if ( v6 != -1073741772 )
      {
LABEL_9:
        NtStatus = -1073741811;
        goto LABEL_18;
      }
    }
    else if ( v6 < 0 )
    {
      goto LABEL_9;
    }
    if ( v15 & 4 && dwFlags & 8 )
      goto LABEL_9;
  }
  NtStatus = Internal_AllowTestSign((int)&v16);
  if ( NtStatus >= 0 )
  {
    NtStatus = Internal_NotifyUILanguageChange(
                 v5,
                 dwFlags,
                 pcwstrNewLanguage,
                 pcwstrPreviousLanguage,
                 dwReserved,
                 RegHandle,
                 v16,
                 (int)pdwStatusRtrn);
    if ( NtStatus >= 0 )
    {
      if ( !(dwFlags & 8)
        || (NtStatus = sub_77E81EEE(dwFlags, pcwstrNewLanguage, dwReserved, RegHandle, v16, (int)pdwStatusRtrn),
            NtStatus >= 0) )
        v14 = 1;
    }
  }
LABEL_18:
  v7 = RtlNtStatusToDosError(NtStatus);
  SetLastError(v7);
  if ( !NtStatus )
  {
LABEL_24:
    if ( RegHandle && EtwEventEnabled(RegHandle, &MUI_ETW_EVENT_NOTIFY_END) )
    {
      v9 = (NTSTATUS *)L"NotifyUILanguageChange API";
      v10 = 0;
      v11 = 54;
      v12 = 0;
      EtwEventWrite(RegHandle, HIDWORD(RegHandle), &MUI_ETW_EVENT_NOTIFY_END, 1, &v9);
    }
    goto LABEL_27;
  }
  if ( pdwStatusRtrn )
    *pdwStatusRtrn = NtStatus;
  if ( RegHandle )
  {
    if ( EtwEventEnabled(RegHandle, &MUI_ETW_EVENT_NOTIFY_ERROR) )
    {
      v9 = &NtStatus;
      v10 = 0;
      v11 = 4;
      v12 = 0;
      EtwEventWrite(RegHandle, HIDWORD(RegHandle), &MUI_ETW_EVENT_NOTIFY_ERROR, 1, &v9);
    }
    goto LABEL_24;
  }
LABEL_27:
  EtwEventUnregister(RegHandle, HIDWORD(RegHandle));
  return v14;
}
// 77DE1348: using guessed type int __stdcall RtlGetUILanguageInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1430: using guessed type int __stdcall EtwEventRegister(_DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1434: using guessed type int __stdcall EtwEventWrite(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77DE1438: using guessed type int __stdcall EtwEventUnregister(_DWORD, _DWORD);
// 77E821FC: using guessed type int MUI_ETW_PROVIDER[5];
// 77E82240: using guessed type wchar_t aNotifyuilang_0[27];

//----- (77E8227B) --------------------------------------------------------
signed int __stdcall GetHebrewSupportedDateRange(int a1, int a2)
{
  signed int result; // eax@1

  *(_DWORD *)(a1 + 8) = 5343;
  *(_DWORD *)(a1 + 12) = 4;
  *(_DWORD *)(a1 + 16) = 7;
  *(_DWORD *)(a1 + 20) = 6;
  result = 1;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = 5999;
  *(_DWORD *)(a2 + 12) = 13;
  *(_DWORD *)(a2 + 16) = 29;
  *(_DWORD *)(a2 + 24) = 23;
  *(_DWORD *)(a2 + 28) = 59;
  *(_DWORD *)(a2 + 32) = 59;
  *(_DWORD *)(a2 + 36) = 9999999;
  return result;
}

//----- (77E822F1) --------------------------------------------------------
signed int __stdcall IsValidHebrewYear(int a1, int a2)
{
  if ( IsValidUmAlQuraEra(a2) )
  {
    if ( (unsigned int)(a1 - 5343) <= 0x290 )
      return 1;
    SetLastError(0x120u);
  }
  return 0;
}

//----- (77E8232B) --------------------------------------------------------
int __stdcall GetHebrewDaysInYearHelper(int a1)
{
  unsigned int v1; // eax@1
  int result; // eax@2

  v1 = *((_BYTE *)&loc_77E5F2DB + 2 * a1);
  if ( v1 >= 4 )
    result = v1 + 379;
  else
    result = v1 + 352;
  return result;
}

//----- (77E82355) --------------------------------------------------------
signed int __stdcall GetHebrewDaysInYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidHebrewYear(a1, a2);
  if ( result )
    result = GetHebrewDaysInYearHelper(a1);
  return result;
}

//----- (77E8237A) --------------------------------------------------------
signed int __stdcall IsHebrewLeapYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidHebrewYear(a1, a2);
  if ( result )
  {
    SetLastError(0);
    result = (7 * a1 + 1) % 0x13u < 7;
  }
  return result;
}

//----- (77E823B3) --------------------------------------------------------
int __stdcall GetHebrewMonthsInYear(int a1, int a2)
{
  int result; // eax@2

  if ( IsValidHebrewYear(a1, a2) )
    result = (IsHebrewLeapYear(a1, a2) != 0) + 12;
  else
    result = 0;
  return result;
}

//----- (77E823E8) --------------------------------------------------------
int __stdcall GetLunarMonthDay(int a1, int a2)
{
  int v2; // eax@3
  int v3; // ecx@3
  int result; // eax@3
  int v5; // ecx@4
  int v6; // ecx@5
  int v7; // ecx@6

  if ( !a2 || (unsigned int)(a1 - 1583) > 0x290 )
    return 0;
  v2 = 2 * (a1 - 1583);
  v3 = (unsigned __int8)HebrewTable[v2];
  *(_DWORD *)(a2 + 16) = v3;
  result = (unsigned __int8)byte_77E61C99[v2];
  if ( !v3 )
  {
    *(_DWORD *)(a2 + 16) = 1;
    goto LABEL_14;
  }
  v5 = v3 - 30;
  if ( !v5 )
  {
    *(_DWORD *)(a2 + 12) = 3;
    return result;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    *(_DWORD *)(a2 + 16) = 2;
    goto LABEL_14;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    *(_DWORD *)(a2 + 16) = 3;
LABEL_14:
    *(_DWORD *)(a2 + 12) = 5;
    return result;
  }
  if ( v7 == 1 )
  {
    *(_DWORD *)(a2 + 12) = 3;
    *(_DWORD *)(a2 + 16) = 29;
  }
  else
  {
    *(_DWORD *)(a2 + 12) = 4;
  }
  return result;
}

//----- (77E82478) --------------------------------------------------------
int __stdcall GetDayDifference(int a1, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5; // edx@1
  unsigned int v6; // esi@1
  int result; // eax@2
  int v8; // edi@4
  int i; // ecx@6
  int v10; // ecx@9

  v5 = a2;
  v6 = a4;
  if ( a2 == a4 )
  {
    result = a3 - a5;
  }
  else
  {
    if ( a4 >= a2 )
    {
      v8 = a3;
    }
    else
    {
      v8 = a5;
      v5 = a4;
      v6 = a2;
      a5 = a3;
    }
    for ( i = (unsigned __int8)*(&LunarMonthLen[14 * a1] + v5) - v8; ; i += (unsigned __int8)*(&LunarMonthLen[14 * a1]
                                                                                             + v5) )
    {
      ++v5;
      if ( v5 >= v6 )
        break;
    }
    v10 = a5 + i;
    if ( a4 >= a2 )
      v10 = -v10;
    result = v10;
  }
  return result;
}

//----- (77E824E6) --------------------------------------------------------
signed int __stdcall HebrewToGregorian(int a1)
{
  int v1; // esi@1
  signed int result; // eax@1
  unsigned int v3; // ecx@2
  int v4; // eax@4
  char v5; // [sp+8h] [bp-50h]@1
  unsigned int v6; // [sp+14h] [bp-44h]@2
  int v7; // [sp+18h] [bp-40h]@3
  int v8; // [sp+30h] [bp-28h]@2
  int v9; // [sp+34h] [bp-24h]@2
  int v10; // [sp+38h] [bp-20h]@2
  int v11; // [sp+3Ch] [bp-1Ch]@2
  int v12; // [sp+40h] [bp-18h]@2
  int v13; // [sp+44h] [bp-14h]@2
  int v14; // [sp+48h] [bp-10h]@2
  int v15; // [sp+4Ch] [bp-Ch]@2
  int v16; // [sp+50h] [bp-8h]@2
  int v17; // [sp+54h] [bp-4h]@2

  v1 = *(_DWORD *)(a1 + 8) - 3760;
  result = GetLunarMonthDay(v1, (int)&v5);
  if ( result )
  {
    v13 = *(_DWORD *)(a1 + 20);
    v14 = *(_DWORD *)(a1 + 24);
    v15 = *(_DWORD *)(a1 + 28);
    v16 = *(_DWORD *)(a1 + 32);
    v17 = *(_DWORD *)(a1 + 36);
    v3 = *(_DWORD *)(a1 + 12);
    v9 = 1;
    v8 = 1;
    v10 = v1;
    v12 = 1;
    v11 = 1;
    if ( v3 == v6 && *(_DWORD *)(a1 + 16) == v7
      || (v4 = GetDayDifference(result, v3, *(_DWORD *)(a1 + 16), v6, v7), AdjustGregorianDays(&v8, v4)) )
    {
      qmemcpy((void *)a1, &v8, 0x28u);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 77E3EC1C: using guessed type _DWORD __stdcall AdjustGregorianDays(_DWORD, _DWORD);

//----- (77E82581) --------------------------------------------------------
signed int __stdcall GregorianToHebrew(int a1)
{
  int v1; // ebx@1
  unsigned int v2; // esi@2
  int v3; // ebx@4
  int v4; // eax@4
  unsigned int v5; // esi@4
  int v6; // ebx@6
  int v7; // ecx@6
  unsigned int v8; // edx@7
  int v9; // esi@8
  int v10; // eax@11
  signed int result; // eax@15
  int v12; // [sp+8h] [bp-2Ch]@2
  int v13; // [sp+Ch] [bp-28h]@2
  unsigned int v14; // [sp+10h] [bp-24h]@2
  int v15; // [sp+14h] [bp-20h]@4
  int v16; // [sp+18h] [bp-1Ch]@4
  int v17; // [sp+30h] [bp-4h]@2

  v1 = GetAbsoluteDateFromGregorian(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  if ( (unsigned int)(v1 - 577813) > 0x3A8FE )
  {
    SetLastError(0x120u);
    result = 0;
  }
  else
  {
    qmemcpy(&v12, (const void *)a1, 0x28u);
    v2 = *(_DWORD *)(a1 + 8);
    v14 = v2 + 3760;
    v12 = 8;
    v13 = 1;
    v17 = GetLunarMonthDay(v2, (int)&v12);
    if ( *(_DWORD *)(a1 + 12) != 1 || *(_DWORD *)(a1 + 16) != 1 )
    {
      v3 = v1 - GetAbsoluteDateFromGregorian(v2, 1, 1);
      v4 = 14 * v17;
      v5 = (unsigned __int8)*(&LunarMonthLen[14 * v17] + v15);
      if ( v16 + v3 > v5 )
      {
        v6 = v16 - v5 + v3;
        v7 = v15++ + 1;
        v16 = 1;
        if ( (unsigned int)v6 > 1 )
        {
          v8 = (unsigned __int8)*(&LunarMonthLen[v4] + v7);
          if ( v6 > v8 )
          {
            v9 = v17;
            do
            {
              v6 -= v8;
              ++v7;
              if ( (unsigned int)v7 > 0xD || !*(&LunarMonthLen[v4] + v7) )
              {
                v10 = *(_DWORD *)(a1 + 8);
                ++v14;
                v9 = *((_BYTE *)&loc_77E6103C + 2 * v10 + 1);
                v7 = 1;
              }
              v4 = 14 * v9;
              v8 = (unsigned __int8)*(&LunarMonthLen[14 * v9] + v7);
            }
            while ( v6 > v8 );
            v15 = v7;
          }
          v16 = v6;
        }
      }
      else
      {
        v16 += v3;
      }
    }
    qmemcpy((void *)a1, &v12, 0x28u);
    result = 1;
  }
  return result;
}

//----- (77E826A1) --------------------------------------------------------
signed int __stdcall IsValidHebrewMonth(unsigned int a1, int a2, int a3)
{
  int v3; // eax@2

  if ( IsValidHebrewYear(a2, a3) )
  {
    v3 = GetHebrewMonthsInYear(a2, a3);
    if ( a1 >= 1 && a1 <= v3 )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E826E2) --------------------------------------------------------
signed int __stdcall GetHebrewDaysInMonth(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@1

  result = IsValidHebrewMonth(a1, a2, a3);
  if ( result )
    result = (unsigned __int8)*(&LunarMonthLen[14 * *((_BYTE *)&loc_77E5F2DB + 2 * a2)] + a1);
  return result;
}

//----- (77E8271B) --------------------------------------------------------
int __stdcall IsHebrewLeapMonth(unsigned int a1, int a2, int a3)
{
  int result; // eax@4

  result = 0;
  if ( IsValidHebrewMonth(a1, a2, a3) )
  {
    SetLastError(0);
    if ( IsHebrewLeapYear(a2, a3) )
    {
      if ( a1 == 7 )
        result = 1;
    }
  }
  return result;
}

//----- (77E8275E) --------------------------------------------------------
int __stdcall HebrewToAbsolute(const void *a1)
{
  int result; // eax@2
  char v2; // [sp+8h] [bp-28h]@1
  unsigned int v3; // [sp+10h] [bp-20h]@2
  int v4; // [sp+14h] [bp-1Ch]@2
  int v5; // [sp+18h] [bp-18h]@2

  qmemcpy(&v2, a1, 0x28u);
  if ( HebrewToGregorian((int)&v2) )
    result = GetAbsoluteDateFromGregorian(v3, v4, v5);
  else
    result = 0;
  return result;
}

//----- (77E8279D) --------------------------------------------------------
signed int __stdcall AbsoluteToHebrew(signed int a1, int a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-28h]@1
  int v4; // [sp+8h] [bp-20h]@3
  int v5; // [sp+Ch] [bp-1Ch]@3
  int v6; // [sp+10h] [bp-18h]@3
  int v7; // [sp+14h] [bp-14h]@3

  if ( GetGregorianFromAbsoluteDate(a1, &v3) && GregorianToHebrew((int)&v3) )
  {
    *(_DWORD *)(a2 + 8) = v4;
    *(_DWORD *)(a2 + 12) = v5;
    *(_DWORD *)(a2 + 16) = v6;
    *(_DWORD *)(a2 + 20) = v7;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E827ED) --------------------------------------------------------
BOOL __stdcall ConvertHebrewDateTimeToSystemTime(const void *a1, int a2)
{
  char v3; // [sp+8h] [bp-28h]@1

  qmemcpy(&v3, a1, 0x28u);
  return HebrewToGregorian((int)&v3) && ConvertGregorianDateTimeToSystemTime((int)&v3, a2);
}

//----- (77E82831) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToHebrewDateTime(int a1, void *a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-28h]@1

  if ( ConvertSystemTimeToGregorianDateTime(a1, 1, &v3) && GregorianToHebrew((int)&v3) )
  {
    qmemcpy(a2, &v3, 0x28u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E82877) --------------------------------------------------------
signed int __stdcall IsValidHebrewDay(unsigned int a1, unsigned int a2, int a3, int a4)
{
  signed int v4; // eax@1

  v4 = GetHebrewDaysInMonth(a2, a3, a4);
  if ( v4 )
  {
    if ( a1 >= 1 && a1 <= v4 )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E828B0) --------------------------------------------------------
unsigned int __stdcall GetHebrewDayOfWeekHelper(const void *a1)
{
  return (HebrewToAbsolute(a1) + 1) % 7u;
}

//----- (77E828D0) --------------------------------------------------------
signed int __stdcall IsValidHebrewDateTime(int a1, int a2, int a3)
{
  if ( *(_DWORD *)a1 != 8 )
  {
LABEL_10:
    SetLastError(0x57u);
    return 0;
  }
  if ( IsValidHebrewDay(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4)) )
  {
    if ( *(_DWORD *)(a1 + 24) <= 0x17u
      && *(_DWORD *)(a1 + 28) <= 0x3Bu
      && *(_DWORD *)(a1 + 32) <= 0x3Bu
      && *(_DWORD *)(a1 + 36) <= 0x98967Fu
      && (!a3 || *(_DWORD *)(a1 + 20) == GetHebrewDayOfWeekHelper((const void *)a1)) )
      return 1;
    goto LABEL_10;
  }
  return 0;
}

//----- (77E82937) --------------------------------------------------------
int __stdcall GetHebrewDayOfYear(int a1)
{
  const void *v1; // esi@1
  int result; // eax@2
  int v3; // eax@4
  char v4; // [sp+8h] [bp-28h]@4
  int v5; // [sp+14h] [bp-1Ch]@4
  int v6; // [sp+18h] [bp-18h]@4
  int v7; // [sp+38h] [bp+8h]@3

  v1 = (const void *)a1;
  if ( IsValidHebrewDateTime(a1, 0, 1)
    && (v7 = HebrewToAbsolute((const void *)a1)) != 0
    && (qmemcpy(&v4, v1, 0x28u), v5 = 1, v6 = 1, (v3 = HebrewToAbsolute(&v4)) != 0) )
    result = v7 - v3 + 1;
  else
    result = 0;
  return result;
}

//----- (77E82995) --------------------------------------------------------
signed int __stdcall UpdateHebrewDayOfWeek(int a1)
{
  signed int result; // eax@1

  result = IsValidHebrewDateTime(a1, 0, 0);
  if ( result )
  {
    *(_DWORD *)(a1 + 20) = GetHebrewDayOfWeekHelper((const void *)a1);
    result = 1;
  }
  return result;
}

//----- (77E829C2) --------------------------------------------------------
int __stdcall IsHebrewLeapDay(unsigned int a1, unsigned int a2, int a3, int a4)
{
  int result; // eax@3

  result = 0;
  if ( IsValidHebrewDay(a1, a2, a3, a4) )
  {
    SetLastError(0);
    if ( IsHebrewLeapMonth(a2, a3, a4) || IsHebrewLeapYear(a3, a4) && a2 == 6 && a1 == 30 )
      result = 1;
  }
  return result;
}

//----- (77E82A20) --------------------------------------------------------
signed int __stdcall AdjustHebrewDays(int a1, int a2)
{
  int v2; // eax@1
  signed int v3; // eax@2

  v2 = HebrewToAbsolute((const void *)a1);
  if ( v2 )
  {
    v3 = a2 + v2;
    if ( (unsigned int)(v3 - 577813) <= 0x3A8FE )
      return AbsoluteToHebrew(v3, a1);
    SetLastError(0x120u);
  }
  return 0;
}

//----- (77E82A62) --------------------------------------------------------
int __stdcall GetHebrewDifferenceInDays(const void *a1, const void *a2)
{
  int v2; // esi@1

  v2 = HebrewToAbsolute(a1);
  return HebrewToAbsolute(a2) - v2;
}

//----- (77E82A86) --------------------------------------------------------
signed int __stdcall AdjustHebrewYears(int a1, int a2)
{
  int v2; // esi@1
  unsigned int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@2
  signed int v6; // eax@4
  signed int result; // eax@6
  signed int v8; // [sp+14h] [bp+8h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 12);
  v4 = a2 + *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 16);
  if ( (unsigned int)(v4 - 5343) > 0x290 )
  {
    SetLastError(0x120u);
    result = 0;
  }
  else
  {
    v5 = GetHebrewMonthsInYear(v4, *(_DWORD *)(v2 + 4));
    if ( (signed int)v3 > v5 )
      v3 = v5;
    v6 = GetHebrewDaysInMonth(v3, v4, *(_DWORD *)(v2 + 4));
    if ( v8 > v6 )
      v8 = v6;
    *(_DWORD *)(v2 + 16) = v8;
    *(_DWORD *)(v2 + 12) = v3;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 20) = GetHebrewDayOfWeekHelper((const void *)v2);
    result = 1;
  }
  return result;
}

//----- (77E82B00) --------------------------------------------------------
signed int __stdcall AdjustHebrewMonths(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  unsigned int v4; // edi@3
  int v5; // eax@3
  int v6; // edi@9
  int v8; // eax@15
  signed int v9; // eax@17
  signed int v10; // [sp+14h] [bp+8h]@1
  int v11; // [sp+18h] [bp+Ch]@4
  int v12; // [sp+18h] [bp+Ch]@9

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 16);
  if ( (unsigned int)(v3 - 5343) > 0x290 )
    goto LABEL_10;
  if ( a2 < 0 )
  {
    v4 = a2 + *(_DWORD *)(v2 + 12);
    if ( (signed int)v4 > 0 )
      goto LABEL_17;
    --v3;
    v12 = -v4;
    v6 = v3 - 5343;
    if ( (unsigned int)(v3 - 5343) <= 0x290 )
    {
      while ( 1 )
      {
        v8 = GetHebrewMonthsInYear(v3, *(_DWORD *)(v2 + 4));
        if ( v12 <= v8 )
          break;
        --v3;
        --v6;
        if ( (unsigned int)v6 > 0x290 )
          goto LABEL_10;
        v12 -= v8;
      }
      v4 = GetHebrewMonthsInYear(v3, *(_DWORD *)(v2 + 4)) - v12;
      goto LABEL_17;
    }
LABEL_10:
    SetLastError(0x120u);
    return 0;
  }
  v4 = a2 + *(_DWORD *)(v2 + 12);
  v5 = GetHebrewMonthsInYear(v3, *(_DWORD *)(v2 + 4));
  if ( (signed int)v4 > v5 )
  {
    v11 = v3 - 5343;
    do
    {
      ++v3;
      ++v11;
      if ( (unsigned int)v11 > 0x290 )
        goto LABEL_10;
      v4 -= v5;
      v5 = GetHebrewMonthsInYear(v3, *(_DWORD *)(v2 + 4));
    }
    while ( (signed int)v4 > v5 );
  }
LABEL_17:
  v9 = GetHebrewDaysInMonth(v4, v3, *(_DWORD *)(v2 + 4));
  if ( !v9 )
    return 0;
  if ( v10 > v9 )
    v10 = v9;
  *(_DWORD *)(v2 + 16) = v10;
  *(_DWORD *)(v2 + 12) = v4;
  *(_DWORD *)(v2 + 8) = v3;
  *(_DWORD *)(v2 + 20) = GetHebrewDayOfWeekHelper((const void *)v2);
  return 1;
}

//----- (77E82BEE) --------------------------------------------------------
int __stdcall IsGregorianLeapMonth(int a1, int a2, int a3)
{
  if ( IsValidGregorianYear(a2, a3) )
  {
    if ( (unsigned int)(a1 - 1) > 0xB )
      SetLastError(0x57u);
    else
      SetLastError(0);
  }
  return 0;
}

//----- (77E82C21) --------------------------------------------------------
signed int __stdcall IsGregorianLeapDay(unsigned int a1, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  signed int result; // eax@1
  int v6; // edi@3
  int *v7; // eax@4

  v4 = 0;
  result = IsValidGregorianYear(a3, a4);
  if ( result )
  {
    if ( (unsigned int)(a2 - 1) <= 0xB
      && ((v6 = IsGregorianLeapYear(a3, a4)) == 0 ? (v7 = &GregorianDaysToMonth365[a2]) : (v7 = &GregorianDaysToMonth366[a2]),
          a1 <= *v7 - *(v7 - 1)) )
    {
      SetLastError(0);
      if ( v6 && a2 == 2 && a1 == 29 )
        v4 = 1;
      result = v4;
    }
    else
    {
      SetLastError(0x57u);
      result = 0;
    }
  }
  return result;
}
// 77E3E524: using guessed type int GregorianDaysToMonth365[];
// 77E3E854: using guessed type int GregorianDaysToMonth366[];

//----- (77E82CA1) --------------------------------------------------------
signed int __stdcall ConvertGregorianDateTimeToSystemTime(int a1, int a2)
{
  signed int result; // eax@2

  if ( *(_DWORD *)(a1 + 8) >= 0x641u )
  {
    *(_WORD *)a2 = *(_WORD *)(a1 + 8);
    *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 12);
    *(_WORD *)(a2 + 6) = *(_WORD *)(a1 + 16);
    *(_WORD *)(a2 + 8) = *(_WORD *)(a1 + 24);
    *(_WORD *)(a2 + 10) = *(_WORD *)(a1 + 28);
    *(_WORD *)(a2 + 12) = *(_WORD *)(a1 + 32);
    *(_WORD *)(a2 + 14) = *(_DWORD *)(a1 + 36) / 0x2710u;
    *(_WORD *)(a2 + 4) = *(_WORD *)(a1 + 20);
    result = 1;
  }
  else
  {
    SetLastError(0x120u);
    result = 0;
  }
  return result;
}

//----- (77E82D1A) --------------------------------------------------------
signed int __stdcall GetGregorianWeekOfYearFullDays(int a1, int a2, signed int a3, signed int a4)
{
  signed int v4; // esi@1
  int v5; // edi@1
  unsigned int v6; // edx@1
  int v7; // esi@4
  signed int v8; // eax@5
  signed int result; // eax@6
  unsigned int v10; // esi@7
  void *v11; // ecx@7
  signed int v12; // esi@8
  unsigned int v13; // edx@10
  char v14; // [sp+Ch] [bp-28h]@14

  v4 = GetCalendarDayOfYear(a1) - 1;
  UpdateCalendarDayOfWeek(a1);
  v5 = *(_DWORD *)(a1 + 20) - v4 % 7;
  v6 = (a2 - v5 + 14) % 7u;
  if ( v6 && (signed int)v6 >= a3 )
    v6 -= 7;
  v7 = v4 - v6;
  if ( v7 >= 0 )
  {
    v8 = v7;
    return v8 / 7 + 1;
  }
  v10 = *(_DWORD *)(a1 + 8);
  if ( v10 > GetMinSupportedCalendarYear(*(_DWORD *)a1) )
    v12 = GetCalendarDaysInYear(v11, *(_DWORD *)a1, v10 - 1, *(_DWORD *)(a1 + 4));
  else
    v12 = a4;
  v13 = (v12 % 7 - v5 + a2 + 14) % 7u;
  if ( v13 && (signed int)v13 >= a3 )
    v13 -= 7;
  v8 = v12 - v13;
  if ( ((v12 - v13) & 0x80000000) == 0 )
    return v8 / 7 + 1;
  CopyCalDateTime(&v14, (const void *)a1);
  result = AdjustCalendarDate((int)&v14, 4, -1 - v12);
  if ( result )
    result = GetGregorianWeekOfYearFullDays(&v14, a2, a3, a4);
  return result;
}

//----- (77E82DEC) --------------------------------------------------------
int __stdcall GetGregorianDayOfYear(int a1)
{
  unsigned int v1; // esi@1
  int v2; // edi@1

  v1 = *(_DWORD *)(a1 + 8);
  v2 = GetAbsoluteDateFromGregorian(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  return 1 - GetAbsoluteDateFromGregorian(v1, 1, 1) + v2;
}

//----- (77E82E25) --------------------------------------------------------
signed int __stdcall GetGregorianDaysInYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidGregorianYear(a1, a2);
  if ( result )
    result = (IsGregorianLeapYear(a1, a2) != 0) + 365;
  return result;
}

//----- (77E82E58) --------------------------------------------------------
signed int __stdcall GetUmAlQuraSupportedDateRange(int a1, int a2)
{
  signed int result; // eax@1

  *(_DWORD *)(a1 + 8) = 1318;
  result = 1;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 20) = 1;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = 1450;
  *(_DWORD *)(a2 + 12) = 12;
  *(_DWORD *)(a2 + 16) = 29;
  *(_DWORD *)(a2 + 24) = 23;
  *(_DWORD *)(a2 + 28) = 59;
  *(_DWORD *)(a2 + 32) = 59;
  *(_DWORD *)(a2 + 36) = 9999999;
  return result;
}

//----- (77E82EC2) --------------------------------------------------------
signed int __stdcall IsValidUmAlQuraEra(int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( a1 != 1 )
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}

//----- (77E82EE1) --------------------------------------------------------
signed int __stdcall IsValidUmAlQuraYear(int a1, int a2)
{
  if ( IsValidUmAlQuraEra(a2) )
  {
    if ( (unsigned int)(a1 - 1318) <= 0x84 )
      return 1;
    SetLastError(0x120u);
  }
  return 0;
}

//----- (77E82F1B) --------------------------------------------------------
signed int __stdcall IsValidUmAlQuraMonth(int a1, int a2, int a3)
{
  if ( IsValidUmAlQuraYear(a2, a3) )
  {
    if ( (unsigned int)(a1 - 1) <= 0xB )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E82F4F) --------------------------------------------------------
signed int __stdcall GetUmAlQuraDaysInMonth(int a1, int a2, int a3)
{
  signed int result; // eax@1

  result = IsValidUmAlQuraMonth(a1, a2, a3);
  if ( result )
    result = ((*(_WORD *)((char *)&loc_77E5F8F5 + 8 * a2 + 3) & (1 << (a1 - 1))) != 0) + 29;
  return result;
}

//----- (77E82F90) --------------------------------------------------------
int __stdcall GetUmAlQuraDaysInYearHelper(int a1)
{
  __int16 v1; // cx@1
  int result; // eax@1
  signed int v3; // edx@1
  int v4; // [sp+8h] [bp+8h]@1

  v1 = *(_WORD *)((char *)&loc_77E5F8F5 + 8 * a1 + 3);
  result = 0;
  v4 = *(_WORD *)((char *)&loc_77E5F8F5 + 8 * a1 + 3);
  v3 = 12;
  while ( 1 )
  {
    LOWORD(v4) = (unsigned __int16)v4 >> 1;
    --v3;
    result += (v1 & 1) + 29;
    if ( !v3 )
      break;
    LOBYTE(v1) = v4;
  }
  return result;
}

//----- (77E82FC4) --------------------------------------------------------
signed int __stdcall GetUmAlQuraDaysInYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidUmAlQuraYear(a1, a2);
  if ( result )
    result = GetUmAlQuraDaysInYearHelper(a1);
  return result;
}

//----- (77E82FE9) --------------------------------------------------------
signed int __stdcall IsUmAlQuraLeapYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidUmAlQuraYear(a1, a2);
  if ( result )
  {
    SetLastError(0);
    result = GetUmAlQuraDaysInYearHelper(a1) == 355;
  }
  return result;
}

//----- (77E8301F) --------------------------------------------------------
int __stdcall IsUmAlQuraLeapMonth(int a1, int a2, int a3)
{
  if ( IsValidUmAlQuraMonth(a1, a2, a3) )
    SetLastError(0);
  return 0;
}

//----- (77E83048) --------------------------------------------------------
signed int __stdcall GregorianToUmAlQura(int a1)
{
  signed int v1; // eax@1
  int v2; // ebx@2
  void *v3; // edi@4
  int v4; // eax@4
  int v5; // ebx@6
  bool v6; // cf@8
  bool v7; // zf@8
  int v8; // ecx@12
  int v10; // [sp+Ch] [bp-28h]@3
  int v11; // [sp+10h] [bp-24h]@12
  int v12; // [sp+14h] [bp-20h]@4
  int v13; // [sp+18h] [bp-1Ch]@4
  int v14; // [sp+1Ch] [bp-18h]@4
  int v15; // [sp+3Ch] [bp+8h]@12

  v1 = GetAbsoluteDateFromGregorian(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16)) - 693714;
  if ( (unsigned int)v1 > 0xB81A )
    goto LABEL_16;
  v2 = v1 / 355;
  if ( (unsigned int)(v1 / 355) > 0x85 )
    goto LABEL_16;
  qmemcpy(&v10, (const void *)a1, 0x28u);
  do
  {
    v3 = (void *)a1;
    v12 = (unsigned __int16)word_77E6222A[4 * v2];
    v13 = (unsigned __int16)word_77E6222C[4 * v2];
    v14 = (unsigned __int16)word_77E6222E[4 * v2];
    v4 = GetGregorianDifferenceInDays((int)&v10, a1);
    ++v2;
  }
  while ( v4 > 0 && v2 < 134 );
  v5 = v2 - 1;
  if ( !v4 )
    goto LABEL_10;
  --v5;
  if ( v5 < 0 )
  {
LABEL_16:
    SetLastError(0x120u);
    return 0;
  }
  v6 = (unsigned int)v5 < 0x85;
  v7 = v5 == 133;
  if ( v5 <= 133 )
  {
    v12 = (unsigned __int16)word_77E6222A[4 * v5];
    v13 = (unsigned __int16)word_77E6222C[4 * v5];
    v14 = (unsigned __int16)word_77E6222E[4 * v5];
    v4 = GetGregorianDifferenceInDays((int)&v10, a1);
LABEL_10:
    v6 = (unsigned int)v5 < 0x85;
    v7 = v5 == 133;
  }
  if ( !v6 && !v7 )
    goto LABEL_16;
  v12 = v5 + 1318;
  v15 = (unsigned __int16)YearsInfo[4 * v5];
  v10 = 23;
  v11 = 1;
  v13 = 1;
  v8 = (v15 & 1) + 29;
  while ( v4 >= v8 )
  {
    LOWORD(v15) = (unsigned __int16)v15 >> 1;
    v4 -= v8;
    v8 = (v15 & 1) + 29;
    ++v13;
  }
  v14 = v4 + 1;
  qmemcpy(v3, &v10, 0x28u);
  return 1;
}
// 77E62228: using guessed type __int16 YearsInfo[];
// 77E6222A: using guessed type __int16 word_77E6222A[];
// 77E6222C: using guessed type __int16 word_77E6222C[];
// 77E6222E: using guessed type __int16 word_77E6222E[];

//----- (77E8317C) --------------------------------------------------------
signed int __stdcall UmAlQuraToGregorian(int a1)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // edx@2
  signed int result; // eax@6
  int v8; // [sp+8h] [bp-28h]@1
  int v9; // [sp+Ch] [bp-24h]@1
  int v10; // [sp+10h] [bp-20h]@1
  int v11; // [sp+14h] [bp-1Ch]@1
  int v12; // [sp+18h] [bp-18h]@1
  int v13; // [sp+1Ch] [bp-14h]@1
  int v14; // [sp+20h] [bp-10h]@1
  int v15; // [sp+24h] [bp-Ch]@1
  int v16; // [sp+28h] [bp-8h]@1
  int v17; // [sp+2Ch] [bp-4h]@1
  int v18; // [sp+38h] [bp+8h]@1

  v1 = a1;
  v2 = 4 * (*(_DWORD *)(a1 + 8) - 1318);
  v10 = (unsigned __int16)word_77E6222A[v2];
  v11 = (unsigned __int16)word_77E6222C[v2];
  v3 = (unsigned __int16)word_77E6222E[v2];
  v4 = (unsigned __int16)YearsInfo[v2];
  v12 = v3;
  v13 = *(_DWORD *)(a1 + 20);
  v14 = *(_DWORD *)(a1 + 24);
  v15 = *(_DWORD *)(a1 + 28);
  v16 = *(_DWORD *)(a1 + 32);
  v17 = *(_DWORD *)(a1 + 36);
  v5 = *(_DWORD *)(a1 + 16) - 1;
  v8 = 1;
  v9 = 1;
  v18 = v4;
  if ( *(_DWORD *)(v1 + 12) > 1u )
  {
    v6 = *(_DWORD *)(v1 + 12) - 1;
    while ( 1 )
    {
      LOWORD(v18) = (unsigned __int16)v18 >> 1;
      --v6;
      v5 += (v4 & 1) + 29;
      if ( !v6 )
        break;
      LOBYTE(v4) = v18;
    }
  }
  if ( AdjustGregorianDays(&v8, v5) )
  {
    qmemcpy((void *)v1, &v8, 0x28u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77E3EC1C: using guessed type _DWORD __stdcall AdjustGregorianDays(_DWORD, _DWORD);
// 77E62228: using guessed type __int16 YearsInfo[];
// 77E6222A: using guessed type __int16 word_77E6222A[];
// 77E6222C: using guessed type __int16 word_77E6222C[];
// 77E6222E: using guessed type __int16 word_77E6222E[];

//----- (77E8322B) --------------------------------------------------------
BOOL __stdcall ConvertUmAlQuraDateTimeToSystemTime(const void *a1, int a2)
{
  char v3; // [sp+8h] [bp-28h]@1

  qmemcpy(&v3, a1, 0x28u);
  return UmAlQuraToGregorian((int)&v3) && ConvertGregorianDateTimeToSystemTime((int)&v3, a2);
}

//----- (77E8326F) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToUmAlQuraDateTime(int a1, void *a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-28h]@1

  if ( ConvertSystemTimeToGregorianDateTime(a1, 1, &v3) && GregorianToUmAlQura((int)&v3) )
  {
    qmemcpy(a2, &v3, 0x28u);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E832B5) --------------------------------------------------------
int __stdcall GetUmAlQuraMonthsInYear(int a1, int a2)
{
  return IsValidUmAlQuraYear(a1, a2) != 0 ? 0xC : 0;
}

//----- (77E832D5) --------------------------------------------------------
signed int __stdcall IsValidUmAlQuraDay(unsigned int a1, int a2, int a3, int a4)
{
  signed int v4; // eax@1

  v4 = GetUmAlQuraDaysInMonth(a2, a3, a4);
  if ( v4 )
  {
    if ( a1 >= 1 && a1 <= v4 )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E8330E) --------------------------------------------------------
int __stdcall IsUmAlQuraLeapDay(unsigned int a1, int a2, int a3, int a4)
{
  if ( IsValidUmAlQuraDay(a1, a2, a3, a4) )
    SetLastError(0);
  return 0;
}

//----- (77E8333A) --------------------------------------------------------
signed int __stdcall UmAlQuraToAbsolute(const void *a1)
{
  signed int result; // eax@1
  char v2; // [sp+8h] [bp-28h]@1
  unsigned int v3; // [sp+10h] [bp-20h]@2
  int v4; // [sp+14h] [bp-1Ch]@2
  int v5; // [sp+18h] [bp-18h]@2

  qmemcpy(&v2, a1, 0x28u);
  result = UmAlQuraToGregorian((int)&v2);
  if ( result )
    result = GetAbsoluteDateFromGregorian(v3, v4, v5);
  return result;
}

//----- (77E83375) --------------------------------------------------------
signed int __stdcall AbsoluteToUmAlQura(signed int a1, int a2)
{
  signed int result; // eax@3
  char v3; // [sp+0h] [bp-28h]@1
  int v4; // [sp+8h] [bp-20h]@3
  int v5; // [sp+Ch] [bp-1Ch]@3
  int v6; // [sp+10h] [bp-18h]@3
  int v7; // [sp+14h] [bp-14h]@3

  if ( GetGregorianFromAbsoluteDate(a1, &v3) && GregorianToUmAlQura((int)&v3) )
  {
    *(_DWORD *)(a2 + 8) = v4;
    *(_DWORD *)(a2 + 12) = v5;
    *(_DWORD *)(a2 + 16) = v6;
    *(_DWORD *)(a2 + 20) = v7;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E833C5) --------------------------------------------------------
unsigned int __stdcall GetUmAlQuraDayOfWeekHelper(const void *a1)
{
  return (UmAlQuraToAbsolute(a1) + 1) % 7u;
}

//----- (77E833E5) --------------------------------------------------------
signed int __stdcall IsValidUmAlQuraDateTime(int a1, int a2, int a3)
{
  if ( *(_DWORD *)a1 != 23 )
  {
LABEL_10:
    SetLastError(0x57u);
    return 0;
  }
  if ( IsValidUmAlQuraDay(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4)) )
  {
    if ( *(_DWORD *)(a1 + 24) <= 0x17u
      && *(_DWORD *)(a1 + 28) <= 0x3Bu
      && *(_DWORD *)(a1 + 32) <= 0x3Bu
      && *(_DWORD *)(a1 + 36) <= 0x98967Fu
      && (!a3 || *(_DWORD *)(a1 + 20) == GetUmAlQuraDayOfWeekHelper((const void *)a1)) )
      return 1;
    goto LABEL_10;
  }
  return 0;
}

//----- (77E8344C) --------------------------------------------------------
signed int __stdcall UpdateUmAlQuraDayOfWeek(int a1)
{
  signed int result; // eax@1

  result = IsValidUmAlQuraDateTime(a1, 0, 0);
  if ( result )
  {
    *(_DWORD *)(a1 + 20) = GetUmAlQuraDayOfWeekHelper((const void *)a1);
    result = 1;
  }
  return result;
}

//----- (77E83479) --------------------------------------------------------
signed int __stdcall AdjustUmAlQuraDays(int a1, int a2)
{
  signed int v2; // eax@1
  signed int v3; // eax@2

  v2 = UmAlQuraToAbsolute((const void *)a1);
  if ( v2 )
  {
    v3 = a2 + v2;
    if ( (unsigned int)(v3 - 693714) <= 0xB81A )
      return AbsoluteToUmAlQura(v3, a1);
    SetLastError(0x120u);
  }
  return 0;
}

//----- (77E834BB) --------------------------------------------------------
int __stdcall GetUmAlQuraDifferenceInDays(const void *a1, const void *a2)
{
  signed int v2; // esi@1

  v2 = UmAlQuraToAbsolute(a1);
  return UmAlQuraToAbsolute(a2) - v2;
}

//----- (77E834DF) --------------------------------------------------------
signed int __stdcall AdjustUmAlQuraMonths(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@1
  signed int v5; // ecx@1
  int v6; // ebx@2
  int v7; // edi@2
  signed int v8; // eax@6
  signed int result; // eax@8
  unsigned int v10; // [sp+14h] [bp+8h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(v2 + 12);
  v5 = a2 + v4 - 1;
  if ( v5 < 0 )
  {
    v6 = (a2 + v4 - 12) / 12 + v3;
    v7 = (a2 + v4) % 12 + 12;
  }
  else
  {
    v6 = v5 / 12 + v3;
    v7 = v5 % 12 + 1;
  }
  if ( (unsigned int)(v6 - 1318) > 0x84 )
  {
    SetLastError(0x120u);
    result = 0;
  }
  else
  {
    if ( v10 > 0x1D )
    {
      v8 = GetUmAlQuraDaysInMonth(v7, v6, *(_DWORD *)(v2 + 4));
      if ( v10 > v8 )
        v10 = v8;
    }
    *(_DWORD *)(v2 + 16) = v10;
    *(_DWORD *)(v2 + 12) = v7;
    *(_DWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 20) = GetUmAlQuraDayOfWeekHelper((const void *)v2);
    result = 1;
  }
  return result;
}

//----- (77E8357D) --------------------------------------------------------
int __stdcall GetUmAlQuraDayOfYear(int a1)
{
  const void *v1; // esi@1
  int result; // eax@2
  signed int v3; // eax@4
  char v4; // [sp+8h] [bp-28h]@4
  int v5; // [sp+14h] [bp-1Ch]@4
  int v6; // [sp+18h] [bp-18h]@4
  signed int v7; // [sp+38h] [bp+8h]@3

  v1 = (const void *)a1;
  if ( IsValidUmAlQuraDateTime(a1, 0, 1)
    && (v7 = UmAlQuraToAbsolute((const void *)a1)) != 0
    && (qmemcpy(&v4, v1, 0x28u), v5 = 1, v6 = 1, UpdateUmAlQuraDayOfWeek((int)&v4), (v3 = UmAlQuraToAbsolute(&v4)) != 0) )
    result = v7 - v3 + 1;
  else
    result = 0;
  return result;
}

//----- (77E835E4) --------------------------------------------------------
signed int __stdcall AdjustUmAlQuraYears(int a1, int a2)
{
  return AdjustUmAlQuraMonths(a1, 12 * a2);
}

//----- (77E83601) --------------------------------------------------------
signed __int16 __stdcall GetMaxEras(int a1)
{
  int v1; // esi@2
  int v2; // eax@3
  signed __int16 result; // ax@3

  if ( a1 == 3 && (v1 = GetCalendar(0, 3)) != 0 )
  {
    v2 = KernelBaseGetGlobalData();
    result = *(_WORD *)GetPtrCalDataArray(3, *(_DWORD *)(v2 + 116), *(_DWORD *)(v1 + 20));
  }
  else
  {
    result = 4;
  }
  return result;
}
// 77E2ADCF: using guessed type int __stdcall GetCalendar(_DWORD, _DWORD);
// 77E8B8C4: using guessed type int __stdcall GetPtrCalDataArray(_DWORD, _DWORD, _DWORD);

//----- (77E83641) --------------------------------------------------------
signed int __stdcall GetGregBasedSupportedDateRange(int a1, int a2, int a3)
{
  if ( a1 == 3 )
  {
    *(_DWORD *)(a2 + 4) = 1;
    *(_DWORD *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 12) = 9;
    *(_DWORD *)(a2 + 16) = 8;
    *(_DWORD *)(a2 + 20) = 2;
    *(_DWORD *)(a3 + 4) = (unsigned __int16)GetMaxEras(3);
    *(_DWORD *)(a3 + 8) = 8011;
    goto LABEL_9;
  }
  if ( a1 == 4 )
  {
    *(_DWORD *)(a2 + 4) = 1;
    *(_DWORD *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 12) = 1;
    *(_DWORD *)(a2 + 16) = 1;
    *(_DWORD *)(a2 + 20) = 1;
    *(_DWORD *)(a3 + 4) = 1;
    *(_DWORD *)(a3 + 8) = 8088;
    goto LABEL_9;
  }
  if ( a1 == 5 )
  {
    *(_DWORD *)(a2 + 4) = 1;
    *(_DWORD *)(a2 + 8) = 2334;
    *(_DWORD *)(a2 + 12) = 1;
    *(_DWORD *)(a2 + 16) = 1;
    *(_DWORD *)(a2 + 20) = 1;
    *(_DWORD *)(a3 + 4) = 1;
    *(_DWORD *)(a3 + 8) = 12332;
    goto LABEL_9;
  }
  if ( a1 == 7 )
  {
    *(_DWORD *)(a2 + 4) = 1;
    *(_DWORD *)(a2 + 8) = 544;
    *(_DWORD *)(a2 + 12) = 1;
    *(_DWORD *)(a2 + 16) = 1;
    *(_DWORD *)(a2 + 20) = 1;
    *(_DWORD *)(a3 + 4) = 1;
    *(_DWORD *)(a3 + 8) = 10542;
LABEL_9:
    *(_DWORD *)(a3 + 20) = 5;
    *(_DWORD *)(a3 + 16) = 31;
    *(_DWORD *)(a3 + 12) = 12;
  }
  *(_DWORD *)(a3 + 28) = 59;
  *(_DWORD *)(a3 + 32) = 59;
  *(_DWORD *)(a3 + 24) = 23;
  *(_DWORD *)(a3 + 36) = 9999999;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  return 1;
}

//----- (77E83738) --------------------------------------------------------
int __stdcall GetEraOffsets(int a1, int a2, unsigned int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // edi@2
  unsigned int v8; // esi@2
  int v9; // eax@4
  int v10; // eax@4

  result = GetCalendar(0, a1);
  v5 = result;
  if ( result )
  {
    v6 = KernelBaseGetGlobalData();
    v7 = GetPtrCalDataArray(a1, *(_DWORD *)(v6 + 116), *(_DWORD *)(v5 + 20));
    v8 = 0;
    if ( *(_WORD *)v7 <= 0u )
      goto LABEL_13;
    do
    {
      if ( v8 >= a3 )
        break;
      v9 = KernelBaseGetGlobalData();
      v10 = *(_WORD *)(GetPtrCalData(a1, *(_DWORD *)(v9 + 116), v7 + 2, v8 + 1) + 10);
      if ( (signed __int16)v10 >= 0 )
        LOWORD(v10) = v10 + 1;
      else
        v10 = -v10;
      *(_DWORD *)(a2 + 4 * v8++) = (unsigned __int16)v10;
    }
    while ( v8 < *(_WORD *)v7 );
    if ( v8 )
    {
      *(_DWORD *)a4 = v8;
      result = 1;
    }
    else
    {
LABEL_13:
      result = 0;
    }
  }
  return result;
}
// 77E2ADCF: using guessed type int __stdcall GetCalendar(_DWORD, _DWORD);
// 77E8B8B9: using guessed type int __stdcall GetPtrCalData(_DWORD, _DWORD, _DWORD, _DWORD);
// 77E8B8C4: using guessed type int __stdcall GetPtrCalDataArray(_DWORD, _DWORD, _DWORD);

//----- (77E837CB) --------------------------------------------------------
int __stdcall GetGregorianYear(int a1, int a2, int a3)
{
  int v3; // ebx@1
  unsigned int v4; // esi@1
  PVOID v5; // edi@1
  int v7; // esi@9

  v3 = a1;
  v4 = (unsigned __int16)GetMaxEras(a1);
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 4 * v4);
  if ( !v5 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  if ( !GetEraOffsets(v3, (int)v5, v4, (int)&a1) )
    return 0;
  if ( (unsigned int)v3 < 3 )
    goto LABEL_15;
  if ( (unsigned int)v3 <= 4 )
  {
    v7 = a2 + *((_DWORD *)v5 + a1 - a3) - 1;
    goto LABEL_12;
  }
  if ( v3 != 5 && v3 != 7 )
  {
LABEL_15:
    v7 = a2;
    goto LABEL_12;
  }
  v7 = a2 - *(_DWORD *)v5;
LABEL_12:
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E83871) --------------------------------------------------------
signed int __stdcall UpdateGregBasedYearAndEra(unsigned int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, int a5)
{
  int v5; // edi@1
  int v6; // eax@1
  unsigned __int16 v7; // ax@1
  signed int result; // eax@2
  int v9; // edx@3
  int v10; // [sp+4h] [bp-8h]@1
  unsigned __int16 v11; // [sp+8h] [bp-4h]@1

  v10 = 0;
  v5 = GetCalendar(0, a1);
  v6 = KernelBaseGetGlobalData();
  v7 = GetCalendarYear((int)&v10, (int)&v11, a1, v5, *(_DWORD *)(v6 + 116), a2, a3, a4);
  if ( v10 )
  {
    v9 = v11;
    *(_DWORD *)(a5 + 8) = v7;
    *(_DWORD *)(a5 + 4) = v9;
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(288);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E2ADCF: using guessed type int __stdcall GetCalendar(_DWORD, _DWORD);

//----- (77E838E1) --------------------------------------------------------
int __stdcall IsValidJapanDate(unsigned int a1, int a2, int a3, int a4, int a5)
{
  unsigned int v5; // esi@1
  PVOID v6; // ebx@1
  int v7; // edi@5
  int v8; // eax@12
  int v10; // [sp+Ch] [bp-8h]@5
  int v11; // [sp+10h] [bp-4h]@1

  v11 = 0;
  v5 = (unsigned __int16)GetMaxEras(3);
  v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 4 * v5);
  if ( v6 )
  {
    if ( !a4 || a4 > v5 || (v7 = GetGregorianYear(3, a3, a4), !GetEraOffsets(3, (int)v6, v5, (int)&v10)) || v10 - a4 < 0 )
    {
      RtlSetLastWin32Error(288);
      return 0;
    }
    if ( v10 == a4 )
    {
      if ( (unsigned int)a3 <= 0x1F4B
        && (unsigned int)v7 >= *(_DWORD *)v6
        && IsValidGregorianMonthAndDay(a1, a2, v7, a5) )
      {
        v11 = 1;
LABEL_21:
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
        return v11;
      }
    }
    else
    {
      v8 = (int)((char *)v6 + 4 * (v10 - a4));
      if ( (unsigned int)v7 >= *(_DWORD *)v8
        && (unsigned int)v7 <= *(_DWORD *)(v8 - 4)
        && IsValidGregorianMonthAndDay(a1, a2, v7, a5) )
      {
        v11 = 1;
        if ( v7 != 1868 || (unsigned int)a2 >= 9 && (a2 != 9 || a1 >= 8) )
          goto LABEL_21;
        v11 = 0;
      }
    }
    RtlSetLastWin32Error(288);
    goto LABEL_21;
  }
  RtlSetLastWin32Error(8);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E83A11) --------------------------------------------------------
int __stdcall IsValidGregBasedDate(int a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@1
  int v8; // eax@5
  signed int v9; // ecx@8

  v6 = 0;
  if ( a1 == 3 )
    return IsValidJapanDate(a2, a3, a4, a5, a6);
  if ( a5 == 1 )
  {
    v8 = GetGregorianYear(a1, a4, 1);
    if ( a1 == 4 )
    {
      v9 = 1;
      v6 = 8088;
    }
    else if ( a1 == 5 )
    {
      v9 = 2334;
      v6 = 12332;
    }
    else
    {
      if ( a1 != 7 )
        goto LABEL_12;
      v9 = 544;
      v6 = 10542;
    }
    if ( a4 < (unsigned int)v9 )
    {
LABEL_14:
      RtlSetLastWin32Error(288);
      return 0;
    }
LABEL_12:
    if ( a4 <= (unsigned int)v6 )
      return IsValidGregorianMonthAndDay(a2, a3, v8, a6);
    goto LABEL_14;
  }
  RtlSetLastWin32Error(87);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E83AAD) --------------------------------------------------------
int __thiscall IsGregBasedLeapYear(void *this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // eax@2
  void *v6; // [sp+0h] [bp-4h]@1

  v6 = this;
  result = IsValidGregBasedDate(a2, 0xAu, 10, a3, a4, (int)&v6);
  if ( result )
  {
    v5 = GetGregorianYear(a2, a3, a4);
    result = IsGregorianLeapYear(v5, 1);
  }
  return result;
}

//----- (77E83AEC) --------------------------------------------------------
int __stdcall IsGregBasedLeapMonth(int a1, int a2, int a3, int a4)
{
  if ( IsValidGregBasedDate(a1, 0xAu, a2, a3, a4, (int)&a4) )
    RtlSetLastWin32Error(0);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E83B1F) --------------------------------------------------------
int __thiscall IsGregBasedLeapDay(void *this, int a2, unsigned int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // eax@2
  void *v8; // [sp+0h] [bp-4h]@1

  v8 = this;
  result = IsValidGregBasedDate(a2, 0xAu, a4, a5, a6, (int)&v8);
  if ( result )
  {
    v7 = GetGregorianYear(a2, a5, a6);
    result = IsGregorianLeapDay(a3, a4, v7, 1);
  }
  return result;
}

//----- (77E83B65) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToGregBasedDateTime(int a1, void *a2)
{
  signed int result; // eax@1
  unsigned int v3; // edx@2
  unsigned __int16 v4; // ST0C_2@2
  unsigned __int16 v5; // ST08_2@2
  unsigned __int16 v6; // ST04_2@2
  char v7; // [sp+0h] [bp-28h]@1
  int v8; // [sp+8h] [bp-20h]@2
  int v9; // [sp+Ch] [bp-1Ch]@2
  int v10; // [sp+10h] [bp-18h]@2

  result = ConvertSystemTimeToGregorianDateTime(a1, 1, &v7);
  if ( result )
  {
    v3 = *(_DWORD *)a2;
    v4 = v10;
    v5 = v9;
    v6 = v8;
    qmemcpy(a2, &v7, 0x28u);
    *(_DWORD *)a2 = v3;
    result = UpdateGregBasedYearAndEra(v3, v6, v5, v4, (int)a2) != 0;
  }
  return result;
}

//----- (77E83BB3) --------------------------------------------------------
signed int __thiscall GetGregBasedDaysInYear(void *this, int a2, int a3, int a4)
{
  signed int result; // eax@2

  if ( IsGregBasedLeapYear(this, a2, a3, a4) )
    result = 366;
  else
    result = GetLastError() != 0 ? 0 : 365;
  return result;
}

//----- (77E83BED) --------------------------------------------------------
signed int __stdcall ConvertGregBasedToGregDateTime(int a1, int a2)
{
  int v2; // edi@1
  signed int result; // eax@1

  v2 = GetGregorianYear(*(_DWORD *)a2, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 4));
  CopyCalDateTime((void *)a1, (const void *)a2);
  result = 1;
  *(_DWORD *)(a1 + 8) = v2;
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}

//----- (77E83C26) --------------------------------------------------------
int __thiscall GetGregBasedDaysInMonth(void *this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // eax@2
  void *v7; // [sp+0h] [bp-4h]@1

  v7 = this;
  result = IsValidGregBasedDate(a2, 0xAu, a3, a4, a5, (int)&v7);
  if ( result )
  {
    v6 = GetGregorianYear(a2, a4, a5);
    result = GetGregorianDaysInMonth(a3, v6, 1);
  }
  return result;
}

//----- (77E83C69) --------------------------------------------------------
int __stdcall GetGregBasedMonthsInYear(int a1, int a2, int a3)
{
  return IsValidGregBasedDate(a1, 0xAu, 10, a2, a3, (int)&a3) != 0 ? 0xC : 0;
}

//----- (77E83C94) --------------------------------------------------------
signed int __stdcall UpdateGregBasedDayOfWeek(int a1)
{
  int v1; // esi@1
  signed int v2; // edi@1
  signed int result; // eax@2
  unsigned int v4; // eax@4
  char v5; // [sp+8h] [bp-28h]@3

  v1 = a1;
  v2 = 0;
  if ( IsValidGregBasedDateTime(a1, (int)&a1, 0) && ConvertGregBasedToGregDateTime((int)&v5, v1) )
  {
    v4 = GetGregorianDayOfWeekHelper((int)&v5);
    if ( v4 != -1 )
    {
      *(_DWORD *)(v1 + 20) = v4;
      v2 = 1;
    }
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E83CE5) --------------------------------------------------------
signed int __stdcall ConvertGregBasedDateTimeToSysTime(int a1, int a2)
{
  signed int result; // eax@1
  char v3; // [sp+0h] [bp-28h]@1

  result = ConvertGregBasedToGregDateTime((int)&v3, a1);
  if ( result )
    result = ConvertGregorianDateTimeToSystemTime((int)&v3, a2);
  return result;
}

//----- (77E83D12) --------------------------------------------------------
int __stdcall GetGregBasedDifferenceInDays(int a1, int a2)
{
  char v3; // [sp+0h] [bp-50h]@1
  char v4; // [sp+28h] [bp-28h]@1

  ConvertGregBasedToGregDateTime((int)&v3, a1);
  ConvertGregBasedToGregDateTime((int)&v4, a2);
  return GetGregorianDifferenceInDays((int)&v3, (int)&v4);
}

//----- (77E83D48) --------------------------------------------------------
signed int __stdcall GetGregBasedDayOfYear(int a1)
{
  signed int result; // eax@1
  char v2; // [sp+0h] [bp-28h]@1

  result = ConvertGregBasedToGregDateTime((int)&v2, a1);
  if ( result )
    result = GetGregorianDayOfYear((int)&v2);
  return result;
}

//----- (77E83D72) --------------------------------------------------------
signed int __stdcall IsValidGregBasedDateTime(int a1, int a2, int a3)
{
  char v4; // [sp+4h] [bp-28h]@5
  int v5; // [sp+18h] [bp-14h]@7

  if ( !IsValidGregorianTime(a1, a2)
    || !IsValidGregBasedDate(
          *(_DWORD *)a1,
          *(_DWORD *)(a1 + 16),
          *(_DWORD *)(a1 + 12),
          *(_DWORD *)(a1 + 8),
          *(_DWORD *)(a1 + 4),
          a2) )
    return 0;
  if ( a3 && CopyCalDateTime(&v4, (const void *)a1) && UpdateGregBasedDayOfWeek((int)&v4) && *(_DWORD *)(a1 + 20) != v5 )
  {
    RtlSetLastWin32Error(288);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E83DEC) --------------------------------------------------------
signed int __stdcall AdjustGregBasedDateTime(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v5; // eax@4
  char v6; // [sp+4h] [bp-28h]@1
  int v7; // [sp+Ch] [bp-20h]@7
  int v8; // [sp+10h] [bp-1Ch]@7
  int v9; // [sp+14h] [bp-18h]@7
  int v10; // [sp+18h] [bp-14h]@8

  v3 = a1;
  if ( !ConvertGregBasedToGregDateTime((int)&v6, a1) )
    return 0;
  v5 = a2 == 2 ? AdjustMonthsInTwelveMonthCalendars((int)&v6, a3) : AdjustGregorianDays(&v6, a3);
  if ( !v5 || !UpdateGregBasedYearAndEra(*(_DWORD *)v3, v7, v8, v9, v3) )
    return 0;
  *(_DWORD *)(v3 + 12) = v8;
  *(_DWORD *)(v3 + 16) = v9;
  *(_DWORD *)(v3 + 20) = v10;
  if ( !IsValidGregBasedDateTime(v3, (int)&a1, 0) )
  {
    RtlSetLastWin32Error(288);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E3EC1C: using guessed type _DWORD __stdcall AdjustGregorianDays(_DWORD, _DWORD);

//----- (77E83E78) --------------------------------------------------------
signed int __stdcall OpenRegistryInternationalKey(int a1, int a2)
{
  signed int result; // eax@3

  if ( *(_DWORD *)a1 || OpenRegKey(a1, 0, L"Control Panel\\International", a2, 3) >= 0 )
  {
    result = 1;
  }
  else
  {
    SetLastError(0x3F1u);
    result = 0;
  }
  return result;
}
// 77E476ED: using guessed type int __stdcall OpenRegKey(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 77E83EB0: using guessed type wchar_t aControlPanel_0[28];

//----- (77E83EED) --------------------------------------------------------
signed int __stdcall GetHijriSupportedDateRange(int a1, int a2)
{
  signed int result; // eax@1

  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  result = 1;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 4) = 1;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 20) = 4;
  *(_DWORD *)(a2 + 12) = 4;
  *(_DWORD *)(a2 + 4) = 1;
  *(_DWORD *)(a2 + 8) = 9666;
  *(_DWORD *)(a2 + 16) = 3;
  *(_DWORD *)(a2 + 20) = 5;
  *(_DWORD *)(a2 + 24) = 23;
  *(_DWORD *)(a2 + 28) = 59;
  *(_DWORD *)(a2 + 32) = 59;
  *(_DWORD *)(a2 + 36) = 9999999;
  return result;
}

//----- (77E83F58) --------------------------------------------------------
signed int __stdcall IsValidHijriYear(int a1, int a2)
{
  if ( IsValidUmAlQuraEra(a2) )
  {
    if ( (unsigned int)(a1 - 1) <= 0x25C1 )
      return 1;
    SetLastError(0x120u);
  }
  return 0;
}

//----- (77E83F8E) --------------------------------------------------------
signed int __stdcall IsValidHijriMonth(unsigned int a1, int a2, int a3)
{
  if ( IsValidHijriYear(a2, a3) )
  {
    if ( a1 - 1 > 0xB )
    {
      SetLastError(0x57u);
    }
    else
    {
      if ( a2 != 9666 || a1 <= 4 )
        return 1;
      SetLastError(0x120u);
    }
  }
  return 0;
}

//----- (77E83FD9) --------------------------------------------------------
BOOL __stdcall NlsHijriLeapYear(int a1)
{
  return (11 * a1 + 14) % 0x1Eu < 0xB;
}

//----- (77E83FFE) --------------------------------------------------------
signed int __stdcall GetAdvanceHijriDate(int a1)
{
  int v1; // edi@1
  signed int result; // eax@1
  const WCHAR *v3; // eax@2
  size_t v4; // esi@4
  const wchar_t *v5; // esi@8
  int v6; // esi@10
  __int16 v7; // cx@10
  unsigned __int16 v8; // ax@12
  int v9; // [sp+4h] [bp-220h]@2
  HANDLE Handle; // [sp+8h] [bp-21Ch]@1
  char v11; // [sp+Ch] [bp-218h]@2

  v1 = 0;
  Handle = 0;
  result = OpenRegistryInternationalKey((int)&Handle, 131097);
  if ( result )
  {
    v9 = (int)&v11;
    v3 = L"AddHijriDateTemp";
    if ( !(a1 & 0x40000000) )
      v3 = L"AddHijriDate";
    v4 = QueryRegValue(Handle, v3, (int)&v9, 0x214u, 1, 0);
    if ( Handle )
    {
      NtClose(Handle);
      Handle = 0;
    }
    if ( (v4 & 0x80000000) == 0 )
    {
      v5 = (const wchar_t *)(v9 + *(_DWORD *)(v9 + 8));
      if ( *(_DWORD *)(v9 + 12) >= 0x18u && !wcsncmp(v5, L"AddHijriDate", 0xCu) )
      {
        v6 = (int)(v5 + 12);
        v7 = *(_WORD *)v6;
        if ( *(_WORD *)v6 )
        {
          v8 = *(_WORD *)(v6 + 2);
          if ( v8 >= 0x30u && v8 < 0x33u && !*(_WORD *)(v6 + 4) )
          {
            v1 = v8 - 48;
            if ( v7 == 45 )
            {
              v1 = -v1;
            }
            else if ( v7 != 43 )
            {
              v1 = 0;
            }
          }
        }
        else
        {
          v1 = -1;
        }
      }
      result = v1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (77E8414F) --------------------------------------------------------
unsigned int __stdcall DaysUpToHijriYear(int a1)
{
  unsigned int v1; // edi@1
  unsigned int v2; // esi@1
  BOOL v3; // eax@2

  v1 = a1 - 30 * ((a1 - 1) / 0x1Eu) - 1;
  v2 = 318930 * ((a1 - 1) / 0x1Eu) / 0x1E + 227013;
  if ( a1 - 30 * ((a1 - 1) / 0x1Eu) != 1 )
  {
    do
    {
      v3 = NlsHijriLeapYear(v1--);
      v2 += v3 + 354;
    }
    while ( v1 );
  }
  return v2;
}

//----- (77E841A0) --------------------------------------------------------
signed int __stdcall IsHijriLeapYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidHijriYear(a1, a2);
  if ( result )
  {
    SetLastError(0);
    result = (11 * a1 + 14) % 0x1Eu < 0xB;
  }
  return result;
}

//----- (77E841DB) --------------------------------------------------------
int __stdcall IsHijriLeapMonth(unsigned int a1, int a2, int a3)
{
  if ( IsValidHijriMonth(a1, a2, a3) )
    SetLastError(0);
  return 0;
}

//----- (77E84204) --------------------------------------------------------
unsigned int __stdcall HijriToAbsolute(int a1)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 + 16) + dword_77E62654[*(_DWORD *)(a1 + 12)] - GetAdvanceHijriDate(0);
  return v1 + DaysUpToHijriYear(*(_DWORD *)(a1 + 8)) - 1;
}
// 77E62654: using guessed type int dword_77E62654[];

//----- (77E84239) --------------------------------------------------------
signed int __stdcall ConvertHijriDateTimeToSystemTime(int a1, int a2)
{
  signed int v2; // eax@1
  signed int result; // eax@3
  char v4; // [sp+4h] [bp-28h]@2
  int v5; // [sp+1Ch] [bp-10h]@3
  int v6; // [sp+20h] [bp-Ch]@3
  int v7; // [sp+24h] [bp-8h]@3
  int v8; // [sp+28h] [bp-4h]@3

  v2 = HijriToAbsolute(a1);
  if ( v2 && GetGregorianFromAbsoluteDate(v2, &v4) )
  {
    v5 = *(_DWORD *)(a1 + 24);
    v6 = *(_DWORD *)(a1 + 28);
    v7 = *(_DWORD *)(a1 + 32);
    v8 = *(_DWORD *)(a1 + 36);
    result = ConvertGregorianDateTimeToSystemTime((int)&v4, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E8428F) --------------------------------------------------------
int __stdcall GetHijriMonthsInYear(int a1, int a2)
{
  return IsValidHijriYear(a1, a2) != 0 ? 0xC : 0;
}

//----- (77E842AF) --------------------------------------------------------
unsigned int __stdcall GetHijriDayOfWeekHelper(int a1)
{
  return (HijriToAbsolute(a1) + 1) % 7;
}

//----- (77E842CF) --------------------------------------------------------
signed int __stdcall GetHijriDaysInMonth(unsigned int a1, int a2, int a3)
{
  signed int result; // eax@1

  result = IsValidHijriMonth(a1, a2, a3);
  if ( result )
  {
    if ( a1 == 12 )
      result = (IsHijriLeapYear(a2, a3) != 0) + 29;
    else
      result = 30 - ((unsigned __int8)((a1 & 1) - 1) != 0);
  }
  return result;
}

//----- (77E8431C) --------------------------------------------------------
int __stdcall GetHijriDaysInYearHelper(int a1)
{
  return (IsHijriLeapYear(a1, 1) != 0) + 354;
}

//----- (77E8433F) --------------------------------------------------------
signed int __stdcall GetHijriDaysInYear(int a1, int a2)
{
  signed int result; // eax@1

  result = IsValidHijriYear(a1, a2);
  if ( result )
    result = GetHijriDaysInYearHelper(a1);
  return result;
}

//----- (77E84364) --------------------------------------------------------
unsigned int __stdcall GetHijriDifferenceInDays(int a1, int a2)
{
  unsigned int v2; // esi@1

  v2 = HijriToAbsolute(a1);
  return HijriToAbsolute(a2) - v2;
}

//----- (77E84388) --------------------------------------------------------
signed int __stdcall AbsoluteToHijri(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // esi@2
  int v5; // edi@2
  unsigned int v6; // ebx@2
  signed int v7; // eax@2
  int v8; // eax@6
  int v9; // esi@8
  signed int v10; // ecx@8
  int *v11; // eax@8
  int v12; // ecx@11
  int v13; // esi@12
  signed int result; // eax@12
  unsigned int v15; // [sp+10h] [bp+8h]@2

  v3 = a1;
  if ( (unsigned int)(a1 - 227013) > 0x344315 )
    goto LABEL_16;
  v15 = (a1 + 1) % 7u;
  v4 = v3 + GetAdvanceHijriDate(a3) + 1;
  v5 = 30 * (v4 - 227013) / 0x2987u + 1;
  v6 = DaysUpToHijriYear(v5);
  v7 = GetHijriDaysInYear(v5, 1);
  if ( v4 >= v6 )
  {
    if ( v4 == v6 )
    {
      v5 = 30 * (v4 - 227013) / 0x2987u;
      v6 -= GetHijriDaysInYear(v5, 1);
    }
    else
    {
      v8 = v6 + v7;
      if ( v4 > (unsigned int)v8 )
      {
        v6 = v8;
        v5 = 30 * (v4 - 227013) / 0x2987u + 2;
      }
    }
  }
  else
  {
    v6 -= v7;
    v5 = 30 * (v4 - 227013) / 0x2987u;
  }
  v9 = v4 - v6;
  v10 = 1;
  v11 = &HijriMonthDays;
  do
  {
    if ( v9 <= (unsigned int)*v11 )
      break;
    ++v10;
    ++v11;
  }
  while ( (unsigned int)v10 <= 0xC );
  v12 = v10 - 1;
  if ( (unsigned int)(v12 - 1) > 0xB )
  {
LABEL_16:
    result = 0;
  }
  else
  {
    v13 = v9 - dword_77E62654[v12];
    *(_DWORD *)(a2 + 12) = v12;
    *(_DWORD *)(a2 + 8) = v5;
    *(_DWORD *)(a2 + 16) = v13;
    *(_DWORD *)(a2 + 20) = v15;
    *(_DWORD *)a2 = 6;
    *(_DWORD *)(a2 + 4) = 1;
    result = 1;
  }
  return result;
}
// 77E62654: using guessed type int dword_77E62654[];
// 77E62658: using guessed type int HijriMonthDays;

//----- (77E84459) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToHijriDateTimeEx(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int result; // eax@3

  v3 = GetAbsoluteDateFromGregorian(*(_WORD *)a1, *(_WORD *)(a1 + 2), *(_WORD *)(a1 + 6));
  if ( v3 && AbsoluteToHijri(v3, a2, a3) )
  {
    *(_DWORD *)(a2 + 24) = *(_WORD *)(a1 + 8);
    *(_DWORD *)(a2 + 28) = *(_WORD *)(a1 + 10);
    *(_DWORD *)(a2 + 32) = *(_WORD *)(a1 + 12);
    *(_DWORD *)(a2 + 36) = 10000 * *(_WORD *)(a1 + 14);
    *(_DWORD *)(a2 + 20) = *(_WORD *)(a1 + 4);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E844C6) --------------------------------------------------------
signed int __stdcall ConvertSystemTimeToHijriDateTime(int a1, int a2)
{
  return ConvertSystemTimeToHijriDateTimeEx(a1, a2, 0);
}

//----- (77E844E1) --------------------------------------------------------
signed int __stdcall AdjustHijriMonths(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int v4; // eax@1
  signed int v5; // ecx@1
  int v6; // ebx@2
  unsigned int v7; // edi@2
  signed int result; // eax@5
  signed int v9; // eax@7
  unsigned int v10; // [sp+14h] [bp+8h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  v10 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(v2 + 12);
  v5 = a2 + v4 - 1;
  if ( v5 < 0 )
  {
    v6 = (a2 + v4 - 12) / 12 + v3;
    v7 = (a2 + v4) % 12 + 12;
  }
  else
  {
    v6 = v5 / 12 + v3;
    v7 = v5 % 12 + 1;
  }
  if ( !IsValidHijriMonth(v7, v6, *(_DWORD *)(v2 + 4)) )
    goto LABEL_15;
  if ( v10 > 0x1D )
  {
    v9 = GetHijriDaysInMonth(v7, v6, *(_DWORD *)(v2 + 4));
    if ( v10 > v9 )
      v10 = v9;
  }
  if ( v6 != 9666 || v7 != 4 || v10 <= 3 )
  {
    *(_DWORD *)(v2 + 16) = v10;
    *(_DWORD *)(v2 + 12) = v7;
    *(_DWORD *)(v2 + 8) = v6;
    *(_DWORD *)(v2 + 20) = GetHijriDayOfWeekHelper(v2);
    result = 1;
  }
  else
  {
LABEL_15:
    SetLastError(0x120u);
    result = 0;
  }
  return result;
}

//----- (77E84593) --------------------------------------------------------
signed int __stdcall IsValidHijriDay(unsigned int a1, unsigned int a2, int a3, int a4)
{
  signed int v4; // eax@1

  v4 = GetHijriDaysInMonth(a2, a3, a4);
  if ( v4 )
  {
    if ( a1 >= 1 && a1 <= v4 )
      return 1;
    SetLastError(0x57u);
  }
  return 0;
}

//----- (77E845CC) --------------------------------------------------------
signed int __stdcall IsValidHijriDateTime(int a1, int a2, int a3)
{
  if ( *(_DWORD *)a1 != 6 )
  {
LABEL_10:
    SetLastError(0x57u);
    return 0;
  }
  if ( IsValidHijriDay(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4)) )
  {
    if ( *(_DWORD *)(a1 + 24) <= 0x17u
      && *(_DWORD *)(a1 + 28) <= 0x3Bu
      && *(_DWORD *)(a1 + 32) <= 0x3Bu
      && *(_DWORD *)(a1 + 36) <= 0x98967Fu
      && (!a3 || *(_DWORD *)(a1 + 20) == GetHijriDayOfWeekHelper(a1)) )
      return 1;
    goto LABEL_10;
  }
  return 0;
}

//----- (77E84633) --------------------------------------------------------
signed int __stdcall GetHijriDayOfYear(int a1)
{
  const void *v1; // esi@1
  signed int result; // eax@1
  char v3; // [sp+8h] [bp-28h]@2
  int v4; // [sp+14h] [bp-1Ch]@2
  int v5; // [sp+18h] [bp-18h]@2
  unsigned int v6; // [sp+38h] [bp+8h]@2

  v1 = (const void *)a1;
  result = IsValidHijriDateTime(a1, 0, 1);
  if ( result )
  {
    v6 = HijriToAbsolute(a1);
    qmemcpy(&v3, v1, 0x28u);
    v4 = 1;
    v5 = 1;
    result = v6 - HijriToAbsolute((int)&v3) + 1;
  }
  return result;
}

//----- (77E84685) --------------------------------------------------------
signed int __stdcall UpdateHijriDayOfWeek(int a1)
{
  signed int result; // eax@1

  result = IsValidHijriDateTime(a1, 0, 0);
  if ( result )
  {
    *(_DWORD *)(a1 + 20) = GetHijriDayOfWeekHelper(a1);
    result = 1;
  }
  return result;
}

//----- (77E846B2) --------------------------------------------------------
int __stdcall IsHijriLeapDay(unsigned int a1, unsigned int a2, int a3, int a4)
{
  int result; // eax@5

  result = 0;
  if ( IsValidHijriDay(a1, a2, a3, a4) )
  {
    SetLastError(0);
    if ( IsHijriLeapYear(a3, a4) )
    {
      if ( a2 == 12 && a1 == 30 )
        result = 1;
    }
  }
  return result;
}

//----- (77E846FE) --------------------------------------------------------
signed int __stdcall AdjustHijriDays(int a1, int a2)
{
  int v2; // eax@1
  signed int result; // eax@2

  v2 = a2 + HijriToAbsolute(a1);
  if ( (unsigned int)(v2 - 227013) > 0x344315 )
  {
    SetLastError(0x120u);
    result = 0;
  }
  else
  {
    result = AbsoluteToHijri(v2, a1, 0);
  }
  return result;
}

//----- (77E8473E) --------------------------------------------------------
signed int __stdcall AdjustHijriYears(int a1, int a2)
{
  return AdjustHijriMonths(a1, 12 * a2);
}

//----- (77E8475B) --------------------------------------------------------
BOOL __stdcall GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
{
  int v3; // eax@1
  BOOL result; // eax@3

  v3 = GetNamedLocaleHashNode(lpLocaleName, 0);
  if ( lpVersionInformation && v3 )
  {
    result = GetNLSVersionHelper(function, v3, (int)lpVersionInformation);
  }
  else
  {
    SetLastError(0x57u);
    result = 0;
  }
  return result;
}
// 77E3FC4E: using guessed type int __fastcall GetNamedLocaleHashNode(_DWORD, _DWORD);

//----- (77E84794) --------------------------------------------------------
BOOLEAN __stdcall SortCloseHandle(PVOID Address)
{
  return InternalSortCloseHandle(Address);
}

//----- (77E847A4) --------------------------------------------------------
__int16 __stdcall GetOldHangulWeight(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  int v4; // eax@2
  int v5; // edx@3
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // ecx@4
  unsigned int v9; // eax@4

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 32) = 0;
  if ( *(_WORD *)v3 >= 0x1160u || (v4 = MapOldHangulSortKey(a1, v3, *(_DWORD *)(v2 + 4), v2 + 28, (int)&a2), v4 <= 0) )
  {
    v8 = *(_DWORD *)(a1 + 224);
    v9 = *(_WORD *)(v2 + 30);
    if ( v8 )
      v9 = *(_DWORD *)(v8 + 4 * (v9 >> 8)) + (unsigned __int8)v9;
    v7 = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v9);
    *(_DWORD *)(v2 + 24) = v7;
    LOWORD(v7) = *(_BYTE *)(v2 + 26) | (unsigned __int16)((unsigned __int8)v7 << 8);
    *(_BYTE *)(v2 + 27) &= 0x3Fu;
    *(_WORD *)(v2 + 28) = v7;
    *(_WORD *)(v2 + 24) = v7;
    *(_BYTE *)(v2 + 26) = 2;
  }
  else
  {
    v5 = BYTE1(a2);
    *(_DWORD *)(v2 + 24) = *(_WORD *)(v2 + 28) | 0x2020000;
    v6 = BYTE2(a2) | ((v5 | ((unsigned __int8)a2 << 8)) << 8);
    v7 = 2 * v4 - 2;
    *(_DWORD *)(v2 + 16) += v7;
    *(_DWORD *)(v2 + 32) = v6;
  }
  return v7;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E8485D) --------------------------------------------------------
signed int __stdcall GetGraphemeStartPositions(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  int v6; // edx@3
  bool v7; // zf@3
  unsigned int v9; // ecx@5
  signed __int16 v10; // bx@6
  unsigned int *v11; // ecx@8
  int v12; // edx@9
  unsigned int v13; // eax@9
  int v14; // eax@14
  int v15; // edi@15
  unsigned int v16; // edx@15
  int v17; // edi@19
  int v18; // ecx@19
  int v19; // eax@20
  int v20; // edx@20
  int v21; // ecx@23
  int v22; // edi@28
  int v23; // eax@28
  int v24; // eax@33
  unsigned __int16 *v25; // edi@34
  unsigned int v26; // edx@34
  int v27; // edi@40
  int v28; // ecx@40
  int v29; // eax@41
  int v30; // edx@41
  int v31; // ecx@46
  int v32; // edi@51
  int v33; // eax@51
  int v34; // eax@56
  unsigned __int16 *v35; // edi@57
  unsigned int v36; // edx@57
  int v37; // edi@63
  int v38; // ecx@63
  int v39; // eax@64
  int v40; // edx@64
  int v41; // ecx@69
  int v42; // edi@74
  int v43; // eax@74
  int v44; // eax@79
  unsigned __int16 *v45; // edi@80
  unsigned int v46; // edx@80
  int v47; // edi@86
  int v48; // ecx@86
  int v49; // eax@87
  int v50; // edx@87
  int v51; // ecx@92
  int v52; // edi@97
  int v53; // eax@97
  int v54; // eax@102
  unsigned __int16 *v55; // edi@103
  unsigned int v56; // edx@103
  int v57; // ecx@107
  int v58; // edi@109
  int v59; // ecx@109
  int v60; // edx@110
  int v61; // eax@110
  int v62; // edx@115
  int v63; // edi@120
  int v64; // eax@120
  int v65; // eax@125
  unsigned __int16 *v66; // edi@126
  unsigned int v67; // edx@126
  int v68; // ecx@130
  int v69; // edi@132
  int v70; // ecx@132
  int v71; // edx@133
  int v72; // eax@133
  int v73; // edx@138
  int v74; // edi@143
  int v75; // eax@143
  int v76; // eax@148
  unsigned __int16 *v77; // edi@149
  unsigned int v78; // ecx@149
  int v79; // edx@150
  int v80; // ecx@153
  int v81; // edi@155
  int v82; // ecx@155
  int v83; // edx@156
  int v84; // eax@156
  int v85; // edx@161
  int v86; // edi@166
  int v87; // eax@166
  int v88; // ecx@176
  int v89; // [sp+Ch] [bp-24h]@1
  unsigned int *v90; // [sp+10h] [bp-20h]@11
  int v91; // [sp+14h] [bp-1Ch]@102
  int v92; // [sp+14h] [bp-1Ch]@137
  int v93; // [sp+14h] [bp-1Ch]@160
  int v94; // [sp+18h] [bp-18h]@14
  int v95; // [sp+18h] [bp-18h]@114
  int v96; // [sp+18h] [bp-18h]@125
  int v97; // [sp+18h] [bp-18h]@148
  int v98; // [sp+1Ch] [bp-14h]@33
  int v99; // [sp+1Ch] [bp-14h]@56
  int v100; // [sp+1Ch] [bp-14h]@79
  signed int v101; // [sp+1Ch] [bp-14h]@107
  int v102; // [sp+1Ch] [bp-14h]@130
  int v103; // [sp+1Ch] [bp-14h]@153
  signed int v104; // [sp+20h] [bp-10h]@17
  int v105; // [sp+20h] [bp-10h]@38
  int v106; // [sp+20h] [bp-10h]@61
  int v107; // [sp+20h] [bp-10h]@84
  int v108; // [sp+20h] [bp-10h]@107
  signed int v109; // [sp+20h] [bp-10h]@130
  signed int v110; // [sp+20h] [bp-10h]@153
  unsigned __int16 *v111; // [sp+24h] [bp-Ch]@8
  int v112; // [sp+28h] [bp-8h]@17
  int v113; // [sp+28h] [bp-8h]@38
  int v114; // [sp+28h] [bp-8h]@61
  int v115; // [sp+28h] [bp-8h]@84
  int v116; // [sp+2Ch] [bp-4h]@17
  int v117; // [sp+2Ch] [bp-4h]@34
  signed int v118; // [sp+2Ch] [bp-4h]@38
  int v119; // [sp+2Ch] [bp-4h]@57
  signed int v120; // [sp+2Ch] [bp-4h]@61
  int v121; // [sp+2Ch] [bp-4h]@80
  signed int v122; // [sp+2Ch] [bp-4h]@84
  int v123; // [sp+2Ch] [bp-4h]@103
  int v124; // [sp+2Ch] [bp-4h]@107
  int v125; // [sp+2Ch] [bp-4h]@126
  int v126; // [sp+2Ch] [bp-4h]@130
  int v127; // [sp+2Ch] [bp-4h]@149
  int v128; // [sp+3Ch] [bp+Ch]@11
  int v129; // [sp+3Ch] [bp+Ch]@153

  v4 = a2;
  v89 = *(_DWORD *)(a2 + 16);
  v5 = a3;
  if ( a3 && a4 )
  {
    v6 = a1;
    v7 = *(_DWORD *)(*(_DWORD *)a1 + 232) == 0;
    *(_DWORD *)a3 = 0;
    if ( v7 )
      return 1;
    v9 = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)a2;
    if ( v9 >= *(_DWORD *)(a2 + 4) )
    {
LABEL_177:
      *(_DWORD *)(v4 + 16) = v89;
      return 1;
    }
    v10 = 255;
    while ( 1 )
    {
      ++*(_DWORD *)v5;
      if ( *(_DWORD *)v5 > a4 )
        return 0;
      *(_DWORD *)(v5 + 4 * *(_DWORD *)v5) = *(_DWORD *)(v4 + 16);
      v11 = *(unsigned int **)(v4 + 16);
      v111 = *(unsigned __int16 **)(v4 + 16);
      if ( *(_DWORD *)(*(_DWORD *)v6 + 232) )
        break;
LABEL_176:
      v88 = (int)((char *)v11 + 2);
      *(_DWORD *)(v4 + 16) = v88;
      if ( (unsigned int)v88 >= *(_DWORD *)(v4 + 4) )
        goto LABEL_177;
    }
    *(_WORD *)(v4 + 30) = *(_WORD *)v11;
    v12 = *(_DWORD *)(*(_DWORD *)v6 + 224);
    v13 = *(_WORD *)v11;
    if ( v12 )
      v13 = *(_DWORD *)(v12 + 4 * (v13 >> 8)) + (unsigned __int8)v13;
    v128 = 0;
    *(_DWORD *)(v4 + 24) = *(_DWORD *)((*pSortTblPtrs)[11] + 4 * v13);
    v90 = v11;
    if ( (unsigned __int8)(*(_BYTE *)(v4 + 27) & ((unsigned __int8)(*(_BYTE *)(v4 + 25) - 3) != 0 ? v10 : 0) & 0xC0) != 64 )
    {
      if ( (unsigned __int8)(*(_BYTE *)(v4 + 27) & ((unsigned __int8)(*(_BYTE *)(v4 + 25) - 3) != 0 ? v10 : 0) & 0xC0) != 128 )
      {
        if ( (unsigned __int8)(*(_BYTE *)(v4 + 27) & ((unsigned __int8)(*(_BYTE *)(v4 + 25) - 3) != 0 ? v10 : 0) & 0xC0) != 192 )
        {
LABEL_175:
          v11 = (unsigned int *)v111;
          v5 = a3;
          v6 = a1;
          goto LABEL_176;
        }
        v14 = *(_DWORD *)a1;
        v94 = *(_DWORD *)(*(_DWORD *)a1 + 272);
        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 20) )
        {
          v15 = *(_DWORD *)(v14 + 236);
          v16 = *(_DWORD *)(v4 + 4);
          if ( (unsigned int)&v111[8 - (v15 == 0)] <= v16 )
          {
            v128 = NlsCountOfWCharsWithinRange(
                     v111,
                     v16,
                     8,
                     *(_WORD *)(*(_DWORD *)(v14 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v14 + 244) + 6),
                     v15,
                     *(_DWORD *)(v4 + 8));
            if ( v128 >= 8 )
            {
              v104 = 0;
              v116 = 0;
              v112 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 20) - 1;
              if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 9 )
              {
                v17 = *(_DWORD *)(*(_DWORD *)a1 + 224);
                v18 = *(_DWORD *)(v4 + 16);
                if ( v17 )
                {
                  v19 = *(_DWORD *)(v17 + 4 * ((unsigned int)*(_WORD *)v18 >> 8))
                      + (unsigned __int16)(v10 & *(_WORD *)v18);
                  v20 = (*pSortTblPtrs)[11];
                }
                else
                {
                  v20 = (*pSortTblPtrs)[11];
                  v19 = *(_WORD *)v18;
                }
                v21 = v17 ? *(_DWORD *)(v20
                                      + 4
                                      * (*(_DWORD *)(v17 + 4 * ((unsigned int)*(_WORD *)(v18 + 2) >> 8))
                                       + (unsigned __int16)(v10 & *(_WORD *)(v18 + 2)))) : *(_DWORD *)(v20 + 4 * *(_WORD *)(v18 + 2));
                if ( !((*(_DWORD *)(v20 + 4 * v19) ^ v21) & 0xE7FFFFFF) )
                  v104 = 1;
              }
              if ( v112 >= 0 )
              {
                while ( 1 )
                {
                  v22 = (v116 + v112) / 2;
                  v23 = NlsCompareRgWChar(2 * v104 + *(_DWORD *)(v4 + 16), v94 + 20 * v22, 8);
                  if ( !v23 )
                    break;
                  if ( v23 >= 0 )
                    v116 = v22 + 1;
                  else
                    v112 = v22 - 1;
                  if ( v116 > v112 )
                    goto LABEL_33;
                }
                *(_DWORD *)(v4 + 24) = *(_DWORD *)(20 * v22 + v94 + 16);
                if ( !v104 )
                  *(_DWORD *)(v4 + 16) += 14;
                goto LABEL_174;
              }
            }
          }
        }
LABEL_33:
        v24 = *(_DWORD *)a1;
        v98 = *(_DWORD *)(*(_DWORD *)a1 + 268);
        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 18) )
        {
          v25 = *(unsigned __int16 **)(v4 + 16);
          v117 = *(_DWORD *)(v24 + 236);
          v26 = *(_DWORD *)(v4 + 4);
          if ( (unsigned int)&v25[7 - (v117 == 0)] <= v26 )
          {
            if ( !v128 )
              v128 = NlsCountOfWCharsWithinRange(
                       v25,
                       v26,
                       7,
                       *(_WORD *)(*(_DWORD *)(v24 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v24 + 244) + 6),
                       v117,
                       *(_DWORD *)(v4 + 8));
            if ( v128 >= 7 )
            {
              v118 = 0;
              v105 = 0;
              v113 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 18) - 1;
              if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 8 )
              {
                v27 = *(_DWORD *)(*(_DWORD *)a1 + 224);
                v28 = *(_DWORD *)(v4 + 16);
                if ( v27 )
                {
                  v29 = *(_DWORD *)(v27 + 4 * ((unsigned int)*(_WORD *)v28 >> 8))
                      + (unsigned __int16)(v10 & *(_WORD *)v28);
                  v30 = (*pSortTblPtrs)[11];
                }
                else
                {
                  v30 = (*pSortTblPtrs)[11];
                  v29 = *(_WORD *)v28;
                }
                v31 = v27 ? *(_DWORD *)(v30
                                      + 4
                                      * (*(_DWORD *)(v27 + 4 * ((unsigned int)*(_WORD *)(v28 + 2) >> 8))
                                       + (unsigned __int16)(v10 & *(_WORD *)(v28 + 2)))) : *(_DWORD *)(v30 + 4 * *(_WORD *)(v28 + 2));
                if ( !((*(_DWORD *)(v30 + 4 * v29) ^ v31) & 0xE7FFFFFF) )
                  v118 = 1;
              }
              if ( v113 >= 0 )
              {
                while ( 1 )
                {
                  v32 = (v105 + v113) / 2;
                  v33 = NlsCompareRgWChar(2 * v118 + *(_DWORD *)(v4 + 16), v98 + 20 * v32, 7);
                  if ( !v33 )
                    break;
                  if ( v33 >= 0 )
                    v105 = v32 + 1;
                  else
                    v113 = v32 - 1;
                  if ( v105 > v113 )
                    goto LABEL_56;
                }
                *(_DWORD *)(v4 + 24) = *(_DWORD *)(20 * v32 + v98 + 16);
                if ( !v118 )
                  *(_DWORD *)(v4 + 16) += 12;
                goto LABEL_174;
              }
            }
          }
        }
LABEL_56:
        v34 = *(_DWORD *)a1;
        v99 = *(_DWORD *)(*(_DWORD *)a1 + 264);
        if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 16) )
        {
          v35 = *(unsigned __int16 **)(v4 + 16);
          v119 = *(_DWORD *)(v34 + 236);
          v36 = *(_DWORD *)(v4 + 4);
          if ( (unsigned int)&v35[6 - (v119 == 0)] <= v36 )
          {
            if ( !v128 )
              v128 = NlsCountOfWCharsWithinRange(
                       v35,
                       v36,
                       6,
                       *(_WORD *)(*(_DWORD *)(v34 + 244) + 4),
                       *(_WORD *)(*(_DWORD *)(v34 + 244) + 6),
                       v119,
                       *(_DWORD *)(v4 + 8));
            if ( v128 >= 6 )
            {
              v120 = 0;
              v106 = 0;
              v114 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 16) - 1;
              if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 7 )
              {
                v37 = *(_DWORD *)(*(_DWORD *)a1 + 224);
                v38 = *(_DWORD *)(v4 + 16);
                if ( v37 )
                {
                  v39 = *(_DWORD *)(v37 + 4 * ((unsigned int)*(_WORD *)v38 >> 8))
                      + (unsigned __int16)(v10 & *(_WORD *)v38);
                  v40 = (*pSortTblPtrs)[11];
                }
                else
                {
                  v40 = (*pSortTblPtrs)[11];
                  v39 = *(_WORD *)v38;
                }
                v41 = v37 ? *(_DWORD *)(v40
                                      + 4
                                      * (*(_DWORD *)(v37 + 4 * ((unsigned int)*(_WORD *)(v38 + 2) >> 8))
                                       + (unsigned __int16)(v10 & *(_WORD *)(v38 + 2)))) : *(_DWORD *)(v40 + 4 * *(_WORD *)(v38 + 2));
                if ( !((*(_DWORD *)(v40 + 4 * v39) ^ v41) & 0xE7FFFFFF) )
                  v120 = 1;
              }
              if ( v114 >= 0 )
              {
                while ( 1 )
                {
                  v42 = (v106 + v114) / 2;
                  v43 = NlsCompareRgWChar(2 * v120 + *(_DWORD *)(v4 + 16), v99 + 16 * v42, 6);
                  if ( !v43 )
                    break;
                  if ( v43 >= 0 )
                    v106 = v42 + 1;
                  else
                    v114 = v42 - 1;
                  if ( v106 > v114 )
                    goto LABEL_79;
                }
                *(_DWORD *)(v4 + 24) = *(_DWORD *)(16 * v42 + v99 + 12);
                if ( !v120 )
                  *(_DWORD *)(v4 + 16) += 10;
                goto LABEL_174;
              }
            }
          }
        }
      }
LABEL_79:
      v44 = *(_DWORD *)a1;
      v100 = *(_DWORD *)(*(_DWORD *)a1 + 260);
      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 14) )
      {
        v45 = *(unsigned __int16 **)(v4 + 16);
        v121 = *(_DWORD *)(v44 + 236);
        v46 = *(_DWORD *)(v4 + 4);
        if ( (unsigned int)&v45[5 - (v121 == 0)] <= v46 )
        {
          if ( !v128 )
            v128 = NlsCountOfWCharsWithinRange(
                     v45,
                     v46,
                     5,
                     *(_WORD *)(*(_DWORD *)(v44 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v44 + 244) + 6),
                     v121,
                     *(_DWORD *)(v4 + 8));
          if ( v128 >= 5 )
          {
            v122 = 0;
            v107 = 0;
            v115 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 14) - 1;
            if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 6 )
            {
              v47 = *(_DWORD *)(*(_DWORD *)a1 + 224);
              v48 = *(_DWORD *)(v4 + 16);
              if ( v47 )
              {
                v49 = *(_DWORD *)(v47 + 4 * ((unsigned int)*(_WORD *)v48 >> 8))
                    + (unsigned __int16)(v10 & *(_WORD *)v48);
                v50 = (*pSortTblPtrs)[11];
              }
              else
              {
                v50 = (*pSortTblPtrs)[11];
                v49 = *(_WORD *)v48;
              }
              v51 = v47 ? *(_DWORD *)(v50
                                    + 4
                                    * (*(_DWORD *)(v47 + 4 * ((unsigned int)*(_WORD *)(v48 + 2) >> 8))
                                     + (unsigned __int16)(v10 & *(_WORD *)(v48 + 2)))) : *(_DWORD *)(v50 + 4 * *(_WORD *)(v48 + 2));
              if ( !((*(_DWORD *)(v50 + 4 * v49) ^ v51) & 0xE7FFFFFF) )
                v122 = 1;
            }
            if ( v115 >= 0 )
            {
              while ( 1 )
              {
                v52 = (v107 + v115) / 2;
                v53 = NlsCompareRgWChar(2 * v122 + *(_DWORD *)(v4 + 16), v100 + 16 * v52, 5);
                if ( !v53 )
                  break;
                if ( v53 >= 0 )
                  v107 = v52 + 1;
                else
                  v115 = v52 - 1;
                if ( v107 > v115 )
                  goto LABEL_102;
              }
              *(_DWORD *)(v4 + 24) = *(_DWORD *)(16 * v52 + v100 + 12);
              if ( !v122 )
                *(_DWORD *)(v4 + 16) += 8;
              goto LABEL_174;
            }
          }
        }
      }
LABEL_102:
      v54 = *(_DWORD *)a1;
      v91 = *(_DWORD *)(*(_DWORD *)a1 + 256);
      if ( *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 12) )
      {
        v55 = *(unsigned __int16 **)(v4 + 16);
        v123 = *(_DWORD *)(v54 + 236);
        v56 = *(_DWORD *)(v4 + 4);
        if ( (unsigned int)&v55[4 - (v123 == 0)] <= v56 )
        {
          if ( !v128 )
            v128 = NlsCountOfWCharsWithinRange(
                     v55,
                     v56,
                     4,
                     *(_WORD *)(*(_DWORD *)(v54 + 244) + 4),
                     *(_WORD *)(*(_DWORD *)(v54 + 244) + 6),
                     v123,
                     *(_DWORD *)(v4 + 8));
          if ( v128 >= 4 )
          {
            v57 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 12) - 1;
            v101 = 0;
            v108 = 0;
            v124 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 12) - 1;
            if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 5 )
            {
              v58 = *(_DWORD *)(*(_DWORD *)a1 + 224);
              v59 = *(_DWORD *)(v4 + 16);
              if ( v58 )
              {
                v60 = (*pSortTblPtrs)[11];
                v61 = *(_DWORD *)(v58 + 4 * ((unsigned int)*(_WORD *)v59 >> 8))
                    + (unsigned __int16)(v10 & *(_WORD *)v59);
                v10 = 255;
              }
              else
              {
                v60 = (*pSortTblPtrs)[11];
                v61 = *(_WORD *)v59;
              }
              v95 = *(_DWORD *)(v60 + 4 * v61);
              v62 = v58 ? *(_DWORD *)(v60
                                    + 4
                                    * (*(_DWORD *)(v58 + 4 * ((unsigned int)*(_WORD *)(v59 + 2) >> 8))
                                     + (unsigned __int16)(v10 & *(_WORD *)(v59 + 2)))) : *(_DWORD *)(v60 + 4 * *(_WORD *)(v59 + 2));
              v57 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 12) - 1;
              if ( !((v95 ^ v62) & 0xE7FFFFFF) )
                v101 = 1;
            }
            if ( v57 >= 0 )
            {
              while ( 1 )
              {
                v63 = (v108 + v124) / 2;
                v64 = NlsCompareRgWChar(2 * v101 + *(_DWORD *)(v4 + 16), v91 + 12 * v63, 4);
                if ( !v64 )
                  break;
                if ( v64 >= 0 )
                  v108 = v63 + 1;
                else
                  v124 = v63 - 1;
                if ( v108 > v124 )
                  goto LABEL_125;
              }
              *(_DWORD *)(v4 + 24) = *(_DWORD *)(12 * v63 + v91 + 8);
              if ( !v101 )
                *(_DWORD *)(v4 + 16) += 6;
LABEL_174:
              v111 = *(unsigned __int16 **)(v4 + 16);
              *(_DWORD *)(v4 + 16) = v90;
              goto LABEL_175;
            }
          }
        }
      }
    }
LABEL_125:
    v65 = *(_DWORD *)a1;
    v96 = *(_DWORD *)(*(_DWORD *)a1 + 252);
    if ( !*(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 10) )
      goto LABEL_148;
    v66 = *(unsigned __int16 **)(v4 + 16);
    v125 = *(_DWORD *)(v65 + 236);
    v67 = *(_DWORD *)(v4 + 4);
    if ( (unsigned int)&v66[3 - (v125 == 0)] > v67 )
      goto LABEL_148;
    if ( !v128 )
      v128 = NlsCountOfWCharsWithinRange(
               v66,
               v67,
               3,
               *(_WORD *)(*(_DWORD *)(v65 + 244) + 4),
               *(_WORD *)(*(_DWORD *)(v65 + 244) + 6),
               v125,
               *(_DWORD *)(v4 + 8));
    if ( v128 < 3 )
      goto LABEL_148;
    v68 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 10) - 1;
    v109 = 0;
    v102 = 0;
    v126 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 10) - 1;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v128 >= 4 )
    {
      v69 = *(_DWORD *)(*(_DWORD *)a1 + 224);
      v70 = *(_DWORD *)(v4 + 16);
      if ( v69 )
      {
        v71 = (*pSortTblPtrs)[11];
        v72 = *(_DWORD *)(v69 + 4 * ((unsigned int)*(_WORD *)v70 >> 8)) + (unsigned __int16)(v10 & *(_WORD *)v70);
        v10 = 255;
      }
      else
      {
        v71 = (*pSortTblPtrs)[11];
        v72 = *(_WORD *)v70;
      }
      v92 = *(_DWORD *)(v71 + 4 * v72);
      v73 = v69 ? *(_DWORD *)(v71
                            + 4
                            * (*(_DWORD *)(v69 + 4 * ((unsigned int)*(_WORD *)(v70 + 2) >> 8))
                             + (unsigned __int16)(v10 & *(_WORD *)(v70 + 2)))) : *(_DWORD *)(v71
                                                                                           + 4 * *(_WORD *)(v70 + 2));
      v68 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 10) - 1;
      if ( !((v92 ^ v73) & 0xE7FFFFFF) )
        v109 = 1;
    }
    if ( v68 >= 0 )
    {
      while ( 1 )
      {
        v74 = (v102 + v126) / 2;
        v75 = NlsCompareRgWChar(2 * v109 + *(_DWORD *)(v4 + 16), v96 + 12 * v74, 3);
        if ( !v75 )
          break;
        if ( v75 >= 0 )
          v102 = v74 + 1;
        else
          v126 = v74 - 1;
        if ( v102 > v126 )
          goto LABEL_148;
      }
      *(_DWORD *)(v4 + 24) = *(_DWORD *)(12 * v74 + v96 + 8);
      if ( !v109 )
        *(_DWORD *)(v4 + 16) += 4;
    }
    else
    {
LABEL_148:
      v76 = *(_DWORD *)a1;
      v97 = *(_DWORD *)(*(_DWORD *)a1 + 248);
      if ( !*(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 8) )
        goto LABEL_175;
      v77 = *(unsigned __int16 **)(v4 + 16);
      v127 = *(_DWORD *)(v76 + 236);
      v78 = *(_DWORD *)(v4 + 4);
      if ( (unsigned int)&v77[2 - (v127 == 0)] > v78 )
        goto LABEL_175;
      v79 = v128;
      if ( !v128 )
        v79 = NlsCountOfWCharsWithinRange(
                v77,
                v78,
                2,
                *(_WORD *)(*(_DWORD *)(v76 + 244) + 4),
                *(_WORD *)(*(_DWORD *)(v76 + 244) + 6),
                v127,
                *(_DWORD *)(v4 + 8));
      if ( v79 < 2 )
        goto LABEL_175;
      v80 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 8) - 1;
      v110 = 0;
      v103 = 0;
      v129 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 8) - 1;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 236) && v79 >= 3 )
      {
        v81 = *(_DWORD *)(*(_DWORD *)a1 + 224);
        v82 = *(_DWORD *)(v4 + 16);
        if ( v81 )
        {
          v83 = (*pSortTblPtrs)[11];
          v84 = *(_DWORD *)(v81 + 4 * ((unsigned int)*(_WORD *)v82 >> 8)) + (unsigned __int16)(v10 & *(_WORD *)v82);
          v10 = 255;
        }
        else
        {
          v83 = (*pSortTblPtrs)[11];
          v84 = *(_WORD *)v82;
        }
        v93 = *(_DWORD *)(v83 + 4 * v84);
        v85 = v81 ? *(_DWORD *)(v83
                              + 4
                              * (*(_DWORD *)(v81 + 4 * ((unsigned int)*(_WORD *)(v82 + 2) >> 8))
                               + (unsigned __int16)(v10 & *(_WORD *)(v82 + 2)))) : *(_DWORD *)(v83
                                                                                             + 4 * *(_WORD *)(v82 + 2));
        v80 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)a1 + 244) + 8) - 1;
        if ( !((v93 ^ v85) & 0xE7FFFFFF) )
          v110 = 1;
      }
      if ( v80 < 0 )
        goto LABEL_175;
      while ( 1 )
      {
        v86 = (v103 + v129) / 2;
        v87 = NlsCompareRgWChar(2 * v110 + *(_DWORD *)(v4 + 16), v97 + 8 * v86, 2);
        if ( !v87 )
          break;
        if ( v87 >= 0 )
          v103 = v86 + 1;
        else
          v129 = v86 - 1;
        if ( v103 > v129 )
          goto LABEL_175;
      }
      *(_DWORD *)(v4 + 24) = *(_DWORD *)(v97 + 8 * v86 + 4);
      if ( !v110 )
        *(_DWORD *)(v4 + 16) += 2;
    }
    goto LABEL_174;
  }
  return 0;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E853D5) --------------------------------------------------------
int __stdcall MapCase(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // edx@5
  int v7; // [sp+14h] [bp+14h]@4

  result = a2;
  if ( a4 )
  {
    if ( a2 <= a4 )
    {
      v7 = 0;
      if ( a2 > 0 )
      {
        v6 = a1;
        v7 = a2;
        do
        {
          *(_WORD *)(a3 - a1 + v6) = *(_WORD *)v6
                                   + *(_WORD *)(a5
                                              + 2
                                              * ((*(_BYTE *)v6 & 0xF)
                                               + *(_WORD *)(a5
                                                          + 2
                                                          * (((unsigned int)*(_BYTE *)v6 >> 4)
                                                           + *(_WORD *)(a5 + 2 * (unsigned __int8)(*(_WORD *)v6 >> 8))))));
          v6 += 2;
          --a2;
        }
        while ( a2 );
      }
      result = v7;
    }
    else
    {
      SetLastError(0x7Au);
      result = 0;
    }
  }
  return result;
}

//----- (77E85453) --------------------------------------------------------
int __stdcall MapIsLetter(__int16 a1)
{
  return *(_WORD *)(6
                  * *(_BYTE *)((a1 & 0xF)
                             + (*pSortTblPtrs)[20]
                             + *(_WORD *)((*pSortTblPtrs)[20]
                                        + 2
                                        * (((unsigned int)(unsigned __int8)a1 >> 4)
                                         + ((unsigned int)*(_WORD *)((*pSortTblPtrs)[20] + 2 * HIBYTE(a1)) >> 1))))
                  + (*pSortTblPtrs)[19]) & 0x100;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E854A3) --------------------------------------------------------
int __stdcall MapIsWordBreak(__int16 a1)
{
  __int16 v1; // ax@3
  int result; // eax@3

  if ( a1 == 39 || a1 == 8217 )
  {
    result = 0;
  }
  else
  {
    v1 = *(_WORD *)(6
                  * *(_BYTE *)((a1 & 0xF)
                             + (*pSortTblPtrs)[20]
                             + *(_WORD *)((*pSortTblPtrs)[20]
                                        + 2
                                        * (((unsigned int)(unsigned __int8)a1 >> 4)
                                         + ((unsigned int)*(_WORD *)((*pSortTblPtrs)[20] + 2 * HIBYTE(a1)) >> 1))))
                  + (*pSortTblPtrs)[19]);
    result = v1 & 0x38;
  }
  return result;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E85505) --------------------------------------------------------
signed int __stdcall MapTitleCase(__int16 *a1, signed int a2, int a3, signed int a4, int a5, int a6)
{
  signed int v6; // edi@1
  __int16 *v8; // ecx@6
  __int16 *v9; // esi@10
  __int16 v10; // dx@12
  signed __int16 v11; // ax@19
  int v12; // ecx@33
  int v13; // eax@33
  int v14; // ecx@39
  int v15; // eax@39
  signed int v16; // [sp+8h] [bp-8h]@1
  int v17; // [sp+Ch] [bp-4h]@10
  signed int v18; // [sp+24h] [bp+14h]@6
  signed int v19; // [sp+24h] [bp+14h]@9

  v6 = 0;
  v16 = 0;
  if ( !a4 )
    return a2;
  if ( a2 > a4 )
  {
    SetLastError(0x7Au);
    return 0;
  }
  if ( a2 > 0 )
  {
    v8 = a1;
    v18 = a2;
    do
    {
      *(__int16 *)((char *)v8 + a3 - (_DWORD)a1) = *v8
                                                 + *(_WORD *)(a6
                                                            + 2
                                                            * ((*(_BYTE *)v8 & 0xF)
                                                             + *(_WORD *)(a6
                                                                        + 2
                                                                        * (((unsigned int)*(_BYTE *)v8 >> 4)
                                                                         + *(_WORD *)(a6
                                                                                    + 2
                                                                                    * (unsigned __int8)((unsigned __int16)*v8 >> 8))))));
      ++v8;
      --v18;
    }
    while ( v18 );
    v6 = 0;
  }
  v19 = 0;
  if ( a2 <= 0 )
  {
LABEL_38:
    if ( v6 < v19 )
    {
      v14 = a3 + 2 * v6;
      v15 = v19 - v6;
      do
      {
        *(_WORD *)v14 = *(__int16 *)((char *)a1 + v14 - a3);
        v14 += 2;
        --v15;
      }
      while ( v15 );
    }
    return v19;
  }
  v9 = a1;
  v17 = a3 - (_DWORD)a1;
  do
  {
    if ( !v16 )
    {
      v10 = *v9
          + *(_WORD *)(a5
                     + 2
                     * ((*(_BYTE *)v9 & 0xF)
                      + *(_WORD *)(a5
                                 + 2
                                 * (((unsigned int)*(_BYTE *)v9 >> 4)
                                  + *(_WORD *)(a5 + 2 * (unsigned __int8)((unsigned __int16)*v9 >> 8))))));
      *(__int16 *)((char *)v9 + v17) = v10;
      if ( v10 == *v9 )
        v6 = v19;
      else
        v6 = -1;
      switch ( v10 )
      {
        case 452:
          v11 = 453;
          break;
        case 455:
          v11 = 456;
          break;
        case 458:
          v11 = 459;
          break;
        default:
          if ( v10 != 497 )
            goto LABEL_24;
          v11 = 498;
          break;
      }
      *(__int16 *)((char *)v9 + v17) = v11;
LABEL_24:
      if ( MapIsLetter(*v9) )
        v16 = 1;
      goto LABEL_36;
    }
    if ( MapIsLetter(*v9) )
    {
      if ( v6 >= 0 && *(__int16 *)((char *)v9 + v17) == *v9 )
        v6 = -1;
    }
    else if ( MapIsWordBreak(*v9) )
    {
      v16 = 0;
      if ( v6 >= 0 )
      {
        if ( v6 < v19 )
        {
          v12 = a3 + 2 * v6;
          v13 = v19 - v6;
          do
          {
            *(_WORD *)v12 = *(__int16 *)((char *)a1 + v12 - a3);
            v12 += 2;
            --v13;
          }
          while ( v13 );
        }
        v6 = -1;
      }
    }
LABEL_36:
    ++v19;
    ++v9;
  }
  while ( v19 < a2 );
  if ( v6 >= 0 )
    goto LABEL_38;
  return v19;
}

//----- (77E856DF) --------------------------------------------------------
signed int __stdcall SortChangeCase(int a1, int a2, int a3, signed int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@1
  unsigned int v9; // edx@9
  int v10; // edx@14
  int v11; // ecx@17
  int v13; // ecx@21

  v8 = a4;
  if ( !a4 || a6 < 0 || !a3 || a6 && !a5 )
    goto LABEL_31;
  if ( a4 <= -1 )
    v8 = SortNlsStrLenW((void *)a3) + 1;
  if ( !a1 )
  {
LABEL_31:
    SetLastError(0x57u);
    return 0;
  }
  v9 = a2 & 0xFEFFFFFF;
  if ( (a2 & 0xFEFFFFFF) == 256 )
  {
    if ( a2 & 0x1000000 )
      v13 = *(_DWORD *)(a1 + 212);
    else
      v13 = *(_DWORD *)(a1 + 220);
    return MapCase(a3, v8, a5, a6, v13);
  }
  if ( v9 == 512 )
  {
    if ( a2 & 0x1000000 )
      v13 = *(_DWORD *)(a1 + 208);
    else
      v13 = *(_DWORD *)(a1 + 216);
    return MapCase(a3, v8, a5, a6, v13);
  }
  if ( v9 != 768 )
  {
    SetLastError(0x3ECu);
    return 0;
  }
  if ( a2 & 0x1000000 )
    v10 = *(_DWORD *)(a1 + 212);
  else
    v10 = *(_DWORD *)(a1 + 220);
  if ( a2 & 0x1000000 )
    v11 = *(_DWORD *)(a1 + 208);
  else
    v11 = *(_DWORD *)(a1 + 216);
  return MapTitleCase((__int16 *)a3, v8, a5, a6, v11, v10);
}

//----- (77E857E2) --------------------------------------------------------
int __stdcall UpdateJamoState(int a1, int a2, int a3)
{
  int result; // eax@1
  char v4; // dl@1
  char v5; // dl@3
  char v6; // dl@5
  unsigned __int8 v7; // cl@10
  unsigned __int8 v8; // cl@12
  unsigned __int8 v9; // cl@14

  result = a3;
  *(_BYTE *)result |= *(_BYTE *)a2;
  v4 = *(_BYTE *)(a2 + 1);
  if ( v4 > *(_BYTE *)(a3 + 8) )
    *(_BYTE *)(a3 + 8) = v4;
  v5 = *(_BYTE *)(a2 + 2);
  if ( v5 > *(_BYTE *)(a3 + 9) )
    *(_BYTE *)(a3 + 9) = v5;
  v6 = *(_BYTE *)(a2 + 3);
  if ( v6 > *(_BYTE *)(a3 + 10) )
    *(_BYTE *)(a3 + 10) = v6;
  switch ( a1 )
  {
    case 1:
      v9 = *(_BYTE *)(a2 + 4);
      if ( v9 > *(_BYTE *)(a3 + 11) )
        *(_BYTE *)(a3 + 11) = v9;
      break;
    case 2:
      v8 = *(_BYTE *)(a2 + 4);
      if ( v8 > *(_BYTE *)(a3 + 12) )
        *(_BYTE *)(a3 + 12) = v8;
      break;
    case 3:
      v7 = *(_BYTE *)(a2 + 4);
      if ( v7 > *(_BYTE *)(a3 + 13) )
        *(_BYTE *)(a3 + 13) = v7;
      break;
  }
  return result;
}

//----- (77E8584C) --------------------------------------------------------
int __stdcall GetJamoComposition(unsigned __int16 **a1, unsigned int a2, int a3, int a4)
{
  unsigned __int16 **v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  unsigned __int16 *v7; // eax@1
  unsigned __int16 v8; // ax@2
  int result; // eax@7
  int v10; // [sp+Ch] [bp-4h]@1
  int v11; // [sp+18h] [bp+8h]@3

  v4 = a1;
  v5 = (*pSortTblPtrs)[22] + 8 * **a1 - 34816;
  v6 = 0;
  v10 = 0;
  UpdateJamoState(a3, v5, a4);
  ++*v4;
  v7 = *a1;
  if ( (unsigned int)*a1 >= a2 )
    return (a3 != 1) - 1;
LABEL_2:
  v8 = *v7;
  if ( !v8 )
    return (a3 != 1) - 1;
  v11 = v8;
  if ( !IsCombiningJamo(v8) )
    return (a3 != 1) - 1;
  if ( (_WORD)v11 == 4448 )
    *(_DWORD *)(a4 + 4) = 1;
  if ( (unsigned __int16)v11 >= 0x1160u )
    result = 3 - ((unsigned __int16)v11 < 0x11A8u);
  else
    result = 1;
  if ( result == a3 )
  {
    if ( v6 )
      goto LABEL_13;
    if ( *(_BYTE *)(v5 + 5) )
    {
      v6 = (*pSortTblPtrs)[23] + 8 * *(_BYTE *)(v5 + 5);
      v10 = v6 + 8 * *(_BYTE *)(v5 + 6);
LABEL_13:
      while ( v6 < (unsigned int)v10 )
      {
        if ( *(_WORD *)v6 == (_WORD)v11 )
        {
          UpdateJamoState(a3, v6 + 2, a4);
          ++*v4;
          v7 = *v4;
          v6 += 8;
          if ( (unsigned int)*v4 < a2 )
            goto LABEL_2;
          return (a3 != 1) - 1;
        }
        v6 += 8 * *(_BYTE *)(v6 + 7) + 8;
      }
    }
  }
  return result;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E8594F) --------------------------------------------------------
int __stdcall MapOldHangulSortKey(int a1, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned int v6; // eax@7
  int v7; // ecx@11
  int v8; // eax@12
  char v9; // cl@14
  char v10; // cl@16
  char v11; // cl@18
  int result; // eax@20
  int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+14h] [bp-Ch]@1
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@1

  v17 = a2;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v5 = GetJamoComposition((unsigned __int16 **)&v17, a3, 1, (int)&v13);
  if ( v5 == 2 )
    v5 = GetJamoComposition((unsigned __int16 **)&v17, a3, 2, (int)&v13);
  if ( v5 == 3 )
    GetJamoComposition((unsigned __int16 **)&v17, a3, 3, (int)&v13);
  if ( v5 != -1 && (_BYTE)v13 )
  {
    LOWORD(v6) = SBYTE2(v15) + 28 * (SBYTE1(v15) + 21 * (char)v15) - 21504;
    if ( v14 )
    {
      LOWORD(v6) = SBYTE2(v15) + 28 * (SBYTE1(v15) + 21 * (char)v15) - 21505;
      if ( (unsigned __int16)v6 < 0xAC00u )
        LOWORD(v6) = 12910;
      BYTE3(v15) += -128;
    }
    v7 = *(_DWORD *)(a1 + 224);
    v6 = (unsigned __int16)v6;
    if ( v7 )
      v8 = (*pSortTblPtrs)[11] + 4 * ((unsigned __int8)v6 + *(_DWORD *)(v7 + 4 * (v6 >> 8)));
    else
      v8 = (*pSortTblPtrs)[11] + 4 * v6;
    *(_WORD *)a4 = *(_WORD *)v8;
    v9 = BYTE3(v15);
    if ( BYTE3(v15) <= 2u )
      v9 = 2;
    *(_BYTE *)a5 = v9;
    v10 = v16;
    if ( (unsigned __int8)v16 <= 2u )
      v10 = 2;
    *(_BYTE *)(a5 + 1) = v10;
    v11 = BYTE1(v16);
    if ( BYTE1(v16) <= 2u )
      v11 = 2;
    *(_BYTE *)(a5 + 2) = v11;
    result = (v17 - a2) >> 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77E2FD84: using guessed type int (*pSortTblPtrs)[30];

//----- (77E85A8B) --------------------------------------------------------
BOOLEAN __stdcall InternalSortCloseHandle(PVOID Address)
{
  BOOLEAN result; // al@4

  if ( Address )
  {
    if ( *((PVOID *)Address + 69) != Address )
      InternalSortCloseHandle(*((PVOID *)Address + 69));
    result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return result;
}

//----- (77E85AC7) --------------------------------------------------------
int __stdcall LookupHandlerByOrdinal(unsigned __int32 a1, const struct _DLOAD_ORDINAL_MAP *a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edi@2
  int v6; // eax@3
  unsigned __int32 v7; // edx@3

  v2 = 0;
  v3 = 0;
  v4 = *(_DWORD *)a2 - 1;
  if ( v4 >= 0 )
  {
    v5 = *((_DWORD *)a2 + 1);
    do
    {
      v6 = (v4 + v3) / 2;
      v7 = *(_DWORD *)(v5 + 8 * v6);
      if ( a1 >= v7 )
      {
        if ( a1 <= v7 )
          return *(_DWORD *)(v5 + 8 * v6 + 4);
        v3 = v6 + 1;
      }
      else
      {
        v4 = v6 - 1;
      }
    }
    while ( v4 >= v3 );
  }
  return v2;
}

//----- (77E85B29) --------------------------------------------------------
BOOL __stdcall WTSSetListenerSecurityA(HANDLE hServer, PVOID pReserved, DWORD Reserved, LPSTR pListenerName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85B3D) --------------------------------------------------------
BOOL __stdcall WTSGetListenerSecurityA(HANDLE hServer, PVOID pReserved, DWORD Reserved, LPSTR pListenerName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85B51) --------------------------------------------------------
BOOL __stdcall WTSQuerySessionInformationA(HANDLE hServer, DWORD SessionId, WTS_INFO_CLASS WTSInfoClass, LPSTR *ppBuffer, DWORD *pBytesReturned)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85B65) --------------------------------------------------------
BOOL __stdcall WTSFreeMemoryExW(WTS_TYPE_CLASS WTSTypeClass, PVOID pMemory, ULONG NumberOfEntries)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85B8D) --------------------------------------------------------
int __stdcall sub_77E85B8D(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E85BB6) --------------------------------------------------------
BOOL __stdcall WTSEnumerateSessionsW(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFOW *ppSessionInfo, DWORD *pCount)
{
  if ( ppSessionInfo )
    *ppSessionInfo = 0;
  if ( pCount )
    *pCount = 0;
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85BE4) --------------------------------------------------------
HANDLE __stdcall WTSOpenServerA(LPSTR pServerName)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85BF8) --------------------------------------------------------
BOOL __stdcall WTSQueryUserToken(ULONG SessionId, PHANDLE phToken)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85C0C) --------------------------------------------------------
BOOL __stdcall WTSSendMessageA(HANDLE hServer, DWORD SessionId, LPSTR pTitle, DWORD TitleLength, LPSTR pMessage, DWORD MessageLength, DWORD Style, DWORD Timeout, DWORD *pResponse, BOOL bWait)
{
  SetLastError(0x65Au);
  return 0;
}

//----- (77E85C20) --------------------------------------------------------
int __stdcall DebugTest(unsigned __int16 a1, char *a2)
{
  return 0;
}

//----- (77E85C2A) --------------------------------------------------------
signed int __stdcall sub_77E85C2A(int a1, int a2)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return -2147024769;
}

//----- (77E85C47) --------------------------------------------------------
signed int __stdcall sub_77E85C47(int a1, int a2, int a3, int a4, int a5)
{
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return -2147024769;
}

//----- (77E85C64) --------------------------------------------------------
signed int __stdcall MFCreateVideoPresenter2(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147024769;
}

//----- (77E85C81) --------------------------------------------------------
signed int __stdcall sub_77E85C81(int a1)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return -2147024769;
}

//----- (77E85C9E) --------------------------------------------------------
signed int __stdcall FmsMapGdiLogicalFont(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147024769;
}

//----- (77E85CBB) --------------------------------------------------------
signed int __stdcall sub_77E85CBB(int a1, int a2, int a3, int a4)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147024769;
}

//----- (77E85D35) --------------------------------------------------------
signed int __stdcall sub_77E85D35(int a1, int a2)
{
  *(_DWORD *)a2 = 10014;
  return -1;
}

//----- (77E85D4F) --------------------------------------------------------
signed int __stdcall sub_77E85D4F(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a4 = 10014;
  return -1;
}

//----- (77E85D69) --------------------------------------------------------
signed int __stdcall sub_77E85D69(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a7 = 127;
  return -1;
}

//----- (77E85D8E) --------------------------------------------------------
signed int __stdcall sub_77E85D8E(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a5 = 10014;
  return -1;
}

//----- (77E85DA8) --------------------------------------------------------
signed int __stdcall sub_77E85DA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a8 = 127;
  return -1;
}

//----- (77E85DC2) --------------------------------------------------------
signed int __stdcall sub_77E85DC2(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a6 = 127;
  return -1;
}

//----- (77E85DE7) --------------------------------------------------------
unsigned int __stdcall sub_77E85DE7(unsigned __int16 a1)
{
  return ((unsigned int)a1 >> 8) | ((unsigned __int8)a1 << 8);
}

//----- (77E85E08) --------------------------------------------------------
signed int __stdcall sub_77E85E08(int a1, int a2, int a3)
{
  SetLastError(0x7Fu);
  return -1;
}

//----- (77E85E1A) --------------------------------------------------------
unsigned int __stdcall sub_77E85E1A(unsigned int a1)
{
  return (((a1 >> 16) | a1 & 0xFF0000) >> 8) | (((a1 << 16) | (unsigned __int16)(a1 & 0xFF00)) << 8);
}

//----- (77E85E60) --------------------------------------------------------
int __stdcall sub_77E85E60(int a1, void *Dst, int a3, int a4, int a5)
{
  if ( a3 && Dst )
    memset(Dst, 0, *(_DWORD *)a3);
  DelayLoad_SetLastNtStatusAndWin32Error();
  return -1;
}

//----- (77E85EC2) --------------------------------------------------------
int __stdcall sub_77E85EC2(int a1, int a2, void *Dst)
{
  memset(Dst, 0, 0x2Cu);
  DelayLoad_SetLastNtStatusAndWin32Error();
  return -1;
}

//----- (77E85F48) --------------------------------------------------------
signed int __cdecl sub_77E85F48(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a7 = 0;
  return 90;
}

//----- (77E85F5D) --------------------------------------------------------
signed int __cdecl sub_77E85F5D(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a8 = 0;
  return 90;
}

//----- (77E86014) --------------------------------------------------------
char __stdcall IsAnimationsEnabled()
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86056) --------------------------------------------------------
char __stdcall IsPalette(int a1)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86078) --------------------------------------------------------
int __stdcall FaxStartMessagesEnum(int a1, int a2, int a3)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E860AD) --------------------------------------------------------
DWORD __stdcall WlanExtractPsdIEDataList(HANDLE hClientHandle, DWORD dwIeDataSize, const PBYTE pRawIeData, LPCWSTR strFormat, PVOID pReserved, PWLAN_RAW_DATA_LIST *ppPsdIEDataList)
{
  return 127;
}

//----- (77E860B8) --------------------------------------------------------
signed int __stdcall sub_77E860B8(int a1, int a2, int a3, int a4)
{
  return 1;
}

//----- (77E860C3) --------------------------------------------------------
int __stdcall sub_77E860C3(int a1, int a2, int a3)
{
  if ( a2 )
    *(_DWORD *)(a2 + 12) = 272;
  return 0;
}

//----- (77E860EE) --------------------------------------------------------
MMRESULT __stdcall mixerGetID(HMIXEROBJ hmxobj, UINT *puMxId, DWORD fdwId)
{
  return 1;
}

//----- (77E860F9) --------------------------------------------------------
signed int __stdcall sub_77E860F9(int a1, int a2, int a3, int a4, int a5, char a6)
{
  if ( !(a6 & 1) )
  {
    if ( !a1 )
      return 11;
    *(_DWORD *)a1 = 0;
  }
  return 1;
}

//----- (77E8612A) --------------------------------------------------------
signed int __stdcall sub_77E8612A(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    result = 1;
  }
  else
  {
    result = 11;
  }
  return result;
}

//----- (77E8615D) --------------------------------------------------------
HANDLE __stdcall FindFirstUrlCacheEntryExA(LPCSTR lpszUrlSearchPattern, DWORD dwFlags, DWORD dwFilter, GROUPID GroupId, LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo, LPDWORD lpcbEntryInfo, LPVOID lpGroupAttributes, LPDWORD lpcbGroupAttributes, LPVOID lpReserved)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E861B7) --------------------------------------------------------
void __stdcall FXSAPIFree()
{
  SetLastError(0x7Fu);
}

//----- (77E861C4) --------------------------------------------------------
int __stdcall sub_77E861C4(int a1, int a2, int a3, int a4)
{
  if ( a3 && a4 > 0 )
    *(_WORD *)a3 = 0;
  return 0;
}

//----- (77E861E6) --------------------------------------------------------
signed int __stdcall sub_77E861E6(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a8 )
    *(_DWORD *)a8 = 0;
  return -2147467259;
}

//----- (77E86203) --------------------------------------------------------
signed int __stdcall sub_77E86203(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 2;
  return -2147467259;
}

//----- (77E86223) --------------------------------------------------------
signed int __stdcall sub_77E86223(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147467259;
}

//----- (77E86240) --------------------------------------------------------
signed int __stdcall sub_77E86240(int a1, int a2, int a3)
{
  if ( a2 )
    *(_WORD *)a2 = 0;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147467259;
}

//----- (77E86269) --------------------------------------------------------
signed int __stdcall sub_77E86269(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 4;
  return -2147467259;
}

//----- (77E86289) --------------------------------------------------------
signed int __stdcall sub_77E86289(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147467259;
}

//----- (77E862A6) --------------------------------------------------------
signed int __stdcall sub_77E862A6(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147467263;
}

//----- (77E862C3) --------------------------------------------------------
signed int __stdcall sub_77E862C3(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 4;
  return -2147467259;
}

//----- (77E862E3) --------------------------------------------------------
signed int __stdcall sub_77E862E3(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a7 )
    *(_DWORD *)a7 = 4;
  return -2147467259;
}

//----- (77E86392) --------------------------------------------------------
signed int __stdcall sub_77E86392(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  return 127;
}

//----- (77E863AD) --------------------------------------------------------
signed int __stdcall sub_77E863AD(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a5 = 0;
  *(_DWORD *)(a5 + 4) = 0;
  return 127;
}

//----- (77E863C8) --------------------------------------------------------
signed int __stdcall sub_77E863C8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a6 = 0;
  return 127;
}

//----- (77E863DF) --------------------------------------------------------
signed int __stdcall sub_77E863DF(int a1, int a2, int a3)
{
  *(_WORD *)a3 = 0;
  *(_WORD *)(a3 + 2) = 0;
  return 127;
}

//----- (77E863FC) --------------------------------------------------------
signed int __stdcall sub_77E863FC(int a1, int a2, int a3)
{
  *(_WORD *)a3 = 0;
  return 127;
}

//----- (77E86415) --------------------------------------------------------
signed int __stdcall sub_77E86415(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a5 = 0;
  return 127;
}

//----- (77E8642C) --------------------------------------------------------
signed int __stdcall sub_77E8642C(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a7 = 0;
  return 127;
}

//----- (77E86443) --------------------------------------------------------
signed int __stdcall sub_77E86443(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a6 = 0;
  return 127;
}

//----- (77E8645A) --------------------------------------------------------
signed int __stdcall sub_77E8645A(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  return 127;
}

//----- (77E86471) --------------------------------------------------------
signed int __stdcall sub_77E86471(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a6 = 0;
  *(_DWORD *)a7 = 0;
  return 127;
}

//----- (77E8649B) --------------------------------------------------------
signed int __stdcall sub_77E8649B(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147023611;
}

//----- (77E864B8) --------------------------------------------------------
signed int __stdcall sub_77E864B8(int a1, int a2, int a3)
{
  return -2147023611;
}

//----- (77E864D2) --------------------------------------------------------
signed int __stdcall sub_77E864D2(int a1, int a2, int a3, int a4)
{
  int v4; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v4 = a2 + 8;
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
  }
  if ( a3 )
    *(_DWORD *)a3 = -2147467259;
  if ( a4 )
    *(_DWORD *)a4 = 4;
  return -2147023611;
}

//----- (77E8650E) --------------------------------------------------------
signed int __stdcall sub_77E8650E(int a1, int a2)
{
  int v2; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v2 = a2 + 8;
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
  }
  return -2147023611;
}

//----- (77E86530) --------------------------------------------------------
signed int __stdcall sub_77E86530(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147023611;
}

//----- (77E8654D) --------------------------------------------------------
signed int __stdcall sub_77E8654D(int a1, int a2, int a3)
{
  int v3; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v3 = a2 + 8;
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
  }
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147023611;
}

//----- (77E86579) --------------------------------------------------------
signed int __stdcall sub_77E86579(int a1, int a2, int a3)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147023611;
}

//----- (77E865A0) --------------------------------------------------------
signed int __stdcall sub_77E865A0(int a1, int a2, int a3)
{
  int v3; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v3 = a2 + 8;
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
  }
  return -2147023611;
}

//----- (77E865C2) --------------------------------------------------------
signed int __stdcall sub_77E865C2(int a1, int a2, int a3, int a4, int a5)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return -2147023611;
}

//----- (77E86619) --------------------------------------------------------
signed int __stdcall sub_77E86619(int a1, int a2, int a3)
{
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
  }
  return -2147023611;
}

//----- (77E86639) --------------------------------------------------------
signed int __stdcall sub_77E86639(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147023611;
}

//----- (77E86656) --------------------------------------------------------
signed int __stdcall sub_77E86656(int a1, int a2, int a3)
{
  int v3; // edi@2

  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    v3 = a3 + 8;
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
  }
  return -2147023611;
}

//----- (77E86678) --------------------------------------------------------
int __stdcall sub_77E86678(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return 0;
}

//----- (77E8669C) --------------------------------------------------------
int __stdcall sub_77E8669C(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_BYTE *)a4 = 0;
  return 0;
}

//----- (77E866B6) --------------------------------------------------------
int __stdcall sub_77E866B6(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return 0;
}

//----- (77E866DA) --------------------------------------------------------
DWORD __stdcall MprAdminConnectionEnum(RAS_SERVER_HANDLE hRasServer, DWORD dwLevel, LPBYTE *lplpbBuffer, DWORD dwPrefMaxLen, LPDWORD lpdwEntriesRead, LPDWORD lpdwTotalEntries, LPDWORD lpdwResumeHandle)
{
  return 127;
}

//----- (77E866F0) --------------------------------------------------------
signed int __stdcall sub_77E866F0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  return -2147024769;
}

//----- (77E8670A) --------------------------------------------------------
int __stdcall sub_77E8670A(int a1, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)a3;
  *(_WORD *)(a2 + 2 * *(_DWORD *)a3 - 2) = 0;
  return result;
}

//----- (77E8676C) --------------------------------------------------------
INT __stdcall WSCInstallNameSpaceEx(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId, LPBLOB lpProviderSpecific)
{
  SetLastError(0x7Fu);
  return -1;
}

//----- (77E86790) --------------------------------------------------------
void __stdcall InitializeIpForwardEntry(PMIB_IPFORWARD_ROW2 Row)
{
  SetLastError(0x7Fu);
}

//----- (77E867B7) --------------------------------------------------------
int __stdcall GetElementMacro(int a1)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E867D7) --------------------------------------------------------
signed int __stdcall sub_77E867D7(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a1 && a3 )
    *(_DWORD *)a3 = 0;
  else
    result = -2147024809;
  return result;
}

//----- (77E86801) --------------------------------------------------------
signed int __stdcall sub_77E86801(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = -2147467263;
  if ( a3 && a4 )
    *(_DWORD *)a4 = 0;
  else
    result = -2147024809;
  return result;
}

//----- (77E8682B) --------------------------------------------------------
signed int __stdcall sub_77E8682B(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // edi@3

  result = -2147467263;
  if ( a2 && a3 )
  {
    *(_DWORD *)a3 = GUID_NULL.Data1;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)&GUID_NULL.Data2;
    v4 = a3 + 8;
    *(_DWORD *)v4 = *(_DWORD *)&GUID_NULL.Data4[0];
    *(_DWORD *)(v4 + 4) = *(_DWORD *)&GUID_NULL.Data4[4];
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (77E8685F) --------------------------------------------------------
signed int __stdcall sub_77E8685F(int a1, int a2, int a3)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( !a1 )
    result = -2147024809;
  if ( a3 )
    result = -2147467261;
  else
    v0 = 0;
  return result;
}

//----- (77E8688C) --------------------------------------------------------
signed int __stdcall sub_77E8688C(int a1, int a2, int a3)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147024882;
}

//----- (77E868B6) --------------------------------------------------------
signed int __stdcall sub_77E868B6(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a6 && a4 )
  {
    if ( !a1 )
      result = -2147024809;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (77E86901) --------------------------------------------------------
signed int __stdcall sub_77E86901(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( !a1 || !a2 )
    result = -2147467261;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  else
    result = -2147467261;
  return result;
}

//----- (77E86935) --------------------------------------------------------
signed int __stdcall sub_77E86935(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  else
    result = -2147467261;
  return result;
}

//----- (77E86959) --------------------------------------------------------
signed int __stdcall sub_77E86959(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // edi@2

  if ( a7 )
  {
    *(_DWORD *)a7 = 0;
    *(_DWORD *)(a7 + 4) = 0;
    v7 = a7 + 8;
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
  }
  return -2147024769;
}

//----- (77E8697B) --------------------------------------------------------
signed int __stdcall RsopFileAccessCheckInternal(unsigned __int16 *a1, void *a2, unsigned __int32 a3, unsigned __int32 *a4, int *a5)
{
  return -2147024769;
}

//----- (77E86988) --------------------------------------------------------
signed int __stdcall sub_77E86988(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  else
    result = -2147467261;
  return result;
}

//----- (77E869AC) --------------------------------------------------------
int __stdcall sub_77E869AC(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return 0;
}

//----- (77E869C6) --------------------------------------------------------
BOOL __stdcall sub_77E869C6(unsigned int a1)
{
  return a1 <= 0xE;
}

//----- (77E869DD) --------------------------------------------------------
BOOL __stdcall sub_77E869DD(int a1)
{
  return (unsigned int)(a1 - 15) <= 3;
}

//----- (77E869F9) --------------------------------------------------------
signed int __stdcall sub_77E869F9(int a1, int a2, int a3, int a4)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147024769;
}

//----- (77E86A16) --------------------------------------------------------
signed int __stdcall sub_77E86A16(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( !a4 || !a5 || !a3 )
    result = -2147024809;
  return result;
}

//----- (77E86A3F) --------------------------------------------------------
signed int __stdcall sub_77E86A3F(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  else
    result = -2147467261;
  return result;
}

//----- (77E86A63) --------------------------------------------------------
signed int __stdcall sub_77E86A63(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@1

  result = -2147024882;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  else
    result = -2147467261;
  return result;
}

//----- (77E86A87) --------------------------------------------------------
signed int __stdcall sub_77E86A87(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return -2147024882;
}

//----- (77E86AA4) --------------------------------------------------------
signed int __stdcall RegisterExtendedControls()
{
  return -2147024769;
}

//----- (77E86AD2) --------------------------------------------------------
signed int __stdcall sub_77E86AD2(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147024882;
}

//----- (77E86AEF) --------------------------------------------------------
signed int __stdcall sub_77E86AEF(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147024882;
}

//----- (77E86B19) --------------------------------------------------------
signed int __stdcall sub_77E86B19(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  return -2147024882;
}

//----- (77E86B37) --------------------------------------------------------
signed int __stdcall sub_77E86B37(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147024882;
}

//----- (77E86B54) --------------------------------------------------------
signed int __stdcall sub_77E86B54(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  return -2147024882;
}

//----- (77E86B7F) --------------------------------------------------------
signed int __stdcall sub_77E86B7F(int a1, int a2, int a3)
{
  *(_WORD *)a2 = 0;
  return -2147024882;
}

//----- (77E86B9A) --------------------------------------------------------
signed int __stdcall sub_77E86B9A(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return -2147024882;
}

//----- (77E86BB3) --------------------------------------------------------
signed int __stdcall sub_77E86BB3(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return -2147024882;
}

//----- (77E86BD1) --------------------------------------------------------
signed int __stdcall DeleteBrowserEmulationUserData(int a1)
{
  return -2147467259;
}

//----- (77E86C23) --------------------------------------------------------
signed int __stdcall sub_77E86C23(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return 1;
}

//----- (77E86C3E) --------------------------------------------------------
signed int __stdcall sub_77E86C3E(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a7 && a6 )
    *(_BYTE *)a7 = 0;
  return 1;
}

//----- (77E86C5F) --------------------------------------------------------
signed int __stdcall SetConsoleMaximumWindowSize(int a1, int a2)
{
  return 1;
}

//----- (77E86CB6) --------------------------------------------------------
SECURITY_STATUS __stdcall SspiDecryptAuthIdentity(PSEC_WINNT_AUTH_IDENTITY_OPAQUE EncryptedAuthData)
{
  return -1073741702;
}

//----- (77E86CDB) --------------------------------------------------------
int __stdcall sub_77E86CDB(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86CFC) --------------------------------------------------------
int __stdcall sub_77E86CFC(int a1, int a2)
{
  int v2; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v2 = a2 + 8;
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
  }
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86D22) --------------------------------------------------------
__int64 __stdcall sub_77E86D22(int a1)
{
  SetLastError(0x7Fu);
  return 0i64;
}

//----- (77E86D4B) --------------------------------------------------------
int __stdcall sub_77E86D4B(int a1)
{
  int v1; // edi@2

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    v1 = a1 + 8;
    *(_DWORD *)v1 = 0;
    *(_DWORD *)(v1 + 4) = 0;
  }
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86DA6) --------------------------------------------------------
HRESULT __stdcall IERegisterXMLNS(LPCWSTR lpszURI, GUID clsid, BOOL fMachine)
{
  return -2147024769;
}

//----- (77E86DB3) --------------------------------------------------------
int __stdcall sub_77E86DB3(int a1, int a2)
{
  if ( a1 )
    *(_WORD *)a1 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E86DD6) --------------------------------------------------------
int __stdcall sub_77E86DD6(int a1, int a2, int a3)
{
  if ( a1 )
    *(_WORD *)a1 = 0;
  return 0;
}

//----- (77E86DF2) --------------------------------------------------------
int __stdcall sub_77E86DF2(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_WORD *)a1 = 0;
  return result;
}

//----- (77E86E08) --------------------------------------------------------
signed int __stdcall sub_77E86E08(int a1, int a2, int a3, int a4, int a5)
{
  if ( a3 && *(_DWORD *)a4 )
    *(_BYTE *)a3 = 0;
  return -2147467259;
}

//----- (77E86E2D) --------------------------------------------------------
signed int __stdcall sub_77E86E2D(int a1, int a2, int a3, int a4, int a5)
{
  if ( a3 && *(_DWORD *)a4 )
    *(_WORD *)a3 = 0;
  return -2147467259;
}

//----- (77E86E54) --------------------------------------------------------
signed int __stdcall sub_77E86E54(int a1, int a2, int a3, int a4)
{
  if ( a2 && *(_DWORD *)a3 )
    *(_BYTE *)a2 = 0;
  return -2147467259;
}

//----- (77E86E79) --------------------------------------------------------
signed int __stdcall sub_77E86E79(int a1, int a2, int a3, int a4)
{
  if ( a2 && *(_DWORD *)a3 )
    *(_WORD *)a2 = 0;
  return -2147467259;
}

//----- (77E86EA0) --------------------------------------------------------
int __cdecl sub_77E86EA0(int a1)
{
  *(_BYTE *)a1 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E86EB9) --------------------------------------------------------
int __cdecl sub_77E86EB9(int a1)
{
  *(_WORD *)a1 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E86ED4) --------------------------------------------------------
int __stdcall sub_77E86ED4(int a1, int a2, int a3, int a4)
{
  *(_WORD *)a1 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E86EF1) --------------------------------------------------------
signed int __stdcall sub_77E86EF1(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_WORD *)a3 = 0;
  return -2147024769;
}

//----- (77E86F12) --------------------------------------------------------
int __stdcall sub_77E86F12(int a1, int a2, int a3, int a4, int a5, int a6)
{
  DelayLoad_SetLastNtStatusAndWin32Error();
  return a5;
}

//----- (77E86F28) --------------------------------------------------------
int __stdcall sub_77E86F28(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  if ( a3 > 0 )
    *(_WORD *)a1 = 0;
  return result;
}

//----- (77E86F44) --------------------------------------------------------
int __stdcall sub_77E86F44(int a1, int a2, int a3, int a4, int a5, void *Dst, int a7)
{
  if ( Dst && a7 && *(_DWORD *)a7 && a4 & 0x20000000 )
    memset(Dst, 0, *(_DWORD *)a7);
  return -2147024769;
}

//----- (77E86F81) --------------------------------------------------------
signed int __stdcall sub_77E86F81(int a1, int a2, int a3)
{
  if ( a3 > 0 )
    *(_WORD *)a2 = 0;
  return -2147024769;
}

//----- (77E86FA2) --------------------------------------------------------
signed int __stdcall sub_77E86FA2(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_WORD *)a3 = 0;
  return -2147024769;
}

//----- (77E86FC3) --------------------------------------------------------
int __stdcall sub_77E86FC3(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E86FE2) --------------------------------------------------------
int __stdcall sub_77E86FE2(int a1, int a2, int a3)
{
  if ( a3 > 0 )
    *(_WORD *)a2 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E87005) --------------------------------------------------------
int __stdcall sub_77E87005(int a1, int a2, int a3)
{
  if ( a3 > 0 )
    *(_BYTE *)a2 = 0;
  return 0;
}

//----- (77E87021) --------------------------------------------------------
int __stdcall sub_77E87021(int a1, int a2, int a3, int a4)
{
  SetLastError(0x7Fu);
  return a4;
}

//----- (77E87039) --------------------------------------------------------
signed int __stdcall sub_77E87039(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a2 = -2;
  *(_DWORD *)a3 = 0;
  return -2147467259;
}

//----- (77E8705B) --------------------------------------------------------
unsigned int __stdcall sub_77E8705B(int a1)
{
  return a1 != 0 ? (unsigned int)&byte_77E1E0E2 : 0;
}
// 77E1E0E2: using guessed type char byte_77E1E0E2;

//----- (77E87075) --------------------------------------------------------
unsigned int __stdcall sub_77E87075(int a1)
{
  return a1 != 0 ? (unsigned int)&Src : 0;
}

//----- (77E870A8) --------------------------------------------------------
unsigned int __stdcall sub_77E870A8(int a1, int a2)
{
  unsigned int result; // eax@3

  if ( a2 )
    *(_DWORD *)a2 = 0;
  result = g_ulDelayLoad_Win32Error;
  if ( g_ulDelayLoad_Win32Error > 0 )
    result = (unsigned __int16)g_ulDelayLoad_Win32Error | 0x80070000;
  return result;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E870D3) --------------------------------------------------------
int __stdcall sub_77E870D3(int a1, int a2, void *Dst)
{
  size_t v3; // edi@1

  v3 = *(_DWORD *)Dst;
  memset(Dst, 0, *(_DWORD *)Dst);
  *(_DWORD *)Dst = v3;
  SetLastError(0x7Fu);
  return -2147024769;
}

//----- (77E87104) --------------------------------------------------------
int __stdcall sub_77E87104(int a1, int a2, int a3, void *Dst, int a5, int a6)
{
  size_t v6; // edi@1

  v6 = *(_DWORD *)Dst;
  memset(Dst, 0, *(_DWORD *)Dst);
  *(_DWORD *)Dst = v6;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  SetLastError(0x7Fu);
  return -2147024769;
}

//----- (77E8715D) --------------------------------------------------------
int __stdcall sub_77E8715D(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return 0;
}

//----- (77E87189) --------------------------------------------------------
signed int __stdcall sub_77E87189(int a1, int a2, int a3, int a4, int a5)
{
  *(_BYTE *)a5 = 0;
  return -2147024769;
}

//----- (77E871A2) --------------------------------------------------------
signed int __stdcall sub_77E871A2(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_BYTE *)a6 = 0;
  return -2147024769;
}

//----- (77E871BB) --------------------------------------------------------
signed int __stdcall sub_77E871BB(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_WORD *)a6 = 0;
  return -2147024769;
}

//----- (77E871D6) --------------------------------------------------------
signed int __stdcall sub_77E871D6(int a1, int a2, int a3, int a4, int a5)
{
  *(_WORD *)a5 = 0;
  return -2147024769;
}

//----- (77E871F1) --------------------------------------------------------
signed int __stdcall sub_77E871F1(int a1, int a2, int a3, int a4, int a5)
{
  *(_WORD *)a4 = 0;
  return -2147024769;
}

//----- (77E87249) --------------------------------------------------------
signed int __stdcall sub_77E87249(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147024769;
}

//----- (77E8726C) --------------------------------------------------------
signed int __stdcall sub_77E8726C(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a4 = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return -2147024769;
}

//----- (77E8728F) --------------------------------------------------------
signed int __stdcall sub_77E8728F(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a5 = 0;
  return -2147024769;
}

//----- (77E872A8) --------------------------------------------------------
int __stdcall sub_77E872A8(void *a1, int a2, int a3)
{
  int result; // eax@3

  if ( a1 )
  {
    if ( a3 )
    {
      result = 0;
      memset(a1, 0, 0x20u);
    }
  }
  return result;
}

//----- (77E87301) --------------------------------------------------------
int __stdcall sub_77E87301(int a1, int a2)
{
  if ( a2 )
    *(_WORD *)a2 = 0;
  return 0;
}

//----- (77E8731D) --------------------------------------------------------
signed int __stdcall sub_77E8731D(int a1, int a2)
{
  *(_DWORD *)a2 = GUID_NULL.Data1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)&GUID_NULL.Data2;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)&GUID_NULL.Data4[0];
  *(_DWORD *)(a2 + 12) = *(_DWORD *)&GUID_NULL.Data4[4];
  return -2147024769;
}

//----- (77E87340) --------------------------------------------------------
signed int __stdcall sub_77E87340(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return -2147024769;
}

//----- (77E87359) --------------------------------------------------------
signed int __stdcall sub_77E87359(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return -2147024891;
}

//----- (77E87372) --------------------------------------------------------
int __stdcall sub_77E87372(int a1, int a2)
{
  *(_DWORD *)a2 = GUID_NULL.Data1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)&GUID_NULL.Data2;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)&GUID_NULL.Data4[0];
  *(_DWORD *)(a2 + 12) = *(_DWORD *)&GUID_NULL.Data4[4];
  return 0;
}

//----- (77E87392) --------------------------------------------------------
signed int __stdcall sub_77E87392(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a5 = 0;
  return -2147024769;
}

//----- (77E873AB) --------------------------------------------------------
signed int __stdcall sub_77E873AB(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  *(_DWORD *)a9 = 0;
  return -2147024769;
}

//----- (77E873C4) --------------------------------------------------------
signed int __stdcall FmsInitializeEnumerator(int a1, int a2)
{
  *(_DWORD *)a1 = 0;
  return -2147024769;
}

//----- (77E873F2) --------------------------------------------------------
signed int __stdcall sub_77E873F2(int a1, int a2, int a3)
{
  *(_WORD *)a2 = 0;
  SetLastError(0x7Fu);
  return -2147024769;
}

//----- (77E87414) --------------------------------------------------------
int __stdcall sub_77E87414(int a1, int a2, int a3)
{
  int result; // eax@1

  result = 0;
  *(_WORD *)a2 = 0;
  return result;
}

//----- (77E87458) --------------------------------------------------------
signed int __stdcall SfpDeleteCatalog(int a1, int a2)
{
  return 120;
}

//----- (77E874A5) --------------------------------------------------------
signed int __stdcall sub_77E874A5(int a1)
{
  *(_DWORD *)a1 = 0;
  return 19;
}

//----- (77E874D0) --------------------------------------------------------
PCCERT_CONTEXT __stdcall CryptUIDlgSelectCertificateFromStore(HCERTSTORE hCertStore, HWND hwnd, LPCWSTR pwszTitle, LPCWSTR pwszDisplayString, DWORD dwDontUseColumn, DWORD dwFlags, void *pvReserved)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E874F2) --------------------------------------------------------
int __stdcall DrawShadowTextEx(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E87503) --------------------------------------------------------
int __stdcall sub_77E87503(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  *(_WORD *)a1 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E8752C) --------------------------------------------------------
signed int __stdcall IsDeviceVirtual(int a1, int a2, int a3)
{
  SetLastError(0x7Fu);
  return 127;
}

//----- (77E87550) --------------------------------------------------------
int __stdcall sub_77E87550(int a1)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E8759C) --------------------------------------------------------
signed int __stdcall SspiUpdateCredentials(int a1, int a2, int a3, int a4)
{
  return -1073741702;
}

//----- (77E876AF) --------------------------------------------------------
RPC_STATUS __stdcall RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE Binding, RPC_CSTR ServerPrincName, unsigned __int32 AuthnLevel, unsigned __int32 AuthnSvc, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, unsigned __int32 AuthzSvc, RPC_SECURITY_QOS *SecurityQos)
{
  return 14;
}

//----- (77E876D0) --------------------------------------------------------
signed int __stdcall sub_77E876D0(int a1, int a2)
{
  v0 = 0;
  return 1702;
}

//----- (77E876F6) --------------------------------------------------------
void __stdcall sub_77E876F6(DWORD dwExceptionCode)
{
  RaiseException(dwExceptionCode, 1u, 0, 0);
}

//----- (77E8771B) --------------------------------------------------------
signed int __stdcall sub_77E8771B(int a1)
{
  if ( a1 )
    v0 = 0;
  return 87;
}

//----- (77E87739) --------------------------------------------------------
signed int __stdcall sub_77E87739(int a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return 14;
}

//----- (77E87780) --------------------------------------------------------
RPC_STATUS __stdcall RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE Binding, RPC_CSTR ServerPrincName, unsigned __int32 AuthnLevel, unsigned __int32 AuthnSvc, RPC_AUTH_IDENTITY_HANDLE AuthIdentity, unsigned __int32 AuthzSvc)
{
  return 14;
}

//----- (77E877F6) --------------------------------------------------------
signed int __stdcall sub_77E877F6(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return 127;
}

//----- (77E87811) --------------------------------------------------------
int __stdcall sub_77E87811(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)(a4 + 24) = 127;
  return 0;
}

//----- (77E8782B) --------------------------------------------------------
int __stdcall sub_77E8782B(int a1, int a2, int a3)
{
  *(_DWORD *)(a3 + 536) = 127;
  return 0;
}

//----- (77E87848) --------------------------------------------------------
int __stdcall sub_77E87848(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)(a3 + 28) = 127;
  return 0;
}

//----- (77E87889) --------------------------------------------------------
signed int __stdcall sub_77E87889(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return -2147024769;
}

//----- (77E878A8) --------------------------------------------------------
signed int __stdcall sub_77E878A8(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 12) = 0;
  return -2147024769;
}

//----- (77E878C6) --------------------------------------------------------
signed int __stdcall sub_77E878C6(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a6 = 0;
  return -2147024769;
}

//----- (77E878DF) --------------------------------------------------------
signed int __stdcall sub_77E878DF(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  v4 = a3 + 8;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 12) = 0;
  return -2147024769;
}

//----- (77E8791F) --------------------------------------------------------
signed int __stdcall sub_77E8791F(int a1, int a2)
{
  *(_WORD *)a2 = 0;
  return -2147024769;
}

//----- (77E8793A) --------------------------------------------------------
signed int __stdcall sub_77E8793A(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return -2147024769;
}

//----- (77E87957) --------------------------------------------------------
__int64 __stdcall sub_77E87957(int a1, __int64 a2)
{
  return a2;
}

//----- (77E8796B) --------------------------------------------------------
int __stdcall sub_77E8796B(int a1, void *Dst, size_t Size)
{
  memset(Dst, 0, Size);
  return -2147024769;
}

//----- (77E8798E) --------------------------------------------------------
int __stdcall sub_77E8798E(int a1, void *Dst)
{
  memset(Dst, 0, 0x108u);
  return -2147024769;
}

//----- (77E879CC) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadSHORT(IPropertyBag *propBag, LPCWSTR propName, SHORT *value)
{
  *value = 0;
  return -2147024769;
}

//----- (77E879E7) --------------------------------------------------------
signed int __stdcall sub_77E879E7(int a1, int a2, int a3)
{
  *(double *)a3 = 0.0;
  return -2147024769;
}

//----- (77E87A01) --------------------------------------------------------
signed int __stdcall sub_77E87A01(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  return -2147024769;
}

//----- (77E87A1D) --------------------------------------------------------
signed int __stdcall sub_77E87A1D(int a1, int a2, int a3)
{
  *(_DWORD *)a2 = 0;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147024769;
}

//----- (77E87A40) --------------------------------------------------------
signed int __stdcall sub_77E87A40(int a1, int a2, int a3, int a4)
{
  return -127;
}

//----- (77E87A4B) --------------------------------------------------------
signed int __stdcall sub_77E87A4B(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  return -2147024769;
}

//----- (77E87A69) --------------------------------------------------------
signed int __stdcall sub_77E87A69(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  return -2147024769;
}

//----- (77E87A87) --------------------------------------------------------
signed int __stdcall sub_77E87A87(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  return -2147024769;
}

//----- (77E87AA5) --------------------------------------------------------
__int16 __stdcall sub_77E87AA5(int a1, __int16 a2)
{
  return a2;
}

//----- (77E87AC8) --------------------------------------------------------
signed int __stdcall sub_77E87AC8(int a1, int a2)
{
  *(double *)a2 = 0.0;
  return -2147024769;
}

//----- (77E87AE2) --------------------------------------------------------
double __stdcall sub_77E87AE2(int a1, double a2)
{
  return a2;
}

//----- (77E87AF3) --------------------------------------------------------
signed int __stdcall sub_77E87AF3(int a1, int a2, int a3)
{
  *(_WORD *)a2 = 0;
  return -2147024769;
}

//----- (77E87B0E) --------------------------------------------------------
signed int __stdcall sub_77E87B0E(int a1, int a2, int a3)
{
  *(_WORD *)a2 = 0;
  *(_WORD *)a3 = 0;
  return -2147024769;
}

//----- (77E87B2F) --------------------------------------------------------
signed int __stdcall sub_77E87B2F(int a1, int a2, int a3)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)a3 = 0;
  return -2147024769;
}

//----- (77E87B59) --------------------------------------------------------
signed int __stdcall sub_77E87B59(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a8 = 0;
  return -2147024769;
}

//----- (77E87B72) --------------------------------------------------------
int __stdcall sub_77E87B72(int a1, int a2, int a3, int a4)
{
  if ( a3 && a4 )
    *(_WORD *)a3 = 0;
  return a4;
}

//----- (77E87B95) --------------------------------------------------------
int __stdcall sub_77E87B95(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a3;
  if ( a3 )
  {
    if ( a4 )
      *(_WORD *)a3 = 0;
  }
  return result;
}

//----- (77E87BB5) --------------------------------------------------------
signed int __stdcall sub_77E87BB5(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 && a5 )
    *(_WORD *)a4 = 0;
  return -2147024769;
}

//----- (77E87BDA) --------------------------------------------------------
signed int __stdcall PSGetValueAndPath(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return -2147024769;
}

//----- (77E87C02) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadType(IPropertyBag *propBag, LPCWSTR propName, VARIANT *var, VARTYPE type)
{
  *(_QWORD *)&var->vt = 0i64;
  var->llVal = 0i64;
  return -2147024769;
}

//----- (77E87C20) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadStr(IPropertyBag *propBag, LPCWSTR propName, LPWSTR value, int characterCount)
{
  if ( characterCount > 0 )
    *value = 0;
  return -2147024769;
}

//----- (77E87C41) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadPOINTS(IPropertyBag *propBag, LPCWSTR propName, POINTS *value)
{
  value->x = 0;
  value->y = 0;
  return -2147024769;
}

//----- (77E87C60) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadRECTL(IPropertyBag *propBag, LPCWSTR propName, RECTL *value)
{
  value->bottom = 0;
  value->left = 0;
  value->right = 0;
  value->top = 0;
  return -2147024769;
}

//----- (77E87C83) --------------------------------------------------------
HRESULT __stdcall PSPropertyBag_ReadPOINTL(IPropertyBag *propBag, LPCWSTR propName, POINTL *value)
{
  value->x = 0;
  value->y = 0;
  return -2147024769;
}

//----- (77E87CA0) --------------------------------------------------------
signed int __stdcall sub_77E87CA0(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = GUID_NULL.Data1;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)&GUID_NULL.Data2;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)&GUID_NULL.Data4[0];
  *(_DWORD *)(a3 + 12) = *(_DWORD *)&GUID_NULL.Data4[4];
  return -2147024769;
}

//----- (77E87CC3) --------------------------------------------------------
signed int __stdcall sub_77E87CC3(int a1, int a2, void *a3)
{
  qmemcpy(a3, &PKEY_Null, 0x14u);
  return -2147024769;
}

//----- (77E87D41) --------------------------------------------------------
signed int __stdcall FveGetStatus(int a1, int a2)
{
  return -2147024769;
}

//----- (77E87DAD) --------------------------------------------------------
signed int __stdcall ComPlusEnableRemoteAccess(int a1)
{
  return -2147024770;
}

//----- (77E87DBA) --------------------------------------------------------
signed int __stdcall CLSIDFromStringByBitness(int a1, int a2, int a3)
{
  return -2147024770;
}

//----- (77E87DE1) --------------------------------------------------------
signed int __stdcall sub_77E87DE1(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return -2147024770;
}

//----- (77E87DFA) --------------------------------------------------------
signed int __stdcall ActivatorUpdateForIsRouterChanges(struct ISimpleTableDispenser *a1, int a2)
{
  return -2147024770;
}

//----- (77E87E14) --------------------------------------------------------
signed int __stdcall sub_77E87E14(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a4 = 0;
  return -2147024770;
}

//----- (77E87E2D) --------------------------------------------------------
signed int __stdcall sub_77E87E2D(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a5 = 0;
  return -2147024770;
}

//----- (77E87E53) --------------------------------------------------------
signed int __stdcall sub_77E87E53(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 0;
  return -2147024770;
}

//----- (77E87E7E) --------------------------------------------------------
signed int __stdcall sub_77E87E7E(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  return -2147024770;
}

//----- (77E87EA4) --------------------------------------------------------
signed int __stdcall sub_77E87EA4(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  return -2147024770;
}

//----- (77E87ECD) --------------------------------------------------------
int __stdcall sub_77E87ECD(int a1, int a2, int a3)
{
  int result; // eax@1

  result = 0;
  *(_WORD *)a3 = 0;
  return result;
}

//----- (77E87EE3) --------------------------------------------------------
int __stdcall sub_77E87EE3(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a3 = 0;
  return 0;
}

//----- (77E87EF9) --------------------------------------------------------
unsigned int __stdcall sub_77E87EF9(int a1, int a2)
{
  unsigned int result; // eax@1

  *(_DWORD *)a2 = 0;
  result = g_ulDelayLoad_Win32Error;
  if ( g_ulDelayLoad_Win32Error > 0 )
    result = (unsigned __int16)g_ulDelayLoad_Win32Error | 0x80070000;
  return result;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E87F3A) --------------------------------------------------------
signed int __stdcall IEWSChangeNotify(int a1, int a2, int a3, int a4, int a5)
{
  return -2147467259;
}

//----- (77E87F62) --------------------------------------------------------
signed int __stdcall sub_77E87F62(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a6 = 0;
  return -2147467259;
}

//----- (77E87F88) --------------------------------------------------------
signed int __stdcall sub_77E87F88(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return -2147467259;
}

//----- (77E87FA2) --------------------------------------------------------
signed int __stdcall MapUriToBrowserEmulationState(int a1, int a2, int a3)
{
  return -2147467259;
}

//----- (77E88001) --------------------------------------------------------
signed int __stdcall MapBrowserEmulationModeToUserAgent(int a1, int a2)
{
  return -2147467259;
}

//----- (77E88024) --------------------------------------------------------
int __stdcall sub_77E88024(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return 0;
}

//----- (77E88047) --------------------------------------------------------
signed int __stdcall sub_77E88047(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return 7;
}

//----- (77E88091) --------------------------------------------------------
signed int __stdcall sub_77E88091(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  return 1;
}

//----- (77E880A8) --------------------------------------------------------
signed int __stdcall sub_77E880A8(int a1, int a2)
{
  *(_DWORD *)a2 = 0;
  return 1;
}

//----- (77E880BF) --------------------------------------------------------
int __stdcall sub_77E880BF(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)a1 = 0;
  result = a2;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return result;
}

//----- (77E880DD) --------------------------------------------------------
int __stdcall sub_77E880DD(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = -1;
  return result;
}

//----- (77E880F1) --------------------------------------------------------
__int32 __stdcall WasDTCInstalledBySQL()
{
  return 0;
}

//----- (77E88106) --------------------------------------------------------
signed int __stdcall KccUnInitializeWait(unsigned __int32 a1)
{
  return 127;
}

//----- (77E8815A) --------------------------------------------------------
signed int __stdcall sub_77E8815A(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return -2147024769;
}

//----- (77E8818E) --------------------------------------------------------
signed int __stdcall sub_77E8818E(int a1, int a2, int a3)
{
  if ( a2 )
    *(_BYTE *)a2 = 0;
  return -2;
}

//----- (77E881A9) --------------------------------------------------------
signed int __stdcall sub_77E881A9(int a1, int a2, int a3)
{
  if ( a2 )
    *(_WORD *)a2 = 0;
  return -2;
}

//----- (77E881C6) --------------------------------------------------------
INSTALLUILEVEL __stdcall MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND *phWnd)
{
  SetLastError(0x7Fu);
  return 2;
}

//----- (77E881D8) --------------------------------------------------------
signed int __stdcall sub_77E881D8(int a1, int a2)
{
  return 3;
}

//----- (77E881FF) --------------------------------------------------------
signed int __stdcall sub_77E881FF(int a1)
{
  *(_DWORD *)a1 = 0;
  return -2147467263;
}

//----- (77E88218) --------------------------------------------------------
HRESULT __stdcall MFShutdown()
{
  return -2147467263;
}

//----- (77E88223) --------------------------------------------------------
signed int __stdcall sub_77E88223(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return 1;
}

//----- (77E8823E) --------------------------------------------------------
HRESULT __stdcall MFCreateVideoSampleFromSurface(IUnknown *pUnkSurface, IMFSample **ppSample)
{
  if ( ppSample )
    *ppSample = 0;
  return -2147024769;
}

//----- (77E8825B) --------------------------------------------------------
signed int __stdcall sub_77E8825B(int a1, int a2)
{
  int v2; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    v2 = a2 + 8;
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
  }
  return -2147024769;
}

//----- (77E8828F) --------------------------------------------------------
HRESULT __stdcall MFConvertToFP16Array(WORD *pDest, const float *pSrc, DWORD dwCount)
{
  return -2147467263;
}

//----- (77E8829C) --------------------------------------------------------
HRESULT __stdcall MFTUnregisterLocal(IClassFactory *pClassFactory)
{
  return -2147467263;
}

//----- (77E882A9) --------------------------------------------------------
HRESULT __stdcall MFBeginRegisterWorkQueueWithMMCSS(DWORD dwWorkQueueId, LPCWSTR wszClass, DWORD dwTaskId, IMFAsyncCallback *pDoneCallback, IUnknown *pDoneState)
{
  return -2147467263;
}

//----- (77E882B6) --------------------------------------------------------
HRESULT __stdcall MFBeginCreateFile(MF_FILE_ACCESSMODE AccessMode, MF_FILE_OPENMODE OpenMode, MF_FILE_FLAGS fFlags, LPCWSTR pwszFilePath, IMFAsyncCallback *pCallback, IUnknown *pState, IUnknown **ppCancelCookie)
{
  return -2147467263;
}

//----- (77E882C3) --------------------------------------------------------
LONGLONG __stdcall MFllMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d)
{
  return 0x7FFFFFFFFFFFFFFFi64;
}

//----- (77E882D3) --------------------------------------------------------
HRESULT __stdcall MFTRegister(CLSID clsidMFT, GUID guidCategory, LPWSTR pszName, UINT32 Flags, UINT32 cInputTypes, MFT_REGISTER_TYPE_INFO *pInputTypes, UINT32 cOutputTypes, MFT_REGISTER_TYPE_INFO *pOutputTypes, IMFAttributes *pAttributes)
{
  return -2147467263;
}

//----- (77E882E0) --------------------------------------------------------
HRESULT __stdcall MFTGetInfo(CLSID clsidMFT, LPWSTR *pszName, MFT_REGISTER_TYPE_INFO **ppInputTypes, UINT32 *pcInputTypes, MFT_REGISTER_TYPE_INFO **ppOutputTypes, UINT32 *pcOutputTypes, IMFAttributes **ppAttributes)
{
  return -2147467263;
}

//----- (77E882ED) --------------------------------------------------------
HRESULT __stdcall MFTEnumEx(GUID guidCategory, UINT32 Flags, const MFT_REGISTER_TYPE_INFO *pInputType, const MFT_REGISTER_TYPE_INFO *pOutputType, IMFActivate ***pppMFTActivate, UINT32 *pnumMFTActivate)
{
  return -2147467263;
}

//----- (77E882FA) --------------------------------------------------------
HRESULT __stdcall MFTRegisterLocalByCLSID(const IID *const clisdMFT, const GUID *const guidCategory, LPCWSTR pszName, UINT32 Flags, UINT32 cInputTypes, const MFT_REGISTER_TYPE_INFO *pInputTypes, UINT32 cOutputTypes, const MFT_REGISTER_TYPE_INFO *pOutputTypes)
{
  return -2147467263;
}

//----- (77E88307) --------------------------------------------------------
HRESULT __stdcall MFCalculateBitmapImageSize(const BITMAPINFOHEADER *pBMIH, UINT32 cbBufSize, UINT32 *pcbImageSize, BOOL *pbKnown)
{
  return -2147467263;
}

//----- (77E88314) --------------------------------------------------------
HRESULT __stdcall MFCreateAttributes(IMFAttributes **ppMFAttributes, UINT32 cInitialSize)
{
  return -2147467263;
}

//----- (77E88321) --------------------------------------------------------
HRESULT __stdcall MFCreateVideoMediaTypeFromVideoInfoHeader2(const KS_VIDEOINFOHEADER2 *pVideoInfoHeader, DWORD cbVideoInfoHeader, QWORD AdditionalVideoFlags, const GUID *pSubtype, IMFVideoMediaType **ppIVideoMediaType)
{
  return -2147467263;
}

//----- (77E8832E) --------------------------------------------------------
HRESULT __stdcall MFCreateVideoMediaTypeFromBitMapInfoHeader(const BITMAPINFOHEADER *pbmihBitMapInfoHeader, DWORD dwPixelAspectRatioX, DWORD dwPixelAspectRatioY, MFVideoInterlaceMode InterlaceMode, QWORD VideoFlags, QWORD qwFramesPerSecondNumerator, QWORD qwFramesPerSecondDenominator, DWORD dwMaxBitRate, IMFVideoMediaType **ppIVideoMediaType)
{
  return -2147467263;
}

//----- (77E8833B) --------------------------------------------------------
HRESULT __stdcall MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(const BITMAPINFOHEADER *pbmihBitMapInfoHeader, UINT32 cbBitMapInfoHeader, DWORD dwPixelAspectRatioX, DWORD dwPixelAspectRatioY, MFVideoInterlaceMode InterlaceMode, QWORD VideoFlags, DWORD dwFramesPerSecondNumerator, DWORD dwFramesPerSecondDenominator, DWORD dwMaxBitRate, IMFVideoMediaType **ppIVideoMediaType)
{
  return -2147467263;
}

//----- (77E8835F) --------------------------------------------------------
signed int __stdcall sub_77E8835F(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)a4 = 0;
  return 127;
}

//----- (77E8837C) --------------------------------------------------------
signed int __stdcall sub_77E8837C(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a3 = 0;
  *(_DWORD *)a4 = 0;
  return -1073741702;
}

//----- (77E8839B) --------------------------------------------------------
signed int __stdcall sub_77E8839B(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = 0;
  return -1073741702;
}

//----- (77E883C4) --------------------------------------------------------
signed int __stdcall sub_77E883C4(int a1, int a2, int a3)
{
  if ( a1 )
  {
    if ( a2 )
      *(_DWORD *)a2 = 0;
    if ( a3 )
      *(_DWORD *)a3 = 0;
  }
  return -2147024769;
}

//----- (77E883F0) --------------------------------------------------------
int __stdcall sub_77E883F0(int a1, LPFILETIME lpFileTime)
{
  struct _SYSTEMTIME SystemTime; // [sp+4h] [bp-10h]@1

  SystemTime.wYear = 0;
  *(_DWORD *)&SystemTime.wMonth = 0;
  *(_DWORD *)&SystemTime.wDay = 0;
  *(_DWORD *)&SystemTime.wMinute = 0;
  SystemTime.wMilliseconds = 0;
  GetSystemTime(&SystemTime);
  SystemTimeToFileTime(&SystemTime, lpFileTime);
  return -2147024769;
}

//----- (77E8844E) --------------------------------------------------------
BOOL __stdcall CredPackAuthenticationBufferW(DWORD dwFlags, LPWSTR pszUserName, LPWSTR pszPassword, PBYTE pPackedCredentials, DWORD *pcbPackedCredentials)
{
  return 0;
}

//----- (77E88464) --------------------------------------------------------
int __stdcall sub_77E88464(int a1, int a2, void *Dst)
{
  size_t v3; // edi@2

  if ( Dst )
  {
    v3 = *(_DWORD *)Dst;
    memset(Dst, 0, *(_DWORD *)Dst);
    *(_DWORD *)Dst = v3;
  }
  return 0;
}

//----- (77E8848F) --------------------------------------------------------
int __stdcall UpdatePanningFeedback(HWND a1, __int32 a2, __int32 a3, int a4)
{
  return 0;
}

//----- (77E88499) --------------------------------------------------------
int __stdcall sub_77E88499(int a1, int a2, int a3, void *Dst)
{
  size_t v4; // edi@4

  if ( a3 )
    *(_DWORD *)a3 = 0;
  if ( Dst )
  {
    v4 = *(_DWORD *)Dst;
    memset(Dst, 0, *(_DWORD *)Dst);
    *(_DWORD *)Dst = v4;
  }
  return 0;
}

//----- (77E884CE) --------------------------------------------------------
int __stdcall sub_77E884CE(int a1, int a2, int a3, int a4, void *Dst)
{
  size_t v5; // edi@4

  if ( a4 )
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = 0;
  }
  if ( Dst )
  {
    v5 = *(_DWORD *)Dst;
    memset(Dst, 0, *(_DWORD *)Dst);
    *(_DWORD *)Dst = v5;
  }
  return 0;
}

//----- (77E88510) --------------------------------------------------------
__int64 __stdcall sub_77E88510(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return 0i64;
}

//----- (77E88528) --------------------------------------------------------
int __stdcall sub_77E88528(int a1, int a2, int a3)
{
  if ( a2 && a3 )
    *(_BYTE *)a2 = 0;
  return 0;
}

//----- (77E88548) --------------------------------------------------------
int __stdcall sub_77E88548(int a1, int a2, int a3, int a4)
{
  if ( a2 && a3 )
    *(_BYTE *)a2 = 0;
  return 0;
}

//----- (77E88568) --------------------------------------------------------
int __stdcall sub_77E88568(int a1, int a2, int a3)
{
  SetLastError(0x80004005);
  return 0;
}

//----- (77E88619) --------------------------------------------------------
int __stdcall FXSAPIInitialize()
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E88632) --------------------------------------------------------
int __stdcall sub_77E88632(int a1, int a2, int a3)
{
  return a2;
}

//----- (77E88643) --------------------------------------------------------
signed int __stdcall sub_77E88643(int a1, int a2, int a3)
{
  if ( *(_WORD *)a1 )
    *(_WORD *)a1 = 0;
  return -2147024769;
}

//----- (77E88664) --------------------------------------------------------
int __stdcall sub_77E88664(unsigned __int16 *a1, unsigned __int16 *a2, unsigned int a3, int a4)
{
  StringCchCopyW(a2, a3, a1);
  return -2147024882;
}

//----- (77E886BC) --------------------------------------------------------
signed int __stdcall RsopAccessCheckByTypeInternal(void *a1, void *a2, void *a3, unsigned __int32 a4, struct _OBJECT_TYPE_LIST *a5, unsigned __int32 a6, struct _GENERIC_MAPPING *a7, struct _PRIVILEGE_SET *a8, unsigned __int32 *a9, unsigned __int32 *a10, int *a11)
{
  return -2147024769;
}

//----- (77E886C9) --------------------------------------------------------
signed int __stdcall sub_77E886C9(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a7 )
    *(_DWORD *)a7 = 0;
  return 6;
}

//----- (77E886E4) --------------------------------------------------------
signed int __stdcall sub_77E886E4(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return 6;
}

//----- (77E886FF) --------------------------------------------------------
signed int __stdcall GdipCreateHICONFromBitmap(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return 6;
}

//----- (77E8871A) --------------------------------------------------------
signed int __stdcall sub_77E8871A(int a1, int a2, int a3, int a4, int a5)
{
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return 6;
}

//----- (77E88735) --------------------------------------------------------
signed int __stdcall sub_77E88735(int a1, int a2, int a3)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return 6;
}

//----- (77E88750) --------------------------------------------------------
signed int __stdcall sub_77E88750(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return 6;
}

//----- (77E8878C) --------------------------------------------------------
signed int __stdcall sub_77E8878C(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = -1;
  return 6;
}

//----- (77E887A7) --------------------------------------------------------
signed int __stdcall sub_77E887A7(int a1)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return 6;
}

//----- (77E887D8) --------------------------------------------------------
signed int __stdcall sub_77E887D8(int a1, int a2, int a3)
{
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
  }
  return 6;
}

//----- (77E887F6) --------------------------------------------------------
signed int __stdcall GdipAddPathBezierI(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  return 6;
}

//----- (77E88801) --------------------------------------------------------
signed int __stdcall sub_77E88801(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return 6;
}

//----- (77E8881C) --------------------------------------------------------
signed int __stdcall sub_77E8881C(int a1, int a2)
{
  if ( a2 )
    *(float *)a2 = 0.0;
  return 6;
}

//----- (77E88838) --------------------------------------------------------
signed int __stdcall sub_77E88838(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return 6;
}

//----- (77E8885E) --------------------------------------------------------
signed int __stdcall GdipDrawImageRectRect(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  return 6;
}

//----- (77E88874) --------------------------------------------------------
signed int __stdcall GdipGraphicsClear(int a1, int a2)
{
  return 6;
}

//----- (77E888A2) --------------------------------------------------------
int __stdcall FaxGetInstallType(int a1, int a2, int a3, int a4)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E888B3) --------------------------------------------------------
signed int __stdcall FaxSetSenderInformation(int a1)
{
  SetLastError(0x7Fu);
  return -2147467259;
}

//----- (77E888C7) --------------------------------------------------------
int __stdcall FaxGetExtensionDataW(int a1, int a2, int a3, int a4, int a5)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E888D8) --------------------------------------------------------
signed int __stdcall FmsGetFilteredFontList(int a1, int a2, int a3)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147024769;
}

//----- (77E888F5) --------------------------------------------------------
signed int __stdcall FmsGetFontProperty(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return -2147024769;
}

//----- (77E88912) --------------------------------------------------------
int __stdcall FmsGetGdiLogicalFont(int a1, int a2, int a3, void *Dst, void *a5, int a6)
{
  if ( Dst )
    memset(Dst, 0, 0x15Cu);
  if ( a5 )
    memset(a5, 0, 0x64u);
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return -2147024769;
}

//----- (77E8895B) --------------------------------------------------------
int __stdcall FmsGetGDILogFont(int a1, int a2, int a3, void *Dst, void *a5)
{
  if ( Dst )
    memset(Dst, 0, 0x15Cu);
  if ( a5 )
    memset(a5, 0, 0x64u);
  return -2147024769;
}

//----- (77E8899B) --------------------------------------------------------
signed int __stdcall FmsToggleOnDesignAxis(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a5 )
    *(_DWORD *)a5 = -1;
  return -2147024769;
}

//----- (77E889C2) --------------------------------------------------------
HRESULT __stdcall MFCreateVideoMixerAndPresenter(IUnknown *pMixerOwner, IUnknown *pPresenterOwner, const IID *const riidMixer, void **ppvVideoMixer, const IID *const riidPresenter, void **ppvVideoPresenter)
{
  if ( ppvVideoMixer )
    *ppvVideoMixer = 0;
  if ( ppvVideoPresenter )
    *ppvVideoPresenter = 0;
  return -2147024769;
}

//----- (77E88A36) --------------------------------------------------------
signed int __stdcall sub_77E88A36(int a1, int a2)
{
  *(_DWORD *)a1 = 0;
  return -107;
}

//----- (77E88A4D) --------------------------------------------------------
JET_ERR __stdcall JetRetrieveColumns(JET_SESID sesid, JET_TABLEID tableid, JET_RETRIEVECOLUMN *pretrievecolumn, unsigned __int32 cretrievecolumn)
{
  return -107;
}

//----- (77E88A58) --------------------------------------------------------
signed int __stdcall sub_77E88A58(int a1, int a2, int a3)
{
  DelayLoad_SetLastNtStatusAndWin32Error();
  return -2147023611;
}

//----- (77E88A99) --------------------------------------------------------
signed int __stdcall CreateDUIWrapperEx(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    result = -2147024769;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (77E88ABD) --------------------------------------------------------
signed int __stdcall CreateDUIWrapperFromResource(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2

  if ( a5 )
  {
    *(_DWORD *)a5 = 0;
    result = -2147024769;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (77E88AE1) --------------------------------------------------------
signed int __stdcall CreateDUIWrapper(int a1, int a2)
{
  signed int result; // eax@2

  if ( a2 )
  {
    *(_DWORD *)a2 = 0;
    result = -2147024769;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (77E88B05) --------------------------------------------------------
int __stdcall MultiByteToUnicode(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E88B26) --------------------------------------------------------
signed int __stdcall UiaOnGetObject(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2

  if ( a4 && (*(_BYTE *)a4 = 0, a5) )
  {
    *(_DWORD *)a5 = 0;
    result = -2147024769;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (77E88B5F) --------------------------------------------------------
unsigned __int32 __stdcall ComSvcsExceptionFilter(struct _EXCEPTION_POINTERS *a1, const unsigned __int16 *a2, const unsigned __int16 *a3)
{
  return 0;
}

//----- (77E88B97) --------------------------------------------------------
int __stdcall FaxSendDocumentExA(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E88BA8) --------------------------------------------------------
int __stdcall sub_77E88BA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a7 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E88BC5) --------------------------------------------------------
BOOL __stdcall FaxGetPageData(HANDLE FaxHandle, DWORD JobId, LPBYTE *Buffer, LPDWORD BufferSize, LPDWORD ImageWidth, LPDWORD ImageHeight)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E88BD6) --------------------------------------------------------
BOOL __stdcall CredUnPackAuthenticationBufferW(DWORD dwFlags, PVOID pAuthBuffer, DWORD cbAuthBuffer, LPWSTR pszUserName, DWORD *pcchMaxUserName, LPWSTR pszDomainName, DWORD *pcchMaxDomainName, LPWSTR pszPassword, DWORD *pcchMaxPassword)
{
  return 0;
}

//----- (77E88BE0) --------------------------------------------------------
signed int __stdcall ComSvcsLogError(signed int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1

  result = a1;
  if ( a1 >= 0 )
    result = -2147024770;
  return result;
}

//----- (77E88BFA) --------------------------------------------------------
int __stdcall GetMTAThreadPoolMetrics(struct MTA_METRICS *a1)
{
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *((_DWORD *)a1 + 1) = 0;
  }
  return 0;
}

//----- (77E88C17) --------------------------------------------------------
signed int __cdecl GetObjectContext(struct IObjectContext **a1)
{
  if ( a1 )
    *a1 = 0;
  return -2147024770;
}

//----- (77E88C5D) --------------------------------------------------------
signed int __stdcall GetDefaultPartitionForCurrentUser(int a1)
{
  int v1; // edi@2

  if ( a1 )
  {
    *(_DWORD *)a1 = GUID_NULL.Data1;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)&GUID_NULL.Data2;
    v1 = a1 + 8;
    *(_DWORD *)v1 = *(_DWORD *)&GUID_NULL.Data4[0];
    *(_DWORD *)(v1 + 4) = *(_DWORD *)&GUID_NULL.Data4[4];
  }
  return -2147024770;
}

//----- (77E88C84) --------------------------------------------------------
signed int __stdcall GetDefaultPartitionForSid(int a1, int a2)
{
  int v2; // edi@2

  if ( a2 )
  {
    *(_DWORD *)a2 = GUID_NULL.Data1;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)&GUID_NULL.Data2;
    v2 = a2 + 8;
    *(_DWORD *)v2 = *(_DWORD *)&GUID_NULL.Data4[0];
    *(_DWORD *)(v2 + 4) = *(_DWORD *)&GUID_NULL.Data4[4];
  }
  return -2147024770;
}

//----- (77E88CAB) --------------------------------------------------------
signed int __stdcall ComPlusRemoteAccessEnabled(int a1)
{
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return -2147024770;
}

//----- (77E88CC8) --------------------------------------------------------
signed int __stdcall InprocServer32FromString(int a1, int a2, int a3, int a4, int a5)
{
  if ( a5 )
    *(_DWORD *)a5 = 0;
  return -2147024770;
}

//----- (77E88CE5) --------------------------------------------------------
signed int __stdcall ServerGetApplicationType(struct ISimpleTableDispenser *a1, const struct _GUID *a2, enum __MIDL___MIDL_itf_registrar_0000_0000_0001 *a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return -2147024770;
}

//----- (77E88D58) --------------------------------------------------------
signed int __stdcall SysprepComplus2()
{
  return -2147024770;
}

//----- (77E88D63) --------------------------------------------------------
signed int __stdcall GetTrkSvrObject(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = 0;
  return -2147024770;
}

//----- (77E88D80) --------------------------------------------------------
signed int __stdcall LsaIAuditReplay(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return -1073741702;
}

//----- (77E88D8D) --------------------------------------------------------
signed int __stdcall sub_77E88D8D(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)a2 = -1;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return -1;
}

//----- (77E88DAD) --------------------------------------------------------
signed int __stdcall sub_77E88DAD(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  if ( a7 )
    *(_DWORD *)a7 = 0;
  if ( a8 )
    *(_DWORD *)a8 = 0;
  if ( a9 )
    *(_DWORD *)a9 = 0;
  if ( a10 )
    *(_DWORD *)a10 = 0;
  if ( a11 )
  {
    *(_DWORD *)a11 = 0;
    *(_DWORD *)(a11 + 4) = 0;
  }
  if ( a12 )
    *(_DWORD *)a12 = 0;
  return 1;
}

//----- (77E88E0D) --------------------------------------------------------
signed int __stdcall sub_77E88E0D(int a1, int a2, int a3)
{
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
  }
  return 1;
}

//----- (77E88E5B) --------------------------------------------------------
BOOL __stdcall ConvertSecurityDescriptorToStringSecurityDescriptorA(PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD RequestedStringSDRevision, SECURITY_INFORMATION SecurityInformation, LPSTR *StringSecurityDescriptor, PULONG StringSecurityDescriptorLen)
{
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E88F1E) --------------------------------------------------------
int __stdcall sub_77E88F1E(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  if ( a11 )
    *(_DWORD *)a11 = 0;
  if ( a12 )
    *(_DWORD *)a12 = 0;
  return g_lDelayLoad_NtStatus;
}
// 77E61890: using guessed type int g_lDelayLoad_NtStatus;

//----- (77E88F45) --------------------------------------------------------
int __stdcall sub_77E88F45(int a1, int a2, int a3)
{
  if ( a3 )
    *(_DWORD *)a3 = 0;
  return g_lDelayLoad_NtStatus;
}
// 77E61890: using guessed type int g_lDelayLoad_NtStatus;

//----- (77E88F74) --------------------------------------------------------
int __stdcall sub_77E88F74(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  if ( a8 )
    *(_DWORD *)a8 = -1;
  if ( a9 )
    *(_DWORD *)a9 = 0;
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E88F9B) --------------------------------------------------------
int __stdcall sub_77E88F9B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  if ( a8 )
    *(_DWORD *)a8 = -1;
  if ( a9 )
    *(_DWORD *)a9 = 0;
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E88FC2) --------------------------------------------------------
int __stdcall sub_77E88FC2(int a1, int a2, int a3, int a4, int a5)
{
  if ( a5 )
    *(_DWORD *)a5 = -1;
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E88FDF) --------------------------------------------------------
int __stdcall sub_77E88FDF(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a5 )
    *(_DWORD *)a5 = -1;
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E89000) --------------------------------------------------------
int __stdcall sub_77E89000(int a1, int a2, int a3, int a4, int a5, int a6)
{
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E8900D) --------------------------------------------------------
int __stdcall sub_77E8900D(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E89066) --------------------------------------------------------
int __stdcall sub_77E89066(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  result = g_ulDelayLoad_Win32Error;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return result;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E890BD) --------------------------------------------------------
int __stdcall sub_77E890BD(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a3 )
    *(_BYTE *)a3 = 0;
  if ( a5 )
    *(_BYTE *)a5 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E890E8) --------------------------------------------------------
int __stdcall sub_77E890E8(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if ( a3 )
    *(_WORD *)a3 = 0;
  if ( a5 )
    *(_WORD *)a5 = 0;
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E8915E) --------------------------------------------------------
int __stdcall sub_77E8915E(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a6 )
    *(_DWORD *)a6 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E8917D) --------------------------------------------------------
int __stdcall sub_77E8917D(int a1, int a2, int a3, int a4, int a5)
{
  if ( a5 )
    *(_DWORD *)a5 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E8919C) --------------------------------------------------------
int __stdcall sub_77E8919C(int a1, int a2, int a3, int a4, int a5)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E8927B) --------------------------------------------------------
int __stdcall sub_77E8927B(int a1, int a2, int a3, int a4)
{
  if ( a4 )
    *(_DWORD *)a4 = 0;
  return g_lDelayLoad_NtStatus;
}
// 77E61890: using guessed type int g_lDelayLoad_NtStatus;

//----- (77E89298) --------------------------------------------------------
int __stdcall sub_77E89298(int a1, int a2, int a3, int a4, int a5)
{
  return g_lDelayLoad_NtStatus;
}
// 77E61890: using guessed type int g_lDelayLoad_NtStatus;

//----- (77E892A5) --------------------------------------------------------
int __stdcall StmCoalesceChunks(int a1, int a2, int a3)
{
  return g_lDelayLoad_NtStatus;
}
// 77E61890: using guessed type int g_lDelayLoad_NtStatus;

//----- (77E892C1) --------------------------------------------------------
int __stdcall sub_77E892C1(int a1, int a2, int a3, int a4)
{
  int v4; // edi@4

  if ( a3 )
  {
    if ( a4 )
    {
      if ( *(_DWORD *)a4 >= 0xCu )
      {
        *(_DWORD *)a3 = 0;
        v4 = a3 + 4;
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 4) = 0;
      }
      *(_DWORD *)a4 = 12;
    }
  }
  else if ( a4 )
  {
    *(_DWORD *)a4 = 12;
  }
  DelayLoad_SetLastNtStatusAndWin32Error();
  return 0;
}

//----- (77E89303) --------------------------------------------------------
int __stdcall EnableScheduledDiagnostics(int a1)
{
  DelayLoad_SetLastNtStatusAndWin32Error();
  return g_ulDelayLoad_Win32Error;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E89324) --------------------------------------------------------
int __stdcall sub_77E89324(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 1;
  return result;
}

//----- (77E89353) --------------------------------------------------------
int __stdcall sub_77E89353(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 1;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (77E8937B) --------------------------------------------------------
int __stdcall sub_77E8937B(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@5

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 3;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)a2 = 0;
  if ( a3 )
  {
    *(_DWORD *)a2 = 1;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)a3;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 12);
  }
  if ( a4 )
  {
    *(_DWORD *)a2 |= 2u;
    *(_DWORD *)(a2 + 20) = *(_DWORD *)a4;
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a4 + 4);
    *(_DWORD *)(a2 + 28) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a4 + 12);
  }
  result = a5;
  *(_DWORD *)(a2 + 36) = a5;
  return result;
}

//----- (77E8941A) --------------------------------------------------------
int __stdcall sub_77E8941A(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  return result;
}

//----- (77E89484) --------------------------------------------------------
int __stdcall sub_77E89484(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int result; // eax@1

  sub_77E89353(a1 + 12, a2);
  *(_DWORD *)v5 = a3;
  *(_DWORD *)(v5 + 4) = a4;
  result = a5;
  *(_DWORD *)(v5 + 8) = a5;
  return result;
}

//----- (77E894B2) --------------------------------------------------------
unsigned int __stdcall GenerateActionQueue(int a1, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int result; // eax@1

  result = g_ulDelayLoad_Win32Error;
  if ( g_ulDelayLoad_Win32Error > 0 )
    result = (unsigned __int16)g_ulDelayLoad_Win32Error | 0x80070000;
  return result;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E894CD) --------------------------------------------------------
unsigned int __stdcall ProcessActionQueue(int a1, int a2, int a3, int a4, int a5)
{
  unsigned int result; // eax@5

  if ( a3 )
    *(_DWORD *)a3 = 1;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  result = g_ulDelayLoad_Win32Error;
  if ( g_ulDelayLoad_Win32Error > 0 )
    result = (unsigned __int16)g_ulDelayLoad_Win32Error | 0x80070000;
  return result;
}
// 77E6188C: using guessed type int g_ulDelayLoad_Win32Error;

//----- (77E89505) --------------------------------------------------------
BOOL __stdcall FaxPrintCoverPageA(const FAX_CONTEXT_INFOA *FaxContextInfo, const FAX_COVERPAGE_INFOA *CoverPageInfo)
{
  SetLastError(0x7Fu);
  return 0;
}

//----- (77E89516) --------------------------------------------------------
LSTATUS __stdcall RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
{
  int v4; // eax@1

  v4 = RegKrnGetGlobalState();
  return (*(int (__stdcall **)(HKEY, LPCSTR, REGSAM, DWORD, _DWORD))(v4 + 200))(hKey, lpSubKey, samDesired, Reserved, 0);
}

//----- (77E8953D) --------------------------------------------------------
ULONG __stdcall RegDeleteKeyExInternalA(int a1, PCSZ Source, int a3, int a4, int a5)
{
  ULONG result; // eax@2
  ULONG v6; // esi@4
  PWCH v7; // esi@5
  int v8; // eax@5
  LSA_UNICODE_STRING Destination; // [sp+0h] [bp-8h]@3

  if ( Source )
  {
    if ( RtlCreateUnicodeStringFromAsciiz(&Destination, Source) )
    {
      v7 = Destination.Buffer;
      v8 = RegKrnGetGlobalState();
      v6 = (*(int (__stdcall **)(int, PWCH, int, int, int))(v8 + 204))(a1, v7, a3, a4, a5);
      RtlFreeUnicodeString(&Destination);
    }
    else
    {
      v6 = RtlNtStatusToDosError(-1073741801);
    }
    result = v6;
  }
  else
  {
    result = 87;
  }
  return result;
}

//----- (77E895A3) --------------------------------------------------------
LSTATUS __stdcall DeleteAllKeyValues(HKEY hKey)
{
  unsigned int v1; // ebx@1
  PVOID i; // eax@1
  WCHAR *v4; // edi@5
  LSTATUS v5; // eax@6
  DWORD cchValueName; // [sp+Ch] [bp-8h]@3
  LSTATUS v7; // [sp+10h] [bp-4h]@6

  v1 = 520;
  for ( i = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 0x20Au);
        ;
        i = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 2 * cchValueName + 4) )
  {
    v4 = (WCHAR *)i;
    if ( !i )
      break;
    while ( 1 )
    {
      cchValueName = v1 >> 1;
      v5 = RegEnumValueW(hKey, 0, v4, &cchValueName, 0, 0, 0, 0);
      v7 = v5;
      if ( v5 == 234 )
        break;
      if ( v5 == 259 )
      {
        v7 = 0;
LABEL_12:
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
        return v7;
      }
      if ( !v5 )
      {
        v4[cchValueName] = 0;
        v7 = RegDeleteValueW(hKey, v4);
        if ( !v7 )
          continue;
      }
      goto LABEL_12;
    }
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    if ( cchValueName + 1 >= 0x7FFFFFFE )
      return 8;
    v1 = 2 * cchValueName + 2;
  }
  return 8;
}

//----- (77E89675) --------------------------------------------------------
int __stdcall RegDeleteTreeA(HKEY hKey, PCSZ Source)
{
  int result; // eax@4
  int v3; // esi@5
  LSA_UNICODE_STRING Destination; // [sp+4h] [bp-8h]@1

  Destination.Length = 0;
  *(_DWORD *)&Destination.MaximumLength = 0;
  HIWORD(Destination.Buffer) = 0;
  if ( Source && *Source && !RtlCreateUnicodeStringFromAsciiz(&Destination, Source) )
  {
    result = 8;
  }
  else
  {
    v3 = RegDeleteTreeW(hKey, Destination.Buffer);
    RtlFreeUnicodeString(&Destination);
    result = v3;
  }
  return result;
}

//----- (77E896CE) --------------------------------------------------------
HANDLE *__stdcall RegKrnGetAppKeyEventAddressInternal()
{
  RtlRunOnceExecuteOnce(&g_ProcessAppKeyEventInit, (PRTL_RUN_ONCE_INIT_FN)ProcessAppKeyEventInitFn, 0, 0);
  return &g_ProcessAppKeyEvent;
}

//----- (77E896ED) --------------------------------------------------------
LSTATUS __stdcall RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
{
  int v4; // eax@3
  ULONG v5; // eax@5
  NTSTATUS v6; // esi@9
  int v7; // esi@19
  int v8; // edi@19
  int v9; // eax@19
  STRING SourceString; // [sp+10h] [bp-254h]@9
  PVOID Address; // [sp+1Ch] [bp-248h]@3
  int v12; // [sp+20h] [bp-244h]@1
  int (__stdcall *v13)(unsigned int, LSA_UNICODE_STRING *, LSA_UNICODE_STRING *); // [sp+24h] [bp-240h]@1
  int v14; // [sp+28h] [bp-23Ch]@1
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-238h]@9
  LSA_UNICODE_STRING Destination; // [sp+34h] [bp-230h]@4
  LSTATUS v17; // [sp+3Ch] [bp-228h]@3
  char v18; // [sp+40h] [bp-224h]@9
  CPPEH_RECORD ms_exc; // [sp+24Ch] [bp-18h]@17

  v14 = 0;
  v12 = 0;
  v13 = *(int (__stdcall **)(unsigned int, LSA_UNICODE_STRING *, LSA_UNICODE_STRING *))(RegKrnGetGlobalState() + 112);
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  v4 = RegKrnGetGlobalState();
  v17 = (*(int (__stdcall **)(HKEY, PVOID *, int *, int *))(v4 + 176))(hKey, &Address, &v14, &v12);
  if ( !v17 )
  {
    if ( RtlCreateUnicodeStringFromAsciiz(&Destination, lpSubKey) )
    {
      if ( Destination.Length )
        Destination.Length += 2;
      DestinationString.Buffer = (PWCH)&v18;
      DestinationString.MaximumLength = 520;
      v6 = RtlInitAnsiStringEx(&SourceString, lpFile);
      if ( v6 >= 0 )
      {
        v6 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 0);
        if ( v6 >= 0 )
        {
          if ( DestinationString.Length > 0u )
            DestinationString.Length += 2;
          if ( (unsigned __int8)Address & 1 )
          {
            if ( v13 )
            {
              ms_exc.registration.TryLevel = 0;
              v17 = v13((unsigned int)Address & 0xFFFFFFFE, &Destination, &DestinationString);
              ms_exc.registration.TryLevel = -2;
            }
          }
          else
          {
            v17 = LocalBaseRegLoadKey(Address, (int)&Destination, (int)&DestinationString);
          }
          RtlFreeUnicodeString(&Destination);
          goto LABEL_19;
        }
      }
      RtlFreeUnicodeString(&Destination);
      v5 = RtlNtStatusToDosError(v6);
    }
    else
    {
      v5 = RtlNtStatusToDosError(-1073741801);
    }
    v17 = v5;
  }
LABEL_19:
  v7 = v12;
  v8 = v14;
  v9 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v9 + 168))(v8, v7);
  return v17;
}

//----- (77E898D9) --------------------------------------------------------
LSTATUS __stdcall RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
{
  int (__stdcall *v2)(_DWORD, _DWORD); // esi@1
  LSTATUS result; // eax@2
  int v4; // eax@3
  LSTATUS v5; // ebx@3
  int v6; // esi@13
  int v7; // edi@13
  int v8; // eax@13
  LSA_UNICODE_STRING Destination; // [sp+10h] [bp-34h]@4
  LSTATUS v10; // [sp+18h] [bp-2Ch]@11
  void *v11; // [sp+20h] [bp-24h]@3
  int v12; // [sp+24h] [bp-20h]@1
  int v13; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@11

  v12 = 0;
  v13 = 0;
  v2 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 116);
  if ( hKey == HKEY_PERFORMANCE_DATA )
  {
    result = 6;
  }
  else
  {
    v4 = RegKrnGetGlobalState();
    v5 = (*(int (__stdcall **)(HKEY, int *, int *, int *))(v4 + 176))(hKey, &v11, &v12, &v13);
    if ( !v5 )
    {
      if ( RtlCreateUnicodeStringFromAsciiz(&Destination, lpSubKey) )
      {
        if ( Destination.Length > 0u )
          Destination.Length += 2;
        if ( (unsigned __int8)v11 & 1 )
        {
          if ( v2 )
          {
            ms_exc.registration.TryLevel = 0;
            v5 = v2((unsigned int)v11 & 0xFFFFFFFE, &Destination);
            v10 = v5;
            ms_exc.registration.TryLevel = -2;
          }
        }
        else
        {
          v5 = LocalBaseRegUnLoadKey(v11, (int)&Destination);
        }
        RtlFreeUnicodeString(&Destination);
      }
      else
      {
        v5 = RtlNtStatusToDosError(-1073741801);
      }
    }
    v6 = v13;
    v7 = v12;
    v8 = RegKrnGetGlobalState();
    (*(void (__stdcall **)(int, int))(v8 + 168))(v7, v6);
    result = v5;
  }
  return result;
}

//----- (77E899F1) --------------------------------------------------------
LSTATUS __stdcall RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
{
  int (__stdcall *v2)(_DWORD, _DWORD); // esi@1
  int v4; // eax@3
  LSTATUS v5; // ebx@3
  NTSTATUS v6; // eax@4
  ULONG v7; // eax@5
  int v8; // esi@13
  int v9; // edi@13
  int v10; // eax@13
  UNICODE_STRING DestinationString; // [sp+10h] [bp-34h]@4
  LSTATUS v12; // [sp+18h] [bp-2Ch]@12
  void *v13; // [sp+20h] [bp-24h]@3
  int v14; // [sp+24h] [bp-20h]@1
  int v15; // [sp+28h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+2Ch] [bp-18h]@12

  v14 = 0;
  v15 = 0;
  v2 = *(int (__stdcall **)(_DWORD, _DWORD))(RegKrnGetGlobalState() + 116);
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  v4 = RegKrnGetGlobalState();
  v5 = (*(int (__stdcall **)(HKEY, int *, int *, int *))(v4 + 176))(hKey, &v13, &v14, &v15);
  if ( !v5 )
  {
    v6 = RtlInitUnicodeStringEx(&DestinationString, lpSubKey);
    if ( v6 >= 0 )
    {
      if ( DestinationString.Length > 0u )
        DestinationString.Length += 2;
      if ( (unsigned __int8)v13 & 1 )
      {
        if ( v2 )
        {
          ms_exc.registration.TryLevel = 0;
          v5 = v2((unsigned int)v13 & 0xFFFFFFFE, &DestinationString);
          v12 = v5;
          ms_exc.registration.TryLevel = -2;
        }
        goto LABEL_13;
      }
      v7 = LocalBaseRegUnLoadKey(v13, (int)&DestinationString);
    }
    else
    {
      v7 = RtlNtStatusToDosError(v6);
    }
    v5 = v7;
  }
LABEL_13:
  v8 = v15;
  v9 = v14;
  v10 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v10 + 168))(v9, v8);
  return v5;
}

//----- (77E89AF1) --------------------------------------------------------
LSTATUS __stdcall RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory)
{
  return 120;
}

//----- (77E89AFC) --------------------------------------------------------
LSTATUS __stdcall RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
{
  HKEY v3; // esi@1
  int v5; // eax@3
  LSTATUS v6; // ebx@3
  NTSTATUS v7; // eax@4
  ULONG v8; // eax@5
  int v9; // esi@14
  int v10; // edi@14
  int v11; // eax@14
  STRING SourceString; // [sp+10h] [bp-3Ch]@4
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-34h]@1
  LSTATUS v14; // [sp+20h] [bp-2Ch]@13
  int v15; // [sp+28h] [bp-24h]@1
  int v16; // [sp+2Ch] [bp-20h]@1
  int (__stdcall *v17)(unsigned int, LSA_UNICODE_STRING *, DWORD); // [sp+30h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@13

  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v15 = 0;
  v16 = 0;
  v17 = *(int (__stdcall **)(unsigned int, LSA_UNICODE_STRING *, DWORD))(RegKrnGetGlobalState() + 124);
  v3 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  v5 = RegKrnGetGlobalState();
  v6 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v5 + 176))(v3, &hKey, &v15, &v16);
  if ( !v6 )
  {
    v7 = RtlInitAnsiStringEx(&SourceString, lpFile);
    if ( v7 < 0 || (v7 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u), v7 < 0) )
    {
      v8 = RtlNtStatusToDosError(v7);
    }
    else
    {
      if ( DestinationString.Length > 0u )
        DestinationString.Length += 2;
      if ( (unsigned __int8)hKey & 1 )
      {
        if ( v17 )
        {
          ms_exc.registration.TryLevel = 0;
          v6 = v17((unsigned int)hKey & 0xFFFFFFFE, &DestinationString, dwFlags);
          v14 = v6;
          ms_exc.registration.TryLevel = -2;
        }
        goto LABEL_14;
      }
      v8 = LocalBaseRegRestoreKey(hKey, &DestinationString, dwFlags);
    }
    v6 = v8;
  }
LABEL_14:
  RtlFreeUnicodeString(&DestinationString);
  v9 = v16;
  v10 = v15;
  v11 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v11 + 168))(v10, v9);
  return v6;
}

//----- (77E89C39) --------------------------------------------------------
LSTATUS __stdcall RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags)
{
  int (__stdcall *v4)(_DWORD, _DWORD, _DWORD, _DWORD); // ebx@1
  HKEY v5; // esi@1
  int v7; // eax@3
  NTSTATUS v8; // eax@4
  int v9; // esi@10
  int v10; // esi@19
  int v11; // edi@19
  int v12; // eax@19
  int v13; // [sp+10h] [bp-4Ch]@10
  STRING SourceString; // [sp+24h] [bp-38h]@4
  LSA_UNICODE_STRING DestinationString; // [sp+2Ch] [bp-30h]@1
  int v16; // [sp+38h] [bp-24h]@1
  int v17; // [sp+3Ch] [bp-20h]@1
  LSTATUS v18; // [sp+40h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+44h] [bp-18h]@16

  DestinationString.Length = 0;
  *(_DWORD *)&DestinationString.MaximumLength = 0;
  HIWORD(DestinationString.Buffer) = 0;
  v16 = 0;
  v17 = 0;
  v4 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(RegKrnGetGlobalState() + 128);
  v5 = hKey;
  if ( hKey == HKEY_PERFORMANCE_DATA )
    return 6;
  v7 = RegKrnGetGlobalState();
  v18 = (*(int (__stdcall **)(HKEY, HKEY *, int *, int *))(v7 + 176))(v5, &hKey, &v16, &v17);
  if ( !v18 )
  {
    v8 = RtlInitAnsiStringEx(&SourceString, lpFile);
    if ( v8 >= 0 )
    {
      v8 = RtlAnsiStringToUnicodeString(&DestinationString, &SourceString, 1u);
      if ( v8 >= 0 )
      {
        if ( DestinationString.Length > 0u )
          DestinationString.Length += 2;
        if ( lpSecurityAttributes )
        {
          v9 = (int)&v13;
          lpFile = (LPCSTR)&v13;
          v18 = MapSAToRpcSA((int)lpSecurityAttributes, (int)&v13);
          if ( v18 )
            goto LABEL_19;
        }
        else
        {
          v9 = 0;
          lpFile = 0;
        }
        if ( (unsigned __int8)hKey & 1 )
        {
          if ( v4 )
          {
            ms_exc.registration.TryLevel = 0;
            v18 = v4((unsigned int)hKey & 0xFFFFFFFE, &DestinationString, v9, Flags);
            ms_exc.registration.TryLevel = -2;
          }
        }
        else
        {
          v18 = LocalBaseRegSaveKeyEx((int)hKey, &DestinationString, v9, Flags);
        }
        if ( v9 )
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v9 + 4));
        goto LABEL_19;
      }
    }
    v18 = RtlNtStatusToDosError(v8);
  }
LABEL_19:
  RtlFreeUnicodeString(&DestinationString);
  v10 = v17;
  v11 = v16;
  v12 = RegKrnGetGlobalState();
  (*(void (__stdcall **)(int, int))(v12 + 168))(v11, v10);
  return v18;
}

//----- (77E89DC1) --------------------------------------------------------
int __stdcall RemapPredefinedHandleInternal(int a1, HANDLE SourceHandle)
{
  int v3; // eax@5
  int v4; // edi@7
  int *v5; // esi@13
  void *v6; // ST14_4@14
  PVOID v7; // eax@15
  HANDLE TargetHandle; // [sp+4h] [bp-8h]@1
  int v9; // [sp+8h] [bp-4h]@3

  TargetHandle = 0;
  if ( !(a1 & 0x80000000) )
    return -1073741816;
  v9 = RtlRunOnceExecuteOnce(
         &PredefinedHandleTableCriticalSectionInit,
         (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
         0,
         0);
  RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
  if ( v9 >= 0 )
  {
    v3 = MapPredefinedRegistryHandleToIndex(a1);
    if ( v3 == -1 )
    {
      v9 = -1073741816;
      goto LABEL_18;
    }
    v4 = 4 * v3;
    if ( byte_77EA6B2C[16 * v3] == 1 )
    {
      v9 = -1073741816;
      goto LABEL_18;
    }
    if ( SourceHandle )
    {
      v9 = NtDuplicateObject((HANDLE)0xFFFFFFFF, SourceHandle, (HANDLE)0xFFFFFFFF, &TargetHandle, 0, 0, 2u);
      if ( v9 < 0 )
      {
LABEL_18:
        RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
        if ( v9 < 0 )
        {
          if ( TargetHandle )
            RegCloseKey((HKEY)TargetHandle);
        }
        return v9;
      }
      if ( (unsigned __int8)SourceHandle & 2 )
        TargetHandle = (HANDLE)((unsigned int)TargetHandle | 2);
    }
    v5 = &PredefinedHandleTable[v4];
    if ( PredefinedHandleTable[v4] )
    {
      ++*(_DWORD *)(dword_77EA6B24[v4] + 4);
      v6 = (void *)dword_77EA6B24[v4];
      *v5 = 0;
      DereferenceHandleUnit(v6);
    }
    v7 = AllocatePredefinedHandleUnit((int)&PredefinedHandleTable[v4]);
    if ( v7 )
    {
      *(_DWORD *)v7 = TargetHandle;
      *((_DWORD *)v7 + 3) = dword_77EA6B24[v4];
      dword_77EA6B24[v4] = (int)v7;
      *v5 = (int)TargetHandle;
    }
    else
    {
      v9 = -1073741801;
    }
    goto LABEL_18;
  }
  return 6;
}
// 77EA6B20: using guessed type int PredefinedHandleTable[];
// 77EA6B24: using guessed type int dword_77EA6B24[];

//----- (77E89EE3) --------------------------------------------------------
signed int __stdcall CleanupPredefinedHandles()
{
  int v0; // esi@1
  int v1; // edi@3
  signed int v3; // [sp+Ch] [bp-4h]@1

  RtlRunOnceExecuteOnce(
    &PredefinedHandleTableCriticalSectionInit,
    (PRTL_RUN_ONCE_INIT_FN)PredefinedHandleTableCriticalSectionInitFn,
    0,
    0);
  RtlEnterCriticalSection(&PredefinedHandleTableCriticalSection);
  v0 = (int)dword_77EA6B24;
  v3 = 10;
  do
  {
    if ( *(_BYTE *)(v0 + 8) != 1 )
    {
      v1 = *(_DWORD *)v0;
      if ( *(_DWORD *)v0 )
      {
        do
        {
          *(_DWORD *)v0 = RemoveUnitFromList(v1, v1);
          LocalBaseRegCloseKey((int *)v1);
          FreePredefinedHandleUnit((PVOID)v1);
          v1 = *(_DWORD *)v0;
        }
        while ( *(_DWORD *)v0 );
        *(_DWORD *)(v0 - 4) = 0;
      }
    }
    v0 += 16;
    --v3;
  }
  while ( v3 );
  RtlLeaveCriticalSection(&PredefinedHandleTableCriticalSection);
  return 1;
}
// 77EA6B24: using guessed type int dword_77EA6B24[];

//----- (77E89F5E) --------------------------------------------------------
int __stdcall OpenPredefinedKeyForSpecialAccess(int a1, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle)
{
  int v3; // eax@13
  int result; // eax@13

  if ( a1 != 0x80000000
    && a1 != -2147483647
    && a1 != -2147483646
    && a1 != -2147483644
    && a1 != -2147483568
    && a1 != -2147483552
    && a1 != -2147483645
    && a1 != -2147483643
    && a1 != -2147483642
    && a1 != -2147483641 )
  {
    result = 1010;
  }
  else if ( DesiredAccess & 0x1000000 && KeyHandle )
  {
    v3 = MapPredefinedRegistryHandleToIndex(a1);
    result = (*(&off_77EA6B28 + 4 * v3))(0, DesiredAccess, KeyHandle);
  }
  else
  {
    result = 87;
  }
  return result;
}
// 77EA6B28: using guessed type int (__stdcall *off_77EA6B28)(int, ACCESS_MASK DesiredAccess, PHANDLE KeyHandle);

//----- (77E89FE7) --------------------------------------------------------
BOOL __stdcall ProcessAppKeyEventInitFn(PRTL_RUN_ONCE RunOnce, PVOID Parameter, PVOID *Context)
{
  g_ProcessAppKeyEvent = 0;
  dword_77EA672C = 0;
  return NtCreateEvent(&g_ProcessAppKeyEvent, 0x1F0003u, 0, 0, 0) >= 0;
}

//----- (77E8A022) --------------------------------------------------------
int __cdecl _except_handler4(int a1, PVOID TargetFrame, int a3)
{
  PVOID v3; // ebx@1
  uintptr_t v4; // esi@1
  int v5; // eax@1
  char *v6; // edi@1
  int v7; // ecx@2
  int v8; // ecx@3
  int v9; // ecx@5
  int v10; // eax@5
  int v11; // eax@5
  int v12; // eax@6
  int v13; // ecx@12
  int v14; // ecx@13
  PVOID v16; // eax@16
  int v17; // ecx@19
  int v18; // ecx@20
  int v19; // [sp+Ch] [bp-14h]@4
  int v20; // [sp+10h] [bp-10h]@4
  int v21; // [sp+14h] [bp-Ch]@5
  int v22; // [sp+18h] [bp-8h]@1
  char v23; // [sp+1Fh] [bp-1h]@1
  int v24; // [sp+28h] [bp+8h]@5

  v3 = TargetFrame;
  v4 = __security_cookie ^ *((_DWORD *)TargetFrame + 2);
  v5 = *(_DWORD *)v4;
  v23 = 0;
  v22 = 1;
  v6 = (char *)TargetFrame + 16;
  if ( v5 != -2 )
    v7 = *(_DWORD *)&v6[v5] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 4)];
  v8 = *(_DWORD *)&v6[*(_DWORD *)(v4 + 8)] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 12)];
  if ( *(_BYTE *)(a1 + 4) & 0x66 )
  {
LABEL_21:
    if ( *((_DWORD *)v3 + 3) == -2 )
      return v22;
    _EH4_LocalUnwind(v6, &__security_cookie);
  }
  else
  {
    *((_DWORD *)TargetFrame - 1) = &v19;
    v3 = (PVOID)*((_DWORD *)TargetFrame + 3);
    v19 = a1;
    v20 = a3;
    if ( v3 == (PVOID)-2 )
      return v22;
    do
    {
      v9 = *(_DWORD *)(v4 + 12 * (_DWORD)v3 + 20);
      v10 = v4 + 12 * (_DWORD)v3 + 16;
      v21 = v10;
      v11 = *(_DWORD *)v10;
      v24 = v11;
      if ( v9 )
      {
        v12 = _EH4_CallFilterFunc(v9, v6);
        v23 = 1;
        if ( v12 < 0 )
        {
          v22 = 0;
          goto LABEL_11;
        }
        if ( v12 > 0 )
        {
          _EH4_GlobalUnwind(TargetFrame);
          v16 = TargetFrame;
          if ( *((PVOID *)TargetFrame + 3) != v3 )
          {
            _EH4_LocalUnwind(v6, &__security_cookie);
            v16 = TargetFrame;
          }
          *((_DWORD *)v16 + 3) = v24;
          if ( *(_DWORD *)v4 != -2 )
            v17 = *(_DWORD *)&v6[*(_DWORD *)v4] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 4)];
          v18 = *(_DWORD *)&v6[*(_DWORD *)(v4 + 8)] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 12)];
          _EH4_TransferToHandler(*(_DWORD *)(v21 + 8), v6);
          goto LABEL_21;
        }
        v11 = v24;
      }
      v3 = (PVOID)v11;
    }
    while ( v11 != -2 );
    if ( !v23 )
      return v22;
  }
LABEL_11:
  if ( *(_DWORD *)v4 != -2 )
    v13 = *(_DWORD *)&v6[*(_DWORD *)v4] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 4)];
  v14 = *(_DWORD *)&v6[*(_DWORD *)(v4 + 8)] ^ (unsigned int)&v6[*(_DWORD *)(v4 + 12)];
  return v22;
}
// 77E4A25E: using guessed type int __fastcall _EH4_CallFilterFunc(_DWORD, _DWORD);
// 77E4A275: using guessed type int __fastcall _EH4_TransferToHandler(_DWORD, _DWORD);
// 77E4A2A8: using guessed type _DWORD __stdcall _EH4_LocalUnwind(_DWORD, _DWORD);

//----- (77E8A277) --------------------------------------------------------
BOOL __stdcall SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
{
  int v2; // eax@1
  BOOL result; // eax@2

  v2 = TpSetPoolStackInformation(ptpp, ptpsi);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v2);
    result = 0;
  }
  return result;
}
// 77DE1034: using guessed type int __stdcall TpSetPoolStackInformation(_DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E8A2A3) --------------------------------------------------------
BOOL __stdcall QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
{
  int v2; // eax@1
  BOOL result; // eax@2

  v2 = TpQueryPoolStackInformation(ptpp, ptpsi);
  if ( v2 >= 0 )
  {
    result = 1;
  }
  else
  {
    RtlSetLastWin32ErrorAndNtStatusFromNtStatus(v2);
    result = 0;
  }
  return result;
}
// 77DE1030: using guessed type int __stdcall TpQueryPoolStackInformation(_DWORD, _DWORD);
// 77DE1424: using guessed type int __stdcall RtlSetLastWin32ErrorAndNtStatusFromNtStatus(_DWORD);

//----- (77E8A2CF) --------------------------------------------------------
int __stdcall BasepTpIoCleanupCallback(int a1, int a2)
{
  int result; // eax@1
  int (__stdcall *v3)(_DWORD, _DWORD); // ecx@1

  result = a1;
  v3 = *(int (__stdcall **)(_DWORD, _DWORD))(a1 + 8);
  if ( v3 )
    result = v3(*(_DWORD *)(a1 + 12), a2);
  return result;
}

//----- (77E8A2EF) --------------------------------------------------------
int __stdcall SbpDeriveVirtualOsVersionOnFastPath(int a1, int a2, int a3, int a4, const void *a5)
{
  int v5; // ebx@1
  unsigned int *v6; // esi@1
  int v7; // edi@1
  int v8; // eax@4
  unsigned int v9; // eax@10
  int v11; // [sp+Ch] [bp-14h]@1
  int v12; // [sp+10h] [bp-10h]@3
  int v13; // [sp+14h] [bp-Ch]@1
  unsigned int v14; // [sp+18h] [bp-8h]@1
  signed int *v15; // [sp+1Ch] [bp-4h]@2
  int v16; // [sp+2Ch] [bp+Ch]@1

  v13 = 0;
  v14 = 0;
  v5 = *(_WORD *)(a2 + 8) + (*(_WORD *)(a2 + 4) << 16);
  v6 = (unsigned int *)a1;
  v7 = *(_WORD *)(a2 + 8) + (*(_WORD *)(a2 + 4) << 16);
  v11 = *(_WORD *)(a2 + 8) + (*(_WORD *)(a2 + 4) << 16);
  v16 = *(_WORD *)(a2 + 8) + (*(_WORD *)(a2 + 4) << 16);
  if ( *(_WORD *)a1 > 0u )
  {
    v15 = (signed int *)(a1 + 4);
    do
    {
      if ( SbGetContextDetailsById(*(_WORD *)v15, (int)&v12) )
      {
        v8 = *(_WORD *)(v12 + 22) + (*(_WORD *)(v12 + 20) << 16);
        if ( a5 )
        {
          if ( !memcmp((const void *)(v12 + 4), a5, 0x10u) )
          {
            v13 = 1;
            v7 = v8;
            break;
          }
          v6 = (unsigned int *)a1;
          v7 = v16;
        }
        if ( v8 <= (unsigned int)v11 && v11 - v8 < (unsigned int)v5 )
        {
          v13 = 1;
          v5 = v11 - v8;
          v16 = v8;
          v7 = v8;
        }
      }
      v9 = *(_WORD *)v6;
      ++v14;
      v15 = (signed int *)((char *)v15 + 2);
    }
    while ( v14 < v9 );
  }
  *(_WORD *)a4 = v7;
  *(_WORD *)a3 = HIWORD(v7);
  return v13;
}

//----- (77E8A3BF) --------------------------------------------------------
int __stdcall SbpRetrieveCompatibilityManifest(HANDLE hActCtx, int a2)
{
  PVOID v2; // ebx@1
  HANDLE v3; // eax@1
  ACTCTXW pActCtx; // [sp+8h] [bp-28h]@1
  int v6; // [sp+28h] [bp-8h]@1
  SIZE_T pcbWrittenOrRequired; // [sp+2Ch] [bp-4h]@1
  HANDLE hActCtxa; // [sp+38h] [bp+8h]@1

  memset(&pActCtx.dwFlags, 0, 0x1Cu);
  pActCtx.lpSource = (LPCWSTR)hActCtx;
  pcbWrittenOrRequired = 0;
  v6 = 0;
  v2 = 0;
  pActCtx.cbSize = 32;
  pActCtx.lpResourceName = (LPCWSTR)1;
  pActCtx.dwFlags = 8;
  v3 = CreateActCtxW(&pActCtx);
  hActCtxa = v3;
  if ( v3 != (HANDLE)-1 )
  {
    v6 = QueryActCtxW(0x80000000, v3, 0, 6u, 0, 0, &pcbWrittenOrRequired);
    if ( v6 || NtCurrentTeb()->Reserved2[0] == (PVOID)122 )
    {
      v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, pcbWrittenOrRequired);
      if ( v2 )
      {
        v6 = QueryActCtxW(0x80000000, hActCtxa, 0, 6u, v2, pcbWrittenOrRequired, &pcbWrittenOrRequired);
        if ( !v6 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
          v2 = 0;
        }
      }
    }
    ReleaseActCtx(hActCtxa);
  }
  *(_DWORD *)a2 = v2;
  return v6;
}

//----- (77E8A4A0) --------------------------------------------------------
int __stdcall SbpDeriveVirtualOsVersionBasedOnManifest(HANDLE hActCtx, int a2, int a3, int a4, int a5)
{
  unsigned __int16 v5; // si@1
  unsigned __int16 v6; // di@1
  int v7; // eax@3
  int v8; // ebx@4
  HANDLE v9; // esi@4
  int v10; // eax@8
  int v12; // [sp+Ch] [bp-14h]@4
  int v13; // [sp+10h] [bp-10h]@1
  int v14; // [sp+14h] [bp-Ch]@1
  unsigned int v15; // [sp+18h] [bp-8h]@4
  PVOID Address; // [sp+1Ch] [bp-4h]@1
  HANDLE hActCtxa; // [sp+28h] [bp+8h]@4
  int v18; // [sp+2Ch] [bp+Ch]@5

  v5 = *(_WORD *)(a2 + 4);
  v6 = *(_WORD *)(a2 + 8);
  v14 = 0;
  Address = 0;
  v13 = 0;
  if ( !SbpRetrieveCompatibilityManifest(hActCtx, (int)&Address) )
    goto LABEL_18;
  if ( !Address )
    return v14;
  v7 = *(_DWORD *)Address;
  if ( !*(_DWORD *)Address )
    goto LABEL_18;
  v15 = 0;
  v8 = v6 + (v5 << 16);
  v9 = (HANDLE)v8;
  v12 = v8;
  hActCtxa = (HANDLE)v8;
  if ( !v7 )
    goto LABEL_17;
  v18 = (int)((char *)Address + 4);
  while ( *(_DWORD *)(v18 + 16) != 1 || !SbGetContextDetailsByGuid((const void *)v18, (int)&v13) )
  {
LABEL_14:
    ++v15;
    v18 += 20;
    if ( v15 >= *(_DWORD *)Address )
      goto LABEL_17;
  }
  v10 = *(_WORD *)(v13 + 22) + (*(_WORD *)(v13 + 20) << 16);
  if ( !a5 )
  {
LABEL_11:
    if ( v10 <= (unsigned int)v12 && v12 - v10 < (unsigned int)v8 )
    {
      v14 = 1;
      v8 = v12 - v10;
      hActCtxa = (HANDLE)v10;
      v9 = (HANDLE)v10;
    }
    goto LABEL_14;
  }
  if ( memcmp((const void *)v18, (const void *)a5, 0x10u) )
  {
    v9 = hActCtxa;
    goto LABEL_11;
  }
  v14 = 1;
  v9 = (HANDLE)v10;
LABEL_17:
  *(_WORD *)a4 = (_WORD)v9;
  *(_WORD *)a3 = HIWORD(v9);
LABEL_18:
  if ( Address )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  return v14;
}

//----- (77E8A5C4) --------------------------------------------------------
signed int __stdcall SbGetContextDetailsByGuid(const void *a1, int a2)
{
  int v2; // ebx@1
  int v3; // edx@1
  signed int v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@3
  const void *v7; // [sp+18h] [bp+Ch]@3

  v2 = a2;
  v3 = 0;
  v5 = 0;
  if ( a2 && a1 )
  {
    *(_DWORD *)a2 = 0;
    v7 = dword_77E33608;
    v6 = 0;
    while ( memcmp(a1, v7, 0x10u) )
    {
      v6 += 28;
      v7 = (char *)v7 + 28;
      ++v3;
      if ( v6 >= 0x38 )
        return v5;
    }
    v5 = 1;
    *(_DWORD *)v2 = &SbSupportedOsList[7 * v3];
  }
  return v5;
}
// 77E33604: using guessed type int SbSupportedOsList[];
// 77E33608: using guessed type int dword_77E33608[5];

//----- (77E8A62C) --------------------------------------------------------
int __stdcall SbGetContextDetailsByName(wchar_t *Str1, int a2)
{
  unsigned int v2; // edi@1
  int v3; // esi@3
  signed int v5; // [sp+8h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  if ( a2 && Str1 )
  {
    v3 = 0;
    while ( _wcsicmp(Str1, (&off_77E3361C)[v2]) )
    {
      v2 += 14;
      ++v3;
      if ( v2 >= 28 )
        return v5;
    }
    v5 = 1;
    *(_DWORD *)a2 = &SbSupportedOsList[7 * v3];
  }
  return v5;
}
// 77E33604: using guessed type int SbSupportedOsList[];
// 77E3361C: using guessed type wchar_t *off_77E3361C;

//----- (77E8A688) --------------------------------------------------------
signed int __stdcall SbpIsValidPlatformGuid(const void *a1)
{
  return SbGetContextDetailsByGuid(a1, (int)&a1);
}

//----- (77E8A6A2) --------------------------------------------------------
signed int __fastcall NlsConvertStringToIntegerW(int a1, int a2, signed int a3, unsigned int *a4)
{
  unsigned int *v4; // edi@2
  signed int v5; // ebx@3
  __int16 v6; // ax@8
  int v7; // esi@8
  __int16 v8; // ax@11
  unsigned int v9; // eax@15
  unsigned int v10; // edx@15
  int v11; // edx@16
  int v13; // [sp+Ch] [bp-4h]@1
  signed int v14; // [sp+1Ch] [bp+Ch]@7

  v13 = a2;
  if ( a1 )
  {
    v4 = a4;
    if ( a4 )
    {
      v5 = a3;
      if ( a3 )
      {
        if ( *(_WORD *)a1 )
        {
          *a4 = 0;
          if ( a3 == -1 )
            v5 = 11;
          v14 = 0;
          if ( v5 <= 0 )
            return 1;
          while ( 1 )
          {
            v6 = *(_WORD *)a1;
            LOWORD(v7) = v6 - 48;
            a1 += 2;
            if ( (unsigned __int16)(v6 - 48) > 9u )
            {
              if ( v13 != 16 )
                return v6 == 0;
              if ( (unsigned __int16)(v6 - 65) > 5u )
              {
                if ( (unsigned __int16)(v6 - 97) > 5u )
                  return v6 == 0;
                v8 = v6 - 87;
              }
              else
              {
                v8 = v6 - 55;
              }
              LOWORD(v7) = v8;
            }
            v9 = *v4;
            v10 = *v4;
            v7 = (unsigned __int16)v7;
            if ( v13 == 16 )
              v11 = v7 | 16 * v10;
            else
              v11 = v7 + 10 * v10;
            *v4 = v11;
            if ( v11 < v9 )
              return 0;
            ++v14;
            if ( v14 >= v5 )
              return 1;
          }
        }
      }
    }
  }
  return 0;
}

//----- (77E8A760) --------------------------------------------------------
NTSTATUS __stdcall SetRegValue(HANDLE KeyHandle, PCWSTR SourceString, PVOID Data, ULONG DataSize)
{
  LSA_UNICODE_STRING DestinationString; // [sp+0h] [bp-8h]@1

  RtlInitUnicodeString(&DestinationString, SourceString);
  return NtSetValueKey(KeyHandle, &DestinationString, 0, 1u, Data, DataSize);
}

//----- (77E8A794) --------------------------------------------------------
NTSTATUS __stdcall NlsConvertIntegerToString(ULONG Value, ULONG Base, int a3, STRSAFE_LPWSTR pszDest, size_t cchDest)
{
  unsigned int v5; // esi@1
  NTSTATUS result; // eax@2
  STRSAFE_LPWSTR v7; // ecx@4
  unsigned int v8; // eax@4
  LSA_UNICODE_STRING String; // [sp+8h] [bp-40Ch]@3
  char v10; // [sp+10h] [bp-404h]@3

  v5 = cchDest;
  if ( cchDest < 0x200 )
  {
    String.Length = 2 * cchDest;
    String.MaximumLength = 2 * cchDest;
    String.Buffer = (PWCH)&v10;
    result = RtlIntegerToUnicodeString(Value, Base, &String);
    if ( result >= 0 )
    {
      v7 = pszDest;
      v8 = (unsigned int)String.Length >> 1;
      while ( v8 < a3 )
      {
        if ( v5 < 1 )
          goto LABEL_11;
        *v7 = 48;
        ++v8;
        ++v7;
        --v5;
      }
      if ( StringCchCopyW(v7, v5, String.Buffer) >= 0 )
        return 0;
LABEL_11:
      result = -1073741823;
    }
  }
  else
  {
    result = -2147483643;
  }
  return result;
}

//----- (77E8A844) --------------------------------------------------------
int __stdcall BasepAnsiStringToDynamicUnicodeString(PUNICODE_STRING DestinationString, int a2)
{
  NTSTATUS v2; // eax@2
  STRING SourceString; // [sp+0h] [bp-8h]@1

  if ( RtlInitAnsiStringEx(&SourceString, (PCSZ)a2) < 0 )
    goto LABEL_10;
  v2 = RtlAnsiStringToUnicodeString(DestinationString, &SourceString, 1u);
  if ( v2 >= 0 )
    return 1;
  if ( v2 == -2147483643 )
LABEL_10:
    RtlSetLastWin32Error(206);
  else
    BaseSetLastNTError(v2);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8A899) --------------------------------------------------------
signed int __stdcall BaseVerifyUnicodeString(int a1)
{
  int v1; // edx@1
  unsigned __int16 v3; // cx@5

  v1 = *(_DWORD *)(a1 + 4);
  if ( v1 )
  {
    v3 = *(_WORD *)(a1 + 2);
    if ( v3 && *(_WORD *)a1 <= v3 && !(v3 & 1) && !(*(_WORD *)a1 & 1) )
      return (unsigned __int8)CsrVerifyRegion(v1, v3) != 0 ? 0 : -1073741790;
  }
  else if ( !*(_WORD *)(a1 + 2) && !*(_WORD *)a1 )
  {
    return 0;
  }
  return -1073741790;
}
// 77DE149C: using guessed type int __stdcall CsrVerifyRegion(_DWORD, _DWORD);

//----- (77E8A8FD) --------------------------------------------------------
signed int __stdcall BasepAllocateActivationContextActivationBlock(int a1, int a2, int a3, int a4)
{
  signed int v4; // edi@4
  int v5; // eax@7
  int v6; // eax@13
  PVOID v7; // eax@13
  void *v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v10 = 0;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a1 & 0xFFFFFFFC )
  {
    v4 = -1073741585;
    goto LABEL_19;
  }
  if ( !a4 )
  {
    v4 = -1073741582;
    goto LABEL_19;
  }
  v5 = RtlQueryInformationActivationContext(1, 0, 0, 1, &v9, 8, 0);
  v4 = v5;
  if ( v5 < 0 )
  {
    _DbgPrintEx(
      0x33u,
      0,
      "SXS: %s - Failure getting active activation context; ntstatus %08lx\n",
      "BasepAllocateActivationContextActivationBlock",
      v5);
    goto LABEL_19;
  }
  if ( v10 & 1 )
  {
    RtlReleaseActivationContext(v9);
    v9 = 0;
  }
  if ( !(a1 & 2) || v9 )
  {
    v6 = KernelBaseGetGlobalData();
    v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 0x10u);
    *(_DWORD *)a4 = v7;
    if ( !v7 )
    {
      v4 = -1073741801;
      goto LABEL_19;
    }
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(*(_DWORD *)a4 + 12) = v9;
    v9 = 0;
    if ( a1 & 1 )
      **(_DWORD **)a4 |= 1u;
    *(_DWORD *)(*(_DWORD *)a4 + 4) = a2;
    *(_DWORD *)(*(_DWORD *)a4 + 8) = a3;
  }
  v4 = 0;
LABEL_19:
  if ( v9 )
    RtlReleaseActivationContext(v9);
  return v4;
}
// 77DE117C: using guessed type int __stdcall RtlQueryInformationActivationContext(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E8AA73) --------------------------------------------------------
BOOLEAN __stdcall BasepFreeActivationContextActivationBlock(PVOID Address)
{
  BOOLEAN result; // al@4

  if ( Address )
  {
    if ( *((_DWORD *)Address + 3) )
    {
      RtlReleaseActivationContext(*((HANDLE *)Address + 3));
      *((_DWORD *)Address + 3) = 0;
    }
    result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  return result;
}

//----- (77E8AAB1) --------------------------------------------------------
void __stdcall __noreturn BaseExitThreadPoolThread(int a1)
{
  RtlExitUserThread(a1);
  __debugbreak();
  JUMPOUT(*(_DWORD *)byte_77E8AAC0);
}
// 77DE170C: using guessed type int __stdcall RtlExitUserThread(_DWORD);

//----- (77E8AAC5) --------------------------------------------------------
int __stdcall BaseCreateThreadPoolThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, int a3)
{
  HANDLE v3; // eax@1
  int v5; // [sp+10h] [bp-40h]@1
  int v6; // [sp+14h] [bp-3Ch]@1
  char v7; // [sp+18h] [bp-38h]@1
  int v8; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v5 = 36;
  v6 = 1;
  memset(&v7, 0, 0x1Cu);
  v8 = 0;
  RtlActivateActivationContextUnsafeFast(&v5, 0);
  ms_exc.registration.TryLevel = 0;
  v3 = CreateRemoteThread((HANDLE)0xFFFFFFFF, 0, 0, lpStartAddress, lpParameter, 4u, 0);
  *(_DWORD *)a3 = v3;
  if ( !v3 )
  {
    v8 = *(_DWORD *)&NtCurrentTeb()->Reserved3[1412];
    if ( v8 >= 0 )
      v8 = -1073741823;
  }
  ms_exc.registration.TryLevel = -2;
  RtlDeactivateActivationContextUnsafeFast(&v5);
  return v8;
}
// 77DE140C: using guessed type int __fastcall RtlActivateActivationContextUnsafeFast(_DWORD, _DWORD);
// 77DE1410: using guessed type int __thiscall RtlDeactivateActivationContextUnsafeFast(_DWORD);

//----- (77E8AB79) --------------------------------------------------------
int __stdcall IsThisARootDirectory(HANDLE FileHandle, int a2)
{
  signed int v2; // edi@1
  NTSTATUS v3; // eax@5
  NTSTATUS v4; // esi@6
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+8h] [bp-654h]@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-64Ch]@5
  ULONG ReturnLength; // [sp+28h] [bp-634h]@6
  LSA_UNICODE_STRING TargetName; // [sp+2Ch] [bp-630h]@6
  HANDLE SymbolicLinkHandle; // [sp+34h] [bp-628h]@5
  char v11; // [sp+38h] [bp-624h]@6
  unsigned int FileInformation; // [sp+448h] [bp-214h]@2

  v2 = 0;
  if ( FileHandle
    && NtQueryInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 0x210u, FileNameInformation) >= 0
    && *((_WORD *)&FileInformation + (FileInformation >> 1) + 1) == 92
    || a2
    && (*(_WORD *)a2 -= 2,
        ObjectAttributes.Length = 24,
        ObjectAttributes.RootDirectory = 0,
        ObjectAttributes.Attributes = 64,
        ObjectAttributes.ObjectName = (PUNICODE_STRING)a2,
        ObjectAttributes.SecurityDescriptor = 0,
        ObjectAttributes.SecurityQualityOfService = 0,
        v3 = NtOpenSymbolicLinkObject(&SymbolicLinkHandle, 1u, &ObjectAttributes),
        *(_WORD *)a2 += 2,
        v3 >= 0)
    && (TargetName.Buffer = (PWCH)&v11,
        TargetName.Length = 0,
        TargetName.MaximumLength = 1040,
        ReturnLength = 0,
        v4 = NtQuerySymbolicLinkObject(SymbolicLinkHandle, &TargetName, &ReturnLength),
        NtClose(SymbolicLinkHandle),
        v4 >= 0) )
    v2 = 1;
  return v2;
}

//----- (77E8AC9A) --------------------------------------------------------
signed int __stdcall BasepIsRealtimeAllowed(char a1, signed int a2)
{
  signed int result; // eax@2
  int v3; // [sp+0h] [bp-4h]@1

  v3 = 14;
  if ( RtlAcquirePrivilege(&v3, 1, (_BYTE)a2 != 0, &a2) >= 0 )
  {
    if ( !a1 )
    {
      RtlReleasePrivilege(a2);
      a2 = 1;
    }
    result = a2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 77DE1530: using guessed type int __stdcall RtlReleasePrivilege(_DWORD);
// 77DE1534: using guessed type int __stdcall RtlAcquirePrivilege(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E8ACEA) --------------------------------------------------------
void *__stdcall GetExtents(HANDLE hDevice)
{
  int v1; // eax@1
  PVOID i; // eax@1
  int v3; // eax@4
  void *v4; // esi@5
  DWORD v6; // [sp+Ch] [bp-8h]@3
  ULONG Size; // [sp+10h] [bp-4h]@1

  Size = 32;
  v1 = KernelBaseGetGlobalData();
  for ( i = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v1 + 44), 0x20u);
        ;
        i = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v3 + 44), Size) )
  {
    v4 = i;
    if ( !i )
      break;
    memset(i, 0, Size);
    if ( DeviceIoControl(hDevice, 0x560000u, 0, 0, v4, Size, &Size, 0) == 1 )
      return v4;
    v6 = GetLastError();
    if ( v6 != 234 )
      goto LABEL_7;
    Size = 24 * *(_DWORD *)v4 + 8;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
    v3 = KernelBaseGetGlobalData();
  }
  v6 = 8;
LABEL_7:
  if ( v6 )
  {
    if ( v4 )
    {
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v4);
      v4 = 0;
    }
    RtlSetLastWin32Error(v6);
  }
  return v4;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8ADD8) --------------------------------------------------------
BOOLEAN __stdcall NotifyMountMgr(PWSTR dosname, PCWSTR SourceString, int a3)
{
  BOOLEAN result; // al@1
  ULONG v4; // ebx@2
  int v5; // eax@2
  PVOID v6; // eax@2
  PVOID v7; // esi@2
  HANDLE v8; // eax@4
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-14h]@2
  LSA_UNICODE_STRING ntname; // [sp+Ch] [bp-Ch]@1
  DWORD BytesReturned; // [sp+14h] [bp-4h]@5
  PWSTR dosnamea; // [sp+20h] [bp+8h]@4

  result = RtlDosPathNameToNtPathName_U(dosname, &ntname, 0, 0);
  if ( result )
  {
    RtlInitUnicodeString(&DestinationString, SourceString);
    DestinationString.Length -= 2;
    ntname.Length -= 2;
    v4 = DestinationString.Length + ntname.Length + 8;
    v5 = KernelBaseGetGlobalData();
    v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), v4);
    v7 = v6;
    if ( v6 )
    {
      *(_WORD *)v6 = 8;
      *((_WORD *)v6 + 1) = ntname.Length;
      *((_WORD *)v6 + 2) = ntname.Length + 8;
      *((_WORD *)v6 + 3) = DestinationString.Length;
      memcpy((char *)v6 + 8, ntname.Buffer, *((_WORD *)v6 + 1));
      memcpy((char *)v7 + *((_WORD *)v7 + 2), DestinationString.Buffer, *((_WORD *)v7 + 3));
      *(_WORD *)((char *)v7 + *((_WORD *)v7 + 2) + 2) = 63;
      v8 = CreateFileW(L"\\\\.\\MountPointManager", 0xC0000000, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
      dosnamea = (PWSTR)v8;
      if ( v8 != (HANDLE)-1 )
      {
        DeviceIoControl(v8, 4 * (a3 == 0) + 7192600, v7, v4, 0, 0, &BytesReturned, 0);
        CloseHandle(dosnamea);
      }
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
      result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    }
    else
    {
      result = RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, ntname.Buffer);
    }
  }
  return result;
}

//----- (77E8AF34) --------------------------------------------------------
int __stdcall DeleteVolumeNameForRoot(PVOID Address)
{
  int v1; // eax@1
  PVOID v2; // ebx@1
  int v4; // eax@3
  PVOID v5; // esi@3
  int v6; // eax@5
  HANDLE v7; // eax@9
  BOOL v8; // ebx@10
  DWORD BytesReturned; // [sp+4h] [bp-8h]@12
  HANDLE hObject; // [sp+8h] [bp-4h]@9
  PVOID Addressa; // [sp+14h] [bp+8h]@5

  v1 = KernelBaseGetGlobalData();
  v2 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v1 + 44), 0x1Eu);
  if ( !v2 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  qmemcpy(v2, L"\\DosDevices\\", 0x18u);
  *((_WORD *)v2 + 12) = _toupper(*(_WORD *)Address);
  *((_WORD *)v2 + 13) = 58;
  *((_WORD *)v2 + 14) = 0;
  v4 = KernelBaseGetGlobalData();
  v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v4 + 44), 0x34u);
  if ( !v5 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
LABEL_7:
    RtlSetLastWin32Error(8);
    return 0;
  }
  memset(v5, 0, 0x18u);
  *((_WORD *)v5 + 2) = 28;
  *(_DWORD *)v5 = 24;
  memcpy((char *)v5 + 24, v2, 0x1Cu);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
  v6 = KernelBaseGetGlobalData();
  Addressa = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v6 + 44), 0x638u);
  if ( !Addressa )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
    goto LABEL_7;
  }
  v7 = CreateFileW(L"\\\\.\\MountPointManager", 0xC0000000, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  hObject = v7;
  if ( v7 == (HANDLE)-1 )
  {
    v8 = 0;
  }
  else
  {
    v8 = DeviceIoControl(v7, 0x6DC004u, v5, 0x34u, Addressa, 0x638u, &BytesReturned, 0);
    CloseHandle(hObject);
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Addressa);
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77E61B5C: using guessed type wchar_t aDosdevices[13];

//----- (77E8B0D2) --------------------------------------------------------
BOOL __stdcall DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
{
  LPCWSTR v1; // ebx@1
  NTSTATUS v3; // eax@4
  HANDLE v4; // eax@13
  int v5; // eax@15
  PVOID v6; // edi@15
  WCHAR v7; // cx@21
  int v8; // eax@29
  __int16 v9; // dx@29
  int v10; // esi@29
  __int16 v11; // cx@33
  BOOL v12; // ebx@51
  UNICODE_STRING DestinationString; // [sp+4h] [bp-10h]@4
  DWORD BytesReturned; // [sp+Ch] [bp-8h]@27
  HANDLE hObject; // [sp+10h] [bp-4h]@14

  v1 = lpszVolumeMountPoint;
  if ( !lpszVolumeMountPoint )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v3 = RtlInitUnicodeStringEx(&DestinationString, lpszVolumeMountPoint);
  if ( v3 < 0 )
  {
    BaseSetLastNTError(v3);
    return 0;
  }
  if ( DestinationString.Buffer[((unsigned int)DestinationString.Length >> 1) - 1] != 92 )
  {
    BaseSetLastNTError(-1073741773);
    return 0;
  }
  if ( GetDriveTypeW(lpszVolumeMountPoint) == 4 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( DestinationString.Length == 6 )
  {
    if ( DestinationString.Buffer[1] != 58 )
      goto LABEL_13;
    return DeleteVolumeNameForRoot((PVOID)v1);
  }
  if ( DestinationString.Length == 14 && *DestinationString.Buffer == 92 && DestinationString.Buffer[1] == 92 )
  {
    v7 = DestinationString.Buffer[2];
    if ( (v7 == 46 || v7 == 63) && DestinationString.Buffer[3] == 92 && DestinationString.Buffer[5] == 58 )
    {
      v1 = lpszVolumeMountPoint + 4;
      return DeleteVolumeNameForRoot((PVOID)v1);
    }
  }
LABEL_13:
  v4 = CreateFileW(L"\\\\.\\MountPointManager", 0xC0000000, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  if ( v4 == (HANDLE)-1 )
    return 0;
  CloseHandle(v4);
  hObject = CreateFileW(lpszVolumeMountPoint, 0xC0000000, 7u, 0, 3u, 0x2200080u, (HANDLE)0xFFFFFFFF);
  if ( hObject == (HANDLE)-1 )
    return 0;
  v5 = KernelBaseGetGlobalData();
  v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], *(_DWORD *)(v5 + 44), 0x4000u);
  if ( !v6 )
  {
    CloseHandle(hObject);
    RtlSetLastWin32Error(8);
    return 0;
  }
  if ( !DeviceIoControl(hObject, 0x900A8u, 0, 0, v6, 0x4000u, &BytesReturned, 0) || *(_DWORD *)v6 != -1610612733 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
    CloseHandle(hObject);
    return 0;
  }
  v8 = *((_WORD *)v6 + 4);
  v9 = *((_WORD *)v6 + 5);
  v10 = (int)((char *)v6 + v8 + 16);
  if ( v9 != 96 && (v9 != 98 || *(_WORD *)((char *)v6 + v8 + 112) != 92)
    || *(_WORD *)v10 != 92
    || (v11 = *(_WORD *)((char *)v6 + v8 + 18), v11 != 63) && v11 != 92
    || *(_WORD *)((char *)v6 + v8 + 20) != 63
    || *(_WORD *)((char *)v6 + v8 + 22) != 92
    || *(_WORD *)((char *)v6 + v8 + 24) != 86
    || *(_WORD *)((char *)v6 + v8 + 26) != 111
    || *(_WORD *)((char *)v6 + v8 + 28) != 108
    || *(_WORD *)((char *)v6 + v8 + 30) != 117
    || *(_WORD *)((char *)v6 + v8 + 32) != 109
    || *(_WORD *)((char *)v6 + v8 + 34) != 101
    || *(_WORD *)((char *)v6 + v8 + 36) != 123
    || *(_WORD *)((char *)v6 + v8 + 54) != 45
    || *(_WORD *)((char *)v6 + v8 + 64) != 45
    || *(_WORD *)((char *)v6 + v8 + 74) != 45
    || *(_WORD *)((char *)v6 + v8 + 84) != 45
    || *(_WORD *)((char *)v6 + v8 + 110) != 125
    || v9 != 98
    || v11 != 63 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
    CloseHandle(hObject);
    RtlSetLastWin32Error(87);
    return 0;
  }
  *((_WORD *)v6 + 2) = 0;
  v12 = DeviceIoControl(hObject, 0x900ACu, v6, 8u, 0, 0, &BytesReturned, 0);
  CloseHandle(hObject);
  if ( v12 )
  {
    *(_WORD *)(v10 + 2) = 92;
    *(_WORD *)(v10 + 98) = 0;
    NotifyMountMgr((PWSTR)lpszVolumeMountPoint, (PCWSTR)v10, 0);
  }
  RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
  return v12;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8B3EA) --------------------------------------------------------
int __stdcall IsDiskOnCluster(int a1)
{
  DWORD v1; // esi@1
  HANDLE v2; // edi@1
  HRESULT v3; // eax@1
  DWORD BytesReturned; // [sp+Ch] [bp-50h]@1
  int v6; // [sp+10h] [bp-4Ch]@1
  char OutBuffer; // [sp+17h] [bp-45h]@1
  wchar_t pszDest; // [sp+18h] [bp-44h]@1

  v6 = 0;
  BytesReturned = 0;
  v1 = 0;
  v2 = (HANDLE)-1;
  OutBuffer = 0;
  v3 = StringCbPrintfW(&pszDest, 0x40u, L"\\\\.\\PhysicalDrive%lu", a1);
  if ( v3 >= 0 )
  {
    v2 = CreateFileW(&pszDest, 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
    if ( v2 != (HANDLE)-1 && DeviceIoControl(v2, 0x700F8u, 0, 0, &OutBuffer, 1u, &BytesReturned, 0) )
      v6 = OutBuffer != 0;
    else
      v1 = GetLastError();
  }
  else
  {
    v1 = (unsigned __int16)v3;
  }
  if ( v1 )
  {
    v6 = 0;
    RtlSetLastWin32Error(v1);
  }
  if ( v2 != (HANDLE)-1 )
    CloseHandle(v2);
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8B4D7) --------------------------------------------------------
int __stdcall IsVolumeOnCluster(LPCWSTR lpFileName, int a2)
{
  void *v2; // ebx@1
  const WCHAR *v3; // esi@1
  signed int v4; // edi@1
  HANDLE v5; // eax@3
  void *v6; // eax@7
  int v8; // [sp+Ch] [bp-8h]@1
  DWORD v9; // [sp+10h] [bp-4h]@1
  LPCWSTR lpFileNamea; // [sp+1Ch] [bp+8h]@3

  v2 = 0;
  v3 = &lpFileName[a2 - 1];
  v4 = 0;
  v8 = 0;
  v9 = 0;
  if ( *v3 == 92 )
  {
    *v3 = 0;
    v4 = 1;
  }
  v5 = CreateFileW(lpFileName, 0, 3u, 0, 3u, 0x80u, (HANDLE)0xFFFFFFFF);
  lpFileNamea = (LPCWSTR)v5;
  if ( v4 )
    *v3 = 92;
  if ( v5 == (HANDLE)-1 || (v6 = GetExtents(v5), (v2 = v6) == 0) )
  {
    v9 = GetLastError();
    goto LABEL_11;
  }
  if ( *(_DWORD *)v6 )
  {
    v8 = IsDiskOnCluster(*((_DWORD *)v6 + 2));
LABEL_11:
    if ( !v9 )
      goto LABEL_13;
    goto LABEL_12;
  }
  v9 = 87;
LABEL_12:
  v8 = 0;
  RtlSetLastWin32Error(v9);
LABEL_13:
  if ( lpFileNamea != (LPCWSTR)-1 )
    CloseHandle((HANDLE)lpFileNamea);
  if ( v2 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v2);
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8B59E) --------------------------------------------------------
DWORD __stdcall GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
{
  DWORD result; // eax@2
  unsigned int v4; // esi@4
  PVOID v5; // eax@5
  int v6; // eax@9
  NTSTATUS v7; // eax@9
  int v8; // esi@11
  void *v9; // edi@11
  __int16 v10; // [sp+10h] [bp-250h]@9
  PVOID v11; // [sp+14h] [bp-24Ch]@9
  DWORD v12; // [sp+18h] [bp-248h]@4
  int v13; // [sp+1Ch] [bp-244h]@5
  void *Dst; // [sp+20h] [bp-240h]@1
  STRING AnsiString; // [sp+24h] [bp-23Ch]@3
  LSA_UNICODE_STRING UnicodeString; // [sp+2Ch] [bp-234h]@3
  DWORD v17; // [sp+34h] [bp-22Ch]@3
  PVOID Address; // [sp+38h] [bp-228h]@1
  WCHAR szLongPath; // [sp+3Ch] [bp-224h]@4
  CPPEH_RECORD ms_exc; // [sp+248h] [bp-18h]@3

  Dst = lpszLongPath;
  Address = 0;
  if ( lpszShortPath )
  {
    AnsiString.Buffer = 0;
    UnicodeString.Buffer = 0;
    v17 = 0;
    ms_exc.registration.TryLevel = 0;
    if ( Basep8BitStringToDynamicUnicodeString((int)&UnicodeString, lpszShortPath) )
    {
      Address = &szLongPath;
      v4 = GetLongPathNameW(UnicodeString.Buffer, &szLongPath, 0x104u);
      v12 = v4;
      if ( v4 >= 0x104 )
      {
        v13 = *(_DWORD *)(KernelBaseGetGlobalData() + 44);
        v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], v13 + 0x200000, 2 * v12);
        Address = v5;
        if ( v5 )
        {
          v4 = GetLongPathNameW(UnicodeString.Buffer, (LPWSTR)v5, v12);
        }
        else
        {
          v4 = 0;
          RtlSetLastWin32Error(8);
        }
      }
      if ( v4 )
      {
        UnicodeString.MaximumLength = 2 * v4 + 2;
        v11 = Address;
        v10 = 2 * v4;
        v6 = KernelBaseGetGlobalData();
        v7 = (*(int (__stdcall **)(STRING *, __int16 *, signed int))(v6 + 28))(&AnsiString, &v10, 1);
        if ( v7 >= 0 )
        {
          v8 = AnsiString.Length;
          v17 = AnsiString.Length;
          v9 = Dst;
          if ( Dst && cchBuffer > AnsiString.Length )
          {
            _memmove(Dst, AnsiString.Buffer, AnsiString.Length);
            *((_BYTE *)v9 + v8) = 0;
          }
          else
          {
            v17 = AnsiString.Length + 1;
          }
        }
        else
        {
          BaseSetLastNTError(v7);
          v17 = 0;
        }
      }
    }
    ms_exc.registration.TryLevel = -2;
    if ( UnicodeString.Buffer )
      RtlFreeUnicodeString(&UnicodeString);
    if ( AnsiString.Buffer )
      RtlFreeAnsiString(&AnsiString);
    if ( Address )
    {
      if ( Address != &szLongPath )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
    }
    result = v17;
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8B8CF) --------------------------------------------------------
NTSTATUS __stdcall BasepUpdateProcessParametersFlags(HANDLE ProcessHandle, char Buffer, int a3)
{
  return NtWriteVirtualMemory(ProcessHandle, (PVOID)(*(_DWORD *)(a3 + 24) + 8), &Buffer, 4u, 0);
}

//----- (77E8B8F8) --------------------------------------------------------
int __stdcall GetExeName(const char *a1, char a2, int a3)
{
  int result; // eax@1
  __int16 v4; // cx@4

  result = (int)a1;
  if ( a1 )
  {
    if ( a2 )
    {
      *(_BYTE *)a3 = 1;
      do
      {
        v4 = *(_WORD *)result;
        result += 2;
      }
      while ( v4 );
      result = 2 * ((result - (signed int)(a1 + 2)) >> 1);
    }
    else
    {
      *(_BYTE *)a3 = 0;
      result = strlen(a1);
    }
  }
  return result;
}

//----- (77E8B93D) --------------------------------------------------------
int __stdcall AddConsoleAliasInternal(int a1, __int16 a2, void *a3, __int16 a4, void *a5, int a6)
{
  unsigned int v6; // esi@1
  unsigned __int16 v7; // ax@1
  __int16 v9; // cx@5
  PVOID v10; // esi@7
  ULONG v11; // ST0C_4@12
  struct _PORT_MESSAGE RequestMessage; // [sp+10h] [bp-A4h]@11
  NTSTATUS NtStatus; // [sp+30h] [bp-84h]@11
  __int16 v14; // [sp+38h] [bp-7Ch]@1
  unsigned __int16 v15; // [sp+3Ah] [bp-7Ah]@7
  unsigned __int16 v16; // [sp+3Ch] [bp-78h]@1
  int v17; // [sp+40h] [bp-74h]@9
  int v18; // [sp+44h] [bp-70h]@6
  int v19; // [sp+48h] [bp-6Ch]@9
  char v20; // [sp+4Ch] [bp-68h]@1
  char v21; // [sp+4Dh] [bp-67h]@1

  v6 = 2;
  v14 = a2;
  v20 = a6;
  v7 = GetExeName((const char *)a5, a6, (int)&v21);
  v16 = v7;
  if ( !v7 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( a3 )
  {
    v9 = a4;
    v6 = 3;
  }
  else
  {
    v18 = 0;
    v9 = 0;
  }
  v15 = v9;
  v10 = ConsoleAllocateCaptureBuffer(v6, (unsigned __int16)v14 + v7 + (unsigned __int16)v9);
  if ( !v10 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  ConsoleCaptureMessageBuffer((int)v10, (void *)a1, (unsigned __int16)v14, (int)&v17);
  ConsoleCaptureMessageBuffer((int)v10, a5, v16, (int)&v19);
  if ( a3 )
    ConsoleCaptureMessageBuffer((int)v10, a3, v15, (int)&v18);
  ConsoleClientCallServer(&RequestMessage, (int)v10, 50, 24);
  ConsoleFreeCaptureBuffer(v10);
  if ( NtStatus < 0 )
  {
    v11 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v11);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8BA52) --------------------------------------------------------
BOOL __stdcall AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
{
  __int16 v3; // di@2
  LPWSTR v4; // esi@4
  __int16 v5; // ax@6

  if ( Source )
    v3 = 2 * wcslen(Source);
  else
    v3 = 0;
  v4 = Target;
  if ( Target && Target != (LPWSTR)-1 )
  {
    v5 = 2 * wcslen(Target);
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  return AddConsoleAliasInternal((int)Source, v3, v4, v5, ExeName, 1);
}

//----- (77E8BABC) --------------------------------------------------------
BOOL __stdcall AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
{
  __int16 v3; // di@2
  LPSTR v4; // esi@4
  __int16 v5; // ax@6

  if ( Source )
    v3 = strlen(Source);
  else
    v3 = 0;
  v4 = Target;
  if ( Target && Target != LPSTR_TEXTCALLBACKW )
  {
    v5 = strlen(Target);
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  return AddConsoleAliasInternal((int)Source, v3, v4, v5, ExeName, 0);
}

//----- (77E8BB19) --------------------------------------------------------
int __stdcall GetConsoleAliasInternal(void *a1, int a2, int a3, int a4, void *a5, int a6)
{
  int result; // eax@2
  PVOID v7; // esi@4
  ULONG v8; // eax@8
  struct _PORT_MESSAGE RequestMessage; // [sp+Ch] [bp-A4h]@6
  NTSTATUS NtStatus; // [sp+2Ch] [bp-84h]@6
  unsigned __int16 v11; // [sp+34h] [bp-7Ch]@4
  unsigned __int16 v12; // [sp+36h] [bp-7Ah]@4
  unsigned __int16 v13; // [sp+38h] [bp-78h]@3
  int v14; // [sp+3Ch] [bp-74h]@6
  void *Src; // [sp+40h] [bp-70h]@6
  int v16; // [sp+44h] [bp-6Ch]@6
  char v17; // [sp+48h] [bp-68h]@3
  char v18; // [sp+49h] [bp-67h]@3

  if ( a1 && (v17 = a6, (v13 = GetExeName((const char *)a5, a6, (int)&v18)) != 0) )
  {
    v12 = a4;
    v11 = a2;
    v7 = ConsoleAllocateCaptureBuffer(3u, (unsigned __int16)a2 + (unsigned __int16)a4 + v13);
    if ( v7 )
    {
      ConsoleCaptureMessageBuffer((int)v7, a5, v13, (int)&v16);
      ConsoleCaptureMessageBuffer((int)v7, a1, v11, (int)&v14);
      ConsoleCaptureMessageBuffer((int)v7, 0, v12, (int)&Src);
      ConsoleClientCallServer(&RequestMessage, (int)v7, 51, 24);
      if ( NtStatus < 0 )
      {
        v8 = RtlNtStatusToDosError(NtStatus);
        RtlSetLastWin32Error(v8);
        if ( NtStatus != -1073741789 )
          v12 = 0;
      }
      else
      {
        memcpy((void *)a3, Src, v12);
      }
      ConsoleFreeCaptureBuffer(v7);
      result = v12;
    }
    else
    {
      RtlSetLastWin32Error(8);
      result = 0;
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8BC4E) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
{
  int v4; // eax@2

  if ( Source )
    v4 = 2 * wcslen(Source);
  else
    v4 = 0;
  return GetConsoleAliasInternal(Source, v4, (int)TargetBuffer, TargetBufferLength, ExeName, 1);
}

//----- (77E8BC90) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
{
  int v4; // eax@2

  if ( Source )
    v4 = strlen(Source);
  else
    v4 = 0;
  return GetConsoleAliasInternal(Source, v4, (int)TargetBuffer, TargetBufferLength, ExeName, 0);
}

//----- (77E8BCCB) --------------------------------------------------------
int __stdcall GetConsoleAliasesLengthInternal(void *Src, int a2)
{
  unsigned __int16 v2; // ax@1
  PVOID v4; // esi@3
  ULONG v5; // ST0C_4@7
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@5
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@5
  unsigned __int16 v8; // [sp+2Ch] [bp-7Ch]@1
  int v9; // [sp+30h] [bp-78h]@5
  int v10; // [sp+34h] [bp-74h]@6
  char v11; // [sp+38h] [bp-70h]@1
  char v12; // [sp+39h] [bp-6Fh]@1

  v11 = a2;
  v2 = GetExeName((const char *)Src, a2, (int)&v12);
  v8 = v2;
  if ( !v2 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v4 = ConsoleAllocateCaptureBuffer(1u, v2);
  if ( v4 )
  {
    ConsoleCaptureMessageBuffer((int)v4, Src, v8, (int)&v9);
    ConsoleClientCallServer(&RequestMessage, (int)v4, 52, 16);
    ConsoleFreeCaptureBuffer(v4);
    if ( NtStatus >= 0 )
      return v10;
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8BD97) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasesLengthA(LPSTR ExeName)
{
  return GetConsoleAliasesLengthInternal(ExeName, 0);
}

//----- (77E8BDAF) --------------------------------------------------------
int __stdcall GetConsoleAliasExesLengthInternal(char a1)
{
  int result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@2
  char v6; // [sp+2Ch] [bp-78h]@1

  v6 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 53, 8);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = v5;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8BE12) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasExesLengthW()
{
  return GetConsoleAliasExesLengthInternal(1);
}

//----- (77E8BE1F) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasExesLengthA()
{
  return GetConsoleAliasExesLengthInternal(0);
}

//----- (77E8BE2C) --------------------------------------------------------
size_t __stdcall GetConsoleAliasExesInternal(void *Dst, int a2, char a3)
{
  PVOID v3; // esi@1
  ULONG v5; // ST0C_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+14h] [bp-BCh]@3
  NTSTATUS NtStatus; // [sp+34h] [bp-9Ch]@3
  size_t Size; // [sp+3Ch] [bp-94h]@1
  void *Src; // [sp+40h] [bp-90h]@3
  char v10; // [sp+44h] [bp-8Ch]@1
  CPPEH_RECORD ms_exc; // [sp+B8h] [bp-18h]@4

  Size = a2;
  v10 = a3;
  v3 = ConsoleAllocateCaptureBuffer(1u, a2);
  if ( v3 )
  {
    ConsoleCaptureMessageBuffer((int)v3, 0, Size, (int)&Src);
    ConsoleClientCallServer(&RequestMessage, (int)v3, 55, 12);
    if ( NtStatus >= 0 )
    {
      ms_exc.registration.TryLevel = 0;
      memcpy(Dst, Src, Size);
      ms_exc.registration.TryLevel = -2;
      ConsoleFreeCaptureBuffer(v3);
      return Size;
    }
    ConsoleFreeCaptureBuffer(v3);
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8BF4C) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
{
  return GetConsoleAliasExesInternal(ExeNameBuffer, ExeNameBufferLength, 0);
}

//----- (77E8BF67) --------------------------------------------------------
BOOLEAN __stdcall ExpungeConsoleCommandHistoryInternal(void *Src, int a2)
{
  unsigned __int16 v2; // ax@1
  BOOLEAN result; // al@2
  PVOID v4; // edi@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@5
  unsigned __int16 v6; // [sp+2Ch] [bp-7Ch]@1
  int v7; // [sp+30h] [bp-78h]@5
  char v8; // [sp+34h] [bp-74h]@1
  char v9; // [sp+35h] [bp-73h]@1

  v8 = a2;
  v2 = GetExeName((const char *)Src, a2, (int)&v9);
  v6 = v2;
  if ( v2 )
  {
    v4 = ConsoleAllocateCaptureBuffer(1u, v2);
    if ( v4 )
    {
      ConsoleCaptureMessageBuffer((int)v4, Src, v6, (int)&v7);
      ConsoleClientCallServer(&RequestMessage, (int)v4, 56, 12);
      result = ConsoleFreeCaptureBuffer(v4);
    }
    else
    {
      result = RtlSetLastWin32Error(8);
    }
  }
  else
  {
    result = RtlSetLastWin32Error(87);
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C014) --------------------------------------------------------
BOOLEAN __stdcall ExpungeConsoleCommandHistoryA(void *Src)
{
  return ExpungeConsoleCommandHistoryInternal(Src, 0);
}

//----- (77E8C02C) --------------------------------------------------------
signed int __stdcall SetConsoleNumberOfCommandsInternal(int a1, void *a2, char a3)
{
  unsigned __int16 v3; // ax@1
  PVOID v5; // esi@3
  ULONG v6; // ST0C_4@7
  void *Src; // [sp+0h] [bp-A8h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@5
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@5
  int v10; // [sp+2Ch] [bp-7Ch]@1
  unsigned __int16 v11; // [sp+30h] [bp-78h]@1
  int v12; // [sp+34h] [bp-74h]@5
  char v13; // [sp+38h] [bp-70h]@1
  char v14; // [sp+39h] [bp-6Fh]@1

  Src = a2;
  v10 = a1;
  v13 = a3;
  v3 = GetExeName((const char *)&Src, a3, (int)&v14);
  v11 = v3;
  if ( !v3 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v5 = ConsoleAllocateCaptureBuffer(1u, v3);
  if ( v5 )
  {
    ConsoleCaptureMessageBuffer((int)v5, Src, v11, (int)&v12);
    ConsoleClientCallServer(&RequestMessage, (int)v5, 57, 16);
    ConsoleFreeCaptureBuffer(v5);
    if ( NtStatus >= 0 )
      return 1;
    v6 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v6);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C110) --------------------------------------------------------
signed int __stdcall SetConsoleNumberOfCommandsA(int a1, void *a2)
{
  return SetConsoleNumberOfCommandsInternal(a1, a2, 0);
}

//----- (77E8C12B) --------------------------------------------------------
int __stdcall GetConsoleCommandHistoryLengthInternal(void *Src, int a2)
{
  unsigned __int16 v2; // ax@1
  int result; // eax@2
  PVOID v4; // edi@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@5
  int v6; // [sp+2Ch] [bp-7Ch]@5
  unsigned __int16 v7; // [sp+30h] [bp-78h]@1
  int v8; // [sp+34h] [bp-74h]@5
  char v9; // [sp+38h] [bp-70h]@1
  char v10; // [sp+39h] [bp-6Fh]@1

  v9 = a2;
  v2 = GetExeName((const char *)Src, a2, (int)&v10);
  v7 = v2;
  if ( v2 )
  {
    v4 = ConsoleAllocateCaptureBuffer(1u, v2);
    if ( v4 )
    {
      ConsoleCaptureMessageBuffer((int)v4, Src, v7, (int)&v8);
      ConsoleClientCallServer(&RequestMessage, (int)v4, 58, 16);
      ConsoleFreeCaptureBuffer(v4);
      result = v6;
    }
    else
    {
      RtlSetLastWin32Error(8);
      result = 0;
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C1DF) --------------------------------------------------------
int __stdcall GetConsoleCommandHistoryLengthA(void *Src)
{
  return GetConsoleCommandHistoryLengthInternal(Src, 0);
}

//----- (77E8C1F7) --------------------------------------------------------
BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle)
{
  return SetConsoleTitleInternal((void *)lpConsoleTitle, strlen(lpConsoleTitle), 0);
}

//----- (77E8C271) --------------------------------------------------------
int __stdcall GetConsoleInputExeNameW(int a1, void *Dst)
{
  int v2; // esi@1
  int result; // eax@2
  size_t v4; // esi@3

  v2 = (unsigned __int16)ExeNameLength;
  if ( (unsigned __int16)ExeNameLength < (unsigned int)a1 )
  {
    RtlEnterCriticalSection(&ExeNameCriticalSection);
    v4 = 2 * v2;
    memcpy(Dst, ExeNameBuffer, v4);
    *(_WORD *)((char *)Dst + v4) = 0;
    RtlLeaveCriticalSection(&ExeNameCriticalSection);
    result = 1;
  }
  else
  {
    RtlSetLastWin32Error(111);
    result = v2 + 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6000: using guessed type __int16 ExeNameLength;
// 77EA60A0: using guessed type __int16 ExeNameBuffer[];

//----- (77E8C309) --------------------------------------------------------
size_t __stdcall GetConsoleAliasesInternal(int a1, unsigned __int32 a2, void *a3, int a4)
{
  PVOID v4; // ebx@4
  ULONG v6; // ST0C_4@8
  PVOID Address; // [sp+14h] [bp-C0h]@3
  struct _PORT_MESSAGE RequestMessage; // [sp+18h] [bp-BCh]@6
  NTSTATUS NtStatus; // [sp+38h] [bp-9Ch]@6
  unsigned __int16 v10; // [sp+40h] [bp-94h]@1
  int v11; // [sp+44h] [bp-90h]@6
  char v12; // [sp+48h] [bp-8Ch]@3
  char v13; // [sp+49h] [bp-8Bh]@1
  size_t Size; // [sp+4Ch] [bp-88h]@3
  void *Src; // [sp+50h] [bp-84h]@6
  CPPEH_RECORD ms_exc; // [sp+BCh] [bp-18h]@7

  v10 = GetExeName((const char *)a3, a4, (int)&v13);
  if ( v10 && (v12 = a4, Size = a2, ULongAdd(v10, a2, (unsigned __int32 *)&Address) >= 0) )
  {
    v4 = ConsoleAllocateCaptureBuffer(2u, (unsigned int)Address);
    Address = v4;
    if ( v4 )
    {
      ConsoleCaptureMessageBuffer((int)v4, a3, v10, (int)&v11);
      ConsoleCaptureMessageBuffer((int)v4, 0, Size, (int)&Src);
      ConsoleClientCallServer(&RequestMessage, (int)v4, 54, 20);
      if ( NtStatus >= 0 )
      {
        ms_exc.registration.TryLevel = 0;
        memcpy((void *)a1, Src, Size);
        ms_exc.registration.TryLevel = -2;
        ConsoleFreeCaptureBuffer(v4);
        return Size;
      }
      ConsoleFreeCaptureBuffer(v4);
      v6 = RtlNtStatusToDosError(NtStatus);
      RtlSetLastWin32Error(v6);
    }
    else
    {
      RtlSetLastWin32Error(8);
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C471) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
{
  return GetConsoleAliasesInternal((int)AliasBuffer, AliasBufferLength, ExeName, 1);
}

//----- (77E8C48F) --------------------------------------------------------
DWORD __stdcall GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
{
  return GetConsoleAliasesInternal((int)AliasBuffer, AliasBufferLength, ExeName, 0);
}

//----- (77E8C4AD) --------------------------------------------------------
size_t __stdcall GetConsoleCommandHistoryInternal(int a1, unsigned __int32 a2, void *a3, int a4)
{
  unsigned __int16 v4; // ax@1
  PVOID v5; // esi@4
  ULONG v7; // ST0C_4@8
  PVOID Address; // [sp+14h] [bp-C0h]@3
  struct _PORT_MESSAGE RequestMessage; // [sp+18h] [bp-BCh]@6
  NTSTATUS NtStatus; // [sp+38h] [bp-9Ch]@6
  size_t Size; // [sp+40h] [bp-94h]@1
  void *Src; // [sp+44h] [bp-90h]@6
  unsigned __int16 v13; // [sp+48h] [bp-8Ch]@1
  int v14; // [sp+4Ch] [bp-88h]@6
  char v15; // [sp+50h] [bp-84h]@1
  char v16; // [sp+51h] [bp-83h]@1
  CPPEH_RECORD ms_exc; // [sp+BCh] [bp-18h]@7

  Size = a2;
  v4 = GetExeName((const char *)a3, a4, (int)&v16);
  v13 = v4;
  v15 = a4;
  if ( v4 && ULongAdd(a2, v4, (unsigned __int32 *)&Address) >= 0 )
  {
    v5 = ConsoleAllocateCaptureBuffer(2u, (unsigned int)Address);
    Address = v5;
    if ( v5 )
    {
      ConsoleCaptureMessageBuffer((int)v5, a3, v13, (int)&v14);
      ConsoleCaptureMessageBuffer((int)v5, 0, Size, (int)&Src);
      ConsoleClientCallServer(&RequestMessage, (int)v5, 59, 20);
      if ( NtStatus >= 0 )
      {
        ms_exc.registration.TryLevel = 0;
        memcpy((void *)a1, Src, Size);
        ms_exc.registration.TryLevel = -2;
        ConsoleFreeCaptureBuffer(v5);
        return Size;
      }
      ConsoleFreeCaptureBuffer(v5);
      v7 = RtlNtStatusToDosError(NtStatus);
      RtlSetLastWin32Error(v7);
    }
    else
    {
      RtlSetLastWin32Error(8);
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C611) --------------------------------------------------------
size_t __stdcall GetConsoleCommandHistoryW(int a1, unsigned __int32 a2, void *a3)
{
  return GetConsoleCommandHistoryInternal(a1, a2, a3, 1);
}

//----- (77E8C62F) --------------------------------------------------------
size_t __stdcall GetConsoleCommandHistoryA(int a1, unsigned __int32 a2, void *a3)
{
  return GetConsoleCommandHistoryInternal(a1, a2, a3, 0);
}

//----- (77E8C64D) --------------------------------------------------------
int __stdcall GetConsoleInputExeNameA(USHORT a1, CHAR *a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  NTSTATUS v4; // eax@3
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-214h]@3
  STRING v7; // [sp+14h] [bp-20Ch]@3
  WCHAR SourceString; // [sp+1Ch] [bp-204h]@1

  v2 = GetConsoleInputExeNameW(256, &SourceString);
  v3 = v2;
  if ( v2 )
  {
    if ( (unsigned int)v2 < 0x100 )
    {
      RtlInitUnicodeString(&DestinationString, &SourceString);
      v7.Length = 0;
      v7.MaximumLength = a1;
      v7.Buffer = a2;
      v4 = RtlUnicodeStringToAnsiString(&v7, &DestinationString, 0);
      if ( v4 < 0 )
      {
        if ( v4 == -2147483643 )
        {
          RtlSetLastWin32Error(111);
          return v3 + 1;
        }
        RtlSetLastWin32Error(87);
      }
    }
  }
  return v3;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C700) --------------------------------------------------------
int __stdcall SetConsoleInputExeNameA(PCSZ SourceString)
{
  NTSTATUS v1; // eax@1
  int result; // eax@5
  int v3; // esi@6
  STRING DestinationString; // [sp+0h] [bp-10h]@1
  LSA_UNICODE_STRING UnicodeString; // [sp+8h] [bp-8h]@1

  RtlInitAnsiString(&DestinationString, SourceString);
  v1 = RtlAnsiStringToUnicodeString(&UnicodeString, &DestinationString, 1u);
  if ( v1 >= 0 )
  {
    v3 = SetConsoleInputExeNameW(UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    result = v3;
  }
  else
  {
    if ( v1 == -2147483643 )
      RtlSetLastWin32Error(206);
    else
      RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8C764) --------------------------------------------------------
NTSTATUS __stdcall RtlStringCchCopyA(char *pszDest, size_t cchDest, const char *pszSrc)
{
  NTSTATUS result; // eax@1
  char *v4; // eax@5
  NTSTATUS v5; // ebx@5
  size_t v6; // esi@5
  char v7; // cl@7

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -1073741811;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cchDest;
    if ( !cchDest )
      goto LABEL_14;
    do
    {
      if ( !(2147483646 - cchDest + v6) )
        break;
      v7 = v4[pszSrc - pszDest];
      if ( !v7 )
        break;
      *v4++ = v7;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_14:
      --v4;
      v5 = -2147483643;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (77E8C7CC) --------------------------------------------------------
size_t __stdcall GetConsoleOriginalTitleA(int a1, size_t cbDest)
{
  return GetConsoleTitleInternal(a1, cbDest, 0, 1);
}

//----- (77E8C7E9) --------------------------------------------------------
DWORD __stdcall GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
{
  return GetConsoleTitleInternal((int)lpConsoleTitle, 2 * nSize, 1, 1);
}

//----- (77E8C809) --------------------------------------------------------
DWORD __stdcall GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
{
  return GetConsoleTitleInternal((int)lpConsoleTitle, nSize, 0, 0);
}

//----- (77E8C826) --------------------------------------------------------
signed int __stdcall FreeConsoleInternal()
{
  ConsoleClientCleanup(1);
  return 1;
}

//----- (77E8C836) --------------------------------------------------------
NTSTATUS __stdcall AttachConsoleInternal(HANDLE ProcessHandle, int a2)
{
  HANDLE v2; // esi@1
  NTSTATUS result; // eax@2
  int v4; // ST10_4@8
  NTSTATUS v5; // eax@8
  char ProcessInformation; // [sp+Ch] [bp-264h]@2
  void *v7; // [sp+20h] [bp-250h]@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+24h] [bp-24Ch]@4
  CLIENT_ID ClientId; // [sp+3Ch] [bp-234h]@4
  HANDLE Handle; // [sp+44h] [bp-22Ch]@4
  int v11; // [sp+48h] [bp-228h]@5
  NTSTATUS v12; // [sp+4Ch] [bp-224h]@5
  HANDLE v13; // [sp+50h] [bp-220h]@7
  char v14; // [sp+58h] [bp-218h]@7
  char v15; // [sp+59h] [bp-217h]@7
  char v16; // [sp+5Ah] [bp-216h]@7
  char v17; // [sp+5Bh] [bp-215h]@7
  char v18; // [sp+60h] [bp-210h]@8

  v2 = ProcessHandle;
  if ( ProcessHandle == (HANDLE)-1 )
  {
    result = NtQueryInformationProcess(ProcessHandle, 0, &ProcessInformation, 0x18u, 0);
    if ( result < 0 )
      return result;
    v2 = v7;
  }
  ClientId.UniqueThread = 0;
  ClientId.UniqueProcess = v2;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  result = NtOpenProcess(&Handle, 0x1000u, &ObjectAttributes, &ClientId);
  if ( result >= 0 )
  {
    v12 = NtQueryInformationProcess(Handle, ProcessConsoleHostProcess, &v11, 4u, 0);
    NtClose(Handle);
    if ( v12 < 0 )
      goto LABEL_15;
    if ( v11 )
    {
      v16 = 0;
      v15 = 1;
      v17 = 0;
      v14 = 1;
      v13 = v2;
      v12 = 540;
      result = CsrClientConnectToServer(0, 2, &v13, &v12, 0);
      if ( result < 0 )
        return result;
      v4 = v11;
      *(_DWORD *)(a2 + 248) = v2;
      *(_BYTE *)(a2 + 244) = 0;
      v5 = ConsoleConnect((const void *)a2, (int)&v18, v4);
    }
    else
    {
      v5 = -1073741790;
    }
    if ( v5 < 0 )
    {
LABEL_15:
      result = -1073741823;
    }
    else
    {
      NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] = v2;
      result = 0;
    }
  }
  return result;
}
// 77DE1670: using guessed type int __stdcall CsrClientConnectToServer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E8C9B3) --------------------------------------------------------
BOOL __stdcall FreeConsole()
{
  NTSTATUS v0; // edi@4
  BOOL result; // eax@7
  ULONG v2; // eax@8

  RtlEnterCriticalSection(&DllLock);
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
  {
    FreeConsoleInternal();
    NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] = 0;
    if ( InputWaitHandle )
    {
      CloseHandle(InputWaitHandle);
      InputWaitHandle = 0;
    }
    v0 = 0;
  }
  else
  {
    v0 = -1073741811;
  }
  RtlLeaveCriticalSection(&DllLock);
  if ( v0 < 0 )
  {
    v2 = RtlNtStatusToDosError(v0);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CA31) --------------------------------------------------------
NTSTATUS __stdcall AllocConsoleInternal(int a1)
{
  NTSTATUS v1; // esi@1
  int v2; // ST10_4@7
  NTSTATUS result; // eax@8
  HANDLE Handles; // [sp+Ch] [bp-230h]@3
  HANDLE v5; // [sp+10h] [bp-22Ch]@3
  int v6; // [sp+14h] [bp-228h]@1
  HANDLE Handle; // [sp+18h] [bp-224h]@2
  int v8; // [sp+1Ch] [bp-220h]@1
  HANDLE v9; // [sp+20h] [bp-21Ch]@3
  char v10; // [sp+24h] [bp-218h]@1
  char v11; // [sp+25h] [bp-217h]@1
  char v12; // [sp+26h] [bp-216h]@1
  char v13; // [sp+27h] [bp-215h]@1
  int v14; // [sp+28h] [bp-214h]@7
  wchar_t pszDest; // [sp+2Ch] [bp-210h]@1

  RtlStringCchCopyNW(
    &pszDest,
    0x105u,
    (const wchar_t *)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters[1].Reserved2[9],
    (unsigned int)LOWORD(NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters[1].Reserved2[8]) >> 1);
  v8 = 0;
  v10 = 1;
  v12 = 1;
  v11 = 0;
  v13 = 0;
  v6 = 540;
  v1 = CsrClientConnectToServer(0, 2, &v8, &v6, 0);
  if ( v1 < 0 )
    goto LABEL_12;
  v1 = ConsoleOpenWaitEvent(v8, (int)&pszDest, &Handle);
  if ( v1 >= 0 )
  {
    Handles = Handle;
    v5 = v9;
    v1 = NtWaitForMultipleObjects(2u, &Handles, WaitAny, 0, 0);
    if ( v1 == 1 )
      v1 = -1073741823;
    NtClose(Handle);
  }
  NtClose(v9);
  if ( v1 < 0
    || (v2 = v8, *(_DWORD *)(a1 + 252) = v14, v1 = ConsoleConnect((const void *)a1, (int)&pszDest, v2), v1 < 0) )
  {
LABEL_12:
    result = v1;
  }
  else
  {
    NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] = (PVOID)v8;
    result = 0;
  }
  return result;
}
// 77DE1670: using guessed type int __stdcall CsrClientConnectToServer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E8CB95) --------------------------------------------------------
BOOL __stdcall AllocConsole()
{
  ULONG v0; // eax@2
  BOOL result; // eax@2
  NTSTATUS v2; // edi@3
  bool v3; // sf@3
  int v4; // ecx@4
  ULONG v5; // eax@7
  char Dst; // [sp+4h] [bp-628h]@3
  void *v7; // [sp+8h] [bp-624h]@4

  RtlEnterCriticalSection(&DllLock);
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
  {
    RtlLeaveCriticalSection(&DllLock);
    v0 = RtlNtStatusToDosError(-1073741790);
    RtlSetLastWin32Error(v0);
    result = 0;
  }
  else
  {
    InitializeConsoleConnectionInfo(&Dst);
    v2 = AllocConsoleInternal((int)&Dst);
    v3 = v2 < 0;
    if ( v2 >= 0 )
    {
      SetUpHandles((int)&Dst);
      InitializeCtrlHandling();
      InputWaitHandle = v7;
      SetTEBLangID(v4);
      v3 = v2 < 0;
    }
    gbConsoleApp = !v3;
    RtlLeaveCriticalSection(&DllLock);
    if ( v2 < 0 )
    {
      v5 = RtlNtStatusToDosError(v2);
      RtlSetLastWin32Error(v5);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);
// 77EA6541: using guessed type char gbConsoleApp;

//----- (77E8CC63) --------------------------------------------------------
BOOL __stdcall AttachConsole(DWORD dwProcessId)
{
  ULONG v1; // eax@2
  BOOL result; // eax@2
  NTSTATUS v3; // edi@3
  int v4; // ecx@4
  ULONG v5; // eax@7
  char Dst; // [sp+4h] [bp-628h]@3
  void *v7; // [sp+8h] [bp-624h]@4

  RtlEnterCriticalSection(&DllLock);
  if ( NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0] )
  {
    v1 = RtlNtStatusToDosError(-1073741790);
    RtlSetLastWin32Error(v1);
    RtlLeaveCriticalSection(&DllLock);
    result = 0;
  }
  else
  {
    InitializeConsoleConnectionInfo(&Dst);
    v3 = AttachConsoleInternal((HANDLE)dwProcessId, (int)&Dst);
    if ( v3 >= 0 )
    {
      SetUpHandles((int)&Dst);
      InitializeCtrlHandling();
      InputWaitHandle = v7;
      SetTEBLangID(v4);
    }
    RtlLeaveCriticalSection(&DllLock);
    if ( v3 < 0 )
    {
      v5 = RtlNtStatusToDosError(v3);
      RtlSetLastWin32Error(v5);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CD2C) --------------------------------------------------------
HANDLE __stdcall GetConsoleInputWaitHandle()
{
  return InputWaitHandle;
}

//----- (77E8CD37) --------------------------------------------------------
signed int __stdcall GetConsoleHandleInformation(int a1, int a2)
{
  signed int result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+10h] [bp-BCh]@1
  NTSTATUS NtStatus; // [sp+30h] [bp-9Ch]@1
  int v6; // [sp+38h] [bp-94h]@1
  int v7; // [sp+3Ch] [bp-90h]@2
  CPPEH_RECORD ms_exc; // [sp+B4h] [bp-18h]@2

  v6 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 32, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = v7;
    ms_exc.registration.TryLevel = -2;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CDE1) --------------------------------------------------------
signed int __stdcall SetConsoleHandleInformation(int a1, int a2, int a3)
{
  signed int result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v7; // [sp+28h] [bp-7Ch]@1
  int v8; // [sp+2Ch] [bp-78h]@1
  int v9; // [sp+30h] [bp-74h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 33, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CE50) --------------------------------------------------------
BOOL __stdcall ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
{
  __int16 v5; // ax@1
  NTSTATUS v6; // eax@1
  NTSTATUS v7; // esi@1
  ULONG v8; // eax@2
  BOOL result; // eax@3
  char Dst; // [sp+Ch] [bp-54h]@1

  v5 = GetCurrentExeName(&Dst, 40);
  v6 = ReadConsoleInternal(
         (int)hConsoleInput,
         (int)lpBuffer,
         nNumberOfCharsToRead,
         (int)lpNumberOfCharsRead,
         0,
         0,
         (unsigned __int16)v5,
         &Dst);
  v7 = v6;
  result = 1;
  if ( v6 < 0 )
  {
    v8 = RtlNtStatusToDosError(v6);
    RtlSetLastWin32Error(v8);
    if ( v7 != -1073741536 )
      result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CEC9) --------------------------------------------------------
signed int __stdcall SetConsoleCursor(int a1, int a2)
{
  ULONG v2; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v6; // [sp+28h] [bp-7Ch]@1
  int v7; // [sp+2Ch] [bp-78h]@1

  v6 = a1;
  v7 = a2;
  ConsoleClientCallServer(&RequestMessage, 0, 41, 8);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8CF32) --------------------------------------------------------
int __stdcall ShowConsoleCursor(int a1, int a2)
{
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  int v4; // [sp+28h] [bp-7Ch]@1
  int v5; // [sp+2Ch] [bp-78h]@1
  int v6; // [sp+30h] [bp-74h]@1

  v4 = a1;
  v5 = a2;
  ConsoleClientCallServer(&RequestMessage, 0, 42, 12);
  return v6;
}

//----- (77E8CF7B) --------------------------------------------------------
int __stdcall ConsoleMenuControl(int a1, int a2, int a3)
{
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  int v5; // [sp+28h] [bp-7Ch]@1
  int v6; // [sp+2Ch] [bp-78h]@1
  int v7; // [sp+30h] [bp-74h]@1
  int v8; // [sp+34h] [bp-70h]@1

  v5 = a1;
  v6 = a2;
  v7 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 43, 16);
  return v8;
}

//----- (77E8CFCA) --------------------------------------------------------
signed int __stdcall SetConsolePaletteInternal(int a1, int a2, int a3)
{
  ULONG v3; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v7; // [sp+28h] [bp-7Ch]@1
  int v8; // [sp+2Ch] [bp-78h]@1
  int v9; // [sp+30h] [bp-74h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 44, 12);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D039) --------------------------------------------------------
BOOL __stdcall SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
{
  BOOL result; // eax@4
  ULONG v4; // eax@5
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  HANDLE v7; // [sp+2Ch] [bp-7Ch]@1
  DWORD v8; // [sp+30h] [bp-78h]@1
  struct _COORD v9; // [sp+34h] [bp-74h]@3

  v7 = hConsoleOutput;
  v8 = dwFlags;
  ConsoleClientCallServer(&RequestMessage, 0, 45, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    if ( lpNewScreenBufferDimensions )
      *lpNewScreenBufferDimensions = v9;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D0B0) --------------------------------------------------------
signed int __stdcall RegisterConsoleVDM(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  ULONG v9; // eax@4
  signed int result; // eax@4
  struct _PORT_MESSAGE RequestMessage; // [sp+Ch] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+2Ch] [bp-84h]@3
  int v13; // [sp+34h] [bp-7Ch]@1
  int v14; // [sp+38h] [bp-78h]@2
  int v15; // [sp+3Ch] [bp-74h]@2
  int v16; // [sp+40h] [bp-70h]@2
  int v17; // [sp+44h] [bp-6Ch]@6
  int v18; // [sp+48h] [bp-68h]@6
  int v19; // [sp+4Ch] [bp-64h]@6

  v13 = a1;
  if ( a1 )
  {
    v14 = a2;
    v15 = a3;
    v16 = a4;
  }
  ConsoleClientCallServer(&RequestMessage, 0, 46, 28);
  if ( NtStatus >= 0 )
  {
    if ( a1 )
    {
      *(_DWORD *)a6 = v17;
      *(_DWORD *)a7 = v18;
      *(_DWORD *)a9 = v19;
    }
    result = 1;
  }
  else
  {
    v9 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v9);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D14D) --------------------------------------------------------
signed int __stdcall GetConsoleHardwareState(int a1, int a2, int a3)
{
  ULONG v3; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@1
  int v7; // [sp+30h] [bp-7Ch]@1
  int v8; // [sp+34h] [bp-78h]@3
  int v9; // [sp+38h] [bp-74h]@3

  v7 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 47, 12);
  if ( NtStatus >= 0 )
  {
    *(_DWORD *)a2 = v8;
    *(_DWORD *)a3 = v9;
    result = 1;
  }
  else
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D1C4) --------------------------------------------------------
signed int __stdcall SetConsoleHardwareState(int a1, int a2, int a3)
{
  ULONG v3; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v7; // [sp+28h] [bp-7Ch]@1
  int v8; // [sp+2Ch] [bp-78h]@1
  int v9; // [sp+30h] [bp-74h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 48, 12);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D233) --------------------------------------------------------
BOOL __stdcall GetConsoleDisplayMode(LPDWORD lpModeFlags)
{
  BOOL result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  int v3; // [sp+24h] [bp-84h]@1
  DWORD v4; // [sp+2Ch] [bp-7Ch]@2

  ConsoleClientCallServer(&RequestMessage, 0, 49, 4);
  if ( v3 < 0 )
  {
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    *lpModeFlags = v4;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D293) --------------------------------------------------------
int __stdcall SetConsoleKeyShortcuts(int a1, char a2, void *Src, int a4)
{
  PVOID v4; // edi@1
  ULONG v6; // ST0C_4@11
  struct _PORT_MESSAGE RequestMessage; // [sp+Ch] [bp-A4h]@8
  NTSTATUS NtStatus; // [sp+2Ch] [bp-84h]@10
  int v9; // [sp+34h] [bp-7Ch]@1
  char v10; // [sp+38h] [bp-78h]@1
  int v11; // [sp+3Ch] [bp-74h]@3
  int v12; // [sp+40h] [bp-70h]@6

  v9 = a1;
  v4 = 0;
  v10 = a2;
  if ( Src && a4 )
  {
    v11 = a4;
    v4 = ConsoleAllocateCaptureBuffer(1u, 4 * a4);
    if ( !v4 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer((int)v4, Src, 4 * a4, (int)&v12);
  }
  else
  {
    v11 = 0;
  }
  ConsoleClientCallServer(&RequestMessage, (int)v4, 62, 16);
  if ( v4 )
    ConsoleFreeCaptureBuffer(v4);
  if ( NtStatus < 0 )
  {
    v6 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v6);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D346) --------------------------------------------------------
signed int __stdcall SetConsoleMenuClose(int a1)
{
  ULONG v1; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@1

  v5 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 63, 4);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D3A9) --------------------------------------------------------
signed int __stdcall SetConsolePalette(int a1, int a2, int a3)
{
  return SetConsolePaletteInternal(a1, a2, a3);
}

//----- (77E8D3FF) --------------------------------------------------------
bool __stdcall GetConsoleInput(int a1, void *a2, unsigned int a3, int a4, __int16 a5, char a6)
{
  PVOID v7; // edi@5
  int v8; // eax@10
  ULONG v9; // eax@11
  struct _PORT_MESSAGE RequestMessage; // [sp+14h] [bp-BCh]@9
  NTSTATUS NtStatus; // [sp+34h] [bp-9Ch]@9
  int v12; // [sp+3Ch] [bp-94h]@4
  char v13; // [sp+40h] [bp-90h]@8
  void *Src; // [sp+A4h] [bp-2Ch]@7
  int v15; // [sp+A8h] [bp-28h]@4
  __int16 v16; // [sp+ACh] [bp-24h]@4
  char v17; // [sp+AEh] [bp-22h]@4
  CPPEH_RECORD ms_exc; // [sp+B8h] [bp-18h]@2

  if ( (a1 & 0x10000003) != 3 )
  {
    *(_DWORD *)a4 = 0;
    RtlSetLastWin32Error(6);
    ms_exc.registration.TryLevel = -2;
    return 0;
  }
  v12 = a1;
  v15 = a3;
  v16 = a5;
  v17 = a6;
  if ( a3 <= 5 )
  {
    Src = &v13;
    v7 = 0;
  }
  else
  {
    v7 = ConsoleAllocateCaptureBuffer(1u, 20 * a3);
    if ( !v7 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer((int)v7, 0, 20 * a3, (int)&Src);
  }
  ConsoleClientCallServer(&RequestMessage, (int)v7, 1, 116);
  if ( NtStatus < 0 )
  {
    *(_DWORD *)a4 = 0;
    v9 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v9);
  }
  else
  {
    v8 = v15;
    *(_DWORD *)a4 = v15;
    memcpy(a2, Src, 20 * v8);
  }
  if ( v7 )
    ConsoleFreeCaptureBuffer(v7);
  return NtStatus >= 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D531) --------------------------------------------------------
BOOL __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = GetConsoleInput((int)hConsoleInput, lpBuffer, nLength, (int)lpNumberOfEventsRead, 3, 0);
  return result;
}

//----- (77E8D554) --------------------------------------------------------
BOOL __stdcall PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = GetConsoleInput((int)hConsoleInput, lpBuffer, nLength, (int)lpNumberOfEventsRead, 3, 1);
  return result;
}

//----- (77E8D59A) --------------------------------------------------------
BOOL __stdcall ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = GetConsoleInput((int)hConsoleInput, lpBuffer, nLength, (int)lpNumberOfEventsRead, 0, 1);
  return result;
}

//----- (77E8D5BD) --------------------------------------------------------
bool __stdcall ReadConsoleInputExA(int a1, void *a2, unsigned int a3, int a4, __int16 a5)
{
  return GetConsoleInput(a1, a2, a3, a4, a5, 0);
}

//----- (77E8D5E1) --------------------------------------------------------
bool __stdcall ReadConsoleInputExW(int a1, void *a2, unsigned int a3, int a4, __int16 a5)
{
  return GetConsoleInput(a1, a2, a3, a4, a5, 1);
}

//----- (77E8D605) --------------------------------------------------------
int __stdcall WriteConsoleInputInternal(int a1, void *Src, int a3, int a4, char a5, char a6)
{
  PVOID v6; // edi@2
  ULONG v7; // ST0C_4@10
  struct _PORT_MESSAGE RequestMessage; // [sp+14h] [bp-BCh]@7
  NTSTATUS NtStatus; // [sp+34h] [bp-9Ch]@9
  int v11; // [sp+3Ch] [bp-94h]@1
  char Dst; // [sp+40h] [bp-90h]@6
  int v13; // [sp+A4h] [bp-2Ch]@5
  int v14; // [sp+A8h] [bp-28h]@1
  char v15; // [sp+ACh] [bp-24h]@1
  char v16; // [sp+ADh] [bp-23h]@1
  CPPEH_RECORD ms_exc; // [sp+B8h] [bp-18h]@6

  v11 = a1;
  v14 = a3;
  v15 = a5;
  v16 = a6;
  if ( (unsigned int)a3 <= 5 )
  {
    v13 = (int)&Dst;
    v6 = 0;
    ms_exc.registration.TryLevel = 0;
    memcpy(&Dst, Src, 20 * a3);
    ms_exc.registration.TryLevel = -2;
  }
  else
  {
    v6 = ConsoleAllocateCaptureBuffer(1u, 20 * a3);
    if ( !v6 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer((int)v6, Src, 20 * a3, (int)&v13);
  }
  ConsoleClientCallServer(&RequestMessage, (int)v6, 2, 116);
  if ( v6 )
    ConsoleFreeCaptureBuffer(v6);
  *(_DWORD *)a4 = v14;
  if ( NtStatus < 0 )
  {
    v7 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v7);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8D719) --------------------------------------------------------
BOOL __stdcall WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
{
  return WriteConsoleInputInternal((int)hConsoleInput, (void *)lpBuffer, nLength, (int)lpNumberOfEventsWritten, 0, 1);
}

//----- (77E8D75F) --------------------------------------------------------
void *__stdcall CopyRectangle(void *Src, __int16 a2, int a3, void *Dst, int a5, int a6)
{
  void *result; // eax@1
  __int16 v7; // dx@1
  signed __int16 v8; // di@1
  const void *v9; // esi@7
  char *v10; // ecx@13
  int v11; // ebx@21
  int v12; // edx@27
  int v13; // [sp+Ch] [bp-Ch]@21
  signed __int16 v14; // [sp+10h] [bp-8h]@1
  char v15; // [sp+17h] [bp-1h]@9
  char v16; // [sp+2Bh] [bp+13h]@15

  result = (void *)a3;
  v7 = *(_WORD *)(a3 + 2);
  v8 = *(_WORD *)(a3 + 6) - v7 + 1;
  v14 = *(_WORD *)(a3 + 4) - *(_WORD *)a3 + 1;
  if ( v14 > (signed __int16)(a5 - a6 + 1) )
    v14 = a5 - a6 + 1;
  if ( v8 > (signed __int16)(HIWORD(a5) - HIWORD(a6) + 1) )
    v8 = HIWORD(a5) - HIWORD(a6) + 1;
  if ( v14 == a2 )
  {
    if ( v7 )
      v9 = (char *)Src + 4 * (*(_WORD *)a3 + a2 * v7);
    else
      v9 = Src;
    v15 = 1;
  }
  else
  {
    v15 = 0;
    v9 = 0;
  }
  if ( v14 == (_WORD)a5 )
  {
    if ( HIWORD(a6) )
      v10 = (char *)Dst + 4 * ((signed __int16)a6 + (signed __int16)a5 * SHIWORD(a6));
    else
      v10 = (char *)Dst;
    v16 = 1;
  }
  else
  {
    v16 = 0;
    v10 = 0;
  }
  if ( v15 && v16 )
  {
    result = memmove(v10, v9, 4 * v14 * v8);
  }
  else if ( v8 > 0 )
  {
    v11 = 0;
    v13 = (unsigned __int16)v8;
    do
    {
      if ( !v16 )
        v10 = (char *)Dst + 4 * ((signed __int16)a6 + (signed __int16)a5 * (v11 + SHIWORD(a6)));
      if ( !v15 )
        v9 = (char *)Src + 4 * (*(_WORD *)result + a2 * (v11 + *((_WORD *)result + 1)));
      if ( v14 > 0 )
      {
        v12 = (unsigned __int16)v14;
        do
        {
          *(_DWORD *)v10 = *(_DWORD *)v9;
          v9 = (char *)v9 + 4;
          v10 += 4;
          --v12;
        }
        while ( v12 );
      }
      ++v11;
      --v13;
    }
    while ( v13 );
  }
  return result;
}

//----- (77E8D8C2) --------------------------------------------------------
signed int __stdcall ReadConsoleOutputInternal(int a1, void *a2, int a3, int a4, int a5, char a6)
{
  __int16 v6; // cx@1
  __int16 v7; // cx@1
  __int16 v8; // dx@3
  __int16 v9; // ax@3
  __int16 v10; // bx@5
  int v11; // eax@5
  size_t v12; // edi@6
  int v13; // eax@6
  int v15; // edi@9
  __int16 v16; // ax@12
  __int16 v17; // cx@12
  bool v18; // sf@15
  ULONG v19; // ST14_4@16
  unsigned int v20; // [sp+Ch] [bp-B8h]@3
  PVOID Address; // [sp+14h] [bp-B0h]@3
  PVOID Addressa; // [sp+14h] [bp-B0h]@6
  __int16 v23[2]; // [sp+18h] [bp-ACh]@1
  __int16 v24; // [sp+1Ch] [bp-A8h]@12
  __int16 v25; // [sp+1Eh] [bp-A6h]@12
  struct _PORT_MESSAGE RequestMessage; // [sp+20h] [bp-A4h]@11
  NTSTATUS NtStatus; // [sp+40h] [bp-84h]@11
  int v28; // [sp+48h] [bp-7Ch]@1
  char v29; // [sp+4Ch] [bp-78h]@10
  void *Src; // [sp+50h] [bp-74h]@9
  int v31; // [sp+54h] [bp-70h]@5
  int v32; // [sp+58h] [bp-6Ch]@5
  char v33; // [sp+5Ch] [bp-68h]@1

  v28 = a1;
  v6 = *(_WORD *)(a5 + 4);
  v33 = a6;
  v7 = v6 - *(_WORD *)a5 + 1;
  v23[0] = v7;
  if ( v7 > (signed __int16)a3 - (signed __int16)a4 )
  {
    v7 = a3 - a4;
    v23[0] = a3 - a4;
  }
  v8 = *(_WORD *)(a5 + 2);
  Address = (PVOID)((unsigned int)a4 >> 16);
  v20 = (unsigned int)a3 >> 16;
  v23[1] = *(_WORD *)(a5 + 6) - v8 + 1;
  v9 = v23[1];
  if ( v23[1] > SHIWORD(a3) - SHIWORD(a4) )
  {
    v9 = v20 - (_WORD)Address;
    v23[1] = v20 - (_WORD)Address;
  }
  v10 = v23[0];
  v11 = v7 * v9;
  LOWORD(v31) = *(_WORD *)a5;
  LOWORD(v32) = v31 + v23[0] - 1;
  HIWORD(v31) = v8;
  HIWORD(v32) = v8 + v23[1] - 1;
  if ( (unsigned int)v11 <= 1 )
  {
    v15 = 0;
    Src = &v29;
  }
  else
  {
    v12 = 4 * v11;
    v13 = (int)ConsoleAllocateCaptureBuffer(1u, 4 * v11);
    Addressa = (PVOID)v13;
    if ( !v13 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer(v13, 0, v12, (int)&Src);
    v15 = (int)Addressa;
  }
  ConsoleClientCallServer(&RequestMessage, v15, 3, 24);
  if ( NtStatus >= 0 )
  {
    v16 = v31 - *(_WORD *)a5;
    v17 = HIWORD(v31) - *(_WORD *)(a5 + 2);
    LOWORD(a4) = v16 + a4;
    HIWORD(a4) += v17;
    v23[0] = v31 - *(_WORD *)a5;
    v23[1] = v17;
    v24 = v16 + v32 - v31;
    v25 = v17 + HIWORD(v32) - HIWORD(v31);
    CopyRectangle(Src, v10, (int)v23, a2, a3, a4);
  }
  if ( v15 )
    ConsoleFreeCaptureBuffer((PVOID)v15);
  v18 = NtStatus < 0;
  *(_DWORD *)a5 = v31;
  *(_DWORD *)(a5 + 4) = v32;
  if ( v18 )
  {
    v19 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v19);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8DAB1) --------------------------------------------------------
BOOL __stdcall ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
{
  return ReadConsoleOutputInternal(
           (int)hConsoleOutput,
           lpBuffer,
           *(_DWORD *)&dwBufferSize,
           *(_DWORD *)&dwBufferCoord,
           (int)lpReadRegion,
           1);
}

//----- (77E8DAD5) --------------------------------------------------------
BOOL __stdcall ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
{
  return ReadConsoleOutputInternal(
           (int)hConsoleOutput,
           lpBuffer,
           *(_DWORD *)&dwBufferSize,
           *(_DWORD *)&dwBufferCoord,
           (int)lpReadRegion,
           0);
}

//----- (77E8DAF9) --------------------------------------------------------
int __stdcall WriteConsoleOutputString(int a1, void *Src, int a3, int a4, int a5, int a6, int a7)
{
  PVOID v7; // edi@2
  bool v9; // sf@9
  ULONG v10; // ST0C_4@10
  size_t v11; // [sp-4h] [bp-B8h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+10h] [bp-A4h]@7
  NTSTATUS NtStatus; // [sp+30h] [bp-84h]@9
  int v14; // [sp+38h] [bp-7Ch]@1
  int v15; // [sp+3Ch] [bp-78h]@1
  int v16; // [sp+40h] [bp-74h]@1
  char Dst; // [sp+44h] [bp-70h]@6
  int v18; // [sp+94h] [bp-20h]@5
  int v19; // [sp+98h] [bp-1Ch]@1

  v14 = a1;
  v19 = a3;
  v16 = a5;
  v15 = a6;
  v11 = a4 * a3;
  if ( (unsigned int)(a4 * a3) <= 0x50 )
  {
    v18 = (int)&Dst;
    v7 = 0;
    memcpy(&Dst, Src, v11);
  }
  else
  {
    v7 = ConsoleAllocateCaptureBuffer(1u, v11);
    if ( !v7 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer((int)v7, Src, a4 * a3, (int)&v18);
  }
  ConsoleClientCallServer(&RequestMessage, (int)v7, 6, 100);
  if ( v7 )
    ConsoleFreeCaptureBuffer(v7);
  v9 = NtStatus < 0;
  *(_DWORD *)a7 = v19;
  if ( v9 )
  {
    v10 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v10);
    return 0;
  }
  return 1;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8DBD1) --------------------------------------------------------
BOOL __stdcall WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
{
  return WriteConsoleOutputString(
           (int)hConsoleOutput,
           (void *)lpCharacter,
           nLength,
           1,
           1,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfCharsWritten);
}

//----- (77E8DBF7) --------------------------------------------------------
BOOL __stdcall WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
{
  return WriteConsoleOutputString(
           (int)hConsoleOutput,
           (void *)lpCharacter,
           nLength,
           2,
           2,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfCharsWritten);
}

//----- (77E8DC1D) --------------------------------------------------------
BOOL __stdcall WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
{
  return WriteConsoleOutputString(
           (int)hConsoleOutput,
           (void *)lpAttribute,
           nLength,
           2,
           3,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfAttrsWritten);
}

//----- (77E8DC43) --------------------------------------------------------
BOOL __stdcall FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
{
  return FillConsoleOutput(
           (int)hConsoleOutput,
           cCharacter,
           nLength,
           1,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfCharsWritten);
}

//----- (77E8DC6D) --------------------------------------------------------
BOOL __stdcall FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
{
  return FillConsoleOutput(
           (int)hConsoleOutput,
           cCharacter,
           nLength,
           2,
           *(_DWORD *)&dwWriteCoord,
           (int)lpNumberOfCharsWritten);
}

//----- (77E8DC91) --------------------------------------------------------
HANDLE __stdcall CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
{
  LPVOID v5; // ebx@1
  DWORD v6; // edi@3
  PVOID v7; // esi@5
  BOOL v8; // eax@6
  ULONG v9; // ST0C_4@18
  struct _PORT_MESSAGE RequestMessage; // [sp+14h] [bp-BCh]@15
  NTSTATUS NtStatus; // [sp+34h] [bp-9Ch]@17
  DWORD v13; // [sp+3Ch] [bp-94h]@5
  int v14; // [sp+40h] [bp-90h]@8
  DWORD v15; // [sp+44h] [bp-8Ch]@8
  DWORD v16; // [sp+48h] [bp-88h]@8
  size_t Size; // [sp+4Ch] [bp-84h]@11
  int v18; // [sp+50h] [bp-80h]@13
  int v19; // [sp+60h] [bp-70h]@20
  int v20; // [sp+64h] [bp-6Ch]@20
  void *v21; // [sp+68h] [bp-68h]@21
  CPPEH_RECORD ms_exc; // [sp+B8h] [bp-18h]@11

  v5 = lpScreenBufferData;
  if ( dwDesiredAccess & 0x3FFFFFFF )
    goto LABEL_26;
  if ( dwShareMode & 0xFFFFFFFC )
    goto LABEL_26;
  v6 = dwFlags;
  if ( dwFlags != 1 && dwFlags != 2 )
    goto LABEL_26;
  v13 = dwDesiredAccess;
  v7 = 0;
  if ( lpSecurityAttributes )
    v8 = lpSecurityAttributes->bInheritHandle;
  else
    v8 = 0;
  v14 = v8;
  v15 = dwShareMode;
  v16 = dwFlags;
  if ( dwFlags != 2 )
  {
    v5 = 0;
    goto LABEL_15;
  }
  if ( v8 || !lpScreenBufferData )
  {
LABEL_26:
    RtlSetLastWin32Error(87);
    return (HANDLE)-1;
  }
  ms_exc.registration.TryLevel = 0;
  qmemcpy(&Size, lpScreenBufferData, 0x14u);
  v7 = ConsoleAllocateCaptureBuffer(1u, Size);
  if ( !v7 )
  {
    RtlSetLastWin32Error(8);
    ms_exc.registration.TryLevel = -2;
    return (HANDLE)-1;
  }
  ConsoleCaptureMessageBuffer((int)v7, *((void **)lpScreenBufferData + 1), Size, (int)&v18);
  ms_exc.registration.TryLevel = -2;
  v6 = 2;
LABEL_15:
  ConsoleClientCallServer(&RequestMessage, (int)v7, 38, 48);
  if ( v7 )
    ConsoleFreeCaptureBuffer(v7);
  if ( NtStatus < 0 )
  {
    v9 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v9);
    return (HANDLE)-1;
  }
  if ( v6 == 2 )
  {
    *((_DWORD *)v5 + 3) = v19;
    *((_DWORD *)v5 + 4) = v20;
  }
  return v21;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8DDF1) --------------------------------------------------------
signed int __stdcall InvalidateConsoleDIBits(int a1, int a2)
{
  int v2; // ecx@1
  signed int result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v7; // [sp+28h] [bp-7Ch]@1
  int v8; // [sp+2Ch] [bp-78h]@1
  int v9; // [sp+30h] [bp-74h]@1

  v7 = a1;
  v2 = *(_DWORD *)a2;
  v9 = *(_DWORD *)(a2 + 4);
  v8 = v2;
  ConsoleClientCallServer(&RequestMessage, 0, 39, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8DE62) --------------------------------------------------------
signed int __stdcall WriteConsoleOutputInternal(int a1, void *a2, unsigned int a3, int a4, int a5, char a6)
{
  __int16 v6; // cx@1
  __int16 v7; // cx@1
  __int16 v8; // dx@3
  __int16 v9; // ax@3
  __int16 v10; // ax@3
  int v11; // eax@7
  PVOID v12; // edi@8
  bool v13; // sf@17
  ULONG v14; // ST14_4@18
  int v16; // [sp+10h] [bp-B8h]@13
  unsigned int v17; // [sp+14h] [bp-B4h]@3
  int v18; // [sp+18h] [bp-B0h]@1
  ULONG Size; // [sp+20h] [bp-A8h]@3
  struct _PORT_MESSAGE RequestMessage; // [sp+24h] [bp-A4h]@13
  NTSTATUS NtStatus; // [sp+44h] [bp-84h]@17
  int v22; // [sp+4Ch] [bp-7Ch]@1
  char v23; // [sp+50h] [bp-78h]@12
  PVOID Address; // [sp+54h] [bp-74h]@9
  int v25; // [sp+58h] [bp-70h]@7
  int v26; // [sp+5Ch] [bp-6Ch]@7
  char v27; // [sp+60h] [bp-68h]@1
  char v28; // [sp+61h] [bp-67h]@9

  v22 = a1;
  v6 = *(_WORD *)(a5 + 4);
  v27 = a6;
  v7 = v6 - *(_WORD *)a5 + 1;
  LOWORD(v18) = v7;
  if ( v7 > (signed __int16)a3 - (signed __int16)a4 )
  {
    v7 = a3 - a4;
    LOWORD(v18) = a3 - a4;
  }
  v8 = *(_WORD *)(a5 + 2);
  v9 = *(_WORD *)(a5 + 6);
  v17 = (unsigned int)a4 >> 16;
  Size = a3 >> 16;
  v10 = v9 - v8 + 1;
  HIWORD(v18) = v10;
  if ( v10 > SHIWORD(a3) - SHIWORD(a4) )
  {
    v10 = Size - v17;
    HIWORD(v18) = Size - v17;
  }
  if ( v7 <= 0 || v10 <= 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v11 = v7 * v10;
  LOWORD(v25) = *(_WORD *)a5;
  LOWORD(v26) = v25 + v18 - 1;
  HIWORD(v25) = v8;
  HIWORD(v26) = v8 + HIWORD(v18) - 1;
  if ( (unsigned int)v11 <= 1 )
  {
    v28 = 0;
    v12 = 0;
    Address = &v23;
  }
  else
  {
    Size = 4 * v11;
    v12 = ConsoleAllocateCaptureBuffer(1u, 4 * v11);
    if ( v12 )
    {
      v28 = 0;
      ConsoleCaptureMessageBuffer((int)v12, 0, Size, (int)&Address);
    }
    else
    {
      v28 = 1;
      Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
      if ( !Address )
      {
        RtlSetLastWin32Error(8);
        return 0;
      }
    }
  }
  v16 = a4;
  LOWORD(v17) = a4 + v18 - 1;
  HIWORD(v17) = HIWORD(v18) + HIWORD(a4) - 1;
  Size = 0;
  CopyRectangle(a2, a3, (int)&v16, Address, v18, 0);
  ConsoleClientCallServer(&RequestMessage, (int)v12, 4, 24);
  if ( v12 )
  {
    ConsoleFreeCaptureBuffer(v12);
  }
  else if ( v28 )
  {
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
  }
  v13 = NtStatus < 0;
  *(_DWORD *)a5 = v25;
  *(_DWORD *)(a5 + 4) = v26;
  if ( !v13 )
    return 1;
  v14 = RtlNtStatusToDosError(NtStatus);
  RtlSetLastWin32Error(v14);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E09D) --------------------------------------------------------
BOOL __stdcall WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
{
  return WriteConsoleOutputInternal(
           (int)hConsoleOutput,
           (void *)lpBuffer,
           *(_DWORD *)&dwBufferSize,
           *(_DWORD *)&dwBufferCoord,
           (int)lpWriteRegion,
           1);
}

//----- (77E8E0C1) --------------------------------------------------------
BOOL __stdcall WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
{
  return WriteConsoleOutputInternal(
           (int)hConsoleOutput,
           (void *)lpBuffer,
           *(_DWORD *)&dwBufferSize,
           *(_DWORD *)&dwBufferCoord,
           (int)lpWriteRegion,
           0);
}

//----- (77E8E0E5) --------------------------------------------------------
bool __stdcall ReadConsoleOutputString(int a1, void *Dst, int a3, int a4, int a5, int a6, int a7)
{
  PVOID v8; // edi@4
  bool v9; // sf@8
  int v10; // eax@8
  ULONG v11; // eax@10
  size_t Size; // [sp+8h] [bp-A8h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+Ch] [bp-A4h]@8
  NTSTATUS NtStatus; // [sp+2Ch] [bp-84h]@8
  int v15; // [sp+34h] [bp-7Ch]@1
  int v16; // [sp+38h] [bp-78h]@1
  int v17; // [sp+3Ch] [bp-74h]@1
  char v18; // [sp+40h] [bp-70h]@7
  void *Src; // [sp+90h] [bp-20h]@6
  int v20; // [sp+94h] [bp-1Ch]@1

  v15 = a1;
  v20 = a3;
  v17 = a5;
  v16 = a6;
  if ( ULongLongToULong((unsigned int)a4 * (unsigned __int64)(unsigned int)a3, (ULONG *)&Size) < 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  if ( Size <= 0x50 )
  {
    Src = &v18;
    v8 = 0;
  }
  else
  {
    v8 = ConsoleAllocateCaptureBuffer(1u, Size);
    if ( !v8 )
    {
      RtlSetLastWin32Error(8);
      return 0;
    }
    ConsoleCaptureMessageBuffer((int)v8, 0, Size, (int)&Src);
  }
  ConsoleClientCallServer(&RequestMessage, (int)v8, 5, 100);
  v9 = NtStatus < 0;
  v10 = v20;
  *(_DWORD *)a7 = v20;
  if ( v9 )
  {
    v11 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v11);
  }
  else
  {
    memcpy(Dst, Src, a4 * v10);
  }
  if ( v8 )
    ConsoleFreeCaptureBuffer(v8);
  return NtStatus >= 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E1F3) --------------------------------------------------------
BOOL __stdcall ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = ReadConsoleOutputString(
                     (int)hConsoleOutput,
                     lpCharacter,
                     nLength,
                     1,
                     1,
                     *(_DWORD *)&dwReadCoord,
                     (int)lpNumberOfCharsRead);
  return result;
}

//----- (77E8E219) --------------------------------------------------------
BOOL __stdcall ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = ReadConsoleOutputString(
                     (int)hConsoleOutput,
                     lpCharacter,
                     nLength,
                     2,
                     2,
                     *(_DWORD *)&dwReadCoord,
                     (int)lpNumberOfCharsRead);
  return result;
}

//----- (77E8E23F) --------------------------------------------------------
BOOL __stdcall ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
{
  BOOL result; // eax@1

  LOBYTE(result) = ReadConsoleOutputString(
                     (int)hConsoleOutput,
                     lpAttribute,
                     nLength,
                     2,
                     3,
                     *(_DWORD *)&dwReadCoord,
                     (int)lpNumberOfAttrsRead);
  return result;
}

//----- (77E8E265) --------------------------------------------------------
NTSTATUS __stdcall SetLastConsoleEventActiveInternal()
{
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1

  return ConsoleClientCallServer(&RequestMessage, 0, 64, 0);
}

//----- (77E8E29D) --------------------------------------------------------
NTSTATUS __stdcall SetLastConsoleEventActive()
{
  LastConsoleEventActive = 1;
  return SetLastConsoleEventActiveInternal();
}
// 77EA6FEC: using guessed type int LastConsoleEventActive;

//----- (77E8E2AE) --------------------------------------------------------
int __stdcall GetNumberOfConsoleFonts()
{
  int result; // eax@2
  ULONG v1; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v4; // [sp+28h] [bp-7Ch]@2

  ConsoleClientCallServer(&RequestMessage, 0, 9, 4);
  if ( NtStatus < 0 )
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  else
  {
    result = v4;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E309) --------------------------------------------------------
BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
{
  BOOL result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  HANDLE v6; // [sp+2Ch] [bp-7Ch]@1
  DWORD v7; // [sp+30h] [bp-78h]@2

  v6 = hConsoleInput;
  ConsoleClientCallServer(&RequestMessage, 0, 10, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    *lpNumberOfEvents = v7;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E376) --------------------------------------------------------
COORD __stdcall GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
{
  ULONG v1; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v5; // [sp+28h] [bp-7Ch]@1
  COORD v6; // [sp+2Ch] [bp-78h]@2

  v5 = hConsoleOutput;
  ConsoleClientCallServer(&RequestMessage, 0, 20, 8);
  if ( NtStatus < 0 )
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    v6 = 0;
  }
  return v6;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E3DF) --------------------------------------------------------
BOOL __stdcall SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
{
  ULONG v3; // ST14_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@3
  HANDLE v6; // [sp+28h] [bp-7Ch]@3
  COORD v7; // [sp+2Ch] [bp-78h]@3
  COORD v8; // [sp+30h] [bp-74h]@3
  WORD v9; // [sp+38h] [bp-6Ch]@3
  __int16 v10; // [sp+3Ah] [bp-6Ah]@3
  __int16 v11; // [sp+3Ch] [bp-68h]@3
  COORD v12; // [sp+3Eh] [bp-66h]@3
  WORD v13; // [sp+42h] [bp-62h]@3
  char v14; // [sp+48h] [bp-5Ch]@3

  if ( lpConsoleScreenBufferInfoEx->cbSize == 96 )
  {
    v6 = hConsoleOutput;
    v7 = lpConsoleScreenBufferInfoEx->dwSize;
    v8 = lpConsoleScreenBufferInfoEx->dwCursorPosition;
    v9 = lpConsoleScreenBufferInfoEx->wAttributes;
    v13 = lpConsoleScreenBufferInfoEx->wPopupAttributes;
    v10 = lpConsoleScreenBufferInfoEx->srWindow.Right - lpConsoleScreenBufferInfoEx->srWindow.Left;
    v11 = lpConsoleScreenBufferInfoEx->srWindow.Bottom - lpConsoleScreenBufferInfoEx->srWindow.Top;
    v12 = lpConsoleScreenBufferInfoEx->dwMaximumWindowSize;
    qmemcpy(&v14, lpConsoleScreenBufferInfoEx->ColorTable, 0x40u);
    ConsoleClientCallServer(&RequestMessage, 0, 82, 96);
    if ( NtStatus >= 0 )
      return 1;
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E497) --------------------------------------------------------
BOOL __stdcall GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
{
  BOOL result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  HANDLE v6; // [sp+2Ch] [bp-7Ch]@1
  DWORD v7; // [sp+30h] [bp-78h]@2
  unsigned __int8 v8; // [sp+34h] [bp-74h]@2

  v6 = hConsoleOutput;
  ConsoleClientCallServer(&RequestMessage, 0, 12, 12);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    lpConsoleCursorInfo->dwSize = v7;
    lpConsoleCursorInfo->bVisible = v8;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E50B) --------------------------------------------------------
BOOL __stdcall GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
{
  char *v1; // edi@2
  BOOL result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  DWORD v6; // [sp+2Ch] [bp-7Ch]@2
  COORD v7; // [sp+30h] [bp-78h]@2
  int v8; // [sp+34h] [bp-74h]@2
  int v9; // [sp+38h] [bp-70h]@2

  ConsoleClientCallServer(&RequestMessage, 0, 77, 16);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    lpConsoleSelectionInfo->dwFlags = v6;
    lpConsoleSelectionInfo->dwSelectionAnchor = v7;
    v1 = (char *)&lpConsoleSelectionInfo->srSelection;
    *(_DWORD *)v1 = v8;
    *((_DWORD *)v1 + 1) = v9;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E576) --------------------------------------------------------
BOOL __stdcall GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
{
  BOOL result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  DWORD v5; // [sp+2Ch] [bp-7Ch]@2

  ConsoleClientCallServer(&RequestMessage, 0, 13, 4);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    *lpNumberOfMouseButtons = v5;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E5DD) --------------------------------------------------------
COORD __stdcall GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
{
  ULONG v2; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v6; // [sp+28h] [bp-7Ch]@1
  DWORD v7; // [sp+2Ch] [bp-78h]@1
  COORD v8; // [sp+30h] [bp-74h]@2

  v6 = hConsoleOutput;
  v7 = nFont;
  ConsoleClientCallServer(&RequestMessage, 0, 15, 12);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    v8 = 0;
  }
  return v8;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E64C) --------------------------------------------------------
BOOL __stdcall GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
{
  ULONG v3; // ST0C_4@6
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@4
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@4
  DWORD v6; // [sp+28h] [bp-7Ch]@4
  DWORD v7; // [sp+2Ch] [bp-78h]@4

  if ( dwCtrlEvent && dwCtrlEvent != 1 )
  {
    RtlSetLastWin32Error(87);
  }
  else
  {
    v6 = dwCtrlEvent;
    v7 = dwProcessGroupId;
    ConsoleClientCallServer(&RequestMessage, 0, 65, 8);
    if ( NtStatus >= 0 )
      return 1;
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E6C2) --------------------------------------------------------
BOOL __stdcall SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
{
  BOOL result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v5; // [sp+28h] [bp-7Ch]@1

  v5 = hConsoleOutput;
  ConsoleClientCallServer(&RequestMessage, 0, 18, 4);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E725) --------------------------------------------------------
BOOL __stdcall FlushConsoleInputBuffer(HANDLE hConsoleInput)
{
  BOOL result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v5; // [sp+28h] [bp-7Ch]@1

  v5 = hConsoleInput;
  ConsoleClientCallServer(&RequestMessage, 0, 19, 4);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E788) --------------------------------------------------------
BOOL __stdcall SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
{
  BOOL result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v6; // [sp+28h] [bp-7Ch]@1
  COORD v7; // [sp+2Ch] [bp-78h]@1

  v6 = hConsoleOutput;
  v7 = dwSize;
  ConsoleClientCallServer(&RequestMessage, 0, 21, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E7F1) --------------------------------------------------------
BOOL __stdcall SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
{
  DWORD v2; // ecx@1
  BOOL result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v7; // [sp+28h] [bp-7Ch]@1
  DWORD v8; // [sp+2Ch] [bp-78h]@1
  char v9; // [sp+30h] [bp-74h]@1

  v7 = hConsoleOutput;
  v2 = lpConsoleCursorInfo->dwSize;
  v9 = LOBYTE(lpConsoleCursorInfo->bVisible);
  v8 = v2;
  ConsoleClientCallServer(&RequestMessage, 0, 23, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E862) --------------------------------------------------------
BOOL __stdcall SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
{
  int v3; // ecx@1
  BOOL result; // eax@2
  ULONG v5; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  HANDLE v8; // [sp+28h] [bp-7Ch]@1
  int v9; // [sp+2Ch] [bp-78h]@1
  int v10; // [sp+30h] [bp-74h]@1
  int v11; // [sp+34h] [bp-70h]@1

  v8 = hConsoleOutput;
  v9 = bAbsolute;
  v3 = *(_DWORD *)&lpConsoleWindow->Left;
  v11 = *(_DWORD *)&lpConsoleWindow->Right;
  v10 = v3;
  ConsoleClientCallServer(&RequestMessage, 0, 24, 16);
  if ( NtStatus < 0 )
  {
    v5 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v5);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E8D9) --------------------------------------------------------
BOOL __stdcall ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
{
  return ScrollConsoleScreenBufferInternal(
           (int)hConsoleOutput,
           (int)lpScrollRectangle,
           (int)lpClipRectangle,
           *(_DWORD *)&dwDestinationOrigin,
           (int)lpFill,
           0);
}

//----- (77E8E8FD) --------------------------------------------------------
signed int __stdcall SetConsoleFont(int a1, int a2)
{
  signed int result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v6; // [sp+28h] [bp-7Ch]@1
  int v7; // [sp+2Ch] [bp-78h]@1

  v6 = a1;
  v7 = a2;
  ConsoleClientCallServer(&RequestMessage, 0, 27, 8);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E966) --------------------------------------------------------
signed int __stdcall SetConsoleIcon(int a1)
{
  signed int result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@1

  v5 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 28, 4);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8E9C9) --------------------------------------------------------
BOOL __stdcall SetConsoleCP(UINT wCodePageID)
{
  BOOL result; // eax@2
  ULONG v2; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  UINT v5; // [sp+28h] [bp-7Ch]@1
  int v6; // [sp+2Ch] [bp-78h]@1

  v6 = 0;
  v5 = wCodePageID;
  ConsoleClientCallServer(&RequestMessage, 0, 61, 8);
  if ( NtStatus < 0 )
  {
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EA30) --------------------------------------------------------
int __stdcall SetConsoleOutputCPInternal(int a1)
{
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  int v3; // [sp+20h] [bp-84h]@1
  int v4; // [sp+28h] [bp-7Ch]@1
  int v5; // [sp+2Ch] [bp-78h]@1

  v4 = a1;
  v5 = 1;
  ConsoleClientCallServer(&RequestMessage, 0, 61, 8);
  return v3;
}

//----- (77E8EA7D) --------------------------------------------------------
BOOL __stdcall SetConsoleOutputCP(UINT wCodePageID)
{
  int v1; // eax@1
  int v2; // ecx@1
  BOOL result; // eax@2
  ULONG v4; // eax@3

  v1 = SetConsoleOutputCPInternal(wCodePageID);
  if ( v1 < 0 )
  {
    v4 = RtlNtStatusToDosError(v1);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    SetTEBLangID(v2);
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EAB1) --------------------------------------------------------
DWORD __stdcall GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
{
  PVOID v2; // ebx@3
  ULONG v4; // ST0C_4@9
  struct _PORT_MESSAGE RequestMessage; // [sp+10h] [bp-A4h]@5
  NTSTATUS NtStatus; // [sp+30h] [bp-84h]@5
  DWORD v7; // [sp+38h] [bp-7Ch]@3
  void *Src; // [sp+3Ch] [bp-78h]@5

  if ( !dwProcessCount || !lpdwProcessList )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v7 = dwProcessCount;
  v2 = ConsoleAllocateCaptureBuffer(1u, 4 * dwProcessCount);
  if ( !v2 )
  {
    RtlSetLastWin32Error(8);
    return 0;
  }
  ConsoleCaptureMessageBuffer((int)v2, 0, 4 * dwProcessCount, (int)&Src);
  ConsoleClientCallServer(&RequestMessage, (int)v2, 78, 8);
  if ( NtStatus < 0 )
  {
    ConsoleFreeCaptureBuffer(v2);
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    return 0;
  }
  if ( dwProcessCount >= v7 )
    memcpy(lpdwProcessList, Src, 4 * v7);
  ConsoleFreeCaptureBuffer(v2);
  return v7;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EB7E) --------------------------------------------------------
BOOL __stdcall GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
{
  ULONG v2; // ST0C_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@3
  UINT v5; // [sp+2Ch] [bp-7Ch]@4
  UINT v6; // [sp+30h] [bp-78h]@4
  DWORD v7; // [sp+34h] [bp-74h]@4

  if ( lpConsoleHistoryInfo->cbSize == 16 )
  {
    ConsoleClientCallServer(&RequestMessage, 0, 79, 12);
    if ( NtStatus >= 0 )
    {
      lpConsoleHistoryInfo->HistoryBufferSize = v5;
      lpConsoleHistoryInfo->NumberOfHistoryBuffers = v6;
      lpConsoleHistoryInfo->dwFlags = v7;
      return 1;
    }
    v2 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v2);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EBFB) --------------------------------------------------------
BOOL __stdcall SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
{
  UINT v1; // ecx@3
  ULONG v3; // ST0C_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@3
  UINT v6; // [sp+28h] [bp-7Ch]@3
  UINT v7; // [sp+2Ch] [bp-78h]@3
  DWORD v8; // [sp+30h] [bp-74h]@3

  if ( lpConsoleHistoryInfo->cbSize == 16 )
  {
    v6 = lpConsoleHistoryInfo->HistoryBufferSize;
    v1 = lpConsoleHistoryInfo->NumberOfHistoryBuffers;
    v8 = lpConsoleHistoryInfo->dwFlags;
    v7 = v1;
    ConsoleClientCallServer(&RequestMessage, 0, 80, 12);
    if ( NtStatus >= 0 )
      return 1;
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EC76) --------------------------------------------------------
int __stdcall GetConsoleFontInfo(int a1, char a2, int a3, void *Dst)
{
  int result; // eax@2
  PVOID v5; // edi@3
  ULONG v6; // eax@7
  ULONG pulResult; // [sp+8h] [bp-A8h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+Ch] [bp-A4h]@5
  NTSTATUS NtStatus; // [sp+2Ch] [bp-84h]@5
  int v10; // [sp+34h] [bp-7Ch]@1
  char v11; // [sp+38h] [bp-78h]@1
  void *Src; // [sp+3Ch] [bp-74h]@5
  int v13; // [sp+40h] [bp-70h]@1

  v10 = a1;
  v11 = a2;
  v13 = a3;
  if ( ULongLongToULong(8i64 * (unsigned int)a3, &pulResult) >= 0 )
  {
    v5 = ConsoleAllocateCaptureBuffer(1u, pulResult);
    if ( v5 )
    {
      ConsoleCaptureMessageBuffer((int)v5, 0, 8 * a3, (int)&Src);
      ConsoleClientCallServer(&RequestMessage, (int)v5, 14, 16);
      if ( NtStatus < 0 )
      {
        v13 = 0;
        v6 = RtlNtStatusToDosError(NtStatus);
        RtlSetLastWin32Error(v6);
      }
      else
      {
        memcpy(Dst, Src, 8 * v13);
      }
      ConsoleFreeCaptureBuffer(v5);
      result = v13;
    }
    else
    {
      RtlSetLastWin32Error(8);
      result = 0;
    }
  }
  else
  {
    RtlSetLastWin32Error(87);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8ED61) --------------------------------------------------------
BOOL __stdcall GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
{
  ULONG v4; // ST0C_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@3
  HANDLE v7; // [sp+2Ch] [bp-7Ch]@3
  char v8; // [sp+30h] [bp-78h]@3
  DWORD v9; // [sp+34h] [bp-74h]@4
  COORD v10; // [sp+38h] [bp-70h]@4
  UINT v11; // [sp+3Ch] [bp-6Ch]@4
  UINT v12; // [sp+40h] [bp-68h]@4
  wchar_t pszSrc; // [sp+44h] [bp-64h]@4

  if ( lpConsoleCurrentFontEx->cbSize == 84 )
  {
    v8 = bMaximumWindow;
    v7 = hConsoleOutput;
    ConsoleClientCallServer(&RequestMessage, 0, 16, 88);
    if ( NtStatus >= 0 )
    {
      lpConsoleCurrentFontEx->dwFontSize = v10;
      lpConsoleCurrentFontEx->nFont = v9;
      lpConsoleCurrentFontEx->FontFamily = v11;
      lpConsoleCurrentFontEx->FontWeight = v12;
      RtlStringCchCopyW(lpConsoleCurrentFontEx->FaceName, 0x20u, &pszSrc);
      return 1;
    }
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EDFF) --------------------------------------------------------
BOOL __stdcall SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
{
  ULONG v4; // ST0C_4@5
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@3
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@3
  HANDLE v7; // [sp+28h] [bp-7Ch]@3
  char v8; // [sp+2Ch] [bp-78h]@3
  DWORD v9; // [sp+30h] [bp-74h]@3
  COORD v10; // [sp+34h] [bp-70h]@3
  UINT v11; // [sp+38h] [bp-6Ch]@3
  UINT v12; // [sp+3Ch] [bp-68h]@3
  wchar_t pszDest; // [sp+40h] [bp-64h]@3

  if ( lpConsoleCurrentFontEx->cbSize == 84 )
  {
    v7 = hConsoleOutput;
    v8 = bMaximumWindow;
    v10 = lpConsoleCurrentFontEx->dwFontSize;
    v9 = lpConsoleCurrentFontEx->nFont;
    v11 = lpConsoleCurrentFontEx->FontFamily;
    v12 = lpConsoleCurrentFontEx->FontWeight;
    RtlStringCchCopyW(&pszDest, 0x20u, lpConsoleCurrentFontEx->FaceName);
    ConsoleClientCallServer(&RequestMessage, 0, 81, 88);
    if ( NtStatus >= 0 )
      return 1;
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
  }
  else
  {
    RtlSetLastWin32Error(87);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EE9B) --------------------------------------------------------
int __stdcall GetConsoleKeyboardLayoutNameWorker(char *pszDest, size_t cchDest, int a3)
{
  int result; // eax@5
  ULONG v4; // eax@6
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@1
  char pszSrc; // [sp+30h] [bp-7Ch]@3
  int v8; // [sp+44h] [bp-68h]@1

  v8 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 66, 24);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    if ( a3 )
      RtlStringCchCopyA(pszDest, cchDest, &pszSrc);
    else
      RtlStringCbCopyW((wchar_t *)pszDest, cchDest, (const wchar_t *)&pszSrc);
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8EF1D) --------------------------------------------------------
int __stdcall GetConsoleKeyboardLayoutNameA(char *pszDest)
{
  return GetConsoleKeyboardLayoutNameWorker(pszDest, 9u, 1);
}

//----- (77E8EF37) --------------------------------------------------------
int __stdcall GetConsoleKeyboardLayoutNameW(char *pszDest)
{
  return GetConsoleKeyboardLayoutNameWorker(pszDest, 0x12u, 0);
}

//----- (77E8EF51) --------------------------------------------------------
BOOL __stdcall GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
{
  BOOL result; // eax@2
  struct _CONSOLE_FONT_INFOEX ConsoleCurrentFontEx; // [sp+4h] [bp-58h]@1

  ConsoleCurrentFontEx.cbSize = 84;
  if ( GetCurrentConsoleFontEx(hConsoleOutput, bMaximumWindow, &ConsoleCurrentFontEx) )
  {
    lpConsoleCurrentFont->nFont = ConsoleCurrentFontEx.nFont;
    lpConsoleCurrentFont->dwFontSize = ConsoleCurrentFontEx.dwFontSize;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E8EFAA) --------------------------------------------------------
signed int __stdcall GetConsoleNlsMode(int a1, int a2)
{
  signed int result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  int v6; // [sp+2Ch] [bp-7Ch]@1
  int v7; // [sp+30h] [bp-78h]@1
  int v8; // [sp+34h] [bp-74h]@2

  v7 = 0;
  v6 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 74, 12);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = v8;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F01B) --------------------------------------------------------
signed int __stdcall SetConsoleNlsMode(int a1, int a2)
{
  signed int result; // eax@2
  ULONG v3; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v6; // [sp+28h] [bp-7Ch]@1
  int v7; // [sp+30h] [bp-74h]@1

  v6 = a1;
  v7 = a2;
  ConsoleClientCallServer(&RequestMessage, 0, 75, 12);
  if ( NtStatus < 0 )
  {
    v3 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F084) --------------------------------------------------------
signed int __stdcall GetConsoleCharType(int a1, int a2, int a3)
{
  signed int result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+4h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+24h] [bp-84h]@1
  int v7; // [sp+2Ch] [bp-7Ch]@1
  int v8; // [sp+30h] [bp-78h]@1
  int v9; // [sp+34h] [bp-74h]@2

  v7 = a1;
  v8 = a2;
  ConsoleClientCallServer(&RequestMessage, 0, 68, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = v9;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F0F7) --------------------------------------------------------
signed int __stdcall SetConsoleCursorMode(int a1, int a2, int a3)
{
  signed int result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v7; // [sp+28h] [bp-7Ch]@1
  int v8; // [sp+2Ch] [bp-78h]@1
  int v9; // [sp+30h] [bp-74h]@1

  v7 = a1;
  v8 = a2;
  v9 = a3;
  ConsoleClientCallServer(&RequestMessage, 0, 70, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F166) --------------------------------------------------------
signed int __stdcall GetConsoleCursorMode(int a1, int a2, int a3)
{
  signed int result; // eax@2
  ULONG v4; // eax@3
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@1
  int v7; // [sp+30h] [bp-7Ch]@1
  int v8; // [sp+34h] [bp-78h]@2
  int v9; // [sp+38h] [bp-74h]@2

  v7 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 71, 12);
  if ( NtStatus < 0 )
  {
    v4 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v4);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = v8;
    *(_DWORD *)a3 = v9;
    result = 1;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F1DD) --------------------------------------------------------
signed int __stdcall RegisterConsoleOS2(int a1)
{
  ULONG v1; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@1

  v5 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 72, 4);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F240) --------------------------------------------------------
signed int __stdcall SetConsoleOS2OemFormat(int a1)
{
  ULONG v1; // eax@2
  signed int result; // eax@2
  struct _PORT_MESSAGE RequestMessage; // [sp+0h] [bp-A4h]@1
  NTSTATUS NtStatus; // [sp+20h] [bp-84h]@1
  int v5; // [sp+28h] [bp-7Ch]@1

  v5 = a1;
  ConsoleClientCallServer(&RequestMessage, 0, 73, 4);
  if ( NtStatus >= 0 )
  {
    result = 1;
  }
  else
  {
    v1 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v1);
    result = 0;
  }
  return result;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F2A3) --------------------------------------------------------
int __stdcall SetConsoleLocalEUDC(int a1, __int16 a2, int a3, void *Src)
{
  PVOID v5; // esi@3
  ULONG v6; // ST0C_4@7
  size_t Size; // [sp+4h] [bp-A8h]@1
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@5
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@5
  int v10; // [sp+30h] [bp-7Ch]@1
  __int16 v11; // [sp+34h] [bp-78h]@1
  int v12; // [sp+36h] [bp-76h]@1
  int v13; // [sp+3Ch] [bp-70h]@5

  v10 = a1;
  v11 = a2;
  v12 = a3;
  if ( ULongLongToULong((unsigned int)SHIWORD(a3) * (unsigned __int64)(((signed __int16)a3 + 7) / 8), (ULONG *)&Size) < 0 )
  {
    RtlSetLastWin32Error(87);
    return 0;
  }
  v5 = ConsoleAllocateCaptureBuffer(1u, Size);
  if ( v5 )
  {
    ConsoleCaptureMessageBuffer((int)v5, Src, Size, (int)&v13);
    ConsoleClientCallServer(&RequestMessage, (int)v5, 69, 16);
    ConsoleFreeCaptureBuffer(v5);
    if ( NtStatus >= 0 )
      return 1;
    v6 = RtlNtStatusToDosError(NtStatus);
    RtlSetLastWin32Error(v6);
  }
  else
  {
    RtlSetLastWin32Error(8);
  }
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F37D) --------------------------------------------------------
signed int __stdcall VDMConsoleOperation(unsigned int a1, int a2)
{
  int v3; // edi@17
  ULONG v4; // eax@18
  struct _PORT_MESSAGE RequestMessage; // [sp+8h] [bp-A4h]@8
  NTSTATUS NtStatus; // [sp+28h] [bp-84h]@8
  unsigned int v7; // [sp+30h] [bp-7Ch]@1
  int v8; // [sp+34h] [bp-78h]@4
  int v9; // [sp+38h] [bp-74h]@7
  int v10; // [sp+3Ch] [bp-70h]@7
  int v11; // [sp+40h] [bp-6Ch]@17
  int v12; // [sp+44h] [bp-68h]@17
  int v13; // [sp+48h] [bp-64h]@17
  int v14; // [sp+4Ch] [bp-60h]@17

  v7 = a1;
  if ( a1 == 4 || a1 == 5 )
  {
    v9 = *(_DWORD *)a2;
    v10 = *(_DWORD *)(a2 + 4);
  }
  else if ( a1 == 7 || a1 == 8 )
  {
    v8 = a2 != 0;
  }
  ConsoleClientCallServer(&RequestMessage, 0, 40, 32);
  if ( NtStatus >= 0 )
  {
    if ( a1 == 2 )
      goto LABEL_21;
    if ( a1 == 3 )
    {
      *(_DWORD *)a2 = v11;
      *(_DWORD *)(a2 + 4) = v12;
      v3 = a2 + 8;
      *(_DWORD *)v3 = v13;
      *(_DWORD *)(v3 + 4) = v14;
      return 1;
    }
    if ( a1 > 3 )
    {
      if ( a1 <= 5 )
      {
        *(_DWORD *)a2 = v9;
        *(_DWORD *)(a2 + 4) = v10;
        return 1;
      }
      if ( a1 == 6 )
LABEL_21:
        *(_DWORD *)a2 = v8;
    }
    return 1;
  }
  v4 = RtlNtStatusToDosError(NtStatus);
  RtlSetLastWin32Error(v4);
  return 0;
}
// 77DE1610: using guessed type int __stdcall RtlSetLastWin32Error(_DWORD);

//----- (77E8F445) --------------------------------------------------------
NTSTATUS __stdcall ConsoleClientCleanup(int a1)
{
  int v2; // [sp+4h] [bp-228h]@2
  int ProcessInformation; // [sp+8h] [bp-224h]@1
  PVOID v4; // [sp+Ch] [bp-220h]@2
  char v5; // [sp+14h] [bp-218h]@2
  char v6; // [sp+15h] [bp-217h]@2
  char v7; // [sp+16h] [bp-216h]@2
  char v8; // [sp+17h] [bp-215h]@2

  ProcessInformation = 0;
  if ( a1 )
  {
    v7 = 0;
    v6 = 0;
    v5 = 1;
    v8 = 1;
    v4 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->Reserved2[0];
    v2 = 540;
    CsrClientConnectToServer(0, 2, &v4, &v2, 0);
  }
  if ( ConsolePortHeap )
  {
    RtlDestroyHeap(ConsolePortHeap);
    ConsolePortHeap = 0;
  }
  if ( ConsoleLpcHandle )
  {
    NtClose(ConsoleLpcHandle);
    ConsoleLpcHandle = 0;
  }
  return NtSetInformationProcess((HANDLE)0xFFFFFFFF, ProcessConsoleHostProcess, &ProcessInformation, 4u);
}
// 77DE1670: using guessed type int __stdcall CsrClientConnectToServer(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E8F50C) --------------------------------------------------------
HLOCAL __stdcall InitGlobalBuffers(int a1, SIZE_T dwBytes, int a3)
{
  HLOCAL v3; // esi@1
  HLOCAL result; // eax@2
  HGLOBAL v5; // eax@5
  int v6; // eax@6
  int v7; // ecx@8
  HGLOBAL v8; // eax@12
  HGLOBAL v9; // eax@13

  v3 = LocalAlloc(0x40u, 0x50u);
  if ( !v3 )
    goto LABEL_21;
  if ( !dwBytes )
    dwBytes = 4224;
  v5 = GlobalAlloc(0x40u, dwBytes);
  *(_DWORD *)v3 = v5;
  if ( v5 )
  {
    v6 = a3;
    if ( !a3 )
      v6 = 0x8000;
    v7 = a1;
    if ( !a1 )
      v7 = 0x8000;
    *((_DWORD *)v3 + 11) = v6;
    *((_DWORD *)v3 + 12) = v7;
    if ( v6 )
    {
      while ( *((_DWORD *)v3 + 12) )
      {
        v8 = GlobalAlloc(0x40u, *((_DWORD *)v3 + 11) + 1);
        *((_DWORD *)v3 + 1) = v8;
        if ( v8 )
        {
          v9 = GlobalAlloc(0x40u, *((_DWORD *)v3 + 12));
          *((_DWORD *)v3 + 4) = v9;
          if ( v9 )
            return v3;
          GlobalFree(*((HGLOBAL *)v3 + 1));
        }
        *((_DWORD *)v3 + 11) -= 1024;
        *((_DWORD *)v3 + 12) -= 1024;
        if ( !*((_DWORD *)v3 + 11) )
          break;
      }
    }
    GlobalFree(*(HGLOBAL *)v3);
    result = 0;
  }
  else
  {
LABEL_21:
    result = 0;
  }
  return result;
}

//----- (77E8F5C2) --------------------------------------------------------
HLOCAL __stdcall InitGlobalBuffersEx()
{
  return InitGlobalBuffers(0x8000, 0x1080u, 0x8000);
}

//----- (77E8F5D9) --------------------------------------------------------
HLOCAL __stdcall FreeGlobalBuffers(HLOCAL hMem)
{
  HLOCAL result; // eax@8

  if ( hMem )
  {
    if ( *(_DWORD *)hMem )
    {
      GlobalFree(*(HGLOBAL *)hMem);
      *(_DWORD *)hMem = 0;
    }
    if ( *((_DWORD *)hMem + 1) )
    {
      GlobalFree(*((HGLOBAL *)hMem + 1));
      *((_DWORD *)hMem + 1) = 0;
    }
    if ( *((_DWORD *)hMem + 4) )
    {
      GlobalFree(*((HGLOBAL *)hMem + 4));
      *((_DWORD *)hMem + 4) = 0;
    }
    result = LocalFree(hMem);
  }
  return result;
}

//----- (77E8F627) --------------------------------------------------------
int __stdcall lz_CopyFile(HFILE hFile, HFILE a2, int a3)
{
  int result; // eax@2
  UINT v4; // ecx@6
  void *v5; // edx@6
  int v6; // eax@6
  int v7; // edi@6
  int v8; // eax@6
  UINT v9; // eax@8
  UINT i; // eax@6
  UINT v11; // edi@11

  if ( _llseek(hFile, 0, 0) )
  {
    result = -1;
  }
  else if ( a2 != -2 && _llseek(a2, 0, 0) )
  {
    result = -2;
  }
  else
  {
    v4 = *(_DWORD *)(a3 + 44);
    v5 = *(void **)(a3 + 4);
    v6 = (int)((char *)v5 + v4 + 1);
    v7 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)(a3 + 8) = v6;
    *(_DWORD *)(a3 + 12) = v6;
    v8 = *(_DWORD *)(a3 + 16);
    *(_DWORD *)(a3 + 28) = 0;
    *(_DWORD *)(a3 + 20) = v8 + v7;
    *(_DWORD *)(a3 + 24) = v8;
    *(_DWORD *)(a3 + 40) = 0;
    for ( i = _lread(hFile, v5, v4); ; i = _lread(hFile, *(LPVOID *)(a3 + 4), *(_DWORD *)(a3 + 44)) )
    {
      v11 = i;
      if ( i > 0 )
      {
        if ( i == -1 )
          return -1;
        v9 = _lwrite(a2, *(LPCCH *)(a3 + 4), i);
        if ( v9 != v11 )
          return 2 * (v9 != -1) - 4;
        *(_DWORD *)(a3 + 40) += v9;
        if ( v11 == *(_DWORD *)(a3 + 44) )
          continue;
      }
      break;
    }
    if ( v11 == -1 )
      return -1;
    result = 1;
  }
  return result;
}

//----- (77E8F6E5) --------------------------------------------------------
int __stdcall ExpandOrCopyFile(HFILE hFile, HFILE a2, int a3)
{
  int result; // eax@3
  BOOL v4; // eax@4
  int v5; // edi@4
  int v7; // [sp+Ch] [bp-18h]@1
  char v8; // [sp+14h] [bp-10h]@5
  int v9; // [sp+18h] [bp-Ch]@7

  if ( GetHdr((int)&v7, hFile, a3 + 36) != 1 && *(_DWORD *)(a3 + 36) >= 14 )
    return -1;
  v4 = IsCompressed((int)&v7);
  v5 = v4 == 1;
  if ( v4 == 1 )
  {
    if ( v8 != 65 )
      return -8;
    result = LZDecode(hFile, a2, v9 - 1, 1, 1, a3);
  }
  else
  {
    result = lz_CopyFile(hFile, a2, a3);
  }
  if ( result == 1 )
  {
    result = WriteOutBuf(70, a2, a3);
    if ( result == 1 )
    {
      result = CopyDateTimeStamp((HANDLE)hFile, (HANDLE)a2);
      if ( result == 1 )
      {
        if ( v5 && *(_DWORD *)(a3 + 40) != v9 )
          return -3;
        result = 1;
      }
    }
  }
  return result;
}

//----- (77E8F7A7) --------------------------------------------------------
int __stdcall GetHdr(int a1, HFILE hFile, int a3)
{
  LONG v3; // eax@1
  UINT v4; // eax@3
  int v5; // ecx@3
  int result; // eax@4
  char v7; // al@5
  int v8; // edx@5
  signed int v9; // eax@5
  int v10; // esi@6
  char Buffer; // [sp+10h] [bp-14h]@3
  int v12; // [sp+14h] [bp-10h]@5
  char v13; // [sp+18h] [bp-Ch]@5
  char v14; // [sp+19h] [bp-Bh]@5
  char v15[6]; // [sp+1Ah] [bp-Ah]@6

  v3 = _llseek(hFile, 0, 2);
  *(_DWORD *)a3 = v3;
  if ( v3 < 0 || _llseek(hFile, 0, 0) )
  {
    result = -1;
  }
  else
  {
    v4 = _lread(hFile, &Buffer, 0xEu);
    v5 = 0;
    if ( v4 == 14 )
    {
      v7 = v13;
      *(_DWORD *)a1 = *(_DWORD *)&Buffer;
      *(_DWORD *)(a1 + 4) = v12;
      *(_BYTE *)(a1 + 8) = v7;
      *(_BYTE *)(a1 + 9) = v14;
      v8 = 0;
      *(_DWORD *)(a1 + 12) = 0;
      v9 = 0;
      do
      {
        v10 = (unsigned __int8)v15[v9] << v5;
        v5 += 8;
        v8 |= v10;
        ++v9;
      }
      while ( v9 < 4 );
      *(_DWORD *)(a1 + 12) = v8;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)a3;
      result = 1;
    }
    else
    {
      LOBYTE(v5) = v4 == -1;
      result = 2 * v5 - 3;
    }
  }
  return result;
}
// 77E8F7A7: using guessed type char var_A[6];

//----- (77E8F85E) --------------------------------------------------------
BOOL __stdcall IsCompressed(int a1)
{
  int String1; // [sp+8h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-Ch]@1
  char v4; // [sp+10h] [bp-8h]@1

  String1 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = 0;
  return lstrcmpA((LPCSTR)&String1, "SZDD'3") == 0;
}

//----- (77E8F8B2) --------------------------------------------------------
int __stdcall LZDecode(HFILE hFile, HFILE a2, int a3, char a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@3
  int v8; // eax@7
  int v9; // ecx@7
  int v10; // eax@7
  int v11; // edx@7
  int v12; // ecx@7
  int v13; // eax@9
  char *v14; // eax@10
  char *v15; // eax@16
  unsigned int v16; // eax@20
  unsigned int v17; // eax@24
  int v18; // edi@27
  int i; // ebx@27
  char v20; // cl@28
  unsigned int v21; // eax@28
  int v22; // eax@38
  int v24; // [sp+Ch] [bp-4h]@27

  v6 = a6;
  *(_DWORD *)(a6 + 32) = 16;
  if ( a4 == 1 )
  {
    if ( _llseek(hFile, 14, 0) != 14 )
      return -1;
    if ( a2 != -2 && _llseek(a2, 0, 0) )
      return -2;
    v8 = *(_DWORD *)(v6 + 4) + *(_DWORD *)(v6 + 44) + 1;
    v9 = *(_DWORD *)(v6 + 48);
    *(_DWORD *)(v6 + 8) = v8;
    *(_DWORD *)(v6 + 12) = v8;
    v10 = *(_DWORD *)(v6 + 16);
    *(_DWORD *)(v6 + 24) = v10;
    v11 = 4096 - *(_DWORD *)(v6 + 32);
    *(_DWORD *)(v6 + 20) = v10 + v9;
    v12 = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 40) = 0;
    if ( v11 > 0 )
    {
      do
        *(_BYTE *)(v12++ + *(_DWORD *)v6) = 32;
      while ( v12 < 4096 - *(_DWORD *)(v6 + 32) );
    }
    v13 = 4096 - *(_DWORD *)(v6 + 32);
    *(_DWORD *)(v6 + 52) = 0;
    *(_DWORD *)(v6 + 56) = v13;
  }
  v14 = *(char **)(v6 + 12);
  if ( (unsigned int)v14 < *(_DWORD *)(v6 + 8) )
    goto LABEL_33;
  result = ReadInBuf((int)&a4, hFile, v6);
  if ( result == 1 )
  {
    while ( result != 500 )
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(v6 + 40) > a3 )
        {
          v22 = *(_DWORD *)(v6 + 12);
          if ( v22 == *(_DWORD *)(v6 + 4) + 1 )
            *(_DWORD *)(v6 + 28) = 1;
          else
            *(_DWORD *)(v6 + 12) = v22 - 1;
          return 1;
        }
        *(_DWORD *)(v6 + 52) >>= 1;
        if ( !(*(_DWORD *)(v6 + 52) & 0x100) )
        {
          *(_DWORD *)(v6 + 52) = (unsigned __int8)a4 | 0xFF00;
          v15 = *(char **)(v6 + 12);
          if ( (unsigned int)v15 >= *(_DWORD *)(v6 + 8) )
          {
            if ( ReadInBuf((int)&a4, hFile, v6) != 1 )
              return -3;
          }
          else
          {
            a4 = *v15;
            *(_DWORD *)(v6 + 12) = v15 + 1;
          }
        }
        if ( *(_BYTE *)(v6 + 52) & 1 )
        {
          v16 = *(_DWORD *)(v6 + 24);
          if ( v16 >= *(_DWORD *)(v6 + 20) )
          {
            ++*(_DWORD *)(v6 + 40);
            result = WriteOutBuf(a4, a2, v6);
            if ( result != 1 )
              return result;
          }
          else
          {
            *(_BYTE *)v16 = a4;
            ++*(_DWORD *)(v6 + 24);
            ++*(_DWORD *)(v6 + 40);
          }
          *(_BYTE *)(*(_DWORD *)(v6 + 56) + *(_DWORD *)v6) = a4;
          *(_DWORD *)(v6 + 56) = ((unsigned __int16)*(_DWORD *)(v6 + 56) + 1) & 0xFFF;
        }
        else
        {
          v17 = *(_DWORD *)(v6 + 12);
          if ( v17 >= *(_DWORD *)(v6 + 8) )
          {
            if ( ReadInBuf((int)((char *)&a6 + 3), hFile, v6) != 1 )
              return -3;
          }
          else
          {
            BYTE3(a6) = *(_BYTE *)v17;
            *(_DWORD *)(v6 + 12) = v17 + 1;
          }
          v18 = (unsigned __int8)a4 | 16 * (unsigned __int8)(BYTE3(a6) & 0xF0);
          v24 = (BYTE3(a6) & 0xF) + 2;
          for ( i = 0; i <= v24; *(_DWORD *)(v6 + 56) = ((unsigned __int16)*(_DWORD *)(v6 + 56) + 1) & 0xFFF )
          {
            v20 = *(_BYTE *)((((_WORD)v18 + (_WORD)i) & 0xFFF) + *(_DWORD *)v6);
            v21 = *(_DWORD *)(v6 + 24);
            a4 = *(_BYTE *)((((_WORD)v18 + (_WORD)i) & 0xFFF) + *(_DWORD *)v6);
            if ( v21 >= *(_DWORD *)(v6 + 20) )
            {
              ++*(_DWORD *)(v6 + 40);
              result = WriteOutBuf(a4, a2, v6);
              if ( result != 1 )
                return result;
            }
            else
            {
              *(_BYTE *)v21 = v20;
              ++*(_DWORD *)(v6 + 24);
              ++*(_DWORD *)(v6 + 40);
            }
            *(_BYTE *)(*(_DWORD *)(v6 + 56) + *(_DWORD *)v6) = a4;
            ++i;
          }
        }
        v14 = *(char **)(v6 + 12);
        if ( (unsigned int)v14 >= *(_DWORD *)(v6 + 8) )
          break;
LABEL_33:
        a4 = *v14;
        *(_DWORD *)(v6 + 12) = v14 + 1;
      }
      result = ReadInBuf((int)&a4, hFile, v6);
      if ( result != 1 && result != 500 )
        return result;
    }
  }
  else if ( result != 500 )
  {
    return result;
  }
  return 1;
}

//----- (77E8FB20) --------------------------------------------------------
int __stdcall ExtractFileNameW(int a1)
{
  int result; // eax@1
  __int16 v2; // cx@1
  int i; // edx@1

  result = a1;
  v2 = *(_WORD *)a1;
  for ( i = a1; *(_WORD *)i; v2 = *(_WORD *)i )
  {
    if ( v2 == 92 || v2 == 58 )
      result = i + 2;
    i += 2;
  }
  return result;
}

//----- (77E8FB57) --------------------------------------------------------
int __stdcall ExtractFileName(int a1)
{
  BYTE *v1; // esi@1
  int v2; // edi@1
  BYTE v3; // al@3

  v1 = (BYTE *)a1;
  v2 = a1;
  while ( *v1 )
  {
    if ( !IsDBCSLeadByte(*v1) )
    {
      v3 = *v1;
      if ( *v1 == 47 || v3 == 92 || v3 == 58 )
        v2 = LZCharNextA(v1);
    }
    v1 = (BYTE *)LZCharNextA(v1);
  }
  return v2;
}

//----- (77E8FBA2) --------------------------------------------------------
int __stdcall ExtractExtensionW(int a1)
{
  int i; // eax@1

  for ( i = ExtractFileNameW(a1); *(_WORD *)i; i += 2 )
  {
    if ( *(_WORD *)i == 46 )
      return i + 2;
  }
  if ( *(_WORD *)i == 46 )
    return i + 2;
  return 0;
}

//----- (77E8FBD7) --------------------------------------------------------
int __stdcall ExtractExtension(int a1)
{
  int i; // eax@1
  BYTE *v2; // esi@2

  for ( i = ExtractFileName(a1); ; i = LZCharNextA(v2) )
  {
    v2 = (BYTE *)i;
    if ( IsDBCSLeadByte(*(_BYTE *)i) )
      continue;
    if ( !*v2 )
      break;
    if ( *v2 == 46 )
      return (int)(v2 + 1);
  }
  if ( *v2 == 46 )
    return (int)(v2 + 1);
  return 0;
}

//----- (77E8FC1C) --------------------------------------------------------
WCHAR __stdcall MakeCompressedNameW(wchar_t *Dst, rsize_t SizeInWords)
{
  const WCHAR v2; // di@1
  int v3; // eax@1
  const WCHAR *v4; // esi@1

  v2 = 0;
  v3 = ExtractExtensionW((int)Dst);
  v4 = (const WCHAR *)v3;
  if ( v3 )
  {
    if ( lstrlenW((LPCWSTR)v3) < 3 )
    {
      wcscat_s(Dst, SizeInWords, L"_");
    }
    else
    {
      v2 = v4[lstrlenW(v4) - 1];
      v4[lstrlenW(v4) - 1] = 95;
    }
  }
  else
  {
    wcscat_s(Dst, SizeInWords, L"._");
  }
  return v2;
}
// 77E8FC84: using guessed type wchar_t a__1[2];

//----- (77E8FC8D) --------------------------------------------------------
CHAR __stdcall MakeCompressedName(LPCSTR lpString, rsize_t SizeInBytes)
{
  const CHAR v2; // bl@1
  int v3; // eax@1
  int v4; // ecx@1
  const CHAR v5; // dl@2
  const CHAR *v6; // eax@11

  v2 = 0;
  v3 = lstrlenA(lpString);
  v4 = v3;
  if ( !v3 )
    goto LABEL_16;
  do
  {
    --v4;
    v5 = lpString[v4];
    if ( v5 == 46 )
      break;
    if ( v5 == 92 || v5 == 58 )
    {
      v4 = 0;
      break;
    }
  }
  while ( v4 );
  if ( v4 )
  {
    if ( (unsigned int)(v3 - v4) > 3 )
    {
      v6 = &lpString[v3 - 1];
      v2 = *v6;
      *v6 = 95;
    }
    else
    {
      strcat_s((char *)lpString, SizeInBytes, "_");
    }
  }
  else
  {
LABEL_16:
    strcat_s((char *)lpString, SizeInBytes, "._");
  }
  return v2;
}

//----- (77E8FD03) --------------------------------------------------------
int __stdcall MakeExpandedName(int a1, unsigned __int8 a2)
{
  BYTE *v2; // esi@1
  int result; // eax@1
  int v4; // edi@1
  unsigned __int8 v5; // bl@2
  BYTE i; // al@5
  BYTE v7; // al@8
  BYTE *v8; // esi@26
  int j; // eax@26

  v2 = (BYTE *)a1;
  result = ExtractExtension(a1);
  v4 = result;
  if ( result )
  {
    v5 = a2;
    if ( a2 >= 0x41u && a2 <= 0x5Au || (unsigned __int8)(a2 - 97) <= 0x19u )
    {
      for ( i = *(_BYTE *)a1; i; i = *v2 )
      {
        if ( IsDBCSLeadByte(i) )
        {
          v2 += 2;
        }
        else
        {
          v7 = *v2;
          if ( (char)*v2 >= 65 && (char)v7 <= 90 || (char)v7 >= 97 && (char)v7 <= 122 )
            break;
          ++v2;
        }
      }
      if ( LZIsCharLowerA(*v2) )
      {
        if ( (unsigned __int8)(a2 - 65) <= 0x19u )
          v5 = a2 + 32;
      }
      else if ( LZIsCharUpperA(*v2) && (unsigned __int8)(a2 - 97) <= 0x19u )
      {
        v5 = a2 - 32;
      }
    }
    result = lstrlenA((LPCSTR)v4);
    if ( result > 0 )
    {
      if ( IsDBCSLeadByte(*(_BYTE *)v4) || *(_BYTE *)v4 != 95 || (result = IsDBCSLeadByte(*(_BYTE *)(v4 + 1))) == 0 )
      {
        v8 = (BYTE *)v4;
        for ( j = v4; *(_BYTE *)j; j = LZCharNextA((BYTE *)j) )
          v8 = (BYTE *)j;
        result = IsDBCSLeadByte(*v8);
        if ( !result && *v8 == 95 )
          *v8 = v5;
      }
      else
      {
        *(_BYTE *)v4 = v5;
      }
    }
    if ( !*(_BYTE *)v4 && *(_BYTE *)(v4 - 1) == 46 )
      *(_BYTE *)(v4 - 1) = 0;
  }
  return result;
}

//----- (77E8FE04) --------------------------------------------------------
int __stdcall CopyDateTimeStamp(HANDLE hFile, HANDLE a2)
{
  int result; // eax@2
  struct _FILETIME CreationTime; // [sp+0h] [bp-18h]@1
  struct _FILETIME LastAccessTime; // [sp+8h] [bp-10h]@1
  struct _FILETIME LastWriteTime; // [sp+10h] [bp-8h]@1

  if ( GetFileTime(hFile, &CreationTime, &LastAccessTime, &LastWriteTime) )
    result = SetFileTime(a2, &CreationTime, &LastAccessTime, &LastWriteTime) != 0 ? 1 : -1;
  else
    result = -1;
  return result;
}

//----- (77E8FE4E) --------------------------------------------------------
int __stdcall ReadInBuf(int a1, HFILE hFile, int a3)
{
  UINT v3; // eax@1
  int v4; // edx@1
  bool v6; // zf@6
  int v7; // eax@6

  **(_BYTE **)(a3 + 4) = *(_BYTE *)(*(_DWORD *)(a3 + 8) - 1);
  v3 = _lread(hFile, (LPVOID)(*(_DWORD *)(a3 + 4) + 1), *(_DWORD *)(a3 + 44));
  v4 = *(_DWORD *)(a3 + 44);
  if ( v3 != v4 )
  {
    if ( v3 == -1 )
      return -1;
    if ( !v3 )
      return 500;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a3 + 4) + v3 + 1;
  }
  v6 = *(_DWORD *)(a3 + 28) == 0;
  v7 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a3 + 12) = v7 + 1;
  if ( v6 )
  {
    if ( !v4 )
      return -1;
    *(_BYTE *)a1 = *(_BYTE *)(v7 + 1);
    ++*(_DWORD *)(a3 + 12);
  }
  else
  {
    *(_BYTE *)a1 = *(_BYTE *)v7;
    *(_DWORD *)(a3 + 28) = 0;
  }
  return 1;
}

//----- (77E8FECF) --------------------------------------------------------
int __stdcall WriteOutBuf(char a1, HFILE hFile, int a3)
{
  const CHAR *v3; // eax@1
  UINT v4; // esi@1
  UINT v5; // eax@2
  int result; // eax@3

  v3 = *(const CHAR **)(a3 + 16);
  v4 = *(_DWORD *)(a3 + 24) - (_DWORD)v3;
  *(_DWORD *)(a3 + 24) = v3;
  if ( hFile == -2 || (v5 = _lwrite(hFile, v3, v4), v5 == v4) )
  {
    *(_BYTE *)(*(_DWORD *)(a3 + 24))++ = a1;
    result = 1;
  }
  else
  {
    result = 2 * (v5 == -1) - 4;
  }
  return result;
}

//----- (77E8FF21) --------------------------------------------------------
int __stdcall LZIsCharLowerA(BYTE TestChar)
{
  int result; // eax@3
  WORD CharType[2]; // [sp+0h] [bp-8h]@1
  WCHAR UnicodeString[2]; // [sp+4h] [bp-4h]@1

  *(_DWORD *)CharType = 0;
  *(_DWORD *)UnicodeString = 0;
  if ( (_BYTE)NlsMbCodePageTag && IsDBCSLeadByte(TestChar) )
  {
    result = 0;
  }
  else
  {
    RtlMultiByteToUnicodeN(UnicodeString, 2u, 0, (PCHAR)&TestChar, 1u);
    GetStringTypeW(1u, UnicodeString, 1, CharType);
    result = (CharType[0] & 2) == 2;
  }
  return result;
}

//----- (77E8FF86) --------------------------------------------------------
int __stdcall LZIsCharUpperA(BYTE TestChar)
{
  int result; // eax@3
  WORD CharType[2]; // [sp+0h] [bp-8h]@1
  WCHAR UnicodeString[2]; // [sp+4h] [bp-4h]@1

  *(_DWORD *)CharType = 0;
  *(_DWORD *)UnicodeString = 0;
  if ( (_BYTE)NlsMbCodePageTag && IsDBCSLeadByte(TestChar) )
  {
    result = 0;
  }
  else
  {
    RtlMultiByteToUnicodeN(UnicodeString, 2u, 0, (PCHAR)&TestChar, 1u);
    GetStringTypeW(1u, UnicodeString, 1, CharType);
    result = (CharType[0] & 1) == 1;
  }
  return result;
}

//----- (77E8FFEB) --------------------------------------------------------
int __stdcall LZCharNextA(BYTE *a1)
{
  int v1; // esi@1

  v1 = (int)a1;
  if ( (_BYTE)NlsMbCodePageTag && IsDBCSLeadByte(*a1) )
    v1 = (int)(a1 + 1);
  if ( *(_BYTE *)v1 )
    ++v1;
  return v1;
}

//----- (77E9001E) --------------------------------------------------------
int __stdcall K32EmptyWorkingSet(HANDLE ProcessHandle)
{
  NTSTATUS v1; // eax@1
  DWORD v2; // eax@2
  int result; // eax@2
  struct _SYSTEM_INFO SystemInfo; // [sp+0h] [bp-44h]@1
  char ProcessInformation; // [sp+24h] [bp-20h]@1
  int v6; // [sp+2Ch] [bp-18h]@3
  int v7; // [sp+30h] [bp-14h]@3

  GetSystemInfo(&SystemInfo);
  v1 = NtQueryInformationProcess(ProcessHandle, ProcessQuotaLimits, &ProcessInformation, 0x20u, 0);
  if ( v1 < 0
    || (v6 = -1,
        v7 = -1,
        v1 = NtSetInformationProcess(ProcessHandle, ProcessQuotaLimits, &ProcessInformation, 0x20u),
        v1 < 0)
    && v1 != -1073741727 )
  {
    v2 = RtlNtStatusToDosError(v1);
    SetLastError(v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E90089) --------------------------------------------------------
int __stdcall K32GetDeviceDriverFileNameA(int a1, void *Dst, int a3)
{
  int result; // eax@1
  unsigned int v4; // kr00_4@2
  int v5; // edi@2
  char v6; // [sp+4h] [bp-120h]@1
  char Src; // [sp+20h] [bp-104h]@2

  result = FindDeviceDriver(a1, &v6);
  if ( result )
  {
    v4 = strlen(&Src);
    v5 = v4 + 1;
    if ( a3 < v4 + 1 )
      v5 = a3;
    memcpy(Dst, &Src, v5);
    if ( v5 == v4 + 1 )
      --v5;
    result = v5;
  }
  return result;
}

//----- (77E90104) --------------------------------------------------------
HLOCAL __stdcall K32GetDeviceDriverFileNameW(int a1, LPWSTR lpWideCharStr, SIZE_T uBytes)
{
  HLOCAL result; // eax@1
  const CHAR *v4; // ebx@1
  int v5; // eax@3
  HLOCAL v6; // esi@3

  result = LocalAlloc(0, uBytes);
  v4 = (const CHAR *)result;
  if ( result )
  {
    v5 = K32GetDeviceDriverFileNameA(a1, result, uBytes);
    v6 = (HLOCAL)v5;
    if ( !v5 )
      goto LABEL_12;
    if ( v5 < uBytes )
      ++v5;
    if ( !MultiByteToWideChar(0, 0, v4, v5, lpWideCharStr, uBytes) )
LABEL_12:
      v6 = 0;
    LocalFree((HLOCAL)v4);
    result = v6;
  }
  return result;
}

//----- (77E90164) --------------------------------------------------------
BOOL __stdcall K32EnumPageFilesW(PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine, LPVOID pContext)
{
  SIZE_T v2; // ebx@1
  HLOCAL i; // eax@1
  PVOID j; // esi@10
  wchar_t *v5; // eax@11
  ULONG v6; // eax@14
  DWORD v8; // eax@9
  struct _ENUM_PAGE_FILE_INFORMATION pPageFileInfo; // [sp+Ch] [bp-20h]@11
  NTSTATUS NtStatus; // [sp+20h] [bp-Ch]@2
  PVOID SystemInformation; // [sp+24h] [bp-8h]@2
  ULONG ReturnLength; // [sp+28h] [bp-4h]@2

  v2 = 4096;
  for ( i = LocalAlloc(0, 0x1000u); ; i = LocalAlloc(0, v2) )
  {
    SystemInformation = i;
    if ( !i )
    {
      v8 = RtlNtStatusToDosError(-1073741670);
LABEL_20:
      SetLastError(v8);
      return 0;
    }
    NtStatus = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)18, SystemInformation, v2, &ReturnLength);
    if ( NtStatus >= 0 )
      break;
    LocalFree(SystemInformation);
    if ( NtStatus != -1073741820 )
    {
      v8 = RtlNtStatusToDosError(NtStatus);
      goto LABEL_20;
    }
    if ( ReturnLength <= v2 )
      v2 += 4096;
    else
      v2 = ReturnLength;
  }
  for ( j = SystemInformation; ReturnLength > 0x18; j = (char *)j + *(_DWORD *)j )
  {
    pPageFileInfo.Reserved = 0;
    pPageFileInfo.cb = 20;
    pPageFileInfo.TotalSize = *((_DWORD *)j + 1);
    pPageFileInfo.TotalInUse = *((_DWORD *)j + 2);
    pPageFileInfo.PeakUsage = *((_DWORD *)j + 3);
    v5 = wcschr(*((const wchar_t **)j + 5), 0x3Au);
    if ( v5 && (unsigned int)v5 > *((_DWORD *)j + 5) )
      ((void (__stdcall *)(_DWORD, _DWORD, _DWORD))pCallBackRoutine)(pContext, &pPageFileInfo, v5 - 1);
    v6 = *(_DWORD *)j;
    if ( !*(_DWORD *)j || v6 > ReturnLength )
      break;
    ReturnLength -= v6;
  }
  LocalFree(SystemInformation);
  return 1;
}

//----- (77E90252) --------------------------------------------------------
int __stdcall CallBackConvertToAscii(int a1, int a2, LPCWSTR lpWideCharStr)
{
  int v3; // edi@1
  unsigned int v4; // kr00_4@1
  CHAR *v5; // eax@1
  void *v6; // ebx@1
  int result; // eax@2

  v3 = 0;
  v4 = wcslen(lpWideCharStr);
  v5 = (CHAR *)LocalAlloc(0, v4 + 1);
  v6 = v5;
  if ( v5 )
  {
    if ( WideCharToMultiByte(0, 0, lpWideCharStr, -1, v5, v4 + 1, 0, 0) )
      v3 = (*(int (__stdcall **)(_DWORD, int, void *))(a1 + 4))(*(_DWORD *)a1, a2, v6);
    else
      *(_DWORD *)(a1 + 8) = GetLastError();
    LocalFree(v6);
    result = v3;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = RtlNtStatusToDosError(-1073741670);
    result = 0;
  }
  return result;
}

//----- (77E902DC) --------------------------------------------------------
BOOL __stdcall K32EnumPageFilesA(PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine, LPVOID pContext)
{
  BOOL v2; // esi@1
  LPVOID v4; // [sp+4h] [bp-Ch]@1
  PENUM_PAGE_FILE_CALLBACKA v5; // [sp+8h] [bp-8h]@1
  DWORD dwErrCode; // [sp+Ch] [bp-4h]@1

  dwErrCode = 0;
  v4 = pContext;
  v5 = pCallBackRoutine;
  v2 = K32EnumPageFilesW((PENUM_PAGE_FILE_CALLBACKW)CallBackConvertToAscii, &v4);
  if ( v2 && dwErrCode )
  {
    v2 = 0;
    SetLastError(dwErrCode);
  }
  return v2;
}

//----- (77E90326) --------------------------------------------------------
int __stdcall K32EnumProcessModulesEx(HANDLE ProcessHandle, int a2, int a3, int a4, int a5)
{
  return EnumProcessModulesInternal(ProcessHandle, a2, a3, a4, 1);
}

//----- (77E903A9) --------------------------------------------------------
int __stdcall K32InitializeProcessForWsWatch(HANDLE ProcessHandle)
{
  NTSTATUS v1; // eax@1
  DWORD v2; // eax@3
  int result; // eax@3

  v1 = NtSetInformationProcess(ProcessHandle, ProcessWorkingSetWatch, 0, 0);
  if ( v1 >= 0 || v1 == -1073741752 )
  {
    result = 1;
  }
  else
  {
    v2 = RtlNtStatusToDosError(v1);
    SetLastError(v2);
    result = 0;
  }
  return result;
}

//----- (77E903E6) --------------------------------------------------------
int __stdcall GetWsChangesInternal(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)
{
  NTSTATUS v5; // eax@1
  int result; // eax@2
  DWORD v7; // eax@3

  v5 = NtQueryInformationProcess(
         ProcessHandle,
         ProcessInformationClass,
         ProcessInformation,
         ProcessInformationLength,
         ReturnLength);
  if ( v5 < 0 )
  {
    v7 = RtlNtStatusToDosError(v5);
    SetLastError(v7);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E90422) --------------------------------------------------------
int __stdcall K32GetWsChanges(HANDLE ProcessHandle, PVOID ProcessInformation, ULONG ProcessInformationLength)
{
  return GetWsChangesInternal(ProcessHandle, ProcessWorkingSetWatch, ProcessInformation, ProcessInformationLength, 0);
}

//----- (77E90442) --------------------------------------------------------
int __stdcall K32GetWsChangesEx(HANDLE ProcessHandle, PVOID ProcessInformation, PULONG ReturnLength)
{
  return GetWsChangesInternal(ProcessHandle, ProcessWorkingSetWatchEx, ProcessInformation, *ReturnLength, ReturnLength);
}

//----- (77E90463) --------------------------------------------------------
unsigned int __stdcall K32GetProcessImageFileNameW(HANDLE ProcessHandle, void *Dst, int a3)
{
  HLOCAL v3; // eax@1
  HLOCAL v4; // edi@1
  unsigned int v5; // esi@2
  signed int v6; // eax@3
  DWORD v7; // eax@6

  v3 = LocalAlloc(0, 2 * a3 + 8);
  v4 = v3;
  if ( v3 )
  {
    v6 = NtQueryInformationProcess(ProcessHandle, ProcessImageFileName, v3, 2 * a3 + 8, 0);
    if ( v6 == -1073741820 )
      v6 = -1073741789;
    if ( v6 >= 0 )
    {
      memcpy(Dst, *((const void **)v4 + 1), *(_WORD *)v4);
      v5 = (unsigned int)*(_WORD *)v4 >> 1;
      if ( v5 < a3 )
        *((_WORD *)Dst + v5) = 0;
    }
    else
    {
      v7 = RtlNtStatusToDosError(v6);
      SetLastError(v7);
      v5 = 0;
    }
    LocalFree(v4);
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

//----- (77E904EC) --------------------------------------------------------
unsigned int __stdcall K32GetProcessImageFileNameA(HANDLE ProcessHandle, LPSTR lpMultiByteStr, int cbMultiByte)
{
  HLOCAL v3; // eax@1
  HLOCAL v4; // edi@1
  unsigned int v5; // esi@2
  signed int v6; // eax@3
  DWORD v7; // eax@6
  int v8; // eax@7
  CHAR *v9; // eax@8

  v3 = LocalAlloc(0, 2 * cbMultiByte + 8);
  v4 = v3;
  if ( v3 )
  {
    v6 = NtQueryInformationProcess(ProcessHandle, ProcessImageFileName, v3, 2 * cbMultiByte + 8, 0);
    if ( v6 == -1073741820 )
      v6 = -1073741789;
    if ( v6 >= 0 )
    {
      v8 = WideCharToMultiByte(
             0,
             0,
             *((LPCWSTR *)v4 + 1),
             (unsigned int)*(_WORD *)v4 >> 1,
             lpMultiByteStr,
             cbMultiByte,
             0,
             0);
      v5 = v8;
      if ( v8 )
      {
        v9 = &lpMultiByteStr[v8];
        if ( lpMultiByteStr[v5 - 1] )
        {
          if ( v5 < cbMultiByte )
            *v9 = 0;
        }
        else
        {
          --v5;
        }
      }
    }
    else
    {
      v7 = RtlNtStatusToDosError(v6);
      SetLastError(v7);
      v5 = 0;
    }
    LocalFree(v4);
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

//----- (77E90585) --------------------------------------------------------
__int16 __stdcall KeySemanticsGetSid(int a1, int a2)
{
  __int16 result; // ax@1

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 16) + 32;
  result = *(_WORD *)(a1 + 6) - 44;
  *(_WORD *)a2 = result;
  return result;
}

//----- (77E905AD) --------------------------------------------------------
NTSTATUS __stdcall GetFixedKeyInfo(HANDLE KeyHandle, HANDLE a2, int a3, int a4, int a5, int a6, int a7)
{
  unsigned int v7; // ebx@1
  NTSTATUS result; // eax@1
  char KeyInformation; // [sp+Ch] [bp-38h]@12
  int v10; // [sp+20h] [bp-24h]@13
  unsigned int v11; // [sp+24h] [bp-20h]@13
  int v12; // [sp+28h] [bp-1Ch]@13
  int v13; // [sp+34h] [bp-10h]@1
  int v14; // [sp+38h] [bp-Ch]@1
  int v15; // [sp+3Ch] [bp-8h]@1
  int v16; // [sp+40h] [bp-4h]@1

  v7 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  result = -1073741772;
  if ( a3 )
    *(_DWORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  if ( a7 )
    *(_DWORD *)a7 = 0;
  if ( a5 )
    *(_DWORD *)a5 = 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  if ( KeyHandle )
  {
    result = NtQueryKey(KeyHandle, KeyCachedInformation, &KeyInformation, 0x28u, (PULONG)&KeyHandle);
    if ( result < 0 )
      return result;
    v7 = v11;
    v16 = v10;
    v14 = v12;
  }
  if ( a2 )
  {
    result = NtQueryKey(a2, KeyCachedInformation, &KeyInformation, 0x28u, (PULONG)&KeyHandle);
    if ( result < 0 )
      return result;
    v15 = v10;
    v13 = v12;
    if ( v11 > v7 )
      v7 = v11;
  }
  if ( a3 )
    *(_DWORD *)a3 = v16;
  if ( a4 )
    *(_DWORD *)a4 = v15;
  if ( a7 )
    *(_DWORD *)a7 = v7;
  if ( a5 )
    *(_DWORD *)a5 = v14;
  if ( a6 )
    *(_DWORD *)a6 = v13;
  return result;
}

//----- (77E9069C) --------------------------------------------------------
NTSTATUS __stdcall BaseRegMapClassOnAccessDenied(int a1, PHANDLE KeyHandle, PUNICODE_STRING DestinationString, int a4, int a5)
{
  bool v5; // zf@1
  USHORT v7; // ax@8
  WCHAR *v8; // eax@8
  __int16 v9; // di@10
  unsigned int v10; // esi@10
  NTSTATUS v11; // eax@11
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-2Ch]@10
  __int16 v13; // [sp+24h] [bp-14h]@10
  PWCH v14; // [sp+28h] [bp-10h]@10
  UNICODE_STRING SourceString; // [sp+2Ch] [bp-Ch]@1
  NTSTATUS v16; // [sp+34h] [bp-4h]@1

  v5 = (*(_BYTE *)a1 & 4) == 0;
  v16 = -1073741790;
  SourceString.Buffer = 0;
  if ( !v5 && *(_DWORD *)a4 )
  {
    if ( *KeyHandle )
    {
      NtClose(*KeyHandle);
      *KeyHandle = 0;
    }
    *(_DWORD *)a4 = 0;
    SourceString.MaximumLength = **(_WORD **)(a1 + 16) + 128;
    SourceString.Buffer = (PWCH)RtlAllocateHeap(
                                  NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1],
                                  0,
                                  SourceString.MaximumLength);
    if ( !SourceString.Buffer )
      return -1073741801;
    v16 = BaseRegTranslateToUserClassKey(a1, &SourceString, (int)&a4);
    if ( v16 >= 0 )
    {
      v7 = SourceString.MaximumLength - a4 + 2;
      DestinationString->MaximumLength = v7;
      v8 = (WCHAR *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v7);
      DestinationString->Buffer = v8;
      if ( v8 )
      {
        v9 = a4;
        v14 = SourceString.Buffer;
        SourceString.Length += -2 - a4;
        v10 = 2 * (((unsigned int)(unsigned __int16)a4 + 2) >> 1);
        SourceString.Buffer = (PWCH)((char *)SourceString.Buffer + v10);
        v13 = a4;
        RtlCopyUnicodeString(DestinationString, &SourceString);
        SourceString.Buffer = (PWCH)((char *)SourceString.Buffer - v10);
        SourceString.Length += v9 + 2;
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&v13;
        ObjectAttributes.Length = 24;
        ObjectAttributes.RootDirectory = 0;
        ObjectAttributes.Attributes = 64;
        ObjectAttributes.SecurityDescriptor = 0;
        ObjectAttributes.SecurityQualityOfService = 0;
        if ( a5 )
          v11 = NtOpenKeyTransacted(KeyHandle, 0x2000000, &ObjectAttributes, a5);
        else
          v11 = NtOpenKey(KeyHandle, 0x2000000u, &ObjectAttributes);
        v16 = v11;
        if ( v11 < 0 )
        {
          RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString->Buffer);
          DestinationString->Buffer = 0;
        }
      }
      else
      {
        v16 = -1073741801;
      }
    }
    if ( SourceString.Buffer )
      RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, SourceString.Buffer);
  }
  return v16;
}
// 77DE1694: using guessed type int __stdcall NtOpenKeyTransacted(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E9083B) --------------------------------------------------------
signed int __stdcall ExtractClassKey(HANDLE *a1, int a2, int a3)
{
  HANDLE *v3; // ebx@1
  bool v4; // cf@5
  int v5; // edi@10
  __int16 v6; // cx@14
  signed int result; // eax@17
  ULONG ResultLength; // [sp+Ch] [bp-8h]@9
  int v9; // [sp+10h] [bp-4h]@1

  v9 = 0;
  v3 = (HANDLE *)(RegKrnGetGlobalState() + 156);
  if ( *(_WORD *)a2 < 0xEu
    || (_wcsnicmp(*(const wchar_t **)(a2 + 4), off_77EA6CF0, 7u)
     || *(_WORD *)a2 > 0xEu && *(_WORD *)(*(_DWORD *)(a2 + 4) + 14) != 92)
    && ((v4 = *(_WORD *)a2 < 0x20u, v9 = 1, v4)
     || _wcsnicmp(*(const wchar_t **)(a2 + 4), off_77EA6CF4, 0x10u)
     || *(_WORD *)a2 > 0x20u && *(_WORD *)(*(_DWORD *)(a2 + 4) + 32) != 92)
    || NtQueryKey(*a1, KeyNameInformation, &dword_77EA6FA0, 0x3Eu, &ResultLength) < 0
    || (v5 = v9, dword_77EA6FA0 != (unsigned __int16)word_77E90988[v9])
    || _wcsnicmp(&Str1, (&off_77EA6CF8)[2 * v9], (unsigned __int16)word_77E90984[v5])
    || !*v3 && OpenClassesRootInternal(0, 0x2000000u, v3, a3) )
  {
    result = 0;
  }
  else
  {
    v6 = word_77E9098C[v5];
    if ( *(_WORD *)a2 > (unsigned __int16)v6 )
    {
      *(_WORD *)a2 -= v6;
      *(_WORD *)(a2 + 2) -= word_77E9098C[v5];
      *(_DWORD *)(a2 + 4) += 2 * ((unsigned int)(unsigned __int16)word_77E9098C[v5] >> 1);
    }
    else
    {
      *(_WORD *)a2 = 0;
    }
    *a1 = *v3;
    result = 1;
  }
  return result;
}
// 77E90984: using guessed type __int16 word_77E90984[];
// 77E90988: using guessed type __int16 word_77E90988[];
// 77E9098C: using guessed type __int16 word_77E9098C[];
// 77EA6FA0: using guessed type int dword_77EA6FA0;

//----- (77E90995) --------------------------------------------------------
NTSTATUS __stdcall CreateMultipartUserClassKey(HANDLE a1, int a2)
{
  NTSTATUS result; // eax@1
  unsigned int v3; // esi@3
  wchar_t *v4; // eax@3
  wchar_t *v5; // edi@6
  wchar_t *v6; // eax@11
  wchar_t v7; // cx@12
  signed int v8; // eax@13
  HANDLE v9; // esi@15
  wchar_t *v10; // eax@18
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-1E8h]@15
  UNICODE_STRING Source; // [sp+24h] [bp-1D0h]@1
  int v13; // [sp+2Ch] [bp-1C8h]@1
  int v14; // [sp+30h] [bp-1C4h]@1
  int v15; // [sp+34h] [bp-1C0h]@1
  int v16; // [sp+38h] [bp-1BCh]@1
  char *v17; // [sp+3Ch] [bp-1B8h]@1
  __int16 v18; // [sp+40h] [bp-1B4h]@15
  wchar_t *v19; // [sp+44h] [bp-1B0h]@10
  wchar_t *Str; // [sp+48h] [bp-1ACh]@3
  int v21; // [sp+4Ch] [bp-1A8h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+50h] [bp-1A4h]@2
  HANDLE KeyHandle; // [sp+58h] [bp-19Ch]@3
  int v24; // [sp+5Ch] [bp-198h]@1
  NTSTATUS v25; // [sp+60h] [bp-194h]@2
  unsigned int i; // [sp+64h] [bp-190h]@6
  HANDLE v27; // [sp+68h] [bp-18Ch]@1
  char v28; // [sp+6Ch] [bp-188h]@1
  char Dst; // [sp+6Dh] [bp-187h]@1

  v21 = a2;
  v28 = 0;
  memset(&Dst, 0, 0x181u);
  v14 = 0;
  v15 = 0;
  v13 = 0;
  Source.Length = 0;
  *(_DWORD *)&Source.MaximumLength = 0;
  HIWORD(Source.Buffer) = 0;
  v17 = &v28;
  v27 = 0;
  v24 = 1;
  v16 = 386;
  result = BaseRegGetKeySemantics(a1, &Source, (int)&v13);
  if ( result >= 0 )
  {
    DestinationString.Buffer = 0;
    v25 = BaseRegMapClassOnAccessDenied((int)&v13, &v27, &DestinationString, (int)&v24, 0);
    BaseRegReleaseKeySemantics((int)&v13);
    result = v25;
    if ( v25 >= 0 )
    {
      KeyHandle = (HANDLE)(v27 != a1 ? (unsigned int)v27 : 0);
      Str = DestinationString.Buffer;
      v3 = 1;
      v24 = 1;
      v4 = wcschr(DestinationString.Buffer, 0x5Cu);
      if ( v4 )
      {
        do
        {
          ++v3;
          v4 = wcschr(v4 + 1, 0x5Cu);
        }
        while ( v4 );
        v24 = v3;
      }
      v5 = Str;
      for ( i = 0; i < v3; ++i )
      {
        if ( *v5 != 92 || i == v3 - 1 )
        {
          v19 = v5;
          if ( i == v3 - 1 )
          {
            v6 = v5;
            do
            {
              v7 = *v6;
              ++v6;
            }
            while ( v7 );
            v8 = (char *)v6 - (char *)(v5 + 1);
          }
          else
          {
            v8 = (char *)wcschr(v5, 0x5Cu) - (char *)v5;
          }
          v9 = KeyHandle;
          v18 = 2 * (v8 >> 1);
          ObjectAttributes.RootDirectory = v27;
          ObjectAttributes.ObjectName = (PUNICODE_STRING)&v18;
          ObjectAttributes.Length = 24;
          ObjectAttributes.Attributes = 64;
          ObjectAttributes.SecurityDescriptor = 0;
          ObjectAttributes.SecurityQualityOfService = 0;
          v25 = NtCreateKey(&KeyHandle, 0x2000000u, &ObjectAttributes, 0, 0, 0, 0);
          v27 = KeyHandle;
          if ( v9 )
            NtClose(v9);
          if ( v25 < 0 )
            break;
          v10 = wcschr(v5, 0x5Cu);
          v3 = v24;
          v5 = v10 + 1;
        }
        else
        {
          ++v5;
        }
      }
      if ( DestinationString.Buffer )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, DestinationString.Buffer);
      result = v25;
      if ( v25 >= 0 )
        *(_DWORD *)v21 = v27;
    }
  }
  return result;
}

//----- (77E90C36) --------------------------------------------------------
ULONG __stdcall LocalBaseRegUnLoadKey(void *a1, int a2)
{
  unsigned __int16 v2; // cx@3
  NTSTATUS v3; // eax@8
  OBJECT_ATTRIBUTES KeyObjectAttributes; // [sp+4h] [bp-18h]@8

  if ( !a1 )
    return 87;
  if ( !a2 )
    goto LABEL_8;
  v2 = *(_WORD *)a2;
  if ( *(_WORD *)a2 & 1 )
    return 87;
  if ( !v2 )
  {
LABEL_8:
    KeyObjectAttributes.ObjectName = (PUNICODE_STRING)a2;
    KeyObjectAttributes.Length = 24;
    KeyObjectAttributes.RootDirectory = a1;
    KeyObjectAttributes.Attributes = 64;
    KeyObjectAttributes.SecurityDescriptor = 0;
    KeyObjectAttributes.SecurityQualityOfService = 0;
    v3 = NtUnloadKey(&KeyObjectAttributes);
    return RtlNtStatusToDosError(v3);
  }
  if ( *(_DWORD *)(a2 + 4) )
  {
    if ( v2 > 0u )
      *(_WORD *)a2 = v2 - 2;
    goto LABEL_8;
  }
  return 87;
}

//----- (77E90CA6) --------------------------------------------------------
int __stdcall CombineKeyInfo(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  unsigned int v6; // ecx@2
  unsigned int v7; // ecx@4
  unsigned int v8; // ecx@6
  unsigned int v9; // edx@8
  unsigned int v10; // edx@10
  unsigned int v11; // edx@12
  unsigned int v12; // ecx@14

  result = a1;
  if ( a3 == 4 )
  {
    *(_DWORD *)(a1 + 12) = a4;
    *(_DWORD *)(a1 + 20) = a5;
    v6 = *(_DWORD *)(a2 + 16);
    if ( v6 > *(_DWORD *)(a1 + 16) )
      *(_DWORD *)(a1 + 16) = v6;
    v7 = *(_DWORD *)(a2 + 24);
    if ( v7 > *(_DWORD *)(a1 + 24) )
      *(_DWORD *)(a1 + 24) = v7;
    v8 = *(_DWORD *)(a2 + 28);
    if ( v8 > *(_DWORD *)(a1 + 28) )
      *(_DWORD *)(a1 + 28) = v8;
  }
  else
  {
    *(_DWORD *)(a1 + 20) = a4;
    *(_DWORD *)(a1 + 32) = a5;
    v9 = *(_DWORD *)(a2 + 24);
    if ( v9 > *(_DWORD *)(a1 + 24) )
      *(_DWORD *)(a1 + 24) = v9;
    v10 = *(_DWORD *)(a2 + 28);
    if ( v10 > *(_DWORD *)(a1 + 28) )
      *(_DWORD *)(a1 + 28) = v10;
    v11 = *(_DWORD *)(a2 + 36);
    if ( v11 > *(_DWORD *)(a1 + 36) )
      *(_DWORD *)(a1 + 36) = v11;
    v12 = *(_DWORD *)(a2 + 40);
    if ( v12 > *(_DWORD *)(a1 + 40) )
      *(_DWORD *)(a1 + 40) = v12;
  }
  return result;
}

//----- (77E90D27) --------------------------------------------------------
int __stdcall LocalOpenPerformanceNlsText(int a1, int a2, int a3)
{
  *(_DWORD *)a3 = -2147483552;
  return 0;
}

//----- (77E90D40) --------------------------------------------------------
signed int __stdcall SfpInstallCatalog(int a1, int a2, int a3)
{
  return 120;
}

//----- (77E90D4B) --------------------------------------------------------
BOOLEAN __stdcall ValStateReleaseValues(PVOID Address, int a2)
{
  unsigned int v2; // esi@1

  v2 = 0;
  if ( a2 )
  {
    do
    {
      if ( *((_DWORD *)Address + v2) )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)Address + v2));
      ++v2;
    }
    while ( v2 < a2 );
  }
  return RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
}

//----- (77E90D9E) --------------------------------------------------------
signed int __stdcall ValStateAddValueToSortedValues(int a1, int a2)
{
  int v2; // edi@1
  int v3; // ebx@1
  int v4; // eax@2
  LONG v5; // eax@2
  int v7; // eax@8
  int v8; // ecx@8
  UNICODE_STRING String1; // [sp+Ch] [bp-14h]@1
  UNICODE_STRING String2; // [sp+14h] [bp-Ch]@2
  int v11; // [sp+1Ch] [bp-4h]@1

  v11 = 0;
  v2 = *(_DWORD *)(a1 + 4 * a2);
  String1.Buffer = (PWCH)(v2 + 12);
  String1.Length = *(_WORD *)(v2 + 8);
  v3 = a2 - 1;
  if ( a2 - 1 >= 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(a1 + 4 * v3);
      String2.Buffer = (PWCH)(v4 + 12);
      String2.Length = *(_WORD *)(v4 + 8);
      v5 = RtlCompareUnicodeString(&String1, &String2, 1u);
      if ( v5 >= 0 )
        break;
      --v3;
      if ( v3 < 0 )
        goto LABEL_8;
    }
    if ( !v5 )
      return 0;
    v11 = v3 + 1;
  }
LABEL_8:
  v7 = a2 - 1;
  v8 = v11;
  while ( v7 >= v8 )
  {
    *(_DWORD *)(a1 + 4 * v7 + 4) = *(_DWORD *)(a1 + 4 * v7);
    --v7;
  }
  *(_DWORD *)(a1 + 4 * v8) = v2;
  return 1;
}

//----- (77E90E26) --------------------------------------------------------
NTSTATUS __stdcall EnumerateValue(HANDLE KeyHandle, ULONG Index, PVOID KeyValueInformation, ULONG KeyValueInformationLength, int a5)
{
  PVOID v5; // edi@1
  NTSTATUS v6; // eax@1
  NTSTATUS v7; // ebx@1

  v5 = KeyValueInformation;
  v6 = NtEnumerateValueKey(
         KeyHandle,
         Index,
         0,
         KeyValueInformation,
         KeyValueInformationLength,
         (PULONG)&KeyValueInformation);
  v7 = v6;
  if ( a5 && v6 == -2147483643 )
  {
    v5 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, (ULONG)KeyValueInformation);
    if ( !v5 )
      return -1073741801;
    v7 = NtEnumerateValueKey(KeyHandle, Index, 0, v5, (ULONG)KeyValueInformation, (PULONG)&KeyValueInformation);
    if ( v7 >= 0 )
      goto LABEL_8;
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v5);
  }
  if ( v7 >= 0 )
  {
LABEL_8:
    if ( a5 )
      *(_DWORD *)a5 = v5;
  }
  return v7;
}

//----- (77E90EC5) --------------------------------------------------------
NTSTATUS __stdcall ValStateUpdate(ULONG Index)
{
  ULONG v1; // esi@1
  void *v2; // ST04_4@1
  void *v3; // ST00_4@1
  NTSTATUS result; // eax@1
  int v5; // edi@2
  PVOID v6; // edi@4
  PVOID v7; // eax@7
  ULONG v8; // ecx@7
  void *v9; // ecx@11
  int v10; // ecx@11
  int v11; // ebx@11
  unsigned int v12; // eax@17
  int v13; // ecx@19
  HANDLE KeyHandle; // [sp+8h] [bp-20h]@11
  int Size; // [sp+Ch] [bp-1Ch]@6
  int v16; // [sp+10h] [bp-18h]@1
  unsigned int v17; // [sp+14h] [bp-14h]@12
  int v18; // [sp+18h] [bp-10h]@1
  int v19; // [sp+1Ch] [bp-Ch]@1
  PVOID Address; // [sp+20h] [bp-8h]@3
  int v21; // [sp+24h] [bp-4h]@2
  ULONG Indexa; // [sp+30h] [bp+8h]@6
  unsigned int Indexb; // [sp+30h] [bp+8h]@12
  ULONG Indexc; // [sp+30h] [bp+8h]@19

  v1 = Index;
  v2 = *(void **)(Index + 8);
  v19 = 0;
  v3 = *(void **)(Index + 4);
  v18 = 0;
  v16 = 0;
  *(_DWORD *)(Index + 16) = 0;
  result = GetFixedKeyInfo(v3, v2, (int)&v19, (int)&v18, 0, 0, (int)&v16);
  if ( result >= 0 )
  {
    v5 = v18 + v19;
    v21 = v18 + v19;
    if ( v18 + v19 )
    {
      Address = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 8 * v5);
      if ( !Address )
        return -1073741801;
      v6 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, 4 * v5);
      if ( !v6 )
      {
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        return -1073741801;
      }
      memset(v6, 0, 4 * v21);
      Indexa = 0;
      Size = v16 + 16;
      if ( v21 )
      {
        while ( 1 )
        {
          v7 = RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Size);
          v8 = Indexa;
          *((_DWORD *)v6 + Indexa) = v7;
          if ( !v7 )
            break;
          ++Indexa;
          if ( v8 + 1 >= v21 )
            goto LABEL_9;
        }
        v13 = Indexa - 1;
        Indexc = v13;
        if ( v13 )
        {
          while ( 1 )
          {
            RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *((PVOID *)v6 + v13));
            --Indexc;
            if ( !Indexc )
              break;
            v13 = Indexc;
          }
        }
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, Address);
        return -1073741801;
      }
LABEL_9:
      if ( *(_DWORD *)(v1 + 24) )
        RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, *(PVOID *)(v1 + 24));
      v9 = *(void **)(v1 + 4);
      *(_DWORD *)(v1 + 24) = Address;
      KeyHandle = v9;
      v10 = v19;
      v11 = 0;
      for ( Address = (PVOID)1; ; Address = 0 )
      {
        v17 = v10;
        for ( Indexb = 0; Indexb < v17; ++Indexb )
        {
          if ( EnumerateValue(KeyHandle, Indexb, *((PVOID *)v6 + v11), Size, 0) >= 0 )
          {
            **((_DWORD **)v6 + v11) = Indexb;
            *(_DWORD *)(*((_DWORD *)v6 + v11) + 4) = Address;
            if ( ValStateAddValueToSortedValues((int)v6, v11) )
              ++v11;
          }
        }
        v12 = 0;
        if ( !Address )
          break;
        KeyHandle = *(HANDLE *)(v1 + 8);
        v10 = v18;
      }
      *(_DWORD *)(v1 + 16) = v11;
      if ( (unsigned int)v11 > 0 )
      {
        do
        {
          *(_DWORD *)(*(_DWORD *)(v1 + 24) + 8 * v12) = **((_DWORD **)v6 + v12);
          *(_DWORD *)(*(_DWORD *)(v1 + 24) + 8 * v12 + 4) = *(_DWORD *)(*((_DWORD *)v6 + v12) + 4);
          ++v12;
        }
        while ( v12 < *(_DWORD *)(v1 + 16) );
      }
      ValStateReleaseValues(v6, v21);
    }
    result = 0;
  }
  return result;
}

//----- (77E910E4) --------------------------------------------------------
int __stdcall BasepSxsOverrideStreamToMessageStream(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@1

  *(_BYTE *)a2 = 1;
  *(_BYTE *)(a2 + 1) = 3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 8) = v2;
  *(_BYTE *)(a2 + 2) = 2;
  *(_QWORD *)(a2 + 24) = *(_DWORD *)(a1 + 8);
  result = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 32) = result;
  return result;
}

//----- (77E91128) --------------------------------------------------------
NTSTATUS __stdcall SetFilePointerFromBegin(HANDLE FileHandle, int a2)
{
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-10h]@1
  int FileInformation; // [sp+Ch] [bp-8h]@1
  int v5; // [sp+10h] [bp-4h]@1

  v5 = 0;
  FileInformation = a2;
  return NtSetInformationFile(FileHandle, &IoStatusBlock, &FileInformation, 8u, FilePositionInformation);
}

//----- (77E9115C) --------------------------------------------------------
NTSTATUS __stdcall ReadFileSync(HANDLE FileHandle, PVOID Buffer, ULONG Length, int a4)
{
  NTSTATUS result; // eax@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+4h] [bp-8h]@1

  result = NtReadFile(FileHandle, 0, 0, 0, &IoStatusBlock, Buffer, Length, 0, 0);
  if ( result == 259 )
    result = NtWaitForSingleObject(FileHandle, 0, 0);
  if ( result < 0 )
  {
    if ( result == -1073741807 )
    {
      if ( a4 )
        *(_DWORD *)a4 = 0;
      return result;
    }
    if ( (result & 0xC0000000) != 0x80000000 )
      return result;
  }
  if ( a4 )
    *(_DWORD *)a4 = IoStatusBlock.Information;
  return result;
}

//----- (77E911CA) --------------------------------------------------------
NTSTATUS __stdcall BasepSxsCreateResourceStreamFromFileHandle(int a1, ULONG Length, PHANDLE FileHandle, int a4)
{
  PHANDLE v4; // esi@1
  NTSTATUS v5; // eax@2
  NTSTATUS v6; // ebx@2
  int v7; // ST24_4@16
  void *v8; // ST20_4@16
  ULONG v9; // edx@18
  int v10; // eax@20
  int v11; // ecx@20
  PHANDLE v12; // ecx@20
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-44h]@2
  int v15; // [sp+24h] [bp-2Ch]@1
  ULONG v16; // [sp+28h] [bp-28h]@1
  int v17; // [sp+2Ch] [bp-24h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+30h] [bp-20h]@2
  LARGE_INTEGER SectionSize; // [sp+38h] [bp-18h]@1
  ULONG ViewSize; // [sp+40h] [bp-10h]@1
  int v21; // [sp+44h] [bp-Ch]@1
  int v22; // [sp+48h] [bp-8h]@1
  PVOID BaseAddress; // [sp+4Ch] [bp-4h]@1

  v4 = FileHandle;
  v15 = 24;
  v16 = Length;
  v17 = 0;
  SectionSize = 0i64;
  v22 = 0;
  Length = 0;
  v21 = 0;
  BaseAddress = 0;
  ViewSize = 0;
  if ( *FileHandle
    || (ObjectAttributes.Length = 24,
        ObjectAttributes.ObjectName = *(PUNICODE_STRING *)(a1 + 4),
        ObjectAttributes.RootDirectory = 0,
        ObjectAttributes.Attributes = 64,
        ObjectAttributes.SecurityDescriptor = 0,
        ObjectAttributes.SecurityQualityOfService = 0,
        v5 = NtOpenFile(FileHandle, 0x120089u, &ObjectAttributes, &IoStatusBlock, 5u, 0x60u),
        v6 = v5,
        v5 >= 0) )
  {
    v6 = LdrResSearchResource(*v4, &v15, 3, 34832, &v22, &Length, 0, 0);
    if ( v6 >= 0 )
    {
      if ( Length <= 0x800000 )
      {
        SectionSize.s.LowPart = Length;
        FileHandle = v4 + 2;
        v6 = NtCreateSection(v4 + 2, 6u, 0, &SectionSize, 4u, 0x8000000u, 0);
        if ( v6 >= 0 )
        {
          v6 = NtMapViewOfSection(*FileHandle, v4[1], &BaseAddress, 0, 0, 0, &ViewSize, ViewUnmap, 0, 4u);
          if ( v6 >= 0 )
          {
            v7 = v22;
            v8 = *v4;
            *((_QWORD *)v4 + 2) = (signed int)BaseAddress;
            v6 = SetFilePointerFromBegin(v8, v7);
            if ( v6 >= 0 )
            {
              v6 = ReadFileSync(*v4, v4[4], Length, (int)&v21);
              if ( v6 >= 0 )
              {
                v9 = Length;
                if ( v21 == Length )
                {
                  v10 = a4;
                  *(_DWORD *)(a4 + 12) = *v4;
                  *(_BYTE *)(v10 + 1) = 1;
                  *(_BYTE *)v10 = 1;
                  v11 = *(_DWORD *)a1;
                  *(_DWORD *)(v10 + 4) = **(_DWORD **)a1;
                  *(_DWORD *)(v10 + 8) = *(_DWORD *)(v11 + 4);
                  v12 = FileHandle;
                  *(_BYTE *)(v10 + 2) = 3;
                  *(_DWORD *)(v10 + 16) = *v12;
                  *(_DWORD *)(v10 + 24) = 0;
                  *(_DWORD *)(v10 + 28) = 0;
                  *(_DWORD *)(v10 + 32) = v9;
                  v6 = 0;
                }
                else
                {
                  v6 = -1073741701;
                }
              }
            }
          }
        }
      }
      else
      {
        v6 = -1072365534;
      }
    }
  }
  else if ( v5 != -1073741772
         && v5 != -1073741687
         && v5 != -1073741686
         && v5 != -1073741685
         && v5 != -1073741308
         && v5 != -1072365566
         && v5 != -1073741809 )
  {
    DbgPrintEx(
      0x33u,
      0,
      "SXS: %s() NtOpenFile(%wZ) failed. Status = 0x%x\n",
      "BasepSxsCreateResourceStreamFromFileHandle",
      ObjectAttributes.ObjectName,
      v5);
  }
  return v6;
}
// 77E26B04: using guessed type int __stdcall LdrResSearchResource(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E913E8) --------------------------------------------------------
BOOL __stdcall SXSEnumProc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam)
{
  HRSRC v4; // eax@1
  HRSRC v5; // ebx@1
  const char *v6; // esi@2
  DWORD v7; // eax@2
  int v8; // ebx@2
  unsigned int v9; // edi@7
  signed int v11; // [sp+8h] [bp-4h]@1

  v11 = 0;
  v4 = FindResourceW(hModule, lpName, (LPCWSTR)0x18);
  v5 = v4;
  if ( v4 )
  {
    v6 = (const char *)LoadResource(hModule, v4);
    v7 = SizeofResource(hModule, v5);
    v8 = (int)&v6[v7];
    if ( (unsigned int)v6 >= (unsigned int)hModule && v8 >= (unsigned int)hModule && v7 )
    {
      while ( (unsigned int)v6 < v8 && !v11 )
      {
        v9 = 0;
        do
        {
          if ( v11 )
            break;
          if ( (unsigned int)&v6[SXSManifestInstallers[v9]] < v8
            && !_strnicmp(v6, (&off_77E3CB3C)[v9 * 4], SXSManifestInstallers[v9]) )
          {
            *(_DWORD *)lParam = 1;
            v11 = 1;
          }
          v9 += 3;
        }
        while ( v9 < 24 );
        ++v6;
      }
    }
  }
  return v11 == 0;
}
// 77E3CB38: using guessed type int SXSManifestInstallers[];
// 77E3CB3C: using guessed type char *off_77E3CB3C;

//----- (77E91483) --------------------------------------------------------
PVOID __stdcall WerpGetLastError()
{
  return NtCurrentTeb()->Reserved2[0];
}

//----- (77E914E9) --------------------------------------------------------
signed int StringCchPrintfW(wchar_t *Dest, unsigned int a2, wchar_t *Format, ...)
{
  signed int result; // eax@1
  unsigned int v4; // esi@5
  signed int v5; // ebx@5
  int v6; // eax@5
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, Format);
  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = a2 - 1;
    v5 = 0;
    v6 = _vsnwprintf(Dest, a2 - 1, Format, va);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147024774;
    }
    else if ( v6 != v4 )
    {
      goto LABEL_11;
    }
    Dest[v4] = 0;
LABEL_11:
    result = v5;
  }
  return result;
}

//----- (77E91547) --------------------------------------------------------
signed int __stdcall GetCrashVerticalPaths(HANDLE hProcess, void *a2, wchar_t *Dest, unsigned __int32 a4, wchar_t *a5, unsigned __int32 a6, LPWSTR lpBuffer, UINT uSize)
{
  signed int v8; // esi@1
  int v9; // ebx@1
  UINT v10; // eax@4
  int v11; // eax@9
  NTSTATUS v12; // eax@12
  char ProcessInformation; // [sp+Ch] [bp-1Ch]@12
  int v15; // [sp+1Ch] [bp-Ch]@14
  BOOL Wow64Process; // [sp+24h] [bp-4h]@1

  v8 = -2147467259;
  Wow64Process = 0;
  v9 = WerpIsProtectedProcess(hProcess);
  if ( !IsWow64Process(hProcess, &Wow64Process) )
  {
    Wow64Process = 0;
    DbgPrintOut(0, "IsWow64Process failed");
  }
  if ( Wow64Process )
    v10 = RegisterConsoleIME((int)lpBuffer, uSize);
  else
    v10 = GetSystemDirectoryW(lpBuffer, uSize);
  if ( v10 && v10 <= uSize && *lpBuffer )
  {
    v11 = (int)L"WerFaultSecure.exe";
    if ( !v9 )
      v11 = (int)L"WerFault.exe";
    v8 = StringCchPrintfW(Dest, a4, L"%s\\%s", lpBuffer, v11);
    if ( v8 < 0 )
      goto LABEL_22;
    v12 = NtQueryInformationProcess(hProcess, 0, &ProcessInformation, 0x18u, 0);
    if ( v12 < 0 )
    {
      v8 = v12 | 0x10000000;
      DbgPrintOut(0, "NtQueryInformationProcess failed with 0x%x", v12 | 0x10000000);
      return v8;
    }
    v8 = StringCchPrintfW(a5, a6, L"%s -u -p %d -s %I64d", Dest, v15, a2, (unsigned __int64)(signed int)a2 >> 32);
    if ( v8 < 0 )
    {
LABEL_22:
      DbgPrintOut(0, "StringCchPrintf failed with 0x%x", v8);
      return v8;
    }
    v8 = 0;
  }
  else
  {
    DbgPrintOut(0, "GetSystemWindowsDirectory failed or the size was not adequate");
  }
  return v8;
}
// 77E91720: using guessed type wchar_t aWerfault_exe[13];
// 77E9173C: using guessed type wchar_t aWerfaultsecure[19];

//----- (77E9177F) --------------------------------------------------------
int __stdcall StartCrashVertical(HANDLE ProcessHandle, void *a2, void **a3)
{
  signed int v3; // eax@1
  int v4; // eax@3
  PVOID v5; // eax@4
  HANDLE v6; // ST24_4@7
  struct _STARTUPINFOW StartupInfo; // [sp+Ch] [bp-228h]@1
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+50h] [bp-1E4h]@1
  void **v10; // [sp+60h] [bp-1D4h]@1
  UINT uMode; // [sp+64h] [bp-1D0h]@3
  PVOID v12; // [sp+68h] [bp-1CCh]@1
  void *v13; // [sp+6Ch] [bp-1C8h]@1
  WCHAR CommandLine; // [sp+70h] [bp-1C4h]@1
  WCHAR ApplicationName; // [sp+170h] [bp-C4h]@1
  WCHAR CurrentDirectory; // [sp+1F0h] [bp-44h]@1

  v13 = a2;
  v10 = a3;
  memset(&StartupInfo.lpReserved, 0, 0x40u);
  ProcessInformation.hProcess = 0;
  ProcessInformation.hThread = 0;
  ProcessInformation.dwProcessId = 0;
  ProcessInformation.dwThreadId = 0;
  CurrentDirectory = 0;
  ApplicationName = 0;
  CommandLine = 0;
  StartupInfo.wShowWindow = 0;
  StartupInfo.cb = 68;
  StartupInfo.dwFlags = 1;
  v3 = GetCrashVerticalPaths(ProcessHandle, a2, &ApplicationName, 0x40u, &CommandLine, 0x80u, &CurrentDirectory, 0x20u);
  v12 = (PVOID)v3;
  if ( v3 >= 0 )
  {
    uMode = SetErrorMode(1u);
    v13 = (void *)RtlGetCurrentTransaction();
    RtlSetCurrentTransaction(0);
    v4 = WerpIsProtectedProcess(ProcessHandle);
    if ( CreateProcessW(
           &ApplicationName,
           &CommandLine,
           0,
           0,
           1,
           v4 != 0 ? 0x40000 : 0,
           0,
           &CurrentDirectory,
           &StartupInfo,
           &ProcessInformation) )
    {
      SetErrorMode(uMode);
      v6 = ProcessInformation.hThread;
      *v10 = ProcessInformation.hProcess;
      NtClose(v6);
      v12 = 0;
    }
    else
    {
      DbgPrintOut(0, "Failed to create the process %S", &ApplicationName);
      v5 = WerpGetLastError();
      if ( (signed int)v5 > 0 )
        v5 = (PVOID)((unsigned __int16)v5 | 0x80070000);
      v12 = v5;
      SetErrorMode(uMode);
    }
    if ( v13 )
      RtlSetCurrentTransaction(v13);
  }
  else
  {
    DbgPrintOut(0, "Failed to get the paths for the crash vertical. Error was 0x%x", v3);
  }
  return (int)v12;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);

//----- (77E91994) --------------------------------------------------------
const unsigned __int16 *__stdcall WerpPathTail(LPCWSTR lpString)
{
  const unsigned __int16 *result; // eax@2
  unsigned int v2; // eax@3
  __int16 v3; // cx@4

  if ( lpString )
  {
    v2 = (unsigned int)&lpString[lstrlenW(lpString)];
    while ( v2 > (unsigned int)lpString )
    {
      v2 -= 2;
      v3 = *(_WORD *)v2;
      if ( *(_WORD *)v2 == 92 || v3 == 47 || v3 == 58 )
        goto LABEL_9;
    }
    v2 -= 2;
LABEL_9:
    result = (const unsigned __int16 *)(v2 + 2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E919DA) --------------------------------------------------------
signed int __stdcall ERROR_HR_FROM_WIN32(__int32 a1)
{
  signed int result; // eax@1
  bool v2; // sf@1

  result = a1;
  v2 = a1 < 0;
  if ( a1 > 0 )
  {
    result = (unsigned __int16)a1 | 0x80070000;
    v2 = result < 0;
  }
  if ( !v2 )
    result = -2147467259;
  return result;
}

//----- (77E91A02) --------------------------------------------------------
signed int __stdcall StringCchVPrintfA(char *Dest, unsigned int a2, const char *Format, va_list Args)
{
  signed int result; // eax@1
  unsigned int v5; // esi@5
  signed int v6; // ebx@5
  int v7; // eax@5

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v5 = a2 - 1;
    v6 = 0;
    v7 = _vsnprintf(Dest, a2 - 1, Format, Args);
    if ( v7 < 0 || v7 > v5 )
    {
      Dest[v5] = 0;
      v6 = -2147024774;
    }
    else if ( v7 == v5 )
    {
      Dest[v5] = 0;
    }
    result = v6;
  }
  return result;
}

//----- (77E91A61) --------------------------------------------------------
void DbgPrintOut(int a1, char *Format, ...)
{
  const CHAR *v2; // eax@5
  char Dest; // [sp+0h] [bp-204h]@9
  va_list va; // [sp+214h] [bp+10h]@1

  va_start(va, Format);
  if ( a1 )
  {
    if ( a1 != 1 )
    {
      if ( a1 == 2 )
      {
        v2 = "Info - ";
        goto LABEL_9;
      }
      if ( a1 != 3 )
      {
        v2 = "Print - ";
        goto LABEL_9;
      }
    }
    v2 = "Warning - ";
  }
  else
  {
    v2 = "Error - ";
  }
LABEL_9:
  OutputDebugStringA(v2);
  if ( StringCchVPrintfA(&Dest, 0x200u, Format, va) < 0 )
    OutputDebugStringA("Error in logging");
  else
    OutputDebugStringA(&Dest);
  OutputDebugStringA("\r\n");
}

//----- (77E91B32) --------------------------------------------------------
int __stdcall WerpIsProtectedProcess(HANDLE ProcessHandle)
{
  NTSTATUS v2; // eax@3
  int ProcessInformation; // [sp+8h] [bp-20h]@1
  char v4; // [sp+Ch] [bp-1Ch]@1
  int v5; // [sp+24h] [bp-4h]@5

  ProcessInformation = 0;
  memset(&v4, 0, 0x1Cu);
  if ( !ProcessHandle )
    return 0;
  ProcessInformation = 32;
  v2 = NtQueryInformationProcess(ProcessHandle, 0, &ProcessInformation, 0x20u, 0);
  if ( v2 < 0 )
  {
    DbgPrintOut(0, "NtQueryInformationProcess failed with status: 0x%x", v2);
    return 0;
  }
  return v5 & 1;
}

//----- (77E91BC4) --------------------------------------------------------
int __stdcall WerpIsProcessInAeDebugExclusionList(HANDLE ProcessHandle)
{
  int v1; // edi@1
  NTSTATUS v2; // eax@1
  NTSTATUS v3; // eax@8
  __int16 ProcessInformation; // [sp+Ch] [bp-25Ch]@1
  char Dst; // [sp+Eh] [bp-25Ah]@1
  LPCWSTR lpString; // [sp+10h] [bp-258h]@3
  LSA_UNICODE_STRING ValueName; // [sp+220h] [bp-48h]@8
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+228h] [bp-40h]@5
  PCWSTR SourceString; // [sp+240h] [bp-28h]@3
  int v11; // [sp+244h] [bp-24h]@1
  ULONG ResultLength; // [sp+248h] [bp-20h]@1
  HANDLE KeyHandle; // [sp+24Ch] [bp-1Ch]@1
  int KeyValueInformation; // [sp+250h] [bp-18h]@1
  int v15; // [sp+254h] [bp-14h]@1
  int v16; // [sp+258h] [bp-10h]@1
  int v17; // [sp+25Ch] [bp-Ch]@1
  int v18; // [sp+260h] [bp-8h]@1

  ProcessInformation = 0;
  KeyHandle = 0;
  memset(&Dst, 0, 0x212u);
  KeyValueInformation = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v11 = 0;
  v18 = 0;
  ResultLength = 0;
  v1 = WerpIsProtectedProcess(ProcessHandle);
  v2 = NtQueryInformationProcess(ProcessHandle, ProcessImageFileNameWin32, &ProcessInformation, 0x210u, 0);
  if ( (v2 & 0xC0000000) == -1073741824 )
  {
    DbgPrintOut(0, "NtQueryInformationProcess failed 0x%x", v2);
  }
  else
  {
    SourceString = WerpPathTail(lpString);
    if ( SourceString )
    {
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E91D2C;
      if ( !v1 )
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E91D24;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      if ( NtOpenKey(&KeyHandle, 1u, &ObjectAttributes) >= 0 )
      {
        ResultLength = 0;
        v3 = RtlInitUnicodeStringEx(&ValueName, SourceString);
        if ( (v3 & 0xC0000000) == -1073741824 )
        {
          DbgPrintOut(0, "RtlInitUnicodeStringEx returned 0x%x", v3);
        }
        else if ( NtQueryValueKey(
                    KeyHandle,
                    &ValueName,
                    KeyValuePartialInformation,
                    &KeyValueInformation,
                    0x14u,
                    &ResultLength) >= 0
               && v15 == 4
               && v17 )
        {
          v11 = 1;
        }
      }
    }
    else
    {
      DbgPrintOut(0, "WerpPathTail returned NULL");
    }
  }
  if ( KeyHandle )
    CloseHandle(KeyHandle);
  return v11;
}
// 77E91D24: using guessed type int dword_77E91D24;
// 77E91D2C: using guessed type int dword_77E91D2C;

//----- (77E91DA3) --------------------------------------------------------
int __stdcall WerpGetDebugger(HANDLE ProcessHandle, unsigned __int16 *a2, unsigned int a3, int a4, int a5)
{
  ULONG v5; // edi@4
  LPVOID v6; // ebx@4
  NTSTATUS v7; // eax@10
  UNICODE_STRING *v8; // eax@13
  int v9; // esi@17
  signed int v10; // eax@17
  int result; // eax@38
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-30h]@1
  int v13; // [sp+20h] [bp-18h]@1
  ULONG KeyValueInformationLength; // [sp+24h] [bp-14h]@4
  int v15; // [sp+28h] [bp-10h]@1
  ULONG ResultLength; // [sp+2Ch] [bp-Ch]@1
  int v17; // [sp+30h] [bp-8h]@4
  HANDLE KeyHandle; // [sp+34h] [bp-4h]@1
  int v19; // [sp+44h] [bp+Ch]@5

  ObjectAttributes.Length = 0;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.Attributes = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  KeyHandle = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v13 = 0;
  ResultLength = 0;
  v15 = 0;
  if ( ProcessHandle && a2 && a3 - 293 <= 0x7FFFFED2 )
  {
    v5 = 2 * a3 + 16;
    v17 = WerpIsProtectedProcess(ProcessHandle);
    KeyValueInformationLength = v5;
    v6 = VirtualAlloc(0, v5, 0x1000u, 4u);
    if ( v6 )
    {
      if ( a4 )
        *(_DWORD *)a4 = 0;
      *a2 = 0;
      ObjectAttributes.Length = 24;
      ObjectAttributes.RootDirectory = 0;
      ObjectAttributes.Attributes = 64;
      ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E91FB0;
      if ( !v17 )
        ObjectAttributes.ObjectName = (PUNICODE_STRING)&dword_77E91FA8;
      ObjectAttributes.SecurityDescriptor = 0;
      ObjectAttributes.SecurityQualityOfService = 0;
      v7 = NtOpenKey(&KeyHandle, 1u, &ObjectAttributes);
      if ( v7 >= 0 )
      {
        if ( v17 )
        {
          v8 = (UNICODE_STRING *)&dword_77E91FC0;
          v15 = 1;
        }
        else
        {
          v8 = &stru_77E91FB8;
        }
        if ( NtQueryValueKey(KeyHandle, v8, KeyValuePartialInformation, v6, v5, &ResultLength) < 0
          || *((_DWORD *)v6 + 1) != 1 )
        {
          v19 = -2147023728;
        }
        else
        {
          v9 = (int)((char *)v6 + 12);
          v10 = StringCchCopyW(a2, a3, (const unsigned __int16 *)v6 + 6);
          v19 = v10;
          if ( v10 >= 0 )
          {
            if ( v17 )
            {
              *(_WORD *)v9 = 0;
              if ( NtQueryValueKey(
                     KeyHandle,
                     &stru_77E91FC8,
                     KeyValuePartialInformation,
                     v6,
                     KeyValueInformationLength,
                     &ResultLength) >= 0
                && *((_DWORD *)v6 + 1) == 4 )
                v15 = *(_BYTE *)v9 == 0;
            }
            *(_WORD *)v9 = 0;
            if ( NtQueryValueKey(
                   KeyHandle,
                   &stru_77E91FD0,
                   KeyValuePartialInformation,
                   v6,
                   KeyValueInformationLength,
                   &ResultLength) >= 0
              && *((_DWORD *)v6 + 1) == 1
              && *(_WORD *)v9 == 49 )
              v13 = WerpIsProcessInAeDebugExclusionList(ProcessHandle) == 0;
            v19 = 0;
          }
          else
          {
            DbgPrintOut(0, "Stringcchcopy failed while copying the debugger path 0x%x", v10);
          }
        }
      }
      else
      {
        v19 = v7 | 0x10000000;
      }
    }
    else
    {
      v19 = -2147024882;
    }
    if ( a4 )
      *(_DWORD *)a4 = v13;
    if ( a5 )
      *(_DWORD *)a5 = v15;
    if ( KeyHandle )
    {
      CloseHandle(KeyHandle);
      KeyHandle = 0;
    }
    if ( v6 )
      VirtualFree(v6, 0, 0x8000u);
    result = v19;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}
// 77E91FA8: using guessed type int dword_77E91FA8;
// 77E91FB0: using guessed type int dword_77E91FB0;
// 77E91FC0: using guessed type int dword_77E91FC0;

//----- (77E92017) --------------------------------------------------------
signed int __stdcall WerpLaunchAeDebug(void *a1, void *a2, char *a3, const void *a4, WCHAR *a5, int a6)
{
  DWORD v6; // eax@2
  signed int v7; // edi@3
  HANDLE v8; // ST14_4@7
  HANDLE v9; // ST10_4@7
  HANDLE v10; // eax@7
  int v11; // eax@15
  LPVOID v12; // eax@16
  int *v13; // eax@19
  PWSTR v14; // edi@22
  wchar_t *v15; // esi@24
  signed int v16; // eax@24
  signed int v17; // eax@27
  NTSTATUS v18; // eax@33
  struct _STARTUPINFOW StartupInfo; // [sp+Ch] [bp-3F0h]@1
  unsigned __int16 SystemInformation; // [sp+50h] [bp-3ACh]@11
  struct _SECURITY_ATTRIBUTES EventAttributes; // [sp+5Ch] [bp-3A0h]@7
  struct _PROCESS_INFORMATION ProcessInformation; // [sp+68h] [bp-394h]@1
  int v24; // [sp+78h] [bp-384h]@5
  HANDLE Handles; // [sp+7Ch] [bp-380h]@32
  PWSTR Path; // [sp+80h] [bp-37Ch]@1
  DWORD v27; // [sp+84h] [bp-378h]@1
  SIZE_T NumberOfBytesWritten; // [sp+88h] [bp-374h]@17
  HANDLE v29; // [sp+8Ch] [bp-370h]@9
  const void *v30; // [sp+90h] [bp-36Ch]@1
  HANDLE hSourceHandle; // [sp+94h] [bp-368h]@1
  int *v32; // [sp+98h] [bp-364h]@1
  HANDLE hObject; // [sp+9Ch] [bp-360h]@1
  HANDLE Process; // [sp+A0h] [bp-35Ch]@1
  HANDLE TargetHandle; // [sp+A4h] [bp-358h]@1
  LPVOID lpBaseAddress; // [sp+A8h] [bp-354h]@1
  LPWSTR lpCommandLine; // [sp+ACh] [bp-350h]@1
  int Buffer; // [sp+B0h] [bp-34Ch]@15
  int v39; // [sp+B4h] [bp-348h]@15
  DWORD v40; // [sp+B8h] [bp-344h]@13
  int v41; // [sp+BCh] [bp-340h]@15
  int v42; // [sp+C0h] [bp-33Ch]@15
  int v43; // [sp+C4h] [bp-338h]@15
  char *v44; // [sp+C8h] [bp-334h]@17
  int v45; // [sp+CCh] [bp-330h]@17
  char *v46; // [sp+D0h] [bp-32Ch]@17
  int v47; // [sp+D4h] [bp-328h]@17
  char v48; // [sp+D8h] [bp-324h]@17
  char v49[720]; // [sp+128h] [bp-2D4h]@17

  Process = a1;
  hSourceHandle = a2;
  v30 = a4;
  Path = a5;
  TargetHandle = 0;
  StartupInfo.cb = 0;
  memset(&StartupInfo.lpReserved, 0, 0x40u);
  ProcessInformation.hProcess = 0;
  ProcessInformation.hThread = 0;
  ProcessInformation.dwProcessId = 0;
  ProcessInformation.dwThreadId = 0;
  hObject = 0;
  lpCommandLine = 0;
  lpBaseAddress = 0;
  v32 = 0;
  v27 = GetProcessId(a1);
  if ( !v27 )
  {
    v6 = GetLastError();
    if ( (signed int)v6 > 0 )
      v6 = (unsigned __int16)v6 | 0x80070000;
    v7 = v6;
    goto LABEL_41;
  }
  v24 = v27 == GetCurrentProcessId();
  lpCommandLine = (LPWSTR)VirtualAlloc(0, 0x4C0u, 0x1000u, 4u);
  if ( !lpCommandLine )
  {
    v7 = -2147024882;
    goto LABEL_41;
  }
  EventAttributes.bInheritHandle = 1;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.nLength = 12;
  v8 = GetCurrentProcess();
  v9 = hSourceHandle;
  v10 = GetCurrentProcess();
  if ( !DuplicateHandle(v10, v9, v8, &TargetHandle, 0, 1, 2u) )
    TargetHandle = 0;
  v29 = CreateEventW(&EventAttributes, 1, 0, 0);
  if ( v29 && a3 && NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)1, &SystemInformation, 0xCu, 0) >= 0 )
  {
    if ( hSourceHandle )
      v40 = GetThreadId(hSourceHandle);
    else
      v40 = 0;
    v39 = SystemInformation;
    v11 = *((_DWORD *)a3 + 3);
    Buffer = 40;
    v41 = 0;
    v42 = v11;
    v43 = 0;
    if ( v24 )
    {
      v46 = (char *)v30;
      v44 = a3;
      v45 = 0;
      v47 = 0;
      v13 = &Buffer;
      goto LABEL_21;
    }
    v12 = VirtualAllocEx(Process, 0, 0x348u, 0x1000u, 4u);
    lpBaseAddress = v12;
    if ( v12 )
    {
      qmemcpy(&v48, a3, 0x50u);
      qmemcpy(v49, v30, 0x2CCu);
      NumberOfBytesWritten = (_BYTE *)v12 - (_BYTE *)&Buffer;
      v46 = &v49[(_BYTE *)v12 - (_BYTE *)&Buffer];
      v44 = &v48 + (_BYTE *)v12 - (_BYTE *)&Buffer;
      v45 = 0;
      v47 = 0;
      if ( WriteProcessMemory(Process, lpBaseAddress, &Buffer, 0x348u, &NumberOfBytesWritten) )
      {
        if ( NumberOfBytesWritten == 840 )
        {
          v13 = (int *)lpBaseAddress;
LABEL_21:
          v32 = v13;
          goto LABEL_22;
        }
      }
    }
  }
LABEL_22:
  v14 = Path;
  if ( *Path == 34 || RtlDetermineDosPathNameType_U(Path) != 5 )
  {
    v15 = v14;
LABEL_27:
    v17 = StringCchPrintfW(lpCommandLine, 0x13Bu, v15, v27, v29, v32);
    v7 = v17;
    if ( v17 >= 0 )
    {
      hObject = (HANDLE)RtlGetCurrentTransaction();
      RtlSetCurrentTransaction(0);
      StartupInfo.cb = 68;
      StartupInfo.lpDesktop = (LPWSTR)&Src;
      if ( CreateProcessW(0, lpCommandLine, 0, 0, 1, a6 != 0 ? 0x40000 : 0, 0, 0, &StartupInfo, &ProcessInformation)
        && v29 )
      {
        Handles = v29;
        Path = (PWSTR)ProcessInformation.hProcess;
        do
        {
          do
            v18 = NtWaitForMultipleObjects(2u, &Handles, WaitAny, 1u, 0);
          while ( v18 == 192 );
        }
        while ( v18 == 257 );
        if ( v18 == 1 )
        {
          v7 = -2147418113;
        }
        else if ( !v18 )
        {
          v7 = 0;
        }
      }
    }
    else
    {
      DbgPrintOut(0, "StringCchPrintf failed while printng the debugger commandline with 0x%x", v17);
    }
    goto LABEL_39;
  }
  v15 = lpCommandLine + 315;
  v16 = StringCchPrintfW(lpCommandLine + 315, 0x125u, L"%s\\system32\\%s", 2147352624, v14);
  v7 = v16;
  if ( v16 >= 0 )
    goto LABEL_27;
  DbgPrintOut(0, "StringCchPrintf failed while printing the debugger path with 0x%x", v16);
LABEL_39:
  if ( lpBaseAddress )
    VirtualFreeEx(Process, lpBaseAddress, 0, 0x8000u);
LABEL_41:
  if ( TargetHandle )
  {
    CloseHandle(TargetHandle);
    TargetHandle = 0;
  }
  if ( (_DWORD)ProcessInformation.hProcess )
    CloseHandle(ProcessInformation.hProcess);
  if ( ProcessInformation.hThread )
    CloseHandle(ProcessInformation.hThread);
  if ( hObject )
  {
    RtlSetCurrentTransaction(hObject);
    CloseHandle(hObject);
  }
  if ( lpCommandLine )
    VirtualFree(lpCommandLine, 0, 0x8000u);
  return v7;
}
// 77E2D275: using guessed type int __stdcall RtlSetCurrentTransaction(_DWORD);
// 77E92017: using guessed type char var_324[80];
// 77E92017: using guessed type char var_2D4[720];

//----- (77E9254F) --------------------------------------------------------
signed int __stdcall GetNtdllFunction(LPCSTR lpProcName, void **a2)
{
  HMODULE v2; // eax@3
  __int32 v3; // eax@5
  signed int result; // eax@5
  FARPROC v5; // eax@6

  if ( a2 && lpProcName )
  {
    v2 = hModule;
    if ( (hModule || (v2 = GetModuleHandleW(L"ntdll.dll"), (hModule = v2) != 0))
      && (v5 = GetProcAddress(v2, lpProcName)) != 0 )
    {
      *a2 = v5;
      result = 0;
    }
    else
    {
      v3 = GetLastError();
      result = ERROR_HR_FROM_WIN32(v3);
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid parrams");
    result = -2147024809;
  }
  return result;
}

//----- (77E925E1) --------------------------------------------------------
int __stdcall WerpNtWow64QueryInformationProcess64(void *a1, enum _PROCESSINFOCLASS a2, void *a3, unsigned __int32 a4, unsigned __int32 *a5)
{
  signed int v5; // esi@1
  int result; // eax@2
  int v7; // esi@3
  void *v8; // [sp+4h] [bp-4h]@1

  v8 = 0;
  v5 = GetNtdllFunction("NtWow64QueryInformationProcess64", &v8);
  if ( v5 >= 0 )
  {
    v7 = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v8)(a1, a2, a3, a4, a5);
    if ( (v7 & 0xC0000000) == -1073741824 )
      DbgPrintOut(0, "NtWow64QueryInformationProcess64 failed with 0x%x", v7);
    result = v7 | 0x10000000;
  }
  else
  {
    DbgPrintOut(0, "Unable to get NtWow64QueryInformationProcess64");
    result = v5;
  }
  return result;
}

//----- (77E926DA) --------------------------------------------------------
int __stdcall WerpNtWow64ReadVirtualMemory64(void *a1, unsigned __int64 a2, void *a3, unsigned __int64 a4, unsigned __int64 *a5)
{
  signed int v5; // esi@1
  int result; // eax@2
  int v7; // esi@3
  void *v8; // [sp+4h] [bp-4h]@1

  v8 = 0;
  v5 = GetNtdllFunction("NtWow64ReadVirtualMemory64", &v8);
  if ( v5 >= 0 )
  {
    v7 = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v8)(
           a1,
           a2,
           HIDWORD(a2),
           a3,
           a4,
           HIDWORD(a4),
           a5);
    if ( (v7 & 0xC0000000) == -1073741824 )
      DbgPrintOut(0, "NtWow64ReadVirtualMemory64 failed with 0x%x", v7);
    result = v7 | 0x10000000;
  }
  else
  {
    DbgPrintOut(0, "Unable to get NtWow64ReadVirtualMemory64`");
    result = v5;
  }
  return result;
}

//----- (77E927C8) --------------------------------------------------------
signed int __stdcall _FindFileByPath(wchar_t *Str2, struct _WER_GATHER **a2, struct _WER_GATHER **a3)
{
  signed int result; // eax@2
  struct _PEB *v4; // eax@3
  PVOID v5; // esi@3
  int v6; // esi@5
  struct _WER_GATHER *v7; // edi@5
  const wchar_t *v8; // eax@8
  signed int v9; // [sp+14h] [bp-1Ch]@1

  v9 = -2147023728;
  if ( a2 )
  {
    v4 = WerpCurrentPeb();
    v5 = v4[1].Reserved9[8];
    if ( v5 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v4[1].Reserved9[8]) >= 0 )
    {
      v6 = *((_DWORD *)v5 + 538);
      v7 = 0;
      while ( 1 )
      {
        if ( !v6 )
          goto LABEL_13;
        if ( *(_DWORD *)(v6 + 8) == 2 )
        {
          v8 = (const wchar_t *)(v6 + *(_DWORD *)(v6 + 44));
          if ( v8 )
          {
            if ( !_wcsnicmp(v8, Str2, 0x104u) )
              break;
          }
        }
        v7 = (struct _WER_GATHER *)v6;
        v6 = *(_DWORD *)v6;
      }
      if ( a3 )
        *a3 = v7;
      *a2 = (struct _WER_GATHER *)v6;
      v9 = 0;
      if ( !v6 )
      {
LABEL_13:
        v9 = -2147023728;
        goto LABEL_16;
      }
    }
    else
    {
      DbgPrintOut(0, "PEB is not initialized");
    }
LABEL_16:
    result = v9;
  }
  else
  {
    DbgPrintOut(0, "_FindFileByPathInvalid args");
    result = -2147024809;
  }
  return result;
}

//----- (77E928E9) --------------------------------------------------------
signed int __stdcall WerpUnregisterFile(PCWSTR pwzFilePath)
{
  struct _PEB *v2; // ebx@5
  struct _WER_PEB_HEADER_BLOCK *v3; // esi@10
  struct _WER_GATHER *v4; // [sp+10h] [bp-24h]@1
  struct _WER_GATHER *v5; // [sp+14h] [bp-20h]@1
  int v6; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@10

  v4 = 0;
  v5 = 0;
  v6 = -2147467259;
  if ( !pwzFilePath )
  {
    DbgPrintOut(0, "Invalid args in %s", "WerpUnregisterFile");
    return -2147024809;
  }
  if ( !WerpCheckOkToRegister() )
  {
    DbgPrintOut(0, "Invalid state");
    return -2147019873;
  }
  v2 = WerpCurrentPeb();
  if ( !v2 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  ms_exc.registration.TryLevel = 0;
  v3 = (struct _WER_PEB_HEADER_BLOCK *)v2[1].Reserved9[8];
  if ( v3 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v2[1].Reserved9[8]) >= 0 )
  {
    v6 = _FindFileByPath((wchar_t *)pwzFilePath, &v4, &v5);
    if ( !v6 )
      v6 = _DeleteElement(v3, v4, v5);
  }
  else
  {
    DbgPrintOut(0, "PEB is not initialized");
  }
  ms_exc.registration.TryLevel = -2;
  RtlReleasePebLock();
  return v6;
}

//----- (77E92A19) --------------------------------------------------------
signed int __stdcall WerpRegisterFile(PCWSTR pwzFile, WER_REGISTER_FILE_TYPE regFileType, DWORD dwFlags)
{
  int v3; // esi@1
  signed int result; // eax@2
  unsigned int v5; // eax@7
  size_t v6; // ebx@7
  int v7; // edi@7
  int v8; // eax@7
  int v9; // eax@9
  struct _WER_HEAP_MAIN_HEADER *v10; // [sp+10h] [bp-24h]@7
  signed int v11; // [sp+18h] [bp-1Ch]@8

  v3 = 0;
  if ( WerpCheckOkToRegister() )
  {
    if ( pwzFile )
    {
      if ( WerpInitPEBStore() >= 0 )
      {
        WerpUnregisterFile(pwzFile);
        v5 = wcslen(pwzFile);
        v6 = 2 * v5 + 2;
        v7 = 2 * v5 + 50;
        v8 = WerpGetHeapHandle();
        v10 = (struct _WER_HEAP_MAIN_HEADER *)v8;
        if ( v8 )
        {
          v9 = WerpHeapAlloc((struct _WER_HEAP_MAIN_HEADER *)v8, v7);
          v3 = v9;
          if ( v9 )
          {
            memset((void *)v9, 0, v7);
            *(_DWORD *)(v3 + 8) = 2;
            *(_DWORD *)(v3 + 20) = dwFlags;
            *(_DWORD *)(v3 + 40) = 1;
            *(_DWORD *)(v3 + 12) = v7;
            *(_DWORD *)(v3 + 24) = regFileType;
            *(_DWORD *)(v3 + 44) = 48;
            v11 = StringCbCopyW((STRSAFE_LPWSTR)(v3 + *(_DWORD *)(v3 + 44)), v6, pwzFile);
            if ( v11 >= 0 )
              v11 = WerpAddGatherToPEB((struct _WER_GATHER *)v3);
          }
          else
          {
            DbgPrintOut(0, "OOM");
            v11 = -2147024882;
          }
        }
        else
        {
          DbgPrintOut(0, "Unable to get the heap handle");
          v11 = -2147467259;
        }
        if ( v11 < 0 )
        {
          if ( v3 )
            WerpHeapFree(v10, (void *)v3);
        }
        result = v11;
      }
      else
      {
        DbgPrintOut(0, "WerpInitPEBStore failed");
        result = -2147467259;
      }
    }
    else
    {
      DbgPrintOut(0, "Invalid params");
      result = -2147024809;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid state");
    result = -2147019873;
  }
  return result;
}

//----- (77E92BA9) --------------------------------------------------------
signed int __stdcall WerpGetPeb32FromProcess(HANDLE ProcessHandle, struct _PEB32 *lpBuffer)
{
  NTSTATUS v2; // eax@3
  NTSTATUS v3; // edi@3
  signed int result; // eax@4
  const void *ProcessInformation; // [sp+8h] [bp-4h]@1

  ProcessInformation = 0;
  if ( ProcessHandle && lpBuffer )
  {
    v2 = NtQueryInformationProcess(ProcessHandle, ProcessWow64Information, &ProcessInformation, 4u, 0);
    v3 = v2;
    if ( v2 >= 0 )
    {
      if ( ProcessInformation )
      {
        if ( ReadProcessMemory(ProcessHandle, ProcessInformation, (LPVOID)lpBuffer, 0x248u, 0) )
        {
          result = 0;
        }
        else
        {
          DbgPrintOut(0, "ReadProcessMemory failed while trying to read PebBaseAddress");
          result = GetLastError();
          if ( result > 0 )
            result = (unsigned __int16)result | 0x80070000;
        }
      }
      else
      {
        DbgPrintOut(0, "No 32 PEB for process");
        result = -2147467259;
      }
    }
    else
    {
      DbgPrintOut(0, "NtQueryInformationProcess failed with status 0x%x", v2);
      result = v3 | 0x10000000;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid arg");
    result = -2147024809;
  }
  return result;
}

//----- (77E92CB7) --------------------------------------------------------
int __stdcall WerpGetPeb64FromProcess(void *a1, struct _PEB64 *a2)
{
  int v2; // eax@3
  int v3; // edi@3
  int result; // eax@4
  int v5; // edi@7
  int v6; // [sp+8h] [bp-30h]@3
  char Dst; // [sp+Ch] [bp-2Ch]@3
  unsigned __int64 v8; // [sp+10h] [bp-28h]@5

  if ( a1 && a2 )
  {
    v6 = 0;
    memset(&Dst, 0, 0x2Cu);
    v2 = WerpNtWow64QueryInformationProcess64(a1, 0, &v6, 0x30u, 0);
    v3 = v2;
    if ( v2 >= 0 )
    {
      if ( v8 )
      {
        v5 = WerpNtWow64ReadVirtualMemory64(a1, v8, (void *)a2, 0x380ui64, 0);
        if ( v5 >= 0 )
        {
          result = 0;
        }
        else
        {
          DbgPrintOut(0, "WerpNtWow64ReadVirtualMemory64  failed while trying to read PebBaseAddress");
          result = v5 | 0x10000000;
        }
      }
      else
      {
        DbgPrintOut(0, "No 64 bit PEB for process");
        result = -2147467259;
      }
    }
    else
    {
      DbgPrintOut(0, "WerpNtWow64QueryInformationProcess64 failed with status 0x%x", v2);
      result = v3 | 0x10000000;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid arg");
    result = -2147024809;
  }
  return result;
}

//----- (77E92E2A) --------------------------------------------------------
signed int __stdcall WerpGetRecoveryInfoForSelf(struct _WER_RECOVERY_INFO **a1)
{
  struct _PEB *v2; // edi@3
  PVOID v3; // edi@8
  signed int v4; // [sp+10h] [bp-1Ch]@11

  if ( !a1 )
    return -2147024809;
  *a1 = 0;
  v2 = WerpCurrentPeb();
  if ( !v2 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  v3 = v2[1].Reserved9[8];
  if ( v3 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v3) >= 0 )
  {
    if ( *((_DWORD *)v3 + 522) == 64 )
    {
      *a1 = (struct _WER_RECOVERY_INFO *)((char *)v3 + 2088);
      v4 = 0;
    }
    else
    {
      DbgPrintOut(0, "Invalid handle passed");
      v4 = -2147024890;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid PEB entry");
    v4 = -2147467259;
  }
  RtlReleasePebLock();
  return v4;
}

//----- (77E92F31) --------------------------------------------------------
signed int __stdcall WerpRecoveryInProgress(int a1)
{
  signed int result; // eax@2
  signed int v2; // eax@3
  struct _WER_RECOVERY_INFO *v3; // esi@5
  struct _WER_RECOVERY_INFO *v4; // [sp+8h] [bp-4h]@1

  v4 = 0;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    v2 = WerpGetRecoveryInfoForSelf(&v4);
    if ( v2 >= 0 )
    {
      v3 = v4;
      if ( *((_DWORD *)v4 + 12) )
      {
        if ( WaitForSingleObject(*((HANDLE *)v4 + 10), 0) )
        {
          if ( *((_QWORD *)v3 + 3) )
            SetEvent(*((HANDLE *)v3 + 6));
        }
        else
        {
          *(_DWORD *)a1 = 1;
        }
        result = 0;
      }
      else
      {
        result = -2147467259;
      }
    }
    else
    {
      DbgPrintOut(0, "WerpGetRecoveryInfoForSelf failed with 0x%x", v2);
      result = -2147467259;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid params");
    result = -2147024809;
  }
  return result;
}

//----- (77E92FC1) --------------------------------------------------------
void __stdcall WerpRecoveryFinished(int a1)
{
  signed int v1; // eax@1
  struct _WER_RECOVERY_INFO *v2; // eax@3
  struct _WER_RECOVERY_INFO *v3; // [sp+0h] [bp-4h]@1

  v3 = 0;
  v1 = WerpGetRecoveryInfoForSelf(&v3);
  if ( v1 >= 0 )
  {
    v2 = v3;
    if ( *((_DWORD *)v3 + 12) == 1 )
    {
      *((_DWORD *)v3 + 13) = a1;
      if ( *((_QWORD *)v2 + 4) )
        SetEvent(*((HANDLE *)v2 + 8));
      else
        DbgPrintOut(0, "No done event for recovery mode");
    }
  }
  else
  {
    DbgPrintOut(0, "WerpGetRecoveryInfoForSelf failed with 0x%x", v1);
  }
}

//----- (77E93045) --------------------------------------------------------
signed int __stdcall WerpAddRuntimeDllToPEB(struct _WER_RUNTIME_DLL *a1, int *a2)
{
  struct _PEB *v2; // ebx@3
  PVOID v4; // ebx@8
  int v5; // edx@10
  int v6; // eax@19
  int v7; // ecx@19
  unsigned int v8; // [sp+10h] [bp-24h]@19
  signed int v9; // [sp+18h] [bp-1Ch]@1

  v9 = -2147467259;
  if ( a1 && a2 )
  {
    *a2 = 0;
    v2 = WerpCurrentPeb();
    if ( !v2 )
    {
      DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
      return -2147467259;
    }
    if ( WerpAcquirePebLock() < 0 )
    {
      DbgPrintOut(0, "Unable to get the peb lock");
      return -2147467259;
    }
    v4 = v2[1].Reserved9[8];
    if ( !v4 || WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v4) < 0 )
    {
      DbgPrintOut(0, "Invalid PEB entry");
      goto LABEL_29;
    }
    v5 = *((_DWORD *)v4 + 540);
    if ( v5 )
    {
      do
      {
        if ( !wcscmp((const unsigned __int16 *)(v5 + 24), (const unsigned __int16 *)a1 + 12)
          && *(_DWORD *)(v5 + 16) == *((_DWORD *)a1 + 4)
          && *(_DWORD *)(v5 + 20) == *((_DWORD *)a1 + 5) )
        {
          *a2 = 1;
          v9 = 0;
          goto LABEL_29;
        }
        v5 = *(_DWORD *)v5;
      }
      while ( v5 );
      v6 = *((_DWORD *)v4 + 540);
      v7 = 0;
      v8 = 0;
      while ( v6 )
      {
        v7 = v6;
        v6 = *(_DWORD *)v6;
        ++v8;
      }
      if ( v8 >= 0x10 )
      {
        v9 = -2147024774;
        goto LABEL_29;
      }
      if ( v7 )
        *(_QWORD *)v7 = (signed int)a1;
      else
        *((_QWORD *)v4 + 270) = (signed int)a1;
      *(_DWORD *)a1 = 0;
      *((_DWORD *)a1 + 1) = 0;
    }
    else
    {
      *(_DWORD *)a1 = 0;
      *((_DWORD *)a1 + 1) = 0;
      *((_QWORD *)v4 + 270) = (signed int)a1;
    }
    v9 = 0;
LABEL_29:
    RtlReleasePebLock();
    return v9;
  }
  DbgPrintOut(0, "Invalid args");
  return -2147024809;
}

//----- (77E93201) --------------------------------------------------------
signed int __stdcall WerpRegisterRuntimeExceptionModule(PCWSTR pwszOutOfProcessCallbackDll, PVOID pContext)
{
  int v2; // esi@1
  signed int result; // eax@2
  unsigned int v4; // eax@7
  size_t v5; // ebx@7
  int v6; // edi@7
  int v7; // eax@7
  int v8; // eax@9
  struct _WER_HEAP_MAIN_HEADER *v9; // [sp+10h] [bp-28h]@7
  int v10; // [sp+14h] [bp-24h]@1
  int v11; // [sp+18h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@7

  v12 = -2147467259;
  v2 = 0;
  v11 = 0;
  v10 = 0;
  if ( WerpCheckOkToRegister() )
  {
    if ( pwszOutOfProcessCallbackDll )
    {
      if ( WerpInitPEBStore() >= 0 )
      {
        ms_exc.registration.TryLevel = 0;
        v4 = wcslen(pwszOutOfProcessCallbackDll);
        v5 = 2 * v4 + 2;
        v6 = 2 * v4 + 26;
        v7 = WerpGetHeapHandle();
        v9 = (struct _WER_HEAP_MAIN_HEADER *)v7;
        if ( v7 )
        {
          v8 = WerpHeapAlloc((struct _WER_HEAP_MAIN_HEADER *)v7, v6);
          v2 = v8;
          v11 = v8;
          if ( v8 )
          {
            memset((void *)v8, 0, v6);
            *(_QWORD *)(v2 + 16) = (signed int)pContext;
            *(_DWORD *)(v2 + 8) = v6;
            v12 = StringCbCopyW((STRSAFE_LPWSTR)(v2 + 24), v5, pwszOutOfProcessCallbackDll);
            if ( v12 >= 0 )
            {
              v12 = WerpAddRuntimeDllToPEB((struct _WER_RUNTIME_DLL *)v2, &v10);
              if ( v12 < 0 )
                DbgPrintOut(0, "Failed register runtime crash dll");
            }
            else
            {
              DbgPrintOut(0, "StringCbCopy failed");
            }
          }
          else
          {
            DbgPrintOut(0, "OOM");
            v12 = -2147024882;
          }
        }
        else
        {
          DbgPrintOut(0, "Unable to get the heap handle");
          v12 = -2147467259;
        }
        ms_exc.registration.TryLevel = -2;
        if ( v12 < 0 || v10 )
        {
          if ( v2 )
          {
            WerpHeapFree(v9, (void *)v2);
            v11 = 0;
          }
        }
        result = v12;
      }
      else
      {
        DbgPrintOut(0, "WerpInitPEBStore failed");
        result = -2147467259;
      }
    }
    else
    {
      DbgPrintOut(0, "Invalid arguments in call to function");
      result = -2147024809;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid state");
    result = -2147019873;
  }
  return result;
}

//----- (77E933C9) --------------------------------------------------------
signed int __stdcall WerpUnregisterRuntimeExceptionModule(const unsigned __int16 *a1, int a2)
{
  int v2; // ebx@1
  struct _PEB *v4; // edi@3
  PVOID v5; // edi@8
  int i; // ecx@12
  int v7; // eax@16
  struct _WER_HEAP_MAIN_HEADER *v8; // [sp+10h] [bp-24h]@10
  signed int v9; // [sp+18h] [bp-1Ch]@1

  v9 = -2147467259;
  v2 = 0;
  if ( !a1 )
  {
    DbgPrintOut(0, "Invalid arguments in call to function");
    return -2147024809;
  }
  v4 = WerpCurrentPeb();
  if ( !v4 )
  {
    DbgPrintOut(0, "Unable to get the pPeb, WerpCurrentPeb failed");
    return -2147467259;
  }
  if ( WerpAcquirePebLock() < 0 )
  {
    DbgPrintOut(0, "Unable to get the peb lock");
    return -2147467259;
  }
  v5 = v4[1].Reserved9[8];
  if ( v5 && WerpValidatePebHeader((struct _WER_PEB_HEADER_BLOCK *)v5) >= 0 )
  {
    v8 = (struct _WER_HEAP_MAIN_HEADER *)WerpGetHeapHandle();
    if ( v8 )
    {
      for ( i = *((_DWORD *)v5 + 540); ; i = *(_DWORD *)i )
      {
        if ( !i )
        {
          v9 = -2147024894;
          goto LABEL_23;
        }
        if ( !wcscmp((const unsigned __int16 *)(i + 24), a1) && *(_QWORD *)(i + 16) == a2 )
          break;
        v2 = i;
      }
      v7 = *(_DWORD *)i;
      if ( v2 )
      {
        *(_DWORD *)v2 = v7;
        *(_DWORD *)(v2 + 4) = *(_DWORD *)(i + 4);
      }
      else
      {
        *((_DWORD *)v5 + 540) = v7;
        *((_DWORD *)v5 + 541) = *(_DWORD *)(i + 4);
      }
      WerpHeapFree(v8, (void *)i);
      v9 = 0;
    }
    else
    {
      DbgPrintOut(0, "Unable to get the heap handle");
      v9 = -2147467259;
    }
  }
  else
  {
    DbgPrintOut(0, "Invalid PEB entry");
  }
LABEL_23:
  RtlReleasePebLock();
  return v9;
}

//----- (77E93559) --------------------------------------------------------
signed int __stdcall WerpInitiateRecovery(struct _WER_RECOVERY_INFO *a1)
{
  bool v2; // bl@5
  bool v3; // bl@5
  int v4; // ST04_4@8
  int v5; // eax@8

  if ( !a1 )
  {
    DbgPrintOut(0, "Invalid params");
    return -2147024809;
  }
  if ( *((_DWORD *)a1 + 12) )
  {
    DbgPrintOut(0, "Already in recovery");
    return -2147019873;
  }
  v2 = NtClearEvent(*((HANDLE *)a1 + 6)) >= 0;
  v3 = NtClearEvent(*((HANDLE *)a1 + 8)) >= 0 && v2;
  if ( NtClearEvent(*((HANDLE *)a1 + 10)) >= 0 && v3 )
  {
    if ( *((_QWORD *)a1 + 1) )
    {
      *((_DWORD *)a1 + 12) = 1;
      v4 = *((_DWORD *)a1 + 4);
      v5 = RtlDecodeSystemPointer(*((_DWORD *)a1 + 2));
      ((void (__stdcall *)(int))v5)(v4);
      *((_DWORD *)a1 + 12) = 0;
      return 0;
    }
    DbgPrintOut(0, "No recovery function found");
  }
  else
  {
    DbgPrintOut(0, "Invalid events");
  }
  return -2147467259;
}
// 77DE12A0: using guessed type int __stdcall RtlDecodeSystemPointer(_DWORD);

//----- (77E936F9) --------------------------------------------------------
signed int __stdcall WerpRecoveryInvokedRemotely()
{
  signed int v0; // esi@2
  struct _WER_RECOVERY_INFO *v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  if ( WerpGetRecoveryInfoForSelf(&v2) )
  {
    DbgPrintOut(0, "No recovery rotuine found when control reached WerpRecoveryInvokedRemotely");
    v0 = -2147467259;
  }
  else
  {
    v0 = WerpInitiateRecovery(v2);
    if ( v0 >= 0 )
      v0 = 0;
    else
      DbgPrintOut(0, "WerpInitiateRecovery failed");
  }
  return v0;
}

//----- (77E937B8) --------------------------------------------------------
int __stdcall RealWerpStringLookup(unsigned __int16 *a1, void **a2)
{
  signed int v2; // esi@1
  DWORD v3; // edi@1

  v2 = 0;
  v3 = GetLastError();
  if ( !FSPErrorMessages::CMessageMapper::Lookup(
          (FSPErrorMessages::CMessageMapper *)&FSPErrorMessages::CMessageMapper::ms_instance,
          a1,
          a2) )
    v2 = 1;
  SetLastError(v3);
  return v2;
}

//----- (77E937F0) --------------------------------------------------------
struct Node *__thiscall FSPErrorMessages::CMessageMapper::Lookup(FSPErrorMessages::CMessageMapper *this, const unsigned __int16 *a2, void **a3)
{
  return FSPErrorMessages::CMessageTagCache::Lookup(*((FSPErrorMessages::CMessageTagCache **)this + 10), a2, a3);
}

//----- (77E93803) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageMapper::ResetAndDisable(FSPErrorMessages::CMessageMapper *this)
{
  FSPErrorMessages::CMessageMapper *v1; // esi@1

  v1 = this;
  FSPErrorMessages::CMessageMapper::Reset(this);
  *((_DWORD *)v1 + 9) = 1;
}

//----- (77E9381B) --------------------------------------------------------
int __stdcall HashStringToDwordCaseInsensitive(const unsigned __int16 *a1)
{
  WCHAR *v1; // edi@1
  int v2; // ebx@1
  signed int v3; // esi@1
  WCHAR v4; // ax@2
  signed int v5; // ecx@2

  v1 = (WCHAR *)a1;
  v2 = 0;
  v3 = 31415;
  while ( *v1 )
  {
    v4 = RtlUpcaseUnicodeChar(*v1);
    v5 = v3;
    v3 *= 27183;
    v2 = v2 * v5 + v4;
    ++v1;
  }
  return v2;
}

//----- (77E93860) --------------------------------------------------------
int __stdcall FSPErrorMessages::CMessageMapper::ReportMessage(struct tagWerpMessageId *a2, unsigned __int32 a3, const unsigned __int16 *a4)
{
  int v4; // eax@2
  unsigned __int32 v6; // [sp+4h] [bp-18h]@4
  int v7; // [sp+8h] [bp-14h]@4
  int v8; // [sp+Ch] [bp-10h]@4
  int v9; // [sp+10h] [bp-Ch]@4
  int v10; // [sp+14h] [bp-8h]@4
  int v11; // [sp+18h] [bp-4h]@4

  if ( *(_DWORD *)a2 )
    v4 = HashStringToDwordCaseInsensitive(*(const unsigned __int16 **)a2);
  else
    v4 = 0;
  v7 = v4;
  v8 = *((_DWORD *)a2 + 1);
  v9 = *((_DWORD *)a2 + 2);
  v10 = *((_DWORD *)a2 + 4);
  v11 = *((_DWORD *)a2 + 3);
  v6 = a3;
  return WerReportSQMEvent(0, &v6, 6, a4) | 0x10000000;
}
// 77E956D0: using guessed type int __stdcall WerReportSQMEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (77E938BC) --------------------------------------------------------
int __stdcall FSPErrorMessages::CMessageMapper::ReportMessageText(const unsigned __int16 *a2, unsigned __int32 a3)
{
  int v4; // [sp+4h] [bp-14h]@1
  int v5; // [sp+8h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v8 = HashStringToDwordCaseInsensitive(a2);
  v4 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  return FSPErrorMessages::CMessageMapper::ReportMessage((struct tagWerpMessageId *)&v4, a3, a2);
}

//----- (77E938FB) --------------------------------------------------------
__int32 __stdcall FSPErrorMessages::CMessageMapper::GetModuleTimeStampFromFileNameNoLock(LPCWSTR lpLibFileName, unsigned __int32 *a3)
{
  signed int v3; // ebx@1
  HMODULE v4; // eax@1
  HMODULE v5; // edi@1
  __int32 result; // eax@2
  PIMAGE_NT_HEADERS v7; // eax@4

  v3 = 0;
  *a3 = 0;
  v4 = LoadLibraryExW(lpLibFileName, 0, 2u);
  v5 = v4;
  if ( v4 )
  {
    v7 = RtlImageNtHeader((PVOID)((unsigned int)v4 & 0xFFFFFFFC));
    if ( v7 )
      *a3 = v7->FileHeader.TimeDateStamp;
    else
      v3 = -805306245;
    FreeLibrary(v5);
    result = v3;
  }
  else
  {
    result = GetLastError();
    if ( result > 0 )
      result = (unsigned __int16)result | 0x80070000;
  }
  return result;
}

//----- (77E9395E) --------------------------------------------------------
signed int __stdcall FSPErrorMessages::CMessageMapper::GetModuleVersionFromFileNameNoLock(LPCWSTR lpLibFileName, unsigned __int32 *a3, unsigned __int32 *a4)
{
  HMODULE v4; // eax@1
  HMODULE v5; // ebx@1
  HRSRC v6; // eax@2
  HRSRC v7; // esi@2
  HGLOBAL v8; // eax@4
  void *v9; // edi@4
  LPVOID v10; // esi@5
  signed int v11; // esi@7
  DWORD v12; // eax@9
  DWORD v13; // eax@14
  DWORD v14; // eax@18

  v4 = LoadLibraryExW(lpLibFileName, 0, 2u);
  v5 = v4;
  if ( v4 )
  {
    v6 = FindResourceW(v4, (LPCWSTR)1, (LPCWSTR)0x10);
    v7 = v6;
    if ( v6 )
    {
      if ( SizeofResource(v5, v6) < 0x5C )
      {
        v11 = -2147023083;
LABEL_17:
        FreeLibrary(v5);
        return v11;
      }
      v8 = LoadResource(v5, v7);
      v9 = v8;
      if ( v8 )
      {
        v10 = LockResource(v8);
        if ( v10 )
        {
          if ( __wcsnicmp((const wchar_t *)v10 + 3, L"VS_VERSION_INFO", 0xFu) )
          {
            v11 = -2147023083;
          }
          else
          {
            *a3 = *((_DWORD *)v10 + 12);
            *a4 = *((_DWORD *)v10 + 13);
            v11 = 0;
          }
        }
        else
        {
          v12 = GetLastError();
          if ( (signed int)v12 > 0 )
            v12 = (unsigned __int16)v12 | 0x80070000;
          v11 = v12;
        }
        FreeResource(v9);
        goto LABEL_17;
      }
    }
    v13 = GetLastError();
    if ( (signed int)v13 > 0 )
      v13 = (unsigned __int16)v13 | 0x80070000;
    v11 = v13;
    goto LABEL_17;
  }
  v14 = GetLastError();
  if ( (signed int)v14 > 0 )
    v14 = (unsigned __int16)v14 | 0x80070000;
  return v14;
}

//----- (77E93A69) --------------------------------------------------------
signed int __stdcall StringCchCatW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3)
{
  unsigned int v3; // edx@1
  signed int result; // eax@1
  int v5; // ecx@5
  unsigned int v6; // esi@5
  unsigned __int16 *v7; // eax@5
  unsigned int v8; // [sp+14h] [bp+Ch]@5

  v3 = a2;
  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result < 0 )
  {
    v5 = 0;
  }
  else
  {
    v8 = 0;
    v5 = 0;
    v6 = v3;
    v7 = a1;
    if ( !v3 )
      goto LABEL_17;
    do
    {
      if ( !*v7 )
        break;
      ++v7;
      --v6;
    }
    while ( v6 );
    if ( v6 )
      v5 = v3 - v6;
    else
LABEL_17:
      v8 = -2147024809;
    result = v8;
  }
  if ( result >= 0 )
    result = sub_77E2DB49((int)a3, v3 - v5, (int)&a1[v5], 0, 0x7FFFFFFF);
  return result;
}

//----- (77E93ADF) --------------------------------------------------------
signed int __stdcall StringCbLengthA(const char *a1, unsigned int a2, unsigned int *a3)
{
  const char *v3; // ecx@1
  unsigned int v4; // edx@1
  signed int v5; // esi@3
  unsigned int v6; // edx@3
  signed int result; // eax@8

  v3 = a1;
  v4 = 0;
  if ( a1 && a2 <= 0x7FFFFFFF )
  {
    v5 = 0;
    v6 = a2;
    if ( !a2 )
      goto LABEL_17;
    do
    {
      if ( !*v3 )
        break;
      ++v3;
      --v6;
    }
    while ( v6 );
    if ( v6 )
    {
      v4 = a2 - v6;
    }
    else
    {
LABEL_17:
      v5 = -2147024809;
      v4 = 0;
    }
    result = v5;
  }
  else
  {
    result = -2147024809;
  }
  if ( a3 )
  {
    if ( result < 0 )
      *a3 = 0;
    else
      *a3 = v4;
  }
  return result;
}

//----- (77E93B3F) --------------------------------------------------------
__int32 __thiscall FSPErrorMessages::CMessageMapper::PopulateModuleInformation(FSPErrorMessages::CMessageMapper *this, wchar_t *Str, unsigned __int32 a3, struct tagWerpMessageId *a4)
{
  wchar_t *v4; // eax@1
  int v5; // eax@2
  struct tagWerpMessageId *v6; // esi@3
  signed int v7; // eax@5
  signed int v8; // ST14_4@6
  int v9; // ST10_4@6
  int v10; // ST0C_4@6
  HANDLE v11; // eax@6
  DWORD v12; // eax@6
  __int32 v13; // eax@7
  __int32 v14; // ST18_4@8
  int v15; // ST14_4@8
  int v16; // ST10_4@8
  HANDLE v17; // eax@8
  DWORD v18; // eax@8
  FSPErrorMessages::CMessageMapper *v20; // [sp+8h] [bp-4h]@1

  v20 = this;
  v4 = _wcsrchr(Str, 0x5Cu);
  if ( v4 && (v5 = (int)(v4 + 1), *(_WORD *)v5) )
  {
    v6 = a4;
    *(_DWORD *)a4 = v5;
  }
  else
  {
    v6 = a4;
    *(_DWORD *)a4 = Str;
  }
  *((_DWORD *)v6 + 4) = a3;
  v7 = FSPErrorMessages::CMessageMapper::GetModuleVersionFromFileNameNoLock(
         Str,
         (unsigned __int32 *)v6 + 1,
         (unsigned __int32 *)v6 + 2);
  if ( v7 < 0 )
  {
    v8 = v7;
    v9 = *((_DWORD *)v6 + 4);
    v10 = *(_DWORD *)v6;
    v11 = GetCurrentProcess();
    v12 = GetProcessId(v11);
    FSPErrorMessages::CMessageMapper::DumpTrace(
      v20,
      "USE: GETMODULEVERSION failed PID=%ld | MODNAME=%S | STRID=%ld | hr = %X\n",
      v12,
      v10,
      v9,
      v8);
    *((_DWORD *)v6 + 1) = 0;
    *((_DWORD *)v6 + 2) = 0;
  }
  v13 = FSPErrorMessages::CMessageMapper::GetModuleTimeStampFromFileNameNoLock(Str, (unsigned __int32 *)v6 + 3);
  if ( v13 < 0 )
  {
    v14 = v13;
    v15 = *((_DWORD *)v6 + 4);
    v16 = *(_DWORD *)v6;
    v17 = GetCurrentProcess();
    v18 = GetProcessId(v17);
    FSPErrorMessages::CMessageMapper::DumpTrace(
      v20,
      "USE: GETMODSTAMP failed PID=%ld | MODNAME=%S | STRID=%ld | hr = %X\n",
      v18,
      v16,
      v15,
      v14);
    *((_DWORD *)v6 + 3) = 0;
  }
  return 0;
}

//----- (77E93C8E) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::ReportMessageFromText(FSPErrorMessages::CMessageMapper *this, LONG Exchange, unsigned __int32 a3)
{
  LONG v3; // esi@1
  FSPErrorMessages::CMessageMapper *v4; // ebx@1
  signed int result; // eax@2
  unsigned __int32 v6; // edi@9
  unsigned __int32 v7; // ST10_4@11
  HANDLE v8; // eax@11
  DWORD v9; // eax@11
  int v10; // eax@6
  signed int v11; // edi@12
  char v12; // [sp+Ch] [bp-24h]@10
  wchar_t *Str; // [sp+20h] [bp-10h]@7
  unsigned __int32 v14; // [sp+24h] [bp-Ch]@8
  int v15; // [sp+28h] [bp-8h]@8
  int v16; // [sp+2Ch] [bp-4h]@1

  v3 = Exchange;
  v4 = this;
  v16 = 0;
  if ( *(_WORD *)Exchange )
  {
    if ( !InterlockedCompareExchange(&FSPErrorMessages::g_pwszWMREscalatedMessageBuffer, Exchange, 0) )
    {
      v16 = 1;
      WerRegisterMemoryBlock((PVOID)v3, 2 * wcslen((const unsigned __int16 *)v3));
    }
    if ( *((_DWORD *)v4 + 7) )
    {
      RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)v4);
      if ( !FSPErrorMessages::CMessageTagCache::LookupTag(
              *((FSPErrorMessages::CMessageTagCache **)v4 + 10),
              (LPCWSTR)v3,
              (struct FSPErrorMessages::MessageTag *)&Str) )
      {
        Str = 0;
        v14 = 0;
        v15 = 0;
      }
      RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)v4);
      v6 = v15 | a3;
      if ( Str )
      {
        FSPErrorMessages::CMessageMapper::PopulateModuleInformation(v4, Str, v14, (struct tagWerpMessageId *)&v12);
        v10 = FSPErrorMessages::CMessageMapper::ReportMessage(
                (struct tagWerpMessageId *)&v12,
                v6,
                (const unsigned __int16 *)v3);
      }
      else
      {
        FSPErrorMessages::CMessageHashVectorBuilder::CMessageHashVectorBuilder((FSPErrorMessages::CMessageHashVectorBuilder *)((char *)&Exchange + 3));
        v7 = FSPErrorMessages::CMessageHashVectorBuilder::GetCombinedIndexHash((const unsigned __int16 *)v3) % 0xED;
        v8 = GetCurrentProcess();
        v9 = GetProcessId(v8);
        FSPErrorMessages::CMessageMapper::DumpTrace(
          v4,
          "USE: Lookup failed PID=%ld | STR=%S | HashModBuckets=%ld\n",
          v9,
          v3,
          v7);
        v10 = FSPErrorMessages::CMessageMapper::ReportMessageText((const unsigned __int16 *)v3, v6);
      }
    }
    else
    {
      v10 = FSPErrorMessages::CMessageMapper::ReportMessageText((const unsigned __int16 *)v3, a3);
    }
    v11 = v10;
    if ( v16 )
    {
      WerUnregisterMemoryBlock((PVOID)v3);
      FSPErrorMessages::g_pwszWMREscalatedMessageBuffer = 0;
    }
    result = v11;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (77E93DE3) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageMapper::ReportMessageFromStringId(FSPErrorMessages::CMessageMapper *this, HINSTANCE hModule, unsigned __int32 a3, unsigned __int32 a4)
{
  FSPErrorMessages::CMessageMapper *v4; // esi@1
  signed int result; // eax@1
  char v6; // [sp+4h] [bp-220h]@2
  wchar_t Str; // [sp+18h] [bp-20Ch]@1

  v4 = this;
  result = FSPErrorMessages::CMessageMapper::GetModuleFileNameFromHandleNoLock(this, hModule, &Str, 0x104u);
  if ( result >= 0 )
  {
    FSPErrorMessages::CMessageMapper::PopulateModuleInformation(v4, &Str, a3, (struct tagWerpMessageId *)&v6);
    result = FSPErrorMessages::CMessageMapper::ReportMessage((struct tagWerpMessageId *)&v6, a4 | 4, 0);
  }
  return result;
}

//----- (77E93E59) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageTagCache::Init(FSPErrorMessages::CMessageTagCache *this, void *a2)
{
  FSPErrorMessages::CMessageTagCache *v2; // esi@1

  v2 = this;
  *((_DWORD *)this + 238) = a2;
  memset((void *)this, 0, 0x3B4u);
  *((_DWORD *)v2 + 237) = 0;
  FSPErrorMessages::CResourceModuleInfoTable::Init((FSPErrorMessages::CMessageTagCache *)((char *)v2 + 956), a2);
}

//----- (77E93E99) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageTagCache::Free(FSPErrorMessages::CMessageTagCache *this, void *Address)
{
  RtlFreeHeap(*((HANDLE *)this + 238), 0, Address);
}

//----- (77E93EB8) --------------------------------------------------------
void __thiscall FSPErrorMessages::CMessageTagCache::InsertNode(FSPErrorMessages::CMessageTagCache *this, unsigned __int32 a2, struct Node *a3)
{
  struct NodeVtbl **v3; // ecx@1

  v3 = (struct NodeVtbl **)((char *)this + 4 * (a2 % 0xED));
  if ( *v3 )
  {
    a3[3].lpVtbl = *v3;
    a3[4].lpVtbl = (struct NodeVtbl *)(*v3)->GetTypeInfo;
    a3[3].lpVtbl->GetTypeInfo = (HRESULT (__stdcall *)(Node *, UINT, LCID, ITypeInfo **))a3;
    a3[4].lpVtbl->GetTypeInfoCount = (HRESULT (__stdcall *)(Node *, UINT *))a3;
    *v3 = (struct NodeVtbl *)a3;
  }
  else
  {
    *v3 = (struct NodeVtbl *)a3;
    a3[3].lpVtbl = (struct NodeVtbl *)a3;
    a3[4].lpVtbl = (struct NodeVtbl *)a3;
  }
}

//----- (77E93F03) --------------------------------------------------------
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::LookupNodeByMessageTag(FSPErrorMessages::CMessageTagCache *this, unsigned __int32 a2, struct FSPErrorMessages::MessageTag *Source2)
{
  char *v3; // edi@1
  int v4; // esi@1
  struct Node *result; // eax@4

  v3 = (char *)this + 4 * (a2 % 0xED);
  v4 = *(_DWORD *)v3;
  if ( *(_DWORD *)v3 )
  {
    while ( RtlCompareMemory((const void *)v4, (const void *)Source2, 0xCu) != 12 )
    {
      v4 = *(_DWORD *)(v4 + 12);
      if ( v4 == *(_DWORD *)v3 )
        goto LABEL_4;
    }
    *(_DWORD *)v3 = v4;
    result = (struct Node *)v4;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (77E93F4A) --------------------------------------------------------
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::LookupNodeByMessage(FSPErrorMessages::CMessageTagCache *this, unsigned __int32 a2, const unsigned __int16 *a3)
{
  char *v3; // edi@1
  int v4; // esi@1
  struct Node *result; // eax@4

  v3 = (char *)this + 4 * (a2 % 0xED);
  v4 = *(_DWORD *)v3;
  if ( *(_DWORD *)v3 )
  {
    while ( FSPErrorMessages::CMessageHashVector::Match((FSPErrorMessages::CMessageHashVector *)(v4 + 20), a3) != 1 )
    {
      v4 = *(_DWORD *)(v4 + 12);
      if ( v4 == *(_DWORD *)v3 )
        goto LABEL_4;
    }
    *(_DWORD *)v3 = v4;
    result = (struct Node *)v4;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (77E93F90) --------------------------------------------------------
void __stdcall FSPErrorMessages::CMessageTagCache::ProcessCRLFs(const unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int32 a4)
{
  const unsigned __int16 *v4; // ecx@1
  unsigned __int16 *v5; // edx@1
  unsigned __int16 v6; // ax@8

  v4 = a2;
  v5 = a3;
  if ( a2 )
  {
    while ( 1 )
    {
      v6 = *v4;
      if ( !*v4 || v5 >= &a3[a4 - 1] )
        break;
      if ( v6 != 13 && v6 != 10 )
      {
        *v5 = v6;
        ++v5;
      }
      ++v4;
    }
    *v5 = 0;
  }
}

//----- (77E93FD7) --------------------------------------------------------
struct Node *__thiscall FSPErrorMessages::CMessageTagCache::Lookup(FSPErrorMessages::CMessageTagCache *this, const unsigned __int16 *a2, void **a3)
{
  unsigned int v3; // esi@1
  struct Node *result; // eax@2
  unsigned __int32 v5; // [sp+Ch] [bp-14h]@1
  unsigned __int32 v6; // [sp+10h] [bp-10h]@1
  unsigned __int32 v7; // [sp+14h] [bp-Ch]@1
  FSPErrorMessages::CMessageTagCache *v8; // [sp+18h] [bp-8h]@1
  char v9; // [sp+1Fh] [bp-1h]@1

  v8 = this;
  FSPErrorMessages::CMessageHashVectorBuilder::CMessageHashVectorBuilder((FSPErrorMessages::CMessageHashVectorBuilder *)&v9);
  v5 = FSPErrorMessages::CMessageHashVectorBuilder::GetCombinedIndexHash(a2);
  v6 = FSPErrorMessages::CMessageHashVectorBuilder::GetStartIndexHash(a2);
  v3 = 0;
  v7 = FSPErrorMessages::CMessageHashVectorBuilder::GetEndIndexHash(a2);
  *a3 = 0;
  while ( 1 )
  {
    result = FSPErrorMessages::CMessageTagCache::LookupNodeByMessage(v8, *(&v5 + v3), a2);
    if ( result )
      break;
    ++v3;
    if ( v3 >= 3 )
      return result;
  }
  *a3 = result;
  return (struct Node *)1;
}

//----- (77E94045) --------------------------------------------------------
int __thiscall FSPErrorMessages::CMessageTagCache::LookupTag(FSPErrorMessages::CMessageTagCache *this, LPCWSTR lpString, struct FSPErrorMessages::MessageTag *a3)
{
  const unsigned __int16 *v3; // ebx@1
  struct FSPErrorMessages::MessageTag *v4; // esi@1
  int v5; // eax@1
  unsigned __int16 *v6; // edi@1
  int v7; // eax@2
  struct FSPErrorMessages::MessageTag *v8; // eax@4
  signed int v10; // [sp+Ch] [bp-8h]@1
  FSPErrorMessages::CMessageTagCache *v11; // [sp+10h] [bp-4h]@1

  v3 = lpString;
  v4 = a3;
  v11 = this;
  v10 = 0;
  *(_DWORD *)a3 = 0;
  *((_DWORD *)v4 + 2) = 0;
  v5 = lstrlenW(lpString);
  v6 = (unsigned __int16 *)RtlAllocateHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 8u, 2 * v5 + 2);
  if ( v6 )
  {
    v7 = lstrlenW(lpString);
    FSPErrorMessages::CMessageTagCache::ProcessCRLFs(lpString, v6, v7 + 1);
    v3 = v6;
  }
  if ( FSPErrorMessages::CMessageTagCache::Lookup(v11, v3, (void **)&a3) )
  {
    v8 = a3;
    *(_DWORD *)v4 = *(_DWORD *)a3;
    *((_DWORD *)v4 + 1) = *((_DWORD *)v8 + 1);
    *((_DWORD *)v4 + 2) = *((_DWORD *)v8 + 2);
    v10 = 1;
  }
  if ( v6 )
    RtlFreeHeap(NtCurrentTeb()->ProcessEnvironmentBlock->Reserved4[1], 0, v6);
  return v10;
}

//----- (77E940EF) --------------------------------------------------------
void FSPErrorMessages::CMessageTagCache::DumpTrace(FSPErrorMessages::CMessageTagCache *this, const char *Format, ...)
{
  va_list va; // [sp+10h] [bp+10h]@1

  va_start(va, Format);
  FSPErrorMessages::CMessageMapper::DumpTrace(
    (FSPErrorMessages::CMessageMapper *)&FSPErrorMessages::CMessageMapper::ms_instance,
    Format,
    va);
}

//----- (77E9410F) --------------------------------------------------------
int __thiscall FSPErrorMessages::CMessageTagCache::ReclaimMemory(FSPErrorMessages::CMessageTagCache *this)
{
  FSPErrorMessages::CMessageTagCache *v1; // edi@1
  int v2; // eax@3
  int v3; // esi@3
  int v4; // ecx@4
  signed int v6; // [sp+8h] [bp-Ch]@1
  signed int v7; // [sp+Ch] [bp-8h]@1
  unsigned int v8; // [sp+10h] [bp-4h]@1

  v8 = 0;
  v6 = 0;
  v1 = this;
  v7 = 118;
  do
  {
    if ( v8 >= 0xED )
      break;
    v2 = (int)((char *)v1 + 4 * *((_DWORD *)v1 + 237));
    v3 = *(_DWORD *)v2;
    if ( *(_DWORD *)v2 )
    {
      v4 = *(_DWORD *)(v3 + 16);
      v8 = 0;
      if ( v4 == v3 )
      {
        *(_DWORD *)v2 = 0;
      }
      else
      {
        v3 = *(_DWORD *)(v3 + 16);
        *(_DWORD *)(*(_DWORD *)(v4 + 16) + 12) = *(_DWORD *)(v4 + 12);
        *(_DWORD *)(*(_DWORD *)(v4 + 12) + 16) = *(_DWORD *)(v4 + 16);
      }
      FSPErrorMessages::CResourceModuleInfoTable::Deintern(
        (FSPErrorMessages::CMessageTagCache *)((char *)v1 + 956),
        *(const unsigned __int16 **)v3);
      FSPErrorMessages::CMessageTagCache::DumpTrace(
        v1,
        "CACHE: Purging node from the cache MOD=%s | STRID=%ld | Flags=%X | HashModBuckets=%ld\n",
        *(_DWORD *)v3,
        *(_DWORD *)(v3 + 4),
        *(_DWORD *)(v3 + 8),
        *((_DWORD *)v1 + 237));
      FSPErrorMessages::CMessageTagCache::Free(v1, (void *)v3);
      --v7;
      v6 = 1;
    }
    else
    {
      ++v8;
    }
    *((_DWORD *)v1 + 237) = (*((_DWORD *)v1 + 237) + 1) % 0xEDu;
  }
  while ( v7 );
  HeapCompact(*((HANDLE *)v1 + 238), 0);
  return v6;
}

//----- (77E9423C) --------------------------------------------------------
void *__thiscall FSPErrorMessages::CMessageTagCache::Alloc(FSPErrorMessages::CMessageTagCache *this, ULONG Size)
{
  FSPErrorMessages::CMessageTagCache *v2; // esi@1
  PVOID v3; // edi@2

  v2 = this;
  do
    v3 = RtlAllocateHeap(*((HANDLE *)v2 + 238), 0, Size);
  while ( !v3 && FSPErrorMessages::CMessageTagCache::ReclaimMemory(v2) == 1 );
  return v3;
}

//----- (77E94275) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CMessageTagCache::Insert(FSPErrorMessages::CMessageTagCache *this, struct FSPErrorMessages::MessageTag *a2, const unsigned __int16 *a3, void **a4)
{
  FSPErrorMessages::CMessageTagCache *v4; // ebx@1
  signed int result; // eax@2
  signed int v6; // ebx@6
  void *v7; // ebx@10
  unsigned __int32 v8; // eax@12
  void *v9; // eax@12
  FSPErrorMessages::CMessageTagCache *v10; // ecx@16
  signed int v11; // esi@21
  unsigned __int16 *v12; // [sp+10h] [bp-38h]@6
  int v13; // [sp+14h] [bp-34h]@10
  int v14; // [sp+18h] [bp-30h]@10
  void *v15; // [sp+1Ch] [bp-2Ch]@10
  unsigned __int32 v16; // [sp+20h] [bp-28h]@1
  int v17; // [sp+24h] [bp-24h]@6
  FSPErrorMessages::CMessageTagCache *v18; // [sp+28h] [bp-20h]@1
  char v19; // [sp+2Fh] [bp-19h]@1
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@10
  unsigned int v21; // [sp+54h] [bp+Ch]@3

  v4 = this;
  v18 = this;
  FSPErrorMessages::CMessageHashVectorBuilder::CMessageHashVectorBuilder((FSPErrorMessages::CMessageHashVectorBuilder *)&v19);
  v16 = FSPErrorMessages::CMessageHashVectorBuilder::NormalizeString(a3, (unsigned __int16 *)v4 + 554, 0x400u);
  if ( v16
    && (v21 = FSPErrorMessages::CMessageHashVectorBuilder::GetCombinedIndexHash((const unsigned __int16 *)v4 + 554)) != 0 )
  {
    while ( 1 )
    {
      v6 = FSPErrorMessages::CResourceModuleInfoTable::Intern(
             (FSPErrorMessages::CMessageTagCache *)((char *)v4 + 956),
             *(LPCWSTR *)a2,
             (const unsigned __int16 **)&v12);
      v17 = v6;
      if ( v6 != -2147024882 || FSPErrorMessages::CMessageTagCache::ReclaimMemory(v18) != 1 )
        break;
      v4 = v18;
    }
    if ( v6 >= 0 )
    {
      v13 = *((_DWORD *)a2 + 1);
      v14 = *((_DWORD *)a2 + 2);
      v7 = 0;
      v15 = 0;
      ms_exc.registration.TryLevel = 0;
      if ( FSPErrorMessages::CMessageTagCache::LookupNodeByMessageTag(
             v18,
             v21,
             (struct FSPErrorMessages::MessageTag *)&v12) )
      {
        v17 = 1;
      }
      else
      {
        v8 = FSPErrorMessages::CMessageHashVectorBuilder::GetMessageHashVectorSize(v16);
        v9 = FSPErrorMessages::CMessageTagCache::Alloc(v18, v8 + 23);
        v7 = v9;
        v15 = v9;
        if ( v9 )
        {
          *(_DWORD *)v9 = 0;
          if ( FSPErrorMessages::CMessageHashVectorBuilder::Construct(
                 (const unsigned __int16 *)v18 + 554,
                 v16,
                 (struct FSPErrorMessages::CMessageHashVector *)((char *)v9 + 20)) )
          {
            *(_DWORD *)v7 = v12;
            *((_DWORD *)v7 + 1) = v13;
            *((_DWORD *)v7 + 2) = v14;
            v10 = v18;
            *((_DWORD *)v7 + 3) = *((_DWORD *)v18 + v21 % 0xED);
            FSPErrorMessages::CMessageTagCache::InsertNode(v10, v21, (struct Node *)v7);
            if ( a4 )
              *a4 = v7;
            v17 = 0;
          }
          else
          {
            v17 = -2146951859;
          }
        }
        else
        {
          v17 = -2147024882;
        }
      }
      ms_exc.registration.TryLevel = -2;
      v11 = v17;
      if ( v17 == 1 || v17 < 0 )
      {
        FSPErrorMessages::CResourceModuleInfoTable::Deintern(
          (FSPErrorMessages::CMessageTagCache *)((char *)v18 + 956),
          v12);
        if ( v11 < 0 )
        {
          if ( v7 )
            FSPErrorMessages::CMessageTagCache::Free(v18, v7);
        }
      }
      result = v11;
    }
    else
    {
      result = v6;
    }
  }
  else
  {
    result = -2146951859;
  }
  return result;
}

//----- (77E94429) --------------------------------------------------------
FSPErrorMessages::CMessageHashVectorBuilder *__thiscall FSPErrorMessages::CMessageHashVectorBuilder::CMessageHashVectorBuilder(FSPErrorMessages::CMessageHashVectorBuilder *this)
{
  return this;
}

//----- (77E94431) --------------------------------------------------------
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetPrintfFormatStringLength(const unsigned __int16 *lpString)
{
  const unsigned __int16 *v2; // esi@1
  int result; // eax@1
  const wchar_t v4; // ax@2
  const unsigned __int16 v5; // ax@8
  const unsigned __int16 v6; // ax@14
  const unsigned __int16 v7; // ax@18
  const wchar_t v8; // ax@31
  int v9; // [sp+4h] [bp-4h]@1

  v9 = 0;
  v2 = lpString;
  result = lstrlenW(lpString);
  if ( result )
  {
    while ( 1 )
    {
      v4 = *v2;
      if ( *v2 != 45 && v4 != 43 && v4 != 48 && v4 != 32 && v4 != 35 )
        break;
      ++v9;
      ++v2;
    }
    v5 = *v2;
    if ( *v2 == 42 )
    {
      ++v2;
      ++v9;
    }
    else
    {
      while ( v5 >= 0x30u && v5 <= 0x39u )
      {
        ++v2;
        ++v9;
        v5 = *v2;
      }
    }
    if ( *v2 == 46 )
    {
      ++v9;
      ++v2;
      v6 = *v2;
      if ( *v2 == 42 )
      {
        ++v9;
        ++v2;
      }
      else
      {
        if ( v6 < 0x30u || v6 > 0x39u )
          return 0;
        do
        {
          if ( v6 > 0x39u )
            break;
          ++v9;
          ++v2;
          v6 = *v2;
        }
        while ( *v2 >= 0x30u );
      }
    }
    if ( __wcsnicmp(v2, L"I32", 3u) && __wcsnicmp(v2, L"I64", 3u) )
    {
      v7 = *v2;
      if ( *v2 == 104 || v7 == 108 || v7 == 73 )
      {
        ++v2;
        ++v9;
      }
    }
    else
    {
      v2 += 3;
      v9 += 3;
    }
    if ( __wcsnicmp(v2, L"ws", 2u) && __wcsnicmp(v2, L"wc", 2u) )
    {
      v8 = *v2;
      if ( *v2 == 99
        || v8 == 67
        || v8 == 100
        || v8 == 105
        || v8 == 111
        || v8 == 117
        || v8 == 120
        || v8 == 88
        || v8 == 101
        || v8 == 69
        || v8 == 102
        || v8 == 103
        || v8 == 71
        || v8 == 110
        || v8 == 112
        || v8 == 115
        || v8 == 83
        || v8 == 90 )
        result = v9 + 1;
      else
        result = 0;
    }
    else
    {
      result = v9 + 2;
    }
  }
  return result;
}

//----- (77E945F9) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetMessageHashVectorSize(unsigned __int32 a2)
{
  return 4 * a2 + 1;
}

//----- (77E94611) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::HashStringToDword(LPCWSTR lpString, const unsigned __int16 *a2, unsigned int a3)
{
  LPCWSTR v3; // esi@1
  unsigned __int32 v4; // edi@1
  const unsigned __int16 *v5; // edx@3
  signed int v6; // ecx@3
  const WCHAR v7; // ax@5
  signed int v8; // ebx@7
  int v9; // ebx@7
  unsigned __int32 result; // eax@8

  v3 = lpString;
  v4 = 0;
  if ( lpString && lstrlenW(lpString) )
  {
    v5 = a2;
    v6 = 31415;
    if ( !a2 )
      v5 = (const unsigned __int16 *)-1;
    v7 = *lpString;
    if ( *lpString )
    {
      do
      {
        if ( !v5 )
          break;
        v8 = v6;
        v6 *= 27183;
        v9 = v7 + v4 * v8;
        ++v3;
        v7 = *v3;
        v5 = (const unsigned __int16 *)((char *)v5 - 1);
        v4 = v9;
      }
      while ( *v3 );
    }
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (77E94676) --------------------------------------------------------
int __stdcall FSPErrorMessages::HashStringToWord(FSPErrorMessages *this, const unsigned __int16 *a2, unsigned int a3)
{
  unsigned int v3; // eax@1
  unsigned int savedregs; // [sp+0h] [bp+0h]@0

  v3 = FSPErrorMessages::HashStringToDword((LPCWSTR)this, a2, savedregs);
  return v3 ^ (v3 >> 16);
}

//----- (77E94696) --------------------------------------------------------
int __thiscall FSPErrorMessages::CMessageHashVector::Match(FSPErrorMessages::CMessageHashVector *this, const unsigned __int16 *lpString)
{
  FSPErrorMessages *v2; // esi@1
  FSPErrorMessages::CMessageHashVector *v3; // edi@1
  int v4; // ebx@1
  int v6; // eax@5
  int v7; // ebx@7
  unsigned int v8; // eax@12
  unsigned int v9; // [sp+0h] [bp-14h]@0
  int v10; // [sp+Ch] [bp-8h]@1
  signed int v11; // [sp+10h] [bp-4h]@1
  int lpStringa; // [sp+1Ch] [bp+8h]@1

  v11 = 0;
  v2 = (FSPErrorMessages *)lpString;
  v3 = this;
  v4 = *(_BYTE *)this & 0x3F;
  v10 = *(_BYTE *)this & 0x3F;
  lpStringa = lstrlenW(lpString);
  if ( !(*(_BYTE *)v3 & 0x40) )
  {
    if ( lpStringa < (unsigned int)*(_WORD *)((char *)v3 + 1)
      || *(_WORD *)((char *)v3 + 3) != (unsigned __int16)FSPErrorMessages::HashStringToWord(
                                                           v2,
                                                           (const unsigned __int16 *)*(_WORD *)((char *)v3 + 1),
                                                           v9) )
      return 0;
    v6 = *(_WORD *)((char *)v3 + 1);
    lpStringa -= v6;
    v2 = (FSPErrorMessages *)((char *)v2 + 2 * v6);
    v11 = 1;
  }
  if ( v11 < (unsigned int)v4 )
  {
    v7 = (int)((char *)v3 + 4 * v11 + 1);
    do
    {
      if ( !*(_WORD *)v2 )
        break;
      if ( lpStringa < (unsigned int)*(_WORD *)v7 )
        return 0;
      if ( *(_WORD *)(v7 + 2) == (unsigned __int16)FSPErrorMessages::HashStringToWord(
                                                     v2,
                                                     (const unsigned __int16 *)*(_WORD *)v7,
                                                     v9) )
      {
        v8 = *(_WORD *)v7;
        lpStringa -= v8;
        ++v11;
        v2 = (FSPErrorMessages *)((char *)v2 + 2 * v8);
        v7 += 4;
      }
      else
      {
        v2 = (FSPErrorMessages *)((char *)v2 + 2);
        --lpStringa;
      }
    }
    while ( v11 < (unsigned int)v10 );
    v4 = v10;
  }
  if ( v11 != v4 || *(_WORD *)v2 && !(*(_BYTE *)v3 & 0x80) )
    return 0;
  return 1;
}

//----- (77E94754) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetStartIndexHash(const unsigned __int16 *Str)
{
  wchar_t *v2; // eax@1
  unsigned __int32 result; // eax@3
  unsigned int v4; // [sp+0h] [bp-4h]@0

  v2 = _wcschr(Str, 0xDu);
  if ( v2 && (unsigned int)(v2 - Str) < 8 || (unsigned int)lstrlenW(Str) < 8 )
    result = 0;
  else
    result = FSPErrorMessages::HashStringToDword(Str, (const unsigned __int16 *)8, v4);
  return result;
}

//----- (77E94796) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetEndIndexHash(const unsigned __int16 *Str)
{
  unsigned int v2; // esi@1
  wchar_t *v3; // eax@1
  unsigned __int32 result; // eax@3
  unsigned int v5; // [sp+0h] [bp-8h]@0

  v2 = wcslen(Str);
  v3 = _wcsrchr(Str, 0xDu);
  if ( v3 && v2 - (v3 - Str) < 8 || v2 < 8 )
    result = 0;
  else
    result = FSPErrorMessages::HashStringToDword(&Str[v2 - 8], (const unsigned __int16 *)8, v5);
  return result;
}

//----- (77E947F1) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetCombinedIndexHash(const unsigned __int16 *a2)
{
  unsigned __int32 v2; // edi@1

  v2 = FSPErrorMessages::CMessageHashVectorBuilder::GetEndIndexHash(a2);
  return v2 ^ FSPErrorMessages::CMessageHashVectorBuilder::GetStartIndexHash(a2);
}

//----- (77E9481B) --------------------------------------------------------
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::Construct(const unsigned __int16 *Str, unsigned __int32 a3, struct FSPErrorMessages::CMessageHashVector *a4)
{
  struct FSPErrorMessages::CMessageHashVector *v4; // edi@3
  const unsigned __int16 *v5; // eax@3
  const unsigned __int16 *v6; // esi@3
  char *v7; // edi@6
  wchar_t *v8; // eax@7
  int v9; // ebx@8
  signed __int16 v10; // ax@10
  int result; // eax@17
  unsigned int v12; // [sp+0h] [bp-10h]@0
  unsigned __int32 v13; // [sp+Ch] [bp-4h]@5

  if ( a3 <= 0x40 && a3 )
  {
    v4 = a4;
    v5 = Str;
    *(_BYTE *)a4 = a3;
    v6 = Str;
    if ( *Str == 13 )
    {
      *(_BYTE *)a4 = a3 | 0x40;
      v6 = Str + 1;
    }
    v13 = 0;
    if ( a3 )
    {
      v7 = (char *)a4 + 3;
      do
      {
        v8 = _wcschr(v6, 0xDu);
        if ( v8 )
        {
          v9 = v8 - v6;
          if ( !v9 )
            goto LABEL_18;
        }
        else
        {
          v9 = lstrlenW(v6);
        }
        v10 = 511;
        if ( (unsigned int)v9 <= 0x1FF )
          v10 = v9;
        *((_WORD *)v7 - 1) = v10;
        ++v13;
        *(_WORD *)v7 = FSPErrorMessages::HashStringToWord(
                         (FSPErrorMessages *)v6,
                         (const unsigned __int16 *)(unsigned __int16)v10,
                         v12);
        v7 += 4;
        v6 += v9 + 1;
      }
      while ( v13 < a3 );
      v4 = a4;
      v5 = Str;
    }
    if ( v6 > v5 && *(v6 - 1) == 13 )
      *(_BYTE *)v4 |= 0x80u;
    result = 1;
  }
  else
  {
LABEL_18:
    result = 0;
  }
  return result;
}

//----- (77E948D4) --------------------------------------------------------
int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::GetFormatStringLength(const unsigned __int16 *a2)
{
  signed int v2; // ebx@3
  const unsigned __int16 *v3; // esi@3
  const unsigned __int16 v4; // ax@3
  wchar_t *v5; // eax@7
  int result; // eax@8
  unsigned int v7; // eax@9
  int v8; // eax@11
  unsigned __int16 v9; // [sp+10h] [bp-44h]@10

  if ( *a2 < 0x31u || *a2 > 0x39u )
  {
    result = FSPErrorMessages::CMessageHashVectorBuilder::GetPrintfFormatStringLength(a2);
  }
  else
  {
    v2 = 1;
    v3 = a2 + 1;
    v4 = a2[1];
    if ( v4 >= 0x30u && v4 <= 0x39u )
    {
      v3 = a2 + 2;
      v2 = 2;
    }
    if ( *v3 == 33
      && (v5 = _wcschr(v3 + 1, 0x21u)) != 0
      && (v7 = v5 - v3 - 1, v7 <= 0x20)
      && StringCchCopyNW(&v9, 0x20u, v3 + 1, v7) >= 0
      && (v8 = FSPErrorMessages::CMessageHashVectorBuilder::GetPrintfFormatStringLength(&v9)) != 0 )
      result = v8 + v2 + 2;
    else
      result = v2;
  }
  return result;
}

//----- (77E94980) --------------------------------------------------------
signed int __stdcall FSPErrorMessages::CMessageHashVectorBuilder::NormalizeString(const unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int32 a4)
{
  const unsigned __int16 *v4; // esi@1
  unsigned __int32 v5; // eax@3
  unsigned __int16 *v6; // ebx@4
  unsigned __int16 *v7; // edi@4
  const unsigned __int16 v8; // cx@5
  signed __int16 v9; // ax@7
  const unsigned __int16 *v10; // eax@9
  int v11; // eax@10
  signed __int16 v12; // ax@30
  signed int result; // eax@33
  signed int v14; // [sp+14h] [bp+8h]@4
  unsigned __int16 *v15; // [sp+18h] [bp+Ch]@4
  unsigned __int32 v16; // [sp+1Ch] [bp+10h]@4

  v4 = a2;
  if ( !a2 )
    goto LABEL_37;
  if ( !*a2 )
    goto LABEL_37;
  v5 = a4;
  if ( a4 <= 2 )
    goto LABEL_37;
  v16 = 0;
  v6 = a3;
  v7 = a3;
  v15 = &a3[v5 - 1];
  v14 = 1;
  while ( v7 < v15 )
  {
    v8 = *v4;
    if ( !*v4 )
      break;
    if ( v8 == 13 )
      goto LABEL_38;
    if ( v8 != 37 || (v10 = v4 + 1, !v4[1]) )
    {
      v9 = *v4;
      goto LABEL_17;
    }
    ++v4;
    v11 = FSPErrorMessages::CMessageHashVectorBuilder::GetFormatStringLength(v10);
    if ( v11 )
    {
      v4 += v11;
      v9 = 13;
      if ( v7 != v6 )
        ++v14;
      goto LABEL_18;
    }
    v9 = *v4;
    if ( *v4 == 48 )
      break;
    if ( v9 == 13 )
LABEL_38:
      v9 = 10;
LABEL_17:
    ++v4;
LABEL_18:
    if ( (_WORD)v16 != 13 || v9 != 13 )
    {
      if ( v9 != 10 )
      {
        *v7 = v9;
        ++v7;
        v16 = (unsigned __int16)v9;
      }
    }
    else
    {
      --v14;
      v16 = 13;
    }
  }
  *v7 = 0;
  if ( *v6 )
  {
    if ( *(v7 - 1) == 13 )
      --v14;
    if ( v7 == v15 && *v4 )
    {
      if ( *(v7 - 2) == 13 )
        v12 = 0;
      else
        v12 = 13;
      *(v7 - 1) = v12;
    }
    result = v14;
  }
  else
  {
LABEL_37:
    result = 0;
  }
  return result;
}

//----- (77E94A9D) --------------------------------------------------------
int __stdcall FSPErrorMessages::CConfig::GetCurrentUserSID(struct _UNICODE_STRING *UnicodeString)
{
  ULONG v2; // ST10_4@3
  HANDLE v3; // eax@3
  PVOID v5; // ST0C_4@10
  HANDLE v6; // eax@10
  signed int v7; // [sp+10h] [bp-28h]@1
  ULONG ReturnLength; // [sp+14h] [bp-24h]@2
  PVOID TokenInformation; // [sp+18h] [bp-20h]@1
  HANDLE TokenHandle; // [sp+1Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@1

  TokenHandle = 0;
  TokenInformation = 0;
  v7 = 0;
  ms_exc.registration.TryLevel = 0;
  if ( NtOpenProcessToken((HANDLE)0xFFFFFFFF, 8u, &TokenHandle) >= 0
    && NtQueryInformationToken(TokenHandle, TokenUser, 0, 0, &ReturnLength) == -1073741789 )
  {
    v2 = ReturnLength;
    v3 = GetProcessHeap();
    TokenInformation = RtlAllocateHeap(v3, 0, v2);
    if ( TokenInformation )
    {
      if ( NtQueryInformationToken(TokenHandle, TokenUser, TokenInformation, ReturnLength, &ReturnLength) >= 0
        && RtlConvertSidToUnicodeString(UnicodeString, *(PSID *)TokenInformation, 1u) >= 0 )
        v7 = 1;
    }
  }
  ms_exc.registration.TryLevel = -2;
  if ( TokenHandle )
    NtClose(TokenHandle);
  if ( TokenInformation )
  {
    v5 = TokenInformation;
    v6 = GetProcessHeap();
    RtlFreeHeap(v6, 0, v5);
  }
  return v7;
}

//----- (77E94B89) --------------------------------------------------------
BOOL __stdcall FSPErrorMessages::LocalDuplicateTokenEx(HANDLE ExistingTokenHandle, ACCESS_MASK DesiredAccess, unsigned __int32 a3, struct _SECURITY_ATTRIBUTES *a4, TOKEN_TYPE TokenType, PHANDLE NewTokenHandle, void **a7)
{
  void *v7; // ecx@2
  ULONG v8; // eax@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-24h]@4
  int v11; // [sp+18h] [bp-Ch]@1
  struct _SECURITY_ATTRIBUTES *v12; // [sp+1Ch] [bp-8h]@1
  char v13; // [sp+20h] [bp-4h]@1
  char v14; // [sp+21h] [bp-3h]@1

  v12 = a4;
  v11 = 12;
  v13 = 1;
  v14 = 0;
  if ( a3 )
  {
    v7 = *(void **)(a3 + 4);
    v8 = *(_DWORD *)(a3 + 8) != 0 ? 2 : 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  ObjectAttributes.Attributes = v8;
  ObjectAttributes.SecurityQualityOfService = &v11;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.ObjectName = 0;
  ObjectAttributes.SecurityDescriptor = v7;
  return NtDuplicateToken(ExistingTokenHandle, DesiredAccess, &ObjectAttributes, 0, TokenType, NewTokenHandle) >= 0;
}

//----- (77E94C03) --------------------------------------------------------
int __usercall FSPErrorMessages::CConfig::IsSetupInProgress@<eax>(FSPErrorMessages::CConfig *this@<ecx>, unsigned __int32 *a2@<esi>)
{
  int result; // eax@2
  __int32 v3; // esi@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-28h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-10h]@1
  unsigned __int16 v6[2]; // [sp+20h] [bp-8h]@3
  HANDLE KeyHandle; // [sp+24h] [bp-4h]@1

  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\System\\Setup");
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  if ( NtOpenKey(&KeyHandle, 1u, &ObjectAttributes)
    || (v3 = FSPErrorMessages::ReadDwordFromRegistry(KeyHandle, L"SystemSetupInProgress", v6, a2),
        NtClose(KeyHandle),
        v3 < 0) )
    result = 0;
  else
    result = *(_DWORD *)v6 != 0;
  return result;
}

//----- (77E94C83) --------------------------------------------------------
int __stdcall FSPErrorMessages::CConfig::GetTracingEnabledValueFromKey(void *KeyHandle)
{
  int result; // eax@2
  unsigned __int32 *savedregs; // [sp+0h] [bp+0h]@0

  if ( FSPErrorMessages::ReadDwordFromRegistry(
         KeyHandle,
         L"EnableTracing",
         (const unsigned __int16 *)&KeyHandle,
         savedregs) >= 0 )
    result = KeyHandle != 0;
  else
    result = 0;
  return result;
}

//----- (77E94CD1) --------------------------------------------------------
unsigned __int32 __stdcall FSPErrorMessages::CConfig::GetHeapSizeFromKey(void *KeyHandle)
{
  unsigned __int32 result; // eax@2
  unsigned __int32 *savedregs; // [sp+0h] [bp+0h]@0

  if ( FSPErrorMessages::ReadDwordFromRegistry(
         KeyHandle,
         L"MessageMappingHeapSize",
         (const unsigned __int16 *)&KeyHandle,
         savedregs) >= 0 )
    result = (unsigned int)(((_DWORD)KeyHandle << 10) - 4097) <= 0xFEFFE ? (_DWORD)KeyHandle << 10 : 0;
  else
    result = 0;
  return result;
}

//----- (77E94D3F) --------------------------------------------------------
int __thiscall FSPErrorMessages::CConfig::OpenPerUserKey(FSPErrorMessages::CConfig *this)
{
  HANDLE *v1; // edi@1
  int result; // eax@2
  int v3; // eax@4
  int v4; // ebx@4
  ULONG v5; // ST0C_4@5
  HANDLE v6; // eax@5
  WCHAR *v7; // eax@5
  PWCH v8; // ST08_4@14
  HANDLE v9; // eax@14
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+10h] [bp-58h]@9
  LSA_UNICODE_STRING v11; // [sp+28h] [bp-40h]@3
  LSA_UNICODE_STRING DestinationString; // [sp+30h] [bp-38h]@3
  UNICODE_STRING Source; // [sp+38h] [bp-30h]@3
  LSA_UNICODE_STRING Destination; // [sp+40h] [bp-28h]@3
  int v15; // [sp+48h] [bp-20h]@4
  FSPErrorMessages::CConfig *v16; // [sp+4Ch] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+50h] [bp-18h]@3

  v16 = this;
  v1 = (HANDLE *)((char *)this + 4);
  if ( *((_DWORD *)this + 1) )
  {
    result = 1;
  }
  else
  {
    Source.Buffer = 0;
    Destination.Buffer = 0;
    ms_exc.registration.TryLevel = 0;
    RtlInitUnicodeString(&DestinationString, L"\\Registry\\User\\");
    RtlInitUnicodeString(&v11, L"\\Software\\Microsoft\\Windows\\Windows Error Reporting\\WMR");
    if ( FSPErrorMessages::CConfig::GetCurrentUserSID(&Source) )
    {
      v3 = Source.Length + v11.Length;
      v4 = v3 + DestinationString.Length + 2;
      v15 = v4;
      if ( (unsigned int)v4 <= 0xFFFE )
      {
        v5 = v3 + DestinationString.Length + 2;
        v6 = GetProcessHeap();
        v7 = (WCHAR *)RtlAllocateHeap(v6, 0, v5);
        Destination.Length = 0;
        Destination.MaximumLength = v4;
        Destination.Buffer = v7;
        if ( v7 )
        {
          if ( !RtlAppendUnicodeStringToString(&Destination, &DestinationString)
            && !RtlAppendUnicodeStringToString(&Destination, &Source)
            && !RtlAppendUnicodeStringToString(&Destination, &v11) )
          {
            ObjectAttributes.Length = 24;
            ObjectAttributes.RootDirectory = 0;
            ObjectAttributes.Attributes = 64;
            ObjectAttributes.ObjectName = &Destination;
            ObjectAttributes.SecurityDescriptor = 0;
            ObjectAttributes.SecurityQualityOfService = 0;
            if ( NtOpenKey(v1, 1u, &ObjectAttributes) )
              *v1 = 0;
          }
        }
      }
    }
    ms_exc.registration.TryLevel = -2;
    RtlFreeUnicodeString(&Source);
    if ( Destination.Buffer )
    {
      v8 = Destination.Buffer;
      v9 = GetProcessHeap();
      RtlFreeHeap(v9, 0, v8);
    }
    result = *((_DWORD *)v16 + 1) != 0;
  }
  return result;
}

//----- (77E94F09) --------------------------------------------------------
int __stdcall FSPErrorMessages::LocalDuplicateToken(FSPErrorMessages *this, void *a2, enum _SECURITY_IMPERSONATION_LEVEL NewTokenHandle, void **a4)
{
  void **savedregs; // [sp+0h] [bp+0h]@0

  return FSPErrorMessages::LocalDuplicateTokenEx(
           (HANDLE)this,
           0xCu,
           0,
           (struct _SECURITY_ATTRIBUTES *)a2,
           TokenImpersonation,
           (PHANDLE)NewTokenHandle,
           savedregs);
}

//----- (77E94F2B) --------------------------------------------------------
bool __stdcall FSPErrorMessages::CConfig::CheckTokenMembership(void *a2, void *a3, int *a4)
{
  HLOCAL v4; // edi@1
  SIZE_T v5; // esi@3
  HLOCAL v6; // eax@3
  NTSTATUS v7; // esi@4
  int v8; // esi@6
  void **v10; // [sp+0h] [bp-78h]@0
  GENERIC_MAPPING GenericMapping; // [sp+Ch] [bp-6Ch]@1
  ULONG PrivilegeSetLength; // [sp+1Ch] [bp-5Ch]@1
  int *v13; // [sp+20h] [bp-58h]@1
  void *v14; // [sp+24h] [bp-54h]@1
  BOOLEAN AccessStatus[4]; // [sp+28h] [bp-50h]@1
  ACCESS_MASK GrantedAccess; // [sp+2Ch] [bp-4Ch]@1
  HANDLE TokenHandle; // [sp+30h] [bp-48h]@1
  PSID Sid; // [sp+34h] [bp-44h]@1
  HANDLE Handle; // [sp+38h] [bp-40h]@1
  struct _PRIVILEGE_SET PrivilegeSet; // [sp+3Ch] [bp-3Ch]@11

  Sid = a3;
  v4 = 0;
  v14 = a2;
  v13 = a4;
  TokenHandle = 0;
  Handle = 0;
  GenericMapping.GenericRead = 0x20000;
  GenericMapping.GenericWrite = 0x20000;
  GenericMapping.GenericExecute = 0x20000;
  GenericMapping.GenericAll = 2031616;
  PrivilegeSetLength = 56;
  GrantedAccess = 0;
  *(_DWORD *)AccessStatus = 0;
  *a4 = 0;
  if ( a2 )
  {
    Handle = a2;
    goto LABEL_3;
  }
  v7 = NtOpenProcessToken((HANDLE)0xFFFFFFFF, 0xAu, &TokenHandle);
  if ( v7 >= 0 )
  {
    v8 = FSPErrorMessages::LocalDuplicateToken(
           (FSPErrorMessages *)TokenHandle,
           (void *)2,
           (enum _SECURITY_IMPERSONATION_LEVEL)&Handle,
           v10);
    CloseHandle(TokenHandle);
    if ( !v8 )
      return 0;
LABEL_3:
    v5 = 3 * RtlLengthSid(Sid) + 40;
    v6 = LocalAlloc(0x40u, v5);
    v4 = v6;
    if ( v6 )
    {
      RtlCreateSecurityDescriptor(v6, 1u);
      RtlSetOwnerSecurityDescriptor(v4, Sid, 0);
      RtlSetGroupSecurityDescriptor(v4, Sid, 0);
      v7 = RtlCreateAcl((PACL)((char *)v4 + 20), v5 - 20, 2u);
      if ( v7 >= 0 )
      {
        v7 = RtlAddAccessAllowedAce((PACL)((char *)v4 + 20), 2u, 1u, Sid);
        if ( v7 >= 0 )
        {
          v7 = RtlSetDaclSecurityDescriptor(v4, 1u, (PACL)((char *)v4 + 20), 0);
          if ( v7 >= 0 )
          {
            v7 = NtAccessCheck(
                   v4,
                   Handle,
                   1u,
                   &GenericMapping,
                   &PrivilegeSet,
                   &PrivilegeSetLength,
                   &GrantedAccess,
                   AccessStatus);
            if ( v7 >= 0 && !*(_DWORD *)AccessStatus && GrantedAccess == 1 )
              *v13 = 1;
          }
        }
      }
    }
    else
    {
      v7 = -1073741670;
    }
    if ( v14 )
      goto LABEL_18;
  }
  if ( Handle )
    NtClose(Handle);
LABEL_18:
  if ( v4 )
    LocalFree(v4);
  return v7 >= 0;
}

//----- (77E950BD) --------------------------------------------------------
int FSPErrorMessages::CConfig::IsInteractiveUser()
{
  int v1; // eax@2
  int v3; // [sp+8h] [bp-14h]@1
  PSID Sid; // [sp+Ch] [bp-10h]@1
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [sp+10h] [bp-Ch]@1

  IdentifierAuthority.Value[0] = 0;
  IdentifierAuthority.Value[1] = 0;
  IdentifierAuthority.Value[2] = 0;
  IdentifierAuthority.Value[3] = 0;
  IdentifierAuthority.Value[4] = 0;
  IdentifierAuthority.Value[5] = 5;
  Sid = 0;
  v3 = 0;
  if ( !RtlAllocateAndInitializeSid(&IdentifierAuthority, 1, 4u, 0, 0, 0, 0, 0, 0, 0, &Sid) )
  {
    LOBYTE(v1) = FSPErrorMessages::CConfig::CheckTokenMembership(0, Sid, &v3);
    if ( !v1 )
      v3 = 0;
  }
  if ( Sid )
    RtlFreeSid(Sid);
  return v3;
}

//----- (77E95145) --------------------------------------------------------
unsigned __int32 __thiscall FSPErrorMessages::CConfig::GetHeapSize(FSPErrorMessages::CConfig *this)
{
  FSPErrorMessages::CConfig *v1; // esi@1
  unsigned __int32 result; // eax@2

  v1 = this;
  if ( !FSPErrorMessages::CConfig::OpenPerUserKey(this)
    || (result = FSPErrorMessages::CConfig::GetHeapSizeFromKey(*((void **)v1 + 1))) == 0 )
  {
    if ( !FSPErrorMessages::CConfig::OpenMachineKey((PHANDLE)v1)
      || (result = FSPErrorMessages::CConfig::GetHeapSizeFromKey(*(void **)v1)) == 0 )
      result = 0x10000;
  }
  return result;
}

//----- (77E95185) --------------------------------------------------------
void __stdcall FSPErrorMessages::CConfig::GetAppName(unsigned __int16 *a2)
{
  PWCH v2; // ecx@2
  const unsigned __int16 *i; // eax@2

  if ( a2 )
  {
    v2 = NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Buffer;
    for ( i = &v2[((unsigned int)NtCurrentTeb()->ProcessEnvironmentBlock->ProcessParameters->ImagePathName.Length >> 1)
                - 1]; i > v2; --i )
    {
      if ( *i == 92 || *i == 47 )
      {
        ++i;
        break;
      }
    }
    StringCchCopyW(a2, 0x104u, i);
  }
}

//----- (77E951E7) --------------------------------------------------------
int FSPErrorMessages::CConfig::IsRestrictedProcess()
{
  unsigned int v1; // esi@1
  wchar_t v3; // [sp+4h] [bp-20Ch]@1

  FSPErrorMessages::CConfig::GetAppName(&v3);
  v1 = 0;
  while ( __wcsicmp(off_77E95240[v1], &v3) )
  {
    ++v1;
    if ( v1 >= 3 )
      return 0;
  }
  return 1;
}
// 77E95240: using guessed type wchar_t *off_77E95240[3];

//----- (77E95251) --------------------------------------------------------
int FSPErrorMessages::CConfig::IsTracedProcess()
{
  unsigned int v1; // esi@1
  wchar_t v3; // [sp+4h] [bp-20Ch]@1

  FSPErrorMessages::CConfig::GetAppName(&v3);
  v1 = 0;
  while ( __wcsicmp(off_77E952AC[v1], &v3) )
  {
    ++v1;
    if ( v1 >= 5 )
      return 0;
  }
  return 1;
}
// 77E952AC: using guessed type wchar_t *off_77E952AC[5];

//----- (77E952C5) --------------------------------------------------------
BOOL __thiscall FSPErrorMessages::CConfig::IsTracingEnabled(FSPErrorMessages::CConfig *this)
{
  void **v1; // esi@1

  v1 = (void **)this;
  return FSPErrorMessages::CConfig::OpenMachineKey((PHANDLE)this)
      && FSPErrorMessages::CConfig::GetTracingEnabledValueFromKey(*v1) == 1
      && FSPErrorMessages::CConfig::IsTracedProcess();
}

//----- (77E952FA) --------------------------------------------------------
void __thiscall FSPErrorMessages::CResourceModuleInfoTable::Init(FSPErrorMessages::CResourceModuleInfoTable *this, void *a2)
{
  *(_DWORD *)this = a2;
  memset((char *)this + 4, 0, 0x94u);
}

//----- (77E95320) --------------------------------------------------------
int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Lookup(FSPErrorMessages::CResourceModuleInfoTable *this, const unsigned __int16 *lpString, unsigned int *a3, struct FSPErrorMessages::CResourceModuleInfoTable::Bucket **a4)
{
  FSPErrorMessages::CResourceModuleInfoTable *v4; // esi@1
  int v5; // eax@1
  int i; // esi@1
  unsigned int v8; // [sp+0h] [bp-8h]@0

  v4 = this;
  v5 = lstrlenW(lpString);
  *a3 = FSPErrorMessages::HashStringToDword(lpString, (const unsigned __int16 *)v5, v8) % 0x25;
  *a4 = 0;
  for ( i = *((_DWORD *)v4 + *a3 + 1); ; i = *(_DWORD *)(i + 8) )
  {
    if ( !i )
      return 0;
    if ( !__wcsicmp(lpString, *(const wchar_t **)i) )
      break;
    *a4 = (struct FSPErrorMessages::CResourceModuleInfoTable::Bucket *)i;
  }
  return i;
}

//----- (77E9537F) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Deintern(FSPErrorMessages::CResourceModuleInfoTable *this, const unsigned __int16 *a2)
{
  FSPErrorMessages::CResourceModuleInfoTable *v2; // ebx@1
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2
  bool v6; // zf@3
  unsigned int v7; // [sp+8h] [bp-4h]@1

  v2 = this;
  v3 = FSPErrorMessages::CResourceModuleInfoTable::Lookup(
         this,
         a2,
         &v7,
         (struct FSPErrorMessages::CResourceModuleInfoTable::Bucket **)&a2);
  v4 = (void *)v3;
  if ( v3 )
  {
    v6 = (*(_DWORD *)(v3 + 4))-- == 1;
    if ( v6 )
    {
      if ( a2 )
        *((_DWORD *)a2 + 2) = *(_DWORD *)(v3 + 8);
      else
        *((_DWORD *)v2 + v7 + 1) = *(_DWORD *)(v3 + 8);
      RtlFreeHeap(*(HANDLE *)v2, 0, *(PVOID *)v3);
      RtlFreeHeap(*(HANDLE *)v2, 0, v4);
    }
    result = 0;
  }
  else
  {
    result = -2147023728;
  }
  return result;
}

//----- (77E953E8) --------------------------------------------------------
signed int __thiscall FSPErrorMessages::CResourceModuleInfoTable::Intern(FSPErrorMessages::CResourceModuleInfoTable *this, LPCWSTR lpString, const unsigned __int16 **a3)
{
  FSPErrorMessages::CResourceModuleInfoTable *v3; // edi@1
  int v4; // eax@1
  unsigned int v5; // edi@3
  PVOID v7; // eax@5
  PVOID v8; // esi@5
  int v9; // eax@7
  unsigned int v10; // ebx@7
  unsigned __int16 *v11; // eax@7
  signed int v12; // ebx@8
  unsigned int v13; // eax@12
  struct FSPErrorMessages::CResourceModuleInfoTable::Bucket *v14; // [sp+8h] [bp-8h]@1
  unsigned int v15; // [sp+Ch] [bp-4h]@1

  *a3 = 0;
  v3 = this;
  v4 = FSPErrorMessages::CResourceModuleInfoTable::Lookup(this, lpString, &v15, &v14);
  if ( !v4 )
  {
    v7 = RtlAllocateHeap(*(HANDLE *)v3, 0, 0xCu);
    v8 = v7;
    if ( !v7 )
      return -2147024882;
    *((_DWORD *)v7 + 1) = 1;
    v9 = lstrlenW(lpString);
    v10 = v9 + 1;
    v11 = (unsigned __int16 *)RtlAllocateHeap(*(HANDLE *)v3, 0, 2 * (v9 + 1));
    *(_DWORD *)v8 = v11;
    if ( v11 )
    {
      v12 = StringCchCopyW(v11, v10, lpString);
      if ( v12 >= 0 )
      {
        v13 = (unsigned int)((char *)v3 + 4 * v15 + 4);
        *((_DWORD *)v8 + 2) = *(_DWORD *)v13;
        *(_DWORD *)v13 = v8;
        *a3 = *(const unsigned __int16 **)v8;
        return 0;
      }
      RtlFreeHeap(*(HANDLE *)v3, 0, *(PVOID *)v8);
    }
    else
    {
      v12 = -2147024882;
    }
    RtlFreeHeap(*(HANDLE *)v3, 0, v8);
    return v12;
  }
  if ( v14 )
  {
    *((_DWORD *)v14 + 2) = *(_DWORD *)(v4 + 8);
    v5 = (unsigned int)((char *)v3 + 4 * v15 + 4);
    *(_DWORD *)(v4 + 8) = *(_DWORD *)v5;
    *(_DWORD *)v5 = v4;
  }
  *a3 = *(const unsigned __int16 **)v4;
  ++*(_DWORD *)(v4 + 4);
  return 0;
}

#error "There were 3 decompilation failure(s) on 2632 function(s)"
