/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// void __stdcall RtlInitUnicodeString(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// NTSTATUS __stdcall NtOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
// NTSTATUS __stdcall NtCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
// NTSTATUS __stdcall NtDeviceIoControlFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, ULONG IoControlCode, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// NTSTATUS __stdcall NtClose(HANDLE Handle);
// int __stdcall RtlGetNtProductType(_DWORD); weak
// NTSTATUS __stdcall NtOpenEvent(PHANDLE EventHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);
// ULONG __stdcall RtlNtStatusToDosError(NTSTATUS NtStatus);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// LPWSTR __stdcall PathFindFileNameW(LPCWSTR pszPath);
// LPWSTR __stdcall PathCombineW(LPWSTR pszDest, LPCWSTR pszDir, LPCWSTR pszFile);
// LSTATUS __stdcall SHDeleteKeyW(HKEY hkey, LPCWSTR pszSubKey);
// int __stdcall SHLoadRegUIStringW(_DWORD, _DWORD, _DWORD, _DWORD); weak
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// void __stdcall Sleep(DWORD dwMilliseconds);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
// BOOL __stdcall DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
// void __stdcall SetLastError(DWORD dwErrCode);
// HANDLE __stdcall OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
// void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);
// UINT __stdcall GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
// BOOL __stdcall IsWow64Process(HANDLE hProcess, PBOOL Wow64Process);
// LSTATUS __stdcall RegFlushKey(HKEY hKey);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// LONG __stdcall CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// HANDLE __stdcall GetProcessHeap();
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);
// BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// UINT __stdcall SetHandleCount(UINT uNumber);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// DWORD __stdcall GetFileType(HANDLE hFile);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall FreeEnvironmentStringsA(LPCH);
// LPCH __stdcall GetEnvironmentStrings();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// LPWCH __stdcall GetEnvironmentStringsW();
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall GetTickCount();
// DWORD __stdcall GetCurrentProcessId();
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// UINT __stdcall GetACP();
// UINT __stdcall GetOEMCP();
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// HANDLE __stdcall GetCurrentThread();
// UINT __stdcall GetConsoleCP();
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// HANDLE __stdcall CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// LSTATUS __stdcall RegGetValueW(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
// LSTATUS __stdcall RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
// LSTATUS __stdcall RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags);
// BOOL __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
// ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, ULONG TypeMask, UCHAR Condition);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
// LSTATUS __stdcall RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// int __stdcall lstrlenA(LPCSTR lpString);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);
// LSTATUS __stdcall RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// LSTATUS __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// DWORD __stdcall GetCurrentThreadId();
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// DWORD __stdcall GetLastError();
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// int __stdcall lstrlenW(LPCWSTR lpString);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// BOOL __stdcall InitiateSystemShutdownExW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);
// BOOL __stdcall SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted);
// BOOL __stdcall SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted);
// BOOL __stdcall StartServiceW(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCWSTR *lpServiceArgVectors);
// BOOL __stdcall QueryServiceConfigW(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGW lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// BOOL __stdcall ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// BOOL __stdcall EnumDependentServicesW(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// DWORD __stdcall GetSidLengthRequired(UCHAR nSubAuthorityCount);
// BOOL __stdcall InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount);
// PDWORD __stdcall GetSidSubAuthority(PSID pSid, DWORD nSubAuthority);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// BOOL __stdcall ChangeServiceConfigW(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword, LPCWSTR lpDisplayName);
// SC_HANDLE __stdcall OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// SC_HANDLE __stdcall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);
// BOOL __stdcall QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// BOOL __stdcall OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
// LSTATUS __stdcall RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey);
// BOOL __stdcall EqualSid(PSID pSid1, PSID pSid2);
// BOOL __stdcall AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);
// BOOL __stdcall InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// BOOL __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// BOOL __stdcall GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// int __stdcall SaveDC(HDC hdc);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// BOOL __stdcall GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
// HRESULT __stdcall CoCreateInstance(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// LPVOID __stdcall CoTaskMemRealloc(LPVOID pv, SIZE_T cb);
// LPVOID __stdcall CoTaskMemAlloc(SIZE_T cb);
// void __stdcall CoTaskMemFree(LPVOID pv);
// int __stdcall StringFromGUID2(const GUID *const rguid, LPOLESTR lpsz, int cchMax);
// HRESULT __stdcall IIDFromString(LPCOLESTR lpsz, LPIID lpiid);
// HRESULT __stdcall CoCreateGuid(GUID *pguid);
// void __stdcall CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved);
// HRESULT __stdcall CoSetProxyBlanket(IUnknown *pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities);
// HRESULT __stdcall CoImpersonateClient();
// HRESULT __stdcall CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);
// void __stdcall CoUninitialize();
// HRESULT __stdcall CoRevertToSelf();
// HRESULT __stdcall VarI4FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, LONG *plOut);
// INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// int __stdcall GetSystemMetrics(int nIndex);
// HDC __stdcall GetDC(HWND hWnd);
// BOOL __stdcall CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck);
// BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HWND __stdcall GetFocus();
// HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
// DWORD __stdcall GetMessagePos();
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// UINT __stdcall GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);
// BOOL __stdcall WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
// UINT __stdcall IsDlgButtonChecked(HWND hDlg, int nIDButton);
// BOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
// BOOL __stdcall SetProcessDPIAware();
// LPWSTR __stdcall CharNextW(LPCWSTR lpsz);
// LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex);
// LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// LRESULT __stdcall DispatchMessageW(const MSG *lpMsg);
// DWORD __stdcall MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
// HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem);
// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// HWND __stdcall GetParent(HWND hWnd);
// LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);
// int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
// int __stdcall GetWindowTextLengthW(HWND hWnd);
// HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// BOOL __stdcall IsWindow(HWND hWnd);
// HCURSOR __stdcall SetCursor(HCURSOR hCursor);
// LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall DestroyMenu(HMENU hMenu);
// BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// HMENU __stdcall CreatePopupMenu();
// BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable);
// HWND __stdcall SetFocus(HWND hWnd);
// _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD); weak
HRESULT __stdcall DllCanUnloadNow();
// void __fastcall __security_check_cookie(uintptr_t StackCookie);
void __cdecl operator delete(void *lpMem); // idb
void __stdcall MemFree(void *lpMem); // idb
LONG __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::Release(void *lpMem);
void *__cdecl memset(void *Dst, int Val, size_t Size);
// void __cdecl sub_6E641724(int a1, int a2, void *a3, void *a4);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(int this, int a2);
signed int __thiscall CImplINetCfg::HrCheckForReentrancy(CImplINetCfg *this, unsigned __int32 a2);
signed int __thiscall CImplINetCfg::HrLockAndTestForValidInterface(CImplINetCfg *this, unsigned __int32 a2);
unsigned int __stdcall CbOfSzAndTerm(const unsigned __int16 *a1);
signed int __stdcall FIsConsideredNetClass(int a1);
int __thiscall CBindingSet::FContainsBindPath(CBindingSet *this, const struct CBindPath *); // idb
int __cdecl std::fill<CFilteredAdapter * *,CFilteredAdapter *>(int a1, int a2, int a3);
void *__cdecl operator new(SIZE_T dwBytes); // idb
unsigned __int32 __stdcall CchToCb(unsigned __int32); // idb
__int32 __stdcall HrFromLastWin32Error(); // idb
int __stdcall CchOfSzSafe(const unsigned __int16 *a1);
// signed int __userpurge sub_6E641D2F@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
__int32 __stdcall HrSetupDiOpenDevRegKey(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, REGSAM samDesired, HKEY *); // idb
int __stdcall std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2);
int __thiscall CBindPath::FIsSameBindPathAs(CBindPath *this, const struct CBindPath *); // idb
int __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::size(int this);
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Insert_n(int, void *Src, int, int); // idb
char *__stdcall std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(void *Src, int a2, void *Dst, int a4);
char *__stdcall std::_Uninit_copy<CFilterMapEntry * *,CFilterMapEntry * *,std::nc_allocator<CFilterMapEntry *>>(void *Src, int a2, void *Dst, int a4, int a5, int a6);
errno_t __cdecl memmove_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
void *__stdcall std::_Destroy<CBindPath>(void *lpMem);
void *__thiscall CBindPath::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(int this);
int __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(int this);
__int32 __thiscall CComponentList::HrInsertComponent(CComponentList *this, const struct CComponent *, unsigned __int32); // idb
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert(int, int, void *Src, int); // idb
void (__cdecl *__stdcall std::_Construct<CBindPath,CBindPath>(int a1, int a2))(int a1, int a2);
int __thiscall CBindPath::CBindPath(int this, int a2);
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::vector<CComponent *,std::nc_allocator<CComponent *>>(void *this, int a2);
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>,CComponent * *,std::nc_allocator<CComponent *>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<std::_Vector_iterator<unsigned short const *,std::nc_allocator<unsigned short const *>>,unsigned short const * *,std::nc_allocator<unsigned short const *>>(int a1, int a2, int a3, int a4, int a5, int a6);
void *__thiscall CComponentList::CComponentList(void *this);
char __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(int this, int a2);
void *__stdcall std::_Allocate<unsigned short const *>(int a1, int a2);
void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
int __cdecl sub_6E64261E(int a1, int a2, int a3);
void __cdecl sub_6E642684(int a1, unsigned int a2);
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(int this);
void __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy(int this);
void *__stdcall std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(void *lpMem, int a2, int a3);
void *__stdcall std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(void *lpMem, int a2, int a3, int a4);
__int32 __thiscall CBindPath::HrAppendComponent(CBindPath *this, const struct CComponent *); // idb
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back(int, int); // idb
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Ufill(int this, int a2, int a3, int a4);
void (__cdecl *__stdcall stdext::unchecked_uninitialized_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4))(int a1, int a2);
void (__cdecl *__stdcall std::_Uninit_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6))(int a1, int a2);
signed int __thiscall CImplINetCfg::HrIsValidInterface(CImplINetCfg *this, unsigned __int32 a2);
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::capacity(int this);
__int32 __thiscall CBindingSet::HrAddBindPath(CBindingSet *this, const struct CBindPath *, unsigned __int32); // idb
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::insert(int this, int a2, int a3, int a4);
void __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Insert_n(void *this, int a2, int a3, int a4);
int __stdcall std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6);
__int32 __thiscall HrRegGetTypeWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int32 a4, unsigned __int8 **a5, unsigned __int32 *a6);
__int32 __stdcall HrRegGetValueWithAlloc(HKEY, const unsigned __int16 *, unsigned __int32 *, unsigned __int8 **, unsigned __int32 *); // idb
__int32 __stdcall HrRegGetValue(HKEY, const unsigned __int16 *, unsigned __int32 *, unsigned __int8 *, unsigned __int32 *); // idb
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(void *lpMem);
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(void *lpMem);
void __stdcall ReleaseIUnknownArray(unsigned __int32, struct IUnknown **); // idb
unsigned __int32 __stdcall ReleaseObj(struct IUnknown *); // idb
void *__stdcall std::_Allocate<CBindPath>(int a1, int a2);
void *__cdecl operator new(SIZE_T dwBytes);
void *__stdcall MemAlloc(SIZE_T dwBytes); // idb
void *__stdcall GetHeap(); // idb
__int32 __stdcall HrOpenNetworkKey(REGSAM samDesired, PHKEY phkResult); // idb
__int32 __stdcall HrRegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, PHKEY phkResult); // idb
int __thiscall CComponentList::FComponentInList(CComponentList *this, const struct CComponent *); // idb
int __stdcall std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(int a1, int a2, int a3, int a4);
int __thiscall std::vector<unsigned short const *,std::nc_allocator<unsigned short const *>>::_Ufill(int this, int a2, int a3, int a4);
void __stdcall stdext::unchecked_uninitialized_fill_n<CComponent * *,unsigned int,CComponent *,std::nc_allocator<CComponent *>>(int a1, int a2, int a3, int a4);
void __cdecl stdext::unchecked_fill_n<CFilterDevice * *,unsigned int,CFilterDevice *>(int a1, int a2, int a3);
void __cdecl std::_Fill_n<CFilterMapEntry * *,unsigned int,CFilterMapEntry *>(int a1, int a2, int a3);
signed int __stdcall HrCoTaskMemAllocAndDupSz(const unsigned __int16 *a1, unsigned __int16 **a2, unsigned __int32 a3);
signed int __stdcall HrCoTaskMemAllocAndDupSzLen(const unsigned __int16 *a1, unsigned __int32 a2, unsigned __int16 **a3, unsigned __int32 a4);
signed int __stdcall StringCbCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4);
void __stdcall SetupDiDestroyDeviceInfoListSafe(void *); // idb
int __stdcall IsValidHandle(void *); // idb
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1);
// int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD); weak
int __stdcall ATL::InlineIsEqualUnknown(const struct _GUID *); // idb
// _DWORD __stdcall ATL::CComObject<CImplINetCfg>::AddRef(_DWORD); weak
int __stdcall ATL::CComClassFactory::CreateInstance(ATL::CComClassFactory *this, struct IUnknown *a2, const struct _GUID *a3, void **a4);
void *__stdcall std::_Allocate<CStackEntry>(int a1, int a2);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this);
char __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy(int this, int a2);
signed int __thiscall CImplINetCfgHolder::HrLockAndTestForValidInterface(CImplINetCfgHolder *this, unsigned __int32 a2);
unsigned __int32 __stdcall WaitForConfigLoadSaveMutex(); // idb
__int32 __stdcall HrFinishNextOrSkipContract(__int32, unsigned __int32, unsigned __int32, struct IUnknown **, unsigned __int32 *); // idb
int __thiscall CExternalComponentData::FLoadedOkayIfLoadedAtAll(CExternalComponentData *__hidden this); // idb
int __thiscall ATL::CComObject<CImplINetCfgComponent>::CComObject<CImplINetCfgComponent>(int this, int a2);
// _DWORD __stdcall std::_Construct<CStackEntry,CStackEntry>(_DWORD, _DWORD); weak
struct CComponent *__thiscall CBindPath::PGetComponentAtIndex(CBindPath *this, unsigned int); // idb
int __stdcall std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<CStackEntry *,CStackEntry *,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(int this);
int __stdcall InlineIsEqualGUID(const struct _GUID *, const struct _GUID *); // idb
signed int __stdcall CImplINetCfgComponent::GetInstanceGuid(CImplINetCfgComponent *this, struct _GUID *a2);
signed int __thiscall CImplINetCfgComponent::HrLockAndTestForValidInterface(CImplINetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent *a3, struct CComponent **a4);
signed int __thiscall CImplINetCfgComponent::HrIsValidInterface(CImplINetCfgComponent *this, unsigned __int32 a2);
__int32 __thiscall CExternalComponentData::HrEnsureExternalDataLoaded(CExternalComponentData *this); // idb
int __stdcall ATL::AtlInternalQueryInterface(void *a1, const struct ATL::_ATL_INTMAP_ENTRY *a2, const struct _GUID *a3, void **a4);
HRESULT __stdcall DllGetClassObject(const IID *const rclsid, const IID *const riid, LPVOID *ppv);
signed int __stdcall ATL::AtlModuleGetClassObject(struct ATL::_ATL_MODULE *a1, const struct _GUID *a2, const struct _GUID *a3, void **a4);
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(int this);
int __stdcall ATL::CComObject<CMSClient>::AddRef(int a1);
// _DWORD __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(_DWORD); weak
__int32 __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::QueryInterface(ATL::CComClassFactory *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall ATL::CComClassFactory::_InternalQueryInterface(ATL::CComClassFactory *this, const struct _GUID *, void **); idb
void *__thiscall CBindingSet::CBindingSet(void *this);
char __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy(int this, int a2);
signed int __thiscall CComponent::HrGetINetCfgComponentInterface(CComponent *this, struct CImplINetCfg *a2, struct INetCfgComponent **a3);
signed int __stdcall CImplINetCfgComponent::HrCreateInstance(struct CImplINetCfg *a1, struct CComponent *a2, struct CImplINetCfgComponent **a3);
void __thiscall CImplINetCfgHolder::HoldINetCfg(CImplINetCfgHolder *this, struct CImplINetCfg *); // idb
unsigned __int32 __stdcall AddRefObj(struct IUnknown *); // idb
unsigned int __thiscall ALIGNUP(BOOL this, unsigned int a2);
int __thiscall IsRunningOnWow64(BOOL this);
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(CImplINetCfgComponent *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplINetCfgComponent::_InternalQueryInterface(CImplINetCfgComponent *this, const struct _GUID *, void **); idb
int __stdcall FSubstringMatch(const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 **, unsigned __int32 *); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(int this, char a2, int a3);
void __thiscall CRegistryBindingsContext::~CRegistryBindingsContext(CRegistryBindingsContext *this);
void __thiscall CNotifyObjectInterface::ReleaseNotifyObject(CNotifyObjectInterface *this, struct CImplINetCfg *, int); // idb
void __stdcall ReleaseConfigLoadSaveMutex(); // idb
__int32 __stdcall HrSetupDiCreateDeviceInfoList(GUID *ClassGuid, HWND hwndParent, void **); // idb
unsigned int __stdcall CbOfSzAndTermSafe(const unsigned __int16 *a1);
void __thiscall CComponent::ReleaseINetCfgComponentInterface(CComponent *__hidden this); // idb
int __stdcall FreeCollectionAndItem<CFilterMap>(int a1);
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(void *this, int a2, int a3, int a4);
int __cdecl std::copy<CFilteredAdapter * *,std::_Vector_iterator<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>>(int a1, int a2, int a3, int a4);
int __cdecl std::_Copy_opt<CComponent * *,std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>>(int a1, int a2, int a3, int a4);
void *__thiscall CComponent::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall CComponent::~CComponent(CComponent *this);
void __thiscall CExternalComponentData::FreeExternalData(CExternalComponentData *this); // idb
void __thiscall CExternalComponentData::FreeDescription(CExternalComponentData *__hidden this); // idb
void *__thiscall ATL::CComObject<CImplINetCfg>::`scalar deleting destructor'(void *lpMem, char a2);
// int ATL::CComObject<CImplINetCfg>::~CComObject<CImplINetCfg>(void); weak
void __thiscall CImplINetCfg::~CImplINetCfg(CImplINetCfg *this);
BOOL __thiscall CWriteLock::~CWriteLock(CWriteLock *this);
void __thiscall CModifyContext::~CModifyContext(CModifyContext *this);
void __thiscall CNetConfigCore::~CNetConfigCore(CNetConfigCore *this);
int __stdcall FreeCollectionAndItem<CComponentList>(int a1);
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::Release(void *lpMem);
void *__thiscall ATL::CComObject<CImplINetCfgClass>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplINetCfgClass>::~CComObject<CImplINetCfgClass>(int this);
void __thiscall CFilterMap::~CFilterMap(CFilterMap *this);
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(int this);
signed int __stdcall CImplINetCfg::Uninitialize(CImplINetCfg *this);
void *__thiscall CNetConfig::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall CNetConfig::~CNetConfig(CNetConfig *this);
void __thiscall CGlobalNotifyInterface::ReleaseINetCfg(CGlobalNotifyInterface *__hidden this); // idb
__int32 __thiscall CComponent::HrOpenInstanceKey(CComponent *this, unsigned __int32, HKEY *, void **, struct _SP_DEVINFO_DATA *); // idb
__int32 __stdcall HrOpenComponentInstanceKey(int a1, GUID *a2, const WCHAR *a3, REGSAM samDesired, HKEY *a5, int a6, void *a7);
__int32 __stdcall HrOpenDeviceInfo(int a1, const WCHAR *DeviceInstanceId, void **a3, struct _SP_DEVINFO_DATA *DeviceInfoData);
__int32 __stdcall HrSetupDiOpenDeviceInfo(HDEVINFO DeviceInfoSet, PCWSTR DeviceInstanceId, HWND hwndParent, DWORD OpenFlags, PSP_DEVINFO_DATA DeviceInfoData); // idb
void *__thiscall CComponentReferences::~CComponentReferences(CComponentReferences *this);
void *__thiscall COMPONENT_REFERENCE_DATA::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall COMPONENT_REFERENCE_DATA::~COMPONENT_REFERENCE_DATA(COMPONENT_REFERENCE_DATA *this);
void __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Tidy(int this);
void *__thiscall ATL::CComObject<CImplINetCfgComponent>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplINetCfgComponent>::~CComObject<CImplINetCfgComponent>(int this);
int __stdcall NetClassEnumFromGuid(const void *a1);
void *__thiscall CComponent::CComponent(void *this);
BOOL __stdcall FIsPhysicalAdapter(int a1, char a2);
__int32 __stdcall HrLoadNetworkConfigurationFromRegistry(unsigned __int32, struct CNetConfig *); // idb
signed int __thiscall CComponentReferences::HrAddReferenceByComponent(CComponentReferences *this, const struct CComponent *a2);
int __cdecl std::fill<CStackEntry *,CStackEntry>(int a1, int a2, int a3);
int __stdcall RegQueryValuesWithAlloc(HKEY a1, unsigned __int32 a2, DWORD Type, unsigned __int8 *a4, unsigned __int8 **a5, unsigned __int32 *a6);
signed int __stdcall CImplINetCfgClass::EnumComponents(CImplINetCfgClass *this, struct IEnumNetCfgComponent **a2);
int __thiscall ATL::CComObject<CImplINetCfgClass>::CComObject<CImplINetCfgClass>(int this, int a2);
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::AddRef(int a1);
signed int __stdcall CImplINetCfgComponent::GetId(CImplINetCfgComponent *this, unsigned __int16 **a2);
wchar_t *__cdecl _wcslwr(wchar_t *String);
unsigned __int32 DwFormatStringWithLocalAlloc(LPCVOID lpSource, LPWSTR lpBuffer, ...); // idb
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::_Ufill(int this, int a2, int a3, int a4);
int __stdcall stdext::unchecked_uninitialized_fill_n<CLanaEntry *,unsigned int,CLanaEntry,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_fill_n<CStackEntry *,unsigned int,CStackEntry,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall CComponent::HrCreateInstance(const struct BASIC_COMPONENT_DATA *a1, char a2, const struct tagOBO_TOKEN *lpMem, struct CComponent **a4);
signed int __stdcall StringCbCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3);
unsigned __int16 *__stdcall HrLoadNetworkConfigurationFromBuffer(const unsigned __int8 *a1, unsigned __int32 a2, struct CNetConfig *a3);
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Insert_n(int this, int a2, int a3, int a4);
signed int __stdcall CImplIEnumNetCfgComponent::Next(CImplIEnumNetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent **Dst, unsigned __int32 *a4);
signed int __thiscall CImplIEnumNetCfgComponent::HrNextOrSkip(CImplIEnumNetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent **Dst, unsigned __int32 *a4);
signed int __thiscall CComponentReferences::HrAddReferenceByUser(CComponentReferences *this);
signed int __thiscall CComponentReferences::HrEnsureAllocated(CComponentReferences *this);
int __stdcall RegQueryValues(HKEY a1, unsigned __int32 a2, DWORD Type, unsigned __int8 *a4, unsigned __int8 *a5, unsigned __int32 *a6);
__int32 __stdcall RegQueryGuid(HKEY hKey, LPCWSTR lpValueName, struct _GUID *a3, unsigned __int32 *a4);
__int32 __stdcall RegQueryValueType(HKEY hKey, LPCWSTR lpValueName, unsigned __int32, LPBYTE lpData, DWORD Type); // idb
DWORD __stdcall HrBuildBindNameFromBindForm(const void *a1, int a2, char a3, int a4, int a5, GUID *rguid, WCHAR *lpBuffer);
wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch);
__int32 __thiscall CStackTable::HrInsertStackEntry(CStackTable *this, const struct CStackEntry *, unsigned __int32); // idb
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::insert(int this, int a2, int a3, int a4);
__int32 __thiscall HrSetupDiGetDeviceName(DWORD this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD RequiredSize);
__int32 __stdcall HrSetupDiGetDeviceRegistryPropertyWithAlloc(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, DWORD RequiredSize); // idb
__int32 __stdcall HrCiHideIrrelevantFilterServices(void *, const struct CComponent *const ); // idb
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(CImplINetCfg *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplINetCfg::_InternalQueryInterface(CImplINetCfg *this, const struct _GUID *, void **); idb
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CImplINetCfg>>,ATL::CComCreator<ATL::CComAggObject<CImplINetCfg>>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComObject<CImplINetCfg>>::CreateInstance(int a1, int a2, int a3);
void *__thiscall ATL::CComObject<CImplINetCfg>::CComObject<CImplINetCfg>(void *this, int a2);
void *__thiscall CImplINetCfg::CImplINetCfg(void *this);
void *__thiscall CNetConfigCore::CNetConfigCore(void *this);
void *__thiscall CStackTable::CStackTable(void *this);
void *__thiscall CNetConfig::CNetConfig(void *this);
void *__thiscall CModifyContext::CModifyContext(void *this);
int __thiscall CRegistryBindingsContext::CRegistryBindingsContext(int this);
signed int __stdcall CImplINetCfg::Initialize(CImplINetCfg *this, void *a2);
__int32 __stdcall CNetConfig::HrCreateInstance(struct CImplINetCfg *, struct CNetConfig **); // idb
void __thiscall CGlobalNotifyInterface::HoldINetCfg(CGlobalNotifyInterface *this, struct CImplINetCfg *); // idb
signed int __stdcall CImplINetCfg::QueryNetCfgClass(CImplINetCfg *this, const struct _GUID *a2, const struct _GUID *a3, void **a4);
int __stdcall CImplINetCfgClass::HrCreateInstance(struct CImplINetCfg *a1, int a2, int a3);
void *__cdecl operator new(unsigned __int32, const struct extrabytes_t *, unsigned __int32); // idb
signed int __stdcall ULongAdd(unsigned __int32 a1, unsigned __int32 a2, unsigned __int32 *a3);
__int32 __stdcall HrCiRegSetComponentInformation(HKEY hKey, HKEY phkResult); // idb
__int32 __stdcall HrCiHideIrrelevantDrivers(HDEVINFO DeviceInfoSet, const unsigned __int16 *, int); // idb
void *__thiscall COMPONENT_REFERENCE_DATA::COMPONENT_REFERENCE_DATA(void *this);
char __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Buy(int this, int a2);
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgComponent>::QueryInterface(CImplIEnumNetCfgComponent *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplIEnumNetCfgComponent::_InternalQueryInterface(CImplIEnumNetCfgComponent *this, const struct _GUID *, void **); idb
int __stdcall CImplIEnumNetCfgComponent::HrCreateInstance(struct CImplINetCfg *a1, int a2, int a3);
int __thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::CComObject<CImplIEnumNetCfgComponent>(int this, int a2);
void *__thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::~CComObject<CImplIEnumNetCfgComponent>(int this);
int __stdcall NcLoadRegUIString(HKEY a1, const unsigned __int16 *a2, unsigned __int8 *Dst, unsigned __int32 *a4);
__int32 __stdcall ATL::CComObject<CImplINetCfgClass>::QueryInterface(CImplINetCfgClass *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplINetCfgClass::_InternalQueryInterface(CImplINetCfgClass *this, const struct _GUID *, void **); idb
signed int __stdcall CImplINetCfgComponent::SupportsBindingInterface(CImplINetCfgComponent *this, char a2, const unsigned __int16 *a3);
int __cdecl _wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
signed int __stdcall CImplINetCfg::FindComponent(CImplINetCfg *this, wchar_t *Str1, struct INetCfgComponent **a3);
int __thiscall CComponentList::PFindComponentByInfId(CComponentList *this, wchar_t *Str1, unsigned __int32 *a3);
signed int __stdcall CImplINetCfg::EnumComponents(CImplINetCfg *this, const struct _GUID *a2, struct IEnumNetCfgComponent **a3);
// _DWORD __cdecl _unlock(_DWORD); weak
void __cdecl _lock(int a1);
void __cdecl free(void *Memory);
volatile LONG *__cdecl __removelocaleref(volatile LONG *lpAddend);
// int __stdcall _freefls(void *Memory); idb
int __cdecl _decode_pointer(int a1);
// int (*__usercall sub_6E6479D9@<eax>(int (*result)(void)@<eax>, unsigned int a2))(void);
signed int __stdcall _CRT_INIT(int a1, int a2, int a3);
signed int __stdcall __CRT_INIT(int a1, int a2, int a3);
BOOL __stdcall _DllMainCRTStartup(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
int __thiscall sub_6E647CC1(_DWORD);
// int _mtterm(void); weak
BOOL _heap_term();
void __cdecl _lock_file2(signed int a1, int a2);
int __cdecl _flushall();
signed int __cdecl sub_6E647DD1(int a1);
int __cdecl _fcloseall();
void _mtdeletelocks();
signed int __stdcall ATL::AtlModuleTerm(struct ATL::_ATL_MODULE *a1);
void _ioterm();
void *__thiscall ATL::CComObjectNoLock<ATL::CComClassFactory>::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall ATL::CComObjectNoLock<ATL::CComClassFactory>::~CComObjectNoLock<ATL::CComClassFactory>(int this);
// void __cdecl _cexit();
HANDLE __termcon();
int __cdecl _fflush_nolock(FILE *File);
int __cdecl _flush(FILE *File); // idb
void __cdecl _unlock_file2(signed int a1, int a2);
_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *a2);
// int _getptd_noexit(void); weak
// int __set_flsgetvalue(void); weak
LONG __cdecl __addlocaleref(volatile LONG *lpAddend);
int __cdecl _initptd(int a1, int a2);
LPVOID __cdecl _calloc_crt(size_t Size, int a2);
LPVOID __cdecl _calloc_impl(size_t Size, int a2, int a3);
__int32 __stdcall HrCreateMutexWithWorldAccess(LPCWSTR lpName, BOOL bInitialOwner, void *lpMem, void **); // idb
__int32 __stdcall HrAllocateSecurityDescriptorAllowAccessToWorld(void **); // idb
FARPROC __stdcall __delayLoadHelper2(HMODULE hModule, int a2);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// int __usercall _tailMerge_SETUPAPI_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
signed int __stdcall ATL::CComCreator<ATL::CComObjectNoLock<ATL::CComClassFactory>>::CreateInstance(int a1, int a2, int a3);
// _DWORD __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::CComObjectNoLock<ATL::CComClassFactory>(_DWORD); weak
ATL::CComClassFactory *__thiscall ATL::CComClassFactory::CComClassFactory(ATL::CComClassFactory *this);
int __fastcall load__SetupWriteTextLog(int a1, int a2);
int __fastcall load__SetupGetThreadLogToken_0(int a1, int a2);
int __fastcall load__SetupDiDestroyDeviceInfoList_4(int a1, int a2);
int __fastcall load__SetupDiGetDeviceRegistryPropertyW_28(int a1, int a2);
int __fastcall load__SetupDiOpenDevRegKey_24(int a1, int a2);
int __fastcall load__SetupDiOpenDeviceInfoW_20(int a1, int a2);
int __fastcall load__SetupDiCreateDeviceInfoList_8(int a1, int a2);
// void *_MarkAllocaS(void *Ptr, unsigned int Marker);
signed int __cdecl _get_osplatform(int a1);
// int _encoded_null(void); weak
void *__cdecl calloc(size_t NumOfElements, size_t SizeOfElements);
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult);
void __cdecl __security_init_cookie();
int __cdecl _ValidateImageBase(int a1);
// int _initp_misc_cfltcvt_tab(void); weak
errno_t __cdecl strcpy_s(char *Dst, rsize_t SizeInBytes, const char *Src);
int __cdecl _initp_misc_rand_s(int a1);
int __cdecl _initp_misc_initcrit(int a1);
void __stdcall InitializeDebugging(int); // idb
// unsigned int __usercall sub_6E648ED0@<eax>(int a1@<esi>);
// signed int __usercall sub_6E648FFD@<eax>(int a1@<esi>, int a2, int a3, int a4, signed int *a5);
signed int _mtinitlocks();
// _DWORD __cdecl __crtInitCritSecAndSpinCountEx(_DWORD, _DWORD); weak
int __cdecl __crtInitCritSecAndSpinCount(int a1, int a2);
signed int _mtinit();
int __cdecl _encode_pointer(int a1);
// int __cdecl __crtGetStringTypeA(struct localeinfo_struct *, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); idb
int __cdecl sub_6E649518(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); // idb
int __cdecl _initterm_e(unsigned int a1, unsigned int a2);
signed int _ioinit();
signed int __initstdio();
// int _setenvp(void); weak
// int __initmbctable(void); weak
// int __usercall sub_6E649AF7@<eax>(int a1@<esi>);
signed int _setargv();
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult);
// int __cdecl __crtLCMapStringA(struct localeinfo_struct *, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR, int cchDest, UINT CodePage, int); idb
int __cdecl sub_6E649CD3(int, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR, int cchDest, UINT CodePage, int); // idb
void __cdecl _freea(void *Memory);
signed int __thiscall ATL::CComModule::Init(ATL::CComModule *this, struct ATL::_ATL_OBJMAP_ENTRY *a2, HINSTANCE a3);
signed int __stdcall ATL::AtlModuleInit(struct ATL::_ATL_MODULE *a1, struct ATL::_ATL_OBJMAP_ENTRY *a2, HINSTANCE a3);
signed int __stdcall IsSystemUpgradeInProgress();
int __cdecl _cinit(int a1);
BOOL _get_sse2_info();
signed int sub_6E64A23C();
int __cdecl _IsNonwritableInCurrentImage(int a1);
int __cdecl _FindPESection(int a1, unsigned int a2);
// int _init_pointers(void); weak
// int __cdecl _ismbblead(unsigned int);
int __cdecl sub_6E64A3C6(struct localeinfo_struct *, char, int, char); // idb
void *__crtGetEnvironmentStringsA();
void *__cdecl malloc(size_t Size);
signed int __cdecl _heap_init(int a1);
signed int __heap_select();
signed int __cdecl _get_winmajor(int a1);
volatile LONG *__updatetmbcinfo();
int _getptd();
signed int __stdcall StringCchCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3);
__int32 __stdcall HrRegCreateKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition); // idb
__int32 __stdcall HrRegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD dwType, BYTE *lpData, DWORD cbData); // idb
void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
void __stdcall GetBindingsBelowComponent(const struct CComponent *, struct GBCONTEXT *); // idb
int __thiscall CBindPath::RemoveLastComponent(CBindPath *this);
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::pop_back(int this);
int __thiscall CNetConfigCore::FIsBindPathDisabled(CNetConfigCore *this, const struct CBindPath *, unsigned __int32); // idb
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
// int __usercall sub_6E64AC25@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>);
int __thiscall CNetConfigCore::HrGetComponentBindings(CNetConfigCore *this, const struct CComponent *a2, unsigned __int32 a3, struct CBindingSet *a4);
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear(int this);
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(int, int, int, int); // idb
LONG __stdcall ATL::CComObject<CMSClient>::Release(void *lpMem);
int __stdcall HrSaveNetworkConfigurationToRegistry(struct CNetConfig *lpMem);
int __thiscall CIndices::PGetIndexByFilter(int this, int a2, int a3);
// int *__usercall sub_6E64AF74@<eax>(int *result@<eax>, int a2@<ebx>, signed __int16 *a3, int *a4);
signed int __cdecl _swoutput_s(char *a1, unsigned int a2, int a3, int a4);
__int32 __stdcall HrSetupDiGetClassDevs(GUID *ClassGuid, PCWSTR Enumerator, HWND hwndParent, DWORD Flags, void **); // idb
void __stdcall RegSafeCloseKey(HKEY); // idb
signed int __cdecl _woutput_s(int a1, int a2, int a3);
int __thiscall CFilterMap::PFindEntryByFilterAndMiniportGuid(CFilterMap *this, const struct CComponent *a2, const struct _GUID *a3);
// void __usercall sub_6E64B46F(int a1@<edx>, unsigned int a2@<ecx>, int a3@<edi>, int a4@<esi>);
// int __usercall sub_6E64B4A2@<eax>(int result@<eax>, signed __int16 a2, int a3, int a4);
// int __usercall sub_6E64B4D5@<eax>(int result@<eax>, int a2@<edi>, signed __int16 a3@<si>);
__int32 __stdcall HrSetupDiEnumDeviceInfo(HDEVINFO DeviceInfoSet, DWORD MemberIndex, PSP_DEVINFO_DATA DeviceInfoData); // idb
void __thiscall CModifyContext::ApplyChanges(CModifyContext *__hidden this); // idb
void CDiagContext::Printf(DWORD NumberOfBytesWritten, int a2, char *Format, ...);
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(void *lpMem);
signed int __stdcall CImplINetCfg::Apply(CImplINetCfg *this);
int __thiscall CModifyContext::HrApplyIfOkOrCancel(CModifyContext *this, int a2);
void __thiscall CImplINetCfg::LowerRpl(int this, int a2);
__int32 __thiscall CBindPath::HrReserveRoomForComponents(CBindPath *this, unsigned int); // idb
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::reserve(int this, int a2);
void *__cdecl std::fill<CBindPath *,CBindPath>(void *a1, void *a2, int a3);
// int __cdecl mbtowc(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes);
int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
__int32 __stdcall HrRegQueryTypeSzBuffer(HKEY hKey, LPCWSTR lpValueName, unsigned __int32, LPBYTE lpData, DWORD Type); // idb
__int32 __stdcall HrRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData); // idb
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1);
__int32 __stdcall HrRegSetSz(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData); // idb
void __stdcall CWriteLock::SetOrQueryLockHolder(void *lpMem, BYTE *lpData, unsigned __int16 **a4);
int __thiscall CWriteLock::ReleaseIfOwned(CWriteLock *__hidden this); // idb
signed int __stdcall CImplINetCfg::ReleaseWriteLock(CImplINetCfg *this);
int __thiscall CWriteLock::FIsLockedByAnyone(CWriteLock *this, unsigned __int16 **); // idb
int __stdcall CreateInstanceKeyPath(int a1, GUID *rguid, unsigned __int16 *pszDest);
int __thiscall CBindPath::FIsSubPathOf(CBindPath *this, const struct CBindPath *); // idb
signed int __thiscall CImplINetCfgComponent::HrBindToOrUnbindFrom(CImplINetCfgComponent *this, struct INetCfgComponent *a2, unsigned __int32 a3);
__int32 __thiscall CModifyContext::HrPrepare(CModifyContext *__hidden this); // idb
signed int __thiscall CRegistryBindingsContext::HrPrepare(CRegistryBindingsContext *this, struct CNetConfig *a2);
int __thiscall CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized(CGlobalNotifyInterface *this);
int __thiscall CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(CNotifyObjectInterface *this, struct CImplINetCfg *a2, int a3);
__int32 __stdcall CImplINetCfg::HrCoCreateWrapper(struct CComponent *a2, IID *rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, IID *riid, void **a7);
signed int __stdcall CImplINetCfgComponent::GetDisplayName(CImplINetCfgComponent *this, unsigned __int16 **a2);
signed int __thiscall CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy(CImplINetCfgComponent *this, unsigned int a2, unsigned __int16 **a3);
int __stdcall FCheckGroupMembership(DWORD nSubAuthority1, int); // idb
int __stdcall FCheckGroupMembershipInternal(BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, int); // idb
signed int __stdcall IsUserMemberOfSID(PSID pSid1, int *a2, int *a3);
int __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(int a1);
int __stdcall ATL::CComObject<CSrvrcfg>::AddRef(int a1);
__int32 __thiscall CComponent::HrOpenServiceKey(CComponent *this, REGSAM samDesired, HKEY *); // idb
__int32 __stdcall HrRegSetBinary(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData, DWORD cbData); // idb
int nullsub_2(void); // weak
int __stdcall HrSaveNetworkConfigurationToBufferWithAlloc(struct CNetConfig *a1, size_t Size, unsigned __int32 *a3);
int __thiscall CComponentReferences::CountComponentsReferencedBy(CComponentReferences *this);
struct CComponent *__thiscall CComponentReferences::PComponentReferencedByAtIndex(CComponentReferences *this, unsigned int); // idb
__int32 __thiscall CComponentList::HrAddComponentsInList1ButNotInList2(CComponentList *this, const struct CComponentList *, const struct CComponentList *); // idb
int __thiscall CNetConfigCore::FContainsLightWeightFilter(CNetConfigCore *__hidden this); // idb
__int32 __thiscall CBindingSet::HrGetAffectedComponentsInBindingSet(CBindingSet *this, struct CComponentList *); // idb
__int32 __stdcall CImplIEnumNetCfgBindingPath::Reset(CImplIEnumNetCfgBindingPath *this); // idb
signed int __stdcall CImplINetCfgComponent::GetClassGuid(CImplINetCfgComponent *this, struct _GUID *a2);
signed int __stdcall CImplINetCfgComponent::GetBindName(CImplINetCfgComponent *this, unsigned __int16 **a2);
int __stdcall ATL::CComObject<CMSClient>::AddRef(int a1);
signed int __stdcall CImplINetCfgBindingPath::IsEnabled(CImplINetCfgBindingPath *this);
int __thiscall CFilterDevices::CFilterDevices(int this, int a2);
void *__stdcall std::_Allocate<CIndex>(int a1, int a2);
int __thiscall CFilterMap::FEntryInList(CFilterMap *this, const struct CFilterMapEntry *); // idb
__int32 __thiscall CPszArray::HrReserveRoomForPointers(CPszArray *this, unsigned int); // idb
signed int __thiscall CCounter::HrSetIndex(CCounter *this, unsigned int a2);
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::size(int this);
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::capacity(int this);
void __stdcall std::_Construct<CIndex,CIndex>(int a1, int a2);
errno_t __cdecl wcsncpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src, rsize_t MaxCount);
int __cdecl _iswctype_l(wint_t C, wctype_t Type, _locale_t Locale);
void __stdcall GetProductFlavor(const void *, enum PRODUCT_FLAVOR *); // idb
int __stdcall FIsUserNetworkConfigOps(); // idb
__int32 __stdcall CMSClient::SysQueryBindingPath(CMSClient *this, unsigned __int32, struct INetCfgBindingPath *); // idb
int __thiscall CComponentReferences::CountSoftwareReferencedBy(CComponentReferences *this);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(int this);
int __stdcall HrSaveNetworkConfigurationToBuffer(struct CNetConfig *a1, unsigned __int8 *Dst, unsigned __int32 *a3);
int __thiscall CComponentList::UnGetIndexOfComponent(CComponentList *this, const struct CComponent *a2);
int __thiscall CComponentReferences::FIsReferencedByOthers(CComponentReferences *__hidden this); // idb
struct CComponent *__thiscall CComponentList::PFindComponentByInstanceGuid(CComponentList *this, const struct _GUID *); // idb
void __thiscall CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath(void *this, int a2, int a3, int a4, int a5);
__int32 __thiscall CFilterMap::HrInsertEntry(CFilterMap *this, const struct CFilterMapEntry *); // idb
__int32 __cdecl wcstol(const wchar_t *Str, wchar_t **EndPtr, int Radix);
int __cdecl sub_6E64E9A8(struct localeinfo_struct *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_6E64E9CD(struct localeinfo_struct *a1, int a2, int a3, int a4, int a5, int a6);
int *__cdecl _errno();
int __thiscall CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll(CBindPath *__hidden this); // idb
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Ufill(int this, int a2, int a3, int a4);
void __stdcall stdext::unchecked_uninitialized_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4);
void __stdcall std::_Uninit_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl _wchartodigit(unsigned __int16 a1);
__int32 __thiscall CFilterMap::HrLoadMapFromRegistry(CFilterMap *this, const struct CNetConfigCore *); // idb
__int32 __thiscall CFilterMap::HrInsertEntriesFromFilterList(CFilterMap *this, HKEY, const unsigned __int16 *); // idb
int __thiscall CComponentReferences::FIsReferencedByUser(CComponentReferences *__hidden this); // idb
int __thiscall CBindPath::FGetPathToken(CBindPath *this, STRSAFE_LPWSTR pszDest, unsigned __int32 *); // idb
__int32 __thiscall CBindingSet::HrAddBindPathsInSet1ButNotInSet2(CBindingSet *this, const struct CBindingSet *, const struct CBindingSet *); // idb
int __thiscall CNetConfigCore::FContainsFilterComponent(CNetConfigCore *__hidden this); // idb
void *__thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::~CComObject<CImplIEnumNetCfgBindingPath>(int this);
void __thiscall CImplIEnumNetCfgBindingPath::~CImplIEnumNetCfgBindingPath(CImplIEnumNetCfgBindingPath *this);
__int32 __thiscall CStackTable::HrReserveRoomForEntries(CStackTable *this, unsigned int); // idb
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::reserve(int this, int a2);
int __stdcall ATL::CComObject<CSrvrcfg>::AddRef(int a1);
// _DWORD __stdcall ATL::CComObject<CSrvrcfg>::AddRef(_DWORD); weak
void __thiscall CImplINetCfg::RaiseRpl(int this, int a2);
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CLanaEntry,std::nc_allocator<CLanaEntry>>,CLanaEntry *,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry *,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6);
__int32 __stdcall CSrvrcfg::Initialize(CSrvrcfg *this, struct IUnknown *, struct INetCfg *, struct INetCfgBindingPath *); // idb
__int32 __thiscall CSrvrcfg::HrGetRegistryInfo(CSrvrcfg *this, int); // idb
__int32 __stdcall HrRegQueryDword(HKEY hKey, LPCWSTR lpValueName, DWORD Type); // idb
signed int __thiscall CFilterMapEntry::HrSetFilterAndIndex(CFilterMapEntry *this, const struct CComponent *a2, CCounter *a3, int a4);
int __thiscall CIndices::HrInsertIndex(int this, unsigned int a2, int a3, int a4, int a5);
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::insert(int this, int a2, int a3, int a4);
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Insert_n(int this, int a2, int a3, int a4);
int __stdcall std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CMSClient>>,ATL::CComCreator<ATL::CComAggObject<CMSClient>>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComObject<CMSClient>>::CreateInstance(int a1, int a2, int a3);
void *__thiscall ATL::CComObject<CMSClient>::CComObject<CMSClient>(void *this, int a2);
void *__thiscall CMSClient::CMSClient(void *this);
RPC_CONFIG_DATA *__thiscall RPC_CONFIG_DATA::RPC_CONFIG_DATA(RPC_CONFIG_DATA *this);
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CSrvrcfg>>,ATL::CComCreator<ATL::CComAggObject<CSrvrcfg>>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComObject<CSrvrcfg>>::CreateInstance(int a1, int a2, int a3);
CSrvrcfg *__thiscall ATL::CComObject<CSrvrcfg>::CComObject<CSrvrcfg>(CSrvrcfg *this, int a2);
CSrvrcfg *__thiscall CSrvrcfg::CSrvrcfg(CSrvrcfg *this);
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(CMSClient *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CMSClient::_InternalQueryInterface(CMSClient *this, const struct _GUID *, void **); idb
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(CSrvrcfg *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CSrvrcfg::_InternalQueryInterface(CSrvrcfg *this, const struct _GUID *, void **); idb
__int32 __thiscall CComponentList::HrCopyComponentList(CComponentList *this, const struct CComponentList *); // idb
void *__thiscall CBindPath::operator=(void *this, int a2);
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::operator=(int, int); // idb
__int32 __thiscall CModifyContext::HrEnableOrDisableBindPath(CModifyContext *this, unsigned __int32, struct CBindPath *, struct INetCfgBindingPath *); // idb
void __thiscall CGlobalNotifyInterface::NotifyBindPath(CGlobalNotifyInterface *this, unsigned __int32, struct CBindPath *, struct INetCfgBindingPath *); // idb
void __thiscall CNotifyObjectInterface::NbQueryOrNotifyBindingPath(void *this, int a2, LPVOID pv, int a4, int a5, int a6);
__int32 __stdcall CImplIEnumNetCfgBindingPath::Next(CImplIEnumNetCfgBindingPath *this, unsigned __int32, struct INetCfgBindingPath **, unsigned __int32 *); // idb
__int32 __thiscall CImplIEnumNetCfgBindingPath::HrNextOrSkip(CImplIEnumNetCfgBindingPath *this, unsigned __int32, struct INetCfgBindingPath **Dst, unsigned __int32 *); // idb
int __stdcall CImplINetCfgBindingPath::HrCreateInstance(struct CImplINetCfg *a1, const struct CBindPath *a2, struct INetCfgBindingPath **a3);
int __thiscall ATL::CComObject<CImplINetCfgBindingPath>::CComObject<CImplINetCfgBindingPath>(int this, int a2);
__int32 __thiscall CNetConfigCore::HrCopyCore(CNetConfigCore *this, const struct CNetConfigCore *); // idb
__int32 __thiscall CBindingSet::HrCopyBindingSet(CBindingSet *this, const struct CBindingSet *); // idb
void *__thiscall CBindingSet::operator=(void *this, int a2);
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::operator=(int, int); // idb
__int32 __thiscall CStackTable::HrCopyStackTable(CStackTable *this, const struct CStackTable *); // idb
int __thiscall CStackTable::operator=(int this, int a2);
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::operator=(void *this, int a2);
void __thiscall CBindingSet::Printf(void *this, int a2, char *a3);
int swprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, ...);
int __cdecl vswprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, va_list ArgList);
__int32 __thiscall CBindingSet::HrReserveRoomForBindPaths(CBindingSet *this, unsigned int); // idb
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::reserve(int this, int a2);
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4);
int __stdcall std::_Uninit_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6);
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Next(CImplIEnumNetCfgBindingInterface *this, unsigned __int32, struct INetCfgBindingInterface **, unsigned __int32 *); // idb
__int32 __thiscall CImplIEnumNetCfgBindingInterface::HrNextOrSkip(CImplIEnumNetCfgBindingInterface *this, unsigned __int32, struct INetCfgBindingInterface **Dst, unsigned __int32 *); // idb
int __stdcall CImplINetCfgBindingInterface::HrCreateInstance(struct CImplINetCfg *a1, struct IUnknown *a2, struct IUnknown *a3, struct INetCfgBindingInterface **a4);
int __thiscall ATL::CComObject<CImplINetCfgBindingInterface>::CComObject<CImplINetCfgBindingInterface>(int this, int a2);
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::QueryInterface(CImplIEnumNetCfgBindingInterface *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplIEnumNetCfgBindingInterface::_InternalQueryInterface(CImplIEnumNetCfgBindingInterface *this, const struct _GUID *, void **); idb
int __stdcall CImplIEnumNetCfgBindingInterface::HrCreateInstance(struct CImplINetCfg *a1, struct IUnknown *a2, struct IEnumNetCfgBindingInterface **a3);
int __thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::CComObject<CImplIEnumNetCfgBindingInterface>(int this, int a2);
void *__thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::~CComObject<CImplIEnumNetCfgBindingInterface>(int this);
void __thiscall CImplIEnumNetCfgBindingInterface::FinalRelease(CImplIEnumNetCfgBindingInterface *__hidden this); // idb
signed int __stdcall CImplINetCfgComponent::EnumBindingPaths(struct IUnknown *this, unsigned __int32 a2, struct IEnumNetCfgBindingPath **a3);
__int32 __stdcall CImplIEnumNetCfgBindingPath::HrCreateInstance(struct CImplINetCfg *, const struct CBindingSet *lpMem, char, struct CImplIEnumNetCfgBindingPath **); // idb
int __thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::CComObject<CImplIEnumNetCfgBindingPath>(int this, int a2);
int __thiscall CImplIEnumNetCfgBindingPath::CImplIEnumNetCfgBindingPath(int this);
signed int __stdcall CImplINetCfgComponent::OpenParamKey(CImplINetCfgComponent *this, HKEY hKey);
signed int __stdcall CImplINetCfgBindingInterface::GetName(CImplINetCfgBindingInterface *this, unsigned __int16 **a2);
int __thiscall CComponent::FCanDirectlyBindTo(CComponent *this, const struct CComponent *, char, const unsigned __int16 **, unsigned __int32 *); // idb
signed int __stdcall CImplINetCfgBindingInterface::GetLowerComponent(CImplINetCfgBindingInterface *this, struct INetCfgComponent **a2);
signed int __thiscall CImplINetCfgBindingInterface::HrLockAndTestForValidInterface(CImplINetCfgBindingInterface *this, unsigned __int32 a2);
signed int __stdcall CImplINetCfgBindingPath::EnumBindingInterfaces(struct IUnknown *this, struct IEnumNetCfgBindingInterface **a2);
signed int __thiscall CImplINetCfgBindingPath::HrLockAndTestForValidInterface(CImplINetCfgBindingPath *this, unsigned __int32 a2, struct CBindPath *a3);
signed int __thiscall CImplINetCfgBindingPath::HrIsValidInterface(CImplINetCfgBindingPath *this, unsigned __int32 a2, struct CBindPath *a3);
__int32 __stdcall ATL::CComObject<CImplINetCfgBindingInterface>::QueryInterface(CImplINetCfgBindingInterface *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplINetCfgBindingInterface::_InternalQueryInterface(CImplINetCfgBindingInterface *this, const struct _GUID *, void **); idb
__int32 __stdcall ATL::CComObject<CImplINetCfgBindingPath>::QueryInterface(CImplINetCfgBindingPath *a1, struct _GUID *a2, void **a3);
// __int32 __thiscall CImplINetCfgBindingPath::_InternalQueryInterface(CImplINetCfgBindingPath *this, const struct _GUID *, void **); idb
void *__thiscall ATL::CComObject<CImplINetCfgBindingInterface>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplINetCfgBindingInterface>::~CComObject<CImplINetCfgBindingInterface>(int this);
void __thiscall CImplINetCfgBindingInterface::FinalRelease(CImplINetCfgBindingInterface *__hidden this); // idb
void *__thiscall ATL::CComObject<CImplINetCfgBindingPath>::`scalar deleting destructor'(void *lpMem, char a2);
LONG __thiscall ATL::CComObject<CImplINetCfgBindingPath>::~CComObject<CImplINetCfgBindingPath>(int this);
void __thiscall CImplINetCfgBindingPath::FinalRelease(CImplINetCfgBindingPath *__hidden this); // idb
__int32 __thiscall CFilterDevices::HrPrepare(CFilterDevices *__hidden this); // idb
__int32 __thiscall HrRegGetMultiSzWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int16 **a4);
int __thiscall CFilteredAdapters::CFilteredAdapters(int this, CModifyContext *a2, int a3);
struct CNetConfig *__thiscall CModifyContext::PNetConfig(CModifyContext *__hidden this); // idb
int __thiscall CFilterMapEntry::CFilterMapEntry(int this, int a2, int a3, int a4, int a5);
char __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Buy(int this, int a2);
__int32 __stdcall CMSClient::Initialize(CMSClient *this, struct IUnknown *a2, struct INetCfg *a3, struct INetCfgBindingPath *a4);
__int32 __thiscall CMSClient::HrGetBrowserRegistryInfo(CMSClient *__hidden this); // idb
signed int __stdcall CMSClient::GetSupportedNotifications(CMSClient *this, unsigned __int32 *a2);
// int __stdcall FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(unsigned __int32 *); idb
__int32 __thiscall CSrvrcfg::HrOpenRegKeys(CSrvrcfg *this, struct INetCfg *); // idb
__int32 __stdcall HrRegOpenKeyBestAccess(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); // idb
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1);
__int32 __stdcall HrRegCreateKeyWithWorldAccess(HKEY hKey, LPCWSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition); // idb
__int32 __thiscall CNetConfig::HrEnsureExternalDataLoadedForAllComponents(CNetConfig *__hidden this); // idb
__int32 __stdcall CImplIEnumNetCfgComponent::Reset(CImplIEnumNetCfgComponent *this); // idb
int __stdcall FIsUserAdmin(); // idb
CAutoImpersonate *__thiscall CAutoImpersonate::CAutoImpersonate(CAutoImpersonate *this);
int __thiscall CAutoImpersonate::ShouldRevertImpersonation(CAutoImpersonate *__hidden this); // idb
// int __stdcall pSetupLoadIndirectString(_DWORD, _DWORD, _DWORD, _DWORD); weak
signed int __stdcall HrSetupLoadIndirectStringWithAlloc(unsigned __int16 *a1, unsigned __int16 **a2);
HRESULT __thiscall CAutoImpersonate::~CAutoImpersonate(CAutoImpersonate *this);
int __thiscall CAutoImpersonate::ShouldRecoverLostImpersonation(CAutoImpersonate *__hidden this); // idb
signed int __stdcall CImplINetCfgComponent::IsBoundTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2);
signed int __stdcall CImplINetCfg::AcquireWriteLock(CImplINetCfg *this, DWORD dwMilliseconds, BYTE *lpData, unsigned __int16 **a4);
int __thiscall CWriteLock::WaitToAcquire(CWriteLock *this, DWORD dwMilliseconds, BYTE *lpData, unsigned __int16 **); // idb
__int32 __thiscall CWriteLock::HrEnsureMutexCreated(void **this); // idb
signed int __thiscall CDynamicBuffer::HrReserveBytes(CDynamicBuffer *this, unsigned __int32 a2);
int __thiscall CDynamicBuffer::FGrowBuffer(CDynamicBuffer *this, unsigned __int32); // idb
signed int __thiscall CAutoImpersonate::CheckPoint(CAutoImpersonate *this, int *a2);
signed int __stdcall CAutoImpersonate::IsImpersonating(int *TokenHandle);
signed int __stdcall CImplINetCfgComponent::BindTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2);
// void __usercall sub_6E651B11(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
void __thiscall CBindingSet::RemoveBindPath(CBindingSet *this, const struct CBindPath *); // idb
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(int, int, int); // idb
void __thiscall CBindingSet::SortForPnpBind(CBindingSet *__hidden this); // idb
void __stdcall std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::greater<CBindPath>>(int a1, int a2, int a3, int a4);
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1);
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1);
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(int a1);
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1);
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(int a1);
int __thiscall CComponent::FIsBindable(CComponent *__hidden this); // idb
void __thiscall CNotifyObjectInterface::ApplyPnpChanges(CNotifyObjectInterface *this, struct CImplINetCfg *, int *); // idb
void __thiscall CNotifyObjectInterface::ApplyRegistryChanges(CNotifyObjectInterface *this, struct CImplINetCfg *, int *); // idb
signed int __thiscall CNotifyObjectInterface::HrGetInterfaceIdsForAdapter(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct CComponent *a3, unsigned __int32 *a4, struct _GUID **a5);
void __thiscall CComponentList::FreeComponentsNotInOtherComponentList(CComponentList *this, const struct CComponentList *); // idb
__int32 __thiscall CBindPath::HrInsertComponent(CBindPath *this, const struct CComponent *); // idb
// __int32 __userpurge CBindingSet::HrAppendBindingSet@<eax>(CBindingSet *this@<ecx>, int a2@<ebx>, const struct CBindingSet *a3);
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1);
void __thiscall CFilterDevices::StartFilterDevices(CFilterDevices *__hidden this); // idb
void __thiscall CFilterDevices::LoadAndRemoveFilterDevicesIfNeeded(CFilterDevices *__hidden this); // idb
signed int __stdcall CFilteredAdapters::HrWriteFilterList(HKEY hKey, struct CDynamicBuffer *a3);
int __thiscall CFilteredAdapter::CFilteredAdapter(int this);
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
int __stdcall GetPnpLayerForBindPath(const struct CBindPath *a1);
LONG __cdecl CompareModifyingFilters(const void *a1, const void *a2);
int __thiscall CServiceManager::~CServiceManager(CServiceManager *this);
unsigned __int32 __thiscall CDiagContext::Flags(CDiagContext *__hidden this); // idb
int __thiscall RPC_CONFIG_DATA::~RPC_CONFIG_DATA(RPC_CONFIG_DATA *this);
void __thiscall CMSClient::CleanupPropPages(CMSClient *__hidden this); // idb
__int32 __stdcall CFilteredAdapter::HrCreateInstance(const struct CComponent *, const struct CNetConfigCore *, struct CFilteredAdapter **); // idb
int __thiscall CNetConfigCore::FAdapterHasAnEnabledLightWeightFilter(CNetConfigCore *this, const struct CComponent *); // idb
__int32 __thiscall CNetConfigCore::HrGetFiltersEnabledForAdapter(CNetConfigCore *this, const struct CComponent *, struct CComponentList *, struct CComponentList *, struct CComponentList *); // idb
int __thiscall CNetConfigCore::FIsLength2BindPathDisabled(CNetConfigCore *this, const struct CComponent *, const struct CComponent *); // idb
__int32 __thiscall CFilteredAdapters::HrLoadFilteredAdaptersFromCore(CFilteredAdapters *__hidden this); // idb
void __thiscall CFilterDevices::InstallFilterDevicesIfNeeded(CFilterDevices *this); // idb
const void **__thiscall CFilteredAdapters::PFindEntryByAdapterGuid(CFilteredAdapters *this, const struct _GUID *a2);
__int32 __thiscall CFilteredAdapters::HrWriteFilterBindings(CFilteredAdapters *this); // idb
void __thiscall CFilteredAdapters::DeleteFilterServiceKeys(CFilteredAdapters *__hidden this); // idb
void __thiscall CFilteredAdapters::SendDetachNotifications(CFilteredAdapters *this); // idb
__int32 __thiscall CFilteredAdapters::HrInsertFilteredAdapter(CFilteredAdapters *this, struct CFilteredAdapter *); // idb
const struct CComponent **__thiscall CFilteredAdapters::PFindEntryByAdapter(CFilteredAdapters *this, const struct CComponent *a2);
__int16 __stdcall NdispUnicodeStringToVar(int a1, int a2, int a3);
int __thiscall CRegistryBindingsContext::HrWriteBindingsForComponent(CRegistryBindingsContext *this, const struct CComponent *rguid);
unsigned __int32 __thiscall CFilterDevices::MapFilterClassToOrdinal(CFilterDevices *this, const unsigned __int16 *Str1);
int __stdcall FGetSzPositionInMultiSzSafe(wchar_t *Str2, wchar_t *Str1, unsigned __int32 *, int *, unsigned __int32 *); // idb
__int32 __thiscall CNetConfigCore::HrGetComponentUpperBindings(CNetConfigCore *this, const struct CComponent *, char, struct CBindingSet *); // idb
__int32 __stdcall HrWriteLinkageValues(GUID *rguid, const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *); // idb
void __thiscall CFilteredAdapter::SortFilters(CFilteredAdapter *__hidden this); // idb
void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *));
// unsigned int __usercall sub_6E6537E8@<eax>(unsigned int result@<eax>, unsigned int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD));
void __thiscall CRegistryBindingsContext::PnpBindOrUnbindBindPaths(CRegistryBindingsContext *this, unsigned int, struct CBindingSet *, unsigned __int32, int *); // idb
int __stdcall HrPnpBindOrUnbind(unsigned int a1, unsigned int a2, PCWSTR a3, PCWSTR SourceString);
int __stdcall NdisHandlePnPEvent(int, int, int, int, int, void *Src, size_t Size); // idb
signed int __thiscall CRegistryBindingsContext::HrGetAdapterUpperBindValue(CRegistryBindingsContext *this, const struct CComponent *a2);
signed int __thiscall CDynamicBuffer::HrCopyString(CDynamicBuffer *this, const unsigned __int16 *a2);
signed int __thiscall CDynamicBuffer::HrCopyBytes(CDynamicBuffer *this, const unsigned __int8 *Src, unsigned __int32 Size);
void __thiscall CFilterDevices::~CFilterDevices(CFilterDevices *this);
void __thiscall CFilteredAdapters::DeleteFilterBindings(CFilteredAdapters *this); // idb
void *__thiscall ATL::CComObject<CMSClient>::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall ATL::CComObject<CMSClient>::~CComObject<CMSClient>(int this);
void __thiscall CMSClient::~CMSClient(CMSClient *this);
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD); weak
void *__thiscall ATL::CComObject<CSrvrcfg>::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall ATL::CComObject<CSrvrcfg>::~CComObject<CSrvrcfg>(int this);
void __thiscall CSrvrcfg::~CSrvrcfg(CSrvrcfg *this);
void __thiscall CSrvrcfg::CleanupPropPages(CSrvrcfg *__hidden this); // idb
void __thiscall CFilteredAdapters::~CFilteredAdapters(CFilteredAdapters *this);
void __thiscall CFilteredAdapters::Free(CFilteredAdapters *__hidden this); // idb
int __stdcall FreeCollectionAndItem<CFilteredAdapters>(int a1);
void __thiscall CFilteredAdapters::SendAttachNotifications(CFilteredAdapters *this); // idb
void *__thiscall CFilterMapEntry::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall CFilterMapEntry::~CFilterMapEntry(CFilterMapEntry *this);
int __cdecl std::copy<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, void *a4);
int __cdecl std::_Copy_opt<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, void *a4);
__int32 __stdcall HrRegSetMultiSzAndLogDifference(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData, const struct CComponent *); // idb
__int32 __stdcall HrRegSetMultiSz(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData); // idb
unsigned __int32 __stdcall CchOfMultiSzAndTermSafe(const unsigned __int16 *); // idb
unsigned __int32 __stdcall CchOfMultiSzSafe(const unsigned __int16 *); // idb
void __thiscall CNetConfigCore::Clear(CNetConfigCore *__hidden this); // idb
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::clear(int this);
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(void *this, int a2, int a3, int a4);
int __cdecl std::copy<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(int a1, int a2, int a3, int a4);
int __cdecl std::_Copy_opt<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(int a1, int a2, int a3, int a4);
int __stdcall CFilterDevices::IsMediumConverterOrLower(wchar_t *Str1); // idb
int __cdecl _wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount);
int __thiscall CBindPath::RemoveFirstComponent(CBindPath *this);
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::erase(int this, int a2, int a3);
__int32 __stdcall HrCreateLinkageKey(GUID *rguid, struct CFilterDevice *, HDEVINFO DeviceInfoSet, PHKEY phkResult); // idb
__int32 __stdcall HrRegSetGuidAsSz(HKEY hKey, LPCWSTR lpValueName, GUID *rguid); // idb
__int32 __thiscall CRegistryBindingsContext::HrWriteBindingsForFilterDevices(CRegistryBindingsContext *this, struct CFilterDevices *); // idb
void __thiscall CFilterDevices::SortForWritingBindings(CFilterDevices *__hidden this); // idb
void *__thiscall CFilteredAdapter::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall CFilteredAdapter::~CFilteredAdapter(CFilteredAdapter *this);
unsigned int __thiscall HrMigrateWinsockConfiguration(void *this);
// int __stdcall MigrateWinsockConfiguration(_DWORD, _DWORD, _DWORD); weak
void __thiscall CFilterDevices::Free(CFilterDevices *__hidden this); // idb
int __stdcall FreeCollectionAndItem<CFilterDevices>(int a1);
int __cdecl std::copy_backward<CComponent * *,CComponent * *>(void *Src, int, int); // idb
int __cdecl std::_Copy_backward_opt<CFilterMapEntry * *,CFilterMapEntry * *>(void *Src, int, int); // idb
signed int __thiscall CFilteredAdapters::HrBuildFilterListEntry(CFilteredAdapters *this, GUID *rguid, GUID *a3, unsigned int a4);
int _snwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, ...);
int __cdecl _vsnwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, va_list ArgList);
signed int __thiscall CFilterMap::HrGetIndexForFilterByMiniportAndLowerFilter(CFilterMap *this, const struct CComponent *a2, const struct _GUID *a3, const struct CComponent *a4, int a5, unsigned int *a6, int *a7);
signed int __thiscall CFilterMapEntry::HrGetIndexByFilter(CFilterMapEntry *this, const struct CComponent *a2, unsigned int *a3, int *a4);
void __stdcall PruneNdisWanBindPathsIfActiveRasConnections(char, struct CBindingSet *, int *); // idb
int __stdcall FExistActiveRasConnections(char); // idb
int __stdcall IsServiceRunning(LPCWSTR lpMachineName); // idb
int __fastcall load__MigrateWinsockConfiguration_12(int a1, int a2);
// int __usercall _tailMerge_MSWSOCK_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
void __thiscall CBindingSet::SortForPnpUnbind(CBindingSet *__hidden this); // idb
void __stdcall std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::less<CBindPath>>(int a1, int a2, int a3, int a4);
signed int __stdcall CImplINetCfgComponent::UnbindFrom(CImplINetCfgComponent *this, struct INetCfgComponent *a2);
int __fastcall load__SetupDiEnumDeviceInfo_12(int a1, int a2);
int __fastcall load__SetupDiGetClassDevsW_16(int a1, int a2);
__int32 __thiscall CNetConfigCore::HrDisableBindPath(CNetConfigCore *this, const struct CBindPath *); // idb
__int32 __thiscall CComponent::HrOpenDeviceInfo(CComponent *this, void **, struct _SP_DEVINFO_DATA *); // idb
int __fastcall load__pSetupLoadIndirectString_16(int a1, int a2);
int __fastcall load__CM_Get_DevNode_Status_Ex_20(int a1, int a2);
signed int __stdcall CImplINetCfgComponent::GetDeviceStatus(CImplINetCfgComponent *this, unsigned __int32 *a2);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
int __cdecl _local_unwind4(int a1, int a2, unsigned int a3);
signed int __cdecl sub_6E65598E(int a1, int a2, int a3, int a4);
int __thiscall _EH4_CallFilterFunc(void *this);
int __thiscall _EH4_TransferToHandler(void *this);
void __thiscall _EH4_GlobalUnwind(PVOID TargetFrame);
int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, int a4);
// _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD); weak
void _NLG_Notify1();
_DWORD __cdecl _NLG_Notify(_DWORD); // weak
int __thiscall _NLG_Call(_DWORD); // weak
size_t __cdecl strlen(const char *Str);
int nullsub_6(); // weak
int __thiscall nullsub_1(_DWORD); // weak
// void (__usercall *__usercall sub_6E656ABA@<eax>(int a1@<ebp>))(int a1@<ebp>);
// void __usercall sub_6E656AC4(int a1@<ebp>);
int nullsub_3(); // weak
int nullsub_4(); // weak
// _UNKNOWN *__usercall sub_6E657049@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E657056@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_6E65709F(int a1@<ebp>);
// void __usercall __noreturn sub_6E657288(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E65729A@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E6572B9@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_6E6572C6(int a1@<ebp>);
// void __usercall __noreturn sub_6E6572F8(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E657314@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_6E657321(int a1@<ebp>);
// void __usercall __noreturn sub_6E6573D8(int a1@<ebp>);
// void __userpurge sub_6E6573EB(int a1@<eax>, int a2@<ebp>, int a3, int a4, int a5, int a6);
// void __userpurge sub_6E6574AC(int a1@<eax>, int a2@<ebp>, int a3, int a4, int a5, int a6);
// _UNKNOWN *__usercall sub_6E65756D@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_6E657586(int a1@<ebp>);
// void __usercall __noreturn sub_6E6575A6(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E6575F9@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E65762B@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E65763F@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E658DE6@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E659648@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E659736@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E6598FC@<eax>(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E659AC2@<eax>(int a1@<ebp>);
// void __usercall __noreturn sub_6E659B9D(int a1@<ebp>);
// _UNKNOWN *__usercall sub_6E659C56@<eax>(int a1@<ebp>);
// int __usercall sub_6E659D48@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659D59(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6E659D63@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659D74(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6E659D84@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659D95(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6E659DBB@<eax>(int a1@<ebp>);
// void __usercall sub_6E659DCC(int a1@<ebp>);
// int __usercall sub_6E659DED@<eax>(int a1@<ebp>);
// void __usercall sub_6E659DFE(int a1@<ebp>);
// int __usercall sub_6E659E2C@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659E3D(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6E659E4D@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659E5E(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6E659E97@<eax>(int a1@<ebp>);
// void __userpurge sub_6E659EA8(int a1@<ebp>, int a2, int a3, int a4);
int nullsub_5(); // weak
int __stdcall NcAtlModuleRegisterServer(struct ATL::_ATL_MODULE *a1);
DWORD __stdcall CMSClient::UpdateRegistry(int a1);
DWORD __stdcall CImplINetCfg::UpdateRegistry(int a1);
void __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>(int this);
DWORD __stdcall CSrvrcfg::UpdateRegistry(int a1);
HRESULT __stdcall DllRegisterServer();
HRESULT __stdcall DllUnregisterServer();
signed int __stdcall NetClassInstaller(unsigned int a1, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
signed int __stdcall NetPropPageProvider(int a1, int (__stdcall *a2)(_DWORD, _DWORD), int a3);
__int32 CServiceManager::HrLock();
signed int __stdcall CMSClient::QueryPropertyUi(CMSClient *this, struct IUnknown *a2);
__int32 __stdcall CSrvrcfg::ApplyPnpChanges(CSrvrcfg *this, struct INetCfgPnpReconfigCallback *); // idb
void *__thiscall ATL::CComContainedObject<CMSClient>::CComContainedObject<CMSClient>(void *this, int a2);
// _DWORD __stdcall ATL::CComContainedObject<CMSClient>::AddRef(_DWORD); weak
// _DWORD __stdcall ATL::CComContainedObject<CMSClient>::Release(_DWORD); weak
// _DWORD __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(_DWORD, _DWORD, _DWORD); weak
CSrvrcfg *__thiscall ATL::CComContainedObject<CSrvrcfg>::CComContainedObject<CSrvrcfg>(CSrvrcfg *this, int a2);
// _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(_DWORD); weak
// _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(_DWORD); weak
// _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(_DWORD, _DWORD, _DWORD); weak
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(int a1, int a2, int a3);
int __thiscall ATL::CComAggObject<CMSClient>::CComAggObject<CMSClient>(int this, int a2);
void __thiscall ATL::CComAggObject<CMSClient>::~CComAggObject<CMSClient>(int this);
signed int __stdcall ATL::CComAggObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3);
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1);
void __thiscall ATL::CComAggObject<CImplINetCfg>::~CComAggObject<CImplINetCfg>(int this);
signed int __stdcall ATL::CComAggObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
int __thiscall ATL::CComAggObject<CSrvrcfg>::CComAggObject<CSrvrcfg>(int this, int a2);
void __thiscall ATL::CComAggObject<CSrvrcfg>::~CComAggObject<CSrvrcfg>(int this);
signed int __stdcall ATL::CComAggObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
void __thiscall ATL::CComObject<CAdvancedConfig>::~CComObject<CAdvancedConfig>(int this);
// __int32 __thiscall CAdvancedConfig::_InternalQueryInterface(CAdvancedConfig *this, const struct _GUID *, void **); idb
__int32 __stdcall ATL::CComObject<CAdvancedConfig>::QueryInterface(CAdvancedConfig *a1, struct _GUID *a2, void **a3);
void __thiscall ATL::CComAggObject<CAdvancedConfig>::~CComAggObject<CAdvancedConfig>(int this);
signed int __stdcall ATL::CComAggObject<CAdvancedConfig>::QueryInterface(int a1, struct _GUID *a2, void **a3);
void *__thiscall ATL::CComContainedObject<CAdvancedConfig>::CComContainedObject<CAdvancedConfig>(void *this, int a2);
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::Release(int a1);
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::QueryInterface(int a1, int a2, int a3);
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3);
void *__thiscall ATL::CComAggObject<CMSClient>::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall ATL::CComAggObject<CImplINetCfg>::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall ATL::CComAggObject<CSrvrcfg>::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall ATL::CComObject<CAdvancedConfig>::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall ATL::CComAggObject<CAdvancedConfig>::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall ATL::CComObject<CAdvancedConfig>::CComObject<CAdvancedConfig>(void *this, int a2);
int __thiscall ATL::CComAggObject<CAdvancedConfig>::CComAggObject<CAdvancedConfig>(int this, int a2);
void *__thiscall ATL::CComContainedObject<CImplINetCfg>::CComContainedObject<CImplINetCfg>(void *this, int a2);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1);
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1);
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1);
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1);
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1);
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CMSClient>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CSrvrcfg>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComObject<CAdvancedConfig>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CAdvancedConfig>>::CreateInstance(int a1, int a2, int a3);
int __thiscall ATL::CComAggObject<CImplINetCfg>::CComAggObject<CImplINetCfg>(int this, int a2);
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CAdvancedConfig>>,ATL::CComCreator<ATL::CComAggObject<CAdvancedConfig>>>::CreateInstance(int a1, int a2, int a3);
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CImplINetCfg>>::CreateInstance(int a1, int a2, int a3);
DWORD __thiscall ATL::CRegKey::DeleteSubKey(ATL::CRegKey *this, const unsigned __int16 *a2);
int __thiscall ATL::_stdcallthunk::Init(LPCVOID lpBaseAddress, unsigned __int32, void *); // idb
int __thiscall ATL::CDynamicStdCallThunk::Init(ATL::CDynamicStdCallThunk *this, unsigned __int32, void *); // idb
void __stdcall Ncfree(void *lpMem); // idb
void *__stdcall Ncrealloc(void *lpMem, SIZE_T dwBytes); // idb
ATL::CExpansionVector *__thiscall ATL::CExpansionVector::CExpansionVector(ATL::CExpansionVector *this);
int __thiscall ATL::CRegParser::EndOfVar(ATL::CRegParser *__hidden this); // idb
// LPWSTR __userpurge sub_6E65ECFF@<eax>(LPWSTR a1@<eax>, __int16 a2);
ATL::CRegParser *__thiscall ATL::CRegParser::CRegParser(ATL::CRegParser *this, struct ATL::CRegObject *a2);
BOOL __stdcall ATL::CRegParser::IsSpace(unsigned __int16 a2);
void __thiscall ATL::CRegParser::IncrementLinePos(ATL::CRegParser *__hidden this); // idb
void __thiscall ATL::CRegParser::SkipWhiteSpace(ATL::CRegParser *this); // idb
signed int __thiscall ATL::CRegParser::NextToken(ATL::CRegParser *this, unsigned __int16 *a2);
int __stdcall sub_6E65EED2(LPCWSTR lpString1, int); // idb
int __stdcall ATL::CRegParser::CanForceRemoveKey(const unsigned __int16 *lpString1);
int __stdcall ATL::CRegParser::HasSubKeys(HKEY hKey);
int __stdcall ATL::CRegParser::HasValues(HKEY hKey);
signed int __thiscall ATL::CRegParser::SkipAssignment(ATL::CRegParser *this, unsigned __int16 *a2);
ATL::CParseBuffer *__thiscall ATL::CParseBuffer::CParseBuffer(ATL::CParseBuffer *this, int a2);
int __thiscall ATL::CParseBuffer::AddChar(ATL::CParseBuffer *this, unsigned __int16); // idb
signed int __thiscall ATL::CExpansionVector::Add(ATL::CExpansionVector *this, LPCWSTR lpString, const unsigned __int16 *a3);
const unsigned __int16 *__thiscall ATL::CExpansionVector::Find(ATL::CExpansionVector *this, unsigned __int16 *); // idb
__int32 __thiscall ATL::CExpansionVector::ClearReplacements(ATL::CExpansionVector *__hidden this); // idb
signed int __stdcall ATL::CRegObject::AddReplacement(ATL::CRegObject *this, LPCWSTR lpString, const unsigned __int16 *a3);
__int32 __stdcall ATL::CRegObject::ClearReplacements(ATL::CRegObject *this); // idb
const unsigned __int16 *__thiscall ATL::CRegObject::StrFromMap(ATL::CRegObject *this, unsigned __int16 *); // idb
unsigned int __stdcall AtlA2WHelper(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar);
__int32 __stdcall ATL::CComClassFactory::LockServer(ATL::CComClassFactory *this, int); // idb
void __thiscall ATL::CComModule::AddCreateWndData(ATL::CComModule *this, struct ATL::_AtlCreateWndData *, void *); // idb
int __thiscall ATL::CComModule::ExtractCreateWndData(ATL::CComModule *this);
ATL::CRegObject *__thiscall ATL::CRegObject::CRegObject(ATL::CRegObject *this);
// __int32 __thiscall ATL::CRegKey::Close(ATL::CRegKey *__hidden this); idb
__int32 __thiscall ATL::CRegKey::Create(ATL::CRegKey *this, HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned __int32 *); // idb
__int32 __thiscall ATL::CRegKey::Open(ATL::CRegKey *this, HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired); // idb
__int32 __thiscall ATL::CRegKey::SetValue(ATL::CRegKey *this, BYTE Data, const unsigned __int16 *); // idb
__int32 __thiscall ATL::CRegKey::SetValue(ATL::CRegKey *this, LPCWSTR lpString, const unsigned __int16 *); // idb
signed int __stdcall ATL::AtlModuleUnregisterServer(struct ATL::_ATL_MODULE *a1, const struct _GUID *a2);
int __stdcall ATL::CDialogImplBase::DialogProc(HWND dwNewLong, unsigned int, unsigned int, __int32); // idb
int __thiscall ATL::CDialogImplBase::EndDialog(ATL::CDialogImplBase *this, int); // idb
void __thiscall ATL::CRegObject::~CRegObject(ATL::CRegObject *this);
signed int __thiscall ATL::CRegParser::AddValue(ATL::CRegParser *this, struct ATL::CRegKey *a2, const unsigned __int16 *a3, unsigned __int16 *a4);
int __thiscall ATL::CParseBuffer::AddString(ATL::CParseBuffer *this, const unsigned __int16 *); // idb
signed int __thiscall ATL::CRegParser::PreProcessBuffer(ATL::CRegParser *this, LPCWSTR lpString, unsigned __int16 **a3);
__int32 __thiscall ATL::CRegKey::RecurseDeleteKey(ATL::CRegKey *this, const unsigned __int16 *); // idb
BOOL __stdcall ATL::CDialogImplBase::StartDialogProc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4);
void __thiscall ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>(void *this);
signed int __thiscall ATL::CRegParser::RegisterSubkeys(ATL::CRegParser *this, HKEY a2, int a3, int a4);
signed int __thiscall ATL::CRegParser::RegisterBuffer(ATL::CRegParser *this, LPCWSTR lpString, int a3);
DWORD __thiscall ATL::CRegObject::RegisterFromResource(ATL::CRegObject *this, LPCWSTR lpLibFileName, LPCWSTR lpName, LPCWSTR lpType, int a5);
DWORD __stdcall ATL::CRegObject::ResourceRegister(ATL::CRegObject *this, LPCWSTR lpLibFileName, __int16 a3, LPCWSTR lpType);
DWORD __stdcall ATL::CRegObject::ResourceUnregister(ATL::CRegObject *this, LPCWSTR lpLibFileName, __int16 a3, LPCWSTR lpType);
DWORD __stdcall ATL::CComModule::UpdateRegistryFromResourceS(ATL::CComModule *this, __int16 a2, int a3, struct ATL::_ATL_REGMAP_ENTRY *a4);
const unsigned __int16 *__stdcall SzLoadString(HINSTANCE hModule, unsigned int); // idb
void __stdcall CiSetReservedField(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const void *); // idb
void __stdcall CiClearReservedField(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
const unsigned __int16 *__stdcall SzLoadIds(unsigned int); // idb
__int32 __thiscall HrRegGetSzWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int16 **a4);
int __stdcall FIsValidErrorFromINetCfgForDiHook(__int32); // idb
signed int __stdcall HrDiAddComponentToINetCfg(int a1, int a2, int a3);
__int32 __stdcall HrDiNotifyINetCfgOfInstallation(const struct NIQ_INFO *); // idb
void __stdcall DisableWOLForWiFi(struct COMPONENT_INSTALL_INFO *); // idb
__int32 __stdcall HrDiNotifyINetCfgOfRemoval(const unsigned __int16 *); // idb
int __stdcall IsServiceRunning(LPCWSTR lpServiceName); // idb
int __stdcall FIsEnumerated(const struct _GUID *); // idb
int __stdcall FIsHandledByClassInstaller(const struct _GUID *); // idb
__int32 __stdcall HrInsertItemIntoInstallQueue(const struct NIQ_INFO *); // idb
__int32 __stdcall HrDiInstallNetAdapter(struct COMPONENT_INSTALL_INFO *); // idb
__int32 __stdcall HrDiRemoveNetAdapter(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, unsigned __int16 *, HWND); // idb
__int32 __stdcall _HrNetClassInstaller(unsigned int a1, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
void *__cdecl std::char_traits<unsigned short>::_Copy_s(void *Dst, int a2, void *Src, int a4);
// int __cdecl std::char_traits<char>::_Copy_s(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount); idb
// int __cdecl std::char_traits<char>::_Move_s(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount); idb
void *__stdcall std::_Allocate<char>(SIZE_T dwBytes, int a2);
int __stdcall std::_Traits_helper::copy_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount, int); // idb
int __stdcall std::_Traits_helper::move_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount, int); // idb
void __thiscall CDiagContext::~CDiagContext(CDiagContext *this);
__int32 __stdcall HrRegQuerySzBuffer(HKEY hKey, LPCWSTR lpValueName, LPBYTE lpData, DWORD Type); // idb
void __stdcall PromptForLeakCheck(const struct DIAG_OPTIONS *, const char *); // idb
void __stdcall CmdRemoveReferences(const struct DIAG_OPTIONS *, struct CNetConfig *lpMem); // idb
void *__stdcall std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4, int a5);
char *__cdecl std::_Copy_opt<CComponent * *,CComponent * *>(void *Src, int a2, void *Dst);
signed int __stdcall StringCchCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4);
int __stdcall std::_Traits_helper::copy_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount); // idb
int __stdcall std::_Traits_helper::move_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount); // idb
int __stdcall HrFindBindPath(struct CImplINetCfg *a1, const unsigned __int16 *a2, struct INetCfgBindingPath **a3, struct INetCfgComponentBindings **a4);
void __stdcall CmdCleanup(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void *__stdcall std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4);
char *__cdecl std::copy<CComponent * *,CComponent * *>(void *Src, int a2, void *Dst);
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Tidy(int this, char a2, rsize_t MaxCount);
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::erase(int this, unsigned int a2, int a3);
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Copy(int this, int a2, rsize_t MaxCount);
// void __usercall __noreturn sub_6E662647(int a1@<ebp>);
void __stdcall CmdShowLanAdapterPnpIds(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::~basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(int this);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Grow(_DWORD, char); weak
void __stdcall CmdShowStackTable(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::~basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this);
// _DWORD __thiscall std::logic_error::~logic_error(std::logic_error *__hidden this); idb
const char *__thiscall std::logic_error::what(std::logic_error *__hidden this); // idb
void *__thiscall std::logic_error::`vector deleting destructor'(void *lpMem, char a2);
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(int this, int a2, int a3, rsize_t a4);
void __thiscall CComponentList::~CComponentList(CComponentList *this);
signed int __stdcall HrCreateINetCfg(int a1, struct CImplINetCfg **a2);
// void __userpurge CNetCfgInternalDiagnostic::DoEnumAllDiagnostic(int a1@<edi>, const struct DIAG_OPTIONS *a2);
// void __userpurge CNetCfgInternalDiagnostic::DoWriteLockDiagnostic(int a1@<edi>, int a2@<esi>, const struct DIAG_OPTIONS *a3, struct CNetConfig *a4);
// void __userpurge CmdAddComponent(int a1@<edi>, struct IUnknown *a2, struct CNetConfig *a3);
void __stdcall CmdAddRemoveStress(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
// void __userpurge CmdRemoveComponent(int a1@<edi>, const struct DIAG_OPTIONS *a2, struct CNetConfig *a3);
// void __userpurge CmdUpdateComponent(int a1@<edi>, struct IUnknown *a2, struct CNetConfig *a3);
void __stdcall CmdShowComponents(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
// void __userpurge CmdEnableOrDisableBinding(struct IUnknown *a1@<ecx>, int a2@<edi>, struct IUnknown *a3, int a4);
// void __userpurge CmdMoveBinding(int a1@<edi>, struct IUnknown *a2);
// void __userpurge CmdSetWanOrder(struct IUnknown *a1@<ecx>, int a2@<esi>, const struct DIAG_OPTIONS *a3);
// int __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(void *Src, rsize_t MaxCount); idb
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(_DWORD); weak
int __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(void *Src); // idb
exception *__thiscall std::logic_error::logic_error(exception *this, int a2);
std::logic_error *__thiscall std::logic_error::logic_error(std::logic_error *this, const struct std::logic_error *a2);
// _DWORD __stdcall std::length_error::length_error(_DWORD); weak
// _DWORD __thiscall std::length_error::length_error(std::length_error *this, const struct std::length_error *); idb
// int __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(void *Src); idb
void __thiscall __noreturn std::logic_error::_Doraise(std::logic_error *this);
void __thiscall __noreturn std::length_error::_Doraise(std::length_error *this);
void __thiscall CLanaMap::~CLanaMap(CLanaMap *this);
void *__thiscall CLanaMap::CLanaMap(void *Dst);
void __stdcall CmdShowLanaDiag(const struct DIAG_OPTIONS *); // idb
void __stdcall CmdShowLanaPaths(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void __stdcall CmdSetLanaNumber(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void __thiscall CBindingSet::~CBindingSet(CBindingSet *this);
void __stdcall CmdShowBindings(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void __stdcall CmdWriteBindings(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void __stdcall CmdRewriteLanaInfo(const struct DIAG_OPTIONS *, struct CNetConfig *); // idb
void __stdcall CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic(const struct DIAG_OPTIONS *, int); // idb
void __stdcall CNetCfgInternalDiagnostic::DoSaveLoadDiagnostic(const struct DIAG_OPTIONS *, struct CNetConfig *lpMem); // idb
// void __userpurge CNetCfgInternalDiagnostic::CmdFullDiagnostic(int a1@<edi>, const struct DIAG_OPTIONS *a2, struct CNetConfig *lpMem);
// void __userpurge NetCfgDiagFromCommandArgs(int a1@<edi>, struct IUnknown *a2);
void __stdcall NetCfgDiagRepairRegistryBindings(FILE *File);
void __stdcall LanaCfgFromCommandArgs(struct DIAG_OPTIONS *a1);
signed int __stdcall CImplINetCfg::GetAdapterOrder(CImplINetCfg *this, unsigned __int32 *a2, struct INetCfgComponent ***a3, int *a4);
int __stdcall StringCchCatNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4);
signed int __stdcall CImplINetCfg::Validate(CImplINetCfg *this);
signed int __stdcall CImplINetCfg::Cancel(CImplINetCfg *this);
signed int __stdcall CImplINetCfg::IsWriteLocked(CImplINetCfg *this, unsigned __int16 **a2);
signed int __stdcall CImplINetCfg::BeginBatchOperation(CImplINetCfg *this);
signed int __stdcall CImplINetCfg::CommitBatchOperation(CImplINetCfg *this);
signed int __stdcall CImplINetCfg::SelectWithFilterAndInstall(CImplINetCfg *this, HWND hWnd, const struct _GUID *lpMem, struct tagOBO_TOKEN *a4, const struct tagCI_FILTER_INFO *a5, struct INetCfgComponent **a6);
signed int __stdcall CImplINetCfg::EnumeratedComponentInstalled(CImplINetCfg *this, void *a2);
signed int __stdcall CImplINetCfg::EnumeratedComponentUpdated(CImplINetCfg *this, const unsigned __int16 *a2);
signed int __stdcall CImplINetCfg::UpdateNonEnumeratedComponent(CImplINetCfg *this, struct INetCfgComponent *a2, unsigned __int32 a3, unsigned __int32 a4);
signed int __stdcall CImplINetCfg::EnumeratedComponentRemoved(CImplINetCfg *this, const unsigned __int16 *a2);
signed int __stdcall CImplINetCfg::GetWanAdaptersFirst(CImplINetCfg *this, int *a2);
signed int __stdcall CImplINetCfg::SetWanAdaptersFirst(CImplINetCfg *this, int a2);
__int32 __stdcall CImplINetCfg::SendPnpReconfig(CImplINetCfg *this, enum tagNCPNP_RECONFIG_LAYER a2, PCWSTR a3, unsigned __int16 *a4, void *a5, size_t Size);
signed int __stdcall CImplINetCfg::HrCreateInstance(struct CNetConfig *a1, struct CImplINetCfg **a2);
void __thiscall CNotifyObjectInterface::~CNotifyObjectInterface(CNotifyObjectInterface *this);
struct INetCfgComponent *__thiscall CComponent::GetINetCfgComponentInterface(CComponent *__hidden this); // idb
int __thiscall CComponent::FCanDirectlyBindToFilter(CComponent *this, const unsigned __int16 *const , const unsigned __int16 *const ); // idb
int __thiscall CComponent::FIsWanAdapter(CComponent *__hidden this); // idb
__int32 __thiscall CComponent::HrStartEnumeratedComponent(CComponent *this); // idb
__int32 __thiscall CComponent::HrOpenInfFile(CComponent *this, void **); // idb
int __stdcall FIsIscsiNicFromNdisNsi(struct _GUID); // idb
int __stdcall FIsIsciSupportedProtocol(const unsigned __int16 *); // idb
unsigned __int32 __stdcall DeletePersistedInterface(unsigned __int16, unsigned __int32); // idb
unsigned __int32 __stdcall FreeNetLuidIndex(unsigned __int16, unsigned __int32); // idb
int __stdcall SetInterfaceDelayedCleanup(unsigned __int16 a1, unsigned __int32 a2);
LSTATUS __stdcall DeleteConnectionRegistryKey(LPCWSTR pszSubKey);
signed int StringCchPrintfW(wchar_t *Dest, unsigned int a2, wchar_t *Format, ...);
__int32 __stdcall HrGetTempKeyPathFromPnPInstanceID(STRSAFE_LPWSTR pszDest, size_t cchDest, const unsigned __int16 *); // idb
void __stdcall StoreExternalResourceInfoInTempRegLocation(HKEY, const unsigned __int16 *); // idb
void __stdcall SetDelayedCleanupFlagEnumCompRemoval(const unsigned __int16 *a1, int Data);
void __stdcall TestAndSetDelayedCleanup(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const unsigned __int16 *); // idb
unsigned __int32 __stdcall SetConnectionNameDelayedCleanup(LPCWSTR pszSubKey); // idb
void __stdcall ReleaseExternallyManagedResources(const unsigned __int16 *); // idb
unsigned __int32 __stdcall EInterfaceTypeFromDword(unsigned __int32 a1);
__int32 __stdcall HrCiGetBusInfoFromInf(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue); // idb
HINF __stdcall HrCiInstallEnumeratedComponent(HINF InfHandle, HKEY a2, const struct COMPONENT_INSTALL_INFO *IntegerValue);
void __stdcall AddOrRemoveLegacyNt4AdapterKey(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData, GUID *a3, BYTE *a4, int a5);
unsigned int __stdcall GetNextStringToken(unsigned __int16 *a1, const unsigned __int16 *a2, unsigned __int16 **a3);
void __stdcall SignalNetworkProviderLoaded(); // idb
int __stdcall FIsFilterDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
unsigned __int32 __stdcall WaitForConnectionNameMutex(); // idb
void __stdcall ReleaseConnectionNameMutex(); // idb
signed int __stdcall HrPnpIdToRegKeyName(unsigned __int16 *a1, unsigned __int32 a2, const unsigned __int16 *a3);
void __stdcall StoreInfoForINetCfg(HKEY, const unsigned __int16 *); // idb
void __stdcall FreeInfoStoredForInetCfg(const unsigned __int16 *); // idb
// int __cdecl wmemmove_s(void *Dst, int, void *Src, int); idb
void *__cdecl std::char_traits<unsigned short>::_Move_s(void *Dst, int a2, void *Src, int a4);
signed int __fastcall sub_6E6684C9(unsigned int a1, int a2, unsigned int a3);
// signed int __userpurge sub_6E6684E7@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3, unsigned int a4);
__int32 __stdcall HrRegisterComObject(const unsigned __int16 *); // idb
// __int32 __stdcall HrUnregisterComObject(const unsigned __int16 *); idb
__int32 __stdcall HrRegSetSzAsUlong(HKEY hKey, LPCWSTR lpValueName, unsigned __int32 Value, int Radix); // idb
HICON __stdcall BeginWaitCursor(); // idb
void __stdcall EndWaitCursor(HICON hInstance); // idb
void __thiscall CWaitCursor::~CWaitCursor(CWaitCursor *this);
int __cdecl TemporaryCode::FInSystemSetup();
__int32 __stdcall HrSetupGetIndirectStringsFromDriverInfoWithAlloc(int a1, int a2, int a3, int a4, int a5);
__int32 __stdcall HrCiRegDeleteComponentNetworkKey(int a1, const WCHAR *a2);
DWORD __stdcall FGetFullShadowedPath(LPWSTR pszDest, LPCWSTR pszPath);
__int32 __stdcall HrCiInstallFromInfSection(HINF InfHandle, PCWSTR SectionName, HKEY RelativeKeyRoot, HWND QueueHandle, unsigned __int32); // idb
__int32 __stdcall HrCiGetDriverDetail(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DRVINFO_DATA_V2_W *Dst, struct _SP_DRVINFO_DETAIL_DATA_W **); // idb
__int32 __stdcall HrCiCreateInstanceKey(struct COMPONENT_INSTALL_INFO *, PHKEY phkResult); // idb
__int32 __stdcall HrCiCallClassInstallerToInstallComponent(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, void *); // idb
void __stdcall SetBadDriverFlagIfNeededInList(HDEVINFO DeviceInfoSet); // idb
__int32 __stdcall HrCiExcludeNonNetClassDriverFromSelectUsingInfId(HDEVINFO DeviceInfoSet, const unsigned __int16 *); // idb
void __stdcall ExcludeLockedDownComponents(const unsigned __int16 *, HDEVINFO DeviceInfoSet); // idb
__int32 __stdcall HrCiHideIrrelevantRasProtocols(HDEVINFO DeviceInfoSet, int a2);
__int32 __stdcall HrCiRemoveFilterDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
int __stdcall HrGetFirstComponent(struct IEnumNetCfgComponent *a1, struct INetCfgComponent **a2);
int __stdcall HrGetNextComponent(struct IEnumNetCfgComponent *a1, struct INetCfgComponent **a2);
int __stdcall HrGetComponentEnum(struct INetCfg *a1, const struct _GUID *a2, struct IUnknown *a3);
int __stdcall HrGetNumInstalledFilters(unsigned __int32 *a1);
char __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Inside(int a1, int a2, unsigned int a3);
void *__stdcall std::_Allocate<unsigned short>(int a1, int a2);
void *__stdcall std::_Traits_helper::move_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4, int a5);
signed int __stdcall StringCbCatW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3);
__int32 __stdcall HrCiInstallServices(HINF InfHandle, const unsigned __int16 *); // idb
__int32 __stdcall HrCiDoCompleteSectionInstall(HINF InfHandle, HKEY RelativeKeyRoot, wchar_t *Str, HWND QueueHandle, int); // idb
__int32 __stdcall HrCiGetDriverInfo(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *, const struct _GUID *, const unsigned __int16 *, const unsigned __int16 *); // idb
__int32 __stdcall HrCiGetClassAndInfFileOfInfId(const unsigned __int16 *, enum NETCLASS *, unsigned __int16 *); // idb
__int32 __stdcall HrCiDoOemFileCopyIfNeeded(wchar_t *Str, unsigned __int16 *, unsigned __int32); // idb
__int32 __stdcall HrCiSetSelectDeviceDialogStrings(HDEVINFO, PSP_DEVINFO_DATA, const struct _GUID *); // idb
__int32 __stdcall HrCiPrepareSelectDeviceDialog(HDEVINFO, struct _SP_DEVINFO_DATA *); // idb
signed int __stdcall HrCiInstallFilterDevice(HDEVINFO a1, const unsigned __int16 *a2, struct CComponent *a3, struct CComponent *a4, struct CFilterDevice **a5);
void *__stdcall std::_Traits_helper::move_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4);
__int32 __stdcall HrCiBuildExcludedDriverList(HDEVINFO DeviceInfoSet, int a2, int a3);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Copy(int this, int a2, int a3);
// void __usercall __noreturn sub_6E66A012(int a1@<ebp>);
BOOL __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(int this, int a2, char a3);
__int32 __stdcall HrCiRegisterNotificationDll(HKEY a1, int a2, int a3);
__int32 __stdcall HrCiGetPropertiesFromInf(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, int a2, unsigned int a3, int a4);
int __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int a1, int a2, void *Src, int a4);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, void *Src);
__int32 __stdcall HrCiRemoveNonEnumeratedComponent(int a1, HKEY hKey, int a3, int a4, int a5);
__int32 __stdcall HrCiRemoveComponent(CComponent *a1, int a2);
__int32 __stdcall HrCiInstallNonEnumeratedComponent(void *, HKEY hKey, struct COMPONENT_INSTALL_INFO *); // idb
__int32 __stdcall HrCiIsInstalledComponent(struct COMPONENT_INSTALL_INFO *, HKEY *); // idb
signed int __stdcall HrCiCreateInstanceKeyAndProcessMainInfSection(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue, PHKEY phkResult);
signed int __stdcall HrCiInstallComponentInternal(HKEY phkResult);
__int32 __stdcall HrCiInstallComponent(const struct COMPONENT_INSTALL_PARAMS *, struct CComponent **, unsigned __int32 *); // idb
__int32 __stdcall HrCiSelectComponent(int a1, HWND hwndParent, void *a3, int a4);
__int32 __stdcall HrCiCreateAndWaitForIndexListMutex(void **); // idb
int __stdcall HrCiAddNextAvailableIndex(wchar_t *Str, unsigned __int32 *a2, unsigned __int16 **a3);
signed int __stdcall HrCiUpdateDescriptionIndexList(int a1, const WCHAR *a2, int a3, unsigned __int32 *a4);
void __stdcall CiSetFriendlyNameIfNeeded(const struct COMPONENT_INSTALL_INFO *); // idb
signed int __thiscall CNotifyObjectInterface::HrQueryPropertyUi(CNotifyObjectInterface *this, struct CImplINetCfg *a2, struct IUnknown *a3);
void __thiscall CNotifyObjectInterface::SetUiContext(CNotifyObjectInterface *this, struct CImplINetCfg *, struct IUnknown *); // idb
// _UNKNOWN *__usercall sub_6E66B996@<eax>(int a1@<ebp>);
int __thiscall CNotifyObjectInterface::QueryNotifyObject(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct _GUID *a3, void **a4);
int __thiscall CNotifyObjectInterface::NewlyAdded(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct NETWORK_INSTALL_PARAMS *a3);
void __thiscall CNotifyObjectInterface::Removed(CNotifyObjectInterface *this, struct CImplINetCfg *); // idb
void __thiscall CNotifyObjectInterface::Updated(CNotifyObjectInterface *this, struct CImplINetCfg *, unsigned __int32, unsigned __int32); // idb
int __thiscall CBindingSet::PGetBindPathAtIndex(void *this, int a2, unsigned int a3);
void __thiscall CGlobalNotifyInterface::ReleaseAllNotifyObjects(CGlobalNotifyInterface *this, struct CComponentList *, int); // idb
int __thiscall CGlobalNotifyInterface::NgSysNotifyComponent(CGlobalNotifyInterface *this, unsigned __int32 a2, struct CComponent *a3);
int __thiscall CGlobalNotifyInterface::ComponentAdded(CGlobalNotifyInterface *this, struct CComponent *a2, const struct NETWORK_INSTALL_PARAMS *a3);
int __thiscall CGlobalNotifyInterface::ComponentRemoved(CGlobalNotifyInterface *this, struct CComponent *a2);
int __thiscall CGlobalNotifyInterface::ComponentUpdated(CGlobalNotifyInterface *this, struct CComponent *a2, unsigned __int32 a3, unsigned __int32 a4);
__int32 __thiscall CGlobalNotifyInterface::QueryAndNotifyBindPaths(CGlobalNotifyInterface *this, unsigned __int32, struct CBindingSet *, unsigned int); // idb
signed int __thiscall CNotifyObjectInterface::HrShowPropertyUi(CNotifyObjectInterface *this, struct CImplINetCfg *a2, HWND a3, struct IUnknown *a4);
int __cdecl wmemcmp(const wchar_t *S1, const wchar_t *S2, size_t N);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::capacity(int this);
void *__stdcall std::_Allocate<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2);
signed int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(int this, unsigned int a2, unsigned int a3, wchar_t *S2, int N);
int __thiscall CComponentReferences::CountTotalReferencedBy(CComponentReferences *this);
__int32 __stdcall HrGetSoftwareOboTokenKey(const struct tagOBO_TOKEN *, int, HKEY hKey); // idb
int __thiscall CComponentReferences::PSoftwareReferencedByAtIndex(void *this, int a2);
signed int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(int this, wchar_t *a2);
int __thiscall CComponentReferences::FIsReferencedByComponent(CComponentReferences *this, const struct CComponent *); // idb
BOOL __cdecl std::operator==<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>>(int a1, wchar_t *a2);
void __thiscall CComponentReferences::GetReferenceDescriptionsAsMultiSz(CComponentReferences *this, LPBYTE lpData, unsigned __int32 *); // idb
int __stdcall std::find<std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>,unsigned short const *>(int a1, int a2, int a3, wchar_t **a4);
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(_DWORD); weak
void *__thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::`scalar deleting destructor'(void *lpMem, char a2);
int __thiscall CComponentReferences::FIsReferencedByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this, int a2);
int __cdecl std::_Copy_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(int a1, int a2, int a3, int a4);
int __cdecl std::_Copy_backward_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2, int a3);
void (__cdecl *__stdcall std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2))(int a1, int a2);
void *__stdcall std::_Destroy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(void *lpMem);
int __cdecl std::copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(int a1, int a2, int a3, int a4);
int __cdecl std::fill<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2, int a3);
int __cdecl std::copy_backward<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2, int a3);
int __stdcall std::_Uninit_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this, void *Src);
void __noreturn std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
void *__stdcall std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(void *lpMem, int a2, int a3, int a4);
void (__cdecl *__stdcall std::_Uninit_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4, int a5, int a6))(int a1, int a2);
int __stdcall std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4);
void *__stdcall std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(void *lpMem, int a2, int a3);
void (__cdecl *__stdcall stdext::unchecked_uninitialized_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4))(int a1, int a2);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Ufill(int this, int a2, int a3, int a4);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Insert_n(void *this, int a2, int a3, int a4);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(int, int, int); // idb
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::insert(int this, int a2, int a3, int a4);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(int, int, int, int); // idb
__int32 __thiscall CComponentReferences::HrRemoveReferenceByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *); // idb
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::push_back(int this, int a2);
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::clear(int this);
int __thiscall CComponentReferences::HrAddReferenceBySoftware(CComponentReferences *this, const unsigned __int16 *Src);
// _UNKNOWN *__usercall sub_6E66D22A@<eax>(int a1@<ebp>);
void __thiscall CComponentReferences::RemoveAllReferences(CComponentReferences *__hidden this); // idb
signed int __thiscall CComponentReferences::HrAddReferenceByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *lpMem);
int __thiscall CComponentList::PFindComponentByBindForm(int this, unsigned int a2, wchar_t *Str1);
int __thiscall CComponentList::PFindComponentByBindName(int this, unsigned int a2, wchar_t *Str1);
int __thiscall CComponentList::PFindComponentByPnpId(CComponentList *this, const unsigned __int16 *Str1);
void __thiscall CComponentList::RemoveComponent(CComponentList *this, const struct CComponent *); // idb
void __stdcall GetFirstComponentFromBindPath(wchar_t *Str, const unsigned __int16 **, unsigned __int32 *); // idb
int __stdcall FBindPathContainsMultipleInterface(const struct CComponentList *, wchar_t *Str); // idb
char __stdcall CLanaMap::GetExportValue(const struct CComponentList *a2, const unsigned __int16 *Str);
unsigned __int8 __thiscall CLanaMap::GetMaxLana(CLanaMap *this);
int __stdcall std::find<unsigned char *,int>(int a1, int a2, int a3);
__int32 __thiscall CLanaMap::HrWriteLanaMapConfig(CLanaMap *__hidden this); // idb
signed int __thiscall CLanaMap::HrCreateRegistryMap(CLanaMap *this);
void __thiscall CLanaMap::GetLanaEntry(CLanaMap *this, const struct CComponentList *, struct CLanaEntry *); // idb
signed int __thiscall CLanaMap::HrSetLanaNumber(CLanaMap *this, char a2, unsigned __int8 a3);
signed int __thiscall CLanaMap::HrWriteLanaConfiguration(CLanaMap *this, const struct CComponentList *a2);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, int a2, unsigned int a3, int a4);
int __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int a1, int a2, void *Src, int a4);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, void *Src);
int __thiscall CLanaMap::Dump(void *this, int a2);
__int32 __thiscall CLanaMap::HrReserveRoomForEntries(CLanaMap *this, unsigned int); // idb
// _UNKNOWN *__usercall sub_6E66DAE4@<eax>(int a1@<ebp>);
__int32 __thiscall CLanaMap::HrAppendEntry(CLanaMap *this, struct CLanaEntry *); // idb
// void __userpurge sub_6E66DB29(int a1@<ebp>, int a2);
__int32 __thiscall CLanaMap::HrLoadLanaMap(CLanaMap *__hidden this); // idb
signed int __stdcall HrUpdateLanaConfig(const struct CComponentList *a1, const unsigned __int16 *a2, unsigned int a3);
__int32 __thiscall CNetConfigCore::HrAddComponentToCore(CNetConfigCore *this, struct CComponent *a2, unsigned __int32 a3);
void __thiscall CNetConfigCore::RemoveComponentFromCore(CNetConfigCore *this, const struct CComponent *); // idb
void __thiscall CNetConfigCore::EnsureComponentNotReferencedByOthers(CNetConfigCore *this, const struct CComponent *); // idb
void __thiscall CNetConfigCore::Free(CNetConfigCore *__hidden this); // idb
void __thiscall GBCONTEXT::~GBCONTEXT(GBCONTEXT *this);
int __thiscall CNetConfigCore::HrGetBindingsInvolvingComponent(CNetConfigCore *this, const struct CComponent *a2, unsigned __int32 a3, struct CBindingSet *a4);
bool __thiscall CBindPath::operator<(int this, int a2);
bool __thiscall CBindPath::operator>(int this, int a2);
int __thiscall CBindingSet::FContainsComponent(CBindingSet *this, const struct CComponent *); // idb
void *__cdecl std::_Copy_opt<CBindPath *,CBindPath *>(int a1, int a2, void *a3);
void *__cdecl std::_Copy_backward_opt<CBindPath *,CBindPath *>(int a1, int a2, void *a3);
void __stdcall std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9);
void __stdcall std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9);
void *__cdecl std::copy<CBindPath *,CBindPath *>(int a1, int a2, void *a3);
void *__cdecl std::copy_backward<CBindPath *,CBindPath *>(int a1, int a2, void *a3);
void __stdcall std::swap<CBindPath>(int a1, int a2);
void __stdcall std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9);
void __stdcall std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9);
void __stdcall std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, void *a3, char a4, char a5, int a6, int a7, int a8, int a9, int a10);
void __stdcall std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath>(int a1, int a2, int a3, int a4, int a5);
void __stdcall std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, void *a3, char a4, char a5, int a6, int a7, int a8, int a9, int a10);
void __stdcall std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, int a4, int a5);
void __stdcall std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, int a4, int a5);
void __stdcall std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, int a4);
void __stdcall std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3);
void __stdcall std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3, int a4);
void __stdcall std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3);
void __thiscall CBindingSet::RemoveBindPathsWithComponent(CBindingSet *this, const struct CComponent *); // idb
int __stdcall std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, unsigned int a3, int a4);
int __stdcall std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3);
int __stdcall std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, unsigned int a3, int a4);
int __stdcall std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3);
void __stdcall std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3);
unsigned __int32 __stdcall CbOfMultiSzAndTermSafe(const unsigned __int16 *); // idb
void *__thiscall CDiagContext::GrowScratchBuffer(CDiagContext *this, unsigned __int32 *); // idb
__int32 __stdcall HrWriteFilteredAdapterUpperBind(HKEY hKey, BYTE *lpData); // idb
__int32 __stdcall HrWriteFilterDeviceLinkage(struct CFilterDevice *, void *, const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *); // idb
__int32 __stdcall CRegistryBindingsContext::HrDeleteBindingsForComponent(const struct CComponent *rguid);
__int32 __thiscall CModifyContext::HrDirtyComponent(CModifyContext *this, const struct CComponent *); // idb
__int32 __thiscall CModifyContext::HrDirtyComponentAndComponentsAbove(CModifyContext *this, const struct CComponent *); // idb
void __thiscall CModifyContext::PushRecursionDepth(CModifyContext *__hidden this); // idb
void __thiscall CModifyContext::InstallOrRemoveRequiredComponents(CModifyContext *this, HKEY a2, int a3);
__int32 __thiscall CModifyContext::HrBeginBatchOperation(CModifyContext *__hidden this); // idb
__int32 __stdcall CModifyContext::HrProcessWinsockRemove(const struct CComponent *a2);
int __thiscall CModifyContext::HrPopRecursionDepth(CModifyContext *this);
int __thiscall CModifyContext::HrUpdateComponent(CModifyContext *this, struct CComponent *a2, unsigned __int32 a3, unsigned __int32 a4);
int __thiscall CModifyContext::HrEndBatchOperation(int this, int a2);
signed int __stdcall CImplIEnumNetCfgComponent::Clone(CImplIEnumNetCfgComponent *this, struct IEnumNetCfgComponent **a2);
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Skip(CImplIEnumNetCfgBindingInterface *this, unsigned __int32); // idb
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Reset(CImplIEnumNetCfgBindingInterface *this); // idb
signed int __stdcall CImplIEnumNetCfgComponent::Skip(CImplIEnumNetCfgComponent *this, unsigned __int32 a2);
__int32 __stdcall CImplIEnumNetCfgBindingPath::Skip(CImplIEnumNetCfgBindingPath *this, unsigned __int32); // idb
void *__thiscall CBindingSet::`scalar deleting destructor'(void *lpMem, char a2);
void *__thiscall CImplIEnumNetCfgBindingPath::`scalar deleting destructor'(void *lpMem, char a2);
// __int32 __thiscall CImplIEnumNetCfgBindingPath::_InternalQueryInterface(CImplIEnumNetCfgBindingPath *this, const struct _GUID *, void **); idb
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgBindingPath>::QueryInterface(CImplIEnumNetCfgBindingPath *a1, struct _GUID *a2, void **a3);
__int32 __thiscall CExternalComponentData::HrReloadExternalData(CExternalComponentData *this); // idb
signed int __thiscall CExternalComponentData::HrSetDescription(CExternalComponentData *this, const unsigned __int16 *a2);
int __stdcall CImplINetCfgClass::SelectAndInstall(CImplINetCfgClass *this, HWND a2, struct tagOBO_TOKEN *a3, struct INetCfgComponent **a4);
signed int __stdcall CImplINetCfgClass::FindComponent(CImplINetCfgClass *this, wchar_t *Str1, struct INetCfgComponent **a3);
signed int __stdcall CImplINetCfgClass::Install(CImplINetCfgClass *this, const unsigned __int16 *a2, struct tagOBO_TOKEN *a3, unsigned __int32 a4, unsigned __int32 a5, const unsigned __int16 *a6, const unsigned __int16 *a7, struct INetCfgComponent **a8);
signed int __stdcall CImplINetCfgClass::DeInstall(CImplINetCfgClass *this, struct INetCfgComponent *a2, struct tagOBO_TOKEN *cb, unsigned __int16 **a4);
__int32 __stdcall ATL::CComObject<CImplINetCfgClass>::QueryInterface(int a1, struct _GUID *a2, void **a3);
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::AddRef(int a1);
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::Release(int a1);
void __thiscall CModifyContext::InstallAndAddAndNotifyComponent(CModifyContext *this, const struct COMPONENT_INSTALL_PARAMS *, struct CComponent **); // idb
int __thiscall CModifyContext::HrInstallNewOrReferenceExistingComponent(CModifyContext *this, const struct COMPONENT_INSTALL_PARAMS *a2, struct CComponent **a3);
struct INetCfgComponentVtbl *__stdcall PComponentFromComInterface(struct INetCfgComponent *a1);
signed int __stdcall HrIsValidINetCfgComponent(struct INetCfgComponent *a1);
int __stdcall CImplINetCfgComponent::SetDisplayName(CImplINetCfgComponent *this, const unsigned __int16 *a2);
signed int __stdcall CImplINetCfgComponent::GetHelpText(CImplINetCfgComponent *this, unsigned __int16 **a2);
signed int __stdcall CImplINetCfgComponent::GetCharacteristics(CImplINetCfgComponent *this, unsigned __int32 *a2);
signed int __stdcall CImplINetCfgComponent::GetPnpDevNodeId(CImplINetCfgComponent *this, unsigned __int16 **a2);
signed int __stdcall CImplINetCfgComponent::OpenParamKeyReadOnly(CImplINetCfgComponent *this, PHKEY phkResult);
signed int __stdcall CImplINetCfgComponent::RaisePropertyUi(struct IUnknown *this, HWND hWnd, unsigned __int32 a3, struct IUnknown *a4);
signed int __stdcall CImplINetCfgComponent::QueryNotifyObject(CImplINetCfgComponent *this, const struct _GUID *a2, void **a3);
signed int __stdcall CImplINetCfgComponent::SetDirty(CImplINetCfgComponent *this);
signed int __stdcall CImplINetCfgComponent::NotifyUpperEdgeConfigChange(CImplINetCfgComponent *this);
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3);
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3);
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1);
signed int __thiscall CImplINetCfgComponent::HrMoveBindPath(CImplINetCfgComponent *this, CImplINetCfgBindingPath *a2, CImplINetCfgBindingPath *a3, int a4);
signed int __stdcall CImplINetCfgComponent::MoveBefore(CImplINetCfgComponent *this, struct INetCfgBindingPath *a2, struct INetCfgBindingPath *a3);
signed int __stdcall CImplINetCfgComponent::MoveAfter(CImplINetCfgComponent *this, struct INetCfgBindingPath *a2, struct INetCfgBindingPath *a3);
signed int __stdcall CImplINetCfgComponent::IsBindableTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2);
signed int __stdcall FOboTokenValidForClass(int a1, int a2);
signed int __stdcall HrProbeOboToken(const struct tagOBO_TOKEN *a1);
void __thiscall CModifyContext::NotifyAndRemoveComponent(CModifyContext *this, struct CComponent *); // idb
int __thiscall CModifyContext::HrRemoveComponentIfNotReferenced(CModifyContext *this, struct CComponent *a2, SIZE_T cb, unsigned __int16 **a4);
// _DWORD __stdcall CStackEntry::operator==(_DWORD); weak
void __thiscall CStackTable::SetWanAdapterOrder(CStackTable *this, int); // idb
int __cdecl std::_Copy_opt<CStackEntry *,CStackEntry *>(int a1, int a2, int a3);
int __cdecl std::_Copy_backward_opt<CLanaEntry *,CLanaEntry *>(int a1, int a2, int a3);
int __stdcall std::find<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry>(int a1, int a2, int a3, int a4);
int __cdecl std::copy<CStackEntry *,CStackEntry *>(int a1, int a2, int a3);
int __cdecl std::copy_backward<CLanaEntry *,CLanaEntry *>(int a1, int a2, int a3);
int __thiscall CStackTable::FStackEntryInTable(CStackTable *this, const struct CComponent *, const struct CComponent *); // idb
void __stdcall GetComponentsAboveComponent(const struct CComponent *, struct GCCONTEXT *); // idb
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(int this, int a2, int a3);
void __thiscall CStackTable::RemoveStackEntry(CStackTable *this, const struct CComponent *, const struct CComponent *); // idb
void __thiscall CStackTable::RemoveEntriesWithComponent(CStackTable *this, const struct CComponent *); // idb
__int32 __thiscall CStackTable::HrMoveStackEntries(int this, int a2, int a3, int a4, CModifyContext *a5);
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::push_back(int this, int a2);
__int32 __thiscall CStackTable::HrInsertStackEntriesForComponent(CStackTable *this, const struct CComponent *, const struct CComponentList *, unsigned __int32); // idb
__int32 __thiscall CStackTable::HrUpdateEntriesForComponent(CStackTable *this, const struct CComponent *, const struct CComponentList *, unsigned __int32); // idb
__int32 __stdcall HrRemoveNameSpaceProvider(LPGUID lpProviderId); // idb
__int32 __stdcall HrAddNameSpaceProvider(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId); // idb
__int32 __stdcall HrWriteWinsockMapping(LPCWSTR lpSrc, HKEY); // idb
__int32 __stdcall HrInstallWinsock(); // idb
__int32 __stdcall HrIsWinsockInstalled(int *); // idb
__int32 __stdcall HrUpdateWinsockTransportList(wchar_t *Str2, int); // idb
__int32 __stdcall HrWriteWinsockInfo(int a1, _DWORD a2, _DWORD a3, int a4);
__int32 __stdcall HrInstallWinsockDependancy(HINF InfHandle, PCWSTR Section); // idb
__int32 __stdcall HrRemoveWinsockDependancy(void *, const unsigned __int16 *); // idb
__int32 __stdcall HrAddOrRemoveWinsockDependancy(void *, const unsigned __int16 *); // idb
void __stdcall EnumLockedDownComponents(void (__stdcall *)(const unsigned __int16 *, void *), void *); // idb
int __stdcall FGetOrSetComponentLockDown(int, STRSAFE_LPCWSTR pszSrc); // idb
// int __stdcall FIsComponentLockedDown(STRSAFE_LPCWSTR pszSrc); idb
void __stdcall LockdownComponentUntilNextReboot(STRSAFE_LPCWSTR pszSrc); // idb
signed int __stdcall CFilterDevice::HrCreateInstance(struct CComponent *a1, struct CComponent *a2, const struct _SP_DEVINFO_DATA *a3, const unsigned __int16 *a4, struct CFilterDevice **a5);
void __stdcall MoveProviderToIndex(wchar_t *Str2, void *lpMem); // idb
// _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Chassign(_DWORD, _DWORD, _DWORD); weak
__int32 __stdcall HrRegSetString(HKEY hKey, LPCWSTR lpValueName, int a3);
__int32 __stdcall HrCiCreateShortNameValueIfNeeded(HINF InfHandle, int a2, int a3, int a4);
__int32 __stdcall HrCiGetPrintProviderInfoFromInf(HINF InfHandle, char a2, PCWSTR Section, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
__int32 __stdcall HrCiDeletePrintProviderIfNeeded(HKEY, unsigned __int32 *); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, unsigned int a2, int a3);
__int32 __stdcall HrCiDeleteNetProviderInfo(HKEY, unsigned __int32 *, unsigned __int32 *); // idb
__int32 __stdcall HrCiSetDeviceName(HINF InfHandle, int a2, int a3, int a4);
__int32 __stdcall HrCiAddPrintProvider(int a1, int a2, int a3, void *lpMem);
__int32 __stdcall HrCiWritePrintProviderInfoIfNeeded(HINF InfHandle, int a2, int a3, void *lpMem);
__int32 __stdcall HrCiAddNetProviderInfo(void *, const unsigned __int16 *, HKEY, int); // idb
signed int __stdcall CImplINetCfgBindingInterface::GetUpperComponent(CImplINetCfgBindingInterface *this, struct INetCfgComponent **a2);
signed int __stdcall CImplINetCfgBindingPath::IsSamePathAs(CImplINetCfgBindingPath *this, struct INetCfgBindingPath *a2);
signed int __stdcall CImplINetCfgBindingPath::IsSubPathOf(CImplINetCfgBindingPath *this, struct INetCfgBindingPath *a2);
signed int __stdcall CImplINetCfgBindingPath::GetOwner(CImplINetCfgBindingPath *this, struct INetCfgComponent **a2);
signed int __stdcall CImplINetCfgBindingPath::GetDepth(CImplINetCfgBindingPath *this, unsigned __int32 *a2);
signed int __stdcall CImplINetCfgBindingPath::Enable(CImplINetCfgBindingPath *this, int a2);
signed int __stdcall CImplINetCfgBindingPath::GetPathToken(CImplINetCfgBindingPath *this, unsigned __int16 **a2);
int __stdcall HrCallValidateProperties(HWND a1);
int __stdcall FVerifyCAPAGES(const struct CAPAGES *); // idb
int __stdcall NetCfgPsDlgProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM); // idb
int __stdcall NetCfgPropSheetCallback(HWND hWnd, unsigned int, __int32); // idb
__int32 __stdcall HrNetCfgPropertySheet(LPCPROPSHEETHEADERW, const struct CAPAGES *, const unsigned __int16 *, const struct CAINCP *); // idb
__int32 __stdcall HrLoadAndAddComponentFromInstanceKey(HKEY a1, int a2, int a3, int a4, CNetConfigCore *a5);
int __stdcall FUpgradeFilterDeviceInstanceKey(struct CNetConfig *, HKEY hKey, const unsigned __int16 *); // idb
void __stdcall UpgradeConnection(const struct _GUID *, BYTE *lpData); // idb
__int32 __stdcall HrLoadComponentReferencesFromLegacy(struct CNetConfig *); // idb
__int32 __stdcall HrLoadNetworkConfigurationFromLegacy(struct CNetConfig *); // idb
LONG __cdecl CompareFilterDevices(const void *a1, const void *a2);
const struct CComponent **__thiscall CFilterDevices::PFindFilterDeviceByAdapterAndFilter(CFilterDevices *this, const struct CComponent *a2, const struct CComponent *a3);
struct CFilterDevice *__thiscall CFilterDevices::PFindFilterDeviceByInstanceGuid(CFilterDevices *this, const unsigned __int16 *); // idb
__int32 __thiscall CFilterDevices::HrFindDeviceAndOpenInstanceKey(CFilterDevices *this, const struct CComponent *, const struct CComponent *, struct CFilterDevice **, HKEY *); // idb
__int32 __thiscall CFilterDevices::HrLoadFilterDevice(CFilterDevices *this, struct _SP_DEVINFO_DATA *, HKEY, const unsigned __int16 *, int *); // idb
__int32 __stdcall CFilteredAdapters::HrWriteFilterServiceKey(const struct CComponent *a2, const unsigned __int16 *Src);
int __thiscall CFilteredAdapters::HrAttachOrDetach(CFilteredAdapters *this, struct CFilterMapEntry *a2, unsigned int a3);
int __stdcall HrNdisAttachOrDetach(unsigned int a1, PCWSTR a2, PCWSTR SourceString);
// _UNKNOWN *__usercall sub_6E6745CB@<eax>(int a1@<ebp>);
unsigned int __stdcall HrPnpUnloadDriver(unsigned int a1, PCWSTR SourceString);
__int32 __thiscall CPszArray::HrAddPointer(CPszArray *this, const unsigned __int16 *); // idb
// _UNKNOWN *__usercall sub_6E6747A6@<eax>(int a1@<ebp>);
signed int __thiscall CCounter::HrGrowBuffer(CCounter *this, unsigned int a2);
int __thiscall CCounter::IGetLowestAvailableIndex(CCounter *this);
void __thiscall CCounter::UnsetIndex(CCounter *this, unsigned int); // idb
LONG __stdcall CompareTimeStamps(SYSTEMTIME *lpSystemTime, SYSTEMTIME *a2);
LONG __cdecl CompareMonitoringFilters(const void *a1, const void *a2);
int __cdecl std::fill<CIndex *,CIndex>(int a1, int a2, int a3);
int __cdecl std::_Copy_backward_opt<CIndex *,CIndex *>(int a1, int a2, int a3);
signed int __thiscall CCounter::HrGetNewIndex(CCounter *this, unsigned int *a2);
int __cdecl std::copy_backward<CIndex *,CIndex *>(int a1, int a2, int a3);
// _DWORD __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *__hidden this); idb
int __thiscall std::bad_alloc::~bad_alloc(std::bad_alloc *this);
void *__thiscall std::bad_alloc::`vector deleting destructor'(void *lpMem, char a2);
// _DWORD __thiscall std::bad_alloc::bad_alloc(std::bad_alloc *this, const struct std::bad_alloc *); idb
void __thiscall __noreturn std::bad_alloc::_Doraise(std::bad_alloc *this);
int __thiscall std::out_of_range::~out_of_range(std::out_of_range *this);
void *__thiscall std::out_of_range::`vector deleting destructor'(void *lpMem, char a2);
// _DWORD __thiscall std::out_of_range::out_of_range(std::out_of_range *this, const struct std::out_of_range *); idb
void __thiscall __noreturn std::out_of_range::_Doraise(std::out_of_range *this);
// void __stdcall __FreeStdCallThunk_cmn(void *lpMem); idb
signed int sub_6E674C91();
void __stdcall ATL::__FreeStdCallThunk(void *); // idb
// void *__stdcall __AllocStdCallThunk_cmn(); idb
char __fastcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Inside(int a1, int a2, unsigned int a3);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD); weak
// _DWORD __stdcall std::allocator<char>::allocate(_DWORD); weak
// int __cdecl std::_Traits_helper::copy_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount); idb
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Tidy(char, rsize_t MaxCount); idb
int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Copy(int this, int a2, rsize_t MaxCount);
// void __usercall __noreturn sub_6E675133(int a1@<ebp>);
// _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>(rsize_t MaxCount); weak
int std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::~basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>();
exception *__thiscall std::logic_error::logic_error(exception *this, rsize_t a2);
// _DWORD __stdcall std::length_error::length_error(_DWORD); weak
void __cdecl __noreturn std::_String_base::_Xlen();
void __cdecl __noreturn std::_String_base::_Xran();
// int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::assign(rsize_t MaxCount, void *Src, rsize_t MaxCount); idb
int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::assign(rsize_t this, void *Src);
// int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>(void *Src); idb
// _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD); weak
// void __userpurge _JumpToContinuation(int a1@<ebx>, int a2@<ebp>, void *a3, struct EHRegistrationNode *a4);
void __stdcall _CallMemberFunction0(void *, void *); // idb
void __stdcall _CallMemberFunction1(void *, void *, void *); // idb
void __stdcall _CallMemberFunction2(void *, void *, void *, int); // idb
// void __userpurge _UnwindNestedFrames(int a1@<edi>, int a2@<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
// _DWORD __cdecl __CxxFrameHandler3(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, void *, void *); weak
// int __usercall _CallSETranslator@<eax>(int a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, void *a4, void *a5, const struct _s_FuncInfo *a6, int a7, struct EHRegistrationNode *a8);
// int __usercall sub_6E67572E@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4@<ebx>);
// const struct _s_TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *, int, int, unsigned int *, unsigned int *); idb
int __cdecl _CreateFrameInfo(int a1, int a2);
// _DWORD __cdecl _IsExceptionObjectToBeDestroyed(_DWORD); weak
int __cdecl _FindAndUnlinkFrame(int a1);
// void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *, const struct _s_FuncInfo *, void *, int, unsigned __int32); idb
BOOL __thiscall type_info::operator==(int this, int a2);
void _purecall();
int __cdecl _except_handler4(int, PVOID TargetFrame, int); // idb
// errno_t __cdecl memcpy_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount);
// _DWORD __cdecl _getextendedkeycode(_DWORD); weak
int __cdecl _getch_nolock();
// int __thiscall _kbhit_nolock(_DWORD); weak
int __cdecl _getch();
int __cdecl _kbhit();
// _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD); weak
// _DWORD __thiscall exception::exception(exception *__hidden this); idb
int __thiscall exception::exception(int this, const char **a2);
int __thiscall exception::exception(int this, int a2);
// int exception::~exception(void); weak
void *__thiscall exception::`vector deleting destructor'(void *lpMem, char a2);
// int __cdecl _wcsicmp_l(const wchar_t *Str1, const wchar_t *Str2, _locale_t Locale);
int fprintf(FILE *File, const char *Format, ...);
// int __cdecl _vsnwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, va_list Args);
// errno_t __cdecl _wcslwr_s_l(wchar_t *Str, size_t SizeInWords, _locale_t Locale);
int __cdecl wcstolX(int a1, int a2, int a3, int a4);
unsigned __int32 __cdecl wcstoul(const wchar_t *Str, wchar_t **EndPtr, int Radix);
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
// wchar_t *__cdecl _itow(int Value, wchar_t *Dest, int Radix);
// wchar_t *__cdecl _ultow(unsigned __int32 Value, wchar_t *Dest, int Radix);
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// int __cdecl _wcsnicmp_l(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount, _locale_t Locale);
// void __stdcall __ArrayUnwind(void *, unsigned int, int, void (__thiscall *)(void *)); idb
void __stdcall `eh vector destructor iterator'(void *a1, unsigned int a2, int a3, void (__thiscall *a4)(void *));
void __stdcall `eh vector constructor iterator'(void *a1, unsigned int a2, int a3, int a4, void (__thiscall *a5)(void *));
__int32 __cdecl _wtol(const wchar_t *Str);
int __cdecl _wtoi(const wchar_t *Str);
// int __fastcall swap(_DWORD, _DWORD); weak
// _DWORD __cdecl _get_errno_from_oserr(_DWORD); weak
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// _DWORD __cdecl _amsg_exit(_DWORD); weak
// int __cdecl __crtExitProcess(UINT uExitCode); idb
DWORD __stdcall __crtTlsAlloc(int a1);
// int __cdecl _freeptd(void *Memory); idb
// _DWORD __thiscall std::bad_exception::bad_exception(std::bad_exception *this, const char *); idb
// _DWORD __thiscall std::bad_exception::bad_exception(std::bad_exception *this, const struct std::bad_exception *); idb
int __cdecl __TypeMatch(int a1, int a2, int a3);
int __cdecl __FrameUnwindFilter(int a1);
int __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4);
// _DWORD __cdecl __DestructExceptionObject(_DWORD, char); weak
// char __usercall sub_6E677547@<al>(int a1@<esi>, int a2);
void __noreturn sub_6E6775E1();
void __thiscall __noreturn std::bad_exception::_Doraise(std::bad_exception *this);
void *__cdecl sub_6E677660(int a1, struct EHRegistrationNode *a2, int a3, struct _s_FuncInfo *a4, void *a5, int a6, unsigned __int32 a7);
// void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8); weak
// void __usercall sub_6E677B14(int a1@<ebx>, int a2@<edi>, struct EHExceptionRecord *a3, struct EHRegistrationNode *a4, void *a5, void *a6, struct _s_FuncInfo *a7, int a8, int a9, struct EHRegistrationNode *a10);
// int __usercall sub_6E677C04@<eax>(int a1@<ebx>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a3, void *a4, void *a5, struct _s_FuncInfo *a6, char a7, int a8, PVOID TargetFrame);
// int __cdecl __InternalCxxFrameHandler(PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *, void *, void *, struct _s_FuncInfo *, int, PVOID TargetFrame, char); idb
void __cdecl __noreturn terminate();
void __cdecl __noreturn unexpected();
// void __cdecl _inconsistency(); idb
void __cdecl __report_gsfailure();
void __cdecl sub_6E67820D(int a1, int a2, unsigned int a3);
// void *__cdecl _VEC_memcpy_0(void *Dst, const void *Src, size_t Size);
int __cdecl _cropzeros_l(int, struct localeinfo_struct *); // idb
void __cdecl _invoke_watson(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
void __cdecl _invalid_parameter(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5);
// int __initconin(void); weak
// _DWORD __cdecl V6_HeapAlloc(_DWORD); weak
signed int __cdecl _mtinitlocknum(int a1);
// int __thiscall _updatetlocinfoEx_nolock(_DWORD); weak
int __updatetlocinfo();
void __cdecl _lock_file(FILE *File);
void __cdecl _unlock_file(FILE *File);
int __cdecl _stbuf(FILE *File); // idb
// int __cdecl _ftbuf(int, FILE *File); idb
// int __thiscall write_char(FILE *File); idb
// int __cdecl write_multi_char(char, int, FILE *File); idb
// int __cdecl write_string(_DWORD); weak
int __cdecl _output_l(FILE *File, int, struct localeinfo_struct *, int); // idb
// int __cdecl _fileno(FILE *File);
int __cdecl _flsbuf(int Ch, FILE *File);
// void __usercall sub_6E67A4C8(int a1@<edi>, int a2@<esi>, wchar_t a3);
// void __usercall sub_6E67A507(int a1@<eax>, wchar_t a2, int a3, int a4);
// void __usercall sub_6E67A539(int a1@<eax>, wchar_t *a2@<edx>, int a3@<ecx>, int a4);
int __cdecl _woutput_l(int, int, struct localeinfo_struct *, int); // idb
int __cdecl sub_6E67B203(LCID Locale, DWORD dwMapFlags, wchar_t *Src, size_t MaxCount, LPWSTR lpDestStr, int cchDest, UINT CodePage); // idb
// size_t __cdecl wcsnlen(const wchar_t *Src, size_t MaxCount);
void __cdecl _NMSG_WRITE(int a1);
// int _FF_MSGBANNER(void); weak
int __get_sigabrt();
int __stdcall sub_6E67B911(LPCRITICAL_SECTION lpCriticalSection, int); // idb
// _DWORD __cdecl _callnewh(_DWORD); weak
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// _DWORD __cdecl __sbh_find_block(_DWORD); weak
// _DWORD __cdecl __sbh_free_block(_DWORD, _DWORD); weak
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// int __cdecl _ValidateRead(const void *, unsigned int); idb
// void __cdecl abort();
// int __cdecl _isdigit_l(int C, _locale_t Locale);
int __cdecl isdigit(int C);
int __cdecl _fptostr(void *Dst, int, int, int); // idb
// int __cdecl _putwch_nolock(__int16 Buffer); idb
// int __cdecl _isleadbyte_l(int C, _locale_t Locale);
// int __cdecl isleadbyte(int C);
// errno_t __cdecl strcat_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// errno_t __cdecl strncpy_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
// int __cdecl _isatty(int);
// int __cdecl _get_printf_count_output();
// errno_t __cdecl _wctomb_s_l(int *SizeConverted, char *MbCh, size_t SizeInBytes, wchar_t WCh, _locale_t Locale);
// errno_t __cdecl wctomb_s(int *SizeConverted, char *MbCh, rsize_t SizeInBytes, wchar_t WCh);
int __cdecl wctomb(char *MbCh, wchar_t WCh);
// int __cdecl _lseeki64_nolock(int, int, int, DWORD dwMoveMethod); idb
__int64 __cdecl _lseeki64(int, __int64, int);
int __cdecl _write_nolock(int a1, int a2, DWORD nNumberOfBytesToWrite);
int __cdecl _write(int, const void *, unsigned int);
int __cdecl _getbuf(int a1);
// int __cdecl ferror(FILE *File);
wint_t __cdecl _fputwc_nolock(wchar_t Ch, FILE *File);
// int __cdecl __ansicp(LCID Locale); idb
void *__cdecl __convertcp(UINT CodePage, UINT a2, int a3, int a4, int a5, int a6);
int __cdecl sub_6E67E459(int, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale); // idb
int __cdecl __crtGetStringTypeW(struct localeinfo_struct *, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale); // idb
// int __thiscall write_char_0(FILE *File); idb
// int __cdecl write_multi_char_0(char, int, FILE *File); idb
// int __cdecl write_string_0(_DWORD); weak
int __cdecl _safecrt_cfltcvt(int, char *, size_t Count, int, int Value, char); // idb
int __cdecl _safecrt_wctomb_s(int, void *Dst, size_t Size, wchar_t WCh); // idb
int __cdecl _output_s(FILE *a1, int a2, int a3);
signed int __cdecl _soutput_s(char *a1, int a2, int a3, int a4);
int __cdecl _flsbuf_s(int, FILE *File); // idb
int __cdecl __crtMessageBoxA(int a1, int a2, int a3);
// int __cdecl _set_error_mode(int Mode);
__int32 __cdecl atol(const char *Str);
signed int __cdecl _ld12tod(int a1, int a2);
signed int __cdecl _ld12tof(int a1, int a2);
// _DWORD __cdecl __mtold12(_DWORD, _DWORD, _DWORD); weak
signed int __cdecl __strgtold12_decimal_point(int a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8);
signed int __cdecl __strgtold12_l(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __cdecl _resetstkoflw();
// int __cdecl fclose(FILE *File);
int __cdecl _commit(int);
// int __cdecl strtoxl(struct localeinfo_struct *, int, int, int, int, int); idb
int __cdecl strtolX(int a1, int a2, int a3, int a4);
signed int __cdecl _free_osfhnd(signed int a1);
__int32 __cdecl _get_osfhandle(int);
int __cdecl __lock_fhandle(int Filehandle);
void __cdecl _unlock_fhandle(int Filehandle);
int __cdecl _flswbuf(int, FILE *File); // idb
// int _snprintf(char *Dest, size_t Count, const char *Format, ...);
// char *__cdecl _itoa(int Value, char *Dest, int Radix);
signed int __cdecl _close_nolock(signed int a1);
int __cdecl _close(int);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
signed int __stdcall DwWin32ErrorFromHr(__int32 a1);
signed int __stdcall HrCoTaskMemAlloc(SIZE_T cb, void **a2);
int __stdcall IUnknown::QueryInterface<IUnknown>(int a1, int a2);
__int32 __stdcall HrLoadLibAndGetProcs(LPCWSTR lpLibFileName, unsigned int, const char *const *, HINSTANCE *, int (__stdcall **Dst)()); // idb
__int32 __stdcall HrCreateEventWithWorldAccess(LPCWSTR lpName, BOOL bManualReset, BOOL bInitialState, void *lpMem, void **); // idb
void __stdcall NcSetProxyBlanket(IUnknown *pProxy); // idb
__int32 __stdcall HrCreateInstanceBase(IID *rclsid, DWORD dwClsContext, IID *riid, LPVOID *ppv); // idb
__int32 __stdcall HrQIAndSetProxyBlanketBase(struct IUnknown *, const struct _GUID *, void **); // idb
unsigned int __stdcall CbOfSz(const unsigned __int16 *a1);
unsigned int __stdcall CbOfSzSafe(const unsigned __int16 *a1);
signed int __stdcall FFindStringInCommaSeparatedList(const WCHAR *lpString, const WCHAR *a2, int a3, int a4);
const unsigned __int16 *__stdcall SzLoadStringPcch(HINSTANCE hModule, unsigned int, int *); // idb
int __stdcall FSubStringPresent(LPCWSTR lpString, wchar_t *Str2, wchar_t); // idb
// signed int __userpurge sub_6E68287F@<eax>(unsigned int a1@<ecx>, int a2@<esi>, int a3, unsigned int a4);
signed int __stdcall StringCbCatNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4);
signed int __stdcall HrAddStringToDelimitedSz(wchar_t *Str2, wchar_t *Str, wchar_t a3, unsigned __int32 a4, unsigned __int32 a5, unsigned __int16 **a6);
signed int __stdcall HrRemoveStringFromDelimitedSz(wchar_t *Str2, wchar_t *Str, wchar_t a3, char a4, unsigned __int16 **a5);
int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::erase(int this, int a2, void *lpMem);
int __stdcall DeleteColString(int a1);
__int32 __stdcall HrSetupCommitFileQueue(HWND Owner, HSPFILEQ QueueHandle, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context); // idb
__int32 __stdcall HrSetupInitDefaultQueueCallbackEx(HWND OwnerWindow, HWND AlternateProgressWindow, UINT ProgressMessage, DWORD Reserved1, PVOID Reserved2, void **); // idb
__int32 __stdcall HrSetupOpenFileQueue(void **); // idb
__int32 __stdcall HrSetupOpenInfFile(PCWSTR FileName, PCWSTR InfClass, DWORD InfStyle, PUINT ErrorLine, void **); // idb
__int32 __stdcall HrSetupFindFirstLine(HINF InfHandle, PCWSTR Section, PCWSTR Key, PINFCONTEXT Context); // idb
__int32 __stdcall HrSetupFindNextLine(PINFCONTEXT ContextIn, PINFCONTEXT ContextOut); // idb
__int32 __stdcall HrSetupGetIntField(PINFCONTEXT Context, DWORD FieldIndex, PINT IntegerValue); // idb
__int32 __stdcall HrSetupGetMultiSzField(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, LPDWORD RequiredSize); // idb
__int32 __stdcall HrSetupGetStringField(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, PDWORD RequiredSize); // idb
__int32 __stdcall HrSetupScanFileQueueWithNoCallback(HSPFILEQ FileQueue, DWORD Flags, HWND Window, PDWORD Result); // idb
__int32 __stdcall HrSetupGetFirstDword(HINF InfHandle, PCWSTR Section, PCWSTR Key, unsigned __int32 *IntegerValue); // idb
// void __thiscall CSetupInfFile::Close(CSetupInfFile *__hidden this); idb
void __thiscall CSetupInfFile::EnsureClosed(CSetupInfFile *__hidden this); // idb
__int32 __stdcall HrSetupDiCallClassInstaller(DI_FUNCTION InstallFunction, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupCopyOemInfBuffer(PCWSTR SourceInfFileName, PCWSTR OEMSourceMediaLocation, DWORD OEMSourceMediaType, DWORD CopyStyle, PWSTR DestinationInfFileName, DWORD DestinationInfFileNameSize, PWSTR *DestinationInfFileNameComponent); // idb
__int32 __stdcall HrSetupDiBuildDriverInfoList(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType); // idb
__int32 __stdcall HrSetupDiCreateDeviceInfo(HDEVINFO DeviceInfoSet, PCWSTR DeviceName, GUID *ClassGuid, PCWSTR DeviceDescription, HWND hwndParent, DWORD CreationFlags, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupDiEnumDriverInfo(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType, DWORD MemberIndex, struct _SP_DRVINFO_DATA_V2_W *Dst); // idb
__int32 __stdcall HrSetupDiSelectBestCompatDrv(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupDiGetDeviceInfoListClass(HDEVINFO DeviceInfoSet, LPGUID ClassGuid); // idb
__int32 __stdcall HrSetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PWSTR DeviceInstanceId, DWORD DeviceInstanceIdSize, unsigned __int32 *); // idb
__int32 __stdcall HrSetupDiInstallDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupDiSetClassInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_CLASSINSTALL_HEADER ClassInstallParams, DWORD ClassInstallParamsSize); // idb
__int32 __stdcall HrSetupDiGetFixedSizeClassInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_CLASSINSTALL_HEADER *Dst, size_t Size); // idb
__int32 __stdcall HrSetupDiGetSelectedDriver(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DRVINFO_DATA_V2_W *Dst); // idb
__int32 __stdcall HrSetupDiGetDriverInfoDetail(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, struct _SP_DRVINFO_DETAIL_DATA_W **); // idb
__int32 __stdcall HrSetupDiCreateDevRegKey(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, HINF InfHandle, PCWSTR InfSectionName, HKEY *); // idb
__int32 __stdcall HrSetupDiGetActualSectionToInstallWithBuffer(HINF InfHandle, PCWSTR InfSectionName, DWORD RequiredSize, DWORD InfSectionWithExtSize, unsigned __int32 *, PWSTR *Extension); // idb
__int32 __stdcall HrSetupDiGetDeviceInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DEVINSTALL_PARAMS_W *Dst); // idb
__int32 __stdcall HrSetupDiGetDriverInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams); // idb
__int32 __stdcall HrSetupDiSetDeviceInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DEVINSTALL_PARAMS_W DeviceInstallParams); // idb
__int32 __stdcall HrSetupDiSetDriverInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams); // idb
__int32 __stdcall HrSetupDiSetDeipFlags(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData, int a3, int a4, int a5);
__int32 __stdcall HrSetupDiRemoveDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupDiGetDeviceRegistryProperty(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, PBYTE PropertyBuffer, DWORD PropertyBufferSize, PDWORD RequiredSize); // idb
__int32 __stdcall HrSetupDiSetDeviceRegistryProperty(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, BYTE *PropertyBuffer, DWORD PropertyBufferSize); // idb
__int32 __stdcall HrSetupDiSendPropertyChangeNotification(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, unsigned __int32, unsigned __int32, unsigned __int32); // idb
int __stdcall FSetupDiCheckIfRestartNeeded(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __stdcall HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData); // idb
__int32 __stdcall HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData); // idb
__int32 __stdcall HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA ClassImageListData, GUID *ClassGuid, PINT ImageIndex); // idb
__int32 __stdcall HrSetupDiGetParentWindow(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, HWND *); // idb
__int32 __stdcall HrSetupInstallFilesFromInfSection(HINF InfHandle, HINF LayoutInfHandle, HSPFILEQ FileQueue, PCWSTR SectionName, PCWSTR SourceRootPath, UINT CopyFlags); // idb
__int32 __stdcall HrSetupInstallFromInfSection(HWND Owner, HINF InfHandle, PCWSTR SectionName, UINT Flags, HKEY RelativeKeyRoot, PCWSTR SourceRootPath, UINT CopyFlags, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
void __stdcall SetupCloseInfFileSafe(void *); // idb
signed int __stdcall ULongLongToULong(unsigned __int64 a1, unsigned __int32 *a2);
signed int __stdcall HrSetupGetMultiSzFieldWithAlloc(PINFCONTEXT Context, DWORD FieldIndex, unsigned __int16 **a3);
signed int __stdcall HrSetupGetFirstMultiSzFieldWithAlloc(HINF InfHandle, PCWSTR Section, PCWSTR Key, unsigned __int16 **a4);
__int32 __stdcall HrSetupDiSetDeviceName(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, BYTE *PropertyBuffer); // idb
__int32 __stdcall HrSetupGetStringField(PINFCONTEXT Context, DWORD FieldIndex, int a3);
__int32 __stdcall HrSetupGetStringFieldMapToDword(PINFCONTEXT Context, DWORD FieldIndex, const struct MAP_SZ_DWORD *, unsigned int, unsigned __int32 *); // idb
__int32 __stdcall HrSetupGetStringFieldAsBool(PINFCONTEXT Context, DWORD FieldIndex, int *); // idb
__int32 __stdcall HrSetupGetFirstString(HINF InfHandle, PCWSTR Section, PCWSTR Key, int a4);
__int32 __stdcall HrSetupGetFirstStringAsBool(HINF InfHandle, PCWSTR Section, PCWSTR Key, int *); // idb
__int32 __stdcall HrRegQueryValueWithAlloc(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpType, unsigned __int8 **, unsigned __int32 *); // idb
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, int a2, int a3);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::resize(int this, unsigned int a2, int a3);
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::resize(int this, unsigned int a2);
// __int32 __stdcall HrRegQueryTypeString(HKEY hKey, LPCWSTR lpValueName, DWORD a3, int a4);
// void __usercall sub_6E683E7C(int a1@<ebp>);
// void __userpurge sub_6E683EA0(int a1@<ebp>, int a2, int a3, int a4, int a5);
// _UNKNOWN *__usercall sub_6E683EB9@<eax>(int a1@<ebp>);
__int32 __stdcall HrRegDeleteKey(HKEY hKey, LPCWSTR lpSubKey); // idb
__int32 __stdcall HrRegDeleteValue(HKEY hKey, LPCWSTR lpValueName); // idb
__int32 __stdcall HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName); // idb
__int32 __stdcall HrRegEnumKeyEx(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime); // idb
__int32 __stdcall HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData); // idb
__int32 __stdcall HrRegRestoreKey(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags); // idb
signed int __stdcall HrRegAddStringToMultiSz(wchar_t *Str2, HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, unsigned __int32 a5, unsigned __int32 a6);
signed int __stdcall HrRegAddStringToSz(wchar_t *Str2, HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, wchar_t a5, unsigned __int32 a6, unsigned __int32 a7);
__int32 __stdcall HrRegRemoveStringFromMultiSz(wchar_t *Str2, HKEY lpMem, LPCWSTR lpSubKey, LPCWSTR lpValueName, char); // idb
__int32 __stdcall HrRegDeleteKeyTree(HKEY, LPCWSTR); // idb
__int32 __stdcall HrRegSetBool(HKEY hKey, LPCWSTR lpValueName, BYTE Data); // idb
__int32 __stdcall HrRegSetDword(HKEY hKey, LPCWSTR lpValueName, BYTE Data); // idb
__int32 __thiscall CService::HrSetStartType(CService *this, unsigned __int32); // idb
NTSTATUS __stdcall ScStopNetbios();
HRESULT __stdcall HrRegisterOrUnregisterComObject(const WCHAR *a1, int a2);
__int32 __stdcall HrEnableAndStartSpooler(); // idb
__int32 __stdcall HrEnableAllPrivileges(struct _TOKEN_PRIVILEGES **); // idb
__int32 __stdcall HrRestorePrivileges(PTOKEN_PRIVILEGES NewState); // idb
void __stdcall NCPERM_SETBIT(unsigned __int32, unsigned __int32); // idb
int __stdcall NCPERM_CHECKBIT(unsigned __int32); // idb
signed int __stdcall IsHomenetModuleOSType(int a1);
int __stdcall IsPermittedOnSku(unsigned __int32); // idb
int __stdcall FIsUserLuaAdmin(); // idb
int __stdcall FIsUserService(); // idb
int __stdcall FIsUserLocalService(); // idb
int __stdcall FIsUserLocalSystem(); // idb
int __stdcall FIsUserNetworkService(); // idb
int __stdcall FIsUserPowerUser(); // idb
int __stdcall FIsUserGuest(); // idb
signed int __stdcall NCPERM_USER_TYPE();
void __stdcall RefreshAllPermission(); // idb
int __stdcall FHasPermission(HKEY hKey); // idb
void __stdcall RemoveSzFromMultiSz(wchar_t *Str2, wchar_t *Str1, char, int *); // idb
signed int __stdcall HrAddSzToMultiSz(wchar_t *Str2, wchar_t *Str1, unsigned __int32 a3, unsigned __int32 a4, unsigned __int16 **a5, int *a6);
__int32 __thiscall CService::HrSetDependencies(CService *this, const unsigned __int16 *); // idb
void __stdcall StopDependentServices(SC_HANDLE hService, const unsigned __int16 *, struct CSCTX *); // idb
void __thiscall CService::Close(CService *__hidden this); // idb
// void __thiscall CServiceManager::Close(CServiceManager *__hidden this); idb
__int32 __thiscall CServiceManager::HrOpen(CServiceManager *this, int a2, DWORD dwDesiredAccess, const WCHAR *lpMachineName, const WCHAR *lpDatabaseName);
__int32 __thiscall CServiceManager::HrOpenService(CServiceManager *this, CService *a2, const WCHAR *lpServiceName, int a4, DWORD a5, DWORD dwDesiredAccess);
void __thiscall CServiceManager::Unlock(CServiceManager *__hidden this); // idb
DWORD __stdcall HrQueryServiceConfigWithAlloc(SC_HANDLE hService, struct _QUERY_SERVICE_CONFIGW **a2);
void __stdcall SvcControlServicesAndWait(struct CSCTX *, unsigned int, const unsigned __int16 *const *, unsigned __int64); // idb
__int32 __stdcall HrChangeServiceStartType(const unsigned __int16 *, unsigned __int32); // idb
__int32 __thiscall CServiceManager::HrControlServicesAndWait(CServiceManager *this, unsigned int, const unsigned __int16 *const *, const struct CSFLAGS *, unsigned __int64); // idb
__int32 __thiscall CServiceManager::HrStartServicesAndWait(CServiceManager *this, unsigned int, const unsigned __int16 *const *, unsigned __int32); // idb
__int32 __thiscall CServiceManager::HrAddRemoveServiceDependency(CServiceManager *this, int a2, void *lpMem, int a4);
HRESULT __thiscall CAutoImpersonate::RecoverLostImpersonation(CAutoImpersonate *this);
signed int __stdcall HrFromConfigManagerError(unsigned __int32 a1, __int32 a2);
__int32 __stdcall HrProcessInfExtension(HINF InfHandle, const unsigned __int16 *Src, const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *, __int32 (__stdcall *)(void *, const unsigned __int16 *), __int32 (__stdcall *)(void *, const unsigned __int16 *)); // idb
void __thiscall CDiagContext::SetFlags(CDiagContext *this, unsigned __int32); // idb
int __stdcall SzFromCharacteristics(int a1, int a2);
__int32 __stdcall HrCreateAndInitializeINetCfg(int *, struct INetCfg **, int, unsigned __int32, const unsigned __int16 *, struct IUnknown *); // idb
int __stdcall HrUninitializeAndUnlockINetCfg(struct IUnknown *a1);
signed int __stdcall HrIsLanCapableAdapter(struct IUnknown *a1);
int __stdcall HrUninitializeAndReleaseINetCfg(int a1, struct IUnknown *a2, int a3);
void __thiscall CPropSheetPage::SetChangedFlag(CPropSheetPage *__hidden this); // idb
signed int CPropSheetPage::UCreatePageCallbackHandler();
LONG __thiscall CIsdnPage::~CIsdnPage(CIsdnPage *this);
void __thiscall CAdvanced::DestroyPageCallbackHandler(CAdvanced *__hidden this); // idb
struct _PSP *__thiscall CIsdnPage::CreatePage(CIsdnPage *this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
__int32 __thiscall CIsdnPage::OnApply(CIsdnPage *this, int, struct tagNMHDR *, int *); // idb
signed int __thiscall CIsdnPage::OnContextMenu(CIsdnPage *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5);
void __thiscall CIsdnPage::EnableDisableConfigure(CIsdnPage *__hidden this); // idb
__int32 __thiscall CSpidsDlg::OnInitDialog(CSpidsDlg *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CSpidsDlg::OnSelChange(CSpidsDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
signed int __thiscall CMsnDlg::OnHelp(CMsnDlg *this, unsigned int a2, unsigned int a3, struct tagHELPINFO *a4, int *a5);
__int32 __thiscall CEazDlg::OnInitDialog(CEazDlg *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CJapanDlg::OnOk(CJapanDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CMsnDlg::OnInitDialog(CMsnDlg *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CMsnDlg::OnOk(CMsnDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CMsnDlg::OnSelChange(CMsnDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CJapanDlg::OnInitDialog(CJapanDlg *this, unsigned int, unsigned int, __int32, int *); // idb
int __thiscall ATL::CDialogImpl<CSpidsDlg>::DoModal(void *, HWND hWndParent); // idb
int __thiscall ATL::CDialogImpl<CEazDlg>::DoModal(void *, HWND hWndParent); // idb
int __thiscall ATL::CDialogImpl<CMsnDlg>::DoModal(void *, HWND hWndParent); // idb
int __thiscall ATL::CDialogImpl<CJapanDlg>::DoModal(void *, HWND hWndParent); // idb
int __thiscall CEazDlg::ProcessWindowMessage(CEazDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32); // idb
void __thiscall CEazDlg::~CEazDlg(CEazDlg *this);
CMsnDlg *__thiscall CMsnDlg::CMsnDlg(CMsnDlg *this, struct _ISDNConfigInfo *a2);
int __thiscall CMsnDlg::ProcessWindowMessage(CMsnDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32); // idb
void __thiscall CMsnDlg::~CMsnDlg(CMsnDlg *this);
int __thiscall CJapanDlg::ProcessWindowMessage(CJapanDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32); // idb
void __thiscall CJapanDlg::~CJapanDlg(CJapanDlg *this);
CIsdnPage *__thiscall CIsdnPage::CIsdnPage(CIsdnPage *this);
void *__thiscall CIsdnPage::`scalar deleting destructor'(void *lpMem, char a2);
__int32 __thiscall CIsdnPage::OnInitDialog(CIsdnPage *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CIsdnPage::OnSwitchType(CIsdnPage *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
void __thiscall CIsdnPage::DoJapanDlg(CIsdnPage *__hidden this); // idb
void __thiscall CIsdnPage::DoEazDlg(CIsdnPage *__hidden this); // idb
void __thiscall CIsdnPage::DoMsnDlg(CIsdnPage *__hidden this); // idb
signed int __stdcall HrGetIsdnPage(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _PSP **a3);
int __thiscall CSpidsDlg::ProcessWindowMessage(CSpidsDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32); // idb
void __thiscall CSpidsDlg::~CSpidsDlg(CSpidsDlg *this);
void __thiscall CIsdnPage::DoSpidsDlg(CIsdnPage *__hidden this); // idb
__int32 __thiscall CIsdnPage::OnConfigure(CIsdnPage *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
int __thiscall CIsdnPage::ProcessWindowMessage(CIsdnPage *this, HWND, unsigned int, unsigned int, HWND, CIsdnPage *, unsigned __int32); // idb
int __stdcall FAdapterIsIsdn(HKEY); // idb
__int32 __stdcall HrAddIsdnWizardPagesIfAppropriate(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
__int32 __stdcall HrReadNthDChannelInfo(HKEY hKey, unsigned __int32 Value, DWORD Type);
__int32 __stdcall HrReadDChannelsInfo(HKEY hKey, unsigned __int32 a2, struct _ISDNDChannel **a3);
__int32 __stdcall HrReadIsdnPropertiesInfo(HKEY hKey, void *a2, struct _SP_DEVINFO_DATA *a3, struct _ISDNConfigInfo **a4);
__int32 __stdcall HrWriteIsdnPropertiesInfo(HKEY, struct _ISDNConfigInfo *); // idb
void __stdcall FreeIsdnPropertiesInfo(HLOCAL hMem); // idb
int __thiscall FShowIsdnPages(DWORD this, HKEY hKey);
void __stdcall CheckShowPagesFlag(struct _ISDNConfigInfo *); // idb
void __stdcall SetWizardButtons(HWND hDlg, char, struct _ISDNConfigInfo *); // idb
unsigned __int32 __stdcall DwGetSwitchType(HWND hDlg, struct _ISDNConfigInfo *, int nIDDlgItem); // idb
void __stdcall OnIsdnSwitchTypeWizNext(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall SetSwitchType(HWND hDlg, int nIDDlgItem, unsigned __int32); // idb
signed int __stdcall OnIsdnInfoPageSetActive(HWND hWnd, struct _ISDNConfigInfo *a2);
void __stdcall OnIsdnInfoPageApply(HWND, HKEY hKey); // idb
void __stdcall GetDataFromListBox(WPARAM wParam, HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall SetDataToListBox(int, HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnMsnPageSelChange(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnMsnPageAdd(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnMsnPageRemove(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnMsnPageEditSelChange(HWND hWnd, struct _ISDNConfigInfo *); // idb
void __stdcall SetDataToEditControls(HWND hDlg, int nIDDlgItem, int, struct _ISDNConfigInfo *, LPCWSTR lpString); // idb
void __stdcall GetDataFromEditControls(HWND hDlg, int nIDDlgItem, int, struct _ISDNConfigInfo *, LPWSTR lpString); // idb
void __stdcall SetModifiedIsdnChannelInfo(HWND hDlg, int, int, int nIDDlgItem, WPARAM wParam, struct _ISDNConfigInfo *); // idb
unsigned __int32 __stdcall DwGetCurrentCountryCode(); // idb
char __stdcall FIsDefaultForLocale(unsigned __int32 a1, unsigned __int32 a2);
signed int __stdcall DestroyWizardData(HWND a1, unsigned int a2, struct _PROPSHEETPAGEW *a3);
signed int __stdcall OnIsdnSwitchTypeSetActive(HWND hWnd, struct _ISDNConfigInfo *a2);
void __stdcall PopulateIsdnSwitchTypes(HWND hDlg, int nIDDlgItem, struct _ISDNConfigInfo *); // idb
void __stdcall RetrieveIsdnChannelInfo(HWND hDlg, int, int, int nIDDlgItem, struct _ISDNConfigInfo *, unsigned __int32, WPARAM); // idb
void __stdcall SetCurrentIsdnChannelSelection(HWND hDlg, int, int, int nIDDlgItem, struct _ISDNConfigInfo *, unsigned __int32, int *); // idb
void __stdcall PopulateIsdnChannels(HWND hDlg, int nIDDlgItem, int, int, int, struct _ISDNConfigInfo *); // idb
void __stdcall OnIsdnSwitchTypeInit(HWND hDlg, struct _ISDNConfigInfo *); // idb
int __stdcall IsdnSwitchTypeProc(HWND hWnd, unsigned int, unsigned int, __int32); // idb
void __stdcall OnIsdnInfoPageInit(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnIsdnInfoPageTransition(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnIsdnInfoPageSelChange(HWND hDlg, WPARAM wParam); // idb
void __stdcall OnMsnPageInitDialog(HWND hDlg, struct _ISDNConfigInfo *); // idb
void __stdcall OnIsdnInfoPageWizNext(HWND hWnd, HKEY hKey); // idb
int __stdcall IsdnInfoPageProc(HWND hWnd, unsigned int, unsigned int, __int32); // idb
void __stdcall AddWizardPage(LPCPROPSHEETPAGEW constPropSheetPagePointer, struct _SP_NEWDEVICEWIZARD_DATA *); // idb
void __stdcall FillInIsdnWizardPropertyPage(HINSTANCE, struct _PROPSHEETPAGEW *, __int16, const unsigned __int16 *, int (__stdcall *)(HWND, unsigned int, unsigned int, __int32), const unsigned __int16 *, const unsigned __int16 *, void *); // idb
__int32 __stdcall HrAddIsdnWizardPagesToDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _ISDNConfigInfo *); // idb
int __stdcall FIsComponentId(LPCWSTR lpString1, LPCWSTR lpString2); // idb
int __stdcall CMSClient::ApplyPnpChanges(CMSClient *this, struct INetCfgPnpReconfigCallback *a2);
__int32 __stdcall CMSClient::Install(CMSClient *this, unsigned __int32); // idb
__int32 __stdcall CMSClient::Upgrade(CMSClient *this, char, unsigned __int32); // idb
int __stdcall CMSClient::Removing(CMSClient *this);
signed int __stdcall CMSClient::MergePropPages(CMSClient *this, unsigned __int32 *a2, unsigned __int8 **a3, unsigned int *a4, HWND hWnd, struct _PSP **a6);
__int32 __stdcall CSrvrcfg::CancelChanges(CSrvrcfg *this); // idb
signed int __stdcall CMSClient::SysNotifyComponent(CMSClient *this, char a2, LPCWSTR lpString2);
__int32 CMSClient::HrSetNetLogonDependencies();
__int32 __thiscall CMSClient::HrRestoreRegistry(CMSClient *__hidden this); // idb
__int32 __stdcall CMSClient::ApplyRegistryChanges(CMSClient *this); // idb
__int32 __thiscall CMSClient::HrProcessAnswerFile(CMSClient *this, PCWSTR FileName, const unsigned __int16 *); // idb
__int32 __stdcall CMSClient::ReadAnswerFile(CMSClient *this, PCWSTR FileName, const unsigned __int16 *); // idb
__int32 __thiscall CMSClient::HrSetBrowserRegistryInfo(CMSClient *__hidden this); // idb
void __thiscall CMSClient::SetBrowserDomainList(CMSClient *this, unsigned __int16 *); // idb
CRPCConfigDlg *__thiscall CRPCConfigDlg::CRPCConfigDlg(CRPCConfigDlg *this, struct CMSClient *a2);
int __thiscall CRPCConfigDlg::ProcessWindowMessage(CRPCConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, __int32 *, unsigned __int32); // idb
signed int __thiscall CMSClient::HrSetupPropSheets(CMSClient *this, struct _PSP ***a2, int a3);
void __thiscall CRPCConfigDlg::SetState(CRPCConfigDlg *__hidden this); // idb
signed int __thiscall CRPCConfigDlg::HrValidateRpcData(CRPCConfigDlg *this);
__int32 __thiscall CRPCConfigDlg::OnKillActive(CRPCConfigDlg *this, int, struct tagNMHDR *, int *); // idb
__int32 __thiscall CRPCConfigDlg::OnDestroy(CRPCConfigDlg *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CRPCConfigDlg::OnInitDialog(CRPCConfigDlg *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CRPCConfigDlg::OnOk(CRPCConfigDlg *this, int, struct tagNMHDR *, int *); // idb
CButton *__thiscall CButton::CButton(CButton *this, HWND hDlg, int nIDDlgItem);
LRESULT __thiscall CListBox::AddString(CListBox *this, unsigned __int16 *lParam);
LRESULT __thiscall CListBox::GetItemData(CListBox *this, int wParam);
void __thiscall CListBox::SetItemData(CListBox *this, WPARAM wParam, void *); // idb
int __thiscall CListBox::FindItemData(CListBox *this, int, void *); // idb
void __thiscall CListBox::SetCurSel(CListBox *this, int); // idb
void __thiscall CButton::SetCheck(CButton *this, int); // idb
void __thiscall CComboBox::AdjustMinDroppedWidth(CComboBox *this, unsigned __int16 *); // idb
void *__thiscall CComboBox::CComboBox(void *this, HWND hDlg, int nIDDlgItem);
void __thiscall CComboBox::ResetContent(CComboBox *__hidden this); // idb
LRESULT __thiscall CComboBox::GetItemData(CComboBox *this, int wParam);
void __thiscall CComboBox::SetItemData(CComboBox *this, WPARAM wParam, void *); // idb
LRESULT __thiscall CComboBox::AddString(CComboBox *this, unsigned __int16 *lParam);
void __thiscall CComboBox::SetCurSel(CComboBox *this, int); // idb
void __thiscall CEdit::SetStyle(CEdit *this, __int32); // idb
void __thiscall CEdit::LimitText(CEdit *this, int); // idb
struct _PSP *__thiscall CAdvanced::CreatePage(CAdvanced *this, void *, struct _SP_DEVINFO_DATA *); // idb
__int32 __thiscall CAdvanced::OnDestroy(CAdvanced *this, unsigned int, unsigned int, __int32, int *); // idb
LONG __thiscall CAdvanced::~CAdvanced(CAdvanced *this);
void __thiscall CAdvanced::Apply(CAdvanced *__hidden this); // idb
int __thiscall CAdvanced::EnumvalToItem(CAdvanced *this, unsigned __int16 *const ); // idb
void __thiscall CAdvanced::BeginEdit(CAdvanced *__hidden this); // idb
int __thiscall CAdvanced::CAdvanced(int this);
void *__thiscall CAdvanced::`scalar deleting destructor'(void *lpMem, char a2);
__int32 __thiscall CAdvanced::OnEdit(CAdvanced *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CAdvanced::OnDrop(CAdvanced *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
void __thiscall CAdvanced::SetParamRange(CAdvanced *__hidden this); // idb
void __thiscall CAdvanced::UpdateParamDisplay(CAdvanced *this); // idb
int __thiscall CAdvanced::ItemToEnumval(CAdvanced *this, int, LPCWSTR lpString, unsigned int); // idb
signed int __stdcall HrGetAdvancedPage(void *a1, struct _SP_DEVINFO_DATA *a2, struct _PSP **a3);
void __thiscall CAdvanced::UpdateDisplay(CAdvanced *this); // idb
void __thiscall CAdvanced::SelectParam(CAdvanced *this); // idb
void __thiscall CAdvanced::GetParamValue(CAdvanced *this); // idb
__int32 __thiscall CAdvanced::OnPresent(CAdvanced *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
void __thiscall CAdvanced::FillParamListbox(CAdvanced *__hidden this); // idb
int __thiscall CAdvanced::FValidateCurrParam(CAdvanced *__hidden this); // idb
__int32 __thiscall CAdvanced::OnInitDialog(CAdvanced *this, unsigned int, unsigned int, __int32, int *); // idb
__int32 __thiscall CAdvanced::OnApply(CAdvanced *this, int, struct tagNMHDR *, int *); // idb
__int32 __thiscall CAdvanced::OnKillActive(CAdvanced *this, int, struct tagNMHDR *, int *); // idb
signed int __thiscall CAdvanced::OnList(CAdvanced *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5);
int __thiscall CAdvanced::ProcessWindowMessage(CAdvanced *this, HWND, unsigned int, unsigned int, HWND, CAdvanced *, unsigned __int32); // idb
void __stdcall UpdateAdvancedParametersIfNeeded(void *, struct _SP_DEVINFO_DATA *); // idb
void *__thiscall CParam::`scalar deleting destructor'(void *lpMem, char a2);
int __thiscall CAdvancedParams::FSetParamValue(CAdvancedParams *this, LPCWSTR lpString1, const unsigned __int16 *const ); // idb
int __thiscall CAdvancedParams::FValidateSingleParam(CAdvancedParams *this, struct CParam *, int, HWND); // idb
int __thiscall CAdvancedParams::FSave(CAdvancedParams *__hidden this); // idb
int __thiscall CAdvancedParams::~CAdvancedParams(CAdvancedParams *this);
int __thiscall CAdvancedParams::CAdvancedParams(int this);
void __thiscall CAdvancedParams::FillParamList(CAdvancedParams *this, HKEY, HKEY); // idb
__int32 __thiscall CAdvancedParams::HrInit(CAdvancedParams *this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData); // idb
// int __thiscall CValue::CValue(_DWORD); weak
void __thiscall CValue::Destroy(CValue *__hidden this); // idb
void __thiscall CValue::SetNumericValue(CValue *this, unsigned __int32); // idb
int __thiscall CValue::Compare(CValue *this, struct CValue *); // idb
unsigned __int32 __thiscall CValue::GetNumericValueAsDword(CValue *__hidden this); // idb
void __thiscall CValue::Copy(CValue *this, struct CValue *); // idb
int __thiscall CValue::FromString(CValue *this, const unsigned __int16 *const ); // idb
int __thiscall CValue::ToString(CValue *this, wchar_t *Dst, unsigned int); // idb
int __thiscall CValue::FLoadFromRegistry(CValue *this, HKEY hKey, LPCWSTR lpValueName, HKEY); // idb
int __thiscall CValue::FSaveToRegistry(CValue *this, HKEY hKey, LPCWSTR lpValueName); // idb
int __thiscall CValue::Init(int this, int a2, int a3);
int __thiscall CValue::InitNotPresent(int this, int a2);
CParam *__thiscall CParam::CParam(CParam *this);
void __thiscall CParam::InitParamType(CParam *this, unsigned __int16 *); // idb
int __thiscall CParam::~CParam(CParam *this);
int __thiscall CParam::Apply(CParam *this); // idb
signed int __thiscall CParam::Validate(CParam *this);
int __thiscall CParam::FInit(CParam *this, HKEY, HKEY, LPCWSTR lpString); // idb
void __thiscall CParam::GetDescription(CParam *this, unsigned __int16 *, unsigned int); // idb
void __stdcall StripSpaces(unsigned __int16 *Dst); // idb
unsigned int __stdcall Reg_QueryInt(HKEY hKey, LPCWSTR lpValueName, unsigned int); // idb
__int32 __stdcall CSrvrcfg::Install(CSrvrcfg *this, unsigned __int32); // idb
signed int __stdcall CSrvrcfg::Upgrade(CSrvrcfg *this, unsigned __int32 a2, unsigned __int32 a3);
signed int __stdcall CSrvrcfg::MergePropPages(CSrvrcfg *this, unsigned __int32 *a2, unsigned __int8 **a3, unsigned int *a4, HWND hWnd, const unsigned __int16 **a6);
__int32 __thiscall CSrvrcfg::HrRestoreRegistry(CSrvrcfg *__hidden this); // idb
__int32 __stdcall CSrvrcfg::ApplyRegistryChanges(CSrvrcfg *this); // idb
__int32 __thiscall CSrvrcfg::HrProcessAnswerFile(CSrvrcfg *this, PCWSTR FileName, const unsigned __int16 *); // idb
__int32 __stdcall CSrvrcfg::ReadAnswerFile(CSrvrcfg *this, PCWSTR FileName, const unsigned __int16 *); // idb
__int32 __thiscall CSrvrcfg::HrSetRegistryInfo(CSrvrcfg *__hidden this); // idb
int __thiscall CServerConfigDlg::ProcessWindowMessage(CServerConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CPropSheetPage *, unsigned __int32); // idb
void *__thiscall CServerConfigDlg::`vector deleting destructor'(void *lpMem, char a2);
signed int __thiscall CSrvrcfg::HrSetupPropSheets(CSrvrcfg *this, struct _PSP ***a2, int a3);
signed int __thiscall CServerConfigDlg::OnInitDialog(CServerConfigDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5);
__int32 __thiscall CServerConfigDlg::OnOk(CServerConfigDlg *this, int, struct tagNMHDR *, int *); // idb
signed int __stdcall HrGetINetCfg(HWND hWnd, struct INetCfg **pv, struct INetCfgLock **a3);
CBindingsDlg *__thiscall CBindingsDlg::CBindingsDlg(CBindingsDlg *this, struct INetCfg *a2);
int __thiscall CBindingsDlg::ProcessWindowMessage(CBindingsDlg *this, HWND, unsigned __int32, CSrvrcfg *, HWND, CBindingsDlg *, unsigned __int32); // idb
void *__thiscall CBindingsDlg::`vector deleting destructor'(void *lpMem, char a2);
signed int __stdcall HrDoAdvCfgDlg(HWND hWnd);
__int32 __thiscall CProviderOrderDlg::MoveItem(CProviderOrderDlg *this, bool); // idb
__int32 __thiscall CProviderOrderDlg::UpdateUpDownButtons(CProviderOrderDlg *this, HWND); // idb
// LRESULT __userpurge sub_6E68D485@<eax>(int a1@<eax>, LPARAM a2@<ecx>, HWND hWnd, int a4, int a5);
__int32 __thiscall CProviderOrderDlg::OnTreeItemChanged(CProviderOrderDlg *this, int, struct tagNMHDR *, int *); // idb
LONG __thiscall CProviderOrderDlg::~CProviderOrderDlg(CProviderOrderDlg *this);
void __stdcall sub_6E68D574(HWND hWnd, int a2, char a3, int a4, int a5, char a6, int a7, int a8, int a9);
int __thiscall CProviderOrderDlg::CProviderOrderDlg(int this);
void *__thiscall CProviderOrderDlg::`vector deleting destructor'(void *lpMem, char a2);
signed int __stdcall HrGetNetworkProviderName(HKEY hKey, int a2);
int __thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(void *this, int a2, int a3, int a4, int a5);
void __stdcall ConvertColStringToString(int a1, int a2, int a3);
int __thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(void *this, int a2, int a3, int a4);
void __stdcall ConvertStringToColString(unsigned __int16 *a1, wchar_t a2, int a3);
__int32 __thiscall CProviderOrderDlg::WriteProviders(CProviderOrderDlg *this, HWND); // idb
signed int __thiscall sub_6E68DA85(void *this, int a2);
bool __stdcall AreThereMultipleProviders(); // idb
void *__thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>(void *this, int a2);
// void __usercall __noreturn sub_6E68DD47(int a1@<ebp>);
signed int __thiscall CProviderOrderDlg::OnInitDialog(CProviderOrderDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5);
__int32 __thiscall CProviderOrderDlg::OnOk(CProviderOrderDlg *this, int, struct tagNMHDR *, int *); // idb
int __thiscall CProviderOrderDlg::ProcessWindowMessage(CProviderOrderDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CProviderOrderDlg *, unsigned __int32); // idb
__int32 __thiscall CBindingsDlg::OnTreeItemChanged(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
LPARAM __thiscall CBindingsDlg::HtiIsSubItem(CBindingsDlg *this, struct INetCfgComponent *a2, struct _TREEITEM *a3);
void __stdcall ChangeTreeItemParam(HWND hWnd, struct _TREEITEM *, __int32); // idb
struct _TREEITEM *__thiscall CBindingsDlg::HtiMoveTreeItemAfter(CBindingsDlg *this, struct _TREEITEM *, struct _TREEITEM *, struct _TREEITEM *); // idb
void __thiscall CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch(int this);
int __thiscall CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext(int this, int a2);
void __thiscall CIterNetCfgComponent::~CIterNetCfgComponent(CIterNetCfgComponent *this);
CIterNetCfgBindingPath *__thiscall CIterNetCfgBindingPath::CIterNetCfgBindingPath(CIterNetCfgBindingPath *this, struct INetCfgComponent *a2);
CIterNetCfgUpperBindingPath *__thiscall CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath(CIterNetCfgUpperBindingPath *this, struct INetCfgComponent *a2);
CIterNetCfgBindingInterface *__thiscall CIterNetCfgBindingInterface::CIterNetCfgBindingInterface(CIterNetCfgBindingInterface *this, struct INetCfgBindingPath *a2);
int __stdcall CBindingsDlg::HrComponentIsHidden(struct IUnknown *a2, unsigned __int32 a3);
void __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::clear(int this);
int __stdcall std::find<std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::iterator,BIND_PATH_INFO *>(int a1, int a2, int a3, int a4);
void __thiscall CBindingsDlg::OnBindingUpDown(CBindingsDlg *this, int); // idb
__int32 __thiscall CBindingsDlg::OnBindingUp(CBindingsDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CBindingsDlg::OnBindingDown(CBindingsDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
int __stdcall BpiFindBindPathInList(int a1, int a2);
int __thiscall CBindingsDlg::HrOrderSubItems(CBindingsDlg *this);
void __thiscall std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy(int this);
int __stdcall FreeBindPathInfoList(int a1);
void __thiscall TREE_ITEM_DATA::~TREE_ITEM_DATA(TREE_ITEM_DATA *this);
void __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::~list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>(void *); // idb
int __thiscall std::list<HTREEITEMP,std::nc_allocator<HTREEITEMP>>::pop_front(int this);
void *__thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>(void *this);
void __thiscall CIterTreeView::EraseAndDeleteAll(CIterTreeView *__hidden this); // idb
void *__thiscall TREE_ITEM_DATA::`scalar deleting destructor'(void *lpMem, char a2);
void __thiscall CIterTreeView::~CIterTreeView(CIterTreeView *this);
int __thiscall TREE_ITEM_DATA::TREE_ITEM_DATA(int this);
__int32 __stdcall CBindingsDlg::OnTreeDeleteItem(int a2, struct tagNMHDR *a3, int *a4);
LRESULT __thiscall CBindingsDlg::HtiAddTreeViewItem(CBindingsDlg *this, struct IUnknown *a2, struct _TREEITEM *a3);
void __thiscall CIterTreeView::Reset(CIterTreeView *__hidden this); // idb
void __thiscall CIterTreeView::PushAndAlloc(CIterTreeView *this, struct _TREEITEM *); // idb
void __stdcall AddToListIfNotAlreadyAdded(int a1, void *lpMem);
void __thiscall CBindingsDlg::AssociateBinding(CBindingsDlg *this, struct IUnknown *, LPARAM, unsigned __int32); // idb
__int32 __thiscall CBindingsDlg::HrHandleValidSubItem(CBindingsDlg *this, struct IUnknown *, struct IUnknown *, struct IUnknown *, struct _TREEITEM *, struct TREE_ITEM_DATA *); // idb
LPARAM __thiscall CIterTreeView::HtiNext(CIterTreeView *this);
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(int this, int a2, int a3, int a4, int a5, unsigned int a6, int a7);
CIterTreeView *__thiscall CIterTreeView::CIterTreeView(int this, int a2);
void __thiscall CBindingsDlg::SetCheckboxStates(CBindingsDlg *__hidden this); // idb
int __thiscall CBindingsDlg::HrHandleSubItem(CBindingsDlg *this, struct IUnknown *a2, struct IUnknown *a3, struct TREE_ITEM_DATA *a4, struct _TREEITEM *a5);
int __thiscall CBindingsDlg::HrHandleTopLevel(CBindingsDlg *this, struct INetCfgBindingPath *a2);
int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::splice(int this, int a2, int a3, int a4);
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::splice(int this, int a2, int a3);
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::merge(int this, int a2);
void __thiscall CBindingsDlg::ToggleCheckbox(CBindingsDlg *this, struct _TREEITEM *); // idb
__int32 __thiscall CBindingsDlg::OnClickOrDoubleClick(CBindingsDlg *this, int, struct tagNMHDR *, int); // idb
int __stdcall CBindingsDlg::HrOrderDisableList(struct TREE_ITEM_DATA *a2);
int __thiscall CBindingsDlg::HrOrderDisableLists(CBindingsDlg *this);
int __thiscall CBindingsDlg::HrHandleSubpath(CBindingsDlg *this, int a2, struct IUnknown *a3);
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::swap(int this, int a2);
signed int __thiscall CBindingsDlg::OnTreeKeyDown(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4);
__int32 __thiscall CBindingsDlg::OnClick(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
__int32 __thiscall CBindingsDlg::OnDoubleClick(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
void __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::sort(int this);
void __thiscall CBindingsDlg::BuildBindingsList(CBindingsDlg *this, struct INetCfgComponent *); // idb
void __thiscall CBindingsDlg::GetWanOrdering(CBindingsDlg *__hidden this); // idb
void __thiscall CBindingsDlg::SetWanOrdering(CBindingsDlg *__hidden this); // idb
void __thiscall CBindingsDlg::AddListViewItem(CBindingsDlg *this, struct IUnknown *, int, int, const unsigned __int16 *); // idb
__int32 __thiscall CBindingsDlg::OnListDeleteItem(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
int __thiscall CBindingsDlg::FIsWanBinding(CBindingsDlg *this, int); // idb
void __thiscall CBindingsDlg::SetAdapterButtons(CBindingsDlg *this); // idb
void __stdcall ChangeListItemParam(HWND hWnd, int, __int32); // idb
void *__stdcall std::_Allocate<std::_List_nod<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Node>(int a1, int a2);
int __thiscall CIterNetCon::HrNext(CIterNetCon *this, struct INetConnection **a2);
int __thiscall CIterNetCfgComponent::CIterNetCfgComponent(int this, struct IUnknown *a2, int a3);
CIterNetCon *__thiscall CIterNetCon::CIterNetCon(CIterNetCon *this, struct INetConnectionManager *a2, enum tagNETCONMGR_ENUM_FLAGS a3);
void __thiscall CBindingsDlg::OnAdapterChange(CBindingsDlg *this, int); // idb
void *std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
void *__stdcall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Buynode(int a1, int a2, int a3);
__int32 __thiscall CBindingsDlg::OnListItemChanged(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
int __thiscall std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(int this, int a2, void *lpMem, int a4);
void __thiscall std::list<INetCfgComponent *,std::nc_allocator<INetCfgComponent *>>::unique(int this);
unsigned int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::_Incsize(int this, unsigned int a2);
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(void *this, int a2, int a3);
int __stdcall CBindingsDlg::HrGetAdapters(struct IUnknown *, struct IUnknown *); // idb
int __thiscall CBindingsDlg::HrBuildAdapterList(CBindingsDlg *this);
void __thiscall CBindingsDlg::MoveAdapterBindings(void *this, struct IUnknown *a2, struct IUnknown *a3, int a4);
void __thiscall CBindingsDlg::OnAdapterUpDown(CBindingsDlg *this, int); // idb
__int32 __thiscall CBindingsDlg::OnAdapterUp(CBindingsDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
__int32 __thiscall CBindingsDlg::OnAdapterDown(CBindingsDlg *this, unsigned __int16, unsigned __int16, HWND, int *); // idb
LONG __thiscall CBindingsDlg::~CBindingsDlg(CBindingsDlg *this);
signed int __thiscall CBindingsDlg::OnInitDialog(CBindingsDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5);
__int32 __thiscall CBindingsDlg::OnOk(CBindingsDlg *this, int, struct tagNMHDR *, int *); // idb
BOOL __thiscall CSortableBindPath::operator<(void *this, int a2);
int __stdcall FIsHidden(struct INetCfgComponent *); // idb
struct _IMAGELIST *__stdcall ImageList_LoadImageAndMirror(HINSTANCE hInst, LPCWSTR name, int, int cGrow, COLORREF crMask, UINT type, UINT fuLoad); // idb
int __fastcall load__SetupCloseInfFile_4(int a1, int a2);
int __fastcall load__SetupDiGetDeviceInstanceIdW_20(int a1, int a2);
int __fastcall load__SetupDiRestartDevices_8(int a1, int a2);
int __fastcall load__SetupDiGetDeviceInstallParamsW_12(int a1, int a2);
int __fastcall load__SetupDiDeleteDeviceInfo_8(int a1, int a2);
int __fastcall load__pSetupGetIndirectStringsFromDriverInfo_28(int a1, int a2);
// int __stdcall pSetupGetIndirectStringsFromDriverInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __fastcall load__SetupCloseFileQueue_4(int a1, int a2);
int __fastcall load__SetupTermDefaultQueueCallback_4(int a1, int a2);
int __fastcall load__SetupDefaultQueueCallbackW_16(int a1, int a2);
int __fastcall load__SetupOpenAppendInfFileW_12(int a1, int a2);
int __fastcall load__SetupInstallServicesFromInfSectionW_12(int a1, int a2);
int __fastcall load__SetupDiDestroyDriverInfoList_12(int a1, int a2);
int __fastcall load__SetupCommitFileQueueW_16(int a1, int a2);
int __fastcall load__SetupInitDefaultQueueCallbackEx_20(int a1, int a2);
int __fastcall load__SetupOpenFileQueue_0(int a1, int a2);
int __fastcall load__SetupOpenInfFileW_16(int a1, int a2);
int __fastcall load__SetupFindFirstLineW_16(int a1, int a2);
int __fastcall load__SetupFindNextLine_8(int a1, int a2);
int __fastcall load__SetupGetIntField_12(int a1, int a2);
int __fastcall load__SetupGetMultiSzFieldW_20(int a1, int a2);
int __fastcall load__SetupGetStringFieldW_20(int a1, int a2);
int __fastcall load__SetupScanFileQueueW_24(int a1, int a2);
int __fastcall load__SetupDiCallClassInstaller_12(int a1, int a2);
int __fastcall load__SetupCopyOEMInfW_32(int a1, int a2);
int __fastcall load__SetupDiBuildDriverInfoList_12(int a1, int a2);
int __fastcall load__SetupDiCreateDeviceInfoW_28(int a1, int a2);
int __fastcall load__SetupDiEnumDriverInfoW_20(int a1, int a2);
int __fastcall load__SetupDiSelectBestCompatDrv_8(int a1, int a2);
int __fastcall load__SetupDiGetDeviceInfoListClass_8(int a1, int a2);
int __fastcall load__SetupDiInstallDevice_8(int a1, int a2);
int __fastcall load__SetupDiSetClassInstallParamsW_16(int a1, int a2);
int __fastcall load__SetupDiGetClassInstallParamsW_20(int a1, int a2);
int __fastcall load__SetupDiGetSelectedDriverW_12(int a1, int a2);
int __fastcall load__SetupDiGetDriverInfoDetailW_24(int a1, int a2);
int __fastcall load__SetupDiCreateDevRegKeyW_28(int a1, int a2);
int __fastcall load__SetupDiGetActualSectionToInstallW_24(int a1, int a2);
int __fastcall load__SetupDiGetDriverInstallParamsW_16(int a1, int a2);
int __fastcall load__SetupDiSetDeviceInstallParamsW_12(int a1, int a2);
int __fastcall load__SetupDiSetDriverInstallParamsW_16(int a1, int a2);
int __fastcall load__SetupDiRemoveDevice_8(int a1, int a2);
int __fastcall load__SetupDiSetDeviceRegistryPropertyW_20(int a1, int a2);
int __fastcall load__SetupDiGetClassImageList_4(int a1, int a2);
int __fastcall load__SetupDiDestroyClassImageList_4(int a1, int a2);
int __fastcall load__SetupDiGetClassImageIndex_12(int a1, int a2);
int __fastcall load__SetupInstallFilesFromInfSectionW_24(int a1, int a2);
int __fastcall load__SetupInstallFromInfSectionW_44(int a1, int a2);
// DWORD __stdcall GetLastError();
// int __stdcall DelayLoadFailureHook(_DWORD, _DWORD); weak
// NTSTATUS __stdcall LsaClose(LSA_HANDLE ObjectHandle);
// NTSTATUS __stdcall LsaFreeMemory(PVOID Buffer);
// NTSTATUS __stdcall LsaQueryInformationPolicy(LSA_HANDLE PolicyHandle, POLICY_INFORMATION_CLASS InformationClass, PVOID *Buffer);
// NTSTATUS __stdcall LsaOpenPolicy(PLSA_UNICODE_STRING SystemName, PLSA_OBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, PLSA_HANDLE PolicyHandle);
int __fastcall load__DestroyPropertySheetPage_4(int a1, int a2);
// int __usercall _tailMerge_COMCTL32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
int __fastcall load__PropertySheetW_4(int a1, int a2);
int __fastcall load__CreatePropertySheetPageW_4(int a1, int a2);
int __fastcall load__ImageList_Duplicate_4(int a1, int a2);
int __fastcall load__ImageList_Destroy_4(int a1, int a2);
int __fastcall load__ImageList_ReplaceIcon_12(int a1, int a2);
int __fastcall load__ImageList_AddMasked_12(int a1, int a2);
int __fastcall load__ImageList_Add_12(int a1, int a2);
int __fastcall load__ImageList_Create_20(int a1, int a2);
int __fastcall load__RasEnumConnectionsW_12(int a1, int a2);
// int __usercall _tailMerge_RASAPI32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// DWORD __stdcall RasEnumConnectionsW(struct tagRASCONNW *, LPDWORD, LPDWORD);
int __fastcall load__AddPrintProvidorW_12(int a1, int a2);
// int __usercall _tailMerge_WINSPOOL_DRV@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// BOOL __stdcall AddPrintProvidorW(LPWSTR pName, DWORD level, LPBYTE pProvidorInfo);
int __fastcall load__DeletePrintProvidorW_12(int a1, int a2);
// BOOL __stdcall DeletePrintProvidorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pPrintProvidorName);
int __fastcall load__WSCUnInstallNameSpace_4(int a1, int a2);
// int __usercall _tailMerge_WS2_32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>);
// INT __stdcall WSCUnInstallNameSpace(LPGUID lpProviderId);
int __fastcall load__WSCInstallNameSpace_20(int a1, int a2);
// INT __stdcall WSCInstallNameSpace(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId);
// HRESULT __stdcall SLGetWindowsInformationDWORD(PCWSTR pwszValueName, DWORD *pdwValue);
// int __stdcall NsiGetParameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NsiSetParameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// DWORD __stdcall ConvertInterfaceGuidToLuid(const GUID *InterfaceGuid, PNET_LUID InterfaceLuid);
int __cdecl _vsnprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, va_list ArgList);
LONG __thiscall CPropSheetPage::~CPropSheetPage(CPropSheetPage *this);
signed int __stdcall CPropSheetPage::DialogProc(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4);
int __stdcall CPropSheetPage::PropSheetPageProc(HWND a1, unsigned int a2, struct _PROPSHEETPAGEW *a3);
struct _PSP *__thiscall CPropSheetPage::CreatePage(CPropSheetPage *this, __int16, unsigned __int32, const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *, HINSTANCE); // idb
__int32 __stdcall HrNcQueryUserForRebootEx(HWND hWnd, LPCWSTR lpCaption, LPCWSTR lpText, void *lpMem); // idb
__int32 __stdcall HrNcQueryUserForReboot(HINSTANCE hModule, HWND hWnd, unsigned int, unsigned int, void *lpMem); // idb
__int32 __stdcall LresFromHr(__int32); // idb
int NcMsgBox(HINSTANCE hModule, HWND hWnd, unsigned int, unsigned int, UINT uType, ...); // idb
void __stdcall SetDefaultButton(HWND hWnd, WPARAM wParam); // idb
unsigned __int32 __stdcall DwContextIdFromIdc(const struct CONTEXTIDMAP *, int, int); // idb
void __stdcall OnHelpGeneric(HWND hWndMain, struct tagHELPINFO *, const struct CONTEXTIDMAP *, int, LPCWSTR lpszHelp); // idb
int NcMsgBox(HWND hWnd, unsigned int, unsigned int, UINT uType, ...); // idb
int __stdcall FBadArgs_INetCfgProperties_MergePropPages(unsigned __int32 *, unsigned __int8 **, unsigned int *, HWND hWnd, const unsigned __int16 **); // idb
int __stdcall HrFindAndRemoveComponent(struct IUnknown *a1, const struct _GUID *a2, struct IUnknown *a3, struct tagOBO_TOKEN *a4);
__int32 __stdcall HrInstallComponent(struct INetCfg *, const struct NETWORK_INSTALL_PARAMS *, const struct _GUID *, const unsigned __int16 *, struct tagOBO_TOKEN *, struct IUnknown *); // idb
__int32 __stdcall HrInstallComponentOboComponent(struct INetCfg *, const struct NETWORK_INSTALL_PARAMS *, const struct _GUID *, const unsigned __int16 *, struct INetCfgComponent *, struct IUnknown *); // idb
int __stdcall HrRemoveComponentOboComponent(struct IUnknown *a1, const struct _GUID *a2, struct IUnknown *a3, struct INetCfgComponent *a4);
int __stdcall HrGetLastComponentAndInterface(struct INetCfgBindingPath *a1, struct INetCfgComponent **a2, struct IUnknown *a3);
void __stdcall FreeNetconProperties(struct tagNETCON_PROPERTIES *pv); // idb
// int __stdcall HrQIAndSetProxyBlanket<INetLanConnection>(struct IUnknown *, void **); idb
__int32 __stdcall HrOpenConnectionKey(GUID *rguid, OLECHAR *a2, REGSAM samDesired, char a4, BYTE *a5, PHKEY phkResult);
__int32 __stdcall HrIsConnection(struct INetCfgComponent *); // idb
int __stdcall HrGetDeviceGuid(struct INetConnection *a1, struct _GUID *a2);
int __stdcall FPconnEqualGuid(struct INetConnection *, const struct _GUID *); // idb
// _DWORD __thiscall CIntelliName::CIntelliName(CIntelliName *this, HINSTANCE, int (__stdcall *)(const struct CIntelliName *, const unsigned __int16 *, enum tagNETCON_MEDIATYPE *, enum tagNETCON_SUBMEDIATYPE *)); idb
void *__stdcall OpenDevice(HANDLE FileHandle); // idb
__int32 __stdcall HrQueryDeviceOIDByName(PCWSTR SourceString, DWORD dwIoControlCode, char InBuffer, DWORD BytesReturned, void *Dst); // idb
__int32 __stdcall HrQueryNDISAdapterOID(GUID *rguid, char InBuffer, DWORD BytesReturned, void *Dst); // idb
__int32 __stdcall CIntelliName::HrGetPseudoMediaTypes(const struct _GUID *a2, enum tagNETCON_MEDIATYPE *a3, enum tagNETCON_SUBMEDIATYPE *a4);
// void __cdecl sub_6E6920E9(int a1, int a2);
// void __cdecl sub_6E692114(int a1, int a2);
// void __cdecl sub_6E69213E(int a1, int a2);
// void __cdecl sub_6E692169(int a1, int a2);
// void __cdecl sub_6E6921B7(int a1, int a2);
// void __cdecl sub_6E6921FA(int a1, int a2);
// void __cdecl sub_6E692227(int a1, int a2);
// void __cdecl sub_6E692251(int a1, int a2);
// void __cdecl sub_6E69227E(int a1, int a2);
// void __cdecl sub_6E6922B1(int a1, int a2);
// void __cdecl sub_6E692318(int a1, int a2);
// void __cdecl sub_6E69237C(int a1, int a2);
// void __cdecl sub_6E6923DD(int a1, int a2);
// void __cdecl sub_6E692498(int a1, int a2);
// void __cdecl sub_6E692511(int a1, int a2);
// void __cdecl sub_6E692568(int a1, int a2);
// void __cdecl sub_6E6925C0(int a1, int a2);
// void __cdecl sub_6E69261C(int a1, int a2);
// void __cdecl sub_6E69267B(int a1, int a2);
// void __cdecl sub_6E6926D4(int a1, int a2);
// void __cdecl sub_6E692725(int a1, int a2);
// void __cdecl sub_6E69277C(int a1, int a2);
// void __cdecl sub_6E6927E0(int a1, int a2);
// void __cdecl sub_6E692844(int a1, int a2);
// void __cdecl sub_6E692895(int a1, int a2);
// void __cdecl sub_6E6928D9(int a1, int a2);
// void __cdecl sub_6E69291D(int a1, int a2);
// void __cdecl sub_6E6929B8(int a1, int a2);
// void __cdecl sub_6E692A09(int a1, int a2);
// void __cdecl sub_6E692A60(int a1, int a2);
// void __cdecl sub_6E692AA5(int a1, int a2);
// void __cdecl sub_6E692B80(int a1, int a2);
// void __cdecl sub_6E692C2D(int a1, int a2);
// void __cdecl sub_6E692C71(int a1, int a2);
// void __cdecl sub_6E692CB5(int a1, int a2);
// void __cdecl sub_6E692CF9(int a1, int a2);
// void __cdecl sub_6E692D3D(int a1, int a2);
// void __cdecl sub_6E692D81(int a1, int a2);
// void __cdecl sub_6E692DC5(int a1, int a2);
// void __cdecl sub_6E692E1F(int a1, int a2);
// void __cdecl sub_6E692E8F(int a1, int a2);
// void __cdecl sub_6E692EE8(int a1, int a2);
// void __cdecl sub_6E692F40(int a1, int a2);
// void __cdecl sub_6E692FDD(int a1, int a2);
// void __cdecl sub_6E693034(int a1, int a2);
// void __cdecl sub_6E693079(int a1, int a2);
// void __cdecl sub_6E6930D4(int a1, int a2);
// void __cdecl sub_6E69312C(int a1, int a2);
// void __cdecl sub_6E6931DC(int a1, int a2);
// void __cdecl sub_6E693221(int a1, int a2);
// void __cdecl sub_6E693265(int a1, int a2);
// void __cdecl sub_6E6932A9(int a1, int a2);
// void __cdecl sub_6E6932ED(int a1, int a2);
// void __cdecl sub_6E693331(int a1, int a2);
// void __cdecl sub_6E693375(int a1, int a2);
// void __cdecl sub_6E6933B9(int a1, int a2);
// void __cdecl sub_6E693430(int a1, int a2);
// void __cdecl sub_6E693475(int a1, int a2);
// void __cdecl sub_6E6934B9(int a1, int a2);
// void __cdecl sub_6E6934FD(int a1, int a2);
// void __cdecl sub_6E693578(int a1, int a2);
// void __cdecl sub_6E6935D9(int a1, int a2);
// void __cdecl sub_6E693630(int a1, int a2);
// void __cdecl sub_6E693688(int a1, int a2);
// void __cdecl sub_6E693734(int a1, int a2);
// void __cdecl sub_6E693779(int a1, int a2);
// void __cdecl sub_6E6937BD(int a1, int a2);
// void __cdecl sub_6E693801(int a1, int a2);
// void __cdecl sub_6E693924(int a1, int a2);
// void __cdecl sub_6E693988(int a1, int a2);
// void __cdecl sub_6E6939EC(int a1, int a2);
// void __cdecl sub_6E693A68(int a1, int a2);
// void __cdecl sub_6E693ACC(int a1, int a2);
// void __cdecl sub_6E693B30(int a1, int a2);
// void __cdecl sub_6E693B88(int a1, int a2);
// void __cdecl sub_6E693BEC(int a1, int a2);
// void __cdecl sub_6E693C4D(int a1, int a2);
// void __cdecl sub_6E693CBD(int a1, int a2);
// void __cdecl sub_6E693D48(int a1, int a2);
// void __cdecl sub_6E693DAF(int a1, int a2);
// void __cdecl sub_6E693E14(int a1, int a2);
// void __cdecl sub_6E693E59(int a1, int a2);
// void __cdecl sub_6E693EB0(int a1, int a2);
// void __cdecl sub_6E693F08(int a1, int a2);
// void __cdecl sub_6E693F60(int a1, int a2);
// void __cdecl sub_6E693FBC(int a1, int a2);
// void __cdecl sub_6E694020(int a1, int a2);
// void __cdecl sub_6E694065(int a1, int a2);
// void __cdecl sub_6E6940ED(int a1, int a2);
// void __cdecl sub_6E694131(int a1, int a2);
// void __cdecl sub_6E694175(int a1, int a2);
// void __cdecl sub_6E6941B9(int a1, int a2);
// void __cdecl sub_6E6941FD(int a1, int a2);
// void __cdecl sub_6E694241(int a1, int a2);
// void __cdecl sub_6E694298(int a1, int a2);
// void __cdecl sub_6E6942F0(int a1, int a2);
// void __cdecl sub_6E694335(int a1, int a2);
// void __cdecl sub_6E69438C(int a1, int a2);
// void __cdecl sub_6E6943E4(int a1, int a2);
// void __cdecl sub_6E694429(int a1, int a2);
// void __cdecl sub_6E694480(int a1, int a2);
// void __cdecl sub_6E6944D1(int a1, int a2);
// void __cdecl sub_6E694525(int a1, int a2);
// void __cdecl sub_6E69457C(int a1, int a2);
// void __cdecl sub_6E6945D7(int a1, int a2);
// void __cdecl sub_6E69463C(int a1, int a2);
// void __cdecl sub_6E694694(int a1, int a2);
// void __cdecl sub_6E6946EC(int a1, int a2);
// void __cdecl sub_6E69479C(int a1, int a2);
// void __cdecl _ehhandler___Pop__Micro_queue_details_Concurrency__QAE_NPAXIAAV_Concurrent_queue_base_v4_23__Z(int a1, int a2);
// void __cdecl sub_6E694867(int a1, int a2);
// void __cdecl sub_6E6948C0(int a1, int a2);
// void __cdecl sub_6E694918(int a1, int a2);
// void __cdecl _ehhandler___0_TaskCollection_details_Concurrency__AAE_PAV012__N_Z(int a1, int a2);
// void __cdecl sub_6E694A7C(int a1, int a2);
// void __cdecl sub_6E694AD8(int a1, int a2);
// void __cdecl sub_6E694B52(int a1, int a2);
// void __cdecl sub_6E694BD0(int a1, int a2);
// void __cdecl sub_6E694C25(int a1, int a2);
// void __cdecl sub_6E694CA4(int a1, int a2);
// void __cdecl sub_6E694CFF(int a1, int a2);
// void __cdecl sub_6E694D67(int a1, int a2);
// void __cdecl sub_6E694DC0(int a1, int a2);
// void __cdecl sub_6E694E05(int a1, int a2);
// void __cdecl sub_6E694E6C(int a1, int a2);
// void __cdecl sub_6E694EC7(int a1, int a2);
// void __cdecl sub_6E694F31(int a1, int a2);
// void __cdecl sub_6E694F95(int a1, int a2);
// void __cdecl sub_6E694FD9(int a1, int a2);
// void __cdecl sub_6E695088(int a1, int a2);
// void __cdecl sub_6E6950E0(int a1, int a2);
// void __cdecl sub_6E695138(int a1, int a2);
// void __cdecl sub_6E695190(int a1, int a2);
// void __cdecl sub_6E6951E8(int a1, int a2);
// void __cdecl sub_6E6952A4(int a1, int a2);
// void __cdecl sub_6E695354(int a1, int a2);
// void __cdecl sub_6E6953B7(int a1, int a2);
// void __cdecl sub_6E695470(int a1, int a2);
// void __cdecl _ehhandler__RegisterForExitTracking_SchedulerBase_details_Concurrency__QAEXPAVExternalContextBase_23__Z(int a1, int a2);
// void __cdecl sub_6E69552D(int a1, int a2);
// void __cdecl sub_6E695599(int a1, int a2);
// void __cdecl sub_6E6955F0(int a1, int a2);
// PVOID __stdcall SetupInitDefaultQueueCallbackEx(HWND OwnerWindow, HWND AlternateProgressWindow, UINT ProgressMessage, DWORD Reserved1, PVOID Reserved2);
// HSPFILEQ __stdcall SetupOpenFileQueue();
// HINF __stdcall SetupOpenInfFileW(PCWSTR FileName, PCWSTR InfClass, DWORD InfStyle, PUINT ErrorLine);
// BOOL __stdcall SetupFindFirstLineW(HINF InfHandle, PCWSTR Section, PCWSTR Key, PINFCONTEXT Context);
// BOOL __stdcall SetupFindNextLine(PINFCONTEXT ContextIn, PINFCONTEXT ContextOut);
// BOOL __stdcall SetupGetIntField(PINFCONTEXT Context, DWORD FieldIndex, PINT IntegerValue);
// BOOL __stdcall SetupGetMultiSzFieldW(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, LPDWORD RequiredSize);
// BOOL __stdcall SetupGetStringFieldW(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, PDWORD RequiredSize);
// BOOL __stdcall SetupScanFileQueueW(HSPFILEQ FileQueue, DWORD Flags, HWND Window, PSP_FILE_CALLBACK_W CallbackRoutine, PVOID CallbackContext, PDWORD Result);
// BOOL __stdcall SetupDiCallClassInstaller(DI_FUNCTION InstallFunction, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupCopyOEMInfW(PCWSTR SourceInfFileName, PCWSTR OEMSourceMediaLocation, DWORD OEMSourceMediaType, DWORD CopyStyle, PWSTR DestinationInfFileName, DWORD DestinationInfFileNameSize, PDWORD RequiredSize, PWSTR *DestinationInfFileNameComponent);
// BOOL __stdcall SetupDiBuildDriverInfoList(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType);
// BOOL __stdcall SetupDiCreateDeviceInfoW(HDEVINFO DeviceInfoSet, PCWSTR DeviceName, const GUID *ClassGuid, PCWSTR DeviceDescription, HWND hwndParent, DWORD CreationFlags, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiEnumDeviceInfo(HDEVINFO DeviceInfoSet, DWORD MemberIndex, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiEnumDriverInfoW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType, DWORD MemberIndex, PSP_DRVINFO_DATA_W DriverInfoData);
// BOOL __stdcall SetupDiSelectBestCompatDrv(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiGetDeviceInfoListClass(HDEVINFO DeviceInfoSet, LPGUID ClassGuid);
// BOOL __stdcall SetupCommitFileQueueW(HWND Owner, HSPFILEQ QueueHandle, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context);
// BOOL __stdcall SetupDiInstallDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// HKEY __stdcall SetupDiOpenDevRegKey(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, REGSAM samDesired);
// BOOL __stdcall SetupDiSetClassInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_CLASSINSTALL_HEADER ClassInstallParams, DWORD ClassInstallParamsSize);
// BOOL __stdcall SetupDiGetClassInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_CLASSINSTALL_HEADER ClassInstallParams, DWORD ClassInstallParamsSize, PDWORD RequiredSize);
// BOOL __stdcall SetupDiGetSelectedDriverW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData);
// BOOL __stdcall SetupDiGetDriverInfoDetailW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINFO_DETAIL_DATA_W DriverInfoDetailData, DWORD DriverInfoDetailDataSize, PDWORD RequiredSize);
// HKEY __stdcall SetupDiCreateDevRegKeyW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, HINF InfHandle, PCWSTR InfSectionName);
// BOOL __stdcall SetupDiGetActualSectionToInstallW(HINF InfHandle, PCWSTR InfSectionName, PWSTR InfSectionWithExt, DWORD InfSectionWithExtSize, PDWORD RequiredSize, PWSTR *Extension);
// BOOL __stdcall SetupDiGetDriverInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams);
// BOOL __stdcall SetupDiSetDeviceInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DEVINSTALL_PARAMS_W DeviceInstallParams);
// BOOL __stdcall SetupDiSetDriverInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams);
// BOOL __stdcall SetupDiRemoveDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiOpenDeviceInfoW(HDEVINFO DeviceInfoSet, PCWSTR DeviceInstanceId, HWND hwndParent, DWORD OpenFlags, PSP_DEVINFO_DATA DeviceInfoData);
// HDEVINFO __stdcall SetupDiCreateDeviceInfoList(const GUID *ClassGuid, HWND hwndParent);
// BOOL __stdcall SetupDiSetDeviceRegistryPropertyW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, const BYTE *PropertyBuffer, DWORD PropertyBufferSize);
// BOOL __stdcall SetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData);
// BOOL __stdcall SetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData);
// BOOL __stdcall SetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA ClassImageListData, const GUID *ClassGuid, PINT ImageIndex);
// BOOL __stdcall SetupInstallFilesFromInfSectionW(HINF InfHandle, HINF LayoutInfHandle, HSPFILEQ FileQueue, PCWSTR SectionName, PCWSTR SourceRootPath, UINT CopyFlags);
// BOOL __stdcall SetupInstallFromInfSectionW(HWND Owner, HINF InfHandle, PCWSTR SectionName, UINT Flags, HKEY RelativeKeyRoot, PCWSTR SourceRootPath, UINT CopyFlags, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// CONFIGRET __stdcall CM_Get_DevNode_Status_Ex(PULONG pulStatus, PULONG pulProblemNumber, DEVINST dnDevInst, ULONG ulFlags, HMACHINE hMachine);
// BOOL __stdcall SetupDiGetDeviceRegistryPropertyW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, PBYTE PropertyBuffer, DWORD PropertyBufferSize, PDWORD RequiredSize);
// BOOL __stdcall SetupDiDestroyDriverInfoList(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType);
// BOOL __stdcall SetupInstallServicesFromInfSectionW(HINF InfHandle, PCWSTR SectionName, DWORD Flags);
// BOOL __stdcall SetupOpenAppendInfFileW(PCWSTR FileName, HINF InfHandle, PUINT ErrorLine);
// UINT __stdcall SetupDefaultQueueCallbackW(PVOID Context, UINT Notification, UINT_PTR Param1, UINT_PTR Param2);
// void __stdcall SetupTermDefaultQueueCallback(PVOID Context);
// BOOL __stdcall SetupCloseFileQueue(HSPFILEQ QueueHandle);
// BOOL __stdcall SetupDiDeleteDeviceInfo(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiGetDeviceInstallParamsW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DEVINSTALL_PARAMS_W DeviceInstallParams);
// BOOL __stdcall SetupDiRestartDevices(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData);
// BOOL __stdcall SetupDiGetDeviceInstanceIdW(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PWSTR DeviceInstanceId, DWORD DeviceInstanceIdSize, PDWORD RequiredSize);
// BOOL __stdcall SetupDiDestroyDeviceInfoList(HDEVINFO DeviceInfoSet);
// void __stdcall SetupCloseInfFile(HINF InfHandle);
// SP_LOG_TOKEN __stdcall SetupGetThreadLogToken();
// HDEVINFO __stdcall SetupDiGetClassDevsW(const GUID *ClassGuid, PCWSTR Enumerator, HWND hwndParent, DWORD Flags);
// void _SetupWriteTextLog(SP_LOG_TOKEN LogToken, DWORD Category, DWORD Flags, PCSTR MessageStr, ...);
// HIMAGELIST __stdcall ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
// INT_PTR __stdcall PropertySheetW(LPCPROPSHEETHEADERW);
// HPROPSHEETPAGE __stdcall CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
// HIMAGELIST __stdcall ImageList_Duplicate(HIMAGELIST himl);
// BOOL __stdcall ImageList_Destroy(HIMAGELIST himl);
// int __stdcall ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
// int __stdcall ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
// int __stdcall ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
// BOOL __stdcall DestroyPropertySheetPage(HPROPSHEETPAGE);
// DWORD __stdcall RasEnumConnectionsW(struct tagRASCONNW *, LPDWORD, LPDWORD);
// BOOL __stdcall AddPrintProvidorW(LPWSTR pName, DWORD level, LPBYTE pProvidorInfo);
// BOOL __stdcall DeletePrintProvidorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pPrintProvidorName);
// INT __stdcall WSCUnInstallNameSpace(LPGUID lpProviderId);
// INT __stdcall WSCInstallNameSpace(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId);

//-------------------------------------------------------------------------
// Data declarations

char byte_6E640000[2] = { 'M', 'Z' }; // weak
__int16 word_6E640002 = 144; // weak
int (__stdcall *ATL::CComObjectNoLock<ATL::CComClassFactory>::`vftable')(ATL::CComClassFactory *, struct _GUID *, void **) = &ATL::CComObjectNoLock<ATL::CComClassFactory>::QueryInterface; // weak
GUID CLSID_CNetCfg = { 1526944353u, 16633u, 4561u, { 170u, 236u, 0u, 128u, 95u, 193u, 39u, 14u } };
int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(CMSClient *, struct _GUID *, void **) = &ATL::CComObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfgComponent>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfgComponent>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfgComponent>::QueryInterface; // weak
GUID GUID_DEVCLASS_NET = { 1295444338u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
_UNKNOWN loc_6E642105; // weak
_UNKNOWN loc_6E642398; // weak
_UNKNOWN loc_6E642468; // weak
_UNKNOWN loc_6E6424BE; // weak
_UNKNOWN loc_6E64278F; // weak
_UNKNOWN loc_6E642935; // weak
int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(CImplINetCfg *, struct _GUID *, void **) = &ATL::CComObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(CImplINetCfgComponent *, struct _GUID *, void **) = &ATL::CComObject<CImplINetCfgComponent>::QueryInterface; // weak
int (__stdcall *ATL::CComAggObject<CImplINetCfg>::`vftable')(int, struct _GUID *, void **) = &ATL::CComAggObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComAggObject<CSrvrcfg>::`vftable')(int, struct _GUID *, void **) = &ATL::CComAggObject<CSrvrcfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CAdvancedConfig>::`vftable')(CAdvancedConfig *, struct _GUID *, void **) = &ATL::CComObject<CAdvancedConfig>::QueryInterface; // weak
int (__stdcall *ATL::CComAggObject<CAdvancedConfig>::`vftable')(int, struct _GUID *, void **) = &ATL::CComAggObject<CAdvancedConfig>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`vftable')(CImplIEnumNetCfgBindingInterface *, struct _GUID *, void **) = &ATL::CComObject<CImplIEnumNetCfgBindingInterface>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplIEnumNetCfgComponent>::`vftable')(CImplIEnumNetCfgComponent *, struct _GUID *, void **) = &ATL::CComObject<CImplIEnumNetCfgComponent>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingPath>::`vftable')(CImplIEnumNetCfgBindingPath *, struct _GUID *, void **) = &ATL::CComObject<CImplIEnumNetCfgBindingPath>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgBindingInterface>::`vftable')(CImplINetCfgBindingInterface *, struct _GUID *, void **) = &ATL::CComObject<CImplINetCfgBindingInterface>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgBindingPath>::`vftable')(CImplINetCfgBindingPath *, struct _GUID *, void **) = &ATL::CComObject<CImplINetCfgBindingPath>::QueryInterface; // weak
GUID IID_INetCfgComponentBindings = { 3236474526u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
int (__stdcall *ATL::CComAggObject<CMSClient>::`vftable')(int, struct _GUID *, void **) = &ATL::CComAggObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(CImplINetCfgClass *, struct _GUID *, void **) = &ATL::CComObject<CImplINetCfgClass>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(int, int, int) = &ATL::CComObject<CImplINetCfgClass>::QueryInterface; // weak
_UNKNOWN extrabytes; // weak
GUID IID_INetCfgLock = { 3236474527u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_INetCfgInternalSetup = { 2551394934u, 19232u, 4561u, { 171u, 1u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_INetCfgSpecialCase = { 3236474517u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
_UNKNOWN loc_6E64561C; // weak
wchar_t *off_6E645820[2] = { L"Ndi", L"Clsid" }; // weak
GUID IID_INetCfg = { 3236474515u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_INetCfgClass = { 3236474519u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_IEnumNetCfgComponent = { 3236474514u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_INetCfgClassSetup = { 3236474525u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
int (__thiscall *CBindingsDlg::`vftable')(CBindingsDlg *this, HWND, unsigned __int32, CSrvrcfg *, HWND, CBindingsDlg *, unsigned __int32) = &CBindingsDlg::ProcessWindowMessage; // weak
int (__thiscall *CProviderOrderDlg::`vftable')(CProviderOrderDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CProviderOrderDlg *, unsigned __int32) = &CProviderOrderDlg::ProcessWindowMessage; // weak
_UNKNOWN loc_6E647B94; // weak
_UNKNOWN loc_6E647BB8; // weak
_UNKNOWN loc_6E647BCA; // weak
_UNKNOWN loc_6E647BDD; // weak
int dword_6E647BE8[2] = { 4294967294, 0 }; // weak
int (*CPropSheetPage::`vftable')() = &_purecall; // weak
_UNKNOWN loc_6E647D00; // weak
PfnDliHook __pfnDliNotifyHook2 = NULL;
int (*ATL::CComClassFactory::`vftable'[3])() = { &_purecall, &_purecall, &_purecall }; // weak
GUID IID_IUnknown = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
const WCHAR SrcStr = 0u; // idb
int __xc_a = 0; // weak
int __xc_z = 0; // weak
int __xi_a = 0; // weak
int __xi_z = 0; // weak
int (__cdecl *_FPinit)(_DWORD) = &_fpmath; // weak
_UNKNOWN loc_6E64A7DB; // weak
void *off_6E64A878 = &loc_6E64A7D4; // weak
int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int) = &ATL::CComObject<CSrvrcfg>::QueryInterface; // weak
int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int) = &ATL::CComObject<CSrvrcfg>::QueryInterface; // weak
const WCHAR String = 0u; // idb
char __lookuptable_s[] = { '\x06' }; // weak
int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(CSrvrcfg *, struct _GUID *, void **) = &ATL::CComObject<CSrvrcfg>::QueryInterface; // weak
_UNKNOWN loc_6E64C39C; // weak
LPCWSTR MAP_NETCLASS_TO_NETWORK_SUBTREE = L"System\\CurrentControlSet\\Control\\Network\\{4d36e972-e325-11ce-bfc1-08002be10318}"; // idb
GUID IID_INetCfgComponentNotifyBinding = { 2468493537u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
GUID IID_INetCfgComponentUpperEdge = { 2468493540u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
GUID IID_INetCfgComponentControl = { 2468493535u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
GUID IID_INetCfgComponentSetup = { 2468493539u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
GUID IID_INetCfgComponentPropertyUi = { 2468493536u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
GUID IID_INetCfgComponentNotifyGlobal = { 2468493538u, 48801u, 4560u, { 146u, 152u, 0u, 192u, 79u, 201u, 157u, 207u } };
wchar_t asc_6E64D524[] = L"->"; // idb
GUID GUID_DEVCLASS_INFRARED = { 1809653701u, 33039u, 4560u, { 190u, 199u, 8u, 0u, 43u, 226u, 9u, 47u } };
GUID GUID_DEVCLASS_NETCLIENT = { 1295444339u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
GUID GUID_DEVCLASS_NETSERVICE = { 1295444340u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
GUID GUID_DEVCLASS_NETTRANS = { 1295444341u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
_UNKNOWN loc_6E64DE79; // weak
_UNKNOWN loc_6E64E960; // weak
_UNKNOWN loc_6E64F5E7; // weak
_UNKNOWN loc_6E64FB09; // weak
GUID IID_INetCfgBindingPath = { 3236474518u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
_UNKNOWN loc_6E65006A; // weak
_UNKNOWN loc_6E6503A8; // weak
GUID IID_INetCfgBindingInterface = { 3236474516u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID IID_IEnumNetCfgBindingInterface = { 3236474512u, 12398u, 4561u, { 170u, 207u, 0u, 128u, 95u, 193u, 39u, 14u } };
_UNKNOWN loc_6E651B3C; // weak
_UNKNOWN loc_6E651CC7; // weak
_UNKNOWN locret_6E651CD0; // weak
_UNKNOWN loc_6E652042; // weak
_UNKNOWN loc_6E652077; // weak
_UNKNOWN loc_6E652A8A; // weak
const CHAR byte_6E6530C8 = '\0'; // idb
_UNKNOWN loc_6E653A19; // weak
_UNKNOWN loc_6E655693; // weak
_UNKNOWN locret_6E65569C; // weak
_UNKNOWN loc_6E655A19; // weak
_UNKNOWN loc_6E655A95; // weak
_UNKNOWN loc_6E656AC9; // weak
_UNKNOWN loc_6E65759D; // weak
int dword_6E658688[2] = { 1, 0 }; // weak
int dword_6E658720 = 0; // weak
_UNKNOWN loc_6E659D3D; // weak
_UNKNOWN loc_6E659DD7; // weak
_UNKNOWN loc_6E659E09; // weak
int (__thiscall *std::logic_error::`vftable')(void *lpMem, char) = &std::logic_error::`vector deleting destructor'; // weak
wchar_t aMs_tcpip[9] = L"ms_tcpip"; // weak
int (__thiscall *std::bad_alloc::`vftable')(void *lpMem, char) = &std::bad_alloc::`vector deleting destructor'; // weak
int (__thiscall *std::out_of_range::`vftable')(void *lpMem, char) = &std::out_of_range::`vector deleting destructor'; // weak
int (__thiscall *exception::`vftable')(void *lpMem, char) = &exception::`vector deleting destructor'; // weak
_UNKNOWN off_6E65C950; // weak
const char *const __lookuptable = (const char *const )0x6000006; // weak
const struct PERM_MAP_STRUCT *const USER_PERM_MAP = (const struct PERM_MAP_STRUCT *const )2; // weak
wchar_t *off_6E65CFBC = L"NC_AddRemoveComponents"; // weak
int dword_6E65CFC0[] = { 1 }; // weak
int dword_6E65D4E0[34] =
{
  1005,
  2003230,
  2003230,
  1010,
  2003240,
  2003240,
  1008,
  2003250,
  2003255,
  14103,
  2003265,
  2003260,
  1001,
  2003270,
  2003270,
  1002,
  2003280,
  2003280,
  1014,
  2003290,
  2003290,
  1003,
  2003300,
  2003300,
  1000,
  2003310,
  2003310,
  1011,
  2003320,
  2003320,
  0,
  0,
  0,
  0
}; // weak
int (__thiscall *CIsdnPage::`vftable')(CIsdnPage *this, HWND, unsigned int, unsigned int, HWND, CIsdnPage *, unsigned __int32) = &CIsdnPage::ProcessWindowMessage; // weak
int (__thiscall *CEazDlg::`vftable'[4])(CEazDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32) =
{
  &CEazDlg::ProcessWindowMessage,
  &CMsnDlg::ProcessWindowMessage,
  &CJapanDlg::ProcessWindowMessage,
  &CSpidsDlg::ProcessWindowMessage
}; // weak
int (__thiscall *CMsnDlg::`vftable'[3])(CMsnDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32) =
{
  &CMsnDlg::ProcessWindowMessage,
  &CJapanDlg::ProcessWindowMessage,
  &CSpidsDlg::ProcessWindowMessage
}; // weak
int (__thiscall *CJapanDlg::`vftable'[2])(CJapanDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32) = { &CJapanDlg::ProcessWindowMessage, &CSpidsDlg::ProcessWindowMessage }; // weak
int (__thiscall *CSpidsDlg::`vftable')(CSpidsDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32) = &CSpidsDlg::ProcessWindowMessage; // weak
unsigned __int32 dword_6E65D638 = 1u; // idb
unsigned int dword_6E65D63C = 12u; // idb
struct IUnknown stru_6E65D6B0 = { (struct IUnknownVtbl *)0x73006D }; // idb
int (__thiscall *CAdvanced::`vftable')(CAdvanced *this, HWND, unsigned int, unsigned int, HWND, CAdvanced *, unsigned __int32) = &CAdvanced::ProcessWindowMessage; // weak
GUID _GUID_c08956a2_1cd3_11d1_b1c5_00805fc1270e = { 3230226082u, 7379u, 4561u, { 177u, 197u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID CLSID_LanConnectionManager = { 3121769171u, 8550u, 4561u, { 177u, 208u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID GUID_NULL = { 0u, 0u, 0u, { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } };
int NPI_MS_NDIS_MODULEID[6] = { 24, 1, 3942664721, 299146010, 1342186385, 3159979780 }; // weak
int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComContainedObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComContainedObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComContainedObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int) = &ATL::CComContainedObject<CMSClient>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CSrvrcfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CSrvrcfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CSrvrcfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CAdvancedConfig>::`vftable')(int, int, int) = &ATL::CComContainedObject<CAdvancedConfig>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CImplINetCfg>::QueryInterface; // weak
int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int) = &ATL::CComContainedObject<CImplINetCfg>::QueryInterface; // weak
LPCWSTR off_6E6601E0 = L"HKCR"; // idb
int dword_6E6601E4[] = { 2147483648 }; // weak
GUID _GUID_98133274_4b20_11d1_ab01_00805fc1270e = { 2551394932u, 19232u, 4561u, { 171u, 1u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID CLSID_InstallQueue = { 3121769183u, 8550u, 4561u, { 177u, 208u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID _GUID_faedcf5f_31fe_11d1_aad2_00805fc1270e = { 4209889119u, 12798u, 4561u, { 170u, 210u, 0u, 128u, 95u, 193u, 39u, 14u } };
GUID CLSID_ConnectionManager = { 3121769169u, 8550u, 4561u, { 177u, 208u, 0u, 128u, 95u, 193u, 39u, 14u } };
int dword_6E66243C = 0; // weak
int dword_6E662440 = 0; // weak
int dword_6E663498[] = { 3 }; // weak
wchar_t *off_6E66349C = L"ms_msclient"; // weak
int dword_6E6634A0[] = { 0 }; // weak
int _TI2_AVlogic_error_std__ = 0; // weak
_UNKNOWN loc_6E66B984; // weak
_UNKNOWN loc_6E66D21F; // weak
_UNKNOWN loc_6E66DAD9; // weak
_UNKNOWN loc_6E66DB1E; // weak
wchar_t asc_6E66F630[3] = L", "; // weak
GUID IID_INetRasConnectionIpUiInfo = { 4209889112u, 12798u, 4561u, { 170u, 210u, 0u, 128u, 95u, 193u, 39u, 14u } };
int dword_6E673F90 = 0; // weak
int dword_6E673F94 = 1; // weak
_UNKNOWN loc_6E6745C0; // weak
_UNKNOWN loc_6E67479B; // weak
_UNKNOWN loc_6E675595; // weak
_UNKNOWN loc_6E6756FD; // weak
int (__cdecl *_pDestructExceptionObject)(_DWORD, _DWORD) = &__DestructExceptionObject; // weak
struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_6E699508, &dword_6E699798 }; // idb
GUID _GUID_00000000_0000_0000_c000_000000000046 = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
const unsigned __int16 *const off_6E683B44 = &c_szYes; // weak
// extern _UNKNOWN loc_6E683E5A; weak
// extern _UNKNOWN loc_6E683E71; weak
wchar_t aIsdn[5] = L"isdn"; // weak
const WCHAR c_szEmpty = 0u; // idb
int dword_6E688D98 = 14120; // weak
int dword_6E688D9C = 10; // weak
int dword_6E688DA0 = 11; // weak
int (__stdcall *off_6E688DA4)(HWND hWnd, unsigned int, unsigned int, __int32) = &IsdnSwitchTypeProc; // weak
int (__thiscall *CRPCConfigDlg::`vftable')(CRPCConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, __int32 *, unsigned __int32) = &CRPCConfigDlg::ProcessWindowMessage; // weak
int (__thiscall *CServerConfigDlg::`vftable')(CServerConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CPropSheetPage *, unsigned __int32) = &CServerConfigDlg::ProcessWindowMessage; // weak
int nIDButton = 203; // idb
GUID GUID_DEVCLASS_MODEM = { 1295444333u, 58149u, 4558u, { 191u, 193u, 8u, 0u, 43u, 225u, 3u, 24u } };
int dword_6E6914B0[9] = { 1, 28443, 28443, 2, 28444, 28444, 0, 0, 0 }; // weak
int _TI3_AVlength_error_std__ = 0; // weak
int _TI2_AVbad_alloc_std__ = 0; // weak
int _TI3_AVout_of_range_std__ = 0; // weak
int _TI2_AVbad_exception_std__ = 0; // weak
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_SETUPAPI_dll = { 1 }; // idb
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_COMCTL32_dll = { 1 }; // idb
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_MSWSOCK_dll = { 1 }; // idb
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_RASAPI32_dll = { 1 }; // idb
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_WINSPOOL_DRV = { 1 }; // idb
struct HINSTANCE__ _DELAY_IMPORT_DESCRIPTOR_WS2_32_dll = { 1 }; // idb
// extern void *pSetupLoadIndirectString; weak
// extern void *pSetupGetIndirectStringsFromDriverInfo; weak
// extern void *MigrateWinsockConfiguration; weak
int `IsRunningOnWow64'::`2'::dwCachedWow64 = 4294967295; // weak
int __security_cookie_complement = 1153374641; // weak
DWORD __getvalueindex = 4294967295u; // idb
int __flsindex = 4294967295; // weak
HANDLE g_hLocalHeap = NULL; // idb
int dword_6E699158 = 0; // weak
void *_aenvptr = NULL; // idb
int _osplatform = 0; // weak
unsigned int _osver = 0u;
unsigned int _winver = 0u;
unsigned int _winmajor = 0u;
unsigned int _winminor = 0u;
int __argc = 0;
char **__argv = NULL;
char *_pgmptr = NULL;
int _C_Termination_Done = 0; // weak
int gpFlsAlloc = 0; // weak
LPVOID gpFlsGetValue = NULL; // idb
int gpFlsSetValue = 0; // weak
int gpFlsFree = 0; // weak
int dword_6E6991A0 = 0; // weak
HANDLE _crtheap = NULL; // idb
int dword_6E6991AC = 0; // weak
int dword_6E6991B8 = 0; // weak
int dword_6E6991C0 = 0; // weak
int dword_6E6991C4 = 0; // weak
int dword_6E6991CC = 0; // weak
int dword_6E6991D0 = 0; // weak
void *__piob = NULL; // idb
int _nstream = 0; // weak
int __sse2_available = 0; // weak
int __active_heap = 0; // weak
UINT _nhandle = 0u; // idb
int __onexitend = 0; // weak
int __onexitbegin = 0; // weak
int __mbctype_initialized = 0; // weak
int _acmdln = 0; // weak
HANDLE g_ConfigLoadSaveMutex = NULL; // idb
_UNKNOWN _Module; // weak
HMODULE hModule = NULL; // idb
HINSTANCE hInst = NULL; // idb
int dword_6E699218 = 0; // weak
volatile LONG Addend = 0; // idb
volatile LONG __initialmbcinfo = 0; // idb
int (*__initiallocalestructinfo)[22] = &__initiallocinfo; // weak
uintptr_t __security_cookie = 3141592654u;
int dword_6E699508 = 0; // weak
int dword_6E69950C = 0; // weak
int dword_6E699514 = 0; // weak
wchar_t *off_6E699620 = L"         (((((                  H"; // weak
int dword_6E699798 = 0; // weak
__int16 word_6E699824 = 0; // weak
__int16 word_6E699828 = 0; // weak
__int16 word_6E69982C = 0; // weak
__int16 word_6E699830 = 0; // weak
int dword_6E699834 = 0; // weak
int dword_6E699838 = 0; // weak
int dword_6E69983C = 0; // weak
int dword_6E699840 = 0; // weak
int dword_6E699844 = 0; // weak
int dword_6E699848 = 0; // weak
int dword_6E69984C = 0; // weak
int dword_6E699850 = 0; // weak
__int16 word_6E699854 = 0; // weak
int dword_6E699858 = 0; // weak
int dword_6E69985C = 0; // weak
__int16 word_6E699860 = 0; // weak
int __clocalestr[2] = { 67, 0 }; // weak
int (*off_6E699A90[4])() = { &_fptrap, &_fptrap, &_fptrap, &_fptrap }; // weak
int (*off_6E699A98[2])() = { &_fptrap, &_fptrap }; // weak
int (*off_6E699A9C)() = &_fptrap; // weak
int _XcptActTab[3] = { 3221225477, 11, 0 }; // weak
_UNKNOWN off_6E699B18; // weak
int __pioinfo[] = { 0 }; // weak
CHAR Filename[260] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_6E699DC4 = '\0'; // weak
LPCRITICAL_SECTION lpCriticalSection = NULL; // idb
int dword_6E699DCC[] = { 1 }; // weak
int dword_6E699EE8[84] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
FILE _iob[] = ;
int dword_6E69A048[2] = { 0, 0 }; // weak
int dword_6E69A058[3] = { 0, 0, 0 }; // weak
int dword_6E69A078[3] = { 0, 0, 0 }; // weak
int dword_6E69A0A8[124] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_6E69A298[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_6E69A2B8[2] = { 0, 0 }; // weak
volatile LONG *___ptmbcinfo = &__initialmbcinfo; // idb
_DWORD ___ptlocinfo = 1852413272; // weak
int g_IsInUpgrade = 0; // weak
int __locale_changed = 0; // weak
int (__stdcall *_pRawDllMain)(_DWORD, _DWORD, _DWORD) = NULL; // weak
char __globallocalestatus = ''; // weak
HANDLE _coninpfh = (HANDLE)0xFFFFFFFE; // idb
HANDLE _confh = (HANDLE)0xFFFFFFFE; // idb
int __mb_cur_max = 1;
CDiagContext *g_pDiagCtx = NULL; // idb
GUID MAP_NETCLASS_TO_GUID =
{
  1852054360u,
  55472u,
  28260u,
  { 224u, 216u, 100u, 110u, 192u, 216u, 100u, 110u }
};
const wctype_t *_pwctype = &asc_6E64D552;
int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD) = NULL; // weak
const unsigned __int16 **ATL::rgszNeverDelete = &aClsid_0; // weak
int (__thiscall **std::length_error `RTTI Type Descriptor')(void *lpMem, char) = &type_info::`vftable'; // weak
int dword_6E69B4A4 = 4294967295; // weak
int dword_6E69B610 = 12; // weak
int __badioinfo[9] = { 4294967295, 2688, 0, 0, 0, 0, 0, 0, 0 }; // weak
int (__thiscall **std::bad_exception `RTTI Type Descriptor')(void *lpMem, char) = &type_info::`vftable'; // weak
char *__nullstring = "(null)"; // weak
unsigned __int16 *__wnullstring = &aNull_0; // weak
char *__nullstring = "(null)"; // weak
wchar_t *__wnullstring = L"(null)"; // weak
int dword_6E69B898[] = { 2 }; // weak
LPCVOID lpBuffer = &aR6002FloatingP; // idb
int dword_6E69B958 = 1024; // weak
int dword_6E69B95C = 4294966273; // weak
int dword_6E69B960 = 53; // weak
int dword_6E69B964 = 11; // weak
int dword_6E69B968 = 64; // weak
int dword_6E69B96C = 1023; // weak
int dword_6E69B970 = 128; // weak
int dword_6E69B974 = 4294967169; // weak
int dword_6E69B978 = 24; // weak
int dword_6E69B97C = 8; // weak
int dword_6E69B980 = 32; // weak
int dword_6E69B984 = 127; // weak
int _pow10pos[2] = { 0, 0 }; // weak
int _pow10neg[87] =
{
  3436039373,
  3435973836,
  1073466572,
  3607772529,
  171798691,
  1073259479,
  3745211482,
  1855425871,
  1073054482,
  1697436611,
  391701017,
  1072812471,
  2216890320,
  2890341191,
  1072605125,
  1773577792,
  3171266412,
  1072399927,
  1119632691,
  2497045882,
  1072158399,
  3472752066,
  1997636705,
  1071950796,
  3780856879,
  2495530061,
  1070196373,
  995345554,
  348996725,
  1068473022,
  2495244254,
  514671929,
  1066717105,
  3804635940,
  825998012,
  1064995681,
  3243857249,
  2085859710,
  1063238418,
  2368728791,
  2240986630,
  1061485333,
  3919920932,
  3928466745,
  1059760255,
  3835800701,
  1182557372,
  1045814736,
  3422976867,
  2205635619,
  1031901695,
  423295633,
  1126523770,
  1017954353,
  953256225,
  3096921986,
  1004010752,
  140019932,
  3823677723,
  990094982,
  1111852230,
  1973007879,
  976149303,
  3525079347,
  3996310307,
  962236489,
  3233712038,
  2191907415,
  850764454,
  296904930,
  1151292071,
  739293017,
  769935653,
  1397699638,
  627822254,
  2751748495,
  2109923008,
  516352251,
  1518921630,
  3208417623,
  404915024,
  1650805582,
  2945418237,
  293442566,
  2682138084,
  80270030,
  181970653
}; // weak
int dword_6E69BC48 = 356; // weak
wchar_t *off_6E69BC50 = L"edit"; // weak
GUID *off_6E69BCC0[3] = { &GUID_DEVCLASS_NETTRANS, &GUID_DEVCLASS_NETSERVICE, &GUID_DEVCLASS_NETCLIENT }; // weak
LPCWSTR lpString2 = NULL; // idb
__int16 word_6E69BCD0[] = { 0 }; // weak
int dword_6E69BCD4 = 0; // weak
__int16 word_6E69BCD8 = 0; // weak
int dword_6E69BCDC = 0; // weak
HANDLE g_ConnectionNameMutex = NULL; // idb
int dword_6E69BCE4 = 0; // weak
int dword_6E69BCE8 = 0; // weak
int dword_6E69BCEC = 0; // weak
int dword_6E69BCF0 = 0; // weak
int dword_6E69BCF4 = 0; // weak
LONG lpfnOldWndProc = 0; // idb
int g_fChanged = 0; // weak
__int32 g_hr = 0; // weak
_UNKNOWN g_cai; // weak
int dword_6E69BD08 = 0; // weak
_UNKNOWN g_capPagesToAdd; // weak
int dword_6E69BD10 = 0; // weak
union _SLIST_HEADER *__AtlThunkPool = NULL; // weak
struct _SINGLE_LIST_ENTRY *(__stdcall *__AtlInterlockedPushEntrySList)(union _SLIST_HEADER *, struct _SINGLE_LIST_ENTRY *) = NULL; // weak
struct _SINGLE_LIST_ENTRY *(__stdcall *__AtlInterlockedPopEntrySList)(union _SLIST_HEADER *) = NULL; // weak
__int32 (__stdcall *__AtlInterlockedCompareExchange)(volatile __int32 *, __int32, __int32) = NULL; // weak
int dword_6E69BD24 = 0; // weak
int __app_type = 0; // weak
int _cflush = 0; // weak
int _stdbuf[2] = { 0, 0 }; // weak
int dword_6E69BD54 = 0; // weak
char Dst[25] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
CHAR byte_6E69BD71[143] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_6E69BE75; // weak
int _maxwait; // weak
int _newmode; // weak
int dword_6E69C080; // weak
int dword_6E69C084; // weak
int dword_6E69C088; // weak
int dword_6E69C08C; // weak
int dword_6E69C090; // weak
int dword_6E69C094; // weak
int dword_6E69C098; // weak
int dword_6E69C09C; // weak
int __sbh_cntHeaderList; // weak
LPVOID __sbh_pHeaderList; // idb
int __sbh_threshold; // weak


//----- (6E6415D3) --------------------------------------------------------
HRESULT __stdcall DllCanUnloadNow()
{
  return Addend != 0;
}

//----- (6E6415F6) --------------------------------------------------------
void __cdecl operator delete(void *lpMem)
{
  MemFree(lpMem);
}

//----- (6E64160A) --------------------------------------------------------
void __stdcall MemFree(void *lpMem)
{
  if ( lpMem )
  {
    if ( g_hLocalHeap )
      HeapFree(g_hLocalHeap, 0, lpMem);
  }
}

//----- (6E641649) --------------------------------------------------------
LONG __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 1);
  if ( !v1 && lpMem )
    ATL::CComObjectNoLock<ATL::CComClassFactory>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E64166F) --------------------------------------------------------
void *__cdecl memset(void *Dst, int Val, size_t Size)
{
  size_t v3; // edx@1
  int v4; // eax@2
  void *v5; // edi@4
  int v6; // ecx@5
  unsigned int v7; // ecx@6
  unsigned int v8; // ecx@6
  void *result; // eax@8

  v3 = Size;
  if ( Size )
  {
    LOBYTE(v4) = Val;
    if ( !(_BYTE)Val && Size >= 0x100 )
      JUMPOUT(__sse2_available, 0, sub_6E64261E);
    v5 = Dst;
    if ( Size < 4 )
      goto LABEL_18;
    v6 = -(signed int)Dst & 3;
    if ( v6 )
    {
      v3 = Size - v6;
      do
      {
        *(_BYTE *)v5 = Val;
        v5 = (char *)v5 + 1;
        --v6;
      }
      while ( v6 );
    }
    v4 = 16843009 * (unsigned __int8)Val;
    v7 = v3;
    v3 &= 3u;
    v8 = v7 >> 2;
    if ( !v8 || (memset32(v5, v4, v8), v5 = (char *)v5 + 4 * v8, v3) )
    {
LABEL_18:
      do
      {
        *(_BYTE *)v5 = v4;
        v5 = (char *)v5 + 1;
        --v3;
      }
      while ( v3 );
    }
    result = Dst;
  }
  else
  {
    result = Dst;
  }
  return result;
}
// 6E6991DC: using guessed type int __sse2_available;

//----- (6E641B6D) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(int this, int a2)
{
  bool v2; // cf@1
  int result; // eax@1
  int v4; // ecx@2

  v2 = *(_DWORD *)(this + 24) < 8u;
  result = a2;
  *(_DWORD *)(this + 20) = a2;
  if ( v2 )
    v4 = this + 4;
  else
    v4 = *(_DWORD *)(this + 4);
  *(_WORD *)(v4 + 2 * a2) = 0;
  return result;
}

//----- (6E641B94) --------------------------------------------------------
signed int __thiscall CImplINetCfg::HrCheckForReentrancy(CImplINetCfg *this, unsigned __int32 a2)
{
  bool v2; // zf@2
  signed int result; // eax@4

  if ( a2 & 0x20 )
    v2 = *((_DWORD *)this + 21) == *((_DWORD *)this + 20);
  else
    v2 = *((_DWORD *)this + 20) == 0;
  if ( v2 )
    result = 0;
  else
    result = -2147467259;
  return result;
}

//----- (6E641BB8) --------------------------------------------------------
signed int __thiscall CImplINetCfg::HrLockAndTestForValidInterface(CImplINetCfg *this, unsigned __int32 a2)
{
  CImplINetCfg *v2; // esi@1
  struct _RTL_CRITICAL_SECTION *v3; // edi@1
  signed int v4; // esi@1

  v2 = this;
  v3 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 24);
  EnterCriticalSection((LPCRITICAL_SECTION)this + 1);
  v4 = CImplINetCfg::HrIsValidInterface(v2, a2);
  if ( v4 )
    LeaveCriticalSection(v3);
  return v4;
}

//----- (6E641BEC) --------------------------------------------------------
unsigned int __stdcall CbOfSzAndTerm(const unsigned __int16 *a1)
{
  return 2 * wcslen(a1) + 2;
}

//----- (6E641C1B) --------------------------------------------------------
signed int __stdcall FIsConsideredNetClass(int a1)
{
  signed int result; // eax@1

  result = 1;
  if ( a1 )
  {
    if ( a1 != 1 )
      result = 0;
  }
  return result;
}

//----- (6E641C36) --------------------------------------------------------
int __thiscall CBindingSet::FContainsBindPath(CBindingSet *this, const struct CBindPath *a2)
{
  CBindPath *v2; // esi@1
  CBindPath *v3; // edi@1

  v2 = (CBindPath *)*((_DWORD *)this + 2);
  v3 = (CBindPath *)*((_DWORD *)this + 3);
  while ( 1 )
  {
    if ( v2 == v3 )
      return 0;
    if ( CBindPath::FIsSameBindPathAs(v2, a2) )
      break;
    v2 = (CBindPath *)((char *)v2 + 20);
  }
  return 1;
}

//----- (6E641C58) --------------------------------------------------------
int __cdecl std::fill<CFilteredAdapter * *,CFilteredAdapter *>(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a1; result != a2; result += 4 )
    *(_DWORD *)result = *(_DWORD *)a3;
  return result;
}

//----- (6E641C70) --------------------------------------------------------
void *__cdecl operator new(SIZE_T dwBytes)
{
  return MemAlloc(dwBytes);
}

//----- (6E641CBE) --------------------------------------------------------
unsigned __int32 __stdcall CchToCb(unsigned __int32 a1)
{
  unsigned __int32 result; // eax@2

  if ( a1 > 0x7FFFFFFF )
    result = 0;
  else
    result = 2 * a1;
  return result;
}

//----- (6E641CDC) --------------------------------------------------------
__int32 __stdcall HrFromLastWin32Error()
{
  __int32 result; // eax@1

  result = GetLastError();
  if ( result & 0xE0000000 && (result & 0xE0000000) == -536870912 )
  {
    result = (unsigned __int16)result | 0x800F0000;
  }
  else if ( result > 0 )
  {
    result = (unsigned __int16)result | 0x80070000;
  }
  return result;
}

//----- (6E641D05) --------------------------------------------------------
int __stdcall CchOfSzSafe(const unsigned __int16 *a1)
{
  const unsigned __int16 *v1; // eax@1
  const unsigned __int16 v2; // cx@2
  int result; // eax@3

  v1 = a1;
  if ( a1 )
  {
    do
    {
      v2 = *v1;
      ++v1;
    }
    while ( v2 );
    result = v1 - (a1 + 1);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E641D2F) --------------------------------------------------------
signed int __userpurge sub_6E641D2F@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // edi@1

  v5 = a1;
  v6 = a2;
  result = 0;
  v8 = 0;
  if ( !a2 )
    goto LABEL_12;
  do
  {
    if ( !a5 )
      break;
    if ( !*(_WORD *)v5 )
      break;
    *(_WORD *)a3 = *(_WORD *)v5;
    a3 += 2;
    v5 += 2;
    --v6;
    --a5;
    ++v8;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_12:
    a3 -= 2;
    --v8;
    result = -2147024774;
  }
  *(_WORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = v8;
  return result;
}

//----- (6E641D97) --------------------------------------------------------
__int32 __stdcall HrSetupDiOpenDevRegKey(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, REGSAM samDesired, HKEY *a7)
{
  HKEY v7; // ecx@1
  __int32 result; // eax@2

  v7 = SetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired);
  if ( v7 == (HKEY)-1 )
  {
    result = HrFromLastWin32Error();
    *a7 = 0;
  }
  else
  {
    result = 0;
    *a7 = v7;
  }
  return result;
}

//----- (6E641DCF) --------------------------------------------------------
int __stdcall std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    *(_DWORD *)a1 = *(_DWORD *)a2;
  return result;
}

//----- (6E641DEB) --------------------------------------------------------
int __thiscall CBindPath::FIsSameBindPathAs(CBindPath *this, const struct CBindPath *a2)
{
  CBindPath *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1
  int result; // eax@4

  v2 = this;
  v3 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4));
  v4 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a2 + 4));
  if ( v3 && v4 && v3 == v4 )
    result = memcmp(*((const char **)v2 + 2), *((const char **)a2 + 2), *((_DWORD *)v2 + 3) - *((_DWORD *)v2 + 2)) == 0;
  else
    result = 0;
  return result;
}

//----- (6E641E50) --------------------------------------------------------
int __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::size(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 8) - v1) >> 2;
  else
    result = 0;
  return result;
}

//----- (6E641E68) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Insert_n(int this, void *Src, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@1
  int v6; // eax@2
  int v7; // eax@3
  int v8; // eax@4
  void *v9; // eax@11
  void *v10; // ebx@11
  int v11; // eax@11
  int v12; // eax@11
  int v13; // edi@11
  int v14; // ebx@14
  int v15; // [sp+8h] [bp-4h]@1
  int v16; // [sp+1Ch] [bp+10h]@1
  int v17; // [sp+1Ch] [bp+10h]@4
  int v18; // [sp+1Ch] [bp+10h]@8

  v4 = this;
  v15 = *(_DWORD *)a4;
  result = std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(this);
  v16 = result;
  if ( a3 )
  {
    v6 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v4);
    if ( 0x3FFFFFFF - v6 < (unsigned int)a3 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v7 = a3 + v6;
    if ( v16 < (unsigned int)v7 )
    {
      if ( 0x3FFFFFFF - ((unsigned int)v16 >> 1) < v16 )
        v18 = 0;
      else
        v18 = ((unsigned int)v16 >> 1) + v16;
      if ( v18 < (unsigned int)v7 )
        v18 = v7;
      v9 = std::_Allocate<unsigned short const *>(v18, 0);
      v10 = v9;
      v11 = (int)std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
                   *(void **)(v4 + 4),
                   (int)Src,
                   v9,
                   v4);
      v12 = std::vector<unsigned short const *,std::nc_allocator<unsigned short const *>>::_Ufill(
              v4,
              v11,
              a3,
              (int)&v15);
      std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
        Src,
        *(_DWORD *)(v4 + 8),
        (void *)v12,
        v4);
      v13 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v4) + a3;
      if ( *(_DWORD *)(v4 + 4) )
        operator delete(*(void **)(v4 + 4));
      *(_DWORD *)(v4 + 12) = (char *)v10 + 4 * v18;
      result = (int)((char *)v10 + 4 * v13);
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)(v4 + 4) = v10;
    }
    else
    {
      v8 = *(_DWORD *)(v4 + 8);
      v17 = *(_DWORD *)(v4 + 8);
      if ( (*(_DWORD *)(v4 + 8) - (signed int)Src) >> 2 >= (unsigned int)a3 )
      {
        v14 = v8 - 4 * a3;
        *(_DWORD *)(v4 + 8) = std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
                                (void *)(v8 - 4 * a3),
                                v8,
                                (void *)v8,
                                v4);
        std::copy_backward<CComponent * *,CComponent * *>(Src, v14, v17);
        result = std::fill<CFilteredAdapter * *,CFilteredAdapter *>((int)Src, (int)((char *)Src + 4 * a3), (int)&v15);
      }
      else
      {
        std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
          Src,
          v8,
          (char *)Src + 4 * a3,
          v4);
        std::vector<unsigned short const *,std::nc_allocator<unsigned short const *>>::_Ufill(
          v4,
          *(_DWORD *)(v4 + 8),
          a3 - ((*(_DWORD *)(v4 + 8) - (signed int)Src) >> 2),
          (int)&v15);
        *(_DWORD *)(v4 + 8) += 4 * a3;
        result = std::fill<CFilteredAdapter * *,CFilteredAdapter *>((int)Src, *(_DWORD *)(v4 + 8) - 4 * a3, (int)&v15);
      }
    }
  }
  return result;
}

//----- (6E641F8D) --------------------------------------------------------
char *__stdcall std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(void *Src, int a2, void *Dst, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<CFilterMapEntry * *,CFilterMapEntry * *,std::nc_allocator<CFilterMapEntry *>>(
           Src,
           a2,
           Dst,
           a4,
           a4,
           v5);
}

//----- (6E641FBB) --------------------------------------------------------
char *__stdcall std::_Uninit_copy<CFilterMapEntry * *,CFilterMapEntry * *,std::nc_allocator<CFilterMapEntry *>>(void *Src, int a2, void *Dst, int a4, int a5, int a6)
{
  if ( (a2 - (signed int)Src) >> 2 )
    memmove_s(Dst, 4 * ((a2 - (signed int)Src) >> 2), Src, 4 * ((a2 - (signed int)Src) >> 2));
  return (char *)Dst + 4 * ((a2 - (signed int)Src) >> 2);
}

//----- (6E641FF5) --------------------------------------------------------
errno_t __cdecl memmove_s(void *Dst, rsize_t DstSize, const void *Src, rsize_t MaxCount)
{
  errno_t v5; // esi@8

  if ( !MaxCount )
    return 0;
  if ( Dst && Src )
  {
    if ( DstSize >= MaxCount )
    {
      memmove(Dst, Src, MaxCount);
      return 0;
    }
    *_errno() = 34;
    v5 = 34;
  }
  else
  {
    v5 = 22;
    *_errno() = 22;
  }
  _invalid_parameter(0, 0, 0, 0, 0);
  return v5;
}

//----- (6E64203A) --------------------------------------------------------
void *__stdcall std::_Destroy<CBindPath>(void *lpMem)
{
  return CBindPath::`scalar deleting destructor'(lpMem, 0);
}

//----- (6E642052) --------------------------------------------------------
void *__thiscall CBindPath::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)lpMem + 4));
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E642078) --------------------------------------------------------
void __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(int this)
{
  int v1; // esi@1

  v1 = this;
  if ( *(_DWORD *)(this + 4) )
    operator delete(*(void **)(this + 4));
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
}

//----- (6E6420A0) --------------------------------------------------------
int __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 12) - v1) >> 2;
  else
    result = 0;
  return result;
}

//----- (6E6420B8) --------------------------------------------------------
__int32 __thiscall CComponentList::HrInsertComponent(CComponentList *this, const struct CComponent *a2, unsigned __int32 a3)
{
  CComponentList *v3; // esi@1
  const struct CComponent *v4; // edi@1
  void *v5; // ecx@2
  void *i; // eax@2
  __int32 result; // eax@3

  v3 = this;
  v4 = a2;
  if ( CComponentList::FComponentInList(this, a2) )
  {
    result = 0;
  }
  else
  {
    v5 = (void *)*((_DWORD *)v3 + 3);
    i = (void *)*((_DWORD *)v3 + 3);
    if ( a3 & 0x1000 )
    {
      for ( i = (void *)*((_DWORD *)v3 + 2); i != v5; i = (char *)i + 4 )
      {
        if ( *((_DWORD *)v4 + 4) >= *(_DWORD *)(*(_DWORD *)i + 16) )
          break;
      }
    }
    a2 = v4;
    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert(
      (int)((char *)v3 + 4),
      (int)&a3,
      i,
      (int)&a2);
    a2 = 0;
    result = 0;
  }
  return result;
}

//----- (6E642115) --------------------------------------------------------
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert(int this, int a2, void *Src, int a4)
{
  int v4; // edi@1
  signed int v5; // esi@2
  int result; // eax@3

  v4 = this;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size(this) )
    v5 = (signed int)((char *)Src - *(_DWORD *)(v4 + 4)) >> 2;
  else
    v5 = 0;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Insert_n(v4, Src, 1, a4);
  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4) + 4 * v5;
  return result;
}

//----- (6E642159) --------------------------------------------------------
void (__cdecl *__stdcall std::_Construct<CBindPath,CBindPath>(int a1, int a2))(int a1, int a2)
{
  void (__cdecl *result)(int, int); // eax@1

  result = sub_6E6930D4;
  if ( a1 )
    result = (void (__cdecl *)(int, int))CBindPath::CBindPath(a1, a2);
  return result;
}

//----- (6E642188) --------------------------------------------------------
int __thiscall CBindPath::CBindPath(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::vector<CComponent *,std::nc_allocator<CComponent *>>(
    (void *)(this + 4),
    a2 != 0 ? a2 + 4 : 0);
  return v2;
}

//----- (6E6421B3) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::vector<CComponent *,std::nc_allocator<CComponent *>>(void *this, int a2)
{
  int v2; // edi@1
  int v3; // eax@1

  v2 = (int)this;
  v3 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2);
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(v2, v3) )
    *(_DWORD *)(v2 + 8) = std::_Uninitialized_copy<std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>,CComponent * *,std::nc_allocator<CComponent *>>(
                            *(_DWORD *)(a2 + 4),
                            *(_DWORD *)(a2 + 8),
                            *(_DWORD *)(v2 + 4),
                            v2);
  return v2;
}

//----- (6E642202) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>,CComponent * *,std::nc_allocator<CComponent *>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<std::_Vector_iterator<unsigned short const *,std::nc_allocator<unsigned short const *>>,unsigned short const * *,std::nc_allocator<unsigned short const *>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E642230) --------------------------------------------------------
int __stdcall std::_Uninit_copy<std::_Vector_iterator<unsigned short const *,std::nc_allocator<unsigned short const *>>,unsigned short const * *,std::nc_allocator<unsigned short const *>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  while ( a1 != a2 )
  {
    std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(
      a3,
      a1);
    a3 += 4;
    a1 += 4;
  }
  return a3;
}

//----- (6E642260) --------------------------------------------------------
void *__thiscall CComponentList::CComponentList(void *this)
{
  void *v1; // esi@1

  v1 = this;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)((char *)this + 4), 0);
  return v1;
}

//----- (6E642278) --------------------------------------------------------
char __thiscall std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  void *v4; // eax@5

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  if ( a2 )
  {
    if ( (unsigned int)a2 > 0x3FFFFFFF )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v4 = std::_Allocate<unsigned short const *>(a2, 0);
    *(_DWORD *)(v2 + 4) = v4;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 12) = (char *)v4 + 4 * a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E6422C3) --------------------------------------------------------
void *__stdcall std::_Allocate<unsigned short const *>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(4 * v2);
}

//----- (6E6422FA) --------------------------------------------------------
void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
{
  const void *v3; // esi@1
  void *v4; // edi@1
  size_t v5; // ecx@5
  void *result; // eax@9
  char *v7; // edi@20
  char *v8; // esi@20
  size_t v9; // ecx@34

  v3 = Src;
  v4 = Dst;
  if ( Dst > Src && Dst < (char *)Src + Size )
  {
    v8 = (char *)Src + Size - 4;
    v7 = (char *)Dst + Size - 4;
    if ( (unsigned __int8)v7 & 3 )
    {
      if ( Size >= 4 )
        JUMPOUT(__CS__, *(_DWORD *)((char *)&loc_6E6424BE + 4 * ((unsigned __int8)v7 & 3) + 6));
      switch ( Size )
      {
        case 0u:
LABEL_36:
          result = Dst;
          break;
        case 1u:
LABEL_26:
          v7[3] = v8[3];
          result = Dst;
          break;
        case 2u:
LABEL_27:
          v7[3] = v8[3];
          v7[2] = v8[2];
          result = Dst;
          break;
        case 3u:
          goto LABEL_28;
      }
    }
    else
    {
      v9 = Size >> 2;
      if ( Size >> 2 < 8 )
        JUMPOUT(*(_DWORD *)sub_6E651B11);
      qmemcpy(v7, v8, 4 * v9);
      v8 += 4 * v9;
      v7 += 4 * v9;
      switch ( Size & 3 )
      {
        case 0u:
          goto LABEL_36;
        case 1u:
          goto LABEL_26;
        case 2u:
          goto LABEL_27;
        case 3u:
          break;
      }
LABEL_28:
      v7[3] = v8[3];
      v7[2] = v8[2];
      v7[1] = v8[1];
      result = Dst;
    }
  }
  else if ( Size >= 0x100
         && __sse2_available
         && (v3 = Src, v4 = Dst, ((unsigned __int8)Dst & 0xF) == ((unsigned __int8)Src & 0xF)) )
  {
    result = _VEC_memcpy_0(Dst, Src, Size);
  }
  else
  {
    if ( (unsigned __int8)v4 & 3 )
    {
      if ( Size >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)&loc_6E642398 + ((unsigned __int8)v4 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)&loc_6E642468 + Size - 4));
    }
    v5 = Size >> 2;
    if ( Size >> 2 >= 8 )
    {
      qmemcpy(v4, v3, 4 * v5);
      v3 = (char *)v3 + 4 * v5;
      v4 = (char *)v4 + 4 * v5;
    }
    else
    {
      switch ( v5 )
      {
        case 0u:
          goto LABEL_8;
        case 1u:
          goto LABEL_7;
        case 2u:
          goto LABEL_22;
        case 3u:
          goto LABEL_21;
        case 4u:
          goto LABEL_30;
        case 5u:
          goto LABEL_32;
        case 6u:
          break;
        case 7u:
          *((_DWORD *)v4 + v5 - 7) = *((_DWORD *)v3 + v5 - 7);
          break;
      }
      *((_DWORD *)v4 + v5 - 6) = *((_DWORD *)v3 + v5 - 6);
LABEL_32:
      *((_DWORD *)v4 + v5 - 5) = *((_DWORD *)v3 + v5 - 5);
LABEL_30:
      *((_DWORD *)v4 + v5 - 4) = *((_DWORD *)v3 + v5 - 4);
LABEL_21:
      *((_DWORD *)v4 + v5 - 3) = *((_DWORD *)v3 + v5 - 3);
LABEL_22:
      *((_DWORD *)v4 + v5 - 2) = *((_DWORD *)v3 + v5 - 2);
LABEL_7:
      *((_DWORD *)v4 + v5 - 1) = *((_DWORD *)v3 + v5 - 1);
      v3 = (char *)v3 + 4 * v5;
      v4 = (char *)v4 + 4 * v5;
    }
LABEL_8:
    switch ( Size & 3 )
    {
      case 0u:
        result = Dst;
        break;
      case 1u:
        *(_BYTE *)v4 = *(_BYTE *)v3;
        result = Dst;
        break;
      case 2u:
        *(_BYTE *)v4 = *(_BYTE *)v3;
        *((_BYTE *)v4 + 1) = *((_BYTE *)v3 + 1);
        result = Dst;
        break;
      case 3u:
        *(_BYTE *)v4 = *(_BYTE *)v3;
        *((_BYTE *)v4 + 1) = *((_BYTE *)v3 + 1);
        *((_BYTE *)v4 + 2) = *((_BYTE *)v3 + 2);
        result = Dst;
        break;
    }
  }
  return result;
}
// 6E6991DC: using guessed type int __sse2_available;

//----- (6E64261E) --------------------------------------------------------
int __cdecl sub_6E64261E(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // edx@2
  unsigned int v6; // [sp+4h] [bp-Ch]@2

  result = a1;
  v4 = (unsigned __int8)((char)a1 % -16);
  if ( (char)a1 % -16 )
  {
    memset((void *)a1, 0, 16 - v4);
    sub_6E64261E(16 - v4 + a1, 0, a3 - (16 - v4));
    result = a1;
  }
  else
  {
    v5 = a3 & 0x7F;
    v6 = v5;
    if ( a3 != v5 )
    {
      sub_6E642684(a1, a3 - v5);
      result = a1;
      v5 = v6;
    }
    if ( v5 )
    {
      memset((void *)(a3 + result - v5), 0, v6);
      result = a1;
    }
  }
  return result;
}

//----- (6E642684) --------------------------------------------------------
void __cdecl sub_6E642684(int a1, unsigned int a2)
{
  int v2; // edi@1
  unsigned int v3; // ecx@1

  v2 = a1;
  v3 = a2 >> 7;
  do
  {
    _mm_store_si128((__m128i *)v2, 0i64);
    _mm_store_si128((__m128i *)(v2 + 16), 0i64);
    _mm_store_si128((__m128i *)(v2 + 32), 0i64);
    _mm_store_si128((__m128i *)(v2 + 48), 0i64);
    _mm_store_si128((__m128i *)(v2 + 64), 0i64);
    _mm_store_si128((__m128i *)(v2 + 80), 0i64);
    _mm_store_si128((__m128i *)(v2 + 96), 0i64);
    _mm_store_si128((__m128i *)(v2 + 112), 0i64);
    v2 += 128;
    --v3;
  }
  while ( v3 );
}

//----- (6E6426D8) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 8) - v1) / 20;
  else
    result = 0;
  return result;
}

//----- (6E6426F3) --------------------------------------------------------
void __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy(int this)
{
  int v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  v2 = *(void **)(this + 4);
  if ( v2 )
  {
    std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(v2, *(_DWORD *)(this + 8), this);
    operator delete(*(void **)(v1 + 4));
  }
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
}

//----- (6E642727) --------------------------------------------------------
void *__stdcall std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(void *lpMem, int a2, int a3)
{
  return std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(lpMem, a2, a3, a3);
}

//----- (6E642746) --------------------------------------------------------
void *__stdcall std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(void *lpMem, int a2, int a3, int a4)
{
  void *i; // esi@1
  void *result; // eax@3

  for ( i = lpMem; i != (void *)a2; i = (char *)i + 20 )
    result = std::_Destroy<CBindPath>(i);
  return result;
}

//----- (6E642769) --------------------------------------------------------
__int32 __thiscall CBindPath::HrAppendComponent(CBindPath *this, const struct CComponent *a2)
{
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back((int)((char *)this + 4), (int)&a2);
  return 0;
}

//----- (6E64279F) --------------------------------------------------------
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back(int this, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int result; // eax@2

  v2 = this;
  v3 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(this);
  if ( v3 >= (unsigned int)std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(v2) )
  {
    result = std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert(
               v2,
               (int)&a2,
               *(void **)(v2 + 8),
               a2);
  }
  else
  {
    result = std::vector<unsigned short const *,std::nc_allocator<unsigned short const *>>::_Ufill(
               v2,
               *(_DWORD *)(v2 + 8),
               1,
               a2);
    *(_DWORD *)(v2 + 8) = result;
  }
  return result;
}

//----- (6E6427E4) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Ufill(int this, int a2, int a3, int a4)
{
  stdext::unchecked_uninitialized_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(
    a2,
    a3,
    a4,
    this);
  return a2 + 20 * a3;
}

//----- (6E64280A) --------------------------------------------------------
void (__cdecl *__stdcall stdext::unchecked_uninitialized_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4))(int a1, int a2)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(a1, a2, a3, a4, a4, v5);
}

//----- (6E642838) --------------------------------------------------------
void (__cdecl *__stdcall std::_Uninit_fill_n<CBindPath *,unsigned int,CBindPath,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6))(int a1, int a2)
{
  void (__cdecl *result)(int, int); // eax@1

  result = (void (__cdecl *)(int, int))a1;
  while ( a2 )
  {
    result = std::_Construct<CBindPath,CBindPath>(a1, a3);
    --a2;
    a1 += 20;
  }
  return result;
}

//----- (6E642881) --------------------------------------------------------
signed int __thiscall CImplINetCfg::HrIsValidInterface(CImplINetCfg *this, unsigned __int32 a2)
{
  char v2; // dl@1
  CImplINetCfg *v3; // esi@1
  int v4; // esi@7
  signed int result; // eax@8
  int v6; // eax@16

  v2 = a2;
  v3 = this;
  if ( !(a2 & 0x10) || (result = CImplINetCfg::HrCheckForReentrancy(this, a2)) == 0 )
  {
    if ( v2 & 1 && *((_DWORD *)v3 + 12) )
      return -2147180512;
    if ( !(v2 & 1) && !*((_DWORD *)v3 + 12) )
      return -2147180511;
    if ( !(v2 & 2) )
      goto LABEL_24;
    if ( !*((_DWORD *)v3 + 19) )
      return -2147180508;
    v6 = *((_DWORD *)v3 + 12);
    if ( *(_BYTE *)(v6 + 296) || v2 < 0 || (result = CModifyContext::HrPrepare((CModifyContext *)(v6 + 72))) == 0 )
    {
LABEL_24:
      if ( a2 & 0x40 || (v4 = *((_DWORD *)v3 + 12)) == 0 || (result = *(_DWORD *)(v4 + 292)) == 0 )
        result = 0;
    }
  }
  return result;
}

//----- (6E6428D5) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::capacity(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 12) - v1) / 20;
  else
    result = 0;
  return result;
}

//----- (6E6428F0) --------------------------------------------------------
__int32 __thiscall CBindingSet::HrAddBindPath(CBindingSet *this, const struct CBindPath *a2, unsigned __int32 a3)
{
  CBindingSet *v3; // esi@1
  int v4; // eax@2
  __int32 result; // eax@4

  v3 = this;
  if ( CBindingSet::FContainsBindPath(this, a2) )
  {
    result = 0;
  }
  else
  {
    v4 = *((_DWORD *)v3 + 2);
    if ( a3 & 0x400 )
      v4 = *((_DWORD *)v3 + 3);
    std::vector<CBindPath,std::nc_allocator<CBindPath>>::insert((int)((char *)v3 + 4), (int)&a2, v4, (int)a2);
    a2 = 0;
    result = 0;
  }
  return result;
}

//----- (6E642945) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::insert(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@3

  v4 = this;
  if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(this) )
    v5 = (a3 - *(_DWORD *)(v4 + 4)) / 20;
  else
    v5 = 0;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Insert_n((void *)v4, a3, 1, a4);
  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4) + 20 * v5;
  return result;
}

//----- (6E6429B9) --------------------------------------------------------
void __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Insert_n(void *this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ebx@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // ebx@5
  int v10; // eax@8
  int v11; // ST08_4@8
  int v12; // eax@8
  int v13; // edi@8
  void *v14; // eax@8
  int v15; // ecx@12
  int v16; // eax@13
  int v17; // esi@13
  int v18; // ebx@16
  char v19; // [sp+Ch] [bp-28h]@1
  char v20; // [sp+10h] [bp-24h]@11
  void *v21; // [sp+20h] [bp-14h]@1
  int v22; // [sp+30h] [bp-4h]@1
  int v23; // [sp+40h] [bp+Ch]@8
  int v24; // [sp+44h] [bp+10h]@8
  void *v25; // [sp+44h] [bp+10h]@12

  v4 = (int)this;
  v21 = this;
  CBindPath::CBindPath((int)&v19, a4);
  v22 = 0;
  v5 = a3;
  v6 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::capacity(v4);
  if ( a3 )
  {
    v7 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v4);
    if ( 214748364 - v7 < (unsigned int)a3 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v8 = a3 + v7;
    if ( v6 >= (unsigned int)v8 )
    {
      v15 = *(_DWORD *)(v4 + 8);
      v25 = *(void **)(v4 + 8);
      if ( (*(_DWORD *)(v4 + 8) - a2) / 20 >= (unsigned int)a3 )
      {
        v18 = v15 - 20 * a3;
        *(_DWORD *)(v4 + 8) = std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(
                                v15 - 20 * a3,
                                v15,
                                v15,
                                v4);
        std::copy_backward<CBindPath *,CBindPath *>(a2, v18, v25);
        std::fill<CBindPath *,CBindPath>((void *)a2, (void *)(a2 + 20 * a3), (int)&v19);
      }
      else
      {
        std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(a2, v15, 20 * a3 + a2, v4);
        v16 = (*(_DWORD *)(v4 + 8) - a2) / 20;
        LOBYTE(v22) = 3;
        std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Ufill(v4, *(_DWORD *)(v4 + 8), a3 - v16, (int)&v19);
        *(_DWORD *)(v4 + 8) += 20 * a3;
        v17 = *(_DWORD *)(v4 + 8);
        v22 = 0;
        std::fill<CBindPath *,CBindPath>((void *)a2, (void *)(v17 - 20 * a3), (int)&v19);
      }
    }
    else
    {
      if ( 214748364 - ((unsigned int)v6 >> 1) < v6 )
        v9 = 0;
      else
        v9 = ((unsigned int)v6 >> 1) + v6;
      if ( v9 < (unsigned int)v8 )
        v9 = v8;
      v10 = (int)std::_Allocate<CBindPath>(v9, 0);
      v24 = v10;
      v11 = *(_DWORD *)(v4 + 4);
      LOBYTE(v22) = 1;
      v12 = std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(v11, a2, v10, v4);
      v23 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Ufill(v4, v12, a3, (int)&v19);
      std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(a2, *(_DWORD *)(v4 + 8), v23, v4);
      v13 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v4) + v5;
      v14 = *(void **)(v4 + 4);
      if ( v14 )
      {
        std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(v14, *(_DWORD *)(v4 + 8), v4);
        operator delete(*(void **)(v4 + 4));
      }
      *(_DWORD *)(v4 + 12) = v24 + 20 * v9;
      *(_DWORD *)(v4 + 8) = v24 + 20 * v13;
      *(_DWORD *)(v4 + 4) = v24;
    }
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v20);
}

//----- (6E642AB6) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(a1, a2, a3, a4, a4, v5);
}

//----- (6E642AE4) --------------------------------------------------------
int __stdcall std::_Uninit_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int i; // esi@1

  for ( i = a1; i != a2; i += 20 )
  {
    std::_Construct<CBindPath,CBindPath>(a3, i);
    a3 += 20;
  }
  return a3;
}

//----- (6E642B53) --------------------------------------------------------
__int32 __thiscall HrRegGetTypeWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int32 a4, unsigned __int8 **a5, unsigned __int32 *a6)
{
  __int32 result; // eax@1
  unsigned __int32 v7; // [sp+0h] [bp-4h]@1

  v7 = this;
  result = HrRegGetValueWithAlloc(a2, lpMem, (unsigned __int32 *)&a2, (unsigned __int8 **)&lpMem, &v7);
  if ( !result )
  {
    if ( a2 == (HKEY)a4 )
    {
      *a5 = (unsigned __int8 *)lpMem;
      if ( a6 )
        *a6 = v7;
      return result;
    }
    MemFree((void *)lpMem);
    result = -2147023092;
  }
  *a5 = 0;
  if ( a6 )
    *a6 = 0;
  return result;
}

//----- (6E642BA1) --------------------------------------------------------
__int32 __stdcall HrRegGetValueWithAlloc(HKEY a1, const unsigned __int16 *a2, unsigned __int32 *a3, unsigned __int8 **a4, unsigned __int32 *a5)
{
  unsigned __int8 *v5; // ebx@6
  signed int v7; // [sp+18h] [bp-110h]@1
  size_t Size; // [sp+1Ch] [bp-10Ch]@3
  __int32 v9; // [sp+20h] [bp-108h]@3
  char Src; // [sp+24h] [bp-104h]@3

  v7 = 0;
  *a4 = 0;
  if ( a5 )
    *a5 = 0;
  Size = 256;
  v9 = HrRegGetValue(a1, a2, a3, (unsigned __int8 *)&Src, (unsigned __int32 *)&Size);
  if ( v9 == -2147024662 )
  {
    v9 = 0;
    v7 = 1;
  }
  if ( !v9 )
  {
    v5 = (unsigned __int8 *)MemAlloc(Size);
    if ( v5 )
    {
      if ( v7 )
        v9 = HrRegGetValue(a1, a2, a3, v5, (unsigned __int32 *)&Size);
      else
        memcpy(v5, &Src, Size);
      if ( v9 )
      {
        MemFree(v5);
      }
      else
      {
        *a4 = v5;
        if ( a5 )
          *a5 = Size;
      }
    }
    else
    {
      v9 = -2147024882;
    }
  }
  return v9;
}

//----- (6E642CAF) --------------------------------------------------------
__int32 __stdcall HrRegGetValue(HKEY hkey, const unsigned __int16 *lpValue, unsigned __int32 *pdwType, unsigned __int8 *pvData, unsigned __int32 *pcbData)
{
  __int32 result; // eax@1

  result = RegGetValueW(hkey, 0, lpValue, 0x1000FFFFu, pdwType, pvData, pcbData);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E642D0D) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 5);
  if ( !v1 && lpMem )
    ATL::CComObject<CImplINetCfg>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E642D75) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 4);
  if ( !v1 && lpMem )
    ATL::CComObject<CImplINetCfgComponent>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E642DA0) --------------------------------------------------------
void __stdcall ReleaseIUnknownArray(unsigned __int32 a1, struct IUnknown **a2)
{
  struct IUnknown **v2; // esi@2

  if ( a1 )
  {
    v2 = a2;
    do
    {
      --a1;
      ReleaseObj(*v2);
      ++v2;
    }
    while ( a1 );
  }
}

//----- (6E642DCC) --------------------------------------------------------
unsigned __int32 __stdcall ReleaseObj(struct IUnknown *a1)
{
  unsigned __int32 result; // eax@2

  if ( a1 )
    result = a1->lpVtbl->Release(a1);
  else
    result = 0;
  return result;
}

//----- (6E642DEB) --------------------------------------------------------
void *__stdcall std::_Allocate<CBindPath>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(20 * v2);
}

//----- (6E642E14) --------------------------------------------------------
void *__cdecl operator new(SIZE_T dwBytes)
{
  void *result; // eax@1
  char v2; // [sp+0h] [bp-Ch]@2

  result = MemAlloc(dwBytes);
  if ( !result )
  {
    std::bad_alloc::bad_alloc((std::bad_alloc *)&v2);
    _CxxThrowException(&v2, &_TI2_AVbad_alloc_std__);
  }
  return result;
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E6961E8: using guessed type int _TI2_AVbad_alloc_std__;

//----- (6E642E33) --------------------------------------------------------
void *__stdcall MemAlloc(SIZE_T dwBytes)
{
  void *result; // eax@1

  result = GetHeap();
  if ( result )
    result = HeapAlloc(result, 0, dwBytes);
  return result;
}

//----- (6E642E56) --------------------------------------------------------
void *__stdcall GetHeap()
{
  void *result; // eax@1

  result = g_hLocalHeap;
  if ( !g_hLocalHeap )
  {
    result = HeapCreate((DWORD)g_hLocalHeap, 0x10000u, (SIZE_T)g_hLocalHeap);
    g_hLocalHeap = result;
  }
  return result;
}

//----- (6E642E69) --------------------------------------------------------
__int32 __stdcall HrOpenNetworkKey(REGSAM samDesired, PHKEY phkResult)
{
  return HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Network", samDesired, phkResult);
}

//----- (6E642E8C) --------------------------------------------------------
__int32 __stdcall HrRegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, PHKEY phkResult)
{
  __int32 result; // eax@1
  bool v5; // sf@1

  result = RegOpenKeyExW(hKey, lpSubKey, 0, samDesired, phkResult);
  v5 = result < 0;
  if ( result > 0 )
  {
    result = (unsigned __int16)result | 0x80070000;
    v5 = result < 0;
  }
  if ( v5 )
    *phkResult = 0;
  return result;
}

//----- (6E642EBF) --------------------------------------------------------
BOOL __thiscall CComponentList::FComponentInList(CComponentList *this, const struct CComponent *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  v2 = *((_DWORD *)this + 3);
  return *(_DWORD *)std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(
                      (int)&v4,
                      *((_DWORD *)this + 2),
                      v2,
                      (int)&a2) != v2;
}

//----- (6E642EEE) --------------------------------------------------------
int __stdcall std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(int a1, int a2, int a3, int a4)
{
  int i; // ecx@1
  int result; // eax@4

  for ( i = a2; i != a3; i += 4 )
  {
    if ( *(_DWORD *)i == *(_DWORD *)a4 )
      break;
  }
  result = a1;
  *(_DWORD *)a1 = i;
  return result;
}

//----- (6E642F1D) --------------------------------------------------------
int __thiscall std::vector<unsigned short const *,std::nc_allocator<unsigned short const *>>::_Ufill(int this, int a2, int a3, int a4)
{
  stdext::unchecked_uninitialized_fill_n<CComponent * *,unsigned int,CComponent *,std::nc_allocator<CComponent *>>(
    a2,
    a3,
    a4,
    this);
  return a2 + 4 * a3;
}

//----- (6E642F43) --------------------------------------------------------
void __stdcall stdext::unchecked_uninitialized_fill_n<CComponent * *,unsigned int,CComponent *,std::nc_allocator<CComponent *>>(int a1, int a2, int a3, int a4)
{
  stdext::unchecked_fill_n<CFilterDevice * *,unsigned int,CFilterDevice *>(a1, a2, a3);
}

//----- (6E642F62) --------------------------------------------------------
void __cdecl stdext::unchecked_fill_n<CFilterDevice * *,unsigned int,CFilterDevice *>(int a1, int a2, int a3)
{
  std::_Fill_n<CFilterMapEntry * *,unsigned int,CFilterMapEntry *>(a1, a2, a3);
}

//----- (6E642F8B) --------------------------------------------------------
void __cdecl std::_Fill_n<CFilterMapEntry * *,unsigned int,CFilterMapEntry *>(int a1, int a2, int a3)
{
  int v3; // eax@2

  if ( a2 )
  {
    v3 = a1;
    do
    {
      --a2;
      *(_DWORD *)v3 = *(_DWORD *)a3;
      v3 += 4;
    }
    while ( a2 );
  }
}

//----- (6E642FB3) --------------------------------------------------------
signed int __stdcall HrCoTaskMemAllocAndDupSz(const unsigned __int16 *a1, unsigned __int16 **a2, unsigned __int32 a3)
{
  int v3; // eax@1

  v3 = CchOfSzSafe(a1);
  return HrCoTaskMemAllocAndDupSzLen(a1, v3, a2, a3);
}

//----- (6E642FD8) --------------------------------------------------------
signed int __stdcall HrCoTaskMemAllocAndDupSzLen(const unsigned __int16 *a1, unsigned __int32 a2, unsigned __int16 **a3, unsigned __int32 a4)
{
  unsigned __int32 v4; // eax@1
  unsigned int v5; // eax@2
  unsigned int v6; // edi@2
  unsigned int v7; // esi@2
  signed int v8; // ebx@2
  unsigned __int16 *v9; // eax@3

  v4 = a2;
  if ( a2 >= a4 )
    v4 = a4;
  v5 = CchToCb(v4);
  v6 = v5;
  v7 = v5 + 2;
  v8 = -2147024882;
  if ( v5 + 2 <= v5 )
  {
    *a3 = 0;
  }
  else
  {
    v9 = (unsigned __int16 *)CoTaskMemAlloc(v5 + 2);
    *a3 = v9;
    if ( v9 )
    {
      v8 = 0;
      StringCbCopyNW(v9, v7, a1, v6);
    }
  }
  return v8;
}

//----- (6E643033) --------------------------------------------------------
signed int __stdcall StringCbCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // ecx@1
  signed int result; // eax@1
  unsigned __int16 *v6; // eax@5
  signed int v7; // ebx@5
  unsigned int v8; // esi@5
  unsigned int v9; // edi@6
  unsigned __int16 v10; // cx@8

  v4 = a2 >> 1;
  result = 0;
  if ( !(a2 >> 1) || v4 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( a4 >> 1 > 0x7FFFFFFE )
    {
      result = -2147024809;
      *a1 = 0;
    }
    else
    {
      v6 = a1;
      v7 = 0;
      v8 = a2 >> 1;
      if ( !v4 )
        goto LABEL_18;
      v9 = (a4 >> 1) - v4;
      do
      {
        if ( !(v9 + v8) )
          break;
        v10 = *(unsigned __int16 *)((char *)v6 + (char *)a3 - (char *)a1);
        if ( !v10 )
          break;
        *v6 = v10;
        ++v6;
        --v8;
      }
      while ( v8 );
      if ( !v8 )
      {
LABEL_18:
        --v6;
        v7 = -2147024774;
      }
      *v6 = 0;
      result = v7;
    }
  }
  return result;
}

//----- (6E6430B5) --------------------------------------------------------
void __stdcall SetupDiDestroyDeviceInfoListSafe(void *DeviceInfoSet)
{
  if ( IsValidHandle(DeviceInfoSet) )
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
}

//----- (6E6430D6) --------------------------------------------------------
int __stdcall IsValidHandle(void *a1)
{
  int result; // eax@1

  result = 0;
  if ( a1 )
  {
    if ( a1 != (void *)-1 )
      result = 1;
  }
  return result;
}

//----- (6E6430F2) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::Release((void *)(a1 - 4));
}

//----- (6E643228) --------------------------------------------------------
BOOL __stdcall ATL::InlineIsEqualUnknown(const struct _GUID *a1)
{
  return !a1->Data1
      && !*(_DWORD *)&a1->Data2
      && *(_DWORD *)&a1->Data4[0] == 192
      && *(_DWORD *)&a1->Data4[4] == 1174405120;
}

//----- (6E64325F) --------------------------------------------------------
int __stdcall ATL::CComClassFactory::CreateInstance(ATL::CComClassFactory *this, struct IUnknown *a2, const struct _GUID *a3, void **a4)
{
  int result; // eax@1

  result = -2147467261;
  if ( a4 )
  {
    *a4 = 0;
    if ( !a2 || ATL::InlineIsEqualUnknown(a3) )
      result = (*(int (__stdcall **)(struct IUnknown *, const struct _GUID *, void **))((int (__stdcall **)(_DWORD, _DWORD, _DWORD))this
                                                                                      + 8))(
                 a2,
                 a3,
                 a4);
    else
      result = -2147221232;
  }
  return result;
}

//----- (6E643295) --------------------------------------------------------
void *__stdcall std::_Allocate<CStackEntry>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(8 * v2);
}

//----- (6E6432BE) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)(this + 24) = 7;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
    this,
    0);
  return v1;
}

//----- (6E6432DA) --------------------------------------------------------
char __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  void *v4; // eax@5

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  if ( a2 )
  {
    if ( (unsigned int)a2 > 0x1FFFFFFF )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v4 = std::_Allocate<CStackEntry>(a2, 0);
    *(_DWORD *)(v2 + 4) = v4;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 12) = (char *)v4 + 8 * a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E643306) --------------------------------------------------------
signed int __thiscall CImplINetCfgHolder::HrLockAndTestForValidInterface(CImplINetCfgHolder *this, unsigned __int32 a2)
{
  CImplINetCfgHolder *v2; // esi@1
  signed int v3; // edi@1

  v2 = this;
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 2) + 24));
  v3 = CImplINetCfg::HrIsValidInterface(*((CImplINetCfg **)v2 + 2), a2);
  if ( v3 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v2 + 2) + 24));
  return v3;
}

//----- (6E64333E) --------------------------------------------------------
unsigned __int32 __stdcall WaitForConfigLoadSaveMutex()
{
  DWORD v0; // eax@2
  MSG Msg; // [sp+8h] [bp-28h]@8
  SP_LOG_TOKEN LogToken; // [sp+24h] [bp-Ch]@1
  DWORD v4; // [sp+2Ch] [bp-4h]@2

  LogToken = SetupGetThreadLogToken();
  if ( g_ConfigLoadSaveMutex
    || (HrCreateMutexWithWorldAccess(L"Global\\d3b1bbc7-c020-4056-9ded-7c6f40b5a2fc", 0, 0, &g_ConfigLoadSaveMutex),
        g_ConfigLoadSaveMutex) )
  {
    while ( 1 )
    {
      v0 = MsgWaitForMultipleObjects(1u, &g_ConfigLoadSaveMutex, 0, 0x7530u, 0x4FFu);
      v4 = v0;
      if ( v0 != 1 )
        break;
      while ( PeekMessageW(&Msg, 0, 0, 0, 1u) )
        DispatchMessageW(&Msg);
    }
    if ( v0 == 258 )
    {
      _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Wait for ConfigLoadSaveMutex timed out");
    }
    else if ( v4 == -1 )
    {
      v4 = GetLastError();
      _SetupWriteTextLog(LogToken, 0x40000000u, 2u, "NCI: Wait for ConfigLoadSaveMutex failed with error %08x", v4);
    }
  }
  else
  {
    _SetupWriteTextLog(LogToken, 0x40000000u, 1u, "NCI: Failed to create ConfigLoadSaveMutex");
    v4 = GetLastError();
  }
  return v4;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6433DC) --------------------------------------------------------
__int32 __stdcall HrFinishNextOrSkipContract(__int32 a1, unsigned __int32 a2, unsigned __int32 a3, struct IUnknown **a4, unsigned __int32 *a5)
{
  unsigned __int32 v6; // esi@7

  if ( a1 )
  {
    if ( a4 )
    {
      v6 = 0;
      if ( a3 )
      {
        do
        {
          ReleaseObj(a4[v6]);
          a4[v6++] = 0;
        }
        while ( v6 < a3 );
      }
    }
    if ( a5 )
      *a5 = 0;
  }
  else
  {
    if ( a5 )
      *a5 = a2;
    a1 = a2 != a3;
  }
  return a1;
}

//----- (6E64340E) --------------------------------------------------------
BOOL __thiscall CExternalComponentData::FLoadedOkayIfLoadedAtAll(CExternalComponentData *this)
{
  return *((_DWORD *)this + 17) == 0;
}

//----- (6E64341C) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplINetCfgComponent>::CComObject<CImplINetCfgComponent>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 8) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 12) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E641B04: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E641B14: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E641B2C: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E642D34: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(CImplINetCfgComponent *, struct _GUID *, void **);

//----- (6E64347F) --------------------------------------------------------
struct CComponent *__thiscall CBindPath::PGetComponentAtIndex(CBindPath *this, unsigned int a2)
{
  CBindPath *v2; // esi@1
  struct CComponent *result; // eax@2

  v2 = this;
  if ( a2 >= std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4)) )
    result = 0;
  else
    result = *(struct CComponent **)(*((_DWORD *)v2 + 2) + 4 * a2);
  return result;
}

//----- (6E6434FF) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<CStackEntry *,CStackEntry *,std::nc_allocator<CStackEntry>>(a1, a2, a3, a4, a4, v5);
}

//----- (6E64352D) --------------------------------------------------------
int __stdcall std::_Uninit_copy<CStackEntry *,CStackEntry *,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int i; // esi@1

  for ( i = a1; i != a2; i += 8 )
  {
    std::_Construct<CStackEntry,CStackEntry>(a3, i);
    a3 += 8;
  }
  return a3;
}
// 6E64345D: using guessed type _DWORD __stdcall std::_Construct<CStackEntry,CStackEntry>(_DWORD, _DWORD);

//----- (6E64355A) --------------------------------------------------------
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 8) - v1) >> 3;
  else
    result = 0;
  return result;
}

//----- (6E643572) --------------------------------------------------------
BOOL __stdcall InlineIsEqualGUID(const struct _GUID *a1, const struct _GUID *a2)
{
  return a1->Data1 == a2->Data1
      && *(_DWORD *)&a1->Data2 == *(_DWORD *)&a2->Data2
      && *(_DWORD *)&a1->Data4[0] == *(_DWORD *)&a2->Data4[0]
      && *(_DWORD *)&a1->Data4[4] == *(_DWORD *)&a2->Data4[4];
}

//----- (6E6435AB) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetInstanceGuid(CImplINetCfgComponent *this, struct _GUID *a2)
{
  CImplINetCfgComponent *v2; // ebx@1
  int v3; // esi@2
  char *v4; // edi@2
  char *v6; // edi@4
  signed int thisa; // [sp+14h] [bp+8h]@1

  v2 = this;
  thisa = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( thisa )
  {
    a2->Data1 = GUID_NULL.Data1;
    *(_DWORD *)&a2->Data2 = *(_DWORD *)&GUID_NULL.Data2;
    v6 = (char *)a2->Data4;
    *(_DWORD *)v6 = *(_DWORD *)&GUID_NULL.Data4[0];
    *((_DWORD *)v6 + 1) = *(_DWORD *)&GUID_NULL.Data4[4];
  }
  else
  {
    v3 = *((_DWORD *)v2 + 7);
    a2->Data1 = *(_DWORD *)v3;
    v3 += 4;
    *(_DWORD *)&a2->Data2 = *(_DWORD *)v3;
    v3 += 4;
    v4 = (char *)a2->Data4;
    *(_DWORD *)v4 = *(_DWORD *)v3;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(v3 + 4);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v2 + 6) + 24));
  }
  return thisa;
}

//----- (6E6435FA) --------------------------------------------------------
signed int __thiscall CImplINetCfgComponent::HrLockAndTestForValidInterface(CImplINetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent *a3, struct CComponent **a4)
{
  CImplINetCfgComponent *v4; // esi@1
  signed int v5; // edi@1

  v4 = this;
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 6) + 24));
  v5 = CImplINetCfgComponent::HrIsValidInterface(v4, a2);
  if ( v5 )
    goto LABEL_6;
  if ( a3 )
  {
    v5 = CImplINetCfgComponent::HrIsValidInterface((CImplINetCfgComponent *)a3, 4u);
    if ( !v5 )
    {
      *a4 = (struct CComponent *)a3[7].lpVtbl;
      return v5;
    }
LABEL_6:
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v4 + 6) + 24));
  }
  return v5;
}

//----- (6E64363E) --------------------------------------------------------
signed int __thiscall CImplINetCfgComponent::HrIsValidInterface(CImplINetCfgComponent *this, unsigned __int32 a2)
{
  CImplINetCfgComponent *v2; // esi@1
  signed int result; // eax@1
  int v4; // esi@2

  v2 = this;
  result = CImplINetCfg::HrIsValidInterface(*((CImplINetCfg **)this + 6), a2);
  if ( !result )
  {
    v4 = *((_DWORD *)v2 + 7);
    if ( v4 )
    {
      if ( a2 & 4 )
        result = CExternalComponentData::HrEnsureExternalDataLoaded((CExternalComponentData *)(v4 + 36));
    }
    else
    {
      result = -2147024890;
    }
  }
  return result;
}

//----- (6E64367A) --------------------------------------------------------
__int32 __thiscall CExternalComponentData::HrEnsureExternalDataLoaded(CExternalComponentData *this)
{
  CExternalComponentData *v1; // esi@1
  __int32 result; // eax@2
  char *v3; // edi@4
  __int32 v4; // eax@4
  __int32 v5; // ebx@4
  unsigned int v6; // eax@5
  void *v7; // eax@6
  unsigned __int16 *v8; // ecx@6
  DWORD v9; // ecx@7
  unsigned __int32 v10; // ecx@10
  unsigned __int32 v11; // ecx@13
  signed int v12; // edi@14
  unsigned __int32 v13; // ST24_4@16
  SP_LOG_TOKEN LogToken; // [sp+4h] [bp-38h]@4
  HDEVINFO DeviceInfoSet; // [sp+Ch] [bp-30h]@4
  unsigned __int16 *v16; // [sp+10h] [bp-2Ch]@5
  HKEY hKey; // [sp+14h] [bp-28h]@4
  void *lpMem; // [sp+18h] [bp-24h]@5
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+1Ch] [bp-20h]@4

  v1 = this;
  if ( *((_BYTE *)this + 72) )
  {
    result = *((_DWORD *)this + 17);
  }
  else
  {
    v3 = (char *)this - 36;
    LogToken = SetupGetThreadLogToken();
    v4 = CComponent::HrOpenInstanceKey(
           (CExternalComponentData *)((char *)v1 - 36),
           0x20019u,
           &hKey,
           &DeviceInfoSet,
           &DeviceInfoData);
    v5 = v4;
    if ( v4 )
    {
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!!! NCI: (loading external data) Error 0x%08X opening %ws instance key",
        v4,
        *((_DWORD *)v3 + 7));
    }
    else
    {
      v6 = RegQueryValuesWithAlloc(
             hKey,
             0xDu,
             (DWORD)off_6E645820,
             (unsigned __int8 *)v1,
             (unsigned __int8 **)&lpMem,
             (unsigned __int32 *)&v16);
      if ( v6 )
      {
        if ( (signed int)v6 > 0 )
          v6 = (unsigned __int16)v6 | 0x80070000;
        v5 = v6;
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "!!! NCI: Error 0x%08X loading external data for %ws",
          v6,
          *((_DWORD *)v3 + 7));
        memset((void *)v1, 0, 0x4Cu);
      }
      else
      {
        v7 = lpMem;
        v8 = v16;
        *(_DWORD *)v1 = lpMem;
        *((_DWORD *)v1 + 15) = (char *)v7 + (_DWORD)v8;
        if ( DeviceInfoSet == (HDEVINFO)v5
          || !FIsConsideredNetClass(*((_DWORD *)v3 + 4))
          || (v5 = HrSetupDiGetDeviceName(v9, DeviceInfoSet, &DeviceInfoData, (DWORD)((char *)v1 + 4))) == 0 )
        {
          v5 = HrBuildBindNameFromBindForm(
                 *((const void **)v1 + 5),
                 *((_DWORD *)v3 + 4),
                 *((_DWORD *)v3 + 6),
                 *((_DWORD *)v1 + 3),
                 *((_DWORD *)v3 + 7),
                 (GUID *)((char *)v1 - 36),
                 (WCHAR *)v1 + 32);
          if ( !v5 && !FIsConsideredNetClass(*((_DWORD *)v3 + 4)) )
          {
            if ( HrRegGetTypeWithAlloc(v10, hKey, L"LocDescription", 1u, (unsigned __int8 **)&lpMem, 0) < 0 )
              goto LABEL_24;
            v12 = HrSetupLoadIndirectStringWithAlloc((unsigned __int16 *)lpMem, &v16);
            if ( v12 >= 0 )
              *((_DWORD *)v1 + 1) = v16;
            operator delete(lpMem);
            v11 = v13;
            if ( v12 < 0 )
LABEL_24:
              v5 = HrRegGetSzWithAlloc(v11, hKey, L"Description", (unsigned __int16 **)v1 + 1);
          }
        }
      }
      SetupDiDestroyDeviceInfoListSafe(DeviceInfoSet);
      RegCloseKey(hKey);
    }
    *((_DWORD *)v1 + 17) = v5;
    result = v5;
    *((_BYTE *)v1 + 72) = 1;
  }
  return result;
}
// 6E645820: using guessed type wchar_t *off_6E645820[2];
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6436AE) --------------------------------------------------------
int __stdcall ATL::AtlInternalQueryInterface(void *a1, const struct ATL::_ATL_INTMAP_ENTRY *a2, const struct _GUID *a3, void **a4)
{
  const struct ATL::_ATL_INTMAP_ENTRY *i; // esi@3
  int (__stdcall *v5)(_DWORD, _DWORD, _DWORD, _DWORD); // edi@4
  char *v6; // esi@8
  int result; // eax@8
  char *v8; // esi@11
  const struct ATL::_ATL_INTMAP_ENTRY *v9; // [sp+10h] [bp+Ch]@5

  if ( a4 )
  {
    *a4 = 0;
    if ( ATL::InlineIsEqualUnknown(a3) )
    {
      v8 = (char *)a1 + *((_DWORD *)a2 + 1);
      (*(void (__stdcall **)(char *))(*(_DWORD *)v8 + 4))(v8);
      *a4 = v8;
      result = 0;
    }
    else
    {
      for ( i = a2; ; i = (const struct ATL::_ATL_INTMAP_ENTRY *)((char *)i + 12) )
      {
        v5 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*((_DWORD *)i + 2);
        if ( !v5 )
          break;
        v9 = (const struct ATL::_ATL_INTMAP_ENTRY *)(*(_DWORD *)i == 0);
        if ( *(_DWORD *)i == 0 || InlineIsEqualGUID(*(const struct _GUID **)i, a3) )
        {
          if ( v5 == (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))1 )
          {
            v6 = (char *)a1 + *((_DWORD *)i + 1);
            (*(void (__stdcall **)(char *))(*(_DWORD *)v6 + 4))(v6);
            *a4 = v6;
            return 0;
          }
          result = v5(a1, a3, a4, *((_DWORD *)i + 1));
          if ( !result || !v9 && result < 0 )
            return result;
        }
      }
      result = -2147467262;
    }
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E643729) --------------------------------------------------------
HRESULT __stdcall DllGetClassObject(const IID *const rclsid, const IID *const riid, LPVOID *ppv)
{
  HRESULT result; // eax@3

  if ( ppv )
  {
    *ppv = 0;
    if ( dword_6E699218 )
      result = ATL::AtlModuleGetClassObject((struct ATL::_ATL_MODULE *)&_Module, rclsid, riid, ppv);
    else
      result = -2147467259;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}
// 6E699218: using guessed type int dword_6E699218;

//----- (6E643766) --------------------------------------------------------
signed int __stdcall ATL::AtlModuleGetClassObject(struct ATL::_ATL_MODULE *a1, const struct _GUID *a2, const struct _GUID *a3, void **a4)
{
  int v4; // esi@2
  signed int result; // eax@10
  int v6; // [sp+14h] [bp-1Ch]@2

  if ( a1 )
  {
    v4 = *((_DWORD *)a1 + 4);
    v6 = 0;
    if ( a4 )
    {
      while ( *(_DWORD *)v4 )
      {
        if ( InlineIsEqualGUID(a2, *(const struct _GUID **)v4) )
        {
          if ( !*(_DWORD *)(v4 + 16) )
          {
            EnterCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 76));
            if ( !*(_DWORD *)(v4 + 16) )
              v6 = (*(int (__stdcall **)(_DWORD, GUID *, int))(v4 + 8))(*(_DWORD *)(v4 + 12), &IID_IUnknown, v4 + 16);
            LeaveCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 76));
          }
          if ( *(_DWORD *)(v4 + 16) )
            v6 = (*(int (__stdcall **)(_DWORD, const struct _GUID *, void **))**(int (__stdcall ****)(_DWORD, _DWORD, _DWORD))(v4 + 16))(
                   *(_DWORD *)(v4 + 16),
                   a3,
                   a4);
          break;
        }
        v4 += 28;
      }
      if ( !*a4 && !v6 )
        v6 = -2147221231;
      result = v6;
    }
    else
    {
      result = -2147467261;
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E6437EB) --------------------------------------------------------
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 12) - v1) >> 3;
  else
    result = 0;
  return result;
}

//----- (6E643803) --------------------------------------------------------
int __stdcall ATL::CComObject<CMSClient>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::AddRef(a1 - 4);
}
// 6E64380F: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(_DWORD);

//----- (6E643854) --------------------------------------------------------
__int32 __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::QueryInterface(ATL::CComClassFactory *a1, struct _GUID *a2, void **a3)
{
  return ATL::CComClassFactory::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E6438B9) --------------------------------------------------------
void *__thiscall CBindingSet::CBindingSet(void *this)
{
  void *v1; // esi@1

  v1 = this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)((char *)this + 4), 0);
  return v1;
}

//----- (6E6438D1) --------------------------------------------------------
char __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  void *v4; // eax@5

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  if ( a2 )
  {
    if ( (unsigned int)a2 > 0xCCCCCCC )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v4 = std::_Allocate<CBindPath>(a2, 0);
    *(_DWORD *)(v2 + 4) = v4;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 12) = (char *)v4 + 20 * a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E6438FD) --------------------------------------------------------
signed int __thiscall CComponent::HrGetINetCfgComponentInterface(CComponent *this, struct CImplINetCfg *a2, struct INetCfgComponent **a3)
{
  signed int v3; // edi@1
  struct IUnknown **v4; // esi@1

  v3 = 0;
  v4 = (struct IUnknown **)((char *)this + 124);
  if ( *((_DWORD *)this + 31)
    || (v3 = CImplINetCfgComponent::HrCreateInstance(a2, this, (struct CImplINetCfgComponent **)this + 31)) == 0 )
  {
    AddRefObj(*v4);
    *a3 = (struct INetCfgComponent *)*v4;
  }
  return v3;
}

//----- (6E643938) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::HrCreateInstance(struct CImplINetCfg *a1, struct CComponent *a2, struct CImplINetCfgComponent **a3)
{
  signed int v3; // edi@1
  int v4; // eax@1
  int v5; // esi@2

  v3 = -2147024882;
  v4 = (int)operator new(0x20u);
  if ( v4 )
    v5 = ATL::CComObject<CImplINetCfgComponent>::CComObject<CImplINetCfgComponent>(v4, 0);
  else
    v5 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 28) = a2;
    v3 = 0;
    CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v5 + 16), a1);
    AddRefObj((struct IUnknown *)v5);
    *a3 = (struct CImplINetCfgComponent *)v5;
  }
  return v3;
}

//----- (6E64398E) --------------------------------------------------------
void __thiscall CImplINetCfgHolder::HoldINetCfg(CImplINetCfgHolder *this, struct CImplINetCfg *a2)
{
  CImplINetCfgHolder *v2; // esi@1

  v2 = this;
  AddRefObj((struct IUnknown *)a2);
  *((_DWORD *)v2 + 2) = a2;
}

//----- (6E6439AE) --------------------------------------------------------
unsigned __int32 __stdcall AddRefObj(struct IUnknown *a1)
{
  unsigned __int32 result; // eax@2

  if ( a1 )
    result = a1->lpVtbl->AddRef(a1);
  else
    result = 0;
  return result;
}

//----- (6E6439D0) --------------------------------------------------------
unsigned int __thiscall ALIGNUP(BOOL this, unsigned int a2)
{
  bool v2; // zf@1
  unsigned int result; // eax@1

  v2 = IsRunningOnWow64(this) == 0;
  result = a2;
  if ( !v2 )
    result = (a2 + 7) & 0xFFFFFFF8;
  return result;
}

//----- (6E6439F0) --------------------------------------------------------
int __thiscall IsRunningOnWow64(BOOL this)
{
  int result; // eax@1
  HANDLE v2; // eax@3
  BOOL Wow64Process; // [sp+0h] [bp-4h]@1

  Wow64Process = this;
  result = `IsRunningOnWow64'::`2'::dwCachedWow64;
  if ( `IsRunningOnWow64'::`2'::dwCachedWow64 == -1 )
  {
    v2 = GetCurrentProcess();
    if ( IsWow64Process(v2, &Wow64Process) )
    {
      result = Wow64Process;
      `IsRunningOnWow64'::`2'::dwCachedWow64 = Wow64Process;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}
// 6E699140: using guessed type int `IsRunningOnWow64'::`2'::dwCachedWow64;

//----- (6E643A0B) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(CImplINetCfgComponent *a1, struct _GUID *a2, void **a3)
{
  return CImplINetCfgComponent::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E643A95) --------------------------------------------------------
int __stdcall FSubstringMatch(const unsigned __int16 *a1, const unsigned __int16 *a2, const unsigned __int16 **a3, unsigned __int32 *a4)
{
  const unsigned __int16 *v4; // eax@3
  const unsigned __int16 *v5; // esi@4
  const unsigned __int16 v6; // ax@4
  const unsigned __int16 v7; // ax@7
  const unsigned __int16 *v8; // ebx@7
  int v9; // ebx@11
  const unsigned __int16 *k; // edx@12
  const unsigned __int16 v11; // ax@13
  const unsigned __int16 *j; // edi@13
  const unsigned __int16 v13; // ax@16
  int v14; // ecx@22
  bool v15; // cf@22
  bool v16; // zf@22
  int v17; // eax@22
  int result; // eax@29
  const unsigned __int16 *i; // [sp+0h] [bp-4h]@7
  const unsigned __int16 *v20; // [sp+Ch] [bp+8h]@4

  if ( a3 )
    *a3 = 0;
  if ( a4 )
    *a4 = 0;
  v4 = a1;
LABEL_4:
  v5 = v4;
  v6 = *v4;
  v20 = v5;
  if ( v6 )
  {
    do
    {
      if ( v6 != 32 && v6 != 44 )
        break;
      ++v5;
      v6 = *v5;
      v20 = v5;
    }
    while ( *v5 );
  }
  v7 = *v5;
  v8 = v5;
  for ( i = v5; *v8; i = v8 )
  {
    if ( v7 == 32 )
      break;
    if ( v7 == 44 )
      break;
    ++v8;
    v7 = *v8;
  }
  v9 = v8 - v5;
  if ( v9 )
  {
    k = a2;
    while ( 1 )
    {
      do
      {
        v11 = *k;
        for ( j = k; *j; v11 = *j )
        {
          if ( v11 != 32 && v11 != 44 )
            break;
          ++j;
        }
        v13 = *j;
        for ( k = j; *k; v13 = *k )
        {
          if ( v13 == 32 )
            break;
          if ( v13 == 44 )
            break;
          ++k;
        }
        if ( !(k - j) )
        {
          v4 = i;
          goto LABEL_4;
        }
      }
      while ( v9 != k - j );
      v14 = 2 * v9;
      v17 = 0;
      v15 = 0;
      v16 = 1;
      do
      {
        if ( !v14 )
          break;
        v15 = *(_BYTE *)v5 < *(_BYTE *)j;
        v16 = *(_BYTE *)v5 == *(_BYTE *)j;
        v5 = (const unsigned __int16 *)((char *)v5 + 1);
        j = (const unsigned __int16 *)((char *)j + 1);
        --v14;
      }
      while ( v16 );
      if ( !v16 )
        v17 = -v15 - (v15 - 1);
      if ( !v17 )
        break;
      v5 = v20;
    }
    if ( a3 )
      *a3 = v20;
    if ( a4 )
      *a4 = v9;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E643C11) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(int this, char a2, int a3)
{
  int v3; // esi@1
  void *v5; // edi@4

  v3 = this;
  if ( a2 && *(_DWORD *)(this + 24) >= 8u )
  {
    v5 = *(void **)(this + 4);
    if ( a3 )
      std::_Traits_helper::copy_s<std::char_traits<unsigned short>>((void *)(this + 4), 8, v5, a3);
    operator delete(v5);
  }
  *(_DWORD *)(v3 + 24) = 7;
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
           v3,
           a3);
}

//----- (6E643C44) --------------------------------------------------------
void __thiscall CRegistryBindingsContext::~CRegistryBindingsContext(CRegistryBindingsContext *this)
{
  CRegistryBindingsContext *v1; // esi@1

  v1 = this;
  MemFree(*((void **)this + 14));
  MemFree(*((void **)v1 + 10));
  MemFree(*((void **)v1 + 6));
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)v1 + 8));
}

//----- (6E643C6F) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::ReleaseNotifyObject(CNotifyObjectInterface *this, struct CImplINetCfg *a2, int a3)
{
  CNotifyObjectInterface *v3; // esi@1

  v3 = this;
  if ( *(_DWORD *)this )
  {
    if ( a3 )
    {
      CImplINetCfg::RaiseRpl((int)a2, 1);
      (*(void (__stdcall **)(_DWORD))(***(_DWORD ***)v3 + 24))(**(_DWORD **)v3);
      CImplINetCfg::LowerRpl((int)a2, 1);
    }
    ReleaseObj(**(struct IUnknown ***)v3);
    ReleaseObj(*(struct IUnknown **)(*(_DWORD *)v3 + 4));
    ReleaseObj(*(struct IUnknown **)(*(_DWORD *)v3 + 8));
    ReleaseObj(*(struct IUnknown **)(*(_DWORD *)v3 + 12));
    ReleaseObj(*(struct IUnknown **)(*(_DWORD *)v3 + 16));
    ReleaseObj(*(struct IUnknown **)(*(_DWORD *)v3 + 20));
    MemFree(*(void **)v3);
    *(_DWORD *)v3 = 0;
  }
  *((_BYTE *)v3 + 4) = 0;
}

//----- (6E643C9A) --------------------------------------------------------
void __stdcall ReleaseConfigLoadSaveMutex()
{
  if ( g_ConfigLoadSaveMutex )
    ReleaseMutex(g_ConfigLoadSaveMutex);
}

//----- (6E643CC4) --------------------------------------------------------
__int32 __stdcall HrSetupDiCreateDeviceInfoList(GUID *ClassGuid, HWND hwndParent, void **a3)
{
  HDEVINFO v3; // ecx@1
  __int32 result; // eax@2

  v3 = SetupDiCreateDeviceInfoList(ClassGuid, hwndParent);
  if ( v3 == (HDEVINFO)-1 )
  {
    result = HrFromLastWin32Error();
    *a3 = 0;
  }
  else
  {
    result = 0;
    *a3 = v3;
  }
  return result;
}

//----- (6E643CF0) --------------------------------------------------------
unsigned int __stdcall CbOfSzAndTermSafe(const unsigned __int16 *a1)
{
  unsigned int result; // eax@1

  result = 0;
  if ( a1 )
    result = CbOfSzAndTerm(a1);
  return result;
}

//----- (6E643D0B) --------------------------------------------------------
void __thiscall CComponent::ReleaseINetCfgComponentInterface(CComponent *this)
{
  CComponent *v1; // esi@1
  int v2; // eax@1

  v1 = this;
  v2 = *((_DWORD *)this + 31);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 28) = 0;
    ReleaseObj(*((struct IUnknown **)this + 31));
    *((_DWORD *)v1 + 31) = 0;
  }
}

//----- (6E643D30) --------------------------------------------------------
int __stdcall FreeCollectionAndItem<CFilterMap>(int a1)
{
  int v1; // esi@1
  void **i; // edi@1

  v1 = a1;
  for ( i = *(void ***)(a1 + 4); i != *(void ***)(v1 + 8); ++i )
  {
    if ( *i )
      CFilterMapEntry::`scalar deleting destructor'(*i, 1);
  }
  return std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
           (void *)v1,
           (int)&a1,
           *(_DWORD *)(v1 + 4),
           *(_DWORD *)(v1 + 8));
}

//----- (6E643D64) --------------------------------------------------------
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(void *this, int a2, int a3, int a4)
{
  void *v4; // esi@1
  int v5; // ecx@1
  int result; // eax@2
  int v7; // eax@3
  char v8; // [sp+4h] [bp-4h]@3

  v4 = this;
  v5 = a3;
  if ( a3 != a4 )
  {
    v7 = std::copy<CFilteredAdapter * *,std::_Vector_iterator<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>>(
           (int)&v8,
           a4,
           *((_DWORD *)v4 + 2),
           a3);
    v5 = a3;
    *((_DWORD *)v4 + 2) = *(_DWORD *)v7;
  }
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}

//----- (6E643DA1) --------------------------------------------------------
int __cdecl std::copy<CFilteredAdapter * *,std::_Vector_iterator<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>>(int a1, int a2, int a3, int a4)
{
  std::_Copy_opt<CComponent * *,std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>>(a1, a2, a3, a4);
  return a1;
}

//----- (6E643DD3) --------------------------------------------------------
int __cdecl std::_Copy_opt<CComponent * *,std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>>(int a1, int a2, int a3, int a4)
{
  int i; // eax@1
  int result; // eax@3

  for ( i = a2; i != a3; i += 4 )
  {
    *(_DWORD *)a4 = *(_DWORD *)i;
    a4 += 4;
  }
  result = a1;
  *(_DWORD *)a1 = a4;
  return result;
}

//----- (6E643DF3) --------------------------------------------------------
void *__thiscall CComponent::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CComponent::~CComponent((CComponent *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E643E19) --------------------------------------------------------
void __thiscall CComponent::~CComponent(CComponent *this)
{
  CComponent *v1; // esi@1

  v1 = this;
  CComponent::ReleaseINetCfgComponentInterface(this);
  if ( *((_DWORD *)v1 + 5) )
    SetupCloseInfFile(*((HINF *)v1 + 5));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 140),
    1,
    0);
  CComponentReferences::~CComponentReferences((CComponent *)((char *)v1 + 120));
  CNotifyObjectInterface::ReleaseNotifyObject((CComponent *)((char *)v1 + 112), 0, 0);
  CExternalComponentData::FreeExternalData((CComponent *)((char *)v1 + 36));
}

//----- (6E643E7F) --------------------------------------------------------
void __thiscall CExternalComponentData::FreeExternalData(CExternalComponentData *this)
{
  CExternalComponentData *v1; // esi@1

  v1 = this;
  LocalFree(*((HLOCAL *)this + 16));
  CExternalComponentData::FreeDescription(v1);
  MemFree(*(void **)v1);
}

//----- (6E643EA2) --------------------------------------------------------
void __thiscall CExternalComponentData::FreeDescription(CExternalComponentData *this)
{
  CExternalComponentData *v1; // esi@1
  unsigned int v2; // eax@1

  v1 = this;
  v2 = *((_DWORD *)this + 1);
  if ( v2 < *(_DWORD *)this || v2 > *((_DWORD *)this + 15) )
    MemFree(*((void **)this + 1));
  *((_DWORD *)v1 + 1) = 0;
}

//----- (6E643EDC) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfg>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplINetCfg>::~CComObject<CImplINetCfg>();
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 6E643F02: using guessed type int ATL::CComObject<CImplINetCfg>::~CComObject<CImplINetCfg>(void);

//----- (6E643F4E) --------------------------------------------------------
void __thiscall CImplINetCfg::~CImplINetCfg(CImplINetCfg *this)
{
  CImplINetCfg *v1; // esi@1

  v1 = this;
  CWriteLock::~CWriteLock((CImplINetCfg *)((char *)this + 72));
  DeleteCriticalSection((LPCRITICAL_SECTION)v1 + 1);
}

//----- (6E643F80) --------------------------------------------------------
BOOL __thiscall CWriteLock::~CWriteLock(CWriteLock *this)
{
  CWriteLock *v1; // esi@1
  BOOL result; // eax@3

  v1 = this;
  if ( *(_DWORD *)this )
  {
    CWriteLock::ReleaseIfOwned(this);
    result = CloseHandle(*(HANDLE *)v1);
  }
  return result;
}

//----- (6E643F95) --------------------------------------------------------
void __thiscall CModifyContext::~CModifyContext(CModifyContext *this)
{
  CModifyContext *v1; // esi@1

  v1 = this;
  CFilterMap::~CFilterMap((CModifyContext *)((char *)this + 196));
  CRegistryBindingsContext::~CRegistryBindingsContext((CModifyContext *)((char *)v1 + 124));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 108));
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)v1 + 88));
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)v1 + 68));
  CNetConfigCore::~CNetConfigCore(v1);
}

//----- (6E643FCD) --------------------------------------------------------
void __thiscall CNetConfigCore::~CNetConfigCore(CNetConfigCore *this)
{
  CNetConfigCore *v1; // esi@1

  v1 = this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)this + 48));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 24));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 4));
}

//----- (6E643FF0) --------------------------------------------------------
int __stdcall FreeCollectionAndItem<CComponentList>(int a1)
{
  int v1; // esi@1
  void **i; // edi@1

  v1 = a1;
  for ( i = *(void ***)(a1 + 8); i != *(void ***)(v1 + 12); ++i )
  {
    if ( *i )
      CComponent::`scalar deleting destructor'(*i, 1);
  }
  return std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
           (void *)(v1 + 4),
           (int)&a1,
           *(_DWORD *)(v1 + 8),
           *(_DWORD *)(v1 + 12));
}

//----- (6E644049) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 2);
  if ( !v1 && lpMem )
    ATL::CComObject<CImplINetCfgClass>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E64407D) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfgClass>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplINetCfgClass>::~CComObject<CImplINetCfgClass>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E6440A3) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplINetCfgClass>::~CComObject<CImplINetCfgClass>(int this)
{
  struct IUnknown *v1; // ST00_4@1

  v1 = *(struct IUnknown **)(this + 16);
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgClass>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CImplINetCfgClass>::`vftable';
  *(_DWORD *)(this + 8) = 1;
  ReleaseObj(v1);
  return InterlockedDecrement(&Addend);
}
// 6E644030: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(CImplINetCfgClass *, struct _GUID *, void **);
// 6E6440CC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(int, int, int);

//----- (6E6440E9) --------------------------------------------------------
void __thiscall CFilterMap::~CFilterMap(CFilterMap *this)
{
  int v1; // esi@1

  v1 = (int)this;
  FreeCollectionAndItem<CFilterMap>((int)this);
  *(_DWORD *)(v1 + 16) = 0;
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v1);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(v1);
}

//----- (6E64410C) --------------------------------------------------------
int __thiscall std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  return std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
           (void *)this,
           (int)&v2,
           *(_DWORD *)(this + 4),
           *(_DWORD *)(this + 8));
}

//----- (6E64412A) --------------------------------------------------------
signed int __stdcall CImplINetCfg::Uninitialize(CImplINetCfg *this)
{
  void *v1; // ecx@2
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-Ch]@1
  signed int v4; // [sp+14h] [bp-4h]@1

  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(LogToken, 0x40000000u, (5 - (g_IsInUpgrade != 0)) | 0x10000, "NCI: Enter INetCfg::Uninitialize.");
  v4 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0x50u);
  if ( !v4 )
  {
    v1 = (void *)*((_DWORD *)this + 12);
    if ( v1 )
      CNetConfig::`scalar deleting destructor'(v1, 1);
    ReleaseIUnknownArray(5u, (struct IUnknown **)this + 13);
    *((_DWORD *)this + 13) = 0;
    *((_DWORD *)this + 14) = 0;
    *((_DWORD *)this + 15) = 0;
    *((_DWORD *)this + 16) = 0;
    *((_DWORD *)this + 17) = 0;
    LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfg::Uninitialize, hr = %08xx.",
    v4);
  return v4;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E644237) --------------------------------------------------------
void *__thiscall CNetConfig::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CNetConfig::~CNetConfig((CNetConfig *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E64425D) --------------------------------------------------------
void __thiscall CNetConfig::~CNetConfig(CNetConfig *this)
{
  CNetConfig *v1; // esi@1

  v1 = this;
  FreeCollectionAndItem<CComponentList>((int)this);
  CModifyContext::~CModifyContext((CNetConfig *)((char *)v1 + 72));
  CGlobalNotifyInterface::ReleaseINetCfg((CNetConfig *)((char *)v1 + 64));
  CNetConfigCore::~CNetConfigCore(v1);
}

//----- (6E6442A1) --------------------------------------------------------
void __thiscall CGlobalNotifyInterface::ReleaseINetCfg(CGlobalNotifyInterface *this)
{
  CGlobalNotifyInterface *v1; // esi@1
  int v2; // eax@1

  v1 = this;
  v2 = *((_DWORD *)this + 1);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 48) = 0;
    ReleaseObj(*((struct IUnknown **)this + 1));
    *((_DWORD *)v1 + 1) = 0;
  }
}

//----- (6E6442C4) --------------------------------------------------------
__int32 __thiscall CComponent::HrOpenInstanceKey(CComponent *this, unsigned __int32 a2, HKEY *a3, void **a4, struct _SP_DEVINFO_DATA *a5)
{
  return HrOpenComponentInstanceKey(
           *((_DWORD *)this + 4),
           (GUID *)this,
           *((const WCHAR **)this + 8),
           a2,
           a3,
           (int)a4,
           a5);
}

//----- (6E6442EB) --------------------------------------------------------
__int32 __stdcall HrOpenComponentInstanceKey(int a1, GUID *a2, const WCHAR *a3, REGSAM samDesired, HKEY *a5, int a6, void *a7)
{
  HDEVINFO v7; // ebx@4
  __int32 v8; // esi@5
  HDEVINFO v9; // eax@6
  unsigned int v11; // edi@18
  WCHAR *v12; // eax@19
  HANDLE v13; // edi@22
  HDEVINFO DeviceInfoSet; // [sp+18h] [bp-5C4h]@1
  char v15; // [sp+1Ch] [bp-5C0h]@15
  wchar_t pszSrc; // [sp+38h] [bp-5A4h]@1
  char v17; // [sp+3Ah] [bp-5A2h]@1
  wchar_t pszDest; // [sp+240h] [bp-39Ch]@1
  char Dst; // [sp+242h] [bp-39Ah]@1
  WCHAR Name; // [sp+448h] [bp-194h]@18
  char v21; // [sp+44Ah] [bp-192h]@18

  DeviceInfoSet = a7;
  pszDest = 0;
  memset(&Dst, 0, 0x206u);
  pszSrc = 0;
  memset(&v17, 0, 0x206u);
  *a5 = 0;
  if ( a6 )
    *(_DWORD *)a6 = 0;
  if ( !FIsConsideredNetClass(a1) )
  {
    CreateInstanceKeyPath(a1, a2, &pszDest);
    return HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, samDesired, a5);
  }
  v7 = DeviceInfoSet;
  if ( !DeviceInfoSet )
    v7 = &v15;
  v8 = HrOpenDeviceInfo(a1, a3, &DeviceInfoSet, (struct _SP_DEVINFO_DATA *)v7);
  if ( !v8 )
  {
    v8 = HrSetupDiOpenDevRegKey(DeviceInfoSet, (PSP_DEVINFO_DATA)v7, 1u, 0, 2u, samDesired, a5);
    v9 = DeviceInfoSet;
    if ( !v8 )
    {
      if ( !a6 )
      {
LABEL_16:
        SetupDiDestroyDeviceInfoList(v9);
        goto LABEL_11;
      }
      *(_DWORD *)a6 = DeviceInfoSet;
    }
    if ( a6 && !v8 )
      goto LABEL_11;
    goto LABEL_16;
  }
LABEL_11:
  if ( (v8 == -2146500085 || v8 == -2146500092) && samDesired == 131097 )
  {
    Name = 0;
    memset(&v21, 0, 0x18Eu);
    StringCchCopyW(&Name, 0xC8u, a3);
    v11 = 0;
    if ( wcslen(&Name) )
    {
      do
      {
        v12 = &Name + v11;
        if ( 92 == *v12 )
          *v12 = 38;
        ++v11;
      }
      while ( v11 < wcslen(&Name) );
    }
    v13 = OpenEventW(0x20000u, 0, &Name);
    if ( v13 )
    {
      if ( StringCchCopyW(&pszDest, 0x104u, L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\")
        || HrPnpIdToRegKeyName(&pszSrc, 0x104u, a3)
        || StringCchCatW(&pszDest, 0x104u, &pszSrc)
        || (v8 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0x20019u, a5)) != 0 )
        v8 = -2146500085;
      CloseHandle(v13);
    }
  }
  return v8;
}

//----- (6E644414) --------------------------------------------------------
__int32 __stdcall HrOpenDeviceInfo(int a1, const WCHAR *DeviceInstanceId, void **a3, struct _SP_DEVINFO_DATA *DeviceInfoData)
{
  __int32 v4; // ebx@1

  v4 = HrSetupDiCreateDeviceInfoList(0, 0, a3);
  if ( !v4 )
  {
    v4 = HrSetupDiOpenDeviceInfo(*a3, DeviceInstanceId, 0, 0, DeviceInfoData);
    if ( v4 )
    {
      SetupDiDestroyDeviceInfoList(*a3);
      *a3 = 0;
    }
  }
  return v4;
}

//----- (6E644456) --------------------------------------------------------
__int32 __stdcall HrSetupDiOpenDeviceInfo(HDEVINFO DeviceInfoSet, PCWSTR DeviceInstanceId, HWND hwndParent, DWORD OpenFlags, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v5; // esi@3

  if ( DeviceInfoData )
  {
    memset(DeviceInfoData, 0, 0x1Cu);
    DeviceInfoData->cbSize = 28;
  }
  v5 = 0;
  if ( !SetupDiOpenDeviceInfoW(DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData) )
    v5 = HrFromLastWin32Error();
  return v5;
}

//----- (6E64449D) --------------------------------------------------------
void *__thiscall CComponentReferences::~CComponentReferences(CComponentReferences *this)
{
  void *v1; // ecx@1
  void *result; // eax@2

  v1 = *(void **)this;
  if ( v1 )
    result = COMPONENT_REFERENCE_DATA::`scalar deleting destructor'(v1, 1);
  return result;
}

//----- (6E6444B0) --------------------------------------------------------
void *__thiscall COMPONENT_REFERENCE_DATA::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  COMPONENT_REFERENCE_DATA::~COMPONENT_REFERENCE_DATA((COMPONENT_REFERENCE_DATA *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E6444D6) --------------------------------------------------------
void __thiscall COMPONENT_REFERENCE_DATA::~COMPONENT_REFERENCE_DATA(COMPONENT_REFERENCE_DATA *this)
{
  COMPONENT_REFERENCE_DATA *v1; // esi@1

  v1 = this;
  std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Tidy((int)((char *)this + 20));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 4));
}

//----- (6E6444F1) --------------------------------------------------------
void __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Tidy(int this)
{
  int v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  v2 = *(void **)(this + 4);
  if ( v2 )
  {
    std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
      v2,
      *(_DWORD *)(this + 8),
      this);
    operator delete(*(void **)(v1 + 4));
  }
  *(_DWORD *)(v1 + 4) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 12) = 0;
}

//----- (6E64452A) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfgComponent>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplINetCfgComponent>::~CComObject<CImplINetCfgComponent>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E644550) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplINetCfgComponent>::~CComObject<CImplINetCfgComponent>(int this)
{
  struct IUnknown *v1; // ST00_4@1

  v1 = *(struct IUnknown **)(this + 24);
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 8) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 12) = &ATL::CComObject<CImplINetCfgComponent>::`vftable';
  *(_DWORD *)(this + 16) = 1;
  ReleaseObj(v1);
  return InterlockedDecrement(&Addend);
}
// 6E641B04: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E641B14: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E641B2C: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(int, int, int);
// 6E642D34: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgComponent>::`vftable')(CImplINetCfgComponent *, struct _GUID *, void **);

//----- (6E644640) --------------------------------------------------------
int __stdcall NetClassEnumFromGuid(const void *a1)
{
  if ( !memcmp(&GUID_DEVCLASS_NET, a1, 0x10u) )
    return 0;
  if ( !memcmp(&GUID_DEVCLASS_INFRARED, a1, 0x10u) )
    return 1;
  if ( !memcmp(&GUID_DEVCLASS_NETTRANS, a1, 0x10u) )
    return 2;
  if ( !memcmp(&GUID_DEVCLASS_NETCLIENT, a1, 0x10u) )
    return 3;
  return 2 * (memcmp(&GUID_DEVCLASS_NETSERVICE, a1, 0x10u) != 0) + 4;
}

//----- (6E64466F) --------------------------------------------------------
void *__thiscall CComponent::CComponent(void *this)
{
  void *v1; // esi@1

  v1 = this;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)this + 140));
  return v1;
}

//----- (6E644688) --------------------------------------------------------
BOOL __stdcall FIsPhysicalAdapter(int a1, char a2)
{
  return FIsConsideredNetClass(a1) && a2 & 4;
}

//----- (6E6446B3) --------------------------------------------------------
__int32 __stdcall HrLoadNetworkConfigurationFromRegistry(unsigned __int32 a1, struct CNetConfig *a2)
{
  SP_LOG_TOKEN v2; // kr00_8@1
  __int32 v3; // esi@1
  unsigned __int32 v4; // eax@2
  unsigned __int32 v5; // ecx@2
  __int32 v6; // esi@3
  unsigned __int32 v8; // [sp+Ch] [bp-Ch]@3
  void *lpMem; // [sp+10h] [bp-8h]@3
  HKEY hKey; // [sp+14h] [bp-4h]@1

  v2 = SetupGetThreadLogToken();
  v3 = HrOpenNetworkKey(0x20019u, &hKey);
  if ( !v3 )
  {
    v4 = WaitForConfigLoadSaveMutex();
    if ( v4 )
    {
      if ( (signed int)v4 > 0 )
        v4 = (unsigned __int16)v4 | 0x80070000;
    }
    else
    {
      v6 = HrRegGetTypeWithAlloc(v5, hKey, L"Config", 3u, (unsigned __int8 **)&lpMem, &v8);
      ReleaseConfigLoadSaveMutex();
      if ( !v6 )
      {
        v3 = (__int32)HrLoadNetworkConfigurationFromBuffer((const unsigned __int8 *)lpMem, v8, a2);
        MemFree(lpMem);
LABEL_5:
        RegCloseKey(hKey);
        return v3;
      }
      _SetupWriteTextLog(v2, 0x40000000u, 2u, "NCI: Failed to read config from registry. hr = 0x%08x", v6);
      v3 = HrLoadNetworkConfigurationFromLegacy(a2);
      if ( v3 )
        goto LABEL_5;
      v4 = HrSaveNetworkConfigurationToRegistry(a2);
    }
    v3 = v4;
    goto LABEL_5;
  }
  return v3;
}

//----- (6E64473E) --------------------------------------------------------
signed int __thiscall CComponentReferences::HrAddReferenceByComponent(CComponentReferences *this, const struct CComponent *a2)
{
  CComponentList **v2; // esi@1
  signed int result; // eax@1

  v2 = (CComponentList **)this;
  result = CComponentReferences::HrEnsureAllocated(this);
  if ( !result )
    result = CComponentList::HrInsertComponent(*v2, a2, 0x2200u);
  return result;
}

//----- (6E644768) --------------------------------------------------------
int __cdecl std::fill<CStackEntry *,CStackEntry>(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a1; result != a2; result += 8 )
  {
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
  }
  return result;
}

//----- (6E6447E2) --------------------------------------------------------
int __stdcall RegQueryValuesWithAlloc(HKEY a1, unsigned __int32 a2, DWORD Type, unsigned __int8 *a4, unsigned __int8 **a5, unsigned __int32 *a6)
{
  int v6; // ebx@1
  void *v7; // edi@1
  unsigned __int32 v8; // ecx@3
  SIZE_T v10; // esi@5
  unsigned __int8 *v11; // edi@5
  SIZE_T dwBytes; // [sp+Ch] [bp-4h]@1

  *a5 = 0;
  *a6 = 0;
  v6 = 14;
  v7 = MemAlloc(0x200u);
  dwBytes = 512;
  if ( v7 && (v6 = RegQueryValues(a1, a2, Type, a4, (unsigned __int8 *)v7, &dwBytes), v6 == 234) )
  {
    MemFree(v7);
    v10 = dwBytes;
    v6 = 14;
    v11 = (unsigned __int8 *)MemAlloc(dwBytes);
    if ( v11 )
    {
      dwBytes = v10;
      v6 = RegQueryValues(a1, a2, Type, a4, v11, &dwBytes);
      if ( v6 )
      {
        MemFree(v11);
      }
      else
      {
        *a5 = v11;
        *a6 = v10;
      }
    }
  }
  else
  {
    v8 = dwBytes;
    *a5 = (unsigned __int8 *)v7;
    *a6 = v8;
  }
  return v6;
}

//----- (6E64484D) --------------------------------------------------------
signed int __stdcall CImplINetCfgClass::EnumComponents(CImplINetCfgClass *this, struct IEnumNetCfgComponent **a2)
{
  signed int v2; // ebx@1

  *a2 = 0;
  v2 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplINetCfgClass *)((char *)this + 8), 0);
  if ( !v2 )
  {
    v2 = CImplIEnumNetCfgComponent::HrCreateInstance(
           *((struct CImplINetCfg **)this + 4),
           *((_DWORD *)this + 5),
           (int)a2);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 4) + 24));
  }
  return v2;
}

//----- (6E644897) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplINetCfgClass>::CComObject<CImplINetCfgClass>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 6;
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgClass>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CImplINetCfgClass>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E644030: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(CImplINetCfgClass *, struct _GUID *, void **);
// 6E6440CC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgClass>::`vftable')(int, int, int);

//----- (6E6448CE) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::AddRef(int a1)
{
  return InterlockedIncrement((volatile LONG *)(a1 + 8));
}

//----- (6E6448E9) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetId(CImplINetCfgComponent *this, unsigned __int16 **a2)
{
  signed int v2; // ebx@1

  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( v2 )
  {
    *a2 = 0;
  }
  else
  {
    v2 = HrCoTaskMemAllocAndDupSz(*(const unsigned __int16 **)(*((_DWORD *)this + 7) + 28), a2, 0xC8u);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 6) + 24));
  }
  return v2;
}

//----- (6E64493D) --------------------------------------------------------
wchar_t *__cdecl _wcslwr(wchar_t *String)
{
  wchar_t *result; // eax@2
  wchar_t *i; // ecx@3
  wchar_t v3; // dx@4

  if ( __locale_changed )
  {
    _wcslwr_s_l(String, 0xFFFFFFFF, 0);
    result = String;
  }
  else
  {
    result = String;
    if ( String )
    {
      for ( i = String; *i; ++i )
      {
        v3 = *i;
        if ( *i >= 0x41u && v3 <= 0x5Au )
          *i = v3 + 32;
      }
    }
    else
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      result = 0;
    }
  }
  return result;
}
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E644989) --------------------------------------------------------
unsigned __int32 DwFormatStringWithLocalAlloc(LPCVOID lpSource, LPWSTR lpBuffer, ...)
{
  va_list Arguments; // [sp+0h] [bp-4h]@1
  va_list va; // [sp+14h] [bp+10h]@1

  va_start(va, lpBuffer);
  Arguments = va;
  return FormatMessageW(0x500u, lpSource, 0, 0, lpBuffer, 0, &Arguments);
}

//----- (6E6449B6) --------------------------------------------------------
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::_Ufill(int this, int a2, int a3, int a4)
{
  stdext::unchecked_uninitialized_fill_n<CLanaEntry *,unsigned int,CLanaEntry,std::nc_allocator<CLanaEntry>>(
    a2,
    a3,
    a4,
    this);
  return a2 + 8 * a3;
}

//----- (6E6449DC) --------------------------------------------------------
int __stdcall stdext::unchecked_uninitialized_fill_n<CLanaEntry *,unsigned int,CLanaEntry,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_fill_n<CStackEntry *,unsigned int,CStackEntry,std::nc_allocator<CStackEntry>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E644A0A) --------------------------------------------------------
int __stdcall std::_Uninit_fill_n<CStackEntry *,unsigned int,CStackEntry,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@2

  while ( a2 )
  {
    result = std::_Construct<CStackEntry,CStackEntry>(a1, a3);
    --a2;
    a1 += 8;
  }
  return result;
}
// 6E64345D: using guessed type _DWORD __stdcall std::_Construct<CStackEntry,CStackEntry>(_DWORD, _DWORD);

//----- (6E644A32) --------------------------------------------------------
signed int __stdcall CComponent::HrCreateInstance(const struct BASIC_COMPONENT_DATA *a1, char a2, const struct tagOBO_TOKEN *lpMem, struct CComponent **a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // edi@1
  unsigned int v6; // eax@1
  void *v7; // eax@1
  void *v8; // ebx@2
  int v9; // eax@4
  unsigned __int16 *v11; // eax@8
  unsigned int v12; // [sp+Ch] [bp-10h]@1
  struct CComponent *v13; // [sp+10h] [bp-Ch]@3
  unsigned int v14; // [sp+14h] [bp-8h]@1
  signed int v15; // [sp+18h] [bp-4h]@1

  v4 = CbOfSzAndTerm(*((const unsigned __int16 **)a1 + 8));
  v5 = v4;
  v12 = v4;
  v6 = CbOfSzAndTermSafe(*((const unsigned __int16 **)a1 + 9));
  v14 = v6;
  v15 = -2147024882;
  v7 = operator new(0xACu, (const struct extrabytes_t *)&extrabytes, v5 + v6);
  if ( v7 )
    v8 = CComponent::CComponent(v7);
  else
    v8 = 0;
  v13 = (struct CComponent *)v8;
  if ( v8 )
  {
    v15 = 0;
    memset(v8, 0, 0xACu);
    *(_DWORD *)v8 = *(_DWORD *)a1;
    *((_DWORD *)v8 + 1) = *((_DWORD *)a1 + 1);
    *((_DWORD *)v8 + 2) = *((_DWORD *)a1 + 2);
    *((_DWORD *)v8 + 3) = *((_DWORD *)a1 + 3);
    *((_DWORD *)v8 + 4) = *((_DWORD *)a1 + 4);
    *((_DWORD *)v8 + 6) = *((_DWORD *)a1 + 5);
    *((_DWORD *)v8 + 33) = *((_DWORD *)a1 + 6);
    v9 = *((_DWORD *)a1 + 7);
    *((_DWORD *)v8 + 42) = 0;
    *((_DWORD *)v8 + 34) = v9;
    *((_DWORD *)v8 + 7) = (char *)v8 + 172;
    StringCbCopyW((unsigned __int16 *)v8 + 86, v12, *((const unsigned __int16 **)a1 + 8));
    _wcslwr(*((wchar_t **)v8 + 7));
    if ( v14 )
    {
      v11 = (unsigned __int16 *)(v12 + *((_DWORD *)v8 + 7));
      *((_DWORD *)v8 + 8) = v11;
      StringCbCopyW(v11, v14, *((const unsigned __int16 **)a1 + 9));
    }
    if ( a2 & 1
      && (v15 = CExternalComponentData::HrEnsureExternalDataLoaded((CExternalComponentData *)((char *)v8 + 36))) != 0
      || lpMem
      && (v15 = CComponentReferences::HrAddReferenceByOboToken((CComponentReferences *)((char *)v8 + 120), lpMem)) != 0 )
    {
      CComponent::`scalar deleting destructor'(v8, 1);
      v13 = 0;
    }
  }
  *a4 = v13;
  return v15;
}

//----- (6E644B38) --------------------------------------------------------
signed int __stdcall StringCbCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3)
{
  int v3; // edx@1
  signed int result; // eax@1

  v3 = a2 >> 1;
  result = 0;
  if ( !(a2 >> 1) || (unsigned int)v3 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    result = sub_6E641D2F((int)a3, v3, (int)a1, 0, 2147483646);
  return result;
}

//----- (6E644BA5) --------------------------------------------------------
unsigned __int16 *__stdcall HrLoadNetworkConfigurationFromBuffer(const unsigned __int8 *a1, unsigned __int32 a2, struct CNetConfig *a3)
{
  BOOL v3; // ecx@1
  BOOL v4; // ecx@1
  unsigned __int32 v5; // edi@1
  BOOL v6; // ecx@2
  const unsigned __int8 *v7; // ebx@2
  BOOL v8; // ecx@3
  unsigned __int32 v9; // edi@3
  BOOL v10; // ecx@4
  int v11; // ebx@4
  BOOL v12; // ecx@5
  unsigned int v13; // ebx@6
  BOOL v14; // ecx@6
  unsigned int v15; // eax@6
  BOOL v16; // ecx@6
  unsigned int v17; // ebx@7
  BOOL v18; // ecx@7
  unsigned int v19; // eax@7
  BOOL v20; // ecx@7
  unsigned __int16 *v21; // ebx@8
  unsigned int v22; // eax@8
  BOOL v23; // ecx@8
  const unsigned __int16 *v24; // ebx@8
  unsigned int v25; // eax@8
  BOOL v26; // ecx@8
  unsigned int v27; // eax@8
  int v28; // esi@8
  unsigned int v29; // eax@8
  BOOL v30; // ecx@8
  unsigned int v31; // eax@8
  const unsigned __int16 *v32; // ST0C_4@8
  unsigned int v33; // eax@8
  BOOL v34; // ecx@8
  unsigned int v35; // eax@8
  unsigned __int32 v36; // edi@13
  CBindPath *v37; // ecx@14
  unsigned int v38; // ebx@14
  BOOL v39; // ecx@14
  BOOL v40; // ecx@14
  unsigned __int32 v41; // edi@14
  BOOL v42; // ecx@15
  unsigned int v43; // ebx@15
  unsigned int v44; // eax@16
  BOOL v45; // ecx@16
  unsigned int v46; // ebx@17
  BOOL v47; // ecx@17
  unsigned int v48; // eax@17
  BOOL v49; // ecx@17
  unsigned int v50; // edi@18
  struct CComponent *v51; // eax@18
  unsigned int v52; // ST0C_4@18
  CBindPath *v53; // edi@18
  struct CComponent *v54; // eax@18
  BOOL v55; // ecx@23
  unsigned __int32 v56; // edi@23
  BOOL v57; // ecx@24
  unsigned int *v58; // ebx@24
  BOOL v59; // ecx@26
  BOOL v60; // ecx@27
  BOOL v61; // ecx@29
  struct CComponent *v62; // eax@30
  BOOL v63; // ecx@37
  unsigned int v64; // edi@38
  int v65; // ebx@38
  const struct CComponent *v66; // eax@38
  BOOL v67; // ecx@39
  unsigned __int32 v68; // edi@40
  BOOL v69; // ecx@42
  unsigned __int32 v70; // edi@42
  BOOL v71; // ecx@43
  int v72; // ebx@43
  BOOL v73; // ecx@44
  unsigned __int32 v74; // edi@44
  unsigned int v75; // ebx@45
  BOOL v76; // ecx@45
  BOOL v77; // ecx@46
  unsigned __int32 v78; // edi@46
  BOOL v79; // ecx@47
  unsigned int v80; // ebx@47
  BOOL v81; // ecx@49
  unsigned int v82; // eax@50
  BOOL v83; // ecx@51
  unsigned int v84; // eax@52
  unsigned int v86; // eax@58
  BOOL v87; // ecx@58
  unsigned int v88; // eax@58
  BOOL v89; // ecx@58
  int v90; // esi@61
  char v91; // [sp+Ch] [bp-70h]@31
  char v92; // [sp+10h] [bp-6Ch]@1
  struct CComponent *v93; // [sp+20h] [bp-5Ch]@1
  struct CComponent *v94; // [sp+24h] [bp-58h]@1
  struct CComponent *v95; // [sp+28h] [bp-54h]@9
  CBindPath *v96; // [sp+2Ch] [bp-50h]@1
  unsigned int v97; // [sp+30h] [bp-4Ch]@17
  unsigned int v98; // [sp+34h] [bp-48h]@4
  unsigned __int16 *v99; // [sp+38h] [bp-44h]@1
  unsigned int v100; // [sp+3Ch] [bp-40h]@2
  unsigned __int32 v101; // [sp+40h] [bp-3Ch]@3
  char v102; // [sp+44h] [bp-38h]@5
  int v103; // [sp+48h] [bp-34h]@6
  int v104; // [sp+4Ch] [bp-30h]@6
  int v105; // [sp+50h] [bp-2Ch]@6
  int v106; // [sp+54h] [bp-28h]@7
  int v107; // [sp+58h] [bp-24h]@8
  unsigned __int16 *v108; // [sp+64h] [bp-18h]@8
  int v109; // [sp+68h] [bp-14h]@33
  int v110; // [sp+78h] [bp-4h]@1

  v96 = a3;
  v94 = 0;
  v93 = 0;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v92, 0);
  v110 = 0;
  v99 = 0;
  v5 = ALIGNUP(v3, 4u);
  if ( a2 >= v5 )
  {
    v100 = *(_DWORD *)a1;
    v7 = &a1[ALIGNUP(v4, 4u)];
    if ( v100 )
    {
      v99 = (unsigned __int16 *)-2147418113;
LABEL_61:
      v90 = (int)v96;
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)v96 + 48));
      std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::clear(v90 + 24);
      FreeCollectionAndItem<CComponentList>(v90);
    }
    else
    {
      v9 = ALIGNUP(v6, 4u) + v5;
      v101 = v9;
      if ( a2 >= v9 )
      {
        v98 = *(_DWORD *)v7;
        v11 = (int)&v7[ALIGNUP(v8, 4u)];
        if ( v98 )
        {
          while ( 1 )
          {
            --v98;
            memset(&v102, 0, 0x28u);
            v101 += ALIGNUP(0, 0x10u);
            if ( a2 < v101 )
              break;
            *(_DWORD *)&v102 = *(_DWORD *)v11;
            v103 = *(_DWORD *)(v11 + 4);
            v104 = *(_DWORD *)(v11 + 8);
            v105 = *(_DWORD *)(v11 + 12);
            v13 = ALIGNUP(v12, 0x10u) + v11;
            v15 = ALIGNUP(v14, 4u);
            v101 += v15;
            if ( a2 < v101 )
              break;
            v106 = *(_DWORD *)v13;
            v17 = ALIGNUP(v16, 4u) + v13;
            v19 = ALIGNUP(v18, 4u);
            v101 += v19;
            if ( a2 < v101 )
              break;
            v107 = *(_DWORD *)v17;
            v21 = (unsigned __int16 *)(ALIGNUP(v20, 4u) + v17);
            v108 = v21;
            v22 = CbOfSzAndTerm(v21);
            v24 = (unsigned __int16 *)((char *)v21 + ALIGNUP(v23, v22));
            v25 = CbOfSzAndTerm(v108);
            v27 = ALIGNUP(v26, v25);
            v101 += v27;
            v28 = (int)v24;
            v29 = CbOfSzAndTerm(v24);
            v31 = ALIGNUP(v30, v29);
            v32 = v24;
            v11 = (int)((char *)v24 + v31);
            v33 = CbOfSzAndTerm(v32);
            v35 = ALIGNUP(v34, v33);
            v101 += v35;
            if ( *(_WORD *)v28 )
              v109 = v28;
            v99 = (unsigned __int16 *)CComponent::HrCreateInstance(
                                        (const struct BASIC_COMPONENT_DATA *)&v102,
                                        0,
                                        0,
                                        &v95);
            if ( v99 )
              goto LABEL_61;
            v99 = (unsigned __int16 *)CComponentList::HrInsertComponent(v96, v95, 0x2100u);
            if ( v99 )
              goto LABEL_61;
            if ( !v98 )
            {
              v9 = v101;
              goto LABEL_13;
            }
          }
        }
        else
        {
LABEL_13:
          v36 = ALIGNUP(v10, 4u) + v9;
          if ( a2 >= v36 )
          {
            v37 = v96;
            *((_DWORD *)v96 + 10) = *(_DWORD *)v11;
            v38 = ALIGNUP((BOOL)v37, 4u) + v11;
            v41 = ALIGNUP(v39, 4u) + v36;
            v101 = v41;
            if ( a2 >= v41 )
            {
              v100 = *(_DWORD *)v38;
              v43 = ALIGNUP(v40, 4u) + v38;
              if ( v100 )
              {
                while ( 1 )
                {
                  --v100;
                  v93 = 0;
                  v94 = 0;
                  v44 = ALIGNUP(v42, 4u);
                  v101 += v44;
                  if ( a2 < v101 )
                    break;
                  v97 = *(_DWORD *)v43;
                  v46 = ALIGNUP(v45, 4u) + v43;
                  v48 = ALIGNUP(v47, 4u);
                  v101 += v48;
                  if ( a2 < v101 )
                    break;
                  v50 = *(_DWORD *)v46;
                  v43 = ALIGNUP(v49, 4u) + v46;
                  v51 = CBindPath::PGetComponentAtIndex(v96, v97);
                  v52 = v50;
                  v53 = v96;
                  v93 = v51;
                  v54 = CBindPath::PGetComponentAtIndex(v96, v52);
                  v94 = v54;
                  if ( !v93 || !v54 )
                  {
LABEL_57:
                    v99 = (unsigned __int16 *)-2147024809;
                    goto LABEL_61;
                  }
                  v99 = (unsigned __int16 *)CStackTable::HrInsertStackEntry(
                                              (CBindPath *)((char *)v53 + 20),
                                              (const struct CStackEntry *)&v93,
                                              0x2000u);
                  if ( v99 )
                    goto LABEL_61;
                  if ( !v100 )
                  {
                    v41 = v101;
                    goto LABEL_23;
                  }
                }
              }
              else
              {
LABEL_23:
                v56 = ALIGNUP(v42, 4u) + v41;
                if ( a2 >= v56 )
                {
                  v100 = *(_DWORD *)v43;
                  v58 = (unsigned int *)(ALIGNUP(v55, 4u) + v43);
                  while ( v100 )
                  {
                    --v100;
                    v56 += ALIGNUP(v57, 4u);
                    if ( a2 < v56 )
                      goto LABEL_55;
                    v98 = *v58;
                    v58 = (unsigned int *)((char *)v58 + ALIGNUP(v59, 4u));
                    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)&v92);
                    while ( v98 )
                    {
                      --v98;
                      v56 += ALIGNUP(v60, 4u);
                      if ( a2 < v56 )
                        goto LABEL_55;
                      v97 = *v58;
                      v58 = (unsigned int *)((char *)v58 + ALIGNUP(v61, 4u));
                      v62 = CBindPath::PGetComponentAtIndex(v96, v97);
                      v95 = v62;
                      if ( !v62 )
                        goto LABEL_57;
                      v99 = (unsigned __int16 *)CBindPath::HrAppendComponent((CBindPath *)&v91, v62);
                      if ( v99 )
                        goto LABEL_61;
                    }
                    v99 = (unsigned __int16 *)CBindingSet::HrAddBindPath(
                                                (CBindPath *)((char *)v96 + 44),
                                                (const struct CBindPath *)&v91,
                                                0x500u);
                    if ( v99 )
                      goto LABEL_61;
                  }
                  v70 = ALIGNUP(v57, 4u) + v56;
                  if ( a2 >= v70 )
                  {
                    v98 = *v58;
                    v72 = (int)((char *)v58 + ALIGNUP(v69, 4u));
                    if ( v98 )
                    {
                      while ( 1 )
                      {
                        --v98;
                        v74 = ALIGNUP(v71, 4u) + v70;
                        if ( a2 < v74 )
                          break;
                        v97 = *(_DWORD *)v72;
                        v75 = ALIGNUP(v73, 4u) + v72;
                        v95 = CBindPath::PGetComponentAtIndex(v96, v97);
                        if ( !v95 )
                          goto LABEL_57;
                        v78 = ALIGNUP(v76, 4u) + v74;
                        if ( a2 < v78 )
                          break;
                        v100 = *(_DWORD *)v75;
                        v80 = ALIGNUP(v77, 4u) + v75;
                        if ( v100 )
                        {
                          v99 = (unsigned __int16 *)CComponentReferences::HrAddReferenceByUser((struct CComponent *)((char *)v95 + 120));
                          if ( v99 )
                            goto LABEL_61;
                        }
                        v68 = ALIGNUP(v79, 4u) + v78;
                        if ( a2 < v68 )
                          break;
                        v100 = *(_DWORD *)v80;
                        v82 = ALIGNUP(v81, 4u);
                        v97 = 0;
                        v65 = v82 + v80;
                        if ( v100 )
                        {
                          do
                          {
                            v101 = ALIGNUP(v67, 4u) + v68;
                            if ( a2 < v101 )
                              goto LABEL_54;
                            v64 = *(_DWORD *)v65;
                            v65 += ALIGNUP(v63, 4u);
                            v66 = CBindPath::PGetComponentAtIndex(v96, v64);
                            if ( !v66 )
                            {
                              v99 = (unsigned __int16 *)-2147024809;
                              goto LABEL_54;
                            }
                            v99 = (unsigned __int16 *)CComponentReferences::HrAddReferenceByComponent(
                                                        (struct CComponent *)((char *)v95 + 120),
                                                        v66);
                            if ( v99 )
                              goto LABEL_61;
                            ++v97;
                            v68 = v101;
                          }
                          while ( v97 < v100 );
                        }
                        v70 = ALIGNUP(v67, 4u) + v68;
                        if ( a2 >= v70 )
                        {
                          v100 = *(_DWORD *)v65;
                          v84 = ALIGNUP(v83, 4u);
                          v97 = 0;
                          v72 = v84 + v65;
                          if ( v100 )
                          {
                            do
                            {
                              v99 = (unsigned __int16 *)v72;
                              v86 = CbOfSzAndTerm((const unsigned __int16 *)v72);
                              v72 += ALIGNUP(v87, v86);
                              v88 = CbOfSzAndTerm(v99);
                              v70 += ALIGNUP(v89, v88);
                              v99 = (unsigned __int16 *)CComponentReferences::HrAddReferenceBySoftware(
                                                          (struct CComponent *)((char *)v95 + 120),
                                                          v99);
                              if ( v99 )
                                goto LABEL_61;
                              ++v97;
                            }
                            while ( v97 < v100 );
                          }
                          if ( v98 )
                            continue;
                        }
                        break;
                      }
LABEL_54:
                      if ( v99 )
                        goto LABEL_61;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_55:
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v92);
  return v99;
}

//----- (6E644EE5) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Insert_n(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  int result; // eax@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // ebx@4
  int v10; // eax@5
  int v11; // eax@10
  int v12; // ebx@10
  int v13; // eax@10
  int v14; // eax@10
  int v15; // edi@10
  int v16; // eax@10
  int v17; // [sp+Ch] [bp-18h]@1
  int v18; // [sp+10h] [bp-14h]@1
  int v19; // [sp+20h] [bp-4h]@5
  unsigned int v20; // [sp+34h] [bp+10h]@1
  int v21; // [sp+34h] [bp+10h]@8

  v4 = this;
  v5 = *(_DWORD *)(a4 + 4);
  v17 = *(_DWORD *)a4;
  v18 = v5;
  result = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(this);
  v20 = result;
  if ( a3 )
  {
    v7 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(v4);
    if ( 0x1FFFFFFF - v7 < (unsigned int)a3 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v8 = a3 + v7;
    if ( v20 < v8 )
    {
      if ( 0x1FFFFFFF - (v20 >> 1) < v20 )
        v21 = 0;
      else
        v21 = (v20 >> 1) + v20;
      if ( v21 < (unsigned int)v8 )
        v21 = v8;
      v11 = (int)std::_Allocate<CStackEntry>(v21, 0);
      v19 = 0;
      v12 = v11;
      v13 = std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
              *(_DWORD *)(v4 + 4),
              a2,
              v11,
              v4);
      v14 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::_Ufill(v4, v13, a3, (int)&v17);
      std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
        a2,
        *(_DWORD *)(v4 + 8),
        v14,
        v4);
      v15 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(v4) + a3;
      v16 = *(_DWORD *)(v4 + 4);
      if ( v16 )
      {
        while ( v16 != *(_DWORD *)(v4 + 8) )
          v16 += 8;
        operator delete(*(void **)(v4 + 4));
      }
      *(_DWORD *)(v4 + 12) = v12 + 8 * v21;
      result = v12 + 8 * v15;
      *(_DWORD *)(v4 + 8) = result;
      *(_DWORD *)(v4 + 4) = v12;
    }
    else
    {
      v9 = *(_DWORD *)(v4 + 8);
      if ( (*(_DWORD *)(v4 + 8) - a2) >> 3 >= (unsigned int)a3 )
      {
        *(_DWORD *)(v4 + 8) = std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
                                v9 - 8 * a3,
                                v9,
                                v9,
                                v4);
        std::copy_backward<CLanaEntry *,CLanaEntry *>(a2, v9 - 8 * a3, v9);
        result = std::fill<CStackEntry *,CStackEntry>(a2, a2 + 8 * a3, (int)&v17);
      }
      else
      {
        std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(a2, v9, a2 + 8 * a3, v4);
        v10 = *(_DWORD *)(v4 + 8);
        v19 = 2;
        std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::_Ufill(v4, v10, a3 - ((v10 - a2) >> 3), (int)&v17);
        *(_DWORD *)(v4 + 8) += 8 * a3;
        result = std::fill<CStackEntry *,CStackEntry>(a2, *(_DWORD *)(v4 + 8) - 8 * a3, (int)&v17);
      }
    }
  }
  return result;
}

//----- (6E64502C) --------------------------------------------------------
signed int __stdcall CImplIEnumNetCfgComponent::Next(CImplIEnumNetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent **Dst, unsigned __int32 *a4)
{
  signed int result; // eax@3

  if ( Dst && (a4 || a2 == 1) )
    result = CImplIEnumNetCfgComponent::HrNextOrSkip(this, a2, Dst, a4);
  else
    result = -2147467261;
  return result;
}

//----- (6E64505F) --------------------------------------------------------
signed int __thiscall CImplIEnumNetCfgComponent::HrNextOrSkip(CImplIEnumNetCfgComponent *this, unsigned __int32 a2, struct INetCfgComponent **Dst, unsigned __int32 *a4)
{
  CImplIEnumNetCfgComponent *v4; // esi@1
  CBindPath *v5; // ebx@4
  struct CComponent *v6; // edi@6
  int v7; // eax@7
  struct INetCfgComponent **v9; // [sp+8h] [bp-Ch]@4
  unsigned __int32 v10; // [sp+Ch] [bp-8h]@4
  signed int v11; // [sp+10h] [bp-4h]@3

  v4 = this;
  if ( Dst )
    memset(Dst, 0, 4 * a2);
  v11 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplIEnumNetCfgComponent *)((char *)v4 + 4), 0);
  if ( !v11 )
  {
    v10 = 0;
    v5 = *(CBindPath **)(*((_DWORD *)v4 + 3) + 48);
    v9 = Dst;
    do
    {
      if ( v10 >= a2 )
        break;
      v6 = CBindPath::PGetComponentAtIndex(v5, *((_DWORD *)v4 + 4));
      if ( !v6 )
        break;
      v7 = *((_DWORD *)v4 + 5);
      if ( (v7 == 6 || v7 == *((_DWORD *)v6 + 4))
        && CExternalComponentData::FLoadedOkayIfLoadedAtAll((struct CComponent *)((char *)v6 + 36)) )
      {
        if ( Dst )
          v11 = CComponent::HrGetINetCfgComponentInterface(v6, *((struct CImplINetCfg **)v4 + 3), v9);
        ++v10;
        ++v9;
      }
      ++*((_DWORD *)v4 + 4);
    }
    while ( !v11 );
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v4 + 3) + 24));
    v11 = HrFinishNextOrSkipContract(v11, v10, a2, (struct IUnknown **)Dst, a4);
  }
  return v11;
}

//----- (6E645298) --------------------------------------------------------
signed int __thiscall CComponentReferences::HrAddReferenceByUser(CComponentReferences *this)
{
  CComponentReferences *v1; // esi@1
  signed int result; // eax@1

  v1 = this;
  result = CComponentReferences::HrEnsureAllocated(this);
  if ( !result )
    *(_BYTE *)(*(_DWORD *)v1 + 36) = 1;
  return result;
}

//----- (6E6452B3) --------------------------------------------------------
signed int __thiscall CComponentReferences::HrEnsureAllocated(CComponentReferences *this)
{
  CComponentReferences *v1; // esi@1
  void *v2; // edi@1
  signed int v3; // ebx@2
  void *v4; // ecx@2
  signed int result; // eax@6

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)this )
  {
    result = 0;
  }
  else
  {
    v3 = -2147024882;
    v4 = operator new(0x28u);
    if ( v4 )
      v2 = COMPONENT_REFERENCE_DATA::COMPONENT_REFERENCE_DATA(v4);
    *(_DWORD *)v1 = v2;
    if ( v2 )
    {
      memset(v2, 0, 0x28u);
      v3 = 0;
    }
    result = v3;
  }
  return result;
}

//----- (6E645330) --------------------------------------------------------
int __stdcall RegQueryValues(HKEY a1, unsigned __int32 a2, DWORD Type, unsigned __int8 *a4, unsigned __int8 *a5, unsigned __int32 *a6)
{
  const WCHAR v6; // dx@38
  unsigned __int32 v7; // edi@1
  DWORD v8; // esi@2
  struct _GUID *v9; // ebx@3
  int v10; // eax@4
  int v11; // eax@9
  int v12; // ecx@11
  LPCWSTR v13; // eax@11
  bool v14; // cf@12
  int v15; // eax@13
  __int32 v16; // eax@16
  int result; // eax@25
  unsigned __int32 v18; // [sp+4h] [bp-10h]@1
  int v19; // [sp+8h] [bp-Ch]@4
  unsigned __int32 v20; // [sp+Ch] [bp-8h]@1
  HKEY hKey; // [sp+10h] [bp-4h]@1

  v7 = 0;
  v18 = *a6;
  v20 = 0;
  hKey = a1;
  if ( !a2 )
    goto LABEL_24;
  v8 = Type + 4;
  do
  {
    v9 = 0;
    if ( !*(_DWORD *)(v8 - 4) )
      goto LABEL_45;
    if ( hKey != a1 )
      RegCloseKey(hKey);
    if ( !RegOpenKeyExW(a1, *(LPCWSTR *)(v8 - 4), 0, 0x20019u, &hKey) )
    {
LABEL_45:
      v10 = v7 & 3;
      v19 = v7 & 3;
      if ( v7 & 3 )
      {
        v7 += 4 - v10;
        v19 = 4 - v10;
        v20 = v7;
      }
      if ( a5 )
        v9 = (struct _GUID *)&a5[v7];
      if ( v18 <= v7 )
      {
        v9 = 0;
        Type = 0;
      }
      else
      {
        Type = v18 - v7;
      }
      v11 = *(_DWORD *)(v8 + 4);
      if ( v11 == -5 )
      {
        v16 = RegQueryGuid(hKey, *(LPCWSTR *)v8, v9, &Type);
      }
      else
      {
        if ( v11 == 1 )
        {
          v12 = (int)L"HelpText";
          v13 = *(LPCWSTR *)v8;
          do
          {
            v14 = *v13 < *(_WORD *)v12;
            if ( *v13 != *(_WORD *)v12 )
              goto LABEL_46;
            if ( !*v13 )
              break;
            v6 = v13[1];
            v14 = v6 < *(_WORD *)(v12 + 2);
            if ( v6 != *(_WORD *)(v12 + 2) )
            {
LABEL_46:
              v15 = -v14 - (v14 - 1);
              goto LABEL_14;
            }
            v13 += 2;
            v12 += 4;
          }
          while ( v6 );
          v15 = 0;
LABEL_14:
          if ( !v15 )
          {
            v16 = NcLoadRegUIString(hKey, *(const unsigned __int16 **)v8, (unsigned __int8 *)v9, &Type);
            v7 = v20;
            goto LABEL_17;
          }
          v7 = v20;
        }
        v16 = RegQueryValueType(hKey, *(LPCWSTR *)v8, *(_DWORD *)(v8 + 4), (LPBYTE)v9, (DWORD)&Type);
      }
LABEL_17:
      if ( v16 && v16 != 234 )
        v7 -= v19;
      else
        v7 += Type;
      v20 = v7;
      if ( !v16 && v9 )
        *(_DWORD *)&a4[*(_DWORD *)(v8 + 8)] = v9;
    }
    v8 += 16;
    --a2;
  }
  while ( a2 );
  if ( hKey != a1 )
    RegCloseKey(hKey);
LABEL_24:
  *a6 = v7;
  if ( v7 > v18 )
    result = a5 != 0 ? 0xEA : 0;
  else
    result = 0;
  return result;
}
// 6E645428: using guessed type wchar_t aHelptext[9];

//----- (6E645465) --------------------------------------------------------
__int32 __stdcall RegQueryGuid(HKEY hKey, LPCWSTR lpValueName, struct _GUID *a3, unsigned __int32 *a4)
{
  unsigned __int32 v4; // ebx@1
  __int32 v5; // eax@1
  char *v7; // edi@7
  DWORD Type; // [sp+Ch] [bp-6Ch]@1
  __int32 v9; // [sp+10h] [bp-68h]@1
  IID iid; // [sp+14h] [bp-64h]@4
  OLECHAR sz; // [sp+24h] [bp-54h]@1

  v4 = *a4;
  *a4 = 0;
  Type = 78;
  v5 = RegQueryValueType(hKey, lpValueName, 1u, (LPBYTE)&sz, (DWORD)&Type);
  v9 = v5;
  if ( v5 )
  {
    if ( v5 != 234 )
      return v9;
    return 1804;
  }
  if ( IIDFromString(&sz, &iid) )
    return 1804;
  *a4 = 16;
  if ( a3 )
  {
    if ( v4 < 0x10 )
    {
      v9 = 234;
    }
    else
    {
      a3->Data1 = iid.Data1;
      *(_DWORD *)&a3->Data2 = *(_DWORD *)&iid.Data2;
      v7 = (char *)a3->Data4;
      *(_DWORD *)v7 = *(_DWORD *)&iid.Data4[0];
      *((_DWORD *)v7 + 1) = *(_DWORD *)&iid.Data4[4];
    }
  }
  return v9;
}

//----- (6E6454D2) --------------------------------------------------------
__int32 __stdcall RegQueryValueType(HKEY hKey, LPCWSTR lpValueName, unsigned __int32 a3, LPBYTE lpData, DWORD Type)
{
  __int32 result; // eax@1

  result = RegQueryValueExW(hKey, lpValueName, 0, &Type, lpData, (LPDWORD)Type);
  if ( !result && a3 != Type )
    result = 1804;
  return result;
}

//----- (6E645509) --------------------------------------------------------
DWORD __stdcall HrBuildBindNameFromBindForm(const void *a1, int a2, char a3, int a4, int a5, GUID *rguid, WCHAR *lpBuffer)
{
  const void *v7; // esi@1
  wchar_t *i; // eax@4
  wchar_t *v9; // esi@5
  int v11; // edx@14
  wchar_t v12; // cx@15
  DWORD v13; // eax@17
  DWORD v14; // [sp+10h] [bp-58h]@1
  OLECHAR sz; // [sp+14h] [bp-54h]@1

  v14 = 0;
  v7 = a1;
  StringFromGUID2(rguid, &sz, 39);
  if ( FIsPhysicalAdapter(a2, a3) )
    goto LABEL_2;
  if ( !a1 || !*(_WORD *)a1 )
  {
    if ( FIsConsideredNetClass(a2) )
    {
LABEL_2:
      v7 = L"%3";
      goto LABEL_3;
    }
    if ( !a4 || (v7 = L"%1", !*(_WORD *)a4) )
      v7 = L"%2";
  }
LABEL_3:
  DwFormatStringWithLocalAlloc(v7, lpBuffer, a4, a5, &sz);
  if ( *(_DWORD *)lpBuffer )
  {
    for ( i = wcschr(*(const wchar_t **)lpBuffer, 0x5Fu); ; i = wcschr(v9, 0x5Fu) )
    {
      v9 = i;
      if ( !i )
        break;
      v11 = (int)(i + 1);
      do
      {
        v12 = *i;
        ++i;
      }
      while ( v12 );
      StringCchCopyW(v9, (signed int)((char *)i - v11) >> 1, v9 + 1);
    }
  }
  else
  {
    v13 = GetLastError();
    if ( (signed int)v13 > 0 )
      v13 = (unsigned __int16)v13 | 0x80070000;
    v14 = v13;
  }
  return v14;
}
// 6E6455A0: using guessed type wchar_t a3[3];
// 6E6515EC: using guessed type wchar_t a2[3];
// 6E6515F4: using guessed type wchar_t a1_0[3];

//----- (6E6455AB) --------------------------------------------------------
wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch)
{
  wchar_t *result; // eax@1

  for ( result = (wchar_t *)Str; *result; ++result )
  {
    if ( *result == Ch )
      return result;
  }
  if ( *result != Ch )
    result = 0;
  return result;
}

//----- (6E6455D6) --------------------------------------------------------
__int32 __thiscall CStackTable::HrInsertStackEntry(CStackTable *this, const struct CStackEntry *a2, unsigned __int32 a3)
{
  CStackTable *v3; // ebx@1
  int v4; // eax@1
  unsigned __int32 v5; // ecx@1
  unsigned __int32 v6; // esi@1
  int v8; // [sp+Ch] [bp-18h]@1
  CComponent *v9; // [sp+10h] [bp-14h]@1

  v3 = this;
  v4 = *(_DWORD *)a2;
  v9 = (CComponent *)*((_DWORD *)a2 + 1);
  v5 = *((_DWORD *)this + 3);
  v8 = *(_DWORD *)a2;
  v6 = v5;
  if ( a3 & 0x1000 )
  {
    v6 = *((_DWORD *)v3 + 2);
    a3 = 0;
    if ( v6 != v5 )
    {
      while ( *(_DWORD *)(v4 + 16) < *(_DWORD *)(*(_DWORD *)v6 + 16) )
      {
        v6 += 8;
        if ( v6 == v5 )
          goto LABEL_10;
      }
      a3 = v6;
LABEL_10:
      while ( v6 != v5 )
      {
        if ( v4 == *(_DWORD *)v6 )
        {
          if ( wcscmp(*((const unsigned __int16 **)v9 + 7), L"ms_netbt") == 0 )
          {
            while ( v6 != v5 && v8 == *(_DWORD *)v6 )
              v6 += 8;
          }
          else if ( CComponent::FIsWanAdapter(v9) && !*((_DWORD *)v3 + 5) )
          {
            while ( v6 != *((_DWORD *)v3 + 3) && v8 == *(_DWORD *)v6 )
              v6 += 8;
          }
          goto LABEL_2;
        }
        v6 += 8;
      }
    }
    if ( a3 )
      v6 = a3;
  }
LABEL_2:
  std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::insert((int)((char *)v3 + 4), (int)&a2, v6, (int)a2);
  a2 = 0;
  return 0;
}
// 6E658DF4: using guessed type wchar_t aMs_netbt[9];

//----- (6E64562C) --------------------------------------------------------
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::insert(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@3

  v4 = this;
  if ( std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(this) )
    v5 = (a3 - *(_DWORD *)(v4 + 4)) >> 3;
  else
    v5 = 0;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Insert_n(v4, a3, 1, a4);
  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4) + 8 * v5;
  return result;
}

//----- (6E645685) --------------------------------------------------------
__int32 __thiscall HrSetupDiGetDeviceName(DWORD this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD RequiredSize)
{
  __int32 result; // eax@1
  DWORD PropertyRegDataType; // [sp+0h] [bp-4h]@1

  PropertyRegDataType = this;
  result = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
             DeviceInfoSet,
             DeviceInfoData,
             0xCu,
             &PropertyRegDataType,
             RequiredSize);
  if ( result < 0 )
    result = HrSetupDiGetDeviceRegistryPropertyWithAlloc(
               DeviceInfoSet,
               DeviceInfoData,
               0,
               &PropertyRegDataType,
               RequiredSize);
  return result;
}

//----- (6E6456C0) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDeviceRegistryPropertyWithAlloc(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, DWORD RequiredSize)
{
  DWORD v5; // edi@1
  BYTE *v6; // eax@3
  __int32 result; // eax@5

  v5 = RequiredSize;
  *(_DWORD *)RequiredSize = 0;
  if ( SetupDiGetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, 0, 0, 0, &RequiredSize) )
  {
    result = -2147467259;
  }
  else
  {
    if ( GetLastError() != 122 )
    {
LABEL_7:
      MemFree(*(void **)v5);
      *(_DWORD *)v5 = 0;
      return HrFromLastWin32Error();
    }
    v6 = (BYTE *)MemAlloc(RequiredSize);
    *(_DWORD *)v5 = v6;
    if ( v6 )
    {
      if ( SetupDiGetDeviceRegistryPropertyW(
             DeviceInfoSet,
             DeviceInfoData,
             Property,
             PropertyRegDataType,
             v6,
             RequiredSize,
             0) )
        return 0;
      goto LABEL_7;
    }
    result = -2147024882;
  }
  return result;
}

//----- (6E6458F5) --------------------------------------------------------
__int32 __stdcall HrCiHideIrrelevantFilterServices(void *a1, const struct CComponent *const a2)
{
  struct _GUID v2; // ST0C_16@1
  __int32 i; // ebx@1
  unsigned __int32 v4; // ecx@18
  unsigned __int32 v5; // ecx@19
  struct _SP_DRVINSTALL_PARAMS DriverInstallParams; // [sp+Ch] [bp-874h]@3
  int v8; // [sp+20h] [bp-860h]@1
  CComponent *v9; // [sp+24h] [bp-85Ch]@1
  DWORD Type; // [sp+28h] [bp-858h]@12
  int v11; // [sp+2Ch] [bp-854h]@3
  DWORD MemberIndex; // [sp+30h] [bp-850h]@2
  unsigned __int32 IntegerValue; // [sp+34h] [bp-84Ch]@7
  int v14; // [sp+38h] [bp-848h]@3
  HKEY RelativeKeyRoot; // [sp+3Ch] [bp-844h]@1
  struct _SP_DRVINFO_DETAIL_DATA_W *v16; // [sp+40h] [bp-840h]@4
  HINF InfHandle; // [sp+44h] [bp-83Ch]@5
  HKEY phkResult; // [sp+48h] [bp-838h]@18
  HDEVINFO DeviceInfoSet; // [sp+4Ch] [bp-834h]@1
  void *lpMem; // [sp+50h] [bp-830h]@12
  HKEY hKey; // [sp+54h] [bp-82Ch]@12
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+58h] [bp-828h]@2
  WCHAR Section; // [sp+674h] [bp-20Ch]@6

  v9 = a2;
  *(_QWORD *)&v2.Data1 = *(_QWORD *)a2;
  *(_DWORD *)&v2.Data4[0] = *((_DWORD *)a2 + 2);
  DeviceInfoSet = a1;
  *(_DWORD *)&v2.Data4[4] = *((_DWORD *)a2 + 3);
  v8 = FIsIscsiNicFromNdisNsi(v2);
  i = HrRegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Control\\Network\\FTempKey",
        0,
        0xF003Fu,
        0,
        &RelativeKeyRoot,
        0);
  if ( !i )
  {
    MemberIndex = 0;
    for ( i = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, 0, &Dst);
          !i;
          i = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, MemberIndex, &Dst) )
    {
      ++MemberIndex;
      v14 = 1;
      v11 = 0;
      HrSetupDiGetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
      if ( !(DriverInstallParams.Flags & 0x800) )
      {
        v16 = 0;
        if ( !HrSetupDiGetDriverInfoDetail(DeviceInfoSet, 0, &Dst, &v16) )
        {
          InfHandle = 0;
          if ( !HrSetupOpenInfFile(v16->InfFileName, 0, 2u, 0, &InfHandle) )
          {
            if ( !HrSetupDiGetActualSectionToInstallWithBuffer(
                    InfHandle,
                    v16->SectionName,
                    (DWORD)&Section,
                    0x104u,
                    0,
                    0) )
            {
              IntegerValue = 0;
              if ( !HrSetupGetFirstDword(InfHandle, &Section, L"Characteristics", &IntegerValue)
                && IntegerValue & 0x40400
                && !HrCiInstallFromInfSection(InfHandle, &Section, RelativeKeyRoot, 0, 4u) )
              {
                if ( !v8 )
                  goto LABEL_30;
                if ( IntegerValue & 0x400 )
                  goto LABEL_31;
                hKey = 0;
                lpMem = 0;
                Type = 0;
                if ( HrRegOpenKeyEx(RelativeKeyRoot, L"Ndi", 0xF003Fu, &hKey) )
                  goto LABEL_30;
                HrRegQueryDword(hKey, L"FilterType", (DWORD)&lpMem);
                HrRegQueryDword(hKey, L"FilterRunType", (DWORD)&Type);
                if ( lpMem == (void *)2 || Type == 1 )
                  v11 = 1;
                RegDeleteValueW(hKey, L"FilterType");
                RegDeleteValueW(hKey, L"FilterRunType");
                RegCloseKey(hKey);
                if ( v11 == 1 )
                {
LABEL_31:
                  v14 = 0;
                }
                else
                {
LABEL_30:
                  if ( !HrRegOpenKeyEx(RelativeKeyRoot, L"Ndi\\Interfaces", 0xF003Fu, &phkResult) )
                  {
                    hKey = 0;
                    lpMem = 0;
                    HrRegGetTypeWithAlloc(v4, phkResult, L"FilterMediaTypes", 1u, (unsigned __int8 **)&hKey, 0);
                    HrRegGetTypeWithAlloc(v5, phkResult, L"LowerExclude", 1u, (unsigned __int8 **)&lpMem, 0);
                    v14 = CComponent::FCanDirectlyBindToFilter(
                            v9,
                            (const unsigned __int16 *const )hKey,
                            (const unsigned __int16 *const )lpMem);
                    MemFree(hKey);
                    MemFree(lpMem);
                    RegDeleteValueW(phkResult, L"FilterMediaTypes");
                    RegDeleteValueW(phkResult, L"LowerExclude");
                    RegCloseKey(phkResult);
                  }
                }
              }
            }
            SetupCloseInfFileSafe(InfHandle);
            if ( !v14 )
            {
              DriverInstallParams.Flags |= 0x800u;
              HrSetupDiSetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
            }
          }
          MemFree(v16);
        }
      }
    }
    if ( i == -2147024637 )
      i = 0;
    RegCloseKey(RelativeKeyRoot);
    HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Network\\FTempKey");
  }
  return i;
}

//----- (6E645D6B) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(CImplINetCfg *a1, struct _GUID *a2, void **a3)
{
  return CImplINetCfg::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E645E05) --------------------------------------------------------
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CImplINetCfg>>,ATL::CComCreator<ATL::CComAggObject<CImplINetCfg>>>::CreateInstance(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( a1 )
    result = ATL::CComCreator<ATL::CComAggObject<CImplINetCfg>>::CreateInstance(a1, a2, a3);
  else
    result = ATL::CComCreator<ATL::CComObject<CImplINetCfg>>::CreateInstance(0, a2, a3);
  return result;
}

//----- (6E645E2A) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComObject<CImplINetCfg>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // ebx@2
  void *v5; // eax@2
  signed int result; // eax@6

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v4 = -2147024882;
    v5 = operator new(0x5Cu);
    if ( v5 )
      v3 = ATL::CComObject<CImplINetCfg>::CComObject<CImplINetCfg>(v5, a1);
    if ( v3 )
    {
      v4 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v4 )
        ATL::CComObject<CImplINetCfg>::`scalar deleting destructor'(v3, 1);
    }
    result = v4;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E645E83) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfg>::CComObject<CImplINetCfg>(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  CImplINetCfg::CImplINetCfg(this);
  *(_DWORD *)v2 = &ATL::CComObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 3) = &ATL::CComObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 4) = &ATL::CComObject<CImplINetCfg>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E642CDC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(CImplINetCfg *, struct _GUID *, void **);
// 6E643BA0: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E643BB0: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E643BCC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E643BF4: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfg>::`vftable')(int, int, int);

//----- (6E645EC5) --------------------------------------------------------
void *__thiscall CImplINetCfg::CImplINetCfg(void *this)
{
  void *v1; // esi@1

  v1 = this;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 20);
  *((_DWORD *)v1 + 18) = 0;
  *((_DWORD *)v1 + 19) = 0;
  *((_DWORD *)v1 + 12) = 0;
  *((_DWORD *)v1 + 20) = 0;
  *((_DWORD *)v1 + 21) = 0;
  *((_BYTE *)v1 + 88) = 0;
  *((_DWORD *)v1 + 13) = 0;
  *((_DWORD *)v1 + 14) = 0;
  *((_DWORD *)v1 + 15) = 0;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 17) = 0;
  return v1;
}
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);

//----- (6E645EF9) --------------------------------------------------------
void *__thiscall CNetConfigCore::CNetConfigCore(void *this)
{
  void *v1; // esi@1

  v1 = this;
  CComponentList::CComponentList(this);
  CStackTable::CStackTable((char *)v1 + 20);
  CBindingSet::CBindingSet((char *)v1 + 44);
  return v1;
}

//----- (6E645F34) --------------------------------------------------------
void *__thiscall CStackTable::CStackTable(void *this)
{
  void *v1; // esi@1

  v1 = this;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy((int)((char *)this + 4), 0);
  return v1;
}

//----- (6E645F4C) --------------------------------------------------------
void *__thiscall CNetConfig::CNetConfig(void *this)
{
  void *v1; // esi@1

  v1 = this;
  CNetConfigCore::CNetConfigCore(this);
  CModifyContext::CModifyContext((char *)v1 + 72);
  memset(v1, 0, 0x12Cu);
  return v1;
}

//----- (6E645F8E) --------------------------------------------------------
void *__thiscall CModifyContext::CModifyContext(void *this)
{
  void *v1; // esi@1

  v1 = this;
  CNetConfigCore::CNetConfigCore(this);
  CBindingSet::CBindingSet((char *)v1 + 64);
  CBindingSet::CBindingSet((char *)v1 + 84);
  CComponentList::CComponentList((char *)v1 + 104);
  CRegistryBindingsContext::CRegistryBindingsContext((int)((char *)v1 + 124));
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)((char *)v1 + 196), 0);
  return v1;
}

//----- (6E645FF2) --------------------------------------------------------
int __thiscall CRegistryBindingsContext::CRegistryBindingsContext(int this)
{
  int v1; // esi@1

  v1 = this;
  CBindingSet::CBindingSet((void *)(this + 4));
  *(_DWORD *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 44) = 0;
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)(v1 + 60) = 0;
  *(_DWORD *)(v1 + 64) = 0;
  *(_DWORD *)(v1 + 68) = 0;
  return v1;
}

//----- (6E646025) --------------------------------------------------------
signed int __stdcall CImplINetCfg::Initialize(CImplINetCfg *this, void *a2)
{
  SP_LOG_TOKEN v2; // kr00_8@1
  signed int v3; // edi@1

  v2 = SetupGetThreadLogToken();
  v3 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0x11u);
  if ( !v3 )
  {
    v3 = CNetConfig::HrCreateInstance(this, (struct CNetConfig **)this + 12);
    if ( !v3 )
      *((_BYTE *)this + 88) = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
  }
  _SetupWriteTextLog(
    v2,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfg::Initialize, hr = %08xx.",
    v3);
  return v3;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6460D0) --------------------------------------------------------
__int32 __stdcall CNetConfig::HrCreateInstance(struct CImplINetCfg *a1, struct CNetConfig **a2)
{
  __int32 v2; // ebx@1
  void *v3; // ecx@1
  void *v4; // esi@2

  v2 = -2147024882;
  v3 = operator new(0x12Cu);
  if ( v3 )
    v4 = CNetConfig::CNetConfig(v3);
  else
    v4 = 0;
  if ( v4 )
  {
    v2 = HrLoadNetworkConfigurationFromRegistry(*((_DWORD *)a1 + 19) != 0 ? 131078 : 131097, (struct CNetConfig *)v4);
    if ( v2 )
    {
      CNetConfig::`scalar deleting destructor'(v4, 1);
    }
    else
    {
      CGlobalNotifyInterface::HoldINetCfg((CGlobalNotifyInterface *)((char *)v4 + 64), a1);
      *a2 = (struct CNetConfig *)v4;
    }
  }
  return v2;
}

//----- (6E646153) --------------------------------------------------------
void __thiscall CGlobalNotifyInterface::HoldINetCfg(CGlobalNotifyInterface *this, struct CImplINetCfg *a2)
{
  CGlobalNotifyInterface *v2; // esi@1

  v2 = this;
  AddRefObj((struct IUnknown *)a2);
  *((_DWORD *)v2 + 1) = a2;
}

//----- (6E646173) --------------------------------------------------------
signed int __stdcall CImplINetCfg::QueryNetCfgClass(CImplINetCfg *this, const struct _GUID *a2, const struct _GUID *a3, void **a4)
{
  int v4; // esi@1
  signed int v5; // ebx@2
  char *v6; // esi@3
  const struct _GUID *v7; // eax@3
  int v9; // [sp+8h] [bp-4h]@1

  v4 = NetClassEnumFromGuid(a2);
  *a4 = 0;
  v9 = v4;
  if ( v4 == 6 )
    return -2147024809;
  v5 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0);
  if ( !v5 )
  {
    v6 = (char *)this + 4 * v4 + 52;
    v7 = *(const struct _GUID **)v6;
    a2 = v7;
    if ( !v7 )
    {
      v5 = CImplINetCfgClass::HrCreateInstance(this, v9, (int)&a2);
      if ( v5 )
      {
LABEL_7:
        LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
        return v5;
      }
      v7 = a2;
      *(_DWORD *)v6 = a2;
    }
    v5 = (*(int (__stdcall **)(const struct _GUID *, const struct _GUID *, void **))v7->Data1)(v7, a3, a4);
    goto LABEL_7;
  }
  return v5;
}

//----- (6E6461F4) --------------------------------------------------------
int __stdcall CImplINetCfgClass::HrCreateInstance(struct CImplINetCfg *a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // esi@2

  v3 = -2147024882;
  v4 = (int)operator new(0x18u);
  if ( v4 )
    v5 = ATL::CComObject<CImplINetCfgClass>::CComObject<CImplINetCfgClass>(v4, 0);
  else
    v5 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 20) = a2;
    v3 = (**(int (__stdcall ***)(int, GUID *, int))v5)(v5, &IID_INetCfgClass, a3);
    if ( v3 )
      operator delete((void *)v5);
    else
      CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v5 + 8), a1);
  }
  return v3;
}

//----- (6E646265) --------------------------------------------------------
void *__cdecl operator new(unsigned __int32 a1, const struct extrabytes_t *a2, unsigned __int32 a3)
{
  SIZE_T v3; // ecx@0
  void *result; // eax@2
  SIZE_T dwBytes; // [sp+0h] [bp-4h]@1

  dwBytes = v3;
  if ( ULongAdd(a1, a3, &dwBytes) < 0 )
    result = 0;
  else
    result = MemAlloc(dwBytes);
  return result;
}

//----- (6E646291) --------------------------------------------------------
signed int __stdcall ULongAdd(unsigned __int32 a1, unsigned __int32 a2, unsigned __int32 *a3)
{
  signed int result; // eax@2

  if ( a1 + a2 < a1 )
  {
    *a3 = -1;
    result = -2147024362;
  }
  else
  {
    *a3 = a1 + a2;
    result = 0;
  }
  return result;
}

//----- (6E6462B6) --------------------------------------------------------
__int32 __stdcall HrCiRegSetComponentInformation(HKEY hKey, HKEY phkResult)
{
  HKEY v2; // esi@1
  signed int v3; // eax@1
  int v4; // ST10_4@1
  __int32 v5; // edi@1
  int v6; // edi@8
  unsigned __int32 v7; // eax@11
  struct _SYSTEMTIME SystemTime; // [sp+Ch] [bp-10h]@16

  v2 = phkResult;
  v3 = FIsConsideredNetClass(*(_DWORD *)phkResult);
  v4 = *((_DWORD *)v2 + 9);
  phkResult = (HKEY)v3;
  v5 = HrRegSetDword(hKey, L"Characteristics", v4);
  if ( v5 >= 0 )
  {
    if ( phkResult )
      goto LABEL_20;
    v5 = HrRegSetSz(hKey, L"InfPath", *((BYTE **)v2 + 2));
    if ( v5 >= 0 )
    {
      v5 = HrRegSetSz(hKey, L"InfSection", *((BYTE **)v2 + 10));
      if ( v5 >= 0 )
      {
        if ( *((_DWORD *)v2 + 12) )
        {
          HrRegSetSz(hKey, L"LocDescription", *((BYTE **)v2 + 12));
          operator delete(*((void **)v2 + 12));
          *((_DWORD *)v2 + 12) = 0;
        }
        v5 = HrRegSetSz(hKey, L"Description", *((BYTE **)v2 + 11));
        if ( v5 >= 0 )
        {
LABEL_20:
          v6 = *(_DWORD *)v2;
          if ( !FIsConsideredNetClass(*(_DWORD *)v2)
            || *((_DWORD *)v2 + 8)
            || !FIsPhysicalAdapter(v6, *((_DWORD *)v2 + 9))
            || (v7 = *((_DWORD *)v2 + 16), v7 == -1)
            || (v5 = HrRegSetSzAsUlong(hKey, L"BusType", v7, 10), v5 >= 0) )
          {
            v5 = HrRegSetSz(hKey, L"ComponentId", *((BYTE **)v2 + 1));
            if ( !v5 )
            {
              if ( *((_DWORD *)v2 + 9) & 0x40400 )
              {
                phkResult = 0;
                v5 = HrRegOpenKeyEx(hKey, L"Ndi", 0x20006u, &phkResult);
                if ( !v5 )
                {
                  SystemTime.wYear = 0;
                  *(_DWORD *)&SystemTime.wMonth = 0;
                  *(_DWORD *)&SystemTime.wDay = 0;
                  *(_DWORD *)&SystemTime.wMinute = 0;
                  SystemTime.wMilliseconds = 0;
                  GetSystemTime(&SystemTime);
                  v5 = HrRegSetValueEx(phkResult, L"TimeStamp", 3u, (BYTE *)&SystemTime, 0x10u);
                  RegSafeCloseKey(phkResult);
                }
              }
            }
          }
        }
      }
    }
  }
  return v5;
}

//----- (6E64642D) --------------------------------------------------------
__int32 __stdcall HrCiHideIrrelevantDrivers(HDEVINFO DeviceInfoSet, const unsigned __int16 *a2, int a3)
{
  __int32 i; // esi@1
  signed int v4; // esi@3
  unsigned __int32 v5; // ecx@9
  unsigned __int32 v6; // ecx@10
  unsigned __int32 v7; // ecx@22
  struct _SP_DRVINSTALL_PARAMS DriverInstallParams; // [sp+Ch] [bp-878h]@3
  unsigned __int16 *v10; // [sp+20h] [bp-864h]@1
  HKEY phkResult; // [sp+24h] [bp-860h]@22
  DWORD MemberIndex; // [sp+28h] [bp-85Ch]@2
  HINF InfHandle; // [sp+2Ch] [bp-858h]@5
  HKEY RelativeKeyRoot; // [sp+30h] [bp-854h]@1
  void *lpMem; // [sp+34h] [bp-850h]@9
  unsigned __int8 *v16; // [sp+38h] [bp-84Ch]@9
  HDEVINFO v17; // [sp+3Ch] [bp-848h]@1
  struct _SP_DRVINFO_DETAIL_DATA_W *v18; // [sp+40h] [bp-844h]@4
  HKEY hKey; // [sp+44h] [bp-840h]@9
  unsigned __int16 *v20; // [sp+48h] [bp-83Ch]@9
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+4Ch] [bp-838h]@2
  int v22; // [sp+668h] [bp-21Ch]@9
  __int16 v23; // [sp+66Ch] [bp-218h]@9
  __int16 v24; // [sp+66Eh] [bp-216h]@9
  char v25; // [sp+670h] [bp-214h]@9
  char v26; // [sp+671h] [bp-213h]@9
  char v27; // [sp+672h] [bp-212h]@9
  char v28; // [sp+673h] [bp-211h]@9
  char v29; // [sp+674h] [bp-210h]@9
  char v30; // [sp+675h] [bp-20Fh]@9
  char v31; // [sp+676h] [bp-20Eh]@9
  char v32; // [sp+677h] [bp-20Dh]@9
  DWORD RequiredSize; // [sp+678h] [bp-20Ch]@6

  v10 = (unsigned __int16 *)a2;
  v17 = DeviceInfoSet;
  i = HrRegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"System\\CurrentControlSet\\Control\\Network\\FTempKey",
        0,
        0xF003Fu,
        0,
        &RelativeKeyRoot,
        0);
  if ( !i )
  {
    MemberIndex = 0;
    for ( i = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, 0, &Dst);
          !i;
          i = HrSetupDiEnumDriverInfo(v17, 0, 1u, MemberIndex, &Dst) )
    {
      ++MemberIndex;
      v4 = 0;
      HrSetupDiGetDriverInstallParams(v17, 0, &Dst, &DriverInstallParams);
      if ( !(DriverInstallParams.Flags & 0x800) )
      {
        v18 = 0;
        if ( !HrSetupDiGetDriverInfoDetail(v17, 0, &Dst, &v18) )
        {
          InfHandle = 0;
          if ( !HrSetupOpenInfFile(v18->InfFileName, 0, 2u, 0, &InfHandle)
            && !HrSetupDiGetActualSectionToInstallWithBuffer(
                  InfHandle,
                  v18->SectionName,
                  (DWORD)&RequiredSize,
                  0x104u,
                  0,
                  0)
            && !HrCiInstallFromInfSection(InfHandle, (PCWSTR)&RequiredSize, RelativeKeyRoot, 0, 4u) )
          {
            if ( !a3 )
              goto LABEL_35;
            v23 = 0;
            v24 = 0;
            v20 = 0;
            lpMem = 0;
            v16 = 0;
            hKey = 0;
            v22 = 0;
            v25 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 0;
            v29 = 0;
            v30 = 0;
            v31 = 0;
            v32 = 0;
            if ( !HrRegOpenKeyEx(RelativeKeyRoot, L"Ndi", 0xF003Fu, &hKey) )
            {
              HrRegGetTypeWithAlloc(v5, hKey, L"BindForm", 1u, (unsigned __int8 **)&lpMem, 0);
              HrRegGetTypeWithAlloc(v6, hKey, L"Service", 1u, &v16, 0);
              if ( !HrBuildBindNameFromBindForm(
                      lpMem,
                      2,
                      0,
                      (int)v16,
                      (int)v18->HardwareID,
                      (GUID *)&v22,
                      (WCHAR *)&v20)
                && !FIsIsciSupportedProtocol(v20) )
              {
                DriverInstallParams.Flags |= 0x800u;
                v4 = 1;
                HrSetupDiSetDriverInstallParams(v17, 0, &Dst, &DriverInstallParams);
              }
            }
            if ( hKey )
            {
              RegCloseKey(hKey);
              hKey = 0;
            }
            if ( lpMem )
            {
              MemFree(lpMem);
              lpMem = 0;
            }
            if ( v16 )
            {
              MemFree(v16);
              v16 = 0;
            }
            if ( !v20 )
              MemFree(0);
            if ( !v4 )
            {
LABEL_35:
              if ( !HrRegOpenKeyEx(RelativeKeyRoot, L"Ndi\\Interfaces", 0xF003Fu, &phkResult) )
              {
                v20 = 0;
                if ( !HrRegGetTypeWithAlloc(v7, phkResult, L"LowerRange", 1u, (unsigned __int8 **)&v20, 0)
                  && !FSubstringMatch(v10, v20, 0, 0) )
                {
                  DriverInstallParams.Flags |= 0x800u;
                  HrSetupDiSetDriverInstallParams(v17, 0, &Dst, &DriverInstallParams);
                }
                MemFree(v20);
                RegDeleteValueW(phkResult, L"LowerRange");
                RegCloseKey(phkResult);
              }
            }
          }
          SetupCloseInfFileSafe(InfHandle);
          MemFree(v18);
        }
      }
    }
    if ( i == -2147024637 )
      i = 0;
    RegCloseKey(RelativeKeyRoot);
    HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Network\\FTempKey");
  }
  return i;
}

//----- (6E64683F) --------------------------------------------------------
void *__thiscall COMPONENT_REFERENCE_DATA::COMPONENT_REFERENCE_DATA(void *this)
{
  void *v1; // esi@1

  v1 = this;
  CComponentList::CComponentList(this);
  std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Buy(
    (int)((char *)v1 + 20),
    0);
  return v1;
}

//----- (6E646870) --------------------------------------------------------
char __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Buy(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  void *v4; // eax@6

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  if ( a2 )
  {
    if ( (unsigned int)a2 > 0x9249249 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v4 = std::_Allocate<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
           a2,
           0);
    *(_DWORD *)(v2 + 4) = v4;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 12) = (char *)v4 + 28 * a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E64689C) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgComponent>::QueryInterface(CImplIEnumNetCfgComponent *a1, struct _GUID *a2, void **a3)
{
  return CImplIEnumNetCfgComponent::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E6468F1) --------------------------------------------------------
int __stdcall CImplIEnumNetCfgComponent::HrCreateInstance(struct CImplINetCfg *a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // esi@2

  v3 = -2147024882;
  v4 = (int)operator new(0x18u);
  if ( v4 )
    v5 = ATL::CComObject<CImplIEnumNetCfgComponent>::CComObject<CImplIEnumNetCfgComponent>(v4, 0);
  else
    v5 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)(v5 + 20) = a2;
    v3 = (**(int (__stdcall ***)(int, GUID *, int))v5)(v5, &IID_IEnumNetCfgComponent, a3);
    if ( v3 )
      operator delete((void *)v5);
    else
      CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v5 + 4), a1);
  }
  return v3;
}

//----- (6E646965) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::CComObject<CImplIEnumNetCfgComponent>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)this = &ATL::CComObject<CImplIEnumNetCfgComponent>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E64315C: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgComponent>::`vftable')(CImplIEnumNetCfgComponent *, struct _GUID *, void **);

//----- (6E6469C5) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplIEnumNetCfgComponent>::~CComObject<CImplIEnumNetCfgComponent>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E6469EB) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplIEnumNetCfgComponent>::~CComObject<CImplIEnumNetCfgComponent>(int this)
{
  struct IUnknown *v1; // ST00_4@1

  v1 = *(struct IUnknown **)(this + 12);
  *(_DWORD *)this = &ATL::CComObject<CImplIEnumNetCfgComponent>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  ReleaseObj(v1);
  return InterlockedDecrement(&Addend);
}
// 6E64315C: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgComponent>::`vftable')(CImplIEnumNetCfgComponent *, struct _GUID *, void **);

//----- (6E646A27) --------------------------------------------------------
int __stdcall NcLoadRegUIString(HKEY a1, const unsigned __int16 *a2, unsigned __int8 *Dst, unsigned __int32 *a4)
{
  int v4; // esi@1
  void *v5; // ebx@1
  void *v6; // eax@5
  int result; // eax@8
  unsigned int v8; // eax@14
  bool v9; // cf@15
  bool v10; // zf@15
  signed int v11; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v11 = 0;
  if ( a1 && a2 )
  {
    if ( a4 )
    {
      while ( 1 )
      {
        if ( v5 )
          MemFree(v5);
        v4 += 256;
        v6 = MemAlloc(2 * v4);
        v5 = v6;
        if ( !v6 )
          break;
        if ( SHLoadRegUIStringW(a1, a2, v6, v4) < 0 )
        {
          v11 = 1627;
LABEL_8:
          MemFree(v5);
          return v11;
        }
        if ( wcslen((const unsigned __int16 *)v5) != v4 - 1 )
        {
          v8 = 2 * wcslen((const unsigned __int16 *)v5) + 2;
          if ( Dst )
          {
            v9 = v8 < *a4;
            v10 = v8 == *a4;
            *a4 = v8;
            if ( v9 || v10 )
            {
              if ( Dst )
                memcpy(Dst, v5, v8);
            }
            else
            {
              v11 = 234;
            }
          }
          else
          {
            *a4 = v8;
          }
          goto LABEL_8;
        }
      }
      result = 14;
    }
    else
    {
      result = Dst != 0 ? 0xA0 : 0;
    }
  }
  else
  {
    result = 160;
  }
  return result;
}
// 6E641034: using guessed type int __stdcall SHLoadRegUIStringW(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (6E646AA7) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgClass>::QueryInterface(CImplINetCfgClass *a1, struct _GUID *a2, void **a3)
{
  return CImplINetCfgClass::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E646B20) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::SupportsBindingInterface(CImplINetCfgComponent *this, char a2, const unsigned __int16 *a3)
{
  signed int v3; // esi@2
  const unsigned __int16 *v4; // eax@4

  if ( a2 & 3 )
  {
    v3 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)((char *)this - 4), 4u, 0, 0);
    if ( !v3 )
    {
      if ( a2 & 1 )
        v4 = *(const unsigned __int16 **)(*((_DWORD *)this + 6) + 80);
      else
        v4 = *(const unsigned __int16 **)(*((_DWORD *)this + 6) + 84);
      if ( !v4 )
        v4 = &String;
      v3 = FSubstringMatch(v4, a3, 0, 0) == 0;
      LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 5) + 24));
    }
  }
  else
  {
    v3 = -2147024809;
  }
  return v3;
}

//----- (6E646BAA) --------------------------------------------------------
int __cdecl _wcsicmp(const wchar_t *Str1, const wchar_t *Str2)
{
  const wchar_t *v2; // edi@2
  const wchar_t *v3; // edx@3
  const wchar_t v4; // ax@4
  const wchar_t v5; // cx@6
  const wchar_t v6; // ax@6
  int result; // eax@10

  if ( __locale_changed )
  {
    result = _wcsicmp_l(Str1, Str2, 0);
  }
  else
  {
    v2 = Str1;
    if ( Str1 && (v3 = Str2) != 0 )
    {
      do
      {
        v4 = *v2;
        if ( *v2 >= 0x41u && v4 <= 0x5Au )
          v4 += 32;
        v5 = v4;
        v6 = *v3;
        if ( *v3 >= 0x41u && v6 <= 0x5Au )
          v6 += 32;
        ++v2;
        ++v3;
      }
      while ( v5 && v5 == v6 );
      result = v5 - v6;
    }
    else
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      result = 0x7FFFFFFF;
    }
  }
  return result;
}
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E646C20) --------------------------------------------------------
signed int __stdcall CImplINetCfg::FindComponent(CImplINetCfg *this, wchar_t *Str1, struct INetCfgComponent **a3)
{
  signed int v3; // edi@4
  int v4; // eax@5
  CComponent *v5; // ebx@5

  if ( wcslen(Str1) >= 0xC8 )
  {
    v3 = -2147024809;
  }
  else
  {
    if ( a3 )
      *a3 = 0;
    v3 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0);
    if ( !v3 )
    {
      v4 = CComponentList::PFindComponentByInfId(*((CComponentList **)this + 12), Str1, 0);
      v5 = (CComponent *)v4;
      if ( v4 && CExternalComponentData::FLoadedOkayIfLoadedAtAll((CExternalComponentData *)(v4 + 36)) )
      {
        v3 = 0;
        if ( a3 )
          v3 = CComponent::HrGetINetCfgComponentInterface(v5, this, a3);
      }
      else
      {
        v3 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
    }
  }
  return v3;
}

//----- (6E646C94) --------------------------------------------------------
int __thiscall CComponentList::PFindComponentByInfId(CComponentList *this, wchar_t *Str1, unsigned __int32 *a3)
{
  CComponentList *v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@3
  unsigned __int32 v7; // ebx@9

  v3 = this;
  v4 = *((_DWORD *)this + 2);
  if ( a3 )
  {
    v7 = *a3;
    if ( v7 <= std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4)) )
      v4 += 4 * v7;
  }
  while ( 1 )
  {
    if ( v4 == *((_DWORD *)v3 + 3) )
      return 0;
    v5 = *(_DWORD *)v4;
    if ( !_wcsicmp(Str1, *(const wchar_t **)(*(_DWORD *)v4 + 28)) )
      break;
    v4 += 4;
  }
  if ( a3 )
    *a3 = (v4 - *((_DWORD *)v3 + 2)) >> 2;
  return v5;
}

//----- (6E646CDB) --------------------------------------------------------
signed int __stdcall CImplINetCfg::EnumComponents(CImplINetCfg *this, const struct _GUID *a2, struct IEnumNetCfgComponent **a3)
{
  signed int v3; // esi@3
  int v4; // eax@5
  int v6; // [sp+8h] [bp-4h]@1

  v6 = 6;
  if ( a2 && (v6 = NetClassEnumFromGuid(a2), v6 == 6) )
  {
    v3 = -2147024809;
    *a3 = 0;
  }
  else
  {
    *a3 = 0;
    v3 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0);
    if ( !v3 )
    {
      if ( a2 )
        v4 = v6;
      else
        v4 = 6;
      v3 = CImplIEnumNetCfgComponent::HrCreateInstance(this, v4, (int)a3);
      LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
    }
  }
  return v3;
}

//----- (6E6476B9) --------------------------------------------------------
void __cdecl _lock(int a1)
{
  LPCRITICAL_SECTION *v1; // esi@1

  v1 = &lpCriticalSection + 2 * a1;
  if ( !*v1 && !_mtinitlocknum(a1) )
    _amsg_exit(17);
  EnterCriticalSection(*v1);
}
// 6E6770A0: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);

//----- (6E6476E2) --------------------------------------------------------
void __cdecl free(void *Memory)
{
  BOOL v1; // eax@3
  int v2; // eax@6
  int *v3; // esi@10
  DWORD v4; // eax@10
  int v5; // [sp+10h] [bp-1Ch]@6

  if ( Memory )
  {
    if ( __active_heap != 3 )
    {
      v1 = HeapFree(_crtheap, 0, Memory);
      goto LABEL_4;
    }
    _lock(4);
    v2 = __sbh_find_block(Memory);
    v5 = v2;
    if ( v2 )
      __sbh_free_block(v2, Memory);
    _unlock(4);
    if ( !v5 )
    {
      v1 = HeapFree(_crtheap, 0, Memory);
LABEL_4:
      if ( !v1 )
      {
        v3 = _errno();
        v4 = GetLastError();
        *v3 = _get_errno_from_oserr(v4);
      }
      return;
    }
  }
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E676EB4: using guessed type _DWORD __cdecl _get_errno_from_oserr(_DWORD);
// 6E67B9AB: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 6E67B9E0: using guessed type _DWORD __cdecl __sbh_free_block(_DWORD, _DWORD);
// 6E6991E0: using guessed type int __active_heap;

//----- (6E64774F) --------------------------------------------------------
volatile LONG *__cdecl __removelocaleref(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  volatile LONG *v2; // ebx@6
  volatile LONG *lpAddenda; // [sp+Ch] [bp+8h]@6

  v1 = lpAddend;
  if ( lpAddend )
  {
    InterlockedDecrement(lpAddend);
    if ( *((_DWORD *)lpAddend + 44) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 44));
    if ( *((_DWORD *)lpAddend + 46) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 46));
    if ( *((_DWORD *)lpAddend + 45) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 45));
    if ( *((_DWORD *)lpAddend + 48) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 48));
    v2 = lpAddend + 20;
    lpAddenda = (volatile LONG *)6;
    do
    {
      if ( *((int **)v2 - 2) != __clocalestr && *v2 )
        InterlockedDecrement(*(volatile LONG **)v2);
      if ( *((_DWORD *)v2 - 1) && *((_DWORD *)v2 + 1) )
        InterlockedDecrement(*((volatile LONG **)v2 + 1));
      v2 += 4;
      lpAddenda = (volatile LONG *)((char *)lpAddenda - 1);
    }
    while ( lpAddenda );
    InterlockedDecrement((volatile LONG *)(*((_DWORD *)v1 + 53) + 180));
  }
  return v1;
}
// 6E699A70: using guessed type int __clocalestr[2];

//----- (6E64794B) --------------------------------------------------------
int __cdecl _decode_pointer(int a1)
{
  HMODULE v1; // eax@3
  FARPROC v2; // eax@4
  int v4; // ST04_4@8
  LPVOID v5; // eax@8
  int v6; // eax@8

  if ( TlsGetValue(__getvalueindex)
    && __flsindex != -1
    && (v4 = __flsindex, v5 = TlsGetValue(__getvalueindex), (v6 = ((int (__stdcall *)(int))v5)(v4)) != 0) )
  {
    v2 = *(FARPROC *)(v6 + 508);
  }
  else
  {
    v1 = GetModuleHandleW(L"KERNELBASE.DLL");
    if ( !v1 )
    {
      v1 = GetModuleHandleW(L"KERNEL32.DLL");
      if ( !v1 )
        return a1;
    }
    v2 = GetProcAddress(v1, "DecodePointer");
  }
  if ( v2 )
    a1 = ((int (__stdcall *)(int))v2)(a1);
  return a1;
}
// 6E699150: using guessed type int __flsindex;

//----- (6E6479D9) --------------------------------------------------------
int (*__usercall sub_6E6479D9@<eax>(int (*result)(void)@<eax>, unsigned int a2))(void)
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)result; i < a2; i += 4 )
  {
    result = *(int (**)(void))i;
    if ( *(_DWORD *)i )
      result = (int (*)(void))result();
  }
  return result;
}

//----- (6E6479FD) --------------------------------------------------------
signed int __stdcall _CRT_INIT(int a1, int a2, int a3)
{
  if ( a2 == 1 )
    __security_init_cookie();
  return __CRT_INIT(a1, a2, a3);
}

//----- (6E647A13) --------------------------------------------------------
signed int __stdcall __CRT_INIT(int a1, int a2, int a3)
{
  int v3; // eax@3
  void *v5; // eax@25
  int v6; // esi@25
  void *v7; // ST08_4@26
  int v8; // ST04_4@26
  int v9; // eax@26
  int v10; // ST00_4@26
  struct _OSVERSIONINFOA VersionInformation; // [sp+8h] [bp-98h]@2

  if ( a2 == 1 )
  {
    VersionInformation.dwOSVersionInfoSize = 148;
    if ( GetVersionExA(&VersionInformation) )
    {
      v3 = VersionInformation.dwBuildNumber & 0x7FFF;
      if ( VersionInformation.dwPlatformId != 2 )
        v3 |= 0x8000u;
      _osplatform = VersionInformation.dwPlatformId;
      _winver = VersionInformation.dwMinorVersion + (VersionInformation.dwMajorVersion << 8);
      _winmajor = VersionInformation.dwMajorVersion;
      _winminor = VersionInformation.dwMinorVersion;
      _osver = v3;
      if ( _heap_init(1) )
      {
        if ( _mtinit() )
        {
          _acmdln = (int)GetCommandLineA();
          _aenvptr = __crtGetEnvironmentStringsA();
          if ( _ioinit() >= 0 )
          {
            if ( _setargv() >= 0 && _setenvp() >= 0 && !_cinit(0) )
            {
              ++dword_6E699158;
              return 1;
            }
            _ioterm();
          }
          _mtterm();
        }
        _heap_term();
      }
    }
  }
  else if ( a2 )
  {
    if ( a2 != 2 )
    {
      if ( a2 == 3 )
        _freeptd(0);
      return 1;
    }
    __set_flsgetvalue();
    v5 = calloc(1u, 0x214u);
    v6 = (int)v5;
    if ( v5 )
    {
      v7 = v5;
      v8 = __flsindex;
      v9 = _decode_pointer(gpFlsSetValue);
      if ( ((int (__thiscall *)(int, int, void *))v9)(v10, v8, v7) )
      {
        _initptd(v6, 0);
        return 1;
      }
      free((void *)v6);
    }
  }
  else if ( dword_6E699158 > 0 )
  {
    --dword_6E699158;
    if ( !_C_Termination_Done )
      _cexit();
    if ( !a3 )
    {
      _ioterm();
      _mtterm();
      _heap_term();
    }
    return 1;
  }
  return 0;
}
// 6E647D35: using guessed type int _mtterm(void);
// 6E6483F5: using guessed type int __set_flsgetvalue(void);
// 6E64983F: using guessed type int _setenvp(void);
// 6E699150: using guessed type int __flsindex;
// 6E699158: using guessed type int dword_6E699158;
// 6E699160: using guessed type int _osplatform;
// 6E69918C: using guessed type int _C_Termination_Done;
// 6E699198: using guessed type int gpFlsSetValue;
// 6E6991FC: using guessed type int _acmdln;

//----- (6E647B26) --------------------------------------------------------
BOOL __stdcall _DllMainCRTStartup(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  BOOL result; // eax@12
  int v4; // [sp+0h] [bp-1Ch]@3
  int v5; // [sp+0h] [bp-1Ch]@8

  if ( fdwReason == 1 )
    __security_init_cookie();
  _SEH_prolog4(dword_6E647BE8, 12);
  v4 = 1;
  if ( !fdwReason && !dword_6E699158 )
    goto LABEL_27;
  if ( fdwReason != 1 && fdwReason != 2 )
    goto LABEL_28;
  if ( _pRawDllMain )
  {
    dword_6E69BD24 = 1;
    v4 = _pRawDllMain(hinstDLL, fdwReason, lpReserved);
  }
  if ( v4 && _CRT_INIT((int)hinstDLL, fdwReason, (int)lpReserved) )
  {
LABEL_28:
    v5 = DllMain(hinstDLL, fdwReason, lpReserved);
    if ( fdwReason == 1 && !v5 )
    {
      DllMain(hinstDLL, 0, 0);
      _CRT_INIT((int)hinstDLL, 0, 0);
      if ( _pRawDllMain )
        _pRawDllMain(hinstDLL, 0, 0);
    }
    if ( !fdwReason || fdwReason == 3 )
    {
      v5 = _CRT_INIT((int)hinstDLL, fdwReason, (int)lpReserved);
      if ( _pRawDllMain )
      {
        if ( dword_6E69BD24 )
          v5 = _pRawDllMain(hinstDLL, fdwReason, lpReserved);
      }
    }
    result = v5;
  }
  else
  {
LABEL_27:
    result = 0;
  }
  return result;
}
// 6E641400: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 6E647BE8: using guessed type int dword_6E647BE8[2];
// 6E699158: using guessed type int dword_6E699158;
// 6E69B2D0: using guessed type int (__stdcall *_pRawDllMain)(_DWORD, _DWORD, _DWORD);
// 6E69BD24: using guessed type int dword_6E69BD24;

//----- (6E647C5D) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  int v4; // ecx@6

  if ( fdwReason == 1 )
  {
    if ( IsSystemUpgradeInProgress() )
      g_IsInUpgrade = 1;
    DisableThreadLibraryCalls(hinstDLL);
    InitializeDebugging(1);
    SetProcessDPIAware();
    ATL::CComModule::Init((ATL::CComModule *)&_Module, (struct ATL::_ATL_OBJMAP_ENTRY *)&off_6E699B18, hinstDLL);
  }
  else if ( !fdwReason )
  {
    ATL::AtlModuleTerm((struct ATL::_ATL_MODULE *)&_Module);
    sub_6E647CC1(v4);
    if ( g_hLocalHeap )
    {
      if ( !lpvReserved )
      {
        HeapDestroy(g_hLocalHeap);
        g_hLocalHeap = 0;
      }
    }
  }
  return 1;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E647D7B) --------------------------------------------------------
BOOL _heap_term()
{
  BOOL result; // eax@2
  int v1; // ebx@3
  LPVOID *v2; // esi@4

  if ( __active_heap == 3 )
  {
    v1 = 0;
    if ( __sbh_cntHeaderList > 0 )
    {
      v2 = (LPVOID *)((char *)__sbh_pHeaderList + 16);
      do
      {
        VirtualFree(*(v2 - 1), 0, 0x8000u);
        HeapFree(_crtheap, 0, *v2);
        v2 += 5;
        ++v1;
      }
      while ( v1 < __sbh_cntHeaderList );
    }
    HeapFree(_crtheap, 0, __sbh_pHeaderList);
  }
  result = HeapDestroy(_crtheap);
  _crtheap = 0;
  return result;
}
// 6E6991E0: using guessed type int __active_heap;
// 6E69C0A0: using guessed type int __sbh_cntHeaderList;

//----- (6E647DA1) --------------------------------------------------------
void __cdecl _lock_file2(signed int a1, int a2)
{
  if ( a1 >= 20 )
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _lock(a1 + 16);
}

//----- (6E647DC3) --------------------------------------------------------
int __cdecl _flushall()
{
  return sub_6E647DD1(1);
}

//----- (6E647DD1) --------------------------------------------------------
signed int __cdecl sub_6E647DD1(int a1)
{
  signed int i; // esi@1
  int v2; // eax@4
  int v3; // ecx@5
  char *v4; // eax@11
  signed int result; // eax@13
  signed int v6; // [sp+10h] [bp-24h]@1
  signed int v7; // [sp+18h] [bp-1Ch]@1

  v7 = 0;
  v6 = 0;
  _lock(1);
  for ( i = 0; i < _nstream; ++i )
  {
    v4 = (char *)__piob + 4 * i;
    if ( *(_DWORD *)v4 )
    {
      v2 = *(_DWORD *)v4;
      if ( *(_BYTE *)(v2 + 12) & 0x83 )
      {
        _lock_file2(i, v2);
        v3 = *(_DWORD *)(*((_DWORD *)__piob + i) + 12);
        if ( v3 & 0x83 )
        {
          if ( a1 == 1 )
          {
            if ( _fflush_nolock(*((FILE **)__piob + i)) != -1 )
              ++v7;
          }
          else if ( !a1 && v3 & 2 && _fflush_nolock(*((FILE **)__piob + i)) == -1 )
          {
            v6 = -1;
          }
        }
        _unlock_file2(i, *((_DWORD *)__piob + i));
      }
    }
  }
  _unlock(1);
  result = v7;
  if ( a1 != 1 )
    result = v6;
  return result;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E6991D8: using guessed type int _nstream;

//----- (6E647EE1) --------------------------------------------------------
int __cdecl _fcloseall()
{
  signed int i; // edi@1
  int v1; // esi@3
  char *v2; // eax@3
  int v3; // eax@5
  int v5; // [sp+14h] [bp-1Ch]@1

  v5 = 0;
  _lock(1);
  for ( i = 3; i < _nstream; ++i )
  {
    v1 = 4 * i;
    v2 = (char *)__piob + 4 * i;
    if ( *(_DWORD *)v2 )
    {
      v3 = *(_DWORD *)v2;
      if ( *(_BYTE *)(v3 + 12) & 0x83 && fclose((FILE *)v3) != -1 )
        ++v5;
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)((char *)__piob + v1) + 32));
        free(*(void **)((char *)__piob + v1));
        *(_DWORD *)((char *)__piob + v1) = 0;
      }
    }
  }
  _unlock(1);
  return v5;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E6991D8: using guessed type int _nstream;

//----- (6E647F65) --------------------------------------------------------
void _mtdeletelocks()
{
  signed int v0; // esi@1
  LPCRITICAL_SECTION v1; // edi@2
  signed int v2; // esi@4

  v0 = (signed int)&lpCriticalSection;
  do
  {
    v1 = *(LPCRITICAL_SECTION *)v0;
    if ( *(_DWORD *)v0 && *(_DWORD *)(v0 + 4) != 1 )
    {
      DeleteCriticalSection(*(LPCRITICAL_SECTION *)v0);
      free(v1);
      *(_DWORD *)v0 = 0;
    }
    v0 += 8;
  }
  while ( v0 < (signed int)dword_6E699EE8 );
  v2 = (signed int)&lpCriticalSection;
  do
  {
    if ( *(_DWORD *)v2 )
    {
      if ( *(_DWORD *)(v2 + 4) == 1 )
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v2);
    }
    v2 += 8;
  }
  while ( v2 < (signed int)dword_6E699EE8 );
}
// 6E699EE8: using guessed type int dword_6E699EE8[84];

//----- (6E647FF3) --------------------------------------------------------
signed int __stdcall ATL::AtlModuleTerm(struct ATL::_ATL_MODULE *a1)
{
  int v1; // edi@2
  int v2; // eax@4
  void *v3; // esi@7
  signed int result; // eax@8

  if ( a1 )
  {
    v1 = *((_DWORD *)a1 + 4);
    if ( v1 )
    {
      while ( *(_DWORD *)v1 )
      {
        v2 = *(_DWORD *)(v1 + 16);
        if ( v2 )
          (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v2 + 8))(*(_DWORD *)(v1 + 16));
        *(_DWORD *)(v1 + 16) = 0;
        v1 += 28;
      }
    }
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 28));
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 52));
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 76));
    v3 = (void *)*((_DWORD *)a1 + 6);
    if ( v3 )
      HeapDestroy(v3);
    result = 0;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E6480AA) --------------------------------------------------------
void _ioterm()
{
  void **v0; // esi@1
  void *v1; // edi@2
  int i; // eax@5

  v0 = (void **)__pioinfo;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (int)((char *)v1 + 1152); (unsigned int)v1 < i; i = (int)((char *)*v0 + 1152) )
      {
        if ( *((_BYTE *)v1 + 8) & 4 )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 36;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)Filename );
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E64810F) --------------------------------------------------------
void *__thiscall ATL::CComObjectNoLock<ATL::CComClassFactory>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObjectNoLock<ATL::CComClassFactory>::~CComObjectNoLock<ATL::CComClassFactory>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E648135) --------------------------------------------------------
void __thiscall ATL::CComObjectNoLock<ATL::CComClassFactory>::~CComObjectNoLock<ATL::CComClassFactory>(int this)
{
  *(_DWORD *)this = &ATL::CComObjectNoLock<ATL::CComClassFactory>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 8));
}
// 6E641630: using guessed type int (__stdcall *ATL::CComObjectNoLock<ATL::CComClassFactory>::`vftable')(ATL::CComClassFactory *, struct _GUID *, void **);

//----- (6E648239) --------------------------------------------------------
HANDLE __termcon()
{
  HANDLE result; // eax@3

  if ( _confh != (HANDLE)-1 && _confh != (HANDLE)-2 )
    CloseHandle(_confh);
  result = _coninpfh;
  if ( _coninpfh != (HANDLE)-1 && _coninpfh != (HANDLE)-2 )
    result = (HANDLE)CloseHandle(_coninpfh);
  return result;
}

//----- (6E648290) --------------------------------------------------------
int __cdecl _fflush_nolock(FILE *File)
{
  int result; // eax@4
  int v2; // eax@8

  if ( File )
  {
    if ( _flush(File) )
    {
      result = -1;
    }
    else if ( File->_flag & 0x4000 )
    {
      v2 = _fileno(File);
      result = -(_commit(v2) != 0);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = sub_6E647DD1(0);
  }
  return result;
}

//----- (6E6482C7) --------------------------------------------------------
int __cdecl _flush(FILE *File)
{
  signed int v1; // ebx@1
  char *v2; // eax@3
  char *v4; // eax@4
  char *v5; // edi@4
  unsigned int v6; // ST08_4@5
  char *v7; // ST04_4@5
  int v8; // eax@5
  int v9; // eax@6

  v1 = 0;
  if ( (File->_flag & 3) == 2 )
  {
    if ( File->_flag & 0x108 )
    {
      v4 = File->_base;
      v5 = (char *)(File->_ptr - v4);
      if ( (signed int)v5 > 0 )
      {
        v6 = File->_ptr - v4;
        v7 = File->_base;
        v8 = _fileno(File);
        if ( (char *)_write(v8, v7, v6) == v5 )
        {
          v9 = File->_flag;
          if ( (char)v9 < 0 )
            File->_flag = v9 & 0xFFFFFFFD;
        }
        else
        {
          File->_flag |= 0x20u;
          v1 = -1;
        }
      }
    }
  }
  v2 = File->_base;
  File->_cnt = 0;
  File->_ptr = v2;
  return v1;
}

//----- (6E648315) --------------------------------------------------------
void __cdecl _unlock_file2(signed int a1, int a2)
{
  if ( a1 >= 20 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _unlock(a1 + 16);
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (6E648337) --------------------------------------------------------
_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *a2)
{
  _LocaleUpdate *v2; // esi@1
  int v3; // eax@2
  int v4; // eax@7
  pthreadmbcinfo v6; // eax@10

  v2 = this;
  *((_BYTE *)this + 12) = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2->locinfo;
    v6 = a2->mbcinfo;
LABEL_11:
    *((_DWORD *)v2 + 1) = v6;
    return v2;
  }
  v3 = _getptd_noexit();
  *((_DWORD *)v2 + 2) = v3;
  if ( !v3 )
  {
    *(_DWORD *)v2 = ___ptlocinfo;
    v6 = (pthreadmbcinfo)___ptmbcinfo;
    goto LABEL_11;
  }
  *(_DWORD *)v2 = *(_DWORD *)(v3 + 108);
  *((_DWORD *)v2 + 1) = *(_DWORD *)(v3 + 104);
  if ( *(_DWORD *)v2 != ___ptlocinfo && !(*(_BYTE *)(v3 + 112) & 2) && __globallocalestatus & 1 )
    *(_DWORD *)v2 = __updatetlocinfo();
  if ( *((volatile LONG **)v2 + 1) != ___ptmbcinfo
    && !(*(_BYTE *)(*((_DWORD *)v2 + 2) + 112) & 2)
    && __globallocalestatus & 1 )
    *((_DWORD *)v2 + 1) = __updatetmbcinfo();
  v4 = *((_DWORD *)v2 + 2);
  if ( !(*(_BYTE *)(v4 + 112) & 2) )
  {
    *(_DWORD *)(v4 + 112) |= 2u;
    *((_BYTE *)v2 + 12) = 1;
  }
  return v2;
}
// 6E6483B5: using guessed type int _getptd_noexit(void);
// 6E69B2C4: using guessed type _DWORD ___ptlocinfo;
// 6E69B2D4: using guessed type char __globallocalestatus;

//----- (6E64845A) --------------------------------------------------------
LONG __cdecl __addlocaleref(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  volatile LONG *v2; // ebx@5
  volatile LONG *lpAddenda; // [sp+14h] [bp+8h]@5

  v1 = lpAddend;
  InterlockedIncrement(lpAddend);
  if ( *((_DWORD *)lpAddend + 44) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 44));
  if ( *((_DWORD *)lpAddend + 46) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 46));
  if ( *((_DWORD *)lpAddend + 45) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 45));
  if ( *((_DWORD *)lpAddend + 48) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 48));
  v2 = lpAddend + 20;
  lpAddenda = (volatile LONG *)6;
  do
  {
    if ( *((int **)v2 - 2) != __clocalestr && *v2 )
      InterlockedIncrement(*(volatile LONG **)v2);
    if ( *((_DWORD *)v2 - 1) && *((_DWORD *)v2 + 1) )
      InterlockedIncrement(*((volatile LONG **)v2 + 1));
    v2 += 4;
    lpAddenda = (volatile LONG *)((char *)lpAddenda - 1);
  }
  while ( lpAddenda );
  return InterlockedIncrement((volatile LONG *)(*((_DWORD *)v1 + 53) + 180));
}
// 6E699A70: using guessed type int __clocalestr[2];

//----- (6E6484EE) --------------------------------------------------------
int __cdecl _initptd(int a1, int a2)
{
  HMODULE hModule; // [sp+10h] [bp-1Ch]@1

  hModule = GetModuleHandleW(L"KERNELBASE.DLL");
  if ( !hModule )
    hModule = GetModuleHandleW(L"KERNEL32.DLL");
  *(_DWORD *)(a1 + 92) = _XcptActTab;
  *(_DWORD *)(a1 + 20) = 1;
  if ( hModule )
  {
    *(_DWORD *)(a1 + 504) = GetProcAddress(hModule, "EncodePointer");
    *(_DWORD *)(a1 + 508) = GetProcAddress(hModule, "DecodePointer");
  }
  *(_DWORD *)(a1 + 112) = 1;
  *(_BYTE *)(a1 + 200) = 67;
  *(_BYTE *)(a1 + 331) = 67;
  *(_DWORD *)(a1 + 104) = &__initialmbcinfo;
  InterlockedIncrement(&__initialmbcinfo);
  _lock(12);
  *(_DWORD *)(a1 + 108) = a2;
  if ( !a2 )
    *(_DWORD *)(a1 + 108) = ___ptlocinfo;
  __addlocaleref(*(volatile LONG **)(a1 + 108));
  return _unlock(12);
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E699AA0: using guessed type int _XcptActTab[3];
// 6E69B2C4: using guessed type _DWORD ___ptlocinfo;

//----- (6E6485D7) --------------------------------------------------------
LPVOID __cdecl _calloc_crt(size_t Size, int a2)
{
  DWORD v2; // esi@1
  LPVOID v3; // edi@2
  int v5; // eax@7

  v2 = 0;
  do
  {
    v3 = _calloc_impl(Size, a2, 0);
    if ( v3 || (unsigned int)_maxwait <= 0 )
      break;
    Sleep(v2);
    v5 = v2 + 1000;
    if ( v2 + 1000 > _maxwait )
      v5 = -1;
    v2 = v5;
  }
  while ( v5 != -1 );
  return v3;
}
// 6E69C06C: using guessed type int _maxwait;

//----- (6E64860E) --------------------------------------------------------
LPVOID __cdecl _calloc_impl(size_t Size, int a2, int a3)
{
  unsigned int v3; // esi@3
  LPVOID v4; // ebx@4
  void *Dst; // [sp+10h] [bp-1Ch]@15
  unsigned int Sizea; // [sp+34h] [bp+8h]@3

  if ( !Size || 0xFFFFFFE0 / Size >= a2 )
  {
    v3 = a2 * Size;
    Sizea = v3;
    if ( !v3 )
      v3 = 1;
    while ( 1 )
    {
      v4 = 0;
      if ( v3 <= 0xFFFFFFE0 )
        break;
LABEL_8:
      if ( v4 )
        return v4;
      if ( !_newmode )
      {
        if ( a3 )
          *(_DWORD *)a3 = 12;
        return v4;
      }
      if ( !_callnewh(v3) )
      {
        if ( a3 )
          *(_DWORD *)a3 = 12;
        return 0;
      }
    }
    if ( __active_heap == 3 )
    {
      v3 = (v3 + 15) & 0xFFFFFFF0;
      if ( Sizea <= __sbh_threshold )
      {
        _lock(4);
        Dst = (void *)__sbh_alloc_block(Sizea);
        _unlock(4);
        v4 = Dst;
        if ( !Dst )
        {
LABEL_7:
          v4 = HeapAlloc(_crtheap, 8u, v3);
          goto LABEL_8;
        }
        memset(Dst, 0, Sizea);
      }
    }
    if ( v4 )
      return v4;
    goto LABEL_7;
  }
  *_errno() = 12;
  _invalid_parameter(0, 0, 0, 0, 0);
  return 0;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E67B92B: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 6E67BEBD: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 6E6991E0: using guessed type int __active_heap;
// 6E69C074: using guessed type int _newmode;
// 6E69C0A8: using guessed type int __sbh_threshold;

//----- (6E6486A9) --------------------------------------------------------
__int32 __stdcall HrCreateMutexWithWorldAccess(LPCWSTR lpName, BOOL bInitialOwner, void *lpMem, void **a4)
{
  void *v4; // ebx@1
  void **v5; // esi@2
  __int32 v6; // edi@2
  struct _SECURITY_ATTRIBUTES MutexAttributes; // [sp+Ch] [bp-Ch]@3

  v4 = lpMem;
  if ( lpMem )
    *(_DWORD *)lpMem = 0;
  v5 = a4;
  *a4 = 0;
  v6 = HrAllocateSecurityDescriptorAllowAccessToWorld(&lpMem);
  if ( !v6 )
  {
    MutexAttributes.bInheritHandle = 0;
    MutexAttributes.lpSecurityDescriptor = lpMem;
    MutexAttributes.nLength = 12;
    *v5 = CreateMutexW(&MutexAttributes, bInitialOwner, lpName);
    v6 = HrFromLastWin32Error();
    if ( v6 == -2147024713 )
    {
      if ( v4 )
        *(_DWORD *)v4 = 1;
      v6 = 0;
    }
    MemFree(lpMem);
  }
  return v6;
}

//----- (6E648725) --------------------------------------------------------
__int32 __stdcall HrAllocateSecurityDescriptorAllowAccessToWorld(void **a1)
{
  unsigned __int32 v1; // eax@1
  unsigned int v2; // edi@1
  unsigned __int32 v3; // esi@1
  signed int v4; // eax@1
  ACL *v5; // edi@7
  void *v6; // esi@10
  __int32 result; // eax@14
  DWORD v8; // eax@17
  PSECURITY_DESCRIPTOR pSecurityDescriptor; // [sp+10h] [bp-18h]@1
  PSID pSid; // [sp+14h] [bp-14h]@1
  DWORD v11; // [sp+18h] [bp-10h]@1
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [sp+1Ch] [bp-Ch]@7

  pSecurityDescriptor = 0;
  *a1 = 0;
  v1 = GetSidLengthRequired(1u);
  v2 = v1;
  v3 = (v1 + 23) & 0xFFFFFFFC;
  v11 = 14;
  pSid = 0;
  v4 = ULongAdd(v1, v3, (unsigned __int32 *)&pSid);
  if ( v4 < 0 || (v4 = ULongAdd((unsigned __int32)pSid, 0x14u, (unsigned __int32 *)&pSid), v4 < 0) )
  {
    v11 = (unsigned __int16)v4;
  }
  else
  {
    if ( v2 >= v3 + v2 || v3 + v2 + 20 <= 0x14 )
    {
      LOWORD(result) = v11;
      return (unsigned __int16)result | 0x80070000;
    }
    pSecurityDescriptor = MemAlloc(v3 + v2 + 20);
  }
  if ( pSecurityDescriptor )
  {
    v5 = (ACL *)((char *)pSecurityDescriptor + 20);
    pIdentifierAuthority.Value[0] = 0;
    pIdentifierAuthority.Value[1] = 0;
    pIdentifierAuthority.Value[2] = 0;
    pIdentifierAuthority.Value[3] = 0;
    pIdentifierAuthority.Value[4] = 0;
    pIdentifierAuthority.Value[5] = 1;
    v11 = 0;
    pSid = (char *)pSecurityDescriptor + v3 + 20;
    if ( InitializeSid((char *)pSecurityDescriptor + v3 + 20, &pIdentifierAuthority, 1u) )
    {
      *GetSidSubAuthority(pSid, 0) = 0;
      if ( InitializeAcl(v5, v3, 2u) )
      {
        if ( AddAccessAllowedAce(v5, 2u, 0x1FFFFFu, pSid) )
        {
          v6 = pSecurityDescriptor;
          if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) )
          {
            if ( SetSecurityDescriptorDacl(pSecurityDescriptor, 1, v5, 0)
              && SetSecurityDescriptorOwner(pSecurityDescriptor, 0, 0)
              && SetSecurityDescriptorGroup(pSecurityDescriptor, 0, 0) )
              goto LABEL_14;
          }
        }
      }
    }
    v8 = GetLastError();
    v11 = v8;
    if ( !v8 )
    {
      v6 = pSecurityDescriptor;
LABEL_14:
      *a1 = v6;
      return v11;
    }
    MemFree(pSecurityDescriptor);
  }
  result = v11;
  if ( (signed int)v11 > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E648899) --------------------------------------------------------
FARPROC __stdcall __delayLoadHelper2(HMODULE hModule, int a2)
{
  volatile LONG *v2; // esi@1
  volatile LONG v3; // edx@1
  const CHAR *v4; // ebx@1
  int v5; // ecx@1
  const CHAR *v6; // eax@1
  FARPROC v7; // esi@5
  HMODULE v9; // eax@11
  HMODULE v10; // edi@11
  LONG v11; // esi@12
  DWORD v12; // eax@19
  LONG v13; // eax@21
  DWORD v14; // eax@24
  struct DelayLoadInfo pdli; // [sp+Ch] [bp-2Ch]@13
  LPCSTR lpProcName; // [sp+30h] [bp-8h]@2
  int v17; // [sp+34h] [bp-4h]@1
  HMODULE hModulea; // [sp+40h] [bp+8h]@1

  v17 = 0;
  v2 = (volatile LONG *)&byte_6E640000[*((_DWORD *)hModule + 2)];
  v3 = *v2;
  v4 = &byte_6E640000[*((_DWORD *)hModule + 1)];
  v5 = *(_DWORD *)(&byte_6E640000[4 * ((a2 - *((_DWORD *)hModule + 3) - (signed int)byte_6E640000) >> 2)]
                 + *((_DWORD *)hModule + 4));
  hModulea = (HMODULE)*v2;
  v6 = (char *)&word_6E640002 + v5;
  if ( v5 < 0 )
    v6 = (const CHAR *)(unsigned __int16)v5;
  lpProcName = v6;
  if ( !v3 )
  {
    v9 = LoadLibraryExA(v4, 0, 0);
    v10 = v9;
    hModulea = v9;
    if ( v9 )
    {
      v11 = InterlockedCompareExchange(v2, (LONG)v9, 0);
      if ( v11 )
      {
        FreeLibrary(v10);
        hModulea = (HMODULE)v11;
      }
      else
      {
        memset(&pdli.pidd, 0, 0x20u);
        pdli.hmodCur = hModulea;
        pdli.cb = 36;
        pdli.szDll = v4;
        if ( __pfnDliNotifyHook2 )
          __pfnDliNotifyHook2(5u, &pdli);
      }
    }
    else
    {
      v12 = GetLastError();
      if ( v12 != 126 && v12 != 193 )
        goto LABEL_26;
      v13 = InterlockedCompareExchange(v2, -1, 0);
      if ( !v13 )
      {
LABEL_23:
        v17 = 1;
LABEL_26:
        v7 = (FARPROC)DelayLoadFailureHook(v4, lpProcName);
        goto LABEL_8;
      }
      hModulea = (HMODULE)v13;
    }
  }
  if ( hModulea == (HMODULE)-1 )
    goto LABEL_23;
  if ( !hModulea )
    goto LABEL_26;
  v7 = GetProcAddress(hModulea, lpProcName);
  if ( v7 || (v14 = GetLastError(), v14 == 127) || v14 == 182 )
    v17 = 1;
  if ( !v7 )
    goto LABEL_26;
LABEL_8:
  if ( v17 )
    *(_DWORD *)a2 = v7;
  return v7;
}
// 6E640002: using guessed type __int16 word_6E640002;
// 6E690E9C: using guessed type int __stdcall DelayLoadFailureHook(_DWORD, _DWORD);

//----- (6E648A00) --------------------------------------------------------
int __usercall _tailMerge_SETUPAPI_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_SETUPAPI_dll, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E648A16) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComObjectNoLock<ATL::CComClassFactory>>::CreateInstance(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@5
  signed int result; // eax@6
  int v7; // [sp+18h] [bp+10h]@2

  v3 = a3;
  v4 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v7 = -2147024882;
    if ( operator new(0x24u) )
      v4 = ATL::CComObjectNoLock<ATL::CComClassFactory>::CComObjectNoLock<ATL::CComClassFactory>(a1);
    if ( v4 )
    {
      v5 = *(_DWORD *)v4;
      *(_DWORD *)(v4 + 32) = a1;
      v7 = (*(int (__stdcall **)(int, int, int))v5)(v4, a2, v3);
      if ( v7 )
        ATL::CComObjectNoLock<ATL::CComClassFactory>::`scalar deleting destructor'((void *)v4, 1);
    }
    result = v7;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}
// 6E648A77: using guessed type _DWORD __stdcall ATL::CComObjectNoLock<ATL::CComClassFactory>::CComObjectNoLock<ATL::CComClassFactory>(_DWORD);

//----- (6E648A92) --------------------------------------------------------
ATL::CComClassFactory *__thiscall ATL::CComClassFactory::CComClassFactory(ATL::CComClassFactory *this)
{
  ATL::CComClassFactory *v1; // esi@1

  v1 = this;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 4);
  *(_DWORD *)v1 = ATL::CComClassFactory::`vftable';
  return v1;
}
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);
// 6E648AAC: using guessed type int (*ATL::CComClassFactory::`vftable'[3])();

//----- (6E648BD6) --------------------------------------------------------
int __fastcall load__SetupWriteTextLog(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&_SetupWriteTextLog, a2, a1);
}

//----- (6E648BE0) --------------------------------------------------------
int __fastcall load__SetupGetThreadLogToken_0(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupGetThreadLogToken, a2, a1);
}

//----- (6E648BEA) --------------------------------------------------------
int __fastcall load__SetupDiDestroyDeviceInfoList_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiDestroyDeviceInfoList, a2, a1);
}

//----- (6E648BF4) --------------------------------------------------------
int __fastcall load__SetupDiGetDeviceRegistryPropertyW_28(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDeviceRegistryPropertyW, a2, a1);
}

//----- (6E648BFE) --------------------------------------------------------
int __fastcall load__SetupDiOpenDevRegKey_24(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiOpenDevRegKey, a2, a1);
}

//----- (6E648C08) --------------------------------------------------------
int __fastcall load__SetupDiOpenDeviceInfoW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiOpenDeviceInfoW, a2, a1);
}

//----- (6E648C12) --------------------------------------------------------
int __fastcall load__SetupDiCreateDeviceInfoList_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiCreateDeviceInfoList, a2, a1);
}

//----- (6E648CB3) --------------------------------------------------------
signed int __cdecl _get_osplatform(int a1)
{
  signed int result; // eax@3

  if ( a1 && _osplatform )
  {
    *(_DWORD *)a1 = _osplatform;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 6E699160: using guessed type int _osplatform;

//----- (6E648CED) --------------------------------------------------------
void *__cdecl calloc(size_t NumOfElements, size_t SizeOfElements)
{
  LPVOID v2; // edi@1
  int v4; // esi@3
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  v2 = _calloc_impl(NumOfElements, SizeOfElements, (int)&v5);
  if ( !v2 )
  {
    v4 = v5;
    if ( v5 )
    {
      if ( _errno() )
        *_errno() = v4;
    }
  }
  return v2;
}

//----- (6E648D1E) --------------------------------------------------------
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ulAugend + ulAddend < ulAugend )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ulAugend + ulAddend;
    result = 0;
  }
  return result;
}

//----- (6E648D5E) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  DWORD v0; // esi@5
  DWORD v1; // esi@5
  DWORD v2; // esi@5
  DWORD v3; // esi@5
  DWORD v4; // esi@5
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-10h]@5
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-8h]@1

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie != -1153374642 && __security_cookie & 0xFFFF0000 )
  {
    __security_cookie_complement = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v0 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v1 = GetCurrentProcessId() ^ v0;
    v2 = GetCurrentThreadId() ^ v1;
    v3 = GetTickCount() ^ v2;
    QueryPerformanceCounter(&PerformanceCount);
    v4 = PerformanceCount.LowPart ^ PerformanceCount.HighPart ^ v3;
    if ( v4 == -1153374642 || !(__security_cookie & 0xFFFF0000) )
      v4 = -1153374641;
    __security_cookie = v4;
    __security_cookie_complement = ~v4;
  }
}
// 6E699144: using guessed type int __security_cookie_complement;

//----- (6E648D9F) --------------------------------------------------------
int __cdecl _ValidateImageBase(int a1)
{
  int v1; // eax@2
  int result; // eax@3

  if ( *(_WORD *)a1 != 23117 || (v1 = a1 + *(_DWORD *)(a1 + 60), *(_DWORD *)v1 != 17744) )
    result = 0;
  else
    result = *(_WORD *)(v1 + 24) == 267;
  return result;
}

//----- (6E648E03) --------------------------------------------------------
errno_t __cdecl strcpy_s(char *Dst, rsize_t SizeInBytes, const char *Src)
{
  rsize_t v3; // edi@2
  const char *v4; // esi@3
  char *v5; // edx@4
  const char v6; // al@5
  errno_t v8; // esi@10

  if ( !Dst )
    goto LABEL_10;
  v3 = SizeInBytes;
  if ( SizeInBytes <= 0 )
    goto LABEL_10;
  v4 = Src;
  if ( !Src )
  {
    *Dst = 0;
LABEL_10:
    v8 = 22;
    *_errno() = 22;
    goto LABEL_11;
  }
  v5 = Dst;
  do
  {
    v6 = *v4;
    *v5++ = *v4++;
    if ( !v6 )
      break;
    --v3;
  }
  while ( v3 );
  if ( v3 )
    return 0;
  *Dst = 0;
  *_errno() = 34;
  v8 = 34;
LABEL_11:
  _invalid_parameter(0, 0, 0, 0, 0);
  return v8;
}

//----- (6E648E74) --------------------------------------------------------
int __cdecl _initp_misc_rand_s(int a1)
{
  int result; // eax@1

  result = a1;
  dword_6E6991C0 = a1;
  return result;
}
// 6E6991C0: using guessed type int dword_6E6991C0;

//----- (6E648E88) --------------------------------------------------------
int __cdecl _initp_misc_initcrit(int a1)
{
  int result; // eax@1

  result = a1;
  dword_6E6991C4 = a1;
  return result;
}
// 6E6991C4: using guessed type int dword_6E6991C4;

//----- (6E648ED0) --------------------------------------------------------
unsigned int __usercall sub_6E648ED0@<eax>(int a1@<esi>)
{
  unsigned int v1; // eax@2
  BYTE v2; // al@4
  unsigned int result; // eax@5
  __int16 v4; // cx@6
  CHAR v5; // cl@11
  int v6; // ebx@14
  unsigned int v7; // ecx@15
  unsigned int v8; // eax@15
  int v9; // ebx@17
  unsigned int v10; // ecx@19
  char v11; // dl@21
  int v12; // [sp+8h] [bp-51Ch]@19
  struct _cpinfo CPInfo; // [sp+Ch] [bp-518h]@1
  __int16 CharType[256]; // [sp+20h] [bp-504h]@5
  CHAR v15[256]; // [sp+220h] [bp-304h]@5
  CHAR v16[256]; // [sp+320h] [bp-204h]@5
  char Dst[256]; // [sp+420h] [bp-104h]@3

  if ( GetCPInfo(*(_DWORD *)(a1 + 4), &CPInfo) )
  {
    v1 = 0;
    do
    {
      Dst[v1] = v1;
      ++v1;
    }
    while ( v1 < 0x100 );
    v2 = CPInfo.LeadByte[0];
    Dst[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v6 = (int)&CPInfo.LeadByte[1];
      do
      {
        v7 = v2;
        v8 = *(_BYTE *)v6;
        if ( v7 <= v8 )
          memset(&Dst[v7], 32, v8 - v7 + 1);
        v9 = v6 + 1;
        v2 = *(_BYTE *)v9;
        v6 = v9 + 1;
      }
      while ( v2 );
    }
    __crtGetStringTypeA(0, 1u, Dst, 256, (LPWORD)CharType, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 12), 0);
    __crtLCMapStringA(0, *(_DWORD *)(a1 + 12), 0x100u, Dst, 256, v16, 256, *(_DWORD *)(a1 + 4), 0);
    __crtLCMapStringA(0, *(_DWORD *)(a1 + 12), 0x200u, Dst, 256, v15, 256, *(_DWORD *)(a1 + 4), 0);
    result = 0;
    while ( 1 )
    {
      v4 = CharType[result];
      if ( v4 & 1 )
        break;
      if ( v4 & 2 )
      {
        *(_BYTE *)(a1 + result + 29) |= 0x20u;
        v5 = v15[result];
LABEL_13:
        *(_BYTE *)(a1 + result + 285) = v5;
        goto LABEL_9;
      }
      *(_BYTE *)(a1 + result + 285) = 0;
LABEL_9:
      ++result;
      if ( result >= 0x100 )
        return result;
    }
    *(_BYTE *)(a1 + result + 29) |= 0x10u;
    v5 = v16[result];
    goto LABEL_13;
  }
  v10 = 0;
  v12 = -97 - (a1 + 285);
  do
  {
    result = a1 + v10 + 285;
    if ( result + v12 + 32 <= 0x19 )
    {
      *(_BYTE *)(a1 + v10 + 29) |= 0x10u;
      v11 = v10 + 32;
LABEL_24:
      *(_BYTE *)result = v11;
      goto LABEL_26;
    }
    if ( result + v12 <= 0x19 )
    {
      *(_BYTE *)(a1 + v10 + 29) |= 0x20u;
      v11 = v10 - 32;
      goto LABEL_24;
    }
    *(_BYTE *)result = 0;
LABEL_26:
    ++v10;
  }
  while ( v10 < 0x100 );
  return result;
}
// 6E648ED0: using guessed type char Dst[256];
// 6E648ED0: using guessed type WORD CharType[256];

//----- (6E648FFD) --------------------------------------------------------
signed int __usercall sub_6E648FFD@<eax>(int a1@<esi>, int a2, int a3, int a4, signed int *a5)
{
  signed int result; // eax@41
  int v6; // eax@47
  int v7; // eax@1
  signed int *v8; // ecx@1
  signed int v9; // edx@1
  int v10; // edi@1
  int v11; // edx@3
  int v12; // ecx@8
  char v13; // bl@9
  unsigned int v14; // ST00_4@9
  int v15; // ebx@16
  int v16; // edx@23
  unsigned int v17; // edx@24
  char v18; // al@28
  int v19; // eax@33
  int v20; // ecx@35
  int v21; // eax@53
  int v22; // ecx@56
  int v23; // ecx@65
  signed int v24; // [sp+8h] [bp-8h]@1
  int v25; // [sp+Ch] [bp-4h]@1
  int v26; // [sp+18h] [bp+8h]@4
  signed int v27; // [sp+18h] [bp+8h]@24

  v7 = *(_DWORD *)a1;
  v8 = a5;
  v9 = *a5;
  *(_DWORD *)a1 = 0;
  v25 = v7;
  v10 = a2;
  v24 = v9;
  *a5 = 1;
  if ( a3 && v9 >= 1 )
  {
    v11 = a3;
    a3 += 4;
    *(_DWORD *)v11 = a4;
  }
  v26 = 0;
  do
  {
    if ( *(_BYTE *)v10 == 34 )
    {
      v13 = 34;
      ++v10;
      v26 = v26 == 0;
    }
    else
    {
      ++*(_DWORD *)a1;
      if ( a4 && *(_DWORD *)a1 <= v25 )
      {
        v12 = a4++;
        *(_BYTE *)v12 = *(_BYTE *)v10;
      }
      v13 = *(_BYTE *)v10;
      v14 = *(_BYTE *)v10++;
      if ( _ismbblead(v14) )
      {
        ++*(_DWORD *)a1;
        if ( a4 && *(_DWORD *)a1 <= v25 )
        {
          v22 = a4++;
          *(_BYTE *)v22 = *(_BYTE *)v10;
        }
        ++v10;
      }
      v8 = a5;
      if ( !v13 )
      {
        --v10;
        goto LABEL_16;
      }
    }
  }
  while ( v26 || v13 != 32 && v13 != 9 );
  if ( a4 )
    *(_BYTE *)(a4 - 1) = 0;
LABEL_16:
  v15 = 0;
  while ( *(_BYTE *)v10 )
  {
    while ( *(_BYTE *)v10 == 32 || *(_BYTE *)v10 == 9 )
      ++v10;
    if ( !*(_BYTE *)v10 )
      break;
    ++*v8;
    if ( a3 && *v8 <= v24 )
    {
      v16 = a3;
      a3 += 4;
      *(_DWORD *)v16 = a4;
    }
    while ( 1 )
    {
      v27 = 1;
      v17 = 0;
      while ( *(_BYTE *)v10 == 92 )
      {
        ++v10;
        ++v17;
      }
      if ( *(_BYTE *)v10 == 34 )
      {
        if ( !(v17 & 1) )
        {
          if ( v15 && *(_BYTE *)(v10 + 1) == 34 )
            ++v10;
          else
            v27 = 0;
          v15 = v15 == 0;
        }
        v17 >>= 1;
      }
      while ( v17 )
      {
        --v17;
        ++*(_DWORD *)a1;
        if ( a4 && *(_DWORD *)a1 <= v25 )
        {
          v21 = a4++;
          *(_BYTE *)v21 = 92;
        }
      }
      v18 = *(_BYTE *)v10;
      if ( !*(_BYTE *)v10 || !v15 && (v18 == 32 || v18 == 9) )
        break;
      if ( v27 )
      {
        ++*(_DWORD *)a1;
        v19 = _ismbblead(*(_BYTE *)v10);
        if ( a4 )
        {
          if ( v19 )
          {
            v23 = a4++;
            *(_BYTE *)v23 = *(_BYTE *)v10++;
            ++*(_DWORD *)a1;
          }
          v20 = a4++;
          *(_BYTE *)v20 = *(_BYTE *)v10;
        }
        else if ( v19 )
        {
          ++v10;
          ++*(_DWORD *)a1;
        }
        v8 = a5;
      }
      ++v10;
    }
    ++*(_DWORD *)a1;
    if ( a4 && *(_DWORD *)a1 <= v25 )
    {
      v6 = a4++;
      *(_BYTE *)v6 = 0;
    }
  }
  ++*v8;
  result = *v8;
  if ( a3 && result <= v24 )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (6E649155) --------------------------------------------------------
signed int _mtinitlocks()
{
  signed int v0; // esi@1
  struct _RTL_CRITICAL_SECTION *v1; // edi@1
  LPCRITICAL_SECTION *v3; // eax@6

  v0 = 0;
  v1 = (struct _RTL_CRITICAL_SECTION *)dword_6E699EE8;
  while ( 1 )
  {
    if ( dword_6E699DCC[2 * v0] == 1 )
    {
      v3 = &lpCriticalSection + 2 * v0;
      *v3 = v1;
      ++v1;
      if ( !__crtInitCritSecAndSpinCountEx(*v3, 4000) )
        break;
    }
    ++v0;
    if ( v0 >= 36 )
      return 1;
  }
  *(&lpCriticalSection + 2 * v0) = 0;
  return 0;
}
// 6E6491A4: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCountEx(_DWORD, _DWORD);
// 6E699DCC: using guessed type int dword_6E699DCC[];
// 6E699EE8: using guessed type int dword_6E699EE8[84];

//----- (6E6491BD) --------------------------------------------------------
int __cdecl __crtInitCritSecAndSpinCount(int a1, int a2)
{
  FARPROC v2; // esi@1
  int v3; // ST28_4@2
  HMODULE v5; // edi@5
  int v6; // [sp+0h] [bp-34h]@0
  int v7; // [sp+4h] [bp-30h]@0
  int v8; // [sp+8h] [bp-2Ch]@0
  int v9; // [sp+Ch] [bp-28h]@0
  int v10; // [sp+10h] [bp-24h]@0
  int v11; // [sp+14h] [bp-20h]@0
  int v12; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@2
  int savedregs; // [sp+34h] [bp+0h]@2

  v12 = 0;
  v2 = (FARPROC)_decode_pointer(dword_6E6991C4);
  if ( !v2 )
  {
    if ( _get_osplatform((int)&v12) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v12 != 1 )
    {
      v5 = GetModuleHandleW(L"kernelbase.dll");
      if ( v5 )
      {
        v2 = GetProcAddress(v5, "InitializeCriticalSectionAndSpinCount");
        if ( v2 )
        {
LABEL_7:
          dword_6E6991C4 = _encode_pointer((int)v2);
          goto LABEL_2;
        }
      }
      else
      {
        GetModuleHandleW(L"kernel32.dll");
      }
    }
    v2 = (FARPROC)sub_6E67B911;
    goto LABEL_7;
  }
LABEL_2:
  v3 = ((int (__stdcall *)(int, int, int, int, int, int, int, int, int, DWORD, EXCEPTION_POINTERS *, struct _EH3_EXCEPTION_REGISTRATION *, PVOID, PSCOPETABLE_ENTRY, _DWORD, int))v2)(
         a1,
         a2,
         v6,
         v7,
         v8,
         v9,
         v10,
         v11,
         v12,
         ms_exc.old_esp,
         ms_exc.exc_ptr,
         ms_exc.registration.Next,
         ms_exc.registration.ExceptionHandler,
         ms_exc.registration.ScopeTable,
         0,
         savedregs);
  ms_exc.registration.TryLevel = -2;
  return v3;
}
// 6E6991C4: using guessed type int dword_6E6991C4;

//----- (6E6492C3) --------------------------------------------------------
signed int _mtinit()
{
  HMODULE v0; // eax@1
  HMODULE v1; // edi@1
  DWORD v2; // eax@7
  int v3; // eax@10
  int v4; // ST08_4@10
  LPVOID v5; // eax@11
  int v6; // esi@11
  LPVOID v7; // ST0C_4@12
  int v8; // ST08_4@12
  int v9; // eax@12
  int v10; // ST04_4@12

  v0 = GetModuleHandleW(L"KERNEL32.DLL");
  v1 = v0;
  if ( v0 )
  {
    gpFlsAlloc = (int)GetProcAddress(v0, "FlsAlloc");
    gpFlsGetValue = GetProcAddress(v1, "FlsGetValue");
    gpFlsSetValue = (int)GetProcAddress(v1, "FlsSetValue");
    gpFlsFree = (int)GetProcAddress(v1, "FlsFree");
  }
  if ( !gpFlsAlloc || !gpFlsGetValue || !gpFlsSetValue || !gpFlsFree )
  {
    gpFlsGetValue = TlsGetValue;
    gpFlsAlloc = (int)__crtTlsAlloc;
    gpFlsSetValue = (int)TlsSetValue;
    gpFlsFree = (int)TlsFree;
  }
  v2 = TlsAlloc();
  __getvalueindex = v2;
  if ( v2 != -1 && TlsSetValue(v2, gpFlsGetValue) )
  {
    _init_pointers();
    gpFlsAlloc = _encode_pointer(gpFlsAlloc);
    gpFlsGetValue = (LPVOID)_encode_pointer((int)gpFlsGetValue);
    gpFlsSetValue = _encode_pointer(gpFlsSetValue);
    gpFlsFree = _encode_pointer(gpFlsFree);
    if ( _mtinitlocks() )
    {
      v3 = _decode_pointer(gpFlsAlloc);
      __flsindex = ((int (__thiscall *)(int, int (__stdcall *)(void *)))v3)(v4, _freefls);
      if ( __flsindex != -1 )
      {
        v5 = _calloc_crt(1u, 532);
        v6 = (int)v5;
        if ( v5 )
        {
          v7 = v5;
          v8 = __flsindex;
          v9 = _decode_pointer(gpFlsSetValue);
          if ( ((int (__thiscall *)(int, int, LPVOID))v9)(v10, v8, v7) )
          {
            _initptd(v6, 0);
            *(_DWORD *)(v6 + 4) = -1;
            return 1;
          }
          free((void *)v6);
        }
      }
    }
    _mtterm();
  }
  return 0;
}
// 6E647D35: using guessed type int _mtterm(void);
// 6E64A34C: using guessed type int _init_pointers(void);
// 6E699150: using guessed type int __flsindex;
// 6E699190: using guessed type int gpFlsAlloc;
// 6E699198: using guessed type int gpFlsSetValue;
// 6E69919C: using guessed type int gpFlsFree;

//----- (6E64945A) --------------------------------------------------------
int __cdecl _encode_pointer(int a1)
{
  int v1; // ST04_4@3
  LPVOID v2; // eax@3
  int v3; // eax@3
  FARPROC v4; // eax@4
  HMODULE v6; // eax@8

  if ( TlsGetValue(__getvalueindex)
    && __flsindex != -1
    && (v1 = __flsindex, v2 = TlsGetValue(__getvalueindex), (v3 = ((int (__stdcall *)(int))v2)(v1)) != 0) )
  {
    v4 = *(FARPROC *)(v3 + 504);
  }
  else
  {
    v6 = GetModuleHandleW(L"KERNELBASE.DLL");
    if ( !v6 )
    {
      v6 = GetModuleHandleW(L"KERNEL32.DLL");
      if ( !v6 )
        return a1;
    }
    v4 = GetProcAddress(v6, "EncodePointer");
  }
  if ( v4 )
    a1 = ((int (__stdcall *)(int))v4)(a1);
  return a1;
}
// 6E699150: using guessed type int __flsindex;

//----- (6E649518) --------------------------------------------------------
int __cdecl sub_6E649518(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // ecx@0
  signed int v8; // eax@1
  void *v9; // ebx@1
  int v10; // edi@1
  int v11; // eax@5
  int v12; // edi@5
  int v13; // eax@8
  void *v14; // esp@9
  void *v15; // eax@9
  int v16; // eax@14
  void *v18; // esi@29
  UINT v19; // eax@33
  const CHAR *v20; // eax@35
  BOOL v21; // edi@37
  signed int v22; // [sp+0h] [bp-14h]@9
  WORD CharType[2]; // [sp+Ch] [bp-8h]@2

  v8 = dword_6E6991D0;
  v9 = 0;
  v10 = v7;
  if ( !dword_6E6991D0 )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, CharType) )
    {
      dword_6E6991D0 = 1;
      goto LABEL_4;
    }
    if ( GetLastError() == 120 )
    {
      v8 = 2;
      dword_6E6991D0 = 2;
    }
    else
    {
      v8 = dword_6E6991D0;
    }
  }
  if ( v8 != 2 && v8 )
  {
    if ( v8 != 1 )
      return 0;
LABEL_4:
    *(_DWORD *)CharType = 0;
    if ( !CodePage )
      CodePage = *(_DWORD *)(*(_DWORD *)v10 + 4);
    v11 = MultiByteToWideChar(CodePage, 8 * (a7 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
    v12 = v11;
    if ( !v11 )
      return 0;
    if ( v11 <= 0 || (unsigned int)v11 > 0x7FFFFFF0 )
      goto LABEL_13;
    v13 = 2 * v11 + 8;
    if ( (unsigned int)v13 > 0x400 )
    {
      v15 = malloc(2 * v12 + 8);
      if ( !v15 )
        goto LABEL_12;
      *(_DWORD *)v15 = 56797;
    }
    else
    {
      v14 = alloca(v13);
      v15 = &v22;
      if ( !&v22 )
      {
LABEL_12:
        v9 = v15;
LABEL_13:
        if ( v9 )
        {
          memset(v9, 0, 2 * v12);
          v16 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v9, v12);
          if ( v16 )
            *(_DWORD *)CharType = GetStringTypeW(dwInfoType, (LPCWSTR)v9, v16, lpCharType);
          _freea(v9);
          return *(_DWORD *)CharType;
        }
        return 0;
      }
      v22 = 52428;
    }
    v15 = (char *)v15 + 8;
    goto LABEL_12;
  }
  v18 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)v10 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)v10 + 4);
  v19 = __ansicp(Locale);
  if ( v19 == -1 )
    return 0;
  if ( v19 != CodePage )
  {
    v20 = (const CHAR *)__convertcp(CodePage, v19, (int)lpMultiByteStr, (int)&cbMultiByte, 0, 0);
    v18 = (void *)v20;
    if ( !v20 )
      return 0;
    lpMultiByteStr = v20;
  }
  v21 = GetStringTypeA(Locale, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType);
  if ( v18 )
    free(v18);
  return v21;
}
// 6E6991D0: using guessed type int dword_6E6991D0;

//----- (6E649661) --------------------------------------------------------
int __cdecl _initterm_e(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@1

  v2 = a1;
  result = 0;
  while ( v2 < a2 && !result )
  {
    if ( *(_DWORD *)v2 )
      result = (*(int (**)(void))v2)();
    v2 += 4;
  }
  return result;
}

//----- (6E64968A) --------------------------------------------------------
signed int _ioinit()
{
  void *v0; // eax@1
  int i; // ecx@2
  DWORD v2; // eax@5
  signed int result; // eax@8
  signed int v4; // ebx@10
  int v5; // esi@11
  HANDLE v6; // eax@14
  HANDLE v7; // edi@14
  DWORD v8; // eax@20
  int v9; // eax@21
  signed int v10; // edi@26
  LPBYTE v11; // ebx@26
  signed int v12; // esi@28
  void *v13; // eax@29
  int *v14; // ecx@30
  int j; // edx@30
  int v16; // esi@43
  struct _STARTUPINFOA StartupInfo; // [sp+10h] [bp-64h]@1
  int k; // [sp+54h] [bp-20h]@37
  HANDLE *v19; // [sp+58h] [bp-1Ch]@26
  CPPEH_RECORD ms_exc; // [sp+5Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  GetStartupInfoA(&StartupInfo);
  ms_exc.registration.TryLevel = -2;
  v0 = calloc(0x20u, 0x24u);
  if ( v0 )
  {
    __pioinfo[0] = (int)v0;
    _nhandle = 32;
    for ( i = (int)((char *)v0 + 1152); (unsigned int)v0 < i; i = __pioinfo[0] + 1152 )
    {
      *((_BYTE *)v0 + 4) = 0;
      *(_DWORD *)v0 = -1;
      *((_BYTE *)v0 + 5) = 10;
      *((_DWORD *)v0 + 2) = 0;
      *((_BYTE *)v0 + 6) = 10;
      *((_BYTE *)v0 + 7) = 10;
      v0 = (char *)v0 + 36;
    }
    if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
    {
      v10 = *(_DWORD *)StartupInfo.lpReserved2;
      v11 = StartupInfo.lpReserved2 + 4;
      v19 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
      if ( v10 >= 2048 )
        v10 = 2048;
      v12 = 1;
      while ( (signed int)_nhandle < v10 )
      {
        v13 = calloc(0x20u, 0x24u);
        if ( !v13 )
        {
          v10 = _nhandle;
          break;
        }
        v14 = &__pioinfo[v12];
        *v14 = (int)v13;
        _nhandle += 32;
        for ( j = (int)((char *)v13 + 1152); (unsigned int)v13 < j; j = *v14 + 1152 )
        {
          *((_BYTE *)v13 + 4) = 0;
          *(_DWORD *)v13 = -1;
          *((_BYTE *)v13 + 5) = 10;
          *((_DWORD *)v13 + 2) = 0;
          *((_BYTE *)v13 + 6) = 10;
          *((_BYTE *)v13 + 7) = 10;
          v13 = (char *)v13 + 36;
        }
        ++v12;
      }
      for ( k = 0; k < v10; ++v19 )
      {
        if ( *v19 != (HANDLE)-1 && *v19 != (HANDLE)-2 && *v11 & 1 && (*v11 & 8 || GetFileType(*v19)) )
        {
          v16 = __pioinfo[k >> 5] + 36 * (k & 0x1F);
          *(_DWORD *)v16 = *v19;
          *(_BYTE *)(v16 + 4) = *v11;
          if ( !__crtInitCritSecAndSpinCount(v16 + 12, 4000) )
            goto LABEL_8;
          *(_DWORD *)(v16 + 8) |= 4u;
        }
        ++k;
        ++v11;
      }
    }
    v4 = 0;
    do
    {
      v5 = __pioinfo[0] + 36 * v4;
      if ( *(_DWORD *)v5 == -1 || *(_DWORD *)v5 == -2 )
      {
        *(_BYTE *)(v5 + 4) = -127;
        if ( v4 )
          v2 = -(v4 != 1) - 11;
        else
          v2 = -10;
        v6 = GetStdHandle(v2);
        v7 = v6;
        if ( v6 != (HANDLE)-1 && v6 && (v8 = GetFileType(v6)) != 0 )
        {
          *(_DWORD *)v5 = v7;
          v9 = (unsigned __int8)v8;
          if ( v9 == 2 )
          {
            *(_BYTE *)(v5 + 4) |= 0x40u;
          }
          else if ( v9 == 3 )
          {
            *(_BYTE *)(v5 + 4) |= 8u;
          }
          if ( !__crtInitCritSecAndSpinCount(v5 + 12, 4000) )
            goto LABEL_8;
          *(_DWORD *)(v5 + 8) |= 4u;
        }
        else
        {
          *(_BYTE *)(v5 + 4) |= 0x40u;
          *(_DWORD *)v5 = -2;
        }
      }
      else
      {
        *(_BYTE *)(v5 + 4) |= 0x80u;
      }
      ++v4;
    }
    while ( v4 < 3 );
    SetHandleCount(_nhandle);
    result = 0;
  }
  else
  {
LABEL_8:
    result = -1;
  }
  return result;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E6497A7) --------------------------------------------------------
signed int __initstdio()
{
  size_t v0; // eax@1
  void *v1; // eax@4
  int v2; // edx@5
  FILE *v3; // ecx@5
  signed int v4; // edx@8
  signed int v5; // ecx@8
  int v6; // eax@9
  signed int result; // eax@13

  v0 = _nstream;
  if ( _nstream )
  {
    if ( _nstream >= 20 )
      goto LABEL_4;
    v0 = 20;
  }
  else
  {
    v0 = 512;
  }
  _nstream = v0;
LABEL_4:
  v1 = calloc(v0, 4u);
  __piob = v1;
  if ( v1 || (_nstream = 20, v1 = calloc(0x14u, 4u), (__piob = v1) != 0) )
  {
    v2 = 0;
    v3 = _iob;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v2) = v3;
      ++v3;
      v2 += 4;
      if ( (signed int)v3 >= (signed int)dword_6E69A2B8 )
        break;
      v1 = __piob;
    }
    v4 = 0;
    v5 = (signed int)dword_6E69A048;
    do
    {
      v6 = *(_DWORD *)(36 * (v4 & 0x1F) + __pioinfo[v4 >> 5]);
      if ( v6 == -1 || v6 == -2 || !v6 )
        *(_DWORD *)v5 = -2;
      v5 += 32;
      ++v4;
    }
    while ( v5 < (signed int)dword_6E69A0A8 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 6E6991D8: using guessed type int _nstream;
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69A048: using guessed type int dword_6E69A048[2];
// 6E69A0A8: using guessed type int dword_6E69A0A8[124];
// 6E69A2B8: using guessed type int dword_6E69A2B8[2];

//----- (6E649AF7) --------------------------------------------------------
int __usercall sub_6E649AF7@<eax>(int a1@<esi>)
{
  int result; // eax@3
  int v2; // [sp+4h] [bp-10h]@1
  int v3; // [sp+Ch] [bp-8h]@5
  char v4; // [sp+10h] [bp-4h]@4

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v2, 0);
  dword_6E6991AC = 0;
  if ( a1 == -2 )
  {
    dword_6E6991AC = 1;
    result = GetOEMCP();
    goto LABEL_4;
  }
  if ( a1 == -3 )
  {
    dword_6E6991AC = 1;
    result = GetACP();
    goto LABEL_4;
  }
  if ( a1 == -4 )
  {
    result = *(_DWORD *)(v2 + 4);
    dword_6E6991AC = 1;
LABEL_4:
    if ( v4 )
      *(_DWORD *)(v3 + 112) &= 0xFFFFFFFD;
    return result;
  }
  if ( v4 )
    *(_DWORD *)(v3 + 112) &= 0xFFFFFFFD;
  return a1;
}
// 6E6991AC: using guessed type int dword_6E6991AC;

//----- (6E649B5C) --------------------------------------------------------
signed int _setargv()
{
  unsigned int v0; // esi@5
  char **v1; // edi@8
  signed int result; // eax@9
  ULONG pulResult; // [sp+Ch] [bp-14h]@5
  ULONG ulAddend; // [sp+10h] [bp-10h]@6
  unsigned int v5; // [sp+14h] [bp-Ch]@1
  int v6; // [sp+18h] [bp-8h]@4
  unsigned int v7; // [sp+1Ch] [bp-4h]@1

  v7 = 0;
  v5 = 0;
  if ( !__mbctype_initialized )
    __initmbctable();
  byte_6E699DC4 = 0;
  GetModuleFileNameA(0, Filename, 0x104u);
  _pgmptr = Filename;
  if ( !_acmdln || (v6 = _acmdln, !*(_BYTE *)_acmdln) )
    v6 = (int)Filename;
  sub_6E648FFD((int)&v5, v6, 0, 0, (signed int *)&v7);
  v0 = v7;
  if ( ULongLongToULong(4i64 * v7, &pulResult) >= 0
    && ULongLongToULong(4i64 * v5, &ulAddend) >= 0
    && ULongAdd(pulResult, ulAddend, &pulResult) >= 0
    && (v1 = (char **)malloc(pulResult)) != 0 )
  {
    sub_6E648FFD((int)&v5, v6, (int)v1, (int)&v1[v0], (signed int *)&v7);
    __argc = v7 - 1;
    __argv = v1;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 6E649938: using guessed type int __initmbctable(void);
// 6E6991F4: using guessed type int __mbctype_initialized;
// 6E6991FC: using guessed type int _acmdln;
// 6E699DC4: using guessed type char byte_6E699DC4;

//----- (6E649C5D) --------------------------------------------------------
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ullOperand > 0xFFFFFFFF )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ullOperand;
    result = 0;
  }
  return result;
}

//----- (6E649CD3) --------------------------------------------------------
int __cdecl sub_6E649CD3(int a1, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR a6, int cchDest, UINT CodePage, int a9)
{
  UINT v9; // esi@1
  int v10; // ebx@1
  int v11; // ecx@5
  LPCSTR v12; // eax@5
  int v13; // eax@9
  int v14; // eax@15
  int v15; // edi@15
  int v16; // eax@18
  void *v17; // esp@19
  void *v18; // eax@19
  WCHAR *v19; // eax@20
  unsigned int v20; // eax@23
  int v21; // eax@27
  void *v22; // esp@28
  void *v23; // eax@28
  WCHAR *v24; // eax@29
  int v26; // edi@62
  const CHAR *v27; // eax@68
  int v28; // eax@69
  int v29; // esi@70
  int v30; // eax@73
  void *v31; // esp@74
  void *v32; // eax@75
  void *v33; // eax@74
  void *v34; // eax@79
  CHAR *v35; // [sp-10h] [bp-5Ch]@33
  int v36; // [sp-Ch] [bp-58h]@33
  unsigned int v37; // [sp-4h] [bp-50h]@19
  unsigned int v38; // [sp-4h] [bp-50h]@28
  int v39; // [sp+0h] [bp-4Ch]@19
  void *v40; // [sp+10h] [bp-3Ch]@78
  void *Memory; // [sp+14h] [bp-38h]@62
  int v42; // [sp+18h] [bp-34h]@14
  UINT v43; // [sp+1Ch] [bp-30h]@15
  LPCSTR lpSrcStr; // [sp+20h] [bp-2Ch]@14
  size_t Size; // [sp+24h] [bp-28h]@14
  LPWSTR lpDestStr; // [sp+28h] [bp-24h]@14
  LPWSTR lpWideCharStr; // [sp+2Ch] [bp-20h]@21
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@16

  v9 = CodePage;
  v10 = 0;
  if ( !dword_6E6991CC )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_6E6991CC = 1;
    }
    else if ( GetLastError() == 120 )
    {
      dword_6E6991CC = 2;
    }
  }
  if ( cbMultiByte > 0 )
  {
    v11 = cbMultiByte;
    v12 = lpMultiByteStr;
    while ( 1 )
    {
      --v11;
      if ( !*v12 )
        break;
      ++v12;
      if ( !v11 )
      {
        v11 = -1;
        break;
      }
    }
    v13 = cbMultiByte - v11 - 1;
    if ( v13 < cbMultiByte )
      v13 = cbMultiByte - v11;
    cbMultiByte = v13;
  }
  if ( dword_6E6991CC != 2 && dword_6E6991CC )
  {
    if ( dword_6E6991CC == 1 )
    {
      lpSrcStr = 0;
      lpDestStr = 0;
      v42 = 0;
      Size = 0;
      if ( !v9 )
      {
        v9 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
      }
      v14 = MultiByteToWideChar(v9, 8 * (a9 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
      v15 = v14;
      v43 = v14;
      if ( v14 )
      {
        ms_exc.registration.TryLevel = 1;
        if ( v14 <= 0 || 0xFFFFFFE0 / v14 < 2 )
        {
          v19 = 0;
        }
        else
        {
          v16 = 2 * v14 + 8;
          if ( (unsigned int)v16 > 0x400 )
          {
            v37 = 56797;
            v18 = malloc(2 * v15 + 8);
          }
          else
          {
            v17 = alloca(v16);
            ms_exc.old_esp = (DWORD)&v39;
            v18 = &v39;
            v37 = 52428;
          }
          v19 = (WCHAR *)_MarkAllocaS(v18, v37);
        }
        lpWideCharStr = v19;
        ms_exc.registration.TryLevel = -2;
        if ( v19 )
        {
LABEL_22:
          if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, lpWideCharStr, v15) )
          {
            v20 = LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, 0, 0);
            v10 = v20;
            lpSrcStr = (LPCSTR)v20;
            if ( v20 )
            {
              if ( dwMapFlags & 0x400 )
              {
                if ( cchDest && (signed int)v20 <= cchDest )
                  LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, (LPWSTR)a6, cchDest);
                goto LABEL_35;
              }
              ms_exc.registration.TryLevel = 2;
              if ( (signed int)v20 <= 0 || 0xFFFFFFE0 / v20 < 2 )
              {
                v24 = 0;
              }
              else
              {
                v21 = 2 * v20 + 8;
                if ( (unsigned int)v21 > 0x400 )
                {
                  v38 = 56797;
                  v23 = malloc(2 * v10 + 8);
                }
                else
                {
                  v22 = alloca(v21);
                  ms_exc.old_esp = (DWORD)&v39;
                  v23 = &v39;
                  v38 = 52428;
                }
                v24 = (WCHAR *)_MarkAllocaS(v23, v38);
              }
              lpDestStr = v24;
              ms_exc.registration.TryLevel = -2;
              if ( v24 )
                goto LABEL_31;
              lpDestStr = (LPWSTR)malloc(2 * v10);
              if ( lpDestStr )
              {
                Size = 1;
LABEL_31:
                if ( LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, lpDestStr, v10) )
                {
                  if ( cchDest )
                  {
                    v36 = cchDest;
                    v35 = a6;
                  }
                  else
                  {
                    v36 = 0;
                    v35 = 0;
                  }
                  v10 = WideCharToMultiByte(CodePage, 0, lpDestStr, v10, v35, v36, 0, 0);
                }
                goto LABEL_35;
              }
            }
          }
LABEL_35:
          if ( Size )
          {
            free(lpDestStr);
          }
          else if ( lpDestStr )
          {
            _freea(lpDestStr);
          }
          if ( v42 )
          {
            free(lpWideCharStr);
          }
          else if ( lpWideCharStr )
          {
            _freea(lpWideCharStr);
          }
          return v10;
        }
        lpWideCharStr = (LPWSTR)malloc(2 * v15);
        if ( lpWideCharStr )
        {
          v42 = 1;
          goto LABEL_22;
        }
      }
    }
    return 0;
  }
  lpSrcStr = 0;
  v26 = 0;
  Memory = 0;
  v42 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( !v9 )
  {
    v9 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  v43 = __ansicp(Locale);
  if ( v43 == -1 )
    return 0;
  if ( v43 != v9 )
  {
    v27 = (const CHAR *)__convertcp(v9, v43, (int)lpMultiByteStr, (int)&cbMultiByte, 0, 0);
    lpSrcStr = v27;
    if ( !v27 )
      return 0;
    v28 = LCMapStringA(Locale, dwMapFlags, v27, cbMultiByte, 0, 0);
    Size = v28;
    if ( !v28 )
      goto LABEL_70;
    ms_exc.registration.TryLevel = 0;
    if ( v28 <= 0 || (unsigned int)v28 > 0xFFFFFFE0 )
    {
      v33 = 0;
    }
    else
    {
      v30 = v28 + 8;
      if ( (unsigned int)v30 > 0x400 )
      {
        v32 = malloc(v30);
        v33 = _MarkAllocaS(v32, 0xDDDDu);
      }
      else
      {
        v31 = alloca(v30);
        ms_exc.old_esp = (DWORD)&v39;
        v33 = _MarkAllocaS(&v39, 0xCCCCu);
      }
    }
    v26 = (int)v33;
    v40 = v33;
    ms_exc.registration.TryLevel = -2;
    if ( !v33 )
    {
      v34 = malloc(Size);
      v26 = (int)v34;
      if ( !v34 )
        goto LABEL_70;
      memset(v34, 0, Size);
      v42 = 1;
    }
    Size = LCMapStringA(Locale, dwMapFlags, lpSrcStr, cbMultiByte, (LPSTR)v26, Size);
    if ( Size )
    {
      Memory = __convertcp(v43, CodePage, v26, (int)&Size, (int)a6, cchDest);
      v29 = Memory != 0 ? Size : 0;
LABEL_83:
      if ( v42 )
      {
        free((void *)v26);
      }
      else if ( v26 )
      {
        _freea((void *)v26);
      }
      goto LABEL_89;
    }
LABEL_70:
    v29 = 0;
    goto LABEL_83;
  }
  v29 = LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cbMultiByte, a6, cchDest);
LABEL_89:
  if ( lpSrcStr )
    free((void *)lpSrcStr);
  if ( Memory && a6 != Memory )
    free(Memory);
  return v29;
}
// 6E6991CC: using guessed type int dword_6E6991CC;

//----- (6E649F51) --------------------------------------------------------
void __cdecl _freea(void *Memory)
{
  if ( Memory )
  {
    if ( *((_DWORD *)Memory - 2) == 56797 )
      free((char *)Memory - 8);
  }
}

//----- (6E649F73) --------------------------------------------------------
signed int __thiscall ATL::CComModule::Init(ATL::CComModule *this, struct ATL::_ATL_OBJMAP_ENTRY *a2, HINSTANCE a3)
{
  *((_DWORD *)this + 25) = 0;
  *(_DWORD *)this = 100;
  return ATL::AtlModuleInit(this, a2, a3);
}

//----- (6E649F97) --------------------------------------------------------
signed int __stdcall ATL::AtlModuleInit(struct ATL::_ATL_MODULE *a1, struct ATL::_ATL_OBJMAP_ENTRY *a2, HINSTANCE a3)
{
  signed int result; // eax@3

  if ( a1 && *(_DWORD *)a1 >= 0x64u )
  {
    *((_DWORD *)a1 + 4) = a2;
    *((_DWORD *)a1 + 2) = a3;
    *((_DWORD *)a1 + 3) = a3;
    *((_DWORD *)a1 + 1) = a3;
    *((_DWORD *)a1 + 5) = 0;
    *((_DWORD *)a1 + 6) = 0;
    InitializeCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 28));
    InitializeCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 52));
    InitializeCriticalSection((LPCRITICAL_SECTION)((char *)a1 + 76));
    result = 0;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E64A015) --------------------------------------------------------
signed int __stdcall IsSystemUpgradeInProgress()
{
  signed int v0; // esi@1
  DWORD cbData; // [sp+4h] [bp-10h]@2
  BYTE Data[4]; // [sp+8h] [bp-Ch]@2
  DWORD Type; // [sp+Ch] [bp-8h]@2
  HKEY phkResult; // [sp+10h] [bp-4h]@1

  v0 = 0;
  phkResult = 0;
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, 1u, &phkResult) )
  {
    *(_DWORD *)Data = 0;
    cbData = 4;
    Type = 0;
    if ( !RegQueryValueExW(phkResult, L"Upgrade", 0, &Type, Data, &cbData) && Type == 4 && *(_DWORD *)Data == 1 )
      v0 = 1;
    RegCloseKey(phkResult);
  }
  return v0;
}

//----- (6E64A0AB) --------------------------------------------------------
int __cdecl _cinit(int a1)
{
  int v1; // eax@4
  int result; // eax@4

  if ( _FPinit && _IsNonwritableInCurrentImage((int)&_FPinit) )
    _FPinit(a1);
  _initp_misc_cfltcvt_tab();
  v1 = _encoded_null();
  __onexitend = v1;
  __onexitbegin = v1;
  result = _initterm_e((unsigned int)&__xi_a, (unsigned int)&__xi_z);
  if ( !result )
  {
    sub_6E6479D9((int (*)(void))&__xc_a, (unsigned int)&__xc_z);
    if ( __dyn_tls_init_callback )
    {
      if ( _IsNonwritableInCurrentImage((int)&__dyn_tls_init_callback) )
        __dyn_tls_init_callback(0, 2, 0);
    }
    result = 0;
  }
  return result;
}
// 6E648CDF: using guessed type int _encoded_null(void);
// 6E648DDD: using guessed type int _initp_misc_cfltcvt_tab(void);
// 6E64A11C: using guessed type int __xc_a;
// 6E64A120: using guessed type int __xc_z;
// 6E64A124: using guessed type int __xi_a;
// 6E64A134: using guessed type int __xi_z;
// 6E64A138: using guessed type int (__cdecl *_FPinit)(_DWORD);
// 6E6991EC: using guessed type int __onexitend;
// 6E6991F0: using guessed type int __onexitbegin;
// 6E69B400: using guessed type int (__stdcall *__dyn_tls_init_callback)(_DWORD, _DWORD, _DWORD);

//----- (6E64A1D5) --------------------------------------------------------
BOOL _get_sse2_info()
{
  unsigned int v0; // et0@1
  unsigned int v1; // ecx@1
  unsigned int v2; // et0@1
  int v14; // [sp+18h] [bp-4h]@1

  v14 = 0;
  v0 = __readeflags();
  v1 = v0;
  __writeeflags(v0 ^ 0x200000);
  v2 = __readeflags();
  if ( v2 != v1 )
  {
    __writeeflags(v1);
    _EAX = 0;
    __asm { cpuid }
    _EAX = 1;
    __asm { cpuid }
    v14 = _EDX;
  }
  return v14 & 0x4000000 && sub_6E64A23C();
}

//----- (6E64A23C) --------------------------------------------------------
signed int sub_6E64A23C()
{
  return 1;
}

//----- (6E64A289) --------------------------------------------------------
int __cdecl _IsNonwritableInCurrentImage(int a1)
{
  int v1; // eax@2
  int result; // eax@3

  if ( _ValidateImageBase((int)byte_6E640000)
    && (v1 = _FindPESection((int)byte_6E640000, a1 - (_DWORD)byte_6E640000)) != 0 )
    result = ~(unsigned __int8)(*(_DWORD *)(v1 + 36) >> 31) & 1;
  else
    result = 0;
  return result;
}

//----- (6E64A301) --------------------------------------------------------
int __cdecl _FindPESection(int a1, unsigned int a2)
{
  int v2; // ecx@1
  unsigned int v3; // esi@1
  unsigned int v4; // edx@1
  int result; // eax@1
  unsigned int v6; // ecx@2

  v2 = a1 + *(_DWORD *)(a1 + 60);
  v3 = *(_WORD *)(v2 + 6);
  v4 = 0;
  result = *(_WORD *)(v2 + 20) + v2 + 24;
  if ( *(_WORD *)(v2 + 6) )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(result + 12);
      if ( a2 >= v6 && a2 < v6 + *(_DWORD *)(result + 8) )
        break;
      ++v4;
      result += 40;
      if ( v4 >= v3 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (6E64A3C6) --------------------------------------------------------
int __cdecl sub_6E64A3C6(struct localeinfo_struct *a1, char a2, int a3, char a4)
{
  int result; // eax@3
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@6
  char v8; // [sp+Ch] [bp-4h]@5

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v5, a1);
  if ( (unsigned __int8)a4 & *(_BYTE *)(v6 + (unsigned __int8)a2 + 29)
    || (a3 ? (result = (unsigned __int16)(a3 & *(_WORD *)(*(_DWORD *)(v5 + 200) + 2 * (unsigned __int8)a2))) : (result = 0),
        result) )
    result = 1;
  if ( v8 )
    *(_DWORD *)(v7 + 112) &= 0xFFFFFFFD;
  return result;
}

//----- (6E64A412) --------------------------------------------------------
void *__crtGetEnvironmentStringsA()
{
  signed int v0; // eax@1
  void *v1; // ebx@1
  const WCHAR *v2; // edi@1
  const WCHAR *i; // eax@5
  int v4; // eax@8
  CHAR *v5; // eax@9
  LPCH v7; // eax@24
  CHAR *v8; // esi@24
  void *v9; // eax@28
  void *v10; // edi@28
  int cchWideChar; // [sp+Ch] [bp-Ch]@8
  int cbMultiByte; // [sp+10h] [bp-8h]@8
  int cbMultiBytea; // [sp+10h] [bp-8h]@28
  void *Memory; // [sp+14h] [bp-4h]@9

  v0 = dword_6E6991A0;
  v1 = 0;
  v2 = 0;
  if ( !dword_6E6991A0 )
  {
    v2 = GetEnvironmentStringsW();
    if ( v2 )
    {
      dword_6E6991A0 = 1;
      goto LABEL_4;
    }
    if ( GetLastError() == 120 )
    {
      v0 = 2;
      dword_6E6991A0 = 2;
    }
    else
    {
      v0 = dword_6E6991A0;
    }
  }
  if ( v0 == 1 )
  {
LABEL_4:
    if ( !v2 )
    {
      v2 = GetEnvironmentStringsW();
      if ( !v2 )
        return 0;
    }
    for ( i = v2; *i; ++i )
    {
      do
        ++i;
      while ( *i );
    }
    cchWideChar = i - v2 + 1;
    v4 = WideCharToMultiByte(0, 0, v2, cchWideChar, 0, 0, 0, 0);
    cbMultiByte = v4;
    if ( v4 )
    {
      v5 = (CHAR *)malloc(v4);
      Memory = v5;
      if ( v5 )
      {
        if ( !WideCharToMultiByte(0, 0, v2, cchWideChar, v5, cbMultiByte, 0, 0) )
        {
          free(Memory);
          Memory = 0;
        }
        v1 = Memory;
      }
    }
    FreeEnvironmentStringsW((LPWCH)v2);
    return v1;
  }
  if ( v0 != 2 && v0 )
    return 0;
  v7 = GetEnvironmentStrings();
  v8 = v7;
  if ( !v7 )
    return 0;
  for ( ; *v7; ++v7 )
  {
    do
      ++v7;
    while ( *v7 );
  }
  cbMultiBytea = v7 - v8 + 1;
  v9 = malloc(cbMultiBytea);
  v10 = v9;
  if ( !v9 )
  {
    FreeEnvironmentStringsA(v8);
    return 0;
  }
  memcpy(v9, v8, cbMultiBytea);
  FreeEnvironmentStringsA(v8);
  return v10;
}
// 6E6991A0: using guessed type int dword_6E6991A0;

//----- (6E64A4CA) --------------------------------------------------------
void *__cdecl malloc(size_t Size)
{
  size_t v1; // esi@1
  SIZE_T v2; // eax@5
  LPVOID v3; // eax@6
  void *v4; // ebx@7
  void *result; // eax@8

  v1 = Size;
  if ( Size > 0xFFFFFFE0 )
  {
    _callnewh(Size);
    *_errno() = 12;
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( !_crtheap )
      {
        _FF_MSGBANNER();
        _NMSG_WRITE(30);
        __crtExitProcess(0xFFu);
      }
      if ( __active_heap == 1 )
      {
        v2 = v1 ? v1 : 1;
        v3 = HeapAlloc(_crtheap, 0, v2);
      }
      else if ( __active_heap != 3 || (v3 = (LPVOID)V6_HeapAlloc(v1)) == 0 )
      {
        if ( !v1 )
          v1 = 1;
        v3 = HeapAlloc(_crtheap, 0, (v1 + 15) & 0xFFFFFFF0);
      }
      v4 = v3;
      if ( v3 )
        break;
      if ( !_newmode )
      {
        *_errno() = 12;
LABEL_22:
        *_errno() = 12;
        break;
      }
      if ( !_callnewh(Size) )
        goto LABEL_22;
      v1 = Size;
    }
    result = v4;
  }
  return result;
}
// 6E67900D: using guessed type _DWORD __cdecl V6_HeapAlloc(_DWORD);
// 6E67B6AF: using guessed type int _FF_MSGBANNER(void);
// 6E67B92B: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 6E6991E0: using guessed type int __active_heap;
// 6E69C074: using guessed type int _newmode;

//----- (6E64A52B) --------------------------------------------------------
signed int __cdecl _heap_init(int a1)
{
  _crtheap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( _crtheap )
  {
    __active_heap = __heap_select();
    if ( __active_heap != 3 || __sbh_heap_init(1016) )
      return 1;
    HeapDestroy(_crtheap);
    _crtheap = 0;
  }
  return 0;
}
// 6E67B958: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 6E6991E0: using guessed type int __active_heap;

//----- (6E64A570) --------------------------------------------------------
signed int __heap_select()
{
  signed int result; // eax@5
  unsigned int v1; // [sp+4h] [bp-8h]@1
  int v2; // [sp+8h] [bp-4h]@1

  v2 = 0;
  v1 = 0;
  if ( _get_osplatform((int)&v2) )
    _invoke_watson(0, 0, 0, 0, 0);
  if ( _get_winmajor((int)&v1) )
    _invoke_watson(0, 0, 0, 0, 0);
  if ( v2 != 2 || v1 < 5 )
    result = 3;
  else
    result = 1;
  return result;
}

//----- (6E64A5C0) --------------------------------------------------------
signed int __cdecl _get_winmajor(int a1)
{
  signed int result; // eax@3

  if ( a1 && _osplatform )
  {
    *(_DWORD *)a1 = _winmajor;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 6E699160: using guessed type int _osplatform;

//----- (6E64A5F1) --------------------------------------------------------
volatile LONG *__updatetmbcinfo()
{
  int v0; // eax@1
  int v1; // edi@1
  volatile LONG *v2; // esi@4

  v0 = _getptd();
  v1 = v0;
  if ( (*(_BYTE *)(v0 + 112) & 2 || !(__globallocalestatus & 1)) && *(_DWORD *)(v0 + 108) )
  {
    v2 = *(volatile LONG **)(v0 + 104);
  }
  else
  {
    _lock(13);
    v2 = *(volatile LONG **)(v1 + 104);
    if ( v2 != ___ptmbcinfo )
    {
      if ( v2 && !InterlockedDecrement(v2) && v2 != &__initialmbcinfo )
        free((void *)v2);
      *(_DWORD *)(v1 + 104) = ___ptmbcinfo;
      v2 = ___ptmbcinfo;
      InterlockedIncrement(___ptmbcinfo);
    }
    _unlock(13);
  }
  if ( !v2 )
    _amsg_exit(32);
  return v2;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E6770A0: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);
// 6E69B2D4: using guessed type char __globallocalestatus;

//----- (6E64A659) --------------------------------------------------------
int _getptd()
{
  int v0; // esi@1

  v0 = _getptd_noexit();
  if ( !v0 )
    _amsg_exit(16);
  return v0;
}
// 6E6483B5: using guessed type int _getptd_noexit(void);
// 6E6770A0: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);

//----- (6E64A679) --------------------------------------------------------
signed int __stdcall StringCchCopyW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3)
{
  signed int result; // eax@1
  unsigned __int16 *v4; // eax@4
  signed int v5; // ebx@4
  unsigned int v6; // esi@4
  unsigned __int16 v7; // cx@6

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = a1;
    v5 = 0;
    v6 = a2;
    if ( !a2 )
      goto LABEL_15;
    do
    {
      if ( !(2147483646 - a2 + v6) )
        break;
      v7 = *(unsigned __int16 *)((char *)v4 + (char *)a3 - (char *)a1);
      if ( !v7 )
        break;
      *v4 = v7;
      ++v4;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_15:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (6E64A6FC) --------------------------------------------------------
__int32 __stdcall HrRegCreateKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
  __int32 result; // eax@1
  bool v8; // sf@1

  result = RegCreateKeyExW(
             hKey,
             lpSubKey,
             0,
             0,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             phkResult,
             lpdwDisposition);
  v8 = result < 0;
  if ( result > 0 )
  {
    result = (unsigned __int16)result | 0x80070000;
    v8 = result < 0;
  }
  if ( v8 )
    *phkResult = 0;
  return result;
}

//----- (6E64A73A) --------------------------------------------------------
__int32 __stdcall HrRegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD dwType, BYTE *lpData, DWORD cbData)
{
  __int32 result; // eax@1

  result = RegSetValueExW(hKey, lpValueName, 0, dwType, lpData, cbData);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E64A788) --------------------------------------------------------
#error "6E64A9F0: invalid basic block (funcsize=155)"

//----- (6E64AAAF) --------------------------------------------------------
void __stdcall GetBindingsBelowComponent(const struct CComponent *a1, struct GBCONTEXT *a2)
{
  const struct CComponent *v2; // ebx@11
  struct GBCONTEXT *v3; // esi@1
  __int32 v4; // eax@1
  int v5; // edi@2
  signed int v6; // [sp+4h] [bp-4h]@1
  CBindPath *v7; // [sp+14h] [bp+Ch]@1

  v6 = 0;
  v3 = a2;
  v7 = (struct GBCONTEXT *)((char *)a2 + 24);
  v4 = CBindPath::HrAppendComponent(v7, a1);
  *((_DWORD *)v3 + 5) = v4;
  if ( !v4 )
  {
    v5 = *(_DWORD *)(*(_DWORD *)v3 + 28);
    if ( v5 == *(_DWORD *)(*(_DWORD *)v3 + 32) )
      goto LABEL_19;
    do
    {
      if ( a1 == *(const struct CComponent **)v5 )
      {
        v2 = *(const struct CComponent **)(v5 + 4);
        if ( CComponentList::FComponentInList(v7, *(const struct CComponent **)(v5 + 4)) )
        {
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Circular binding detected...\n");
        }
        else
        {
          v6 = 1;
          GetBindingsBelowComponent(v2, v3);
          if ( *((_DWORD *)v3 + 5) )
            return;
        }
      }
      v5 += 8;
    }
    while ( v5 != *(_DWORD *)(*(_DWORD *)v3 + 32) );
    if ( !v6 )
    {
LABEL_19:
      if ( a1 != *((const struct CComponent **)v3 + 2)
        && (!*((_DWORD *)v3 + 3) || !CNetConfigCore::FIsBindPathDisabled(*(CNetConfigCore **)v3, v7, 1u)) )
        *((_DWORD *)v3 + 5) = CBindingSet::HrAddBindPath(*((CBindingSet **)v3 + 1), v7, *((_DWORD *)v3 + 4) | 0x400);
    }
    CBindPath::RemoveLastComponent(v7);
  }
}

//----- (6E64AB32) --------------------------------------------------------
int __thiscall CBindPath::RemoveLastComponent(CBindPath *this)
{
  CBindPath *v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@1

  v1 = this;
  v2 = (int)((char *)this + 4);
  v3 = 0;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4)) )
  {
    v3 = *(_DWORD *)(*((_DWORD *)v1 + 3) - 4);
    std::vector<CComponent *,std::nc_allocator<CComponent *>>::pop_back(v2);
  }
  return v3;
}

//----- (6E64AB63) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::pop_back(int this)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = this;
  result = std::vector<CParam *,std::nc_allocator<CParam *>>::size(this);
  if ( result )
    *(_DWORD *)(v1 + 8) -= 4;
  return result;
}

//----- (6E64AB7C) --------------------------------------------------------
int __thiscall CNetConfigCore::FIsBindPathDisabled(CNetConfigCore *this, const struct CBindPath *a2, unsigned __int32 a3)
{
  CNetConfigCore *v3; // edi@1
  CBindPath *i; // esi@1

  v3 = this;
  for ( i = (CBindPath *)*((_DWORD *)this + 13); ; i = (CBindPath *)((char *)i + 20) )
  {
    if ( i == *((CBindPath **)v3 + 14) )
      return 0;
    if ( CBindPath::FIsSameBindPathAs(i, a2) || a3 & 2 && CBindPath::FIsSubPathOf(i, a2) )
      break;
  }
  return 1;
}

//----- (6E64ABC9) --------------------------------------------------------
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPWSTR v4; // ebx@3
  STRSAFE_LPWSTR v5; // ecx@4

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  v4 = pszDest;
  if ( result < 0 )
  {
    v5 = 0;
  }
  else
  {
    result = sub_6E64AC25((int)pszDest, cchDest, (int)&pszDest);
    v5 = pszDest;
  }
  if ( result >= 0 )
    result = sub_6E641D2F((int)pszSrc, cchDest - (_DWORD)v5, (int)&v4[(_DWORD)v5], 0, 0x7FFFFFFF);
  return result;
}

//----- (6E64AC25) --------------------------------------------------------
int __usercall sub_6E64AC25@<eax>(int a1@<eax>, int a2@<edx>, int a3@<edi>)
{
  int v3; // esi@1
  int result; // eax@1
  int v5; // ecx@1

  v3 = a1;
  result = 0;
  v5 = a2;
  if ( !a2 )
    goto LABEL_11;
  do
  {
    if ( !*(_WORD *)v3 )
      break;
    v3 += 2;
    --a2;
  }
  while ( a2 );
  if ( !a2 )
LABEL_11:
    result = -2147024809;
  JUMPOUT(a3, 0, nullsub_1);
  if ( result < 0 )
  {
    *(_DWORD *)a3 = 0;
    result = nullsub_1(v5);
  }
  else
  {
    *(_DWORD *)a3 = v5 - a2;
  }
  return result;
}
// 6E656008: using guessed type int __thiscall nullsub_1(_DWORD);

//----- (6E64AC62) --------------------------------------------------------
int __thiscall CNetConfigCore::HrGetComponentBindings(CNetConfigCore *this, const struct CComponent *a2, unsigned __int32 a3, struct CBindingSet *a4)
{
  CNetConfigCore *v4; // ebx@1
  int v5; // esi@3
  CNetConfigCore *Dst; // [sp+Ch] [bp-38h]@3
  struct CBindingSet *v8; // [sp+10h] [bp-34h]@3
  const struct CComponent *v9; // [sp+14h] [bp-30h]@3
  unsigned __int32 v10; // [sp+18h] [bp-2Ch]@3
  int v11; // [sp+1Ch] [bp-28h]@3
  int v12; // [sp+20h] [bp-24h]@3
  char v13; // [sp+24h] [bp-20h]@1
  char v14; // [sp+28h] [bp-1Ch]@3
  int v15; // [sp+40h] [bp-4h]@1

  v4 = this;
  CComponentList::CComponentList(&v13);
  v15 = 0;
  if ( !(a3 & 1) )
    std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)a4 + 4));
  memset(&Dst, 0, 0x2Cu);
  v8 = a4;
  Dst = v4;
  v9 = a2;
  v10 = a3 & 2;
  v11 = (a3 & 1) != 0 ? 512 : 256;
  GetBindingsBelowComponent(a2, (struct GBCONTEXT *)&Dst);
  v5 = v12;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v14);
  return v5;
}

//----- (6E64ACEA) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  return std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(
           this,
           (int)&v2,
           *(_DWORD *)(this + 4),
           *(_DWORD *)(this + 8));
}

//----- (6E64AD08) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  int result; // eax@2
  void **v7; // eax@3
  void *v8; // edi@3
  char v9; // [sp+4h] [bp-4h]@3

  v4 = this;
  v5 = a3;
  if ( a3 != a4 )
  {
    v7 = (void **)std::copy<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(
                    (int)&v9,
                    a4,
                    *(_DWORD *)(v4 + 8),
                    (void *)a3);
    v8 = *v7;
    std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(*v7, *(_DWORD *)(v4 + 8), v4);
    v5 = a3;
    *(_DWORD *)(v4 + 8) = v8;
  }
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}

//----- (6E64AE4E) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CMSClient>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 4);
  if ( !v1 && lpMem )
    ATL::CComObject<CMSClient>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E64AE79) --------------------------------------------------------
int __stdcall HrSaveNetworkConfigurationToRegistry(struct CNetConfig *lpMem)
{
  int v1; // esi@1
  unsigned int v2; // eax@3
  DWORD cbData; // [sp+4h] [bp-8h]@2
  HKEY hKey; // [sp+8h] [bp-4h]@1

  v1 = HrOpenNetworkKey(0x20006u, &hKey);
  if ( !v1 )
  {
    v1 = HrSaveNetworkConfigurationToBufferWithAlloc(lpMem, (size_t)&lpMem, &cbData);
    if ( !v1 )
    {
      v2 = WaitForConfigLoadSaveMutex();
      if ( v2 )
      {
        if ( (signed int)v2 > 0 )
          v2 = (unsigned __int16)v2 | 0x80070000;
        v1 = v2;
      }
      else
      {
        v1 = HrRegSetBinary(hKey, L"Config", (BYTE *)lpMem, cbData);
        MemFree((void *)lpMem);
        RegFlushKey(hKey);
        ReleaseConfigLoadSaveMutex();
      }
    }
    RegCloseKey(hKey);
  }
  return v1;
}

//----- (6E64AEF8) --------------------------------------------------------
int __thiscall CIndices::PGetIndexByFilter(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int result; // eax@5

  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)(this + 8);
  while ( v3 != v4 )
  {
    if ( *(_DWORD *)v3 == a3 )
    {
      *(_DWORD *)(v3 + 12) = 0;
      break;
    }
    v3 += 16;
  }
  result = a2;
  *(_DWORD *)a2 = v3;
  return result;
}

//----- (6E64AF74) --------------------------------------------------------
int *__usercall sub_6E64AF74@<eax>(int *result@<eax>, int a2@<ebx>, signed __int16 *a3, int *a4)
{
  int v4; // edi@1

  v4 = (int)result;
  if ( *(_BYTE *)(a2 + 12) & 0x40 && !*(_DWORD *)(a2 + 8) )
  {
    result = a4;
    *(_DWORD *)v4 += a4;
  }
  else
  {
    while ( (signed int)a4 > 0 )
    {
      a4 = (int *)((char *)a4 - 1);
      result = (int *)sub_6E64B4D5(a2, v4, *a3);
      ++a3;
      if ( *(_DWORD *)v4 == -1 )
      {
        result = _errno();
        if ( *result != 42 )
          return result;
        result = (int *)sub_6E64B4D5(a2, v4, 63);
      }
    }
  }
  return result;
}

//----- (6E64B00F) --------------------------------------------------------
signed int __cdecl _swoutput_s(char *a1, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // edi@1
  signed int result; // eax@4
  FILE File; // [sp+8h] [bp-20h]@3
  signed int v7; // [sp+34h] [bp+Ch]@4

  v4 = a2;
  if ( a2 == -1 )
  {
    File._cnt = 0x7FFFFFFF;
  }
  else
  {
    if ( a2 > 0x3FFFFFFF )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
    File._cnt = 2 * a2;
  }
  File._base = a1;
  File._ptr = a1;
  File._flag = 66;
  result = _woutput_s((int)&File, a3, a4);
  v7 = result;
  *(_WORD *)&a1[2 * v4 - 2] = 0;
  if ( result >= 0 )
  {
    --File._cnt;
    if ( File._cnt >= 0 )
    {
      *File._ptr = 0;
      ++File._ptr;
LABEL_7:
      --File._cnt;
      if ( File._cnt >= 0 )
      {
        *File._ptr = 0;
        return v7;
      }
      if ( _flsbuf_s(0, &File) != -1 )
        return v7;
      return -2;
    }
    if ( _flsbuf_s(0, &File) != -1 )
      goto LABEL_7;
    return -2;
  }
  if ( File._cnt < 0 )
    return -2;
  if ( a1 )
  {
    if ( v4 > 0 )
      *(_WORD *)a1 = 0;
  }
  return result;
}

//----- (6E64B09A) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetClassDevs(GUID *ClassGuid, PCWSTR Enumerator, HWND hwndParent, DWORD Flags, void **a5)
{
  HDEVINFO v5; // ecx@1
  __int32 result; // eax@2

  v5 = SetupDiGetClassDevsW(ClassGuid, Enumerator, hwndParent, Flags);
  if ( v5 == (HDEVINFO)-1 )
  {
    result = HrFromLastWin32Error();
    *a5 = 0;
  }
  else
  {
    result = 0;
    *a5 = v5;
  }
  return result;
}

//----- (6E64B0CC) --------------------------------------------------------
void __stdcall RegSafeCloseKey(HKEY hKey)
{
  if ( hKey )
    RegCloseKey(hKey);
}

//----- (6E64B248) --------------------------------------------------------
signed int __cdecl _woutput_s(int a1, int a2, int a3)
{
  signed int result; // eax@26
  char *v4; // ebx@29
  int v5; // esi@31
  int v6; // ebx@37
  unsigned int v7; // eax@45
  int v8; // ebx@1
  int v9; // esi@1
  __int16 v10; // di@1
  unsigned int v11; // ecx@3
  int v12; // eax@6
  unsigned int v13; // eax@7
  int v14; // edi@12
  int v15; // ebx@14
  char *v16; // ebx@14
  char *v17; // eax@16
  int v18; // eax@55
  int v19; // eax@59
  __int16 v20; // ax@71
  int *v21; // esi@99
  unsigned int v22; // eax@109
  int v23; // eax@114
  char *v24; // esi@115
  unsigned __int16 v25; // cx@116
  size_t v26; // eax@117
  char *v27; // eax@122
  char *v28; // edx@122
  char v29; // cl@123
  int v30; // ebx@129
  __int64 v31; // rax@129
  size_t v32; // esi@136
  void *v33; // eax@136
  int v34; // eax@141
  char *v35; // esi@141
  int v36; // ebx@141
  char v37; // cl@144
  signed int v38; // ecx@160
  unsigned int v39; // ebx@181
  unsigned int v40; // edi@181
  char *i; // esi@187
  int v42; // eax@188
  unsigned __int64 v43; // ST08_8@189
  unsigned __int64 v44; // rcx@189
  size_t v45; // eax@192
  char *v46; // esi@192
  signed __int16 v47; // [sp-4h] [bp-478h]@50
  int v48; // [sp+Ch] [bp-468h]@141
  int v49; // [sp+10h] [bp-464h]@141
  int v50; // [sp+18h] [bp-45Ch]@30
  wchar_t DstCh[2]; // [sp+1Ch] [bp-458h]@30
  size_t v52; // [sp+20h] [bp-454h]@31
  int v53; // [sp+24h] [bp-450h]@1
  int v54; // [sp+28h] [bp-44Ch]@4
  void *Memory; // [sp+2Ch] [bp-448h]@3
  int v56; // [sp+30h] [bp-444h]@1
  __int16 v57; // [sp+34h] [bp-440h]@37
  __int16 v58; // [sp+36h] [bp-43Eh]@152
  char v59; // [sp+38h] [bp-43Ch]@110
  char v60; // [sp+39h] [bp-43Bh]@110
  unsigned int v61; // [sp+3Ch] [bp-438h]@3
  char v62[4]; // [sp+40h] [bp-434h]@1
  int v63; // [sp+44h] [bp-430h]@1
  int v64; // [sp+48h] [bp-42Ch]@1
  int v65; // [sp+4Ch] [bp-428h]@1
  int v66; // [sp+50h] [bp-424h]@1
  int v67; // [sp+54h] [bp-420h]@3
  unsigned int v68; // [sp+58h] [bp-41Ch]@3
  int v69; // [sp+5Ch] [bp-418h]@1
  size_t Count; // [sp+60h] [bp-414h]@3
  char *SrcCh; // [sp+64h] [bp-410h]@14
  int Value; // [sp+68h] [bp-40Ch]@1
  int v73; // [sp+6Ch] [bp-408h]@1
  wchar_t v74; // [sp+70h] [bp-404h]@91
  char v75[513]; // [sp+26Fh] [bp-205h]@187

  v8 = a3;
  v9 = a2;
  v10 = 0;
  v64 = a1;
  v69 = a3;
  v56 = 0;
  v73 = 0;
  v65 = 0;
  Value = 0;
  v66 = 0;
  *(_DWORD *)v62 = 0;
  v53 = 0;
  v63 = 0;
  if ( !a1 || !a2 )
    goto LABEL_207;
  v11 = *(_WORD *)a2;
  v67 = 0;
  Count = 0;
  v61 = 0;
  Memory = 0;
  v68 = v11;
  if ( !(_WORD)v11 )
    goto LABEL_217;
  while ( 1 )
  {
    v9 += 2;
    v54 = v9;
    if ( v67 < 0 )
      break;
    if ( (unsigned __int16)(v11 - 32) > 0x58u )
      v12 = 0;
    else
      v12 = *((_BYTE *)L"\u6e00\u6b00\u6100\u6700\u6500" + (unsigned __int16)v11) & 0xF;
    v13 = (unsigned int)(unsigned __int8)*(&__lookuptable_s[9 * v12] + v61) >> 4;
    v61 = v13;
    if ( v13 == 8 )
      goto LABEL_207;
    switch ( v13 )
    {
      case 3u:
        if ( (_WORD)v11 == 42 )
        {
          v18 = *(_DWORD *)v8;
          v8 += 4;
          v69 = v8;
          v65 = v18;
          if ( v18 < 0 )
          {
            v73 |= 4u;
            v65 = -v65;
          }
        }
        else
        {
          v65 = 10 * v65 + (unsigned __int16)v11 - 48;
        }
        goto LABEL_45;
      case 0u:
        goto LABEL_23;
      case 7u:
        if ( (signed int)(unsigned __int16)v11 <= 100 )
        {
          if ( (unsigned __int16)v11 == 100 )
            goto LABEL_170;
          if ( (signed int)(unsigned __int16)v11 > 83 )
          {
            if ( (unsigned __int16)v11 == 88 )
              goto LABEL_147;
            if ( (unsigned __int16)v11 == 90 )
            {
              v23 = *(_DWORD *)v8;
              v69 = v8 + 4;
              if ( v23 )
              {
                v24 = *(char **)(v23 + 4);
                if ( v24 )
                {
                  v25 = *(_WORD *)v23;
                  if ( *(_WORD *)(v23 + 2) < *(_WORD *)v23 )
                    goto LABEL_207;
                  v26 = v25;
                  if ( v73 & 0x800 )
                  {
                    if ( !(~(_BYTE)v25 & 1) || !(~(_BYTE)v24 & 1) )
                      goto LABEL_207;
                    SrcCh = v24;
                    v26 = (unsigned int)v25 >> 1;
                    v63 = 1;
                  }
                  else
                  {
                    v63 = 0;
                    SrcCh = v24;
                  }
                  goto LABEL_212;
                }
              }
              v27 = __nullstring;
              SrcCh = __nullstring;
              v28 = __nullstring + 1;
              do
                v29 = *v27++;
              while ( v29 );
              goto LABEL_124;
            }
            if ( (unsigned __int16)v11 == 97 )
              goto LABEL_91;
            if ( (unsigned __int16)v11 != 99 )
              goto LABEL_33;
            goto LABEL_109;
          }
          if ( (unsigned __int16)v11 == 83 )
          {
            if ( !(v73 & 0x830) )
              v73 |= 0x20u;
LABEL_12:
            v14 = Value;
            if ( Value == -1 )
              v14 = 0x7FFFFFFF;
            v15 = v8 + 4;
            v69 = v15;
            v16 = *(char **)(v15 - 4);
            SrcCh = v16;
            if ( !(v73 & 0x20) )
            {
              if ( !v16 )
                SrcCh = (char *)__wnullstring;
              v17 = SrcCh;
              v63 = 1;
              while ( v14 )
              {
                --v14;
                if ( !*(_WORD *)v17 )
                  break;
                v17 += 2;
              }
              v26 = (v17 - SrcCh) >> 1;
              goto LABEL_212;
            }
            if ( !v16 )
              SrcCh = __nullstring;
            Count = 0;
            v21 = (int *)SrcCh;
            if ( v14 > 0 )
            {
              do
              {
                if ( !*(_BYTE *)v21 )
                  break;
                if ( isleadbyte(*(_BYTE *)v21) )
                  v21 = (int *)((char *)v21 + 1);
                v21 = (int *)((char *)v21 + 1);
                ++Count;
              }
              while ( (signed int)Count < v14 );
            }
            goto LABEL_33;
          }
          if ( (unsigned __int16)v11 == 65 )
            goto LABEL_90;
          if ( (unsigned __int16)v11 == 67 )
          {
            if ( !(v73 & 0x830) )
              v73 |= 0x20u;
LABEL_109:
            v22 = *(_WORD *)v8;
            v63 = 1;
            v69 = v8 + 4;
            *(_DWORD *)DstCh = v22;
            if ( v73 & 0x20 )
            {
              v59 = v22;
              v60 = 0;
              if ( mbtowc(&v74, &v59, __mb_cur_max) < 0 )
                v53 = 1;
            }
            else
            {
              v74 = v22;
            }
            SrcCh = (char *)&v74;
            Count = 1;
            goto LABEL_33;
          }
          if ( (unsigned __int16)v11 == 69 || (unsigned __int16)v11 == 71 )
          {
LABEL_90:
            v11 += 32;
            *(_DWORD *)v62 = 1;
            v68 = v11;
LABEL_91:
            v73 |= 0x40u;
            SrcCh = (char *)&v74;
            Count = 512;
            if ( Value >= 0 )
            {
              if ( Value )
              {
                if ( Value > 512 )
                  Value = 512;
                if ( Value > 163 )
                {
                  v32 = Value + 349;
                  v33 = malloc(Value + 349);
                  LOBYTE(v11) = v68;
                  Memory = v33;
                  if ( v33 )
                  {
                    SrcCh = (char *)v33;
                    Count = v32;
                  }
                  else
                  {
                    Value = 163;
                  }
                }
              }
              else if ( (_WORD)v11 == 103 )
              {
                Value = 1;
              }
            }
            else
            {
              Value = 6;
            }
            if ( v73 & 0x80 )
              *(_DWORD *)v62 |= 0x80u;
            v34 = *(_DWORD *)v8;
            v35 = SrcCh;
            v36 = v8 + 8;
            v48 = v34;
            v49 = *(_DWORD *)(v36 - 4);
            v69 = v36;
            _safecrt_cfltcvt((int)&v48, SrcCh, Count, (char)v11, Value, v62[0]);
            if ( *v35 == 45 )
            {
              v73 |= 0x100u;
              ++SrcCh;
            }
            v27 = SrcCh;
            v28 = SrcCh + 1;
            do
              v37 = *v27++;
            while ( v37 );
LABEL_124:
            v26 = v27 - v28;
LABEL_212:
            Count = v26;
            goto LABEL_33;
          }
        }
        else
        {
          if ( (signed int)(unsigned __int16)v11 > 112 )
          {
            if ( (unsigned __int16)v11 != 115 )
            {
              if ( (unsigned __int16)v11 == 117 )
                goto LABEL_171;
              if ( (unsigned __int16)v11 != 120 )
                goto LABEL_33;
              v56 = 39;
              goto LABEL_151;
            }
            goto LABEL_12;
          }
          if ( (unsigned __int16)v11 == 112 )
          {
            Value = 8;
LABEL_147:
            v56 = 7;
LABEL_151:
            v68 = 16;
            if ( v73 & 0x80 )
            {
              v57 = 48;
              v58 = v56 + 81;
              v66 = 2;
            }
            goto LABEL_172;
          }
          if ( (signed int)(unsigned __int16)v11 < 101 )
            goto LABEL_33;
          if ( (signed int)(unsigned __int16)v11 <= 103 )
            goto LABEL_91;
          if ( (unsigned __int16)v11 == 105 )
          {
LABEL_170:
            v73 |= 0x40u;
LABEL_171:
            v68 = 10;
LABEL_172:
            if ( !(v73 & 0x8000) && !(v73 & 0x1000) )
            {
              v30 = v8 + 4;
              if ( v73 & 0x20 )
              {
                v69 = v30;
                if ( v73 & 0x40 )
                  LODWORD(v31) = *(_WORD *)(v30 - 4);
                else
                  LODWORD(v31) = *(_WORD *)(v30 - 4);
                v31 = (signed int)v31;
              }
              else
              {
                LODWORD(v31) = *(_DWORD *)(v30 - 4);
                if ( v73 & 0x40 )
                  v31 = (signed int)v31;
                else
                  HIDWORD(v31) = 0;
LABEL_177:
                v69 = v30;
              }
              if ( v73 & 0x40 && SHIDWORD(v31) <= 0 && SHIDWORD(v31) < 0 )
              {
                v31 = -v31;
                v73 |= 0x100u;
              }
              v39 = HIDWORD(v31);
              v40 = v31;
              if ( !(v73 & 0x9000) )
                v39 = 0;
              if ( Value >= 0 )
              {
                v73 &= 0xFFFFFFF7;
                if ( Value > 512 )
                  Value = 512;
              }
              else
              {
                Value = 1;
              }
              if ( !(v39 | (unsigned int)v31) )
                v66 = 0;
              for ( i = v75; ; --i )
              {
                v42 = Value--;
                if ( v42 <= 0 && !(v39 | v40) )
                  break;
                v43 = __PAIR__(v39, v40);
                v44 = __PAIR__(v39, v40) % (signed int)v68;
                v38 = v44 + 48;
                v50 = HIDWORD(v44);
                v39 = v43 / (signed int)v68 >> 32;
                v40 = v43 / (signed int)v68;
                if ( v38 > 57 )
                  LOBYTE(v38) = v56 + v38;
                *i = v38;
              }
              v45 = v75 - i;
              v46 = i + 1;
              Count = v45;
              SrcCh = v46;
              if ( v73 & 0x200 && (!v45 || *v46 != 48) )
              {
                --SrcCh;
                ++Count;
                *SrcCh = 48;
              }
              goto LABEL_33;
            }
            v30 = v8 + 8;
            LODWORD(v31) = *(_DWORD *)(v30 - 8);
            HIDWORD(v31) = *(_DWORD *)(v30 - 4);
            goto LABEL_177;
          }
          if ( (unsigned __int16)v11 == 110 )
            goto LABEL_207;
          if ( (unsigned __int16)v11 == 111 )
          {
            v68 = 8;
            if ( v73 & 0x80 )
              v73 |= 0x200u;
            goto LABEL_172;
          }
        }
LABEL_33:
        if ( v53 )
          goto LABEL_42;
        if ( !(v73 & 0x40) )
          goto LABEL_35;
        if ( v73 & 0x100 )
        {
          v47 = 45;
        }
        else if ( v73 & 1 )
        {
          v47 = 43;
        }
        else
        {
          if ( !(v73 & 2) )
            goto LABEL_35;
          v47 = 32;
        }
        v57 = v47;
        v66 = 1;
LABEL_35:
        v5 = v65 - Count - v66;
        v52 = v65 - Count - v66;
        if ( !(v73 & 0xC) )
          sub_6E64B4A2((int)&v67, 32, v65 - Count - v66, v64);
        v6 = v64;
        sub_6E64AF74(&v67, v64, &v57, (int *)v66);
        if ( v73 & 8 && !(v73 & 4) )
          sub_6E64B4A2((int)&v67, 48, v5, v6);
        if ( v63 || (signed int)Count <= 0 )
        {
          sub_6E64AF74(&v67, v6, (signed __int16 *)SrcCh, (int *)Count);
        }
        else
        {
          v4 = SrcCh;
          v68 = Count;
          while ( 1 )
          {
            --v68;
            v50 = mbtowc(DstCh, v4, __mb_cur_max);
            if ( v50 <= 0 )
              break;
            sub_6E64B4D5(v64, (int)&v67, DstCh[0]);
            v4 += v50;
            v5 = v52;
            if ( (signed int)v68 <= 0 )
              goto LABEL_40;
          }
          v67 = -1;
        }
LABEL_40:
        if ( v67 >= 0 && v73 & 4 )
          sub_6E64B4A2((int)&v67, 32, v5, v64);
LABEL_42:
        if ( Memory )
        {
          free(Memory);
          Memory = 0;
        }
LABEL_43:
        v8 = v69;
LABEL_44:
        v9 = v54;
        v10 = 0;
LABEL_45:
        v7 = *(_WORD *)v9;
        v68 = v7;
        if ( (_WORD)v7 == v10 )
          goto LABEL_24;
        v11 = v7;
        break;
      case 1u:
        Value = -1;
        *(_DWORD *)v62 = 0;
        v53 = 0;
        v65 = 0;
        v66 = 0;
        v73 = 0;
        v63 = 0;
        goto LABEL_45;
      case 4u:
        Value = 0;
        goto LABEL_45;
      case 5u:
        if ( (_WORD)v11 == 42 )
        {
          v19 = *(_DWORD *)v8;
          v8 += 4;
          v69 = v8;
          Value = v19;
          if ( v19 < 0 )
            Value = -1;
        }
        else
        {
          Value = 10 * Value + (unsigned __int16)v11 - 48;
        }
        goto LABEL_45;
      case 6u:
        if ( (unsigned __int16)v11 != 73 )
        {
          switch ( (unsigned __int16)v11 )
          {
            case 0x68u:
              v73 |= 0x20u;
              break;
            case 0x6Cu:
              if ( *(_WORD *)v9 == 108 )
              {
                v9 += 2;
                v73 |= 0x1000u;
              }
              else
              {
                v73 |= 0x10u;
              }
              break;
            case 0x77u:
              v73 |= 0x800u;
              break;
          }
          goto LABEL_45;
        }
        v20 = *(_WORD *)v9;
        if ( *(_WORD *)v9 == 54 && *(_WORD *)(v9 + 2) == 52 )
        {
          v9 += 4;
          v73 |= 0x8000u;
          goto LABEL_45;
        }
        if ( v20 == 51 && *(_WORD *)(v9 + 2) == 50 )
        {
          v9 += 4;
          v73 &= 0xFFFF7FFF;
          goto LABEL_45;
        }
        if ( v20 == 100 || v20 == 105 || v20 == 111 || v20 == 117 || v20 == 120 || v20 == 88 )
          goto LABEL_45;
        v61 = 0;
LABEL_23:
        v63 = 1;
        sub_6E64B4D5(v64, (int)&v67, v11);
        goto LABEL_44;
      case 2u:
        if ( (unsigned __int16)v11 == 32 )
        {
          v73 |= 2u;
          goto LABEL_45;
        }
        if ( (unsigned __int16)v11 == 35 )
        {
          v73 |= 0x80u;
          goto LABEL_45;
        }
        if ( (unsigned __int16)v11 == 43 )
        {
          v73 |= 1u;
          goto LABEL_45;
        }
        if ( (unsigned __int16)v11 == 45 )
        {
          v73 |= 4u;
          goto LABEL_45;
        }
        if ( (unsigned __int16)v11 != 48 )
          goto LABEL_43;
        v73 |= 8u;
        goto LABEL_45;
      default:
        goto LABEL_43;
    }
  }
LABEL_24:
  if ( v61 && v61 != 7 )
  {
LABEL_207:
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  else
  {
LABEL_217:
    result = v67;
  }
  return result;
}
// 6E69B88C: using guessed type char *__nullstring;
// 6E69B890: using guessed type wchar_t *__wnullstring;
// 6E64B248: using guessed type char var_205[513];

//----- (6E64B410) --------------------------------------------------------
int __thiscall CFilterMap::PFindEntryByFilterAndMiniportGuid(CFilterMap *this, const struct CComponent *a2, const struct _GUID *a3)
{
  int v3; // ebx@1
  int v4; // edx@2
  int v6; // [sp+4h] [bp-8h]@1
  int v7; // [sp+8h] [bp-4h]@1

  v7 = 0;
  v3 = *((_DWORD *)this + 1);
  v6 = *((_DWORD *)this + 2);
  if ( v3 != v6 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)v3;
      if ( memcmp((const char *)a3, (const char *)(*(_DWORD *)v3 + 4), 16) <= 0 )
      {
        if ( memcmp(a3, (const void *)(v4 + 4), 0x10u) )
          return v7;
        if ( a2 == *(const struct CComponent **)v4 )
          break;
      }
      v3 += 4;
      if ( v3 == v6 )
        return v7;
    }
    v7 = *(_DWORD *)v3;
  }
  return v7;
}

//----- (6E64B46F) --------------------------------------------------------
void __usercall sub_6E64B46F(int a1@<edx>, unsigned int a2@<ecx>, int a3@<edi>, int a4@<esi>)
{
  unsigned int v4; // edx@1
  unsigned int v5; // ecx@1

  v4 = a2 & a1;
  *(_BYTE *)a3 = *(_BYTE *)a4;
  v5 = a2 >> 2;
  *(_BYTE *)(a3 + 1) = *(_BYTE *)(a4 + 1);
  JUMPOUT(v5, 8, &loc_6E64A7DB);
  qmemcpy((void *)(a3 + 2), (const void *)(a4 + 2), 4 * v5);
  JUMPOUT(__CS__, *(&off_6E64A878 + v4));
}
// 6E64A878: using guessed type void *off_6E64A878;

//----- (6E64B4A2) --------------------------------------------------------
int __usercall sub_6E64B4A2@<eax>(int result@<eax>, signed __int16 a2, int a3, int a4)
{
  int v4; // edi@1

  v4 = result;
  if ( a3 > 0 )
  {
    do
    {
      --a3;
      result = sub_6E64B4D5(a4, v4, a2);
    }
    while ( *(_DWORD *)v4 != -1 && a3 > 0 );
  }
  return result;
}

//----- (6E64B4D5) --------------------------------------------------------
int __usercall sub_6E64B4D5@<eax>(int result@<eax>, int a2@<edi>, signed __int16 a3@<si>)
{
  int v3; // ecx@1
  bool v4; // sf@3
  signed __int16 v5; // cx@4

  v3 = *(_DWORD *)(result + 12);
  if ( (!(v3 & 0x40) || *(_DWORD *)(result + 8))
    && ((v4 = *(_DWORD *)(result + 4) - 2 < 0, *(_DWORD *)(result + 4) -= 2, v4) ? (*(_DWORD *)(result + 12) = v3 | 0x20,
                                                                                    v5 = -1) : (**(_WORD **)result = a3,
                                                                                                *(_DWORD *)result += 2,
                                                                                                v5 = a3),
        v5 == -1 && (result = ferror((FILE *)result)) != 0) )
    *(_DWORD *)a2 = -1;
  else
    ++*(_DWORD *)a2;
  return result;
}

//----- (6E64BCAA) --------------------------------------------------------
__int32 __stdcall HrSetupDiEnumDeviceInfo(HDEVINFO DeviceInfoSet, DWORD MemberIndex, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 result; // eax@2

  memset(DeviceInfoData, 0, 0x1Cu);
  DeviceInfoData->cbSize = 28;
  if ( SetupDiEnumDeviceInfo(DeviceInfoSet, MemberIndex, DeviceInfoData) )
    result = 0;
  else
    result = HrFromLastWin32Error();
  return result;
}

//----- (6E64BCE6) --------------------------------------------------------
void __thiscall CModifyContext::ApplyChanges(CModifyContext *this)
{
  CModifyContext *v1; // esi@1
  char *v2; // ebx@1
  __int32 v3; // eax@4
  __int32 v4; // eax@5
  __int32 v5; // eax@6
  __int32 v6; // eax@7
  __int32 v7; // eax@8
  __int32 v8; // eax@9
  const struct CComponent **v9; // eax@10
  const struct CComponent *v10; // ebx@11
  bool v11; // zf@12
  int v12; // eax@12
  __int32 v13; // eax@17
  __int32 v14; // eax@18
  __int32 v15; // eax@23
  const struct CComponent **v16; // eax@24
  const struct CComponent *v17; // eax@26
  int v18; // eax@29
  const struct CComponent **v19; // eax@33
  struct CBindPath *v20; // eax@34
  const struct CComponent **v21; // eax@41
  struct CImplINetCfg *v22; // ST30_4@42
  CNotifyObjectInterface *v23; // ecx@42
  void *v24; // ecx@45
  const struct CComponent **v25; // eax@47
  const struct CComponent **v26; // eax@51
  int v27; // ST34_4@52
  const struct CComponent **v28; // eax@59
  const struct CComponent **v29; // eax@67
  const struct CComponent **v30; // eax@71
  const struct CComponent **v31; // eax@82
  struct CImplINetCfg *v32; // ST30_4@84
  CNotifyObjectInterface *v33; // ecx@84
  int v34; // edi@86
  int v35; // ebx@87
  int v36; // eax@97
  struct CComponent *v37; // eax@109
  struct CBindPath *v38; // eax@114
  char *v39; // ecx@116
  struct CBindPath *v40; // eax@121
  const struct CComponent **v41; // eax@122
  int v42; // eax@135
  int v43; // eax@137
  __int32 v44; // eax@139
  int v45; // eax@141
  __int32 v46; // eax@145
  const struct CComponent **v47; // eax@146
  int v48; // eax@156
  int v49; // eax@159
  struct CBindPath *v50; // eax@162
  struct CBindPath *i; // eax@165
  int v52; // eax@170
  struct CBindPath *v53; // eax@172
  struct CComponent *v54; // eax@180
  int j; // ebx@184
  int v56; // edi@185
  int v57; // ecx@189
  int v58; // eax@191
  const WCHAR *v59; // eax@194
  int v60; // [sp+Ch] [bp-210h]@1
  char v61; // [sp+3Ch] [bp-1E0h]@63
  int v62; // [sp+50h] [bp-1CCh]@1
  int v63; // [sp+54h] [bp-1C8h]@1
  int v64; // [sp+58h] [bp-1C4h]@1
  char v65; // [sp+5Ch] [bp-1C0h]@18
  unsigned __int16 **v66; // [sp+60h] [bp-1BCh]@1
  int v67; // [sp+64h] [bp-1B8h]@1
  int v68; // [sp+68h] [bp-1B4h]@1
  int v69; // [sp+6Ch] [bp-1B0h]@1
  char v70; // [sp+70h] [bp-1ACh]@17
  unsigned __int16 **v71; // [sp+74h] [bp-1A8h]@1
  int v72; // [sp+78h] [bp-1A4h]@1
  int v73; // [sp+7Ch] [bp-1A0h]@1
  unsigned __int32 v74; // [sp+80h] [bp-19Ch]@1
  int v75; // [sp+84h] [bp-198h]@1
  int v76; // [sp+88h] [bp-194h]@1
  int v77; // [sp+8Ch] [bp-190h]@39
  SP_LOG_TOKEN LogToken; // [sp+90h] [bp-18Ch]@1
  struct CBindPath *v79; // [sp+98h] [bp-184h]@4
  struct CComponent *v80; // [sp+9Ch] [bp-180h]@1
  const struct CComponent **v81; // [sp+A0h] [bp-17Ch]@10
  char v82; // [sp+A4h] [bp-178h]@1
  int v83; // [sp+218h] [bp-4h]@1

  v1 = this;
  v2 = (char *)this - 72;
  CFilterDevices::CFilterDevices((int)&v60, (int)((char *)this - 72));
  v83 = 0;
  CFilteredAdapters::CFilteredAdapters((int)&v82, v1, (int)&v60);
  v71 = 0;
  v72 = 0;
  v73 = 0;
  v66 = 0;
  v67 = 0;
  v68 = 0;
  v75 = 0;
  v76 = 0;
  LOBYTE(v83) = 4;
  LogToken = SetupGetThreadLogToken();
  v64 = 0;
  v69 = 0;
  v63 = 0;
  v80 = (struct CComponent *)FIsUserNetworkConfigOps();
  v62 = 0;
  v74 = 0;
  if ( CComponentList::PFindComponentByInfId((CComponentList *)v2, L"ms_rascli", 0) )
    v74 = 1;
  if ( CComponentList::PFindComponentByInfId((CComponentList *)v2, L"ms_rassrv", 0) )
    v74 |= 2u;
  v79 = (struct CBindPath *)(v2 + 44);
  v3 = CBindingSet::HrAddBindPathsInSet1ButNotInSet2(
         (CModifyContext *)((char *)v1 + 64),
         (CModifyContext *)((char *)v1 + 44),
         (const struct CBindingSet *)(v2 + 44));
  *((_DWORD *)v1 + 55) = v3;
  if ( !v3 )
  {
    v4 = CBindingSet::HrAddBindPathsInSet1ButNotInSet2(
           (CModifyContext *)((char *)v1 + 84),
           v79,
           (CModifyContext *)((char *)v1 + 44));
    *((_DWORD *)v1 + 55) = v4;
    if ( !v4 )
    {
      v5 = CBindingSet::HrGetAffectedComponentsInBindingSet(
             (CModifyContext *)((char *)v1 + 64),
             (CModifyContext *)((char *)v1 + 104));
      *((_DWORD *)v1 + 55) = v5;
      if ( !v5 )
      {
        v6 = CBindingSet::HrGetAffectedComponentsInBindingSet(
               (CModifyContext *)((char *)v1 + 84),
               (CModifyContext *)((char *)v1 + 104));
        *((_DWORD *)v1 + 55) = v6;
        if ( !v6 )
        {
          v7 = CComponentList::HrAddComponentsInList1ButNotInList2(
                 (CModifyContext *)((char *)v1 + 104),
                 (const struct CComponentList *)v2,
                 v1);
          *((_DWORD *)v1 + 55) = v7;
          if ( !v7 )
          {
            v8 = CComponentList::HrAddComponentsInList1ButNotInList2(
                   (CModifyContext *)((char *)v1 + 104),
                   v1,
                   (const struct CComponentList *)v2);
            *((_DWORD *)v1 + 55) = v8;
            if ( !v8 )
            {
              CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 0: The following components are dirty:\n");
              v9 = (const struct CComponent **)*((_DWORD *)v1 + 29);
              v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
              if ( v81 != v9 )
              {
                do
                {
                  v10 = *v81;
                  if ( CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), *v81) )
                  {
                    v11 = CComponentList::FComponentInList(v1, v10) == 0;
                    v12 = *((_DWORD *)v10 + 8);
                    if ( v11 )
                    {
                      if ( !v12 )
                        v12 = *((_DWORD *)v10 + 7);
                      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %-12S  (installed)\n", v12);
                    }
                    else
                    {
                      if ( !v12 )
                        v12 = *((_DWORD *)v10 + 7);
                      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S\n", v12);
                    }
                  }
                  else
                  {
                    v36 = *((_DWORD *)v10 + 8);
                    if ( !v36 )
                      v36 = *((_DWORD *)v10 + 7);
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %-12S  (removed)\n", v36);
                  }
                  ++v81;
                }
                while ( v81 != *((const struct CComponent ***)v1 + 29) );
              }
              v13 = CPszArray::HrReserveRoomForPointers((CPszArray *)&v70, 0x20u);
              *((_DWORD *)v1 + 55) = v13;
              if ( !v13 )
              {
                v14 = CPszArray::HrReserveRoomForPointers((CPszArray *)&v65, 0x20u);
                *((_DWORD *)v1 + 55) = v14;
                if ( !v14 )
                {
                  if ( !v80 )
                  {
                    if ( CNetConfigCore::FContainsFilterComponent((CModifyContext *)((char *)v1 - 72))
                      || CNetConfigCore::FContainsFilterComponent(v1)
                      || CNetConfigCore::FContainsLightWeightFilter((CModifyContext *)((char *)v1 - 72))
                      || CNetConfigCore::FContainsLightWeightFilter(v1) )
                    {
                      v69 = 1;
                      v15 = CFilterDevices::HrPrepare((CFilterDevices *)&v60);
                      *((_DWORD *)v1 + 55) = v15;
                      if ( v15 )
                        goto LABEL_91;
                    }
                    else
                    {
                      v69 = 0;
                    }
                  }
                  CBindingSet::Printf((void *)v79, 3, "   The following bindings are currently disabled:\n");
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 1: Save the network configuration binary.\n");
                  HrSaveNetworkConfigurationToRegistry((CModifyContext *)((char *)v1 - 72));
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 2: Write the following static bindings.\n");
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN STATIC BINDINGS]");
                  v16 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  while ( v16 != *((const struct CComponent ***)v1 + 29) )
                  {
                    v17 = *v81;
                    v11 = *((_DWORD *)*v81 + 4) == 2;
                    v80 = *v81;
                    if ( v11 )
                      v64 = 1;
                    if ( CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), v17) )
                    {
                      v18 = CRegistryBindingsContext::HrWriteBindingsForComponent(
                              (CModifyContext *)((char *)v1 + 124),
                              v80);
                      if ( v18 )
                        *((_DWORD *)v1 + 55) = v18;
                    }
                    else if ( !FIsConsideredNetClass(*((_DWORD *)v80 + 4))
                           || !CComponentList::PFindComponentByPnpId(
                                 (CModifyContext *)((char *)v1 - 72),
                                 *((const unsigned __int16 **)v80 + 8)) )
                    {
                      CRegistryBindingsContext::HrDeleteBindingsForComponent(v80);
                    }
                    ++v81;
                    v16 = v81;
                  }
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI END STATIC BINDINGS]");
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 3: Notify: apply registry changes\n");
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI BEGIN NOTIFY APPLY REGISTRY CHANGES]");
                  v21 = (const struct CComponent **)*((_DWORD *)v1 + 29);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  if ( v81 != v21 )
                  {
                    do
                    {
                      v22 = (struct CImplINetCfg *)*((_DWORD *)v1 - 1);
                      v23 = (const struct CComponent *)((char *)*v81 + 112);
                      v80 = *v81;
                      CNotifyObjectInterface::ApplyRegistryChanges(v23, v22, &v77);
                      if ( v77 )
                      {
                        v37 = v80;
                        *((_BYTE *)v1 + 225) = 1;
                        CDiagContext::Printf(
                          (DWORD)g_pDiagCtx,
                          3,
                          "      %S notify object wants a reboot\n",
                          *((_DWORD *)v37 + 7));
                        _SetupWriteTextLog(
                          LogToken,
                          0x40000000u,
                          5 - (g_IsInUpgrade != 0),
                          "! NCI: %ws notify object wants a reboot.",
                          *((_DWORD *)v80 + 7));
                      }
                      ++v81;
                    }
                    while ( v81 != *((const struct CComponent ***)v1 + 29) );
                  }
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI END NOTIFY APPLY REGISTRY CHANGES]");
                  if ( v64 )
                  {
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Migrating winsock configuration.\n");
                    HrMigrateWinsockConfiguration(v24);
                  }
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 4: Unbind the following deleted bindings:\n");
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI BEGIN UNBIND DELETED BINDINGS]");
                  if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v1 + 88)) )
                  {
                    v25 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                    v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                    while ( v25 != *((const struct CComponent ***)v1 + 29) )
                    {
                      if ( FIsConsideredNetClass(*((_DWORD *)*v81 + 4))
                        && !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), *v81) )
                        CBindingSet::RemoveBindPathsWithComponent((CModifyContext *)((char *)v1 + 84), *v81);
                      ++v81;
                      v25 = v81;
                    }
                    CBindingSet::SortForPnpUnbind((CModifyContext *)((char *)v1 + 84));
                    CRegistryBindingsContext::PnpBindOrUnbindBindPaths(
                      (CModifyContext *)((char *)v1 + 124),
                      2u,
                      (CModifyContext *)((char *)v1 + 84),
                      v74,
                      &v77);
                    if ( v77 )
                      *((_BYTE *)v1 + 225) = 1;
                  }
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI END UNBIND DELETED BINDINGS] Reboot = %01d",
                    *((_BYTE *)v1 + 225));
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 5: Stop the following services:\n");
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN STOP SERVICES]");
                  v26 = (const struct CComponent **)*((_DWORD *)v1 + 29);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  if ( v81 != v26 )
                  {
                    do
                    {
                      v27 = *((_DWORD *)*v81 + 4);
                      v80 = *v81;
                      if ( !FIsConsideredNetClass(v27)
                        && !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), v80) )
                      {
                        CModifyContext::HrProcessWinsockRemove(v80);
                        if ( *((_DWORD *)v80 + 4) == 2 || *((_DWORD *)v80 + 6) & 0x4000 )
                          HrPnpUnloadDriver(1u, *((PCWSTR *)v80 + 25));
                        v38 = (struct CBindPath *)*((_DWORD *)v80 + 13);
                        if ( v38 )
                        {
                          while ( 1 )
                          {
                            v11 = *(_WORD *)v38 == 0;
                            v79 = v38;
                            if ( v11 )
                              break;
                            v39 = &v65;
                            if ( !(*((_DWORD *)v80 + 6) & 0x40000) )
                              v39 = &v70;
                            CPszArray::HrAddPointer((CPszArray *)v39, (const unsigned __int16 *)v79);
                            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S", v79);
                            _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:   %ws", v79);
                            v38 = (struct CBindPath *)((char *)v79 + 2 * wcslen((const unsigned __int16 *)v79) + 2);
                          }
                          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
                        }
                      }
                      ++v81;
                    }
                    while ( v81 != *((const struct CComponent ***)v1 + 29) );
                  }
                  if ( v71 && (v72 - (signed int)v71) >> 2 )
                  {
                    v40 = (struct CBindPath *)CServiceManager::HrControlServicesAndWait(
                                                (CServiceManager *)&v75,
                                                (v72 - (signed int)v71) >> 2,
                                                (const unsigned __int16 *const *)v71,
                                                (const struct CSFLAGS *)&dword_6E658720,
                                                LogToken);
                    v79 = v40;
                    if ( v40 )
                    {
                      *((_BYTE *)v1 + 226) = 1;
                      CDiagContext::Printf(
                        (DWORD)g_pDiagCtx,
                        3,
                        "      some service failed to stop (hr = 0x%08X)\n",
                        v40);
                      _SetupWriteTextLog(
                        LogToken,
                        0x40000000u,
                        5 - (g_IsInUpgrade != 0),
                        "!!! NCI:      some service failed to stop [0x%08X]",
                        v79);
                      v41 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                      v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                      while ( v41 != *((const struct CComponent ***)v1 + 29) )
                      {
                        if ( !FIsConsideredNetClass(*((_DWORD *)*v81 + 4))
                          && *((_DWORD *)*v81 + 13)
                          && !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), *v81) )
                          LockdownComponentUntilNextReboot(*((STRSAFE_LPCWSTR *)*v81 + 7));
                        ++v81;
                        v41 = v81;
                      }
                    }
                    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)&v70);
                  }
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI END STOP SERVICES]");
                  if ( v69 )
                  {
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 5a: Remove filter devices:\n");
                    CFilterDevices::LoadAndRemoveFilterDevicesIfNeeded((CFilterDevices *)&v60);
                  }
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 6: Uninstall the following components:\n");
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI BEGIN UNINSTALL COMPONENTS]");
                  v28 = (const struct CComponent **)*((_DWORD *)v1 + 29);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  if ( v81 != v28 )
                  {
                    do
                    {
                      v80 = *v81;
                      if ( !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), v80) )
                      {
                        if ( FIsConsideredNetClass(*((_DWORD *)v80 + 4))
                          && CComponentList::PFindComponentByPnpId(
                               (CModifyContext *)((char *)v1 - 72),
                               *((const unsigned __int16 **)v80 + 8)) )
                        {
                          CDiagContext::Printf(
                            (DWORD)g_pDiagCtx,
                            3,
                            "   Skip removal of %S because a duplicate was installed\n",
                            *((_DWORD *)v80 + 8));
                        }
                        else if ( !(*((_DWORD *)v80 + 6) & 0x40000) )
                        {
                          if ( *((_DWORD *)v80 + 8) )
                            v42 = *((_DWORD *)v80 + 8);
                          else
                            v42 = *((_DWORD *)v80 + 7);
                          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S\n", v42);
                          v43 = *((_DWORD *)v80 + 8);
                          if ( !v43 )
                            v43 = *((_DWORD *)v80 + 7);
                          _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:     %ws", v43);
                          v44 = HrCiRemoveComponent(v80, (int)((char *)v80 + 140));
                          v79 = (struct CBindPath *)v44;
                          if ( v44 && v44 != -2146500085 )
                          {
                            *((_BYTE *)v1 + 226) = 1;
                            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      ^^^ needs a reboot (hr = 0x%08X)\n", v44);
                            v45 = *((_DWORD *)v80 + 8);
                            if ( !v45 )
                              v45 = *((_DWORD *)v80 + 7);
                            _SetupWriteTextLog(
                              LogToken,
                              0x40000000u,
                              5 - (g_IsInUpgrade != 0),
                              "! NCI:     %ws needs a reboot. [0x%08X].",
                              v45,
                              v79);
                          }
                        }
                      }
                      ++v81;
                    }
                    while ( v81 != *((const struct CComponent ***)v1 + 29) );
                  }
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI END UNINSTALL COMPONENTS]");
                  if ( v69 )
                  {
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 6a: Modify filter devices:\n");
                    CFilterDevices::InstallFilterDevicesIfNeeded((CFilterDevices *)&v60);
                    CRegistryBindingsContext::HrWriteBindingsForFilterDevices(
                      (CModifyContext *)((char *)v1 + 124),
                      (struct CFilterDevices *)&v60);
                    CFilteredAdapters::HrLoadFilteredAdaptersFromCore((CFilteredAdapters *)&v82);
                    CFilteredAdapters::HrWriteFilterBindings((CFilteredAdapters *)&v82);
                    CRegistryBindingsContext::PnpBindOrUnbindBindPaths(
                      (CModifyContext *)((char *)v1 + 124),
                      2u,
                      (struct CBindingSet *)&v61,
                      v74,
                      &v77);
                    if ( v77 )
                      *((_BYTE *)v1 + 225) = 1;
                    CFilteredAdapters::SendDetachNotifications((CFilteredAdapters *)&v82);
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 6b: Starting filter devices:\n");
                    CFilterDevices::StartFilterDevices((CFilterDevices *)&v60);
                    CFilterDevices::Free((CFilterDevices *)&v60);
                  }
                  if ( v66 && (v67 - (signed int)v66) >> 2 )
                  {
                    v46 = CServiceManager::HrControlServicesAndWait(
                            (CServiceManager *)&v75,
                            (v67 - (signed int)v66) >> 2,
                            (const unsigned __int16 *const *)v66,
                            (const struct CSFLAGS *)&dword_6E658720,
                            LogToken);
                    if ( v46 )
                    {
                      *((_BYTE *)v1 + 226) = 1;
                      CDiagContext::Printf(
                        (DWORD)g_pDiagCtx,
                        3,
                        "      some service failed to stop (hr = 0x%08X)\n",
                        v46);
                      v47 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                      v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                      while ( v47 != *((const struct CComponent ***)v1 + 29) )
                      {
                        if ( !FIsConsideredNetClass(*((_DWORD *)*v81 + 4))
                          && *((_DWORD *)*v81 + 13)
                          && !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), *v81) )
                          LockdownComponentUntilNextReboot(*((STRSAFE_LPCWSTR *)*v81 + 7));
                        ++v81;
                        v47 = v81;
                      }
                    }
                    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)&v65);
                  }
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 6: Uninstall the following filter components:\n");
                  v29 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  while ( v29 != *((const struct CComponent ***)v1 + 29) )
                  {
                    v80 = *v81;
                    if ( !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), v80)
                      && *((_DWORD *)v80 + 6) & 0x40000 )
                    {
                      if ( *((_DWORD *)v80 + 8) )
                        v48 = *((_DWORD *)v80 + 8);
                      else
                        v48 = *((_DWORD *)v80 + 7);
                      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S\n", v48);
                      HrCiRemoveComponent(v80, (int)((char *)v80 + 140));
                    }
                    ++v81;
                    v29 = v81;
                  }
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 7: Start the following drivers/services:\n");
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN START SERVICES]");
                  v30 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  while ( v30 != *((const struct CComponent ***)v1 + 29) )
                  {
                    v80 = *v81;
                    if ( !CComponentList::FComponentInList(v1, v80) )
                    {
                      v49 = *((_DWORD *)v80 + 4);
                      if ( v49 == 3 )
                        v63 = 1;
                      if ( FIsConsideredNetClass(v49) )
                      {
                        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S\n", *((_DWORD *)v80 + 8));
                        _SetupWriteTextLog(
                          LogToken,
                          0x40000000u,
                          5 - (g_IsInUpgrade != 0),
                          "NCI: Starting device %ws",
                          *((_DWORD *)v80 + 8));
                        v50 = (struct CBindPath *)CComponent::HrStartEnumeratedComponent(v80);
                        v79 = v50;
                        if ( v50 )
                        {
                          *((_BYTE *)v1 + 225) = 1;
                          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      ^^^ needs a reboot (hr = 0x%08X)\n", v50);
                          _SetupWriteTextLog(
                            LogToken,
                            0x40000000u,
                            5 - (g_IsInUpgrade != 0),
                            "!!! NCI: Device start unsucessful. result 0x%08X",
                            v79);
                        }
                      }
                      else if ( *((_DWORD *)v80 + 13) )
                      {
                        _SetupWriteTextLog(
                          LogToken,
                          0x40000000u,
                          5 - (g_IsInUpgrade != 0),
                          "NCI: Starting the following services:");
                        for ( i = (struct CBindPath *)*((_DWORD *)v80 + 13);
                              ;
                              i = (struct CBindPath *)((char *)v79 + 2 * wcslen((const unsigned __int16 *)v79) + 2) )
                        {
                          v11 = *(_WORD *)i == 0;
                          v79 = i;
                          if ( v11 )
                            break;
                          CPszArray::HrAddPointer((CPszArray *)&v70, (const unsigned __int16 *)v79);
                          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S", v79);
                          _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:    %ws", v79);
                        }
                        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
                      }
                    }
                    ++v81;
                    v30 = v81;
                  }
                  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI END START SERVICES]");
                  if ( v71 && (v72 - (signed int)v71) >> 2 && !(CDiagContext::Flags(g_pDiagCtx) & 2) )
                  {
                    v52 = 0;
                    if ( v71 )
                      v52 = (v72 - (signed int)v71) >> 2;
                    v53 = (struct CBindPath *)CServiceManager::HrControlServicesAndWait(
                                                (CServiceManager *)&v75,
                                                v52,
                                                (const unsigned __int16 *const *)v71,
                                                (const struct CSFLAGS *)dword_6E658688,
                                                LogToken);
                    v79 = v53;
                    if ( v53 )
                    {
                      *((_BYTE *)v1 + 225) = 1;
                      CDiagContext::Printf(
                        (DWORD)g_pDiagCtx,
                        3,
                        "      some service failed to start (hr = 0x%08X)\n",
                        v53);
                      _SetupWriteTextLog(
                        LogToken,
                        0x40000000u,
                        5 - (g_IsInUpgrade != 0),
                        "!!! NCI: A service failed to start [0x%08X]. Reboot recommended.",
                        v79);
                    }
                  }
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 8: Bind the following added bindings:\n");
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI BEGIN BIND ADDED BINDPATHS]");
                  if ( v69 )
                  {
                    CFilteredAdapters::SendAttachNotifications((CFilteredAdapters *)&v82);
                    CBindingSet::HrAppendBindingSet(
                      (CModifyContext *)((char *)v1 + 64),
                      0x40000000,
                      (const struct CBindingSet *)&v61);
                  }
                  if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v1 + 68)) )
                  {
                    v19 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                    v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                    while ( v19 != *((const struct CComponent ***)v1 + 29) )
                    {
                      if ( !CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), *v81) )
                        CBindingSet::RemoveBindPathsWithComponent((CModifyContext *)((char *)v1 + 64), *v81);
                      ++v81;
                      v19 = v81;
                    }
                    v20 = (struct CBindPath *)*((_DWORD *)v1 + 18);
                    v79 = (struct CBindPath *)*((_DWORD *)v1 + 18);
                    while ( v20 != *((struct CBindPath **)v1 + 19) )
                    {
                      if ( GetPnpLayerForBindPath(v79) != 2
                        || CComponentList::FComponentInList(v1, **((const struct CComponent ***)v79 + 2)) )
                        v79 = (struct CBindPath *)((char *)v79 + 20);
                      else
                        std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(
                          (int)((char *)v1 + 68),
                          (int)&v64,
                          (int)v79);
                      v20 = v79;
                    }
                    CBindingSet::SortForPnpBind((CModifyContext *)((char *)v1 + 64));
                    CRegistryBindingsContext::PnpBindOrUnbindBindPaths(
                      (CModifyContext *)((char *)v1 + 124),
                      1u,
                      (CModifyContext *)((char *)v1 + 64),
                      v74,
                      &v77);
                    if ( v77 )
                      *((_BYTE *)v1 + 225) = 1;
                  }
                  if ( v63 )
                    SignalNetworkProviderLoaded();
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI END BIND ADDED BINDPATHS]. Reboot %01d",
                    *((_BYTE *)v1 + 225));
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Step 9: Notify: apply PnP changes\n");
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI BEGIN NOTIFY APPLY PNP CHANGES]");
                  v31 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  v81 = (const struct CComponent **)*((_DWORD *)v1 + 28);
                  while ( v31 != *((const struct CComponent ***)v1 + 29) )
                  {
                    v32 = (struct CImplINetCfg *)*((_DWORD *)v1 - 1);
                    v33 = (const struct CComponent *)((char *)*v81 + 112);
                    v80 = *v81;
                    CNotifyObjectInterface::ApplyPnpChanges(v33, v32, &v77);
                    if ( v77 )
                    {
                      CDiagContext::Printf(
                        (DWORD)g_pDiagCtx,
                        3,
                        "      %S notify object wants a reboot\n",
                        *((_DWORD *)v80 + 7));
                      _SetupWriteTextLog(
                        LogToken,
                        0x40000000u,
                        5 - (g_IsInUpgrade != 0),
                        "! NCI: %ws notify object wants a reboot.",
                        *((_DWORD *)v80 + 7));
                      if ( CComponentList::FComponentInList((CModifyContext *)((char *)v1 - 72), v80) )
                      {
                        *((_BYTE *)v1 + 225) = 1;
                      }
                      else
                      {
                        v54 = v80;
                        *((_BYTE *)v1 + 226) = 1;
                        LockdownComponentUntilNextReboot(*((STRSAFE_LPCWSTR *)v54 + 7));
                      }
                    }
                    ++v81;
                    v31 = v81;
                  }
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "[NCI END NOTIFY APPLY PNP CHANGES]");
                  CDiagContext::Printf(
                    (DWORD)g_pDiagCtx,
                    3,
                    "Step 10: Release notify objects for removed components:\n");
                  v34 = *((_DWORD *)v1 + 28);
                  if ( v34 != *((_DWORD *)v1 + 29) )
                  {
                    do
                    {
                      v35 = *(_DWORD *)v34;
                      if ( !FIsConsideredNetClass(*(_DWORD *)(*(_DWORD *)v34 + 16))
                        && !CComponentList::FComponentInList(
                              (CModifyContext *)((char *)v1 - 72),
                              (const struct CComponent *)v35)
                        && *(_DWORD *)(v35 + 20) )
                      {
                        CNotifyObjectInterface::ReleaseNotifyObject((CNotifyObjectInterface *)(v35 + 112), 0, 0);
                        v62 = 1;
                      }
                      v34 += 4;
                    }
                    while ( v34 != *((_DWORD *)v1 + 29) );
                    if ( v62 )
                    {
                      CDiagContext::Printf(
                        (DWORD)g_pDiagCtx,
                        3,
                        "   calling CoFreeUnusedLibraries before running remove sections\n");
                      CoFreeUnusedLibrariesEx(0, 0);
                      for ( j = *((_DWORD *)v1 + 28); j != *((_DWORD *)v1 + 29); j += 4 )
                      {
                        v56 = *(_DWORD *)j;
                        if ( !FIsConsideredNetClass(*(_DWORD *)(*(_DWORD *)j + 16))
                          && !CComponentList::FComponentInList(
                                (CModifyContext *)((char *)v1 - 72),
                                (const struct CComponent *)v56)
                          && *(_DWORD *)(v56 + 20) )
                        {
                          if ( *(_DWORD *)(v56 + 164) < 8u )
                            v57 = v56 + 144;
                          else
                            v57 = *(_DWORD *)(v56 + 144);
                          v58 = *(_DWORD *)(v56 + 32);
                          if ( !v58 )
                            v58 = *(_DWORD *)(v56 + 28);
                          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S  [%S]\n", v58, v57);
                          if ( *(_DWORD *)(v56 + 164) < 8u )
                            v59 = (const WCHAR *)(v56 + 144);
                          else
                            v59 = *(const WCHAR **)(v56 + 144);
                          HrCiInstallFromInfSection(*(HINF *)(v56 + 20), v59, 0, 0, 0x10u);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_91:
  LOBYTE(v83) = 3;
  CServiceManager::~CServiceManager((CServiceManager *)&v75);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v65);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v70);
  CFilteredAdapters::~CFilteredAdapters((CFilteredAdapters *)&v82);
  v83 = -1;
  CFilterDevices::~CFilterDevices((CFilterDevices *)&v60);
}
// 6E658688: using guessed type int dword_6E658688[2];
// 6E658720: using guessed type int dword_6E658720;
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64C151) --------------------------------------------------------
void CDiagContext::Printf(DWORD NumberOfBytesWritten, int a2, char *Format, ...)
{
  DWORD v3; // esi@1
  char *v4; // edi@4
  int v5; // ebx@5
  HANDLE v6; // eax@6
  va_list va; // [sp+18h] [bp+14h]@1

  va_start(va, Format);
  v3 = NumberOfBytesWritten;
  if ( NumberOfBytesWritten )
  {
    if ( *(_BYTE *)NumberOfBytesWritten & 1 )
    {
      v4 = *(char **)(NumberOfBytesWritten + 4);
      if ( v4 )
      {
        v5 = _vsnprintf_s(v4, 0x1000u, 0x1000u, Format, va);
        if ( *(_BYTE *)v3 & 1 )
        {
          v6 = GetStdHandle(0xFFFFFFF5);
          if ( v6 != (HANDLE)-1 )
            WriteFile(v6, v4, v5, &NumberOfBytesWritten, 0);
        }
      }
    }
  }
}

//----- (6E64C18D) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(void *lpMem)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)lpMem + 3);
  if ( !v1 && lpMem )
    ATL::CComObject<CSrvrcfg>::`scalar deleting destructor'(lpMem, 1);
  return v1;
}

//----- (6E64C1B8) --------------------------------------------------------
signed int __stdcall CImplINetCfg::Apply(CImplINetCfg *this)
{
  int v1; // eax@2
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-Ch]@1
  signed int v4; // [sp+14h] [bp-4h]@1

  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(LogToken, 0x40000000u, (5 - (g_IsInUpgrade != 0)) | 0x10000, "NCI: Enter INetCfg::Apply");
  v4 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0x92u);
  if ( !v4 )
  {
    v1 = *((_DWORD *)this + 12);
    if ( *(_BYTE *)(v1 + 296) )
    {
      v4 = CModifyContext::HrApplyIfOkOrCancel((CModifyContext *)(v1 + 72), 1);
    }
    else if ( *(_BYTE *)(v1 + 297) || *(_BYTE *)(v1 + 298) )
    {
      v4 = 303136;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfg::Apply, hr = %08xx.",
    v4);
  return v4;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64C2B3) --------------------------------------------------------
int __thiscall CModifyContext::HrApplyIfOkOrCancel(CModifyContext *this, int a2)
{
  CModifyContext *v2; // esi@1
  char *v3; // edi@1
  int v4; // esi@5
  int v6; // [sp+14h] [bp+8h]@3

  v2 = this;
  v3 = (char *)this - 72;
  if ( !a2 || *((_DWORD *)this + 55) )
  {
    CGlobalNotifyInterface::ReleaseAllNotifyObjects(
      (CGlobalNotifyInterface *)(v3 + 64),
      (CModifyContext *)((char *)this - 72),
      1);
    CGlobalNotifyInterface::ReleaseAllNotifyObjects((CGlobalNotifyInterface *)(v3 + 64), v2, 1);
    CComponentList::FreeComponentsNotInOtherComponentList(v2, (const struct CComponentList *)v3);
    CNetConfigCore::Free((CNetConfigCore *)v3);
    CNetConfigCore::Clear(v2);
    CNetConfigCore::Clear((CNetConfigCore *)v3);
    v6 = *((_DWORD *)v2 + 55);
    *((_DWORD *)v2 + 55) = HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)v3);
  }
  else
  {
    CImplINetCfg::RaiseRpl(*((_DWORD *)v3 + 17), 1);
    CModifyContext::ApplyChanges(v2);
    CImplINetCfg::LowerRpl(*((_DWORD *)v3 + 17), 1);
    CComponentList::FreeComponentsNotInOtherComponentList(v2, (const struct CComponentList *)v3);
    CNetConfigCore::Clear(v2);
    v6 = 0;
    if ( *((_BYTE *)v2 + 225) || *((_BYTE *)v2 + 226) )
      v6 = 303136;
  }
  *((_BYTE *)v2 + 224) = 0;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)v2 + 68));
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)v2 + 88));
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)((char *)v2 + 108));
  v4 = (int)((char *)v2 + 196);
  FreeCollectionAndItem<CFilterMap>(v4);
  *(_DWORD *)(v4 + 16) = 0;
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v4);
  return v6;
}

//----- (6E64C362) --------------------------------------------------------
void __thiscall CImplINetCfg::LowerRpl(int this, int a2)
{
  if ( !a2 )
    --*(_DWORD *)(this + 84);
  --*(_DWORD *)(this + 80);
}

//----- (6E64C37D) --------------------------------------------------------
__int32 __thiscall CBindPath::HrReserveRoomForComponents(CBindPath *this, unsigned int a2)
{
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::reserve((int)((char *)this + 4), a2);
  return 0;
}

//----- (6E64C3AC) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::reserve(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // ebx@3

  v2 = this;
  if ( (unsigned int)a2 > 0x3FFFFFFF )
    std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
  result = std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(this);
  if ( result < (unsigned int)a2 )
  {
    v4 = (int)std::_Allocate<unsigned short const *>(a2, 0);
    std::_Uninitialized_copy<std::_Vector_iterator<CComponent *,std::nc_allocator<CComponent *>>,CComponent * *,std::nc_allocator<CComponent *>>(
      *(_DWORD *)(v2 + 4),
      *(_DWORD *)(v2 + 8),
      v4,
      v2);
    v5 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v2);
    if ( *(_DWORD *)(v2 + 4) )
      operator delete(*(void **)(v2 + 4));
    *(_DWORD *)(v2 + 12) = v4 + 4 * a2;
    result = v4 + 4 * v5;
    *(_DWORD *)(v2 + 8) = result;
    *(_DWORD *)(v2 + 4) = v4;
  }
  return result;
}

//----- (6E64C495) --------------------------------------------------------
void *__cdecl std::fill<CBindPath *,CBindPath>(void *a1, void *a2, int a3)
{
  void *i; // esi@1
  void *result; // eax@3

  for ( i = a1; i != a2; i = (char *)i + 20 )
    result = CBindPath::operator=(i, a3);
  return result;
}

//----- (6E64C4CE) --------------------------------------------------------
int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale)
{
  int result; // eax@9
  pthreadlocinfo v5; // eax@15
  int v6; // ecx@15
  bool v7; // zf@17
  struct localeinfo_struct v8; // [sp+8h] [bp-10h]@4
  int v9; // [sp+10h] [bp-8h]@8
  char v10; // [sp+14h] [bp-4h]@7

  if ( !SrcCh || !SrcSizeInBytes )
    return 0;
  if ( !*SrcCh )
  {
    if ( DstCh )
      *DstCh = 0;
    return 0;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v8, Locale);
  if ( !v8.locinfo->lc_category[0].wlocale )
  {
    if ( DstCh )
      *DstCh = *SrcCh;
    goto LABEL_7;
  }
  if ( _isleadbyte_l(*SrcCh, &v8) )
  {
    v5 = v8.locinfo;
    v6 = (int)v8.locinfo->locale_name[3];
    if ( v6 > 1
      && (signed int)SrcSizeInBytes >= v6
      && (v7 = MultiByteToWideChar(v8.locinfo->lc_codepage, 9u, SrcCh, v6, DstCh, DstCh != 0) == 0, v5 = v8.locinfo, !v7)
      || (wchar_t *)SrcSizeInBytes >= v5->locale_name[3] && SrcCh[1] )
    {
      result = (int)v5->locale_name[3];
      if ( v10 )
        *(_DWORD *)(v9 + 112) &= 0xFFFFFFFD;
      return result;
    }
  }
  else if ( MultiByteToWideChar(v8.locinfo->lc_codepage, 9u, SrcCh, 1, DstCh, DstCh != 0) )
  {
LABEL_7:
    if ( v10 )
      *(_DWORD *)(v9 + 112) &= 0xFFFFFFFD;
    return 1;
  }
  *_errno() = 42;
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFD;
  return -1;
}

//----- (6E64C52F) --------------------------------------------------------
__int32 __stdcall HrRegQueryTypeSzBuffer(HKEY hKey, LPCWSTR lpValueName, unsigned __int32 a3, LPBYTE lpData, DWORD Type)
{
  unsigned int v5; // esi@1
  __int32 result; // eax@1
  bool v7; // sf@1

  v5 = *(_DWORD *)Type;
  result = HrRegQueryValueEx(hKey, lpValueName, &Type, lpData, (LPDWORD)Type);
  v7 = result < 0;
  if ( !result )
  {
    if ( Type == a3 )
      return result;
    result = -2147023092;
    v7 = 1;
  }
  if ( v7 && lpData && v5 >= 2 )
    *(_WORD *)lpData = 0;
  return result;
}

//----- (6E64C572) --------------------------------------------------------
__int32 __stdcall HrRegQueryValueEx(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  __int32 result; // eax@1

  result = RegQueryValueExW(hKey, lpValueName, 0, lpType, lpData, lpcbData);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E64C5A5) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfg>::Release((void *)(a1 - 4));
}

//----- (6E64C5B4) --------------------------------------------------------
__int32 __stdcall HrRegSetSz(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData)
{
  unsigned int v3; // eax@1

  v3 = CbOfSzAndTermSafe((const unsigned __int16 *)lpData);
  return HrRegSetValueEx(hKey, lpValueName, 1u, lpData, v3);
}

//----- (6E64C62A) --------------------------------------------------------
void __stdcall CWriteLock::SetOrQueryLockHolder(void *lpMem, BYTE *lpData, unsigned __int16 **a4)
{
  unsigned __int32 v3; // ecx@15
  int v4; // esi@3
  HKEY phkResult; // [sp+Ch] [bp-8h]@6
  HKEY hKey; // [sp+10h] [bp-4h]@9

  v4 = lpMem && !lpData;
  if ( a4 )
    *a4 = 0;
  if ( !HrOpenNetworkKey(lpMem != 0 ? 196639 : 131097, &phkResult) )
  {
    if ( v4 )
    {
      RegDeleteKeyW(phkResult, L"NetCfgLockHolder");
      goto LABEL_12;
    }
    if ( lpMem )
    {
      if ( HrRegCreateKeyWithWorldAccess(phkResult, L"NetCfgLockHolder", 1u, 0x20006u, &hKey, (LPDWORD)&lpMem) )
      {
LABEL_12:
        RegCloseKey(phkResult);
        return;
      }
      HrRegSetSz(hKey, 0, lpData);
    }
    else
    {
      if ( HrRegOpenKeyEx(phkResult, L"NetCfgLockHolder", 0x20019u, &hKey) )
        goto LABEL_12;
      if ( !HrRegGetTypeWithAlloc(v3, hKey, 0, 1u, (unsigned __int8 **)&lpMem, 0) )
      {
        HrCoTaskMemAllocAndDupSz((const unsigned __int16 *)lpMem, a4, 0x100u);
        MemFree(lpMem);
      }
    }
    RegCloseKey(hKey);
    goto LABEL_12;
  }
}

//----- (6E64C6E7) --------------------------------------------------------
int __thiscall CWriteLock::ReleaseIfOwned(CWriteLock *this)
{
  CWriteLock *v1; // esi@1
  signed int v2; // ebx@1

  v1 = this;
  v2 = 1;
  if ( *((_DWORD *)this + 1) )
  {
    CWriteLock::SetOrQueryLockHolder((void *)1, 0, 0);
    ReleaseMutex(*(HANDLE *)v1);
    *((_DWORD *)v1 + 1) = 0;
  }
  else
  {
    v2 = 0;
  }
  return v2;
}

//----- (6E64C74F) --------------------------------------------------------
signed int __stdcall CImplINetCfg::ReleaseWriteLock(CImplINetCfg *this)
{
  CImplINetCfg *v1; // ebx@1
  CWriteLock *v2; // ebx@2
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-10h]@1
  struct _RTL_CRITICAL_SECTION *lpCriticalSection; // [sp+14h] [bp-8h]@1
  LPVOID pv; // [sp+18h] [bp-4h]@1
  signed int thisa; // [sp+24h] [bp+8h]@1

  v1 = this;
  pv = 0;
  LogToken = SetupGetThreadLogToken();
  lpCriticalSection = (struct _RTL_CRITICAL_SECTION *)((char *)this + 20);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 20));
  thisa = CImplINetCfg::HrCheckForReentrancy((CImplINetCfg *)((char *)this - 4), 0);
  if ( !thisa )
  {
    v2 = (CImplINetCfg *)((char *)v1 + 68);
    if ( !CWriteLock::FIsLockedByAnyone(v2, (unsigned __int16 **)&pv) )
      pv = 0;
    if ( CWriteLock::ReleaseIfOwned(v2) == 1 )
    {
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        (5 - (g_IsInUpgrade != 0)) | 0x10000,
        "NCI: %ws Released write lock.",
        pv);
      _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "\r\n\r\n");
    }
  }
  LeaveCriticalSection(lpCriticalSection);
  if ( pv )
    CoTaskMemFree(pv);
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfgLock::ReleaseWriteLock, hr = %08xx",
    thisa);
  return thisa;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64C8A3) --------------------------------------------------------
int __thiscall CWriteLock::FIsLockedByAnyone(CWriteLock *this, unsigned __int16 **a2)
{
  CWriteLock *v2; // esi@1
  signed int v3; // edi@1
  DWORD v5; // eax@5

  v2 = this;
  v3 = *((_DWORD *)this + 1);
  if ( !v3 )
  {
    if ( CWriteLock::HrEnsureMutexCreated((void **)this) )
      return v3;
    v5 = WaitForSingleObject(*(HANDLE *)v2, 0);
    if ( !v5 )
    {
      ReleaseMutex(*(HANDLE *)v2);
      return v3;
    }
    if ( v5 != 258 )
      return v3;
    v3 = 1;
  }
  CWriteLock::SetOrQueryLockHolder(0, 0, a2);
  return v3;
}

//----- (6E64C8FE) --------------------------------------------------------
int __stdcall CreateInstanceKeyPath(int a1, GUID *rguid, unsigned __int16 *pszDest)
{
  StringCchCopyW(pszDest, 0x104u, (&MAP_NETCLASS_TO_NETWORK_SUBTREE)[2 * a1]);
  StringCchCatW(pszDest, 0x104u, L"\\");
  return StringFromGUID2(rguid, &pszDest[wcslen(pszDest)], 39);
}

//----- (6E64CCDC) --------------------------------------------------------
int __thiscall CBindPath::FIsSubPathOf(CBindPath *this, const struct CBindPath *a2)
{
  CBindPath *v2; // edi@1
  int v3; // eax@1
  int result; // eax@4
  int v5; // [sp+8h] [bp-4h]@1

  v2 = this;
  v5 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4));
  v3 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a2 + 4));
  if ( v5 && v3 && v5 < (unsigned int)v3 )
    result = memcmp(
               *((const char **)v2 + 2),
               (const char *)(*((_DWORD *)a2 + 2) + 4 * (v3 - v5)),
               *((_DWORD *)v2 + 3) - *((_DWORD *)v2 + 2)) == 0;
  else
    result = 0;
  return result;
}

//----- (6E64CD3C) --------------------------------------------------------
signed int __thiscall CImplINetCfgComponent::HrBindToOrUnbindFrom(CImplINetCfgComponent *this, struct INetCfgComponent *a2, unsigned __int32 a3)
{
  CImplINetCfgComponent *v3; // esi@1
  signed int v4; // edi@1
  const struct CComponent *v5; // ebx@2
  CNetConfigCore *v6; // ecx@3
  struct CBindPath *v7; // ebx@4
  char v9; // [sp+Ch] [bp-24h]@3
  int v10; // [sp+10h] [bp-20h]@3
  CComponentList *v11; // [sp+14h] [bp-1Ch]@4
  struct CBindPath *v12; // [sp+18h] [bp-18h]@5
  struct CComponent *v13; // [sp+20h] [bp-10h]@1
  int v14; // [sp+2Ch] [bp-4h]@3

  v3 = this;
  v13 = 0;
  v4 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 2u, a2, &v13);
  if ( !v4 )
  {
    v5 = (const struct CComponent *)*((_DWORD *)v3 + 7);
    v4 = 1;
    if ( v5 != v13 )
    {
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v10, 0);
      v6 = *(CNetConfigCore **)(*((_DWORD *)v3 + 6) + 48);
      v14 = 0;
      v4 = CNetConfigCore::HrGetComponentBindings(v6, v5, 0, (struct CBindingSet *)&v9);
      if ( !v4 )
      {
        v7 = v11;
        v4 = 1;
        while ( v7 != v12 )
        {
          if ( CComponentList::FComponentInList(v7, v13) )
          {
            v4 = CModifyContext::HrEnableOrDisableBindPath(
                   (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v3 + 6) + 48) + 72),
                   a3,
                   v7,
                   0);
            if ( v4 )
              break;
          }
          v7 = (struct CBindPath *)((char *)v7 + 20);
        }
      }
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v10);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v3 + 6) + 24));
  }
  return v4;
}

//----- (6E64CDFC) --------------------------------------------------------
__int32 __thiscall CModifyContext::HrPrepare(CModifyContext *this)
{
  CModifyContext *v1; // esi@1
  char *v2; // edi@1
  signed int v3; // eax@1
  __int32 v4; // eax@2
  __int32 v5; // eax@3
  __int32 v6; // eax@4
  __int32 v7; // eax@5
  __int32 v8; // eax@6
  __int32 v9; // eax@7
  __int32 v10; // eax@8

  v1 = this;
  v2 = (char *)this - 72;
  v3 = CRegistryBindingsContext::HrPrepare(
         (CModifyContext *)((char *)this + 124),
         (CModifyContext *)((char *)this - 72));
  *((_DWORD *)v1 + 55) = v3;
  if ( !v3 )
  {
    v4 = CNetConfigCore::HrCopyCore(v1, (const struct CNetConfigCore *)v2);
    *((_DWORD *)v1 + 55) = v4;
    if ( !v4 )
    {
      v5 = CBindPath::HrReserveRoomForComponents((CBindPath *)v2, 0x40u);
      *((_DWORD *)v1 + 55) = v5;
      if ( !v5 )
      {
        v6 = CStackTable::HrReserveRoomForEntries((CStackTable *)(v2 + 20), 0x40u);
        *((_DWORD *)v1 + 55) = v6;
        if ( !v6 )
        {
          v7 = CBindingSet::HrReserveRoomForBindPaths((CModifyContext *)((char *)v1 + 64), 0x40u);
          *((_DWORD *)v1 + 55) = v7;
          if ( !v7 )
          {
            v8 = CBindingSet::HrReserveRoomForBindPaths((CModifyContext *)((char *)v1 + 84), 0x40u);
            *((_DWORD *)v1 + 55) = v8;
            if ( !v8 )
            {
              v9 = CBindPath::HrReserveRoomForComponents((CModifyContext *)((char *)v1 + 104), 0x40u);
              *((_DWORD *)v1 + 55) = v9;
              if ( !v9 )
              {
                v10 = CFilterMap::HrLoadMapFromRegistry((CModifyContext *)((char *)v1 + 196), v1);
                *((_DWORD *)v1 + 55) = v10;
                if ( !v10 )
                  *((_BYTE *)v1 + 224) = 1;
              }
            }
          }
        }
      }
    }
  }
  return *((_DWORD *)v1 + 55);
}

//----- (6E64CEC0) --------------------------------------------------------
signed int __thiscall CRegistryBindingsContext::HrPrepare(CRegistryBindingsContext *this, struct CNetConfig *a2)
{
  CRegistryBindingsContext *v2; // esi@1
  signed int result; // eax@1

  v2 = this;
  *(_DWORD *)this = a2;
  result = CDynamicBuffer::HrReserveBytes((CRegistryBindingsContext *)((char *)this + 24), 0x1000u);
  if ( !result )
  {
    result = CDynamicBuffer::HrReserveBytes((CRegistryBindingsContext *)((char *)v2 + 40), 0x1000u);
    if ( !result )
    {
      result = CDynamicBuffer::HrReserveBytes((CRegistryBindingsContext *)((char *)v2 + 56), 0x1000u);
      if ( !result )
      {
        result = CNetConfig::HrEnsureExternalDataLoadedForAllComponents(*(CNetConfig **)v2);
        if ( !result )
          result = CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized((CGlobalNotifyInterface *)(*(_DWORD *)v2 + 64));
      }
    }
  }
  return result;
}

//----- (6E64CF1A) --------------------------------------------------------
int __thiscall CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized(CGlobalNotifyInterface *this)
{
  struct CImplINetCfg **v1; // esi@1
  char *v2; // ebx@1
  int i; // edi@2

  JUMPOUT(*(_DWORD *)this, 0, nullsub_2);
  v1 = (struct CImplINetCfg **)((char *)this + 4);
  *(_DWORD *)this = 1;
  v2 = (char *)this - 64;
  if ( *((_DWORD *)this + 1)
    || !CImplINetCfg::HrCreateInstance((CGlobalNotifyInterface *)((char *)this - 64), (struct CImplINetCfg **)this + 1) )
  {
    for ( i = *((_DWORD *)v2 + 2);
          i != *((_DWORD *)v2 + 3)
       && !CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(
             (CNotifyObjectInterface *)(*(_DWORD *)i + 112),
             *v1,
             0);
          i += 4 )
      ;
  }
  return nullsub_2();
}
// 6E64DA8A: using guessed type int nullsub_2(void);

//----- (6E64CF67) --------------------------------------------------------
int __thiscall CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(CNotifyObjectInterface *this, struct CImplINetCfg *a2, int a3)
{
  CNotifyObjectInterface *v3; // esi@1
  int v4; // ebx@2
  IID *v5; // eax@4
  void *v7; // edi@9
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-30h]@1
  struct IUnknown *v9; // [sp+1Ch] [bp-24h]@8
  int v10; // [sp+20h] [bp-20h]@3
  struct IUnknown *v11; // [sp+24h] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@11

  v3 = this;
  LogToken = SetupGetThreadLogToken();
  if ( *((_BYTE *)v3 + 4) )
    return 0;
  *((_BYTE *)v3 + 4) = 1;
  v4 = (int)((char *)v3 - 112);
  if ( FIsConsideredNetClass(*((_DWORD *)v3 - 24)) )
    return 0;
  v10 = CExternalComponentData::HrEnsureExternalDataLoaded((CExternalComponentData *)(v4 + 36));
  if ( !v10 )
  {
    v5 = *(IID **)(v4 + 44);
    if ( !v5 )
      return 0;
    if ( !CImplINetCfg::HrCoCreateWrapper(
            (CNotifyObjectInterface *)((char *)v3 - 112),
            v5,
            0,
            0x401u,
            &IID_INetCfgComponentControl,
            (void **)&v11) )
    {
      v10 = CComponent::HrGetINetCfgComponentInterface(
              (CNotifyObjectInterface *)((char *)v3 - 112),
              a2,
              (struct INetCfgComponent **)&v9);
      if ( !v10 )
      {
        v10 = -2147024882;
        v7 = MemAlloc(0x1Cu);
        *(_DWORD *)v3 = v7;
        if ( v7 )
        {
          v10 = 0;
          memset(v7, 0, 0x1Cu);
          AddRefObj(v11);
          **(_DWORD **)v3 = v11;
          v11->lpVtbl->QueryInterface(v11, &IID_INetCfgComponentNotifyBinding, (void **)(*(_DWORD *)v3 + 4));
          v11->lpVtbl->QueryInterface(v11, &IID_INetCfgComponentPropertyUi, (void **)(*(_DWORD *)v3 + 8));
          v11->lpVtbl->QueryInterface(v11, &IID_INetCfgComponentSetup, (void **)(*(_DWORD *)v3 + 12));
          v11->lpVtbl->QueryInterface(v11, &IID_INetCfgComponentUpperEdge, (void **)(*(_DWORD *)v3 + 16));
          v11->lpVtbl->QueryInterface(v11, &IID_INetCfgComponentNotifyGlobal, (void **)(*(_DWORD *)v3 + 20));
          if ( *(_DWORD *)(*(_DWORD *)v3 + 20) )
          {
            if ( (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(*(_DWORD *)v3 + 20) + 12))(
                   *(_DWORD *)(*(_DWORD *)v3 + 20),
                   *(_DWORD *)v3 + 24) < 0 )
              *(_DWORD *)(*(_DWORD *)v3 + 24) = 0;
          }
          CImplINetCfg::RaiseRpl((int)a2, 1);
          ms_exc.registration.TryLevel = 0;
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "NCI: Init Notify Object for %ws",
            *(_DWORD *)(v4 + 28));
          ((void (__stdcall *)(struct IUnknown *, struct IUnknown *, struct CImplINetCfg *, int))v11->lpVtbl[1].QueryInterface)(
            v11,
            v9,
            a2,
            a3);
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "NCI: Init Notify Object for %ws complete",
            *(_DWORD *)(v4 + 28));
          ms_exc.registration.TryLevel = -2;
          CImplINetCfg::LowerRpl((int)a2, 1);
        }
        ReleaseObj(v9);
      }
      ReleaseObj(v11);
    }
  }
  return v10;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64D205) --------------------------------------------------------
__int32 __stdcall CImplINetCfg::HrCoCreateWrapper(struct CComponent *a2, IID *rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, IID *riid, void **a7)
{
  HRESULT v6; // edi@2
  HKEY v8; // [sp+10h] [bp-58h]@3
  OLECHAR sz; // [sp+14h] [bp-54h]@2
  char Dst; // [sp+16h] [bp-52h]@2

  if ( *((_DWORD *)a2 + 42) )
  {
    v8 = 0;
    if ( !CComponent::HrOpenInstanceKey(a2, 0x20019u, &v8, 0, 0) )
    {
      HrCiRegisterNotificationDll(v8, 0, 1);
      RegSafeCloseKey(v8);
    }
  }
  v6 = CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, a7);
  sz = 0;
  memset(&Dst, 0, 0x4Cu);
  StringFromGUID2(rclsid, &sz, 39);
  return v6;
}

//----- (6E64D285) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetDisplayName(CImplINetCfgComponent *this, unsigned __int16 **a2)
{
  return CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy(this, 4u, a2);
}

//----- (6E64D2A0) --------------------------------------------------------
signed int __thiscall CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy(CImplINetCfgComponent *this, unsigned int a2, unsigned __int16 **a3)
{
  CImplINetCfgComponent *v3; // esi@1
  signed int v4; // ebx@1

  v3 = this;
  *a3 = 0;
  v4 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 4u, 0, 0);
  if ( !v4 )
  {
    v4 = HrCoTaskMemAllocAndDupSz(*(const unsigned __int16 **)(*((_DWORD *)v3 + 7) + a2 + 36), a3, 0x1000u);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v3 + 6) + 24));
  }
  return v4;
}

//----- (6E64D2F3) --------------------------------------------------------
int __stdcall FCheckGroupMembership(DWORD nSubAuthority1, int a2)
{
  return FCheckGroupMembershipInternal(2u, 0x20u, nSubAuthority1, a2);
}

//----- (6E64D310) --------------------------------------------------------
int __stdcall FCheckGroupMembershipInternal(BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, int a4)
{
  int v4; // esi@1
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  PSID pSid; // [sp+10h] [bp-10h]@1
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [sp+14h] [bp-Ch]@1

  pIdentifierAuthority.Value[0] = 0;
  pIdentifierAuthority.Value[1] = 0;
  pIdentifierAuthority.Value[2] = 0;
  pIdentifierAuthority.Value[3] = 0;
  pIdentifierAuthority.Value[4] = 0;
  pIdentifierAuthority.Value[5] = 5;
  pSid = 0;
  v4 = 0;
  v7 = 0;
  v6 = 0;
  if ( AllocateAndInitializeSid(
         &pIdentifierAuthority,
         nSubAuthorityCount,
         nSubAuthority0,
         nSubAuthority1,
         0,
         0,
         0,
         0,
         0,
         0,
         &pSid) )
  {
    if ( IsUserMemberOfSID(pSid, &v7, &v6) >= 0 )
    {
      if ( a4 )
      {
        v4 = v7;
      }
      else if ( v7 && !v6 )
      {
        v4 = 1;
      }
    }
    FreeSid(pSid);
  }
  return v4;
}

//----- (6E64D3AF) --------------------------------------------------------
signed int __stdcall IsUserMemberOfSID(PSID pSid1, int *a2, int *a3)
{
  HANDLE v3; // eax@5
  DWORD (__stdcall *v4)(); // esi@6
  int v5; // eax@6
  HANDLE v6; // eax@7
  unsigned int v7; // eax@12
  DWORD v8; // ST10_4@14
  HANDLE v9; // eax@14
  LPVOID v10; // esi@14
  unsigned int v11; // edi@18
  PSID *v12; // ebx@19
  HANDLE v13; // eax@23
  int v15; // eax@32
  int v16; // eax@36
  int v17; // eax@46
  HANDLE ExistingTokenHandle; // [sp+4h] [bp-10h]@7
  DWORD TokenInformationLength; // [sp+8h] [bp-Ch]@1
  HANDLE TokenHandle; // [sp+Ch] [bp-8h]@1
  int v21; // [sp+10h] [bp-4h]@1

  v21 = 0;
  TokenHandle = 0;
  TokenInformationLength = 0;
  if ( !pSid1 || !a2 )
    return -2147024809;
  *a2 = 0;
  if ( a3 )
    *a3 = 0;
  v3 = GetCurrentThread();
  if ( OpenThreadToken(v3, 8u, 0, &TokenHandle) )
  {
    v4 = GetLastError;
    goto LABEL_11;
  }
  TokenHandle = 0;
  v4 = GetLastError;
  v5 = GetLastError();
  if ( v5 == 1008 )
  {
    v6 = GetCurrentProcess();
    if ( !OpenProcessToken(v6, 0xAu, &ExistingTokenHandle) )
    {
      v15 = GetLastError();
      if ( v15 > 0 )
        v15 = (unsigned __int16)v15 | 0x80070000;
      v21 = v15;
      if ( v15 < 0 )
        goto LABEL_24;
    }
    if ( !DuplicateToken(ExistingTokenHandle, SecurityImpersonation, &TokenHandle) )
    {
      TokenHandle = 0;
      v16 = GetLastError();
      if ( v16 > 0 )
        v16 = (unsigned __int16)v16 | 0x80070000;
      v21 = v16;
    }
    CloseHandle(ExistingTokenHandle);
  }
  else
  {
    if ( v5 > 0 )
      v5 = (unsigned __int16)v5 | 0x80070000;
    v21 = v5;
  }
  if ( v21 >= 0 )
  {
LABEL_11:
    if ( !GetTokenInformation(TokenHandle, TokenGroups, 0, TokenInformationLength, &TokenInformationLength) )
    {
      v7 = v4();
      if ( v7 != 122 )
      {
        if ( (signed int)v7 > 0 )
          v7 = (unsigned __int16)v7 | 0x80070000;
        v21 = v7;
      }
    }
    if ( v21 >= 0 )
    {
      v8 = TokenInformationLength;
      v9 = GetProcessHeap();
      v10 = HeapAlloc(v9, 8u, v8);
      if ( !v10 )
        v21 = -2147024882;
      if ( v21 >= 0 )
      {
        if ( !GetTokenInformation(TokenHandle, TokenGroups, v10, TokenInformationLength, &TokenInformationLength) )
        {
          v17 = GetLastError();
          if ( v17 > 0 )
            v17 = (unsigned __int16)v17 | 0x80070000;
          v21 = v17;
        }
        if ( v21 >= 0 )
        {
          v11 = 0;
          if ( *(_DWORD *)v10 )
          {
            v12 = (PSID *)((char *)v10 + 4);
            while ( !EqualSid(pSid1, *v12) )
            {
              ++v11;
              v12 += 2;
              if ( v11 >= *(_DWORD *)v10 )
                goto LABEL_22;
            }
            *a2 = 1;
            if ( a3 )
              *a3 = (*((_DWORD *)v10 + 2 * v11 + 2) >> 4) & 1;
          }
        }
      }
LABEL_22:
      if ( v10 )
      {
        v13 = GetProcessHeap();
        HeapFree(v13, 0, v10);
      }
    }
  }
LABEL_24:
  if ( TokenHandle )
    CloseHandle(TokenHandle);
  return v21;
}

//----- (6E64D905) --------------------------------------------------------
int __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::AddRef(a1 - 12);
}
// 6E64380F: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(_DWORD);

//----- (6E64D914) --------------------------------------------------------
int __stdcall ATL::CComObject<CSrvrcfg>::AddRef(int a1)
{
  return ATL::CComObject<CSrvrcfg>::AddRef(a1 - 8);
}
// 6E64F322: using guessed type _DWORD __stdcall ATL::CComObject<CSrvrcfg>::AddRef(_DWORD);

//----- (6E64D983) --------------------------------------------------------
__int32 __thiscall CComponent::HrOpenServiceKey(CComponent *this, REGSAM samDesired, HKEY *phkResult)
{
  CComponent *v3; // ebx@1
  wchar_t pszDest; // [sp+Ch] [bp-20Ch]@1

  *phkResult = 0;
  v3 = this;
  StringCchCopyW(&pszDest, 0x104u, L"System\\CurrentControlSet\\Services");
  StringCchCatW(&pszDest, 0x104u, L"\\");
  StringCchCatW(&pszDest, 0x104u, *((STRSAFE_LPCWSTR *)v3 + 12));
  return HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, samDesired, phkResult);
}

//----- (6E64DA51) --------------------------------------------------------
__int32 __stdcall HrRegSetBinary(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData, DWORD cbData)
{
  return HrRegSetValueEx(hKey, lpValueName, 3u, lpData, cbData);
}

//----- (6E64DAAB) --------------------------------------------------------
int __stdcall HrSaveNetworkConfigurationToBufferWithAlloc(struct CNetConfig *a1, size_t Size, unsigned __int32 *a3)
{
  unsigned __int32 *v3; // ebx@1
  size_t v4; // esi@1
  int result; // eax@1
  void *v6; // eax@3

  v3 = a3;
  v4 = Size;
  *(_DWORD *)Size = 0;
  *v3 = 0;
  Size = 0;
  result = HrSaveNetworkConfigurationToBuffer(a1, 0, (unsigned __int32 *)&Size);
  if ( !result )
  {
    do
    {
      if ( *(_DWORD *)v4 )
      {
        MemFree(*(void **)v4);
        *(_DWORD *)v4 = 0;
      }
      v6 = MemAlloc(Size);
      *(_DWORD *)v4 = v6;
      if ( v6 )
      {
        memset(v6, 0, Size);
        result = HrSaveNetworkConfigurationToBuffer(a1, *(unsigned __int8 **)v4, (unsigned __int32 *)&Size);
        if ( !result )
          *v3 = Size;
      }
      else
      {
        result = -2147024882;
      }
    }
    while ( result == -2147024774 );
  }
  return result;
}

//----- (6E64DB29) --------------------------------------------------------
int __thiscall CComponentReferences::CountComponentsReferencedBy(CComponentReferences *this)
{
  JUMPOUT(*(_DWORD *)this, 0, nullsub_3);
  return std::vector<CParam *,std::nc_allocator<CParam *>>::size(*(_DWORD *)this + 4);
}
// 6E656F8A: using guessed type int nullsub_3();

//----- (6E64DB40) --------------------------------------------------------
struct CComponent *__thiscall CComponentReferences::PComponentReferencedByAtIndex(CComponentReferences *this, unsigned int a2)
{
  CBindPath *v2; // ecx@1
  struct CComponent *result; // eax@2

  v2 = *(CBindPath **)this;
  if ( v2 )
    result = CBindPath::PGetComponentAtIndex(v2, a2);
  else
    result = 0;
  return result;
}

//----- (6E64DB8C) --------------------------------------------------------
__int32 __thiscall CComponentList::HrAddComponentsInList1ButNotInList2(CComponentList *this, const struct CComponentList *a2, const struct CComponentList *a3)
{
  const struct CComponent **v3; // esi@1
  const struct CComponent *v4; // ebx@2
  __int32 v6; // eax@7
  CComponentList *i; // [sp+8h] [bp-8h]@1
  __int32 v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v3 = (const struct CComponent **)*((_DWORD *)a2 + 2);
  for ( i = this; v3 != *((const struct CComponent ***)a2 + 3); ++v3 )
  {
    v4 = *v3;
    if ( !CComponentList::FComponentInList(a3, *v3) )
    {
      v6 = CComponentList::HrInsertComponent(i, v4, 0x1200u);
      v8 = v6;
      if ( v6 )
        break;
    }
  }
  return v8;
}

//----- (6E64DBDB) --------------------------------------------------------
int __thiscall CNetConfigCore::FContainsLightWeightFilter(CNetConfigCore *this)
{
  int v1; // eax@1
  int v2; // ecx@1

  v1 = *((_DWORD *)this + 2);
  v2 = *((_DWORD *)this + 3);
  while ( v1 != v2 )
  {
    if ( *(_DWORD *)(*(_DWORD *)v1 + 24) & 0x40000 )
      return 1;
    v1 += 4;
  }
  return 0;
}

//----- (6E64DC11) --------------------------------------------------------
__int32 __thiscall CBindingSet::HrGetAffectedComponentsInBindingSet(CBindingSet *this, struct CComponentList *a2)
{
  CBindingSet *v2; // ebx@1
  int v3; // esi@1
  int v4; // eax@4
  const struct CComponent *v5; // ebx@4
  CBindingSet *v7; // [sp+8h] [bp-8h]@1
  __int32 v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v2 = this;
  v3 = *((_DWORD *)this + 2);
  v7 = this;
  if ( v3 != *((_DWORD *)this + 3) )
  {
    do
    {
      v8 = CComponentList::HrInsertComponent(a2, **(const struct CComponent ***)(v3 + 8), 0x1200u);
      if ( v8 )
        break;
      if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4) == 2 )
      {
        v4 = *(_DWORD *)(v3 + 12) - 4;
        v5 = *(const struct CComponent **)v4;
        if ( FIsConsideredNetClass(*(_DWORD *)(*(_DWORD *)v4 + 16)) )
        {
          v8 = CComponentList::HrInsertComponent(a2, v5, 0x1200u);
          if ( v8 )
            return v8;
        }
        v2 = v7;
      }
      v3 += 20;
    }
    while ( v3 != *((_DWORD *)v2 + 3) );
  }
  return v8;
}

//----- (6E64DC93) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingPath::Reset(CImplIEnumNetCfgBindingPath *this)
{
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  *((_DWORD *)this + 10) = *(_DWORD *)(*((_DWORD *)this + 9) + 8);
  LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  return 0;
}

//----- (6E64DCCB) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetClassGuid(CImplINetCfgComponent *this, struct _GUID *a2)
{
  CImplINetCfgComponent *v2; // ebx@1
  int v3; // esi@2
  char *v4; // edi@2
  char *v6; // edi@4
  signed int thisa; // [sp+14h] [bp+8h]@1

  v2 = this;
  thisa = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( thisa )
  {
    a2->Data1 = GUID_NULL.Data1;
    *(_DWORD *)&a2->Data2 = *(_DWORD *)&GUID_NULL.Data2;
    v6 = (char *)a2->Data4;
    *(_DWORD *)v6 = *(_DWORD *)&GUID_NULL.Data4[0];
    *((_DWORD *)v6 + 1) = *(_DWORD *)&GUID_NULL.Data4[4];
  }
  else
  {
    v3 = *(&MAP_NETCLASS_TO_GUID.Data1 + *(_DWORD *)(*((_DWORD *)v2 + 7) + 16));
    a2->Data1 = *(_DWORD *)v3;
    v3 += 4;
    *(_DWORD *)&a2->Data2 = *(_DWORD *)v3;
    v3 += 4;
    v4 = (char *)a2->Data4;
    *(_DWORD *)v4 = *(_DWORD *)v3;
    *((_DWORD *)v4 + 1) = *(_DWORD *)(v3 + 4);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v2 + 6) + 24));
  }
  return thisa;
}

//----- (6E64DD24) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetBindName(CImplINetCfgComponent *this, unsigned __int16 **a2)
{
  return CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy(this, 0x40u, a2);
}

//----- (6E64DD3F) --------------------------------------------------------
int __stdcall ATL::CComObject<CMSClient>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::AddRef(a1 - 8);
}
// 6E64380F: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfgComponent>::AddRef(_DWORD);

//----- (6E64DD4E) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::IsEnabled(CImplINetCfgBindingPath *this)
{
  signed int v1; // edi@1
  char v3; // [sp+8h] [bp-14h]@1
  char v4; // [sp+Ch] [bp-10h]@1

  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v4, 0);
  v1 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, (struct CBindPath *)&v3);
  if ( !v1 )
  {
    if ( CNetConfigCore::FIsBindPathDisabled(
           *(CNetConfigCore **)(*((_DWORD *)this + 3) + 48),
           (const struct CBindPath *)&v3,
           2u) )
      v1 = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v4);
  return v1;
}

//----- (6E64DDB3) --------------------------------------------------------
int __thiscall CFilterDevices::CFilterDevices(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(this, 0);
  CComponentList::CComponentList((void *)(v2 + 20));
  CBindingSet::CBindingSet((void *)(v2 + 48));
  memset((void *)v2, 0, 0x44u);
  *(_DWORD *)(v2 + 16) = a2;
  return v2;
}

//----- (6E64DE05) --------------------------------------------------------
void *__stdcall std::_Allocate<CIndex>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(16 * v2);
}

//----- (6E64DE2E) --------------------------------------------------------
BOOL __thiscall CFilterMap::FEntryInList(CFilterMap *this, const struct CFilterMapEntry *a2)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-4h]@1

  v2 = *((_DWORD *)this + 2);
  return *(_DWORD *)std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(
                      (int)&v4,
                      *((_DWORD *)this + 1),
                      v2,
                      (int)&a2) != v2;
}

//----- (6E64DE5D) --------------------------------------------------------
__int32 __thiscall CPszArray::HrReserveRoomForPointers(CPszArray *this, unsigned int a2)
{
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::reserve((int)this, a2);
  return 0;
}

//----- (6E64DE89) --------------------------------------------------------
signed int __thiscall CCounter::HrSetIndex(CCounter *this, unsigned int a2)
{
  CCounter *v2; // esi@1
  unsigned int v3; // edi@2
  char v4; // bl@2
  unsigned int v5; // eax@3
  int v6; // ecx@5
  signed int v8; // eax@11
  signed int v9; // [sp+4h] [bp-4h]@1

  v9 = 0;
  v2 = this;
  if ( a2 > 0x270F )
  {
    v9 = -2147024809;
  }
  else
  {
    v3 = (a2 >> 5) + 1;
    v4 = a2 & 0x1F;
    if ( v3 <= 1 || v3 <= *((_DWORD *)this + 1) || (v8 = CCounter::HrGrowBuffer(this, v3), (v9 = v8) == 0) )
    {
      v5 = *((_DWORD *)v2 + 1);
      if ( v5 )
      {
        if ( v5 < v3 )
          return -2147024774;
        *(_DWORD *)v2 = *(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v3 - 4);
      }
      if ( *(_DWORD *)v2 & (1 << v4) )
      {
        v9 = -2147024809;
      }
      else
      {
        v6 = (1 << v4) | *(_DWORD *)v2;
        *(_DWORD *)v2 = v6;
        if ( v5 )
          *(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v3 - 4) = v6;
      }
    }
  }
  return v9;
}

//----- (6E64DEFB) --------------------------------------------------------
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::size(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 8) - v1) >> 4;
  else
    result = 0;
  return result;
}

//----- (6E64DF0E) --------------------------------------------------------
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::capacity(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 12) - v1) >> 4;
  else
    result = 0;
  return result;
}

//----- (6E64DF21) --------------------------------------------------------
void __stdcall std::_Construct<CIndex,CIndex>(int a1, int a2)
{
  int v2; // edi@2

  if ( a1 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    v2 = a1 + 8;
    *(_DWORD *)v2 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 12);
  }
}

//----- (6E64DF5D) --------------------------------------------------------
errno_t __cdecl wcsncpy_s(wchar_t *Dst, rsize_t SizeInWords, const wchar_t *Src, rsize_t MaxCount)
{
  rsize_t v4; // ebx@3
  const wchar_t *v5; // edx@5
  wchar_t *v6; // eax@6
  const wchar_t v7; // cx@7
  errno_t v9; // esi@17
  const wchar_t v10; // cx@21

  if ( MaxCount )
  {
    if ( Dst )
      goto LABEL_3;
LABEL_17:
    v9 = 22;
    *_errno() = 22;
LABEL_18:
    _invalid_parameter(0, 0, 0, 0, 0);
    return v9;
  }
  if ( !Dst )
  {
    if ( !SizeInWords )
      return 0;
    goto LABEL_17;
  }
LABEL_3:
  v4 = SizeInWords;
  if ( SizeInWords <= 0 )
    goto LABEL_17;
  if ( !MaxCount )
  {
    *Dst = 0;
    return 0;
  }
  v5 = Src;
  if ( !Src )
  {
    *Dst = 0;
    goto LABEL_17;
  }
  v6 = Dst;
  if ( MaxCount == -1 )
  {
    do
    {
      v10 = *v5;
      *v6 = *v5;
      ++v6;
      ++v5;
      if ( !v10 )
        break;
      --v4;
    }
    while ( v4 );
  }
  else
  {
    do
    {
      v7 = *v5;
      *v6 = *v5;
      ++v6;
      ++v5;
      if ( !v7 )
        break;
      --v4;
      if ( !v4 )
        break;
      --MaxCount;
    }
    while ( MaxCount );
    if ( !MaxCount )
      *v6 = 0;
  }
  if ( v4 )
    return 0;
  if ( MaxCount != -1 )
  {
    *Dst = 0;
    *_errno() = 34;
    v9 = 34;
    goto LABEL_18;
  }
  Dst[SizeInWords - 1] = 0;
  return 80;
}

//----- (6E64DFDB) --------------------------------------------------------
int __cdecl _iswctype_l(wint_t C, wctype_t Type, _locale_t Locale)
{
  struct localeinfo_struct v4; // [sp+0h] [bp-14h]@6
  int v5; // [sp+8h] [bp-Ch]@9
  char v6; // [sp+Ch] [bp-8h]@8
  WORD CharType[2]; // [sp+10h] [bp-4h]@3

  if ( C == -1 )
  {
    *(_DWORD *)CharType = 0;
  }
  else if ( C >= 0x100u )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v4, Locale);
    if ( !__crtGetStringTypeW(
            &v4,
            1u,
            &C,
            1,
            CharType,
            v4.locinfo->lc_codepage,
            (LCID)v4.locinfo->lc_category[0].wlocale) )
      *(_DWORD *)CharType = 0;
    if ( v6 )
      *(_DWORD *)(v5 + 112) &= 0xFFFFFFFD;
  }
  else
  {
    *(_DWORD *)CharType = (unsigned __int16)(Type & _pwctype[C]);
  }
  return Type & CharType[0];
}

//----- (6E64E09D) --------------------------------------------------------
void __stdcall GetProductFlavor(const void *a1, enum PRODUCT_FLAVOR *a2)
{
  enum PRODUCT_FLAVOR *v2; // esi@1

  v2 = a2;
  *(_DWORD *)a2 = 1;
  RtlGetNtProductType(&a2);
  if ( a2 != (enum PRODUCT_FLAVOR *)1 )
    *(_DWORD *)v2 = 2;
}
// 6E641014: using guessed type int __stdcall RtlGetNtProductType(_DWORD);

//----- (6E64E0CA) --------------------------------------------------------
int __stdcall FIsUserNetworkConfigOps()
{
  return FCheckGroupMembership(0x22Cu, 0);
}

//----- (6E64E0DC) --------------------------------------------------------
__int32 __stdcall CMSClient::SysQueryBindingPath(CMSClient *this, unsigned __int32 a2, struct INetCfgBindingPath *a3)
{
  return 0;
}

//----- (6E64E0E6) --------------------------------------------------------
int __thiscall CComponentReferences::CountSoftwareReferencedBy(CComponentReferences *this)
{
  JUMPOUT(*(_DWORD *)this, 0, nullsub_4);
  return std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(*(_DWORD *)this + 20);
}
// 6E656F8B: using guessed type int nullsub_4();

//----- (6E64E0F8) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 8) - v1) / 28;
  else
    result = 0;
  return result;
}

//----- (6E64E144) --------------------------------------------------------
int __stdcall HrSaveNetworkConfigurationToBuffer(struct CNetConfig *a1, unsigned __int8 *Dst, unsigned __int32 *a3)
{
  BOOL v3; // ecx@70
  unsigned int v4; // ebx@70
  BOOL v5; // ecx@70
  void (*v6)(SP_LOG_TOKEN, DWORD, DWORD, PCSTR, ...); // edi@1
  BOOL v7; // ecx@1
  unsigned int v8; // eax@1
  BOOL v9; // ecx@1
  unsigned __int8 *v10; // ebx@1
  BOOL v11; // ecx@4
  BOOL v12; // ecx@4
  struct CComponent *v13; // esi@8
  BOOL v14; // ecx@10
  BOOL v15; // ecx@10
  BOOL v16; // ecx@10
  unsigned int v17; // edi@10
  BOOL v18; // ecx@10
  unsigned int v19; // edi@10
  BOOL v20; // ecx@10
  int v21; // esi@12
  unsigned int v22; // ebx@12
  BOOL v23; // ecx@12
  unsigned int v24; // ebx@12
  BOOL v25; // ecx@12
  void *v26; // ebx@12
  void *v27; // ebx@12
  BOOL v28; // ecx@15
  BOOL v29; // ecx@18
  int v30; // esi@21
  unsigned int v31; // edi@22
  BOOL v32; // ecx@22
  unsigned int v33; // eax@22
  BOOL v34; // ecx@25
  BOOL v35; // ecx@27
  int v36; // esi@30
  int v37; // ST40_4@31
  BOOL v38; // ecx@31
  unsigned int v39; // edi@31
  BOOL v40; // ecx@31
  BOOL v41; // ecx@31
  BOOL v42; // ecx@34
  BOOL v43; // ecx@36
  BOOL v44; // ecx@40
  BOOL v45; // ecx@41
  BOOL v46; // ecx@46
  BOOL v47; // ecx@47
  BOOL v48; // ecx@47
  BOOL v49; // ecx@51
  BOOL v50; // ecx@51
  int v51; // esi@59
  BOOL v53; // ecx@63
  BOOL v54; // ecx@65
  unsigned int v55; // eax@72
  const struct CComponent **v56; // edi@72
  BOOL v57; // ecx@74
  int v58; // esi@76
  BOOL v59; // ecx@76
  const void *v60; // esi@79
  BOOL v61; // ecx@81
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-2Ch]@1
  struct CComponent *v63; // [sp+14h] [bp-24h]@8
  struct CComponent *v64; // [sp+14h] [bp-24h]@63
  struct CComponent *v65; // [sp+14h] [bp-24h]@72
  unsigned int v66; // [sp+18h] [bp-20h]@10
  unsigned int v67; // [sp+18h] [bp-20h]@76
  const unsigned __int16 *Src; // [sp+1Ch] [bp-1Ch]@8
  char *Srca; // [sp+1Ch] [bp-1Ch]@40
  size_t Size; // [sp+20h] [bp-18h]@10
  size_t Sizea; // [sp+20h] [bp-18h]@18
  size_t Sizeb; // [sp+20h] [bp-18h]@27
  unsigned int v73; // [sp+24h] [bp-14h]@10
  int v74; // [sp+24h] [bp-14h]@47
  int v75; // [sp+24h] [bp-14h]@51
  int v76; // [sp+24h] [bp-14h]@72
  size_t v77; // [sp+28h] [bp-10h]@10
  unsigned int v78; // [sp+28h] [bp-10h]@50
  int v79; // [sp+28h] [bp-10h]@54
  unsigned int v80; // [sp+2Ch] [bp-Ch]@7
  unsigned int v81; // [sp+2Ch] [bp-Ch]@39
  unsigned __int32 v82; // [sp+30h] [bp-8h]@1
  unsigned int v83; // [sp+34h] [bp-4h]@1
  unsigned int v84; // [sp+34h] [bp-4h]@4
  unsigned int v85; // [sp+34h] [bp-4h]@15
  unsigned int v86; // [sp+34h] [bp-4h]@18
  unsigned int v87; // [sp+34h] [bp-4h]@27
  unsigned __int32 v88; // [sp+34h] [bp-4h]@36
  unsigned int v89; // [sp+34h] [bp-4h]@41
  unsigned int v90; // [sp+34h] [bp-4h]@44
  unsigned int v91; // [sp+34h] [bp-4h]@47
  int Dsta; // [sp+44h] [bp+Ch]@4
  unsigned __int8 *Dstb; // [sp+44h] [bp+Ch]@18
  unsigned __int8 *Dstc; // [sp+44h] [bp+Ch]@27
  unsigned __int8 *Dstd; // [sp+44h] [bp+Ch]@36

  v6 = _SetupWriteTextLog;
  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI: BEGIN WRITING CONFIG BLOB]");
  v82 = *a3;
  v8 = ALIGNUP(v7, 4u);
  v10 = Dst;
  v83 = v8;
  if ( Dst && v8 <= v82 )
  {
    *(_DWORD *)Dst = 0;
    v10 = &Dst[ALIGNUP(v9, 4u)];
  }
  Dsta = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a1 + 4));
  v84 = ALIGNUP(v11, 4u) + v83;
  if ( v10 && v84 <= v82 )
  {
    *(_DWORD *)v10 = Dsta;
    v10 += ALIGNUP(v12, 4u);
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Number of components %d", Dsta);
  }
  v80 = 0;
  if ( Dsta )
  {
    do
    {
      v13 = CBindPath::PGetComponentAtIndex(a1, v80);
      v63 = v13;
      Src = (const unsigned __int16 *)*((_DWORD *)v13 + 8);
      if ( !Src )
        Src = &String;
      Size = CbOfSzAndTerm(*((const unsigned __int16 **)v13 + 7));
      v77 = CbOfSzAndTerm(Src);
      v73 = ALIGNUP(v14, Size);
      v66 = ALIGNUP(v15, v77);
      v17 = ALIGNUP(v16, 0x10u);
      v19 = ALIGNUP(v18, 4u) + v17;
      v84 += v73 + v66 + v19 + ALIGNUP(v20, 4u);
      if ( v10 && v84 <= v82 )
      {
        *(_DWORD *)v10 = *(_DWORD *)v13;
        v21 = (int)((char *)v13 + 4);
        *((_DWORD *)v10 + 1) = *(_DWORD *)v21;
        v21 += 4;
        *((_DWORD *)v10 + 2) = *(_DWORD *)v21;
        *((_DWORD *)v10 + 3) = *(_DWORD *)(v21 + 4);
        v22 = (unsigned int)&v10[ALIGNUP(v12, 0x10u)];
        *(_DWORD *)v22 = *((_DWORD *)v63 + 4);
        v24 = ALIGNUP(v23, 4u) + v22;
        *(_DWORD *)v24 = *((_DWORD *)v63 + 6);
        v26 = (void *)(ALIGNUP(v25, 4u) + v24);
        memcpy(v26, *((const void **)v63 + 7), Size);
        v27 = (char *)v26 + v73;
        memcpy(v27, Src, v77);
        v10 = (unsigned __int8 *)((char *)v27 + v66);
      }
      ++v80;
    }
    while ( v80 < Dsta );
    v6 = _SetupWriteTextLog;
  }
  v85 = ALIGNUP(v12, 4u) + v84;
  if ( v10 && v85 <= v82 )
  {
    *(_DWORD *)v10 = *((_DWORD *)a1 + 10);
    v10 += ALIGNUP(v28, 4u);
  }
  Dstb = 0;
  Sizea = 0;
  v86 = ALIGNUP(v28, 4u) + v85;
  if ( v10 && v86 <= v82 )
  {
    Sizea = (size_t)v10;
    v10 += ALIGNUP(v29, 4u);
  }
  v30 = *((_DWORD *)a1 + 7);
  if ( v30 != *((_DWORD *)a1 + 8) )
  {
    do
    {
      v31 = ALIGNUP(v29, 4u);
      v33 = v31 + v86 + ALIGNUP(v32, 4u);
      ++Dstb;
      v86 = v33;
      if ( v10 && v33 <= v82 )
      {
        *(_DWORD *)v10 = CComponentList::UnGetIndexOfComponent(a1, *(const struct CComponent **)v30);
        v4 = (unsigned int)&v10[ALIGNUP(v3, 4u)];
        *(_DWORD *)v4 = CComponentList::UnGetIndexOfComponent(a1, *(const struct CComponent **)(v30 + 4));
        v10 = (unsigned __int8 *)(ALIGNUP(v5, 4u) + v4);
      }
      v30 += 8;
    }
    while ( v30 != *((_DWORD *)a1 + 8) );
    v6 = _SetupWriteTextLog;
  }
  v34 = Sizea;
  if ( Sizea )
  {
    *(_DWORD *)Sizea = Dstb;
    v6(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Number of stack entries %d", Dstb);
  }
  Dstc = 0;
  Sizeb = 0;
  v87 = ALIGNUP(v34, 4u) + v86;
  if ( v10 && v87 <= v82 )
  {
    Sizeb = (size_t)v10;
    v10 += ALIGNUP(v35, 4u);
  }
  v36 = *((_DWORD *)a1 + 13);
  if ( v36 != *((_DWORD *)a1 + 14) )
  {
    do
    {
      ++Dstc;
      v37 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v36 + 4);
      v39 = v37 * ALIGNUP(v38, 4u);
      v87 += v39 + ALIGNUP(v40, 4u);
      if ( v10 && v87 <= v82 )
      {
        v76 = 0;
        v65 = (struct CComponent *)v10;
        v55 = ALIGNUP(v41, 4u);
        v56 = *(const struct CComponent ***)(v36 + 8);
        v10 += v55;
        while ( v56 != *(const struct CComponent ***)(v36 + 12) )
        {
          ++v76;
          *(_DWORD *)v10 = CComponentList::UnGetIndexOfComponent(a1, *v56);
          v10 += ALIGNUP(v57, 4u);
          ++v56;
        }
        *(_DWORD *)v65 = v76;
      }
      v36 += 20;
    }
    while ( v36 != *((_DWORD *)a1 + 14) );
    v6 = _SetupWriteTextLog;
  }
  v42 = Sizeb;
  if ( Sizeb )
  {
    *(_DWORD *)Sizeb = Dstc;
    v6(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Number of disabled bindpaths %d", Dstc);
  }
  Dstd = 0;
  v88 = ALIGNUP(v42, 4u) + v87;
  if ( v10 && v88 <= v82 )
  {
    Sizeb = (size_t)v10;
    v10 += ALIGNUP(v43, 4u);
  }
  v81 = 0;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a1 + 4)) )
  {
    do
    {
      Srca = (char *)CBindPath::PGetComponentAtIndex(a1, v81) + 120;
      if ( CComponentReferences::FIsReferencedByOthers((CComponentReferences *)Srca) )
      {
        ++Dstd;
        v89 = ALIGNUP(v44, 4u) + v88;
        if ( v10 && v89 <= v82 )
        {
          *(_DWORD *)v10 = v81;
          v10 += ALIGNUP(v45, 4u);
        }
        v90 = ALIGNUP(v45, 4u) + v89;
        if ( v10 && v90 <= v82 )
        {
          *(_DWORD *)v10 = CComponentReferences::FIsReferencedByUser((CComponentReferences *)Srca) != 0;
          v10 += ALIGNUP(v46, 4u);
        }
        v74 = CComponentReferences::CountComponentsReferencedBy((CComponentReferences *)Srca);
        v91 = ALIGNUP(v47, 4u) + v90;
        if ( v10 && v91 <= v82 )
        {
          *(_DWORD *)v10 = v74;
          v10 += ALIGNUP(v48, 4u);
        }
        v78 = 0;
        if ( v74 )
        {
          do
          {
            v64 = CComponentReferences::PComponentReferencedByAtIndex((CComponentReferences *)Srca, v78);
            v91 += ALIGNUP(v53, 4u);
            if ( v10 && v91 <= v82 )
            {
              *(_DWORD *)v10 = CComponentList::UnGetIndexOfComponent(a1, v64);
              v10 += ALIGNUP(v54, 4u);
            }
            ++v78;
          }
          while ( v78 < v74 );
        }
        v75 = CComponentReferences::CountSoftwareReferencedBy((CComponentReferences *)Srca);
        v88 = ALIGNUP(v49, 4u) + v91;
        if ( v10 && v88 <= v82 )
        {
          *(_DWORD *)v10 = v75;
          v10 += ALIGNUP(v50, 4u);
        }
        v79 = 0;
        if ( v75 )
        {
          do
          {
            v58 = CComponentReferences::PSoftwareReferencedByAtIndex(Srca, v79);
            v67 = 2 * *(_DWORD *)(v58 + 20) + 2;
            v88 += ALIGNUP(v59, v67);
            if ( v10 && v88 <= v82 )
            {
              if ( *(_DWORD *)(v58 + 24) < 8u )
                v60 = (const void *)(v58 + 4);
              else
                v60 = *(const void **)(v58 + 4);
              memcpy(v10, v60, v67);
              v10 += ALIGNUP(v61, v67);
            }
            ++v79;
          }
          while ( v79 < (unsigned int)v75 );
        }
      }
      ++v81;
    }
    while ( v81 < std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a1 + 4)) );
  }
  if ( Sizeb )
  {
    *(_DWORD *)Sizeb = Dstd;
    v6(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Number of components being referenced %d", Dstd);
  }
  *a3 = v88;
  if ( v88 > v82 )
    v51 = v10 != 0 ? 0x8007007A : 0;
  else
    v51 = 0;
  if ( v10 )
    v6(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: cbBuf - %d, cbBufIn - %d", v88, v82);
  v6(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI: END WRITING CONFIG BLOB]");
  return v51;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64E76B) --------------------------------------------------------
int __thiscall CComponentList::UnGetIndexOfComponent(CComponentList *this, const struct CComponent *a2)
{
  int v2; // esi@1
  int v4; // [sp+4h] [bp-4h]@1

  v2 = *((_DWORD *)this + 2);
  std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(
    (int)&v4,
    *((_DWORD *)this + 2),
    *((_DWORD *)this + 3),
    (int)&a2);
  return (v4 - v2) >> 2;
}

//----- (6E64E7B0) --------------------------------------------------------
BOOL __thiscall CComponentReferences::FIsReferencedByOthers(CComponentReferences *this)
{
  int v1; // esi@1

  v1 = *(_DWORD *)this;
  return *(_DWORD *)this
      && (*(_BYTE *)(v1 + 36)
       || std::vector<CParam *,std::nc_allocator<CParam *>>::size(v1 + 4)
       || std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v1 + 20));
}

//----- (6E64E7DF) --------------------------------------------------------
struct CComponent *__thiscall CComponentList::PFindComponentByInstanceGuid(CComponentList *this, const struct _GUID *a2)
{
  const void **v2; // edx@1
  struct CComponent *result; // eax@2
  const void **v4; // [sp+Ch] [bp-4h]@1

  v2 = (const void **)*((_DWORD *)this + 2);
  v4 = (const void **)*((_DWORD *)this + 3);
  if ( v2 == v4 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      result = (struct CComponent *)*v2;
      if ( !memcmp(a2, *v2, 0x10u) )
        break;
      ++v2;
      if ( v2 == v4 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (6E64E83A) --------------------------------------------------------
void __thiscall CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath(void *this, int a2, int a3, int a4, int a5)
{
  int v5; // eax@8
  void *v6; // ebx@1
  int i; // eax@2
  int v8; // esi@4
  int v9; // eax@4
  int v10; // edx@12
  int v11; // [sp-Ch] [bp-54h]@12
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-38h]@1
  int v13; // [sp+28h] [bp-20h]@3
  LPVOID pv; // [sp+2Ch] [bp-1Ch]@14
  CPPEH_RECORD ms_exc; // [sp+30h] [bp-18h]@12

  v6 = this;
  LogToken = SetupGetThreadLogToken();
  if ( a5 )
    *(_DWORD *)a5 = 0;
  CImplINetCfg::RaiseRpl(*((_DWORD *)v6 + 1), a2 != 1);
  for ( i = *((_DWORD *)v6 - 14); ; i = v13 + 4 )
  {
    v13 = i;
    if ( i == *((_DWORD *)v6 - 13) )
      break;
    v8 = *(_DWORD *)i;
    v9 = *(_DWORD *)(*(_DWORD *)i + 112);
    if ( v9 )
    {
      if ( *(_DWORD *)(v9 + 20) )
      {
        v5 = *(_DWORD *)(v9 + 24);
        if ( v5 & 0x100 )
        {
          if ( v5 & a3 )
          {
            ms_exc.registration.TryLevel = 0;
            v11 = *(_DWORD *)(*(_DWORD *)(v8 + 112) + 20);
            v10 = *(_DWORD *)v11;
            if ( a2 )
            {
              if ( (*(int (__stdcall **)(int, int, int))(v10 + 20))(v11, a3, a4) != 1 )
                CModifyContext::HrDirtyComponent(
                  (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v6 + 1) + 48) + 72),
                  (const struct CComponent *)v8);
            }
            else if ( (*(int (__stdcall **)(int, int, int))(v10 + 16))(v11, a3, a4) == 303138 )
            {
              *(_DWORD *)a5 = 1;
              pv = 0;
              if ( (*(int (__stdcall **)(int, LPVOID *))(*(_DWORD *)a4 + 28))(a4, &pv) >= 0 )
              {
                _SetupWriteTextLog(
                  LogToken,
                  0x40000000u,
                  5 - (g_IsInUpgrade != 0),
                  "NCI: %ws Notify object disabled path %ws",
                  *(_DWORD *)(v8 + 28),
                  pv);
                CoTaskMemFree(pv);
                pv = 0;
              }
              ms_exc.registration.TryLevel = -2;
              break;
            }
            ms_exc.registration.TryLevel = -2;
          }
        }
      }
    }
  }
  CImplINetCfg::LowerRpl(*((_DWORD *)v6 + 1), a2 != 1);
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64E8D4) --------------------------------------------------------
__int32 __thiscall CFilterMap::HrInsertEntry(CFilterMap *this, const struct CFilterMapEntry *a2)
{
  CFilterMap *v2; // edi@1
  const struct CFilterMapEntry *v3; // esi@1
  void *i; // edx@3
  int v5; // eax@5
  int v6; // ebx@5
  bool v7; // zf@7
  int v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+20h] [bp-4h]@9

  v2 = this;
  v9 = (int)this;
  v3 = a2;
  if ( !CFilterMap::FEntryInList(this, a2)
    && !CFilterMap::PFindEntryByFilterAndMiniportGuid(
          v2,
          *(const struct CComponent **)v3,
          (const struct _GUID *)((char *)v3 + 4)) )
  {
    for ( i = (void *)*((_DWORD *)v2 + 1); i != *((void **)v2 + 2); i = (char *)i + 4 )
    {
      v5 = *(_DWORD *)i;
      v6 = memcmp((const char *)v3 + 4, (const char *)(*(_DWORD *)i + 4), 16);
      v3 = a2;
      if ( v6 <= 0 )
      {
        v7 = memcmp((char *)a2 + 4, (const void *)(v5 + 4), 0x10u) == 0;
        v3 = a2;
        if ( !v7 || *(_DWORD *)a2 <= *(_DWORD *)v5 )
        {
          v2 = (CFilterMap *)v9;
          break;
        }
      }
      v2 = (CFilterMap *)v9;
    }
    v10 = 0;
    a2 = v3;
    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert((int)v2, (int)&v9, i, (int)&a2);
  }
  return 0;
}

//----- (6E64E978) --------------------------------------------------------
__int32 __cdecl wcstol(const wchar_t *Str, wchar_t **EndPtr, int Radix)
{
  __int32 result; // eax@2

  if ( __locale_changed )
    result = sub_6E64E9A8(0, (int)Str, (int)EndPtr, Radix, 0);
  else
    result = sub_6E64E9A8((struct localeinfo_struct *)&__initiallocalestructinfo, (int)Str, (int)EndPtr, Radix, 0);
  return result;
}
// 6E699490: using guessed type int (*__initiallocalestructinfo)[22];
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E64E9A8) --------------------------------------------------------
int __cdecl sub_6E64E9A8(struct localeinfo_struct *a1, int a2, int a3, int a4, int a5)
{
  return sub_6E64E9CD(a1, a2, a3, a4, a5, 0);
}

//----- (6E64E9CD) --------------------------------------------------------
int __cdecl sub_6E64E9CD(struct localeinfo_struct *a1, int a2, int a3, int a4, int a5, int a6)
{
  wint_t v6; // si@7
  int v7; // edi@7
  unsigned int v8; // ebx@13
  int v9; // eax@14
  int v10; // edi@22
  int v12; // edi@52
  int v13; // eax@54
  struct localeinfo_struct Locale; // [sp+8h] [bp-18h]@1
  int v15; // [sp+10h] [bp-10h]@39
  char v16; // [sp+14h] [bp-Ch]@31
  unsigned int v17; // [sp+18h] [bp-8h]@13
  unsigned int v18; // [sp+1Ch] [bp-4h]@7

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a1);
  if ( a3 )
    *(_DWORD *)a3 = a2;
  if ( a2 && (!a4 || a4 >= 2 && a4 <= 36) )
  {
    v6 = *(_WORD *)a2;
    v18 = 0;
    v7 = a2 + 2;
    while ( _iswctype_l(v6, 8u, &Locale) )
    {
      v6 = *(_WORD *)v7;
      v7 += 2;
    }
    if ( v6 == 45 )
    {
      a5 |= 2u;
    }
    else if ( v6 != 43 )
    {
      goto LABEL_11;
    }
    v6 = *(_WORD *)v7;
    v7 += 2;
LABEL_11:
    if ( a4 )
    {
LABEL_12:
      if ( a4 == 16 && !_wchartodigit(v6) && (*(_WORD *)v7 == 120 || *(_WORD *)v7 == 88) )
      {
        v12 = v7 + 2;
        v6 = *(_WORD *)v12;
        v7 = v12 + 2;
      }
      goto LABEL_13;
    }
    if ( _wchartodigit(v6) )
    {
      a4 = 10;
    }
    else
    {
      if ( *(_WORD *)v7 == 120 || *(_WORD *)v7 == 88 )
      {
        a4 = 16;
        goto LABEL_12;
      }
      a4 = 8;
    }
LABEL_13:
    v17 = 0xFFFFFFFF % a4;
    v8 = 0xFFFFFFFF / a4;
    while ( 1 )
    {
      v9 = _wchartodigit(v6);
      if ( v9 == -1 )
      {
        if ( (v6 < 0x41u || v6 > 0x5Au) && (unsigned __int16)(v6 - 97) > 0x19u )
        {
LABEL_22:
          v10 = v7 - 2;
          if ( a5 & 8 )
          {
            if ( (a5 & 4 || !(a5 & 1) && (a5 & 2 && v18 > 0x80000000 || !(a5 & 2) && v18 > 0x7FFFFFFF)) && !a6 )
            {
              *_errno() = 34;
              if ( a5 & 1 )
                v18 = -1;
              else
                v18 = ((a5 & 2) != 0) + 0x7FFFFFFF;
            }
          }
          else
          {
            if ( a3 )
              v10 = a2;
            v18 = 0;
          }
          if ( a3 )
            *(_DWORD *)a3 = v10;
          if ( a5 & 2 )
            v18 = -v18;
          if ( v16 )
            *(_DWORD *)(v15 + 112) &= 0xFFFFFFFD;
          return v18;
        }
        v13 = v6;
        if ( (unsigned __int16)(v6 - 97) <= 0x19u )
          v13 = v6 - 32;
        v9 = v13 - 55;
      }
      if ( v9 >= (unsigned int)a4 )
        goto LABEL_22;
      a5 |= 8u;
      if ( a6 || v18 < v8 || v18 == v8 && v9 <= v17 )
      {
        v18 = v9 + a4 * v18;
      }
      else
      {
        a5 |= 4u;
        if ( !a3 )
          goto LABEL_22;
      }
      v6 = *(_WORD *)v7;
      v7 += 2;
    }
  }
  *_errno() = 22;
  _invalid_parameter(0, 0, 0, 0, 0);
  if ( v16 )
    *(_DWORD *)(v15 + 112) &= 0xFFFFFFFD;
  return 0;
}

//----- (6E64EB2C) --------------------------------------------------------
int *__cdecl _errno()
{
  int v0; // eax@1
  int *result; // eax@2

  v0 = _getptd_noexit();
  if ( v0 )
    result = (int *)(v0 + 8);
  else
    result = &dword_6E69B610;
  return result;
}
// 6E6483B5: using guessed type int _getptd_noexit(void);
// 6E69B610: using guessed type int dword_6E69B610;

//----- (6E64EB42) --------------------------------------------------------
int __thiscall CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll(CBindPath *this)
{
  CBindPath *v1; // edi@1
  int i; // esi@1

  v1 = this;
  for ( i = *((_DWORD *)this + 2); ; i += 4 )
  {
    if ( i == *((_DWORD *)v1 + 3) )
      return 1;
    if ( !CExternalComponentData::FLoadedOkayIfLoadedAtAll((CExternalComponentData *)(*(_DWORD *)i + 36)) )
      break;
  }
  return 0;
}

//----- (6E64EB72) --------------------------------------------------------
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Ufill(int this, int a2, int a3, int a4)
{
  stdext::unchecked_uninitialized_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(a2, a3, a4, this);
  return a2 + 16 * a3;
}

//----- (6E64EB98) --------------------------------------------------------
void __stdcall stdext::unchecked_uninitialized_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4)
{
  int v4; // [sp+4h] [bp-4h]@0

  LOBYTE(v4) = 0;
  std::_Uninit_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(a1, a2, a3, a4, a4, v4);
}

//----- (6E64EBC6) --------------------------------------------------------
void __stdcall std::_Uninit_fill_n<CIndex *,unsigned int,CIndex,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  while ( a2 )
  {
    std::_Construct<CIndex,CIndex>(a1, a3);
    --a2;
    a1 += 16;
  }
}

//----- (6E64EBEE) --------------------------------------------------------
int __cdecl _wchartodigit(unsigned __int16 a1)
{
  signed int v2; // ecx@5
  unsigned __int16 v3; // dx@38

  if ( a1 < 0x30u )
    return -1;
  if ( a1 < 0x3Au )
    return a1 - 48;
  v2 = 65296;
  if ( a1 >= 0xFF10u )
  {
    v3 = -230;
LABEL_40:
    if ( a1 < v3 )
      return a1 - v2;
    return -1;
  }
  v2 = 1632;
  if ( a1 >= 0x660u )
  {
    if ( a1 < 0x66Au )
      return a1 - v2;
    v2 = 1776;
    if ( a1 >= 0x6F0u )
    {
      if ( a1 < 0x6FAu )
        return a1 - v2;
      v2 = 2406;
      if ( a1 >= 0x966u )
      {
        if ( a1 < 0x970u )
          return a1 - v2;
        v2 = 2534;
        if ( a1 >= 0x9E6u )
        {
          if ( a1 < 0x9F0u )
            return a1 - v2;
          v2 = 2662;
          if ( a1 >= 0xA66u )
          {
            if ( a1 < 0xA70u )
              return a1 - v2;
            v2 = 2790;
            if ( a1 >= 0xAE6u )
            {
              if ( a1 < 0xAF0u )
                return a1 - v2;
              v2 = 2918;
              if ( a1 >= 0xB66u )
              {
                if ( a1 < 0xB70u )
                  return a1 - v2;
                v2 = 3174;
                if ( a1 >= 0xC66u )
                {
                  if ( a1 < 0xC70u )
                    return a1 - v2;
                  v2 = 3302;
                  if ( a1 >= 0xCE6u )
                  {
                    if ( a1 < 0xCF0u )
                      return a1 - v2;
                    v2 = 3430;
                    if ( a1 >= 0xD66u )
                    {
                      if ( a1 < 0xD70u )
                        return a1 - v2;
                      v2 = 3664;
                      if ( a1 >= 0xE50u )
                      {
                        if ( a1 < 0xE5Au )
                          return a1 - v2;
                        v2 = 3792;
                        if ( a1 >= 0xED0u )
                        {
                          if ( a1 < 0xEDAu )
                            return a1 - v2;
                          v2 = 3872;
                          if ( a1 >= 0xF20u )
                          {
                            if ( a1 < 0xF2Au )
                              return a1 - v2;
                            v2 = 4160;
                            if ( a1 >= 0x1040u )
                            {
                              if ( a1 < 0x104Au )
                                return a1 - v2;
                              v2 = 6112;
                              if ( a1 >= 0x17E0u )
                              {
                                if ( a1 < 0x17EAu )
                                  return a1 - v2;
                                v2 = 6160;
                                if ( a1 >= 0x1810u )
                                {
                                  v3 = 6170;
                                  goto LABEL_40;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -1;
}

//----- (6E64EC1B) --------------------------------------------------------
__int32 __thiscall CFilterMap::HrLoadMapFromRegistry(CFilterMap *this, const struct CNetConfigCore *a2)
{
  __int32 v2; // esi@1
  __int32 v3; // eax@5
  unsigned __int32 v4; // ecx@5
  __int32 v5; // eax@6
  CFilterMap *v7; // [sp+8h] [bp-38h]@1
  void *lpMem; // [sp+Ch] [bp-34h]@6
  HKEY phkResult; // [sp+10h] [bp-30h]@5
  HKEY hKey; // [sp+14h] [bp-2Ch]@4
  DWORD MemberIndex; // [sp+18h] [bp-28h]@2
  HDEVINFO DeviceInfoSet; // [sp+1Ch] [bp-24h]@1
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+20h] [bp-20h]@3

  v7 = this;
  *((_DWORD *)this + 4) = a2;
  DeviceInfoSet = 0;
  v2 = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, 0, 0, 8u, &DeviceInfoSet);
  if ( !v2 )
  {
    MemberIndex = 0;
    do
    {
      DeviceInfoData.cbSize = 0;
      memset(&DeviceInfoData.ClassGuid, 0, 0x18u);
      v2 = HrSetupDiEnumDeviceInfo(DeviceInfoSet, MemberIndex, &DeviceInfoData);
      if ( !v2 )
      {
        if ( HrSetupDiOpenDevRegKey(DeviceInfoSet, &DeviceInfoData, 1u, 0, 2u, 0x20019u, &hKey) )
        {
          v2 = 0;
        }
        else
        {
          phkResult = 0;
          v3 = HrRegOpenKeyEx(hKey, L"Linkage", 0x20019u, &phkResult);
          v2 = v3;
          if ( v3 )
          {
            if ( v3 == -2147024894 )
              v2 = 0;
          }
          else
          {
            v5 = HrRegGetTypeWithAlloc(v4, phkResult, L"FilterList", 7u, (unsigned __int8 **)&lpMem, 0);
            v2 = v5;
            if ( v5 )
            {
              if ( v5 == -2147024894 )
                v2 = 0;
            }
            else
            {
              v2 = CFilterMap::HrInsertEntriesFromFilterList(v7, hKey, (const unsigned __int16 *)lpMem);
              if ( v2 )
                v2 = 0;
              MemFree(lpMem);
            }
            RegSafeCloseKey(phkResult);
          }
          RegSafeCloseKey(hKey);
        }
      }
      ++MemberIndex;
    }
    while ( !v2 );
    if ( v2 == -2147024637 )
      v2 = 0;
    SetupDiDestroyDeviceInfoListSafe(DeviceInfoSet);
  }
  return v2;
}

//----- (6E64ED60) --------------------------------------------------------
__int32 __thiscall CFilterMap::HrInsertEntriesFromFilterList(CFilterMap *this, HKEY a2, const unsigned __int16 *a3)
{
  __int32 v3; // esi@1
  const unsigned __int16 *v4; // eax@1
  bool v5; // zf@1
  LPCWSTR v6; // edi@4
  struct CComponent *v7; // eax@10
  int v8; // ebx@10
  HRESULT v9; // eax@14
  __int32 v10; // eax@15
  int v11; // edi@18
  int v12; // eax@19
  int v14; // [sp+10h] [bp-29Ch]@4
  wchar_t *EndPtr; // [sp+18h] [bp-294h]@5
  DWORD Type; // [sp+1Ch] [bp-290h]@15
  struct CComponent *v17; // [sp+20h] [bp-28Ch]@1
  int v18; // [sp+24h] [bp-288h]@14
  CCounter *v19; // [sp+28h] [bp-284h]@5
  LPCWSTR lpString; // [sp+2Ch] [bp-280h]@2
  CFilterMap *v21; // [sp+30h] [bp-27Ch]@1
  IID iid; // [sp+34h] [bp-278h]@9
  wchar_t Str1; // [sp+44h] [bp-268h]@15
  wchar_t sz; // [sp+24Ch] [bp-60h]@9
  char Dst; // [sp+24Eh] [bp-5Eh]@9
  int v26; // [sp+2A8h] [bp-4h]@19

  v3 = 0;
  v17 = 0;
  v4 = a3;
  v5 = *a3 == 0;
  v21 = this;
  while ( 1 )
  {
    lpString = v4;
    if ( v5 || v3 )
      return v3;
    v6 = lpString;
    v14 = lstrlenW(lpString);
    if ( v14 == 82 )
    {
      *_errno() = 0;
      v19 = (CCounter *)wcstol(v6 + 78, &EndPtr, 10);
      if ( !*EndPtr && *_errno() != 34 && (signed int)v19 >= -1 && (unsigned int)v19 <= 0x270F )
      {
        sz = 0;
        memset(&Dst, 0, 0x4Cu);
        iid.Data1 = 0;
        *(_DWORD *)&iid.Data2 = 0;
        *(_DWORD *)&iid.Data4[0] = 0;
        *(_DWORD *)&iid.Data4[4] = 0;
        wcsncpy_s(&sz, 0x27u, v6 + 39, 0x26u);
        v3 = IIDFromString(&sz, &iid);
        if ( v3 )
          goto LABEL_29;
        v7 = CComponentList::PFindComponentByInstanceGuid(*((CComponentList **)v21 + 4), &iid);
        v8 = (int)v7;
        if ( v7 )
        {
          if ( *((_DWORD *)v7 + 6) & 0x40000 )
          {
            if ( **((_DWORD **)v7 + 17) != 1 )
              v17 = v7;
            wcsncpy_s(&sz, 0x27u, lpString, 0x26u);
            v9 = IIDFromString(&sz, &iid);
            v18 = 0;
            v3 = v9;
            if ( !v9 )
            {
              Type = 520;
              v10 = HrRegQueryTypeSzBuffer(a2, L"FilterInfId", 1u, (LPBYTE)&Str1, (DWORD)&Type);
              v3 = v10;
              if ( v10 )
              {
                if ( v10 != -2147024894 )
                {
LABEL_29:
                  v3 = 0;
                  goto LABEL_24;
                }
                v3 = 0;
                if ( !CComponentList::PFindComponentByInstanceGuid(*((CComponentList **)v21 + 4), &iid) )
                  goto LABEL_24;
              }
              else
              {
                if ( !CComponentList::PFindComponentByInfId(*((CComponentList **)v21 + 4), &Str1, 0) )
                  goto LABEL_24;
                v18 = 1;
              }
              v11 = CFilterMap::PFindEntryByFilterAndMiniportGuid(v21, (const struct CComponent *)v8, &iid);
              if ( v11 )
                goto LABEL_23;
              v12 = (int)operator new(0x38u);
              v26 = 0;
              if ( v12 )
                v11 = CFilterMapEntry::CFilterMapEntry(v12, v8, (int)&iid, 1, v18);
              else
                v11 = 0;
              v26 = -1;
              if ( v11 )
              {
                v3 = CFilterMap::HrInsertEntry(v21, (const struct CFilterMapEntry *)v11);
                if ( !v3 )
                  goto LABEL_23;
                CFilterMapEntry::`scalar deleting destructor'((void *)v11, 1);
              }
              else
              {
                v3 = -2147024882;
              }
              if ( !v3 )
              {
LABEL_23:
                v3 = CFilterMapEntry::HrSetFilterAndIndex(
                       (CFilterMapEntry *)v11,
                       (const struct CComponent *)(**(_DWORD **)(v8 + 68) == 1 ? (unsigned int)v17 : 0),
                       v19,
                       1);
                goto LABEL_24;
              }
            }
          }
        }
      }
    }
LABEL_24:
    v4 = &lpString[v14 + 1];
    v5 = *v4 == 0;
  }
}

//----- (6E64F010) --------------------------------------------------------
BOOL __thiscall CComponentReferences::FIsReferencedByUser(CComponentReferences *this)
{
  return *(_DWORD *)this && *(_BYTE *)(*(_DWORD *)this + 36);
}

//----- (6E64F02C) --------------------------------------------------------
BOOL __thiscall CBindPath::FGetPathToken(CBindPath *this, STRSAFE_LPWSTR pszDest, unsigned __int32 *a3)
{
  int v3; // esi@3
  int v4; // ecx@8
  int v5; // ebx@8
  int v6; // eax@9
  int v7; // edi@10
  __int16 v8; // dx@11
  const wchar_t *v9; // ecx@15
  CBindPath *v11; // [sp+0h] [bp-10h]@1
  signed int v12; // [sp+4h] [bp-Ch]@3
  unsigned __int32 cchDest; // [sp+8h] [bp-8h]@3
  unsigned __int32 v14; // [sp+Ch] [bp-4h]@3

  v11 = this;
  if ( pszDest )
    *pszDest = 0;
  v14 = 0;
  v3 = *((_DWORD *)this + 2);
  cchDest = *a3;
  v12 = 1;
  if ( v3 != *((_DWORD *)this + 3) )
  {
    do
    {
      if ( v12 )
      {
        v12 = 0;
      }
      else
      {
        v14 += 2;
        if ( pszDest && v14 <= cchDest )
          StringCchCatW(pszDest, cchDest, L"->");
      }
      v4 = *(_DWORD *)v3;
      v5 = *(_DWORD *)(*(_DWORD *)v3 + 32);
      if ( v5 )
        v6 = *(_DWORD *)(*(_DWORD *)v3 + 32);
      else
        v6 = *(_DWORD *)(v4 + 28);
      v7 = v6 + 2;
      do
      {
        v8 = *(_WORD *)v6;
        v6 += 2;
      }
      while ( v8 );
      v14 += (v6 - v7) >> 1;
      if ( pszDest && v14 <= cchDest )
      {
        if ( v5 )
          v9 = *(const wchar_t **)(*(_DWORD *)v3 + 32);
        else
          v9 = *(const wchar_t **)(v4 + 28);
        StringCchCatW(pszDest, cchDest, v9);
      }
      v3 += 4;
    }
    while ( v3 != *((_DWORD *)v11 + 3) );
  }
  *a3 = v14;
  return cchDest >= v14;
}

//----- (6E64F0F3) --------------------------------------------------------
__int32 __thiscall CBindingSet::HrAddBindPathsInSet1ButNotInSet2(CBindingSet *this, const struct CBindingSet *a2, const struct CBindingSet *a3)
{
  const struct CBindPath *v3; // esi@1
  __int32 v4; // ebx@1
  CBindingSet *v6; // [sp+Ch] [bp-4h]@1

  v3 = (const struct CBindPath *)*((_DWORD *)a2 + 2);
  v6 = this;
  v4 = 0;
  while ( v3 != *((const struct CBindPath **)a2 + 3) )
  {
    if ( !CBindingSet::FContainsBindPath(a3, v3) )
    {
      v4 = CBindingSet::HrAddBindPath(v6, v3, 0x600u);
      if ( v4 )
        break;
    }
    v3 = (const struct CBindPath *)((char *)v3 + 20);
  }
  return v4;
}

//----- (6E64F18E) --------------------------------------------------------
int __thiscall CNetConfigCore::FContainsFilterComponent(CNetConfigCore *this)
{
  int v1; // eax@1
  int v2; // ecx@1

  v1 = *((_DWORD *)this + 2);
  v2 = *((_DWORD *)this + 3);
  while ( 1 )
  {
    if ( v1 == v2 )
      return 0;
    if ( *(_DWORD *)(*(_DWORD *)v1 + 24) & 0x400 )
      break;
    v1 += 4;
  }
  return 1;
}

//----- (6E64F1E8) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplIEnumNetCfgBindingPath>::~CComObject<CImplIEnumNetCfgBindingPath>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E64F20E) --------------------------------------------------------
void __thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::~CComObject<CImplIEnumNetCfgBindingPath>(int this)
{
  int v1; // esi@1
  struct IUnknown *v2; // ST00_4@1

  v1 = this;
  v2 = *(struct IUnknown **)(this + 12);
  *(_DWORD *)this = &ATL::CComObject<CImplIEnumNetCfgBindingPath>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  ReleaseObj(v2);
  InterlockedDecrement(&Addend);
  CImplIEnumNetCfgBindingPath::~CImplIEnumNetCfgBindingPath((CImplIEnumNetCfgBindingPath *)v1);
}
// 6E643178: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingPath>::`vftable')(CImplIEnumNetCfgBindingPath *, struct _GUID *, void **);

//----- (6E64F23B) --------------------------------------------------------
void __thiscall CImplIEnumNetCfgBindingPath::~CImplIEnumNetCfgBindingPath(CImplIEnumNetCfgBindingPath *this)
{
  CImplIEnumNetCfgBindingPath *v1; // esi@1
  void *v2; // ecx@1

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 9);
  if ( (void *)((char *)v1 + 16) != v2 && v2 )
    CBindingSet::`scalar deleting destructor'(v2, 1);
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)v1 + 20));
}

//----- (6E64F25C) --------------------------------------------------------
__int32 __thiscall CStackTable::HrReserveRoomForEntries(CStackTable *this, unsigned int a2)
{
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::reserve((int)((char *)this + 4), a2);
  return 0;
}

//----- (6E64F28B) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::reserve(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // ebx@3
  int v6; // eax@3

  v2 = this;
  if ( (unsigned int)a2 > 0x1FFFFFFF )
    std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
  result = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(this);
  if ( result < (unsigned int)a2 )
  {
    v4 = (int)std::_Allocate<CStackEntry>(a2, 0);
    std::_Uninitialized_copy<std::_Vector_iterator<CLanaEntry,std::nc_allocator<CLanaEntry>>,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
      *(_DWORD *)(v2 + 4),
      *(_DWORD *)(v2 + 8),
      v4,
      v2);
    v5 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(v2);
    v6 = *(_DWORD *)(v2 + 4);
    if ( v6 )
    {
      while ( v6 != *(_DWORD *)(v2 + 8) )
        v6 += 8;
      operator delete(*(void **)(v2 + 4));
    }
    *(_DWORD *)(v2 + 12) = v4 + 8 * a2;
    result = v4 + 8 * v5;
    *(_DWORD *)(v2 + 8) = result;
    *(_DWORD *)(v2 + 4) = v4;
  }
  return result;
}

//----- (6E64F316) --------------------------------------------------------
int __stdcall ATL::CComObject<CSrvrcfg>::AddRef(int a1)
{
  return ATL::CComObject<CSrvrcfg>::AddRef(a1 - 4);
}
// 6E64F322: using guessed type _DWORD __stdcall ATL::CComObject<CSrvrcfg>::AddRef(_DWORD);

//----- (6E64F33D) --------------------------------------------------------
void __thiscall CImplINetCfg::RaiseRpl(int this, int a2)
{
  ++*(_DWORD *)(this + 80);
  if ( !a2 )
    ++*(_DWORD *)(this + 84);
}

//----- (6E64F359) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CLanaEntry,std::nc_allocator<CLanaEntry>>,CLanaEntry *,std::nc_allocator<CLanaEntry>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry *,std::nc_allocator<CStackEntry>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E64F387) --------------------------------------------------------
int __stdcall std::_Uninit_copy<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry *,std::nc_allocator<CStackEntry>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  while ( a1 != a2 )
  {
    std::_Construct<CStackEntry,CStackEntry>(a3, a1);
    a3 += 8;
    a1 += 8;
  }
  return a3;
}
// 6E64345D: using guessed type _DWORD __stdcall std::_Construct<CStackEntry,CStackEntry>(_DWORD, _DWORD);

//----- (6E64F3B7) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::Initialize(CSrvrcfg *this, struct IUnknown *a2, struct INetCfg *a3, struct INetCfgBindingPath *a4)
{
  __int32 result; // eax@2

  if ( CMSClient::SysQueryBindingPath((CMSClient *)a2, (unsigned __int32)a3, a4) )
  {
    result = -2147024809;
  }
  else
  {
    *((_DWORD *)this + 13) = a2;
    AddRefObj(a2);
    GetProductFlavor(0, (CSrvrcfg *)((char *)this + 84));
    result = CSrvrcfg::HrOpenRegKeys(this, a3);
    if ( result >= 0 )
      result = CSrvrcfg::HrGetRegistryInfo(this, (int)a4);
  }
  return result;
}

//----- (6E64F40F) --------------------------------------------------------
__int32 __thiscall CSrvrcfg::HrGetRegistryInfo(CSrvrcfg *this, int a2)
{
  CSrvrcfg *v2; // esi@1
  __int32 v3; // edi@1
  bool v4; // zf@1
  DWORD v5; // ebx@1
  __int32 v6; // eax@5
  __int32 v7; // eax@6
  __int32 v8; // eax@10
  DWORD Type; // [sp+Ch] [bp-8h]@6
  HKEY hKey; // [sp+10h] [bp-4h]@1

  v2 = this;
  v3 = 0;
  v4 = *((_DWORD *)this + 21) == 2;
  v5 = (DWORD)((char *)this + 44);
  hKey = 0;
  *((_DWORD *)this + 11) = 0;
  if ( v4 )
  {
    *((_DWORD *)this + 10) = 3;
    *((_DWORD *)this + 12) = 1;
  }
  else
  {
    *((_DWORD *)this + 10) = 1;
    *((_DWORD *)this + 12) = 0;
  }
  if ( *((_DWORD *)this + 19) )
    return v3;
  v3 = HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
         0x20019u,
         &hKey);
  if ( v3 < 0 )
    goto LABEL_9;
  v6 = HrRegQueryDword(hKey, L"Lmannounce", v5);
  v3 = v6;
  if ( v6 >= 0 || v6 == -2147024894 )
  {
    v7 = HrRegQueryDword(hKey, L"Size", (DWORD)&Type);
    v3 = v7;
    if ( v7 < 0 )
    {
      if ( v7 != -2147024894 )
        goto LABEL_11;
      v3 = 0;
    }
    else
    {
      *((_DWORD *)v2 + 10) = Type;
    }
    RegCloseKey(hKey);
    hKey = 0;
LABEL_9:
    if ( !a2 )
    {
      v8 = HrRegQueryDword(*((HKEY *)v2 + 16), L"LargeSystemCache", (DWORD)((char *)v2 + 48));
      v3 = v8;
      if ( v8 < 0 && v8 == -2147024894 )
        v3 = 0;
    }
  }
LABEL_11:
  if ( hKey )
    RegCloseKey(hKey);
  return v3;
}

//----- (6E64F4E5) --------------------------------------------------------
__int32 __stdcall HrRegQueryDword(HKEY hKey, LPCWSTR lpValueName, DWORD Type)
{
  DWORD v3; // edi@1
  __int32 result; // eax@1
  DWORD cbData; // [sp+4h] [bp-4h]@1

  v3 = Type;
  cbData = 4;
  result = HrRegQueryValueEx(hKey, lpValueName, &Type, (LPBYTE)Type, &cbData);
  if ( !result )
  {
    if ( Type == 4 )
      return result;
    result = -2147023092;
  }
  *(_DWORD *)v3 = 0;
  return result;
}

//----- (6E64F527) --------------------------------------------------------
signed int __thiscall CFilterMapEntry::HrSetFilterAndIndex(CFilterMapEntry *this, const struct CComponent *a2, CCounter *a3, int a4)
{
  unsigned int v4; // edi@1
  CFilterMapEntry *v5; // esi@1
  unsigned int v6; // ebx@2
  unsigned int v7; // ST0C_4@4
  signed int v8; // esi@4
  int v10; // [sp+1Ch] [bp-4h]@1

  v4 = (unsigned int)a2;
  v5 = this;
  v10 = (int)((char *)this + 28);
  CIndices::PGetIndexByFilter((int)((char *)this + 28), (int)&a2, (int)a2);
  if ( v4 && !(*(_DWORD *)(v4 + 24) & 0x40000)
    || (v6 = (unsigned int)a3, (unsigned int)a3 > 0x270F)
    || a2 != *((const struct CComponent **)v5 + 9) )
  {
    v8 = -2147024809;
  }
  else
  {
    v7 = (unsigned int)a3;
    a3 = (CFilterMapEntry *)((char *)v5 + 44);
    v8 = CCounter::HrSetIndex((CFilterMapEntry *)((char *)v5 + 44), v7);
    if ( !v8 )
    {
      v8 = CIndices::HrInsertIndex(v10, v4, v6, a4, a4);
      if ( v8 )
        CCounter::UnsetIndex(a3, v6);
    }
  }
  return v8;
}

//----- (6E64F5B6) --------------------------------------------------------
int __thiscall CIndices::HrInsertIndex(int this, unsigned int a2, int a3, int a4, int a5)
{
  int i; // eax@2
  char v7; // [sp+Ch] [bp-18h]@4
  int v8; // [sp+10h] [bp-14h]@1
  int v9; // [sp+20h] [bp-4h]@4

  v8 = 0;
  if ( a4 )
  {
    for ( i = *(_DWORD *)(this + 4); i != *(_DWORD *)(this + 8) && a2 > *(_DWORD *)i; i += 16 )
      ;
  }
  else
  {
    i = *(_DWORD *)(this + 8);
  }
  v9 = 0;
  std::vector<CIndex,std::nc_allocator<CIndex>>::insert(this, (int)&v7, i, (int)&a2);
  return v8;
}

//----- (6E64F609) --------------------------------------------------------
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::insert(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@3

  v4 = this;
  if ( std::vector<CIndex,std::nc_allocator<CIndex>>::size(this) )
    v5 = (a3 - *(_DWORD *)(v4 + 4)) >> 4;
  else
    v5 = 0;
  std::vector<CIndex,std::nc_allocator<CIndex>>::_Insert_n(v4, a3, 1, a4);
  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4) + 16 * v5;
  return result;
}

//----- (6E64F64D) --------------------------------------------------------
int __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Insert_n(int this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@1
  unsigned int v6; // edi@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // edi@5
  int v10; // eax@8
  int v11; // eax@8
  int v12; // eax@8
  int v13; // esi@8
  int v14; // eax@8
  int v15; // edi@17
  int v16; // eax@18
  int v17; // [sp+Ch] [bp-20h]@1
  int v18; // [sp+10h] [bp-1Ch]@1
  int v19; // [sp+14h] [bp-18h]@1
  int v20; // [sp+18h] [bp-14h]@1
  int v21; // [sp+28h] [bp-4h]@8
  int v22; // [sp+3Ch] [bp+10h]@8

  v4 = this;
  v17 = *(_DWORD *)a4;
  v18 = *(_DWORD *)(a4 + 4);
  v19 = *(_DWORD *)(a4 + 8);
  v20 = *(_DWORD *)(a4 + 12);
  result = std::vector<CIndex,std::nc_allocator<CIndex>>::capacity(this);
  v6 = result;
  if ( a3 )
  {
    v7 = std::vector<CIndex,std::nc_allocator<CIndex>>::size(v4);
    if ( 0xFFFFFFF - v7 < (unsigned int)a3 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v8 = a3 + v7;
    if ( v6 >= v8 )
    {
      v15 = *(_DWORD *)(v4 + 8);
      if ( (*(_DWORD *)(v4 + 8) - a2) >> 4 >= (unsigned int)a3 )
      {
        *(_DWORD *)(v4 + 8) = std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(
                                v15 - 16 * a3,
                                v15,
                                v15,
                                v4);
        std::copy_backward<CIndex *,CIndex *>(a2, v15 - 16 * a3, v15);
        result = std::fill<CIndex *,CIndex>(a2, a2 + 16 * a3, (int)&v17);
      }
      else
      {
        std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(a2, v15, a2 + 16 * a3, v4);
        v16 = *(_DWORD *)(v4 + 8);
        v21 = 2;
        std::vector<CIndex,std::nc_allocator<CIndex>>::_Ufill(v4, v16, a3 - ((v16 - a2) >> 4), (int)&v17);
        *(_DWORD *)(v4 + 8) += 16 * a3;
        result = std::fill<CIndex *,CIndex>(a2, *(_DWORD *)(v4 + 8) - 16 * a3, (int)&v17);
      }
    }
    else
    {
      if ( 0xFFFFFFF - (v6 >> 1) < v6 )
        v9 = 0;
      else
        v9 = (v6 >> 1) + v6;
      if ( v9 < (unsigned int)v8 )
        v9 = v8;
      v10 = (int)std::_Allocate<CIndex>(v9, 0);
      v21 = 0;
      v22 = v10;
      v11 = std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(*(_DWORD *)(v4 + 4), a2, v10, v4);
      v12 = std::vector<CIndex,std::nc_allocator<CIndex>>::_Ufill(v4, v11, a3, (int)&v17);
      std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(a2, *(_DWORD *)(v4 + 8), v12, v4);
      v13 = std::vector<CIndex,std::nc_allocator<CIndex>>::size(v4) + a3;
      v14 = *(_DWORD *)(v4 + 4);
      if ( v14 )
      {
        while ( v14 != *(_DWORD *)(v4 + 8) )
          v14 += 16;
        operator delete(*(void **)(v4 + 4));
      }
      result = v22;
      *(_DWORD *)(v4 + 12) = v22 + 16 * v9;
      *(_DWORD *)(v4 + 8) = v22 + 16 * v13;
      *(_DWORD *)(v4 + 4) = v22;
    }
  }
  return result;
}

//----- (6E64F720) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(a1, a2, a3, a4, a4, v5);
}

//----- (6E64F74E) --------------------------------------------------------
int __stdcall std::_Uninit_copy<CIndex *,CIndex *,std::nc_allocator<CIndex>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int i; // esi@1

  for ( i = a1; i != a2; i += 16 )
  {
    std::_Construct<CIndex,CIndex>(a3, i);
    a3 += 16;
  }
  return a3;
}

//----- (6E64F76D) --------------------------------------------------------
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CMSClient>>,ATL::CComCreator<ATL::CComAggObject<CMSClient>>>::CreateInstance(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( a1 )
    result = ATL::CComCreator<ATL::CComAggObject<CMSClient>>::CreateInstance(a1, a2, a3);
  else
    result = ATL::CComCreator<ATL::CComObject<CMSClient>>::CreateInstance(0, a2, a3);
  return result;
}

//----- (6E64F792) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComObject<CMSClient>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // ebx@2
  void *v5; // ecx@2
  signed int result; // eax@6

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v4 = -2147024882;
    v5 = operator new(0xE8u);
    if ( v5 )
      v3 = ATL::CComObject<CMSClient>::CComObject<CMSClient>(v5, a1);
    if ( v3 )
    {
      v4 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v4 )
        ATL::CComObject<CMSClient>::`scalar deleting destructor'(v3, 1);
    }
    result = v4;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E64F7FD) --------------------------------------------------------
void *__thiscall ATL::CComObject<CMSClient>::CComObject<CMSClient>(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  CMSClient::CMSClient(this);
  *(_DWORD *)v2 = &ATL::CComObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 3) = &ATL::CComObject<CMSClient>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E641A70: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);
// 6E641A8C: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(CMSClient *, struct _GUID *, void **);
// 6E64AD28: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);
// 6E64AD4C: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);

//----- (6E64F838) --------------------------------------------------------
void *__thiscall CMSClient::CMSClient(void *this)
{
  void *v1; // esi@1

  v1 = this;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 16);
  RPC_CONFIG_DATA::RPC_CONFIG_DATA((RPC_CONFIG_DATA *)((char *)v1 + 44));
  *((_DWORD *)v1 + 32) = 0;
  *((_DWORD *)v1 + 33) = 0;
  *((_DWORD *)v1 + 34) = 0;
  *((_DWORD *)v1 + 35) = 0;
  *((_DWORD *)v1 + 36) = 0;
  *((_DWORD *)v1 + 37) = 0;
  *((_DWORD *)v1 + 38) = 0;
  *((_DWORD *)v1 + 39) = 0;
  *((_DWORD *)v1 + 40) = 0;
  *((_DWORD *)v1 + 41) = 0;
  *((_DWORD *)v1 + 42) = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 176));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 204));
  memset((char *)v1 + 44, 0, 0x54u);
  *((_DWORD *)v1 + 43) = 0;
  return v1;
}
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);

//----- (6E64F8CB) --------------------------------------------------------
RPC_CONFIG_DATA *__thiscall RPC_CONFIG_DATA::RPC_CONFIG_DATA(RPC_CONFIG_DATA *this)
{
  RPC_CONFIG_DATA *v1; // esi@1

  v1 = this;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)this);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 28));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 56));
  return v1;
}

//----- (6E64F8EE) --------------------------------------------------------
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CSrvrcfg>>,ATL::CComCreator<ATL::CComAggObject<CSrvrcfg>>>::CreateInstance(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( a1 )
    result = ATL::CComCreator<ATL::CComAggObject<CSrvrcfg>>::CreateInstance(a1, a2, a3);
  else
    result = ATL::CComCreator<ATL::CComObject<CSrvrcfg>>::CreateInstance(0, a2, a3);
  return result;
}

//----- (6E64F913) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComObject<CSrvrcfg>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // ebx@2
  CSrvrcfg *v5; // ecx@2
  signed int result; // eax@6

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v4 = -2147024882;
    v5 = (CSrvrcfg *)operator new(0xACu);
    if ( v5 )
      v3 = (void *)ATL::CComObject<CSrvrcfg>::CComObject<CSrvrcfg>(v5, a1);
    if ( v3 )
    {
      v4 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v4 )
        ATL::CComObject<CSrvrcfg>::`scalar deleting destructor'(v3, 1);
    }
    result = v4;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E64F97E) --------------------------------------------------------
CSrvrcfg *__thiscall ATL::CComObject<CSrvrcfg>::CComObject<CSrvrcfg>(CSrvrcfg *this, int a2)
{
  CSrvrcfg *v2; // esi@1

  v2 = this;
  CSrvrcfg::CSrvrcfg(this);
  *(_DWORD *)v2 = &ATL::CComObject<CSrvrcfg>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComObject<CSrvrcfg>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComObject<CSrvrcfg>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E64AD68: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E64AD8C: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E64C168: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(CSrvrcfg *, struct _GUID *, void **);

//----- (6E64F9B2) --------------------------------------------------------
CSrvrcfg *__thiscall CSrvrcfg::CSrvrcfg(CSrvrcfg *this)
{
  CSrvrcfg *v1; // esi@1

  v1 = this;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 12);
  *((_DWORD *)v1 + 13) = 0;
  *((_DWORD *)v1 + 15) = 0;
  *((_DWORD *)v1 + 16) = 0;
  *((_DWORD *)v1 + 17) = 0;
  *((_DWORD *)v1 + 18) = 0;
  *((_DWORD *)v1 + 19) = 0;
  *((_DWORD *)v1 + 20) = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 88));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 116));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)((char *)v1 + 144));
  *((_DWORD *)v1 + 14) = 0;
  *((_DWORD *)v1 + 10) = 0;
  *((_DWORD *)v1 + 11) = 0;
  *((_DWORD *)v1 + 12) = 0;
  return v1;
}
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);

//----- (6E64FA08) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(CMSClient *a1, struct _GUID *a2, void **a3)
{
  return CMSClient::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E64FA81) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(CSrvrcfg *a1, struct _GUID *a2, void **a3)
{
  return CSrvrcfg::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E64FAED) --------------------------------------------------------
__int32 __thiscall CComponentList::HrCopyComponentList(CComponentList *this, const struct CComponentList *a2)
{
  CBindPath::operator=((void *)this, (int)a2);
  return 0;
}

//----- (6E64FB19) --------------------------------------------------------
void *__thiscall CBindPath::operator=(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::operator=((int)((char *)this + 4), a2 != 0 ? a2 + 4 : 0);
  return v2;
}

//----- (6E64FB44) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::operator=(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@3
  int v5; // ebx@4
  int v6; // eax@6
  char *v7; // eax@7
  void *v9; // ebx@12
  int v10; // [sp+10h] [bp+8h]@12

  v2 = a2;
  v3 = this;
  if ( this != a2 )
  {
    if ( !std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2) )
    {
      std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v3);
      return v3;
    }
    v4 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2);
    if ( v4 <= (unsigned int)std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3) )
    {
      std::copy<CComponent * *,CComponent * *>(*(void **)(a2 + 4), *(_DWORD *)(a2 + 8), *(void **)(v3 + 4));
      v7 = (char *)(*(_DWORD *)(v3 + 4) + 4 * std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2));
      goto LABEL_8;
    }
    v5 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2);
    if ( v5 <= (unsigned int)std::vector<CParam *,std::nc_allocator<CParam *>>::capacity(v3) )
    {
      v9 = *(void **)(a2 + 4);
      v10 = (int)((char *)v9 + 4 * std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3));
      std::copy<CComponent * *,CComponent * *>(v9, v10, *(void **)(v3 + 4));
      v7 = std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
             (void *)v10,
             *(_DWORD *)(v2 + 8),
             *(void **)(v3 + 8),
             v3);
      goto LABEL_8;
    }
    if ( *(_DWORD *)(v3 + 4) )
      operator delete(*(void **)(v3 + 4));
    v6 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2);
    if ( std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(v3, v6) )
    {
      v7 = std::_Uninitialized_copy<CFilterDevice * *,CFilterDevice * *,std::nc_allocator<CFilterDevice *>>(
             *(void **)(a2 + 4),
             *(_DWORD *)(a2 + 8),
             *(void **)(v3 + 4),
             v3);
LABEL_8:
      *(_DWORD *)(v3 + 8) = v7;
      return v3;
    }
  }
  return v3;
}

//----- (6E64FC12) --------------------------------------------------------
__int32 __thiscall CModifyContext::HrEnableOrDisableBindPath(CModifyContext *this, unsigned __int32 a2, struct CBindPath *a3, struct INetCfgBindingPath *a4)
{
  char *v4; // esi@1
  int v5; // edi@1
  __int32 v6; // ebx@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = (char *)this - 72;
  v5 = (int)((char *)this - 24);
  v6 = 0;
  v8 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v5);
  if ( a2 == 16 )
  {
    CBindingSet::RemoveBindPath((CBindingSet *)(v4 + 44), a3);
  }
  else
  {
    v6 = CNetConfigCore::HrDisableBindPath((CNetConfigCore *)v4, a3);
    if ( v6 )
      return v6;
  }
  if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v5) != v8 )
    CGlobalNotifyInterface::NotifyBindPath((CGlobalNotifyInterface *)(v4 + 64), a2, a3, a4);
  return v6;
}

//----- (6E64FC6D) --------------------------------------------------------
void __thiscall CGlobalNotifyInterface::NotifyBindPath(CGlobalNotifyInterface *this, unsigned __int32 a2, struct CBindPath *a3, struct INetCfgBindingPath *a4)
{
  int v4; // edi@1
  int v5; // eax@1
  int v6; // ebx@1
  int v7; // eax@7
  signed int v8; // [sp+Ch] [bp-814h]@1
  CGlobalNotifyInterface *v9; // [sp+10h] [bp-810h]@1
  struct IUnknown *v10; // [sp+14h] [bp-80Ch]@1
  unsigned __int32 v11; // [sp+18h] [bp-808h]@5
  wchar_t pszDest; // [sp+1Ch] [bp-804h]@5

  v8 = 0;
  v4 = *((_DWORD *)this + 1);
  v9 = this;
  v5 = *((_DWORD *)a3 + 2);
  v10 = (struct IUnknown *)a4;
  v6 = *(_DWORD *)v5;
  if ( a4
    || CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll(a3)
    && (v8 = 1,
        !CImplINetCfgBindingPath::HrCreateInstance((struct CImplINetCfg *)v4, a3, (struct INetCfgBindingPath **)&v10)) )
  {
    if ( a2 & 1 )
    {
      v11 = 0;
      CNotifyObjectInterface::NbQueryOrNotifyBindingPath((void *)(v6 + 112), v4, 0, a2, (int)v10, (int)&v11);
      if ( v11 || (CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath((void *)v9, 0, a2, (int)v10, (int)&v11), v11) )
      {
        a2 = 33;
        CNetConfigCore::HrDisableBindPath(*(CNetConfigCore **)(v4 + 48), a3);
      }
    }
    v11 = 1023;
    if ( CBindPath::FGetPathToken(a3, &pszDest, &v11) )
    {
      if ( a2 & 0x10 )
      {
        v7 = (int)"enabled";
      }
      else
      {
        v7 = (int)"disabled";
        if ( !(a2 & 0x20) )
          v7 = (int)"removed";
      }
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S (%s)\n", &pszDest, v7);
    }
    CNotifyObjectInterface::NbQueryOrNotifyBindingPath((void *)(v6 + 112), v4, (LPVOID)1, a2, (int)v10, 0);
    CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath((void *)v9, 1, a2, (int)v10, 0);
    if ( v8 )
      ReleaseObj(v10);
  }
}

//----- (6E64FDA1) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::NbQueryOrNotifyBindingPath(void *this, int a2, LPVOID pv, int a4, int a5, int a6)
{
  void *v6; // esi@1
  int v7; // edi@6
  int v8; // eax@6
  int v9; // ecx@6
  int v10; // esi@7
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-28h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@6

  v6 = this;
  LogToken = SetupGetThreadLogToken();
  if ( a6 )
    *(_DWORD *)a6 = 0;
  if ( *(_DWORD *)v6 && *(_DWORD *)(*(_DWORD *)v6 + 4) )
  {
    v7 = (int)((char *)v6 - 112);
    v12 = pv != (LPVOID)1;
    CImplINetCfg::RaiseRpl(a2, v12);
    v8 = *(_DWORD *)(*(_DWORD *)v6 + 4);
    v9 = *(_DWORD *)v8;
    if ( pv )
    {
      (*(void (__stdcall **)(int, int, int))(v9 + 16))(v8, a4, a5);
    }
    else
    {
      v10 = a5;
      if ( (*(int (__stdcall **)(int, int, int))(v9 + 12))(v8, a4, a5) == 303138 )
      {
        *(_DWORD *)a6 = 1;
        pv = 0;
        if ( (*(int (__stdcall **)(int, LPVOID *))(*(_DWORD *)v10 + 28))(v10, &pv) >= 0 )
        {
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "NCI: %ws Notify object disabled path %ws",
            *(_DWORD *)(v7 + 28),
            pv);
          CoTaskMemFree(pv);
          pv = 0;
        }
      }
    }
    CImplINetCfg::LowerRpl(a2, v12);
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E64FE01) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingPath::Next(CImplIEnumNetCfgBindingPath *this, unsigned __int32 a2, struct INetCfgBindingPath **Dst, unsigned __int32 *a4)
{
  __int32 result; // eax@3

  if ( Dst && (a4 || a2 == 1) )
    result = CImplIEnumNetCfgBindingPath::HrNextOrSkip(this, a2, Dst, a4);
  else
    result = -2147467261;
  return result;
}

//----- (6E64FE37) --------------------------------------------------------
__int32 __thiscall CImplIEnumNetCfgBindingPath::HrNextOrSkip(CImplIEnumNetCfgBindingPath *this, unsigned __int32 a2, struct INetCfgBindingPath **Dst, unsigned __int32 *a4)
{
  unsigned __int32 v4; // ebx@1
  CImplIEnumNetCfgBindingPath *v5; // esi@1
  __int32 v6; // edi@3
  CBindPath *v7; // ecx@6
  struct INetCfgBindingPath **v9; // [sp+Ch] [bp-4h]@4

  v4 = 0;
  v5 = this;
  if ( Dst )
    memset(Dst, 0, 4 * a2);
  v6 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplIEnumNetCfgBindingPath *)((char *)v5 + 4), 0);
  if ( !v6 )
  {
    v9 = Dst;
    do
    {
      if ( v4 >= a2 )
        break;
      v7 = (CBindPath *)*((_DWORD *)v5 + 10);
      if ( v7 == *(CBindPath **)(*((_DWORD *)v5 + 9) + 12) )
        break;
      if ( CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll(v7) )
      {
        if ( Dst )
          v6 = CImplINetCfgBindingPath::HrCreateInstance(
                 *((struct CImplINetCfg **)v5 + 3),
                 *((const struct CBindPath **)v5 + 10),
                 v9);
        ++v4;
        ++v9;
      }
      *((_DWORD *)v5 + 10) += 20;
    }
    while ( !v6 );
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v5 + 3) + 24));
    v6 = HrFinishNextOrSkipContract(v6, v4, a2, (struct IUnknown **)Dst, a4);
  }
  return v6;
}

//----- (6E64FEDB) --------------------------------------------------------
int __stdcall CImplINetCfgBindingPath::HrCreateInstance(struct CImplINetCfg *a1, const struct CBindPath *a2, struct INetCfgBindingPath **a3)
{
  int v3; // eax@1
  int v4; // esi@2
  int v5; // eax@4
  int v6; // ebx@4
  size_t v7; // edi@4
  unsigned __int32 v8; // edi@6
  CComponent *v9; // eax@7
  signed int v10; // eax@7
  int v11; // eax@10
  void *v13; // eax@15
  int v14; // [sp+4h] [bp-4h]@1

  v14 = -2147024882;
  v3 = (int)operator new(0x38u);
  if ( v3 )
    v4 = ATL::CComObject<CImplINetCfgBindingPath>::CComObject<CImplINetCfgBindingPath>(v3, 0);
  else
    v4 = 0;
  if ( !v4 )
    return v14;
  v5 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)a2 + 4));
  v6 = v5;
  v7 = 4 * v5;
  if ( (unsigned int)(4 * v5) <= 0x20 )
  {
    *(_DWORD *)(v4 + 48) = v4 + 16;
    goto LABEL_6;
  }
  v13 = MemAlloc(4 * v5);
  *(_DWORD *)(v4 + 48) = v13;
  if ( v13 )
  {
LABEL_6:
    memset(*(void **)(v4 + 48), 0, v7);
    v8 = 0;
    if ( !v6 )
      goto LABEL_21;
    while ( 1 )
    {
      v9 = CBindPath::PGetComponentAtIndex(a2, v8);
      v10 = CComponent::HrGetINetCfgComponentInterface(
              v9,
              a1,
              (struct INetCfgComponent **)(*(_DWORD *)(v4 + 48) + 4 * v8++));
      v14 = v10;
      if ( v10 )
        break;
      if ( v8 >= v6 )
        goto LABEL_9;
    }
    ReleaseIUnknownArray(v8, *(struct IUnknown ***)(v4 + 48));
LABEL_9:
    if ( !v14 )
    {
LABEL_21:
      v11 = *(_DWORD *)v4;
      *(_DWORD *)(v4 + 52) = v6;
      v14 = (*(int (__stdcall **)(int, GUID *, struct INetCfgBindingPath **))v11)(v4, &IID_INetCfgBindingPath, a3);
      if ( !v14 )
      {
        CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v4 + 4), a1);
        return v14;
      }
    }
  }
  if ( *(_DWORD *)(v4 + 48) != v4 + 16 )
    MemFree(*(void **)(v4 + 48));
  operator delete((void *)v4);
  return v14;
}

//----- (6E64FFCD) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplINetCfgBindingPath>::CComObject<CImplINetCfgBindingPath>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgBindingPath>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E6431AC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgBindingPath>::`vftable')(CImplINetCfgBindingPath *, struct _GUID *, void **);

//----- (6E64FFFA) --------------------------------------------------------
__int32 __thiscall CNetConfigCore::HrCopyCore(CNetConfigCore *this, const struct CNetConfigCore *a2)
{
  CNetConfigCore *v2; // esi@1
  __int32 v3; // ebx@1

  v2 = this;
  v3 = CComponentList::HrCopyComponentList(this, a2);
  if ( v3
    || (v3 = CStackTable::HrCopyStackTable(
               (CNetConfigCore *)((char *)v2 + 20),
               (const struct CNetConfigCore *)((char *)a2 + 20))) != 0
    || (v3 = CBindingSet::HrCopyBindingSet(
               (CNetConfigCore *)((char *)v2 + 44),
               (const struct CNetConfigCore *)((char *)a2 + 44))) != 0 )
    CNetConfigCore::Clear(v2);
  return v3;
}

//----- (6E65004E) --------------------------------------------------------
__int32 __thiscall CBindingSet::HrCopyBindingSet(CBindingSet *this, const struct CBindingSet *a2)
{
  CBindingSet::operator=((void *)this, (int)a2);
  return 0;
}

//----- (6E65007A) --------------------------------------------------------
void *__thiscall CBindingSet::operator=(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::operator=((int)((char *)this + 4), a2 != 0 ? a2 + 4 : 0);
  return v2;
}

//----- (6E6500A5) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::operator=(int this, int a2)
{
  int v2; // esi@1
  int v3; // ebx@3
  int v4; // ebx@4
  void *v5; // eax@5
  int v6; // eax@6
  int v7; // eax@7
  void *v9; // eax@11
  int v10; // ebx@12

  v2 = this;
  if ( this != a2 )
  {
    if ( !std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(a2) )
    {
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear(v2);
      return v2;
    }
    v3 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(a2);
    if ( v3 <= (unsigned int)std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v2) )
    {
      v9 = std::copy<CBindPath *,CBindPath *>(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(void **)(v2 + 4));
      std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(v9, *(_DWORD *)(v2 + 8), v2);
      v7 = *(_DWORD *)(v2 + 4) + 20 * std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(a2);
      goto LABEL_8;
    }
    v4 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(a2);
    if ( v4 <= (unsigned int)std::vector<CBindPath,std::nc_allocator<CBindPath>>::capacity(v2) )
    {
      v10 = *(_DWORD *)(a2 + 4) + 20 * std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v2);
      std::copy<CBindPath *,CBindPath *>(*(_DWORD *)(a2 + 4), v10, *(void **)(v2 + 4));
      v7 = std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(
             v10,
             *(_DWORD *)(a2 + 8),
             *(_DWORD *)(v2 + 8),
             v2);
      goto LABEL_8;
    }
    v5 = *(void **)(v2 + 4);
    if ( v5 )
    {
      std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(v5, *(_DWORD *)(v2 + 8), v2);
      operator delete(*(void **)(v2 + 4));
    }
    v6 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(a2);
    if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy(v2, v6) )
    {
      v7 = std::_Uninitialized_copy<CBindPath *,CBindPath *,std::nc_allocator<CBindPath>>(
             *(_DWORD *)(a2 + 4),
             *(_DWORD *)(a2 + 8),
             *(_DWORD *)(v2 + 4),
             v2);
LABEL_8:
      *(_DWORD *)(v2 + 8) = v7;
      return v2;
    }
  }
  return v2;
}

//----- (6E650136) --------------------------------------------------------
__int32 __thiscall CStackTable::HrCopyStackTable(CStackTable *this, const struct CStackTable *a2)
{
  CStackTable::operator=((int)this, (int)a2);
  return 0;
}

//----- (6E650162) --------------------------------------------------------
int __thiscall CStackTable::operator=(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::operator=((void *)(this + 4), a2 != 0 ? a2 + 4 : 0);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
  return v2;
}

//----- (6E650195) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::operator=(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@3
  int v5; // ebx@4
  int v6; // eax@6
  int v7; // eax@7
  int v9; // ebx@12
  int v10; // [sp+10h] [bp+8h]@12

  v2 = a2;
  v3 = (int)this;
  if ( this != (void *)a2 )
  {
    if ( !std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(a2) )
    {
      std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::clear(v3);
      return v3;
    }
    v4 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(a2);
    if ( v4 <= (unsigned int)std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(v3) )
    {
      std::copy<CStackEntry *,CStackEntry *>(*(_DWORD *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(v3 + 4));
      v7 = *(_DWORD *)(v3 + 4) + 8 * std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(a2);
      goto LABEL_8;
    }
    v5 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(a2);
    if ( v5 <= (unsigned int)std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(v3) )
    {
      v9 = *(_DWORD *)(a2 + 4);
      v10 = v9 + 8 * std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(v3);
      std::copy<CStackEntry *,CStackEntry *>(v9, v10, *(_DWORD *)(v3 + 4));
      v7 = std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
             v10,
             *(_DWORD *)(v2 + 8),
             *(_DWORD *)(v3 + 8),
             v3);
      goto LABEL_8;
    }
    if ( *(_DWORD *)(v3 + 4) )
      operator delete(*(void **)(v3 + 4));
    v6 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(a2);
    if ( std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy(v3, v6) )
    {
      v7 = std::_Uninitialized_copy<CLanaEntry *,CLanaEntry *,std::nc_allocator<CLanaEntry>>(
             *(_DWORD *)(a2 + 4),
             *(_DWORD *)(a2 + 8),
             *(_DWORD *)(v3 + 4),
             v3);
LABEL_8:
      *(_DWORD *)(v3 + 8) = v7;
      return v3;
    }
  }
  return v3;
}

//----- (6E650226) --------------------------------------------------------
void __thiscall CBindingSet::Printf(void *this, int a2, char *a3)
{
  void *v3; // edi@1
  CBindPath *v4; // esi@3
  wchar_t *v5; // ecx@4
  unsigned __int32 v6; // [sp+8h] [bp-80Ch]@4
  int i; // [sp+Ch] [bp-808h]@3
  __int16 Dst[1024]; // [sp+10h] [bp-804h]@4

  v3 = this;
  if ( a3 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, a2, a3);
  v4 = (CBindPath *)*((_DWORD *)v3 + 2);
  for ( i = 1; v4 != *((CBindPath **)v3 + 3); ++i )
  {
    v5 = (wchar_t *)&Dst[swprintf_s((wchar_t *)Dst, 0x400u, L"%2i: ", i)];
    v6 = 1023 - wcslen((const unsigned __int16 *)Dst);
    if ( CBindPath::FGetPathToken(v4, v5, &v6) )
      CDiagContext::Printf((DWORD)g_pDiagCtx, a2, "%S\n", Dst);
    v4 = (CBindPath *)((char *)v4 + 20);
  }
}
// 6E650226: using guessed type wchar_t Dst[1024];

//----- (6E650321) --------------------------------------------------------
int swprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, ...)
{
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, Format);
  return vswprintf_s(Dst, SizeInWords, Format, va);
}

//----- (6E650342) --------------------------------------------------------
int __cdecl vswprintf_s(wchar_t *Dst, size_t SizeInWords, const wchar_t *Format, va_list ArgList)
{
  int result; // eax@4

  if ( !Dst || SizeInWords <= 0 || !Format )
  {
    *_errno() = 22;
LABEL_7:
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  result = _swoutput_s((char *)Dst, SizeInWords, (int)Format, (int)ArgList);
  if ( result >= 0 )
    return result;
  *Dst = 0;
  if ( result == -2 )
  {
    *_errno() = 34;
    goto LABEL_7;
  }
  return -1;
}

//----- (6E650389) --------------------------------------------------------
__int32 __thiscall CBindingSet::HrReserveRoomForBindPaths(CBindingSet *this, unsigned int a2)
{
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::reserve((int)((char *)this + 4), a2);
  return 0;
}

//----- (6E6503B8) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::reserve(int this, int a2)
{
  int v2; // esi@1
  int v3; // ebx@1
  int result; // eax@2
  int v5; // edi@3
  void *v6; // eax@3
  int v7; // [sp+24h] [bp+8h]@3

  v2 = this;
  v3 = a2;
  if ( (unsigned int)a2 > 0xCCCCCCC )
    std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
  result = std::vector<CBindPath,std::nc_allocator<CBindPath>>::capacity(this);
  if ( result < (unsigned int)a2 )
  {
    v7 = (int)std::_Allocate<CBindPath>(a2, 0);
    std::_Uninitialized_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(
      *(_DWORD *)(v2 + 4),
      *(_DWORD *)(v2 + 8),
      v7,
      v2);
    v5 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size(v2);
    v6 = *(void **)(v2 + 4);
    if ( v6 )
    {
      std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(v6, *(_DWORD *)(v2 + 8), v2);
      operator delete(*(void **)(v2 + 4));
    }
    result = v7;
    *(_DWORD *)(v2 + 12) = v7 + 20 * v3;
    *(_DWORD *)(v2 + 8) = v7 + 20 * v5;
    *(_DWORD *)(v2 + 4) = v7;
  }
  return result;
}

//----- (6E650435) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E650463) --------------------------------------------------------
int __stdcall std::_Uninit_copy<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath *,std::nc_allocator<CBindPath>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  while ( a1 != a2 )
  {
    std::_Construct<CBindPath,CBindPath>(a3, a1);
    a3 += 20;
    a1 += 20;
  }
  return a3;
}

//----- (6E650495) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Next(CImplIEnumNetCfgBindingInterface *this, unsigned __int32 a2, struct INetCfgBindingInterface **Dst, unsigned __int32 *a4)
{
  __int32 result; // eax@3

  if ( Dst && (a4 || a2 == 1) )
    result = CImplIEnumNetCfgBindingInterface::HrNextOrSkip(this, a2, Dst, a4);
  else
    result = -2147467261;
  return result;
}

//----- (6E6504CB) --------------------------------------------------------
__int32 __thiscall CImplIEnumNetCfgBindingInterface::HrNextOrSkip(CImplIEnumNetCfgBindingInterface *this, unsigned __int32 a2, struct INetCfgBindingInterface **Dst, unsigned __int32 *a4)
{
  struct INetCfgBindingInterface **v4; // ebx@1
  CImplIEnumNetCfgBindingInterface *v5; // esi@1
  __int32 v6; // edi@3
  int v7; // eax@6
  unsigned int v8; // ecx@6
  unsigned __int32 v10; // [sp+Ch] [bp-4h]@4

  v4 = Dst;
  v5 = this;
  if ( Dst )
    memset(Dst, 0, 4 * a2);
  v6 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplIEnumNetCfgBindingInterface *)((char *)v5 + 4), 0);
  if ( !v6 )
  {
    v10 = 0;
    do
    {
      if ( v10 >= a2 )
        break;
      v7 = *((_DWORD *)v5 + 4);
      v8 = *((_DWORD *)v5 + 5);
      if ( v8 >= *(_DWORD *)(v7 + 52) )
        break;
      if ( Dst )
        v6 = CImplINetCfgBindingInterface::HrCreateInstance(
               *((struct CImplINetCfg **)v5 + 3),
               *(struct IUnknown **)(*(_DWORD *)(v7 + 48) + 4 * v8 - 4),
               *(struct IUnknown **)(*(_DWORD *)(v7 + 48) + 4 * v8),
               v4);
      ++v10;
      ++v4;
      ++*((_DWORD *)v5 + 5);
    }
    while ( !v6 );
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v5 + 3) + 24));
    v6 = HrFinishNextOrSkipContract(v6, v10, a2, (struct IUnknown **)Dst, a4);
  }
  return v6;
}

//----- (6E65056D) --------------------------------------------------------
int __stdcall CImplINetCfgBindingInterface::HrCreateInstance(struct CImplINetCfg *a1, struct IUnknown *a2, struct IUnknown *a3, struct INetCfgBindingInterface **a4)
{
  int v4; // eax@1
  int v5; // esi@2
  int v6; // eax@4
  int v8; // [sp+4h] [bp-4h]@1

  v8 = -2147024882;
  v4 = (int)operator new(0x18u);
  if ( v4 )
    v5 = ATL::CComObject<CImplINetCfgBindingInterface>::CComObject<CImplINetCfgBindingInterface>(v4, 0);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = *(_DWORD *)v5;
    *(_DWORD *)(v5 + 16) = a2;
    *(_DWORD *)(v5 + 20) = a3;
    v8 = (*(int (__stdcall **)(int, GUID *, struct INetCfgBindingInterface **))v6)(v5, &IID_INetCfgBindingInterface, a4);
    if ( v8 )
    {
      operator delete((void *)v5);
    }
    else
    {
      AddRefObj(a2);
      AddRefObj(a3);
      CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v5 + 4), a1);
    }
  }
  return v8;
}

//----- (6E6505F9) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplINetCfgBindingInterface>::CComObject<CImplINetCfgBindingInterface>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgBindingInterface>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643194: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgBindingInterface>::`vftable')(CImplINetCfgBindingInterface *, struct _GUID *, void **);

//----- (6E650626) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::QueryInterface(CImplIEnumNetCfgBindingInterface *a1, struct _GUID *a2, void **a3)
{
  return CImplIEnumNetCfgBindingInterface::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E650679) --------------------------------------------------------
int __stdcall CImplIEnumNetCfgBindingInterface::HrCreateInstance(struct CImplINetCfg *a1, struct IUnknown *a2, struct IEnumNetCfgBindingInterface **a3)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // esi@2
  int v6; // eax@4

  v3 = -2147024882;
  v4 = (int)operator new(0x18u);
  if ( v4 )
    v5 = ATL::CComObject<CImplIEnumNetCfgBindingInterface>::CComObject<CImplIEnumNetCfgBindingInterface>(v4, 0);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = *(_DWORD *)v5;
    *(_DWORD *)(v5 + 16) = a2;
    v3 = (*(int (__stdcall **)(int, GUID *, struct IEnumNetCfgBindingInterface **))v6)(
           v5,
           &IID_IEnumNetCfgBindingInterface,
           a3);
    if ( v3 )
    {
      operator delete((void *)v5);
    }
    else
    {
      AddRefObj(a2);
      CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v5 + 4), a1);
    }
  }
  return v3;
}

//----- (6E6506F1) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::CComObject<CImplIEnumNetCfgBindingInterface>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 1;
  *(_DWORD *)this = &ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643140: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`vftable')(CImplIEnumNetCfgBindingInterface *, struct _GUID *, void **);

//----- (6E650758) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplIEnumNetCfgBindingInterface>::~CComObject<CImplIEnumNetCfgBindingInterface>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65077E) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplIEnumNetCfgBindingInterface>::~CComObject<CImplIEnumNetCfgBindingInterface>(int this)
{
  *(_DWORD *)this = &ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  CImplIEnumNetCfgBindingInterface::FinalRelease((CImplIEnumNetCfgBindingInterface *)this);
  return InterlockedDecrement(&Addend);
}
// 6E643140: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingInterface>::`vftable')(CImplIEnumNetCfgBindingInterface *, struct _GUID *, void **);

//----- (6E6507A1) --------------------------------------------------------
void __thiscall CImplIEnumNetCfgBindingInterface::FinalRelease(CImplIEnumNetCfgBindingInterface *this)
{
  CImplIEnumNetCfgBindingInterface *v1; // esi@1

  v1 = this;
  ReleaseObj(*((struct IUnknown **)this + 4));
  ReleaseObj(*((struct IUnknown **)v1 + 3));
}

//----- (6E6507BD) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::EnumBindingPaths(struct IUnknown *this, unsigned __int32 a2, struct IEnumNetCfgBindingPath **a3)
{
  struct IUnknown *v3; // esi@3
  CImplINetCfgComponent *v4; // ecx@3
  signed int v5; // edi@3
  CNetConfigCore *v6; // ecx@5
  int v7; // eax@6
  const struct CComponent *v9; // [sp-14h] [bp-18h]@5
  struct CBindingSet *v10; // [sp-Ch] [bp-10h]@5

  if ( a2 != 1 && a2 != 2 )
  {
    v5 = -2147024809;
  }
  else
  {
    v3 = this;
    v4 = (CImplINetCfgComponent *)&this[-1];
    *a3 = 0;
    v5 = CImplINetCfgComponent::HrLockAndTestForValidInterface(v4, 0, 0, 0);
    if ( !v5 )
    {
      v5 = CImplIEnumNetCfgBindingPath::HrCreateInstance(
             (struct CImplINetCfg *)v3[5].lpVtbl,
             0,
             1,
             (struct CImplIEnumNetCfgBindingPath **)&this);
      if ( !v5 )
      {
        v10 = (struct CBindingSet *)&this[4];
        v6 = (CNetConfigCore *)v3[5].lpVtbl[4].QueryInterface;
        v9 = (const struct CComponent *)v3[6].lpVtbl;
        if ( a2 == 1 )
          v7 = CNetConfigCore::HrGetBindingsInvolvingComponent(v6, v9, 0, v10);
        else
          v7 = CNetConfigCore::HrGetComponentBindings(v6, v9, 0, v10);
        v5 = v7;
        if ( !v7 )
        {
          v5 = this->lpVtbl[1].Release(this);
          AddRefObj(this);
          *a3 = (struct IEnumNetCfgBindingPath *)this;
        }
        ReleaseObj(this);
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&v3[5].lpVtbl[2]);
    }
  }
  return v5;
}

//----- (6E650869) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingPath::HrCreateInstance(struct CImplINetCfg *a1, const struct CBindingSet *lpMem, char a3, struct CImplIEnumNetCfgBindingPath **a4)
{
  __int32 v4; // ebx@1
  int v5; // ecx@1
  int v6; // esi@2

  v4 = -2147024882;
  v5 = (int)operator new(0x2Cu);
  if ( v5 )
    v6 = ATL::CComObject<CImplIEnumNetCfgBindingPath>::CComObject<CImplIEnumNetCfgBindingPath>(v5, 0);
  else
    v6 = 0;
  if ( v6 )
  {
    v4 = 0;
    if ( a3 & 4 )
    {
      *(_DWORD *)(v6 + 36) = lpMem;
      *(_DWORD *)(v6 + 40) = *((_DWORD *)lpMem + 2);
LABEL_8:
      v4 = 0;
      CImplINetCfgHolder::HoldINetCfg((CImplINetCfgHolder *)(v6 + 4), a1);
      AddRefObj((struct IUnknown *)v6);
      *a4 = (struct CImplIEnumNetCfgBindingPath *)v6;
      return v4;
    }
    if ( a3 & 2 )
    {
      v4 = CBindingSet::HrCopyBindingSet((CBindingSet *)(v6 + 16), lpMem);
      *(_DWORD *)(v6 + 36) = v6 + 16;
    }
    else
    {
      *(_DWORD *)(v6 + 36) = v6 + 16;
    }
    *(_DWORD *)(v6 + 40) = *(_DWORD *)(v6 + 24);
    if ( !v4 )
      goto LABEL_8;
    CImplIEnumNetCfgBindingPath::`scalar deleting destructor'((void *)v6, 1);
  }
  if ( a3 & 4 && lpMem )
    CBindingSet::`scalar deleting destructor'((void *)lpMem, 1);
  return v4;
}

//----- (6E650901) --------------------------------------------------------
int __thiscall ATL::CComObject<CImplIEnumNetCfgBindingPath>::CComObject<CImplIEnumNetCfgBindingPath>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  CImplIEnumNetCfgBindingPath::CImplIEnumNetCfgBindingPath(this);
  *(_DWORD *)v2 = &ATL::CComObject<CImplIEnumNetCfgBindingPath>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643178: using guessed type int (__stdcall *ATL::CComObject<CImplIEnumNetCfgBindingPath>::`vftable')(CImplIEnumNetCfgBindingPath *, struct _GUID *, void **);

//----- (6E650927) --------------------------------------------------------
int __thiscall CImplIEnumNetCfgBindingPath::CImplIEnumNetCfgBindingPath(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  CBindingSet::CBindingSet((void *)(this + 16));
  *(_DWORD *)(v1 + 36) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  return v1;
}

//----- (6E65094D) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::OpenParamKey(CImplINetCfgComponent *this, HKEY hKey)
{
  HKEY *v2; // ebx@1
  signed int v3; // edi@1
  int v4; // edi@2
  __int32 v5; // eax@4
  DWORD dwDisposition; // [sp+Ch] [bp-4h]@6

  v2 = (HKEY *)hKey;
  *(_DWORD *)hKey = 0;
  v3 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 4u, 0, 0);
  if ( !v3 )
  {
    v4 = *((_DWORD *)this + 7);
    if ( FIsConsideredNetClass(*(_DWORD *)(v4 + 16)) )
    {
      v3 = CComponent::HrOpenInstanceKey((CComponent *)v4, 0x2001Fu, v2, 0, 0);
    }
    else
    {
      if ( *(_DWORD *)(v4 + 48) )
        v5 = CComponent::HrOpenServiceKey((CComponent *)v4, 0x2001Du, &hKey);
      else
        v5 = CComponent::HrOpenInstanceKey((CComponent *)v4, 0x2001Du, &hKey, 0, 0);
      v3 = v5;
      if ( !v5 )
      {
        v3 = HrRegCreateKeyEx(hKey, L"Parameters", 0, 0x2001Fu, 0, v2, &dwDisposition);
        RegCloseKey(hKey);
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 6) + 24));
  }
  return v3;
}

//----- (6E6509FF) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingInterface::GetName(CImplINetCfgBindingInterface *this, unsigned __int16 **a2)
{
  unsigned __int16 **v2; // ebx@1
  CImplINetCfgBindingInterface *v3; // esi@1
  signed int v4; // edi@1

  v2 = a2;
  *a2 = 0;
  v3 = this;
  v4 = CImplINetCfgBindingInterface::HrLockAndTestForValidInterface(this, 4u);
  if ( !v4 )
  {
    if ( CComponent::FCanDirectlyBindTo(
           *(CComponent **)(*((_DWORD *)v3 + 4) + 28),
           *(const struct CComponent **)(*((_DWORD *)v3 + 5) + 28),
           0,
           (const unsigned __int16 **)&this,
           (unsigned __int32 *)&a2) )
      v4 = HrCoTaskMemAllocAndDupSzLen((const unsigned __int16 *)this, (unsigned __int32)a2, v2, 0x1000u);
    else
      v4 = -2147418113;
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v3 + 3) + 24));
  }
  return v4;
}

//----- (6E650A73) --------------------------------------------------------
int __thiscall CComponent::FCanDirectlyBindTo(CComponent *this, const struct CComponent *a2, char a3, const unsigned __int16 **a4, unsigned __int32 *a5)
{
  const struct CComponent *v5; // esi@1
  CComponent *v6; // ebx@1
  const unsigned __int16 *v7; // esi@3
  const unsigned __int16 *v8; // eax@3
  const unsigned __int16 *v9; // ebx@4
  int result; // eax@6
  struct _GUID v11; // ST00_16@10
  int v12; // eax@11
  const WCHAR *v13; // ecx@20
  const unsigned __int16 v14; // dx@25
  const WCHAR v15; // si@26
  const WCHAR *i; // edx@26
  struct _GUID v17; // ST00_16@33

  v5 = a2;
  v6 = this;
  if ( *((_DWORD *)this + 6) & 0x40400 && FIsConsideredNetClass(*((_DWORD *)a2 + 4)) )
  {
    if ( a3 )
    {
      *(_QWORD *)&v11.Data1 = *(_QWORD *)a2;
      *(_QWORD *)&v11.Data4[0] = *((_QWORD *)a2 + 1);
      if ( FIsIscsiNicFromNdisNsi(v11) )
      {
        v12 = *((_DWORD *)v6 + 6);
        if ( v12 & 0x400 || v12 & 0x40000 && (**((_DWORD **)v6 + 17) != 1 || **((_DWORD **)v6 + 18) == 1) )
          return 0;
      }
      v5 = a2;
    }
    result = CComponent::FCanDirectlyBindToFilter(
               v5,
               *((const unsigned __int16 *const *)v6 + 23),
               *((const unsigned __int16 *const *)v6 + 22));
    if ( result && a4 && a5 )
    {
      v13 = (const WCHAR *)*((_DWORD *)v5 + 21);
      if ( !v13 )
        v13 = &String;
      while ( 1 )
      {
        v14 = *v13;
        if ( !*v13 || v14 != 32 && v14 != 44 )
          break;
        ++v13;
      }
      v15 = *v13;
      for ( i = v13; *i; v15 = *i )
      {
        if ( v15 == 32 )
          break;
        if ( v15 == 44 )
          break;
        ++i;
      }
      *a4 = v13;
      *a5 = i - v13;
    }
  }
  else
  {
    if ( a3 && FIsConsideredNetClass(*((_DWORD *)a2 + 4)) && *((_DWORD *)v6 + 4) == 2 )
    {
      *(_QWORD *)&v17.Data1 = *(_QWORD *)a2;
      *(_QWORD *)&v17.Data4[0] = *((_QWORD *)a2 + 1);
      if ( FIsIscsiNicFromNdisNsi(v17) && !FIsIsciSupportedProtocol(*((const unsigned __int16 **)v6 + 25)) )
        return 0;
      v5 = a2;
    }
    v7 = (const unsigned __int16 *)*((_DWORD *)v5 + 21);
    v8 = &String;
    if ( !v7 )
      v7 = &String;
    v9 = (const unsigned __int16 *)*((_DWORD *)v6 + 20);
    if ( v9 )
      v8 = v9;
    result = FSubstringMatch(v8, v7, a4, a5);
  }
  return result;
}

//----- (6E650AC9) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingInterface::GetLowerComponent(CImplINetCfgBindingInterface *this, struct INetCfgComponent **a2)
{
  signed int v2; // ebx@1

  *a2 = 0;
  v2 = CImplINetCfgBindingInterface::HrLockAndTestForValidInterface(this, 0);
  if ( !v2 )
  {
    AddRefObj(*((struct IUnknown **)this + 5));
    *a2 = (struct INetCfgComponent *)*((_DWORD *)this + 5);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v2;
}

//----- (6E650B11) --------------------------------------------------------
signed int __thiscall CImplINetCfgBindingInterface::HrLockAndTestForValidInterface(CImplINetCfgBindingInterface *this, unsigned __int32 a2)
{
  CImplINetCfgBindingInterface *v2; // esi@1
  signed int v3; // edi@1

  v2 = this;
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  v3 = CImplINetCfgComponent::HrIsValidInterface(*((CImplINetCfgComponent **)v2 + 4), a2);
  if ( v3 || (v3 = CImplINetCfgComponent::HrIsValidInterface(*((CImplINetCfgComponent **)v2 + 5), a2)) != 0 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v2 + 3) + 24));
  return v3;
}

//----- (6E650B5E) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::EnumBindingInterfaces(struct IUnknown *this, struct IEnumNetCfgBindingInterface **a2)
{
  signed int v2; // ebx@1

  *a2 = 0;
  v2 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface((CImplINetCfgBindingPath *)this, 0, 0);
  if ( !v2 )
  {
    v2 = CImplIEnumNetCfgBindingInterface::HrCreateInstance((struct CImplINetCfg *)this[3].lpVtbl, this, a2);
    LeaveCriticalSection((LPCRITICAL_SECTION)&this[3].lpVtbl[2]);
  }
  return v2;
}

//----- (6E650BA6) --------------------------------------------------------
signed int __thiscall CImplINetCfgBindingPath::HrLockAndTestForValidInterface(CImplINetCfgBindingPath *this, unsigned __int32 a2, struct CBindPath *a3)
{
  CImplINetCfgBindingPath *v3; // esi@1
  signed int v4; // edi@1

  v3 = this;
  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  v4 = CImplINetCfgBindingPath::HrIsValidInterface(v3, a2, a3);
  if ( v4 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v3 + 3) + 24));
  return v4;
}

//----- (6E650BE0) --------------------------------------------------------
signed int __thiscall CImplINetCfgBindingPath::HrIsValidInterface(CImplINetCfgBindingPath *this, unsigned __int32 a2, struct CBindPath *a3)
{
  CImplINetCfgBindingPath *v3; // esi@1
  signed int result; // eax@1
  unsigned int v5; // ebx@1
  int v6; // edi@5

  v3 = this;
  result = CImplINetCfg::HrIsValidInterface(*((CImplINetCfg **)this + 3), a2);
  v5 = 0;
  if ( !result )
  {
    if ( a3 )
    {
      result = CBindPath::HrReserveRoomForComponents(a3, *((_DWORD *)v3 + 13));
      if ( !result && *((_DWORD *)v3 + 13) > 0u )
      {
        while ( 1 )
        {
          v6 = *(_DWORD *)(*((_DWORD *)v3 + 12) + 4 * v5);
          if ( !v6 )
            break;
          result = CImplINetCfgComponent::HrIsValidInterface((CImplINetCfgComponent *)v6, 0);
          if ( !result )
          {
            result = CBindPath::HrAppendComponent(a3, *(const struct CComponent **)(v6 + 28));
            if ( !result )
            {
              ++v5;
              if ( v5 < *((_DWORD *)v3 + 13) )
                continue;
            }
          }
          return result;
        }
        result = -2147024882;
      }
    }
  }
  return result;
}

//----- (6E650C52) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgBindingInterface>::QueryInterface(CImplINetCfgBindingInterface *a1, struct _GUID *a2, void **a3)
{
  return CImplINetCfgBindingInterface::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E650CA5) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgBindingPath>::QueryInterface(CImplINetCfgBindingPath *a1, struct _GUID *a2, void **a3)
{
  return CImplINetCfgBindingPath::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E650D2D) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfgBindingInterface>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplINetCfgBindingInterface>::~CComObject<CImplINetCfgBindingInterface>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E650D53) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplINetCfgBindingInterface>::~CComObject<CImplINetCfgBindingInterface>(int this)
{
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgBindingInterface>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  CImplINetCfgBindingInterface::FinalRelease((CImplINetCfgBindingInterface *)this);
  return InterlockedDecrement(&Addend);
}
// 6E643194: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgBindingInterface>::`vftable')(CImplINetCfgBindingInterface *, struct _GUID *, void **);

//----- (6E650D76) --------------------------------------------------------
void __thiscall CImplINetCfgBindingInterface::FinalRelease(CImplINetCfgBindingInterface *this)
{
  CImplINetCfgBindingInterface *v1; // esi@1

  v1 = this;
  ReleaseObj(*((struct IUnknown **)this + 4));
  ReleaseObj(*((struct IUnknown **)v1 + 5));
  ReleaseObj(*((struct IUnknown **)v1 + 3));
}

//----- (6E650DCE) --------------------------------------------------------
void *__thiscall ATL::CComObject<CImplINetCfgBindingPath>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CImplINetCfgBindingPath>::~CComObject<CImplINetCfgBindingPath>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E650DF4) --------------------------------------------------------
LONG __thiscall ATL::CComObject<CImplINetCfgBindingPath>::~CComObject<CImplINetCfgBindingPath>(int this)
{
  *(_DWORD *)this = &ATL::CComObject<CImplINetCfgBindingPath>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  CImplINetCfgBindingPath::FinalRelease((CImplINetCfgBindingPath *)this);
  return InterlockedDecrement(&Addend);
}
// 6E6431AC: using guessed type int (__stdcall *ATL::CComObject<CImplINetCfgBindingPath>::`vftable')(CImplINetCfgBindingPath *, struct _GUID *, void **);

//----- (6E650E17) --------------------------------------------------------
void __thiscall CImplINetCfgBindingPath::FinalRelease(CImplINetCfgBindingPath *this)
{
  CImplINetCfgBindingPath *v1; // esi@1

  v1 = this;
  ReleaseIUnknownArray(*((_DWORD *)this + 13), *((struct IUnknown ***)this + 12));
  if ( *((CImplINetCfgBindingPath **)v1 + 12) != (CImplINetCfgBindingPath *)((char *)v1 + 16) )
    MemFree(*((void **)v1 + 12));
  ReleaseObj(*((struct IUnknown **)v1 + 3));
}

//----- (6E650E44) --------------------------------------------------------
__int32 __thiscall CFilterDevices::HrPrepare(CFilterDevices *this)
{
  CFilterDevices *v1; // esi@1
  __int32 v2; // edi@1
  unsigned __int32 v3; // ecx@3
  HKEY hKey; // [sp+8h] [bp-4h]@3

  v1 = this;
  v2 = CBindPath::HrReserveRoomForComponents((CFilterDevices *)((char *)this + 20), 8u);
  if ( !v2 )
  {
    v2 = CBindingSet::HrReserveRoomForBindPaths((CFilterDevices *)((char *)v1 + 48), 8u);
    if ( !v2 )
    {
      v2 = HrOpenNetworkKey(0x20019u, &hKey);
      if ( !v2 )
      {
        v2 = HrRegGetMultiSzWithAlloc(v3, hKey, L"FilterClasses", (unsigned __int16 **)v1 + 11);
        if ( v2 == -2147024894 )
          v2 = 0;
        RegCloseKey(hKey);
      }
    }
  }
  return v2;
}

//----- (6E650EB5) --------------------------------------------------------
__int32 __thiscall HrRegGetMultiSzWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int16 **a4)
{
  return HrRegGetTypeWithAlloc(this, a2, lpMem, 7u, (unsigned __int8 **)a4, 0);
}

//----- (6E650ED5) --------------------------------------------------------
int __thiscall CFilteredAdapters::CFilteredAdapters(int this, CModifyContext *a2, int a3)
{
  int v3; // esi@1

  v3 = this;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(this, 0);
  *(_DWORD *)(v3 + 20) = (char *)a2 + 196;
  *(_DWORD *)(v3 + 16) = CModifyContext::PNetConfig(a2);
  *(_DWORD *)(v3 + 24) = a3;
  *(_DWORD *)(v3 + 28) = (char *)a2 + 148;
  *(_DWORD *)(v3 + 32) = (char *)a2 + 164;
  return v3;
}

//----- (6E650F2E) --------------------------------------------------------
struct CNetConfig *__thiscall CModifyContext::PNetConfig(CModifyContext *this)
{
  return (struct CNetConfig *)((char *)this - 72);
}

//----- (6E650F37) --------------------------------------------------------
int __thiscall CFilterMapEntry::CFilterMapEntry(int this, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1

  v5 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)a3;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(this + 20) = a5;
  *(_DWORD *)(this + 24) = a4;
  std::vector<CIndex,std::nc_allocator<CIndex>>::_Buy(this + 28, 0);
  *(_DWORD *)(v5 + 44) = 0;
  *(_DWORD *)(v5 + 48) = 0;
  *(_DWORD *)(v5 + 52) = 0;
  return v5;
}

//----- (6E650F7E) --------------------------------------------------------
char __thiscall std::vector<CIndex,std::nc_allocator<CIndex>>::_Buy(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  void *v4; // eax@6

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  if ( a2 )
  {
    if ( (unsigned int)a2 > 0xFFFFFFF )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v4 = std::_Allocate<CIndex>(a2, 0);
    *(_DWORD *)(v2 + 4) = v4;
    *(_DWORD *)(v2 + 8) = v4;
    *(_DWORD *)(v2 + 12) = (char *)v4 + 16 * a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E650FAA) --------------------------------------------------------
__int32 __stdcall CMSClient::Initialize(CMSClient *this, struct IUnknown *a2, struct INetCfg *a3, struct INetCfgBindingPath *a4)
{
  int v4; // eax@2
  int v5; // esi@2
  bool v6; // sf@3
  struct IUnknown *v8; // [sp+4h] [bp-4h]@1

  v8 = 0;
  if ( !CMSClient::SysQueryBindingPath((CMSClient *)a2, (unsigned __int32)a3, a4) )
  {
    *((_DWORD *)this + 32) = a2;
    *((_DWORD *)this + 33) = a3;
    AddRefObj(a2);
    AddRefObj(*((struct IUnknown **)this + 33));
    v4 = (*(int (__stdcall **)(_DWORD, _DWORD, struct IUnknown **))(**((_DWORD **)this + 33) + 32))(
           *((_DWORD *)this + 33),
           L"ms_server",
           &v8);
    v5 = v4;
    if ( v4 == 1 )
    {
      *((_DWORD *)this + 40) = 2;
    }
    else
    {
      v6 = v4 < 0;
      if ( !v4 )
      {
        ReleaseObj(v8);
        v6 = 0;
      }
      if ( v6 )
        return v5;
    }
    return CMSClient::HrGetBrowserRegistryInfo(this);
  }
  return -2147024809;
}

//----- (6E651032) --------------------------------------------------------
__int32 __thiscall CMSClient::HrGetBrowserRegistryInfo(CMSClient *this)
{
  CMSClient *v1; // esi@1
  __int32 v2; // eax@1
  unsigned __int32 v3; // ecx@1
  __int32 v4; // edi@1
  __int32 v5; // eax@3
  int v6; // esi@4
  void *v8; // eax@10
  HKEY phkResult; // [sp+Ch] [bp-4h]@1

  phkResult = 0;
  v1 = this;
  v2 = HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
         0x20019u,
         &phkResult);
  v4 = v2;
  if ( v2 < 0 )
  {
    if ( v2 != -2147024894 )
      goto LABEL_5;
    v4 = 0;
  }
  if ( phkResult )
  {
    v5 = HrRegGetMultiSzWithAlloc(v3, phkResult, L"OtherDomains", (unsigned __int16 **)v1 + 42);
    v4 = v5;
    if ( v5 < 0 )
    {
      if ( v5 != -2147024894 )
        goto LABEL_5;
      v4 = 0;
    }
  }
  v6 = (int)((char *)v1 + 168);
  if ( !*(_DWORD *)v6 )
  {
    v8 = operator new(2u);
    *(_DWORD *)v6 = v8;
    if ( v8 )
      *(_WORD *)v8 = 0;
  }
LABEL_5:
  RegSafeCloseKey(phkResult);
  return v4;
}

//----- (6E6510CD) --------------------------------------------------------
signed int __stdcall CMSClient::GetSupportedNotifications(CMSClient *this, unsigned __int32 *a2)
{
  signed int result; // eax@2

  if ( FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(a2) )
  {
    result = -2147024809;
  }
  else
  {
    *a2 = 655411;
    result = 0;
  }
  return result;
}

//----- (6E65110C) --------------------------------------------------------
__int32 __thiscall CSrvrcfg::HrOpenRegKeys(CSrvrcfg *this, struct INetCfg *a2)
{
  return HrRegOpenKeyBestAccess(
           HKEY_LOCAL_MACHINE,
           L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
           (PHKEY)this + 16);
}

//----- (6E6511B5) --------------------------------------------------------
__int32 __stdcall HrRegOpenKeyBestAccess(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
{
  __int32 result; // eax@1

  result = RegOpenKeyExW(hKey, lpSubKey, 0, 0xF003Fu, phkResult);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  if ( result == -2147024891 )
  {
    result = RegOpenKeyExW(hKey, lpSubKey, 0, 0x3001Fu, phkResult);
    if ( result > 0 )
      result = (unsigned __int16)result | 0x80070000;
    if ( result == -2147024891 )
    {
      result = RegOpenKeyExW(hKey, lpSubKey, 0, 0x2001Fu, phkResult);
      if ( result > 0 )
        result = (unsigned __int16)result | 0x80070000;
      if ( result == -2147024891 )
      {
        result = RegOpenKeyExW(hKey, lpSubKey, 0, 0x20019u, phkResult);
        if ( result > 0 )
          result = (unsigned __int16)result | 0x80070000;
        if ( result == -2147024891 )
        {
          result = RegOpenKeyExW(hKey, lpSubKey, 0, 0x20001u, phkResult);
          if ( result > 0 )
            result = (unsigned __int16)result | 0x80070000;
        }
      }
    }
  }
  if ( result < 0 )
    *phkResult = 0;
  return result;
}

//----- (6E651206) --------------------------------------------------------
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfg>::AddRef(a1 - 4);
}
// 6E643244: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfg>::AddRef(_DWORD);

//----- (6E651215) --------------------------------------------------------
__int32 __stdcall HrRegCreateKeyWithWorldAccess(HKEY hKey, LPCWSTR lpSubKey, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition)
{
  __int32 v6; // esi@3
  int v8; // [sp+4h] [bp-10h]@1
  void *v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  void *lpMem; // [sp+10h] [bp-4h]@1

  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ( !HrAllocateSecurityDescriptorAllowAccessToWorld(&lpMem) )
  {
    v10 = 0;
    v8 = 12;
    v9 = lpMem;
  }
  v6 = HrRegCreateKeyEx(
         hKey,
         lpSubKey,
         dwOptions,
         samDesired,
         (LPSECURITY_ATTRIBUTES)(lpMem != 0 ? (unsigned int)&v8 : 0),
         phkResult,
         lpdwDisposition);
  MemFree(lpMem);
  return v6;
}

//----- (6E651287) --------------------------------------------------------
__int32 __thiscall CNetConfig::HrEnsureExternalDataLoadedForAllComponents(CNetConfig *this)
{
  CNetConfig *v1; // edi@1
  SP_LOG_TOKEN v2; // rax@1
  int v3; // ebx@1
  int v4; // esi@2
  __int32 v5; // eax@2
  int v7; // eax@9
  int v8; // eax@14
  SP_LOG_TOKEN LogToken; // [sp+8h] [bp-Ch]@1
  __int32 v10; // [sp+10h] [bp-4h]@1

  v1 = this;
  v2 = SetupGetThreadLogToken();
  v3 = *((_DWORD *)v1 + 2);
  v10 = 0;
  LogToken = v2;
  while ( v3 != *((_DWORD *)v1 + 3) )
  {
    v4 = *(_DWORD *)v3;
    v5 = CExternalComponentData::HrEnsureExternalDataLoaded((CExternalComponentData *)(*(_DWORD *)v3 + 36));
    if ( v5 == -2146500085 || v5 == -2146500092 || v5 == -2147024894 )
    {
      v7 = *(_DWORD *)(v4 + 32);
      if ( !v7 )
        v7 = *(_DWORD *)(v4 + 28);
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Removing %s from the core because its external data is missing\n", v7);
      v8 = *(_DWORD *)(v4 + 32);
      if ( !v8 )
        v8 = *(_DWORD *)(v4 + 28);
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!!! NCI: Removing %ws from core because its external data is missing",
        v8);
      CNetConfigCore::RemoveComponentFromCore(v1, (const struct CComponent *)v4);
      HrCiRemoveComponent((CComponent *)v4, 0);
      CComponent::`scalar deleting destructor'((void *)v4, 1);
    }
    else
    {
      if ( v5 && !v10 )
        v10 = v5;
      v3 += 4;
    }
  }
  return v10;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E65130C) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgComponent::Reset(CImplIEnumNetCfgComponent *this)
{
  int v1; // eax@1

  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  v1 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 4) = 0;
  LeaveCriticalSection((LPCRITICAL_SECTION)(v1 + 24));
  return 0;
}

//----- (6E6513E6) --------------------------------------------------------
int __stdcall FIsUserAdmin()
{
  return FCheckGroupMembership(0x220u, 0);
}

//----- (6E6513F8) --------------------------------------------------------
CAutoImpersonate *__thiscall CAutoImpersonate::CAutoImpersonate(CAutoImpersonate *this)
{
  CAutoImpersonate *result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 1) = 1;
  return result;
}

//----- (6E65140E) --------------------------------------------------------
int __thiscall CAutoImpersonate::ShouldRevertImpersonation(CAutoImpersonate *this)
{
  int result; // eax@1

  result = 0;
  JUMPOUT(*((_DWORD *)this + 3), 0, nullsub_5);
  if ( !*((_DWORD *)this + 2) )
  {
    if ( *(_DWORD *)this )
      result = 1;
  }
  return result;
}
// 6E65BBFF: using guessed type int nullsub_5();

//----- (6E65147E) --------------------------------------------------------
signed int __stdcall HrSetupLoadIndirectStringWithAlloc(unsigned __int16 *a1, unsigned __int16 **a2)
{
  int v2; // ebx@8
  void *v3; // eax@8
  void **v4; // esi@1
  int i; // eax@2
  char v7; // [sp+Ch] [bp-24h]@1
  int v8; // [sp+1Ch] [bp-14h]@3
  int v9; // [sp+20h] [bp-10h]@2
  int v10; // [sp+2Ch] [bp-4h]@1
  signed int v11; // [sp+3Ch] [bp+Ch]@1

  v4 = (void **)a2;
  *a2 = 0;
  CAutoImpersonate::CAutoImpersonate((CAutoImpersonate *)&v7);
  v10 = 0;
  v11 = CAutoImpersonate::CheckPoint((CAutoImpersonate *)&v7, 0);
  if ( v11 >= 0 )
  {
    for ( i = pSetupLoadIndirectString(a1, *v4, 0, &v9); ; i = pSetupLoadIndirectString(a1, *v4, v2, &v9) )
    {
      v8 = i;
      if ( i || GetLastError() != 122 )
        break;
      operator delete(*v4);
      v2 = v9;
      v3 = operator new(2 * v9);
      *v4 = v3;
      if ( !v3 )
      {
        v11 = -2147024882;
        break;
      }
    }
    if ( v11 >= 0 && !v8 )
    {
      operator delete(*v4);
      *v4 = 0;
      v11 = HrFromLastWin32Error();
    }
  }
  v10 = -1;
  CAutoImpersonate::~CAutoImpersonate((CAutoImpersonate *)&v7);
  return v11;
}
// 6E65142C: using guessed type int __stdcall pSetupLoadIndirectString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (6E6514F0) --------------------------------------------------------
HRESULT __thiscall CAutoImpersonate::~CAutoImpersonate(CAutoImpersonate *this)
{
  CAutoImpersonate *v1; // esi@1
  CAutoImpersonate *v2; // ecx@1
  HRESULT result; // eax@2

  v1 = this;
  if ( CAutoImpersonate::ShouldRevertImpersonation(this) )
  {
    result = CoRevertToSelf();
  }
  else
  {
    result = CAutoImpersonate::ShouldRecoverLostImpersonation(v2);
    if ( result )
      result = CAutoImpersonate::RecoverLostImpersonation(v1);
  }
  return result;
}

//----- (6E651516) --------------------------------------------------------
BOOL __thiscall CAutoImpersonate::ShouldRecoverLostImpersonation(CAutoImpersonate *this)
{
  CAutoImpersonate *v1; // esi@1
  int v3; // [sp+4h] [bp-4h]@2

  v1 = this;
  return *((_DWORD *)this + 3)
      && CAutoImpersonate::IsImpersonating(&v3) >= 0
      && *((_DWORD *)v1 + 2)
      && !v3
      && *((_DWORD *)v1 + 1);
}

//----- (6E651630) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::IsBoundTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2)
{
  signed int v2; // ebx@1
  const struct CComponent *v3; // edi@2
  CComponentList *v4; // edi@4
  char v6; // [sp+8h] [bp-14h]@3
  int v7; // [sp+Ch] [bp-10h]@3
  CComponentList *v8; // [sp+10h] [bp-Ch]@4
  CComponentList *v9; // [sp+14h] [bp-8h]@5

  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(
         (CImplINetCfgComponent *)((char *)this - 4),
         4u,
         a2,
         (struct CComponent **)&a2);
  if ( !v2 )
  {
    v3 = (const struct CComponent *)*((_DWORD *)this + 6);
    v2 = 1;
    if ( (struct INetCfgComponent *)v3 != a2 )
    {
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v7, 0);
      v2 = CNetConfigCore::HrGetComponentBindings(
             *(CNetConfigCore **)(*((_DWORD *)this + 5) + 48),
             v3,
             0,
             (struct CBindingSet *)&v6);
      if ( !v2 )
      {
        v4 = v8;
        v2 = 1;
        while ( v4 != v9 )
        {
          if ( CComponentList::FComponentInList(v4, (const struct CComponent *)a2)
            && !CNetConfigCore::FIsBindPathDisabled(*(CNetConfigCore **)(*((_DWORD *)this + 5) + 48), v4, 2u) )
          {
            v2 = 0;
            break;
          }
          v4 = (CComponentList *)((char *)v4 + 20);
        }
      }
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v7);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 5) + 24));
  }
  return v2;
}

//----- (6E6516D2) --------------------------------------------------------
signed int __stdcall CImplINetCfg::AcquireWriteLock(CImplINetCfg *this, DWORD dwMilliseconds, BYTE *lpData, unsigned __int16 **a4)
{
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-Ch]@1
  signed int v6; // [sp+14h] [bp-4h]@4

  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: %ws asking for write lock with timeout = %d ms.",
    lpData,
    dwMilliseconds);
  if ( a4 )
    *a4 = 0;
  if ( FIsUserAdmin()
    || FIsUserNetworkConfigOps()
    || FIsUserService()
    || FIsUserLocalSystem()
    || FIsUserLocalService()
    || FIsUserNetworkService() )
  {
    v6 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 4), 0x11u);
    if ( !v6 )
    {
      if ( CWriteLock::WaitToAcquire((CImplINetCfg *)((char *)this + 68), dwMilliseconds, lpData, a4) )
      {
        v6 = 0;
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          (5 - (g_IsInUpgrade != 0)) | 0x10000,
          "NCI: %ws acquired write lock.",
          lpData);
      }
      else
      {
        v6 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 20));
    }
  }
  else
  {
    v6 = -2147024891;
  }
  return v6;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E651802) --------------------------------------------------------
int __thiscall CWriteLock::WaitToAcquire(CWriteLock *this, DWORD dwMilliseconds, BYTE *lpData, unsigned __int16 **a4)
{
  DWORD v4; // eax@2
  MSG Msg; // [sp+0h] [bp-24h]@8
  int v7; // [sp+1Ch] [bp-8h]@1
  HANDLE *pHandles; // [sp+20h] [bp-4h]@1

  v7 = 0;
  pHandles = (HANDLE *)this;
  if ( !CWriteLock::HrEnsureMutexCreated((void **)this) )
  {
    while ( 1 )
    {
      v4 = MsgWaitForMultipleObjects(1u, pHandles, 0, dwMilliseconds, 0x4FFu);
      if ( v4 != 1 )
        break;
      while ( PeekMessageW(&Msg, 0, 0, 0, 1u) )
        DispatchMessageW(&Msg);
    }
    if ( v4 && v4 != 128 )
    {
      if ( v4 != 258 )
        HrFromLastWin32Error();
      if ( a4 )
        CWriteLock::SetOrQueryLockHolder(0, 0, a4);
    }
    else
    {
      v7 = 1;
      pHandles[1] = HANDLE_FLAG_INHERIT;
      CWriteLock::SetOrQueryLockHolder((void *)1, lpData, a4);
    }
  }
  return v7;
}

//----- (6E651876) --------------------------------------------------------
__int32 __thiscall CWriteLock::HrEnsureMutexCreated(void **this)
{
  JUMPOUT(*this, 0, nullsub_6);
  return HrCreateMutexWithWorldAccess(L"Global\\NetCfgWriteLock", 0, 0, this);
}
// 6E655F84: using guessed type int nullsub_6();

//----- (6E6518C3) --------------------------------------------------------
signed int __thiscall CDynamicBuffer::HrReserveBytes(CDynamicBuffer *this, unsigned __int32 a2)
{
  signed int result; // eax@2

  if ( a2 <= *((_DWORD *)this + 2) )
    result = 0;
  else
    result = CDynamicBuffer::FGrowBuffer(this, a2) != 0 ? 0 : -2147024882;
  return result;
}

//----- (6E6518F1) --------------------------------------------------------
BOOL __thiscall CDynamicBuffer::FGrowBuffer(CDynamicBuffer *this, unsigned __int32 a2)
{
  CDynamicBuffer *v2; // esi@1
  void *v3; // ebx@1
  unsigned __int32 v4; // edi@3
  unsigned int v5; // ecx@3
  unsigned int v6; // eax@4
  void *v7; // eax@5

  v2 = this;
  v3 = 0;
  if ( !*((_DWORD *)this + 3) )
    *((_DWORD *)this + 3) = 4096;
  v4 = a2;
  v5 = *((_DWORD *)this + 3);
  if ( a2 % v5 )
    v4 = v5 - a2 % v5 + a2;
  v6 = *((_DWORD *)v2 + 2);
  if ( v6 + v4 >= v6 )
  {
    v7 = MemAlloc(v6 + v4);
    v3 = v7;
    if ( v7 )
    {
      memcpy(v7, *(const void **)v2, *((_DWORD *)v2 + 1));
      MemFree(*(void **)v2);
      *((_DWORD *)v2 + 2) += v4;
      *(_DWORD *)v2 = v3;
    }
  }
  return v3 != 0;
}

//----- (6E651960) --------------------------------------------------------
signed int __thiscall CAutoImpersonate::CheckPoint(CAutoImpersonate *this, int *a2)
{
  CAutoImpersonate *v2; // esi@1
  signed int result; // eax@1
  int v4; // ecx@2
  int v5; // [sp+4h] [bp-4h]@1

  v2 = this;
  result = CAutoImpersonate::IsImpersonating(&v5);
  if ( result >= 0 )
  {
    v4 = v5;
    *((_DWORD *)v2 + 2) = v5;
    if ( a2 )
      *a2 = v4;
    *((_DWORD *)v2 + 3) = 1;
  }
  return result;
}

//----- (6E651998) --------------------------------------------------------
signed int __stdcall CAutoImpersonate::IsImpersonating(int *TokenHandle)
{
  int *v1; // esi@1
  signed int v2; // edi@1
  HANDLE v3; // eax@2
  DWORD v4; // eax@3
  signed int result; // eax@4
  int *v6; // ST0C_4@7

  v1 = TokenHandle;
  v2 = 0;
  if ( TokenHandle )
  {
    *TokenHandle = 0;
    v3 = GetCurrentThread();
    if ( OpenThreadToken(v3, 8u, 0, (PHANDLE)&TokenHandle) )
    {
      v6 = TokenHandle;
      *v1 = 1;
      CloseHandle(v6);
    }
    else
    {
      v4 = GetLastError();
      if ( v4 != 1008 )
      {
        if ( (signed int)v4 > 0 )
          v4 = (unsigned __int16)v4 | 0x80070000;
        v2 = v4;
      }
    }
    result = v2;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E651A53) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::BindTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2)
{
  return CImplINetCfgComponent::HrBindToOrUnbindFrom((CImplINetCfgComponent *)((char *)this - 4), a2, 0x10u);
}

//----- (6E651B11) --------------------------------------------------------
void __usercall sub_6E651B11(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a2 + 4 * a1 + 16) = *(_DWORD *)(a3 + 4 * a1 + 16);
  *(_DWORD *)(a2 + 4 * a1 + 12) = *(_DWORD *)(a3 + 4 * a1 + 12);
  *(_DWORD *)(a2 + 4 * a1 + 8) = *(_DWORD *)(a3 + 4 * a1 + 8);
  *(_DWORD *)(a2 + 4 * a1 + 4) = *(_DWORD *)(a3 + 4 * a1 + 4);
  JUMPOUT(loc_6E651B3C);
}

//----- (6E651B4F) --------------------------------------------------------
void __thiscall CBindingSet::RemoveBindPath(CBindingSet *this, const struct CBindPath *a2)
{
  CBindingSet *v2; // esi@1
  int v3; // ebx@1
  int i; // edi@1

  v2 = this;
  v3 = *((_DWORD *)this + 3);
  for ( i = *((_DWORD *)this + 2); i != v3; i += 20 )
  {
    if ( CBindPath::FIsSameBindPathAs((CBindPath *)i, a2) )
    {
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase((int)((char *)v2 + 4), (int)&a2, i);
      return;
    }
  }
}

//----- (6E651B8F) --------------------------------------------------------
int __thiscall std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  char v5; // [sp+4h] [bp-4h]@1

  v3 = this;
  std::copy<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(
    (int)&v5,
    a3 + 20,
    *(_DWORD *)(this + 8),
    (void *)a3);
  std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(
    (void *)(*(_DWORD *)(v3 + 8) - 20),
    *(_DWORD *)(v3 + 8),
    v3);
  result = a2;
  *(_DWORD *)(v3 + 8) -= 20;
  *(_DWORD *)a2 = a3;
  return result;
}

//----- (6E651C65) --------------------------------------------------------
void __thiscall CBindingSet::SortForPnpBind(CBindingSet *this)
{
  std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
    *((_DWORD *)this + 2),
    *((_DWORD *)this + 3),
    (int)this);
}

//----- (6E651C82) --------------------------------------------------------
void __stdcall std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3)
{
  std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::greater<CBindPath>>(
    a1,
    a2,
    (a2 - a1) / 20,
    a3);
}

//----- (6E651CAB) --------------------------------------------------------
void __stdcall std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::greater<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1

  v4 = (a2 - a1) / 20;
  JUMPOUT(v4, 32, sub_6E6573EB);
  if ( v4 > 1 )
    std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      a1,
      a2,
      a4);
}

//----- (6E651DB5) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1)
{
  return ATL::CComObject<CMSClient>::Release((void *)(a1 - 4));
}

//----- (6E651DC4) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1)
{
  return ATL::CComObject<CMSClient>::Release((void *)(a1 - 8));
}

//----- (6E651DD3) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(int a1)
{
  return ATL::CComObject<CSrvrcfg>::Release((void *)(a1 - 4));
}

//----- (6E651DE2) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CMSClient>::Release(int a1)
{
  return ATL::CComObject<CMSClient>::Release((void *)(a1 - 12));
}

//----- (6E651DF1) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CSrvrcfg>::Release(int a1)
{
  return ATL::CComObject<CSrvrcfg>::Release((void *)(a1 - 8));
}

//----- (6E651E00) --------------------------------------------------------
int __thiscall CComponent::FIsBindable(CComponent *this)
{
  CComponent *v1; // esi@1
  const wchar_t *v2; // eax@1
  int result; // eax@3
  const wchar_t *v4; // esi@8

  v1 = this;
  v2 = (const wchar_t *)*((_DWORD *)this + 20);
  if ( !v2 )
    v2 = &String;
  if ( _wcsicmp(L"nolower", v2) )
    goto LABEL_13;
  v4 = (const wchar_t *)*((_DWORD *)v1 + 21);
  if ( !v4 )
    v4 = &String;
  result = _wcsicmp(L"noupper", v4);
  if ( result )
LABEL_13:
    result = 1;
  return result;
}

//----- (6E651E68) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::ApplyPnpChanges(CNotifyObjectInterface *this, struct CImplINetCfg *a2, int *a3)
{
  CNotifyObjectInterface *v3; // esi@1
  int v4; // esi@3
  int v5; // eax@3
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-28h]@1
  CNotifyObjectInterface *v7; // [sp+1Ch] [bp-1Ch]@1

  v3 = this;
  v7 = this;
  LogToken = SetupGetThreadLogToken();
  *a3 = 0;
  if ( *(_DWORD *)v3 )
  {
    v4 = (int)((char *)v3 - 112);
    CImplINetCfg::RaiseRpl((int)a2, 1);
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      calling %S->ApplyPnpChanges\n", *(_DWORD *)(v4 + 28));
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Calling %ws ApplyPnpChanges",
      *(_DWORD *)(v4 + 28));
    v5 = (*(int (__stdcall **)(_DWORD, unsigned int))(***(_DWORD ***)v7 + 20))(
           **(_DWORD **)v7,
           a2 != 0 ? (unsigned int)((char *)a2 + 16) : 0);
    if ( v5 < 0 || v5 == 303136 )
    {
      *a3 = 1;
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "! NCI: %ws ApplyPnpChanges returned 0x%08X. Reboot requested",
        *(_DWORD *)(v4 + 28),
        v5);
    }
    CImplINetCfg::LowerRpl((int)a2, 1);
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E651EC1) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::ApplyRegistryChanges(CNotifyObjectInterface *this, struct CImplINetCfg *a2, int *a3)
{
  CNotifyObjectInterface *v3; // ebx@1
  int v4; // ebx@3
  int v5; // eax@3
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-28h]@1
  CNotifyObjectInterface *v7; // [sp+1Ch] [bp-1Ch]@1

  v3 = this;
  v7 = this;
  LogToken = SetupGetThreadLogToken();
  *a3 = 0;
  if ( *(_DWORD *)v3 )
  {
    v4 = (int)((char *)v3 - 112);
    CImplINetCfg::RaiseRpl((int)a2, 1);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Calling %ws ApplyRegistryChanges",
      *(_DWORD *)(v4 + 28));
    v5 = (*(int (__stdcall **)(_DWORD))(***(_DWORD ***)v7 + 16))(**(_DWORD **)v7);
    if ( v5 < 0 || v5 == 303136 )
    {
      *a3 = 1;
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "! NCI: %ws ApplyRegistryChanges returned 0x%08X. Reboot requested.",
        *(_DWORD *)(v4 + 28),
        v5);
    }
    CImplINetCfg::LowerRpl((int)a2, 1);
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E651F19) --------------------------------------------------------
signed int __thiscall CNotifyObjectInterface::HrGetInterfaceIdsForAdapter(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct CComponent *a3, unsigned __int32 *a4, struct _GUID **a5)
{
  CNotifyObjectInterface *v5; // esi@1
  signed int result; // eax@4
  signed int v7; // [sp+18h] [bp-20h]@7
  struct IUnknown *v8; // [sp+1Ch] [bp-1Ch]@7
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@8

  v5 = this;
  SetupGetThreadLogToken();
  *a4 = 0;
  if ( a5 )
    *a5 = 0;
  if ( *(_DWORD *)v5 && *(_DWORD *)(*(_DWORD *)v5 + 16) )
  {
    v8 = 0;
    v7 = CComponent::HrGetINetCfgComponentInterface(a3, a2, (struct INetCfgComponent **)&v8);
    if ( !v7 )
    {
      CImplINetCfg::RaiseRpl((int)a2, 1);
      ms_exc.registration.TryLevel = 0;
      v7 = (*(int (__stdcall **)(_DWORD, struct IUnknown *, unsigned __int32 *, struct _GUID **))(**(_DWORD **)(*(_DWORD *)v5 + 16)
                                                                                                + 12))(
             *(_DWORD *)(*(_DWORD *)v5 + 16),
             v8,
             a4,
             a5);
      if ( v7 == 1 )
      {
        *a4 = 0;
        if ( a5 )
          *a5 = 0;
      }
      ms_exc.registration.TryLevel = -2;
      CImplINetCfg::LowerRpl((int)a2, 1);
      ReleaseObj(v8);
    }
    result = v7;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6E651FCB) --------------------------------------------------------
void __thiscall CComponentList::FreeComponentsNotInOtherComponentList(CComponentList *this, const struct CComponentList *a2)
{
  CComponentList *v2; // edi@1
  const struct CComponent **v3; // esi@1
  const struct CComponent *v4; // ebx@2
  char v5; // [sp+8h] [bp-4h]@6

  v2 = this;
  v3 = (const struct CComponent **)*((_DWORD *)this + 2);
  if ( v3 != *((const struct CComponent ***)this + 3) )
  {
    do
    {
      v4 = *v3;
      if ( CComponentList::FComponentInList(a2, *v3) )
      {
        ++v3;
      }
      else
      {
        std::vector<CComponent *,std::nc_allocator<CComponent *>>::erase((int)((char *)v2 + 4), (int)&v5, (int)v3);
        if ( v4 )
          CComponent::`scalar deleting destructor'((void *)v4, 1);
      }
    }
    while ( v3 != *((const struct CComponent ***)v2 + 3) );
  }
}

//----- (6E652014) --------------------------------------------------------
__int32 __thiscall CBindPath::HrInsertComponent(CBindPath *this, const struct CComponent *a2)
{
  int v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+1Ch] [bp-4h]@1

  v4 = 0;
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::insert(
    (int)((char *)this + 4),
    (int)&v3,
    *((void **)this + 2),
    (int)&a2);
  return 0;
}

//----- (6E652052) --------------------------------------------------------
__int32 __userpurge CBindingSet::HrAppendBindingSet@<eax>(CBindingSet *this@<ecx>, int a2@<ebx>, const struct CBindingSet *a3)
{
  CBindingSet *v3; // edi@1
  int i; // esi@1

  v3 = this;
  for ( i = *(_DWORD *)(a2 + 8); i != *(_DWORD *)(a2 + 12); i += 20 )
  {
    if ( !CBindingSet::FContainsBindPath(v3, (const struct CBindPath *)i) )
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::insert(
        (int)((char *)v3 + 4),
        (int)&a3,
        *((_DWORD *)v3 + 3),
        i);
  }
  return 0;
}

//----- (6E652087) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::Release((void *)(a1 - 8));
}

//----- (6E6520C2) --------------------------------------------------------
void __thiscall CFilterDevices::StartFilterDevices(CFilterDevices *this)
{
  CFilterDevices *v1; // edi@1
  int v2; // eax@3
  int v3; // ebx@4
  int v4; // esi@4

  v1 = this;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)this) )
  {
    v2 = *((_DWORD *)v1 + 2);
    if ( v2 != *((_DWORD *)v1 + 1) )
    {
      do
      {
        v3 = v2 - 4;
        v4 = *(_DWORD *)(v2 - 4);
        CDiagContext::Printf(
          (DWORD)g_pDiagCtx,
          3,
          "   %S filter over %S adapter\n",
          *(_DWORD *)(*(_DWORD *)(v4 + 4) + 28),
          *(_DWORD *)(*(_DWORD *)v4 + 32));
        if ( HrSetupDiSendPropertyChangeNotification(*((HDEVINFO *)v1 + 10), (PSP_DEVINFO_DATA)(v4 + 8), 4u, 2u, 0) )
          CDiagContext::Printf(
            (DWORD)g_pDiagCtx,
            3,
            "   Failed to start filter device for %S over %S adapter\n",
            *(_DWORD *)(*(_DWORD *)(v4 + 4) + 28),
            *(_DWORD *)(*(_DWORD *)v4 + 32));
        v2 = v3;
      }
      while ( v3 != *((_DWORD *)v1 + 1) );
    }
  }
}

//----- (6E6520DB) --------------------------------------------------------
void __thiscall CFilterDevices::LoadAndRemoveFilterDevicesIfNeeded(CFilterDevices *this)
{
  CFilterDevices *v1; // ebx@1
  HDEVINFO *v2; // esi@1
  __int32 v3; // eax@3
  int v4; // eax@9
  int v5; // [sp+Ch] [bp-238h]@11
  DWORD Type; // [sp+10h] [bp-234h]@5
  HKEY hKey; // [sp+14h] [bp-230h]@4
  DWORD MemberIndex; // [sp+18h] [bp-22Ch]@2
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+1Ch] [bp-228h]@3
  BYTE Data; // [sp+38h] [bp-20Ch]@5

  v1 = this;
  v2 = (HDEVINFO *)((char *)this + 40);
  if ( !HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, 0, 0, 8u, (void **)this + 10) )
  {
    MemberIndex = 0;
    while ( 1 )
    {
      v3 = HrSetupDiEnumDeviceInfo(*v2, MemberIndex, &DeviceInfoData);
      if ( !v3 )
        break;
LABEL_8:
      ++MemberIndex;
      if ( v3 )
      {
        v4 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)v1);
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   Loaded %d filter devices\n", v4);
        return;
      }
    }
    if ( HrSetupDiOpenDevRegKey(*v2, &DeviceInfoData, 1u, 0, 2u, 0x20019u, &hKey) )
    {
LABEL_7:
      v3 = 0;
      goto LABEL_8;
    }
    Type = 520;
    if ( !HrRegQueryTypeSzBuffer(hKey, L"FilterInfId", 1u, &Data, (DWORD)&Type) )
    {
      if ( CFilterDevices::HrLoadFilterDevice(v1, &DeviceInfoData, hKey, (const unsigned __int16 *)&Data, &v5) )
      {
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   Removing filter device for %S\n", &Data);
      }
      else if ( !v5 )
      {
        goto LABEL_6;
      }
      HrCiRemoveFilterDevice(*v2, &DeviceInfoData);
    }
LABEL_6:
    RegCloseKey(hKey);
    goto LABEL_7;
  }
}

//----- (6E6521EE) --------------------------------------------------------
signed int __stdcall CFilteredAdapters::HrWriteFilterList(HKEY hKey, struct CDynamicBuffer *a3)
{
  signed int v2; // edi@1
  BYTE *v3; // edi@3
  const WCHAR *v4; // esi@3
  HKEY phkResult; // [sp+4h] [bp-4h]@1

  phkResult = 0;
  v2 = HrRegOpenKeyEx(hKey, L"Linkage", 0x20006u, &phkResult);
  if ( !v2 )
  {
    v2 = CDynamicBuffer::HrCopyString(a3, &String);
    if ( !v2 )
    {
      v3 = *(BYTE **)a3;
      v4 = *(const WCHAR **)a3;
      if ( **(_WORD **)a3 )
      {
        do
          v4 += lstrlenW(v4) + 1;
        while ( *v4 );
      }
      v2 = HrRegSetMultiSz(phkResult, L"FilterList", v3);
    }
    RegSafeCloseKey(phkResult);
  }
  return v2;
}

//----- (6E65228B) --------------------------------------------------------
int __thiscall CFilteredAdapter::CFilteredAdapter(int this)
{
  int v1; // esi@1

  v1 = this;
  CComponentList::CComponentList((void *)(this + 4));
  CComponentList::CComponentList((void *)(v1 + 24));
  *(_DWORD *)v1 = 0;
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v1 + 8);
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v1 + 28);
  return v1;
}

//----- (6E6522D0) --------------------------------------------------------
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  HRESULT result; // eax@1

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    result = sub_6E641D2F((int)pszSrc, cchDest, (int)pszDest, 0, 2147483646);
  return result;
}

//----- (6E65230C) --------------------------------------------------------
int __stdcall GetPnpLayerForBindPath(const struct CBindPath *a1)
{
  return (FIsConsideredNetClass(*(_DWORD *)(*(_DWORD *)(*((_DWORD *)a1 + 2) + 4) + 16)) == 0) + 1;
}

//----- (6E652333) --------------------------------------------------------
LONG __cdecl CompareModifyingFilters(const void *a1, const void *a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // esi@1
  LONG result; // eax@2

  v2 = *(_DWORD *)(*(_DWORD *)a1 + 128);
  v3 = *(_DWORD *)(*(_DWORD *)a2 + 128);
  if ( v3 == v2 )
    result = CompareTimeStamps(*(SYSTEMTIME **)(*(_DWORD *)a1 + 76), *(SYSTEMTIME **)(*(_DWORD *)a2 + 76));
  else
    result = v3 < v2 ? -1 : 1;
  return result;
}

//----- (6E652408) --------------------------------------------------------
int __thiscall CServiceManager::~CServiceManager(CServiceManager *this)
{
  int result; // eax@1

  result = 0;
  if ( *((_DWORD *)this + 1) )
    *((_DWORD *)this + 1) = 0;
  JUMPOUT(*(_DWORD *)this, 0, CServiceManager::Close);
  return result;
}

//----- (6E652421) --------------------------------------------------------
unsigned __int32 __thiscall CDiagContext::Flags(CDiagContext *this)
{
  unsigned __int32 result; // eax@2

  if ( this )
    result = *(_DWORD *)this;
  else
    result = 0;
  return result;
}

//----- (6E652431) --------------------------------------------------------
int __thiscall RPC_CONFIG_DATA::~RPC_CONFIG_DATA(RPC_CONFIG_DATA *this)
{
  int v1; // esi@1

  v1 = (int)this;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)this + 56),
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    v1 + 28,
    1,
    0);
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
           v1,
           1,
           0);
}

//----- (6E652460) --------------------------------------------------------
void __thiscall CMSClient::CleanupPropPages(CMSClient *this)
{
  char *v1; // esi@1
  int v2; // ecx@1

  v1 = (char *)this + 172;
  v2 = *((_DWORD *)this + 43);
  if ( v2 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v1 = 0;
}

//----- (6E6524E8) --------------------------------------------------------
__int32 __stdcall CFilteredAdapter::HrCreateInstance(const struct CComponent *a1, const struct CNetConfigCore *a2, struct CFilteredAdapter **a3)
{
  int v3; // eax@3
  int v4; // esi@1
  __int32 v5; // edi@1

  v4 = 0;
  v5 = 1;
  *a3 = 0;
  if ( CNetConfigCore::FAdapterHasAnEnabledLightWeightFilter(a2, a1) )
  {
    v3 = (int)operator new(0x2Cu);
    if ( v3 )
      v4 = CFilteredAdapter::CFilteredAdapter(v3);
    if ( v4 )
    {
      *(_DWORD *)v4 = a1;
      v5 = CNetConfigCore::HrGetFiltersEnabledForAdapter(
             a2,
             a1,
             (struct CComponentList *)(v4 + 24),
             (struct CComponentList *)(v4 + 24),
             (struct CComponentList *)(v4 + 4));
      if ( v5 >= 0
        && (std::vector<CParam *,std::nc_allocator<CParam *>>::size(v4 + 8)
         || std::vector<CParam *,std::nc_allocator<CParam *>>::size(v4 + 28)) )
      {
        *a3 = (struct CFilteredAdapter *)v4;
      }
      else
      {
        v5 = 1;
        CFilteredAdapter::`scalar deleting destructor'((void *)v4, 1);
      }
    }
    else
    {
      v5 = -2147024882;
    }
  }
  return v5;
}

//----- (6E652521) --------------------------------------------------------
int __thiscall CNetConfigCore::FAdapterHasAnEnabledLightWeightFilter(CNetConfigCore *this, const struct CComponent *a2)
{
  CNetConfigCore *v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@1

  v2 = this;
  v3 = *((_DWORD *)this + 7);
  v4 = *((_DWORD *)this + 8);
  while ( v3 != v4 )
  {
    if ( *(_DWORD *)(*(_DWORD *)v3 + 24) & 0x40000
      && *(const struct CComponent **)(v3 + 4) == a2
      && !CNetConfigCore::FIsLength2BindPathDisabled(
            v2,
            *(const struct CComponent **)v3,
            *(const struct CComponent **)(v3 + 4)) )
      return 1;
    v3 += 8;
  }
  return 0;
}

//----- (6E6525D0) --------------------------------------------------------
__int32 __thiscall CNetConfigCore::HrGetFiltersEnabledForAdapter(CNetConfigCore *this, const struct CComponent *a2, struct CComponentList *a3, struct CComponentList *a4, struct CComponentList *a5)
{
  int v5; // esi@6
  struct CComponentList *v6; // ecx@12
  CNetConfigCore *v7; // esi@1
  int v8; // ebx@1
  const struct CComponent *v9; // ecx@2
  __int32 result; // eax@4
  CNetConfigCore *v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@6

  v7 = this;
  v11 = this;
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)((char *)a3 + 4));
  v8 = *((_DWORD *)v7 + 7);
  if ( v8 != *((_DWORD *)v7 + 8) )
  {
    do
    {
      v9 = *(const struct CComponent **)(v8 + 4);
      if ( v9 != a2 )
        goto LABEL_3;
      v5 = *(_DWORD *)v8;
      v12 = *(_DWORD *)(*(_DWORD *)v8 + 24) & 0x400;
      if ( !v12 && (!a4 && !a5 || !(*(_DWORD *)(*(_DWORD *)v8 + 24) & 0x40000)) )
        goto LABEL_3;
      if ( CNetConfigCore::FIsLength2BindPathDisabled(v11, (const struct CComponent *)v5, v9) )
        goto LABEL_3;
      if ( v12 )
      {
        v6 = a3;
      }
      else
      {
        v6 = a4;
        if ( !a4 || **(_DWORD **)(v5 + 68) == 1 )
        {
          if ( !a5 || **(_DWORD **)(v5 + 68) != 1 )
            goto LABEL_3;
          v6 = a5;
        }
      }
      result = CComponentList::HrInsertComponent(v6, (const struct CComponent *)v5, 0x2100u);
      if ( result )
        return result;
LABEL_3:
      v8 += 8;
    }
    while ( v8 != *((_DWORD *)v11 + 8) );
  }
  return 0;
}

//----- (6E652658) --------------------------------------------------------
int __thiscall CNetConfigCore::FIsLength2BindPathDisabled(CNetConfigCore *this, const struct CComponent *a2, const struct CComponent *a3)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = *((_DWORD *)this + 13);
  v4 = *((_DWORD *)this + 14);
  while ( 1 )
  {
    if ( v3 == v4 )
      return 0;
    if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4) == 2
      && **(const struct CComponent ***)(v3 + 8) == a2
      && *(const struct CComponent **)(*(_DWORD *)(v3 + 12) - 4) == a3 )
      break;
    v3 += 20;
  }
  return 1;
}

//----- (6E6526F0) --------------------------------------------------------
__int32 __thiscall CFilteredAdapters::HrLoadFilteredAdaptersFromCore(CFilteredAdapters *this)
{
  CFilteredAdapter *v1; // ecx@8
  int v2; // ebx@8
  int v3; // esi@9
  CFilteredAdapters *v4; // esi@1
  int v5; // ecx@1
  const struct CComponent **v6; // edi@1
  __int32 result; // eax@1
  const struct CComponent *v8; // edx@3
  CFilteredAdapters *i; // [sp+8h] [bp-8h]@1
  CFilteredAdapter *v10; // [sp+Ch] [bp-4h]@7

  v4 = this;
  v5 = *((_DWORD *)this + 4);
  v6 = *(const struct CComponent ***)(v5 + 8);
  result = 0;
  for ( i = v4; v6 != *(const struct CComponent ***)(v5 + 12); ++v6 )
  {
    if ( result < 0 )
      break;
    v8 = *v6;
    if ( !*((_DWORD *)*v6 + 4) )
    {
      v10 = 0;
      result = CFilteredAdapter::HrCreateInstance(v8, (const struct CNetConfigCore *)v5, &v10);
      if ( !result )
      {
        v1 = v10;
        v2 = *((_DWORD *)v10 + 8);
        if ( v2 != *((_DWORD *)v10 + 9) )
        {
          do
          {
            v3 = *(_DWORD *)v2 + 128;
            if ( !*(_DWORD *)v3 )
              *(_DWORD *)v3 = CFilterDevices::MapFilterClassToOrdinal(
                                *((CFilterDevices **)i + 6),
                                *(const unsigned __int16 **)(*(_DWORD *)v2 + 64));
            v2 += 4;
          }
          while ( v2 != *((_DWORD *)v10 + 9) );
          v4 = i;
          v1 = v10;
        }
        CFilteredAdapter::SortFilters(v1);
        result = CFilteredAdapters::HrInsertFilteredAdapter(v4, v10);
      }
    }
    v5 = *((_DWORD *)v4 + 4);
  }
  return result;
}

//----- (6E65272D) --------------------------------------------------------
void __thiscall CFilterDevices::InstallFilterDevicesIfNeeded(CFilterDevices *this)
{
  CFilterDevices *v1; // esi@1
  int v2; // ecx@2
  int i; // ebx@2
  struct CComponent *v4; // edi@4
  const struct CComponent **v5; // eax@7
  const struct CComponent *v6; // ebx@11
  const struct CComponent **v7; // eax@11
  int v8; // edi@11
  struct CComponent *v9; // edi@23
  signed int v10; // [sp+4h] [bp-438h]@7
  HKEY v11; // [sp+8h] [bp-434h]@13
  HKEY hKey; // [sp+Ch] [bp-430h]@14
  DWORD Type; // [sp+10h] [bp-42Ch]@16
  void *lpMem; // [sp+14h] [bp-428h]@23
  __int32 v15; // [sp+18h] [bp-424h]@14
  int v16; // [sp+1Ch] [bp-420h]@3
  struct CComponent *v17; // [sp+20h] [bp-41Ch]@4
  const struct CComponent **v18; // [sp+24h] [bp-418h]@7
  BYTE Data; // [sp+28h] [bp-414h]@16
  BYTE v20[520]; // [sp+230h] [bp-20Ch]@13

  v1 = this;
  if ( *((_DWORD *)this + 10) )
  {
    v2 = *((_DWORD *)this + 4);
    for ( i = *(_DWORD *)(v2 + 8); ; i += 4 )
    {
      v16 = i;
      if ( i == *(_DWORD *)(v2 + 12) )
        break;
      v4 = *(struct CComponent **)i;
      v17 = v4;
      if ( !*((_DWORD *)v4 + 4) )
      {
        if ( CNetConfigCore::HrGetFiltersEnabledForAdapter(
               (CNetConfigCore *)v2,
               v4,
               (CFilterDevices *)((char *)v1 + 20),
               0,
               0) )
          return;
        v10 = 0;
        v5 = (const struct CComponent **)*((_DWORD *)v1 + 7);
        v18 = v5;
        if ( v5 != *((const struct CComponent ***)v1 + 8) )
        {
          while ( 1 )
          {
            v6 = *v5;
            v7 = CFilterDevices::PFindFilterDeviceByAdapterAndFilter(v1, v4, *v5);
            v8 = v7 == 0;
            if ( !v7 || *((_DWORD *)v6 + 32) == v8 )
            {
              *(_WORD *)v20 = 0;
              if ( !CComponent::HrOpenInstanceKey(v6, 0x20019u, &v11, 0, 0) )
              {
                v15 = HrRegOpenKeyEx(v11, L"Ndi", 0x20019u, &hKey);
                if ( !v15 )
                {
                  if ( !*((_DWORD *)v6 + 32) )
                  {
                    Type = 520;
                    v15 = HrRegQueryTypeSzBuffer(hKey, L"FilterClass", 1u, &Data, (DWORD)&Type);
                    if ( !v15 )
                      *((_DWORD *)v6 + 32) = CFilterDevices::MapFilterClassToOrdinal(
                                               v1,
                                               (const unsigned __int16 *)&Data);
                  }
                  if ( v8 )
                  {
                    Type = 520;
                    v15 = HrRegQueryTypeSzBuffer(hKey, L"FilterDeviceInfId", 1u, v20, (DWORD)&Type);
                  }
                  RegCloseKey(hKey);
                }
                RegCloseKey(v11);
                if ( !v15 )
                {
                  if ( v8 )
                  {
                    v9 = v17;
                    CDiagContext::Printf(
                      (DWORD)g_pDiagCtx,
                      3,
                      "   Installing filter device for %S over %S adapter\n",
                      *((_DWORD *)v6 + 7),
                      *((_DWORD *)v17 + 8));
                    if ( !HrCiInstallFilterDevice(
                            *((HDEVINFO *)v1 + 10),
                            (const unsigned __int16 *)v20,
                            v9,
                            v6,
                            (struct CFilterDevice **)&lpMem) )
                    {
                      if ( CPszArray::HrAddPointer(v1, (const unsigned __int16 *)lpMem) )
                      {
                        if ( lpMem )
                          operator delete(lpMem);
                      }
                      else
                      {
                        v10 = 1;
                      }
                    }
                  }
                }
              }
            }
            ++v18;
            if ( v18 == *((const struct CComponent ***)v1 + 8) )
              break;
            v4 = v17;
            v5 = v18;
          }
          if ( v10 )
            CNetConfigCore::HrGetComponentUpperBindings(
              *((CNetConfigCore **)v1 + 4),
              v17,
              3,
              (CFilterDevices *)((char *)v1 + 48));
          i = v16;
        }
      }
      v2 = *((_DWORD *)v1 + 4);
    }
  }
}

//----- (6E6527B2) --------------------------------------------------------
const void **__thiscall CFilteredAdapters::PFindEntryByAdapterGuid(CFilteredAdapters *this, const struct _GUID *a2)
{
  const void ***v2; // edx@1
  const void **result; // eax@2
  const void ***v4; // [sp+Ch] [bp-4h]@1

  v2 = (const void ***)*((_DWORD *)this + 1);
  v4 = (const void ***)*((_DWORD *)this + 2);
  if ( v2 == v4 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      result = *v2;
      if ( !memcmp(a2, **v2, 0x10u) )
        break;
      ++v2;
      if ( v2 == v4 )
        goto LABEL_6;
    }
  }
  return result;
}

//----- (6E6527F2) --------------------------------------------------------
__int32 __thiscall CFilteredAdapters::HrWriteFilterBindings(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // ebx@1
  int *v2; // esi@1
  int v3; // eax@2
  int v4; // edi@2
  bool v5; // cf@2
  unsigned __int32 *v6; // ecx@4
  unsigned __int32 *v7; // esi@5
  int v8; // edi@6
  const struct CComponent **v9; // esi@6
  const struct CComponent *v10; // esi@9
  CFilterMap *v11; // ecx@10
  int v12; // eax@17
  const struct CComponent *v14; // edi@24
  CFilterMap *v15; // ecx@24
  int v16; // eax@31
  int *i; // [sp+8h] [bp-3Ch]@1
  struct CFilterDevice *v18; // [sp+Ch] [bp-38h]@34
  struct CComponent *v19; // [sp+10h] [bp-34h]@2
  int v20; // [sp+14h] [bp-30h]@2
  int v21; // [sp+18h] [bp-2Ch]@2
  const struct CComponent **v22; // [sp+1Ch] [bp-28h]@4
  unsigned int v23; // [sp+20h] [bp-24h]@10
  int v24; // [sp+24h] [bp-20h]@10
  HKEY hKey; // [sp+28h] [bp-1Ch]@1
  __int32 v26; // [sp+2Ch] [bp-18h]@1
  IID iid; // [sp+30h] [bp-14h]@5

  v26 = 0;
  hKey = 0;
  v1 = this;
  CFilteredAdapters::DeleteFilterBindings(this);
  v2 = (int *)*((_DWORD *)v1 + 1);
  for ( i = v2; v2 != *((int **)v1 + 2); i = v2 )
  {
    v3 = *((_DWORD *)v1 + 7);
    v4 = *v2;
    v5 = *(_DWORD *)(v3 + 8) < 2u;
    v21 = *v2;
    v19 = 0;
    v20 = 0;
    if ( !v5 )
      **(_WORD **)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    v6 = *(unsigned __int32 **)v4;
    v22 = *(const struct CComponent ***)(v4 + 32);
    v26 = CComponent::HrOpenInstanceKey((CComponent *)v6, 0xF003Fu, &hKey, 0, 0);
    if ( !v26 )
    {
      v7 = *(unsigned __int32 **)v4;
      iid.Data1 = **(_DWORD **)v4;
      ++v7;
      *(_DWORD *)&iid.Data2 = *v7;
      ++v7;
      *(_DWORD *)&iid.Data4[0] = *v7;
      *(_DWORD *)&iid.Data4[4] = v7[1];
      while ( 1 )
      {
        v8 = v21;
        v9 = *(const struct CComponent ***)(v21 + 12);
        if ( v9 != *(const struct CComponent ***)(v21 + 16) )
          break;
LABEL_7:
        if ( !v26 && v22 != *(const struct CComponent ***)(v8 + 36) )
        {
          v10 = *v22;
          if ( *((_DWORD *)*v22 + 6) & 0x400 )
          {
            if ( *(_DWORD *)(*((_DWORD *)v1 + 7) + 4) )
            {
              v26 = CFilteredAdapters::HrWriteFilterList(hKey, *((struct CDynamicBuffer **)v1 + 7));
              v16 = *((_DWORD *)v1 + 7);
              if ( *(_DWORD *)(v16 + 8) >= 2u )
                **(_WORD **)v16 = 0;
              *(_DWORD *)(v16 + 4) = 0;
            }
            RegSafeCloseKey(hKey);
            v20 = 1;
            hKey = 0;
            v19 = 0;
            v18 = 0;
            if ( !v26 )
            {
              v26 = CFilterDevices::HrFindDeviceAndOpenInstanceKey(
                      *((CFilterDevices **)v1 + 6),
                      *(const struct CComponent **)v8,
                      v10,
                      &v18,
                      &hKey);
              if ( !v26 )
                v26 = IIDFromString((LPCOLESTR)v18 + 18, &iid);
            }
          }
          else
          {
            v11 = (CFilterMap *)*((_DWORD *)v1 + 5);
            v24 = 0;
            v26 = CFilterMap::HrGetIndexForFilterByMiniportAndLowerFilter(v11, v10, &iid, 0, v20, &v23, &v24);
            if ( !v26 )
            {
              v26 = CFilteredAdapters::HrBuildFilterListEntry(v1, &iid, (GUID *)v10, v23);
              if ( !v26 && !v24 )
                v26 = CFilteredAdapters::HrWriteFilterServiceKey(v10, (const unsigned __int16 *)v1 + 18);
            }
            v19 = v10;
          }
          ++v22;
          if ( !v26 )
            continue;
        }
        goto LABEL_15;
      }
      while ( !v26 )
      {
        v14 = *v9;
        v15 = (CFilterMap *)*((_DWORD *)v1 + 5);
        v24 = 0;
        v26 = CFilterMap::HrGetIndexForFilterByMiniportAndLowerFilter(v15, v14, &iid, v19, v20, &v23, &v24);
        if ( !v26 )
        {
          v26 = CFilteredAdapters::HrBuildFilterListEntry(v1, &iid, (GUID *)v14, v23);
          if ( !v26 && !v24 )
            v26 = CFilteredAdapters::HrWriteFilterServiceKey(v14, (const unsigned __int16 *)v1 + 18);
        }
        ++v9;
        if ( v9 == *(const struct CComponent ***)(v21 + 16) )
        {
          v8 = v21;
          goto LABEL_7;
        }
      }
LABEL_15:
      if ( !v26 && *(_DWORD *)(*((_DWORD *)v1 + 7) + 4) )
      {
        v26 = CFilteredAdapters::HrWriteFilterList(hKey, *((struct CDynamicBuffer **)v1 + 7));
        v12 = *((_DWORD *)v1 + 7);
        if ( *(_DWORD *)(v12 + 8) >= 2u )
          **(_WORD **)v12 = 0;
        *(_DWORD *)(v12 + 4) = 0;
      }
      RegSafeCloseKey(hKey);
      hKey = 0;
      v2 = i;
    }
    ++v2;
  }
  CFilteredAdapters::DeleteFilterServiceKeys(v1);
  return v26;
}

//----- (6E65295B) --------------------------------------------------------
void __thiscall CFilteredAdapters::DeleteFilterServiceKeys(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // ebx@1
  int v2; // eax@1
  int i; // edi@1
  int v4; // esi@3
  int j; // eax@5
  __int32 v6; // edi@14
  int v7; // [sp+Ch] [bp-238h]@11
  int v8; // [sp+10h] [bp-234h]@2
  HKEY hKey; // [sp+14h] [bp-230h]@1
  int v10; // [sp+18h] [bp-22Ch]@6
  HKEY v11; // [sp+1Ch] [bp-228h]@1
  HKEY phkResult; // [sp+20h] [bp-224h]@1
  WCHAR Name; // [sp+24h] [bp-220h]@1
  char Dst; // [sp+26h] [bp-21Eh]@1
  int Format; // [sp+230h] [bp-14h]@1
  int v16; // [sp+234h] [bp-10h]@1
  int v17; // [sp+238h] [bp-Ch]@1
  int v18; // [sp+23Ch] [bp-8h]@1

  Name = 0;
  v1 = this;
  memset(&Dst, 0, 0x208u);
  Format = *(_DWORD *)L"%s-%04d";
  v16 = *(_DWORD *)L"\u7300\u2d00\u3000\u3400\u6400";
  v17 = *(_DWORD *)L"s-%04d";
  hKey = 0;
  phkResult = 0;
  v11 = 0;
  v2 = *((_DWORD *)v1 + 5);
  v18 = *(_DWORD *)L"\u2d00\u3000\u3400\u6400";
  for ( i = *(_DWORD *)(v2 + 4); ; i += 4 )
  {
    v8 = i;
    if ( i == *(_DWORD *)(v2 + 8) )
      break;
    v4 = *(_DWORD *)i;
    if ( *(_DWORD *)(*(_DWORD *)i + 24)
      && CComponentList::FComponentInList(*((CComponentList **)v1 + 4), *(const struct CComponent **)v4) )
    {
      for ( j = *(_DWORD *)(v4 + 32); ; j += 16 )
      {
        v10 = j;
        if ( j == *(_DWORD *)(v4 + 36) )
          break;
        if ( *(_DWORD *)(j + 12) )
        {
          v7 = *(_DWORD *)(j + 4);
          if ( !CComponent::HrOpenServiceKey(*(CComponent **)v4, 0xF003Fu, &hKey) )
          {
            if ( !HrRegOpenKeyEx(hKey, L"Parameters\\Adapters", 0xF003Fu, &phkResult) )
            {
              StringFromGUID2((const GUID *const )(v4 + 4), (LPOLESTR)v1 + 140, 39);
              if ( !HrRegOpenKeyEx(phkResult, (LPCWSTR)v1 + 140, 0xF003Fu, &v11) )
              {
                StringFromGUID2(*(const GUID *const *)v4, (LPOLESTR)v1 + 101, 39);
                _snwprintf_s((wchar_t *)v1 + 18, 0x53u, 0x52u, (const wchar_t *)&Format, (char *)v1 + 202, v7);
                HrRegDeleteKey(v11, (LPCWSTR)v1 + 18);
                v6 = HrRegEnumKey(v11, 0, &Name, 0x105u);
                RegSafeCloseKey(v11);
                if ( v6 == -2147024637 )
                  HrRegDeleteKey(phkResult, (LPCWSTR)v1 + 140);
              }
              RegSafeCloseKey(phkResult);
            }
            RegSafeCloseKey(hKey);
          }
          i = v8;
          j = v10;
        }
      }
    }
    v2 = *((_DWORD *)v1 + 5);
  }
}
// 6E6529FC: using guessed type wchar_t aS04d[8];

//----- (6E652A19) --------------------------------------------------------
void __thiscall CFilteredAdapters::SendDetachNotifications(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // edi@1
  int v2; // eax@1
  int i; // esi@1
  int v4; // eax@3
  int j; // ecx@4

  v1 = this;
  v2 = *((_DWORD *)this + 5);
  for ( i = *(_DWORD *)(v2 + 4); i != *(_DWORD *)(v2 + 8); i += 4 )
  {
    v4 = *(_DWORD *)i;
    if ( *(_DWORD *)(*(_DWORD *)i + 24) )
    {
      for ( j = *(_DWORD *)(v4 + 32); j != *(_DWORD *)(v4 + 36); j += 16 )
      {
        if ( *(_DWORD *)(j + 12) )
        {
          CFilteredAdapters::HrAttachOrDetach(v1, (struct CFilterMapEntry *)v4, 0xBu);
          break;
        }
      }
    }
    v2 = *((_DWORD *)v1 + 5);
  }
}

//----- (6E652A5C) --------------------------------------------------------
__int32 __thiscall CFilteredAdapters::HrInsertFilteredAdapter(CFilteredAdapters *this, struct CFilteredAdapter *a2)
{
  int v2; // esi@1

  v2 = (int)this;
  if ( !CFilteredAdapters::PFindEntryByAdapter(this, *(const struct CComponent **)a2) )
    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back(v2, (int)&a2);
  return 0;
}

//----- (6E652A9A) --------------------------------------------------------
const struct CComponent **__thiscall CFilteredAdapters::PFindEntryByAdapter(CFilteredAdapters *this, const struct CComponent *a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  const struct CComponent **result; // eax@3

  v2 = *((_DWORD *)this + 1);
  v3 = *((_DWORD *)this + 2);
  while ( v2 != v3 )
  {
    result = *(const struct CComponent ***)v2;
    if ( a2 == **(const struct CComponent ***)v2 )
      return result;
    v2 += 4;
  }
  return 0;
}

//----- (6E652AC4) --------------------------------------------------------
__int16 __stdcall NdispUnicodeStringToVar(int a1, int a2, int a3)
{
  void *v3; // edi@1
  unsigned __int16 v4; // ax@2
  __int16 result; // ax@4

  v3 = (void *)(a1 + *(_DWORD *)(a3 + 4));
  if ( a2 && (v4 = *(_WORD *)a2) != 0 )
  {
    *(_WORD *)a3 = v4;
    memcpy(v3, *(const void **)(a2 + 4), v4);
  }
  else
  {
    *(_WORD *)a3 = 0;
  }
  *((_WORD *)v3 + ((unsigned int)*(_WORD *)a3 >> 1)) = 0;
  result = *(_WORD *)a3 + 2;
  *(_WORD *)(a3 + 2) = result;
  return result;
}

//----- (6E652D7C) --------------------------------------------------------
int __thiscall CRegistryBindingsContext::HrWriteBindingsForComponent(CRegistryBindingsContext *this, const struct CComponent *rguid)
{
  int v2; // eax@34
  int v3; // edi@38
  struct CImplINetCfg *v4; // eax@44
  CRegistryBindingsContext *v5; // edi@1
  int result; // eax@1
  signed int v7; // eax@9
  int v8; // eax@11
  int v9; // ecx@11
  bool v10; // cf@12
  unsigned __int16 v11; // dx@14
  int v12; // eax@17
  signed int v13; // eax@20
  int v14; // ecx@20
  int v15; // eax@21
  signed int v16; // eax@22
  int v17; // eax@23
  int v18; // eax@28
  wchar_t *v19; // eax@61
  wchar_t v20; // cx@62
  int v21; // edi@62
  int v22; // eax@71
  const unsigned __int16 *v23; // [sp-8h] [bp-C58h]@22
  size_t v24; // [sp-4h] [bp-C54h]@22
  LSA_UNICODE_STRING v25; // [sp+Ch] [bp-C44h]@20
  LSA_UNICODE_STRING DestinationString; // [sp+14h] [bp-C3Ch]@1
  LSA_UNICODE_STRING v27; // [sp+1Ch] [bp-C34h]@20
  LPVOID pv; // [sp+24h] [bp-C2Ch]@44
  unsigned __int32 v29; // [sp+28h] [bp-C28h]@44
  int v30; // [sp+2Ch] [bp-C24h]@34
  SP_LOG_TOKEN LogToken; // [sp+30h] [bp-C20h]@1
  unsigned __int32 i; // [sp+38h] [bp-C18h]@37
  CRegistryBindingsContext *v33; // [sp+3Ch] [bp-C14h]@1
  CDynamicBuffer *v34; // [sp+40h] [bp-C10h]@2
  int v35; // [sp+44h] [bp-C0Ch]@28
  int v36; // [sp+48h] [bp-C08h]@10
  __int16 pszDest[512]; // [sp+4Ch] [bp-C04h]@36
  wchar_t v38; // [sp+44Ch] [bp-804h]@36
  wchar_t v39[512]; // [sp+84Ch] [bp-404h]@8

  v5 = this;
  v33 = this;
  DestinationString.Buffer = 0;
  LogToken = SetupGetThreadLogToken();
  result = CComponent::FIsBindable(rguid);
  if ( result )
  {
    v10 = *((_DWORD *)v5 + 8) < 2u;
    v34 = (CRegistryBindingsContext *)((char *)v5 + 24);
    if ( !v10 )
      **((_WORD **)v5 + 6) = 0;
    *((_DWORD *)v5 + 7) = 0;
    if ( *((_DWORD *)v5 + 12) >= 2u )
      **((_WORD **)v5 + 10) = 0;
    *((_DWORD *)v5 + 11) = 0;
    if ( *((_DWORD *)v5 + 16) >= 2u )
      **((_WORD **)v5 + 14) = 0;
    *((_DWORD *)v5 + 15) = 0;
    StringCchCopyW(v39, 0x200u, L"\\Device\\");
    StringCchCatW(v39, 0x200u, *((STRSAFE_LPCWSTR *)rguid + 25));
    CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 40), v39);
    CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 40), &String);
    if ( FIsConsideredNetClass(*((_DWORD *)rguid + 4)) )
    {
      v7 = CRegistryBindingsContext::HrGetAdapterUpperBindValue(v5, rguid);
LABEL_10:
      v36 = v7;
      if ( !v7 )
        goto LABEL_11;
      return v36;
    }
    v36 = CNetConfigCore::HrGetComponentBindings(
            *(CNetConfigCore **)v5,
            rguid,
            2u,
            (CRegistryBindingsContext *)((char *)v5 + 4));
    if ( v36 )
      return v36;
    if ( !std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v5 + 8)) )
    {
LABEL_11:
      v8 = *((_DWORD *)rguid + 7);
      v9 = (int)L"ms_netbios";
      do
      {
        v10 = *(_WORD *)v8 < *(_WORD *)v9;
        if ( *(_WORD *)v8 != *(_WORD *)v9 )
          goto LABEL_74;
        if ( !*(_WORD *)v8 )
          break;
        v11 = *(_WORD *)(v8 + 2);
        v10 = v11 < *(_WORD *)(v9 + 2);
        if ( v11 != *(_WORD *)(v9 + 2) )
        {
LABEL_74:
          v12 = -v10 - (v10 - 1);
          goto LABEL_18;
        }
        v8 += 4;
        v9 += 4;
      }
      while ( v11 );
      v12 = 0;
LABEL_18:
      if ( !v12 )
      {
        v22 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v5 + 8));
        HrUpdateLanaConfig(*(const struct CComponentList **)v5, *(const unsigned __int16 **)v34, v22);
      }
      v36 = HrWriteLinkageValues(
              (GUID *)rguid,
              *(const unsigned __int16 **)v34,
              *((const unsigned __int16 **)v5 + 10),
              *((const unsigned __int16 **)v5 + 14));
      if ( !v36 )
      {
        RtlInitUnicodeString(&DestinationString, 0);
        RtlInitUnicodeString(&v27, *((PCWSTR *)rguid + 25));
        RtlInitUnicodeString(&v25, 0);
        _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), &byte_6E6530C8);
        v13 = FIsConsideredNetClass(*((_DWORD *)rguid + 4));
        v14 = (int)L"BIND_LIST";
        if ( v13 )
        {
          v15 = (int)L"NDIS";
        }
        else
        {
          v14 = (int)L"RECONFIGURE";
          v15 = (int)L"TDI";
        }
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: Calling NdisHandlePnPEvent [%ws, %ws] with",
          v15,
          v14);
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: %ws %ws",
          *((_DWORD *)rguid + 25),
          *(_DWORD *)v34);
        v16 = FIsConsideredNetClass(*((_DWORD *)rguid + 4));
        v24 = *((_DWORD *)v33 + 7);
        v23 = *(const unsigned __int16 **)v34;
        if ( v16 )
          v17 = NdisHandlePnPEvent(1, 9, (int)&DestinationString, (int)&v27, (int)&v25, (void *)v23, v24);
        else
          v17 = NdisHandlePnPEvent(2, 3, (int)&DestinationString, (int)&v27, (int)&v25, (void *)v23, v24);
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: NdisHandlePnPEvent result 0x%08x\r\n\r\n",
          v17);
      }
      return v36;
    }
    if ( *((_DWORD *)v5 + 12) >= 2u )
      **((_WORD **)v5 + 10) = 0;
    *((_DWORD *)v5 + 11) = 0;
    v2 = *((_DWORD *)v5 + 3);
    v30 = v2;
    if ( v2 == *((_DWORD *)v5 + 4) )
    {
LABEL_53:
      v36 = CDynamicBuffer::HrCopyString(v34, &String);
      if ( v36 )
        return v36;
      v36 = CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 40), &String);
      if ( v36 )
        return v36;
      v7 = CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 56), &String);
      goto LABEL_10;
    }
    v36 = v2 + 8;
    while ( 1 )
    {
      StringCchCopyW((unsigned __int16 *)pszDest, 0x200u, L"\\Device\\");
      StringCchCopyW(v39, 0x200u, L"\\Device\\");
      v38 = 0;
      v18 = *(_DWORD *)v36;
      v35 = v18;
      if ( v18 != *(_DWORD *)(v36 + 4) )
        break;
LABEL_48:
      if ( v18 != *(_DWORD *)(v36 + 4)
        || !CDynamicBuffer::HrCopyString(v34, (const unsigned __int16 *)pszDest)
        && !CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 40), v39)
        && !CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v5 + 56), &v38) )
      {
        v30 += 20;
        v36 += 20;
        if ( v30 != *((_DWORD *)v5 + 4) )
          continue;
      }
      goto LABEL_53;
    }
    i = v18 + 4;
    while ( 1 )
    {
      v3 = *(_DWORD *)v18;
      if ( v18 != *(_DWORD *)v36 )
      {
        if ( v18 != *(_DWORD *)v36 + 4 )
        {
          StringCchCatW((STRSAFE_LPWSTR)pszDest, 0x200u, L"_");
          StringCchCatW(&v38, 0x200u, L" ");
        }
        StringCchCatW((STRSAFE_LPWSTR)pszDest, 0x200u, *(STRSAFE_LPCWSTR *)(v3 + 100));
        StringCchCatW(&v38, 0x200u, L"\"");
        StringCchCatW(&v38, 0x200u, *(STRSAFE_LPCWSTR *)(v3 + 100));
        StringCchCatW(&v38, 0x200u, L"\"");
        v18 = v35;
      }
      if ( v18 != *(_DWORD *)v36 )
        StringCchCatW(v39, 0x200u, L"_");
      StringCchCatW(v39, 0x200u, *(STRSAFE_LPCWSTR *)(v3 + 100));
      if ( i == *(_DWORD *)(v36 + 4) - 4 )
      {
        v4 = *(struct CImplINetCfg **)(*(_DWORD *)v33 + 68);
        v27.Buffer = *(PWSTR *)i;
        if ( CNotifyObjectInterface::HrGetInterfaceIdsForAdapter(
               (CNotifyObjectInterface *)(v3 + 112),
               v4,
               (const struct CComponent *)v27.Buffer,
               &v29,
               (struct _GUID **)&pv) < 0 )
          goto LABEL_28;
        if ( v29 )
          break;
      }
      v35 += 4;
      i += 4;
      v18 = v35;
      if ( v35 == *(_DWORD *)(v36 + 4) )
        goto LABEL_47;
    }
    if ( v35 == *(_DWORD *)v36 )
    {
      StringCchCatW((STRSAFE_LPWSTR)pszDest, 0x200u, *((STRSAFE_LPCWSTR *)v27.Buffer + 25));
      if ( CDynamicBuffer::HrCopyString(v34, (const unsigned __int16 *)pszDest) )
        goto LABEL_28;
    }
    else
    {
      StringCchCatW((STRSAFE_LPWSTR)pszDest, 0x200u, L"_");
      DestinationString.Buffer = (PWSTR)&pszDest[wcslen((const unsigned __int16 *)pszDest)];
    }
    StringCchCatW(v39, 0x200u, L"_");
    v19 = v39;
    do
    {
      v20 = *v19;
      v21 = 0;
      ++v19;
    }
    while ( v20 );
    v25.Buffer = &v39[v19 - &v39[1]];
    for ( i = 0; i < v29; v21 += 16 )
    {
      if ( v35 != *(_DWORD *)v36 )
      {
        StringFromGUID2((const GUID *const )((char *)pv + v21), DestinationString.Buffer, 39);
        if ( CDynamicBuffer::HrCopyString(v34, (const unsigned __int16 *)pszDest) )
          break;
      }
      StringFromGUID2((const GUID *const )((char *)pv + v21), v25.Buffer, 39);
      if ( CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v33 + 40), v39) )
        break;
      ++i;
    }
    CoTaskMemFree(pv);
    if ( v35 != *(_DWORD *)v36 )
      StringCchCatW(&v38, 0x200u, L" ");
    StringCchCatW(&v38, 0x200u, L"\"");
    StringCchCatW(&v38, 0x200u, *((STRSAFE_LPCWSTR *)v27.Buffer + 25));
    StringCchCatW(&v38, 0x200u, L"\"");
    CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v33 + 56), &v38);
LABEL_28:
    v18 = v35;
LABEL_47:
    v5 = v33;
    goto LABEL_48;
  }
  return result;
}
// 6E651DA0: using guessed type wchar_t aTdi[4];
// 6E652EA0: using guessed type wchar_t aMs_netbios_0[11];
// 6E65309C: using guessed type wchar_t aReconfigure[12];
// 6E6530B4: using guessed type wchar_t aBind_list[10];
// 6E6550E8: using guessed type wchar_t aNdis[5];
// 6E69B2C8: using guessed type int g_IsInUpgrade;
// 6E652D7C: using guessed type wchar_t pszDest[512];

//----- (6E6530E9) --------------------------------------------------------
unsigned __int32 __thiscall CFilterDevices::MapFilterClassToOrdinal(CFilterDevices *this, const unsigned __int16 *Str1)
{
  const unsigned __int16 *v2; // ebx@1
  CFilterDevices *v3; // esi@1
  unsigned __int32 v4; // edi@4
  unsigned __int32 result; // eax@5
  int v6; // eax@12
  int v7; // [sp+8h] [bp-10h]@14
  unsigned __int16 *v8; // [sp+Ch] [bp-Ch]@14
  unsigned __int32 v9; // [sp+10h] [bp-8h]@3
  unsigned __int32 v10; // [sp+14h] [bp-4h]@3

  v2 = Str1;
  v3 = this;
  if ( _wcsicmp(Str1, L"ms_firewall_lower") )
  {
    if ( CFilterDevices::IsMediumConverterOrLower((wchar_t *)v2) )
    {
      if ( _wcsicmp(v2 + 20, L"top") )
      {
        if ( _wcsicmp(v2 + 20, L"bottom") && (v6 = _wtoi(v2 + 20), v6 - 255 >= (unsigned int)v6) )
          result = v6 - 255;
        else
          result = -1;
      }
      else
      {
        result = -255;
      }
    }
    else
    {
      if ( FGetSzPositionInMultiSzSafe((wchar_t *)v2, *((wchar_t **)v3 + 11), &v10, 0, &v9) )
      {
        v4 = v10 + 1;
      }
      else
      {
        v4 = v9 + 1;
        if ( !HrAddSzToMultiSz((wchar_t *)v2, *((wchar_t **)v3 + 11), 4u, 0, &v8, &v7) )
        {
          MemFree(*((void **)v3 + 11));
          *((_DWORD *)v3 + 11) = v8;
          if ( !HrOpenNetworkKey(0x20006u, (PHKEY)&Str1) )
          {
            HrRegSetMultiSz((HKEY)Str1, L"FilterClasses", *((BYTE **)v3 + 11));
            RegCloseKey((HKEY)Str1);
          }
        }
      }
      result = v4;
    }
  }
  else
  {
    result = -256;
  }
  return result;
}

//----- (6E65316D) --------------------------------------------------------
int __stdcall FGetSzPositionInMultiSzSafe(wchar_t *Str2, wchar_t *Str1, unsigned __int32 *a3, int *a4, unsigned __int32 *a5)
{
  unsigned __int32 *v5; // eax@2
  wchar_t *v6; // esi@4
  unsigned __int32 v7; // edi@6
  int result; // eax@12
  signed int Str1a; // [sp+14h] [bp+Ch]@6

  *a3 = 0;
  if ( a4 )
    *a4 = 0;
  v5 = a5;
  if ( a5 )
    *a5 = 0;
  v6 = Str1;
  if ( Str1 && Str2 )
  {
    v7 = 0;
    Str1a = 0;
    if ( *v6 )
    {
      do
      {
        if ( !_wcsicmp(v6, Str2) )
        {
          if ( Str1a )
          {
            if ( a4 )
              *a4 = 1;
          }
          else
          {
            *a3 = v7;
            Str1a = 1;
          }
        }
        v6 += wcslen(v6) + 1;
        ++v7;
      }
      while ( *v6 );
      v5 = a5;
    }
    if ( v5 )
      *v5 = v7;
    result = Str1a;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E653253) --------------------------------------------------------
__int32 __thiscall CNetConfigCore::HrGetComponentUpperBindings(CNetConfigCore *this, const struct CComponent *a2, char a3, struct CBindingSet *a4)
{
  CNetConfigCore *v4; // edi@1
  __int32 v5; // ebx@3
  __int32 v6; // eax@4
  int v7; // esi@4
  char v9; // [sp+Ch] [bp-24h]@3
  char v10; // [sp+10h] [bp-20h]@1
  unsigned __int32 v11; // [sp+20h] [bp-10h]@1
  int v12; // [sp+2Ch] [bp-4h]@1

  v4 = this;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v10, 0);
  v12 = 0;
  v11 = 1536;
  if ( !(a3 & 1) )
  {
    std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)a4 + 4));
    v11 = 1280;
  }
  v5 = CBindPath::HrReserveRoomForComponents((CBindPath *)&v9, 2u);
  if ( !v5 )
  {
    v6 = CBindPath::HrInsertComponent((CBindPath *)&v9, a2);
    v7 = *((_DWORD *)v4 + 7);
    v5 = v6;
    while ( v7 != *((_DWORD *)v4 + 8) )
    {
      if ( a2 == *(const struct CComponent **)(v7 + 4)
        && (!(a3 & 2)
         || !CNetConfigCore::FIsLength2BindPathDisabled(
               v4,
               *(const struct CComponent **)v7,
               *(const struct CComponent **)(v7 + 4))) )
      {
        CBindPath::HrInsertComponent((CBindPath *)&v9, *(const struct CComponent **)v7);
        v5 = CBindingSet::HrAddBindPath(a4, (const struct CBindPath *)&v9, v11);
        if ( v5 )
          break;
        CBindPath::RemoveFirstComponent((CBindPath *)&v9);
      }
      v7 += 8;
    }
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v10);
  return v5;
}

//----- (6E653316) --------------------------------------------------------
__int32 __stdcall HrWriteLinkageValues(GUID *rguid, const unsigned __int16 *a2, const unsigned __int16 *a3, const unsigned __int16 *a4)
{
  unsigned __int32 v4; // eax@1
  unsigned __int32 v5; // eax@3
  unsigned int i; // eax@7
  bool v7; // zf@8
  unsigned int j; // eax@10
  __int32 v9; // eax@16
  HKEY hKey; // [sp+18h] [bp-21Ch]@13
  SP_LOG_TOKEN LogToken; // [sp+1Ch] [bp-218h]@1
  __int32 v13; // [sp+24h] [bp-210h]@8
  BYTE Data[2]; // [sp+28h] [bp-20Ch]@15
  __int16 v15[259]; // [sp+2Ah] [bp-20Ah]@15

  LogToken = SetupGetThreadLogToken();
  v4 = rguid[2].Data1;
  if ( !v4 )
    v4 = *(_DWORD *)&rguid[1].Data4[4];
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S  (%S)\n", *(_DWORD *)&rguid[6].Data2, v4);
  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:");
  v5 = rguid[2].Data1;
  if ( !v5 )
    v5 = *(_DWORD *)&rguid[1].Data4[4];
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "NCI: Writing Network Linkage information for %ws",
    v5);
  if ( FIsConsideredNetClass(rguid[1].Data1) )
  {
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      UpperBind:\n");
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:      UpperBind:");
  }
  else
  {
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      Bind:\n");
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:      Bind:");
  }
  for ( i = (unsigned int)a2; ; i = v13 + 2 * wcslen((const unsigned __int16 *)v13) + 2 )
  {
    v7 = *(_WORD *)i == 0;
    v13 = i;
    if ( v7 )
      break;
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "         %S\n", v13);
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:         %ws", v13);
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      Export:\n");
  _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:      Export:");
  for ( j = (unsigned int)a3; ; j = v13 + 2 * wcslen((const unsigned __int16 *)v13) + 2 )
  {
    v7 = *(_WORD *)j == 0;
    v13 = j;
    if ( v7 )
      break;
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "         %S\n", v13);
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI:         %ws", v13);
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
  v13 = HrCreateLinkageKey(rguid, 0, 0, &hKey);
  if ( !v13 )
  {
    if ( FIsConsideredNetClass(rguid[1].Data1) )
    {
      StringCchCopyW((unsigned __int16 *)Data, 0x104u, *(const unsigned __int16 **)&rguid[6].Data2);
      v15[wcslen((const unsigned __int16 *)Data)] = 0;
      v13 = HrRegSetMultiSzAndLogDifference(hKey, L"RootDevice", Data, (const struct CComponent *)rguid);
      if ( !v13 )
      {
        v9 = HrRegSetMultiSzAndLogDifference(hKey, L"UpperBind", (BYTE *)a2, (const struct CComponent *)rguid);
LABEL_17:
        v13 = v9;
        if ( !v9 && *a3 )
          v13 = HrRegSetMultiSzAndLogDifference(hKey, L"Export", (BYTE *)a3, (const struct CComponent *)rguid);
        goto LABEL_20;
      }
    }
    else
    {
      v13 = HrRegSetMultiSzAndLogDifference(hKey, L"Bind", (BYTE *)a2, (const struct CComponent *)rguid);
      if ( !v13 )
      {
        v9 = HrRegSetMultiSzAndLogDifference(hKey, L"Route", (BYTE *)a4, (const struct CComponent *)rguid);
        goto LABEL_17;
      }
    }
LABEL_20:
    RegCloseKey(hKey);
  }
  if ( v13 < 0 && v13 != -2146500085 )
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!! NCI: Error 0x%08x writing linkage information",
      v13);
  return v13;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;
// 6E653316: using guessed type __int16 var_20A[259];

//----- (6E653719) --------------------------------------------------------
void __thiscall CFilteredAdapter::SortFilters(CFilteredAdapter *this)
{
  CFilteredAdapter *v1; // esi@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // eax@5

  v1 = this;
  v2 = (int)((char *)this + 28);
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 28)) )
  {
    v3 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v2);
    qsort(*((void **)v1 + 8), v3, 4u, (int (__cdecl *)(const void *, const void *))CompareModifyingFilters);
  }
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)v1 + 8)) )
  {
    v4 = std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)v1 + 8));
    qsort(*((void **)v1 + 3), v4, 4u, (int (__cdecl *)(const void *, const void *))CompareMonitoringFilters);
  }
}

//----- (6E653761) --------------------------------------------------------
void __cdecl qsort(void *Base, size_t NumOfElements, size_t SizeOfElements, int (__cdecl *PtFuncCompare)(const void *, const void *))
{
  unsigned int v4; // ebx@1
  int v5; // edi@2
  unsigned int v6; // esi@6
  unsigned int v7; // eax@7
  int v8; // eax@9
  const void *v9; // edi@14
  size_t v10; // edx@29
  unsigned int v11; // eax@29
  int v12; // ecx@30
  int v13; // eax@38
  int v14; // edx@41
  int v15; // ecx@43
  int v16; // ecx@47
  int v17; // edx@10
  int v18; // eax@10
  int v19[30]; // [sp+8h] [bp-100h]@10
  int v20[30]; // [sp+80h] [bp-88h]@10
  size_t v21; // [sp+F8h] [bp-10h]@31
  int v22; // [sp+FCh] [bp-Ch]@6
  char *v23; // [sp+100h] [bp-8h]@6
  void *v24; // [sp+104h] [bp-4h]@6
  char Base_3; // [sp+113h] [bp+Bh]@31

  v4 = (unsigned int)Base;
  if ( !Base && NumOfElements )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return;
  }
  v5 = SizeOfElements;
  if ( SizeOfElements && PtFuncCompare )
  {
    if ( NumOfElements < 2 )
      return;
    v6 = (unsigned int)((char *)Base + SizeOfElements * (NumOfElements - 1));
    v22 = 0;
    v24 = Base;
    v23 = (char *)Base + SizeOfElements * (NumOfElements - 1);
    while ( 1 )
    {
      v7 = (v6 - v4) / v5 + 1;
      if ( v7 <= 8 )
      {
        sub_6E6537E8(v6, v4, v5, (int (__cdecl *)(_DWORD, _DWORD))PtFuncCompare);
        goto LABEL_9;
      }
      v9 = (const void *)(v4 + v5 * (v7 >> 1));
      if ( PtFuncCompare((const void *)v4, v9) > 0 )
        swap(v9, SizeOfElements);
      if ( PtFuncCompare((const void *)v4, (const void *)v6) > 0 )
        swap(v6, SizeOfElements);
      if ( PtFuncCompare(v9, (const void *)v6) > 0 )
        swap(v6, SizeOfElements);
      while ( 1 )
      {
        if ( (unsigned int)v9 > v4 )
        {
          while ( 1 )
          {
            v4 += SizeOfElements;
            if ( v4 >= (unsigned int)v9 )
              break;
            if ( PtFuncCompare((const void *)v4, v9) > 0 )
            {
              if ( (unsigned int)v9 > v4 )
                goto LABEL_26;
              goto LABEL_24;
            }
          }
        }
        do
LABEL_24:
          v4 += SizeOfElements;
        while ( v4 <= (unsigned int)v23 && PtFuncCompare((const void *)v4, v9) <= 0 );
        do
LABEL_26:
          v6 -= SizeOfElements;
        while ( v6 > (unsigned int)v9 && PtFuncCompare((const void *)v6, v9) > 0 );
        if ( v4 > v6 )
          break;
        v10 = SizeOfElements;
        v11 = v6;
        if ( v4 != v6 )
        {
          v12 = v4 - v6;
          do
          {
            v21 = v10 - 1;
            Base_3 = *(_BYTE *)(v12 + v11);
            *(_BYTE *)(v12 + v11) = *(_BYTE *)v11;
            *(_BYTE *)v11 = Base_3;
            v10 = v21;
            ++v11;
          }
          while ( v21 );
        }
        if ( v9 == (const void *)v6 )
          v9 = (const void *)v4;
      }
      v6 += SizeOfElements;
      if ( (unsigned int)v9 >= v6 )
        goto LABEL_38;
      do
      {
        v6 -= SizeOfElements;
        if ( v6 <= (unsigned int)v9 )
          goto LABEL_38;
      }
      while ( !PtFuncCompare((const void *)v6, v9) );
      if ( (unsigned int)v9 < v6 )
      {
LABEL_40:
        v13 = (int)v24;
      }
      else
      {
LABEL_38:
        while ( 1 )
        {
          v6 -= SizeOfElements;
          v13 = (int)v24;
          if ( v6 <= (unsigned int)v24 )
            break;
          if ( PtFuncCompare((const void *)v6, v9) )
            goto LABEL_40;
        }
      }
      v14 = (int)v23;
      if ( (signed int)(v6 - v13) < (signed int)&v23[-v4] )
      {
        if ( v4 < (unsigned int)v23 )
        {
          v16 = v22;
          v20[v22] = v4;
          v19[v16] = v14;
          v22 = v16 + 1;
        }
        if ( v13 >= v6 )
          goto LABEL_50;
        v4 = (unsigned int)v24;
        v5 = SizeOfElements;
        v23 = (char *)v6;
      }
      else
      {
        if ( v13 < v6 )
        {
          v15 = v22;
          v20[v22] = v13;
          v19[v15] = v6;
          v22 = v15 + 1;
        }
        if ( v4 >= v14 )
        {
LABEL_50:
          v5 = SizeOfElements;
LABEL_9:
          v8 = v22-- - 1;
          if ( v22 < 0 )
            return;
          v17 = v20[v8];
          v18 = v19[v8];
          v24 = (void *)v17;
          v23 = (char *)v18;
          v4 = v17;
          v6 = v18;
        }
        else
        {
          v6 = (unsigned int)v23;
          v5 = SizeOfElements;
          v24 = (void *)v4;
        }
      }
    }
  }
  *_errno() = 22;
  _invalid_parameter(0, 0, 0, 0, 0);
}
// 6E676E8D: using guessed type int __fastcall swap(_DWORD, _DWORD);
// 6E653761: using guessed type int var_88[30];
// 6E653761: using guessed type int var_100[30];

//----- (6E6537E8) --------------------------------------------------------
unsigned int __usercall sub_6E6537E8@<eax>(unsigned int result@<eax>, unsigned int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD))
{
  unsigned int v4; // edx@1
  unsigned int v5; // edi@1
  int v6; // ecx@2
  unsigned int v7; // esi@3
  unsigned int v8; // ebx@3
  int v9; // esi@8
  int v10; // ecx@12
  char v11; // dl@13

  v4 = a2;
  v5 = result;
  if ( result > a2 )
  {
    v6 = a3;
    do
    {
      v7 = a2 + a3;
      v8 = v4;
      if ( a2 + a3 <= v5 )
      {
        do
        {
          if ( a4(v7, v8) > 0 )
            v8 = v7;
          v7 += a3;
        }
        while ( v7 <= v5 );
        v6 = a3;
        v4 = a2;
      }
      v9 = v6;
      result = v5;
      if ( v8 != v5 && v6 )
      {
        v10 = v8 - v5;
        do
        {
          v11 = *(_BYTE *)(v10 + result);
          *(_BYTE *)(v10 + result) = *(_BYTE *)result;
          --v9;
          *(_BYTE *)result++ = v11;
        }
        while ( v9 );
        v6 = a3;
        v4 = a2;
      }
      v5 -= v6;
    }
    while ( v5 > v4 );
  }
  return result;
}

//----- (6E653848) --------------------------------------------------------
void __thiscall CRegistryBindingsContext::PnpBindOrUnbindBindPaths(CRegistryBindingsContext *this, unsigned int a2, struct CBindingSet *a3, unsigned __int32 a4, int *a5)
{
  struct CBindingSet *v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@4
  int v8; // ebx@5
  int v9; // edi@8
  int v10; // eax@13
  int v11; // ecx@13
  int v12; // eax@13
  unsigned __int32 v13; // [sp+8h] [bp-414h]@11
  CRegistryBindingsContext *v14; // [sp+Ch] [bp-410h]@1
  struct CBindingSet *v15; // [sp+10h] [bp-40Ch]@1
  int *v16; // [sp+14h] [bp-408h]@1
  wchar_t pszDest; // [sp+18h] [bp-404h]@4

  *a5 = 0;
  v5 = a3;
  v14 = this;
  v15 = a3;
  v16 = a5;
  PruneNdisWanBindPathsIfActiveRasConnections(a4, a3, a5);
  v6 = *((_DWORD *)a3 + 2);
  if ( v6 != *((_DWORD *)a3 + 3) )
  {
    do
    {
      if ( !(*(_DWORD *)(**(_DWORD **)(v6 + 8) + 24) & 0x40000) )
      {
        if ( (unsigned int)std::vector<CParam *,std::nc_allocator<CParam *>>::size(v6 + 4) <= 2
          || (v10 = *(_DWORD *)(v6 + 12), v11 = *(_DWORD *)(v10 - 8),
                                          v12 = *(_DWORD *)(v10 - 4),
                                          !*(_DWORD *)(v11 + 124))
          || !*(_DWORD *)(v12 + 124)
          || CNotifyObjectInterface::HrGetInterfaceIdsForAdapter(
               (CNotifyObjectInterface *)(v11 + 112),
               *(struct CImplINetCfg **)(*(_DWORD *)v14 + 68),
               (const struct CComponent *)v12,
               &v13,
               0) )
        {
          StringCchCopyW(&pszDest, 0x200u, L"\\Device\\");
          v7 = *(_DWORD *)(v6 + 8) + 4;
          if ( v7 != *(_DWORD *)(v6 + 12) )
          {
            do
            {
              v8 = *(_DWORD *)v7;
              if ( v7 != *(_DWORD *)(v6 + 8) + 4 )
                StringCchCatW(&pszDest, 0x200u, L"_");
              StringCchCatW(&pszDest, 0x200u, *(STRSAFE_LPCWSTR *)(v8 + 100));
              v7 += 4;
            }
            while ( v7 != *(_DWORD *)(v6 + 12) );
            v5 = v15;
          }
          v9 = GetPnpLayerForBindPath((const struct CBindPath *)v6);
          if ( HrPnpBindOrUnbind(v9, a2, *(PCWSTR *)(**(_DWORD **)(v6 + 8) + 100), &pszDest) )
          {
            if ( v9 != 1 )
              *v16 = 1;
          }
        }
      }
      v6 += 20;
    }
    while ( v6 != *((_DWORD *)v5 + 3) );
  }
}

//----- (6E65395C) --------------------------------------------------------
int __stdcall HrPnpBindOrUnbind(unsigned int a1, unsigned int a2, PCWSTR a3, PCWSTR SourceString)
{
  int v4; // ecx@1
  char v5[4]; // eax@3
  signed int v7; // esi@10
  int v8; // ecx@10
  int v9; // eax@12
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-34h]@4
  LSA_UNICODE_STRING v11; // [sp+14h] [bp-2Ch]@4
  SP_LOG_TOKEN LogToken; // [sp+1Ch] [bp-24h]@1
  int v13; // [sp+24h] [bp-1Ch]@4
  const WCHAR *v14; // [sp+28h] [bp-18h]@4
  int v15; // [sp+2Ch] [bp-14h]@1
  int v16; // [sp+3Ch] [bp-4h]@4

  v15 = 0;
  LogToken = SetupGetThreadLogToken();
  v4 = (int)"BIND";
  if ( a2 != 1 )
    v4 = (int)"UNBIND";
  *(_DWORD *)v5 = "NDIS";
  if ( a1 != 1 )
    *(_DWORD *)v5 = "TDI";
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   PnP Event: %s %s %S - %S\n", *(_DWORD *)v5, v4, a3, SourceString);
  RtlInitUnicodeString(&DestinationString, SourceString);
  RtlInitUnicodeString(&v11, a3);
  v14 = &String;
  v13 = 131074;
  v16 = 0;
  if ( (!(CDiagContext::Flags(g_pDiagCtx) & 4) || a2 != 1)
    && !NdisHandlePnPEvent(a1, a2, (int)&DestinationString, (int)&v11, (int)&v13, 0, 0) )
  {
    v7 = GetLastError();
    v8 = (int)L"NDIS";
    if ( a1 != 1 )
      v8 = (int)L"TDI";
    v9 = (int)L"BIND";
    if ( a2 != 1 )
      v9 = (int)L"UNBIND";
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      2u,
      "!NCI: Op=%ws, Layer=%ws, Upper=%ws Lower=%ws, Error=%08x",
      v9,
      v8,
      a3,
      SourceString,
      v7);
    if ( a1 == 2 && v7 == 31 )
      v7 = 2;
    if ( v7 != 2 )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      ^^^ Error = %d\n", v7);
      if ( v7 > 0 )
        v7 = (unsigned __int16)v7 | 0x80070000;
      v15 = v7;
    }
  }
  return v15;
}
// 6E651DA0: using guessed type wchar_t aTdi[4];
// 6E6550E8: using guessed type wchar_t aNdis[5];
// 6E659948: using guessed type wchar_t aUnbind[7];
// 6E659958: using guessed type wchar_t aBind[5];

//----- (6E653A5E) --------------------------------------------------------
int __stdcall NdisHandlePnPEvent(int a1, int a2, int a3, int a4, int a5, void *Src, size_t Size)
{
  signed int v7; // edi@2
  int v8; // ecx@10
  int v9; // eax@11
  int v10; // eax@12
  int v11; // esi@16
  int v12; // ecx@17
  int v13; // eax@18
  int v14; // ecx@20
  int v15; // esi@22
  int v16; // ecx@23
  int v17; // eax@24
  int v18; // ecx@26
  int v19; // eax@28
  int v20; // edx@28
  SIZE_T v21; // eax@28
  int v22; // ebx@31
  HANDLE v23; // esi@34
  char v25; // [sp+Ch] [bp-34h]@32
  int v26; // [sp+14h] [bp-2Ch]@28
  int v27; // [sp+20h] [bp-20h]@10
  int v28; // [sp+28h] [bp-18h]@16
  int v29; // [sp+30h] [bp-10h]@22
  DWORD BytesReturned; // [sp+34h] [bp-Ch]@35
  DWORD nInBufferSize; // [sp+38h] [bp-8h]@28
  int v32; // [sp+3Ch] [bp-4h]@1

  v32 = 0;
  if ( a1 != 1 && a1 != 2 )
    goto LABEL_52;
  v7 = 8;
  if ( a2 != 1
    && a2 != 2
    && a2 != 3
    && a2 != 5
    && a2 != 6
    && a2 != 7
    && a2 != 8
    && a2 != 9
    && a2 != 10
    && a2 != 11
    && a2 != 14 )
    goto LABEL_52;
  v8 = a3;
  v27 = 40;
  v9 = a3 ? *(_WORD *)a3 : 0;
  v10 = v9 + 42;
  if ( (unsigned int)v10 < 0x28 )
    goto LABEL_52;
  if ( a3 )
    v8 = *(_WORD *)a3;
  if ( v10 < (unsigned int)(v8 + 2)
    || ((v28 = v10, v11 = v10, !a4) ? (v12 = 0) : (v12 = *(_WORD *)a4),
        (v13 = v10 + v12 + 2, v13 < (unsigned int)v11)
     || (!a4 ? (v14 = 0) : (v14 = *(_WORD *)a4),
         v13 < (unsigned int)(v14 + 2)
      || ((v29 = v13, v15 = v13, !a5) ? (v16 = 0) : (v16 = *(_WORD *)a5),
          (v17 = v13 + v16 + 2, v17 < (unsigned int)v15)
       || (!a5 ? (v18 = 0) : (v18 = *(_WORD *)a5),
           v17 < (unsigned int)(v18 + 2)
        || (v19 = (-v17 & 3) + v17, v20 = v19, v26 = v19, v21 = v19 + Size + 1, nInBufferSize = v21, v21 < v20)
        || v21 < Size
        || v21 < 1)))) )
  {
LABEL_52:
    v7 = 87;
  }
  else
  {
    v22 = (int)LocalAlloc(0x40u, v21);
    if ( v22 )
    {
      qmemcpy((void *)v22, &v25, 0x28u);
      *(_DWORD *)v22 = a1;
      *(_DWORD *)(v22 + 4) = a2;
      NdispUnicodeStringToVar(v22, a3, v22 + 16);
      NdispUnicodeStringToVar(v22, a4, v22 + 24);
      NdispUnicodeStringToVar(v22, a5, v22 + 32);
      *(_DWORD *)(v22 + 12) = Size;
      if ( Size )
        memcpy((void *)(v22 + *(_DWORD *)(v22 + 8)), Src, Size);
      *(_BYTE *)(v22 + *(_DWORD *)(v22 + 8) + Size) = 0;
      v23 = CreateFileW(L"\\\\.\\NDIS", 0xC0000000, 0, 0, 3u, 0, 0);
      if ( v23 == (HANDLE)-1 )
      {
        v7 = GetLastError();
      }
      else
      {
        v32 = DeviceIoControl(v23, 0x170008u, (LPVOID)v22, nInBufferSize, 0, 0, &BytesReturned, 0);
        v7 = GetLastError();
        CloseHandle(v23);
      }
      LocalFree((HLOCAL)v22);
    }
  }
  SetLastError(v7);
  return v32;
}

//----- (6E653C72) --------------------------------------------------------
signed int __thiscall CRegistryBindingsContext::HrGetAdapterUpperBindValue(CRegistryBindingsContext *this, const struct CComponent *a2)
{
  CRegistryBindingsContext *v2; // esi@1
  CDynamicBuffer *v3; // edi@1
  signed int result; // eax@3
  int i; // ebx@4
  int v6; // eax@6

  v2 = this;
  v3 = (CRegistryBindingsContext *)((char *)this + 24);
  if ( *((_DWORD *)this + 8) >= 2u )
    **(_WORD **)v3 = 0;
  *((_DWORD *)this + 7) = 0;
  result = CNetConfigCore::HrGetComponentUpperBindings(
             *(CNetConfigCore **)this,
             a2,
             2,
             (CRegistryBindingsContext *)((char *)this + 4));
  if ( !result )
  {
    for ( i = *((_DWORD *)v2 + 3); ; i += 20 )
    {
      if ( i != *((_DWORD *)v2 + 4) )
      {
        v6 = **(_DWORD **)(i + 8);
        if ( *(_DWORD *)(v6 + 24) & 0x40400 || !CDynamicBuffer::HrCopyString(v3, *(const unsigned __int16 **)(v6 + 100)) )
          continue;
      }
      break;
    }
    result = CDynamicBuffer::HrCopyString(v3, &String);
  }
  return result;
}

//----- (6E653CE5) --------------------------------------------------------
signed int __thiscall CDynamicBuffer::HrCopyString(CDynamicBuffer *this, const unsigned __int16 *a2)
{
  CDynamicBuffer *v2; // esi@1
  unsigned __int32 v3; // eax@1

  v2 = this;
  v3 = CbOfSzAndTermSafe(a2);
  return CDynamicBuffer::HrCopyBytes(v2, (const unsigned __int8 *)a2, v3);
}

//----- (6E653D0A) --------------------------------------------------------
signed int __thiscall CDynamicBuffer::HrCopyBytes(CDynamicBuffer *this, const unsigned __int8 *Src, unsigned __int32 Size)
{
  CDynamicBuffer *v3; // esi@1
  signed int result; // eax@2

  v3 = this;
  if ( Size <= *((_DWORD *)this + 2) - *((_DWORD *)this + 1) || CDynamicBuffer::FGrowBuffer(this, Size) )
  {
    memcpy((void *)(*(_DWORD *)v3 + *((_DWORD *)v3 + 1)), Src, Size);
    *((_DWORD *)v3 + 1) += Size;
    result = 0;
  }
  else
  {
    result = -2147024882;
  }
  return result;
}

//----- (6E65487C) --------------------------------------------------------
void __thiscall CFilterDevices::~CFilterDevices(CFilterDevices *this)
{
  int v1; // esi@1

  v1 = (int)this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)this + 52));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(v1 + 24);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(v1);
}

//----- (6E65489E) --------------------------------------------------------
void __thiscall CFilteredAdapters::DeleteFilterBindings(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // ebx@1
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // edi@2
  const void **v5; // eax@3
  const void **v6; // edi@3
  CComponent *v7; // eax@9
  __int32 v8; // eax@10
  struct _GUID **v9; // eax@13
  struct _GUID **v10; // edi@13
  const struct CComponent **v11; // eax@14
  const struct CComponent **v12; // esi@14
  int v13; // ST04_4@15
  int v14; // edi@15
  char v15; // [sp+8h] [bp-70h]@15
  int v16; // [sp+Ch] [bp-6Ch]@15
  HKEY phkResult; // [sp+10h] [bp-68h]@1
  struct CFilterDevice *v18; // [sp+14h] [bp-64h]@15
  int v19; // [sp+18h] [bp-60h]@1
  struct _GUID *v20; // [sp+1Ch] [bp-5Ch]@3
  HKEY hKey; // [sp+20h] [bp-58h]@1
  OLECHAR sz; // [sp+24h] [bp-54h]@13
  char Dst; // [sp+26h] [bp-52h]@13

  v1 = this;
  v2 = *((_DWORD *)this + 5);
  hKey = 0;
  phkResult = 0;
  v3 = *(_DWORD *)(v2 + 4);
  v19 = v3;
  if ( v3 != *(_DWORD *)(v2 + 8) )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)v3;
      hKey = 0;
      if ( *(_DWORD *)(v4 + 20) )
      {
        sz = 0;
        memset(&Dst, 0, 0x4Cu);
        StringFromGUID2((const GUID *const )(v4 + 4), &sz, 39);
        v9 = (struct _GUID **)CFilterDevices::PFindFilterDeviceByInstanceGuid(*((CFilterDevices **)v1 + 6), &sz);
        v10 = v9;
        if ( !v9 )
          goto LABEL_6;
        v20 = *v9;
        v11 = CFilteredAdapters::PFindEntryByAdapter(v1, (const struct CComponent *)v20);
        v12 = v11;
        if ( v11 )
        {
          v13 = (int)v11[8];
          v16 = (int)v11[9];
          v18 = (struct CFilterDevice *)(v10 + 1);
          v14 = *(_DWORD *)std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(
                             (int)&v15,
                             v13,
                             v16,
                             (int)(v10 + 1))
              + 4;
          if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)(v12 + 2))
            || v14 != v16 && !(*(_DWORD *)(*(_DWORD *)v14 + 24) & 0x400) )
            goto LABEL_6;
          v16 = 0;
          v8 = CFilterDevices::HrFindDeviceAndOpenInstanceKey(
                 *((CFilterDevices **)v1 + 6),
                 (const struct CComponent *)v20,
                 *(const struct CComponent **)v18,
                 (struct CFilterDevice **)&v16,
                 &hKey);
        }
        else
        {
          v18 = 0;
          v8 = CFilterDevices::HrFindDeviceAndOpenInstanceKey(
                 *((CFilterDevices **)v1 + 6),
                 (const struct CComponent *)v20,
                 (const struct CComponent *)v10[1],
                 &v18,
                 &hKey);
        }
      }
      else
      {
        v20 = (struct _GUID *)(v4 + 4);
        v5 = CFilteredAdapters::PFindEntryByAdapterGuid(v1, (const struct _GUID *)(v4 + 4));
        v6 = v5;
        if ( v5 )
        {
          if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)(v5 + 2))
            || !(*(_DWORD *)(*(_DWORD *)v6[8] + 24) & 0x400) )
            goto LABEL_6;
          v8 = CComponent::HrOpenInstanceKey((CComponent *)*v6, 0xF003Fu, &hKey, 0, 0);
        }
        else
        {
          v7 = CComponentList::PFindComponentByInstanceGuid(*((CComponentList **)v1 + 4), v20);
          if ( !v7 )
            goto LABEL_6;
          v8 = CComponent::HrOpenInstanceKey(v7, 0xF003Fu, &hKey, 0, 0);
        }
      }
      if ( !v8 )
      {
        if ( !HrRegOpenKeyEx(hKey, L"Linkage", 0xF003Fu, &phkResult) )
        {
          HrRegDeleteValue(phkResult, L"FilterList");
          RegSafeCloseKey(phkResult);
        }
        RegSafeCloseKey(hKey);
        hKey = 0;
      }
LABEL_6:
      v19 += 4;
      if ( v19 == *(_DWORD *)(*((_DWORD *)v1 + 5) + 8) )
        return;
      v3 = v19;
    }
  }
}

//----- (6E65494D) --------------------------------------------------------
void *__thiscall ATL::CComObject<CMSClient>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CMSClient>::~CComObject<CMSClient>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E654973) --------------------------------------------------------
void __thiscall ATL::CComObject<CMSClient>::~CComObject<CMSClient>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComObject<CMSClient>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CMSClient>::`vftable';
  *(_DWORD *)(this + 8) = &ATL::CComObject<CMSClient>::`vftable';
  *(_DWORD *)(this + 12) = &ATL::CComObject<CMSClient>::`vftable';
  *(_DWORD *)(this + 16) = 1;
  InterlockedDecrement(&Addend);
  CMSClient::~CMSClient((CMSClient *)v1);
}
// 6E641A70: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);
// 6E641A8C: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(CMSClient *, struct _GUID *, void **);
// 6E64AD28: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);
// 6E64AD4C: using guessed type int (__stdcall *ATL::CComObject<CMSClient>::`vftable')(int, int, int);

//----- (6E6549AD) --------------------------------------------------------
void __thiscall CMSClient::~CMSClient(CMSClient *this)
{
  CMSClient *v1; // esi@1

  v1 = this;
  ReleaseObj(*((struct IUnknown **)this + 32));
  ReleaseObj(*((struct IUnknown **)v1 + 33));
  RegSafeCloseKey(*((HKEY *)v1 + 41));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
    0,
    -1);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
    0,
    -1);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
    0,
    -1);
  CMSClient::CleanupPropPages(v1);
  operator delete(*((void **)v1 + 42));
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 204),
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 176),
    1,
    0);
  RPC_CONFIG_DATA::~RPC_CONFIG_DATA((CMSClient *)((char *)v1 + 44));
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 20));
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E654AA6) --------------------------------------------------------
void *__thiscall ATL::CComObject<CSrvrcfg>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CSrvrcfg>::~CComObject<CSrvrcfg>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E654ACC) --------------------------------------------------------
void __thiscall ATL::CComObject<CSrvrcfg>::~CComObject<CSrvrcfg>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComObject<CSrvrcfg>::`vftable';
  *(_DWORD *)(this + 4) = &ATL::CComObject<CSrvrcfg>::`vftable';
  *(_DWORD *)(this + 8) = &ATL::CComObject<CSrvrcfg>::`vftable';
  *(_DWORD *)(this + 12) = 1;
  InterlockedDecrement(&Addend);
  CSrvrcfg::~CSrvrcfg((CSrvrcfg *)v1);
}
// 6E64AD68: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E64AD8C: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E64C168: using guessed type int (__stdcall *ATL::CComObject<CSrvrcfg>::`vftable')(CSrvrcfg *, struct _GUID *, void **);

//----- (6E654AFF) --------------------------------------------------------
void __thiscall CSrvrcfg::~CSrvrcfg(CSrvrcfg *this)
{
  CSrvrcfg *v1; // esi@1

  v1 = this;
  ReleaseObj(*((struct IUnknown **)this + 13));
  RegSafeCloseKey(*((HKEY *)v1 + 16));
  CSrvrcfg::CleanupPropPages(v1);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 144),
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 116),
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)((char *)v1 + 88),
    1,
    0);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 16));
}

//----- (6E654B6A) --------------------------------------------------------
void __thiscall CSrvrcfg::CleanupPropPages(CSrvrcfg *this)
{
  CSrvrcfg *v1; // esi@1
  int v2; // ecx@1

  v1 = this;
  v2 = *((_DWORD *)this + 14);
  if ( v2 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *((_DWORD *)v1 + 14) = 0;
}

//----- (6E654B85) --------------------------------------------------------
void __thiscall CFilteredAdapters::~CFilteredAdapters(CFilteredAdapters *this)
{
  int v1; // esi@1

  v1 = (int)this;
  CFilteredAdapters::Free(this);
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(v1);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(v1);
}

//----- (6E654BA3) --------------------------------------------------------
void __thiscall CFilteredAdapters::Free(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // esi@1

  v1 = this;
  FreeCollectionAndItem<CFilteredAdapters>((int)this);
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 5) = 0;
  *((_DWORD *)v1 + 6) = 0;
  *((_DWORD *)v1 + 7) = 0;
  *((_DWORD *)v1 + 8) = 0;
}

//----- (6E654BC6) --------------------------------------------------------
int __stdcall FreeCollectionAndItem<CFilteredAdapters>(int a1)
{
  int v1; // esi@1
  void **i; // edi@1

  v1 = a1;
  for ( i = *(void ***)(a1 + 4); i != *(void ***)(v1 + 8); ++i )
  {
    if ( *i )
      CFilteredAdapter::`scalar deleting destructor'(*i, 1);
  }
  return std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
           (void *)v1,
           (int)&a1,
           *(_DWORD *)(v1 + 4),
           *(_DWORD *)(v1 + 8));
}

//----- (6E654C08) --------------------------------------------------------
void __thiscall CFilteredAdapters::SendAttachNotifications(CFilteredAdapters *this)
{
  CFilteredAdapters *v1; // edi@1
  int v2; // eax@1
  int i; // esi@1
  int v4; // ecx@3

  v1 = this;
  v2 = *((_DWORD *)this + 5);
  for ( i = *(_DWORD *)(v2 + 4); i != *(_DWORD *)(v2 + 8); i += 4 )
  {
    v4 = *(_DWORD *)i;
    if ( !*(_DWORD *)(*(_DWORD *)i + 24) || !*(_DWORD *)(*(_DWORD *)(v4 + 36) - 16 + 8) )
      CFilteredAdapters::HrAttachOrDetach(v1, (struct CFilterMapEntry *)v4, 0xAu);
    v2 = *((_DWORD *)v1 + 5);
  }
}

//----- (6E654C5A) --------------------------------------------------------
void *__thiscall CFilterMapEntry::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CFilterMapEntry::~CFilterMapEntry((CFilterMapEntry *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E654C80) --------------------------------------------------------
void __thiscall CFilterMapEntry::~CFilterMapEntry(CFilterMapEntry *this)
{
  CFilterMapEntry *v1; // esi@1

  v1 = this;
  if ( *((_DWORD *)this + 12) )
    MemFree(*((void **)this + 13));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 28));
}

//----- (6E654CC9) --------------------------------------------------------
int __cdecl std::copy<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, void *a4)
{
  std::_Copy_opt<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(a1, a2, a3, a4);
  return a1;
}

//----- (6E654CFB) --------------------------------------------------------
int __cdecl std::_Copy_opt<CBindPath *,std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, void *a4)
{
  int i; // esi@1
  int result; // eax@3

  for ( i = a2; i != a3; i += 20 )
  {
    CBindPath::operator=(a4, i);
    a4 = (char *)a4 + 20;
  }
  result = a1;
  *(_DWORD *)a1 = a4;
  return result;
}

//----- (6E654D1D) --------------------------------------------------------
__int32 __stdcall HrRegSetMultiSzAndLogDifference(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData, const struct CComponent *a4)
{
  __int32 result; // eax@2
  BYTE *v5; // ebx@4
  __int32 v6; // eax@4
  unsigned __int32 v7; // eax@11
  FILE *v8; // esi@13
  int v9; // eax@14
  int v10; // eax@23
  DWORD Type; // [sp+8h] [bp-4h]@4

  if ( !(CDiagContext::Flags(g_pDiagCtx) & 0x20) )
    return HrRegSetMultiSz(hKey, lpValueName, lpData);
  Type = *((_DWORD *)g_pDiagCtx + 4);
  v5 = (BYTE *)*((_DWORD *)g_pDiagCtx + 3);
  v6 = HrRegQueryTypeSzBuffer(hKey, lpValueName, 7u, *((LPBYTE *)g_pDiagCtx + 3), (DWORD)&Type);
  if ( v6 != -2147024662 )
  {
    if ( v5 )
      goto LABEL_10;
    if ( v6 )
      goto LABEL_21;
  }
  v5 = (BYTE *)CDiagContext::GrowScratchBuffer(g_pDiagCtx, &Type);
  if ( v5 )
    v6 = HrRegQueryTypeSzBuffer(hKey, lpValueName, 7u, v5, (DWORD)&Type);
  else
    v6 = -2147024882;
LABEL_10:
  if ( v6 )
  {
LABEL_21:
    if ( v6 == -2147024894 )
    {
      if ( *((_DWORD *)a4 + 8) )
        v10 = *((_DWORD *)a4 + 8);
      else
        v10 = *((_DWORD *)a4 + 7);
      fprintf(*((FILE **)g_pDiagCtx + 2), "added   Linkage\\%S for %S\n", lpValueName, v10);
    }
    return HrRegSetMultiSz(hKey, lpValueName, lpData);
  }
  v7 = CbOfMultiSzAndTermSafe((const unsigned __int16 *)lpData);
  if ( v7 != Type || (result = 0, memcmp(lpData, v5, Type)) )
  {
    v8 = (FILE *)*((_DWORD *)g_pDiagCtx + 2);
    if ( *((_DWORD *)a4 + 8) )
      v9 = *((_DWORD *)a4 + 8);
    else
      v9 = *((_DWORD *)a4 + 7);
    fprintf(v8, "reset   Linkage\\%S for %S.  bad value was:\n", lpValueName, v9);
    fprintf(v8, "            REG_MULTI_SZ =\n");
    if ( *(_WORD *)v5 )
    {
      do
      {
        fprintf(v8, "                %S\n", v5);
        v5 += 2 * wcslen((const unsigned __int16 *)v5) + 2;
      }
      while ( *(_WORD *)v5 );
    }
    else
    {
      fprintf(v8, "                <empty>\n");
    }
    fprintf(v8, "\n");
    return HrRegSetMultiSz(hKey, lpValueName, lpData);
  }
  return result;
}

//----- (6E654D51) --------------------------------------------------------
__int32 __stdcall HrRegSetMultiSz(HKEY hKey, LPCWSTR lpValueName, BYTE *lpData)
{
  unsigned __int32 v3; // eax@1

  v3 = CchOfMultiSzAndTermSafe((const unsigned __int16 *)lpData);
  return HrRegSetValueEx(hKey, lpValueName, 7u, lpData, 2 * v3);
}

//----- (6E654D7A) --------------------------------------------------------
unsigned __int32 __stdcall CchOfMultiSzAndTermSafe(const unsigned __int16 *a1)
{
  unsigned __int32 result; // eax@2

  if ( a1 )
    result = CchOfMultiSzSafe(a1) + 1;
  else
    result = 0;
  return result;
}

//----- (6E654D9B) --------------------------------------------------------
unsigned __int32 __stdcall CchOfMultiSzSafe(const unsigned __int16 *a1)
{
  const unsigned __int16 *v1; // edx@1
  unsigned __int32 result; // eax@1
  const unsigned __int16 *v3; // ecx@3
  const unsigned __int16 v4; // di@4
  int v5; // ecx@5

  v1 = a1;
  result = 0;
  if ( a1 && *a1 )
  {
    do
    {
      v3 = v1;
      do
      {
        v4 = *v3;
        ++v3;
      }
      while ( v4 );
      v5 = v3 - (v1 + 1) + 1;
      v1 += v5;
      result += v5;
    }
    while ( *v1 );
  }
  return result;
}

//----- (6E654DD9) --------------------------------------------------------
void __thiscall CNetConfigCore::Clear(CNetConfigCore *this)
{
  CNetConfigCore *v1; // esi@1

  v1 = this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)this + 48));
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::clear((int)((char *)v1 + 24));
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)((char *)v1 + 4));
}

//----- (6E654DFC) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::clear(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  return std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(
           (void *)this,
           (int)&v2,
           *(_DWORD *)(this + 4),
           *(_DWORD *)(this + 8));
}

//----- (6E654E1A) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(void *this, int a2, int a3, int a4)
{
  void *v4; // esi@1
  int v5; // ecx@1
  int v6; // eax@2
  int result; // eax@3
  char v8; // [sp+4h] [bp-4h]@2

  v4 = this;
  v5 = a3;
  if ( a3 != a4 )
  {
    v6 = std::copy<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(
           (int)&v8,
           a4,
           *((_DWORD *)v4 + 2),
           a3);
    v5 = a3;
    *((_DWORD *)v4 + 2) = *(_DWORD *)v6;
  }
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}

//----- (6E654E55) --------------------------------------------------------
int __cdecl std::copy<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(int a1, int a2, int a3, int a4)
{
  std::_Copy_opt<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(a1, a2, a3, a4);
  return a1;
}

//----- (6E654E87) --------------------------------------------------------
int __cdecl std::_Copy_opt<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(int a1, int a2, int a3, int a4)
{
  int i; // eax@1
  int result; // eax@3

  for ( i = a2; i != a3; i += 8 )
  {
    *(_DWORD *)a4 = *(_DWORD *)i;
    *(_DWORD *)(a4 + 4) = *(_DWORD *)(i + 4);
    a4 += 8;
  }
  result = a1;
  *(_DWORD *)a1 = a4;
  return result;
}

//----- (6E654EA7) --------------------------------------------------------
BOOL __stdcall CFilterDevices::IsMediumConverterOrLower(wchar_t *Str1)
{
  return _wcsnicmp(Str1, L"ms_medium_converter_", wcslen(L"ms_medium_converter_")) == 0;
}

//----- (6E654F11) --------------------------------------------------------
int __cdecl _wcsnicmp(const wchar_t *Str1, const wchar_t *Str2, size_t MaxCount)
{
  int result; // eax@2
  const wchar_t *v4; // edi@3
  const wchar_t *v5; // edx@4
  const wchar_t v6; // ax@5
  const wchar_t v7; // cx@7
  const wchar_t v8; // ax@7

  if ( __locale_changed )
  {
    result = _wcsnicmp_l(Str1, Str2, MaxCount, 0);
  }
  else
  {
    result = 0;
    if ( MaxCount )
    {
      v4 = Str1;
      if ( Str1 && (v5 = Str2) != 0 )
      {
        do
        {
          v6 = *v4;
          if ( *v4 >= 0x41u && v6 <= 0x5Au )
            v6 += 32;
          v7 = v6;
          v8 = *v5;
          if ( *v5 >= 0x41u && v8 <= 0x5Au )
            v8 += 32;
          ++v4;
          ++v5;
          --MaxCount;
        }
        while ( MaxCount && v7 && v7 == v8 );
        result = v7 - v8;
      }
      else
      {
        *_errno() = 22;
        _invalid_parameter(0, 0, 0, 0, 0);
        result = 0x7FFFFFFF;
      }
    }
  }
  return result;
}
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E654F93) --------------------------------------------------------
int __thiscall CBindPath::RemoveFirstComponent(CBindPath *this)
{
  CBindPath *v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@1
  char v5; // [sp+Ch] [bp-4h]@2

  v1 = this;
  v2 = (int)((char *)this + 4);
  v3 = 0;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 4)) )
  {
    v3 = **((_DWORD **)v1 + 2);
    std::vector<CComponent *,std::nc_allocator<CComponent *>>::erase(v2, (int)&v5, *((_DWORD *)v1 + 2));
  }
  return v3;
}

//----- (6E654FCB) --------------------------------------------------------
int __thiscall std::vector<CComponent *,std::nc_allocator<CComponent *>>::erase(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  char v5; // [sp+4h] [bp-4h]@1

  v3 = this;
  std::copy<CFilteredAdapter * *,std::_Vector_iterator<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>>(
    (int)&v5,
    a3 + 4,
    *(_DWORD *)(this + 8),
    a3);
  result = a2;
  *(_DWORD *)(v3 + 8) -= 4;
  *(_DWORD *)a2 = a3;
  return result;
}

//----- (6E655001) --------------------------------------------------------
__int32 __stdcall HrCreateLinkageKey(GUID *rguid, struct CFilterDevice *a2, HDEVINFO DeviceInfoSet, PHKEY phkResult)
{
  __int32 v4; // ebx@4
  __int32 v5; // eax@6
  HKEY hKey; // [sp+Ch] [bp-4h]@1

  hKey = 0;
  if ( rguid )
  {
    if ( !FIsConsideredNetClass(rguid[1].Data1) && rguid[3].Data1 )
    {
      v5 = CComponent::HrOpenServiceKey((CComponent *)rguid, 0x2001Du, &hKey);
    }
    else
    {
      v4 = CComponent::HrOpenInstanceKey((CComponent *)rguid, 0x2001Fu, &hKey, 0, 0);
      if ( v4 )
        return v4;
      if ( !FIsConsideredNetClass(rguid[1].Data1) )
      {
LABEL_8:
        v4 = HrRegCreateKeyEx(hKey, L"Linkage", 0, 0x2001Fu, 0, phkResult, 0);
        RegCloseKey(hKey);
        return v4;
      }
      v5 = HrRegSetGuidAsSz(hKey, L"NetCfgInstanceId", rguid);
    }
  }
  else
  {
    v5 = HrSetupDiOpenDevRegKey(DeviceInfoSet, (PSP_DEVINFO_DATA)((char *)a2 + 8), 1u, 0, 2u, 0x2001Fu, &hKey);
  }
  v4 = v5;
  if ( !v5 )
    goto LABEL_8;
  return v4;
}

//----- (6E655097) --------------------------------------------------------
__int32 __stdcall HrRegSetGuidAsSz(HKEY hKey, LPCWSTR lpValueName, GUID *rguid)
{
  OLECHAR sz; // [sp+8h] [bp-54h]@1

  StringFromGUID2(rguid, &sz, 39);
  return HrRegSetSz(hKey, lpValueName, (BYTE *)&sz);
}

//----- (6E6550F7) --------------------------------------------------------
__int32 __thiscall CRegistryBindingsContext::HrWriteBindingsForFilterDevices(CRegistryBindingsContext *this, struct CFilterDevices *a2)
{
  CRegistryBindingsContext *v2; // ebx@1
  int v3; // eax@1
  int v5; // ebx@3
  int v6; // edi@4
  CDynamicBuffer *v7; // ecx@9
  unsigned __int16 *v8; // eax@11
  int v9; // [sp+Ch] [bp-7Ch]@1
  int v10; // [sp+10h] [bp-78h]@3
  int v11; // [sp+14h] [bp-74h]@1
  __int32 v12; // [sp+18h] [bp-70h]@1
  CRegistryBindingsContext *v13; // [sp+1Ch] [bp-6Ch]@1
  unsigned __int16 *v14; // [sp+20h] [bp-68h]@1
  unsigned __int16 *i; // [sp+20h] [bp-68h]@11
  unsigned __int16 v16; // [sp+24h] [bp-64h]@1
  unsigned __int16 v17; // [sp+34h] [bp-54h]@4
  __int16 v18; // [sp+82h] [bp-6h]@1

  v2 = this;
  v13 = this;
  v14 = 0;
  StringCchCopyW(&v16, 0x30u, L"\\Device\\");
  v18 = 0;
  v12 = 0;
  CFilterDevices::SortForWritingBindings(a2);
  v3 = *((_DWORD *)a2 + 1);
  v9 = 0;
  v11 = v3;
  if ( v3 != *((_DWORD *)a2 + 2) )
  {
    v5 = (int)((char *)v2 + 24);
    v10 = v3 + 4;
    while ( 1 )
    {
      v6 = *(_DWORD *)v3;
      StringCchCopyW(&v17, 0x28u, (const unsigned __int16 *)(*(_DWORD *)v3 + 36));
      if ( v9 && *(_DWORD *)v6 == *(_DWORD *)v9 )
      {
        v14 += wcslen(v14) + 1;
        if ( *(_DWORD *)(v5 + 8) >= 2u )
          **(_WORD **)v5 = 0;
        *(_DWORD *)(v5 + 4) = 0;
        CDynamicBuffer::HrCopyString((CDynamicBuffer *)v5, *(const unsigned __int16 **)(*(_DWORD *)(v9 + 4) + 100));
        CDynamicBuffer::HrCopyString((CDynamicBuffer *)v5, &String);
      }
      else
      {
        v7 = (CRegistryBindingsContext *)((char *)v13 + 40);
        if ( *((_DWORD *)v13 + 12) >= 2u )
          **(_WORD **)v7 = 0;
        *((_DWORD *)v13 + 11) = 0;
        CDynamicBuffer::HrCopyString(v7, (const unsigned __int16 *)(v6 + 36));
        v8 = (unsigned __int16 *)v10;
        for ( i = (unsigned __int16 *)v10; v8 != *((unsigned __int16 **)a2 + 2) && **(_DWORD **)i == *(_DWORD *)v6; v8 = i )
        {
          CDynamicBuffer::HrCopyString(
            (CRegistryBindingsContext *)((char *)v13 + 40),
            (const unsigned __int16 *)(*(_DWORD *)i + 36));
          i += 2;
        }
        CDynamicBuffer::HrCopyString(
          (CRegistryBindingsContext *)((char *)v13 + 40),
          *(const unsigned __int16 **)(*(_DWORD *)v6 + 100));
        CDynamicBuffer::HrCopyString((CRegistryBindingsContext *)((char *)v13 + 40), &String);
        v14 = (unsigned __int16 *)*((_DWORD *)v13 + 10);
        CRegistryBindingsContext::HrGetAdapterUpperBindValue(v13, *(const struct CComponent **)v6);
      }
      v12 = HrWriteFilterDeviceLinkage(
              (struct CFilterDevice *)v6,
              *((void **)a2 + 10),
              &v16,
              v14,
              *(const unsigned __int16 **)v5);
      if ( v10 == *((_DWORD *)a2 + 2) || **(_DWORD **)v10 != *(_DWORD *)v6 )
      {
        if ( *(_DWORD *)(v5 + 8) >= 2u )
          **(_WORD **)v5 = 0;
        *(_DWORD *)(v5 + 4) = 0;
        CDynamicBuffer::HrCopyString((CDynamicBuffer *)v5, *(const unsigned __int16 **)(*(_DWORD *)(v6 + 4) + 100));
        CDynamicBuffer::HrCopyString((CDynamicBuffer *)v5, &String);
        v12 = HrWriteFilteredAdapterUpperBind(*(HKEY *)v6, *(BYTE **)v5);
      }
      v11 += 4;
      v10 += 4;
      v9 = v6;
      if ( v11 == *((_DWORD *)a2 + 2) )
        break;
      v3 = v11;
    }
  }
  return v12;
}

//----- (6E655164) --------------------------------------------------------
void __thiscall CFilterDevices::SortForWritingBindings(CFilterDevices *this)
{
  int v1; // esi@1
  int v2; // eax@3

  v1 = (int)this;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)this) )
  {
    v2 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v1);
    qsort(*(void **)(v1 + 4), v2, 4u, (int (__cdecl *)(const void *, const void *))CompareFilterDevices);
  }
}

//----- (6E65517D) --------------------------------------------------------
void *__thiscall CFilteredAdapter::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CFilteredAdapter::~CFilteredAdapter((CFilteredAdapter *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E6551A3) --------------------------------------------------------
void __thiscall CFilteredAdapter::~CFilteredAdapter(CFilteredAdapter *this)
{
  CFilteredAdapter *v1; // esi@1

  v1 = this;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)this + 28));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 8));
}

//----- (6E6551BE) --------------------------------------------------------
unsigned int __thiscall HrMigrateWinsockConfiguration(void *this)
{
  unsigned int result; // eax@1
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  result = MigrateWinsockConfiguration(&v2, 0, 0);
  if ( (signed int)result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}
// 6E6551E0: using guessed type int __stdcall MigrateWinsockConfiguration(_DWORD, _DWORD, _DWORD);

//----- (6E6551EB) --------------------------------------------------------
void __thiscall CFilterDevices::Free(CFilterDevices *this)
{
  int v1; // esi@1
  void *v2; // ST00_4@1

  v1 = (int)this;
  MemFree(*((void **)this + 11));
  v2 = *(void **)(v1 + 40);
  *(_DWORD *)(v1 + 44) = 0;
  SetupDiDestroyDeviceInfoListSafe(v2);
  *(_DWORD *)(v1 + 40) = 0;
  FreeCollectionAndItem<CFilterDevices>(v1);
}

//----- (6E655215) --------------------------------------------------------
int __stdcall FreeCollectionAndItem<CFilterDevices>(int a1)
{
  int v1; // esi@1
  void **i; // edi@1

  v1 = a1;
  for ( i = *(void ***)(a1 + 4); i != *(void ***)(v1 + 8); ++i )
  {
    if ( *i )
      operator delete(*i);
  }
  return std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
           (void *)v1,
           (int)&a1,
           *(_DWORD *)(v1 + 4),
           *(_DWORD *)(v1 + 8));
}

//----- (6E65527F) --------------------------------------------------------
int __cdecl std::copy_backward<CComponent * *,CComponent * *>(void *Src, int a2, int a3)
{
  return std::_Copy_backward_opt<CFilterMapEntry * *,CFilterMapEntry * *>(Src, a2, a3);
}

//----- (6E6552AB) --------------------------------------------------------
int __cdecl std::_Copy_backward_opt<CFilterMapEntry * *,CFilterMapEntry * *>(void *Src, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // esi@1

  v3 = 4 * ((a2 - (signed int)Src) >> 2);
  v4 = a3 - v3;
  if ( (a2 - (signed int)Src) >> 2 > 0 )
    memmove_s((void *)(a3 - v3), 4 * ((a2 - (signed int)Src) >> 2), Src, 4 * ((a2 - (signed int)Src) >> 2));
  return v4;
}

//----- (6E6552D6) --------------------------------------------------------
signed int __thiscall CFilteredAdapters::HrBuildFilterListEntry(CFilteredAdapters *this, GUID *rguid, GUID *a3, unsigned int a4)
{
  CFilteredAdapters *v4; // esi@1
  char *v5; // ebx@1

  v4 = this;
  v5 = (char *)this + 280;
  StringFromGUID2(rguid, (LPOLESTR)this + 140, 39);
  StringFromGUID2(a3, (LPOLESTR)v4 + 101, 39);
  _snwprintf_s((wchar_t *)v4 + 18, 0x53u, 0x52u, L"%s-%s-%04d", v5, (char *)v4 + 202, a4);
  return CDynamicBuffer::HrCopyString(*((CDynamicBuffer **)v4 + 7), (const unsigned __int16 *)v4 + 18);
}

//----- (6E65534F) --------------------------------------------------------
int _snwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, ...)
{
  va_list va; // [sp+18h] [bp+18h]@1

  va_start(va, Format);
  return _vsnwprintf_s(DstBuf, SizeInWords, MaxCount, Format, va);
}

//----- (6E655373) --------------------------------------------------------
int __cdecl _vsnwprintf_s(wchar_t *DstBuf, size_t SizeInWords, size_t MaxCount, const wchar_t *Format, va_list ArgList)
{
  int result; // eax@6

  if ( Format )
  {
    if ( MaxCount )
    {
      if ( !DstBuf )
        goto LABEL_14;
      goto LABEL_4;
    }
    if ( DstBuf )
    {
LABEL_4:
      if ( SizeInWords > 0 )
      {
        if ( SizeInWords <= MaxCount )
        {
          result = _swoutput_s((char *)DstBuf, SizeInWords, (int)Format, (int)ArgList);
          if ( result == -2 )
          {
            if ( MaxCount == -1 )
              return -1;
LABEL_15:
            *DstBuf = 0;
            if ( result == -2 )
            {
              *_errno() = 34;
              goto LABEL_17;
            }
            return -1;
          }
        }
        else
        {
          result = _swoutput_s((char *)DstBuf, MaxCount + 1, (int)Format, (int)ArgList);
          if ( result == -2 )
            return -1;
        }
        if ( result >= 0 )
          return result;
        goto LABEL_15;
      }
LABEL_14:
      *_errno() = 22;
LABEL_17:
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
    if ( SizeInWords )
      goto LABEL_14;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}

//----- (6E6553DB) --------------------------------------------------------
signed int __thiscall CFilterMap::HrGetIndexForFilterByMiniportAndLowerFilter(CFilterMap *this, const struct CComponent *a2, const struct _GUID *a3, const struct CComponent *a4, int a5, unsigned int *a6, int *a7)
{
  int v7; // eax@3
  signed int v8; // esi@4
  int v10; // eax@7
  CFilterMap *v11; // [sp+Ch] [bp-10h]@1
  int v12; // [sp+28h] [bp+Ch]@8

  v11 = this;
  if ( a6 && a7 )
  {
    v7 = CFilterMap::PFindEntryByFilterAndMiniportGuid(this, a2, a3);
    if ( v7 )
    {
      v8 = CFilterMapEntry::HrGetIndexByFilter((CFilterMapEntry *)v7, a4, a6, a7);
    }
    else
    {
      *a6 = 0;
      *a7 = 0;
      v10 = (int)operator new(0x38u);
      if ( v10 )
        v12 = CFilterMapEntry::CFilterMapEntry(v10, (int)a2, (int)a3, 0, a5);
      else
        v12 = 0;
      if ( v12 )
      {
        v8 = CFilterMapEntry::HrSetFilterAndIndex(
               (CFilterMapEntry *)v12,
               (const struct CComponent *)(**((_DWORD **)a2 + 17) == 1 ? (unsigned int)a4 : 0),
               (CCounter *)*a6,
               *a7);
        if ( v8 || (v8 = CFilterMap::HrInsertEntry(v11, (const struct CFilterMapEntry *)v12)) != 0 )
          CFilterMapEntry::`scalar deleting destructor'((void *)v12, 1);
      }
      else
      {
        v8 = -2147024882;
      }
    }
  }
  else
  {
    v8 = -2147024809;
  }
  return v8;
}

//----- (6E655430) --------------------------------------------------------
signed int __thiscall CFilterMapEntry::HrGetIndexByFilter(CFilterMapEntry *this, const struct CComponent *a2, unsigned int *a3, int *a4)
{
  CFilterMapEntry *v4; // esi@1
  unsigned int *v5; // ebx@3
  unsigned int *v6; // eax@4
  int v8; // [sp+1Ch] [bp-8h]@4
  signed int v9; // [sp+20h] [bp-4h]@1

  v9 = 0;
  v4 = this;
  if ( a4 )
    *a4 = 0;
  v5 = a3;
  if ( a3 )
  {
    v8 = (int)((char *)this + 28);
    CIndices::PGetIndexByFilter((int)((char *)this + 28), (int)&a3, (int)a2);
    v6 = a3;
    if ( a3 == *((unsigned int **)v4 + 9) )
    {
      *v5 = 0;
      a4 = (int *)((char *)v4 + 44);
      v9 = CCounter::HrGetNewIndex((CFilterMapEntry *)((char *)v4 + 44), v5);
      if ( !v9 )
      {
        v9 = CIndices::HrInsertIndex(v8, (unsigned int)a2, *v5, 0, 0);
        if ( v9 )
          CCounter::UnsetIndex((CCounter *)a4, *v5);
      }
    }
    else
    {
      *v5 = a3[1];
      if ( a4 )
        *a4 = v6[2];
    }
  }
  else
  {
    v9 = -2147024809;
  }
  return v9;
}

//----- (6E65549A) --------------------------------------------------------
void __stdcall PruneNdisWanBindPathsIfActiveRasConnections(char a1, struct CBindingSet *a2, int *a3)
{
  char v3; // ST18_1@1
  struct CBindingSet *v4; // edi@3
  int v5; // esi@3

  v3 = a1;
  *a3 = 0;
  if ( FExistActiveRasConnections(v3) )
  {
    v4 = a2;
    v5 = *((_DWORD *)a2 + 2);
    while ( v5 != *((_DWORD *)v4 + 3) )
    {
      if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size(v5 + 4) != 2
        || GetPnpLayerForBindPath((const struct CBindPath *)v5) != 1
        || _wcsicmp(L"NdisWan", *(const wchar_t **)(*(_DWORD *)(*(_DWORD *)(v5 + 12) - 4) + 48)) )
      {
        v5 += 20;
      }
      else
      {
        CDiagContext::Printf(
          (DWORD)g_pDiagCtx,
          3,
          "   Skipping PnP BIND/UNBIND for  %S -> %S  (active RAS connections)\n",
          *(_DWORD *)(**(_DWORD **)(v5 + 8) + 100),
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 12) - 4) + 100));
        *a3 = 1;
        std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase((int)((char *)v4 + 4), (int)&a1, v5);
      }
    }
  }
}

//----- (6E6554BE) --------------------------------------------------------
int __stdcall FExistActiveRasConnections(char a1)
{
  int v1; // edi@1
  DWORD v3; // eax@5
  DWORD v4[2]; // [sp+4h] [bp-574h]@5
  struct tagRASCONNW Dst; // [sp+Ch] [bp-56Ch]@5

  v1 = 0;
  if ( !(a1 & 1)
    || (memset(&Dst, 0, 0x568u),
        Dst.dwSize = 1384,
        v4[0] = 1384,
        v4[1] = 0,
        (v3 = RasEnumConnectionsW(&Dst, v4, &v4[1])) != 0)
    && v3 != 603
    || *(_QWORD *)v4 <= 0ui64 )
  {
    if ( a1 & 2 )
      v1 = IsServiceRunning(0);
  }
  else
  {
    v1 = 1;
  }
  return v1;
}

//----- (6E655504) --------------------------------------------------------
int __stdcall IsServiceRunning(LPCWSTR lpMachineName)
{
  SC_HANDLE v1; // ebx@1
  SC_HANDLE v2; // eax@1
  SC_HANDLE v3; // eax@2
  struct _SERVICE_STATUS ServiceStatus; // [sp+4h] [bp-24h]@3
  SC_HANDLE hSCObject; // [sp+20h] [bp-8h]@2
  int v7; // [sp+24h] [bp-4h]@1
  LPCWSTR lpMachineNamea; // [sp+30h] [bp+8h]@1

  v1 = 0;
  v7 = 0;
  v2 = OpenSCManagerW(lpMachineName, 0, 0x80000000);
  lpMachineNamea = (LPCWSTR)v2;
  if ( v2 )
  {
    v3 = OpenServiceW(v2, L"RemoteAccess", 4u);
    hSCObject = v3;
    if ( v3 )
    {
      if ( QueryServiceStatus(v3, &ServiceStatus) && ServiceStatus.dwCurrentState == 4
        || (v1 = OpenServiceW((SC_HANDLE)lpMachineNamea, L"Router", 4u)) != 0
        && QueryServiceStatus(v1, &ServiceStatus)
        && ServiceStatus.dwCurrentState == 4 )
        v7 = 1;
      CloseServiceHandle(hSCObject);
      if ( v1 )
        CloseServiceHandle(v1);
    }
    CloseServiceHandle((SC_HANDLE)lpMachineNamea);
  }
  return v7;
}

//----- (6E6555DF) --------------------------------------------------------
int __fastcall load__MigrateWinsockConfiguration_12(int a1, int a2)
{
  return _tailMerge_MSWSOCK_dll((int)&MigrateWinsockConfiguration, a2, a1);
}
// 6E699110: using guessed type void *MigrateWinsockConfiguration;

//----- (6E6555E6) --------------------------------------------------------
int __usercall _tailMerge_MSWSOCK_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_MSWSOCK_dll, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E655631) --------------------------------------------------------
void __thiscall CBindingSet::SortForPnpUnbind(CBindingSet *this)
{
  std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
    *((_DWORD *)this + 2),
    *((_DWORD *)this + 3),
    (int)this);
}

//----- (6E65564E) --------------------------------------------------------
void __stdcall std::sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3)
{
  std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::less<CBindPath>>(
    a1,
    a2,
    (a2 - a1) / 20,
    a3);
}

//----- (6E655677) --------------------------------------------------------
void __stdcall std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::less<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1

  v4 = (a2 - a1) / 20;
  JUMPOUT(v4, 32, sub_6E6574AC);
  if ( v4 > 1 )
    std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(a1, a2, a4);
}

//----- (6E6556A5) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::UnbindFrom(CImplINetCfgComponent *this, struct INetCfgComponent *a2)
{
  return CImplINetCfgComponent::HrBindToOrUnbindFrom((CImplINetCfgComponent *)((char *)this - 4), a2, 0x20u);
}

//----- (6E6556DD) --------------------------------------------------------
int __fastcall load__SetupDiEnumDeviceInfo_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiEnumDeviceInfo, a2, a1);
}

//----- (6E6556E7) --------------------------------------------------------
int __fastcall load__SetupDiGetClassDevsW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetClassDevsW, a2, a1);
}

//----- (6E65570C) --------------------------------------------------------
__int32 __thiscall CNetConfigCore::HrDisableBindPath(CNetConfigCore *this, const struct CBindPath *a2)
{
  int v2; // eax@1
  CNetConfigCore *v3; // edi@1
  __int32 result; // eax@2
  wchar_t *v5; // eax@5

  v2 = **((_DWORD **)a2 + 2);
  v3 = this;
  if ( *(_DWORD *)(v2 + 24) & 0x40000
    && **(_DWORD **)(v2 + 68) != 1
    && (v5 = *(wchar_t **)(v2 + 64)) != 0
    && CFilterDevices::IsMediumConverterOrLower(v5) )
    result = 0;
  else
    result = CBindingSet::HrAddBindPath((CNetConfigCore *)((char *)v3 + 44), a2, 0x600u);
  return result;
}

//----- (6E655743) --------------------------------------------------------
__int32 __thiscall CComponent::HrOpenDeviceInfo(CComponent *this, void **a2, struct _SP_DEVINFO_DATA *a3)
{
  return HrOpenDeviceInfo(*((_DWORD *)this + 4), *((const WCHAR **)this + 8), a2, a3);
}

//----- (6E65575E) --------------------------------------------------------
int __fastcall load__pSetupLoadIndirectString_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&pSetupLoadIndirectString, a2, a1);
}
// 6E69909C: using guessed type void *pSetupLoadIndirectString;

//----- (6E655768) --------------------------------------------------------
int __fastcall load__CM_Get_DevNode_Status_Ex_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&CM_Get_DevNode_Status_Ex, a2, a1);
}

//----- (6E655777) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetDeviceStatus(CImplINetCfgComponent *this, unsigned __int32 *a2)
{
  signed int v2; // edi@1
  int v3; // edi@2
  unsigned __int32 v4; // eax@4
  ULONG pulStatus; // [sp+Ch] [bp-30h]@4
  ULONG pulProblemNumber; // [sp+10h] [bp-2Ch]@4
  HDEVINFO DeviceInfoSet; // [sp+14h] [bp-28h]@3
  CImplINetCfgComponent *v9; // [sp+18h] [bp-24h]@1
  struct _SP_DEVINFO_DATA v10; // [sp+1Ch] [bp-20h]@3

  v9 = this;
  *a2 = 0;
  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( !v2 )
  {
    v3 = *((_DWORD *)v9 + 7);
    if ( FIsConsideredNetClass(*(_DWORD *)(v3 + 16)) )
    {
      v2 = CComponent::HrOpenDeviceInfo((CComponent *)v3, &DeviceInfoSet, &v10);
      if ( !v2 )
      {
        v4 = CM_Get_DevNode_Status_Ex(&pulStatus, &pulProblemNumber, v10.DevInst, 0, 0);
        if ( v4 )
        {
          if ( v4 == 13 )
            v2 = -2147180505;
          else
            v2 = HrFromConfigManagerError(v4, -2147467259);
        }
        else
        {
          v2 = 0;
          *a2 = pulProblemNumber;
        }
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      }
    }
    else
    {
      v2 = -2147418113;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v9 + 6) + 24));
  }
  return v2;
}

//----- (6E6558FE) --------------------------------------------------------
int __cdecl _local_unwind4(int a1, int a2, unsigned int a3)
{
  int result; // eax@2
  unsigned int v4; // esi@2
  int v5; // esi@5
  int v6; // ebx@5
  int v7; // eax@6
  int v8; // eax@6
  int v9; // [sp-8h] [bp-28h]@1
  signed int (__cdecl *v10)(int, int, int, int); // [sp-4h] [bp-24h]@1
  unsigned int v11; // [sp+0h] [bp-20h]@1
  unsigned int v12; // [sp+4h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-18h]@1
  int v14; // [sp+Ch] [bp-14h]@1

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v10 = sub_6E65598E;
  v11 = (unsigned int)&v9 ^ __security_cookie;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 12);
    if ( v4 == -2 || a3 != -2 && v4 <= a3 )
      break;
    v5 = 3 * v4;
    v6 = (*(_DWORD *)a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 16;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)((*(_DWORD *)a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 0x10);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      v7 = *(_DWORD *)(v6 + 8);
      _NLG_Notify(257);
      v8 = *(_DWORD *)(v6 + 8);
      _NLG_Call(1);
    }
  }
  return result;
}
// 6E655A8A: using guessed type _DWORD __cdecl _NLG_Notify(_DWORD);
// 6E655AA9: using guessed type int __thiscall _NLG_Call(_DWORD);

//----- (6E65598E) --------------------------------------------------------
signed int __cdecl sub_6E65598E(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1
  int v5; // ecx@2
  int v6; // ebp@2

  result = 1;
  if ( *(_DWORD *)(a1 + 4) & 6 )
  {
    v5 = a2 ^ *(_DWORD *)(a2 + 8);
    v6 = *(_DWORD *)(a2 + 24);
    _local_unwind4(*(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 12));
    *(_DWORD *)a4 = a2;
    result = 3;
  }
  return result;
}

//----- (6E6559D4) --------------------------------------------------------
int __thiscall _EH4_CallFilterFunc(void *this)
{
  return ((int (__fastcall *)(void *, _DWORD))this)(this, 0);
}

//----- (6E6559EB) --------------------------------------------------------
int __thiscall _EH4_TransferToHandler(void *this)
{
  void *v1; // esi@1

  v1 = this;
  _NLG_Notify(1);
  return ((int (__fastcall *)(_DWORD, _DWORD))v1)(0, 0);
}
// 6E655A8A: using guessed type _DWORD __cdecl _NLG_Notify(_DWORD);

//----- (6E655A04) --------------------------------------------------------
void __thiscall _EH4_GlobalUnwind(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &loc_6E655A19, 0, 0);
}

//----- (6E655A1E) --------------------------------------------------------
int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, int a4)
{
  return _local_unwind4(a4, a1, a2);
}

//----- (6E655A81) --------------------------------------------------------
void _NLG_Notify1()
{
  JUMPOUT(&loc_6E655A95);
}

//----- (6E655A8A) --------------------------------------------------------
#error "6E655AA0: positive sp value has been found (funcsize=10)"

//----- (6E655AA1) --------------------------------------------------------
#error "6E655AA2: positive sp value has been found (funcsize=0)"

//----- (6E655AF8) --------------------------------------------------------
size_t __cdecl strlen(const char *Str)
{
  const char *v1; // ecx@1
  char v2; // al@2
  int v3; // eax@4
  int v4; // eax@5

  v1 = Str;
  if ( !((unsigned __int8)Str & 3) )
    goto LABEL_4;
  do
  {
    v2 = *v1++;
    if ( !v2 )
      return v1 - 1 - Str;
  }
  while ( (unsigned __int8)v1 & 3 );
  while ( 1 )
  {
    do
    {
LABEL_4:
      v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
      v1 += 4;
    }
    while ( !(v3 & 0x81010100) );
    v4 = *((_DWORD *)v1 - 1);
    if ( !(_BYTE)v4 )
      break;
    if ( !BYTE1(v4) )
      return v1 - 3 - Str;
    if ( !(v4 & 0xFF0000) )
      return v1 - 2 - Str;
    if ( !(v4 & 0xFF000000) )
      return v1 - 1 - Str;
  }
  return v1 - 4 - Str;
}

//----- (6E656ABA) --------------------------------------------------------
void (__usercall *__usercall sub_6E656ABA@<eax>(int a1@<ebp>))(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return sub_6E656AC4;
}

//----- (6E656AC4) --------------------------------------------------------
void __usercall sub_6E656AC4(int a1@<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 20);
  JUMPOUT(loc_6E656AC9);
}

//----- (6E657049) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E657049@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E642105;
}

//----- (6E657056) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E657056@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E64FB09;
}

//----- (6E65709F) --------------------------------------------------------
void __usercall __noreturn sub_6E65709F(int a1@<ebp>)
{
  operator delete(*(void **)(a1 + 12));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E657288) --------------------------------------------------------
void __usercall __noreturn sub_6E657288(int a1@<ebp>)
{
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(*(_DWORD *)(a1 - 20));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E65729A) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E65729A@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E64C39C;
}

//----- (6E6572B9) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E6572B9@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E652042;
}

//----- (6E6572C6) --------------------------------------------------------
void __usercall __noreturn sub_6E6572C6(int a1@<ebp>)
{
  void *i; // esi@1

  for ( i = *(void **)(a1 - 20); i != *(void **)(a1 + 16); i = (char *)i + 20 )
    std::_Destroy<CBindPath>(i);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E6572F8) --------------------------------------------------------
void __usercall __noreturn sub_6E6572F8(int a1@<ebp>)
{
  void *i; // esi@1

  for ( i = *(void **)(a1 - 20); i != *(void **)(a1 + 16); i = (char *)i + 20 )
    std::_Destroy<CBindPath>(i);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E657314) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E657314@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E64278F;
}

//----- (6E657321) --------------------------------------------------------
void __usercall __noreturn sub_6E657321(int a1@<ebp>)
{
  void *i; // esi@1

  for ( i = *(void **)(a1 - 20); i != *(void **)(a1 + 8); i = (char *)i + 20 )
    std::_Destroy<CBindPath>(i);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E6573D8) --------------------------------------------------------
void __usercall __noreturn sub_6E6573D8(int a1@<ebp>)
{
  operator delete(*(void **)(a1 + 8));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E6573EB) --------------------------------------------------------
void __userpurge sub_6E6573EB(int a1@<eax>, int a2@<ebp>, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // [sp-4h] [bp-Ch]@3

  v6 = *(_DWORD *)(a2 + 16);
  do
  {
    if ( v6 <= 0 )
      break;
    std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      a2 - 8,
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(a2 + 12),
      *(_DWORD *)(a2 + 20));
    v6 = v6 / 2 / 2 + v6 / 2;
    v7 = *(_DWORD *)(a2 + 20);
    if ( (*(_DWORD *)(a2 - 8) - *(_DWORD *)(a2 + 8)) / 20 >= (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 - 4)) / 20 )
    {
      std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::greater<CBindPath>>(
        *(_DWORD *)(a2 - 4),
        *(_DWORD *)(a2 + 12),
        v6,
        v7);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 - 8);
    }
    else
    {
      std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::greater<CBindPath>>(
        *(_DWORD *)(a2 + 8),
        *(_DWORD *)(a2 - 8),
        v6,
        v7);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 - 4);
    }
    a1 = (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) / 20;
  }
  while ( a1 > 32 );
  JUMPOUT(a1, 32, &loc_6E651CC7);
  std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a2 + 20));
  std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a2 + 20));
  JUMPOUT(&locret_6E651CD0);
}

//----- (6E6574AC) --------------------------------------------------------
void __userpurge sub_6E6574AC(int a1@<eax>, int a2@<ebp>, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // [sp-4h] [bp-Ch]@3

  v6 = *(_DWORD *)(a2 + 16);
  do
  {
    if ( v6 <= 0 )
      break;
    std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
      a2 - 8,
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(a2 + 12),
      *(_DWORD *)(a2 + 20));
    v6 = v6 / 2 / 2 + v6 / 2;
    v7 = *(_DWORD *)(a2 + 20);
    if ( (*(_DWORD *)(a2 - 8) - *(_DWORD *)(a2 + 8)) / 20 >= (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 - 4)) / 20 )
    {
      std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::less<CBindPath>>(
        *(_DWORD *)(a2 - 4),
        *(_DWORD *)(a2 + 12),
        v6,
        v7);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 - 8);
    }
    else
    {
      std::_Sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,std::less<CBindPath>>(
        *(_DWORD *)(a2 + 8),
        *(_DWORD *)(a2 - 8),
        v6,
        v7);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 - 4);
    }
    a1 = (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 8)) / 20;
  }
  while ( a1 > 32 );
  JUMPOUT(a1, 32, &loc_6E655693);
  std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a2 + 20));
  std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
    *(_DWORD *)(a2 + 8),
    *(_DWORD *)(a2 + 12),
    *(_DWORD *)(a2 + 20));
  JUMPOUT(&locret_6E65569C);
}

//----- (6E65756D) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E65756D@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E6503A8;
}

//----- (6E657586) --------------------------------------------------------
void __usercall __noreturn sub_6E657586(int a1@<ebp>)
{
  std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(
    *(void **)(a1 + 16),
    *(_DWORD *)(a1 + 12),
    *(_DWORD *)(a1 - 20));
  operator delete(*(void **)(a1 + 16));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E6575A6) --------------------------------------------------------
void __usercall __noreturn sub_6E6575A6(int a1@<ebp>)
{
  std::_Destroy_range<CBindPath,std::nc_allocator<CBindPath>>(
    (void *)(*(_DWORD *)(a1 + 8) + 20 * *(_DWORD *)(a1 + 12)),
    20 * *(_DWORD *)(a1 + 12) + *(_DWORD *)(*(_DWORD *)(a1 - 20) + 8),
    *(_DWORD *)(a1 - 20));
  JUMPOUT(&loc_6E65759D);
}

//----- (6E6575F9) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E6575F9@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E65006A;
}

//----- (6E65762B) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E65762B@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147024882;
  return &loc_6E652077;
}

//----- (6E65763F) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E65763F@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E642935;
}

//----- (6E658DE6) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E658DE6@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E64561C;
}

//----- (6E659648) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E659648@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 24) = -2147024882;
  return &loc_6E64E960;
}

//----- (6E659736) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E659736@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147024882;
  return &loc_6E652A8A;
}

//----- (6E6598FC) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E6598FC@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147418113;
  return &loc_6E653A19;
}

//----- (6E659AC2) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E659AC2@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E64DE79;
}

//----- (6E659B9D) --------------------------------------------------------
void __usercall __noreturn sub_6E659B9D(int a1@<ebp>)
{
  operator delete(*(void **)(a1 + 16));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E659C56) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E659C56@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147024882;
  return &loc_6E64F5E7;
}

//----- (6E659D48) --------------------------------------------------------
int __usercall sub_6E659D48@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659D59) --------------------------------------------------------
void __userpurge sub_6E659D59(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6E659D3D);
}

//----- (6E659D63) --------------------------------------------------------
int __usercall sub_6E659D63@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659D74) --------------------------------------------------------
void __userpurge sub_6E659D74(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6E647B94);
}

//----- (6E659D84) --------------------------------------------------------
int __usercall sub_6E659D84@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659D95) --------------------------------------------------------
void __userpurge sub_6E659D95(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6E647BB8);
}

//----- (6E659DBB) --------------------------------------------------------
int __usercall sub_6E659DBB@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659DCC) --------------------------------------------------------
void __usercall sub_6E659DCC(int a1@<ebp>)
{
  int v1; // et1@1

  v1 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(loc_6E659DD7);
}

//----- (6E659DED) --------------------------------------------------------
int __usercall sub_6E659DED@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659DFE) --------------------------------------------------------
void __usercall sub_6E659DFE(int a1@<ebp>)
{
  int v1; // et1@1

  v1 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(loc_6E659E09);
}

//----- (6E659E2C) --------------------------------------------------------
int __usercall sub_6E659E2C@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659E3D) --------------------------------------------------------
void __userpurge sub_6E659E3D(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(&loc_6E647BCA);
}

//----- (6E659E4D) --------------------------------------------------------
int __usercall sub_6E659E4D@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659E5E) --------------------------------------------------------
void __userpurge sub_6E659E5E(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6E647D00);
}

//----- (6E659E97) --------------------------------------------------------
int __usercall sub_6E659E97@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6E6754CD: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6E659EA8) --------------------------------------------------------
void __userpurge sub_6E659EA8(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(&loc_6E647BDD);
}

//----- (6E65DB35) --------------------------------------------------------
int __stdcall NcAtlModuleRegisterServer(struct ATL::_ATL_MODULE *a1)
{
  int v1; // esi@1
  int i; // edi@1

  v1 = *((_DWORD *)a1 + 4);
  for ( i = 0; *(_DWORD *)v1; v1 += 28 )
  {
    if ( !(*(int (**)(void))(v1 + 24))() )
    {
      i = (*(int (__stdcall **)(signed int))(v1 + 4))(1);
      if ( i < 0 )
        break;
    }
  }
  return i;
}

//----- (6E65DB6F) --------------------------------------------------------
DWORD __stdcall CMSClient::UpdateRegistry(int a1)
{
  return ATL::CComModule::UpdateRegistryFromResourceS((ATL::CComModule *)&_Module, 31006, a1, 0);
}

//----- (6E65DB91) --------------------------------------------------------
DWORD __stdcall CImplINetCfg::UpdateRegistry(int a1)
{
  return ATL::CComModule::UpdateRegistryFromResourceS((ATL::CComModule *)&_Module, 31009, a1, 0);
}

//----- (6E65DBB3) --------------------------------------------------------
void __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>(int this)
{
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 4));
}

//----- (6E65DBC3) --------------------------------------------------------
DWORD __stdcall CSrvrcfg::UpdateRegistry(int a1)
{
  return ATL::CComModule::UpdateRegistryFromResourceS((ATL::CComModule *)&_Module, 31021, a1, 0);
}

//----- (6E65DBE5) --------------------------------------------------------
HRESULT __stdcall DllRegisterServer()
{
  signed int v0; // edi@1
  HRESULT v1; // eax@1
  int v2; // esi@1

  v0 = 1;
  v1 = CoInitializeEx(0, 6u);
  v2 = v1;
  if ( v1 >= 0 )
    goto LABEL_10;
  v0 = 0;
  if ( v1 == -2147417850 )
    v2 = 0;
  if ( v2 >= 0 )
  {
LABEL_10:
    v2 = NcAtlModuleRegisterServer((struct ATL::_ATL_MODULE *)&_Module);
    if ( v0 )
      CoUninitialize();
  }
  return v2;
}

//----- (6E65DC2C) --------------------------------------------------------
HRESULT __stdcall DllUnregisterServer()
{
  ATL::AtlModuleUnregisterServer((struct ATL::_ATL_MODULE *)&_Module, 0);
  return 0;
}

//----- (6E65DC40) --------------------------------------------------------
signed int __stdcall NetClassInstaller(unsigned int a1, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  signed int v3; // eax@1
  int v4; // ecx@2
  signed int result; // eax@4

  v3 = _HrNetClassInstaller(a1, DeviceInfoSet, DeviceInfoData);
  if ( v3 >= 0 )
  {
    result = 0;
  }
  else
  {
    v4 = (v3 >> 16) & 0x1FFF;
    if ( v4 == 15 || v4 == 7 )
      result = DwWin32ErrorFromHr(v3);
    else
      result = 31;
  }
  return result;
}

//----- (6E65DCA5) --------------------------------------------------------
signed int __stdcall NetPropPageProvider(int a1, int (__stdcall *a2)(_DWORD, _DWORD), int a3)
{
  struct _SP_DEVINFO_DATA *v3; // eax@1
  signed int v4; // ebx@1
  HPROPSHEETPAGE v6; // [sp+8h] [bp-8h]@1
  HPROPSHEETPAGE v7; // [sp+Ch] [bp-4h]@1

  v3 = *(struct _SP_DEVINFO_DATA **)(a1 + 12);
  v4 = 0;
  v7 = 0;
  v6 = 0;
  if ( v3 && *(_DWORD *)(a1 + 4) == 3 )
  {
    if ( HrGetAdvancedPage(*(void **)(a1 + 8), v3, &v7) >= 0 )
    {
      if ( a2(v7, a3) )
      {
        v7 = 0;
        v4 = 1;
      }
      if ( v7 )
        DestroyPropertySheetPage(v7);
    }
    if ( HrGetIsdnPage(*(HDEVINFO *)(a1 + 8), *(PSP_DEVINFO_DATA *)(a1 + 12), &v6) >= 0 )
    {
      if ( a2(v6, a3) )
      {
        v6 = 0;
        v4 = 1;
      }
      if ( v6 )
        DestroyPropertySheetPage(v6);
    }
  }
  return v4;
}

//----- (6E65DD3A) --------------------------------------------------------
__int32 CServiceManager::HrLock()
{
  return 0;
}

//----- (6E65DD42) --------------------------------------------------------
signed int __stdcall CMSClient::QueryPropertyUi(CMSClient *this, struct IUnknown *a2)
{
  return 1;
}

//----- (6E65DD4D) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::ApplyPnpChanges(CSrvrcfg *this, struct INetCfgPnpReconfigCallback *a2)
{
  return 0;
}

//----- (6E65DD57) --------------------------------------------------------
void *__thiscall ATL::CComContainedObject<CMSClient>::CComContainedObject<CMSClient>(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  CMSClient::CMSClient(this);
  *((_DWORD *)v2 + 4) = a2;
  *(_DWORD *)v2 = &ATL::CComContainedObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComContainedObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComContainedObject<CMSClient>::`vftable';
  *((_DWORD *)v2 + 3) = &ATL::CComContainedObject<CMSClient>::`vftable';
  return v2;
}
// 6E65DD8C: using guessed type int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int);
// 6E65DDB0: using guessed type int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int);
// 6E65DDCC: using guessed type int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int);
// 6E65DDE8: using guessed type int (__stdcall *ATL::CComContainedObject<CMSClient>::`vftable')(int, int, int);

//----- (6E65DE64) --------------------------------------------------------
CSrvrcfg *__thiscall ATL::CComContainedObject<CSrvrcfg>::CComContainedObject<CSrvrcfg>(CSrvrcfg *this, int a2)
{
  CSrvrcfg *v2; // esi@1

  v2 = this;
  CSrvrcfg::CSrvrcfg(this);
  *((_DWORD *)v2 + 3) = a2;
  *(_DWORD *)v2 = &ATL::CComContainedObject<CSrvrcfg>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComContainedObject<CSrvrcfg>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComContainedObject<CSrvrcfg>::`vftable';
  return v2;
}
// 6E65DE94: using guessed type int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E65DEB8: using guessed type int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int);
// 6E65DED4: using guessed type int (__stdcall *ATL::CComContainedObject<CSrvrcfg>::`vftable')(int, int, int);

//----- (6E65DF4C) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1)
{
  return ATL::CComContainedObject<CMSClient>::Release(a1 - 4);
}
// 6E65DE2B: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::Release(_DWORD);

//----- (6E65DF5B) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1)
{
  return ATL::CComContainedObject<CMSClient>::Release(a1 - 8);
}
// 6E65DE2B: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::Release(_DWORD);

//----- (6E65DF6A) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::Release(int a1)
{
  return ATL::CComContainedObject<CMSClient>::Release(a1 - 12);
}
// 6E65DE2B: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::Release(_DWORD);

//----- (6E65DF79) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1)
{
  return ATL::CComContainedObject<CMSClient>::AddRef(a1 - 4);
}
// 6E65DE11: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::AddRef(_DWORD);

//----- (6E65DF88) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(int a1)
{
  return ATL::CComContainedObject<CSrvrcfg>::Release(a1 - 4);
}
// 6E65DF13: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(_DWORD);

//----- (6E65DF94) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1)
{
  return ATL::CComContainedObject<CMSClient>::AddRef(a1 - 8);
}
// 6E65DE11: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::AddRef(_DWORD);

//----- (6E65DFA3) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(int a1)
{
  return ATL::CComContainedObject<CSrvrcfg>::Release(a1 - 8);
}
// 6E65DF13: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::Release(_DWORD);

//----- (6E65DFB2) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CSrvrcfg>::AddRef(a1 - 4);
}
// 6E65DEF9: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(_DWORD);

//----- (6E65DFC1) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CMSClient>::QueryInterface(a1 - 4, a2, a3);
}
// 6E65DE45: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(_DWORD, _DWORD, _DWORD);

//----- (6E65DFD0) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::AddRef(int a1)
{
  return ATL::CComContainedObject<CMSClient>::AddRef(a1 - 12);
}
// 6E65DE11: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::AddRef(_DWORD);

//----- (6E65DFDF) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CSrvrcfg>::AddRef(a1 - 8);
}
// 6E65DEF9: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::AddRef(_DWORD);

//----- (6E65DFEE) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CMSClient>::QueryInterface(a1 - 8, a2, a3);
}
// 6E65DE45: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(_DWORD, _DWORD, _DWORD);

//----- (6E65DFFD) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CMSClient>::QueryInterface(a1 - 12, a2, a3);
}
// 6E65DE45: using guessed type _DWORD __stdcall ATL::CComContainedObject<CMSClient>::QueryInterface(_DWORD, _DWORD, _DWORD);

//----- (6E65E00C) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CSrvrcfg>::QueryInterface(a1 - 4, a2, a3);
}
// 6E65DF2D: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(_DWORD, _DWORD, _DWORD);

//----- (6E65E01B) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CSrvrcfg>::QueryInterface(a1 - 8, a2, a3);
}
// 6E65DF2D: using guessed type _DWORD __stdcall ATL::CComContainedObject<CSrvrcfg>::QueryInterface(_DWORD, _DWORD, _DWORD);

//----- (6E65E02A) --------------------------------------------------------
int __thiscall ATL::CComAggObject<CMSClient>::CComAggObject<CMSClient>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &ATL::CComAggObject<CMSClient>::`vftable';
  ATL::CComContainedObject<CMSClient>::CComContainedObject<CMSClient>((void *)(this + 12), a2);
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643828: using guessed type int (__stdcall *ATL::CComAggObject<CMSClient>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E05E) --------------------------------------------------------
void __thiscall ATL::CComAggObject<CMSClient>::~CComAggObject<CMSClient>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComAggObject<CMSClient>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  InterlockedDecrement(&Addend);
  CMSClient::~CMSClient((CMSClient *)(v1 + 12));
}
// 6E643828: using guessed type int (__stdcall *ATL::CComAggObject<CMSClient>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E089) --------------------------------------------------------
signed int __stdcall ATL::CComAggObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( ATL::InlineIsEqualUnknown(a2) )
  {
    if ( !a3 )
      return -2147467261;
    *a3 = (void *)a1;
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  }
  else
  {
    v3 = CMSClient::_InternalQueryInterface((CMSClient *)(a1 + 12), a2, a3);
  }
  return v3;
}

//----- (6E65E0D7) --------------------------------------------------------
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfg>::AddRef(a1 - 12);
}
// 6E643244: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfg>::AddRef(_DWORD);

//----- (6E65E0E6) --------------------------------------------------------
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfg>::AddRef(a1 - 16);
}
// 6E643244: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfg>::AddRef(_DWORD);

//----- (6E65E0F5) --------------------------------------------------------
int __stdcall ATL::CComObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfg>::AddRef(a1 - 8);
}
// 6E643244: using guessed type _DWORD __stdcall ATL::CComObject<CImplINetCfg>::AddRef(_DWORD);

//----- (6E65E104) --------------------------------------------------------
void __thiscall ATL::CComAggObject<CImplINetCfg>::~CComAggObject<CImplINetCfg>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComAggObject<CImplINetCfg>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  ReleaseIUnknownArray(5u, (struct IUnknown **)(this + 64));
  InterlockedDecrement(&Addend);
  CImplINetCfg::~CImplINetCfg((CImplINetCfg *)(v1 + 12));
}
// 6E6430FC: using guessed type int (__stdcall *ATL::CComAggObject<CImplINetCfg>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E13A) --------------------------------------------------------
signed int __stdcall ATL::CComAggObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( ATL::InlineIsEqualUnknown(a2) )
  {
    if ( !a3 )
      return -2147467261;
    *a3 = (void *)a1;
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  }
  else
  {
    v3 = CImplINetCfg::_InternalQueryInterface((CImplINetCfg *)(a1 + 12), a2, a3);
  }
  return v3;
}

//----- (6E65E188) --------------------------------------------------------
int __thiscall ATL::CComAggObject<CSrvrcfg>::CComAggObject<CSrvrcfg>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &ATL::CComAggObject<CSrvrcfg>::`vftable';
  ATL::CComContainedObject<CSrvrcfg>::CComContainedObject<CSrvrcfg>((CSrvrcfg *)(this + 12), a2);
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643108: using guessed type int (__stdcall *ATL::CComAggObject<CSrvrcfg>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E1BC) --------------------------------------------------------
void __thiscall ATL::CComAggObject<CSrvrcfg>::~CComAggObject<CSrvrcfg>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComAggObject<CSrvrcfg>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  InterlockedDecrement(&Addend);
  CSrvrcfg::~CSrvrcfg((CSrvrcfg *)(v1 + 12));
}
// 6E643108: using guessed type int (__stdcall *ATL::CComAggObject<CSrvrcfg>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E1E7) --------------------------------------------------------
signed int __stdcall ATL::CComAggObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( ATL::InlineIsEqualUnknown(a2) )
  {
    if ( !a3 )
      return -2147467261;
    *a3 = (void *)a1;
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  }
  else
  {
    v3 = CSrvrcfg::_InternalQueryInterface((CSrvrcfg *)(a1 + 12), a2, a3);
  }
  return v3;
}

//----- (6E65E235) --------------------------------------------------------
void __thiscall ATL::CComObject<CAdvancedConfig>::~CComObject<CAdvancedConfig>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComObject<CAdvancedConfig>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  InterlockedDecrement(&Addend);
  DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 8));
}
// 6E643114: using guessed type int (__stdcall *ATL::CComObject<CAdvancedConfig>::`vftable')(CAdvancedConfig *, struct _GUID *, void **);

//----- (6E65E29D) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CAdvancedConfig>::QueryInterface(CAdvancedConfig *a1, struct _GUID *a2, void **a3)
{
  return CAdvancedConfig::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E65E2B9) --------------------------------------------------------
void __thiscall ATL::CComAggObject<CAdvancedConfig>::~CComAggObject<CAdvancedConfig>(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &ATL::CComAggObject<CAdvancedConfig>::`vftable';
  *(_DWORD *)(this + 4) = 1;
  InterlockedDecrement(&Addend);
  DeleteCriticalSection((LPCRITICAL_SECTION)(v1 + 20));
}
// 6E643124: using guessed type int (__stdcall *ATL::CComAggObject<CAdvancedConfig>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E2E7) --------------------------------------------------------
signed int __stdcall ATL::CComAggObject<CAdvancedConfig>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( ATL::InlineIsEqualUnknown(a2) )
  {
    if ( !a3 )
      return -2147467261;
    *a3 = (void *)a1;
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
  }
  else
  {
    v3 = CAdvancedConfig::_InternalQueryInterface((CAdvancedConfig *)(a1 + 12), a2, a3);
  }
  return v3;
}

//----- (6E65E335) --------------------------------------------------------
void *__thiscall ATL::CComContainedObject<CAdvancedConfig>::CComContainedObject<CAdvancedConfig>(void *this, int a2)
{
  void *v2; // esi@1
  char *v3; // edi@1

  v2 = this;
  v3 = (char *)this + 4;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 4);
  *(_DWORD *)v3 = a2;
  *(_DWORD *)v2 = &ATL::CComContainedObject<CAdvancedConfig>::`vftable';
  return v2;
}
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);
// 6E65E35C: using guessed type int (__stdcall *ATL::CComContainedObject<CAdvancedConfig>::`vftable')(int, int, int);

//----- (6E65E371) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::AddRef(int a1)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 4) + 4))(*(_DWORD *)(a1 + 4));
}

//----- (6E65E38B) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::Release(int a1)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 4) + 8))(*(_DWORD *)(a1 + 4));
}

//----- (6E65E3A5) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CAdvancedConfig>::QueryInterface(int a1, int a2, int a3)
{
  return (***(int (__stdcall ****)(_DWORD, _DWORD, _DWORD))(a1 + 4))(*(_DWORD *)(a1 + 4), a2, a3);
}

//----- (6E65E3C4) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CMSClient>::QueryInterface((CMSClient *)(a1 - 4), a2, a3);
}

//----- (6E65E3D3) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfg>::QueryInterface((CImplINetCfg *)(a1 - 8), a2, a3);
}

//----- (6E65E3E2) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CMSClient>::QueryInterface((CMSClient *)(a1 - 8), a2, a3);
}

//----- (6E65E3F1) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CSrvrcfg>::QueryInterface((CSrvrcfg *)(a1 - 4), a2, a3);
}

//----- (6E65E400) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfg>::QueryInterface((CImplINetCfg *)(a1 - 12), a2, a3);
}

//----- (6E65E40F) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CMSClient>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CMSClient>::QueryInterface((CMSClient *)(a1 - 12), a2, a3);
}

//----- (6E65E41E) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CSrvrcfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CSrvrcfg>::QueryInterface((CSrvrcfg *)(a1 - 8), a2, a3);
}

//----- (6E65E42D) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfg>::QueryInterface((CImplINetCfg *)(a1 - 16), a2, a3);
}

//----- (6E65E43C) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfg>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfg>::QueryInterface((CImplINetCfg *)(a1 - 4), a2, a3);
}

//----- (6E65E44B) --------------------------------------------------------
void *__thiscall ATL::CComAggObject<CMSClient>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComAggObject<CMSClient>::~CComAggObject<CMSClient>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65E471) --------------------------------------------------------
void *__thiscall ATL::CComAggObject<CImplINetCfg>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComAggObject<CImplINetCfg>::~CComAggObject<CImplINetCfg>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65E497) --------------------------------------------------------
void *__thiscall ATL::CComAggObject<CSrvrcfg>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComAggObject<CSrvrcfg>::~CComAggObject<CSrvrcfg>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65E4BD) --------------------------------------------------------
void *__thiscall ATL::CComObject<CAdvancedConfig>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComObject<CAdvancedConfig>::~CComObject<CAdvancedConfig>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65E4E3) --------------------------------------------------------
void *__thiscall ATL::CComAggObject<CAdvancedConfig>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  ATL::CComAggObject<CAdvancedConfig>::~CComAggObject<CAdvancedConfig>((int)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E65E5A5) --------------------------------------------------------
void *__thiscall ATL::CComObject<CAdvancedConfig>::CComObject<CAdvancedConfig>(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>((char *)this + 4);
  *(_DWORD *)v2 = &ATL::CComObject<CAdvancedConfig>::`vftable';
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643114: using guessed type int (__stdcall *ATL::CComObject<CAdvancedConfig>::`vftable')(CAdvancedConfig *, struct _GUID *, void **);
// 6E64320D: using guessed type int __thiscall ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>(_DWORD);

//----- (6E65E602) --------------------------------------------------------
int __thiscall ATL::CComAggObject<CAdvancedConfig>::CComAggObject<CAdvancedConfig>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &ATL::CComAggObject<CAdvancedConfig>::`vftable';
  ATL::CComContainedObject<CAdvancedConfig>::CComContainedObject<CAdvancedConfig>((void *)(this + 12), a2);
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E643124: using guessed type int (__stdcall *ATL::CComAggObject<CAdvancedConfig>::`vftable')(int, struct _GUID *, void **);

//----- (6E65E66A) --------------------------------------------------------
void *__thiscall ATL::CComContainedObject<CImplINetCfg>::CComContainedObject<CImplINetCfg>(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  CImplINetCfg::CImplINetCfg(this);
  *((_DWORD *)v2 + 5) = a2;
  *(_DWORD *)v2 = &ATL::CComContainedObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 1) = &ATL::CComContainedObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 2) = &ATL::CComContainedObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 3) = &ATL::CComContainedObject<CImplINetCfg>::`vftable';
  *((_DWORD *)v2 + 4) = &ATL::CComContainedObject<CImplINetCfg>::`vftable';
  return v2;
}
// 6E65E6A8: using guessed type int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E65E6B8: using guessed type int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E65E6D4: using guessed type int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E65E6FC: using guessed type int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int);
// 6E65E714: using guessed type int (__stdcall *ATL::CComContainedObject<CImplINetCfg>::`vftable')(int, int, int);

//----- (6E65E745) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 20) + 4))(*(_DWORD *)(a1 + 20));
}

//----- (6E65E75F) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(a1 + 20) + 8))(*(_DWORD *)(a1 + 20));
}

//----- (6E65E779) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3)
{
  return (***(int (__stdcall ****)(_DWORD, _DWORD, _DWORD))(a1 + 20))(*(_DWORD *)(a1 + 20), a2, a3);
}

//----- (6E65E798) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::Release(a1 - 12);
}

//----- (6E65E7A4) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::AddRef(a1 - 4);
}

//----- (6E65E7B0) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::Release(a1 - 16);
}

//----- (6E65E7BC) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::AddRef(a1 - 8);
}

//----- (6E65E7C8) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CImplINetCfg>::QueryInterface(a1 - 4, a2, a3);
}

//----- (6E65E7D4) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::AddRef(a1 - 12);
}

//----- (6E65E7E3) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CImplINetCfg>::QueryInterface(a1 - 8, a2, a3);
}

//----- (6E65E7EF) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::AddRef(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::AddRef(a1 - 16);
}

//----- (6E65E7FE) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CImplINetCfg>::QueryInterface(a1 - 12, a2, a3);
}

//----- (6E65E80D) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::QueryInterface(int a1, int a2, int a3)
{
  return ATL::CComContainedObject<CImplINetCfg>::QueryInterface(a1 - 16, a2, a3);
}

//----- (6E65E81C) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::Release(a1 - 4);
}

//----- (6E65E82B) --------------------------------------------------------
int __stdcall ATL::CComContainedObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComContainedObject<CImplINetCfg>::Release(a1 - 8);
}

//----- (6E65E83A) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfg>::Release((void *)(a1 - 8));
}

//----- (6E65E849) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfg>::Release((void *)(a1 - 12));
}

//----- (6E65E858) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfg>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfg>::Release((void *)(a1 - 16));
}

//----- (6E65E867) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CMSClient>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  signed int result; // eax@2
  int v5; // ebx@3
  int v6; // ecx@3

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v5 = -2147024882;
    v6 = (int)operator new(0xF4u);
    if ( v6 )
      v3 = (void *)ATL::CComAggObject<CMSClient>::CComAggObject<CMSClient>(v6, a1);
    if ( v3 )
    {
      v5 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v5 )
        ATL::CComAggObject<CMSClient>::`scalar deleting destructor'(v3, 1);
    }
    result = v5;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E65E8DA) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CSrvrcfg>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  signed int result; // eax@2
  int v5; // ebx@3
  int v6; // ecx@3

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v5 = -2147024882;
    v6 = (int)operator new(0xB8u);
    if ( v6 )
      v3 = (void *)ATL::CComAggObject<CSrvrcfg>::CComAggObject<CSrvrcfg>(v6, a1);
    if ( v3 )
    {
      v5 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v5 )
        ATL::CComAggObject<CSrvrcfg>::`scalar deleting destructor'(v3, 1);
    }
    result = v5;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E65E94D) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComObject<CAdvancedConfig>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  signed int result; // eax@2
  int v5; // ebx@3
  void *v6; // eax@3

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v5 = -2147024882;
    v6 = operator new(0x20u);
    if ( v6 )
      v3 = ATL::CComObject<CAdvancedConfig>::CComObject<CAdvancedConfig>(v6, a1);
    if ( v3 )
    {
      v5 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v5 )
        ATL::CComObject<CAdvancedConfig>::`scalar deleting destructor'(v3, 1);
    }
    result = v5;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E65E9AE) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CAdvancedConfig>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  signed int result; // eax@2
  int v5; // ebx@3
  int v6; // eax@3

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v5 = -2147024882;
    v6 = (int)operator new(0x2Cu);
    if ( v6 )
      v3 = (void *)ATL::CComAggObject<CAdvancedConfig>::CComAggObject<CAdvancedConfig>(v6, a1);
    if ( v3 )
    {
      v5 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v5 )
        ATL::CComAggObject<CAdvancedConfig>::`scalar deleting destructor'(v3, 1);
    }
    result = v5;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E65EA0F) --------------------------------------------------------
int __thiscall ATL::CComAggObject<CImplINetCfg>::CComAggObject<CImplINetCfg>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &ATL::CComAggObject<CImplINetCfg>::`vftable';
  ATL::CComContainedObject<CImplINetCfg>::CComContainedObject<CImplINetCfg>((void *)(this + 12), a2);
  InterlockedIncrement(&Addend);
  return v2;
}
// 6E6430FC: using guessed type int (__stdcall *ATL::CComAggObject<CImplINetCfg>::`vftable')(int, struct _GUID *, void **);

//----- (6E65EA43) --------------------------------------------------------
signed int __stdcall ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CAdvancedConfig>>,ATL::CComCreator<ATL::CComAggObject<CAdvancedConfig>>>::CreateInstance(int a1, int a2, int a3)
{
  signed int result; // eax@2

  if ( a1 )
    result = ATL::CComCreator<ATL::CComAggObject<CAdvancedConfig>>::CreateInstance(a1, a2, a3);
  else
    result = ATL::CComCreator<ATL::CComObject<CAdvancedConfig>>::CreateInstance(0, a2, a3);
  return result;
}

//----- (6E65EA6A) --------------------------------------------------------
signed int __stdcall ATL::CComCreator<ATL::CComAggObject<CImplINetCfg>>::CreateInstance(int a1, int a2, int a3)
{
  void *v3; // esi@1
  signed int result; // eax@2
  int v5; // ebx@3
  int v6; // eax@3

  v3 = 0;
  if ( a3 )
  {
    *(_DWORD *)a3 = 0;
    v5 = -2147024882;
    v6 = (int)operator new(0x68u);
    if ( v6 )
      v3 = (void *)ATL::CComAggObject<CImplINetCfg>::CComAggObject<CImplINetCfg>(v6, a1);
    if ( v3 )
    {
      v5 = (**(int (__stdcall ***)(void *, int, int))v3)(v3, a2, a3);
      if ( v5 )
        ATL::CComAggObject<CImplINetCfg>::`scalar deleting destructor'(v3, 1);
    }
    result = v5;
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6E65EACB) --------------------------------------------------------
DWORD __thiscall ATL::CRegKey::DeleteSubKey(ATL::CRegKey *this, const unsigned __int16 *a2)
{
  ATL::CRegKey *v2; // esi@1
  HMODULE v3; // eax@3
  HMODULE v4; // eax@5
  int (__stdcall *v5)(_DWORD, _DWORD, _DWORD, _DWORD); // eax@7
  DWORD result; // eax@8
  int (__stdcall *v7)(_DWORD, _DWORD); // eax@9

  v2 = this;
  if ( !*((_DWORD *)this + 1) && !*((_DWORD *)this + 2) )
  {
    v3 = GetModuleHandleW(L"API-MS-Win-Core-LocalRegistry-L1-1-0.dll");
    if ( v3 )
    {
      *((_DWORD *)v2 + 1) = GetProcAddress(v3, "RegDeleteKeyExW");
    }
    else
    {
      v4 = LoadLibraryW(L"advapi32.dll");
      if ( v4 )
        *((_DWORD *)v2 + 2) = GetProcAddress(v4, "RegDeleteKeyW");
    }
  }
  v5 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*((_DWORD *)v2 + 1);
  if ( v5 )
  {
    result = v5(*(_DWORD *)v2, a2, 0, 0);
  }
  else
  {
    v7 = (int (__stdcall *)(_DWORD, _DWORD))*((_DWORD *)v2 + 2);
    if ( v7 )
      result = v7(*(_DWORD *)v2, a2);
    else
      result = GetLastError();
  }
  return result;
}

//----- (6E65EBDF) --------------------------------------------------------
int __thiscall ATL::_stdcallthunk::Init(LPCVOID lpBaseAddress, unsigned __int32 a2, void *a3)
{
  LPCVOID v3; // ST04_4@1
  HANDLE v4; // eax@1

  *((_DWORD *)lpBaseAddress + 1) = a3;
  v3 = lpBaseAddress;
  *(_DWORD *)lpBaseAddress = 69485767;
  *((_BYTE *)lpBaseAddress + 8) = -23;
  *(_DWORD *)((char *)lpBaseAddress + 9) = a2 - (_DWORD)lpBaseAddress - 13;
  v4 = GetCurrentProcess();
  FlushInstructionCache(v4, v3, 0xDu);
  return 1;
}

//----- (6E65EC1B) --------------------------------------------------------
int __thiscall ATL::CDynamicStdCallThunk::Init(ATL::CDynamicStdCallThunk *this, unsigned __int32 a2, void *a3)
{
  ATL::CDynamicStdCallThunk *v3; // esi@1
  int result; // eax@2

  v3 = this;
  if ( *(_DWORD *)this || (result = (int)__AllocStdCallThunk_cmn(), (*(_DWORD *)v3 = result) != 0) )
  {
    if ( a2 || a3 )
      result = ATL::_stdcallthunk::Init(*(LPCVOID *)v3, a2, a3);
    else
      result = 1;
  }
  return result;
}

//----- (6E65EC5B) --------------------------------------------------------
void __stdcall Ncfree(void *lpMem)
{
  if ( g_hLocalHeap )
    HeapFree(g_hLocalHeap, 0, lpMem);
}

//----- (6E65EC7E) --------------------------------------------------------
void *__stdcall Ncrealloc(void *lpMem, SIZE_T dwBytes)
{
  void *v2; // eax@1
  void *result; // eax@2

  v2 = GetHeap();
  if ( v2 )
  {
    if ( lpMem )
      result = HeapReAlloc(v2, 0, lpMem, dwBytes);
    else
      result = HeapAlloc(v2, 0, dwBytes);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E65ECB8) --------------------------------------------------------
ATL::CExpansionVector *__thiscall ATL::CExpansionVector::CExpansionVector(ATL::CExpansionVector *this)
{
  ATL::CExpansionVector *v1; // esi@1

  v1 = this;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 10;
  *(_DWORD *)this = MemAlloc(0x28u);
  return v1;
}

//----- (6E65ECDA) --------------------------------------------------------
BOOL __thiscall ATL::CRegParser::EndOfVar(ATL::CRegParser *this)
{
  return 39 == **(_WORD **)this && 39 != *CharNextW(*(LPCWSTR *)this);
}

//----- (6E65ECFF) --------------------------------------------------------
LPWSTR __userpurge sub_6E65ECFF@<eax>(LPWSTR a1@<eax>, __int16 a2)
{
  int v2; // esi@1

  v2 = 0;
  while ( *a1 )
  {
    if ( *a1 == a2 )
      return a1;
    a1 = CharNextW(a1);
  }
  return (LPWSTR)v2;
}

//----- (6E65ED2E) --------------------------------------------------------
ATL::CRegParser *__thiscall ATL::CRegParser::CRegParser(ATL::CRegParser *this, struct ATL::CRegObject *a2)
{
  ATL::CRegParser *result; // eax@1

  result = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 1) = 1;
  return result;
}

//----- (6E65ED4E) --------------------------------------------------------
BOOL __stdcall ATL::CRegParser::IsSpace(unsigned __int16 a2)
{
  return (signed int)a2 >= 9 && ((signed int)a2 <= 10 || a2 == 13 || a2 == 32);
}

//----- (6E65ED7B) --------------------------------------------------------
void __thiscall ATL::CRegParser::IncrementLinePos(ATL::CRegParser *this)
{
  ATL::CRegParser *v1; // esi@1
  LPWSTR v2; // eax@1

  v1 = this;
  v2 = CharNextW(*(LPCWSTR *)this);
  *(_DWORD *)v1 = v2;
  if ( 10 == *v2 )
    ++*((_DWORD *)v1 + 1);
}

//----- (6E65ED9C) --------------------------------------------------------
void __thiscall ATL::CRegParser::SkipWhiteSpace(ATL::CRegParser *this)
{
  ATL::CRegParser *i; // esi@1

  for ( i = this; ATL::CRegParser::IsSpace(**(_WORD **)i); ATL::CRegParser::IncrementLinePos(i) )
    ;
}

//----- (6E65EDC2) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::NextToken(ATL::CRegParser *this, unsigned __int16 *a2)
{
  ATL::CRegParser *v2; // esi@1
  unsigned __int16 *v3; // ebx@1
  unsigned __int16 v4; // ax@1
  unsigned __int16 *v6; // edi@3
  unsigned __int16 *v7; // ebx@8
  ATL::CRegParser *v8; // ecx@14

  v2 = this;
  ATL::CRegParser::SkipWhiteSpace(this);
  v3 = *(unsigned __int16 **)v2;
  v4 = **(_WORD **)v2;
  if ( !v4 )
    return -2147352567;
  v6 = a2;
  if ( 39 != v4 )
  {
    do
    {
      if ( ATL::CRegParser::IsSpace(v4) )
        break;
      ATL::CRegParser::IncrementLinePos(v8);
      if ( &v6[(*(_DWORD *)v2 - (signed int)v3) >> 1] >= a2 + 4096 )
        return -2147352567;
      for ( ; (unsigned int)v3 < *(_DWORD *)v2; ++v6 )
      {
        *v6 = *v3;
        ++v3;
      }
      v3 = *(unsigned __int16 **)v2;
      v4 = **(_WORD **)v2;
    }
    while ( v4 );
    *v6 = 0;
    return 0;
  }
  ATL::CRegParser::IncrementLinePos(v2);
  while ( **(_WORD **)v2 && !ATL::CRegParser::EndOfVar(v2) )
  {
    if ( 39 == **(_WORD **)v2 )
      ATL::CRegParser::IncrementLinePos(v2);
    v7 = *(unsigned __int16 **)v2;
    ATL::CRegParser::IncrementLinePos(v2);
    if ( &v6[(*(_DWORD *)v2 - (signed int)v7) >> 1] >= a2 + 4096 )
      return -2147352567;
    for ( ; (unsigned int)v7 < *(_DWORD *)v2; ++v6 )
    {
      *v6 = *v7;
      ++v7;
    }
  }
  if ( **(_WORD **)v2 )
  {
    *v6 = 0;
    ATL::CRegParser::IncrementLinePos(v2);
    return 0;
  }
  return -2147352567;
}

//----- (6E65EED2) --------------------------------------------------------
int __stdcall sub_6E65EED2(LPCWSTR lpString1, int a2)
{
  unsigned int v2; // esi@3

  if ( !(dword_6E69BCDC & 1) )
  {
    dword_6E69BCDC |= 1u;
    word_6E69BCD0[0] = 8;
    lpString2 = L"S";
    dword_6E69BCD4 = (int)L"D";
    word_6E69BCD8 = 3;
  }
  v2 = 0;
  while ( lstrcmpiW(lpString1, (&lpString2)[4 * v2]) )
  {
    ++v2;
    if ( v2 >= 2 )
      return 0;
  }
  *(_WORD *)a2 = word_6E69BCD0[4 * v2];
  return 1;
}
// 6E65EF44: using guessed type wchar_t aD_0[2];
// 6E65EF48: using guessed type wchar_t aS[2];
// 6E69BCD0: using guessed type __int16 word_6E69BCD0[];
// 6E69BCD4: using guessed type int dword_6E69BCD4;
// 6E69BCD8: using guessed type __int16 word_6E69BCD8;
// 6E69BCDC: using guessed type int dword_6E69BCDC;

//----- (6E65EF51) --------------------------------------------------------
int __stdcall ATL::CRegParser::CanForceRemoveKey(const unsigned __int16 *lpString1)
{
  LPCWSTR *v1; // esi@1

  v1 = (LPCWSTR *)&ATL::rgszNeverDelete;
  while ( lstrcmpiW(lpString1, *v1) )
  {
    ++v1;
    if ( (signed int)v1 >= (signed int)&std::length_error `RTTI Type Descriptor' )
      return 1;
  }
  return 0;
}
// 6E69B420: using guessed type const unsigned __int16 **ATL::rgszNeverDelete;
// 6E69B428: using guessed type int (__thiscall **std::length_error `RTTI Type Descriptor')(void *lpMem, char);

//----- (6E65EF87) --------------------------------------------------------
int __stdcall ATL::CRegParser::HasSubKeys(HKEY hKey)
{
  int result; // eax@2
  DWORD cSubKeys; // [sp+0h] [bp-4h]@1

  cSubKeys = 0;
  if ( RegQueryInfoKeyW(hKey, 0, 0, 0, &cSubKeys, 0, 0, 0, 0, 0, 0, 0) >= 0 )
    result = cSubKeys > 0;
  else
    result = 0;
  return result;
}

//----- (6E65EFC3) --------------------------------------------------------
int __stdcall ATL::CRegParser::HasValues(HKEY hKey)
{
  int result; // eax@2
  DWORD cbData; // [sp+4h] [bp-8h]@4
  DWORD cValues; // [sp+8h] [bp-4h]@1

  cValues = 0;
  if ( RegQueryInfoKeyW(hKey, 0, 0, 0, 0, 0, 0, &cValues, 0, 0, 0, 0) )
  {
    result = 0;
  }
  else if ( cValues == 1 )
  {
    cbData = 0;
    if ( RegQueryValueExW(hKey, 0, 0, 0, 0, &cbData) )
      result = 1;
    else
      result = cbData == 0;
  }
  else
  {
    result = cValues > 0;
  }
  return result;
}

//----- (6E65F02D) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::SkipAssignment(ATL::CRegParser *this, unsigned __int16 *a2)
{
  ATL::CRegParser *v2; // esi@1
  unsigned __int16 *v3; // ebx@1
  signed int result; // eax@2

  v2 = this;
  v3 = (unsigned __int16 *)MemAlloc(0x2000u);
  if ( v3 )
  {
    if ( *a2 == 61 && ATL::CRegParser::NextToken(v2, a2) >= 0 )
    {
      ATL::CRegParser::SkipWhiteSpace(v2);
      if ( ATL::CRegParser::NextToken(v2, v3) >= 0 )
        ATL::CRegParser::NextToken(v2, a2);
    }
    Ncfree(v3);
    result = 0;
  }
  else
  {
    result = -2147024882;
  }
  return result;
}

//----- (6E65F092) --------------------------------------------------------
ATL::CParseBuffer *__thiscall ATL::CParseBuffer::CParseBuffer(ATL::CParseBuffer *this, int a2)
{
  ATL::CParseBuffer *v2; // esi@1
  LPVOID v3; // eax@1

  v2 = this;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = a2;
  v3 = CoTaskMemAlloc(2 * a2);
  *((_DWORD *)v2 + 2) = v3;
  if ( !v3 )
    *((_DWORD *)v2 + 1) = 0;
  return v2;
}

//----- (6E65F0C2) --------------------------------------------------------
int __thiscall ATL::CParseBuffer::AddChar(ATL::CParseBuffer *this, unsigned __int16 a2)
{
  ATL::CParseBuffer *v2; // esi@1
  int v3; // eax@1
  LPVOID v4; // eax@2

  v2 = this;
  v3 = *((_DWORD *)this + 1);
  if ( *(_DWORD *)this != v3 )
    goto LABEL_4;
  v4 = CoTaskMemRealloc(*((LPVOID *)this + 2), 4 * v3);
  *((_DWORD *)v2 + 2) = v4;
  if ( v4 )
  {
    *((_DWORD *)v2 + 1) *= 2;
LABEL_4:
    *(_WORD *)(*((_DWORD *)v2 + 2) + 2 * (*(_DWORD *)v2)++) = a2;
    return 1;
  }
  return 0;
}

//----- (6E65F108) --------------------------------------------------------
signed int __thiscall ATL::CExpansionVector::Add(ATL::CExpansionVector *this, LPCWSTR lpString, const unsigned __int16 *a3)
{
  ATL::CExpansionVector *v3; // edi@1
  void *v4; // esi@1
  LPVOID v5; // eax@2
  void *v6; // ecx@2
  int v7; // eax@4
  void *v8; // eax@5
  signed int v10; // [sp+8h] [bp-Ch]@1
  int v11; // [sp+Ch] [bp-8h]@2
  int cb; // [sp+10h] [bp-4h]@2

  v10 = 0;
  v3 = this;
  v4 = operator new(8u);
  if ( !v4 )
    return -2147024882;
  cb = 2 * lstrlenW(lpString) + 2;
  v11 = 2 * lstrlenW(a3) + 2;
  *(_DWORD *)v4 = CoTaskMemAlloc(cb);
  v5 = CoTaskMemAlloc(v11);
  v6 = *(void **)v4;
  *((_DWORD *)v4 + 1) = v5;
  if ( !v6 || !v5 )
  {
    CoTaskMemFree(v6);
LABEL_13:
    CoTaskMemFree(*((LPVOID *)v4 + 1));
    operator delete(v4);
    return -2147024882;
  }
  memcpy(v6, lpString, cb);
  memcpy(*((void **)v4 + 1), a3, v11);
  v7 = *((_DWORD *)v3 + 2);
  if ( *((_DWORD *)v3 + 1) == v7 )
  {
    v8 = Ncrealloc(*(void **)v3, 8 * v7);
    if ( v8 )
    {
      *((_DWORD *)v3 + 2) *= 2;
      *(_DWORD *)v3 = v8;
      goto LABEL_7;
    }
    CoTaskMemFree(*(LPVOID *)v4);
    goto LABEL_13;
  }
LABEL_7:
  if ( *(_DWORD *)v3 )
    *(_DWORD *)(*(_DWORD *)v3 + 4 * (*((_DWORD *)v3 + 1))++) = v4;
  else
    v10 = -2147024882;
  return v10;
}

//----- (6E65F1E8) --------------------------------------------------------
const unsigned __int16 *__thiscall ATL::CExpansionVector::Find(ATL::CExpansionVector *this, unsigned __int16 *lpString2)
{
  ATL::CExpansionVector *v2; // esi@1
  int v3; // edi@1
  const unsigned __int16 *result; // eax@4

  v2 = this;
  v3 = 0;
  if ( *((_DWORD *)this + 1) <= 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( lstrcmpiW(**(LPCWSTR **)(*(_DWORD *)v2 + 4 * v3), lpString2) )
    {
      ++v3;
      if ( v3 >= *((_DWORD *)v2 + 1) )
        goto LABEL_4;
    }
    result = *(const unsigned __int16 **)(*(_DWORD *)(*(_DWORD *)v2 + 4 * v3) + 4);
  }
  return result;
}

//----- (6E65F22A) --------------------------------------------------------
__int32 __thiscall ATL::CExpansionVector::ClearReplacements(ATL::CExpansionVector *this)
{
  ATL::CExpansionVector *i; // esi@1
  int v2; // edi@2
  int v4; // [sp+4h] [bp-4h]@1

  v4 = 0;
  for ( i = this; v4 < *((_DWORD *)i + 1); ++v4 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)i + 4 * v4);
    CoTaskMemFree(*(LPVOID *)(v2 + 4));
    CoTaskMemFree(*(LPVOID *)v2);
    operator delete((void *)v2);
  }
  *((_DWORD *)i + 1) = 0;
  return 0;
}

//----- (6E65F278) --------------------------------------------------------
signed int __stdcall ATL::CRegObject::AddReplacement(ATL::CRegObject *this, LPCWSTR lpString, const unsigned __int16 *a3)
{
  signed int v3; // edi@1

  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  v3 = ATL::CExpansionVector::Add(this, lpString, a3);
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  return v3;
}

//----- (6E65F2AF) --------------------------------------------------------
__int32 __stdcall ATL::CRegObject::ClearReplacements(ATL::CRegObject *this)
{
  __int32 v1; // edi@1

  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  v1 = ATL::CExpansionVector::ClearReplacements(this);
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  return v1;
}

//----- (6E65F2E0) --------------------------------------------------------
const unsigned __int16 *__thiscall ATL::CRegObject::StrFromMap(ATL::CRegObject *this, unsigned __int16 *a2)
{
  ATL::CExpansionVector *v2; // esi@1
  struct _RTL_CRITICAL_SECTION *v3; // edi@1
  const unsigned __int16 *v4; // esi@1

  v2 = this;
  v3 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 12);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  v4 = ATL::CExpansionVector::Find(v2, a2);
  LeaveCriticalSection(v3);
  return v4;
}

//----- (6E65F313) --------------------------------------------------------
unsigned int __stdcall AtlA2WHelper(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar)
{
  unsigned int result; // eax@3

  if ( lpWideCharStr && lpMultiByteStr )
  {
    *lpWideCharStr = 0;
    result = MultiByteToWideChar(0, 0, lpMultiByteStr, -1, lpWideCharStr, cchWideChar) != 0 ? (unsigned int)lpWideCharStr : 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E65F351) --------------------------------------------------------
__int32 __stdcall ATL::CComClassFactory::LockServer(ATL::CComClassFactory *this, int a2)
{
  if ( a2 )
    InterlockedIncrement(&Addend);
  else
    InterlockedDecrement(&Addend);
  return 0;
}

//----- (6E65F37A) --------------------------------------------------------
void __thiscall ATL::CComModule::AddCreateWndData(ATL::CComModule *this, struct ATL::_AtlCreateWndData *a2, void *a3)
{
  ATL::CComModule *v3; // edi@1

  v3 = this;
  if ( !a3 )
    RaiseException(0xC0000005, 1u, 0, 0);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v3 + 52));
  *(_DWORD *)a2 = a3;
  *((_DWORD *)a2 + 1) = GetCurrentThreadId();
  *((_DWORD *)a2 + 2) = *((_DWORD *)v3 + 25);
  *((_DWORD *)v3 + 25) = a2;
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v3 + 52));
}

//----- (6E65F3D1) --------------------------------------------------------
int __thiscall ATL::CComModule::ExtractCreateWndData(ATL::CComModule *this)
{
  ATL::CComModule *v1; // edi@1
  int v2; // ebx@1
  int v3; // esi@1
  DWORD v4; // eax@2
  int v5; // eax@5
  int v7; // [sp+14h] [bp-1Ch]@1

  v1 = this;
  v2 = 0;
  v7 = 0;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 52));
  v3 = *((_DWORD *)v1 + 25);
  if ( v3 )
  {
    v4 = GetCurrentThreadId();
    while ( v3 )
    {
      if ( *(_DWORD *)(v3 + 4) == v4 )
      {
        v5 = *(_DWORD *)(v3 + 8);
        if ( v2 )
          *(_DWORD *)(v2 + 8) = v5;
        else
          *((_DWORD *)v1 + 25) = v5;
        v7 = *(_DWORD *)v3;
        break;
      }
      v2 = v3;
      v3 = *(_DWORD *)(v3 + 8);
    }
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 52));
  return v7;
}

//----- (6E65F452) --------------------------------------------------------
ATL::CRegObject *__thiscall ATL::CRegObject::CRegObject(ATL::CRegObject *this)
{
  ATL::CRegObject *v1; // esi@1

  v1 = this;
  ATL::CExpansionVector::CExpansionVector(this);
  InitializeCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
  return v1;
}

//----- (6E65F48D) --------------------------------------------------------
__int32 __thiscall ATL::CRegKey::Create(ATL::CRegKey *this, HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, unsigned __int32 *a8)
{
  ATL::CRegKey *v8; // edi@1
  __int32 result; // eax@1
  HKEY phkResult; // [sp+4h] [bp-8h]@1
  DWORD dwDisposition; // [sp+8h] [bp-4h]@1

  dwDisposition = 0;
  phkResult = 0;
  v8 = this;
  result = RegCreateKeyExW(
             hKey,
             lpSubKey,
             0,
             lpClass,
             dwOptions,
             samDesired,
             lpSecurityAttributes,
             &phkResult,
             &dwDisposition);
  if ( a8 )
    *a8 = dwDisposition;
  if ( !result )
  {
    result = ATL::CRegKey::Close(v8);
    *(_DWORD *)v8 = phkResult;
  }
  return result;
}

//----- (6E65F4E7) --------------------------------------------------------
__int32 __thiscall ATL::CRegKey::Open(ATL::CRegKey *this, HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired)
{
  ATL::CRegKey *v4; // esi@1
  __int32 result; // eax@1
  HKEY phkResult; // [sp+4h] [bp-4h]@1

  phkResult = 0;
  v4 = this;
  result = RegOpenKeyExW(hKey, lpSubKey, 0, samDesired, &phkResult);
  if ( !result )
  {
    result = ATL::CRegKey::Close(v4);
    *(_DWORD *)v4 = phkResult;
  }
  return result;
}

//----- (6E65F523) --------------------------------------------------------
__int32 __thiscall ATL::CRegKey::SetValue(ATL::CRegKey *this, BYTE Data, const unsigned __int16 *lpValueName)
{
  return RegSetValueExW(*(HKEY *)this, lpValueName, 0, 4u, &Data, 4u);
}

//----- (6E65F546) --------------------------------------------------------
__int32 __thiscall ATL::CRegKey::SetValue(ATL::CRegKey *this, LPCWSTR lpString, const unsigned __int16 *lpValueName)
{
  ATL::CRegKey *v3; // esi@1
  int v4; // eax@1

  v3 = this;
  v4 = lstrlenW(lpString);
  return RegSetValueExW(*(HKEY *)v3, lpValueName, 0, 1u, (const BYTE *)lpString, 2 * v4 + 2);
}

//----- (6E65F578) --------------------------------------------------------
signed int __stdcall ATL::AtlModuleUnregisterServer(struct ATL::_ATL_MODULE *a1, const struct _GUID *a2)
{
  signed int result; // eax@2
  int v3; // ebx@3
  const void *i; // edi@3
  bool v5; // zf@5

  if ( a1 )
  {
    v3 = *((_DWORD *)a1 + 4);
    for ( i = *(const void **)v3; *(_DWORD *)v3; i = *(const void **)v3 )
    {
      if ( a2 )
        v5 = memcmp(a2, i, 0x10u) == 0;
      else
        v5 = (*(int (**)(void))(v3 + 24))() == 0;
      if ( v5 )
        (*(void (__stdcall **)(_DWORD))(v3 + 4))(0);
      v3 += 28;
    }
    result = 0;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E65F5CA) --------------------------------------------------------
int __stdcall ATL::CDialogImplBase::DialogProc(HWND dwNewLong, unsigned int a2, unsigned int a3, __int32 a4)
{
  HWND v4; // esi@1
  unsigned int v5; // edi@1
  int result; // eax@9

  v4 = dwNewLong;
  v5 = a2;
  if ( (**(int (__thiscall ***)(HWND, _DWORD, unsigned int, unsigned int, __int32, HWND *, _DWORD))dwNewLong)(
         dwNewLong,
         *((_DWORD *)dwNewLong + 1),
         a2,
         a3,
         a4,
         &dwNewLong,
         0) )
  {
    if ( v5 < 0x2E || v5 > 0x2F && v5 != 55 && v5 != 57 && v5 != 272 && (v5 <= 0x131 || v5 > 0x138) )
    {
      if ( dwNewLong )
        SetWindowLongW(*((HWND *)v4 + 1), 0, (LONG)dwNewLong);
      result = 1;
    }
    else
    {
      result = (int)dwNewLong;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E65F648) --------------------------------------------------------
BOOL __thiscall ATL::CDialogImplBase::EndDialog(ATL::CDialogImplBase *this, int nResult)
{
  return EndDialog(*((HWND *)this + 1), nResult);
}

//----- (6E65F662) --------------------------------------------------------
void __thiscall ATL::CRegObject::~CRegObject(ATL::CRegObject *this)
{
  ATL::CRegObject *v1; // esi@1

  v1 = this;
  ATL::CRegObject::ClearReplacements(this);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
}

//----- (6E65F67E) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::AddValue(ATL::CRegParser *this, struct ATL::CRegKey *a2, const unsigned __int16 *a3, unsigned __int16 *a4)
{
  ATL::CRegParser *v4; // ebx@1
  void *v5; // eax@1
  const WCHAR *v6; // edi@1
  signed int result; // eax@2
  signed int v8; // eax@4
  signed int v9; // esi@5
  unsigned __int16 *v10; // esi@9
  signed int v11; // edi@11
  LONG plOut; // [sp+Ch] [bp-Ch]@16
  void *lpMem; // [sp+10h] [bp-8h]@1
  int v14; // [sp+14h] [bp-4h]@7

  v4 = this;
  v5 = MemAlloc(0x2000u);
  v6 = (const WCHAR *)v5;
  lpMem = v5;
  if ( v5 )
  {
    v8 = ATL::CRegParser::NextToken(v4, (unsigned __int16 *)v5);
    if ( v8 >= 0 )
    {
      if ( sub_6E65EED2(v6, (int)&v14) )
      {
        v10 = (unsigned __int16 *)MemAlloc(0x2000u);
        if ( v10 )
        {
          ATL::CRegParser::SkipWhiteSpace(v4);
          v11 = ATL::CRegParser::NextToken(v4, v10);
          if ( v11 < 0 )
            goto LABEL_21;
          if ( (unsigned __int16)v14 == 3 )
          {
            VarI4FromStr(v10, 0, 0, &plOut);
            ATL::CRegKey::SetValue(a2, plOut, a3);
          }
          else if ( (unsigned __int16)v14 == 8 )
          {
            ATL::CRegKey::SetValue(a2, v10, a3);
          }
          v11 = ATL::CRegParser::NextToken(v4, a4);
          if ( v11 < 0 )
          {
LABEL_21:
            Ncfree(v10);
            v9 = v11;
          }
          else
          {
            Ncfree(v10);
            v9 = 0;
          }
        }
        else
        {
          v9 = -2147024882;
        }
      }
      else
      {
        v9 = -2147352567;
      }
    }
    else
    {
      v9 = v8;
    }
    Ncfree(lpMem);
    result = v9;
  }
  else
  {
    result = -2147024882;
  }
  return result;
}

//----- (6E65F767) --------------------------------------------------------
int __thiscall ATL::CParseBuffer::AddString(ATL::CParseBuffer *this, const unsigned __int16 *a2)
{
  const unsigned __int16 *v2; // esi@1
  ATL::CParseBuffer *v3; // edi@1

  v2 = a2;
  v3 = this;
  while ( 1 )
  {
    if ( !*v2 )
      return 1;
    if ( !ATL::CParseBuffer::AddChar(v3, *v2) )
      break;
    ++v2;
  }
  return 0;
}

//----- (6E65F79E) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::PreProcessBuffer(ATL::CRegParser *this, LPCWSTR lpString, unsigned __int16 **a3)
{
  ATL::CRegParser *v3; // esi@1
  int v4; // eax@1
  LPWSTR v6; // eax@8
  LPWSTR v7; // edi@8
  int v8; // eax@9
  const unsigned __int16 *v9; // eax@10
  signed int v10; // esi@22
  unsigned __int16 *v11; // eax@25
  unsigned __int16 v12; // [sp-4h] [bp-64h]@7
  char v13; // [sp+Ch] [bp-54h]@1
  LPVOID pv; // [sp+14h] [bp-4Ch]@1
  int v15; // [sp+18h] [bp-48h]@5
  WCHAR String1; // [sp+1Ch] [bp-44h]@10

  *a3 = 0;
  v3 = this;
  v4 = lstrlenW(lpString);
  ATL::CParseBuffer::CParseBuffer((ATL::CParseBuffer *)&v13, 2 * v4);
  if ( !pv )
  {
    CoTaskMemFree(0);
    return -2147024882;
  }
  *(_DWORD *)v3 = lpString;
  v15 = 0;
  if ( !*lpString )
    goto LABEL_21;
  while ( 1 )
  {
    if ( **(_WORD **)v3 != 37 )
    {
      v12 = **(_WORD **)v3;
LABEL_16:
      if ( !ATL::CParseBuffer::AddChar((ATL::CParseBuffer *)&v13, v12) )
      {
LABEL_12:
        CoTaskMemFree(pv);
        return -2147024882;
      }
      goto LABEL_17;
    }
    ATL::CRegParser::IncrementLinePos(v3);
    v12 = 37;
    if ( **(_WORD **)v3 == 37 )
      goto LABEL_16;
    v6 = sub_6E65ECFF(*(LPWSTR *)v3, 37);
    v7 = v6;
    if ( !v6 )
      goto LABEL_19;
    v8 = (signed int)((char *)v6 - *(_DWORD *)v3) >> 1;
    if ( v8 > 31 )
      break;
    lstrcpynW(&String1, *(LPCWSTR *)v3, v8 + 1);
    v9 = ATL::CRegObject::StrFromMap(*((ATL::CRegObject **)v3 + 2), &String1);
    if ( !v9 )
    {
LABEL_19:
      v15 = -2147352567;
      goto LABEL_21;
    }
    if ( !ATL::CParseBuffer::AddString((ATL::CParseBuffer *)&v13, v9) )
      goto LABEL_12;
    while ( *(LPWSTR *)v3 != v7 )
      ATL::CRegParser::IncrementLinePos(v3);
LABEL_17:
    ATL::CRegParser::IncrementLinePos(v3);
    if ( !**(_WORD **)v3 )
      goto LABEL_21;
  }
  v15 = -2147467259;
LABEL_21:
  if ( ATL::CParseBuffer::AddChar((ATL::CParseBuffer *)&v13, 0) )
  {
    v10 = v15;
    if ( v15 >= 0 )
    {
      v11 = (unsigned __int16 *)pv;
      pv = 0;
      *a3 = v11;
    }
  }
  else
  {
    v10 = -2147024882;
  }
  CoTaskMemFree(pv);
  return v10;
}

//----- (6E65F8DE) --------------------------------------------------------
__int32 __thiscall ATL::CRegKey::RecurseDeleteKey(ATL::CRegKey *this, const unsigned __int16 *lpSubKey)
{
  HKEY v2; // ST14_4@1
  __int32 v3; // edi@1
  __int32 result; // eax@2
  DWORD v5; // eax@5
  __int32 v6; // esi@8
  struct _FILETIME ftLastWriteTime; // [sp+Ch] [bp-230h]@6
  unsigned __int16 *v8; // [sp+14h] [bp-228h]@1
  ATL::CRegKey *v9; // [sp+18h] [bp-224h]@1
  HKEY hKey; // [sp+1Ch] [bp-220h]@1
  int v11; // [sp+20h] [bp-21Ch]@1
  int v12; // [sp+24h] [bp-218h]@1
  DWORD cchName; // [sp+28h] [bp-214h]@6
  WCHAR Name; // [sp+2Ch] [bp-210h]@5
  int v15; // [sp+238h] [bp-4h]@1

  v9 = this;
  v8 = (unsigned __int16 *)lpSubKey;
  hKey = 0;
  v11 = 0;
  v12 = 0;
  v2 = *(HKEY *)this;
  v15 = 0;
  v3 = ATL::CRegKey::Open((ATL::CRegKey *)&hKey, v2, lpSubKey, 0xF003Fu);
  if ( v3 )
  {
    ATL::CRegKey::Close((ATL::CRegKey *)&hKey);
    result = v3;
  }
  else
  {
    while ( 1 )
    {
      cchName = 256;
      if ( RegEnumKeyExW(hKey, 0, &Name, &cchName, 0, 0, 0, &ftLastWriteTime) )
        break;
      v5 = ATL::CRegKey::RecurseDeleteKey((ATL::CRegKey *)&hKey, &Name);
      if ( v5 )
        goto LABEL_8;
    }
    ATL::CRegKey::Close((ATL::CRegKey *)&hKey);
    v5 = ATL::CRegKey::DeleteSubKey(v9, v8);
LABEL_8:
    v6 = v5;
    ATL::CRegKey::Close((ATL::CRegKey *)&hKey);
    result = v6;
  }
  return result;
}

//----- (6E65F9C5) --------------------------------------------------------
BOOL __stdcall ATL::CDialogImplBase::StartDialogProc(HWND hWnd, UINT a2, WPARAM a3, LPARAM a4)
{
  BOOL result; // eax@1
  int v5; // esi@2
  LONG v6; // esi@3

  result = ATL::CComModule::ExtractCreateWndData((ATL::CComModule *)&_Module);
  if ( result )
  {
    v5 = result + 20;
    *(_DWORD *)(result + 4) = hWnd;
    result = ATL::CDynamicStdCallThunk::Init(
               (ATL::CDynamicStdCallThunk *)(result + 20),
               (unsigned __int32)ATL::CDialogImplBase::DialogProc,
               (void *)result);
    if ( result )
    {
      v6 = *(_DWORD *)v5;
      SetWindowLongW(hWnd, 4, v6);
      result = ((int (__stdcall *)(HWND, UINT, WPARAM, LPARAM))v6)(hWnd, a2, a3, a4);
    }
  }
  return result;
}

//----- (6E65FA17) --------------------------------------------------------
void __thiscall ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>(void *this)
{
  void *v1; // esi@1
  void *v2; // ST00_4@2

  v1 = this;
  while ( *(_DWORD *)v1 )
  {
    v2 = *(void **)v1;
    *(_DWORD *)v1 = **(_DWORD **)v1;
    Ncfree(v2);
  }
}

//----- (6E65FA36) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::RegisterSubkeys(ATL::CRegParser *this, HKEY a2, int a3, int a4)
{
  unsigned __int16 *v4; // eax@1
  void *v5; // edi@1
  signed int v6; // esi@2
  int v8; // ebx@8
  int *v9; // ecx@17
  bool v10; // sf@31
  signed int v11; // eax@39
  unsigned __int16 *v12; // edx@46
  signed int v13; // esi@46
  unsigned __int16 v14; // bx@47
  int v15; // edx@47
  ATL::CRegParser *v16; // ecx@47
  signed int v17; // eax@62
  int v18; // [sp+Ch] [bp-250h]@1
  HKEY v19; // [sp+10h] [bp-24Ch]@27
  int v20; // [sp+14h] [bp-248h]@27
  int v21; // [sp+18h] [bp-244h]@27
  int v22; // [sp+1Ch] [bp-240h]@1
  HKEY v23; // [sp+20h] [bp-23Ch]@12
  int v24; // [sp+24h] [bp-238h]@12
  int v25; // [sp+28h] [bp-234h]@12
  HKEY v26; // [sp+2Ch] [bp-230h]@1
  int v27; // [sp+30h] [bp-22Ch]@1
  int v28; // [sp+34h] [bp-228h]@1
  HKEY hKey; // [sp+38h] [bp-224h]@1
  LPWSTR lpString1; // [sp+3Ch] [bp-220h]@6
  ATL::CRegParser *v31; // [sp+40h] [bp-21Ch]@1
  WCHAR ValueName; // [sp+44h] [bp-218h]@23
  int v33; // [sp+258h] [bp-4h]@1

  v31 = this;
  hKey = a2;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v33 = 0;
  v22 = 1;
  v18 = a4;
  v4 = (unsigned __int16 *)MemAlloc(0x2000u);
  v5 = v4;
  if ( !v4 )
    goto LABEL_2;
  v6 = ATL::CRegParser::NextToken(v31, v4);
  if ( v6 < 0 )
    goto LABEL_5;
  lpString1 = (LPWSTR)MemAlloc(0x2000u);
  if ( !lpString1 )
  {
    Ncfree(v5);
LABEL_2:
    v6 = -2147024882;
    goto LABEL_3;
  }
  do
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( *(_WORD *)v5 == 125 )
          goto LABEL_81;
        v8 = lstrcmpiW((LPCWSTR)v5, L"Delete") == 0;
        if ( !lstrcmpiW((LPCWSTR)v5, L"ForceRemove") || v8 )
        {
          v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
          if ( v6 < 0 )
            goto LABEL_81;
          if ( a3 )
          {
            v23 = 0;
            v24 = 0;
            v25 = 0;
            LOBYTE(v33) = 1;
            if ( sub_6E65ECFF((LPWSTR)v5, 92) )
            {
              Ncfree(lpString1);
              Ncfree(v5);
              ATL::CRegKey::Close((ATL::CRegKey *)&v23);
              goto LABEL_83;
            }
            if ( ATL::CRegParser::CanForceRemoveKey((const unsigned __int16 *)v5) )
            {
              v23 = hKey;
              ATL::CRegKey::RecurseDeleteKey((ATL::CRegKey *)&v23, (const unsigned __int16 *)v5);
              v23 = 0;
            }
            if ( v8 )
            {
              v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
              if ( v6 < 0 )
              {
                v9 = (int *)&v23;
              }
              else
              {
                v6 = ATL::CRegParser::SkipAssignment(v31, (unsigned __int16 *)v5);
                v9 = (int *)&v23;
                if ( v6 >= 0 )
                  goto LABEL_18;
              }
              ATL::CRegKey::Close((ATL::CRegKey *)v9);
              goto LABEL_81;
            }
            LOBYTE(v33) = 0;
            ATL::CRegKey::Close((ATL::CRegKey *)&v23);
          }
        }
        if ( !lstrcmpiW((LPCWSTR)v5, L"NoRemove") )
        {
          v22 = 0;
          v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
          if ( v6 < 0 )
            goto LABEL_81;
        }
        if ( lstrcmpiW((LPCWSTR)v5, L"Val") )
          break;
        v6 = ATL::CRegParser::NextToken(v31, &ValueName);
        if ( v6 < 0 )
          goto LABEL_81;
        v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
        if ( v6 < 0 )
          goto LABEL_81;
        if ( *(_WORD *)v5 != 61 )
          goto LABEL_86;
        if ( a3 )
        {
          v20 = 0;
          v21 = 0;
          v19 = hKey;
          LOBYTE(v33) = 2;
          v6 = ATL::CRegParser::AddValue(v31, (struct ATL::CRegKey *)&v19, &ValueName, (unsigned __int16 *)v5);
          v19 = 0;
          if ( v6 < 0 )
          {
            Ncfree(lpString1);
            Ncfree(v5);
            ATL::CRegKey::Close((ATL::CRegKey *)&v19);
            goto LABEL_3;
          }
          v9 = (int *)&v19;
LABEL_18:
          LOBYTE(v33) = 0;
          ATL::CRegKey::Close((ATL::CRegKey *)v9);
          goto LABEL_74;
        }
        if ( !a4 )
          RegDeleteValueW(hKey, &ValueName);
        v6 = ATL::CRegParser::SkipAssignment(v31, (unsigned __int16 *)v5);
        v10 = v6 < 0;
LABEL_79:
        if ( v10 )
          goto LABEL_81;
      }
      if ( sub_6E65ECFF((LPWSTR)v5, 92) )
        goto LABEL_86;
      if ( a3 )
      {
        if ( !ATL::CRegKey::Open((ATL::CRegKey *)&v26, hKey, (LPCWSTR)v5, 0xF003Fu)
          || !ATL::CRegKey::Open((ATL::CRegKey *)&v26, hKey, (LPCWSTR)v5, 0x20019u)
          || !ATL::CRegKey::Create((ATL::CRegKey *)&v26, hKey, (LPCWSTR)v5, 0, 0, 0xF003Fu, 0, 0) )
        {
          v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
          if ( v6 >= 0 )
          {
            if ( *(_WORD *)v5 == 61 )
            {
              v11 = ATL::CRegParser::AddValue(v31, (struct ATL::CRegKey *)&v26, 0, (unsigned __int16 *)v5);
              goto LABEL_73;
            }
            goto LABEL_74;
          }
          goto LABEL_81;
        }
LABEL_86:
        Ncfree(lpString1);
        Ncfree(v5);
LABEL_83:
        v6 = -2147352567;
        goto LABEL_3;
      }
      if ( !a4 && ATL::CRegKey::Open((ATL::CRegKey *)&v26, hKey, (LPCWSTR)v5, 0xF003Fu) )
        a4 = 1;
      lstrcpynW(lpString1, (LPCWSTR)v5, 260);
      if ( !a4 && !ATL::CRegParser::HasSubKeys(v26) && !ATL::CRegParser::HasValues(v26) )
        break;
      v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
      if ( v6 < 0 )
        goto LABEL_81;
      v6 = ATL::CRegParser::SkipAssignment(v31, (unsigned __int16 *)v5);
      if ( v6 < 0 )
        goto LABEL_81;
      if ( *(_WORD *)v5 == 123 )
      {
        v6 = ATL::CRegParser::RegisterSubkeys(v31, v26, 0, a4);
        if ( v6 < 0 )
          goto LABEL_81;
        if ( a4 )
        {
          a4 = v18;
          v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
          if ( v6 < 0 )
            goto LABEL_81;
          v17 = ATL::CRegParser::SkipAssignment(v31, (unsigned __int16 *)v5);
          goto LABEL_78;
        }
LABEL_64:
        if ( ATL::CRegParser::HasSubKeys(v26) )
        {
          if ( ATL::CRegParser::CanForceRemoveKey(lpString1) )
            ATL::CRegKey::RecurseDeleteKey((ATL::CRegKey *)&v26, lpString1);
LABEL_77:
          v17 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
LABEL_78:
          v6 = v17;
          v10 = v17 < 0;
          goto LABEL_79;
        }
        if ( !a4 )
          goto LABEL_68;
      }
      else if ( !a4 )
      {
        goto LABEL_64;
      }
    }
    v12 = *(unsigned __int16 **)v31;
    v13 = 0;
    while ( 1 )
    {
      v14 = *v12;
      if ( ATL::CRegParser::IsSpace(*v12) )
        goto LABEL_48;
      if ( v14 != 123 )
        break;
      if ( v13 )
        goto LABEL_68;
      v13 = 1;
LABEL_48:
      v12 = (unsigned __int16 *)(v15 + 2);
    }
    if ( *(_WORD *)v15 == 125 && v13 == 1 && ATL::CRegParser::NextToken(v16, (unsigned __int16 *)v5) >= 0 )
      ATL::CRegParser::RegisterSubkeys(v31, v26, 0, 0);
LABEL_68:
    if ( ATL::CRegKey::Close((ATL::CRegKey *)&v26) )
      goto LABEL_86;
    if ( v22 )
      RegDeleteKeyW(hKey, lpString1);
    v6 = ATL::CRegParser::NextToken(v31, (unsigned __int16 *)v5);
    if ( v6 < 0 )
      goto LABEL_81;
    v11 = ATL::CRegParser::SkipAssignment(v31, (unsigned __int16 *)v5);
LABEL_73:
    v6 = v11;
    if ( v11 < 0 )
      goto LABEL_81;
LABEL_74:
    ;
  }
  while ( !a3 || *(_WORD *)v5 != 123 );
  v6 = ATL::CRegParser::RegisterSubkeys(v31, v26, a3, 0);
  if ( v6 >= 0 )
    goto LABEL_77;
LABEL_81:
  Ncfree(lpString1);
LABEL_5:
  Ncfree(v5);
LABEL_3:
  ATL::CRegKey::Close((ATL::CRegKey *)&v26);
  return v6;
}

//----- (6E660091) --------------------------------------------------------
signed int __thiscall ATL::CRegParser::RegisterBuffer(ATL::CRegParser *this, LPCWSTR lpString, int a3)
{
  ATL::CRegParser *v3; // esi@1
  signed int result; // eax@1
  signed int v5; // edi@1
  LPVOID v6; // eax@2
  unsigned int v7; // edi@4
  LPVOID v8; // ebx@12
  HKEY v9; // ST00_4@20
  LPVOID pv; // [sp+Ch] [bp-214h]@1
  HKEY v11; // [sp+10h] [bp-210h]@7
  WCHAR String1; // [sp+14h] [bp-20Ch]@3

  v3 = this;
  pv = 0;
  result = ATL::CRegParser::PreProcessBuffer(this, lpString, (unsigned __int16 **)&pv);
  v5 = result;
  if ( result >= 0 )
  {
    v6 = pv;
    for ( *(_DWORD *)v3 = pv; *(_WORD *)v6; v6 = *(LPVOID *)v3 )
    {
      v5 = ATL::CRegParser::NextToken(v3, &String1);
      if ( v5 < 0 )
        break;
      v7 = 0;
      while ( lstrcmpiW(&String1, (&off_6E6601E0)[4 * v7]) )
      {
        ++v7;
        if ( v7 >= 0xE )
        {
          v11 = 0;
          goto LABEL_8;
        }
      }
      v11 = (HKEY)dword_6E6601E4[2 * v7];
LABEL_8:
      if ( !v11 )
        goto LABEL_24;
      v5 = ATL::CRegParser::NextToken(v3, &String1);
      if ( v5 < 0 )
        break;
      if ( 123 != String1 )
      {
LABEL_24:
        v5 = -2147352567;
        break;
      }
      if ( a3 )
      {
        v8 = *(LPVOID *)v3;
        v5 = ATL::CRegParser::RegisterSubkeys(v3, v11, a3, 0);
        if ( v5 < 0 )
        {
          v9 = v11;
          *(_DWORD *)v3 = v8;
          ATL::CRegParser::RegisterSubkeys(v3, v9, 0, 0);
          break;
        }
      }
      else
      {
        v5 = ATL::CRegParser::RegisterSubkeys(v3, v11, 0, 0);
        if ( v5 < 0 )
          break;
      }
      ATL::CRegParser::SkipWhiteSpace(v3);
    }
    CoTaskMemFree(pv);
    result = v5;
  }
  return result;
}
// 6E6601E4: using guessed type int dword_6E6601E4[];

//----- (6E660255) --------------------------------------------------------
DWORD __thiscall ATL::CRegObject::RegisterFromResource(ATL::CRegObject *this, LPCWSTR lpLibFileName, LPCWSTR lpName, LPCWSTR lpType, int a5)
{
  HMODULE v5; // eax@1
  HMODULE v6; // edi@1
  DWORD v7; // eax@2
  DWORD v8; // esi@3
  HRSRC v9; // eax@5
  HRSRC v10; // esi@5
  DWORD v11; // eax@6
  HGLOBAL v12; // ebx@8
  DWORD v13; // esi@9
  const CHAR *v14; // edi@9
  void *v15; // esp@10
  unsigned int v16; // eax@12
  int v17; // eax@13
  void *v18; // esp@13
  int v20; // [sp+0h] [bp-20h]@10
  char v21; // [sp+Ch] [bp-14h]@1
  HMODULE hLibModule; // [sp+18h] [bp-8h]@1

  ATL::CRegParser::CRegParser((ATL::CRegParser *)&v21, this);
  v5 = LoadLibraryExW(lpLibFileName, 0, 2u);
  v6 = v5;
  hLibModule = v5;
  if ( v5 )
  {
    v9 = FindResourceW(v5, lpName, lpType);
    v10 = v9;
    if ( v9 && (v12 = LoadResource(v6, v9)) != 0 )
    {
      v13 = SizeofResource(v6, v10);
      v14 = (const CHAR *)v12;
      if ( *((_BYTE *)v12 + v13) )
      {
        v15 = alloca(v13 + 1);
        v14 = (const CHAR *)&v20;
        memcpy(&v20, v12, v13 + 1);
        *((_BYTE *)&v20 + v13) = 0;
      }
      if ( v14 )
      {
        v17 = lstrlenA(v14);
        v18 = alloca(2 * (v17 + 1));
        v16 = AtlA2WHelper((LPWSTR)&v20, v14, v17 + 1);
      }
      else
      {
        v16 = 0;
      }
      v11 = ATL::CRegParser::RegisterBuffer((ATL::CRegParser *)&v21, (LPCWSTR)v16, a5);
    }
    else
    {
      v11 = GetLastError();
      if ( (signed int)v11 > 0 )
        v11 = (unsigned __int16)v11 | 0x80070000;
    }
    v8 = v11;
    FreeLibrary(hLibModule);
  }
  else
  {
    v7 = GetLastError();
    if ( (signed int)v7 > 0 )
      v7 = (unsigned __int16)v7 | 0x80070000;
    v8 = v7;
  }
  return v8;
}

//----- (6E660361) --------------------------------------------------------
DWORD __stdcall ATL::CRegObject::ResourceRegister(ATL::CRegObject *this, LPCWSTR lpLibFileName, __int16 a3, LPCWSTR lpType)
{
  return ATL::CRegObject::RegisterFromResource(this, lpLibFileName, (LPCWSTR)(unsigned __int16)a3, lpType, 1);
}

//----- (6E660384) --------------------------------------------------------
DWORD __stdcall ATL::CRegObject::ResourceUnregister(ATL::CRegObject *this, LPCWSTR lpLibFileName, __int16 a3, LPCWSTR lpType)
{
  return ATL::CRegObject::RegisterFromResource(this, lpLibFileName, (LPCWSTR)(unsigned __int16)a3, lpType, 0);
}

//----- (6E6603A7) --------------------------------------------------------
DWORD __stdcall ATL::CComModule::UpdateRegistryFromResourceS(ATL::CComModule *this, __int16 a2, int a3, struct ATL::_ATL_REGMAP_ENTRY *a4)
{
  struct ATL::_ATL_REGMAP_ENTRY *v4; // esi@1
  DWORD v5; // eax@2
  DWORD v6; // esi@4
  char v8; // [sp+Ch] [bp-244h]@1
  int v9; // [sp+30h] [bp-220h]@1
  WCHAR Filename; // [sp+34h] [bp-21Ch]@1
  char Dst; // [sp+36h] [bp-21Ah]@1
  int v12; // [sp+24Ch] [bp-4h]@1

  v4 = a4;
  v9 = 0;
  v12 = 0;
  ATL::CRegObject::CRegObject((ATL::CRegObject *)&v8);
  Filename = 0;
  LOBYTE(v12) = 1;
  memset(&Dst, 0, 0x208u);
  if ( GetModuleFileNameW(hModule, &Filename, 0x104u) )
  {
    ATL::CRegObject::AddReplacement((ATL::CRegObject *)&v8, L"Module", &Filename);
    if ( a4 )
    {
      while ( *(_DWORD *)v4 )
      {
        ATL::CRegObject::AddReplacement((ATL::CRegObject *)&v8, *(LPCWSTR *)v4, *((const unsigned __int16 **)v4 + 1));
        v4 = (struct ATL::_ATL_REGMAP_ENTRY *)((char *)v4 + 8);
      }
    }
    if ( a3 )
      v5 = ATL::CRegObject::ResourceRegister((ATL::CRegObject *)&v8, &Filename, a2, L"REGISTRY");
    else
      v5 = ATL::CRegObject::ResourceUnregister((ATL::CRegObject *)&v8, &Filename, a2, L"REGISTRY");
  }
  else
  {
    v5 = GetLastError();
    if ( (signed int)v5 > 0 )
      v5 = (unsigned __int16)v5 | 0x80070000;
  }
  v6 = v5;
  ATL::CRegObject::~CRegObject((ATL::CRegObject *)&v8);
  ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::_ATL_SAFE_ALLOCA_IMPL::_CCRTAllocator>(&v9);
  return v6;
}

//----- (6E6604CF) --------------------------------------------------------
const unsigned __int16 *__stdcall SzLoadString(HINSTANCE hModule, unsigned int a2)
{
  return SzLoadStringPcch(hModule, a2, (int *)&a2);
}

//----- (6E6604EC) --------------------------------------------------------
void __stdcall CiSetReservedField(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const void *a3)
{
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+Ch] [bp-230h]@1

  HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
  Dst.ClassInstallReserved = (ULONG_PTR)a3;
  HrSetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
}

//----- (6E660545) --------------------------------------------------------
void __stdcall CiClearReservedField(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+8h] [bp-230h]@1

  HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
  Dst.ClassInstallReserved = 0;
  HrSetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
}

//----- (6E66059A) --------------------------------------------------------
const unsigned __int16 *__stdcall SzLoadIds(unsigned int a1)
{
  return SzLoadString(hInst, a1);
}

//----- (6E6605B6) --------------------------------------------------------
__int32 __thiscall HrRegGetSzWithAlloc(unsigned __int32 this, HKEY a2, const unsigned __int16 *lpMem, unsigned __int16 **a4)
{
  return HrRegGetTypeWithAlloc(this, a2, lpMem, 1u, (unsigned __int8 **)a4, 0);
}

//----- (6E6605D6) --------------------------------------------------------
BOOL __stdcall FIsValidErrorFromINetCfgForDiHook(__int32 a1)
{
  return a1 == -2147180508 || a1 == -2147180507;
}

//----- (6E6605FD) --------------------------------------------------------
signed int __stdcall HrDiAddComponentToINetCfg(int a1, int a2, int a3)
{
  signed int result; // eax@1
  struct CComponent *v4; // [sp+10h] [bp-40h]@1
  char v5; // [sp+14h] [bp-3Ch]@1
  int v6; // [sp+18h] [bp-38h]@1
  int v7; // [sp+1Ch] [bp-34h]@1
  int v8; // [sp+20h] [bp-30h]@1
  int v9; // [sp+24h] [bp-2Ch]@1
  int v10; // [sp+28h] [bp-28h]@1
  int v11; // [sp+2Ch] [bp-24h]@1
  int v12; // [sp+30h] [bp-20h]@1
  int v13; // [sp+34h] [bp-1Ch]@1
  int v14; // [sp+38h] [bp-18h]@1
  int v15; // [sp+4Ch] [bp-4h]@1

  v15 = 0;
  memset(&v5, 0, 0x28u);
  *(_DWORD *)&v5 = *(_DWORD *)(a3 + 20);
  v6 = *(_DWORD *)(a3 + 24);
  v7 = *(_DWORD *)(a3 + 28);
  v8 = *(_DWORD *)(a3 + 32);
  v9 = NetClassEnumFromGuid((const void *)(a3 + 4));
  v14 = *(_DWORD *)(a3 + 40);
  v13 = *(_DWORD *)(a3 + 44);
  v10 = *(_DWORD *)(a3 + 36);
  v11 = *(_DWORD *)(a3 + 48);
  v12 = *(_DWORD *)(a3 + 52);
  result = CComponent::HrCreateInstance((const struct BASIC_COMPONENT_DATA *)&v5, 1, 0, &v4);
  if ( !result )
    result = (*(int (__stdcall **)(int, struct CComponent *))(*(_DWORD *)a2 + 24))(a2, v4);
  return result;
}

//----- (6E660694) --------------------------------------------------------
__int32 __stdcall HrDiNotifyINetCfgOfInstallation(const struct NIQ_INFO *a1)
{
  signed int v1; // ebx@1
  __int32 v2; // esi@1
  signed int v3; // eax@4
  int v4; // eax@9
  int v6; // [sp+Ch] [bp-Ch]@1
  struct IUnknown *v7; // [sp+10h] [bp-8h]@1
  struct IUnknown *v8; // [sp+14h] [bp-4h]@2

  v1 = 0;
  v6 = 1;
  v2 = HrCreateAndInitializeINetCfg(&v6, (struct INetCfg **)&v7, 1, 0x7D0u, L"INetCfg Installer Interface", 0);
  if ( v2 >= 0 )
  {
    v2 = v7->lpVtbl->QueryInterface(v7, &IID_INetCfgInternalSetup, (void **)&v8);
    if ( !v2 )
    {
      if ( *(_DWORD *)a1 )
        v3 = ((int (__stdcall *)(struct IUnknown *, _DWORD))v8->lpVtbl[2].AddRef)(v8, *((_DWORD *)a1 + 10));
      else
        v3 = HrDiAddComponentToINetCfg((int)v7, (int)v8, (int)a1);
      v2 = v3;
      if ( v3 == 303136 )
      {
        v1 = 1;
        v2 = 0;
      }
      ReleaseObj(v8);
    }
    v4 = HrUninitializeAndReleaseINetCfg(v6, v7, 1);
    if ( !v2 )
    {
      v2 = v4;
      if ( !v4 )
      {
        if ( v1 )
          v2 = 303136;
      }
    }
  }
  return v2;
}

//----- (6E660779) --------------------------------------------------------
void __stdcall DisableWOLForWiFi(struct COMPONENT_INSTALL_INFO *a1)
{
  SP_LOG_TOKEN v1; // kr00_8@1
  __int32 v2; // eax@7
  DWORD v3; // [sp+8h] [bp-Ch]@4
  DWORD Type; // [sp+Ch] [bp-8h]@2
  HKEY hKey; // [sp+10h] [bp-4h]@1

  hKey = 0;
  v1 = SetupGetThreadLogToken();
  if ( !HrSetupDiOpenDevRegKey(*((HDEVINFO *)a1 + 14), *((PSP_DEVINFO_DATA *)a1 + 15), 1u, 0, 2u, 0xF003Fu, &hKey) )
  {
    if ( HrRegQueryDword(hKey, L"PnPCapabilities", (DWORD)&Type)
      && !HrRegQueryDword(hKey, L"Characteristics", (DWORD)&Type)
      && !HrRegQueryDword(hKey, L"*IfType", (DWORD)&v3)
      && Type & 4
      && v3 == 71 )
    {
      v2 = HrRegSetDword(hKey, L"PnPCapabilities", 0x10u);
      if ( v2 )
        _SetupWriteTextLog(
          v1,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: Failed to disable WoL for WiFi device with error code HR 0x%lx",
          v2);
    }
    RegCloseKey(hKey);
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6608E9) --------------------------------------------------------
__int32 __stdcall HrDiNotifyINetCfgOfRemoval(const unsigned __int16 *a1)
{
  __int32 v1; // esi@1
  int v2; // eax@6
  signed int v4; // [sp+8h] [bp-10h]@2
  int v5; // [sp+Ch] [bp-Ch]@1
  struct IUnknown *v6; // [sp+10h] [bp-8h]@1
  struct IUnknown *v7; // [sp+14h] [bp-4h]@2

  v5 = 1;
  v1 = HrCreateAndInitializeINetCfg(&v5, (struct INetCfg **)&v6, 1, 0x7D0u, L"INetCfg UnInstaller Interface", 0);
  if ( v1 >= 0 )
  {
    v4 = 0;
    v1 = v6->lpVtbl->QueryInterface(v6, &IID_INetCfgInternalSetup, (void **)&v7);
    if ( v1 >= 0 )
    {
      v1 = ((int (__stdcall *)(struct IUnknown *, const unsigned __int16 *))v7->lpVtbl[3].QueryInterface)(v7, a1);
      if ( v1 == 303136 )
        v4 = 1;
      ReleaseObj(v7);
    }
    v2 = HrUninitializeAndReleaseINetCfg(v5, v6, 1);
    if ( v1 >= 0 )
    {
      v1 = v2;
      if ( v2 >= 0 )
      {
        if ( v4 )
          v1 = 303136;
      }
    }
  }
  return v1;
}

//----- (6E6609C1) --------------------------------------------------------
int __stdcall IsServiceRunning(LPCWSTR lpServiceName)
{
  SC_HANDLE v1; // eax@1
  SC_HANDLE v2; // ebx@1
  SC_HANDLE v3; // edi@2
  struct _SERVICE_STATUS ServiceStatus; // [sp+8h] [bp-20h]@3
  int v6; // [sp+24h] [bp-4h]@1

  v6 = 0;
  v1 = OpenSCManagerW(0, 0, 4u);
  v2 = v1;
  if ( v1 )
  {
    v3 = OpenServiceW(v1, lpServiceName, 4u);
    if ( v3 )
    {
      if ( QueryServiceStatus(v3, &ServiceStatus) )
        v6 = ServiceStatus.dwCurrentState == 4;
      CloseServiceHandle(v3);
    }
    CloseServiceHandle(v2);
  }
  return v6;
}

//----- (6E660A29) --------------------------------------------------------
int __stdcall FIsEnumerated(const struct _GUID *a1)
{
  int result; // eax@2

  if ( !memcmp(&GUID_DEVCLASS_NET, a1, 0x10u) || (result = 0, !memcmp(&GUID_DEVCLASS_INFRARED, a1, 0x10u)) )
    result = 1;
  return result;
}

//----- (6E660A60) --------------------------------------------------------
int __stdcall FIsHandledByClassInstaller(const struct _GUID *a1)
{
  int result; // eax@4

  if ( FIsEnumerated(a1)
    || !memcmp(&GUID_DEVCLASS_NETTRANS, a1, 0x10u)
    || !memcmp(&GUID_DEVCLASS_NETCLIENT, a1, 0x10u)
    || (result = 0, !memcmp(&GUID_DEVCLASS_NETSERVICE, a1, 0x10u)) )
    result = 1;
  return result;
}

//----- (6E660AB4) --------------------------------------------------------
__int32 __stdcall HrInsertItemIntoInstallQueue(const struct NIQ_INFO *a1)
{
  signed int v1; // edi@1
  HRESULT v2; // esi@1
  LPVOID ppv; // [sp+8h] [bp-4h]@4

  v1 = 1;
  v2 = CoInitializeEx(0, 4u);
  if ( v2 == -2147417850 )
  {
    v2 = 0;
    v1 = 0;
  }
  if ( v2 >= 0 )
  {
    v2 = HrCreateInstanceBase(&CLSID_InstallQueue, 0x415u, &_GUID_98133274_4b20_11d1_ab01_00805fc1270e, &ppv);
    if ( !v2 )
    {
      v2 = (*(int (__stdcall **)(LPVOID, const struct NIQ_INFO *))(*(_DWORD *)ppv + 12))(ppv, a1);
      (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
    }
    if ( v1 )
      CoUninitialize();
  }
  return v2;
}

//----- (6E660B49) --------------------------------------------------------
__int32 __stdcall HrDiInstallNetAdapter(struct COMPONENT_INSTALL_INFO *phkResult)
{
  signed int v1; // edi@1
  __int32 v2; // eax@3
  void *v3; // eax@4
  struct _SP_DEVINFO_DATA *v4; // ST14_4@7
  void *v5; // ST10_4@7
  int v6; // esi@13
  bool v7; // zf@13
  int v8; // eax@13
  int v9; // eax@13
  int v10; // edi@21
  int v11; // eax@23
  ULONG_PTR v13; // [sp+Ch] [bp-8ECh]@1
  void *lpMem; // [sp+10h] [bp-8E8h]@3
  SP_LOG_TOKEN LogToken; // [sp+14h] [bp-8E4h]@1
  int v16; // [sp+1Ch] [bp-8DCh]@7
  __int32 v17; // [sp+20h] [bp-8D8h]@3
  struct _SP_DRVINFO_DATA_V2_W v18; // [sp+24h] [bp-8D4h]@3
  struct _SP_DEVINSTALL_PARAMS_W v19; // [sp+640h] [bp-2B8h]@1
  int Dst; // [sp+86Ch] [bp-8Ch]@13
  int v21; // [sp+870h] [bp-88h]@13
  int v22; // [sp+874h] [bp-84h]@13
  int v23; // [sp+878h] [bp-80h]@13
  int v24; // [sp+87Ch] [bp-7Ch]@13
  int v25; // [sp+880h] [bp-78h]@13
  int v26; // [sp+884h] [bp-74h]@13
  int v27; // [sp+888h] [bp-70h]@13
  int v28; // [sp+88Ch] [bp-6Ch]@13
  int v29; // [sp+890h] [bp-68h]@13
  int v30; // [sp+894h] [bp-64h]@13
  int v31; // [sp+898h] [bp-60h]@13
  DWORD v32; // [sp+89Ch] [bp-5Ch]@13
  DWORD v33; // [sp+8A0h] [bp-58h]@13
  OLECHAR sz; // [sp+8A4h] [bp-54h]@16

  v13 = 0;
  v1 = 1;
  LogToken = SetupGetThreadLogToken();
  HrSetupDiGetDeviceInstallParams(*((HDEVINFO *)phkResult + 14), *((PSP_DEVINFO_DATA *)phkResult + 15), &v19);
  if ( v19.ClassInstallReserved )
  {
    v13 = v19.ClassInstallReserved;
    v1 = 0;
  }
  lpMem = 0;
  v2 = HrCiGetDriverDetail(
         *((HDEVINFO *)phkResult + 14),
         *((PSP_DEVINFO_DATA *)phkResult + 15),
         &v18,
         (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem);
  v17 = v2;
  if ( !v2 )
  {
    v3 = lpMem;
    *((_DWORD *)phkResult + 2) = (char *)lpMem + 536;
    *((_DWORD *)phkResult + 1) = (char *)v3 + 1568;
    *((_DWORD *)phkResult + 10) = (char *)v3 + 24;
    *((_DWORD *)phkResult + 11) = (char *)&v18 + 12;
LABEL_10:
    v17 = HrCiInstallComponentInternal((HKEY)phkResult);
    DisableWOLForWiFi(phkResult);
    if ( !v17 )
    {
      if ( !v1 || FIsFilterDevice(*((HDEVINFO *)phkResult + 14), *((PSP_DEVINFO_DATA *)phkResult + 15)) )
      {
        if ( v13 )
        {
          *(_DWORD *)(v13 + 16) = *((_DWORD *)phkResult + 9);
          *(_DWORD *)v13 = *((_DWORD *)phkResult + 4);
          *(_DWORD *)(v13 + 4) = *((_DWORD *)phkResult + 5);
          v10 = v13 + 8;
          *(_DWORD *)v10 = *((_DWORD *)phkResult + 6);
          *(_DWORD *)(v10 + 4) = *((_DWORD *)phkResult + 7);
        }
      }
      else
      {
        memset(&Dst, 0, 0x38u);
        v6 = *((_DWORD *)phkResult + 15) + 4;
        v7 = *((_DWORD *)phkResult + 17) == 1;
        Dst = *((_DWORD *)phkResult + 8) != 0;
        v21 = *(_DWORD *)v6;
        v6 += 4;
        v22 = *(_DWORD *)v6;
        v6 += 4;
        v23 = *(_DWORD *)v6;
        v8 = *((_DWORD *)phkResult + 9);
        v24 = *(_DWORD *)(v6 + 4);
        v25 = *((_DWORD *)phkResult + 4);
        v26 = *((_DWORD *)phkResult + 5);
        v27 = *((_DWORD *)phkResult + 6);
        v28 = *((_DWORD *)phkResult + 7);
        v29 = v8;
        v32 = v19.Flags;
        v33 = v19.FlagsEx;
        v31 = *((_DWORD *)phkResult + 1);
        v9 = *((_DWORD *)phkResult + 13);
        v30 = *((_DWORD *)phkResult + 13);
        if ( v7 )
          Dst = 0;
        _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN BINDINGS UPDATE for %ws]", v9);
        v17 = HrDiNotifyINetCfgOfInstallation((const struct NIQ_INFO *)&Dst);
        if ( FIsValidErrorFromINetCfgForDiHook(v17) )
        {
          StringFromGUID2((const GUID *const )phkResult + 1, &sz, 39);
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "! NCI: Binding engine busy [0x%08X]. Adding device to queue",
            v17);
          v17 = HrInsertItemIntoInstallQueue((const struct NIQ_INFO *)&Dst);
        }
        else if ( v17 == 303136 )
        {
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "NCI: Reboot has been requested during binding process. Setting DI_NEEDREBOOT");
          HrSetupDiSetDeipFlags(*((HDEVINFO *)phkResult + 14), *((struct _SP_DEVINFO_DATA **)phkResult + 15), 256, 0, 1);
          v17 = 0;
        }
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "[NCI END BINDINGS UPDATE for %ws. Result 0x%08X]",
          v30,
          v17);
      }
      if ( *((_BYTE *)phkResult + 36) & 4 )
      {
        v11 = *((_DWORD *)phkResult + 15);
        if ( !memcmp(&GUID_DEVCLASS_NET, (const void *)(v11 + 4), 0x10u) )
          AddOrRemoveLegacyNt4AdapterKey(
            *((HDEVINFO *)phkResult + 14),
            (struct _SP_DEVINFO_DATA *)v11,
            (GUID *)phkResult + 1,
            *((BYTE **)phkResult + 11),
            0);
      }
    }
    MemFree(lpMem);
    goto LABEL_26;
  }
  if ( v2 == -2146500093 )
  {
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Null driver install.");
    if ( !HrCiIsInstalledComponent(phkResult, 0) )
    {
      v4 = (struct _SP_DEVINFO_DATA *)*((_DWORD *)phkResult + 15);
      v16 = 1;
      v5 = (void *)*((_DWORD *)phkResult + 14);
      v17 = v1;
      CiSetReservedField(v5, v4, &v16);
      HrSetupDiCallClassInstaller(5u, *((HDEVINFO *)phkResult + 14), *((PSP_DEVINFO_DATA *)phkResult + 15));
      CiClearReservedField(*((HDEVINFO *)phkResult + 14), *((PSP_DEVINFO_DATA *)phkResult + 15));
    }
    v17 = -2146500082;
  }
  if ( !v17 )
    goto LABEL_10;
LABEL_26:
  if ( v17 >= 0 )
    v17 = 0;
  return v17;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E660F83) --------------------------------------------------------
__int32 __stdcall HrDiRemoveNetAdapter(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, unsigned __int16 *a3, HWND a4)
{
  PSP_DEVINFO_DATA v4; // esi@1
  DWORD v5; // eax@2
  __int32 v6; // eax@3
  bool v7; // sf@15
  unsigned __int8 v8; // of@15
  const WCHAR *v9; // ST18_4@20
  int v10; // eax@20
  int v11; // esi@25
  __int32 v12; // eax@25
  DWORD Type; // [sp+Ch] [bp-298h]@6
  HKEY v15; // [sp+10h] [bp-294h]@1
  HKEY hKey; // [sp+14h] [bp-290h]@1
  struct _SP_DEVINFO_DATA *v17; // [sp+18h] [bp-28Ch]@1
  DWORD v18; // [sp+1Ch] [bp-288h]@1
  void *lpMem; // [sp+20h] [bp-284h]@1
  SP_LOG_TOKEN LogToken; // [sp+24h] [bp-280h]@1
  unsigned __int16 *v21; // [sp+2Ch] [bp-278h]@1
  HDEVINFO v22; // [sp+30h] [bp-274h]@1
  struct IUnknown *v23; // [sp+34h] [bp-270h]@1
  __int32 v24; // [sp+38h] [bp-26Ch]@3
  struct _SP_DEVINSTALL_PARAMS_W v25; // [sp+3Ch] [bp-268h]@1
  int Dst; // [sp+268h] [bp-3Ch]@25
  int v27; // [sp+26Ch] [bp-38h]@25
  int v28; // [sp+270h] [bp-34h]@25
  int v29; // [sp+274h] [bp-30h]@25
  int v30; // [sp+278h] [bp-2Ch]@25
  unsigned __int16 *v31; // [sp+290h] [bp-14h]@25
  const WCHAR *v32; // [sp+294h] [bp-10h]@25

  v4 = DeviceInfoData;
  v21 = a3;
  v22 = DeviceInfoSet;
  v17 = DeviceInfoData;
  hKey = 0;
  v15 = 0;
  lpMem = (void *)1;
  v23 = (struct IUnknown *)1;
  v18 = 0;
  LogToken = SetupGetThreadLogToken();
  HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &v25);
  if ( v25.ClassInstallReserved )
  {
    v5 = *(_DWORD *)v25.ClassInstallReserved;
    v23 = *(struct IUnknown **)(v25.ClassInstallReserved + 4);
    v18 = v5;
  }
  v6 = HrSetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, 1u, 0, 2u, 0x20019u, &hKey);
  v24 = v6;
  if ( v6 )
  {
    if ( v6 == -2146500092 )
      v24 = 0;
  }
  else
  {
    StoreExternalResourceInfoInTempRegLocation(hKey, v21);
    if ( v23 && !v18 )
    {
      v24 = HrRegQueryDword(hKey, L"Characteristics", (DWORD)&Type);
      if ( v24 || (lpMem = (void *)(~(unsigned __int8)(Type >> 5) & 1)) != 0 )
      {
        if ( !memcmp(&GUID_DEVCLASS_NET, &DeviceInfoData->ClassGuid, 0x10u) )
          AddOrRemoveLegacyNt4AdapterKey(v22, v17, 0, 0, 1);
        v4 = v17;
      }
      else
      {
        _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "!!! NCI: Device is not user-removable");
        v24 = -2147024891;
      }
    }
    RegCloseKey(hKey);
  }
  v8 = 0;
  v7 = v24 < 0;
  if ( v24 )
  {
LABEL_33:
    if ( v7 ^ v8 )
      return v24;
    goto LABEL_34;
  }
  if ( lpMem )
  {
    if ( !HrSetupDiOpenDevRegKey(v22, v4, 1u, 0, 1u, 0x20019u, &v15) )
    {
      if ( !HrRegQueryDword(v15, L"InstanceIndex", (DWORD)&v18)
        && !HrSetupDiGetDeviceRegistryPropertyWithAlloc(v22, v4, 0, 0, (DWORD)&lpMem) )
      {
        v9 = (const WCHAR *)lpMem;
        v10 = NetClassEnumFromGuid(&v4->ClassGuid);
        HrCiUpdateDescriptionIndexList(v10, v9, 1, &v18);
        MemFree(lpMem);
      }
      RegCloseKey(v15);
    }
    v24 = HrSetupDiRemoveDevice(v22, v4);
    TestAndSetDelayedCleanup(v22, v4, v21);
    if ( !v24 )
    {
      if ( !v23 )
        goto LABEL_31;
      _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: Notifying binding engine of removal");
      v24 = HrDiNotifyINetCfgOfRemoval(v21);
      if ( FIsValidErrorFromINetCfgForDiHook(v24) )
      {
        memset(&Dst, 0, 0x38u);
        v11 = (int)&v4->ClassGuid;
        v27 = *(_DWORD *)v11;
        v11 += 4;
        v28 = *(_DWORD *)v11;
        v11 += 4;
        v29 = *(_DWORD *)v11;
        v30 = *(_DWORD *)(v11 + 4);
        v31 = v21;
        Dst = 2;
        v32 = &String;
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "! NCI: Binding engine busy [0x%08X]. Adding device to queue",
          v24);
        v12 = HrInsertItemIntoInstallQueue((const struct NIQ_INFO *)&Dst);
        v4 = v17;
        v24 = v12;
      }
      else if ( v24 < 0 )
      {
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "!!! NCI: Binding engine result [0x%08X]",
          v24);
      }
      if ( v24 == 303136 )
      {
        HrSetupDiSetDeipFlags(v22, v4, 256, 0, 1);
        v24 = 0;
      }
    }
    if ( v23 )
    {
LABEL_32:
      v8 = 0;
      v7 = v24 < 0;
      goto LABEL_33;
    }
LABEL_31:
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Releasing external resources.This is programmatic component removal.");
    ReleaseExternallyManagedResources(v21);
    goto LABEL_32;
  }
LABEL_34:
  if ( !memcmp(&GUID_DEVCLASS_NET, &v4->ClassGuid, 0x10u) )
  {
    if ( IsServiceRunning(L"netman") )
    {
      v23 = 0;
      if ( HrCreateInstanceBase(
             &CLSID_ConnectionManager,
             0x404u,
             &_GUID_faedcf5f_31fe_11d1_aad2_00805fc1270e,
             (LPVOID *)&v23) >= 0 )
      {
        ((void (__stdcall *)(struct IUnknown *))v23->lpVtbl[1].QueryInterface)(v23);
        ReleaseObj(v23);
      }
    }
  }
  return v24;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6614D9) --------------------------------------------------------
__int32 __stdcall _HrNetClassInstaller(unsigned int a1, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  const unsigned __int16 *v3; // eax@16
  __int32 v4; // esi@21
  unsigned __int32 v5; // ecx@26
  int v6; // eax@34
  unsigned int v7; // edx@36
  char *v8; // eax@37
  char *v9; // eax@39
  __int16 v10; // cx@40
  DWORD v11; // eax@44
  int Mem; // [sp+Ch] [bp-C34h]@42
  HWND v14; // [sp+10h] [bp-C30h]@33
  unsigned __int16 *v15; // [sp+14h] [bp-C2Ch]@27
  HKEY hKey; // [sp+18h] [bp-C28h]@1
  SP_LOG_TOKEN LogToken; // [sp+1Ch] [bp-C24h]@1
  HKEY phkResult; // [sp+24h] [bp-C1Ch]@19
  HINF InfHandle; // [sp+28h] [bp-C18h]@21
  __int32 v20; // [sp+2Ch] [bp-C14h]@1
  struct _SP_DRVINFO_DATA_V2_W v21; // [sp+30h] [bp-C10h]@20
  struct _SP_CLASSINSTALL_HEADER ClassInstallParams; // [sp+64Ch] [bp-5F4h]@15
  unsigned __int16 v23; // [sp+654h] [bp-5ECh]@16
  struct _SP_DEVINSTALL_PARAMS_W v24; // [sp+828h] [bp-418h]@4
  int v25; // [sp+A54h] [bp-1ECh]@34
  HWND v26; // [sp+A60h] [bp-1E0h]@34
  unsigned __int32 v27; // [sp+A64h] [bp-1DCh]@34
  int v28; // [sp+A68h] [bp-1D8h]@34
  int v29; // [sp+A6Ch] [bp-1D4h]@34
  int v30; // [sp+A70h] [bp-1D0h]@34
  WCHAR *v31; // [sp+A88h] [bp-1B8h]@34
  HKEY v32; // [sp+A8Ch] [bp-1B4h]@34
  PSP_DEVINFO_DATA v33; // [sp+A90h] [bp-1B0h]@34
  int v34; // [sp+A94h] [bp-1ACh]@34
  WCHAR DeviceInstanceId; // [sp+A9Ch] [bp-1A4h]@32
  char Dst; // [sp+A9Eh] [bp-1A2h]@32
  int v37; // [sp+C3Ch] [bp-4h]@51

  hKey = (HKEY)DeviceInfoSet;
  v20 = -2146500082;
  LogToken = SetupGetThreadLogToken();
  if ( a1 != 2 && a1 != 5 )
  {
    switch ( a1 )
    {
      case 0xCu:
        v20 = HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &v24);
        MemFree((void *)v24.ClassInstallReserved);
        break;
      case 0x19u:
        if ( DeviceInfoData
          && FIsHandledByClassInstaller(&DeviceInfoData->ClassGuid)
          && !FIsEnumerated(&DeviceInfoData->ClassGuid) )
          v20 = 0;
        break;
      case 1u:
        HrCiPrepareSelectDeviceDialog(DeviceInfoSet, DeviceInfoData);
        break;
      case 0x1Eu:
        v20 = HrAddIsdnWizardPagesIfAppropriate(DeviceInfoSet, DeviceInfoData);
        break;
      case 0x27u:
        v20 = HrSetupDiGetFixedSizeClassInstallParams(DeviceInfoSet, DeviceInfoData, &ClassInstallParams, 0x408u);
        if ( !v20 )
        {
          v3 = SzLoadIds(0x36C8u);
          StringCchCopyW(&v23, 0x200u, v3);
          v20 = HrSetupDiSetClassInstallParams(DeviceInfoSet, DeviceInfoData, &ClassInstallParams, 0x408u);
          if ( v20 < 0 )
            v20 = -2146500082;
        }
        break;
      default:
        if ( a1 == 24
          && !HrRegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\Network\\NDISTempKey",
                0,
                0xF003Fu,
                0,
                &phkResult,
                0) )
        {
          HIDWORD(LogToken) = 0;
          if ( !HrCiGetDriverDetail(
                  DeviceInfoSet,
                  DeviceInfoData,
                  &v21,
                  (struct _SP_DRVINFO_DETAIL_DATA_W **)&LogToken + 1) )
          {
            InfHandle = 0;
            v4 = HrSetupOpenInfFile((PCWSTR)(HIDWORD(LogToken) + 536), 0, 2u, 0, &InfHandle);
            if ( !v4 )
            {
              v4 = HrSetupDiGetActualSectionToInstallWithBuffer(
                     InfHandle,
                     (PCWSTR)(HIDWORD(LogToken) + 24),
                     (DWORD)v24.DriverPath,
                     0x104u,
                     0,
                     0);
              if ( !v4 )
                v4 = HrCiInstallFromInfSection(InfHandle, v24.DriverPath, phkResult, 0, 4u);
              SetupCloseInfFile(InfHandle);
            }
            MemFree(HIDWORD(LogToken));
            if ( !v4 && !HrRegOpenKeyEx(phkResult, L"Ndi\\Interfaces", 0x20019u, &hKey) )
            {
              v15 = 0;
              if ( !HrRegGetTypeWithAlloc(v5, hKey, L"UpperRange", 1u, (unsigned __int8 **)&v15, 0)
                && FSubstringMatch(v15, L"ndisatm", 0, 0) )
                v20 = -2146500053;
              MemFree(v15);
              RegCloseKey(hKey);
            }
          }
          RegCloseKey(phkResult);
          HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Network\\NDISTempKey");
        }
        break;
    }
    return v20;
  }
  DeviceInstanceId = 0;
  memset(&Dst, 0, 0x18Eu);
  v20 = HrSetupDiGetDeviceInstanceId(DeviceInfoSet, DeviceInfoData, &DeviceInstanceId, 0xC8u, 0);
  if ( v20 )
    return v20;
  v14 = 0;
  HrSetupDiGetParentWindow(DeviceInfoSet, DeviceInfoData, &v14);
  if ( a1 == 2 )
  {
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "[NCI BEGIN INSTALL DEVICE for %ws]",
      &DeviceInstanceId);
    memset(&v25, 0, 0x48u);
    v33 = DeviceInfoData;
    v26 = v14;
    v32 = hKey;
    v6 = NetClassEnumFromGuid(&DeviceInfoData->ClassGuid);
    v34 = -1;
    v25 = v6;
    v27 = GUID_NULL.Data1;
    v28 = *(_DWORD *)&GUID_NULL.Data2;
    v29 = *(_DWORD *)&GUID_NULL.Data4[0];
    v30 = *(_DWORD *)&GUID_NULL.Data4[4];
    v31 = &DeviceInstanceId;
    v20 = HrDiInstallNetAdapter((struct COMPONENT_INSTALL_INFO *)&v25);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "[NCI END INSTALL DEVICE for %ws]",
      &DeviceInstanceId);
    return v20;
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "[NCI BEGIN REMOVE DEVICE for %ws]",
    &DeviceInstanceId);
  StringCchCopyW(&v24.DriverPath[60], 0xC8u, &DeviceInstanceId);
  if ( wcslen(&v24.DriverPath[60]) )
  {
    v7 = 0;
    do
    {
      v8 = (char *)&v24.DriverPath[v7 + 60];
      if ( 92 == *(_WORD *)v8 )
        *(_WORD *)v8 = 38;
      v9 = (char *)&v24.DriverPath[60];
      ++v7;
      phkResult = (HKEY)&v24.DriverPath[61];
      do
      {
        v10 = *(_WORD *)v9;
        v9 += 2;
      }
      while ( v10 );
    }
    while ( v7 < (v9 - (char *)phkResult) >> 1 );
  }
  InfHandle = 0;
  v20 = HrCreateEventWithWorldAccess(&v24.DriverPath[60], 0, 0, &Mem, &InfHandle);
  if ( v20 || !Mem )
  {
    if ( !InfHandle )
      v20 = HrFromLastWin32Error();
    goto LABEL_50;
  }
  v11 = WaitForSingleObject(InfHandle, 0x7530u);
  if ( v11 == 128 )
  {
LABEL_50:
    if ( !v20 )
    {
      v37 = 0;
      v20 = HrDiRemoveNetAdapter(hKey, DeviceInfoData, &DeviceInstanceId, v14);
      if ( InfHandle )
      {
        SetEvent(InfHandle);
        CloseHandle(InfHandle);
      }
    }
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "[NCI END REMOVE DEVICE for %ws. Result 0x%08X]",
      &DeviceInstanceId,
      v20);
    return v20;
  }
  if ( !v11 )
    SetEvent(InfHandle);
  CloseHandle(InfHandle);
  return 0;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E661BA7) --------------------------------------------------------
void *__cdecl std::char_traits<unsigned short>::_Copy_s(void *Dst, int a2, void *Src, int a4)
{
  memcpy_s(Dst, 2 * a2, Src, 2 * a4);
  return Dst;
}

//----- (6E661C16) --------------------------------------------------------
void *__stdcall std::_Allocate<char>(SIZE_T dwBytes, int a2)
{
  if ( (dwBytes & 0x80000000) != 0 )
    dwBytes = 0;
  return operator new(dwBytes);
}

//----- (6E661C3D) --------------------------------------------------------
int __stdcall std::_Traits_helper::copy_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount, int a5)
{
  return std::char_traits<char>::_Copy_s(Dst, DstSize, Src, MaxCount);
}

//----- (6E661C5F) --------------------------------------------------------
int __stdcall std::_Traits_helper::move_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount, int a5)
{
  return std::char_traits<char>::_Move_s(Dst, DstSize, Src, MaxCount);
}

//----- (6E661C81) --------------------------------------------------------
void __thiscall CDiagContext::~CDiagContext(CDiagContext *this)
{
  CDiagContext *v1; // esi@1

  v1 = this;
  MemFree(*((void **)this + 1));
  MemFree(*((void **)v1 + 3));
}

//----- (6E661C9D) --------------------------------------------------------
__int32 __stdcall HrRegQuerySzBuffer(HKEY hKey, LPCWSTR lpValueName, LPBYTE lpData, DWORD Type)
{
  return HrRegQueryTypeSzBuffer(hKey, lpValueName, 1u, lpData, Type);
}

//----- (6E661CBE) --------------------------------------------------------
void __stdcall PromptForLeakCheck(const struct DIAG_OPTIONS *a1, const char *a2)
{
  if ( *((_DWORD *)a1 + 14) )
  {
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, (char *)a2);
    while ( !_kbhit() )
      Sleep(0x32u);
    _getch();
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
  }
}

//----- (6E661D15) --------------------------------------------------------
void __stdcall CmdRemoveReferences(const struct DIAG_OPTIONS *a1, struct CNetConfig *lpMem)
{
  int v2; // eax@1

  v2 = CComponentList::PFindComponentByInfId(lpMem, *((wchar_t **)a1 + 6), 0);
  if ( v2 )
  {
    CComponentReferences::RemoveAllReferences((CComponentReferences *)(v2 + 120));
    HrSaveNetworkConfigurationToRegistry(lpMem);
  }
}

//----- (6E661D47) --------------------------------------------------------
void *__stdcall std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4, int a5)
{
  return std::char_traits<unsigned short>::_Copy_s(Dst, a2, Src, a4);
}

//----- (6E661D69) --------------------------------------------------------
char *__cdecl std::_Copy_opt<CComponent * *,CComponent * *>(void *Src, int a2, void *Dst)
{
  if ( (a2 - (signed int)Src) >> 2 > 0 )
    memmove_s(Dst, 4 * ((a2 - (signed int)Src) >> 2), Src, 4 * ((a2 - (signed int)Src) >> 2));
  return (char *)Dst + 4 * ((a2 - (signed int)Src) >> 2);
}

//----- (6E661D9F) --------------------------------------------------------
signed int __stdcall StringCchCopyNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4)
{
  signed int result; // eax@1

  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( a4 <= 0x7FFFFFFE )
    {
      result = sub_6E641D2F((int)a3, a2, (int)a1, 0, a4);
    }
    else
    {
      result = -2147024809;
      *a1 = 0;
    }
  }
  return result;
}

//----- (6E661DEE) --------------------------------------------------------
int __stdcall std::_Traits_helper::copy_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount)
{
  return std::_Traits_helper::copy_s<std::char_traits<char>>(Dst, DstSize, Src, MaxCount, MaxCount);
}

//----- (6E661E10) --------------------------------------------------------
int __stdcall std::_Traits_helper::move_s<std::char_traits<char>>(void *Dst, rsize_t DstSize, void *Src, rsize_t MaxCount)
{
  return std::_Traits_helper::move_s<std::char_traits<char>>(Dst, DstSize, Src, MaxCount, MaxCount);
}

//----- (6E661E34) --------------------------------------------------------
int __stdcall HrFindBindPath(struct CImplINetCfg *a1, const unsigned __int16 *a2, struct INetCfgBindingPath **a3, struct INetCfgComponentBindings **a4)
{
  unsigned int v4; // eax@3
  int v5; // esi@4
  int v6; // eax@5
  struct INetCfgBindingPath **v7; // ebx@11
  struct IUnknown **v8; // esi@12
  struct IUnknown *v10; // [sp+Ch] [bp-640h]@8
  unsigned __int16 *v11; // [sp+40Ch] [bp-240h]@3
  struct INetCfgBindingPath **v12; // [sp+410h] [bp-23Ch]@1
  const unsigned __int16 *v13; // [sp+414h] [bp-238h]@1
  struct IUnknown *v14; // [sp+418h] [bp-234h]@7
  struct IUnknown *v15; // [sp+41Ch] [bp-230h]@15
  void **v16; // [sp+420h] [bp-22Ch]@1
  LPVOID pv; // [sp+424h] [bp-228h]@12
  struct IUnknown *v18; // [sp+428h] [bp-224h]@1
  struct IUnknown *v19; // [sp+42Ch] [bp-220h]@6
  unsigned __int32 i; // [sp+430h] [bp-21Ch]@10
  unsigned __int32 v21; // [sp+434h] [bp-218h]@8
  unsigned __int16 v22; // [sp+438h] [bp-214h]@3
  unsigned __int16 v23[2]; // [sp+640h] [bp-Ch]@1
  wchar_t v24; // [sp+644h] [bp-8h]@1

  *(_DWORD *)v23 = *(_DWORD *)L"->";
  v24 = asc_6E64D524[2];
  v13 = a2;
  v12 = a3;
  v16 = (void **)a4;
  v18 = 0;
  *a3 = 0;
  if ( a4 )
    *a4 = 0;
  StringCchCopyW(&v22, 0x104u, a2);
  v4 = GetNextStringToken(&v22, v23, &v11);
  if ( v4 )
  {
    v6 = (*(int (__stdcall **)(struct CImplINetCfg *, unsigned int, struct IUnknown **))(*(_DWORD *)a1 + 32))(
           a1,
           v4,
           &v18);
    v5 = v6;
    if ( v6 )
    {
      if ( v6 == 1 )
        v5 = 0;
    }
    else
    {
      v19 = 0;
      v5 = v18->lpVtbl->QueryInterface(v18, &IID_INetCfgComponentBindings, (void **)&v19);
      if ( !v5 )
      {
        v5 = ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **))v19->lpVtbl[2].Release)(
               v19,
               2,
               &v14);
        if ( !v5 )
        {
          v5 = ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **, unsigned __int32 *))v14->lpVtbl[1].QueryInterface)(
                 v14,
                 256,
                 &v10,
                 &v21);
          if ( v5 >= 0 && v21 )
          {
            for ( i = 0; i < v21; ++i )
            {
              v7 = v12;
              if ( *v12 )
                break;
              v8 = &(&v10)[i];
              if ( !((int (__stdcall *)(struct IUnknown *, LPVOID *))(*v8)->lpVtbl[2].AddRef)(*v8, &pv) )
              {
                if ( !wcscmp(v13, (const unsigned __int16 *)pv) )
                {
                  AddRefObj(*v8);
                  *v7 = (struct INetCfgBindingPath *)*v8;
                  if ( v16 )
                  {
                    if ( !((int (__stdcall *)(struct IUnknown *, struct IUnknown **))v10->lpVtbl[2].Release)(v10, &v15) )
                    {
                      v15->lpVtbl->QueryInterface(v15, &IID_INetCfgComponentBindings, v16);
                      ReleaseObj(v15);
                    }
                  }
                }
                CoTaskMemFree(pv);
              }
            }
            ReleaseIUnknownArray(v21, &v10);
            v5 = 0;
          }
          ReleaseObj(v14);
        }
        ReleaseObj(v19);
      }
      ReleaseObj(v18);
    }
  }
  else
  {
    v5 = -2147024809;
  }
  return v5;
}

//----- (6E66208D) --------------------------------------------------------
void __stdcall CmdCleanup(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  unsigned int v2; // eax@1
  const WCHAR *v3; // edi@3
  int v4; // esi@3
  DWORD v5; // edi@7
  HRESULT v6; // esi@8
  DWORD v7; // esi@22
  __int32 v8; // edi@23
  struct _FILETIME ftLastWriteTime; // [sp+Ch] [bp-8D0h]@8
  int v10; // [sp+14h] [bp-8C8h]@26
  int v11; // [sp+18h] [bp-8C4h]@26
  DWORD cchName; // [sp+1Ch] [bp-8C0h]@8
  HINF InfHandle; // [sp+20h] [bp-8BCh]@15
  CComponentList *v14; // [sp+24h] [bp-8B8h]@1
  DWORD Type; // [sp+28h] [bp-8B4h]@13
  HKEY hKey; // [sp+2Ch] [bp-8B0h]@12
  HKEY phkResult; // [sp+30h] [bp-8ACh]@6
  unsigned int i; // [sp+34h] [bp-8A8h]@1
  HDEVINFO DeviceInfoSet; // [sp+38h] [bp-8A4h]@21
  IID iid; // [sp+3Ch] [bp-8A0h]@10
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+4Ch] [bp-890h]@23
  WCHAR DeviceInstanceId; // [sp+68h] [bp-874h]@24
  WCHAR FileName; // [sp+478h] [bp-464h]@13
  wchar_t pszDest; // [sp+680h] [bp-25Ch]@13
  OLECHAR sz; // [sp+888h] [bp-54h]@8

  v14 = a2;
  v2 = 0;
  for ( i = 0; ; v2 = i )
  {
    v3 = *(const WCHAR **)((char *)&dword_6E662440 + v2);
    v4 = *(int *)((char *)&dword_6E66243C + v2);
    if ( !v3 )
      v3 = (&MAP_NETCLASS_TO_NETWORK_SUBTREE)[2 * v4];
    if ( FIsConsideredNetClass(*(int *)((char *)&dword_6E66243C + v2)) )
    {
      if ( !HrSetupDiGetClassDevs(*((GUID **)&MAP_NETCLASS_TO_GUID.Data1 + v4), 0, 0, 8u, &DeviceInfoSet) )
      {
        v7 = 0;
        do
        {
          v8 = HrSetupDiEnumDeviceInfo(DeviceInfoSet, v7, &DeviceInfoData);
          if ( !v8
            && SetupDiGetDeviceInstanceIdW(DeviceInfoSet, &DeviceInfoData, &DeviceInstanceId, 0x208u, 0)
            && !CComponentList::PFindComponentByPnpId(v14, &DeviceInstanceId) )
          {
            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Removing %S...\n", &DeviceInstanceId);
            v10 = 0;
            v11 = 0;
            CiSetReservedField(DeviceInfoSet, &DeviceInfoData, &v10);
            v8 = HrSetupDiCallClassInstaller(5u, DeviceInfoSet, &DeviceInfoData);
            CiClearReservedField(DeviceInfoSet, &DeviceInfoData);
          }
          ++v7;
        }
        while ( !v8 );
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      }
    }
    else if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, v3, 0x20019u, &phkResult) )
    {
      v5 = 0;
      do
      {
        cchName = 39;
        v6 = HrRegEnumKeyEx(phkResult, v5, &sz, &cchName, 0, 0, &ftLastWriteTime);
        if ( !v6 && cchName == 38 )
        {
          v6 = IIDFromString(&sz, &iid);
          if ( !v6 && !CComponentList::PFindComponentByInstanceGuid(v14, &iid) )
          {
            v6 = HrRegOpenKeyEx(phkResult, &sz, 0x20019u, &hKey);
            if ( !v6 )
            {
              FileName = 0;
              pszDest = 0;
              Type = 520;
              HrRegQueryTypeSzBuffer(hKey, L"InfPath", 1u, (LPBYTE)&FileName, (DWORD)&Type);
              Type = 504;
              HrRegQueryTypeSzBuffer(hKey, L"InfSection", 1u, (LPBYTE)&pszDest, (DWORD)&Type);
              if ( FileName && pszDest )
              {
                v6 = HrSetupOpenInfFile(&FileName, 0, 2u, 0, &InfHandle);
                if ( !v6 )
                {
                  StringCchCatW(&pszDest, 0x104u, L".Remove");
                  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Running %S...\n", &pszDest);
                  v6 = HrCiDoCompleteSectionInstall(InfHandle, hKey, &pszDest, 0, 0);
                  SetupCloseInfFile(InfHandle);
                }
              }
              RegCloseKey(hKey);
            }
            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Deleting tree %S...\n", &sz);
            HrRegDeleteKeyTree(phkResult, &sz);
            --v5;
          }
        }
        ++v5;
      }
      while ( !v6 );
      RegCloseKey(phkResult);
    }
    i += 8;
    if ( i >= 0x30 )
      break;
  }
}
// 6E66243C: using guessed type int dword_6E66243C;
// 6E662440: using guessed type int dword_6E662440;

//----- (6E662471) --------------------------------------------------------
void *__stdcall std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4)
{
  return std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(Dst, a2, Src, a4, a4);
}

//----- (6E662493) --------------------------------------------------------
char *__cdecl std::copy<CComponent * *,CComponent * *>(void *Src, int a2, void *Dst)
{
  return std::_Copy_opt<CComponent * *,CComponent * *>(Src, a2, Dst);
}

//----- (6E6624BF) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Tidy(int this, char a2, rsize_t MaxCount)
{
  int v3; // esi@1
  void *v4; // edi@3

  v3 = this;
  if ( a2 && *(_DWORD *)(this + 24) >= 0x10u )
  {
    v4 = *(void **)(this + 4);
    if ( MaxCount )
      std::_Traits_helper::copy_s<std::char_traits<char>>((void *)(this + 4), 0x10u, v4, MaxCount);
    operator delete(v4);
  }
  *(_DWORD *)(v3 + 24) = 15;
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(MaxCount);
}
// 6E674F8F: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD);

//----- (6E66250E) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::erase(int this, unsigned int a2, int a3)
{
  int v3; // esi@1
  unsigned int v4; // eax@3
  unsigned int v5; // ecx@6
  int v6; // edx@6
  int v7; // ebx@7

  v3 = this;
  if ( *(_DWORD *)(this + 20) < a2 )
    std::_String_base::_Xran();
  v4 = *(_DWORD *)(this + 20) - a2;
  if ( v4 < a3 )
    a3 = *(_DWORD *)(this + 20) - a2;
  if ( a3 )
  {
    v5 = *(_DWORD *)(this + 24);
    v6 = v3 + 4;
    if ( v5 < 0x10 )
      v7 = v3 + 4;
    else
      v7 = *(_DWORD *)v6;
    if ( v5 >= 0x10 )
      v6 = *(_DWORD *)v6;
    std::_Traits_helper::move_s<std::char_traits<char>>((void *)(a2 + v6), v5 - a2, (void *)(a3 + a2 + v7), v4 - a3);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(*(_DWORD *)(v3 + 20) - a3);
  }
  return v3;
}
// 6E674F8F: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD);

//----- (6E662581) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Copy(int this, int a2, rsize_t MaxCount)
{
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // ecx@3
  void *v6; // ebx@6
  void *v7; // eax@8
  unsigned int v9; // [sp+10h] [bp-14h]@3

  v3 = this;
  v4 = a2 | 0xF;
  if ( (a2 | 0xFu) <= 0xFFFFFFFE )
  {
    v5 = *(_DWORD *)(this + 24);
    v9 = *(_DWORD *)(v3 + 24) >> 1;
    if ( v4 / 3u < v9 && v5 <= -2 - v9 )
      v4 = v5 + v9;
  }
  else
  {
    v4 = a2;
  }
  v6 = std::_Allocate<char>(v4 + 1, 0);
  if ( MaxCount )
  {
    if ( *(_DWORD *)(v3 + 24) < 0x10u )
      v7 = (void *)(v3 + 4);
    else
      v7 = *(void **)(v3 + 4);
    std::_Traits_helper::copy_s<std::char_traits<char>>(v6, v4 + 1, v7, MaxCount);
  }
  std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Tidy(v3, 1, 0);
  *(_DWORD *)(v3 + 4) = v6;
  *(_DWORD *)(v3 + 24) = v4;
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(MaxCount);
}
// 6E674F8F: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD);

//----- (6E662647) --------------------------------------------------------
void __usercall __noreturn sub_6E662647(int a1@<ebp>)
{
  std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Tidy(*(_DWORD *)(a1 - 24), 1, 0);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E662661) --------------------------------------------------------
void __stdcall CmdShowLanAdapterPnpIds(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  int i; // esi@2
  int v3; // edi@3
  const unsigned __int16 *v4; // eax@4

  if ( !CNetConfig::HrEnsureExternalDataLoadedForAllComponents(a2) )
  {
    for ( i = *((_DWORD *)a2 + 2); i != *((_DWORD *)a2 + 3); i += 4 )
    {
      v3 = *(_DWORD *)i;
      if ( *(_DWORD *)i )
      {
        v4 = *(const unsigned __int16 **)(v3 + 84);
        if ( !v4 )
          v4 = &String;
        if ( FSubstringMatch(v4, L"ndis5", 0, 0) )
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S\n", *(_DWORD *)(v3 + 32));
      }
    }
  }
}

//----- (6E6626DD) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::~basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(int this)
{
  return std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Tidy(this, 1, 0);
}

//----- (6E662753) --------------------------------------------------------
void __stdcall CmdShowStackTable(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  int i; // esi@1
  int v3; // eax@2
  int v4; // edx@3
  int v5; // eax@6
  int v6; // eax@10

  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n%15s | %s\n---------------------------------\n", "Upper", "Lower");
  for ( i = *((_DWORD *)a2 + 7); i != *((_DWORD *)a2 + 8); i += 8 )
  {
    v3 = *(_DWORD *)(i + 4);
    if ( *(_DWORD *)(v3 + 32) )
      v4 = *(_DWORD *)(v3 + 32);
    else
      v4 = *(_DWORD *)(v3 + 28);
    if ( *(_DWORD *)(*(_DWORD *)i + 32) )
      v5 = *(_DWORD *)(*(_DWORD *)i + 32);
    else
      v5 = *(_DWORD *)(*(_DWORD *)i + 28);
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%15S | %S\n", v5, v4);
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
  v6 = (int)"first";
  if ( !*((_DWORD *)a2 + 10) )
    v6 = (int)"last";
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "WAN adapters are ordered %s\n\n", v6);
}

//----- (6E662883) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::~basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
           this,
           1,
           0);
}

//----- (6E6628B6) --------------------------------------------------------
const char *__thiscall std::logic_error::what(std::logic_error *this)
{
  const char *result; // eax@2

  if ( *((_DWORD *)this + 9) < 0x10u )
    result = (char *)this + 16;
  else
    result = (const char *)*((_DWORD *)this + 4);
  return result;
}

//----- (6E6628C9) --------------------------------------------------------
void *__thiscall std::logic_error::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::logic_error::~logic_error((std::logic_error *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E6628EF) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(int this, int a2, int a3, rsize_t a4)
{
  int v4; // ebx@1
  int v5; // esi@3
  int v6; // edi@9
  rsize_t v7; // ecx@11
  void *v8; // eax@12

  v4 = this;
  if ( *(_DWORD *)(a2 + 20) < (unsigned int)a3 )
    std::_String_base::_Xran();
  v5 = *(_DWORD *)(a2 + 20) - a3;
  if ( a4 < v5 )
    v5 = a4;
  if ( this == a2 )
  {
    std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::erase(this, a3 + v5, -1);
    std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::erase(v4, 0, a3);
  }
  else if ( (unsigned __int8)std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Grow(v5, 0) )
  {
    if ( *(_DWORD *)(a2 + 24) < 0x10u )
      v6 = a2 + 4;
    else
      v6 = *(_DWORD *)(a2 + 4);
    v7 = *(_DWORD *)(v4 + 24);
    if ( v7 < 0x10 )
      v8 = (void *)(v4 + 4);
    else
      v8 = *(void **)(v4 + 4);
    std::_Traits_helper::copy_s<std::char_traits<char>>(v8, v7, (void *)(a3 + v6), v5);
    std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(v5);
  }
  return v4;
}
// 6E6626EC: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Grow(_DWORD, char);
// 6E674F8F: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD);

//----- (6E662985) --------------------------------------------------------
void __thiscall CComponentList::~CComponentList(CComponentList *this)
{
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)this + 4));
}

//----- (6E662992) --------------------------------------------------------
signed int __stdcall HrCreateINetCfg(int a1, struct CImplINetCfg **a2)
{
  signed int v2; // esi@1
  int v3; // eax@3
  struct IUnknown *v5; // [sp+4h] [bp-4h]@1

  v2 = ATL::CComCreator<ATL::CComObject<CImplINetCfg>>::CreateInstance(0, (int)&IID_INetCfg, (int)&v5);
  if ( !v2 )
  {
    if ( a1 )
    {
      v3 = ((int (__stdcall *)(struct IUnknown *, signed int, _DWORD, _DWORD))v5[1].lpVtbl[1].QueryInterface)(
             &v5[1],
             100,
             L"ncdiag",
             0);
      v2 = v3;
      if ( v3 == 1 )
      {
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "The write lock could not be acquired.\n");
LABEL_5:
        ReleaseObj(v5);
        return v2;
      }
      if ( v3 == -2147180507 )
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "A reboot is required before any futher changes can be made.\n");
      if ( v2 )
        goto LABEL_5;
    }
    v2 = ((int (__stdcall *)(struct IUnknown *, _DWORD))v5->lpVtbl[1].QueryInterface)(v5, 0);
    if ( !v2 )
    {
      *a2 = (struct CImplINetCfg *)v5;
      return v2;
    }
    goto LABEL_5;
  }
  return v2;
}
// 6E65C078: using guessed type wchar_t aNcdiag[7];

//----- (6E662A9C) --------------------------------------------------------
void __userpurge CNetCfgInternalDiagnostic::DoEnumAllDiagnostic(int a1@<edi>, const struct DIAG_OPTIONS *a2)
{
  int v2; // ST0C_4@2
  struct IUnknown *v3; // edi@2
  signed int v4; // esi@2
  int v5; // eax@3
  struct IUnknown **v6; // edi@6
  unsigned __int32 j; // edi@11
  struct IUnknown **v8; // esi@12
  struct IUnknown *v9; // [sp+4h] [bp-82Ch]@10
  struct IUnknown *v10; // [sp+404h] [bp-42Ch]@14
  struct IUnknown *v11; // [sp+604h] [bp-22Ch]@3
  char v12; // [sp+804h] [bp-2Ch]@12
  unsigned __int32 v13; // [sp+808h] [bp-28h]@14
  struct IUnknown *v14; // [sp+80Ch] [bp-24h]@9
  struct IUnknown *v15; // [sp+810h] [bp-20h]@8
  struct IUnknown *v16; // [sp+814h] [bp-1Ch]@1
  struct IUnknown *v17; // [sp+818h] [bp-18h]@13
  struct IUnknown *v18; // [sp+81Ch] [bp-14h]@2
  LPVOID pv; // [sp+820h] [bp-10h]@6
  unsigned __int32 v20; // [sp+824h] [bp-Ch]@10
  unsigned __int32 i; // [sp+828h] [bp-8h]@5
  unsigned __int32 v22; // [sp+82Ch] [bp-4h]@3

  PromptForLeakCheck(a2, "Enumerate All diagnostic...(dump heap)");
  if ( HrCreateINetCfg(0, (struct CImplINetCfg **)&v16) )
    goto LABEL_32;
  v2 = a1;
  v3 = v16;
  v4 = ((int (__stdcall *)(struct IUnknown *, _DWORD, struct IUnknown **, int))v16->lpVtbl[2].AddRef)(v16, 0, &v18, v2);
  if ( !v4 )
  {
    v5 = ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **, unsigned __int32 *))v18->lpVtbl[1].QueryInterface)(
           v18,
           128,
           &v11,
           &v22);
    v4 = v5;
    if ( v5 >= 0 && v22 )
    {
      for ( i = 0; i < v22; ++i )
      {
        v6 = &(&v11)[i];
        v4 = ((int (__stdcall *)(struct IUnknown *, LPVOID *))(*v6)->lpVtbl[2].QueryInterface)(*v6, &pv);
        if ( v4 )
          break;
        v4 = *(_WORD *)pv != 0 ? 0 : 0x80004005;
        if ( v4 )
          break;
        v4 = (*v6)->lpVtbl->QueryInterface(*v6, &IID_INetCfgComponentBindings, (void **)&v15);
        if ( !v4 )
        {
          v4 = ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **))v15->lpVtbl[2].Release)(
                 v15,
                 2,
                 &v14);
          if ( !v4 )
          {
            v4 = ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **, unsigned __int32 *))v14->lpVtbl[1].QueryInterface)(
                   v14,
                   256,
                   &v9,
                   &v20);
            if ( v4 >= 0 )
            {
              for ( j = 0; j < v20; ++j )
              {
                v8 = &(&v9)[j];
                if ( !((int (__stdcall *)(struct IUnknown *, char *))(*v8)->lpVtbl[3].QueryInterface)(*v8, &v12)
                  && !((int (__stdcall *)(struct IUnknown *, struct IUnknown **))(*v8)->lpVtbl[3].AddRef)(*v8, &v17) )
                {
                  if ( ((int (__stdcall *)(struct IUnknown *, signed int, struct IUnknown **, unsigned __int32 *))v17->lpVtbl[1].QueryInterface)(
                         v17,
                         128,
                         &v10,
                         &v13) >= 0 )
                    ReleaseIUnknownArray(v13, &v10);
                  ReleaseObj(v17);
                }
              }
              ReleaseIUnknownArray(v20, &v9);
              v4 = 0;
            }
            ReleaseObj(v14);
          }
          ReleaseObj(v15);
        }
        CoTaskMemFree(pv);
        if ( v4 )
          break;
      }
      ReleaseIUnknownArray(v22, &v11);
      v3 = v16;
    }
    else if ( v5 == 1 )
    {
      v4 = 0;
    }
    ReleaseObj(v18);
  }
  ((void (*)(void))v3->lpVtbl[1].AddRef)();
  ReleaseObj(v3);
  if ( v4 )
LABEL_32:
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Enumerate All diagnostic.\n");
  PromptForLeakCheck(a2, "Enumerate All diagnostic...(dump heap and compare)");
}
// 6E662A9C: could not find valid save-restore pair for edi

//----- (6E662D28) --------------------------------------------------------
void __userpurge CNetCfgInternalDiagnostic::DoWriteLockDiagnostic(int a1@<edi>, int a2@<esi>, const struct DIAG_OPTIONS *a3, struct CNetConfig *a4)
{
  signed int v4; // ebx@1
  int v5; // eax@6
  struct IUnknown *v6; // [sp+4h] [bp-8h]@1
  LPVOID pv; // [sp+8h] [bp-4h]@2

  v4 = 0;
  PromptForLeakCheck(a3, "WriteLock diagnostic...(dump heap)");
  if ( ATL::CComCreator<ATL::CComObject<CImplINetCfg>>::CreateInstance(0, (int)&IID_INetCfg, (int)&v6) )
    goto LABEL_29;
  if ( ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v6[1].lpVtbl[1].Release)(&v6[1], &pv, a1, a2) != 1 )
    v4 = 1;
  if ( pv )
    v4 = 1;
  v5 = ((int (__stdcall *)(_DWORD, _DWORD))v6[1].lpVtbl[1].QueryInterface)(&v6[1], 100);
  if ( v5 )
    v4 = 1;
  if ( pv )
    v4 = 1;
  if ( !v5 )
  {
    if ( ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v6[1].lpVtbl[1].Release)(&v6[1], &pv, L"ncdiag", &pv) )
      v4 = 1;
    if ( !pv )
      v4 = 1;
    if ( !v4 && wcscmp(L"ncdiag", (const unsigned __int16 *)pv) )
      v4 = 1;
    CoTaskMemFree(pv);
    if ( v6[1].lpVtbl[1].AddRef(&v6[1]) )
      v4 = 1;
    if ( ((int (__cdecl *)(_DWORD, _DWORD))v6[1].lpVtbl[1].Release)(&v6[1], &pv) != 1 )
      v4 = 1;
    if ( pv )
      v4 = 1;
  }
  ReleaseObj(v6);
  if ( v4 )
  {
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED WriteLock diagnostic.\n");
  }
  else
  {
LABEL_29:
    PromptForLeakCheck(a3, "WriteLock diagnostic...(dump heap and compare)");
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Passed WriteLock diagnostic.\n");
  }
}
// 6E65C078: using guessed type wchar_t aNcdiag[7];

//----- (6E662F0C) --------------------------------------------------------
void __userpurge CmdAddComponent(int a1@<edi>, struct IUnknown *a2, struct CNetConfig *a3)
{
  struct IUnknown *v3; // esi@1
  int v4; // edi@2
  struct IUnknownVtbl *v5; // ST04_4@3
  char *v6; // [sp-8h] [bp-2Ch]@6
  struct IUnknownVtbl *v7; // [sp-4h] [bp-28h]@6
  int v8; // [sp+4h] [bp-20h]@3
  struct IUnknown *v9; // [sp+1Ch] [bp-8h]@3
  struct IUnknown *v10; // [sp+20h] [bp-4h]@2

  v3 = a2;
  PromptForLeakCheck((const struct DIAG_OPTIONS *)a2, "Add component...(dump heap)");
  if ( HrCreateINetCfg(1, (struct CImplINetCfg **)&a2) )
    goto LABEL_12;
  v4 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *, GUID *, struct IUnknown **, int))a2->lpVtbl[3].QueryInterface)(
         a2,
         &v3[2],
         &IID_INetCfgClassSetup,
         &v10,
         a1);
  if ( v4 )
    goto LABEL_11;
  v5 = v3[6].lpVtbl;
  memset(&v8, 0, 0x18u);
  v8 = 1;
  v4 = ((int (__stdcall *)(struct IUnknown *, struct IUnknownVtbl *, int *, _DWORD, _DWORD, _DWORD, _DWORD, struct IUnknown **))v10->lpVtbl[1].AddRef)(
         v10,
         v5,
         &v8,
         0,
         0,
         0,
         0,
         &v9);
  if ( v4 >= 0 )
    ReleaseObj(v9);
  if ( v4 == 303136 )
  {
    v7 = v3[6].lpVtbl;
    v6 = "%S was installed, but a reboot is required.\n";
LABEL_9:
    v4 = 0;
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, v6, v7);
    goto LABEL_10;
  }
  if ( v4 == -2147024894 )
  {
    v7 = v3[6].lpVtbl;
    v6 = "The INF file for %S could not be found.\n";
    goto LABEL_9;
  }
LABEL_10:
  ReleaseObj(v10);
LABEL_11:
  ((void (__cdecl *)(struct IUnknown *))a2->lpVtbl[1].AddRef)(a2);
  ReleaseObj(a2);
  if ( v4 )
LABEL_12:
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Add component.\n");
  PromptForLeakCheck((const struct DIAG_OPTIONS *)v3, "Add component...(dump heap and compare)");
}

//----- (6E663091) --------------------------------------------------------
void __stdcall CmdAddRemoveStress(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  signed int v2; // esi@1
  int i; // eax@4
  unsigned int v4; // eax@6
  int v5; // esi@8
  wchar_t *v6; // ebx@8
  struct IUnknown *v7; // edi@15
  int v8; // eax@15
  int v9; // eax@17
  struct IUnknown *v10; // edi@38
  int v11; // [sp+Ch] [bp-64h]@18
  int v12; // [sp+24h] [bp-4Ch]@10
  int v13; // [sp+3Ch] [bp-34h]@1
  int v14; // [sp+40h] [bp-30h]@6
  int v15; // [sp+44h] [bp-2Ch]@2
  int v16; // [sp+48h] [bp-28h]@1
  struct IUnknown *v17; // [sp+4Ch] [bp-24h]@1
  struct IUnknown *v18; // [sp+50h] [bp-20h]@10
  struct IUnknown *v19; // [sp+54h] [bp-1Ch]@9
  unsigned int v20; // [sp+58h] [bp-18h]@2
  char v21; // [sp+5Ch] [bp-14h]@16

  GetProductFlavor(0, (enum PRODUCT_FLAVOR *)&v13);
  v16 = 0;
  CDiagContext::SetFlags(g_pDiagCtx, 0x17u);
  v2 = HrCreateINetCfg(1, (struct CImplINetCfg **)&v17);
  if ( v2 )
    goto LABEL_44;
  v20 = 0;
  v15 = 1;
  if ( _kbhit() )
  {
LABEL_37:
    _getch();
  }
  else
  {
    while ( !v2 )
    {
      for ( i = v20; ; i = v14 + v20 + 1 )
      {
        v14 = i;
        if ( (unsigned int)i >= 6 || v2 )
          break;
        v4 = 6 * v14;
        if ( !dword_6E6634A0[3 * v14] || v13 != 1 )
        {
          v5 = dword_6E663498[v4 / 2];
          v6 = (&off_6E66349C)[v4];
          if ( v15 )
          {
            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "--------------------\nInstalling %S\n", (&off_6E66349C)[v4]);
            v2 = ((int (__stdcall *)(struct IUnknown *, _DWORD, GUID *, struct IUnknown **))v17->lpVtbl[3].QueryInterface)(
                   v17,
                   *(&MAP_NETCLASS_TO_GUID.Data1 + v5),
                   &IID_INetCfgClassSetup,
                   &v19);
            if ( !v2 )
            {
              memset(&v12, 0, 0x18u);
              v12 = 1;
              v2 = ((int (__stdcall *)(struct IUnknown *, wchar_t *, int *, _DWORD, _DWORD, _DWORD, _DWORD, struct IUnknown **))v19->lpVtbl[1].AddRef)(
                     v19,
                     v6,
                     &v12,
                     0,
                     0,
                     0,
                     0,
                     &v18);
              if ( v2 >= 0 )
                ReleaseObj(v18);
              if ( v2 == 303136 )
              {
                v2 = 0;
                CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S was installed, but a reboot is required.\n", v6);
              }
              ReleaseObj(v19);
            }
          }
          else
          {
            v7 = v17;
            v8 = ((int (__stdcall *)(struct IUnknown *, wchar_t *, struct IUnknown **))v17->lpVtbl[2].Release)(
                   v17,
                   v6,
                   &v18);
            v2 = v8;
            if ( v8 )
            {
              if ( v8 == 1 )
                v2 = 0;
            }
            else
            {
              CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "--------------------\nRemoving %S\n", v6);
              v2 = ((int (__stdcall *)(struct IUnknown *, char *))v18->lpVtbl[3].AddRef)(v18, &v21);
              if ( !v2 )
              {
                v9 = ((int (__stdcall *)(struct IUnknown *, char *, GUID *, struct IUnknown **))v7->lpVtbl[3].QueryInterface)(
                       v7,
                       &v21,
                       &IID_INetCfgClassSetup,
                       &v19);
                v2 = v9;
                if ( !v9 )
                {
                  memset(&v11, 0, 0x18u);
                  v11 = 1;
                  v2 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *, int *, _DWORD))v19->lpVtbl[1].Release)(
                         v19,
                         v18,
                         &v11,
                         0);
                  if ( v2 == 303136 )
                  {
                    v2 = 0;
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S was removed, but a reboot is required.\n", v6);
                  }
                  if ( v2 == 303139 )
                  {
                    v2 = 0;
                    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S is still referenced\n", v6);
                  }
                  if ( v2 == -2147024809 )
                  {
                    v2 = 0;
                    CDiagContext::Printf(
                      (DWORD)g_pDiagCtx,
                      3,
                      "%S is installed, but not on behalf of the user, so we can't remove it.  (Proceeding.)\n",
                      v6);
                  }
                  ReleaseObj(v19);
                }
              }
              ReleaseObj(v18);
            }
          }
        }
      }
      ++v20;
      if ( v20 >= 6 )
        v20 = 0;
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
      if ( !v16 )
      {
        PromptForLeakCheck(a1, "Add/Remove stress...(dump heap)");
        v16 = 1;
      }
      v15 = v15 == 0;
      if ( _kbhit() )
      {
        if ( v2 )
          break;
        goto LABEL_37;
      }
    }
  }
  v10 = v17;
  v17->lpVtbl[1].AddRef(v17);
  ReleaseObj(v10);
  if ( v2 )
LABEL_44:
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Add/Remove stress component.\n");
  if ( v16 )
    PromptForLeakCheck(a1, "Add/Remove stress...(dump heap and compare)");
}
// 6E663498: using guessed type int dword_6E663498[];
// 6E66349C: using guessed type wchar_t *off_6E66349C;
// 6E6634A0: using guessed type int dword_6E6634A0[];

//----- (6E6634E5) --------------------------------------------------------
void __userpurge CmdRemoveComponent(int a1@<edi>, const struct DIAG_OPTIONS *a2, struct CNetConfig *a3)
{
  signed int v3; // eax@1
  int v4; // esi@1
  int v5; // ST0C_4@2
  struct IUnknown *v6; // edi@2
  int v7; // eax@2
  int v8; // [sp+8h] [bp-3Ch]@5
  struct IUnknown *v9; // [sp+20h] [bp-24h]@1
  struct IUnknown *v10; // [sp+24h] [bp-20h]@4
  LPVOID pv; // [sp+28h] [bp-1Ch]@5
  struct IUnknown *v12; // [sp+2Ch] [bp-18h]@2
  char v13; // [sp+30h] [bp-14h]@3

  PromptForLeakCheck(a2, "Remove component...(dump heap)");
  v3 = HrCreateINetCfg(1, (struct CImplINetCfg **)&v9);
  v4 = v3;
  if ( v3 )
  {
    if ( v3 == -2147180507 )
      v4 = 0;
  }
  else
  {
    v5 = a1;
    v6 = v9;
    v7 = ((int (__stdcall *)(struct IUnknown *, _DWORD, struct IUnknown **, int))v9->lpVtbl[2].Release)(
           v9,
           *((_DWORD *)a2 + 6),
           &v12,
           v5);
    v4 = v7;
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S was not found.\n", *((_DWORD *)a2 + 6));
        v4 = 0;
      }
    }
    else
    {
      v4 = ((int (__stdcall *)(struct IUnknown *, char *))v12->lpVtbl[3].AddRef)(v12, &v13);
      if ( !v4 )
      {
        v4 = ((int (__stdcall *)(struct IUnknown *, char *, GUID *, struct IUnknown **))v6->lpVtbl[3].QueryInterface)(
               v6,
               &v13,
               &IID_INetCfgClassSetup,
               &v10);
        if ( !v4 )
        {
          pv = 0;
          memset(&v8, 0, 0x18u);
          v8 = 1;
          v4 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *, int *, LPVOID *))v10->lpVtbl[1].Release)(
                 v10,
                 v12,
                 &v8,
                 &pv);
          if ( pv )
            CoTaskMemFree(pv);
          if ( v4 == 303136 )
          {
            v4 = 0;
            CDiagContext::Printf(
              (DWORD)g_pDiagCtx,
              3,
              "%S was removed, but a reboot is required.\n",
              *((_DWORD *)a2 + 6));
          }
          if ( v4 == 303139 )
          {
            v4 = 0;
            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S is still referenced\n", *((_DWORD *)a2 + 6));
          }
          if ( v4 == -2147024809 )
          {
            v4 = 0;
            CDiagContext::Printf(
              (DWORD)g_pDiagCtx,
              3,
              "%S is installed, but not on behalf of the user, so it was not removed.\n",
              *((_DWORD *)a2 + 6));
          }
          ReleaseObj(v10);
          v6 = v9;
        }
      }
      ReleaseObj(v12);
    }
    ((void (*)(void))v6->lpVtbl[1].AddRef)();
    ReleaseObj(v6);
  }
  if ( v4 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Remove component.\n");
  PromptForLeakCheck(a2, "Remove component...(dump heap and compare)");
}
// 6E6634E5: could not find valid save-restore pair for edi

//----- (6E663744) --------------------------------------------------------
void __userpurge CmdUpdateComponent(int a1@<edi>, struct IUnknown *a2, struct CNetConfig *a3)
{
  struct IUnknown *v3; // ebx@1
  signed int v4; // eax@1
  int v5; // esi@1
  int v6; // ST0C_4@2
  struct IUnknown *v7; // edi@2
  int v8; // eax@2
  struct IUnknown *v9; // [sp+8h] [bp-4h]@2

  v3 = a2;
  PromptForLeakCheck((const struct DIAG_OPTIONS *)a2, "Update component...(dump heap)");
  v4 = HrCreateINetCfg(1, (struct CImplINetCfg **)&a2);
  v5 = v4;
  if ( v4 )
  {
    if ( v4 == -2147180507 )
      v5 = 0;
  }
  else
  {
    v6 = a1;
    v7 = a2;
    v8 = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a2->lpVtbl[2].Release)(a2, v3[6].lpVtbl, &v9, v6);
    v5 = v8;
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S was not found.\n", v3[6].lpVtbl);
        v5 = 0;
      }
    }
    else
    {
      v5 = v7->lpVtbl->QueryInterface(v7, &IID_INetCfgInternalSetup, (void **)&a2);
      if ( !v5 )
      {
        v5 = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))a2->lpVtbl[2].Release)(a2, v9, 2, 0);
        if ( !v5 )
        {
          v5 = v7->lpVtbl[1].Release(v7);
          if ( v5 == 303136 )
          {
            v5 = 0;
            CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S was removed, but a reboot is required.\n", v3[6].lpVtbl);
          }
        }
        ReleaseObj(a2);
      }
      ReleaseObj(v9);
    }
    ((void (*)(void))v7->lpVtbl[1].AddRef)();
    ReleaseObj(v7);
  }
  if ( v5 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Update component.\n");
  PromptForLeakCheck((const struct DIAG_OPTIONS *)v3, "Update component...(dump heap and compare)");
}
// 6E663744: could not find valid save-restore pair for edi

//----- (6E6638BC) --------------------------------------------------------
void __stdcall CmdShowComponents(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  struct CNetConfig *v2; // ebx@1
  int v3; // ecx@2
  int v4; // esi@3
  int v5; // eax@4
  int v6; // eax@5
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ST38_4@15
  int v10; // edi@25
  const WCHAR *v11; // edx@27
  int *v12; // ecx@29
  int v13; // esi@31
  unsigned int v14; // ebx@32
  struct CComponent *v15; // eax@33
  const wchar_t *v16; // eax@35
  int v17; // ebx@41
  int v18; // esi@42
  int v19; // eax@43
  const wchar_t *v20; // eax@45
  int v21; // [sp+10h] [bp-24Ch]@17
  int v22; // [sp+14h] [bp-248h]@19
  char v23[4]; // [sp+18h] [bp-244h]@23
  char v24[4]; // [sp+1Ch] [bp-240h]@15
  int v25; // [sp+20h] [bp-23Ch]@2
  int v26; // [sp+24h] [bp-238h]@21
  CComponentReferences *v27; // [sp+28h] [bp-234h]@15
  int v28; // [sp+2Ch] [bp-230h]@9
  char v29; // [sp+30h] [bp-22Ch]@15
  int *v30; // [sp+34h] [bp-228h]@29
  unsigned int v31; // [sp+48h] [bp-214h]@29
  OLECHAR sz; // [sp+4Ch] [bp-210h]@4
  int v33; // [sp+258h] [bp-4h]@15

  v2 = a2;
  if ( !CNetConfig::HrEnsureExternalDataLoadedForAllComponents(a2) )
  {
    v3 = *((_DWORD *)a2 + 2);
    v25 = v3;
    if ( v3 != *((_DWORD *)a2 + 3) )
    {
      do
      {
        v4 = *(_DWORD *)v3;
        if ( *(_DWORD *)v3 )
        {
          StringFromGUID2((const GUID *const )v4, &sz, 256);
          v5 = *(_DWORD *)(v4 + 16);
          if ( v5 )
          {
            v6 = v5 - 1;
            if ( v6 )
            {
              v7 = v6 - 1;
              if ( v7 )
              {
                v8 = v7 - 1;
                if ( v8 )
                {
                  if ( v8 == 1 )
                    v28 = (int)"SERVICE  ";
                  else
                    v28 = (int)"(Invalid)";
                }
                else
                {
                  v28 = (int)"CLIENT   ";
                }
              }
              else
              {
                v28 = (int)"TRANSPORT";
              }
            }
            else
            {
              v28 = (int)"INFRARED ";
            }
          }
          else
          {
            v28 = (int)"NET      ";
          }
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v29);
          v9 = *(_DWORD *)(v4 + 24);
          v33 = 0;
          SzFromCharacteristics(v9, (int)&v29);
          v27 = (CComponentReferences *)(v4 + 120);
          *(_DWORD *)v24 = "Yes";
          if ( !CComponentReferences::FIsReferencedByUser((CComponentReferences *)(v4 + 120)) )
            *(_DWORD *)v24 = "No";
          v21 = *(_DWORD *)(v4 + 52);
          if ( !v21 )
            v21 = (int)L"none";
          v22 = *(_DWORD *)(v4 + 48);
          if ( !v22 )
            v22 = (int)L"(none)";
          v26 = *(_DWORD *)(v4 + 56);
          if ( !v26 )
            v26 = (int)L"<default>";
          *(_DWORD *)v23 = "Yes";
          if ( !*(_DWORD *)(v4 + 44) )
            *(_DWORD *)v23 = "No";
          v10 = *(_DWORD *)(v4 + 40);
          if ( !v10 )
            v10 = (int)L"<no description>";
          v11 = *(const WCHAR **)(v4 + 32);
          if ( !v11 )
            v11 = &String;
          v12 = v30;
          if ( v31 < 8 )
            v12 = (int *)&v30;
          CDiagContext::Printf(
            (DWORD)g_pDiagCtx,
            3,
            "\n%S   %S\n            Description:  %S\n                  Class:  %s\n              Character:  (0x%08x) %S\n                   Guid:  %S\n          NotifyObject?:  %s\n               BindForm:  %S\n               BindName:  %S\n   Service (CoServices):  %S  (%S)\n         Ref'd by User?:  %s\n",
            *(_DWORD *)(v4 + 28),
            v11,
            v10,
            v28,
            *(_DWORD *)(v4 + 24),
            v12,
            &sz,
            *(_DWORD *)v23,
            v26,
            *(_DWORD *)(v4 + 100),
            v22,
            v21,
            *(_DWORD *)v24);
          v13 = CComponentReferences::CountComponentsReferencedBy(v27);
          if ( v13 )
          {
            v14 = 0;
            sz = 0;
            if ( v13 )
            {
              do
              {
                v15 = CComponentReferences::PComponentReferencedByAtIndex(v27, v14);
                if ( v15 )
                {
                  if ( *((_DWORD *)v15 + 8) )
                    v16 = (const wchar_t *)*((_DWORD *)v15 + 8);
                  else
                    v16 = (const wchar_t *)*((_DWORD *)v15 + 7);
                  StringCchCatW(&sz, 0x100u, v16);
                  StringCchCatW(&sz, 0x100u, L" ");
                }
                ++v14;
              }
              while ( v14 < v13 );
            }
          }
          else
          {
            StringCchCopyW(&sz, 0x100u, L"(none)");
          }
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "    Ref'd by Components:  %S\n", &sz);
          v17 = CComponentReferences::CountSoftwareReferencedBy(v27);
          if ( v17 )
          {
            v18 = 0;
            sz = 0;
            if ( v17 )
            {
              do
              {
                v19 = CComponentReferences::PSoftwareReferencedByAtIndex((void *)v27, v18);
                if ( v19 )
                {
                  if ( *(_DWORD *)(v19 + 24) < 8u )
                    v20 = (const wchar_t *)(v19 + 4);
                  else
                    v20 = *(const wchar_t **)(v19 + 4);
                  StringCchCatW(&sz, 0x100u, v20);
                  StringCchCatW(&sz, 0x100u, L" ");
                }
                ++v18;
              }
              while ( v18 < (unsigned int)v17 );
            }
          }
          else
          {
            StringCchCopyW(&sz, 0x100u, L"(none)");
          }
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      Ref'd by Software:  %S\n", &sz);
          v33 = -1;
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v29,
            1,
            0);
          v3 = v25;
          v2 = a2;
        }
        v3 += 4;
        v25 = v3;
      }
      while ( v3 != *((_DWORD *)v2 + 3) );
    }
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
  }
}
// 6E663D68: using guessed type wchar_t aNoDescription[17];
// 6E663D8C: using guessed type wchar_t aDefault[10];
// 6E663DB0: using guessed type wchar_t aNone[5];

//----- (6E663E0F) --------------------------------------------------------
void __userpurge CmdEnableOrDisableBinding(struct IUnknown *a1@<ecx>, int a2@<edi>, struct IUnknown *a3, int a4)
{
  struct IUnknown *v4; // edi@2
  struct IUnknown *v5; // esi@3
  int v6; // eax@6
  int v7; // [sp-4h] [bp-8h]@2
  struct IUnknown *v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  if ( !HrCreateINetCfg(1, (struct CImplINetCfg **)&v8) )
  {
    v7 = a2;
    v4 = v8;
    if ( !HrFindBindPath(
            (struct CImplINetCfg *)v8,
            (const unsigned __int16 *)a3[10].lpVtbl,
            (struct INetCfgBindingPath **)&a3,
            0) )
    {
      v5 = a3;
      if ( a3 )
      {
        ((void (__stdcall *)(struct IUnknown *, int))a3->lpVtbl[2].QueryInterface)(a3, a4);
        ReleaseObj(v5);
      }
    }
    if ( ((int (__stdcall *)(struct IUnknown *, int))v4->lpVtbl[1].Release)(v4, v7) )
    {
      v6 = (int)"enable";
      if ( !a4 )
        v6 = (int)"disable";
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED to %s binding\n", v6);
    }
    ((void (*)(void))v4->lpVtbl[1].AddRef)();
    ReleaseObj(v4);
  }
}
// 6E663E0F: could not find valid save-restore pair for edi

//----- (6E663EC4) --------------------------------------------------------
void __userpurge CmdMoveBinding(int a1@<edi>, struct IUnknown *a2)
{
  struct CImplINetCfg *v2; // ebx@2
  struct IUnknown *v3; // esi@2
  struct INetCfgBindingPath *v4; // edi@2
  struct IUnknownVtbl *v5; // ecx@7
  int v6; // [sp-Ch] [bp-14h]@2
  struct INetCfgBindingPath *v7; // [sp+0h] [bp-8h]@5
  struct IUnknown *v8; // [sp+4h] [bp-4h]@1

  if ( HrCreateINetCfg(1, (struct CImplINetCfg **)&v8) )
    return;
  v2 = (struct CImplINetCfg *)v8;
  v3 = a2;
  v6 = a1;
  v4 = 0;
  if ( !HrFindBindPath(
          (struct CImplINetCfg *)v8,
          (const unsigned __int16 *)a2[10].lpVtbl,
          (struct INetCfgBindingPath **)&a2,
          (struct INetCfgComponentBindings **)&v8)
    && a2 )
  {
    if ( _wcsicmp((const wchar_t *)v3[11].lpVtbl, L"null") )
    {
      if ( HrFindBindPath(v2, (const unsigned __int16 *)v3[11].lpVtbl, &v7, 0) )
      {
LABEL_11:
        ReleaseObj(a2);
        ReleaseObj(v8);
        goto LABEL_12;
      }
      v4 = v7;
    }
    v5 = v8->lpVtbl;
    if ( v3[12].lpVtbl )
      v5[3].QueryInterface(v8, (const IID *const )a2, (void **)v4);
    else
      ((void (__stdcall *)(struct IUnknown *, struct IUnknown *, struct INetCfgBindingPath *))v5[3].AddRef)(v8, a2, v4);
    ReleaseObj((struct IUnknown *)v4);
    goto LABEL_11;
  }
LABEL_12:
  if ( (*(int (__stdcall **)(struct CImplINetCfg *, int))(*(_DWORD *)v2 + 20))(v2, v6) )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED to move binding\n");
  (*(void (__cdecl **)(struct CImplINetCfg *))(*(_DWORD *)v2 + 16))(v2);
  ReleaseObj((struct IUnknown *)v2);
}
// 6E663EC4: could not find valid save-restore pair for edi

//----- (6E663F9B) --------------------------------------------------------
void __userpurge CmdSetWanOrder(struct IUnknown *a1@<ecx>, int a2@<esi>, const struct DIAG_OPTIONS *a3)
{
  int v3; // ST0C_4@2
  struct IUnknown *v4; // esi@2
  struct IUnknown *v5; // [sp+0h] [bp-4h]@1

  v5 = a1;
  if ( !HrCreateINetCfg(1, (struct CImplINetCfg **)&v5) )
  {
    v3 = a2;
    v4 = v5;
    ((void (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))v5->lpVtbl->QueryInterface)(
      v5,
      &IID_INetCfgSpecialCase,
      &v5,
      v3);
    ((void (__stdcall *)(_DWORD, _DWORD))v5->lpVtbl[2].QueryInterface)(v5, *((_DWORD *)a3 + 13));
    ReleaseObj(v5);
    if ( v4->lpVtbl[1].Release(v4) )
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED to move binding\n");
    ((void (*)(void))v4->lpVtbl[1].AddRef)();
    ReleaseObj(v4);
  }
}
// 6E663F9B: could not find valid save-restore pair for esi

//----- (6E6640B4) --------------------------------------------------------
int __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(void *Src)
{
  return std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::assign(
           Src,
           strlen((const char *)Src));
}

//----- (6E6640DC) --------------------------------------------------------
exception *__thiscall std::logic_error::logic_error(exception *this, int a2)
{
  exception *v2; // esi@1

  v2 = this;
  exception::exception(this);
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(a2);
  return v2;
}
// 6E65C06C: using guessed type int (__thiscall *std::logic_error::`vftable')(void *lpMem, char);
// 6E664084: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(_DWORD);

//----- (6E664116) --------------------------------------------------------
std::logic_error *__thiscall std::logic_error::logic_error(std::logic_error *this, const struct std::logic_error *a2)
{
  std::logic_error *v2; // esi@1

  v2 = this;
  exception::exception((int)this, (int)a2);
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>((char *)a2 + 12);
  return v2;
}
// 6E65C06C: using guessed type int (__thiscall *std::logic_error::`vftable')(void *lpMem, char);
// 6E664084: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>(_DWORD);

//----- (6E66421D) --------------------------------------------------------
void __thiscall __noreturn std::logic_error::_Doraise(std::logic_error *this)
{
  char v1; // [sp+0h] [bp-28h]@1

  std::logic_error::logic_error((std::logic_error *)&v1, this);
  _CxxThrowException(&v1, &_TI2_AVlogic_error_std__);
}
// 6E664240: using guessed type int _TI2_AVlogic_error_std__;
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E664255) --------------------------------------------------------
void __thiscall __noreturn std::length_error::_Doraise(std::length_error *this)
{
  char v1; // [sp+0h] [bp-28h]@1

  std::length_error::length_error((std::length_error *)&v1, this);
  _CxxThrowException(&v1, &_TI3_AVlength_error_std__);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E695648: using guessed type int _TI3_AVlength_error_std__;

//----- (6E66427A) --------------------------------------------------------
void __thiscall CLanaMap::~CLanaMap(CLanaMap *this)
{
  int v1; // esi@1

  v1 = (int)this;
  MemFree(*((void **)this + 4));
  MemFree(*(void **)(v1 + 276));
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy(v1);
}

//----- (6E66429F) --------------------------------------------------------
void *__thiscall CLanaMap::CLanaMap(void *Dst)
{
  void *v1; // esi@1

  v1 = Dst;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy((int)Dst, 0);
  *((_DWORD *)v1 + 69) = 0;
  *((_DWORD *)v1 + 70) = 0;
  *((_DWORD *)v1 + 71) = 0;
  *((_DWORD *)v1 + 72) = 0;
  memset(v1, 0, 0x124u);
  *((_DWORD *)v1 + 72) = 256;
  return v1;
}

//----- (6E6642DC) --------------------------------------------------------
void __stdcall CmdShowLanaDiag(const struct DIAG_OPTIONS *a1)
{
  int *v1; // eax@2
  DWORD Type; // [sp+Ch] [bp-158h]@5
  HKEY hKey; // [sp+10h] [bp-154h]@4
  char Dst; // [sp+14h] [bp-150h]@1
  char v5; // [sp+138h] [bp-2Ch]@2
  int *v6; // [sp+13Ch] [bp-28h]@2
  unsigned int v7; // [sp+150h] [bp-14h]@2
  int v8; // [sp+160h] [bp-4h]@1

  CLanaMap::CLanaMap(&Dst);
  v8 = 0;
  if ( !CLanaMap::HrLoadLanaMap((CLanaMap *)&Dst) )
  {
    CDiagContext::Printf(
      (DWORD)g_pDiagCtx,
      3,
      "NetBios Bindings and Lana Information\n-------------------------------------\n");
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v5);
    LOBYTE(v8) = 1;
    CLanaMap::Dump(&Dst, (int)&v5);
    v1 = v6;
    if ( v7 < 8 )
      v1 = (int *)&v6;
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "%S", v1);
    if ( !HrRegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\currentcontrolset\\services\\netbios\\parameters",
            0x20019u,
            &hKey) )
    {
      if ( !HrRegQueryDword(hKey, L"MaxLana", (DWORD)&Type) )
        CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\nMaximum Lana: %d\n", Type);
      RegCloseKey(hKey);
    }
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
      (int)&v5,
      1,
      0);
  }
  CLanaMap::~CLanaMap((CLanaMap *)&Dst);
}

//----- (6E6644CA) --------------------------------------------------------
void __stdcall CmdShowLanaPaths(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  __int32 v2; // eax@1
  CLanaMap *v3; // ecx@1
  int i; // esi@3
  int v5; // eax@7
  wchar_t *v6; // eax@9
  wchar_t *v7; // eax@10
  signed int v8; // eax@11
  wchar_t *v9; // eax@12
  wchar_t v10; // cx@13
  unsigned __int32 v11; // [sp+Ch] [bp-344h]@5
  wchar_t *Str; // [sp+10h] [bp-340h]@5
  char v13; // [sp+14h] [bp-33Ch]@1
  int v14; // [sp+18h] [bp-338h]@3
  int v15; // [sp+1Ch] [bp-334h]@19
  unsigned __int16 v16; // [sp+138h] [bp-218h]@3
  char Dst; // [sp+13Ah] [bp-216h]@3
  int v18; // [sp+34Ch] [bp-4h]@1

  CLanaMap::CLanaMap(&v13);
  v18 = 0;
  PromptForLeakCheck(a1, "Show Lana UI info diagnostic...(dump heap)");
  v2 = CNetConfig::HrEnsureExternalDataLoadedForAllComponents(a2);
  v3 = (CLanaMap *)&v13;
  if ( !v2 )
  {
    if ( !CLanaMap::HrLoadLanaMap((CLanaMap *)&v13) )
    {
      v16 = 0;
      memset(&Dst, 0, 0x206u);
      for ( i = v14; i != v15; i += 8 )
      {
        if ( *(_BYTE *)(i + 4) == 1 )
        {
          CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "Lana: %3d\n", *(_BYTE *)(i + 5));
          GetFirstComponentFromBindPath(*(wchar_t **)i, (const unsigned __int16 **)&Str, &v11);
          while ( Str && *Str )
          {
            StringCchCopyNW(&v16, 0x104u, Str, v11);
            v5 = CComponentList::PFindComponentByBindName((int)a2, 6u, &v16);
            if ( v5 )
              CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "-->%S", *(_DWORD *)(v5 + 40));
            v6 = wcschr(Str, 0x5Fu);
            Str = v6;
            if ( !v6 )
              break;
            Str = v6 + 1;
            v7 = wcschr(v6 + 1, 0x5Fu);
            if ( v7 )
            {
              v8 = (char *)v7 - (char *)Str;
            }
            else
            {
              v9 = Str;
              do
              {
                v10 = *v9;
                ++v9;
              }
              while ( v10 );
              v8 = (char *)v9 - (char *)(Str + 1);
            }
            v11 = v8 >> 1;
          }
          CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\n\n");
        }
      }
    }
    PromptForLeakCheck(a1, "Show Lana UI info diagnostic...(dump heap and compare)");
    v3 = (CLanaMap *)&v13;
  }
  CLanaMap::~CLanaMap(v3);
}

//----- (6E6646F8) --------------------------------------------------------
void __stdcall CmdSetLanaNumber(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  __int32 v2; // eax@1
  CLanaMap *v3; // ecx@1
  signed int v4; // edi@2
  char v5; // al@3
  char Dst; // [sp+Ch] [bp-134h]@1
  int v7; // [sp+13Ch] [bp-4h]@1

  CLanaMap::CLanaMap(&Dst);
  v7 = 0;
  v2 = CNetConfig::HrEnsureExternalDataLoadedForAllComponents(a2);
  v3 = (CLanaMap *)&Dst;
  if ( !v2 )
  {
    v4 = CLanaMap::HrLoadLanaMap((CLanaMap *)&Dst);
    if ( v4 )
      goto LABEL_8;
    v5 = *((_BYTE *)a1 + 64);
    if ( v5 == *((_BYTE *)a1 + 65) )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nNo change.\n");
    }
    else
    {
      v4 = CLanaMap::HrSetLanaNumber((CLanaMap *)&Dst, v5, *((_BYTE *)a1 + 65));
      if ( v4 )
        goto LABEL_8;
      v4 = CLanaMap::HrWriteLanaConfiguration((CLanaMap *)&Dst, a2);
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nLana changed.\n");
    }
    if ( !v4 )
    {
LABEL_14:
      v3 = (CLanaMap *)&Dst;
      goto LABEL_15;
    }
LABEL_8:
    if ( v4 == -2147020584 )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nThe old lana number is not currently assigned to a bind path.\n");
    }
    else if ( v4 == -2147024713 )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nThe new lana number is currently assigned to a bind path.\n");
    }
    else
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nError %X occurred\n", v4);
    }
    goto LABEL_14;
  }
LABEL_15:
  CLanaMap::~CLanaMap(v3);
}

//----- (6E664895) --------------------------------------------------------
void __thiscall CBindingSet::~CBindingSet(CBindingSet *this)
{
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)this + 4));
}

//----- (6E6648A2) --------------------------------------------------------
void __stdcall CmdShowBindings(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  bool v2; // zf@1
  char *v3; // ecx@2
  int v4; // eax@3
  int v5; // ebx@4
  int v6; // eax@7
  int v7; // eax@8
  const struct CComponent **v8; // esi@16
  char v9; // [sp+Ch] [bp-44h]@8
  int v10; // [sp+10h] [bp-40h]@1
  int v11; // [sp+20h] [bp-30h]@1
  char v12; // [sp+24h] [bp-2Ch]@1
  int v13; // [sp+4Ch] [bp-4h]@1

  v11 = 0;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v10, 0);
  v13 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v12);
  v2 = *((_DWORD *)a1 + 7) == 4;
  LOBYTE(v13) = 1;
  if ( v2 )
  {
    v3 = (char *)a2 + 44;
    goto LABEL_23;
  }
  v4 = *((_DWORD *)a1 + 8);
  if ( v4 != 2 )
  {
    if ( v4 == 1 )
    {
      v8 = (const struct CComponent **)*((_DWORD *)a2 + 2);
      if ( v8 != *((const struct CComponent ***)a2 + 3) )
      {
        while ( 1 )
        {
          if ( *v8 )
          {
            v11 = CNetConfigCore::HrGetComponentBindings(a2, *v8, 1u, (struct CBindingSet *)&v9);
            if ( v11 )
              goto LABEL_24;
          }
          ++v8;
          if ( v8 == *((const struct CComponent ***)a2 + 3) )
            goto LABEL_20;
        }
      }
    }
LABEL_21:
    if ( !std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)&v10) )
    {
LABEL_24:
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
        (int)&v12,
        1,
        0);
      goto LABEL_25;
    }
    v3 = &v9;
LABEL_23:
    CBindingSet::Printf(v3, 3, 0);
    goto LABEL_24;
  }
  v5 = CComponentList::PFindComponentByPnpId(a2, *((const unsigned __int16 **)a1 + 9));
  if ( v5 || (v5 = CComponentList::PFindComponentByInfId(a2, *((wchar_t **)a1 + 9), 0)) != 0 )
  {
    v6 = *((_DWORD *)a1 + 7);
    if ( v6 == 1 )
    {
      v7 = CNetConfigCore::HrGetComponentBindings(a2, (const struct CComponent *)v5, 0, (struct CBindingSet *)&v9);
    }
    else
    {
      if ( v6 != 2 )
      {
LABEL_12:
        if ( *((_DWORD *)a1 + 7) == 3 && FIsConsideredNetClass(*(_DWORD *)(v5 + 16)) )
          v11 = CNetConfigCore::HrGetComponentUpperBindings(
                  a2,
                  (const struct CComponent *)v5,
                  0,
                  (struct CBindingSet *)&v9);
LABEL_20:
        if ( v11 )
          goto LABEL_24;
        goto LABEL_21;
      }
      v7 = CNetConfigCore::HrGetBindingsInvolvingComponent(
             a2,
             (const struct CComponent *)v5,
             0,
             (struct CBindingSet *)&v9);
    }
    v11 = v7;
    goto LABEL_12;
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Component not found.");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v12,
    1,
    0);
LABEL_25:
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v10);
}

//----- (6E6649FE) --------------------------------------------------------
void __stdcall CmdWriteBindings(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  const struct CComponent **i; // esi@2
  char v3; // [sp+Ch] [bp-54h]@1
  int v4; // [sp+5Ch] [bp-4h]@1

  CRegistryBindingsContext::CRegistryBindingsContext((int)&v3);
  v4 = 0;
  if ( !CRegistryBindingsContext::HrPrepare((CRegistryBindingsContext *)&v3, a2) )
  {
    for ( i = (const struct CComponent **)*((_DWORD *)a2 + 2); i != *((const struct CComponent ***)a2 + 3); ++i )
    {
      if ( *i )
        CRegistryBindingsContext::HrWriteBindingsForComponent((CRegistryBindingsContext *)&v3, *i);
    }
  }
  CRegistryBindingsContext::~CRegistryBindingsContext((CRegistryBindingsContext *)&v3);
}

//----- (6E664A57) --------------------------------------------------------
void __stdcall CmdRewriteLanaInfo(const struct DIAG_OPTIONS *a1, struct CNetConfig *a2)
{
  int v2; // eax@2
  char v3; // [sp+Ch] [bp-54h]@1
  int v4; // [sp+5Ch] [bp-4h]@1

  CRegistryBindingsContext::CRegistryBindingsContext((int)&v3);
  v4 = 0;
  if ( !CRegistryBindingsContext::HrPrepare((CRegistryBindingsContext *)&v3, a2) )
  {
    v2 = CComponentList::PFindComponentByInfId(a2, L"MS_NetBios", 0);
    if ( v2 )
      CRegistryBindingsContext::HrWriteBindingsForComponent(
        (CRegistryBindingsContext *)&v3,
        (const struct CComponent *)v2);
    else
      CDiagContext::Printf((DWORD)g_pDiagCtx, 26, "\nNetBios is not installed.\n");
  }
  CRegistryBindingsContext::~CRegistryBindingsContext((CRegistryBindingsContext *)&v3);
}

//----- (6E664AF7) --------------------------------------------------------
void __stdcall CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic(const struct DIAG_OPTIONS *a1, int a2)
{
  struct IUnknown *v2; // edi@1
  int v3; // esi@3
  char v4; // [sp+Ch] [bp-138h]@3
  char v5; // [sp+4Ch] [bp-F8h]@4
  struct IUnknown *v6; // [sp+50h] [bp-F4h]@5
  int v7; // [sp+140h] [bp-4h]@3

  v2 = 0;
  if ( !a2 )
    PromptForLeakCheck(a1, "Create/Release diagnostic...(dump heap)");
  CNetConfig::CNetConfig(&v4);
  v7 = 0;
  v3 = HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v4);
  if ( !v3 )
  {
    v3 = CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized((CGlobalNotifyInterface *)&v5);
    if ( !v3 )
    {
      v2 = v6;
      AddRefObj(v6);
    }
  }
  v7 = -1;
  CNetConfig::~CNetConfig((CNetConfig *)&v4);
  if ( !v3 )
  {
    if ( !v2 )
      goto LABEL_11;
    v3 = v2->lpVtbl[1].AddRef(v2);
    ReleaseObj(v2);
  }
  if ( v3 == -2147180511 )
  {
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Passed Create/Release diagnostic.\n");
    goto LABEL_12;
  }
LABEL_11:
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Create/Release diagnostic.\n");
LABEL_12:
  if ( !a2 )
    PromptForLeakCheck(a1, "Create/Release diagnostic...(dump heap and compare)");
}

//----- (6E664C6D) --------------------------------------------------------
void __stdcall CNetCfgInternalDiagnostic::DoSaveLoadDiagnostic(const struct DIAG_OPTIONS *a1, struct CNetConfig *lpMem)
{
  struct CNetConfig *v2; // esi@1
  const struct CComponent **v3; // edi@2
  unsigned __int16 *v4; // ebx@7
  char v5; // [sp+Ch] [bp-160h]@8
  int v6; // [sp+13Ch] [bp-30h]@1
  int v7; // [sp+14Ch] [bp-20h]@1
  unsigned __int32 v8; // [sp+150h] [bp-1Ch]@9
  int v9; // [sp+154h] [bp-18h]@1
  unsigned __int32 v10; // [sp+158h] [bp-14h]@7
  size_t Size; // [sp+15Ch] [bp-10h]@7
  int v12; // [sp+168h] [bp-4h]@1

  v9 = 0;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v6, 0);
  v12 = 0;
  v2 = lpMem;
  v7 = (int)((char *)lpMem + 48);
  if ( !std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)lpMem + 48)) )
  {
    v3 = (const struct CComponent **)*((_DWORD *)v2 + 2);
    v9 = 1;
    while ( v3 != *((const struct CComponent ***)v2 + 3) )
    {
      if ( *v3 && CNetConfigCore::HrGetComponentBindings(v2, *v3, 1u, (struct CNetConfig *)((char *)v2 + 44)) )
        goto LABEL_20;
      ++v3;
    }
  }
  v4 = (unsigned __int16 *)HrSaveNetworkConfigurationToBufferWithAlloc(v2, (size_t)&Size, &v10);
  if ( !v4 )
  {
    CNetConfig::CNetConfig(&v5);
    LOBYTE(v12) = 1;
    v4 = HrLoadNetworkConfigurationFromBuffer((const unsigned __int8 *)Size, v10, (struct CNetConfig *)&v5);
    if ( !v4 )
    {
      v4 = (unsigned __int16 *)HrSaveNetworkConfigurationToBufferWithAlloc(
                                 (struct CNetConfig *)&v5,
                                 (size_t)&lpMem,
                                 &v8);
      if ( !v4 )
      {
        if ( v8 == v10 && !memcmp((const char *)lpMem, (const char *)Size, v10) )
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "Passed Save/Load diagnostic.  (%d bytes)\n", v10);
        else
          CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED compare for Save/Load diagnostic.\n");
        MemFree((void *)lpMem);
      }
    }
    MemFree((void *)Size);
    LOBYTE(v12) = 0;
    CNetConfig::~CNetConfig((CNetConfig *)&v5);
  }
  if ( v9 )
    std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear(v7);
  if ( v4 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "FAILED Save/Load diagnostic.\n");
LABEL_20:
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v6);
}

//----- (6E664E43) --------------------------------------------------------
void __userpurge CNetCfgInternalDiagnostic::CmdFullDiagnostic(int a1@<edi>, const struct DIAG_OPTIONS *a2, struct CNetConfig *lpMem)
{
  CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic(a2, 1);
  if ( *((_DWORD *)a2 + 14) )
    CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic(a2, 0);
  CNetCfgInternalDiagnostic::DoEnumAllDiagnostic(a1, a2);
  CNetCfgInternalDiagnostic::DoSaveLoadDiagnostic(a2, lpMem);
  CNetCfgInternalDiagnostic::DoWriteLockDiagnostic(a1, (int)a2, a2, lpMem);
}

//----- (6E664E84) --------------------------------------------------------
void __userpurge NetCfgDiagFromCommandArgs(int a1@<edi>, struct IUnknown *a2)
{
  struct IUnknown *v2; // ecx@1
  char v3; // [sp+4h] [bp-12Ch]@1

  g_pDiagCtx = (CDiagContext *)a2->lpVtbl;
  CNetConfig::CNetConfig(&v3);
  HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v3);
  switch ( a2[1].lpVtbl )
  {
    case 1u:
      CmdShowBindings((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 2u:
      CmdShowComponents((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 3u:
      CmdShowStackTable((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 4u:
      CmdShowLanAdapterPnpIds((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 5u:
      CmdAddComponent(a1, a2, (struct CNetConfig *)&v3);
      break;
    case 6u:
      CmdRemoveComponent(a1, (const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 7u:
      CmdUpdateComponent(a1, a2, (struct CNetConfig *)&v3);
      break;
    case 8u:
      CmdRemoveReferences((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 9u:
      CmdEnableOrDisableBinding(v2, a1, a2, 1);
      break;
    case 0xAu:
      CmdEnableOrDisableBinding(v2, a1, a2, 0);
      break;
    case 0xBu:
      CmdMoveBinding(a1, a2);
      break;
    case 0xCu:
      CmdWriteBindings((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 0xDu:
      CmdSetWanOrder(v2, (int)a2, (const struct DIAG_OPTIONS *)a2);
      break;
    case 0xEu:
      CNetCfgInternalDiagnostic::CmdFullDiagnostic(a1, (const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 0xFu:
      CmdCleanup((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    case 0x10u:
      CmdAddRemoveStress((const struct DIAG_OPTIONS *)a2, (struct CNetConfig *)&v3);
      break;
    default:
      break;
  }
  g_pDiagCtx = 0;
  CNetConfig::~CNetConfig((CNetConfig *)&v3);
}

//----- (6E665005) --------------------------------------------------------
void __stdcall NetCfgDiagRepairRegistryBindings(FILE *File)
{
  signed int v1; // ebx@1
  HRESULT v2; // eax@1
  __int32 v3; // eax@4
  char v4; // [sp+8h] [bp-140h]@4
  int v5; // [sp+134h] [bp-14h]@4
  int v6; // [sp+138h] [bp-10h]@4
  FILE *v7; // [sp+13Ch] [bp-Ch]@4
  int v8; // [sp+140h] [bp-8h]@4
  int v9; // [sp+144h] [bp-4h]@4

  v1 = 1;
  v2 = CoInitializeEx(0, 6u);
  if ( v2 >= 0 || (v1 = 0, v2 == -2147417850) )
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    CNetConfig::CNetConfig(&v4);
    CDiagContext::SetFlags((CDiagContext *)&v5, 0x20u);
    g_pDiagCtx = (CDiagContext *)&v5;
    v7 = File;
    v3 = HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v4);
    if ( v3 )
      fprintf(File, "Failed to load network configuration from the registry.  (hr=0x%08x)\n", v3);
    else
      CmdWriteBindings(0, (struct CNetConfig *)&v4);
    g_pDiagCtx = 0;
    if ( v1 )
      CoUninitialize();
    CNetConfig::~CNetConfig((CNetConfig *)&v4);
    CDiagContext::~CDiagContext((CDiagContext *)&v5);
  }
  else
  {
    fprintf(File, "CoInitializeEx failed.  (hr=0x%08x)\n", v2);
  }
}

//----- (6E66514A) --------------------------------------------------------
void __stdcall LanaCfgFromCommandArgs(struct DIAG_OPTIONS *a1)
{
  char v1; // [sp+4h] [bp-12Ch]@1

  g_pDiagCtx = *(CDiagContext **)a1;
  CNetConfig::CNetConfig(&v1);
  HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v1);
  switch ( *((_DWORD *)a1 + 1) )
  {
    case 0x11:
      CmdShowLanaDiag(a1);
      break;
    case 0x13:
      CmdShowLanaPaths(a1, (struct CNetConfig *)&v1);
      break;
    case 0x14:
      CmdSetLanaNumber(a1, (struct CNetConfig *)&v1);
      break;
    case 0x15:
      CmdRewriteLanaInfo(a1, (struct CNetConfig *)&v1);
      break;
  }
  g_pDiagCtx = 0;
  CNetConfig::~CNetConfig((CNetConfig *)&v1);
}

//----- (6E6651DD) --------------------------------------------------------
signed int __stdcall CImplINetCfg::GetAdapterOrder(CImplINetCfg *this, unsigned __int32 *a2, struct INetCfgComponent ***a3, int *a4)
{
  return -2147467263;
}

//----- (6E6651EA) --------------------------------------------------------
int __stdcall StringCchCatNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // ebx@1
  int result; // eax@1
  unsigned int v6; // ecx@5

  v4 = a2;
  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result < 0 )
  {
    v6 = 0;
  }
  else
  {
    result = sub_6E64AC25((int)a1, a2, (int)&a2);
    v6 = a2;
  }
  if ( result >= 0 )
  {
    if ( a4 <= 0x7FFFFFFE )
      result = sub_6E641D2F((int)a3, v4 - v6, (int)&a1[v6], 0, a4);
    else
      result = -2147024809;
  }
  return result;
}

//----- (6E665256) --------------------------------------------------------
signed int __stdcall CImplINetCfg::Validate(CImplINetCfg *this)
{
  signed int v1; // edi@1

  v1 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0x10u);
  if ( !v1 )
    LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
  return v1;
}

//----- (6E665286) --------------------------------------------------------
signed int __stdcall CImplINetCfg::Cancel(CImplINetCfg *this)
{
  signed int v1; // edi@1
  int v2; // eax@2

  v1 = CImplINetCfg::HrLockAndTestForValidInterface(this, 0x10u);
  if ( !v1 )
  {
    v2 = *((_DWORD *)this + 12);
    if ( *(_BYTE *)(v2 + 296) )
      v1 = CModifyContext::HrApplyIfOkOrCancel((CModifyContext *)(v2 + 72), 0);
    LeaveCriticalSection((LPCRITICAL_SECTION)this + 1);
  }
  return v1;
}

//----- (6E6652CD) --------------------------------------------------------
signed int __stdcall CImplINetCfg::IsWriteLocked(CImplINetCfg *this, unsigned __int16 **a2)
{
  signed int v2; // esi@3

  if ( a2 )
    *a2 = 0;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 20));
  v2 = CImplINetCfg::HrCheckForReentrancy((CImplINetCfg *)((char *)this - 4), 0);
  if ( !v2 )
    v2 = CWriteLock::FIsLockedByAnyone((CImplINetCfg *)((char *)this + 68), a2) == 0;
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 20));
  return v2;
}

//----- (6E665323) --------------------------------------------------------
signed int __stdcall CImplINetCfg::BeginBatchOperation(CImplINetCfg *this)
{
  signed int v1; // edi@1

  v1 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 2u);
  if ( !v1 )
  {
    v1 = CModifyContext::HrBeginBatchOperation((CModifyContext *)(*((_DWORD *)this + 10) + 72));
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
  }
  return v1;
}

//----- (6E665361) --------------------------------------------------------
signed int __stdcall CImplINetCfg::CommitBatchOperation(CImplINetCfg *this)
{
  signed int v1; // edi@1

  v1 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 2u);
  if ( !v1 )
  {
    v1 = CModifyContext::HrEndBatchOperation(*((_DWORD *)this + 10) + 72, 1);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
  }
  return v1;
}

//----- (6E6653A1) --------------------------------------------------------
signed int __stdcall CImplINetCfg::SelectWithFilterAndInstall(CImplINetCfg *this, HWND hWnd, const struct _GUID *lpMem, struct tagOBO_TOKEN *a4, const struct tagCI_FILTER_INFO *a5, struct INetCfgComponent **a6)
{
  signed int result; // eax@2
  signed int v7; // ebx@6
  const struct tagCI_FILTER_INFO *v8; // esi@11
  int v9; // ebx@13
  __int32 v10; // eax@15
  int v11; // eax@18
  int v12; // eax@19
  int v13; // esi@20
  struct INetCfgComponent *v14; // eax@20
  int v15; // [sp+0h] [bp-4h]@1

  v15 = NetClassEnumFromGuid(lpMem);
  if ( FIsConsideredNetClass(v15) )
  {
    result = -2147024809;
  }
  else
  {
    if ( FOboTokenValidForClass((int)a4, v15) )
    {
      if ( !hWnd || IsWindow(hWnd) )
      {
        v7 = HrProbeOboToken(a4);
        if ( !v7 )
        {
          if ( a6 )
            *a6 = 0;
          v7 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 0x22u);
          if ( !v7 )
          {
            v8 = a5;
            if ( a5 )
            {
              if ( !*(_DWORD *)a5 )
              {
                v9 = *((_DWORD *)a5 + 1);
                if ( !CImplINetCfgComponent::HrIsValidInterface(*((CImplINetCfgComponent **)a5 + 1), 4u) )
                  *((_DWORD *)v8 + 2) = *(_DWORD *)(v9 + 28);
              }
            }
            v10 = HrCiSelectComponent(v15, hWnd, (void *)v8, (int)&lpMem);
            v7 = v10;
            if ( v8 )
              *((_DWORD *)v8 + 2) = 0;
            if ( !v10 )
            {
              v11 = CComponentList::PFindComponentByInfId(
                      *((CComponentList **)this + 10),
                      *(wchar_t **)&lpMem->Data2,
                      0);
              hWnd = (HWND)v11;
              if ( v11 )
              {
                v13 = *(_DWORD *)this;
                v14 = CComponent::GetINetCfgComponentInterface((CComponent *)v11);
                v12 = (*(int (__stdcall **)(CImplINetCfg *, struct INetCfgComponent *, signed int, _DWORD))(v13 + 32))(
                        this,
                        v14,
                        512,
                        0);
              }
              else
              {
                *(_DWORD *)&lpMem->Data4[4] = a4;
                v12 = CModifyContext::HrInstallNewOrReferenceExistingComponent(
                        (CModifyContext *)(*((_DWORD *)this + 10) + 72),
                        (const struct COMPONENT_INSTALL_PARAMS *)lpMem,
                        (struct CComponent **)&hWnd);
              }
              v7 = v12;
              if ( v12 >= 0 )
              {
                if ( a6 )
                  CComponent::HrGetINetCfgComponentInterface((CComponent *)hWnd, (CImplINetCfg *)((char *)this - 8), a6);
              }
              operator delete((void *)lpMem);
            }
            LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
          }
        }
      }
      else
      {
        v7 = -2147024809;
      }
    }
    else
    {
      v7 = -2147467261;
    }
    result = v7;
  }
  return result;
}

//----- (6E6654F5) --------------------------------------------------------
signed int __stdcall CImplINetCfg::EnumeratedComponentInstalled(CImplINetCfg *this, void *a2)
{
  CImplINetCfg *v2; // esi@1
  signed int v3; // edi@1
  int v4; // ecx@2
  char v6; // [sp+8h] [bp-1Ch]@2
  void *v7; // [sp+20h] [bp-4h]@2

  v2 = this;
  v3 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 0x22u);
  if ( !v3 )
  {
    memset(&v6, 0, 0x1Cu);
    v4 = *((_DWORD *)v2 + 10);
    v7 = a2;
    v3 = CModifyContext::HrInstallNewOrReferenceExistingComponent(
           (CModifyContext *)(v4 + 72),
           (const struct COMPONENT_INSTALL_PARAMS *)&v6,
           &this);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v2 + 16));
  }
  return v3;
}

//----- (6E66554C) --------------------------------------------------------
signed int __stdcall CImplINetCfg::EnumeratedComponentUpdated(CImplINetCfg *this, const unsigned __int16 *a2)
{
  signed int v2; // edi@1
  int v3; // eax@2

  v2 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 2u);
  if ( !v2 )
  {
    v3 = CComponentList::PFindComponentByPnpId(*((CComponentList **)this + 10), a2);
    if ( v3 )
      v2 = CModifyContext::HrUpdateComponent(
             (CModifyContext *)(*((_DWORD *)this + 10) + 72),
             (struct CComponent *)v3,
             0,
             0);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
  }
  return v2;
}

//----- (6E66559C) --------------------------------------------------------
signed int __stdcall CImplINetCfg::UpdateNonEnumeratedComponent(CImplINetCfg *this, struct INetCfgComponent *a2, unsigned __int32 a3, unsigned __int32 a4)
{
  CImplINetCfg *v4; // edi@1
  struct INetCfgComponent *v5; // esi@2
  struct INetCfgComponentVtbl *v7; // esi@5
  __int32 v8; // eax@6
  unsigned __int32 v9; // ST0C_4@9
  HRESULT (__stdcall *v10)(INetCfgComponent *, LPCWSTR); // [sp+Ch] [bp-20h]@6
  HRESULT (__stdcall *v11)(INetCfgComponent *, LPDWORD); // [sp+10h] [bp-1Ch]@6
  HKEY hKey; // [sp+28h] [bp-4h]@5

  v4 = this;
  if ( !CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 0x22u) )
  {
    v5 = a2;
    if ( !a2 )
    {
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
      return -2147024882;
    }
    if ( !CImplINetCfgComponent::HrIsValidInterface((CImplINetCfgComponent *)a2, 4u) )
    {
      v7 = v5[7].lpVtbl;
      if ( !CComponent::HrOpenInstanceKey((CComponent *)v7, 0x3001Fu, &hKey, 0, 0) )
      {
        memset(&v10, 0, 0x1Cu);
        v10 = v7->SetDisplayName;
        v11 = v7->GetCharacteristics;
        v8 = HrCiInstallComponent((const struct COMPONENT_INSTALL_PARAMS *)&v10, 0, (unsigned __int32 *)&a2);
        if ( v8 == -2146500093 )
        {
          CComponentReferences::RemoveAllReferences((CComponentReferences *)&v7[2]);
          CModifyContext::HrRemoveComponentIfNotReferenced(
            (CModifyContext *)(*((_DWORD *)this + 10) + 72),
            (struct CComponent *)v7,
            0,
            0);
        }
        else if ( !v8 )
        {
          v9 = a4;
          v7->GetId = (HRESULT (__stdcall *)(INetCfgComponent *, LPWSTR *))a2;
          CModifyContext::HrUpdateComponent(
            (CModifyContext *)(*((_DWORD *)this + 10) + 72),
            (struct CComponent *)v7,
            a3,
            v9);
        }
        RegCloseKey(hKey);
        v4 = this;
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 16));
  }
  return 0;
}

//----- (6E66568A) --------------------------------------------------------
signed int __stdcall CImplINetCfg::EnumeratedComponentRemoved(CImplINetCfg *this, const unsigned __int16 *a2)
{
  signed int v2; // ebx@1
  int v3; // eax@2
  int v4; // eax@3

  v2 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 8), 0x22u);
  if ( !v2 )
  {
    v3 = CComponentList::PFindComponentByPnpId(*((CComponentList **)this + 10), a2);
    if ( v3
      && (v4 = CModifyContext::HrRemoveComponentIfNotReferenced(
                 (CModifyContext *)(*((_DWORD *)this + 10) + 72),
                 (struct CComponent *)v3,
                 0,
                 0),
          (v2 = v4) != 0) )
    {
      if ( v4 == -2147180507 )
        SetDelayedCleanupFlagEnumCompRemoval(a2, 0);
    }
    else
    {
      ReleaseExternallyManagedResources(a2);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 16));
  }
  return v2;
}

//----- (6E6656FA) --------------------------------------------------------
signed int __stdcall CImplINetCfg::GetWanAdaptersFirst(CImplINetCfg *this, int *a2)
{
  signed int v2; // edi@1

  v2 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 12), 0);
  if ( !v2 )
  {
    *a2 = *(_DWORD *)(*((_DWORD *)this + 9) + 40);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  }
  return v2;
}

//----- (6E665736) --------------------------------------------------------
signed int __stdcall CImplINetCfg::SetWanAdaptersFirst(CImplINetCfg *this, int a2)
{
  signed int v2; // edi@1

  v2 = CImplINetCfg::HrLockAndTestForValidInterface((CImplINetCfg *)((char *)this - 12), 2u);
  if ( !v2 )
  {
    CStackTable::SetWanAdapterOrder((CStackTable *)(*((_DWORD *)this + 9) + 20), a2 != 0);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 12));
  }
  return v2;
}

//----- (6E665779) --------------------------------------------------------
__int32 __stdcall CImplINetCfg::SendPnpReconfig(CImplINetCfg *this, enum tagNCPNP_RECONFIG_LAYER a2, PCWSTR a3, unsigned __int16 *a4, void *a5, size_t Size)
{
  LSA_UNICODE_STRING v7; // [sp+8h] [bp-22Ch]@6
  LSA_UNICODE_STRING DestinationString; // [sp+10h] [bp-224h]@6
  LSA_UNICODE_STRING v9; // [sp+18h] [bp-21Ch]@6
  void *Src; // [sp+20h] [bp-214h]@1
  __int32 v11; // [sp+24h] [bp-210h]@3
  WCHAR SourceString; // [sp+28h] [bp-20Ch]@4

  Src = a5;
  if ( a2 == 1 || a2 == 2 )
  {
    v11 = 0;
    SourceString = 0;
    if ( *a4 )
    {
      StringCchCopyW(&SourceString, 0x104u, L"\\Device\\");
      StringCchCatNW(&SourceString, 0x104u, a4, 260 - wcslen(&SourceString));
    }
    RtlInitUnicodeString(&DestinationString, &SourceString);
    RtlInitUnicodeString(&v7, a3);
    RtlInitUnicodeString(&v9, 0);
    if ( !NdisHandlePnPEvent((a2 != 1) + 1, 3, (int)&DestinationString, (int)&v7, (int)&v9, Src, Size) )
      v11 = HrFromLastWin32Error();
  }
  else
  {
    v11 = -2147024809;
  }
  return v11;
}

//----- (6E665897) --------------------------------------------------------
signed int __stdcall CImplINetCfg::HrCreateInstance(struct CNetConfig *a1, struct CImplINetCfg **a2)
{
  signed int v2; // edi@1
  void *v3; // eax@1
  void *v4; // esi@2

  v2 = -2147024882;
  v3 = operator new(0x5Cu);
  if ( v3 )
    v4 = ATL::CComObject<CImplINetCfg>::CComObject<CImplINetCfg>(v3, 0);
  else
    v4 = 0;
  if ( v4 )
  {
    *((_DWORD *)v4 + 12) = a1;
    v2 = 0;
    AddRefObj((struct IUnknown *)v4);
    *a2 = (struct CImplINetCfg *)v4;
  }
  return v2;
}

//----- (6E6658E2) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::~CNotifyObjectInterface(CNotifyObjectInterface *this)
{
  CNotifyObjectInterface::ReleaseNotifyObject(this, 0, 0);
}

//----- (6E6658F1) --------------------------------------------------------
struct INetCfgComponent *__thiscall CComponent::GetINetCfgComponentInterface(CComponent *this)
{
  return (struct INetCfgComponent *)*((_DWORD *)this + 31);
}

//----- (6E6658FA) --------------------------------------------------------
int __thiscall CComponent::FCanDirectlyBindToFilter(CComponent *this, const unsigned __int16 *const a2, const unsigned __int16 *const a3)
{
  int result; // eax@1
  CComponent *v4; // esi@1
  const unsigned __int16 *v5; // eax@2
  const unsigned __int16 *v6; // eax@6

  result = 1;
  v4 = this;
  if ( !a2 )
    goto LABEL_11;
  v5 = (const unsigned __int16 *)*((_DWORD *)this + 20);
  if ( !v5 )
    v5 = &String;
  result = FSubstringMatch(a2, v5, 0, 0);
  if ( result )
  {
LABEL_11:
    if ( a3 )
    {
      v6 = (const unsigned __int16 *)*((_DWORD *)v4 + 21);
      if ( !v6 )
        v6 = &String;
      result = FSubstringMatch(a3, v6, 0, 0) == 0;
    }
  }
  return result;
}

//----- (6E665955) --------------------------------------------------------
int __thiscall CComponent::FIsWanAdapter(CComponent *this)
{
  const unsigned __int16 *v1; // ecx@2
  int result; // eax@5

  if ( *((_DWORD *)this + 4) )
    goto LABEL_9;
  v1 = (const unsigned __int16 *)*((_DWORD *)this + 20);
  if ( !v1 )
    v1 = &String;
  if ( !FSubstringMatch(v1, L"wan", 0, 0) )
LABEL_9:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (6E665991) --------------------------------------------------------
__int32 __thiscall CComponent::HrStartEnumeratedComponent(CComponent *this)
{
  CComponent *v1; // esi@1
  int v2; // eax@2
  __int32 v3; // eax@3
  int v4; // eax@4
  __int32 v5; // eax@5
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-30h]@1
  HDEVINFO DeviceInfoSet; // [sp+14h] [bp-28h]@1
  __int32 v9; // [sp+18h] [bp-24h]@1
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+1Ch] [bp-20h]@1

  v1 = this;
  LogToken = SetupGetThreadLogToken();
  v9 = CComponent::HrOpenDeviceInfo(v1, &DeviceInfoSet, &DeviceInfoData);
  if ( !v9 )
  {
    v2 = *((_DWORD *)v1 + 33);
    if ( v2 )
    {
      v3 = HrSetupDiSetDeipFlags(DeviceInfoSet, &DeviceInfoData, v2, 0, 1);
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: SP_DEVINSTALL_PARAMS.Flags 0x%08x. Set result 0x%08x",
        *((_DWORD *)v1 + 33),
        v3);
    }
    v4 = *((_DWORD *)v1 + 34);
    if ( v4 )
    {
      v5 = HrSetupDiSetDeipFlags(DeviceInfoSet, &DeviceInfoData, v4, 1, 1);
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: SP_DEVINSTALL_PARAMS.FlagsEx 0x%08x. Set result: 0x%08x",
        *((_DWORD *)v1 + 34),
        v5);
    }
    if ( !SetupDiRestartDevices(DeviceInfoSet, &DeviceInfoData) )
      v9 = HrFromLastWin32Error();
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
  }
  if ( v9 < 0 )
    _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "!!! NCI: Error 0x%08x starting device", v9);
  return v9;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E665B5B) --------------------------------------------------------
__int32 __thiscall CComponent::HrOpenInfFile(CComponent *this, void **a2)
{
  CComponent *v2; // ebx@1
  void **v3; // esi@1
  DWORD Type; // [sp+10h] [bp-420h]@1
  HKEY hKey; // [sp+14h] [bp-41Ch]@1
  __int32 v7; // [sp+18h] [bp-418h]@1
  WCHAR pszDest; // [sp+1Ch] [bp-414h]@5
  WCHAR pszPath; // [sp+224h] [bp-20Ch]@3

  v2 = this;
  v3 = (void **)((char *)this + 20);
  *a2 = 0;
  v7 = 0;
  hKey = 0;
  Type = 520;
  if ( !*((_DWORD *)this + 5) )
  {
    v7 = CComponent::HrOpenInstanceKey(this, 0x20019u, &hKey, 0, 0);
    if ( !v7 )
    {
      v7 = HrRegQueryTypeSzBuffer(hKey, L"InfPath", 1u, (LPBYTE)&pszPath, (DWORD)&Type);
      if ( !v7 )
      {
        if ( !*((_DWORD *)v2 + 42)
          || !FGetFullShadowedPath(&pszDest, &pszPath)
          || (v7 = HrSetupOpenInfFile(&pszDest, 0, 2u, 0, v3)) != 0 )
          v7 = HrSetupOpenInfFile(&pszPath, 0, 2u, 0, v3);
      }
      RegSafeCloseKey(hKey);
    }
  }
  *a2 = *v3;
  return v7;
}

//----- (6E665C70) --------------------------------------------------------
int __stdcall FIsIscsiNicFromNdisNsi(struct _GUID a1)
{
  signed int v1; // esi@1
  NET_LUID InterfaceLuid; // [sp+8h] [bp-20h]@1
  int v4; // [sp+10h] [bp-18h]@1
  GUID InterfaceGuid; // [sp+14h] [bp-14h]@1

  InterfaceGuid = a1;
  v1 = 0;
  v4 = 0;
  if ( !ConvertInterfaceGuidToLuid(&InterfaceGuid, &InterfaceLuid)
    && !NsiGetParameter(1, NPI_MS_NDIS_MODULEID, 1, &InterfaceLuid, 8, 2, &v4, 4, 556)
    && v4 & 0x80 )
    v1 = 1;
  return v1;
}
// 6E65D840: using guessed type int NPI_MS_NDIS_MODULEID[6];
// 6E690FBB: using guessed type int __stdcall NsiGetParameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (6E665CE7) --------------------------------------------------------
int __stdcall FIsIsciSupportedProtocol(const unsigned __int16 *a1)
{
  signed int v1; // edi@1
  unsigned __int32 v2; // ecx@1
  void *lpMem; // [sp+8h] [bp-8h]@1
  HKEY hKey; // [sp+Ch] [bp-4h]@1

  v1 = 1;
  hKey = 0;
  lpMem = 0;
  if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Network", 0x20019u, &hKey)
    && !HrRegGetTypeWithAlloc(v2, hKey, L"IscsiSupportedProtocols", 1u, (unsigned __int8 **)&lpMem, 0)
    && !FSubstringMatch((const unsigned __int16 *)lpMem, a1, 0, 0) )
    v1 = 0;
  if ( hKey )
  {
    RegCloseKey(hKey);
    hKey = 0;
  }
  if ( lpMem )
    MemFree(lpMem);
  return v1;
}

//----- (6E665D9D) --------------------------------------------------------
unsigned __int32 __stdcall DeletePersistedInterface(unsigned __int16 a1, unsigned __int32 a2)
{
  DWORD v2; // esi@1
  HANDLE v3; // edi@1
  unsigned __int32 InBuffer; // [sp+8h] [bp-Ch]@3
  unsigned __int16 v6; // [sp+Ch] [bp-8h]@3
  DWORD BytesReturned; // [sp+10h] [bp-4h]@3

  v2 = 0;
  v3 = CreateFileW(L"\\\\.\\NDIS", 0xC0000000, 0, 0, 3u, 0, 0);
  if ( v3 )
  {
    InBuffer = a2;
    v6 = a1;
    if ( !DeviceIoControl(v3, 0x170050u, &InBuffer, 8u, 0, 0, &BytesReturned, 0) )
      v2 = GetLastError();
    CloseHandle(v3);
  }
  else
  {
    v2 = GetLastError();
  }
  return v2;
}

//----- (6E665E16) --------------------------------------------------------
unsigned __int32 __stdcall FreeNetLuidIndex(unsigned __int16 a1, unsigned __int32 a2)
{
  DWORD v2; // esi@1
  HANDLE v3; // edi@1
  unsigned __int32 InBuffer; // [sp+8h] [bp-Ch]@3
  unsigned __int16 v6; // [sp+Ch] [bp-8h]@3
  DWORD BytesReturned; // [sp+10h] [bp-4h]@3

  v2 = 0;
  v3 = CreateFileW(L"\\\\.\\NDIS", 0xC0000000, 0, 0, 3u, 0, 0);
  if ( v3 )
  {
    InBuffer = a2;
    v6 = a1;
    if ( !DeviceIoControl(v3, 0x170048u, &InBuffer, 8u, 0, 0, &BytesReturned, 0) )
      v2 = GetLastError();
    CloseHandle(v3);
  }
  else
  {
    v2 = GetLastError();
  }
  return v2;
}

//----- (6E665E8F) --------------------------------------------------------
int __stdcall SetInterfaceDelayedCleanup(unsigned __int16 a1, unsigned __int32 a2)
{
  __int64 v2; // rt0@1
  int v3; // eax@1
  int v4; // esi@2
  int v5; // eax@3
  __int64 v7; // [sp+Ch] [bp-14h]@1
  SP_LOG_TOKEN LogToken; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+1Ch] [bp-4h]@1
  int v10; // [sp+28h] [bp+8h]@1

  LogToken = SetupGetThreadLogToken();
  HIDWORD(v2) = a1 / 0x100u;
  LODWORD(v2) = (a1 << 24) | a2 & 0xFFFFFF;
  v7 = v2 << 24;
  v3 = NsiGetParameter(0, NPI_MS_NDIS_MODULEID, 10, &v7, 8, 0, &v9, 4, 1084);
  v10 = v3;
  if ( v3 )
  {
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: NsiGetParameter for Flags field failed with error code 0x%1x",
      v3);
    v4 = v10;
  }
  else
  {
    v9 |= 1u;
    v5 = NsiSetParameter(0, 0, NPI_MS_NDIS_MODULEID, 10, &v7, 8, 0, &v9, 4, 1084);
    v4 = v5;
    if ( v5 )
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: NsiSetParameter for Flags field failed with error code 0x%1x",
        v5);
  }
  return v4;
}
// 6E65D840: using guessed type int NPI_MS_NDIS_MODULEID[6];
// 6E690FBB: using guessed type int __stdcall NsiGetParameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6E690FC6: using guessed type int __stdcall NsiSetParameter(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E666007) --------------------------------------------------------
LSTATUS __stdcall DeleteConnectionRegistryKey(LPCWSTR pszSubKey)
{
  SP_LOG_TOKEN v1; // kr00_8@1
  LSTATUS v2; // esi@2
  LSTATUS v3; // eax@3
  HKEY phkResult; // [sp+Ch] [bp-4h]@1

  phkResult = 0;
  v1 = SetupGetThreadLogToken();
  if ( pszSubKey )
  {
    v3 = RegOpenKeyExW(
           HKEY_LOCAL_MACHINE,
           L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}",
           0,
           2u,
           &phkResult);
    v2 = v3;
    if ( v3 )
      _SetupWriteTextLog(
        v1,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!NCI: RegOpenKeyEx failed with error code 0x%lx",
        v3);
    else
      v2 = SHDeleteKeyW(phkResult, pszSubKey);
  }
  else
  {
    v2 = 87;
  }
  if ( phkResult )
    RegCloseKey(phkResult);
  return v2;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6660C9) --------------------------------------------------------
signed int StringCchPrintfW(wchar_t *Dest, unsigned int a2, wchar_t *Format, ...)
{
  signed int result; // eax@1
  unsigned int v4; // esi@5
  signed int v5; // ebx@5
  int v6; // eax@5
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, Format);
  result = 0;
  if ( !a2 || a2 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = a2 - 1;
    v5 = 0;
    v6 = _vsnwprintf(Dest, a2 - 1, Format, va);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147024774;
    }
    else if ( v6 != v4 )
    {
      goto LABEL_11;
    }
    Dest[v4] = 0;
LABEL_11:
    result = v5;
  }
  return result;
}

//----- (6E666127) --------------------------------------------------------
__int32 __stdcall HrGetTempKeyPathFromPnPInstanceID(STRSAFE_LPWSTR pszDest, size_t cchDest, const unsigned __int16 *a3)
{
  __int32 result; // eax@1
  wchar_t pszSrc; // [sp+8h] [bp-20Ch]@1
  char Dst; // [sp+Ah] [bp-20Ah]@1

  pszSrc = 0;
  memset(&Dst, 0, 0x206u);
  result = HrPnpIdToRegKeyName(&pszSrc, 0x104u, a3);
  if ( !result )
  {
    result = StringCchCopyW(pszDest, cchDest, L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\");
    if ( !result )
      result = StringCchCatW(pszDest, cchDest, &pszSrc);
  }
  return result;
}

//----- (6E6661AF) --------------------------------------------------------
void __stdcall StoreExternalResourceInfoInTempRegLocation(HKEY a1, const unsigned __int16 *a2)
{
  SP_LOG_TOKEN v2; // rax@1
  unsigned int v3; // ebx@1
  unsigned __int32 v4; // ecx@10
  DWORD v5; // [sp+Ch] [bp-22Ch]@10
  DWORD Type; // [sp+10h] [bp-228h]@8
  unsigned __int16 *v7; // [sp+14h] [bp-224h]@1
  unsigned int v8; // [sp+1Ch] [bp-21Ch]@1
  HKEY v9; // [sp+20h] [bp-218h]@1
  void *lpMem; // [sp+24h] [bp-214h]@1
  HKEY hKey; // [sp+28h] [bp-210h]@1
  WCHAR SubKey; // [sp+2Ch] [bp-20Ch]@1
  char Dst; // [sp+2Eh] [bp-20Ah]@1

  hKey = 0;
  lpMem = 0;
  v9 = a1;
  v7 = (unsigned __int16 *)a2;
  SubKey = 0;
  memset(&Dst, 0, 0x206u);
  v2 = SetupGetThreadLogToken();
  v8 = HIDWORD(v2);
  v3 = v2;
  if ( a1 && a2 )
  {
    _SetupWriteTextLog(v2, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI: BEGIN STORE EXTERNAL RESOURCE INFO]");
    StoreInfoForINetCfg(v9, v7);
    if ( HrGetTempKeyPathFromPnPInstanceID(&SubKey, 0x104u, v7) )
    {
      _SetupWriteTextLog(
        __PAIR__(v8, v3),
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!!!NCI: Failed to create temp key path during component remove");
    }
    else if ( HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20006u, 0, &hKey, 0) )
    {
      _SetupWriteTextLog(
        __PAIR__(v8, v3),
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!!!NCI: Failed to create temp reg key during remove");
    }
    else
    {
      if ( !HrRegQueryDword(v9, L"*IfType", (DWORD)&Type) )
      {
        _SetupWriteTextLog(__PAIR__(v8, v3), 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: IfType=%d", Type);
        HrRegSetDword(hKey, L"*IfType", Type);
      }
      if ( !HrRegQueryDword(v9, L"NetLuidIndex", (DWORD)&v5) )
      {
        _SetupWriteTextLog(__PAIR__(v8, v3), 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: NetLuidIndex=%d", v5);
        HrRegSetDword(hKey, L"NetLuidIndex", v5);
      }
      if ( !HrRegGetTypeWithAlloc(v4, v9, L"NetCfgInstanceId", 1u, (unsigned __int8 **)&lpMem, 0) )
      {
        _SetupWriteTextLog(
          __PAIR__(v8, v3),
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: NetcfgInstanceId(GUID)=%ws",
          lpMem);
        HrRegSetSz(hKey, L"NetCfgInstanceId", (BYTE *)lpMem);
        MemFree(lpMem);
      }
      RegCloseKey(hKey);
      _SetupWriteTextLog(
        __PAIR__(v8, v3),
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "[NCI: END STORE EXTERNAL RESOURCE INFO]");
    }
  }
  else
  {
    _SetupWriteTextLog(
      v2,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!!NCI: StoreNdisManagedDataInTempRegistryLocation, missing InstanceKey or pszPnpID");
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66653F) --------------------------------------------------------
void __stdcall SetDelayedCleanupFlagEnumCompRemoval(const unsigned __int16 *a1, int Data)
{
  SP_LOG_TOKEN v2; // kr00_8@1
  __int32 v3; // eax@1
  __int32 v4; // eax@4
  __int32 v5; // eax@6
  HKEY hKey; // [sp+Ch] [bp-210h]@1
  WCHAR SubKey; // [sp+10h] [bp-20Ch]@1
  char Dst; // [sp+12h] [bp-20Ah]@1

  hKey = 0;
  SubKey = 0;
  memset(&Dst, 0, 0x206u);
  v2 = SetupGetThreadLogToken();
  v3 = HrGetTempKeyPathFromPnPInstanceID(&SubKey, 0x104u, a1);
  if ( v3 )
  {
    _SetupWriteTextLog(
      v2,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!!NCI: Failed to create temp key path for %ws, Hr=%08x",
      a1,
      v3);
  }
  else
  {
    v4 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0x20006u, &hKey);
    if ( v4 )
    {
      _SetupWriteTextLog(
        v2,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!!!NCI: Failed to open temp reg key for %ws, Hr = %08x",
        a1,
        v4);
    }
    else
    {
      v5 = HrRegSetBool(hKey, L"DelayedCleanup", Data);
      if ( v5 )
        _SetupWriteTextLog(
          v2,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "!!!NCI: Failed to store delayed cleanup flag=%08x for %ws, Hr = %08x",
          Data,
          a1,
          v5);
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E666715) --------------------------------------------------------
void __stdcall TestAndSetDelayedCleanup(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, const unsigned __int16 *a3)
{
  DWORD v3; // eax@2
  int v4; // eax@4
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-23Ch]@1
  int Data; // [sp+14h] [bp-234h]@1
  int Dst; // [sp+18h] [bp-230h]@1
  int v8; // [sp+1Ch] [bp-22Ch]@3

  Data = 0;
  LogToken = SetupGetThreadLogToken();
  memset(&Dst, 0, 0x22Cu);
  Dst = 556;
  if ( SetupDiGetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, (PSP_DEVINSTALL_PARAMS_W)&Dst) )
  {
    if ( v8 & 0x20180 )
    {
      Data = 1;
      v4 = (int)L"Required.";
    }
    else
    {
      v4 = (int)L"not required.";
    }
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI:Delayed Cleanup %ws. DevInstallParams.Flags=0x%08x",
      v4,
      v8);
    SetDelayedCleanupFlagEnumCompRemoval(a3, Data);
  }
  else
  {
    v3 = GetLastError();
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!NCI: TestAndSetDelayedCleanup failed with error code 0x%lx",
      v3);
  }
}
// 6E66686C: using guessed type wchar_t aNotRequired_[14];
// 6E666888: using guessed type wchar_t aRequired_[10];
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6668DD) --------------------------------------------------------
unsigned __int32 __stdcall SetConnectionNameDelayedCleanup(LPCWSTR pszSubKey)
{
  LSTATUS v1; // eax@5
  unsigned __int32 v2; // ecx@9
  LSTATUS v3; // eax@13
  DWORD v5; // [sp+8h] [bp-228h]@2
  DWORD Type; // [sp+Ch] [bp-224h]@1
  DWORD v7; // [sp+10h] [bp-220h]@1
  void *lpMem; // [sp+14h] [bp-21Ch]@1
  SP_LOG_TOKEN LogToken; // [sp+18h] [bp-218h]@1
  HKEY phkResult; // [sp+20h] [bp-210h]@1
  WCHAR SubKey; // [sp+24h] [bp-20Ch]@1
  char Dst; // [sp+26h] [bp-20Ah]@1

  SubKey = 0;
  lpMem = 0;
  memset(&Dst, 0, 0x206u);
  v7 = -1;
  Type = -1;
  phkResult = 0;
  LogToken = SetupGetThreadLogToken();
  if ( pszSubKey )
  {
    if ( StringCchPrintfW(
           &SubKey,
           0x104u,
           L"%ws\\%ws%ws",
           L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}",
           pszSubKey,
           L"\\Connection") )
    {
      v5 = GetLastError();
    }
    else
    {
      v1 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20019u, &phkResult);
      v5 = v1;
      if ( v1 )
      {
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "!NCI: RegOpenKeyEx failed with error code 0x%lx for key %ws",
          v1,
          &SubKey);
      }
      else
      {
        if ( HrRegQueryDword(phkResult, L"DefaultNameIndex", (DWORD)&Type) )
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "!NCI: AdapterGuid %ws does not have Default Index",
            pszSubKey);
        if ( HrRegQueryDword(phkResult, L"DefaultNameResourceId", (DWORD)&v7) )
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "!NCI: AdapterGuid %ws does not have DefaultName Resource Idenetifier",
            pszSubKey);
        if ( HrRegGetTypeWithAlloc(v2, phkResult, L"Name", 1u, (unsigned __int8 **)&lpMem, 0) )
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "!NCI: AdapterGuid %ws does not have Connection Name",
            pszSubKey);
        RegCloseKey(phkResult);
        phkResult = 0;
        v3 = DeleteConnectionRegistryKey(pszSubKey);
        v5 = v3;
        if ( v3 )
        {
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "!NCI: Failed to delete Connection Registry key. Error:0x%08x",
            v3);
        }
        else if ( HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 1u, 0x20006u, 0, &phkResult, 0) )
        {
          _SetupWriteTextLog(
            LogToken,
            0x40000000u,
            5 - (g_IsInUpgrade != 0),
            "!NCI: Delayed Cleanup, failed to create volatile Connection key. Error:0x%lx",
            0);
        }
        else
        {
          if ( Type != -1 && HrRegSetDword(phkResult, L"DefaultNameIndex", Type) )
            _SetupWriteTextLog(
              LogToken,
              0x40000000u,
              5 - (g_IsInUpgrade != 0),
              "!NCI: Delayed Cleanup, failed to store default index=%08X. Error:0x%lx",
              Type,
              0);
          if ( v7 != -1 && HrRegSetDword(phkResult, L"DefaultNameResourceId", v7) )
            _SetupWriteTextLog(
              LogToken,
              0x40000000u,
              5 - (g_IsInUpgrade != 0),
              "!NCI: Delayed Cleanup, failed to store default identifier=%08X. Error:0x%lx",
              v7,
              0);
          if ( lpMem )
          {
            if ( HrRegSetSz(phkResult, L"Name", (BYTE *)lpMem) )
              _SetupWriteTextLog(
                LogToken,
                0x40000000u,
                5 - (g_IsInUpgrade != 0),
                "!NCI: Delayed Cleanup, failed to store Connectin Name =%ws. Error:0x%lx",
                lpMem,
                0);
            MemFree(lpMem);
          }
          RegCloseKey(phkResult);
        }
      }
    }
  }
  else
  {
    v5 = 87;
  }
  return v5;
}
// 6E666C58: using guessed type wchar_t aConnection_0[12];
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E666F4D) --------------------------------------------------------
void __stdcall ReleaseExternallyManagedResources(const unsigned __int16 *a1)
{
  SP_LOG_TOKEN v1; // kr00_8@1
  unsigned __int32 v2; // ecx@10
  int v3; // eax@14
  unsigned __int32 v4; // eax@20
  int v5; // eax@23
  int v6; // ecx@29
  LSTATUS v7; // eax@37
  unsigned __int32 v8; // eax@40
  const CHAR *v9; // [sp-Ch] [bp-250h]@22
  DWORD v10; // [sp-8h] [bp-24Ch]@20
  const CHAR *v11; // [sp-8h] [bp-24Ch]@39
  const CHAR *v12; // [sp-4h] [bp-248h]@2
  DWORD v13; // [sp-4h] [bp-248h]@20
  void *v14; // [sp-4h] [bp-248h]@37
  signed int v15; // [sp+Ch] [bp-238h]@1
  signed int v16; // [sp+10h] [bp-234h]@1
  signed int v17; // [sp+14h] [bp-230h]@1
  DWORD Type; // [sp+18h] [bp-22Ch]@1
  unsigned __int16 *v19; // [sp+1Ch] [bp-228h]@1
  HKEY hKey; // [sp+20h] [bp-224h]@1
  unsigned int v21; // [sp+28h] [bp-21Ch]@1
  void *lpMem; // [sp+2Ch] [bp-218h]@1
  DWORD v23; // [sp+30h] [bp-214h]@10
  DWORD v24; // [sp+34h] [bp-210h]@8
  WCHAR SubKey; // [sp+38h] [bp-20Ch]@1
  char Dst; // [sp+3Ah] [bp-20Ah]@1

  v19 = (unsigned __int16 *)a1;
  SubKey = 0;
  hKey = 0;
  lpMem = 0;
  memset(&Dst, 0, 0x206u);
  Type = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v1 = SetupGetThreadLogToken();
  v21 = HIDWORD(v1);
  _SetupWriteTextLog(v1, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI: BEGIN Release Externally Managed Resources]");
  if ( HrGetTempKeyPathFromPnPInstanceID(&SubKey, 0x104u, a1) )
  {
    v12 = "!!!NCI: Failed to create temp key path in ReleaseExternallyManagedResources";
LABEL_3:
    _SetupWriteTextLog(__PAIR__(v21, (unsigned int)v1), 0x40000000u, 1u, v12);
    return;
  }
  if ( HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0x20019u, &hKey) )
  {
    v12 = "!!!NCI: Failed to open temp reg key in ReleaseExternallyManagedResources";
    goto LABEL_3;
  }
  if ( HrRegQueryDword(hKey, L"DelayedCleanup", (DWORD)&Type) )
  {
    _SetupWriteTextLog(
      __PAIR__(v21, (unsigned int)v1),
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Delayed Cleanup Flag Not set for PnpID=%ws in ReleaseExternallyManagedResources",
      v19);
    Type = 0;
  }
  if ( !HrRegQueryDword(hKey, L"*IfType", (DWORD)&v24) )
  {
    v17 = 1;
    _SetupWriteTextLog(__PAIR__(v21, (unsigned int)v1), 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: IfType=%d", v24);
  }
  if ( !HrRegQueryDword(hKey, L"NetLuidIndex", (DWORD)&v23) )
  {
    v16 = 1;
    _SetupWriteTextLog(
      __PAIR__(v21, (unsigned int)v1),
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: NetLuidIndex=%d",
      v23);
  }
  if ( !HrRegGetTypeWithAlloc(v2, hKey, L"NetCfgInstanceId", 1u, (unsigned __int8 **)&lpMem, 0) )
  {
    v15 = 1;
    _SetupWriteTextLog(
      __PAIR__(v21, (unsigned int)v1),
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: NetcfgInstanceId(GUID)=%ws",
      lpMem);
  }
  v3 = (int)L"NOT Present";
  if ( !v17 )
  {
    if ( v16 )
    {
      v6 = (int)L"Present";
LABEL_32:
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        2u,
        "!NCI: IfType %ws, NetLuidIndex %ws. pszPnpID= %ws",
        v3,
        v6,
        v19);
      goto LABEL_33;
    }
LABEL_30:
    v6 = (int)L"NOT Present";
    if ( v17 )
      v3 = (int)L"Present";
    goto LABEL_32;
  }
  if ( !v16 )
    goto LABEL_30;
  if ( Type )
  {
    v5 = SetInterfaceDelayedCleanup(v24, v23);
    v13 = v23;
    v10 = v24;
    if ( !v5 )
    {
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: Set Delayed Cleanup flag; IfType=%08X, NetLuidIndex=%08X",
        v24,
        v23);
      goto LABEL_33;
    }
    v9 = "!NCI: Failed set Delayed Cleanup Flag; IfType=%08X, NetLuidIndex=%08X";
  }
  else
  {
    if ( DeletePersistedInterface(v24, v23) )
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        1u,
        "!NCI: Failed to delete persisted NSI Interface; IfType=%08X, NetLuidIndex=%08X",
        v24,
        v23);
    else
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        4u,
        "NCI: Deleted persisted NSI Interface; IfType=%08X, NetLuidIndex=%08X",
        v24,
        v23);
    v4 = FreeNetLuidIndex(v24, v23);
    v13 = v23;
    v10 = v24;
    if ( !v4 )
    {
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        4u,
        "NCI: Freed NetLuidIndex; IfType=%08X, NetLuidIndex=%08X",
        v24,
        v23);
      goto LABEL_33;
    }
    v9 = "!NCI: Failed to free NetLuidIndex; IfType=%08X, NetLuidIndex=%08X";
  }
  _SetupWriteTextLog(__PAIR__(v21, (unsigned int)v1), 0x40000000u, 1u, v9, v10, v13);
LABEL_33:
  if ( v15 )
  {
    if ( WaitForConnectionNameMutex() )
    {
      _SetupWriteTextLog(
        __PAIR__(v21, (unsigned int)v1),
        0x40000000u,
        1u,
        "!NCI: Failed to wait for ConnectionNameMutex");
LABEL_44:
      MemFree(lpMem);
      goto LABEL_45;
    }
    if ( Type )
    {
      v8 = SetConnectionNameDelayedCleanup((LPCWSTR)lpMem);
      v14 = lpMem;
      if ( v8 )
        goto LABEL_38;
      v11 = "NCI: Successfully Set Delayed Connection Registry Key Cleanup for GUID=%ws";
    }
    else
    {
      v7 = DeleteConnectionRegistryKey((LPCWSTR)lpMem);
      v14 = lpMem;
      if ( v7 )
      {
LABEL_38:
        _SetupWriteTextLog(
          __PAIR__(v21, (unsigned int)v1),
          0x40000000u,
          1u,
          "!NCI: Failed to delete Connection Name Registry Key for GUID= %ws ",
          v14);
LABEL_43:
        ReleaseConnectionNameMutex();
        goto LABEL_44;
      }
      v11 = "NCI: Successfully deleted Connection Registry Key for GUID=%ws";
    }
    _SetupWriteTextLog(__PAIR__(v21, (unsigned int)v1), 0x40000000u, 4u, v11, v14);
    goto LABEL_43;
  }
LABEL_45:
  RegCloseKey(hKey);
  FreeInfoStoredForInetCfg(v19);
  _SetupWriteTextLog(
    __PAIR__(v21, (unsigned int)v1),
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "[NCI: END Release Externally Managed Resources]");
}
// 6E6674B0: using guessed type wchar_t aPresent[8];
// 6E667660: using guessed type wchar_t aNotPresent[12];
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6677A3) --------------------------------------------------------
unsigned __int32 __stdcall EInterfaceTypeFromDword(unsigned __int32 a1)
{
  unsigned __int32 result; // eax@1

  result = a1;
  if ( a1 >= 0x11 )
    result = -1;
  return result;
}

//----- (6E6677BC) --------------------------------------------------------
__int32 __stdcall HrCiGetBusInfoFromInf(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue)
{
  struct COMPONENT_INSTALL_INFO *v2; // esi@1
  __int32 v3; // edi@1

  v2 = IntegerValue;
  v3 = 0;
  if ( *((_DWORD *)IntegerValue + 16) == -1 )
  {
    v3 = HrSetupGetFirstDword(InfHandle, *((PCWSTR *)IntegerValue + 10), L"BusType", (unsigned __int32 *)&IntegerValue);
    if ( !v3 )
      *((_DWORD *)v2 + 16) = EInterfaceTypeFromDword((unsigned __int32)IntegerValue);
  }
  return v3;
}

//----- (6E667800) --------------------------------------------------------
HINF __stdcall HrCiInstallEnumeratedComponent(HINF InfHandle, HKEY a2, const struct COMPONENT_INSTALL_INFO *IntegerValue)
{
  const struct COMPONENT_INSTALL_INFO *v3; // esi@1
  const WCHAR *v4; // ST14_4@2
  signed int v5; // ebx@3
  struct _SP_DEVINFO_DATA *v6; // ST08_4@6
  unsigned int v7; // eax@8
  SP_LOG_TOKEN v8; // rax@14
  void *v9; // eax@16
  bool v10; // zf@16
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-Ch]@14
  int LogToken_4; // [sp+10h] [bp-8h]@11
  HKEY hKey; // [sp+14h] [bp-4h]@11

  v3 = IntegerValue;
  CiSetFriendlyNameIfNeeded(IntegerValue);
  if ( *((_DWORD *)v3 + 16) == 5 )
  {
    v4 = (const WCHAR *)*((_DWORD *)v3 + 10);
    IntegerValue = 0;
    if ( HrSetupGetFirstDword(InfHandle, v4, L"Port1DeviceNumber", (unsigned __int32 *)&IntegerValue) )
    {
      if ( HrSetupGetFirstDword(
             InfHandle,
             *((PCWSTR *)v3 + 10),
             L"Port1FunctionNumber",
             (unsigned __int32 *)&IntegerValue) )
        goto LABEL_14;
      v5 = 0;
    }
    else
    {
      v5 = 1;
    }
    v6 = (struct _SP_DEVINFO_DATA *)*((_DWORD *)v3 + 15);
    InfHandle = 0;
    if ( !HrSetupDiGetDeviceRegistryProperty(*((HDEVINFO *)v3 + 14), v6, 0x1Cu, 0, (PBYTE)&InfHandle, 4u, 0) )
    {
      if ( v5 )
        v7 = (unsigned int)InfHandle >> 16;
      else
        LOWORD(v7) = (_WORD)InfHandle;
      v7 = (unsigned __int16)v7;
      if ( (unsigned __int16)v7 >= (unsigned int)IntegerValue )
      {
        LogToken_4 = v7 - (_DWORD)IntegerValue + 1;
        if ( !HrSetupDiCreateDevRegKey(*((HDEVINFO *)v3 + 14), *((PSP_DEVINFO_DATA *)v3 + 15), 1u, 0, 1u, 0, 0, &hKey) )
        {
          HrRegSetDword(hKey, L"Port", LogToken_4);
          RegCloseKey(hKey);
        }
        HrRegSetDword(a2, L"Port", LogToken_4);
      }
    }
  }
LABEL_14:
  UpdateAdvancedParametersIfNeeded(*((void **)v3 + 14), *((struct _SP_DEVINFO_DATA **)v3 + 15));
  v8 = SetupGetThreadLogToken();
  LogToken = v8;
  if ( !*((_DWORD *)v3 + 8) )
  {
    _SetupWriteTextLog(
      v8,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Fresh install of device. DI_DONOTCALLCONFIGMG flag set. Device will be started after bindings");
    HrSetupDiSetDeipFlags(*((HDEVINFO *)v3 + 14), *((struct _SP_DEVINFO_DATA **)v3 + 15), 0x20000, 0, 1);
  }
  v9 = (void *)HrSetupDiInstallDevice(*((HDEVINFO *)v3 + 14), *((PSP_DEVINFO_DATA *)v3 + 15));
  v10 = *((_DWORD *)v3 + 8) == 0;
  InfHandle = v9;
  if ( v10 )
  {
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Device installed. Clearing DI_DONOTCALLCONFIGMG flag.");
    HrSetupDiSetDeipFlags(*((HDEVINFO *)v3 + 14), *((struct _SP_DEVINFO_DATA **)v3 + 15), 0x20000, 0, 2);
  }
  return InfHandle;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E667A79) --------------------------------------------------------
void __stdcall AddOrRemoveLegacyNt4AdapterKey(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData, GUID *a3, BYTE *a4, int a5)
{
  wchar_t *v5; // eax@2
  const wchar_t *v6; // eax@3
  unsigned __int32 v7; // esi@4
  unsigned int v8; // eax@7
  DWORD dwDisposition; // [sp+8h] [bp-B8h]@4
  wchar_t *EndPtr; // [sp+Ch] [bp-B4h]@4
  GUID *rguid; // [sp+10h] [bp-B0h]@1
  BYTE *lpData; // [sp+14h] [bp-ACh]@1
  wchar_t *Str; // [sp+18h] [bp-A8h]@1
  HKEY phkResult; // [sp+1Ch] [bp-A4h]@4
  HKEY hKey; // [sp+20h] [bp-A0h]@6
  OLECHAR sz; // [sp+24h] [bp-9Ch]@7
  WCHAR ValueName; // [sp+74h] [bp-4Ch]@1
  WCHAR v18; // [sp+8Ch] [bp-34h]@1
  WCHAR SubKey; // [sp+A4h] [bp-1Ch]@5

  rguid = a3;
  lpData = a4;
  qmemcpy(&v18, L"Description", 0x18u);
  qmemcpy(&ValueName, L"ServiceName", 0x18u);
  if ( !HrSetupDiGetDeviceRegistryPropertyWithAlloc(DeviceInfoSet, DeviceInfoData, 9u, 0, (DWORD)&Str) )
  {
    v5 = wcsrchr(Str, 0x5Cu);
    if ( v5 )
    {
      v6 = v5 + 1;
      if ( *v6 )
      {
        v7 = wcstoul(v6, &EndPtr, 10) + 1;
        if ( !HrRegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards",
                0,
                0x20006u,
                0,
                &phkResult,
                &dwDisposition) )
        {
          StringCchPrintfW(&SubKey, 0xCu, L"%d", v7);
          if ( a5 )
          {
            HrRegDeleteKey(phkResult, &SubKey);
          }
          else if ( !HrRegCreateKeyEx(phkResult, &SubKey, 0, 0x20006u, 0, &hKey, 0) )
          {
            StringFromGUID2(rguid, &sz, 39);
            HrRegSetValueEx(hKey, &ValueName, 1u, (BYTE *)&sz, 0x4Eu);
            v8 = CbOfSzAndTerm((const unsigned __int16 *)lpData);
            HrRegSetValueEx(hKey, &v18, 1u, lpData, v8);
            RegCloseKey(hKey);
          }
          RegCloseKey(phkResult);
        }
      }
    }
    operator delete(Str);
  }
}
// 6E667C10: using guessed type wchar_t aServicename[12];

//----- (6E667CA1) --------------------------------------------------------
unsigned int __stdcall GetNextStringToken(unsigned __int16 *a1, const unsigned __int16 *a2, unsigned __int16 **a3)
{
  unsigned __int16 *v3; // ecx@1
  unsigned __int16 i; // ax@3
  const unsigned __int16 *v5; // esi@4
  const unsigned __int16 v6; // dx@5
  const unsigned __int16 *v7; // edx@11
  const unsigned __int16 v8; // ax@12
  unsigned __int16 *v10; // [sp+8h] [bp+8h]@10

  v3 = a1;
  if ( !a1 )
    v3 = *a3;
  for ( i = *v3; *v3; i = *v3 )
  {
    v5 = a2;
    if ( *a2 )
    {
      v6 = *a2;
      do
      {
        if ( v6 == i )
          break;
        ++v5;
        v6 = *v5;
      }
      while ( *v5 );
    }
    if ( !*v5 )
      break;
    ++v3;
  }
  v10 = v3;
  if ( *v3 )
  {
    while ( 1 )
    {
      v7 = a2;
      if ( *a2 )
      {
        v8 = *a2;
        do
        {
          if ( v8 == *v3 )
            break;
          ++v7;
          v8 = *v7;
        }
        while ( *v7 );
      }
      if ( *v7 )
        break;
      ++v3;
      if ( !*v3 )
        goto LABEL_19;
    }
    *v3 = 0;
    ++v3;
  }
LABEL_19:
  *a3 = v3;
  return v10 != v3 ? (unsigned int)v10 : 0;
}

//----- (6E667D4B) --------------------------------------------------------
void __stdcall SignalNetworkProviderLoaded()
{
  NTSTATUS v0; // eax@1
  DWORD v1; // eax@3
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-24h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+18h] [bp-Ch]@1
  HANDLE EventHandle; // [sp+20h] [bp-4h]@1

  RtlInitUnicodeString(&DestinationString, L"\\Security\\NetworkProviderLoad");
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  v0 = NtOpenEvent(&EventHandle, 0x100003u, &ObjectAttributes);
  if ( v0 < 0 )
  {
    v1 = RtlNtStatusToDosError(v0);
    SetLastError(v1);
  }
  else
  {
    SetEvent(EventHandle);
    CloseHandle(EventHandle);
  }
}

//----- (6E667E01) --------------------------------------------------------
int __stdcall FIsFilterDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  signed int v2; // esi@1
  DWORD Type; // [sp+4h] [bp-214h]@2
  HKEY hKey; // [sp+8h] [bp-210h]@1
  BYTE Data; // [sp+Ch] [bp-20Ch]@2

  v2 = 0;
  if ( !HrSetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, 1u, 0, 2u, 0x20019u, &hKey) )
  {
    Type = 520;
    if ( !HrRegQueryTypeSzBuffer(hKey, L"FilterInfId", 1u, &Data, (DWORD)&Type) )
      v2 = 1;
    RegCloseKey(hKey);
  }
  return v2;
}

//----- (6E667E8C) --------------------------------------------------------
unsigned __int32 __stdcall WaitForConnectionNameMutex()
{
  DWORD v0; // eax@7
  MSG Msg; // [sp+8h] [bp-28h]@5
  SP_LOG_TOKEN LogToken; // [sp+24h] [bp-Ch]@1
  DWORD v4; // [sp+2Ch] [bp-4h]@3

  LogToken = SetupGetThreadLogToken();
  if ( g_ConnectionNameMutex
    || (HrCreateMutexWithWorldAccess(L"Global\\3a886eb8-fe40-4d0a-b78b-9e0bcb683fb7", 0, 0, &g_ConnectionNameMutex),
        g_ConnectionNameMutex) )
  {
    while ( 1 )
    {
      v0 = MsgWaitForMultipleObjects(1u, &g_ConnectionNameMutex, 0, 0x7530u, 0x4FFu);
      v4 = v0;
      if ( v0 != 1 )
        break;
      while ( PeekMessageW(&Msg, 0, 0, 0, 1u) )
        DispatchMessageW(&Msg);
    }
    if ( v0 == 258 )
    {
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: Wait for ConnectionName Mutex timed out");
    }
    else if ( v4 == -1 )
    {
      v4 = GetLastError();
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "!NCI: Wait for ConnectionName Mutex failed with error %08x",
        v4);
    }
  }
  else
  {
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!!NCI: Failed to create ConnectionName Mutex in WaitForConnectionNameMutex");
    v4 = GetLastError();
  }
  return v4;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6680C9) --------------------------------------------------------
void __stdcall ReleaseConnectionNameMutex()
{
  if ( g_ConnectionNameMutex )
    ReleaseMutex(g_ConnectionNameMutex);
}

//----- (6E6680DF) --------------------------------------------------------
signed int __stdcall HrPnpIdToRegKeyName(unsigned __int16 *a1, unsigned __int32 a2, const unsigned __int16 *a3)
{
  signed int result; // eax@1
  unsigned int v4; // edi@2

  result = StringCchCopyW(a1, a2, a3);
  if ( !result )
  {
    v4 = 0;
    if ( wcslen(a1) )
    {
      do
      {
        if ( 92 == a1[v4] )
          a1[v4] = 95;
        ++v4;
      }
      while ( v4 < wcslen(a1) );
    }
  }
  return result;
}

//----- (6E668145) --------------------------------------------------------
void __stdcall StoreInfoForINetCfg(HKEY a1, const unsigned __int16 *a2)
{
  unsigned __int32 v2; // ecx@8
  unsigned __int32 v3; // ecx@14
  unsigned __int32 v4; // ecx@15
  void *lpMem; // [sp+10h] [bp-430h]@1
  BYTE *lpData; // [sp+14h] [bp-42Ch]@1
  BYTE *v7; // [sp+18h] [bp-428h]@1
  HKEY hKey; // [sp+1Ch] [bp-424h]@1
  HKEY phkResult; // [sp+20h] [bp-420h]@1
  HKEY v10; // [sp+24h] [bp-41Ch]@1
  HKEY v11; // [sp+28h] [bp-418h]@1
  wchar_t pszSrc; // [sp+2Ch] [bp-414h]@1
  char Dst; // [sp+2Eh] [bp-412h]@1
  wchar_t pszDest; // [sp+234h] [bp-20Ch]@1
  char v15; // [sp+236h] [bp-20Ah]@1

  pszSrc = 0;
  memset(&Dst, 0, 0x206u);
  pszDest = 0;
  memset(&v15, 0, 0x206u);
  hKey = 0;
  v10 = 0;
  phkResult = 0;
  v11 = 0;
  lpMem = 0;
  lpData = 0;
  v7 = 0;
  if ( !StringCchCopyW(&pszDest, 0x104u, L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\")
    && !HrPnpIdToRegKeyName(&pszSrc, 0x104u, a2)
    && !StringCchCatW(&pszDest, 0x104u, &pszSrc)
    && !StringCchCatW(&pszDest, 0x104u, L"\\Ndi")
    && !HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0, 0x20006u, 0, &v10, 0) )
    HrRegCreateKeyEx(v10, L"Interfaces", 0, 0x20006u, 0, &v11, 0);
  if ( v10 )
  {
    if ( !HrRegOpenKeyEx(a1, L"Ndi", 0x20019u, &hKey) )
    {
      if ( !HrRegGetTypeWithAlloc(v2, hKey, L"RequiredAll", 1u, (unsigned __int8 **)&lpMem, 0) )
      {
        HrRegSetSz(v10, L"RequiredAll", (BYTE *)lpMem);
        MemFree(lpMem);
      }
      RegCloseKey(hKey);
    }
    RegSafeCloseKey(v10);
  }
  if ( v11 )
  {
    if ( !HrRegOpenKeyEx(a1, L"Ndi\\Interfaces", 0x20019u, &phkResult) )
    {
      if ( !HrRegGetTypeWithAlloc(v3, phkResult, L"UpperRange", 1u, &lpData, 0) )
      {
        HrRegSetSz(v11, L"UpperRange", lpData);
        MemFree(lpData);
      }
      if ( !HrRegGetTypeWithAlloc(v4, phkResult, L"LowerRange", 1u, &v7, 0) )
      {
        HrRegSetSz(v11, L"LowerRange", v7);
        MemFree(v7);
      }
      RegCloseKey(phkResult);
    }
    RegSafeCloseKey(v11);
  }
}

//----- (6E6683DB) --------------------------------------------------------
void __stdcall FreeInfoStoredForInetCfg(const unsigned __int16 *a1)
{
  HKEY hKey; // [sp+4h] [bp-210h]@1
  WCHAR v2; // [sp+8h] [bp-20Ch]@1
  char Dst; // [sp+Ah] [bp-20Ah]@1

  v2 = 0;
  memset(&Dst, 0, 0x206u);
  hKey = 0;
  if ( !HrRegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\",
          0x20006u,
          &hKey) )
  {
    if ( !HrPnpIdToRegKeyName(&v2, 0x104u, a1) )
      HrRegDeleteKeyTree(hKey, &v2);
    RegCloseKey(hKey);
  }
}

//----- (6E6684A6) --------------------------------------------------------
void *__cdecl std::char_traits<unsigned short>::_Move_s(void *Dst, int a2, void *Src, int a4)
{
  wmemmove_s(Dst, a2, Src, a4);
  return Dst;
}

//----- (6E6684C9) --------------------------------------------------------
signed int __fastcall sub_6E6684C9(unsigned int a1, int a2, unsigned int a3)
{
  signed int result; // eax@1

  result = 0;
  if ( !a1 || a1 > a3 )
    result = -2147024809;
  return result;
}

//----- (6E6684E7) --------------------------------------------------------
signed int __userpurge sub_6E6684E7@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3, unsigned int a4)
{
  int v4; // edi@1
  signed int result; // eax@1
  int v6; // edx@1

  v4 = a1;
  result = sub_6E6684C9(a2, a2, a4);
  if ( result < 0 )
    *(_DWORD *)v4 = 0;
  else
    result = sub_6E64AC25(a3, v6, v4);
  return result;
}

//----- (6E668514) --------------------------------------------------------
__int32 __stdcall HrRegisterComObject(const unsigned __int16 *a1)
{
  return HrRegisterOrUnregisterComObject(a1, 0);
}

//----- (6E668544) --------------------------------------------------------
__int32 __stdcall HrRegSetSzAsUlong(HKEY hKey, LPCWSTR lpValueName, unsigned __int32 Value, int Radix)
{
  wchar_t Dest; // [sp+8h] [bp-48h]@1

  _ultow(Value, &Dest, Radix);
  return HrRegSetSz(hKey, lpValueName, (BYTE *)&Dest);
}

//----- (6E668590) --------------------------------------------------------
HICON __stdcall BeginWaitCursor()
{
  HCURSOR v0; // eax@1

  v0 = LoadCursorW(0, (LPCWSTR)0x7F02);
  return SetCursor(v0);
}

//----- (6E6685AA) --------------------------------------------------------
void __stdcall EndWaitCursor(HICON hInstance)
{
  HICON v1; // eax@1

  v1 = hInstance;
  if ( !hInstance )
    v1 = LoadCursorW((HINSTANCE)hInstance, (LPCWSTR)0x7F00);
  SetCursor(v1);
}

//----- (6E6685D2) --------------------------------------------------------
void __thiscall CWaitCursor::~CWaitCursor(CWaitCursor *this)
{
  EndWaitCursor(*(HICON *)this);
}

//----- (6E6685DF) --------------------------------------------------------
int __cdecl TemporaryCode::FInSystemSetup()
{
  signed int v0; // esi@1
  DWORD Type; // [sp+4h] [bp-8h]@2
  HKEY hKey; // [sp+8h] [bp-4h]@1

  v0 = 0;
  if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\Setup", 0x20019u, &hKey) )
  {
    if ( !HrRegQueryDword(hKey, L"SystemSetupInProgress", (DWORD)&Type) && Type )
      v0 = 1;
    RegCloseKey(hKey);
  }
  return v0;
}

//----- (6E668661) --------------------------------------------------------
__int32 __stdcall HrSetupGetIndirectStringsFromDriverInfoWithAlloc(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // edi@3
  void *v8; // eax@3
  __int32 v10; // [sp+Ch] [bp-4h]@1

  v5 = a5;
  v10 = 0;
  *(_DWORD *)a5 = 0;
  v6 = pSetupGetIndirectStringsFromDriverInfo(a1, a2, a3, a4, 0, 0, &a5);
  if ( !v6 )
  {
    do
    {
      if ( GetLastError() != 122 )
        break;
      operator delete(*(void **)v5);
      v7 = a5;
      v8 = operator new(2 * a5);
      *(_DWORD *)v5 = v8;
      if ( !v8 )
        return -2147024882;
      v6 = pSetupGetIndirectStringsFromDriverInfo(a1, a2, a3, a4, *(_DWORD *)v5, v7, &a5);
    }
    while ( !v6 );
    if ( !v6 )
    {
      operator delete(*(void **)v5);
      *(_DWORD *)v5 = 0;
      v10 = HrFromLastWin32Error();
    }
  }
  return v10;
}
// 6E690CF6: using guessed type int __stdcall pSetupGetIndirectStringsFromDriverInfo(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (6E668710) --------------------------------------------------------
__int32 __stdcall HrCiRegDeleteComponentNetworkKey(int a1, const WCHAR *a2)
{
  const WCHAR *v2; // eax@1
  __int32 v3; // esi@1
  HKEY phkResult; // [sp+4h] [bp-4h]@1

  v2 = (&MAP_NETCLASS_TO_NETWORK_SUBTREE)[2 * a1];
  phkResult = 0;
  v3 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, v2, 0x20006u, &phkResult);
  if ( !v3 )
  {
    v3 = HrRegDeleteKeyTree(phkResult, a2);
    RegSafeCloseKey(phkResult);
  }
  return v3;
}

//----- (6E668760) --------------------------------------------------------
DWORD __stdcall FGetFullShadowedPath(LPWSTR pszDest, LPCWSTR pszPath)
{
  DWORD result; // eax@1
  const WCHAR *v3; // eax@2
  WCHAR Buffer; // [sp+8h] [bp-20Ch]@1

  result = GetEnvironmentVariableW(L"INSTALLER_SHADOWED_COMPONENT_PAYLOAD", &Buffer, 0x104u);
  if ( result )
  {
    v3 = PathFindFileNameW(pszPath);
    PathCombineW(pszDest, &Buffer, v3);
    result = 1;
  }
  return result;
}

//----- (6E6687C6) --------------------------------------------------------
__int32 __stdcall HrCiInstallFromInfSection(HINF InfHandle, PCWSTR SectionName, HKEY RelativeKeyRoot, HWND QueueHandle, unsigned __int32 a5)
{
  HWND v5; // ebx@1
  __int32 v6; // edi@1
  int v7; // eax@4
  DWORD Result; // [sp+Ch] [bp-8h]@5
  PVOID Context; // [sp+10h] [bp-4h]@4

  v5 = QueueHandle;
  v6 = 0;
  if ( !(a5 & 0x10) )
    goto LABEL_14;
  SetupOpenAppendInfFileW(0, InfHandle, 0);
  v6 = HrSetupOpenFileQueue((void **)&QueueHandle);
  if ( !v6 )
  {
    v6 = HrSetupInstallFilesFromInfSection(InfHandle, 0, QueueHandle, SectionName, 0, 0);
    if ( !v6 )
    {
      v7 = TemporaryCode::FInSystemSetup();
      v6 = HrSetupInitDefaultQueueCallbackEx(v5, (HWND)-(v7 != 0), 0, 0, 0, &Context);
      if ( !v6 )
      {
        v6 = HrSetupScanFileQueueWithNoCallback(QueueHandle, 0x22u, v5, &Result);
        if ( !v6 && Result != 1 )
          v6 = HrSetupCommitFileQueue(v5, QueueHandle, SetupDefaultQueueCallbackW, Context);
        SetupTermDefaultQueueCallback(Context);
        SetupCloseFileQueue(QueueHandle);
        if ( !v6 )
        {
LABEL_14:
          if ( a5 & 0xFFFFFFEF )
            v6 = HrSetupInstallFromInfSection(
                   v5,
                   InfHandle,
                   SectionName,
                   a5 & 0xFFFFFFEF,
                   RelativeKeyRoot,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0);
        }
      }
    }
  }
  return v6;
}

//----- (6E6688AA) --------------------------------------------------------
__int32 __stdcall HrCiGetDriverDetail(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DRVINFO_DATA_V2_W *Dst, struct _SP_DRVINFO_DETAIL_DATA_W **a4)
{
  __int32 v4; // ebx@1
  bool v5; // sf@1

  memset(Dst, 0, 0x61Cu);
  Dst->cbSize = 1564;
  *a4 = 0;
  v4 = HrSetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, Dst);
  v5 = v4 < 0;
  if ( !v4 )
  {
    v4 = HrSetupDiGetDriverInfoDetail(DeviceInfoSet, DeviceInfoData, Dst, a4);
    v5 = v4 < 0;
  }
  if ( v5 && *a4 )
  {
    MemFree(*a4);
    *a4 = 0;
  }
  return v4;
}

//----- (6E668910) --------------------------------------------------------
__int32 __stdcall HrCiCreateInstanceKey(struct COMPONENT_INSTALL_INFO *a1, PHKEY phkResult)
{
  __int32 result; // eax@2
  WCHAR SubKey; // [sp+Ch] [bp-20Ch]@5

  *phkResult = 0;
  if ( FIsConsideredNetClass(*(_DWORD *)a1) )
  {
    result = HrSetupDiCreateDevRegKey(
               *((HDEVINFO *)a1 + 14),
               *((PSP_DEVINFO_DATA *)a1 + 15),
               1u,
               0,
               2u,
               0,
               0,
               phkResult);
  }
  else if ( *((_DWORD *)a1 + 9) & 0x40000 || (result = CoCreateGuid((GUID *)a1 + 1)) == 0 )
  {
    CreateInstanceKeyPath(*(_DWORD *)a1, (GUID *)a1 + 1, &SubKey);
    result = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0, 0xF003Fu, 0, phkResult, 0);
  }
  return result;
}

//----- (6E6689AB) --------------------------------------------------------
__int32 __stdcall HrCiCallClassInstallerToInstallComponent(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, void *a3)
{
  __int32 v3; // ebx@1
  bool v4; // sf@2
  int v6; // [sp+Ch] [bp-238h]@15
  void *v7; // [sp+10h] [bp-234h]@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+14h] [bp-230h]@3

  v7 = a3;
  v3 = HrSetupDiCallClassInstaller(0x19u, DeviceInfoSet, DeviceInfoData);
  if ( v3 )
    return v3;
  v3 = HrSetupDiCallClassInstaller(0x18u, DeviceInfoSet, DeviceInfoData);
  v4 = v3 < 0;
  if ( !v3 )
  {
    if ( !HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst) && Dst.Flags & 0x1000000 )
    {
LABEL_7:
      v3 = HrSetupDiCallClassInstaller(0x22u, DeviceInfoSet, DeviceInfoData);
      v4 = v3 < 0;
      if ( !v3 )
      {
        v3 = HrSetupDiCallClassInstaller(0x20u, DeviceInfoSet, DeviceInfoData);
        v4 = v3 < 0;
        if ( !v3 )
        {
          if ( v7 )
            CiSetReservedField(DeviceInfoSet, DeviceInfoData, v7);
          v3 = HrSetupDiCallClassInstaller(2u, DeviceInfoSet, DeviceInfoData);
          if ( v7 )
            CiClearReservedField(DeviceInfoSet, DeviceInfoData);
          v4 = v3 < 0;
        }
      }
      goto LABEL_14;
    }
    v3 = HrSetupDiCallClassInstaller(0x15u, DeviceInfoSet, DeviceInfoData);
    v4 = v3 < 0;
    if ( !v3 )
    {
      HrSetupDiSetDeipFlags(DeviceInfoSet, DeviceInfoData, 0x1000000, 0, 1);
      goto LABEL_7;
    }
  }
LABEL_14:
  if ( v4 )
  {
    v7 = 0;
    v6 = 1;
    CiSetReservedField(DeviceInfoSet, DeviceInfoData, &v6);
    HrSetupDiCallClassInstaller(5u, DeviceInfoSet, DeviceInfoData);
    CiClearReservedField(DeviceInfoSet, DeviceInfoData);
  }
  return v3;
}

//----- (6E668ACD) --------------------------------------------------------
void __stdcall SetBadDriverFlagIfNeededInList(HDEVINFO DeviceInfoSet)
{
  struct _SP_DRVINSTALL_PARAMS DriverInstallParams; // [sp+8h] [bp-638h]@2
  DWORD MemberIndex; // [sp+1Ch] [bp-624h]@1
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+20h] [bp-620h]@1

  MemberIndex = 0;
  while ( !HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, MemberIndex, &Dst) )
  {
    ++MemberIndex;
    if ( !HrSetupDiGetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams)
      && !(DriverInstallParams.Flags & 0x800) )
    {
      if ( DriverInstallParams.Flags & 4 )
      {
        DriverInstallParams.Flags |= 0x800u;
        HrSetupDiSetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
      }
    }
  }
}

//----- (6E668B85) --------------------------------------------------------
__int32 __stdcall HrCiExcludeNonNetClassDriverFromSelectUsingInfId(HDEVINFO DeviceInfoSet, const unsigned __int16 *a2)
{
  __int32 result; // eax@1
  struct _SP_DRVINSTALL_PARAMS DriverInstallParams; // [sp+8h] [bp-640h]@2
  LPCWSTR lpString2; // [sp+1Ch] [bp-62Ch]@1
  void *lpMem; // [sp+20h] [bp-628h]@3
  DWORD MemberIndex; // [sp+24h] [bp-624h]@1
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+28h] [bp-620h]@1

  lpString2 = a2;
  MemberIndex = 0;
  for ( result = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, 0, &Dst);
        !result;
        result = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, MemberIndex, &Dst) )
  {
    ++MemberIndex;
    HrSetupDiGetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
    if ( !(DriverInstallParams.Flags & 0x800)
      && !HrSetupDiGetDriverInfoDetail(DeviceInfoSet, 0, &Dst, (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem) )
    {
      if ( !lstrcmpiW((LPCWSTR)lpMem + 784, lpString2) )
      {
        DriverInstallParams.Flags |= 0x800u;
        HrSetupDiSetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
      }
      MemFree(lpMem);
    }
  }
  if ( result == -2147024637 )
    result = 0;
  return result;
}

//----- (6E668C8A) --------------------------------------------------------
void __stdcall ExcludeLockedDownComponents(const unsigned __int16 *a1, HDEVINFO DeviceInfoSet)
{
  HrCiExcludeNonNetClassDriverFromSelectUsingInfId(DeviceInfoSet, a1);
}

//----- (6E668CA3) --------------------------------------------------------
__int32 __stdcall HrCiHideIrrelevantRasProtocols(HDEVINFO DeviceInfoSet, int a2)
{
  __int32 result; // eax@7
  unsigned int i; // esi@7
  struct _SP_DRVINSTALL_PARAMS DriverInstallParams; // [sp+Ch] [bp-66Ch]@8
  int v5; // [sp+20h] [bp-658h]@10
  int *v6; // [sp+24h] [bp-654h]@5
  void *lpMem; // [sp+28h] [bp-650h]@9
  DWORD MemberIndex; // [sp+2Ch] [bp-64Ch]@1
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+30h] [bp-648h]@7
  char v10; // [sp+64Ch] [bp-2Ch]@1
  int v11; // [sp+660h] [bp-18h]@1
  int v12; // [sp+664h] [bp-14h]@1
  int v13; // [sp+668h] [bp-10h]@1
  int v14; // [sp+66Ch] [bp-Ch]@1
  wchar_t v15; // [sp+670h] [bp-8h]@1

  qmemcpy(&v10, L"ms_netmon", 0x14u);
  v11 = *(_DWORD *)L"ms_tcpip";
  v12 = *(_DWORD *)L"\u7300\u5f00\u7400\u6300\u7000\u6900\u7000";
  v13 = *(_DWORD *)L"s_tcpip";
  v14 = *(_DWORD *)L"\u5f00\u7400\u6300\u7000\u6900\u7000";
  MemberIndex = 0;
  v15 = aMs_tcpip[8];
  if ( !(dword_6E69BCF4 & 1) )
  {
    dword_6E69BCF4 |= 1u;
    dword_6E69BCEC = (int)&v10;
    dword_6E69BCF0 = (int)&v11;
  }
  if ( !(dword_6E69BCF4 & 2) )
  {
    dword_6E69BCF4 |= 2u;
    dword_6E69BCE4 = (int)&v10;
    dword_6E69BCE8 = (int)&v11;
  }
  v6 = &dword_6E69BCEC;
  if ( a2 != 1 )
    v6 = &dword_6E69BCE4;
  result = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, 0, &Dst);
  for ( i = 0; !result; result = HrSetupDiEnumDriverInfo(DeviceInfoSet, 0, 1u, MemberIndex, &Dst) )
  {
    ++MemberIndex;
    HrSetupDiGetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
    if ( !(DriverInstallParams.Flags & 0x800)
      && !HrSetupDiGetDriverInfoDetail(DeviceInfoSet, 0, &Dst, (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem) )
    {
      v5 = 1;
      do
      {
        if ( !_wcsicmp((const wchar_t *)v6[i], (const wchar_t *)lpMem + 784) )
          v5 = 0;
        ++i;
      }
      while ( i < 2 );
      if ( v5 )
      {
        DriverInstallParams.Flags |= 0x800u;
        HrSetupDiSetDriverInstallParams(DeviceInfoSet, 0, &Dst, &DriverInstallParams);
      }
      MemFree(lpMem);
    }
    i = 0;
  }
  if ( result == -2147024637 )
    result = 0;
  return result;
}
// 6E65C494: using guessed type wchar_t aMs_tcpip[9];
// 6E668E3C: using guessed type wchar_t aMs_netmon[10];
// 6E69BCE4: using guessed type int dword_6E69BCE4;
// 6E69BCE8: using guessed type int dword_6E69BCE8;
// 6E69BCEC: using guessed type int dword_6E69BCEC;
// 6E69BCF0: using guessed type int dword_6E69BCF0;
// 6E69BCF4: using guessed type int dword_6E69BCF4;

//----- (6E668E55) --------------------------------------------------------
__int32 __stdcall HrCiRemoveFilterDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v2; // esi@1
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  CiSetReservedField(DeviceInfoSet, DeviceInfoData, &v4);
  v2 = HrSetupDiCallClassInstaller(5u, DeviceInfoSet, DeviceInfoData);
  CiClearReservedField(DeviceInfoSet, DeviceInfoData);
  return v2;
}

//----- (6E668E9E) --------------------------------------------------------
int __stdcall HrGetFirstComponent(struct IEnumNetCfgComponent *a1, struct INetCfgComponent **a2)
{
  INetCfgComponent **v2; // edi@1

  v2 = a2;
  *a2 = 0;
  a1->lpVtbl->Reset(a1);
  return a1->lpVtbl->Next(a1, 1, v2, (ULONG *)&a2);
}

//----- (6E668ECC) --------------------------------------------------------
int __stdcall HrGetNextComponent(struct IEnumNetCfgComponent *a1, struct INetCfgComponent **a2)
{
  INetCfgComponent **v2; // eax@1

  v2 = a2;
  *a2 = 0;
  return a1->lpVtbl->Next(a1, 1, v2, (ULONG *)&a2);
}

//----- (6E668EF2) --------------------------------------------------------
int __stdcall HrGetComponentEnum(struct INetCfg *a1, const struct _GUID *a2, struct IUnknown *a3)
{
  struct IUnknown *v3; // esi@1
  int v4; // edi@1

  v3 = a3;
  a3->lpVtbl = 0;
  v4 = a1->lpVtbl->QueryNetCfgClass(a1, a2, &IID_INetCfgClass, (void **)&a3);
  if ( !v4 )
  {
    v4 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *))a3->lpVtbl[1].AddRef)(a3, v3);
    ReleaseObj(a3);
  }
  return v4;
}

//----- (6E668F3B) --------------------------------------------------------
int __stdcall HrGetNumInstalledFilters(unsigned __int32 *a1)
{
  unsigned __int32 *v1; // ebx@1
  int v2; // esi@1
  int i; // eax@3
  struct IUnknown *v5; // [sp+Ch] [bp-Ch]@1
  struct IUnknown v6; // [sp+10h] [bp-8h]@1
  struct IUnknown *v7; // [sp+14h] [bp-4h]@1

  v1 = a1;
  v5 = 0;
  v6.lpVtbl = 0;
  v7 = 0;
  *a1 = 0;
  v2 = HrCreateAndInitializeINetCfg(0, (struct INetCfg **)&v5, 0, 0, 0, 0);
  if ( !v2 )
  {
    v2 = HrGetComponentEnum((struct INetCfg *)v5, &GUID_DEVCLASS_NETSERVICE, &v6);
    if ( !v2 )
    {
      for ( i = HrGetFirstComponent((struct IEnumNetCfgComponent *)v6.lpVtbl, (struct INetCfgComponent **)&v7);
            ;
            i = HrGetNextComponent((struct IEnumNetCfgComponent *)v6.lpVtbl, (struct INetCfgComponent **)&v7) )
      {
        v2 = i;
        if ( i )
          break;
        v2 = ((int (__stdcall *)(struct IUnknown *, unsigned __int32 **))v7->lpVtbl[2].AddRef)(v7, &a1);
        if ( v2 )
        {
          ReleaseObj(v7);
          break;
        }
        if ( (unsigned int)a1 & 0x40400 )
          ++*v1;
        ReleaseObj(v7);
      }
      if ( v2 == 1 )
        v2 = 0;
      ReleaseObj((struct IUnknown *)v6.lpVtbl);
    }
    HrUninitializeAndReleaseINetCfg(0, v5, 0);
  }
  return v2;
}

//----- (6E668FFC) --------------------------------------------------------
char __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Inside(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  int v4; // eax@1
  unsigned int v5; // edx@2
  char result; // al@8

  v3 = *(_DWORD *)(a1 + 24);
  v4 = a1 + 4;
  if ( v3 < 8 )
    v5 = a1 + 4;
  else
    v5 = *(_DWORD *)v4;
  if ( a3 < v5 )
    goto LABEL_12;
  if ( v3 >= 8 )
    v4 = *(_DWORD *)v4;
  if ( v4 + 2 * *(_DWORD *)(a1 + 20) <= a3 )
LABEL_12:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (6E66903A) --------------------------------------------------------
void *__stdcall std::_Allocate<unsigned short>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(2 * v2);
}

//----- (6E669060) --------------------------------------------------------
void *__stdcall std::_Traits_helper::move_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4, int a5)
{
  return std::char_traits<unsigned short>::_Move_s(Dst, a2, Src, a4);
}

//----- (6E669082) --------------------------------------------------------
signed int __stdcall StringCbCatW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3)
{
  unsigned int v3; // esi@1
  signed int result; // eax@1

  v3 = a2 >> 1;
  result = sub_6E6684E7((int)&a2, a2 >> 1, (int)a1, 0x7FFFFFFFu);
  if ( result >= 0 )
    result = sub_6E641D2F((int)a3, v3 - a2, (int)&a1[a2], 0, 0x7FFFFFFF);
  return result;
}

//----- (6E6690C8) --------------------------------------------------------
__int32 __stdcall HrCiInstallServices(HINF InfHandle, const unsigned __int16 *a2)
{
  BOOL v2; // esi@1
  __int32 result; // eax@4
  WCHAR SectionName; // [sp+4h] [bp-20Ch]@1

  StringCchPrintfW(&SectionName, 0x104u, L"%s.%s", a2, L"Services");
  v2 = SetupInstallServicesFromInfSectionW(InfHandle, &SectionName, 0);
  if ( !v2 && GetLastError() == -536870655 )
    v2 = 1;
  result = 0;
  if ( !v2 )
    result = HrFromLastWin32Error();
  return result;
}
// 6E669150: using guessed type wchar_t aServices[9];

//----- (6E669167) --------------------------------------------------------
__int32 __stdcall HrCiDoCompleteSectionInstall(HINF InfHandle, HKEY RelativeKeyRoot, wchar_t *Str, HWND QueueHandle, int a5)
{
  __int32 v5; // ebx@1
  __int32 v6; // eax@3
  wchar_t *v7; // eax@8

  v5 = 0;
  if ( Str && *Str )
  {
    v6 = HrCiInstallFromInfSection(InfHandle, Str, RelativeKeyRoot, QueueHandle, a5 != 0 ? 5 : 1983);
    v5 = v6;
    if ( !a5 )
    {
      if ( v6 )
        return v5;
      v5 = HrCiInstallServices(InfHandle, Str);
      if ( v5 )
        return v5;
      v5 = HrCiInstallFromInfSection(InfHandle, Str, RelativeKeyRoot, QueueHandle, 0x40u);
    }
    if ( !v5 )
    {
      v7 = wcsstr(Str, L".Remove");
      if ( !v7 || wcscmp(v7, L".Remove") )
        v5 = HrAddOrRemoveWinsockDependancy(InfHandle, Str);
    }
  }
  return v5;
}

//----- (6E669232) --------------------------------------------------------
__int32 __stdcall HrCiGetDriverInfo(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *a2, const struct _GUID *a3, const unsigned __int16 *a4, const unsigned __int16 *a5)
{
  unsigned int v5; // edi@1
  WCHAR *v6; // eax@2
  unsigned int v7; // eax@7
  struct _SP_DEVINFO_DATA *v8; // edi@7
  __int32 v9; // eax@19
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-44Ch]@27
  __int32 v12; // [sp+20h] [bp-43Ch]@6
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+24h] [bp-438h]@8
  WCHAR DeviceName; // [sp+250h] [bp-20Ch]@1
  __int16 v15[259]; // [sp+252h] [bp-20Ah]@7

  StringCchCopyW(&DeviceName, 0x104u, a4);
  v5 = 0;
  if ( DeviceName )
  {
    v6 = &DeviceName;
    do
    {
      if ( 92 == *v6 )
        *v6 = 38;
      ++v5;
      v6 = &DeviceName + v5;
    }
    while ( *v6 );
  }
  v12 = HrSetupDiCreateDeviceInfo(DeviceInfoSet, &DeviceName, (GUID *)a3, 0, 0, 1u, a2);
  if ( !v12 )
  {
    StringCchCopyNW(&DeviceName, 0x104u, a4, v5);
    v15[v5] = 0;
    v7 = CbOfSzAndTerm(&DeviceName);
    v8 = a2;
    v12 = HrSetupDiSetDeviceRegistryProperty(DeviceInfoSet, a2, 1u, (BYTE *)&DeviceName, v7 + 2);
    if ( !v12 )
    {
      if ( !HrSetupDiGetDeviceInstallParams(DeviceInfoSet, a2, &Dst) )
      {
        Dst.FlagsEx |= 0x2000u;
        if ( Dst.DriverPath[0] || a5 && *a5 && (StringCchCopyW(Dst.DriverPath, 0x104u, a5), Dst.DriverPath[0]) )
        {
          Dst.Flags |= 0x10000u;
          if ( !_wcsicmp(L"netrasa.inf", Dst.DriverPath) || !_wcsicmp(L"netpsa.inf", Dst.DriverPath) )
            Dst.Flags |= 0x1000000u;
        }
        if ( !FIsEnumerated(a3) )
          Dst.FlagsEx |= 0x800u;
        HrSetupDiSetDeviceInstallParams(DeviceInfoSet, a2, &Dst);
      }
      v9 = HrSetupDiBuildDriverInfoList(DeviceInfoSet, a2, 2u);
      v12 = v9;
      if ( v9 )
      {
        if ( v9 == -2147024894 )
          v12 = -2146500093;
      }
      else
      {
        v12 = HrSetupDiSelectBestCompatDrv(DeviceInfoSet, a2);
        if ( v12 == -2146500056 )
          v12 = -2146500093;
        if ( v12 < 0 )
          SetupDiDestroyDriverInfoList(DeviceInfoSet, a2, 2u);
      }
      if ( v12 == -2146500093 )
      {
        LogToken = SetupGetThreadLogToken();
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: Start of attempt to use %%SYSTEMROOT%%\\inf for building driver list after failure");
        if ( !HrSetupDiSetDeipFlags(DeviceInfoSet, a2, -2147221504, 1, 1)
          && !HrSetupDiBuildDriverInfoList(DeviceInfoSet, a2, 2u) )
        {
          if ( HrSetupDiSelectBestCompatDrv(DeviceInfoSet, a2) )
            SetupDiDestroyDriverInfoList(DeviceInfoSet, a2, 2u);
          else
            v12 = 0;
        }
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: End of attempt to use %%SYSTEMROOT%%\\inf for building driver list after failure");
        v8 = a2;
      }
    }
    if ( v12 < 0 )
      SetupDiDeleteDeviceInfo(DeviceInfoSet, v8);
  }
  return v12;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;
// 6E669232: using guessed type __int16 var_20A[259];

//----- (6E66960D) --------------------------------------------------------
__int32 __stdcall HrCiGetClassAndInfFileOfInfId(const unsigned __int16 *a1, enum NETCLASS *a2, unsigned __int16 *a3)
{
  __int32 v3; // esi@1
  int v4; // eax@4
  unsigned __int16 *v5; // ecx@9
  void *lpMem; // [sp+Ch] [bp-648h]@6
  unsigned __int16 *v8; // [sp+10h] [bp-644h]@1
  HDEVINFO DeviceInfoSet; // [sp+14h] [bp-640h]@1
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+18h] [bp-63Ch]@3
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+634h] [bp-20h]@2

  v8 = a3;
  v3 = HrSetupDiCreateDeviceInfoList(0, 0, &DeviceInfoSet);
  if ( v3 )
    goto LABEL_13;
  v3 = HrCiGetDriverInfo(DeviceInfoSet, &DeviceInfoData, &GUID_NULL, a1, 0);
  if ( !v3 )
  {
    v3 = HrSetupDiGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &Dst);
    if ( !v3 )
    {
      v4 = NetClassEnumFromGuid(&DeviceInfoData.ClassGuid);
      *(_DWORD *)a2 = v4;
      if ( (unsigned int)v4 < 5 )
      {
        v3 = HrCiGetDriverDetail(DeviceInfoSet, &DeviceInfoData, &Dst, (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem);
        if ( !v3 )
        {
          StringCchCopyW(v8, 0x104u, (const unsigned __int16 *)lpMem + 268);
          MemFree(lpMem);
        }
      }
      else
      {
        v3 = -2146500090;
      }
    }
  }
  SetupDiDestroyDeviceInfoList(DeviceInfoSet);
  if ( v3 )
  {
LABEL_13:
    v5 = v8;
    *(_DWORD *)a2 = 6;
    *v5 = 0;
  }
  return v3;
}

//----- (6E669720) --------------------------------------------------------
__int32 __stdcall HrCiDoOemFileCopyIfNeeded(wchar_t *Str, unsigned __int16 *a2, unsigned __int32 a3)
{
  WCHAR *v3; // eax@1
  int v4; // ecx@2
  __int32 v6; // [sp+8h] [bp-420h]@1
  PWSTR DestinationInfFileNameComponent; // [sp+10h] [bp-418h]@1
  WCHAR DestinationInfFileName; // [sp+14h] [bp-414h]@9
  WCHAR Buffer; // [sp+21Ch] [bp-20Ch]@1
  char Dst; // [sp+21Eh] [bp-20Ah]@1

  v6 = 0;
  Buffer = 0;
  memset(&Dst, 0, 0x206u);
  GetSystemWindowsDirectoryW(&Buffer, 0x104u);
  StringCchCatW(&Buffer, 0x104u, L"\\");
  StringCchCatW(&Buffer, 0x104u, L"Inf");
  v3 = wcsrchr(Str, 0x5Cu);
  DestinationInfFileNameComponent = v3;
  if ( v3 )
    v4 = v3 - Str;
  else
    v4 = wcslen(Str);
  if ( v4 != wcslen(&Buffer) || _wcsnicmp(Str, &Buffer, v4) )
  {
    v6 = HrSetupCopyOemInfBuffer(Str, 0, 1u, 0, &DestinationInfFileName, 0x104u, &DestinationInfFileNameComponent);
    if ( !v6 )
      StringCchCopyW(a2, a3, DestinationInfFileNameComponent);
  }
  else if ( DestinationInfFileNameComponent )
  {
    StringCchCopyW(a2, a3, DestinationInfFileNameComponent + 1);
  }
  else
  {
    StringCchCopyW(a2, a3, Str);
  }
  return v6;
}

//----- (6E669871) --------------------------------------------------------
__int32 __stdcall HrCiSetSelectDeviceDialogStrings(HDEVINFO a1, PSP_DEVINFO_DATA a2, const struct _GUID *a3)
{
  __int32 result; // eax@1
  const unsigned __int16 *v4; // eax@8
  const unsigned __int16 *v5; // eax@8
  const unsigned __int16 *v6; // eax@10
  const unsigned __int16 *v7; // eax@10
  const unsigned __int16 *v8; // eax@12
  const unsigned __int16 *v9; // eax@12
  const unsigned __int16 *v10; // eax@14
  const unsigned __int16 *v11; // eax@14
  const unsigned __int16 *v12; // eax@14
  const unsigned __int16 *v13; // eax@16
  const unsigned __int16 *v14; // eax@16
  const unsigned __int16 *v15; // eax@16
  const unsigned __int16 *v16; // eax@8
  const wchar_t *v17; // eax@19
  signed int v18; // [sp+10h] [bp-6F0h]@4
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+14h] [bp-6ECh]@5
  struct _SP_CLASSINSTALL_HEADER ClassInstallParams; // [sp+240h] [bp-4C0h]@1
  unsigned __int16 v21; // [sp+248h] [bp-4B8h]@8
  wchar_t pszDest; // [sp+2C0h] [bp-440h]@17
  unsigned __int16 v23; // [sp+4C0h] [bp-240h]@8
  unsigned __int16 v24; // [sp+4FCh] [bp-204h]@14

  result = HrSetupDiGetFixedSizeClassInstallParams(a1, a2, &ClassInstallParams, 0x4BCu);
  if ( result < 0 && result == -2146500075 )
    result = 0;
  v18 = 0;
  if ( !result )
  {
    HrSetupDiGetDeviceInstallParams(a1, a2, &Dst);
    if ( Dst.Flags & 1 )
      v18 = 1;
    if ( !memcmp(&GUID_DEVCLASS_NETCLIENT, a3, 0x10u) )
    {
      v4 = SzLoadIds(0x36B9u);
      StringCchCopyW(&v21, 0x3Cu, v4);
      v5 = SzLoadIds(0x36B8u);
      StringCchCopyW(&v23, 0x1Eu, v5);
      v16 = SzLoadIds(0x36B7u);
    }
    else if ( !memcmp(&GUID_DEVCLASS_NETSERVICE, a3, 0x10u) )
    {
      v6 = SzLoadIds(0x36C3u);
      StringCchCopyW(&v21, 0x3Cu, v6);
      v7 = SzLoadIds(0x36C2u);
      StringCchCopyW(&v23, 0x1Eu, v7);
      v16 = SzLoadIds(0x36C1u);
    }
    else if ( !memcmp(&GUID_DEVCLASS_NETTRANS, a3, 0x10u) )
    {
      v8 = SzLoadIds(0x36C0u);
      StringCchCopyW(&v21, 0x3Cu, v8);
      v9 = SzLoadIds(0x36BFu);
      StringCchCopyW(&v23, 0x1Eu, v9);
      v16 = SzLoadIds(0x36BEu);
    }
    else if ( !memcmp(&GUID_DEVCLASS_NET, a3, 0x10u) )
    {
      v10 = SzLoadIds(0x36B6u);
      StringCchCopyW(&v21, 0x3Cu, v10);
      v11 = SzLoadIds(0x36B5u);
      StringCchCopyW(&v24, 0x100u, v11);
      v12 = SzLoadIds(0x36B4u);
      StringCchCopyW(&v23, 0x1Eu, v12);
      v16 = SzLoadIds(0x36B3u);
    }
    else
    {
      if ( memcmp(&GUID_DEVCLASS_INFRARED, a3, 0x10u) )
      {
LABEL_18:
        if ( v18 )
        {
          v17 = SzLoadIds(0x36C4u);
          StringCchCatW(&pszDest, 0x100u, v17);
        }
        ClassInstallParams.InstallFunction = 1;
        return HrSetupDiSetClassInstallParams(a1, a2, &ClassInstallParams, 0x4BCu);
      }
      v13 = SzLoadIds(0x36BDu);
      StringCchCopyW(&v21, 0x3Cu, v13);
      v14 = SzLoadIds(0x36BCu);
      StringCchCopyW(&v24, 0x100u, v14);
      v15 = SzLoadIds(0x36BBu);
      StringCchCopyW(&v23, 0x1Eu, v15);
      v16 = SzLoadIds(0x36BAu);
    }
    StringCchCopyW(&pszDest, 0x100u, v16);
    goto LABEL_18;
  }
  return result;
}

//----- (6E669B08) --------------------------------------------------------
__int32 __stdcall HrCiPrepareSelectDeviceDialog(HDEVINFO a1, struct _SP_DEVINFO_DATA *a2)
{
  __int32 v2; // ebx@1
  int v3; // ecx@10
  int v4; // eax@11
  const unsigned __int16 *v5; // ebx@12
  struct _GUID v6; // ST04_16@14
  int v7; // eax@14
  __int32 v8; // eax@14
  const struct CComponent *v9; // eax@19
  HICON hInstance; // [sp+Ch] [bp-258h]@5
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+18h] [bp-24Ch]@7
  GUID ClassGuid; // [sp+244h] [bp-20h]@2
  int v14; // [sp+260h] [bp-4h]@5

  v2 = 0;
  if ( a2 )
  {
    ClassGuid.Data1 = a2->ClassGuid.Data1;
    *(_DWORD *)&ClassGuid.Data2 = *(_DWORD *)&a2->ClassGuid.Data2;
    *(_DWORD *)&ClassGuid.Data4[0] = *(_DWORD *)&a2->ClassGuid.Data4[0];
    *(_DWORD *)&ClassGuid.Data4[4] = *(_DWORD *)&a2->ClassGuid.Data4[4];
  }
  else
  {
    v2 = HrSetupDiGetDeviceInfoListClass(a1, &ClassGuid);
    if ( v2 )
      return v2;
  }
  if ( FIsEnumerated(&ClassGuid) )
  {
LABEL_23:
    HrCiSetSelectDeviceDialogStrings(a1, a2, &ClassGuid);
    HrSetupDiSetDeipFlags(a1, a2, 135266304, 0, 1);
    return v2;
  }
  hInstance = BeginWaitCursor();
  v14 = 0;
  v2 = HrSetupDiSetDeipFlags(a1, 0, 2048, 1, 1);
  if ( !v2 )
  {
    v2 = HrSetupDiBuildDriverInfoList(a1, 0, 1u);
    if ( !v2 )
    {
      SetBadDriverFlagIfNeededInList(a1);
      EnumLockedDownComponents(ExcludeLockedDownComponents, a1);
      v2 = HrSetupDiGetDeviceInstallParams(a1, a2, &Dst);
      if ( !v2 )
      {
        if ( Dst.ClassInstallReserved )
        {
          if ( !memcmp(&GUID_DEVCLASS_NETTRANS, &ClassGuid, 0x10u) )
          {
            v3 = *(_DWORD *)Dst.ClassInstallReserved;
            if ( !*(_DWORD *)Dst.ClassInstallReserved )
            {
              v4 = *(_DWORD *)(Dst.ClassInstallReserved + 8);
              if ( v4 )
              {
                v5 = *(const unsigned __int16 **)(v4 + 84);
                if ( !v5 )
                  v5 = &String;
                *(_QWORD *)&v6.Data1 = *(_QWORD *)v4;
                *(_QWORD *)&v6.Data4[0] = *(_QWORD *)(v4 + 8);
                v7 = FIsIscsiNicFromNdisNsi(v6);
                v8 = HrCiHideIrrelevantDrivers(a1, v5, v7);
                goto LABEL_21;
              }
            }
            if ( v3 == 1 || v3 == 2 )
            {
              v8 = HrCiHideIrrelevantRasProtocols(a1, v3);
LABEL_21:
              v2 = v8;
              goto LABEL_22;
            }
          }
          else if ( !memcmp(&GUID_DEVCLASS_NETSERVICE, &ClassGuid, 0x10u) )
          {
            v9 = *(const struct CComponent **)(Dst.ClassInstallReserved + 8);
            if ( v9 )
            {
              v8 = HrCiHideIrrelevantFilterServices(a1, v9);
              goto LABEL_21;
            }
          }
        }
      }
    }
  }
LABEL_22:
  v14 = -1;
  EndWaitCursor(hInstance);
  if ( !v2 )
    goto LABEL_23;
  return v2;
}

//----- (6E669CB9) --------------------------------------------------------
signed int __stdcall HrCiInstallFilterDevice(HDEVINFO a1, const unsigned __int16 *a2, struct CComponent *a3, struct CComponent *a4, struct CFilterDevice **a5)
{
  signed int v5; // esi@1
  struct CComponent *v6; // edi@4
  unsigned int v7; // esi@6
  unsigned int v8; // esi@6
  unsigned __int16 *v9; // eax@6
  unsigned __int16 *v10; // edi@6
  void *lpMem; // [sp+10h] [bp-90h]@5
  HKEY hKey; // [sp+14h] [bp-8Ch]@3
  HDEVINFO DeviceInfoSet; // [sp+18h] [bp-88h]@1
  GUID rguid; // [sp+1Ch] [bp-84h]@2
  int v16; // [sp+2Ch] [bp-74h]@2
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+30h] [bp-70h]@1
  OLECHAR sz; // [sp+4Ch] [bp-54h]@3

  *a5 = 0;
  DeviceInfoSet = a1;
  v5 = HrCiGetDriverInfo(a1, &DeviceInfoData, (const struct _GUID *)MAP_NETCLASS_TO_GUID.Data1, a2, 0);
  if ( !v5 )
  {
    rguid.Data1 = 0;
    *(_DWORD *)&rguid.Data2 = 0;
    *(_DWORD *)&rguid.Data4[0] = 0;
    *(_DWORD *)&rguid.Data4[4] = 0;
    v16 = 0;
    v5 = HrCiCallClassInstallerToInstallComponent(DeviceInfoSet, &DeviceInfoData, &rguid);
    if ( !v5 )
    {
      StringFromGUID2(&rguid, &sz, 39);
      v5 = HrSetupDiOpenDevRegKey(DeviceInfoSet, &DeviceInfoData, 1u, 0, 2u, 0x20006u, &hKey);
      if ( !v5 )
      {
        HrRegSetSz(hKey, L"NetCfgInstanceId", (BYTE *)&sz);
        v6 = a4;
        HrRegSetSz(hKey, L"FilterInfId", *((BYTE **)a4 + 7));
        v5 = HrRegSetSz(hKey, L"FilterClass", *((BYTE **)a4 + 16));
        RegCloseKey(hKey);
        if ( !v5 )
        {
          if ( !HrSetupDiGetDeviceRegistryPropertyWithAlloc(DeviceInfoSet, &DeviceInfoData, 0, 0, (DWORD)&lpMem) )
          {
            v7 = CbOfSzSafe(*((const unsigned __int16 **)a3 + 10));
            v8 = v7 + CbOfSzSafe((const unsigned __int16 *)lpMem) + 8;
            v9 = (unsigned __int16 *)MemAlloc(v8);
            v10 = v9;
            if ( v9 )
            {
              StringCbCopyW(v9, v8, *((const unsigned __int16 **)a3 + 10));
              StringCbCatW(v10, v8, L" - ");
              StringCbCatW(v10, v8, (const unsigned __int16 *)lpMem);
              HrSetupDiSetDeviceRegistryProperty(DeviceInfoSet, &DeviceInfoData, 0xCu, (BYTE *)v10, v8);
              MemFree(v10);
            }
            MemFree(lpMem);
            v6 = a4;
          }
          v5 = CFilterDevice::HrCreateInstance(a3, v6, &DeviceInfoData, &sz, a5);
        }
      }
    }
    SetupDiDestroyDriverInfoList(DeviceInfoSet, &DeviceInfoData, 2u);
  }
  return v5;
}

//----- (6E669EA9) --------------------------------------------------------
void *__stdcall std::_Traits_helper::move_s<std::char_traits<unsigned short>>(void *Dst, int a2, void *Src, int a4)
{
  return std::_Traits_helper::move_s<std::char_traits<unsigned short>>(Dst, a2, Src, a4, a4);
}

//----- (6E669ECB) --------------------------------------------------------
__int32 __stdcall HrCiBuildExcludedDriverList(HDEVINFO DeviceInfoSet, int a2, int a3)
{
  __int32 v3; // edi@1
  int i; // esi@3
  HICON hInstance; // [sp+Ch] [bp-10h]@1

  hInstance = BeginWaitCursor();
  v3 = HrSetupDiSetDeipFlags(DeviceInfoSet, 0, 2048, 1, 1);
  if ( !v3 )
    v3 = HrSetupDiBuildDriverInfoList(DeviceInfoSet, 0, 1u);
  for ( i = *(_DWORD *)(a3 + 8); i != *(_DWORD *)(a3 + 12); i += 4 )
  {
    if ( a2 == *(_DWORD *)(*(_DWORD *)i + 16) )
      v3 = HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
             DeviceInfoSet,
             *(const unsigned __int16 **)(*(_DWORD *)i + 28));
  }
  EndWaitCursor(hInstance);
  return v3;
}

//----- (6E669F47) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Copy(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // ecx@3
  void *v6; // ebx@6
  void *v7; // eax@8
  unsigned int v9; // [sp+10h] [bp-14h]@3

  v3 = this;
  v4 = a2 | 7;
  if ( (a2 | 7u) <= 0x7FFFFFFE )
  {
    v5 = *(_DWORD *)(this + 24);
    v9 = *(_DWORD *)(v3 + 24) >> 1;
    if ( v4 / 3u < v9 && v5 <= 2147483646 - v9 )
      v4 = v5 + v9;
  }
  else
  {
    v4 = a2;
  }
  v6 = std::_Allocate<unsigned short>(v4 + 1, 0);
  if ( a3 )
  {
    if ( *(_DWORD *)(v3 + 24) < 8u )
      v7 = (void *)(v3 + 4);
    else
      v7 = *(void **)(v3 + 4);
    std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(v6, v4 + 1, v7, a3);
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    v3,
    1,
    0);
  *(_DWORD *)(v3 + 4) = v6;
  *(_DWORD *)(v3 + 24) = v4;
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
           v3,
           a3);
}

//----- (6E66A012) --------------------------------------------------------
void __usercall __noreturn sub_6E66A012(int a1@<ebp>)
{
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    *(_DWORD *)(a1 - 24),
    1,
    0);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E66A02C) --------------------------------------------------------
BOOL __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(int this, int a2, char a3)
{
  unsigned int v3; // eax@7

  if ( (unsigned int)a2 > 0x7FFFFFFE )
    std::_String_base::_Xlen();
  if ( *(_DWORD *)(this + 24) >= (unsigned int)a2 )
  {
    if ( a3 && (unsigned int)a2 < 8 )
    {
      v3 = *(_DWORD *)(this + 20);
      if ( a2 < v3 )
        v3 = a2;
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
        this,
        1,
        v3);
    }
    else if ( !a2 )
    {
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
        this,
        0);
    }
  }
  else
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Copy(
      this,
      a2,
      *(_DWORD *)(this + 20));
  }
  return (unsigned int)a2 > 0;
}

//----- (6E66A096) --------------------------------------------------------
__int32 __stdcall HrCiRegisterNotificationDll(HKEY a1, int a2, int a3)
{
  __int32 v3; // esi@1
  __int32 v4; // eax@2
  void *v5; // eax@4
  HRESULT v6; // eax@8
  void *v7; // eax@11
  __int32 v8; // eax@14
  HKEY hKey; // [sp+Ch] [bp-238h]@1
  int v11; // [sp+10h] [bp-234h]@2
  LPCWSTR pszPath; // [sp+14h] [bp-230h]@4
  unsigned int v13; // [sp+28h] [bp-21Ch]@4
  WCHAR pszDest; // [sp+2Ch] [bp-218h]@6
  int v15; // [sp+240h] [bp-4h]@2

  v3 = HrRegOpenKeyEx(a1, L"Ndi", 0x20019u, &hKey);
  if ( !v3 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v11);
    v15 = 0;
    v4 = HrRegQueryTypeString(hKey, L"ComponentDLL", 1u, (int)&v11);
    v3 = v4;
    if ( v4 )
    {
      if ( v4 == -2147024894 )
        v3 = 0;
    }
    else
    {
      if ( !a3 )
        goto LABEL_25;
      v5 = (void *)pszPath;
      if ( v13 < 8 )
        v5 = &pszPath;
      if ( !FGetFullShadowedPath(&pszDest, (LPCWSTR)v5)
        || (a2 ? (v6 = HrRegisterOrUnregisterComObject(&pszDest, 1)) : (v6 = HrRegisterOrUnregisterComObject(
                                                                               &pszDest,
                                                                               0)),
            (v3 = v6) != 0) )
      {
LABEL_25:
        v7 = (void *)pszPath;
        if ( a2 )
        {
          if ( v13 < 8 )
            v7 = &pszPath;
          v8 = HrUnregisterComObject((const unsigned __int16 *)v7);
        }
        else
        {
          if ( v13 < 8 )
            v7 = &pszPath;
          v8 = HrRegisterComObject((const unsigned __int16 *)v7);
        }
        v3 = v8;
      }
    }
    RegCloseKey(hKey);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
      (int)&v11,
      1,
      0);
  }
  return v3;
}

//----- (6E66A1CB) --------------------------------------------------------
__int32 __stdcall HrCiGetPropertiesFromInf(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue)
{
  int v2; // edi@2
  void *v3; // eax@6
  __int32 v5; // [sp+Ch] [bp-30h]@1
  int v6; // [sp+10h] [bp-2Ch]@5
  LPCOLESTR lpsz; // [sp+14h] [bp-28h]@6
  unsigned int v8; // [sp+28h] [bp-14h]@6
  int v9; // [sp+38h] [bp-4h]@5

  v5 = HrSetupGetFirstDword(
         InfHandle,
         *((PCWSTR *)IntegerValue + 10),
         L"Characteristics",
         (unsigned __int32 *)IntegerValue + 9);
  if ( !v5 )
  {
    v2 = *((_DWORD *)IntegerValue + 9);
    if ( FIsPhysicalAdapter(*(_DWORD *)IntegerValue, v2) )
    {
      v5 = HrCiGetBusInfoFromInf(InfHandle, IntegerValue);
    }
    else if ( v2 & 0x40000 )
    {
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v6);
      v9 = 0;
      v5 = HrSetupGetFirstString(InfHandle, *((PCWSTR *)IntegerValue + 10), L"NetCfgInstanceId", (int)&v6);
      if ( !v5 )
      {
        v3 = (void *)lpsz;
        if ( v8 < 8 )
          v3 = &lpsz;
        v5 = IIDFromString((LPCOLESTR)v3, (LPIID)IntegerValue + 1);
      }
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
        (int)&v6,
        1,
        0);
    }
  }
  return v5;
}

//----- (6E66A273) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@3
  int v6; // edi@9
  int v7; // ecx@11
  void *v8; // eax@12

  v4 = this;
  if ( *(_DWORD *)(a2 + 20) < a3 )
    std::_String_base::_Xran();
  v5 = *(_DWORD *)(a2 + 20) - a3;
  if ( a4 < v5 )
    v5 = a4;
  if ( this == a2 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
      a3 + v5,
      -1);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
      0,
      a3);
  }
  else if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                               this,
                               v5,
                               0) )
  {
    if ( *(_DWORD *)(a2 + 24) < 8u )
      v6 = a2 + 4;
    else
      v6 = *(_DWORD *)(a2 + 4);
    v7 = *(_DWORD *)(v4 + 24);
    if ( (unsigned int)v7 < 8 )
      v8 = (void *)(v4 + 4);
    else
      v8 = *(void **)(v4 + 4);
    std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(v8, v7, (void *)(v6 + 2 * a3), v5);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
      v4,
      v5);
  }
  return v4;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E66A30A) --------------------------------------------------------
int __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int a1, int a2, void *Src, int a4)
{
  int v4; // esi@1
  int v5; // eax@3
  int result; // eax@5
  int v7; // ecx@7
  void *v8; // eax@8

  v4 = a1;
  if ( std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Inside(
         a1,
         a2,
         (unsigned int)Src) )
  {
    if ( *(_DWORD *)(v4 + 24) < 8u )
      v5 = v4 + 4;
    else
      v5 = *(_DWORD *)(v4 + 4);
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
               v4,
               v4,
               (signed int)((char *)Src - v5) >> 1,
               a4);
  }
  else
  {
    if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                            v4,
                            a4,
                            0) )
    {
      v7 = *(_DWORD *)(v4 + 24);
      if ( (unsigned int)v7 < 8 )
        v8 = (void *)(v4 + 4);
      else
        v8 = *(void **)(v4 + 4);
      std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(v8, v7, Src, a4);
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
        v4,
        a4);
    }
    result = v4;
  }
  return result;
}

//----- (6E66A382) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, void *Src)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
           this,
           (int)((char *)Src + 2),
           Src,
           wcslen((const unsigned __int16 *)Src));
}

//----- (6E66A3AF) --------------------------------------------------------
__int32 __stdcall HrCiRemoveNonEnumeratedComponent(int a1, HKEY hKey, int a3, int a4, int a5)
{
  __int32 v5; // edi@1
  DWORD Type; // [sp+Ch] [bp-268h]@1
  HINF InfHandle; // [sp+10h] [bp-264h]@1
  GUID *rguid; // [sp+14h] [bp-260h]@1
  wchar_t pszDest; // [sp+18h] [bp-25Ch]@1
  OLECHAR sz; // [sp+220h] [bp-54h]@5

  InfHandle = (HINF)a1;
  rguid = (GUID *)a4;
  Type = 520;
  v5 = HrRegQueryTypeSzBuffer(hKey, L"InfSection", 1u, (LPBYTE)&pszDest, (DWORD)&Type);
  if ( !v5 )
  {
    StringCchCatW(&pszDest, 0x104u, L".Remove");
    if ( a5 )
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
        a5,
        &pszDest);
    v5 = HrCiDoCompleteSectionInstall(InfHandle, hKey, &pszDest, 0, 0);
  }
  HrCiRegisterNotificationDll(hKey, 1, 1);
  StringFromGUID2(rguid, &sz, 39);
  HrCiRegDeleteComponentNetworkKey(a3, &sz);
  if ( v5 == 1 )
    v5 = 0;
  return v5;
}

//----- (6E66A492) --------------------------------------------------------
__int32 __stdcall HrCiRemoveComponent(CComponent *a1, int a2)
{
  int v2; // eax@1
  __int32 v3; // edi@1
  int v5; // [sp+Ch] [bp-38h]@1
  int v6; // [sp+10h] [bp-34h]@4
  int v7; // [sp+14h] [bp-30h]@1
  void *v8; // [sp+18h] [bp-2Ch]@1
  HKEY hKey; // [sp+1Ch] [bp-28h]@1
  HDEVINFO DeviceInfoSet; // [sp+20h] [bp-24h]@1
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+24h] [bp-20h]@3

  v7 = a2;
  v2 = *((_DWORD *)a1 + 4);
  v8 = 0;
  DeviceInfoSet = 0;
  hKey = 0;
  v3 = 0;
  v5 = v2;
  if ( FIsConsideredNetClass(v2) )
  {
    if ( !(*((_BYTE *)a1 + 24) & 4) )
    {
      v3 = HrOpenDeviceInfo(v5, *((const WCHAR **)a1 + 8), &DeviceInfoSet, &DeviceInfoData);
      if ( !v3 )
      {
        v6 = 0;
        v7 = 0;
        CiSetReservedField(DeviceInfoSet, &DeviceInfoData, &v6);
        v3 = HrSetupDiCallClassInstaller(5u, DeviceInfoSet, &DeviceInfoData);
        CiClearReservedField(DeviceInfoSet, &DeviceInfoData);
        if ( !v3 )
          v3 = FSetupDiCheckIfRestartNeeded(DeviceInfoSet, &DeviceInfoData) != 0 ? 0x4A020 : 0;
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      }
    }
  }
  else
  {
    v3 = CComponent::HrOpenInstanceKey(a1, 0xF003Fu, &hKey, 0, 0);
    if ( !v3 )
    {
      if ( *((_DWORD *)a1 + 4) == 3 )
        v3 = HrCiDeleteNetProviderInfo(hKey, 0, 0);
      if ( !v3 )
      {
        v3 = CComponent::HrOpenInfFile(a1, &v8);
        if ( !v3 )
          v3 = HrCiRemoveNonEnumeratedComponent((int)v8, hKey, *((_DWORD *)a1 + 4), (int)a1, v7);
      }
    }
    RegSafeCloseKey(hKey);
  }
  return v3;
}

//----- (6E66A5C8) --------------------------------------------------------
__int32 __stdcall HrCiInstallNonEnumeratedComponent(void *a1, HKEY hKey, struct COMPONENT_INSTALL_INFO *a3)
{
  __int32 v3; // ebx@1
  bool v4; // sf@1
  BYTE Data; // [sp+10h] [bp-20Ch]@2

  v3 = HrCiRegisterNotificationDll(hKey, 0, 0);
  v4 = v3 < 0;
  if ( !v3 )
  {
    v3 = HrCiDoOemFileCopyIfNeeded(*((wchar_t **)a3 + 2), (unsigned __int16 *)&Data, 0x104u);
    v4 = v3 < 0;
    if ( !v3 )
    {
      v3 = HrRegSetSz(hKey, L"InfPath", &Data);
      v4 = v3 < 0;
      if ( !v3 )
      {
        if ( *(_DWORD *)a3 != 3 )
          return v3;
        v3 = HrCiAddNetProviderInfo(a1, *((const unsigned __int16 **)a3 + 10), hKey, *((_DWORD *)a3 + 8));
        v4 = v3 < 0;
      }
    }
  }
  if ( v4 && !*((_DWORD *)a3 + 8) )
    HrCiRemoveNonEnumeratedComponent((int)a1, hKey, *(_DWORD *)a3, (int)((char *)a3 + 16), 0);
  return v3;
}

//----- (6E66A680) --------------------------------------------------------
__int32 __stdcall HrCiIsInstalledComponent(struct COMPONENT_INSTALL_INFO *a1, HKEY *a2)
{
  bool v2; // sf@9
  HKEY v3; // ST14_4@12
  CComponent *v4; // ecx@21
  CComponent *v5; // esi@21
  char *v6; // edi@21
  char v8; // [sp+Ch] [bp-1ACh]@19
  DWORD v9; // [sp+138h] [bp-80h]@10
  int v10; // [sp+13Ch] [bp-7Ch]@1
  CComponent *v11; // [sp+140h] [bp-78h]@1
  SP_LOG_TOKEN LogToken; // [sp+144h] [bp-74h]@1
  DWORD Type; // [sp+14Ch] [bp-6Ch]@5
  HKEY hKey; // [sp+150h] [bp-68h]@4
  HRESULT v15; // [sp+154h] [bp-64h]@4
  OLECHAR sz; // [sp+158h] [bp-60h]@13
  int v17; // [sp+1B4h] [bp-4h]@19

  v11 = (CComponent *)a2;
  v10 = 1;
  LogToken = SetupGetThreadLogToken();
  if ( a2 )
    *a2 = 0;
  if ( !FIsConsideredNetClass(*(_DWORD *)a1) )
  {
    CNetConfig::CNetConfig(&v8);
    v17 = 0;
    v15 = HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v8);
    if ( !v15 )
    {
      v11 = (CComponent *)CComponentList::PFindComponentByInfId((CComponentList *)&v8, *((wchar_t **)a1 + 1), 0);
      if ( v11 )
      {
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: Component already installed. This is an update.");
        v4 = v11;
        v10 = 0;
        v5 = v11;
        *((_DWORD *)a1 + 4) = *(_DWORD *)v11;
        v5 = (CComponent *)((char *)v5 + 4);
        *((_DWORD *)a1 + 5) = *(_DWORD *)v5;
        v5 = (CComponent *)((char *)v5 + 4);
        v6 = (char *)a1 + 24;
        *(_DWORD *)v6 = *(_DWORD *)v5;
        *((_DWORD *)v6 + 1) = *((_DWORD *)v5 + 1);
        if ( a2 )
          v15 = CComponent::HrOpenInstanceKey(v4, 0xF003Fu, a2, 0, 0);
      }
      else
      {
        _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: This is a fresh install.");
      }
    }
    v17 = -1;
    CNetConfig::~CNetConfig((CNetConfig *)&v8);
    goto LABEL_25;
  }
  v15 = HrSetupDiOpenDevRegKey(*((HDEVINFO *)a1 + 14), *((PSP_DEVINFO_DATA *)a1 + 15), 1u, 0, 2u, 0xF003Fu, &hKey);
  if ( v15 >= 0 )
  {
    Type = 0;
    v15 = HrRegQueryDword(hKey, L"NewDeviceInstall", (DWORD)&Type);
    if ( v15 >= 0 )
    {
      if ( Type )
      {
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: NewDeviceInstall is 1, assume new install");
      }
      else
      {
        v10 = 0;
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: NewDeviceInstall is 0. Assuming this is an update");
      }
    }
  }
  v2 = v15 < 0;
  if ( !v15 )
  {
    Type = 0;
    v9 = 78;
    if ( HrRegQueryDword(hKey, L"BootNic", (DWORD)&Type) >= 0 && Type == 1 )
    {
      v3 = hKey;
      *((_DWORD *)a1 + 17) = 1;
      HrRegDeleteValue(v3, L"BootNic");
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: BootNic is 1. Assuming this is an iSCSI NIC");
    }
    v15 = HrRegQueryTypeSzBuffer(hKey, L"NetCfgInstanceId", 1u, (LPBYTE)&sz, (DWORD)&v9);
    if ( !v15 )
      v15 = IIDFromString(&sz, (LPIID)a1 + 1);
    if ( v15 < 0 )
    {
      RegCloseKey(hKey);
    }
    else if ( v11 )
    {
      *(_DWORD *)v11 = hKey;
    }
LABEL_25:
    v2 = v15 < 0;
  }
  if ( !v2 && v10 )
    v15 = 1;
  return v15;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66A9F7) --------------------------------------------------------
signed int __stdcall HrCiCreateInstanceKeyAndProcessMainInfSection(HINF InfHandle, struct COMPONENT_INSTALL_INFO *IntegerValue, PHKEY phkResult)
{
  struct COMPONENT_INSTALL_INFO *v3; // ebx@1
  __int32 v4; // esi@5
  __int32 v5; // eax@10
  unsigned __int32 v7; // [sp+8h] [bp-10h]@4
  int v8; // [sp+Ch] [bp-Ch]@2
  DWORD Type; // [sp+10h] [bp-8h]@4
  HKEY hKey; // [sp+14h] [bp-4h]@1
  __int32 IntegerValuea; // [sp+24h] [bp+Ch]@1

  v3 = IntegerValue;
  hKey = 0;
  IntegerValuea = HrCiGetPropertiesFromInf(InfHandle, IntegerValue);
  if ( IntegerValuea )
    return IntegerValuea;
  v8 = FIsConsideredNetClass(*(_DWORD *)v3);
  if ( !v8 && *((_DWORD *)v3 + 9) & 0x40400 )
  {
    v7 = 0;
    Type = 0;
    if ( HrOpenNetworkKey(0x20019u, &hKey)
      || (v4 = HrRegQueryDword(hKey, L"MaxNumFilters", (DWORD)&Type), RegCloseKey(hKey), v4) )
      Type = 14;
    IntegerValuea = HrGetNumInstalledFilters(&v7);
    if ( IntegerValuea )
      return IntegerValuea;
    if ( v7 >= Type )
      return -2147180503;
  }
  v5 = HrCiIsInstalledComponent(v3, phkResult);
  IntegerValuea = v5;
  if ( v5 == 1 )
  {
    IntegerValuea = HrCiCreateInstanceKey(v3, phkResult);
    if ( v8 && !memcmp(&GUID_NULL, (char *)v3 + 16, 0x10u) )
      IntegerValuea = CoCreateGuid((GUID *)v3 + 1);
  }
  else
  {
    if ( v5 )
      return IntegerValuea;
    *((_DWORD *)v3 + 8) = 1;
  }
  if ( !IntegerValuea )
  {
    IntegerValuea = HrCiDoCompleteSectionInstall(InfHandle, *phkResult, *((wchar_t **)v3 + 10), *((HWND *)v3 + 3), v8);
    if ( IntegerValuea < 0 && !*((_DWORD *)v3 + 8) && !v8 )
      HrCiRemoveNonEnumeratedComponent((int)InfHandle, *phkResult, *(_DWORD *)v3, (int)((char *)v3 + 16), 0);
  }
  return IntegerValuea;
}

//----- (6E66AB51) --------------------------------------------------------
signed int __stdcall HrCiInstallComponentInternal(HKEY phkResult)
{
  const WCHAR *v1; // ST04_4@1
  signed int v2; // edi@1
  HINF v3; // eax@6
  int v5; // [sp+Ch] [bp-218h]@2
  HKEY hKey; // [sp+10h] [bp-214h]@1
  HINF InfHandle; // [sp+14h] [bp-210h]@1
  DWORD RequiredSize; // [sp+18h] [bp-20Ch]@2

  v1 = (const WCHAR *)*((_DWORD *)phkResult + 2);
  InfHandle = 0;
  hKey = 0;
  v2 = HrSetupOpenInfFile(v1, 0, 2u, 0, &InfHandle);
  if ( !v2 )
  {
    v5 = *((_DWORD *)phkResult + 10);
    v2 = HrSetupDiGetActualSectionToInstallWithBuffer(
           InfHandle,
           *((PCWSTR *)phkResult + 10),
           (DWORD)&RequiredSize,
           0x104u,
           0,
           0);
    if ( !v2 )
    {
      *((_DWORD *)phkResult + 10) = &RequiredSize;
      v2 = HrCiCreateInstanceKeyAndProcessMainInfSection(InfHandle, (struct COMPONENT_INSTALL_INFO *)phkResult, &hKey);
      if ( !v2 )
      {
        v2 = HrCiRegSetComponentInformation(hKey, phkResult);
        if ( !v2 )
        {
          if ( FIsConsideredNetClass(*(_DWORD *)phkResult) )
            v3 = HrCiInstallEnumeratedComponent(InfHandle, hKey, (const struct COMPONENT_INSTALL_INFO *)phkResult);
          else
            v3 = (HINF)HrCiInstallNonEnumeratedComponent(InfHandle, hKey, (struct COMPONENT_INSTALL_INFO *)phkResult);
          v2 = (signed int)v3;
        }
        RegSafeCloseKey(hKey);
      }
      *((_DWORD *)phkResult + 10) = v5;
    }
    SetupCloseInfFile(InfHandle);
  }
  return v2;
}

//----- (6E66AC52) --------------------------------------------------------
__int32 __stdcall HrCiInstallComponent(const struct COMPONENT_INSTALL_PARAMS *a1, struct CComponent **a2, unsigned __int32 *a3)
{
  void *v3; // eax@1
  SP_LOG_TOKEN v4; // rax@1
  int v5; // ST18_4@1
  __int32 v6; // edi@5
  int v7; // ecx@7
  __int32 v8; // eax@8
  struct CComponent **v9; // edi@19
  void *v11; // [sp+Ch] [bp-AA0h]@14
  struct CComponent **v12; // [sp+10h] [bp-A9Ch]@1
  SP_LOG_TOKEN LogToken; // [sp+14h] [bp-A98h]@1
  unsigned __int32 *v14; // [sp+1Ch] [bp-A90h]@1
  HKEY hKey; // [sp+20h] [bp-A8Ch]@1
  HDEVINFO DeviceInfoSet; // [sp+24h] [bp-A88h]@1
  void *lpMem; // [sp+28h] [bp-A84h]@1
  __int32 v18; // [sp+2Ch] [bp-A80h]@6
  struct _SP_DRVINFO_DATA_V2_W v19; // [sp+30h] [bp-A7Ch]@13
  struct _SP_DEVINSTALL_PARAMS_W v20; // [sp+64Ch] [bp-460h]@11
  int Dst; // [sp+878h] [bp-234h]@14
  int v22; // [sp+87Ch] [bp-230h]@14
  char *v23; // [sp+880h] [bp-22Ch]@14
  int v24; // [sp+884h] [bp-228h]@14
  int v25; // [sp+888h] [bp-224h]@16
  int v26; // [sp+88Ch] [bp-220h]@16
  int v27; // [sp+890h] [bp-21Ch]@16
  int v28; // [sp+894h] [bp-218h]@16
  unsigned __int32 v29; // [sp+89Ch] [bp-210h]@16
  char *v30; // [sp+8A0h] [bp-20Ch]@14
  WCHAR *v31; // [sp+8A4h] [bp-208h]@14
  char v32; // [sp+8A8h] [bp-204h]@14
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+8C0h] [bp-1ECh]@6
  int v34; // [sp+8DCh] [bp-1D0h]@7
  char v35; // [sp+8E0h] [bp-1CCh]@7
  int v36; // [sp+8E4h] [bp-1C8h]@8
  int v37; // [sp+8E8h] [bp-1C4h]@8
  int v38; // [sp+8ECh] [bp-1C0h]@7
  unsigned __int32 v39; // [sp+8F0h] [bp-1BCh]@8
  DWORD v40; // [sp+8F4h] [bp-1B8h]@12
  DWORD v41; // [sp+8F8h] [bp-1B4h]@12
  int v42; // [sp+8FCh] [bp-1B0h]@7
  WCHAR *v43; // [sp+900h] [bp-1ACh]@10
  int v44; // [sp+904h] [bp-1A8h]@8
  struct _SYSTEMTIME SystemTime; // [sp+908h] [bp-1A4h]@8
  WCHAR DeviceInstanceId; // [sp+918h] [bp-194h]@9

  v14 = a3;
  v3 = (void *)*(&MAP_NETCLASS_TO_GUID.Data1 + *(_DWORD *)a1);
  v12 = a2;
  DeviceInfoSet = 0;
  hKey = 0;
  lpMem = v3;
  v4 = SetupGetThreadLogToken();
  v5 = *((_DWORD *)a1 + 1);
  LogToken = v4;
  _SetupWriteTextLog(v4, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN CI: Installing %ws]", v5);
  if ( a2 )
    *a2 = 0;
  if ( v14 )
    *v14 = 0;
  v6 = HrSetupDiCreateDeviceInfoList((GUID *)lpMem, 0, &DeviceInfoSet);
  if ( !v6 )
  {
    v18 = HrCiGetDriverInfo(
            DeviceInfoSet,
            &DeviceInfoData,
            (const struct _GUID *)lpMem,
            *((const unsigned __int16 **)a1 + 1),
            *((const unsigned __int16 **)a1 + 2));
    if ( v18 )
    {
LABEL_26:
      SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      v6 = v18;
      goto LABEL_27;
    }
    v34 = 0;
    memset(&v35, 0, 0x24u);
    v7 = *((_DWORD *)a1 + 1);
    v38 = *(_DWORD *)a1;
    v42 = v7;
    if ( FIsConsideredNetClass(v38) )
    {
      v44 = 0;
      *(_DWORD *)&SystemTime.wYear = 0;
      *(_DWORD *)&SystemTime.wDayOfWeek = 0;
      *(_DWORD *)&SystemTime.wHour = 0;
      *(_DWORD *)&SystemTime.wSecond = 0;
      v8 = HrCiCallClassInstallerToInstallComponent(DeviceInfoSet, &DeviceInfoData, &v44);
      v39 = *(_DWORD *)&SystemTime.wSecond;
      v34 = v44;
      *(_DWORD *)&v35 = *(_DWORD *)&SystemTime;
      v36 = *(_DWORD *)&SystemTime.wDayOfWeek;
      v18 = v8;
      v37 = *(_DWORD *)&SystemTime.wHour;
      if ( !v8 )
      {
        if ( !HrSetupDiGetDeviceInstanceId(DeviceInfoSet, &DeviceInfoData, &DeviceInstanceId, 0xC8u, 0) )
          v43 = &DeviceInstanceId;
        v18 = HrSetupDiGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &v20);
        if ( v18 >= 0 )
        {
          v40 = v20.Flags;
          v41 = v20.FlagsEx;
        }
LABEL_18:
        if ( !v18 )
        {
          v9 = v12;
          if ( !v12
            || (v18 = CComponent::HrCreateInstance(
                        (const struct BASIC_COMPONENT_DATA *)&v34,
                        1,
                        *((const struct tagOBO_TOKEN **)a1 + 3),
                        (struct CComponent **)&lpMem)) == 0
            && (*v9 = (struct CComponent *)lpMem,
                SystemTime.wYear = 0,
                *(_DWORD *)&SystemTime.wMonth = 0,
                *(_DWORD *)&SystemTime.wDay = 0,
                *(_DWORD *)&SystemTime.wMinute = 0,
                SystemTime.wMilliseconds = 0,
                GetSystemTime(&SystemTime),
                (v18 = CComponent::HrOpenInstanceKey((CComponent *)lpMem, 0xF003Fu, &hKey, 0, 0)) == 0)
            && (v18 = HrRegSetValueEx(hKey, L"InstallTimeStamp", 3u, (BYTE *)&SystemTime, 0x10u),
                RegSafeCloseKey(hKey),
                !v18) )
          {
            if ( v14 )
              *v14 = v39;
          }
        }
        goto LABEL_25;
      }
    }
    else
    {
      lpMem = 0;
      v18 = HrCiGetDriverDetail(DeviceInfoSet, &DeviceInfoData, &v19, (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem);
      if ( !v18 )
      {
        memset(&Dst, 0, 0x48u);
        Dst = *(_DWORD *)a1;
        v22 = *((_DWORD *)a1 + 1);
        v30 = (char *)lpMem + 24;
        v23 = (char *)lpMem + 536;
        v24 = *((_DWORD *)a1 + 5);
        v31 = v19.Description;
        HrSetupGetIndirectStringsFromDriverInfoWithAlloc(
          (int)DeviceInfoSet,
          (int)&DeviceInfoData,
          (int)&v19,
          0,
          (int)&v32);
        v18 = HrSetupOpenInfFile((PCWSTR)lpMem + 268, 0, 2u, 0, &v11);
        if ( !v18 )
        {
          v18 = HrCiInstallComponentInternal((HKEY)&Dst);
          if ( !v18 )
          {
            v34 = v25;
            *(_DWORD *)&v35 = v26;
            v36 = v27;
            v37 = v28;
            v39 = v29;
          }
        }
        MemFree(lpMem);
        goto LABEL_18;
      }
    }
LABEL_25:
    SetupDiDestroyDriverInfoList(DeviceInfoSet, &DeviceInfoData, 2u);
    goto LABEL_26;
  }
LABEL_27:
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "[NCI END CI: Installing %ws. Result: 0x%08X]",
    *((_DWORD *)a1 + 1),
    v6);
  return v6;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66B0E8) --------------------------------------------------------
__int32 __stdcall HrCiSelectComponent(int a1, HWND hwndParent, void *a3, int a4)
{
  __int32 v4; // edi@1
  void *v5; // edi@6
  unsigned int v6; // ebx@6
  void *v7; // edx@6
  char v9; // [sp+Ch] [bp-768h]@2
  HWND v10; // [sp+138h] [bp-63Ch]@1
  void *v11; // [sp+13Ch] [bp-638h]@1
  void *lpMem; // [sp+140h] [bp-634h]@5
  HDEVINFO DeviceInfoSet; // [sp+144h] [bp-630h]@1
  struct _SP_DRVINFO_DATA_V2_W Dst; // [sp+148h] [bp-62Ch]@5
  int v15; // [sp+770h] [bp-4h]@2

  v11 = a3;
  v10 = hwndParent;
  v4 = HrSetupDiCreateDeviceInfoList(*((GUID **)&MAP_NETCLASS_TO_GUID.Data1 + a1), hwndParent, &DeviceInfoSet);
  if ( !v4 )
  {
    CNetConfig::CNetConfig(&v9);
    v15 = 0;
    v4 = HrLoadNetworkConfigurationFromRegistry(0x20019u, (struct CNetConfig *)&v9);
    if ( !v4 )
    {
      v4 = HrCiBuildExcludedDriverList(DeviceInfoSet, a1, (int)&v9);
      if ( !v4 )
      {
        CiSetReservedField(DeviceInfoSet, 0, v11);
        HrSetupDiSetDeipFlags(DeviceInfoSet, 0, 1, 0, 1);
        v4 = HrSetupDiCallClassInstaller(1u, DeviceInfoSet, 0);
        if ( !v4 )
        {
          v4 = HrCiGetDriverDetail(DeviceInfoSet, 0, &Dst, (struct _SP_DRVINFO_DETAIL_DATA_W **)&lpMem);
          if ( !v4 )
          {
            v5 = lpMem;
            v6 = CbOfSzAndTerm((const unsigned __int16 *)lpMem + 784);
            v11 = (void *)CbOfSzAndTerm((const unsigned __int16 *)v5 + 268);
            v4 = -2147024882;
            v7 = operator new(0x1Cu, (const struct extrabytes_t *)&extrabytes, (unsigned __int32)((char *)v11 + v6));
            *(_DWORD *)a4 = v7;
            if ( v7 )
            {
              memset(v7, 0, 0x1Cu);
              **(_DWORD **)a4 = a1;
              *(_DWORD *)(*(_DWORD *)a4 + 20) = v10;
              *(_DWORD *)(*(_DWORD *)a4 + 4) = *(_DWORD *)a4 + 28;
              StringCbCopyW(*(unsigned __int16 **)(*(_DWORD *)a4 + 4), v6, (const unsigned __int16 *)lpMem + 784);
              *(_DWORD *)(*(_DWORD *)a4 + 8) = v6 + *(_DWORD *)(*(_DWORD *)a4 + 4);
              StringCbCopyW(
                *(unsigned __int16 **)(*(_DWORD *)a4 + 8),
                (unsigned int)v11,
                (const unsigned __int16 *)lpMem + 268);
              v4 = 0;
            }
            MemFree(lpMem);
          }
        }
        CiClearReservedField(DeviceInfoSet, 0);
      }
    }
    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    v15 = -1;
    CNetConfig::~CNetConfig((CNetConfig *)&v9);
  }
  return v4;
}

//----- (6E66B2C0) --------------------------------------------------------
__int32 __stdcall HrCiCreateAndWaitForIndexListMutex(void **a1)
{
  DWORD v1; // eax@5
  MSG Msg; // [sp+8h] [bp-84h]@3
  HANDLE *pHandles; // [sp+24h] [bp-68h]@1
  __int32 v5; // [sp+28h] [bp-64h]@1
  WCHAR Name; // [sp+2Ch] [bp-60h]@1

  qmemcpy(&Name, L"Global\\{84b06608-8026-11d2-b1f2-00c04fd912b2}", 0x5Cu);
  pHandles = a1;
  v5 = HrCreateMutexWithWorldAccess(&Name, 0, 0, a1);
  if ( !v5 )
  {
    while ( 1 )
    {
      v1 = MsgWaitForMultipleObjects(1u, pHandles, 0, 0x7530u, 0x4FFu);
      if ( v1 != 1 )
        break;
      while ( PeekMessageW(&Msg, 0, 0, 0, 1u) )
        DispatchMessageW(&Msg);
    }
    if ( v1 == 258 )
    {
      v5 = -2147023436;
    }
    else if ( v1 == -1 )
    {
      v5 = HrFromLastWin32Error();
    }
  }
  return v5;
}
// 6E66B380: using guessed type wchar_t aGlobal84b06608[46];

//----- (6E66B3E1) --------------------------------------------------------
int __stdcall HrCiAddNextAvailableIndex(wchar_t *Str, unsigned __int32 *a2, unsigned __int16 **a3)
{
  wchar_t *v3; // esi@1
  signed int v4; // ebx@1
  wchar_t *EndPtr; // [sp+Ch] [bp-24h]@2
  unsigned __int32 *v7; // [sp+10h] [bp-20h]@1
  wchar_t *Str1; // [sp+14h] [bp-1Ch]@1
  unsigned __int32 v9; // [sp+18h] [bp-18h]@1
  int v10; // [sp+1Ch] [bp-14h]@1
  wchar_t Dest; // [sp+20h] [bp-10h]@5

  v3 = Str;
  v7 = a2;
  Str1 = Str;
  v10 = 0;
  *a3 = 0;
  v9 = 0;
  v4 = 1;
  while ( wcstoul(v3, &EndPtr, 10) == v4 )
  {
    ++v9;
    ++v4;
    v3 += wcslen(v3) + 1;
    if ( (unsigned int)v4 >= 0x2711 )
      goto LABEL_6;
  }
  StringCchPrintfW(&Dest, 6u, L"%u", v4);
  v10 = HrAddSzToMultiSz(&Dest, Str1, 8u, v9, a3, &v10);
  if ( v10 )
    return v10;
LABEL_6:
  *v7 = v4;
  return v10;
}

//----- (6E66B499) --------------------------------------------------------
signed int __stdcall HrCiUpdateDescriptionIndexList(int a1, const WCHAR *a2, int a3, unsigned __int32 *a4)
{
  signed int v4; // esi@1
  unsigned __int32 v5; // ecx@2
  __int32 v6; // eax@3
  BYTE *v7; // eax@5
  int v9; // [sp+Ch] [bp-230h]@7
  HANDLE hMutex; // [sp+10h] [bp-22Ch]@1
  void *lpMem; // [sp+14h] [bp-228h]@4
  LPCWSTR lpValueName; // [sp+18h] [bp-224h]@1
  wchar_t *Str1; // [sp+1Ch] [bp-220h]@3
  HKEY hKey; // [sp+20h] [bp-21Ch]@2
  wchar_t pszDest; // [sp+24h] [bp-218h]@2
  wchar_t Dest; // [sp+22Ch] [bp-10h]@7

  lpValueName = a2;
  hMutex = 0;
  v4 = HrCiCreateAndWaitForIndexListMutex(&hMutex);
  if ( !v4 )
  {
    StringCchCopyW(&pszDest, 0x104u, (&MAP_NETCLASS_TO_NETWORK_SUBTREE)[2 * a1]);
    StringCchCatW(&pszDest, 0x104u, L"\\");
    StringCchCatW(&pszDest, 0x104u, L"Descriptions");
    v4 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0, 0x3001Fu, 0, &hKey, 0);
    if ( v4 )
    {
LABEL_20:
      ReleaseMutex(hMutex);
      CloseHandle(hMutex);
      return v4;
    }
    v6 = HrRegGetMultiSzWithAlloc(v5, hKey, lpValueName, &Str1);
    v4 = v6;
    if ( v6 )
    {
      if ( v6 == -2147024894 && !a3 )
      {
        v4 = HrRegAddStringToMultiSz(L"1", hKey, 0, lpValueName, 2u, 0);
        if ( !v4 )
          *a4 = 1;
      }
      goto LABEL_19;
    }
    lpMem = 0;
    if ( !a3 )
    {
      v4 = HrCiAddNextAvailableIndex(Str1, a4, (unsigned __int16 **)&lpMem);
      v7 = (BYTE *)lpMem;
LABEL_11:
      if ( !v4 && v7 )
        v4 = HrRegSetMultiSz(hKey, lpValueName, v7);
      goto LABEL_14;
    }
    if ( a3 == 1 )
    {
      StringCchPrintfW(&Dest, 6u, L"%u", *a4);
      RemoveSzFromMultiSz(&Dest, Str1, 32, &v9);
      if ( v9 )
      {
        if ( CchOfMultiSzSafe(Str1) )
        {
          v7 = (BYTE *)Str1;
          goto LABEL_11;
        }
        HrRegDeleteValue(hKey, lpValueName);
      }
    }
LABEL_14:
    MemFree(lpMem);
    MemFree(Str1);
LABEL_19:
    RegCloseKey(hKey);
    goto LABEL_20;
  }
  return v4;
}

//----- (6E66B6B1) --------------------------------------------------------
void __stdcall CiSetFriendlyNameIfNeeded(const struct COMPONENT_INSTALL_INFO *a1)
{
  unsigned int v1; // kr00_4@2
  unsigned int v2; // eax@13
  DWORD RequiredSize; // [sp+Ch] [bp-22Ch]@2
  DWORD PropertyRegDataType; // [sp+10h] [bp-228h]@2
  HKEY hKey; // [sp+14h] [bp-224h]@4
  int v6; // [sp+18h] [bp-220h]@5
  DWORD Type; // [sp+1Ch] [bp-21Ch]@5
  int v8; // [sp+20h] [bp-218h]@1
  BYTE PropertyBuffer[2]; // [sp+24h] [bp-214h]@1
  char Dst; // [sp+26h] [bp-212h]@1
  wchar_t pszSrc; // [sp+228h] [bp-10h]@11

  *(_WORD *)PropertyBuffer = 0;
  v8 = 0;
  memset(&Dst, 0, 0x200u);
  if ( !wcsstr(*((const wchar_t **)a1 + 2), L"rndiscmp.inf")
    || (SetupDiGetDeviceRegistryPropertyW(
          *((HDEVINFO *)a1 + 14),
          *((PSP_DEVINFO_DATA *)a1 + 15),
          0,
          &PropertyRegDataType,
          PropertyBuffer,
          0x200u,
          &RequiredSize),
        v1 = wcslen((const unsigned __int16 *)PropertyBuffer),
        v8 = v1 != 0,
        v1 == 0) )
    StringCchCopyNW((unsigned __int16 *)PropertyBuffer, 0x101u, *((const unsigned __int16 **)a1 + 11), 0xFAu);
  if ( !HrSetupDiCreateDevRegKey(*((HDEVINFO *)a1 + 14), *((PSP_DEVINFO_DATA *)a1 + 15), 1u, 0, 1u, 0, 0, &hKey) )
  {
    v6 = HrRegQueryDword(hKey, L"InstanceIndex", (DWORD)&Type);
    if ( v6 == -2147024894 )
    {
      v6 = HrCiUpdateDescriptionIndexList(*(_DWORD *)a1, (const WCHAR *)PropertyBuffer, 0, &Type);
      if ( v6 )
      {
LABEL_12:
        if ( v8 )
        {
          v2 = CbOfSzAndTerm((const unsigned __int16 *)PropertyBuffer);
          HrSetupDiSetDeviceRegistryProperty(
            *((HDEVINFO *)a1 + 14),
            *((PSP_DEVINFO_DATA *)a1 + 15),
            0xCu,
            PropertyBuffer,
            v2);
        }
        RegCloseKey(hKey);
        return;
      }
      HrRegSetDword(hKey, L"InstanceIndex", Type);
    }
    if ( !v6 && Type != 1 && !FIsFilterDevice(*((HDEVINFO *)a1 + 14), *((PSP_DEVINFO_DATA *)a1 + 15)) )
    {
      StringCchPrintfW(&pszSrc, 6u, L"%u", Type);
      StringCchCatW((STRSAFE_LPWSTR)PropertyBuffer, 0x101u, L" #");
      StringCchCatW((STRSAFE_LPWSTR)PropertyBuffer, 0x101u, &pszSrc);
      v8 = 1;
    }
    goto LABEL_12;
  }
}

//----- (6E66B8E3) --------------------------------------------------------
signed int __thiscall CNotifyObjectInterface::HrQueryPropertyUi(CNotifyObjectInterface *this, struct CImplINetCfg *a2, struct IUnknown *a3)
{
  CNotifyObjectInterface *v3; // esi@1
  signed int result; // eax@4
  int v5; // [sp+28h] [bp+Ch]@4

  v3 = this;
  if ( *(_DWORD *)this && *(_DWORD *)(*(_DWORD *)this + 8) && *((_BYTE *)this - 88) & 0x80 )
  {
    CImplINetCfg::RaiseRpl((int)a2, 1);
    v5 = (*(int (__stdcall **)(_DWORD, struct IUnknown *))(**(_DWORD **)(*(_DWORD *)v3 + 8) + 12))(
           *(_DWORD *)(*(_DWORD *)v3 + 8),
           a3);
    CImplINetCfg::LowerRpl((int)a2, 1);
    result = v5;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6E66B956) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::SetUiContext(CNotifyObjectInterface *this, struct CImplINetCfg *a2, struct IUnknown *a3)
{
  CNotifyObjectInterface *v3; // esi@1
  int v4; // [sp-4h] [bp-20h]@0
  int v5; // [sp+0h] [bp-1Ch]@0
  int v6; // [sp+4h] [bp-18h]@0
  int v7; // [sp+8h] [bp-14h]@0
  int v8; // [sp+Ch] [bp-10h]@0
  int v9; // [sp+10h] [bp-Ch]@0
  int v10; // [sp+14h] [bp-8h]@0
  int savedregs; // [sp+1Ch] [bp+0h]@0

  v3 = this;
  CImplINetCfg::RaiseRpl((int)a2, 1);
  (*(void (__stdcall **)(_DWORD, struct IUnknown *, int, int, int, int, int, int, int, _DWORD, int))(**(_DWORD **)(*(_DWORD *)v3 + 8) + 16))(
    *(_DWORD *)(*(_DWORD *)v3 + 8),
    a3,
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    0,
    savedregs);
  CImplINetCfg::LowerRpl((int)a2, 1);
}

//----- (6E66B996) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E66B996@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 4) = -1;
  return &loc_6E66B984;
}

//----- (6E66B9A5) --------------------------------------------------------
int __thiscall CNotifyObjectInterface::QueryNotifyObject(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct _GUID *a3, void **a4)
{
  CNotifyObjectInterface *v4; // esi@1
  int result; // eax@1
  int v6; // eax@2

  *a4 = 0;
  v4 = this;
  result = CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(this, a2, 0);
  if ( !result )
  {
    v6 = *(_DWORD *)v4;
    if ( *(_DWORD *)v4 && *(_DWORD *)v6 )
      result = (*(int (__stdcall **)(int (__stdcall ***)(_DWORD, _DWORD, _DWORD), const struct _GUID *, void **))**(int (__stdcall ****)(_DWORD, _DWORD, _DWORD))v6)(
                 *(int (__stdcall ****)(_DWORD, _DWORD, _DWORD))v6,
                 a3,
                 a4);
    else
      result = -2147467262;
  }
  return result;
}

//----- (6E66B9EA) --------------------------------------------------------
int __thiscall CNotifyObjectInterface::NewlyAdded(CNotifyObjectInterface *this, struct CImplINetCfg *a2, const struct NETWORK_INSTALL_PARAMS *a3)
{
  CNotifyObjectInterface *v3; // ebx@1
  int result; // eax@1
  int v5; // ST3C_4@7
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-2Ch]@1
  CNotifyObjectInterface *v7; // [sp+1Ch] [bp-20h]@1
  signed int v8; // [sp+20h] [bp-1Ch]@5

  v3 = this;
  v7 = this;
  LogToken = SetupGetThreadLogToken();
  result = CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(v3, a2, 1);
  if ( !result && *(_DWORD *)v3 && *(_DWORD *)(*(_DWORD *)v3 + 12) )
  {
    if ( a3 )
      v8 = *(_DWORD *)a3;
    else
      v8 = 2;
    CImplINetCfg::RaiseRpl((int)a2, 0);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Calling %ws notify object Install fcn",
      *((_DWORD *)v3 - 21));
    v5 = (*(int (__stdcall **)(_DWORD, signed int))(**(_DWORD **)(*(_DWORD *)v7 + 12) + 12))(
           *(_DWORD *)(*(_DWORD *)v7 + 12),
           v8);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: %ws returned 0x%08X",
      *((_DWORD *)v3 - 21),
      v5);
    if ( v5 >= 0 && a3 && *((_DWORD *)a3 + 2) )
    {
      if ( *((_DWORD *)a3 + 3) )
      {
        CImplINetCfg::RaiseRpl((int)a2, 1);
        (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(*(_DWORD *)v7 + 12) + 20))(
          *(_DWORD *)(*(_DWORD *)v7 + 12),
          *((_DWORD *)a3 + 2),
          *((_DWORD *)a3 + 3));
        CImplINetCfg::LowerRpl((int)a2, 1);
      }
    }
    CImplINetCfg::LowerRpl((int)a2, 0);
    result = 0;
  }
  return result;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66BBFD) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::Removed(CNotifyObjectInterface *this, struct CImplINetCfg *a2)
{
  CNotifyObjectInterface *v2; // esi@1
  SP_LOG_TOKEN LogToken; // ST28_8@3

  v2 = this;
  if ( *(_DWORD *)this )
  {
    if ( *(_DWORD *)(*(_DWORD *)this + 12) )
    {
      LogToken = SetupGetThreadLogToken();
      CImplINetCfg::RaiseRpl((int)a2, 0);
      _SetupWriteTextLog(
        LogToken,
        0x40000000u,
        5 - (g_IsInUpgrade != 0),
        "NCI: Calling %ws Removing",
        *((_DWORD *)v2 - 21));
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(*(_DWORD *)v2 + 12) + 24))(*(_DWORD *)(*(_DWORD *)v2 + 12));
      CImplINetCfg::LowerRpl((int)a2, 0);
    }
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66BD29) --------------------------------------------------------
void __thiscall CNotifyObjectInterface::Updated(CNotifyObjectInterface *this, struct CImplINetCfg *a2, unsigned __int32 a3, unsigned __int32 a4)
{
  CNotifyObjectInterface *v4; // edi@1
  SP_LOG_TOKEN LogToken; // ST2C_8@3
  int v6; // edi@3
  CNotifyObjectInterface *v7; // [sp+1Ch] [bp-1Ch]@1
  unsigned __int32 v8; // [sp+48h] [bp+10h]@3

  v4 = this;
  v7 = this;
  if ( *(_DWORD *)this && *(_DWORD *)(*(_DWORD *)this + 12) )
  {
    LogToken = SetupGetThreadLogToken();
    v6 = (int)((char *)v4 - 112);
    CImplINetCfg::RaiseRpl((int)a2, 0);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Update called on Notify Object for %ws",
      *(_DWORD *)(v6 + 28));
    v8 = (*(int (__stdcall **)(_DWORD, unsigned __int32, unsigned __int32))(**(_DWORD **)(*(_DWORD *)v7 + 12) + 16))(
           *(_DWORD *)(*(_DWORD *)v7 + 12),
           a3,
           a4);
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "NCI: Notify Object update fcn for %ws complete. Result 0x%08X",
      *(_DWORD *)(v6 + 28),
      v8);
    if ( !v8 )
      CModifyContext::HrDirtyComponent((CModifyContext *)(*((_DWORD *)a2 + 12) + 72), (const struct CComponent *)v6);
    CImplINetCfg::LowerRpl((int)a2, 0);
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66BF01) --------------------------------------------------------
int __thiscall CBindingSet::PGetBindPathAtIndex(void *this, int a2, unsigned int a3)
{
  void *v3; // esi@1
  int result; // eax@4
  unsigned int v5; // [sp+10h] [bp+Ch]@2

  v3 = this;
  if ( a3 >= std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)this + 4)) )
    v5 = *((_DWORD *)v3 + 3);
  else
    v5 = *((_DWORD *)v3 + 2) + 20 * a3;
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}

//----- (6E66BF3D) --------------------------------------------------------
void __thiscall CGlobalNotifyInterface::ReleaseAllNotifyObjects(CGlobalNotifyInterface *this, struct CComponentList *a2, int a3)
{
  struct CImplINetCfg *v3; // ebx@1
  int v4; // esi@3
  CGlobalNotifyInterface *v5; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v5 = this;
  if ( a3 )
    v3 = (struct CImplINetCfg *)*((_DWORD *)this + 1);
  v4 = *((_DWORD *)a2 + 2);
  if ( v4 != *((_DWORD *)a2 + 3) )
  {
    do
    {
      CNotifyObjectInterface::ReleaseNotifyObject((CNotifyObjectInterface *)(*(_DWORD *)v4 + 112), v3, a3);
      v4 += 4;
    }
    while ( v4 != *((_DWORD *)a2 + 3) );
    this = v5;
  }
  *(_DWORD *)this = 0;
}

//----- (6E66BF86) --------------------------------------------------------
int __thiscall CGlobalNotifyInterface::NgSysNotifyComponent(CGlobalNotifyInterface *this, unsigned __int32 a2, struct CComponent *a3)
{
  CGlobalNotifyInterface *v3; // esi@1
  int result; // eax@1
  int v5; // edi@3
  int v6; // eax@11
  int v7; // esi@13
  int v8; // eax@13
  int v9; // eax@15
  SP_LOG_TOKEN LogToken; // [sp+10h] [bp-44h]@1
  int v11; // [sp+1Ch] [bp-38h]@11
  signed int v12; // [sp+20h] [bp-34h]@2
  struct IUnknown *v13; // [sp+24h] [bp-30h]@2
  CGlobalNotifyInterface *v14; // [sp+28h] [bp-2Ch]@1
  int v15; // [sp+2Ch] [bp-28h]@12
  int v16; // [sp+30h] [bp-24h]@17
  unsigned __int32 v17; // [sp+34h] [bp-20h]@17
  int v18; // [sp+38h] [bp-1Ch]@3
  CPPEH_RECORD ms_exc; // [sp+3Ch] [bp-18h]@17

  v3 = this;
  v14 = this;
  LogToken = SetupGetThreadLogToken();
  result = CExternalComponentData::FLoadedOkayIfLoadedAtAll((struct CComponent *)((char *)a3 + 36));
  if ( result )
  {
    v12 = CComponent::HrGetINetCfgComponentInterface(
            a3,
            *((struct CImplINetCfg **)v3 + 1),
            (struct INetCfgComponent **)&v13);
    if ( !v12 )
    {
      v18 = 0;
      v5 = *((_DWORD *)a3 + 4);
      if ( FIsConsideredNetClass(v5) )
      {
        v18 = 0x10000;
      }
      else
      {
        switch ( v5 )
        {
          case 2:
            v18 = 0x20000;
            break;
          case 3:
            v18 = 0x40000;
            break;
          case 4:
            v18 = 0x80000;
            break;
        }
      }
      v11 = (int)((char *)v3 - 64);
      CImplINetCfg::RaiseRpl(*((_DWORD *)v3 + 1), 0);
      v6 = *((_DWORD *)v3 - 14);
      while ( 1 )
      {
        v15 = v6;
        if ( v6 == *(_DWORD *)(v11 + 12) )
          break;
        v7 = *(_DWORD *)v6;
        v8 = *(_DWORD *)(*(_DWORD *)v6 + 112);
        if ( v8 )
        {
          if ( *(_DWORD *)(v8 + 20) )
          {
            v9 = *(_DWORD *)(v8 + 24);
            if ( v9 & v18 )
            {
              if ( v9 & a2 )
              {
                ms_exc.registration.TryLevel = 0;
                v17 = a2 | v18;
                _SetupWriteTextLog(
                  LogToken,
                  0x40000000u,
                  5 - (g_IsInUpgrade != 0),
                  "[NCI BEGIN NO: Notifying %ws about %ws. Change flags: 0x%08X]",
                  *(_DWORD *)(v7 + 28),
                  *((_DWORD *)a3 + 7),
                  a2 | v18);
                v16 = (*(int (__stdcall **)(_DWORD, unsigned __int32, struct IUnknown *))(**(_DWORD **)(*(_DWORD *)(v7 + 112) + 20)
                                                                                        + 24))(
                        *(_DWORD *)(*(_DWORD *)(v7 + 112) + 20),
                        v17,
                        v13);
                _SetupWriteTextLog(
                  LogToken,
                  0x40000000u,
                  5 - (g_IsInUpgrade != 0),
                  "[NCI END NO: Notifying %ws about %ws. Change flags: 0x%08X]",
                  *(_DWORD *)(v7 + 28),
                  *((_DWORD *)a3 + 7),
                  v17);
                if ( v16 != 1 )
                {
                  _SetupWriteTextLog(
                    LogToken,
                    0x40000000u,
                    5 - (g_IsInUpgrade != 0),
                    "NCI: %ws returned 0x%08X",
                    *(_DWORD *)(v7 + 28),
                    v16);
                  v12 = CModifyContext::HrDirtyComponent(
                          (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v14 + 1) + 48) + 72),
                          (const struct CComponent *)v7);
                }
                ms_exc.registration.TryLevel = -2;
              }
            }
          }
        }
        v6 = v15 + 4;
        v3 = v14;
      }
      CImplINetCfg::LowerRpl(*((_DWORD *)v3 + 1), 0);
      ReleaseObj(v13);
    }
    result = v12;
  }
  return result;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66C271) --------------------------------------------------------
int __thiscall CGlobalNotifyInterface::ComponentAdded(CGlobalNotifyInterface *this, struct CComponent *a2, const struct NETWORK_INSTALL_PARAMS *a3)
{
  CGlobalNotifyInterface *v3; // esi@1
  int result; // eax@1

  v3 = this;
  result = CNotifyObjectInterface::NewlyAdded(
             (struct CComponent *)((char *)a2 + 112),
             *((struct CImplINetCfg **)this + 1),
             a3);
  if ( !result )
    result = CGlobalNotifyInterface::NgSysNotifyComponent(v3, 1u, a2);
  return result;
}

//----- (6E66C2A4) --------------------------------------------------------
int __thiscall CGlobalNotifyInterface::ComponentRemoved(CGlobalNotifyInterface *this, struct CComponent *a2)
{
  CGlobalNotifyInterface *v2; // esi@1

  v2 = this;
  CNotifyObjectInterface::Removed((struct CComponent *)((char *)a2 + 112), *((struct CImplINetCfg **)this + 1));
  return CGlobalNotifyInterface::NgSysNotifyComponent(v2, 2u, a2);
}

//----- (6E66C2D0) --------------------------------------------------------
int __thiscall CGlobalNotifyInterface::ComponentUpdated(CGlobalNotifyInterface *this, struct CComponent *a2, unsigned __int32 a3, unsigned __int32 a4)
{
  CGlobalNotifyInterface *v4; // esi@1

  v4 = this;
  CNotifyObjectInterface::Updated((struct CComponent *)((char *)a2 + 112), *((struct CImplINetCfg **)this + 1), a3, a4);
  return CGlobalNotifyInterface::NgSysNotifyComponent(v4, 4u, a2);
}

//----- (6E66C302) --------------------------------------------------------
__int32 __thiscall CGlobalNotifyInterface::QueryAndNotifyBindPaths(CGlobalNotifyInterface *this, unsigned __int32 a2, struct CBindingSet *a3, unsigned int a4)
{
  char *v4; // eax@2
  struct CBindingSet *v5; // edi@4
  int v6; // eax@4
  unsigned int v7; // esi@4
  int v8; // ebx@4
  int v9; // eax@5
  CGlobalNotifyInterface *v11; // [sp+0h] [bp-4h]@1
  signed int v12; // [sp+Ch] [bp+8h]@2

  v11 = this;
  if ( a2 & 1 )
  {
    v12 = 17;
    v4 = "Query and notify the following bindings:\n";
  }
  else
  {
    v12 = 2;
    v4 = "Notify the following bindings are removed:\n";
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, v4);
  v5 = a3;
  v6 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)a3 + 4));
  v7 = a4;
  v8 = v6;
  while ( v7 < v8 )
  {
    v9 = CBindingSet::PGetBindPathAtIndex((void *)v5, (int)&a3, v7);
    CGlobalNotifyInterface::NotifyBindPath(v11, v12, *(struct CBindPath **)v9, 0);
    ++v7;
  }
  return 0;
}

//----- (6E66C3D7) --------------------------------------------------------
signed int __thiscall CNotifyObjectInterface::HrShowPropertyUi(CNotifyObjectInterface *this, struct CImplINetCfg *a2, HWND a3, struct IUnknown *a4)
{
  CNotifyObjectInterface *v4; // ebx@1
  int v5; // ecx@5
  int v6; // ST00_4@5
  int v7; // eax@5
  int v8; // ecx@10
  int v9; // ST14_4@10
  int v10; // ecx@14
  int v11; // ST14_4@14
  signed int result; // eax@17
  int Dst; // [sp+Ch] [bp-70h]@7
  int v14; // [sp+10h] [bp-6Ch]@7
  HWND v15; // [sp+14h] [bp-68h]@7
  HMODULE v16; // [sp+18h] [bp-64h]@7
  int v17; // [sp+20h] [bp-5Ch]@7
  int v18; // [sp+40h] [bp-3Ch]@7
  LPVOID v19; // [sp+44h] [bp-38h]@7
  int v20; // [sp+48h] [bp-34h]@7
  int v21; // [sp+4Ch] [bp-30h]@7
  int v22; // [sp+50h] [bp-2Ch]@5
  unsigned __int16 *v23; // [sp+54h] [bp-28h]@5
  LPVOID pv; // [sp+58h] [bp-24h]@5
  CNotifyObjectInterface *v25; // [sp+5Ch] [bp-20h]@1
  struct CComponent *v26; // [sp+60h] [bp-1Ch]@7
  int v27; // [sp+64h] [bp-18h]@5
  int v28; // [sp+68h] [bp-14h]@5
  int v29; // [sp+78h] [bp-4h]@5
  HWND v30; // [sp+88h] [bp+Ch]@10

  v4 = this;
  v25 = this;
  if ( *(_DWORD *)this && *(_DWORD *)(*(_DWORD *)this + 8) )
  {
    if ( a4 )
      CNotifyObjectInterface::SetUiContext(this, a2, a4);
    v22 = 0;
    pv = 0;
    v27 = 0;
    v23 = 0;
    CImplINetCfg::RaiseRpl((int)a2, 1);
    v5 = **(_DWORD **)(*(_DWORD *)v4 + 8);
    v6 = *(_DWORD *)(*(_DWORD *)v4 + 8);
    v29 = 0;
    v7 = (*(int (__stdcall **)(int, int *, LPVOID *, int *, HWND, unsigned __int16 **))(v5 + 20))(
           v6,
           &v22,
           &pv,
           &v27,
           a3,
           &v23);
    v29 = -1;
    v28 = v7;
    CImplINetCfg::LowerRpl((int)a2, 1);
    if ( !v28 && v27 )
    {
      v26 = (CNotifyObjectInterface *)((char *)v4 - 112);
      memset(&Dst, 0, 0x34u);
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v15 = a3;
      v16 = hModule;
      v17 = *((_DWORD *)v4 - 18);
      v18 = v27;
      v19 = pv;
      v21 = *(_DWORD *)v4 + 8;
      Dst = 52;
      v14 = 129;
      v20 = 1;
      v28 = HrNetCfgPropertySheet(
              (LPCPROPSHEETHEADERW)&Dst,
              (const struct CAPAGES *)&v18,
              v23,
              (const struct CAINCP *)&v20);
      if ( v28 )
      {
        CImplINetCfg::RaiseRpl((int)a2, 1);
        v10 = **(_DWORD **)(*(_DWORD *)v4 + 8);
        v11 = *(_DWORD *)(*(_DWORD *)v4 + 8);
        v29 = 4;
        (*(void (__stdcall **)(int))(v10 + 32))(v11);
        v29 = -1;
        CImplINetCfg::LowerRpl((int)a2, 1);
      }
      else
      {
        if ( *((_DWORD *)a2 + 19) )
          CModifyContext::HrBeginBatchOperation((CModifyContext *)(*((_DWORD *)a2 + 12) + 72));
        v30 = 0;
        CImplINetCfg::RaiseRpl((int)a2, 0);
        v8 = **(_DWORD **)(*(_DWORD *)v4 + 8);
        v9 = *(_DWORD *)(*(_DWORD *)v4 + 8);
        v29 = 2;
        v28 = (*(int (__stdcall **)(int))(v8 + 28))(v9);
        if ( v28 == 303141 )
          v30 = (HWND)1;
        v29 = -1;
        CImplINetCfg::LowerRpl((int)a2, 0);
        if ( *((_DWORD *)a2 + 19) )
        {
          CModifyContext::HrDirtyComponent((CModifyContext *)(*((_DWORD *)a2 + 12) + 72), v26);
          CGlobalNotifyInterface::NgSysNotifyComponent(
            (CGlobalNotifyInterface *)(*((_DWORD *)a2 + 12) + 64),
            0x200u,
            v26);
          v28 = CModifyContext::HrEndBatchOperation(*((_DWORD *)a2 + 12) + 72, (v30 == 0) + 1);
        }
      }
    }
    CoTaskMemFree(pv);
    if ( a4 )
      CNotifyObjectInterface::SetUiContext(v4, a2, 0);
    result = v28;
  }
  else
  {
    result = -2147467262;
  }
  return result;
}

//----- (6E66C617) --------------------------------------------------------
int __cdecl wmemcmp(const wchar_t *S1, const wchar_t *S2, size_t N)
{
  const wchar_t *v3; // ecx@2
  const wchar_t *v4; // eax@2
  int result; // eax@5

  if ( N )
  {
    v3 = S2;
    v4 = S1;
    while ( *v4 == *v3 )
    {
      ++v4;
      ++v3;
      --N;
      if ( !N )
        goto LABEL_5;
    }
    result = *v4 < *v3 ? -1 : 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (6E66C650) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::capacity(int this)
{
  int v1; // edx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 4);
  if ( v1 )
    result = (*(_DWORD *)(this + 12) - v1) / 28;
  else
    result = 0;
  return result;
}

//----- (6E66C66B) --------------------------------------------------------
void *__stdcall std::_Allocate<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(28 * v2);
}

//----- (6E66C692) --------------------------------------------------------
signed int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(int this, unsigned int a2, unsigned int a3, wchar_t *S2, int N)
{
  unsigned int v5; // ebx@3
  int v6; // eax@5
  int v7; // esi@8
  signed int result; // eax@10

  if ( *(_DWORD *)(this + 20) < a2 )
    std::_String_base::_Xran();
  v5 = a3;
  if ( *(_DWORD *)(this + 20) - a2 < a3 )
    v5 = *(_DWORD *)(this + 20) - a2;
  v6 = N;
  if ( v5 < N )
    v6 = v5;
  if ( *(_DWORD *)(this + 24) < 8u )
    v7 = this + 4;
  else
    v7 = *(_DWORD *)(this + 4);
  result = wmemcmp((const wchar_t *)(v7 + 2 * a2), S2, v6);
  if ( !result )
  {
    if ( v5 >= N )
      result = v5 != N;
    else
      result = -1;
  }
  return result;
}

//----- (6E66C700) --------------------------------------------------------
int __thiscall CComponentReferences::CountTotalReferencedBy(CComponentReferences *this)
{
  int v1; // esi@1
  int result; // eax@2
  int v3; // edi@3

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v3 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v1 + 20);
    result = std::vector<CParam *,std::nc_allocator<CParam *>>::size(v1 + 4) + v3 + (*(_BYTE *)(v1 + 36) != 0);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E66C734) --------------------------------------------------------
__int32 __stdcall HrGetSoftwareOboTokenKey(const struct tagOBO_TOKEN *a1, int a2, HKEY hKey)
{
  const struct tagOBO_TOKEN *v3; // ebx@1
  LPCWSTR v4; // eax@1
  int v5; // edx@1
  const WCHAR v6; // cx@2
  int v7; // ecx@3
  LPCWSTR v8; // eax@3
  int v9; // edx@3
  const WCHAR v10; // si@4
  int v11; // edi@5
  unsigned __int16 *v12; // eax@5
  STRSAFE_LPWSTR *v13; // esi@5
  unsigned int v14; // edi@6
  __int32 v16; // [sp+14h] [bp+8h]@5

  v3 = a1;
  v4 = a1->pszwManufacturer;
  v5 = (int)(v4 + 1);
  do
  {
    v6 = *v4;
    ++v4;
  }
  while ( v6 );
  v7 = (signed int)((char *)v4 - v5) >> 1;
  v8 = a1->pszwProduct;
  v9 = (int)(v8 + 1);
  do
  {
    v10 = *v8;
    ++v8;
  }
  while ( v10 );
  v11 = ((signed int)((char *)v8 - v9) >> 1) + v7;
  v16 = -2147024882;
  v12 = (unsigned __int16 *)MemAlloc(2 * v11 + 2);
  v13 = (STRSAFE_LPWSTR *)hKey;
  *(_DWORD *)hKey = v12;
  if ( v12 )
  {
    v16 = 0;
    v14 = v11 + 1;
    StringCchCopyW(v12, v14, v3->pszwManufacturer);
    StringCchCatW(*v13, v14, v3->pszwProduct);
    if ( a2 )
    {
      v16 = HrRegCreateKeyEx(
              HKEY_LOCAL_MACHINE,
              L"SYSTEM\\CurrentControlSet\\Control\\Network\\RefNames",
              0,
              0x20006u,
              0,
              &hKey,
              0);
      if ( v16 < 0 )
      {
        MemFree(*v13);
        *v13 = 0;
      }
      else
      {
        v16 = HrRegSetSz(hKey, *v13, (BYTE *)v3->pszwDisplayName);
        if ( v16 < 0 )
        {
          MemFree(*v13);
          *v13 = 0;
        }
        RegCloseKey(hKey);
      }
    }
  }
  return v16;
}

//----- (6E66C809) --------------------------------------------------------
int __thiscall CComponentReferences::PSoftwareReferencedByAtIndex(void *this, int a2)
{
  int v2; // ecx@1
  int result; // eax@2

  v2 = *(_DWORD *)this;
  if ( v2 )
    result = *(_DWORD *)(v2 + 24) + 28 * a2;
  else
    result = 0;
  return result;
}

//----- (6E66C82A) --------------------------------------------------------
signed int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(int this, wchar_t *a2)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(
           this,
           0,
           *(_DWORD *)(this + 20),
           a2,
           wcslen(a2));
}

//----- (6E66C85C) --------------------------------------------------------
int __thiscall CComponentReferences::FIsReferencedByComponent(CComponentReferences *this, const struct CComponent *a2)
{
  CComponentList *v2; // ecx@1
  int result; // eax@2

  v2 = *(CComponentList **)this;
  if ( v2 )
    result = CComponentList::FComponentInList(v2, a2);
  else
    result = 0;
  return result;
}

//----- (6E66C878) --------------------------------------------------------
BOOL __cdecl std::operator==<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>>(int a1, wchar_t *a2)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::compare(
           a1,
           a2) == 0;
}

//----- (6E66C894) --------------------------------------------------------
void __thiscall CComponentReferences::GetReferenceDescriptionsAsMultiSz(CComponentReferences *this, LPBYTE lpData, unsigned __int32 *a3)
{
  unsigned __int32 v3; // eax@1
  unsigned __int16 *v4; // ebx@1
  void *v5; // edi@1
  int v6; // eax@1
  int v7; // esi@1
  int v8; // edi@2
  unsigned int v9; // eax@2
  int v10; // eax@9
  int i; // esi@9
  const WCHAR *v12; // eax@11
  unsigned __int32 v13; // eax@19
  HKEY hKey; // [sp+Ch] [bp-Ch]@1
  unsigned int v15; // [sp+10h] [bp-8h]@1
  unsigned int v16; // [sp+14h] [bp-4h]@1

  v3 = *a3;
  v16 = 0;
  v4 = (unsigned __int16 *)lpData;
  v5 = (void *)this;
  v15 = v3;
  v6 = *(_DWORD *)this;
  v7 = *(_DWORD *)(*(_DWORD *)this + 8);
  hKey = (HKEY)this;
  if ( v7 != *(_DWORD *)(v6 + 12) )
  {
    do
    {
      v8 = *(_DWORD *)v7;
      v9 = CbOfSzAndTermSafe(*(const unsigned __int16 **)(*(_DWORD *)v7 + 40));
      v16 += v9;
      lpData = (LPBYTE)v9;
      if ( v4 && v16 <= v15 )
      {
        StringCbCopyW(v4, v15 + v9 - v16, *(const unsigned __int16 **)(v8 + 40));
        v4 = (unsigned __int16 *)((char *)v4 + (_DWORD)lpData);
      }
      v7 += 4;
    }
    while ( v7 != *(_DWORD *)(*(_DWORD *)hKey + 12) );
    v5 = hKey;
  }
  if ( std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(*(_DWORD *)v5 + 20)
    && !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Network\\RefNames", 0x20019u, &hKey) )
  {
    v10 = *(_DWORD *)v5;
    for ( i = *(_DWORD *)(*(_DWORD *)v5 + 24); i != *(_DWORD *)(v10 + 28); i += 28 )
    {
      lpData = (LPBYTE)(v15 - v16);
      if ( *(_DWORD *)(i + 24) < 8u )
        v12 = (const WCHAR *)(i + 4);
      else
        v12 = *(const WCHAR **)(i + 4);
      if ( !HrRegQuerySzBuffer(hKey, v12, (LPBYTE)v4, (DWORD)&lpData) )
      {
        v16 += (unsigned int)lpData;
        if ( v4 )
          v4 = (unsigned __int16 *)((char *)v4 + (_DWORD)lpData);
      }
      v10 = *(_DWORD *)v5;
    }
    RegCloseKey(hKey);
  }
  v13 = v16 + 2;
  if ( v4 && v13 <= v15 )
    *v4 = 0;
  *a3 = v13;
}

//----- (6E66C998) --------------------------------------------------------
int __stdcall std::find<std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>,unsigned short const *>(int a1, int a2, int a3, wchar_t **a4)
{
  int result; // eax@5

  while ( a2 != a3
       && !(unsigned __int8)std::operator==<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>>(
                              a2,
                              *a4) )
    a2 += 28;
  result = a1;
  *(_DWORD *)a1 = a2;
  return result;
}

//----- (6E66C9E9) --------------------------------------------------------
void *__thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)lpMem,
    1,
    0);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E66CA13) --------------------------------------------------------
int __thiscall CComponentReferences::FIsReferencedByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *lpMem)
{
  CComponentList **v2; // esi@1
  int v3; // ecx@1
  int result; // eax@2
  const struct tagOBO_TOKEN *v5; // edi@3
  int v6; // ebx@3
  CComponentList *v7; // eax@8
  int v8; // esi@8
  struct INetCfgComponentVtbl *v9; // eax@10
  char v10; // [sp+4h] [bp-4h]@8

  v2 = (CComponentList **)this;
  v3 = *(_DWORD *)this;
  if ( v3 )
  {
    v5 = lpMem;
    v6 = 0;
    if ( lpMem->Type == 1 )
    {
      v6 = *(_BYTE *)(v3 + 36);
    }
    else if ( lpMem->Type == 2 )
    {
      if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4) )
      {
        v9 = PComponentFromComInterface(v5->pncc);
        v6 = CComponentList::FComponentInList(*v2, (const struct CComponent *)v9);
      }
    }
    else if ( lpMem->Type == 3
           && std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v3 + 20)
           && !HrGetSoftwareOboTokenKey(v5, 0, (HKEY)&lpMem) )
    {
      v7 = *v2;
      v8 = *((_DWORD *)*v2 + 7);
      LOBYTE(v6) = *(_DWORD *)std::find<std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>,unsigned short const *>(
                                (int)&v10,
                                *((_DWORD *)v7 + 6),
                                v8,
                                (wchar_t **)&lpMem) != v8;
      MemFree((void *)lpMem);
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E66CAAB) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 24) = 7;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
    this,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    v2,
    a2,
    0,
    -1);
  return v2;
}

//----- (6E66CADB) --------------------------------------------------------
int __cdecl std::_Copy_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(int a1, int a2, int a3, int a4)
{
  int i; // esi@1
  int result; // eax@4

  for ( i = a2; i != a3; i += 28 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(i);
    a4 += 28;
  }
  result = a1;
  *(_DWORD *)a1 = a4;
  return result;
}
// 6E66C9CF: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(_DWORD);

//----- (6E66CB08) --------------------------------------------------------
int __cdecl std::_Copy_backward_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2, int a3)
{
  int i; // esi@1

  for ( i = a2;
        i != a1;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(i) )
  {
    a3 -= 28;
    i -= 28;
  }
  return a3;
}
// 6E66C9CF: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(_DWORD);

//----- (6E66CB36) --------------------------------------------------------
void (__cdecl *__stdcall std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2))(int a1, int a2)
{
  void (__cdecl *result)(int, int); // eax@1

  result = sub_6E6930D4;
  if ( a1 )
    result = (void (__cdecl *)(int, int))std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
                                           a1,
                                           a2);
  return result;
}

//----- (6E66CB65) --------------------------------------------------------
void *__stdcall std::_Destroy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(void *lpMem)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::`scalar deleting destructor'(
           lpMem,
           0);
}

//----- (6E66CB7D) --------------------------------------------------------
int __cdecl std::copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(int a1, int a2, int a3, int a4)
{
  std::_Copy_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(
    a1,
    a2,
    a3,
    a4);
  return a1;
}

//----- (6E66CBAF) --------------------------------------------------------
int __cdecl std::fill<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(int a1, int a2, int a3)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = a1; i != a2; i += 28 )
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(a3);
  return result;
}
// 6E66C9CF: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(_DWORD);

//----- (6E66CBD4) --------------------------------------------------------
int __cdecl std::copy_backward<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(int a1, int a2, int a3)
{
  return std::_Copy_backward_opt<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(
           a1,
           a2,
           a3);
}

//----- (6E66CC00) --------------------------------------------------------
int __stdcall std::_Uninit_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int i; // esi@1

  for ( i = a1; i != a2; i += 28 )
  {
    std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
      a3,
      i);
    a3 += 28;
  }
  return a3;
}

//----- (6E66CC5C) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(int this, void *Src)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 24) = 7;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
    this,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    v2,
    Src);
  return v2;
}

//----- (6E66CC88) --------------------------------------------------------
void __noreturn std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen()
{
  char v0; // [sp+Ch] [bp-50h]@2
  char v1; // [sp+34h] [bp-28h]@1
  int v2; // [sp+58h] [bp-4h]@1

  std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>("vector<T> too long");
  v2 = 0;
  std::length_error::length_error(&v1);
  _CxxThrowException(&v0, &_TI3_AVlength_error_std__);
}
// 6E664155: using guessed type _DWORD __stdcall std::length_error::length_error(_DWORD);
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E695648: using guessed type int _TI3_AVlength_error_std__;

//----- (6E66CCD8) --------------------------------------------------------
void *__stdcall std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(void *lpMem, int a2, int a3, int a4)
{
  void *i; // esi@1
  void *result; // eax@2

  for ( i = lpMem; i != (void *)a2; i = (char *)i + 28 )
    result = std::_Destroy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(i);
  return result;
}

//----- (6E66CCFB) --------------------------------------------------------
void (__cdecl *__stdcall std::_Uninit_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4, int a5, int a6))(int a1, int a2)
{
  void (__cdecl *result)(int, int); // eax@1

  result = (void (__cdecl *)(int, int))a1;
  while ( a2 )
  {
    result = std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
               a1,
               a3);
    --a2;
    a1 += 28;
  }
  return result;
}

//----- (6E66CD54) --------------------------------------------------------
int __stdcall std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E66CD82) --------------------------------------------------------
void *__stdcall std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(void *lpMem, int a2, int a3)
{
  return std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
           lpMem,
           a2,
           a3,
           a3);
}

//----- (6E66CDA1) --------------------------------------------------------
void (__cdecl *__stdcall stdext::unchecked_uninitialized_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(int a1, int a2, int a3, int a4))(int a1, int a2)
{
  int v5; // [sp+4h] [bp-4h]@0

  LOBYTE(v5) = 0;
  return std::_Uninit_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
           a1,
           a2,
           a3,
           a4,
           a4,
           v5);
}

//----- (6E66CDCF) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Ufill(int this, int a2, int a3, int a4)
{
  stdext::unchecked_uninitialized_fill_n<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,unsigned int,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
    a2,
    a3,
    a4,
    this);
  return a2 + 28 * a3;
}

//----- (6E66CDF5) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Insert_n(void *this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // eax@4
  int v8; // ebx@6
  int v9; // eax@10
  int v10; // ecx@10
  int v11; // eax@10
  int v12; // ST2C_4@10
  int v13; // edi@10
  void *v14; // eax@10
  int v15; // ecx@13
  int v16; // eax@14
  int v17; // esi@14
  int v18; // ebx@15
  void *lpMem; // [sp+14h] [bp-34h]@10
  int lpMema; // [sp+14h] [bp-34h]@13
  char v22; // [sp+18h] [bp-30h]@1
  int v23; // [sp+44h] [bp-4h]@1

  v4 = (int)this;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
    (int)&v22,
    a4);
  v23 = 0;
  v5 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::capacity(v4);
  if ( a3 )
  {
    v6 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v4);
    if ( 153391689 - v6 < (unsigned int)a3 )
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Xlen();
    v7 = a3 + v6;
    if ( v5 >= (unsigned int)v7 )
    {
      v15 = *(_DWORD *)(v4 + 8);
      lpMema = *(_DWORD *)(v4 + 8);
      if ( (*(_DWORD *)(v4 + 8) - a2) / 28 >= (unsigned int)a3 )
      {
        v18 = v15 - 28 * a3;
        *(_DWORD *)(v4 + 8) = std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
                                v15 - 28 * a3,
                                v15,
                                v15,
                                v4);
        std::copy_backward<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(
          a2,
          v18,
          lpMema);
        std::fill<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
          a2,
          a2 + 28 * a3,
          (int)&v22);
      }
      else
      {
        std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
          a2,
          v15,
          28 * a3 + a2,
          v4);
        v16 = (*(_DWORD *)(v4 + 8) - a2) / 28;
        LOBYTE(v23) = 3;
        std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Ufill(
          v4,
          *(_DWORD *)(v4 + 8),
          a3 - v16,
          (int)&v22);
        *(_DWORD *)(v4 + 8) += 28 * a3;
        v17 = *(_DWORD *)(v4 + 8);
        v23 = 0;
        std::fill<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
          a2,
          v17 - 28 * a3,
          (int)&v22);
      }
    }
    else
    {
      if ( 153391689 - ((unsigned int)v5 >> 1) >= v5 )
        v8 = ((unsigned int)v5 >> 1) + v5;
      else
        v8 = 0;
      if ( v8 < (unsigned int)v7 )
        v8 = v7;
      v9 = (int)std::_Allocate<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>(
                  v8,
                  0);
      v10 = *(_DWORD *)(v4 + 4);
      lpMem = (void *)v9;
      LOBYTE(v23) = 1;
      v11 = std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
              v10,
              a2,
              v9,
              v4);
      v12 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Ufill(
              v4,
              v11,
              a3,
              (int)&v22);
      std::_Uninitialized_copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
        a2,
        *(_DWORD *)(v4 + 8),
        v12,
        v4);
      v13 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v4)
          + a3;
      v14 = *(void **)(v4 + 4);
      if ( v14 )
      {
        std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
          v14,
          *(_DWORD *)(v4 + 8),
          v4);
        operator delete(*(void **)(v4 + 4));
      }
      *(_DWORD *)(v4 + 12) = (char *)lpMem + 28 * v8;
      *(_DWORD *)(v4 + 8) = (char *)lpMem + 28 * v13;
      *(_DWORD *)(v4 + 4) = lpMem;
    }
  }
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
           (int)&v22,
           1,
           0);
}

//----- (6E66CFD6) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  char v5; // [sp+4h] [bp-4h]@1

  v3 = this;
  std::copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(
    (int)&v5,
    a3 + 28,
    *(_DWORD *)(this + 8),
    a3);
  std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
    (void *)(*(_DWORD *)(v3 + 8) - 28),
    *(_DWORD *)(v3 + 8),
    v3);
  result = a2;
  *(_DWORD *)(v3 + 8) -= 28;
  *(_DWORD *)a2 = a3;
  return result;
}

//----- (6E66D01A) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::insert(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@4

  v4 = this;
  if ( std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(this) )
    v5 = (a3 - *(_DWORD *)(v4 + 4)) / 28;
  else
    v5 = 0;
  std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Insert_n(
    (void *)v4,
    a3,
    1,
    a4);
  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 4) + 28 * v5;
  return result;
}

//----- (6E66D063) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  void **v6; // eax@2
  void *v7; // edi@2
  int result; // eax@3
  char v9; // [sp+4h] [bp-4h]@2

  v4 = this;
  v5 = a3;
  if ( a3 != a4 )
  {
    v6 = (void **)std::copy<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>>(
                    (int)&v9,
                    a4,
                    *(_DWORD *)(v4 + 8),
                    a3);
    v7 = *v6;
    std::_Destroy_range<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>(
      *v6,
      *(_DWORD *)(v4 + 8),
      v4);
    v5 = a3;
    *(_DWORD *)(v4 + 8) = v7;
  }
  result = a2;
  *(_DWORD *)a2 = v5;
  return result;
}

//----- (6E66D0AA) --------------------------------------------------------
__int32 __thiscall CComponentReferences::HrRemoveReferenceByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *lpMem)
{
  CComponentList **v2; // esi@1
  int v3; // edi@1
  __int32 result; // eax@2
  __int32 v5; // ebx@3
  int v6; // eax@8
  struct INetCfgComponentVtbl *v7; // eax@9
  int v8; // [sp+8h] [bp-8h]@8
  char v9; // [sp+Ch] [bp-4h]@8

  v2 = (CComponentList **)this;
  v3 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v5 = 0;
    switch ( lpMem->Type )
    {
      case 1:
        if ( !std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4)
          && !std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(v3 + 20) )
          *(_BYTE *)(v3 + 36) = 0;
        break;
      case 2:
        v7 = PComponentFromComInterface(lpMem->pncc);
        CComponentList::RemoveComponent(*v2, (const struct CComponent *)v7);
        break;
      case 3:
        v5 = HrGetSoftwareOboTokenKey(lpMem, 1, (HKEY)&lpMem);
        if ( !v5 )
        {
          v6 = std::find<std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>,unsigned short const *>(
                 (int)&v9,
                 *((_DWORD *)*v2 + 6),
                 *((_DWORD *)*v2 + 7),
                 (wchar_t **)&lpMem);
          std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(
            (int)((char *)*v2 + 20),
            (int)&v8,
            *(_DWORD *)v6);
          MemFree((void *)lpMem);
        }
        break;
      default:
        v5 = -2147467259;
        break;
    }
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E66D158) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::push_back(int this, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int result; // eax@2

  v2 = this;
  v3 = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::size(this);
  if ( v3 >= (unsigned int)std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::capacity(v2) )
  {
    result = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::insert(
               v2,
               (int)&a2,
               *(_DWORD *)(v2 + 8),
               a2);
  }
  else
  {
    result = std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::_Ufill(
               v2,
               *(_DWORD *)(v2 + 8),
               1,
               a2);
    *(_DWORD *)(v2 + 8) = result;
  }
  return result;
}

//----- (6E66D19D) --------------------------------------------------------
int __thiscall std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::clear(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  return std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::erase(
           this,
           (int)&v2,
           *(_DWORD *)(this + 4),
           *(_DWORD *)(this + 8));
}

//----- (6E66D1BB) --------------------------------------------------------
int __thiscall CComponentReferences::HrAddReferenceBySoftware(CComponentReferences *this, const unsigned __int16 *Src)
{
  CComponentReferences *v2; // edi@1
  int v3; // esi@2
  int v4; // ecx@3
  char v6; // [sp+Ch] [bp-34h]@3
  char v7; // [sp+28h] [bp-18h]@2
  int v8; // [sp+2Ch] [bp-14h]@1
  int v9; // [sp+3Ch] [bp-4h]@3

  v2 = this;
  v8 = CComponentReferences::HrEnsureAllocated(this);
  if ( !v8 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)v2 + 28);
    if ( *(_DWORD *)std::find<std::_Vector_iterator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>,unsigned short const *>(
                      (int)&v7,
                      *(_DWORD *)(*(_DWORD *)v2 + 24),
                      *(_DWORD *)(*(_DWORD *)v2 + 28),
                      (wchar_t **)&Src) == v3 )
    {
      v9 = 0;
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
        (int)&v6,
        (void *)Src);
      v4 = *(_DWORD *)v2 + 20;
      LOBYTE(v9) = 1;
      std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::push_back(
        v4,
        (int)&v6);
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
        (int)&v6,
        1,
        0);
    }
  }
  return v8;
}

//----- (6E66D22A) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E66D22A@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147024882;
  return &loc_6E66D21F;
}

//----- (6E66D23C) --------------------------------------------------------
void __thiscall CComponentReferences::RemoveAllReferences(CComponentReferences *this)
{
  CComponentReferences *v1; // esi@1

  v1 = this;
  if ( *(_DWORD *)this )
  {
    *(_BYTE *)(*(_DWORD *)this + 36) = 0;
    std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear(*(_DWORD *)this + 4);
    std::vector<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>>>::clear(*(_DWORD *)v1 + 20);
  }
}

//----- (6E66D267) --------------------------------------------------------
signed int __thiscall CComponentReferences::HrAddReferenceByOboToken(CComponentReferences *this, const struct tagOBO_TOKEN *lpMem)
{
  CComponentReferences *v2; // edi@1
  int v3; // esi@4
  struct INetCfgComponentVtbl *v4; // eax@7

  v2 = this;
  if ( lpMem->Type == 1 )
    return CComponentReferences::HrAddReferenceByUser(this);
  if ( lpMem->Type == 2 )
  {
    v4 = PComponentFromComInterface(lpMem->pncc);
    return CComponentReferences::HrAddReferenceByComponent(v2, (const struct CComponent *)v4);
  }
  if ( lpMem->Type == 3 )
  {
    v3 = HrGetSoftwareOboTokenKey(lpMem, 1, (HKEY)&lpMem);
    if ( !v3 )
    {
      v3 = CComponentReferences::HrAddReferenceBySoftware(v2, (const unsigned __int16 *)lpMem);
      MemFree((void *)lpMem);
    }
  }
  else
  {
    v3 = -2147467259;
  }
  return v3;
}

//----- (6E66D2D5) --------------------------------------------------------
int __thiscall CComponentList::PFindComponentByBindForm(int this, unsigned int a2, wchar_t *Str1)
{
  int v3; // ebx@1
  int i; // esi@1
  int v5; // edi@2

  v3 = this;
  for ( i = *(_DWORD *)(this + 8); ; i += 4 )
  {
    if ( i == *(_DWORD *)(v3 + 12) )
      return 0;
    v5 = *(_DWORD *)i;
    if ( *(_DWORD *)(*(_DWORD *)i + 56)
      && (a2 >= 5 || a2 == *(_DWORD *)(v5 + 16))
      && !_wcsicmp(Str1, *(const wchar_t **)(*(_DWORD *)i + 56)) )
      break;
  }
  return v5;
}

//----- (6E66D323) --------------------------------------------------------
int __thiscall CComponentList::PFindComponentByBindName(int this, unsigned int a2, wchar_t *Str1)
{
  int v3; // ebx@1
  int i; // edi@1
  int v5; // esi@2

  v3 = this;
  for ( i = *(_DWORD *)(this + 8); ; i += 4 )
  {
    if ( i == *(_DWORD *)(v3 + 12) )
      return 0;
    v5 = *(_DWORD *)i;
    if ( (a2 >= 5 || a2 == *(_DWORD *)(v5 + 16)) && !_wcsicmp(Str1, *(const wchar_t **)(v5 + 100)) )
      break;
  }
  return v5;
}

//----- (6E66D36C) --------------------------------------------------------
int __thiscall CComponentList::PFindComponentByPnpId(CComponentList *this, const unsigned __int16 *Str1)
{
  CComponentList *v2; // ebx@1
  int i; // esi@1
  int v4; // edi@2

  v2 = this;
  for ( i = *((_DWORD *)this + 2); ; i += 4 )
  {
    if ( i == *((_DWORD *)v2 + 3) )
      return 0;
    v4 = *(_DWORD *)i;
    if ( *(_DWORD *)(*(_DWORD *)i + 32) )
    {
      if ( !_wcsicmp(Str1, *(const wchar_t **)(*(_DWORD *)i + 32)) )
        break;
    }
  }
  return v4;
}

//----- (6E66D3AD) --------------------------------------------------------
void __thiscall CComponentList::RemoveComponent(CComponentList *this, const struct CComponent *a2)
{
  CComponentList *v2; // esi@1
  int v3; // eax@1
  char v4; // [sp+4h] [bp-4h]@1

  v2 = this;
  v3 = std::find<std::_Vector_const_iterator<CFilterMapEntry *,std::nc_allocator<CFilterMapEntry *>>,CFilterMapEntry const *>(
         (int)&v4,
         *((_DWORD *)this + 2),
         *((_DWORD *)this + 3),
         (int)&a2);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::erase((int)((char *)v2 + 4), (int)&a2, *(_DWORD *)v3);
}

//----- (6E66D3E3) --------------------------------------------------------
void __stdcall GetFirstComponentFromBindPath(wchar_t *Str, const unsigned __int16 **a2, unsigned __int32 *a3)
{
  wchar_t *v3; // eax@1
  wchar_t *v4; // ecx@3

  *a3 = 0;
  v3 = wcschr(Str, 0x5Fu);
  if ( !v3 )
    v3 = &Str[wcslen(Str)];
  v4 = v3;
  if ( v3 != Str )
  {
    while ( 92 != *v4 )
    {
      --v4;
      if ( v4 == Str )
        goto LABEL_8;
    }
    ++v4;
  }
LABEL_8:
  *a2 = v4;
  *a3 = v3 - v4;
}

//----- (6E66D445) --------------------------------------------------------
int __stdcall FBindPathContainsMultipleInterface(const struct CComponentList *a1, wchar_t *Str)
{
  signed int v2; // edi@1
  wchar_t *v3; // eax@1
  IID iid; // [sp+8h] [bp-14h]@2

  v2 = 0;
  v3 = wcsrchr(Str, 0x7Bu);
  if ( v3 && !IIDFromString(v3, &iid) && !CComponentList::PFindComponentByInstanceGuid(a1, &iid) )
    v2 = 1;
  return v2;
}

//----- (6E66D4A5) --------------------------------------------------------
char __stdcall CLanaMap::GetExportValue(const struct CComponentList *a2, const unsigned __int16 *Str)
{
  void *v2; // eax@1
  char v4; // [sp+13h] [bp-21h]@1
  wchar_t Str2; // [sp+14h] [bp-20h]@1

  qmemcpy(&Str2, L"NdisWanNbfIn{", 0x1Cu);
  v4 = 1;
  v2 = wcsrchr(Str, 0x5Fu);
  if ( !v2 )
  {
    v2 = wcsrchr(Str, 0x5Cu);
    if ( !v2 )
      v2 = (void *)Str;
  }
  if ( v2 != (void *)Str )
    v2 = (char *)v2 + 2;
  if ( !_wcsnicmp((const wchar_t *)v2, &Str2, wcslen(&Str2)) || FBindPathContainsMultipleInterface(a2, (wchar_t *)Str) )
    v4 = 0;
  return v4;
}
// 6E66D544: using guessed type wchar_t aNdiswannbfin[14];

//----- (6E66D565) --------------------------------------------------------
unsigned __int8 __thiscall CLanaMap::GetMaxLana(CLanaMap *this)
{
  unsigned __int8 result; // al@1

  result = -2;
  do
  {
    if ( *((_BYTE *)this + result + 20) )
      break;
    --result;
  }
  while ( result );
  return result;
}

//----- (6E66D57B) --------------------------------------------------------
int __stdcall std::find<unsigned char *,int>(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a1; result != a2; ++result )
  {
    if ( *(_BYTE *)result == *(_DWORD *)a3 )
      break;
  }
  return result;
}

//----- (6E66D5A3) --------------------------------------------------------
__int32 __thiscall CLanaMap::HrWriteLanaMapConfig(CLanaMap *this)
{
  CLanaMap *v1; // edi@1
  __int32 v2; // esi@1
  DWORD v3; // eax@2
  BYTE *v4; // edi@3
  unsigned __int8 v5; // al@7
  CLanaMap *v7; // [sp+Ch] [bp-Ch]@1
  HKEY phkResult; // [sp+10h] [bp-8h]@6
  HKEY hKey; // [sp+14h] [bp-4h]@1

  v1 = this;
  v7 = this;
  v2 = HrRegCreateKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Services\\NetBios\\Linkage",
         0,
         0x20006u,
         0,
         &hKey,
         0);
  if ( !v2 )
  {
    v3 = *((_DWORD *)v1 + 70);
    if ( v3 <= 0 )
      v4 = 0;
    else
      v4 = (BYTE *)*((_DWORD *)v1 + 69);
    v2 = HrRegSetBinary(hKey, L"LanaMap", v4, v3);
    RegCloseKey(hKey);
    if ( !v2 )
    {
      v2 = HrRegCreateKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\NetBIOS\\Parameters",
             0,
             0x20006u,
             0,
             &phkResult,
             0);
      if ( !v2 )
      {
        v5 = CLanaMap::GetMaxLana(v7);
        v2 = HrRegSetDword(phkResult, L"MaxLana", v5);
        RegCloseKey(phkResult);
      }
    }
  }
  return v2;
}

//----- (6E66D6DD) --------------------------------------------------------
signed int __thiscall CLanaMap::HrCreateRegistryMap(CLanaMap *this)
{
  CLanaMap *v1; // esi@1
  int v2; // eax@5
  signed int result; // eax@5
  int i; // edi@6

  v1 = this;
  if ( *((_DWORD *)this + 70) )
  {
    if ( *((_DWORD *)this + 71) >= 2u )
      **((_WORD **)this + 69) = 0;
    *((_DWORD *)this + 70) = 0;
  }
  v2 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size((int)this);
  result = CDynamicBuffer::HrReserveBytes((CLanaMap *)((char *)v1 + 276), 2 * v2);
  if ( !result )
  {
    for ( i = *((_DWORD *)v1 + 1); i != *((_DWORD *)v1 + 2); i += 8 )
      result = CDynamicBuffer::HrCopyBytes((CLanaMap *)((char *)v1 + 276), (const unsigned __int8 *)(i + 4), 2u);
  }
  return result;
}

//----- (6E66D742) --------------------------------------------------------
void __thiscall CLanaMap::GetLanaEntry(CLanaMap *this, const struct CComponentList *a2, struct CLanaEntry *a3)
{
  struct CLanaEntry *v3; // esi@1
  CLanaMap *v4; // ebx@1
  int i; // edi@1
  struct CLanaEntry *v6; // eax@6

  v3 = a3;
  v4 = this;
  for ( i = *((_DWORD *)this + 1); i != *((_DWORD *)v4 + 2); i += 8 )
  {
    if ( !_wcsicmp(*(const wchar_t **)v3, *(const wchar_t **)i) )
    {
      *((_BYTE *)v3 + 4) = CLanaMap::GetExportValue(a2, *(const unsigned __int16 **)v3);
      *((_BYTE *)v3 + 5) = *(_BYTE *)(i + 5);
      return;
    }
  }
  a3 = 0;
  a3 = (struct CLanaEntry *)std::find<unsigned char *,int>((int)((char *)v4 + 20), (int)((char *)v4 + 274), (int)&a3);
  if ( a3 == (CLanaMap *)((char *)v4 + 274) )
  {
    *((_BYTE *)v3 + 4) = 0;
    *((_BYTE *)v3 + 5) = -1;
  }
  else
  {
    *((_BYTE *)v3 + 4) = CLanaMap::GetExportValue(a2, *(const unsigned __int16 **)v3);
    v6 = a3;
    *((_BYTE *)v3 + 5) = (_BYTE)a3 - (_BYTE)v4 - 20;
    *(_BYTE *)v6 = 1;
  }
}

//----- (6E66D7D6) --------------------------------------------------------
signed int __thiscall CLanaMap::HrSetLanaNumber(CLanaMap *this, char a2, unsigned __int8 a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@1
  bool v6; // zf@8
  int v7; // ecx@9
  int v8; // esi@9
  signed int v10; // [sp+Ch] [bp-4h]@1

  v3 = *((_DWORD *)this + 1);
  v4 = 0;
  v5 = (char *)this + a3 + 20;
  v10 = 0;
  if ( *v5 )
  {
    v7 = *((_DWORD *)this + 2);
    v8 = 0;
    if ( v3 == v7 )
      goto LABEL_24;
    while ( 1 )
    {
      if ( v8 || a2 != *(_BYTE *)(v3 + 5) )
      {
        if ( !v4 && a3 == *(_BYTE *)(v3 + 5) )
          v4 = v3;
      }
      else
      {
        v8 = v3;
      }
      if ( v8 && v4 )
        break;
      v3 += 8;
      if ( v3 == v7 )
        goto LABEL_21;
    }
    *(_BYTE *)(v8 + 5) = a3;
    *(_BYTE *)(v4 + 5) = a2;
LABEL_21:
    if ( !v8 )
      goto LABEL_24;
    v6 = v4 == 0;
  }
  else
  {
    while ( v3 != *((_DWORD *)this + 2) )
    {
      if ( a2 == *(_BYTE *)(v3 + 5) )
      {
        *((_BYTE *)this + *(_BYTE *)(v3 + 5) + 20) = 0;
        *(_BYTE *)(v3 + 5) = a3;
        *v5 = 1;
        break;
      }
      v3 += 8;
    }
    v6 = v3 == *((_DWORD *)this + 2);
  }
  if ( v6 )
LABEL_24:
    v10 = -2147020584;
  return v10;
}

//----- (6E66D879) --------------------------------------------------------
signed int __thiscall CLanaMap::HrWriteLanaConfiguration(CLanaMap *this, const struct CComponentList *a2)
{
  CLanaMap *v2; // esi@1
  signed int result; // eax@1

  v2 = this;
  result = CLanaMap::HrCreateRegistryMap(this);
  if ( !result )
    result = CLanaMap::HrWriteLanaMapConfig(v2);
  return result;
}

//----- (6E66D897) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, int a2, unsigned int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edi@10
  unsigned int v7; // eax@12
  int v8; // edx@13
  int v10; // [sp+14h] [bp+8h]@8

  v4 = a2;
  v5 = this;
  if ( *(_DWORD *)(a2 + 20) < a3 )
    std::_String_base::_Xran();
  if ( *(_DWORD *)(a2 + 20) - a3 < a4 )
    a4 = *(_DWORD *)(a2 + 20) - a3;
  if ( -1 - *(_DWORD *)(this + 20) <= (unsigned int)a4 )
    std::_String_base::_Xlen();
  if ( a4 )
  {
    v10 = a4 + *(_DWORD *)(this + 20);
    if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                            this,
                            a4 + *(_DWORD *)(this + 20),
                            0) )
    {
      if ( *(_DWORD *)(v4 + 24) < 8u )
        v6 = v4 + 4;
      else
        v6 = *(_DWORD *)(v4 + 4);
      v7 = *(_DWORD *)(v5 + 24);
      if ( v7 < 8 )
        v8 = v5 + 4;
      else
        v8 = *(_DWORD *)(v5 + 4);
      std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(
        (void *)(v8 + 2 * *(_DWORD *)(v5 + 20)),
        v7 - *(_DWORD *)(v5 + 20),
        (void *)(v6 + 2 * a3),
        a4);
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
        v5,
        v10);
    }
  }
  return v5;
}

//----- (6E66D937) --------------------------------------------------------
int __fastcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int a1, int a2, void *Src, int a4)
{
  int v4; // esi@1
  int v5; // eax@3
  int result; // eax@5
  int v7; // edi@9
  unsigned int v8; // eax@10
  int v9; // edx@11

  v4 = a1;
  if ( std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Inside(
         a1,
         a2,
         (unsigned int)Src) )
  {
    if ( *(_DWORD *)(v4 + 24) < 8u )
      v5 = v4 + 4;
    else
      v5 = *(_DWORD *)(v4 + 4);
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
               v4,
               v4,
               (signed int)((char *)Src - v5) >> 1,
               a4);
  }
  else
  {
    if ( -1 - *(_DWORD *)(v4 + 20) <= (unsigned int)a4 )
      std::_String_base::_Xlen();
    if ( a4 )
    {
      v7 = a4 + *(_DWORD *)(v4 + 20);
      if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                              v4,
                              a4 + *(_DWORD *)(v4 + 20),
                              0) )
      {
        v8 = *(_DWORD *)(v4 + 24);
        if ( v8 < 8 )
          v9 = v4 + 4;
        else
          v9 = *(_DWORD *)(v4 + 4);
        std::_Traits_helper::copy_s<std::char_traits<unsigned short>>(
          (void *)(v9 + 2 * *(_DWORD *)(v4 + 20)),
          v8 - *(_DWORD *)(v4 + 20),
          Src,
          a4);
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
          v4,
          v7);
      }
    }
    result = v4;
  }
  return result;
}

//----- (6E66D9D1) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, void *Src)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
           this,
           (int)((char *)Src + 2),
           Src,
           wcslen((const unsigned __int16 *)Src));
}

//----- (6E66D9FE) --------------------------------------------------------
int __thiscall CLanaMap::Dump(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@1
  int i; // esi@1
  wchar_t Dest; // [sp+Ch] [bp-804h]@2

  v2 = this;
  result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
             0,
             -1);
  for ( i = *((_DWORD *)v2 + 1); i != *((_DWORD *)v2 + 2); i += 8 )
  {
    StringCchPrintfW(
      &Dest,
      0x400u,
      L"Lana: %3d  Export: %d Path: %s\n",
      *(_BYTE *)(i + 5),
      *(_BYTE *)(i + 4),
      *(_DWORD *)i);
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
               a2,
               &Dest);
  }
  return result;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E66DABD) --------------------------------------------------------
__int32 __thiscall CLanaMap::HrReserveRoomForEntries(CLanaMap *this, unsigned int a2)
{
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::reserve((int)this, a2);
  return 0;
}

//----- (6E66DAE4) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E66DAE4@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E66DAD9;
}

//----- (6E66DAF6) --------------------------------------------------------
__int32 __thiscall CLanaMap::HrAppendEntry(CLanaMap *this, struct CLanaEntry *a2)
{
  CLanaMap *v2; // esi@1

  v2 = this;
  std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::push_back((int)this, (int)a2);
  *((_BYTE *)v2 + *((_BYTE *)a2 + 5) + 20) = 1;
  return 0;
}

//----- (6E66DB29) --------------------------------------------------------
void __userpurge sub_6E66DB29(int a1@<ebp>, int a2)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  JUMPOUT(&loc_6E66DB1E);
}

//----- (6E66DB3D) --------------------------------------------------------
__int32 __thiscall CLanaMap::HrLoadLanaMap(CLanaMap *this)
{
  __int32 v1; // eax@1
  unsigned __int32 v2; // ecx@1
  __int32 v3; // ebx@1
  unsigned __int32 v4; // ecx@2
  unsigned __int8 *i; // ecx@4
  CLanaMap *v6; // ecx@6
  unsigned int v7; // ecx@6
  unsigned __int8 *v8; // esi@7
  CLanaMap *v9; // ebx@10
  char *v10; // eax@11
  char v11; // cl@11
  char *v12; // edi@12
  int v13; // eax@12
  unsigned __int8 *v15; // [sp+4h] [bp-28h]@7
  int v16; // [sp+8h] [bp-24h]@7
  int v17; // [sp+Ch] [bp-20h]@12
  unsigned __int32 v18; // [sp+10h] [bp-1Ch]@3
  unsigned __int32 v19; // [sp+14h] [bp-18h]@2
  void *lpMem; // [sp+18h] [bp-14h]@2
  unsigned __int8 *v21; // [sp+1Ch] [bp-10h]@3
  HKEY hKey; // [sp+20h] [bp-Ch]@1
  unsigned int v23; // [sp+24h] [bp-8h]@7
  CLanaMap *v24; // [sp+28h] [bp-4h]@1

  v24 = this;
  v1 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Services\\NetBios\\Linkage", 0x20019u, &hKey);
  v3 = v1;
  if ( v1 )
  {
    if ( v1 == -2147024894 )
      v3 = 0;
  }
  else
  {
    v3 = HrRegGetTypeWithAlloc(v2, hKey, L"LanaMap", 3u, (unsigned __int8 **)&lpMem, &v19);
    if ( !v3 )
    {
      v18 = v19 >> 1;
      v3 = HrRegGetTypeWithAlloc(v4, hKey, L"Bind", 7u, &v21, 0);
      if ( !v3 )
      {
        for ( i = v21; *(_WORD *)i; i += 2 * wcslen((const unsigned __int16 *)i) + 2 )
          ++v3;
        v6 = v24;
        *((_DWORD *)v24 + 4) = v21;
        v3 = CLanaMap::HrReserveRoomForEntries(v6, v3);
        v7 = 0;
        if ( !v3 )
        {
          v8 = v21;
          v15 = 0;
          v23 = 0;
          v16 = 0;
          if ( *(_WORD *)v21 )
          {
            while ( 1 )
            {
              v9 = v24;
              v15 = v8;
              if ( v7 >= v18 )
              {
                v17 = 0;
                v12 = (char *)v24 + 274;
                v13 = std::find<unsigned char *,int>((int)((char *)v24 + 20), (int)((char *)v24 + 274), (int)&v17);
                if ( (char *)v13 != v12 )
                {
                  BYTE1(v16) = v13 - (_BYTE)v9 - 20;
                  LOBYTE(v16) = 1;
                }
              }
              else
              {
                v10 = (char *)lpMem + 2 * v7;
                v11 = v10[1];
                LOBYTE(v10) = *v10;
                BYTE1(v16) = v11;
                LOBYTE(v16) = (_BYTE)v10;
              }
              *((_BYTE *)v9 + BYTE1(v16) + 20) = 1;
              v3 = CLanaMap::HrAppendEntry(v9, (struct CLanaEntry *)&v15);
              if ( v3 )
                break;
              ++v23;
              v8 += 2 * wcslen((const unsigned __int16 *)v8) + 2;
              if ( !*(_WORD *)v8 )
                break;
              v7 = v23;
            }
          }
        }
      }
      MemFree(lpMem);
    }
    if ( v3 == -2147024894 )
      v3 = 0;
    RegCloseKey(hKey);
  }
  return v3;
}

//----- (6E66DCC4) --------------------------------------------------------
signed int __stdcall HrUpdateLanaConfig(const struct CComponentList *a1, const unsigned __int16 *a2, unsigned int a3)
{
  const unsigned __int16 *v3; // esi@1
  signed int v4; // edi@1
  const unsigned __int16 *v6; // [sp+Ch] [bp-264h]@4
  struct CComponentList *v7; // [sp+14h] [bp-25Ch]@1
  char Dst; // [sp+18h] [bp-258h]@1
  char v9; // [sp+13Ch] [bp-134h]@1
  int v10; // [sp+26Ch] [bp-4h]@1

  v3 = a2;
  v7 = a1;
  CLanaMap::CLanaMap(&Dst);
  v10 = 0;
  CLanaMap::CLanaMap(&v9);
  LOBYTE(v10) = 1;
  v4 = CLanaMap::HrLoadLanaMap((CLanaMap *)&Dst);
  if ( !v4 )
  {
    v4 = CLanaMap::HrReserveRoomForEntries((CLanaMap *)&v9, a3);
    if ( !v4 )
    {
      while ( *v3 )
      {
        v6 = v3;
        CLanaMap::GetLanaEntry((CLanaMap *)&Dst, v7, (struct CLanaEntry *)&v6);
        v4 = CLanaMap::HrAppendEntry((CLanaMap *)&v9, (struct CLanaEntry *)&v6);
        if ( v4 )
          goto LABEL_8;
        v3 += wcslen(v3) + 1;
      }
      v4 = CLanaMap::HrWriteLanaConfiguration((CLanaMap *)&v9, v7);
    }
  }
LABEL_8:
  CLanaMap::~CLanaMap((CLanaMap *)&v9);
  CLanaMap::~CLanaMap((CLanaMap *)&Dst);
  return v4;
}

//----- (6E66DDAF) --------------------------------------------------------
__int32 __thiscall CNetConfigCore::HrAddComponentToCore(CNetConfigCore *this, struct CComponent *a2, unsigned __int32 a3)
{
  CNetConfigCore *v3; // esi@1
  __int32 result; // eax@3
  __int32 v5; // ebx@4

  v3 = this;
  if ( FIsConsideredNetClass(*((_DWORD *)a2 + 4))
    && CComponentList::PFindComponentByPnpId(v3, *((const unsigned __int16 **)a2 + 8)) )
  {
    result = -2147024809;
  }
  else
  {
    v5 = CComponentList::HrInsertComponent(v3, a2, a3 | 0x100);
    if ( !v5 )
    {
      v5 = CStackTable::HrInsertStackEntriesForComponent((CNetConfigCore *)((char *)v3 + 20), a2, v3, a3);
      if ( v5 )
        CComponentList::RemoveComponent(v3, a2);
    }
    result = v5;
  }
  return result;
}

//----- (6E66DE1D) --------------------------------------------------------
void __thiscall CNetConfigCore::RemoveComponentFromCore(CNetConfigCore *this, const struct CComponent *a2)
{
  CNetConfigCore *v2; // esi@1

  v2 = this;
  CComponentList::RemoveComponent(this, a2);
  CStackTable::RemoveEntriesWithComponent((CNetConfigCore *)((char *)v2 + 20), a2);
  CBindingSet::RemoveBindPathsWithComponent((CNetConfigCore *)((char *)v2 + 44), a2);
}

//----- (6E66DE4D) --------------------------------------------------------
void __thiscall CNetConfigCore::EnsureComponentNotReferencedByOthers(CNetConfigCore *this, const struct CComponent *a2)
{
  int v2; // ebx@1
  int v3; // esi@2
  CComponentList **v4; // edi@2
  int v5; // ecx@4
  int v6; // eax@6
  CNetConfigCore *i; // [sp+4h] [bp-4h]@1

  v2 = *((_DWORD *)this + 2);
  for ( i = this; v2 != *((_DWORD *)i + 3); v2 += 4 )
  {
    v3 = *(_DWORD *)v2;
    v4 = (CComponentList **)(*(_DWORD *)v2 + 120);
    if ( CComponentReferences::FIsReferencedByComponent((CComponentReferences *)v4, a2) )
    {
      if ( *((_DWORD *)a2 + 8) )
        v5 = *((_DWORD *)a2 + 8);
      else
        v5 = *((_DWORD *)a2 + 7);
      v6 = *(_DWORD *)(v3 + 32);
      if ( !v6 )
        v6 = *(_DWORD *)(v3 + 28);
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   %S is still referenced by %S.  Removing the refernce.\n", v6, v5);
      CComponentList::RemoveComponent(*v4, a2);
    }
  }
}

//----- (6E66DF03) --------------------------------------------------------
void __thiscall CNetConfigCore::Free(CNetConfigCore *this)
{
  FreeCollectionAndItem<CComponentList>((int)this);
}

//----- (6E66DF11) --------------------------------------------------------
void __thiscall GBCONTEXT::~GBCONTEXT(GBCONTEXT *this)
{
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)this + 28));
}

//----- (6E66DF1E) --------------------------------------------------------
int __thiscall CNetConfigCore::HrGetBindingsInvolvingComponent(CNetConfigCore *this, const struct CComponent *a2, unsigned __int32 a3, struct CBindingSet *a4)
{
  CNetConfigCore *v4; // ebx@1
  struct CBindingSet *v5; // esi@1
  unsigned __int32 v6; // edi@4
  unsigned __int32 v7; // eax@5
  int v8; // edi@9
  int v9; // esi@14
  char v11; // [sp+Ch] [bp-2Ch]@3
  char v12; // [sp+10h] [bp-28h]@1
  unsigned __int32 v13; // [sp+14h] [bp-24h]@5
  int v14; // [sp+18h] [bp-20h]@8
  CNetConfigCore *v15; // [sp+20h] [bp-18h]@3
  char *v16; // [sp+24h] [bp-14h]@3
  int v17; // [sp+28h] [bp-10h]@3
  int v18; // [sp+34h] [bp-4h]@1

  v4 = this;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v12, 0);
  v18 = 0;
  v5 = a4;
  if ( !(a3 & 1) )
    std::vector<CBindPath,std::nc_allocator<CBindPath>>::clear((int)((char *)a4 + 4));
  a4 = (struct CBindingSet *)std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v5 + 4));
  v17 = 0;
  v15 = (CNetConfigCore *)((char *)v4 + 20);
  v16 = &v11;
  GetComponentsAboveComponent(a2, (struct GCCONTEXT *)&v15);
  if ( !v17 )
  {
    v6 = a3 | 1;
    v17 = CNetConfigCore::HrGetComponentBindings(v4, a2, a3 | 1, v5);
    if ( !v17 )
    {
      v7 = v13;
      a3 = v13;
      while ( v7 != v14 )
      {
        v17 = CNetConfigCore::HrGetComponentBindings(v4, *(const struct CComponent **)a3, v6, v5);
        if ( v17 )
          goto LABEL_14;
        a3 += 4;
        v7 = a3;
      }
      v8 = *(_DWORD *)CBindingSet::PGetBindPathAtIndex((void *)v5, (int)&a3, (unsigned int)a4);
      while ( v8 != *((_DWORD *)v5 + 3) )
      {
        if ( CComponentList::FComponentInList((CComponentList *)v8, a2) )
          v8 += 20;
        else
          std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase((int)((char *)v5 + 4), (int)&a4, v8);
      }
    }
  }
LABEL_14:
  v9 = v17;
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v12);
  return v9;
}

//----- (6E66E010) --------------------------------------------------------
bool __thiscall CBindPath::operator<(int this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edi@3
  int v6; // ebx@3
  int v7; // edi@7
  int v8; // eax@7

  v2 = *(_DWORD *)(a2 + 8);
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  while ( 1 )
  {
    if ( v4 == *(_DWORD *)(v3 + 12) || v2 == *(_DWORD *)(a2 + 12) )
    {
      v7 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2 + 4);
      return v7 < (unsigned int)std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4);
    }
    v5 = *(_DWORD *)(*(_DWORD *)v4 + 16);
    v6 = *(_DWORD *)(*(_DWORD *)v2 + 16);
    if ( v5 > v6 )
    {
      LOBYTE(v8) = 1;
      return v8;
    }
    if ( v5 < v6 )
      break;
    v4 += 4;
    v2 += 4;
  }
  LOBYTE(v8) = 0;
  return v8;
}

//----- (6E66E071) --------------------------------------------------------
bool __thiscall CBindPath::operator>(int this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edi@3
  int v6; // ebx@3
  int v7; // edi@7
  int v8; // eax@7

  v2 = *(_DWORD *)(a2 + 8);
  v3 = this;
  v4 = *(_DWORD *)(this + 8);
  while ( 1 )
  {
    if ( v4 == *(_DWORD *)(v3 + 12) || v2 == *(_DWORD *)(a2 + 12) )
    {
      v7 = std::vector<CParam *,std::nc_allocator<CParam *>>::size(a2 + 4);
      return std::vector<CParam *,std::nc_allocator<CParam *>>::size(v3 + 4) < (unsigned int)v7;
    }
    v5 = *(_DWORD *)(*(_DWORD *)v4 + 16);
    v6 = *(_DWORD *)(*(_DWORD *)v2 + 16);
    if ( v5 < v6 )
    {
      LOBYTE(v8) = 1;
      return v8;
    }
    if ( v5 > v6 )
      break;
    v4 += 4;
    v2 += 4;
  }
  LOBYTE(v8) = 0;
  return v8;
}

//----- (6E66E0D2) --------------------------------------------------------
int __thiscall CBindingSet::FContainsComponent(CBindingSet *this, const struct CComponent *a2)
{
  CComponentList *v2; // esi@1
  CComponentList *v3; // edi@1

  v2 = (CComponentList *)*((_DWORD *)this + 2);
  v3 = (CComponentList *)*((_DWORD *)this + 3);
  while ( 1 )
  {
    if ( v2 == v3 )
      return 0;
    if ( CComponentList::FComponentInList(v2, a2) )
      break;
    v2 = (CComponentList *)((char *)v2 + 20);
  }
  return 1;
}

//----- (6E66E108) --------------------------------------------------------
void *__cdecl std::_Copy_opt<CBindPath *,CBindPath *>(int a1, int a2, void *a3)
{
  int i; // esi@1

  for ( i = a1; i != a2; i += 20 )
  {
    CBindPath::operator=(a3, i);
    a3 = (char *)a3 + 20;
  }
  return a3;
}

//----- (6E66E133) --------------------------------------------------------
void *__cdecl std::_Copy_backward_opt<CBindPath *,CBindPath *>(int a1, int a2, void *a3)
{
  int i; // esi@1

  for ( i = a2; i != a1; CBindPath::operator=(a3, i) )
  {
    a3 = (char *)a3 - 20;
    i -= 20;
  }
  return a3;
}

//----- (6E66E161) --------------------------------------------------------
void __stdcall std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int i; // esi@1

  v9 = a2;
  for ( i = (a2 - 1) / 2; a3 < v9 && CBindPath::operator>(20 * i + a1, (int)&a4); i = (i - 1) / 2 )
  {
    CBindPath::operator=((void *)(a1 + 20 * v9), 20 * i + a1);
    v9 = i;
  }
  CBindPath::operator=((void *)(a1 + 20 * v9), (int)&a4);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E1DF) --------------------------------------------------------
void __stdcall std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int i; // esi@1

  v9 = a2;
  for ( i = (a2 - 1) / 2; a3 < v9 && CBindPath::operator<(20 * i + a1, (int)&a4); i = (i - 1) / 2 )
  {
    CBindPath::operator=((void *)(a1 + 20 * v9), 20 * i + a1);
    v9 = i;
  }
  CBindPath::operator=((void *)(a1 + 20 * v9), (int)&a4);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E25D) --------------------------------------------------------
void *__cdecl std::copy<CBindPath *,CBindPath *>(int a1, int a2, void *a3)
{
  return std::_Copy_opt<CBindPath *,CBindPath *>(a1, a2, a3);
}

//----- (6E66E289) --------------------------------------------------------
void *__cdecl std::copy_backward<CBindPath *,CBindPath *>(int a1, int a2, void *a3)
{
  return std::_Copy_backward_opt<CBindPath *,CBindPath *>(a1, a2, a3);
}

//----- (6E66E2B5) --------------------------------------------------------
void __stdcall std::swap<CBindPath>(int a1, int a2)
{
  char v2; // [sp+Ch] [bp-20h]@1
  char v3; // [sp+10h] [bp-1Ch]@1
  int v4; // [sp+28h] [bp-4h]@1

  CBindPath::CBindPath((int)&v2, a1);
  v4 = 0;
  CBindPath::operator=((void *)a1, a2);
  CBindPath::operator=((void *)a2, (int)&v2);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v3);
}

//----- (6E66E2FC) --------------------------------------------------------
void __stdcall std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int i; // esi@1
  char v11; // [sp-1Ch] [bp-34h]@8
  char v12; // [sp-18h] [bp-30h]@8
  int v13; // [sp-14h] [bp-2Ch]@8
  int v14; // [sp-10h] [bp-28h]@8
  int v15; // [sp-Ch] [bp-24h]@8
  int v16; // [sp-8h] [bp-20h]@8
  int v17; // [sp+14h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  for ( i = 2 * a2 + 2; i < a3; i = 2 * i + 2 )
  {
    if ( CBindPath::operator>(20 * i + a1, 20 * i + a1 - 20) )
      --i;
    CBindPath::operator=((void *)(a1 + 20 * v9), a1 + 20 * i);
    v9 = i;
  }
  if ( i == a3 )
  {
    CBindPath::operator=((void *)(a1 + 20 * v9), 20 * a3 + a1 - 20);
    v9 = a3 - 1;
  }
  v16 = a9;
  CBindPath::CBindPath((int)&v11, (int)&a4);
  std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(
    a1,
    v9,
    a2,
    v11,
    v12,
    v13,
    v14,
    v15,
    v16);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E3A6) --------------------------------------------------------
void __stdcall std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, char a4, char a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int i; // esi@1
  char v11; // [sp-1Ch] [bp-34h]@8
  char v12; // [sp-18h] [bp-30h]@8
  int v13; // [sp-14h] [bp-2Ch]@8
  int v14; // [sp-10h] [bp-28h]@8
  int v15; // [sp-Ch] [bp-24h]@8
  int v16; // [sp-8h] [bp-20h]@8
  int v17; // [sp+14h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  for ( i = 2 * a2 + 2; i < a3; i = 2 * i + 2 )
  {
    if ( CBindPath::operator<(20 * i + a1, 20 * i + a1 - 20) )
      --i;
    CBindPath::operator=((void *)(a1 + 20 * v9), a1 + 20 * i);
    v9 = i;
  }
  if ( i == a3 )
  {
    CBindPath::operator=((void *)(a1 + 20 * v9), 20 * a3 + a1 - 20);
    v9 = a3 - 1;
  }
  v16 = a9;
  CBindPath::CBindPath((int)&v11, (int)&a4);
  std::_Push_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(
    a1,
    v9,
    a2,
    v11,
    v12,
    v13,
    v14,
    v15,
    v16);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E450) --------------------------------------------------------
void __stdcall std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, void *a3, char a4, char a5, int a6, int a7, int a8, int a9, int a10)
{
  char v10; // [sp-1Ch] [bp-38h]@1
  char v11; // [sp-18h] [bp-34h]@1
  int v12; // [sp-14h] [bp-30h]@1
  int v13; // [sp-10h] [bp-2Ch]@1
  int v14; // [sp-Ch] [bp-28h]@1
  int v15; // [sp-8h] [bp-24h]@1
  char *v16; // [sp+Ch] [bp-10h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v17 = 0;
  CBindPath::operator=(a3, a1);
  v15 = a9;
  v16 = &v10;
  CBindPath::CBindPath((int)&v10, (int)&a4);
  std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(
    a1,
    0,
    (a2 - a1) / 20,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E4AB) --------------------------------------------------------
void __stdcall std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath>(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // ecx@1
  int v7; // edx@2
  int v8; // ebx@5
  int v9; // edi@5
  int v10; // edi@7
  int *v11; // eax@8
  int v12; // eax@10
  int v13; // ecx@12
  int v14; // esi@13
  char v15; // [sp+Ch] [bp-3Ch]@7
  char v16; // [sp+10h] [bp-38h]@14
  int v17; // [sp+20h] [bp-28h]@12
  int v18; // [sp+24h] [bp-24h]@11
  int v19; // [sp+28h] [bp-20h]@9
  int v20; // [sp+2Ch] [bp-1Ch]@1
  int i; // [sp+30h] [bp-18h]@5
  void *v22; // [sp+34h] [bp-14h]@7
  int v23; // [sp+38h] [bp-10h]@1
  int v24; // [sp+44h] [bp-4h]@7

  v5 = (a2 - a1) / 20;
  v20 = v5;
  v6 = (a2 - a1) / 20;
  v23 = (a3 - a1) / 20;
  if ( v5 )
  {
    do
    {
      v7 = v23 % v6;
      v23 = v6;
      v6 = v7;
    }
    while ( v7 );
  }
  if ( v23 < (a3 - a1) / 20 && v23 > 0 )
  {
    v8 = 20 * v5;
    v9 = 20 * v23;
    for ( i = 20 * v23; ; v9 = i )
    {
      v10 = a1 + v9;
      v22 = (void *)v10;
      CBindPath::CBindPath((int)&v15, v10);
      v24 = 0;
      if ( v10 + v8 == a3 )
      {
        v11 = &a1;
      }
      else
      {
        v19 = v10 + v8;
        v11 = &v19;
      }
      while ( 1 )
      {
        v14 = *v11;
        if ( *v11 == v10 )
          break;
        CBindPath::operator=(v22, *v11);
        v12 = (a3 - v14) / 20;
        v22 = (void *)v14;
        if ( v20 >= v12 )
        {
          v13 = 20 * (v20 - v12);
          v11 = &v17;
          v17 = a1 + v13;
        }
        else
        {
          v18 = v8 + v14;
          v11 = &v18;
        }
      }
      CBindPath::operator=(v22, (int)&v15);
      v24 = -1;
      std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v16);
      --v23;
      i -= 20;
      if ( v23 <= 0 )
        break;
    }
  }
}

//----- (6E66E5A7) --------------------------------------------------------
void __stdcall std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, void *a3, char a4, char a5, int a6, int a7, int a8, int a9, int a10)
{
  char v10; // [sp-1Ch] [bp-38h]@1
  char v11; // [sp-18h] [bp-34h]@1
  int v12; // [sp-14h] [bp-30h]@1
  int v13; // [sp-10h] [bp-2Ch]@1
  int v14; // [sp-Ch] [bp-28h]@1
  int v15; // [sp-8h] [bp-24h]@1
  char *v16; // [sp+Ch] [bp-10h]@1
  int v17; // [sp+18h] [bp-4h]@1

  v17 = 0;
  CBindPath::operator=(a3, a1);
  v15 = a9;
  v16 = &v10;
  CBindPath::CBindPath((int)&v10, (int)&a4);
  std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(
    a1,
    0,
    (a2 - a1) / 20,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&a5);
}

//----- (6E66E602) --------------------------------------------------------
void __stdcall std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@2
  char v8; // [sp-18h] [bp-28h]@3
  char v9; // [sp-14h] [bp-24h]@3
  int v10; // [sp-10h] [bp-20h]@3
  int v11; // [sp-Ch] [bp-1Ch]@3
  int v12; // [sp-8h] [bp-18h]@3
  int v13; // [sp-4h] [bp-14h]@3
  char *v14; // [sp+Ch] [bp-4h]@3

  v5 = (a2 - a1) / 20;
  v6 = v5 / 2;
  if ( v5 / 2 > 0 )
  {
    v7 = 20 * v6;
    do
    {
      v13 = a3;
      v7 -= 20;
      v14 = &v8;
      --v6;
      CBindPath::CBindPath((int)&v8, v7 + a1);
      std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(
        a1,
        v6,
        v5,
        v8,
        v9,
        v10,
        v11,
        v12,
        v13);
    }
    while ( v6 > 0 );
  }
}

//----- (6E66E65D) --------------------------------------------------------
void __stdcall std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@2
  char v8; // [sp-18h] [bp-28h]@3
  char v9; // [sp-14h] [bp-24h]@3
  int v10; // [sp-10h] [bp-20h]@3
  int v11; // [sp-Ch] [bp-1Ch]@3
  int v12; // [sp-8h] [bp-18h]@3
  int v13; // [sp-4h] [bp-14h]@3
  char *v14; // [sp+Ch] [bp-4h]@3

  v5 = (a2 - a1) / 20;
  v6 = v5 / 2;
  if ( v5 / 2 > 0 )
  {
    v7 = 20 * v6;
    do
    {
      v13 = a3;
      v7 -= 20;
      v14 = &v8;
      --v6;
      CBindPath::CBindPath((int)&v8, v7 + a1);
      std::_Adjust_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(
        a1,
        v6,
        v5,
        v8,
        v9,
        v10,
        v11,
        v12,
        v13);
    }
    while ( v6 > 0 );
  }
}

//----- (6E66E6B8) --------------------------------------------------------
void __stdcall std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3, int a4)
{
  if ( CBindPath::operator>(a2, a1) )
    std::swap<CBindPath>(a2, a1);
  if ( CBindPath::operator>(a3, a2) )
    std::swap<CBindPath>(a3, a2);
  if ( CBindPath::operator>(a2, a1) )
    std::swap<CBindPath>(a2, a1);
}

//----- (6E66E714) --------------------------------------------------------
void __stdcall std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::greater<CBindPath>>(int a1, int a2, int a3, int a4)
{
  char v4; // [sp-1Ch] [bp-20h]@1
  char v5; // [sp-18h] [bp-1Ch]@1
  int v6; // [sp-14h] [bp-18h]@1
  int v7; // [sp-10h] [bp-14h]@1
  int v8; // [sp-Ch] [bp-10h]@1
  int v9; // [sp-8h] [bp-Ch]@1
  int v10; // [sp-4h] [bp-8h]@1
  char *v11; // [sp+0h] [bp-4h]@1

  v10 = 0;
  v9 = a3;
  v11 = &v4;
  CBindPath::CBindPath((int)&v4, a2 - 20);
  std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(
    a1,
    a2 - 20,
    (void *)(a2 - 20),
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    v10);
}

//----- (6E66E74C) --------------------------------------------------------
void __stdcall std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3, int a4)
{
  std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath>(a1, a2, a3, 0, 0);
}

//----- (6E66E76C) --------------------------------------------------------
void __stdcall std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3, int a4)
{
  if ( CBindPath::operator<(a2, a1) )
    std::swap<CBindPath>(a2, a1);
  if ( CBindPath::operator<(a3, a2) )
    std::swap<CBindPath>(a3, a2);
  if ( CBindPath::operator<(a2, a1) )
    std::swap<CBindPath>(a2, a1);
}

//----- (6E66E7C8) --------------------------------------------------------
void __stdcall std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::less<CBindPath>>(int a1, int a2, int a3, int a4)
{
  char v4; // [sp-1Ch] [bp-20h]@1
  char v5; // [sp-18h] [bp-1Ch]@1
  int v6; // [sp-14h] [bp-18h]@1
  int v7; // [sp-10h] [bp-14h]@1
  int v8; // [sp-Ch] [bp-10h]@1
  int v9; // [sp-8h] [bp-Ch]@1
  int v10; // [sp-4h] [bp-8h]@1
  char *v11; // [sp+0h] [bp-4h]@1

  v10 = 0;
  v9 = a3;
  v11 = &v4;
  CBindPath::CBindPath((int)&v4, a2 - 20);
  std::_Pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(
    a1,
    a2 - 20,
    (void *)(a2 - 20),
    v4,
    v5,
    v6,
    v7,
    v8,
    v9,
    v10);
}

//----- (6E66E800) --------------------------------------------------------
void __stdcall std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3)
{
  if ( (a2 - a1) / 20 > 1 )
    std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::greater<CBindPath>>(
      a1,
      a2,
      a3,
      0,
      0);
}

//----- (6E66E831) --------------------------------------------------------
void __stdcall std::make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3)
{
  if ( (a2 - a1) / 20 > 1 )
    std::_Make_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,int,CBindPath,std::less<CBindPath>>(
      a1,
      a2,
      a3,
      0,
      0);
}

//----- (6E66E862) --------------------------------------------------------
void __stdcall std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edi@2
  int v7; // esi@2

  v4 = (a3 - a1) / 20;
  if ( v4 <= 40 )
  {
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(a1, a2, a3, a4);
  }
  else
  {
    v5 = (v4 + 1) / 8;
    v6 = 40 * v5;
    v7 = 20 * v5;
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      a1,
      20 * v5 + a1,
      40 * v5 + a1,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      a2 - v7,
      a2,
      v7 + a2,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      a3 - v6,
      a3 - v7,
      a3,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
      v7 + a1,
      a2,
      a3 - v7,
      a4);
  }
}

//----- (6E66E900) --------------------------------------------------------
void __stdcall std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3)
{
  if ( (a2 - a1) / 20 > 1 )
    std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::greater<CBindPath>>(
      a1,
      a2,
      a3,
      0);
}

//----- (6E66E92F) --------------------------------------------------------
void __stdcall std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(int a1, int a2, int a3)
{
  if ( a1 != a2 && a2 != a3 )
    std::_Rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(a1, a2, a3, a3);
}

//----- (6E66E959) --------------------------------------------------------
void __stdcall std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edi@2
  int v7; // esi@2

  v4 = (a3 - a1) / 20;
  if ( v4 <= 40 )
  {
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(a1, a2, a3, a4);
  }
  else
  {
    v5 = (v4 + 1) / 8;
    v6 = 40 * v5;
    v7 = 20 * v5;
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
      a1,
      20 * v5 + a1,
      40 * v5 + a1,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
      a2 - v7,
      a2,
      v7 + a2,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
      a3 - v6,
      a3 - v7,
      a3,
      a4);
    std::_Med3<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
      v7 + a1,
      a2,
      a3 - v7,
      a4);
  }
}

//----- (6E66E9F7) --------------------------------------------------------
void __stdcall std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3)
{
  if ( (a2 - a1) / 20 > 1 )
    std::_Pop_heap_0<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,CBindPath,std::less<CBindPath>>(
      a1,
      a2,
      a3,
      0);
}

//----- (6E66EA26) --------------------------------------------------------
void __thiscall CBindingSet::RemoveBindPathsWithComponent(CBindingSet *this, const struct CComponent *a2)
{
  CBindingSet *v2; // edi@1
  int v3; // esi@1
  int v4; // [sp+8h] [bp-4h]@3

  v2 = this;
  v3 = *((_DWORD *)this + 2);
  while ( v3 != *((_DWORD *)v2 + 3) )
  {
    if ( CComponentList::FComponentInList((CComponentList *)v3, a2) )
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::erase((int)((char *)v2 + 4), (int)&v4, v3);
    else
      v3 += 20;
  }
}

//----- (6E66EA65) --------------------------------------------------------
int __stdcall std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ST08_4@15
  int v7; // eax@27
  int v8; // ecx@27
  int v9; // ecx@28
  int v10; // eax@32
  int result; // eax@34
  int v12; // [sp+Ch] [bp-Ch]@18
  unsigned int v13; // [sp+10h] [bp-8h]@11
  int v14; // [sp+14h] [bp-4h]@11

  v4 = a2 + 20 * ((signed int)(a3 - a2) / 20 / 2);
  std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(
    a2,
    a2 + 20 * ((signed int)(a3 - a2) / 20 / 2),
    a3 - 20,
    a4);
  v5 = v4 + 20;
  while ( a2 < (unsigned int)v4 && !CBindPath::operator>(v4 - 20, v4) && !CBindPath::operator>(v4, v4 - 20) )
    v4 -= 20;
  while ( v5 < a3 && !CBindPath::operator>(v5, v4) && !CBindPath::operator>(v4, v5) )
    v5 += 20;
  v14 = v5;
  v13 = v4;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v14 < a3; v14 += 20 )
      {
        if ( !CBindPath::operator>(v4, v14) )
        {
          if ( CBindPath::operator>(v14, v4) )
            break;
          v6 = v5;
          v5 += 20;
          std::swap<CBindPath>(v6, v14);
        }
      }
      if ( a2 < v13 )
      {
        v12 = v13 - 20;
        do
        {
          if ( !CBindPath::operator>(v12, v4) )
          {
            if ( CBindPath::operator>(v4, v12) )
              break;
            v4 -= 20;
            std::swap<CBindPath>(v4, v12);
          }
          v13 -= 20;
          v12 -= 20;
        }
        while ( a2 < v13 );
      }
      if ( v13 == a2 )
        break;
      v9 = v13 - 20;
      v13 -= 20;
      if ( v14 == a3 )
      {
        v4 -= 20;
        if ( v9 != v4 )
          std::swap<CBindPath>(v9, v4);
        v5 -= 20;
        std::swap<CBindPath>(v4, v5);
      }
      else
      {
        v10 = v14;
        v14 += 20;
        std::swap<CBindPath>(v10, v9);
      }
    }
    if ( v14 == a3 )
      break;
    if ( v5 != v14 )
      std::swap<CBindPath>(v4, v5);
    v7 = v14;
    v14 += 20;
    v8 = v4;
    v5 += 20;
    v4 += 20;
    std::swap<CBindPath>(v8, v7);
  }
  result = a1;
  *(_DWORD *)a1 = v4;
  *(_DWORD *)(a1 + 4) = v5;
  return result;
}

//----- (6E66EBDE) --------------------------------------------------------
int __stdcall std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3)
{
  int result; // eax@3

  while ( 1 )
  {
    result = (a2 - a1) / 20;
    if ( result <= 1 )
      break;
    std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(a1, a2, a3);
    a2 -= 20;
  }
  return result;
}

//----- (6E66EC11) --------------------------------------------------------
void __stdcall std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::greater<CBindPath>>(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // edi@7
  int v6; // ebx@8

  v3 = a1;
  if ( a1 != a2 )
  {
    v4 = a1 + 20;
    if ( a1 + 20 != a2 )
    {
      while ( 1 )
      {
        if ( CBindPath::operator>(v4, v3) )
        {
          std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(v3, v4, v4 + 20);
        }
        else
        {
          v5 = v4 - 20;
          if ( CBindPath::operator>(v4, v4 - 20) )
          {
            do
            {
              v6 = v5;
              v5 -= 20;
            }
            while ( CBindPath::operator>(v4, v5) );
            if ( v6 != v4 )
              std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(v6, v4, v4 + 20);
          }
        }
        v4 += 20;
        if ( v4 == a2 )
          break;
        v3 = a1;
      }
    }
  }
}

//----- (6E66EC85) --------------------------------------------------------
int __stdcall std::_Unguarded_partition<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // ST08_4@15
  int v7; // eax@27
  int v8; // ecx@27
  int v9; // ecx@28
  int v10; // eax@32
  int result; // eax@34
  int v12; // [sp+Ch] [bp-Ch]@18
  unsigned int v13; // [sp+10h] [bp-8h]@11
  int v14; // [sp+14h] [bp-4h]@11

  v4 = a2 + 20 * ((signed int)(a3 - a2) / 20 / 2);
  std::_Median<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(
    a2,
    a2 + 20 * ((signed int)(a3 - a2) / 20 / 2),
    a3 - 20,
    a4);
  v5 = v4 + 20;
  while ( a2 < (unsigned int)v4 && !CBindPath::operator<(v4 - 20, v4) && !CBindPath::operator<(v4, v4 - 20) )
    v4 -= 20;
  while ( v5 < a3 && !CBindPath::operator<(v5, v4) && !CBindPath::operator<(v4, v5) )
    v5 += 20;
  v14 = v5;
  v13 = v4;
  while ( 1 )
  {
    while ( 1 )
    {
      for ( ; v14 < a3; v14 += 20 )
      {
        if ( !CBindPath::operator<(v4, v14) )
        {
          if ( CBindPath::operator<(v14, v4) )
            break;
          v6 = v5;
          v5 += 20;
          std::swap<CBindPath>(v6, v14);
        }
      }
      if ( a2 < v13 )
      {
        v12 = v13 - 20;
        do
        {
          if ( !CBindPath::operator<(v12, v4) )
          {
            if ( CBindPath::operator<(v4, v12) )
              break;
            v4 -= 20;
            std::swap<CBindPath>(v4, v12);
          }
          v13 -= 20;
          v12 -= 20;
        }
        while ( a2 < v13 );
      }
      if ( v13 == a2 )
        break;
      v9 = v13 - 20;
      v13 -= 20;
      if ( v14 == a3 )
      {
        v4 -= 20;
        if ( v9 != v4 )
          std::swap<CBindPath>(v9, v4);
        v5 -= 20;
        std::swap<CBindPath>(v4, v5);
      }
      else
      {
        v10 = v14;
        v14 += 20;
        std::swap<CBindPath>(v10, v9);
      }
    }
    if ( v14 == a3 )
      break;
    if ( v5 != v14 )
      std::swap<CBindPath>(v4, v5);
    v7 = v14;
    v14 += 20;
    v8 = v4;
    v5 += 20;
    v4 += 20;
    std::swap<CBindPath>(v8, v7);
  }
  result = a1;
  *(_DWORD *)a1 = v4;
  *(_DWORD *)(a1 + 4) = v5;
  return result;
}

//----- (6E66EDFE) --------------------------------------------------------
int __stdcall std::sort_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3)
{
  int result; // eax@3

  while ( 1 )
  {
    result = (a2 - a1) / 20;
    if ( result <= 1 )
      break;
    std::pop_heap<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(a1, a2, a3);
    a2 -= 20;
  }
  return result;
}

//----- (6E66EE31) --------------------------------------------------------
void __stdcall std::_Insertion_sort<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>,std::less<CBindPath>>(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // edi@7
  int v6; // ebx@8

  v3 = a1;
  if ( a1 != a2 )
  {
    v4 = a1 + 20;
    if ( a1 + 20 != a2 )
    {
      while ( 1 )
      {
        if ( CBindPath::operator<(v4, v3) )
        {
          std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(v3, v4, v4 + 20);
        }
        else
        {
          v5 = v4 - 20;
          if ( CBindPath::operator<(v4, v4 - 20) )
          {
            do
            {
              v6 = v5;
              v5 -= 20;
            }
            while ( CBindPath::operator<(v4, v5) );
            if ( v6 != v4 )
              std::rotate<std::_Vector_iterator<CBindPath,std::nc_allocator<CBindPath>>>(v6, v4, v4 + 20);
          }
        }
        v4 += 20;
        if ( v4 == a2 )
          break;
        v3 = a1;
      }
    }
  }
}

//----- (6E66EEA5) --------------------------------------------------------
unsigned __int32 __stdcall CbOfMultiSzAndTermSafe(const unsigned __int16 *a1)
{
  return 2 * CchOfMultiSzAndTermSafe(a1);
}

//----- (6E66EEBD) --------------------------------------------------------
void *__thiscall CDiagContext::GrowScratchBuffer(CDiagContext *this, unsigned __int32 *a2)
{
  CDiagContext *v2; // esi@1
  void *v3; // eax@1
  unsigned __int32 v4; // eax@2

  v2 = this;
  MemFree(*((void **)this + 3));
  v3 = MemAlloc(*a2);
  *((_DWORD *)v2 + 3) = v3;
  if ( v3 )
    v4 = *a2;
  else
    v4 = 0;
  *((_DWORD *)v2 + 4) = v4;
  *a2 = v4;
  return (void *)*((_DWORD *)v2 + 3);
}

//----- (6E66EEF8) --------------------------------------------------------
__int32 __stdcall HrWriteFilteredAdapterUpperBind(HKEY hKey, BYTE *lpData)
{
  __int32 v2; // esi@1

  v2 = HrCreateLinkageKey((GUID *)hKey, 0, 0, &hKey);
  if ( !v2 )
  {
    v2 = HrRegSetMultiSz(hKey, L"UpperBind", lpData);
    RegCloseKey(hKey);
  }
  return v2;
}

//----- (6E66EF3B) --------------------------------------------------------
__int32 __stdcall HrWriteFilterDeviceLinkage(struct CFilterDevice *a1, void *a2, const unsigned __int16 *a3, const unsigned __int16 *a4, const unsigned __int16 *a5)
{
  const unsigned __int16 *v5; // esi@1
  const unsigned __int16 *i; // esi@3
  const unsigned __int16 *j; // esi@6
  __int32 v8; // esi@9
  int v9; // eax@14
  HKEY phkResult; // [sp+18h] [bp-214h]@1
  HKEY hKey; // [sp+1Ch] [bp-210h]@9
  WCHAR SubKey; // [sp+20h] [bp-20Ch]@15

  v5 = a3;
  phkResult = (HKEY)a5;
  CDiagContext::Printf(
    (DWORD)g_pDiagCtx,
    3,
    "   %S filter over %S adapter\n",
    *(_DWORD *)(*((_DWORD *)a1 + 1) + 28),
    *(_DWORD *)(*(_DWORD *)a1 + 32));
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      Export:\n");
  if ( *a3 )
  {
    do
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "         %S\n", v5);
      v5 += wcslen(v5) + 1;
    }
    while ( *v5 );
  }
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      RootDevice:\n");
  for ( i = a4; *i; i += wcslen(i) + 1 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "         %S\n", i);
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      UpperBind:\n");
  for ( j = (const unsigned __int16 *)phkResult; *j; j += wcslen(j) + 1 )
    CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "         %S\n", j);
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "\n");
  v8 = HrCreateLinkageKey(0, a1, a2, &hKey);
  if ( !v8 )
  {
    v8 = HrRegSetMultiSz(hKey, L"Export", (BYTE *)a3);
    if ( !v8 )
    {
      v8 = HrRegSetMultiSz(hKey, L"RootDevice", (BYTE *)a4);
      if ( !v8 )
        v8 = HrRegSetMultiSz(hKey, L"UpperBind", (BYTE *)phkResult);
    }
    RegDeleteValueW(hKey, L"BindPath");
    RegDeleteValueW(hKey, L"Bind");
    RegDeleteValueW(hKey, L"Route");
    RegDeleteKeyW(hKey, L"Disabled");
    RegCloseKey(hKey);
  }
  v9 = *((_DWORD *)a1 + 1);
  if ( *(_DWORD *)(v9 + 48) )
  {
    StringCchPrintfW(
      &SubKey,
      0x104u,
      L"System\\CurrentControlSet\\Services\\%s\\Parameters\\Adapters\\%s",
      *(_DWORD *)(v9 + 48),
      *(_DWORD *)(*(_DWORD *)a1 + 100));
    v8 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0, 0x20006u, 0, &phkResult, 0);
    if ( !v8 )
    {
      v8 = HrRegSetSz(phkResult, L"UpperBindings", (BYTE *)a3);
      RegCloseKey(phkResult);
    }
  }
  return v8;
}

//----- (6E66F2A4) --------------------------------------------------------
__int32 __stdcall CRegistryBindingsContext::HrDeleteBindingsForComponent(const struct CComponent *rguid)
{
  return HrWriteLinkageValues((GUID *)rguid, &String, &String, &String);
}

//----- (6E66F2C2) --------------------------------------------------------
__int32 __thiscall CModifyContext::HrDirtyComponent(CModifyContext *this, const struct CComponent *a2)
{
  CModifyContext *v2; // esi@1
  __int32 result; // eax@1

  v2 = this;
  result = CComponentList::HrInsertComponent((CModifyContext *)((char *)this + 104), a2, 0x1200u);
  *((_DWORD *)v2 + 55) = result;
  return result;
}

//----- (6E66F2EA) --------------------------------------------------------
__int32 __thiscall CModifyContext::HrDirtyComponentAndComponentsAbove(CModifyContext *this, const struct CComponent *a2)
{
  CModifyContext *v2; // esi@1
  __int32 v3; // eax@1
  CModifyContext *v5; // [sp+4h] [bp-Ch]@2
  CModifyContext *v6; // [sp+8h] [bp-8h]@2
  int v7; // [sp+Ch] [bp-4h]@2

  v2 = this;
  v3 = CModifyContext::HrDirtyComponent(this, a2);
  *((_DWORD *)v2 + 55) = v3;
  if ( !v3 )
  {
    v7 = 0;
    v5 = (CModifyContext *)((char *)v2 - 52);
    v6 = (CModifyContext *)((char *)v2 + 104);
    GetComponentsAboveComponent(a2, (struct GCCONTEXT *)&v5);
    *((_DWORD *)v2 + 55) = v7;
  }
  return *((_DWORD *)v2 + 55);
}

//----- (6E66F340) --------------------------------------------------------
void __thiscall CModifyContext::PushRecursionDepth(CModifyContext *this)
{
  ++*((_DWORD *)this + 54);
}

//----- (6E66F34C) --------------------------------------------------------
void __thiscall CModifyContext::InstallOrRemoveRequiredComponents(CModifyContext *this, HKEY a2, int a3)
{
  unsigned __int32 v3; // ecx@2
  CModifyContext *v4; // esi@8
  unsigned int v5; // edx@9
  __int32 v6; // eax@14
  int v7; // eax@16
  struct CComponent *v8; // edi@16
  signed int v9; // eax@17
  int v10; // [sp+Ch] [bp-274h]@9
  HKEY v11; // [sp+10h] [bp-270h]@9
  int v12; // [sp+24h] [bp-25Ch]@14
  __int32 v13; // [sp+28h] [bp-258h]@15
  unsigned __int16 *v14; // [sp+2Ch] [bp-254h]@15
  unsigned int v15; // [sp+30h] [bp-250h]@15
  int *v16; // [sp+34h] [bp-24Ch]@15
  int v17; // [sp+40h] [bp-240h]@15
  int v18; // [sp+44h] [bp-23Ch]@15
  int v19; // [sp+48h] [bp-238h]@15
  int v20; // [sp+4Ch] [bp-234h]@15
  HKEY v21; // [sp+50h] [bp-230h]@1
  SP_LOG_TOKEN LogToken; // [sp+54h] [bp-22Ch]@1
  CModifyContext *v23; // [sp+5Ch] [bp-224h]@1
  void *lpMem; // [sp+60h] [bp-220h]@1
  HKEY hKey; // [sp+64h] [bp-21Ch]@1
  __int32 v26; // [sp+68h] [bp-218h]@2
  unsigned __int16 v27; // [sp+6Ch] [bp-214h]@14
  unsigned __int16 v28[2]; // [sp+274h] [bp-Ch]@1
  wchar_t v29; // [sp+278h] [bp-8h]@1

  *(_DWORD *)v28 = *(_DWORD *)L", ";
  v23 = this;
  hKey = a2;
  v29 = asc_6E66F630[2];
  LogToken = SetupGetThreadLogToken();
  lpMem = 0;
  if ( !CComponent::HrOpenInstanceKey((CComponent *)a2, 0x20019u, &v21, 0, 0) )
  {
    v26 = HrRegOpenKeyEx(v21, L"Ndi", 0x20019u, &hKey);
    if ( !v26 )
    {
      v26 = HrRegGetTypeWithAlloc(v3, hKey, L"RequiredAll", 1u, (unsigned __int8 **)&lpMem, 0);
      RegCloseKey(hKey);
    }
    if ( v26 == -2147024894 )
      v26 = 0;
    RegCloseKey(v21);
    if ( !v26 )
    {
      if ( lpMem )
      {
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "NCI: %ws requires %ws",
          *((_DWORD *)a2 + 7),
          lpMem);
        v4 = v23;
        if ( CComponent::HrGetINetCfgComponentInterface(
               (CComponent *)a2,
               *((struct CImplINetCfg **)v23 - 1),
               (struct INetCfgComponent **)&hKey) )
        {
LABEL_21:
          MemFree(lpMem);
          return;
        }
        memset(&v10, 0, 0x18u);
        v11 = hKey;
        v10 = 2;
        v5 = GetNextStringToken((unsigned __int16 *)lpMem, v28, (unsigned __int16 **)&LogToken + 1);
        v26 = v5;
        if ( !v5 )
        {
LABEL_20:
          ReleaseObj((struct IUnknown *)hKey);
          goto LABEL_21;
        }
        while ( 1 )
        {
          if ( !*(_WORD *)v5 )
            goto LABEL_20;
          if ( a3 )
          {
            v7 = CComponentList::PFindComponentByInfId((CModifyContext *)((char *)v4 - 72), (wchar_t *)v5, 0);
            v8 = (struct CComponent *)v7;
            v23 = (CModifyContext *)v7;
            if ( !v7 )
              goto LABEL_19;
            v9 = FIsConsideredNetClass(*(_DWORD *)(v7 + 16));
            CModifyContext::HrRemoveComponentIfNotReferenced(v4, v8, v9 == 0 ? (unsigned int)&v10 : 0, 0);
          }
          else
          {
            memset(&v12, 0, 0x1Cu);
            v6 = HrCiGetClassAndInfFileOfInfId((const unsigned __int16 *)v5, (enum NETCLASS *)&v12, &v27);
            *((_DWORD *)v4 + 55) = v6;
            if ( v6 )
              goto LABEL_20;
            v13 = v26;
            v17 = 0;
            v18 = 0;
            v19 = 0;
            v20 = 0;
            v14 = &v27;
            v15 = FIsConsideredNetClass(v12) == 0 ? (unsigned int)&v10 : 0;
            v16 = &v17;
            CModifyContext::HrInstallNewOrReferenceExistingComponent(
              v4,
              (const struct COMPONENT_INSTALL_PARAMS *)&v12,
              &v23);
          }
          if ( *((_DWORD *)v4 + 55) )
            goto LABEL_20;
LABEL_19:
          v26 = GetNextStringToken(0, v28, (unsigned __int16 **)&LogToken + 1);
          if ( !v26 )
            goto LABEL_20;
          v5 = v26;
        }
      }
    }
  }
}
// 6E66F630: using guessed type wchar_t asc_6E66F630[3];
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66F63B) --------------------------------------------------------
__int32 __thiscall CModifyContext::HrBeginBatchOperation(CModifyContext *this)
{
  ++*((_DWORD *)this + 54);
  return *((_DWORD *)this + 55);
}

//----- (6E66F64D) --------------------------------------------------------
__int32 __stdcall CModifyContext::HrProcessWinsockRemove(const struct CComponent *a2)
{
  __int32 v1; // esi@1
  DWORD Type; // [sp+8h] [bp-218h]@2
  void *v4; // [sp+Ch] [bp-214h]@1
  HKEY hKey; // [sp+10h] [bp-210h]@1
  wchar_t pszDest; // [sp+14h] [bp-20Ch]@3

  v4 = 0;
  hKey = 0;
  v1 = CComponent::HrOpenInfFile(a2, &v4);
  if ( !v1 )
  {
    Type = 520;
    v1 = CComponent::HrOpenInstanceKey(a2, 0x20019u, &hKey, 0, 0);
    if ( !v1 )
    {
      v1 = HrRegQueryTypeSzBuffer(hKey, L"InfSection", 1u, (LPBYTE)&pszDest, (DWORD)&Type);
      if ( !v1 )
      {
        StringCchCatW(&pszDest, 0x104u, L".Remove");
        v1 = HrAddOrRemoveWinsockDependancy(v4, &pszDest);
      }
      RegSafeCloseKey(hKey);
    }
  }
  return v1;
}

//----- (6E66F724) --------------------------------------------------------
int __thiscall CModifyContext::HrPopRecursionDepth(CModifyContext *this)
{
  bool v1; // zf@1
  int result; // eax@2

  v1 = (*((_DWORD *)this + 54))-- == 1;
  if ( v1 )
    result = CModifyContext::HrApplyIfOkOrCancel(this, *((_DWORD *)this + 55) == 0);
  else
    result = *((_DWORD *)this + 55);
  return result;
}

//----- (6E66F74A) --------------------------------------------------------
int __thiscall CModifyContext::HrUpdateComponent(CModifyContext *this, struct CComponent *a2, unsigned __int32 a3, unsigned __int32 a4)
{
  CModifyContext *v4; // edi@1
  int v5; // esi@1
  int v6; // eax@3
  struct CBindPath *v7; // eax@6
  struct CBindPath *v8; // eax@11
  int v9; // esi@17
  char v11; // [sp+Ch] [bp-38h]@1
  int v12; // [sp+10h] [bp-34h]@1
  struct CBindPath *v13; // [sp+14h] [bp-30h]@6
  struct CBindPath *v14; // [sp+18h] [bp-2Ch]@10
  char v15; // [sp+20h] [bp-24h]@5
  int v16; // [sp+24h] [bp-20h]@1
  struct CBindPath *v17; // [sp+28h] [bp-1Ch]@11
  struct CBindPath *v18; // [sp+2Ch] [bp-18h]@15
  struct CBindPath *v19; // [sp+34h] [bp-10h]@6
  int v20; // [sp+40h] [bp-4h]@1

  v4 = this;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v12, 0);
  v20 = 0;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v16, 0);
  ++*((_DWORD *)v4 + 54);
  v5 = (int)((char *)v4 - 72);
  LOBYTE(v20) = 1;
  if ( !CNetConfigCore::HrGetBindingsInvolvingComponent(
          (CModifyContext *)((char *)v4 - 72),
          a2,
          0,
          (struct CBindingSet *)&v11)
    && !CExternalComponentData::HrReloadExternalData((struct CComponent *)((char *)a2 + 36)) )
  {
    v6 = CStackTable::HrUpdateEntriesForComponent(
           (CStackTable *)(v5 + 20),
           a2,
           (CModifyContext *)((char *)v4 - 72),
           0x1000u);
    if ( v6
      || (v6 = CNetConfigCore::HrGetBindingsInvolvingComponent(
                 (CModifyContext *)((char *)v4 - 72),
                 a2,
                 0,
                 (struct CBindingSet *)&v15)) != 0 )
    {
      *((_DWORD *)v4 + 55) = v6;
    }
    else
    {
      v7 = v13;
      v19 = v13;
      while ( v7 != v14 )
      {
        if ( !CBindingSet::FContainsBindPath((CBindingSet *)&v15, v19) )
        {
          CBindingSet::HrAddBindPath((CModifyContext *)((char *)v4 + 84), v19, 0x600u);
          CBindingSet::RemoveBindPath((CBindingSet *)(v5 + 44), v19);
          CGlobalNotifyInterface::NotifyBindPath((CGlobalNotifyInterface *)(v5 + 64), 2u, v19, 0);
        }
        v19 = (struct CBindPath *)((char *)v19 + 20);
        v7 = v19;
      }
      v8 = v17;
      v19 = v17;
      while ( v8 != v18 )
      {
        if ( !CBindingSet::FContainsBindPath((CBindingSet *)&v11, v19) )
        {
          CBindingSet::HrAddBindPath((CModifyContext *)((char *)v4 + 64), v19, 0x600u);
          CGlobalNotifyInterface::NotifyBindPath((CGlobalNotifyInterface *)(v5 + 64), 0x11u, v19, 0);
        }
        v19 = (struct CBindPath *)((char *)v19 + 20);
        v8 = v19;
      }
      CGlobalNotifyInterface::ComponentUpdated((CGlobalNotifyInterface *)(v5 + 64), a2, a3, a4);
    }
  }
  v9 = CModifyContext::HrPopRecursionDepth(v4);
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v16);
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v12);
  return v9;
}

//----- (6E66F89E) --------------------------------------------------------
int __thiscall CModifyContext::HrEndBatchOperation(int this, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    result = CModifyContext::HrPopRecursionDepth((CModifyContext *)this);
  }
  else
  {
    result = 0;
    *(_DWORD *)(this + 216) = 0;
  }
  return result;
}

//----- (6E66F8C1) --------------------------------------------------------
signed int __stdcall CImplIEnumNetCfgComponent::Clone(CImplIEnumNetCfgComponent *this, struct IEnumNetCfgComponent **a2)
{
  return -2147467263;
}

//----- (6E66F8CE) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Skip(CImplIEnumNetCfgBindingInterface *this, unsigned __int32 a2)
{
  return CImplIEnumNetCfgBindingInterface::HrNextOrSkip(this, a2, 0, 0);
}

//----- (6E66F8EB) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingInterface::Reset(CImplIEnumNetCfgBindingInterface *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // ST00_4@1

  EnterCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  v1 = (struct _RTL_CRITICAL_SECTION *)(*((_DWORD *)this + 3) + 24);
  *((_DWORD *)this + 5) = 1;
  LeaveCriticalSection(v1);
  return 0;
}

//----- (6E66F921) --------------------------------------------------------
signed int __stdcall CImplIEnumNetCfgComponent::Skip(CImplIEnumNetCfgComponent *this, unsigned __int32 a2)
{
  return CImplIEnumNetCfgComponent::HrNextOrSkip(this, a2, 0, 0);
}

//----- (6E66F93E) --------------------------------------------------------
__int32 __stdcall CImplIEnumNetCfgBindingPath::Skip(CImplIEnumNetCfgBindingPath *this, unsigned __int32 a2)
{
  return CImplIEnumNetCfgBindingPath::HrNextOrSkip(this, a2, 0, 0);
}

//----- (6E66F95B) --------------------------------------------------------
void *__thiscall CBindingSet::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)((char *)lpMem + 4));
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E66F984) --------------------------------------------------------
void *__thiscall CImplIEnumNetCfgBindingPath::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CImplIEnumNetCfgBindingPath::~CImplIEnumNetCfgBindingPath((CImplIEnumNetCfgBindingPath *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E66F9E1) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplIEnumNetCfgBindingPath>::QueryInterface(CImplIEnumNetCfgBindingPath *a1, struct _GUID *a2, void **a3)
{
  return CImplIEnumNetCfgBindingPath::_InternalQueryInterface(a1, a2, a3);
}

//----- (6E66F9FD) --------------------------------------------------------
__int32 __thiscall CExternalComponentData::HrReloadExternalData(CExternalComponentData *this)
{
  CExternalComponentData *v1; // esi@1

  v1 = this;
  CExternalComponentData::FreeExternalData(this);
  memset((void *)v1, 0, 0x4Cu);
  return CExternalComponentData::HrEnsureExternalDataLoaded(v1);
}

//----- (6E66FA21) --------------------------------------------------------
signed int __thiscall CExternalComponentData::HrSetDescription(CExternalComponentData *this, const unsigned __int16 *a2)
{
  CExternalComponentData *v2; // edi@1
  signed int v3; // ebx@1
  unsigned int v4; // eax@1
  unsigned __int16 *v5; // esi@1
  unsigned int v6; // eax@2

  v2 = this;
  CExternalComponentData::FreeDescription(this);
  v3 = -2147024882;
  v4 = CbOfSzAndTerm(a2);
  v5 = (unsigned __int16 *)MemAlloc(v4);
  *((_DWORD *)v2 + 1) = v5;
  if ( v5 )
  {
    v6 = CbOfSzAndTerm(a2);
    StringCbCopyW(v5, v6, a2);
    v3 = 0;
  }
  return v3;
}

//----- (6E66FA6E) --------------------------------------------------------
int __stdcall CImplINetCfgClass::SelectAndInstall(CImplINetCfgClass *this, HWND a2, struct tagOBO_TOKEN *a3, struct INetCfgComponent **a4)
{
  return (*(int (__stdcall **)(int, HWND, _DWORD, struct tagOBO_TOKEN *, _DWORD, struct INetCfgComponent **))(*(_DWORD *)(*((_DWORD *)this + 3) + 8) + 20))(
           *((_DWORD *)this + 3) + 8,
           a2,
           *(&MAP_NETCLASS_TO_GUID.Data1 + *((_DWORD *)this + 4)),
           a3,
           0,
           a4);
}

//----- (6E66FAA0) --------------------------------------------------------
signed int __stdcall CImplINetCfgClass::FindComponent(CImplINetCfgClass *this, wchar_t *Str1, struct INetCfgComponent **a3)
{
  signed int v3; // ebx@2
  int v4; // eax@6
  int v5; // edi@6

  if ( wcslen(Str1) < 0xC8 )
  {
    if ( a3 )
      *a3 = 0;
    v3 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplINetCfgClass *)((char *)this + 8), 0);
    if ( !v3 )
    {
      v4 = CComponentList::PFindComponentByInfId(*(CComponentList **)(*((_DWORD *)this + 4) + 48), Str1, 0);
      v5 = v4;
      if ( v4
        && CExternalComponentData::FLoadedOkayIfLoadedAtAll((CExternalComponentData *)(v4 + 36))
        && *((_DWORD *)this + 5) == *(_DWORD *)(v5 + 16) )
      {
        v3 = 0;
        if ( a3 )
          v3 = CComponent::HrGetINetCfgComponentInterface((CComponent *)v5, *((struct CImplINetCfg **)this + 4), a3);
      }
      else
      {
        v3 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 4) + 24));
    }
  }
  else
  {
    v3 = -2147024809;
  }
  return v3;
}

//----- (6E66FB46) --------------------------------------------------------
signed int __stdcall CImplINetCfgClass::Install(CImplINetCfgClass *this, const unsigned __int16 *a2, struct tagOBO_TOKEN *a3, unsigned __int32 a4, unsigned __int32 a5, const unsigned __int16 *a6, const unsigned __int16 *a7, struct INetCfgComponent **a8)
{
  signed int v8; // edi@5
  int v10; // [sp+Ch] [bp-34h]@10
  const unsigned __int16 *v11; // [sp+10h] [bp-30h]@10
  struct tagOBO_TOKEN *v12; // [sp+18h] [bp-28h]@10
  int *v13; // [sp+1Ch] [bp-24h]@10
  unsigned __int32 v14; // [sp+28h] [bp-18h]@10
  unsigned __int32 v15; // [sp+2Ch] [bp-14h]@10
  const unsigned __int16 *v16; // [sp+30h] [bp-10h]@10
  const unsigned __int16 *v17; // [sp+34h] [bp-Ch]@10
  SP_LOG_TOKEN LogToken; // [sp+38h] [bp-8h]@1

  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(LogToken, 0x40000000u, (5 - (g_IsInUpgrade != 0)) | 0x10000, "NCI: Enter INetCfgClass::Install");
  if ( FOboTokenValidForClass((int)a3, *((_DWORD *)this + 4)) )
  {
    if ( *a2 && (a7 != 0) == (a6 != 0) && wcslen(a2) < 0xC8 )
    {
      v8 = HrProbeOboToken(a3);
      if ( !v8 )
      {
        if ( a8 )
          *a8 = 0;
        v8 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplINetCfgClass *)((char *)this + 4), 0x32u);
        if ( !v8 )
        {
          v14 = a4;
          v15 = a5;
          v16 = a6;
          v17 = a7;
          memset(&v10, 0, 0x1Cu);
          v10 = *((_DWORD *)this + 4);
          v11 = a2;
          v12 = a3;
          v13 = (int *)&v14;
          v8 = CModifyContext::HrInstallNewOrReferenceExistingComponent(
                 (CModifyContext *)(*(_DWORD *)(*((_DWORD *)this + 3) + 48) + 72),
                 (const struct COMPONENT_INSTALL_PARAMS *)&v10,
                 (struct CComponent **)&a3);
          if ( v8 >= 0 && a8 )
            CComponent::HrGetINetCfgComponentInterface((CComponent *)a3, *((struct CImplINetCfg **)this + 3), a8);
          LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
        }
      }
    }
    else
    {
      v8 = -2147024809;
    }
  }
  else
  {
    v8 = -2147467261;
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfgClass::Install, hr = %08xx.",
    v8);
  return v8;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66FD12) --------------------------------------------------------
signed int __stdcall CImplINetCfgClass::DeInstall(CImplINetCfgClass *this, struct INetCfgComponent *a2, struct tagOBO_TOKEN *cb, unsigned __int16 **a4)
{
  CImplINetCfgClass *v4; // edi@1
  struct INetCfgComponentVtbl *v5; // esi@10
  void *v6; // esi@12
  struct INetCfgComponentVtbl *v7; // ebx@16
  void *v8; // eax@16
  unsigned __int16 *i; // ebx@18
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-4h]@2

  v4 = this;
  LogToken = SetupGetThreadLogToken();
  if ( FOboTokenValidForClass((int)cb, *((_DWORD *)this + 4)) )
  {
    v12 = HrProbeOboToken(cb);
    if ( !v12 )
    {
      if ( a4 )
        *a4 = 0;
      if ( a2[7].lpVtbl && GetEnvironmentVariableW(L"INSTALLER_SHADOWED_COMPONENT_PAYLOAD", 0, 0) )
        a2[7].lpVtbl[2].GetDeviceStatus = (HRESULT (__stdcall *)(INetCfgComponent *, ULONG *))1;
      v12 = CImplINetCfgHolder::HrLockAndTestForValidInterface((CImplINetCfgClass *)((char *)this + 4), 0x32u);
      if ( !v12 )
      {
        v12 = CImplINetCfgComponent::HrIsValidInterface((CImplINetCfgComponent *)a2, 4u);
        if ( !v12 )
        {
          v5 = a2[7].lpVtbl;
          if ( FIsPhysicalAdapter(*((_DWORD *)this + 4), (char)v5->GetId) )
          {
            v12 = -2146500090;
          }
          else
          {
            if ( v5->GetInstanceGuid )
              v6 = v5->GetInstanceGuid;
            else
              v6 = v5->GetCharacteristics;
            _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI BEGIN DEINSTALL %ws]", v6);
            v12 = CModifyContext::HrRemoveComponentIfNotReferenced(
                    (CModifyContext *)(*(_DWORD *)(*((_DWORD *)this + 3) + 48) + 72),
                    (struct CComponent *)a2[7].lpVtbl,
                    (SIZE_T)cb,
                    a4);
            if ( v12 == 303139 && a4 )
            {
              v7 = a2[7].lpVtbl;
              v8 = v7->GetInstanceGuid;
              if ( !v8 )
                v8 = v7->GetCharacteristics;
              _SetupWriteTextLog(
                LogToken,
                0x40000000u,
                5 - (g_IsInUpgrade != 0),
                "! NCI: %ws is still referenced by",
                v8);
              for ( i = *a4; *i; i += wcslen(i) + 1 )
                _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "%ws", i);
            }
            _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "[NCI END DEINSTALL]");
            v4 = this;
          }
        }
        LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v4 + 3) + 24));
      }
    }
  }
  else
  {
    v12 = -2147467261;
  }
  return v12;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E66FF3B) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgClass>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfgClass>::QueryInterface((CImplINetCfgClass *)(a1 - 4), a2, a3);
}

//----- (6E66FF4A) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::AddRef(int a1)
{
  return ATL::CComObject<CImplINetCfgClass>::AddRef(a1 - 4);
}

//----- (6E66FF59) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgClass>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfgClass>::Release((void *)(a1 - 4));
}

//----- (6E66FF68) --------------------------------------------------------
void __thiscall CModifyContext::InstallAndAddAndNotifyComponent(CModifyContext *this, const struct COMPONENT_INSTALL_PARAMS *a2, struct CComponent **a3)
{
  CModifyContext *v3; // esi@1
  __int32 v4; // eax@2
  __int32 v5; // eax@10
  int v6; // eax@11
  int v7; // eax@12
  __int32 v8; // eax@14
  SP_LOG_TOKEN LogToken; // [sp+4h] [bp-14h]@1
  int v10; // [sp+Ch] [bp-Ch]@9
  CComponentList *v11; // [sp+10h] [bp-8h]@1
  struct CComponent *v12; // [sp+14h] [bp-4h]@2
  int v13; // [sp+20h] [bp+8h]@12

  v3 = this;
  LogToken = SetupGetThreadLogToken();
  v11 = CModifyContext::PNetConfig(v3);
  if ( *((_DWORD *)a2 + 6) )
  {
    v12 = (struct CComponent *)*((_DWORD *)a2 + 6);
  }
  else
  {
    v4 = HrCiInstallComponent(a2, &v12, 0);
    *((_DWORD *)v3 + 55) = v4;
    if ( v4 )
      return;
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "[NCI BEGIN RC: Install any components required by %ws]",
    *((_DWORD *)v12 + 7));
  CModifyContext::InstallOrRemoveRequiredComponents(v3, (HKEY)v12, 0);
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "[NCI END RC: Install any components required by %ws. Result 0x%08X]",
    *((_DWORD *)v12 + 7),
    *((_DWORD *)v3 + 55));
  if ( !*((_DWORD *)v3 + 55) )
  {
    if ( FIsConsideredNetClass(*((_DWORD *)v12 + 4)) )
    {
      _SetupWriteTextLog(LogToken, 0x40000000u, 5 - (g_IsInUpgrade != 0), "NCI: pnp id %ws", *((_DWORD *)v12 + 8));
      while ( 1 )
      {
        v10 = CComponentList::PFindComponentByPnpId(v11, *((const unsigned __int16 **)v12 + 8));
        if ( !v10 )
          break;
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "! NCI: Found %ws already in core replacing with this instance",
          *((_DWORD *)v12 + 8));
        CComponentReferences::RemoveAllReferences((CComponentReferences *)(v10 + 120));
        CModifyContext::HrRemoveComponentIfNotReferenced(v3, (struct CComponent *)v10, 0, 0);
      }
    }
    v5 = CNetConfigCore::HrAddComponentToCore(v11, v12, 0x1000u);
    *((_DWORD *)v3 + 55) = v5;
    if ( !v5 )
    {
      v6 = CGlobalNotifyInterface::ComponentAdded(
             (CComponentList *)((char *)v11 + 64),
             v12,
             *((const struct NETWORK_INSTALL_PARAMS **)a2 + 4));
      *((_DWORD *)v3 + 55) = v6;
      if ( !v6 )
      {
        v13 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v3 + 68));
        v7 = CNetConfigCore::HrGetBindingsInvolvingComponent(v11, v12, 1u, (CModifyContext *)((char *)v3 + 64));
        *((_DWORD *)v3 + 55) = v7;
        if ( !v7 )
        {
          if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v3 + 68)) <= (unsigned int)v13
            || (v8 = CGlobalNotifyInterface::QueryAndNotifyBindPaths(
                       (CComponentList *)((char *)v11 + 64),
                       1u,
                       (CModifyContext *)((char *)v3 + 64),
                       v13),
                (*((_DWORD *)v3 + 55) = v8) == 0) )
            *a3 = v12;
        }
      }
    }
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E670210) --------------------------------------------------------
int __thiscall CModifyContext::HrInstallNewOrReferenceExistingComponent(CModifyContext *this, const struct COMPONENT_INSTALL_PARAMS *a2, struct CComponent **a3)
{
  CModifyContext *v3; // edi@1
  CComponentList *v4; // eax@1
  int v5; // eax@2
  int v6; // ebx@2
  int result; // eax@4
  signed int v8; // eax@14

  v3 = this;
  *a3 = 0;
  v4 = CModifyContext::PNetConfig(this);
  if ( *((_DWORD *)a2 + 3) )
  {
    v5 = CComponentList::PFindComponentByInfId(v4, *((wchar_t **)a2 + 1), 0);
    v6 = v5;
    if ( v5 )
    {
      if ( *(_DWORD *)(v5 + 24) & 0x100 )
      {
        *a3 = 0;
        result = -2146500089;
      }
      else if ( CComponentReferences::FIsReferencedByOboToken(
                  (CComponentReferences *)(v5 + 120),
                  *((const struct tagOBO_TOKEN **)a2 + 3)) )
      {
        *a3 = (struct CComponent *)v6;
        result = 0;
      }
      else
      {
        CModifyContext::PushRecursionDepth(v3);
        v8 = CComponentReferences::HrAddReferenceByOboToken(
               (CComponentReferences *)(v6 + 120),
               *((const struct tagOBO_TOKEN **)a2 + 3));
        *((_DWORD *)v3 + 55) = v8;
        if ( !v8 )
          *a3 = (struct CComponent *)v6;
        result = CModifyContext::HrPopRecursionDepth(v3);
      }
      return result;
    }
    if ( CComponentList::PFindComponentByInfId(v3, *((wchar_t **)a2 + 1), 0) )
      return -2147418113;
  }
  if ( *((_DWORD *)a2 + 6) || !FIsComponentLockedDown(*((STRSAFE_LPCWSTR *)a2 + 1)) )
  {
    CModifyContext::PushRecursionDepth(v3);
    CModifyContext::InstallAndAddAndNotifyComponent(v3, a2, a3);
    result = CModifyContext::HrPopRecursionDepth(v3);
    if ( *((_DWORD *)v3 + 55) == -2146500093 )
      *((_DWORD *)v3 + 55) = 0;
  }
  else
  {
    result = -2147180507;
  }
  return result;
}

//----- (6E670303) --------------------------------------------------------
struct INetCfgComponentVtbl *__stdcall PComponentFromComInterface(struct INetCfgComponent *a1)
{
  return a1[7].lpVtbl;
}

//----- (6E670317) --------------------------------------------------------
signed int __stdcall HrIsValidINetCfgComponent(struct INetCfgComponent *a1)
{
  signed int result; // eax@2

  if ( a1 )
    result = CImplINetCfgComponent::HrIsValidInterface((CImplINetCfgComponent *)a1, 0);
  else
    result = -2147024882;
  return result;
}

//----- (6E67033A) --------------------------------------------------------
int __stdcall CImplINetCfgComponent::SetDisplayName(CImplINetCfgComponent *this, const unsigned __int16 *a2)
{
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-38h]@1
  HDEVINFO DeviceInfoSet; // [sp+14h] [bp-30h]@3
  BYTE *PropertyBuffer; // [sp+18h] [bp-2Ch]@1
  CImplINetCfgComponent *v6; // [sp+1Ch] [bp-28h]@1
  int v7; // [sp+20h] [bp-24h]@1
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+24h] [bp-20h]@3

  v6 = this;
  PropertyBuffer = (BYTE *)a2;
  LogToken = SetupGetThreadLogToken();
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Enter INetCfgComponent::SetDisplayName");
  v7 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 6u, 0, 0);
  if ( !v7 )
  {
    if ( FIsConsideredNetClass(*(_DWORD *)(*((_DWORD *)v6 + 7) + 16)) )
    {
      v7 = CComponent::HrOpenDeviceInfo(*((CComponent **)v6 + 7), &DeviceInfoSet, &DeviceInfoData);
      if ( !v7 )
      {
        v7 = HrSetupDiSetDeviceName(DeviceInfoSet, &DeviceInfoData, PropertyBuffer);
        if ( !v7 )
          CExternalComponentData::HrSetDescription(
            (CExternalComponentData *)(*((_DWORD *)v6 + 7) + 36),
            (const unsigned __int16 *)PropertyBuffer);
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      }
    }
    else
    {
      v7 = -2147467263;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v6 + 6) + 24));
  }
  _SetupWriteTextLog(
    LogToken,
    0x40000000u,
    (5 - (g_IsInUpgrade != 0)) | 0x10000,
    "NCI: Exit INetCfgComponent::SetDisplayName, hr = %08xx",
    v7);
  return v7;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E6704C1) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetHelpText(CImplINetCfgComponent *this, unsigned __int16 **a2)
{
  return CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy(this, 0x18u, a2);
}

//----- (6E6704DC) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetCharacteristics(CImplINetCfgComponent *this, unsigned __int32 *a2)
{
  signed int v2; // ebx@1

  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( v2 )
  {
    *a2 = 0;
  }
  else
  {
    *a2 = *(_DWORD *)(*((_DWORD *)this + 7) + 24);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 6) + 24));
  }
  return v2;
}

//----- (6E670526) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::GetPnpDevNodeId(CImplINetCfgComponent *this, unsigned __int16 **a2)
{
  signed int v2; // ebx@1
  int v3; // esi@2

  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 0, 0, 0);
  if ( v2 )
  {
    *a2 = 0;
  }
  else
  {
    v3 = *((_DWORD *)this + 7);
    if ( FIsConsideredNetClass(*(_DWORD *)(v3 + 16)) )
      v2 = HrCoTaskMemAllocAndDupSz(*(const unsigned __int16 **)(v3 + 32), a2, 0xC8u);
    else
      v2 = -2147467263;
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 6) + 24));
  }
  return v2;
}

//----- (6E67058D) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::OpenParamKeyReadOnly(CImplINetCfgComponent *this, PHKEY phkResult)
{
  HKEY *v2; // esi@1
  signed int v3; // ebx@1
  int v4; // ebx@2
  __int32 v5; // eax@5
  HKEY hKey; // [sp+Ch] [bp-4h]@5

  v2 = phkResult;
  *phkResult = 0;
  v3 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)((char *)this - 12), 4u, 0, 0);
  if ( !v3 )
  {
    v4 = *((_DWORD *)this + 4);
    if ( FIsConsideredNetClass(*(_DWORD *)(v4 + 16)) )
    {
      v3 = CComponent::HrOpenInstanceKey((CComponent *)v4, 0x20019u, v2, 0, 0);
    }
    else
    {
      if ( *(_DWORD *)(v4 + 48) )
        v5 = CComponent::HrOpenServiceKey((CComponent *)v4, 0x20019u, &hKey);
      else
        v5 = CComponent::HrOpenInstanceKey((CComponent *)v4, 0x20019u, &hKey, 0, 0);
      v3 = v5;
      if ( !v5 )
      {
        v3 = HrRegCreateKeyEx(hKey, L"Parameters", 0, 0x20019u, 0, phkResult, (LPDWORD)&phkResult);
        RegCloseKey(hKey);
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v3;
}

//----- (6E67063C) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::RaisePropertyUi(struct IUnknown *this, HWND hWnd, unsigned __int32 a3, struct IUnknown *a4)
{
  bool v4; // zf@1
  char v5; // al@1
  struct IUnknown *v6; // esi@6
  signed int v7; // ebx@6
  unsigned __int32 v8; // edi@6
  signed int v9; // edi@10
  struct IUnknownVtbl *v10; // ebx@12
  CNotifyObjectInterface *v11; // ecx@16
  signed int v12; // eax@17

  v4 = IsWindow(hWnd) == 0;
  v5 = a3;
  if ( v4 && a3 & 2 )
    return -2147024809;
  if ( !(a3 & 3) )
    return -2147024809;
  a3 &= 1u;
  if ( v5 & 1 )
  {
    if ( v5 & 2 )
      return -2147024809;
  }
  v6 = this;
  v7 = 0;
  v8 = 2;
  if ( a4
    && !this[6].lpVtbl[6].AddRef
    && !a4->lpVtbl->QueryInterface(a4, &IID_INetRasConnectionIpUiInfo, (void **)&this) )
  {
    v8 = 4;
    v7 = 1;
    ReleaseObj(this);
  }
  v9 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)v6, v8, 0, 0);
  if ( !v9 )
  {
    if ( v7 )
    {
      v10 = v6[7].lpVtbl;
      if ( wcscmp((const unsigned __int16 *)v10[2].AddRef, L"ms_tcpip")
        && wcscmp((const unsigned __int16 *)v10[2].AddRef, L"ms_tcpip6") )
      {
        v9 = -2147180508;
LABEL_20:
        LeaveCriticalSection((LPCRITICAL_SECTION)&v6[6].lpVtbl[2]);
        return v9;
      }
      v9 = CNotifyObjectInterface::HrEnsureNotifyObjectInitialized(
             (CNotifyObjectInterface *)&v10[9].AddRef,
             (struct CImplINetCfg *)v6[6].lpVtbl,
             0);
      if ( v9 )
        goto LABEL_20;
    }
    v11 = (CNotifyObjectInterface *)&v6[7].lpVtbl[9].AddRef;
    if ( a3 )
      v12 = CNotifyObjectInterface::HrQueryPropertyUi(v11, (struct CImplINetCfg *)v6[6].lpVtbl, a4);
    else
      v12 = CNotifyObjectInterface::HrShowPropertyUi(v11, (struct CImplINetCfg *)v6[6].lpVtbl, hWnd, a4);
    v9 = v12;
    goto LABEL_20;
  }
  return v9;
}
// 6E65C494: using guessed type wchar_t aMs_tcpip[9];
// 6E670798: using guessed type wchar_t aMs_tcpip6[10];

//----- (6E6707C1) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::QueryNotifyObject(CImplINetCfgComponent *this, const struct _GUID *a2, void **a3)
{
  signed int v3; // ebx@1

  *a3 = 0;
  v3 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)((char *)this - 8), 4u, 0, 0);
  if ( !v3 )
  {
    v3 = CNotifyObjectInterface::QueryNotifyObject(
           (CNotifyObjectInterface *)(*((_DWORD *)this + 5) + 112),
           *((struct CImplINetCfg **)this + 4),
           a2,
           a3);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 4) + 24));
  }
  return v3;
}

//----- (6E670814) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::SetDirty(CImplINetCfgComponent *this)
{
  signed int v1; // edi@1

  v1 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)((char *)this - 8), 2u, 0, 0);
  if ( !v1 )
  {
    v1 = CModifyContext::HrDirtyComponent(
           (CModifyContext *)(*(_DWORD *)(*((_DWORD *)this + 4) + 48) + 72),
           *((const struct CComponent **)this + 5));
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 4) + 24));
  }
  return v1;
}

//----- (6E67085F) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::NotifyUpperEdgeConfigChange(CImplINetCfgComponent *this)
{
  signed int v1; // edi@1

  v1 = CImplINetCfgComponent::HrLockAndTestForValidInterface((CImplINetCfgComponent *)((char *)this - 8), 2u, 0, 0);
  if ( !v1 )
  {
    v1 = CModifyContext::HrDirtyComponentAndComponentsAbove(
           (CModifyContext *)(*(_DWORD *)(*((_DWORD *)this + 4) + 48) + 72),
           *((const struct CComponent **)this + 5));
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 4) + 24));
  }
  return v1;
}

//----- (6E6708AA) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfgComponent>::QueryInterface((CImplINetCfgComponent *)(a1 - 4), a2, a3);
}

//----- (6E6708B9) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfgComponent>::QueryInterface((CImplINetCfgComponent *)(a1 - 8), a2, a3);
}

//----- (6E6708C8) --------------------------------------------------------
__int32 __stdcall ATL::CComObject<CImplINetCfgComponent>::QueryInterface(int a1, struct _GUID *a2, void **a3)
{
  return ATL::CComObject<CImplINetCfgComponent>::QueryInterface((CImplINetCfgComponent *)(a1 - 12), a2, a3);
}

//----- (6E6708D7) --------------------------------------------------------
LONG __stdcall ATL::CComObject<CImplINetCfgComponent>::Release(int a1)
{
  return ATL::CComObject<CImplINetCfgComponent>::Release((void *)(a1 - 12));
}

//----- (6E6708E6) --------------------------------------------------------
signed int __thiscall CImplINetCfgComponent::HrMoveBindPath(CImplINetCfgComponent *this, CImplINetCfgBindingPath *a2, CImplINetCfgBindingPath *a3, int a4)
{
  CImplINetCfgComponent *v4; // esi@1
  signed int v5; // edi@1
  struct CComponent **v6; // ecx@5
  struct CComponent *v7; // edx@5
  struct CComponent **v8; // eax@7
  char v10; // [sp+Ch] [bp-44h]@4
  char v11; // [sp+10h] [bp-40h]@2
  struct CComponent **v12; // [sp+14h] [bp-3Ch]@7
  struct CComponent **v13; // [sp+18h] [bp-38h]@9
  char v14; // [sp+20h] [bp-30h]@2
  char v15; // [sp+24h] [bp-2Ch]@2
  int v16; // [sp+28h] [bp-28h]@5
  struct CComponent **v17; // [sp+2Ch] [bp-24h]@12
  struct CComponent *v18; // [sp+34h] [bp-1Ch]@2
  struct CComponent *v19; // [sp+38h] [bp-18h]@2
  struct CComponent *v20; // [sp+3Ch] [bp-14h]@2
  struct CComponent *v21; // [sp+40h] [bp-10h]@2
  int v22; // [sp+4Ch] [bp-4h]@2

  v4 = this;
  v5 = CImplINetCfgComponent::HrLockAndTestForValidInterface(this, 2u, 0, 0);
  if ( !v5 )
  {
    std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v15, 0);
    v22 = 0;
    std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v11, 0);
    LOBYTE(v22) = 1;
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v5 = CImplINetCfgBindingPath::HrIsValidInterface(a2, 2u, (struct CBindPath *)&v14);
    if ( !v5 )
    {
      if ( !a3 || (v5 = CImplINetCfgBindingPath::HrIsValidInterface(a3, 2u, (struct CBindPath *)&v10)) == 0 )
      {
        v6 = (struct CComponent **)v16;
        v7 = (struct CComponent *)*((_DWORD *)v4 + 7);
        if ( v7 == *(struct CComponent **)v16 )
        {
          if ( !a3 )
          {
            v20 = *(struct CComponent **)v16;
            v21 = *(struct CComponent **)(v16 + 4);
            v5 = CStackTable::HrMoveStackEntries(
                   *(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 20,
                   (int)&v20,
                   0,
                   a4,
                   (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 72));
            if ( v5 >= 0 )
              CModifyContext::HrDirtyComponentAndComponentsAbove(
                (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 72),
                v20);
            goto LABEL_20;
          }
          v8 = v12;
          if ( v7 == *v12 )
          {
            v5 = -2147024809;
            while ( v6 != v17 && v8 != v13 )
            {
              if ( *v6 != *v8 )
              {
                v21 = *v6;
                v19 = *v8;
                v5 = CStackTable::HrMoveStackEntries(
                       *(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 20,
                       (int)&v20,
                       (int)&v18,
                       a4,
                       (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 72));
                if ( v5 >= 0 )
                {
                  CModifyContext::HrDirtyComponentAndComponentsAbove(
                    (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 72),
                    v20);
                  CModifyContext::HrDirtyComponentAndComponentsAbove(
                    (CModifyContext *)(*(_DWORD *)(*((_DWORD *)v4 + 6) + 48) + 72),
                    v18);
                }
                goto LABEL_20;
              }
              v20 = *v6;
              ++v6;
              v18 = *v8;
              ++v8;
            }
            goto LABEL_20;
          }
        }
        v5 = -2147024809;
      }
    }
LABEL_20:
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)v4 + 6) + 24));
    std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v11);
    std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v15);
  }
  return v5;
}

//----- (6E670A65) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::MoveBefore(CImplINetCfgComponent *this, struct INetCfgBindingPath *a2, struct INetCfgBindingPath *a3)
{
  return CImplINetCfgComponent::HrMoveBindPath(
           (CImplINetCfgComponent *)((char *)this - 4),
           (CImplINetCfgBindingPath *)a2,
           (CImplINetCfgBindingPath *)a3,
           1);
}

//----- (6E670A86) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::MoveAfter(CImplINetCfgComponent *this, struct INetCfgBindingPath *a2, struct INetCfgBindingPath *a3)
{
  return CImplINetCfgComponent::HrMoveBindPath(
           (CImplINetCfgComponent *)((char *)this - 4),
           (CImplINetCfgBindingPath *)a2,
           (CImplINetCfgBindingPath *)a3,
           2);
}

//----- (6E670AA7) --------------------------------------------------------
signed int __stdcall CImplINetCfgComponent::IsBindableTo(CImplINetCfgComponent *this, struct INetCfgComponent *a2)
{
  signed int v2; // esi@1
  const struct CComponent *v3; // ebx@2
  char v5; // [sp+8h] [bp-14h]@3
  int v6; // [sp+Ch] [bp-10h]@3

  v2 = CImplINetCfgComponent::HrLockAndTestForValidInterface(
         (CImplINetCfgComponent *)((char *)this - 4),
         4u,
         a2,
         (struct CComponent **)&a2);
  if ( !v2 )
  {
    v3 = (const struct CComponent *)*((_DWORD *)this + 6);
    v2 = 1;
    if ( (struct INetCfgComponent *)v3 != a2 )
    {
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v6, 0);
      v2 = CNetConfigCore::HrGetComponentBindings(
             *(CNetConfigCore **)(*((_DWORD *)this + 5) + 48),
             v3,
             0,
             (struct CBindingSet *)&v5);
      if ( !v2 )
        v2 = CBindingSet::FContainsComponent((CBindingSet *)&v5, (const struct CComponent *)a2) == 0;
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v6);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 5) + 24));
  }
  return v2;
}

//----- (6E670B2B) --------------------------------------------------------
signed int __stdcall FOboTokenValidForClass(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 || (result = FIsConsideredNetClass(a2)) != 0 )
    result = 1;
  return result;
}

//----- (6E670B4E) --------------------------------------------------------
signed int __stdcall HrProbeOboToken(const struct tagOBO_TOKEN *a1)
{
  signed int result; // eax@1

  result = 0;
  if ( a1 && a1->Type != 1 )
  {
    if ( a1->Type == 2 )
    {
      result = HrIsValidINetCfgComponent(a1->pncc);
    }
    else if ( a1->Type != 3 || !*a1->pszwManufacturer || !*a1->pszwProduct || !*a1->pszwDisplayName )
    {
      result = -2147024809;
    }
  }
  return result;
}

//----- (6E670B97) --------------------------------------------------------
void __thiscall CModifyContext::NotifyAndRemoveComponent(CModifyContext *this, struct CComponent *a2)
{
  CModifyContext *v2; // esi@1
  struct CNetConfig *v3; // ebx@1
  int v4; // eax@1
  __int32 v5; // eax@3
  int v6; // eax@4
  SP_LOG_TOKEN LogToken; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+18h] [bp-4h]@1

  v2 = this;
  LogToken = SetupGetThreadLogToken();
  v3 = CModifyContext::PNetConfig(v2);
  v8 = std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v2 + 88));
  v4 = CNetConfigCore::HrGetBindingsInvolvingComponent(v3, a2, 1u, (CModifyContext *)((char *)v2 + 84));
  *((_DWORD *)v2 + 55) = v4;
  if ( !v4 )
  {
    CNetConfigCore::RemoveComponentFromCore(v3, a2);
    if ( std::vector<CBindPath,std::nc_allocator<CBindPath>>::size((int)((char *)v2 + 88)) <= (unsigned int)v8
      || (v5 = CGlobalNotifyInterface::QueryAndNotifyBindPaths(
                 (struct CNetConfig *)((char *)v3 + 64),
                 2u,
                 (CModifyContext *)((char *)v2 + 84),
                 v8),
          (*((_DWORD *)v2 + 55) = v5) == 0) )
    {
      v6 = CGlobalNotifyInterface::ComponentRemoved((struct CNetConfig *)((char *)v3 + 64), a2);
      *((_DWORD *)v2 + 55) = v6;
      if ( !v6 )
      {
        CComponent::ReleaseINetCfgComponentInterface(a2);
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "[NCI BEGIN RC: Remove any components required by %ws]",
          *((_DWORD *)a2 + 7));
        CModifyContext::InstallOrRemoveRequiredComponents(v2, (HKEY)a2, 1);
        _SetupWriteTextLog(
          LogToken,
          0x40000000u,
          5 - (g_IsInUpgrade != 0),
          "[NCI END RC: Remove any components required by %ws. Result 0x%08X]",
          *((_DWORD *)a2 + 7),
          *((_DWORD *)v2 + 55));
        if ( !*((_DWORD *)v2 + 55) )
          CNetConfigCore::EnsureComponentNotReferencedByOthers(v3, a2);
      }
    }
  }
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E670D2F) --------------------------------------------------------
int __thiscall CModifyContext::HrRemoveComponentIfNotReferenced(CModifyContext *this, struct CComponent *a2, SIZE_T cb, unsigned __int16 **a4)
{
  struct CComponent *v4; // ebx@1
  CModifyContext *v5; // esi@1
  int result; // eax@5
  CComponentReferences *v7; // edi@12
  void **v8; // ebx@14
  signed int v9; // eax@15
  struct CComponent *v10; // [sp+14h] [bp+8h]@6

  v4 = a2;
  v5 = this;
  if ( cb
    && *(_DWORD *)cb != 1
    && !CComponentReferences::FIsReferencedByOboToken(
          (struct CComponent *)((char *)a2 + 120),
          (const struct tagOBO_TOKEN *)cb)
    && CComponentReferences::CountTotalReferencedBy((struct CComponent *)((char *)a2 + 120)) )
  {
    result = -2147024809;
  }
  else
  {
    CModifyContext::PNetConfig(v5);
    v10 = (struct CComponent *)1;
    CModifyContext::PushRecursionDepth(v5);
    if ( !CComponentList::FComponentInList(v5, v4) )
      *((_DWORD *)v5 + 55) = -2147418113;
    if ( cb && !*((_DWORD *)v5 + 55) )
      *((_DWORD *)v5 + 55) = CComponentReferences::HrRemoveReferenceByOboToken(
                               (struct CComponent *)((char *)v4 + 120),
                               (const struct tagOBO_TOKEN *)cb);
    if ( !*((_DWORD *)v5 + 55) )
    {
      v7 = (struct CComponent *)((char *)v4 + 120);
      if ( CComponentReferences::CountTotalReferencedBy((struct CComponent *)((char *)v4 + 120)) )
      {
        v8 = (void **)a4;
        if ( a4 )
        {
          cb = 0;
          CComponentReferences::GetReferenceDescriptionsAsMultiSz(v7, 0, &cb);
          v9 = HrCoTaskMemAlloc(cb, v8);
          *((_DWORD *)v5 + 55) = v9;
          if ( !v9 )
            CComponentReferences::GetReferenceDescriptionsAsMultiSz(v7, (LPBYTE)*v8, &cb);
        }
      }
      else
      {
        v10 = 0;
        CModifyContext::NotifyAndRemoveComponent(v5, v4);
      }
    }
    result = CModifyContext::HrPopRecursionDepth(v5);
    if ( v10 )
    {
      if ( result >= 0 )
        result = 303139;
    }
  }
  return result;
}

//----- (6E670E59) --------------------------------------------------------
void __thiscall CStackTable::SetWanAdapterOrder(CStackTable *this, int a2)
{
  *((_DWORD *)this + 5) = a2;
}

//----- (6E670E6D) --------------------------------------------------------
int __cdecl std::_Copy_opt<CStackEntry *,CStackEntry *>(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@1

  v3 = a1;
  result = a3;
  while ( v3 != a2 )
  {
    *(_DWORD *)result = *(_DWORD *)v3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(v3 + 4);
    result += 8;
    v3 += 8;
  }
  return result;
}

//----- (6E670E96) --------------------------------------------------------
int __cdecl std::_Copy_backward_opt<CLanaEntry *,CLanaEntry *>(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@1

  v3 = a2;
  for ( result = a3; v3 != a1; *(_DWORD *)(result + 4) = *(_DWORD *)(v3 + 4) )
  {
    v3 -= 8;
    result -= 8;
    *(_DWORD *)result = *(_DWORD *)v3;
  }
  return result;
}

//----- (6E670EC2) --------------------------------------------------------
int __stdcall std::find<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry>(int a1, int a2, int a3, int a4)
{
  int i; // esi@1
  int result; // eax@5

  for ( i = a2; i != a3 && !CStackEntry::operator==(a4); i += 8 )
    ;
  result = a1;
  *(_DWORD *)a1 = i;
  return result;
}
// 6E670E33: using guessed type _DWORD __stdcall CStackEntry::operator==(_DWORD);

//----- (6E670EF5) --------------------------------------------------------
int __cdecl std::copy<CStackEntry *,CStackEntry *>(int a1, int a2, int a3)
{
  return std::_Copy_opt<CStackEntry *,CStackEntry *>(a1, a2, a3);
}

//----- (6E670F21) --------------------------------------------------------
int __cdecl std::copy_backward<CLanaEntry *,CLanaEntry *>(int a1, int a2, int a3)
{
  return std::_Copy_backward_opt<CLanaEntry *,CLanaEntry *>(a1, a2, a3);
}

//----- (6E670F4D) --------------------------------------------------------
int __thiscall CStackTable::FStackEntryInTable(CStackTable *this, const struct CComponent *a2, const struct CComponent *a3)
{
  int v3; // eax@1
  int v4; // ecx@1

  v3 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  while ( 1 )
  {
    if ( v3 == v4 )
      return 0;
    if ( a2 == *(const struct CComponent **)v3 && a3 == *(const struct CComponent **)(v3 + 4) )
      break;
    v3 += 8;
  }
  return 1;
}

//----- (6E670F80) --------------------------------------------------------
void __stdcall GetComponentsAboveComponent(const struct CComponent *a1, struct GCCONTEXT *a2)
{
  int v2; // eax@1
  int i; // esi@1

  v2 = *(_DWORD *)a2;
  for ( i = *(_DWORD *)(*(_DWORD *)a2 + 8); i != *(_DWORD *)(v2 + 12); i += 8 )
  {
    if ( a1 == *(const struct CComponent **)(i + 4) )
    {
      *((_DWORD *)a2 + 2) = CComponentList::HrInsertComponent(
                              *((CComponentList **)a2 + 1),
                              *(const struct CComponent **)i,
                              0x1200u);
      GetComponentsAboveComponent(*(const struct CComponent **)i, a2);
      if ( *((_DWORD *)a2 + 2) )
        break;
    }
    v2 = *(_DWORD *)a2;
  }
}

//----- (6E670FCE) --------------------------------------------------------
int __thiscall std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  char v5; // [sp+4h] [bp-4h]@1

  v3 = this;
  std::copy<CStackEntry *,std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>>(
    (int)&v5,
    a3 + 8,
    *(_DWORD *)(this + 8),
    a3);
  result = a2;
  *(_DWORD *)(v3 + 8) -= 8;
  *(_DWORD *)a2 = a3;
  return result;
}

//----- (6E671004) --------------------------------------------------------
void __thiscall CStackTable::RemoveStackEntry(CStackTable *this, const struct CComponent *a2, const struct CComponent *a3)
{
  int v3; // eax@1
  int v4; // edx@1

  v3 = *((_DWORD *)this + 2);
  v4 = *((_DWORD *)this + 3);
  if ( v3 != v4 )
  {
    while ( a2 != *(const struct CComponent **)v3 || a3 != *(const struct CComponent **)(v3 + 4) )
    {
      v3 += 8;
      if ( v3 == v4 )
        return;
    }
    std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase((int)((char *)this + 4), (int)&a2, v3);
  }
}

//----- (6E671043) --------------------------------------------------------
void __thiscall CStackTable::RemoveEntriesWithComponent(CStackTable *this, const struct CComponent *a2)
{
  CStackTable *v2; // edi@1
  int v3; // esi@1
  const struct CComponent *v4; // ebx@2

  v2 = this;
  v3 = *((_DWORD *)this + 2);
  if ( v3 != *((_DWORD *)this + 3) )
  {
    v4 = a2;
    do
    {
      if ( v4 == *(const struct CComponent **)v3 || v4 == *(const struct CComponent **)(v3 + 4) )
        std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase((int)((char *)v2 + 4), (int)&a2, v3);
      else
        v3 += 8;
    }
    while ( v3 != *((_DWORD *)v2 + 3) );
  }
}

//----- (6E671084) --------------------------------------------------------
__int32 __thiscall CStackTable::HrMoveStackEntries(int this, int a2, int a3, int a4, CModifyContext *a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // ST08_4@1
  int v8; // ST04_4@1
  int v9; // ebx@1
  int v11; // esi@6
  int v12; // edi@9
  int v13; // ebx@11
  int v14; // eax@17
  char v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v5 = *(_DWORD *)(this + 8);
  v6 = *(_DWORD *)(this + 12);
  v7 = *(_DWORD *)(this + 12);
  v8 = *(_DWORD *)(this + 8);
  v16 = this;
  v9 = *(_DWORD *)std::find<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry>(
                    (int)&v15,
                    v8,
                    v7,
                    a2);
  if ( v9 == v6 )
    return -2147024809;
  if ( a3 )
  {
    if ( *(_DWORD *)a2 != *(_DWORD *)a3 )
      return -2147024809;
    if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(a3 + 4) )
      return -2147024809;
    v11 = *(_DWORD *)std::find<std::_Vector_iterator<CStackEntry,std::nc_allocator<CStackEntry>>,CStackEntry>(
                       (int)&a3,
                       v5,
                       v6,
                       a3);
    if ( v11 == v6 )
      return -2147024809;
    if ( a4 == 2 )
      goto LABEL_8;
  }
  else
  {
    v11 = v9;
    if ( a4 == 2 )
    {
      do
        v11 += 8;
      while ( v11 != v6 && *(_DWORD *)v11 == *(_DWORD *)v9 );
      goto LABEL_9;
    }
    v14 = *(_DWORD *)(v16 + 8);
    v11 = v9 - 8;
    if ( v9 - 8 != v14 )
    {
      while ( *(_DWORD *)v11 == *(_DWORD *)v9 )
      {
        v11 -= 8;
        if ( v11 == v14 )
          goto LABEL_9;
      }
LABEL_8:
      v11 += 8;
      goto LABEL_9;
    }
  }
LABEL_9:
  v12 = v16 + 4;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase(v16 + 4, (int)&a4, v9);
  if ( v9 < (unsigned int)v11 )
    v11 -= 8;
  v13 = a2;
  std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::insert(v12, (int)&a2, v11, a2);
  return CModifyContext::HrDirtyComponentAndComponentsAbove(a5, *(const struct CComponent **)v13);
}

//----- (6E671157) --------------------------------------------------------
int __thiscall std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::push_back(int this, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int result; // eax@2

  v2 = this;
  v3 = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::size(this);
  if ( v3 >= (unsigned int)std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::capacity(v2) )
  {
    result = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::insert(v2, (int)&a2, *(_DWORD *)(v2 + 8), a2);
  }
  else
  {
    result = std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::_Ufill(v2, *(_DWORD *)(v2 + 8), 1, a2);
    *(_DWORD *)(v2 + 8) = result;
  }
  return result;
}

//----- (6E67119C) --------------------------------------------------------
__int32 __thiscall CStackTable::HrInsertStackEntriesForComponent(CStackTable *this, const struct CComponent *a2, const struct CComponentList *a3, unsigned __int32 a4)
{
  const struct CComponentList *v4; // eax@1
  const struct CComponent **v5; // edi@1
  const struct CComponent *v6; // esi@2
  const struct CComponent *v8; // [sp+4h] [bp-10h]@1
  const struct CComponent *v9; // [sp+8h] [bp-Ch]@1
  __int32 v10; // [sp+Ch] [bp-8h]@1
  CStackTable *v11; // [sp+10h] [bp-4h]@1

  v4 = a3;
  v5 = (const struct CComponent **)*((_DWORD *)a3 + 2);
  v11 = this;
  v9 = 0;
  v8 = 0;
  v10 = 0;
  if ( v5 != *((const struct CComponent ***)a3 + 3) )
  {
    while ( 1 )
    {
      v6 = *v5;
      if ( *v5 != a2 )
        break;
LABEL_9:
      ++v5;
      if ( v5 == *((const struct CComponent ***)v4 + 3) )
        return v10;
    }
    if ( CComponent::FCanDirectlyBindTo(v6, a2, 1, 0, 0) )
    {
      v8 = v6;
      v9 = a2;
    }
    else
    {
      if ( !CComponent::FCanDirectlyBindTo(a2, v6, 1, 0, 0) )
      {
LABEL_8:
        v4 = a3;
        goto LABEL_9;
      }
      v8 = a2;
      v9 = v6;
    }
    v10 = CStackTable::HrInsertStackEntry(v11, (const struct CStackEntry *)&v8, a4);
    if ( v10 )
    {
      CStackTable::RemoveEntriesWithComponent(v11, a2);
      return v10;
    }
    goto LABEL_8;
  }
  return v10;
}

//----- (6E671236) --------------------------------------------------------
__int32 __thiscall CStackTable::HrUpdateEntriesForComponent(CStackTable *this, const struct CComponent *a2, const struct CComponentList *a3, unsigned __int32 a4)
{
  CStackTable *v4; // edi@1
  const struct CComponentList *v5; // ebx@1
  CComponent **v6; // esi@1
  CComponent *v7; // edi@2
  int v8; // esi@10
  const struct CComponent *v9; // ebx@11
  struct CStackEntry *i; // esi@18
  char v12; // [sp+Ch] [bp-34h]@13
  char v13; // [sp+10h] [bp-30h]@1
  struct CStackEntry *v14; // [sp+14h] [bp-2Ch]@18
  struct CStackEntry *v15; // [sp+18h] [bp-28h]@21
  const struct CComponent *v16; // [sp+24h] [bp-1Ch]@1
  const struct CComponent *v17; // [sp+28h] [bp-18h]@1
  CStackTable *v18; // [sp+2Ch] [bp-14h]@1
  __int32 v19; // [sp+30h] [bp-10h]@1
  int v20; // [sp+3Ch] [bp-4h]@1

  v4 = this;
  v18 = this;
  v17 = 0;
  v16 = 0;
  std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::_Buy((int)&v13, 0);
  v5 = a3;
  v20 = 0;
  v19 = 0;
  v6 = (CComponent **)*((_DWORD *)a3 + 2);
  if ( v6 != *((CComponent ***)a3 + 3) )
  {
    while ( 1 )
    {
      v7 = *v6;
      if ( *v6 != a2 )
      {
        if ( CComponent::FCanDirectlyBindTo(v7, a2, 1, 0, 0) )
        {
          v16 = v7;
          v17 = a2;
LABEL_7:
          std::vector<CLanaEntry,std::nc_allocator<CLanaEntry>>::push_back((int)&v13, (int)&v16);
          goto LABEL_8;
        }
        if ( CComponent::FCanDirectlyBindTo(a2, v7, 1, 0, 0) )
        {
          v16 = a2;
          v17 = v7;
          goto LABEL_7;
        }
      }
LABEL_8:
      ++v6;
      if ( v6 == *((CComponent ***)v5 + 3) )
      {
        v4 = v18;
        break;
      }
    }
  }
  v8 = *((_DWORD *)v4 + 2);
  while ( v8 != *((_DWORD *)v4 + 3) )
  {
    v9 = *(const struct CComponent **)v8;
    if ( a2 != *(const struct CComponent **)v8 && a2 != *(const struct CComponent **)(v8 + 4) )
    {
LABEL_16:
      v8 += 8;
    }
    else
    {
      if ( CStackTable::FStackEntryInTable((CStackTable *)&v12, v9, *(const struct CComponent **)(v8 + 4)) )
      {
        CStackTable::RemoveStackEntry((CStackTable *)&v12, v9, *(const struct CComponent **)(v8 + 4));
        goto LABEL_16;
      }
      std::vector<CStackEntry,std::nc_allocator<CStackEntry>>::erase((int)((char *)v4 + 4), (int)&a3, v8);
    }
  }
  for ( i = v14; i != v15; i = (struct CStackEntry *)((char *)i + 8) )
  {
    v19 = CStackTable::HrInsertStackEntry(v4, i, a4);
    if ( v19 )
    {
      CStackTable::RemoveEntriesWithComponent(v4, a2);
      break;
    }
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v13);
  return v19;
}

//----- (6E67134B) --------------------------------------------------------
__int32 __stdcall HrRemoveNameSpaceProvider(LPGUID lpProviderId)
{
  __int32 result; // eax@3

  if ( WSCUnInstallNameSpace(lpProviderId) && GetLastError() != 10022 )
    result = HrFromLastWin32Error();
  else
    result = 0;
  return result;
}

//----- (6E67137B) --------------------------------------------------------
__int32 __stdcall HrAddNameSpaceProvider(LPWSTR lpszIdentifier, LPWSTR lpszPathName, DWORD dwNameSpace, DWORD dwVersion, LPGUID lpProviderId)
{
  __int32 result; // eax@3

  if ( WSCInstallNameSpace(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId)
    && (HrRemoveNameSpaceProvider(lpProviderId),
        WSCInstallNameSpace(lpszIdentifier, lpszPathName, dwNameSpace, dwVersion, lpProviderId)) )
    result = HrFromLastWin32Error();
  else
    result = 0;
  return result;
}

//----- (6E6713CA) --------------------------------------------------------
__int32 __stdcall HrWriteWinsockMapping(LPCWSTR lpSrc, HKEY a2)
{
  __int32 v2; // edi@2
  DWORD v3; // eax@3
  DWORD v4; // eax@6
  char *v6; // [sp+Ch] [bp-224h]@5
  HKEY hKey; // [sp+10h] [bp-220h]@1
  int (__stdcall *v8)(); // [sp+14h] [bp-21Ch]@1
  void *lpMem; // [sp+18h] [bp-218h]@1
  HMODULE hLibModule; // [sp+1Ch] [bp-214h]@1
  WCHAR Dst; // [sp+20h] [bp-210h]@3

  hLibModule = 0;
  v8 = 0;
  hKey = a2;
  lpMem = MemAlloc(0x2000u);
  if ( !lpMem )
    goto LABEL_2;
  v3 = ExpandEnvironmentStringsW(lpSrc, &Dst, 0x105u);
  if ( v3 && (signed int)v3 <= 261 )
  {
    v6 = "WSHGetWinsockMapping";
    v2 = HrLoadLibAndGetProcs(&Dst, 1u, (const char *const *)&v6, &hLibModule, &v8);
    if ( v2 >= 0 )
    {
      v4 = ((int (__stdcall *)(void *, signed int))v8)(lpMem, 0x2000);
      if ( v4 > 0x2000 )
      {
LABEL_2:
        v2 = -2147024882;
        goto LABEL_9;
      }
      v2 = HrRegSetBinary(hKey, L"Mapping", (BYTE *)lpMem, v4);
    }
  }
  else
  {
    v2 = -2147024894;
  }
LABEL_9:
  MemFree(lpMem);
  if ( hLibModule )
    FreeLibrary(hLibModule);
  return v2;
}

//----- (6E6714FA) --------------------------------------------------------
__int32 __stdcall HrInstallWinsock()
{
  void *v0; // eax@1
  __int32 v1; // ebx@3
  void *v2; // eax@4
  signed int v3; // esi@7
  LPCWSTR lpValueName; // [sp+Ch] [bp-58h]@7
  BYTE Data[4]; // [sp+10h] [bp-54h]@7
  int v7; // [sp+14h] [bp-50h]@7
  int v8; // [sp+18h] [bp-4Ch]@7
  int v9; // [sp+1Ch] [bp-48h]@7
  int v10; // [sp+20h] [bp-44h]@7
  DWORD dwDisposition; // [sp+24h] [bp-40h]@3
  HKEY v12; // [sp+28h] [bp-3Ch]@1
  HKEY phkResult; // [sp+30h] [bp-34h]@1
  char v14; // [sp+34h] [bp-30h]@1
  LPCWSTR lpSubKey; // [sp+38h] [bp-2Ch]@1
  unsigned int v16; // [sp+4Ch] [bp-18h]@1
  int v17; // [sp+60h] [bp-4h]@1

  v12 = 0;
  phkResult = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v14);
  v17 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v14,
    L"System\\CurrentControlSet\\Services");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v14,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v14,
    L"Winsock");
  v0 = (void *)lpSubKey;
  if ( v16 < 8 )
    v0 = &lpSubKey;
  v1 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v0, 0, 0x2001Fu, 0, &phkResult, &dwDisposition);
  if ( !v1 )
  {
    LOBYTE(v17) = 1;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v14,
      (void *)&L"\\");
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v14,
      (void *)&L"Parameters");
    v2 = (void *)lpSubKey;
    v17 = 0;
    if ( v16 < 8 )
      v2 = &lpSubKey;
    v1 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v2, 0, 0x2001Fu, 0, &v12, &dwDisposition);
    if ( !v1 )
    {
      lpValueName = L"ErrorControl";
      *(_DWORD *)Data = 1;
      v7 = (int)L"Start";
      v8 = 3;
      v9 = (int)L"Type";
      v10 = 4;
      v3 = 0;
      do
      {
        v1 = HrRegSetDword(phkResult, (&lpValueName)[4 * v3], *(_DWORD *)&Data[8 * v3]);
        if ( v1 )
          break;
        ++v3;
      }
      while ( v3 < 3 );
    }
  }
  RegSafeCloseKey(v12);
  RegSafeCloseKey(phkResult);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v14,
    1,
    0);
  return v1;
}
// 6E6714FA: too many cbuild loops
// 6E65C6E0: using guessed type wchar_t aSystemCurre_18[34];
// 6E65D40C: using guessed type const unsigned __int16 *const c_szBackslash;
// 6E65D4AC: using guessed type const unsigned __int16 *const c_szParameters;
// 6E67164C: using guessed type wchar_t aErrorcontrol[13];
// 6E671668: using guessed type wchar_t aStart_0[6];
// 6E671674: using guessed type wchar_t aType[5];

//----- (6E671685) --------------------------------------------------------
__int32 __stdcall HrIsWinsockInstalled(int *a1)
{
  void *v1; // eax@1
  void *v2; // eax@4
  HKEY hKey; // [sp+10h] [bp-34h]@3
  __int32 v5; // [sp+14h] [bp-30h]@3
  char v6; // [sp+18h] [bp-2Ch]@1
  LPCWSTR lpSubKey; // [sp+1Ch] [bp-28h]@1
  unsigned int v8; // [sp+30h] [bp-14h]@1
  int v9; // [sp+40h] [bp-4h]@1

  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v6);
  v9 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v6,
    L"System\\CurrentControlSet\\Services");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    L"Winsock");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    (void *)&L"Parameters");
  v1 = (void *)lpSubKey;
  if ( v8 < 8 )
    v1 = &lpSubKey;
  v5 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v1, 0x20019u, &hKey);
  if ( v5 )
    goto LABEL_14;
  RegCloseKey(hKey);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v6,
    L"System\\CurrentControlSet\\Services");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v6,
    L"AFD");
  v2 = (void *)lpSubKey;
  if ( v8 < 8 )
    v2 = &lpSubKey;
  v5 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v2, 0x20019u, &hKey);
  if ( v5 )
  {
LABEL_14:
    if ( v5 == -2147024894 )
      v5 = 0;
    *a1 = 0;
  }
  else
  {
    RegCloseKey(hKey);
    *a1 = 1;
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v6,
    1,
    0);
  return v5;
}
// 6E65C6E0: using guessed type wchar_t aSystemCurre_18[34];
// 6E65D40C: using guessed type const unsigned __int16 *const c_szBackslash;
// 6E65D4AC: using guessed type const unsigned __int16 *const c_szParameters;
// 6E671798: using guessed type wchar_t aAfd[4];

//----- (6E6717A5) --------------------------------------------------------
__int32 __stdcall HrUpdateWinsockTransportList(wchar_t *Str2, int a2)
{
  void *v2; // eax@1
  __int32 v3; // eax@3
  __int32 v4; // esi@3
  signed int v5; // eax@7
  HKEY phkResult; // [sp+Ch] [bp-30h]@1
  char v8; // [sp+10h] [bp-2Ch]@1
  LPCWSTR lpSubKey; // [sp+14h] [bp-28h]@1
  unsigned int v10; // [sp+28h] [bp-14h]@1
  int v11; // [sp+38h] [bp-4h]@1

  phkResult = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v8);
  v11 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v8,
    L"System\\CurrentControlSet\\Services");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v8,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v8,
    L"Winsock");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v8,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v8,
    (void *)&L"Parameters");
  v2 = (void *)lpSubKey;
  if ( v10 < 8 )
    v2 = &lpSubKey;
  v3 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v2, 0x2001Fu, &phkResult);
  v4 = v3;
  if ( v3 )
  {
    if ( v3 == -2147024894 )
      v4 = 0;
  }
  else
  {
    if ( a2 )
      v5 = HrRegAddStringToMultiSz(Str2, phkResult, 0, L"Transports", 4u, 0);
    else
      v5 = HrRegRemoveStringFromMultiSz(Str2, phkResult, 0, L"Transports", 64);
    v4 = v5;
  }
  RegSafeCloseKey(phkResult);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v8,
    1,
    0);
  return v4;
}
// 6E65C6E0: using guessed type wchar_t aSystemCurre_18[34];
// 6E65D40C: using guessed type const unsigned __int16 *const c_szBackslash;
// 6E65D4AC: using guessed type const unsigned __int16 *const c_szParameters;

//----- (6E67189D) --------------------------------------------------------
__int32 __stdcall HrWriteWinsockInfo(int a1, _DWORD a2, _DWORD a3, int a4)
{
  void *v4; // eax@1
  __int32 v5; // esi@3
  const WCHAR *v6; // ebx@4
  BYTE *v7; // ecx@5
  wchar_t *v8; // eax@15
  DWORD dwDisposition; // [sp+Ch] [bp-4Ch]@3
  LPCWSTR lpValueName; // [sp+10h] [bp-48h]@8
  BYTE Data[4]; // [sp+14h] [bp-44h]@8
  int v13; // [sp+18h] [bp-40h]@8
  int v14; // [sp+1Ch] [bp-3Ch]@8
  int v15; // [sp+20h] [bp-38h]@1
  unsigned int v16; // [sp+24h] [bp-34h]@8
  HKEY phkResult; // [sp+28h] [bp-30h]@3
  char v18; // [sp+2Ch] [bp-2Ch]@1
  LPCWSTR lpSubKey; // [sp+30h] [bp-28h]@1
  unsigned int v20; // [sp+44h] [bp-14h]@1
  int v21; // [sp+54h] [bp-4h]@1

  v15 = a1;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v18);
  v21 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v18,
    L"System\\CurrentControlSet\\Services");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    a1,
    0,
    -1);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    (void *)&L"Parameters");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    (void *)&L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    L"Winsock");
  v4 = (void *)lpSubKey;
  if ( v20 < 8 )
    v4 = &lpSubKey;
  v5 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v4, 0, 0x2001Fu, 0, &phkResult, &dwDisposition);
  if ( !v5 )
  {
    v6 = (const WCHAR *)(a2 + 4);
    v7 = (BYTE *)(*(_DWORD *)(a2 + 24) < 8u ? a2 + 4 : *(_DWORD *)v6);
    v5 = HrRegSetValueEx(phkResult, L"HelperDllName", 2u, v7, 2 * *(_DWORD *)(a2 + 20) + 2);
    if ( !v5 )
    {
      v16 = 0;
      *(_DWORD *)Data = a3;
      lpValueName = L"MaxSockAddrLength";
      v13 = (int)L"MinSockAddrLength";
      v14 = a4;
      while ( 1 )
      {
        v5 = HrRegSetDword(phkResult, (&lpValueName)[4 * v16], *(_DWORD *)&Data[8 * v16]);
        if ( v5 )
          break;
        ++v16;
        if ( v16 >= 2 )
        {
          if ( *(_DWORD *)(a2 + 24) >= 8u )
            v6 = *(const WCHAR **)v6;
          v5 = HrWriteWinsockMapping(v6, phkResult);
          if ( !v5 )
          {
            if ( *(_DWORD *)(v15 + 24) < 8u )
              v8 = (wchar_t *)(v15 + 4);
            else
              v8 = *(wchar_t **)(v15 + 4);
            v5 = HrUpdateWinsockTransportList(v8, 1);
          }
          break;
        }
      }
    }
  }
  RegSafeCloseKey(phkResult);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v18,
    1,
    0);
  return v5;
}
// 6E67189D: too many cbuild loops
// 6E65C6E0: using guessed type wchar_t aSystemCurre_18[34];
// 6E65D40C: using guessed type const unsigned __int16 *const c_szBackslash;
// 6E65D4AC: using guessed type const unsigned __int16 *const c_szParameters;

//----- (6E671A08) --------------------------------------------------------
__int32 __stdcall HrInstallWinsockDependancy(HINF InfHandle, PCWSTR Section)
{
  __int32 v2; // eax@1
  __int32 v3; // esi@1
  __int32 v4; // eax@8
  void *v5; // ecx@17
  void *v6; // eax@23
  WCHAR *v7; // ecx@26
  WCHAR *v8; // eax@28
  int v10; // [sp+Ch] [bp-C8h]@17
  unsigned __int32 v11; // [sp+10h] [bp-C4h]@1
  unsigned __int32 IntegerValue; // [sp+14h] [bp-C0h]@1
  DWORD dwVersion; // [sp+18h] [bp-BCh]@1
  DWORD dwNameSpace; // [sp+1Ch] [bp-B8h]@1
  int v15; // [sp+20h] [bp-B4h]@1
  int v16; // [sp+24h] [bp-B0h]@1
  IID iid; // [sp+28h] [bp-ACh]@25
  int v18; // [sp+38h] [bp-9Ch]@1
  int v19; // [sp+54h] [bp-80h]@1
  int v20; // [sp+70h] [bp-64h]@1
  LPCOLESTR lpsz; // [sp+74h] [bp-60h]@23
  unsigned int v22; // [sp+88h] [bp-4Ch]@23
  int v23; // [sp+8Ch] [bp-48h]@1
  LPWSTR lpszIdentifier; // [sp+90h] [bp-44h]@28
  unsigned int v25; // [sp+A4h] [bp-30h]@28
  int v26; // [sp+A8h] [bp-2Ch]@1
  LPWSTR lpszPathName; // [sp+ACh] [bp-28h]@26
  unsigned int v28; // [sp+C0h] [bp-14h]@26
  int v29; // [sp+D0h] [bp-4h]@1

  IntegerValue = 0;
  v11 = 0;
  dwNameSpace = 0;
  dwVersion = 1;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v18);
  v29 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v19);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v26);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v23);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v20);
  LOBYTE(v29) = 4;
  v16 = 0;
  v15 = 0;
  v2 = HrSetupGetFirstString(InfHandle, Section, L"TransportService", (int)&v19);
  v3 = v2;
  if ( v2 )
  {
    if ( v2 != -2146500351 && v2 != -2146500350 )
      goto LABEL_34;
  }
  else
  {
    v3 = HrSetupGetFirstString(InfHandle, Section, L"HelperDllName", (int)&v18);
    if ( v3 < 0 )
      goto LABEL_34;
    v3 = HrSetupGetFirstDword(InfHandle, Section, L"MaxSockAddrLength", &IntegerValue);
    if ( v3 < 0 )
      goto LABEL_34;
    v3 = HrSetupGetFirstDword(InfHandle, Section, L"MinSockAddrLength", &v11);
    if ( v3 < 0 )
      goto LABEL_34;
    v16 = 1;
  }
  v4 = HrSetupGetFirstString(InfHandle, Section, L"ProviderId", (int)&v20);
  v3 = v4;
  if ( v4 )
  {
    if ( v4 != -2146500351 && v4 != -2146500350 )
      goto LABEL_34;
  }
  else
  {
    v3 = HrSetupGetFirstString(InfHandle, Section, L"LibraryPath", (int)&v26);
    if ( v3 < 0 )
      goto LABEL_34;
    v3 = HrSetupGetFirstString(InfHandle, Section, L"DisplayString", (int)&v23);
    if ( v3 < 0 )
      goto LABEL_34;
    v3 = HrSetupGetFirstDword(InfHandle, Section, L"SupportedNameSpace", &dwNameSpace);
    if ( v3 < 0 )
      goto LABEL_34;
    HrSetupGetFirstDword(InfHandle, Section, L"Version", &dwVersion);
    v15 = 1;
  }
  if ( v16 || v15 )
  {
    v3 = HrIsWinsockInstalled(&v10);
    if ( v3 >= 0 )
    {
      if ( v10 || (v3 = HrInstallWinsock(), v3 >= 0) )
      {
        if ( !v16 || (v3 = HrWriteWinsockInfo((int)&v19, &v18, IntegerValue, v11), v3 >= 0) )
        {
          if ( !v15 )
            goto LABEL_37;
          v6 = (void *)lpsz;
          if ( v22 < 8 )
            v6 = &lpsz;
          v3 = IIDFromString((LPCOLESTR)v6, &iid);
          if ( v3 >= 0 )
          {
            v7 = lpszPathName;
            if ( v28 < 8 )
              v7 = (WCHAR *)&lpszPathName;
            v8 = lpszIdentifier;
            if ( v25 < 8 )
              v8 = (WCHAR *)&lpszIdentifier;
            v3 = HrAddNameSpaceProvider(v8, v7, dwNameSpace, dwVersion, &iid);
            if ( v3 >= 0 )
            {
LABEL_37:
              if ( v16 || v15 )
                HrMigrateWinsockConfiguration(v5);
            }
          }
        }
      }
    }
  }
LABEL_34:
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v20,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v23,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v26,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v19,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v18,
    1,
    0);
  return v3;
}

//----- (6E671D41) --------------------------------------------------------
__int32 __stdcall HrRemoveWinsockDependancy(void *InfHandle, const unsigned __int16 *Section)
{
  __int32 v2; // eax@1
  HRESULT v3; // esi@1
  wchar_t *v4; // eax@2
  void *v5; // eax@5
  void *v6; // eax@7
  __int32 v7; // eax@13
  void *v8; // ecx@13
  void *v9; // eax@14
  HKEY hKey; // [sp+Ch] [bp-60h]@9
  int v12; // [sp+10h] [bp-5Ch]@1
  IID iid; // [sp+14h] [bp-58h]@16
  int v14; // [sp+24h] [bp-48h]@1
  void *Src; // [sp+28h] [bp-44h]@2
  unsigned int v16; // [sp+3Ch] [bp-30h]@2
  int v17; // [sp+40h] [bp-2Ch]@1
  LPCOLESTR lpsz; // [sp+44h] [bp-28h]@7
  unsigned int v19; // [sp+58h] [bp-14h]@7
  int v20; // [sp+68h] [bp-4h]@1

  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v17);
  v20 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v14);
  v12 = 0;
  LOBYTE(v20) = 1;
  v2 = HrSetupGetFirstString(InfHandle, Section, L"TransportService", (int)&v14);
  v3 = v2;
  if ( v2 )
  {
    if ( v2 != -2146500351 && v2 != -2146500350 )
      goto LABEL_23;
  }
  else
  {
    v4 = (wchar_t *)Src;
    if ( v16 < 8 )
      v4 = (wchar_t *)&Src;
    v3 = HrUpdateWinsockTransportList(v4, 0);
    if ( v3 < 0 )
      goto LABEL_23;
    v12 = 1;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
      (int)&v17,
      L"System\\CurrentControlSet\\Services");
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v17,
      (void *)&L"\\");
    v5 = Src;
    if ( v16 < 8 )
      v5 = &Src;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v17,
      v5);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v17,
      (void *)&L"\\");
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v17,
      (void *)&L"Parameters");
    v6 = (void *)lpsz;
    if ( v19 < 8 )
      v6 = &lpsz;
    if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v6, 0x3001Fu, &hKey) )
    {
      HrRegDeleteKeyTree(hKey, L"Winsock");
      RegCloseKey(hKey);
    }
  }
  v7 = HrSetupGetFirstString(InfHandle, Section, L"ProviderId", (int)&v17);
  v3 = v7;
  if ( v7 )
  {
    if ( v7 == -2146500351 || v7 == -2146500350 )
    {
      if ( !v12 )
      {
LABEL_22:
        v3 = 0;
        goto LABEL_23;
      }
LABEL_21:
      HrMigrateWinsockConfiguration(v8);
      goto LABEL_22;
    }
  }
  else
  {
    v9 = (void *)lpsz;
    if ( v19 < 8 )
      v9 = &lpsz;
    v3 = IIDFromString((LPCOLESTR)v9, &iid);
    if ( v3 >= 0 )
    {
      HrRemoveNameSpaceProvider(&iid);
      goto LABEL_21;
    }
  }
LABEL_23:
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v14,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v17,
    1,
    0);
  return v3;
}
// 6E65C6E0: using guessed type wchar_t aSystemCurre_18[34];
// 6E65D40C: using guessed type const unsigned __int16 *const c_szBackslash;
// 6E65D4AC: using guessed type const unsigned __int16 *const c_szParameters;

//----- (6E671EC2) --------------------------------------------------------
__int32 __stdcall HrAddOrRemoveWinsockDependancy(void *InfHandle, const unsigned __int16 *a2)
{
  __int32 result; // eax@1

  result = HrProcessInfExtension(
             InfHandle,
             a2,
             L"Winsock",
             L"AddSock",
             L"DelSock",
             HrInstallWinsockDependancy,
             HrRemoveWinsockDependancy);
  if ( result == -2146500350 )
    result = 0;
  return result;
}

//----- (6E671F1D) --------------------------------------------------------
void __stdcall EnumLockedDownComponents(void (__stdcall *a1)(const unsigned __int16 *, void *), void *a2)
{
  DWORD v2; // ebx@2
  DWORD i; // [sp-20h] [bp-244h]@2
  WCHAR *v4; // [sp-1Ch] [bp-240h]@2
  DWORD *v5; // [sp-18h] [bp-23Ch]@2
  struct _FILETIME *v6; // [sp-Ch] [bp-230h]@2
  struct _FILETIME ftLastWriteTime; // [sp+0h] [bp-224h]@2
  void (__stdcall *v8)(const unsigned __int16 *, void *); // [sp+8h] [bp-21Ch]@1
  void *v9; // [sp+Ch] [bp-218h]@1
  DWORD cchName; // [sp+10h] [bp-214h]@2
  HKEY hKey; // [sp+14h] [bp-210h]@1
  WCHAR Name; // [sp+18h] [bp-20Ch]@2

  v8 = a1;
  v9 = a2;
  if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Network\\Lockdown", 0x20019u, &hKey) )
  {
    v6 = &ftLastWriteTime;
    v5 = &cchName;
    v4 = &Name;
    v2 = 0;
    for ( i = 0; ; i = v2 )
    {
      cchName = 260;
      if ( HrRegEnumKeyEx(hKey, i, v4, v5, 0, 0, v6) )
        break;
      v8(&Name, v9);
      v6 = &ftLastWriteTime;
      v5 = &cchName;
      ++v2;
      v4 = &Name;
    }
    RegCloseKey(hKey);
  }
}

//----- (6E671FE9) --------------------------------------------------------
int __stdcall FGetOrSetComponentLockDown(int a1, STRSAFE_LPCWSTR pszSrc)
{
  signed int v3; // [sp+Ch] [bp-214h]@1
  HKEY phkResult; // [sp+10h] [bp-210h]@1
  wchar_t pszDest; // [sp+14h] [bp-20Ch]@1

  v3 = 0;
  phkResult = 0;
  StringCchCopyW(&pszDest, 0x104u, L"SYSTEM\\CurrentControlSet\\Control\\Network\\Lockdown");
  StringCchCatW(&pszDest, 0x104u, L"\\");
  StringCchCatW(&pszDest, 0x104u, pszSrc);
  if ( a1 )
  {
    CDiagContext::Printf(
      (DWORD)g_pDiagCtx,
      3,
      "      %S is being locked down to prevent re-install until the next reboot\n",
      pszSrc);
    HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 1u, 0x20006u, 0, &phkResult, 0);
  }
  else if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0x20019u, &phkResult) )
  {
    v3 = 1;
  }
  RegSafeCloseKey(phkResult);
  return v3;
}

//----- (6E672140) --------------------------------------------------------
void __stdcall LockdownComponentUntilNextReboot(STRSAFE_LPCWSTR pszSrc)
{
  FGetOrSetComponentLockDown(1, pszSrc);
}

//----- (6E672158) --------------------------------------------------------
signed int __stdcall CFilterDevice::HrCreateInstance(struct CComponent *a1, struct CComponent *a2, const struct _SP_DEVINFO_DATA *a3, const unsigned __int16 *a4, struct CFilterDevice **a5)
{
  signed int v5; // esi@1
  void *v6; // eax@1
  struct CFilterDevice *v7; // ebx@1

  v5 = -2147024882;
  v6 = operator new(0x74u);
  v7 = (struct CFilterDevice *)v6;
  if ( v6 )
  {
    *(_DWORD *)v6 = a1;
    *((_DWORD *)v6 + 1) = a2;
    qmemcpy((char *)v6 + 8, a3, 0x1Cu);
    StringCchCopyW((unsigned __int16 *)v6 + 18, 0x27u, a4);
    v5 = 0;
  }
  *a5 = v7;
  return v5;
}

//----- (6E6721FA) --------------------------------------------------------
void __stdcall MoveProviderToIndex(wchar_t *Str2, void *lpMem)
{
  unsigned __int32 v2; // ecx@1
  HKEY hKey; // [sp+0h] [bp-Ch]@1
  wchar_t *Str1; // [sp+4h] [bp-8h]@2
  BYTE pProvidorInfo[4]; // [sp+8h] [bp-4h]@5

  if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Print\\Providers", 0x20019u, &hKey) )
  {
    if ( !HrRegGetTypeWithAlloc(v2, hKey, L"Order", 7u, (unsigned __int8 **)&Str1, 0) )
    {
      if ( !HrAddSzToMultiSz(Str2, Str1, 8u, (unsigned __int32)lpMem, (unsigned __int16 **)&lpMem, (int *)&Str2) && Str2 )
      {
        *(_DWORD *)pProvidorInfo = lpMem;
        if ( !AddPrintProvidorW(0, 2u, pProvidorInfo) && HrFromLastWin32Error() == -2147024809 )
          AddPrintProvidorW(0, 2u, pProvidorInfo);
        MemFree(lpMem);
      }
      MemFree(Str1);
    }
    RegCloseKey(hKey);
  }
}

//----- (6E6722FF) --------------------------------------------------------
__int32 __stdcall HrRegSetString(HKEY hKey, LPCWSTR lpValueName, int a3)
{
  BYTE *v3; // eax@2

  if ( *(_DWORD *)(a3 + 24) < 8u )
    v3 = (BYTE *)(a3 + 4);
  else
    v3 = *(BYTE **)(a3 + 4);
  return HrRegSetSz(hKey, lpValueName, v3);
}

//----- (6E67232A) --------------------------------------------------------
__int32 __stdcall HrCiCreateShortNameValueIfNeeded(HINF InfHandle, int a2, int a3, int a4)
{
  const WCHAR *v4; // eax@2
  __int32 v5; // esi@4
  const WCHAR *v6; // eax@9
  struct _INFCONTEXT Context; // [sp+Ch] [bp-44h]@4
  HKEY v9; // [sp+1Ch] [bp-34h]@1
  HKEY hKey; // [sp+20h] [bp-30h]@6
  int v11; // [sp+24h] [bp-2Ch]@7
  int v12; // [sp+4Ch] [bp-4h]@7

  v9 = (HKEY)a2;
  if ( *(_DWORD *)(a3 + 24) < 8u )
    v4 = (const WCHAR *)(a3 + 4);
  else
    v4 = *(const WCHAR **)(a3 + 4);
  v5 = HrSetupFindFirstLine(InfHandle, v4, L"ShortName", &Context);
  if ( v5 >= 0 )
  {
    v5 = HrSetupGetStringField(&Context, 1u, a4);
    if ( v5 >= 0 )
    {
      v5 = HrRegCreateKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Control\\NetworkProvider\\ShortName",
             0,
             2u,
             0,
             &hKey,
             0);
      if ( v5 >= 0 )
      {
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v11);
        v12 = 0;
        v5 = HrRegQueryTypeString(v9, L"Name", 1u, (int)&v11);
        if ( v5 >= 0 )
        {
          if ( *(_DWORD *)(a4 + 24) < 8u )
            v6 = (const WCHAR *)(a4 + 4);
          else
            v6 = *(const WCHAR **)(a4 + 4);
          v5 = HrRegSetString(hKey, v6, (int)&v11);
        }
        RegCloseKey(hKey);
        v12 = -1;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
          (int)&v11,
          1,
          0);
      }
    }
  }
  if ( v5 == -2146500350 || v5 == -2146500607 )
    v5 = 1;
  if ( v5 < 0 )
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
      0,
      -1);
  return v5;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E672439) --------------------------------------------------------
__int32 __stdcall HrCiGetPrintProviderInfoFromInf(HINF InfHandle, char a2, PCWSTR Section, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // ebx@1
  void *v12; // eax@1
  __int32 v13; // esi@3
  void *v14; // eax@5
  void *v15; // eax@9
  struct _INFCONTEXT Context; // [sp+Ch] [bp-24h]@3
  int v18; // [sp+1Ch] [bp-14h]@1
  int v19; // [sp+20h] [bp-10h]@1
  int v20; // [sp+2Ch] [bp-4h]@1

  v11 = a9;
  v18 = a10;
  v19 = a11;
  v20 = 0;
  v12 = (void *)Section;
  if ( (unsigned int)a8 < 8 )
    v12 = &Section;
  v13 = HrSetupFindFirstLine(InfHandle, (PCWSTR)v12, L"PrintProviderName", &Context);
  if ( !v13 )
  {
    v13 = HrSetupGetStringField(&Context, 1u, v11);
    if ( !v13 )
    {
      v14 = (void *)Section;
      if ( (unsigned int)a8 < 8 )
        v14 = &Section;
      v13 = HrSetupFindFirstLine(InfHandle, (PCWSTR)v14, L"PrintProviderDll", &Context);
      if ( !v13 )
      {
        v13 = HrSetupGetStringField(&Context, 1u, v18);
        if ( !v13 )
        {
          v15 = (void *)Section;
          if ( (unsigned int)a8 < 8 )
            v15 = &Section;
          v13 = HrSetupFindFirstLine(InfHandle, (PCWSTR)v15, L"DisplayName", &Context);
          if ( !v13 )
            v13 = HrSetupGetStringField(&Context, 1u, v19);
        }
      }
    }
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&a2,
    1,
    0);
  return v13;
}

//----- (6E672539) --------------------------------------------------------
__int32 __stdcall HrCiDeletePrintProviderIfNeeded(HKEY a1, unsigned __int32 *a2)
{
  __int32 v2; // eax@1
  unsigned __int32 v3; // ecx@3
  wchar_t *v4; // eax@5
  WCHAR *v5; // eax@9
  void *lpMem; // [sp+Ch] [bp-3Ch]@4
  HKEY v8; // [sp+10h] [bp-38h]@1
  HKEY hKey; // [sp+14h] [bp-34h]@3
  __int32 v10; // [sp+18h] [bp-30h]@1
  int v11; // [sp+1Ch] [bp-2Ch]@1
  LPWSTR pPrintProvidorName; // [sp+20h] [bp-28h]@5
  unsigned int v13; // [sp+34h] [bp-14h]@5
  int v14; // [sp+44h] [bp-4h]@1

  v8 = a1;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v11);
  v14 = 0;
  v2 = HrRegQueryTypeString(a1, L"PrintProviderName", 1u, (int)&v11);
  v10 = v2;
  if ( v2 < 0 )
  {
    if ( v2 == -2147024894 )
      v10 = 0;
  }
  else
  {
    if ( a2 )
    {
      *a2 = 0;
      v10 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Print\\Providers", 0x20019u, &hKey);
      if ( v10 >= 0 )
      {
        v10 = HrRegGetTypeWithAlloc(v3, hKey, L"Order", 7u, (unsigned __int8 **)&lpMem, 0);
        if ( !v10 )
        {
          v4 = pPrintProvidorName;
          if ( v13 < 8 )
            v4 = (wchar_t *)&pPrintProvidorName;
          FGetSzPositionInMultiSzSafe(v4, (wchar_t *)lpMem, a2, 0, 0);
          MemFree(lpMem);
        }
        RegCloseKey(hKey);
      }
    }
    v5 = pPrintProvidorName;
    if ( v13 < 8 )
      v5 = (WCHAR *)&pPrintProvidorName;
    DeletePrintProvidorW(0, 0, v5);
    HrRegDeleteValue(v8, L"PrintProviderName");
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v11,
    1,
    0);
  return v10;
}

//----- (6E672627) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(int this, unsigned int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@4

  v3 = this;
  if ( -1 - *(_DWORD *)(this + 20) <= a2 )
    std::_String_base::_Xlen();
  if ( a2 )
  {
    v4 = a2 + *(_DWORD *)(this + 20);
    if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                            this,
                            a2 + *(_DWORD *)(this + 20),
                            0) )
    {
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Chassign(
        *(_DWORD *)(v3 + 20),
        a2,
        a3);
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
        v3,
        v4);
    }
  }
  return v3;
}
// 6E6722AD: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Chassign(_DWORD, _DWORD, _DWORD);

//----- (6E67267E) --------------------------------------------------------
__int32 __stdcall HrCiDeleteNetProviderInfo(HKEY a1, unsigned __int32 *a2, unsigned __int32 *a3)
{
  __int32 v3; // esi@5
  unsigned __int32 v4; // ecx@7
  void *v5; // eax@17
  int v7; // [sp+10h] [bp-24Ch]@9
  DWORD Type; // [sp+14h] [bp-248h]@5
  void *lpMem; // [sp+18h] [bp-244h]@10
  HKEY hKey; // [sp+1Ch] [bp-240h]@5
  HKEY phkResult; // [sp+20h] [bp-23Ch]@7
  HKEY v12; // [sp+24h] [bp-238h]@1
  wchar_t *Str; // [sp+28h] [bp-234h]@8
  HKEY v14; // [sp+2Ch] [bp-230h]@1
  int v15; // [sp+30h] [bp-22Ch]@15
  LPCWSTR lpValueName; // [sp+34h] [bp-228h]@17
  unsigned int v17; // [sp+48h] [bp-214h]@17
  WCHAR Data[262]; // [sp+4Ch] [bp-210h]@6
  int v19; // [sp+258h] [bp-4h]@15

  v12 = a1;
  v14 = (HKEY)a2;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
    *a3 = 0;
  Type = 512;
  v3 = HrRegOpenKeyEx(a1, L"Ndi", 0x20019u, &hKey);
  if ( !v3 )
  {
    v3 = HrRegQueryTypeSzBuffer(hKey, L"Service", 1u, (LPBYTE)Data, (DWORD)&Type);
    RegCloseKey(hKey);
    if ( !v3 )
    {
      v3 = HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
             0x2001Fu,
             &phkResult);
      if ( !v3 )
      {
        Str = 0;
        v3 = HrRegGetTypeWithAlloc(v4, phkResult, L"ProviderOrder", 1u, (unsigned __int8 **)&Str, 0);
        if ( !v3 && FFindStringInCommaSeparatedList(Data, Str, 0, (int)&v7) )
        {
          v3 = HrRemoveStringFromDelimitedSz(Data, Str, 0x2Cu, 64, (unsigned __int16 **)&lpMem);
          if ( !v3 )
          {
            HrRegSetSz(phkResult, L"ProviderOrder", (BYTE *)lpMem);
            MemFree(lpMem);
          }
          if ( v14 )
            *(_DWORD *)v14 = v7;
        }
        MemFree(Str);
        RegCloseKey(phkResult);
        if ( !v3 )
        {
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v15);
          v19 = 0;
          v3 = HrRegQueryTypeString(v12, L"ShortName", 1u, (int)&v15);
          if ( !v3 )
          {
            v3 = HrRegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   L"System\\CurrentControlSet\\Control\\NetworkProvider\\ShortName",
                   2u,
                   &v14);
            if ( !v3 )
            {
              v5 = (void *)lpValueName;
              if ( v17 < 8 )
                v5 = &lpValueName;
              v3 = HrRegDeleteValue(v14, (LPCWSTR)v5);
              HrRegDeleteValue(v12, L"ShortName");
              RegCloseKey(v14);
            }
          }
          if ( v3 == -2147024894 )
            v3 = 0;
          v19 = -1;
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v15,
            1,
            0);
          if ( !v3 )
            v3 = HrCiDeletePrintProviderIfNeeded(v12, a3);
        }
      }
    }
  }
  return v3;
}

//----- (6E6728B6) --------------------------------------------------------
__int32 __stdcall HrCiSetDeviceName(HINF InfHandle, int a2, int a3, int a4)
{
  const WCHAR *v4; // esi@2
  __int32 v5; // esi@4
  struct _INFCONTEXT Context; // [sp+Ch] [bp-60h]@4
  int v8; // [sp+1Ch] [bp-50h]@1
  HKEY hKey; // [sp+20h] [bp-4Ch]@1
  int v10; // [sp+24h] [bp-48h]@5
  int v11; // [sp+40h] [bp-2Ch]@1
  int v12; // [sp+68h] [bp-4h]@1

  hKey = (HKEY)a2;
  v8 = a4;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
    (int)&v11,
    (void *)&L"\\Device\\");
  v12 = 0;
  if ( *(_DWORD *)(a3 + 24) < 8u )
    v4 = (const WCHAR *)(a3 + 4);
  else
    v4 = *(const WCHAR **)(a3 + 4);
  v5 = HrSetupFindFirstLine(InfHandle, v4, L"DeviceName", &Context);
  if ( v5 >= 0 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v10);
    LOBYTE(v12) = 1;
    v5 = HrSetupGetStringField(&Context, 1u, (int)&v10);
    if ( v5 >= 0 )
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
        (int)&v11,
        (int)&v10,
        0,
        -1);
    LOBYTE(v12) = 0;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
      (int)&v10,
      1,
      0);
  }
  if ( v5 == -2146500350 || v5 == -2146500607 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
      (int)&v11,
      v8,
      0,
      -1);
    v5 = 0;
  }
  if ( v5 >= 0 )
    v5 = HrRegSetString(hKey, L"DeviceName", (int)&v11);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v11,
    1,
    0);
  return v5;
}
// 6E6729B0: using guessed type const unsigned __int16 *const c_szDevice;

//----- (6E6729C7) --------------------------------------------------------
__int32 __stdcall HrCiAddPrintProvider(int a1, int a2, int a3, void *lpMem)
{
  SP_LOG_TOKEN v4; // rax@1
  bool v5; // cf@1
  int v6; // esi@4
  __int32 v7; // eax@7
  __int32 v8; // ebx@7
  __int32 v9; // eax@9
  void *v10; // eax@16
  BYTE pProvidorInfo[4]; // [sp+10h] [bp-40h]@5
  int v13; // [sp+14h] [bp-3Ch]@1
  int v14; // [sp+18h] [bp-38h]@2
  SP_LOG_TOKEN LogToken; // [sp+1Ch] [bp-34h]@1
  char v16; // [sp+24h] [bp-2Ch]@16
  LPCWSTR lpSubKey; // [sp+28h] [bp-28h]@16
  unsigned int v18; // [sp+3Ch] [bp-14h]@16
  int v19; // [sp+4Ch] [bp-4h]@16

  v4 = SetupGetThreadLogToken();
  v13 = 0;
  v5 = *(_DWORD *)(a2 + 24) < 8u;
  LogToken = v4;
  if ( v5 )
    v14 = a2 + 4;
  else
    v14 = *(_DWORD *)(a2 + 4);
  v6 = a1 + 4;
  if ( *(_DWORD *)(a1 + 24) < 8u )
    *(_DWORD *)pProvidorInfo = a1 + 4;
  else
    *(_DWORD *)pProvidorInfo = *(_DWORD *)v6;
  v7 = HrEnableAndStartSpooler();
  v8 = v7;
  if ( v7 )
  {
    if ( *(_DWORD *)(a1 + 24) >= 8u )
      v6 = *(_DWORD *)v6;
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!! NCI: Spooler failed to start while attempting to add print provider %ws. error 0x%08X",
      v6,
      v7);
LABEL_15:
    if ( v8 )
      return v8;
    goto LABEL_16;
  }
  if ( !AddPrintProvidorW(0, 1u, pProvidorInfo) )
  {
    v9 = HrFromLastWin32Error();
    v8 = v9;
    if ( *(_DWORD *)(a1 + 24) >= 8u )
      v6 = *(_DWORD *)v6;
    _SetupWriteTextLog(
      LogToken,
      0x40000000u,
      5 - (g_IsInUpgrade != 0),
      "!!! NCI: Adding print provider %ws failed. 0x%08X",
      v6,
      v9);
    goto LABEL_15;
  }
LABEL_16:
  MoveProviderToIndex(*(wchar_t **)pProvidorInfo, lpMem);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
    (int)&v16,
    L"System\\CurrentControlSet\\Control\\Print\\Providers");
  v19 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v16,
    L"\\");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v16,
    a1,
    0,
    -1);
  v10 = (void *)lpSubKey;
  if ( v18 < 8 )
    v10 = &lpSubKey;
  v8 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v10, 2u, (PHKEY)&LogToken + 1);
  if ( !v8 )
  {
    v8 = HrRegSetString(HIDWORD(LogToken), L"DisplayName", a3);
    RegCloseKey(HIDWORD(LogToken));
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v16,
    1,
    0);
  return v8;
}
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E672B9B) --------------------------------------------------------
__int32 __stdcall HrCiWritePrintProviderInfoIfNeeded(HINF InfHandle, int a2, int a3, void *lpMem)
{
  void *v4; // eax@1
  __int32 v5; // eax@3
  __int32 v6; // esi@3
  char v8; // [sp-2Ch] [bp-D0h]@4
  const WCHAR *v9; // [sp-28h] [bp-CCh]@4
  int v10; // [sp-24h] [bp-C8h]@4
  int v11; // [sp-20h] [bp-C4h]@4
  int v12; // [sp-1Ch] [bp-C0h]@4
  int v13; // [sp-18h] [bp-BCh]@4
  int v14; // [sp-14h] [bp-B8h]@4
  int v15; // [sp-10h] [bp-B4h]@4
  int v16; // [sp-Ch] [bp-B0h]@4
  int v17; // [sp-8h] [bp-ACh]@4
  struct _INFCONTEXT Context; // [sp+Ch] [bp-98h]@3
  char *v19; // [sp+1Ch] [bp-88h]@4
  HKEY hKey; // [sp+20h] [bp-84h]@1
  int v21; // [sp+24h] [bp-80h]@1
  int v22; // [sp+40h] [bp-64h]@1
  int v23; // [sp+5Ch] [bp-48h]@1
  char v24; // [sp+78h] [bp-2Ch]@1
  PCWSTR Section; // [sp+7Ch] [bp-28h]@1
  unsigned int v26; // [sp+90h] [bp-14h]@1
  int v27; // [sp+A0h] [bp-4h]@1

  hKey = (HKEY)a3;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v22);
  v27 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v23);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v21);
  LOBYTE(v27) = 2;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
    (int)&v24,
    a2);
  LOBYTE(v27) = 3;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v24,
    L".");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v24,
    L"PrintProvider");
  v4 = (void *)Section;
  if ( v26 < 8 )
    v4 = &Section;
  v5 = HrSetupFindFirstLine(InfHandle, (PCWSTR)v4, 0, &Context);
  v6 = v5;
  if ( v5 )
  {
    if ( v5 == -2146500350 )
      v6 = 0;
  }
  else
  {
    v17 = (int)&v22;
    v16 = (int)&v21;
    v15 = (int)&v23;
    v19 = &v8;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
      (int)&v8,
      (int)&v24);
    v6 = HrCiGetPrintProviderInfoFromInf(InfHandle, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17);
    if ( !v6 )
    {
      v6 = HrCiAddPrintProvider((int)&v23, (int)&v21, (int)&v22, lpMem);
      if ( !v6 )
        HrRegSetString(hKey, L"PrintProviderName", (int)&v23);
    }
  }
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v24,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v21,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v23,
    1,
    0);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v22,
    1,
    0);
  return v6;
}
// 6E65C8D8: using guessed type wchar_t a_[2];
// 6E672CC0: using guessed type wchar_t aPrintprovider[14];

//----- (6E672CE1) --------------------------------------------------------
__int32 __stdcall HrCiAddNetProviderInfo(void *a1, const unsigned __int16 *a2, HKEY a3, int a4)
{
  __int32 v4; // esi@3
  void *v5; // eax@6
  bool v6; // sf@9
  int v8; // [sp+Ch] [bp-29Ch]@12
  DWORD Type; // [sp+28h] [bp-280h]@3
  void *lpMem; // [sp+2Ch] [bp-27Ch]@1
  void *Src; // [sp+30h] [bp-278h]@1
  HKEY hKey; // [sp+34h] [bp-274h]@3
  HKEY v13; // [sp+38h] [bp-270h]@1
  HINF InfHandle; // [sp+3Ch] [bp-26Ch]@1
  HKEY phkResult; // [sp+40h] [bp-268h]@1
  int v16; // [sp+44h] [bp-264h]@9
  int v17; // [sp+60h] [bp-248h]@9
  char v18; // [sp+7Ch] [bp-22Ch]@6
  LPCWSTR lpSubKey; // [sp+80h] [bp-228h]@6
  unsigned int v20; // [sp+94h] [bp-214h]@6
  BYTE Data; // [sp+98h] [bp-210h]@4
  int v22; // [sp+2A4h] [bp-4h]@6

  InfHandle = a1;
  Src = (void *)a2;
  v13 = a3;
  phkResult = 0;
  lpMem = 0;
  if ( a4 )
    HrCiDeleteNetProviderInfo(a3, (unsigned __int32 *)&phkResult, (unsigned __int32 *)&lpMem);
  Type = 512;
  v4 = HrRegOpenKeyEx(a3, L"Ndi", 0x20019u, &hKey);
  if ( !v4 )
  {
    v4 = HrRegQueryTypeSzBuffer(hKey, L"Service", 1u, &Data, (DWORD)&Type);
    RegCloseKey(hKey);
    if ( !v4 )
    {
      v4 = HrRegAddStringToSz(
             (wchar_t *)&Data,
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
             L"ProviderOrder",
             0x2Cu,
             0x18u,
             (unsigned __int32)phkResult);
      if ( !v4 )
      {
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
          (int)&v18,
          (void *)&L"System\\CurrentControlSet\\Services");
        v22 = 0;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          (int)&v18,
          L"\\");
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          (int)&v18,
          &Data);
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          (int)&v18,
          L"\\");
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          (int)&v18,
          L"NetworkProvider");
        v5 = (void *)lpSubKey;
        if ( v20 < 8 )
          v5 = &lpSubKey;
        v4 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCWSTR)v5, 0x2001Bu, &phkResult);
        if ( !v4 )
        {
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
            (int)&v17,
            Src);
          LOBYTE(v22) = 1;
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
            (int)&v17,
            1u,
            46);
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
            (int)&v17,
            L"NetworkProvider");
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v16);
          LOBYTE(v22) = 2;
          v4 = HrCiCreateShortNameValueIfNeeded(InfHandle, (int)phkResult, (int)&v17, (int)&v16);
          v6 = v4 < 0;
          if ( !v4 )
          {
            HrRegSetString(v13, L"ShortName", (int)&v16);
            v6 = 0;
          }
          if ( !v6 )
          {
            std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
              (int)&v8,
              &Data);
            LOBYTE(v22) = 3;
            v4 = HrCiSetDeviceName(InfHandle, (int)phkResult, (int)&v17, (int)&v8);
            std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
              (int)&v8,
              1,
              0);
          }
          RegCloseKey(phkResult);
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v16,
            1,
            0);
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v17,
            1,
            0);
        }
        v22 = -1;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
          (int)&v18,
          1,
          0);
        if ( !v4 )
        {
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
            (int)&v8,
            Src);
          v22 = 4;
          v4 = HrCiWritePrintProviderInfoIfNeeded(InfHandle, (int)&v8, (int)v13, lpMem);
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v8,
            1,
            0);
        }
      }
    }
  }
  return v4;
}
// 6E672FA0: using guessed type wchar_t aNetworkprovide[16];
// 6E672FC0: using guessed type const unsigned __int16 *const c_szRegKeyServices;

//----- (6E673009) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingInterface::GetUpperComponent(CImplINetCfgBindingInterface *this, struct INetCfgComponent **a2)
{
  signed int v2; // ebx@1

  *a2 = 0;
  v2 = CImplINetCfgBindingInterface::HrLockAndTestForValidInterface(this, 0);
  if ( !v2 )
  {
    AddRefObj(*((struct IUnknown **)this + 4));
    *a2 = (struct INetCfgComponent *)*((_DWORD *)this + 4);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v2;
}

//----- (6E673051) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::IsSamePathAs(CImplINetCfgBindingPath *this, struct INetCfgBindingPath *a2)
{
  signed int v2; // esi@1
  struct INetCfgBindingPathVtbl *v3; // eax@2

  v2 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, 0);
  if ( !v2 )
  {
    v3 = (struct INetCfgBindingPathVtbl *)*((_DWORD *)this + 13);
    if ( v3 == a2[13].lpVtbl )
      v2 = memcmp(*((const char **)this + 12), (const char *)a2[12].lpVtbl, 4 * (_DWORD)v3) != 0;
    else
      v2 = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v2;
}

//----- (6E6730B5) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::IsSubPathOf(CImplINetCfgBindingPath *this, struct INetCfgBindingPath *a2)
{
  signed int v2; // esi@1
  struct INetCfgBindingPathVtbl *v3; // eax@2

  v2 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, 0);
  if ( !v2 )
  {
    v3 = a2[13].lpVtbl;
    if ( *((_DWORD *)this + 13) < (unsigned int)v3 )
      v2 = memcmp(
             *((const char **)this + 12),
             (const char *)a2[12].lpVtbl + 4 * (_DWORD)((char *)v3 - *((_DWORD *)this + 13)),
             4 * *((_DWORD *)this + 13)) != 0;
    else
      v2 = 1;
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v2;
}

//----- (6E673123) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::GetOwner(CImplINetCfgBindingPath *this, struct INetCfgComponent **a2)
{
  struct INetCfgComponent **v2; // edi@1
  signed int v4; // [sp+14h] [bp+Ch]@1

  v2 = a2;
  *a2 = 0;
  v4 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, 0);
  if ( !v4 )
  {
    AddRefObj(**((struct IUnknown ***)this + 12));
    *v2 = (struct INetCfgComponent *)**((_DWORD **)this + 12);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v4;
}

//----- (6E673171) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::GetDepth(CImplINetCfgBindingPath *this, unsigned __int32 *a2)
{
  unsigned __int32 *v2; // esi@1
  signed int v4; // [sp+14h] [bp+Ch]@1

  v2 = a2;
  *a2 = 0;
  v4 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, 0);
  if ( !v4 )
  {
    *v2 = *((_DWORD *)this + 13);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  return v4;
}

//----- (6E6731B3) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::Enable(CImplINetCfgBindingPath *this, int a2)
{
  signed int v2; // edi@1
  char v4; // [sp+8h] [bp-14h]@1
  char v5; // [sp+Ch] [bp-10h]@1

  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v5, 0);
  v2 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 2u, (struct CBindPath *)&v4);
  if ( !v2 )
  {
    v2 = CModifyContext::HrEnableOrDisableBindPath(
           (CModifyContext *)(*(_DWORD *)(*((_DWORD *)this + 3) + 48) + 72),
           a2 != 0 ? 16 : 32,
           (struct CBindPath *)&v4,
           (struct INetCfgBindingPath *)this);
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v5);
  return v2;
}

//----- (6E673222) --------------------------------------------------------
signed int __stdcall CImplINetCfgBindingPath::GetPathToken(CImplINetCfgBindingPath *this, unsigned __int16 **a2)
{
  void **v2; // esi@1
  signed int v3; // ebx@1
  char v5; // [sp+Ch] [bp-14h]@1
  char v6; // [sp+10h] [bp-10h]@1

  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v6, 0);
  v2 = (void **)a2;
  *a2 = 0;
  v3 = CImplINetCfgBindingPath::HrLockAndTestForValidInterface(this, 0, (struct CBindPath *)&v5);
  if ( !v3 )
  {
    a2 = 0;
    CBindPath::FGetPathToken((CBindPath *)&v5, 0, (unsigned __int32 *)&a2);
    if ( a2 )
    {
      a2 = (unsigned __int16 **)((char *)a2 + 1);
      v3 = HrCoTaskMemAlloc(2 * (_DWORD)a2, v2);
      if ( !v3 )
        CBindPath::FGetPathToken((CBindPath *)&v5, (STRSAFE_LPWSTR)*v2, (unsigned __int32 *)&a2);
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)this + 3) + 24));
  }
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v6);
  return v3;
}

//----- (6E6732AE) --------------------------------------------------------
int __stdcall HrCallValidateProperties(HWND a1)
{
  int result; // eax@1
  int i; // esi@1

  result = 0;
  for ( i = 0; i < g_cai; ++i )
  {
    result = (*(int (__stdcall **)(_DWORD, HWND))(**(_DWORD **)(dword_6E69BD08 + 4 * i) + 24))(
               *(_DWORD *)(dword_6E69BD08 + 4 * i),
               a1);
    if ( result )
      break;
  }
  return result;
}
// 6E69BD08: using guessed type int dword_6E69BD08;

//----- (6E6732E8) --------------------------------------------------------
int __stdcall FVerifyCAPAGES(const struct CAPAGES *a1)
{
  int v1; // edx@1

  v1 = 0;
  if ( *(_DWORD *)a1 )
    LOBYTE(v1) = *((_DWORD *)a1 + 1) != 0;
  else
    LOBYTE(v1) = *((_DWORD *)a1 + 1) == 0;
  return v1;
}

//----- (6E673311) --------------------------------------------------------
int __stdcall NetCfgPsDlgProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM a4)
{
  bool v4; // zf@6
  LRESULT v5; // eax@9
  LPARAM lParam; // [sp+4h] [bp-Ch]@9
  int v8; // [sp+8h] [bp-8h]@9
  int v9; // [sp+Ch] [bp-4h]@9

  if ( Msg == 2 )
  {
    SetWindowLongW(hWnd, 4, lpfnOldWndProc);
  }
  else
  {
    if ( Msg != 273 )
    {
      if ( Msg != 274 )
      {
        if ( Msg == 1128 )
          g_fChanged = 1;
        return CallWindowProcW((WNDPROC)lpfnOldWndProc, hWnd, Msg, wParam, a4);
      }
      v4 = wParam == 61536;
LABEL_15:
      if ( v4 )
        g_hr = -2147023673;
      return CallWindowProcW((WNDPROC)lpfnOldWndProc, hWnd, Msg, wParam, a4);
    }
    if ( 1 == (_WORD)wParam )
    {
      if ( !HIWORD(wParam) )
      {
        v8 = 0;
        lParam = (LPARAM)hWnd;
        v9 = -201;
        v5 = SendMessageW(hWnd, 0x476u, 0, 0);
        if ( SendMessageW((HWND)v5, 0x4Eu, 0, (LPARAM)&lParam) || HrCallValidateProperties(hWnd) )
          return 1;
      }
    }
    else if ( 2 == (_WORD)wParam )
    {
      v4 = HIWORD(wParam) == 0;
      goto LABEL_15;
    }
  }
  return CallWindowProcW((WNDPROC)lpfnOldWndProc, hWnd, Msg, wParam, a4);
}
// 6E69BCFC: using guessed type int g_fChanged;
// 6E69BD00: using guessed type __int32 g_hr;

//----- (6E673403) --------------------------------------------------------
int __stdcall NetCfgPropSheetCallback(HWND hWnd, unsigned int a2, __int32 a3)
{
  int v3; // esi@2

  if ( a2 == 1 )
  {
    v3 = 0;
    for ( lpfnOldWndProc = SetWindowLongW(hWnd, 4, (LONG)NetCfgPsDlgProc); v3 < g_capPagesToAdd; ++v3 )
      SendMessageW(hWnd, 0x467u, 0, *(_DWORD *)(dword_6E69BD10 + 4 * v3));
  }
  return 0;
}
// 6E69BD10: using guessed type int dword_6E69BD10;

//----- (6E67345B) --------------------------------------------------------
__int32 __stdcall HrNetCfgPropertySheet(LPCPROPSHEETHEADERW a1, const struct CAPAGES *a2, const unsigned __int16 *a3, const struct CAINCP *a4)
{
  int v4; // eax@1
  DWORD v5; // edi@1
  __int32 result; // eax@8

  g_cai = *(_DWORD *)a4;
  v4 = *((_DWORD *)a4 + 1);
  g_capPagesToAdd = 0;
  dword_6E69BD10 = 0;
  dword_6E69BD08 = v4;
  a1->dwFlags |= 0x100u;
  v5 = a1->dwFlags;
  a1->pfnCallback = NetCfgPropSheetCallback;
  if ( FVerifyCAPAGES(a2) )
  {
    a1->nPages = *(_DWORD *)a2;
    a1->ppsp = (LPCPROPSHEETPAGEW)*((_DWORD *)a2 + 1);
  }
  else
  {
    a1->nPages = 0;
    a1->ppsp = 0;
  }
  if ( a3 )
  {
    a1->dwFlags = v5 | 0x40;
    a1->nStartPage = (UINT)a3;
  }
  g_hr = 0;
  g_fChanged = 0;
  if ( PropertySheetW(a1) == -1 )
    g_hr = -2147467259;
  result = g_hr;
  if ( g_hr >= 0 )
    result = g_fChanged == 0;
  return result;
}
// 6E69BCFC: using guessed type int g_fChanged;
// 6E69BD00: using guessed type __int32 g_hr;
// 6E69BD08: using guessed type int dword_6E69BD08;
// 6E69BD10: using guessed type int dword_6E69BD10;

//----- (6E67350E) --------------------------------------------------------
__int32 __stdcall HrLoadAndAddComponentFromInstanceKey(HKEY a1, int a2, int a3, int a4, CNetConfigCore *a5)
{
  __int32 result; // eax@1
  DWORD v6; // [sp+Ch] [bp-454h]@4
  CNetConfigCore *v7; // [sp+10h] [bp-450h]@1
  int v8; // [sp+14h] [bp-44Ch]@1
  DWORD v9; // [sp+18h] [bp-448h]@7
  struct CComponent *v10; // [sp+1Ch] [bp-444h]@10
  HKEY hKey; // [sp+20h] [bp-440h]@3
  char v12; // [sp+24h] [bp-43Ch]@1
  int v13; // [sp+28h] [bp-438h]@10
  int v14; // [sp+2Ch] [bp-434h]@10
  int v15; // [sp+30h] [bp-430h]@10
  int v16; // [sp+34h] [bp-42Ch]@10
  DWORD Type; // [sp+38h] [bp-428h]@1
  wchar_t *v18; // [sp+44h] [bp-41Ch]@10
  int v19; // [sp+48h] [bp-418h]@10
  BYTE Data; // [sp+4Ch] [bp-414h]@4
  wchar_t Str2; // [sp+254h] [bp-20Ch]@7

  v8 = a2;
  v7 = a5;
  memset(&v12, 0, 0x28u);
  result = HrRegQueryDword(a1, L"Characteristics", (DWORD)&Type);
  if ( !result )
  {
    if ( Type & 0x400 && !HrRegOpenKeyEx(a1, L"Ndi", 0x2001Fu, &hKey) )
    {
      v6 = 520;
      if ( !HrRegQueryTypeSzBuffer(hKey, L"MiniportId", 1u, &Data, (DWORD)&v6) )
        HrRegSetSz(hKey, L"FilterDeviceInfId", &Data);
      RegCloseKey(hKey);
    }
    v9 = 520;
    result = HrRegQueryTypeSzBuffer(a1, L"ComponentId", 1u, (LPBYTE)&Str2, (DWORD)&v9);
    if ( !result )
    {
      if ( !_wcsicmp(L"ms_wanarp", &Str2) )
        HrRegDeleteKey(a1, L"RefCounts");
      *(_DWORD *)&v12 = *(_DWORD *)v8;
      v13 = *(_DWORD *)(v8 + 4);
      v14 = *(_DWORD *)(v8 + 8);
      v15 = *(_DWORD *)(v8 + 12);
      v16 = a3;
      v18 = &Str2;
      v19 = a4;
      result = CComponent::HrCreateInstance((const struct BASIC_COMPONENT_DATA *)&v12, 1, 0, &v10);
      if ( !result )
        result = CNetConfigCore::HrAddComponentToCore(v7, v10, 0x1000u);
    }
  }
  return result;
}

//----- (6E6736C3) --------------------------------------------------------
int __stdcall FUpgradeFilterDeviceInstanceKey(struct CNetConfig *a1, HKEY hKey, const unsigned __int16 *a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = CComponentList::PFindComponentByBindForm((int)a1, 4u, (wchar_t *)a3);
  if ( v3 )
  {
    HrRegSetSz(hKey, L"FilterInfId", *(BYTE **)(v3 + 28));
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E6736F9) --------------------------------------------------------
void __stdcall UpgradeConnection(const struct _GUID *a1, BYTE *lpData)
{
  HKEY hKey; // [sp+4h] [bp-210h]@1
  wchar_t pszDest; // [sp+8h] [bp-20Ch]@1

  CreateInstanceKeyPath(0, (GUID *)a1, &pszDest);
  StringCchCatW(&pszDest, 0x104u, L"\\Connection");
  if ( !HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0x2001Fu, &hKey) )
  {
    HrRegSetSz(hKey, L"PnpInstanceId", lpData);
    RegCloseKey(hKey);
  }
}

//----- (6E6737C1) --------------------------------------------------------
__int32 __stdcall HrLoadComponentReferencesFromLegacy(struct CNetConfig *a1)
{
  CComponent **v1; // eax@1
  __int32 v2; // esi@1
  CComponent *v3; // edi@4
  int v4; // eax@9
  const struct CComponent *v5; // eax@12
  CComponentReferences *v6; // ecx@13
  BYTE Data; // [sp+8h] [bp-23Ch]@7
  DWORD Type; // [sp+Ch] [bp-238h]@7
  DWORD cchValueName; // [sp+10h] [bp-234h]@7
  DWORD cbData; // [sp+14h] [bp-230h]@7
  HKEY v12; // [sp+18h] [bp-22Ch]@4
  HKEY hKey; // [sp+1Ch] [bp-228h]@5
  DWORD dwIndex; // [sp+20h] [bp-224h]@6
  CComponent **v15; // [sp+24h] [bp-220h]@1
  IID iid; // [sp+28h] [bp-21Ch]@11
  wchar_t Str2; // [sp+38h] [bp-20Ch]@7

  v1 = (CComponent **)*((_DWORD *)a1 + 2);
  v2 = 0;
  v15 = v1;
  if ( v1 == *((CComponent ***)a1 + 3) )
    return v2;
  while ( 2 )
  {
    v3 = *v1;
    v2 = CComponent::HrOpenInstanceKey(*v1, 0x20019u, &v12, 0, 0);
    if ( v2 )
      goto LABEL_23;
    v2 = HrRegOpenKeyEx(v12, L"RefCounts", 0x20019u, &hKey);
    if ( v2 )
      goto LABEL_22;
    dwIndex = 0;
    do
    {
      cchValueName = 260;
      cbData = 4;
      v2 = HrRegEnumValue(hKey, dwIndex, &Str2, &cchValueName, &Type, &Data, &cbData);
      if ( v2 )
        goto LABEL_18;
      if ( _wcsicmp(L"User", &Str2) )
      {
        if ( 123 != Str2
          || IIDFromString(&Str2, &iid)
          || (v5 = CComponentList::PFindComponentByInstanceGuid(a1, &iid)) == 0 )
        {
          v5 = (const struct CComponent *)CComponentList::PFindComponentByInfId(a1, &Str2, 0);
          v6 = (CComponent *)((char *)v3 + 120);
          if ( !v5 )
          {
            v4 = CComponentReferences::HrAddReferenceBySoftware(v6, &Str2);
            goto LABEL_17;
          }
        }
        else
        {
          v6 = (CComponent *)((char *)v3 + 120);
        }
        v4 = CComponentReferences::HrAddReferenceByComponent(v6, v5);
      }
      else
      {
        v4 = CComponentReferences::HrAddReferenceByUser((CComponent *)((char *)v3 + 120));
      }
LABEL_17:
      v2 = v4;
LABEL_18:
      ++dwIndex;
    }
    while ( !v2 );
    if ( v2 == -2147024637 )
      v2 = 0;
    RegCloseKey(hKey);
LABEL_22:
    RegCloseKey(v12);
LABEL_23:
    ++v15;
    if ( v15 != *((CComponent ***)a1 + 3) )
    {
      v1 = v15;
      continue;
    }
    break;
  }
  if ( v2 == -2147024894 )
    v2 = 0;
  return v2;
}

//----- (6E673993) --------------------------------------------------------
__int32 __stdcall HrLoadNetworkConfigurationFromLegacy(struct CNetConfig *a1)
{
  struct CNetConfig *v1; // ebx@1
  SP_LOG_TOKEN v2; // rax@1
  HKEY v3; // ecx@5
  int v4; // eax@7
  const WCHAR *v5; // esi@7
  __int32 v6; // esi@8
  DWORD v7; // ebx@9
  signed int v8; // esi@27
  HKEY v9; // esi@44
  bool v10; // zf@44
  int v11; // ebx@45
  __int32 v12; // eax@47
  unsigned __int32 v13; // ecx@50
  const unsigned __int16 *j; // esi@52
  int v15; // eax@55
  wchar_t *k; // eax@53
  struct _FILETIME ftLastWriteTime; // [sp+Ch] [bp-708h]@10
  char v19; // [sp+14h] [bp-700h]@52
  int v20; // [sp+18h] [bp-6FCh]@44
  char v21; // [sp+28h] [bp-6ECh]@53
  char v22; // [sp+2Ch] [bp-6E8h]@44
  HKEY v23; // [sp+3Ch] [bp-6D8h]@25
  unsigned __int16 *v24; // [sp+40h] [bp-6D4h]@53
  DWORD Type; // [sp+44h] [bp-6D0h]@28
  unsigned __int32 v26; // [sp+48h] [bp-6CCh]@25
  HDEVINFO DeviceInfoSet; // [sp+4Ch] [bp-6C8h]@20
  void *lpMem; // [sp+50h] [bp-6C4h]@7
  DWORD cchName; // [sp+54h] [bp-6C0h]@7
  HKEY hKey; // [sp+58h] [bp-6BCh]@1
  HKEY i; // [sp+5Ch] [bp-6B8h]@5
  HKEY v32; // [sp+60h] [bp-6B4h]@2
  HKEY v33; // [sp+64h] [bp-6B0h]@7
  HKEY phkResult; // [sp+68h] [bp-6ACh]@13
  struct CNetConfig *v35; // [sp+6Ch] [bp-6A8h]@1
  struct _SP_DEVINFO_DATA DeviceInfoData; // [sp+70h] [bp-6A4h]@22
  IID iid; // [sp+8Ch] [bp-688h]@12
  WCHAR DeviceInstanceId; // [sp+9Ch] [bp-678h]@23
  BYTE Data[2]; // [sp+4ACh] [bp-268h]@28
  OLECHAR sz; // [sp+6B4h] [bp-60h]@10
  int v41; // [sp+710h] [bp-4h]@44

  v1 = a1;
  v35 = a1;
  v2 = SetupGetThreadLogToken();
  _SetupWriteTextLog(
    v2,
    0x40000000u,
    5 - (g_IsInUpgrade != 0),
    "NCI: Creating new Config data from legacy registry info");
  if ( !HrOpenNetworkKey(0x20019u, &hKey) )
  {
    if ( !HrRegQueryDword(hKey, L"WanAdaptersFirst", (DWORD)&v32) )
      *((_DWORD *)a1 + 10) = v32 != 0;
    RegCloseKey(hKey);
  }
  v3 = 0;
  for ( i = 0; ; v3 = i )
  {
    v4 = *(_DWORD *)((char *)v3 + (_DWORD)&dword_6E673F90);
    cchName = *(_DWORD *)((char *)v3 + (_DWORD)&dword_6E673F94);
    v5 = (&MAP_NETCLASS_TO_NETWORK_SUBTREE)[2 * v4];
    lpMem = (void *)v4;
    v33 = (HKEY)(4 * v4);
    if ( FIsConsideredNetClass(v4) )
    {
      v6 = HrSetupDiGetClassDevs(*(GUID **)((char *)v33 + (_DWORD)&MAP_NETCLASS_TO_GUID), 0, 0, 8u, &DeviceInfoSet);
      if ( !v6 )
      {
        v33 = 0;
        do
        {
          v6 = HrSetupDiEnumDeviceInfo(DeviceInfoSet, (DWORD)v33, &DeviceInfoData);
          if ( !v6 )
          {
            if ( SetupDiGetDeviceInstanceIdW(DeviceInfoSet, &DeviceInfoData, &DeviceInstanceId, 0x208u, 0)
              && !HrSetupDiOpenDevRegKey(DeviceInfoSet, &DeviceInfoData, 1u, 0, 2u, 0x2001Fu, &phkResult) )
            {
              v26 = 16;
              if ( !HrRegOpenKeyEx(phkResult, L"Linkage", 0x20019u, &v23) )
              {
                RegCloseKey(v23);
                if ( !RegQueryGuid(phkResult, L"NetCfgInstanceId", &iid, &v26) )
                {
                  v8 = 0;
                  if ( HrRegOpenKeyEx(phkResult, L"Ndi", 0x20019u, &v32) )
                    goto LABEL_71;
                  Type = 520;
                  if ( !HrRegQueryTypeSzBuffer(v32, L"FilterName", 1u, Data, (DWORD)&Type) )
                    v8 = 1;
                  RegCloseKey(v32);
                  if ( !v8 )
                  {
LABEL_71:
                    if ( cchName == 1 )
                    {
                      UpgradeConnection(&iid, (BYTE *)&DeviceInstanceId);
                      HrLoadAndAddComponentFromInstanceKey(
                        phkResult,
                        (int)&iid,
                        (int)lpMem,
                        (int)&DeviceInstanceId,
                        v35);
                    }
                  }
                  else if ( cchName == 2 )
                  {
                    FUpgradeFilterDeviceInstanceKey(v35, phkResult, (const unsigned __int16 *)Data);
                  }
                }
              }
              RegCloseKey(phkResult);
            }
            v1 = v35;
            v6 = 0;
          }
          v33 = (HKEY)((char *)v33 + 1);
        }
        while ( !v6 );
        if ( v6 == -2147024637 )
          v6 = 0;
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
      }
    }
    else
    {
      v6 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, v5, 0x20019u, &hKey);
      if ( !v6 )
      {
        v7 = 0;
        do
        {
          cchName = 39;
          v6 = HrRegEnumKeyEx(hKey, v7, &sz, &cchName, 0, 0, &ftLastWriteTime);
          if ( !v6 && cchName == 38 )
          {
            if ( !IIDFromString(&sz, &iid) && !HrRegOpenKeyEx(hKey, &sz, 0x20019u, &phkResult) )
            {
              HrLoadAndAddComponentFromInstanceKey(phkResult, (int)&iid, (int)lpMem, 0, v35);
              RegCloseKey(phkResult);
            }
            v6 = 0;
          }
          ++v7;
        }
        while ( !v6 );
        if ( v6 == -2147024637 )
          v6 = 0;
        RegCloseKey(hKey);
        v1 = v35;
      }
    }
    i += 2;
    if ( (unsigned int)i >= 0x30 )
      break;
  }
  if ( !v6 )
  {
    v6 = HrLoadComponentReferencesFromLegacy(v1);
    if ( !v6 )
    {
      std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy((int)&v22, 0);
      v41 = 0;
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Buy((int)&v20, 0);
      v9 = (HKEY)*((_DWORD *)v1 + 2);
      v10 = v9 == *((HKEY *)v1 + 3);
      LOBYTE(v41) = 1;
      while ( 1 )
      {
        v32 = v9;
        if ( v10 )
          break;
        v11 = *(_DWORD *)v9;
        if ( FIsConsideredNetClass(*(_DWORD *)(*(_DWORD *)v9 + 16)) || !*(_DWORD *)(v11 + 48) )
          v12 = CComponent::HrOpenInstanceKey((CComponent *)v11, 0x20019u, &v33, 0, 0);
        else
          v12 = CComponent::HrOpenServiceKey((CComponent *)v11, 0x20019u, &v33);
        if ( !v12 )
        {
          if ( !HrRegOpenKeyEx(v33, L"Linkage\\Disabled", 0x20019u, &i) )
          {
            if ( !HrRegGetTypeWithAlloc(v13, i, L"BindPath", 7u, (unsigned __int8 **)&lpMem, 0) )
            {
              CNetConfigCore::HrGetComponentBindings(v35, (const struct CComponent *)v11, 0, (struct CBindingSet *)&v19);
              for ( j = (const unsigned __int16 *)lpMem; *j; j += wcslen(j) + 1 )
              {
                std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::clear((int)&v22);
                CBindPath::HrAppendComponent((CBindPath *)&v21, (const struct CComponent *)v11);
                for ( k = (wchar_t *)GetNextStringToken((unsigned __int16 *)j, L"_", &v24);
                      k;
                      k = (wchar_t *)GetNextStringToken(0, L"_", &v24) )
                {
                  if ( !*k )
                    break;
                  v15 = CComponentList::PFindComponentByBindName((int)v35, 6u, k);
                  if ( !v15 )
                    break;
                  CBindPath::HrAppendComponent((CBindPath *)&v21, (const struct CComponent *)v15);
                }
                if ( CBindingSet::FContainsBindPath((CBindingSet *)&v19, (const struct CBindPath *)&v21) )
                  CNetConfigCore::HrDisableBindPath(v35, (const struct CBindPath *)&v21);
              }
              MemFree(lpMem);
              v9 = v32;
            }
            RegCloseKey(i);
          }
          RegCloseKey(v33);
        }
        ++v9;
        v10 = v9 == *((HKEY *)v35 + 3);
      }
      v6 = 0;
      std::vector<CBindPath,std::nc_allocator<CBindPath>>::_Tidy((int)&v20);
      std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)&v22);
    }
  }
  return v6;
}
// 6E673F90: using guessed type int dword_6E673F90;
// 6E673F94: using guessed type int dword_6E673F94;
// 6E69B2C8: using guessed type int g_IsInUpgrade;

//----- (6E674021) --------------------------------------------------------
LONG __cdecl CompareFilterDevices(const void *a1, const void *a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // esi@1
  bool v4; // cf@1
  int v5; // eax@2
  int v6; // ecx@2
  unsigned int v7; // edx@2
  unsigned int v8; // esi@2
  LONG result; // eax@3

  v2 = **(_DWORD **)a1;
  v3 = **(_DWORD **)a2;
  v4 = v2 < v3;
  if ( v2 != v3
    || (v5 = *(_DWORD *)(*(_DWORD *)a2 + 4),
        v6 = *(_DWORD *)(*(_DWORD *)a1 + 4),
        v7 = *(_DWORD *)(v6 + 128),
        v8 = *(_DWORD *)(v5 + 128),
        v4 = v7 < v8,
        v7 != v8) )
    result = v4 ? -1 : 1;
  else
    result = CompareTimeStamps(*(SYSTEMTIME **)(v5 + 76), *(SYSTEMTIME **)(v6 + 76));
  return result;
}

//----- (6E67406C) --------------------------------------------------------
const struct CComponent **__thiscall CFilterDevices::PFindFilterDeviceByAdapterAndFilter(CFilterDevices *this, const struct CComponent *a2, const struct CComponent *a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  const struct CComponent **result; // eax@2

  v3 = *((_DWORD *)this + 1);
  v4 = *((_DWORD *)this + 2);
  while ( v3 != v4 )
  {
    result = *(const struct CComponent ***)v3;
    if ( a2 == **(const struct CComponent ***)v3 && a3 == result[1] )
      return result;
    v3 += 4;
  }
  return 0;
}

//----- (6E67409E) --------------------------------------------------------
struct CFilterDevice *__thiscall CFilterDevices::PFindFilterDeviceByInstanceGuid(CFilterDevices *this, const unsigned __int16 *a2)
{
  int v2; // ebx@1
  int i; // edi@1
  struct CFilterDevice *result; // eax@2

  v2 = *((_DWORD *)this + 2);
  for ( i = *((_DWORD *)this + 1); i != v2; i += 4 )
  {
    result = *(struct CFilterDevice **)i;
    if ( !wcscmp(a2, (const unsigned __int16 *)(*(_DWORD *)i + 36)) )
      return result;
  }
  return 0;
}

//----- (6E6740FA) --------------------------------------------------------
__int32 __thiscall CFilterDevices::HrFindDeviceAndOpenInstanceKey(CFilterDevices *this, const struct CComponent *a2, const struct CComponent *a3, struct CFilterDevice **a4, HKEY *a5)
{
  __int32 v5; // ebx@1
  CFilterDevices *v6; // edi@1
  const struct CComponent **v7; // esi@2

  v5 = 0;
  v6 = this;
  if ( a4 )
  {
    v7 = CFilterDevices::PFindFilterDeviceByAdapterAndFilter(this, a2, a3);
    if ( v7 )
    {
      v5 = HrSetupDiOpenDevRegKey(*((HDEVINFO *)v6 + 10), (PSP_DEVINFO_DATA)(v7 + 2), 1u, 0, 2u, 0x20019u, a5);
      if ( !v5 )
        *a4 = (struct CFilterDevice *)v7;
    }
  }
  return v5;
}

//----- (6E67414E) --------------------------------------------------------
__int32 __thiscall CFilterDevices::HrLoadFilterDevice(CFilterDevices *this, struct _SP_DEVINFO_DATA *a2, HKEY a3, const unsigned __int16 *a4, int *a5)
{
  CFilterDevices *v5; // esi@1
  __int32 v6; // ebx@1
  unsigned __int32 v7; // ecx@2
  struct CFilterDevice *v8; // ecx@4
  int v9; // edi@7
  int v10; // eax@14
  struct CComponent *v11; // ebx@14
  DWORD Type; // [sp+14h] [bp-6Ch]@1
  HKEY hKey; // [sp+18h] [bp-68h]@2
  int v15; // [sp+1Ch] [bp-64h]@1
  void *lpMem; // [sp+20h] [bp-60h]@3
  wchar_t *Str1; // [sp+24h] [bp-5Ch]@1
  struct CFilterDevice *v18; // [sp+28h] [bp-58h]@5
  BYTE Data; // [sp+2Ch] [bp-54h]@1

  v15 = 0;
  Str1 = (wchar_t *)a4;
  *a5 = 0;
  v5 = this;
  Type = 78;
  v6 = HrRegQueryTypeSzBuffer(a3, L"NetCfgInstanceId", 1u, &Data, (DWORD)&Type);
  if ( !v6 )
  {
    v6 = HrRegOpenKeyEx(a3, L"Linkage", 0x20019u, &hKey);
    if ( !v6 )
    {
      v6 = HrRegGetTypeWithAlloc(v7, hKey, L"RootDevice", 7u, (unsigned __int8 **)&lpMem, 0);
      if ( v6 )
      {
        v9 = v15;
      }
      else
      {
        v8 = (struct CFilterDevice *)lpMem;
        if ( !*(_WORD *)lpMem )
          goto LABEL_24;
        do
        {
          v18 = v8;
          v8 = (struct CFilterDevice *)((char *)v8 + 2 * wcslen((const unsigned __int16 *)v8) + 2);
        }
        while ( *(_WORD *)v8 );
        if ( v18 )
        {
          v9 = CComponentList::PFindComponentByBindName(*((_DWORD *)v5 + 4), 0, (wchar_t *)v18);
          if ( !v9 )
            v6 = -2147023728;
        }
        else
        {
LABEL_24:
          v9 = v15;
        }
        MemFree(lpMem);
      }
      RegCloseKey(hKey);
      if ( !v6 )
      {
        v6 = CNetConfigCore::HrGetFiltersEnabledForAdapter(
               *((CNetConfigCore **)v5 + 4),
               (const struct CComponent *)v9,
               (CFilterDevices *)((char *)v5 + 20),
               0,
               0);
        if ( !v6 )
        {
          v10 = CComponentList::PFindComponentByInfId(*((CComponentList **)v5 + 4), Str1, 0);
          v11 = (struct CComponent *)v10;
          if ( v10
            && CComponentList::FComponentInList((CFilterDevices *)((char *)v5 + 20), (const struct CComponent *)v10) )
          {
            v6 = CFilterDevice::HrCreateInstance(
                   (struct CComponent *)v9,
                   v11,
                   a2,
                   (const unsigned __int16 *)&Data,
                   &v18);
            if ( !v6 )
            {
              v6 = CPszArray::HrAddPointer(v5, (const unsigned __int16 *)v18);
              if ( v6 )
              {
                if ( v18 )
                  operator delete((void *)v18);
              }
            }
          }
          else
          {
            *a5 = 1;
            CDiagContext::Printf(
              (DWORD)g_pDiagCtx,
              3,
              "   Removing filter device for %S over %S adapter\n",
              Str1,
              *(_DWORD *)(v9 + 32));
            v6 = CNetConfigCore::HrGetComponentUpperBindings(
                   *((CNetConfigCore **)v5 + 4),
                   (const struct CComponent *)v9,
                   3,
                   (CFilterDevices *)((char *)v5 + 48));
          }
        }
      }
    }
  }
  return v6;
}

//----- (6E674337) --------------------------------------------------------
__int32 __stdcall CFilteredAdapters::HrWriteFilterServiceKey(const struct CComponent *a2, const unsigned __int16 *Src)
{
  __int32 v2; // edi@1
  HKEY phkResult; // [sp+Ch] [bp-2BCh]@2
  HKEY hKey; // [sp+10h] [bp-2B8h]@1
  wchar_t DstBuf; // [sp+14h] [bp-2B4h]@2
  wchar_t Dst; // [sp+21Ch] [bp-ACh]@2
  __int16 v8; // [sp+268h] [bp-60h]@2
  char v9; // [sp+26Ah] [bp-5Eh]@2

  v2 = CComponent::HrOpenServiceKey(a2, 0xF003Fu, &hKey);
  if ( !v2 )
  {
    wcsncpy_s(&Dst, 0x53u, Src, 0x52u);
    v8 = 0;
    _snwprintf_s(&DstBuf, 0x104u, 0x103u, L"Parameters\\Adapters\\%s\\%s", &Dst, &v9);
    v2 = HrRegCreateKeyEx(hKey, &DstBuf, 0, 0xF003Fu, 0, &phkResult, 0);
    if ( !v2 )
      RegSafeCloseKey(phkResult);
    RegSafeCloseKey(hKey);
  }
  return v2;
}

//----- (6E67443D) --------------------------------------------------------
int __thiscall CFilteredAdapters::HrAttachOrDetach(CFilteredAdapters *this, struct CFilterMapEntry *a2, unsigned int a3)
{
  CFilteredAdapters *v3; // ebx@1
  const WCHAR *SourceString; // ST24_4@1
  wchar_t Format; // [sp+14h] [bp-1Ch]@1

  v3 = this;
  qmemcpy(&Format, L"\\Device\\%s", 0x16u);
  StringFromGUID2((const GUID *const )((char *)a2 + 4), (LPOLESTR)this + 140, 39);
  SourceString = (const WCHAR *)((char *)v3 + 36);
  _snwprintf_s((wchar_t *)v3 + 18, 0x53u, 0x52u, &Format, (char *)v3 + 280);
  v3 = (CFilteredAdapters *)((char *)v3 + 202);
  StringFromGUID2(*(const GUID *const *)a2, (LPOLESTR)v3, 39);
  return HrNdisAttachOrDetach(a3, (PCWSTR)v3, SourceString);
}
// 6E6744C4: using guessed type wchar_t aDeviceS[11];

//----- (6E6744DF) --------------------------------------------------------
int __stdcall HrNdisAttachOrDetach(unsigned int a1, PCWSTR a2, PCWSTR SourceString)
{
  SP_LOG_TOKEN v3; // kr00_8@1
  int v4; // eax@1
  int v5; // esi@4
  int v6; // eax@4
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-24h]@3
  LSA_UNICODE_STRING v9; // [sp+14h] [bp-1Ch]@3
  int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@3

  v10 = 0;
  v3 = SetupGetThreadLogToken();
  v4 = (int)"ATTACH";
  if ( a1 != 10 )
    v4 = (int)"DETACH";
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   PnP Event: %s %S - %S\n", v4, a2, SourceString);
  RtlInitUnicodeString(&DestinationString, SourceString);
  RtlInitUnicodeString(&v9, a2);
  v11 = 0;
  if ( !NdisHandlePnPEvent(1, a1, (int)&DestinationString, (int)&v9, 0, 0, 0) )
  {
    v5 = GetLastError();
    v6 = (int)L"ATTACH";
    if ( a1 != 10 )
      v6 = (int)L"DETACH";
    _SetupWriteTextLog(
      v3,
      0x40000000u,
      2u,
      "!NCI: Op=%ws, Layer=NDIS, Upper=%ws Lower=%ws, Error=%08x",
      v6,
      a2,
      SourceString,
      v5);
    if ( v5 != 2 )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      ^^^ Error = %d\n", v5);
      if ( v5 > 0 )
        v5 = (unsigned __int16)v5 | 0x80070000;
      v10 = v5;
    }
  }
  return v10;
}
// 6E674614: using guessed type wchar_t aDetach[7];
// 6E674624: using guessed type wchar_t aAttach[7];

//----- (6E6745CB) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E6745CB@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147418113;
  return &loc_6E6745C0;
}

//----- (6E674664) --------------------------------------------------------
unsigned int __stdcall HrPnpUnloadDriver(unsigned int a1, PCWSTR SourceString)
{
  unsigned int v2; // edi@1
  DWORD v3; // eax@2
  unsigned int v4; // esi@2
  LSA_UNICODE_STRING DestinationString; // [sp+Ch] [bp-28h]@1
  LSA_UNICODE_STRING v7; // [sp+14h] [bp-20h]@1
  LSA_UNICODE_STRING v8; // [sp+1Ch] [bp-18h]@1
  int v9; // [sp+30h] [bp-4h]@1

  v2 = 0;
  CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "   PnP Event: UNLOAD %S\n", SourceString);
  RtlInitUnicodeString(&DestinationString, 0);
  RtlInitUnicodeString(&v7, SourceString);
  RtlInitUnicodeString(&v8, 0);
  v9 = 0;
  if ( !NdisHandlePnPEvent(a1, 5, (int)&DestinationString, (int)&v7, (int)&v8, 0, 0) )
  {
    v3 = GetLastError();
    v4 = v3;
    if ( v3 == 31 )
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      %S does not support UNLOAD. (Okay)\n", SourceString);
    }
    else
    {
      CDiagContext::Printf((DWORD)g_pDiagCtx, 3, "      ^^^ Error = %d\n", v3);
      if ( (signed int)v4 > 0 )
        v4 = (unsigned __int16)v4 | 0x80070000;
      v2 = v4;
    }
  }
  return v2;
}

//----- (6E67477E) --------------------------------------------------------
__int32 __thiscall CPszArray::HrAddPointer(CPszArray *this, const unsigned __int16 *a2)
{
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back((int)this, (int)&a2);
  return 0;
}

//----- (6E6747A6) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E6747A6@<eax>(int a1@<ebp>)
{
  *(_DWORD *)(a1 + 8) = -2147024882;
  return &loc_6E67479B;
}

//----- (6E6747B8) --------------------------------------------------------
signed int __thiscall CCounter::HrGrowBuffer(CCounter *this, unsigned int a2)
{
  CCounter *v2; // esi@1
  unsigned int v3; // ecx@1
  void *v4; // eax@6
  void *v5; // edi@6
  int v6; // eax@7
  signed int v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v2 = this;
  v3 = *((_DWORD *)this + 1);
  if ( v3 == 313 || a2 < v3 || a2 < 2 )
  {
    v8 = -2147024809;
  }
  else
  {
    if ( a2 > 0x139 )
      a2 = 313;
    v4 = MemAlloc(4 * a2);
    v5 = v4;
    if ( v4 )
    {
      memset(v4, 0, 4 * a2);
      v6 = *((_DWORD *)v2 + 1);
      if ( v6 )
      {
        memcpy(v5, *((const void **)v2 + 2), 4 * v6);
        MemFree(*((void **)v2 + 2));
      }
      else
      {
        *(_DWORD *)v5 = *(_DWORD *)v2;
      }
      *((_DWORD *)v2 + 2) = v5;
      *((_DWORD *)v2 + 1) = a2;
    }
    else
    {
      v8 = -2147024882;
    }
  }
  return v8;
}

//----- (6E674853) --------------------------------------------------------
int __thiscall CCounter::IGetLowestAvailableIndex(CCounter *this)
{
  int v1; // edx@1
  signed int v2; // edi@1
  int result; // eax@1
  signed int v4; // ebx@2
  int v5; // esi@3
  int v6; // edx@4
  unsigned int v7; // esi@9
  bool v8; // zf@16
  bool v9; // sf@16
  unsigned __int8 v10; // of@16
  signed int v11; // [sp+8h] [bp-4h]@1

  v1 = *((_DWORD *)this + 1);
  v11 = -1;
  v2 = 1;
  result = 0;
  if ( v1 )
  {
    v4 = 0;
    if ( v1 )
    {
      v5 = *((_DWORD *)this + 2);
      while ( 1 )
      {
        v6 = *(_DWORD *)v5;
        *(_DWORD *)this = *(_DWORD *)v5;
        if ( v6 != -1 )
          break;
        ++v4;
        v5 += 4;
        if ( (unsigned int)v4 >= *((_DWORD *)this + 1) )
          goto LABEL_8;
      }
      v11 = v4;
    }
  }
LABEL_8:
  if ( *(_DWORD *)this == -1 )
    goto LABEL_24;
  v7 = 0;
  while ( v2 & *(_DWORD *)this )
  {
    v2 *= 2;
    ++v7;
    if ( v7 >= 0x20 )
      return result;
  }
  *(_DWORD *)this |= v2;
  if ( v11 == -1 )
    result = v7;
  else
    result = v7 + 32 * v11;
  v10 = __OFSUB__(result, 9999);
  v8 = result == 9999;
  v9 = result - 9999 < 0;
  if ( (unsigned int)result <= 0x270F )
  {
    if ( v11 != -1 )
      *(_DWORD *)(*((_DWORD *)this + 2) + 4 * v11) = *(_DWORD *)this;
    v10 = __OFSUB__(result, 9999);
    v8 = result == 9999;
    v9 = result - 9999 < 0;
  }
  if ( !((unsigned __int8)(v9 ^ v10) | v8) )
LABEL_24:
    result = -1;
  return result;
}

//----- (6E6748DE) --------------------------------------------------------
void __thiscall CCounter::UnsetIndex(CCounter *this, unsigned int a2)
{
  CCounter *v2; // edx@1
  int v3; // edi@1
  unsigned int v4; // esi@1
  char v5; // cl@1
  int v6; // eax@4

  v2 = this;
  v3 = *((_DWORD *)this + 1);
  v4 = (a2 >> 5) + 1;
  v5 = a2 & 0x1F;
  if ( v3 )
    *(_DWORD *)v2 = *(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v4 - 4);
  if ( *(_DWORD *)v2 & (1 << v5) )
  {
    v6 = *(_DWORD *)v2 & ~(1 << v5);
    *(_DWORD *)v2 = v6;
    if ( v3 )
      *(_DWORD *)(*((_DWORD *)v2 + 2) + 4 * v4 - 4) = v6;
  }
}

//----- (6E67492C) --------------------------------------------------------
LONG __stdcall CompareTimeStamps(SYSTEMTIME *lpSystemTime, SYSTEMTIME *a2)
{
  LONG result; // eax@5
  struct _FILETIME FileTime; // [sp+4h] [bp-10h]@3
  FILETIME FileTime2; // [sp+Ch] [bp-8h]@4

  if ( lpSystemTime && a2 )
  {
    if ( SystemTimeToFileTime(lpSystemTime, &FileTime) && SystemTimeToFileTime(a2, &FileTime2) )
    {
      result = CompareFileTime(&FileTime, &FileTime2);
    }
    else
    {
      HrFromLastWin32Error();
      result = -1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E674987) --------------------------------------------------------
LONG __cdecl CompareMonitoringFilters(const void *a1, const void *a2)
{
  return CompareTimeStamps(*(SYSTEMTIME **)(*(_DWORD *)a1 + 76), *(SYSTEMTIME **)(*(_DWORD *)a2 + 76));
}

//----- (6E6749AA) --------------------------------------------------------
int __cdecl std::fill<CIndex *,CIndex>(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@2

  for ( result = a1; result != a2; *(_DWORD *)v4 = *(_DWORD *)(a3 + 12) )
  {
    *(_DWORD *)result = *(_DWORD *)a3;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(result + 8) = *(_DWORD *)(a3 + 8);
    v4 = result + 12;
    result += 16;
  }
  return result;
}

//----- (6E6749D3) --------------------------------------------------------
int __cdecl std::_Copy_backward_opt<CIndex *,CIndex *>(int a1, int a2, int a3)
{
  int i; // eax@1

  for ( i = a2; i != a1; *(_DWORD *)(a3 + 12) = *(_DWORD *)(i + 12) )
  {
    a3 -= 16;
    i -= 16;
    *(_DWORD *)a3 = *(_DWORD *)i;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(i + 4);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(i + 8);
  }
  return a3;
}

//----- (6E674A03) --------------------------------------------------------
signed int __thiscall CCounter::HrGetNewIndex(CCounter *this, unsigned int *a2)
{
  signed int v2; // edi@1
  CCounter *v3; // esi@1
  int v4; // ebx@2
  int v5; // eax@3
  unsigned int v6; // eax@4

  v2 = 0;
  v3 = this;
  if ( a2 )
  {
    v4 = CCounter::IGetLowestAvailableIndex(this);
    if ( v4 == -1 )
    {
      v5 = *((_DWORD *)v3 + 1);
      if ( v5 )
        v6 = 2 * v5;
      else
        v6 = 2;
      v2 = CCounter::HrGrowBuffer(v3, v6);
      if ( !v2 )
        v4 = CCounter::IGetLowestAvailableIndex(v3);
    }
    *a2 = v4;
  }
  else
  {
    v2 = -2147024809;
  }
  return v2;
}

//----- (6E674A5F) --------------------------------------------------------
int __cdecl std::copy_backward<CIndex *,CIndex *>(int a1, int a2, int a3)
{
  return std::_Copy_backward_opt<CIndex *,CIndex *>(a1, a2, a3);
}

//----- (6E674ACF) --------------------------------------------------------
int __thiscall std::bad_alloc::~bad_alloc(std::bad_alloc *this)
{
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return exception::~exception();
}
// 6E65C92C: using guessed type int (__thiscall *std::bad_alloc::`vftable')(void *lpMem, char);
// 6E676461: using guessed type int exception::~exception(void);

//----- (6E674AF8) --------------------------------------------------------
void *__thiscall std::bad_alloc::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::bad_alloc::~bad_alloc((std::bad_alloc *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E674B71) --------------------------------------------------------
void __thiscall __noreturn std::bad_alloc::_Doraise(std::bad_alloc *this)
{
  char v1; // [sp+0h] [bp-Ch]@1

  std::bad_alloc::bad_alloc((std::bad_alloc *)&v1, this);
  _CxxThrowException(&v1, &_TI2_AVbad_alloc_std__);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E6961E8: using guessed type int _TI2_AVbad_alloc_std__;

//----- (6E674B96) --------------------------------------------------------
int __thiscall std::out_of_range::~out_of_range(std::out_of_range *this)
{
  *(_DWORD *)this = &std::out_of_range::`vftable';
  return std::logic_error::~logic_error(this);
}
// 6E65C938: using guessed type int (__thiscall *std::out_of_range::`vftable')(void *lpMem, char);

//----- (6E674BBF) --------------------------------------------------------
void *__thiscall std::out_of_range::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  std::out_of_range::~out_of_range((std::out_of_range *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E674C39) --------------------------------------------------------
void __thiscall __noreturn std::out_of_range::_Doraise(std::out_of_range *this)
{
  char v1; // [sp+0h] [bp-28h]@1

  std::out_of_range::out_of_range((std::out_of_range *)&v1, this);
  _CxxThrowException(&v1, &_TI3_AVout_of_range_std__);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E696204: using guessed type int _TI3_AVout_of_range_std__;

//----- (6E674C91) --------------------------------------------------------
signed int sub_6E674C91()
{
  HMODULE v0; // eax@1
  HMODULE v1; // edi@1
  signed int result; // eax@2
  FARPROC v3; // eax@3
  int v4; // eax@4
  __int32 (__stdcall *v5)(volatile __int32 *, __int32, __int32); // eax@8
  volatile __int32 *v6; // esi@11
  volatile __int32 v7; // eax@11
  HANDLE v8; // eax@12
  __int32 v9; // edi@12
  HANDLE v10; // eax@14

  v0 = LoadLibraryA("kernel32.dll");
  v1 = v0;
  if ( !v0 )
    return 0;
  v3 = GetProcAddress(v0, "IsProcessorFeaturePresent");
  if ( v3 )
    v4 = ((int (__stdcall *)(signed int))v3)(12);
  else
    v4 = 0;
  if ( !v4 )
  {
    result = 1;
    __AtlThunkPool = (union _SLIST_HEADER *)1;
    return result;
  }
  __AtlInterlockedPopEntrySList = (struct _SINGLE_LIST_ENTRY *(__stdcall *)(union _SLIST_HEADER *))GetProcAddress(
                                                                                                     v1,
                                                                                                     "InterlockedPopEntrySList");
  __AtlInterlockedPushEntrySList = (struct _SINGLE_LIST_ENTRY *(__stdcall *)(union _SLIST_HEADER *, struct _SINGLE_LIST_ENTRY *))GetProcAddress(v1, "InterlockedPushEntrySList");
  v5 = (__int32 (__stdcall *)(volatile __int32 *, __int32, __int32))GetProcAddress(v1, "InterlockedCompareExchange");
  __AtlInterlockedCompareExchange = v5;
  if ( __AtlInterlockedPushEntrySList && __AtlInterlockedPopEntrySList && v5 )
  {
    v6 = (volatile __int32 *)&NtCurrentTeb()->ProcessEnvironmentBlock->AtlThunkSListPtr32;
    v7 = *v6;
    if ( *v6 )
    {
LABEL_16:
      __AtlThunkPool = (union _SLIST_HEADER *)v7;
      return 1;
    }
    v8 = GetProcessHeap();
    v9 = (__int32)HeapAlloc(v8, 0, 8u);
    if ( v9 )
    {
      *(_DWORD *)v9 = 0;
      *(_DWORD *)(v9 + 4) = 0;
      if ( __AtlInterlockedCompareExchange(v6, v9, 0) )
      {
        v10 = GetProcessHeap();
        HeapFree(v10, 0, (LPVOID)v9);
      }
      v7 = *v6;
      goto LABEL_16;
    }
  }
  return 0;
}
// 6E69BD14: using guessed type union _SLIST_HEADER *__AtlThunkPool;
// 6E69BD18: using guessed type struct _SINGLE_LIST_ENTRY *(__stdcall *__AtlInterlockedPushEntrySList)(union _SLIST_HEADER *, struct _SINGLE_LIST_ENTRY *);
// 6E69BD1C: using guessed type struct _SINGLE_LIST_ENTRY *(__stdcall *__AtlInterlockedPopEntrySList)(union _SLIST_HEADER *);
// 6E69BD20: using guessed type __int32 (__stdcall *__AtlInterlockedCompareExchange)(volatile __int32 *, __int32, __int32);

//----- (6E674DF6) --------------------------------------------------------
void __stdcall ATL::__FreeStdCallThunk(void *a1)
{
  __FreeStdCallThunk_cmn(a1);
}

//----- (6E674ECE) --------------------------------------------------------
char __fastcall std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::_Inside(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // esi@1
  int v4; // eax@1
  unsigned int v5; // edx@2
  char result; // al@8

  v3 = *(_DWORD *)(a1 + 24);
  v4 = a1 + 4;
  if ( v3 < 0x10 )
    v5 = a1 + 4;
  else
    v5 = *(_DWORD *)v4;
  if ( a3 < v5 )
    goto LABEL_12;
  if ( v3 >= 0x10 )
    v4 = *(_DWORD *)v4;
  if ( v4 + *(_DWORD *)(a1 + 20) <= a3 )
LABEL_12:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (6E675069) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Copy(int this, int a2, rsize_t MaxCount)
{
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // ecx@3
  void *v6; // ebx@6
  void *v7; // eax@8
  unsigned int v9; // [sp+10h] [bp-14h]@3

  v3 = this;
  v4 = a2 | 0xF;
  if ( (a2 | 0xFu) <= 0xFFFFFFFE )
  {
    v5 = *(_DWORD *)(this + 24);
    v9 = *(_DWORD *)(v3 + 24) >> 1;
    if ( v4 / 3u < v9 && v5 <= -2 - v9 )
      v4 = v5 + v9;
  }
  else
  {
    v4 = a2;
  }
  v6 = (void *)std::allocator<char>::allocate(v4 + 1);
  if ( MaxCount )
  {
    if ( *(_DWORD *)(v3 + 24) < 0x10u )
      v7 = (void *)(v3 + 4);
    else
      v7 = *(void **)(v3 + 4);
    std::_Traits_helper::copy_s<std::char_traits<char>>(v6, v4 + 1, v7, MaxCount);
  }
  std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Tidy(1, 0);
  *(_DWORD *)(v3 + 4) = v6;
  *(_DWORD *)(v3 + 24) = v4;
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(MaxCount);
}
// 6E674F8F: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Eos(_DWORD);
// 6E674FB5: using guessed type _DWORD __stdcall std::allocator<char>::allocate(_DWORD);

//----- (6E675133) --------------------------------------------------------
void __usercall __noreturn sub_6E675133(int a1@<ebp>)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 - 24);
  std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Tidy(1, 0);
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E67517D) --------------------------------------------------------
int std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::~basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>()
{
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::_Tidy(1, 0);
}

//----- (6E67518C) --------------------------------------------------------
exception *__thiscall std::logic_error::logic_error(exception *this, rsize_t a2)
{
  exception *v2; // esi@1

  v2 = this;
  exception::exception(this);
  *(_DWORD *)v2 = &std::logic_error::`vftable';
  std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>(a2);
  return v2;
}
// 6E65C06C: using guessed type int (__thiscall *std::logic_error::`vftable')(void *lpMem, char);
// 6E67514D: using guessed type _DWORD __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>(rsize_t MaxCount);

//----- (6E6751E8) --------------------------------------------------------
void __cdecl __noreturn std::_String_base::_Xlen()
{
  char v0; // [sp+Ch] [bp-50h]@2
  char v1; // [sp+34h] [bp-28h]@1
  int v2; // [sp+58h] [bp-4h]@1

  std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>("string too long");
  v2 = 0;
  std::length_error::length_error(&v1);
  _CxxThrowException(&v0, &_TI3_AVlength_error_std__);
}
// 6E6751C6: using guessed type _DWORD __stdcall std::length_error::length_error(_DWORD);
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E695648: using guessed type int _TI3_AVlength_error_std__;

//----- (6E675235) --------------------------------------------------------
void __cdecl __noreturn std::_String_base::_Xran()
{
  int (__thiscall **v0)(void *, char); // [sp+Ch] [bp-50h]@1
  char v1; // [sp+34h] [bp-28h]@1
  int v2; // [sp+58h] [bp-4h]@1

  std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>("invalid string position");
  v2 = 0;
  std::logic_error::logic_error((exception *)&v0, (rsize_t)&v1);
  v0 = &std::out_of_range::`vftable';
  _CxxThrowException(&v0, &_TI3_AVout_of_range_std__);
}
// 6E65C938: using guessed type int (__thiscall *std::out_of_range::`vftable')(void *lpMem, char);
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E696204: using guessed type int _TI3_AVout_of_range_std__;

//----- (6E675479) --------------------------------------------------------
int __thiscall std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::assign(rsize_t this, void *Src)
{
  return std::basic_string<char,std::char_traits<char>,std::allocator<char>,_STL70>::assign(
           this,
           Src,
           strlen((const char *)Src));
}

//----- (6E6754F2) --------------------------------------------------------
void __userpurge _JumpToContinuation(int a1@<ebx>, int a2@<ebp>, void *a3, struct EHRegistrationNode *a4)
{
  int v4; // et1@1
  void (__stdcall *v5)(_DWORD, _DWORD); // eax@1
  int v6; // ebx@1
  int v7; // ebp@1
  int v8; // et1@1

  *(_DWORD *)(a2 - 4) = *(_DWORD *)(a2 + 12) + 12;
  v4 = *(_DWORD *)a1;
  v5 = *(void (__stdcall **)(_DWORD, _DWORD))(a2 + 8);
  v6 = *(_DWORD *)(a2 + 12);
  v7 = *(_DWORD *)(a2 - 4);
  v8 = *(_DWORD *)(v6 - 4);
  v5(a3, a4);
}

//----- (6E675524) --------------------------------------------------------
void __stdcall _CallMemberFunction0(void *a1, void *a2)
{
  ((void (__thiscall *)(_DWORD))a2)(a1);
}

//----- (6E675538) --------------------------------------------------------
void __stdcall _CallMemberFunction1(void *a1, void *a2, void *a3)
{
  ((void (__thiscall *)(_DWORD, _DWORD))a2)(a1, a3);
}

//----- (6E67554F) --------------------------------------------------------
void __stdcall _CallMemberFunction2(void *a1, void *a2, void *a3, int a4)
{
  ((void (__thiscall *)(_DWORD, _DWORD, _DWORD))a2)(a1, a3, a4);
}

//----- (6E675569) --------------------------------------------------------
void __userpurge _UnwindNestedFrames(int a1@<edi>, int a2@<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  RtlUnwind(TargetFrame, &loc_6E675595, ExceptionRecord, 0);
  ExceptionRecord->ExceptionFlags &= 0xFFFFFFFD;
  *(_DWORD *)a2 = a1;
}

//----- (6E675638) --------------------------------------------------------
int __usercall _CallSETranslator@<eax>(int a1@<ebx>, struct EHExceptionRecord *a2, struct EHRegistrationNode *a3, void *a4, void *a5, const struct _s_FuncInfo *a6, int a7, struct EHRegistrationNode *a8)
{
  int result; // eax@2
  int v9; // [sp+0h] [bp-44h]@3
  int v10; // [sp+4h] [bp-40h]@3
  int v11; // [sp+8h] [bp-3Ch]@3
  struct EHExceptionRecord *v12; // [sp+Ch] [bp-38h]@3
  void *v13; // [sp+10h] [bp-34h]@3
  int v14; // [sp+14h] [bp-30h]@3
  int v15; // [sp+18h] [bp-2Ch]@3
  struct EHRegistrationNode *v16; // [sp+1Ch] [bp-28h]@3
  int (__usercall *v17)@<eax>(int@<ebp>, int@<edi>, int@<esi>, int@<ebx>); // [sp+20h] [bp-24h]@3
  unsigned int v18; // [sp+24h] [bp-20h]@3
  const struct _s_FuncInfo *v19; // [sp+28h] [bp-1Ch]@3
  struct EHRegistrationNode *v20; // [sp+2Ch] [bp-18h]@3
  int v21; // [sp+30h] [bp-14h]@3
  struct EHRegistrationNode *v22; // [sp+34h] [bp-10h]@3
  int *v23; // [sp+38h] [bp-Ch]@3
  int *v24; // [sp+3Ch] [bp-8h]@3
  int v25; // [sp+40h] [bp-4h]@3
  int savedregs; // [sp+44h] [bp+0h]@3

  if ( a2 == (struct EHExceptionRecord *)291 )
  {
    *(_DWORD *)a3 = &loc_6E6756FD;
    result = 1;
  }
  else
  {
    v17 = sub_6E67572E;
    v18 = (unsigned int)&v16 ^ __security_cookie;
    v19 = a6;
    v20 = a3;
    v21 = a7;
    v22 = a8;
    v25 = 0;
    v23 = &v9;
    v24 = &savedregs;
    v16 = a8;
    v11 = 1;
    v12 = a2;
    v13 = a4;
    v15 = 0;
    v15 = _getptd();
    v10 = v15;
    v14 = *(_DWORD *)(v15 + 128);
    ((void (__cdecl *)(_DWORD, struct EHExceptionRecord **))v14)(*(_DWORD *)a2, &v12);
    v11 = 0;
    if ( v25 )
      *(_DWORD *)v16 = *(_DWORD *)a1;
    result = v11;
  }
  return result;
}

//----- (6E67572E) --------------------------------------------------------
int __usercall sub_6E67572E@<eax>(int a1@<ebp>, int a2@<edi>, int a3@<esi>, int a4@<ebx>)
{
  int v4; // ecx@1
  int result; // eax@2
  int (*v6)(void); // eax@5
  int v7; // ebx@5
  int v8; // et1@5
  int v9; // ebp@5

  v4 = *(_DWORD *)(a1 + 12) ^ *(_DWORD *)(*(_DWORD *)(a1 + 12) + 8);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4) & 0x66 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 36) = 1;
    result = 1;
  }
  else
  {
    __InternalCxxFrameHandler(
      *(PEXCEPTION_RECORD *)(a1 + 8),
      *(struct EHRegistrationNode **)(*(_DWORD *)(a1 + 12) + 16),
      *(void **)(a1 + 16),
      0,
      *(struct _s_FuncInfo **)(*(_DWORD *)(a1 + 12) + 12),
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 20),
      *(PVOID *)(*(_DWORD *)(a1 + 12) + 24),
      1);
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 12) + 36) )
      _UnwindNestedFrames(a2, a3, *(PVOID *)(a1 + 12), *(PEXCEPTION_RECORD *)(a1 + 8));
    _CallSETranslator(a4, (struct EHExceptionRecord *)0x123, (struct EHRegistrationNode *)(a1 - 4), 0, 0, 0, 0, 0);
    v6 = *(int (**)(void))(a1 - 4);
    v7 = *(_DWORD *)(a1 + 12);
    v8 = *(_DWORD *)(v7 + 28);
    v9 = *(_DWORD *)(v7 + 32);
    result = v6();
  }
  return result;
}

//----- (6E675847) --------------------------------------------------------
int __cdecl _CreateFrameInfo(int a1, int a2)
{
  int v2; // eax@1

  *(_DWORD *)a1 = a2;
  v2 = _getptd() + 152;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)v2;
  *(_DWORD *)v2 = a1;
  return a1;
}

//----- (6E67589C) --------------------------------------------------------
int __cdecl _FindAndUnlinkFrame(int a1)
{
  int result; // eax@1

  result = _getptd() + 152;
  if ( a1 == *(_DWORD *)result )
  {
    *(_DWORD *)result = *(_DWORD *)(a1 + 4);
  }
  else
  {
    for ( result = *(_DWORD *)result; ; result = *(_DWORD *)(result + 4) )
    {
      if ( !*(_DWORD *)(result + 4) )
        _inconsistency();
      if ( a1 == *(_DWORD *)(result + 4) )
        break;
    }
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
  }
  return result;
}

//----- (6E6759C5) --------------------------------------------------------
BOOL __thiscall type_info::operator==(int this, int a2)
{
  return strcmp((const char *)(a2 + 9), (const char *)(this + 9)) == 0;
}

//----- (6E675A08) --------------------------------------------------------
void _purecall()
{
  RaiseException(0xC0000002, 1u, 0, 0);
}

//----- (6E675A1F) --------------------------------------------------------
int __cdecl _except_handler4(int a1, PVOID TargetFrame, int a3)
{
  unsigned int v3; // ebx@1
  uintptr_t v4; // esi@1
  int v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  int v8; // ecx@3
  void *v9; // ecx@5
  int v10; // eax@5
  int v11; // eax@5
  int v12; // eax@6
  int v13; // ecx@12
  int v14; // ecx@13
  PVOID v16; // eax@20
  int v17; // ecx@23
  int v18; // ecx@24
  int v19; // [sp+Ch] [bp-18h]@4
  int v20; // [sp+10h] [bp-14h]@4
  int v21; // [sp+14h] [bp-10h]@5
  int v22; // [sp+18h] [bp-Ch]@1
  int v23; // [sp+1Ch] [bp-8h]@5
  char v24; // [sp+23h] [bp-1h]@1

  v3 = (unsigned int)TargetFrame;
  v4 = __security_cookie ^ *((_DWORD *)TargetFrame + 2);
  v5 = *(_DWORD *)v4;
  v24 = 0;
  v22 = 1;
  v6 = (int)((char *)TargetFrame + 16);
  if ( v5 != -2 )
    v7 = *(_DWORD *)(v5 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
  if ( *(_BYTE *)(a1 + 4) & 0x66 )
  {
LABEL_25:
    if ( *(_DWORD *)(v3 + 12) == -2 )
      return v22;
    _EH4_LocalUnwind(v3, 0xFFFFFFFE, v6, (int)&__security_cookie);
  }
  else
  {
    *((_DWORD *)TargetFrame - 1) = &v19;
    v3 = *((_DWORD *)TargetFrame + 3);
    v19 = a1;
    v20 = a3;
    if ( v3 == -2 )
      return v22;
    do
    {
      v9 = *(void **)(v4 + 12 * v3 + 20);
      v10 = v4 + 12 * v3 + 16;
      v21 = v10;
      v11 = *(_DWORD *)v10;
      v23 = v11;
      if ( v9 )
      {
        v12 = _EH4_CallFilterFunc(v9);
        v24 = 1;
        if ( v12 < 0 )
        {
          v22 = 0;
          goto LABEL_11;
        }
        if ( v12 > 0 )
        {
          if ( *(_DWORD *)a1 == -529697949
            && _pDestructExceptionObject
            && _IsNonwritableInCurrentImage((int)&_pDestructExceptionObject) )
            _pDestructExceptionObject(a1, 1);
          _EH4_GlobalUnwind(TargetFrame);
          v16 = TargetFrame;
          if ( *((_DWORD *)TargetFrame + 3) != v3 )
          {
            _EH4_LocalUnwind((int)TargetFrame, v3, v6, (int)&__security_cookie);
            v16 = TargetFrame;
          }
          *((_DWORD *)v16 + 3) = v23;
          if ( *(_DWORD *)v4 != -2 )
            v17 = *(_DWORD *)(*(_DWORD *)v4 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
          v18 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
          _EH4_TransferToHandler(*(void **)(v21 + 8));
          goto LABEL_25;
        }
        v11 = v23;
      }
      v3 = v11;
    }
    while ( v11 != -2 );
    if ( !v24 )
      return v22;
  }
LABEL_11:
  if ( *(_DWORD *)v4 != -2 )
    v13 = *(_DWORD *)(*(_DWORD *)v4 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
  v14 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
  return v22;
}
// 6E675BAC: using guessed type int (__cdecl *_pDestructExceptionObject)(_DWORD, _DWORD);

//----- (6E676035) --------------------------------------------------------
int __cdecl _getch_nolock()
{
  int result; // eax@2
  int v1; // edi@11
  int v2; // eax@12
  struct _INPUT_RECORD Buffer; // [sp+4h] [bp-1Ch]@9
  DWORD NumberOfEventsRead; // [sp+18h] [bp-8h]@8
  DWORD Mode; // [sp+1Ch] [bp-4h]@1

  Mode = 0;
  if ( dword_6E69B4A4 == -1 )
  {
    if ( _coninpfh == (HANDLE)-2 )
      __initconin();
    if ( _coninpfh == (HANDLE)-1 )
    {
      result = -1;
    }
    else
    {
      GetConsoleMode(_coninpfh, &Mode);
      SetConsoleMode(_coninpfh, 0);
      while ( 1 )
      {
        if ( !ReadConsoleInputA(_coninpfh, &Buffer, 1u, &NumberOfEventsRead) || !NumberOfEventsRead )
        {
          v1 = -1;
          goto LABEL_15;
        }
        if ( Buffer.EventType == 1 && Buffer.Event.KeyEvent.bKeyDown )
        {
          v1 = *((unsigned __int8 *)&Buffer.Event.FocusEvent + 10);
          if ( Buffer.Event.KeyEvent.uChar.AsciiChar )
            goto LABEL_15;
          v2 = _getextendedkeycode(&Buffer.Event);
          if ( v2 )
            break;
        }
      }
      v1 = *(_BYTE *)v2;
      dword_6E69B4A4 = *(_BYTE *)(v2 + 1);
LABEL_15:
      if ( Mode )
        SetConsoleMode(_coninpfh, Mode);
      result = v1;
    }
  }
  else
  {
    result = (unsigned __int8)dword_6E69B4A4;
    dword_6E69B4A4 = -1;
  }
  return result;
}
// 6E675C37: using guessed type _DWORD __cdecl _getextendedkeycode(_DWORD);
// 6E678FB2: using guessed type int __initconin(void);
// 6E69B4A4: using guessed type int dword_6E69B4A4;

//----- (6E676238) --------------------------------------------------------
int __cdecl _getch()
{
  int v0; // ST18_4@1

  _lock(3);
  v0 = _getch_nolock();
  _unlock(3);
  return v0;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (6E6762A1) --------------------------------------------------------
int __cdecl _kbhit()
{
  int v0; // ST04_4@1
  int v1; // ST18_4@1

  _lock(3);
  v1 = _kbhit_nolock(v0);
  _unlock(3);
  return v1;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E676109: using guessed type int __thiscall _kbhit_nolock(_DWORD);

//----- (6E676393) --------------------------------------------------------
int __thiscall exception::exception(int this, const char **a2)
{
  int v2; // esi@1
  unsigned int v3; // kr00_4@2
  char *v4; // eax@2

  v2 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)this = &exception::`vftable';
  if ( *a2 )
  {
    v3 = strlen(*a2);
    v4 = (char *)malloc(v3 + 1);
    *(_DWORD *)(v2 + 4) = v4;
    if ( v4 )
    {
      strcpy_s(v4, v3 + 1, *a2);
      *(_DWORD *)(v2 + 8) = 1;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = 0;
  }
  return v2;
}
// 6E65C944: using guessed type int (__thiscall *exception::`vftable')(void *lpMem, char);

//----- (6E6763F4) --------------------------------------------------------
int __thiscall exception::exception(int this, int a2)
{
  int v2; // esi@1
  const char *v3; // eax@1
  unsigned int v4; // kr00_4@3
  char *v5; // eax@3

  v2 = this;
  *(_DWORD *)this = &exception::`vftable';
  *(_DWORD *)(this + 8) = 0;
  v3 = *(const char **)(a2 + 4);
  if ( *(_DWORD *)(a2 + 8) )
  {
    if ( v3 )
    {
      v4 = strlen(v3);
      v5 = (char *)malloc(v4 + 1);
      *(_DWORD *)(v2 + 4) = v5;
      if ( v5 )
      {
        strcpy_s(v5, v4 + 1, *(const char **)(a2 + 4));
        *(_DWORD *)(v2 + 8) = 1;
      }
    }
    else
    {
      *(_DWORD *)(this + 4) = 0;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = v3;
  }
  return v2;
}
// 6E65C944: using guessed type int (__thiscall *exception::`vftable')(void *lpMem, char);

//----- (6E6764A3) --------------------------------------------------------
void *__thiscall exception::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  exception::~exception();
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}
// 6E676461: using guessed type int exception::~exception(void);

//----- (6E6765DF) --------------------------------------------------------
int fprintf(FILE *File, const char *Format, ...)
{
  int result; // eax@2
  int *v3; // edi@7
  int v4; // eax@7
  int *v5; // edi@12
  int v6; // eax@12
  int v7; // edi@17
  int v8; // [sp+10h] [bp-1Ch]@1
  va_list va; // [sp+3Ch] [bp+10h]@1

  va_start(va, Format);
  v8 = 0;
  if ( File == 0 || Format == 0 )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  else
  {
    _lock_file(File);
    if ( !(File->_flag & 0x40) )
    {
      if ( _fileno(File) == -1 || _fileno(File) == -2 )
      {
        v4 = (int)__badioinfo;
      }
      else
      {
        v3 = &__pioinfo[_fileno(File) >> 5];
        v4 = *v3 + 36 * (_fileno(File) & 0x1F);
      }
      if ( *(_BYTE *)(v4 + 8) & 3
        || (_fileno(File) == -1 || _fileno(File) == -2 ? (v6 = (int)__badioinfo) : (v5 = &__pioinfo[_fileno(File) >> 5],
                                                                                    v6 = *v5
                                                                                       + 36 * (_fileno(File) & 0x1F)),
            *(_BYTE *)(v6 + 8) & 8) )
      {
        *_errno() = 22;
        _invalid_parameter(0, 0, 0, 0, 0);
        v8 = -1;
      }
    }
    if ( !v8 )
    {
      v7 = _stbuf(File);
      v8 = _output_l(File, (int)Format, 0, (int)va);
      _ftbuf(v7, File);
    }
    _unlock_file(File);
    result = v8;
  }
  return result;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69B624: using guessed type int __badioinfo[9];

//----- (6E676A23) --------------------------------------------------------
int __cdecl wcstolX(int a1, int a2, int a3, int a4)
{
  int result; // eax@2

  if ( __locale_changed )
    result = sub_6E64E9CD(0, a1, a2, a3, 0, a4);
  else
    result = sub_6E64E9CD((struct localeinfo_struct *)&__initiallocalestructinfo, a1, a2, a3, 0, a4);
  return result;
}
// 6E699490: using guessed type int (*__initiallocalestructinfo)[22];
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E676A56) --------------------------------------------------------
unsigned __int32 __cdecl wcstoul(const wchar_t *Str, wchar_t **EndPtr, int Radix)
{
  unsigned __int32 result; // eax@2

  if ( __locale_changed )
    result = sub_6E64E9A8(0, (int)Str, (int)EndPtr, Radix, 1);
  else
    result = sub_6E64E9A8((struct localeinfo_struct *)&__initiallocalestructinfo, (int)Str, (int)EndPtr, Radix, 1);
  return result;
}
// 6E699490: using guessed type int (*__initiallocalestructinfo)[22];
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E676D39) --------------------------------------------------------
void __stdcall `eh vector destructor iterator'(void *a1, unsigned int a2, int a3, void (__thiscall *a4)(void *))
{
  char *i; // [sp+34h] [bp+8h]@1

  for ( i = (char *)a1 + a3 * a2; ; a4(i) )
  {
    --a3;
    if ( a3 < 0 )
      break;
    i -= a2;
  }
}

//----- (6E676DC9) --------------------------------------------------------
void __stdcall `eh vector constructor iterator'(void *a1, unsigned int a2, int a3, int a4, void (__thiscall *a5)(void *))
{
  int i; // [sp+14h] [bp-1Ch]@1

  for ( i = 0; i < a3; ++i )
  {
    ((void (__thiscall *)(void *))a4)(a1);
    a1 = (char *)a1 + a2;
  }
}

//----- (6E676E59) --------------------------------------------------------
__int32 __cdecl _wtol(const wchar_t *Str)
{
  __int32 result; // eax@2

  if ( Str )
    result = wcstolX((int)Str, 0, 10, 1);
  else
    result = 0;
  return result;
}

//----- (6E676E80) --------------------------------------------------------
int __cdecl _wtoi(const wchar_t *Str)
{
  return _wtol(Str);
}

//----- (6E677155) --------------------------------------------------------
DWORD __stdcall __crtTlsAlloc(int a1)
{
  return TlsAlloc();
}

//----- (6E677275) --------------------------------------------------------
int __cdecl __TypeMatch(int a1, int a2, int a3)
{
  int v3; // edx@1
  int v4; // eax@3
  int result; // eax@5
  int v6; // eax@8

  v3 = *(_DWORD *)(a1 + 4);
  result = 1;
  if ( v3 && *(_BYTE *)(v3 + 8) )
  {
    if ( (v4 = *(_DWORD *)(a2 + 4), v3 != v4) && strcmp((const char *)(v3 + 8), (const char *)(v4 + 8))
      || *(_BYTE *)a2 & 2 && !(*(_BYTE *)a1 & 8)
      || (v6 = *(_DWORD *)a3, *(_DWORD *)a3 & 1) && !(*(_BYTE *)a1 & 1)
      || v6 & 2 && !(*(_BYTE *)a1 & 2) )
      result = 0;
  }
  return result;
}

//----- (6E6772F3) --------------------------------------------------------
int __cdecl __FrameUnwindFilter(int a1)
{
  int v1; // eax@1
  int v2; // eax@4

  v1 = **(_DWORD **)a1;
  if ( v1 == -532459699 )
  {
    v2 = _getptd() + 144;
    if ( *(_DWORD *)v2 > 0 )
      --*(_DWORD *)v2;
  }
  else if ( v1 == -529697949 )
  {
    *(_DWORD *)(_getptd() + 144) = 0;
    terminate();
  }
  return 0;
}

//----- (6E677338) --------------------------------------------------------
int __cdecl __FrameUnwindToState(int a1, int a2, int a3, int a4)
{
  signed int v4; // esi@2
  int v5; // eax@9
  int v6; // ecx@9
  int result; // eax@18
  int v8; // [sp+14h] [bp-20h]@4

  if ( *(_DWORD *)(a3 + 4) > 128 )
    v4 = *(_DWORD *)(a1 + 8);
  else
    v4 = *(_BYTE *)(a1 + 8);
  v8 = _getptd();
  ++*(_DWORD *)(v8 + 144);
  while ( v4 != a4 )
  {
    if ( v4 <= -1 || v4 >= *(_DWORD *)(a3 + 4) )
      _inconsistency();
    v5 = 8 * v4;
    v6 = 8 * v4 + *(_DWORD *)(a3 + 8);
    v4 = *(_DWORD *)v6;
    if ( *(_DWORD *)(v6 + 4) )
    {
      *(_DWORD *)(a1 + 8) = v4;
      _CallSettingFrame(*(_DWORD *)(*(_DWORD *)(a3 + 8) + v5 + 4), a1, 259);
    }
  }
  if ( !v8 )
    v8 = _getptd();
  result = v8 + 144;
  if ( *(_DWORD *)(v8 + 144) > 0 )
    --*(_DWORD *)result;
  if ( v4 != a4 )
    _inconsistency();
  *(_DWORD *)(a1 + 8) = v4;
  return result;
}
// 6E655A35: using guessed type _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD);

//----- (6E677547) --------------------------------------------------------
char __usercall sub_6E677547@<al>(int a1@<esi>, int a2)
{
  int v2; // edx@1
  int v3; // eax@4
  int v4; // edi@7
  int v5; // ebx@7
  int v7; // [sp+0h] [bp-1Ch]@4
  int v8; // [sp+4h] [bp-18h]@4
  int v9; // [sp+8h] [bp-14h]@4
  int v10; // [sp+Ch] [bp-10h]@4
  int v11; // [sp+10h] [bp-Ch]@6
  int *v12; // [sp+14h] [bp-8h]@6
  char v13; // [sp+1Bh] [bp-1h]@3

  v2 = a2;
  if ( !a2 )
    _inconsistency();
  v13 = 0;
  if ( *(_DWORD *)a2 > 0 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 12);
    v10 = 0;
    v8 = v3 + 4;
    v7 = *(_DWORD *)v3;
    v9 = *(_DWORD *)a2;
    while ( 1 )
    {
      v12 = (int *)v8;
      v11 = v7;
      if ( v7 > 0 )
      {
        v4 = *(_DWORD *)(a1 + 28);
        v5 = *(_DWORD *)(v2 + 4) + v10;
        while ( !__TypeMatch(v5, *v12, v4) )
        {
          --v11;
          ++v12;
          if ( v11 <= 0 )
            goto LABEL_12;
        }
        v13 = 1;
      }
LABEL_12:
      v10 += 16;
      --v9;
      if ( !v9 )
        break;
      v2 = a2;
    }
  }
  return v13;
}

//----- (6E6775E1) --------------------------------------------------------
void __noreturn sub_6E6775E1()
{
  if ( *(_DWORD *)(_getptd() + 148) )
    _inconsistency();
  unexpected();
}

//----- (6E67763B) --------------------------------------------------------
void __thiscall __noreturn std::bad_exception::_Doraise(std::bad_exception *this)
{
  char v1; // [sp+0h] [bp-Ch]@1

  std::bad_exception::bad_exception((std::bad_exception *)&v1, this);
  _CxxThrowException(&v1, &_TI2_AVbad_exception_std__);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E6962C0: using guessed type int _TI2_AVbad_exception_std__;

//----- (6E677660) --------------------------------------------------------
void *__cdecl sub_6E677660(int a1, struct EHRegistrationNode *a2, int a3, struct _s_FuncInfo *a4, void *a5, int a6, unsigned __int32 a7)
{
  int v7; // esi@1
  int v9; // eax@5
  char v10; // [sp+10h] [bp-40h]@1
  int v11; // [sp+18h] [bp-38h]@1
  int v12; // [sp+1Ch] [bp-34h]@1
  int v13; // [sp+20h] [bp-30h]@1
  int v14; // [sp+24h] [bp-2Ch]@1
  int v15; // [sp+28h] [bp-28h]@1
  void *v16; // [sp+2Ch] [bp-24h]@1
  int v17; // [sp+30h] [bp-20h]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v16 = a5;
  v11 = 0;
  v15 = *((_DWORD *)a2 - 1);
  v14 = _CreateFrameInfo((int)&v10, *(_DWORD *)(a1 + 24));
  v7 = _getptd();
  v17 = v7;
  v13 = *(_DWORD *)(v7 + 136);
  v12 = *(_DWORD *)(v7 + 140);
  *(_DWORD *)(v7 + 136) = a1;
  *(_DWORD *)(v7 + 140) = a3;
  ms_exc.registration.TryLevel = 1;
  v16 = _CallCatchBlock2(a2, a4, a5, a6, a7);
  ms_exc.registration.TryLevel = -2;
  *((_DWORD *)a2 - 1) = v15;
  _FindAndUnlinkFrame(v14);
  if ( !v7 )
  {
    v7 = _getptd();
    v17 = v7;
  }
  *(_DWORD *)(v7 + 136) = v13;
  *(_DWORD *)(v7 + 140) = v12;
  if ( *(_DWORD *)a1 == -529697949 && *(_DWORD *)(a1 + 16) == 3 )
  {
    v9 = *(_DWORD *)(a1 + 20);
    if ( (v9 == 429065504 || v9 == 429065505 || v9 == 429065506)
      && !v11
      && v16
      && _IsExceptionObjectToBeDestroyed(*(_DWORD *)(a1 + 24)) )
      __DestructExceptionObject(a1, 0);
  }
  return v16;
}
// 6E675870: using guessed type _DWORD __cdecl _IsExceptionObjectToBeDestroyed(_DWORD);
// 6E67749F: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);

//----- (6E677B14) --------------------------------------------------------
void __usercall sub_6E677B14(int a1@<ebx>, int a2@<edi>, struct EHExceptionRecord *a3, struct EHRegistrationNode *a4, void *a5, void *a6, struct _s_FuncInfo *a7, int a8, int a9, struct EHRegistrationNode *a10)
{
  int v10; // edi@2
  int v11; // esi@8
  const struct _s_TryBlockMapEntry *v12; // edi@8
  int v13; // eax@12
  int v14; // ecx@12
  int v15; // [sp-8h] [bp-14h]@9
  int v16; // [sp-4h] [bp-10h]@2
  struct EHRegistrationNode *v17; // [sp+0h] [bp-Ch]@0
  unsigned int v18; // [sp+4h] [bp-8h]@8
  unsigned int v19; // [sp+8h] [bp-4h]@8

  if ( *(_DWORD *)a3 != -2147483645 )
  {
    v16 = a2;
    v10 = _getptd() + 128;
    if ( !*(_DWORD *)v10
      || *(_DWORD *)v10 == _encoded_null()
      || *(_DWORD *)a3 == -532459699
      || !_CallSETranslator(a1, a3, a4, a5, a6, a7, a9, a10) )
    {
      if ( !*((_DWORD *)a7 + 3) )
        _inconsistency();
      v11 = a8;
      v12 = _GetRangeOfTrysToCheck(a7, a9, a8, &v19, &v18);
      if ( v19 < v18 )
      {
        v15 = a1;
        do
        {
          if ( v11 >= *(_DWORD *)v12 && v11 <= *((_DWORD *)v12 + 1) )
          {
            v13 = *((_DWORD *)v12 + 4) + 16 * *((_DWORD *)v12 + 3);
            v14 = *(_DWORD *)(v13 - 12);
            if ( (!v14 || !*(_BYTE *)(v14 + 8)) && !(*(_BYTE *)(v13 - 16) & 0x40) )
            {
              CatchIt(
                a3,
                (struct EHRegistrationNode *)a5,
                (struct _CONTEXT *)a6,
                (void *)a7,
                0,
                (const struct _s_HandlerType *)a9,
                a10,
                (const struct _s_TryBlockMapEntry *)v15,
                v16,
                v17,
                v18);
              v11 = a8;
            }
          }
          ++v19;
          v12 = (const struct _s_TryBlockMapEntry *)((char *)v12 + 20);
        }
        while ( v19 < v18 );
      }
    }
  }
}
// 6E677B14: could not find valid save-restore pair for edi
// 6E648CDF: using guessed type int _encoded_null(void);
// 6E677AA1: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);

//----- (6E677C04) --------------------------------------------------------
int __usercall sub_6E677C04@<eax>(int a1@<ebx>, PEXCEPTION_RECORD ExceptionRecord, struct EHRegistrationNode *a3, void *a4, void *a5, struct _s_FuncInfo *a6, char a7, int a8, PVOID TargetFrame)
{
  int v9; // edi@1
  signed int v10; // eax@1
  int v11; // ecx@2
  int v12; // esi@7
  ULONG_PTR v13; // eax@9
  int result; // eax@13
  int v15; // edi@13
  int v16; // eax@18
  int v17; // eax@23
  int v18; // edi@23
  int v19; // ebx@25
  int i; // esi@25
  int v21; // eax@34
  const struct _s_TryBlockMapEntry *v22; // edi@38
  int *v23; // eax@43
  int v24; // ecx@43
  int v25; // eax@43
  int v26; // ebx@45
  int v27; // eax@62
  int v28; // ST1C_4@66
  const struct _s_TryBlockMapEntry *v29; // [sp+0h] [bp-44h]@0
  int v30; // [sp+4h] [bp-40h]@0
  struct EHRegistrationNode *v31; // [sp+8h] [bp-3Ch]@0
  unsigned __int8 v32; // [sp+Ch] [bp-38h]@29
  int v33; // [sp+18h] [bp-2Ch]@43
  int *v34; // [sp+1Ch] [bp-28h]@43
  unsigned int v35; // [sp+20h] [bp-24h]@38
  int v36; // [sp+24h] [bp-20h]@42
  int v37; // [sp+28h] [bp-1Ch]@44
  int *v38; // [sp+2Ch] [bp-18h]@44
  unsigned int v39; // [sp+30h] [bp-14h]@38
  int v40; // [sp+34h] [bp-10h]@42
  int v41; // [sp+38h] [bp-Ch]@4
  int v42; // [sp+3Ch] [bp-8h]@1
  char v43; // [sp+43h] [bp-1h]@1

  v42 = 0;
  v9 = (int)a6;
  v10 = *((_DWORD *)a6 + 1);
  v43 = 0;
  if ( v10 > 128 )
    v11 = *((_DWORD *)a3 + 2);
  else
    v11 = *((_BYTE *)a3 + 8);
  v41 = v11;
  if ( v11 < -1 || v11 >= v10 )
    _inconsistency();
  v12 = (int)ExceptionRecord;
  if ( ExceptionRecord->ExceptionCode != -529697949 )
    goto LABEL_76;
  a1 = 429065504;
  if ( ExceptionRecord->NumberParameters == 3 )
  {
    v13 = ExceptionRecord->ExceptionInformation[0];
    if ( (v13 == 429065504 || v13 == 429065505 || v13 == 429065506) && !ExceptionRecord->ExceptionInformation[2] )
    {
      result = _getptd();
      v15 = result;
      v12 = *(_DWORD *)(result + 136);
      v42 = result;
      if ( !v12 )
        return result;
      ExceptionRecord = (PEXCEPTION_RECORD)v12;
      a4 = *(void **)(result + 140);
      if ( !_ValidateRead((const void *)v12, 1u) )
        _inconsistency();
      if ( *(_DWORD *)v12 == -529697949 && *(_DWORD *)(v12 + 16) == 3 )
      {
        v16 = *(_DWORD *)(v12 + 20);
        if ( (v16 == 429065504 || v16 == 429065505 || v16 == 429065506) && !*(_DWORD *)(v12 + 28) )
          _inconsistency();
      }
      v17 = v15 + 148;
      v18 = *(_DWORD *)(v15 + 148);
      if ( v18 )
      {
        *(_DWORD *)v17 = 0;
        if ( !sub_6E677547(v12, v18) )
        {
          v19 = 0;
          for ( i = 0; i < *(_DWORD *)v18; v19 += 16 )
          {
            if ( type_info::operator==(
                   *(_DWORD *)(*(_DWORD *)(v18 + 4) + v19 + 4),
                   (int)&std::bad_exception `RTTI Type Descriptor') )
            {
              __DestructExceptionObject(ExceptionRecord, 1);
              std::bad_exception::bad_exception((std::bad_exception *)&v32, "bad exception");
              _CxxThrowException(&v32, &_TI2_AVbad_exception_std__);
            }
            ++i;
          }
LABEL_28:
          terminate();
        }
      }
      v9 = (int)a6;
    }
  }
  if ( *(_DWORD *)v12 != -529697949
    || *(_DWORD *)(v12 + 16) != 3
    || (v21 = *(_DWORD *)(v12 + 20), v21 != 429065504) && v21 != 429065505 && v21 != 429065506 )
  {
LABEL_76:
    if ( *(_DWORD *)(v9 + 12) )
    {
      if ( a7 )
        goto LABEL_28;
      sub_6E677B14(
        a1,
        v9,
        (struct EHExceptionRecord *)v12,
        a3,
        a4,
        a5,
        (struct _s_FuncInfo *)v9,
        v41,
        a8,
        (struct EHRegistrationNode *)TargetFrame);
    }
  }
  else
  {
    if ( *(_DWORD *)(v9 + 12) )
    {
      v22 = _GetRangeOfTrysToCheck((const struct _s_FuncInfo *)v9, a8, v41, &v39, &v35);
      while ( v39 < v35 )
      {
        if ( *(_DWORD *)v22 <= v41 && v41 <= *((_DWORD *)v22 + 1) )
        {
          v40 = *((_DWORD *)v22 + 4);
          v36 = *((_DWORD *)v22 + 3);
          if ( v36 > 0 )
          {
            v23 = *(int **)(*(_DWORD *)(v12 + 28) + 12);
            v24 = (int)(v23 + 1);
            v25 = *v23;
            v34 = (int *)v24;
            v33 = v25;
            while ( 1 )
            {
              v38 = v34;
              v37 = v33;
              if ( v33 > 0 )
                break;
LABEL_47:
              --v36;
              v40 += 16;
              if ( v36 <= 0 )
                goto LABEL_50;
            }
            while ( 1 )
            {
              v26 = *v38;
              if ( __TypeMatch(v40, *v38, *(_DWORD *)(v12 + 28)) )
                break;
              --v37;
              ++v38;
              if ( v37 <= 0 )
                goto LABEL_47;
            }
            v43 = 1;
            CatchIt(
              (struct EHExceptionRecord *)v12,
              (struct EHRegistrationNode *)a4,
              (struct _CONTEXT *)a5,
              (void *)a6,
              (const struct _s_FuncInfo *)v26,
              (const struct _s_HandlerType *)a8,
              (const struct _s_CatchableType *)TargetFrame,
              v29,
              v30,
              v31,
              v32);
            v12 = (int)ExceptionRecord;
          }
        }
LABEL_50:
        ++v39;
        v22 = (const struct _s_TryBlockMapEntry *)((char *)v22 + 20);
      }
      v9 = (int)a6;
    }
    if ( a7 )
      __DestructExceptionObject(v12, 1);
    if ( !v43
      && (*(_DWORD *)v9 & 0x1FFFFFFFu) >= 0x19930521
      && *(_DWORD *)(v9 + 28)
      && !sub_6E677547(v12, *(_DWORD *)(v9 + 28)) )
    {
      if ( !v42 )
      {
        v42 = _getptd();
        if ( !v42 )
        {
          v42 = _getptd();
          if ( !v42 )
            v42 = _getptd();
        }
      }
      v27 = v42;
      *(_DWORD *)(v42 + 136) = v12;
      *(_DWORD *)(v27 + 140) = a4;
      if ( TargetFrame )
        _UnwindNestedFrames(v9, v12, TargetFrame, (PEXCEPTION_RECORD)v12);
      else
        _UnwindNestedFrames(v9, v12, (PVOID)a3, (PEXCEPTION_RECORD)v12);
      __FrameUnwindToState((int)a3, (int)a5, v9, -1);
      v28 = *(_DWORD *)(v9 + 28);
      sub_6E6775E1();
    }
  }
  result = v42;
  if ( !v42 )
    result = _getptd();
  if ( *(_DWORD *)(result + 148) )
    _inconsistency();
  return result;
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E67749F: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);
// 6E677AA1: using guessed type void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, _DWORD, struct EHRegistrationNode *, unsigned __int8);
// 6E6962C0: using guessed type int _TI2_AVbad_exception_std__;
// 6E69B648: using guessed type int (__thiscall **std::bad_exception `RTTI Type Descriptor')(void *lpMem, char);

//----- (6E678056) --------------------------------------------------------
void __cdecl __noreturn terminate()
{
  void (*v0)(void); // eax@1

  v0 = *(void (**)(void))(_getptd() + 120);
  if ( v0 )
    v0();
  abort();
}

//----- (6E6780B9) --------------------------------------------------------
void __cdecl __noreturn unexpected()
{
  void (*v0)(void); // eax@1

  v0 = *(void (**)(void))(_getptd() + 124);
  JUMPOUT(v0, 0, terminate);
  v0();
  terminate();
}

//----- (6E678124) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  int v0; // eax@0
  int v1; // edx@0
  int v2; // ecx@0
  int v3; // ebx@0
  int v4; // edi@0
  int v5; // esi@0
  unsigned int v6; // et0@1
  HANDLE v7; // eax@1
  int vars0; // [sp+328h] [bp+0h]@0
  int retaddr; // [sp+32Ch] [bp+4h]@1
  char v10; // [sp+330h] [bp+8h]@0

  dword_6E699848 = v0;
  dword_6E699844 = v2;
  dword_6E699840 = v1;
  dword_6E69983C = v3;
  dword_6E699838 = v5;
  dword_6E699834 = v4;
  word_6E699860 = __SS__;
  word_6E699854 = __CS__;
  word_6E699830 = __DS__;
  word_6E69982C = __ES__;
  word_6E699828 = __FS__;
  word_6E699824 = __GS__;
  v6 = __readeflags();
  dword_6E699858 = v6;
  dword_6E69984C = vars0;
  dword_6E699850 = retaddr;
  dword_6E69985C = (int)&v10;
  dword_6E699798 = 65537;
  dword_6E699514 = retaddr;
  dword_6E699508 = -1073740791;
  dword_6E69950C = 1;
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&ExceptionInfo);
  v7 = GetCurrentProcess();
  TerminateProcess(v7, 0xC0000409);
}
// 6E699144: using guessed type int __security_cookie_complement;
// 6E699508: using guessed type int dword_6E699508;
// 6E69950C: using guessed type int dword_6E69950C;
// 6E699514: using guessed type int dword_6E699514;
// 6E699798: using guessed type int dword_6E699798;
// 6E699824: using guessed type __int16 word_6E699824;
// 6E699828: using guessed type __int16 word_6E699828;
// 6E69982C: using guessed type __int16 word_6E69982C;
// 6E699830: using guessed type __int16 word_6E699830;
// 6E699834: using guessed type int dword_6E699834;
// 6E699838: using guessed type int dword_6E699838;
// 6E69983C: using guessed type int dword_6E69983C;
// 6E699840: using guessed type int dword_6E699840;
// 6E699844: using guessed type int dword_6E699844;
// 6E699848: using guessed type int dword_6E699848;
// 6E69984C: using guessed type int dword_6E69984C;
// 6E699850: using guessed type int dword_6E699850;
// 6E699854: using guessed type __int16 word_6E699854;
// 6E699858: using guessed type int dword_6E699858;
// 6E69985C: using guessed type int dword_6E69985C;
// 6E699860: using guessed type __int16 word_6E699860;

//----- (6E67820D) --------------------------------------------------------
void __cdecl sub_6E67820D(int a1, int a2, unsigned int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  unsigned int v5; // ecx@1
  __m128i v6; // xmm1@2
  __m128i v7; // xmm2@2
  __m128i v8; // xmm3@2
  __m128i v9; // xmm5@2
  __m128i v10; // xmm6@2
  __m128i v11; // xmm7@2

  v3 = a2;
  v4 = a1;
  v5 = a3 >> 7;
  do
  {
    v6 = _mm_load_si128((const __m128i *)(v3 + 16));
    v7 = _mm_load_si128((const __m128i *)(v3 + 32));
    v8 = _mm_load_si128((const __m128i *)(v3 + 48));
    _mm_store_si128((__m128i *)v4, _mm_load_si128((const __m128i *)v3));
    _mm_store_si128((__m128i *)(v4 + 16), v6);
    _mm_store_si128((__m128i *)(v4 + 32), v7);
    _mm_store_si128((__m128i *)(v4 + 48), v8);
    v9 = _mm_load_si128((const __m128i *)(v3 + 80));
    v10 = _mm_load_si128((const __m128i *)(v3 + 96));
    v11 = _mm_load_si128((const __m128i *)(v3 + 112));
    _mm_store_si128((__m128i *)(v4 + 64), _mm_load_si128((const __m128i *)(v3 + 64)));
    _mm_store_si128((__m128i *)(v4 + 80), v9);
    _mm_store_si128((__m128i *)(v4 + 96), v10);
    _mm_store_si128((__m128i *)(v4 + 112), v11);
    v3 += 128;
    v4 += 128;
    --v5;
  }
  while ( v5 );
}

//----- (6E6783F5) --------------------------------------------------------
int __cdecl _cropzeros_l(int a1, struct localeinfo_struct *a2)
{
  int v2; // eax@1
  char i; // cl@1
  char v4; // cl@4
  int result; // eax@4
  char v6; // cl@9
  int v7; // edx@10
  char v8; // cl@14
  int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-8h]@16
  char v11; // [sp+10h] [bp-4h]@15

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a2);
  v2 = a1;
  for ( i = *(_BYTE *)a1; *(_BYTE *)v2; i = *(_BYTE *)v2 )
  {
    if ( i == ***(_BYTE ***)(v9 + 188) )
      break;
    ++v2;
  }
  v4 = *(_BYTE *)v2;
  result = v2 + 1;
  if ( v4 )
  {
    while ( 1 )
    {
      v6 = *(_BYTE *)result;
      if ( !*(_BYTE *)result || v6 == 101 || v6 == 69 )
        break;
      ++result;
    }
    v7 = result;
    do
      --result;
    while ( *(_BYTE *)result == 48 );
    if ( *(_BYTE *)result == ***(_BYTE ***)(v9 + 188) )
      --result;
    do
    {
      v8 = *(_BYTE *)v7;
      ++result;
      ++v7;
      *(_BYTE *)result = v8;
    }
    while ( v8 );
  }
  if ( v11 )
  {
    result = v10;
    *(_DWORD *)(result + 112) &= 0xFFFFFFFD;
  }
  return result;
}

//----- (6E678ECC) --------------------------------------------------------
void __cdecl _invoke_watson(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5)
{
  unsigned int v5; // et0@1

  v5 = __readeflags();
  OutputDebugStringA("Invalid parameter passed to C runtime function.\n");
}

//----- (6E678FA2) --------------------------------------------------------
void __cdecl _invalid_parameter(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5)
{
  _invoke_watson(a1, a2, a3, a4, a5);
}

//----- (6E679089) --------------------------------------------------------
signed int __cdecl _mtinitlocknum(int a1)
{
  LPCRITICAL_SECTION *v1; // esi@4
  signed int result; // eax@5
  void *v3; // edi@6
  signed int v4; // [sp+10h] [bp-1Ch]@1

  v4 = 1;
  if ( !_crtheap )
  {
    _FF_MSGBANNER();
    _NMSG_WRITE(30);
    __crtExitProcess(0xFFu);
  }
  v1 = &lpCriticalSection + 2 * a1;
  if ( *v1 )
  {
    result = 1;
  }
  else
  {
    v3 = malloc(0x18u);
    if ( v3 )
    {
      _lock(10);
      if ( *v1 )
      {
        free(v3);
      }
      else if ( __crtInitCritSecAndSpinCount((int)v3, 4000) )
      {
        *v1 = (LPCRITICAL_SECTION)v3;
      }
      else
      {
        free(v3);
        *_errno() = 12;
        v4 = 0;
      }
      _unlock(10);
      result = v4;
    }
    else
    {
      *_errno() = 12;
      result = 0;
    }
  }
  return result;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E67B6AF: using guessed type int _FF_MSGBANNER(void);

//----- (6E6793A7) --------------------------------------------------------
int __updatetlocinfo()
{
  int v0; // eax@1
  int v1; // ST04_4@4
  int v2; // ST18_4@4
  int v3; // esi@4

  v0 = _getptd();
  if ( (*(_BYTE *)(v0 + 112) & 2 || !(__globallocalestatus & 1)) && *(_DWORD *)(v0 + 108) )
  {
    v3 = *(_DWORD *)(_getptd() + 108);
  }
  else
  {
    _lock(12);
    v2 = _updatetlocinfoEx_nolock(v1);
    _unlock(12);
    v3 = v2;
  }
  if ( !v3 )
    _amsg_exit(32);
  return v3;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E6770A0: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);
// 6E679364: using guessed type int __thiscall _updatetlocinfoEx_nolock(_DWORD);
// 6E69B2C4: using guessed type _DWORD ___ptlocinfo;
// 6E69B2D4: using guessed type char __globallocalestatus;

//----- (6E679503) --------------------------------------------------------
void __cdecl _lock_file(FILE *File)
{
  if ( File < _iob || (unsigned int)File > (unsigned int)dword_6E69A298 )
    EnterCriticalSection((LPCRITICAL_SECTION)&File[1]);
  else
    _lock(File - _iob + 16);
}
// 6E69A298: using guessed type int dword_6E69A298[8];

//----- (6E67953D) --------------------------------------------------------
void __cdecl _unlock_file(FILE *File)
{
  if ( File < _iob || (unsigned int)File > (unsigned int)dword_6E69A298 )
    LeaveCriticalSection((LPCRITICAL_SECTION)&File[1]);
  else
    _unlock(File - _iob + 16);
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E69A298: using guessed type int dword_6E69A298[8];

//----- (6E679577) --------------------------------------------------------
int __cdecl _stbuf(FILE *File)
{
  int v1; // eax@1
  signed int v2; // eax@3
  int *v3; // edi@7
  void *v4; // eax@8
  char *v5; // edi@10

  v1 = _fileno(File);
  if ( !_isatty(v1) )
    return 0;
  if ( (int *)File == dword_6E69A058 )
  {
    v2 = 0;
  }
  else
  {
    if ( (int *)File != dword_6E69A078 )
      return 0;
    v2 = 1;
  }
  ++_cflush;
  if ( File->_flag & 0x10C )
    return 0;
  v3 = &_stdbuf[v2];
  if ( *v3 || (v4 = malloc(0x1000u), (*v3 = (int)v4) != 0) )
  {
    v5 = (char *)*v3;
    File->_base = v5;
    File->_ptr = v5;
    File->_bufsiz = 4096;
    File->_cnt = 4096;
  }
  else
  {
    File->_base = (char *)&File->_charbuf;
    File->_ptr = (char *)&File->_charbuf;
    File->_bufsiz = 2;
    File->_cnt = 2;
  }
  File->_flag |= 0x1102u;
  return 1;
}
// 6E69A058: using guessed type int dword_6E69A058[3];
// 6E69A078: using guessed type int dword_6E69A078[3];
// 6E69BD48: using guessed type int _cflush;
// 6E69BD4C: using guessed type int _stdbuf[2];

//----- (6E6796FE) --------------------------------------------------------
int __cdecl _output_l(FILE *File, int a2, struct localeinfo_struct *a3, int a4)
{
  FILE *v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  int *v8; // esi@9
  int v9; // eax@9
  int *v10; // esi@14
  int v11; // eax@14
  char v12; // cl@18
  int v13; // edx@18
  int v14; // esi@19
  int v15; // eax@21
  char v16; // al@53
  char v17; // al@67
  signed int v18; // edx@84
  int v19; // edi@86
  char *v20; // edi@86
  char *v21; // eax@89
  int v22; // edi@94
  int v23; // eax@99
  char *v24; // esi@100
  unsigned __int16 v25; // cx@101
  int v26; // eax@102
  char *v27; // eax@107
  int v28; // edx@107
  char v29; // cl@108
  int v30; // esi@119
  __int64 v31; // rax@127
  int v32; // edi@127
  int v33; // esi@134
  void *v34; // eax@134
  int v35; // eax@137
  int v36; // edi@137
  int v37; // ST18_4@137
  int v38; // ST14_4@137
  char *v39; // edi@137
  int v40; // ST10_4@137
  int v41; // ST0C_4@137
  char *v42; // ST08_4@137
  int v43; // eax@137
  int v44; // esi@137
  int v45; // eax@139
  int v46; // eax@142
  char v47; // cl@146
  unsigned int v48; // ebx@169
  unsigned int v49; // edi@169
  char *i; // esi@177
  int v51; // eax@178
  unsigned __int64 v52; // ST10_8@180
  unsigned __int64 v53; // rcx@180
  signed int v54; // ecx@180
  int v55; // eax@183
  int v56; // esi@183
  char *j; // eax@193
  int v58; // ebx@208
  FILE *v59; // edi@210
  char *v60; // esi@215
  wchar_t v61; // ax@216
  char v62; // al@227
  int v63; // [sp+Ch] [bp-278h]@137
  int v64; // [sp+10h] [bp-274h]@137
  int v65; // [sp+14h] [bp-270h]@23
  int v66; // [sp+18h] [bp-26Ch]@216
  int v67; // [sp+20h] [bp-264h]@78
  int v68; // [sp+24h] [bp-260h]@1
  FILE *v69; // [sp+28h] [bp-25Ch]@1
  int v70; // [sp+2Ch] [bp-258h]@1
  void *Memory; // [sp+30h] [bp-254h]@18
  int v72; // [sp+34h] [bp-250h]@1
  struct localeinfo_struct Locale; // [sp+38h] [bp-24Ch]@1
  int v74; // [sp+40h] [bp-244h]@4
  char v75; // [sp+44h] [bp-240h]@3
  int v76; // [sp+48h] [bp-23Ch]@1
  int v77; // [sp+4Ch] [bp-238h]@1
  int v78; // [sp+50h] [bp-234h]@1
  int v79; // [sp+54h] [bp-230h]@1
  char v80; // [sp+58h] [bp-22Ch]@155
  char v81; // [sp+59h] [bp-22Bh]@155
  int v82; // [sp+5Ch] [bp-228h]@18
  int v83; // [sp+60h] [bp-224h]@1
  int SizeConverted; // [sp+64h] [bp-220h]@18
  char *v85; // [sp+68h] [bp-21Ch]@78
  int v86; // [sp+6Ch] [bp-218h]@1
  char v87; // [sp+73h] [bp-211h]@18
  int v88; // [sp+74h] [bp-210h]@1
  char MbCh; // [sp+78h] [bp-20Ch]@78
  char v90; // [sp+277h] [bp-Dh]@177
  char v91; // [sp+278h] [bp-Ch]@216

  v4 = File;
  v5 = a2;
  v6 = a4;
  v69 = File;
  v79 = a2;
  v83 = a4;
  v70 = 0;
  v88 = 0;
  v77 = 0;
  v86 = 0;
  v78 = 0;
  v68 = 0;
  v72 = 0;
  v76 = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  if ( !File
    || !(File->_flag & 0x40)
    && (_fileno(File) == -1 || _fileno(File) == -2 ? (v9 = (int)__badioinfo) : (v8 = &__pioinfo[_fileno(File) >> 5],
                                                                                v9 = *v8 + 36 * (_fileno(File) & 0x1F),
                                                                                v5 = v79),
        *(_BYTE *)(v9 + 8) & 3
     || (_fileno(File) == -1 || _fileno(File) == -2 ? (v11 = (int)__badioinfo) : (v10 = &__pioinfo[_fileno(File) >> 5],
                                                                                  v11 = *v10
                                                                                      + 36 * (_fileno(File) & 0x1F),
                                                                                  v5 = v79),
         *(_BYTE *)(v11 + 8) & 8))
    || !v5 )
  {
LABEL_2:
    *_errno() = 22;
    goto LABEL_3;
  }
  v12 = *(_BYTE *)v5;
  v13 = 0;
  v82 = 0;
  SizeConverted = 0;
  Memory = 0;
  v87 = v12;
  if ( !v12 )
  {
LABEL_230:
    if ( v75 )
      *(_DWORD *)(v74 + 112) &= 0xFFFFFFFD;
    return v82;
  }
  while ( 2 )
  {
    v14 = v5 + 1;
    v79 = v14;
    if ( v82 < 0 )
      goto LABEL_230;
    if ( (unsigned __int8)(v12 - 32) > 0x58u )
      v15 = 0;
    else
      v15 = *((_BYTE *)&off_6E65C950 + v12) & 0xF;
    v65 = (signed int)LOBYTE((&(&__lookuptable)[8 * v15])[v13]) >> 4;
    switch ( v65 )
    {
      case 1:
        v86 = -1;
        v68 = 0;
        v72 = 0;
        v77 = 0;
        v78 = 0;
        v88 = 0;
        v76 = 0;
        goto LABEL_227;
      case 2:
        switch ( v12 )
        {
          case 32:
            v88 |= 2u;
            break;
          case 35:
            v88 |= 0x80u;
            break;
          case 43:
            v88 |= 1u;
            break;
          case 45:
            v88 |= 4u;
            break;
          case 48:
            v88 |= 8u;
            break;
        }
        goto LABEL_227;
      case 3:
        if ( v12 == 42 )
        {
          v83 = v6 + 4;
          v77 = *(_DWORD *)v6;
          if ( v77 < 0 )
          {
            v88 |= 4u;
            v77 = -v77;
          }
        }
        else
        {
          v77 = 10 * v77 + v12 - 48;
        }
        goto LABEL_227;
      case 4:
        v86 = 0;
        goto LABEL_227;
      case 5:
        if ( v12 == 42 )
        {
          v83 = v6 + 4;
          v86 = *(_DWORD *)v6;
          if ( v86 < 0 )
            v86 = -1;
        }
        else
        {
          v86 = 10 * v86 + v12 - 48;
        }
        goto LABEL_227;
      case 6:
        switch ( v12 )
        {
          case 73:
            v16 = *(_BYTE *)v14;
            if ( *(_BYTE *)v14 != 54 || *(_BYTE *)(v14 + 1) != 52 )
            {
              if ( v16 != 51 || *(_BYTE *)(v14 + 1) != 50 )
              {
                if ( v16 != 100 && v16 != 105 && v16 != 111 && v16 != 117 && v16 != 120 && v16 != 88 )
                {
                  v65 = 0;
LABEL_66:
                  v76 = 0;
                  if ( _isleadbyte_l((unsigned __int8)v12, &Locale) )
                  {
                    write_char(v4);
                    v17 = *(_BYTE *)v79++;
                    if ( !v17 )
                      goto LABEL_2;
                  }
                  write_char(v4);
                }
              }
              else
              {
                v88 &= 0xFFFF7FFF;
                v79 = v14 + 2;
              }
            }
            else
            {
              v88 |= 0x8000u;
              v79 = v14 + 2;
            }
            break;
          case 104:
            v88 |= 0x20u;
            break;
          case 108:
            if ( *(_BYTE *)v14 == 108 )
            {
              v88 |= 0x1000u;
              v79 = v14 + 1;
            }
            else
            {
              v88 |= 0x10u;
            }
            break;
          case 119:
            v88 |= 0x800u;
            break;
        }
        goto LABEL_227;
      case 0:
        goto LABEL_66;
      case 7:
        if ( v12 > 100 )
        {
          if ( v12 > 112 )
          {
            if ( v12 == 115 )
              goto LABEL_84;
            if ( v12 != 117 )
            {
              if ( v12 != 120 )
                goto LABEL_199;
              v70 = 39;
              goto LABEL_154;
            }
          }
          else
          {
            if ( v12 == 112 )
            {
              v86 = 8;
              goto LABEL_149;
            }
            if ( v12 < 101 )
              goto LABEL_199;
            if ( v12 <= 103 )
              goto LABEL_78;
            if ( v12 != 105 )
            {
              if ( v12 == 110 )
              {
                v30 = *(_DWORD *)v6;
                v83 = v6 + 4;
                if ( !_get_printf_count_output() )
                  goto LABEL_2;
                if ( v88 & 0x20 )
                  *(_WORD *)v30 = v82;
                else
                  *(_DWORD *)v30 = v82;
                v72 = 1;
                goto LABEL_225;
              }
              if ( v12 != 111 )
                goto LABEL_199;
              SizeConverted = 8;
              if ( v88 & 0x80 )
                v88 |= 0x200u;
LABEL_126:
              if ( v88 & 0x8000 || v88 & 0x1000 )
              {
                v31 = *(_QWORD *)v6;
                v32 = v6 + 8;
              }
              else
              {
                v32 = v6 + 4;
                if ( v88 & 0x20 )
                {
                  v83 = v32;
                  if ( v88 & 0x40 )
                    LODWORD(v31) = *(_WORD *)(v32 - 4);
                  else
                    LODWORD(v31) = *(_WORD *)(v32 - 4);
                  v31 = (signed int)v31;
LABEL_166:
                  if ( v88 & 0x40 && v31 < 0 )
                  {
                    v31 = -v31;
                    v88 |= 0x100u;
                  }
                  v48 = HIDWORD(v31);
                  v49 = v31;
                  if ( !(v88 & 0x9000) )
                    v48 = 0;
                  if ( v86 >= 0 )
                  {
                    v88 &= 0xFFFFFFF7;
                    if ( v86 > 512 )
                      v86 = 512;
                  }
                  else
                  {
                    v86 = 1;
                  }
                  if ( !(v48 | (unsigned int)v31) )
                    v78 = 0;
                  for ( i = &v90; ; --i )
                  {
                    v51 = v86--;
                    if ( v51 <= 0 && !(v48 | v49) )
                      break;
                    v52 = __PAIR__(v48, v49);
                    v53 = __PAIR__(v48, v49) % SizeConverted;
                    v54 = v53 + 48;
                    v67 = HIDWORD(v53);
                    v48 = v52 / SizeConverted >> 32;
                    v49 = v52 / SizeConverted;
                    if ( v54 > 57 )
                      LOBYTE(v54) = v70 + v54;
                    *i = v54;
                  }
                  v55 = &v90 - i;
                  v56 = (int)(i + 1);
                  SizeConverted = v55;
                  v85 = (char *)v56;
                  if ( v88 & 0x200 && (!v55 || *(_BYTE *)v56 != 48) )
                  {
                    --v85;
                    *v85 = 48;
                    v26 = v55 + 1;
                    goto LABEL_198;
                  }
                  goto LABEL_199;
                }
                LODWORD(v31) = *(_DWORD *)(v32 - 4);
                if ( v88 & 0x40 )
                  v31 = (signed int)v31;
                else
                  HIDWORD(v31) = 0;
              }
              v83 = v32;
              goto LABEL_166;
            }
LABEL_124:
            v88 |= 0x40u;
          }
          SizeConverted = 10;
          goto LABEL_126;
        }
        if ( v12 == 100 )
          goto LABEL_124;
        if ( v12 <= 83 )
        {
          if ( v12 == 83 )
          {
            if ( !(v88 & 0x830) )
              v88 |= 0x800u;
LABEL_84:
            v18 = v86;
            if ( v86 == -1 )
              v18 = 0x7FFFFFFF;
            v19 = v6 + 4;
            v83 = v19;
            v20 = *(char **)(v19 - 4);
            v85 = v20;
            if ( v88 & 0x810 )
            {
              if ( !v20 )
                v85 = (char *)__wnullstring;
              v21 = v85;
              v76 = 1;
              while ( v18 )
              {
                --v18;
                if ( !*(_WORD *)v21 )
                  break;
                v21 += 2;
              }
              v26 = (v21 - v85) >> 1;
            }
            else
            {
              if ( !v20 )
                v85 = __nullstring;
              for ( j = v85; ; ++j )
              {
                if ( v18 )
                {
                  --v18;
                  if ( *j )
                    continue;
                }
                break;
              }
              v26 = j - v85;
            }
            goto LABEL_198;
          }
          if ( v12 == 65 )
            goto LABEL_77;
          if ( v12 == 67 )
          {
            if ( !(v88 & 0x830) )
              v88 |= 0x800u;
LABEL_94:
            v22 = v6 + 4;
            v83 = v22;
            if ( v88 & 0x810 )
            {
              if ( wctomb_s(&SizeConverted, &MbCh, 0x200u, *(_WORD *)(v22 - 4)) )
                v72 = 1;
            }
            else
            {
              MbCh = *(_BYTE *)(v22 - 4);
              SizeConverted = 1;
            }
            v85 = &MbCh;
            goto LABEL_199;
          }
          if ( v12 == 69 || v12 == 71 )
          {
LABEL_77:
            v12 += 32;
            v68 = 1;
            v87 = v12;
LABEL_78:
            v88 |= 0x40u;
            v85 = &MbCh;
            v67 = 512;
            if ( v86 >= 0 )
            {
              if ( v86 )
              {
                if ( v86 > 512 )
                  v86 = 512;
                if ( v86 > 163 )
                {
                  v33 = v86 + 349;
                  v34 = malloc(v86 + 349);
                  v12 = v87;
                  Memory = v34;
                  if ( v34 )
                  {
                    v85 = (char *)v34;
                    v67 = v33;
                  }
                  else
                  {
                    v86 = 163;
                  }
                }
              }
              else if ( v12 == 103 )
              {
                v86 = 1;
              }
            }
            else
            {
              v86 = 6;
            }
            v35 = *(_DWORD *)v6;
            v36 = v6 + 8;
            v63 = v35;
            v64 = *(_DWORD *)(v36 - 4);
            v37 = v68;
            v38 = v86;
            v83 = v36;
            v39 = v85;
            v40 = v12;
            v41 = v67;
            v42 = v85;
            v43 = _decode_pointer((int)off_6E699A90[0]);
            ((void (__cdecl *)(int *, char *, int, int, int, int, struct localeinfo_struct *))v43)(
              &v63,
              v42,
              v41,
              v40,
              v38,
              v37,
              &Locale);
            v44 = v88 & 0x80;
            if ( v88 & 0x80 && !v86 )
            {
              v45 = _decode_pointer((int)off_6E699A9C);
              ((void (__cdecl *)(char *, struct localeinfo_struct *))v45)(v39, &Locale);
            }
            if ( v87 == 103 && !v44 )
            {
              v46 = _decode_pointer((int)off_6E699A98[0]);
              ((void (__cdecl *)(char *, struct localeinfo_struct *))v46)(v39, &Locale);
            }
            if ( *v39 == 45 )
            {
              v88 |= 0x100u;
              ++v39;
              v85 = v39;
            }
            v27 = v39;
            v28 = (int)(v39 + 1);
            do
              v47 = *v27++;
            while ( v47 );
LABEL_109:
            v26 = (int)&v27[-v28];
LABEL_198:
            SizeConverted = v26;
          }
LABEL_199:
          if ( !v72 )
          {
            if ( v88 & 0x40 )
            {
              if ( v88 & 0x100 )
              {
                v80 = 45;
LABEL_207:
                v78 = 1;
                goto LABEL_208;
              }
              if ( v88 & 1 )
              {
                v80 = 43;
                goto LABEL_207;
              }
              if ( v88 & 2 )
              {
                v80 = 32;
                goto LABEL_207;
              }
            }
LABEL_208:
            v58 = v77 - SizeConverted - v78;
            if ( !(v88 & 0xC) )
              write_multi_char(32, v77 - SizeConverted - v78, v69);
            v59 = v69;
            write_string(v78);
            if ( v88 & 8 && !(v88 & 4) )
              write_multi_char(48, v58, v59);
            if ( v76 && SizeConverted > 0 )
            {
              v60 = v85;
              v67 = SizeConverted;
              while ( 1 )
              {
                v61 = *(_WORD *)v60;
                --v67;
                v60 += 2;
                if ( wctomb_s(&v66, &v91, 6u, v61) || !v66 )
                  break;
                write_string(v66);
                if ( !v67 )
                  goto LABEL_222;
              }
              v82 = -1;
            }
            else
            {
              write_string(SizeConverted);
            }
LABEL_222:
            if ( v82 >= 0 && v88 & 4 )
              write_multi_char(32, v58, v59);
          }
LABEL_225:
          if ( Memory )
          {
            free(Memory);
            Memory = 0;
          }
LABEL_227:
          v5 = v79;
          v62 = *(_BYTE *)v79;
          v87 = v62;
          if ( !v62 )
            goto LABEL_230;
          v13 = v65;
          v4 = v69;
          v6 = v83;
          v12 = v62;
          continue;
        }
        if ( v12 == 88 )
        {
LABEL_149:
          v70 = 7;
LABEL_154:
          SizeConverted = 16;
          if ( v88 & 0x80 )
          {
            v80 = 48;
            v81 = v70 + 81;
            v78 = 2;
          }
          goto LABEL_126;
        }
        if ( v12 != 90 )
        {
          if ( v12 == 97 )
            goto LABEL_78;
          if ( v12 != 99 )
            goto LABEL_199;
          goto LABEL_94;
        }
        v23 = *(_DWORD *)v6;
        v83 = v6 + 4;
        if ( !v23 || (v24 = *(char **)(v23 + 4)) == 0 )
        {
          v27 = __nullstring;
          v85 = __nullstring;
          v28 = (int)(__nullstring + 1);
          do
            v29 = *v27++;
          while ( v29 );
          goto LABEL_109;
        }
        v25 = *(_WORD *)v23;
        if ( *(_WORD *)(v23 + 2) < *(_WORD *)v23 )
          goto LABEL_229;
        v26 = v25;
        if ( !(v88 & 0x800) )
        {
          v76 = 0;
          v85 = v24;
          goto LABEL_198;
        }
        if ( ~(_BYTE)v25 & 1 && ~(_BYTE)v24 & 1 )
        {
          v85 = v24;
          v26 = (unsigned int)v25 >> 1;
          v76 = 1;
          goto LABEL_198;
        }
LABEL_229:
        *_errno() = 22;
LABEL_3:
        _invalid_parameter(0, 0, 0, 0, 0);
        if ( v75 )
          *(_DWORD *)(v74 + 112) &= 0xFFFFFFFD;
        return -1;
      default:
        goto LABEL_227;
    }
  }
}
// 6E65C970: using guessed type const char *const __lookuptable;
// 6E6796AC: using guessed type int __cdecl write_string(_DWORD);
// 6E699A90: using guessed type int (*off_6E699A90[4])();
// 6E699A98: using guessed type int (*off_6E699A98[2])();
// 6E699A9C: using guessed type int (*off_6E699A9C)();
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69B624: using guessed type int __badioinfo[9];
// 6E69B884: using guessed type char *__nullstring;
// 6E69B888: using guessed type unsigned __int16 *__wnullstring;

//----- (6E67A376) --------------------------------------------------------
int __cdecl _flsbuf(int Ch, FILE *File)
{
  int v2; // esi@1
  int v3; // eax@1
  int v5; // ebx@6
  unsigned int v6; // eax@9
  const void *v7; // eax@15
  int v8; // edi@15
  unsigned int v9; // edi@15
  int v10; // eax@20
  __int64 v11; // rax@23

  v2 = (int)File;
  File = (FILE *)_fileno(File);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  v5 = 0;
  if ( v3 & 1 )
  {
    *(_DWORD *)(v2 + 4) = 0;
    if ( !(v3 & 0x10) )
    {
      *(_DWORD *)(v2 + 12) = v3 | 0x20;
      return -1;
    }
    *(_DWORD *)v2 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 12) = v3 & 0xFFFFFFFE;
  }
  v6 = *(_DWORD *)(v2 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v2 + 12) = v6;
  *(_DWORD *)(v2 + 4) = 0;
  if ( !(v6 & 0x10C) && ((int *)v2 != dword_6E69A058 && (int *)v2 != dword_6E69A078 || !_isatty((int)File)) )
    _getbuf(v2);
  if ( *(_DWORD *)(v2 + 12) & 0x108 )
  {
    v7 = *(const void **)(v2 + 8);
    v8 = *(_DWORD *)v2;
    *(_DWORD *)v2 = (char *)v7 + 1;
    v9 = v8 - (_DWORD)v7;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 24) - 1;
    if ( (signed int)v9 <= 0 )
    {
      if ( File == (FILE *)-1 || File == (FILE *)-2 )
        v10 = (int)__badioinfo;
      else
        v10 = __pioinfo[(signed int)File >> 5] + 36 * ((unsigned __int8)File & 0x1F);
      if ( *(_BYTE *)(v10 + 4) & 0x20 )
      {
        v11 = _lseeki64((int)File, 0i64, 2);
        if ( (HIDWORD(v11) & (unsigned int)v11) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v5 = _write((int)File, v7, v9);
    }
    **(_BYTE **)(v2 + 8) = Ch;
  }
  else
  {
    v9 = 1;
    v5 = _write((int)File, &Ch, 1u);
  }
  if ( v5 != v9 )
  {
LABEL_27:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return -1;
  }
  return (unsigned __int8)Ch;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69A058: using guessed type int dword_6E69A058[3];
// 6E69A078: using guessed type int dword_6E69A078[3];
// 6E69B624: using guessed type int __badioinfo[9];

//----- (6E67A4C8) --------------------------------------------------------
void __usercall sub_6E67A4C8(int a1@<edi>, int a2@<esi>, wchar_t a3)
{
  if ( (!(*(_BYTE *)(a2 + 12) & 0x40) || *(_DWORD *)(a2 + 8))
    && _fputwc_nolock(a3, (FILE *)a2) == -1
    && ferror((FILE *)a2) )
    *(_DWORD *)a1 = -1;
  else
    ++*(_DWORD *)a1;
}

//----- (6E67A507) --------------------------------------------------------
void __usercall sub_6E67A507(int a1@<eax>, wchar_t a2, int a3, int a4)
{
  int v4; // edi@1

  v4 = a1;
  if ( a3 > 0 )
  {
    do
    {
      --a3;
      sub_6E67A4C8(v4, a4, a2);
    }
    while ( *(_DWORD *)v4 != -1 && a3 > 0 );
  }
}

//----- (6E67A539) --------------------------------------------------------
void __usercall sub_6E67A539(int a1@<eax>, wchar_t *a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  wchar_t *v6; // ebx@1

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( !(*(_BYTE *)(a3 + 12) & 0x40) || *(_DWORD *)(a3 + 8) )
  {
    while ( a4 > 0 )
    {
      --a4;
      sub_6E67A4C8(v5, v4, *v6);
      ++v6;
      if ( *(_DWORD *)v5 == -1 )
      {
        if ( *_errno() != 42 )
          return;
        sub_6E67A4C8(v5, v4, 0x3Fu);
      }
    }
  }
  else
  {
    *(_DWORD *)a1 += a4;
  }
}

//----- (6E67A590) --------------------------------------------------------
int __cdecl _woutput_l(int a1, int a2, struct localeinfo_struct *a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  char *v7; // edx@7
  int v8; // ecx@7
  int v9; // edi@8
  int v10; // eax@10
  __int16 v11; // ax@42
  wchar_t *v12; // edi@65
  signed int v13; // esi@71
  int v14; // ebx@73
  unsigned __int16 *v15; // ebx@73
  int *i; // edi@76
  int v17; // eax@86
  int v18; // eax@91
  unsigned __int16 *v19; // esi@92
  unsigned __int16 v20; // cx@93
  int v21; // eax@94
  char *v22; // eax@99
  int v23; // edx@99
  char v24; // cl@100
  int v25; // esi@111
  __int64 v26; // rax@119
  int v27; // ebx@119
  int v28; // esi@126
  void *v29; // eax@126
  int v30; // eax@129
  int v31; // ebx@129
  int v32; // ST18_4@129
  int v33; // ST14_4@129
  int v34; // ST10_4@129
  int v35; // ST0C_4@129
  int v36; // eax@129
  int v37; // esi@129
  int v38; // eax@131
  int v39; // eax@134
  char v40; // cl@138
  unsigned int v41; // ebx@161
  unsigned int v42; // esi@161
  char *j; // edi@169
  int v44; // eax@170
  signed int v45; // ecx@172
  unsigned __int64 v46; // kr00_8@172
  char *v47; // eax@175
  int v48; // edi@175
  unsigned __int16 *v49; // eax@181
  int v50; // esi@196
  int v51; // ebx@196
  char *v52; // eax@214
  signed __int16 v53; // [sp-4h] [bp-488h]@190
  int v54; // [sp+10h] [bp-474h]@204
  int v55; // [sp+14h] [bp-470h]@129
  int v56; // [sp+18h] [bp-46Ch]@129
  int v57; // [sp+1Ch] [bp-468h]@12
  wchar_t v58[2]; // [sp+20h] [bp-464h]@86
  int v59; // [sp+24h] [bp-460h]@1
  int v60; // [sp+28h] [bp-45Ch]@1
  int v61; // [sp+2Ch] [bp-458h]@1
  void *Memory; // [sp+30h] [bp-454h]@7
  int v63; // [sp+34h] [bp-450h]@8
  struct localeinfo_struct Locale; // [sp+38h] [bp-44Ch]@1
  int v65; // [sp+40h] [bp-444h]@4
  char v66; // [sp+44h] [bp-440h]@3
  char SrcCh; // [sp+48h] [bp-43Ch]@87
  char v68; // [sp+49h] [bp-43Bh]@87
  __int16 v69; // [sp+4Ch] [bp-438h]@147
  __int16 v70; // [sp+4Eh] [bp-436h]@147
  int v71; // [sp+50h] [bp-434h]@65
  int v72; // [sp+54h] [bp-430h]@1
  int v73; // [sp+58h] [bp-42Ch]@1
  int v74; // [sp+5Ch] [bp-428h]@1
  int v75; // [sp+60h] [bp-424h]@1
  int v76; // [sp+64h] [bp-420h]@7
  int v77; // [sp+68h] [bp-41Ch]@7
  int v78; // [sp+6Ch] [bp-418h]@1
  char *v79; // [sp+70h] [bp-414h]@7
  unsigned __int16 *v80; // [sp+74h] [bp-410h]@65
  int v81; // [sp+78h] [bp-40Ch]@1
  int v82; // [sp+7Ch] [bp-408h]@1
  wchar_t DstCh; // [sp+80h] [bp-404h]@65
  char v84[513]; // [sp+27Fh] [bp-205h]@169

  v4 = a4;
  v5 = a2;
  v75 = a1;
  v78 = a4;
  v61 = 0;
  v82 = 0;
  v73 = 0;
  v81 = 0;
  v74 = 0;
  v59 = 0;
  v60 = 0;
  v72 = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  if ( !v75 || !a2 )
  {
    *_errno() = 22;
    goto LABEL_3;
  }
  v7 = (char *)*(_WORD *)a2;
  v8 = 0;
  v77 = 0;
  v76 = 0;
  Memory = 0;
  v79 = v7;
  if ( !(_WORD)v7 )
  {
LABEL_217:
    if ( v66 )
      *(_DWORD *)(v65 + 112) &= 0xFFFFFFFD;
    return v77;
  }
  while ( 2 )
  {
    v9 = v5 + 2;
    v63 = v9;
    if ( v77 < 0 )
      goto LABEL_217;
    if ( (unsigned __int16)((_WORD)v7 - 32) > 0x58u )
      v10 = 0;
    else
      v10 = *((_BYTE *)&off_6E65C950 + (unsigned __int16)v7) & 0xF;
    v57 = (signed int)LOBYTE((&(&__lookuptable)[8 * v10])[v8]) >> 4;
    switch ( v57 )
    {
      case 1:
        v81 = -1;
        v59 = 0;
        v60 = 0;
        v73 = 0;
        v74 = 0;
        v82 = 0;
        v72 = 0;
        goto LABEL_214;
      case 2:
        switch ( (unsigned __int16)v7 )
        {
          case 0x20u:
            v82 |= 2u;
            break;
          case 0x23u:
            v82 |= 0x80u;
            break;
          case 0x2Bu:
            v82 |= 1u;
            break;
          case 0x2Du:
            v82 |= 4u;
            break;
          case 0x30u:
            v82 |= 8u;
            break;
        }
        goto LABEL_214;
      case 3:
        if ( (_WORD)v7 == 42 )
        {
          v78 = v4 + 4;
          v73 = *(_DWORD *)v4;
          if ( v73 < 0 )
          {
            v82 |= 4u;
            v73 = -v73;
          }
        }
        else
        {
          v73 = 10 * v73 + (unsigned __int16)v7 - 48;
        }
        goto LABEL_214;
      case 4:
        v81 = 0;
        goto LABEL_214;
      case 5:
        if ( (_WORD)v7 == 42 )
        {
          v78 = v4 + 4;
          v81 = *(_DWORD *)v4;
          if ( v81 < 0 )
            v81 = -1;
        }
        else
        {
          v81 = 10 * v81 + (unsigned __int16)v7 - 48;
        }
        goto LABEL_214;
      case 6:
        switch ( (unsigned __int16)v7 )
        {
          case 0x49u:
            v11 = *(_WORD *)v9;
            if ( *(_WORD *)v9 != 54 || *(_WORD *)(v9 + 2) != 52 )
            {
              if ( v11 != 51 || *(_WORD *)(v9 + 2) != 50 )
              {
                if ( v11 != 100 && v11 != 105 && v11 != 111 && v11 != 117 && v11 != 120 && v11 != 88 )
                {
                  v57 = 0;
LABEL_55:
                  v72 = 1;
                  sub_6E67A4C8((int)&v77, v75, (wchar_t)v7);
                }
              }
              else
              {
                v82 &= 0xFFFF7FFF;
                v63 = v9 + 4;
              }
            }
            else
            {
              v82 |= 0x8000u;
              v63 = v9 + 4;
            }
            break;
          case 0x68u:
            v82 |= 0x20u;
            break;
          case 0x6Cu:
            if ( *(_WORD *)v9 == 108 )
            {
              v82 |= 0x1000u;
              v63 = v9 + 2;
            }
            else
            {
              v82 |= 0x10u;
            }
            break;
          case 0x77u:
            v82 |= 0x800u;
            break;
        }
        goto LABEL_214;
      case 0:
        goto LABEL_55;
      case 7:
        if ( (signed int)(unsigned __int16)v7 > 100 )
        {
          if ( (signed int)(unsigned __int16)v7 > 112 )
          {
            if ( (unsigned __int16)v7 != 115 )
            {
              if ( (unsigned __int16)v7 != 117 )
              {
                if ( (unsigned __int16)v7 != 120 )
                  goto LABEL_187;
                v61 = 39;
                goto LABEL_146;
              }
LABEL_117:
              v79 = (char *)10;
              goto LABEL_118;
            }
LABEL_71:
            v13 = v81;
            if ( v81 == -1 )
              v13 = 0x7FFFFFFF;
            v14 = v4 + 4;
            v78 = v14;
            v15 = *(unsigned __int16 **)(v14 - 4);
            v80 = v15;
            if ( v82 & 0x20 )
            {
              if ( !v15 )
                v80 = (unsigned __int16 *)__nullstring;
              v76 = 0;
              for ( i = (int *)v80; v76 < v13; ++v76 )
              {
                if ( !*(_BYTE *)i )
                  break;
                if ( _isleadbyte_l(*(_BYTE *)i, &Locale) )
                  i = (int *)((char *)i + 1);
                i = (int *)((char *)i + 1);
              }
            }
            else
            {
              if ( !v15 )
                v80 = __wnullstring;
              v49 = v80;
              v72 = 1;
              while ( v13 )
              {
                --v13;
                if ( !*v49 )
                  break;
                ++v49;
              }
              v21 = v49 - v80;
LABEL_186:
              v76 = v21;
            }
            goto LABEL_187;
          }
          if ( (unsigned __int16)v7 == 112 )
          {
            v81 = 8;
LABEL_141:
            v61 = 7;
LABEL_146:
            v79 = (char *)16;
            if ( v82 & 0x80 )
            {
              v69 = 48;
              v70 = v61 + 81;
              v74 = 2;
            }
            goto LABEL_118;
          }
          if ( (signed int)(unsigned __int16)v7 < 101 )
            goto LABEL_187;
          if ( (signed int)(unsigned __int16)v7 <= 103 )
            goto LABEL_65;
          if ( (unsigned __int16)v7 == 105 )
            goto LABEL_116;
          if ( (unsigned __int16)v7 != 110 )
          {
            if ( (unsigned __int16)v7 != 111 )
              goto LABEL_187;
            v79 = (char *)8;
            if ( v82 & 0x80 )
              v82 |= 0x200u;
LABEL_118:
            if ( v82 & 0x8000 || v82 & 0x1000 )
            {
              v26 = *(_QWORD *)v4;
              v27 = v4 + 8;
            }
            else
            {
              v27 = v4 + 4;
              if ( v82 & 0x20 )
              {
                v78 = v27;
                if ( v82 & 0x40 )
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                else
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                v26 = (signed int)v26;
LABEL_158:
                if ( v82 & 0x40 && v26 < 0 )
                {
                  v26 = -v26;
                  v82 |= 0x100u;
                }
                v41 = HIDWORD(v26);
                v42 = v26;
                if ( !(v82 & 0x9000) )
                  v41 = 0;
                if ( v81 >= 0 )
                {
                  v82 &= 0xFFFFFFF7;
                  if ( v81 > 512 )
                    v81 = 512;
                }
                else
                {
                  v81 = 1;
                }
                if ( !(v41 | (unsigned int)v26) )
                  v74 = 0;
                for ( j = v84; ; --j )
                {
                  v44 = v81--;
                  if ( v44 <= 0 && !(v41 | v42) )
                    break;
                  v45 = __PAIR__(v41, v42) % (signed int)v79 + 48;
                  v46 = __PAIR__(v41, v42) / (signed int)v79;
                  v41 = __PAIR__(v41, v42) / (signed int)v79 >> 32;
                  v42 = v46;
                  if ( v45 > 57 )
                    LOBYTE(v45) = v61 + v45;
                  *j = v45;
                }
                v47 = (char *)(v84 - j);
                v48 = (int)(j + 1);
                v76 = (int)v47;
                v80 = (unsigned __int16 *)v48;
                if ( v82 & 0x200 && (!v47 || *(_BYTE *)v48 != 48) )
                {
                  v80 = (unsigned __int16 *)((char *)v80 - 1);
                  *(_BYTE *)v80 = 48;
                  v21 = (int)(v47 + 1);
                  goto LABEL_186;
                }
LABEL_187:
                if ( v60 )
                  goto LABEL_212;
                if ( v82 & 0x40 )
                {
                  if ( v82 & 0x100 )
                  {
                    v53 = 45;
                    goto LABEL_195;
                  }
                  if ( v82 & 1 )
                  {
                    v53 = 43;
                    goto LABEL_195;
                  }
                  if ( v82 & 2 )
                  {
                    v53 = 32;
LABEL_195:
                    v69 = v53;
                    v74 = 1;
                  }
                }
                v50 = v76;
                v51 = v73 - v76 - v74;
                if ( !(v82 & 0xC) )
                  sub_6E67A507((int)&v77, 0x20u, v73 - v76 - v74, v75);
                sub_6E67A539((int)&v77, (wchar_t *)&v69, v75, v74);
                if ( v82 & 8 && !(v82 & 4) )
                  sub_6E67A507((int)&v77, 0x30u, v51, v75);
                if ( v72 || v50 <= 0 )
                {
                  sub_6E67A539((int)&v77, v80, v75, v50);
                }
                else
                {
                  v79 = (char *)v80;
                  v71 = v50;
                  while ( 1 )
                  {
                    --v71;
                    v54 = _mbtowc_l(v58, v79, (size_t)Locale.locinfo->locale_name[3], &Locale);
                    if ( v54 <= 0 )
                      break;
                    sub_6E67A4C8((int)&v77, v75, v58[0]);
                    v79 += v54;
                    if ( v71 <= 0 )
                      goto LABEL_209;
                  }
                  v77 = -1;
                }
LABEL_209:
                if ( v77 >= 0 && v82 & 4 )
                  sub_6E67A507((int)&v77, 0x20u, v51, v75);
                goto LABEL_212;
              }
              LODWORD(v26) = *(_DWORD *)(v27 - 4);
              if ( v82 & 0x40 )
                v26 = (signed int)v26;
              else
                HIDWORD(v26) = 0;
            }
            v78 = v27;
            goto LABEL_158;
          }
          v25 = *(_DWORD *)v4;
          v78 = v4 + 4;
          if ( !_get_printf_count_output() )
            goto LABEL_216;
          if ( v82 & 0x20 )
            *(_WORD *)v25 = v77;
          else
            *(_DWORD *)v25 = v77;
          v60 = 1;
LABEL_212:
          if ( Memory )
          {
            free(Memory);
            Memory = 0;
          }
LABEL_214:
          v5 = v63;
          v52 = (char *)*(_WORD *)v63;
          v79 = v52;
          if ( !(_WORD)v52 )
            goto LABEL_217;
          v8 = v57;
          v4 = v78;
          v7 = v52;
          continue;
        }
        if ( (unsigned __int16)v7 == 100 )
        {
LABEL_116:
          v82 |= 0x40u;
          goto LABEL_117;
        }
        if ( (signed int)(unsigned __int16)v7 <= 83 )
        {
          if ( (unsigned __int16)v7 == 83 )
          {
            if ( !(v82 & 0x830) )
              v82 |= 0x20u;
            goto LABEL_71;
          }
          if ( (unsigned __int16)v7 != 65 )
          {
            if ( (unsigned __int16)v7 != 67 )
            {
              if ( (unsigned __int16)v7 != 69 && (unsigned __int16)v7 != 71 )
                goto LABEL_187;
              goto LABEL_64;
            }
            if ( !(v82 & 0x830) )
              v82 |= 0x20u;
LABEL_86:
            v17 = *(_WORD *)v4;
            v72 = 1;
            v78 = v4 + 4;
            *(_DWORD *)v58 = v17;
            if ( v82 & 0x20 )
            {
              SrcCh = v17;
              v68 = 0;
              if ( _mbtowc_l(&DstCh, &SrcCh, (size_t)Locale.locinfo->locale_name[3], &Locale) < 0 )
                v60 = 1;
            }
            else
            {
              DstCh = v17;
            }
            v80 = &DstCh;
            v76 = 1;
            goto LABEL_187;
          }
LABEL_64:
          v7 += 32;
          v59 = 1;
          v79 = v7;
          goto LABEL_65;
        }
        if ( (unsigned __int16)v7 == 88 )
          goto LABEL_141;
        if ( (unsigned __int16)v7 != 90 )
        {
          if ( (unsigned __int16)v7 != 97 )
          {
            if ( (unsigned __int16)v7 != 99 )
              goto LABEL_187;
            goto LABEL_86;
          }
LABEL_65:
          v82 |= 0x40u;
          v12 = &DstCh;
          v80 = &DstCh;
          v71 = 512;
          if ( v81 >= 0 )
          {
            if ( v81 )
            {
              if ( v81 > 512 )
                v81 = 512;
              if ( v81 > 163 )
              {
                v28 = v81 + 349;
                v29 = malloc(v81 + 349);
                LOBYTE(v7) = (_BYTE)v79;
                Memory = v29;
                if ( v29 )
                {
                  v80 = (unsigned __int16 *)v29;
                  v71 = v28;
                  v12 = (wchar_t *)v29;
                }
                else
                {
                  v81 = 163;
                }
              }
            }
            else if ( (_WORD)v7 == 103 )
            {
              v81 = 1;
            }
          }
          else
          {
            v81 = 6;
          }
          v30 = *(_DWORD *)v4;
          v31 = v4 + 8;
          v55 = v30;
          v56 = *(_DWORD *)(v31 - 4);
          v32 = v59;
          v33 = v81;
          v78 = v31;
          v34 = (char)v7;
          v35 = v71;
          v36 = _decode_pointer((int)off_6E699A90[0]);
          ((void (__cdecl *)(int *, wchar_t *, int, int, int, int, struct localeinfo_struct *))v36)(
            &v55,
            v12,
            v35,
            v34,
            v33,
            v32,
            &Locale);
          v37 = v82 & 0x80;
          if ( v82 & 0x80 && !v81 )
          {
            v38 = _decode_pointer((int)off_6E699A9C);
            ((void (__cdecl *)(wchar_t *, struct localeinfo_struct *))v38)(v12, &Locale);
          }
          if ( (_WORD)v79 == 103 && !v37 )
          {
            v39 = _decode_pointer((int)off_6E699A98[0]);
            ((void (__cdecl *)(wchar_t *, struct localeinfo_struct *))v39)(v12, &Locale);
          }
          if ( *(_BYTE *)v12 == 45 )
          {
            v82 |= 0x100u;
            v12 = (wchar_t *)((char *)v12 + 1);
            v80 = v12;
          }
          v22 = (char *)v12;
          v23 = (int)((char *)v12 + 1);
          do
            v40 = *v22++;
          while ( v40 );
LABEL_101:
          v21 = (int)&v22[-v23];
          goto LABEL_186;
        }
        v18 = *(_DWORD *)v4;
        v78 = v4 + 4;
        if ( !v18 || (v19 = *(unsigned __int16 **)(v18 + 4)) == 0 )
        {
          v22 = __nullstring;
          v80 = (unsigned __int16 *)__nullstring;
          v23 = (int)(__nullstring + 1);
          do
            v24 = *v22++;
          while ( v24 );
          goto LABEL_101;
        }
        v20 = *(_WORD *)v18;
        if ( *(_WORD *)(v18 + 2) < *(_WORD *)v18 )
          goto LABEL_216;
        v21 = v20;
        if ( !(v82 & 0x800) )
        {
          v72 = 0;
          v80 = v19;
          goto LABEL_186;
        }
        if ( ~(_BYTE)v20 & 1 && ~(_BYTE)v19 & 1 )
        {
          v80 = v19;
          v21 = (unsigned int)v20 >> 1;
          v72 = 1;
          goto LABEL_186;
        }
LABEL_216:
        *_errno() = 22;
LABEL_3:
        _invalid_parameter(0, 0, 0, 0, 0);
        if ( v66 )
          *(_DWORD *)(v65 + 112) &= 0xFFFFFFFD;
        return -1;
      default:
        goto LABEL_214;
    }
  }
}
// 6E65C970: using guessed type const char *const __lookuptable;
// 6E699A90: using guessed type int (*off_6E699A90[4])();
// 6E699A98: using guessed type int (*off_6E699A98[2])();
// 6E699A9C: using guessed type int (*off_6E699A9C)();
// 6E69B884: using guessed type char *__nullstring;
// 6E69B888: using guessed type unsigned __int16 *__wnullstring;
// 6E67A590: using guessed type char var_205[513];

//----- (6E67B203) --------------------------------------------------------
int __cdecl sub_6E67B203(LCID Locale, DWORD dwMapFlags, wchar_t *Src, size_t MaxCount, LPWSTR lpDestStr, int cchDest, UINT CodePage)
{
  int v7; // ecx@0
  const char *v8; // ebx@1
  int v9; // edi@1
  UINT v11; // eax@16
  unsigned int v12; // eax@19
  int v13; // edi@19
  int v14; // eax@23
  void *v15; // esp@24
  CHAR *v16; // eax@24
  int v17; // eax@33
  int v18; // esi@33
  int v19; // eax@36
  void *v20; // esp@37
  void *v21; // eax@37
  int v22; // eax@52
  signed int v23; // [sp+0h] [bp-1Ch]@24
  int cchSrc; // [sp+Ch] [bp-10h]@19
  int v25; // [sp+10h] [bp-Ch]@12
  LPSTR lpMultiByteStr; // [sp+14h] [bp-8h]@29

  v8 = 0;
  v9 = v7;
  if ( !dword_6E69BD54 )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_6E69BD54 = 1;
    }
    else if ( GetLastError() == 120 )
    {
      dword_6E69BD54 = 2;
    }
  }
  if ( (signed int)MaxCount > 0 )
    MaxCount = wcsnlen(Src, MaxCount);
  if ( dword_6E69BD54 == 1 )
    return LCMapStringW(Locale, dwMapFlags, Src, MaxCount, lpDestStr, cchDest);
  if ( dword_6E69BD54 != 2 && dword_6E69BD54 )
    return 0;
  v25 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)v9 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)v9 + 4);
  v11 = __ansicp(Locale);
  if ( CodePage != v11 && v11 != -1 )
    CodePage = v11;
  v12 = WideCharToMultiByte(CodePage, 0, Src, MaxCount, 0, 0, 0, 0);
  v13 = v12;
  cchSrc = v12;
  if ( !v12 )
    return 0;
  if ( (signed int)v12 > 0 && 0xFFFFFFE0 / v12 >= 1 )
  {
    v14 = v12 + 8;
    if ( (unsigned int)(v13 + 8) > 0x400 )
    {
      v16 = (CHAR *)malloc(v13 + 8);
      if ( v16 )
      {
        *(_DWORD *)v16 = 56797;
        goto LABEL_28;
      }
    }
    else
    {
      v15 = alloca(v14);
      v16 = (CHAR *)&v23;
      if ( &v23 )
      {
        v23 = 52428;
LABEL_28:
        v16 += 8;
        goto LABEL_29;
      }
    }
LABEL_29:
    lpMultiByteStr = v16;
    goto LABEL_31;
  }
  lpMultiByteStr = 0;
LABEL_31:
  if ( !lpMultiByteStr )
    return 0;
  if ( WideCharToMultiByte(CodePage, 0, Src, MaxCount, lpMultiByteStr, v13, 0, 0) )
  {
    v17 = LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, v13, 0, 0);
    v18 = v17;
    if ( v17 )
    {
      if ( v17 <= 0 || 0xFFFFFFE0 / v17 < 1 )
      {
LABEL_43:
        if ( v8 )
        {
          if ( LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cchSrc, (LPSTR)v8, v18) )
          {
            if ( dwMapFlags & 0x400 )
            {
              v25 = v18;
              if ( cchDest )
              {
                if ( cchDest <= v18 )
                  v18 = cchDest - 1;
                if ( strncpy_s((char *)lpDestStr, cchDest, v8, v18) )
                  _invoke_watson(0, 0, 0, 0, 0);
              }
            }
            else
            {
              if ( cchDest )
                v22 = MultiByteToWideChar(CodePage, 1u, v8, v18, lpDestStr, cchDest);
              else
                v22 = MultiByteToWideChar(CodePage, 1u, v8, v18, 0, 0);
              v25 = v22;
            }
          }
          _freea((void *)v8);
        }
        goto LABEL_56;
      }
      v19 = v17 + 8;
      if ( (unsigned int)(v18 + 8) > 0x400 )
      {
        v21 = malloc(v18 + 8);
        if ( v21 )
        {
          *(_DWORD *)v21 = 56797;
          goto LABEL_41;
        }
      }
      else
      {
        v20 = alloca(v19);
        v21 = &v23;
        if ( &v23 )
        {
          v23 = 52428;
LABEL_41:
          v21 = (char *)v21 + 8;
          goto LABEL_42;
        }
      }
LABEL_42:
      v8 = (const char *)v21;
      goto LABEL_43;
    }
  }
LABEL_56:
  _freea(lpMultiByteStr);
  return v25;
}
// 6E69BD54: using guessed type int dword_6E69BD54;

//----- (6E67B4CA) --------------------------------------------------------
void __cdecl _NMSG_WRITE(int a1)
{
  unsigned int v1; // esi@1
  HANDLE v2; // eax@21
  DWORD NumberOfBytesWritten; // [sp+Ch] [bp-8h]@23
  unsigned int v4; // [sp+10h] [bp-4h]@1

  v1 = 0;
  v4 = 0;
  do
  {
    if ( a1 == dword_6E69B898[2 * v1] )
      break;
    ++v1;
    v4 = v1;
  }
  while ( v1 < 0x17 );
  if ( v1 < 0x17 )
  {
    if ( _set_error_mode(3) != 1 && (_set_error_mode(3) || __app_type != 1) )
    {
      if ( a1 != 252 )
      {
        if ( strcpy_s(Dst, 0x314u, "Runtime Error!\n\nProgram: ") )
          _invoke_watson(0, 0, 0, 0, 0);
        byte_6E69BE75 = 0;
        if ( !GetModuleFileNameA(0, byte_6E69BD71, 0x104u) && strcpy_s(byte_6E69BD71, 0x2FBu, "<program name unknown>") )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, byte_6E69BD71) )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, "\n\n") )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, (const char *)*(&lpBuffer + 2 * v4)) )
          _invoke_watson(0, 0, 0, 0, 0);
        __crtMessageBoxA((int)Dst, (int)"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      v2 = GetStdHandle(0xFFFFFFF4);
      if ( v2 && v2 != (HANDLE)-1 )
        WriteFile(v2, *(&lpBuffer + 2 * v1), strlen((const char *)*(&lpBuffer + 2 * v1)), &NumberOfBytesWritten, 0);
    }
  }
}
// 6E69B898: using guessed type int dword_6E69B898[];
// 6E69BD2C: using guessed type int __app_type;
// 6E69BE75: using guessed type char byte_6E69BE75;

//----- (6E67B729) --------------------------------------------------------
int __get_sigabrt()
{
  return _decode_pointer(dword_6E6991B8);
}
// 6E6991B8: using guessed type int dword_6E6991B8;

//----- (6E67B911) --------------------------------------------------------
int __stdcall sub_6E67B911(LPCRITICAL_SECTION lpCriticalSection, int a2)
{
  InitializeCriticalSection(lpCriticalSection);
  return 1;
}

//----- (6E67C32A) --------------------------------------------------------
int __cdecl isdigit(int C)
{
  signed int v1; // eax@2
  wchar_t v2; // ax@4
  int result; // eax@4

  if ( __locale_changed )
  {
    result = _isdigit_l(C, 0);
  }
  else
  {
    v1 = -1;
    if ( C != -1 )
      v1 = (unsigned __int8)C;
    v2 = off_6E699620[v1];
    result = v2 & 4;
  }
  return result;
}
// 6E699620: using guessed type wchar_t *off_6E699620;
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E67C60B) --------------------------------------------------------
int __cdecl _fptostr(void *Dst, int a2, int a3, int a4)
{
  int v4; // ecx@1
  char v5; // bl@1
  signed int v6; // esi@2
  int v8; // esi@5
  int v9; // eax@6
  char *v10; // eax@10
  char v11; // cl@11
  char *v12; // eax@24
  char v13; // cl@25
  char *v14; // [sp+8h] [bp-4h]@1

  v4 = a4;
  v5 = 0;
  v14 = *(char **)(a4 + 12);
  if ( !Dst || (unsigned int)a2 <= 0 )
  {
    v6 = 22;
    *_errno() = 22;
LABEL_3:
    _invalid_parameter(0, 0, 0, 0, 0);
    return v6;
  }
  v8 = a3;
  *(_BYTE *)Dst = 0;
  if ( a3 <= 0 )
    v9 = 0;
  else
    v9 = a3;
  if ( a2 <= (unsigned int)(v9 + 1) )
  {
    *_errno() = 34;
    v6 = 34;
    goto LABEL_3;
  }
  *(_BYTE *)Dst = 48;
  v10 = (char *)Dst + 1;
  if ( a3 > 0 )
  {
    do
    {
      v11 = *v14;
      if ( *v14 == v5 )
      {
        v11 = 48;
      }
      else
      {
        ++v14;
        v5 = 0;
      }
      *v10++ = v11;
      --v8;
    }
    while ( v8 > 0 );
    v4 = a4;
  }
  *v10 = 0;
  if ( v8 >= 0 && *v14 >= 53 )
  {
    while ( 1 )
    {
      --v10;
      if ( *v10 != 57 )
        break;
      *v10 = 48;
    }
    ++*v10;
  }
  if ( *(_BYTE *)Dst == 49 )
  {
    ++*(_DWORD *)(v4 + 4);
  }
  else
  {
    v12 = (char *)Dst + 1;
    do
      v13 = *v12++;
    while ( v13 );
    memmove(Dst, (char *)Dst + 1, v12 - ((_BYTE *)Dst + 2) + 1);
  }
  return 0;
}

//----- (6E67D5EE) --------------------------------------------------------
int __cdecl wctomb(char *MbCh, wchar_t WCh)
{
  int result; // eax@2
  int SizeConverted; // [sp+0h] [bp-4h]@1

  SizeConverted = -1;
  if ( _wctomb_s_l(&SizeConverted, MbCh, __mb_cur_max, WCh, 0) )
    result = -1;
  else
    result = SizeConverted;
  return result;
}

//----- (6E67D6AF) --------------------------------------------------------
__int64 __cdecl _lseeki64(int Filehandle, __int64 a2, int dwMoveMethod)
{
  __int64 result; // rax@3
  int *v4; // ebx@7
  int v5; // esi@7
  int v6; // edx@10
  __int64 v7; // [sp+10h] [bp-24h]@10

  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1i64;
  }
  if ( Filehandle < 0 || Filehandle >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1i64;
  }
  v4 = &__pioinfo[Filehandle >> 5];
  v5 = 36 * (Filehandle & 0x1F);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    __lock_fhandle(Filehandle);
    if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
    {
      LODWORD(v7) = _lseeki64_nolock(Filehandle, a2, SHIDWORD(a2), dwMoveMethod);
      HIDWORD(v7) = v6;
    }
    else
    {
      *_errno() = 9;
      *__doserrno() = 0;
      v7 = -1i64;
    }
    _unlock_fhandle(Filehandle);
    result = v7;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1i64;
  }
  return result;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E67D7F1) --------------------------------------------------------
int __cdecl _write_nolock(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int v4; // ebx@5
  int *v5; // edi@5
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // esi@13
  UINT v9; // eax@16
  char *v10; // esi@16
  int v11; // ST1C_4@19
  int v12; // eax@25
  signed int v13; // esi@25
  int v14; // eax@29
  int v15; // ecx@34
  __int16 v16; // ax@37
  int v17; // eax@43
  unsigned int v18; // esi@46
  DWORD v19; // ecx@46
  char *v20; // eax@46
  int v21; // edx@48
  char v22; // dl@48
  int v23; // esi@51
  char *v24; // edi@56
  unsigned int v25; // esi@57
  DWORD v26; // ecx@57
  char *v27; // eax@57
  __int16 v28; // dx@59
  int v29; // esi@65
  unsigned int v30; // esi@71
  DWORD v31; // ecx@71
  WCHAR *v32; // eax@71
  DWORD v33; // edx@73
  WCHAR v34; // dx@73
  int v35; // esi@79
  int v36; // edi@79
  UINT CodePage; // [sp+4h] [bp-594h]@16
  int v38; // [sp+8h] [bp-590h]@16
  DWORD Mode; // [sp+Ch] [bp-58Ch]@13
  int v40; // [sp+10h] [bp-588h]@5
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-584h]@16
  int *v42; // [sp+18h] [bp-580h]@5
  DWORD v43; // [sp+1Ch] [bp-57Ch]@51
  int v44; // [sp+20h] [bp-578h]@1
  char *SrcCh; // [sp+24h] [bp-574h]@1
  DWORD v46; // [sp+28h] [bp-570h]@1
  wchar_t DstCh[2]; // [sp+2Ch] [bp-56Ch]@20
  DWORD v48; // [sp+30h] [bp-568h]@17
  char Buffer; // [sp+34h] [bp-564h]@46
  CHAR v50[688]; // [sp+188h] [bp-410h]@79
  WCHAR WideCharStr; // [sp+438h] [bp-160h]@71
  CHAR MultiByteStr; // [sp+58Ch] [bp-Ch]@25

  SrcCh = (char *)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = 36 * (a1 & 0x1F);
  v5 = &__pioinfo[a1 >> 5];
  v6 = v4 + *v5;
  v7 = *(_DWORD *)(v6 + 8) & 3;
  v42 = &__pioinfo[a1 >> 5];
  v40 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    _lseeki64_nolock(a1, 0, 0, 2u);
  if ( _isatty(a1) )
  {
    if ( *(_BYTE *)(v4 + *v5 + 4) & 0x80 )
    {
      v8 = *(_DWORD *)(*(_DWORD *)(_getptd() + 108) + 20) == 0;
      if ( GetConsoleMode(*(HANDLE *)(v4 + *v5), &Mode) )
      {
        if ( !v8 || v40 )
        {
          v9 = GetConsoleCP();
          NumberOfBytesWritten = 0;
          v10 = SrcCh;
          CodePage = v9;
          v38 = (int)SrcCh;
          if ( nNumberOfBytesToWrite )
          {
            v48 = 0;
            while ( 1 )
            {
              if ( v40 )
              {
                if ( v40 == 1 || v40 == 2 )
                {
                  v15 = *(_WORD *)v10;
                  v48 += 2;
                  *(_DWORD *)DstCh = v15;
                  v38 = (int)(v10 + 2);
                  Mode = (_WORD)v15 == 10;
                }
                if ( v40 == 1 || v40 == 2 )
                {
                  v16 = _putwch_nolock(DstCh[0]);
                  if ( v16 != DstCh[0] )
                    goto LABEL_89;
                  ++v46;
                  if ( Mode )
                  {
                    *(_DWORD *)DstCh = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    ++v46;
                    ++v44;
                  }
                }
              }
              else
              {
                v11 = *v10;
                Mode = *v10 == 10;
                if ( isleadbyte(v11) )
                {
                  if ( nNumberOfBytesToWrite + SrcCh - v10 <= 1 || mbtowc(DstCh, v10, 2u) == -1 )
                    goto LABEL_90;
                  ++v10;
                  ++v48;
                }
                else if ( mbtowc(DstCh, v10, 1u) == -1 )
                {
                  goto LABEL_90;
                }
                ++v48;
                v38 = (int)(v10 + 1);
                v12 = WideCharToMultiByte(CodePage, 0, DstCh, 1, &MultiByteStr, 5, 0, 0);
                v13 = v12;
                if ( !v12 )
                  goto LABEL_90;
                if ( !WriteFile(*(HANDLE *)(v4 + *v5), &MultiByteStr, v12, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                v46 += NumberOfBytesWritten;
                if ( (signed int)NumberOfBytesWritten < v13 )
                  goto LABEL_90;
                if ( Mode )
                {
                  v14 = *v5;
                  MultiByteStr = 13;
                  if ( !WriteFile(*(HANDLE *)(v4 + v14), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                    goto LABEL_89;
                  if ( (signed int)NumberOfBytesWritten < 1 )
                    goto LABEL_90;
                  ++v44;
                  ++v46;
                }
              }
              if ( v48 >= nNumberOfBytesToWrite )
                goto LABEL_90;
              v10 = (char *)v38;
            }
          }
LABEL_91:
          if ( *(_DWORD *)DstCh )
          {
            if ( *(_DWORD *)DstCh == 5 )
            {
              *_errno() = 9;
              *__doserrno() = 5;
            }
            else
            {
              _dosmaperr(*(_DWORD *)DstCh);
            }
            return -1;
          }
LABEL_95:
          if ( *(_BYTE *)(v4 + *v42 + 4) & 0x40 && *SrcCh == 26 )
            return 0;
          *_errno() = 28;
          *__doserrno() = 0;
          return -1;
        }
      }
    }
  }
  v17 = v4 + *v5;
  if ( *(_BYTE *)(v17 + 4) & 0x80 )
  {
    *(_DWORD *)DstCh = 0;
    if ( v40 )
    {
      if ( v40 == 2 )
      {
        v24 = SrcCh;
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_95;
        while ( 1 )
        {
          v25 = 0;
          v26 = v24 - SrcCh;
          v27 = &Buffer;
          while ( v26 < nNumberOfBytesToWrite )
          {
            v28 = *(_WORD *)v24;
            v24 += 2;
            v26 += 2;
            if ( v28 == 10 )
            {
              if ( v25 > 0x3FD )
              {
                v24 -= 2;
                break;
              }
              v44 += 2;
              *(_WORD *)v27 = 13;
              v4 = 36 * (a1 & 0x1F);
              v27 += 2;
              v25 += 2;
            }
            *(_WORD *)v27 = v28;
            v27 += 2;
            v25 += 2;
            if ( v25 >= 0x3FF )
              break;
          }
          v29 = v27 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v4 + *v42), &Buffer, v27 - &Buffer, &v43, 0) )
            break;
          v46 += v43;
          if ( (signed int)v43 < v29 || !v43 || v24 - SrcCh >= nNumberOfBytesToWrite )
            goto LABEL_90;
        }
      }
      else
      {
        v48 = (DWORD)SrcCh;
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_95;
        while ( 1 )
        {
          v30 = 0;
          v31 = v48 - (_DWORD)SrcCh;
          v32 = &WideCharStr;
          while ( v31 < nNumberOfBytesToWrite )
          {
            v33 = v48;
            v48 += 2;
            v34 = *(_WORD *)v33;
            v31 += 2;
            if ( v34 == 10 )
            {
              if ( v30 > 0x150 )
              {
                v48 -= 2;
                break;
              }
              *v32 = 13;
              ++v32;
              v30 += 2;
            }
            *v32 = v34;
            ++v32;
            v30 += 2;
            if ( v30 >= 0x152 )
              break;
          }
          v35 = 0;
          v36 = WideCharToMultiByte(0xFDE9u, 0, &WideCharStr, v32 - &WideCharStr, v50, 683, 0, 0);
          if ( !v36 )
            break;
          while ( WriteFile(*(HANDLE *)(v4 + *v42), &v50[v35], v36 - v35, &v43, 0) )
          {
            v35 += v43;
            if ( v36 <= v35 )
              goto LABEL_84;
          }
          *(_DWORD *)DstCh = GetLastError();
LABEL_84:
          if ( v36 <= v35 )
          {
            v46 = v48 - (_DWORD)SrcCh;
            if ( v48 - (unsigned int)SrcCh < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      v48 = (DWORD)SrcCh;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_95;
      while ( 1 )
      {
        v18 = 0;
        v19 = v48 - (_DWORD)SrcCh;
        v20 = &Buffer;
        do
        {
          if ( v19 >= nNumberOfBytesToWrite )
            break;
          v21 = v48++;
          v22 = *(_BYTE *)v21;
          ++v19;
          if ( v22 == 10 )
          {
            ++v44;
            *v20++ = 13;
            ++v18;
          }
          v5 = v42;
          *v20++ = v22;
          ++v18;
        }
        while ( v18 < 0x400 );
        v23 = v20 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v4 + *v5), &Buffer, v20 - &Buffer, &v43, 0) )
          break;
        v46 += v43;
        if ( (signed int)v43 < v23 || v48 - (unsigned int)SrcCh >= nNumberOfBytesToWrite )
          goto LABEL_90;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v17, SrcCh, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)DstCh = 0;
    v46 = v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)DstCh = GetLastError();
LABEL_90:
  if ( !v46 )
    goto LABEL_91;
  return v46 - v44;
}
// 6E676F13: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E67DED0) --------------------------------------------------------
int __cdecl _write(int Filehandle, const void *a2, unsigned int nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  signed int v6; // [sp+14h] [bp-1Ch]@9

  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0
    || Filehandle >= _nhandle
    || (v4 = &__pioinfo[Filehandle >> 5], v5 = 36 * (Filehandle & 0x1F), !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  __lock_fhandle(Filehandle);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = _write_nolock(Filehandle, (int)a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = -1;
  }
  _unlock_fhandle(Filehandle);
  return v6;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E67DFD9) --------------------------------------------------------
int __cdecl _getbuf(int a1)
{
  void *v1; // eax@1
  int result; // eax@4

  ++_cflush;
  v1 = calloc(1u, 0x1000u);
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 12) |= 8u;
    *(_DWORD *)(a1 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 12) |= 4u;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = result;
  return result;
}
// 6E69BD48: using guessed type int _cflush;

//----- (6E67E066) --------------------------------------------------------
wint_t __cdecl _fputwc_nolock(wchar_t Ch, FILE *File)
{
  int *v2; // ebx@4
  int v3; // eax@4
  int *v4; // ebx@9
  int v5; // eax@9
  bool v6; // sf@12
  int v7; // eax@13
  wint_t result; // ax@16
  int v9; // eax@18
  int *v10; // ebx@24
  int v11; // eax@24
  int i; // ebx@28
  int v13; // eax@30
  int SizeConverted; // [sp+Ch] [bp-10h]@27
  char MbCh[8]; // [sp+10h] [bp-Ch]@27

  if ( File->_flag & 0x40 )
    goto LABEL_40;
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v3 = (int)__badioinfo;
  }
  else
  {
    v2 = &__pioinfo[_fileno(File) >> 5];
    v3 = *v2 + 36 * (_fileno(File) & 0x1F);
  }
  if ( (*(_DWORD *)(v3 + 8) & 3) == 2 )
    goto LABEL_40;
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v5 = (int)__badioinfo;
  }
  else
  {
    v4 = &__pioinfo[_fileno(File) >> 5];
    v5 = *v4 + 36 * (_fileno(File) & 0x1F);
  }
  if ( (*(_DWORD *)(v5 + 8) & 3) == 1 )
  {
    v6 = File->_cnt-- - 1 < 0;
    if ( v6 )
    {
      v7 = _flsbuf((char)Ch, File);
    }
    else
    {
      *File->_ptr = Ch;
      v7 = *File->_ptr++;
    }
    if ( v7 != -1 )
    {
      v6 = File->_cnt-- - 1 < 0;
      if ( v6 )
      {
        v9 = _flsbuf(SHIBYTE(Ch), File);
      }
      else
      {
        *File->_ptr = HIBYTE(Ch);
        v9 = *File->_ptr++;
      }
      if ( v9 != -1 )
        return Ch;
    }
    return -1;
  }
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v11 = (int)__badioinfo;
  }
  else
  {
    v10 = &__pioinfo[_fileno(File) >> 5];
    v11 = *v10 + 36 * (_fileno(File) & 0x1F);
  }
  if ( !(*(_BYTE *)(v11 + 4) & 0x80) )
  {
LABEL_40:
    v6 = File->_cnt - 2 < 0;
    File->_cnt -= 2;
    if ( v6 )
    {
      result = _flswbuf(Ch, File);
    }
    else
    {
      result = Ch;
      *(_WORD *)File->_ptr = Ch;
      File->_ptr += 2;
    }
  }
  else
  {
    if ( wctomb_s(&SizeConverted, MbCh, 5u, Ch) )
      return -1;
    for ( i = 0; i < SizeConverted; ++i )
    {
      v6 = File->_cnt-- - 1 < 0;
      if ( v6 )
      {
        v13 = _flsbuf(MbCh[i], File);
      }
      else
      {
        *File->_ptr = MbCh[i];
        v13 = *File->_ptr++;
      }
      if ( v13 == -1 )
        return -1;
    }
    result = Ch;
  }
  return result;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69B624: using guessed type int __badioinfo[9];
// 6E67E066: using guessed type char MbCh[8];

//----- (6E67E29A) --------------------------------------------------------
void *__cdecl __convertcp(UINT CodePage, UINT a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@6
  bool v7; // zf@8
  bool v8; // sf@8
  int v9; // eax@11
  void *v10; // esp@12
  void *v11; // eax@12
  LPSTR v13; // edi@23
  void *v14; // eax@28
  int v15; // eax@29
  signed int v16; // [sp+0h] [bp-40h]@12
  LPSTR v17; // [sp+Ch] [bp-34h]@1
  int v18; // [sp+10h] [bp-30h]@1
  int v19; // [sp+14h] [bp-2Ch]@1
  LPCSTR lpMultiByteStr; // [sp+18h] [bp-28h]@1
  int cbMultiByte; // [sp+1Ch] [bp-24h]@1
  void *Memory; // [sp+20h] [bp-20h]@1
  void *Dst; // [sp+24h] [bp-1Ch]@19
  struct _cpinfo CPInfo; // [sp+28h] [bp-18h]@2

  lpMultiByteStr = (LPCSTR)a3;
  v18 = a4;
  cbMultiByte = *(_DWORD *)a4;
  v17 = (LPSTR)a5;
  Memory = 0;
  v19 = 0;
  if ( CodePage != a2 )
  {
    if ( GetCPInfo(CodePage, &CPInfo) && CPInfo.MaxCharSize == 1 && GetCPInfo(a2, &CPInfo) && CPInfo.MaxCharSize == 1 )
    {
      v6 = cbMultiByte;
      v19 = 1;
      if ( cbMultiByte == -1 )
        v6 = strlen(lpMultiByteStr) + 1;
      v7 = v6 == 0;
      v8 = v6 < 0;
    }
    else
    {
      v6 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, 0, 0);
      v7 = v6 == 0;
      v8 = v6 < 0;
      if ( !v6 )
        return 0;
    }
    if ( v8 || v7 || (unsigned int)v6 > 0x7FFFFFF0 )
    {
      Dst = 0;
LABEL_21:
      if ( Dst )
      {
        memset(Dst, 0, 2 * v6);
        if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)Dst, v6) )
        {
          v13 = v17;
          if ( v17 )
          {
            if ( WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, v17, a6, 0, 0) )
              Memory = v13;
          }
          else if ( v19 || (v6 = WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, 0, 0, 0, 0)) != 0 )
          {
            v14 = calloc(1u, v6);
            Memory = v14;
            if ( v14 )
            {
              v15 = WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, (LPSTR)v14, v6, 0, 0);
              if ( v15 )
              {
                if ( cbMultiByte != -1 )
                  *(_DWORD *)v18 = v15;
              }
              else
              {
                free(Memory);
                Memory = 0;
              }
            }
          }
        }
        _freea(Dst);
        return Memory;
      }
      return 0;
    }
    v9 = 2 * v6 + 8;
    if ( (unsigned int)v9 > 0x400 )
    {
      v11 = malloc(2 * v6 + 8);
      if ( v11 )
      {
        *(_DWORD *)v11 = 56797;
        goto LABEL_18;
      }
    }
    else
    {
      v10 = alloca(v9);
      v11 = &v16;
      if ( &v16 )
      {
        v16 = 52428;
LABEL_18:
        v11 = (char *)v11 + 8;
        goto LABEL_19;
      }
    }
LABEL_19:
    Dst = v11;
    goto LABEL_21;
  }
  return Memory;
}

//----- (6E67E459) --------------------------------------------------------
int __cdecl sub_6E67E459(int a1, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale)
{
  signed int v8; // eax@3
  UINT v9; // eax@17
  unsigned int v10; // eax@20
  size_t v11; // esi@20
  int v12; // eax@23
  void *v13; // esp@24
  void *v14; // eax@24
  int v15; // eax@35
  void *v16; // esp@36
  WORD *v17; // eax@36
  WORD *v18; // ST1C_4@46
  int v19; // ST18_4@46
  const CHAR *v20; // ST14_4@46
  WORD *v21; // esi@46
  signed int v22; // [sp+0h] [bp-20h]@24
  int v23; // [sp+Ch] [bp-14h]@20
  int v24; // [sp+10h] [bp-10h]@13
  LPWORD v25; // [sp+14h] [bp-Ch]@41
  WORD CharType[2]; // [sp+18h] [bp-8h]@4

  if ( cchSrc < -1 )
    return 0;
  v8 = dword_6E69C080;
  if ( !dword_6E69C080 )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, CharType) )
    {
      dword_6E69C080 = 1;
      return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
    }
    if ( GetLastError() == 120 )
    {
      v8 = 2;
      dword_6E69C080 = 2;
    }
    else
    {
      v8 = dword_6E69C080;
    }
  }
  if ( v8 == 1 )
    return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
  if ( v8 != 2 && v8 )
    return 0;
  v24 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v9 = __ansicp(Locale);
  if ( CodePage != v9 && v9 != -1 )
    CodePage = v9;
  v10 = WideCharToMultiByte(CodePage, 0, lpSrcStr, cchSrc, 0, 0, 0, 0);
  v11 = v10;
  v23 = v10;
  if ( !v10 )
    return 0;
  if ( (signed int)v10 > 0 && v10 <= 0xFFFFFFE0 )
  {
    v12 = v10 + 8;
    if ( v11 + 8 > 0x400 )
    {
      v14 = malloc(v11 + 8);
      if ( v14 )
      {
        *(_DWORD *)v14 = 56797;
        goto LABEL_28;
      }
    }
    else
    {
      v13 = alloca(v12);
      v14 = &v22;
      if ( &v22 )
      {
        v22 = 52428;
LABEL_28:
        v14 = (char *)v14 + 8;
        goto LABEL_29;
      }
    }
LABEL_29:
    *(_DWORD *)CharType = v14;
    goto LABEL_31;
  }
  *(_DWORD *)CharType = 0;
LABEL_31:
  if ( !*(_DWORD *)CharType )
    return 0;
  memset(*(void **)CharType, 0, v11);
  if ( !WideCharToMultiByte(CodePage, 0, lpSrcStr, cchSrc, *(LPSTR *)CharType, v11, 0, 0) )
    goto LABEL_51;
  if ( (signed int)(v11 + 1) > 0 && v11 + 1 <= 0x7FFFFFF0 )
  {
    v15 = 2 * v11 + 10;
    if ( (unsigned int)v15 > 0x400 )
    {
      v17 = (WORD *)malloc(2 * v11 + 10);
      if ( v17 )
      {
        *(_DWORD *)v17 = 56797;
        goto LABEL_40;
      }
    }
    else
    {
      v16 = alloca(v15);
      v17 = (WORD *)&v22;
      if ( &v22 )
      {
        v22 = 52428;
LABEL_40:
        v17 += 4;
        goto LABEL_41;
      }
    }
LABEL_41:
    v25 = v17;
    goto LABEL_43;
  }
  v25 = 0;
LABEL_43:
  if ( v25 )
  {
    if ( !Locale )
      Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
    v18 = v25;
    v19 = v23;
    v20 = *(const CHAR **)CharType;
    v21 = &v25[cchSrc];
    *v21 = -1;
    *(v21 - 1) = -1;
    v24 = GetStringTypeA(Locale, dwInfoType, v20, v19, v18);
    if ( *(v21 - 1) == -1 || *v21 != -1 )
      v24 = 0;
    else
      memmove(lpCharType, v25, 2 * cchSrc);
    _freea(v25);
  }
LABEL_51:
  _freea(*(void **)CharType);
  return v24;
}
// 6E69C080: using guessed type int dword_6E69C080;

//----- (6E67E687) --------------------------------------------------------
int __cdecl __crtGetStringTypeW(struct localeinfo_struct *a1, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale)
{
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@1
  int v9; // [sp+8h] [bp-8h]@2
  char v10; // [sp+Ch] [bp-4h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v8, a1);
  result = sub_6E67E459((int)&v8, dwInfoType, lpSrcStr, cchSrc, lpCharType, CodePage, Locale);
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFD;
  return result;
}

//----- (6E67E781) --------------------------------------------------------
int __cdecl _safecrt_cfltcvt(int a1, char *a2, size_t Count, int a4, int Value, char a6)
{
  signed int v6; // eax@1
  unsigned int v7; // kr00_4@5
  char *v8; // esi@5
  int v9; // eax@5
  int result; // eax@7
  char Format; // [sp+14h] [bp-24h]@3
  char Dest[31]; // [sp+15h] [bp-23h]@4

  v6 = 1;
  if ( a6 & 1 )
    a4 -= 32;
  Format = 37;
  if ( a6 & 0x80 )
  {
    Dest[0] = 35;
    v6 = 2;
  }
  *(&Format + v6) = 46;
  _itoa(Value, &Dest[v6], 10);
  v7 = strlen(&Format);
  *(&Format + v7) = a4;
  Dest[v7] = 0;
  v8 = &a2[Count - 1];
  *v8 = 0;
  v9 = _snprintf(a2, Count, &Format, *(double *)a1);
  if ( *v8 || v9 <= 0 )
  {
    *a2 = 0;
    result = 22;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6E67E781: using guessed type char Dest[31];

//----- (6E67E835) --------------------------------------------------------
int __cdecl _safecrt_wctomb_s(int a1, void *Dst, size_t Size, wchar_t WCh)
{
  int *v4; // eax@8
  signed int v5; // esi@9
  int v7; // eax@10
  signed int v8; // [sp-4h] [bp-1Ch]@8
  char MbCh; // [sp+Ch] [bp-Ch]@10

  if ( !Dst && Size > 0 )
  {
    if ( a1 )
      *(_DWORD *)a1 = 0;
    return 0;
  }
  if ( a1 )
    *(_DWORD *)a1 = -1;
  if ( Size > 0x7FFFFFFF )
  {
    v4 = _errno();
    v8 = 22;
    goto LABEL_9;
  }
  v7 = wctomb(&MbCh, WCh);
  if ( v7 >= 0 )
  {
    if ( a1 )
      *(_DWORD *)a1 = v7;
    if ( (signed int)Size >= v7 )
    {
      if ( Dst )
        memcpy(Dst, &MbCh, v7);
      return 0;
    }
    if ( Dst && Size > 0 )
      memset(Dst, 0, Size);
    v4 = _errno();
    v8 = 34;
LABEL_9:
    v5 = v8;
    *v4 = v8;
    _invalid_parameter(0, 0, 0, 0, 0);
    return v5;
  }
  if ( Dst && Size > 0 )
    memset(Dst, 0, Size);
  *_errno() = 42;
  return 42;
}

//----- (6E67E91F) --------------------------------------------------------
int __cdecl _output_s(FILE *a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int *v5; // eax@2
  char v7; // cl@6
  int v8; // eax@9
  unsigned int v9; // eax@11
  int v10; // eax@25
  int v11; // eax@30
  char v12; // al@42
  char v13; // al@56
  int v14; // ecx@73
  int v15; // edi@75
  char *v16; // edi@75
  char *v17; // eax@78
  int v18; // edi@83
  int v19; // eax@88
  char *v20; // esi@89
  unsigned __int16 v21; // cx@90
  int v22; // eax@91
  char *v23; // eax@96
  char *v24; // edx@96
  char v25; // cl@97
  __int64 v26; // rax@111
  int v27; // edi@111
  size_t v28; // esi@118
  void *v29; // eax@118
  int v30; // eax@124
  char *v31; // esi@124
  int v32; // edi@124
  char v33; // cl@127
  unsigned int v34; // ebx@150
  unsigned int v35; // edi@150
  char *i; // esi@158
  int v37; // eax@159
  unsigned __int64 v38; // ST08_8@161
  unsigned __int64 v39; // rcx@161
  signed int v40; // ecx@161
  int v41; // eax@164
  char *v42; // esi@164
  char *j; // eax@174
  int v44; // ebx@189
  FILE *v45; // edi@191
  char *v46; // esi@196
  wchar_t v47; // ax@197
  char v48; // al@209
  const wchar_t *v49; // [sp-14h] [bp-288h]@2
  const wchar_t *v50; // [sp-10h] [bp-284h]@2
  const wchar_t *v51; // [sp-Ch] [bp-280h]@2
  unsigned int v52; // [sp-8h] [bp-27Ch]@2
  uintptr_t v53; // [sp-4h] [bp-278h]@2
  int v54; // [sp+Ch] [bp-268h]@124
  int v55; // [sp+10h] [bp-264h]@124
  int v56; // [sp+14h] [bp-260h]@7
  int v57; // [sp+18h] [bp-25Ch]@197
  size_t Count; // [sp+20h] [bp-254h]@67
  int v59; // [sp+24h] [bp-250h]@1
  FILE *File; // [sp+28h] [bp-24Ch]@1
  int v61; // [sp+2Ch] [bp-248h]@1
  void *Memory; // [sp+30h] [bp-244h]@6
  unsigned int v63; // [sp+34h] [bp-240h]@6
  char v64[4]; // [sp+38h] [bp-23Ch]@1
  int v65; // [sp+3Ch] [bp-238h]@1
  int v66; // [sp+40h] [bp-234h]@1
  int v67; // [sp+44h] [bp-230h]@1
  char v68; // [sp+48h] [bp-22Ch]@136
  char v69; // [sp+49h] [bp-22Bh]@136
  int v70; // [sp+4Ch] [bp-228h]@6
  int v71; // [sp+50h] [bp-224h]@1
  int v72; // [sp+54h] [bp-220h]@6
  char *v73; // [sp+58h] [bp-21Ch]@67
  int Value; // [sp+5Ch] [bp-218h]@1
  char v75; // [sp+63h] [bp-211h]@6
  int v76; // [sp+64h] [bp-210h]@1
  char Dst; // [sp+68h] [bp-20Ch]@67
  char v78; // [sp+267h] [bp-Dh]@158
  char v79; // [sp+268h] [bp-Ch]@197

  v3 = a2;
  v4 = a3;
  File = a1;
  v71 = a3;
  v61 = 0;
  v76 = 0;
  v66 = 0;
  Value = 0;
  v67 = 0;
  *(_DWORD *)v64 = 0;
  v59 = 0;
  v65 = 0;
  if ( a1 && a2 )
  {
    v7 = *(_BYTE *)a2;
    v70 = 0;
    v72 = 0;
    v63 = 0;
    Memory = 0;
    v75 = v7;
    if ( !v7 )
      return v70;
    while ( 1 )
    {
      ++v3;
      v56 = v3;
      if ( v70 < 0 )
        break;
      if ( (unsigned __int8)(v7 - 32) > 0x58u )
        v8 = 0;
      else
        v8 = *((_BYTE *)L"\u6e00\u6b00\u6100\u6700\u6500" + v7) & 0xF;
      v9 = (unsigned int)(unsigned __int8)*(&__lookuptable_s[9 * v8] + v63) >> 4;
      v63 = v9;
      if ( v9 == 8 )
        goto LABEL_2;
      switch ( v9 )
      {
        case 1u:
          Value = -1;
          *(_DWORD *)v64 = 0;
          v59 = 0;
          v66 = 0;
          v67 = 0;
          v76 = 0;
          v65 = 0;
          goto LABEL_209;
        case 2u:
          switch ( v7 )
          {
            case 32:
              v76 |= 2u;
              break;
            case 35:
              v76 |= 0x80u;
              break;
            case 43:
              v76 |= 1u;
              break;
            case 45:
              v76 |= 4u;
              break;
            default:
              if ( v7 != 48 )
                goto LABEL_208;
              v76 |= 8u;
              break;
          }
          goto LABEL_209;
        case 3u:
          if ( v7 == 42 )
          {
            v10 = *(_DWORD *)v4;
            v4 += 4;
            v71 = v4;
            v66 = v10;
            if ( v10 < 0 )
            {
              v76 |= 4u;
              v66 = -v66;
            }
          }
          else
          {
            v66 = 10 * v66 + v7 - 48;
          }
          goto LABEL_209;
        case 4u:
          Value = 0;
          goto LABEL_209;
        case 5u:
          if ( v7 == 42 )
          {
            v11 = *(_DWORD *)v4;
            v4 += 4;
            v71 = v4;
            Value = v11;
            if ( v11 < 0 )
              Value = -1;
          }
          else
          {
            Value = 10 * Value + v7 - 48;
          }
          goto LABEL_209;
        case 6u:
          if ( v7 != 73 )
          {
            switch ( v7 )
            {
              case 104:
                v76 |= 0x20u;
                break;
              case 108:
                if ( *(_BYTE *)v3 == 108 )
                {
                  ++v3;
                  v76 |= 0x1000u;
                }
                else
                {
                  v76 |= 0x10u;
                }
                break;
              case 119:
                v76 |= 0x800u;
                break;
            }
            goto LABEL_209;
          }
          v12 = *(_BYTE *)v3;
          if ( *(_BYTE *)v3 == 54 && *(_BYTE *)(v3 + 1) == 52 )
          {
            v3 += 2;
            v76 |= 0x8000u;
            goto LABEL_209;
          }
          if ( v12 == 51 && *(_BYTE *)(v3 + 1) == 50 )
          {
            v3 += 2;
            v76 &= 0xFFFF7FFF;
            goto LABEL_209;
          }
          if ( v12 == 100 || v12 == 105 || v12 == 111 || v12 == 117 || v12 == 120 || v12 == 88 )
            goto LABEL_209;
          v63 = 0;
LABEL_55:
          v65 = 0;
          if ( !isleadbyte((unsigned __int8)v7) || (write_char_0(File), v13 = *(_BYTE *)v3, ++v3, (v75 = v13) != 0) )
          {
            write_char_0(File);
            goto LABEL_209;
          }
          *_errno() = 22;
          _invalid_parameter(0, 0, 0, 0, 0);
          return -1;
        case 0u:
          goto LABEL_55;
        case 7u:
          if ( v7 > 100 )
          {
            if ( v7 > 112 )
            {
              if ( v7 == 115 )
                goto LABEL_73;
              if ( v7 != 117 )
              {
                if ( v7 != 120 )
                  goto LABEL_180;
                v61 = 39;
                goto LABEL_135;
              }
            }
            else
            {
              if ( v7 == 112 )
              {
                Value = 8;
                goto LABEL_130;
              }
              if ( v7 < 101 )
                goto LABEL_180;
              if ( v7 <= 103 )
                goto LABEL_67;
              if ( v7 != 105 )
              {
                if ( v7 == 110 )
                  goto LABEL_2;
                if ( v7 != 111 )
                  goto LABEL_180;
                v72 = 8;
                if ( v76 & 0x80 )
                  v76 |= 0x200u;
                goto LABEL_110;
              }
LABEL_108:
              v76 |= 0x40u;
            }
            v72 = 10;
            goto LABEL_110;
          }
          if ( v7 == 100 )
            goto LABEL_108;
          if ( v7 > 83 )
          {
            if ( v7 != 88 )
            {
              if ( v7 == 90 )
              {
                v19 = *(_DWORD *)v4;
                v71 = v4 + 4;
                if ( v19 )
                {
                  v20 = *(char **)(v19 + 4);
                  if ( v20 )
                  {
                    v21 = *(_WORD *)v19;
                    if ( *(_WORD *)(v19 + 2) < *(_WORD *)v19 )
                      goto LABEL_212;
                    v22 = v21;
                    if ( v76 & 0x800 )
                    {
                      if ( !(~(_BYTE)v21 & 1) || !(~(_BYTE)v20 & 1) )
                      {
LABEL_212:
                        v5 = _errno();
                        v53 = 0;
                        v52 = 0;
                        v51 = 0;
                        v50 = 0;
                        v49 = 0;
                        goto LABEL_3;
                      }
                      v73 = v20;
                      v22 = (unsigned int)v21 >> 1;
                      v65 = 1;
                    }
                    else
                    {
                      v65 = 0;
                      v73 = v20;
                    }
                    goto LABEL_179;
                  }
                }
                v23 = __nullstring;
                v73 = __nullstring;
                v24 = __nullstring + 1;
                do
                  v25 = *v23++;
                while ( v25 );
LABEL_98:
                v22 = v23 - v24;
LABEL_179:
                v72 = v22;
                goto LABEL_180;
              }
              if ( v7 == 97 )
                goto LABEL_67;
              if ( v7 != 99 )
                goto LABEL_180;
              goto LABEL_83;
            }
LABEL_130:
            v61 = 7;
LABEL_135:
            v72 = 16;
            if ( v76 & 0x80 )
            {
              v68 = 48;
              v69 = v61 + 81;
              v67 = 2;
            }
LABEL_110:
            if ( v76 & 0x8000 || v76 & 0x1000 )
            {
              v26 = *(_QWORD *)v4;
              v27 = v4 + 8;
            }
            else
            {
              v27 = v4 + 4;
              if ( v76 & 0x20 )
              {
                v71 = v27;
                if ( v76 & 0x40 )
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                else
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                v26 = (signed int)v26;
LABEL_147:
                if ( v76 & 0x40 && v26 < 0 )
                {
                  v26 = -v26;
                  v76 |= 0x100u;
                }
                v34 = HIDWORD(v26);
                v35 = v26;
                if ( !(v76 & 0x9000) )
                  v34 = 0;
                if ( Value >= 0 )
                {
                  v76 &= 0xFFFFFFF7;
                  if ( Value > 512 )
                    Value = 512;
                }
                else
                {
                  Value = 1;
                }
                if ( !(v34 | (unsigned int)v26) )
                  v67 = 0;
                for ( i = &v78; ; --i )
                {
                  v37 = Value--;
                  if ( v37 <= 0 && !(v34 | v35) )
                    break;
                  v38 = __PAIR__(v34, v35);
                  v39 = __PAIR__(v34, v35) % v72;
                  v40 = v39 + 48;
                  Count = HIDWORD(v39);
                  v34 = v38 / v72 >> 32;
                  v35 = v38 / v72;
                  if ( v40 > 57 )
                    LOBYTE(v40) = v61 + v40;
                  *i = v40;
                }
                v41 = &v78 - i;
                v42 = i + 1;
                v72 = v41;
                v73 = v42;
                if ( v76 & 0x200 && (!v41 || *v42 != 48) )
                {
                  --v73;
                  *v73 = 48;
                  v22 = v41 + 1;
                  goto LABEL_179;
                }
                goto LABEL_180;
              }
              LODWORD(v26) = *(_DWORD *)(v27 - 4);
              if ( v76 & 0x40 )
                v26 = (signed int)v26;
              else
                HIDWORD(v26) = 0;
            }
            v71 = v27;
            goto LABEL_147;
          }
          if ( v7 == 83 )
          {
            if ( !(v76 & 0x830) )
              v76 |= 0x800u;
LABEL_73:
            v14 = Value;
            if ( Value == -1 )
              v14 = 0x7FFFFFFF;
            v15 = v4 + 4;
            v71 = v15;
            v16 = *(char **)(v15 - 4);
            v73 = v16;
            if ( v76 & 0x810 )
            {
              if ( !v16 )
                v73 = (char *)__wnullstring;
              v17 = v73;
              v65 = 1;
              while ( v14 )
              {
                --v14;
                if ( !*(_WORD *)v17 )
                  break;
                v17 += 2;
              }
              v22 = (v17 - v73) >> 1;
            }
            else
            {
              if ( !v16 )
                v73 = __nullstring;
              for ( j = v73; ; ++j )
              {
                if ( v14 )
                {
                  --v14;
                  if ( *j )
                    continue;
                }
                break;
              }
              v22 = j - v73;
            }
            goto LABEL_179;
          }
          if ( v7 == 65 )
            goto LABEL_66;
          if ( v7 == 67 )
          {
            if ( !(v76 & 0x830) )
              v76 |= 0x800u;
LABEL_83:
            v18 = v4 + 4;
            v71 = v18;
            if ( v76 & 0x810 )
            {
              if ( _safecrt_wctomb_s((int)&v72, &Dst, 0x200u, *(_WORD *)(v18 - 4)) )
                v59 = 1;
            }
            else
            {
              Dst = *(_BYTE *)(v18 - 4);
              v72 = 1;
            }
            v73 = &Dst;
            goto LABEL_180;
          }
          if ( v7 == 69 || v7 == 71 )
          {
LABEL_66:
            v7 += 32;
            *(_DWORD *)v64 = 1;
            v75 = v7;
LABEL_67:
            v76 |= 0x40u;
            v73 = &Dst;
            Count = 512;
            if ( Value >= 0 )
            {
              if ( Value )
              {
                if ( Value > 512 )
                  Value = 512;
                if ( Value <= 163 )
                {
                  v7 = v75;
                }
                else
                {
                  v28 = Value + 349;
                  v29 = malloc(Value + 349);
                  v7 = v75;
                  Memory = v29;
                  if ( v29 )
                  {
                    v73 = (char *)v29;
                    Count = v28;
                  }
                  else
                  {
                    Value = 163;
                  }
                }
              }
              else if ( v7 == 103 )
              {
                Value = 1;
              }
            }
            else
            {
              Value = 6;
            }
            if ( v76 & 0x80 )
              *(_DWORD *)v64 |= 0x80u;
            v30 = *(_DWORD *)v4;
            v31 = v73;
            v32 = v4 + 8;
            v54 = v30;
            v55 = *(_DWORD *)(v32 - 4);
            v71 = v32;
            _safecrt_cfltcvt((int)&v54, v73, Count, v7, Value, v64[0]);
            if ( *v31 == 45 )
            {
              v76 |= 0x100u;
              ++v73;
            }
            v23 = v73;
            v24 = v73 + 1;
            do
              v33 = *v23++;
            while ( v33 );
            goto LABEL_98;
          }
LABEL_180:
          if ( v59 )
            goto LABEL_206;
          if ( !(v76 & 0x40) )
            goto LABEL_189;
          if ( v76 & 0x100 )
          {
            v68 = 45;
          }
          else if ( v76 & 1 )
          {
            v68 = 43;
          }
          else
          {
            if ( !(v76 & 2) )
              goto LABEL_189;
            v68 = 32;
          }
          v67 = 1;
LABEL_189:
          v44 = v66 - v72 - v67;
          if ( !(v76 & 0xC) )
            write_multi_char_0(32, v66 - v72 - v67, File);
          v45 = File;
          write_string_0(v67);
          if ( v76 & 8 && !(v76 & 4) )
            write_multi_char_0(48, v44, v45);
          if ( v65 && v72 > 0 )
          {
            v46 = v73;
            Count = v72;
            while ( 1 )
            {
              v47 = *(_WORD *)v46;
              --Count;
              v46 += 2;
              if ( _safecrt_wctomb_s((int)&v57, &v79, 6u, v47) || !v57 )
                break;
              write_string_0(v57);
              if ( !Count )
                goto LABEL_203;
            }
            v70 = -1;
          }
          else
          {
            write_string_0(v72);
          }
LABEL_203:
          if ( v70 >= 0 && v76 & 4 )
            write_multi_char_0(32, v44, v45);
LABEL_206:
          if ( Memory )
          {
            free(Memory);
            Memory = 0;
          }
LABEL_208:
          v3 = v56;
          v4 = v71;
LABEL_209:
          v48 = *(_BYTE *)v3;
          v75 = v48;
          if ( !v48 )
            goto LABEL_213;
          v7 = v48;
          break;
        default:
          goto LABEL_208;
      }
    }
LABEL_213:
    if ( !v63 || v63 == 7 )
      return v70;
  }
LABEL_2:
  v5 = _errno();
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v50 = 0;
  v49 = 0;
LABEL_3:
  *v5 = 22;
  _invalid_parameter(v49, v50, v51, v52, v53);
  return -1;
}
// 6E67E72F: using guessed type int __cdecl write_string_0(_DWORD);
// 6E69B88C: using guessed type char *__nullstring;
// 6E69B890: using guessed type wchar_t *__wnullstring;

//----- (6E67F412) --------------------------------------------------------
signed int __cdecl _soutput_s(char *a1, int a2, int a3, int a4)
{
  int v5; // ebx@6
  FILE File; // [sp+4h] [bp-20h]@2

  if ( a2 == -1 )
  {
    File._cnt = 0x7FFFFFFF;
  }
  else
  {
    if ( (unsigned int)a2 > 0x7FFFFFFF )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
    File._cnt = a2;
  }
  File._base = a1;
  File._ptr = a1;
  File._flag = 66;
  v5 = _output_s(&File, a3, a4);
  a1[a2 - 1] = 0;
  if ( v5 >= 0 )
  {
    --File._cnt;
    if ( File._cnt < 0 )
    {
      if ( _flsbuf_s(0, &File) == -1 )
        return -2;
    }
    else
    {
      *File._ptr = 0;
    }
    return v5;
  }
  if ( File._cnt >= 0 )
  {
    if ( a1 )
    {
      if ( (unsigned int)a2 > 0 )
        *a1 = 0;
    }
    return v5;
  }
  return -2;
}

//----- (6E67F4C5) --------------------------------------------------------
int __cdecl _flsbuf_s(int a1, FILE *File)
{
  FILE *v2; // esi@1
  signed int v3; // ecx@1
  int v4; // eax@1
  unsigned int v6; // eax@9
  const void *v7; // eax@18
  int v8; // edi@18
  unsigned int v9; // edi@18
  int v10; // eax@22
  __int64 v11; // rax@25
  signed int v12; // [sp+4h] [bp-4h]@1

  v2 = File;
  v3 = _fileno(File);
  v4 = v2->_flag;
  v12 = v3;
  if ( !(v4 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    v2->_flag |= 0x20u;
    return -1;
  }
  if ( v4 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v4 & 1 )
  {
    v2->_cnt = 0;
    if ( !(v4 & 0x10) )
    {
      v2->_flag = v4 | 0x20;
      return -1;
    }
    v2->_ptr = v2->_base;
    v2->_flag = v4 & 0xFFFFFFFE;
  }
  v6 = v2->_flag & 0xFFFFFFEF | 2;
  v2->_flag = v6;
  v2->_cnt = 0;
  File = 0;
  if ( !(v6 & 0x10C) )
  {
    if ( (int *)v2 != dword_6E69A058 && (int *)v2 != dword_6E69A078 || !_isatty(v3) )
    {
      *_errno() = 22;
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
    v3 = v12;
  }
  if ( v2->_flag & 0x108 )
  {
    v7 = v2->_base;
    v8 = (int)v2->_ptr;
    v2->_ptr = (char *)v7 + 1;
    v9 = v8 - (_DWORD)v7;
    v2->_cnt = v2->_bufsiz - 1;
    if ( (signed int)v9 <= 0 )
    {
      if ( v3 == -1 || v3 == -2 )
        v10 = (int)__badioinfo;
      else
        v10 = __pioinfo[v3 >> 5] + 36 * (v3 & 0x1F);
      if ( *(_BYTE *)(v10 + 4) & 0x20 )
      {
        v11 = _lseeki64(v3, 0i64, 2);
        if ( (HIDWORD(v11) & (unsigned int)v11) == -1 )
          goto LABEL_29;
      }
    }
    else
    {
      File = (FILE *)_write(v3, v7, v9);
    }
    *v2->_base = a1;
  }
  else
  {
    v9 = 1;
    File = (FILE *)_write(v3, &a1, 1u);
  }
  if ( File != (FILE *)v9 )
  {
LABEL_29:
    v2->_flag |= 0x20u;
    return -1;
  }
  return (unsigned __int8)a1;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69A058: using guessed type int dword_6E69A058[3];
// 6E69A078: using guessed type int dword_6E69A078[3];
// 6E69B624: using guessed type int __badioinfo[9];

//----- (6E67F630) --------------------------------------------------------
int __cdecl __crtMessageBoxA(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@5
  int v9; // eax@8
  int v10; // eax@9
  int v11; // esi@10
  int v12; // eax@12
  LPCSTR lpProcName; // ST14_4@12
  int v14; // eax@12
  int v15; // ST04_4@13
  int v16; // eax@13
  int v17; // ST00_4@13
  int v18; // eax@21
  LPCSTR v19; // ST14_4@21
  LPCSTR v20; // ST14_4@23
  int v21; // eax@23
  int v22; // ST10_4@23
  int v23; // ST08_4@24
  int v24; // eax@24
  int v25; // ST04_4@24
  char v26; // [sp+10h] [bp-20h]@13
  char v27; // [sp+18h] [bp-18h]@14
  char v28; // [sp+1Ch] [bp-14h]@13
  int v29; // [sp+20h] [bp-10h]@1
  unsigned int v30; // [sp+24h] [bp-Ch]@1
  int v31; // [sp+28h] [bp-8h]@1
  int v32; // [sp+2Ch] [bp-4h]@1

  v29 = _encoded_null();
  v32 = 0;
  v31 = 0;
  v30 = 0;
  if ( !dword_6E69C084 )
  {
    v3 = LoadLibraryExA("USER32.DLL", 0, 0);
    v4 = v3;
    if ( !v3 )
      return 0;
    v6 = (int)GetProcAddress(v3, "MessageBoxA");
    if ( !v6 )
      return 0;
    dword_6E69C084 = _encode_pointer(v6);
    v7 = (int)GetProcAddress(v4, "GetActiveWindow");
    dword_6E69C088 = _encode_pointer(v7);
    v8 = (int)GetProcAddress(v4, "GetLastActivePopup");
    dword_6E69C08C = _encode_pointer(v8);
    if ( _get_osplatform((int)&v31) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v31 == 2 )
    {
      v9 = (int)GetProcAddress(v4, "GetUserObjectInformationA");
      dword_6E69C094 = _encode_pointer(v9);
      if ( dword_6E69C094 )
      {
        v10 = (int)GetProcAddress(v4, "GetProcessWindowStation");
        dword_6E69C090 = _encode_pointer(v10);
      }
    }
  }
  v11 = v29;
  if ( dword_6E69C090 == v29
    || dword_6E69C094 == v29
    || (v12 = _decode_pointer(dword_6E69C090), (v14 = ((int (__thiscall *)(LPCSTR))v12)(lpProcName)) != 0)
    && (v15 = v14,
        v16 = _decode_pointer(dword_6E69C094),
        ((int (__thiscall *)(int, int, signed int, char *, signed int, char *))v16)(v17, v15, 1, &v26, 12, &v28))
    && v27 & 1 )
  {
    if ( dword_6E69C088 != v11 )
    {
      v18 = _decode_pointer(dword_6E69C088);
      v32 = ((int (__thiscall *)(LPCSTR))v18)(v19);
      if ( v32 )
      {
        if ( dword_6E69C08C != v11 )
        {
          v20 = (LPCSTR)v32;
          v21 = _decode_pointer(dword_6E69C08C);
          v32 = ((int (__thiscall *)(int, LPCSTR))v21)(v22, v20);
        }
      }
    }
  }
  else
  {
    if ( _get_winmajor((int)&v30) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v30 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v23 = v32;
  v24 = _decode_pointer(dword_6E69C084);
  return ((int (__thiscall *)(int, int, int, int, int))v24)(v25, v23, a1, a2, a3);
}
// 6E648CDF: using guessed type int _encoded_null(void);
// 6E69C084: using guessed type int dword_6E69C084;
// 6E69C088: using guessed type int dword_6E69C088;
// 6E69C08C: using guessed type int dword_6E69C08C;
// 6E69C090: using guessed type int dword_6E69C090;
// 6E69C094: using guessed type int dword_6E69C094;

//----- (6E67F898) --------------------------------------------------------
__int32 __cdecl atol(const char *Str)
{
  __int32 result; // eax@2

  if ( Str )
    result = strtolX((int)Str, 0, 10, 1);
  else
    result = 0;
  return result;
}

//----- (6E67F97C) --------------------------------------------------------
signed int __cdecl _ld12tod(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  signed int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  signed int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@12
  signed int v14; // edx@12
  int *v15; // ecx@12
  bool v16; // cf@13
  int v17; // eax@28
  int v18; // edx@28
  int *v19; // ebx@29
  unsigned int v20; // esi@29
  char v21; // cl@29
  signed int v22; // edx@30
  int *v23; // ecx@30
  signed int v24; // esi@35
  int v25; // eax@35
  int v26; // edx@35
  int *v27; // ebx@35
  bool j; // zf@36
  int v29; // eax@40
  signed int v30; // edx@40
  int *v31; // ecx@40
  int v32; // edi@40
  signed int k; // ecx@43
  int *v34; // ecx@45
  int v35; // esi@45
  signed int v36; // edi@45
  int v37; // eax@52
  int v38; // edx@52
  int *v39; // ebx@53
  unsigned int v40; // esi@53
  char v41; // cl@53
  signed int v42; // edx@54
  int *v43; // ecx@54
  int v44; // eax@61
  int v45; // edx@61
  int *v46; // ebx@62
  unsigned int v47; // esi@62
  char v48; // cl@62
  signed int v49; // edx@63
  int *v50; // ecx@63
  int v51; // eax@69
  int v52; // edx@69
  unsigned int v53; // edi@70
  signed int v54; // edx@71
  int *v55; // ecx@71
  int v56; // ebx@77
  int v57; // edx@78
  unsigned int v58; // [sp+8h] [bp-2Ch]@7
  int v59; // [sp+Ch] [bp-28h]@7
  int v60; // [sp+10h] [bp-24h]@7
  unsigned int v61; // [sp+14h] [bp-20h]@1
  int v62; // [sp+18h] [bp-1Ch]@1
  int v63; // [sp+1Ch] [bp-18h]@1
  int v64; // [sp+20h] [bp-14h]@1
  int v65; // [sp+24h] [bp-10h]@7
  int v66; // [sp+28h] [bp-Ch]@7
  int v67; // [sp+2Ch] [bp-8h]@7
  int v68; // [sp+30h] [bp-4h]@12
  int v69; // [sp+3Ch] [bp+8h]@7
  int v70; // [sp+3Ch] [bp+8h]@12
  signed int v71; // [sp+3Ch] [bp+8h]@28
  signed int v72; // [sp+3Ch] [bp+8h]@40
  signed int v73; // [sp+3Ch] [bp+8h]@52
  signed int v74; // [sp+3Ch] [bp+8h]@61
  signed int v75; // [sp+3Ch] [bp+8h]@69

  v2 = *(_WORD *)(a1 + 10);
  v64 = *(_WORD *)(a1 + 10) & 0x8000;
  v61 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v62 = *(_DWORD *)(a1 + 2);
  v63 = v4;
  if ( v3 != -16383 )
  {
    v69 = 0;
    v58 = v61;
    v59 = v62;
    v60 = v63;
    v8 = dword_6E69B960 - 1;
    v65 = v3;
    v66 = dword_6E69B960 / 32;
    v9 = dword_6E69B960 % 32;
    v10 = (int *)(&v61 + dword_6E69B960 / 32);
    v67 = 31 - dword_6E69B960 % 32;
    if ( (1 << (31 - dword_6E69B960 % 32)) & *v10 )
    {
      v11 = v66;
      for ( i = (~(-1 << (31 - v9)) & *(&v61 + v66)) == 0; i; i = *(&v61 + v11) == 0 )
      {
        ++v11;
        if ( v11 >= 3 )
          goto LABEL_21;
      }
      v13 = v8 / 32;
      v68 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v61 + v8 / 32);
      v70 = v14 + *v15;
      if ( v70 >= (unsigned int)*v15 )
      {
        v16 = v70 < (unsigned int)v14;
        goto LABEL_17;
      }
LABEL_18:
      v68 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v70;
        if ( v13 < 0 || !v68 )
          break;
        v68 = 0;
        v15 = (int *)(&v61 + v13);
        v70 = *v15 + 1;
        if ( v70 >= (unsigned int)*v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_17:
          if ( !v16 )
            continue;
        }
        goto LABEL_18;
      }
      v69 = v68;
    }
LABEL_21:
    *v10 &= -1 << v67;
    if ( v66 + 1 < 3 )
      memset(&v61 + v66 + 1, 0, 4 * (3 - (v66 + 1)));
    if ( v69 )
      ++v3;
    if ( v3 >= dword_6E69B95C - dword_6E69B960 )
    {
      if ( v3 > dword_6E69B95C )
      {
        if ( v3 < dword_6E69B958 )
        {
          v61 &= 0x7FFFFFFFu;
          v5 = dword_6E69B96C + v3;
          v51 = dword_6E69B964 / 32;
          v52 = dword_6E69B964 % 32;
          v66 = 0;
          v75 = 0;
          v68 = 32 - dword_6E69B964 % 32;
          do
          {
            v53 = *(&v61 + v75);
            v65 = ~(-1 << v52) & *(&v61 + v75);
            *(&v61 + v75++) = v66 | (v53 >> v52);
            v66 = v65 << v68;
          }
          while ( v75 < 3 );
          v54 = 2;
          v55 = &v63 - v51;
          do
          {
            if ( v54 < v51 )
              *(&v61 + v54) = 0;
            else
              *(&v61 + v54) = *v55;
            --v54;
            --v55;
          }
          while ( v54 >= 0 );
          result = 0;
        }
        else
        {
          v62 = 0;
          v63 = 0;
          v61 = 2147483648;
          v44 = dword_6E69B964 / 32;
          v45 = dword_6E69B964 % 32;
          v66 = 0;
          v74 = 0;
          v68 = 32 - dword_6E69B964 % 32;
          do
          {
            v46 = (int *)(&v61 + v74);
            v47 = *v46;
            v65 = ~(-1 << v45) & *v46;
            v48 = v68;
            *v46 = v66 | (v47 >> v45);
            ++v74;
            v66 = v65 << v48;
          }
          while ( v74 < 3 );
          v49 = 2;
          v50 = &v63 - v44;
          do
          {
            if ( v49 < v44 )
              *(&v61 + v49) = 0;
            else
              *(&v61 + v49) = *v50;
            --v49;
            --v50;
          }
          while ( v49 >= 0 );
          v5 = dword_6E69B958 + dword_6E69B96C;
          result = 1;
        }
        goto LABEL_77;
      }
      v61 = v58;
      v62 = v59;
      v17 = (dword_6E69B95C - v65) / 32;
      v63 = v60;
      v18 = (dword_6E69B95C - v65) % 32;
      v66 = 0;
      v71 = 0;
      v68 = 32 - v18;
      do
      {
        v19 = (int *)(&v61 + v71);
        v20 = *v19;
        v65 = ~(-1 << v18) & *v19;
        v21 = v68;
        *v19 = v66 | (v20 >> v18);
        ++v71;
        v66 = v65 << v21;
      }
      while ( v71 < 3 );
      v22 = 2;
      v23 = &v63 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v61 + v22) = 0;
        else
          *(&v61 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_6E69B960 - 1;
      v25 = dword_6E69B960 / 32;
      v66 = dword_6E69B960 / 32;
      v26 = dword_6E69B960 % 32;
      v27 = (int *)(&v61 + dword_6E69B960 / 32);
      v65 = 31 - dword_6E69B960 % 32;
      if ( (1 << (31 - dword_6E69B960 % 32)) & *v27 )
      {
        for ( j = (~(-1 << (31 - v26)) & *(&v61 + v25)) == 0; j; j = *(&v61 + v25) == 0 )
        {
          ++v25;
          if ( v25 >= 3 )
            goto LABEL_50;
        }
        v29 = v24 / 32;
        v72 = 0;
        v30 = 1 << (31 - v24 % 32);
        v31 = (int *)(&v61 + v24 / 32);
        v32 = *v31 + v30;
        if ( v32 < (unsigned int)*v31 || v32 < (unsigned int)v30 )
          v72 = 1;
        *v31 = v32;
        for ( k = v72; ; k = v36 )
        {
          --v29;
          if ( v29 < 0 || !k )
            break;
          v34 = (int *)(&v61 + v29);
          v35 = *v34 + 1;
          v36 = 0;
          if ( v35 < (unsigned int)*v34 || (unsigned int)v35 < 1 )
            v36 = 1;
          *v34 = v35;
        }
      }
LABEL_50:
      *v27 &= -1 << v65;
      if ( v66 + 1 < 3 )
        memset(&v61 + v66 + 1, 0, 4 * (3 - (v66 + 1)));
      v37 = (dword_6E69B964 + 1) / 32;
      v38 = (dword_6E69B964 + 1) % 32;
      v66 = 0;
      v73 = 0;
      v68 = 32 - v38;
      do
      {
        v39 = (int *)(&v61 + v73);
        v40 = *v39;
        v65 = ~(-1 << v38) & *v39;
        v41 = v68;
        *v39 = v66 | (v40 >> v38);
        ++v73;
        v66 = v65 << v41;
      }
      while ( v73 < 3 );
      v42 = 2;
      v43 = &v63 - v37;
      do
      {
        if ( v42 < v37 )
          *(&v61 + v42) = 0;
        else
          *(&v61 + v42) = *v43;
        --v42;
        --v43;
      }
      while ( v42 >= 0 );
    }
    else
    {
      v61 = 0;
      v62 = 0;
      v63 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_77;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v61 + v6) )
  {
    ++v6;
    if ( v6 >= 3 )
    {
      result = 0;
      goto LABEL_77;
    }
  }
  v61 = 0;
  v62 = 0;
  v63 = 0;
  result = 2;
LABEL_77:
  v56 = v61 | (v64 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_6E69B964));
  if ( dword_6E69B968 == 64 )
  {
    v57 = v62;
    *(_DWORD *)(a2 + 4) = v56;
    *(_DWORD *)a2 = v57;
  }
  else if ( dword_6E69B968 == 32 )
  {
    *(_DWORD *)a2 = v56;
  }
  return result;
}
// 6E69B958: using guessed type int dword_6E69B958;
// 6E69B95C: using guessed type int dword_6E69B95C;
// 6E69B960: using guessed type int dword_6E69B960;
// 6E69B964: using guessed type int dword_6E69B964;
// 6E69B968: using guessed type int dword_6E69B968;
// 6E69B96C: using guessed type int dword_6E69B96C;

//----- (6E67FEC5) --------------------------------------------------------
signed int __cdecl _ld12tof(int a1, int a2)
{
  __int16 v2; // bx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // ebx@2
  signed int v6; // eax@2
  signed int result; // eax@5
  signed int v8; // esi@7
  int v9; // edx@7
  int *v10; // edi@7
  signed int v11; // eax@8
  bool i; // zf@8
  int v13; // eax@12
  signed int v14; // edx@12
  int *v15; // ecx@12
  bool v16; // cf@13
  int v17; // eax@28
  int v18; // edx@28
  int *v19; // ebx@29
  unsigned int v20; // esi@29
  char v21; // cl@29
  signed int v22; // edx@30
  int *v23; // ecx@30
  signed int v24; // esi@35
  int v25; // eax@35
  int v26; // edx@35
  int *v27; // ebx@35
  bool j; // zf@36
  int v29; // eax@40
  signed int v30; // edx@40
  int *v31; // ecx@40
  int v32; // edi@40
  signed int k; // ecx@43
  int *v34; // ecx@45
  int v35; // esi@45
  signed int v36; // edi@45
  int v37; // eax@52
  int v38; // edx@52
  int *v39; // ebx@53
  unsigned int v40; // esi@53
  char v41; // cl@53
  signed int v42; // edx@54
  int *v43; // ecx@54
  int v44; // eax@61
  int v45; // edx@61
  int *v46; // ebx@62
  unsigned int v47; // esi@62
  char v48; // cl@62
  signed int v49; // edx@63
  int *v50; // ecx@63
  int v51; // eax@69
  int v52; // edx@69
  unsigned int v53; // edi@70
  signed int v54; // edx@71
  int *v55; // ecx@71
  int v56; // ebx@77
  int v57; // edx@78
  unsigned int v58; // [sp+8h] [bp-2Ch]@7
  int v59; // [sp+Ch] [bp-28h]@7
  int v60; // [sp+10h] [bp-24h]@7
  unsigned int v61; // [sp+14h] [bp-20h]@1
  int v62; // [sp+18h] [bp-1Ch]@1
  int v63; // [sp+1Ch] [bp-18h]@1
  int v64; // [sp+20h] [bp-14h]@1
  int v65; // [sp+24h] [bp-10h]@7
  int v66; // [sp+28h] [bp-Ch]@7
  int v67; // [sp+2Ch] [bp-8h]@7
  int v68; // [sp+30h] [bp-4h]@12
  int v69; // [sp+3Ch] [bp+8h]@7
  int v70; // [sp+3Ch] [bp+8h]@12
  signed int v71; // [sp+3Ch] [bp+8h]@28
  signed int v72; // [sp+3Ch] [bp+8h]@40
  signed int v73; // [sp+3Ch] [bp+8h]@52
  signed int v74; // [sp+3Ch] [bp+8h]@61
  signed int v75; // [sp+3Ch] [bp+8h]@69

  v2 = *(_WORD *)(a1 + 10);
  v64 = *(_WORD *)(a1 + 10) & 0x8000;
  v61 = *(_DWORD *)(a1 + 6);
  v3 = (v2 & 0x7FFF) - 0x3FFF;
  v4 = *(_WORD *)a1 << 16;
  v62 = *(_DWORD *)(a1 + 2);
  v63 = v4;
  if ( v3 != -16383 )
  {
    v69 = 0;
    v58 = v61;
    v59 = v62;
    v60 = v63;
    v8 = dword_6E69B978 - 1;
    v65 = v3;
    v66 = dword_6E69B978 / 32;
    v9 = dword_6E69B978 % 32;
    v10 = (int *)(&v61 + dword_6E69B978 / 32);
    v67 = 31 - dword_6E69B978 % 32;
    if ( (1 << (31 - dword_6E69B978 % 32)) & *v10 )
    {
      v11 = v66;
      for ( i = (~(-1 << (31 - v9)) & *(&v61 + v66)) == 0; i; i = *(&v61 + v11) == 0 )
      {
        ++v11;
        if ( v11 >= 3 )
          goto LABEL_21;
      }
      v13 = v8 / 32;
      v68 = 0;
      v14 = 1 << (31 - v8 % 32);
      v15 = (int *)(&v61 + v8 / 32);
      v70 = v14 + *v15;
      if ( v70 >= (unsigned int)*v15 )
      {
        v16 = v70 < (unsigned int)v14;
        goto LABEL_17;
      }
LABEL_18:
      v68 = 1;
      while ( 1 )
      {
        --v13;
        *v15 = v70;
        if ( v13 < 0 || !v68 )
          break;
        v68 = 0;
        v15 = (int *)(&v61 + v13);
        v70 = *v15 + 1;
        if ( v70 >= (unsigned int)*v15 )
        {
          v16 = (unsigned int)*v15 >= 0xFFFFFFFF;
LABEL_17:
          if ( !v16 )
            continue;
        }
        goto LABEL_18;
      }
      v69 = v68;
    }
LABEL_21:
    *v10 &= -1 << v67;
    if ( v66 + 1 < 3 )
      memset(&v61 + v66 + 1, 0, 4 * (3 - (v66 + 1)));
    if ( v69 )
      ++v3;
    if ( v3 >= dword_6E69B974 - dword_6E69B978 )
    {
      if ( v3 > dword_6E69B974 )
      {
        if ( v3 < dword_6E69B970 )
        {
          v61 &= 0x7FFFFFFFu;
          v5 = dword_6E69B984 + v3;
          v51 = dword_6E69B97C / 32;
          v52 = dword_6E69B97C % 32;
          v66 = 0;
          v75 = 0;
          v68 = 32 - dword_6E69B97C % 32;
          do
          {
            v53 = *(&v61 + v75);
            v65 = ~(-1 << v52) & *(&v61 + v75);
            *(&v61 + v75++) = v66 | (v53 >> v52);
            v66 = v65 << v68;
          }
          while ( v75 < 3 );
          v54 = 2;
          v55 = &v63 - v51;
          do
          {
            if ( v54 < v51 )
              *(&v61 + v54) = 0;
            else
              *(&v61 + v54) = *v55;
            --v54;
            --v55;
          }
          while ( v54 >= 0 );
          result = 0;
        }
        else
        {
          v62 = 0;
          v63 = 0;
          v61 = 2147483648;
          v44 = dword_6E69B97C / 32;
          v45 = dword_6E69B97C % 32;
          v66 = 0;
          v74 = 0;
          v68 = 32 - dword_6E69B97C % 32;
          do
          {
            v46 = (int *)(&v61 + v74);
            v47 = *v46;
            v65 = ~(-1 << v45) & *v46;
            v48 = v68;
            *v46 = v66 | (v47 >> v45);
            ++v74;
            v66 = v65 << v48;
          }
          while ( v74 < 3 );
          v49 = 2;
          v50 = &v63 - v44;
          do
          {
            if ( v49 < v44 )
              *(&v61 + v49) = 0;
            else
              *(&v61 + v49) = *v50;
            --v49;
            --v50;
          }
          while ( v49 >= 0 );
          v5 = dword_6E69B970 + dword_6E69B984;
          result = 1;
        }
        goto LABEL_77;
      }
      v61 = v58;
      v62 = v59;
      v17 = (dword_6E69B974 - v65) / 32;
      v63 = v60;
      v18 = (dword_6E69B974 - v65) % 32;
      v66 = 0;
      v71 = 0;
      v68 = 32 - v18;
      do
      {
        v19 = (int *)(&v61 + v71);
        v20 = *v19;
        v65 = ~(-1 << v18) & *v19;
        v21 = v68;
        *v19 = v66 | (v20 >> v18);
        ++v71;
        v66 = v65 << v21;
      }
      while ( v71 < 3 );
      v22 = 2;
      v23 = &v63 - v17;
      do
      {
        if ( v22 < v17 )
          *(&v61 + v22) = 0;
        else
          *(&v61 + v22) = *v23;
        --v22;
        --v23;
      }
      while ( v22 >= 0 );
      v24 = dword_6E69B978 - 1;
      v25 = dword_6E69B978 / 32;
      v66 = dword_6E69B978 / 32;
      v26 = dword_6E69B978 % 32;
      v27 = (int *)(&v61 + dword_6E69B978 / 32);
      v65 = 31 - dword_6E69B978 % 32;
      if ( (1 << (31 - dword_6E69B978 % 32)) & *v27 )
      {
        for ( j = (~(-1 << (31 - v26)) & *(&v61 + v25)) == 0; j; j = *(&v61 + v25) == 0 )
        {
          ++v25;
          if ( v25 >= 3 )
            goto LABEL_50;
        }
        v29 = v24 / 32;
        v72 = 0;
        v30 = 1 << (31 - v24 % 32);
        v31 = (int *)(&v61 + v24 / 32);
        v32 = *v31 + v30;
        if ( v32 < (unsigned int)*v31 || v32 < (unsigned int)v30 )
          v72 = 1;
        *v31 = v32;
        for ( k = v72; ; k = v36 )
        {
          --v29;
          if ( v29 < 0 || !k )
            break;
          v34 = (int *)(&v61 + v29);
          v35 = *v34 + 1;
          v36 = 0;
          if ( v35 < (unsigned int)*v34 || (unsigned int)v35 < 1 )
            v36 = 1;
          *v34 = v35;
        }
      }
LABEL_50:
      *v27 &= -1 << v65;
      if ( v66 + 1 < 3 )
        memset(&v61 + v66 + 1, 0, 4 * (3 - (v66 + 1)));
      v37 = (dword_6E69B97C + 1) / 32;
      v38 = (dword_6E69B97C + 1) % 32;
      v66 = 0;
      v73 = 0;
      v68 = 32 - v38;
      do
      {
        v39 = (int *)(&v61 + v73);
        v40 = *v39;
        v65 = ~(-1 << v38) & *v39;
        v41 = v68;
        *v39 = v66 | (v40 >> v38);
        ++v73;
        v66 = v65 << v41;
      }
      while ( v73 < 3 );
      v42 = 2;
      v43 = &v63 - v37;
      do
      {
        if ( v42 < v37 )
          *(&v61 + v42) = 0;
        else
          *(&v61 + v42) = *v43;
        --v42;
        --v43;
      }
      while ( v42 >= 0 );
    }
    else
    {
      v61 = 0;
      v62 = 0;
      v63 = 0;
    }
    v5 = 0;
    result = 2;
    goto LABEL_77;
  }
  v5 = 0;
  v6 = 0;
  while ( !*(&v61 + v6) )
  {
    ++v6;
    if ( v6 >= 3 )
    {
      result = 0;
      goto LABEL_77;
    }
  }
  v61 = 0;
  v62 = 0;
  v63 = 0;
  result = 2;
LABEL_77:
  v56 = v61 | (v64 != 0 ? 0x80000000 : 0) | (v5 << (31 - dword_6E69B97C));
  if ( dword_6E69B980 == 64 )
  {
    v57 = v62;
    *(_DWORD *)(a2 + 4) = v56;
    *(_DWORD *)a2 = v57;
  }
  else if ( dword_6E69B980 == 32 )
  {
    *(_DWORD *)a2 = v56;
  }
  return result;
}
// 6E69B970: using guessed type int dword_6E69B970;
// 6E69B974: using guessed type int dword_6E69B974;
// 6E69B978: using guessed type int dword_6E69B978;
// 6E69B97C: using guessed type int dword_6E69B97C;
// 6E69B980: using guessed type int dword_6E69B980;
// 6E69B984: using guessed type int dword_6E69B984;

//----- (6E6805E1) --------------------------------------------------------
signed int __cdecl __strgtold12_decimal_point(int a1, int a2, int a3, int a4, int a5, int a6, int a7, char a8)
{
  int v8; // edx@1
  signed int v9; // ecx@1
  char *v10; // edi@1
  char v11; // al@2
  char v12; // al@7
  int v13; // eax@14
  int v14; // eax@15
  int v15; // eax@60
  int v16; // eax@61
  bool v17; // zf@62
  int v18; // eax@75
  int v19; // ecx@88
  int v20; // eax@102
  int v21; // eax@104
  int *v22; // ecx@110
  char v23; // al@118
  int v24; // ecx@118
  int v25; // eax@118
  int v26; // ebx@119
  __int16 v27; // cx@121
  __int16 v28; // si@121
  unsigned __int16 v29; // cx@121
  __int16 v30; // si@121
  unsigned __int16 v31; // dx@121
  signed int v32; // eax@125
  __int64 *v33; // edi@135
  int v34; // eax@138
  unsigned int v35; // ecx@138
  int v36; // esi@138
  unsigned __int16 v37; // dx@145
  unsigned int v38; // eax@147
  int v39; // esi@150
  int v40; // eax@153
  unsigned int v41; // edi@153
  unsigned int v42; // eax@153
  __int16 v43; // cx@171
  unsigned int v44; // edx@171
  int v45; // esi@171
  unsigned int v46; // eax@171
  signed int result; // eax@176
  signed int v48; // [sp-4h] [bp-8Ch]@9
  signed int v49; // [sp-4h] [bp-8Ch]@12
  int v50; // [sp+Ch] [bp-7Ch]@118
  signed __int16 v51; // [sp+14h] [bp-74h]@1
  __int16 v52; // [sp+18h] [bp-70h]@121
  signed int v53; // [sp+1Ch] [bp-6Ch]@1
  signed int v54; // [sp+20h] [bp-68h]@1
  int v55; // [sp+20h] [bp-68h]@135
  int v56; // [sp+24h] [bp-64h]@1
  signed int v57; // [sp+24h] [bp-64h]@136
  signed int v58; // [sp+28h] [bp-60h]@1
  int v59; // [sp+28h] [bp-60h]@137
  signed int v60; // [sp+2Ch] [bp-5Ch]@1
  char *v61; // [sp+2Ch] [bp-5Ch]@137
  signed int v62; // [sp+30h] [bp-58h]@1
  signed int v63; // [sp+30h] [bp-58h]@135
  int v64; // [sp+34h] [bp-54h]@1
  signed int v65; // [sp+34h] [bp-54h]@110
  int v66; // [sp+38h] [bp-50h]@1
  int v67; // [sp+38h] [bp-50h]@121
  signed int v68; // [sp+3Ch] [bp-4Ch]@1
  signed int v69; // [sp+3Ch] [bp-4Ch]@138
  __int64 v70; // [sp+40h] [bp-48h]@120
  int v71; // [sp+48h] [bp-40h]@120
  __int64 v72; // [sp+4Ch] [bp-3Ch]@102
  unsigned int v73; // [sp+54h] [bp-34h]@127
  int v74; // [sp+56h] [bp-32h]@121
  unsigned int v75; // [sp+5Ch] [bp-2Ch]@121
  unsigned __int64 v76; // [sp+60h] [bp-28h]@121
  char v77; // [sp+68h] [bp-20h]@1
  char v78; // [sp+7Fh] [bp-9h]@80

  v8 = a3;
  v9 = 0;
  v10 = &v77;
  v51 = 0;
  v54 = 1;
  v68 = 0;
  v62 = 0;
  v60 = 0;
  v58 = 0;
  v56 = 0;
  v66 = 0;
  v53 = 0;
  v64 = a3;
  while ( 1 )
  {
    v11 = *(_BYTE *)v8;
    if ( *(_BYTE *)v8 != 32 && v11 != 9 && v11 != 10 && v11 != 13 )
      break;
    ++v8;
  }
  while ( 2 )
  {
    v12 = *(_BYTE *)v8++;
    switch ( v9 )
    {
      case 0:
        if ( (unsigned __int8)(v12 - 49) <= 8u )
          goto LABEL_9;
        if ( v12 == a8 )
          goto LABEL_12;
        v13 = v12 - 43;
        if ( !v13 )
        {
          v51 = 0;
          v9 = 2;
          continue;
        }
        v14 = v13 - 2;
        if ( !v14 )
        {
          v9 = 2;
          v51 = -32768;
          continue;
        }
        if ( v14 != 3 )
          goto LABEL_71;
        goto LABEL_17;
      case 1:
        v62 = 1;
        if ( (unsigned __int8)(v12 - 49) <= 8u )
          goto LABEL_9;
        if ( v12 == a8 )
          goto LABEL_22;
        if ( v12 == 43 || v12 == 45 )
          goto LABEL_31;
        if ( v12 != 48 )
          goto LABEL_26;
        goto LABEL_17;
      case 2:
        if ( (unsigned __int8)(v12 - 49) <= 8u )
        {
LABEL_9:
          v48 = 3;
          goto LABEL_10;
        }
        if ( v12 == a8 )
        {
LABEL_12:
          v49 = 5;
          goto LABEL_13;
        }
        if ( v12 != 48 )
          goto LABEL_35;
LABEL_17:
        v9 = 1;
        continue;
      case 3:
        v62 = 1;
        while ( v12 >= 48 && v12 <= 57 )
        {
          if ( (unsigned int)v68 >= 0x19 )
          {
            ++v66;
          }
          else
          {
            ++v68;
            *v10++ = v12 - 48;
          }
          v12 = *(_BYTE *)v8++;
        }
        if ( v12 != a8 )
          goto LABEL_44;
LABEL_22:
        v49 = 4;
        goto LABEL_13;
      case 4:
        v62 = 1;
        v60 = 1;
        if ( !v68 )
        {
          while ( v12 == 48 )
          {
            --v66;
            v12 = *(_BYTE *)v8++;
          }
        }
        while ( v12 >= 48 && v12 <= 57 )
        {
          if ( (unsigned int)v68 < 0x19 )
          {
            ++v68;
            *v10++ = v12 - 48;
            --v66;
          }
          v12 = *(_BYTE *)v8++;
        }
LABEL_44:
        if ( v12 != 43 && v12 != 45 )
        {
LABEL_26:
          if ( v12 <= 67 || v12 > 69 && (v12 <= 99 || v12 > 101) )
          {
LABEL_71:
            --v8;
            goto LABEL_78;
          }
          v49 = 6;
        }
        else
        {
LABEL_31:
          --v8;
          v49 = 11;
        }
        goto LABEL_13;
      case 5:
        v60 = 1;
        if ( (unsigned __int8)(v12 - 48) > 9u )
          goto LABEL_35;
        v48 = 4;
        goto LABEL_10;
      case 6:
        v64 = v8 - 2;
        if ( (unsigned __int8)(v12 - 49) <= 8u )
          goto LABEL_59;
        v15 = v12 - 43;
        if ( !v15 )
          goto LABEL_66;
        v16 = v15 - 2;
        if ( !v16 )
          goto LABEL_65;
        v17 = v16 == 3;
        goto LABEL_63;
      case 8:
        v58 = 1;
        while ( v12 == 48 )
          v12 = *(_BYTE *)v8++;
        if ( (unsigned __int8)(v12 - 49) > 8u )
          goto LABEL_71;
        goto LABEL_59;
      case 7:
        if ( (unsigned __int8)(v12 - 49) <= 8u )
        {
LABEL_59:
          v48 = 9;
LABEL_10:
          v9 = v48;
          --v8;
          continue;
        }
        v17 = v12 == 48;
LABEL_63:
        if ( !v17 )
        {
LABEL_35:
          v8 = v64;
          goto LABEL_78;
        }
        v49 = 8;
        goto LABEL_13;
      case 11:
        if ( !a7 )
        {
          v9 = 10;
          --v8;
LABEL_86:
          if ( v9 == 10 )
            goto LABEL_78;
          continue;
        }
        v18 = v12 - 43;
        v64 = v8 - 1;
        if ( !v18 )
        {
LABEL_66:
          v49 = 7;
LABEL_13:
          v9 = v49;
          continue;
        }
        if ( v18 == 2 )
        {
LABEL_65:
          v54 = -1;
          v9 = 7;
          continue;
        }
        --v8;
LABEL_78:
        *(_DWORD *)a2 = v8;
        if ( !v62 )
        {
          v53 = 4;
          goto LABEL_175;
        }
        if ( (unsigned int)v68 > 0x18 )
        {
          if ( v78 >= 5 )
            ++v78;
          --v10;
          ++v66;
          v68 = 24;
        }
        if ( !v68 )
        {
LABEL_175:
          v43 = 0;
          LOWORD(v46) = 0;
          v44 = 0;
          v45 = 0;
          goto LABEL_176;
        }
        while ( 1 )
        {
          --v10;
          if ( *v10 )
            break;
          --v68;
          ++v66;
        }
        __mtold12(&v77, v68, &v72);
        v20 = v56;
        if ( v54 < 0 )
          v20 = -v56;
        v21 = v66 + v20;
        if ( !v58 )
          v21 += a5;
        if ( !v60 )
          v21 -= a6;
        if ( v21 > 5200 )
        {
          v45 = 0;
          LOWORD(v46) = 0x7FFF;
          v44 = 2147483648;
          v43 = 0;
          v53 = 2;
          goto LABEL_176;
        }
        if ( v21 < -5200 )
        {
          v53 = 1;
          goto LABEL_175;
        }
        v22 = &_pow10pos[-24];
        v65 = v21;
        if ( v21 )
        {
          if ( v21 < 0 )
          {
            v65 = -v21;
            v22 = &_pow10neg[-24];
          }
          if ( !a4 )
            LOWORD(v72) = 0;
          if ( v65 )
          {
            while ( 1 )
            {
              v23 = v65;
              v65 >>= 3;
              v24 = (int)(v22 + 21);
              v25 = v23 & 7;
              v50 = v24;
              if ( !v25 )
                goto LABEL_170;
              v26 = v24 + 12 * v25;
              if ( *(_WORD *)v26 >= 0x8000u )
              {
                v70 = *(_QWORD *)v26;
                v71 = *(_DWORD *)(v26 + 8);
                --*(_DWORD *)((char *)&v70 + 2);
                v26 = (int)&v70;
              }
              v27 = *(_WORD *)(v26 + 10);
              v67 = 0;
              v75 = 0;
              v76 = 0i64;
              v28 = v74 ^ v27;
              v29 = v27 & 0x7FFF;
              v30 = v28 & 0x8000;
              v52 = v30;
              v31 = v29 + (v74 & 0x7FFF);
              if ( (v74 & 0x7FFFu) >= 0x7FFF || v29 >= 0x7FFFu || v31 > 0xBFFDu )
                break;
              if ( v31 <= 0x3FBFu )
              {
                v32 = 0;
                v72 = 0i64;
LABEL_169:
                v73 = v32;
                goto LABEL_170;
              }
              if ( v74 & 0x7FFF || (++v31, v73 & 0x7FFFFFFF) || v72 )
              {
                if ( v29 || (++v31, *(_DWORD *)(v26 + 8) & 0x7FFFFFFF) || *(_DWORD *)(v26 + 4) || *(_DWORD *)v26 )
                {
                  v55 = 0;
                  v33 = (__int64 *)&v76;
                  v63 = 5;
                  do
                  {
                    v57 = v63;
                    if ( v63 > 0 )
                    {
                      v61 = (char *)&v72 + 2 * v55;
                      v59 = v26 + 8;
                      do
                      {
                        v69 = 0;
                        v34 = *(_WORD *)v59 * *(_WORD *)v61;
                        v35 = *((_DWORD *)v33 - 1);
                        v36 = v35 + v34;
                        if ( v35 + v34 < v35 || v36 < (unsigned int)v34 )
                          v69 = 1;
                        *((_DWORD *)v33 - 1) = v36;
                        if ( v69 )
                          ++*(_WORD *)v33;
                        v61 += 2;
                        v59 -= 2;
                        --v57;
                      }
                      while ( v57 > 0 );
                    }
                    v33 = (__int64 *)((char *)v33 + 2);
                    ++v55;
                    --v63;
                  }
                  while ( v63 > 0 );
                  v37 = v31 - 16382;
                  if ( (signed __int16)v37 <= 0 )
                    goto LABEL_179;
                  do
                  {
                    if ( SHIDWORD(v76) < 0 )
                      break;
                    v38 = v75;
                    v75 *= 2;
                    --v37;
                    v76 = __PAIR__(v76 >> 31, (v38 >> 31) | 2 * v76);
                  }
                  while ( (signed __int16)v37 > 0 );
                  if ( (signed __int16)v37 <= 0 )
                  {
LABEL_179:
                    --v37;
                    if ( (v37 & 0x8000u) != 0 )
                    {
                      v39 = (unsigned __int16)-v37;
                      v37 = 0;
                      do
                      {
                        if ( v75 & 1 )
                          ++v67;
                        v40 = HIDWORD(v76);
                        HIDWORD(v76) >>= 1;
                        v41 = (v40 << 31) | ((unsigned int)v76 >> 1);
                        v42 = ((_DWORD)v76 << 31) | (v75 >> 1);
                        --v39;
                        LODWORD(v76) = v41;
                        v75 = v42;
                      }
                      while ( v39 );
                      if ( v67 )
                        LOWORD(v75) = v75 | 1;
                    }
                  }
                  if ( (unsigned __int16)v75 > 0x8000u || (v75 & 0x1FFFF) == 98304 )
                  {
                    if ( *(unsigned int *)((char *)&v75 + 2) == -1 )
                    {
                      *(unsigned int *)((char *)&v75 + 2) = 0;
                      if ( *(_DWORD *)((char *)&v76 + 2) == -1 )
                      {
                        *(_DWORD *)((char *)&v76 + 2) = 0;
                        if ( WORD3(v76) == -1 )
                        {
                          WORD3(v76) = -32768;
                          ++v37;
                        }
                        else
                        {
                          ++WORD3(v76);
                        }
                      }
                      else
                      {
                        ++*(_DWORD *)((char *)&v76 + 2);
                      }
                    }
                    else
                    {
                      ++*(unsigned int *)((char *)&v75 + 2);
                    }
                  }
                  if ( v37 < 0x7FFFu )
                  {
                    LOWORD(v72) = HIWORD(v75);
                    *(__int64 *)((char *)&v72 + 2) = v76;
                    LOWORD(v74) = v52 | v37;
                  }
                  else
                  {
                    v72 = 0i64;
                    v73 = v52 == 0 ? 2147450880 : -32768;
                  }
                }
                else
                {
                  v73 = 0;
                  v72 = 0i64;
                }
              }
              else
              {
                LOWORD(v74) = 0;
              }
LABEL_170:
              if ( !v65 )
                goto LABEL_171;
              v22 = (int *)v50;
            }
            v32 = v30 == 0 ? 2147450880 : -32768;
            v72 = 0i64;
            goto LABEL_169;
          }
        }
LABEL_171:
        v43 = v72;
        v44 = *(_DWORD *)((char *)&v72 + 6);
        v45 = *(_DWORD *)((char *)&v72 + 2);
        v46 = v73 >> 16;
LABEL_176:
        *(_WORD *)a1 = v43;
        *(_DWORD *)(a1 + 2) = v45;
        *(_WORD *)(a1 + 10) = v51 | v46;
        result = v53;
        *(_DWORD *)(a1 + 6) = v44;
        return result;
      default:
        goto LABEL_86;
      case 9:
        v58 = 1;
        v19 = 0;
        while ( 2 )
        {
          if ( v12 >= 48 && v12 <= 57 )
          {
            v19 = 10 * v19 + v12 - 48;
            if ( v19 <= 5200 )
            {
              v12 = *(_BYTE *)v8++;
              continue;
            }
            v19 = 5201;
          }
          break;
        }
        v56 = v19;
        while ( v12 >= 48 && v12 <= 57 )
          v12 = *(_BYTE *)v8++;
        goto LABEL_71;
    }
  }
}
// 6E68040E: using guessed type _DWORD __cdecl __mtold12(_DWORD, _DWORD, _DWORD);
// 6E69B988: using guessed type int _pow10pos[2];
// 6E69BAE8: using guessed type int _pow10neg[87];

//----- (6E680C73) --------------------------------------------------------
signed int __cdecl __strgtold12_l(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  signed int result; // eax@2

  if ( a8 )
  {
    result = __strgtold12_decimal_point(a1, a2, a3, a4, a5, a6, a7, ***(_BYTE ***)(*(_DWORD *)a8 + 188));
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 0;
  }
  return result;
}

//----- (6E6816B1) --------------------------------------------------------
int __cdecl _resetstkoflw()
{
  void *v0; // esp@3
  DWORD v1; // ebx@4
  DWORD v2; // edi@4
  HMODULE v3; // eax@5
  FARPROC v4; // eax@7
  ULONG v5; // esi@16
  int result; // eax@21
  int v7; // [sp-4h] [bp-6Ch]@3
  struct _SYSTEM_INFO SystemInfo; // [sp+Ch] [bp-5Ch]@4
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+30h] [bp-38h]@3
  DWORD flOldProtect; // [sp+4Ch] [bp-1Ch]@20
  PVOID v11; // [sp+50h] [bp-18h]@4
  LPCVOID lpAddress; // [sp+54h] [bp-14h]@3
  ULONG v13; // [sp+58h] [bp-10h]@5
  int v14; // [sp+5Ch] [bp-Ch]@1
  ULONG ulAugend; // [sp+60h] [bp-8h]@4

  v14 = 0;
  if ( _get_osplatform((int)&v14) )
    _invoke_watson(0, 0, 0, 0, 0);
  v0 = alloca(4);
  lpAddress = &v7;
  if ( !VirtualQuery(&v7, &Buffer, 0x1Cu) )
    goto LABEL_25;
  v11 = Buffer.AllocationBase;
  GetSystemInfo(&SystemInfo);
  v1 = SystemInfo.dwPageSize;
  v2 = v14 != 1 ? 260 : 1;
  ulAugend = 0;
  if ( v14 == 2 )
  {
    v13 = 0;
    v3 = GetModuleHandleW(L"kernelbase.dll");
    if ( v3 || (v3 = GetModuleHandleW(L"kernel32.dll")) != 0 )
    {
      v4 = GetProcAddress(v3, "SetThreadStackGuarantee");
      if ( v4 )
      {
        v13 = 0;
        if ( ((int (__stdcall *)(ULONG *))v4)(&v13) == 1 )
        {
          if ( v13 )
            ulAugend = v13;
        }
      }
    }
  }
  if ( ULongAdd(ulAugend, v1 - 1, &ulAugend) < 0 )
    goto LABEL_25;
  ulAugend &= ~(v1 - 1);
  if ( ulAugend )
  {
    if ( ULongAdd(ulAugend, v1, &ulAugend) < 0 )
      goto LABEL_25;
  }
  if ( ulAugend < 2 * v1 )
    ulAugend = 2 * v1;
  v5 = ((unsigned int)lpAddress & ~(v1 - 1)) - ulAugend;
  if ( v14 == 1 )
    v1 = 17;
  if ( v5 >= (unsigned int)((char *)v11 + v1)
    && VirtualAlloc((LPVOID)v5, ulAugend, 0x1000u, 4u)
    && VirtualProtect((LPVOID)v5, ulAugend, v2, &flOldProtect) )
    result = 1;
  else
LABEL_25:
    result = 0;
  return result;
}

//----- (6E681959) --------------------------------------------------------
int __cdecl _commit(int Filehandle)
{
  int *v2; // edi@7
  int v3; // esi@7
  __int32 v4; // eax@9
  DWORD v5; // [sp+14h] [bp-1Ch]@10

  if ( Filehandle == -2 )
  {
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0
    || Filehandle >= _nhandle
    || (v2 = &__pioinfo[Filehandle >> 5], v3 = 36 * (Filehandle & 0x1F), !(*(_BYTE *)(*v2 + v3 + 4) & 1)) )
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  __lock_fhandle(Filehandle);
  if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
  {
    v4 = _get_osfhandle(Filehandle);
    if ( FlushFileBuffers((HANDLE)v4) )
      v5 = 0;
    else
      v5 = GetLastError();
    if ( !v5 )
      goto LABEL_15;
    *__doserrno() = v5;
  }
  *_errno() = 9;
  v5 = -1;
LABEL_15:
  _unlock_fhandle(Filehandle);
  return v5;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E681CA1) --------------------------------------------------------
int __cdecl strtolX(int a1, int a2, int a3, int a4)
{
  int result; // eax@2

  if ( __locale_changed )
    result = strtoxl(0, a1, a2, a3, 0, a4);
  else
    result = strtoxl((struct localeinfo_struct *)&__initiallocalestructinfo, a1, a2, a3, 0, a4);
  return result;
}
// 6E699490: using guessed type int (*__initiallocalestructinfo)[22];
// 6E69B2CC: using guessed type int __locale_changed;

//----- (6E681CD4) --------------------------------------------------------
signed int __cdecl _free_osfhnd(signed int a1)
{
  int v1; // esi@3
  int *v2; // edi@3
  int v3; // eax@3
  DWORD v5; // [sp-8h] [bp-14h]@9

  if ( a1 >= 0 && a1 < _nhandle )
  {
    v1 = 36 * (a1 & 0x1F);
    v2 = &__pioinfo[a1 >> 5];
    v3 = v1 + *v2;
    if ( *(_BYTE *)(v3 + 4) & 1 )
    {
      if ( *(_DWORD *)v3 != -1 )
      {
        if ( __app_type == 1 )
        {
          if ( !a1 )
          {
            v5 = -10;
            goto LABEL_12;
          }
          if ( a1 == 1 )
          {
            v5 = -11;
            goto LABEL_12;
          }
          if ( a1 == 2 )
          {
            v5 = -12;
LABEL_12:
            SetStdHandle(v5, 0);
            goto LABEL_13;
          }
        }
LABEL_13:
        *(_DWORD *)(v1 + *v2) = -1;
        return 0;
      }
    }
  }
  *_errno() = 9;
  *__doserrno() = 0;
  return -1;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69BD2C: using guessed type int __app_type;

//----- (6E681D5F) --------------------------------------------------------
__int32 __cdecl _get_osfhandle(int a1)
{
  int v2; // eax@7

  if ( a1 == -1 )
    goto LABEL_2;
  if ( a1 == -2 )
  {
    *__doserrno() = 0;
LABEL_2:
    *_errno() = 9;
    return -1;
  }
  if ( a1 < 0 || a1 >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    v2 = __pioinfo[a1 >> 5] + 36 * (a1 & 0x1F);
    if ( *(_BYTE *)(v2 + 4) & 1 )
      return *(_DWORD *)v2;
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
  }
  return -1;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E681DF6) --------------------------------------------------------
int __cdecl __lock_fhandle(int Filehandle)
{
  int v1; // esi@1
  int v3; // [sp+10h] [bp-1Ch]@1

  v1 = __pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F);
  v3 = 1;
  if ( !(*(_BYTE *)(v1 + 8) & 4) )
  {
    _lock(10);
    if ( !(*(_BYTE *)(v1 + 8) & 4) )
    {
      if ( !__crtInitCritSecAndSpinCount(v1 + 12, 4000) )
        v3 = 0;
      *(_DWORD *)(v1 + 8) |= 4u;
    }
    _unlock(10);
  }
  if ( v3 )
    EnterCriticalSection((LPCRITICAL_SECTION)(__pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F) + 12));
  return v3;
}
// 6E64769D: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E681EC1) --------------------------------------------------------
void __cdecl _unlock_fhandle(int Filehandle)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(__pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F) + 12));
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E681EED) --------------------------------------------------------
int __cdecl _flswbuf(int a1, FILE *File)
{
  int v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  const void *v6; // eax@15
  int v7; // edi@15
  unsigned int v8; // edi@15
  int v9; // eax@20
  __int64 v10; // rax@23
  unsigned __int16 v11; // bx@24
  int v12; // [sp+4h] [bp-4h]@9
  signed int Filea; // [sp+14h] [bp+Ch]@1

  v2 = (int)File;
  Filea = _fileno(File);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return 0xFFFF;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    *(_DWORD *)(v2 + 4) = 0;
    if ( !(v3 & 0x10) )
    {
      *(_DWORD *)(v2 + 12) = v3 | 0x20;
      return 0xFFFF;
    }
    *(_DWORD *)v2 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 12) = v3 & 0xFFFFFFFE;
  }
  v5 = *(_DWORD *)(v2 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v2 + 12) = v5;
  *(_DWORD *)(v2 + 4) = 0;
  v12 = 0;
  if ( !(v5 & 0x10C) && ((int *)v2 != dword_6E69A058 && (int *)v2 != dword_6E69A078 || !_isatty(Filea)) )
    _getbuf(v2);
  if ( *(_DWORD *)(v2 + 12) & 0x108 )
  {
    v6 = *(const void **)(v2 + 8);
    v7 = *(_DWORD *)v2;
    *(_DWORD *)v2 = (char *)v6 + 2;
    v8 = v7 - (_DWORD)v6;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 24) - 2;
    if ( (signed int)v8 <= 0 )
    {
      if ( Filea == -1 || Filea == -2 )
        v9 = (int)__badioinfo;
      else
        v9 = __pioinfo[Filea >> 5] + 36 * (Filea & 0x1F);
      if ( *(_BYTE *)(v9 + 4) & 0x20 )
      {
        v10 = _lseeki64(Filea, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v12 = _write(Filea, v6, v8);
    }
    v11 = a1;
    **(_WORD **)(v2 + 8) = a1;
  }
  else
  {
    v11 = a1;
    v8 = 2;
    LOWORD(v12) = a1;
    v12 = _write(Filea, &v12, 2u);
  }
  if ( v12 != v8 )
  {
LABEL_27:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return 0xFFFF;
  }
  return v11;
}
// 6E699BC0: using guessed type int __pioinfo[];
// 6E69A058: using guessed type int dword_6E69A058[3];
// 6E69A078: using guessed type int dword_6E69A078[3];
// 6E69B624: using guessed type int __badioinfo[9];

//----- (6E68218B) --------------------------------------------------------
signed int __cdecl _close_nolock(signed int a1)
{
  __int32 v1; // edi@6
  __int32 v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( _get_osfhandle(a1) == -1
    || (a1 == 1 && *(_BYTE *)(__pioinfo[0] + 76) & 1 || a1 == 2 && *(_BYTE *)(__pioinfo[0] + 40) & 1)
    && (v1 = _get_osfhandle(2), _get_osfhandle(1) == v1)
    || (v2 = _get_osfhandle(a1), CloseHandle((HANDLE)v2)) )
    v3 = 0;
  else
    v3 = GetLastError();
  _free_osfhnd(a1);
  *(_BYTE *)(__pioinfo[a1 >> 5] + 36 * (a1 & 0x1F) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6E676F13: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E682229) --------------------------------------------------------
int __cdecl _close(int Filehandle)
{
  int result; // eax@3
  int *v2; // ebx@9
  int v3; // esi@9
  int v4; // [sp+14h] [bp-1Ch]@12

  if ( Filehandle == -1 )
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0 || Filehandle >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v2 = &__pioinfo[Filehandle >> 5];
  v3 = 36 * (Filehandle & 0x1F);
  if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
  {
    __lock_fhandle(Filehandle);
    if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
    {
      v4 = _close_nolock(Filehandle);
    }
    else
    {
      *_errno() = 9;
      v4 = -1;
    }
    _unlock_fhandle(Filehandle);
    result = v4;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 6E699BC0: using guessed type int __pioinfo[];

//----- (6E6823A2) --------------------------------------------------------
signed int __stdcall DwWin32ErrorFromHr(__int32 a1)
{
  signed int result; // eax@1
  __int32 v2; // eax@2

  result = 0;
  if ( a1 < 0 )
  {
    v2 = (a1 >> 16) & 0x1FFF;
    switch ( v2 )
    {
      case 15:
        result = (unsigned __int16)a1 | 0xE0000000;
        break;
      case 7:
        result = (unsigned __int16)a1;
        break;
      case 4:
        result = 31;
        break;
      default:
        result = a1;
        break;
    }
  }
  return result;
}

//----- (6E6823E8) --------------------------------------------------------
signed int __stdcall HrCoTaskMemAlloc(SIZE_T cb, void **a2)
{
  signed int v2; // esi@1
  LPVOID v3; // eax@1

  v2 = 0;
  v3 = CoTaskMemAlloc(cb);
  *a2 = v3;
  if ( !v3 )
    v2 = -2147024882;
  return v2;
}

//----- (6E682413) --------------------------------------------------------
int __stdcall IUnknown::QueryInterface<IUnknown>(int a1, int a2)
{
  return (**(int (__stdcall ***)(int, GUID *, int))a1)(a1, &_GUID_00000000_0000_0000_c000_000000000046, a2);
}

//----- (6E682441) --------------------------------------------------------
__int32 __stdcall HrLoadLibAndGetProcs(LPCWSTR lpLibFileName, unsigned int a2, const char *const *a3, HINSTANCE *a4, int (__stdcall **Dst)())
{
  HINSTANCE v5; // ebx@1
  int (__stdcall **v6)(); // esi@3
  FARPROC v7; // eax@4
  __int32 v9; // [sp+8h] [bp-4h]@1
  unsigned int lpLibFileNamea; // [sp+14h] [bp+8h]@3

  v9 = 0;
  v5 = LoadLibraryW(lpLibFileName);
  *a4 = v5;
  memset(Dst, 0, 4 * a2);
  if ( v5 )
  {
    if ( a2 )
    {
      v6 = Dst;
      lpLibFileNamea = a2;
      do
      {
        v7 = GetProcAddress(v5, *(LPCSTR *)((char *)v6 + (char *)a3 - (char *)Dst));
        *v6 = v7;
        if ( !v7 )
          v9 = 1;
        ++v6;
        --lpLibFileNamea;
      }
      while ( lpLibFileNamea );
    }
    if ( a2 == 1 && !*Dst )
    {
      v9 = HrFromLastWin32Error();
      FreeLibrary(v5);
    }
  }
  else
  {
    v9 = HrFromLastWin32Error();
  }
  return v9;
}

//----- (6E6824DF) --------------------------------------------------------
__int32 __stdcall HrCreateEventWithWorldAccess(LPCWSTR lpName, BOOL bManualReset, BOOL bInitialState, void *lpMem, void **a5)
{
  void *v5; // ebx@1
  void **v6; // esi@3
  __int32 v7; // edi@3
  struct _SECURITY_ATTRIBUTES EventAttributes; // [sp+Ch] [bp-Ch]@4

  v5 = lpMem;
  if ( lpMem )
    *(_DWORD *)lpMem = 0;
  v6 = a5;
  *a5 = 0;
  v7 = HrAllocateSecurityDescriptorAllowAccessToWorld(&lpMem);
  if ( v7 >= 0 )
  {
    EventAttributes.bInheritHandle = 0;
    EventAttributes.lpSecurityDescriptor = lpMem;
    EventAttributes.nLength = 12;
    *v6 = CreateEventW(&EventAttributes, bManualReset, bInitialState, lpName);
    v7 = HrFromLastWin32Error();
    if ( v7 == -2147024713 )
    {
      if ( v5 )
        *(_DWORD *)v5 = 1;
      v7 = 0;
    }
    MemFree(lpMem);
  }
  return v7;
}

//----- (6E682567) --------------------------------------------------------
void __stdcall NcSetProxyBlanket(IUnknown *pProxy)
{
  struct IUnknown *v1; // [sp+8h] [bp-4h]@2

  if ( CoSetProxyBlanket(pProxy, 0xFFFFFFFF, 0, (OLECHAR *)0xFFFFFFFF, 3u, 3u, 0, 0) >= 0 )
  {
    v1 = 0;
    if ( IUnknown::QueryInterface<IUnknown>((int)pProxy, (int)&v1) >= 0 )
    {
      CoSetProxyBlanket(pProxy, 0xFFFFFFFF, 0, (OLECHAR *)0xFFFFFFFF, 3u, 3u, 0, 0);
      ReleaseObj(v1);
    }
  }
}

//----- (6E6825C1) --------------------------------------------------------
__int32 __stdcall HrCreateInstanceBase(IID *rclsid, DWORD dwClsContext, IID *riid, LPVOID *ppv)
{
  HRESULT v4; // esi@1

  v4 = CoCreateInstance(rclsid, 0, dwClsContext, riid, ppv);
  if ( v4 >= 0 && dwClsContext & 4 )
    NcSetProxyBlanket((IUnknown *)*ppv);
  return v4;
}

//----- (6E6825FD) --------------------------------------------------------
__int32 __stdcall HrQIAndSetProxyBlanketBase(struct IUnknown *a1, const struct _GUID *a2, void **a3)
{
  HRESULT v3; // edi@1

  v3 = a1->lpVtbl->QueryInterface(a1, a2, a3);
  if ( v3 >= 0 )
    NcSetProxyBlanket((IUnknown *)*a3);
  return v3;
}

//----- (6E68262D) --------------------------------------------------------
unsigned int __stdcall CbOfSz(const unsigned __int16 *a1)
{
  return 2 * wcslen(a1);
}

//----- (6E682651) --------------------------------------------------------
unsigned int __stdcall CbOfSzSafe(const unsigned __int16 *a1)
{
  unsigned int result; // eax@1

  result = 0;
  if ( a1 )
    result = CbOfSz(a1);
  return result;
}

//----- (6E682669) --------------------------------------------------------
signed int __stdcall FFindStringInCommaSeparatedList(const WCHAR *lpString, const WCHAR *a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // ebx@1
  const WCHAR *v6; // eax@1
  const WCHAR *v7; // esi@3
  wchar_t *v8; // eax@4
  signed int v9; // ecx@5
  int i; // edx@7
  int v11; // edx@12
  int v12; // edx@13
  int v13; // ecx@14
  const WCHAR *v14; // eax@25
  const WCHAR *v15; // esi@25
  wchar_t *v16; // eax@28
  int v18; // [sp+Ch] [bp-8h]@1
  signed int v19; // [sp+10h] [bp-4h]@1

  v4 = lstrlenW(lpString);
  v5 = a4;
  v19 = 0;
  v18 = lstrlenW(a2);
  v6 = a2;
  if ( a4 )
    *(_DWORD *)a4 = 0;
  v7 = a2;
  do
  {
    v8 = wcsstr(v6, lpString);
    if ( !v8 )
      break;
    v9 = 1;
    v7 = (const WCHAR *)(v8 - a2);
    v19 = 1;
    if ( (signed int)v7 <= 0 )
      goto LABEL_13;
    if ( !a3 )
    {
      for ( i = (int)(v8 - 1); 32 == *(_WORD *)i; i -= 2 )
      {
        if ( v9 > (signed int)v7 )
          goto LABEL_13;
        ++v9;
      }
    }
    if ( v9 > (signed int)v7 || (v11 = (int)&v8[-v9], (v19 = *(_WORD *)v11 == 44) != 0) )
    {
LABEL_13:
      v12 = (int)((char *)v7 + v4);
      if ( (signed int)((char *)v7 + v4) < v18 )
      {
        v13 = v4;
        if ( !a3 && 32 == v8[v4] )
        {
          do
          {
            if ( v12 >= v18 )
              break;
            ++v13;
            ++v12;
          }
          while ( 32 == v8[v13] );
        }
        if ( (signed int)((char *)v7 + v13) < v18 )
          v19 = v8[v13] == 44;
        if ( !a3 )
          v8 += v13 - v4;
      }
    }
    v5 = a4;
    v6 = &v8[v4];
  }
  while ( !v19 );
  if ( v19 && v5 )
  {
    v14 = a2;
    v15 = &a2[(_DWORD)v7];
    while ( 1 )
    {
      v16 = wcschr(v14, 0x2Cu);
      if ( !v16 || v16 >= v15 )
        break;
      ++*(_DWORD *)v5;
      v14 = v16 + 1;
    }
  }
  return v19;
}

//----- (6E682785) --------------------------------------------------------
const unsigned __int16 *__stdcall SzLoadStringPcch(HINSTANCE hModule, unsigned int a2, int *a3)
{
  int v3; // ebx@1
  LPVOID v4; // edi@1
  HRSRC v5; // eax@1
  HGLOBAL v6; // eax@2
  int v7; // ebx@4
  unsigned int v8; // eax@5
  int v9; // edi@5
  unsigned int v11; // [sp+18h] [bp+Ch]@4

  v3 = 1;
  v4 = L" ";
  v5 = FindResourceW(hModule, (LPCWSTR)(((unsigned int)(unsigned __int16)a2 >> 4) + 1), (LPCWSTR)6);
  if ( v5 )
  {
    v6 = LoadResource(hModule, v5);
    if ( v6 )
    {
      v4 = LockResource(v6);
      if ( !v4 )
        goto LABEL_12;
      v11 = a2 & 0xF;
      v7 = 0;
      do
      {
        v8 = v11;
        v9 = (int)((char *)v4 + 2 * v7);
        v7 = *(_WORD *)v9;
        v4 = (LPVOID)(v9 + 2);
        --v11;
      }
      while ( v8 );
      if ( v7 )
      {
        v3 = v7 - 1;
      }
      else
      {
LABEL_12:
        v3 = 1;
        v4 = L" ";
      }
    }
  }
  *a3 = v3;
  return (const unsigned __int16 *)v4;
}

//----- (6E682801) --------------------------------------------------------
int __stdcall FSubStringPresent(LPCWSTR lpString, wchar_t *Str2, wchar_t a3)
{
  const wchar_t *v3; // esi@1
  int v4; // ebx@1
  int v5; // edi@7
  wchar_t *v6; // eax@10

  v3 = lpString;
  v4 = 0;
  if ( lpString && *lpString && Str2 && *Str2 )
  {
    do
    {
      v6 = wcschr(v3, a3);
      v5 = (int)v6;
      if ( !*v3 )
        break;
      if ( !v6 )
        v5 = (int)&v3[lstrlenW(v3)];
      if ( !_wcsnicmp(v3, Str2, (v5 - (signed int)v3) >> 1) )
        return 1;
      v3 = (const wchar_t *)(v5 + 2 * (*(_WORD *)v5 != 0));
    }
    while ( *v3 );
  }
  return v4;
}

//----- (6E68287F) --------------------------------------------------------
signed int __userpurge sub_6E68287F@<eax>(unsigned int a1@<ecx>, int a2@<esi>, int a3, unsigned int a4)
{
  signed int result; // eax@1
  int v5; // eax@5
  signed int v6; // edi@5
  unsigned int v7; // edx@5

  result = 0;
  if ( !a1 || a1 > a4 )
    result = -2147024809;
  if ( result < 0 )
  {
    *(_DWORD *)a2 = 0;
  }
  else
  {
    v5 = a3;
    v6 = 0;
    v7 = a1;
    if ( !a1 )
      goto LABEL_18;
    do
    {
      if ( !*(_WORD *)v5 )
        break;
      v5 += 2;
      --v7;
    }
    while ( v7 );
    if ( !v7 )
LABEL_18:
      v6 = -2147024809;
    if ( a2 )
    {
      if ( v6 < 0 )
        *(_DWORD *)a2 = 0;
      else
        *(_DWORD *)a2 = a1 - v7;
    }
    result = v6;
  }
  return result;
}

//----- (6E6828D9) --------------------------------------------------------
signed int __stdcall StringCbCatNW(unsigned __int16 *a1, unsigned int a2, const unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4; // edi@1
  signed int result; // eax@1

  v4 = a2 >> 1;
  result = sub_6E68287F(a2 >> 1, (int)&a2, (int)a1, 0x7FFFFFFFu);
  if ( result >= 0 )
  {
    if ( a4 >> 1 <= 0x7FFFFFFE )
      result = sub_6E641D2F((int)a3, v4 - a2, (int)&a1[a2], 0, a4 >> 1);
    else
      result = -2147024809;
  }
  return result;
}

//----- (6E682931) --------------------------------------------------------
signed int __stdcall HrAddStringToDelimitedSz(wchar_t *Str2, wchar_t *Str, wchar_t a3, unsigned __int32 a4, unsigned __int32 a5, unsigned __int16 **a6)
{
  unsigned __int16 **v6; // esi@1
  wchar_t *v7; // ebx@16
  unsigned int v8; // edi@16
  unsigned int v9; // edi@16
  unsigned __int16 *v10; // eax@16
  int v11; // eax@28
  int v12; // eax@30
  int v13; // eax@35
  unsigned int v14; // eax@36
  int v15; // ebx@44
  int v16; // eax@45
  int v18; // [sp+10h] [bp-10h]@28
  signed int v19; // [sp+1Ch] [bp-4h]@1
  wchar_t *Stra; // [sp+2Ch] [bp+Ch]@27
  unsigned __int32 v21; // [sp+3Ch] [bp+1Ch]@18

  v6 = a6;
  v19 = 0;
  if ( Str2 && a6 )
    *a6 = 0;
  else
    v19 = -2147467261;
  if ( a4 & 2 && (a4 & 4 || a4 & 8) || a4 & 4 && a4 & 8 )
    v19 = -2147024809;
  if ( !(a4 & 2) && !(a4 & 4) && !(a4 & 8) )
    v19 = -2147024809;
  if ( !v19 )
  {
    v7 = Str;
    v8 = CbOfSzSafe(Str2);
    v9 = v8 + CbOfSzAndTermSafe(Str) + 2;
    v10 = (unsigned __int16 *)MemAlloc(v9);
    *a6 = v10;
    if ( !v10 )
      return -2147024882;
    v21 = 0;
    *v10 = 0;
    if ( a4 & 2 || a4 & 8 && (!a5 || !Str || !*Str) )
    {
      StringCbCopyW(*v6, v9, Str2);
      v21 = 1;
    }
    if ( !Str )
      goto LABEL_41;
    while ( 2 )
    {
      if ( !*v7 )
      {
LABEL_41:
        if ( a4 & 4 || a4 & 8 && v21 <= a5 )
        {
          v15 = lstrlenW(*v6);
          if ( lstrlenW(*v6) > 0 )
          {
            v16 = v15;
            (*v6)[v16] = a3;
            (*v6)[v16 + 1] = 0;
          }
          StringCbCatW(*v6, v9, Str2);
        }
        return v19;
      }
      Stra = wcschr(v7, a3);
      while ( 1 )
      {
        if ( !*v7 )
          goto LABEL_41;
        if ( !Stra )
          Stra = &v7[lstrlenW(v7)];
        v11 = lstrlenW(*v6);
        v18 = v11;
        if ( !(a4 & 8) || v21 != a5 )
          break;
        v12 = v11;
        (*v6)[v12] = a3;
        (*v6)[v12 + 1] = 0;
        StringCbCatW(*v6, v9, Str2);
        ++v21;
      }
      if ( !(a4 & 1) )
      {
        if ( !_wcsnicmp(v7, Str2, Stra - v7) )
        {
LABEL_37:
          v7 = &Stra[*Stra != 0];
          continue;
        }
        v11 = v18;
      }
      break;
    }
    if ( v11 > 0 )
    {
      v13 = v11;
      (*v6)[v13] = a3;
      (*v6)[v13 + 1] = 0;
    }
    v14 = CchToCb(Stra - v7);
    StringCbCatNW(*v6, v9, v7, v14);
    ++v21;
    goto LABEL_37;
  }
  return v19;
}

//----- (6E682B40) --------------------------------------------------------
signed int __stdcall HrRemoveStringFromDelimitedSz(wchar_t *Str2, wchar_t *Str, wchar_t a3, char a4, unsigned __int16 **a5)
{
  unsigned __int16 **v5; // edi@1
  signed int result; // eax@2
  wchar_t *v7; // esi@3
  unsigned int v8; // eax@3
  unsigned __int16 *v9; // eax@3
  wchar_t *v10; // eax@5
  bool v11; // zf@5
  int v12; // eax@12
  int v13; // eax@13
  unsigned int v14; // eax@14
  int v15; // eax@15
  unsigned int v16; // [sp+8h] [bp-8h]@3
  signed int v17; // [sp+Ch] [bp-4h]@3
  wchar_t *Stra; // [sp+1Ch] [bp+Ch]@5
  unsigned __int16 **v19; // [sp+28h] [bp+18h]@7

  v5 = a5;
  if ( a5 )
  {
    v7 = Str;
    v17 = -2147024882;
    v8 = CbOfSzAndTermSafe(Str);
    v16 = v8;
    v9 = (unsigned __int16 *)MemAlloc(v8);
    *a5 = v9;
    if ( v9 )
    {
      v17 = 0;
      *v9 = 0;
      if ( Str )
      {
        v10 = wcschr(Str, a3);
        v11 = *Str == 0;
        Stra = 0;
        while ( 1 )
        {
          v19 = (unsigned __int16 **)v10;
          if ( v11 )
            break;
          if ( !v10 )
            v19 = (unsigned __int16 **)&v7[lstrlenW(v7)];
          if ( _wcsnicmp(v7, Str2, ((char *)v19 - (char *)v7) >> 1) || a4 & 0x20 && (unsigned int)Stra > 0 )
          {
            v12 = lstrlenW(*v5);
            if ( v12 > 0 )
            {
              v13 = v12;
              (*v5)[v13] = a3;
              (*v5)[v13 + 1] = 0;
            }
            v14 = CchToCb(((char *)v19 - (char *)v7) >> 1);
            StringCbCatNW(*v5, v16, v7, v14);
          }
          else
          {
            Stra = (wchar_t *)((char *)Stra + 1);
          }
          v15 = *(_WORD *)v19 != 0;
          v7 = (wchar_t *)((char *)v19 + 2 * v15);
          if ( !*v7 )
            break;
          v10 = wcschr((const wchar_t *)v19 + v15, a3);
          v11 = *v7 == 0;
        }
      }
    }
    result = v17;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E682C4D) --------------------------------------------------------
int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::erase(int this, int a2, void *lpMem)
{
  void *v3; // eax@1
  int v4; // esi@1
  int result; // eax@3
  void *lpMema; // [sp+10h] [bp+Ch]@1

  v3 = lpMem;
  v4 = this;
  lpMema = *(void **)lpMem;
  if ( v3 != *(void **)(this + 4) )
  {
    **((_DWORD **)v3 + 1) = *(_DWORD *)v3;
    *(_DWORD *)(*(_DWORD *)v3 + 4) = *((_DWORD *)v3 + 1);
    operator delete(v3);
    --*(_DWORD *)(v4 + 8);
  }
  result = a2;
  *(_DWORD *)a2 = lpMema;
  return result;
}

//----- (6E682C8D) --------------------------------------------------------
int __stdcall DeleteColString(int a1)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // esi@1
  void *v4; // ecx@2

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 != v2 )
  {
    do
    {
      v4 = *(void **)(v3 + 8);
      if ( v4 )
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::`scalar deleting destructor'(
          v4,
          1);
      v3 = *(_DWORD *)v3;
    }
    while ( v3 != *(_DWORD *)(v1 + 4) );
  }
  return std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(
           v1,
           (int)&a1,
           **(void ***)(v1 + 4),
           *(_DWORD *)(v1 + 4));
}

//----- (6E682CD2) --------------------------------------------------------
__int32 __stdcall HrSetupCommitFileQueue(HWND Owner, HSPFILEQ QueueHandle, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context)
{
  __int32 v4; // esi@1

  v4 = 0;
  if ( !SetupCommitFileQueueW(Owner, QueueHandle, MsgHandler, Context) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E682D03) --------------------------------------------------------
__int32 __stdcall HrSetupInitDefaultQueueCallbackEx(HWND OwnerWindow, HWND AlternateProgressWindow, UINT ProgressMessage, DWORD Reserved1, PVOID Reserved2, void **a6)
{
  PVOID v6; // ecx@1
  __int32 result; // eax@2

  v6 = SetupInitDefaultQueueCallbackEx(OwnerWindow, AlternateProgressWindow, ProgressMessage, Reserved1, Reserved2);
  if ( v6 )
  {
    result = 0;
    *a6 = v6;
  }
  else
  {
    result = HrFromLastWin32Error();
    *a6 = 0;
  }
  return result;
}

//----- (6E682D40) --------------------------------------------------------
__int32 __stdcall HrSetupOpenFileQueue(void **a1)
{
  HSPFILEQ v1; // ecx@1
  __int32 result; // eax@2

  v1 = SetupOpenFileQueue();
  if ( v1 == (HSPFILEQ)-1 )
  {
    result = HrFromLastWin32Error();
    *a1 = 0;
  }
  else
  {
    result = 0;
    *a1 = v1;
  }
  return result;
}

//----- (6E682D6F) --------------------------------------------------------
__int32 __stdcall HrSetupOpenInfFile(PCWSTR FileName, PCWSTR InfClass, DWORD InfStyle, PUINT ErrorLine, void **a5)
{
  HINF v5; // ecx@1
  __int32 result; // eax@2

  v5 = SetupOpenInfFileW(FileName, InfClass, InfStyle, ErrorLine);
  if ( v5 == (HINF)-1 )
  {
    result = HrFromLastWin32Error();
    *a5 = 0;
    if ( ErrorLine )
      *ErrorLine = 0;
  }
  else
  {
    result = 0;
    *a5 = v5;
  }
  return result;
}

//----- (6E682DB4) --------------------------------------------------------
__int32 __stdcall HrSetupFindFirstLine(HINF InfHandle, PCWSTR Section, PCWSTR Key, PINFCONTEXT Context)
{
  __int32 result; // eax@2

  if ( SetupFindFirstLineW(InfHandle, Section, Key, Context) )
    result = 0;
  else
    result = HrFromLastWin32Error();
  return result;
}

//----- (6E682DE1) --------------------------------------------------------
__int32 __stdcall HrSetupFindNextLine(PINFCONTEXT ContextIn, PINFCONTEXT ContextOut)
{
  __int32 result; // eax@2

  if ( SetupFindNextLine(ContextIn, ContextOut) )
  {
    result = 0;
  }
  else
  {
    result = HrFromLastWin32Error();
    if ( result == -2146500350 )
      result = 1;
  }
  return result;
}

//----- (6E682E12) --------------------------------------------------------
__int32 __stdcall HrSetupGetIntField(PINFCONTEXT Context, DWORD FieldIndex, PINT IntegerValue)
{
  __int32 result; // eax@2

  if ( SetupGetIntField(Context, FieldIndex, IntegerValue) )
  {
    result = 0;
  }
  else
  {
    result = HrFromLastWin32Error();
    *IntegerValue = 0;
  }
  return result;
}

//----- (6E682E42) --------------------------------------------------------
__int32 __stdcall HrSetupGetMultiSzField(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, LPDWORD RequiredSize)
{
  __int32 result; // eax@2

  if ( SetupGetMultiSzFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) )
  {
    result = 0;
  }
  else
  {
    result = HrFromLastWin32Error();
    if ( ReturnBuffer )
      *ReturnBuffer = 0;
    if ( RequiredSize )
      *RequiredSize = 0;
  }
  return result;
}

//----- (6E682E88) --------------------------------------------------------
__int32 __stdcall HrSetupGetStringField(PINFCONTEXT Context, DWORD FieldIndex, PWSTR ReturnBuffer, DWORD ReturnBufferSize, PDWORD RequiredSize)
{
  __int32 result; // eax@2

  if ( SetupGetStringFieldW(Context, FieldIndex, ReturnBuffer, ReturnBufferSize, RequiredSize) )
  {
    result = 0;
  }
  else
  {
    result = HrFromLastWin32Error();
    if ( ReturnBuffer )
      *ReturnBuffer = 0;
    if ( RequiredSize )
      *RequiredSize = 0;
  }
  return result;
}

//----- (6E682ECE) --------------------------------------------------------
__int32 __stdcall HrSetupScanFileQueueWithNoCallback(HSPFILEQ FileQueue, DWORD Flags, HWND Window, PDWORD Result)
{
  __int32 v4; // esi@1

  v4 = 0;
  if ( !SetupScanFileQueueW(FileQueue, Flags, Window, 0, 0, Result) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E682F01) --------------------------------------------------------
__int32 __stdcall HrSetupGetFirstDword(HINF InfHandle, PCWSTR Section, PCWSTR Key, unsigned __int32 *IntegerValue)
{
  unsigned __int32 *v4; // esi@1
  __int32 result; // eax@1
  struct _INFCONTEXT Context; // [sp+4h] [bp-10h]@1

  v4 = IntegerValue;
  *IntegerValue = 0;
  result = HrSetupFindFirstLine(InfHandle, Section, Key, &Context);
  if ( !result )
  {
    result = HrSetupGetIntField(&Context, 1u, (PINT)&IntegerValue);
    if ( !result )
      *v4 = (unsigned __int32)IntegerValue;
  }
  return result;
}

//----- (6E682F5A) --------------------------------------------------------
void __thiscall CSetupInfFile::EnsureClosed(CSetupInfFile *this)
{
  JUMPOUT(*(_DWORD *)this, 0, CSetupInfFile::Close);
}

//----- (6E682F65) --------------------------------------------------------
__int32 __stdcall HrSetupDiCallClassInstaller(DI_FUNCTION InstallFunction, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( !SetupDiCallClassInstaller(InstallFunction, DeviceInfoSet, DeviceInfoData) )
  {
    v3 = HrFromLastWin32Error();
    if ( v3 == -2146500082 )
      v3 = 0;
  }
  return v3;
}

//----- (6E682F9D) --------------------------------------------------------
__int32 __stdcall HrSetupCopyOemInfBuffer(PCWSTR SourceInfFileName, PCWSTR OEMSourceMediaLocation, DWORD OEMSourceMediaType, DWORD CopyStyle, PWSTR DestinationInfFileName, DWORD DestinationInfFileNameSize, PWSTR *DestinationInfFileNameComponent)
{
  BOOL v7; // ecx@2
  __int32 result; // eax@5

  if ( DestinationInfFileNameComponent )
  {
    *DestinationInfFileNameComponent = 0;
    v7 = SetupCopyOEMInfW(
           SourceInfFileName,
           OEMSourceMediaLocation,
           OEMSourceMediaType,
           CopyStyle,
           DestinationInfFileName,
           DestinationInfFileNameSize,
           0,
           DestinationInfFileNameComponent);
    if ( !v7 )
    {
      *DestinationInfFileName = 0;
      if ( *DestinationInfFileNameComponent )
        *DestinationInfFileNameComponent = 0;
    }
    result = 0;
    if ( !v7 )
      result = HrFromLastWin32Error();
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E682FF6) --------------------------------------------------------
__int32 __stdcall HrSetupDiBuildDriverInfoList(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( !SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType) )
    v3 = HrFromLastWin32Error();
  return v3;
}

//----- (6E683024) --------------------------------------------------------
__int32 __stdcall HrSetupDiCreateDeviceInfo(HDEVINFO DeviceInfoSet, PCWSTR DeviceName, GUID *ClassGuid, PCWSTR DeviceDescription, HWND hwndParent, DWORD CreationFlags, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v7; // esi@3

  if ( DeviceInfoData )
  {
    memset(DeviceInfoData, 0, 0x1Cu);
    DeviceInfoData->cbSize = 28;
  }
  v7 = 0;
  if ( !SetupDiCreateDeviceInfoW(
          DeviceInfoSet,
          DeviceName,
          ClassGuid,
          DeviceDescription,
          hwndParent,
          CreationFlags,
          DeviceInfoData) )
    v7 = HrFromLastWin32Error();
  return v7;
}

//----- (6E683074) --------------------------------------------------------
__int32 __stdcall HrSetupDiEnumDriverInfo(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD DriverType, DWORD MemberIndex, struct _SP_DRVINFO_DATA_V2_W *Dst)
{
  __int32 v5; // ebx@1

  v5 = 0;
  memset(Dst, 0, 0x61Cu);
  Dst->cbSize = 1564;
  if ( !SetupDiEnumDriverInfoW(DeviceInfoSet, DeviceInfoData, DriverType, MemberIndex, Dst) )
    v5 = HrFromLastWin32Error();
  return v5;
}

//----- (6E6830C0) --------------------------------------------------------
__int32 __stdcall HrSetupDiSelectBestCompatDrv(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v2; // esi@1

  v2 = 0;
  if ( !SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData) )
    v2 = HrFromLastWin32Error();
  return v2;
}

//----- (6E6830EB) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDeviceInfoListClass(HDEVINFO DeviceInfoSet, LPGUID ClassGuid)
{
  __int32 v2; // esi@1

  v2 = 0;
  if ( !SetupDiGetDeviceInfoListClass(DeviceInfoSet, ClassGuid) )
    v2 = HrFromLastWin32Error();
  return v2;
}

//----- (6E683116) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDeviceInstanceId(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PWSTR DeviceInstanceId, DWORD DeviceInstanceIdSize, unsigned __int32 *a5)
{
  __int32 v5; // edi@1
  DWORD v6; // ecx@3
  DWORD RequiredSize; // [sp+8h] [bp-4h]@1

  v5 = 0;
  if ( !SetupDiGetDeviceInstanceIdW(DeviceInfoSet, DeviceInfoData, 0, 0, &RequiredSize) )
  {
    if ( GetLastError() != 122 )
      goto LABEL_11;
    v6 = RequiredSize;
    if ( a5 )
      *a5 = RequiredSize;
    if ( DeviceInstanceIdSize >= v6
      && !SetupDiGetDeviceInstanceIdW(DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, 0) )
LABEL_11:
      v5 = HrFromLastWin32Error();
  }
  return v5;
}

//----- (6E68317B) --------------------------------------------------------
__int32 __stdcall HrSetupDiInstallDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v2; // esi@1

  v2 = 0;
  if ( !SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData) )
    v2 = HrFromLastWin32Error();
  return v2;
}

//----- (6E6831A6) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetClassInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_CLASSINSTALL_HEADER ClassInstallParams, DWORD ClassInstallParamsSize)
{
  __int32 v4; // esi@1

  v4 = 0;
  if ( !SetupDiSetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, ClassInstallParams, ClassInstallParamsSize) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E6831D7) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetFixedSizeClassInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_CLASSINSTALL_HEADER *Dst, size_t Size)
{
  __int32 v4; // edi@1

  v4 = 0;
  memset(Dst, 0, Size);
  Dst->cbSize = 8;
  if ( !SetupDiGetClassInstallParamsW(DeviceInfoSet, DeviceInfoData, Dst, Size, 0) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E68321F) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetSelectedDriver(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DRVINFO_DATA_V2_W *Dst)
{
  __int32 v3; // esi@1

  memset(Dst, 0, 0x61Cu);
  Dst->cbSize = 1564;
  v3 = 0;
  if ( !SetupDiGetSelectedDriverW(DeviceInfoSet, DeviceInfoData, Dst) )
    v3 = HrFromLastWin32Error();
  return v3;
}

//----- (6E683263) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDriverInfoDetail(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, struct _SP_DRVINFO_DETAIL_DATA_W **a4)
{
  struct _SP_DRVINFO_DETAIL_DATA_W **v4; // esi@1
  void *v5; // eax@3
  __int32 v7; // [sp+Ch] [bp-8h]@1
  DWORD RequiredSize; // [sp+10h] [bp-4h]@1
  BOOL v9; // [sp+28h] [bp+14h]@3

  v4 = a4;
  v7 = 0;
  RequiredSize = 0;
  *a4 = 0;
  if ( !SetupDiGetDriverInfoDetailW(DeviceInfoSet, DeviceInfoData, DriverInfoData, 0, 0, &RequiredSize) )
  {
    if ( GetLastError() != 122
      || ((v9 = 1, v5 = MemAlloc(RequiredSize), (*v4 = (struct _SP_DRVINFO_DETAIL_DATA_W *)v5) == 0) ? (v7 = -2147024882) : (memset(v5, 0, RequiredSize), (*v4)->cbSize = 1570, v9 = SetupDiGetDriverInfoDetailW(DeviceInfoSet, DeviceInfoData, DriverInfoData, *v4, RequiredSize, 0)),
          !v9) )
      v7 = HrFromLastWin32Error();
    if ( v7 < 0 )
    {
      MemFree(*v4);
      *v4 = 0;
    }
  }
  return v7;
}

//----- (6E683311) --------------------------------------------------------
__int32 __stdcall HrSetupDiCreateDevRegKey(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Scope, DWORD HwProfile, DWORD KeyType, HINF InfHandle, PCWSTR InfSectionName, HKEY *a8)
{
  HKEY v8; // ecx@1
  __int32 result; // eax@2

  v8 = SetupDiCreateDevRegKeyW(DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, InfHandle, InfSectionName);
  if ( v8 == (HKEY)-1 )
  {
    result = HrFromLastWin32Error();
    *a8 = 0;
  }
  else
  {
    result = 0;
    *a8 = v8;
  }
  return result;
}

//----- (6E683355) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetActualSectionToInstallWithBuffer(HINF InfHandle, PCWSTR InfSectionName, DWORD RequiredSize, DWORD InfSectionWithExtSize, unsigned __int32 *a5, PWSTR *Extension)
{
  DWORD v6; // ebx@1
  BOOL v7; // eax@3
  DWORD v8; // edx@4
  __int32 v9; // ecx@9

  v6 = RequiredSize;
  *(_WORD *)RequiredSize = 0;
  if ( Extension )
    *Extension = 0;
  v7 = SetupDiGetActualSectionToInstallW(InfHandle, InfSectionName, 0, 0, &RequiredSize, 0);
  if ( v7 )
  {
    v8 = RequiredSize;
    if ( a5 )
      *a5 = RequiredSize;
    if ( InfSectionWithExtSize >= v8 )
    {
      v7 = SetupDiGetActualSectionToInstallW(InfHandle, InfSectionName, (PWSTR)v6, InfSectionWithExtSize, 0, Extension);
      if ( !v7 )
        *(_WORD *)v6 = 0;
    }
  }
  v9 = 0;
  if ( !v7 )
    v9 = HrFromLastWin32Error();
  return v9;
}

//----- (6E6833CE) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDeviceInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _SP_DEVINSTALL_PARAMS_W *Dst)
{
  __int32 v3; // ebx@1

  v3 = 0;
  memset(Dst, 0, 0x22Cu);
  Dst->cbSize = 556;
  if ( !SetupDiGetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, Dst) )
    v3 = HrFromLastWin32Error();
  return v3;
}

//----- (6E683414) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDriverInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams)
{
  __int32 v4; // esi@1

  DriverInstallParams->cbSize = 0;
  DriverInstallParams->Rank = 0;
  DriverInstallParams->Flags = 0;
  DriverInstallParams->PrivateData = 0;
  DriverInstallParams->Reserved = 0;
  v4 = 0;
  DriverInstallParams->cbSize = 20;
  if ( !SetupDiGetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E683457) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetDeviceInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DEVINSTALL_PARAMS_W DeviceInstallParams)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( !SetupDiSetDeviceInstallParamsW(DeviceInfoSet, DeviceInfoData, DeviceInstallParams) )
    v3 = HrFromLastWin32Error();
  return v3;
}

//----- (6E683485) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetDriverInstallParams(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, PSP_DRVINFO_DATA_W DriverInfoData, PSP_DRVINSTALL_PARAMS DriverInstallParams)
{
  __int32 v4; // esi@1

  v4 = 0;
  if ( !SetupDiSetDriverInstallParamsW(DeviceInfoSet, DeviceInfoData, DriverInfoData, DriverInstallParams) )
    v4 = HrFromLastWin32Error();
  return v4;
}

//----- (6E6834B6) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetDeipFlags(HDEVINFO DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData, int a3, int a4, int a5)
{
  __int32 result; // eax@1
  char *v6; // eax@5
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+8h] [bp-230h]@1

  result = HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
  if ( !result )
  {
    if ( a4 )
    {
      if ( a4 != 1 )
        return -2147024809;
      v6 = (char *)&Dst.FlagsEx;
    }
    else
    {
      v6 = (char *)&Dst.Flags;
    }
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        *(_DWORD *)v6 |= a3;
      }
      else
      {
        if ( a5 != 2 )
          return -2147024809;
        *(_DWORD *)v6 ^= a3;
      }
    }
    else
    {
      *(_DWORD *)v6 &= a3;
    }
    result = HrSetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
  }
  return result;
}

//----- (6E683549) --------------------------------------------------------
__int32 __stdcall HrSetupDiRemoveDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v2; // esi@1

  v2 = 0;
  if ( !SetupDiRemoveDevice(DeviceInfoSet, DeviceInfoData) )
    v2 = HrFromLastWin32Error();
  return v2;
}

//----- (6E683574) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetDeviceRegistryProperty(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, PDWORD PropertyRegDataType, PBYTE PropertyBuffer, DWORD PropertyBufferSize, PDWORD RequiredSize)
{
  __int32 v7; // edi@1

  v7 = 0;
  if ( !SetupDiGetDeviceRegistryPropertyW(
          DeviceInfoSet,
          DeviceInfoData,
          Property,
          PropertyRegDataType,
          PropertyBuffer,
          PropertyBufferSize,
          RequiredSize) )
  {
    if ( PropertyBuffer )
      *PropertyBuffer = 0;
    v7 = HrFromLastWin32Error();
  }
  return v7;
}

//----- (6E6835B7) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetDeviceRegistryProperty(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, DWORD Property, BYTE *PropertyBuffer, DWORD PropertyBufferSize)
{
  __int32 v5; // esi@1

  v5 = 0;
  if ( !SetupDiSetDeviceRegistryPropertyW(DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize) )
    v5 = HrFromLastWin32Error();
  return v5;
}

//----- (6E6835EB) --------------------------------------------------------
__int32 __stdcall HrSetupDiSendPropertyChangeNotification(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, unsigned __int32 a3, unsigned __int32 a4, unsigned __int32 a5)
{
  __int32 v5; // edi@1
  struct _SP_CLASSINSTALL_HEADER ClassInstallParams; // [sp+Ch] [bp-244h]@1
  unsigned __int32 v8; // [sp+14h] [bp-23Ch]@1
  unsigned __int32 v9; // [sp+18h] [bp-238h]@1
  unsigned __int32 v10; // [sp+1Ch] [bp-234h]@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+20h] [bp-230h]@2

  v8 = a3;
  v9 = a4;
  v10 = a5;
  ClassInstallParams.cbSize = 8;
  ClassInstallParams.InstallFunction = 18;
  v5 = HrSetupDiSetClassInstallParams(DeviceInfoSet, DeviceInfoData, &ClassInstallParams, 0x14u);
  if ( v5 >= 0 )
  {
    v5 = HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
    if ( v5 >= 0 )
    {
      Dst.Flags |= 0x100000u;
      v5 = HrSetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
      if ( v5 >= 0 )
      {
        v5 = HrSetupDiCallClassInstaller(0x12u, DeviceInfoSet, DeviceInfoData);
        if ( v5 >= 0 )
        {
          HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
          Dst.Flags |= 0x4000u;
          HrSetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
        }
      }
    }
  }
  return v5;
}

//----- (6E6836DA) --------------------------------------------------------
int __stdcall FSetupDiCheckIfRestartNeeded(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  signed int v2; // esi@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+4h] [bp-230h]@1

  v2 = 0;
  if ( HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst) >= 0
    && (Dst.Flags & 0x80 || Dst.Flags & 0x100) )
    v2 = 1;
  return v2;
}

//----- (6E683738) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData)
{
  __int32 v1; // esi@1

  ClassImageListData->cbSize = 0;
  ClassImageListData->ImageList = 0;
  ClassImageListData->Reserved = 0;
  v1 = 0;
  ClassImageListData->cbSize = 12;
  if ( !SetupDiGetClassImageList(ClassImageListData) )
    v1 = HrFromLastWin32Error();
  return v1;
}

//----- (6E683770) --------------------------------------------------------
__int32 __stdcall HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA ClassImageListData)
{
  __int32 v1; // esi@1

  v1 = 0;
  if ( !SetupDiDestroyClassImageList(ClassImageListData) )
    v1 = HrFromLastWin32Error();
  return v1;
}

//----- (6E683798) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA ClassImageListData, GUID *ClassGuid, PINT ImageIndex)
{
  __int32 v3; // esi@1

  v3 = 0;
  if ( !SetupDiGetClassImageIndex(ClassImageListData, ClassGuid, ImageIndex) )
    v3 = HrFromLastWin32Error();
  return v3;
}

//----- (6E6837C6) --------------------------------------------------------
__int32 __stdcall HrSetupDiGetParentWindow(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, HWND *a3)
{
  __int32 v3; // edi@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+8h] [bp-230h]@1

  *a3 = 0;
  v3 = HrSetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &Dst);
  if ( v3 >= 0 && IsWindow(Dst.hwndParent) )
    *a3 = Dst.hwndParent;
  return v3;
}

//----- (6E68382C) --------------------------------------------------------
__int32 __stdcall HrSetupInstallFilesFromInfSection(HINF InfHandle, HINF LayoutInfHandle, HSPFILEQ FileQueue, PCWSTR SectionName, PCWSTR SourceRootPath, UINT CopyFlags)
{
  __int32 v6; // esi@1

  v6 = 0;
  if ( !SetupInstallFilesFromInfSectionW(InfHandle, LayoutInfHandle, FileQueue, SectionName, SourceRootPath, CopyFlags) )
    v6 = HrFromLastWin32Error();
  return v6;
}

//----- (6E683863) --------------------------------------------------------
__int32 __stdcall HrSetupInstallFromInfSection(HWND Owner, HINF InfHandle, PCWSTR SectionName, UINT Flags, HKEY RelativeKeyRoot, PCWSTR SourceRootPath, UINT CopyFlags, PSP_FILE_CALLBACK_W MsgHandler, PVOID Context, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  __int32 v11; // esi@1

  v11 = 0;
  if ( !SetupInstallFromInfSectionW(
          Owner,
          InfHandle,
          SectionName,
          Flags,
          RelativeKeyRoot,
          SourceRootPath,
          CopyFlags,
          MsgHandler,
          Context,
          DeviceInfoSet,
          DeviceInfoData) )
    v11 = HrFromLastWin32Error();
  return v11;
}

//----- (6E6838A9) --------------------------------------------------------
void __stdcall SetupCloseInfFileSafe(void *InfHandle)
{
  if ( IsValidHandle(InfHandle) )
    SetupCloseInfFile(InfHandle);
}

//----- (6E6838CA) --------------------------------------------------------
signed int __stdcall ULongLongToULong(unsigned __int64 a1, unsigned __int32 *a2)
{
  signed int result; // eax@2

  if ( a1 > 0xFFFFFFFF )
  {
    *a2 = -1;
    result = -2147024362;
  }
  else
  {
    *a2 = a1;
    result = 0;
  }
  return result;
}

//----- (6E6838FC) --------------------------------------------------------
signed int __stdcall HrSetupGetMultiSzFieldWithAlloc(PINFCONTEXT Context, DWORD FieldIndex, unsigned __int16 **a3)
{
  signed int v3; // esi@1
  WCHAR *v4; // eax@3
  void *v5; // ebx@3
  SIZE_T dwBytes; // [sp+4h] [bp-8h]@2
  DWORD RequiredSize; // [sp+8h] [bp-4h]@1

  *a3 = 0;
  v3 = HrSetupGetMultiSzField(Context, FieldIndex, 0, 0, &RequiredSize);
  if ( !v3 )
  {
    v3 = ULongLongToULong(2i64 * RequiredSize, &dwBytes);
    if ( v3 >= 0 )
    {
      v4 = (WCHAR *)MemAlloc(dwBytes);
      v5 = v4;
      if ( v4 )
      {
        v3 = HrSetupGetMultiSzField(Context, FieldIndex, v4, RequiredSize, 0);
        if ( v3 )
          MemFree(v5);
        else
          *a3 = (unsigned __int16 *)v5;
      }
      else
      {
        v3 = -2147024882;
      }
    }
  }
  return v3;
}

//----- (6E683983) --------------------------------------------------------
signed int __stdcall HrSetupGetFirstMultiSzFieldWithAlloc(HINF InfHandle, PCWSTR Section, PCWSTR Key, unsigned __int16 **a4)
{
  signed int result; // eax@1
  struct _INFCONTEXT Context; // [sp+4h] [bp-10h]@1

  *a4 = 0;
  result = HrSetupFindFirstLine(InfHandle, Section, Key, &Context);
  if ( !result )
    result = HrSetupGetMultiSzFieldWithAlloc(&Context, 1u, a4);
  return result;
}

//----- (6E6839BE) --------------------------------------------------------
__int32 __stdcall HrSetupDiSetDeviceName(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, BYTE *PropertyBuffer)
{
  return HrSetupDiSetDeviceRegistryProperty(
           DeviceInfoSet,
           DeviceInfoData,
           0xCu,
           PropertyBuffer,
           2 * wcslen((const unsigned __int16 *)PropertyBuffer) + 2);
}

//----- (6E6839F5) --------------------------------------------------------
__int32 __stdcall HrSetupGetStringField(PINFCONTEXT Context, DWORD FieldIndex, int a3)
{
  __int32 v3; // esi@1
  bool v4; // sf@1
  void *v5; // esp@4
  int v7; // [sp+0h] [bp-14h]@4
  DWORD RequiredSize; // [sp+Ch] [bp-8h]@1

  RequiredSize = 0;
  v3 = HrSetupGetStringField(Context, FieldIndex, 0, 0, &RequiredSize);
  v4 = v3 < 0;
  if ( !v3 )
  {
    if ( !RequiredSize )
    {
      v3 = -2147024809;
LABEL_7:
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
        0,
        -1);
      return v3;
    }
    v5 = alloca(2 * RequiredSize);
    v3 = HrSetupGetStringField(Context, FieldIndex, (PWSTR)&v7, RequiredSize, 0);
    v4 = v3 < 0;
    if ( !v3 )
    {
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
        a3,
        &v7);
      v4 = 0;
    }
  }
  if ( v4 )
    goto LABEL_7;
  return v3;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E683A84) --------------------------------------------------------
__int32 __stdcall HrSetupGetStringFieldMapToDword(PINFCONTEXT Context, DWORD FieldIndex, const struct MAP_SZ_DWORD *a3, unsigned int a4, unsigned __int32 *a5)
{
  const struct MAP_SZ_DWORD *v5; // esi@1
  __int32 v6; // ebx@1
  void *v7; // eax@3
  int v9; // [sp+Ch] [bp-2Ch]@1
  LPCWSTR lpString2; // [sp+10h] [bp-28h]@3
  unsigned int v11; // [sp+24h] [bp-14h]@3
  int v12; // [sp+34h] [bp-4h]@1

  v5 = a3;
  *a5 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v9);
  v12 = 0;
  v6 = HrSetupGetStringField(Context, FieldIndex, (int)&v9);
  if ( v6 >= 0 )
  {
    v6 = -2147024883;
    while ( a4 )
    {
      --a4;
      v7 = (void *)lpString2;
      if ( v11 < 8 )
        v7 = &lpString2;
      if ( !lstrcmpiW(*(LPCWSTR *)v5, (LPCWSTR)v7) )
      {
        *a5 = *((_DWORD *)v5 + 1);
        v6 = 0;
        break;
      }
      v5 = (const struct MAP_SZ_DWORD *)((char *)v5 + 8);
    }
  }
  v12 = -1;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v9,
    1,
    0);
  return v6;
}

//----- (6E683B0F) --------------------------------------------------------
__int32 __stdcall HrSetupGetStringFieldAsBool(PINFCONTEXT Context, DWORD FieldIndex, int *a3)
{
  int *v3; // esi@1
  __int32 result; // eax@1

  v3 = a3;
  *a3 = 0;
  result = HrSetupGetStringFieldMapToDword(
             Context,
             FieldIndex,
             (const struct MAP_SZ_DWORD *)&off_6E683B44,
             2u,
             (unsigned __int32 *)&a3);
  if ( result >= 0 )
    *v3 = a3 != 0;
  return result;
}
// 6E683B44: using guessed type const unsigned __int16 *const off_6E683B44;

//----- (6E683B59) --------------------------------------------------------
__int32 __stdcall HrSetupGetFirstString(HINF InfHandle, PCWSTR Section, PCWSTR Key, int a4)
{
  __int32 v4; // esi@1
  bool v5; // sf@1
  struct _INFCONTEXT Context; // [sp+4h] [bp-10h]@1

  v4 = HrSetupFindFirstLine(InfHandle, Section, Key, &Context);
  v5 = v4 < 0;
  if ( !v4 )
  {
    v4 = HrSetupGetStringField(&Context, 1u, a4);
    v5 = v4 < 0;
  }
  if ( v5 )
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
      0,
      -1);
  return v4;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E683BA6) --------------------------------------------------------
__int32 __stdcall HrSetupGetFirstStringAsBool(HINF InfHandle, PCWSTR Section, PCWSTR Key, int *a4)
{
  __int32 result; // eax@1
  struct _INFCONTEXT Context; // [sp+4h] [bp-10h]@1

  *a4 = 0;
  result = HrSetupFindFirstLine(InfHandle, Section, Key, &Context);
  if ( !result )
    result = HrSetupGetStringFieldAsBool(&Context, 1u, a4);
  return result;
}

//----- (6E683BE1) --------------------------------------------------------
__int32 __stdcall HrRegQueryValueWithAlloc(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpType, unsigned __int8 **a4, unsigned __int32 *a5)
{
  BYTE *v5; // ebx@6
  signed int v7; // [sp+18h] [bp-110h]@1
  size_t Size; // [sp+1Ch] [bp-10Ch]@3
  __int32 v9; // [sp+20h] [bp-108h]@3
  char Src; // [sp+24h] [bp-104h]@3

  v7 = 0;
  *a4 = 0;
  if ( a5 )
    *a5 = 0;
  Size = 256;
  v9 = HrRegQueryValueEx(hKey, lpValueName, lpType, (LPBYTE)&Src, (LPDWORD)&Size);
  if ( v9 == -2147024662 )
  {
    v9 = 0;
    v7 = 1;
  }
  if ( !v9 )
  {
    v5 = (BYTE *)MemAlloc(Size);
    if ( v5 )
    {
      if ( v7 )
        v9 = HrRegQueryValueEx(hKey, lpValueName, lpType, v5, (LPDWORD)&Size);
      else
        memcpy(v5, &Src, Size);
      if ( v9 )
      {
        MemFree(v5);
      }
      else
      {
        *a4 = v5;
        if ( a5 )
          *a5 = Size;
      }
    }
    else
    {
      v9 = -2147024882;
    }
  }
  return v9;
}

//----- (6E683D13) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(int this, int a2, int a3)
{
  int v3; // esi@1

  v3 = this;
  if ( a2 == -1 )
    std::_String_base::_Xlen();
  if ( (unsigned __int8)std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Grow(
                          this,
                          a2,
                          0) )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Chassign(
      0,
      a2,
      a3);
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Eos(
      v3,
      a2);
  }
  return v3;
}
// 6E6722AD: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Chassign(_DWORD, _DWORD, _DWORD);

//----- (6E683D59) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::resize(int this, unsigned int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@2

  v3 = *(_DWORD *)(this + 20);
  if ( a2 > v3 )
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
               this,
               a2 - v3,
               a3);
  else
    result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(
               a2,
               -1);
  return result;
}
// 6E654A56: using guessed type _DWORD __stdcall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::erase(_DWORD, _DWORD);

//----- (6E683D86) --------------------------------------------------------
int __thiscall std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::resize(int this, unsigned int a2)
{
  return std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::resize(
           this,
           a2,
           0);
}

//----- (6E683E7C) --------------------------------------------------------
void __usercall sub_6E683E7C(int a1@<ebp>)
{
  *(_DWORD *)(a1 - 20) = -2147024872;
  *(_DWORD *)(a1 - 4) = -1;
  JUMPOUT(&loc_6E683E5A);
}

//----- (6E683EA0) --------------------------------------------------------
void __userpurge sub_6E683EA0(int a1@<ebp>, int a2, int a3, int a4, int a5)
{
  if ( *(_DWORD *)(a1 - 20) >= 0 )
    *(_DWORD *)(a1 - 20) = -2147024882;
  *(_DWORD *)(a1 - 4) = -1;
  JUMPOUT(&loc_6E683E71);
}

//----- (6E683EB9) --------------------------------------------------------
_UNKNOWN *__usercall sub_6E683EB9@<eax>(int a1@<ebp>)
{
  if ( *(_DWORD *)(a1 - 20) >= 0 )
    *(_DWORD *)(a1 - 20) = -2147024872;
  *(_DWORD *)(a1 - 4) = -1;
  return &loc_6E683E71;
}

//----- (6E683ED5) --------------------------------------------------------
__int32 __stdcall HrRegDeleteKey(HKEY hKey, LPCWSTR lpSubKey)
{
  __int32 result; // eax@1

  result = RegDeleteKeyExW(hKey, lpSubKey, 0, 0);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683F01) --------------------------------------------------------
__int32 __stdcall HrRegDeleteValue(HKEY hKey, LPCWSTR lpValueName)
{
  __int32 result; // eax@1

  result = RegDeleteValueW(hKey, lpValueName);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683F29) --------------------------------------------------------
__int32 __stdcall HrRegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
{
  __int32 result; // eax@1

  result = RegEnumKeyExW(hKey, dwIndex, lpName, &cchName, 0, 0, 0, 0);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683F60) --------------------------------------------------------
__int32 __stdcall HrRegEnumKeyEx(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
{
  __int32 result; // eax@1

  result = RegEnumKeyExW(hKey, dwIndex, lpName, lpcchName, 0, lpClass, lpcchClass, lpftLastWriteTime);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683F99) --------------------------------------------------------
__int32 __stdcall HrRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
  __int32 result; // eax@1

  result = RegEnumValueW(hKey, dwIndex, lpValueName, lpcchValueName, 0, lpType, lpData, lpcbData);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683FD2) --------------------------------------------------------
__int32 __stdcall HrRegRestoreKey(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
{
  __int32 result; // eax@1

  result = RegRestoreKeyW(hKey, lpFile, dwFlags);
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (6E683FFD) --------------------------------------------------------
signed int __stdcall HrRegAddStringToMultiSz(wchar_t *Str2, HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, unsigned __int32 a5, unsigned __int32 a6)
{
  HKEY v6; // ebx@2
  signed int v7; // esi@8
  __int32 v8; // eax@10
  DWORD v9; // eax@14
  DWORD Type; // [sp+Ch] [bp-10h]@1
  void *lpMem; // [sp+10h] [bp-Ch]@1
  HKEY phkResult; // [sp+14h] [bp-8h]@1
  BYTE *lpData; // [sp+18h] [bp-4h]@1

  Type = 0;
  phkResult = 0;
  lpMem = 0;
  lpData = 0;
  if ( !Str2 || (v6 = hKey) == 0 || !lpValueName || a5 & 0x60 || a5 & 2 && a5 & 4 )
  {
    v7 = -2147024809;
    goto LABEL_18;
  }
  if ( lpSubKey )
  {
    v7 = HrRegCreateKeyEx(hKey, lpSubKey, 0, 3u, 0, &phkResult, 0);
    if ( v7 < 0 )
      goto LABEL_18;
    v6 = phkResult;
  }
  v8 = HrRegQueryValueWithAlloc(v6, lpValueName, &Type, (unsigned __int8 **)&lpMem, 0);
  v7 = v8;
  if ( v8 >= 0 )
  {
    if ( Type != 7 )
    {
      v7 = -2147023092;
      goto LABEL_18;
    }
  }
  else if ( v8 != -2147024894 )
  {
    goto LABEL_18;
  }
  v7 = HrAddSzToMultiSz(Str2, (wchar_t *)lpMem, a5, a6, (unsigned __int16 **)&lpData, (int *)&lpSubKey);
  if ( !v7 && lpSubKey )
  {
    v9 = CbOfMultiSzAndTermSafe((const unsigned __int16 *)lpData);
    v7 = HrRegSetValueEx(v6, lpValueName, 7u, lpData, v9);
  }
LABEL_18:
  RegSafeCloseKey(phkResult);
  MemFree(lpMem);
  MemFree(lpData);
  return v7;
}

//----- (6E684104) --------------------------------------------------------
signed int __stdcall HrRegAddStringToSz(wchar_t *Str2, HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, wchar_t a5, unsigned __int32 a6, unsigned __int32 a7)
{
  signed int v7; // esi@5
  __int32 v8; // eax@6
  DWORD Type; // [sp+8h] [bp-10h]@1
  BYTE *lpData; // [sp+Ch] [bp-Ch]@1
  void *lpMem; // [sp+10h] [bp-8h]@1
  HKEY phkResult; // [sp+14h] [bp-4h]@1

  Type = 0;
  phkResult = 0;
  lpMem = 0;
  lpData = 0;
  if ( !Str2 || !hKey || !lpValueName || a6 & 0x60 )
  {
    v7 = -2147024809;
    goto LABEL_16;
  }
  v7 = HrRegCreateKeyEx(hKey, lpSubKey, 0, 3u, 0, &phkResult, 0);
  if ( v7 >= 0 )
  {
    v8 = HrRegQueryValueWithAlloc(phkResult, lpValueName, &Type, (unsigned __int8 **)&lpMem, 0);
    v7 = v8;
    if ( v8 >= 0 )
    {
      if ( Type != 1 )
      {
        v7 = -2147023092;
        goto LABEL_16;
      }
      if ( a6 & 0x10 && FSubStringPresent((LPCWSTR)lpMem, Str2, a5) )
      {
        v7 = 0;
        goto LABEL_16;
      }
    }
    else if ( v8 != -2147024894 )
    {
      goto LABEL_16;
    }
    v7 = HrAddStringToDelimitedSz(Str2, (wchar_t *)lpMem, a5, a6, a7, (unsigned __int16 **)&lpData);
    if ( !v7 )
      v7 = HrRegSetSz(phkResult, lpValueName, lpData);
  }
LABEL_16:
  RegSafeCloseKey(phkResult);
  MemFree(lpMem);
  MemFree(lpData);
  return v7;
}

//----- (6E684204) --------------------------------------------------------
__int32 __stdcall HrRegRemoveStringFromMultiSz(wchar_t *Str2, HKEY lpMem, LPCWSTR lpSubKey, LPCWSTR lpValueName, char a5)
{
  HKEY v5; // ebx@1
  __int32 result; // eax@7
  __int32 v7; // eax@9
  __int32 v8; // esi@9
  unsigned __int32 v9; // [sp+8h] [bp-Ch]@9
  int v10; // [sp+Ch] [bp-8h]@14
  HKEY phkResult; // [sp+10h] [bp-4h]@1

  v5 = lpMem;
  phkResult = 0;
  lpMem = 0;
  if ( Str2 && lpValueName && v5 && (!(a5 & 0x20) || !(a5 & 0x40)) )
  {
    if ( lpSubKey )
    {
      result = HrRegOpenKeyEx(v5, lpSubKey, 0x2001Fu, &phkResult);
      if ( result )
        return result;
      v5 = phkResult;
    }
    v7 = HrRegQueryValueWithAlloc(v5, lpValueName, (LPDWORD)&lpSubKey, (unsigned __int8 **)&lpMem, &v9);
    v8 = v7;
    if ( v7 >= 0 )
    {
      if ( lpSubKey == (LPCWSTR)7 )
      {
        RemoveSzFromMultiSz(Str2, (wchar_t *)lpMem, a5, &v10);
        if ( v10 )
        {
          v9 = CbOfMultiSzAndTermSafe((const unsigned __int16 *)lpMem);
          v8 = HrRegSetValueEx(v5, lpValueName, 7u, (BYTE *)lpMem, v9);
        }
      }
      else
      {
        v8 = -2147023092;
      }
    }
    else if ( v7 == -2147024894 )
    {
      v8 = 0;
    }
    RegSafeCloseKey(phkResult);
    MemFree(lpMem);
    result = v8;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6E6842F2) --------------------------------------------------------
__int32 __stdcall HrRegDeleteKeyTree(HKEY a1, LPCWSTR a2)
{
  __int32 result; // eax@1
  __int32 v3; // esi@4
  struct _FILETIME ftLastWriteTime; // [sp+4h] [bp-224h]@4
  HKEY v5; // [sp+Ch] [bp-21Ch]@1
  LPCWSTR lpSubKey; // [sp+10h] [bp-218h]@1
  DWORD cchName; // [sp+14h] [bp-214h]@4
  HKEY hKey; // [sp+18h] [bp-210h]@1
  WCHAR Name; // [sp+1Ch] [bp-20Ch]@3

  v5 = a1;
  lpSubKey = a2;
  result = HrRegOpenKeyEx(a1, a2, 0x3001Fu, &hKey);
  if ( !result )
  {
    while ( 1 )
    {
      cchName = 260;
      v3 = RegEnumKeyExW(hKey, 0, &Name, &cchName, 0, 0, 0, &ftLastWriteTime);
      if ( v3 )
        break;
      HrRegDeleteKeyTree(hKey, &Name);
    }
    RegCloseKey(hKey);
    if ( !v3 || v3 == 259 )
      v3 = RegDeleteKeyExW(v5, lpSubKey, 0, 0);
    if ( v3 > 0 )
      v3 = (unsigned __int16)v3 | 0x80070000;
    result = v3;
  }
  return result;
}

//----- (6E6843DA) --------------------------------------------------------
__int32 __stdcall HrRegSetBool(HKEY hKey, LPCWSTR lpValueName, BYTE Data)
{
  *(_DWORD *)&Data = Data != 0;
  return HrRegSetValueEx(hKey, lpValueName, 4u, &Data, 4u);
}

//----- (6E684406) --------------------------------------------------------
__int32 __stdcall HrRegSetDword(HKEY hKey, LPCWSTR lpValueName, BYTE Data)
{
  return HrRegSetValueEx(hKey, lpValueName, 4u, &Data, 4u);
}

//----- (6E684427) --------------------------------------------------------
__int32 __thiscall CService::HrSetStartType(CService *this, unsigned __int32 dwStartType)
{
  __int32 result; // eax@2

  if ( ChangeServiceConfigW(*(SC_HANDLE *)this, 0xFFFFFFFF, dwStartType, 0xFFFFFFFF, 0, 0, 0, 0, 0, 0, 0) )
    result = 0;
  else
    result = HrFromLastWin32Error();
  return result;
}

//----- (6E68445A) --------------------------------------------------------
NTSTATUS __stdcall ScStopNetbios()
{
  NTSTATUS v0; // edi@1
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+8h] [bp-34h]@1
  struct _IO_STATUS_BLOCK v3; // [sp+20h] [bp-1Ch]@2
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+28h] [bp-14h]@1
  LSA_UNICODE_STRING DestinationString; // [sp+30h] [bp-Ch]@1
  HANDLE FileHandle; // [sp+38h] [bp-4h]@1

  FileHandle = 0;
  RtlInitUnicodeString(&DestinationString, L"\\Device\\Netbios");
  ObjectAttributes.ObjectName = &DestinationString;
  ObjectAttributes.Length = 24;
  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.Attributes = 64;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  v0 = NtCreateFile(&FileHandle, 0xC0000000, &ObjectAttributes, &IoStatusBlock, 0, 0x80u, 7u, 3u, 0, 0, 0);
  if ( v0 >= 0 )
    v0 = NtDeviceIoControlFile(FileHandle, 0, 0, 0, &v3, 0x21005Bu, 0, 0, 0, 0);
  if ( FileHandle )
    NtClose(FileHandle);
  return v0;
}

//----- (6E684515) --------------------------------------------------------
HRESULT __stdcall HrRegisterOrUnregisterComObject(const WCHAR *a1, int a2)
{
  HRESULT v2; // esi@1
  char *v3; // eax@4
  HMODULE hLibModule; // [sp+8h] [bp-3Ch]@6
  char *v6; // [sp+Ch] [bp-38h]@6
  int v7; // [sp+10h] [bp-34h]@1
  LPCWSTR lpLibFileName; // [sp+14h] [bp-30h]@1
  char v9; // [sp+18h] [bp-2Ch]@4
  int v10; // [sp+2Ch] [bp-18h]@4
  int v11; // [sp+30h] [bp-14h]@4
  int v12; // [sp+34h] [bp-10h]@4
  int v13; // [sp+38h] [bp-Ch]@4
  __int16 v14; // [sp+3Ch] [bp-8h]@4

  lpLibFileName = a1;
  v7 = 1;
  v2 = CoInitializeEx(0, 4u);
  if ( v2 == -2147417850 )
  {
    v2 = 0;
    v7 = 0;
  }
  if ( v2 >= 0 )
  {
    v10 = *(_DWORD *)"DllRegisterServer";
    v11 = *(_DWORD *)"egisterServer";
    v12 = *(_DWORD *)"terServer";
    v13 = *(_DWORD *)"erver";
    v14 = *(_WORD *)"r";
    qmemcpy(&v9, "DllUnregisterServer", 0x14u);
    v3 = (char *)&v10;
    if ( a2 )
      v3 = &v9;
    v6 = v3;
    v2 = HrLoadLibAndGetProcs(
           lpLibFileName,
           1u,
           (const char *const *)&v6,
           &hLibModule,
           (int (__stdcall **)())&lpLibFileName);
    if ( !v2 )
    {
      v2 = ((int (*)(void))lpLibFileName)();
      if ( v2 == -2147417850 )
        v2 = 0;
      FreeLibrary(hLibModule);
    }
    if ( v7 )
      CoUninitialize();
  }
  return v2;
}

//----- (6E6845FB) --------------------------------------------------------
__int32 __stdcall HrEnableAndStartSpooler()
{
  __int32 v0; // edi@1
  int v2; // [sp+Ch] [bp-18h]@1
  int v3; // [sp+10h] [bp-14h]@1
  unsigned __int16 *v4; // [sp+14h] [bp-10h]@2
  int v5; // [sp+20h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v5 = 0;
  v0 = CServiceManager::HrOpen((CServiceManager *)&v2, 0, 0xF003Fu, 0, 0);
  if ( !v0 )
  {
    v4 = L"Spooler";
    v0 = CServiceManager::HrStartServicesAndWait(
           (CServiceManager *)&v2,
           1u,
           (const unsigned __int16 *const *)&v4,
           0xEA60u);
    if ( v0 == -2147023838 )
    {
      v0 = CServiceManager::HrLock();
      if ( !v0 )
      {
        v4 = 0;
        LOBYTE(v5) = 1;
        v0 = CServiceManager::HrOpenService((CServiceManager *)&v2, (CService *)&v4, L"Spooler", 0, 0xF003Fu, 0xF0002u);
        if ( !v0 )
          v0 = CService::HrSetStartType((CService *)&v4, 3u);
        CServiceManager::Unlock((CServiceManager *)&v2);
        LOBYTE(v5) = 0;
        CService::Close((CService *)&v4);
        if ( !v0 )
        {
          v4 = L"Spooler";
          v0 = CServiceManager::HrStartServicesAndWait(
                 (CServiceManager *)&v2,
                 1u,
                 (const unsigned __int16 *const *)&v4,
                 0xEA60u);
        }
      }
    }
  }
  v5 = -1;
  CServiceManager::~CServiceManager((CServiceManager *)&v2);
  return v0;
}
// 6E6846D4: using guessed type wchar_t aSpooler[8];

//----- (6E6846E9) --------------------------------------------------------
__int32 __stdcall HrEnableAllPrivileges(struct _TOKEN_PRIVILEGES **a1)
{
  HANDLE v1; // eax@1
  BOOL v2; // ebx@1
  HANDLE v3; // eax@3
  void *v4; // esi@4
  unsigned int v5; // ecx@7
  int v6; // eax@8
  struct _TOKEN_PRIVILEGES *v7; // eax@10
  DWORD v8; // ST0C_4@10
  __int32 v10; // [sp+4h] [bp-Ch]@4
  HANDLE TokenHandle; // [sp+8h] [bp-8h]@1
  DWORD TokenInformationLength; // [sp+Ch] [bp-4h]@1

  TokenInformationLength = 4096;
  v1 = GetCurrentThread();
  v2 = OpenThreadToken(v1, 0x28u, 1, &TokenHandle);
  if ( !v2 )
  {
    if ( GetLastError() != 1008 )
      goto LABEL_18;
    v3 = GetCurrentProcess();
    v2 = OpenProcessToken(v3, 0x28u, &TokenHandle);
    if ( !v2 )
      goto LABEL_18;
  }
  v10 = -2147024882;
  v4 = MemAlloc(TokenInformationLength);
  if ( v4 )
  {
    v10 = 0;
    v2 = GetTokenInformation(TokenHandle, TokenPrivileges, v4, TokenInformationLength, &TokenInformationLength);
    if ( v2 )
    {
      if ( *(_DWORD *)v4 )
      {
        v5 = 0;
        if ( *(_DWORD *)v4 )
        {
          v6 = (int)((char *)v4 + 12);
          do
          {
            *(_DWORD *)v6 = 2;
            ++v5;
            v6 += 12;
          }
          while ( v5 < *(_DWORD *)v4 );
        }
      }
      v7 = (struct _TOKEN_PRIVILEGES *)operator new(TokenInformationLength);
      v8 = TokenInformationLength;
      *a1 = v7;
      v2 = AdjustTokenPrivileges(TokenHandle, 0, (PTOKEN_PRIVILEGES)v4, v8, v7, &TokenInformationLength);
      if ( !v2 )
      {
        operator delete(*a1);
        *a1 = 0;
      }
    }
    MemFree(v4);
  }
  CloseHandle(TokenHandle);
  if ( !v2 )
LABEL_18:
    v10 = HrFromLastWin32Error();
  return v10;
}

//----- (6E6847EF) --------------------------------------------------------
__int32 __stdcall HrRestorePrivileges(PTOKEN_PRIVILEGES NewState)
{
  __int32 v1; // esi@1
  signed int v2; // edi@1
  HANDLE v3; // eax@1
  HANDLE TokenHandle; // [sp+8h] [bp-4h]@1

  v1 = 0;
  TokenHandle = 0;
  v2 = 0;
  v3 = GetCurrentProcess();
  if ( !OpenProcessToken(v3, 0x28u, &TokenHandle) )
    goto LABEL_9;
  if ( AdjustTokenPrivileges(TokenHandle, 0, NewState, 0, 0, 0) )
    v2 = 1;
  CloseHandle(TokenHandle);
  if ( !v2 )
LABEL_9:
    v1 = HrFromLastWin32Error();
  return v1;
}

//----- (6E68484B) --------------------------------------------------------
void __stdcall NCPERM_SETBIT(unsigned __int32 a1, unsigned __int32 a2)
{
  dword_6E69C098 = (a2 != 0 ? 1 << a1 : 0) | dword_6E69C098 & ~(1 << a1);
}
// 6E69C098: using guessed type int dword_6E69C098;

//----- (6E68487C) --------------------------------------------------------
BOOL __stdcall NCPERM_CHECKBIT(unsigned __int32 a1)
{
  return (dword_6E69C098 & (1 << a1)) != 0;
}
// 6E69C098: using guessed type int dword_6E69C098;

//----- (6E68489E) --------------------------------------------------------
signed int __stdcall IsHomenetModuleOSType(int a1)
{
  signed int result; // eax@1
  const WCHAR *v2; // ecx@4
  DWORD pdwValue; // [sp+0h] [bp-4h]@1

  result = 0;
  pdwValue = 0;
  if ( (unsigned int)(a1 - 1) > 1 )
  {
    result = 0;
  }
  else
  {
    if ( a1 == 1 )
    {
      v2 = L"Microsoft-Windows-InternetConnectionSharingConfig-HomeNetBeacon";
    }
    else
    {
      if ( a1 != 2 )
        return result;
      v2 = L"Microsoft-Windows-InternetConnectionSharingConfig-HomeNetICS";
    }
    if ( v2 )
    {
      if ( SLGetWindowsInformationDWORD(v2, &pdwValue) < 0 )
        result = 1;
      else
        result = pdwValue > 0;
    }
  }
  return result;
}
// 6E6848F0: using guessed type wchar_t aMicrosoftWindo[64];

//----- (6E6849EF) --------------------------------------------------------
int __stdcall IsPermittedOnSku(unsigned __int32 a1)
{
  int result; // eax@3
  DWORDLONG v2; // rax@4
  struct _OSVERSIONINFOEXW VersionInformation; // [sp+0h] [bp-120h]@1

  VersionInformation.dwOSVersionInfoSize = 0;
  memset(&VersionInformation.dwMajorVersion, 0, 0x118u);
  if ( a1 == 51 )
    goto LABEL_9;
  if ( a1 == 50 )
    return IsHomenetModuleOSType(2);
  VersionInformation.dwOSVersionInfoSize = 284;
  VersionInformation.wSuiteMask = 1188;
  v2 = VerSetConditionMask(0i64, 0x40u, 6u);
  if ( VerifyVersionInfoW(&VersionInformation, 0x40u, v2) )
    result = 0;
  else
LABEL_9:
    result = 1;
  return result;
}

//----- (6E684A86) --------------------------------------------------------
int __stdcall FIsUserLuaAdmin()
{
  return FCheckGroupMembership(0x220u, 1);
}

//----- (6E684A98) --------------------------------------------------------
int __stdcall FIsUserService()
{
  return FCheckGroupMembershipInternal(1u, 6u, 0, 0);
}

//----- (6E684AAB) --------------------------------------------------------
int __stdcall FIsUserLocalService()
{
  return FCheckGroupMembershipInternal(1u, 0x13u, 0, 0);
}

//----- (6E684ABE) --------------------------------------------------------
int __stdcall FIsUserLocalSystem()
{
  return FCheckGroupMembershipInternal(1u, 0x12u, 0, 0);
}

//----- (6E684AD1) --------------------------------------------------------
int __stdcall FIsUserNetworkService()
{
  return FCheckGroupMembershipInternal(1u, 0x14u, 0, 0);
}

//----- (6E684AE4) --------------------------------------------------------
int __stdcall FIsUserPowerUser()
{
  return FCheckGroupMembership(0x223u, 0);
}

//----- (6E684AF6) --------------------------------------------------------
int __stdcall FIsUserGuest()
{
  return FCheckGroupMembership(0x222u, 0);
}

//----- (6E684B08) --------------------------------------------------------
signed int __stdcall NCPERM_USER_TYPE()
{
  if ( FIsUserAdmin() )
    return 1;
  if ( FIsUserLuaAdmin() )
    return 32;
  if ( FIsUserNetworkConfigOps() )
    return 2;
  if ( FIsUserPowerUser() )
    return 4;
  return FIsUserGuest() != 0 ? 16 : 8;
}

//----- (6E684B51) --------------------------------------------------------
void __stdcall RefreshAllPermission()
{
  signed int v0; // eax@1
  unsigned int v1; // esi@8
  signed int v2; // [sp+0h] [bp-Ch]@1
  DWORD Type; // [sp+4h] [bp-8h]@3
  HKEY hKey; // [sp+8h] [bp-4h]@2

  v0 = NCPERM_USER_TYPE();
  dword_6E69C098 = -1;
  v2 = v0;
  if ( !(v0 & 0x21) )
  {
    if ( !HrRegOpenKeyEx(
            HKEY_CURRENT_USER,
            L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer",
            0x20019u,
            &hKey) )
    {
      if ( HrRegQueryDword(hKey, L"NoNetworkConnections", (DWORD)&Type) >= 0 && Type )
        dword_6E69C098 &= 0xFFF7FFFF;
      RegCloseKey(hKey);
      hKey = 0;
    }
    if ( !HrRegOpenKeyEx(
            HKEY_CURRENT_USER,
            L"Software\\Policies\\Microsoft\\Windows\\Network Connections",
            0x20019u,
            &hKey) )
    {
      v1 = 0;
      do
      {
        if ( v2 & dword_6E65CFC0[v1 / 4] )
        {
          if ( HrRegQueryDword(hKey, (&off_6E65CFBC)[v1 / 2], (DWORD)&Type) >= 0 )
            NCPERM_SETBIT(*(unsigned __int32 *)((char *)&USER_PERM_MAP + v1), Type);
        }
        v1 += 12;
      }
      while ( v1 < 0xCC );
      RegCloseKey(hKey);
    }
  }
}
// 6E65CFB8: using guessed type const struct PERM_MAP_STRUCT *const USER_PERM_MAP;
// 6E65CFBC: using guessed type wchar_t *off_6E65CFBC;
// 6E65CFC0: using guessed type int dword_6E65CFC0[];
// 6E69C098: using guessed type int dword_6E69C098;

//----- (6E684C24) --------------------------------------------------------
int __stdcall FHasPermission(HKEY hKey)
{
  unsigned __int32 v1; // edi@1
  int result; // eax@1
  signed int v3; // ebx@2
  unsigned int v4; // esi@4
  DWORD Type; // [sp+4h] [bp-8h]@10
  DWORD v6; // [sp+8h] [bp-4h]@6

  v1 = (unsigned __int32)hKey;
  result = IsPermittedOnSku((unsigned __int32)hKey);
  if ( result )
  {
    v3 = NCPERM_USER_TYPE();
    if ( v3 & 0x21 )
      return 1;
    v4 = 0;
    if ( !dword_6E69C09C )
    {
      RefreshAllPermission();
      dword_6E69C09C = 1;
      return NCPERM_CHECKBIT(v1);
    }
    hKey = 0;
    v6 = 0;
    if ( v1 == 19 )
    {
      if ( HrRegOpenKeyEx(
             HKEY_CURRENT_USER,
             L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer",
             0x20019u,
             &hKey) )
        return NCPERM_CHECKBIT(v1);
      if ( HrRegQueryDword(hKey, L"NoNetworkConnections", (DWORD)&v6) >= 0 && v6 )
        dword_6E69C098 &= 0xFFF7FFFF;
    }
    else
    {
      if ( HrRegOpenKeyEx(
             HKEY_CURRENT_USER,
             L"Software\\Policies\\Microsoft\\Windows\\Network Connections",
             0x20019u,
             &hKey) )
        return NCPERM_CHECKBIT(v1);
      do
      {
        if ( (const struct PERM_MAP_STRUCT *const )v1 == *(const struct PERM_MAP_STRUCT *const *)((char *)&USER_PERM_MAP
                                                                                                + v4 * 2)
          && v3 & (unsigned int)(&off_6E65CFBC)[2 * v4 + 2]
          && HrRegQueryDword(hKey, (&off_6E65CFBC)[v4], (DWORD)&Type) >= 0 )
          NCPERM_SETBIT(*(unsigned __int32 *)((char *)&USER_PERM_MAP + v4 * 2), Type);
        v4 += 6;
      }
      while ( v4 < 102 );
    }
    RegCloseKey(hKey);
    return NCPERM_CHECKBIT(v1);
  }
  return result;
}
// 6E65CFB8: using guessed type const struct PERM_MAP_STRUCT *const USER_PERM_MAP;
// 6E65CFBC: using guessed type wchar_t *off_6E65CFBC;
// 6E69C098: using guessed type int dword_6E69C098;
// 6E69C09C: using guessed type int dword_6E69C09C;

//----- (6E684D2E) --------------------------------------------------------
void __stdcall RemoveSzFromMultiSz(wchar_t *Str2, wchar_t *Str1, char a3, int *a4)
{
  wchar_t *v4; // esi@1
  bool v5; // zf@5
  wchar_t *v6; // eax@5
  int v7; // edx@5
  wchar_t v8; // cx@6
  const unsigned __int16 *v9; // edi@7
  unsigned __int32 v10; // eax@7
  wchar_t v11; // cx@9

  *a4 = 0;
  v4 = Str1;
  if ( Str1 && Str2 && *Str2 && *Str1 )
  {
    do
    {
      v5 = _wcsicmp(v4, Str2) == 0;
      v6 = v4;
      v7 = (int)(v4 + 1);
      if ( v5 )
      {
        do
        {
          v8 = *v6;
          ++v6;
        }
        while ( v8 );
        v9 = &v4[((signed int)((char *)v6 - v7) >> 1) + 1];
        v10 = CchOfMultiSzAndTermSafe(v9);
        memmove(v4, v9, 2 * v10);
        *a4 = 1;
        if ( a3 & 0x20 )
          return;
      }
      else
      {
        do
        {
          v11 = *v6;
          ++v6;
        }
        while ( v11 );
        v4 += ((signed int)((char *)v6 - v7) >> 1) + 1;
      }
    }
    while ( *v4 );
  }
}

//----- (6E684DC1) --------------------------------------------------------
signed int __stdcall HrAddSzToMultiSz(wchar_t *Str2, wchar_t *Str1, unsigned __int32 a3, unsigned __int32 a4, unsigned __int16 **a5, int *a6)
{
  signed int result; // eax@6
  int *v7; // esi@10
  unsigned __int32 v8; // ecx@16
  unsigned int v9; // edi@27
  unsigned __int16 *v10; // eax@27
  unsigned __int32 v11; // ebx@27
  unsigned int v12; // esi@27
  int v13; // eax@35
  int v14; // ecx@35
  __int16 v15; // dx@36
  unsigned __int16 *v16; // ebx@40
  unsigned __int16 *v17; // eax@40
  int v18; // ecx@40
  unsigned __int16 v19; // dx@41
  unsigned __int16 *v20; // ebx@48
  unsigned __int16 *v21; // eax@48
  int v22; // ecx@48
  unsigned __int16 v23; // dx@49
  signed int v24; // [sp+Ch] [bp-18h]@1
  unsigned __int32 v25; // [sp+10h] [bp-14h]@11
  unsigned __int32 v26; // [sp+14h] [bp-10h]@11
  unsigned __int16 *v27; // [sp+18h] [bp-Ch]@1
  unsigned __int32 v28; // [sp+1Ch] [bp-8h]@1
  int v29; // [sp+20h] [bp-4h]@32

  v24 = 0;
  v27 = (unsigned __int16 *)(a3 & 2);
  v28 = a3 & 8;
  if ( a3 & 2 && (a3 & 4 || a3 & 8) || a3 & 4 && a3 & 8 || !(a3 & 2) && !(a3 & 4) && !(a3 & 8) )
  {
    result = -2147024809;
  }
  else
  {
    *a5 = 0;
    v7 = a6;
    *a6 = 1;
    if ( *Str2 )
    {
      if ( FGetSzPositionInMultiSzSafe(Str2, Str1, &v25, (int *)&a6, &v26) )
      {
        if ( a3 & 0x10 )
          *v7 = 0;
        if ( !a6 && !(a3 & 1) )
        {
          v8 = v25;
          if ( a3 & 2 && !v25 )
            *v7 = 0;
          if ( a3 & 4 && v8 == v26 - 1 )
            *v7 = 0;
          if ( v28 && v8 == a4 )
            *v7 = 0;
        }
      }
    }
    else
    {
      *v7 = 0;
    }
    if ( *v7 )
    {
      v26 = CchOfMultiSzSafe(Str1);
      v9 = wcslen(Str2) + v26 + 2;
      v10 = (unsigned __int16 *)MemAlloc(2 * v9);
      v11 = (unsigned __int32)v10;
      v12 = 0;
      v25 = (unsigned __int32)v10;
      if ( v10 )
      {
        a6 = 0;
        if ( v27 || v28 && !a4 )
        {
          StringCchCopyW(v10, v9, Str2);
          v12 = wcslen((const unsigned __int16 *)v11) + 1;
          a6 = (int *)1;
        }
        v29 = 0;
        if ( v26 > 1 )
        {
          do
          {
            if ( v28 && a6 == (int *)a4 )
            {
              StringCchCopyW((unsigned __int16 *)(v11 + 2 * v12), v9 - v12, Str2);
              v13 = v11 + 2 * v12;
              v14 = v13 + 2;
              do
              {
                v15 = *(_WORD *)v13;
                v13 += 2;
              }
              while ( v15 );
              a6 = (int *)((char *)a6 + 1);
              v12 += ((v13 - v14) >> 1) + 1;
            }
            else
            {
              v27 = &Str1[v29];
              if ( a3 & 1 || _wcsicmp(&Str1[v29], Str2) )
              {
                v16 = (unsigned __int16 *)(v11 + 2 * v12);
                StringCchCopyW(v16, v9 - v12, v27);
                v17 = v16;
                v18 = (int)(v16 + 1);
                do
                {
                  v19 = *v17;
                  ++v17;
                }
                while ( v19 );
                v11 = v25;
                a6 = (int *)((char *)a6 + 1);
                v12 += ((signed int)((char *)v17 - v18) >> 1) + 1;
              }
              v29 += wcslen(v27) + 1;
            }
          }
          while ( v29 + 1 < v26 );
        }
        if ( a3 & 4 || v28 && (unsigned int)a6 <= a4 )
        {
          v20 = (unsigned __int16 *)(v11 + 2 * v12);
          StringCchCopyW(v20, v9 - v12, Str2);
          v21 = v20;
          v22 = (int)(v20 + 1);
          do
          {
            v23 = *v21;
            ++v21;
          }
          while ( v23 );
          v11 = v25;
          v12 += ((signed int)((char *)v21 - v22) >> 1) + 1;
        }
        *(_WORD *)(v11 + 2 * v12) = 0;
        *a5 = (unsigned __int16 *)v11;
      }
      else
      {
        v24 = -2147024882;
      }
    }
    result = v24;
  }
  return result;
}

//----- (6E685027) --------------------------------------------------------
__int32 __thiscall CService::HrSetDependencies(CService *this, const unsigned __int16 *lpDependencies)
{
  __int32 result; // eax@2

  if ( ChangeServiceConfigW(*(SC_HANDLE *)this, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0, 0, 0, lpDependencies, 0, 0, 0) )
    result = 0;
  else
    result = HrFromLastWin32Error();
  return result;
}

//----- (6E68505B) --------------------------------------------------------
void __stdcall StopDependentServices(SC_HANDLE hService, const unsigned __int16 *a2, struct CSCTX *a3)
{
  void *v3; // ebx@1
  signed int v4; // esi@1
  DWORD v5; // eax@5
  unsigned int v6; // esi@12
  void *v7; // esp@13
  DWORD v8; // eax@13
  void *v9; // ecx@14
  int v10; // [sp+0h] [bp-18h]@15
  DWORD ServicesReturned; // [sp+Ch] [bp-Ch]@1
  DWORD cbBufSize; // [sp+10h] [bp-8h]@1

  v3 = 0;
  cbBufSize = 256;
  ServicesReturned = 0;
  v4 = 0;
  while ( 1 )
  {
    if ( cbBufSize )
    {
      MemFree(v3);
      v3 = MemAlloc(cbBufSize);
      if ( !v3 )
      {
        v5 = 14;
        goto LABEL_7;
      }
    }
    if ( EnumDependentServicesW(hService, 1u, (LPENUM_SERVICE_STATUSW)v3, cbBufSize, &cbBufSize, &ServicesReturned) )
      goto LABEL_12;
    v5 = GetLastError();
    if ( v5 != 234 )
      break;
    ++v4;
    if ( v4 >= 2 )
      goto LABEL_7;
  }
  if ( v5 )
  {
LABEL_7:
    if ( !*((_DWORD *)a3 + 2) )
      *((_DWORD *)a3 + 2) = v5;
    goto LABEL_9;
  }
LABEL_12:
  v6 = ServicesReturned;
  if ( ServicesReturned )
  {
    v7 = alloca(4 * ServicesReturned);
    v8 = 0;
    if ( ServicesReturned > 0 )
    {
      v9 = v3;
      do
      {
        *(&v10 + v8) = *(_DWORD *)v9;
        v6 = ServicesReturned;
        ++v8;
        v9 = (char *)v9 + 36;
      }
      while ( v8 < ServicesReturned );
    }
    SvcControlServicesAndWait(a3, v6, (const unsigned __int16 *const *)&v10, 0i64);
  }
LABEL_9:
  MemFree(v3);
}

//----- (6E685133) --------------------------------------------------------
void __thiscall CService::Close(CService *this)
{
  CService *v1; // esi@1

  v1 = this;
  if ( *(_DWORD *)this )
  {
    CloseServiceHandle(*(SC_HANDLE *)this);
    *(_DWORD *)v1 = 0;
  }
}

//----- (6E685166) --------------------------------------------------------
__int32 __thiscall CServiceManager::HrOpen(CServiceManager *this, int a2, DWORD dwDesiredAccess, const WCHAR *lpMachineName, const WCHAR *lpDatabaseName)
{
  CServiceManager *v5; // esi@1
  __int32 v6; // edi@1
  SC_HANDLE v7; // eax@3

  v5 = this;
  v6 = 0;
  if ( *(_DWORD *)this )
    CServiceManager::Close(this);
  v7 = OpenSCManagerW(lpMachineName, lpDatabaseName, dwDesiredAccess);
  *(_DWORD *)v5 = v7;
  if ( !v7 )
    v6 = HrFromLastWin32Error();
  return v6;
}

//----- (6E6851A3) --------------------------------------------------------
__int32 __thiscall CServiceManager::HrOpenService(CServiceManager *this, CService *a2, const WCHAR *lpServiceName, int a4, DWORD a5, DWORD dwDesiredAccess)
{
  CServiceManager *v6; // esi@1
  SC_HANDLE v7; // eax@5
  __int32 v9; // [sp+8h] [bp-4h]@1

  v6 = this;
  v9 = 0;
  if ( *(_DWORD *)this || (v9 = CServiceManager::HrOpen(this, a4, a5, 0, 0)) == 0 )
  {
    if ( *(_DWORD *)a2 )
      CService::Close(a2);
    v7 = OpenServiceW(*(SC_HANDLE *)v6, lpServiceName, dwDesiredAccess);
    *(_DWORD *)a2 = v7;
    if ( !v7 )
      v9 = HrFromLastWin32Error();
  }
  return v9;
}

//----- (6E685204) --------------------------------------------------------
void __thiscall CServiceManager::Unlock(CServiceManager *this)
{
  *((_DWORD *)this + 1) = 0;
}

//----- (6E68520E) --------------------------------------------------------
DWORD __stdcall HrQueryServiceConfigWithAlloc(SC_HANDLE hService, struct _QUERY_SERVICE_CONFIGW **a2)
{
  void *v2; // edi@1
  signed int v3; // esi@1
  DWORD v4; // eax@4
  DWORD v5; // esi@12
  DWORD cbBufSize; // [sp+8h] [bp-4h]@1

  v2 = 0;
  cbBufSize = dword_6E69BC48;
  v3 = 0;
  while ( 1 )
  {
    MemFree(v2);
    v2 = MemAlloc(cbBufSize);
    if ( !v2 )
    {
      LOWORD(v4) = 14;
LABEL_11:
      v4 = (unsigned __int16)v4 | 0x80070000;
      goto LABEL_12;
    }
    if ( QueryServiceConfigW(hService, (LPQUERY_SERVICE_CONFIGW)v2, cbBufSize, &cbBufSize) )
      break;
    v4 = GetLastError();
    if ( v4 != 122 )
    {
      if ( (signed int)v4 <= 0 )
        goto LABEL_12;
      goto LABEL_11;
    }
    ++v3;
    if ( v3 >= 2 )
      goto LABEL_11;
  }
  v4 = 0;
  if ( cbBufSize > dword_6E69BC48 )
    dword_6E69BC48 = cbBufSize;
LABEL_12:
  v5 = v4;
  if ( v4 )
  {
    MemFree(v2);
    *a2 = 0;
  }
  else
  {
    *a2 = (struct _QUERY_SERVICE_CONFIGW *)v2;
  }
  return v5;
}
// 6E69BC48: using guessed type int dword_6E69BC48;

//----- (6E6852AC) --------------------------------------------------------
void __stdcall SvcControlServicesAndWait(struct CSCTX *a1, unsigned int a2, const unsigned __int16 *const *a3, unsigned __int64 LogToken)
{
  void *v4; // esp@1
  LPCWSTR *v5; // edi@2
  SC_HANDLE v6; // eax@3
  signed int v7; // esi@3
  int v8; // eax@6
  int v9; // ecx@11
  signed int v10; // eax@11
  BOOL v11; // esi@12
  int v12; // ecx@14
  int v13; // ecx@26
  bool v14; // zf@30
  int v15; // ecx@36
  int v16; // ecx@44
  unsigned int v17; // eax@44
  unsigned int v18; // edi@49
  SC_HANDLE v19; // esi@50
  SC_HANDLE *v20; // esi@61
  signed int v21; // edi@61
  int v22; // eax@64
  int v23; // ecx@64
  int v24; // eax@65
  int v25; // eax@66
  int v26; // [sp+0h] [bp-28h]@1
  int v27; // [sp+Ch] [bp-1Ch]@2
  int v28; // [sp+10h] [bp-18h]@1
  void *Dst; // [sp+14h] [bp-14h]@1
  unsigned int v30; // [sp+18h] [bp-10h]@2
  void *lpMem; // [sp+1Ch] [bp-Ch]@5
  SC_HANDLE hSCObject; // [sp+20h] [bp-8h]@3

  v28 = 0;
  v4 = alloca(4 * a2);
  Dst = &v26;
  memset(&v26, 0, 4 * a2);
  if ( !a2 )
    goto LABEL_60;
  v5 = (LPCWSTR *)a3;
  v27 = (_BYTE *)Dst - (_BYTE *)a3;
  v30 = a2;
  do
  {
    v6 = OpenServiceW(*(SC_HANDLE *)a1, *v5, 0x13Du);
    v7 = 0;
    hSCObject = v6;
    if ( v6 )
    {
      if ( *(_DWORD *)(*((_DWORD *)a1 + 1) + 16)
        && (HrQueryServiceConfigWithAlloc(v6, (struct _QUERY_SERVICE_CONFIGW **)&lpMem) & 0x80000000) == 0 )
      {
        v8 = *((_DWORD *)lpMem + 1);
        if ( v8 == 3 || v8 == 4 )
          v7 = 1;
        MemFree(lpMem);
        if ( v7 )
          goto LABEL_10;
      }
      v9 = *((_DWORD *)a1 + 1);
      v10 = 13;
      if ( *(_DWORD *)v9 )
      {
        v11 = StartServiceW(hSCObject, 0, 0);
        if ( v11 )
        {
LABEL_25:
          v28 = 1;
          *(LPCWSTR *)((char *)v5 + v27) = (LPCWSTR)hSCObject;
          goto LABEL_42;
        }
        v10 = GetLastError();
      }
      else
      {
        v12 = *(_DWORD *)(v9 + 4);
        if ( !v12 )
          goto LABEL_26;
        if ( v12 == 1 )
        {
          StopDependentServices(hSCObject, *v5, a1);
          if ( !_wcsicmp(L"Netbios", *v5) )
            ScStopNetbios();
        }
        v11 = ControlService(hSCObject, *(_DWORD *)(*((_DWORD *)a1 + 1) + 4), (LPSERVICE_STATUS)((char *)a1 + 12));
        if ( v11 )
          goto LABEL_25;
        v10 = GetLastError();
        if ( *(_DWORD *)(*((_DWORD *)a1 + 1) + 4) == 1 && (v10 == 1052 || v10 == 1061) && *((_DWORD *)a1 + 4) == 3 )
        {
          v11 = 1;
          v10 = 0;
        }
      }
      if ( v11 )
        goto LABEL_25;
LABEL_26:
      v13 = *((_DWORD *)a1 + 1);
      if ( *(_DWORD *)(v13 + 4) == 1 )
      {
        if ( v10 == 1062 )
        {
LABEL_34:
          v10 = 0;
          goto LABEL_35;
        }
        if ( v10 != 1052 && v10 != 1061 )
        {
LABEL_35:
          if ( v10 )
          {
            *((_DWORD *)a1 + 2) = v10;
            v14 = *(_DWORD *)v13 == 0;
            v15 = (int)L"StartService";
            if ( v14 )
              v15 = (int)L"ControlService";
            if ( v10 > 0 )
              v10 = (unsigned __int16)v10 | 0x80070000;
            _SetupWriteTextLog(
              LogToken,
              0x40000000u,
              5u,
              "!!! NCI: Error 0x%08X with %ws on service '%ws'",
              v10,
              v15,
              *v5);
          }
LABEL_10:
          CloseServiceHandle(hSCObject);
          goto LABEL_42;
        }
        v14 = *((_DWORD *)a1 + 4) == 1;
      }
      else
      {
        if ( !*(_DWORD *)v13 )
          goto LABEL_35;
        v14 = v10 == 1056;
      }
      if ( !v14 )
        goto LABEL_35;
      goto LABEL_34;
    }
    HrFromLastWin32Error();
LABEL_42:
    ++v5;
    --v30;
  }
  while ( v30 );
  if ( v28 )
  {
    v16 = *((_DWORD *)a1 + 1);
    v17 = *(_DWORD *)(v16 + 8);
    if ( v17 )
    {
      if ( *(_DWORD *)(v16 + 12) )
      {
        hSCObject = (SC_HANDLE)(v17 / 0x64);
        if ( !(v17 / 0x64) )
          hSCObject = (SC_HANDLE)1;
        v30 = 0;
        if ( hSCObject )
        {
          while ( 1 )
          {
            lpMem = (void *)1;
            v18 = 0;
            do
            {
              v19 = (SC_HANDLE)*((_DWORD *)Dst + v18);
              if ( v19 && QueryServiceStatus(v19, (LPSERVICE_STATUS)((char *)a1 + 12)) )
              {
                if ( *((_DWORD *)a1 + 4) == *(_DWORD *)(*((_DWORD *)a1 + 1) + 12) )
                {
                  CloseServiceHandle(v19);
                  *((_DWORD *)Dst + v18) = 0;
                }
                else
                {
                  lpMem = 0;
                }
              }
              ++v18;
            }
            while ( v18 < a2 );
            if ( lpMem )
              break;
            ++v30;
            Sleep(0x64u);
            if ( v30 >= (unsigned int)hSCObject )
              goto LABEL_58;
          }
        }
        else
        {
LABEL_58:
          if ( !*((_DWORD *)a1 + 2) )
            *((_DWORD *)a1 + 2) = 1460;
        }
      }
    }
  }
LABEL_60:
  if ( a2 )
  {
    v20 = (SC_HANDLE *)Dst;
    v21 = (char *)a3 - (_BYTE *)Dst;
    lpMem = (void *)a2;
    do
    {
      if ( *v20 )
      {
        CloseServiceHandle(*v20);
        if ( v28 )
        {
          v22 = *((_DWORD *)a1 + 1);
          v23 = *(_DWORD *)(v22 + 8);
          if ( v23 )
          {
            v24 = *(_DWORD *)(v22 + 12);
            if ( v24 )
            {
              v14 = v24 == 4;
              v25 = (int)L"start";
              if ( !v14 )
                v25 = (int)L"stop";
              _SetupWriteTextLog(
                LogToken,
                0x40000000u,
                5u,
                "!!! NCI: '%ws' did not %ws within %i milliseconds",
                *(SC_HANDLE *)((char *)v20 + v21),
                v25,
                v23);
            }
          }
        }
      }
      ++v20;
      lpMem = (char *)lpMem - 1;
    }
    while ( lpMem );
  }
}
// 6E685604: using guessed type wchar_t aStop[5];
// 6E685610: using guessed type wchar_t aStart[6];
// 6E68564C: using guessed type wchar_t aControlservice[15];
// 6E68566C: using guessed type wchar_t aStartservice[13];

//----- (6E68569D) --------------------------------------------------------
__int32 __stdcall HrChangeServiceStartType(const unsigned __int16 *a1, unsigned __int32 a2)
{
  __int32 v2; // esi@1
  int v4; // [sp+Ch] [bp-18h]@1
  int v5; // [sp+10h] [bp-14h]@1
  int v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v4 = 0;
  v5 = 0;
  v7 = 0;
  v6 = 0;
  LOBYTE(v7) = 1;
  v2 = CServiceManager::HrOpenService((CServiceManager *)&v4, (CService *)&v6, a1, 1, 0xF003Fu, 0xF01FFu);
  if ( !v2 )
    v2 = CService::HrSetStartType((CService *)&v6, a2);
  LOBYTE(v7) = 0;
  CService::Close((CService *)&v6);
  v7 = -1;
  CServiceManager::~CServiceManager((CServiceManager *)&v4);
  return v2;
}

//----- (6E68570F) --------------------------------------------------------
__int32 __thiscall CServiceManager::HrControlServicesAndWait(CServiceManager *this, unsigned int a2, const unsigned __int16 *const *a3, const struct CSFLAGS *a4, unsigned __int64 a5)
{
  CServiceManager *v5; // esi@1
  __int32 result; // eax@2
  int v7; // [sp+4h] [bp-28h]@3
  const struct CSFLAGS *v8; // [sp+8h] [bp-24h]@3
  __int32 v9; // [sp+Ch] [bp-20h]@3

  v5 = this;
  if ( *(_DWORD *)this || (result = CServiceManager::HrOpen(this, 0, 1u, 0, 0)) == 0 )
  {
    memset(&v7, 0, 0x28u);
    v7 = *(_DWORD *)v5;
    v8 = a4;
    SvcControlServicesAndWait((struct CSCTX *)&v7, a2, a3, a5);
    result = v9;
    if ( v9 > 0 )
      result = (unsigned __int16)v9 | 0x80070000;
  }
  return result;
}

//----- (6E685777) --------------------------------------------------------
__int32 __thiscall CServiceManager::HrStartServicesAndWait(CServiceManager *this, unsigned int a2, const unsigned __int16 *const *a3, unsigned __int32 a4)
{
  int v5; // [sp+4h] [bp-14h]@1
  int v6; // [sp+8h] [bp-10h]@1
  unsigned __int32 v7; // [sp+Ch] [bp-Ch]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v5 = 1;
  v6 = 0;
  v7 = a4;
  v8 = 4;
  v9 = 0;
  return CServiceManager::HrControlServicesAndWait(this, a2, a3, (const struct CSFLAGS *)&v5, 1ui64);
}

//----- (6E6857B6) --------------------------------------------------------
__int32 __thiscall CServiceManager::HrAddRemoveServiceDependency(CServiceManager *this, int a2, void *lpMem, int a4)
{
  struct _QUERY_SERVICE_CONFIGW *v4; // esi@6
  struct _QUERY_SERVICE_CONFIGW *v6; // [sp+Ch] [bp-1Ch]@5
  CServiceManager *v7; // [sp+10h] [bp-18h]@1
  SC_HANDLE hService; // [sp+14h] [bp-14h]@3
  __int32 v9; // [sp+18h] [bp-10h]@1
  int v10; // [sp+24h] [bp-4h]@3

  v7 = this;
  v9 = 0;
  if ( *(_WORD *)a2 && *(_WORD *)lpMem )
  {
    hService = 0;
    v10 = 0;
    v9 = CServiceManager::HrOpenService(this, (CService *)&hService, (const WCHAR *)lpMem, 0, 0xF003Fu, 0xF01FFu);
    if ( !v9 )
    {
      v9 = CServiceManager::HrOpenService(v7, (CService *)&hService, (const WCHAR *)a2, 0, 0xF003Fu, 0xF01FFu);
      if ( !v9 )
      {
        v9 = HrQueryServiceConfigWithAlloc(hService, &v6);
        if ( !v9 )
        {
          v4 = v6;
          a2 = 0;
          if ( a4 )
          {
            if ( a4 == 1 )
            {
              RemoveSzFromMultiSz((wchar_t *)lpMem, v6->lpDependencies, 64, &a2);
              if ( a2 )
                v9 = CService::HrSetDependencies((CService *)&hService, v4->lpDependencies);
            }
          }
          else
          {
            v9 = HrAddSzToMultiSz((wchar_t *)lpMem, v6->lpDependencies, 0x14u, 0, (unsigned __int16 **)&lpMem, &a2);
            if ( !v9 && a2 )
            {
              v9 = CService::HrSetDependencies((CService *)&hService, (const unsigned __int16 *)lpMem);
              MemFree(lpMem);
            }
          }
          MemFree(v4);
        }
      }
    }
    if ( v9 == -2147023836 )
      v9 = 0;
    *((_DWORD *)v7 + 1) = 0;
    v10 = -1;
    CService::Close((CService *)&hService);
  }
  return v9;
}

//----- (6E6858DD) --------------------------------------------------------
HRESULT __thiscall CAutoImpersonate::RecoverLostImpersonation(CAutoImpersonate *this)
{
  HRESULT v1; // esi@1
  HRESULT result; // eax@2

  v1 = 0;
  if ( *((_DWORD *)this + 3) )
  {
    if ( CAutoImpersonate::ShouldRecoverLostImpersonation(this) )
      v1 = CoImpersonateClient();
    result = v1;
  }
  else
  {
    result = -2147467259;
  }
  return result;
}

//----- (6E685908) --------------------------------------------------------
signed int __stdcall HrFromConfigManagerError(unsigned __int32 a1, __int32 a2)
{
  signed int result; // eax@9

  if ( a1 <= 0x2F )
  {
    if ( a1 == 47 )
      return -536870368;
    if ( !a1 )
      return 0;
    if ( a1 == 2 )
      return -2147024882;
    if ( a1 == 3 )
      return -2147467261;
    if ( a1 == 5 )
      return -536870389;
    if ( a1 == 16 )
      return -536870393;
    if ( a1 == 30 )
      return -536870395;
    return a2;
  }
  switch ( a1 )
  {
    case 0x30u:
      result = -536870367;
      break;
    case 0x31u:
      result = -536870366;
      break;
    case 0x32u:
      result = -536870365;
      break;
    case 0x33u:
      result = -2147024891;
      break;
    case 0x34u:
      result = -2147467263;
      break;
    default:
      if ( a1 != 56 )
        return a2;
      result = -536870369;
      break;
  }
  return result;
}

//----- (6E6859AB) --------------------------------------------------------
__int32 __stdcall HrProcessInfExtension(HINF InfHandle, const unsigned __int16 *Src, const unsigned __int16 *a3, const unsigned __int16 *a4, const unsigned __int16 *a5, __int32 (__stdcall *a6)(void *, const unsigned __int16 *), __int32 (__stdcall *a7)(void *, const unsigned __int16 *))
{
  void *v7; // eax@1
  signed int v8; // edi@3
  __int32 v9; // esi@3
  int *v10; // eax@10
  int v11; // eax@13
  struct _INFCONTEXT Context; // [sp+Ch] [bp-268h]@3
  LPCWSTR lpString2; // [sp+1Ch] [bp-258h]@1
  __int32 (__stdcall *v15)(void *, const unsigned __int16 *); // [sp+20h] [bp-254h]@1
  LPCWSTR v16; // [sp+24h] [bp-250h]@1
  __int32 (__stdcall *v17)(void *, const unsigned __int16 *); // [sp+28h] [bp-24Ch]@1
  char v18; // [sp+2Ch] [bp-248h]@1
  PCWSTR Section; // [sp+30h] [bp-244h]@1
  unsigned int v20; // [sp+44h] [bp-230h]@1
  int v21; // [sp+48h] [bp-22Ch]@4
  int *v22; // [sp+4Ch] [bp-228h]@10
  unsigned int v23; // [sp+60h] [bp-214h]@11
  WCHAR String1; // [sp+64h] [bp-210h]@5
  __int16 v25; // [sp+262h] [bp-12h]@6
  int v26; // [sp+270h] [bp-4h]@1

  lpString2 = a4;
  v16 = a5;
  v15 = a6;
  v17 = a7;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v18);
  v26 = 0;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
    (int)&v18,
    (void *)Src);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    L".");
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
    (int)&v18,
    (void *)a3);
  v7 = (void *)Section;
  if ( v20 < 8 )
    v7 = &Section;
  v8 = 0;
  v9 = HrSetupFindFirstLine(InfHandle, (PCWSTR)v7, 0, &Context);
  if ( !v9 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v21);
    LOBYTE(v26) = 1;
    while ( 1 )
    {
      v9 = HrSetupGetStringField(&Context, 0, &String1, 0x100u, 0);
      if ( v9 < 0 )
      {
        LOBYTE(v26) = 0;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
          (int)&v21,
          1,
          0);
        goto LABEL_22;
      }
      v25 = 0;
      if ( lstrcmpiW(&String1, lpString2) )
      {
        if ( lstrcmpiW(&String1, v16) )
          goto LABEL_18;
      }
      else
      {
        v8 = 1;
      }
      v9 = HrSetupGetStringField(&Context, 1u, (int)&v21);
      if ( v9 )
        goto LABEL_28;
      v10 = v22;
      if ( v8 )
      {
        if ( v23 < 8 )
          v10 = (int *)&v22;
        v11 = v15(InfHandle, (const unsigned __int16 *)v10);
      }
      else
      {
        if ( v23 < 8 )
          v10 = (int *)&v22;
        v11 = v17(InfHandle, (const unsigned __int16 *)v10);
      }
      v9 = v11;
      if ( v11 < 0 )
      {
LABEL_28:
        LOBYTE(v26) = 0;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
          (int)&v21,
          1,
          0);
        goto LABEL_22;
      }
LABEL_18:
      v9 = HrSetupFindNextLine(&Context, &Context);
      v8 = 0;
      if ( v9 )
      {
        LOBYTE(v26) = 0;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
          (int)&v21,
          1,
          0);
        break;
      }
    }
  }
  if ( v9 == 1 )
    v9 = 0;
LABEL_22:
  v26 = -1;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v18,
    1,
    0);
  return v9;
}
// 6E65C8D8: using guessed type wchar_t a_[2];

//----- (6E685B87) --------------------------------------------------------
void __thiscall CDiagContext::SetFlags(CDiagContext *this, unsigned __int32 a2)
{
  *(_DWORD *)this = a2;
  if ( a2 & 1 )
  {
    if ( !*((_DWORD *)this + 1) )
      *((_DWORD *)this + 1) = MemAlloc(0x1000u);
  }
}

//----- (6E685BB5) --------------------------------------------------------
int __stdcall SzFromCharacteristics(int a1, int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@2
  void *Src; // [sp+4h] [bp-44h]@1
  int v5; // [sp+8h] [bp-40h]@1
  int v6; // [sp+Ch] [bp-3Ch]@1
  int v7; // [sp+10h] [bp-38h]@1
  int v8; // [sp+14h] [bp-34h]@1
  int v9; // [sp+18h] [bp-30h]@1
  int v10; // [sp+1Ch] [bp-2Ch]@1
  int v11; // [sp+20h] [bp-28h]@1
  int v12; // [sp+24h] [bp-24h]@1
  int v13; // [sp+28h] [bp-20h]@1
  int v14; // [sp+2Ch] [bp-1Ch]@1
  int v15; // [sp+30h] [bp-18h]@1
  int v16; // [sp+34h] [bp-14h]@1
  int v17; // [sp+38h] [bp-10h]@1
  int v18; // [sp+3Ch] [bp-Ch]@1
  int v19; // [sp+40h] [bp-8h]@1
  int v20; // [sp+44h] [bp-4h]@1

  Src = L"NCF_VIRTUAL ";
  v5 = (int)L"NCF_SOFTWARE_ENUMERATED ";
  v6 = (int)L"NCF_PHYSICAL ";
  v7 = (int)L"NCF_HIDDEN ";
  v8 = (int)L"NCF_NO_SERVICE ";
  v9 = (int)L"NCF_NOT_USER_REMOVABLE ";
  v10 = (int)L"NCF_MULTIPORT_INSTANCED_ADAPTER ";
  v11 = (int)L"NCF_HAS_UI ";
  v12 = (int)L"NCF_MODEM ";
  v13 = (int)L"NCF_FILTER_DEVICE ";
  v14 = (int)L"NCF_FILTER ";
  v15 = (int)L"NCF_DONTEXPOSELOWER ";
  v16 = (int)L"NCF_HIDE_BINDING ";
  v17 = (int)L"0x4000 ";
  v18 = (int)L"0x8000 ";
  v19 = (int)L"NCF_FORCE_SCM_NOTIFY ";
  v20 = (int)L"NCF_FIXED_BINDING ";
  v2 = 0;
  do
  {
    result = 1 << v2;
    if ( (1 << v2) & a1 )
      result = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
                 a2,
                 *(&Src + v2));
    ++v2;
  }
  while ( v2 < 0x11 );
  return result;
}
// 6E685C5C: using guessed type wchar_t aNcf_fixed_bind[19];
// 6E685C84: using guessed type wchar_t aNcf_force_scm_[22];
// 6E685CB0: using guessed type wchar_t a0x8000[8];
// 6E685CC0: using guessed type wchar_t a0x4000[8];
// 6E685CD0: using guessed type wchar_t aNcf_hide_bindi[18];
// 6E685CF4: using guessed type wchar_t aNcf_dontexpose[21];
// 6E685D20: using guessed type wchar_t aNcf_filter[12];
// 6E685D38: using guessed type wchar_t aNcf_filter_dev[19];
// 6E685D60: using guessed type wchar_t aNcf_modem[11];
// 6E685D78: using guessed type wchar_t aNcf_has_ui[12];
// 6E685D90: using guessed type wchar_t aNcf_multiport_[33];
// 6E685DD4: using guessed type wchar_t aNcf_not_user_r[24];
// 6E685E04: using guessed type wchar_t aNcf_no_service[16];
// 6E685E24: using guessed type wchar_t aNcf_hidden[12];
// 6E685E3C: using guessed type wchar_t aNcf_physical[14];
// 6E685E58: using guessed type wchar_t aNcf_software_e[25];
// 6E685E8C: using guessed type wchar_t aNcf_virtual[13];

//----- (6E685EAB) --------------------------------------------------------
__int32 __stdcall HrCreateAndInitializeINetCfg(int *a1, struct INetCfg **a2, int a3, unsigned __int32 a4, const unsigned __int16 *a5, struct IUnknown *a6)
{
  struct IUnknown *v6; // ebx@1
  HRESULT v7; // esi@5
  struct IUnknown *v8; // ST10_4@15
  LPVOID ppv; // [sp+Ch] [bp-4h]@8

  v6 = a6;
  *a2 = 0;
  if ( v6 )
    v6->lpVtbl = 0;
  if ( !a1 || !*a1 )
    goto LABEL_25;
  v7 = CoInitializeEx(0, 6u);
  if ( v7 == -2147417850 )
  {
    v7 = 0;
    *a1 = 0;
  }
  if ( v7 >= 0 )
  {
LABEL_25:
    v7 = CoCreateInstance(&CLSID_CNetCfg, 0, 0x401u, &IID_INetCfg, &ppv);
    if ( v7 < 0 )
    {
LABEL_19:
      if ( a1 && *a1 )
        CoUninitialize();
      return v7;
    }
    a6 = 0;
    if ( a3 )
    {
      v7 = (**(int (__stdcall ***)(LPVOID, GUID *, struct IUnknown **))ppv)(ppv, &IID_INetCfgLock, &a6);
      if ( v7 < 0 )
        goto LABEL_18;
      v7 = ((int (__stdcall *)(struct IUnknown *, unsigned __int32, const unsigned __int16 *, struct IUnknown *))a6->lpVtbl[1].QueryInterface)(
             a6,
             a4,
             a5,
             v6);
      if ( v7 == 1 )
        v7 = -2147180508;
    }
    if ( v7 >= 0 )
    {
      v7 = (*(int (__stdcall **)(LPVOID, _DWORD))(*(_DWORD *)ppv + 12))(ppv, 0);
      if ( v7 < 0 )
      {
        if ( a6 )
          a6->lpVtbl[1].AddRef(a6);
      }
      else
      {
        v8 = (struct IUnknown *)ppv;
        *a2 = (struct INetCfg *)ppv;
        AddRefObj(v8);
      }
    }
LABEL_18:
    ReleaseObj(a6);
    ReleaseObj((struct IUnknown *)ppv);
    if ( v7 >= 0 )
      return v7;
    goto LABEL_19;
  }
  return v7;
}

//----- (6E685FB4) --------------------------------------------------------
int __stdcall HrUninitializeAndUnlockINetCfg(struct IUnknown *a1)
{
  struct IUnknown *v1; // esi@1
  int v2; // edi@1

  v1 = a1;
  v2 = a1->lpVtbl[1].AddRef(a1);
  if ( v2 >= 0 )
  {
    v2 = v1->lpVtbl->QueryInterface(v1, &IID_INetCfgLock, (void **)&a1);
    if ( v2 >= 0 )
    {
      v2 = a1->lpVtbl[1].AddRef(a1);
      ReleaseObj(a1);
    }
  }
  return v2;
}

//----- (6E685FFE) --------------------------------------------------------
signed int __stdcall HrIsLanCapableAdapter(struct IUnknown *a1)
{
  struct IUnknown *v1; // ebx@1
  int v2; // esi@1
  signed int result; // eax@4
  int v4; // esi@5
  wchar_t *Str1; // [sp+Ch] [bp-4h]@1

  v1 = a1;
  v2 = ((int (__stdcall *)(struct IUnknown *, wchar_t **))a1->lpVtbl[2].QueryInterface)(a1, &Str1);
  if ( !v2 )
  {
    v2 = _wcsicmp(Str1, L"BTH\\MS_BTHPAN") == 0;
    CoTaskMemFree(Str1);
  }
  if ( v2 == 1 )
  {
    result = 1;
  }
  else
  {
    v4 = v1->lpVtbl->QueryInterface(v1, &IID_INetCfgComponentBindings, (void **)&a1);
    if ( !v4 )
    {
      v4 = ((int (__stdcall *)(struct IUnknown *, signed int, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
             a1,
             2,
             &L"ndis4");
      if ( v4 == 1 )
      {
        v4 = ((int (__stdcall *)(struct IUnknown *, signed int, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
               a1,
               2,
               &L"ndis5");
        if ( v4 == 1 )
        {
          v4 = ((int (__stdcall *)(_DWORD, _DWORD, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
                 a1,
                 2,
                 &L"ndis5_ip");
          if ( v4 == 1 )
          {
            v4 = ((int (__stdcall *)(_DWORD, _DWORD, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
                   a1,
                   2,
                   &L"flpp4");
            if ( v4 == 1 )
            {
              v4 = ((int (__stdcall *)(_DWORD, _DWORD, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
                     a1,
                     2,
                     &L"flpp6");
              if ( v4 == 1 )
              {
                v4 = ((int (__stdcall *)(struct IUnknown *, signed int, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
                       a1,
                       1,
                       &L"LocalTalk");
                if ( v4 == 1 )
                  v4 = ((int (__stdcall *)(_DWORD, _DWORD, const unsigned __int16 *const *))a1->lpVtbl[1].Release)(
                         a1,
                         2,
                         &L"ndis1394");
              }
            }
          }
        }
      }
      ReleaseObj(a1);
    }
    result = v4;
  }
  return result;
}
// 6E686104: using guessed type const unsigned __int16 *const c_szBiNdis4;
// 6E686110: using guessed type const unsigned __int16 *const c_szBiNdis5;
// 6E68611C: using guessed type const unsigned __int16 *const c_szBiNdis5Ip;
// 6E686130: using guessed type const unsigned __int16 *const c_szBiNdis1394;
// 6E686144: using guessed type const unsigned __int16 *const c_szBiLocalTalk;
// 6E686158: using guessed type const unsigned __int16 *const c_szBiFlpp4;
// 6E686164: using guessed type const unsigned __int16 *const c_szBiFlpp6;

//----- (6E686191) --------------------------------------------------------
int __stdcall HrUninitializeAndReleaseINetCfg(int a1, struct IUnknown *a2, int a3)
{
  int v3; // eax@2
  int v4; // esi@4

  if ( a3 )
    v3 = HrUninitializeAndUnlockINetCfg(a2);
  else
    v3 = a2->lpVtbl[1].AddRef(a2);
  v4 = v3;
  ReleaseObj(a2);
  if ( a1 )
    CoUninitialize();
  return v4;
}

//----- (6E6861D1) --------------------------------------------------------
void __thiscall CPropSheetPage::SetChangedFlag(CPropSheetPage *this)
{
  CPropSheetPage *v1; // esi@1
  HWND v2; // eax@1

  v1 = this;
  v2 = GetParent(*((HWND *)this + 1));
  SendMessageW(v2, 0x468u, *((_DWORD *)v1 + 1), 0);
}

//----- (6E6861F7) --------------------------------------------------------
signed int CPropSheetPage::UCreatePageCallbackHandler()
{
  return 1;
}

//----- (6E686200) --------------------------------------------------------
LONG __thiscall CIsdnPage::~CIsdnPage(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  *(_DWORD *)this = &CIsdnPage::`vftable';
  v2 = (void *)*((_DWORD *)this + 6);
  if ( v2 )
    FreeIsdnPropertiesInfo(v2);
  RegSafeCloseKey(*((HKEY *)v1 + 3));
  return CPropSheetPage::~CPropSheetPage(v1);
}
// 6E65D568: using guessed type int (__thiscall *CIsdnPage::`vftable')(CIsdnPage *this, HWND, unsigned int, unsigned int, HWND, CIsdnPage *, unsigned __int32);

//----- (6E686246) --------------------------------------------------------
void __thiscall CAdvanced::DestroyPageCallbackHandler(CAdvanced *this)
{
  if ( this )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)this + 4))(1);
}

//----- (6E686257) --------------------------------------------------------
struct _PSP *__thiscall CIsdnPage::CreatePage(CIsdnPage *this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  CIsdnPage *v3; // esi@1
  HKEY *v4; // edi@1
  DWORD v5; // ecx@1
  struct _PSP *v7; // [sp+Ch] [bp-4h]@1

  v3 = this;
  v4 = (HKEY *)((char *)this + 12);
  v7 = 0;
  if ( HrSetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, 1u, 0, 2u, 0xF003Fu, (HKEY *)this + 3) >= 0
    && FShowIsdnPages(v5, *v4)
    && HrReadIsdnPropertiesInfo(*v4, DeviceInfoSet, DeviceInfoData, (struct _ISDNConfigInfo **)v3 + 6) >= 0 )
  {
    *((_DWORD *)v3 + 4) = DeviceInfoSet;
    *((_DWORD *)v3 + 5) = DeviceInfoData;
    v7 = CPropSheetPage::CreatePage(v3, 14116, 0, 0, 0, 0, 0);
  }
  return v7;
}

//----- (6E6862D3) --------------------------------------------------------
__int32 __thiscall CIsdnPage::OnApply(CIsdnPage *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CIsdnPage *v4; // esi@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+4h] [bp-230h]@2

  v4 = this;
  if ( *((_DWORD *)this + 2) )
  {
    *(_DWORD *)(*((_DWORD *)this + 6) + 12) = DwGetSwitchType(
                                                *((HWND *)this + 1),
                                                *((struct _ISDNConfigInfo **)this + 6),
                                                1000);
    HrWriteIsdnPropertiesInfo(*((HKEY *)v4 + 3), *((struct _ISDNConfigInfo **)v4 + 6));
    HrSetupDiGetDeviceInstallParams(*((HDEVINFO *)v4 + 4), *((PSP_DEVINFO_DATA *)v4 + 5), &Dst);
    Dst.FlagsEx |= 0x400u;
    HrSetupDiSetDeviceInstallParams(*((HDEVINFO *)v4 + 4), *((PSP_DEVINFO_DATA *)v4 + 5), &Dst);
    *((_DWORD *)v4 + 2) = 0;
  }
  return 0;
}

//----- (6E68635A) --------------------------------------------------------
signed int __thiscall CIsdnPage::OnContextMenu(CIsdnPage *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CIsdnPage *v5; // edi@1
  signed int result; // eax@1
  HMENU v7; // ebx@1
  struct tagHELPINFO v8; // [sp+8h] [bp-22Ch]@3
  HWND hWnd; // [sp+24h] [bp-210h]@1
  WCHAR Buffer; // [sp+28h] [bp-20Ch]@2

  v5 = this;
  hWnd = (HWND)a3;
  result = (signed int)CreatePopupMenu();
  v7 = (HMENU)result;
  if ( result )
  {
    LoadStringW(hInst, 0x1Cu, &Buffer, 260);
    InsertMenuW(v7, 0xFFFFFFFF, 0x400u, 0x309u, &Buffer);
    if ( TrackPopupMenu(v7, 0x180u, (signed __int16)a4, SHIWORD(a4), 0, *((HWND *)v5 + 1), 0) == 777 )
    {
      v8.iContextType = 1;
      v8.iCtrlId = GetWindowLongW(hWnd, -12);
      OnHelpGeneric(
        *((HWND *)v5 + 1),
        &v8,
        (const struct CONTEXTIDMAP *)dword_6E65D4E0,
        *(_DWORD *)(*((_DWORD *)v5 + 6) + 32) == 14118,
        L"devmgr.hlp");
    }
    DestroyMenu(v7);
    result = 1;
  }
  return result;
}
// 6E65D4E0: using guessed type int dword_6E65D4E0[34];

//----- (6E68644C) --------------------------------------------------------
void __thiscall CIsdnPage::EnableDisableConfigure(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  unsigned __int32 v2; // edi@1
  HWND v3; // eax@1

  v1 = this;
  v2 = DwGetSwitchType(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6), 1000);
  v3 = GetDlgItem(*((HWND *)v1 + 1), 1011);
  if ( v3 )
  {
    if ( v2 && (v2 <= 2 || v2 == 4 || v2 == 8 || v2 == 2048) && *(_DWORD *)(*((_DWORD *)v1 + 6) + 24) )
      EnableWindow(v3, 0);
    else
      EnableWindow(v3, 1);
  }
}

//----- (6E6864AF) --------------------------------------------------------
__int32 __thiscall CSpidsDlg::OnInitDialog(CSpidsDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CSpidsDlg *v5; // esi@1
  HWND v6; // eax@1

  v5 = this;
  PopulateIsdnChannels(*((HWND *)this + 1), 14103, 1008, 1005, 1010, *((struct _ISDNConfigInfo **)this + 6));
  v6 = GetDlgItem(*((HWND *)v5 + 1), 1008);
  SetFocus(v6);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 20) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1010, 0x188u, 0, 0);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 16) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1005, 0x188u, 0, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 14103, 0xC5u, 0x14u, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 1008, 0xC5u, 0x1Eu, 0);
  return 0;
}

//----- (6E686549) --------------------------------------------------------
__int32 __thiscall CSpidsDlg::OnSelChange(CSpidsDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  if ( a2 == 1 )
    OnIsdnInfoPageSelChange(*((HWND *)this + 1), *((_DWORD *)this + 6));
  return 0;
}

//----- (6E68656B) --------------------------------------------------------
signed int __thiscall CMsnDlg::OnHelp(CMsnDlg *this, unsigned int a2, unsigned int a3, struct tagHELPINFO *a4, int *a5)
{
  OnHelpGeneric(
    *((HWND *)this + 1),
    a4,
    (const struct CONTEXTIDMAP *)dword_6E65D4E0,
    *(_DWORD *)(*((_DWORD *)this + 6) + 32) == 14118,
    L"devmgr.hlp");
  return 1;
}
// 6E65D4E0: using guessed type int dword_6E65D4E0[34];

//----- (6E6865A1) --------------------------------------------------------
__int32 __thiscall CEazDlg::OnInitDialog(CEazDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CEazDlg *v5; // esi@1
  HWND v6; // eax@1

  v5 = this;
  PopulateIsdnChannels(*((HWND *)this + 1), 14103, 1008, 1005, 1010, *((struct _ISDNConfigInfo **)this + 6));
  v6 = GetDlgItem(*((HWND *)v5 + 1), 1008);
  SetFocus(v6);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 20) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1010, 0x188u, 0, 0);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 16) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1005, 0x188u, 0, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 1008, 0xC5u, 0x1Eu, 0);
  return 0;
}

//----- (6E686628) --------------------------------------------------------
__int32 __thiscall CJapanDlg::OnOk(CJapanDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  ATL::CDialogImplBase *v5; // esi@1

  v5 = this;
  OnIsdnInfoPageTransition(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
  ATL::CDialogImplBase::EndDialog(v5, 1);
  return 0;
}

//----- (6E68664C) --------------------------------------------------------
__int32 __thiscall CMsnDlg::OnInitDialog(CMsnDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CMsnDlg *v5; // esi@1

  v5 = this;
  OnMsnPageInitDialog(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 16) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1005, 0x188u, 0, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 1001, 0xC5u, 0x1Eu, 0);
  return 0;
}

//----- (6E68669B) --------------------------------------------------------
__int32 __thiscall CMsnDlg::OnOk(CMsnDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CMsnDlg *v5; // esi@1
  LRESULT v6; // eax@1

  v5 = this;
  v6 = SendDlgItemMessageW(*((HWND *)this + 1), 1005, 0x188u, 0, 0);
  if ( v6 != -1 )
    GetDataFromListBox(v6, *((HWND *)v5 + 1), *((struct _ISDNConfigInfo **)v5 + 6));
  ATL::CDialogImplBase::EndDialog(v5, 1);
  return 0;
}

//----- (6E6866DC) --------------------------------------------------------
__int32 __thiscall CMsnDlg::OnSelChange(CMsnDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  if ( a2 == 1 )
    OnMsnPageSelChange(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
  return 0;
}

//----- (6E6866FE) --------------------------------------------------------
__int32 __thiscall CJapanDlg::OnInitDialog(CJapanDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CJapanDlg *v5; // esi@1
  HWND v6; // eax@1

  v5 = this;
  PopulateIsdnChannels(*((HWND *)this + 1), 14103, 1008, 1005, 1010, *((struct _ISDNConfigInfo **)this + 6));
  v6 = GetDlgItem(*((HWND *)v5 + 1), 1008);
  SetFocus(v6);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 20) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1010, 0x188u, 0, 0);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 16) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1005, 0x188u, 0, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 1008, 0xC5u, 0x1Eu, 0);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 14103, 0xC5u, 0x1Eu, 0);
  return 0;
}

//----- (6E686798) --------------------------------------------------------
int __thiscall ATL::CDialogImpl<CSpidsDlg>::DoModal(void *this, HWND hWndParent)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  if ( ATL::CDynamicStdCallThunk::Init((ATL::CDynamicStdCallThunk *)((char *)this + 20), 0, 0) )
  {
    ATL::CComModule::AddCreateWndData(
      (ATL::CComModule *)&_Module,
      (struct ATL::_AtlCreateWndData *)((char *)v2 + 8),
      v2);
    result = DialogBoxParamW(hInst, (LPCWSTR)0x57F, hWndParent, ATL::CDialogImplBase::StartDialogProc, 0);
    *((_DWORD *)v2 + 1) = 0;
  }
  else
  {
    SetLastError(0xEu);
    result = -1;
  }
  return result;
}

//----- (6E6867F5) --------------------------------------------------------
int __thiscall ATL::CDialogImpl<CEazDlg>::DoModal(void *this, HWND hWndParent)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  if ( ATL::CDynamicStdCallThunk::Init((ATL::CDynamicStdCallThunk *)((char *)this + 20), 0, 0) )
  {
    ATL::CComModule::AddCreateWndData(
      (ATL::CComModule *)&_Module,
      (struct ATL::_AtlCreateWndData *)((char *)v2 + 8),
      v2);
    result = DialogBoxParamW(hInst, (LPCWSTR)0x3725, hWndParent, ATL::CDialogImplBase::StartDialogProc, 0);
    *((_DWORD *)v2 + 1) = 0;
  }
  else
  {
    SetLastError(0xEu);
    result = -1;
  }
  return result;
}

//----- (6E686852) --------------------------------------------------------
int __thiscall ATL::CDialogImpl<CMsnDlg>::DoModal(void *this, HWND hWndParent)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  if ( ATL::CDynamicStdCallThunk::Init((ATL::CDynamicStdCallThunk *)((char *)this + 20), 0, 0) )
  {
    ATL::CComModule::AddCreateWndData(
      (ATL::CComModule *)&_Module,
      (struct ATL::_AtlCreateWndData *)((char *)v2 + 8),
      v2);
    result = DialogBoxParamW(hInst, (LPCWSTR)0x3727, hWndParent, ATL::CDialogImplBase::StartDialogProc, 0);
    *((_DWORD *)v2 + 1) = 0;
  }
  else
  {
    SetLastError(0xEu);
    result = -1;
  }
  return result;
}

//----- (6E6868AF) --------------------------------------------------------
int __thiscall ATL::CDialogImpl<CJapanDlg>::DoModal(void *this, HWND hWndParent)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  if ( ATL::CDynamicStdCallThunk::Init((ATL::CDynamicStdCallThunk *)((char *)this + 20), 0, 0) )
  {
    ATL::CComModule::AddCreateWndData(
      (ATL::CComModule *)&_Module,
      (struct ATL::_AtlCreateWndData *)((char *)v2 + 8),
      v2);
    result = DialogBoxParamW(hInst, (LPCWSTR)0x3726, hWndParent, ATL::CDialogImplBase::StartDialogProc, 0);
    *((_DWORD *)v2 + 1) = 0;
  }
  else
  {
    SetLastError(0xEu);
    result = -1;
  }
  return result;
}

//----- (6E68690C) --------------------------------------------------------
int __thiscall CEazDlg::ProcessWindowMessage(CEazDlg *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, ATL::CDialogImplBase *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  __int32 v9; // eax@10
  unsigned __int16 v10; // dx@12

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CEazDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a6);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 273 )
    {
      if ( 2 == (_WORD)a4 )
      {
        ATL::CDialogImplBase::EndDialog(this, 0);
        *(_DWORD *)a6 = 0;
        return 1;
      }
      if ( 1 == (_WORD)a4 )
      {
        v9 = CJapanDlg::OnOk(this, HIWORD(a4), 1u, a5, (int *)&a6);
LABEL_11:
        *(_DWORD *)a6 = v9;
        return 1;
      }
      v10 = 1010;
      if ( 1010 == (_WORD)a4 || (v10 = 1005, 1005 == (_WORD)a4) )
      {
        v9 = CSpidsDlg::OnSelChange(this, HIWORD(a4), v10, a5, (int *)&a6);
        goto LABEL_11;
      }
    }
    else if ( a3 == 83 )
    {
      v7 = CMsnDlg::OnHelp(this, 0x53u, a4, (struct tagHELPINFO *)a5, (int *)&a6);
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (6E6869DB) --------------------------------------------------------
void __thiscall CEazDlg::~CEazDlg(CEazDlg *this)
{
  void *v1; // ecx@1

  *(_DWORD *)this = CEazDlg::`vftable';
  v1 = (void *)*((_DWORD *)this + 5);
  if ( v1 )
    ATL::__FreeStdCallThunk(v1);
}
// 6E65D578: using guessed type int (__thiscall *CEazDlg::`vftable'[4])(CEazDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E6869F4) --------------------------------------------------------
CMsnDlg *__thiscall CMsnDlg::CMsnDlg(CMsnDlg *this, struct _ISDNConfigInfo *a2)
{
  CMsnDlg *result; // eax@1

  result = this;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 5) = 0;
  *(_DWORD *)this = CMsnDlg::`vftable';
  *((_DWORD *)this + 6) = a2;
  *((_DWORD *)this + 7) = 0;
  return result;
}
// 6E65D57C: using guessed type int (__thiscall *CMsnDlg::`vftable'[3])(CMsnDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686A1B) --------------------------------------------------------
int __thiscall CMsnDlg::ProcessWindowMessage(CMsnDlg *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, ATL::CDialogImplBase *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  __int32 v9; // eax@10

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CMsnDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a6);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 273 )
    {
      if ( 2 == (_WORD)a4 )
      {
        ATL::CDialogImplBase::EndDialog(this, 0);
        *(_DWORD *)a6 = 0;
        return 1;
      }
      if ( 1 == (_WORD)a4 )
      {
        v9 = CMsnDlg::OnOk(this, HIWORD(a4), 1u, a5, (int *)&a6);
LABEL_11:
        *(_DWORD *)a6 = v9;
        return 1;
      }
      if ( 1002 == (_WORD)a4 )
      {
        OnMsnPageAdd(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
LABEL_15:
        *(_DWORD *)a6 = 0;
        return 1;
      }
      if ( 1003 == (_WORD)a4 )
      {
        OnMsnPageRemove(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
        goto LABEL_15;
      }
      if ( 1005 == (_WORD)a4 )
      {
        v9 = CMsnDlg::OnSelChange(this, HIWORD(a4), 0x3EDu, a5, (int *)&a6);
        goto LABEL_11;
      }
      if ( 768 == HIWORD(a4) )
      {
        OnMsnPageEditSelChange(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6));
        goto LABEL_15;
      }
    }
    else if ( a3 == 83 )
    {
      v7 = CMsnDlg::OnHelp(this, 0x53u, a4, (struct tagHELPINFO *)a5, (int *)&a6);
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (6E686B37) --------------------------------------------------------
void __thiscall CMsnDlg::~CMsnDlg(CMsnDlg *this)
{
  void *v1; // ecx@1

  *(_DWORD *)this = CMsnDlg::`vftable';
  v1 = (void *)*((_DWORD *)this + 5);
  if ( v1 )
    ATL::__FreeStdCallThunk(v1);
}
// 6E65D57C: using guessed type int (__thiscall *CMsnDlg::`vftable'[3])(CMsnDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686B50) --------------------------------------------------------
int __thiscall CJapanDlg::ProcessWindowMessage(CJapanDlg *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, ATL::CDialogImplBase *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  __int32 v9; // eax@7
  unsigned __int16 v10; // dx@12

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CJapanDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a6);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 273 )
    {
      if ( 1 == (_WORD)a4 )
      {
        v9 = CJapanDlg::OnOk(this, HIWORD(a4), 1u, a5, (int *)&a6);
LABEL_8:
        *(_DWORD *)a6 = v9;
        return 1;
      }
      if ( 2 == (_WORD)a4 )
      {
        ATL::CDialogImplBase::EndDialog(this, 0);
        *(_DWORD *)a6 = 0;
        return 1;
      }
      v10 = 1010;
      if ( 1010 == (_WORD)a4 || (v10 = 1005, 1005 == (_WORD)a4) )
      {
        v9 = CSpidsDlg::OnSelChange(this, HIWORD(a4), v10, a5, (int *)&a6);
        goto LABEL_8;
      }
    }
    else if ( a3 == 83 )
    {
      v7 = CMsnDlg::OnHelp(this, 0x53u, a4, (struct tagHELPINFO *)a5, (int *)&a6);
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (6E686C1F) --------------------------------------------------------
void __thiscall CJapanDlg::~CJapanDlg(CJapanDlg *this)
{
  void *v1; // ecx@1

  *(_DWORD *)this = CJapanDlg::`vftable';
  v1 = (void *)*((_DWORD *)this + 5);
  if ( v1 )
    ATL::__FreeStdCallThunk(v1);
}
// 6E65D580: using guessed type int (__thiscall *CJapanDlg::`vftable'[2])(CJapanDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686C38) --------------------------------------------------------
CIsdnPage *__thiscall CIsdnPage::CIsdnPage(CIsdnPage *this)
{
  CIsdnPage *result; // eax@1

  result = this;
  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = &CIsdnPage::`vftable';
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  return result;
}
// 6E65D568: using guessed type int (__thiscall *CIsdnPage::`vftable')(CIsdnPage *this, HWND, unsigned int, unsigned int, HWND, CIsdnPage *, unsigned __int32);

//----- (6E686C5A) --------------------------------------------------------
void *__thiscall CIsdnPage::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CIsdnPage::~CIsdnPage((CIsdnPage *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E686C80) --------------------------------------------------------
__int32 __thiscall CIsdnPage::OnInitDialog(CIsdnPage *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CIsdnPage *v5; // esi@1

  v5 = this;
  PopulateIsdnSwitchTypes(*((HWND *)this + 1), 1000, *((struct _ISDNConfigInfo **)this + 6));
  SetSwitchType(*((HWND *)v5 + 1), 1000, *(_DWORD *)(*((_DWORD *)v5 + 6) + 12));
  CIsdnPage::EnableDisableConfigure(v5);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 20) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1010, 0x188u, 0, 0);
  *(_DWORD *)(*((_DWORD *)v5 + 6) + 16) = SendDlgItemMessageW(*((HWND *)v5 + 1), 1005, 0x188u, 0, 0);
  return 0;
}

//----- (6E686CF0) --------------------------------------------------------
__int32 __thiscall CIsdnPage::OnSwitchType(CIsdnPage *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CIsdnPage *v5; // esi@1

  v5 = this;
  if ( a2 == 1 )
  {
    *((_DWORD *)this + 2) = 1;
    CPropSheetPage::SetChangedFlag(this);
    CIsdnPage::EnableDisableConfigure(v5);
  }
  return 0;
}

//----- (6E686D1C) --------------------------------------------------------
void __thiscall CIsdnPage::DoJapanDlg(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  int v2; // eax@1
  int v3; // [sp+Ch] [bp-28h]@1
  int v4; // [sp+10h] [bp-24h]@1
  void *v5; // [sp+20h] [bp-14h]@1
  int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1

  v1 = this;
  v2 = *((_DWORD *)this + 6);
  v4 = 0;
  v5 = 0;
  v3 = (int)CJapanDlg::`vftable';
  v6 = v2;
  v7 = 0;
  *(_DWORD *)(v2 + 32) = 14118;
  if ( ATL::CDialogImpl<CJapanDlg>::DoModal(&v3, *((HWND *)this + 1)) )
  {
    *((_DWORD *)v1 + 2) = 1;
    CPropSheetPage::SetChangedFlag(v1);
  }
  v7 = -1;
  v3 = (int)CJapanDlg::`vftable';
  if ( v5 )
    ATL::__FreeStdCallThunk(v5);
}
// 6E65D580: using guessed type int (__thiscall *CJapanDlg::`vftable'[2])(CJapanDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686D88) --------------------------------------------------------
void __thiscall CIsdnPage::DoEazDlg(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  int v2; // eax@1
  int v3; // [sp+Ch] [bp-28h]@1
  int v4; // [sp+10h] [bp-24h]@1
  void *v5; // [sp+20h] [bp-14h]@1
  int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1

  v1 = this;
  v2 = *((_DWORD *)this + 6);
  v4 = 0;
  v5 = 0;
  v3 = (int)CEazDlg::`vftable';
  v6 = v2;
  v7 = 0;
  *(_DWORD *)(v2 + 32) = 14117;
  if ( ATL::CDialogImpl<CEazDlg>::DoModal(&v3, *((HWND *)this + 1)) )
  {
    *((_DWORD *)v1 + 2) = 1;
    CPropSheetPage::SetChangedFlag(v1);
  }
  v7 = -1;
  v3 = (int)CEazDlg::`vftable';
  if ( v5 )
    ATL::__FreeStdCallThunk(v5);
}
// 6E65D578: using guessed type int (__thiscall *CEazDlg::`vftable'[4])(CEazDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686DF4) --------------------------------------------------------
void __thiscall CIsdnPage::DoMsnDlg(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  int v2; // eax@1
  int v3; // [sp+Ch] [bp-2Ch]@1
  void *v4; // [sp+20h] [bp-18h]@3
  int v5; // [sp+34h] [bp-4h]@1

  v1 = this;
  CMsnDlg::CMsnDlg((CMsnDlg *)&v3, *((struct _ISDNConfigInfo **)this + 6));
  v2 = *((_DWORD *)v1 + 6);
  v5 = 0;
  *(_DWORD *)(v2 + 32) = 14119;
  if ( ATL::CDialogImpl<CMsnDlg>::DoModal(&v3, *((HWND *)v1 + 1)) )
  {
    *((_DWORD *)v1 + 2) = 1;
    CPropSheetPage::SetChangedFlag(v1);
  }
  v5 = -1;
  v3 = (int)CMsnDlg::`vftable';
  if ( v4 )
    ATL::__FreeStdCallThunk(v4);
}
// 6E65D57C: using guessed type int (__thiscall *CMsnDlg::`vftable'[3])(CMsnDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686E5C) --------------------------------------------------------
signed int __stdcall HrGetIsdnPage(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _PSP **a3)
{
  CIsdnPage *v3; // eax@1
  CIsdnPage *v4; // esi@2
  signed int result; // eax@5
  struct _PSP *v6; // eax@6
  signed int v7; // edi@7

  v3 = (CIsdnPage *)operator new(0x1Cu);
  if ( v3 )
    v4 = CIsdnPage::CIsdnPage(v3);
  else
    v4 = 0;
  if ( v4 )
  {
    v6 = CIsdnPage::CreatePage(v4, DeviceInfoSet, DeviceInfoData);
    if ( v6 )
    {
      *a3 = v6;
      v7 = 0;
    }
    else
    {
      *a3 = 0;
      v7 = -2147467259;
      (*(void (__thiscall **)(CIsdnPage *, signed int))(*(_DWORD *)v4 + 4))(v4, 1);
    }
    result = v7;
  }
  else
  {
    result = 8;
  }
  return result;
}

//----- (6E686EC0) --------------------------------------------------------
int __thiscall CSpidsDlg::ProcessWindowMessage(CSpidsDlg *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, ATL::CDialogImplBase *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  __int32 v9; // eax@7
  unsigned __int16 v10; // dx@12

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CSpidsDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a6);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 273 )
    {
      if ( 1 == (_WORD)a4 )
      {
        v9 = CJapanDlg::OnOk(this, HIWORD(a4), 1u, a5, (int *)&a6);
LABEL_8:
        *(_DWORD *)a6 = v9;
        return 1;
      }
      if ( 2 == (_WORD)a4 )
      {
        ATL::CDialogImplBase::EndDialog(this, 0);
        *(_DWORD *)a6 = 0;
        return 1;
      }
      v10 = 1010;
      if ( 1010 == (_WORD)a4 || (v10 = 1005, 1005 == (_WORD)a4) )
      {
        v9 = CSpidsDlg::OnSelChange(this, HIWORD(a4), v10, a5, (int *)&a6);
        goto LABEL_8;
      }
    }
    else if ( a3 == 83 )
    {
      v7 = CMsnDlg::OnHelp(this, 0x53u, a4, (struct tagHELPINFO *)a5, (int *)&a6);
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (6E686F8F) --------------------------------------------------------
void __thiscall CSpidsDlg::~CSpidsDlg(CSpidsDlg *this)
{
  void *v1; // ecx@1

  *(_DWORD *)this = &CSpidsDlg::`vftable';
  v1 = (void *)*((_DWORD *)this + 5);
  if ( v1 )
    ATL::__FreeStdCallThunk(v1);
}
// 6E65D584: using guessed type int (__thiscall *CSpidsDlg::`vftable')(CSpidsDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E686FA8) --------------------------------------------------------
void __thiscall CIsdnPage::DoSpidsDlg(CIsdnPage *this)
{
  CIsdnPage *v1; // esi@1
  int v2; // eax@1
  int (__thiscall **v3)(CSpidsDlg *, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32); // [sp+Ch] [bp-28h]@1
  int v4; // [sp+10h] [bp-24h]@1
  void *v5; // [sp+20h] [bp-14h]@1
  int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1

  v1 = this;
  v2 = *((_DWORD *)this + 6);
  v4 = 0;
  v5 = 0;
  v3 = &CSpidsDlg::`vftable';
  v6 = v2;
  v7 = 0;
  *(_DWORD *)(v2 + 32) = 1407;
  if ( ATL::CDialogImpl<CSpidsDlg>::DoModal(&v3, *((HWND *)this + 1)) )
  {
    *((_DWORD *)v1 + 2) = 1;
    CPropSheetPage::SetChangedFlag(v1);
  }
  v7 = -1;
  v3 = &CSpidsDlg::`vftable';
  if ( v5 )
    ATL::__FreeStdCallThunk(v5);
}
// 6E65D584: using guessed type int (__thiscall *CSpidsDlg::`vftable')(CSpidsDlg *this, HWND, unsigned int, unsigned int, HWND, ATL::CDialogImplBase *, unsigned __int32);

//----- (6E687014) --------------------------------------------------------
__int32 __thiscall CIsdnPage::OnConfigure(CIsdnPage *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CIsdnPage *v5; // esi@1
  unsigned __int32 v6; // eax@1
  int v7; // eax@3
  int v8; // eax@4
  int v9; // eax@5
  int v10; // eax@6
  int v11; // eax@7
  int v12; // eax@8
  bool v13; // zf@9
  CIsdnPage *v14; // ecx@11

  v5 = this;
  v6 = DwGetSwitchType(*((HWND *)this + 1), *((struct _ISDNConfigInfo **)this + 6), 1000);
  if ( v6 <= 0x80 )
  {
    if ( v6 == 128 )
    {
LABEL_21:
      CIsdnPage::DoMsnDlg(v5);
      return 0;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
LABEL_11:
      v14 = v5;
LABEL_12:
      CIsdnPage::DoEazDlg(v14);
      return 0;
    }
    v8 = v7 - 1;
    if ( v8 )
    {
      v9 = v8 - 2;
      if ( v9 )
      {
        v10 = v9 - 4;
        if ( v10 )
        {
          v11 = v10 - 8;
          if ( !v11 )
          {
            CIsdnPage::DoJapanDlg(v5);
            return 0;
          }
          v12 = v11 - 16;
          if ( v12 )
          {
            v13 = v12 == 32;
            goto LABEL_20;
          }
          goto LABEL_11;
        }
      }
    }
LABEL_23:
    v14 = v5;
    if ( !*(_DWORD *)(*((_DWORD *)v5 + 6) + 24) )
    {
      CIsdnPage::DoSpidsDlg(v5);
      return 0;
    }
    goto LABEL_12;
  }
  if ( v6 == 256 || v6 == 512 || v6 == 1024 )
    goto LABEL_21;
  if ( v6 == 2048 )
    goto LABEL_23;
  if ( v6 == 4096 || v6 == 0x2000 )
    goto LABEL_21;
  v13 = v6 == 0x4000;
LABEL_20:
  if ( v13 )
    goto LABEL_21;
  return 0;
}

//----- (6E6870B9) --------------------------------------------------------
int __thiscall CIsdnPage::ProcessWindowMessage(CIsdnPage *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, CIsdnPage *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CIsdnPage::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a5);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 78 )
    {
      if ( *((_DWORD *)a5 + 2) == -202 )
      {
        v7 = CIsdnPage::OnApply(this, a4, (struct tagNMHDR *)a5, (int *)&a5);
        goto LABEL_4;
      }
    }
    else if ( a3 == 273 )
    {
      if ( 1000 == (_WORD)a4 )
      {
        v7 = CIsdnPage::OnSwitchType(this, HIWORD(a4), 0x3E8u, a5, (int *)&a5);
        goto LABEL_4;
      }
      if ( 1011 == (_WORD)a4 )
      {
        v7 = CIsdnPage::OnConfigure(this, HIWORD(a4), 0x3F3u, a5, (int *)&a5);
        goto LABEL_4;
      }
    }
    else
    {
      if ( a3 == 83 )
      {
        v7 = CMsnDlg::OnHelp(this, 0x53u, a4, (struct tagHELPINFO *)a5, (int *)&a5);
        goto LABEL_4;
      }
      if ( a3 == 123 )
      {
        v7 = CIsdnPage::OnContextMenu(this, 0x7Bu, a4, (__int32)a5, (int *)&a5);
        goto LABEL_4;
      }
    }
  }
  return 0;
}

//----- (6E68719F) --------------------------------------------------------
int __stdcall FAdapterIsIsdn(HKEY a1)
{
  signed int v1; // esi@1
  unsigned __int32 v2; // ecx@1
  void *lpMem; // [sp+8h] [bp-18h]@2
  HKEY hKey; // [sp+Ch] [bp-14h]@1
  int v6; // [sp+10h] [bp-10h]@1
  int v7; // [sp+14h] [bp-Ch]@1
  wchar_t v8; // [sp+18h] [bp-8h]@1

  v6 = *(_DWORD *)L"isdn";
  v7 = *(_DWORD *)L"\u7300\u6400\u6e00";
  v8 = aIsdn[4];
  v1 = 0;
  if ( HrRegOpenKeyEx(a1, L"Ndi\\Interfaces", 0x20019u, &hKey) >= 0 )
  {
    if ( HrRegGetTypeWithAlloc(v2, hKey, L"LowerRange", 1u, (unsigned __int8 **)&lpMem, 0) >= 0 )
    {
      v1 = FFindStringInCommaSeparatedList((const WCHAR *)&v6, (const WCHAR *)lpMem, 0, 0);
      MemFree(lpMem);
    }
    RegCloseKey(hKey);
  }
  return v1;
}
// 6E687260: using guessed type wchar_t aIsdn[5];

//----- (6E68726F) --------------------------------------------------------
__int32 __stdcall HrAddIsdnWizardPagesIfAppropriate(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  DWORD v2; // ecx@1
  __int32 v3; // esi@1
  struct _ISDNConfigInfo *v5; // [sp+4h] [bp-8h]@3
  HKEY hKey; // [sp+8h] [bp-4h]@1

  hKey = 0;
  v3 = HrSetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, 1u, 0, 2u, 0x20019u, &hKey);
  if ( v3 >= 0 )
  {
    if ( FShowIsdnPages(v2, hKey) )
    {
      v3 = HrReadIsdnPropertiesInfo(hKey, DeviceInfoSet, DeviceInfoData, &v5);
      if ( v3 >= 0 && !*((_DWORD *)v5 + 3) )
        v3 = HrAddIsdnWizardPagesToDevice(DeviceInfoSet, DeviceInfoData, v5);
    }
  }
  RegSafeCloseKey(hKey);
  return v3;
}

//----- (6E6872EA) --------------------------------------------------------
__int32 __stdcall HrReadNthDChannelInfo(HKEY hKey, unsigned __int32 Value, DWORD Type)
{
  unsigned __int32 v3; // ecx@1
  __int32 v4; // ebx@1
  void *v5; // eax@3
  int v7; // eax@7
  HLOCAL v8; // eax@9
  int v9; // esi@13
  signed int v10; // [sp+Ch] [bp-44h]@1
  int v11; // [sp+10h] [bp-40h]@12
  int v12; // [sp+14h] [bp-3Ch]@11
  HKEY v13; // [sp+18h] [bp-38h]@1
  DWORD v14; // [sp+1Ch] [bp-34h]@14
  HKEY phkResult; // [sp+20h] [bp-30h]@1
  wchar_t Dest; // [sp+24h] [bp-2Ch]@1

  phkResult = 0;
  v13 = 0;
  v10 = 0;
  _itow(Value, &Dest, 10);
  v4 = HrRegOpenKeyEx(hKey, &Dest, 0x20019u, &phkResult);
  if ( v4 >= 0 )
  {
    if ( HrRegGetMultiSzWithAlloc(v3, phkResult, L"IsdnMultiSubscriberNumbers", (unsigned __int16 **)(Type + 4)) < 0 )
    {
      v5 = MemAlloc(2u);
      *(_DWORD *)(Type + 4) = v5;
      if ( !v5 )
      {
        RegSafeCloseKey(phkResult);
        return 8;
      }
      *(_WORD *)v5 = 0;
    }
    v4 = HrRegQueryDword(phkResult, L"IsdnNumBChannels", Type);
    if ( v4 >= 0 )
    {
      v7 = *(_DWORD *)Type;
      if ( *(_DWORD *)Type <= 0x32u && v7 )
      {
        v8 = LocalAlloc(0x40u, 774 * v7);
        *(_DWORD *)(Type + 8) = v8;
        if ( v8 )
        {
          memset(v8, 0, 774 * *(_DWORD *)Type);
          v12 = 0;
          if ( *(_DWORD *)Type > 0u )
          {
            v11 = 0;
            do
            {
              v9 = v11 + *(_DWORD *)(Type + 8);
              _itow(v12, &Dest, 10);
              if ( HrRegOpenKeyEx(phkResult, &Dest, 0x20019u, &v13) < 0 )
              {
                v4 = 0;
                v10 = 1;
                *(_WORD *)v9 = 0;
                *(_WORD *)(v9 + 258) = 0;
              }
              else
              {
                v14 = 258;
                HrRegQueryTypeSzBuffer(v13, L"IsdnSpid", 1u, (LPBYTE)v9, (DWORD)&v14);
                v14 = 258;
                HrRegQueryTypeSzBuffer(v13, L"IsdnPhoneNumber", 1u, (LPBYTE)(v9 + 258), (DWORD)&v14);
                v14 = 258;
                v4 = HrRegQueryTypeSzBuffer(v13, L"IsdnSubaddress", 1u, (LPBYTE)(v9 + 516), (DWORD)&v14);
                if ( v4 < 0 )
                  v4 = 0;
              }
              RegSafeCloseKey(v13);
              ++v12;
              v11 += 774;
            }
            while ( (unsigned int)v12 < *(_DWORD *)Type );
          }
        }
        else
        {
          v4 = HrFromLastWin32Error();
        }
      }
      else
      {
        v4 = -2147024883;
      }
    }
  }
  RegSafeCloseKey(phkResult);
  if ( v4 >= 0 )
  {
    if ( v10 )
      v4 = 1;
  }
  else
  {
    LocalFree(*(HLOCAL *)(Type + 8));
    *(_DWORD *)(Type + 8) = 0;
  }
  return v4;
}

//----- (6E687511) --------------------------------------------------------
__int32 __stdcall HrReadDChannelsInfo(HKEY hKey, unsigned __int32 a2, struct _ISDNDChannel **a3)
{
  unsigned __int32 v3; // esi@1
  HLOCAL v4; // eax@1
  struct _ISDNDChannel *v5; // ebx@1
  DWORD v6; // edi@4
  int v7; // esi@12
  signed int v9; // [sp+Ch] [bp-8h]@1
  __int32 v10; // [sp+10h] [bp-4h]@1

  v3 = 0;
  v10 = -2147467259;
  v9 = 0;
  v4 = LocalAlloc(0x40u, 12 * a2);
  v5 = (struct _ISDNDChannel *)v4;
  if ( v4 )
  {
    if ( a2 > 0 )
    {
      v6 = (DWORD)v4;
      while ( 1 )
      {
        v10 = HrReadNthDChannelInfo(hKey, v3, v6);
        if ( v10 < 0 )
          break;
        if ( v10 == 1 )
          v9 = 1;
        ++v3;
        v6 += 12;
        if ( v3 >= a2 )
          goto LABEL_9;
      }
    }
  }
  else
  {
    v10 = HrFromLastWin32Error();
LABEL_9:
    if ( v10 >= 0 )
    {
      *a3 = v5;
      goto LABEL_18;
    }
  }
  if ( v5 )
  {
    if ( a2 )
    {
      v7 = (int)((char *)v5 + 4);
      do
      {
        LocalFree(*(HLOCAL *)(v7 + 4));
        if ( *(_DWORD *)v7 )
          MemFree(*(void **)v7);
        v7 += 12;
        --a2;
      }
      while ( a2 );
    }
    LocalFree((HLOCAL)v5);
    *a3 = 0;
  }
LABEL_18:
  if ( v10 >= 0 && v9 )
    v10 = 1;
  return v10;
}

//----- (6E6875DC) --------------------------------------------------------
__int32 __stdcall HrReadIsdnPropertiesInfo(HKEY hKey, void *a2, struct _SP_DEVINFO_DATA *a3, struct _ISDNConfigInfo **a4)
{
  HLOCAL v4; // eax@1
  DWORD v5; // esi@1
  __int32 v6; // ebx@2
  unsigned __int32 *v7; // edi@4
  HKEY hKeya; // [sp+14h] [bp+8h]@18
  void *v10; // [sp+18h] [bp+Ch]@17

  v4 = LocalAlloc(0x40u, 0x30u);
  v5 = (DWORD)v4;
  if ( !v4 )
  {
    v6 = HrFromLastWin32Error();
    goto LABEL_14;
  }
  memset(v4, 0, 0x30u);
  *(_DWORD *)(v5 + 40) = a2;
  *(_DWORD *)(v5 + 44) = a3;
  v6 = HrRegQueryDword(hKey, L"WanEndpoints", v5);
  if ( v6 >= 0 )
  {
    v7 = (unsigned __int32 *)(v5 + 4);
    v6 = HrRegQueryDword(hKey, L"IsdnNumDChannels", v5 + 4);
    if ( v6 >= 0 )
    {
      if ( *v7 > 0x10 || !*v7 )
      {
        *v7 = 0;
        v6 = -2147024883;
LABEL_14:
        if ( v6 < 0 )
          goto LABEL_15;
LABEL_11:
        *a4 = (struct _ISDNConfigInfo *)v5;
        return v6;
      }
      v6 = HrRegQueryDword(hKey, L"IsdnSwitchTypes", v5 + 8);
      if ( v6 >= 0 )
      {
        v6 = HrReadDChannelsInfo(hKey, *v7, (struct _ISDNDChannel **)(v5 + 36));
        if ( v6 >= 0 )
        {
          *(_DWORD *)(v5 + 24) = **(_DWORD **)(v5 + 36) > 2u;
          v6 = HrRegQueryDword(hKey, L"IsdnSwitchType", v5 + 12);
          if ( v6 < 0 )
            v6 = 0;
          goto LABEL_11;
        }
      }
    }
  }
LABEL_15:
  if ( v5 )
  {
    if ( *(_DWORD *)(v5 + 36) )
    {
      v10 = 0;
      if ( *(_DWORD *)(v5 + 4) )
      {
        hKeya = 0;
        do
        {
          LocalFree(*(HLOCAL *)((char *)hKeya + *(_DWORD *)(v5 + 36) + 8));
          v10 = (char *)v10 + 1;
          hKeya += 3;
        }
        while ( (unsigned int)v10 < *(_DWORD *)(v5 + 4) );
      }
      LocalFree(*(HLOCAL *)(v5 + 36));
    }
    LocalFree((HLOCAL)v5);
    *a4 = 0;
  }
  return v6;
}

//----- (6E68776D) --------------------------------------------------------
__int32 __stdcall HrWriteIsdnPropertiesInfo(HKEY a1, struct _ISDNConfigInfo *a2)
{
  struct _ISDNConfigInfo *v2; // edi@1
  int v3; // ST18_4@1
  __int32 v4; // ebx@1
  int v5; // esi@4
  int v6; // edi@8
  int Value; // [sp+14h] [bp-40h]@0
  int v9; // [sp+18h] [bp-3Ch]@7
  HKEY phkResult; // [sp+1Ch] [bp-38h]@1
  int v11; // [sp+20h] [bp-34h]@6
  HKEY v12; // [sp+24h] [bp-30h]@1
  wchar_t Dest; // [sp+28h] [bp-2Ch]@4

  v2 = a2;
  v3 = *((_DWORD *)a2 + 3);
  phkResult = 0;
  v12 = 0;
  v4 = HrRegSetDword(a1, L"IsdnSwitchType", v3);
  if ( v4 < 0 )
    goto LABEL_15;
  for ( Value = 0; ; ++Value )
  {
    if ( (unsigned int)Value < *((_DWORD *)v2 + 1) )
    {
      v5 = *((_DWORD *)v2 + 9) + 12 * Value;
      _itow(Value, &Dest, 10);
      v4 = HrRegOpenKeyEx(a1, &Dest, 0x20006u, &phkResult);
      if ( v4 >= 0 )
      {
        v4 = HrRegSetMultiSz(phkResult, L"IsdnMultiSubscriberNumbers", *(BYTE **)(v5 + 4));
        if ( v4 >= 0 )
        {
          v11 = 0;
          if ( *(_DWORD *)v5 )
          {
            v9 = 0;
            do
            {
              v6 = v9 + *(_DWORD *)(v5 + 8);
              _itow(v11, &Dest, 10);
              v4 = HrRegCreateKeyEx(phkResult, &Dest, 0, 0x20006u, 0, &v12, 0);
              if ( v4 >= 0 )
              {
                v4 = HrRegSetSz(v12, L"IsdnSpid", (BYTE *)v6);
                if ( v4 >= 0 )
                {
                  v4 = HrRegSetSz(v12, L"IsdnPhoneNumber", (BYTE *)(v6 + 258));
                  if ( v4 >= 0 )
                    v4 = HrRegSetSz(v12, L"IsdnSubaddress", (BYTE *)(v6 + 516));
                }
              }
              RegSafeCloseKey(v12);
              if ( v4 < 0 )
                break;
              ++v11;
              v9 += 774;
            }
            while ( (unsigned int)v11 < *(_DWORD *)v5 );
            v2 = a2;
          }
        }
      }
LABEL_15:
      RegSafeCloseKey(phkResult);
      if ( v4 >= 0 )
        continue;
    }
    break;
  }
  return v4;
}

//----- (6E6878E9) --------------------------------------------------------
void __stdcall FreeIsdnPropertiesInfo(HLOCAL hMem)
{
  HLOCAL v1; // esi@1
  int v2; // edi@1
  HLOCAL hMema; // [sp+10h] [bp+8h]@3

  v1 = hMem;
  v2 = 0;
  if ( hMem )
  {
    if ( *((_DWORD *)hMem + 9) )
    {
      hMema = 0;
      if ( *((_DWORD *)v1 + 1) > 0u )
      {
        do
        {
          LocalFree(*(HLOCAL *)(*((_DWORD *)v1 + 9) + v2 + 8));
          operator delete(*(void **)(*((_DWORD *)v1 + 9) + v2 + 4));
          hMema = (char *)hMema + 1;
          v2 += 12;
        }
        while ( (unsigned int)hMema < *((_DWORD *)v1 + 1) );
      }
      LocalFree(*((HLOCAL *)v1 + 9));
    }
    LocalFree(v1);
  }
}

//----- (6E687945) --------------------------------------------------------
int __thiscall FShowIsdnPages(DWORD this, HKEY hKey)
{
  int result; // eax@2
  DWORD Type; // [sp+0h] [bp-4h]@1

  Type = this;
  if ( HrRegQueryDword(hKey, L"ShowIsdnPages", (DWORD)&Type) < 0 )
    result = FAdapterIsIsdn(hKey);
  else
    result = Type != 0;
  return result;
}

//----- (6E68799D) --------------------------------------------------------
void __stdcall CheckShowPagesFlag(struct _ISDNConfigInfo *a1)
{
  DWORD v1; // ecx@1
  HKEY hKey; // [sp+4h] [bp-4h]@1

  hKey = 0;
  if ( HrSetupDiOpenDevRegKey(*((HDEVINFO *)a1 + 10), *((PSP_DEVINFO_DATA *)a1 + 11), 1u, 0, 2u, 0x20019u, &hKey) >= 0 )
  {
    if ( !FShowIsdnPages(v1, hKey) )
      *((_DWORD *)a1 + 7) = 1;
    RegCloseKey(hKey);
  }
}

//----- (6E6879EF) --------------------------------------------------------
void __stdcall SetWizardButtons(HWND hDlg, char a2, struct _ISDNConfigInfo *a3)
{
  HWND v3; // eax@1

  v3 = GetDlgItem(hDlg, 2);
  EnableWindow(v3, 1);
  if ( a2 )
    PostMessageW(hDlg, 0x470u, 0, 2);
  else
    PostMessageW(hDlg, 0x470u, 0, 3);
}

//----- (6E687A2D) --------------------------------------------------------
unsigned __int32 __stdcall DwGetSwitchType(HWND hDlg, struct _ISDNConfigInfo *a2, int nIDDlgItem)
{
  LRESULT v3; // eax@1

  v3 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x147u, 0, 0);
  return *(&dword_6E65D638 + 2 * SendDlgItemMessageW(hDlg, nIDDlgItem, 0x150u, v3, 0));
}

//----- (6E687A6B) --------------------------------------------------------
void __stdcall OnIsdnSwitchTypeWizNext(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  signed int v2; // edi@1
  unsigned __int32 v3; // eax@1
  int v4; // eax@3
  int v5; // eax@4
  int v6; // eax@5
  int v7; // eax@6
  int v8; // eax@7
  int v9; // eax@8
  bool v10; // zf@9

  v2 = 0;
  v3 = DwGetSwitchType(hDlg, a2, 1000);
  *((_DWORD *)a2 + 3) = v3;
  if ( v3 <= 0x80 )
  {
    if ( v3 == 128 )
    {
LABEL_22:
      v2 = 14114;
      goto LABEL_23;
    }
    v4 = v3 - 1;
    if ( !v4 )
    {
      if ( *((_DWORD *)a2 + 6) )
        *((_DWORD *)a2 + 7) = 1;
      goto LABEL_13;
    }
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 2;
      if ( v6 )
      {
        v7 = v6 - 4;
        if ( v7 )
        {
          v8 = v7 - 8;
          if ( !v8 )
          {
            v2 = 14113;
            goto LABEL_23;
          }
          v9 = v8 - 16;
          if ( v9 )
          {
            v10 = v9 == 32;
            goto LABEL_21;
          }
LABEL_13:
          v2 = 14115;
          goto LABEL_23;
        }
      }
    }
LABEL_24:
    if ( *((_DWORD *)a2 + 6) )
    {
      v2 = 14115;
      *((_DWORD *)a2 + 7) = 1;
    }
    else
    {
      v2 = 14112;
    }
    goto LABEL_23;
  }
  if ( v3 == 256 || v3 == 512 || v3 == 1024 )
    goto LABEL_22;
  if ( v3 == 2048 )
    goto LABEL_24;
  if ( v3 == 4096 || v3 == 0x2000 )
    goto LABEL_22;
  v10 = v3 == 0x4000;
LABEL_21:
  if ( v10 )
    goto LABEL_22;
LABEL_23:
  *((_DWORD *)a2 + 8) = v2;
}

//----- (6E687B29) --------------------------------------------------------
void __stdcall SetSwitchType(HWND hDlg, int nIDDlgItem, unsigned __int32 a3)
{
  WPARAM v3; // edi@1
  LRESULT v4; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x146u, 0, 0);
  if ( v4 > 0 )
  {
    while ( *(&dword_6E65D638 + 2 * SendDlgItemMessageW(hDlg, nIDDlgItem, 0x150u, v3, 0)) != a3 )
    {
      ++v3;
      if ( (signed int)v3 >= v4 )
        return;
    }
    SendDlgItemMessageW(hDlg, nIDDlgItem, 0x14Eu, v3, 0);
  }
}

//----- (6E687B90) --------------------------------------------------------
signed int __stdcall OnIsdnInfoPageSetActive(HWND hWnd, struct _ISDNConfigInfo *a2)
{
  HWND v2; // eax@3
  HWND v3; // eax@3
  signed int result; // eax@3

  if ( *((_DWORD *)a2 + 8) != GetWindowLongW(hWnd, 8) || *((_DWORD *)a2 + 7) )
  {
    result = -1;
  }
  else
  {
    v2 = GetParent(hWnd);
    SetWizardButtons(v2, 0, 0);
    v3 = GetDlgItem(hWnd, 1008);
    SetFocus(v3);
    *((_DWORD *)a2 + 5) = SendDlgItemMessageW(hWnd, 1010, 0x188u, 0, 0);
    *((_DWORD *)a2 + 4) = SendDlgItemMessageW(hWnd, 1005, 0x188u, 0, 0);
    result = 0;
  }
  return result;
}

//----- (6E687C13) --------------------------------------------------------
void __stdcall OnIsdnInfoPageApply(HWND a1, HKEY hKey)
{
  HKEY v2; // esi@1

  v2 = hKey;
  if ( HrSetupDiOpenDevRegKey(*((HDEVINFO *)hKey + 10), *((PSP_DEVINFO_DATA *)hKey + 11), 1u, 0, 2u, 0xF003Fu, &hKey) >= 0 )
  {
    if ( HrWriteIsdnPropertiesInfo(hKey, (struct _ISDNConfigInfo *)v2) >= 0 )
      HrSetupDiSendPropertyChangeNotification(*((HDEVINFO *)v2 + 10), *((PSP_DEVINFO_DATA *)v2 + 11), 3u, 1u, 0);
    RegCloseKey(hKey);
  }
}

//----- (6E687C6B) --------------------------------------------------------
void __stdcall GetDataFromListBox(WPARAM wParam, HWND hDlg, struct _ISDNConfigInfo *a3)
{
  WPARAM v3; // esi@1
  LRESULT v4; // eax@2
  void *v5; // eax@3
  LPARAM v6; // esi@4
  int v7; // [sp+Ch] [bp-4h]@1
  WPARAM wParama; // [sp+18h] [bp+8h]@1
  WPARAM wParamb; // [sp+18h] [bp+8h]@4
  LRESULT v10; // [sp+20h] [bp+10h]@1

  v3 = *((_DWORD *)a3 + 9) + 12 * wParam;
  v7 = 0;
  wParama = 0;
  v10 = SendDlgItemMessageW(hDlg, 1014, 0x18Bu, 0, 0);
  if ( v10 > 0 )
  {
    do
    {
      v4 = SendDlgItemMessageW(hDlg, 1014, 0x18Au, wParama++, 0);
      v7 += v4 + 1;
    }
    while ( (signed int)wParama < v10 );
  }
  operator delete(*(void **)(v3 + 4));
  v5 = operator new(2 * (v7 + 1));
  *(_DWORD *)(v3 + 4) = v5;
  if ( v5 )
  {
    wParamb = 0;
    v6 = (LPARAM)v5;
    if ( v10 > 0 )
    {
      do
      {
        SendDlgItemMessageW(hDlg, 1014, 0x189u, wParamb++, v6);
        v6 += 2 * lstrlenW((LPCWSTR)v6) + 2;
      }
      while ( (signed int)wParamb < v10 );
    }
    *(_WORD *)v6 = 0;
  }
}

//----- (6E687D38) --------------------------------------------------------
void __stdcall SetDataToListBox(int a1, HWND hDlg, struct _ISDNConfigInfo *a3)
{
  int v3; // esi@1
  LPARAM i; // esi@1

  v3 = *((_DWORD *)a3 + 9) + 12 * a1;
  SendDlgItemMessageW(hDlg, 1014, 0x184u, 0, 0);
  for ( i = *(_DWORD *)(v3 + 4); *(_WORD *)i; i += 2 * lstrlenW((LPCWSTR)i) + 2 )
    SendDlgItemMessageW(hDlg, 1014, 0x180u, 0, i);
  SendDlgItemMessageW(hDlg, 1014, 0x186u, 0, 0);
}

//----- (6E687DA5) --------------------------------------------------------
void __stdcall OnMsnPageSelChange(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  HWND v2; // ebx@1
  HWND v3; // eax@1
  LRESULT v4; // eax@1
  HWND v5; // eax@3
  LONG dwNewLong; // [sp+Ch] [bp-4h]@1
  LONG hDlga; // [sp+18h] [bp+8h]@1

  v2 = hDlg;
  v3 = GetDlgItem(hDlg, 1001);
  hDlga = GetWindowLongW(v3, -21);
  v4 = SendDlgItemMessageW(v2, 1005, 0x188u, 0, 0);
  dwNewLong = v4;
  if ( v4 != -1 && v4 != hDlga )
  {
    GetDataFromListBox(hDlga, v2, a2);
    SetDataToListBox(dwNewLong, v2, a2);
    v5 = GetDlgItem(v2, 1001);
    SetWindowLongW(v5, -21, dwNewLong);
  }
}

//----- (6E687E22) --------------------------------------------------------
void __stdcall OnMsnPageAdd(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  LRESULT v2; // eax@1
  HWND v3; // eax@1
  HWND v4; // eax@1
  WCHAR String; // [sp+Ch] [bp-108h]@1

  GetDlgItemTextW(hDlg, 1001, &String, 129);
  v2 = SendDlgItemMessageW(hDlg, 1014, 0x180u, 0, (LPARAM)&String);
  SendDlgItemMessageW(hDlg, 1014, 0x186u, v2, 0);
  v3 = GetDlgItem(hDlg, 1003);
  EnableWindow(v3, 1);
  SetDlgItemTextW(hDlg, 1001, &c_szEmpty);
  v4 = GetDlgItem(hDlg, 1001);
  SetFocus(v4);
}

//----- (6E687ECB) --------------------------------------------------------
void __stdcall OnMsnPageRemove(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  LRESULT v2; // eax@1
  WPARAM v3; // ebx@1
  LRESULT v4; // eax@2
  HWND v5; // eax@6
  HWND v6; // eax@6

  v2 = SendDlgItemMessageW(hDlg, 1014, 0x188u, 0, 0);
  v3 = v2;
  if ( v2 != -1 )
  {
    v4 = SendDlgItemMessageW(hDlg, 1014, 0x182u, v2, 0);
    if ( v4 )
    {
      if ( v3 == v4 )
        --v3;
      SendDlgItemMessageW(hDlg, 1014, 0x186u, v3, 0);
    }
    else
    {
      v5 = GetDlgItem(hDlg, 1003);
      EnableWindow(v5, 0);
      v6 = GetDlgItem(hDlg, 1001);
      SetFocus(v6);
    }
  }
}

//----- (6E687F51) --------------------------------------------------------
void __stdcall OnMsnPageEditSelChange(HWND hWnd, struct _ISDNConfigInfo *a2)
{
  LRESULT v2; // eax@1
  HWND v3; // eax@3
  HWND v4; // eax@4
  HWND v5; // eax@5
  int v6; // [sp-10h] [bp-1Ch]@4

  v2 = SendMessageW(hWnd, 0x400u, 0, 0);
  if ( HIWORD(v2) == 21323 )
    SendDlgItemMessageW(hWnd, (unsigned __int16)v2, 0xF4u, 0, 1);
  v3 = GetDlgItem(hWnd, 1001);
  if ( GetWindowTextLengthW(v3) )
  {
    v4 = GetDlgItem(hWnd, 1002);
    EnableWindow(v4, 1);
    SendMessageW(hWnd, 0x401u, 0x3EAu, 0);
    v6 = 1002;
  }
  else
  {
    v5 = GetDlgItem(hWnd, 1002);
    EnableWindow(v5, 0);
    SendMessageW(hWnd, 0x401u, 1u, 0);
    v6 = 1;
  }
  SendDlgItemMessageW(hWnd, v6, 0xF4u, 1u, 1);
}

//----- (6E68801C) --------------------------------------------------------
void __stdcall SetDataToEditControls(HWND hDlg, int nIDDlgItem, int a3, struct _ISDNConfigInfo *a4, LPCWSTR lpString)
{
  LPCWSTR v5; // edi@7

  if ( *((_DWORD *)a4 + 8) == 1407 || *((_DWORD *)a4 + 8) == 14112 )
  {
    v5 = lpString;
    SetDlgItemTextW(hDlg, a3, lpString);
  }
  else
  {
    if ( *((_DWORD *)a4 + 8) != 14113 )
    {
      if ( *((_DWORD *)a4 + 8) == 14115 || *((_DWORD *)a4 + 8) == 14117 )
      {
        SetDlgItemTextW(hDlg, nIDDlgItem, lpString + 129);
        return;
      }
      if ( *((_DWORD *)a4 + 8) != 14118 )
        return;
    }
    v5 = lpString;
    SetDlgItemTextW(hDlg, a3, lpString + 258);
  }
  SetDlgItemTextW(hDlg, nIDDlgItem, v5 + 129);
}

//----- (6E688094) --------------------------------------------------------
void __stdcall GetDataFromEditControls(HWND hDlg, int nIDDlgItem, int a3, struct _ISDNConfigInfo *a4, LPWSTR lpString)
{
  LPWSTR v5; // ebx@7
  WCHAR *v6; // [sp-8h] [bp-14h]@7

  if ( *((_DWORD *)a4 + 8) == 1407 || *((_DWORD *)a4 + 8) == 14112 )
  {
    v5 = lpString;
    v6 = lpString;
  }
  else
  {
    if ( *((_DWORD *)a4 + 8) != 14113 )
    {
      if ( *((_DWORD *)a4 + 8) == 14115 || *((_DWORD *)a4 + 8) == 14117 )
      {
        GetDlgItemTextW(hDlg, nIDDlgItem, lpString + 129, 129);
        return;
      }
      if ( *((_DWORD *)a4 + 8) != 14118 )
        return;
    }
    v5 = lpString;
    v6 = lpString + 258;
  }
  GetDlgItemTextW(hDlg, a3, v6, 129);
  GetDlgItemTextW(hDlg, nIDDlgItem, v5 + 129, 129);
}

//----- (6E688120) --------------------------------------------------------
void __stdcall SetModifiedIsdnChannelInfo(HWND hDlg, int a2, int a3, int nIDDlgItem, WPARAM wParam, struct _ISDNConfigInfo *a6)
{
  LRESULT v6; // eax@1

  v6 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x199u, wParam, 0);
  GetDataFromEditControls(hDlg, a3, a2, a6, (LPWSTR)v6);
}

//----- (6E688156) --------------------------------------------------------
unsigned __int32 __stdcall DwGetCurrentCountryCode()
{
  WCHAR LCData; // [sp+0h] [bp-18h]@1

  GetLocaleInfoW(0x800u, 5u, &LCData, 10);
  return wcstoul(&LCData, 0, 10);
}

//----- (6E68819C) --------------------------------------------------------
char __stdcall FIsDefaultForLocale(unsigned __int32 a1, unsigned __int32 a2)
{
  bool v2; // cf@9
  bool v3; // zf@9
  bool v6; // zf@24

  if ( a1 > 0x162 )
  {
    if ( a1 > 0x182 )
    {
      if ( a1 == 389 )
        return a2 == 128;
      if ( a1 <= 0x1A3 )
        return 0;
      if ( a1 <= 0x1A5 || a1 == 852 )
        return a2 == 128;
      v6 = a1 == 886;
    }
    else
    {
      if ( a1 >= 0x181 )
        return a2 == 128;
      if ( a1 < 0x166 )
        return 0;
      if ( a1 <= 0x167 || a1 == 370 || a1 == 374 )
        return a2 == 128;
      v6 = a1 == 381;
    }
    goto LABEL_38;
  }
  if ( a1 >= 0x160 )
    return a2 == 128;
  if ( a1 > 0x31 )
  {
    if ( a1 == 61 || a1 == 64 )
      return a2 == 128;
    if ( a1 == 81 )
      return a2 == 16;
    v6 = a1 == 86;
LABEL_38:
    if ( v6 )
      return a2 == 128;
    return 0;
  }
  if ( a1 == 49 )
    return a2 == 128;
  if ( a1 <= 0x24 )
  {
    if ( a1 != 36 )
    {
      if ( a1 == 1 )
      {
        if ( a2 == 4 || a2 == 2048 )
          return 1;
      }
      else if ( a1 > 0x1D )
      {
        v2 = a1 < 0x22;
        v3 = a1 == 34;
        goto LABEL_10;
      }
      return 0;
    }
    return a2 == 128;
  }
  if ( a1 >= 0x27 )
  {
    if ( a1 <= 0x29 )
      return a2 == 128;
    if ( a1 > 0x2A )
    {
      v2 = a1 < 0x2F;
      v3 = a1 == 47;
LABEL_10:
      if ( v2 || v3 )
        return a2 == 128;
      return 0;
    }
  }
  return 0;
}

//----- (6E6882B3) --------------------------------------------------------
signed int __stdcall DestroyWizardData(HWND a1, unsigned int a2, struct _PROPSHEETPAGEW *a3)
{
  LPARAM v3; // esi@2

  if ( a2 == 1 )
  {
    v3 = a3->lParam;
    if ( *(_DWORD *)(v3 + 4) == 14120 )
      FreeIsdnPropertiesInfo(*(HLOCAL *)v3);
    operator delete((void *)v3);
  }
  return 1;
}

//----- (6E6882E9) --------------------------------------------------------
signed int __stdcall OnIsdnSwitchTypeSetActive(HWND hWnd, struct _ISDNConfigInfo *a2)
{
  signed int result; // eax@2
  HWND v3; // eax@3

  CheckShowPagesFlag(a2);
  if ( *((_DWORD *)a2 + 7) )
  {
    result = -1;
  }
  else
  {
    v3 = GetParent(hWnd);
    SetWizardButtons(v3, 1, a2);
    result = 0;
  }
  return result;
}

//----- (6E688321) --------------------------------------------------------
void __stdcall PopulateIsdnSwitchTypes(HWND hDlg, int nIDDlgItem, struct _ISDNConfigInfo *a3)
{
  LPARAM v3; // edi@1
  unsigned __int32 v4; // ebx@1
  LPARAM v5; // eax@3
  LRESULT v6; // eax@3
  int v7; // eax@3
  unsigned __int32 v8; // ecx@3
  unsigned __int32 v9; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v9 = 0;
  v4 = DwGetCurrentCountryCode();
  do
  {
    if ( *((_DWORD *)a3 + 2) & *(&dword_6E65D638 + 2 * v3) )
    {
      v5 = (LPARAM)SzLoadIds(*(&dword_6E65D63C + 2 * v3));
      v6 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x143u, 0, v5);
      SendDlgItemMessageW(hDlg, nIDDlgItem, 0x151u, v6, v3);
      LOBYTE(v7) = FIsDefaultForLocale(v4, *(&dword_6E65D638 + 2 * v3));
      if ( v7 || !v9 )
        v9 = v8;
    }
    ++v3;
  }
  while ( v3 < 15 );
  SetSwitchType(hDlg, 1000, v9);
}

//----- (6E6883B2) --------------------------------------------------------
void __stdcall RetrieveIsdnChannelInfo(HWND hDlg, int a2, int a3, int nIDDlgItem, struct _ISDNConfigInfo *a5, unsigned __int32 a6, WPARAM a7)
{
  void (__stdcall *v7)(HWND, int, UINT, WPARAM, LPARAM); // ebx@1
  LRESULT v8; // eax@1
  unsigned __int32 v9; // esi@1
  LRESULT v10; // ST24_4@7
  LRESULT v11; // [sp+10h] [bp-1Ch]@1
  unsigned __int32 v12; // [sp+14h] [bp-18h]@6
  WPARAM wParam; // [sp+1Ch] [bp-10h]@2
  LPARAM lParam; // [sp+20h] [bp-Ch]@6

  SetModifiedIsdnChannelInfo(hDlg, a2, a3, nIDDlgItem, a7, a5);
  v7 = (void (__stdcall *)(HWND, int, UINT, WPARAM, LPARAM))SendDlgItemMessageW;
  v8 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x18Bu, 0, 0);
  v9 = 12 * a6;
  v11 = v8;
  if ( v8 == *(_DWORD *)(12 * a6 + *((_DWORD *)a5 + 9)) )
  {
    wParam = 0;
    if ( v8 )
    {
      while ( (unsigned int)((LRESULT (__stdcall *)(HWND, int, UINT, WPARAM, LPARAM))v7)(
                              hDlg,
                              nIDDlgItem,
                              0x18Au,
                              wParam,
                              0) <= 3 )
      {
        v7(hDlg, nIDDlgItem, 0x189u, wParam, (LPARAM)&lParam);
        v12 = wcstoul((const wchar_t *)&lParam, 0, 10) - 1;
        if ( v12 >= *(_DWORD *)(v9 + *((_DWORD *)a5 + 9)) )
          break;
        v10 = ((LRESULT (__stdcall *)(HWND, int, UINT, WPARAM, LPARAM))v7)(hDlg, nIDDlgItem, 0x199u, wParam, 0);
        StringCchCopyW(
          (unsigned __int16 *)(774 * v12 + *(_DWORD *)(v9 + *((_DWORD *)a5 + 9) + 8)),
          0x81u,
          (const unsigned __int16 *)v10);
        StringCchCopyW(
          (unsigned __int16 *)(*(_DWORD *)(v9 + *((_DWORD *)a5 + 9) + 8) + 774 * v12 + 258),
          0x81u,
          (const unsigned __int16 *)(v10 + 258));
        ++wParam;
        if ( wParam >= v11 )
          break;
        v7 = (void (__stdcall *)(HWND, int, UINT, WPARAM, LPARAM))SendDlgItemMessageW;
      }
    }
  }
}

//----- (6E6884E5) --------------------------------------------------------
void __stdcall SetCurrentIsdnChannelSelection(HWND hDlg, int a2, int a3, int nIDDlgItem, struct _ISDNConfigInfo *a5, unsigned __int32 a6, int *a7)
{
  LRESULT v7; // eax@1
  LRESULT v8; // eax@1

  v7 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x188u, 0, 0);
  *a7 = v7;
  v8 = SendDlgItemMessageW(hDlg, nIDDlgItem, 0x199u, v7, 0);
  SetDataToEditControls(hDlg, a3, a2, a5, (LPCWSTR)v8);
}

//----- (6E688533) --------------------------------------------------------
void __stdcall PopulateIsdnChannels(HWND hDlg, int nIDDlgItem, int a3, int a4, int a5, struct _ISDNConfigInfo *a6)
{
  int v6; // eax@1
  int v7; // ST30_4@2
  LRESULT v8; // eax@4
  int v9; // [sp+Ch] [bp-20h]@4
  LPARAM lpString; // [sp+10h] [bp-1Ch]@5
  int v11; // [sp+18h] [bp-14h]@3
  int v12; // [sp+1Ch] [bp-10h]@3
  LPARAM lParam; // [sp+20h] [bp-Ch]@2

  SendDlgItemMessageW(hDlg, nIDDlgItem, 0xC5u, 0x80u, 0);
  SendDlgItemMessageW(hDlg, a3, 0xC5u, 0x80u, 0);
  SendDlgItemMessageW(hDlg, a4, 0x184u, 0, 0);
  v6 = 0;
  if ( *((_DWORD *)a6 + 1) > 0u )
  {
    do
    {
      v7 = v6 + 1;
      StringCchPrintfW((wchar_t *)&lParam, 4u, L"%d", v6 + 1);
      SendDlgItemMessageW(hDlg, a4, 0x180u, 0, (LPARAM)&lParam);
      v6 = v7;
    }
    while ( (unsigned int)v7 < *((_DWORD *)a6 + 1) );
  }
  v12 = *((_DWORD *)a6 + 9);
  SendDlgItemMessageW(hDlg, a5, 0x184u, 0, 0);
  v11 = 0;
  if ( *(_DWORD *)v12 <= 0u )
  {
LABEL_8:
    SendDlgItemMessageW(hDlg, a5, 0x186u, 0, 0);
    SendDlgItemMessageW(hDlg, a4, 0x186u, 0, 0);
  }
  else
  {
    while ( 1 )
    {
      v9 = v11 + 1;
      StringCchPrintfW((wchar_t *)&lParam, 4u, L"%d", v11 + 1);
      v8 = SendDlgItemMessageW(hDlg, a5, 0x180u, 0, (LPARAM)&lParam);
      if ( v8 == -1 )
        break;
      lpString = *(_DWORD *)(v12 + 8) + 774 * v11;
      SendDlgItemMessageW(hDlg, a5, 0x19Au, v8, lpString);
      if ( !v11 )
        SetDataToEditControls(hDlg, a3, nIDDlgItem, a6, (LPCWSTR)lpString);
      ++v11;
      if ( (unsigned int)v9 >= *(_DWORD *)v12 )
        goto LABEL_8;
    }
  }
}

//----- (6E688688) --------------------------------------------------------
void __stdcall OnIsdnSwitchTypeInit(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  PopulateIsdnSwitchTypes(hDlg, 1000, a2);
  *((_DWORD *)a2 + 4) = SendDlgItemMessageW(hDlg, 1005, 0x188u, 0, 0);
  *((_DWORD *)a2 + 5) = SendDlgItemMessageW(hDlg, 1010, 0x188u, 0, 0);
}

//----- (6E6886DC) --------------------------------------------------------
int __stdcall IsdnSwitchTypeProc(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4)
{
  LONG v4; // eax@1
  LONG v5; // esi@3
  int v6; // ecx@4
  signed int v7; // eax@6

  v4 = GetWindowLongW(hWnd, -21);
  if ( a2 == 78 )
  {
    v6 = *(_DWORD *)(a4 + 8);
    if ( v6 == -207 )
    {
      OnIsdnSwitchTypeWizNext(hWnd, (struct _ISDNConfigInfo *)v4);
    }
    else if ( v6 == -200 )
    {
      v7 = OnIsdnSwitchTypeSetActive(hWnd, (struct _ISDNConfigInfo *)v4);
      SetWindowLongW(hWnd, 0, v7);
      return 1;
    }
  }
  else if ( a2 == 272 )
  {
    v5 = **(_DWORD **)(a4 + 28);
    SetWindowLongW(hWnd, -21, v5);
    OnIsdnSwitchTypeInit(hWnd, (struct _ISDNConfigInfo *)v5);
  }
  return 0;
}

//----- (6E688759) --------------------------------------------------------
void __stdcall OnIsdnInfoPageInit(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  HWND v2; // eax@1

  PopulateIsdnChannels(hDlg, 14103, 1008, 1005, 1010, a2);
  v2 = GetDlgItem(hDlg, 1008);
  SetFocus(v2);
}

//----- (6E68879A) --------------------------------------------------------
void __stdcall OnIsdnInfoPageTransition(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  LRESULT v2; // eax@2
  LRESULT v3; // ST28_4@4
  LRESULT v4; // ST2C_4@4

  if ( *((_DWORD *)a2 + 8) == 14114 )
  {
    v2 = SendDlgItemMessageW(hDlg, 1005, 0x188u, 0, 0);
    if ( v2 != -1 )
      GetDataFromListBox(v2, hDlg, a2);
  }
  else
  {
    v3 = SendDlgItemMessageW(hDlg, 1005, 0x188u, 0, 0);
    v4 = SendDlgItemMessageW(hDlg, 1010, 0x188u, 0, 0);
    SetModifiedIsdnChannelInfo(hDlg, 14103, 1008, 1010, v4, a2);
    RetrieveIsdnChannelInfo(hDlg, 14103, 1008, 1010, a2, v3, v4);
  }
}

//----- (6E68883B) --------------------------------------------------------
void __stdcall OnIsdnInfoPageSelChange(HWND hDlg, WPARAM wParam)
{
  int v2; // eax@1
  WPARAM v3; // ebx@3
  WPARAM v4; // eax@3
  int v5; // esi@5
  HWND v6; // eax@8
  LRESULT v7; // [sp+Ch] [bp-Ch]@1
  int v8; // [sp+10h] [bp-8h]@6
  int v9; // [sp+14h] [bp-4h]@1
  WPARAM wParama; // [sp+24h] [bp+Ch]@5

  v7 = SendDlgItemMessageW(hDlg, 1005, 0x188u, 0, 0);
  v2 = SendDlgItemMessageW(hDlg, 1010, 0x188u, 0, 0);
  v9 = v2;
  if ( v7 != -1 && v2 != -1 )
  {
    v3 = wParam;
    v4 = *(_DWORD *)(wParam + 20);
    if ( v9 != v4 || v7 != *(_DWORD *)(wParam + 16) )
    {
      SetModifiedIsdnChannelInfo(hDlg, 14103, 1008, 1010, v4, (struct _ISDNConfigInfo *)wParam);
      v5 = *(_DWORD *)(wParam + 36) + 12 * v7;
      wParama = 0;
      if ( *(_DWORD *)v5 )
      {
        v8 = 0;
        do
        {
          SendDlgItemMessageW(hDlg, 1010, 0x19Au, wParama++, v8 + *(_DWORD *)(v5 + 8));
          v8 += 774;
        }
        while ( wParama < *(_DWORD *)v5 );
      }
      SetCurrentIsdnChannelSelection(hDlg, 14103, 1008, 1010, (struct _ISDNConfigInfo *)v3, v7, &v9);
      *(_DWORD *)(v3 + 20) = v9;
      *(_DWORD *)(v3 + 16) = v7;
      v6 = GetDlgItem(hDlg, 1008);
      SetFocus(v6);
    }
  }
}

//----- (6E688931) --------------------------------------------------------
void __stdcall OnMsnPageInitDialog(HWND hDlg, struct _ISDNConfigInfo *a2)
{
  HWND v2; // eax@1
  BOOL v3; // ST14_4@1
  HWND v4; // eax@1
  HWND v5; // eax@1
  HWND v6; // eax@1

  PopulateIsdnChannels(hDlg, 14103, 1008, 1005, 1010, a2);
  SetDataToListBox(0, hDlg, a2);
  v2 = GetDlgItem(hDlg, 1002);
  EnableWindow(v2, 0);
  SendDlgItemMessageW(hDlg, 1001, 0xC5u, 0x80u, 0);
  v3 = SendDlgItemMessageW(hDlg, 1014, 0x18Bu, 0, 0) != 0;
  v4 = GetDlgItem(hDlg, 1003);
  EnableWindow(v4, v3);
  v5 = GetDlgItem(hDlg, 1001);
  SetFocus(v5);
  v6 = GetDlgItem(hDlg, 1001);
  SetWindowLongW(v6, -21, 0);
}

//----- (6E6889E5) --------------------------------------------------------
void __stdcall OnIsdnInfoPageWizNext(HWND hWnd, HKEY hKey)
{
  if ( *((_DWORD *)hKey + 8) == GetWindowLongW(hWnd, 8) )
  {
    OnIsdnInfoPageTransition(hWnd, (struct _ISDNConfigInfo *)hKey);
    OnIsdnInfoPageApply(hWnd, hKey);
  }
}

//----- (6E688A1A) --------------------------------------------------------
int __stdcall IsdnInfoPageProc(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4)
{
  LONG v4; // eax@1
  int v5; // esi@17
  LONG v6; // edi@17
  int v7; // edi@20
  int v8; // edi@21
  int v9; // edi@22
  int v10; // ecx@30
  signed int v11; // eax@34
  int v13; // [sp-10h] [bp-1Ch]@24
  WPARAM v14; // [sp-8h] [bp-14h]@27

  v4 = GetWindowLongW(hWnd, -21);
  if ( a2 == 78 )
  {
    v10 = *(_DWORD *)(a4 + 8);
    switch ( v10 )
    {
      case -207:
        OnIsdnInfoPageWizNext(hWnd, (HKEY)v4);
        break;
      case -206:
        OnIsdnInfoPageTransition(hWnd, (struct _ISDNConfigInfo *)v4);
        break;
      case -202:
        OnIsdnInfoPageApply(hWnd, (HKEY)v4);
        break;
      case -200:
        v11 = OnIsdnInfoPageSetActive(hWnd, (struct _ISDNConfigInfo *)v4);
        SetWindowLongW(hWnd, 0, v11);
        return 1;
    }
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 273 )
    {
      switch ( (unsigned __int16)a3 )
      {
        case 0x3E9u:
          if ( HIWORD(a3) == 768 )
            OnMsnPageEditSelChange(hWnd, (struct _ISDNConfigInfo *)v4);
          break;
        case 0x3EAu:
          OnMsnPageAdd(hWnd, (struct _ISDNConfigInfo *)v4);
          break;
        case 0x3EBu:
          OnMsnPageRemove(hWnd, (struct _ISDNConfigInfo *)v4);
          break;
        default:
          if ( ((unsigned __int16)a3 == 1005 || (unsigned __int16)a3 == 1010) && HIWORD(a3) == 1 )
          {
            if ( *(_DWORD *)(v4 + 32) == 14114 )
              OnMsnPageSelChange(hWnd, (struct _ISDNConfigInfo *)v4);
            else
              OnIsdnInfoPageSelChange(hWnd, v4);
          }
          break;
      }
    }
    return 0;
  }
  v5 = *(_DWORD *)(a4 + 28);
  v6 = *(_DWORD *)v5;
  SetWindowLongW(hWnd, -21, *(_DWORD *)v5);
  SetWindowLongW(hWnd, 8, *(_DWORD *)(v5 + 4));
  if ( *(_DWORD *)(v6 + 32) == 14114 )
    OnMsnPageInitDialog(hWnd, (struct _ISDNConfigInfo *)v6);
  else
    OnIsdnInfoPageInit(hWnd, (struct _ISDNConfigInfo *)v6);
  v7 = *(_DWORD *)(v6 + 32) - 14112;
  if ( !v7 )
  {
    v14 = 20;
    goto LABEL_29;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    v14 = 30;
LABEL_29:
    SendDlgItemMessageW(hWnd, 14103, 0xC5u, v14, 0);
    SendDlgItemMessageW(hWnd, 1008, 0xC5u, 0x1Eu, 0);
    return 0;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    v13 = 1001;
    goto LABEL_26;
  }
  if ( v9 == 1 )
  {
    v13 = 1008;
LABEL_26:
    SendDlgItemMessageW(hWnd, v13, 0xC5u, 0x1Eu, 0);
  }
  return 0;
}

//----- (6E688BDA) --------------------------------------------------------
void __stdcall AddWizardPage(LPCPROPSHEETPAGEW constPropSheetPagePointer, struct _SP_NEWDEVICEWIZARD_DATA *a2)
{
  DWORD v2; // eax@2

  if ( a2->NumDynamicPages < 0x14 )
  {
    a2->DynamicPages[a2->NumDynamicPages] = CreatePropertySheetPageW(constPropSheetPagePointer);
    v2 = a2->NumDynamicPages;
    if ( a2->DynamicPages[v2] )
      a2->NumDynamicPages = v2 + 1;
  }
}

//----- (6E688C11) --------------------------------------------------------
void __stdcall FillInIsdnWizardPropertyPage(HINSTANCE a1, struct _PROPSHEETPAGEW *a2, __int16 a3, const unsigned __int16 *a4, int (__stdcall *a5)(HWND, unsigned int, unsigned int, __int32), const unsigned __int16 *a6, const unsigned __int16 *a7, void *a8)
{
  a2->pfnDlgProc = a5;
  a2->pszTitle = a4;
  a2->hInstance = a1;
  a2->lParam = (LPARAM)a8;
  a2->pszTemplate = (LPCWSTR)(unsigned __int16)a3;
  a2->pszHeaderTitle = a6;
  a2->dwSize = 56;
  a2->dwFlags = 12296;
  a2->hIcon = 0;
  a2->pszHeaderSubTitle = a7;
  a2->pfnCallback = 0;
  a2->pcRefParent = 0;
}

//----- (6E688C65) --------------------------------------------------------
__int32 __stdcall HrAddIsdnWizardPagesToDevice(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData, struct _ISDNConfigInfo *a3)
{
  HINSTANCE v3; // edi@1
  __int32 result; // eax@1
  DWORD v5; // ecx@1
  void *v6; // ST1C_4@3
  const unsigned __int16 *v7; // eax@3
  void *v8; // eax@4
  int v9; // esi@5
  void *v10; // ST1C_4@5
  const unsigned __int16 *v11; // ST18_4@5
  const unsigned __int16 *v12; // eax@5
  struct _SP_CLASSINSTALL_HEADER ClassInstallParams; // [sp+Ch] [bp-A8h]@1
  _BYTE constPropSheetPagePointer[48]; // [sp+70h] [bp-44h]@1
  HLOCAL hMem; // [sp+A8h] [bp-Ch]@2
  void *lpMem; // [sp+ACh] [bp-8h]@2
  int v17; // [sp+B0h] [bp-4h]@3

  *(_DWORD *)constPropSheetPagePointer = 0;
  memset(&constPropSheetPagePointer[4], 0, 0x34u);
  v3 = hInst;
  result = HrSetupDiGetFixedSizeClassInstallParams(DeviceInfoSet, DeviceInfoData, &ClassInstallParams, 0x64u);
  if ( result >= 0 )
  {
    hMem = 0;
    lpMem = 0;
    if ( HrSetupDiGetDeviceName(v5, DeviceInfoSet, DeviceInfoData, (DWORD)&lpMem) < 0 )
    {
LABEL_9:
      result = HrSetupDiSetClassInstallParams(DeviceInfoSet, DeviceInfoData, &ClassInstallParams, 0x64u);
    }
    else
    {
      v6 = lpMem;
      v7 = SzLoadIds(1u);
      DwFormatStringWithLocalAlloc(v7, (LPWSTR)&hMem, v6);
      v17 = 0;
      while ( 1 )
      {
        v8 = operator new(8u);
        if ( !v8 )
          break;
        v9 = v17;
        *(_DWORD *)v8 = a3;
        v9 *= 16;
        v10 = v8;
        *((_DWORD *)v8 + 1) = *(int *)((char *)&dword_6E688D98 + v9);
        v11 = SzLoadIds(*(int *)((char *)&dword_6E688DA0 + v9));
        v12 = SzLoadIds(*(int *)((char *)&dword_6E688D9C + v9));
        FillInIsdnWizardPropertyPage(
          v3,
          (struct _PROPSHEETPAGEW *)constPropSheetPagePointer,
          *(int *)((char *)&dword_6E688D98 + v9),
          (const unsigned __int16 *)hMem,
          *(int (__stdcall **)(HWND, unsigned int, unsigned int, __int32))((char *)&off_6E688DA4 + v9),
          v12,
          v11,
          v10);
        if ( v17 == 4 )
        {
          *(_DWORD *)&constPropSheetPagePointer[4] |= 0x80u;
          *(_DWORD *)&constPropSheetPagePointer[32] = DestroyWizardData;
        }
        AddWizardPage(
          (LPCPROPSHEETPAGEW)constPropSheetPagePointer,
          (struct _SP_NEWDEVICEWIZARD_DATA *)&ClassInstallParams);
        ++v17;
        if ( v17 >= 5 )
        {
          LocalFree(hMem);
          MemFree(lpMem);
          goto LABEL_9;
        }
      }
      result = 8;
    }
  }
  return result;
}
// 6E688D98: using guessed type int dword_6E688D98;
// 6E688D9C: using guessed type int dword_6E688D9C;
// 6E688DA0: using guessed type int dword_6E688DA0;
// 6E688DA4: using guessed type int (__stdcall *off_6E688DA4)(HWND hWnd, unsigned int, unsigned int, __int32);

//----- (6E688DED) --------------------------------------------------------
int __stdcall FIsComponentId(LPCWSTR lpString1, LPCWSTR lpString2)
{
  signed int v2; // esi@1

  v2 = 0;
  if ( !(*(int (__stdcall **)(LPCWSTR, LPCWSTR *))(*(_DWORD *)lpString2 + 24))(lpString2, &lpString2) )
  {
    if ( !lstrcmpiW(lpString1, lpString2) )
      v2 = 1;
    CoTaskMemFree((LPVOID)lpString2);
  }
  return v2;
}

//----- (6E688E2C) --------------------------------------------------------
int __stdcall CMSClient::ApplyPnpChanges(CMSClient *this, struct INetCfgPnpReconfigCallback *a2)
{
  int v2; // esi@1
  int v4; // [sp+4h] [bp-8h]@2
  int v5; // [sp+8h] [bp-4h]@2

  v2 = 0;
  if ( *((_DWORD *)this + 39) )
  {
    v4 = 0;
    v5 = 0;
    this = 0;
    if ( CServiceManager::HrOpenService((CServiceManager *)&v4, (CService *)&this, L"Mrxsmb", 0, 1u, 4u) == -2147023836 )
      v2 = CServiceManager::HrOpenService((CServiceManager *)&v4, (CService *)&this, L"Rdbss", 0, 1u, 4u) != -2147023836 ? 0x4A020 : 0;
    else
      v2 = 303136;
    CService::Close((CService *)&this);
    CServiceManager::~CServiceManager((CServiceManager *)&v4);
  }
  return v2;
}
// 6E688EB0: using guessed type wchar_t aRdbss[6];
// 6E688EBC: using guessed type wchar_t aMrxsmb[7];

//----- (6E688ECF) --------------------------------------------------------
__int32 __stdcall CMSClient::Install(CMSClient *this, unsigned __int32 a2)
{
  *((_DWORD *)this + 33) = 1;
  *((_DWORD *)this + 34) = 1;
  *((_DWORD *)this + 35) = 1;
  if ( a2 & 0xC0 || a2 & 0x100 )
    *((_DWORD *)this + 36) = 1;
  return HrInstallComponentOboComponent(
           *((struct INetCfg **)this + 32),
           0,
           &GUID_DEVCLASS_NETSERVICE,
           (const unsigned __int16 *)&stru_6E65D6B0,
           *((struct INetCfgComponent **)this + 31),
           0);
}

//----- (6E688F26) --------------------------------------------------------
__int32 __stdcall CMSClient::Upgrade(CMSClient *this, char a2, unsigned __int32 a3)
{
  if ( a2 & 0x40 )
    *((_DWORD *)this + 37) = 1;
  return 0;
}

//----- (6E688F49) --------------------------------------------------------
int __stdcall CMSClient::Removing(CMSClient *this)
{
  struct INetCfgComponent *v1; // ST0C_4@1

  v1 = (struct INetCfgComponent *)*((_DWORD *)this + 31);
  *((_DWORD *)this + 38) = 1;
  return HrRemoveComponentOboComponent(*((struct IUnknown **)this + 32), &GUID_DEVCLASS_NETSERVICE, &stru_6E65D6B0, v1);
}

//----- (6E688F7C) --------------------------------------------------------
signed int __stdcall CMSClient::MergePropPages(CMSClient *this, unsigned __int32 *a2, unsigned __int8 **a3, unsigned int *a4, HWND hWnd, struct _PSP **a6)
{
  signed int result; // eax@2

  if ( FBadArgs_INetCfgProperties_MergePropPages(a2, a3, a4, hWnd, (const unsigned __int16 **)a6) )
  {
    result = -2147024809;
  }
  else
  {
    a6 = 0;
    result = CMSClient::HrSetupPropSheets((CMSClient *)((char *)this - 12), &a6, 1);
    if ( result >= 0 )
    {
      *a3 = (unsigned __int8 *)a6;
      *a2 = 0;
      *a4 = 1;
    }
  }
  return result;
}

//----- (6E688FD9) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::CancelChanges(CSrvrcfg *this)
{
  return 0;
}

//----- (6E688FE3) --------------------------------------------------------
signed int __stdcall CMSClient::SysNotifyComponent(CMSClient *this, char a2, LPCWSTR lpString2)
{
  signed int v3; // esi@1

  v3 = 1;
  if ( a2 & 3 && FIsComponentId(L"ms_server", lpString2) )
  {
    if ( a2 & 1 )
    {
      *((_DWORD *)this + 38) = 1;
      return 0;
    }
    if ( a2 & 2 )
    {
      *((_DWORD *)this + 38) = 2;
      return 0;
    }
  }
  return v3;
}

//----- (6E689033) --------------------------------------------------------
__int32 CMSClient::HrSetNetLogonDependencies()
{
  struct _LSA_OBJECT_ATTRIBUTES ObjectAttributes; // [sp+Ch] [bp-40h]@6
  int v2; // [sp+24h] [bp-28h]@3
  int v3; // [sp+28h] [bp-24h]@3
  int v4; // [sp+2Ch] [bp-20h]@3
  int v5; // [sp+30h] [bp-1Ch]@1
  PVOID Buffer; // [sp+34h] [bp-18h]@7
  PVOID PolicyHandle; // [sp+38h] [bp-14h]@6
  __int32 v8; // [sp+3Ch] [bp-10h]@1
  int v9; // [sp+48h] [bp-4h]@3

  v8 = 0;
  if ( !(unsigned __int8)RtlGetNtProductType(&v5) || v5 != 2 )
    goto LABEL_15;
  v2 = 0;
  v3 = 0;
  v9 = 0;
  v4 = 0;
  LOBYTE(v9) = 1;
  v8 = CServiceManager::HrOpen((CServiceManager *)&v2, 0, 0xF003Fu, 0, 0);
  if ( v8 >= 0 )
  {
    v8 = CServiceManager::HrAddRemoveServiceDependency((CServiceManager *)&v2, (int)L"NetLogon", L"LanmanServer", 0);
    CServiceManager::Close((CServiceManager *)&v2);
  }
  LOBYTE(v9) = 0;
  CService::Close((CService *)&v4);
  v9 = -1;
  CServiceManager::~CServiceManager((CServiceManager *)&v2);
  if ( v8 >= 0 )
  {
LABEL_15:
    memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
    PolicyHandle = 0;
    ObjectAttributes.Length = 24;
    if ( LsaOpenPolicy(0, &ObjectAttributes, 1u, &PolicyHandle) >= 0 )
    {
      if ( LsaQueryInformationPolicy(PolicyHandle, PolicyPrimaryDomainInformation, &Buffer) >= 0 )
      {
        if ( *((_DWORD *)Buffer + 2) > 0u )
          v8 = HrChangeServiceStartType(L"NetLogon", 2u);
        LsaFreeMemory(Buffer);
      }
      LsaClose(PolicyHandle);
    }
  }
  return v8;
}
// 6E641014: using guessed type int __stdcall RtlGetNtProductType(_DWORD);
// 6E689120: using guessed type wchar_t aLanmanserver[13];

//----- (6E689153) --------------------------------------------------------
__int32 __thiscall CMSClient::HrRestoreRegistry(CMSClient *this)
{
  CMSClient *v1; // esi@1
  __int32 v2; // edi@1
  const WCHAR *v3; // eax@7
  const WCHAR *v4; // eax@13
  BYTE Data[4]; // [sp+Ch] [bp-Ch]@15
  PTOKEN_PRIVILEGES NewState; // [sp+10h] [bp-8h]@1
  HKEY hKey; // [sp+14h] [bp-4h]@5

  v1 = this;
  v2 = 0;
  NewState = 0;
  if ( *((_DWORD *)this + 49) || *((_DWORD *)this + 56) )
  {
    v2 = HrEnableAllPrivileges(&NewState);
    if ( v2 >= 0 )
    {
      if ( *((_DWORD *)v1 + 49)
        && HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\Browser\\Parameters",
             0xF003Fu,
             &hKey) >= 0 )
      {
        if ( *((_DWORD *)v1 + 50) < 8u )
          v3 = (const WCHAR *)((char *)v1 + 180);
        else
          v3 = (const WCHAR *)*((_DWORD *)v1 + 45);
        HrRegRestoreKey(hKey, v3, 0);
        HrRegSetValueEx(hKey, L"ServiceDll", 2u, L"%SystemRoot%\\System32\\browser.dll", 0x44u);
        RegSafeCloseKey(hKey);
      }
      if ( *((_DWORD *)v1 + 56)
        && HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\NetLogon\\Parameters",
             0xF003Fu,
             &hKey) >= 0 )
      {
        if ( *((_DWORD *)v1 + 57) < 8u )
          v4 = (const WCHAR *)((char *)v1 + 208);
        else
          v4 = (const WCHAR *)*((_DWORD *)v1 + 52);
        HrRegRestoreKey(hKey, v4, 0);
        *(_DWORD *)Data = 1;
        HrRegSetValueEx(hKey, L"RequireSignOrSeal", 4u, Data, 4u);
        RegCloseKey(hKey);
      }
      v2 = HrRestorePrivileges(NewState);
      operator delete(NewState);
    }
  }
  return v2;
}

//----- (6E6893B9) --------------------------------------------------------
__int32 __stdcall CMSClient::ApplyRegistryChanges(CMSClient *this)
{
  __int32 result; // eax@7

  if ( *((_DWORD *)this + 37) )
  {
    *((_DWORD *)this + 37) = 0;
    CMSClient::HrRestoreRegistry(this);
  }
  if ( *((_DWORD *)this + 34) || *((_DWORD *)this + 35) || *((_DWORD *)this + 36) || *((_DWORD *)this + 38) )
  {
    result = CMSClient::HrSetBrowserRegistryInfo(this);
    if ( result >= 0 )
    {
      *((_DWORD *)this + 34) = 0;
      *((_DWORD *)this + 35) = 0;
      *((_DWORD *)this + 36) = 0;
      result = CMSClient::HrSetNetLogonDependencies();
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6E68942C) --------------------------------------------------------
__int32 __thiscall CMSClient::HrProcessAnswerFile(CMSClient *this, PCWSTR FileName, const unsigned __int16 *Section)
{
  CMSClient *v3; // esi@1
  __int32 v4; // ebx@1
  __int32 v5; // eax@9
  unsigned __int16 *v7; // [sp+Ch] [bp-14h]@1
  HINF InfHandle; // [sp+10h] [bp-10h]@1
  int v9; // [sp+1Ch] [bp-4h]@1

  v3 = this;
  InfHandle = 0;
  v9 = 0;
  v7 = 0;
  v4 = HrSetupOpenInfFile(FileName, 0, 3u, 0, &InfHandle);
  if ( v4 >= 0 )
  {
    if ( *((_DWORD *)v3 + 37) )
    {
      HrSetupGetFirstString(InfHandle, Section, L"NetLogon.Parameters", (int)((char *)v3 + 204));
      HrSetupGetFirstString(InfHandle, Section, L"Browser.Parameters", (int)((char *)v3 + 176));
    }
    if ( HrSetupGetFirstMultiSzFieldWithAlloc(InfHandle, Section, L"BrowseDomains", &v7) >= 0 )
      CMSClient::SetBrowserDomainList(v3, v7);
    if ( HrSetupGetFirstString(InfHandle, Section, L"NameServiceNetworkAddress", (int)((char *)v3 + 72)) >= 0 )
      *((_DWORD *)v3 + 34) = 1;
    else
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
        (int)((char *)v3 + 72),
        L"\\\\.");
    v5 = HrSetupGetFirstString(InfHandle, Section, L"NameServiceProtocol", (int)((char *)v3 + 44));
    v4 = v5;
    if ( v5 >= 0 )
    {
      *((_DWORD *)v3 + 34) = 1;
    }
    else
    {
      if ( v5 == -2146500350 )
        v4 = 0;
      std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
        (int)((char *)v3 + 44),
        (void *)&L"ncacn_np");
    }
  }
  v9 = -1;
  CSetupInfFile::EnsureClosed((CSetupInfFile *)&InfHandle);
  return v4;
}
// 6E65D6D0: using guessed type const unsigned __int16 *const c_szProtWinNT;

//----- (6E689609) --------------------------------------------------------
__int32 __stdcall CMSClient::ReadAnswerFile(CMSClient *this, PCWSTR FileName, const unsigned __int16 *a3)
{
  __int32 result; // eax@1

  result = 0;
  if ( a3 && FileName )
  {
    result = CMSClient::HrProcessAnswerFile((CMSClient *)((char *)this - 4), FileName, a3);
    if ( result < 0 )
      result = 0;
  }
  return result;
}

//----- (6E68963A) --------------------------------------------------------
__int32 __thiscall CMSClient::HrSetBrowserRegistryInfo(CMSClient *this)
{
  __int32 v1; // ebx@1
  CMSClient *v3; // [sp+4h] [bp-Ch]@1
  HKEY phkResult; // [sp+8h] [bp-8h]@2
  HKEY hKey; // [sp+Ch] [bp-4h]@3

  v1 = 0;
  v3 = this;
  if ( *((_DWORD *)this + 35) )
  {
    phkResult = 0;
    v1 = HrRegOpenKeyEx(
           HKEY_LOCAL_MACHINE,
           L"System\\CurrentControlSet\\Services\\Browser\\Parameters",
           0xF003Fu,
           &phkResult);
    if ( v1 >= 0 )
    {
      hKey = 0;
      v1 = HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters",
             0xF003Fu,
             &hKey);
      if ( v1 >= 0 )
      {
        v1 = HrRegSetMultiSz(hKey, L"OtherDomains", *((BYTE **)v3 + 42));
        RegSafeCloseKey(hKey);
      }
      RegSafeCloseKey(phkResult);
    }
  }
  return v1;
}

//----- (6E689731) --------------------------------------------------------
void __thiscall CMSClient::SetBrowserDomainList(CMSClient *this, unsigned __int16 *a2)
{
  CMSClient *v2; // edi@1
  char *v3; // esi@1

  v2 = this;
  v3 = (char *)this + 168;
  operator delete(*((void **)this + 42));
  *((_DWORD *)v2 + 35) = 1;
  *(_DWORD *)v3 = a2;
}

//----- (6E689762) --------------------------------------------------------
CRPCConfigDlg *__thiscall CRPCConfigDlg::CRPCConfigDlg(CRPCConfigDlg *this, struct CMSClient *a2)
{
  CRPCConfigDlg *result; // eax@1

  result = this;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = -1;
  *(_DWORD *)this = &CRPCConfigDlg::`vftable';
  *((_DWORD *)this + 3) = a2;
  return result;
}
// 6E689784: using guessed type int (__thiscall *CRPCConfigDlg::`vftable')(CRPCConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, __int32 *, unsigned __int32);

//----- (6E689799) --------------------------------------------------------
int __thiscall CRPCConfigDlg::ProcessWindowMessage(CRPCConfigDlg *this, HWND a2, unsigned int a3, unsigned int a4, struct tagNMHDR *a5, __int32 *a6, unsigned __int32 a7)
{
  CPropSheetPage *v7; // ebx@1
  __int32 v8; // eax@3
  bool v9; // zf@4
  __int32 v11; // eax@17
  CRPCConfigDlg *v12; // [sp+Ch] [bp-4h]@1
  unsigned int v13; // [sp+20h] [bp+10h]@10

  v7 = this;
  v12 = this;
  if ( a7 )
    return 0;
  if ( a3 == 272 )
  {
    a7 = 1;
    v8 = CRPCConfigDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a7);
LABEL_4:
    v9 = a7 == 0;
    *a6 = v8;
    goto LABEL_5;
  }
  if ( a3 == 2 )
  {
    a7 = 1;
    v8 = CRPCConfigDlg::OnDestroy(this, 2u, a4, (__int32)a5, (int *)&a7);
    goto LABEL_4;
  }
  if ( a3 != 273 )
  {
    if ( a3 != 78 )
      return 0;
    if ( a5->code == -202 )
    {
      a7 = 1;
      v11 = CRPCConfigDlg::OnOk(this, a4, a5, (int *)&a7);
      v9 = a7 == 0;
      *a6 = v11;
      if ( !v9 )
        return 1;
    }
    if ( a5->code != -201 )
      return 0;
    a7 = 1;
    *a6 = CRPCConfigDlg::OnKillActive(v12, a4, a5, (int *)&a7);
    goto LABEL_14;
  }
  v13 = a4 >> 16;
  if ( 1 == (_WORD)v13 )
  {
    a7 = 1;
    CRPCConfigDlg::SetState(this);
    CPropSheetPage::SetChangedFlag(v7);
    *a6 = 0;
    if ( a7 )
      return 1;
  }
  if ( 768 == (_WORD)v13 )
  {
    a7 = 1;
    CRPCConfigDlg::SetState(v7);
    CPropSheetPage::SetChangedFlag(v7);
    *a6 = 0;
LABEL_14:
    v9 = a7 == 0;
LABEL_5:
    if ( !v9 )
      return 1;
  }
  return 0;
}

//----- (6E6898CE) --------------------------------------------------------
signed int __thiscall CMSClient::HrSetupPropSheets(CMSClient *this, struct _PSP ***a2, int a3)
{
  CMSClient *v3; // esi@1
  struct _PSP **v4; // ebx@3
  CRPCConfigDlg *v5; // eax@7
  CRPCConfigDlg *v6; // eax@8
  signed int v8; // [sp+Ch] [bp-4h]@1

  v3 = this;
  *a2 = 0;
  v8 = 0;
  if ( (unsigned int)(4 * a3) >> 2 < a3 )
  {
    v8 = -2147024809;
LABEL_5:
    CoTaskMemFree(0);
    return v8;
  }
  v4 = (struct _PSP **)CoTaskMemAlloc(4 * a3);
  if ( !v4 )
  {
    v8 = -2147024882;
    goto LABEL_5;
  }
  if ( !*((_DWORD *)v3 + 43) )
  {
    v5 = (CRPCConfigDlg *)operator new(0x10u);
    if ( v5 )
      v6 = CRPCConfigDlg::CRPCConfigDlg(v5, v3);
    else
      v6 = 0;
    *((_DWORD *)v3 + 43) = v6;
  }
  *v4 = CPropSheetPage::CreatePage(*((CPropSheetPage **)v3 + 43), 1202, 0, 0, 0, 0, 0);
  *a2 = v4;
  return v8;
}

//----- (6E68996B) --------------------------------------------------------
void __thiscall CRPCConfigDlg::SetState(CRPCConfigDlg *this)
{
  CRPCConfigDlg *v1; // esi@1
  LRESULT v2; // eax@1
  WPARAM v3; // ecx@2
  HWND v4; // ST00_4@5
  LRESULT v5; // edi@5
  HWND v6; // eax@10
  LRESULT v7; // [sp+Ch] [bp-Ch]@1
  LRESULT v8; // [sp+10h] [bp-8h]@1
  HWND hWnd; // [sp+14h] [bp-4h]@1

  v1 = this;
  v8 = 0;
  hWnd = GetDlgItem(*((HWND *)this + 1), 216);
  v2 = SendDlgItemMessageW(*((HWND *)v1 + 1), 215, 0x147u, 0, 0);
  v7 = v2;
  if ( v2 != -1 )
  {
    v3 = *((_DWORD *)v1 + 2);
    if ( v2 != v3 )
    {
      if ( v3 != -1 )
      {
        v8 = SendDlgItemMessageW(*((HWND *)v1 + 1), 215, 0x150u, v3, 0);
        v2 = v7;
      }
      v4 = (HWND)*((_DWORD *)v1 + 1);
      *((_DWORD *)v1 + 2) = v2;
      v5 = SendDlgItemMessageW(v4, 215, 0x150u, v2, 0);
      if ( *(_DWORD *)(v5 + 168) )
      {
        SetWindowTextW(hWnd, (LPCWSTR)(v5 + 8));
      }
      else
      {
        if ( v8 )
          GetWindowTextW(hWnd, (LPWSTR)(v8 + 8), 80);
        SetWindowTextW(hWnd, &String);
      }
      EnableWindow(hWnd, *(_DWORD *)(v5 + 168));
      v6 = GetDlgItem(*((HWND *)v1 + 1), 220);
      EnableWindow(v6, *(_DWORD *)(v5 + 168));
    }
  }
}

//----- (6E689A4E) --------------------------------------------------------
signed int __thiscall CRPCConfigDlg::HrValidateRpcData(CRPCConfigDlg *this)
{
  CRPCConfigDlg *v1; // esi@1
  LRESULT v2; // eax@1
  signed int v4; // [sp+Ch] [bp-8h]@1
  HWND hWnd; // [sp+10h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  hWnd = GetDlgItem(*((HWND *)this + 1), 216);
  v2 = SendDlgItemMessageW(*((HWND *)v1 + 1), 215, 0x147u, 0, 0);
  if ( v2 != -1
    && *(_DWORD *)(SendDlgItemMessageW(*((HWND *)v1 + 1), 215, 0x150u, v2, 0) + 168)
    && !GetWindowTextLengthW(hWnd) )
  {
    NcMsgBox(*((HWND *)v1 + 1), 0x2EE3u, 0x2EE7u, 0x30u);
    SetFocus(hWnd);
    v4 = -2147180478;
  }
  return v4;
}

//----- (6E689AE5) --------------------------------------------------------
__int32 __thiscall CRPCConfigDlg::OnKillActive(CRPCConfigDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  __int32 v4; // eax@1

  v4 = CRPCConfigDlg::HrValidateRpcData(this);
  return LresFromHr(v4);
}

//----- (6E689AF8) --------------------------------------------------------
__int32 __thiscall CRPCConfigDlg::OnDestroy(CRPCConfigDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CRPCConfigDlg *v5; // ebx@1
  LRESULT v6; // eax@2
  LRESULT v8; // [sp+Ch] [bp-8h]@1
  WPARAM wParam; // [sp+10h] [bp-4h]@1

  v5 = this;
  wParam = 0;
  v8 = SendDlgItemMessageW(*((HWND *)this + 1), 215, 0x146u, 0, 0);
  if ( v8 > 0 )
  {
    do
    {
      v6 = SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x150u, wParam, 0);
      operator delete((void *)v6);
      ++wParam;
    }
    while ( (signed int)wParam < v8 );
  }
  return 0;
}

//----- (6E689B59) --------------------------------------------------------
__int32 __thiscall CRPCConfigDlg::OnInitDialog(CRPCConfigDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CRPCConfigDlg *v5; // ebx@1
  int v6; // eax@1
  LPARAM v7; // esi@1
  void *v9; // eax@3
  LPARAM v10; // eax@5
  LRESULT v11; // eax@5
  LPARAM v12; // eax@5
  LRESULT v13; // eax@5
  LRESULT v14; // eax@6
  const WCHAR *v15; // ecx@7
  const unsigned __int16 *v16; // eax@13
  LRESULT v17; // [sp+Ch] [bp-10h]@6
  LPARAM lParam; // [sp+10h] [bp-Ch]@5
  int v19; // [sp+14h] [bp-8h]@1
  LPARAM v20; // [sp+18h] [bp-4h]@3
  LPARAM v21; // [sp+18h] [bp-4h]@5

  v5 = this;
  v6 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 2) = -1;
  v19 = v6 + 44;
  v7 = (LPARAM)operator new(0xACu);
  if ( !v7 )
    return -2147024882;
  v9 = operator new(0xACu);
  v20 = (LPARAM)v9;
  if ( !v9 )
  {
    operator delete((void *)v7);
    return -2147024882;
  }
  *(_DWORD *)(v7 + 168) = 0;
  *(_DWORD *)v7 = &L"ncacn_np";
  *(_DWORD *)(v7 + 4) = L"\\pipe\\locator";
  *(_WORD *)(v7 + 8) = 0;
  *(_DWORD *)v9 = L"ncacn_ip_tcp";
  *((_DWORD *)v9 + 1) = &String;
  *((_WORD *)v9 + 4) = 0;
  *((_DWORD *)v9 + 42) = 1;
  v10 = (LPARAM)SzLoadIds(0x2EE9u);
  v11 = SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x143u, 0, v10);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x151u, v11, v7);
  v12 = (LPARAM)SzLoadIds(0x2EE1u);
  v13 = SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x143u, 0, v12);
  SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x151u, v13, v20);
  v21 = 0;
  lParam = SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x146u, 0, 0);
  if ( lParam > 0 )
  {
    while ( 1 )
    {
      v14 = SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x150u, v21, 0);
      v17 = v14;
      v15 = (const WCHAR *)(*(_DWORD *)(v19 + 24) < 8u ? v19 + 4 : *(_DWORD *)(v19 + 4));
      if ( !lstrcmpiW(*(LPCWSTR *)v14, v15) )
        break;
      ++v21;
      if ( v21 >= lParam )
        goto LABEL_16;
    }
    if ( *(_DWORD *)(v19 + 52) < 8u )
      v16 = (const unsigned __int16 *)(v19 + 32);
    else
      v16 = *(const unsigned __int16 **)(v19 + 32);
    StringCchCopyW((unsigned __int16 *)(v17 + 8), 0x50u, v16);
    SendDlgItemMessageW(*((HWND *)v5 + 1), 215, 0x14Eu, v21, 0);
  }
LABEL_16:
  if ( v21 != lParam )
  {
    SendDlgItemMessageW(*((HWND *)v5 + 1), 216, 0xC5u, 0x50u, 0);
    CRPCConfigDlg::SetState(v5);
  }
  return LresFromHr(0);
}
// 6E65D6D0: using guessed type const unsigned __int16 *const c_szProtWinNT;
// 6E689CF0: using guessed type wchar_t aNcacn_ip_tcp[13];
// 6E689D10: using guessed type wchar_t aPipeLocator[14];

//----- (6E689D31) --------------------------------------------------------
__int32 __thiscall CRPCConfigDlg::OnOk(CRPCConfigDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CRPCConfigDlg *v4; // esi@1
  int v5; // edi@1
  LRESULT v6; // eax@1
  LRESULT v7; // eax@2
  LRESULT v8; // ebx@2
  __int32 v10; // [sp-4h] [bp-14h]@1
  HWND hWnd; // [sp+Ch] [bp-4h]@1

  v4 = this;
  hWnd = GetDlgItem(*((HWND *)this + 1), 216);
  v5 = *((_DWORD *)v4 + 3) + 44;
  v6 = SendDlgItemMessageW(*((HWND *)v4 + 1), 215, 0x147u, 0, 0);
  v10 = 0;
  if ( v6 != -1 )
  {
    v7 = SendDlgItemMessageW(*((HWND *)v4 + 1), 215, 0x150u, v6, 0);
    v8 = v7;
    if ( !v7 || v7 == -1 )
      return LresFromHr(1);
    if ( *(_DWORD *)(v7 + 168) )
      GetWindowTextW(hWnd, (LPWSTR)(v7 + 8), 80);
    else
      StringCchCopyW((unsigned __int16 *)(v7 + 8), 0x50u, L"\\\\.");
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
      v5 + 28,
      (void *)(v8 + 8));
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
      v5 + 56,
      *(void **)(v8 + 4));
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
      v5,
      *(void **)v8);
    *(_DWORD *)(*((_DWORD *)v4 + 3) + 136) = 1;
    v10 = 0;
  }
  return LresFromHr(v10);
}

//----- (6E689DF9) --------------------------------------------------------
CButton *__thiscall CButton::CButton(CButton *this, HWND hDlg, int nIDDlgItem)
{
  CButton *v3; // esi@1

  v3 = this;
  *(_DWORD *)this = GetDlgItem(hDlg, nIDDlgItem);
  return v3;
}

//----- (6E689E1B) --------------------------------------------------------
LRESULT __thiscall CListBox::AddString(CListBox *this, unsigned __int16 *lParam)
{
  return SendMessageW(*(HWND *)this, 0x180u, 0, (LPARAM)lParam);
}

//----- (6E689E3B) --------------------------------------------------------
LRESULT __thiscall CListBox::GetItemData(CListBox *this, int wParam)
{
  return SendMessageW(*(HWND *)this, 0x199u, wParam, 0);
}

//----- (6E689E5B) --------------------------------------------------------
void __thiscall CListBox::SetItemData(CListBox *this, WPARAM wParam, void *lParam)
{
  SendMessageW(*(HWND *)this, 0x19Au, wParam, (LPARAM)lParam);
}

//----- (6E689E7C) --------------------------------------------------------
int __thiscall CListBox::FindItemData(CListBox *this, int a2, void *a3)
{
  CListBox *v3; // esi@1
  int v4; // edi@1
  LRESULT v5; // ebx@1

  v3 = this;
  v4 = a2;
  v5 = SendMessageW(*(HWND *)this, 0x18Bu, 0, 0);
  while ( 1 )
  {
    if ( v4 >= v5 )
      return -1;
    if ( (void *)CListBox::GetItemData(v3, v4) == a3 )
      break;
    ++v4;
  }
  return v4;
}

//----- (6E689EC3) --------------------------------------------------------
void __thiscall CListBox::SetCurSel(CListBox *this, int wParam)
{
  SendMessageW(*(HWND *)this, 0x186u, wParam, 0);
}

//----- (6E689EE3) --------------------------------------------------------
void __thiscall CButton::SetCheck(CButton *this, int wParam)
{
  SendMessageW(*(HWND *)this, 0xF1u, wParam, 0);
}

//----- (6E689F03) --------------------------------------------------------
void __thiscall CComboBox::AdjustMinDroppedWidth(CComboBox *this, unsigned __int16 *lpString)
{
  CComboBox *v2; // esi@1
  HDC v3; // eax@1
  HDC v4; // edi@1
  LRESULT v5; // eax@3
  int v6; // eax@5
  WPARAM v7; // edi@6
  HWND v8; // ST00_4@7
  struct tagSIZE psizl; // [sp+8h] [bp-10h]@5
  int nSavedDC; // [sp+10h] [bp-8h]@2
  HDC hdc; // [sp+14h] [bp-4h]@1

  v2 = this;
  v3 = GetDC(*(HWND *)this);
  v4 = v3;
  hdc = v3;
  if ( v3 )
  {
    nSavedDC = SaveDC(v3);
    if ( nSavedDC )
    {
      v5 = SendMessageW(*(HWND *)v2, 0x31u, 0, 0);
      if ( v5 )
        SelectObject(v4, (HGDIOBJ)v5);
      v6 = lstrlenW(lpString);
      if ( GetTextExtentPoint32W(v4, lpString, v6, &psizl) )
      {
        v7 = psizl.cx + GetSystemMetrics(2);
        RestoreDC(hdc, nSavedDC);
        ReleaseDC(*(HWND *)v2, hdc);
        if ( *((_DWORD *)v2 + 1) < (signed int)v7 )
        {
          v8 = *(HWND *)v2;
          *((_DWORD *)v2 + 1) = v7;
          SendMessageW(v8, 0x160u, v7, 0);
        }
      }
    }
  }
}

//----- (6E689FAF) --------------------------------------------------------
void *__thiscall CComboBox::CComboBox(void *this, HWND hDlg, int nIDDlgItem)
{
  void *v3; // esi@1
  HWND v4; // eax@1

  v3 = this;
  v4 = GetDlgItem(hDlg, nIDDlgItem);
  *((_DWORD *)v3 + 1) = 0;
  *(_DWORD *)v3 = v4;
  return v3;
}

//----- (6E689FD5) --------------------------------------------------------
void __thiscall CComboBox::ResetContent(CComboBox *this)
{
  HWND v1; // ST00_4@1

  v1 = *(HWND *)this;
  *((_DWORD *)this + 1) = 0;
  SendMessageW(v1, 0x14Bu, 0, 0);
}

//----- (6E689FEF) --------------------------------------------------------
LRESULT __thiscall CComboBox::GetItemData(CComboBox *this, int wParam)
{
  return SendMessageW(*(HWND *)this, 0x150u, wParam, 0);
}

//----- (6E68A00F) --------------------------------------------------------
void __thiscall CComboBox::SetItemData(CComboBox *this, WPARAM wParam, void *lParam)
{
  SendMessageW(*(HWND *)this, 0x151u, wParam, (LPARAM)lParam);
}

//----- (6E68A030) --------------------------------------------------------
LRESULT __thiscall CComboBox::AddString(CComboBox *this, unsigned __int16 *lParam)
{
  CComboBox *v2; // esi@1

  v2 = this;
  CComboBox::AdjustMinDroppedWidth(this, lParam);
  return SendMessageW(*(HWND *)v2, 0x143u, 0, (LPARAM)lParam);
}

//----- (6E68A05C) --------------------------------------------------------
void __thiscall CComboBox::SetCurSel(CComboBox *this, int wParam)
{
  SendMessageW(*(HWND *)this, 0x14Eu, wParam, 0);
}

//----- (6E68A07C) --------------------------------------------------------
void __thiscall CEdit::SetStyle(CEdit *this, __int32 dwNewLong)
{
  SetWindowLongW(*(HWND *)this, -16, dwNewLong);
}

//----- (6E68A097) --------------------------------------------------------
void __thiscall CEdit::LimitText(CEdit *this, int wParam)
{
  SendMessageW(*(HWND *)this, 0xC5u, wParam, 0);
}

//----- (6E68A0B7) --------------------------------------------------------
struct _PSP *__thiscall CAdvanced::CreatePage(CAdvanced *this, void *DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData)
{
  CAdvanced *v3; // esi@1
  struct _PSP *v4; // edi@1

  v3 = this;
  v4 = 0;
  if ( CAdvancedParams::HrInit((CAdvanced *)((char *)this + 8), DeviceInfoSet, DeviceInfoData) >= 0 )
    v4 = CPropSheetPage::CreatePage(v3, 1505, 0, 0, 0, 0, 0);
  return v4;
}

//----- (6E68A0F4) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnDestroy(CAdvanced *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CAdvanced *v5; // esi@1
  int v6; // ebx@1
  LRESULT v7; // eax@2
  void *v8; // ST0C_4@3
  void *v9; // ST08_4@3
  void *v10; // ST04_4@3
  void *v11; // ST00_4@3
  LRESULT v13; // [sp+Ch] [bp-4h]@1

  v5 = this;
  v6 = 0;
  v13 = SendMessageW(**((HWND **)this + 22), 0x146u, 0, 0);
  if ( v13 > 0 )
  {
    do
    {
      v7 = CComboBox::GetItemData(*((CComboBox **)v5 + 22), v6);
      operator delete((void *)v7);
      ++v6;
    }
    while ( v6 < v13 );
  }
  CComboBox::ResetContent(*((CComboBox **)v5 + 22));
  CValue::Destroy((CAdvanced *)((char *)v5 + 120));
  operator delete(*((void **)v5 + 20));
  v8 = (void *)*((_DWORD *)v5 + 21);
  *((_DWORD *)v5 + 20) = 0;
  operator delete(v8);
  v9 = (void *)*((_DWORD *)v5 + 22);
  *((_DWORD *)v5 + 21) = 0;
  operator delete(v9);
  v10 = (void *)*((_DWORD *)v5 + 23);
  *((_DWORD *)v5 + 22) = 0;
  operator delete(v10);
  v11 = (void *)*((_DWORD *)v5 + 24);
  *((_DWORD *)v5 + 23) = 0;
  operator delete(v11);
  *((_DWORD *)v5 + 24) = 0;
  return LresFromHr(0);
}

//----- (6E68A18E) --------------------------------------------------------
LONG __thiscall CAdvanced::~CAdvanced(CAdvanced *this)
{
  CAdvanced *v1; // esi@1

  v1 = this;
  *(_DWORD *)this = &CAdvanced::`vftable';
  sub_6E647CC1((char *)this + 120);
  CAdvancedParams::~CAdvancedParams((CAdvanced *)((char *)v1 + 8));
  return CPropSheetPage::~CPropSheetPage(v1);
}
// 6E65D6E4: using guessed type int (__thiscall *CAdvanced::`vftable')(CAdvanced *this, HWND, unsigned int, unsigned int, HWND, CAdvanced *, unsigned __int32);

//----- (6E68A1D6) --------------------------------------------------------
void __thiscall CAdvanced::Apply(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  struct _SP_DEVINSTALL_PARAMS_W Dst; // [sp+4h] [bp-230h]@2

  v1 = this;
  if ( CAdvancedParams::FSave((CAdvanced *)((char *)this + 8)) )
  {
    HrSetupDiGetDeviceInstallParams(*((HDEVINFO *)v1 + 14), *((PSP_DEVINFO_DATA *)v1 + 15), &Dst);
    Dst.FlagsEx |= 0x400u;
    HrSetupDiSetDeviceInstallParams(*((HDEVINFO *)v1 + 14), *((PSP_DEVINFO_DATA *)v1 + 15), &Dst);
  }
}

//----- (6E68A23A) --------------------------------------------------------
int __thiscall CAdvanced::EnumvalToItem(CAdvanced *this, unsigned __int16 *const lpString2)
{
  int v2; // edi@1
  CAdvanced *v3; // esi@1
  LRESULT v4; // ebx@1
  LRESULT v5; // eax@2
  int result; // eax@4

  v2 = 0;
  v3 = this;
  v4 = SendMessageW(**((HWND **)this + 22), 0x146u, 0, 0);
  if ( v4 <= 0 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v5 = CComboBox::GetItemData(*((CComboBox **)v3 + 22), v2);
      if ( !lstrcmpiW((LPCWSTR)v5, lpString2) )
        break;
      ++v2;
      if ( v2 >= v4 )
        goto LABEL_4;
    }
    result = v2;
  }
  return result;
}

//----- (6E68A28C) --------------------------------------------------------
void __thiscall CAdvanced::BeginEdit(CAdvanced *this)
{
  CAdvanced *v1; // esi@1

  v1 = this;
  if ( !*((_DWORD *)this + 38) )
  {
    CPropSheetPage::SetChangedFlag(this);
    if ( !*((_DWORD *)v1 + 34) )
    {
      *((_DWORD *)v1 + 34) = 1;
      CButton::SetCheck(*((CButton **)v1 + 23), 1);
      CButton::SetCheck(*((CButton **)v1 + 24), 0);
    }
  }
}

//----- (6E68A2C9) --------------------------------------------------------
int __thiscall CAdvanced::CAdvanced(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &CPropSheetPage::`vftable';
  CAdvancedParams::CAdvancedParams(this + 8);
  *(_DWORD *)v1 = &CAdvanced::`vftable';
  *(_DWORD *)(v1 + 80) = 0;
  *(_DWORD *)(v1 + 84) = 0;
  *(_DWORD *)(v1 + 88) = 0;
  *(_DWORD *)(v1 + 92) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_DWORD *)(v1 + 100) = 0;
  *(_DWORD *)(v1 + 104) = 0;
  *(_DWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 116) = 0;
  CValue::CValue(v1 + 120);
  *(_DWORD *)(v1 + 152) = 0;
  return v1;
}
// 6E647CAC: using guessed type int (*CPropSheetPage::`vftable')();
// 6E65D6E4: using guessed type int (__thiscall *CAdvanced::`vftable')(CAdvanced *this, HWND, unsigned int, unsigned int, HWND, CAdvanced *, unsigned __int32);
// 6E68B347: using guessed type int __thiscall CValue::CValue(_DWORD);

//----- (6E68A330) --------------------------------------------------------
void *__thiscall CAdvanced::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CAdvanced::~CAdvanced((CAdvanced *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68A356) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnEdit(CAdvanced *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  if ( a2 == 768 )
    CAdvanced::BeginEdit(this);
  return LresFromHr(0);
}

//----- (6E68A37B) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnDrop(CAdvanced *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CAdvanced *v5; // esi@1

  v5 = this;
  if ( a2 == 1 && !*((_DWORD *)this + 38) )
  {
    CPropSheetPage::SetChangedFlag(this);
    CAdvanced::BeginEdit(v5);
  }
  return LresFromHr(0);
}

//----- (6E68A3B0) --------------------------------------------------------
void __thiscall CAdvanced::SetParamRange(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  int v2; // eax@1
  int v3; // eax@2
  LONG v4; // eax@4
  int v5; // ecx@4
  unsigned int v6; // eax@5
  unsigned int v7; // eax@8
  __int32 v8; // eax@11
  int v9; // eax@15
  __int32 v10; // ebx@15
  unsigned __int16 *v11; // edi@17
  LRESULT v12; // eax@18
  WPARAM v13; // edi@23
  unsigned __int32 v14; // ebx@23
  WPARAM v15; // eax@23
  CValue *v16; // ecx@23
  LPARAM v17; // eax@23
  HWND v18; // ST0C_4@23
  LPARAM lParam; // [sp+Ch] [bp-42Ch]@23
  unsigned __int32 v20; // [sp+10h] [bp-428h]@23
  int v21; // [sp+14h] [bp-424h]@23
  unsigned __int32 v22; // [sp+18h] [bp-420h]@23
  int v23; // [sp+1Ch] [bp-41Ch]@23
  unsigned __int32 v24; // [sp+20h] [bp-418h]@23
  DWORD cbData; // [sp+24h] [bp-414h]@15
  DWORD cchValueName; // [sp+28h] [bp-410h]@15
  DWORD Type; // [sp+2Ch] [bp-40Ch]@15
  WPARAM wParam; // [sp+30h] [bp-408h]@14
  BYTE Data; // [sp+34h] [bp-404h]@15
  WCHAR ValueName; // [sp+234h] [bp-204h]@15

  v1 = this;
  v2 = *((_DWORD *)this + 29) - 1;
  *((_DWORD *)this + 38) = 1;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        CEdit::LimitText(*((CEdit **)this + 21), *(_DWORD *)(*((_DWORD *)this + 3) + 188));
        v4 = GetWindowLongW(**((HWND **)v1 + 21), -16);
        v5 = *((_DWORD *)v1 + 3);
        if ( *(_DWORD *)(v5 + 212) )
          v6 = v4 | 8;
        else
          v6 = v4 & 0xFFFFFFF7;
        if ( *(_DWORD *)(v5 + 208) )
          v7 = v6 | 0x400;
        else
          v7 = v6 & 0xFFFFFBFF;
        if ( *(_DWORD *)(v5 + 204) )
          v8 = v7 | 0x800;
        else
          v8 = v7 & 0xFFFFF7FF;
        CEdit::SetStyle(*((CEdit **)v1 + 21), v8);
      }
    }
    else
    {
      CComboBox::ResetContent(*((CComboBox **)this + 22));
      wParam = 0;
      do
      {
        v9 = *((_DWORD *)v1 + 3);
        cchValueName = 256;
        cbData = 512;
        v10 = HrRegEnumValue(*(HKEY *)(v9 + 192), wParam, &ValueName, &cchValueName, &Type, &Data, &cbData);
        if ( v10 >= 0 && Type == 1 )
        {
          v11 = (unsigned __int16 *)operator new(2 * (wcslen(&ValueName) + 1));
          if ( !v11 )
            break;
          StringCchCopyW(v11, wcslen(&ValueName) + 1, &ValueName);
          v12 = CComboBox::AddString(*((CComboBox **)v1 + 22), (unsigned __int16 *)&Data);
          if ( v12 < 0 )
            operator delete(v11);
          else
            CComboBox::SetItemData(*((CComboBox **)v1 + 22), v12, v11);
        }
        ++wParam;
      }
      while ( v10 >= 0 );
    }
  }
  else
  {
    v13 = *(_DWORD *)(*((_DWORD *)this + 3) + 12) != 0 ? 16 : 10;
    SendMessageW(*((HWND *)this + 25), 0x46Du, v13, 0);
    v14 = CValue::GetNumericValueAsDword((CValue *)(*((_DWORD *)v1 + 3) + 128));
    v15 = CValue::GetNumericValueAsDword((CValue *)(*((_DWORD *)v1 + 3) + 64));
    v16 = (CValue *)(*((_DWORD *)v1 + 3) + 96);
    wParam = v15;
    v17 = CValue::GetNumericValueAsDword(v16);
    SendMessageW(*((HWND *)v1 + 25), 0x46Fu, wParam, v17);
    lParam = 0;
    v20 = v14;
    v22 = 2 * v14;
    v18 = (HWND)*((_DWORD *)v1 + 25);
    v21 = 1;
    v23 = 3;
    v24 = v13 * v14;
    SendMessageW(v18, 0x46Bu, 3u, (LPARAM)&lParam);
  }
  *((_DWORD *)v1 + 38) = 0;
}

//----- (6E68A61A) --------------------------------------------------------
void __thiscall CAdvanced::UpdateParamDisplay(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  int v2; // eax@1
  int v3; // ST0C_4@15
  LRESULT v4; // eax@17
  wchar_t *v5; // [sp-4h] [bp-230h]@8
  wchar_t Dst; // [sp+8h] [bp-224h]@14
  WCHAR String; // [sp+208h] [bp-24h]@17

  v1 = this;
  v2 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 38) = 1;
  if ( *(_DWORD *)(v2 + 196) )
  {
    CButton::SetCheck(*((CButton **)this + 23), *((_DWORD *)this + 34));
    CButton::SetCheck(*((CButton **)v1 + 24), *((_DWORD *)v1 + 34) == 0);
  }
  if ( !*(_DWORD *)(*((_DWORD *)v1 + 3) + 196) || *((_DWORD *)v1 + 34) )
  {
    if ( *((_DWORD *)v1 + 29) == 1 )
    {
      CValue::ToString((CAdvanced *)((char *)v1 + 120), &String, 0x10u);
      v4 = SendMessageW(*((HWND *)v1 + 25), 0x46Au, 0, 0);
      SetWindowTextW((HWND)v4, &String);
      goto LABEL_18;
    }
    if ( *((_DWORD *)v1 + 29) == 2 )
    {
      v3 = CAdvanced::EnumvalToItem(v1, *((unsigned __int16 *const *)v1 + 37));
      CComboBox::SetCurSel(*((CComboBox **)v1 + 22), v3);
      goto LABEL_18;
    }
    if ( *((_DWORD *)v1 + 29) == 3 )
    {
      CValue::ToString((CAdvanced *)((char *)v1 + 120), &Dst, 0x100u);
      v5 = &Dst;
      goto LABEL_9;
    }
  }
  else
  {
    if ( *((_DWORD *)v1 + 29) == 1 )
      goto LABEL_21;
    if ( *((_DWORD *)v1 + 29) == 2 )
    {
      CComboBox::SetCurSel(*((CComboBox **)v1 + 22), -1);
      goto LABEL_18;
    }
    if ( *((_DWORD *)v1 + 29) == 3 )
    {
LABEL_21:
      v5 = (wchar_t *)&::String;
LABEL_9:
      SetWindowTextW(**((HWND **)v1 + 21), v5);
      goto LABEL_18;
    }
  }
LABEL_18:
  *((_DWORD *)v1 + 38) = 0;
}

//----- (6E68A71E) --------------------------------------------------------
int __thiscall CAdvanced::ItemToEnumval(CAdvanced *this, int a2, LPCWSTR lpString, unsigned int a4)
{
  LRESULT v4; // eax@1
  int result; // eax@2

  v4 = CComboBox::GetItemData(*((CComboBox **)this + 22), a2);
  if ( v4 == -1 )
  {
    result = 0;
  }
  else
  {
    StringCchCopyW((unsigned __int16 *)lpString, a4, (const unsigned __int16 *)v4);
    result = lstrlenW(lpString);
  }
  return result;
}

//----- (6E68A755) --------------------------------------------------------
signed int __stdcall HrGetAdvancedPage(void *a1, struct _SP_DEVINFO_DATA *a2, struct _PSP **a3)
{
  int v3; // ecx@1
  int v4; // esi@2
  struct _PSP *v5; // eax@5
  signed int v6; // edi@6

  v3 = (int)operator new(0x9Cu);
  if ( v3 )
    v4 = CAdvanced::CAdvanced(v3);
  else
    v4 = 0;
  if ( v4 )
  {
    v5 = CAdvanced::CreatePage((CAdvanced *)v4, a1, a2);
    if ( v5 )
    {
      *a3 = v5;
      v6 = 0;
    }
    else
    {
      *a3 = 0;
      v6 = -2147467259;
      (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v4 + 4))(v4, 1);
    }
  }
  else
  {
    *a3 = 0;
    v6 = -2147467259;
  }
  return v6;
}

//----- (6E68A7D6) --------------------------------------------------------
void __thiscall CAdvanced::UpdateDisplay(CAdvanced *this)
{
  int v1; // edi@1
  CAdvanced *v2; // esi@1
  LRESULT v3; // ebx@1
  LRESULT v4; // eax@2
  int v5; // eax@3
  HWND *v6; // eax@17
  HWND *v7; // eax@21

  v1 = 0;
  v2 = this;
  v3 = SendMessageW(**((HWND **)this + 22), 0x146u, 0, 0);
  if ( v3 > 0 )
  {
    do
    {
      v4 = CComboBox::GetItemData(*((CComboBox **)v2 + 22), v1);
      operator delete((void *)v4);
      ++v1;
    }
    while ( v1 < v3 );
  }
  CComboBox::ResetContent(*((CComboBox **)v2 + 22));
  v5 = *((_DWORD *)v2 + 3);
  if ( *(_DWORD *)(v5 + 164) != 4 )
  {
    if ( *(_DWORD *)(v5 + 164) == 5 )
    {
      *((_DWORD *)v2 + 29) = 2;
      goto LABEL_12;
    }
    if ( *(_DWORD *)(v5 + 164) != 6 )
    {
      if ( *(_DWORD *)(v5 + 164) == 7 )
      {
        *((_DWORD *)v2 + 29) = 4;
        goto LABEL_12;
      }
      goto LABEL_11;
    }
LABEL_10:
    *((_DWORD *)v2 + 29) = 3;
    goto LABEL_12;
  }
  if ( *(_DWORD *)(v5 + 124) > 0x7FFFFFFFu )
    goto LABEL_10;
LABEL_11:
  *((_DWORD *)v2 + 29) = 1;
LABEL_12:
  ShowWindow(**((HWND **)v2 + 21), 0);
  ShowWindow(**((HWND **)v2 + 22), 0);
  ShowWindow(*((HWND *)v2 + 25), 0);
  ShowWindow(*((HWND *)v2 + 26), 0);
  if ( *((_DWORD *)v2 + 29) == 1 )
  {
    ShowWindow(**((HWND **)v2 + 21), 5);
    ShowWindow(*((HWND *)v2 + 25), 1);
    goto LABEL_21;
  }
  if ( *((_DWORD *)v2 + 29) == 2 )
  {
    v6 = (HWND *)*((_DWORD *)v2 + 22);
    goto LABEL_18;
  }
  if ( *((_DWORD *)v2 + 29) == 3 )
  {
    v6 = (HWND *)*((_DWORD *)v2 + 21);
LABEL_18:
    ShowWindow(*v6, 5);
    goto LABEL_21;
  }
  if ( *((_DWORD *)v2 + 29) == 4 )
    ShowWindow(*((HWND *)v2 + 26), 1);
LABEL_21:
  v7 = (HWND *)*((_DWORD *)v2 + 23);
  if ( *(_DWORD *)(*((_DWORD *)v2 + 3) + 196) )
  {
    ShowWindow(*v7, 5);
    ShowWindow(**((HWND **)v2 + 24), 5);
  }
  else
  {
    ShowWindow(*v7, 0);
    ShowWindow(**((HWND **)v2 + 24), 0);
  }
  CAdvanced::SetParamRange(v2);
  CAdvanced::UpdateParamDisplay(v2);
}

//----- (6E68A8E7) --------------------------------------------------------
void __thiscall CAdvanced::SelectParam(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  int v2; // eax@1
  LRESULT v3; // eax@2

  v1 = this;
  v2 = SendMessageW(**((HWND **)this + 20), 0x188u, 0, 0);
  if ( v2 >= 0 )
  {
    v3 = CListBox::GetItemData(*((CListBox **)v1 + 20), v2);
    if ( v3 != *((_DWORD *)v1 + 3) )
    {
      *((_DWORD *)v1 + 3) = v3;
      CValue::Destroy((CAdvanced *)((char *)v1 + 120));
      CValue::InitNotPresent((int)((char *)v1 + 120), *(_DWORD *)(*((_DWORD *)v1 + 3) + 164));
      CValue::Copy((CAdvanced *)((char *)v1 + 120), *((struct CValue **)v1 + 3));
      CAdvanced::UpdateDisplay(v1);
    }
  }
}

//----- (6E68A94A) --------------------------------------------------------
void __thiscall CAdvanced::GetParamValue(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  int v2; // eax@4
  int v3; // eax@5
  WCHAR *v4; // eax@8
  int v5; // eax@9
  LRESULT v6; // eax@11
  WCHAR String; // [sp+Ch] [bp-224h]@7
  WCHAR v8; // [sp+20Ch] [bp-24h]@11

  v1 = this;
  if ( *(_DWORD *)(*((_DWORD *)this + 3) + 196) && !SendMessageW(**((HWND **)this + 23), 0xF0u, 0, 0) )
  {
    *((_DWORD *)v1 + 34) = 0;
    return;
  }
  v2 = *((_DWORD *)v1 + 29) - 1;
  *((_DWORD *)v1 + 34) = 1;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 != 1 )
        return;
      GetWindowTextW(**((HWND **)v1 + 21), &String, 256);
    }
    else
    {
      v5 = SendMessageW(**((HWND **)v1 + 22), 0x147u, 0, 0);
      if ( v5 == -1 )
        return;
      CAdvanced::ItemToEnumval(v1, v5, &String, 0x100u);
    }
    v4 = &String;
  }
  else
  {
    v6 = SendMessageW(*((HWND *)v1 + 25), 0x46Au, 0, 0);
    GetWindowTextW((HWND)v6, &v8, 16);
    v4 = &v8;
  }
  CValue::FromString((CAdvanced *)((char *)v1 + 120), v4);
}

//----- (6E68AA2B) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnPresent(CAdvanced *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CAdvanced *v5; // esi@1

  v5 = this;
  if ( a3 == 1105 && !SendMessageW(**((HWND **)this + 23), 0xF0u, 0, 0) )
  {
    *((_DWORD *)v5 + 34) = 1;
    goto LABEL_6;
  }
  if ( a3 == 1106 && !SendMessageW(**((HWND **)v5 + 24), 0xF0u, 0, 0) )
  {
    CAdvanced::GetParamValue(v5);
    *((_DWORD *)v5 + 34) = 0;
LABEL_6:
    CAdvanced::UpdateParamDisplay(v5);
  }
  return LresFromHr(0);
}

//----- (6E68AAAA) --------------------------------------------------------
void __thiscall CAdvanced::FillParamListbox(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  CParam **i; // edi@1
  LRESULT v3; // eax@2
  unsigned __int16 v4; // [sp+8h] [bp-204h]@2

  v1 = this;
  SendMessageW(**((HWND **)this + 20), 0x184u, 0, 0);
  for ( i = (CParam **)*((_DWORD *)v1 + 17); i != *((CParam ***)v1 + 18); ++i )
  {
    CParam::GetDescription(*i, &v4, 0x100u);
    v3 = CListBox::AddString(*((CListBox **)v1 + 20), &v4);
    if ( v3 >= 0 )
      CListBox::SetItemData(*((CListBox **)v1 + 20), v3, (void *)*i);
  }
}

//----- (6E68AB28) --------------------------------------------------------
int __thiscall CAdvanced::FValidateCurrParam(CAdvanced *this)
{
  CAdvanced *v1; // esi@1
  int v2; // ST08_4@1
  signed int v3; // edi@1
  int v4; // eax@1
  int v5; // ecx@1
  char v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+34h] [bp-4h]@1

  v1 = this;
  CValue::CValue(&v7);
  v2 = *(_DWORD *)(*((_DWORD *)v1 + 3) + 164);
  v3 = 0;
  v8 = 0;
  CValue::InitNotPresent((int)&v7, v2);
  CValue::Copy((CValue *)&v7, *((struct CValue **)v1 + 3));
  CAdvanced::GetParamValue(v1);
  CValue::Copy(*((CValue **)v1 + 3), (CAdvanced *)((char *)v1 + 120));
  v4 = CAdvancedParams::FValidateSingleParam(
         (CAdvanced *)((char *)v1 + 8),
         *((struct CParam **)v1 + 3),
         1,
         *((HWND *)v1 + 1));
  v5 = *((_DWORD *)v1 + 3);
  if ( v4 )
  {
    *(_DWORD *)(*((_DWORD *)v1 + 3) + 200) = CValue::Compare((CValue *)v5, (struct CValue *)(v5 + 32)) != 0;
    v3 = 1;
  }
  else
  {
    CValue::Copy((CValue *)v5, (struct CValue *)&v7);
  }
  CValue::Destroy((CValue *)&v7);
  v8 = -1;
  sub_6E647CC1(&v7);
  return v3;
}
// 6E68B347: using guessed type int __thiscall CValue::CValue(_DWORD);

//----- (6E68ABCE) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnInitDialog(CAdvanced *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CAdvanced *v5; // esi@1
  CButton *v6; // eax@1
  CButton *v7; // eax@2
  CButton *v8; // eax@5
  CButton *v9; // eax@6
  void *v10; // eax@8
  void *v11; // eax@9
  CButton *v12; // eax@11
  CButton *v13; // eax@12
  CButton *v14; // eax@14
  CButton *v15; // eax@15
  HWND v16; // ST08_4@17
  HWND v17; // eax@17
  HWND v18; // ST08_4@17

  v5 = this;
  *((_DWORD *)this + 38) = 1;
  v6 = (CButton *)operator new(4u);
  if ( v6 )
    v7 = CButton::CButton(v6, *((HWND *)v5 + 1), 1101);
  else
    v7 = 0;
  *((_DWORD *)v5 + 20) = v7;
  if ( v7 )
  {
    v8 = (CButton *)operator new(4u);
    if ( v8 )
      v9 = CButton::CButton(v8, *((HWND *)v5 + 1), 1102);
    else
      v9 = 0;
    *((_DWORD *)v5 + 21) = v9;
    v10 = operator new(8u);
    if ( v10 )
      v11 = CComboBox::CComboBox(v10, *((HWND *)v5 + 1), 1103);
    else
      v11 = 0;
    *((_DWORD *)v5 + 22) = v11;
    v12 = (CButton *)operator new(4u);
    if ( v12 )
      v13 = CButton::CButton(v12, *((HWND *)v5 + 1), 1105);
    else
      v13 = 0;
    *((_DWORD *)v5 + 23) = v13;
    v14 = (CButton *)operator new(4u);
    if ( v14 )
      v15 = CButton::CButton(v14, *((HWND *)v5 + 1), 1106);
    else
      v15 = 0;
    v16 = (HWND)*((_DWORD *)v5 + 1);
    *((_DWORD *)v5 + 24) = v15;
    v17 = GetDlgItem(v16, 1104);
    v18 = (HWND)*((_DWORD *)v5 + 1);
    *((_DWORD *)v5 + 25) = v17;
    *((_DWORD *)v5 + 26) = GetDlgItem(v18, 1111);
    CAdvanced::FillParamListbox(v5);
    *((_DWORD *)v5 + 3) = 0;
    CValue::Init((int)((char *)v5 + 120), 1, 0);
    if ( SendMessageW(**((HWND **)v5 + 20), 0x18Bu, 0, 0) > 0 )
    {
      CListBox::SetCurSel(*((CListBox **)v5 + 20), 0);
      CAdvanced::SelectParam(v5);
    }
    *((_DWORD *)v5 + 38) = 0;
  }
  return 0;
}

//----- (6E68AD00) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnApply(CAdvanced *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CAdvanced *v4; // esi@1

  v4 = this;
  if ( CAdvanced::FValidateCurrParam(this) )
  {
    CAdvanced::UpdateParamDisplay(v4);
    CAdvanced::Apply(v4);
  }
  return LresFromHr(0);
}

//----- (6E68AD2C) --------------------------------------------------------
__int32 __thiscall CAdvanced::OnKillActive(CAdvanced *this, int a2, struct tagNMHDR *a3, int *a4)
{
  __int32 v4; // esi@1

  v4 = 0;
  if ( !CAdvanced::FValidateCurrParam(this) )
    v4 = -2147467259;
  return LresFromHr(v4);
}

//----- (6E68AD4E) --------------------------------------------------------
signed int __thiscall CAdvanced::OnList(CAdvanced *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  signed int v5; // edi@1
  CAdvanced *v6; // esi@1
  int v7; // eax@3

  v5 = 0;
  v6 = this;
  if ( a2 == 1 )
  {
    if ( CAdvanced::FValidateCurrParam(this) )
    {
      CAdvanced::SelectParam(v6);
    }
    else
    {
      v7 = CListBox::FindItemData(*((CListBox **)v6 + 20), 0, *((void **)v6 + 3));
      CListBox::SetCurSel(*((CListBox **)v6 + 20), v7);
      v5 = 1;
    }
  }
  return v5;
}

//----- (6E68AD95) --------------------------------------------------------
int __thiscall CAdvanced::ProcessWindowMessage(CAdvanced *this, HWND a2, unsigned int a3, unsigned int a4, HWND a5, CAdvanced *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  unsigned __int16 v9; // dx@12
  int v10; // edx@18

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CAdvanced::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a6);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 2 )
    {
      v7 = CAdvanced::OnDestroy(this, 2u, a4, (__int32)a5, (int *)&a6);
      goto LABEL_4;
    }
    if ( a3 == 273 )
    {
      if ( 1102 == (_WORD)a4 )
      {
        v7 = CAdvanced::OnEdit(this, HIWORD(a4), 0x44Eu, a5, (int *)&a6);
        goto LABEL_4;
      }
      if ( 1103 == (_WORD)a4 )
      {
        v7 = CAdvanced::OnDrop(this, HIWORD(a4), 0x44Fu, a5, (int *)&a6);
        goto LABEL_4;
      }
      v9 = 1105;
      if ( 1105 == (_WORD)a4 || (v9 = 1106, 1106 == (_WORD)a4) )
      {
        v7 = CAdvanced::OnPresent(this, HIWORD(a4), v9, a5, (int *)&a6);
        goto LABEL_4;
      }
      if ( 1101 == (_WORD)a4 )
      {
        v7 = CAdvanced::OnList(this, HIWORD(a4), 0x44Du, a5, (int *)&a6);
        goto LABEL_4;
      }
    }
    else if ( a3 == 78 )
    {
      v10 = *((_DWORD *)a5 + 2);
      if ( v10 == -202 )
      {
        v7 = CAdvanced::OnApply(this, a4, (struct tagNMHDR *)a5, (int *)&a6);
        goto LABEL_4;
      }
      if ( v10 == -201 )
      {
        v7 = CAdvanced::OnKillActive(this, a4, (struct tagNMHDR *)a5, (int *)&a6);
        goto LABEL_4;
      }
    }
  }
  return 0;
}

//----- (6E68AECB) --------------------------------------------------------
void __stdcall UpdateAdvancedParametersIfNeeded(void *DeviceInfoSet, struct _SP_DEVINFO_DATA *DeviceInfoData)
{
  char v2; // [sp+Ch] [bp-54h]@1
  int v3; // [sp+5Ch] [bp-4h]@1

  CAdvancedParams::CAdvancedParams((int)&v2);
  v3 = 0;
  if ( CAdvancedParams::HrInit((CAdvancedParams *)&v2, DeviceInfoSet, DeviceInfoData) >= 0 )
    CAdvancedParams::FSave((CAdvancedParams *)&v2);
  v3 = -1;
  CAdvancedParams::~CAdvancedParams((CAdvancedParams *)&v2);
}

//----- (6E68AF16) --------------------------------------------------------
void *__thiscall CParam::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CParam::~CParam((CParam *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68AF3C) --------------------------------------------------------
int __thiscall CAdvancedParams::FSetParamValue(CAdvancedParams *this, LPCWSTR lpString1, const unsigned __int16 *const a3)
{
  CAdvancedParams *v3; // esi@1
  int v4; // ebx@1
  unsigned int v5; // edi@1
  int result; // eax@4
  int v7; // edi@6

  v3 = this;
  v4 = (int)((char *)this + 56);
  v5 = 0;
  if ( std::vector<CParam *,std::nc_allocator<CParam *>>::size((int)((char *)this + 56)) )
  {
    while ( lstrcmpiW(lpString1, *(LPCWSTR *)(*(_DWORD *)(*((_DWORD *)v3 + 15) + 4 * v5) + 172)) )
    {
      ++v5;
      if ( v5 >= std::vector<CParam *,std::nc_allocator<CParam *>>::size(v4) )
        goto LABEL_4;
    }
    v7 = 4 * v5;
    CValue::FromString(*(CValue **)(*((_DWORD *)v3 + 15) + v7), a3);
    result = 1;
    *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v3 + 15) + v7) + 200) = 1;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (6E68AFAB) --------------------------------------------------------
int __thiscall CAdvancedParams::FValidateSingleParam(CAdvancedParams *this, struct CParam *a2, int a3, HWND a4)
{
  signed int v4; // eax@1
  int v5; // eax@2
  int v6; // eax@3
  unsigned int v8; // [sp-8h] [bp-84h]@14
  CAdvancedParams *v9; // [sp+Ch] [bp-70h]@1
  int v10; // [sp+14h] [bp-68h]@1
  wchar_t v11; // [sp+18h] [bp-64h]@8
  wchar_t v12; // [sp+38h] [bp-44h]@5
  wchar_t Dst; // [sp+58h] [bp-24h]@5

  v9 = this;
  v10 = 0;
  v4 = CParam::Validate(a2);
  if ( !v4 )
    return 1;
  v5 = v4 - 1;
  if ( !v5 )
  {
    if ( !a3 )
      return v10;
    v8 = 15003;
    goto LABEL_15;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    if ( !a3 )
      return v10;
    v8 = 15004;
LABEL_15:
    NcMsgBox(a4, 0x3A9Du, v8, 0x30u);
    return v10;
  }
  if ( v6 == 1 )
  {
    CValue::ToString((struct CParam *)((char *)a2 + 64), &Dst, 0x10u);
    CValue::ToString((struct CParam *)((char *)a2 + 96), &v12, 0x10u);
    if ( a3 )
    {
      if ( CValue::GetNumericValueAsDword((struct CParam *)((char *)a2 + 128)) == 1 )
      {
        NcMsgBox(a4, 0x3A9Du, 0x3A98u, 0x30u, &Dst, &v12);
      }
      else
      {
        CValue::ToString((struct CParam *)((char *)a2 + 128), &v11, 0x10u);
        NcMsgBox(a4, 0x3A9Du, 0x3A99u, 0x30u, &Dst, &v12, &v11);
      }
    }
    else
    {
      if ( (struct CParam *)((char *)a2 + 64) > a2 )
        CAdvancedParams::FSetParamValue(v9, *((LPCWSTR *)a2 + 43), &Dst);
      if ( (struct CParam *)((char *)a2 + 96) < a2 )
        CAdvancedParams::FSetParamValue(v9, *((LPCWSTR *)a2 + 43), &v12);
    }
  }
  return v10;
}

//----- (6E68B0F8) --------------------------------------------------------
int __thiscall CAdvancedParams::FSave(CAdvancedParams *this)
{
  CAdvancedParams *v1; // edi@1
  CParam **v2; // esi@1
  signed int v3; // ebx@1

  v1 = this;
  v2 = (CParam **)*((_DWORD *)this + 15);
  v3 = 0;
  while ( v2 != *((CParam ***)v1 + 16) )
  {
    if ( *((_DWORD *)*v2 + 50) )
    {
      v3 = 1;
      CParam::Apply(*v2);
    }
    ++v2;
  }
  return v3;
}

//----- (6E68B12C) --------------------------------------------------------
int __thiscall CAdvancedParams::~CAdvancedParams(CAdvancedParams *this)
{
  CAdvancedParams *v1; // esi@1
  void **i; // edi@1

  v1 = this;
  for ( i = (void **)*((_DWORD *)this + 15); i != *((void ***)v1 + 16); ++i )
  {
    if ( *i )
      CParam::`scalar deleting destructor'(*i, 1);
  }
  RegSafeCloseKey(*(HKEY *)v1);
  std::vector<CComponent *,std::nc_allocator<CComponent *>>::_Tidy((int)((char *)v1 + 56));
  return sub_6E647CC1((char *)v1 + 12);
}

//----- (6E68B184) --------------------------------------------------------
int __thiscall CAdvancedParams::CAdvancedParams(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  CValue::CValue(this + 12);
  *(_DWORD *)(v1 + 44) = 0;
  *(_DWORD *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 52) = 0;
  std::vector<CParam *,std::nc_allocator<CParam *>>::_Buy(v1 + 56, 0);
  return v1;
}
// 6E68B347: using guessed type int __thiscall CValue::CValue(_DWORD);

//----- (6E68B1C9) --------------------------------------------------------
void __thiscall CAdvancedParams::FillParamList(CAdvancedParams *this, HKEY a2, HKEY hKey)
{
  int v3; // edx@1
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // eax@3
  struct _FILETIME ftLastWriteTime; // [sp+Ch] [bp-234h]@2
  DWORD cchName; // [sp+14h] [bp-22Ch]@2
  HKEY v9; // [sp+18h] [bp-228h]@1
  __int32 v10; // [sp+1Ch] [bp-224h]@1
  int v11; // [sp+20h] [bp-220h]@3
  DWORD dwIndex; // [sp+24h] [bp-21Ch]@1
  WCHAR Name; // [sp+28h] [bp-218h]@2
  int v14; // [sp+23Ch] [bp-4h]@3

  v3 = *((_DWORD *)this + 15);
  v9 = a2;
  v4 = (int)((char *)this + 56);
  std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::erase(
    (char *)this + 56,
    (int)&v10,
    v3,
    *((_DWORD *)this + 16));
  v5 = 0;
  dwIndex = 0;
  while ( 1 )
  {
    cchName = 260;
    v10 = HrRegEnumKeyEx(hKey, dwIndex, &Name, &cchName, 0, 0, &ftLastWriteTime);
    if ( v10 >= 0 )
      break;
LABEL_9:
    ++dwIndex;
    v5 = 0;
    if ( v10 < 0 )
      return;
  }
  v6 = (int)operator new(0xD8u);
  v11 = v6;
  v14 = 0;
  if ( v6 )
    v5 = (int)CParam::CParam((CParam *)v6);
  v14 = -1;
  v11 = v5;
  if ( v5 )
  {
    if ( CParam::FInit((CParam *)v5, v9, hKey, &Name) )
      std::vector<CFilteredAdapter *,std::nc_allocator<CFilteredAdapter *>>::push_back(v4, (int)&v11);
    else
      CParam::`scalar deleting destructor'((void *)v5, 1);
    goto LABEL_9;
  }
}

//----- (6E68B2C0) --------------------------------------------------------
__int32 __thiscall CAdvancedParams::HrInit(CAdvancedParams *this, HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
{
  PSP_DEVINFO_DATA v3; // edi@1
  CAdvancedParams *v4; // esi@1
  __int32 result; // eax@1

  v3 = DeviceInfoData;
  v4 = this;
  result = HrSetupDiOpenDevRegKey(DeviceInfoSet, DeviceInfoData, 1u, 0, 2u, 0xF003Fu, (HKEY *)this);
  if ( result >= 0 )
  {
    result = HrRegOpenKeyEx(*(HKEY *)v4, L"Ndi\\Params", 0x2001Bu, (PHKEY)&DeviceInfoData);
    if ( result >= 0 )
    {
      CAdvancedParams::FillParamList(v4, *(HKEY *)v4, (HKEY)DeviceInfoData);
      RegSafeCloseKey((HKEY)DeviceInfoData);
      *((_DWORD *)v4 + 11) = 1;
      *((_DWORD *)v4 + 12) = DeviceInfoSet;
      *((_DWORD *)v4 + 13) = v3;
      result = 0;
    }
  }
  return result;
}

//----- (6E68B368) --------------------------------------------------------
void __thiscall CValue::Destroy(CValue *this)
{
  CValue *v1; // esi@1

  v1 = this;
  if ( !*((_DWORD *)this + 2) )
  {
    operator delete(*((void **)this + 7));
    *((_DWORD *)v1 + 7) = 0;
  }
  *((_DWORD *)v1 + 7) = 0;
  *(_DWORD *)v1 = 0;
}

//----- (6E68B38E) --------------------------------------------------------
void __thiscall CValue::SetNumericValue(CValue *this, unsigned __int32 a2)
{
  if ( *((_DWORD *)this + 1) != 1 )
  {
    if ( *((_DWORD *)this + 1) == 2 )
    {
LABEL_5:
      *((_DWORD *)this + 7) = a2;
      return;
    }
    if ( *((_DWORD *)this + 1) != 3 )
    {
      if ( *((_DWORD *)this + 1) != 4 )
        return;
      goto LABEL_5;
    }
  }
  *((_WORD *)this + 14) = a2;
}

//----- (6E68B3BB) --------------------------------------------------------
int __thiscall CValue::Compare(CValue *this, struct CValue *a2)
{
  int result; // eax@3
  signed int v3; // edx@9
  const WCHAR *v4; // ecx@15
  const WCHAR *v5; // eax@16
  unsigned int v6; // eax@19
  unsigned int v7; // ecx@19
  bool v8; // cf@19
  bool v9; // zf@19
  unsigned __int16 v10; // ax@20
  unsigned __int16 v11; // cx@20
  int v12; // eax@23
  int v13; // ecx@23
  int v14; // edx@24
  bool v15; // sf@24
  unsigned __int8 v16; // of@24
  __int16 v17; // ax@25
  __int16 v18; // cx@25

  if ( *((_DWORD *)this + 4) )
  {
    if ( !*((_DWORD *)a2 + 4) )
      return 1;
  }
  else
  {
    if ( !*((_DWORD *)a2 + 4) )
      return 0;
    if ( *((_DWORD *)a2 + 4) )
      return -1;
  }
  v3 = *((_DWORD *)this + 1);
  if ( v3 == 1 )
  {
    v17 = *((_WORD *)a2 + 14);
    v18 = *((_WORD *)this + 14);
    if ( v18 == v17 )
      return 0;
    v14 = 0;
    v16 = __OFSUB__(v18, v17);
    v15 = (signed __int16)(v18 - v17) < 0;
LABEL_27:
    LOBYTE(v14) = !(v15 ^ v16);
    return 2 * v14 - 1;
  }
  if ( v3 == 2 )
  {
    v12 = *((_DWORD *)a2 + 7);
    v13 = *((_DWORD *)this + 7);
    if ( v13 == v12 )
      return 0;
    v14 = 0;
    v16 = __OFSUB__(v13, v12);
    v15 = v13 - v12 < 0;
    goto LABEL_27;
  }
  if ( v3 == 3 )
  {
    v10 = *((_WORD *)a2 + 14);
    v11 = *((_WORD *)this + 14);
    v8 = v11 < v10;
    v9 = v11 == v10;
  }
  else
  {
    if ( v3 != 4 )
    {
      if ( v3 > 4 && v3 <= 6 )
      {
        v4 = (const WCHAR *)*((_DWORD *)this + 7);
        if ( v4 && (v5 = (const WCHAR *)*((_DWORD *)a2 + 7)) != 0 )
          result = lstrcmpW(v4, v5);
        else
          result = -2;
        return result;
      }
      return 1;
    }
    v6 = *((_DWORD *)a2 + 7);
    v7 = *((_DWORD *)this + 7);
    v8 = v7 < v6;
    v9 = v7 == v6;
  }
  if ( v9 )
    return 0;
  return v8 ? -1 : 1;
}

//----- (6E68B490) --------------------------------------------------------
unsigned __int32 __thiscall CValue::GetNumericValueAsDword(CValue *this)
{
  unsigned __int32 result; // eax@1

  result = 0;
  if ( *((_DWORD *)this + 1) == 1 )
  {
    result = *((_WORD *)this + 14);
  }
  else
  {
    if ( *((_DWORD *)this + 1) == 2 )
      return *((_DWORD *)this + 7);
    if ( *((_DWORD *)this + 1) != 3 )
    {
      if ( *((_DWORD *)this + 1) != 4 )
        return result;
      return *((_DWORD *)this + 7);
    }
    result = *((_WORD *)this + 14);
  }
  return result;
}

//----- (6E68B4B4) --------------------------------------------------------
void __thiscall CValue::Copy(CValue *this, struct CValue *a2)
{
  CValue *v2; // ebx@1
  const WCHAR *v3; // eax@2
  int v4; // eax@3
  void *v5; // eax@3
  const unsigned __int16 *v6; // ST08_4@4
  int v7; // eax@4

  v2 = this;
  CValue::Destroy(this);
  qmemcpy((void *)v2, (const void *)a2, 0x20u);
  if ( !*((_DWORD *)a2 + 2) )
  {
    v3 = (const WCHAR *)*((_DWORD *)a2 + 7);
    if ( v3 )
    {
      v4 = lstrlenW(v3);
      v5 = operator new(2 * (v4 + 1));
      *((_DWORD *)v2 + 7) = v5;
      if ( v5 )
      {
        v6 = (const unsigned __int16 *)*((_DWORD *)a2 + 7);
        v7 = lstrlenW(*((LPCWSTR *)a2 + 7));
        StringCchCopyW(*((unsigned __int16 **)v2 + 7), v7 + 1, v6);
      }
    }
  }
}

//----- (6E68B522) --------------------------------------------------------
int __thiscall CValue::FromString(CValue *this, const unsigned __int16 *const a2)
{
  CValue *v2; // esi@1
  int v3; // eax@4
  signed int v4; // ecx@6
  __int16 v5; // ax@12
  int v6; // eax@16
  void *v7; // eax@16
  int v9; // eax@18
  unsigned __int32 v10; // eax@19
  wchar_t *EndPtr; // [sp+Ch] [bp-208h]@12
  wchar_t Str; // [sp+10h] [bp-204h]@2

  v2 = this;
  if ( a2 )
  {
    StringCchCopyW(&Str, 0x100u, a2);
    StripSpaces(&Str);
  }
  else
  {
    Str = 0;
  }
  v3 = *((_DWORD *)v2 + 3) != 0 ? 16 : 10;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  if ( !Str )
    *((_DWORD *)v2 + 6) = 1;
  v4 = *((_DWORD *)v2 + 1);
  if ( v4 == 2 )
  {
    v10 = wcstol(&Str, &EndPtr, v3);
    goto LABEL_22;
  }
  if ( v4 == 3 )
  {
    v5 = wcstoul(&Str, &EndPtr, v3);
    goto LABEL_13;
  }
  if ( v4 == 4 )
  {
    v10 = wcstoul(&Str, &EndPtr, v3);
LABEL_22:
    *((_DWORD *)v2 + 7) = v10;
LABEL_23:
    if ( *EndPtr )
      *((_DWORD *)v2 + 5) = 1;
    return 1;
  }
  if ( v4 <= 4 )
  {
LABEL_12:
    v5 = wcstol(&Str, &EndPtr, v3);
LABEL_13:
    *((_WORD *)v2 + 14) = v5;
    goto LABEL_23;
  }
  if ( v4 <= 6 )
  {
    if ( *((_DWORD *)v2 + 7) )
    {
      operator delete(*((void **)v2 + 7));
      *((_DWORD *)v2 + 7) = 0;
    }
    v6 = lstrlenW(&Str);
    v7 = operator new(2 * (v6 + 1));
    *((_DWORD *)v2 + 7) = v7;
    if ( !v7 )
      return 0;
    v9 = lstrlenW(&Str);
    StringCchCopyW(*((unsigned __int16 **)v2 + 7), v9 + 1, &Str);
  }
  else if ( v4 != 7 )
  {
    goto LABEL_12;
  }
  return 1;
}

//----- (6E68B6A4) --------------------------------------------------------
int __thiscall CValue::ToString(CValue *this, wchar_t *Dst, unsigned int SizeInWords)
{
  signed int v3; // eax@1
  int v5; // [sp-4h] [bp-4h]@11
  int v6; // [sp-4h] [bp-4h]@14

  v3 = *((_DWORD *)this + 1);
  switch ( v3 )
  {
    case 1:
      swprintf_s(Dst, SizeInWords, L"%d", *((_WORD *)this + 14));
      break;
    case 2:
      swprintf_s(Dst, SizeInWords, L"%ld", *((_DWORD *)this + 7));
      break;
    case 3:
      v6 = *((_WORD *)this + 14);
      if ( *((_DWORD *)this + 3) )
        swprintf_s(Dst, SizeInWords, L"%-2X", v6);
      else
        swprintf_s(Dst, SizeInWords, L"%u", v6);
      break;
    case 4:
      v5 = *((_DWORD *)this + 7);
      if ( *((_DWORD *)this + 3) )
        swprintf_s(Dst, SizeInWords, L"%-2lX", v5);
      else
        swprintf_s(Dst, SizeInWords, L"%lu", v5);
      break;
    default:
      if ( v3 > 4 )
      {
        if ( v3 <= 6 )
        {
          StringCchCopyW(Dst, SizeInWords, *((const unsigned __int16 **)this + 7));
        }
        else if ( v3 == 7 )
        {
          StringCchCopyW(Dst, SizeInWords, L"1");
        }
      }
      break;
  }
  return 1;
}
// 6E68B73C: using guessed type wchar_t aLd[4];
// 6E68B744: using guessed type wchar_t a2x[5];
// 6E68B750: using guessed type wchar_t aLu[4];
// 6E68B758: using guessed type wchar_t a2lx[6];

//----- (6E68B769) --------------------------------------------------------
int __thiscall CValue::FLoadFromRegistry(CValue *this, HKEY hKey, LPCWSTR lpValueName, HKEY a4)
{
  HKEY v4; // eax@1
  CValue *v5; // esi@1
  int result; // eax@7
  DWORD Type; // [sp+Ch] [bp-20Ch]@5
  DWORD cbData; // [sp+10h] [bp-208h]@5
  unsigned __int16 Data[256]; // [sp+14h] [bp-204h]@5

  v4 = a4;
  v5 = this;
  *((_DWORD *)this + 3) = 0;
  if ( a4 == (HKEY)-1 )
    v4 = hKey;
  if ( Reg_QueryInt(v4, L"Base", 0xAu) == 16 )
    *((_DWORD *)v5 + 3) = 1;
  cbData = 512;
  if ( HrRegQueryValueEx(hKey, lpValueName, &Type, (LPBYTE)Data, &cbData) >= 0 && Data[0] )
  {
    *((_DWORD *)v5 + 4) = 1;
    result = CValue::FromString(v5, Data);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E68B825) --------------------------------------------------------
int __thiscall CValue::FSaveToRegistry(CValue *this, HKEY hKey, LPCWSTR lpValueName)
{
  CValue *v3; // esi@1
  int result; // eax@2
  unsigned int v5; // eax@3
  BYTE Data[2]; // [sp+Ch] [bp-204h]@1
  char Dst; // [sp+Eh] [bp-202h]@1

  *(_WORD *)Data = 0;
  v3 = this;
  memset(&Dst, 0, 0x1FEu);
  if ( *((_DWORD *)v3 + 4) )
  {
    CValue::ToString(v3, (wchar_t *)Data, 0x100u);
    v5 = CbOfSzAndTerm((const unsigned __int16 *)Data);
    result = RegSetValueExW(hKey, lpValueName, 0, 1u, Data, v5) == 0;
  }
  else
  {
    RegDeleteValueW(hKey, lpValueName);
    result = 1;
  }
  return result;
}

//----- (6E68B8C4) --------------------------------------------------------
int __thiscall CValue::Init(int this, int a2, int a3)
{
  int result; // eax@4

  *(_DWORD *)this = 1;
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)(this + 16) = 1;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  if ( a2 == 6 || a2 == 5 || a2 == 7 )
  {
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 28) = 0;
    result = CValue::FromString((CValue *)this, 0);
  }
  else
  {
    *(_DWORD *)(this + 8) = 1;
    result = a3;
    *(_DWORD *)(this + 28) = a3;
  }
  return result;
}

//----- (6E68B910) --------------------------------------------------------
int __thiscall CValue::InitNotPresent(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@1

  v2 = this;
  result = CValue::Init(this, a2, 0);
  *(_DWORD *)(v2 + 16) = 0;
  return result;
}

//----- (6E68B930) --------------------------------------------------------
CParam *__thiscall CParam::CParam(CParam *this)
{
  CParam *v1; // esi@1

  v1 = this;
  CValue::CValue(this);
  CValue::CValue((char *)v1 + 32);
  CValue::CValue((char *)v1 + 64);
  CValue::CValue((char *)v1 + 96);
  CValue::CValue((char *)v1 + 128);
  *((_DWORD *)v1 + 40) = 0;
  *((_DWORD *)v1 + 41) = 0;
  *((_DWORD *)v1 + 42) = 0;
  *((_DWORD *)v1 + 43) = 0;
  *((_DWORD *)v1 + 44) = 0;
  *((_DWORD *)v1 + 45) = 0;
  *((_DWORD *)v1 + 46) = 0;
  *((_DWORD *)v1 + 47) = 0;
  *((_DWORD *)v1 + 48) = 0;
  *((_DWORD *)v1 + 49) = 0;
  *((_DWORD *)v1 + 50) = 0;
  *((_DWORD *)v1 + 51) = 0;
  *((_DWORD *)v1 + 52) = 0;
  *((_DWORD *)v1 + 53) = 0;
  return v1;
}
// 6E68B347: using guessed type int __thiscall CValue::CValue(_DWORD);

//----- (6E68B9DB) --------------------------------------------------------
void __thiscall CParam::InitParamType(CParam *this, unsigned __int16 *lpString2)
{
  int v2; // edi@1
  LPCWSTR *v3; // ebx@1
  wchar_t **v4; // esi@2
  int v5; // ecx@6
  unsigned int v6; // [sp+Ch] [bp-4h]@1

  v6 = 0;
  v2 = (int)this;
  v3 = (LPCWSTR *)&off_6E69BC50;
  do
  {
    v4 = (wchar_t **)v3;
    if ( !lstrcmpiW(*v3, lpString2) )
      break;
    ++v6;
    v3 += 4;
  }
  while ( v6 < 7 );
  if ( v6 >= 7 )
    v4 = &off_6E69BC50;
  *(_DWORD *)(v2 + 164) = v4[1];
  CValue::Init(v2, (int)v4[1], 0);
  CValue::Init(v2 + 32, (int)v4[1], 0);
  v5 = v2 + 64;
  if ( *(_DWORD *)(v2 + 8) )
  {
    CValue::Init(v5, (int)v4[1], (int)v4[2]);
    CValue::Init(v2 + 96, (int)v4[1], (int)v4[3]);
    CValue::Init(v2 + 128, (int)v4[1], 1);
  }
  else
  {
    CValue::Init(v5, (int)v4[1], 0);
    CValue::Init(v2 + 96, (int)v4[1], 0);
    CValue::Init(v2 + 128, (int)v4[1], 0);
  }
}
// 6E69BC50: using guessed type wchar_t *off_6E69BC50;

//----- (6E68BA8E) --------------------------------------------------------
int __thiscall CParam::~CParam(CParam *this)
{
  CParam *v1; // esi@1

  v1 = this;
  RegSafeCloseKey(*((HKEY *)this + 48));
  operator delete(*((void **)v1 + 43));
  operator delete(*((void **)v1 + 44));
  operator delete(*((void **)v1 + 45));
  CValue::Destroy(v1);
  CValue::Destroy((CParam *)((char *)v1 + 32));
  CValue::Destroy((CParam *)((char *)v1 + 64));
  CValue::Destroy((CParam *)((char *)v1 + 96));
  CValue::Destroy((CParam *)((char *)v1 + 128));
  sub_6E647CC1((char *)v1 + 128);
  sub_6E647CC1((char *)v1 + 96);
  sub_6E647CC1((char *)v1 + 64);
  sub_6E647CC1((char *)v1 + 32);
  return sub_6E647CC1(v1);
}

//----- (6E68BB4A) --------------------------------------------------------
int __thiscall CParam::Apply(CParam *this)
{
  CParam *v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *((_DWORD *)this + 50) )
  {
    *((_DWORD *)this + 50) = 0;
    CValue::Copy((CParam *)((char *)this + 32), this);
    result = CValue::FSaveToRegistry(v1, *((HKEY *)v1 + 42), *((LPCWSTR *)v1 + 43));
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6E68BB85) --------------------------------------------------------
signed int __thiscall CParam::Validate(CParam *this)
{
  CParam *v1; // esi@1
  signed int result; // eax@2
  unsigned __int32 v3; // ebx@14
  unsigned int v4; // edi@14

  v1 = this;
  if ( CValue::Compare(this, (CParam *)((char *)this + 32)) && (!*((_DWORD *)v1 + 49) || *((_DWORD *)v1 + 4)) )
  {
    if ( *((_DWORD *)v1 + 5) )
    {
      result = 1;
    }
    else if ( *((_DWORD *)v1 + 6) && *((_DWORD *)v1 + 4) && *((_DWORD *)v1 + 1) != 7 )
    {
      result = 2;
    }
    else if ( *((_DWORD *)v1 + 2)
           && (CValue::Compare(v1, (CParam *)((char *)v1 + 64)) < 0
            || CValue::Compare(v1, (CParam *)((char *)v1 + 96)) > 0
            || (v3 = CValue::GetNumericValueAsDword((CParam *)((char *)v1 + 64)),
                v4 = CValue::GetNumericValueAsDword(v1) - v3,
                v4 % CValue::GetNumericValueAsDword((CParam *)((char *)v1 + 128)))) )
    {
      result = 3;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E68BC29) --------------------------------------------------------
int __thiscall CParam::FInit(CParam *this, HKEY a2, HKEY a3, LPCWSTR lpString)
{
  CParam *v4; // esi@1
  int v5; // eax@1
  void *v6; // eax@1
  int v8; // eax@3
  const unsigned __int16 *v9; // eax@7
  int v10; // eax@8
  void *v11; // eax@8
  int v12; // eax@9
  HKEY v13; // ST08_4@9
  HKEY v14; // ST00_4@11
  int v15; // eax@12
  void *v16; // eax@12
  int v17; // eax@13
  int v18; // eax@18
  HKEY v19; // ST08_4@19
  unsigned int v20; // eax@19
  HKEY v21; // ST08_4@21
  HKEY v22; // ST08_4@23
  HKEY v23; // ST08_4@25
  HKEY v24; // ST10_4@30
  const WCHAR *v25; // ST0C_4@30
  HKEY v26; // ST10_4@38
  DWORD Type; // [sp+10h] [bp-110h]@4
  DWORD cbData; // [sp+14h] [bp-10Ch]@4
  HKEY phkResult; // [sp+18h] [bp-108h]@3
  WCHAR String; // [sp+1Ch] [bp-104h]@4

  v4 = this;
  *((_DWORD *)this + 42) = a2;
  v5 = lstrlenW(lpString);
  v6 = operator new(2 * (v5 + 1));
  *((_DWORD *)v4 + 43) = v6;
  if ( !v6 )
    return 0;
  v8 = lstrlenW(lpString);
  StringCchCopyW(*((unsigned __int16 **)v4 + 43), v8 + 1, lpString);
  if ( HrRegOpenKeyEx(a3, lpString, 0x20019u, &phkResult) < 0 )
    return 0;
  cbData = 256;
  if ( HrRegQueryValueEx(phkResult, L"Type", &Type, (LPBYTE)&String, &cbData) < 0 )
    String = 0;
  CParam::InitParamType(v4, &String);
  cbData = 256;
  if ( HrRegQueryValueEx(phkResult, L"ParamDesc", &Type, (LPBYTE)&String, &cbData) < 0 )
  {
    v9 = SzLoadIds(0x3A9Au);
    StringCbCopyW(&String, cbData, v9);
  }
  v10 = lstrlenW(&String);
  v11 = operator new(2 * (v10 + 1));
  *((_DWORD *)v4 + 44) = v11;
  if ( !v11 )
    return 0;
  v12 = lstrlenW(&String);
  StringCchCopyW(*((unsigned __int16 **)v4 + 44), v12 + 1, &String);
  v13 = phkResult;
  *((_DWORD *)v4 + 49) = 0;
  if ( Reg_QueryInt(v13, L"Optional", 0) )
    *((_DWORD *)v4 + 49) = 1;
  v14 = phkResult;
  *((_DWORD *)v4 + 45) = 0;
  *((_DWORD *)v4 + 46) = 0;
  cbData = 256;
  if ( HrRegQueryValueEx(v14, L"HelpFile", &Type, (LPBYTE)&String, &cbData) < 0 )
    goto LABEL_14;
  v15 = lstrlenW(&String);
  v16 = operator new(2 * (v15 + 1));
  *((_DWORD *)v4 + 45) = v16;
  if ( !v16 )
    return 0;
  v17 = lstrlenW(&String);
  StringCchCopyW(*((unsigned __int16 **)v4 + 45), v17 + 1, &String);
  *((_DWORD *)v4 + 46) = Reg_QueryInt(phkResult, L"HelpContext", 0);
LABEL_14:
  if ( *((_DWORD *)v4 + 2) )
  {
    CValue::FLoadFromRegistry((CParam *)((char *)v4 + 128), phkResult, L"Step", (HKEY)0xFFFFFFFF);
    if ( !CValue::GetNumericValueAsDword((CParam *)((char *)v4 + 128)) )
      CValue::SetNumericValue((CParam *)((char *)v4 + 128), 1u);
    CValue::FLoadFromRegistry((CParam *)((char *)v4 + 64), phkResult, L"Min", (HKEY)0xFFFFFFFF);
    CValue::FLoadFromRegistry((CParam *)((char *)v4 + 96), phkResult, L"Max", (HKEY)0xFFFFFFFF);
  }
  else
  {
    v18 = *((_DWORD *)v4 + 41);
    if ( v18 == 6 )
    {
      v19 = phkResult;
      *((_DWORD *)v4 + 47) = 255;
      v20 = Reg_QueryInt(v19, L"LimitText", 0xFFu);
      if ( v20 - 1 <= 0xFE )
        *((_DWORD *)v4 + 47) = v20;
      v21 = phkResult;
      *((_DWORD *)v4 + 51) = 0;
      if ( Reg_QueryInt(v21, L"ReadOnly", 0) )
        *((_DWORD *)v4 + 51) = 1;
      v22 = phkResult;
      *((_DWORD *)v4 + 52) = 0;
      if ( Reg_QueryInt(v22, L"OEMText", 0) )
        *((_DWORD *)v4 + 52) = 1;
      v23 = phkResult;
      *((_DWORD *)v4 + 53) = 0;
      if ( Reg_QueryInt(v23, L"Uppercase", 0) )
        *((_DWORD *)v4 + 53) = 1;
    }
    else if ( v18 == 5 && HrRegOpenKeyEx(phkResult, L"enum", 0x20019u, (PHKEY)v4 + 48) < 0 )
    {
      *((_DWORD *)v4 + 48) = 0;
    }
  }
  v24 = phkResult;
  v25 = (const WCHAR *)*((_DWORD *)v4 + 43);
  *((_DWORD *)v4 + 50) = 0;
  if ( !CValue::FLoadFromRegistry(v4, *((HKEY *)v4 + 42), v25, v24) )
  {
    if ( !CValue::FLoadFromRegistry(v4, phkResult, L"Default", (HKEY)0xFFFFFFFF) )
    {
      if ( *((_DWORD *)v4 + 2) )
        CValue::Copy(v4, (CParam *)((char *)v4 + 64));
      else
        CValue::FromString(v4, &::String);
    }
    if ( *((_DWORD *)v4 + 49) )
      *((_DWORD *)v4 + 4) = 0;
    else
      *((_DWORD *)v4 + 50) = 1;
  }
  CValue::Copy((CParam *)((char *)v4 + 32), v4);
  v26 = phkResult;
  *((_DWORD *)v4 + 40) = 1;
  RegSafeCloseKey(v26);
  return 1;
}

//----- (6E68C10D) --------------------------------------------------------
void __thiscall CParam::GetDescription(CParam *this, unsigned __int16 *a2, unsigned int a3)
{
  StringCchCopyW(a2, a3, *((const unsigned __int16 **)this + 44));
}

//----- (6E68C12C) --------------------------------------------------------
void __stdcall StripSpaces(unsigned __int16 *Dst)
{
  unsigned __int16 *i; // edi@1
  unsigned int v2; // eax@3
  unsigned int j; // eax@4

  for ( i = Dst; *i == 32; ++i )
    ;
  v2 = CbOfSzAndTerm(i);
  memmove(Dst, i, v2);
  if ( lstrlenW(Dst) > 0 )
  {
    for ( j = (unsigned int)&Dst[lstrlenW(Dst) - 1]; j >= (unsigned int)Dst && *(_WORD *)j == 32; j -= 2 )
      ;
    *(_WORD *)(j + 2) = 0;
  }
}

//----- (6E68C18A) --------------------------------------------------------
unsigned int __stdcall Reg_QueryInt(HKEY hKey, LPCWSTR lpValueName, unsigned int a3)
{
  unsigned int result; // eax@2
  DWORD Type; // [sp+0h] [bp-2Ch]@1
  DWORD cbData; // [sp+4h] [bp-28h]@1
  wchar_t Str; // [sp+8h] [bp-24h]@1

  cbData = 32;
  if ( HrRegQueryValueEx(hKey, lpValueName, &Type, (LPBYTE)&Str, &cbData) < 0 )
    result = a3;
  else
    result = _wtoi(&Str);
  return result;
}

//----- (6E68C1E2) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::Install(CSrvrcfg *this, unsigned __int32 a2)
{
  *((_DWORD *)this + 14) = 1;
  *((_DWORD *)this + 16) = 1;
  if ( a2 & 0x40 )
  {
    *((_DWORD *)this + 18) = 1;
LABEL_5:
    *((_DWORD *)this + 17) = 1;
    return 0;
  }
  if ( a2 & 0x80 || a2 & 0x100 )
    goto LABEL_5;
  return 0;
}

//----- (6E68C21B) --------------------------------------------------------
signed int __stdcall CSrvrcfg::Upgrade(CSrvrcfg *this, unsigned __int32 a2, unsigned __int32 a3)
{
  return 1;
}

//----- (6E68C226) --------------------------------------------------------
signed int __stdcall CSrvrcfg::MergePropPages(CSrvrcfg *this, unsigned __int32 *a2, unsigned __int8 **a3, unsigned int *a4, HWND hWnd, const unsigned __int16 **a6)
{
  signed int result; // eax@2
  signed int v7; // [sp+8h] [bp-8h]@1
  struct _PSP **v8; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  v8 = 0;
  if ( FBadArgs_INetCfgProperties_MergePropPages(a2, a3, a4, hWnd, a6) )
  {
    result = -2147024809;
  }
  else
  {
    *a2 = 0;
    if ( *((_DWORD *)this + 19) == 1 )
    {
      *a4 = 0;
    }
    else
    {
      v7 = CSrvrcfg::HrSetupPropSheets((CSrvrcfg *)((char *)this - 8), &v8, 1);
      if ( v7 >= 0 )
      {
        *a3 = (unsigned __int8 *)v8;
        *a4 = 1;
      }
    }
    result = v7;
  }
  return result;
}

//----- (6E68C297) --------------------------------------------------------
__int32 __thiscall CSrvrcfg::HrRestoreRegistry(CSrvrcfg *this)
{
  CSrvrcfg *v1; // esi@1
  __int32 v2; // edi@1
  const WCHAR *v3; // eax@8
  unsigned __int32 v4; // eax@14
  const WCHAR *v5; // eax@21
  const WCHAR *v6; // eax@27
  BYTE Data[4]; // [sp+Ch] [bp-10h]@15
  PTOKEN_PRIVILEGES NewState; // [sp+10h] [bp-Ch]@1
  HKEY phkResult; // [sp+14h] [bp-8h]@1
  HKEY hKey; // [sp+18h] [bp-4h]@6

  v1 = this;
  v2 = 0;
  NewState = 0;
  phkResult = 0;
  if ( *((_DWORD *)this + 41) || *((_DWORD *)this + 34) || *((_DWORD *)this + 27) )
  {
    v2 = HrEnableAllPrivileges(&NewState);
    if ( v2 >= 0 )
    {
      if ( *((_DWORD *)v1 + 41)
        && HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
             0xF003Fu,
             &hKey) >= 0 )
      {
        if ( *((_DWORD *)v1 + 42) < 8u )
          v3 = (const WCHAR *)((char *)v1 + 148);
        else
          v3 = (const WCHAR *)*((_DWORD *)v1 + 37);
        if ( HrRegRestoreKey(hKey, v3, 0) >= 0 )
          phkResult = (HKEY)1;
        RegCloseKey(hKey);
        if ( phkResult )
        {
          phkResult = 0;
          if ( HrRegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
                 0xF003Fu,
                 &phkResult) >= 0 )
          {
            v4 = CchOfMultiSzAndTermSafe((const unsigned __int16 *)L"%SystemRoot%\\System32\\srvsvc.dll");
            if ( HrRegSetValueEx(phkResult, L"ServiceDll", 2u, L"%SystemRoot%\\System32\\srvsvc.dll", 2 * v4) >= 0 )
            {
              *(_DWORD *)Data = 1;
              HrRegSetValueEx(phkResult, L"RestrictNullSessAccess", 4u, Data, 4u);
            }
          }
          RegSafeCloseKey(phkResult);
          if ( HrRegAddStringToMultiSz(
                 L"TrkWks",
                 HKEY_LOCAL_MACHINE,
                 L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
                 L"NullSessionPipes",
                 4u,
                 0) >= 0 )
            HrRegAddStringToMultiSz(
              L"TrkSrv",
              HKEY_LOCAL_MACHINE,
              L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
              L"NullSessionPipes",
              4u,
              0);
        }
      }
      if ( *((_DWORD *)v1 + 34)
        && HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LanmanServer\\Shares",
             0xF003Fu,
             &hKey) >= 0 )
      {
        if ( *((_DWORD *)v1 + 35) < 8u )
          v5 = (const WCHAR *)((char *)v1 + 120);
        else
          v5 = (const WCHAR *)*((_DWORD *)v1 + 30);
        HrRegRestoreKey(hKey, v5, 0);
        RegCloseKey(hKey);
      }
      if ( *((_DWORD *)v1 + 27)
        && HrRegOpenKeyEx(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Services\\LanmanServer\\AutotunedParameters",
             0xF003Fu,
             &hKey) >= 0 )
      {
        if ( *((_DWORD *)v1 + 28) < 8u )
          v6 = (const WCHAR *)((char *)v1 + 92);
        else
          v6 = (const WCHAR *)*((_DWORD *)v1 + 23);
        HrRegRestoreKey(hKey, v6, 0);
        RegCloseKey(hKey);
      }
      v2 = HrRestorePrivileges(NewState);
      operator delete(NewState);
      *((_DWORD *)v1 + 20) = 1;
    }
  }
  return v2;
}

//----- (6E68C6AF) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::ApplyRegistryChanges(CSrvrcfg *this)
{
  __int32 result; // eax@1

  result = 0;
  if ( *((_DWORD *)this + 18) )
  {
    if ( !*((_DWORD *)this + 20) )
    {
      result = CSrvrcfg::HrRestoreRegistry(this);
      if ( result < 0 )
        result = 0;
    }
  }
  if ( *((_DWORD *)this + 15) )
    result = CSrvrcfg::HrSetRegistryInfo(this);
  return result;
}

//----- (6E68C6E8) --------------------------------------------------------
__int32 __thiscall CSrvrcfg::HrProcessAnswerFile(CSrvrcfg *this, PCWSTR FileName, const unsigned __int16 *a3)
{
  CSrvrcfg *v3; // esi@1
  bool v4; // cf@5
  void *v5; // eax@5
  void *v6; // eax@9
  void *v7; // eax@13
  void *v8; // eax@17
  __int32 v9; // esi@22
  HINF InfHandle; // [sp+10h] [bp-30h]@1
  int v12; // [sp+14h] [bp-2Ch]@1
  LPCWSTR lpString1; // [sp+18h] [bp-28h]@5
  unsigned int v14; // [sp+2Ch] [bp-14h]@5
  int v15; // [sp+3Ch] [bp-4h]@1

  v3 = this;
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v12);
  v15 = 0;
  InfHandle = 0;
  LOBYTE(v15) = 1;
  if ( HrSetupOpenInfFile(FileName, 0, 3u, 0, &InfHandle) < 0 )
    goto LABEL_23;
  if ( *((_DWORD *)v3 + 18) )
  {
    HrSetupGetFirstString(InfHandle, a3, L"LanmanServer.Parameters", (int)((char *)v3 + 144));
    HrSetupGetFirstString(InfHandle, a3, L"LanmanServer.Shares", (int)((char *)v3 + 116));
    HrSetupGetFirstString(InfHandle, a3, L"LanmanServer.AutotunedParameters", (int)((char *)v3 + 88));
  }
  if ( HrSetupGetFirstString(InfHandle, a3, L"Optimization", (int)&v12) < 0 )
    goto LABEL_22;
  v4 = v14 < 8;
  v5 = (void *)lpString1;
  *((_DWORD *)v3 + 15) = 1;
  if ( v4 )
    v5 = &lpString1;
  if ( !lstrcmpiW((LPCWSTR)v5, L"MinMemoryUsed") )
  {
    *((_DWORD *)v3 + 10) = 1;
    goto LABEL_22;
  }
  v6 = (void *)lpString1;
  if ( v14 < 8 )
    v6 = &lpString1;
  if ( !lstrcmpiW((LPCWSTR)v6, L"Balance") )
  {
    *((_DWORD *)v3 + 10) = 2;
    goto LABEL_22;
  }
  v7 = (void *)lpString1;
  if ( v14 < 8 )
    v7 = &lpString1;
  if ( !lstrcmpiW((LPCWSTR)v7, L"MaxThroughputForFileSharing") )
  {
    *((_DWORD *)v3 + 12) = 1;
LABEL_21:
    *((_DWORD *)v3 + 10) = 3;
    goto LABEL_22;
  }
  v8 = (void *)lpString1;
  if ( v14 < 8 )
    v8 = &lpString1;
  if ( !lstrcmpiW((LPCWSTR)v8, L"MaxThroughputForNetworkApps") )
  {
    *((_DWORD *)v3 + 12) = 0;
    goto LABEL_21;
  }
LABEL_22:
  v9 = HrSetupGetFirstStringAsBool(InfHandle, a3, L"BroadcastsToLanman2Clients", (int *)v3 + 11);
  if ( v9 < 0 )
LABEL_23:
    v9 = 0;
  LOBYTE(v15) = 0;
  CSetupInfFile::EnsureClosed((CSetupInfFile *)&InfHandle);
  std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
    (int)&v12,
    1,
    0);
  return v9;
}

//----- (6E68C9ED) --------------------------------------------------------
__int32 __stdcall CSrvrcfg::ReadAnswerFile(CSrvrcfg *this, PCWSTR FileName, const unsigned __int16 *a3)
{
  __int32 result; // eax@1

  result = 0;
  if ( a3 && FileName )
  {
    result = CSrvrcfg::HrProcessAnswerFile((CSrvrcfg *)((char *)this - 4), FileName, a3);
    if ( result < 0 )
      result = 0;
  }
  return result;
}

//----- (6E68CA1E) --------------------------------------------------------
__int32 __thiscall CSrvrcfg::HrSetRegistryInfo(CSrvrcfg *this)
{
  CSrvrcfg *v1; // esi@1
  __int32 v2; // edi@1
  HKEY hKey; // [sp+8h] [bp-4h]@1

  v1 = this;
  v2 = HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
         0xF003Fu,
         &hKey);
  if ( v2 >= 0 )
  {
    v2 = HrRegSetDword(hKey, L"Lmannounce", *((_DWORD *)v1 + 11));
    if ( v2 >= 0 )
      v2 = HrRegSetDword(hKey, L"Size", *((_DWORD *)v1 + 10));
    RegCloseKey(hKey);
    if ( v2 >= 0 )
      v2 = HrRegSetDword(*((HKEY *)v1 + 16), L"LargeSystemCache", *((_DWORD *)v1 + 12));
  }
  return v2;
}

//----- (6E68CA98) --------------------------------------------------------
int __thiscall CServerConfigDlg::ProcessWindowMessage(CServerConfigDlg *this, HWND a2, unsigned int a3, unsigned int a4, struct tagNMHDR *a5, CPropSheetPage *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3

  if ( a7 )
    return 0;
  if ( a3 == 272 )
  {
    a3 = 1;
    v7 = CServerConfigDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a3);
  }
  else
  {
    if ( a3 != 78 )
    {
      if ( a3 != 273 || 203 != (_WORD)a4 && 201 != (_WORD)a4 && 202 != (_WORD)a4 && 204 != (_WORD)a4 && 200 != (_WORD)a4 )
        return 0;
      a3 = 1;
      CPropSheetPage::SetChangedFlag(this);
      *(_DWORD *)a6 = 0;
      goto LABEL_5;
    }
    if ( a5->code != -202 )
      return 0;
    a3 = 1;
    v7 = CServerConfigDlg::OnOk(this, a4, a5, (int *)&a3);
  }
  *(_DWORD *)a6 = v7;
LABEL_5:
  if ( a3 )
    return 1;
  return 0;
}

//----- (6E68CB56) --------------------------------------------------------
void *__thiscall CServerConfigDlg::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CPropSheetPage::~CPropSheetPage((CPropSheetPage *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68CB7C) --------------------------------------------------------
signed int __thiscall CSrvrcfg::HrSetupPropSheets(CSrvrcfg *this, struct _PSP ***a2, int a3)
{
  CSrvrcfg *v3; // esi@1
  struct _PSP **v4; // ebx@2
  void *v5; // eax@5
  signed int v7; // [sp+Ch] [bp-4h]@1

  v3 = this;
  *a2 = 0;
  v7 = 0;
  if ( (unsigned int)(4 * a3) >> 2 >= a3 && (v4 = (struct _PSP **)CoTaskMemAlloc(4 * a3)) != 0 )
  {
    if ( !*((_DWORD *)v3 + 14) )
    {
      v5 = operator new(0xCu);
      if ( v5 )
      {
        *((_DWORD *)v5 + 1) = 0;
        *(_DWORD *)v5 = &CServerConfigDlg::`vftable';
        *((_DWORD *)v5 + 2) = v3;
      }
      else
      {
        v5 = 0;
      }
      *((_DWORD *)v3 + 14) = v5;
    }
    *v4 = CPropSheetPage::CreatePage(*((CPropSheetPage **)v3 + 14), 2200, 0, 0, 0, 0, 0);
    *a2 = v4;
  }
  else
  {
    v7 = -2147024882;
    CoTaskMemFree(0);
  }
  return v7;
}
// 6E68CC08: using guessed type int (__thiscall *CServerConfigDlg::`vftable')(CServerConfigDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CPropSheetPage *, unsigned __int32);

//----- (6E68CC1D) --------------------------------------------------------
signed int __thiscall CServerConfigDlg::OnInitDialog(CServerConfigDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CServerConfigDlg *v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1

  v5 = this;
  v6 = *((_DWORD *)this + 2) + 40;
  v7 = 0;
  switch ( *(_DWORD *)v6 )
  {
    case 1:
      v7 = 203;
      break;
    case 2:
      v7 = 201;
      break;
    case 3:
      v7 = 2 * (*(_DWORD *)(v6 + 8) == 0) + 202;
      break;
  }
  CheckDlgButton(*((HWND *)v5 + 1), v7, 1u);
  CheckDlgButton(*((HWND *)v5 + 1), 200, *(_DWORD *)(v6 + 4));
  return 1;
}

//----- (6E68CC7D) --------------------------------------------------------
__int32 __thiscall CServerConfigDlg::OnOk(CServerConfigDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CServerConfigDlg *v4; // edi@1
  int v5; // esi@1
  signed int v6; // ebx@1
  int v7; // ebx@4

  v4 = this;
  v5 = *((_DWORD *)this + 2) + 40;
  v6 = 0;
  do
  {
    if ( IsDlgButtonChecked(*((HWND *)v4 + 1), *(&nIDButton + v6)) )
      break;
    ++v6;
  }
  while ( v6 < 4 );
  v7 = v6 + 1;
  *(_DWORD *)(v5 + 8) = v7 == 3;
  if ( v7 >= 3 )
    v7 = 3;
  *(_DWORD *)v5 = v7;
  *(_DWORD *)(v5 + 4) = IsDlgButtonChecked(*((HWND *)v4 + 1), 200);
  *(_DWORD *)(*((_DWORD *)v4 + 2) + 60) = 1;
  return 0;
}

//----- (6E68CD0B) --------------------------------------------------------
signed int __stdcall HrGetINetCfg(HWND hWnd, struct INetCfg **pv, struct INetCfgLock **a3)
{
  struct INetCfgLock **v3; // eax@1
  struct INetCfg **v4; // ebx@1
  HRESULT v5; // esi@1
  struct IUnknownVtbl *v6; // esi@3
  const unsigned __int16 *v7; // eax@3
  int v8; // eax@3
  struct INetCfg **v9; // eax@6
  struct INetCfgLock *v10; // ecx@12
  LPVOID ppv; // [sp+Ch] [bp-8h]@1
  struct IUnknown *v13; // [sp+10h] [bp-4h]@1

  v3 = a3;
  v4 = pv;
  *pv = 0;
  *v3 = 0;
  ppv = 0;
  v13 = 0;
  v5 = CoCreateInstance(&CLSID_CNetCfg, 0, 0x401u, &IID_INetCfg, &ppv);
  if ( v5 < 0 )
    return v5;
  v5 = (**(int (__stdcall ***)(LPVOID, GUID *, struct IUnknown **))ppv)(ppv, &IID_INetCfgLock, &v13);
  if ( v5 < 0 )
    return v5;
  v6 = v13->lpVtbl;
  v7 = SzLoadIds(0x620Cu);
  v8 = ((int (__stdcall *)(struct IUnknown *, _DWORD, const unsigned __int16 *, struct INetCfg ***))v6[1].QueryInterface)(
         v13,
         0,
         v7,
         &pv);
  v5 = v8;
  if ( !v8 )
  {
    v5 = (*(int (__stdcall **)(LPVOID, _DWORD))(*(_DWORD *)ppv + 12))(ppv, 0);
LABEL_11:
    if ( v5 >= 0 )
    {
      v10 = (struct INetCfgLock *)v13;
      *v4 = (struct INetCfg *)ppv;
      *a3 = v10;
    }
    return v5;
  }
  if ( v8 != 1 )
  {
    if ( v8 == -2147180507 )
    {
      NcMsgBox(hWnd, 0x620Eu, 0x6216u, 0x10u);
      ReleaseObj(v13);
      v13 = 0;
    }
    goto LABEL_11;
  }
  v9 = pv;
  if ( !pv )
    v9 = (struct INetCfg **)SzLoadIds(0x6210u);
  NcMsgBox(hWnd, 0x620Eu, 0x620Fu, 0x10u, v9);
  CoTaskMemFree(pv);
  ReleaseObj(v13);
  return -2147467259;
}

//----- (6E68CE24) --------------------------------------------------------
CBindingsDlg *__thiscall CBindingsDlg::CBindingsDlg(CBindingsDlg *this, struct INetCfg *a2)
{
  CBindingsDlg *v2; // esi@1

  v2 = this;
  *((_DWORD *)this + 1) = 0;
  *(_DWORD *)this = &CBindingsDlg::`vftable';
  *((_DWORD *)this + 2) = a2;
  AddRefObj((struct IUnknown *)a2);
  *((_DWORD *)v2 + 9) = -1;
  *((_DWORD *)v2 + 5) = 0;
  *((_DWORD *)v2 + 6) = 0;
  *((_DWORD *)v2 + 7) = 0;
  *((_DWORD *)v2 + 8) = 0;
  *((_DWORD *)v2 + 10) = 0;
  return v2;
}
// 6E6479B4: using guessed type int (__thiscall *CBindingsDlg::`vftable')(CBindingsDlg *this, HWND, unsigned __int32, CSrvrcfg *, HWND, CBindingsDlg *, unsigned __int32);

//----- (6E68CE64) --------------------------------------------------------
int __thiscall CBindingsDlg::ProcessWindowMessage(CBindingsDlg *this, HWND a2, unsigned __int32 a3, CSrvrcfg *a4, HWND a5, CBindingsDlg *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  bool v8; // zf@4
  unsigned __int32 v10; // ebx@8
  CBindingsDlg *v11; // edi@8
  __int32 v12; // eax@9
  __int32 v13; // eax@11
  signed int v14; // eax@13
  signed int v15; // eax@15
  __int32 v16; // eax@17
  __int32 v17; // eax@19
  __int32 v18; // eax@21
  __int32 v19; // eax@23
  __int32 v20; // eax@25
  CBindingsDlg *v21; // [sp+Ch] [bp-4h]@1

  v21 = this;
  if ( a7 )
    return 0;
  if ( a3 == 272 )
  {
    a3 = 1;
    v7 = CBindingsDlg::OnInitDialog(this, 0x110u, (unsigned int)a4, (__int32)a5, (int *)&a3);
LABEL_4:
    v8 = a3 == 0;
    *(_DWORD *)a6 = v7;
    goto LABEL_5;
  }
  if ( a3 != 78 )
  {
    if ( a3 != 273 )
      return 0;
    switch ( (_WORD)a4 )
    {
      case 0x61A9:
        a3 = 1;
        v7 = CBindingsDlg::OnAdapterUp(this, HIWORD(a4), 0x61A9u, a5, (int *)&a3);
        break;
      case 0x61AA:
        a3 = 1;
        v7 = CBindingsDlg::OnAdapterDown(this, HIWORD(a4), 0x61AAu, a5, (int *)&a3);
        break;
      case 0x61AC:
        a3 = 1;
        v7 = CBindingsDlg::OnBindingUp(this, HIWORD(a4), 0x61ACu, a5, (int *)&a3);
        break;
      default:
        if ( 25005 != (_WORD)a4 )
          return 0;
        a3 = 1;
        v7 = CBindingsDlg::OnBindingDown(this, HIWORD(a4), 0x61ADu, a5, (int *)&a3);
        break;
    }
    goto LABEL_4;
  }
  v10 = (unsigned __int32)a5;
  v11 = a6;
  if ( *((_DWORD *)a5 + 2) == -202 )
  {
    a3 = 1;
    v12 = CBindingsDlg::OnOk(this, (int)a4, (struct tagNMHDR *)a5, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v12;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -458 )
  {
    a3 = 1;
    v13 = CBindingsDlg::OnTreeDeleteItem((int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v13;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -412 )
  {
    a3 = 1;
    v14 = CBindingsDlg::OnTreeKeyDown(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v14;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -454 )
  {
    a3 = 1;
    v15 = CSrvrcfg::Upgrade(a4, v10, (unsigned __int32)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v15;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -451 )
  {
    a3 = 1;
    v16 = CBindingsDlg::OnTreeItemChanged(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v16;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -103 )
  {
    a3 = 1;
    v17 = CBindingsDlg::OnListDeleteItem(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v17;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -101 )
  {
    a3 = 1;
    v18 = CBindingsDlg::OnListItemChanged(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v18;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -3 )
  {
    a3 = 1;
    v19 = CBindingsDlg::OnDoubleClick(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v19;
    if ( !v8 )
      return 1;
  }
  if ( *(_DWORD *)(v10 + 8) == -2 )
  {
    a3 = 1;
    v20 = CBindingsDlg::OnClick(v21, (int)a4, (struct tagNMHDR *)v10, (int *)&a3);
    v8 = a3 == 0;
    *(_DWORD *)v11 = v20;
LABEL_5:
    if ( !v8 )
      return 1;
  }
  return 0;
}

//----- (6E68D0D5) --------------------------------------------------------
void *__thiscall CBindingsDlg::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CBindingsDlg::~CBindingsDlg((CBindingsDlg *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68D0FB) --------------------------------------------------------
signed int __stdcall HrDoAdvCfgDlg(HWND hWnd)
{
  signed int v1; // esi@1
  struct IUnknown *v2; // edi@2
  UINT v3; // esi@2
  char v5; // [sp+Ch] [bp-BCh]@2
  char v6; // [sp+44h] [bp-84h]@2
  PROPSHEETHEADERW Dst; // [sp+74h] [bp-54h]@1
  struct _PSP *v8; // [sp+A8h] [bp-20h]@2
  struct _PSP *v9; // [sp+ACh] [bp-1Ch]@3
  struct IUnknown *v10; // [sp+B4h] [bp-14h]@1
  struct IUnknown *v11; // [sp+B8h] [bp-10h]@1
  int v12; // [sp+C4h] [bp-4h]@2

  Dst.dwSize = 0;
  memset(&Dst.dwFlags, 0, 0x30u);
  v10 = 0;
  v11 = 0;
  v1 = HrGetINetCfg(hWnd, (struct INetCfg **)&v10, (struct INetCfgLock **)&v11);
  if ( v1 >= 0 )
  {
    v2 = v10;
    CBindingsDlg::CBindingsDlg((CBindingsDlg *)&v6, (struct INetCfg *)v10);
    v12 = 0;
    CProviderOrderDlg::CProviderOrderDlg((int)&v5);
    LOBYTE(v12) = 1;
    v8 = CPropSheetPage::CreatePage((CPropSheetPage *)&v6, 25009, 0, 0, 0, 0, 0);
    v3 = 1;
    if ( AreThereMultipleProviders() )
    {
      v9 = CPropSheetPage::CreatePage((CPropSheetPage *)&v5, 25010, 0, 0, 0, 0, 0);
      v3 = 2;
    }
    Dst.hwndParent = hWnd;
    Dst.dwSize = 52;
    Dst.dwFlags = 33554560;
    Dst.hInstance = hInst;
    Dst.pszCaption = SzLoadIds(0x6214u);
    Dst.ppsp = (LPCPROPSHEETPAGEW)&v8;
    Dst.nPages = v3;
    PropertySheetW(&Dst);
    v1 = v2->lpVtbl[1].AddRef(v2);
    if ( v1 >= 0 )
    {
      if ( v11 )
      {
        v1 = v11->lpVtbl[1].AddRef(v11);
        ReleaseObj(v11);
      }
      if ( v1 >= 0 )
        ReleaseObj(v2);
    }
    LOBYTE(v12) = 0;
    CProviderOrderDlg::~CProviderOrderDlg((CProviderOrderDlg *)&v5);
    v12 = -1;
    CBindingsDlg::~CBindingsDlg((CBindingsDlg *)&v6);
  }
  return v1;
}

//----- (6E68D233) --------------------------------------------------------
__int32 __thiscall CProviderOrderDlg::MoveItem(CProviderOrderDlg *this, bool a2)
{
  HWND v2; // edi@1
  LPARAM v3; // eax@2
  signed int v4; // ecx@4
  LPARAM v5; // esi@8
  LPARAM v7; // [sp+Ch] [bp-17Ch]@8
  LPARAM v8; // [sp+10h] [bp-178h]@6
  char v9; // [sp+14h] [bp-174h]@8
  LPARAM lParam; // [sp+50h] [bp-138h]@1
  LPARAM v11; // [sp+54h] [bp-134h]@1
  char *v12; // [sp+60h] [bp-128h]@1
  int v13; // [sp+64h] [bp-124h]@1
  HWND hWnd; // [sp+78h] [bp-110h]@1
  LPARAM v15; // [sp+7Ch] [bp-10Ch]@1
  char v16; // [sp+80h] [bp-108h]@1

  v2 = GetDlgItem(*((HWND *)this + 1), 25011);
  hWnd = v2;
  v15 = SendMessageW(v2, 0x110Au, 9u, 0);
  v11 = v15;
  v12 = &v16;
  lParam = 39;
  v13 = 128;
  SendMessageW(v2, 0x113Eu, 0, (LPARAM)&lParam);
  if ( a2 )
  {
    v3 = SendMessageW(v2, 0x110Au, 2u, v15);
    if ( v3 )
      v3 = SendMessageW(v2, 0x110Au, 2u, v3);
    v4 = -65535;
  }
  else
  {
    v3 = SendMessageW(v2, 0x110Au, 1u, v15);
    v4 = -65534;
  }
  v8 = v4;
  if ( v3 )
    v8 = v3;
  v7 = SendMessageW(v2, 0x110Au, 3u, v15);
  qmemcpy(&v9, &lParam, 0x28u);
  v5 = SendMessageW(hWnd, 0x1132u, 0, (LPARAM)&v7);
  SendMessageW(hWnd, 0x1101u, 0, v15);
  SendMessageW(hWnd, 0x110Bu, 9u, v5);
  return 0;
}

//----- (6E68D36A) --------------------------------------------------------
__int32 __thiscall CProviderOrderDlg::UpdateUpDownButtons(CProviderOrderDlg *this, HWND hWnd)
{
  CProviderOrderDlg *v2; // ebx@1
  LPARAM v3; // eax@1
  HWND v5; // [sp+Ch] [bp-1Ch]@1
  HWND v6; // [sp+10h] [bp-18h]@1
  LPARAM lParam; // [sp+14h] [bp-14h]@1
  HWND v8; // [sp+18h] [bp-10h]@1
  HWND v9; // [sp+1Ch] [bp-Ch]@1
  signed int wParam; // [sp+20h] [bp-8h]@1
  char v11; // [sp+26h] [bp-2h]@1
  char v12; // [sp+27h] [bp-1h]@1

  v2 = this;
  v5 = GetDlgItem(*((HWND *)this + 1), 25012);
  v8 = GetDlgItem(*((HWND *)v2 + 1), 25013);
  wParam = 0;
  v6 = GetFocus();
  v9 = hWnd;
  v11 = 0;
  v12 = 0;
  v3 = SendMessageW(hWnd, 0x110Au, 9u, 0);
  lParam = v3;
  if ( v3 && !SendMessageW(hWnd, 0x110Au, 4u, v3) )
  {
    if ( SendMessageW(hWnd, 0x110Au, 2u, lParam) )
      v12 = 1;
    if ( SendMessageW(hWnd, 0x110Au, 1u, lParam) )
      v11 = 1;
  }
  if ( v6 != v5 || v12 )
  {
    if ( v6 != v8 || v11 )
    {
      SetDefaultButton(*((HWND *)v2 + 1), 0);
      goto LABEL_18;
    }
    if ( v12 )
    {
      v9 = v5;
      wParam = 25012;
    }
    goto LABEL_15;
  }
  if ( !v11 )
  {
LABEL_15:
    SetDefaultButton(*((HWND *)v2 + 1), wParam);
    goto LABEL_16;
  }
  v9 = v8;
  SetDefaultButton(*((HWND *)v2 + 1), 0x61B5u);
LABEL_16:
  SetFocus(v9);
LABEL_18:
  EnableWindow(v5, (unsigned __int8)v12);
  EnableWindow(v8, (unsigned __int8)v11);
  return 0;
}

//----- (6E68D485) --------------------------------------------------------
LRESULT __userpurge sub_6E68D485@<eax>(int a1@<eax>, LPARAM a2@<ecx>, HWND hWnd, int a4, int a5)
{
  LPARAM lParam; // [sp+0h] [bp-44h]@1
  int v7; // [sp+4h] [bp-40h]@1
  int v8; // [sp+8h] [bp-3Ch]@1
  int v9; // [sp+18h] [bp-2Ch]@1
  int v10; // [sp+20h] [bp-24h]@1
  int v11; // [sp+24h] [bp-20h]@1
  int v12; // [sp+2Ch] [bp-18h]@1

  v10 = a1;
  v11 = a1;
  v12 = a5;
  lParam = a2;
  v7 = -65534;
  v8 = 39;
  v9 = a4;
  return SendMessageW(hWnd, 0x1132u, 0, (LPARAM)&lParam);
}

//----- (6E68D4CD) --------------------------------------------------------
__int32 __thiscall CProviderOrderDlg::OnTreeItemChanged(CProviderOrderDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CProviderOrderDlg *v4; // esi@1
  HWND v5; // eax@1

  v4 = this;
  v5 = GetDlgItem(*((HWND *)this + 1), 25011);
  if ( a3 && a3[1].code )
    CProviderOrderDlg::UpdateUpDownButtons(v4, v5);
  return 0;
}

//----- (6E68D504) --------------------------------------------------------
LONG __thiscall CProviderOrderDlg::~CProviderOrderDlg(CProviderOrderDlg *this)
{
  CProviderOrderDlg *v1; // esi@1
  int v2; // edi@1

  v1 = this;
  *(_DWORD *)this = &CProviderOrderDlg::`vftable';
  v2 = (int)((char *)this + 28);
  DeleteColString((int)((char *)this + 28));
  DeleteColString((int)((char *)v1 + 40));
  if ( *((_DWORD *)v1 + 4) )
    DeleteObject(*((HGDIOBJ *)v1 + 4));
  if ( *((_DWORD *)v1 + 5) )
    DeleteObject(*((HGDIOBJ *)v1 + 5));
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)((char *)v1 + 40));
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy(v2);
  return CPropSheetPage::~CPropSheetPage(v1);
}
// 6E6479C4: using guessed type int (__thiscall *CProviderOrderDlg::`vftable')(CProviderOrderDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CProviderOrderDlg *, unsigned __int32);

//----- (6E68D574) --------------------------------------------------------
void __stdcall sub_6E68D574(HWND hWnd, int a2, char a3, int a4, int a5, char a6, int a7, int a8, int a9)
{
  int v9; // esi@1
  int i; // edi@1
  int v11; // eax@2
  int v12; // eax@3

  v9 = *(_DWORD *)a4;
  for ( i = *(_DWORD *)a7; v9 != a4; i = *(_DWORD *)i )
  {
    v11 = *(_DWORD *)(v9 + 8);
    if ( *(_DWORD *)(v11 + 24) < 8u )
      v12 = v11 + 4;
    else
      v12 = *(_DWORD *)(v11 + 4);
    sub_6E68D485(a9, a2, hWnd, v12, *(_DWORD *)(i + 8));
    v9 = *(_DWORD *)v9;
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&a3);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&a6);
}

//----- (6E68D5D0) --------------------------------------------------------
int __thiscall CProviderOrderDlg::CProviderOrderDlg(int this)
{
  int v1; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &CProviderOrderDlg::`vftable';
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>((void *)(this + 28));
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>((void *)(v1 + 40));
  *(_DWORD *)(v1 + 12) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 16) = 0;
  return v1;
}
// 6E6479C4: using guessed type int (__thiscall *CProviderOrderDlg::`vftable')(CProviderOrderDlg *this, HWND, unsigned int, unsigned int, struct tagNMHDR *, CProviderOrderDlg *, unsigned __int32);

//----- (6E68D61C) --------------------------------------------------------
void *__thiscall CProviderOrderDlg::`vector deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CProviderOrderDlg::~CProviderOrderDlg((CProviderOrderDlg *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68D642) --------------------------------------------------------
signed int __stdcall HrGetNetworkProviderName(HKEY hKey, int a2)
{
  LSTATUS i; // eax@1
  WCHAR *v3; // eax@2
  __int32 v5; // [sp+Ch] [bp-Ch]@1
  void *lpMem; // [sp+10h] [bp-8h]@1
  SIZE_T dwBytes; // [sp+14h] [bp-4h]@1

  lpMem = 0;
  dwBytes = 0;
  v5 = 0;
  for ( i = RegLoadMUIStringW(hKey, L"DisplayName", 0, 0, &dwBytes, 0, 0);
        i == 234;
        i = RegLoadMUIStringW(hKey, L"DisplayName", v3, dwBytes, &dwBytes, 0, 0) )
  {
    MemFree(lpMem);
    v3 = (WCHAR *)MemAlloc(dwBytes);
    lpMem = v3;
    if ( !v3 )
      return -2147024882;
  }
  if ( i )
  {
    v5 = HrRegQueryTypeString(hKey, L"Name", 1u, a2);
  }
  else
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::assign(
      a2,
      lpMem);
    MemFree(lpMem);
  }
  return v5;
}

//----- (6E68D70D) --------------------------------------------------------
int __thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(void *this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  void *v6; // [sp+10h] [bp-14h]@1

  v6 = this;
  result = a3;
  while ( result != a4 )
  {
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(v6, a2, result + 8);
    result = *(_DWORD *)a3;
    a3 = *(_DWORD *)a3;
  }
  return result;
}

//----- (6E68D778) --------------------------------------------------------
void __stdcall ConvertColStringToString(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // esi@2
  int v5; // eax@3
  void *v6; // eax@4

  if ( (_WORD)a2 )
  {
    v3 = *(_DWORD *)(a1 + 4);
    v4 = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 != v3 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 8);
        if ( *(_DWORD *)(v5 + 24) < 8u )
          v6 = (void *)(v5 + 4);
        else
          v6 = *(void **)(v5 + 4);
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          a3,
          v6);
        v4 = *(_DWORD *)v4;
        if ( v4 == *(_DWORD *)(a1 + 4) )
          break;
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::append(
          a3,
          1u,
          a2);
      }
      while ( v4 != *(_DWORD *)(a1 + 4) );
    }
  }
}

//----- (6E68D7D0) --------------------------------------------------------
int __thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(void *this, int a2, int a3, int a4)
{
  return std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(
           this,
           a2,
           a3,
           a4,
           a4);
}

//----- (6E68D7EF) --------------------------------------------------------
void __stdcall ConvertStringToColString(unsigned __int16 *a1, wchar_t a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // esi@1
  void *v6; // ecx@2
  unsigned __int16 *v7; // esi@5
  unsigned __int16 *v8; // edi@6
  const wchar_t *i; // esi@7
  wchar_t *v10; // edi@9
  int v11; // eax@12
  int v12; // ecx@12
  int v13; // eax@12
  unsigned __int16 *v14; // [sp+24h] [bp+8h]@6

  v3 = a3;
  v4 = *(_DWORD *)(a3 + 4);
  v5 = *(_DWORD *)v4;
  if ( *(_DWORD *)v4 != v4 )
  {
    do
    {
      v6 = *(void **)(v5 + 8);
      if ( v6 )
        std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::`scalar deleting destructor'(
          v6,
          1);
      v5 = *(_DWORD *)v5;
    }
    while ( v5 != *(_DWORD *)(v3 + 4) );
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(
    v3,
    (int)&a3,
    **(void ***)(v3 + 4),
    *(_DWORD *)(v3 + 4));
  v7 = a1;
  if ( a1 )
  {
    v8 = (unsigned __int16 *)operator new(2 * (wcslen(a1) + 1));
    v14 = v8;
    if ( v8 )
    {
      StringCchCopyW(v8, wcslen(v7) + 1, v7);
      for ( i = v8; ; i = v10 + 1 )
      {
        if ( *i )
        {
          v10 = wcschr(i, a2);
          if ( v10 )
            *v10 = 0;
          if ( *i )
          {
            v11 = (int)operator new(0x1Cu);
            v12 = v11;
            a3 = v11;
            v13 = 0;
            if ( a3 )
              v13 = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
                      v12,
                      (void *)i);
            a3 = v13;
            if ( v13 )
              std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
                (void *)v3,
                *(_DWORD *)(v3 + 4),
                (int)&a3);
          }
          if ( v10 )
            continue;
        }
        break;
      }
      operator delete(v14);
    }
  }
}

//----- (6E68D911) --------------------------------------------------------
__int32 __thiscall CProviderOrderDlg::WriteProviders(CProviderOrderDlg *this, HWND a2)
{
  CProviderOrderDlg *v2; // ebx@1
  __int32 v3; // esi@4
  BYTE *v4; // eax@5
  HWND i; // [sp-14h] [bp-194h]@1
  WPARAM v7; // [sp-Ch] [bp-18Ch]@1
  LPARAM v8; // [sp-8h] [bp-188h]@1
  LPARAM lParam; // [sp+Ch] [bp-174h]@1
  LPARAM v10; // [sp+10h] [bp-170h]@2
  char *v11; // [sp+1Ch] [bp-164h]@1
  int v12; // [sp+20h] [bp-160h]@1
  int v13; // [sp+30h] [bp-150h]@2
  char v14; // [sp+34h] [bp-14Ch]@8
  void *v15; // [sp+38h] [bp-148h]@1
  int v16; // [sp+3Ch] [bp-144h]@1
  int v17; // [sp+40h] [bp-140h]@2
  HWND hWnd; // [sp+44h] [bp-13Ch]@1
  LPARAM v19; // [sp+48h] [bp-138h]@2
  HKEY phkResult; // [sp+4Ch] [bp-134h]@1
  char v21; // [sp+50h] [bp-130h]@5
  BYTE *lpData; // [sp+54h] [bp-12Ch]@5
  unsigned int v23; // [sp+68h] [bp-118h]@5
  char v24; // [sp+6Ch] [bp-114h]@1
  int v25; // [sp+17Ch] [bp-4h]@1

  v2 = this;
  hWnd = a2;
  v15 = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v16 = 0;
  v25 = 0;
  phkResult = 0;
  lParam = 1;
  v11 = &v24;
  v12 = 128;
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::clear((int)((char *)v2 + 28));
  v8 = *((_DWORD *)v2 + 6);
  v7 = 4;
  for ( i = a2; ; i = hWnd )
  {
    v19 = SendMessageW(i, 0x110Au, v7, v8);
    if ( !v19 )
      break;
    v10 = v19;
    SendMessageW(hWnd, 0x113Eu, 0, (LPARAM)&lParam);
    v17 = v13;
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
      (char *)v2 + 28,
      *((_DWORD *)v2 + 8),
      (int)&v17);
    v8 = v19;
    v7 = 1;
  }
  v3 = HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
         0x20006u,
         &phkResult);
  if ( !v3 )
  {
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v21);
    LOBYTE(v25) = 1;
    ConvertColStringToString((int)((char *)v2 + 28), 44, (int)&v21);
    v4 = lpData;
    if ( v23 < 8 )
      v4 = (BYTE *)&lpData;
    v3 = HrRegSetSz(phkResult, L"ProviderOrder", v4);
    LOBYTE(v25) = 0;
    std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
      (int)&v21,
      1,
      0);
  }
  RegSafeCloseKey(phkResult);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v14);
  return v3;
}

//----- (6E68DA85) --------------------------------------------------------
signed int __thiscall sub_6E68DA85(void *this, int a2)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int v4; // eax@5
  int v5; // esi@5
  int v6; // eax@6
  int v7; // eax@7
  int v8; // eax@11
  int v9; // eax@12
  int v10; // ST0C_4@14
  void *v12; // [sp+10h] [bp-318h]@1
  DWORD Type; // [sp+14h] [bp-314h]@1
  HKEY phkResult; // [sp+18h] [bp-310h]@1
  HKEY hKey; // [sp+1Ch] [bp-30Ch]@9
  int v16; // [sp+20h] [bp-308h]@11
  int v17; // [sp+24h] [bp-304h]@6
  WCHAR SubKey; // [sp+40h] [bp-2E8h]@9
  BYTE Data; // [sp+214h] [bp-114h]@2
  int v20; // [sp+324h] [bp-4h]@6

  v2 = (int)this;
  v12 = this;
  Type = 258;
  v3 = HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         L"System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
         0x20019u,
         &phkResult);
  if ( !v3 )
  {
    v3 = HrRegQueryTypeSzBuffer(phkResult, L"ProviderOrder", 1u, &Data, (DWORD)&Type);
    if ( !v3 )
      ConvertStringToColString((unsigned __int16 *)&Data, 0x2Cu, v2);
    RegSafeCloseKey(phkResult);
    if ( !v3 )
    {
      v4 = *(_DWORD *)(v2 + 4);
      v5 = *(_DWORD *)v4;
      if ( *(_DWORD *)v4 != v4 )
      {
        do
        {
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>((int)&v17);
          v6 = *(_DWORD *)(v5 + 8);
          v20 = 0;
          if ( *(_DWORD *)(v6 + 24) < 8u )
            v7 = v6 + 4;
          else
            v7 = *(_DWORD *)(v6 + 4);
          StringCchPrintfW(&SubKey, 0xEAu, L"System\\CurrentControlSet\\Services\\%s\\NetworkProvider", v7);
          v3 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &SubKey, 0x20019u, &hKey);
          if ( !v3 )
          {
            v3 = HrGetNetworkProviderName(hKey, (int)&v17);
            if ( !v3 )
            {
              v8 = (int)operator new(0x1Cu);
              v16 = v8;
              LOBYTE(v20) = 1;
              if ( v8 )
                v9 = std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>(
                       v8,
                       (int)&v17);
              else
                v9 = 0;
              v16 = v9;
              v10 = *(_DWORD *)(a2 + 4);
              LOBYTE(v20) = 0;
              std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert((void *)a2, v10, (int)&v16);
            }
            RegSafeCloseKey(hKey);
          }
          v20 = -1;
          std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70>::_Tidy(
            (int)&v17,
            1,
            0);
          v5 = *(_DWORD *)v5;
        }
        while ( v5 != *((_DWORD *)v12 + 1) );
      }
    }
  }
  return v3;
}

//----- (6E68DC91) --------------------------------------------------------
bool __stdcall AreThereMultipleProviders()
{
  bool v0; // bl@1
  char v2; // [sp+Ch] [bp-24h]@1
  void *v3; // [sp+10h] [bp-20h]@1
  int v4; // [sp+14h] [bp-1Ch]@1
  char v5; // [sp+18h] [bp-18h]@1
  void *v6; // [sp+1Ch] [bp-14h]@1
  unsigned int v7; // [sp+20h] [bp-10h]@1
  int v8; // [sp+2Ch] [bp-4h]@1

  v0 = 0;
  v6 = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v7 = 0;
  v8 = 0;
  v3 = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v4 = 0;
  LOBYTE(v8) = 1;
  if ( !sub_6E68DA85(&v5, (int)&v2) )
    v0 = v7 > 1;
  DeleteColString((int)&v5);
  DeleteColString((int)&v2);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v2);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v5);
  return v0;
}

//----- (6E68DD08) --------------------------------------------------------
void *__thiscall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>(void *this, int a2)
{
  void *v2; // esi@1
  int *v3; // eax@1

  v2 = this;
  v3 = (int *)std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  *((_DWORD *)v2 + 2) = 0;
  *((_DWORD *)v2 + 1) = v3;
  std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::insert<std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::const_iterator>(
    v2,
    *v3,
    **(_DWORD **)(a2 + 4),
    *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (6E68DD47) --------------------------------------------------------
void __usercall __noreturn sub_6E68DD47(int a1@<ebp>)
{
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy(*(_DWORD *)(a1 - 20));
  _CxxThrowException(0, 0);
}
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);

//----- (6E68DD5E) --------------------------------------------------------
signed int __thiscall CProviderOrderDlg::OnInitDialog(CProviderOrderDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CProviderOrderDlg *v5; // esi@1
  HCURSOR v6; // eax@1
  HCURSOR v7; // eax@1
  HANDLE v8; // eax@1
  HANDLE v9; // eax@1
  LPARAM v10; // eax@1
  HWND v11; // eax@1
  LONG v12; // eax@1
  HIMAGELIST v13; // ebx@1
  bool v14; // zf@1
  LPARAM v15; // eax@2
  LPARAM v16; // edi@2
  char v18; // [sp-20h] [bp-58h]@2
  int v19; // [sp-1Ch] [bp-54h]@2
  int v20; // [sp-18h] [bp-50h]@1
  signed int v21; // [sp-14h] [bp-4Ch]@1
  int v22; // [sp-10h] [bp-48h]@1
  int v23; // [sp-Ch] [bp-44h]@1
  int v24; // [sp-8h] [bp-40h]@1
  struct _SP_CLASSIMAGELIST_DATA ClassImageListData; // [sp+Ch] [bp-2Ch]@1
  char *v26; // [sp+18h] [bp-20h]@2
  signed int *v27; // [sp+1Ch] [bp-1Ch]@2
  LPARAM lParam; // [sp+20h] [bp-18h]@1
  int ImageIndex; // [sp+24h] [bp-14h]@1
  HWND hWnd; // [sp+28h] [bp-10h]@1
  int v31; // [sp+34h] [bp-4h]@2

  v5 = this;
  v6 = LoadCursorW(hInst, (LPCWSTR)0xC1D);
  v24 = 32648;
  v23 = 0;
  *((_DWORD *)v5 + 2) = v6;
  v7 = LoadCursorW((HINSTANCE)v23, (LPCWSTR)v24);
  v24 = 0;
  v23 = 16;
  v22 = 16;
  v21 = 1;
  v20 = 30300;
  *((_DWORD *)v5 + 3) = v7;
  v8 = LoadImageW(hInst, (LPCWSTR)v20, v21, v22, v23, v24);
  v24 = 0;
  v23 = 16;
  v22 = 16;
  v21 = 1;
  v20 = 30301;
  *((_DWORD *)v5 + 4) = v8;
  v9 = LoadImageW(hInst, (LPCWSTR)v20, v21, v22, v23, v24);
  *((_BYTE *)v5 + 52) &= 0xFEu;
  v24 = 5251;
  *((_DWORD *)v5 + 5) = v9;
  *((_DWORD *)v5 + 6) = 0;
  v10 = (LPARAM)SzLoadIds(v24);
  v24 = 7000;
  v23 = *((_DWORD *)v5 + 1);
  lParam = v10;
  v11 = GetDlgItem((HWND)v23, 7000);
  hWnd = v11;
  v12 = GetWindowLongW(v11, -20);
  SetWindowLongW(hWnd, -20, v12 | 0x20000);
  SetWindowPos(hWnd, 0, 0, 0, 0, 0, 0x37u);
  hWnd = GetDlgItem(*((HWND *)v5 + 1), 25011);
  HrSetupDiGetClassImageList(&ClassImageListData);
  v13 = ImageList_Duplicate(ClassImageListData.ImageList);
  HrSetupDiGetClassImageIndex(&ClassImageListData, &GUID_DEVCLASS_NETCLIENT, &ImageIndex);
  HrSetupDiDestroyClassImageList(&ClassImageListData);
  SendMessageW(hWnd, 0x1109u, 0, (LPARAM)v13);
  v14 = sub_6E68DA85((char *)v5 + 28, (int)((char *)v5 + 40)) == 0;
  v24 = 0;
  if ( v14 )
  {
    v15 = sub_6E68D485(ImageIndex, 0, hWnd, lParam, v24);
    v24 = ImageIndex;
    lParam = v15;
    v27 = &v21;
    std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>(
      &v21,
      (int)((char *)v5 + 28));
    v26 = &v18;
    v31 = 0;
    std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>(
      &v18,
      (int)((char *)v5 + 40));
    v16 = lParam;
    v31 = -1;
    sub_6E68D574(hWnd, lParam, v18, v19, v20, v21, v22, v23, v24);
    SendMessageW(hWnd, 0x1102u, 2u, v16);
    *((_DWORD *)v5 + 6) = v16;
  }
  else
  {
    sub_6E68D485(ImageIndex, 0, hWnd, (int)L"failed to get network providers", v24);
    *((_BYTE *)v5 + 52) |= 1u;
  }
  v24 = *((_DWORD *)v5 + 4);
  v23 = 1;
  v22 = 247;
  v21 = 25012;
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25012, 0xF7u, 1u, v24);
  v24 = *((_DWORD *)v5 + 5);
  v23 = 1;
  v22 = 247;
  v21 = 25013;
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25013, 0xF7u, 1u, v24);
  CProviderOrderDlg::UpdateUpDownButtons(v5, hWnd);
  return 1;
}
// 6E68DF28: using guessed type wchar_t aFailedToGetNet[32];

//----- (6E68DF6D) --------------------------------------------------------
__int32 __thiscall CProviderOrderDlg::OnOk(CProviderOrderDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CProviderOrderDlg *v4; // esi@1
  HWND v5; // eax@1
  __int32 v6; // edi@2
  __int32 v7; // esi@5
  HICON hInstance; // [sp+Ch] [bp-10h]@1

  v4 = this;
  hInstance = BeginWaitCursor();
  v5 = GetDlgItem(*((HWND *)v4 + 1), 25011);
  if ( *((_BYTE *)v4 + 52) & 1 )
  {
    v6 = 0;
  }
  else
  {
    v6 = CProviderOrderDlg::WriteProviders(v4, v5);
    if ( v6 )
      NcMsgBox(hInst, *((HWND *)v4 + 1), 0x79B2u, 0x79B0u, 0x30u);
  }
  v7 = LresFromHr(v6);
  EndWaitCursor(hInstance);
  return v7;
}

//----- (6E68DFE9) --------------------------------------------------------
int __thiscall CProviderOrderDlg::ProcessWindowMessage(CProviderOrderDlg *this, HWND a2, unsigned int a3, unsigned int a4, struct tagNMHDR *a5, CProviderOrderDlg *a6, unsigned __int32 a7)
{
  signed int v7; // eax@3
  UINT v9; // edx@13

  if ( !a7 )
  {
    if ( a3 == 272 )
    {
      v7 = CProviderOrderDlg::OnInitDialog(this, 0x110u, a4, (__int32)a5, (int *)&a4);
LABEL_4:
      *(_DWORD *)a6 = v7;
      return 1;
    }
    if ( a3 == 273 )
    {
      if ( 25012 == (_WORD)a4 )
      {
        CProviderOrderDlg::MoveItem(this, 1);
LABEL_9:
        *(_DWORD *)a6 = 0;
        return 1;
      }
      if ( 25013 == (_WORD)a4 )
      {
        CProviderOrderDlg::MoveItem(this, 0);
        goto LABEL_9;
      }
    }
    else if ( a3 == 78 )
    {
      v9 = a5->code;
      if ( v9 == -451 )
      {
        v7 = CProviderOrderDlg::OnTreeItemChanged(this, a4, a5, (int *)&a4);
        goto LABEL_4;
      }
      if ( v9 == -202 )
      {
        v7 = CProviderOrderDlg::OnOk(this, a4, a5, (int *)&a4);
        goto LABEL_4;
      }
    }
  }
  return 0;
}

//----- (6E68E093) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnTreeItemChanged(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CBindingsDlg *v4; // esi@1
  HWND v5; // eax@1
  HWND v6; // eax@1
  HWND v7; // eax@3
  HWND v8; // eax@5

  v4 = this;
  v5 = GetDlgItem(*((HWND *)this + 1), 25004);
  EnableWindow(v5, 0);
  v6 = GetDlgItem(*((HWND *)v4 + 1), 25005);
  EnableWindow(v6, 0);
  if ( SendMessageW(*((HWND *)v4 + 4), 0x110Au, 3u, (LPARAM)a3[5].hwndFrom) )
  {
    if ( SendMessageW(*((HWND *)v4 + 4), 0x110Au, 1u, (LPARAM)a3[5].hwndFrom) )
    {
      v7 = GetDlgItem(*((HWND *)v4 + 1), 25005);
      EnableWindow(v7, 1);
    }
    if ( SendMessageW(*((HWND *)v4 + 4), 0x110Au, 2u, (LPARAM)a3[5].hwndFrom) )
    {
      v8 = GetDlgItem(*((HWND *)v4 + 1), 25004);
      EnableWindow(v8, 1);
    }
  }
  return 0;
}

//----- (6E68E141) --------------------------------------------------------
LPARAM __thiscall CBindingsDlg::HtiIsSubItem(CBindingsDlg *this, struct INetCfgComponent *a2, struct _TREEITEM *a3)
{
  CBindingsDlg *v3; // ebx@1
  HWND v4; // ST00_4@2
  LRESULT i; // eax@1
  LPARAM lParam; // [sp+Ch] [bp-28h]@2
  LRESULT v8; // [sp+10h] [bp-24h]@2
  int v9; // [sp+30h] [bp-4h]@2
  LPARAM v10; // [sp+40h] [bp+Ch]@4

  v3 = this;
  for ( i = SendMessageW(*((HWND *)this + 4), 0x110Au, 4u, (LPARAM)a3);
        ;
        i = SendMessageW(*((HWND *)v3 + 4), 0x110Au, 1u, v10) )
  {
    v10 = i;
    if ( !i )
      return 0;
    memset(&v8, 0, 0x24u);
    v8 = i;
    v4 = (HWND)*((_DWORD *)v3 + 4);
    lParam = 20;
    SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
    if ( a2 == *(struct INetCfgComponent **)v9 )
      break;
  }
  return v10;
}

//----- (6E68E1B5) --------------------------------------------------------
void __stdcall ChangeTreeItemParam(HWND hWnd, struct _TREEITEM *a2, __int32 a3)
{
  LPARAM lParam; // [sp+0h] [bp-28h]@1
  struct _TREEITEM *v4; // [sp+4h] [bp-24h]@1
  __int32 v5; // [sp+24h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  lParam = 4;
  SendMessageW(hWnd, 0x113Fu, 0, (LPARAM)&lParam);
}

//----- (6E68E1ED) --------------------------------------------------------
struct _TREEITEM *__thiscall CBindingsDlg::HtiMoveTreeItemAfter(CBindingsDlg *this, struct _TREEITEM *a2, struct _TREEITEM *a3, struct _TREEITEM *a4)
{
  CBindingsDlg *v4; // edi@1
  HWND v5; // ST00_4@1
  LRESULT v6; // eax@5
  HWND v7; // ST00_4@5
  LPARAM i; // eax@5
  LPARAM v10; // [sp+Ch] [bp-258h]@5
  int v11; // [sp+10h] [bp-254h]@2
  LPARAM lParam; // [sp+14h] [bp-250h]@1
  struct _TREEITEM *v13; // [sp+18h] [bp-24Ch]@1
  int v14; // [sp+20h] [bp-244h]@1
  char *v15; // [sp+24h] [bp-240h]@1
  int v16; // [sp+28h] [bp-23Ch]@1
  LRESULT v17; // [sp+50h] [bp-214h]@6
  LPARAM v18; // [sp+54h] [bp-210h]@1
  struct _TREEITEM *v19; // [sp+58h] [bp-20Ch]@1
  LPARAM v20; // [sp+5Ch] [bp-208h]@1
  char v21; // [sp+60h] [bp-204h]@1

  v20 = (LPARAM)a2;
  v19 = a3;
  v15 = &v21;
  v4 = this;
  v5 = (HWND)*((_DWORD *)this + 4);
  v18 = (LPARAM)a4;
  v13 = a4;
  lParam = 47;
  v14 = 61440;
  v16 = 256;
  SendMessageW(v5, 0x113Eu, 0, (LPARAM)&lParam);
  if ( v19 )
  {
    v11 = -65535;
    if ( (struct _TREEITEM *)v20 != v19 )
      v11 = (int)v19;
  }
  else
  {
    v11 = -65534;
  }
  v10 = v20;
  v6 = SendMessageW(*((HWND *)v4 + 4), 0x1132u, 0, (LPARAM)&v10);
  v7 = (HWND)*((_DWORD *)v4 + 4);
  v19 = (struct _TREEITEM *)v6;
  for ( i = SendMessageW(v7, 0x110Au, 4u, (LPARAM)a4); ; i = v17 )
  {
    v20 = i;
    if ( !i )
      break;
    v17 = SendMessageW(*((HWND *)v4 + 4), 0x110Au, 1u, v20);
    CBindingsDlg::HtiMoveTreeItemAfter(v4, v19, 0, (struct _TREEITEM *)v20);
  }
  ChangeTreeItemParam(*((HWND *)v4 + 4), (struct _TREEITEM *)v18, 0);
  SendMessageW(*((HWND *)v4 + 4), 0x1101u, 0, v18);
  return v19;
}

//----- (6E68E345) --------------------------------------------------------
void __thiscall CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch(int this)
{
  int v1; // esi@1
  unsigned int v2; // ecx@1
  int v3; // eax@2

  v1 = this;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 )
  {
    v3 = *(_DWORD *)(v1 + 4);
    if ( v3 )
    {
      if ( v2 < v3 + 4 * *(_DWORD *)(v1 + 12) )
      {
        do
        {
          ReleaseObj(**(struct IUnknown ***)(v1 + 8));
          *(_DWORD *)(v1 + 8) += 4;
        }
        while ( *(_DWORD *)(v1 + 8) < (unsigned int)(*(_DWORD *)(v1 + 4) + 4 * *(_DWORD *)(v1 + 12)) );
      }
      MemFree(*(void **)(v1 + 4));
    }
  }
}

//----- (6E68E38D) --------------------------------------------------------
int __thiscall CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext(int this, int a2)
{
  int v2; // esi@1
  unsigned int v3; // eax@3
  void *v4; // ST0C_4@9
  void *v5; // eax@9
  int v6; // eax@11
  int v7; // eax@12

  v2 = this;
  if ( *(_DWORD *)(this + 16) >= 0 )
  {
    v3 = *(_DWORD *)(this + 8);
    if ( !v3 || v3 >= *(_DWORD *)(this + 4) + 4 * *(_DWORD *)(this + 12) )
    {
      if ( v3 && *(_DWORD *)(this + 12) != 256 )
      {
        *(_DWORD *)a2 = 0;
      }
      else
      {
        v4 = *(void **)(this + 4);
        *(_DWORD *)(this + 8) = 0;
        MemFree(v4);
        v5 = MemAlloc(0x400u);
        *(_DWORD *)(v2 + 4) = v5;
        if ( !v5 )
        {
          *(_DWORD *)a2 = 0;
          *(_DWORD *)(v2 + 16) = -2147024882;
          return *(_DWORD *)(v2 + 16);
        }
        v6 = (*(int (__stdcall **)(_DWORD, signed int, void *, int))(**(_DWORD **)v2 + 12))(
               *(_DWORD *)v2,
               256,
               v5,
               v2 + 12);
        *(_DWORD *)(v2 + 16) = v6;
        if ( v6 < 0 )
        {
          *(_DWORD *)a2 = 0;
          return *(_DWORD *)(v2 + 16);
        }
        v7 = *(_DWORD *)(v2 + 4);
        *(_DWORD *)(v2 + 8) = v7 + 4;
        if ( *(_DWORD *)(v2 + 12) )
        {
          *(_DWORD *)a2 = *(_DWORD *)v7;
          *(_DWORD *)(v2 + 16) = 0;
          return *(_DWORD *)(v2 + 16);
        }
        *(_DWORD *)a2 = 0;
      }
      *(_DWORD *)(v2 + 16) = 1;
      return *(_DWORD *)(v2 + 16);
    }
    *(_DWORD *)a2 = *(_DWORD *)v3;
    *(_DWORD *)(this + 8) += 4;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return *(_DWORD *)(v2 + 16);
}

//----- (6E68E45D) --------------------------------------------------------
void __thiscall CIterNetCfgComponent::~CIterNetCfgComponent(CIterNetCfgComponent *this)
{
  int v1; // esi@1

  v1 = (int)this;
  ReleaseObj(*((struct IUnknown **)this + 5));
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch(v1);
}

//----- (6E68E477) --------------------------------------------------------
CIterNetCfgBindingPath *__thiscall CIterNetCfgBindingPath::CIterNetCfgBindingPath(CIterNetCfgBindingPath *this, struct INetCfgComponent *a2)
{
  struct INetCfgComponent *v2; // eax@1
  CIterNetCfgBindingPath *v3; // esi@1
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // eax@2

  v2 = a2;
  v3 = this;
  v4 = (char *)this + 20;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  v5 = v2->lpVtbl->QueryInterface(v2, &IID_INetCfgComponentBindings, (void **)&a2);
  *((_DWORD *)v3 + 4) = v5;
  if ( v5 >= 0 )
  {
    v6 = ((int (__stdcall *)(struct INetCfgComponent *, signed int, char *))a2->lpVtbl->GetInstanceGuid)(a2, 2, v4);
    *((_DWORD *)v3 + 4) = v6;
    if ( v6 >= 0 )
      *(_DWORD *)v3 = *(_DWORD *)v4;
    ReleaseObj((struct IUnknown *)a2);
  }
  return v3;
}

//----- (6E68E4DB) --------------------------------------------------------
CIterNetCfgUpperBindingPath *__thiscall CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath(CIterNetCfgUpperBindingPath *this, struct INetCfgComponent *a2)
{
  struct INetCfgComponent *v2; // eax@1
  CIterNetCfgUpperBindingPath *v3; // esi@1
  char *v4; // edi@1
  int v5; // eax@1
  int v6; // eax@2

  v2 = a2;
  v3 = this;
  v4 = (char *)this + 20;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  v5 = v2->lpVtbl->QueryInterface(v2, &IID_INetCfgComponentBindings, (void **)&a2);
  *((_DWORD *)v3 + 4) = v5;
  if ( v5 >= 0 )
  {
    v6 = ((int (__stdcall *)(struct INetCfgComponent *, signed int, char *))a2->lpVtbl->GetInstanceGuid)(a2, 1, v4);
    *((_DWORD *)v3 + 4) = v6;
    if ( v6 >= 0 )
      *(_DWORD *)v3 = *(_DWORD *)v4;
    ReleaseObj((struct IUnknown *)a2);
  }
  return v3;
}

//----- (6E68E53F) --------------------------------------------------------
CIterNetCfgBindingInterface *__thiscall CIterNetCfgBindingInterface::CIterNetCfgBindingInterface(CIterNetCfgBindingInterface *this, struct INetCfgBindingPath *a2)
{
  CIterNetCfgBindingInterface *v2; // esi@1
  char *v3; // edi@1
  HRESULT v4; // eax@1

  v2 = this;
  v3 = (char *)this + 20;
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  v4 = a2->lpVtbl->EnumBindingInterfaces(a2, (IEnumNetCfgBindingInterface **)((char *)this + 20));
  *((_DWORD *)v2 + 4) = v4;
  if ( v4 >= 0 )
    *(_DWORD *)v2 = *(_DWORD *)v3;
  return v2;
}

//----- (6E68E581) --------------------------------------------------------
int __stdcall CBindingsDlg::HrComponentIsHidden(struct IUnknown *a2, unsigned __int32 a3)
{
  int v2; // esi@1
  bool v3; // zf@4
  struct IUnknown *v4; // edi@4
  char v6; // [sp+Ch] [bp-28h]@1
  struct IUnknown *v7; // [sp+20h] [bp-14h]@10
  struct IUnknown *v8; // [sp+24h] [bp-10h]@3
  int v9; // [sp+30h] [bp-4h]@1

  v2 = 0;
  CIterNetCfgBindingInterface::CIterNetCfgBindingInterface(
    (CIterNetCfgBindingInterface *)&v6,
    (struct INetCfgBindingPath *)a2);
  v9 = 0;
  --a3;
  do
  {
    if ( !a3 )
      break;
    v2 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v6, (int)&v8);
    if ( v2 )
      break;
    v3 = a3-- == 1;
    v4 = v8;
    if ( v3 )
    {
      v2 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown **))v8->lpVtbl[1].Release)(v8, &a2);
      if ( v2 >= 0 )
      {
        if ( !FIsHidden((struct INetCfgComponent *)a2) )
          v2 = 1;
        ReleaseObj(a2);
      }
    }
    ReleaseObj(v4);
  }
  while ( v2 >= 0 );
  ReleaseObj(v7);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v6);
  return v2;
}

//----- (6E68E610) --------------------------------------------------------
void __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::clear(int this)
{
  int v1; // esi@1
  void **v2; // eax@1
  void *v3; // ecx@1
  void *v4; // edi@2

  v1 = this;
  v2 = *(void ***)(this + 4);
  v3 = *v2;
  *v2 = v2;
  *(_DWORD *)(*(_DWORD *)(v1 + 4) + 4) = *(_DWORD *)(v1 + 4);
  *(_DWORD *)(v1 + 8) = 0;
  if ( v3 != *(void **)(v1 + 4) )
  {
    do
    {
      v4 = *(void **)v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(void **)(v1 + 4) );
  }
}

//----- (6E68E644) --------------------------------------------------------
int __stdcall std::find<std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::iterator,BIND_PATH_INFO *>(int a1, int a2, int a3, int a4)
{
  int i; // ecx@1
  int result; // eax@4

  for ( i = a2; i != a3; i = *(_DWORD *)i )
  {
    if ( *(_DWORD *)(i + 8) == *(_DWORD *)a4 )
      break;
  }
  result = a1;
  *(_DWORD *)a1 = i;
  return result;
}

//----- (6E68E673) --------------------------------------------------------
void __thiscall CBindingsDlg::OnBindingUpDown(CBindingsDlg *this, int a2)
{
  CBindingsDlg *v2; // esi@1
  HWND v3; // ST04_4@1
  LPARAM v4; // eax@2
  HWND v5; // ST04_4@4
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@7
  int v9; // ecx@7
  int *v10; // eax@9
  int v11; // ecx@9
  const IID *v12; // eax@13
  struct IUnknownVtbl *v13; // edx@13
  int v14; // eax@14
  LPARAM v15; // eax@22
  LPARAM lParam; // [sp+Ch] [bp-48h]@1
  LPARAM v17; // [sp+10h] [bp-44h]@1
  int v18; // [sp+30h] [bp-24h]@4
  struct IUnknown *v19; // [sp+34h] [bp-20h]@7
  struct _TREEITEM *v20; // [sp+38h] [bp-1Ch]@4
  int v21; // [sp+3Ch] [bp-18h]@7
  LPARAM v22; // [sp+40h] [bp-14h]@1
  struct IUnknown *v23; // [sp+44h] [bp-10h]@8
  int v24; // [sp+48h] [bp-Ch]@9
  HRESULT v25; // [sp+4Ch] [bp-8h]@8
  LPARAM v26; // [sp+50h] [bp-4h]@4

  lParam = 0;
  v2 = this;
  v3 = (HWND)*((_DWORD *)this + 4);
  memset(&v17, 0, 0x24u);
  v22 = SendMessageW(v3, 0x110Au, 9u, 0);
  if ( a2 )
    v4 = SendMessageW(*((HWND *)v2 + 4), 0x110Au, 2u, v22);
  else
    v4 = SendMessageW(*((HWND *)v2 + 4), 0x110Au, 1u, v22);
  v26 = v4;
  v17 = v22;
  v5 = (HWND)*((_DWORD *)v2 + 4);
  lParam = 4;
  SendMessageW(v5, 0x113Eu, 0, (LPARAM)&lParam);
  v20 = (struct _TREEITEM *)v18;
  v17 = v26;
  SendMessageW(*((HWND *)v2 + 4), 0x113Eu, 0, (LPARAM)&lParam);
  v6 = *(_DWORD *)(v18 + 20);
  if ( a2 )
    v7 = *(_DWORD *)v6;
  else
    v7 = *(_DWORD *)(v6 + 4);
  v8 = **(_DWORD **)(v7 + 8);
  v9 = *(_DWORD *)v8;
  v21 = v8;
  if ( (*(int (__stdcall **)(int, struct IUnknown **))(v9 + 32))(v8, &v19) >= 0 )
  {
    v25 = v19->lpVtbl->QueryInterface(v19, &IID_INetCfgComponentBindings, (void **)&v23);
    if ( v25 >= 0 )
    {
      v10 = (int *)*((_DWORD *)v20 + 5);
      v11 = *v10;
      v24 = v11;
      if ( (int *)v11 != v10 )
      {
        while ( v25 >= 0 )
        {
          v12 = (const IID *)**(_DWORD **)(v11 + 8);
          v13 = v23->lpVtbl;
          v14 = a2 ? v13[3].QueryInterface(v23, v12, (void **)v21) : ((int (__stdcall *)(struct IUnknown *, const IID *, int))v13[3].AddRef)(
                                                                       v23,
                                                                       v12,
                                                                       v21);
          v25 = v14;
          v24 = *(_DWORD *)v24;
          if ( v24 == *((_DWORD *)v20 + 5) )
            break;
          v11 = v24;
        }
      }
      ReleaseObj(v23);
    }
    ReleaseObj(v19);
    if ( v25 >= 0 )
    {
      v20 = (struct _TREEITEM *)SendMessageW(*((HWND *)v2 + 4), 0x110Au, 3u, v22);
      if ( a2 )
      {
        v26 = SendMessageW(*((HWND *)v2 + 4), 0x110Au, 2u, v26);
        if ( !v26 )
          v26 = (LPARAM)v20;
      }
      SendDlgItemMessageW(*((HWND *)v2 + 1), 25003, 0xBu, 0, 0);
      v15 = (LPARAM)CBindingsDlg::HtiMoveTreeItemAfter(v2, v20, (struct _TREEITEM *)v26, (struct _TREEITEM *)v22);
      SendMessageW(*((HWND *)v2 + 4), 0x110Bu, 9u, v15);
      SendDlgItemMessageW(*((HWND *)v2 + 1), 25003, 0xBu, 1u, 0);
      SetFocus(*((HWND *)v2 + 4));
    }
  }
}

//----- (6E68E81D) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnBindingUp(CBindingsDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CBindingsDlg::OnBindingUpDown(this, 1);
  return 0;
}

//----- (6E68E82E) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnBindingDown(CBindingsDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CBindingsDlg::OnBindingUpDown(this, 0);
  return 0;
}

//----- (6E68E83F) --------------------------------------------------------
int __stdcall BpiFindBindPathInList(int a1, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int v4; // edi@2
  int result; // eax@4

  v2 = *(_DWORD *)(a2 + 4);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == v2 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(v3 + 8);
      if ( !(*(int (__stdcall **)(int, _DWORD))(*(_DWORD *)a1 + 12))(a1, *(_DWORD *)v4) )
        break;
      v3 = *(_DWORD *)v3;
      if ( v3 == *(_DWORD *)(a2 + 4) )
        goto LABEL_4;
    }
    result = v4;
  }
  return result;
}

//----- (6E68E87E) --------------------------------------------------------
int __thiscall CBindingsDlg::HrOrderSubItems(CBindingsDlg *this)
{
  CBindingsDlg *v1; // ebx@1
  HWND v2; // ST00_4@1
  HWND v3; // ST00_4@2
  HWND v4; // ST00_4@5
  bool v5; // zf@5
  LRESULT i; // eax@4
  LPARAM v7; // edi@8
  LPARAM v8; // eax@12
  LPARAM lParam; // [sp+Ch] [bp-5Ch]@2
  LPARAM v11; // [sp+10h] [bp-58h]@2
  int v12; // [sp+30h] [bp-38h]@2
  char v13; // [sp+34h] [bp-34h]@2
  struct IUnknown *v14; // [sp+48h] [bp-20h]@12
  struct IUnknown *v15; // [sp+4Ch] [bp-1Ch]@3
  struct _TREEITEM *v16; // [sp+50h] [bp-18h]@2
  int v17; // [sp+54h] [bp-14h]@1
  LPARAM v18; // [sp+58h] [bp-10h]@1
  int v19; // [sp+64h] [bp-4h]@2

  v1 = this;
  v2 = (HWND)*((_DWORD *)this + 4);
  v17 = 0;
  v18 = SendMessageW(v2, 0x110Au, 0, 0);
  if ( !v18 )
    goto LABEL_18;
  do
  {
    memset(&v11, 0, 0x24u);
    v11 = v18;
    v3 = (HWND)*((_DWORD *)v1 + 4);
    lParam = 4;
    SendMessageW(v3, 0x113Eu, 0, (LPARAM)&lParam);
    CIterNetCfgBindingPath::CIterNetCfgBindingPath((CIterNetCfgBindingPath *)&v13, *(struct INetCfgComponent **)v12);
    v19 = 0;
    v16 = 0;
    if ( v17 >= 0 )
    {
      while ( 1 )
      {
        v17 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v13, (int)&v15);
        if ( v17 )
          break;
        for ( i = SendMessageW(*((HWND *)v1 + 4), 0x110Au, 4u, v18); ; i = SendMessageW(
                                                                             *((HWND *)v1 + 4),
                                                                             0x110Au,
                                                                             1u,
                                                                             v7) )
        {
          v7 = i;
          if ( !i )
            break;
          v4 = (HWND)*((_DWORD *)v1 + 4);
          lParam = 4;
          v11 = i;
          SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
          v5 = *(_DWORD *)(v12 + 28) == 0;
          v17 = v12;
          if ( v5 && BpiFindBindPathInList((int)v15, v12 + 16) )
          {
            v16 = CBindingsDlg::HtiMoveTreeItemAfter(v1, (struct _TREEITEM *)v18, v16, (struct _TREEITEM *)v7);
            *(_DWORD *)(v17 + 28) = 1;
            break;
          }
        }
        ReleaseObj(v15);
      }
    }
    v8 = SendMessageW(*((HWND *)v1 + 4), 0x110Au, 1u, v18);
    v19 = -1;
    v18 = v8;
    ReleaseObj(v14);
    CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v13);
  }
  while ( v18 );
  if ( v17 >= 0 )
LABEL_18:
    v17 = 0;
  return v17;
}

//----- (6E68E9C8) --------------------------------------------------------
void __thiscall std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy(int this)
{
  int v1; // esi@1

  v1 = this;
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::clear(this);
  operator delete(*(void **)(v1 + 4));
  *(_DWORD *)(v1 + 4) = 0;
}

//----- (6E68E9E6) --------------------------------------------------------
int __stdcall FreeBindPathInfoList(int a1)
{
  int v1; // edi@1
  int v2; // eax@1
  int v3; // esi@1
  struct IUnknown **v4; // ebx@2

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 != v2 )
  {
    do
    {
      v4 = *(struct IUnknown ***)(v3 + 8);
      ReleaseObj(*v4);
      operator delete(v4);
      v3 = *(_DWORD *)v3;
    }
    while ( v3 != *(_DWORD *)(v1 + 4) );
  }
  return std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(
           v1,
           (int)&a1,
           **(void ***)(v1 + 4),
           *(_DWORD *)(v1 + 4));
}

//----- (6E68EA30) --------------------------------------------------------
void __thiscall TREE_ITEM_DATA::~TREE_ITEM_DATA(TREE_ITEM_DATA *this)
{
  TREE_ITEM_DATA *v1; // esi@1

  v1 = this;
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)((char *)this + 16));
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)((char *)v1 + 4));
}

//----- (6E68EA52) --------------------------------------------------------
int __thiscall std::list<HTREEITEMP,std::nc_allocator<HTREEITEMP>>::pop_front(int this)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  return std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::erase(this, (int)&v2, **(void ***)(this + 4));
}

//----- (6E68EA6D) --------------------------------------------------------
void *__thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>(void *this)
{
  void *v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  v2 = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  *((_DWORD *)v1 + 2) = 0;
  *((_DWORD *)v1 + 1) = v2;
  return v1;
}

//----- (6E68EA87) --------------------------------------------------------
void __thiscall CIterTreeView::EraseAndDeleteAll(CIterTreeView *this)
{
  CIterTreeView *i; // esi@1

  for ( i = this; *((_DWORD *)i + 3); std::list<HTREEITEMP,std::nc_allocator<HTREEITEMP>>::pop_front((int)((char *)i + 4)) )
    ;
}

//----- (6E68EAAB) --------------------------------------------------------
void *__thiscall TREE_ITEM_DATA::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  TREE_ITEM_DATA::~TREE_ITEM_DATA((TREE_ITEM_DATA *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6E68EAD1) --------------------------------------------------------
void __thiscall CIterTreeView::~CIterTreeView(CIterTreeView *this)
{
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)((char *)this + 4));
}

//----- (6E68EADE) --------------------------------------------------------
int __thiscall TREE_ITEM_DATA::TREE_ITEM_DATA(int this)
{
  int v1; // esi@1

  v1 = this;
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>((void *)(this + 4));
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>((void *)(v1 + 16));
  return v1;
}

//----- (6E68EB10) --------------------------------------------------------
__int32 __stdcall CBindingsDlg::OnTreeDeleteItem(int a2, struct tagNMHDR *a3, int *a4)
{
  UINT_PTR v3; // esi@1

  v3 = a3[4].idFrom;
  if ( v3 )
  {
    ReleaseObj(*(struct IUnknown **)v3);
    FreeBindPathInfoList(v3 + 4);
    FreeBindPathInfoList(v3 + 16);
    TREE_ITEM_DATA::`scalar deleting destructor'((void *)v3, 1);
  }
  return 0;
}

//----- (6E68EB4E) --------------------------------------------------------
LRESULT __thiscall CBindingsDlg::HtiAddTreeViewItem(CBindingsDlg *this, struct IUnknown *a2, struct _TREEITEM *a3)
{
  int v3; // esi@1
  int v4; // eax@5
  HWND v5; // ST00_4@8
  LPARAM lParam; // [sp+Ch] [bp-84h]@5
  int Dst; // [sp+10h] [bp-80h]@5
  int v9; // [sp+14h] [bp-7Ch]@8
  int v10; // [sp+1Ch] [bp-74h]@8
  int v11; // [sp+20h] [bp-70h]@8
  LPVOID v12; // [sp+24h] [bp-6Ch]@8
  int v13; // [sp+2Ch] [bp-64h]@8
  int v14; // [sp+30h] [bp-60h]@8
  int v15; // [sp+38h] [bp-58h]@8
  int v16; // [sp+50h] [bp-40h]@5
  struct _SP_CLASSIMAGELIST_DATA ClassImageListData; // [sp+54h] [bp-3Ch]@1
  int ImageIndex; // [sp+60h] [bp-30h]@4
  CBindingsDlg *v19; // [sp+64h] [bp-2Ch]@1
  LPVOID pv; // [sp+68h] [bp-28h]@2
  LRESULT v21; // [sp+6Ch] [bp-24h]@1
  GUID ClassGuid; // [sp+70h] [bp-20h]@3
  int v23; // [sp+8Ch] [bp-4h]@5

  v3 = 0;
  v19 = this;
  v21 = 0;
  if ( HrSetupDiGetClassImageList(&ClassImageListData) >= 0 )
  {
    if ( ((int (__stdcall *)(struct IUnknown *, LPVOID *))a2->lpVtbl[1].QueryInterface)(a2, &pv) >= 0
      && ((int (__stdcall *)(struct IUnknown *, GUID *))a2->lpVtbl[3].AddRef)(a2, &ClassGuid) >= 0
      && HrSetupDiGetClassImageIndex(&ClassImageListData, &ClassGuid, &ImageIndex) >= 0 )
    {
      lParam = 0;
      memset(&Dst, 0, 0x40u);
      v4 = (int)operator new(0x20u);
      v16 = v4;
      v23 = 0;
      if ( v4 )
        v3 = TREE_ITEM_DATA::TREE_ITEM_DATA(v4);
      v23 = -1;
      if ( v3 )
      {
        *(_DWORD *)v3 = a2;
        AddRefObj(a2);
        *(_DWORD *)(v3 + 28) = 0;
        v13 = ImageIndex;
        v14 = ImageIndex;
        v12 = pv;
        v5 = (HWND)*((_DWORD *)v19 + 4);
        v9 = 47;
        v11 = 61472;
        v10 = 4128;
        v15 = v3;
        lParam = (LPARAM)a3;
        Dst = -65534;
        v21 = SendMessageW(v5, 0x1132u, 0, (LPARAM)&lParam);
        CoTaskMemFree(pv);
      }
    }
    HrSetupDiDestroyClassImageList(&ClassImageListData);
  }
  return v21;
}

//----- (6E68EC6C) --------------------------------------------------------
void __thiscall CIterTreeView::Reset(CIterTreeView *this)
{
  CIterTreeView *v1; // esi@1
  LRESULT v2; // eax@1
  LRESULT v3; // [sp+4h] [bp-4h]@2

  v1 = this;
  CIterTreeView::EraseAndDeleteAll(this);
  v2 = SendMessageW(*(HWND *)v1, 0x110Au, 0, 0);
  if ( v2 )
  {
    v3 = v2;
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
      (char *)v1 + 4,
      **((_DWORD **)v1 + 2),
      (int)&v3);
  }
}

//----- (6E68ECAC) --------------------------------------------------------
void __thiscall CIterTreeView::PushAndAlloc(CIterTreeView *this, struct _TREEITEM *a2)
{
  std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
    (char *)this + 4,
    **((_DWORD **)this + 2),
    (int)&a2);
}

//----- (6E68ECD2) --------------------------------------------------------
void __stdcall AddToListIfNotAlreadyAdded(int a1, void *lpMem)
{
  int v2; // eax@1
  int v3; // esi@1
  struct IUnknown **v4; // ebx@2

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 == v2 )
  {
LABEL_5:
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
      (void *)a1,
      *(_DWORD *)(a1 + 4),
      (int)&lpMem);
  }
  else
  {
    v4 = (struct IUnknown **)lpMem;
    while ( (*(int (__stdcall **)(_DWORD, struct IUnknown *))(***(_DWORD ***)(v3 + 8) + 12))(**(_DWORD **)(v3 + 8), *v4) )
    {
      v3 = *(_DWORD *)v3;
      if ( v3 == *(_DWORD *)(a1 + 4) )
        goto LABEL_5;
    }
    ReleaseObj(*v4);
    operator delete(v4);
  }
}

//----- (6E68ED2C) --------------------------------------------------------
void __thiscall CBindingsDlg::AssociateBinding(CBindingsDlg *this, struct IUnknown *a2, LPARAM a3, unsigned __int32 a4)
{
  HWND v4; // ST00_4@1
  int v5; // esi@1
  void *v6; // ebx@2
  void *v7; // ebx@5
  CBindingsDlg *v8; // esi@8
  LPARAM v9; // eax@8
  LPARAM lParam; // [sp+Ch] [bp-2Ch]@1
  LPARAM v11; // [sp+10h] [bp-28h]@1
  int v12; // [sp+30h] [bp-8h]@1
  CBindingsDlg *v13; // [sp+34h] [bp-4h]@1

  memset(&v11, 0, 0x24u);
  v11 = a3;
  v4 = (HWND)*((_DWORD *)this + 4);
  v13 = this;
  lParam = 20;
  SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
  v5 = v12;
  if ( a4 & 1 )
  {
    v6 = operator new(8u);
    if ( v6 )
    {
      *(_DWORD *)v6 = a2;
      AddRefObj(a2);
      *((_DWORD *)v6 + 1) = 0;
      AddToListIfNotAlreadyAdded(v5 + 4, v6);
    }
  }
  if ( a4 & 2 )
  {
    v7 = operator new(8u);
    if ( v7 )
    {
      *(_DWORD *)v7 = a2;
      AddRefObj(a2);
      *((_DWORD *)v7 + 1) = 0;
      AddToListIfNotAlreadyAdded(v5 + 16, v7);
    }
  }
  if ( a4 & 8 )
  {
    v8 = v13;
    v9 = SendMessageW(*((HWND *)v13 + 4), 0x110Au, 3u, a3);
    if ( v9 )
      CBindingsDlg::AssociateBinding(v8, a2, v9, a4);
  }
}

//----- (6E68EDFC) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::HrHandleValidSubItem(CBindingsDlg *this, struct IUnknown *a2, struct IUnknown *a3, struct IUnknown *a4, struct _TREEITEM *a5, struct TREE_ITEM_DATA *a6)
{
  CBindingsDlg *v6; // edi@1
  LPARAM v7; // esi@2

  v6 = this;
  if ( a4 != *(struct IUnknown **)a6 )
  {
    v7 = CBindingsDlg::HtiIsSubItem(this, (struct INetCfgComponent *)a4, a5);
    if ( !v7 )
      v7 = CBindingsDlg::HtiAddTreeViewItem(v6, a4, a5);
    CBindingsDlg::AssociateBinding(v6, a3, v7, 3u);
    CBindingsDlg::AssociateBinding(v6, a2, v7, 1u);
  }
  return 0;
}

//----- (6E68EE54) --------------------------------------------------------
LPARAM __thiscall CIterTreeView::HtiNext(CIterTreeView *this)
{
  CIterTreeView *v1; // esi@1
  LPARAM result; // eax@2
  LRESULT v3; // eax@3
  LRESULT v4; // edi@6
  LPARAM lParam; // [sp+4h] [bp-4h]@3

  v1 = this;
  if ( *((_DWORD *)this + 3) )
  {
    lParam = *(_DWORD *)(**((_DWORD **)this + 2) + 8);
    v3 = SendMessageW(*(HWND *)this, 0x110Au, 4u, *(_DWORD *)(**((_DWORD **)this + 2) + 8));
    if ( v3
      || (std::list<HTREEITEMP,std::nc_allocator<HTREEITEMP>>::pop_front((int)((char *)v1 + 4)),
          (v3 = SendMessageW(*(HWND *)v1, 0x110Au, 1u, lParam)) != 0) )
    {
      CIterTreeView::PushAndAlloc(v1, (struct _TREEITEM *)v3);
    }
    else if ( *((_DWORD *)v1 + 3) )
    {
      v4 = SendMessageW(*(HWND *)v1, 0x110Au, 1u, *(_DWORD *)(**((_DWORD **)v1 + 2) + 8));
      std::list<HTREEITEMP,std::nc_allocator<HTREEITEMP>>::pop_front((int)((char *)v1 + 4));
      if ( v4 )
        CIterTreeView::PushAndAlloc(v1, (struct _TREEITEM *)v4);
    }
    result = lParam;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E68EEDB) --------------------------------------------------------
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(int this, int a2, int a3, int a4, int a5, unsigned int a6, int a7)
{
  int v7; // ecx@3
  int result; // eax@3

  if ( this != a3 )
  {
    std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::_Incsize(this, a6);
    *(_DWORD *)(a3 + 8) -= a6;
  }
  **(_DWORD **)(a4 + 4) = a5;
  **(_DWORD **)(a5 + 4) = a2;
  **(_DWORD **)(a2 + 4) = a4;
  v7 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a5 + 4);
  *(_DWORD *)(a5 + 4) = *(_DWORD *)(a4 + 4);
  result = a4;
  *(_DWORD *)(a4 + 4) = v7;
  return result;
}

//----- (6E68EF42) --------------------------------------------------------
CIterTreeView *__thiscall CIterTreeView::CIterTreeView(int this, int a2)
{
  CIterTreeView *v2; // esi@1

  v2 = (CIterTreeView *)this;
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>((void *)(this + 4));
  *(_DWORD *)v2 = a2;
  CIterTreeView::Reset(v2);
  return v2;
}

//----- (6E68EF7A) --------------------------------------------------------
void __thiscall CBindingsDlg::SetCheckboxStates(CBindingsDlg *this)
{
  CBindingsDlg *v1; // ebx@1
  LPARAM i; // eax@1
  HWND v3; // ST00_4@2
  int v4; // edi@2
  int v5; // eax@2
  int v6; // esi@2
  int v7; // eax@6
  int v8; // eax@7
  LPARAM lParam; // [sp+Ch] [bp-4Ch]@1
  LPARAM v10; // [sp+10h] [bp-48h]@1
  int v11; // [sp+14h] [bp-44h]@9
  int v12; // [sp+18h] [bp-40h]@6
  int v13; // [sp+30h] [bp-28h]@2
  char v14; // [sp+34h] [bp-24h]@1
  char v15; // [sp+38h] [bp-20h]@10
  int v16; // [sp+44h] [bp-14h]@1
  int v17; // [sp+48h] [bp-10h]@2
  int v18; // [sp+54h] [bp-4h]@1

  v1 = this;
  CIterTreeView::CIterTreeView((int)&v14, *((_DWORD *)this + 4));
  lParam = 0;
  v18 = 0;
  memset(&v10, 0, 0x24u);
  v16 = FHasPermission((HKEY)9);
  for ( i = CIterTreeView::HtiNext((CIterTreeView *)&v14); i; i = CIterTreeView::HtiNext((CIterTreeView *)&v14) )
  {
    v10 = i;
    v3 = (HWND)*((_DWORD *)v1 + 4);
    lParam = 20;
    SendMessageW(v3, 0x113Eu, 0, (LPARAM)&lParam);
    v17 = 0;
    v4 = v13 + 20;
    v5 = *(_DWORD *)(v13 + 20);
    v6 = *(_DWORD *)v5;
    if ( *(_DWORD *)v5 != v5 )
    {
      do
      {
        if ( !(*(int (__stdcall **)(_DWORD))(***(_DWORD ***)(v6 + 8) + 20))(**(_DWORD **)(v6 + 8)) )
          ++v17;
        v6 = *(_DWORD *)v6;
      }
      while ( v6 != *(_DWORD *)v4 );
    }
    v7 = 0;
    lParam = 8;
    v12 = 61440;
    if ( v16 )
    {
      LOBYTE(v7) = v17 == 0;
      v8 = v7 + 1;
    }
    else
    {
      LOBYTE(v7) = v17 != 0;
      v8 = v7 + 3;
    }
    v11 = v8 << 12;
    SendMessageW(*((HWND *)v1 + 4), 0x113Fu, 0, (LPARAM)&lParam);
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v15);
}

//----- (6E68F06C) --------------------------------------------------------
int __thiscall CBindingsDlg::HrHandleSubItem(CBindingsDlg *this, struct IUnknown *a2, struct IUnknown *a3, struct TREE_ITEM_DATA *a4, struct _TREEITEM *a5)
{
  struct IUnknown *v5; // esi@1
  struct IUnknownVtbl *v6; // eax@1
  struct IUnknown *v7; // edi@1
  int v8; // ebx@2
  int v10; // [sp+Ch] [bp-Ch]@1
  int v11; // [sp+10h] [bp-8h]@1
  CBindingsDlg *v12; // [sp+14h] [bp-4h]@1

  v5 = a2;
  v6 = a2->lpVtbl;
  v12 = this;
  ((void (__stdcall *)(struct IUnknown *, int *))v6[3].QueryInterface)(a2, &v10);
  v7 = a3;
  ((void (__stdcall *)(struct IUnknown *, int *))a3->lpVtbl[3].QueryInterface)(a3, &v11);
  if ( v11 - v10 == 1 || (v8 = CBindingsDlg::HrComponentIsHidden(v7, v11 - v10)) == 0 )
  {
    v8 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown **))v5->lpVtbl[2].Release)(v5, &a2);
    if ( v8 >= 0 )
    {
      if ( !FIsHidden((struct INetCfgComponent *)a2) )
        v8 = CBindingsDlg::HrHandleValidSubItem(v12, v5, v7, a2, a5, a4);
      ReleaseObj(a2);
    }
  }
  CBindingsDlg::AssociateBinding(v12, v5, (LPARAM)a5, 9u);
  return v8;
}

//----- (6E68F104) --------------------------------------------------------
int __thiscall CBindingsDlg::HrHandleTopLevel(CBindingsDlg *this, struct INetCfgBindingPath *a2)
{
  CBindingsDlg *v2; // esi@1
  struct INetCfgBindingPath *v3; // ebx@1
  HWND v4; // ST00_4@3
  LPARAM v5; // edi@4
  LRESULT v6; // eax@7
  LPARAM v8; // [sp-8h] [bp-60h]@8
  int v9; // [sp-4h] [bp-5Ch]@0
  LPARAM lParam; // [sp+Ch] [bp-4Ch]@2
  LPARAM v11; // [sp+10h] [bp-48h]@2
  int v12; // [sp+30h] [bp-28h]@3
  char v13; // [sp+34h] [bp-24h]@2
  char v14; // [sp+38h] [bp-20h]@10
  int v15; // [sp+44h] [bp-14h]@1
  unsigned int v16; // [sp+48h] [bp-10h]@6
  int v17; // [sp+54h] [bp-4h]@2

  v2 = this;
  v3 = a2;
  v15 = ((int (__stdcall *)(struct INetCfgBindingPath *, struct INetCfgBindingPath **, int))a2->lpVtbl->GetOwner)(
          a2,
          &a2,
          v9);
  if ( v15 >= 0 )
  {
    CIterTreeView::CIterTreeView((int)&v13, *((_DWORD *)v2 + 4));
    lParam = 0;
    v17 = 0;
    memset(&v11, 0, 0x24u);
    while ( 1 )
    {
      v5 = CIterTreeView::HtiNext((CIterTreeView *)&v13);
      if ( !v5 )
        break;
      v4 = (HWND)*((_DWORD *)v2 + 4);
      lParam = 20;
      v11 = v5;
      SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
      if ( *(struct INetCfgBindingPath **)v12 == a2 )
      {
        v8 = v5;
        goto LABEL_9;
      }
    }
    if ( !FIsHidden((struct INetCfgComponent *)a2) )
    {
      v3->lpVtbl->GetDepth(v3, (ULONG *)&v16);
      if ( v16 > 2 )
      {
        v6 = CBindingsDlg::HtiAddTreeViewItem(v2, (struct IUnknown *)a2, 0);
        if ( v6 )
        {
          v8 = v6;
LABEL_9:
          CBindingsDlg::AssociateBinding(v2, (struct IUnknown *)v3, v8, 3u);
          goto LABEL_10;
        }
      }
    }
LABEL_10:
    ReleaseObj((struct IUnknown *)a2);
    std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v14);
  }
  return v15;
}

//----- (6E68F1DA) --------------------------------------------------------
int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::splice(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edx@2

  result = a4;
  if ( a4 != *(_DWORD *)(a3 + 4) )
  {
    v5 = *(_DWORD *)a4;
    if ( this != a3 || a2 != a4 && a2 != v5 )
      result = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(this, a2, a3, a4, v5, 1u, 0);
  }
  return result;
}

//----- (6E68F214) --------------------------------------------------------
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::splice(int this, int a2, int a3)
{
  unsigned int v3; // edi@2
  int result; // eax@3

  if ( this != a3 )
  {
    v3 = *(_DWORD *)(a3 + 8);
    if ( v3 )
      result = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(
                 this,
                 a2,
                 a3,
                 **(_DWORD **)(a3 + 4),
                 *(_DWORD *)(a3 + 4),
                 v3,
                 0);
  }
  return result;
}

//----- (6E68F247) --------------------------------------------------------
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::merge(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // edi@2
  int v6; // ST24_4@5
  int v7; // [sp+4h] [bp-8h]@1
  int v8; // [sp+8h] [bp-4h]@2

  result = a2;
  v7 = this;
  if ( a2 != this )
  {
    v3 = *(_DWORD *)(this + 4);
    v4 = **(_DWORD **)(a2 + 4);
    v5 = *(_DWORD *)v3;
    v8 = *(_DWORD *)(a2 + 4);
    if ( *(_DWORD *)v3 == v3 )
    {
LABEL_9:
      if ( v4 != v8 )
        result = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(
                   v7,
                   v3,
                   result,
                   v4,
                   v8,
                   *(_DWORD *)(result + 8),
                   0);
    }
    else
    {
      while ( v4 != v8 )
      {
        result = CSortableBindPath::operator<((void *)(v4 + 8), v5 + 8);
        if ( (_BYTE)result )
        {
          v6 = *(_DWORD *)v4;
          result = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(
                     v7,
                     v5,
                     a2,
                     v4,
                     *(_DWORD *)v4,
                     1u,
                     0);
          v4 = v6;
        }
        else
        {
          v5 = *(_DWORD *)v5;
        }
        if ( v5 == v3 )
        {
          result = a2;
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

//----- (6E68F2CB) --------------------------------------------------------
void __thiscall CBindingsDlg::ToggleCheckbox(CBindingsDlg *this, struct _TREEITEM *a2)
{
  CBindingsDlg *v2; // esi@1
  signed int v3; // ebx@2
  HWND v4; // ST00_4@2
  int v5; // edi@3
  int v6; // eax@5
  int v7; // esi@5
  LPARAM lParam; // [sp+4h] [bp-2Ch]@2
  struct _TREEITEM *v9; // [sp+8h] [bp-28h]@2
  int v10; // [sp+Ch] [bp-24h]@2
  int v11; // [sp+10h] [bp-20h]@2
  int v12; // [sp+28h] [bp-8h]@3
  CBindingsDlg *v13; // [sp+2Ch] [bp-4h]@1

  v2 = this;
  v13 = this;
  if ( FHasPermission((HKEY)9) )
  {
    memset(&v9, 0, 0x24u);
    v9 = a2;
    v3 = 0;
    v4 = (HWND)*((_DWORD *)v2 + 4);
    lParam = 28;
    v11 = 61440;
    SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
    if ( v10 & 0x1000 )
    {
      v5 = v12 + 16;
    }
    else
    {
      v5 = v12 + 4;
      v3 = 1;
    }
    v6 = *(_DWORD *)(v5 + 4);
    v7 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 != v6 )
    {
      do
      {
        (*(void (__stdcall **)(_DWORD, signed int))(***(_DWORD ***)(v7 + 8) + 24))(**(_DWORD **)(v7 + 8), v3);
        v7 = *(_DWORD *)v7;
      }
      while ( v7 != *(_DWORD *)(v5 + 4) );
    }
    CBindingsDlg::SetCheckboxStates(v13);
  }
}

//----- (6E68F360) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnClickOrDoubleClick(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int a4)
{
  CBindingsDlg *v4; // ebx@1
  unsigned int v5; // esi@2
  HWND v6; // ST00_4@2
  LRESULT v7; // eax@2
  struct tagRECT Rect; // [sp+4h] [bp-20h]@2
  LPARAM lParam; // [sp+14h] [bp-10h]@2
  LONG v11; // [sp+18h] [bp-Ch]@2
  int v12; // [sp+1Ch] [bp-8h]@2
  int v13; // [sp+20h] [bp-4h]@2

  v4 = this;
  if ( a2 == 25003 )
  {
    lParam = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v5 = GetMessagePos();
    GetWindowRect(*((HWND *)v4 + 4), &Rect);
    lParam = (unsigned __int16)v5 - Rect.left;
    v6 = (HWND)*((_DWORD *)v4 + 4);
    v11 = (v5 >> 16) - Rect.top;
    v7 = SendMessageW(v6, 0x1111u, 0, (LPARAM)&lParam);
    if ( v7 )
    {
      if ( v12 & 0x40 || v12 & 0x46 && a4 )
        CBindingsDlg::ToggleCheckbox(v4, (struct _TREEITEM *)v7);
    }
  }
  return 0;
}

//----- (6E68F3E9) --------------------------------------------------------
int __stdcall CBindingsDlg::HrOrderDisableList(struct TREE_ITEM_DATA *a2)
{
  struct TREE_ITEM_DATA *v1; // esi@1
  int v2; // eax@1
  int v3; // ebx@2
  int *v4; // eax@4
  int v5; // edi@4
  int v6; // eax@7
  char v8; // [sp+Ch] [bp-30h]@4
  struct IUnknown *v9; // [sp+20h] [bp-1Ch]@9
  char v10; // [sp+24h] [bp-18h]@7
  int v11; // [sp+28h] [bp-14h]@6
  struct IUnknown *v12; // [sp+2Ch] [bp-10h]@1
  int v13; // [sp+38h] [bp-4h]@4

  v1 = a2;
  v12 = 0;
  v2 = *(_DWORD *)(**((_DWORD **)a2 + 5) + 8);
  if ( !v2 )
    goto LABEL_15;
  v3 = (*(int (__stdcall **)(_DWORD, struct IUnknown **))(**(_DWORD **)v2 + 32))(*(_DWORD *)v2, &v12);
  if ( v3 >= 0 )
  {
    if ( v12 )
    {
      CIterNetCfgBindingPath::CIterNetCfgBindingPath((CIterNetCfgBindingPath *)&v8, (struct INetCfgComponent *)v12);
      v4 = (int *)*((_DWORD *)v1 + 5);
      v13 = 0;
      v5 = *v4;
      while ( 1 )
      {
        v3 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v8, (int)&a2);
        if ( v3 )
          break;
        v11 = BpiFindBindPathInList((int)a2, (int)((char *)v1 + 16));
        if ( v11 )
        {
          v6 = std::find<std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::iterator,BIND_PATH_INFO *>(
                 (int)&v10,
                 **((_DWORD **)v1 + 5),
                 *((_DWORD *)v1 + 5),
                 (int)&v11);
          std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::splice(
            (int)((char *)v1 + 16),
            v5,
            (int)((char *)v1 + 16),
            *(_DWORD *)v6);
          v5 = *(_DWORD *)v5;
        }
        ReleaseObj((struct IUnknown *)a2);
      }
      ReleaseObj(v12);
      ReleaseObj(v9);
      CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v8);
    }
    if ( v3 >= 0 )
LABEL_15:
      v3 = 0;
  }
  return v3;
}

//----- (6E68F4B9) --------------------------------------------------------
int __thiscall CBindingsDlg::HrOrderDisableLists(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  int v2; // ebx@1
  LPARAM v3; // eax@1
  HWND v4; // ST00_4@3
  LPARAM lParam; // [sp+Ch] [bp-44h]@1
  LPARAM v7; // [sp+10h] [bp-40h]@1
  struct TREE_ITEM_DATA *v8; // [sp+30h] [bp-20h]@3
  char v9; // [sp+34h] [bp-1Ch]@1
  char v10; // [sp+38h] [bp-18h]@6
  int v11; // [sp+4Ch] [bp-4h]@1

  v1 = this;
  v2 = 0;
  CIterTreeView::CIterTreeView((int)&v9, *((_DWORD *)this + 4));
  lParam = 0;
  memset(&v7, 0, 0x24u);
  v11 = 0;
  v3 = CIterTreeView::HtiNext((CIterTreeView *)&v9);
  if ( v3 )
  {
    while ( v2 >= 0 )
    {
      v7 = v3;
      v4 = (HWND)*((_DWORD *)v1 + 4);
      lParam = 4;
      SendMessageW(v4, 0x113Eu, 0, (LPARAM)&lParam);
      v2 = CBindingsDlg::HrOrderDisableList(v8);
      v3 = CIterTreeView::HtiNext((CIterTreeView *)&v9);
      if ( !v3 )
      {
        if ( v2 < 0 )
          break;
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    v2 = 0;
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v10);
  return v2;
}

//----- (6E68F545) --------------------------------------------------------
int __thiscall CBindingsDlg::HrHandleSubpath(CBindingsDlg *this, int a2, struct IUnknown *a3)
{
  int *v3; // eax@1
  int v4; // edi@1
  struct IUnknown *v5; // esi@5
  struct IUnknown v6; // eax@5
  HWND v7; // ST00_4@13
  int v8; // edi@13
  int v9; // eax@13
  int v10; // esi@13
  LPARAM v11; // ebx@17
  LPARAM lParam; // [sp+Ch] [bp-60h]@11
  LPARAM v14; // [sp+10h] [bp-5Ch]@11
  int v15; // [sp+30h] [bp-3Ch]@13
  char v16; // [sp+34h] [bp-38h]@11
  char v17; // [sp+38h] [bp-34h]@18
  struct TREE_ITEM_DATA *v18; // [sp+44h] [bp-28h]@13
  int v19; // [sp+48h] [bp-24h]@1
  struct IUnknown *v20; // [sp+4Ch] [bp-20h]@5
  int v21; // [sp+50h] [bp-1Ch]@1
  CBindingsDlg *v22; // [sp+54h] [bp-18h]@1
  struct IUnknown *v23; // [sp+58h] [bp-14h]@5
  int v24; // [sp+5Ch] [bp-10h]@1
  int v25; // [sp+68h] [bp-4h]@11

  v22 = this;
  v3 = *(int **)(a2 + 4);
  v4 = *v3;
  v24 = 0;
  v19 = 0;
  v21 = v4;
  if ( (int *)v4 == v3 )
  {
LABEL_21:
    v24 = v19 == 0;
  }
  else
  {
    while ( v24 >= 0 )
    {
      v5 = *(struct IUnknown **)(v4 + 8);
      v23 = 0;
      v6.lpVtbl = v5->lpVtbl;
      v20 = v5;
      if ( ((int (__stdcall *)(struct IUnknown *, struct IUnknown *))v6.lpVtbl[1].QueryInterface)(v5, a3) )
      {
        v24 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown **))v5->lpVtbl[2].Release)(v5, &v23);
        if ( v24 >= 0 )
        {
          if ( v23 )
          {
            if ( FIsHidden((struct INetCfgComponent *)v23) )
            {
              ReleaseObj(v23);
            }
            else
            {
              ReleaseObj(v23);
              v24 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *))a3->lpVtbl[1].AddRef)(a3, v5);
              if ( !v24 )
              {
                CIterTreeView::CIterTreeView((int)&v16, *((_DWORD *)v22 + 4));
                lParam = 0;
                v25 = 0;
                memset(&v14, 0, 0x24u);
                while ( 1 )
                {
                  v11 = CIterTreeView::HtiNext((CIterTreeView *)&v16);
                  if ( !v11 || v24 < 0 )
                    break;
                  v7 = (HWND)*((_DWORD *)v22 + 4);
                  lParam = 20;
                  v14 = v11;
                  SendMessageW(v7, 0x113Eu, 0, (LPARAM)&lParam);
                  v8 = v15 + 8;
                  v18 = (struct TREE_ITEM_DATA *)v15;
                  v9 = *(_DWORD *)(v15 + 8);
                  v10 = *(_DWORD *)v9;
                  if ( *(_DWORD *)v9 != v9 )
                  {
                    do
                    {
                      if ( !(*(int (__stdcall **)(_DWORD, struct IUnknown *))(***(_DWORD ***)(v10 + 8) + 12))(
                              **(_DWORD **)(v10 + 8),
                              v20) )
                      {
                        v24 = CBindingsDlg::HrHandleSubItem(v22, a3, v20, v18, (struct _TREEITEM *)v11);
                        v19 = 1;
                      }
                      v10 = *(_DWORD *)v10;
                    }
                    while ( v10 != *(_DWORD *)v8 );
                  }
                }
                v25 = -1;
                std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v17);
                v4 = v21;
              }
            }
          }
        }
      }
      v21 = *(_DWORD *)v4;
      if ( v21 == *(_DWORD *)(a2 + 4) )
      {
        if ( v24 < 0 )
          return v24;
        goto LABEL_21;
      }
      v4 = v21;
    }
  }
  return v24;
}

//----- (6E68F6C5) --------------------------------------------------------
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::swap(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 4);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = v3;
  v4 = *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = v4;
  return result;
}

//----- (6E68F6F0) --------------------------------------------------------
signed int __thiscall CBindingsDlg::OnTreeKeyDown(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CBindingsDlg *v4; // esi@1
  LRESULT v5; // eax@2

  v4 = this;
  if ( 32 == LOWORD(a3[1].hwndFrom) )
  {
    v5 = SendMessageW(*((HWND *)this + 4), 0x110Au, 9u, 0);
    if ( v5 )
      CBindingsDlg::ToggleCheckbox(v4, (struct _TREEITEM *)v5);
  }
  return 1;
}

//----- (6E68F72F) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnClick(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  return CBindingsDlg::OnClickOrDoubleClick(this, a2, a3, 0);
}

//----- (6E68F74A) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnDoubleClick(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  return CBindingsDlg::OnClickOrDoubleClick(this, a2, a3, 1);
}

//----- (6E68F765) --------------------------------------------------------
void __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::sort(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@2
  char *v3; // ecx@4
  char *v4; // ecx@14
  char v5[12]; // [sp+0h] [bp-164h]@17
  char v6[12]; // [sp+Ch] [bp-158h]@2
  char v7; // [sp+18h] [bp-14Ch]@14
  char v8; // [sp+12Ch] [bp-38h]@9
  char v9; // [sp+144h] [bp-20h]@3
  int *v10; // [sp+148h] [bp-1Ch]@2
  int v11; // [sp+14Ch] [bp-18h]@2
  char *i; // [sp+150h] [bp-14h]@4
  unsigned int v13; // [sp+154h] [bp-10h]@3
  int v14; // [sp+160h] [bp-4h]@2

  v1 = this;
  if ( *(_DWORD *)(this + 8) >= 2u )
  {
    v2 = 0;
    v10 = (int *)std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
    v11 = 0;
    v14 = 0;
    `eh vector constructor iterator'(
      v6,
      0xCu,
      26,
      (int)std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>,
      std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::~list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>);
    LOBYTE(v14) = 1;
    while ( *(_DWORD *)(v1 + 8) )
    {
      std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Splice(
        (int)&v9,
        *v10,
        v1,
        **(_DWORD **)(v1 + 4),
        ***(_DWORD ***)(v1 + 4),
        1u,
        0);
      v13 = 0;
      if ( !v2 )
        goto LABEL_20;
      v3 = v6;
      for ( i = v6; ; v3 = i )
      {
        if ( *((_DWORD *)v3 + 2) )
        {
          std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::merge((int)v3, (int)&v9);
          std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::swap((int)i, (int)&v9);
          ++v13;
          i += 12;
          if ( v13 < v2 )
            continue;
        }
        break;
      }
      if ( v13 == 25 )
      {
        std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::merge((int)&v8, (int)&v9);
      }
      else
      {
LABEL_20:
        std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::swap((int)&v6[12 * v13], (int)&v9);
        if ( v13 == v2 )
          ++v2;
      }
    }
    if ( v2 > 1 )
    {
      v4 = &v7;
      i = &v7;
      v13 = v2 - 1;
      while ( 1 )
      {
        std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::merge((int)v4, (int)(v4 - 12));
        i += 12;
        --v13;
        if ( !v13 )
          break;
        v4 = i;
      }
    }
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::splice(
      v1,
      **(_DWORD **)(v1 + 4),
      (int)&v5[12 * v2]);
    LOBYTE(v14) = 0;
    `eh vector destructor iterator'(
      v6,
      0xCu,
      26,
      std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::~list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>);
    std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v9);
  }
}
// 6E68F765: using guessed type char var_158[12];
// 6E68F765: using guessed type char var_164[12];

//----- (6E68F8B7) --------------------------------------------------------
void __thiscall CBindingsDlg::BuildBindingsList(CBindingsDlg *this, struct INetCfgComponent *a2)
{
  CBindingsDlg *v2; // esi@1
  HWND v3; // ST00_4@1
  int v4; // eax@2
  struct INetCfgComponent v5; // eax@5
  LPARAM v6; // eax@15
  int v7; // edi@15
  struct INetCfgComponentVtbl *i; // esi@15
  char v9; // [sp+Ch] [bp-3Ch]@1
  struct IUnknown *v10; // [sp+20h] [bp-28h]@19
  int v11; // [sp+24h] [bp-24h]@3
  struct INetCfgComponentVtbl **v12; // [sp+28h] [bp-20h]@1
  int v13; // [sp+2Ch] [bp-1Ch]@1
  HICON hInstance; // [sp+30h] [bp-18h]@1
  struct INetCfgBindingPath *v15; // [sp+34h] [bp-14h]@9
  struct INetCfgComponent v16; // [sp+38h] [bp-10h]@2
  int v17; // [sp+44h] [bp-4h]@1

  v2 = this;
  v12 = (struct INetCfgComponentVtbl **)std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v13 = 0;
  v17 = 0;
  CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath((CIterNetCfgUpperBindingPath *)&v9, a2);
  hInstance = BeginWaitCursor();
  v3 = (HWND)*((_DWORD *)v2 + 1);
  LOBYTE(v17) = 2;
  SendDlgItemMessageW(v3, 25003, 0xBu, 0, 0);
  while ( 1 )
  {
    v4 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v9, (int)&v16);
    a2 = (struct INetCfgComponent *)v4;
    if ( v4 )
      break;
    a2 = (struct INetCfgComponent *)v16.lpVtbl;
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(&v11, (int)v12, (int)&a2);
  }
  if ( v4 >= 0 )
  {
    std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::sort((int)&v11);
    v5.lpVtbl = *v12;
    v16.lpVtbl = v5.lpVtbl;
    if ( (struct INetCfgComponentVtbl **)v5.lpVtbl == v12 )
    {
LABEL_12:
      if ( (signed int)a2 >= 0 )
      {
        a2 = (struct INetCfgComponent *)CBindingsDlg::HrOrderDisableLists(v2);
        if ( (signed int)a2 >= 0 )
          a2 = (struct INetCfgComponent *)CBindingsDlg::HrOrderSubItems(v2);
      }
    }
    else
    {
      while ( (signed int)a2 >= 0 )
      {
        v15 = (struct INetCfgBindingPath *)v5.lpVtbl->Release;
        a2 = (struct INetCfgComponent *)CBindingsDlg::HrHandleSubpath(v2, (int)&v11, (struct IUnknown *)v15);
        if ( a2 == (struct INetCfgComponent *)1 )
          a2 = (struct INetCfgComponent *)CBindingsDlg::HrHandleTopLevel(v2, v15);
        v16.lpVtbl = (struct INetCfgComponentVtbl *)v16.lpVtbl->QueryInterface;
        if ( (struct INetCfgComponentVtbl **)v16.lpVtbl == v12 )
          goto LABEL_12;
        v5.lpVtbl = v16.lpVtbl;
      }
    }
  }
  SendDlgItemMessageW(*((HWND *)v2 + 1), 25003, 0xBu, 1u, 0);
  v6 = SendMessageW(*((HWND *)v2 + 4), 0x110Au, 0, 0);
  SendMessageW(*((HWND *)v2 + 4), 0x110Bu, 9u, v6);
  v7 = (int)v12;
  for ( i = *v12;
        i != (struct INetCfgComponentVtbl *)v7 && (signed int)a2 >= 0;
        i = (struct INetCfgComponentVtbl *)i->QueryInterface )
    ReleaseObj((struct IUnknown *)i->Release);
  EndWaitCursor(hInstance);
  ReleaseObj(v10);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v9);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v11);
}

//----- (6E68FA13) --------------------------------------------------------
void __thiscall CBindingsDlg::GetWanOrdering(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  struct IUnknown *v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v1 = this;
  if ( (***((int (__stdcall ****)(_DWORD, _DWORD, _DWORD))this + 2))(
         *((_DWORD *)this + 2),
         &IID_INetCfgSpecialCase,
         &v2) >= 0 )
  {
    ((void (__stdcall *)(_DWORD, _DWORD))v2->lpVtbl[1].Release)(v2, (char *)v1 + 40);
    ReleaseObj(v2);
  }
}

//----- (6E68FA52) --------------------------------------------------------
void __thiscall CBindingsDlg::SetWanOrdering(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  struct IUnknown *v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  v1 = this;
  if ( (***((int (__stdcall ****)(_DWORD, _DWORD, _DWORD))this + 2))(
         *((_DWORD *)this + 2),
         &IID_INetCfgSpecialCase,
         &v2) >= 0 )
  {
    ((void (__stdcall *)(_DWORD, _DWORD))v2->lpVtbl[2].QueryInterface)(v2, *((_DWORD *)v1 + 10));
    ReleaseObj(v2);
  }
}

//----- (6E68FA90) --------------------------------------------------------
void __thiscall CBindingsDlg::AddListViewItem(CBindingsDlg *this, struct IUnknown *a2, int a3, int a4, const unsigned __int16 *a5)
{
  CBindingsDlg *v5; // esi@1
  HWND v6; // ST00_4@1
  LPARAM lParam; // [sp+8h] [bp-3Ch]@1
  int Dst; // [sp+Ch] [bp-38h]@1
  const unsigned __int16 *v9; // [sp+1Ch] [bp-28h]@1
  int v10; // [sp+24h] [bp-20h]@1
  struct IUnknown *v11; // [sp+28h] [bp-1Ch]@1

  v5 = this;
  memset(&Dst, 0, 0x38u);
  v10 = a4;
  lParam = 15;
  Dst = a3;
  AddRefObj(a2);
  v9 = a5;
  v6 = (HWND)*((_DWORD *)v5 + 3);
  v11 = a2;
  SendMessageW(v6, 0x104Du, 0, (LPARAM)&lParam);
}

//----- (6E68FAF0) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnListDeleteItem(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CBindingsDlg *v4; // esi@1
  HWND v5; // ST00_4@1
  LPARAM lParam; // [sp+4h] [bp-3Ch]@1
  HWND Dst; // [sp+8h] [bp-38h]@1
  struct IUnknown *v9; // [sp+24h] [bp-1Ch]@1

  v4 = this;
  memset(&Dst, 0, 0x38u);
  Dst = a3[1].hwndFrom;
  v5 = (HWND)*((_DWORD *)v4 + 3);
  lParam = 4;
  SendMessageW(v5, 0x104Bu, 0, (LPARAM)&lParam);
  ReleaseObj(v9);
  return 0;
}

//----- (6E68FB43) --------------------------------------------------------
int __thiscall CBindingsDlg::FIsWanBinding(CBindingsDlg *this, int a2)
{
  CBindingsDlg *v2; // esi@1
  HWND v3; // ST00_4@2
  int result; // eax@2
  LPARAM lParam; // [sp+8h] [bp-3Ch]@2
  int Dst; // [sp+Ch] [bp-38h]@2
  int v7; // [sp+28h] [bp-1Ch]@2

  v2 = this;
  if ( a2 == -1 )
  {
    result = 0;
  }
  else
  {
    memset(&Dst, 0, 0x38u);
    v3 = (HWND)*((_DWORD *)v2 + 3);
    lParam = 4;
    Dst = a2;
    SendMessageW(v3, 0x104Bu, 0, (LPARAM)&lParam);
    result = v7 == 0;
  }
  return result;
}

//----- (6E68FB9C) --------------------------------------------------------
void __thiscall CBindingsDlg::SetAdapterButtons(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  HWND v2; // eax@6
  HWND v3; // eax@6
  LRESULT wParam; // [sp+Ch] [bp-Ch]@1
  LRESULT v5; // [sp+10h] [bp-8h]@1
  LRESULT v6; // [sp+14h] [bp-4h]@1

  v6 = -1;
  v5 = -1;
  v1 = this;
  wParam = SendMessageW(*((HWND *)this + 3), 0x100Cu, 0xFFFFFFFF, 2);
  if ( SendMessageW(*((HWND *)v1 + 3), 0x1004u, 0, 0) > 1 )
  {
    v6 = SendMessageW(*((HWND *)v1 + 3), 0x100Cu, wParam, 256);
    v5 = SendMessageW(*((HWND *)v1 + 3), 0x100Cu, wParam, 512);
    if ( CBindingsDlg::FIsWanBinding(v1, v6) )
    {
      v6 = -1;
    }
    else if ( CBindingsDlg::FIsWanBinding(v1, v5) )
    {
      v5 = -1;
    }
  }
  v2 = GetDlgItem(*((HWND *)v1 + 1), 25001);
  EnableWindow(v2, v6 != -1);
  v3 = GetDlgItem(*((HWND *)v1 + 1), 25002);
  EnableWindow(v3, v5 != -1);
}

//----- (6E68FC68) --------------------------------------------------------
void __stdcall ChangeListItemParam(HWND hWnd, int a2, __int32 a3)
{
  LPARAM lParam; // [sp+0h] [bp-3Ch]@1
  int Dst; // [sp+4h] [bp-38h]@1
  __int32 v5; // [sp+20h] [bp-1Ch]@1

  memset(&Dst, 0, 0x38u);
  Dst = a2;
  v5 = a3;
  lParam = 4;
  SendMessageW(hWnd, 0x104Cu, 0, (LPARAM)&lParam);
}

//----- (6E68FCB0) --------------------------------------------------------
void *__stdcall std::_Allocate<std::_List_nod<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Node>(int a1, int a2)
{
  int v2; // eax@1

  v2 = a1;
  if ( a1 < 0 )
    v2 = 0;
  return operator new(12 * v2);
}

//----- (6E68FCD7) --------------------------------------------------------
int __thiscall CIterNetCon::HrNext(CIterNetCon *this, struct INetConnection **a2)
{
  int v2; // edi@1

  v2 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)this, (int)a2);
  if ( v2 >= 0 && *a2 )
    NcSetProxyBlanket((IUnknown *)*a2);
  return v2;
}

//----- (6E68FD06) --------------------------------------------------------
int __thiscall CIterNetCfgComponent::CIterNetCfgComponent(int this, struct IUnknown *a2, int a3)
{
  struct IUnknown *v3; // eax@1
  int v4; // esi@1
  int v5; // ST04_4@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // eax@2

  v3 = a2;
  v4 = this;
  v5 = a3;
  v6 = this + 20;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  v7 = ((int (__stdcall *)(struct IUnknown *, int, GUID *, struct IUnknown **))v3->lpVtbl[3].QueryInterface)(
         v3,
         v5,
         &IID_INetCfgClass,
         &a2);
  *(_DWORD *)(v4 + 16) = v7;
  if ( v7 >= 0 )
  {
    v8 = ((int (__stdcall *)(struct IUnknown *, int))a2->lpVtbl[1].AddRef)(a2, v6);
    *(_DWORD *)(v4 + 16) = v8;
    if ( v8 >= 0 )
      *(_DWORD *)v4 = *(_DWORD *)v6;
    ReleaseObj(a2);
  }
  return v4;
}

//----- (6E68FD6C) --------------------------------------------------------
CIterNetCon *__thiscall CIterNetCon::CIterNetCon(CIterNetCon *this, struct INetConnectionManager *a2, enum tagNETCONMGR_ENUM_FLAGS a3)
{
  CIterNetCon *v3; // esi@1
  IUnknown **v4; // edi@1
  HRESULT v5; // eax@1

  v3 = this;
  v4 = (IUnknown **)((char *)this + 20);
  *(_DWORD *)this = 0;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = 0;
  v5 = a2->lpVtbl->EnumConnections(a2, a3, (IEnumNetConnection **)((char *)this + 20));
  *((_DWORD *)v3 + 4) = v5;
  if ( v5 >= 0 )
  {
    NcSetProxyBlanket(*v4);
    *(_DWORD *)v3 = *v4;
  }
  return v3;
}

//----- (6E68FDB8) --------------------------------------------------------
void __thiscall CBindingsDlg::OnAdapterChange(CBindingsDlg *this, int a2)
{
  CBindingsDlg *v2; // esi@1
  HWND v3; // ST00_4@1
  struct INetCfgComponent *v4; // edi@1
  char *v5; // ST0C_4@3
  const unsigned __int16 *v6; // eax@3
  struct INetConnection *v7; // edi@8
  HWND (__stdcall *v8)(HWND, int); // ebx@15
  HWND v9; // eax@15
  HWND v10; // eax@15
  HWND v11; // eax@16
  HWND v12; // eax@16
  HWND v13; // eax@17
  BOOL v14; // [sp-8h] [bp-29Ch]@15
  LPARAM lParam; // [sp+Ch] [bp-288h]@1
  int Dst; // [sp+10h] [bp-284h]@1
  char *v17; // [sp+20h] [bp-274h]@1
  int v18; // [sp+24h] [bp-270h]@1
  struct INetCfgComponent *v19; // [sp+2Ch] [bp-268h]@1
  char v20; // [sp+48h] [bp-24Ch]@6
  struct IUnknown *v21; // [sp+5Ch] [bp-238h]@14
  struct INetConnection *v22; // [sp+60h] [bp-234h]@7
  LPVOID ppv; // [sp+64h] [bp-230h]@5
  struct tagNETCON_PROPERTIES *pv; // [sp+68h] [bp-22Ch]@9
  int v25; // [sp+6Ch] [bp-228h]@3
  LPCWSTR lpString; // [sp+70h] [bp-224h]@3
  struct _GUID v27; // [sp+74h] [bp-220h]@4
  char v28; // [sp+84h] [bp-210h]@1
  int v29; // [sp+290h] [bp-4h]@6

  v2 = this;
  memset(&Dst, 0, 0x38u);
  v17 = &v28;
  Dst = a2;
  v3 = (HWND)*((_DWORD *)v2 + 3);
  lParam = 5;
  v18 = 256;
  SendMessageW(v3, 0x104Bu, 0, (LPARAM)&lParam);
  SendMessageW(*((HWND *)v2 + 4), 0x1101u, 0, -65536);
  v4 = v19;
  if ( v19 )
  {
    CBindingsDlg::BuildBindingsList(v2, v19);
    CBindingsDlg::SetCheckboxStates(v2);
  }
  CBindingsDlg::SetAdapterButtons(v2);
  v5 = v17;
  v6 = SzLoadIds(0x620Du);
  DwFormatStringWithLocalAlloc(v6, (LPWSTR)&lpString, v5);
  v25 = 1;
  if ( !v4 )
    goto LABEL_20;
  if ( v4->lpVtbl->GetInstanceGuid(v4, &v27) < 0
    || HrCreateInstanceBase(&CLSID_LanConnectionManager, 0x415u, &_GUID_c08956a2_1cd3_11d1_b1c5_00805fc1270e, &ppv) < 0 )
    goto LABEL_21;
  CIterNetCon::CIterNetCon((CIterNetCon *)&v20, (struct INetConnectionManager *)ppv, 0);
  v29 = 0;
  while ( !CIterNetCon::HrNext((CIterNetCon *)&v20, &v22) )
  {
    v7 = v22;
    if ( FPconnEqualGuid(v22, &v27) )
    {
      if ( v7->lpVtbl->GetProperties(v7, &pv) < 0 )
        break;
      if ( pv->MediaType == 3 )
      {
        if ( pv->dwCharacter & 0x200 )
          v25 = 0;
      }
      FreeNetconProperties(pv);
    }
  }
  ReleaseObj(v21);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v20);
  if ( v25 )
  {
LABEL_21:
    v8 = GetDlgItem;
    v9 = GetDlgItem(*((HWND *)v2 + 1), 25114);
    ShowWindow(v9, 5);
    v10 = GetDlgItem(*((HWND *)v2 + 1), 25114);
    EnableWindow(v10, 1);
    v14 = 1;
  }
  else
  {
LABEL_20:
    v8 = GetDlgItem;
    v11 = GetDlgItem(*((HWND *)v2 + 1), 25114);
    ShowWindow(v11, 0);
    v12 = GetDlgItem(*((HWND *)v2 + 1), 25114);
    EnableWindow(v12, 0);
    v14 = 0;
  }
  v13 = v8(*((HWND *)v2 + 1), 25003);
  EnableWindow(v13, v14);
  SetDlgItemTextW(*((HWND *)v2 + 1), 25114, lpString);
  LocalFree((HLOCAL)lpString);
}

//----- (6E68FFDD) --------------------------------------------------------
void *std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode()
{
  void *result; // eax@1

  result = std::_Allocate<std::_List_nod<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Node>(1, 0);
  if ( result )
    *(_DWORD *)result = result;
  if ( result != (void *)-4 )
    *((_DWORD *)result + 1) = result;
  return result;
}

//----- (6E68FFFB) --------------------------------------------------------
void *__stdcall std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Buynode(int a1, int a2, int a3)
{
  void *v3; // esi@1

  v3 = std::_Allocate<std::_List_nod<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Node>(1, 0);
  if ( v3 )
    *(_DWORD *)v3 = a1;
  if ( v3 != (void *)-4 )
    *((_DWORD *)v3 + 1) = a2;
  std::_Construct<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>(
    (int)((char *)v3 + 8),
    a3);
  return v3;
}

//----- (6E690039) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnListItemChanged(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CBindingsDlg *v4; // edi@1

  v4 = this;
  if ( a3[1].code & 2 && !((unsigned int)a3[2].hwndFrom & 2) && a3[1].hwndFrom != (HWND)*((_DWORD *)this + 9) )
  {
    CBindingsDlg::OnAdapterChange(this, (int)a3[1].hwndFrom);
    *((_DWORD *)v4 + 9) = a3[1].hwndFrom;
  }
  return 0;
}

//----- (6E690072) --------------------------------------------------------
int __thiscall std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(int this, int a2, void *lpMem, int a4)
{
  void *v4; // eax@1
  int v5; // esi@1
  int v6; // ecx@1
  int result; // eax@6
  int v8; // [sp+4h] [bp-4h]@4

  v4 = lpMem;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  if ( lpMem != *(void **)v6 || a4 != v6 )
  {
    while ( v4 != (void *)a4 )
      v4 = *(void **)std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::erase(v5, (int)&v8, v4);
  }
  else
  {
    std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::clear(v5);
  }
  result = a2;
  *(_DWORD *)a2 = a4;
  return result;
}

//----- (6E6900BB) --------------------------------------------------------
void __thiscall std::list<INetCfgComponent *,std::nc_allocator<INetCfgComponent *>>::unique(int this)
{
  int v1; // edi@1
  int **v2; // ecx@2
  int *v3; // esi@2
  int v4; // eax@2
  int v5; // [sp+4h] [bp-4h]@4

  v1 = this;
  if ( *(_DWORD *)(this + 8) >= 2u )
  {
    v2 = *(int ***)(this + 4);
    v3 = *v2;
    v4 = **v2;
    if ( (int **)v4 != v2 )
    {
      do
      {
        if ( v3[2] == *(_DWORD *)(v4 + 8) )
          v4 = std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::erase(v1, (int)&v5, (void *)v4);
        else
          v3 = (int *)v4;
        v4 = *(_DWORD *)v4;
      }
      while ( v4 != *(_DWORD *)(v1 + 4) );
    }
  }
}

//----- (6E6900FE) --------------------------------------------------------
unsigned int __thiscall std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::_Incsize(int this, unsigned int a2)
{
  int v2; // eax@1
  unsigned int result; // eax@4
  char v4; // [sp+Ch] [bp-50h]@3
  char v5; // [sp+34h] [bp-28h]@2
  int v6; // [sp+58h] [bp-4h]@2

  v2 = *(_DWORD *)(this + 8);
  if ( 0x3FFFFFFF - v2 < a2 )
  {
    std::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>::basic_string<char,std::char_traits<char>,std::nc_allocator<char>,_STL70>("list<T> too long");
    v6 = 0;
    std::length_error::length_error(&v5);
    _CxxThrowException(&v4, &_TI3_AVlength_error_std__);
  }
  result = a2 + v2;
  *(_DWORD *)(this + 8) = result;
  return result;
}
// 6E664155: using guessed type _DWORD __stdcall std::length_error::length_error(_DWORD);
// 6E676309: using guessed type _DWORD __stdcall _CxxThrowException(_DWORD, _DWORD);
// 6E695648: using guessed type int _TI3_AVlength_error_std__;

//----- (6E69016A) --------------------------------------------------------
int __thiscall std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(void *this, int a2, int a3)
{
  int v3; // ebx@1
  void *v4; // esi@1
  int result; // eax@1

  v3 = (int)this;
  v4 = std::list<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *,std::nc_allocator<std::basic_string<unsigned short,std::char_traits<unsigned short>,std::nc_allocator<unsigned short>,_STL70> *>>::_Buynode(
         a2,
         *(_DWORD *)(a2 + 4),
         a3);
  std::list<BIND_PATH_INFO *,std::nc_allocator<BIND_PATH_INFO *>>::_Incsize(v3, 1u);
  *(_DWORD *)(a2 + 4) = v4;
  result = *((_DWORD *)v4 + 1);
  *(_DWORD *)result = v4;
  return result;
}

//----- (6E6901A3) --------------------------------------------------------
int __stdcall CBindingsDlg::HrGetAdapters(struct IUnknown *a1, struct IUnknown *a2)
{
  void *v2; // eax@1
  int v3; // ebx@1
  int v4; // esi@2
  bool v5; // sf@2
  char v7; // [sp+Ch] [bp-30h]@1
  struct IUnknown *v8; // [sp+20h] [bp-1Ch]@12
  char v9; // [sp+24h] [bp-18h]@12
  void *v10; // [sp+28h] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-10h]@1
  int v12; // [sp+38h] [bp-4h]@1

  CIterNetCfgBindingPath::CIterNetCfgBindingPath((CIterNetCfgBindingPath *)&v7, (struct INetCfgComponent *)a1);
  v12 = 0;
  v2 = std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v11 = 0;
  v10 = v2;
  v3 = (int)a2;
  LOBYTE(v12) = 1;
  do
  {
    v4 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v7, (int)&a2);
    v5 = v4 < 0;
    if ( v4 )
      break;
    v4 = HrGetLastComponentAndInterface((struct INetCfgBindingPath *)a2, (struct INetCfgComponent **)&a1, 0);
    if ( v4 >= 0 )
    {
      v4 = HrIsConnection((struct INetCfgComponent *)a1);
      if ( v4 )
        ReleaseObj(a1);
      else
        std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(
          (void *)v3,
          *(_DWORD *)(v3 + 4),
          (int)&a1);
    }
    ReleaseObj(a2);
    v5 = v4 < 0;
  }
  while ( v4 >= 0 );
  if ( !v5 )
  {
    if ( *(_DWORD *)(v3 + 8) )
    {
      std::list<INetCfgComponent *,std::nc_allocator<INetCfgComponent *>>::unique(v3);
      v4 = 0;
    }
    else
    {
      v4 = 1;
    }
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v9);
  ReleaseObj(v8);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v7);
  return v4;
}

//----- (6E690269) --------------------------------------------------------
int __thiscall CBindingsDlg::HrBuildAdapterList(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  int v2; // eax@3
  bool v3; // sf@11
  unsigned __int8 v4; // of@11
  void *i; // edi@13
  struct IUnknown *v6; // ebx@14
  struct IUnknown v7; // eax@14
  int v8; // ST08_4@14
  const unsigned __int16 *v9; // eax@28
  LPARAM lParam; // [sp+Ch] [bp-B8h]@31
  int v12; // [sp+18h] [bp-ACh]@31
  int v13; // [sp+1Ch] [bp-A8h]@31
  char v14; // [sp+48h] [bp-7Ch]@14
  struct IUnknown *v15; // [sp+5Ch] [bp-68h]@22
  struct _SP_CLASSIMAGELIST_DATA ClassImageListData; // [sp+60h] [bp-64h]@1
  int ImageIndex; // [sp+6Ch] [bp-58h]@2
  struct IUnknown *v18; // [sp+70h] [bp-54h]@12
  int v19; // [sp+74h] [bp-50h]@14
  struct IUnknown v20; // [sp+78h] [bp-4Ch]@6
  int v21; // [sp+7Ch] [bp-48h]@1
  int v22; // [sp+80h] [bp-44h]@1
  struct IUnknown *v23; // [sp+84h] [bp-40h]@16
  __int32 v24; // [sp+88h] [bp-3Ch]@12
  struct tagNETCON_PROPERTIES *pv; // [sp+8Ch] [bp-38h]@18
  int v26; // [sp+90h] [bp-34h]@1
  struct IUnknown *v27; // [sp+94h] [bp-30h]@1
  int v28; // [sp+98h] [bp-2Ch]@1
  char v29; // [sp+9Ch] [bp-28h]@4
  struct _GUID v30; // [sp+A4h] [bp-20h]@8
  int v31; // [sp+C0h] [bp-4h]@1

  v1 = this;
  v27 = 0;
  v26 = 0;
  v21 = (int)std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
  v22 = 0;
  v31 = 0;
  v28 = HrSetupDiGetClassImageList(&ClassImageListData);
  if ( v28 >= 0 )
  {
    v28 = HrSetupDiGetClassImageIndex(&ClassImageListData, &GUID_DEVCLASS_MODEM, &ImageIndex);
    if ( v28 >= 0 )
    {
      v2 = (*(int (__stdcall **)(_DWORD, _DWORD, struct IUnknown **))(**((_DWORD **)v1 + 2) + 32))(
             *((_DWORD *)v1 + 2),
             L"ms_tcpip",
             &v27);
      v28 = v2;
      if ( v2 == 1 )
      {
        CIterNetCfgComponent::CIterNetCfgComponent(
          (int)&v29,
          *((struct IUnknown **)v1 + 2),
          (int)&GUID_DEVCLASS_NETTRANS);
        LOBYTE(v31) = 1;
        do
        {
          v28 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v29, (int)&v27);
          if ( v28 )
            break;
          v28 = CBindingsDlg::HrGetAdapters(v27, &v20);
          ReleaseObj(v27);
          if ( !v28 )
            break;
        }
        while ( v28 >= 0 );
        LOBYTE(v31) = 0;
        ReleaseObj(*(struct IUnknown **)&v30.Data4[4]);
        CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v29);
      }
      else
      {
        if ( v2 )
          goto LABEL_26;
        v28 = CBindingsDlg::HrGetAdapters(v27, &v20);
        ReleaseObj(v27);
      }
    }
  }
  v4 = 0;
  v3 = v28 < 0;
  if ( v28 )
    goto LABEL_27;
  v24 = HrCreateInstanceBase(
          &CLSID_LanConnectionManager,
          0x415u,
          &_GUID_c08956a2_1cd3_11d1_b1c5_00805fc1270e,
          (LPVOID *)&v18);
  if ( v24 >= 0 )
  {
    for ( i = *(void **)v21; i != (void *)v21; i = *(void **)i )
    {
      CIterNetCon::CIterNetCon((CIterNetCon *)&v14, (struct INetConnectionManager *)v18, 0);
      v19 = 0;
      v6 = (struct IUnknown *)*((_DWORD *)i + 2);
      v7.lpVtbl = v6->lpVtbl;
      v8 = *((_DWORD *)i + 2);
      LOBYTE(v31) = 2;
      ((void (__stdcall *)(int, struct _GUID *))v7.lpVtbl[2].Release)(v8, &v30);
      while ( v24 >= 0 && !v19 && !CIterNetCon::HrNext((CIterNetCon *)&v14, (struct INetConnection **)&v23) )
      {
        if ( FPconnEqualGuid((struct INetConnection *)v23, &v30) )
        {
          v24 = ((int (__stdcall *)(struct IUnknown *, struct tagNETCON_PROPERTIES **))v23->lpVtbl[2].AddRef)(v23, &pv);
          if ( v24 >= 0 )
          {
            CBindingsDlg::AddListViewItem(v1, v6, v26++, *((_DWORD *)v1 + 11), pv->pszwName);
            v19 = 1;
            FreeNetconProperties(pv);
          }
        }
        ReleaseObj(v23);
      }
      ReleaseObj(v6);
      LOBYTE(v31) = 0;
      ReleaseObj(v15);
      CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v14);
    }
    ReleaseObj(v18);
  }
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(
    (int)&v20,
    (int)&pv,
    *(void **)v21,
    v21);
LABEL_26:
  v4 = 0;
  v3 = v28 < 0;
LABEL_27:
  if ( !(v3 ^ v4) )
  {
    CBindingsDlg::GetWanOrdering(v1);
    v9 = SzLoadIds(0x6215u);
    CBindingsDlg::AddListViewItem(v1, 0, *((_DWORD *)v1 + 10) == 0 ? v26 : 0, ImageIndex, v9);
  }
  HrSetupDiDestroyClassImageList(&ClassImageListData);
  if ( v28 >= 0 )
  {
    CBindingsDlg::SetAdapterButtons(v1);
    SendMessageW(*((HWND *)v1 + 3), 0x101Eu, 0, 0xFFFF);
    v28 = 0;
  }
  v13 = 3;
  v12 = 3;
  SendMessageW(*((HWND *)v1 + 3), 0x102Bu, 0, (LPARAM)&lParam);
  std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v20);
  return v28;
}
// 6E65C494: using guessed type wchar_t aMs_tcpip[9];

//----- (6E690509) --------------------------------------------------------
void __thiscall CBindingsDlg::MoveAdapterBindings(void *this, struct IUnknown *a2, struct IUnknown *a3, int a4)
{
  struct IUnknown *v4; // ebx@1
  int v5; // edi@1
  bool v6; // sf@5
  struct IUnknown *v7; // esi@6
  void *i; // esi@19
  struct IUnknownVtbl *v9; // ecx@21
  const IID *v10; // [sp-Ch] [bp-80h]@21
  char v11; // [sp+Ch] [bp-68h]@2
  struct IUnknown *v12; // [sp+20h] [bp-54h]@31
  char v13; // [sp+24h] [bp-50h]@4
  struct IUnknown *v14; // [sp+38h] [bp-3Ch]@29
  char v15; // [sp+3Ch] [bp-38h]@14
  int v16; // [sp+40h] [bp-34h]@4
  int v17; // [sp+44h] [bp-30h]@4
  int v18; // [sp+48h] [bp-2Ch]@28
  void *v19; // [sp+4Ch] [bp-28h]@1
  struct IUnknown *v20; // [sp+50h] [bp-24h]@6
  struct IUnknown *v21; // [sp+54h] [bp-20h]@5
  int v22; // [sp+58h] [bp-1Ch]@4
  struct IUnknown *v23; // [sp+5Ch] [bp-18h]@3
  struct IUnknown *v24; // [sp+60h] [bp-14h]@18
  unsigned int v25; // [sp+64h] [bp-10h]@1
  int v26; // [sp+70h] [bp-4h]@2

  v19 = this;
  v4 = 0;
  v5 = 0;
  v25 = 0;
  do
  {
    CIterNetCfgComponent::CIterNetCfgComponent((int)&v11, *((struct IUnknown **)v19 + 2), (int)off_6E69BCC0[v25 / 4]);
    v26 = 0;
    while ( v5 >= 0 )
    {
      v5 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v11, (int)&v23);
      if ( v5 )
        break;
      CIterNetCfgBindingPath::CIterNetCfgBindingPath((CIterNetCfgBindingPath *)&v13, (struct INetCfgComponent *)v23);
      LOBYTE(v26) = 1;
      v22 = 1;
      v16 = (int)std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Buynode();
      v17 = 0;
      LOBYTE(v26) = 2;
      do
      {
        v5 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v13, (int)&v21);
        v6 = v5 < 0;
        if ( v5 )
          break;
        v7 = v21;
        v5 = HrGetLastComponentAndInterface((struct INetCfgBindingPath *)v21, (struct INetCfgComponent **)&v20, 0);
        if ( v5 >= 0 )
        {
          if ( v20 == a3 )
          {
            if ( a4 == 1 )
            {
              if ( v22 )
              {
                v4 = v7;
                AddRefObj(v7);
                v22 = 0;
              }
            }
            else if ( a4 == 2 )
            {
              ReleaseObj(v4);
              v4 = v7;
              AddRefObj(v7);
            }
          }
          else if ( v20 == a2 )
          {
            AddRefObj(v7);
            std::list<CSortableBindPath,std::nc_allocator<CSortableBindPath>>::_Insert(&v15, v16, (int)&v21);
          }
          ReleaseObj(v20);
        }
        ReleaseObj(v7);
        v6 = v5 < 0;
      }
      while ( v5 >= 0 );
      if ( !v6 )
      {
        v5 = v23->lpVtbl->QueryInterface(v23, &IID_INetCfgComponentBindings, (void **)&v24);
        if ( v5 >= 0 )
        {
          for ( i = *(void **)v16; i != (void *)v16 && v5 >= 0; i = *(void **)i )
          {
            v9 = v24->lpVtbl;
            v10 = (const IID *)*((_DWORD *)i + 2);
            if ( a4 == 1 )
            {
              v5 = v9[3].QueryInterface(v24, v10, (void **)v4);
            }
            else
            {
              v5 = ((int (__stdcall *)(struct IUnknown *, const IID *, struct IUnknown *))v9[3].AddRef)(v24, v10, v4);
              if ( a4 == 2 )
              {
                ReleaseObj(v4);
                v4 = (struct IUnknown *)*((_DWORD *)i + 2);
                AddRefObj(*((struct IUnknown **)i + 2));
              }
            }
            ReleaseObj(*((struct IUnknown **)i + 2));
          }
          ReleaseObj(v24);
        }
        std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::erase(
          (int)&v15,
          (int)&v18,
          *(void **)v16,
          v16);
      }
      ReleaseObj(v4);
      ReleaseObj(v23);
      std::list<INetCfgBindingPath *,std::nc_allocator<INetCfgBindingPath *>>::_Tidy((int)&v15);
      ReleaseObj(v14);
      CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v13);
      v4 = 0;
    }
    v26 = -1;
    ReleaseObj(v12);
    CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v11);
    v25 += 4;
  }
  while ( v25 < 0xC );
}
// 6E69BCC0: using guessed type GUID *off_6E69BCC0[3];

//----- (6E6906E8) --------------------------------------------------------
void __thiscall CBindingsDlg::OnAdapterUpDown(CBindingsDlg *this, int a2)
{
  CBindingsDlg *v2; // esi@1
  HWND v3; // ST00_4@1
  LRESULT v4; // eax@2
  HWND v5; // ST00_4@10
  LRESULT v6; // eax@10
  LPARAM v7; // [sp+Ch] [bp-288h]@11
  int v8; // [sp+18h] [bp-27Ch]@11
  int v9; // [sp+1Ch] [bp-278h]@11
  LPARAM lParam; // [sp+48h] [bp-24Ch]@1
  WPARAM Dst; // [sp+4Ch] [bp-248h]@1
  int v12; // [sp+54h] [bp-240h]@10
  int v13; // [sp+58h] [bp-23Ch]@10
  char *v14; // [sp+5Ch] [bp-238h]@1
  int v15; // [sp+60h] [bp-234h]@1
  struct IUnknown *v16; // [sp+68h] [bp-22Ch]@1
  struct IUnknown *v17; // [sp+84h] [bp-210h]@1
  WPARAM wParam; // [sp+88h] [bp-20Ch]@1
  WPARAM v19; // [sp+8Ch] [bp-208h]@4
  char v20; // [sp+90h] [bp-204h]@1

  v2 = this;
  lParam = 0;
  memset(&Dst, 0, 0x38u);
  wParam = SendMessageW(*((HWND *)v2 + 3), 0x100Cu, 0xFFFFFFFF, 2);
  Dst = wParam;
  v3 = (HWND)*((_DWORD *)v2 + 3);
  lParam = 15;
  v14 = &v20;
  v15 = 256;
  SendMessageW(v3, 0x104Bu, 0, (LPARAM)&lParam);
  v17 = v16;
  if ( v16 )
  {
    v4 = SendMessageW(*((HWND *)v2 + 3), 0x100Cu, wParam, a2 != 0 ? 256 : 512);
  }
  else
  {
    *((_DWORD *)v2 + 10) = a2;
    if ( a2 )
    {
      v19 = 0;
      goto LABEL_7;
    }
    v4 = SendMessageW(*((HWND *)v2 + 3), 0x1004u, 0, 0) - 1;
  }
  v19 = v4;
LABEL_7:
  Dst = v19;
  SendMessageW(*((HWND *)v2 + 3), 0x104Bu, 0, (LPARAM)&lParam);
  if ( v17 )
    CBindingsDlg::MoveAdapterBindings((void *)v2, v17, v16, (a2 == 0) + 1);
  else
    CBindingsDlg::SetWanOrdering(v2);
  Dst = wParam;
  SendMessageW(*((HWND *)v2 + 3), 0x104Bu, 0, (LPARAM)&lParam);
  ChangeListItemParam(*((HWND *)v2 + 3), wParam, 0);
  SendMessageW(*((HWND *)v2 + 3), 0x1008u, wParam, 0);
  Dst = v19;
  v5 = (HWND)*((_DWORD *)v2 + 3);
  v13 = 0;
  v12 = 0;
  v6 = SendMessageW(v5, 0x104Du, 0, (LPARAM)&lParam);
  if ( v6 != -1 )
  {
    v9 = 3;
    v8 = 3;
    SendMessageW(*((HWND *)v2 + 3), 0x102Bu, v6, (LPARAM)&v7);
  }
  *((_DWORD *)v2 + 9) = v19;
  CBindingsDlg::SetAdapterButtons(v2);
  SetFocus(*((HWND *)v2 + 3));
}

//----- (6E6908CB) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnAdapterUp(CBindingsDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CBindingsDlg::OnAdapterUpDown(this, 1);
  return 0;
}

//----- (6E6908DC) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnAdapterDown(CBindingsDlg *this, unsigned __int16 a2, unsigned __int16 a3, HWND a4, int *a5)
{
  CBindingsDlg::OnAdapterUpDown(this, 0);
  return 0;
}

//----- (6E6908ED) --------------------------------------------------------
LONG __thiscall CBindingsDlg::~CBindingsDlg(CBindingsDlg *this)
{
  CBindingsDlg *v1; // esi@1
  void *v2; // eax@1

  v1 = this;
  v2 = (void *)*((_DWORD *)this + 5);
  *(_DWORD *)this = &CBindingsDlg::`vftable';
  if ( v2 )
    DeleteObject(v2);
  if ( *((_DWORD *)v1 + 6) )
    DeleteObject(*((HGDIOBJ *)v1 + 6));
  if ( *((_DWORD *)v1 + 7) )
    ImageList_Destroy(*((HIMAGELIST *)v1 + 7));
  if ( *((_DWORD *)v1 + 8) )
    ImageList_Destroy(*((HIMAGELIST *)v1 + 8));
  ReleaseObj(*((struct IUnknown **)v1 + 2));
  return CPropSheetPage::~CPropSheetPage(v1);
}
// 6E6479B4: using guessed type int (__thiscall *CBindingsDlg::`vftable')(CBindingsDlg *this, HWND, unsigned __int32, CSrvrcfg *, HWND, CBindingsDlg *, unsigned __int32);

//----- (6E690943) --------------------------------------------------------
signed int __thiscall CBindingsDlg::OnInitDialog(CBindingsDlg *this, unsigned int a2, unsigned int a3, __int32 a4, int *a5)
{
  CBindingsDlg *v5; // esi@1
  HWND v6; // ST14_4@1
  HWND v7; // eax@1
  HWND v8; // ST14_4@1
  HWND v9; // eax@1
  HWND v10; // ST10_4@1
  HWND v11; // eax@1
  HICON v12; // eax@2
  int v13; // eax@2
  LPARAM v14; // ST18_4@2
  HWND v15; // ST0C_4@2
  int v16; // eax@3
  HWND v17; // ST0C_4@3
  LPARAM v18; // eax@8
  HWND v19; // ST0C_4@8
  LPARAM lParam; // [sp+Ch] [bp-4Ch]@1
  int v22; // [sp+10h] [bp-48h]@1
  LONG v23; // [sp+14h] [bp-44h]@3
  struct tagRECT Rect; // [sp+38h] [bp-20h]@3
  struct _SP_CLASSIMAGELIST_DATA ClassImageListData; // [sp+48h] [bp-10h]@1
  int v26; // [sp+54h] [bp-4h]@1

  v5 = this;
  v6 = (HWND)*((_DWORD *)this + 1);
  lParam = 0;
  memset(&v22, 0, 0x28u);
  v7 = GetDlgItem(v6, 25000);
  v8 = (HWND)*((_DWORD *)v5 + 1);
  *((_DWORD *)v5 + 3) = v7;
  v9 = GetDlgItem(v8, 25003);
  v10 = (HWND)*((_DWORD *)v5 + 1);
  *((_DWORD *)v5 + 4) = v9;
  v11 = GetDlgItem(v10, 25114);
  ShowWindow(v11, 0);
  v26 = HrSetupDiGetClassImageList(&ClassImageListData);
  if ( v26 >= 0 )
  {
    *((_DWORD *)v5 + 7) = ImageList_Duplicate(ClassImageListData.ImageList);
    v12 = LoadIconW(hInst, (LPCWSTR)0x7598);
    v13 = ImageList_ReplaceIcon(*((HIMAGELIST *)v5 + 7), -1, v12);
    v14 = *((_DWORD *)v5 + 7);
    v15 = (HWND)*((_DWORD *)v5 + 3);
    *((_DWORD *)v5 + 11) = v13;
    SendMessageW(v15, 0x1003u, 1u, v14);
    SendMessageW(*((HWND *)v5 + 4), 0x1109u, 0, *((_DWORD *)v5 + 7));
    HrSetupDiDestroyClassImageList(&ClassImageListData);
  }
  GetClientRect(*((HWND *)v5 + 3), &Rect);
  lParam = 3;
  v22 = 0;
  v16 = GetSystemMetrics(2);
  v17 = (HWND)*((_DWORD *)v5 + 3);
  v23 = Rect.right - v16;
  SendMessageW(v17, 0x1061u, 0, (LPARAM)&lParam);
  if ( !*((_DWORD *)v5 + 5) && !*((_DWORD *)v5 + 6) )
  {
    *((_DWORD *)v5 + 5) = LoadImageW(hInst, (LPCWSTR)0x765C, 1u, 16, 16, 0);
    *((_DWORD *)v5 + 6) = LoadImageW(hInst, (LPCWSTR)0x765D, 1u, 16, 16, 0);
  }
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25001, 0xF7u, 1u, *((_DWORD *)v5 + 5));
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25002, 0xF7u, 1u, *((_DWORD *)v5 + 6));
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25004, 0xF7u, 1u, *((_DWORD *)v5 + 5));
  SendDlgItemMessageW(*((HWND *)v5 + 1), 25005, 0xF7u, 1u, *((_DWORD *)v5 + 6));
  if ( v26 >= 0 )
    v26 = CBindingsDlg::HrBuildAdapterList(v5);
  v18 = (LPARAM)ImageList_LoadImageAndMirror(hInst, (LPCWSTR)0x765F, 16, 0, 0x1000006u, 0, 0);
  v19 = (HWND)*((_DWORD *)v5 + 4);
  *((_DWORD *)v5 + 8) = v18;
  SendMessageW(v19, 0x1109u, 2u, v18);
  if ( v26 < 0 )
    SetWindowLongW(*((HWND *)v5 + 1), 0, 1);
  return 1;
}

//----- (6E690B1B) --------------------------------------------------------
__int32 __thiscall CBindingsDlg::OnOk(CBindingsDlg *this, int a2, struct tagNMHDR *a3, int *a4)
{
  CBindingsDlg *v4; // esi@1
  __int32 v5; // edi@1
  __int32 v6; // esi@5
  int v8; // [sp-4h] [bp-20h]@0
  HICON hInstance; // [sp+Ch] [bp-10h]@1

  v4 = this;
  hInstance = BeginWaitCursor();
  v5 = (*(int (__stdcall **)(_DWORD, int))(**((_DWORD **)v4 + 2) + 20))(*((_DWORD *)v4 + 2), v8);
  if ( v5 == 303136 )
  {
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)v4 + 2) + 16))(*((_DWORD *)v4 + 2));
    HrNcQueryUserForReboot(hInst, *((HWND *)v4 + 1), 0x620Eu, 0x76C0u, (void *)3);
  }
  if ( v5 == 1 )
    v5 = 0;
  v6 = LresFromHr(v5);
  EndWaitCursor(hInstance);
  return v6;
}

//----- (6E690B91) --------------------------------------------------------
BOOL __thiscall CSortableBindPath::operator<(void *this, int a2)
{
  unsigned int v3; // [sp+0h] [bp-8h]@1
  unsigned int v4; // [sp+4h] [bp-4h]@1

  (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)this + 36))(*(_DWORD *)this, &v3);
  (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)a2 + 36))(*(_DWORD *)a2, &v4);
  return v4 < v3;
}

//----- (6E690BC6) --------------------------------------------------------
BOOL __stdcall FIsHidden(struct INetCfgComponent *a1)
{
  return a1->lpVtbl->GetCharacteristics(a1, (LPDWORD)&a1) >= 0
      && ((unsigned __int16)a1 & 0x2000 || (unsigned __int8)a1 & 8);
}

//----- (6E690BFB) --------------------------------------------------------
struct _IMAGELIST *__stdcall ImageList_LoadImageAndMirror(HINSTANCE hInst, LPCWSTR name, int a3, int cGrow, COLORREF crMask, UINT type, UINT fuLoad)
{
  struct _IMAGELIST *v7; // esi@1
  HBITMAP v8; // ebx@1
  signed int v9; // esi@3
  signed int v10; // ecx@5
  struct _IMAGELIST *v11; // eax@9
  int v12; // eax@11
  char pv; // [sp+8h] [bp-18h]@2
  int v15; // [sp+Ch] [bp-14h]@9
  int cy; // [sp+10h] [bp-10h]@4
  char v17; // [sp+1Ah] [bp-6h]@8
  int v18; // [sp+1Ch] [bp-4h]@7

  v7 = 0;
  v8 = (HBITMAP)LoadImageW(hInst, name, type, 0, 0, fuLoad);
  if ( v8 )
  {
    if ( GetObjectW(v8, 24, &pv) == 24 )
    {
      v9 = a3;
      if ( !a3 )
        v9 = cy;
      v10 = 0;
      if ( crMask != -1 )
        v10 = 1;
      if ( v18 )
        v10 |= (unsigned __int8)(v17 & 0xFE);
      v11 = ImageList_Create(v9, cy, v10 | 0x2000, v15 / v9, cGrow);
      v7 = v11;
      if ( v11 )
      {
        if ( crMask == -1 )
          v12 = ImageList_Add(v11, v8, 0);
        else
          v12 = ImageList_AddMasked(v11, v8, crMask);
        if ( v12 < 0 )
        {
          ImageList_Destroy(v7);
          v7 = 0;
        }
      }
    }
    DeleteObject(v8);
  }
  return v7;
}

//----- (6E690CB5) --------------------------------------------------------
int __fastcall load__SetupCloseInfFile_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupCloseInfFile, a2, a1);
}

//----- (6E690CBF) --------------------------------------------------------
int __fastcall load__SetupDiGetDeviceInstanceIdW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDeviceInstanceIdW, a2, a1);
}

//----- (6E690CC9) --------------------------------------------------------
int __fastcall load__SetupDiRestartDevices_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiRestartDevices, a2, a1);
}

//----- (6E690CD3) --------------------------------------------------------
int __fastcall load__SetupDiGetDeviceInstallParamsW_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDeviceInstallParamsW, a2, a1);
}

//----- (6E690CDD) --------------------------------------------------------
int __fastcall load__SetupDiDeleteDeviceInfo_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiDeleteDeviceInfo, a2, a1);
}

//----- (6E690CE7) --------------------------------------------------------
int __fastcall load__pSetupGetIndirectStringsFromDriverInfo_28(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&pSetupGetIndirectStringsFromDriverInfo, a2, a1);
}
// 6E6990BC: using guessed type void *pSetupGetIndirectStringsFromDriverInfo;

//----- (6E690CFC) --------------------------------------------------------
int __fastcall load__SetupCloseFileQueue_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupCloseFileQueue, a2, a1);
}

//----- (6E690D06) --------------------------------------------------------
int __fastcall load__SetupTermDefaultQueueCallback_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupTermDefaultQueueCallback, a2, a1);
}

//----- (6E690D10) --------------------------------------------------------
int __fastcall load__SetupDefaultQueueCallbackW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDefaultQueueCallbackW, a2, a1);
}

//----- (6E690D1A) --------------------------------------------------------
int __fastcall load__SetupOpenAppendInfFileW_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupOpenAppendInfFileW, a2, a1);
}

//----- (6E690D24) --------------------------------------------------------
int __fastcall load__SetupInstallServicesFromInfSectionW_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupInstallServicesFromInfSectionW, a2, a1);
}

//----- (6E690D2E) --------------------------------------------------------
int __fastcall load__SetupDiDestroyDriverInfoList_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiDestroyDriverInfoList, a2, a1);
}

//----- (6E690D38) --------------------------------------------------------
int __fastcall load__SetupCommitFileQueueW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupCommitFileQueueW, a2, a1);
}

//----- (6E690D42) --------------------------------------------------------
int __fastcall load__SetupInitDefaultQueueCallbackEx_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupInitDefaultQueueCallbackEx, a2, a1);
}

//----- (6E690D4C) --------------------------------------------------------
int __fastcall load__SetupOpenFileQueue_0(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupOpenFileQueue, a2, a1);
}

//----- (6E690D56) --------------------------------------------------------
int __fastcall load__SetupOpenInfFileW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupOpenInfFileW, a2, a1);
}

//----- (6E690D60) --------------------------------------------------------
int __fastcall load__SetupFindFirstLineW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupFindFirstLineW, a2, a1);
}

//----- (6E690D6A) --------------------------------------------------------
int __fastcall load__SetupFindNextLine_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupFindNextLine, a2, a1);
}

//----- (6E690D74) --------------------------------------------------------
int __fastcall load__SetupGetIntField_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupGetIntField, a2, a1);
}

//----- (6E690D7E) --------------------------------------------------------
int __fastcall load__SetupGetMultiSzFieldW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupGetMultiSzFieldW, a2, a1);
}

//----- (6E690D88) --------------------------------------------------------
int __fastcall load__SetupGetStringFieldW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupGetStringFieldW, a2, a1);
}

//----- (6E690D92) --------------------------------------------------------
int __fastcall load__SetupScanFileQueueW_24(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupScanFileQueueW, a2, a1);
}

//----- (6E690D9C) --------------------------------------------------------
int __fastcall load__SetupDiCallClassInstaller_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiCallClassInstaller, a2, a1);
}

//----- (6E690DA6) --------------------------------------------------------
int __fastcall load__SetupCopyOEMInfW_32(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupCopyOEMInfW, a2, a1);
}

//----- (6E690DB0) --------------------------------------------------------
int __fastcall load__SetupDiBuildDriverInfoList_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiBuildDriverInfoList, a2, a1);
}

//----- (6E690DBA) --------------------------------------------------------
int __fastcall load__SetupDiCreateDeviceInfoW_28(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiCreateDeviceInfoW, a2, a1);
}

//----- (6E690DC4) --------------------------------------------------------
int __fastcall load__SetupDiEnumDriverInfoW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiEnumDriverInfoW, a2, a1);
}

//----- (6E690DCE) --------------------------------------------------------
int __fastcall load__SetupDiSelectBestCompatDrv_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiSelectBestCompatDrv, a2, a1);
}

//----- (6E690DD8) --------------------------------------------------------
int __fastcall load__SetupDiGetDeviceInfoListClass_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDeviceInfoListClass, a2, a1);
}

//----- (6E690DE2) --------------------------------------------------------
int __fastcall load__SetupDiInstallDevice_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiInstallDevice, a2, a1);
}

//----- (6E690DEC) --------------------------------------------------------
int __fastcall load__SetupDiSetClassInstallParamsW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiSetClassInstallParamsW, a2, a1);
}

//----- (6E690DF6) --------------------------------------------------------
int __fastcall load__SetupDiGetClassInstallParamsW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetClassInstallParamsW, a2, a1);
}

//----- (6E690E00) --------------------------------------------------------
int __fastcall load__SetupDiGetSelectedDriverW_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetSelectedDriverW, a2, a1);
}

//----- (6E690E0A) --------------------------------------------------------
int __fastcall load__SetupDiGetDriverInfoDetailW_24(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDriverInfoDetailW, a2, a1);
}

//----- (6E690E14) --------------------------------------------------------
int __fastcall load__SetupDiCreateDevRegKeyW_28(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiCreateDevRegKeyW, a2, a1);
}

//----- (6E690E1E) --------------------------------------------------------
int __fastcall load__SetupDiGetActualSectionToInstallW_24(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetActualSectionToInstallW, a2, a1);
}

//----- (6E690E28) --------------------------------------------------------
int __fastcall load__SetupDiGetDriverInstallParamsW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetDriverInstallParamsW, a2, a1);
}

//----- (6E690E32) --------------------------------------------------------
int __fastcall load__SetupDiSetDeviceInstallParamsW_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiSetDeviceInstallParamsW, a2, a1);
}

//----- (6E690E3C) --------------------------------------------------------
int __fastcall load__SetupDiSetDriverInstallParamsW_16(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiSetDriverInstallParamsW, a2, a1);
}

//----- (6E690E46) --------------------------------------------------------
int __fastcall load__SetupDiRemoveDevice_8(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiRemoveDevice, a2, a1);
}

//----- (6E690E50) --------------------------------------------------------
int __fastcall load__SetupDiSetDeviceRegistryPropertyW_20(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiSetDeviceRegistryPropertyW, a2, a1);
}

//----- (6E690E5A) --------------------------------------------------------
int __fastcall load__SetupDiGetClassImageList_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetClassImageList, a2, a1);
}

//----- (6E690E64) --------------------------------------------------------
int __fastcall load__SetupDiDestroyClassImageList_4(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiDestroyClassImageList, a2, a1);
}

//----- (6E690E6E) --------------------------------------------------------
int __fastcall load__SetupDiGetClassImageIndex_12(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupDiGetClassImageIndex, a2, a1);
}

//----- (6E690E78) --------------------------------------------------------
int __fastcall load__SetupInstallFilesFromInfSectionW_24(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupInstallFilesFromInfSectionW, a2, a1);
}

//----- (6E690E82) --------------------------------------------------------
int __fastcall load__SetupInstallFromInfSectionW_44(int a1, int a2)
{
  return _tailMerge_SETUPAPI_dll((int)&SetupInstallFromInfSectionW, a2, a1);
}

//----- (6E690ECE) --------------------------------------------------------
int __fastcall load__DestroyPropertySheetPage_4(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&DestroyPropertySheetPage, a2, a1);
}

//----- (6E690ED5) --------------------------------------------------------
int __usercall _tailMerge_COMCTL32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_COMCTL32_dll, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E690EE6) --------------------------------------------------------
int __fastcall load__PropertySheetW_4(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&PropertySheetW, a2, a1);
}

//----- (6E690EED) --------------------------------------------------------
int __fastcall load__CreatePropertySheetPageW_4(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&CreatePropertySheetPageW, a2, a1);
}

//----- (6E690EF4) --------------------------------------------------------
int __fastcall load__ImageList_Duplicate_4(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_Duplicate, a2, a1);
}

//----- (6E690EFB) --------------------------------------------------------
int __fastcall load__ImageList_Destroy_4(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_Destroy, a2, a1);
}

//----- (6E690F02) --------------------------------------------------------
int __fastcall load__ImageList_ReplaceIcon_12(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_ReplaceIcon, a2, a1);
}

//----- (6E690F09) --------------------------------------------------------
int __fastcall load__ImageList_AddMasked_12(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_AddMasked, a2, a1);
}

//----- (6E690F10) --------------------------------------------------------
int __fastcall load__ImageList_Add_12(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_Add, a2, a1);
}

//----- (6E690F17) --------------------------------------------------------
int __fastcall load__ImageList_Create_20(int a1, int a2)
{
  return _tailMerge_COMCTL32_dll((int)&ImageList_Create, a2, a1);
}

//----- (6E690F1E) --------------------------------------------------------
int __fastcall load__RasEnumConnectionsW_12(int a1, int a2)
{
  return _tailMerge_RASAPI32_dll((int)&RasEnumConnectionsW, a2, a1);
}

//----- (6E690F25) --------------------------------------------------------
int __usercall _tailMerge_RASAPI32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_RASAPI32_dll, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E690F41) --------------------------------------------------------
int __fastcall load__AddPrintProvidorW_12(int a1, int a2)
{
  return _tailMerge_WINSPOOL_DRV((int)&AddPrintProvidorW, a2, a1);
}

//----- (6E690F48) --------------------------------------------------------
int __usercall _tailMerge_WINSPOOL_DRV@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_WINSPOOL_DRV, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E690F64) --------------------------------------------------------
int __fastcall load__DeletePrintProvidorW_12(int a1, int a2)
{
  return _tailMerge_WINSPOOL_DRV((int)&DeletePrintProvidorW, a2, a1);
}

//----- (6E690F76) --------------------------------------------------------
int __fastcall load__WSCUnInstallNameSpace_4(int a1, int a2)
{
  return _tailMerge_WS2_32_dll((int)&WSCUnInstallNameSpace, a2, a1);
}

//----- (6E690F7D) --------------------------------------------------------
int __usercall _tailMerge_WS2_32_dll@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // ST0C_4@1
  int v4; // ST08_4@1
  FARPROC v5; // eax@1

  v3 = a3;
  v4 = a2;
  v5 = __delayLoadHelper2(&_DELAY_IMPORT_DESCRIPTOR_WS2_32_dll, a1);
  return ((int (__fastcall *)(int, int))v5)(v3, v4);
}

//----- (6E690F99) --------------------------------------------------------
int __fastcall load__WSCInstallNameSpace_20(int a1, int a2)
{
  return _tailMerge_WS2_32_dll((int)&WSCInstallNameSpace, a2, a1);
}

//----- (6E690FDC) --------------------------------------------------------
int __cdecl _vsnprintf_s(char *DstBuf, size_t SizeInBytes, size_t MaxCount, const char *Format, va_list ArgList)
{
  int result; // eax@2

  if ( !Format )
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  if ( MaxCount )
  {
    if ( !DstBuf )
    {
LABEL_9:
      *_errno() = 22;
LABEL_15:
      _invalid_parameter(0, 0, 0, 0, 0);
      return -1;
    }
  }
  else if ( !DstBuf )
  {
    if ( !SizeInBytes )
      return 0;
    goto LABEL_9;
  }
  if ( SizeInBytes <= 0 )
    goto LABEL_9;
  if ( SizeInBytes > MaxCount )
  {
    result = _soutput_s(DstBuf, MaxCount + 1, (int)Format, (int)ArgList);
    if ( result == -2 )
      return -1;
    goto LABEL_12;
  }
  result = _soutput_s(DstBuf, SizeInBytes, (int)Format, (int)ArgList);
  if ( result != -2 )
  {
LABEL_12:
    if ( result >= 0 )
      return result;
    goto LABEL_13;
  }
  if ( MaxCount == -1 )
    return -1;
LABEL_13:
  *DstBuf = 0;
  if ( result == -2 )
  {
    *_errno() = 34;
    goto LABEL_15;
  }
  return -1;
}

//----- (6E691098) --------------------------------------------------------
LONG __thiscall CPropSheetPage::~CPropSheetPage(CPropSheetPage *this)
{
  CPropSheetPage *v1; // esi@1
  LONG result; // eax@1

  v1 = this;
  result = *((_DWORD *)this + 1);
  *(_DWORD *)this = &CPropSheetPage::`vftable';
  if ( result )
  {
    result = GetWindowLongW((HWND)result, 8);
    if ( result )
      result = SetWindowLongW(*((HWND *)v1 + 1), 8, 0);
  }
  return result;
}
// 6E647CAC: using guessed type int (*CPropSheetPage::`vftable')();

//----- (6E6910CB) --------------------------------------------------------
signed int __stdcall CPropSheetPage::DialogProc(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4)
{
  HWND v4; // edi@1
  LONG v5; // esi@2
  signed int result; // eax@9
  signed int v7; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  v4 = hWnd;
  if ( a2 == 272 )
  {
    v5 = *(_DWORD *)(a4 + 28);
    SetWindowLongW(hWnd, 8, *(_DWORD *)(a4 + 28));
    *(_DWORD *)(v5 + 4) = v4;
  }
  else
  {
    result = GetWindowLongW(hWnd, 8);
    v5 = result;
    if ( !result )
      return result;
  }
  if ( (**(int (__thiscall ***)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))v5)(
         v5,
         v4,
         a2,
         a3,
         a4,
         &hWnd,
         0) )
  {
    if ( a2 >= 0x2E && (a2 <= 0x2F || a2 == 55 || a2 == 57 || a2 == 272) )
      return (signed int)hWnd;
    SetWindowLongW(v4, 0, (LONG)hWnd);
    v7 = 1;
  }
  return v7;
}

//----- (6E691165) --------------------------------------------------------
int __stdcall CPropSheetPage::PropSheetPageProc(HWND a1, unsigned int a2, struct _PROPSHEETPAGEW *a3)
{
  LPARAM v3; // ecx@1
  int v4; // esi@1

  v3 = a3->lParam;
  v4 = 1;
  if ( a2 == 2 )
  {
    v4 = (*(int (**)(void))(*(_DWORD *)v3 + 8))();
  }
  else if ( a2 == 1 )
  {
    (*(void (**)(void))(*(_DWORD *)v3 + 12))();
  }
  return v4;
}

//----- (6E691199) --------------------------------------------------------
struct _PSP *__thiscall CPropSheetPage::CreatePage(CPropSheetPage *this, __int16 a2, unsigned __int32 a3, const unsigned __int16 *a4, const unsigned __int16 *a5, const unsigned __int16 *a6, HINSTANCE hModule)
{
  CPropSheetPage *v7; // esi@1
  LPVOID v8; // eax@2
  HRSRC v9; // eax@3
  HGLOBAL v10; // eax@4
  _BYTE constPropSheetPagePointer[48]; // [sp+4h] [bp-38h]@1

  v7 = this;
  memset(&constPropSheetPagePointer[4], 0, 0x34u);
  *(_DWORD *)constPropSheetPagePointer = 56;
  *(_DWORD *)&constPropSheetPagePointer[4] = a3;
  if ( !hModule )
  {
    *(_DWORD *)&constPropSheetPagePointer[8] = ::hModule;
    v8 = (LPVOID)(unsigned __int16)a2;
LABEL_7:
    *(_DWORD *)&constPropSheetPagePointer[12] = v8;
    *(_DWORD *)&constPropSheetPagePointer[40] = a4;
    *(_DWORD *)&constPropSheetPagePointer[44] = a5;
    *(_DWORD *)&constPropSheetPagePointer[20] = a6;
    *(_DWORD *)&constPropSheetPagePointer[24] = CPropSheetPage::DialogProc;
    *(_DWORD *)&constPropSheetPagePointer[32] = CPropSheetPage::PropSheetPageProc;
    *(_DWORD *)&constPropSheetPagePointer[28] = v7;
    return CreatePropertySheetPageW((LPCPROPSHEETPAGEW)constPropSheetPagePointer);
  }
  v9 = FindResourceW(hModule, (LPCWSTR)(unsigned __int16)a2, (LPCWSTR)5);
  if ( v9 )
  {
    v10 = LoadResource(hModule, v9);
    if ( v10 )
    {
      v8 = LockResource(v10);
      if ( v8 )
      {
        *(_DWORD *)&constPropSheetPagePointer[8] = 0;
        *(_DWORD *)&constPropSheetPagePointer[4] |= 1u;
        goto LABEL_7;
      }
    }
  }
  return 0;
}

//----- (6E691248) --------------------------------------------------------
__int32 __stdcall HrNcQueryUserForRebootEx(HWND hWnd, LPCWSTR lpCaption, LPCWSTR lpText, void *lpMem)
{
  __int32 v4; // edi@1

  v4 = 1;
  if ( !((unsigned __int8)lpMem & 1) || MessageBoxW(hWnd, lpText, lpCaption, 0x34u) == 6 )
  {
    if ( (unsigned __int8)lpMem & 2 )
    {
      lpMem = 0;
      v4 = HrEnableAllPrivileges((struct _TOKEN_PRIVILEGES **)&lpMem);
      if ( !v4 && !InitiateSystemShutdownExW(0, 0, 0, 0, 1, 0x80020009) )
        v4 = HrFromLastWin32Error();
      if ( lpMem )
        MemFree(lpMem);
    }
    else
    {
      v4 = 0;
    }
  }
  return v4;
}

//----- (6E6912C2) --------------------------------------------------------
__int32 __stdcall HrNcQueryUserForReboot(HINSTANCE hModule, HWND hWnd, unsigned int a3, unsigned int a4, void *lpMem)
{
  const WCHAR *v5; // esi@1
  const WCHAR *v6; // eax@1

  v5 = SzLoadString(hModule, a3);
  v6 = SzLoadString(hModule, a4);
  return HrNcQueryUserForRebootEx(hWnd, v5, v6, lpMem);
}

//----- (6E6912F7) --------------------------------------------------------
__int32 __stdcall LresFromHr(__int32 a1)
{
  __int32 result; // eax@1

  result = a1;
  if ( a1 == -2147180479 )
  {
    result = 1;
  }
  else if ( a1 == -2147180478 )
  {
    result = 2;
  }
  else if ( a1 >= 0 )
  {
    result = 0;
  }
  return result;
}

//----- (6E691326) --------------------------------------------------------
int NcMsgBox(HINSTANCE hModule, HWND hWnd, unsigned int a3, unsigned int a4, UINT uType, ...)
{
  const WCHAR *v5; // edi@1
  const unsigned __int16 *v6; // eax@1
  int v7; // esi@1
  va_list Arguments; // [sp+8h] [bp-8h]@1
  WCHAR Buffer[2]; // [sp+Ch] [bp-4h]@1
  va_list va; // [sp+2Ch] [bp+1Ch]@1

  va_start(va, uType);
  v5 = SzLoadString(hModule, a3);
  v6 = SzLoadString(hModule, a4);
  Arguments = va;
  *(_DWORD *)Buffer = 0;
  FormatMessageW(0x500u, v6, 0, 0, Buffer, 0, &Arguments);
  Arguments = 0;
  v7 = MessageBoxW(hWnd, *(LPCWSTR *)Buffer, v5, uType);
  LocalFree(*(HLOCAL *)Buffer);
  return v7;
}

//----- (6E691392) --------------------------------------------------------
void __stdcall SetDefaultButton(HWND hWnd, WPARAM wParam)
{
  LRESULT v2; // eax@1
  int v3; // ST1C_4@3
  HWND v4; // eax@3
  HWND v5; // eax@7

  v2 = SendMessageW(hWnd, 0x400u, 0, 0);
  if ( HIWORD(v2) == 21323 )
  {
    if ( (_WORD)v2 )
    {
      v3 = (unsigned __int16)v2;
      v4 = GetDlgItem(hWnd, (unsigned __int16)v2);
      if ( v3 != wParam )
      {
        if ( v4 )
          SendMessageW(v4, 0xF4u, 0, 1);
      }
    }
  }
  SendMessageW(hWnd, 0x401u, wParam, 0);
  if ( wParam )
  {
    v5 = GetDlgItem(hWnd, wParam);
    SendMessageW(v5, 0xF4u, 1u, 1);
  }
}

//----- (6E69141F) --------------------------------------------------------
unsigned __int32 __stdcall DwContextIdFromIdc(const struct CONTEXTIDMAP *a1, int a2, int a3)
{
  int v3; // edx@1
  int i; // eax@1
  unsigned __int32 result; // eax@5
  int v6; // eax@7

  v3 = *(_DWORD *)a1;
  for ( i = 0; ; v3 = *((_DWORD *)a1 + 3 * i) )
  {
    if ( !v3 )
      return 0;
    if ( a3 == v3 )
      break;
    ++i;
  }
  v6 = 12 * i;
  if ( a2 )
    result = *(_DWORD *)((char *)a1 + v6 + 8);
  else
    result = *(_DWORD *)((char *)a1 + v6 + 4);
  return result;
}

//----- (6E69145F) --------------------------------------------------------
void __stdcall OnHelpGeneric(HWND hWndMain, struct tagHELPINFO *a2, const struct CONTEXTIDMAP *a3, int a4, LPCWSTR lpszHelp)
{
  int v5; // eax@2
  const WCHAR *v6; // [sp-Ch] [bp-Ch]@4
  ULONG_PTR v7; // [sp-4h] [bp-4h]@4

  if ( a2->iContextType == 1 )
  {
    v5 = a2->iCtrlId;
    if ( v5 != -1 )
    {
      if ( (unsigned int)(v5 - 1) > 8 )
      {
        v7 = DwContextIdFromIdc(a3, a4, v5);
        v6 = lpszHelp;
      }
      else
      {
        v7 = DwContextIdFromIdc((const struct CONTEXTIDMAP *)dword_6E6914B0, a4, v5);
        v6 = L"windows.hlp";
      }
      WinHelpW(hWndMain, v6, 8u, v7);
    }
  }
}
// 6E6914B0: using guessed type int dword_6E6914B0[9];
// 6E6914D4: using guessed type wchar_t aWindows_hlp[12];

//----- (6E6914F1) --------------------------------------------------------
int NcMsgBox(HWND hWnd, unsigned int a2, unsigned int a3, UINT uType, ...)
{
  const WCHAR *v4; // edi@1
  const unsigned __int16 *v5; // eax@1
  int result; // eax@2
  int v7; // esi@3
  va_list Arguments; // [sp+8h] [bp-8h]@1
  WCHAR Buffer[2]; // [sp+Ch] [bp-4h]@1
  va_list va; // [sp+28h] [bp+18h]@1

  va_start(va, uType);
  v4 = SzLoadIds(a2);
  v5 = SzLoadIds(a3);
  Arguments = va;
  *(_DWORD *)Buffer = 0;
  FormatMessageW(0x500u, v5, 0, 0, Buffer, 0, &Arguments);
  Arguments = 0;
  if ( *(_DWORD *)Buffer )
  {
    v7 = MessageBoxW(hWnd, *(LPCWSTR *)Buffer, v4, uType);
    LocalFree(*(HLOCAL *)Buffer);
    result = v7;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6E691560) --------------------------------------------------------
BOOL __stdcall FBadArgs_INetCfgProperties_MergePropPages(unsigned __int32 *a1, unsigned __int8 **a2, unsigned int *a3, HWND hWnd, const unsigned __int16 **a5)
{
  *a2 = 0;
  *a3 = 0;
  if ( a5 )
    *a5 = 0;
  return hWnd && !IsWindow(hWnd);
}

//----- (6E69159E) --------------------------------------------------------
int __stdcall HrFindAndRemoveComponent(struct IUnknown *a1, const struct _GUID *a2, struct IUnknown *a3, struct tagOBO_TOKEN *a4)
{
  int v4; // esi@1
  HRESULT v5; // eax@2

  v4 = ((int (__stdcall *)(struct IUnknown *, const struct _GUID *, GUID *, struct IUnknown **))a1->lpVtbl[3].QueryInterface)(
         a1,
         a2,
         &IID_INetCfgClass,
         &a1);
  if ( !v4 )
  {
    v5 = a1->lpVtbl[1].QueryInterface(a1, (const IID *const )a3, (void **)&a3);
    v4 = v5;
    if ( v5 )
    {
      if ( v5 == 1 )
        v4 = 0;
    }
    else
    {
      v4 = a1->lpVtbl->QueryInterface(a1, &IID_INetCfgClassSetup, (void **)&a2);
      if ( v4 >= 0 )
      {
        v4 = (*(int (__stdcall **)(const struct _GUID *, struct IUnknown *, struct tagOBO_TOKEN *, _DWORD))(a2->Data1 + 20))(
               a2,
               a3,
               a4,
               0);
        ReleaseObj((struct IUnknown *)a2);
      }
      ReleaseObj(a3);
    }
    ReleaseObj(a1);
  }
  return v4;
}

//----- (6E69162C) --------------------------------------------------------
__int32 __stdcall HrInstallComponent(struct INetCfg *a1, const struct NETWORK_INSTALL_PARAMS *a2, const struct _GUID *a3, const unsigned __int16 *a4, struct tagOBO_TOKEN *a5, struct IUnknown *a6)
{
  struct IUnknown *v6; // ebx@1
  HRESULT v7; // edi@3
  int v8; // eax@5

  v6 = a6;
  if ( a6 )
    a6->lpVtbl = 0;
  v7 = a1->lpVtbl->QueryNetCfgClass(a1, a3, &IID_INetCfgClassSetup, (void **)&a6);
  if ( !v7 )
  {
    if ( a2 )
      v8 = ((int (__stdcall *)(struct IUnknown *, const unsigned __int16 *, struct tagOBO_TOKEN *, _DWORD, _DWORD, _DWORD, _DWORD, struct IUnknown *))a6->lpVtbl[1].AddRef)(
             a6,
             a4,
             a5,
             *(_DWORD *)a2,
             *((_DWORD *)a2 + 1),
             *((_DWORD *)a2 + 2),
             *((_DWORD *)a2 + 3),
             v6);
    else
      v8 = ((int (__stdcall *)(struct IUnknown *, const unsigned __int16 *, struct tagOBO_TOKEN *, _DWORD, _DWORD, _DWORD, _DWORD, struct IUnknown *))a6->lpVtbl[1].AddRef)(
             a6,
             a4,
             a5,
             0,
             0,
             0,
             0,
             v6);
    v7 = v8;
    ReleaseObj(a6);
  }
  return v7;
}

//----- (6E6916A9) --------------------------------------------------------
__int32 __stdcall HrInstallComponentOboComponent(struct INetCfg *a1, const struct NETWORK_INSTALL_PARAMS *a2, const struct _GUID *a3, const unsigned __int16 *a4, struct INetCfgComponent *a5, struct IUnknown *a6)
{
  struct tagOBO_TOKEN v7; // [sp+0h] [bp-18h]@3

  if ( a6 )
    a6->lpVtbl = 0;
  memset(&v7, 0, sizeof(v7));
  v7.pncc = a5;
  v7.Type = 2;
  return HrInstallComponent(a1, a2, a3, a4, &v7, a6);
}

//----- (6E6916F3) --------------------------------------------------------
int __stdcall HrRemoveComponentOboComponent(struct IUnknown *a1, const struct _GUID *a2, struct IUnknown *a3, struct INetCfgComponent *a4)
{
  struct tagOBO_TOKEN v5; // [sp+4h] [bp-18h]@1

  memset(&v5, 0, sizeof(v5));
  v5.pncc = a4;
  v5.Type = 2;
  return HrFindAndRemoveComponent(a1, a2, a3, &v5);
}

//----- (6E69172F) --------------------------------------------------------
int __stdcall HrGetLastComponentAndInterface(struct INetCfgBindingPath *a1, struct INetCfgComponent **a2, struct IUnknown *a3)
{
  struct IUnknown *v3; // ebx@1
  struct IUnknown *v4; // esi@1
  int v5; // eax@4
  int v6; // edi@4
  char v8; // [sp+Ch] [bp-24h]@3
  struct IUnknown *v9; // [sp+20h] [bp-10h]@13
  int v10; // [sp+2Ch] [bp-4h]@3

  v3 = a3;
  v4 = 0;
  *a2 = 0;
  if ( v3 )
    v3->lpVtbl = 0;
  CIterNetCfgBindingInterface::CIterNetCfgBindingInterface((CIterNetCfgBindingInterface *)&v8, a1);
  v10 = 0;
  while ( 1 )
  {
    v5 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v8, (int)&a3);
    v6 = v5;
    if ( v5 )
      break;
    ReleaseObj(v4);
    v4 = a3;
  }
  if ( v5 == 1 )
  {
    v6 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown **))v4->lpVtbl[1].Release)(v4, &a3);
    if ( !v6 )
    {
      if ( v3 )
        v6 = ((int (__stdcall *)(struct IUnknown *, struct IUnknown *))v4->lpVtbl[1].QueryInterface)(v4, v3);
      if ( !v6 )
      {
        AddRefObj(a3);
        *a2 = (struct INetCfgComponent *)a3;
      }
      ReleaseObj(a3);
    }
  }
  ReleaseObj(v4);
  ReleaseObj(v9);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v8);
  return v6;
}

//----- (6E6917D9) --------------------------------------------------------
void __stdcall FreeNetconProperties(struct tagNETCON_PROPERTIES *pv)
{
  if ( pv )
  {
    CoTaskMemFree(pv->pszwName);
    CoTaskMemFree(pv->pszwDeviceName);
    CoTaskMemFree(pv);
  }
}

//----- (6E691835) --------------------------------------------------------
__int32 __stdcall HrOpenConnectionKey(GUID *rguid, OLECHAR *a2, REGSAM samDesired, char a4, BYTE *a5, PHKEY phkResult)
{
  OLECHAR *v6; // eax@1
  __int32 v8; // eax@16
  char v9; // [sp+8h] [bp-270h]@8
  DWORD dwDisposition; // [sp+10h] [bp-268h]@6
  DWORD Type; // [sp+14h] [bp-264h]@7
  enum tagNETCON_MEDIATYPE v12; // [sp+18h] [bp-260h]@8
  __int32 v13; // [sp+1Ch] [bp-25Ch]@1
  BYTE *lpData; // [sp+20h] [bp-258h]@1
  wchar_t pszDest; // [sp+24h] [bp-254h]@5
  OLECHAR sz; // [sp+224h] [bp-54h]@4

  v6 = a2;
  lpData = a5;
  v13 = 0;
  if ( rguid )
  {
    if ( !a2 )
      goto LABEL_3;
    return -2147024809;
  }
  if ( !a2 || !*a2 )
    return -2147024809;
LABEL_3:
  *phkResult = 0;
  if ( rguid )
  {
    StringFromGUID2(rguid, &sz, 39);
    v6 = &sz;
  }
  StringCchPrintfW(
    &pszDest,
    0x100u,
    L"System\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\%s\\Connection",
    v6);
  if ( a4 & 1 )
  {
    v13 = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, &pszDest, 0, samDesired, 0, phkResult, &dwDisposition);
    if ( !v13 )
    {
      v13 = HrRegSetSz(*phkResult, L"PnpInstanceID", lpData);
      if ( HrRegQueryDword(*phkResult, L"MediaSubType", (DWORD)&Type) == -2147024894 )
      {
        CIntelliName::CIntelliName((CIntelliName *)&v9, 0, 0);
        v12 = 0;
        lpData = 0;
        if ( CIntelliName::HrGetPseudoMediaTypes(rguid, &v12, (enum tagNETCON_SUBMEDIATYPE *)&lpData) >= 0
          && lpData != (BYTE *)1 )
          HrRegSetDword(*phkResult, L"MediaSubType", (BYTE)lpData);
      }
    }
    return v13;
  }
  if ( !(a4 & 2) )
  {
    v8 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, &pszDest, samDesired, phkResult);
    goto LABEL_18;
  }
  if ( wcslen(&sz) )
  {
    StringCchCopyW(
      &pszDest,
      0x100u,
      L"System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002bE10318}");
    StringCchCatW(&pszDest, 0x100u, L"\\");
    StringCchCatW(&pszDest, 0x100u, &sz);
    v8 = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, &pszDest);
LABEL_18:
    v13 = v8;
  }
  return v13;
}

//----- (6E691BBB) --------------------------------------------------------
__int32 __stdcall HrIsConnection(struct INetCfgComponent *a1)
{
  HRESULT v1; // esi@1
  __int32 v2; // eax@2
  HKEY hKey; // [sp+4h] [bp-18h]@2
  char v5; // [sp+8h] [bp-14h]@1

  v1 = a1->lpVtbl->GetInstanceGuid(a1, (GUID *)&v5);
  if ( v1 >= 0 )
  {
    v2 = HrOpenConnectionKey((GUID *)&v5, 0, 0x20019u, 0, 0, &hKey);
    v1 = v2;
    if ( v2 < 0 )
    {
      if ( v2 == -2147024894 )
        v1 = 1;
    }
    else
    {
      RegCloseKey(hKey);
    }
  }
  return v1;
}

//----- (6E691C2B) --------------------------------------------------------
int __stdcall HrGetDeviceGuid(struct INetConnection *a1, struct _GUID *a2)
{
  int v2; // esi@1
  struct IUnknown *v4; // [sp+4h] [bp-4h]@1

  v4 = 0;
  v2 = HrQIAndSetProxyBlanket<INetLanConnection>((struct IUnknown *)a1, (void **)&v4);
  if ( v2 >= 0 )
  {
    v2 = ((int (__stdcall *)(struct IUnknown *, struct _GUID *))v4->lpVtbl[1].Release)(v4, a2);
    ReleaseObj(v4);
  }
  return v2;
}

//----- (6E691C6A) --------------------------------------------------------
int __stdcall FPconnEqualGuid(struct INetConnection *a1, const struct _GUID *a2)
{
  int v2; // esi@1
  struct _GUID v4; // [sp+4h] [bp-14h]@1

  v2 = 0;
  if ( HrGetDeviceGuid(a1, &v4) >= 0 )
    v2 = memcmp(&v4, a2, 0x10u) == 0;
  return v2;
}

//----- (6E691CD5) --------------------------------------------------------
void *__stdcall OpenDevice(HANDLE FileHandle)
{
  NTSTATUS v1; // eax@1
  DWORD v2; // eax@2
  OBJECT_ATTRIBUTES ObjectAttributes; // [sp+0h] [bp-20h]@1
  struct _IO_STATUS_BLOCK IoStatusBlock; // [sp+18h] [bp-8h]@1

  ObjectAttributes.RootDirectory = 0;
  ObjectAttributes.SecurityDescriptor = 0;
  ObjectAttributes.SecurityQualityOfService = 0;
  ObjectAttributes.ObjectName = (PUNICODE_STRING)FileHandle;
  ObjectAttributes.Length = 24;
  ObjectAttributes.Attributes = 64;
  v1 = NtOpenFile(&FileHandle, 0x12019Fu, &ObjectAttributes, &IoStatusBlock, 7u, 0x20u);
  if ( v1 )
  {
    FileHandle = 0;
    v2 = RtlNtStatusToDosError(v1);
    SetLastError(v2);
  }
  return FileHandle;
}

//----- (6E691D3A) --------------------------------------------------------
__int32 __stdcall HrQueryDeviceOIDByName(PCWSTR SourceString, DWORD dwIoControlCode, char InBuffer, DWORD BytesReturned, void *Dst)
{
  DWORD v5; // edi@1
  SIZE_T v6; // esi@2
  void *v7; // eax@2
  void *v8; // ebx@2
  DWORD v9; // ecx@4
  LSA_UNICODE_STRING DestinationString; // [sp+4h] [bp-Ch]@1
  __int32 v12; // [sp+Ch] [bp-4h]@1
  void *SourceStringa; // [sp+18h] [bp+8h]@1

  v12 = 0;
  RtlInitUnicodeString(&DestinationString, SourceString);
  v5 = BytesReturned;
  memset(Dst, 0, *(_DWORD *)BytesReturned);
  SourceStringa = OpenDevice(&DestinationString);
  if ( SourceStringa )
  {
    v6 = *(_DWORD *)v5 + 11;
    v7 = operator new(v6);
    v8 = v7;
    if ( v7 )
    {
      if ( DeviceIoControl(SourceStringa, dwIoControlCode, &InBuffer, 4u, v7, v6, &BytesReturned, 0) )
      {
        v9 = BytesReturned;
        *(_DWORD *)v5 = BytesReturned;
        if ( v9 )
        {
          if ( *((_DWORD *)v8 + 1) <= v9 )
          {
            memcpy(Dst, (char *)v8 + 8, *((_DWORD *)v8 + 1));
          }
          else
          {
            *(_DWORD *)v5 = 0;
            v12 = -2147024774;
          }
        }
        else
        {
          v12 = 1;
        }
      }
      else
      {
        v12 = HrFromLastWin32Error();
      }
      operator delete(v8);
    }
    else
    {
      v12 = -2147024882;
    }
    CloseHandle(SourceStringa);
  }
  else
  {
    v12 = HrFromLastWin32Error();
  }
  return v12;
}

//----- (6E691E1D) --------------------------------------------------------
__int32 __stdcall HrQueryNDISAdapterOID(GUID *rguid, char InBuffer, DWORD BytesReturned, void *Dst)
{
  WCHAR SourceString; // [sp+Ch] [bp-64h]@1
  OLECHAR sz; // [sp+1Ch] [bp-54h]@1

  StringCchCopyW(&SourceString, 0x30u, L"\\DEVICE\\");
  StringFromGUID2(rguid, &sz, 39);
  return HrQueryDeviceOIDByName(&SourceString, 0x17000Eu, InBuffer, BytesReturned, Dst);
}

//----- (6E691E9B) --------------------------------------------------------
__int32 __stdcall CIntelliName::HrGetPseudoMediaTypes(const struct _GUID *a2, enum tagNETCON_MEDIATYPE *a3, enum tagNETCON_SUBMEDIATYPE *a4)
{
  __int32 v3; // ebx@1
  signed int v4; // eax@8
  struct IUnknown *v5; // eax@18
  enum tagNETCON_SUBMEDIATYPE *v6; // esi@18
  struct IUnknownVtbl *v7; // ecx@18
  int v9; // [sp-4h] [bp-6Ch]@0
  char v10; // [sp+Ch] [bp-5Ch]@3
  struct IUnknown *v11; // [sp+20h] [bp-48h]@26
  int Dst; // [sp+24h] [bp-44h]@12
  GUID *rguid; // [sp+28h] [bp-40h]@1
  enum tagNETCON_MEDIATYPE *v14; // [sp+2Ch] [bp-3Ch]@1
  int v15; // [sp+30h] [bp-38h]@3
  PCNZWCH lpString1; // [sp+34h] [bp-34h]@18
  DWORD BytesReturned; // [sp+38h] [bp-30h]@12
  LPVOID ppv; // [sp+3Ch] [bp-2Ch]@1
  enum tagNETCON_SUBMEDIATYPE *v19; // [sp+40h] [bp-28h]@1
  struct IUnknown *v20; // [sp+44h] [bp-24h]@3
  char v21; // [sp+48h] [bp-20h]@6
  int v22; // [sp+64h] [bp-4h]@3

  rguid = (GUID *)a2;
  v14 = a3;
  v19 = a4;
  *(_DWORD *)a4 = 0;
  v3 = CoCreateInstance(&CLSID_CNetCfg, 0, 0x401u, &IID_INetCfg, &ppv);
  if ( v3 < 0 )
    return v3;
  v3 = (*(int (__stdcall **)(LPVOID, _DWORD, int))(*(_DWORD *)ppv + 12))(ppv, 0, v9);
  if ( v3 < 0 )
    goto LABEL_27;
  CIterNetCfgComponent::CIterNetCfgComponent((int)&v10, (struct IUnknown *)ppv, (int)&GUID_DEVCLASS_NET);
  v22 = 0;
  v20 = 0;
  v15 = 0;
  do
  {
    if ( v3 < 0 )
      break;
    v3 = CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::HrNext((int)&v10, (int)&v20);
    if ( v3 )
      break;
    v3 = ((int (__stdcall *)(struct IUnknown *, char *))v20->lpVtbl[2].Release)(v20, &v21);
    if ( v3 )
      goto LABEL_25;
    if ( memcmp(rguid, &v21, 0x10u) )
      goto LABEL_25;
    v4 = HrIsLanCapableAdapter(v20);
    v3 = v4;
    if ( v4 < 0 )
      goto LABEL_25;
    v15 = 1;
    if ( v4 == 1 )
    {
      *v14 = 4;
    }
    else if ( !v4 )
    {
      *v14 = 3;
      BytesReturned = 4;
      v3 = HrQueryNDISAdapterOID(rguid, 2, (DWORD)&BytesReturned, &Dst);
      if ( v3 )
        goto LABEL_18;
      if ( Dst == 1 )
        goto LABEL_31;
      if ( Dst == 7 )
      {
        *(_DWORD *)v19 = 3;
      }
      else
      {
        if ( Dst != 8 )
        {
          if ( Dst != 9 )
          {
            v3 = 1;
LABEL_18:
            v5 = v20;
            v6 = v19;
            *(_DWORD *)v19 = 1;
            v7 = v5->lpVtbl;
            BytesReturned = v3;
            v3 = ((int (__stdcall *)(struct IUnknown *, PCNZWCH *))v7[2].QueryInterface)(v5, &lpString1);
            if ( v3 >= 0 )
            {
              if ( CompareStringW(0x7Fu, 1u, lpString1, -1, L"sw\\{48926476-2cae-4ded-a86e-73ddebed6779}", -1) == 2 )
                *(_DWORD *)v6 = 8;
              CoTaskMemFree((LPVOID)lpString1);
            }
            if ( (BytesReturned & 0x80000000) != 0 && *(_DWORD *)v6 == 1 )
              v3 = BytesReturned;
            goto LABEL_25;
          }
LABEL_31:
          *(_DWORD *)v19 = 2;
          goto LABEL_25;
        }
        *(_DWORD *)v19 = 9;
      }
    }
LABEL_25:
    v20->lpVtbl->Release(v20);
  }
  while ( !v15 );
  (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 16))(ppv);
  v22 = -1;
  ReleaseObj(v11);
  CIEnumIter<IEnumNetCfgBindingInterface,INetCfgBindingInterface *>::ReleaseRemainingBatch((int)&v10);
LABEL_27:
  (*(void (__cdecl **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  return v3;
}

#error "There were 3 decompilation failure(s) on 1913 function(s)"
