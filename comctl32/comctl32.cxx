/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// NTSTATUS __stdcall NtQueryInformationProcess(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
// BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// LSTATUS __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// PVOID __stdcall FreeSid(PSID pSid);
// BOOL __stdcall CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
// BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// LSTATUS __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
// LSTATUS __stdcall RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
// int __stdcall SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse);
// HBRUSH __stdcall CreatePatternBrush(HBITMAP hbm);
// int __stdcall GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
// BOOL __stdcall GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz);
// HGDIOBJ __stdcall GetStockObject(int i);
// BOOL __stdcall DeleteObject(HGDIOBJ ho);
// HRGN __stdcall CreateRectRgn(int x1, int y1, int x2, int y2);
// BOOL __stdcall SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
// BOOL __stdcall OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
// HFONT __stdcall CreateFontIndirectW(const LOGFONTW *lplf);
// int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);
// int __stdcall GetDeviceCaps(HDC hdc, int index);
// BOOL __stdcall DeleteDC(HDC hdc);
// BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
// DWORD __stdcall SetLayout(HDC hdc, DWORD l);
// HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
// HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
// HDC __stdcall CreateCompatibleDC(HDC hdc);
// int __stdcall StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop);
// HBITMAP __stdcall CreateDIBSection(HDC hdc, const BITMAPINFO *lpbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// BOOL __stdcall TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
// BOOL __stdcall ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx);
// BOOL __stdcall GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
// HPALETTE __stdcall CreateHalftonePalette(HDC hdc);
// HPALETTE __stdcall CreatePalette(const LOGPALETTE *plpal);
// UINT __stdcall GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq);
// BOOL __stdcall GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// UINT __stdcall RealizePalette(HDC hdc);
// HPALETTE __stdcall SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
// BOOL __stdcall UnrealizeObject(HGDIOBJ h);
// BOOL __stdcall StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
// COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
// COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color);
// int __stdcall SetBkMode(HDC hdc, int mode);
// BOOL __stdcall SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
// BOOL __stdcall GetDCOrgEx(HDC hdc, LPPOINT lppt);
// int __stdcall EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);
// BOOL __stdcall PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop);
// HBRUSH __stdcall CreateSolidBrush(COLORREF color);
// COLORREF __stdcall GetNearestColor(HDC hdc, COLORREF color);
// UINT __stdcall SetTextAlign(HDC hdc, UINT align);
// UINT __stdcall GetTextAlign(HDC hdc);
// BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
// int __stdcall IntersectClipRect(HDC hdc, int left, int top, int right, int bottom);
// int __stdcall SaveDC(HDC hdc);
// BOOL __stdcall RectVisible(HDC hdc, const RECT *lprect);
// BOOL __stdcall Polyline(HDC hdc, const POINT *apt, int cpt);
// HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
// HBITMAP __stdcall CreateBitmapIndirect(const BITMAP *pbm);
// DWORD __stdcall GetLayout(HDC hdc);
// HBITMAP __stdcall CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits);
// BOOL __stdcall TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);
// HFONT __stdcall CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
// int __stdcall GetClipBox(HDC hdc, LPRECT lprect);
// BOOL __stdcall Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
// int __stdcall SelectClipRgn(HDC hdc, HRGN hrgn);
// BOOL __stdcall Rectangle(HDC hdc, int left, int top, int right, int bottom);
// BOOL __stdcall Ellipse(HDC hdc, int left, int top, int right, int bottom);
// BOOL __stdcall LineTo(HDC hdc, int x, int y);
// BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
// LONG __stdcall GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits);
// HGDIOBJ __stdcall GetCurrentObject(HDC hdc, UINT type);
// int __stdcall CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
// HRGN __stdcall CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode);
// HRGN __stdcall CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h);
// BOOL __stdcall FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
// BOOL __stdcall FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
// BOOL __stdcall GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
// COLORREF __stdcall GetBkColor(HDC hdc);
// COLORREF __stdcall GetPixel(HDC hdc, int x, int y);
// HRGN __stdcall CreateRectRgnIndirect(const RECT *lprect);
// COLORREF __stdcall GetTextColor(HDC hdc);
// int __stdcall ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom);
// int __stdcall GetClipRgn(HDC hdc, HRGN hrgn);
// int __stdcall OffsetRgn(HRGN hrgn, int x, int y);
// int __stdcall GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
// BOOL __stdcall GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
// BOOL __stdcall GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz);
// BOOL __stdcall ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx);
// BOOL __stdcall GetWindowExtEx(HDC hdc, LPSIZE lpsize);
// BOOL __stdcall GetViewportExtEx(HDC hdc, LPSIZE lpsize);
// int __stdcall ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode);
// UINT __stdcall GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);
// BOOL __stdcall SetPixelV(HDC hdc, int x, int y, COLORREF color);
// COLORREF __stdcall SetPixel(HDC hdc, int x, int y, COLORREF color);
// UINT __stdcall SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
// int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
// int __stdcall lstrlenW(LPCWSTR lpString);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// HLOCAL __stdcall LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);
// SIZE_T __stdcall LocalSize(HLOCAL hMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall GetCurrentProcess();
// DWORD __stdcall GetTickCount();
// int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// BOOL __stdcall FreeResource(HGLOBAL hResData);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// int __stdcall lstrlenA(LPCSTR lpString);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
// BOOL __stdcall EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam);
// HRSRC __stdcall FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// HRSRC __stdcall FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage);
// LCID __stdcall GetThreadLocale();
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber);
// LONG __stdcall InterlockedExchange(volatile LONG *Target, LONG Value);
// ATOM __stdcall GlobalAddAtomW(LPCWSTR lpString);
// DWORD __stdcall GetCurrentProcessId();
// DWORD __stdcall GetCurrentThreadId();
// BOOL __stdcall QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired);
// BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie);
// BOOL __stdcall DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// UINT __stdcall GetACP();
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);
// int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// LCID __stdcall GetSystemDefaultLCID();
// void __stdcall Sleep(DWORD dwMilliseconds);
// LANGID __stdcall GetUserDefaultLangID();
// int __stdcall GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);
// BOOL __stdcall EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);
// BOOL __stdcall GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// LCID __stdcall GetUserDefaultLCID();
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// int __stdcall GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);
// DWORD __stdcall GetLastError();
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// LONG __stdcall InterlockedCompareExchange(volatile LONG *Destination, LONG Exchange, LONG Comperand);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// HANDLE __stdcall CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);
// LPSTR __stdcall GetCommandLineA();
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// UINT __stdcall SetHandleCount(UINT uNumber);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// DWORD __stdcall GetFileType(HANDLE hFile);
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall FreeEnvironmentStringsA(LPCH);
// LPCH __stdcall GetEnvironmentStrings();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// LPWCH __stdcall GetEnvironmentStringsW();
// BOOL __stdcall HeapDestroy(HANDLE hHeap);
// HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// UINT __stdcall GetConsoleCP();
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// BOOL __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);
// SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// BOOL __stdcall GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
// LPWSTR __stdcall CharLowerW(LPWSTR lpsz);
// BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);
// HWND __stdcall GetParent(HWND hWnd);
// BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint);
// LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex);
// BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);
// BOOL __stdcall ReleaseCapture();
// HWND __stdcall GetCapture();
// BOOL __stdcall WaitMessage();
// BOOL __stdcall PtInRect(const RECT *lprc, POINT pt);
// LRESULT __stdcall DispatchMessageW(const MSG *lpMsg);
// BOOL __stdcall TranslateMessage(const MSG *lpMsg);
// BOOL __stdcall CallMsgFilterW(LPMSG lpMsg, int nCode);
// BOOL __stdcall PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// BOOL __stdcall IsWindow(HWND hWnd);
// HWND __stdcall SetCapture(HWND hWnd);
// int __stdcall MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);
// BOOL __stdcall SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);
// int __stdcall GetSystemMetrics(int nIndex);
// BOOL __stdcall SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// UINT __stdcall RegisterWindowMessageW(LPCWSTR lpString);
// HBRUSH __stdcall GetSysColorBrush(int nIndex);
// DWORD __stdcall GetSysColor(int nIndex);
// LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// LONG __stdcall GetMessageTime();
// BOOL __stdcall MessageBeep(UINT uType);
// BOOL __stdcall UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// BOOL __stdcall RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags);
// int __stdcall ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);
// UINT __stdcall GetDoubleClickTime();
// BOOL __stdcall SetRectEmpty(LPRECT lprc);
// BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint);
// DWORD __stdcall GetMessagePos();
// HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem);
// LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);
// BOOL __stdcall CopyRect(LPRECT lprcDst, const RECT *lprcSrc);
// int __stdcall ReleaseDC(HWND hWnd, HDC hDC);
// HDC __stdcall GetDC(HWND hWnd);
// HDWP __stdcall DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags);
// HWND __stdcall CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// BOOL __stdcall DestroyWindow(HWND hWnd);
// HWND __stdcall CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);
// int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);
// BOOL __stdcall IsWindowVisible(HWND hWnd);
// LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
// HWND __stdcall SetFocus(HWND hWnd);
// BOOL __stdcall IsChild(HWND hWndParent, HWND hWnd);
// BOOL __stdcall IsWindowEnabled(HWND hWnd);
// BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable);
// HWND __stdcall GetFocus();
// BOOL __stdcall EndDeferWindowPos(HDWP hWinPosInfo);
// HDWP __stdcall BeginDeferWindowPos(int nNumWindows);
// int __stdcall GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
// BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase);
// int __stdcall FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// void __stdcall SetLastErrorEx(DWORD dwErrCode, DWORD dwType);
// int __stdcall GetDlgCtrlID(HWND hWnd);
// HWND __stdcall GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious);
// BOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString);
// BOOL __stdcall IsDialogMessageW(HWND hDlg, LPMSG lpMsg);
// SHORT __stdcall GetKeyState(int nVirtKey);
// BOOL __stdcall MapDialogRect(HWND hDlg, LPRECT lpRect);
// BOOL __stdcall DestroyIcon(HICON hIcon);
// BOOL __stdcall SetForegroundWindow(HWND hWnd);
// HANDLE __stdcall CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags);
// BOOL __stdcall GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi);
// HMONITOR __stdcall MonitorFromWindow(HWND hwnd, DWORD dwFlags);
// HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
// HCURSOR __stdcall SetCursor(HCURSOR hCursor);
// HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
// BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
// BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
// HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
// HWND __stdcall SetActiveWindow(HWND hWnd);
// HWND __stdcall GetActiveWindow();
// void __stdcall PostQuitMessage(int nExitCode);
// BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
// HWND __stdcall GetDesktopWindow();
// BOOL __stdcall IsZoomed(HWND hWnd);
// HWND __stdcall CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// BOOL __stdcall InflateRect(LPRECT lprc, int dx, int dy);
// BOOL __stdcall UpdateWindow(HWND hWnd);
// BOOL __stdcall DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
// BOOL __stdcall DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);
// BOOL __stdcall DrawFrameControl(HDC, LPRECT, UINT, UINT);
// BOOL __stdcall GetIconInfo(HICON hIcon, PICONINFO piconinfo);
// ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass);
// BOOL __stdcall EqualRect(const RECT *lprc1, const RECT *lprc2);
// BOOL __stdcall IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// BOOL __stdcall GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);
// SHORT __stdcall GetAsyncKeyState(int vKey);
// BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// HDC __stdcall GetWindowDC(HWND hWnd);
// BOOL __stdcall EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
// HWND __stdcall GetWindow(HWND hWnd, UINT uCmd);
// BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
// UINT __stdcall GetCaretBlinkTime();
// BOOL __stdcall KillTimer(HWND hWnd, UINT_PTR uIDEvent);
// BOOL __stdcall GetCursorPos(LPPOINT lpPoint);
// UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// HANDLE __stdcall GetPropW(HWND hWnd, LPCWSTR lpString);
// DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);
// BOOL __stdcall SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
// HANDLE __stdcall RemovePropW(HWND hWnd, LPCWSTR lpString);
// LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// BOOL __stdcall SetCursorPos(int X, int Y);
// BOOL __stdcall DrawIcon(HDC hDC, int X, int Y, HICON hIcon);
// HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
// BOOL __stdcall InvertRect(HDC hDC, const RECT *lprc);
// BOOL __stdcall IsRectEmpty(const RECT *lprc);
// BOOL __stdcall EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);
// int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);
// int __stdcall GetScrollPos(HWND hWnd, int nBar);
// BOOL __stdcall GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);
// BOOL __stdcall GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);
// BOOL __stdcall ShowScrollBar(HWND hWnd, int wBar, BOOL bShow);
// int __stdcall SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);
// BOOL __stdcall SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);
// UINT __stdcall GetMenuItemID(HMENU hMenu, int nPos);
// int __stdcall GetMenuItemCount(HMENU hMenu);
// BOOL __stdcall GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii);
// HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos);
// HMENU __stdcall GetSystemMenu(HWND hWnd, BOOL bRevert);
// DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);
// BOOL __stdcall SetMenu(HWND hWnd, HMENU hMenu);
// UINT __stdcall GetMenuState(HMENU hMenu, UINT uId, UINT uFlags);
// BOOL __stdcall SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2);
// BOOL __stdcall UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);
// HICON __stdcall CreateIconIndirect(PICONINFO piconinfo);
// LPWSTR __stdcall CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
// BOOL __stdcall DrawFocusRect(HDC hDC, const RECT *lprc);
// HWND __stdcall WindowFromPoint(POINT Point);
// BOOL __stdcall OffsetRect(LPRECT lprc, int dx, int dy);
// HWND __stdcall SetParent(HWND hWndChild, HWND hWndNewParent);
// BOOL __stdcall AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
// HMENU __stdcall CreatePopupMenu();
// BOOL __stdcall DestroyMenu(HMENU hMenu);
// HMONITOR __stdcall MonitorFromRect(LPCRECT lprc, DWORD dwFlags);
// BOOL __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect);
// BOOL __stdcall AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu);
// int __stdcall FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr);
// HWND __stdcall ChildWindowFromPoint(HWND hWndParent, POINT Point);
// BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);
// INT_PTR __stdcall DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// HCURSOR __stdcall GetCursor();
// HWND __stdcall GetForegroundWindow();
// HMONITOR __stdcall MonitorFromPoint(POINT pt, DWORD dwFlags);
// BOOL __stdcall AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
// HMENU __stdcall GetMenu(HWND hWnd);
// int __stdcall SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);
// int __stdcall GetWindowRgn(HWND hWnd, HRGN hRgn);
// BOOL __stdcall InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
// int __stdcall GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize);
// UINT __stdcall MapVirtualKeyW(UINT uCode, UINT uMapType);
// BOOL __stdcall ShowCaret(HWND hWnd);
// BOOL __stdcall SetCaretPos(int X, int Y);
// BOOL __stdcall GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
// BOOL __stdcall HideCaret(HWND hWnd);
// BOOL __stdcall CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight);
// BOOL __stdcall DestroyCaret();
// HKL __stdcall GetKeyboardLayout(DWORD idThread);
// int __stdcall DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp);
// BOOL __stdcall DestroyCursor(HCURSOR hCursor);
// int __stdcall GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);
// BOOL __stdcall ValidateRect(HWND hWnd, const RECT *lpRect);
// HDC __stdcall GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags);
// BOOL __stdcall LockWindowUpdate(HWND hWndLock);
// BOOL __stdcall SetKeyboardState(LPBYTE lpKeyState);
// BOOL __stdcall GetKeyboardState(PBYTE lpKeyState);
// int __stdcall GetWindowTextLengthW(HWND hWnd);
// HICON __stdcall CopyIcon(HICON hIcon);
// _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD); weak
void *__cdecl memset(void *Dst, int Val, size_t Size);
void __cdecl free(void *Memory);
// _DWORD __cdecl _unlock(_DWORD); weak
void __cdecl _lock(int a1);
int __cdecl _decode_pointer(int a1);
// int (*__usercall sub_6F77185C@<eax>(int (*result)(void)@<eax>, unsigned int a2))(void);
signed int __stdcall _CRT_INIT(int a1, int a2, int a3);
signed int __stdcall __CRT_INIT(int a1, int a2, int a3);
BOOL __stdcall _DllMainCRTStartup(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
int __stdcall HandleHotkey(HWND hWnd); // idb
int __stdcall DPCreateHandler(int, HWND hWndParent, int); // idb
signed int __stdcall InitIPAddr(HINSTANCE a1);
signed int __stdcall ListView_OnCreate(int a1, int a2);
signed int __stdcall InitPager(HINSTANCE a1);
BOOL __stdcall CNativeFont::_SetFontEnumProc(HWND hWnd, LPARAM a2);
signed int __stdcall InitNativeFontCtl(HINSTANCE a1);
void __cdecl _lock_file2(signed int a1, int a2);
int __cdecl _flushall();
signed int __cdecl sub_6F772EF9(int a1);
int __cdecl _fcloseall();
void __stdcall _ProcessDetach(int a1);
const WCHAR *__stdcall UnregisterClasses();
// void __cdecl _cexit();
HANDLE __termcon();
int __cdecl _fflush_nolock(FILE *File);
int __cdecl _flush(FILE *File); // idb
void __cdecl _unlock_file2(signed int a1, int a2);
volatile LONG *__cdecl __removelocaleref(volatile LONG *lpAddend);
// int __stdcall _freefls(void *Memory); idb
HDPA __stdcall DPA_Create(int cItemGrow);
HDPA __stdcall DPA_CreateEx(int cpGrow, HANDLE hheap);
LSTATUS __stdcall InitGlobalMetrics(int a1);
HGDIOBJ __stdcall InitGlobalColors();
HMODULE __stdcall InitIme();
signed int __cdecl _get_osplatform(int a1);
// int _encoded_null(void); weak
void *__cdecl calloc(size_t NumOfElements, size_t SizeOfElements);
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult);
void __cdecl __security_init_cookie();
int __cdecl _initp_misc_rand_s(int a1);
int __cdecl _initp_misc_initcrit(int a1);
// errno_t __cdecl strcpy_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// void *_MarkAllocaS(void *Ptr, unsigned int Marker);
// int __usercall sub_6F77504B@<eax>(int a1@<esi>);
signed int _mtinitlocks();
// _DWORD __cdecl __crtInitCritSecAndSpinCountEx(_DWORD, _DWORD); weak
int __cdecl __crtInitCritSecAndSpinCount(int a1, int a2);
signed int _mtinit();
int __cdecl _encode_pointer(int a1);
// int __cdecl __crtGetStringTypeA(int, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); idb
int __cdecl sub_6F775526(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); // idb
// signed int __usercall sub_6F77566A@<eax>(int a1@<esi>, int a2, int a3, int a4, signed int *a5);
int __cdecl _initterm_e(unsigned int a1, unsigned int a2);
signed int _ioinit();
signed int __initstdio();
LONG __cdecl __addlocaleref(volatile LONG *lpAddend);
// int _setenvp(void); weak
// int __initmbctable(void); weak
int __cdecl _initptd(int a1, int a2);
signed int _setargv();
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult);
// int __cdecl __crtLCMapStringA(int, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR, int cchDest, UINT CodePage, int); idb
int __cdecl sub_6F775F5E(int, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR, int cchDest, UINT CodePage, int); // idb
void __cdecl _freea(void *Memory);
signed int __stdcall _ProcessAttach(HINSTANCE a1);
BOOL __stdcall IsRunningIn16BitProcess();
// int __cdecl _ismbblead(unsigned int);
signed int __cdecl sub_6F776336(struct localeinfo_struct *a1, unsigned __int8 a2, int a3, unsigned __int8 a4);
_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *a2);
// int _getptd_noexit(void); weak
// int __set_flsgetvalue(void); weak
// _DWORD __cdecl _cinit(_DWORD); weak
BOOL _get_sse2_info();
signed int sub_6F776552();
// int _init_pointers(void); weak
LPVOID __cdecl _calloc_crt(size_t Size, int a2);
LPVOID __cdecl _calloc_impl(size_t Size, int a2, int a3);
void *__crtGetEnvironmentStringsA();
void *__cdecl malloc(size_t Size);
signed int __cdecl _heap_init(int a1);
signed int __heap_select();
signed int __cdecl _get_winmajor(int a1);
volatile LONG *__updatetmbcinfo();
int _getptd();
BOOL __stdcall IsSystemProcess();
LONG __stdcall CCDestroyWindow();
BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce);
LONG __stdcall CCCreateWindow();
int __stdcall ActivateModuleActCtx(ULONG_PTR *lpCookie); // idb
BOOL __stdcall GetModuleActCtx(int a1);
signed int __stdcall InitProgressClass(HINSTANCE a1);
// int _mtterm(void); weak
BOOL _heap_term();
void _mtdeletelocks();
void _ioterm();
int __stdcall ProgressWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall Progress_OnCreate(HWND hWnd, int); // idb
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult);
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult);
PVOID __stdcall DPA_GetPtr(HDPA hdpa, INT_PTR i);
int __stdcall DPA_InsertPtr(HDPA hdpa, int i, void *p);
BOOL __stdcall DPA_Destroy(HDPA hdpa);
BOOL __stdcall DPA_Grow(HDPA pdpa, int cp);
LPVOID __stdcall ControlAllocArray(HANDLE hHeap, int a2, int a3);
signed int __stdcall DXA_RoundUp(ULONG ulAugend, unsigned int a2, INT *piResult);
HRESULT UIntToInt(UINT uOperand, INT *piResult);
PVOID __stdcall DPA_DeletePtr(HDPA hdpa, int i);
BOOL __stdcall DPA_DeleteAllPtrs(HDPA hdpa);
void *__cdecl memmove(void *Dst, const void *Src, size_t Size);
void __stdcall DPA_DestroyCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData);
void __stdcall DPA_EnumCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData);
LPVOID __stdcall ControlReAllocArray(HANDLE hHeap, LPVOID lpMem, int a3, int a4);
int __stdcall DPA_Search(HDPA hdpa, void *pFind, int iStart, PFNDACOMPARE pfnCompare, LPARAM lParam, UINT options);
// void __usercall sub_6F777735(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
// void __usercall sub_6F777748(int a1@<ecx>, int a2@<edi>, int a3@<esi>);
int __stdcall HIMAGELIST_QueryInterface(struct _IMAGELIST *a1, const struct _GUID *a2, void **a3);
int __thiscall CImageListBase::IsValid(CImageListBase *__hidden this); // idb
LONG __stdcall CImageList::Release(int a1);
LONG __stdcall CImageList::Release(CImageList *this);
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3);
signed int __stdcall CImageList::QueryInterface(CImageList *this, const struct _GUID *a2, void **a3);
// unsigned __int32 __stdcall CImageList::AddRef(CImageList *this); idb
void __stdcall CImageList::_DeleteBitmap(HBITMAP ho); // idb
void __stdcall CImageList::SelectSrcBitmap(HBITMAP h); // idb
void __stdcall CImageList::SelectDstBitmap(HBITMAP h); // idb
signed int __stdcall CImageList::GetImageRect(CImageList *this, int a2, LPRECT lprc);
int __stdcall CImageList::Draw(HDC hdc, HDC hdcSrc);
HBITMAP __stdcall CreateMonoBitmap(int nWidth, int nHeight);
void __stdcall InitDitherBrush();
// BOOL __usercall sub_6F777CDC@<eax>(char a1@<al>, int a2@<edi>, struct _IMAGELIST *a3);
BOOL __stdcall ImageList_Destroy(HIMAGELIST himl);
void __thiscall CImageList::~CImageList(CImageList *this);
// void __thiscall CImageList::_Destroy(CImageList *__hidden this); idb
void *__thiscall CImageList::`scalar deleting destructor'(void *lpMem, char a2);
void __cdecl operator delete(void *lpMem); // idb
BOOL __stdcall TerminateDitherBrush();
void __stdcall CImageList::GlobalUninit(); // idb
void __stdcall ImageList_DeleteDragBitmaps(); // idb
int __stdcall TB_OnDestroy(HLOCAL hMem); // idb
HLOCAL __stdcall DestroyStrings(int a1);
int __stdcall ToolbarWndProc(HWND hWnd, UINT Msg, int, LPARAM lParam); // idb
COLORREF __stdcall FillRectClr(HDC hdc, RECT *lprect, COLORREF color);
int __stdcall MyNotifyWinEvent(int a1, int a2, int a3, int a4);
BOOL __stdcall ReleaseMonoDC(int a1);
int __stdcall TBGetImageList(int a1, int a2, int a3);
HLOCAL __stdcall CCLocalReAlloc(HLOCAL hMem, SIZE_T uBytes);
wchar_t *__stdcall Str_Set(int a1, LPCWSTR lpString);
HWND __stdcall CCSendNotify(int a1, int a2, LPARAM lParam);
unsigned int __stdcall CICustomDrawNotify(int a1, int a2, LPARAM lParam);
signed int __stdcall CCWndProc(int a1, int a2, unsigned int a3, int a4, int a5);
LRESULT __stdcall CIInitialize(int a1, WPARAM wParam, int a3);
signed int __thiscall CImageList::_ReAllocBitmaps(CImageList *this, int a2);
HBITMAP __thiscall CImageList::_CreateBitmap(CImageList *this, int, int); // idb
void *__cdecl operator new(SIZE_T dwBytes); // idb
int __thiscall CImageList::CImageList(int this);
// __int32 __stdcall ImageList_InitGlobals(); idb
int __stdcall CImageList::Create(int a1, int a2, unsigned int a3, int a4, int a5);
signed int __thiscall CImageList::Initialize(CImageList *this, int a2, int a3, unsigned int a4, int ulAugend, int pulResult);
unsigned __int32 __thiscall CImageList::_SetBkColor(CImageList *this, COLORREF color); // idb
int __stdcall CImageList::GlobalInit(); // idb
int __stdcall ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
signed int __stdcall CImageList::AddMasked(CImageList *this, HBITMAP h, unsigned __int32 color, int *a4);
signed int __thiscall CImageList::_AddMasked(CImageList *this, HBITMAP h, COLORREF color, int *a4);
int __thiscall CImageList::_Add(CImageList *this, HBITMAP h, HBITMAP a3, int a4, int x1, int y1, int *a7);
__int32 __thiscall CImageList::_Replace(CImageList *this, int, int, HBITMAP h, HBITMAP, int x1, int y1); // idb
void __thiscall CImageList::_ResetBkColor(CImageList *this, int, int, unsigned __int32); // idb
HIMAGELIST __stdcall ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
int __stdcall ImageList_CreateInstance(int a1, int a2, unsigned int a3, int a4, int a5, const struct _GUID *a6, void **a7);
int __stdcall TBSetImageList(int a1, int a2, signed int a3, int a4);
int __stdcall TBBuildImageList(HANDLE h); // idb
int __stdcall HeightWithString(int a1, int a2);
signed int __stdcall SetBitmapSize(int a1, int a2, int a3);
void __stdcall TB_OnSize(HDC hDC, int xRight, int yBottom);
signed int __stdcall CountRows(int a1);
void __stdcall TBAutoSize(HWND hWndTo);
void __stdcall NewSize(HWND hWnd, int cy, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall CheckMonoMask(int a1, int a2, int a3);
signed int __stdcall TBRecalc(int a1);
signed int __stdcall GrowToolbar(int a1, int a2, int a3, char a4);
int __stdcall TBInvalidateItemRects(int a1);
int __stdcall TBInitMetrics(int a1);
HFONT __stdcall TBChangeFont(int a1, int a2, HFONT a3);
signed int __stdcall InitToolbarClass(HINSTANCE a1);
int __stdcall TBReallocButtons(SIZE_T uBytes, int); // idb
int __stdcall TBInputStruct(int a1, int a2, int a3);
int __stdcall TBInsertButtons(SIZE_T uBytes, int, int, LPCWSTR lpString, int); // idb
int __stdcall TBOnButtonStructSize(int a1, int a2);
int __stdcall TBAddBitmapToImageList(HANDLE h, int); // idb
HBITMAP __stdcall _CopyBitmap(int a1, HGDIOBJ h, BITMAP *pbm);
__int32 __stdcall CImageList::SetBkColor(CImageList *this, COLORREF color, unsigned __int32 *); // idb
COLORREF __stdcall ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
unsigned __int32 __stdcall GetNearestColor32(HDC hdc, COLORREF color); // idb
int __stdcall AddBitmap(HANDLE h, SIZE_T uBytes, int, int); // idb
signed int __stdcall InitTrackBar(HINSTANCE a1);
signed int __stdcall InitStatusClass(HINSTANCE a1);
void __stdcall TBSetStyle(HWND hWndTo, int a2);
signed int __stdcall InitToolTipsClass(HINSTANCE a1);
HBITMAP __stdcall CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap, UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps);
unsigned int __stdcall MapToStandardBitmaps(unsigned int a1, unsigned int *a2, unsigned int a3);
int __stdcall TBAddStrings(int, HINSTANCE hInstance, void *Src); // idb
int __stdcall TB_StrForButton(int a1, int a2);
BOOL __stdcall TB_HasTopDDArrow(int a1, int a2);
HDC __stdcall TBPaint(HANDLE h, int a2);
int __stdcall DrawToolbarH(HDC hDC, HDC hdc, LPRECT lprc); // idb
// int __userpurge DrawButton@<eax>(int a1@<ebx>, HDC a2, int xLeft, int yTop, HDC hDC, int a6, int a7);
BOOL __stdcall TB_HasDDArrow(int a1, int a2);
int __stdcall DrawFace(HDC hdc, int, int, LPCWSTR lpchText, int, int, int, int); // idb
BOOL __stdcall ImageList_DrawIndirect(IMAGELISTDRAWPARAMS *pimldp);
signed int __stdcall TBIsHotTrack(int a1, int a2, char a3);
signed int __stdcall StateFromCDIS(__int16 a1);
int __stdcall TBShouldDrawButton(int, RECT *lprect, HDC hdc); // idb
int __stdcall InitTBDrawItem(int, int, int, int, int, int xRight, int yBottom); // idb
signed int __stdcall CDISFromState(char a1);
// int __userpurge TBWidthOfButton@<eax>(int a1@<ebx>, HDC hDC, int a3, HDC hdc);
int __stdcall TBDDArrowAdjustment(HDC hDC, int); // idb
int __stdcall TB_OnEraseBkgnd(int, WPARAM wParam); // idb
void __stdcall FlushToolTipsMgrNow(HDC hDC);
int __stdcall PatB(HDC hdc, int, int, int, int, COLORREF color); // idb
int __stdcall DrawBlankButton(HDC hdc, int, int, int, int, int); // idb
int __stdcall DrawString(HDC hdc, int xLeft, int yTop, int, int, LPCWSTR lpchText, int, int); // idb
int __stdcall TBGetDrawTextFlags(int a1, int a2, int a3);
int __stdcall CCGetUIState(int a1);
int __stdcall CCDrawEdge(HDC hdc, RECT *lprcSrc, int, int, int); // idb
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
HLOCAL __stdcall FreeProducedString(HLOCAL hMem);
LPCSTR __stdcall ProduceWFromA(UINT CodePage, LPCSTR lpMultiByteStr);
int __stdcall TBOutputStruct(int, int, void *Dst); // idb
int __stdcall StatusWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall SBSetText(int, int, LPCWSTR lpString); // idb
int __stdcall SetStatusText(int, int, int, LPCWSTR lpString); // idb
int __stdcall PaintStatusWnd(int a1, HDC a2, int a3, int a4, int a5);
int __stdcall DrawStatusTextEx(int, HDC hdc, int, int, int, int); // idb
int __stdcall MGetTextExtent(HDC hdc, LPCWSTR lpString, int c, int, int); // idb
UINT __stdcall GetCodePageForFont(HANDLE h);
signed int __stdcall TV_Init(HINSTANCE a1);
signed int __stdcall Tab_Init(HINSTANCE a1);
int __stdcall StrCmpICW(int a1, int a2);
LPWSTR __stdcall StrChrW(LPCWSTR lpStart, WORD wMatch);
LRESULT __stdcall NewFont(HDC hDC, HGDIOBJ h, int a3);
void __stdcall GetNewMetrics(int a1, HDC hdc, HGDIOBJ h);
BOOL __stdcall ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy);
int __stdcall ImageList_GetImageCount(HIMAGELIST himl);
__int32 __stdcall CImageList::GetImageCount(CImageList *this, int *); // idb
BOOL __stdcall ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo);
BOOL __stdcall ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
signed int __stdcall CImageList::GetIconSize(CImageList *this, int *a2, int *a3);
signed int __thiscall CImageList::_SetOverlayImage(CImageList *this, SIZE_T uBytes, int a3);
int __stdcall CImageList::GetImageInfo(CImageList *this, int a2, struct _IMAGEINFO *a3);
HIMAGELIST __stdcall ImageList_Duplicate(HIMAGELIST himl);
BOOL __stdcall ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);
HIMAGELIST __stdcall ImageList_Read(struct IStream *pstm);
int __stdcall Stream_ReadBitmap(struct IStream *a1, UINT start, HBITMAP *a3);
int __stdcall CImageList::Clone(HGDIOBJ h, const struct _GUID *a2, void **a3);
HBITMAP __stdcall CImageList::_CopyBitmap(HBITMAP h, HDC hdc);
signed int __stdcall CImageList::Load(CImageList *this, struct IStream *a2);
signed int __thiscall CImageList::_Read(CImageList *this, const struct _ILFILEHEADER *a2, HBITMAP h, HBITMAP ho);
void *__cdecl sub_6F77E492(void *Dst, int Val, size_t Size);
int __cdecl _VEC_memzero(int a1, int a2, int a3);
void __cdecl sub_6F77E4FC(int a1, unsigned int a2);
HLOCAL __stdcall PrivateLocalReAllocArray(HLOCAL hMem, int a2, int a3);
PVOID __stdcall DSA_GetItemPtr(HDSA hdsa, int i);
// int __stdcall Alloc(SIZE_T uBytes); idb
HDSA __stdcall DSA_Create(int cbItem, int cItemGrow);
int __stdcall DSA_InsertItem(HDSA hdsa, int i, const void *pitem);
BOOL __stdcall DSA_Destroy(HDSA hdsa);
int __stdcall Free(HLOCAL hMem); // idb
HRESULT __stdcall StringCbCopyW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc);
// signed int __userpurge sub_6F77E766@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5);
int __stdcall RegisterClassNameW(LPCWSTR lpString2); // idb
void __cdecl sub_6F77E818(int a1, int a2, unsigned int a3);
void *__cdecl sub_6F77E8C0(void *Dst, const void *Src, size_t Size);
int __cdecl _VEC_memcpy(int a1, int a2, unsigned int a3);
LPARAM __stdcall ReBarWndProc(HWND a1, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall TB_GetItemRect(HDC hDC, int, int); // idb
int __stdcall TBHeightOfButton(int a1, int a2);
signed int __stdcall InitReBarClass(HINSTANCE a1);
signed int __stdcall InitComboExClass(HINSTANCE a1);
int __stdcall TB_CalcItemRects(HDC hDC); // idb
signed int __stdcall PositionFromID(int a1, int a2);
COLORREF __stdcall RBB_GetBkColor(int a1, int a2);
COLORREF __stdcall RBB_GetTextColor(int a1, int a2);
int __stdcall RBEraseBkgnd(HDC hdcSrc, HDC hdc, int); // idb
COLORREF __stdcall RB_GetBkColor(int a1);
int __stdcall CCForwardEraseBackground(HWND hWnd, HDC hdc); // idb
int __stdcall TB_HasSplitDDArrow(int a1, int a2);
int __stdcall RBPaint(int a1, HDC a2);
COLORREF __stdcall RBDrawBand(int a1, int a2, HDC hdc);
int __stdcall FlipRect(int a1);
int __stdcall RBGetRowCount(int a1);
unsigned int __stdcall RBGetFirstInRow(int a1, unsigned int a2);
int __stdcall RBGetLastInRow(int a1, unsigned int a2, int a3);
int __stdcall RBSizeBandsToRect(int a1, int a2);
int __stdcall RBSetRedraw(int a1, int a2);
int __stdcall RBSizeBarToRect(int a1, int a2);
int __stdcall RBSizeDifference(int a1, int a2);
int __stdcall RBGetRowHeight(int a1, unsigned int a2);
int __stdcall RBGetLineHeight(int a1, unsigned int a2, int a3);
int __stdcall RBBGetHeight(int a1, int a2);
void __stdcall RBSizeBandsToRowHeight(int a1);
void __stdcall RBSizeBandToRowHeight(int a1, unsigned int a2, int a3);
int __stdcall RBInvalidateRect(int, RECT *lprcSrc); // idb
HLOCAL __stdcall RBReallocBands(int a1, int a2);
unsigned int __stdcall RBGetNext(int a1, unsigned int a2, int a3);
unsigned int __stdcall RBEnumBand(int a1, int a2, int a3);
void __stdcall RBResize(int a1, int a2);
signed int __stdcall RBGetBandInfo(int a1, unsigned int a2, int a3);
void __stdcall RBAutoSize(int a1);
int __stdcall RBRecalc(int a1);
signed int __stdcall RBIDToIndex(int a1, unsigned __int16 a2);
HWND __stdcall RBSendNotify(int a1, int a2, int a3);
int __stdcall RBSetRecalc(int a1, int a2);
int __stdcall RBDestroy(HLOCAL hMem); // idb
void *__stdcall RBSetPalette(int a1, void *a2);
signed int __stdcall RBDeleteBand(int a1, int a2);
signed int __stdcall RBRecalcFirst(int a1, int a2, unsigned int a3);
void __stdcall RBInitPaletteHack(int a1);
int __stdcall InvalidateButton(HDC hDC, int, BOOL bErase); // idb
HWND __stdcall SendNotifyEx(int a1, HWND hWnd, int a3, LPARAM lParam, int a5);
int __stdcall _RBBandWidth(int a1, int a2);
int __stdcall RBValidateBandInfo(int, void *Dst); // idb
signed int __stdcall RBSetBarInfo(int a1, int a2);
int __stdcall WrapToolbar(HDC hDC, int, int, int); // idb
signed int __stdcall RBBandsAtMinHeight(unsigned int a1);
int __stdcall RBResizeChildren(int a1);
signed int __stdcall RBSetBandInfo(int a1, unsigned int a2, int a3, int a4);
void __stdcall RBResizeNow(int a1);
HDC __stdcall RBOnSetFont(int a1, int a2);
HDC __stdcall RBAfterSetFont(int a1);
int __stdcall RBBCalcTextExtent(int, HGDIOBJ h, int); // idb
signed int __stdcall RBInsertBand(int pulResult, unsigned int a2, unsigned int a3);
int __stdcall RBCountBands(int a1, int a2);
int __stdcall RBRecalcChevron(int a1, int a2, int a3);
LRESULT __stdcall CIHandleNotifyFormat(int a1, int a2);
HFONT __stdcall TBSetFont(int a1, HFONT a2, int a3);
int __stdcall BoxIt(HDC hDC, int, int, LPRECT lpRect); // idb
signed int __stdcall TBGetMaxSize(int a1, int a2);
int __stdcall RBGetRowHeightExtra(int a1, unsigned int *a2, int a3);
unsigned int __stdcall RBBNextVisible(int a1, unsigned int a2);
int __stdcall RBBCalcMinWidth(int a1, int a2);
BOOL __stdcall RBShouldDrawGripper(int a1, int a2);
void __stdcall RBOnStyleChanged(int a1, int a2, int a3);
void __stdcall CalcTabHeight(int cy, HDC hdc);
int __stdcall UpdateToolTipRects(int a1);
int __stdcall Tab_OnAdjustRect(int, int, LPRECT lprc); // idb
void __stdcall TV_GetBackgroundBrush(int a1, WPARAM wParam);
signed int __stdcall TV_CalcScrollBars(int a1);
UINT __stdcall TV_WndProc(HWND hWnd, UINT Msg, HDC hdc, LPARAM lParam);
int __stdcall Tab_VDFlipRect(int a1, int a2);
int __stdcall Tab_DFlipRect(int a1, int a2);
int __stdcall Tab_WndProc(HWND hWnd, HGLOBAL hMem, INT_PTR i, SIZE_T dwBytes); // idb
int __stdcall Tab_Size(INT_PTR i);
int __stdcall Tab_UpdateArrows(INT_PTR i, int); // idb
int __stdcall Tab_GetClientRect(int, LPRECT lpRect); // idb
int __stdcall Tab_DVFlipRect(int a1, int a2);
int __stdcall Tab_VFlipRect(int a1, int a2);
int __stdcall CalcPaintMetrics(int, HDC hDC); // idb
signed int __stdcall TV_SizeWnd(int a1, LONG a2, unsigned int a3);
int __stdcall TV_InvalidateInsertMarkRect(int, BOOL bErase); // idb
signed int __stdcall TV_GetInsertMarkRect(int a1, int a2);
int __stdcall Tab_GetTextExtentPoint(int, int, LPCWSTR lpString, LPSIZE lpsz); // idb
int __stdcall StripAccelerators(int a1, int a2, int a3);
signed int __stdcall TV_ScrollBarsAfterSetWidth(int a1, int a2);
int __stdcall TV_RecomputeMaxWidth(int a1);
unsigned int __stdcall TreeView_BeginFakeCustomDraw(int a1, LPARAM lParam);
unsigned int __stdcall CIFakeCustomDrawNotify(int a1, int a2, LPARAM lParam);
int __stdcall TV_RecomputeItemWidths(int a1);
int __stdcall TreeView_EndFakeCustomDraw(LPARAM lParam); // idb
__int32 __stdcall CImageList::GetBkColor(CImageList *this, unsigned __int32 *); // idb
int __stdcall TV_GetNextItem(int a1, int a2, int a3);
signed int __stdcall ValidateTreeItem(int a1, int a2);
void *__stdcall TV_OnGetItemA(int a1, int a2);
signed int __stdcall TV_OnGetItem(int a1, int a2);
void __stdcall TV_GetItem(int a1, int a2, char a3, int a4);
signed int __stdcall TV_SelectItem(int a1, int a2, int a3, char a4, int a5);
COLORREF __stdcall ImageList_GetBkColor(HIMAGELIST himl);
int __stdcall TV_SetLeft(int, int nPos); // idb
// int __userpurge sub_6F784564@<eax>(int _EAX@<eax>, int a2@<ebx>, int a3@<ebp>, HDC a4, int a5);
int __stdcall TV_SetIndent(HDC hdc, int); // idb
HGLOBAL __stdcall ThunkItemAtoW(int a1, int a2);
int __stdcall TV_DrawPlusMinus(HDC hdc, int x, int y, int, HGDIOBJ h, HGDIOBJ, HGDIOBJ, int); // idb
BOOL __stdcall TV_DeleteHotFonts(int a1);
HBITMAP __stdcall CreateColorBitmap(int a1, int cy);
signed int __stdcall CImageList::SetOverlayImage(CImageList *this, SIZE_T uBytes, int a3);
BOOL __stdcall ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);
HGDIOBJ __stdcall TV_CreateIndentBmps(HDC hdc);
int __stdcall TV_DrawDottedLine(HDC hdc, int x, int y, int, int); // idb
int __stdcall FreeItemW(HGLOBAL hMem); // idb
int __stdcall Tab_OnInsertItem(INT_PTR, int i, int); // idb
void __stdcall Tab_StyleChanged(INT_PTR i, int a2, int a3);
LRESULT __stdcall TV_OnSetFont(HDC hdc, UINT fWinIni, int a3);
int __stdcall TV_SetItemHeight(HDC hdc); // idb
int __stdcall TV_SetImageList(HDC hdc, HIMAGELIST himl, int cy); // idb
int __stdcall TV_OnCreate(HWND hWnd, int); // idb
LPVOID __stdcall TV_CreateRoot(int a1);
signed int __stdcall Tab_OnCreate(int a1);
HIMC __stdcall ImmAssociateContext(HWND, HIMC);
int __stdcall Tab_CreateItem(int a1, int a2);
HRESULT UIntSub(UINT uMinuend, UINT uSubtrahend, UINT *puResult);
int __stdcall Tab_OnSetFont(int, HANDLE h, int); // idb
int __stdcall RedrawAll(INT_PTR i, UINT flags); // idb
HIMAGELIST __stdcall ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
HIMAGELIST __stdcall ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
int __stdcall PrivateLocalAllocArray(unsigned int a1, unsigned int a2);
int __stdcall SmoothScrollWindow(int dy); // idb
int __stdcall TV_GetPrevVisItem(int a1);
int __stdcall ITEM_OFFSET(int a1, int a2);
int __stdcall TV_StartWatch(int, void *p, int); // idb
int __stdcall RefreshArrows(int, HDC hdc); // idb
int __stdcall TreeView_EndFakeItemDraw(LPARAM lParam); // idb
LONG __stdcall TV_GetItemTextWidth(HDC hdc, int a2, int a3);
int __stdcall TV_HorzScroll(int, int, int nPos); // idb
int __stdcall TV_DefCompare(LPCWSTR *a1, LPCWSTR *a2, int a3);
int __stdcall TV_ScrollVertIntoView(int a1, int a2);
BOOL __stdcall ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle);
int __stdcall TV_ScrollBelow(int a1, int a2, int a3, int a4);
void __stdcall TV_InvalidateItem(int a1, int a2, UINT flags);
signed int __stdcall TV_GetItemRect(int a1, int a2, int a3, int a4);
int __stdcall TV_SortCB(int a1, LPARAM a2, int a3, int (__stdcall *a4)(void *p1, void *p2, LPARAM lParam));
int __stdcall TV_EnsureVisible(int a1, signed int a2);
int __stdcall TV_ScrollIntoView(int a1, int a2);
int __stdcall TV_CountKids(int a1);
int __stdcall TV_GetNextVisItem(int a1);
signed int __stdcall TV_IsShowing(int a1);
int __stdcall TV_DrawItem(int, int, int, int, int y, int); // idb
LPCSTR __stdcall TV_InsertItemA(LRESULT a1, int a2);
int __stdcall TreeView_BeginFakeItemDraw(LPARAM lParam, int); // idb
signed int __stdcall TV_UpdateShownIndexes(int a1, int a2);
signed int __stdcall TV_ScrollBarsAfterAdd(int a1, int a2);
__int16 __stdcall TV_ComputeItemWidth(int a1, int a2, HDC a3);
void __stdcall TV_Paint(int y, HDC hdc);
void __stdcall TV_DrawTree(int y, HDC hdc, int a3, int a4);
HWND __stdcall TV_SendSelChange(int a1, int a2, int a3, int a4, int a5);
// _DWORD __stdcall TV_ScrollBarsAfterExpand(_DWORD, _DWORD); weak
signed int __stdcall TV_ScrollBarsAfterExpandCollapse(int a1, int a2, int a3);
signed int __stdcall TV_ExpandParents(int a1, signed int a2, signed int a3);
signed int __stdcall TV_Expand(int a1, unsigned int a2, int a3, signed int a4);
HWND __stdcall TV_SendItemExpand(int a1, int a2, int a3, char a4);
signed int __stdcall TV_EndWatch(int a1, int a2);
int __stdcall TV_CountVisibleDescendants(int a1);
int __stdcall TV_InsertItem(LRESULT a1, int a2);
signed int __stdcall TV_SetItem(int a1, int a2);
HWND __stdcall Tab_Paint(int cy, int a2);
int __stdcall Tab_DrawItemFrame(int, HDC hdc, HGDIOBJ h, RECT *lprcSrc, HGDIOBJ ho); // idb
int __stdcall DoCorners(HDC hdc, int, int, int); // idb
int __stdcall Tab_DrawEdge(HDC hdc, int, UINT edge, UINT grfFlags, int); // idb
int __stdcall VertDrawEdge(HDC hdc, int, UINT edge, UINT grfFlags, int); // idb
BOOL __stdcall TV_ShouldItemDrawGray(int a1, int a2, char a3);
BOOL __stdcall TV_ShouldItemDrawBlue(int a1, int a2, char a3);
BOOL __stdcall DPA_Sort(HDPA hdpa, PFNDACOMPARE pfnCompare, LPARAM lParam);
int __stdcall DPA_MergeSort(int a1);
int __stdcall DPA_MergeSort2(int a1, int a2, signed int a3);
void __stdcall TV_OnStyleChanged(HDC hdc, int a2, int a3);
signed int __stdcall TV_DismissEdit(int a1, signed int a2);
BOOL __stdcall TV_CancelEditTimer(int a1);
signed int __stdcall TV_SetItemA(int a1, int a2);
int __stdcall TV_SortChildren(int a1, int a2, int a3);
int __stdcall DrawBody(HDC hdc, int cy, int, int, int, WPARAM wParam, UINT options, int); // idb
int __stdcall Tab_ExtTextOut(HDC hdc, int x, int y, UINT options, int, LPCWSTR lpString, UINT c, INT *lpDx, int); // idb
signed int __stdcall TV_ScrollItems(int a1, int a2, int a3, int a4);
signed int __stdcall TV_UpdateToolTip(int a1);
int __stdcall TV_SmoothSetTopItem(int, int nPos, int); // idb
int __stdcall TV_GetShownIndexItem(int a1, unsigned int a2);
HFONT __stdcall TV_CreateBoldFont(int a1);
void __stdcall RecalcTooltipRects(int a1);
int __stdcall CreateMask(int, int yTop, int w, int h, int, LPCWSTR lpchText); // idb
signed int __stdcall InitAnimateClass(HINSTANCE a1);
signed int __stdcall InitHotKeyClass(HINSTANCE a1);
signed int __stdcall ListView_Init(HINSTANCE a1);
signed int __stdcall CCDllGetVersion(int a1);
int __stdcall DeleteButton(HDC hDC, int); // idb
int __stdcall SetStatusParts(SIZE_T uBytes, int, size_t cchDest); // idb
LRESULT __stdcall StatusUpdateToolTips(int a1);
void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
HFONT __stdcall CCCreateStatusFont();
int __stdcall InitStatusWnd(HWND hWnd, int); // idb
int __stdcall SBSetBorders(int a1, int a2);
int __stdcall SBSetFont(HDC hDC, HGDIOBJ h, int); // idb
signed int __stdcall InitUpDownClass(HINSTANCE a1);
signed int __stdcall InitDateClasses(HINSTANCE a1);
signed int __stdcall Header_Init(HINSTANCE a1);
HANDLE __stdcall FastGetSubclassHeader(HWND hWnd);
HANDLE __thiscall GetSubclassHeader(DWORD this, HWND hWnd);
int __stdcall SetSubclassHeader(HWND hWnd, HANDLE hData, int); // idb
int __stdcall FindCallRecord(int a1, int a2, int a3);
BOOL __stdcall DPA_SetPtr(HDPA hdpa, int i, void *p);
BOOL __stdcall Str_SetPtrW(LPWSTR *ppsz, LPCWSTR psz);
LONG __stdcall GetWindowProc(HWND hWnd);
unsigned int __stdcall PurgeSingleCallNode(int a1, int a2);
BOOL __stdcall RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass);
void __stdcall CompactSubclassHeader(HWND hWnd, HLOCAL hMem);
void __stdcall DetachSubclassHeader(HWND hWnd, HLOCAL hMem, int a3);
HLOCAL __stdcall FreeSubclassHeader(HWND hWnd, HLOCAL hMem);
BOOL __stdcall DSA_DeleteItem(HDSA hdsa, int i);
void __stdcall DSA_DestroyCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData);
void __stdcall DSA_EnumCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData);
HDPA __stdcall DPA_Clone(const HDPA hdpa, HDPA hdpaNew);
LRESULT __stdcall CallOriginalWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int a5, WNDPROC lpPrevWndFunc);
int __stdcall LeaveSubclassFrame(int a1);
int __stdcall EnterSubclassCallback(int a1, int a2, int a3);
int __stdcall EnterSubclassFrame(int a1, int a2);
int __stdcall UpdateDeepestCall(int a1);
LRESULT __stdcall MasterSubclassProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int __stdcall CallNextSubclassProc(int a1, int a2, int a3, int a4, int a5);
int __stdcall LeaveSubclassCallback(int a1, int a2);
BOOL __stdcall SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
HANDLE __stdcall AttachSubclassHeader(HWND hWnd);
HLOCAL __stdcall ReAllocSubclassHeader(HWND hWnd, HLOCAL hMem, int a3);
int __cdecl _local_unwind4(int a1, int a2, unsigned int a3);
signed int __cdecl sub_6F78AC8B(int a1, int a2, int a3, int a4);
int __thiscall _EH4_CallFilterFunc(void *this);
int __thiscall _EH4_TransferToHandler(void *this);
void __thiscall _EH4_GlobalUnwind(PVOID TargetFrame);
int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, int a4);
_DWORD __cdecl _NLG_Notify(_DWORD); // weak
int __thiscall _NLG_Call(_DWORD); // weak
int __far nullsub_1(); // weak
// void __userpurge sub_6F78E7ED(int a1@<ebx>, int a2@<ebp>, int a3@<esi>, int a4, int a5, int a6, int a7);
// int __usercall sub_6F79151D@<eax>(int a1@<ebp>);
// void __userpurge sub_6F79152E(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6F791538@<eax>(int a1@<ebp>);
// void __userpurge sub_6F791549(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6F791559@<eax>(int a1@<ebp>);
// void __userpurge sub_6F79156A(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6F791590@<eax>(int a1@<ebp>);
// void __usercall sub_6F7915A1(int a1@<ebp>);
// int __usercall sub_6F7915C2@<eax>(int a1@<ebp>);
// void __usercall sub_6F7915D3(int a1@<ebp>);
// int __usercall sub_6F791601@<eax>(int a1@<ebp>);
// void __userpurge sub_6F791612(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6F791622@<eax>(int a1@<ebp>);
// void __userpurge sub_6F791633(int a1@<ebp>, int a2, int a3, int a4);
// int __usercall sub_6F79166C@<eax>(int a1@<ebp>);
// void __userpurge sub_6F79167D(int a1@<ebp>, int a2, int a3, int a4);
int _purecall();
HINSTANCE __stdcall PrivLoadOleLibrary(); // idb
int __stdcall PrivFreeOleLibrary(HINSTANCE); // idb
int __stdcall PrivCoInitialize(HINSTANCE hModule);
void __stdcall PrivCoUninitialize(HINSTANCE hModule); // idb
int __stdcall PrivRegisterDragDrop(HINSTANCE hModule, HWND a2, struct IDropTarget *a3);
int __stdcall PrivRevokeDragDrop(HINSTANCE hModule, HWND a2);
int __stdcall _mymemcmp(const char *a1, const char *a2, int a3);
int __stdcall MRUIsSameData(int a1, int a2, const char *a3, int a4);
int __stdcall CreateMRUListLazyW(DWORD cbData, int, int, int); // idb
int __stdcall CreateMRUListW(DWORD cbData); // idb
void __stdcall FreeMRUList(HLOCAL hMem);
int __stdcall FindMRUData(int a1, const char *a2, int a3, int a4);
int __stdcall CreateMRUListLazyA(int a1, int a2, int a3, int a4);
int __stdcall CreateMRUListA(int a1);
int __stdcall FindMRUStringW(int, LPCWSTR lpWideCharStr, int); // idb
int __stdcall FindMRUStringA(int, LPCSTR lpMultiByteStr, int); // idb
int __stdcall AddMRUStringW(int ValueName, LPCWSTR psz);
int __stdcall AddMRUStringA(int ValueName, LPCSTR lpMultiByteStr);
signed int __stdcall DelMRUString(int a1, int a2);
int __stdcall AddMRUData(int wMatch, void *Src, size_t Size);
size_t __stdcall EnumMRUListW(int a1, int a2, void *Dst, size_t Size);
int __stdcall EnumMRUListA(SIZE_T uBytes, int, LPSTR lpMultiByteStr, int cbMultiByte); // idb
int __stdcall ReAlloc(HLOCAL hMem, SIZE_T uBytes); // idb
SIZE_T __stdcall GetSize(HLOCAL hMem);
// _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD); weak
HLOCAL __stdcall CCLocalReAllocArray_TCHAR(HLOCAL hMem, int a2);
HLOCAL __stdcall CCLocalReAllocArray_TOOLINFO(HLOCAL hMem, int a2);
int __stdcall CheckForDragBegin(HWND hWndFrom, int, int); // idb
int __stdcall StrToIntW(LPCWSTR lpSrc);
LRESULT __stdcall RelayToToolTips(HWND hWnd, int a2, int a3, int a4, int a5);
BOOL __stdcall IsISearchTimedOut(int a1);
int __stdcall GetIncrementSearchStringA(int, UINT CodePage, LPSTR lpMultiByteStr); // idb
BOOL __stdcall IncrementSearchBeep(int a1);
int __stdcall ScrollShrinkRect(int a1, int a2, int a3);
int __stdcall CCSwapKeys(int a1, int a2, int a3);
int __stdcall RTLSwapLeftRightArrows(int a1, int a2);
int __stdcall CCGetHotFont(HANDLE h, int); // idb
int __stdcall GetMessagePosClient(HWND hWnd, LPPOINT lpPoint); // idb
HWND __stdcall GetDlgItemRect(HWND hDlg, int nIDDlgItem, LPRECT lpRect);
LONG __stdcall SetWindowBits(HWND hWnd, int nIndex, int a3, int a4);
int __stdcall CCInvalidateFrame(HWND hWnd); // idb
int __stdcall FlipPoint(int a1);
int __stdcall CCSetInfoTipWidth(HWND hWnd, HWND); // idb
HDC __stdcall MirrorBitmapInDC(HDC hdc, HANDLE h);
BOOL __stdcall CCOnUIState(int a1, int a2, unsigned int a3, int a4);
HDWP __stdcall SafeDeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int a6, int cy, UINT uFlags);
int __stdcall StrToIntA(LPCSTR lpSrc);
int __stdcall IncrementSearchImeCompStr(SIZE_T uBytes, int, int, int); // idb
signed int __stdcall IncrementSearchString(int pulResult, int a2, int a3);
signed int __stdcall CCNotifyNavigationKeyUsage(int a1, unsigned __int16 a2);
HRESULT __stdcall StringCchCopyA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszSrc);
HRESULT StringCchPrintfW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszFormat, ...);
int __stdcall GetIncrementSearchString(int, STRSAFE_LPWSTR pszDest); // idb
STRSAFE_LPCWSTR __stdcall CCReturnDispInfoText(STRSAFE_LPCWSTR pszSrc, STRSAFE_LPWSTR pszDest, size_t cchDest);
void __stdcall CCPlaySound(LPCWSTR lpString);
LPWSTR __stdcall StrDupW(LPCWSTR lpSrch);
LPSTR __stdcall StrDupA(LPCSTR lpSrch);
int __stdcall CallPropertyPageCallback(int a1, int a2);
BOOL __stdcall DestroyPropertySheetPage(HPROPSHEETPAGE);
int __stdcall EditPropSheetTemplate(int a1, int a2, char a3);
HWND __stdcall CreatePage(void *Src, HWND hWndParent);
// int __stdcall StrDup_AtoW(LPCSTR lpMultiByteStr); idb
signed int __stdcall RethunkShadowStrings(int a1);
LPCDLGTEMPLATEA __stdcall _CreatePageDialog(int a1, int a2, HWND hWndParent, LPCDLGTEMPLATEA lpTemplate);
LPCDLGTEMPLATEA __stdcall _CreatePage(int a1, void *Src, HWND hWndParent, HGLOBAL hResData);
int __stdcall AllocPropertySheetPage(SIZE_T uBytes); // idb
int __stdcall _CreatePropertySheetPage(void *Src, int, int); // idb
HPROPSHEETPAGE __stdcall CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
HPROPSHEETPAGE __stdcall CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
void *__stdcall _Hijaak95Hack(int a1, void *Src);
int __stdcall GetPageInfoEx(int, int, void *Dst, WORD wLanguage, char); // idb
int __stdcall _SetHeaderFonts(HWND hWnd, int); // idb
int __stdcall _WriteHeaderTitle(int, HDC hdc, int, LPCWSTR lpString, int, UINT format); // idb
int __stdcall _ComputeHeaderHeight(HGDIOBJ h, int); // idb
int __stdcall MoveAllButtons(HWND hDlg, int, int, int, int); // idb
int __stdcall RemoveButton(HWND hDlg, int nIDDlgItem, HWND hWnd); // idb
HPALETTE __stdcall PaletteFromBmp(HGDIOBJ h);
LONG __stdcall GetCharDimensions(HDC hdc, LPSIZE psizl);
LRESULT __stdcall Prsht_ButtonSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall Prsht_SubclassButton(HWND hDlg, int nIDDlgItem); // idb
int __stdcall Prsht_GetIdealPageSize(int a1, int a2, char a3);
int __stdcall _Ppd_GetPage(int, WPARAM wParam); // idb
int __stdcall _Ppd_IsPageHidden(int, WPARAM wParam); // idb
HWND __stdcall _Ppd_SendNotify(int a1, WPARAM wParam, int a3, int a4);
int __stdcall FindPageIndex(int a1, int a2, int a3, int a4);
int __stdcall FindPageIndexByHpage(int a1, int a2);
HWND __stdcall PageChanging(int a1);
LRESULT __stdcall SendLastChanceApply(int a1);
LRESULT __stdcall ResetWizButtons(int a1);
LRESULT __stdcall SetWizButtons(int a1, unsigned int a2);
LRESULT __stdcall FindItem(HWND hWnd, int a2, LPARAM lParam);
WPARAM __stdcall PageInfoChange(int a1, int a2);
WPARAM __stdcall PageInfoUnChange(int a1, int a2);
HDWP __stdcall Prsht_RepositionControl(int a1, HWND hWnd, HDWP hWinPosInfo, int a4, int a5, int a6, int a7);
int __stdcall Prsht_ResizeDialog(int, int, int, HDWP hWinPosInfo); // idb
int __stdcall Prsht_RecalcPageSizes(int a1);
void *__stdcall RemovePropPageData(int a1, WPARAM wParam);
LRESULT __stdcall QuerySiblings(int a1, WPARAM wParam, LPARAM lParam);
int __stdcall Prsht_GetObject(void *Src, HWND hWndParent, WPARAM wParam, int, int); // idb
int __stdcall HandlePaletteChange(int, int, HWND hWnd); // idb
HGDIOBJ __stdcall PaintWithPaletteBrush(HDC hdc, RECT *lprc, HPALETTE hPal, HGDIOBJ h);
int __stdcall PaintWithPaletteBitmap(HDC hdc, int wDest, HPALETTE hPal, HANDLE h); // idb
void __stdcall _SetHeaderTitles(HWND hWnd, int a2, int a3, HLOCAL hMem, int a5);
int __stdcall PropSheetPaintHeader(int, int, HWND hWnd, HDC hdc); // idb
HLOCAL __stdcall Prsht_FreeTitle(int a1);
int __stdcall Prsht_EraseWizBkgnd(int, HDC hDC); // idb
LRESULT __stdcall WizardWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
BOOL __stdcall EnumResLangProc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam);
signed int __stdcall GetPageLanguage(int a1, int a2);
HRSRC __stdcall FindResourceExRetry(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);
// int __stdcall FontEnumProc(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM); idb
UINT __stdcall GetDefaultCharsetFromLang(signed int a1);
__int16 __stdcall GetShellResourceLangID();
int __stdcall CCLoadStringExInternal(HMODULE hModule, int, void *Dst, int, WORD wLanguage); // idb
signed int __stdcall ShouldUseMSShellDlg2Font(int a1);
int __stdcall Prsht_GetOverrideState(int a1);
int __stdcall Prsht_GetType(int, WORD wLanguage); // idb
int __stdcall Prsht_GetAction(unsigned int a1, unsigned int a2, unsigned int a3);
void __stdcall Prsht_PrepareTemplate(void *Src, HMODULE hModule, int a3, int a4, LPCSTR lpName, int a6, int a7);
// int __userpurge sub_6F796E38@<eax>(int a1@<eax>, __int16 a2@<dx>, int a3@<edi>, int a4, int a5);
int __stdcall CreateProxyPage(int a1, int a2);
BOOL __stdcall DestroyPropsheetPageArray(int a1);
signed int __stdcall CopyPropertyPageStrings(int a1, int (__stdcall *a2)(_DWORD));
HLOCAL __stdcall FreePropertyPageStrings(int a1);
int __stdcall ThunkPropSheetHeaderAtoW(void *Src, void *Dst); // idb
HLOCAL __stdcall FreePropSheetHeaderW(int a1);
int __stdcall SetNewDefID(HWND hWnd); // idb
void __stdcall PageChange(DWORD_PTR dwRefData, int a2);
void *__stdcall RemovePropPage(DWORD_PTR dwRefData, int a2, WPARAM wParam);
int __stdcall PageSetSelection(DWORD_PTR dwRefData, WPARAM wParam, int, int); // idb
int __stdcall WizNextBack(DWORD_PTR dwRefData, int); // idb
int __stdcall Prop_IsDialogMessage(DWORD_PTR dwRefData, LPMSG lpMsg); // idb
int __stdcall NT5_GetUserDefaultUILanguage();
int __stdcall CCGetSystemDefaultThreadLocale(int a1);
int __stdcall CCLoadStringEx(int, void *Dst, int, WORD wLanguage); // idb
HGDIOBJ __stdcall GetPageFontMetrics(int a1, int a2);
LONG __stdcall Prsht_ComputeIdealPageSize(int a1, int a2, int a3);
int __stdcall InsertPropPage(int, int, void *Src); // idb
LPARAM __stdcall IsFontInstalled(int a1, STRSAFE_LPCWSTR pszSrc);
__int16 __stdcall GetAltFontLangId(int a1);
unsigned int __stdcall CCGetProperThreadLocale(int a1);
int __stdcall LocalizedLoadString(int, void *Dst, int); // idb
BOOL __stdcall _SetTitle(HWND a1, int a2);
void __stdcall InitPropSheetDlg(HWND hWnd, LONG dwNewLong);
int __stdcall ButtonPushed(DWORD_PTR dwRefData, int); // idb
int __stdcall Prsht_OnCommand(DWORD_PTR dwRefData, int nIDDlgItem, HWND hWnd, __int16); // idb
void __stdcall Prsht_OnSetTitle(int a1, char a2, int a3, int (__stdcall *a4)(_DWORD));
BOOL __stdcall PropSheetDlgProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall _RealPropertySheet(HWND hWnd); // idb
int __stdcall _PropertySheet(void *Src, int); // idb
INT_PTR __stdcall PropertySheetW(LPCPROPSHEETHEADERW);
INT_PTR __stdcall PropertySheetA(LPCPROPSHEETHEADERA);
signed int __stdcall Status_GetRect(int a1, int a2, int a3);
HWND __stdcall CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);
HWND __stdcall CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
int __stdcall GetStringInfo(int a1, int a2);
int __stdcall IndexFromPt(int, POINT pt); // idb
void __stdcall StatusForceCreateTooltips(int a1);
int __stdcall SBGetText(int, int, int, size_t cchDest, char); // idb
void __stdcall DrawStatusTextW(HDC hDC, LPCRECT lprc, LPCWSTR pszText, UINT uFlags);
void __stdcall DrawStatusTextA(HDC hDC, LPCRECT lprc, LPCSTR pszText, UINT uFlags);
int __stdcall TBMixedButtonHeight(int a1, int a2);
int __stdcall TBMixedButtonsHeight(int a1);
int __stdcall TBGetSepHeight(int a1, int *a2);
HWND __stdcall CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize);
HWND __stdcall CreateToolbar(HWND hwnd, int a2, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons);
COLORREF __stdcall TB_OnSysColorChange(int a1);
int __stdcall DrawInsertMark(HDC hdc, int, int, COLORREF color); // idb
int __stdcall TBIsRectClipped(int, RECT *lprcSrc2); // idb
COLORREF __stdcall TB_GetInsertMarkColor(int a1);
int __stdcall WrapToolbarCol(int, int, LPRECT lprcDst, int); // idb
int __stdcall TBGetStringA(int, int, int cbMultiByte, LPSTR lpMultiByteStr); // idb
int __stdcall TBLoadImages(HANDLE h, int, int); // idb
signed int __stdcall ReplaceBitmap(int a1, unsigned int a2);
LRESULT __stdcall TB_OnSetCmdID(int a1, int a2, int a3);
int __stdcall GetAccelerator(LPCWSTR lpStart); // idb
int __stdcall TBButtonAccelerator(int a1, int a2);
int __stdcall TBHasAccelerator(int a1, int w2);
int __stdcall TBHasDupChar(int a1, int w2);
int __stdcall TBItemFromAccelerator(int, WORD w2, int); // idb
int __stdcall TBOnMapAccelerator(int, WORD w2, int); // idb
BOOL __stdcall GetUpdateRectEnumProc(HWND hWnd, LPARAM a2);
int __stdcall TB_TranslateAccelerator(int, MSG *lpMsg); // idb
int __stdcall TB_CalcHeight(int a1);
int __stdcall TBGetItem(int, int, LPARAM lParam); // idb
int __stdcall TBGetInfoTip(int a1, int a2, int a3);
LONG __stdcall TBWidthOfString(HDC hDC, int a2, HDC hdc);
int __stdcall TBToggleDropDown(HDC hDC, int, int); // idb
int __stdcall TBInvalidateButton(HDC hDC, int, BOOL bErase); // idb
void __stdcall TBSetHotItem(HDC hDC, int a2, int a3);
int __stdcall GetInsertMarkRect(HDC hDC, int, int); // idb
int __stdcall TBInvalidateMark(HDC hDC); // idb
int __stdcall TBSetInsertMark(HDC hDC, int); // idb
void __stdcall TBCycleHotItem(HDC hDC, int a2, int a3, int a4);
int __stdcall TBHitTest(HDC hDC, int, int); // idb
int __stdcall TBInsertMarkHitTest(HDC hDC, int, int, int); // idb
int __stdcall MakeGroupConsistant(HDC hDC, int); // idb
int __stdcall TB_OnSetImage(HDC hDC, int, int); // idb
signed int __stdcall TB_OnGetButtonInfo(int a1, int a2, int a3);
int __stdcall TBOnChar(HDC hDC, WORD w2); // idb
int __stdcall TBOnKey(HDC hDC, int, int); // idb
signed int __stdcall TB_OnGetButtonInfoA(int a1, int a2, int a3);
int __stdcall TB_CalcWidth(HDC hDC, int); // idb
int __stdcall TB_OnScroll(HDC hDC, int); // idb
int __stdcall TB_OnCalcSize(HDC hDC, int); // idb
int __stdcall TB_OnPagerControlNotify(HDC hDC, int); // idb
void __stdcall TB_ForceCreateTooltips(HDC hDC);
LRESULT __stdcall TBRelayToToolTips(HDC hDC, int a2, int a3, int a4);
int __stdcall ToolbarDragCallback(HWND hWnd, int, WPARAM wParam, LPARAM); // idb
LONG __stdcall DrawToolbarV(int xLeft, HDC hdc, RECT *lprcSrc);
int __stdcall TB_GetItemDropDownRect(HDC hDC, int, int); // idb
int __stdcall TBGetString(int, int, size_t cchDest, STRSAFE_LPWSTR pszDest); // idb
int __stdcall TBMoveButton(HWND hWndTo, int, int); // idb
void __stdcall TBSetStyleEx(HWND hWndTo, int a2, int a3);
char __stdcall TB_OnSetState(HDC hDC, int a2, char a3, int a4);
int __stdcall TB_OnSetButtonInfo(HDC hDC, int, int); // idb
int __stdcall TB_OnSetButtonInfoA(HDC hDC, int, int); // idb
void __stdcall TBOnMouseMove(HDC hDC, HWND hWnd, int a3, int a4, int a5);
int __stdcall TBHandleLButtonDown(HWND hWnd, int, int); // idb
HWND __stdcall TBOnLButtonDown(HDC hDC, int a2, int a3, int a4, int a5);
int __stdcall TBOnLButtonUp(HDC hDC, HWND hWnd, int, int, int); // idb
int __stdcall TBGenerateDragImage(HDC hDC, HGDIOBJ h); // idb
HWND __stdcall isgoodbuddy(int a1);
void __stdcall pickbuddy(int a1);
BOOL __stdcall unachor(int a1);
BOOL __stdcall anchor(int a1);
signed int __stdcall compare(int a1, unsigned int a2, unsigned int a3, int a4);
signed int __stdcall nudge(int a1);
int __stdcall squish(int a1, int a2, int a3);
int __stdcall getthousands(LPWSTR lpLCData); // idb
int __stdcall getgrouping();
int __stdcall getint(int a1, int a2);
BOOL __stdcall PaintUpDownControl(int a1, HDC a2);
HWND __stdcall CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, HWND hBuddy, int nUpper, int nLower, int nPos);
signed int __stdcall UD_HitTest(int a1, LONG a2, LONG a3);
LONG __stdcall UD_Invalidate(int a1, int a2, BOOL bErase);
void __stdcall UD_OnMouseMove(int a1, int a2);
LRESULT __stdcall setint(int a1);
unsigned int __stdcall bump(int a1);
signed int __stdcall ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall setbase(int a1, int a2);
HWND __stdcall setbuddy(DWORD_PTR dwRefData, HWND a2);
LPARAM __stdcall UpDownWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL __stdcall DSA_GetItem(HDSA hdsa, int i, void *pitem);
BOOL __stdcall DSA_DeleteAllItems(HDSA hdsa);
int __stdcall DPA_GetPtrIndex(HDPA hdpa, const void *p);
HRESULT __stdcall DPA_SaveStream(HDPA hdpa, PFNDPASTREAM pfn, struct IStream *pstream, void *pvInstData);
void *__stdcall DPA_MergeThem(int a1, int a2, signed int a3);
int __stdcall Str_GetPtrW(LPCWSTR lpString, void *Dst, int); // idb
size_t __stdcall Str_GetPtrA(LPCSTR lpString, void *Dst, int a3);
BOOL __stdcall DSA_SetItem(HDSA hdsa, int i, const void *pitem);
HRESULT __stdcall DPA_LoadStream(HDPA *phdpa, PFNDPASTREAM pfn, struct IStream *pstream, void *pvInstData);
BOOL __stdcall DPA_Merge(HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam);
LONG __stdcall Str_SetPtrA(volatile LONG *Target, LPCSTR lpString);
LRESULT __stdcall SubclassDeath(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL __stdcall GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR *pdwRefData);
BOOL __stdcall RM_HandleKeyDown(int a1, int a2, int a3);
int __stdcall RM_GetScrollXY(int a1, int a2, int a3, int a4);
int __stdcall RM_CheckScroll(int a1, int a2);
HCURSOR __stdcall RM_SetCursor(int a1, int a2);
HWND __stdcall DoReaderMode(int a1);
int __stdcall PtInLBItem(HWND hWnd, WPARAM wParam, POINT pt, int, int dy); // idb
int __stdcall LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);
void __stdcall DrawInsert(HWND handParent, HWND hLB, int nItem);
LRESULT __stdcall DragListSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
BOOL __stdcall MakeDragList(HWND hLB);
int __stdcall FlatSB_Internal_NotifyWinEvent(int a1, int a2, int a3);
LRESULT __stdcall FlatSB_NCDestroyProc(HLOCAL hMem, HWND hWnd, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall FlatSB_NCCalcProc(int a1, HWND hWnd, WPARAM wParam, RECT *lprcSrc);
void __stdcall TimerMouseLeave(HWND hWnd, UINT a2, UINT pdwRefData, DWORD a4);
BOOL __stdcall FlatSB_InitWSBMetrics(int a1);
LRESULT __stdcall FlatSB_OnSettingChangeProc(int a1, HWND hWnd, WPARAM wParam, LPARAM lParam);
void __stdcall FlatSB_Internal_DrawBox(HDC hdc, int x, HGDIOBJ a3);
void __stdcall FlatSB_Internal_DrawEncartaBox(HDC hdc, int x, HGDIOBJ a3);
LONG __stdcall FlatSB_Internal_DrawArrow(HGDIOBJ h, HDC hdc, RECT *lprcSrc, int y, int mode);
void __stdcall FlatSB_Internal_DrawElevator(int a1, HDC hdc, RECT *lprcSrc, int a4);
int __stdcall FlatSB_Internal_DrawGroove(HBRUSH hbr, HDC hDC, RECT *lprc, COLORREF color); // idb
int __stdcall FlatSB_Internal_SBPosFromPx(int a1, int a2);
int __stdcall FlatSB_Internal_InvertScrollHilite(int a1);
int __stdcall FlatSB_Internal_DrawInvertScrollArea(HGDIOBJ h, int, int); // idb
LRESULT __stdcall FlatSB_Internal_DoScroll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4);
void __stdcall TimerScroll(HWND hWnd, UINT a2, UINT a3, DWORD a4);
void __stdcall FlatSB_Internal_SBTrackLoop(int a1, int a2);
int __stdcall FlatSB_Internal_InitPwSB(int a1);
int __stdcall FlatSB_Internal_GetSBFlags(int a1, int a2);
void __stdcall FlatSB_Internal_DrawThumb2(HBRUSH hbr, HDC hDC, COLORREF color, char a4);
void __stdcall FlatSB_Internal_DrawSB2(HGDIOBJ a1, HDC hdc, COLORREF color, int a4, int a5);
int __stdcall FlatSB_Internal_CalcSBStuff2(int nNumber, int, int); // idb
int __stdcall FlatSB_Internal_CalcSBStuff(int nNumber, int); // idb
int __stdcall FlatSB_Internal_DrawThumb(HBRUSH hbr, COLORREF color); // idb
signed int __stdcall FlatSB_Internal_SBSetParms(int a1, int a2, char a3, int a4, int a5, unsigned int a6, int a7, int a8, int a9, int a10, int a11);
void __stdcall FlatSB_Internal_DrawScrollBar(HGDIOBJ a1, HDC hdc, COLORREF color, int a4);
int __stdcall FlatSB_Internal_IsSizeBox(HWND hWnd); // idb
HGDIOBJ __stdcall FlatSB_Internal_DrawSize(int a1, HDC hdc, int x, int y);
void __stdcall FlatSB_Internal_MoveThumb(HWND hWnd, int a2);
void __stdcall FlatSB_Internal_TrackThumb(int nNumber, int a2, int a3, int a4);
int __stdcall FlatSB_Internal_RedrawScrollBar(HGDIOBJ, COLORREF color); // idb
int __stdcall FlatSB_Internal_EnableScrollBar(HDC hDC, UINT wSBflags, UINT wArrows); // idb
int __stdcall FlatSB_Internal_SetScrollBar(int nNumber, int nBar, LPCSCROLLINFO lpsi, int); // idb
LRESULT __stdcall FlatSB_NCPaintProc(HGDIOBJ a1, HWND hWnd, WPARAM wParam, LPARAM lParam);
LPARAM __stdcall FlatSB_NCHitTestProc(HGDIOBJ a1, HWND hWnd, WPARAM wParam, LPARAM lParam, int a5);
LRESULT __stdcall FlatSB_OnScrollProc(HGDIOBJ a1, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LPARAM __stdcall FlatSB_Internal_EndScroll(HGDIOBJ h, int a2);
UINT __stdcall FlatSB_Internal_TrackBox(HGDIOBJ h, int a2, int a3, int a4);
void __stdcall FlatSB_Internal_SBTrackInit(int nNumber, HWND hWnd, int a3, COLORREF color, int a5);
LRESULT __stdcall FlatSB_SysCommandProc(int nNumber, HWND hWnd, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall FlatSB_CancelModeProc(HGDIOBJ h, HWND hWnd, WPARAM wParam, LPARAM lParam);
LRESULT __stdcall FlatSB_SubclassWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall FlatSB_GetScrollPos(HWND, int code);
BOOL __stdcall FlatSB_GetScrollProp(HWND, int propIndex, LPINT);
BOOL __stdcall FlatSB_GetScrollRange(HWND, int code, LPINT, LPINT);
BOOL __stdcall FlatSB_GetScrollInfo(HWND, int code, LPSCROLLINFO);
BOOL __stdcall FlatSB_ShowScrollBar(HWND, int code, BOOL);
BOOL __stdcall FlatSB_EnableScrollBar(HWND, int, UINT);
int __stdcall FlatSB_SetScrollPos(HWND, int code, int pos, BOOL fRedraw);
int __stdcall FlatSB_SetScrollRange(HWND, int code, int min, int max, BOOL fRedraw);
int __stdcall FlatSB_SetScrollInfo(HWND, int code, LPSCROLLINFO psi, BOOL fRedraw);
BOOL __stdcall FlatSB_SetScrollProp(HWND, UINT index, INT_PTR newValue, BOOL);
HRESULT __stdcall UninitializeFlatSB(HWND);
BOOL __stdcall InitializeFlatSB(HWND);
int __stdcall IsMaxedMDI(HMENU hMenu); // idb
void __stdcall MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT *lpwIDs);
BOOL __stdcall ShowHideMenuCtl(HWND hWnd, UINT_PTR uFlags, LPINT lpInfo);
void __stdcall GetEffectiveClientRect(HWND hWnd, LPRECT lprc, const INT *lpInfo);
BOOL __stdcall ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);
// BOOL __stdcall ImmReleaseContext(HWND, HIMC);
HIMC __stdcall ImmGetContext(HWND);
LONG __stdcall ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
BOOL __stdcall ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
// BOOL __stdcall ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate);
void __stdcall InitMUILanguage(LANGID uiLang);
LANGID __stdcall GetMUILanguage();
signed int __stdcall MirrorIcon(HICON *a1, HICON *a2);
unsigned __int32 __stdcall CNativeFont::v_OnStyleChanged(unsigned int a2, __int32 a3);
void *__stdcall StringBufferAtoW(UINT CodePage, STRSAFE_LPWSTR pszDest, size_t cchDest, int a4);
signed int __stdcall InOutWtoA(int a1, int a2, int a3, unsigned int a4);
STRSAFE_LPWSTR __stdcall InOutAtoW(int a1, int a2, int a3);
HWND __stdcall SendNotify(int a1, int a2, int a3, LPARAM lParam);
BOOL __stdcall CCReleaseCapture(int a1);
int __stdcall ComboEx_GetComboClientRect(int, LPRECT lpRect); // idb
COLORREF __stdcall EraseWindow(HWND hWnd, HDC hdc, COLORREF color);
wchar_t *__stdcall ComboEx_ISetItem(int a1, int a2, int a3);
signed int __stdcall ComboEx_OnGetItem(int a1, int a2);
HLOCAL __stdcall ComboEx_HandleDeleteItem(int a1, int a2);
signed int __stdcall ComboEx_OnInsertItem(int a1, int a2);
int __stdcall ComboEx_OnGetItemData(int, WPARAM wParam); // idb
int __stdcall ComboEx_OnSetItemData(int, WPARAM wParam, int); // idb
int __stdcall ComboEx_StrCmp(int, LPCWSTR lpString1, LPCWSTR lpString2); // idb
LRESULT __stdcall ComboEx_GetFont(int a1);
BOOL __stdcall IsDelimiter(__int16 a1);
int __stdcall ShellEditWordBreakProc(LPCWSTR lpszStart, int, int, int); // idb
signed int __stdcall ComboEx_GetCurSelText(int a1, int a2, int a3);
LRESULT __stdcall ComboEx_UpdateEditText(int a1, int a2);
int __stdcall ComboEx_OnDrawItem(int a1, int a2);
int __stdcall ComboEx_ComputeItemHeight(int cy, int); // idb
int __stdcall ComboEx_OnMeasureItem(int cy, int); // idb
signed int __stdcall ComboEx_OnGetItemA(int a1, int pulResult);
signed int __stdcall ComboEx_OnSetItem(int a1, int a2);
signed int __stdcall ComboEx_OnFindStringExact(int a1, signed int a2, const WCHAR *a3);
LRESULT __stdcall SetPathWordBreakProc(HWND hWnd, int a2);
int __stdcall ComboEx_OnSetFont(int cy, UINT fWinIni, LPARAM lParam); // idb
int __stdcall ComboEx_EndEdit(DWORD dwStyle, int); // idb
BOOL __stdcall ComboEx_SizeEditBox(int a1);
int __stdcall ComboSubclass_HandleCommand(DWORD dwStyle, int, int); // idb
LRESULT __stdcall EditSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall ComboEx_GetLBText(int, int, int, STRSAFE_LPWSTR pszDest); // idb
int __stdcall ComboEx_OnSetImageList(LPARAM lParam, int); // idb
LONG __stdcall ComboEx_OnWindowPosChanging(int a1, int a2);
int __stdcall ComboEx_OnSetExStyle(int a1, int a2, int a3);
int __stdcall ComboEx_GetEditBox(DWORD dwStyle); // idb
int __stdcall ComboEx_BeginEdit(DWORD dwStyle); // idb
int __stdcall ComboSubclass_HandleButton(DWORD dwStyle, int, int); // idb
int __stdcall ComboSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall ComboEx_HandleCommand(DWORD dwStyle, int, int); // idb
HLOCAL __stdcall ComboEx_OnDestroy(HLOCAL hMem);
LONG __stdcall ComboEx_OnCreate(HWND hWnd, int a2);
int __stdcall ComboExWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall TME_PostMouseLeave(HWND hWnd); // idb
int __stdcall TME_CancelMouseLeave(int a1);
BOOL __stdcall TME_CancelMouseHover(int a1);
HLOCAL __stdcall TME_CancelTracking(HLOCAL hMem);
HLOCAL __stdcall TME_RemoveAllTracking(int a1);
HLOCAL __stdcall TME_MouseHasLeft(int a1);
LRESULT __stdcall TME_SubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
signed int __stdcall TME_CheckInWindow(int a1, int a2);
signed int __stdcall GetMouseKeyFlags();
int __stdcall TME_SubclassWnd(DWORD_PTR dwRefData); // idb
HWND __stdcall GetTMEdata(HWND hWnd);
void __stdcall TME_MouseLeaveTimer(HWND hWnd, UINT a2, UINT a3, DWORD a4);
void __stdcall TME_MouseHoverTimer(HWND hWnd, UINT a2, UINT a3, DWORD a4);
UINT_PTR __stdcall TME_ResetMouseLeave(int a1, int a2);
UINT_PTR __stdcall TME_ResetMouseHover(int a1, int a2);
signed int __stdcall QueryTrackMouseEvent(int a1);
signed int __stdcall EmulateTrackMouseEvent(int a1);
BOOL __stdcall _TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);
BOOL __stdcall ChrCmpIW(WORD w1, WORD w2);
int __stdcall StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
int __stdcall StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
int __stdcall IntlStrEqWorkerW(int, PCNZWCH lpString1, PCNZWCH lpString2, int cchCount1); // idb
LPCWSTR __stdcall ProduceAFromW(UINT CodePage, LPCWSTR lpWideCharStr);
COLORREF __stdcall RB_GetTextColor(int a1);
COLORREF __stdcall RBB_GetTextColor_External(int a1, int a2);
COLORREF __stdcall RBB_GetBkColor_External(int a1, int a2);
int __stdcall TrueMapWindowPoints(HWND hWnd, HWND hWndFrom, int, int); // idb
int __stdcall MapRectInRTLMirroredWindow(int, HWND hWnd); // idb
void __stdcall RBRealize(int a1, HDC hdc, BOOL bForceBkgd, int a4);
signed int __stdcall RBMoveBand(int a1, unsigned int a2, unsigned int a3);
int __stdcall RBVertMungeGripperRect(int, LPRECT lprc); // idb
HGDIOBJ __stdcall RBDrawChevron(int a1, int a2, HDC hdc);
void __stdcall RBUpdateChevronState(int a1, int a2, unsigned __int16 a3);
BOOL __stdcall SHHasTimeoutElapsed(int a1, DWORD a2);
int __stdcall RBTileBlt(int, int, int x, int y, int, int cy, HDC hdc, HDC hdcSrc); // idb
signed int __stdcall RBGetBarInfo(int a1, int a2);
unsigned int __stdcall RBGetPrev(int a1, unsigned int a2, int a3);
int __stdcall RBMinX(int a1, int a2);
int __stdcall minmax(int a1, int a2, int a3);
int __stdcall RBPassBreak(int a1, int a2, int a3);
int __stdcall RBGetClientRect(int, LPRECT lpRect); // idb
int __stdcall RBGetBandBorders(int a1, int a2, int a3);
void __stdcall RBOnPushChevron(int a1, int a2, int a3, int a4);
int __stdcall RBCanBandMove(int a1, int a2);
int __stdcall _RBHitTest(int, int, POINT pt); // idb
int __stdcall RBHitTest(int a1, int a2);
unsigned int __stdcall RBBPrevVisible(int a1, unsigned int a2);
int __stdcall RBMaxX(int a1, unsigned int a2);
HCURSOR __stdcall RBSetCursor(int a1, int a2, int a3, int a4);
int __stdcall RebarDragCallback(HWND hWnd, int, int, LPARAM lParam); // idb
void *__stdcall RBSetFont(int a1, int a2);
signed int __stdcall RBSetBandPos(int a1, unsigned int a2, LONG a3);
signed int __stdcall RBSetBandPosAnim(int a1, unsigned int a2, LONG a3);
signed int __stdcall RBDragSize(int a1, LONG a2);
signed int __stdcall RBRoomForBandVert(int a1, int a2);
int __stdcall RBMakeNewRow(int a1, unsigned int a2, int a3);
void __stdcall RBDragBand(int a1, POINT pt);
int __stdcall RBGrowBand(int a1, int a2, signed int a3, int a4);
signed int __stdcall RBShowBand(int a1, unsigned int a2, int a3);
int __stdcall RBMaximizeBand(int a1, unsigned int a2, int a3, int a4);
void __stdcall RBOnBeginDrag(int a1, int a2);
void __stdcall RBOnMouseMove(HWND hWnd, int a2, int a3, int a4, int a5);
int __stdcall RBMinimizeBand(int a1, unsigned int a2, int a3);
void __stdcall RBToggleBand(int a1, int a2);
unsigned int __stdcall MCInsertMarkers(unsigned int a1, signed int *a2);
int __stdcall MCRemoveMarkers(int a1, int a2);
int __stdcall MCLoadString(int, void *Dst, int); // idb
HMENU __stdcall MCReloadMenus(LPCWSTR lpNewItem);
int __stdcall MCHandleEraseBkgnd(int, HDC hdc); // idb
int __stdcall MCGetDateFormatWithTempYear(int, SYSTEMTIME *lpDate, LPCWSTR lpFormat, __int16, LPWSTR lpDateStr, int cchDate); // idb
LRESULT __stdcall MCUpdateEditYear(int a1);
COLORREF __stdcall MCInitColorArray(int a1);
int __stdcall MCOnStyleChanging(int a1, int a2, int a3);
HGDIOBJ __stdcall MCDrawTodayCircle(HGDIOBJ h, HDC hdc, int y1);
BOOL __stdcall MCInvalidateMonthDays(int a1);
int __stdcall MCGetTodayBtnRect(int a1, int a2);
int __stdcall MCPaintArrowBtn(int, HDC, int, int); // idb
int __stdcall MCGetMonthFormat(int, SYSTEMTIME *lpDate, LPWSTR lpDateStr, int cchDate, int); // idb
signed int __stdcall MCIsSelectedDayMoYr(int a1, __int16 a2, __int16 a3, __int16 a4);
BOOL __stdcall MCIsBoldOffsetDay(int a1, char a2, int a3);
int __stdcall MCRecomputeSizing(int a1, int a2);
int __stdcall MCUpdateMonthNamePos(int a1);
void __stdcall MCUpdateDayState(int a1);
void __stdcall MCNotifySelChange(int a1, int a2);
int __stdcall MCGetOffsetForYrMo(int a1, int a2, int a3);
int __stdcall MCGetRcForMonth(int a1, signed int a2, int a3);
int __stdcall FGetOffsetForPt(int, POINT pt, int); // idb
int __stdcall FGetRowColForRelPt(int, POINT pt, int, int); // idb
int __stdcall GetYrMoForOffset(int a1, int a2, int a3, int a4);
int __stdcall FGetDateForPt(int, POINT pt, int, int, int, int, int); // idb
signed int __stdcall MCInvalidateDates(int a1, int a2, int a3);
int __stdcall MCHandleMultiSelect(int a1, int a2);
int __stdcall MCGetTitleRcsForOffset(int a1, signed int a2, int a3, int a4);
int __stdcall MCDPAEnumCallback(void *p, void *pData);
void __stdcall MCDPADestroy(HDPA hdpa);
BOOL __stdcall MCEnumCalInfoProc(LPWSTR lpSrch);
HDPA __stdcall MCGetCalInfoDPA(CALID Calendar, CALTYPE CalType);
void __stdcall MCFreeCalendarInfo(int a1);
signed int __stdcall MCGetEraInfo(int a1);
signed int __stdcall MCGetCalendarInfo(int a1);
int __stdcall MCIsDateStringRTL(WCHAR SrcStr); // idb
LONG __stdcall SECGetMaxEraLength(int a1, HDC hdc, LPSIZE psizl);
HLOCAL __stdcall SECDestroy(int a1);
HGDIOBJ __stdcall SECSetFont(int a1, void *a2);
int __stdcall InvalidateScrollRect(HWND hWnd, int, int); // idb
int __stdcall SECGetYearValue(int a1, __int16 a2);
int __stdcall SECAdjustByEra(int a1, int a2);
int __stdcall SECAdjustByType(int a1, int a2, unsigned int a3);
int __stdcall SECInvalidate(int a1, signed int a2);
int __stdcall SECGetEraName(int, int, __int16, LPWSTR lpDateStr, int cchDate); // idb
int __stdcall SECIncrementEra(int a1, int a2, int a3);
signed int __stdcall SECIncrementSubedit(int a1, int a2);
signed int __stdcall SECIsNumeric(int a1);
int __stdcall SECSubeditFromPt(int a1, int a2, int a3);
int __stdcall SECGetSystemtime(int a1, int a2);
signed int __stdcall SECSetSystemtime(int a1, int a2);
HLOCAL __stdcall DPNcCreateHandler(HWND hWnd);
LONG __stdcall DPDestroyHandler(HWND hWnd, HLOCAL hMem, int a3, int a4);
int __stdcall DPOnStyleChanging(int a1, int a2, int a3);
LONG __stdcall _RecomputeMonthCalRect(int a1, int a2, int a3);
HWND __stdcall DPNotifyDateChange(int a1);
signed int __stdcall DPSetDate(int a1, int a2, int a3);
int __stdcall DPDrawDropdownButton(int, HDC, int); // idb
signed int __stdcall MCHandleHitTest(int a1, int a2);
LONG __stdcall MCNcCreateHandler(HWND hWnd);
LRESULT __stdcall MCNcDestroyHandler(HWND hWnd, HLOCAL hMem, WPARAM wParam, LPARAM lParam);
void __stdcall MCUpdateToday(int a1);
int __stdcall FUpdateRcDayCur(int, POINT pt); // idb
int __stdcall MCGetRcForDay(int a1, signed int a2, int a3, int a4);
signed int __stdcall MCSetToday(int a1, int a2);
char *__stdcall SEGetTimeDateFormat(int a1, int a2, STRSAFE_LPWSTR pszDest, size_t cchDest);
int __stdcall SECRecomputeSizing(int a1, int a2);
int __stdcall SECParseFormat(int, int, STRSAFE_LPCWSTR pszSrc); // idb
HWND __stdcall SECSetSubeditValue(int a1, int a2, unsigned int a3, int a4);
int __stdcall SECSaveResetSubeditEdit(int a1, int a2);
STRSAFE_LPWSTR __stdcall SECFormatSubed(int a1, int a2, STRSAFE_LPWSTR pszDest, size_t cchDest);
HGDIOBJ __stdcall SECDrawSubedits(HDC hdc, int a2, int a3, int a4);
signed int __stdcall DPHandleLocaleChange(int a1);
int __stdcall DPHandleSetFont(int, HANDLE h, int); // idb
unsigned int __stdcall DPPaint(int a1, HDC hdc);
int __stdcall DPRecomputeSizing(int a1, int a2);
int __stdcall MCCalcSizes(int a1);
HFONT __stdcall MCHandleSetFont(int a1, HANDLE h, int a3);
HGDIOBJ __stdcall MCPaintMonth(HGDIOBJ a1, HDC hdc, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall MCUpdateRcDayCur(int a1, int a2);
BOOL __stdcall SECSetCurSubed(int a1, int a2);
signed int __stdcall SECIncrFocus(int a1, int a2);
signed int __stdcall SECHandleKeydown(int a1, UINT a2, int a3);
int __stdcall SECHandleChar(int, WORD wMatch); // idb
int __stdcall SECEdit(int, int, int nMaxCount); // idb
signed int __stdcall SECSafeSetCurSubed(int a1, int a2);
int __stdcall DTM_OnSetFormat(int, STRSAFE_LPCWSTR pszSrc); // idb
int __stdcall DPOnStyleChanged(int a1, int a2, int a3);
HWND __stdcall DPLBD_MonthCal(HDC hDC, int a2);
HWND __stdcall DPHandleSECEdit(int a1);
int __stdcall DPLButtonDown(HDC hDC, int, int); // idb
int __stdcall DPHandleKeydown(HDC hDC, int, int); // idb
int __stdcall DPHandleChar(int, WORD wMatch, int); // idb
int __stdcall MCOnStyleChanged(int a1, int a2, int a3);
int __stdcall MCPaint(HGDIOBJ, HDC hdc); // idb
int __stdcall MCUpdateStartEndDates(int a1, int a2);
int __stdcall FIncrStartMonth(int a1, int a2, int a3);
int __stdcall MCIncrStartMonth(int a1, int a2, int a3);
signed int __stdcall MCHandleTimer(int a1, int a2);
int __stdcall MCMouseMove(HDC hDC, int, int); // idb
int __stdcall FScrollIntoView(int a1);
int __stdcall DatePickWndProc(HWND hWnd, UINT Msg, int, LPARAM lParam); // idb
int __stdcall UpdateLocaleInfo(int, void *Dst); // idb
int __stdcall MonthCal_OnPaint(HGDIOBJ, HDC hdc); // idb
int __stdcall MCCreateHandler(LPCWSTR lpNewItem, WPARAM wParam, int); // idb
int __stdcall MCSizeHandler(int a1, int a2);
signed int __stdcall MCSetDate(int a1, int a2);
BOOL __stdcall MCGotoToday(int a1);
int __stdcall MCContextMenu(int a1, int a2, int a3);
int __stdcall MCLButtonDown(DWORD dwExStyle, int, int nPos); // idb
int __stdcall MCLButtonUp(int a1, int a2, int a3);
signed int __stdcall MCHandleKeydown(int a1, unsigned int a2, int a3);
int __stdcall MonthCalWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall GetPrevButton(int a1, int a2);
signed int __stdcall GetAdjustInfo(int a1, int a2, int a3, int a4, int a5);
HWND __stdcall SendItemNotify(HDC hDC, int a2, int a3);
int __stdcall GetNearestInsert(HDC hDC, int, int, int); // idb
int __stdcall PaintAdjustLine(HDC hDC, HDC hdc); // idb
int __stdcall SafeEnableWindow(HWND hDlg, int nIDDlgItem, WPARAM wParam, BOOL bEnable); // idb
int __stdcall InsertIndex(int, POINT pt, BOOL bAutoScroll); // idb
int __stdcall IsInButtonList(HWND hWnd, struct tagPOINT Point); // idb
int __stdcall SaveRestoreFromReg(SIZE_T, int, HKEY, LPCWSTR, LPCWSTR); // idb
LONG __stdcall FixPTB(HWND hWnd);
void __stdcall MoveButton(HDC hDC, int a2);
LPARAM __stdcall LBMoveButton(int a1, int nIDDlgItem, WPARAM wParam, int a4, WPARAM a5, int a6);
int __stdcall HandleDragMsg(int, HWND hWnd, int, int); // idb
int __stdcall InitAdjustDlg(HWND hDlg, int); // idb
BOOL __stdcall AdjustDlgProc(HWND hWnd, UINT a2, WPARAM wParam, LPARAM a4);
void __stdcall CustomizeTB(int a1, int a2);
DWORD __stdcall _GetHcursorPdy3(int a1, int a2);
int __stdcall _GetCursorLowerLeft(int a1, int a2, int a3, int a4);
UINT __stdcall ToolTips_NewFont(int a1, HANDLE h);
int __stdcall ChildOfActiveWindow(HWND hWnd); // idb
BOOL __stdcall PopBubble(int a1);
int __stdcall TTSetTimer(int, UINT_PTR nIDEvent); // idb
int __stdcall TTWindowFromPoint(int, LPARAM lParam); // idb
signed int __stdcall ToolHasMoved(int a1);
int __stdcall FindTool(int a1, int a2);
int __stdcall TTUnsubclassHwnd(HWND hWnd, UINT_PTR uIdSubclass, int); // idb
LRESULT __stdcall TTSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __stdcall TTSubclassHwnd(DWORD_PTR pdwRefData, UINT_PTR uIdSubclass); // idb
wchar_t *__stdcall TTSetTipText(int a1, LPCWSTR lpString);
wchar_t *__stdcall TTBeforeFreeTool(UINT_PTR *a1, int a2);
int __stdcall DeleteTool(int a1, int a2);
int __stdcall StripAccels(int a1);
int __stdcall GetToolRect(int, LPRECT lpRect); // idb
int __stdcall PointInTool(int, int, POINT pt); // idb
BOOL __stdcall ShowVirtualBubble(int a1);
int __stdcall TTGetTipPosition(int, POINT pt, int, int, int); // idb
int __stdcall TTCreateTitleBitmaps(HICON hIcon); // idb
int __stdcall TTRenderTitledTip(int, HDC hdcDst, int, RECT *lprcSrc, int); // idb
int __stdcall TTGetTipSize(UINT format, int, LPCWSTR lpString, int, int); // idb
signed int __stdcall TTAdjustRect(int a1, int a2, int a3);
HRGN __stdcall CreateBalloonRgn(int a1, int a2, int x2, int a4, int a5, int a6, int a7);
int __stdcall TTSetDelayTime(int a1, int a2, __int16 a3);
UINT __stdcall TTGetDelayTime(int a1, int a2);
int __stdcall CopyToolInfoA(int, int, UINT CodePage); // idb
int __stdcall ThunkToolInfoAtoW(int, int, int, UINT CodePage); // idb
int __stdcall ThunkToolInfoWtoA(int, int, UINT CodePage); // idb
int __stdcall ThunkToolTipTextAtoW(int, int, UINT CodePage); // idb
int __stdcall ToolTipsMgrCreate(WPARAM wParam, int); // idb
int __stdcall AddTool(int, void *Src); // idb
int __stdcall GetToolText(int a1, int a2);
int __stdcall GetCurToolText(int a1);
int __stdcall GetToolAtPoint(int, int, POINT pt, int, int); // idb
int __stdcall DoShowBubble(UINT uFlags); // idb
int __stdcall ShowBubbleForTool(UINT uFlags, int); // idb
int __stdcall HandleRelayedMessage(int, HWND hWnd, int, int, int); // idb
int __stdcall TTUpdateTipText(UINT uFlags, int); // idb
int __stdcall TTSetFont(UINT uFlags, HANDLE h, int); // idb
int __stdcall CopyToolInfo(int a1, int a2);
int __stdcall TTToolAtMessagePos(int a1);
int __stdcall TTCheckCursorPos(int a1);
void __stdcall TTHandleTimer(UINT uFlags, int a2);
int __stdcall TTRender(UINT options, HDC hdc); // idb
int __stdcall TTOnPaint(UINT options); // idb
int __stdcall ToolTipsWndProc(HWND hWnd, UINT Msg, size_t cchDest, LPARAM lParam); // idb
int __stdcall FormatIPAddress(int a1, int a2);
int __stdcall IP_OnSetFont(HDC hdc, HGDIOBJ h, LPARAM lParam); // idb
LRESULT __stdcall EnterField(HWND *a1, unsigned __int16 a2, unsigned __int16 a3);
int __stdcall GetFieldValue(HWND *a1);
LRESULT __stdcall SetFieldValue(int a1, int a2, int a3);
signed int __stdcall ExitField(int a1, int a2);
signed int __stdcall SwitchFields(int a1, int a2, int a3, unsigned __int16 a4, unsigned __int16 a5);
LRESULT __stdcall IPAddressFieldProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
HMENU __stdcall IPAddressWndFn(HWND hWnd, UINT Msg, BOOL bEnable, int a4);
BOOL __stdcall DoNotify(int a1, unsigned __int16 a2);
signed int __stdcall HandleStop(int a1);
void __stdcall HandlePaint(int a1, HDC hdc);
int __stdcall HandleErase(int, WPARAM wParam); // idb
int __stdcall HandleTick(LPCRITICAL_SECTION lpCriticalSection); // idb
int __stdcall Ani_OnStyleChanged(int a1, int a2, int a3);
int __stdcall HandleOpen(int, int, LPCWSTR lpFileName, int); // idb
DWORD __stdcall PlayThread(LPVOID lpThreadParameter);
int __stdcall HandlePlay(LPVOID lpParameter, int, int, int); // idb
int __stdcall HandleFirstPaint(int a1);
// _DWORD __stdcall HandlePrint(_DWORD, _DWORD); weak
int __stdcall AnimateWndProc(HWND hWnd, UINT Msg, int, LPCSTR lpMultiByteStr); // idb
int __stdcall SetHotKey(HWND hWnd, __int16, __int16, int); // idb
int __stdcall GetKeyName(UINT uCode, LPWSTR lpString, int cchSize, int); // idb
LONG __stdcall HKMSetRules(HWND hWnd, LONG dwNewLong, LONG a3);
LONG __stdcall HKMSetFont(HWND hWnd, LONG dwNewLong);
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc);
int __stdcall PaintHotKey(HWND hWnd); // idb
int __stdcall HotKeyWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall UpdatePosition(int a1, int a2, int a3);
LONG __stdcall ProPaint(int a1, HDC a2);
int __stdcall TBLogToPhys(int a1, int a2);
int __stdcall TBPhysToLog(int a1, int a2);
int __stdcall TBFlipPoint(int a1, int a2);
int __stdcall PatRect(HDC hdc, int, int, int, int, int); // idb
int __stdcall VertInvalidateRect(HWND hWnd, int, BOOL bErase, int); // idb
int __stdcall VertPatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop, int); // idb
int __stdcall DrawTic(int a1, int a2, int a3, int a4);
int __stdcall DrawTicsOneLine(int a1, int a2, int a3);
int __stdcall DrawTics(int a1);
void __stdcall GetChannelRect(int a1, int a2);
int __stdcall DrawChannel(int a1, int a2);
void __stdcall DrawThumb(int y, UINT a2, int a3);
BOOL __stdcall TBInvalidateAll(int a1);
int __stdcall MoveThumb(int a1, int a2);
HWND __stdcall DrawFocus(int a1, HBRUSH hbr);
void __stdcall DoAutoTics(int a1);
int __stdcall ValidateThumbHeight(int a1);
int __stdcall TBPositionBuddies(HWND hWndTo); // idb
BOOL __stdcall TBNukeBuffer(int a1);
int __stdcall TBResize(HWND hWndTo); // idb
int __stdcall TBSetBuddy(HWND hWndTo, int, int); // idb
LRESULT __stdcall DoTrack(int a1, signed int a2, unsigned __int16 a3);
signed int __stdcall WTrackType(int a1, int a2);
int __stdcall TBTrackEnd(int a1);
int __stdcall TBTrack(int a1, int a2);
void __stdcall FlushChanges(HBRUSH hbr);
int __stdcall TrackOnCreate(HWND hWnd, int); // idb
void __stdcall TBTrackInit(int a1, int a2);
HWND __stdcall TrackOnNotify(int a1, LPARAM lParam);
int __stdcall TrackBarWndProc(HWND hWnd, UINT Msg, int, LPARAM lParam); // idb
LRESULT __stdcall TV_PopBubble(LRESULT a1);
HWND __stdcall TV_SendBeginDrag(int a1, int a2, int a3, int a4, int a5);
int __stdcall TV_CheckHit(int a1, signed int a2, signed int a3, int a4);
int __stdcall TV_OnSetRedraw(int a1, int a2);
int __stdcall TV_WalkToLevel(int a1, int a2);
signed int __stdcall TV_ExpandOnSelChange(int a1, int a2, int a3);
signed int __stdcall TV_ResetItem(int a1, LPVOID lpMem);
signed int __stdcall BetweenItems(int a1, int a2, int a3, int a4);
int __stdcall TV_GetVisCount(int a1, int a2);
int __stdcall TV_OnHitTest(int a1, int a2);
int __stdcall TV_IsItemTruncated(int a1, int a2, int a3);
signed int __stdcall TV_HandleTTNShow(int a1, int a2);
int __stdcall TV_HandleTTCustomDraw(int a1, int a2);
signed int __stdcall TV_SetToolTipTarget(int a1, int a2);
int __stdcall TV_ItemAtCursor(HWND *a1, int a2);
signed int __stdcall TV_UpdateToolTipTarget(int a1);
signed int __stdcall TV_SetInsertMark(int a1, int a2, int a3);
BOOL __stdcall TV_GetInfoTip(int a1, int a2, int a3, const WCHAR *a4, int a5);
int __stdcall TV_HandleNeedText(int a1, int a2);
int __stdcall TV_HandleNeedTextA(int a1, int a2);
HGDIOBJ __stdcall TV_OnSetBkColor(HDC hdc, COLORREF color);
int __stdcall TV_TranslateAccelerator(int, MSG *lpMsg); // idb
int __stdcall TV_SetEditSize(int a1);
int __stdcall TV_OnCalcSize(int a1, int a2);
int __stdcall TV_OnScroll(int a1, int a2);
void __stdcall TV_OnMouseMove(int a1, int a2, int a3);
LRESULT __stdcall TV_OnWinIniChange(HDC hdc, int a2);
int __stdcall TV_OnPagerControlNotify(int a1, int a2);
void __stdcall TV_SetItemRecurse(int a1, int a2, int a3);
signed int __stdcall TV_HandleStateIconClick(int a1, int a2);
void __stdcall TV_Command(int a1, __int16 a2, HWND hWnd, int a4);
void __stdcall TV_InitCheckBoxes(HDC hdc);
LRESULT __stdcall TV_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall TV_EditLabel(int a1, int a2, const WCHAR *a3);
int __stdcall TV_Timer(int a1, int a2);
int __stdcall TV_OnImeComposition(int a1, int a2, int a3);
signed int __stdcall TV_OnChar(int a1, int a2, int a3);
BOOL __stdcall TV_CheckForDragBegin(int a1, int a2, int a3, int a4);
signed int __stdcall TV_FinishCheckDrag(int a1);
int __stdcall TV_SendRButtonDown(HWND hWnd, int, int); // idb
int __stdcall TV_DoExpandRecurse(int a1, int a2, signed int a3);
int __stdcall TV_ExpandRecurse(int a1, int a2, signed int a3);
int __stdcall TV_KeyDown(int a1, int a2, int a3);
int __stdcall TV_ButtonDown(int a1, int a2, char a3, signed int a4, signed int a5, char a6);
int __stdcall VertSmoothScrollWindow(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __stdcall VFlipRect(int a1, int a2);
int __stdcall VertImageList_GetIconSize(HIMAGELIST himl, int *, int *cy, int); // idb
int __stdcall VertImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int, UINT fStyle, int); // idb
int __stdcall Tab_ImageList_Draw(int cy, int i, HDC hdcDst, int x, int, UINT fStyle); // idb
int __stdcall Tab_DrawTextEx(HDC hdc, LPWSTR lpchText, int cchText, int, UINT format, LPDRAWTEXTPARAMS lpdtp, int); // idb
int __stdcall VertDrawFocusRect(HDC hDC, int, int); // idb
int __stdcall Tab_DrawFocusRect(HDC hDC, int, int); // idb
int __stdcall Tab_InterButtonGap(int a1);
signed int __stdcall BorrowOne(int a1, int a2, signed int a3, int a4);
signed int __stdcall FillLastRow(int a1);
signed int __stdcall RightJustify(int a1);
signed int __stdcall Tab_OnSetItemExtra(int a1, int a2);
int __stdcall Tab_OnHitTest(int, int, int cy, int); // idb
int __stdcall Tab_FreeItem(int, HLOCAL hMem); // idb
BOOL __stdcall Tab_InvertRows(int a1);
INT_PTR __stdcall Tab_FindTab(int a1, INT_PTR i, int a3);
signed int __stdcall ThunkItemWtoA(int a1, int a2, int a3);
int __stdcall Tab_SmoothScrollWindow(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8, int a9);
int __stdcall Tab_InvalidateRect(int, int, BOOL bErase); // idb
int __stdcall Tab_PatBlt(HDC hdc, int, int, int, int, DWORD rop, int); // idb
int __stdcall Tab_OnDestroy(HLOCAL hMem); // idb
int __stdcall PutzRowToBottom(int a1, int a2);
void __stdcall Tab_InvalidateItem(int a1, INT_PTR i, BOOL bErase);
int __stdcall Tab_Scroll(int a1, int a2, int a3);
void __stdcall Tab_OnHScroll(int a1, int a2, int a3, INT_PTR i);
void __stdcall Tab_OnMouseMove(int a1, char a2, int a3, int cy);
void __stdcall Tab_OnRemoveImage(int a1, int i);
int __stdcall Tab_OnGetItem(int, INT_PTR i, int); // idb
INT_PTR __stdcall Tab_OnSetRedraw(INT_PTR i, int a2);
int __stdcall Tab_OnDeleteAllItems(INT_PTR i); // idb
int __stdcall Tab_OnSetItem(INT_PTR, INT_PTR i, int); // idb
int __stdcall Tab_DeselectAll(INT_PTR, int); // idb
int __stdcall Tab_OnRButtonDown(INT_PTR, int, int cy, int); // idb
int __stdcall Tab_OnDeleteItem(UINT flags, INT_PTR i); // idb
int __stdcall Tab_OnGetItemRect(int, INT_PTR i, int); // idb
INT_PTR __stdcall ChangeSel(HWND hWnd, INT_PTR i, int a3, int a4);
void __stdcall Tab_SetCurFocus(HWND hWnd, INT_PTR i);
int __stdcall Tab_OnKeyDown(HWND hWnd, int, int, int, int); // idb
int __stdcall TabDragCallback(HWND hWnd, int, WPARAM wParam, LPARAM lParam); // idb
int __stdcall Tab_OnButtonUp(HWND hWnd, int, int cy, INT_PTR i); // idb
void __stdcall Tab_OnLButtonDown(INT_PTR a1, int a2, int cy, int a4);
int __stdcall Tab_ExtendedStyleChange(int a1, int a2, int a3);
int __stdcall Header_OnGetItemOrder(int pitem, int); // idb
int __stdcall Header_ItemOrderToIndex(int, int i); // idb
PVOID __stdcall Header_GetItemPtrByOrder(int a1, int i);
int __stdcall Header_InitOrderArray(int i); // idb
int __stdcall Header_ShiftItems(int, int i, int); // idb
int __stdcall Header_OnSetItemOrder(int pitem, int i, int); // idb
signed int __stdcall Header_OnGetOrderArray(int a1, int a2, int a3);
int __stdcall Header_OnSetOrderArray(int pitem, int, int); // idb
signed int __stdcall HDDragFullWindows(int a1);
BOOL __stdcall Header_SendChange(int a1, int a2, int a3, int a4);
BOOL __stdcall Header_Notify(int a1, int a2, int a3, int a4);
int __stdcall Header_NewFont(int, HGDIOBJ h); // idb
signed int __stdcall Header_OnCreate(int a1, int a2);
int __stdcall Header_DestroyItemCallback(void *p, void *pData);
int __stdcall Header_DrawDivider(HWND *a1, LONG a2);
int __stdcall Header_PinDividerPos(int a1, int a2);
signed int __stdcall Header_IsTracking(int a1);
HGDIOBJ __stdcall Header_OnSetFont(int a1, HGDIOBJ h, int a3);
int __stdcall Header_OnGetFont(int a1);
int __stdcall Header_OnGetItem(int pitem, int i, int); // idb
signed int __stdcall Header_OnLayout(int a1, int a2);
int __stdcall Header_OnGetItemRect(int, int i, LPRECT lpRect); // idb
int __stdcall Header_InvalidateItem(int, int i, UINT flags); // idb
LONG __stdcall _Header_DrawBitmap(HDC hdc, HIMAGELIST himl, int a3, HDC hdcSrc, int a5, char a6, LPRECT lprc, int a8);
int __stdcall Header_DrawButtonEdges(int, HDC hdc, LPRECT qrc, int); // idb
HIMAGELIST __stdcall Header_DrawFilterGlyph(int a1, HDC hdc, int a3, int a4);
int __stdcall Header_GetFilterRects(int a1, int a2, int a3, int a4);
int __stdcall Header_SetHotItem(int, int i); // idb
int __stdcall Header_HitTest(int a1, LONG a2, LONG a3, int a4);
int __stdcall Header_OnHitTest(int a1, int a2);
int __stdcall Header_OnSetCursor(int, HWND hWnd, int, int); // idb
int __stdcall Header_GetDividerRect(int, int i, LPRECT lprc); // idb
int __stdcall Header_OnGetItemA(int pitem, int i, int); // idb
int __stdcall Header_OnSetItem(int pitem, int i, int); // idb
int __stdcall Header_FilterChanged(int pitem, int); // idb
int __stdcall Header_InvalidateDivider(int, int i); // idb
int __stdcall _Header_SetHotDivider(int, int i); // idb
int __stdcall Header_OnSetHotDivider(int pitem, int, int); // idb
int __stdcall Header_MoveDrag(int pitem, int, __int16); // idb
int __stdcall Header_EndDrag(int a1);
void __stdcall Header_OnLButtonUp(int pitem, int a2, int a3, int a4);
int __stdcall Header_OnSetItemA(int pitem, int i, int); // idb
int __stdcall Header_DrawItem(int pitem, int, int i, int, int, int); // idb
int __stdcall Header_Draw(int pitem, HDC hdc, int); // idb
HIMAGELIST __stdcall Header_OnCreateDragImage(int pitem, int i);
int __stdcall Header_StopFilterEdit(int pitem, int); // idb
int __stdcall Header_OnFilterButton(int pitem, int i); // idb
int __stdcall Header_OnClearFilter(int pitem, int i); // idb
int __stdcall Header_OnNCDestroy(int pitem); // idb
void __stdcall Header_OnPaint(int pitem, HDC hdc);
void __stdcall Header_StartDrag(int pitem, int i, int x, int a4);
void __stdcall Header_OnMouseMove(int pitem, int i, __int16 a3, int a4);
int __stdcall Header_OnInsertItem(int i, int, int pitem); // idb
int __stdcall Header_OnDeleteItem(int, int i); // idb
int __stdcall Header_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall Header_BeginFilterEdit(int pitem, int i); // idb
void __stdcall Header_OnLButtonDown(int pitem, int a2, int a3, int a4, int a5);
int __stdcall Header_OnInsertItemA(int i, int, int pitem); // idb
int __stdcall Header_WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall ListView_SetSRecompute(int a1);
signed int __stdcall ListView_GetRegIASetting(int a1);
int __stdcall ListView_NotifyCacheHint(int a1, int a2, int a3);
int __stdcall ListView_LazyCreateObjects(int *a1, int a2, int a3);
int __stdcall ListView_LazyCreateWinEvents(int a1, int a2, int a3);
HWND __stdcall ListView_RequestFindItem(int a1, const void *a2, int a3);
BOOL __stdcall ListView_SendChange(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
HWND __stdcall ListView_Notify(int a1, INT_PTR i, int a3, int a4);
signed int __stdcall ListView_GetEmptyText(int a1);
void __stdcall ListView_NotifyFocusEvent(int a1);
int __stdcall ListView_NotifyRecreate(int a1);
int __stdcall ListView_SortCallback(void *p1, void *p2, LPARAM lParam);
int __stdcall ListView_InvalidateTTLastHit(int a1, int a2);
int __stdcall ListView_SortAllColumns(void *Src, LPARAM lParam); // idb
int __stdcall ListView_OnApproximateViewRect(int a1, int a2, int a3, int a4);
signed int __stdcall ListView_OnSetLVRangeObject(int a1, int a2, int a3);
int __stdcall ListView_OnSortItems(void *Src, int, int, int); // idb
struct _IMAGELIST *__stdcall CreateCheckBoxImagelist(HIMAGELIST himl, int a2, HICON hicon, int a4);
LRESULT __stdcall ListView_PopBubble(int a1);
LRESULT __stdcall ListView_OnHelp(int a1, LPARAM lParam);
int __stdcall ListView_OnSetIconSpacing(int a1, int a2);
int __thiscall fShouldFirstClickActivate(LONG this);
// int __stdcall ChildOfDesktop(HWND hWnd); idb
BOOL __stdcall EditBoxHasFocus();
int __stdcall EqualRects(RECT *lprc1, int, int); // idb
int __stdcall ListView_FindWorkArea(int, POINT pt, int); // idb
HRESULT IntToUInt(INT iOperand, UINT *puResult);
int __stdcall ListView_OnGetNumberOfWorkAreas(int a1, int a2);
int __stdcall ListView_OnGetWorkAreas(int, int, LPRECT lprcDst); // idb
BOOL __stdcall ListView_IsItemUnfolded(int a1, int a2);
BOOL __stdcall ListView_IsItemUnfoldedPtr(int a1, int a2);
int __stdcall ListView_SetFocus(HWND hWnd); // idb
void __stdcall ListView_Realize(int a1, HDC hdc, BOOL bForceBkgd, int a4);
int __stdcall RectInRect(RECT *lprcSrc1, RECT *lprcSrc2); // idb
BOOL __stdcall ListView_DeleteHrgnInval(int a1);
int __stdcall ListView_OnSetBkColor(int, COLORREF color); // idb
int __stdcall InitBrushOrg(int, HDC hdc); // idb
void __stdcall ListView_InvalidateRegion(int a1, HRGN hrgnSrc2);
int __stdcall LVSeeThruScroll(HDC hdc, HDC hdcSrc); // idb
int __stdcall ListView_DrawSimpleBackground(int, HDC hDC, RECT *lprc); // idb
int __stdcall ListView_DrawBackground(int, HDC hdc, RECT *lprect); // idb
int __stdcall ListView_OnEraseBkgnd(int, HDC hdc); // idb
void __stdcall ListView_OnCommand(int a1, __int16 a2, HWND hWnd, int a4);
signed int __stdcall GetLVKeyFlags();
int __stdcall ListView_IncrementalSearch(int, int, LPARAM lParam, int); // idb
HLOCAL __stdcall GET_COMP_STRING(HIMC a1, DWORD a2);
signed int __stdcall SameChars(int a1, __int16 a2);
int __stdcall ListView_ComputeCYItemSize(int a1);
int __stdcall ListView_InvalidateCachedLabelSizes(int a1);
int __stdcall ListView_OnStyleChanging(int a1, int a2, int a3);
LONG __stdcall ListView_TypeChange(HDC hdc, __int16 a2);
int __stdcall ListView_OnHitTest(HDC hdc, int); // idb
int __stdcall ScrollAmount(int a1, int a2, signed int a3);
bool __stdcall CanScroll(int a1, int code, int a3);
int __stdcall OrderRect(int a1);
signed int __stdcall ShouldScroll(int a1, int a2, int a3);
int __stdcall ListView_RBeginMarquee(int a1, int a2, int a3, int a4);
int __stdcall ListView_CancelPendingTimer(int, int, UINT_PTR uIDEvent); // idb
UINT_PTR __stdcall ListView_SetupPendingNameEdit(int a1);
int __stdcall ListView_OnHVScroll(int, int, int, int code); // idb
int __stdcall ListView_OnVScroll(int a1, int a2, int a3, int a4);
int __stdcall ListView_OnHScroll(int a1, int a2, int a3, int a4);
int __stdcall ListView_ValidateOneScrollParam(int, int code, int); // idb
signed int __stdcall ListView_ValidateScrollParams(int a1, int *a2, int *a3);
int __stdcall ListView_OnGetImageList(int a1, int a2);
int __stdcall ListView_OnSetImageList(int, HIMAGELIST himl, int); // idb
// signed int __userpurge ListView_OnGetItem@<eax>(int a1@<edi>, HDPA hdpa, int a3);
// int __userpurge ListView_OnGetItemState@<eax>(int a1@<edi>, struct _DPA *a2, int a3, int a4);
// int __userpurge ListView_OnGetItemText@<eax>(int a1@<edi>, struct _DPA *a2, int a3, int a4);
int __stdcall ImgCtxCallback(int a1, int a2);
HLOCAL __stdcall ListView_ReleaseBkImage(int a1);
signed int __stdcall ListView_OnGetBkImageA(int a1, int a2);
HLOCAL __stdcall ListView_FreeSubItem(HLOCAL hMem);
int __stdcall ListView_GetCxScrollbar(int a1);
int __stdcall ListView_GetCyScrollbar(int a1);
int __stdcall ListView_GetWindowStyle(int a1);
int __stdcall ListView_SetScrollInfo(int, int code, LPSCROLLINFO psi, BOOL fRedraw); // idb
int __stdcall ListView_FreeItem(int, LPVOID lpMem); // idb
int __stdcall ListView_CompareString(int, int, LPCWSTR lpString2, char, int); // idb
int __stdcall ListView_GetRects(int, int, int, int, LPRECT lprcDst, LPRECT); // idb
int __stdcall ListView_GetRectsOwnerData(int, int, int, int, LPRECT lprcDst, LPRECT, int); // idb
void __stdcall ListView_InvalidateItemEx(int a1, int a2, int a3, UINT flags, int a5);
signed int __stdcall LV_IsItemOnViewEdge(int a1, int a2);
int __stdcall LV_AdjustViewRectOnMove(int a1, int a2, int a3, int a4);
int __stdcall ListView_OnGetItemPosition(int, INT_PTR i, int); // idb
signed int __stdcall ListView_OnGetOrigin(int a1, int a2);
LONG __stdcall ListView_OnGetStringWidth(int a1, LPCWSTR lpString, HDC hdc);
int __stdcall ListView_OnGetColumnWidth(int, WPARAM wParam); // idb
signed int __stdcall ListView_DrawItem(int a1);
int __stdcall ListView_OnGetTopIndex(int a1);
int __stdcall ListView_OnGetCountPerPage(int a1);
int __stdcall ListView_UnfoldRects(int, INT_PTR i, RECT *lprcSrc1, LPRECT lprc, LPRECT lprcDst, LPRECT); // idb
void __stdcall ListView_SendODChangeAndInvalidate(int a1, int a2, int a3, int a4, int a5);
BOOL __stdcall ListView_EnableWindow(int a1, int a2);
BOOL __stdcall ListView_IsItemVisible(int a1, int a2);
void __stdcall ListView_RecalcRegion(int a1, int puResult, BOOL bRedraw);
// signed int __userpurge ListView_OnSetCursorMsg@<eax>(int a1@<edi>, int a2);
void __stdcall ListView_OnSetHotItem(int a1, int a2);
void __stdcall ListView_OnMouseMove(HDC hdc, int a2, int a3, int a4);
int __stdcall ListView_GetUnfoldedRect(int, INT_PTR i, LPRECT lprc); // idb
HLOCAL __stdcall ListView_OnNCDestroy(HLOCAL hMem);
int __stdcall ListView_InvalidateSelectedOrCutOwnerData(int a1, int a2);
signed int __stdcall ScrollDetect(int a1, int a2, int a3, int *a4, int *a5);
unsigned int __stdcall ListView_UpdateScrollBars(HDC hdc);
int __stdcall ListView_OnSetFont(int a1, void *a2, int a3);
signed int __stdcall ListView_OnGetItemA(int a1, int a2);
int __stdcall ListView_OnGetItemTextA(int a1, int a2, int a3);
int __stdcall ListView_OnSetBkImage(int, STRSAFE_LPCWSTR pszSrc); // idb
const CHAR *__stdcall ListView_OnSetBkImageA(int a1, const void *a2);
signed int __stdcall ListView_OnGetBkImage(int a1, int a2);
int __stdcall ListView_LRInvalidateBelow(HDC hdc, int, int); // idb
LONG __stdcall ListView_IInvalidateBelow(int a1, int a2);
unsigned int __stdcall ListView_OnUpdate(HDC hdc, int a2);
int __stdcall ListView_OnDeleteAllItems(HDPA hdpa); // idb
int __stdcall ListView_IFindNearestItem(int a1, int a2, int a3, int a4);
int __stdcall ListView_Arrow(HDC hdc, int a2, unsigned int a3);
int __stdcall ListView_OnGetNextItem(HDC a1, int a2, int a3);
int __stdcall ListView_OnFindItem(int a1, signed int a2, int a3);
signed int __stdcall ListView_OnGetItemRect(int a1, int a2, struct tagRECT *a3);
signed int __stdcall ListView_OnRedrawItems(int a1, int a2, int a3);
int __stdcall ListView_OnSetItemPosition(int, INT_PTR i, int, int); // idb
const WCHAR *__stdcall ListView_OnGetStringWidthA(int a1, LPCSTR lpMultiByteStr, HDC hdc);
LRESULT __stdcall ListView_ISetColumnWidth(int a1, WPARAM wParam, int a3, int a4);
int __stdcall SHDrawText(HDC hdc, int, RECT *lprc, int, int, int, int, int, COLORREF color); // idb
HGDIOBJ __stdcall ListView_OnCreateDragImage(int nHeight, INT_PTR i, HGDIOBJ h);
void __stdcall ListView_InvalidateFoldedItem(int a1, INT_PTR i, int a3, UINT flags);
unsigned int __stdcall LV_OnShowWindow(HDC a1, int a2);
int __stdcall ListView_BullyIconsOnWorkarea(int, HDPA hdpa); // idb
int __stdcall ListView_OnSetWorkAreas(int, void *p, RECT *lprc); // idb
signed int __stdcall LVGenerateDragImage(signed int a1, int a2);
HLOCAL __stdcall ListView_OnDestroy(HDPA hdpa);
unsigned int __stdcall ListView_OnWindowPosChanged(HDC hdc, unsigned int a2);
BOOL __stdcall ListView_RedrawSelection(int a1);
void __stdcall ListView_OnSetFocus(int a1, int a2);
void __stdcall ListView_OnKillFocus(int a1, int a2);
int __stdcall ListView_DeselectAll(INT_PTR i, int a2);
int __stdcall ListView_OnScroll(HDC hdc, int, int); // idb
int __stdcall ListView_OnEnsureVisible(HDC hdc, int, int); // idb
int __stdcall ListView_OnSetRedraw(HDC hdc, int); // idb
int __stdcall ListView_OnSetItem(INT_PTR i, INT_PTR a2);
int __stdcall ListView_OnSetItemState(INT_PTR i, int, int, int); // idb
int __stdcall ListView_IsItemUnfolded2(int, int, int, STRSAFE_LPWSTR pszDest, int); // idb
int __stdcall ListView_OnSetItemText(INT_PTR a1, int a2, int a3, int a4);
int __stdcall ListView_CreateItem(int a1, int a2);
int __stdcall ListView_OnInsertItem(HDC hdc, int); // idb
int __stdcall ListView_OnDeleteItem(LPVOID lpMem, int i); // idb
signed int __stdcall ListView_OnFindItemA(int a1, signed int a2, int a3);
void __stdcall ListView_Redraw(WPARAM wParam, HDC hdc, int a3);
int __stdcall ListView_OnSetItemCount(HDC hdc, int cp, int); // idb
int __stdcall ListView_InitCheckBoxes(INT_PTR i, int); // idb
INT_PTR __stdcall ListView_ExtendedStyleChange(INT_PTR i, int a2, int a3);
int __stdcall ListView_OnNotify(HDC, int, int); // idb
int __stdcall ListView_OnWinIniChange(INT_PTR i, int, int); // idb
void __stdcall ListView_OnPaint(WPARAM wParam, int a2);
// void __userpurge ListView_ToggleSelection(int a1@<edi>, INT_PTR i, int a3);
void *__stdcall ListView_SetFocusSel(INT_PTR i, void *p, int a3, int a4, int a5);
int __stdcall ListView_OnImeComposition(LPCWSTR lpString, int, HLOCAL hMem); // idb
void __stdcall ListView_OnChar(LPCWSTR lpString, void *p, int a3);
LRESULT __stdcall ListView_OnStyleChanged(HDC hdc, int a2, int a3);
HRGN __stdcall ListView_DragSelect(HDC hdc, int a2, int a3);
int __stdcall ListView_HandleStateIconClick(INT_PTR i, int); // idb
int __stdcall ListView_OnTimer(HDC hdc, UINT_PTR uIDEvent); // idb
LPCSTR __stdcall ListView_OnSetItemA(INT_PTR a1, INT_PTR a2);
LPCSTR __stdcall ListView_OnSetItemTextA(int a1, int a2, int a3, LPCSTR lpMultiByteStr);
int __stdcall ListView_OnInsertItemA(HDC hdc, int); // idb
// void __userpurge ListView_SelectRangeTo(int a1@<edi>, void *p, void *a3, int a4);
__int16 __stdcall ListView_OnKey(HCURSOR hCursor, int wParam, int a3, int a4, int a5);
// int __userpurge ListView_ButtonSelect@<eax>(int a1@<edi>, INT_PTR i, void *p, int a4, int a5);
int __stdcall ListView_HandleMouse(HWND hWnd, int, int, int, int, int); // idb
int __stdcall ListView_OnButtonDown(HWND hWnd, int, int, int, int); // idb
HWND __stdcall ListView_OnMouseHover(HDC hdc, int a2, int a3, int a4);
INT_PTR __stdcall ListView_WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall LIncrWord(int a1, int a2, int a3, int a4);
signed int __stdcall CmpDate(int a1, int a2);
signed int __stdcall CmpSystemtime(int a1, int a2);
int __stdcall DaysBetweenDates(int a1, int a2);
int __stdcall GetStartDowForMonth(signed int a1, signed int a2);
int __stdcall DowFromDate(int a1);
signed int __stdcall GetDaysForMonth(signed int a1, int a2);
signed int __stdcall GetWeekNumber(int a1, int a2, int a3);
int __stdcall IsValidDate(int a1);
BOOL __stdcall IsValidTime(int a1);
int __stdcall IsValidSystemtime(int a1);
int __stdcall IncrSystemTime(int a1, int a2, int a3, int a4);
int __stdcall ListView_RefoldLabelRect(int a1, int a2, int a3);
int __stdcall ListView_GetSlotCountEx(int a1, int a2, int a3);
int __stdcall ListView_GetSlotCount(int a1, int a2);
int __stdcall LV_GetItemPixelRow(int a1, int a2);
int __stdcall LV_GetMaxPlacedItem(int a1);
int __stdcall NearestSlot(int a1, int a2, signed int a3, signed int a4, int a5);
int __stdcall ListView_CalcHitSlot(int a1, signed int a2, signed int a3, signed int a4);
int __stdcall _GetCurrentItemSize(int a1, int a2, int a3);
int __stdcall ListView_IApproximateViewRect(int a1, int a2, int a3, int a4);
LONG __stdcall _CalcSlotRect(int a1, int a2, int a3, int a4, int a5, LPRECT lprc);
signed int __stdcall ListView_SetIconPos(int a1, int a2, int a3, int a4);
int __stdcall ArrangeIconCompare(void *p1, void *p2, LPARAM lParam);
int __stdcall ListView_ComOnScroll(HDC hdc, int, int, int code, int, int); // idb
int __stdcall ListView_IScroll2_SmoothScroll(HWND hWnd, int, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags); // idb
int __stdcall ListView_IScroll2(HDC hdc, int, int, int); // idb
int __stdcall ListView_IOnScroll(HDC hdc, int, int, int code); // idb
int __stdcall ListView_IGetScrollUnitsPerLine(int a1, int a2);
int __stdcall ListView_ChangeEditRectForRegion(int, RECT *lprc2); // idb
LRESULT __stdcall RescrollEditWindow(HWND hWnd);
signed int __stdcall ListView_DismissEdit(int a1, signed int a2);
HWND __stdcall CreateEditInPlaceWindow(HWND hWnd, LPCWSTR lpWindowName, WPARAM wParam, DWORD dwStyle, WPARAM a5);
COLORREF __stdcall ListView_DrawBorderSel(HIMAGELIST himl, int a2, HDC hdc, int a4, int a5, COLORREF color);
int __stdcall ListView_DrawImageEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, char, int); // idb
HIMC __stdcall ListView_SizeIME(HWND hWnd);
unsigned int __stdcall sub_6F7CC344(HIMC a1, DWORD a2, int a3);
signed int __stdcall ListView_IDrawItem(int a1);
int __stdcall ListView_CalcMinMaxIndex(int a1, int a2, int a3, int a4);
HWND __stdcall ListView_DoOnEditLabel(HDC hdc, INT_PTR i, int a3);
int __stdcall ListView_RecomputeLabelSize(int a1, int a2, int a3, HDC a4, int a5);
int __stdcall SetEditInPlaceSize(HWND hWnd, LPRECT lprcDst, int, int); // idb
WPARAM __stdcall DrawCompositionLine(HWND hWnd, HDC hdc, HGDIOBJ h, int a4, int a5, WPARAM wParam, int a7, int a8);
HIMC __stdcall ListView_PaintComposition(HWND a1, int a2);
int __stdcall ListView_IGetRectsOwnerData(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall ListView_IsCleanRect(int, RECT *lprcSrc2, int, int, int); // idb
int __stdcall ListView_FindFreeSlot(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
signed int __stdcall ListView_SetEditSize(int a1);
int __stdcall ListView_InsertComposition(HWND hWnd, int, int, int); // idb
void __stdcall ListView_Recompute(int a1);
int __stdcall ListView_GetViewRect2(int, LPRECT lprc, int, int); // idb
int __stdcall ListView_GetClientRect(int a1, int a2, int a3, int a4);
UINT __stdcall ListView_IUpdateScrollBars(HDC hdc);
int __stdcall ListView_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam); // idb
int __stdcall ListView_OnEditLabel(HDC hdc, INT_PTR i, int); // idb
int __stdcall ListView_IItemHitTest(int, POINT pt, int, int); // idb
int __stdcall ListView_IGetRects(int a1, int a2, int a3, int a4, int a5);
int __stdcall _ListView_GetRectsFromItem(int, int, int, RECT *lprcSrc1, RECT *lprcSrc2, LPRECT lprcDst, LPRECT); // idb
int __stdcall _ListView_InvalidateItemPtr(int, int, int, UINT flags); // idb
int __stdcall ListView_IUnstackOverlaps(int, HDPA hdpa, int); // idb
int __stdcall ListView_SnapToGrid(int, HDPA hdpa); // idb
int __stdcall ListView_CommonArrangeEx(HDC hdc, int, HDPA hdpa, int); // idb
int __stdcall ListView_CommonArrange(HDC hdc, int, HDPA hdpa); // idb
int __stdcall ListView_OnArrange(HDC hdc, int); // idb
int __stdcall ListView_ScaleIconPositions(HDC hdc, int); // idb
int __stdcall TV_DrawDescender(int, HDC hdc, int x, int, int); // idb
int __stdcall TV_EraseDescender(int, HDC hDC, int, int, int); // idb
int __stdcall TV_DrawKinDescender(int, HDC hdc, int x, int, int, char); // idb
COLORREF __stdcall TV_GetInsertMarkColor(int a1);
HGDIOBJ __stdcall TV_CreateDragImage(HDC hdc, int a2);
int __stdcall TV_GenerateDragImage(HDC hdc, int); // idb
int __stdcall TV_GetNext(int a1);
int __stdcall TV_VertScroll(int a1, int a2, int a3);
int __stdcall TV_CompareItems(int a1, int a2, int a3);
int __stdcall TV_SortChildrenCB(int a1, LPARAM a2, int a3);
signed int __stdcall TV_ScrollBarsAfterRemove(int a1, int a2);
signed int __stdcall TV_ScrollBarsAfterCollapse(int a1, int a2);
int __stdcall TV_ScrollBarsAfterResize(int, int, int, UINT flags); // idb
int __stdcall TV_DeleteItemRecurse(int, LPVOID lpMem, int); // idb
int __stdcall TV_DeleteItem(int, LPVOID lpMem, int); // idb
LONG __stdcall TV_DestroyTree(HLOCAL hMem);
LRESULT __stdcall TV_CreateToolTips(int a1);
int __stdcall ListView_LApproximateViewRect(int a1, int a2, int a3, signed int a4);
int __stdcall ListView_LItemHitTest(int a1, int a2, signed int a3, int a4, int a5);
int __stdcall ListView_LGetRects(HDC a1, signed int a2, int a3, int a4, int a5, int a6);
int __stdcall ListView_LOnScroll(HDC hdc, int, int, int); // idb
signed int __stdcall ListView_LGetScrollUnitsPerLine(int a1, int a2);
int __stdcall ListView_LCalcViewItem(int a1, int a2, signed int a3);
int __stdcall LV_GetNewColWidth(int a1, int a2, int a3);
signed int __stdcall ListView_MaybeResizeListColumns(int a1, int a2, int a3);
signed int __stdcall ListView_LDrawItem(int a1);
int __stdcall ListView_LScroll2_SmoothScroll(HWND hWnd, int, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags); // idb
BOOL __stdcall ListView_LScroll2(int a1, int a2, int a3, int a4);
int __stdcall ListView_LUpdateScrollBars(int a1);
void __stdcall ListView_RInitialize(int a1, int a2);
int __stdcall CCDrawRect(HDC hdc, int, int, int, int); // idb
void __stdcall ListView_RAfterRedraw(WPARAM wParam, HDC hdc);
int __stdcall ListView_RGetCXLabel(int a1, int a2, int a3, int a4, int a5);
int __stdcall ListView_CreateHeader(int a1);
LRESULT __stdcall ListView_OnInsertColumn(int a1, WPARAM wParam, int a3);
int __stdcall ListView_FreeColumnData(void *p, void *pData);
int __stdcall ListView_RGetColumnWidth(int, WPARAM wParam); // idb
unsigned int __stdcall ListView_BeginFakeCustomDraw(int a1, LPARAM lParam, int a3);
int __stdcall ListView_BeginFakeItemDraw(LPARAM lParam); // idb
void __stdcall ListView_EndFakeItemDraw(LPARAM lParam);
int __stdcall ListView_EndFakeCustomDraw(LPARAM lParam); // idb
LRESULT __stdcall ListView_OnGetColumn(int a1, WPARAM wParam, int a3);
int __stdcall ListView_OnSetColumn(int, WPARAM wParam, int); // idb
int __stdcall ListView_RDestroyColumn(void *p, void *pData);
void __stdcall ListView_RDestroy(int a1);
HDC __stdcall ListView_RHeaderTrack(HDC hdc, int a2);
BOOL __stdcall ListView_AdjustColumn(HDC a1, int a2);
HWND __stdcall ListView_ForwardHeaderNotify(int a1, LPARAM lParam);
int __stdcall ListView_GetSubItem(int, INT_PTR i, int, int); // idb
int __stdcall ListView_RGetTotalColumnWidth(int a1);
int __stdcall ListView_RGetRects(int a1, int a2, int a3, int a4, int a5, int a6);
signed int __stdcall ListView_RXHitTest(int a1, LPARAM a2);
int __stdcall ListView_NeedsEllipses(HDC hdc, LPCWSTR lpString, int, int, int); // idb
int __stdcall ListView_RScroll2_SmoothScroll(HWND hWnd, int, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags); // idb
int __stdcall ListView_RScroll2(int a1, __int64 a2, int a3);
signed int __stdcall ListView_ROnEnsureVisible(int a1, int a2, int a3);
int __stdcall ListView_ROnScroll(HDC hdc, int, int, int code); // idb
signed int __stdcall ListView_RGetScrollUnitsPerLine(int a1, int a2);
int __stdcall ListView_RApproximateViewRect(int a1, int a2, int a3, int a4);
LRESULT __stdcall ListView_OnInsertColumnA(int a1, WPARAM wParam, int a3);
int __stdcall ListView_OnDeleteColumn(int, WPARAM wParam); // idb
BOOL __stdcall hasVertScroll(int a1);
LRESULT __stdcall ListView_RSetColumnWidth(int a1, WPARAM wParam, int a3);
int __stdcall ListView_OnGetColumnA(int, WPARAM wParam, int); // idb
LPCSTR __stdcall ListView_OnSetColumnA(int a1, WPARAM wParam, int a3);
int __stdcall ListView_HeaderNotify(HDC hdc, LPARAM); // idb
int __stdcall ListView_RItemHitTest(int a1, LPARAM a2, int a3, int a4, int a5);
int __stdcall ListView_RGetRectsEx(int, int, WPARAM wParam, int, int); // idb
int __stdcall ListView_OnGetSubItemRect(int, int, LPRECT lprcDst); // idb
int __stdcall ListView_OnSubItemHitTest(HDC hdc, int); // idb
int __stdcall ListView_RUpdateScrollBars(int a1);
signed int __stdcall ListView_RDrawItem(int a1);
int __stdcall ListView_SetSubItem(HDPA hdpa, INT_PTR i); // idb
int __stdcall ListView_SGetRectsOwnerData(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall ListView_SGetRects(int a1, int a2, int a3, int a4, int a5);
int __stdcall ListView_DoLookupString(int, LPCWSTR lpString2, char, int, int); // idb
int __stdcall ListView_LookupString(int, LPCWSTR lpString2, char, int); // idb
int __stdcall ListView_SItemHitTest(int, POINT pt, int, int); // idb
int __stdcall LoadMLFontLink(struct IMLangFontLink **); // idb
signed int __stdcall FDoFontLink(HDC hdc, struct IMLangFontLink **a2, const unsigned __int16 *a3, int cchWideChar);
signed int __stdcall FDoFontLink(HDC a1, struct IMLangFontLink **a2, unsigned __int16 a3, unsigned __int16 a4);
int __stdcall _GetCharWidthWFontLink(HDC hdc, WCHAR WideCharStr, unsigned __int16, LPINT lpBuffer); // idb
int __stdcall GetCharWidthWrap(HDC hdc, int WideCharStr, int iLast, LPINT lpBuffer);
int __stdcall _OtherGetTextExtentPointW(HDC hdc, const unsigned __int16 *, int, LPSIZE lpsz); // idb
int __stdcall _GetTextExtentPointWFontLink(HDC hdc, LPCWSTR lpWideCharStr, int cchWideChar, LPSIZE lpsz); // idb
int __stdcall GetTextExtentPointWrap(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz); // idb
int __stdcall GetTextExtentPoint32Wrap(HDC, const unsigned __int16 *, int, struct tagSIZE *); // idb
int __stdcall _OtherExtTextOutW(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpString, UINT c, INT *lpDx); // idb
// unsigned int __userpurge _ExtTextOutWFontLink@<eax>(int a1@<edi>, HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpWideCharStr, unsigned int cchWideChar, INT *lpDx);
unsigned int __stdcall ExtTextOutWrap(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpString, UINT c, INT *lpDx);
unsigned int __stdcall TextOutWrap(HDC hdc, int x, int y, LPCWSTR lpString, UINT c);
int __stdcall UserIsFELineBreakEnd(unsigned __int16); // idb
int __stdcall UserIsFullWidth(unsigned __int16); // idb
int sub_6F7D3DC2(); // weak
int __stdcall GetNextWordbreak(const unsigned __int16 *a1, const unsigned __int16 *a2, unsigned __int32 a3, struct DRAWTEXTDATA *a4);
int __stdcall GetPrefixCount(const unsigned __int16 *a1, int a2, unsigned __int16 *a3, int a4);
LONG __stdcall KKGetPrefixWidth(HDC hdc, LPCWSTR lpString, int a3);
void __stdcall PSMTextOut(HDC hdc, int xLeft, int y, LPCWSTR lpString, UINT c, unsigned __int32); // idb
LONG __stdcall DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpString, int c, unsigned int a4, int a5);
int __stdcall DT_DrawStr(HDC hdc, int xLeft, int y, LPCWSTR lpString, UINT c, int, unsigned __int32, const struct DRAWTEXTDATA *); // idb
void __stdcall DT_DrawJustifiedLine(HDC hdc, int y, LPCWSTR lpString, UINT c, unsigned __int32, struct DRAWTEXTDATA *); // idb
int __stdcall DT_InitDrawTextInfo(HDC hdc, const struct tagRECT *, unsigned int, struct DRAWTEXTDATA *, const struct tagDRAWTEXTPARAMS *); // idb
const unsigned __int16 *__stdcall DT_AdjustWhiteSpaces(const unsigned __int16 *, int *, unsigned int); // idb
const unsigned __int16 *__stdcall DT_BreakAWord(HDC hdc, LPCWSTR lpString, int, int, unsigned int, int); // idb
LPCWSTR __stdcall DT_GetLineBreak(HDC hdc, LPCWSTR lpString, int a3, unsigned __int32 a4, int *a5, struct DRAWTEXTDATA *a6);
int __stdcall NeedsEndEllipsis(HDC hdc, LPCWSTR lpString, int *, const struct DRAWTEXTDATA *, unsigned int); // idb
const unsigned __int16 *__stdcall PathFindFileNameW(const unsigned __int16 *a1, int a2);
int __stdcall AddPathEllipsis(HDC hdc, LPCWSTR lpString, int, unsigned int, int, int); // idb
int __stdcall IsComplexScriptPresent(const unsigned __int16 *, int); // idb
HRESULT __stdcall StringCchCopyNW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy);
size_t __stdcall AddEllipsisAndDrawLine(HDC hdc, int y, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy, unsigned __int32 a5, struct DRAWTEXTDATA *const a6);
LONG __stdcall DrawTextExPrivWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp);
LONG __stdcall DrawTextWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format);
int __stdcall WimpyDrawEx(struct IImageList *a1, int a2, HDC a3, int a4, int a5, int a6, int a7, unsigned __int32 a8, unsigned __int32 a9, unsigned int a10);
int __stdcall WimpyDraw(struct IImageList *a1, int a2, HDC a3, int a4, int a5, unsigned int a6);
__int32 __stdcall CImageList::GetPrivateGoo(CImageList *this, HBITMAP *, HDC *, HBITMAP *, HDC *); // idb
int __stdcall CImageList::GetMirror(CImageList *this, const struct _GUID *a2, void **a3);
int __stdcall GetScreenDepth(); // idb
void __stdcall ImageList_ReleaseWorkDC(HDC hdc); // idb
int __thiscall CImageList::_SetIconSize(CImageList *this, int a2, int a3);
int __stdcall CImageList::SetIconSize(CImageList *this, int a2, int a3);
signed int __stdcall CImageList::SetFlags(CImageList *this, unsigned int a2);
__int32 __stdcall CImageList::GetFlags(CImageList *this, unsigned int *); // idb
HGDIOBJ __stdcall CImageList::_CreateMirroredBitmap(HBITMAP h);
signed int __stdcall CImageList::SetColorTable(CImageList *this, UINT iStart, UINT cEntries, RGBQUAD *prgbq, int *a5);
void __thiscall CImageList::_RemoveItemBitmap(CImageList *this, int); // idb
void __stdcall BlendCT(unsigned __int32 *, unsigned __int32, unsigned int, unsigned int); // idb
void __stdcall ImageList_BlendDither(HDC hdc, int x, int y, struct CImageList *, int x1, int y1, int w, int h, COLORREF color, unsigned int); // idb
void __stdcall ImageList_BlendCT(HDC hdc, int xDest, int yDest, struct CImageList *, int xSrc, int, int DestWidth, int DestHeight, unsigned __int32, char); // idb
void __stdcall Blend16(unsigned __int16 *, int, unsigned __int16 *, int, int, int, unsigned __int32, int); // idb
int __thiscall CImageList::_MoreOverlaysUsed(CImageList *__hidden this); // idb
__int32 __stdcall Stream_WriteBitmap(struct IStream *, HBITMAP h, UINT start); // idb
int __thiscall CImageList::GetSpareImageRect(CImageList *this, struct tagRECT *); // idb
void __thiscall CImageList::_CopyOneImage(CImageList *this, int, int, int, struct CImageList *, int); // idb
HDC __stdcall ImageList_GetDragDC(); // idb
void __stdcall ImageList_ReleaseDragDC(HDC hdc); // idb
signed int __stdcall CImageList::DragShowNolock(CImageList *this, int a2);
int __stdcall CImageList::GetDragImage(CImageList *this, struct tagPOINT *a2, struct tagPOINT *a3, const struct _GUID *a4, void **a5);
signed int __stdcall CImageList::GetOverlayImage(CImageList *this, int a2, int *a3);
void __stdcall ImageList_EndDrag();
BOOL __stdcall ImageList_DragEnter(HWND hwndLock, int x, int y);
BOOL __stdcall ImageList_DragMove(int x, int y);
BOOL __stdcall ImageList_DragLeave(HWND hwndLock);
BOOL __stdcall ImageList_DragShowNolock(BOOL fShow);
int __stdcall CControl::v_OnNCCalcSize(unsigned int a2, __int32 a3, __int32 *a4);
signed int __stdcall CImageList::GetIcon(CImageList *this, int a2, unsigned int a3, HICON *a4);
signed int __thiscall CImageList::_Remove(CImageList *this, int a2);
signed int __stdcall CImageList::Remove(CImageList *this, int a2);
// int __userpurge CImageList::_IsSameObject@<eax>(CImageList *this@<ecx>, int a2@<esi>, struct IUnknown *a3);
signed int __stdcall CImageList::Copy(CImageList *this, int a2, struct IUnknown *a3, int a4, unsigned int cy);
void __stdcall ImageList_Blend16(HDC hdcSrc, int x1, int y1, struct CImageList *, int, int, int, int cy, unsigned __int32, unsigned int); // idb
void __stdcall ImageList_Blend(HDC hdc, int x, int y, struct CImageList *a4, int x1, int y1, int w, int h, COLORREF color, int a10);
// __int32 __userpurge CImageList::CopyDitherImage@<eax>(int a1@<edi>, CImageList *this, unsigned __int16 a3, int a4, int a5, struct IUnknown *a6, int a7, unsigned int a8);
void __thiscall CImageList::_Merge(CImageList *this, HDC hdcSrc, int, int x, int); // idb
__int32 __stdcall CImageList::Save(CImageList *this, struct IStream *, int); // idb
__int32 __stdcall CImageList::DragMove(CImageList *this, int, int); // idb
signed int __stdcall CImageList::DragEnter(CImageList *this, HWND a2, int a3, int a4);
signed int __stdcall CImageList::DragLeave(CImageList *this, HWND a2);
__int32 __stdcall CImageList::EndDrag(CImageList *this); // idb
BOOL __stdcall ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);
HIMAGELIST __stdcall ImageList_GetDragImage(POINT *ppt, POINT *pptHotspot);
BOOL __stdcall ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);
int __thiscall ImageList_CopyDitherImage(void *this, struct _IMAGELIST *a2, int a3, int a4, int a5, struct _IMAGELIST *a6, int a7, int a8);
BOOL __stdcall ImageList_Write(HIMAGELIST himl, struct IStream *pstm);
int __stdcall ImageList_GetImageRect(struct _IMAGELIST *, int, int); // idb
BOOL __stdcall ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
int __stdcall ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
int __stdcall ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
BOOL __stdcall ImageList_Remove(HIMAGELIST himl, int i);
HICON __stdcall ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags);
BOOL __stdcall ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags);
BOOL __stdcall ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);
HIMAGELIST __stdcall ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);
int __stdcall ImageList_SetFlags(struct _IMAGELIST *, int); // idb
int __stdcall ImageList_SetColorTable(struct _IMAGELIST *, int, int, int); // idb
int __stdcall ImageList_GetFlags(struct _IMAGELIST *); // idb
__int32 __stdcall CImageList::GetClassID(CImageList *this, struct _GUID *); // idb
signed int __stdcall CImageList::IsDirty(CImageList *this);
signed int __stdcall CImageList::GetSizeMax(CImageList *this, union _ULARGE_INTEGER *a2);
unsigned __int32 __stdcall CImageList::AddRef(int a1);
unsigned __int32 __stdcall CImageList::AddRef(int a1);
unsigned __int32 __stdcall CImageList::AddRef(int a1);
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3);
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3);
HDC __stdcall ImageList_GetWorkDC(HDC hdc, int, int cy); // idb
signed int __stdcall CImageList::SetImageCount(CImageList *this, unsigned int a2);
int __thiscall CImageList::_AddValidated(CImageList *this, HBITMAP h, HBITMAP a3, int *a4);
int __stdcall CImageList::Add(HGDIOBJ ho, HBITMAP h, HBITMAP a3, int *a4);
signed int __thiscall CImageList::_ReplaceValidated(CImageList *this, int a2, HBITMAP h, HBITMAP a4);
signed int __stdcall CImageList::Replace(HGDIOBJ ho, int a2, HBITMAP h, HBITMAP a4);
int __thiscall CImageList::_ReplaceIcon(CImageList *this, int a2, HICON h, int *a4);
int __stdcall CImageList::ReplaceIcon(HICON h, int a2, HICON hIcon, int *a4);
int __thiscall CImageList::CreateDragBitmaps(CImageList *__hidden this); // idb
int __stdcall ImageList_AddIcon(HIMAGELIST himl, HICON hicon); // idb
// __int32 __userpurge CImageList::_Merge@<eax>(CImageList *this@<ecx>, int a2@<edi>, int a3, struct IUnknown *h, int a5, int xLeft, int yTop, struct CImageList **a8);
// int __userpurge CImageList::Merge@<eax>(int a1@<edi>, CImageList *this, int a3, struct IUnknown *h, int a5, int xLeft, int yTop, const struct _GUID *a8, void **a9);
int __stdcall ImageList_MergeDragImages(int xLeft, CImageList *); // idb
int __stdcall ImageList_SetDragImage(struct _IMAGELIST *, int, int xLeft, CImageList *); // idb
signed int __stdcall CImageList::SetDragCursorImage(CImageList *this, struct IUnknown *a2, int a3, int xLeft, CImageList *a5);
signed int __stdcall CImageList::BeginDrag(CImageList *this, int a2, int xLeft, CImageList *a4);
HIMAGELIST __stdcall ImageList_Clone(struct _IMAGELIST *a1, int a2, int cy, UINT flags, int cInitial, int cGrow);
LONG __stdcall CImageList::Release(int a1);
LONG __stdcall CImageList::Release(int a1);
HLOCAL __thiscall CByteStream::~CByteStream(CByteStream *this);
char __thiscall CByteStream::GrowBuffer(CByteStream *this, int a2);
unsigned __int8 *__thiscall CByteStream::GetBuffer(CByteStream *this, bool); // idb
void __thiscall CByteStream::Reset(CByteStream *__hidden this); // idb
void *__thiscall CByteStream::CByteStream(void *this, signed int a2);
size_t __thiscall CByteStream::Write(CByteStream *this, const void *Src, size_t Size);
int __thiscall CByteStream::Align(int this, int a2, int a3);
size_t __stdcall CDlgTemplateConverter::CopyStringW(struct CByteStream *a2, LPCWSTR lpString, int a4);
CByteStream *__thiscall CByteStream::operator<<<unsigned long>(CByteStream *this, void *Src);
CByteStream *__thiscall CByteStream::operator<<<short>(CByteStream *this, void *Src);
CByteStream *__thiscall CByteStream::operator<<<unsigned char>(CByteStream *this, void *Src);
int __thiscall CDlgTemplateConverter::CDlgTemplateConverter(int this, int a2);
int __thiscall CDlgTemplateConverter::DlgHdrToDlgEx(CDlgTemplateConverter *this, struct CByteStream *a2, unsigned __int16 **a3);
int __thiscall CDlgTemplateConverter::DlgItemToDlgEx(CDlgTemplateConverter *this, struct CByteStream *a2, unsigned __int16 **a3);
int __thiscall CDlgTemplateConverter::DlgToDlgEx(CDlgTemplateConverter *this, struct DLGTEMPLATE *a2, struct tagDLGTEMPLATEEX **a3);
int __stdcall CvtDlgToDlgEx(struct DLGTEMPLATE *, struct tagDLGTEMPLATEEX **, int); // idb
int __stdcall GetItemObject(int, int, int, LPARAM lParam); // idb
signed int __stdcall GetDragProxyTarget(int a1, int a2);
int __stdcall CDragProxy::Drop(CDragProxy *this, struct IDataObject *a2, unsigned __int32 a3, struct _POINTL a4, unsigned __int32 *a5);
int __thiscall CDragProxy::CallCB(CDragProxy *this, unsigned int a2, unsigned int a3, __int32 a4);
int __thiscall CDragProxy::Register(struct IDropTarget *this); // idb
void __thiscall CDragProxy::RevokeAndFreeCB(CDragProxy *__hidden this); // idb
int __stdcall DestroyDragProxy(CDragProxy *); // idb
signed int __stdcall CDragProxy::QueryInterface(CDragProxy *this, const struct _GUID *a2, void **a3);
signed int __stdcall CDragProxy::DragEnter(CDragProxy *this, struct IDataObject *a2, unsigned __int32 a3, struct _POINTL a4, unsigned __int32 *a5);
void __thiscall CDragProxy::UpdateSelection(CDragProxy *this, unsigned __int32); // idb
int __thiscall CDragProxy::CDragProxy(int this, int a2, int a3);
void __thiscall CDragProxy::SetDropTarget(CDragProxy *this, struct IDropTarget *); // idb
int __stdcall CreateDragProxy(int a1, int a2, int a3);
__int32 __stdcall CDragProxy::DragLeave(CDragProxy *this); // idb
void __thiscall CDragProxy::SetTargetItem(CDragProxy *this, int, unsigned __int32); // idb
__int32 __thiscall CDragProxy::~CDragProxy(CDragProxy *this);
void *__thiscall CDragProxy::`scalar deleting destructor'(void *lpMem, char a2);
int __stdcall CDragProxy::DragOver(CDragProxy *this, unsigned __int32 a2, struct _POINTL a3, unsigned __int32 *a4);
unsigned __int32 __stdcall CDragProxy::Release(CDragProxy *this); // idb
int __thiscall CControl::v_OnStyleChanged(CControl *this, unsigned int a2, __int32 a3);
void __thiscall CControl::_OnPaint(CControl *this, HDC); // idb
void __thiscall CPager::_DrawBlank(CPager *this, HDC hDC, int); // idb
__int32 __thiscall CPager::v_OnCommand(CPager *this, WPARAM wParam, __int32); // idb
HWND __thiscall CPager::v_OnNotify(CPager *this, unsigned int a2, __int32 lParam);
void __thiscall CPager::_GetChildSize(CPager *__hidden this); // idb
void __thiscall CPager::_SetChildPos(CPager *this, const struct tagRECT *, unsigned int); // idb
int __thiscall CPager::_PGFToPGNDirection(CPager *this, unsigned __int32 a2);
struct tagRECT *__thiscall CPager::_GetButtonRect(CPager *this, LPRECT lpRect, int); // idb
void __thiscall CPager::_OnReCalcSize(CPager *this); // idb
void __thiscall CPager::_OnSetPos(CPager *this, int); // idb
int __thiscall CPager::_OnGetPos(CPager *__hidden this); // idb
unsigned __int32 __thiscall CPager::_GetButtonState(CPager *this, int); // idb
void __thiscall CPager::_KillTimer(CPager *__hidden this); // idb
int __thiscall CPager::_OnSetBorder(CPager *this, int); // idb
int __thiscall CPager::_OnSetButtonSize(CPager *this, int); // idb
int __stdcall DrawChar(HDC hdc, COLORREF color, unsigned int, WCHAR chText, unsigned int, UINT format, int); // idb
void __stdcall DrawBlankButton(HDC hdc, LPRECT lprc, unsigned __int32); // idb
void __stdcall DrawCharButton(HDC hdc, RECT *lprcSrc, unsigned __int32, WCHAR chText, unsigned int, UINT format, int); // idb
int __stdcall DrawScrollArrow(HDC hdc, HGDIOBJ h, unsigned __int32); // idb
HGDIOBJ __stdcall DrawChevron(HDC hdc, RECT *lprcSrc, int y);
int __thiscall CPager::CPager(int this);
__int32 __stdcall CPager::PagerWndProc(HWND hWnd, unsigned int, unsigned int, __int32); // idb
int __thiscall CControl::v_WndProc(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __thiscall CPager::_HitTestScreen(CPager *this, const struct tagPOINT *); // idb
int __thiscall CPager::_HitTest(CPager *this, int, int); // idb
void __thiscall CPager::_DrawButton(CPager *this, HDC hdc, int); // idb
void __thiscall CPager::v_OnNCPaint(CPager *this); // idb
int __thiscall CPager::_OnPrint(CPager *this, HDC hdc, LPARAM lParam); // idb
void __thiscall CPager::v_OnSize(CPager *this, int, int); // idb
void __thiscall CPager::_Scroll(CPager *this, unsigned __int32); // idb
void __thiscall CPager::_OnMouseLeave(CPager *this); // idb
void __thiscall CPager::_OnMouseMove(CPager *this, char, __int32); // idb
void __thiscall CPager::_OnSetChild(CPager *this, HWND hWnd, HWND); // idb
signed int __thiscall CPager::_DragCallback(CPager *this, HWND a2, unsigned int a3, unsigned int a4, __int32 a5);
int __thiscall CPager::_HitTestCursor(CPager *this); // idb
void __thiscall CPager::_OnLButtonChange(CPager *this, unsigned int, __int32); // idb
void __thiscall CPager::_OnTimer(CPager *this, unsigned int); // idb
signed int __stdcall CPager::PagerDragCallback(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4);
void __thiscall CPager::_NeedScrollbars(CPager *this, struct tagRECT); // idb
int __thiscall CPager::v_OnNCCalcSize(CPager *this, WPARAM wParam, LPARAM lParam, __int32 *); // idb
int __thiscall CPager::v_OnStyleChanged(CPager *this, unsigned int a2, __int32 a3);
signed int __thiscall CPager::v_OnCreate(CPager *this);
signed int __thiscall CPager::v_WndProc(CPager *this, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
signed int CNativeFont::v_OnCreate();
signed int __stdcall CNativeFont::_GetFontAssocStatus(enum FASTATUS *a1);
__int32 __stdcall CNativeFont::NativeFontWndProc(HWND hWnd, unsigned int, unsigned int, __int32); // idb
BOOL __thiscall CNativeFont::_GetNativeDialogFont(CNativeFont *this, HWND hWnd);
LRESULT __stdcall CNativeFont::_SubclassDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int __thiscall CNativeFont::v_WndProc(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int __stdcall LoadFile(LPCWSTR lpFileName, unsigned __int32 *, void **, void **); // idb
signed int __stdcall RleFile_Close(int a1);
bool __stdcall IsSafeFileAddress(struct _RLEFILE *, void *, unsigned int); // idb
signed int __stdcall RleFile_ChangeColor(int a1, unsigned int a2, unsigned int a3);
int __stdcall RleFile_Seek(struct _RLEFILE *, int); // idb
int __stdcall RleFile_Draw(struct _RLEFILE *, HDC hdc, int, int xDest, int yDest); // idb
int __stdcall RleFile_Init(struct _RLEFILE *, int, int, int); // idb
int __stdcall RleFile_Paint(struct _RLEFILE *, HDC hdc, int, int xDest, int yDest); // idb
int __stdcall RleFile_OpenFromFile(struct _RLEFILE *, LPCWSTR lpFileName); // idb
int __stdcall RleFile_OpenFromResource(struct _RLEFILE *, HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); // idb
int __thiscall CLVRange::_FindValue(CLVRange *this, __int32, __int32 *); // idb
void __thiscall CLVRange::_InitNew(CLVRange *__hidden this); // idb
HGLOBAL __thiscall CLVRange::~CLVRange(CLVRange *this);
signed int __stdcall CLVRange::QueryInterface(CLVRange *this, const struct _GUID *a2, void **a3);
unsigned __int32 __stdcall CDragProxy::AddRef(CDragProxy *this); // idb
signed int __stdcall CLVRange::Clear(CLVRange *this);
BOOL __stdcall CLVRange::IsSelected(CLVRange *this, __int32 a2);
BOOL __stdcall CLVRange::IsEmpty(CLVRange *this);
__int32 __stdcall CLVRange::CountIncluded(CLVRange *this, __int32 *); // idb
__int32 __stdcall CLVRange::NextSelected(CLVRange *this, __int32, __int32 *); // idb
__int32 __stdcall CLVRange::NextUnSelected(CLVRange *this, __int32, __int32 *); // idb
int __stdcall CLVRange::InvertRange(CLVRange *this, __int32 a2, __int32 a3);
int __thiscall CLVRange::_Enlarge(CLVRange *__hidden this); // idb
int __thiscall CLVRange::_Shrink(CLVRange *__hidden this); // idb
int __thiscall CLVRange::_InsertRange(CLVRange *this, __int32, __int32, __int32); // idb
signed int __thiscall CLVRange::_RemoveRanges(CLVRange *this, __int32 a2, __int32 a3, __int32 *a4);
void *__thiscall CLVRange::`scalar deleting destructor'(void *lpMem, char a2);
unsigned __int32 __stdcall CLVRange::Release(CLVRange *this); // idb
signed int __stdcall CLVRange::IncludeRange(CLVRange *this, __int32 a2, __int32 a3);
__int32 __stdcall CLVRange::ExcludeRange(CLVRange *this, __int32, __int32); // idb
signed int __stdcall CLVRange::InsertItem(CLVRange *this, __int32 a2);
signed int __stdcall CLVRange::RemoveItem(CLVRange *this, __int32 a2);
void *__stdcall LVRange_Create();
// bool __usercall sub_6F7DB735@<al>(unsigned int a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, unsigned int a4@<edi>);
// int __usercall sub_6F7DB767@<eax>(unsigned int a1@<edx>, unsigned int a2@<ecx>, unsigned int a3@<ebx>);
// unsigned int __usercall sub_6F7DB7B2@<eax>(int a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<esi>);
unsigned int __stdcall sub_6F7DB804(unsigned int a1, unsigned int a2);
unsigned int __stdcall sub_6F7DB877(unsigned int a1, unsigned int a2);
// unsigned int __userpurge sub_6F7DB8D2@<eax>(unsigned int a1@<edi>, int a2, wchar_t *Str1, int a4);
// unsigned int __userpurge sub_6F7DB956@<eax>(unsigned int a1@<eax>, unsigned int a2, int a3);
// int __userpurge sub_6F7DB9B0@<eax>(int a1@<eax>, unsigned int a2, int a3, char a4, unsigned int a5);
int __stdcall sub_6F7DBA32(unsigned int a1, unsigned int a2, char a3);
void __stdcall RtlGetVersionResource(void *, unsigned int, unsigned __int32, struct _RTL_VERSION_RESOURCE *Dst); // idb
void __stdcall RtlGetVersionResourceFromSelf(struct _RTL_VERSION_RESOURCE *Dst); // idb
signed int __stdcall Mirror_IsProcessRTL();
unsigned __int8 *__stdcall Skip_IDorString(void *); // idb
unsigned int __stdcall Skip_DialogHeader(struct DLGTEMPLATE *a1);
void __stdcall EditBiDiDLGTemplate(struct DLGTEMPLATE *a1, int a2, int a3, int a4);
BOOL __stdcall IsValidHDPA(int a1);
// _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD); weak
// int __cdecl _vsnwprintf(wchar_t *Dest, size_t Count, const wchar_t *Format, va_list Args);
int __cdecl _except_handler4(int, PVOID TargetFrame, int); // idb
// int __cdecl _wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// _DWORD __cdecl _amsg_exit(_DWORD); weak
// int __cdecl __crtExitProcess(UINT uExitCode); idb
DWORD __stdcall __crtTlsAlloc(int a1);
// int __cdecl _freeptd(void *Memory); idb
void __cdecl __report_gsfailure();
int __cdecl _flsbuf(int Ch, FILE *File);
// void __usercall sub_6F7DCC6B(int a1@<edi>, int a2@<esi>, wchar_t a3);
// void __usercall sub_6F7DCCAA(int a1@<eax>, wchar_t a2, int a3, int a4);
// void __usercall sub_6F7DCCDC(int a1@<eax>, wchar_t *a2@<edx>, int a3@<ecx>, int a4);
int __cdecl _woutput_l(int, int, struct localeinfo_struct *, int); // idb
void __cdecl _invoke_watson(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
void __cdecl _invalid_parameter(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5);
// _DWORD __cdecl _get_errno_from_oserr(_DWORD); weak
// int *__cdecl _errno();
// unsigned __int32 *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// _DWORD __cdecl _ValidateImageBase(_DWORD); weak
// _DWORD __cdecl _FindPESection(_DWORD, _DWORD); weak
int __cdecl _IsNonwritableInCurrentImage(int a1);
// int __thiscall _updatetlocinfoEx_nolock(_DWORD); weak
int __updatetlocinfo();
void __cdecl _NMSG_WRITE(int a1);
// int _FF_MSGBANNER(void); weak
signed int __cdecl _mtinitlocknum(int a1);
void __cdecl __noreturn terminate();
int __get_sigabrt();
int __stdcall sub_6F7DE4F1(LPCRITICAL_SECTION lpCriticalSection, int); // idb
// _DWORD __cdecl _callnewh(_DWORD); weak
// _DWORD __cdecl __sbh_heap_init(_DWORD); weak
// _DWORD __cdecl __sbh_find_block(_DWORD); weak
// _DWORD __cdecl __sbh_free_block(_DWORD, _DWORD); weak
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// _DWORD __cdecl V6_HeapAlloc(_DWORD); weak
// int __cdecl _lseeki64_nolock(int, int, int, DWORD dwMoveMethod); idb
__int64 __cdecl _lseeki64(int, __int64, int);
DWORD __cdecl _write_nolock(int a1, int a2, DWORD nNumberOfBytesToWrite);
int __cdecl _write(int, const void *, unsigned int);
int __cdecl _getbuf(int a1);
// int __cdecl _isatty(int);
void __cdecl _lock_file(FILE *File);
void __cdecl _unlock_file(FILE *File);
// int __cdecl _fileno(FILE *File);
// int __cdecl ferror(FILE *File);
wint_t __cdecl _fputwc_nolock(wchar_t Ch, FILE *File);
// int __cdecl _get_printf_count_output();
// int __cdecl _mbtowc_l(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes, _locale_t Locale);
// int __cdecl mbtowc(wchar_t *DstCh, const char *SrcCh, size_t SrcSizeInBytes);
// int __cdecl _isleadbyte_l(int C, _locale_t Locale);
// int __cdecl isleadbyte(int C);
// int __thiscall write_char(FILE *File); idb
// int __cdecl write_multi_char(char, int, FILE *File); idb
// int __cdecl write_string(_DWORD); weak
int __cdecl _output_l(FILE *File, int, struct localeinfo_struct *, int); // idb
// errno_t __cdecl strcat_s(char *Dst, rsize_t SizeInBytes, const char *Src);
// errno_t __cdecl strncpy_s(char *Dst, rsize_t SizeInBytes, const char *Src, rsize_t MaxCount);
int __cdecl sub_6F7E1000(LCID Locale, DWORD dwMapFlags, wchar_t *Src, size_t MaxCount, LPWSTR lpDestStr, int cchDest, UINT CodePage); // idb
int __cdecl __crtMessageBoxA(int a1, int a2, int a3);
// int __cdecl _set_error_mode(int Mode);
// void __cdecl abort();
// _DWORD __cdecl _free_osfhnd(_DWORD); weak
__int32 __cdecl _get_osfhandle(int);
int __cdecl __lock_fhandle(int Filehandle);
void __cdecl _unlock_fhandle(int Filehandle);
// int __cdecl _putwch_nolock(__int16 Buffer); idb
int __cdecl _flswbuf(int, FILE *File); // idb
// errno_t __cdecl wctomb_s(int *SizeConverted, char *MbCh, rsize_t SizeInBytes, wchar_t WCh);
// int __cdecl __ansicp(LCID Locale); idb
void *__cdecl __convertcp(UINT CodePage, UINT a2, int a3, int a4, int a5, int a6);
int __cdecl _resetstkoflw();
__int32 __cdecl atol(const char *Str);
// size_t __cdecl wcsnlen(const wchar_t *Src, size_t MaxCount);
int __cdecl sub_6F7E2080(int, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale); // idb
int __cdecl __crtGetStringTypeW(struct localeinfo_struct *, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale); // idb
// int __cdecl fclose(FILE *File);
int __cdecl _commit(int);
// int __cdecl strtoxl(struct localeinfo_struct *, int, int, int, int, int); idb
int __cdecl strtolX(int a1, int a2, int a3, int a4);
signed int __cdecl _close_nolock(signed int a1);
int __cdecl _close(int);
int __stdcall NT5_AnimateWindow(int a1, int a2, int a3);
int __stdcall SlideAnimate(int a1, int a2);
int __stdcall CoolTooltipBubble(HWND hWnd, int, int, int); // idb
HCURSOR __stdcall LoadHandCursor(int a1);
HRESULT StringCchPrintfA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszFormat, ...);
signed int __stdcall Emulate_GetCalendarInfoA(int a1, int a2, int a3, int a4, int a5, int a6);
int __stdcall NT5_GetCalendarInfoA(int a1, int a2, int a3, int a4, int a5, int a6);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// int __cdecl _vsnprintf(char *Dest, size_t Count, const char *Format, va_list Args);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_6F771A17; // weak
_UNKNOWN loc_6F771A3B; // weak
_UNKNOWN loc_6F771A4D; // weak
_UNKNOWN loc_6F771A60; // weak
int dword_6F771A70[2] = { 4294967294, 0 }; // weak
_UNKNOWN loc_6F772E94; // weak
const WCHAR SrcStr = 0u; // idb
_UNKNOWN loc_6F777783; // weak
GUID _GUID_46eb5926_582e_4017_9fdf_e8998daa0950 = { 1189828902u, 22574u, 16407u, { 159u, 223u, 232u, 153u, 141u, 170u, 9u, 80u } };
int (__cdecl *CImageList::`vftable')(int) = &CImageList::QueryInterface; // weak
GUID IID_IImageList = { 1189828902u, 22574u, 16407u, { 159u, 223u, 232u, 153u, 141u, 170u, 9u, 80u } };
GUID IID_IUnknown = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
__int32 (__stdcall *CImageList::`vftable')(CImageList *this, const struct _GUID *, void **) = &CImageList::QueryInterface; // weak
int (__stdcall *CImageList::`vftable')(int, int, int) = &CImageList::QueryInterface; // weak
int (__stdcall *CImageList::`vftable')(int, int, int) = &CImageList::QueryInterface; // weak
int dword_6F778B60[5] = { 3722278775, 3722278775, 3722278775, 3722278775, 2425393296 }; // weak
int dword_6F77A868[] = { 0 }; // weak
int dword_6F77A86C[] = { 18 }; // weak
const WCHAR c_szNULL = 0u; // idb
_UNKNOWN loc_6F78456C; // weak
_UNKNOWN loc_6F786B09; // weak
int dword_6F789764[5] = { 5, 82, 7601, 2, 0 }; // weak
_UNKNOWN loc_6F789C4C; // weak
int dword_6F789D28[] = { 126355082 }; // weak
int dword_6F789DAC[] = { 2425393296 }; // weak
_UNKNOWN loc_6F78AD16; // weak
GUID IID_IImageListPriv = { 3914121787u, 2326u, 19366u, { 147u, 244u, 170u, 82u, 181u, 53u, 94u, 232u } };
GUID IID_IPersist = { 268u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID IID_IPersistStream = { 265u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
_UNKNOWN loc_6F791512; // weak
_UNKNOWN loc_6F7915AC; // weak
_UNKNOWN loc_6F7915DE; // weak
int dword_6F7928C8[4] = { 1, 2, 12321, 9 }; // weak
int dword_6F7928D8[] = { 12323 }; // weak
wchar_t aStatic[7] = L"Static"; // weak
const WCHAR WindowName = 0u; // idb
int c_stEpoch[4] = { 591576, 917504, 0, 0 }; // weak
int c_stArmageddon[4] = { 796431, 2031616, 3866647, 65470523 }; // weak
int (__stdcall *pfnListView_ItemHitTest)(int, POINT pt, int, int) = &ListView_IItemHitTest; // weak
int (__stdcall *pfnListView_Scroll2)(HDC hdc, int, int, int) = &ListView_IScroll2; // weak
wchar_t a___[] = L"..."; // idb
GUID _GUID_00000000_0000_0000_c000_000000000046 = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID _GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8 = { 3914121787u, 2326u, 19366u, { 147u, 244u, 170u, 82u, 181u, 53u, 94u, 232u } };
__int32 (__stdcall *CDragProxy::`vftable')(CDragProxy *this, const struct _GUID *, void **) = &CDragProxy::QueryInterface; // weak
__int32 (__stdcall *CLVRange::`vftable')(CLVRange *this, const struct _GUID *, void **) = &CLVRange::QueryInterface; // weak
const char *const __lookuptable = (const char *const )0x6000006; // weak
GUID IID_IDropTarget = { 290u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
WPARAM wParam = 12324u; // idb
int g_PSPT_Action[] = { 0 }; // weak
int nIDDlgItem = 12323; // idb
int g_dxButtonSep = 8; // weak
int s_Combos[] = { 1 }; // weak
int (__stdcall *pfnListView_ApproximateViewRect[4])(int, int, int, int) =
{
  &ListView_IApproximateViewRect,
  &ListView_RApproximateViewRect,
  &ListView_IApproximateViewRect,
  &ListView_LApproximateViewRect
}; // weak
int (__stdcall *pfnListView_OnScroll[4])(HDC hdc, int, int, int code) =
{
  &ListView_IOnScroll,
  &ListView_ROnScroll,
  &ListView_IOnScroll,
  &ListView_LOnScroll
}; // weak
int (__stdcall *pfnListView_DrawItem[4])(int) =
{
  &ListView_IDrawItem,
  &ListView_RDrawItem,
  &ListView_IDrawItem,
  &ListView_LDrawItem
}; // weak
int (__stdcall *pfnListView_UpdateScrollBars)(HDC hdc) = &ListView_IUpdateScrollBars; // weak
GUID CLSID_IImgCtx = { 810611670u, 39093u, 4559u, { 187u, 130u, 0u, 170u, 0u, 189u, 206u, 11u } };
GUID IID_IImgCtx = { 810611671u, 39093u, 4559u, { 187u, 130u, 0u, 170u, 0u, 189u, 206u, 11u } };
_UNKNOWN loc_6F7C3DDB; // weak
_UNKNOWN loc_6F7C3E7C; // weak
int dword_6F7C7E40[4] = { 4, 4, 4, 4 }; // weak
int dword_6F7C7E50[4] = { 0, 0, 0, 0 }; // weak
int (__stdcall *pfnListView_GetScrollUnitsPerLine[4])(int, int) =
{
  &ListView_IGetScrollUnitsPerLine,
  &ListView_RGetScrollUnitsPerLine,
  &ListView_IGetScrollUnitsPerLine,
  &ListView_LGetScrollUnitsPerLine
}; // weak
const wchar_t c_szSpace = 32u; // idb
_UNKNOWN loc_6F7D0C89; // weak
_UNKNOWN loc_6F7D1C55; // weak
_UNKNOWN loc_6F7D3BAF; // weak
_UNKNOWN loc_6F7D3DCE; // weak
GUID _GUID_00000109_0000_0000_c000_000000000046 = { 265u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID CLSID_ImageList = { 2085055394u, 689u, 18676u, { 128u, 72u, 178u, 70u, 25u, 221u, 192u, 88u } };
int dword_6F7D7EAC[2] = { 0, 0 }; // weak
__int32 (__thiscall *CPager::`vftable')(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) = &CPager::v_WndProc; // weak
__int32 (__thiscall *CNativeFont::`vftable')(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) = &CNativeFont::v_WndProc; // weak
GUID IID_ILVRange = { 2527215126u, 41404u, 4561u, { 176u, 132u, 0u, 192u, 79u, 195u, 58u, 165u } };
char byte_6F7DC102[6] = { '', '', '', '', '', '' }; // weak
struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_6F7E6C18, &dword_6F7E6C68 }; // idb
int (*off_6F7E6018[4])() = { &_fptrap, &_fptrap, &_fptrap, &_fptrap }; // weak
int (*off_6F7E6020[2])() = { &_fptrap, &_fptrap }; // weak
int (*off_6F7E6024)() = &_fptrap; // weak
int (__stdcall *icc)(int) = &InitToolbarClass; // weak
wchar_t *off_6F7E602C = L"ToolbarWindow32"; // weak
int dword_6F7E6030[] = { 4 }; // weak
int dword_6F7E6034[] = { 0 }; // weak
int gpFlsFree = 0; // weak
int gpFlsSetValue = 0; // weak
LPVOID gpFlsGetValue = NULL; // idb
int gpFlsAlloc = 0; // weak
int __security_cookie_complement = 1153374641; // weak
uintptr_t __security_cookie = 3141592654u;
HGDIOBJ g_hbmDcDeselect = NULL; // idb
struct _RTL_CRITICAL_SECTION g_csDll = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int _acmdln = 0; // weak
int __pioinfo[] = { 0 }; // weak
volatile LONG *___ptmbcinfo = &__initialmbcinfo; // idb
char **__argv = NULL;
void *__piob = NULL; // idb
HANDLE _crtheap = NULL; // idb
FILE _iob[] = ;
int dword_6F7E6520[2] = { 0, 0 }; // weak
int dword_6F7E6530[3] = { 0, 0, 0 }; // weak
int dword_6F7E6550[3] = { 0, 0, 0 }; // weak
int dword_6F7E6580[124] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_6F7E6770[8] = { 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
int *__lconv_c[10] =
{
  &__lconv_static_decimal,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null,
  &__lconv_static_null
}; // weak
HGDIOBJ g_hbrMonoDither = NULL; // idb
HDC g_hdcSrc = NULL; // idb
HDC g_hdcDst = NULL; // idb
HGDIOBJ g_hbrStripe = NULL; // idb
int __argc = 0;
DWORD __getvalueindex = 4294967295u; // idb
int (*__initiallocalestructinfo)[22] = &__initiallocinfo; // weak
int g_iILRefCount = 0; // weak
int __flsindex = 4294967295; // weak
int _C_Termination_Done = 0; // weak
int g_pfnImmDestroyContext = 0; // weak
int g_pfnImmSetCandidateWindow = 0; // weak
HINSTANCE g_hinst = NULL; // idb
int g_pfnImmReleaseContext = 0; // weak
int g_cyFrame = 0; // weak
int (__stdcall *g_pfnImmAssociateContext)(_DWORD, _DWORD) = NULL; // weak
int g_pfnImmCreateContext = 0; // weak
int (__stdcall *g_pfnImmGetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__stdcall *g_pfnImmNotifyIME)(_DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
char *__nullstring = "(null)"; // weak
int g_pfnImmGetCompositionStringA = 0; // weak
int (__stdcall *g_pfnImmGetContext)(_DWORD) = NULL; // weak
char *_pgmptr = NULL;
unsigned __int16 *__wnullstring = &aNull; // weak
_DWORD ___ptlocinfo = 1870553864; // weak
int (__stdcall *g_pfnImmSetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int g_cxFrame = 0; // weak
int g_pfnImmSetCompositionStringA = 0; // weak
volatile LONG g_dwWindowCount = 0; // idb
__int16 g_aCC32Subclass = 0; // weak
int g_bComplexPlatform = 0; // weak
int g_bRemoteSession = 0; // weak
HGDIOBJ g_hfontSystem = NULL; // idb
int g_uDragImages = 0; // weak
HGDIOBJ g_hbrBtnHighlight = NULL; // idb
HBRUSH g_hbrBtnFace = NULL; // idb
int g_cyScreen = 0; // weak
HBRUSH g_hbrHighlight = NULL; // idb
int g_hbrGrayText = 0; // weak
int g_cxScreen = 0; // weak
HGDIOBJ g_hbrBtnShadow = NULL; // idb
int g_hbrWindowFrame = 0; // weak
int g_hbrWindowText = 0; // weak
BYTE g_fSmoothScroll = 0u; // idb
HBRUSH g_hbrWindow = NULL; // idb
int g_fDragFullWindows = 0; // weak
int dword_6F7E68C0 = 0; // weak
int dword_6F7E68C4 = 0; // weak
int g_uiACP = 0; // weak
HDC g_hdc = NULL; // idb
HDC g_hdcMask = NULL; // idb
int g_fDBCSEnabled = 0; // weak
int g_fMEEnabled = 0; // weak
int g_fDBCSInputEnabled = 0; // weak
HBITMAP g_hbmSrc = NULL; // weak
HBITMAP g_hbmDst = NULL; // weak
int dword_6F7E68E8 = 0; // weak
int dword_6F7E68EC = 0; // weak
void *_aenvptr = NULL; // idb
int _osplatform = 0; // weak
unsigned int _osver = 0u;
unsigned int _winver = 0u;
unsigned int _winmajor = 0u;
unsigned int _winminor = 0u;
int dword_6F7E6908 = 0; // weak
int dword_6F7E6918 = 0; // weak
int dword_6F7E6920 = 0; // weak
int dword_6F7E6924 = 0; // weak
int dword_6F7E6928 = 0; // weak
int dword_6F7E692C = 0; // weak
int g_msgMSWheel = 0; // weak
int g_clr3DLight = 0; // weak
COLORREF g_clr3DDkShadow = 0u; // idb
int g_clrInfoBk = 0; // weak
int g_clrInfoText = 0; // weak
COLORREF g_clrHighlightText = 0u; // idb
COLORREF g_clrHighlight = 0u; // idb
COLORREF g_clrBtnHighlight = 0u; // idb
COLORREF g_clrBtnShadow = 0u; // idb
COLORREF g_clrBtnFace = 0u; // idb
COLORREF g_clrBtnText = 0u; // idb
COLORREF g_clrGrayText = 0u; // idb
int g_clrWindowFrame = 0; // weak
COLORREF g_clrWindowText = 0u; // idb
COLORREF g_clrWindow = 0u; // idb
int g_cyScrollbar = 0; // weak
int g_cxScrollbar = 0; // weak
int g_cyDoubleClk = 0; // weak
int g_cxDoubleClk = 0; // weak
int g_cxLabelMargin = 0; // weak
int g_cyLabelSpace = 0; // weak
int g_cyIconMargin = 0; // weak
int g_cxIconMargin = 0; // weak
int g_cyIconSpacing = 0; // weak
int g_cxIconSpacing = 0; // weak
int g_cySmIcon = 0; // idb
int g_cxSmIcon = 0; // idb
int g_cyIcon = 0; // weak
int g_cxIcon = 0; // weak
int g_cyHScroll = 0; // weak
int g_cxVScroll = 0; // weak
int g_cyBorder = 0; // idb
int g_cxBorder = 0; // idb
int g_cyEdge = 0; // idb
int g_cxEdge = 0; // idb
int _nstream = 0; // weak
int __sse2_available = 0; // weak
int __active_heap = 0; // weak
UINT _nhandle = 0u; // idb
int __mbctype_initialized = 0; // weak
_UNKNOWN g_drb; // weak
HBITMAP dword_6F7E69D8 = NULL; // idb
HBITMAP h = NULL; // idb
int dword_6F7E69E0 = 4294967295; // idb
int cy = 4294967295; // idb
volatile LONG __initialmbcinfo = 0; // idb
int g_ucScrollLines = 3; // weak
int g_dwHoverSelectTimeout = 0; // weak
struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority = { { 0u, 0u, 0u, 0u, 0u, 5u } }; // idb
int dword_6F7E6C18 = 0; // weak
int dword_6F7E6C1C = 0; // weak
int dword_6F7E6C24 = 0; // weak
int dword_6F7E6C68 = 0; // weak
__int16 word_6F7E6CF4 = 0; // weak
__int16 word_6F7E6CF8 = 0; // weak
__int16 word_6F7E6CFC = 0; // weak
__int16 word_6F7E6D00 = 0; // weak
int dword_6F7E6D04 = 0; // weak
int dword_6F7E6D08 = 0; // weak
int dword_6F7E6D0C = 0; // weak
int dword_6F7E6D10 = 0; // weak
int dword_6F7E6D14 = 0; // weak
int dword_6F7E6D18 = 0; // weak
int dword_6F7E6D1C = 0; // weak
int dword_6F7E6D20 = 0; // weak
__int16 word_6F7E6D24 = 0; // weak
int dword_6F7E6D28 = 0; // weak
int dword_6F7E6D2C = 0; // weak
__int16 word_6F7E6D30 = 0; // weak
int __clocalestr[2] = { 67, 0 }; // weak
wchar_t c_szAnimateClass[13] = L"SysAnimate32"; // weak
int _XcptActTab[3] = { 3221225477, 11, 0 }; // weak
CHAR Filename[260] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_6F7E70E4 = '\0'; // weak
LPCRITICAL_SECTION lpCriticalSection = NULL; // idb
int dword_6F7E70EC[] = { 1 }; // weak
int dword_6F7E7208[86] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
int (__stdcall *_pRawDllMain)(_DWORD, _DWORD, _DWORD) = NULL; // weak
HANDLE _coninpfh = (HANDLE)0xFFFFFFFE; // idb
HANDLE _confh = (HANDLE)0xFFFFFFFE; // idb
char __globallocalestatus = ''; // weak
HGDIOBJ g_hbmWork = NULL; // idb
int dword_6F7E84DC = 4294967295; // weak
int dword_6F7E84E4 = 35; // weak
int dword_6F7E84E8[] = { 4294967276 }; // weak
int dword_6F7E84EC[] = { 20 }; // weak
int dword_6F7E8564[3] = { 33, 20, 4294967276 }; // weak
int dword_6F7E8570 = 4294967295; // weak
int g_bRunOnNT5 = 1; // weak
int g_fSlowMachine = 4294967295; // weak
int dword_6F7E859C[] = { 1 }; // weak
int mpcdymoAccum[] = { 0 }; // weak
int x = 4294934529; // idb
_UNKNOWN g_dctx; // weak
int dword_6F7E85DC = 0; // weak
CImageList *dword_6F7E85E0 = NULL; // idb
int dword_6F7E85E4 = 0; // weak
int dword_6F7E85E8 = 4294967295; // idb
int dword_6F7E85EC = 0; // weak
int dword_6F7E85F0 = 0; // weak
int dword_6F7E85F4 = 0; // weak
int dword_6F7E85F8 = 0; // weak
int dword_6F7E85FC = 0; // weak
int dword_6F7E8600 = 0; // weak
int dword_6F7E8604 = 0; // weak
int dword_6F7E8608 = 0; // weak
HWND hWnd = NULL; // idb
int __badioinfo[9] = { 4294967295, 2688, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_6F7E89C0[] = { 2 }; // weak
LPCVOID lpBuffer = &aR6002FloatingP; // idb
int g_fNeverPlaySound = 0; // weak
__int16 word_6F7E8A94 = 0; // weak
struct tagPOINT X = { 0, 0 }; // idb
UINT uDragListMsg = 0u; // idb
int dword_6F7E8AA4 = 0; // weak
__int16 g_PUILangId = 0; // weak
int dword_6F7E8AAC = 0; // weak
int (__stdcall *g_pfnTME)(_DWORD) = NULL; // weak
int g_dyButtonHack = 0; // weak
int dword_6F7E8AB8 = 0; // weak
__int32 (__stdcall *g_pfnGetGlobalFontLinkObject)(struct IMLangFontLink **) = NULL; // weak
struct tagBITMAP g_bmWork = { 0, 0, 0, 0, 0u, 0u, NULL }; // weak
int dword_6F7E8AC4 = 0; // weak
int dword_6F7E8AC8 = 0; // weak
__int16 word_6F7E8AD2 = 0; // weak
_UNKNOWN CNativeFont::_s_uiFontAssocStatus; // weak
int dword_6F7E8ADC = 0; // weak
int __app_type = 0; // weak
int __locale_changed = 0; // weak
char Dst[25] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
CHAR byte_6F7E8B21[223] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_6F7E8C25; // weak
int _maxwait; // weak
int _newmode; // weak
int _cflush; // weak
int dword_6F7E8E30; // weak
int dword_6F7E8E34; // weak
int dword_6F7E8E38; // weak
int dword_6F7E8E3C; // weak
int dword_6F7E8E40; // weak
int dword_6F7E8E44; // weak
int dword_6F7E8E48; // weak
int (__stdcall *dword_6F7E8E4C)(_DWORD, _DWORD, _DWORD); // weak
int g_bUseDblClickTimer; // weak
HDPA g_hdpaCal; // idb
int _GetUserDefaultUILanguage; // weak
int gcWheelDelta; // weak
int __sbh_cntHeaderList; // weak
LPVOID __sbh_pHeaderList; // idb
int __sbh_threshold; // weak
int (__cdecl *_pDestructExceptionObject)(_DWORD, _DWORD); // weak
int _GetCalendarInfoA; // weak


//----- (6F7716DB) --------------------------------------------------------
void *__cdecl memset(void *Dst, int Val, size_t Size)
{
  size_t v3; // edx@1
  int v4; // eax@2
  void *v5; // edi@4
  int v6; // ecx@5
  unsigned int v7; // ecx@6
  unsigned int v8; // ecx@6
  void *result; // eax@8

  v3 = Size;
  if ( Size )
  {
    LOBYTE(v4) = Val;
    if ( (_BYTE)Val || Size < 0x100 || !__sse2_available )
    {
      v5 = Dst;
      if ( Size < 4 )
        goto LABEL_19;
      v6 = -(signed int)Dst & 3;
      if ( v6 )
      {
        v3 = Size - v6;
        do
        {
          *(_BYTE *)v5 = Val;
          v5 = (char *)v5 + 1;
          --v6;
        }
        while ( v6 );
      }
      v4 = 16843009 * (unsigned __int8)Val;
      v7 = v3;
      v3 &= 3u;
      v8 = v7 >> 2;
      if ( !v8 || (memset32(v5, v4, v8), v5 = (char *)v5 + 4 * v8, v3) )
      {
LABEL_19:
        do
        {
          *(_BYTE *)v5 = v4;
          v5 = (char *)v5 + 1;
          --v3;
        }
        while ( v3 );
      }
      result = Dst;
    }
    else
    {
      result = sub_6F77E492(Dst, Val, Size);
    }
  }
  else
  {
    result = Dst;
  }
  return result;
}
// 6F7E69C0: using guessed type int __sse2_available;

//----- (6F77175B) --------------------------------------------------------
void __cdecl free(void *Memory)
{
  BOOL v1; // eax@3
  int v2; // eax@6
  int *v3; // esi@10
  DWORD v4; // eax@10
  int v5; // [sp+10h] [bp-1Ch]@6

  if ( Memory )
  {
    if ( __active_heap != 3 )
    {
      v1 = HeapFree(_crtheap, 0, Memory);
      goto LABEL_4;
    }
    _lock(4);
    v2 = __sbh_find_block(Memory);
    v5 = v2;
    if ( v2 )
      __sbh_free_block(v2, Memory);
    _unlock(4);
    if ( !v5 )
    {
      v1 = HeapFree(_crtheap, 0, Memory);
LABEL_4:
      if ( !v1 )
      {
        v3 = _errno();
        v4 = GetLastError();
        *v3 = _get_errno_from_oserr(v4);
      }
      return;
    }
  }
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7DDA1A: using guessed type _DWORD __cdecl _get_errno_from_oserr(_DWORD);
// 6F7DE58B: using guessed type _DWORD __cdecl __sbh_find_block(_DWORD);
// 6F7DE5C0: using guessed type _DWORD __cdecl __sbh_free_block(_DWORD, _DWORD);
// 6F7E69C4: using guessed type int __active_heap;

//----- (6F7717D5) --------------------------------------------------------
void __cdecl _lock(int a1)
{
  LPCRITICAL_SECTION *v1; // esi@1

  v1 = &lpCriticalSection + 2 * a1;
  if ( !*v1 && !_mtinitlocknum(a1) )
    _amsg_exit(17);
  EnterCriticalSection(*v1);
}
// 6F7DC8FE: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);

//----- (6F7717FE) --------------------------------------------------------
int __cdecl _decode_pointer(int a1)
{
  HMODULE v1; // eax@3
  FARPROC v2; // eax@4
  int v4; // ST04_4@8
  LPVOID v5; // eax@8
  int v6; // eax@8

  if ( TlsGetValue(__getvalueindex)
    && __flsindex != -1
    && (v4 = __flsindex, v5 = TlsGetValue(__getvalueindex), (v6 = ((int (__stdcall *)(_DWORD))v5)(v4)) != 0) )
  {
    v2 = *(FARPROC *)(v6 + 508);
  }
  else
  {
    v1 = GetModuleHandleW(L"KERNELBASE.DLL");
    if ( !v1 )
    {
      v1 = GetModuleHandleW(L"KERNEL32.DLL");
      if ( !v1 )
        return a1;
    }
    v2 = GetProcAddress(v1, "DecodePointer");
  }
  if ( v2 )
    a1 = ((int (__stdcall *)(_DWORD))v2)(a1);
  return a1;
}
// 6F7E6804: using guessed type int __flsindex;

//----- (6F77185C) --------------------------------------------------------
int (*__usercall sub_6F77185C@<eax>(int (*result)(void)@<eax>, unsigned int a2))(void)
{
  int (**i)(void); // esi@1

  for ( i = (int (**)(void))result; (unsigned int)i < a2; ++i )
  {
    result = *i;
    if ( *i )
      result = (int (*)(void))result();
  }
  return result;
}

//----- (6F771880) --------------------------------------------------------
signed int __stdcall _CRT_INIT(int a1, int a2, int a3)
{
  if ( a2 == 1 )
    __security_init_cookie();
  return __CRT_INIT(a1, a2, a3);
}

//----- (6F771896) --------------------------------------------------------
signed int __stdcall __CRT_INIT(int a1, int a2, int a3)
{
  int v3; // eax@3
  void *v5; // eax@25
  int v6; // esi@25
  void *v7; // ST08_4@26
  int v8; // ST04_4@26
  int v9; // eax@26
  int v10; // ST00_4@26
  struct _OSVERSIONINFOA VersionInformation; // [sp+8h] [bp-98h]@2

  if ( a2 == 1 )
  {
    VersionInformation.dwOSVersionInfoSize = 148;
    if ( GetVersionExA(&VersionInformation) )
    {
      v3 = VersionInformation.dwBuildNumber & 0x7FFF;
      if ( VersionInformation.dwPlatformId != 2 )
        v3 |= 0x8000u;
      _osplatform = VersionInformation.dwPlatformId;
      _winver = VersionInformation.dwMinorVersion + (VersionInformation.dwMajorVersion << 8);
      _winmajor = VersionInformation.dwMajorVersion;
      _winminor = VersionInformation.dwMinorVersion;
      _osver = v3;
      if ( _heap_init(1) )
      {
        if ( _mtinit() )
        {
          _acmdln = (int)GetCommandLineA();
          _aenvptr = __crtGetEnvironmentStringsA();
          if ( _ioinit() >= 0 )
          {
            if ( _setargv() >= 0 && _setenvp() >= 0 && !_cinit(0) )
            {
              ++dword_6F7E68EC;
              return 1;
            }
            _ioterm();
          }
          _mtterm();
        }
        _heap_term();
      }
    }
  }
  else if ( a2 )
  {
    if ( a2 != 2 )
    {
      if ( a2 == 3 )
        _freeptd(0);
      return 1;
    }
    __set_flsgetvalue();
    v5 = calloc(1u, 0x214u);
    v6 = (int)v5;
    if ( v5 )
    {
      v7 = v5;
      v8 = __flsindex;
      v9 = _decode_pointer(gpFlsSetValue);
      if ( ((int (__thiscall *)(int, int, void *))v9)(v10, v8, v7) )
      {
        _initptd(v6, 0);
        return 1;
      }
      free((void *)v6);
    }
  }
  else if ( dword_6F7E68EC > 0 )
  {
    --dword_6F7E68EC;
    if ( !_C_Termination_Done )
      _cexit();
    if ( !a3 )
    {
      _ioterm();
      _mtterm();
      _heap_term();
    }
    return 1;
  }
  return 0;
}
// 6F7759D8: using guessed type int _setenvp(void);
// 6F776440: using guessed type int __set_flsgetvalue(void);
// 6F77645A: using guessed type _DWORD __cdecl _cinit(_DWORD);
// 6F776DA9: using guessed type int _mtterm(void);
// 6F7E62C8: using guessed type int gpFlsSetValue;
// 6F7E63EC: using guessed type int _acmdln;
// 6F7E6804: using guessed type int __flsindex;
// 6F7E6808: using guessed type int _C_Termination_Done;
// 6F7E68EC: using guessed type int dword_6F7E68EC;
// 6F7E68F4: using guessed type int _osplatform;

//----- (6F7719A9) --------------------------------------------------------
BOOL __stdcall _DllMainCRTStartup(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  BOOL result; // eax@12
  int v4; // [sp+0h] [bp-1Ch]@3
  int v5; // [sp+0h] [bp-1Ch]@8

  if ( fdwReason == 1 )
    __security_init_cookie();
  _SEH_prolog4(dword_6F771A70, 12);
  v4 = 1;
  if ( !fdwReason && !dword_6F7E68EC )
    goto LABEL_27;
  if ( fdwReason != 1 && fdwReason != 2 )
    goto LABEL_28;
  if ( _pRawDllMain )
  {
    dword_6F7E8ADC = 1;
    v4 = _pRawDllMain(hinstDLL, fdwReason, lpReserved);
  }
  if ( v4 && _CRT_INIT((int)hinstDLL, fdwReason, (int)lpReserved) )
  {
LABEL_28:
    v5 = DllMain(hinstDLL, fdwReason, lpReserved);
    if ( fdwReason == 1 && !v5 )
    {
      DllMain(hinstDLL, 0, 0);
      _CRT_INIT((int)hinstDLL, 0, 0);
      if ( _pRawDllMain )
        _pRawDllMain(hinstDLL, 0, 0);
    }
    if ( !fdwReason || fdwReason == 3 )
    {
      v5 = _CRT_INIT((int)hinstDLL, fdwReason, (int)lpReserved);
      if ( _pRawDllMain )
      {
        if ( dword_6F7E8ADC )
          v5 = _pRawDllMain(hinstDLL, fdwReason, lpReserved);
      }
    }
    result = v5;
  }
  else
  {
LABEL_27:
    result = 0;
  }
  return result;
}
// 6F771682: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 6F771A70: using guessed type int dword_6F771A70[2];
// 6F7E68EC: using guessed type int dword_6F7E68EC;
// 6F7E8360: using guessed type int (__stdcall *_pRawDllMain)(_DWORD, _DWORD, _DWORD);
// 6F7E8ADC: using guessed type int dword_6F7E8ADC;

//----- (6F771AE5) --------------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason )
  {
    if ( fdwReason == 1 )
    {
      DisableThreadLibraryCalls(hinstDLL);
      return _ProcessAttach(hinstDLL);
    }
  }
  else
  {
    _ProcessDetach((int)hinstDLL);
  }
  return 1;
}

//----- (6F772625) --------------------------------------------------------
int __stdcall HandleHotkey(HWND hWnd)
{
  unsigned __int16 v1; // di@1
  HWND v2; // ebx@1
  int result; // eax@2
  WCHAR ClassName; // [sp+Ch] [bp-44h]@1

  v1 = SendMessageW(hWnd, 0x33u, 0, 0);
  v2 = GetFocus();
  GetClassNameW(v2, &ClassName, 32);
  if ( lstrcmpW(&ClassName, L"msctls_hotkey32") )
  {
    result = 0;
  }
  else
  {
    SendMessageW(v2, 0x401u, v1, 0);
    result = 1;
  }
  return result;
}

//----- (6F7726C1) --------------------------------------------------------
int __stdcall DPCreateHandler(int a1, HWND hWndParent, int a3)
{
  int v3; // ecx@1
  int result; // eax@2
  unsigned int v5; // eax@5
  __int16 v6; // ax@7
  __int16 v7; // si@7
  __int16 v8; // si@8
  HWND v9; // ecx@13
  LRESULT v10; // eax@13
  struct _SYSTEMTIME SystemTime; // [sp+4h] [bp-10h]@13

  CIInitialize(a1, (WPARAM)hWndParent, a3);
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 & 0xFFC0 )
  {
    result = -1;
  }
  else
  {
    if ( v3 & 1 )
    {
      *(_DWORD *)(a1 + 296) |= 2u;
      *(_DWORD *)(a1 + 36) = CreateWindowExW(
                               0,
                               L"msctls_updown32",
                               0,
                               v3 & 0x8000000 | 0x50000000,
                               2147483648,
                               2147483648,
                               2147483648,
                               2147483648,
                               hWndParent,
                               (HMENU)0x3E8,
                               g_hinst,
                               0);
    }
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 & 2 )
    {
      *(_DWORD *)(a1 + 288) = -1;
      *(_DWORD *)(a1 + 124) = 1;
    }
    *(_DWORD *)(a1 + 296) = *(_DWORD *)(a1 + 296) & 0xFFFFFFFE | ~(v5 >> 27) & 1 | 0x40;
    *(_DWORD *)(a1 + 72) = c_stEpoch[0];
    *(_DWORD *)(a1 + 76) = c_stEpoch[1];
    *(_DWORD *)(a1 + 80) = c_stEpoch[2];
    *(_DWORD *)(a1 + 84) = c_stEpoch[3];
    *(_DWORD *)(a1 + 88) = c_stArmageddon[0];
    *(_DWORD *)(a1 + 92) = c_stArmageddon[1];
    *(_DWORD *)(a1 + 96) = c_stArmageddon[2];
    *(_DWORD *)(a1 + 100) = c_stArmageddon[3];
    *(_DWORD *)(a1 + 292) = 1;
    MCGetCalendarInfo(a1 + 216);
    v6 = GetUserDefaultLCID();
    *(_DWORD *)(a1 + 236) &= 0xFFFFFFFC;
    v7 = v6;
    if ( GetWindowLongW(hWndParent, -20) & 0x400000 )
    {
      v8 = v7 & 0x3FF;
      if ( *(_BYTE *)(a1 + 8) & 8 )
      {
        *(_DWORD *)(a1 + 236) |= 1u;
        if ( v8 == 1 )
          *(_DWORD *)(a1 + 236) |= 2u;
      }
      else if ( v8 == 13 )
      {
        *(_DWORD *)(a1 + 236) |= 1u;
      }
    }
    *(_DWORD *)(a1 + 120) = a1;
    GetLocalTime(&SystemTime);
    SECSetSystemtime(a1, (int)&SystemTime);
    SECSetFont(a1 + 120, 0);
    *(_DWORD *)(a1 + 296) |= 0x100u;
    DPHandleLocaleChange(a1);
    MCLoadString(4165, (void *)(a1 + 186), 15);
    v9 = *(HWND *)(a3 + 12);
    v10 = 0;
    if ( v9 )
      v10 = SendMessageW(v9, 0x31u, 0, 0);
    DPHandleSetFont(a1, (HANDLE)v10, 0);
    MCInitColorArray(a1 + 48);
    result = 0;
  }
  return result;
}
// 6F792938: using guessed type int c_stEpoch[4];
// 6F792948: using guessed type int c_stArmageddon[4];

//----- (6F77287D) --------------------------------------------------------
signed int __stdcall InitIPAddr(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpszClassName = L"SysIPAddress32";
  WndClass.lpszMenuName = 0;
  WndClass.hIcon = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F01);
  WndClass.hInstance = a1;
  WndClass.style = 16395;
  WndClass.lpfnWndProc = (WNDPROC)IPAddressWndFn;
  WndClass.cbWndExtra = 4;
  WndClass.hbrBackground = (HBRUSH)6;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F7728DC: using guessed type wchar_t aSysipaddress32[15];

//----- (6F7728FF) --------------------------------------------------------
signed int __stdcall ListView_OnCreate(int a1, int a2)
{
  bool v2; // zf@1
  void *v3; // eax@4
  void *v4; // eax@5
  int v5; // eax@8
  HDPA v6; // eax@11
  HDPA v7; // eax@12
  int v8; // eax@14
  int v9; // esi@16
  char v11; // al@20
  int v12; // eax@22
  HWND v13; // eax@24
  int v14; // ST28_4@25
  UINT v15; // eax@26
  LPARAM lParam; // [sp+Ch] [bp-2Ch]@25
  int v17; // [sp+10h] [bp-28h]@25
  int v18; // [sp+14h] [bp-24h]@25
  int v19; // [sp+18h] [bp-20h]@25
  struct tagRECT Rect; // [sp+1Ch] [bp-1Ch]@25
  int v21; // [sp+2Ch] [bp-Ch]@25
  int v22; // [sp+30h] [bp-8h]@25

  CCCreateWindow();
  InitDitherBrush();
  CIInitialize(a1, *(_DWORD *)a1, a2);
  v2 = (*(_DWORD *)(a1 + 8) & 0x10000000) == 0;
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 44);
  if ( !v2 )
    *(_DWORD *)(a1 + 44) |= 2u;
  ListView_GetRegIASetting((int)&g_bUseDblClickTimer);
  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    v3 = LVRange_Create();
    *(_DWORD *)(a1 + 364) = v3;
    if ( v3 )
    {
      v4 = LVRange_Create();
      *(_DWORD *)(a1 + 368) = v4;
      if ( v4 )
        goto LABEL_6;
    }
  }
  else
  {
    v6 = DPA_CreateEx(16, *(HANDLE *)(a1 + 80));
    *(_DWORD *)(a1 + 40) = v6;
    if ( v6 )
    {
      v7 = DPA_CreateEx(16, *(HANDLE *)(a1 + 80));
      *(_DWORD *)(a1 + 216) = v7;
      if ( v7 )
      {
LABEL_6:
        *(_DWORD *)(a1 + 400) = -1;
        *(_DWORD *)(a1 + 404) = -1;
        *(_DWORD *)(a1 + 392) = -1;
        *(_DWORD *)(a1 + 252) = -1;
        *(_DWORD *)(a1 + 100) = -1;
        *(_DWORD *)(a1 + 96) = -1;
        *(_DWORD *)(a1 + 156) = -1;
        *(_DWORD *)(a1 + 244) = -1;
        *(_DWORD *)(a1 + 228) = 0x7FFFFFFF;
        *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 + 20);
        *(_DWORD *)(a1 + 124) = *(_DWORD *)(a2 + 16);
        if ( (*(_DWORD *)(a1 + 8) & 3) == 2 )
          *(_DWORD *)(a1 + 44) |= 0x20u;
        ListView_OnSetFont(a1, 0, 0);
        *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 172) + 16 * *(_DWORD *)(a1 + 88);
        v5 = *(_DWORD *)(a1 + 8);
        if ( v5 & 0x400 && (v5 & 3) == 1 )
          *(_DWORD *)(a1 + 188) = *(_DWORD *)(a1 + 348);
        else
          *(_DWORD *)(a1 + 348) = *(_DWORD *)(a1 + 188);
        ListView_OnSetIconSpacing(a1, -1);
        ListView_UpdateScrollBars((HDC)a1);
        *(_DWORD *)(a1 + 60) = -1;
        *(_DWORD *)(a1 + 68) = -16777216;
        *(_DWORD *)(a1 + 72) = -16777216;
        *(_DWORD *)(a1 + 444) = -16777216;
        ListView_OnSetBkColor(a1, g_clrWindow);
        v11 = *(_DWORD *)(a1 + 8) & 3;
        *(_DWORD *)(a1 + 328) = 0x7FFFFFFF;
        if ( v11 == 1 )
          ListView_RInitialize(a1, 0);
        v12 = *(_DWORD *)(a1 + 8);
        if ( v12 & 0x8000000 )
        {
          *(_DWORD *)(a1 + 8) = v12 & 0xF7FFFFFF;
          ListView_EnableWindow(a1, 0);
        }
        v13 = CreateWindowExW(0, L"tooltips_class32", 0, 0x80000002, 0, 0, 0, 0, 0, 0, g_hinst, 0);
        *(_DWORD *)(a1 + 152) = v13;
        if ( v13 )
        {
          v14 = *(_DWORD *)a1;
          lParam = 44;
          v17 = 256;
          v18 = v14;
          v19 = 0;
          v21 = 0;
          v22 = -1;
          GetClientRect((HWND)v14, &Rect);
          SendMessageW(*(HWND *)(a1 + 152), 0x432u, 0, (LPARAM)&lParam);
          SendMessageW(*(HWND *)(a1 + 152), 0x30u, *(_DWORD *)(a1 + 56), 0);
        }
        v15 = GetDoubleClickTime();
        SetTimer(*(HWND *)a1, 0x2Du, v15, 0);
        return 1;
      }
      DPA_Destroy(*(HDPA *)(a1 + 40));
    }
  }
  v8 = *(_DWORD *)(a1 + 364);
  if ( v8 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 8))(*(_DWORD *)(a1 + 364));
  v9 = *(_DWORD *)(a1 + 368);
  if ( v9 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
  return 0;
}
// 6F7E8E50: using guessed type int g_bUseDblClickTimer;

//----- (6F772B7F) --------------------------------------------------------
signed int __stdcall InitPager(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = CPager::PagerWndProc;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"SysPager";
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 0x4000;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F772BE0: using guessed type wchar_t aSyspager[9];

//----- (6F772BF7) --------------------------------------------------------
BOOL __stdcall CNativeFont::_SetFontEnumProc(HWND hWnd, LPARAM a2)
{
  int v2; // edi@1
  int v3; // edi@5
  int v4; // edi@5
  int v5; // edi@11
  int v6; // edi@11
  int v7; // edi@11
  BOOL result; // eax@14
  WCHAR ClassName; // [sp+Ch] [bp-44h]@4

  v2 = 0;
  if ( a2 && *(_DWORD *)a2 )
  {
    if ( *(_BYTE *)(a2 + 4) & 0x10 )
      goto LABEL_18;
    GetClassNameW(hWnd, &ClassName, 32);
    if ( *(_BYTE *)(a2 + 4) & 1 )
    {
      v3 = StrCmpICW((int)L"Edit", (int)&ClassName) == 0;
      v4 = (StrCmpICW((int)L"RichEdit20A", (int)&ClassName) == 0) | v3;
      v2 = (StrCmpICW((int)L"RichEdit20W", (int)&ClassName) == 0) | v4;
    }
    if ( *(_BYTE *)(a2 + 4) & 2 )
      v2 |= StrCmpICW((int)L"Static", (int)&ClassName) == 0;
    if ( *(_BYTE *)(a2 + 4) & 8 )
      v2 |= StrCmpICW((int)L"Button", (int)&ClassName) == 0;
    if ( *(_BYTE *)(a2 + 4) & 4 )
    {
      v5 = (StrCmpICW((int)L"ListBox", (int)&ClassName) == 0) | v2;
      v6 = (StrCmpICW((int)L"ComboBox", (int)&ClassName) == 0) | v5;
      v7 = (StrCmpICW((int)L"ComboBoxEx32", (int)&ClassName) == 0) | v6;
      v2 = (StrCmpICW((int)L"SysListView32", (int)&ClassName) == 0) | v7;
    }
    if ( v2 )
LABEL_18:
      SendMessageW(hWnd, 0x30u, *(_DWORD *)a2, 0);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F772D3C: using guessed type wchar_t aComboboxex32[13];
// 6F772D58: using guessed type wchar_t aSyslistview32[14];
// 6F772D74: using guessed type wchar_t aCombobox[9];
// 6F772D88: using guessed type wchar_t aListbox[8];
// 6F772D98: using guessed type wchar_t aButton[7];
// 6F772DA8: using guessed type wchar_t aRichedit20w[12];
// 6F772DC0: using guessed type wchar_t aRichedit20a[12];
// 6F7928EC: using guessed type wchar_t aStatic[7];

//----- (6F772DDD) --------------------------------------------------------
signed int __stdcall InitNativeFontCtl(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = CNativeFont::NativeFontWndProc;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"NativeFontCtl";
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 0x4000;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F772E3C: using guessed type wchar_t aNativefontctl[14];

//----- (6F772EC9) --------------------------------------------------------
void __cdecl _lock_file2(signed int a1, int a2)
{
  if ( a1 >= 20 )
    EnterCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _lock(a1 + 16);
}

//----- (6F772EEB) --------------------------------------------------------
int __cdecl _flushall()
{
  return sub_6F772EF9(1);
}

//----- (6F772EF9) --------------------------------------------------------
signed int __cdecl sub_6F772EF9(int a1)
{
  signed int i; // esi@1
  int v2; // eax@4
  int v3; // ecx@5
  char *v4; // eax@11
  signed int result; // eax@13
  signed int v6; // [sp+10h] [bp-24h]@1
  signed int v7; // [sp+18h] [bp-1Ch]@1

  v7 = 0;
  v6 = 0;
  _lock(1);
  for ( i = 0; i < _nstream; ++i )
  {
    v4 = (char *)__piob + 4 * i;
    if ( *(_DWORD *)v4 )
    {
      v2 = *(_DWORD *)v4;
      if ( *(_BYTE *)(v2 + 12) & 0x83 )
      {
        _lock_file2(i, v2);
        v3 = *(_DWORD *)(*((_DWORD *)__piob + i) + 12);
        if ( v3 & 0x83 )
        {
          if ( a1 == 1 )
          {
            if ( _fflush_nolock(*((FILE **)__piob + i)) != -1 )
              ++v7;
          }
          else if ( !a1 && v3 & 2 && _fflush_nolock(*((FILE **)__piob + i)) == -1 )
          {
            v6 = -1;
          }
        }
        _unlock_file2(i, *((_DWORD *)__piob + i));
      }
    }
  }
  _unlock(1);
  result = v7;
  if ( a1 != 1 )
    result = v6;
  return result;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7E69BC: using guessed type int _nstream;

//----- (6F773009) --------------------------------------------------------
int __cdecl _fcloseall()
{
  signed int i; // edi@1
  int v1; // esi@3
  char *v2; // eax@3
  int v3; // eax@5
  int v5; // [sp+14h] [bp-1Ch]@1

  v5 = 0;
  _lock(1);
  for ( i = 3; i < _nstream; ++i )
  {
    v1 = 4 * i;
    v2 = (char *)__piob + 4 * i;
    if ( *(_DWORD *)v2 )
    {
      v3 = *(_DWORD *)v2;
      if ( *(_BYTE *)(v3 + 12) & 0x83 && fclose((FILE *)v3) != -1 )
        ++v5;
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*(_DWORD *)((char *)__piob + v1) + 32));
        free(*(void **)((char *)__piob + v1));
        *(_DWORD *)((char *)__piob + v1) = 0;
      }
    }
  }
  _unlock(1);
  return v5;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7E69BC: using guessed type int _nstream;

//----- (6F773097) --------------------------------------------------------
void __stdcall _ProcessDetach(int a1)
{
  if ( g_hdc )
    DeleteDC(g_hdc);
  if ( g_hdcMask )
    DeleteDC(g_hdcMask);
  g_hdcMask = 0;
  g_hdc = 0;
  UnregisterClasses();
  DeleteCriticalSection(&g_csDll);
}

//----- (6F7730DF) --------------------------------------------------------
const WCHAR *__stdcall UnregisterClasses()
{
  unsigned int v0; // esi@1
  const WCHAR *result; // eax@2

  v0 = 0;
  do
  {
    result = (&off_6F7E602C)[v0 / 2];
    if ( result )
    {
      if ( dword_6F7E6034[v0 / 4] )
        result = (const WCHAR *)UnregisterClassW(result, g_hinst);
    }
    v0 += 16;
  }
  while ( v0 < 0x130 );
  return result;
}
// 6F7E602C: using guessed type wchar_t *off_6F7E602C;
// 6F7E6034: using guessed type int dword_6F7E6034[];

//----- (6F773249) --------------------------------------------------------
HANDLE __termcon()
{
  HANDLE result; // eax@3

  if ( _confh != (HANDLE)-1 && _confh != (HANDLE)-2 )
    CloseHandle(_confh);
  result = _coninpfh;
  if ( _coninpfh != (HANDLE)-1 && _coninpfh != (HANDLE)-2 )
    result = (HANDLE)CloseHandle(_coninpfh);
  return result;
}

//----- (6F7732A0) --------------------------------------------------------
int __cdecl _fflush_nolock(FILE *File)
{
  int result; // eax@4
  int v2; // eax@8

  if ( File )
  {
    if ( _flush(File) )
    {
      result = -1;
    }
    else if ( File->_flag & 0x4000 )
    {
      v2 = _fileno(File);
      result = -(_commit(v2) != 0);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = sub_6F772EF9(0);
  }
  return result;
}

//----- (6F7732D7) --------------------------------------------------------
int __cdecl _flush(FILE *File)
{
  signed int v1; // ebx@1
  char *v2; // eax@3
  char *v4; // eax@4
  char *v5; // edi@4
  unsigned int v6; // ST08_4@5
  char *v7; // ST04_4@5
  int v8; // eax@5
  int v9; // eax@6

  v1 = 0;
  if ( (File->_flag & 3) == 2 )
  {
    if ( File->_flag & 0x108 )
    {
      v4 = File->_base;
      v5 = (char *)(File->_ptr - v4);
      if ( (signed int)v5 > 0 )
      {
        v6 = File->_ptr - v4;
        v7 = File->_base;
        v8 = _fileno(File);
        if ( (char *)_write(v8, v7, v6) == v5 )
        {
          v9 = File->_flag;
          if ( (char)v9 < 0 )
            File->_flag = v9 & 0xFFFFFFFD;
        }
        else
        {
          File->_flag |= 0x20u;
          v1 = -1;
        }
      }
    }
  }
  v2 = File->_base;
  File->_cnt = 0;
  File->_ptr = v2;
  return v1;
}

//----- (6F773325) --------------------------------------------------------
void __cdecl _unlock_file2(signed int a1, int a2)
{
  if ( a1 >= 20 )
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  else
    _unlock(a1 + 16);
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);

//----- (6F773355) --------------------------------------------------------
volatile LONG *__cdecl __removelocaleref(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  volatile LONG *v2; // ebx@6
  volatile LONG *lpAddenda; // [sp+Ch] [bp+8h]@6

  v1 = lpAddend;
  if ( lpAddend )
  {
    InterlockedDecrement(lpAddend);
    if ( *((_DWORD *)lpAddend + 44) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 44));
    if ( *((_DWORD *)lpAddend + 46) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 46));
    if ( *((_DWORD *)lpAddend + 45) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 45));
    if ( *((_DWORD *)lpAddend + 48) )
      InterlockedDecrement(*((volatile LONG **)lpAddend + 48));
    v2 = lpAddend + 20;
    lpAddenda = (volatile LONG *)6;
    do
    {
      if ( *((int **)v2 - 2) != __clocalestr && *v2 )
        InterlockedDecrement(*(volatile LONG **)v2);
      if ( *((_DWORD *)v2 - 1) && *((_DWORD *)v2 + 1) )
        InterlockedDecrement(*((volatile LONG **)v2 + 1));
      v2 += 4;
      lpAddenda = (volatile LONG *)((char *)lpAddenda - 1);
    }
    while ( lpAddenda );
    InterlockedDecrement((volatile LONG *)(*((_DWORD *)v1 + 53) + 180));
  }
  return v1;
}
// 6F7E6F40: using guessed type int __clocalestr[2];

//----- (6F774830) --------------------------------------------------------
HDPA __stdcall DPA_Create(int cItemGrow)
{
  return DPA_CreateEx(cItemGrow, 0);
}

//----- (6F774848) --------------------------------------------------------
HDPA __stdcall DPA_CreateEx(int cpGrow, HANDLE hheap)
{
  HANDLE v2; // esi@1
  HDPA result; // eax@3
  int v4; // ecx@4

  v2 = hheap;
  if ( !hheap )
    v2 = GetProcessHeap();
  result = (HDPA)HeapAlloc(v2, 8u, 0x14u);
  if ( result )
  {
    v4 = cpGrow;
    if ( cpGrow < 8 )
      v4 = 8;
    *((_DWORD *)result + 4) = v4;
    *((_DWORD *)result + 2) = v2;
  }
  return result;
}

//----- (6F7748CA) --------------------------------------------------------
LSTATUS __stdcall InitGlobalMetrics(int a1)
{
  LSTATUS result; // eax@6
  DWORD cbData; // [sp+Ch] [bp-204h]@14
  HKEY hKey; // [sp+10h] [bp-200h]@13
  HKEY phkResult; // [sp+14h] [bp-1FCh]@1
  int pvParam; // [sp+18h] [bp-1F8h]@5
  int v6; // [sp+20h] [bp-1F0h]@5
  int v7; // [sp+24h] [bp-1ECh]@5

  phkResult = 0;
  if ( !dword_6F7E68C0 )
  {
    dword_6F7E68C0 = 1;
    g_msgMSWheel = 522;
  }
  g_uDragImages = RegisterWindowMessageW(L"ShellGetDragImage");
  SystemParametersInfoW(0x68u, 0, &g_ucScrollLines, 0);
  g_cxIcon = GetSystemMetrics(11);
  g_cyIcon = GetSystemMetrics(12);
  g_cxSmIcon = GetSystemMetrics(49);
  g_cySmIcon = GetSystemMetrics(50);
  g_cxIconSpacing = GetSystemMetrics(38);
  g_cyIconSpacing = GetSystemMetrics(39);
  RegOpenCurrentUser(0x20019u, &phkResult);
  if ( !g_bRemoteSession )
  {
    if ( !a1 || a1 == 37 )
      SystemParametersInfoW(0x26u, 4u, &g_fDragFullWindows, 0);
    *(_DWORD *)&g_fSmoothScroll = 1;
    if ( !IsSystemProcess() && phkResult && !RegOpenKeyExW(phkResult, L"Control Panel\\Desktop", 0, 0x20019u, &hKey) )
    {
      cbData = 4;
      RegQueryValueExW(hKey, L"SmoothScroll", 0, 0, &g_fSmoothScroll, &cbData);
      RegCloseKey(hKey);
    }
  }
  if ( !a1 || a1 == 42 )
  {
    g_cxEdge = GetSystemMetrics(45);
    g_cyEdge = GetSystemMetrics(46);
    g_cxBorder = GetSystemMetrics(5);
    g_cyBorder = GetSystemMetrics(6);
    g_cxScreen = GetSystemMetrics(0);
    g_cyScreen = GetSystemMetrics(1);
    g_cxFrame = GetSystemMetrics(32);
    g_cyFrame = GetSystemMetrics(33);
    pvParam = 500;
    SystemParametersInfoW(0x29u, 0x1F4u, &pvParam, 0);
    g_cxScrollbar = v6;
    g_cxVScroll = v6;
    g_cyScrollbar = v7;
    g_cyHScroll = v7;
    g_cxIconMargin = 8 * g_cxBorder;
    g_cyIconMargin = g_cyEdge;
    g_cyLabelSpace = 2 * g_cyEdge;
    g_cxLabelMargin = g_cxEdge;
    g_cxDoubleClk = GetSystemMetrics(36);
    g_cyDoubleClk = GetSystemMetrics(37);
  }
  result = SystemParametersInfoW(0x66u, 0, &g_dwHoverSelectTimeout, 0);
  if ( phkResult )
    result = RegCloseKey(phkResult);
  return result;
}
// 6F7E6820: using guessed type int g_cyFrame;
// 6F7E6854: using guessed type int g_cxFrame;
// 6F7E6868: using guessed type int g_bRemoteSession;
// 6F7E6870: using guessed type int g_uDragImages;
// 6F7E687C: using guessed type int g_cyScreen;
// 6F7E6888: using guessed type int g_cxScreen;
// 6F7E68A0: using guessed type int g_fDragFullWindows;
// 6F7E68C0: using guessed type int dword_6F7E68C0;
// 6F7E6930: using guessed type int g_msgMSWheel;
// 6F7E696C: using guessed type int g_cyScrollbar;
// 6F7E6970: using guessed type int g_cxScrollbar;
// 6F7E6974: using guessed type int g_cyDoubleClk;
// 6F7E6978: using guessed type int g_cxDoubleClk;
// 6F7E697C: using guessed type int g_cxLabelMargin;
// 6F7E6980: using guessed type int g_cyLabelSpace;
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;
// 6F7E698C: using guessed type int g_cyIconSpacing;
// 6F7E6990: using guessed type int g_cxIconSpacing;
// 6F7E699C: using guessed type int g_cyIcon;
// 6F7E69A0: using guessed type int g_cxIcon;
// 6F7E69A4: using guessed type int g_cyHScroll;
// 6F7E69A8: using guessed type int g_cxVScroll;
// 6F7E6C08: using guessed type int g_ucScrollLines;
// 6F7E6C0C: using guessed type int g_dwHoverSelectTimeout;

//----- (6F774A9D) --------------------------------------------------------
HGDIOBJ __stdcall InitGlobalColors()
{
  HGDIOBJ result; // eax@1

  g_clrWindow = GetSysColor(5);
  g_clrWindowText = GetSysColor(8);
  g_clrWindowFrame = GetSysColor(6);
  g_clrGrayText = GetSysColor(17);
  g_clrBtnText = GetSysColor(18);
  g_clrBtnFace = GetSysColor(15);
  g_clrBtnShadow = GetSysColor(16);
  g_clrBtnHighlight = GetSysColor(20);
  g_clrHighlight = GetSysColor(13);
  g_clrHighlightText = GetSysColor(14);
  g_clrInfoText = GetSysColor(23);
  g_clrInfoBk = GetSysColor(24);
  g_clr3DDkShadow = GetSysColor(21);
  g_clr3DLight = GetSysColor(22);
  g_hbrGrayText = (int)GetSysColorBrush(17);
  g_hbrWindow = GetSysColorBrush(5);
  g_hbrWindowText = (int)GetSysColorBrush(8);
  g_hbrWindowFrame = (int)GetSysColorBrush(6);
  g_hbrBtnFace = GetSysColorBrush(15);
  g_hbrBtnHighlight = GetSysColorBrush(20);
  g_hbrBtnShadow = GetSysColorBrush(16);
  g_hbrHighlight = GetSysColorBrush(13);
  result = GetStockObject(13);
  g_hfontSystem = result;
  return result;
}
// 6F7E6884: using guessed type int g_hbrGrayText;
// 6F7E6890: using guessed type int g_hbrWindowFrame;
// 6F7E6894: using guessed type int g_hbrWindowText;
// 6F7E6934: using guessed type int g_clr3DLight;
// 6F7E693C: using guessed type int g_clrInfoBk;
// 6F7E6940: using guessed type int g_clrInfoText;
// 6F7E6960: using guessed type int g_clrWindowFrame;

//----- (6F774BBD) --------------------------------------------------------
HMODULE __stdcall InitIme()
{
  HMODULE result; // eax@2
  HMODULE v1; // edi@3

  g_fMEEnabled = GetSystemMetrics(74);
  g_fDBCSInputEnabled = GetSystemMetrics(42);
  g_fDBCSEnabled = g_fDBCSInputEnabled;
  if ( g_fDBCSInputEnabled || (result = (HMODULE)GetSystemMetrics(82), (g_fDBCSInputEnabled = (int)result) != 0) )
  {
    result = LoadLibraryW(L"imm32.dll");
    v1 = result;
    if ( !g_pfnImmSetCandidateWindow )
    {
      if ( !result
        || (result = (HMODULE)GetProcAddress(result, "ImmCreateContext"), (g_pfnImmCreateContext = (int)result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmDestroyContext"), (g_pfnImmDestroyContext = (int)result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmNotifyIME"),
            (g_pfnImmNotifyIME = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmAssociateContext"),
            (g_pfnImmAssociateContext = (int (__stdcall *)(_DWORD, _DWORD))result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmReleaseContext"), (g_pfnImmReleaseContext = (int)result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmGetContext"),
            (g_pfnImmGetContext = (int (__stdcall *)(_DWORD))result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmGetCompositionStringA"),
            (g_pfnImmGetCompositionStringA = (int)result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmSetCompositionStringA"),
            (g_pfnImmSetCompositionStringA = (int)result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmGetCompositionStringW"),
            (g_pfnImmGetCompositionStringW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmSetCompositionStringW"),
            (g_pfnImmSetCompositionStringW = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))result) == 0)
        || (result = (HMODULE)GetProcAddress(v1, "ImmSetCandidateWindow"),
            (g_pfnImmSetCandidateWindow = (int)result) == 0) )
      {
        g_fDBCSEnabled = 0;
        g_fDBCSInputEnabled = 0;
      }
    }
  }
  return result;
}
// 6F7E6810: using guessed type int g_pfnImmDestroyContext;
// 6F7E6814: using guessed type int g_pfnImmSetCandidateWindow;
// 6F7E681C: using guessed type int g_pfnImmReleaseContext;
// 6F7E6824: using guessed type int (__stdcall *g_pfnImmAssociateContext)(_DWORD, _DWORD);
// 6F7E6828: using guessed type int g_pfnImmCreateContext;
// 6F7E682C: using guessed type int (__stdcall *g_pfnImmGetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD);
// 6F7E6830: using guessed type int (__stdcall *g_pfnImmNotifyIME)(_DWORD, _DWORD, _DWORD, _DWORD);
// 6F7E6838: using guessed type int g_pfnImmGetCompositionStringA;
// 6F7E683C: using guessed type int (__stdcall *g_pfnImmGetContext)(_DWORD);
// 6F7E6850: using guessed type int (__stdcall *g_pfnImmSetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 6F7E6858: using guessed type int g_pfnImmSetCompositionStringA;
// 6F7E68D4: using guessed type int g_fDBCSEnabled;
// 6F7E68D8: using guessed type int g_fMEEnabled;
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F774E19) --------------------------------------------------------
signed int __cdecl _get_osplatform(int a1)
{
  signed int result; // eax@3

  if ( a1 && _osplatform )
  {
    *(_DWORD *)a1 = _osplatform;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 6F7E68F4: using guessed type int _osplatform;

//----- (6F774E53) --------------------------------------------------------
void *__cdecl calloc(size_t NumOfElements, size_t SizeOfElements)
{
  LPVOID v2; // edi@1
  int v4; // esi@3
  int v5; // [sp+4h] [bp-4h]@1

  v5 = 0;
  v2 = _calloc_impl(NumOfElements, SizeOfElements, (int)&v5);
  if ( !v2 )
  {
    v4 = v5;
    if ( v5 )
    {
      if ( _errno() )
        *_errno() = v4;
    }
  }
  return v2;
}

//----- (6F774E84) --------------------------------------------------------
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ulAugend + ulAddend < ulAugend )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ulAugend + ulAddend;
    result = 0;
  }
  return result;
}

//----- (6F774EA7) --------------------------------------------------------
void __cdecl __security_init_cookie()
{
  DWORD v0; // esi@5
  DWORD v1; // esi@5
  DWORD v2; // esi@5
  DWORD v3; // esi@5
  DWORD v4; // esi@5
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-10h]@5
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-8h]@1

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie != -1153374642 && __security_cookie & 0xFFFF0000 )
  {
    __security_cookie_complement = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v0 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v1 = GetCurrentProcessId() ^ v0;
    v2 = GetCurrentThreadId() ^ v1;
    v3 = GetTickCount() ^ v2;
    QueryPerformanceCounter(&PerformanceCount);
    v4 = PerformanceCount.LowPart ^ PerformanceCount.HighPart ^ v3;
    if ( v4 == -1153374642 || !(__security_cookie & 0xFFFF0000) )
      v4 = -1153374641;
    __security_cookie = v4;
    __security_cookie_complement = ~v4;
  }
}
// 6F7E62E0: using guessed type int __security_cookie_complement;

//----- (6F774F31) --------------------------------------------------------
int __cdecl _initp_misc_rand_s(int a1)
{
  int result; // eax@1

  result = a1;
  dword_6F7E6920 = a1;
  return result;
}
// 6F7E6920: using guessed type int dword_6F7E6920;

//----- (6F774F45) --------------------------------------------------------
int __cdecl _initp_misc_initcrit(int a1)
{
  int result; // eax@1

  result = a1;
  dword_6F7E6924 = a1;
  return result;
}
// 6F7E6924: using guessed type int dword_6F7E6924;

//----- (6F77504B) --------------------------------------------------------
int __usercall sub_6F77504B@<eax>(int a1@<esi>)
{
  unsigned int v1; // eax@2
  BYTE v2; // al@4
  int result; // eax@5
  WORD v4; // cx@6
  CHAR v5; // cl@11
  int v6; // ebx@14
  unsigned int v7; // ecx@15
  unsigned int v8; // eax@15
  int v9; // ebx@17
  unsigned int v10; // ecx@19
  char v11; // dl@21
  int v12; // [sp+8h] [bp-51Ch]@19
  struct _cpinfo CPInfo; // [sp+Ch] [bp-518h]@1
  WORD CharType[256]; // [sp+20h] [bp-504h]@5
  CHAR v15[256]; // [sp+220h] [bp-304h]@5
  CHAR v16[256]; // [sp+320h] [bp-204h]@5
  char Dst[256]; // [sp+420h] [bp-104h]@3

  if ( GetCPInfo(*(_DWORD *)(a1 + 4), &CPInfo) )
  {
    v1 = 0;
    do
    {
      Dst[v1] = v1;
      ++v1;
    }
    while ( v1 < 0x100 );
    v2 = CPInfo.LeadByte[0];
    Dst[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v6 = (int)&CPInfo.LeadByte[1];
      do
      {
        v7 = v2;
        v8 = *(_BYTE *)v6;
        if ( v7 <= v8 )
          memset(&Dst[v7], 32, v8 - v7 + 1);
        v9 = v6 + 1;
        v2 = *(_BYTE *)v9;
        v6 = v9 + 1;
      }
      while ( v2 );
    }
    __crtGetStringTypeA(0, 1u, Dst, 256, CharType, *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 12), 0);
    __crtLCMapStringA(0, *(_DWORD *)(a1 + 12), 0x100u, Dst, 256, v16, 256, *(_DWORD *)(a1 + 4), 0);
    __crtLCMapStringA(0, *(_DWORD *)(a1 + 12), 0x200u, Dst, 256, v15, 256, *(_DWORD *)(a1 + 4), 0);
    result = 0;
    while ( 1 )
    {
      v4 = CharType[result];
      if ( v4 & 1 )
        break;
      if ( v4 & 2 )
      {
        *(_BYTE *)(a1 + result + 29) |= 0x20u;
        v5 = v15[result];
LABEL_13:
        *(_BYTE *)(a1 + result + 285) = v5;
        goto LABEL_9;
      }
      *(_BYTE *)(a1 + result + 285) = 0;
LABEL_9:
      ++result;
      if ( (unsigned int)result >= 0x100 )
        return result;
    }
    *(_BYTE *)(a1 + result + 29) |= 0x10u;
    v5 = v16[result];
    goto LABEL_13;
  }
  v10 = 0;
  v12 = -97 - (a1 + 285);
  do
  {
    result = a1 + v10 + 285;
    if ( (unsigned int)(result + v12 + 32) <= 0x19 )
    {
      *(_BYTE *)(a1 + v10 + 29) |= 0x10u;
      v11 = v10 + 32;
LABEL_24:
      *(_BYTE *)result = v11;
      goto LABEL_26;
    }
    if ( (unsigned int)(result + v12) <= 0x19 )
    {
      *(_BYTE *)(a1 + v10 + 29) |= 0x20u;
      v11 = v10 - 32;
      goto LABEL_24;
    }
    *(_BYTE *)result = 0;
LABEL_26:
    ++v10;
  }
  while ( v10 < 0x100 );
  return result;
}
// 6F77504B: using guessed type char Dst[256];
// 6F77504B: using guessed type CHAR var_204[256];
// 6F77504B: using guessed type WORD CharType[256];
// 6F77504B: using guessed type CHAR var_304[256];

//----- (6F775153) --------------------------------------------------------
signed int _mtinitlocks()
{
  signed int v0; // esi@1
  struct _RTL_CRITICAL_SECTION *v1; // edi@1
  LPCRITICAL_SECTION *v3; // eax@6

  v0 = 0;
  v1 = (struct _RTL_CRITICAL_SECTION *)dword_6F7E7208;
  while ( 1 )
  {
    if ( dword_6F7E70EC[2 * v0] == 1 )
    {
      v3 = &lpCriticalSection + 2 * v0;
      *v3 = v1;
      ++v1;
      if ( !__crtInitCritSecAndSpinCountEx(*v3, 4000) )
        break;
    }
    ++v0;
    if ( v0 >= 36 )
      return 1;
  }
  *(&lpCriticalSection + 2 * v0) = 0;
  return 0;
}
// 6F7751A2: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCountEx(_DWORD, _DWORD);
// 6F7E70EC: using guessed type int dword_6F7E70EC[];
// 6F7E7208: using guessed type int dword_6F7E7208[86];

//----- (6F7751BB) --------------------------------------------------------
int __cdecl __crtInitCritSecAndSpinCount(int a1, int a2)
{
  FARPROC v2; // esi@1
  int v3; // ST28_4@2
  HMODULE v5; // edi@5
  int v6; // [sp+0h] [bp-34h]@0
  int v7; // [sp+4h] [bp-30h]@0
  int v8; // [sp+8h] [bp-2Ch]@0
  int v9; // [sp+Ch] [bp-28h]@0
  int v10; // [sp+10h] [bp-24h]@0
  int v11; // [sp+14h] [bp-20h]@0
  int v12; // [sp+18h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+1Ch] [bp-18h]@2
  int savedregs; // [sp+34h] [bp+0h]@2

  v12 = 0;
  v2 = (FARPROC)_decode_pointer(dword_6F7E6924);
  if ( !v2 )
  {
    if ( _get_osplatform((int)&v12) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v12 != 1 )
    {
      v5 = GetModuleHandleW(L"kernelbase.dll");
      if ( v5 )
      {
        v2 = GetProcAddress(v5, "InitializeCriticalSectionAndSpinCount");
        if ( v2 )
        {
LABEL_7:
          dword_6F7E6924 = _encode_pointer((int)v2);
          goto LABEL_2;
        }
      }
      else
      {
        GetModuleHandleW(L"kernel32.dll");
      }
    }
    v2 = (FARPROC)sub_6F7DE4F1;
    goto LABEL_7;
  }
LABEL_2:
  v3 = ((int (__stdcall *)(int, int, int, int, int, int, int, int, int, DWORD, EXCEPTION_POINTERS *, struct _EH3_EXCEPTION_REGISTRATION *, PVOID, PSCOPETABLE_ENTRY, _DWORD, int))v2)(
         a1,
         a2,
         v6,
         v7,
         v8,
         v9,
         v10,
         v11,
         v12,
         ms_exc.old_esp,
         ms_exc.exc_ptr,
         ms_exc.registration.Next,
         ms_exc.registration.ExceptionHandler,
         ms_exc.registration.ScopeTable,
         0,
         savedregs);
  ms_exc.registration.TryLevel = -2;
  return v3;
}
// 6F7E6924: using guessed type int dword_6F7E6924;

//----- (6F7752C3) --------------------------------------------------------
signed int _mtinit()
{
  HMODULE v0; // eax@1
  HMODULE v1; // edi@1
  DWORD v2; // eax@7
  int v3; // eax@10
  int v4; // ST08_4@10
  LPVOID v5; // eax@11
  int v6; // esi@11
  LPVOID v7; // ST0C_4@12
  int v8; // ST08_4@12
  int v9; // eax@12
  int v10; // ST04_4@12

  v0 = GetModuleHandleW(L"KERNEL32.DLL");
  v1 = v0;
  if ( v0 )
  {
    gpFlsAlloc = (int)GetProcAddress(v0, "FlsAlloc");
    gpFlsGetValue = GetProcAddress(v1, "FlsGetValue");
    gpFlsSetValue = (int)GetProcAddress(v1, "FlsSetValue");
    gpFlsFree = (int)GetProcAddress(v1, "FlsFree");
  }
  if ( !gpFlsAlloc || !gpFlsGetValue || !gpFlsSetValue || !gpFlsFree )
  {
    gpFlsGetValue = TlsGetValue;
    gpFlsAlloc = (int)__crtTlsAlloc;
    gpFlsSetValue = (int)TlsSetValue;
    gpFlsFree = (int)TlsFree;
  }
  v2 = TlsAlloc();
  __getvalueindex = v2;
  if ( v2 != -1 && TlsSetValue(v2, gpFlsGetValue) )
  {
    _init_pointers();
    gpFlsAlloc = _encode_pointer(gpFlsAlloc);
    gpFlsGetValue = (LPVOID)_encode_pointer((int)gpFlsGetValue);
    gpFlsSetValue = _encode_pointer(gpFlsSetValue);
    gpFlsFree = _encode_pointer(gpFlsFree);
    if ( _mtinitlocks() )
    {
      v3 = _decode_pointer(gpFlsAlloc);
      __flsindex = ((int (__thiscall *)(int, int (__stdcall *)(void *)))v3)(v4, _freefls);
      if ( __flsindex != -1 )
      {
        v5 = _calloc_crt(1u, 532);
        v6 = (int)v5;
        if ( v5 )
        {
          v7 = v5;
          v8 = __flsindex;
          v9 = _decode_pointer(gpFlsSetValue);
          if ( ((int (__thiscall *)(int, int, LPVOID))v9)(v10, v8, v7) )
          {
            _initptd(v6, 0);
            *(_DWORD *)(v6 + 4) = -1;
            return 1;
          }
          free((void *)v6);
        }
      }
    }
    _mtterm();
  }
  return 0;
}
// 6F7765A1: using guessed type int _init_pointers(void);
// 6F776DA9: using guessed type int _mtterm(void);
// 6F7E62C0: using guessed type int gpFlsFree;
// 6F7E62C8: using guessed type int gpFlsSetValue;
// 6F7E62D8: using guessed type int gpFlsAlloc;
// 6F7E6804: using guessed type int __flsindex;

//----- (6F77545A) --------------------------------------------------------
int __cdecl _encode_pointer(int a1)
{
  int v1; // ST04_4@3
  LPVOID v2; // eax@3
  int v3; // eax@3
  FARPROC v4; // eax@4
  HMODULE v6; // eax@8

  if ( TlsGetValue(__getvalueindex)
    && __flsindex != -1
    && (v1 = __flsindex, v2 = TlsGetValue(__getvalueindex), (v3 = ((int (__stdcall *)(_DWORD))v2)(v1)) != 0) )
  {
    v4 = *(FARPROC *)(v3 + 504);
  }
  else
  {
    v6 = GetModuleHandleW(L"KERNELBASE.DLL");
    if ( !v6 )
    {
      v6 = GetModuleHandleW(L"KERNEL32.DLL");
      if ( !v6 )
        return a1;
    }
    v4 = GetProcAddress(v6, "EncodePointer");
  }
  if ( v4 )
    a1 = ((int (__stdcall *)(_DWORD))v4)(a1);
  return a1;
}
// 6F7E6804: using guessed type int __flsindex;

//----- (6F775526) --------------------------------------------------------
int __cdecl sub_6F775526(DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7)
{
  int v7; // ecx@0
  signed int v8; // eax@1
  void *v9; // ebx@1
  int v10; // edi@1
  int v11; // eax@5
  int v12; // edi@5
  int v13; // eax@8
  void *v14; // esp@9
  void *v15; // eax@9
  int v16; // eax@14
  void *v18; // esi@29
  UINT v19; // eax@33
  const CHAR *v20; // eax@35
  BOOL v21; // edi@37
  signed int v22; // [sp+0h] [bp-14h]@9
  WORD CharType[2]; // [sp+Ch] [bp-8h]@2

  v8 = dword_6F7E692C;
  v9 = 0;
  v10 = v7;
  if ( !dword_6F7E692C )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, CharType) )
    {
      dword_6F7E692C = 1;
      goto LABEL_4;
    }
    if ( GetLastError() == 120 )
    {
      v8 = 2;
      dword_6F7E692C = 2;
    }
    else
    {
      v8 = dword_6F7E692C;
    }
  }
  if ( v8 != 2 && v8 )
  {
    if ( v8 != 1 )
      return 0;
LABEL_4:
    *(_DWORD *)CharType = 0;
    if ( !CodePage )
      CodePage = *(_DWORD *)(*(_DWORD *)v10 + 4);
    v11 = MultiByteToWideChar(CodePage, 8 * (a7 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
    v12 = v11;
    if ( !v11 )
      return 0;
    if ( v11 <= 0 || (unsigned int)v11 > 0x7FFFFFF0 )
      goto LABEL_13;
    v13 = 2 * v11 + 8;
    if ( (unsigned int)v13 > 0x400 )
    {
      v15 = malloc(2 * v12 + 8);
      if ( !v15 )
        goto LABEL_12;
      *(_DWORD *)v15 = 56797;
    }
    else
    {
      v14 = alloca(v13);
      v15 = &v22;
      if ( !&v22 )
      {
LABEL_12:
        v9 = v15;
LABEL_13:
        if ( v9 )
        {
          memset(v9, 0, 2 * v12);
          v16 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v9, v12);
          if ( v16 )
            *(_DWORD *)CharType = GetStringTypeW(dwInfoType, (LPCWSTR)v9, v16, lpCharType);
          _freea(v9);
          return *(_DWORD *)CharType;
        }
        return 0;
      }
      v22 = 52428;
    }
    v15 = (char *)v15 + 8;
    goto LABEL_12;
  }
  v18 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)v10 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)v10 + 4);
  v19 = __ansicp(Locale);
  if ( v19 == -1 )
    return 0;
  if ( v19 != CodePage )
  {
    v20 = (const CHAR *)__convertcp(CodePage, v19, (int)lpMultiByteStr, (int)&cbMultiByte, 0, 0);
    v18 = (void *)v20;
    if ( !v20 )
      return 0;
    lpMultiByteStr = v20;
  }
  v21 = GetStringTypeA(Locale, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType);
  if ( v18 )
    free(v18);
  return v21;
}
// 6F7E692C: using guessed type int dword_6F7E692C;

//----- (6F77566A) --------------------------------------------------------
signed int __usercall sub_6F77566A@<eax>(int a1@<esi>, int a2, int a3, int a4, signed int *a5)
{
  unsigned int v5; // edx@30
  int v6; // eax@1
  signed int *v7; // ecx@1
  signed int v8; // edx@1
  int v9; // edi@1
  int v10; // edx@3
  int v11; // ecx@8
  char v12; // bl@9
  unsigned int v13; // ST00_4@9
  int v14; // ebx@16
  signed int result; // eax@20
  int v16; // eax@34
  int v17; // edx@39
  char v18; // al@43
  int v19; // eax@48
  int v20; // ecx@50
  int v21; // eax@59
  int v22; // ecx@63
  int v23; // ecx@65
  signed int v24; // [sp+8h] [bp-8h]@1
  int v25; // [sp+Ch] [bp-4h]@1
  signed int v26; // [sp+18h] [bp+8h]@28
  int v27; // [sp+18h] [bp+8h]@4

  v6 = *(_DWORD *)a1;
  v7 = a5;
  v8 = *a5;
  *(_DWORD *)a1 = 0;
  v25 = v6;
  v9 = a2;
  v24 = v8;
  *a5 = 1;
  if ( a3 && v8 >= 1 )
  {
    v10 = a3;
    a3 += 4;
    *(_DWORD *)v10 = a4;
  }
  v27 = 0;
  do
  {
    if ( *(_BYTE *)v9 == 34 )
    {
      v12 = 34;
      ++v9;
      v27 = v27 == 0;
    }
    else
    {
      ++*(_DWORD *)a1;
      if ( a4 && *(_DWORD *)a1 <= v25 )
      {
        v11 = a4++;
        *(_BYTE *)v11 = *(_BYTE *)v9;
      }
      v12 = *(_BYTE *)v9;
      v13 = *(_BYTE *)v9++;
      if ( _ismbblead(v13) )
      {
        ++*(_DWORD *)a1;
        if ( a4 && *(_DWORD *)a1 <= v25 )
        {
          v22 = a4++;
          *(_BYTE *)v22 = *(_BYTE *)v9;
        }
        ++v9;
      }
      v7 = a5;
      if ( !v12 )
      {
        --v9;
        goto LABEL_16;
      }
    }
  }
  while ( v27 || v12 != 32 && v12 != 9 );
  if ( a4 )
    *(_BYTE *)(a4 - 1) = 0;
LABEL_16:
  v14 = 0;
  while ( *(_BYTE *)v9 )
  {
    while ( *(_BYTE *)v9 == 32 || *(_BYTE *)v9 == 9 )
      ++v9;
    if ( !*(_BYTE *)v9 )
      break;
    ++*v7;
    if ( a3 && *v7 <= v24 )
    {
      v17 = a3;
      a3 += 4;
      *(_DWORD *)v17 = a4;
    }
    while ( 1 )
    {
      v26 = 1;
      v5 = 0;
      while ( *(_BYTE *)v9 == 92 )
      {
        ++v9;
        ++v5;
      }
      if ( *(_BYTE *)v9 == 34 )
      {
        if ( !(v5 & 1) )
        {
          if ( v14 && *(_BYTE *)(v9 + 1) == 34 )
            ++v9;
          else
            v26 = 0;
          v14 = v14 == 0;
        }
        v5 >>= 1;
      }
      while ( v5 )
      {
        --v5;
        ++*(_DWORD *)a1;
        if ( a4 && *(_DWORD *)a1 <= v25 )
        {
          v21 = a4++;
          *(_BYTE *)v21 = 92;
        }
      }
      v18 = *(_BYTE *)v9;
      if ( !*(_BYTE *)v9 || !v14 && (v18 == 32 || v18 == 9) )
        break;
      if ( v26 )
      {
        ++*(_DWORD *)a1;
        v19 = _ismbblead(*(_BYTE *)v9);
        if ( a4 )
        {
          if ( v19 )
          {
            v23 = a4++;
            *(_BYTE *)v23 = *(_BYTE *)v9++;
            ++*(_DWORD *)a1;
          }
          v20 = a4++;
          *(_BYTE *)v20 = *(_BYTE *)v9;
        }
        else if ( v19 )
        {
          ++v9;
          ++*(_DWORD *)a1;
        }
        v7 = a5;
      }
      ++v9;
    }
    ++*(_DWORD *)a1;
    if ( a4 && *(_DWORD *)a1 <= v25 )
    {
      v16 = a4++;
      *(_BYTE *)v16 = 0;
    }
  }
  ++*v7;
  result = *v7;
  if ( a3 && result <= v24 )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (6F775732) --------------------------------------------------------
int __cdecl _initterm_e(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int result; // eax@1

  v2 = a1;
  result = 0;
  while ( v2 < a2 && !result )
  {
    if ( *(_DWORD *)v2 )
      result = (*(int (**)(void))v2)();
    v2 += 4;
  }
  return result;
}

//----- (6F77575B) --------------------------------------------------------
signed int _ioinit()
{
  void *v0; // eax@1
  int i; // ecx@2
  signed int v2; // ebx@6
  int v3; // esi@7
  DWORD v4; // eax@9
  HANDLE v5; // eax@10
  HANDLE v6; // edi@10
  DWORD v7; // eax@12
  int v8; // eax@13
  signed int result; // eax@18
  signed int v10; // edi@26
  LPBYTE v11; // ebx@26
  signed int v12; // esi@28
  void *v13; // eax@29
  int *v14; // ecx@30
  int j; // edx@30
  int v16; // esi@43
  struct _STARTUPINFOA StartupInfo; // [sp+10h] [bp-64h]@1
  int k; // [sp+54h] [bp-20h]@37
  HANDLE *v19; // [sp+58h] [bp-1Ch]@26
  CPPEH_RECORD ms_exc; // [sp+5Ch] [bp-18h]@1

  ms_exc.registration.TryLevel = 0;
  GetStartupInfoA(&StartupInfo);
  ms_exc.registration.TryLevel = -2;
  v0 = calloc(0x20u, 0x24u);
  if ( v0 )
  {
    __pioinfo[0] = (int)v0;
    _nhandle = 32;
    for ( i = (int)((char *)v0 + 1152); (unsigned int)v0 < i; i = __pioinfo[0] + 1152 )
    {
      *((_BYTE *)v0 + 4) = 0;
      *(_DWORD *)v0 = -1;
      *((_BYTE *)v0 + 5) = 10;
      *((_DWORD *)v0 + 2) = 0;
      *((_BYTE *)v0 + 6) = 10;
      *((_BYTE *)v0 + 7) = 10;
      v0 = (char *)v0 + 36;
    }
    if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
    {
      v10 = *(_DWORD *)StartupInfo.lpReserved2;
      v11 = StartupInfo.lpReserved2 + 4;
      v19 = (HANDLE *)&StartupInfo.lpReserved2[*(_DWORD *)StartupInfo.lpReserved2 + 4];
      if ( v10 >= 2048 )
        v10 = 2048;
      v12 = 1;
      while ( (signed int)_nhandle < v10 )
      {
        v13 = calloc(0x20u, 0x24u);
        if ( !v13 )
        {
          v10 = _nhandle;
          break;
        }
        v14 = &__pioinfo[v12];
        *v14 = (int)v13;
        _nhandle += 32;
        for ( j = (int)((char *)v13 + 1152); (unsigned int)v13 < j; j = *v14 + 1152 )
        {
          *((_BYTE *)v13 + 4) = 0;
          *(_DWORD *)v13 = -1;
          *((_BYTE *)v13 + 5) = 10;
          *((_DWORD *)v13 + 2) = 0;
          *((_BYTE *)v13 + 6) = 10;
          *((_BYTE *)v13 + 7) = 10;
          v13 = (char *)v13 + 36;
        }
        ++v12;
      }
      for ( k = 0; k < v10; ++v19 )
      {
        if ( *v19 != (HANDLE)-1 && *v19 != (HANDLE)-2 && *v11 & 1 && (*v11 & 8 || GetFileType(*v19)) )
        {
          v16 = __pioinfo[k >> 5] + 36 * (k & 0x1F);
          *(_DWORD *)v16 = *v19;
          *(_BYTE *)(v16 + 4) = *v11;
          if ( !__crtInitCritSecAndSpinCount(v16 + 12, 4000) )
            goto LABEL_21;
          *(_DWORD *)(v16 + 8) |= 4u;
        }
        ++k;
        ++v11;
      }
    }
    v2 = 0;
    do
    {
      v3 = __pioinfo[0] + 36 * v2;
      if ( *(_DWORD *)v3 == -1 || *(_DWORD *)v3 == -2 )
      {
        *(_BYTE *)(v3 + 4) = -127;
        if ( v2 )
          v4 = -(v2 != 1) - 11;
        else
          v4 = -10;
        v5 = GetStdHandle(v4);
        v6 = v5;
        if ( v5 != (HANDLE)-1 && v5 && (v7 = GetFileType(v5)) != 0 )
        {
          *(_DWORD *)v3 = v6;
          v8 = (unsigned __int8)v7;
          if ( v8 == 2 )
          {
            *(_BYTE *)(v3 + 4) |= 0x40u;
          }
          else if ( v8 == 3 )
          {
            *(_BYTE *)(v3 + 4) |= 8u;
          }
          if ( !__crtInitCritSecAndSpinCount(v3 + 12, 4000) )
            goto LABEL_21;
          *(_DWORD *)(v3 + 8) |= 4u;
        }
        else
        {
          *(_BYTE *)(v3 + 4) |= 0x40u;
          *(_DWORD *)v3 = -2;
        }
      }
      else
      {
        *(_BYTE *)(v3 + 4) |= 0x80u;
      }
      ++v2;
    }
    while ( v2 < 3 );
    SetHandleCount(_nhandle);
    result = 0;
  }
  else
  {
LABEL_21:
    result = -1;
  }
  return result;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7758A2) --------------------------------------------------------
signed int __initstdio()
{
  size_t v0; // eax@1
  void *v1; // eax@4
  int v2; // edx@5
  FILE *v3; // ecx@5
  signed int v4; // edx@8
  signed int v5; // ecx@8
  int v6; // eax@9
  signed int result; // eax@13

  v0 = _nstream;
  if ( _nstream )
  {
    if ( _nstream >= 20 )
      goto LABEL_4;
    v0 = 20;
  }
  else
  {
    v0 = 512;
  }
  _nstream = v0;
LABEL_4:
  v1 = calloc(v0, 4u);
  __piob = v1;
  if ( v1 || (_nstream = 20, v1 = calloc(0x14u, 4u), (__piob = v1) != 0) )
  {
    v2 = 0;
    v3 = _iob;
    while ( 1 )
    {
      *(_DWORD *)((char *)v1 + v2) = v3;
      ++v3;
      v2 += 4;
      if ( (signed int)v3 >= (signed int)__lconv_c )
        break;
      v1 = __piob;
    }
    v4 = 0;
    v5 = (signed int)dword_6F7E6520;
    do
    {
      v6 = *(_DWORD *)(36 * (v4 & 0x1F) + __pioinfo[v4 >> 5]);
      if ( v6 == -1 || v6 == -2 || !v6 )
        *(_DWORD *)v5 = -2;
      v5 += 32;
      ++v4;
    }
    while ( v5 < (signed int)dword_6F7E6580 );
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7E6520: using guessed type int dword_6F7E6520[2];
// 6F7E6580: using guessed type int dword_6F7E6580[124];
// 6F7E6790: using guessed type int *__lconv_c[10];
// 6F7E69BC: using guessed type int _nstream;

//----- (6F775944) --------------------------------------------------------
LONG __cdecl __addlocaleref(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  volatile LONG *v2; // ebx@5
  volatile LONG *lpAddenda; // [sp+14h] [bp+8h]@5

  v1 = lpAddend;
  InterlockedIncrement(lpAddend);
  if ( *((_DWORD *)lpAddend + 44) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 44));
  if ( *((_DWORD *)lpAddend + 46) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 46));
  if ( *((_DWORD *)lpAddend + 45) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 45));
  if ( *((_DWORD *)lpAddend + 48) )
    InterlockedIncrement(*((volatile LONG **)lpAddend + 48));
  v2 = lpAddend + 20;
  lpAddenda = (volatile LONG *)6;
  do
  {
    if ( *((int **)v2 - 2) != __clocalestr && *v2 )
      InterlockedIncrement(*(volatile LONG **)v2);
    if ( *((_DWORD *)v2 - 1) && *((_DWORD *)v2 + 1) )
      InterlockedIncrement(*((volatile LONG **)v2 + 1));
    v2 += 4;
    lpAddenda = (volatile LONG *)((char *)lpAddenda - 1);
  }
  while ( lpAddenda );
  return InterlockedIncrement((volatile LONG *)(*((_DWORD *)v1 + 53) + 180));
}
// 6F7E6F40: using guessed type int __clocalestr[2];

//----- (6F775CFC) --------------------------------------------------------
int __cdecl _initptd(int a1, int a2)
{
  HMODULE hModule; // [sp+10h] [bp-1Ch]@1

  hModule = GetModuleHandleW(L"KERNELBASE.DLL");
  if ( !hModule )
    hModule = GetModuleHandleW(L"KERNEL32.DLL");
  *(_DWORD *)(a1 + 92) = _XcptActTab;
  *(_DWORD *)(a1 + 20) = 1;
  if ( hModule )
  {
    *(_DWORD *)(a1 + 504) = GetProcAddress(hModule, "EncodePointer");
    *(_DWORD *)(a1 + 508) = GetProcAddress(hModule, "DecodePointer");
  }
  *(_DWORD *)(a1 + 112) = 1;
  *(_BYTE *)(a1 + 200) = 67;
  *(_BYTE *)(a1 + 331) = 67;
  *(_DWORD *)(a1 + 104) = &__initialmbcinfo;
  InterlockedIncrement(&__initialmbcinfo);
  _lock(12);
  *(_DWORD *)(a1 + 108) = a2;
  if ( !a2 )
    *(_DWORD *)(a1 + 108) = ___ptlocinfo;
  __addlocaleref(*(volatile LONG **)(a1 + 108));
  return _unlock(12);
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7E684C: using guessed type _DWORD ___ptlocinfo;
// 6F7E6F68: using guessed type int _XcptActTab[3];

//----- (6F775DE7) --------------------------------------------------------
signed int _setargv()
{
  unsigned int v0; // esi@5
  char **v1; // edi@8
  signed int result; // eax@9
  ULONG pulResult; // [sp+Ch] [bp-14h]@5
  ULONG ulAddend; // [sp+10h] [bp-10h]@6
  unsigned int v5; // [sp+14h] [bp-Ch]@1
  int v6; // [sp+18h] [bp-8h]@4
  unsigned int v7; // [sp+1Ch] [bp-4h]@1

  v7 = 0;
  v5 = 0;
  if ( !__mbctype_initialized )
    __initmbctable();
  byte_6F7E70E4 = 0;
  GetModuleFileNameA(0, Filename, 0x104u);
  _pgmptr = Filename;
  if ( !_acmdln || (v6 = _acmdln, !*(_BYTE *)_acmdln) )
    v6 = (int)Filename;
  sub_6F77566A((int)&v5, v6, 0, 0, (signed int *)&v7);
  v0 = v7;
  if ( ULongLongToULong(4i64 * v7, &pulResult) >= 0
    && ULongLongToULong(4i64 * v5, &ulAddend) >= 0
    && ULongAdd(pulResult, ulAddend, &pulResult) >= 0
    && (v1 = (char **)malloc(pulResult)) != 0 )
  {
    sub_6F77566A((int)&v5, v6, (int)v1, (int)&v1[v0], (signed int *)&v7);
    __argc = v7 - 1;
    __argv = v1;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 6F775ADE: using guessed type int __initmbctable(void);
// 6F7E63EC: using guessed type int _acmdln;
// 6F7E69D0: using guessed type int __mbctype_initialized;
// 6F7E70E4: using guessed type char byte_6F7E70E4;

//----- (6F775EE8) --------------------------------------------------------
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ullOperand > 0xFFFFFFFF )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ullOperand;
    result = 0;
  }
  return result;
}

//----- (6F775F5E) --------------------------------------------------------
int __cdecl sub_6F775F5E(int a1, LCID Locale, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPSTR a6, int cchDest, UINT CodePage, int a9)
{
  UINT v9; // esi@1
  int v10; // ebx@1
  int v11; // ecx@5
  LPCSTR v12; // eax@5
  int v13; // eax@9
  int v14; // eax@15
  int v15; // edi@15
  int v16; // eax@18
  void *v17; // esp@19
  void *v18; // eax@19
  WCHAR *v19; // eax@20
  unsigned int v20; // eax@23
  int v21; // eax@27
  void *v22; // esp@28
  void *v23; // eax@28
  WCHAR *v24; // eax@29
  int v26; // edi@62
  const CHAR *v27; // eax@68
  int v28; // eax@69
  int v29; // esi@70
  int v30; // eax@73
  void *v31; // esp@74
  void *v32; // eax@75
  void *v33; // eax@74
  void *v34; // eax@79
  CHAR *v35; // [sp-10h] [bp-5Ch]@33
  int v36; // [sp-Ch] [bp-58h]@33
  unsigned int v37; // [sp-4h] [bp-50h]@19
  unsigned int v38; // [sp-4h] [bp-50h]@28
  int v39; // [sp+0h] [bp-4Ch]@19
  void *v40; // [sp+10h] [bp-3Ch]@78
  void *Memory; // [sp+14h] [bp-38h]@62
  int v42; // [sp+18h] [bp-34h]@14
  UINT v43; // [sp+1Ch] [bp-30h]@15
  LPCSTR lpSrcStr; // [sp+20h] [bp-2Ch]@14
  size_t Size; // [sp+24h] [bp-28h]@14
  LPWSTR lpDestStr; // [sp+28h] [bp-24h]@14
  LPWSTR lpWideCharStr; // [sp+2Ch] [bp-20h]@21
  CPPEH_RECORD ms_exc; // [sp+34h] [bp-18h]@16

  v9 = CodePage;
  v10 = 0;
  if ( !dword_6F7E6928 )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_6F7E6928 = 1;
    }
    else if ( GetLastError() == 120 )
    {
      dword_6F7E6928 = 2;
    }
  }
  if ( cbMultiByte > 0 )
  {
    v11 = cbMultiByte;
    v12 = lpMultiByteStr;
    while ( 1 )
    {
      --v11;
      if ( !*v12 )
        break;
      ++v12;
      if ( !v11 )
      {
        v11 = -1;
        break;
      }
    }
    v13 = cbMultiByte - v11 - 1;
    if ( v13 < cbMultiByte )
      v13 = cbMultiByte - v11;
    cbMultiByte = v13;
  }
  if ( dword_6F7E6928 != 2 && dword_6F7E6928 )
  {
    if ( dword_6F7E6928 == 1 )
    {
      lpSrcStr = 0;
      lpDestStr = 0;
      v42 = 0;
      Size = 0;
      if ( !v9 )
      {
        v9 = *(_DWORD *)(*(_DWORD *)a1 + 4);
        CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
      }
      v14 = MultiByteToWideChar(v9, 8 * (a9 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
      v15 = v14;
      v43 = v14;
      if ( v14 )
      {
        ms_exc.registration.TryLevel = 1;
        if ( v14 <= 0 || 0xFFFFFFE0 / v14 < 2 )
        {
          v19 = 0;
        }
        else
        {
          v16 = 2 * v14 + 8;
          if ( (unsigned int)v16 > 0x400 )
          {
            v37 = 56797;
            v18 = malloc(2 * v15 + 8);
          }
          else
          {
            v17 = alloca(v16);
            ms_exc.old_esp = (DWORD)&v39;
            v18 = &v39;
            v37 = 52428;
          }
          v19 = (WCHAR *)_MarkAllocaS(v18, v37);
        }
        lpWideCharStr = v19;
        ms_exc.registration.TryLevel = -2;
        if ( v19 )
        {
LABEL_22:
          if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, lpWideCharStr, v15) )
          {
            v20 = LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, 0, 0);
            v10 = v20;
            lpSrcStr = (LPCSTR)v20;
            if ( v20 )
            {
              if ( dwMapFlags & 0x400 )
              {
                if ( cchDest && (signed int)v20 <= cchDest )
                  LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, (LPWSTR)a6, cchDest);
                goto LABEL_35;
              }
              ms_exc.registration.TryLevel = 2;
              if ( (signed int)v20 <= 0 || 0xFFFFFFE0 / v20 < 2 )
              {
                v24 = 0;
              }
              else
              {
                v21 = 2 * v20 + 8;
                if ( (unsigned int)v21 > 0x400 )
                {
                  v38 = 56797;
                  v23 = malloc(2 * v10 + 8);
                }
                else
                {
                  v22 = alloca(v21);
                  ms_exc.old_esp = (DWORD)&v39;
                  v23 = &v39;
                  v38 = 52428;
                }
                v24 = (WCHAR *)_MarkAllocaS(v23, v38);
              }
              lpDestStr = v24;
              ms_exc.registration.TryLevel = -2;
              if ( v24 )
                goto LABEL_31;
              lpDestStr = (LPWSTR)malloc(2 * v10);
              if ( lpDestStr )
              {
                Size = 1;
LABEL_31:
                if ( LCMapStringW(Locale, dwMapFlags, lpWideCharStr, v15, lpDestStr, v10) )
                {
                  if ( cchDest )
                  {
                    v36 = cchDest;
                    v35 = a6;
                  }
                  else
                  {
                    v36 = 0;
                    v35 = 0;
                  }
                  v10 = WideCharToMultiByte(CodePage, 0, lpDestStr, v10, v35, v36, 0, 0);
                }
                goto LABEL_35;
              }
            }
          }
LABEL_35:
          if ( Size )
          {
            free(lpDestStr);
          }
          else if ( lpDestStr )
          {
            _freea(lpDestStr);
          }
          if ( v42 )
          {
            free(lpWideCharStr);
          }
          else if ( lpWideCharStr )
          {
            _freea(lpWideCharStr);
          }
          return v10;
        }
        lpWideCharStr = (LPWSTR)malloc(2 * v15);
        if ( lpWideCharStr )
        {
          v42 = 1;
          goto LABEL_22;
        }
      }
    }
    return 0;
  }
  lpSrcStr = 0;
  v26 = 0;
  Memory = 0;
  v42 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( !v9 )
  {
    v9 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  v43 = __ansicp(Locale);
  if ( v43 == -1 )
    return 0;
  if ( v43 != v9 )
  {
    v27 = (const CHAR *)__convertcp(v9, v43, (int)lpMultiByteStr, (int)&cbMultiByte, 0, 0);
    lpSrcStr = v27;
    if ( !v27 )
      return 0;
    v28 = LCMapStringA(Locale, dwMapFlags, v27, cbMultiByte, 0, 0);
    Size = v28;
    if ( !v28 )
      goto LABEL_70;
    ms_exc.registration.TryLevel = 0;
    if ( v28 <= 0 || (unsigned int)v28 > 0xFFFFFFE0 )
    {
      v33 = 0;
    }
    else
    {
      v30 = v28 + 8;
      if ( (unsigned int)v30 > 0x400 )
      {
        v32 = malloc(v30);
        v33 = _MarkAllocaS(v32, 0xDDDDu);
      }
      else
      {
        v31 = alloca(v30);
        ms_exc.old_esp = (DWORD)&v39;
        v33 = _MarkAllocaS(&v39, 0xCCCCu);
      }
    }
    v26 = (int)v33;
    v40 = v33;
    ms_exc.registration.TryLevel = -2;
    if ( !v33 )
    {
      v34 = malloc(Size);
      v26 = (int)v34;
      if ( !v34 )
        goto LABEL_70;
      memset(v34, 0, Size);
      v42 = 1;
    }
    Size = LCMapStringA(Locale, dwMapFlags, lpSrcStr, cbMultiByte, (LPSTR)v26, Size);
    if ( Size )
    {
      Memory = __convertcp(v43, CodePage, v26, (int)&Size, (int)a6, cchDest);
      v29 = Memory != 0 ? Size : 0;
LABEL_83:
      if ( v42 )
      {
        free((void *)v26);
      }
      else if ( v26 )
      {
        _freea((void *)v26);
      }
      goto LABEL_89;
    }
LABEL_70:
    v29 = 0;
    goto LABEL_83;
  }
  v29 = LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cbMultiByte, a6, cchDest);
LABEL_89:
  if ( lpSrcStr )
    free((void *)lpSrcStr);
  if ( Memory && a6 != Memory )
    free(Memory);
  return v29;
}
// 6F7E6928: using guessed type int dword_6F7E6928;

//----- (6F7761E1) --------------------------------------------------------
void __cdecl _freea(void *Memory)
{
  if ( Memory )
  {
    if ( *((_DWORD *)Memory - 2) == 56797 )
      free((char *)Memory - 8);
  }
}

//----- (6F776203) --------------------------------------------------------
signed int __stdcall _ProcessAttach(HINSTANCE a1)
{
  HMODULE v1; // eax@1
  HMODULE v2; // eax@1
  FARPROC v3; // esi@2
  DWORD v4; // eax@3
  INITCOMMONCONTROLSEX picce; // [sp+4h] [bp-8h]@9

  g_hinst = a1;
  g_uiACP = GetACP();
  InitializeCriticalSection(&g_csDll);
  v1 = GetModuleHandleW(L"LPK.DLL");
  a1 = 0;
  g_bComplexPlatform = (int)v1;
  v2 = GetModuleHandleW(L"KERNEL32");
  g_bRemoteSession = v2
                  && (v3 = GetProcAddress(v2, "ProcessIdToSessionId")) != 0
                  && (v4 = GetCurrentProcessId(), ((int (__stdcall *)(_DWORD, _DWORD))v3)(v4, &a1))
                  && a1;
  InitGlobalMetrics(0);
  InitGlobalColors();
  InitIme();
  if ( IsRunningIn16BitProcess() )
  {
    picce.dwSize = 8;
    picce.dwICC = 255;
    InitCommonControlsEx(&picce);
  }
  return 1;
}
// 6F7E6864: using guessed type int g_bComplexPlatform;
// 6F7E6868: using guessed type int g_bRemoteSession;
// 6F7E68C8: using guessed type int g_uiACP;

//----- (6F7762E1) --------------------------------------------------------
BOOL __stdcall IsRunningIn16BitProcess()
{
  HANDLE v0; // eax@1
  int ProcessInformation; // [sp+0h] [bp-4h]@1

  ProcessInformation = 0;
  v0 = GetCurrentProcess();
  return NtQueryInformationProcess(v0, ProcessWx86Information, &ProcessInformation, 4u, 0) >= 0 && ProcessInformation;
}

//----- (6F776336) --------------------------------------------------------
signed int __cdecl sub_6F776336(struct localeinfo_struct *a1, unsigned __int8 a2, int a3, unsigned __int8 a4)
{
  signed int result; // eax@3
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@6
  char v8; // [sp+Ch] [bp-4h]@5

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v5, a1);
  if ( a4 & *(_BYTE *)(v6 + a2 + 29)
    || (a3 ? (result = (unsigned __int16)(a3 & *(_WORD *)(*(_DWORD *)(v5 + 200) + 2 * a2))) : (result = 0), result) )
    result = 1;
  if ( v8 )
    *(_DWORD *)(v7 + 112) &= 0xFFFFFFFD;
  return result;
}

//----- (6F776382) --------------------------------------------------------
_LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, struct localeinfo_struct *a2)
{
  _LocaleUpdate *v2; // esi@1
  int v3; // eax@2
  int v4; // eax@7
  pthreadmbcinfo v6; // eax@14

  v2 = this;
  *((_BYTE *)this + 12) = 0;
  if ( a2 )
  {
    *(_DWORD *)this = a2->locinfo;
    v6 = a2->mbcinfo;
    goto LABEL_16;
  }
  v3 = _getptd_noexit();
  *((_DWORD *)v2 + 2) = v3;
  if ( !v3 )
  {
    *(_DWORD *)v2 = ___ptlocinfo;
    v6 = (pthreadmbcinfo)___ptmbcinfo;
LABEL_16:
    *((_DWORD *)v2 + 1) = v6;
    return v2;
  }
  *(_DWORD *)v2 = *(_DWORD *)(v3 + 108);
  *((_DWORD *)v2 + 1) = *(_DWORD *)(v3 + 104);
  if ( *(_DWORD *)v2 != ___ptlocinfo && !(*(_BYTE *)(v3 + 112) & 2) && __globallocalestatus & 1 )
    *(_DWORD *)v2 = __updatetlocinfo();
  if ( *((volatile LONG **)v2 + 1) != ___ptmbcinfo
    && !(*(_BYTE *)(*((_DWORD *)v2 + 2) + 112) & 2)
    && __globallocalestatus & 1 )
    *((_DWORD *)v2 + 1) = __updatetmbcinfo();
  v4 = *((_DWORD *)v2 + 2);
  if ( !(*(_BYTE *)(v4 + 112) & 2) )
  {
    *(_DWORD *)(v4 + 112) |= 2u;
    *((_BYTE *)v2 + 12) = 1;
  }
  return v2;
}
// 6F776400: using guessed type int _getptd_noexit(void);
// 6F7E684C: using guessed type _DWORD ___ptlocinfo;
// 6F7E8460: using guessed type char __globallocalestatus;

//----- (6F7764EB) --------------------------------------------------------
BOOL _get_sse2_info()
{
  unsigned int v0; // et0@1
  unsigned int v1; // ecx@1
  unsigned int v2; // et0@1
  int v14; // [sp+18h] [bp-4h]@1

  v14 = 0;
  v0 = __readeflags();
  v1 = v0;
  __writeeflags(v0 ^ 0x200000);
  v2 = __readeflags();
  if ( v2 != v1 )
  {
    __writeeflags(v1);
    _EAX = 0;
    __asm { cpuid }
    _EAX = 1;
    __asm { cpuid }
    v14 = _EDX;
  }
  return v14 & 0x4000000 && sub_6F776552();
}

//----- (6F776552) --------------------------------------------------------
signed int sub_6F776552()
{
  return 1;
}

//----- (6F7765FE) --------------------------------------------------------
LPVOID __cdecl _calloc_crt(size_t Size, int a2)
{
  DWORD v2; // esi@1
  LPVOID v3; // edi@2
  int v5; // eax@7

  v2 = 0;
  do
  {
    v3 = _calloc_impl(Size, a2, 0);
    if ( v3 || (unsigned int)_maxwait <= 0 )
      break;
    Sleep(v2);
    v5 = v2 + 1000;
    if ( v2 + 1000 > _maxwait )
      v5 = -1;
    v2 = v5;
  }
  while ( v5 != -1 );
  return v3;
}
// 6F7E8E1C: using guessed type int _maxwait;

//----- (6F776635) --------------------------------------------------------
LPVOID __cdecl _calloc_impl(size_t Size, int a2, int a3)
{
  unsigned int v3; // esi@3
  LPVOID v4; // ebx@4
  void *Dst; // [sp+10h] [bp-1Ch]@15
  unsigned int Sizea; // [sp+34h] [bp+8h]@3

  if ( !Size || 0xFFFFFFE0 / Size >= a2 )
  {
    v3 = a2 * Size;
    Sizea = v3;
    if ( !v3 )
      v3 = 1;
    while ( 1 )
    {
      v4 = 0;
      if ( v3 <= 0xFFFFFFE0 )
        break;
LABEL_8:
      if ( v4 )
        return v4;
      if ( !_newmode )
      {
        if ( a3 )
          *(_DWORD *)a3 = 12;
        return v4;
      }
      if ( !_callnewh(v3) )
      {
        if ( a3 )
          *(_DWORD *)a3 = 12;
        return 0;
      }
    }
    if ( __active_heap == 3 )
    {
      v3 = (v3 + 15) & 0xFFFFFFF0;
      if ( Sizea <= __sbh_threshold )
      {
        _lock(4);
        Dst = (void *)__sbh_alloc_block(Sizea);
        _unlock(4);
        v4 = Dst;
        if ( !Dst )
        {
LABEL_7:
          v4 = HeapAlloc(_crtheap, 8u, v3);
          goto LABEL_8;
        }
        memset(Dst, 0, Sizea);
      }
    }
    if ( v4 )
      return v4;
    goto LABEL_7;
  }
  *_errno() = 12;
  _invalid_parameter(0, 0, 0, 0, 0);
  return 0;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7DE50B: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 6F7DEA9D: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 6F7E69C4: using guessed type int __active_heap;
// 6F7E8E24: using guessed type int _newmode;
// 6F7E8E68: using guessed type int __sbh_threshold;

//----- (6F7766D1) --------------------------------------------------------
void *__crtGetEnvironmentStringsA()
{
  signed int v0; // eax@1
  void *v1; // ebx@1
  const WCHAR *v2; // edi@1
  const WCHAR *i; // eax@5
  int v4; // eax@8
  CHAR *v5; // eax@9
  LPCH v7; // eax@24
  CHAR *v8; // esi@24
  void *v9; // eax@28
  void *v10; // edi@28
  int cchWideChar; // [sp+Ch] [bp-Ch]@8
  int cbMultiByte; // [sp+10h] [bp-8h]@8
  int cbMultiBytea; // [sp+10h] [bp-8h]@28
  void *Memory; // [sp+14h] [bp-4h]@9

  v0 = dword_6F7E6908;
  v1 = 0;
  v2 = 0;
  if ( !dword_6F7E6908 )
  {
    v2 = GetEnvironmentStringsW();
    if ( v2 )
    {
      dword_6F7E6908 = 1;
      goto LABEL_4;
    }
    if ( GetLastError() == 120 )
    {
      v0 = 2;
      dword_6F7E6908 = 2;
    }
    else
    {
      v0 = dword_6F7E6908;
    }
  }
  if ( v0 == 1 )
  {
LABEL_4:
    if ( !v2 )
    {
      v2 = GetEnvironmentStringsW();
      if ( !v2 )
        return 0;
    }
    for ( i = v2; *i; ++i )
    {
      do
        ++i;
      while ( *i );
    }
    cchWideChar = i - v2 + 1;
    v4 = WideCharToMultiByte(0, 0, v2, cchWideChar, 0, 0, 0, 0);
    cbMultiByte = v4;
    if ( v4 )
    {
      v5 = (CHAR *)malloc(v4);
      Memory = v5;
      if ( v5 )
      {
        if ( !WideCharToMultiByte(0, 0, v2, cchWideChar, v5, cbMultiByte, 0, 0) )
        {
          free(Memory);
          Memory = 0;
        }
        v1 = Memory;
      }
    }
    FreeEnvironmentStringsW((LPWCH)v2);
    return v1;
  }
  if ( v0 != 2 && v0 )
    return 0;
  v7 = GetEnvironmentStrings();
  v8 = v7;
  if ( !v7 )
    return 0;
  for ( ; *v7; ++v7 )
  {
    do
      ++v7;
    while ( *v7 );
  }
  cbMultiBytea = v7 - v8 + 1;
  v9 = malloc(cbMultiBytea);
  v10 = v9;
  if ( !v9 )
  {
    FreeEnvironmentStringsA(v8);
    return 0;
  }
  memcpy(v9, v8, cbMultiBytea);
  FreeEnvironmentStringsA(v8);
  return v10;
}
// 6F7E6908: using guessed type int dword_6F7E6908;

//----- (6F776791) --------------------------------------------------------
void *__cdecl malloc(size_t Size)
{
  size_t v1; // esi@1
  SIZE_T v2; // eax@5
  LPVOID v3; // eax@6
  void *v4; // ebx@7
  void *result; // eax@8

  v1 = Size;
  if ( Size > 0xFFFFFFE0 )
  {
    _callnewh(Size);
    *_errno() = 12;
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( !_crtheap )
      {
        _FF_MSGBANNER();
        _NMSG_WRITE(30);
        __crtExitProcess(0xFFu);
      }
      if ( __active_heap == 1 )
      {
        v2 = v1 ? v1 : 1;
        v3 = HeapAlloc(_crtheap, 0, v2);
      }
      else if ( __active_heap != 3 || (v3 = (LPVOID)V6_HeapAlloc(v1)) == 0 )
      {
        if ( !v1 )
          v1 = 1;
        v3 = HeapAlloc(_crtheap, 0, (v1 + 15) & 0xFFFFFFF0);
      }
      v4 = v3;
      if ( v3 )
        break;
      if ( !_newmode )
      {
        *_errno() = 12;
LABEL_22:
        *_errno() = 12;
        break;
      }
      if ( !_callnewh(Size) )
        goto LABEL_22;
      v1 = Size;
    }
    result = v4;
  }
  return result;
}
// 6F7DE13B: using guessed type int _FF_MSGBANNER(void);
// 6F7DE50B: using guessed type _DWORD __cdecl _callnewh(_DWORD);
// 6F7DED87: using guessed type _DWORD __cdecl V6_HeapAlloc(_DWORD);
// 6F7E69C4: using guessed type int __active_heap;
// 6F7E8E24: using guessed type int _newmode;

//----- (6F7767F2) --------------------------------------------------------
signed int __cdecl _heap_init(int a1)
{
  _crtheap = HeapCreate(a1 == 0, 0x1000u, 0);
  if ( _crtheap )
  {
    __active_heap = __heap_select();
    if ( __active_heap != 3 || __sbh_heap_init(1016) )
      return 1;
    HeapDestroy(_crtheap);
    _crtheap = 0;
  }
  return 0;
}
// 6F7DE538: using guessed type _DWORD __cdecl __sbh_heap_init(_DWORD);
// 6F7E69C4: using guessed type int __active_heap;

//----- (6F776837) --------------------------------------------------------
signed int __heap_select()
{
  signed int result; // eax@5
  unsigned int v1; // [sp+4h] [bp-8h]@1
  int v2; // [sp+8h] [bp-4h]@1

  v2 = 0;
  v1 = 0;
  if ( _get_osplatform((int)&v2) )
    _invoke_watson(0, 0, 0, 0, 0);
  if ( _get_winmajor((int)&v1) )
    _invoke_watson(0, 0, 0, 0, 0);
  if ( v2 != 2 || v1 < 5 )
    result = 3;
  else
    result = 1;
  return result;
}

//----- (6F776887) --------------------------------------------------------
signed int __cdecl _get_winmajor(int a1)
{
  signed int result; // eax@3

  if ( a1 && _osplatform )
  {
    *(_DWORD *)a1 = _winmajor;
    result = 0;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = 22;
  }
  return result;
}
// 6F7E68F4: using guessed type int _osplatform;

//----- (6F7768B8) --------------------------------------------------------
volatile LONG *__updatetmbcinfo()
{
  int v0; // eax@1
  int v1; // edi@1
  volatile LONG *v2; // esi@4

  v0 = _getptd();
  v1 = v0;
  if ( (*(_BYTE *)(v0 + 112) & 2 || !(__globallocalestatus & 1)) && *(_DWORD *)(v0 + 108) )
  {
    v2 = *(volatile LONG **)(v0 + 104);
  }
  else
  {
    _lock(13);
    v2 = *(volatile LONG **)(v1 + 104);
    if ( v2 != ___ptmbcinfo )
    {
      if ( v2 && !InterlockedDecrement(v2) && v2 != &__initialmbcinfo )
        free((void *)v2);
      *(_DWORD *)(v1 + 104) = ___ptmbcinfo;
      v2 = ___ptmbcinfo;
      InterlockedIncrement(___ptmbcinfo);
    }
    _unlock(13);
  }
  if ( !v2 )
    _amsg_exit(32);
  return v2;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7DC8FE: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);
// 6F7E8460: using guessed type char __globallocalestatus;

//----- (6F776921) --------------------------------------------------------
int _getptd()
{
  int v0; // esi@1

  v0 = _getptd_noexit();
  if ( !v0 )
    _amsg_exit(16);
  return v0;
}
// 6F776400: using guessed type int _getptd_noexit(void);
// 6F7DC8FE: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);

//----- (6F776B41) --------------------------------------------------------
BOOL __stdcall IsSystemProcess()
{
  HANDLE v0; // eax@1
  BOOL IsMember; // [sp+4h] [bp-Ch]@1
  HANDLE TokenHandle; // [sp+8h] [bp-8h]@1
  PSID pSid; // [sp+Ch] [bp-4h]@2

  IsMember = 0;
  v0 = GetCurrentProcess();
  if ( OpenProcessToken(v0, 8u, &TokenHandle) )
  {
    if ( AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0x12u, 0, 0, 0, 0, 0, 0, 0, &pSid) )
    {
      CheckTokenMembership(TokenHandle, pSid, &IsMember);
      FreeSid(pSid);
    }
    CloseHandle(TokenHandle);
  }
  return IsMember;
}

//----- (6F776BD5) --------------------------------------------------------
LONG __stdcall CCDestroyWindow()
{
  return InterlockedDecrement(&g_dwWindowCount);
}

//----- (6F776BE6) --------------------------------------------------------
BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
{
  unsigned int v1; // esi@1
  BOOL v3; // [sp+Ch] [bp-8h]@1
  ULONG_PTR ulCookie; // [sp+10h] [bp-4h]@1

  v1 = 0;
  v3 = 1;
  ulCookie = 0;
  if ( !picce || picce->dwSize != 8 || picce->dwICC & 0x7FFFC000 || !ActivateModuleActCtx(&ulCookie) )
    return 0;
  while ( !(dword_6F7E6030[v1] & picce->dwICC) )
  {
LABEL_6:
    v1 += 4;
    if ( v1 >= 76 )
      goto LABEL_7;
  }
  if ( (*(int (__stdcall **)(int))((char *)&icc + v1 * 4))((int)g_hinst) )
  {
    dword_6F7E6034[v1] = 1;
    goto LABEL_6;
  }
  v3 = 0;
LABEL_7:
  DeactivateActCtx(0, ulCookie);
  return v3;
}
// 6F7E6028: using guessed type int (__stdcall *icc)(int);
// 6F7E6030: using guessed type int dword_6F7E6030[];
// 6F7E6034: using guessed type int dword_6F7E6034[];

//----- (6F776C4D) --------------------------------------------------------
LONG __stdcall CCCreateWindow()
{
  LONG result; // eax@1

  result = InterlockedIncrement(&g_dwWindowCount);
  if ( result == 1 )
  {
    InitGlobalColors();
    result = InitGlobalMetrics(0);
  }
  return result;
}

//----- (6F776C9F) --------------------------------------------------------
BOOL __stdcall ActivateModuleActCtx(ULONG_PTR *lpCookie)
{
  BOOL v1; // edi@1
  HANDLE hActCtx; // [sp+8h] [bp-4h]@1

  v1 = 0;
  hActCtx = 0;
  *lpCookie = 0;
  if ( GetModuleActCtx((int)&hActCtx) )
    v1 = ActivateActCtx(hActCtx, lpCookie);
  return v1;
}

//----- (6F776CD7) --------------------------------------------------------
BOOL __stdcall GetModuleActCtx(int a1)
{
  BOOL result; // eax@1
  int pvBuffer; // [sp+4h] [bp-8h]@1
  int v3; // [sp+8h] [bp-4h]@1

  pvBuffer = 0;
  v3 = 0;
  result = QueryActCtxW(0x80000008, g_hinst, 0, 1u, &pvBuffer, 8u, 0);
  if ( result )
  {
    if ( a1 )
      *(_DWORD *)a1 = pvBuffer;
  }
  return result;
}

//----- (6F776D1F) --------------------------------------------------------
signed int __stdcall InitProgressClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.hIcon = 0;
  WndClass.lpfnWndProc = (WNDPROC)ProgressWndProc;
  WndClass.lpszClassName = L"msctls_progress32";
  WndClass.style = 16387;
  WndClass.hInstance = a1;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F776D80: using guessed type wchar_t s_szPROGRESS_CLASS[18];

//----- (6F776DE8) --------------------------------------------------------
BOOL _heap_term()
{
  BOOL result; // eax@2
  int v1; // ebx@3
  LPVOID *v2; // esi@4

  if ( __active_heap == 3 )
  {
    v1 = 0;
    if ( __sbh_cntHeaderList > 0 )
    {
      v2 = (LPVOID *)((char *)__sbh_pHeaderList + 16);
      do
      {
        VirtualFree(*(v2 - 1), 0, 0x8000u);
        HeapFree(_crtheap, 0, *v2);
        v2 += 5;
        ++v1;
      }
      while ( v1 < __sbh_cntHeaderList );
    }
    HeapFree(_crtheap, 0, __sbh_pHeaderList);
  }
  result = HeapDestroy(_crtheap);
  _crtheap = 0;
  return result;
}
// 6F7E69C4: using guessed type int __active_heap;
// 6F7E8E60: using guessed type int __sbh_cntHeaderList;

//----- (6F776E14) --------------------------------------------------------
void _mtdeletelocks()
{
  signed int v0; // esi@1
  LPCRITICAL_SECTION v1; // edi@2
  signed int v2; // esi@4

  v0 = (signed int)&lpCriticalSection;
  do
  {
    v1 = *(LPCRITICAL_SECTION *)v0;
    if ( *(_DWORD *)v0 && *(_DWORD *)(v0 + 4) != 1 )
    {
      DeleteCriticalSection(*(LPCRITICAL_SECTION *)v0);
      free(v1);
      *(_DWORD *)v0 = 0;
    }
    v0 += 8;
  }
  while ( v0 < (signed int)dword_6F7E7208 );
  v2 = (signed int)&lpCriticalSection;
  do
  {
    if ( *(_DWORD *)v2 )
    {
      if ( *(_DWORD *)(v2 + 4) == 1 )
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v2);
    }
    v2 += 8;
  }
  while ( v2 < (signed int)dword_6F7E7208 );
}
// 6F7E7208: using guessed type int dword_6F7E7208[86];

//----- (6F776E5F) --------------------------------------------------------
void _ioterm()
{
  void **v0; // esi@1
  void *v1; // edi@2
  int i; // eax@5

  v0 = (void **)__pioinfo;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      for ( i = (int)((char *)v1 + 1152); (unsigned int)v1 < i; i = (int)((char *)*v0 + 1152) )
      {
        if ( *((_BYTE *)v1 + 8) & 4 )
          DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 12));
        v1 = (char *)v1 + 36;
      }
      free(*v0);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (signed int)v0 < (signed int)&___ptmbcinfo );
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F776EB6) --------------------------------------------------------
int __stdcall ProgressWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int v4; // eax@1
  unsigned __int32 v5; // edx@1
  int v6; // esi@1
  int result; // eax@9
  WPARAM v8; // eax@30
  int v9; // eax@37
  int v10; // edi@44
  HWND v11; // ST00_4@46
  int v12; // eax@52
  int v13; // esi@53
  int v14; // [sp-4h] [bp-20h]@37
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@27

  v4 = GetWindowLongW(hWnd, 0);
  v5 = lParam;
  v6 = v4;
  if ( Msg <= 0x401 )
  {
    if ( Msg != 1025 )
    {
      if ( Msg <= 0x15 )
      {
        if ( Msg == 21 )
        {
          InitGlobalColors();
          InvalidateRect(hWnd, 0, 1);
          return 0;
        }
        if ( Msg == 1 )
        {
          CCCreateWindow();
          return Progress_OnCreate(hWnd, lParam);
        }
        if ( Msg == 2 )
        {
          CCDestroyWindow();
          if ( v6 )
            LocalFree((HLOCAL)v6);
          return 0;
        }
        if ( Msg != 15 )
        {
          if ( Msg == 20 && v4 && *(_DWORD *)(v4 + 28) != -16777216 )
          {
            GetClientRect(hWnd, &Rect);
            FillRectClr((HDC)wParam, &Rect, *(_DWORD *)(v6 + 28));
            return 1;
          }
          return DefWindowProcW(hWnd, Msg, wParam, lParam);
        }
LABEL_20:
        ProPaint(v4, (HDC)wParam);
        return 0;
      }
      if ( Msg == 48 )
      {
        result = *(_DWORD *)(v4 + 24);
        *(_DWORD *)(v6 + 24) = wParam;
        return result;
      }
      if ( Msg == 49 )
        return *(_DWORD *)(v4 + 24);
      if ( Msg != 61 )
      {
        if ( Msg != 792 )
          return DefWindowProcW(hWnd, Msg, wParam, lParam);
        goto LABEL_20;
      }
      if ( lParam != -12 )
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      return 65549;
    }
    v8 = (unsigned __int16)lParam;
    v5 = (unsigned int)lParam >> 16;
LABEL_44:
    v10 = *(_WORD *)(v6 + 8) | (*(_WORD *)(v6 + 12) << 16);
    if ( v8 != *(_DWORD *)(v6 + 8) || v5 != *(_DWORD *)(v6 + 12) )
    {
      v11 = *(HWND *)v6;
      *(_DWORD *)(v6 + 12) = v5;
      *(_DWORD *)(v6 + 8) = v8;
      RedrawWindow(v11, 0, 0, 5u);
      UpdatePosition(v6, *(_DWORD *)(v6 + 16), 0);
    }
    return v10;
  }
  if ( Msg > 0x406 )
  {
    if ( Msg == 1031 )
    {
      if ( lParam )
      {
        *(_DWORD *)lParam = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(lParam + 4) = *(_DWORD *)(v4 + 12);
      }
      if ( wParam )
        result = *(_DWORD *)(v4 + 8);
      else
        result = *(_DWORD *)(v4 + 12);
    }
    else if ( Msg == 1032 )
    {
      result = *(_DWORD *)(v4 + 16);
    }
    else
    {
      if ( Msg == 1033 )
      {
        v12 = *(_DWORD *)(v4 + 32);
        *(_DWORD *)(v6 + 32) = lParam;
      }
      else
      {
        if ( Msg != 8193 )
          return DefWindowProcW(hWnd, Msg, wParam, lParam);
        v12 = *(_DWORD *)(v4 + 28);
        *(_DWORD *)(v6 + 28) = lParam;
      }
      v13 = v12;
      InvalidateRect(hWnd, 0, 1);
      result = v13;
    }
    return result;
  }
  if ( Msg == 1030 )
  {
    v8 = wParam;
    goto LABEL_44;
  }
  if ( Msg == 1026 )
  {
    result = UpdatePosition(v4, wParam, 0);
  }
  else
  {
    if ( Msg == 1027 )
    {
      v9 = wParam + *(_DWORD *)(v4 + 16);
      v14 = 0;
    }
    else
    {
      if ( Msg == 1028 )
      {
        result = *(_DWORD *)(v4 + 20);
        *(_DWORD *)(v6 + 20) = wParam;
        return result;
      }
      if ( Msg != 1029 )
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      v9 = *(_DWORD *)(v4 + 16) + *(_DWORD *)(v4 + 20);
      v14 = 1;
    }
    result = UpdatePosition(v6, v9, v14);
  }
  return result;
}

//----- (6F776F86) --------------------------------------------------------
int __stdcall Progress_OnCreate(HWND hWnd, int a2)
{
  HLOCAL v2; // eax@1
  HLOCAL v3; // esi@1
  int result; // eax@4

  v2 = LocalAlloc(0x40u, 0x24u);
  v3 = v2;
  if ( v2 )
  {
    SetWindowLongW(hWnd, 0, (LONG)v2);
    *(_DWORD *)v3 = hWnd;
    *((_DWORD *)v3 + 3) = 100;
    *((_DWORD *)v3 + 5) = 10;
    *((_DWORD *)v3 + 1) = *(_DWORD *)(a2 + 32);
    *((_DWORD *)v3 + 7) = -16777216;
    *((_DWORD *)v3 + 8) = -16777216;
    SetWindowLongW(hWnd, -20, *(_DWORD *)(a2 + 44) & 0xFFFFFDFF | 0x20000);
    if ( !(*(_DWORD *)(a2 + 44) & 0x20000) )
      SetWindowPos(hWnd, 0, 0, 0, 0, 0, 0x37u);
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F777011) --------------------------------------------------------
HRESULT ULongLongToULong(ULONGLONG ullOperand, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ullOperand > 0xFFFFFFFF )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ullOperand;
    result = 0;
  }
  return result;
}

//----- (6F77703E) --------------------------------------------------------
HRESULT ULongAdd(ULONG ulAugend, ULONG ulAddend, ULONG *pulResult)
{
  HRESULT result; // eax@2

  if ( ulAugend + ulAddend < ulAugend )
  {
    *pulResult = -1;
    result = -2147024362;
  }
  else
  {
    *pulResult = ulAugend + ulAddend;
    result = 0;
  }
  return result;
}

//----- (6F777063) --------------------------------------------------------
PVOID __stdcall DPA_GetPtr(HDPA hdpa, INT_PTR i)
{
  PVOID result; // eax@4

  if ( hdpa && i >= 0 && i < *(_DWORD *)hdpa )
    result = *(PVOID *)(*((_DWORD *)hdpa + 1) + 4 * i);
  else
    result = 0;
  return result;
}

//----- (6F77708D) --------------------------------------------------------
int __stdcall DPA_InsertPtr(HDPA hdpa, int i, void *p)
{
  int v3; // edi@2
  int v4; // eax@4
  int result; // eax@7

  if ( hdpa )
  {
    v3 = i;
    if ( i < 0 )
      goto LABEL_16;
    if ( i > *(_DWORD *)hdpa )
      v3 = *(_DWORD *)hdpa;
    v4 = *(_DWORD *)hdpa + 1;
    if ( (unsigned int)v4 <= *((_DWORD *)hdpa + 3) || DPA_Grow(hdpa, v4) )
    {
      if ( v3 < *(_DWORD *)hdpa )
        memmove(
          (void *)(*((_DWORD *)hdpa + 1) + 4 * v3 + 4),
          (const void *)(*((_DWORD *)hdpa + 1) + 4 * v3),
          4 * (*(_DWORD *)hdpa - v3));
      *(_DWORD *)(*((_DWORD *)hdpa + 1) + 4 * v3) = p;
      ++*(_DWORD *)hdpa;
      result = v3;
    }
    else
    {
LABEL_16:
      result = -1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7770F1) --------------------------------------------------------
BOOL __stdcall DPA_Destroy(HDPA hdpa)
{
  void *v1; // eax@2
  BOOL result; // eax@3

  if ( hdpa )
  {
    v1 = (void *)*((_DWORD *)hdpa + 1);
    if ( !v1 || (result = HeapFree(*((HANDLE *)hdpa + 2), 0, v1)) != 0 )
      result = HeapFree(*((HANDLE *)hdpa + 2), 0, (LPVOID)hdpa);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F777137) --------------------------------------------------------
BOOL __stdcall DPA_Grow(HDPA pdpa, int cp)
{
  void *v2; // eax@5
  LPVOID v3; // eax@6
  signed int v4; // eax@8

  if ( pdpa && cp >= 0 )
  {
    if ( cp <= *((_DWORD *)pdpa + 3) )
      return 1;
    if ( DXA_RoundUp(cp, *((_DWORD *)pdpa + 4), &cp) )
    {
      v2 = (void *)*((_DWORD *)pdpa + 1);
      v3 = v2 ? ControlReAllocArray(*((HANDLE *)pdpa + 2), v2, cp, 4) : ControlAllocArray(*((HANDLE *)pdpa + 2), cp, 4);
      if ( v3 )
      {
        *((_DWORD *)pdpa + 1) = v3;
        *((_DWORD *)pdpa + 3) = cp;
        v4 = *((_DWORD *)pdpa + 4);
        if ( v4 < 256 )
          *((_DWORD *)pdpa + 4) = 2 * v4;
        return 1;
      }
    }
  }
  return 0;
}

//----- (6F7771AD) --------------------------------------------------------
LPVOID __stdcall ControlAllocArray(HANDLE hHeap, int a2, int a3)
{
  LPVOID v3; // esi@1
  SIZE_T dwBytes; // [sp+4h] [bp-4h]@1

  v3 = 0;
  dwBytes = 0;
  if ( ULongLongToULong((unsigned int)a3 * (unsigned __int64)(unsigned int)a2, &dwBytes) >= 0 )
    v3 = HeapAlloc(hHeap, 8u, dwBytes);
  return v3;
}

//----- (6F7771EA) --------------------------------------------------------
signed int __stdcall DXA_RoundUp(ULONG ulAugend, unsigned int a2, INT *piResult)
{
  unsigned int v3; // esi@1
  signed int v4; // edi@1

  v3 = a2;
  v4 = 0;
  if ( ULongAdd(ulAugend, a2 - 1, &ulAugend) >= 0 && UIntToInt(v3 * (ulAugend / v3), piResult) >= 0 )
    v4 = 1;
  return v4;
}

//----- (6F77722F) --------------------------------------------------------
HRESULT UIntToInt(UINT uOperand, INT *piResult)
{
  HRESULT result; // eax@2

  if ( uOperand > 0x7FFFFFFF )
  {
    *piResult = -1;
    result = -2147024362;
  }
  else
  {
    *piResult = uOperand;
    result = 0;
  }
  return result;
}

//----- (6F777252) --------------------------------------------------------
PVOID __stdcall DPA_DeletePtr(HDPA hdpa, int i)
{
  HDPA v2; // esi@1
  int v3; // eax@3
  int v4; // ecx@4
  void *v5; // edi@4
  UINT v6; // eax@5
  UINT v7; // ecx@5
  PVOID result; // eax@6
  LPVOID v9; // eax@11

  v2 = hdpa;
  if ( hdpa && i >= 0 && (v3 = *(_DWORD *)hdpa, i < *(_DWORD *)hdpa) )
  {
    v4 = *((_DWORD *)hdpa + 1) + 4 * i;
    v5 = *(void **)v4;
    if ( i < v3 - 1 )
      memmove((void *)v4, (const void *)(v4 + 4), 4 * (v3 - i) - 4);
    --*(_DWORD *)v2;
    v6 = *((_DWORD *)v2 + 3);
    v7 = *((_DWORD *)v2 + 4);
    if ( *((_DWORD *)v2 + 3) - *(_DWORD *)v2 > (signed int)v7 )
    {
      hdpa = 0;
      if ( UIntSub(v6, v7, (UINT *)&hdpa) >= 0 )
      {
        v9 = ControlReAllocArray(*((HANDLE *)v2 + 2), *((LPVOID *)v2 + 1), (int)hdpa, 4);
        if ( v9 )
          *((_DWORD *)v2 + 1) = v9;
      }
      *((_DWORD *)v2 + 3) -= *((_DWORD *)v2 + 4);
    }
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7772A9) --------------------------------------------------------
BOOL __stdcall DPA_DeleteAllPtrs(HDPA hdpa)
{
  BOOL result; // eax@3

  if ( hdpa && (!*((_DWORD *)hdpa + 1) || HeapFree(*((HANDLE *)hdpa + 2), 0, *((LPVOID *)hdpa + 1))) )
  {
    *((_DWORD *)hdpa + 1) = 0;
    *((_DWORD *)hdpa + 3) = 0;
    *(_DWORD *)hdpa = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F777509) --------------------------------------------------------
#error "6F777557: positive sp value has been found (funcsize=28)"

//----- (6F7775CF) --------------------------------------------------------
void __stdcall DPA_DestroyCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData)
{
  DPA_EnumCallback(hdpa, pfnCB, pData);
  DPA_Destroy(hdpa);
}

//----- (6F7775F3) --------------------------------------------------------
void __stdcall DPA_EnumCallback(HDPA hdpa, PFNDAENUMCALLBACK pfnCB, void *pData)
{
  int v3; // edi@1

  v3 = 0;
  if ( hdpa && *(_DWORD *)hdpa > 0 )
  {
    do
    {
      if ( !pfnCB(*(void **)(*((_DWORD *)hdpa + 1) + 4 * v3), pData) )
        break;
      ++v3;
    }
    while ( v3 < *(_DWORD *)hdpa );
  }
}

//----- (6F77765B) --------------------------------------------------------
LPVOID __stdcall ControlReAllocArray(HANDLE hHeap, LPVOID lpMem, int a3, int a4)
{
  LPVOID v4; // esi@1
  SIZE_T dwBytes; // [sp+4h] [bp-4h]@1

  v4 = 0;
  dwBytes = 0;
  if ( ULongLongToULong((unsigned int)a4 * (unsigned __int64)(unsigned int)a3, &dwBytes) >= 0 )
    v4 = HeapReAlloc(hHeap, 8u, lpMem, dwBytes);
  return v4;
}

//----- (6F7776CD) --------------------------------------------------------
int __stdcall DPA_Search(HDPA hdpa, void *pFind, int iStart, PFNDACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
  int v6; // edi@1
  int v7; // eax@2
  int v8; // ebx@2
  int v9; // esi@2
  int v10; // edi@2
  int i; // esi@16
  signed int iStarta; // [sp+18h] [bp+10h]@2

  v6 = *(_DWORD *)hdpa;
  if ( options & 1 )
  {
    iStarta = -1;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = v6 - 1;
    if ( v10 < 0 )
    {
LABEL_7:
      if ( options & 6 )
      {
        iStarta = v8;
        if ( v7 <= 0 )
          return v9;
      }
      return iStarta;
    }
    while ( 1 )
    {
      v9 = (v10 + v8) / 2;
      v7 = pfnCompare(pFind, *(void **)(*((_DWORD *)hdpa + 1) + 4 * v9), lParam);
      if ( v7 < 0 )
      {
        v10 = v9 - 1;
      }
      else
      {
        if ( v7 <= 0 )
        {
          while ( v9 > 0 && !pfnCompare(pFind, *(void **)(*((_DWORD *)hdpa + 1) + 4 * v9 - 4), lParam) )
            --v9;
          return v9;
        }
        v8 = v9 + 1;
      }
      if ( v8 > v10 )
        goto LABEL_7;
    }
  }
  for ( i = iStart; ; ++i )
  {
    if ( i >= v6 )
      return -1;
    if ( !pfnCompare(pFind, *(void **)(*((_DWORD *)hdpa + 1) + 4 * i), lParam) )
      break;
  }
  return i;
}

//----- (6F777735) --------------------------------------------------------
void __usercall sub_6F777735(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a2 + 4 * a1 + 28) = *(_DWORD *)(a3 + 4 * a1 + 28);
  sub_6F777748(a1, a2, a3);
}

//----- (6F777748) --------------------------------------------------------
void __usercall sub_6F777748(int a1@<ecx>, int a2@<edi>, int a3@<esi>)
{
  *(_DWORD *)(a2 + 4 * a1 + 24) = *(_DWORD *)(a3 + 4 * a1 + 24);
  *(_DWORD *)(a2 + 4 * a1 + 20) = *(_DWORD *)(a3 + 4 * a1 + 20);
  *(_DWORD *)(a2 + 4 * a1 + 16) = *(_DWORD *)(a3 + 4 * a1 + 16);
  *(_DWORD *)(a2 + 4 * a1 + 12) = *(_DWORD *)(a3 + 4 * a1 + 12);
  *(_DWORD *)(a2 + 4 * a1 + 8) = *(_DWORD *)(a3 + 4 * a1 + 8);
  *(_DWORD *)(a2 + 4 * a1 + 4) = *(_DWORD *)(a3 + 4 * a1 + 4);
  JUMPOUT(loc_6F777783);
}

//----- (6F7777A1) --------------------------------------------------------
int __stdcall HIMAGELIST_QueryInterface(struct _IMAGELIST *a1, const struct _GUID *a2, void **a3)
{
  int result; // eax@3

  *a3 = 0;
  if ( a1
    && CImageListBase::IsValid((CImageListBase *)(a1 != (struct _IMAGELIST *)4 ? (unsigned int)((char *)a1 - 8) : 0)) )
    result = (**(int (__stdcall ***)(_DWORD, _DWORD, _DWORD))a1)(a1, a2, a3);
  else
    result = -2147467261;
  return result;
}

//----- (6F7777E5) --------------------------------------------------------
int __thiscall CImageListBase::IsValid(CImageListBase *this)
{
  signed int v2; // [sp+10h] [bp-1Ch]@1

  v2 = 0;
  if ( !((unsigned __int8)this & 3)
    && InterlockedCompareExchange((volatile LONG *)this + 1, 1280133448, 1280133448) == 1280133448 )
    v2 = 1;
  return v2;
}

//----- (6F777851) --------------------------------------------------------
LONG __stdcall CImageList::Release(int a1)
{
  return CImageList::Release((CImageList *)(a1 - 8));
}

//----- (6F77785D) --------------------------------------------------------
LONG __stdcall CImageList::Release(CImageList *this)
{
  LONG v1; // edi@1

  v1 = InterlockedDecrement((volatile LONG *)this + 5);
  if ( !v1 && this )
    CImageList::`scalar deleting destructor'((void *)this, 1);
  return v1;
}

//----- (6F77790D) --------------------------------------------------------
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3)
{
  return CImageList::QueryInterface((CImageList *)(a1 - 8), a2, a3);
}

//----- (6F777919) --------------------------------------------------------
signed int __stdcall CImageList::QueryInterface(CImageList *this, const struct _GUID *a2, void **a3)
{
  signed int v3; // ebx@2
  CImageList *v4; // eax@4
  char *v5; // esi@4

  if ( a3 )
  {
    *a3 = 0;
    v3 = -2147467262;
    if ( !memcmp(a2, &IID_IUnknown, 0x10u) || !memcmp(a2, &IID_IImageList, 0x10u) )
    {
      v4 = this;
      v5 = (char *)this + 8;
    }
    else if ( !memcmp(a2, &IID_IImageListPriv, 0x10u) )
    {
      v4 = this;
      v5 = (char *)this + 12;
    }
    else
    {
      if ( memcmp(a2, &IID_IPersist, 0x10u) && memcmp(a2, &IID_IPersistStream, 0x10u) )
        return v3;
      v4 = this;
      v5 = (char *)this + 16;
    }
    *a3 = (void *)(v4 != 0 ? (unsigned int)v5 : 0);
    v3 = 0;
    (*(void (__stdcall **)(CImageList *))(*(_DWORD *)v4 + 4))(v4);
    return v3;
  }
  return -2147024809;
}

//----- (6F7779C8) --------------------------------------------------------
void __stdcall CImageList::_DeleteBitmap(HBITMAP ho)
{
  if ( ho )
  {
    if ( g_hbmDst == ho )
      CImageList::SelectDstBitmap(0);
    if ( g_hbmSrc == ho )
      CImageList::SelectSrcBitmap(0);
    DeleteObject(ho);
  }
}
// 6F7E68E0: using guessed type HBITMAP g_hbmSrc;
// 6F7E68E4: using guessed type HBITMAP g_hbmDst;

//----- (6F777A45) --------------------------------------------------------
void __stdcall CImageList::SelectSrcBitmap(HBITMAP h)
{
  HBITMAP v1; // eax@5

  if ( h != g_hbmSrc )
  {
    if ( h )
    {
      if ( h == g_hbmDst )
        CImageList::SelectDstBitmap(0);
      v1 = h;
    }
    else
    {
      v1 = (HBITMAP)g_hbmDcDeselect;
    }
    SelectObject(g_hdcSrc, v1);
    g_hbmSrc = h;
  }
}
// 6F7E68E0: using guessed type HBITMAP g_hbmSrc;
// 6F7E68E4: using guessed type HBITMAP g_hbmDst;

//----- (6F777A64) --------------------------------------------------------
void __stdcall CImageList::SelectDstBitmap(HBITMAP h)
{
  HBITMAP v1; // eax@4

  if ( h != g_hbmDst )
  {
    if ( h )
    {
      if ( h == g_hbmSrc )
        CImageList::SelectSrcBitmap(0);
      v1 = h;
    }
    else
    {
      v1 = (HBITMAP)g_hbmDcDeselect;
    }
    SelectObject(g_hdcDst, v1);
    g_hbmDst = h;
  }
}
// 6F7E68E0: using guessed type HBITMAP g_hbmSrc;
// 6F7E68E4: using guessed type HBITMAP g_hbmDst;

//----- (6F777AA8) --------------------------------------------------------
signed int __stdcall CImageList::GetImageRect(CImageList *this, int a2, LPRECT lprc)
{
  signed int result; // eax@4

  if ( lprc && a2 >= 0 && a2 < *((_DWORD *)this + 7) )
  {
    SetRect(
      lprc,
      a2 % *((_DWORD *)this + 12) * *((_DWORD *)this + 10),
      a2 / *((_DWORD *)this + 12) * *((_DWORD *)this + 11),
      a2 % *((_DWORD *)this + 12) * *((_DWORD *)this + 10) + *((_DWORD *)this + 10),
      a2 / *((_DWORD *)this + 12) * *((_DWORD *)this + 11) + *((_DWORD *)this + 11));
    result = 0;
  }
  else
  {
    result = -2147467259;
  }
  return result;
}

//----- (6F777AFF) --------------------------------------------------------
int __stdcall CImageList::Draw(HDC hdc, HDC hdcSrc)
{
  HDC v2; // esi@1
  int v3; // eax@2
  HDC v4; // ebx@3
  int v5; // eax@5
  bool v6; // zf@5
  HDC v7; // edx@11
  int v8; // eax@12
  unsigned int v9; // eax@19
  COLORREF v11; // eax@26
  HDC v12; // ST20_4@26
  int v13; // eax@27
  DWORD v14; // eax@33
  DWORD v15; // eax@39
  HDC v16; // eax@51
  COLORREF v17; // ecx@51
  HDC v18; // ST18_4@69
  int v19; // ST14_4@69
  int v20; // ST10_4@69
  HBRUSH v21; // eax@70
  HGDIOBJ v22; // eax@70
  int v23; // eax@72
  int v24; // ST20_4@73
  int v25; // eax@73
  int v26; // edx@73
  int v27; // eax@73
  int v28; // eax@73
  bool v29; // sf@73
  struct HDC__ v30; // [sp+8h] [bp-80h]@1
  char Dst; // [sp+Ch] [bp-7Ch]@1
  int x; // [sp+4Ch] [bp-3Ch]@56
  int y; // [sp+50h] [bp-38h]@57
  int v34; // [sp+5Ch] [bp-2Ch]@5
  int v35; // [sp+60h] [bp-28h]@5
  int v36; // [sp+64h] [bp-24h]@8
  int v37; // [sp+68h] [bp-20h]@10
  COLORREF color; // [sp+6Ch] [bp-1Ch]@26
  COLORREF v39; // [sp+70h] [bp-18h]@26
  int v40; // [sp+74h] [bp-14h]@12
  int v41; // [sp+78h] [bp-10h]@11
  int v42; // [sp+7Ch] [bp-Ch]@11
  int x1; // [sp+80h] [bp-8h]@11
  int y1; // [sp+84h] [bp-4h]@11
  HDC hdca; // [sp+90h] [bp+8h]@11
  COLORREF hdcb; // [sp+90h] [bp+8h]@41
  HDC hdcc; // [sp+90h] [bp+8h]@72
  HDC hdcSrca; // [sp+94h] [bp+Ch]@11

  v30.unused = 0;
  memset(&Dst, 0, 0x40u);
  v2 = hdcSrc;
  if ( *(_DWORD *)hdcSrc != 68 )
  {
    if ( *(_DWORD *)hdcSrc != 56 )
      return -2147024809;
    qmemcpy(&v30, hdcSrc, 0x38u);
    v30.unused = 68;
    v2 = &v30;
  }
  v3 = *((_DWORD *)v2 + 2);
  if ( v3 < 0 )
    return -2147024809;
  v4 = hdc;
  if ( v3 >= *((_DWORD *)hdc + 7) )
    return -2147024809;
  if ( *((_DWORD *)hdc + 111) && GetLayout(*((HDC *)v2 + 3)) & 1 )
    return (*(int (__stdcall **)(int, HDC))(*(_DWORD *)(*((_DWORD *)hdc + 111) + 8) + 32))(
             *((_DWORD *)hdc + 111) + 8,
             v2);
  EnterCriticalSection(&g_csDll);
  (*(void (__stdcall **)(HDC, _DWORD, int *))(*(_DWORD *)hdc + 60))(hdc, *((_DWORD *)v2 + 2), &v34);
  v5 = *((_DWORD *)v2 + 8) + v34;
  v35 += *((_DWORD *)v2 + 9);
  v6 = *((_DWORD *)v2 + 10) == -16777216;
  v34 = v5;
  if ( v6 )
    *((_DWORD *)v2 + 10) = *((_DWORD *)hdc + 15);
  if ( *((_DWORD *)v2 + 10) == -1 )
    *((_DWORD *)v2 + 12) |= 1u;
  if ( !*((_DWORD *)v2 + 6) )
    *((_DWORD *)v2 + 6) = v36 - v5;
  if ( !*((_DWORD *)v2 + 7) )
    *((_DWORD *)v2 + 7) = v37 - v35;
  do
  {
    v6 = (*((_BYTE *)v2 + 48) & 0xE) == 0;
    v7 = (HDC)*((_DWORD *)v4 + 19);
    hdca = (HDC)*((_DWORD *)v4 + 20);
    v41 = v34;
    v42 = v35;
    hdcSrca = v7;
    x1 = v34;
    y1 = v35;
    if ( !v6 )
    {
      v16 = ImageList_GetWorkDC(*((HDC *)v2 + 3), *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7));
      v17 = *((_DWORD *)v2 + 11);
      hdcSrca = v16;
      x1 = 0;
      y1 = 0;
      if ( v17 == -1 && hdca )
      {
        if ( (*((_DWORD *)v4 + 13) & 0xFE) != 16 || *((_BYTE *)v2 + 48) & 0x10 )
        {
          if ( CImageList::GetSpareImageRect((CImageList *)(v4 - 2), (struct tagRECT *)&x) )
          {
            v41 = x;
            v42 = y;
          }
          BitBlt(hdcSrca, 0, 0, *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7), *((HDC *)v4 + 19), v34, v35, 0xCC0020u);
          v39 = (COLORREF)SelectObject(hdca, g_hbrMonoDither);
          BitBlt(hdca, x, y, *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7), *((HDC *)v4 + 20), v34, v35, 0xFC008Au);
          SelectObject(hdca, (HGDIOBJ)v39);
        }
        else
        {
          BitBlt(
            v16,
            0,
            0,
            *((_DWORD *)v2 + 6),
            *((_DWORD *)v2 + 7),
            *((HDC *)v2 + 3),
            *((_DWORD *)v2 + 4),
            *((_DWORD *)v2 + 5),
            0xCC0020u);
          ImageList_Blend16(
            hdcSrca,
            0,
            0,
            (struct CImageList *)(v4 - 2),
            v34,
            v35,
            *((_DWORD *)v2 + 6),
            *((_DWORD *)v2 + 7),
            *((_DWORD *)v2 + 11),
            *((_DWORD *)v2 + 12));
        }
        *((_DWORD *)v2 + 12) |= 1u;
      }
      else
      {
        ImageList_Blend(
          v16,
          0,
          0,
          (struct CImageList *)(v4 - 2),
          v34,
          v35,
          *((_DWORD *)v2 + 6),
          *((_DWORD *)v2 + 7),
          v17,
          *((_DWORD *)v2 + 12));
      }
    }
    v40 = hdcSrca == *((HDC *)v4 + 19);
    v8 = *((_DWORD *)v2 + 12);
    if ( v8 & 0x10 && hdca )
    {
      if ( v8 & 0x40 )
        v15 = *((_DWORD *)v2 + 13);
      else
        v15 = (*((_DWORD *)v2 + 12) & 1) != 0 ? 8913094 : 13369376;
      BitBlt(
        *((HDC *)v2 + 3),
        *((_DWORD *)v2 + 4),
        *((_DWORD *)v2 + 5),
        *((_DWORD *)v2 + 6),
        *((_DWORD *)v2 + 7),
        hdca,
        v41,
        v42,
        v15);
    }
    else if ( v8 & 0x20 )
    {
      hdcb = GetBkColor(hdcSrca);
      if ( *((_DWORD *)v2 + 10) != -16777216 )
        SetBkColor(hdcSrca, *((_DWORD *)v2 + 10));
      if ( *((_BYTE *)v2 + 48) & 0x40 )
        v14 = *((_DWORD *)v2 + 13);
      else
        v14 = 13369376;
      BitBlt(
        *((HDC *)v2 + 3),
        *((_DWORD *)v2 + 4),
        *((_DWORD *)v2 + 5),
        *((_DWORD *)v2 + 6),
        *((_DWORD *)v2 + 7),
        hdcSrca,
        x1,
        y1,
        v14);
      SetBkColor(hdcSrca, hdcb);
    }
    else
    {
      if ( v8 & 1 && hdca )
      {
        v11 = SetTextColor(*((HDC *)v2 + 3), 0);
        v12 = (HDC)*((_DWORD *)v2 + 3);
        v39 = v11;
        color = SetBkColor(v12, 0xFFFFFFu);
        if ( v40 )
        {
          v13 = *((_DWORD *)v4 + 15);
          if ( v13 == 0xFFFFFF )
          {
            BitBlt(
              *((HDC *)v2 + 3),
              *((_DWORD *)v2 + 4),
              *((_DWORD *)v2 + 5),
              *((_DWORD *)v2 + 6),
              *((_DWORD *)v2 + 7),
              hdca,
              v41,
              v42,
              0xBB0226u);
            BitBlt(
              *((HDC *)v2 + 3),
              *((_DWORD *)v2 + 4),
              *((_DWORD *)v2 + 5),
              *((_DWORD *)v2 + 6),
              *((_DWORD *)v2 + 7),
              hdcSrca,
              x1,
              y1,
              0x8800C6u);
            goto LABEL_31;
          }
          if ( !v13 || v13 == -1 )
          {
            BitBlt(
              *((HDC *)v2 + 3),
              *((_DWORD *)v2 + 4),
              *((_DWORD *)v2 + 5),
              *((_DWORD *)v2 + 6),
              *((_DWORD *)v2 + 7),
              hdca,
              v41,
              v42,
              0x8800C6u);
            BitBlt(
              *((HDC *)v2 + 3),
              *((_DWORD *)v2 + 4),
              *((_DWORD *)v2 + 5),
              *((_DWORD *)v2 + 6),
              *((_DWORD *)v2 + 7),
              hdcSrca,
              x1,
              y1,
              0xEE0086u);
LABEL_31:
            SetTextColor(*((HDC *)v2 + 3), v39);
            SetBkColor(*((HDC *)v2 + 3), color);
            goto LABEL_19;
          }
        }
        BitBlt(hdcSrca, x1, y1, *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7), hdca, v41, v42, 0x220326u);
        BitBlt(
          *((HDC *)v2 + 3),
          *((_DWORD *)v2 + 4),
          *((_DWORD *)v2 + 5),
          *((_DWORD *)v2 + 6),
          *((_DWORD *)v2 + 7),
          hdca,
          v41,
          v42,
          0x8800C6u);
        BitBlt(
          *((HDC *)v2 + 3),
          *((_DWORD *)v2 + 4),
          *((_DWORD *)v2 + 5),
          *((_DWORD *)v2 + 6),
          *((_DWORD *)v2 + 7),
          hdcSrca,
          x1,
          y1,
          0xEE0086u);
        if ( v40 )
          CImageList::_ResetBkColor(
            (CImageList *)(v4 - 2),
            *((_DWORD *)v2 + 2),
            *((_DWORD *)v2 + 2),
            *((_DWORD *)v4 + 15));
        goto LABEL_31;
      }
      if ( v40 && *((_DWORD *)v2 + 10) == *((_DWORD *)v4 + 15) && *((_DWORD *)v4 + 5) || !hdca )
      {
        BitBlt(
          *((HDC *)v2 + 3),
          *((_DWORD *)v2 + 4),
          *((_DWORD *)v2 + 5),
          *((_DWORD *)v2 + 6),
          *((_DWORD *)v2 + 7),
          hdcSrca,
          x1,
          y1,
          0xCC0020u);
      }
      else
      {
        if ( v40
          && (*((_DWORD *)v2 + 10) == *((_DWORD *)v4 + 15) && !*((_DWORD *)v4 + 5)
           || GetNearestColor32(hdcSrca, *((_DWORD *)v2 + 10)) != *((_DWORD *)v2 + 10)) )
        {
          hdcSrca = ImageList_GetWorkDC(*((HDC *)v2 + 3), *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7));
          v18 = (HDC)*((_DWORD *)v4 + 19);
          x1 = 0;
          v19 = *((_DWORD *)v2 + 7);
          y1 = 0;
          v20 = *((_DWORD *)v2 + 6);
          v40 = 0;
          BitBlt(hdcSrca, 0, 0, v20, v19, v18, v34, v35, 0xCC0020u);
        }
        SetBrushOrgEx(hdcSrca, x1 - *((_DWORD *)v2 + 4), y1 - *((_DWORD *)v2 + 5), 0);
        v21 = CreateSolidBrush(*((_DWORD *)v2 + 10));
        v39 = (COLORREF)SelectObject(hdcSrca, v21);
        BitBlt(hdcSrca, x1, y1, *((_DWORD *)v2 + 6), *((_DWORD *)v2 + 7), hdca, v41, v42, 0xE20746u);
        v22 = SelectObject(hdcSrca, (HGDIOBJ)v39);
        DeleteObject(v22);
        SetBrushOrgEx(hdcSrca, 0, 0, 0);
        BitBlt(
          *((HDC *)v2 + 3),
          *((_DWORD *)v2 + 4),
          *((_DWORD *)v2 + 5),
          *((_DWORD *)v2 + 6),
          *((_DWORD *)v2 + 7),
          hdcSrca,
          x1,
          y1,
          0xCC0020u);
        if ( v40 )
          CImageList::_ResetBkColor(
            (CImageList *)(v4 - 2),
            *((_DWORD *)v2 + 2),
            *((_DWORD *)v2 + 2),
            *((_DWORD *)v4 + 15));
      }
    }
LABEL_19:
    v9 = *((_DWORD *)v2 + 12);
    if ( !(v9 & 0xF00) )
      break;
    v23 = ((v9 >> 8) & 0xF) - 1;
    hdcc = (HDC)v23;
    if ( v23 >= 15 )
      break;
    v24 = *((_DWORD *)v4 + v23 + 21);
    *((_DWORD *)v2 + 2) = v24;
    (*(void (__stdcall **)(HDC, int, int *))(*(_DWORD *)v4 + 60))(v4, v24, &v34);
    *((_DWORD *)v2 + 6) = *((_DWORD *)v4 + (_DWORD)hdcc + 66);
    *((_DWORD *)v2 + 7) = *((_DWORD *)v4 + (_DWORD)hdcc + 81);
    v25 = (int)(v4 + (_DWORD)hdcc + 36);
    *((_DWORD *)v2 + 4) += *(_DWORD *)v25;
    *((_DWORD *)v2 + 5) += *((_DWORD *)v4 + (_DWORD)hdcc + 51);
    v26 = *(_DWORD *)v25 + *((_DWORD *)v2 + 8);
    v27 = *((_DWORD *)v4 + (_DWORD)hdcc + 51) + *((_DWORD *)v2 + 9);
    v34 += v26;
    v35 += v27;
    v28 = *((_DWORD *)v2 + 12) & 0x10 | 1;
    *((_DWORD *)v2 + 12) = v28;
    v6 = *((_DWORD *)v2 + 6) == 0;
    v29 = *((_DWORD *)v2 + 6) < 0;
    *((_DWORD *)v2 + 12) = v28 | *((_DWORD *)v4 + (_DWORD)hdcc + 96);
    if ( v29 || v6 )
      break;
  }
  while ( *((_DWORD *)v2 + 7) > 0 );
  if ( !v40 )
    ImageList_ReleaseWorkDC(hdcSrca);
  LeaveCriticalSection(&g_csDll);
  return 0;
}

//----- (6F777C77) --------------------------------------------------------
HBITMAP __stdcall CreateMonoBitmap(int nWidth, int nHeight)
{
  return CreateBitmap(nWidth, nHeight, 1u, 1u, 0);
}

//----- (6F777C97) --------------------------------------------------------
void __stdcall InitDitherBrush()
{
  HBITMAP v0; // eax@3
  void *v1; // esi@3

  if ( dword_6F7E68E8 )
  {
    ++dword_6F7E68E8;
  }
  else
  {
    v0 = CreateBitmap(8, 8, 1u, 1u, sub_6F777CDC);
    v1 = v0;
    if ( v0 )
    {
      g_hbrMonoDither = CreatePatternBrush(v0);
      DeleteObject(v1);
      ++dword_6F7E68E8;
    }
  }
}
// 6F7E68E8: using guessed type int dword_6F7E68E8;

//----- (6F777CDC) --------------------------------------------------------
BOOL __usercall sub_6F777CDC@<eax>(char a1@<al>, int a2@<edi>, struct _IMAGELIST *a3)
{
  int v3; // edi@1

  *(_BYTE *)a2 = a1;
  v3 = a2 + 1;
  *(_BYTE *)v3++ = a1;
  *(_BYTE *)v3++ = a1;
  *(_BYTE *)v3++ = a1;
  *(_BYTE *)v3++ = a1;
  *(_BYTE *)v3++ = a1;
  *(_BYTE *)v3 = a1;
  *(_BYTE *)(v3 + 1) = a1;
  return ImageList_Destroy(a3);
}

//----- (6F777CF1) --------------------------------------------------------
BOOL __stdcall ImageList_Destroy(HIMAGELIST himl)
{
  BOOL v1; // esi@1

  v1 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)himl + 8))(himl);
    v1 = 1;
  }
  return v1;
}

//----- (6F777D2D) --------------------------------------------------------
void __thiscall CImageList::~CImageList(CImageList *this)
{
  CImageList *v1; // esi@1
  int v2; // eax@1

  v1 = this;
  v2 = *((_DWORD *)this + 113);
  *(_DWORD *)this = &CImageList::`vftable';
  *((_DWORD *)this + 2) = &CImageList::`vftable';
  *((_DWORD *)this + 3) = &CImageList::`vftable';
  *((_DWORD *)this + 4) = &CImageList::`vftable';
  if ( v2 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
  CImageList::_Destroy(v1);
  *((_DWORD *)v1 + 1) = 0;
}
// 6F777888: using guessed type int (__cdecl *CImageList::`vftable')(int);
// 6F77799C: using guessed type __int32 (__stdcall *CImageList::`vftable')(CImageList *this, const struct _GUID *, void **);
// 6F7779FC: using guessed type int (__stdcall *CImageList::`vftable')(int, int, int);
// 6F777A1C: using guessed type int (__stdcall *CImageList::`vftable')(int, int, int);

//----- (6F777E13) --------------------------------------------------------
void *__thiscall CImageList::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CImageList::~CImageList((CImageList *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6F777E39) --------------------------------------------------------
void __cdecl operator delete(void *lpMem)
{
  HANDLE v1; // eax@2

  if ( lpMem )
  {
    v1 = GetProcessHeap();
    HeapFree(v1, 0, lpMem);
  }
}

//----- (6F777E5D) --------------------------------------------------------
BOOL __stdcall TerminateDitherBrush()
{
  BOOL result; // eax@3

  --dword_6F7E68E8;
  if ( !dword_6F7E68E8 )
  {
    result = DeleteObject(g_hbrMonoDither);
    g_hbrMonoDither = 0;
  }
  return result;
}
// 6F7E68E8: using guessed type int dword_6F7E68E8;

//----- (6F777E8A) --------------------------------------------------------
void __stdcall CImageList::GlobalUninit()
{
  TerminateDitherBrush();
  if ( g_hbrStripe )
  {
    DeleteObject(g_hbrStripe);
    g_hbrStripe = 0;
  }
  ImageList_DeleteDragBitmaps();
  if ( g_hdcDst )
  {
    CImageList::SelectDstBitmap(0);
    DeleteDC(g_hdcDst);
    g_hdcDst = 0;
  }
  if ( g_hdcSrc )
  {
    CImageList::SelectSrcBitmap(0);
    DeleteDC(g_hdcSrc);
    g_hdcSrc = 0;
  }
  if ( g_hbmWork )
  {
    DeleteObject(g_hbmWork);
    g_hbmWork = 0;
  }
}

//----- (6F777F07) --------------------------------------------------------
void __stdcall ImageList_DeleteDragBitmaps()
{
  if ( h )
  {
    CImageList::_DeleteBitmap(h);
    h = 0;
  }
  if ( dword_6F7E69D8 )
  {
    CImageList::_DeleteBitmap(dword_6F7E69D8);
    dword_6F7E69D8 = 0;
  }
  dword_6F7E69E0 = -1;
  cy = -1;
}

//----- (6F777F5A) --------------------------------------------------------
BOOL __stdcall TB_OnDestroy(HLOCAL hMem)
{
  int v1; // esi@1
  bool v2; // zf@1
  bool v3; // sf@1
  int v4; // edi@2
  int v5; // eax@3
  int v6; // eax@16
  HWND hWnd; // [sp+Ch] [bp-4h]@1
  HLOCAL hMema; // [sp+18h] [bp+8h]@1

  v1 = (int)hMem;
  v2 = *((_DWORD *)hMem + 33) == 0;
  v3 = *((_DWORD *)hMem + 33) < 0;
  hWnd = *(HWND *)hMem;
  hMema = 0;
  if ( !v3 && !v2 )
  {
    v4 = 0;
    do
    {
      v5 = *(_DWORD *)(v1 + 48) + v4 + 16;
      if ( *(_DWORD *)v5 != -1 && *(_DWORD *)v5 & 0xFFFF0000 )
        Str_Set(v5, 0);
      hMema = (char *)hMema + 1;
      v4 += 28;
    }
    while ( (signed int)hMema < *(_DWORD *)(v1 + 132) );
  }
  if ( *(_DWORD *)(v1 + 8) & 0x100 && IsWindow(*(HWND *)(v1 + 64)) )
  {
    DestroyWindow(*(HWND *)(v1 + 64));
    *(_DWORD *)(v1 + 64) = 0;
  }
  if ( *(_DWORD *)(v1 + 172) )
    DestroyDragProxy(*(CDragProxy **)(v1 + 172));
  if ( *(_DWORD *)(v1 + 44) )
    DeleteObject(*(HGDIOBJ *)(v1 + 44));
  ReleaseMonoDC(v1);
  if ( *(_DWORD *)(v1 + 92) > 0 )
    DestroyStrings(v1);
  if ( *(_DWORD *)(v1 + 76) && *(_BYTE *)(v1 + 236) & 4 )
    DeleteObject(*(HGDIOBJ *)(v1 + 76));
  if ( *(_DWORD *)(v1 + 84) )
  {
    v6 = TBGetImageList(v1, 0, 0);
    ImageList_Destroy((HIMAGELIST)v6);
  }
  if ( *(_DWORD *)(v1 + 84) )
    LocalFree(*(HLOCAL *)(v1 + 84));
  CCLocalReAlloc(*(HLOCAL *)(v1 + 196), 0);
  Str_Set(v1 + 68, 0);
  if ( *(_DWORD *)(v1 + 48) )
    LocalFree(*(HLOCAL *)(v1 + 48));
  LocalFree((HLOCAL)v1);
  SetWindowLongW(hWnd, 0, 0);
  return TerminateDitherBrush();
}

//----- (6F778056) --------------------------------------------------------
HLOCAL __stdcall DestroyStrings(int a1)
{
  HLOCAL v1; // ebx@1
  int v2; // edi@1
  bool v3; // zf@1
  bool v4; // sf@1
  HLOCAL *v5; // esi@1
  HLOCAL v6; // eax@2
  SIZE_T v8; // [sp+Ch] [bp-4h]@1
  int v9; // [sp+18h] [bp+8h]@1

  v1 = 0;
  v2 = a1;
  v3 = *(_DWORD *)(a1 + 92) == 0;
  v4 = *(_DWORD *)(a1 + 92) < 0;
  v5 = *(HLOCAL **)(a1 + 88);
  v8 = 0;
  v9 = 0;
  if ( !v4 && !v3 )
  {
    do
    {
      v6 = *v5;
      if ( (unsigned int)*v5 >= v8 || v6 <= v1 )
      {
        v1 = *v5;
        v8 = (SIZE_T)((char *)v6 + 2 * (LocalSize(*v5) >> 1));
        LocalFree(*v5);
      }
      ++v5;
      ++v9;
    }
    while ( v9 < *(_DWORD *)(v2 + 92) );
  }
  return LocalFree(*(HLOCAL *)(v2 + 88));
}

//----- (6F7780BB) --------------------------------------------------------
#error "6F77A9FE: switch analysis failed (funcsize=1666)"

//----- (6F778197) --------------------------------------------------------
COLORREF __stdcall FillRectClr(HDC hdc, RECT *lprect, COLORREF color)
{
  COLORREF v3; // edi@1

  v3 = SetBkColor(hdc, color);
  ExtTextOutW(hdc, 0, 0, 2u, lprect, 0, 0, 0);
  return SetBkColor(hdc, v3);
}

//----- (6F7781D4) --------------------------------------------------------
int __stdcall MyNotifyWinEvent(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  HMODULE v5; // eax@4

  result = dword_6F7E68C4;
  if ( !dword_6F7E68C4 )
  {
    v5 = GetModuleHandleW(L"USER32");
    if ( v5 )
      dword_6F7E68C4 = (int)GetProcAddress(v5, "NotifyWinEvent");
    result = dword_6F7E68C4;
    if ( !dword_6F7E68C4 )
      result = dword_6F7E68C4++ + 1;
  }
  if ( result != 1 )
    result = ((int (__stdcall *)(int, int, int, int))result)(a1, a2, a3, a4);
  return result;
}
// 6F7E68C4: using guessed type int dword_6F7E68C4;

//----- (6F7781FB) --------------------------------------------------------
BOOL __stdcall ReleaseMonoDC(int a1)
{
  BOOL result; // eax@1

  result = *(_DWORD *)(a1 + 40);
  if ( result )
  {
    SelectObject((HDC)result, g_hfontSystem);
    result = DeleteDC(*(HDC *)(a1 + 40));
    *(_DWORD *)(a1 + 40) = 0;
  }
  return result;
}

//----- (6F77831A) --------------------------------------------------------
int __stdcall TBGetImageList(int a1, int a2, int a3)
{
  int result; // eax@1

  result = 0;
  if ( a3 >= 0 && a3 < *(_DWORD *)(a1 + 200) )
    result = *(_DWORD *)(*(_DWORD *)(a1 + 196) + 4 * (a2 + 3 * a3));
  return result;
}

//----- (6F77834B) --------------------------------------------------------
HLOCAL __stdcall CCLocalReAlloc(HLOCAL hMem, SIZE_T uBytes)
{
  HLOCAL result; // eax@3

  if ( uBytes )
  {
    if ( hMem )
      result = LocalReAlloc(hMem, uBytes, 0x42u);
    else
      result = LocalAlloc(0x40u, uBytes);
  }
  else
  {
    if ( hMem )
      LocalFree(hMem);
    result = 0;
  }
  return result;
}

//----- (6F7783DB) --------------------------------------------------------
wchar_t *__stdcall Str_Set(int a1, LPCWSTR lpString)
{
  wchar_t *result; // eax@4
  HLOCAL v3; // esi@7
  int v4; // eax@7
  size_t v5; // ebx@7
  wchar_t *v6; // esi@8

  if ( !lpString || lpString == (LPCWSTR)-1 )
  {
    if ( *(_DWORD *)a1 )
    {
      if ( *(_DWORD *)a1 != -1 )
        LocalFree(*(HLOCAL *)a1);
    }
    *(_DWORD *)a1 = lpString;
    goto LABEL_4;
  }
  v3 = *(HLOCAL *)a1;
  v4 = lstrlenW(lpString);
  v5 = 2 * v4 + 2;
  if ( v3 == (HLOCAL)-1 )
    v3 = 0;
  result = (wchar_t *)CCLocalReAlloc(v3, 2 * v4 + 2);
  v6 = result;
  if ( result )
  {
    StringCbCopyW(result, v5, lpString);
    *(_DWORD *)a1 = v6;
LABEL_4:
    result = (wchar_t *)1;
  }
  return result;
}

//----- (6F77840C) --------------------------------------------------------
HWND __stdcall CCSendNotify(int a1, int a2, LPARAM lParam)
{
  int v3; // ebx@1
  int v4; // esi@1
  HWND v5; // eax@1
  HWND v6; // eax@3
  HWND v7; // edi@5
  int v8; // edi@9
  WCHAR *v10; // edi@25
  HLOCAL v11; // eax@51
  int v12; // eax@52
  bool v13; // zf@55
  int v14; // eax@58
  SIZE_T v15; // ST1C_4@59
  HLOCAL v16; // eax@59
  HLOCAL v17; // eax@61
  const WCHAR *v18; // ST1C_4@63
  int v19; // eax@65
  SIZE_T v20; // eax@66
  HLOCAL v21; // eax@66
  HLOCAL v22; // eax@70
  int v23; // eax@80
  SIZE_T v24; // ST1C_4@81
  int v25; // esi@88
  UINT v26; // ST18_4@93
  SIZE_T v27; // eax@94
  int v28; // eax@100
  UINT v29; // ST18_4@102
  UINT v30; // ST18_4@107
  int v31; // eax@118
  int v32; // eax@136
  int v33; // esi@138
  int v34; // ecx@138
  UINT v35; // ST18_4@138
  int v36; // eax@155
  const WCHAR *v37; // ST1C_4@155
  UINT v38; // ST18_4@155
  int v39; // eax@160
  int v40; // ebx@176
  const CHAR *v41; // eax@185
  int v42; // ebx@196
  LPCSTR *v43; // edi@203
  int v44; // ebx@205
  HLOCAL v45; // ebx@207
  int v46; // ebx@215
  int v47; // ecx@218
  unsigned int v48; // eax@241
  DWORD v49; // [sp-1Ch] [bp-9Ch]@53
  const WCHAR *v50; // [sp-18h] [bp-98h]@53
  int v51; // [sp-10h] [bp-90h]@52
  int v52; // [sp-Ch] [bp-8Ch]@52
  int v53; // [sp-Ch] [bp-8Ch]@67
  unsigned int v54; // [sp-4h] [bp-84h]@34
  char v55; // [sp+Ch] [bp-74h]@35
  DWORD dwProcessId; // [sp+18h] [bp-68h]@10
  int v57; // [sp+1Ch] [bp-64h]@15
  WPARAM wParam; // [sp+20h] [bp-60h]@4
  HWND hWnd; // [sp+24h] [bp-5Ch]@1
  int v60; // [sp+28h] [bp-58h]@1
  int v61; // [sp+2Ch] [bp-54h]@1
  LPWSTR lpWideCharStr; // [sp+30h] [bp-50h]@1
  HLOCAL hMem; // [sp+34h] [bp-4Ch]@1
  int cchWideChar; // [sp+38h] [bp-48h]@1
  char pszDest; // [sp+3Ch] [bp-44h]@163

  lpWideCharStr = 0;
  v61 = 0;
  v3 = lParam;
  v4 = a1;
  hMem = 0;
  cchWideChar = 0;
  v5 = *(HWND *)(a1 + 4);
  v60 = a1;
  hWnd = v5;
  if ( v5 == HWND_MESSAGE|0x2 )
    hWnd = GetParent(*(HWND *)a1);
  if ( !hWnd )
    return 0;
  v6 = *(HWND *)a1;
  if ( *(_DWORD *)a1 == -1 )
  {
    wParam = *(_DWORD *)(lParam + 4);
    a2 = *(_DWORD *)(lParam + 8);
    v8 = *(_DWORD *)(lParam + 8);
  }
  else
  {
    wParam = 0;
    if ( v6 )
    {
      v7 = GetParent(v6);
      if ( v7 )
      {
        if ( v7 != GetWindow(*(HWND *)a1, 4u) )
          wParam = GetDlgCtrlID(*(HWND *)a1);
      }
    }
    if ( !lParam )
      v3 = (int)&v55;
    v8 = a2;
    *(_DWORD *)v3 = *(_DWORD *)a1;
    *(_DWORD *)(v3 + 4) = wParam;
    *(_DWORD *)(v3 + 8) = a2;
  }
  if ( !GetWindowThreadProcessId(hWnd, &dwProcessId) || dwProcessId != GetCurrentProcessId() )
    return 0;
  if ( *(_BYTE *)(a1 + 16) & 1 )
    return (HWND)SendMessageW(hWnd, 0x4Eu, wParam, v3);
  v57 = 1;
  if ( v8 > -451 )
  {
    if ( v8 <= -321 )
    {
      if ( v8 == -321 )
      {
        *(_DWORD *)(v3 + 8) = -301;
      }
      else if ( v8 > -327 )
      {
        switch ( v8 )
        {
          case -326:
            *(_DWORD *)(v3 + 8) = -306;
            break;
          case -325:
            *(_DWORD *)(v3 + 8) = -305;
            break;
          case -323:
            *(_DWORD *)(v3 + 8) = -303;
            break;
          default:
            if ( v8 != -322 )
              goto LABEL_24;
            *(_DWORD *)(v3 + 8) = -302;
            break;
        }
      }
      else if ( v8 == -327 )
      {
        *(_DWORD *)(v3 + 8) = -307;
      }
      else
      {
        if ( v8 == -450 )
        {
          *(_DWORD *)(v3 + 8) = -401;
          goto LABEL_42;
        }
        if ( v8 == -414 )
        {
          *(_DWORD *)(v3 + 8) = -413;
LABEL_65:
          v10 = *(WCHAR **)(v3 + 12);
          v19 = *(_DWORD *)(v3 + 16);
LABEL_124:
          lpWideCharStr = v10;
          cchWideChar = v19;
          goto LABEL_26;
        }
        if ( v8 == -329 )
        {
          v10 = *(WCHAR **)(v3 + 20);
          v27 = *(_DWORD *)(v3 + 24);
          *(_DWORD *)(v3 + 8) = -309;
          lpWideCharStr = v10;
          cchWideChar = v27;
          v21 = LocalAlloc(0x40u, v27);
          *(_DWORD *)(v3 + 20) = v21;
          if ( !v21 )
          {
            *(_DWORD *)(v3 + 20) = v10;
            goto LABEL_26;
          }
          v53 = *(_DWORD *)(v3 + 24);
          goto LABEL_97;
        }
        if ( v8 != -328 )
          goto LABEL_24;
        *(_DWORD *)(v3 + 8) = -308;
      }
    }
    else
    {
      if ( v8 > -176 )
      {
        if ( v8 == -175 )
        {
          *(_DWORD *)(v3 + 8) = -105;
          goto LABEL_157;
        }
        if ( v8 != -163 )
        {
          if ( v8 != -161 )
          {
            if ( v8 != -158 )
              goto LABEL_24;
            v54 = *(_DWORD *)(v3 + 20);
            *(_DWORD *)(v3 + 8) = -157;
            if ( !InOutWtoA(a1, (int)&lpWideCharStr, v3 + 16, v54) )
              return 0;
            goto LABEL_141;
          }
          *(_DWORD *)(v3 + 8) = -160;
LABEL_157:
          if ( !(*(_BYTE *)(v3 + 12) & 1) || InOutWtoA(a1, (int)&lpWideCharStr, v3 + 32, *(_DWORD *)(v3 + 36)) )
            goto LABEL_25;
          return 0;
        }
        *(_DWORD *)(v3 + 8) = -162;
LABEL_154:
        if ( *(_BYTE *)(v3 + 16) & 0xE )
        {
          lpWideCharStr = *(LPWSTR *)(v3 + 20);
          v10 = lpWideCharStr;
          v36 = lstrlenW(lpWideCharStr);
          v37 = *(const WCHAR **)(v3 + 20);
          v38 = *(_DWORD *)(a1 + 20);
          cchWideChar = v36 + 1;
          *(_DWORD *)(v3 + 20) = ProduceAFromW(v38, v37);
          goto LABEL_26;
        }
LABEL_141:
        v10 = lpWideCharStr;
        goto LABEL_142;
      }
      if ( v8 == -176 )
      {
        *(_DWORD *)(v3 + 8) = -106;
        goto LABEL_157;
      }
      if ( v8 != -320 )
      {
        if ( v8 != -179 )
        {
          if ( v8 != -178 )
          {
            if ( v8 != -177 )
              goto LABEL_24;
            v31 = v3 + 12;
            *(_DWORD *)(v3 + 8) = -150;
            if ( v3 == -12 )
              goto LABEL_25;
            if ( v31 == -1 )
              goto LABEL_25;
            if ( !(*(_BYTE *)v31 & 1) )
              goto LABEL_25;
            v10 = *(WCHAR **)(v3 + 32);
            if ( !v10 || v10 == (WCHAR *)-1 )
              goto LABEL_25;
            v19 = *(_DWORD *)(v3 + 36);
            goto LABEL_124;
          }
          *(_DWORD *)(v3 + 8) = -151;
          goto LABEL_157;
        }
        *(_DWORD *)(v3 + 8) = -152;
        goto LABEL_154;
      }
      *(_DWORD *)(v3 + 8) = -300;
    }
    v25 = *(_DWORD *)(v3 + 20);
    if ( v25 && v25 != -1 )
    {
      if ( *(_BYTE *)v25 & 2 && (v10 = *(WCHAR **)(v25 + 8)) != 0 && v10 != (WCHAR *)-1 )
      {
        cchWideChar = *(_DWORD *)(v25 + 16);
        v26 = *(_DWORD *)(v60 + 20);
        lpWideCharStr = v10;
        *(_DWORD *)(v25 + 8) = ProduceAFromW(v26, v10);
      }
      else
      {
        v10 = lpWideCharStr;
      }
      if ( *(_DWORD *)v25 & 0x100 )
      {
        if ( *(_DWORD *)(v25 + 40) )
        {
          v32 = *(_DWORD *)(v25 + 36);
          if ( !(v32 & 0x8000) && !(v32 & 0xF) )
          {
            v33 = *(_DWORD *)(v25 + 40);
            v34 = *(_DWORD *)(v33 + 4);
            hMem = *(HLOCAL *)v33;
            v35 = *(_DWORD *)(v60 + 20);
            cchWideChar = v34;
            *(_DWORD *)v33 = ProduceAFromW(v35, (LPCWSTR)hMem);
          }
        }
      }
      goto LABEL_142;
    }
    goto LABEL_141;
  }
  if ( v8 == -451 )
  {
    *(_DWORD *)(v3 + 8) = -402;
    v61 = 1;
LABEL_225:
    if ( v61 )
      goto LABEL_226;
    *(_DWORD *)(v3 + 8) = -409;
LABEL_42:
    v61 = 1;
LABEL_226:
    if ( *(_BYTE *)(v3 + 16) & 1 )
    {
      v28 = *(_DWORD *)(v3 + 32);
      if ( v28 )
      {
        if ( v28 != -1 )
        {
          v29 = *(_DWORD *)(a1 + 20);
          hMem = *(HLOCAL *)(v3 + 32);
          *(_DWORD *)(v3 + 32) = ProduceAFromW(v29, (LPCWSTR)hMem);
        }
      }
    }
    if ( *(_DWORD *)(v3 + 8) == -409 )
      goto LABEL_25;
LABEL_228:
    if ( !v61 )
    {
      *(_DWORD *)(v3 + 8) = -405;
      v61 = 1;
LABEL_230:
      if ( !v61 )
        *(_DWORD *)(v3 + 8) = -406;
    }
LABEL_232:
    if ( !(*(_BYTE *)(v3 + 56) & 1) )
      goto LABEL_25;
    v10 = *(WCHAR **)(v3 + 72);
    if ( !v10 || v10 == (WCHAR *)-1 )
      goto LABEL_25;
    v30 = *(_DWORD *)(a1 + 20);
    lpWideCharStr = *(LPWSTR *)(v3 + 72);
    *(_DWORD *)(v3 + 72) = ProduceAFromW(v30, lpWideCharStr);
    goto LABEL_26;
  }
  if ( v8 > -530 )
  {
    switch ( v8 )
    {
      case -453:
        *(_DWORD *)(v3 + 8) = -404;
        goto LABEL_75;
      case -459:
        *(_DWORD *)(v3 + 8) = -410;
        goto LABEL_75;
      case -460:
        *(_DWORD *)(v3 + 8) = -411;
LABEL_75:
        if ( !(*(_BYTE *)(v3 + 12) & 1) || InOutWtoA(a1, (int)&lpWideCharStr, v3 + 28, *(_DWORD *)(v3 + 32)) )
          goto LABEL_25;
        return 0;
      case -456:
        *(_DWORD *)(v3 + 8) = -407;
        goto LABEL_232;
      case -457:
        *(_DWORD *)(v3 + 8) = -408;
        goto LABEL_232;
      case -458:
        goto LABEL_225;
      case -454:
        goto LABEL_228;
      case -455:
        goto LABEL_230;
      case -452:
        *(_DWORD *)(v3 + 8) = -403;
        if ( !(*(_BYTE *)(v3 + 12) & 1) )
          goto LABEL_25;
        v10 = *(WCHAR **)(v3 + 28);
        if ( !v10 )
          goto LABEL_25;
        if ( v10 == (WCHAR *)-1 )
          goto LABEL_25;
        v23 = *(_DWORD *)(v3 + 32);
        if ( !v23 )
          goto LABEL_25;
        v24 = *(_DWORD *)(v3 + 32);
        lpWideCharStr = *(LPWSTR *)(v3 + 28);
        cchWideChar = v23;
        v16 = LocalAlloc(0x40u, v24);
        hMem = v16;
        if ( !v16 )
          return 0;
        *(_DWORD *)(v3 + 28) = v16;
        goto LABEL_83;
      default:
        goto LABEL_24;
    }
    goto LABEL_24;
  }
  if ( v8 == -530 )
  {
    v22 = LocalAlloc(0x40u, 0x6Cu);
    v61 = (int)v22;
    if ( !v22 )
      return 0;
    *(_DWORD *)v22 = *(_DWORD *)v3;
    *((_DWORD *)v22 + 1) = *(_DWORD *)(v3 + 4);
    *((_DWORD *)v22 + 2) = *(_DWORD *)(v3 + 8);
    *((_DWORD *)v22 + 3) = (char *)v22 + 16;
    *((_DWORD *)v22 + 2) = -520;
    *((_DWORD *)v22 + 24) = *(_DWORD *)(v3 + 176);
    *((_DWORD *)v22 + 25) = *(_DWORD *)(v3 + 180);
    *((_DWORD *)v22 + 26) = *(_DWORD *)(v3 + 184);
    v52 = 80;
    v51 = (int)((char *)v22 + 16);
    v50 = (const WCHAR *)(v3 + 16);
    v49 = 0;
    goto LABEL_54;
  }
  if ( v8 <= -744 )
  {
    if ( v8 == -744 )
    {
      v18 = *(const WCHAR **)(v3 + 16);
      *(_DWORD *)(v3 + 8) = -757;
      v10 = (WCHAR *)ProduceAFromW(*(_DWORD *)(a1 + 20), v18);
      lpWideCharStr = v10;
      *(_DWORD *)(v3 + 16) = v10;
      goto LABEL_26;
    }
    if ( v8 == -809 )
    {
      v17 = LocalAlloc(0x40u, 0x114u);
      v61 = (int)v17;
      if ( !v17 )
        return 0;
      *(_DWORD *)v17 = *(_DWORD *)v3;
      *((_DWORD *)v17 + 1) = *(_DWORD *)(v3 + 4);
      *((_DWORD *)v17 + 2) = *(_DWORD *)(v3 + 8);
      *((_DWORD *)v17 + 2) = -808;
      *((_DWORD *)v17 + 3) = *(_DWORD *)(v3 + 12);
      v52 = 260;
      v51 = (int)((char *)v17 + 16);
      v12 = v3 + 16;
LABEL_53:
      v50 = (const WCHAR *)v12;
      v49 = 0;
LABEL_54:
      WideCharToMultiByte(*(_DWORD *)(v60 + 20), v49, v50, -1, (LPSTR)v51, v52, 0, 0);
      v10 = (WCHAR *)v3;
      v3 = v61;
      lpWideCharStr = v10;
LABEL_142:
      v4 = v60;
      goto LABEL_26;
    }
    if ( v8 != -807 )
    {
      if ( v8 != -806 )
      {
        if ( v8 != -745 )
          goto LABEL_24;
        *(_DWORD *)(v3 + 8) = -758;
        goto LABEL_50;
      }
      v11 = LocalAlloc(0x40u, 0x11Cu);
      v61 = (int)v11;
      if ( !v11 )
        return 0;
      *(_DWORD *)v11 = *(_DWORD *)v3;
      *((_DWORD *)v11 + 1) = *(_DWORD *)(v3 + 4);
      *((_DWORD *)v11 + 2) = *(_DWORD *)(v3 + 8);
      *((_DWORD *)v11 + 2) = -805;
      *((_DWORD *)v11 + 3) = *(_DWORD *)(v3 + 12);
      *((_DWORD *)v11 + 4) = *(_DWORD *)(v3 + 16);
      *((_DWORD *)v11 + 70) = *(_DWORD *)(v3 + 540);
      v52 = 260;
      v51 = (int)((char *)v11 + 20);
      v12 = v3 + 20;
      goto LABEL_53;
    }
    v13 = (*(_BYTE *)(v3 + 12) & 1) == 0;
    *(_DWORD *)(v3 + 8) = -800;
    if ( v13 )
      goto LABEL_25;
    v10 = *(WCHAR **)(v3 + 20);
    if ( !v10 )
      goto LABEL_25;
    if ( v10 == (WCHAR *)-1 )
      goto LABEL_25;
    v14 = *(_DWORD *)(v3 + 24);
    if ( !v14 )
      goto LABEL_25;
    v15 = *(_DWORD *)(v3 + 24);
    lpWideCharStr = *(LPWSTR *)(v3 + 20);
    cchWideChar = v14;
    v16 = LocalAlloc(0x40u, v15);
    hMem = v16;
    if ( !v16 )
      return 0;
    *(_DWORD *)(v3 + 20) = v16;
LABEL_83:
    *(_WORD *)v16 = 0;
LABEL_26:
    hWnd = (HWND)SendMessageW(hWnd, 0x4Eu, wParam, v3);
    if ( !v57 )
      return hWnd;
    v48 = *(_DWORD *)(v3 + 8);
    if ( v48 > 0xFFFFFE6C )
    {
      if ( v48 <= 0xFFFFFF60 )
      {
        if ( v48 != -160 )
        {
          if ( v48 <= 0xFFFFFECF )
          {
            if ( v48 < 0xFFFFFECC )
            {
              if ( v48 != -403 )
              {
                if ( v48 <= 0xFFFFFE6D )
                  return hWnd;
                if ( v48 <= 0xFFFFFE6F )
                  goto LABEL_249;
                if ( v48 != -309 )
                  return hWnd;
                MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, *(LPCSTR *)(v3 + 20), -1, v10, cchWideChar);
                LocalFree(*(HLOCAL *)(v3 + 20));
LABEL_195:
                *(_DWORD *)(v3 + 20) = v10;
                return hWnd;
              }
              if ( !v10 )
                return hWnd;
              if ( v10 == (WCHAR *)-1 )
                return hWnd;
              if ( !(*(_BYTE *)(v3 + 12) & 1) )
                return hWnd;
              v41 = *(const CHAR **)(v3 + 28);
              if ( !v41 || v41 == (const CHAR *)-1 )
                return hWnd;
              MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, v41, -1, v10, cchWideChar);
              *(_DWORD *)(v3 + 28) = v10;
LABEL_188:
              LocalFree(hMem);
              return hWnd;
            }
LABEL_196:
            v42 = *(_DWORD *)(v3 + 20);
            if ( v42 && v42 != -1 )
            {
              if ( *(_BYTE *)v42 & 2 && v10 && v10 != (WCHAR *)-1 )
              {
                MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, *(LPCSTR *)(v42 + 8), -1, v10, cchWideChar);
                FreeProducedString(*(HLOCAL *)(v42 + 8));
                *(_DWORD *)(v42 + 8) = v10;
              }
              if ( *(_DWORD *)v42 & 0x100 )
              {
                v43 = *(LPCSTR **)(v42 + 40);
                if ( v43 )
                {
                  if ( hMem )
                  {
                    v44 = *(_DWORD *)(v42 + 36);
                    if ( !(v44 & 0x8000) && !(v44 & 0xF) )
                    {
                      v45 = hMem;
                      MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, *v43, -1, (LPWSTR)hMem, cchWideChar);
                      FreeProducedString((HLOCAL)*v43);
                      *v43 = (LPCSTR)v45;
                    }
                  }
                }
              }
            }
            return hWnd;
          }
          if ( v48 < 0xFFFFFED1 )
            return hWnd;
          if ( v48 <= 0xFFFFFED4 )
            goto LABEL_196;
          if ( v48 != -162 )
            return hWnd;
LABEL_193:
          if ( !v10 )
            return hWnd;
          FreeProducedString(*(HLOCAL *)(v3 + 20));
          goto LABEL_195;
        }
LABEL_214:
        v40 = v3 + 32;
        goto LABEL_223;
      }
      if ( v48 == -157 )
      {
        v40 = v3 + 16;
        goto LABEL_223;
      }
      if ( v48 == -152 )
        goto LABEL_193;
      if ( v48 == -151 )
        goto LABEL_214;
      if ( v48 == -150 )
      {
        v46 = v3 + 12;
        if ( v46 )
        {
          if ( v46 != -1 )
          {
            if ( *(_BYTE *)v46 & 1 )
            {
              v47 = *(_DWORD *)(v46 + 20);
              if ( v47 )
              {
                if ( v47 != -1 )
                  StringBufferAtoW(*(_DWORD *)(v4 + 20), v10, cchWideChar, v46 + 20);
              }
            }
          }
        }
        return hWnd;
      }
      if ( v48 > 0xFFFFFF95 && v48 <= 0xFFFFFF97 )
        goto LABEL_214;
      return hWnd;
    }
    if ( v48 != -404 )
    {
      if ( v48 <= 0xFFFFFD32 )
      {
        if ( v48 == -718 )
          goto LABEL_172;
        if ( v48 != -808 && v48 != -805 )
        {
          if ( v48 == -800 )
          {
            MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, *(LPCSTR *)(v3 + 20), -1, v10, cchWideChar);
            if ( hMem )
              LocalFree(hMem);
            goto LABEL_195;
          }
          if ( v48 > 0xFFFFFD09 )
          {
            if ( v48 <= 0xFFFFFD0B )
              goto LABEL_261;
            if ( v48 == -756 )
            {
              FreeProducedString(v10);
              v39 = *(_DWORD *)(v3 + 32);
              if ( v39 && *(_BYTE *)v39 )
              {
                if ( v39 == v3 + 36 )
                {
                  StringCchCopyA(&pszDest, 0x40u, (STRSAFE_LPCSTR)(v3 + 36));
                  MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, &pszDest, -1, (LPWSTR)(v3 + 36), 32);
                }
                else
                {
                  *(_DWORD *)(v3 + 32) = ProduceWFromA(*(_DWORD *)(v4 + 20), *(LPCSTR *)(v3 + 32));
                }
              }
              return hWnd;
            }
            if ( v48 == -755 )
LABEL_261:
              FreeProducedString(v10);
          }
          return hWnd;
        }
        goto LABEL_174;
      }
      if ( v48 > 0xFFFFFE66 )
      {
        if ( v48 != -409 )
        {
          if ( v48 <= 0xFFFFFE67 || v48 > 0xFFFFFE6B )
            return hWnd;
LABEL_251:
          if ( v10 )
          {
            if ( v10 != (WCHAR *)-1 )
            {
              FreeProducedString(*(HLOCAL *)(v3 + 72));
              *(_DWORD *)(v3 + 72) = v10;
            }
          }
          return hWnd;
        }
LABEL_249:
        if ( hMem && hMem != (HLOCAL)-1 )
        {
          FreeProducedString(*(HLOCAL *)(v3 + 32));
          *(_DWORD *)(v3 + 32) = hMem;
        }
        if ( a2 == -458 )
          return hWnd;
        goto LABEL_251;
      }
      if ( v48 < 0xFFFFFE65 )
      {
        if ( v48 == -700 )
        {
          MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, *(LPCSTR *)(v3 + 40), -1, v10, cchWideChar);
          *(_DWORD *)(v3 + 40) = v10;
          goto LABEL_188;
        }
        if ( v48 != -520 )
        {
          if ( v48 != -413 )
            return hWnd;
LABEL_172:
          StringBufferAtoW(*(_DWORD *)(v4 + 20), v10, cchWideChar, v3 + 12);
          return hWnd;
        }
        ThunkToolTipTextAtoW(v3, (int)v10, *(_DWORD *)(v4 + 20));
LABEL_174:
        LocalFree((HLOCAL)v3);
        return hWnd;
      }
    }
    v40 = v3 + 28;
LABEL_223:
    InOutAtoW(v4, (int)&lpWideCharStr, v40);
    return hWnd;
  }
  if ( v8 == -743 )
  {
    *(_DWORD *)(v3 + 8) = -756;
    goto LABEL_50;
  }
  if ( v8 == -742 )
  {
    *(_DWORD *)(v3 + 8) = -755;
LABEL_50:
    v10 = (WCHAR *)ProduceAFromW(*(_DWORD *)(a1 + 20), *(LPCWSTR *)(v3 + 12));
    lpWideCharStr = v10;
    *(_DWORD *)(v3 + 12) = v10;
    goto LABEL_26;
  }
  if ( v8 != -720 )
  {
    if ( v8 != -719 )
    {
LABEL_24:
      v57 = 0;
LABEL_25:
      v10 = lpWideCharStr;
      goto LABEL_26;
    }
    *(_DWORD *)(v3 + 8) = -718;
    goto LABEL_65;
  }
  v10 = *(WCHAR **)(v3 + 40);
  v20 = *(_DWORD *)(v3 + 36);
  *(_DWORD *)(v3 + 8) = -700;
  lpWideCharStr = v10;
  cchWideChar = v20;
  v21 = LocalAlloc(0x40u, v20);
  hMem = v21;
  if ( v21 )
  {
    v53 = *(_DWORD *)(v3 + 36);
    *(_DWORD *)(v3 + 40) = v21;
LABEL_97:
    WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, v10, -1, (LPSTR)v21, v53, 0, 0);
    goto LABEL_26;
  }
  return 0;
}

//----- (6F7784FA) --------------------------------------------------------
unsigned int __stdcall CICustomDrawNotify(int a1, int a2, LPARAM lParam)
{
  unsigned int result; // eax@3
  HWND v4; // eax@5

  if ( !(a2 & 0x10000) || *(_BYTE *)(a1 + 12) & 0x20 )
  {
    *(_DWORD *)(lParam + 12) = a2;
    v4 = CCSendNotify(a1, -12, lParam);
    result = (unsigned __int16)((unsigned __int16)v4 & 0xFE01) == 0 ? (unsigned int)v4 : 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F77853E) --------------------------------------------------------
signed int __stdcall CCWndProc(int a1, int a2, unsigned int a3, int a4, int a5)
{
  signed int result; // eax@2
  int v6; // ecx@4
  int v7; // esi@13

  if ( (unsigned int)(a2 - 0x2000) <= 0x1FF )
  {
    v6 = 0;
    result = 1;
    switch ( a2 )
    {
      case 8197:
        v7 = *(_DWORD *)(a1 + 16);
        v6 = v7 & 1;
        *(_DWORD *)(a1 + 16) = v7 ^ (a3 ^ v7) & 1;
        break;
      case 8198:
        v6 = *(_DWORD *)(a1 + 16) & 1;
        break;
      case 8199:
        if ( a3 > 5 )
        {
          v6 = -1;
        }
        else
        {
          v6 = *(_DWORD *)(a1 + 28);
          *(_DWORD *)(a1 + 28) = a3;
        }
        break;
      case 8200:
        v6 = *(_DWORD *)(a1 + 28);
        break;
    }
    *(_DWORD *)a5 = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7785B3) --------------------------------------------------------
LRESULT __stdcall CIInitialize(int a1, WPARAM wParam, int a3)
{
  int v3; // edx@1
  HWND v4; // eax@1
  bool v5; // al@3
  char v6; // cl@4
  LRESULT result; // eax@4

  *(_DWORD *)a1 = wParam;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 12);
  v3 = *(_DWORD *)(a3 + 32);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a3 + 44);
  v4 = *(HWND *)(a1 + 4);
  v5 = v4 && SendMessageW(v4, 0x55u, wParam, 3) == 2;
  v6 = v5 ^ *(_DWORD *)(a1 + 16);
  result = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 16) ^= v6 & 1;
  if ( result )
  {
    result = SendMessageW((HWND)result, 0x129u, 0, 0);
    *(_WORD *)(a1 + 32) = result;
  }
  return result;
}

//----- (6F778637) --------------------------------------------------------
signed int __thiscall CImageList::_ReAllocBitmaps(CImageList *this, int a2)
{
  int v2; // eax@1
  CImageList *v3; // esi@1
  signed int v4; // ecx@3
  int v5; // eax@3
  int v6; // edi@3
  int v7; // ebx@3
  int v8; // eax@7
  HDC v9; // eax@10
  int v11; // ebx@20
  HBITMAP h; // [sp+4h] [bp-8h]@3
  HBITMAP v13; // [sp+8h] [bp-4h]@3

  v2 = a2;
  v3 = this;
  if ( a2 <= 0 )
  {
    v2 = -a2;
    a2 = -a2;
  }
  else if ( *((_DWORD *)this + 10) >= a2 )
  {
    return 0;
  }
  v4 = *((_DWORD *)this + 14);
  v5 = (v2 + v4 - 1) / v4;
  v13 = 0;
  h = 0;
  v6 = v4 * *((_DWORD *)v3 + 12);
  v7 = *((_DWORD *)v3 + 13) * v5;
  if ( a2 <= 0 )
    goto LABEL_7;
  if ( *((_BYTE *)v3 + 60) & 1 )
  {
    v13 = CreateMonoBitmap(v6, *((_DWORD *)v3 + 13) * v5);
    if ( !v13 )
      return -2147024882;
  }
  h = CImageList::_CreateBitmap(v3, v6, v7);
  if ( !h )
  {
    if ( v13 )
      CImageList::_DeleteBitmap(v13);
    return -2147024882;
  }
LABEL_7:
  v8 = *((_DWORD *)v3 + 9);
  if ( v8 > 0 )
  {
    if ( a2 < v8 )
      v8 = a2;
    v11 = *((_DWORD *)v3 + 13) * ((v8 + *((_DWORD *)v3 + 14) - 1) / *((_DWORD *)v3 + 14));
    if ( *((_BYTE *)v3 + 60) & 1 )
    {
      CImageList::SelectDstBitmap(v13);
      BitBlt(g_hdcDst, 0, 0, v6, v11, *((HDC *)v3 + 22), 0, 0, 0xCC0020u);
    }
    CImageList::SelectDstBitmap(h);
    BitBlt(g_hdcDst, 0, 0, v6, v11, *((HDC *)v3 + 21), 0, 0, 0xCC0020u);
  }
  CImageList::SelectDstBitmap(0);
  CImageList::SelectSrcBitmap(0);
  if ( h )
    SelectObject(*((HDC *)v3 + 21), h);
  v9 = (HDC)*((_DWORD *)v3 + 22);
  if ( v9 && v13 )
    SelectObject(v9, v13);
  if ( *((_DWORD *)v3 + 20) )
    CImageList::_DeleteBitmap(*((HBITMAP *)v3 + 20));
  if ( *((_DWORD *)v3 + 19) )
    CImageList::_DeleteBitmap(*((HBITMAP *)v3 + 19));
  *((_DWORD *)v3 + 16) = -1;
  *((_DWORD *)v3 + 20) = v13;
  *((_DWORD *)v3 + 10) = a2;
  *((_DWORD *)v3 + 19) = h;
  return 0;
}

//----- (6F77871D) --------------------------------------------------------
HBITMAP __thiscall CImageList::_CreateBitmap(CImageList *this, int a2, int cy)
{
  CImageList *v3; // esi@1
  int v4; // eax@2
  WORD v5; // ax@4
  HBITMAP v6; // eax@5
  HBITMAP v7; // esi@6
  HBITMAP result; // eax@6
  HDC v9; // eax@8
  HPALETTE v10; // eax@12
  DWORD v11; // esi@13
  signed __int32 v12; // ecx@14
  char *v13; // eax@15
  int v14; // edx@15
  BITMAPINFO bmi; // [sp+8h] [bp-430h]@4
  int v16; // [sp+34h] [bp-404h]@4
  int v17; // [sp+38h] [bp-400h]@4
  int v18; // [sp+3Ch] [bp-3FCh]@4
  int v19; // [sp+40h] [bp-3F8h]@4
  int v20; // [sp+44h] [bp-3F4h]@4
  int v21; // [sp+48h] [bp-3F0h]@4
  int v22; // [sp+4Ch] [bp-3ECh]@4
  int v23; // [sp+50h] [bp-3E8h]@4
  int v24; // [sp+54h] [bp-3E4h]@4
  int v25; // [sp+58h] [bp-3E0h]@4
  int v26; // [sp+5Ch] [bp-3DCh]@4
  int v27; // [sp+60h] [bp-3D8h]@4
  int v28; // [sp+64h] [bp-3D4h]@4
  int v29; // [sp+68h] [bp-3D0h]@4
  int v30; // [sp+6Ch] [bp-3CCh]@4
  void *ppvBits; // [sp+430h] [bp-8h]@5
  HDC hdc; // [sp+434h] [bp-4h]@2
  int cya; // [sp+444h] [bp+Ch]@12

  v3 = this;
  if ( *((_DWORD *)this + 19) && (v9 = (HDC)*((_DWORD *)this + 21)) != 0 )
  {
    result = CreateCompatibleBitmap(v9, a2, cy);
  }
  else
  {
    hdc = GetDC(0);
    v4 = *((_DWORD *)v3 + 15);
    if ( !(v4 & 0xFE) )
      *((_DWORD *)v3 + 15) = v4 | 4;
    if ( (*((_BYTE *)v3 + 60) & 0xFE) == -2 )
    {
      v6 = CreateCompatibleBitmap(hdc, a2, cy);
    }
    else
    {
      bmi.bmiHeader.biWidth = a2;
      bmi.bmiHeader.biHeight = cy;
      bmi.bmiHeader.biPlanes = 1;
      v5 = *((_WORD *)v3 + 30) & 0xFE;
      bmi.bmiHeader.biSize = 40;
      bmi.bmiHeader.biBitCount = v5;
      bmi.bmiHeader.biCompression = 0;
      bmi.bmiHeader.biSizeImage = 0;
      bmi.bmiHeader.biXPelsPerMeter = 0;
      bmi.bmiHeader.biYPelsPerMeter = 0;
      bmi.bmiHeader.biClrUsed = 16;
      bmi.bmiHeader.biClrImportant = 0;
      bmi.bmiColors[0] = 0;
      v16 = 0x800000;
      v17 = 0x8000;
      v18 = 8421376;
      v19 = 128;
      v20 = 8388736;
      v21 = 32896;
      v22 = 12632256;
      v23 = 8421504;
      v24 = 16711680;
      v25 = 65280;
      v26 = 16776960;
      v27 = 255;
      v28 = 16711935;
      v29 = 0xFFFF;
      v30 = 0xFFFFFF;
      if ( v5 == 8 )
      {
        v10 = CreateHalftonePalette(0);
        cya = (int)v10;
        if ( v10 )
        {
          v11 = GetPaletteEntries(v10, 0, 0x100u, (LPPALETTEENTRY)bmi.bmiColors);
          DeleteObject((HGDIOBJ)cya);
          if ( (signed int)v11 > 64 )
          {
            v12 = 0;
            for ( bmi.bmiHeader.biClrUsed = v11; v12 < (signed __int32)bmi.bmiHeader.biClrUsed; *(_DWORD *)v13 = v14 )
            {
              v13 = (char *)&bmi.bmiColors[v12];
              v14 = bmi.bmiColors[v12++].rgbRed | (((unsigned __int8)v13[1] | ((unsigned __int8)*v13 << 8)) << 8);
            }
          }
        }
        else
        {
          bmi.bmiHeader.biBitCount = *((_WORD *)v3 + 30) & 0xFE;
          bmi.bmiHeader.biClrUsed = 256;
        }
        if ( bmi.bmiHeader.biClrUsed <= 0x10 )
          bmi.bmiHeader.biBitCount = 4;
      }
      v6 = CreateDIBSection(hdc, &bmi, 0, &ppvBits, 0, 0);
    }
    v7 = v6;
    ReleaseDC(0, hdc);
    result = v7;
  }
  return result;
}

//----- (6F778894) --------------------------------------------------------
void *__cdecl operator new(SIZE_T dwBytes)
{
  HANDLE v1; // eax@1

  v1 = GetProcessHeap();
  return HeapAlloc(v1, 8u, dwBytes);
}

//----- (6F7788B2) --------------------------------------------------------
int __thiscall CImageList::CImageList(int this)
{
  int result; // eax@1

  result = this;
  *(_DWORD *)(this + 4) = 1280133448;
  *(_DWORD *)this = &CImageList::`vftable';
  *(_DWORD *)(this + 8) = &CImageList::`vftable';
  *(_DWORD *)(this + 12) = &CImageList::`vftable';
  *(_DWORD *)(this + 16) = &CImageList::`vftable';
  *(_DWORD *)(this + 20) = 1;
  return result;
}
// 6F777888: using guessed type int (__cdecl *CImageList::`vftable')(int);
// 6F77799C: using guessed type __int32 (__stdcall *CImageList::`vftable')(CImageList *this, const struct _GUID *, void **);
// 6F7779FC: using guessed type int (__stdcall *CImageList::`vftable')(int, int, int);
// 6F777A1C: using guessed type int (__stdcall *CImageList::`vftable')(int, int, int);

//----- (6F77890F) --------------------------------------------------------
int __stdcall CImageList::Create(int a1, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // esi@1
  __int32 v6; // edi@4
  int v7; // eax@5
  int result; // eax@9

  v5 = 0;
  if ( a1 < 0 || a2 < 0 || a3 & 0xFFFFD600 )
  {
    result = 0;
  }
  else
  {
    v6 = ImageList_InitGlobals();
    EnterCriticalSection(&g_csDll);
    if ( v6 >= 0 )
    {
      v7 = (int)operator new(0x608u);
      if ( v7 )
        v5 = CImageList::CImageList(v7);
      else
        v5 = 0;
      if ( v5 )
      {
        if ( CImageList::Initialize((CImageList *)v5, a1, a2, a3, a4, a5) < 0 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
          v5 = 0;
        }
      }
    }
    LeaveCriticalSection(&g_csDll);
    result = v5;
  }
  return result;
}

//----- (6F77899A) --------------------------------------------------------
signed int __thiscall CImageList::Initialize(CImageList *this, int a2, int a3, unsigned int a4, int ulAugend, int pulResult)
{
  CImageList *v6; // esi@1
  unsigned int v7; // eax@2
  HGDIOBJ v8; // eax@3
  HDC v9; // eax@3
  HDC v10; // eax@5
  int v11; // eax@6
  signed int result; // eax@11
  signed int v13; // eax@17
  signed int v14; // [sp+Ch] [bp-4h]@1

  v6 = this;
  v14 = -2147024882;
  if ( pulResult < 4 )
    v7 = 4;
  else
    v7 = (pulResult + 3) & 0xFFFFFFFC;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 17) = -1;
  *((_DWORD *)this + 11) = v7;
  *((_DWORD *)this + 12) = a2;
  *((_DWORD *)this + 14) = 4;
  *((_DWORD *)this + 13) = a3;
  v8 = GetStockObject(4);
  *((_DWORD *)v6 + 113) = 0;
  *((_DWORD *)v6 + 18) = v8;
  *((_DWORD *)v6 + 15) = a4;
  *((_DWORD *)v6 + 7) = 1;
  memset((char *)v6 + 92, 0xFFu, 0x3Cu);
  v9 = CreateCompatibleDC(0);
  *((_DWORD *)v6 + 21) = v9;
  if ( v9 )
  {
    if ( *((_BYTE *)v6 + 60) & 1 && (v10 = CreateCompatibleDC(0), (*((_DWORD *)v6 + 22) = v10) == 0) )
    {
      v14 = -2147024882;
    }
    else
    {
      v11 = ulAugend;
      if ( ulAugend < 0 )
        v11 = 0;
      if ( ULongAdd(v11, 1u, (ULONG *)&pulResult) >= 0 && (v14 = CImageList::_ReAllocBitmaps(v6, pulResult), v14 >= 0)
        || (v13 = CImageList::_ReAllocBitmaps(v6, 1), v14 = v13, v13 >= 0) )
      {
        if ( !*((_DWORD *)v6 + 6) )
          ++g_iILRefCount;
      }
    }
  }
  result = v14;
  *((_DWORD *)v6 + 6) = 1;
  return result;
}
// 6F7E6800: using guessed type int g_iILRefCount;

//----- (6F778A78) --------------------------------------------------------
unsigned __int32 __thiscall CImageList::_SetBkColor(CImageList *this, COLORREF color)
{
  CImageList *v2; // esi@1
  unsigned __int32 result; // eax@1
  COLORREF v4; // edi@1
  HBRUSH v5; // eax@6
  COLORREF v6; // ST08_4@6
  int v7; // eax@7
  COLORREF colora; // [sp+10h] [bp+8h]@5

  v2 = this;
  result = *((_DWORD *)this + 17);
  v4 = color;
  if ( result != color )
  {
    EnterCriticalSection(&g_csDll);
    if ( *((_DWORD *)v2 + 18) )
      DeleteObject(*((HGDIOBJ *)v2 + 18));
    colora = *((_DWORD *)v2 + 17);
    *((_DWORD *)v2 + 17) = v4;
    if ( v4 == -1 )
    {
      *((_DWORD *)v2 + 18) = GetStockObject(4);
      *((_DWORD *)v2 + 7) = 1;
    }
    else
    {
      v5 = CreateSolidBrush(v4);
      v6 = *((_DWORD *)v2 + 17);
      *((_DWORD *)v2 + 18) = v5;
      *((_DWORD *)v2 + 7) = GetNearestColor32(*((HDC *)v2 + 21), v6) == *((_DWORD *)v2 + 17);
    }
    v7 = *((_DWORD *)v2 + 9);
    if ( v7 > 0 )
      CImageList::_ResetBkColor(v2, 0, v7 - 1, *((_DWORD *)v2 + 17));
    LeaveCriticalSection(&g_csDll);
    result = colora;
  }
  return result;
}

//----- (6F778AAF) --------------------------------------------------------
int __stdcall CImageList::GlobalInit()
{
  HDC v0; // ebx@2
  HBITMAP v1; // eax@2
  HBITMAP v2; // edi@2
  int result; // eax@7

  if ( g_hdcDst )
  {
    result = 1;
  }
  else
  {
    v0 = GetDC(0);
    g_hdcSrc = CreateCompatibleDC(v0);
    g_hdcDst = CreateCompatibleDC(v0);
    InitDitherBrush();
    v1 = CreateBitmap(8, 8, 1u, 1u, dword_6F778B60);
    v2 = v1;
    if ( v1 )
    {
      g_hbmDcDeselect = SelectObject(g_hdcDst, v1);
      SelectObject(g_hdcDst, g_hbmDcDeselect);
      g_hbrStripe = CreatePatternBrush(v2);
      DeleteObject(v2);
    }
    ReleaseDC(0, v0);
    if ( g_hdcSrc && g_hdcDst && g_hbrMonoDither )
    {
      result = 1;
    }
    else
    {
      CImageList::GlobalUninit();
      result = 0;
    }
  }
  return result;
}
// 6F778B60: using guessed type int dword_6F778B60[5];

//----- (6F778B75) --------------------------------------------------------
int __stdcall ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = -1;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, HBITMAP, COLORREF, int *))(*(_DWORD *)himl + 28))(himl, hbmImage, crMask, &v4);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v4;
}

//----- (6F778BED) --------------------------------------------------------
signed int __stdcall CImageList::AddMasked(CImageList *this, HBITMAP h, unsigned __int32 color, int *a4)
{
  HBITMAP v5; // edi@3

  if ( *((_DWORD *)this + 111) )
  {
    v5 = (HBITMAP)CImageList::_CreateMirroredBitmap(h);
    CImageList::_AddMasked(*((CImageList **)this + 111), v5, color, a4);
    DeleteObject(v5);
  }
  return CImageList::_AddMasked((CImageList *)((char *)this - 8), h, color, a4);
}

//----- (6F778C1E) --------------------------------------------------------
signed int __thiscall CImageList::_AddMasked(CImageList *this, HBITMAP h, COLORREF color, int *a4)
{
  unsigned int v4; // eax@6
  signed int v5; // edx@8
  int v6; // esi@16
  signed int result; // eax@16
  RGBQUAD prgbq[256]; // [sp+4h] [bp-828h]@6
  RGBQUAD v9[256]; // [sp+404h] [bp-428h]@11
  char pv; // [sp+804h] [bp-28h]@1
  int nWidth; // [sp+808h] [bp-24h]@2
  int cy; // [sp+80Ch] [bp-20h]@2
  unsigned __int16 v13; // [sp+816h] [bp-16h]@5
  int v14; // [sp+818h] [bp-14h]@4
  CImageList *v15; // [sp+81Ch] [bp-10h]@1
  HGDIOBJ ho; // [sp+820h] [bp-Ch]@2
  COLORREF v17; // [sp+824h] [bp-8h]@9
  UINT cEntries; // [sp+828h] [bp-4h]@1
  COLORREF colora; // [sp+838h] [bp+Ch]@14

  *a4 = -1;
  v15 = this;
  cEntries = 0;
  if ( GetObjectW(h, 24, &pv) == 24 )
  {
    ho = CreateMonoBitmap(nWidth, cy);
    if ( ho )
    {
      EnterCriticalSection(&g_csDll);
      CImageList::SelectSrcBitmap(h);
      CImageList::SelectDstBitmap((HBITMAP)ho);
      if ( color == -16777216 )
        color = GetPixel(g_hdcSrc, 0, 0);
      if ( v14 && v13 <= 8u )
      {
        v4 = GetDIBColorTable(g_hdcSrc, 0, 0x100u, prgbq);
        cEntries = v4;
        if ( (signed int)v4 <= 0 || v4 > 0x100 )
        {
          cEntries = 0;
        }
        else
        {
          v5 = 0;
          if ( (signed int)v4 > 0 )
          {
            v17 = color >> 16;
            do
            {
              if ( prgbq[v5] == ((unsigned __int8)v17 | ((((unsigned __int8)color << 8) | BYTE1(color)) << 8)) )
                v9[v5] = (RGBQUAD)0xFFFFFF;
              else
                v9[v5] = 0;
              ++v5;
            }
            while ( v5 < (signed int)cEntries );
          }
          SetDIBColorTable(g_hdcSrc, 0, cEntries, v9);
        }
      }
      colora = SetBkColor(g_hdcSrc, color);
      BitBlt(g_hdcDst, 0, 0, nWidth, cy, g_hdcSrc, 0, 0, 0xCC0020u);
      SetBkColor(g_hdcSrc, 0xFFFFFFu);
      v17 = SetTextColor(g_hdcSrc, 0);
      BitBlt(g_hdcSrc, 0, 0, nWidth, cy, g_hdcDst, 0, 0, 0x220326u);
      SetBkColor(g_hdcSrc, colora);
      SetTextColor(g_hdcSrc, v17);
      if ( cEntries )
        SetDIBColorTable(g_hdcSrc, 0, cEntries, prgbq);
      CImageList::SelectSrcBitmap(0);
      CImageList::SelectDstBitmap(0);
      v6 = CImageList::_Add(v15, h, (HBITMAP)ho, nWidth / *((_DWORD *)v15 + 12), 0, 0, a4);
      DeleteObject(ho);
      LeaveCriticalSection(&g_csDll);
      result = v6;
    }
    else
    {
      result = -2147024882;
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}
// 6F778C1E: using guessed type RGBQUAD prgbq[256];
// 6F778C1E: using guessed type RGBQUAD var_428[256];

//----- (6F778E1F) --------------------------------------------------------
int __thiscall CImageList::_Add(CImageList *this, HBITMAP h, HBITMAP a3, int a4, int x1, int y1, int *a7)
{
  CImageList *v7; // esi@1
  signed int v8; // ebx@1
  int v9; // eax@4
  int v10; // ecx@5
  RGBQUAD prgbq; // [sp+Ch] [bp-408h]@12
  UINT v13; // [sp+40Ch] [bp-8h]@12
  int v14; // [sp+410h] [bp-4h]@1

  v7 = this;
  v8 = -1;
  v14 = 0;
  EnterCriticalSection(&g_csDll);
  if ( h && !*((_DWORD *)v7 + 9) && (*((_BYTE *)v7 + 60) & 0xFE) != -2 )
  {
    if ( !*((_DWORD *)v7 + 8) )
    {
      CImageList::SelectDstBitmap(h);
      v13 = GetDIBColorTable(g_hdcDst, 0, 0x100u, &prgbq);
      if ( v13 )
        (*(void (__stdcall **)(int, _DWORD, UINT, RGBQUAD *, int *))(*((_DWORD *)v7 + 3) + 20))(
          (char *)v7 + 12,
          0,
          v13,
          &prgbq,
          &v13);
      CImageList::SelectDstBitmap(0);
    }
    *((_DWORD *)v7 + 16) = -1;
  }
  v9 = *((_DWORD *)v7 + 10);
  if ( *((_DWORD *)v7 + 9) + a4 + 1 <= v9 )
    goto LABEL_19;
  v10 = *((_DWORD *)v7 + 11);
  if ( a4 > v10 )
    v10 = a4;
  v14 = CImageList::_ReAllocBitmaps(v7, v9 + v10 + 1);
  if ( v14 >= 0 )
  {
LABEL_19:
    v8 = *((_DWORD *)v7 + 9);
    *((_DWORD *)v7 + 9) = a4 + v8;
    if ( h )
    {
      v14 = CImageList::_Replace(v7, v8, a4, h, a3, x1, y1);
      if ( v14 < 0 )
      {
        *((_DWORD *)v7 + 9) -= a4;
        v8 = -1;
      }
    }
  }
  LeaveCriticalSection(&g_csDll);
  *a7 = v8;
  return v14;
}

//----- (6F778ED7) --------------------------------------------------------
__int32 __thiscall CImageList::_Replace(CImageList *this, int a2, int a3, HBITMAP h, HBITMAP a5, int x1, int y1)
{
  CImageList *v7; // esi@1
  int v8; // edi@3
  HDC v9; // eax@4
  int x; // [sp+8h] [bp-10h]@4
  int y; // [sp+Ch] [bp-Ch]@5
  int ha; // [sp+28h] [bp+10h]@3

  v7 = this;
  CImageList::SelectSrcBitmap(h);
  if ( *((_DWORD *)v7 + 22) )
    CImageList::SelectDstBitmap(a5);
  v8 = x1;
  for ( ha = 0; ha < a3; v8 += *((_DWORD *)v7 + 12) )
  {
    (*(void (__stdcall **)(int, int, int *))(*((_DWORD *)v7 + 2) + 60))((char *)v7 + 8, a2 + ha, &x);
    v9 = (HDC)*((_DWORD *)v7 + 22);
    if ( v9 )
      BitBlt(v9, x, y, *((_DWORD *)v7 + 12), *((_DWORD *)v7 + 13), g_hdcDst, v8, y1, 0xCC0020u);
    BitBlt(*((HDC *)v7 + 21), x, y, *((_DWORD *)v7 + 12), *((_DWORD *)v7 + 13), g_hdcSrc, v8, y1, 0xCC0020u);
    ++ha;
  }
  CImageList::_ResetBkColor(v7, a2, a2 + a3 - 1, *((_DWORD *)v7 + 17));
  CImageList::SelectSrcBitmap(0);
  if ( *((_DWORD *)v7 + 22) )
    CImageList::SelectDstBitmap(0);
  return 0;
}

//----- (6F778FAD) --------------------------------------------------------
void __thiscall CImageList::_ResetBkColor(CImageList *this, int a2, int a3, unsigned __int32 rop)
{
  CImageList *v4; // esi@1
  int i; // ebx@6
  int x; // [sp+4h] [bp-14h]@7
  int y; // [sp+8h] [bp-10h]@7
  HGDIOBJ h; // [sp+14h] [bp-4h]@1
  signed int ropa; // [sp+28h] [bp+10h]@5

  v4 = this;
  h = 0;
  if ( *((_DWORD *)this + 22) )
  {
    if ( rop && rop != -1 )
    {
      if ( rop == 0xFFFFFF )
      {
        ropa = 15597702;
      }
      else
      {
        ropa = 14812998;
        h = SelectObject(*((HDC *)this + 21), *((HGDIOBJ *)this + 18));
      }
    }
    else
    {
      ropa = 2229030;
    }
    for ( i = a2; i <= a3; ++i )
    {
      (*(void (__stdcall **)(int, int, int *))(*((_DWORD *)v4 + 2) + 60))((char *)v4 + 8, i, &x);
      BitBlt(*((HDC *)v4 + 21), x, y, *((_DWORD *)v4 + 12), *((_DWORD *)v4 + 13), *((HDC *)v4 + 22), x, y, ropa);
    }
    if ( h )
      SelectObject(*((HDC *)v4 + 21), h);
  }
}

//----- (6F77908C) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow)
{
  ImageList_CreateInstance(cx, cy, flags, cInitial, cGrow, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&cGrow);
  return (HIMAGELIST)cGrow;
}

//----- (6F7790BA) --------------------------------------------------------
int __stdcall ImageList_CreateInstance(int a1, int a2, unsigned int a3, int a4, int a5, const struct _GUID *a6, void **a7)
{
  int v7; // edi@1
  int v8; // eax@1
  int v9; // esi@1
  int v10; // eax@2
  int v12; // eax@5

  *a7 = 0;
  v7 = -2147024882;
  v8 = CImageList::Create(a1, a2, a3, a4, a5);
  v9 = v8;
  if ( v8 )
  {
    v10 = *(_DWORD *)(v8 + 60);
    if ( v10 & 0x2000 )
    {
      *(_DWORD *)(v9 + 60) = v10 & 0xFFFFDFFF;
      v12 = CImageList::Create(a1, a2, a3, a4, a5);
      *(_DWORD *)(v9 + 452) = v12;
      if ( v12 )
        *(_DWORD *)(v12 + 60) &= 0xFFFFDFFF;
    }
    v7 = (**(int (__stdcall ***)(int, const struct _GUID *, void **))v9)(v9, a6, a7);
    (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
  }
  return v7;
}

//----- (6F77913F) --------------------------------------------------------
int __stdcall TBSetImageList(int a1, int a2, signed int a3, int a4)
{
  signed int v4; // esi@2
  signed int v5; // eax@3
  int v6; // esi@5
  HLOCAL v8; // eax@8
  int v9; // ecx@9
  int v10; // [sp+8h] [bp-4h]@1

  v10 = 0;
  if ( *(_DWORD *)(a1 + 28) < 5 || (v4 = a3, a3 < 0) || a3 >= 20 )
    v4 = 0;
  v5 = *(_DWORD *)(a1 + 200);
  if ( v4 >= v5 && v5 >= 0 )
  {
    v8 = CCLocalReAlloc(*(HLOCAL *)(a1 + 196), 12 * (v4 + 1));
    if ( v8 )
    {
      v9 = *(_DWORD *)(a1 + 200);
      *(_DWORD *)(a1 + 196) = v8;
      memset((char *)v8 + 12 * v9, 0, 12 * (v4 - v9 + 1));
      *(_DWORD *)(a1 + 200) = v4 + 1;
    }
  }
  if ( v4 < *(_DWORD *)(a1 + 200) )
  {
    v6 = *(_DWORD *)(a1 + 196) + 4 * (a2 + 3 * v4);
    v10 = *(_DWORD *)v6;
    *(_DWORD *)v6 = a4;
  }
  return v10;
}

//----- (6F779197) --------------------------------------------------------
int __stdcall TBBuildImageList(HANDLE h)
{
  int result; // eax@1
  int v2; // ebx@2
  int v3; // eax@2
  int i; // edi@2

  result = (int)((char *)h + 236);
  *(_DWORD *)result |= 1u;
  if ( !(*((_BYTE *)h + 236) & 2) )
  {
    v2 = 0;
    v3 = TBSetImageList((int)h, 0, 0, 0);
    result = ImageList_Destroy((HIMAGELIST)v3);
    for ( i = *((_DWORD *)h + 21); v2 < *((_DWORD *)h + 20); i += 12 )
    {
      result = TBAddBitmapToImageList(h, i);
      ++v2;
    }
  }
  return result;
}

//----- (6F7791F0) --------------------------------------------------------
int __stdcall HeightWithString(int a1, int a2)
{
  int v2; // eax@3
  int result; // eax@4

  if ( *(_BYTE *)(a1 + 36) & 8 )
  {
    if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
    {
LABEL_3:
      v2 = *(_DWORD *)(a1 + 136);
      if ( v2 )
        return v2 + a2 + 1;
      goto LABEL_6;
    }
    result = TBMixedButtonsHeight(a1);
  }
  else
  {
    if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
      goto LABEL_3;
    result = *(_DWORD *)(a1 + 136);
  }
  if ( a2 > result )
LABEL_6:
    result = a2;
  return result;
}

//----- (6F77922E) --------------------------------------------------------
signed int __stdcall SetBitmapSize(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // ebx@2
  int v5; // eax@5
  HWND v7; // ST04_4@12

  v3 = a2;
  if ( !a2 )
    v3 = a2 + 1;
  v4 = a3;
  if ( !a3 )
    v4 = a3 + 1;
  if ( v3 == -1 )
    v3 = *(_DWORD *)(a1 + 104);
  if ( v4 == -1 )
    v4 = *(_DWORD *)(a1 + 108);
  v5 = v4;
  if ( *(_DWORD *)(a1 + 104) == v3 && *(_DWORD *)(a1 + 108) == v4 )
    return 1;
  if ( *(_DWORD *)(a1 + 92) || *(_BYTE *)(a1 + 236) & 8 )
    v5 = HeightWithString(a1, v4);
  if ( GrowToolbar(a1, v3, v5, 1) )
  {
    v7 = *(HWND *)a1;
    *(_DWORD *)(a1 + 104) = v3;
    *(_DWORD *)(a1 + 108) = v4;
    InvalidateRect(v7, 0, 1);
    *(_DWORD *)(a1 + 236) &= 0xFFFFFFFE;
    return 1;
  }
  return 0;
}

//----- (6F779284) --------------------------------------------------------
void __stdcall TB_OnSize(HDC hDC, int xRight, int yBottom)
{
  HDC v3; // esi@1
  int v4; // edi@3
  int v5; // eax@5
  int v6; // ecx@5
  int v7; // eax@8
  int v8; // edx@8
  int v9; // ecx@10
  struct tagRECT rcDst; // [sp+4h] [bp-40h]@15
  RECT rcSrc2; // [sp+14h] [bp-30h]@14
  struct tagRECT rc; // [sp+24h] [bp-20h]@8
  RECT rcSrc1; // [sp+34h] [bp-10h]@15
  int hDCa; // [sp+4Ch] [bp+8h]@14

  v3 = hDC;
  if ( *((_BYTE *)hDC + 36) & 0x10 )
  {
    v4 = *((_DWORD *)hDC + 63);
    if ( *((_DWORD *)hDC + 63) >= yBottom )
      v4 = yBottom;
    v5 = *((_DWORD *)hDC + 62);
    v6 = *((_DWORD *)hDC + 62);
    if ( v5 > xRight || (v6 = xRight, v5 >= xRight) )
      v5 = xRight;
    SetRect(&rc, v5, *((_DWORD *)hDC + 61), v6, v4);
    v7 = *((_DWORD *)hDC + 63);
    v8 = *((_DWORD *)hDC + 63);
    if ( v7 <= yBottom )
      v8 = yBottom;
    v9 = *((_DWORD *)hDC + 62);
    if ( v9 >= xRight )
      v9 = xRight;
    if ( v7 >= yBottom )
      v7 = yBottom;
    SetRect(&rcSrc2, *((_DWORD *)hDC + 60), v7, v9, v8);
    for ( hDCa = 0; hDCa < *((_DWORD *)v3 + 33); ++hDCa )
    {
      TB_GetItemRect(v3, hDCa, (int)&rcSrc1);
      if ( IntersectRect(&rcDst, &rcSrc1, &rc) || IntersectRect(&rcDst, &rcSrc1, &rcSrc2) )
        InvalidateRect(*(HWND *)v3, &rcSrc1, 1);
    }
    SetRect((LPRECT)v3 + 15, 0, 0, xRight, yBottom);
  }
}

//----- (6F7792B9) --------------------------------------------------------
signed int __stdcall CountRows(int a1)
{
  unsigned int v1; // edx@1
  signed int result; // eax@1
  int v3; // ecx@1

  v1 = *(_DWORD *)(a1 + 48);
  result = 1;
  v3 = v1 + 28 * *(_DWORD *)(a1 + 132);
  while ( v1 < v3 )
  {
    if ( *(_BYTE *)(v1 + 8) & 0x20 )
    {
      ++result;
      if ( *(_BYTE *)(v1 + 9) & 1 )
        ++result;
    }
    v1 += 28;
  }
  return result;
}

//----- (6F779309) --------------------------------------------------------
void __stdcall TBAutoSize(HWND hWndTo)
{
  int v1; // esi@1
  int v2; // eax@1
  signed int v3; // eax@2
  int v4; // eax@3
  int v5; // ecx@3
  HWND v6; // ST20_4@4
  int v7; // eax@5
  struct tagRECT rcDst; // [sp+4h] [bp-24h]@14
  struct tagRECT Rect; // [sp+14h] [bp-14h]@9
  int cy; // [sp+24h] [bp-4h]@4
  HWND hWndToa; // [sp+30h] [bp+8h]@4

  v1 = (int)hWndTo;
  v2 = *((_DWORD *)hWndTo + 59);
  if ( v2 & 0x800 )
  {
    *((_DWORD *)hWndTo + 59) = v2 | 0x2000;
  }
  else
  {
    v3 = CountRows((int)hWndTo);
    if ( *((_BYTE *)hWndTo + 36) & 2 )
    {
      v4 = *((_DWORD *)hWndTo + 28) * v3;
      v5 = g_cyEdge;
    }
    else
    {
      v4 = *((_DWORD *)hWndTo + 29) * v3;
      v5 = g_cxEdge;
    }
    v6 = *(HWND *)hWndTo;
    cy = v4 + 2 * v5;
    hWndToa = GetParent(v6);
    if ( hWndToa )
    {
      v7 = *(_DWORD *)(v1 + 8);
      if ( v7 & 0x200 || *(_BYTE *)(v1 + 36) & 2 )
      {
        if ( v7 & 0xC )
          GetWindowRect(*(HWND *)v1, &Rect);
        else
          GetWindowRect(hWndToa, &Rect);
        if ( *(_DWORD *)(v1 + 8) & 0x200 )
          WrapToolbar((HDC)v1, Rect.right - Rect.left, (int)&rcDst, 0);
        else
          WrapToolbarCol(v1, *(_DWORD *)(v1 + 260), &rcDst, 0);
      }
      if ( *(_DWORD *)(v1 + 8) & 0x200 || *(_BYTE *)(v1 + 36) & 0x12 )
        TBInvalidateItemRects(v1);
      GetWindowRect(*(HWND *)v1, &Rect);
      MapWindowPoints(0, hWndToa, (LPPOINT)&Rect, 2u);
      NewSize(*(HWND *)v1, cy, *(_DWORD *)(v1 + 8), Rect.left, Rect.top, Rect.right, Rect.bottom);
    }
  }
}

//----- (6F7793CA) --------------------------------------------------------
void __stdcall NewSize(HWND hWnd, int cy, int a3, int a4, int a5, int a6, int a7)
{
  LONG v7; // ebx@4
  LONG v8; // esi@4
  LONG v9; // edi@4
  int v10; // eax@5
  HWND v11; // eax@7
  int v12; // ecx@8
  int v13; // eax@8
  int v14; // edx@9
  int v15; // edx@16
  int v16; // esi@16
  LONG v17; // [sp+4h] [bp-30h]@4
  struct tagRECT Rect; // [sp+10h] [bp-24h]@2
  struct tagRECT v19; // [sp+20h] [bp-14h]@2
  int v20; // [sp+30h] [bp-4h]@4
  int cya; // [sp+40h] [bp+Ch]@6

  if ( a3 & 4 )
    return;
  GetWindowRect(hWnd, &Rect);
  Rect.right -= Rect.left;
  Rect.bottom -= Rect.top;
  GetClientRect(hWnd, &v19);
  if ( GetWindowLongW(hWnd, -20) & 0x400000 )
    TrueMapWindowPoints(hWnd, 0, (int)&v19, 1);
  else
    ClientToScreen(hWnd, (LPPOINT)&v19);
  v7 = v19.left - Rect.left;
  v8 = Rect.right - v19.right - (v19.left - Rect.left);
  v9 = Rect.bottom - v19.bottom - (v19.top - Rect.top);
  v20 = a3 & 0x80;
  v17 = v19.top - Rect.top;
  if ( a3 & 0x80 )
    v10 = v8 + v7;
  else
    v10 = Rect.bottom - v19.bottom;
  cya = v10 + cy;
  if ( !(a3 & 8) )
  {
    v11 = GetParent(hWnd);
    GetClientRect(v11, &v19);
    if ( v20 )
    {
      v13 = -v8;
      a7 = v17 + v9 + v19.bottom;
      v12 = a4;
    }
    else
    {
      v12 = -v7;
      a6 = v7 + v8 + v19.right;
      v13 = a5;
    }
    v14 = a3 & 3;
    if ( v14 == 1 )
    {
      if ( v20 )
        v12 = -v7;
      else
        v13 = -v17;
    }
    else if ( v14 != 2 )
    {
      if ( v20 )
        v12 = v19.right + v8 - cya;
      else
        v13 = v19.bottom + v9 - cya;
    }
    goto LABEL_12;
  }
  if ( (a3 & 3) > 0 && (a3 & 3) <= 2 )
  {
    v12 = a4;
    goto LABEL_34;
  }
  if ( v20 )
  {
    v12 = a6 - cya + a4;
LABEL_34:
    v13 = a5;
    goto LABEL_12;
  }
  v13 = a7 - cya + a5;
  v12 = a4;
LABEL_12:
  if ( !(a3 & 0x42) )
  {
    if ( v20 )
      v12 += g_cxEdge;
    else
      v13 += g_cyEdge;
  }
  if ( v20 )
  {
    v16 = cya;
    v15 = a7;
  }
  else
  {
    v15 = cya;
    v16 = a6;
  }
  SetWindowPos(hWnd, 0, v12, v13, v16, v15, 4u);
}

//----- (6F7794FA) --------------------------------------------------------
signed int __stdcall CheckMonoMask(int a1, int a2, int a3)
{
  void *v3; // eax@1
  signed int result; // eax@4
  signed int v5; // edi@6
  char pv; // [sp+Ch] [bp-18h]@2
  int v7; // [sp+10h] [bp-14h]@2
  int v8; // [sp+14h] [bp-10h]@3

  v3 = *(void **)(a1 + 44);
  if ( v3 )
  {
    GetObjectW(v3, 24, &pv);
    if ( a2 <= v7 && a3 <= v8 )
      return 1;
  }
  result = (signed int)CreateMonoBitmap(a2 + 8, a3 + 8);
  v5 = result;
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 44) )
      DeleteObject(*(HGDIOBJ *)(a1 + 44));
    *(_DWORD *)(a1 + 44) = v5;
    return 1;
  }
  return result;
}

//----- (6F779561) --------------------------------------------------------
signed int __stdcall TBRecalc(int a1)
{
  int v1; // esi@1
  int v2; // ecx@1
  HWND v3; // ST10_4@4
  int v4; // edi@4
  int v5; // eax@7
  int v6; // ebx@10
  int v7; // eax@11
  int v8; // eax@12
  int v9; // edx@13
  int v10; // eax@16
  int v11; // edi@20
  int v12; // eax@20
  LONG v14; // eax@27
  int v15; // eax@31
  char v16; // cl@32
  int v17; // edx@34
  int v18; // ebx@34
  int v19; // eax@36
  int v20; // edi@36
  int v21; // ebx@37
  int v22; // ecx@43
  int v23; // eax@59
  LONG v24; // ecx@59
  int v25; // eax@69
  int v26; // ebx@74
  int v27; // edx@74
  LONG v28; // edi@79
  int v29; // eax@86
  bool v30; // zf@86
  bool v31; // sf@86
  unsigned __int8 v32; // of@86
  struct tagTEXTMETRICW tm; // [sp+8h] [bp-88h]@1
  UINT format; // [sp+44h] [bp-4Ch]@74
  struct tagRECT rc; // [sp+48h] [bp-48h]@59
  struct tagRECT v36; // [sp+58h] [bp-38h]@4
  int v37; // [sp+68h] [bp-28h]@12
  LONG v38; // [sp+6Ch] [bp-24h]@67
  HGDIOBJ h; // [sp+70h] [bp-20h]@1
  LONG v40; // [sp+74h] [bp-1Ch]@67
  int v41; // [sp+78h] [bp-18h]@4
  struct tagSIZE sz; // [sp+7Ch] [bp-14h]@4
  int v43; // [sp+84h] [bp-Ch]@10
  HDC hdc; // [sp+88h] [bp-8h]@4
  int v45; // [sp+8Ch] [bp-4h]@30
  int v46; // [sp+98h] [bp+8h]@10
  int v47; // [sp+98h] [bp+8h]@67

  tm.tmHeight = 0;
  memset(&tm.tmAscent, 0, 0x38u);
  v1 = a1;
  v2 = *(_DWORD *)(a1 + 236);
  h = 0;
  if ( !(v2 & 0x800) )
  {
    *(_DWORD *)(a1 + 136) = 0;
    if ( !*(_DWORD *)(a1 + 92) && !(v2 & 8) || !*(_DWORD *)(a1 + 96) )
    {
      v6 = *(_DWORD *)(a1 + 104);
      v37 = *(_DWORD *)(a1 + 104);
      goto LABEL_20;
    }
    v3 = *(HWND *)a1;
    sz.cx = 0;
    sz.cy = 0;
    v4 = *(_DWORD *)(a1 + 148);
    v36.left = 0;
    v36.top = 0;
    v36.right = 0;
    v36.bottom = 0;
    v41 = v4;
    *(_DWORD *)(a1 + 112) = 0;
    hdc = GetDC(v3);
    if ( !hdc )
      return 0;
    if ( *(_DWORD *)(a1 + 76) )
      h = SelectObject(hdc, *(HGDIOBJ *)(a1 + 76));
    GetTextMetricsW(hdc, &tm);
    v5 = *(_DWORD *)(a1 + 96);
    if ( v5 )
      *(_DWORD *)(a1 + 136) = tm.tmHeight * v5 + tm.tmExternalLeading * (v5 - 1);
    if ( *(_DWORD *)(a1 + 8) & 0x1000 )
    {
      v4 += *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 156);
      v41 = v4;
    }
    v6 = *(_DWORD *)(a1 + 104);
    v30 = *(_DWORD *)(a1 + 132) == 0;
    v31 = *(_DWORD *)(a1 + 132) < 0;
    v46 = *(_DWORD *)(a1 + 104);
    v43 = 0;
    if ( v31 || v30 )
    {
LABEL_11:
      v7 = *(_DWORD *)(v1 + 120);
      if ( v7 && v7 > v4 + v6 )
        v6 = v7 - v4;
      v8 = *(_DWORD *)(v1 + 124);
      v37 = v6;
      if ( v8 && v8 < v4 + v6 )
      {
        v30 = *(_DWORD *)(v1 + 132) == 0;
        v31 = *(_DWORD *)(v1 + 132) < 0;
        v6 = v8 - v4;
        v38 = 0;
        v40 = 0;
        v47 = v8 - v4;
        v43 = 0;
        if ( !v31 && !v30 )
        {
          v45 = 0;
          do
          {
            v25 = *(_DWORD *)(v1 + 48);
            if ( !(*(_BYTE *)(v25 + v45 + 8) & 8) )
            {
              if ( !*(_DWORD *)(v1 + 96)
                || *(_BYTE *)(v1 + 36) & 8 && *(_DWORD *)(v1 + 8) & 0x1000 && !(*(_BYTE *)(v25 + v45 + 9) & 0x40) )
              {
                v26 = 0;
              }
              else
              {
                v26 = TB_StrForButton(v1, v25 + v45);
                format = TBGetDrawTextFlags(v1, 0, v27) | 0x400;
              }
              if ( !v26 )
                goto LABEL_101;
              if ( *(_BYTE *)(v1 + 36) & 4 && TB_HasDDArrow(v1, v45 + *(_DWORD *)(v1 + 48)) )
                v28 = v47 - *(_DWORD *)(v1 + 140);
              else
                v28 = v47;
              if ( v28 <= 1 )
                v28 = 1;
              v36.bottom = *(_DWORD *)(v1 + 136);
              v36.right = v28;
              DrawTextW(hdc, (LPCWSTR)v26, -1, &v36, format);
              if ( *(_DWORD *)(v1 + 96) <= 1 )
              {
                v29 = 0;
                v32 = __OFSUB__(v36.right, v28);
                v30 = v36.right == v28;
                v31 = v36.right - v28 < 0;
              }
              else
              {
                if ( v47 + v36.right - v28 > v40 )
                  v40 = v47 + v36.right - v28;
                v29 = 0;
                v32 = __OFSUB__(v36.bottom, *(_DWORD *)(v1 + 136));
                v30 = v36.bottom == *(_DWORD *)(v1 + 136);
                v31 = v36.bottom - *(_DWORD *)(v1 + 136) < 0;
              }
              if ( v38 < v36.bottom )
                v38 = v36.bottom;
              LOBYTE(v29) = !((unsigned __int8)(v31 ^ v32) | v30);
              if ( v29 )
                *(_BYTE *)(v45 + *(_DWORD *)(v1 + 48) + 8) |= 0x40u;
              else
LABEL_101:
                *(_BYTE *)(v45 + *(_DWORD *)(v1 + 48) + 8) &= 0xBFu;
              v4 = v41;
              v6 = v47;
            }
            ++v43;
            v45 += 28;
          }
          while ( v43 < *(_DWORD *)(v1 + 132) );
          if ( v40 && *(_DWORD *)(v1 + 96) > 1 )
            v6 = v40;
        }
        v14 = v38;
      }
      else
      {
        v9 = 0;
        if ( *(_DWORD *)(v1 + 132) > 0 )
        {
          v22 = 0;
          do
          {
            *(_BYTE *)(v22 + *(_DWORD *)(v1 + 48) + 8) &= 0xBFu;
            ++v9;
            v22 += 28;
          }
          while ( v9 < *(_DWORD *)(v1 + 132) );
        }
        if ( !*(_DWORD *)(v1 + 96) || !*(_DWORD *)(v1 + 132) )
          goto LABEL_16;
        v14 = sz.cy;
      }
      if ( *(_DWORD *)(v1 + 136) > v14 )
        *(_DWORD *)(v1 + 136) = v14;
LABEL_16:
      v10 = *(_DWORD *)(v1 + 120);
      if ( v10 && v10 > v4 + v6 )
        v6 = v10 - v4;
      if ( h )
        SelectObject(hdc, h);
      ReleaseDC(*(HWND *)v1, hdc);
LABEL_20:
      v11 = HeightWithString(v1, *(_DWORD *)(v1 + 108));
      v12 = v6;
      if ( v6 <= v37 )
        v12 = v37;
      if ( GrowToolbar(v1, v12, v11, 3) )
        return GrowToolbar(v1, v6, v11, 1);
      return 0;
    }
    v45 = 0;
    while ( 1 )
    {
      v15 = v45 + *(_DWORD *)(v1 + 48);
      if ( !(*(_BYTE *)(v15 + 8) & 8) )
        break;
LABEL_40:
      ++v43;
      v45 += 28;
      if ( v43 >= *(_DWORD *)(v1 + 132) )
      {
        v6 = v46;
        v4 = v41;
        goto LABEL_11;
      }
    }
    v16 = *(_BYTE *)(v15 + 9);
    if ( v16 & 0x10 || *(_BYTE *)(v1 + 36) & 8 && *(_DWORD *)(v1 + 8) & 0x1000 && !(v16 & 1) )
      *(_WORD *)(v15 + 10) = 0;
    v18 = TB_StrForButton(v1, *(_DWORD *)(v1 + 48) + v45);
    if ( v18 )
    {
      if ( *(_DWORD *)(v1 + 28) < 5 )
      {
        sz.cx = 0;
        sz.cy = 0;
        v19 = lstrlenW((LPCWSTR)v18);
        GetTextExtentPointW(hdc, (LPCWSTR)v18, v19, &sz);
        v20 = sz.cx;
        goto LABEL_37;
      }
      v23 = TBGetDrawTextFlags(v1, 0, v17);
      v24 = *(_DWORD *)(v1 + 136);
      rc.left = 0;
      rc.top = 0;
      rc.right = 0;
      rc.bottom = v24;
      DrawTextW(hdc, (LPCWSTR)v18, -1, &rc, v23 & 0xFFFFFFEF | 0x420);
      v20 = rc.right - rc.left;
      sz.cy = rc.bottom - rc.top;
    }
    else
    {
      v20 = 0;
    }
    sz.cx = v20;
LABEL_37:
    v21 = v45 + *(_DWORD *)(v1 + 48);
    if ( TB_HasTopDDArrow(v1, v21) )
    {
      if ( v20 > *(_DWORD *)(v1 + 104) + *(_DWORD *)(v1 + 140) + 2 * g_cxEdge )
        goto LABEL_39;
      v20 = *(_DWORD *)(v1 + 104) + *(_DWORD *)(v1 + 140) + 2 * g_cxEdge;
    }
    else
    {
      if ( !(*(_BYTE *)(v1 + 36) & 4) || !TB_HasDDArrow(v1, v21) )
      {
LABEL_39:
        if ( v46 < v20 )
          v46 = v20;
        goto LABEL_40;
      }
      v20 += *(_DWORD *)(v1 + 140);
    }
    sz.cx = v20;
    goto LABEL_39;
  }
  *(_DWORD *)(a1 + 236) = v2 | 0x2000;
  return 1;
}

//----- (6F7796F5) --------------------------------------------------------
signed int __stdcall GrowToolbar(int a1, int a2, int a3, char a4)
{
  int v4; // edi@1
  int v5; // ebx@2
  int v6; // eax@5
  signed int result; // eax@8
  int v8; // eax@11
  int v9; // edx@23

  v4 = a2;
  if ( !a2 )
    v4 = 24;
  v5 = a3;
  if ( !a3 )
    v5 = 22;
  if ( a4 & 1 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x1000 )
      v4 += *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 156);
    v4 += *(_DWORD *)(a1 + 148);
    v6 = *(_DWORD *)(a1 + 112);
    v5 += *(_DWORD *)(a1 + 152);
    if ( v4 >= v6 || !*(_DWORD *)(a1 + 92) || *(_DWORD *)(a1 + 28) >= 5 && *(_DWORD *)(a1 + 96) <= 0 )
      goto LABEL_6;
LABEL_35:
    v4 = v6;
    goto LABEL_6;
  }
  if ( v5 == -1 )
    v5 = *(_DWORD *)(a1 + 116);
  if ( v4 == -1 )
    v4 = *(_DWORD *)(a1 + 112);
  v9 = *(_DWORD *)(a1 + 108);
  if ( v5 < v9 + *(_DWORD *)(a1 + 152) )
    v5 = v9 + *(_DWORD *)(a1 + 152);
  v6 = *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 148);
  if ( v4 < v6 )
    goto LABEL_35;
LABEL_6:
  if ( *(_DWORD *)(a1 + 44) && v4 <= *(_DWORD *)(a1 + 112) && v5 <= *(_DWORD *)(a1 + 116)
    || (result = CheckMonoMask(a1, v4, v5)) != 0 )
  {
    if ( !(a4 & 2) )
    {
      if ( !(a4 & 1) && (*(_DWORD *)(a1 + 112) != v4 || *(_DWORD *)(a1 + 116) != v5) )
        InvalidateRect(*(HWND *)a1, 0, 1);
      v8 = ~(unsigned __int8)(*(_DWORD *)(a1 + 8) >> 10) & 2;
      *(_DWORD *)(a1 + 112) = v4;
      *(_DWORD *)(a1 + 116) = v5;
      *(_DWORD *)(a1 + 128) = v8;
      TBInvalidateItemRects(a1);
    }
    result = 1;
  }
  return result;
}

//----- (6F7797A2) --------------------------------------------------------
int __stdcall TBInvalidateItemRects(int a1)
{
  int result; // eax@1
  unsigned int v2; // edx@1

  result = a1;
  *(_DWORD *)(a1 + 164) = -1;
  v2 = *(_DWORD *)(a1 + 236) & 0xFFFEFFFF | 0x10;
  *(_DWORD *)(a1 + 168) = -1;
  *(_DWORD *)(a1 + 236) = v2;
  return result;
}

//----- (6F7797DC) --------------------------------------------------------
int __stdcall TBInitMetrics(int a1)
{
  int result; // eax@1

  InitGlobalColors();
  result = GetSystemMetrics(72);
  *(_DWORD *)(a1 + 140) = result;
  return result;
}

//----- (6F77999C) --------------------------------------------------------
HFONT __stdcall TBChangeFont(int a1, int a2, HFONT a3)
{
  int v3; // edi@1
  HFONT v4; // ebx@3
  HFONT result; // eax@4
  char pvParam; // [sp+8h] [bp-60h]@2

  v3 = (*(_DWORD *)(a1 + 236) >> 2) & 1;
  if ( a2 && a2 != 34 && a2 != 42 || !SystemParametersInfoW(0x1Fu, 0x5Cu, &pvParam, 0) )
  {
    result = 0;
  }
  else
  {
    v4 = a3;
    if ( a3 )
    {
      *(_DWORD *)(a1 + 236) &= 0xFFFFFFFB;
    }
    else
    {
      result = CreateFontIndirectW((const LOGFONTW *)&pvParam);
      v4 = result;
      if ( !result )
        return result;
      *(_DWORD *)(a1 + 236) |= 4u;
    }
    if ( *(_DWORD *)(a1 + 76) )
    {
      if ( v3 )
        DeleteObject(*(HGDIOBJ *)(a1 + 76));
    }
    *(_DWORD *)(a1 + 76) = v4;
    result = (HFONT)TBRecalc(a1);
  }
  return result;
}

//----- (6F779A2E) --------------------------------------------------------
signed int __stdcall InitToolbarClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.cbClsExtra = 0;
  WndClass.hIcon = 0;
  WndClass.lpfnWndProc = (WNDPROC)ToolbarWndProc;
  WndClass.lpszClassName = L"ToolbarWindow32";
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = a1;
  WndClass.lpszMenuName = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = (HBRUSH)16;
  RegisterClassW(&WndClass);
  return 1;
}

//----- (6F779B10) --------------------------------------------------------
int __stdcall TBReallocButtons(SIZE_T uBytes, int a2)
{
  SIZE_T v2; // esi@1
  int v3; // edi@3
  HLOCAL v4; // eax@4
  int result; // eax@6

  v2 = uBytes;
  if ( uBytes
    && *(_DWORD *)(uBytes + 100)
    && (v3 = *(_DWORD *)(uBytes + 52), ULongLongToULong(28i64 * (unsigned int)a2, &uBytes) >= 0)
    && (v4 = CCLocalReAlloc(*(HLOCAL *)(v2 + 48), uBytes)) != 0 )
  {
    if ( v3 )
      *(_DWORD *)(v2 + 52) = (char *)v4 + v3 - *(_DWORD *)(v2 + 48);
    *(_DWORD *)(v2 + 48) = v4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F779B6A) --------------------------------------------------------
int __stdcall TBInputStruct(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)a2 = *(_DWORD *)a3;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
  *(_BYTE *)(a2 + 8) = *(_BYTE *)(a3 + 8);
  *(_BYTE *)(a2 + 9) = *(_BYTE *)(a3 + 9);
  *(_WORD *)(a2 + 10) = 0;
  if ( *(_DWORD *)(a1 + 100) < 0x14u )
  {
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = -1;
  }
  else
  {
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);
  }
  return result;
}

//----- (6F779BDC) --------------------------------------------------------
int __stdcall TBInsertButtons(SIZE_T uBytes, int a2, int ulAddend, LPCWSTR lpString, int a5)
{
  SIZE_T v5; // ebx@1
  int v6; // esi@1
  unsigned int v7; // ecx@3
  signed int v8; // eax@5
  int v9; // edx@6
  int v10; // eax@6
  LPCWSTR v11; // edi@11
  int v12; // edi@11
  SIZE_T v13; // eax@12
  int v14; // esi@13
  const CHAR *v15; // ecx@13
  HWND v16; // ecx@15
  bool v17; // zf@17
  int result; // eax@27
  const WCHAR *v19; // ST0C_4@34
  int v20; // eax@35
  const void *v21; // esi@39
  void *v22; // edi@39
  HWND v23; // eax@49
  int v24; // [sp-1Ch] [bp-5Ch]@25
  int v25; // [sp-18h] [bp-58h]@25
  int v26; // [sp-10h] [bp-50h]@25
  LPARAM lParam; // [sp+8h] [bp-38h]@49
  int v28; // [sp+Ch] [bp-34h]@49
  HWND v29; // [sp+10h] [bp-30h]@49
  int v30; // [sp+14h] [bp-2Ch]@49
  int v31; // [sp+2Ch] [bp-14h]@49
  int v32; // [sp+34h] [bp-Ch]@5
  int v33; // [sp+38h] [bp-8h]@1
  int v34; // [sp+3Ch] [bp-4h]@10

  v33 = -1;
  v5 = uBytes;
  v6 = ulAddend;
  if ( ULongAdd(*(_DWORD *)(uBytes + 132), ulAddend, &uBytes) >= 0 && TBReallocButtons(v5, uBytes) )
  {
    v7 = *(_DWORD *)(v5 + 132);
    if ( a2 > v7 )
      a2 = *(_DWORD *)(v5 + 132);
    v8 = *(_DWORD *)(v5 + 204);
    v32 = v6;
    if ( v8 >= 0 && v8 < (signed int)v7 )
      v33 = *(_DWORD *)(28 * v8 + *(_DWORD *)(v5 + 48) + 4);
    v9 = 28 * v7 + *(_DWORD *)(v5 + 48) - 28;
    v10 = v9 + 28 * v6;
    uBytes = v9 + 28 * v6;
    a2 = v7 - a2;
    if ( a2 )
    {
      do
      {
        v21 = (const void *)v9;
        v22 = (void *)v10;
        v9 -= 28;
        v10 -= 28;
        v17 = a2-- == 1;
        qmemcpy(v22, v21, 0x1Cu);
      }
      while ( !v17 );
      v6 = ulAddend;
      uBytes = v10;
    }
    v34 = (*(_DWORD *)(v5 + 92) || *(_BYTE *)(v5 + 236) & 8)
       && (*(_DWORD *)(v5 + 8) & 0x1000
        || g_cyEdge + *(_DWORD *)(v5 + 108) + *(_DWORD *)(v5 + 152) < *(_DWORD *)(v5 + 116));
    v11 = lpString;
    *(_DWORD *)(v5 + 132) += v6;
    v12 = (int)((char *)v11 + *(_DWORD *)(v5 + 100) * (v6 - 1));
    if ( v6 )
    {
      while ( 1 )
      {
        TBInputStruct(v5, v10, v12);
        v13 = uBytes;
        if ( *(_BYTE *)(uBytes + 9) & 1 )
          *(_DWORD *)(uBytes + 16) = -1;
        v14 = v13 + 16;
        v15 = *(const CHAR **)(v13 + 16);
        if ( v15 != (const CHAR *)-1 && (unsigned int)v15 & 0xFFFF0000 )
        {
          lpString = *(LPCWSTR *)(v13 + 16);
          if ( !a5 )
            lpString = (LPCWSTR)ProduceWFromA(*(_DWORD *)(v5 + 20), v15);
          v19 = lpString;
          *(_DWORD *)v14 = 0;
          Str_Set(v14, v19);
          if ( !a5 )
            FreeProducedString((HLOCAL)lpString);
          v20 = *(_DWORD *)(v5 + 236);
          if ( !(v20 & 8) )
            v34 = 1;
          *(_DWORD *)(v5 + 236) = v20 | 8;
          v13 = uBytes;
        }
        v16 = *(HWND *)(v5 + 64);
        if ( v16 && !(*(_BYTE *)(v12 + 9) & 1) )
        {
          v23 = *(HWND *)v5;
          v31 = -1;
          v29 = v23;
          v30 = *(_DWORD *)(v12 + 4);
          lParam = 44;
          v28 = 0;
          SendMessageW(v16, 0x432u, 0, (LPARAM)&lParam);
          v13 = uBytes;
        }
        if ( *(_BYTE *)(v13 + 9) & 1 && *(_DWORD *)v13 <= 0 )
          *(_DWORD *)v13 = 8;
        v12 -= *(_DWORD *)(v5 + 100);
        v17 = ulAddend-- == 1;
        uBytes = v13 - 28;
        if ( v17 )
          break;
        v10 = uBytes;
      }
    }
    if ( *(_BYTE *)(v5 + 36) & 2 || *(_DWORD *)(v5 + 8) & 0x200 )
      TBAutoSize((HWND)v5);
    TBInvalidateItemRects(v5);
    if ( v34 && !*(_DWORD *)(v5 + 72) )
      TBRecalc(v5);
    if ( v32 == 1 )
    {
      v26 = a2 + 1;
      v25 = *(_DWORD *)v5;
      v24 = 0x8000;
    }
    else
    {
      v26 = 0;
      v25 = *(_DWORD *)v5;
      v24 = 32772;
    }
    MyNotifyWinEvent(v24, v25, -4, v26);
    if ( v33 != -1 )
      *(_DWORD *)(v5 + 204) = PositionFromID(v5, v33);
    TBInvalidateItemRects(v5);
    InvalidateRect(*(HWND *)v5, 0, 1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F779D8E) --------------------------------------------------------
int __stdcall TBOnButtonStructSize(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
  {
    if ( !*(_DWORD *)(a1 + 132) )
      *(_DWORD *)(a1 + 100) = a2;
  }
  return result;
}

//----- (6F779ED2) --------------------------------------------------------
int __stdcall TBAddBitmapToImageList(HANDLE h, int a2)
{
  int v2; // edi@1
  struct _IMAGELIST *v3; // eax@2
  struct _IMAGELIST *v4; // esi@2
  COLORREF v5; // eax@4
  HINSTANCE v6; // eax@6
  HBITMAP v7; // eax@7
  signed int v8; // ebx@9
  int v9; // ecx@11
  HBITMAP v10; // eax@13
  void *v11; // esi@13
  char pv; // [sp+Ch] [bp-20h]@9
  int v14; // [sp+10h] [bp-1Ch]@9
  int v15; // [sp+14h] [bp-18h]@10
  HIMAGELIST himl; // [sp+24h] [bp-8h]@1
  HGDIOBJ ho; // [sp+28h] [bp-4h]@1
  HANDLE ha; // [sp+34h] [bp+8h]@8

  v2 = (int)h;
  ho = 0;
  himl = (HIMAGELIST)TBGetImageList((int)h, 0, 0);
  if ( himl )
    goto LABEL_6;
  v3 = ImageList_Create(*((_DWORD *)h + 26), *((_DWORD *)h + 27), 0xFFu, 4, 4);
  v4 = v3;
  himl = v3;
  if ( v3 )
  {
    TBSetImageList((int)h, 0, 0, (int)v3);
    if ( *((_DWORD *)h + 2) & 0x8000 )
      v5 = -1;
    else
      v5 = g_clrBtnFace;
    ImageList_SetBkColor(v4, v5);
LABEL_6:
    v6 = *(HINSTANCE *)(a2 + 4);
    if ( v6 )
    {
      v7 = CreateMappedBitmap(v6, *(_DWORD *)(a2 + 8), 4u, 0, 0);
      ho = v7;
    }
    else
    {
      v7 = *(HBITMAP *)(a2 + 8);
      if ( !v7 )
        return 1;
    }
    ha = v7;
    if ( v7 )
    {
      GetObjectW(v7, 24, &pv);
      v8 = *(_DWORD *)(v2 + 104);
      if ( v14 < v8 )
        v14 = *(_DWORD *)(v2 + 104);
      if ( v15 < *(_DWORD *)(v2 + 108) )
        v15 = *(_DWORD *)(v2 + 108);
      v9 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 )
      {
        if ( v9 > v14 / v8 )
          v14 = v8 * v9;
      }
      else
      {
        v14 = v8;
      }
      v10 = _CopyBitmap(v2, ha, (BITMAP *)&pv);
      v11 = v10;
      if ( v10 )
      {
        ImageList_AddMasked(himl, v10, g_clrBtnFace);
        DeleteObject(v11);
      }
    }
    if ( ho )
      DeleteObject(ho);
    return 1;
  }
  return 0;
}

//----- (6F779FE3) --------------------------------------------------------
HBITMAP __stdcall _CopyBitmap(int a1, HGDIOBJ h, BITMAP *pbm)
{
  HBITMAP v3; // edi@1
  HDC v4; // eax@1
  BITMAP *v5; // esi@4
  int v6; // edx@5
  int v7; // eax@5
  WORD v8; // ax@8
  HBITMAP v9; // eax@9
  unsigned __int32 v11; // eax@17
  signed __int16 v12; // [sp-4h] [bp-444h]@7
  BITMAPINFO bmi; // [sp+Ch] [bp-434h]@5
  HDC hdc; // [sp+434h] [bp-Ch]@1
  HDC v15; // [sp+438h] [bp-8h]@1
  HDC hdcSrc; // [sp+43Ch] [bp-4h]@1

  v3 = 0;
  hdc = GetDC(*(HWND *)a1);
  hdcSrc = CreateCompatibleDC(hdc);
  v4 = CreateCompatibleDC(hdc);
  v15 = v4;
  if ( hdc )
  {
    if ( !hdcSrc || !v4 )
      goto LABEL_11;
    SelectObject(hdcSrc, h);
    v5 = pbm;
    if ( pbm->bmBits )
    {
      v6 = pbm->bmPlanes;
      memset(&bmi, 0, 0x28u);
      bmi.bmiHeader.biWidth = pbm->bmWidth;
      bmi.bmiHeader.biHeight = pbm->bmHeight;
      bmi.bmiHeader.biPlanes = 1;
      v7 = v6 * pbm->bmBitsPixel;
      bmi.bmiHeader.biSize = 40;
      if ( (unsigned int)v7 <= 1 )
      {
        v8 = 1;
        goto LABEL_9;
      }
      if ( (unsigned int)v7 <= 4 )
      {
        v12 = 4;
LABEL_8:
        v8 = v12;
LABEL_9:
        bmi.bmiHeader.biBitCount = v8;
        bmi.bmiHeader.biClrUsed = GetDIBColorTable(hdcSrc, 0, 1 << v8, bmi.bmiColors);
        v9 = CreateDIBSection(hdc, &bmi, 0, &h, 0, 0);
LABEL_10:
        v3 = v9;
        SelectObject(v15, v9);
        PatB(v15, 0, 0, v5->bmWidth, v5->bmHeight, g_clrBtnFace);
        BitBlt(v15, 0, 0, v5->bmWidth, v5->bmHeight, hdcSrc, 0, 0, 0xCC0020u);
LABEL_11:
        ReleaseDC(*(HWND *)a1, hdc);
        goto LABEL_12;
      }
      if ( (unsigned int)v7 <= 8 )
      {
        v12 = 8;
        goto LABEL_8;
      }
    }
    v11 = ((pbm->bmWidth * pbm->bmBitsPixel + 15) >> 3) & 0xFFFFFFFE;
    pbm->bmBits = 0;
    v5->bmWidthBytes = v11;
    v9 = CreateBitmapIndirect(v5);
    goto LABEL_10;
  }
LABEL_12:
  if ( hdcSrc )
    DeleteDC(hdcSrc);
  if ( v15 )
    DeleteDC(v15);
  return v3;
}

//----- (6F77A164) --------------------------------------------------------
__int32 __stdcall CImageList::SetBkColor(CImageList *this, COLORREF color, unsigned __int32 *a3)
{
  CImageList *v3; // ecx@1

  v3 = (CImageList *)*((_DWORD *)this + 111);
  if ( v3 )
    CImageList::_SetBkColor(v3, color);
  *a3 = CImageList::_SetBkColor((CImageList *)((char *)this - 8), color);
  return 0;
}

//----- (6F77A197) --------------------------------------------------------
COLORREF __stdcall ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk)
{
  COLORREF v2; // esi@1
  COLORREF v4; // [sp+4h] [bp-4h]@1

  v2 = clrBk;
  v4 = clrBk;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&clrBk) >= 0 )
  {
    (*(void (__stdcall **)(COLORREF, COLORREF, int *))(*(_DWORD *)clrBk + 80))(clrBk, v2, &v4);
    (*(void (__stdcall **)(COLORREF))(*(_DWORD *)clrBk + 8))(clrBk);
  }
  return v4;
}

//----- (6F77A245) --------------------------------------------------------
unsigned __int32 __stdcall GetNearestColor32(HDC hdc, COLORREF color)
{
  COLORREF v2; // edi@1
  COLORREF v3; // ebx@1

  v2 = GetPixel(hdc, 0, 0);
  v3 = SetPixel(hdc, 0, 0, color);
  SetPixelV(hdc, 0, 0, v2);
  return v3;
}

//----- (6F77A286) --------------------------------------------------------
int __stdcall AddBitmap(HANDLE h, SIZE_T uBytes, int a3, int a4)
{
  int v4; // ecx@5
  SIZE_T v5; // ebx@5
  int v6; // edx@6
  int result; // eax@6
  HLOCAL v8; // edi@14
  int v9; // eax@15
  int v10; // edi@15
  int v11; // edi@16

  if ( a3 == -1 )
  {
    if ( a4 & 1 )
      SetBitmapSize((int)h, 24, 24);
    else
      SetBitmapSize((int)h, 16, 16);
    MapToStandardBitmaps((unsigned int)&a3, (unsigned int *)&a4, (unsigned int)&uBytes);
  }
  v4 = *((_DWORD *)h + 21);
  v5 = uBytes;
  if ( v4 )
  {
    v6 = *((_DWORD *)h + 20);
    result = 0;
    while ( v6 > 0 )
    {
      if ( *(_DWORD *)(v4 + 4) == a3 && *(_DWORD *)(v4 + 8) == a4 )
      {
        if ( *(_DWORD *)v4 >= (signed int)uBytes )
          return result;
        if ( v6 == 1 )
        {
          *(_DWORD *)v4 = uBytes;
          return result;
        }
      }
      result += *(_DWORD *)v4;
      --v6;
      v4 += 12;
    }
  }
  if ( ULongAdd(*((_DWORD *)h + 20), 1u, &uBytes) >= 0
    && ULongLongToULong(12i64 * uBytes, &uBytes) >= 0
    && (v8 = CCLocalReAlloc(*((HLOCAL *)h + 21), uBytes)) != 0
    && (v9 = 12 * *((_DWORD *)h + 20),
        *((_DWORD *)h + 21) = v8,
        v10 = (int)((char *)v8 + v9),
        *(_DWORD *)(v10 + 4) = a3,
        *(_DWORD *)(v10 + 8) = a4,
        *(_DWORD *)v10 = v5,
        TBAddBitmapToImageList(h, v10)) )
  {
    ++*((_DWORD *)h + 20);
    v11 = v10 - 12;
    for ( result = 0; (unsigned int)v11 >= *((_DWORD *)h + 21); v11 -= 12 )
      result += *(_DWORD *)v11;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F77A3D3) --------------------------------------------------------
signed int __stdcall InitTrackBar(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = (WNDPROC)TrackBarWndProc;
  WndClass.lpszClassName = L"msctls_trackbar32";
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 0x4000;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F77A434: using guessed type wchar_t s_szSTrackBarClass[18];

//----- (6F77A45D) --------------------------------------------------------
signed int __stdcall InitStatusClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.cbClsExtra = 0;
  WndClass.hIcon = 0;
  WndClass.lpfnWndProc = (WNDPROC)StatusWndProc;
  WndClass.style = 16393;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = a1;
  WndClass.lpszMenuName = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.lpszClassName = L"msctls_statusbar32";
  RegisterClassW(&WndClass);
  return 1;
}

//----- (6F77A501) --------------------------------------------------------
void __stdcall TBSetStyle(HWND hWndTo, int a2)
{
  int v2; // edx@1
  signed int v3; // edi@1
  int i; // ecx@4

  v2 = 0;
  v3 = 0;
  if ( (a2 ^ *((_DWORD *)hWndTo + 2)) & 0x200 )
  {
    v3 = 1;
    for ( i = 0; i < *((_DWORD *)hWndTo + 33); v2 += 28 )
    {
      *(_BYTE *)(*((_DWORD *)hWndTo + 12) + v2 + 8) &= 0xDFu;
      ++i;
    }
  }
  *((_DWORD *)hWndTo + 2) = a2;
  if ( v3 )
    TBRecalc((int)hWndTo);
  TBAutoSize(hWndTo);
}

//----- (6F77A540) --------------------------------------------------------
signed int __stdcall InitToolTipsClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+4h] [bp-28h]@1

  WndClass.lpfnWndProc = (WNDPROC)ToolTipsWndProc;
  WndClass.lpszClassName = L"tooltips_class32";
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.hbrBackground = 0;
  WndClass.style = 18440;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}

//----- (6F77A5DD) --------------------------------------------------------
HBITMAP __stdcall CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap, UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HRSRC v5; // eax@1
  HGLOBAL v6; // eax@2
  LPVOID v7; // eax@3
  LPVOID v8; // ebx@3
  HGLOBAL v9; // eax@6
  signed int v10; // edi@8
  int v11; // ST30_4@9
  char *v12; // eax@12
  signed int v13; // ecx@12
  int v14; // edi@13
  int v15; // edx@13
  int v16; // eax@14
  int v17; // ecx@15
  int v18; // edi@19
  INT_PTR v19; // eax@19
  int v20; // ebx@19
  HBITMAP v21; // eax@24
  HBITMAP result; // eax@29
  signed int v23; // ecx@35
  int v24; // [sp+4h] [bp-10Ch]@12
  int v25[31]; // [sp+8h] [bp-108h]@31
  int v26; // [sp+84h] [bp-8Ch]@8
  int v27[11]; // [sp+88h] [bp-88h]@9
  int Src[16]; // [sp+B4h] [bp-5Ch]@35
  void *ppvBits; // [sp+F4h] [bp-1Ch]@24
  HGLOBAL hResData; // [sp+F8h] [bp-18h]@2
  void *Dst; // [sp+FCh] [bp-14h]@14
  void *lpBits; // [sp+100h] [bp-10h]@19
  UINT v33; // [sp+104h] [bp-Ch]@14
  HGDIOBJ h; // [sp+108h] [bp-8h]@1
  int v35; // [sp+10Ch] [bp-4h]@11
  HINSTANCE hInstancea; // [sp+118h] [bp+8h]@6

  h = 0;
  v5 = FindResourceW(hInstance, (LPCWSTR)(unsigned __int16)idBitmap, (LPCWSTR)2);
  if ( v5 && (v6 = LoadResource(hInstance, v5), (hResData = v6) != 0) )
  {
    v7 = LockResource(v6);
    v8 = v7;
    if ( v7 )
    {
      if ( ULongLongToULong(4i64 * (unsigned int)(1 << *((_BYTE *)v7 + 14)), (ULONG *)&idBitmap) >= 0
        && ULongAdd(*(_DWORD *)v8, idBitmap, (ULONG *)&idBitmap) >= 0 )
      {
        v9 = GlobalAlloc(0x40u, idBitmap);
        hInstancea = (HINSTANCE)v9;
        if ( v9 )
        {
          memmove(v9, v8, idBitmap);
          if ( !lpColorMap )
          {
            lpColorMap = (LPCOLORMAP)&v26;
            iNumMaps = 6;
            v10 = 0;
            do
            {
              v11 = dword_6F77A86C[v10];
              *(int *)((char *)&v26 + v10 * 4) = dword_6F77A868[v10];
              v27[v10] = GetSysColor(v11);
              v10 += 2;
            }
            while ( v10 < 12 );
          }
          if ( iNumMaps > 16 )
            iNumMaps = 16;
          v35 = 0;
          if ( iNumMaps > 0 )
          {
            v12 = (char *)&lpColorMap->to;
            v13 = (char *)&v24 - (char *)lpColorMap;
            do
            {
              v14 = (unsigned __int8)*(v12 - 3);
              *(_DWORD *)&v12[v13] = (unsigned __int8)v12[2] | ((((unsigned __int8)*v12 << 8) | (unsigned __int8)v12[1]) << 8);
              v15 = v35;
              *(&v24 + 2 * v35) = (unsigned __int8)*(v12 - 2) | ((((unsigned __int8)*(v12 - 4) << 8) | v14) << 8);
              v12 += 8;
              v35 = v15 + 1;
            }
            while ( v15 + 1 < iNumMaps );
          }
          v16 = (int)((char *)hInstancea + *(_DWORD *)hInstancea);
          Dst = (char *)hInstancea + *(_DWORD *)hInstancea;
          v35 = 16;
          v33 = wFlags & 2;
          if ( wFlags & 2 )
          {
            v23 = 0;
            lpColorMap = (LPCOLORMAP)(v16 - (_DWORD)Src);
            do
            {
              if ( *(COLORREF *)((char *)&lpColorMap->from + 4 * v23 + (_DWORD)Src) == 16711935 )
                Src[v23] = 0xFFFFFF;
              else
                Src[v23] = 0;
              ++v23;
            }
            while ( v23 < 16 );
          }
          do
          {
            --v35;
            v17 = 0;
            if ( iNumMaps > 0 )
            {
              while ( (*(_DWORD *)v16 & 0xFFFFFF) != *(&v24 + 2 * v17) )
              {
                ++v17;
                if ( v17 >= iNumMaps )
                  goto LABEL_18;
              }
              *(_DWORD *)v16 = v25[2 * v17];
            }
LABEL_18:
            v16 += 4;
          }
          while ( v35 > 0 );
          v18 = *((_DWORD *)v8 + 1);
          v19 = (INT_PTR)((char *)v8 + idBitmap);
          v20 = *((_DWORD *)v8 + 2);
          lpBits = (void *)v19;
          v35 = v18;
          lpColorMap = (LPCOLORMAP)v20;
          idBitmap = (INT_PTR)GetDC(0);
          iNumMaps = (int)CreateCompatibleDC((HDC)idBitmap);
          if ( iNumMaps )
          {
            if ( v33 )
              v35 = 2 * v18;
            if ( wFlags & 4 )
            {
              wFlags = *((_DWORD *)hInstancea + 4);
              if ( wFlags != 3 )
                *((_DWORD *)hInstancea + 4) = 0;
              v21 = CreateDIBSection((HDC)idBitmap, (const BITMAPINFO *)hInstancea, 0, &ppvBits, 0, 0);
              h = v21;
              *((_DWORD *)hInstancea + 4) = wFlags;
              if ( v21 )
                goto LABEL_47;
            }
            h = CreateCompatibleBitmap((HDC)idBitmap, v35, v20);
            if ( h )
            {
LABEL_47:
              wFlags = (UINT)SelectObject((HDC)iNumMaps, h);
              StretchDIBits(
                (HDC)iNumMaps,
                0,
                0,
                v18,
                v20,
                0,
                0,
                v18,
                v20,
                lpBits,
                (const BITMAPINFO *)hInstancea,
                0,
                0xCC0020u);
              if ( v33 )
              {
                memmove(Dst, Src, 0x40u);
                StretchDIBits(
                  (HDC)iNumMaps,
                  v18,
                  0,
                  v18,
                  (int)lpColorMap,
                  0,
                  0,
                  v18,
                  (int)lpColorMap,
                  lpBits,
                  (const BITMAPINFO *)hInstancea,
                  0,
                  0xCC0020u);
                BitBlt((HDC)iNumMaps, 0, 0, v18, (int)lpColorMap, (HDC)iNumMaps, v18, 0, 0x220326u);
              }
              SelectObject((HDC)iNumMaps, (HGDIOBJ)wFlags);
            }
            DeleteObject((HGDIOBJ)iNumMaps);
          }
          ReleaseDC(0, (HDC)idBitmap);
          GlobalFree(hInstancea);
        }
      }
      FreeResource(hResData);
      result = (HBITMAP)h;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F77A5DD: could not find valid save-restore pair for ebx
// 6F77A868: using guessed type int dword_6F77A868[];
// 6F77A86C: using guessed type int dword_6F77A86C[];
// 6F77A5DD: using guessed type int var_88[11];
// 6F77A5DD: using guessed type int var_108[31];
// 6F77A5DD: using guessed type int Src[16];

//----- (6F77A8AF) --------------------------------------------------------
unsigned int __stdcall MapToStandardBitmaps(unsigned int a1, unsigned int *a2, unsigned int a3)
{
  unsigned int result; // eax@1

  result = a1;
  if ( *(_DWORD *)a1 == -1 )
  {
    *(_DWORD *)a1 = g_hinst;
    result = *a2;
    if ( *a2 > 3 )
    {
      if ( result <= 7 )
      {
        *a2 = (result & 1) + 124;
        result = a3;
        *(_DWORD *)a3 = 12;
      }
      else if ( result <= 9 )
      {
        *a2 = (result & 1) + 130;
        result = a3;
        *(_DWORD *)a3 = 5;
      }
    }
    else
    {
      *a2 = (result & 1) + 120;
      result = a3;
      *(_DWORD *)a3 = 15;
    }
  }
  return result;
}

//----- (6F77A8EC) --------------------------------------------------------
int __stdcall TBAddStrings(int a1, HINSTANCE hInstance, void *Src)
{
  void *v3; // eax@3
  int v4; // ecx@3
  size_t v6; // esi@9
  HLOCAL v7; // eax@9
  WCHAR *v8; // edi@9
  int v9; // esi@11
  HLOCAL v10; // eax@13
  int v11; // ecx@14
  int v12; // ebx@14
  HINSTANCE v13; // eax@14
  int v14; // eax@16
  bool v15; // zf@16
  int v16; // edi@18
  int v17; // esi@22
  HLOCAL v18; // eax@24
  int v19; // esi@26
  WCHAR v20; // cx@26
  int i; // eax@26
  HLOCAL v22; // eax@34
  HLOCAL hMem; // [sp+Ch] [bp-4h]@11
  int v24; // [sp+18h] [bp+8h]@15
  HINSTANCE hInstancea; // [sp+1Ch] [bp+Ch]@3

  if ( hInstance )
  {
    v8 = (WCHAR *)LocalAlloc(0x40u, 0x800u);
    if ( !v8 )
      return -1;
    v17 = LoadStringW(hInstance, (unsigned __int16)Src, v8, 1024);
    if ( !v17 )
    {
      LocalFree(v8);
      return -1;
    }
    v18 = LocalReAlloc(v8, 2 * v17 + 2, 2u);
    if ( v18 )
      v8 = (WCHAR *)v18;
    v19 = v17 - 1;
    v20 = *v8;
    hInstancea = 0;
    for ( i = (int)(v8 + 1); v19; i += 2 )
    {
      if ( *(_WORD *)i == v20 )
      {
        if ( v19 != 1 )
          hInstancea = (HINSTANCE)((char *)hInstancea + 1);
        *(_WORD *)i = 0;
      }
      *(_WORD *)(i - 2) = *(_WORD *)i;
      --v19;
    }
  }
  else
  {
    if ( !((unsigned int)Src & 0xFFFF0000) )
      return -1;
    v3 = Src;
    v4 = 0;
    hInstancea = 0;
    while ( 1 )
    {
      ++v4;
      if ( !*(_WORD *)v3 )
      {
        hInstancea = (HINSTANCE)((char *)hInstancea + 1);
        if ( !*((_WORD *)v3 + 1) )
          break;
      }
      v3 = (char *)v3 + 2;
    }
    v6 = 2 * v4;
    v7 = LocalAlloc(0x40u, 2 * v4);
    v8 = (WCHAR *)v7;
    if ( !v7 )
      return -1;
    memmove(v7, Src, v6);
  }
  v9 = a1;
  hMem = v8;
  if ( ULongAdd(*(_DWORD *)(a1 + 92), (ULONG)hInstancea, (ULONG *)&Src) < 0
    || ULongLongToULong(4i64 * (unsigned int)Src, (ULONG *)&Src) < 0
    || (v10 = CCLocalReAlloc(*(HLOCAL *)(a1 + 88), (SIZE_T)Src)) == 0 )
  {
LABEL_6:
    LocalFree(hMem);
    return -1;
  }
  v11 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 88) = v10;
  v12 = (int)((char *)v10 + 4 * v11);
  v13 = hInstancea;
  if ( (signed int)hInstancea > 0 )
  {
    v24 = (int)hInstancea;
    do
    {
      *(_DWORD *)v12 = v8;
      v14 = lstrlenW(v8);
      v12 += 4;
      v15 = v24-- == 1;
      v8 += v14 + 1;
    }
    while ( !v15 );
    v13 = hInstancea;
  }
  v16 = *(_DWORD *)(v9 + 92);
  *(_DWORD *)(v9 + 92) = (char *)v13 + v16;
  if ( !TBRecalc(v9) )
  {
    *(_DWORD *)(v9 + 92) -= hInstancea;
    if ( ULongLongToULong(4i64 * *(_DWORD *)(v9 + 92), (ULONG *)&Src) >= 0 )
    {
      v22 = CCLocalReAlloc(*(HLOCAL *)(v9 + 88), (SIZE_T)Src);
      if ( v22 )
        *(_DWORD *)(v9 + 88) = v22;
    }
    goto LABEL_6;
  }
  return v16;
}

//----- (6F77B8A8) --------------------------------------------------------
int __stdcall TB_StrForButton(int a1, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 + 16);
  if ( result == -1 )
    goto LABEL_10;
  if ( result & 0xFFFF0000 )
    return result;
  if ( result == -1 || result >= *(_DWORD *)(a1 + 92) )
LABEL_10:
    result = 0;
  else
    result = *(_DWORD *)(*(_DWORD *)(a1 + 88) + 4 * result);
  return result;
}

//----- (6F77B918) --------------------------------------------------------
BOOL __stdcall TB_HasTopDDArrow(int a1, int a2)
{
  return !(*(_DWORD *)(a1 + 8) & 0x1000)
      && *(_BYTE *)(a2 + 9) & 0x80
      && *(_DWORD *)(a1 + 96) > 0
      && TB_StrForButton(a1, a2);
}

//----- (6F77B941) --------------------------------------------------------
HDC __stdcall TBPaint(HANDLE h, int a2)
{
  HDC result; // eax@1
  int v3; // esi@17
  COLORREF v4; // eax@18
  LPARAM lParam; // [sp+Ch] [bp-D8h]@1
  char Dst; // [sp+10h] [bp-D4h]@1
  HDC v7; // [sp+1Ch] [bp-C8h]@4
  struct tagRECT v8; // [sp+20h] [bp-C4h]@4
  int v9; // [sp+34h] [bp-B0h]@19
  int v10; // [sp+38h] [bp-ACh]@19
  int v11; // [sp+78h] [bp-6Ch]@17
  struct tagRECT Rect; // [sp+88h] [bp-5Ch]@1
  int v13; // [sp+98h] [bp-4Ch]@1
  HDC hdc; // [sp+9Ch] [bp-48h]@2
  struct tagPAINTSTRUCT Paint; // [sp+A0h] [bp-44h]@2

  v13 = a2;
  lParam = 0;
  memset(&Dst, 0, 0x68u);
  result = (HDC)GetClientRect(*(HWND *)h, &Rect);
  if ( a2 )
  {
    hdc = (HDC)a2;
  }
  else
  {
    result = BeginPaint(*(HWND *)h, &Paint);
    hdc = result;
  }
  if ( Rect.right )
  {
    v7 = hdc;
    v8 = Rect;
    result = (HDC)CICustomDrawNotify((int)h, 1, (LPARAM)&lParam);
    *((_DWORD *)h + 3) = result;
    if ( !((unsigned __int8)result & 4) )
    {
      if ( !(*((_BYTE *)h + 236) & 1) )
        TBBuildImageList(h);
      if ( *((_BYTE *)h + 36) & 4 )
        DrawToolbarV((int)h, hdc, &Rect);
      else
        DrawToolbarH((HDC)h, hdc, &Rect);
      if ( *((_DWORD *)h + 53) != -1 )
      {
        v3 = ~(unsigned __int8)(*((_DWORD *)h + 2) >> 7) & 1;
        if ( GetInsertMarkRect((HDC)h, (int)&v11, v3) )
        {
          v4 = TB_GetInsertMarkColor((int)h);
          DrawInsertMark(hdc, (int)&v11, v3, v4);
        }
      }
      result = (HDC)ReleaseMonoDC((int)h);
    }
    if ( *((_BYTE *)h + 12) & 0x10 )
    {
      v9 = 0;
      v10 = 0;
      v7 = hdc;
      result = (HDC)CICustomDrawNotify((int)h, 2, (LPARAM)&lParam);
    }
  }
  if ( !v13 )
    result = (HDC)EndPaint(*(HWND *)h, &Paint);
  return result;
}

//----- (6F77BA39) --------------------------------------------------------
int __stdcall DrawToolbarH(HDC hDC, HDC hdc, LPRECT lprc)
{
  LPRECT v3; // esi@1
  HDC v4; // edi@1
  int v5; // edx@1
  LONG v6; // ecx@1
  int result; // eax@1
  int v8; // ecx@4
  bool v9; // zf@4
  int v10; // eax@12
  int v11; // ecx@13
  int v12; // eax@17
  int v13; // eax@19
  int v14; // eax@22
  RECT rcSrc; // [sp+8h] [bp-24h]@22
  LONG v16; // [sp+18h] [bp-14h]@1
  int v17; // [sp+1Ch] [bp-10h]@4
  LONG v18; // [sp+20h] [bp-Ch]@17
  int v19; // [sp+24h] [bp-8h]@1
  int yTop; // [sp+28h] [bp-4h]@1
  int hDCa; // [sp+34h] [bp+8h]@2
  int lprca; // [sp+3Ch] [bp+10h]@1

  v19 = 0;
  v3 = lprc;
  v4 = hDC;
  v5 = *((_DWORD *)hDC + 12);
  v16 = lprc->right - lprc->left;
  v6 = *((_DWORD *)hDC + 32);
  lprc->top = v6;
  yTop = v6;
  lprc->bottom = *((_DWORD *)hDC + 32) + *((_DWORD *)hDC + 29);
  result = *((_DWORD *)hDC + 36);
  lprca = *((_DWORD *)hDC + 36);
  if ( *((_DWORD *)hDC + 33) > 0 )
  {
    hDCa = v5;
    do
    {
      if ( !(*(_BYTE *)(hDCa + 8) & 8) )
      {
        v8 = TBWidthOfButton((int)InflateRect, v4, hDCa, hdc);
        v9 = (*(_BYTE *)(hDCa + 9) & 1) == 0;
        v17 = v8;
        if ( v9 || *((_DWORD *)v4 + 2) & 0x800 )
        {
          v3->left = lprca;
          v3->right = lprca + v8;
          if ( TBShouldDrawButton((int)v4, v3, hdc) )
          {
            if ( *(_BYTE *)(hDCa + 9) & 1 )
            {
              if ( *((_BYTE *)v4 + 8) & 0x80 )
              {
                v18 = v3->top;
                v12 = TBGetSepHeight((int)v4, (int *)hDCa);
                v3->top = v18 + (v12 - 1) / 2;
                InflateRect(v3, -g_cxEdge, 0);
                CCDrawEdge(hdc, v3, 6, 2, (int)(v4 + 46));
                InflateRect(v3, g_cxEdge, 0);
                v3->top = v18;
              }
              else
              {
                v3->left += (v17 - 1) / 2;
                InflateRect(v3, 0, -g_cyEdge);
                CCDrawEdge(hdc, v3, 6, 1, (int)(v4 + 46));
                InflateRect(v3, 0, g_cyEdge);
              }
            }
            else
            {
              DrawButton((int)InflateRect, hdc, lprca, yTop, v4, hDCa, (*((_DWORD *)v4 + 59) >> 6) & 1);
            }
          }
        }
        lprca += v17;
        if ( *(_BYTE *)(hDCa + 8) & 0x20 )
        {
          if ( *(_BYTE *)(hDCa + 9) & 1 )
          {
            v13 = *((_DWORD *)v4 + 2);
            if ( (char)v13 >= 0 )
            {
              if ( v13 & 0x800 )
              {
                v14 = *((_DWORD *)v4 + 29) + (TBGetSepHeight((int)v4, (int *)hDCa) - 1) / 2;
                rcSrc.left = g_cxEdge;
                rcSrc.top = v3->top + v14;
                rcSrc.bottom = g_cxEdge + rcSrc.top;
                rcSrc.right = v16 - g_cxEdge;
                CCDrawEdge(hdc, &rcSrc, 6, 2, (int)(v4 + 46));
              }
              v10 = *((_DWORD *)v4 + 29) + TBGetSepHeight((int)v4, (int *)hDCa);
            }
            else
            {
              v10 = TBGetSepHeight((int)v4, (int *)hDCa);
            }
          }
          else
          {
            v10 = *((_DWORD *)v4 + 29);
          }
          v11 = *((_DWORD *)v4 + 36);
          yTop += v10;
          v3->top += v10;
          v3->bottom += v10;
          lprca = v11;
        }
      }
      ++v19;
      result = v19;
      hDCa += 28;
    }
    while ( v19 < *((_DWORD *)v4 + 33) );
  }
  return result;
}

//----- (6F77BB2A) --------------------------------------------------------
int __userpurge DrawButton@<eax>(int a1@<ebx>, HDC a2, int xLeft, int yTop, HDC hDC, int a6, int a7)
{
  signed int v7; // ebx@1
  LPCWSTR v8; // ecx@4
  int result; // eax@5
  int v10; // ebx@6
  HGDIOBJ v11; // eax@8
  COLORREF v12; // eax@9
  bool v13; // zf@9
  int v14; // ecx@11
  signed int v15; // eax@12
  signed int v16; // eax@16
  int v17; // eax@17
  HGDIOBJ v18; // eax@18
  int v19; // eax@22
  int v20; // eax@25
  COLORREF v21; // eax@42
  int v22; // eax@46
  int v23; // eax@68
  HFONT v24; // eax@70
  int v25; // edi@91
  int v26; // edi@91
  int v27; // eax@92
  int v28; // ecx@92
  LPARAM v29; // [sp+Ch] [bp-160h]@84
  char v30; // [sp+10h] [bp-15Ch]@84
  int v31; // [sp+18h] [bp-154h]@84
  int v32; // [sp+24h] [bp-148h]@84
  WCHAR chText[2]; // [sp+30h] [bp-13Ch]@1
  char Dst; // [sp+34h] [bp-138h]@1
  int v35; // [sp+38h] [bp-134h]@6
  int v36; // [sp+3Ch] [bp-130h]@5
  int v37; // [sp+40h] [bp-12Ch]@23
  int v38; // [sp+44h] [bp-128h]@22
  unsigned int v39; // [sp+48h] [bp-124h]@5
  LPARAM lParam; // [sp+4Ch] [bp-120h]@5
  HDC v41; // [sp+5Ch] [bp-110h]@3
  struct tagRECT rc; // [sp+60h] [bp-10Ch]@3
  int v43; // [sp+70h] [bp-FCh]@3
  int v44; // [sp+74h] [bp-F8h]@3
  int v45; // [sp+78h] [bp-F4h]@3
  HGDIOBJ v46; // [sp+7Ch] [bp-F0h]@38
  COLORREF color; // [sp+88h] [bp-E4h]@9
  COLORREF v48; // [sp+8Ch] [bp-E0h]@80
  COLORREF v49; // [sp+94h] [bp-D8h]@43
  COLORREF v50; // [sp+98h] [bp-D4h]@42
  COLORREF v51; // [sp+9Ch] [bp-D0h]@82
  int v52; // [sp+A0h] [bp-CCh]@6
  int v53; // [sp+A4h] [bp-C8h]@6
  int v54; // [sp+A8h] [bp-C4h]@6
  int v55; // [sp+ACh] [bp-C0h]@6
  int v56; // [sp+B8h] [bp-B4h]@17
  COLORREF v57; // [sp+BCh] [bp-B0h]@43
  int v58; // [sp+C0h] [bp-ACh]@92
  int v59; // [sp+C4h] [bp-A8h]@92
  int v60; // [sp+C8h] [bp-A4h]@92
  int v61; // [sp+CCh] [bp-A0h]@92
  COLORREF v62; // [sp+D0h] [bp-9Ch]@9
  HGDIOBJ h; // [sp+D4h] [bp-98h]@9
  int v64; // [sp+D8h] [bp-94h]@6
  HGDIOBJ ho; // [sp+DCh] [bp-90h]@1
  HGDIOBJ v66; // [sp+E0h] [bp-8Ch]@6
  int cy; // [sp+E4h] [bp-88h]@6
  int v68; // [sp+E8h] [bp-84h]@3
  COLORREF v69; // [sp+ECh] [bp-80h]@23
  int v70; // [sp+F0h] [bp-7Ch]@6
  HGDIOBJ v71; // [sp+F4h] [bp-78h]@40
  int v72; // [sp+F8h] [bp-74h]@1
  int v73; // [sp+FCh] [bp-70h]@1
  LPCWSTR lpchText; // [sp+100h] [bp-6Ch]@1
  int w; // [sp+104h] [bp-68h]@6
  HDC hdc; // [sp+108h] [bp-64h]@1
  char pv; // [sp+10Ch] [bp-60h]@69
  char v78; // [sp+126h] [bp-46h]@70
  int xLefta; // [sp+178h] [bp+Ch]@11
  int yTopa; // [sp+17Ch] [bp+10h]@11

  hdc = a2;
  v72 = a6;
  v73 = TBWidthOfButton(a1, hDC, a6, a2);
  lpchText = (LPCWSTR)*((_DWORD *)hDC + 29);
  *(_DWORD *)chText = 0;
  memset(&Dst, 0, 0x84u);
  ho = 0;
  v7 = *(_BYTE *)(a6 + 8);
  if ( v7 & 0x10 )
  {
    if ( v7 & 2 || !(v7 & 4) )
      v7 &= 0xFFFFFFEF;
    else
      v7 = 16;
  }
  if ( !a7 )
    v7 &= 0xFFFFFFFB;
  v68 = TBIsHotTrack((int)hDC, a6, v7);
  v44 = 0;
  v41 = hdc;
  v43 = *(_DWORD *)(a6 + 4);
  v45 = *(_DWORD *)(a6 + 12);
  SetRect(&rc, xLeft, yTop, xLeft + v73, (int)((char *)lpchText + yTop));
  if ( *((_BYTE *)hDC + 36) & 4 )
    v8 = lpchText;
  else
    v8 = &lpchText[-g_cyEdge];
  InitTBDrawItem((int)chText, (int)hDC, a6, v7, v68, v73 - 3 * g_cxEdge, (int)v8);
  v39 = CICustomDrawNotify((int)hDC, 65537, (LPARAM)&lParam);
  result = v44 & 0x40;
  v68 = v44 & 0x40;
  v36 = v44 & 0x40;
  if ( !(v39 & 4) )
  {
    v35 = StateFromCDIS(v44);
    v70 = v35;
    v10 = v54 - v52;
    w = v73 - 2 * g_cxEdge;
    cy = (int)&lpchText[-g_cyEdge];
    v64 = v54 - v52;
    v66 = (HGDIOBJ)(v55 - v53);
    if ( TB_HasDDArrow((int)hDC, a6) && !TB_HasTopDDArrow((int)hDC, a6) )
    {
      v23 = TBDDArrowAdjustment(hDC, a6);
      w -= v23;
      v64 = v10 - v23;
    }
    if ( !(*((_DWORD *)hDC + 59) & 0x20000)
      && GetObjectW(*((HANDLE *)hDC + 19), 92, &pv)
      && (v78 = 3, v24 = CreateFontIndirectW((const LOGFONTW *)&pv), (ho = v24) != 0) )
      v11 = SelectObject(hdc, v24);
    else
      v11 = SelectObject(hdc, *((HGDIOBJ *)hDC + 19));
    h = v11;
    v12 = SetTextColor(hdc, color);
    v13 = (*((_DWORD *)hDC + 2) & 0x800) == 0;
    v62 = v12;
    if ( v13 )
      DrawBlankButton(hdc, xLeft, yTop, v73, (int)lpchText, (int)chText);
    xLefta = g_cxEdge + xLeft;
    v14 = *((_DWORD *)hDC + 9);
    yTopa = g_cyEdge + yTop;
    if ( v14 & 4 )
      v15 = *((_DWORD *)hDC + 29) - *((_DWORD *)hDC + 27);
    else
      v15 = *((_DWORD *)hDC + 38) - 2 * g_cyEdge;
    v73 = v15 / 2;
    if ( v15 / 2 < 0 )
      v73 = 0;
    if ( *((_DWORD *)hDC + 2) & 0x1000 && *((_DWORD *)hDC + 24) && (!(v14 & 8) || *(_BYTE *)(a6 + 9) & 0x40) )
    {
      v16 = *((_DWORD *)hDC + 37);
    }
    else if ( TB_HasTopDDArrow((int)hDC, a6) )
    {
      v16 = w + 2 * g_cxEdge - *((_DWORD *)hDC + 35) - *((_DWORD *)hDC + 26);
    }
    else
    {
      v16 = w - *((_DWORD *)hDC + 26);
    }
    v17 = v16 / 2;
    lpchText = (LPCWSTR)v17;
    v56 = v70 & 3;
    if ( v70 & 3 && !(v39 & 0x40000) )
    {
      ++v73;
      lpchText = (LPCWSTR)(v17 + 1);
    }
    v18 = 0;
    if ( (!v68 || *((_DWORD *)hDC + 7) < 5)
      && (v70 & 0x11 || v70 & 0x80 && !(*((_DWORD *)hDC + 2) & 0x800) && !(v39 & 0x80000)) )
    {
      if ( v46 )
        v18 = SelectObject(hdc, v46);
      v71 = v18;
      if ( v18 )
      {
        if ( v70 & 0x80 )
          v21 = SetTextColor(hdc, v48);
        else
          v21 = SetTextColor(hdc, v50);
        v69 = v21;
        v57 = SetBkColor(hdc, v49);
        PatBlt(hdc, xLefta, yTopa, w, cy, 0xF00021u);
        SelectObject(hdc, v71);
        SetTextColor(hdc, v69);
        SetBkColor(hdc, v57);
      }
    }
    if ( v39 & 0x20000 && v68 )
      PatB(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, v51);
    v19 = *(_DWORD *)v72;
    v38 = v19;
    if ( v19 == -1 && *((_BYTE *)hDC + 236) & 2 )
    {
      v29 = 0;
      memset(&v30, 0, 0x20u);
      v31 = 1;
      TBGetItem((int)hDC, v72, (LPARAM)&v29);
      v19 = v32;
    }
    v38 = (signed __int16)v19;
    v37 = SHIWORD(v19);
    v69 = v70 & 4;
    if ( v70 & 4 && (!(*((_DWORD *)hDC + 2) & 0x8000000) || *((_DWORD *)hDC + 7) < 5)
      || TBGetImageList((int)hDC, 2, SHIWORD(v19)) )
    {
      v20 = yTopa;
      if ( *((_BYTE *)hDC + 36) & 4 )
        v20 = yTopa - g_cyEdge;
      DrawFace(hdc, xLefta, v20, lpchText, v73, v64, (int)v66, (int)chText);
    }
    if ( !v69 || *((_DWORD *)hDC + 2) & 0x8000000 && *((_DWORD *)hDC + 7) >= 5 )
    {
      if ( !*((_DWORD *)hDC + 10) )
      {
        result = (int)CreateCompatibleDC(hdc);
        *((_DWORD *)hDC + 10) = result;
        if ( !result )
          return result;
        SetTextColor((HDC)result, 0);
        SelectObject(*((HDC *)hDC + 10), *((HGDIOBJ *)hDC + 19));
      }
      v66 = SelectObject(*((HDC *)hDC + 10), *((HGDIOBJ *)hDC + 11));
      if ( GetLayout(hdc) & 1 && !(GetLayout(*((HDC *)hDC + 10)) & 1) )
        SetLayout(*((HDC *)hDC + 10), 1u);
      v22 = TBGetImageList((int)hDC, 2, v37);
      CreateMask((int)lpchText, v73, w, cy, v22 == 0, chText);
      SetTextColor(hdc, 0);
      SetBkColor(hdc, 0xFFFFFFu);
      if ( !(v70 & 0x10) && !(v39 & 0x100000) )
      {
        v71 = SelectObject(hdc, g_hbrBtnHighlight);
        if ( v71 )
        {
          BitBlt(hdc, xLefta + 1, yTopa + 1, w, cy, *((HDC *)hDC + 10), 0, 0, 0xB8074Au);
          SelectObject(hdc, v71);
        }
      }
      v71 = SelectObject(hdc, g_hbrBtnShadow);
      if ( v71 )
      {
        BitBlt(hdc, xLefta, yTopa, w, cy, *((HDC *)hDC + 10), 0, 0, 0xB8074Au);
        SelectObject(hdc, v71);
      }
      if ( v70 & 1 )
        BitBlt(*((HDC *)hDC + 10), 1, 1, w - 1, cy - 1, *((HDC *)hDC + 10), 0, 0, 0x8800C6u);
      SelectObject(*((HDC *)hDC + 10), v66);
    }
    if ( TB_HasDDArrow((int)hDC, v72) )
    {
      v25 = -(*((_DWORD *)hDC + 12) + 28 * *((_DWORD *)hDC + 52) != v72);
      w = 96;
      v26 = v25 + 1;
      if ( TB_HasTopDDArrow((int)hDC, v72) )
      {
        v27 = (int)((char *)lpchText + *((_DWORD *)hDC + 26) + xLefta);
        v60 = v27 + *((_DWORD *)hDC + 35);
        v58 = v27;
        v28 = *((_DWORD *)hDC + 27);
        v59 = yTopa + v73;
        v61 = yTopa + v73 + v28;
      }
      else
      {
        TB_GetItemRect(hDC, (v72 - *((_DWORD *)hDC + 12)) / 28, (int)&v58);
        v58 = v60 - *((_DWORD *)hDC + 35);
      }
      if ( *(_BYTE *)(v72 + 9) & 0x80 )
        w = 352;
      if ( !v69 || *((_DWORD *)hDC + 2) & 0x8000000 && *((_DWORD *)hDC + 7) >= 5 )
      {
        w |= 0x80u;
      }
      else if ( (v26 || v56) && !TB_HasTopDDArrow((int)hDC, v72) )
      {
        w |= 0x10u;
      }
      else if ( v68 || !(*((_DWORD *)hDC + 2) & 0x800) )
      {
        w |= 8u;
      }
      DrawScrollArrow(hdc, &v58, (unsigned __int16)w);
    }
    SelectObject(hdc, h);
    result = SetTextColor(hdc, v62);
    if ( ho )
      result = DeleteObject(ho);
  }
  if ( v39 & 0x10 )
    result = CICustomDrawNotify((int)hDC, 65538, (LPARAM)&lParam);
  return result;
}

//----- (6F77BEC0) --------------------------------------------------------
BOOL __stdcall TB_HasDDArrow(int a1, int a2)
{
  return *(_BYTE *)(a1 + 36) & 1 && *(_BYTE *)(a2 + 9) & 8 || *(_BYTE *)(a2 + 9) & 0x80;
}

//----- (6F77BEEB) --------------------------------------------------------
int __stdcall DrawFace(HDC hdc, int a2, int a3, LPCWSTR lpchText, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // ebx@1
  int v10; // esi@1
  int v11; // eax@1
  int v12; // edx@4
  int v13; // eax@9
  COLORREF v14; // eax@13
  int v15; // ebx@15
  int result; // eax@19
  int v17; // edx@23
  int v18; // esi@25
  int v19; // eax@35
  int v20; // ebx@36
  int v21; // eax@54
  IMAGELISTDRAWPARAMS pimldp; // [sp+Ch] [bp-68h]@1
  RECT rcSrc; // [sp+50h] [bp-24h]@47
  int v24; // [sp+60h] [bp-14h]@1
  int v25; // [sp+64h] [bp-10h]@32
  int v26; // [sp+68h] [bp-Ch]@2
  int v27; // [sp+6Ch] [bp-8h]@3
  int v28; // [sp+70h] [bp-4h]@1
  const WCHAR *lpchTexta; // [sp+88h] [bp+14h]@19
  int v30; // [sp+8Ch] [bp+18h]@21
  int v31; // [sp+98h] [bp+24h]@3

  pimldp.cbSize = 0;
  memset(&pimldp.himl, 0, 0x40u);
  v8 = a8;
  v9 = *(_DWORD *)(a8 + 4);
  v28 = 0;
  v10 = *(_DWORD *)a8;
  v11 = *(_DWORD *)(*(_DWORD *)a8 + 8);
  v24 = v9;
  v26 = !(v11 & 0x1000) || *(_DWORD *)(a8 + 20) != -2 || !(*(_BYTE *)(v9 + 9) & 0x10);
  v27 = *(_DWORD *)(a8 + 8);
  v31 = v27;
  v27 &= 4u;
  if ( v27 )
  {
    v12 = *(_DWORD *)(v8 + 12);
    v28 = *(_DWORD *)(v8 + 12);
    if ( v11 & 0x800 )
    {
      if ( v31 & 3 )
      {
        v25 = 2;
      }
      else
      {
        if ( !v12 )
          goto LABEL_5;
        v25 = 4;
      }
      TB_GetItemRect((HDC)v10, (v9 - *(_DWORD *)(v10 + 48)) / 28, (int)&rcSrc);
      if ( TB_HasSplitDDArrow(v10, v9) )
        rcSrc.right -= *(_DWORD *)(v10 + 140);
      if ( !(*(_DWORD *)(v8 + 24) & 0x10000) )
        CCDrawEdge(hdc, &rcSrc, v25, 15, v10 + 184);
    }
  }
LABEL_5:
  pimldp.himl = 0;
  if ( v28 || v31 & 1 )
  {
    v20 = *(_DWORD *)(v8 + 16);
    pimldp.himl = (HIMAGELIST)TBGetImageList(v10, 1, *(_DWORD *)(v8 + 16));
    if ( pimldp.himl )
      goto LABEL_11;
    v13 = TBGetImageList(v10, 0, v20);
    pimldp.himl = (HIMAGELIST)v13;
LABEL_10:
    if ( v13 )
      goto LABEL_11;
LABEL_41:
    v15 = a5;
    goto LABEL_19;
  }
  if ( v27 && (!(*(_DWORD *)(v10 + 8) & 0x8000000) || *(_DWORD *)(v10 + 28) < 5)
    || (v21 = TBGetImageList(v10, 2, *(_DWORD *)(v8 + 16)), (pimldp.himl = (HIMAGELIST)v21) == 0) )
  {
    v13 = TBGetImageList(v10, 0, *(_DWORD *)(v8 + 16));
    pimldp.himl = (HIMAGELIST)v13;
    if ( !v13 )
      goto LABEL_41;
    goto LABEL_10;
  }
LABEL_11:
  if ( *(_DWORD *)(v8 + 20) == -1 || !v26 )
    goto LABEL_41;
  v14 = *(_DWORD *)(v8 + 100);
  if ( *(_DWORD *)(v10 + 8) & 0x8000 )
    v14 = -1;
  if ( *(_BYTE *)(v10 + 36) & 0x20 )
    v14 = -16777216;
  pimldp.i = *(_DWORD *)(v8 + 20);
  pimldp.hdcDst = hdc;
  pimldp.x = (int)((char *)lpchText + a2);
  v15 = a5;
  pimldp.y = a5 + a3;
  pimldp.cbSize = 68;
  pimldp.cx = 0;
  pimldp.cy = 0;
  pimldp.xBitmap = 0;
  pimldp.yBitmap = 0;
  pimldp.rgbBk = v14;
  pimldp.rgbFg = -16777216;
  pimldp.fStyle = 0;
  if ( v31 & 0x11 )
    pimldp.fStyle = 1;
  if ( v31 & 0x80 && !(*(_DWORD *)(v8 + 24) & 0x80000) )
    pimldp.fStyle = 5;
  if ( *(_DWORD *)(v8 + 24) & 0x200000 )
    pimldp.fStyle = 5;
  ImageList_DrawIndirect(&pimldp);
LABEL_19:
  result = TB_StrForButton(v10, v24);
  lpchTexta = (const WCHAR *)result;
  if ( !result )
    return result;
  v30 = v31 & 0x80 && *(_DWORD *)(v10 + 8) & 0x1000 && !(*(_DWORD *)(v8 + 24) & 0x80000);
  if ( !(v31 & 3) || *(_DWORD *)(v8 + 24) & 0x40000 )
  {
    v17 = a2;
  }
  else
  {
    v17 = a2 + 1;
    if ( !(*(_DWORD *)(v10 + 8) & 0x1000) )
      goto LABEL_25;
    ++a3;
  }
  if ( *(_DWORD *)(v10 + 8) & 0x1000 )
  {
    if ( v26 )
    {
      v19 = *(_DWORD *)(v10 + 156) + *(_DWORD *)(v10 + 104);
      v17 += v19;
      a6 -= v19;
    }
    else
    {
      v17 += g_cxEdge;
    }
    return DrawString(hdc, v17 + 1, a3 + 1, a6, a7, lpchTexta, v30, v8);
  }
LABEL_25:
  v18 = *(_DWORD *)(v10 + 108);
  a3 += v18 + v15;
  a7 -= v15 + v18;
  return DrawString(hdc, v17 + 1, a3 + 1, a6, a7, lpchTexta, v30, v8);
}

//----- (6F77C0A6) --------------------------------------------------------
BOOL __stdcall ImageList_DrawIndirect(IMAGELISTDRAWPARAMS *pimldp)
{
  IMAGELISTDRAWPARAMS *v1; // edi@1
  BOOL v2; // esi@1
  BOOL result; // eax@4

  v1 = pimldp;
  v2 = 0;
  if ( pimldp )
  {
    if ( HIMAGELIST_QueryInterface(pimldp->himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&pimldp) >= 0 )
    {
      v2 = (*(int (__stdcall **)(IMAGELISTDRAWPARAMS *, IMAGELISTDRAWPARAMS *))(pimldp->cbSize + 32))(pimldp, v1) == 0;
      (*(void (__stdcall **)(IMAGELISTDRAWPARAMS *))(pimldp->cbSize + 8))(pimldp);
    }
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F77C0F6) --------------------------------------------------------
signed int __stdcall TBIsHotTrack(int a1, int a2, char a3)
{
  signed int v3; // edi@1

  v3 = 0;
  if ( *(_DWORD *)(a1 + 8) & 0x800 && *(_DWORD *)(a1 + 48) + 28 * *(_DWORD *)(a1 + 204) == a2 )
    v3 = 1;
  if ( !(a3 & 2) && GetKeyState(1) < 0 && GetCapture() == *(HWND *)a1 )
    v3 = 0;
  if ( !v3 && *(_DWORD *)(a1 + 208) == (a2 - *(_DWORD *)(a1 + 48)) / 28 )
    v3 = 1;
  return v3;
}

//----- (6F77C159) --------------------------------------------------------
signed int __stdcall StateFromCDIS(__int16 a1)
{
  signed int result; // eax@1

  result = 0;
  if ( a1 & 8 )
    result = 1;
  if ( a1 & 1 )
    result |= 2u;
  if ( !(a1 & 4) )
    result |= 4u;
  if ( (char)a1 < 0 )
    result |= 0x80u;
  if ( a1 & 0x100 )
    result |= 0x10u;
  return result;
}

//----- (6F77C19A) --------------------------------------------------------
int __stdcall TBShouldDrawButton(int a1, RECT *lprect, HDC hdc)
{
  int result; // eax@3

  if ( RectVisible(hdc, lprect) )
  {
    if ( *(_BYTE *)(a1 + 36) & 0x10 )
      result = TBIsRectClipped(a1, lprect) == 0;
    else
      result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F77C1CC) --------------------------------------------------------
int __stdcall InitTBDrawItem(int a1, int a2, int a3, int a4, int a5, int xRight, int yBottom)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 4) = a3;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 12) = a5;
  *(_DWORD *)(a1 + 16) = *(_WORD *)(a3 + 2);
  *(_DWORD *)(a1 + 20) = *(_WORD *)a3;
  *(_DWORD *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 76) = g_hbrMonoDither;
  *(_DWORD *)(a1 + 80) = GetStockObject(4);
  *(_DWORD *)(a1 + 84) = GetStockObject(7);
  *(_DWORD *)(a1 + 92) = g_clrHighlight;
  *(_DWORD *)(a1 + 104) = g_clrBtnHighlight;
  *(_DWORD *)(a1 + 96) = g_clrHighlightText;
  *(_DWORD *)(a1 + 100) = g_clrBtnFace;
  *(_DWORD *)(a1 + 128) = 1;
  *(_DWORD *)(a1 + 132) = 2;
  *(_DWORD *)(a1 + 88) = g_clrBtnText;
  SetRect((LPRECT)(a1 + 112), 0, 0, xRight, yBottom);
  result = CDISFromState(a4);
  *(_DWORD *)(a1 + 68) = result;
  if ( *(_DWORD *)(a2 + 8) & 0x800 )
  {
    if ( a5 )
    {
      result |= 0x40u;
      *(_DWORD *)(a1 + 68) = result;
    }
  }
  return result;
}

//----- (6F77C28B) --------------------------------------------------------
signed int __stdcall CDISFromState(char a1)
{
  signed int result; // eax@1

  result = 0;
  if ( a1 & 1 )
    result = 8;
  if ( a1 & 2 )
    result |= 1u;
  if ( !(a1 & 4) )
    result |= 4u;
  if ( a1 < 0 )
    result |= 0x80u;
  if ( a1 & 0x10 )
    result |= 0x100u;
  return result;
}

//----- (6F77C2CA) --------------------------------------------------------
int __userpurge TBWidthOfButton@<eax>(int a1@<ebx>, HDC hDC, int a3, HDC hdc)
{
  char v4; // al@1
  int result; // eax@3
  LONG v6; // eax@18
  int v7; // eax@21
  int v8; // eax@31
  struct tagRECT Rect; // [sp+8h] [bp-10h]@38

  v4 = *(_BYTE *)(a3 + 9);
  if ( !(v4 & 0x10) && (!(*((_BYTE *)hDC + 36) & 8) || !(*((_DWORD *)hDC + 2) & 0x1000) || v4 & 1) )
    goto LABEL_3;
  if ( !*((_DWORD *)hDC + 24) || *((_BYTE *)hDC + 36) & 8 && *((_DWORD *)hDC + 2) & 0x1000 && !(v4 & 0x40) )
  {
    LOWORD(v7) = 0;
LABEL_24:
    *(_WORD *)(a3 + 10) = v7;
    goto LABEL_25;
  }
  if ( *(_WORD *)(a3 + 10) )
    goto LABEL_3;
  v6 = TBWidthOfString(hDC, a3, hdc);
  LOWORD(a1) = v6 + *((_WORD *)hDC + 74);
  *(_WORD *)(a3 + 10) = a1;
  if ( v6 )
  {
    if ( *((_DWORD *)hDC + 2) & 0x1000 && TB_HasSplitDDArrow((int)hDC, a3) )
      LOWORD(v7) = a1 + *((_WORD *)hDC + 80);
    else
      v7 = a1 + 2 * g_cxEdge;
    goto LABEL_24;
  }
LABEL_25:
  if ( *(_DWORD *)a3 != -2 )
  {
    if ( *((_DWORD *)hDC + 2) & 0x1000 )
    {
      *(_WORD *)(a3 + 10) += *((_WORD *)hDC + 52) + *((_WORD *)hDC + 78);
      if ( *((_DWORD *)hDC + 24)
        && (!(*((_BYTE *)hDC + 36) & 8) || !(*((_DWORD *)hDC + 2) & 0x1000) || *(_BYTE *)(a3 + 9) & 0x40) )
        goto LABEL_35;
      v8 = *(_WORD *)(a3 + 10) + 2 * g_cxEdge;
    }
    else
    {
      v8 = *((_DWORD *)hDC + 26) + *((_DWORD *)hDC + 37);
      if ( *(_WORD *)(a3 + 10) > v8 )
        LOWORD(v8) = *(_WORD *)(a3 + 10);
    }
    *(_WORD *)(a3 + 10) = v8;
  }
LABEL_35:
  *(_WORD *)(a3 + 10) += TBDDArrowAdjustment(hDC, a3);
LABEL_3:
  LOWORD(result) = *(_WORD *)(a3 + 10);
  if ( (_WORD)result )
  {
    result = (unsigned __int16)result;
  }
  else if ( *(_BYTE *)(a3 + 9) & 1 )
  {
    if ( *((_BYTE *)hDC + 8) & 0x80 )
    {
      GetWindowRect(*(HWND *)hDC, &Rect);
      result = Rect.right - Rect.left;
    }
    else
    {
      result = *(_DWORD *)a3;
    }
  }
  else if ( *((_BYTE *)hDC + 36) & 4 )
  {
    result = *((_DWORD *)hDC + 28);
  }
  else
  {
    result = *((_DWORD *)hDC + 28) + TBDDArrowAdjustment(hDC, a3);
  }
  return result;
}

//----- (6F77C325) --------------------------------------------------------
int __stdcall TBDDArrowAdjustment(HDC hDC, int a2)
{
  int result; // eax@2
  char v3; // al@5
  int v4; // esi@9

  if ( !TB_HasDDArrow((int)hDC, a2) )
    goto LABEL_19;
  if ( TB_HasTopDDArrow((int)hDC, a2) )
  {
    v3 = *(_BYTE *)(a2 + 9);
    if ( !(v3 & 0x10) && (!(*((_BYTE *)hDC + 36) & 8) || !(*((_DWORD *)hDC + 2) & 0x1000) || v3 & 1) )
      goto LABEL_19;
  }
  v4 = *((_WORD *)hDC + 70);
  if ( *(_BYTE *)(a2 + 9) & 0x80 )
  {
    v4 += -2 * g_cxEdge;
    if ( *(_DWORD *)a2 != -2 )
      v4 -= g_cxEdge;
  }
  if ( TB_HasTopDDArrow((int)hDC, a2) )
  {
    if ( TBWidthOfString(hDC, a2, 0) >= v4 + *((_DWORD *)hDC + 26) )
      v4 = 0;
  }
  if ( v4 > 0 )
    result = v4;
  else
LABEL_19:
    result = 0;
  return result;
}

//----- (6F77C350) --------------------------------------------------------
int __stdcall TB_OnEraseBkgnd(int a1, WPARAM wParam)
{
  int result; // eax@1
  bool v3; // zf@1
  LPARAM lParam; // [sp+8h] [bp-6Ch]@1
  char Dst; // [sp+Ch] [bp-68h]@1
  WPARAM v6; // [sp+18h] [bp-5Ch]@1

  lParam = 0;
  result = (int)memset(&Dst, 0, 0x68u);
  v3 = (*(_DWORD *)(a1 + 8) & 0x2000) == 0;
  v6 = wParam;
  if ( v3 )
  {
    *(_DWORD *)(a1 + 12) = 0;
  }
  else
  {
    result = CICustomDrawNotify(a1, 3, (LPARAM)&lParam);
    *(_DWORD *)(a1 + 12) = result;
  }
  if ( !(*(_BYTE *)(a1 + 12) & 4) )
  {
    if ( !(*(_DWORD *)(a1 + 8) & 0x8000) || (result = CCForwardEraseBackground(*(HWND *)a1, (HDC)wParam)) == 0 )
      result = DefWindowProcW(*(HWND *)a1, 0x14u, wParam, 0);
  }
  if ( *(_BYTE *)(a1 + 12) & 0x40 )
    result = CICustomDrawNotify(a1, 4, (LPARAM)&lParam);
  return result;
}

//----- (6F77C3BD) --------------------------------------------------------
void __stdcall FlushToolTipsMgrNow(HDC hDC)
{
  int v1; // ebx@1
  int v2; // eax@3
  int v3; // eax@3
  int v4; // edi@4
  LPARAM lParam; // [sp+8h] [bp-2Ch]@3
  int v6; // [sp+10h] [bp-24h]@3
  int v7; // [sp+14h] [bp-20h]@6
  RECT rcSrc2; // [sp+18h] [bp-1Ch]@6
  int v9; // [sp+2Ch] [bp-8h]@3

  v1 = 0;
  if ( *((_DWORD *)hDC + 16) )
  {
    v2 = *(_DWORD *)hDC;
    v9 = -1;
    v6 = v2;
    v3 = *((_DWORD *)hDC + 12);
    lParam = 44;
    if ( *((_DWORD *)hDC + 33) > 0u )
    {
      v4 = v3 + 4;
      do
      {
        if ( !(*(_BYTE *)(v4 + 5) & 1) )
        {
          v7 = *(_DWORD *)v4;
          if ( !TB_GetItemRect(hDC, v1, (int)&rcSrc2)
            || *((_BYTE *)hDC + 36) & 0x10 && TBIsRectClipped((int)hDC, &rcSrc2) )
          {
            rcSrc2.bottom = 0;
            rcSrc2.top = 0;
            rcSrc2.right = 0;
            rcSrc2.left = 0;
          }
          SendMessageW(*((HWND *)hDC + 16), 0x434u, 0, (LPARAM)&lParam);
        }
        ++v1;
        v4 += 28;
      }
      while ( (unsigned int)v1 < *((_DWORD *)hDC + 33) );
    }
    *((_DWORD *)hDC + 59) &= 0xFFFFFFEF;
  }
}

//----- (6F77C41A) --------------------------------------------------------
BOOL __stdcall PatB(HDC hdc, int a2, int a3, int a4, int a5, COLORREF color)
{
  RECT rect; // [sp+0h] [bp-10h]@1

  SetBkColor(hdc, color);
  rect.left = a2;
  rect.right = a4 + a2;
  rect.top = a3;
  rect.bottom = a5 + a3;
  return ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
}

//----- (6F77C469) --------------------------------------------------------
int __stdcall DrawBlankButton(HDC hdc, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // ebx@1
  struct tagRECT qrc; // [sp+Ch] [bp-10h]@4

  result = a6;
  v7 = *(_DWORD *)(a6 + 8);
  if ( !(v7 & 1) )
  {
    PatB(hdc, a2, a3, a4, a5, *(_DWORD *)(a6 + 100));
    result = a6;
  }
  if ( !(*(_DWORD *)(result + 24) & 0x10000) )
  {
    qrc.left = a2;
    qrc.top = a3;
    qrc.right = a4 + a2;
    qrc.bottom = a5 + a3;
    result = DrawEdge(hdc, &qrc, (v7 & 3) != 0 ? 10 : 5, 0x100Fu);
  }
  return result;
}

//----- (6F77C4E9) --------------------------------------------------------
int __stdcall DrawString(HDC hdc, int xLeft, int yTop, int a4, int a5, LPCWSTR lpchText, int a7, int a8)
{
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // edi@1
  int result; // eax@1
  HDC v12; // ebx@5
  int v13; // esi@7
  int v14; // eax@9
  int v15; // edi@14
  COLORREF v16; // eax@20
  COLORREF v17; // ST10_4@20
  struct tagRECT rc; // [sp+8h] [bp-18h]@12
  COLORREF v19; // [sp+18h] [bp-8h]@20
  COLORREF color; // [sp+1Ch] [bp-4h]@20
  int hdca; // [sp+28h] [bp+8h]@6
  int v22; // [sp+44h] [bp+24h]@1

  v8 = a8;
  v9 = *(_DWORD *)(a8 + 4);
  v10 = *(_DWORD *)a8;
  result = *(_DWORD *)(*(_DWORD *)a8 + 8) & 0x1000;
  v22 = *(_DWORD *)(a8 + 4);
  if ( (result || g_cyEdge + *(_DWORD *)(v10 + 108) + *(_DWORD *)(v10 + 152) < *(_DWORD *)(v10 + 116))
    && *(_DWORD *)(v10 + 96)
    && (!(*(_BYTE *)(v10 + 36) & 8) || !result || *(_BYTE *)(v9 + 9) & 0x40) )
  {
    v12 = hdc;
    if ( a7 )
    {
      hdca = SetBkMode(hdc, *(_DWORD *)(v8 + 132));
      v16 = SetBkColor(v12, *(_DWORD *)(v8 + 92));
      v17 = *(_DWORD *)(v8 + 96);
      color = v16;
      v19 = SetTextColor(v12, v17);
    }
    else
    {
      hdca = SetBkMode(hdc, *(_DWORD *)(v8 + 128));
    }
    v13 = TBGetDrawTextFlags(v10, 0x8000, v22);
    if ( *(_BYTE *)(v10 + 36) & 4 )
    {
      v14 = a5;
    }
    else if ( *(_DWORD *)(v10 + 8) & 0x1000 )
    {
      v14 = *(_DWORD *)(v10 + 136);
      v15 = *(_DWORD *)(v10 + 108);
      if ( v14 <= v15 )
        v14 = v15;
    }
    else
    {
      v14 = a5;
      if ( !a5 || *(_DWORD *)(v10 + 136) < a5 )
        v14 = *(_DWORD *)(v10 + 136);
    }
    SetRect(&rc, xLeft, yTop, xLeft + a4, yTop + v14);
    DrawTextW(v12, lpchText, -1, &rc, v13);
    result = SetBkMode(v12, hdca);
    if ( a7 )
    {
      SetBkColor(v12, color);
      result = SetTextColor(v12, v19);
    }
  }
  return result;
}

//----- (6F77C5DA) --------------------------------------------------------
int __stdcall TBGetDrawTextFlags(int a1, int a2, int a3)
{
  int v3; // esi@5
  int v5; // [sp+Ch] [bp+Ch]@2
  int v6; // [sp+Ch] [bp+Ch]@4

  if ( *(_DWORD *)(a1 + 96) > 1 )
    v5 = a2 | 0x2010;
  else
    v5 = a2 | 0x20;
  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
    v6 = v5 | 0x24;
  else
    v6 = v5 | 1;
  v3 = *(_DWORD *)(a1 + 176) | v6 & ~*(_DWORD *)(a1 + 180);
  if ( *(_BYTE *)(a3 + 9) & 0x20 )
    v3 |= 0x800u;
  if ( CCGetUIState(a1) & 2 )
    v3 |= 0x100000u;
  return v3;
}

//----- (6F77C63A) --------------------------------------------------------
int __stdcall CCGetUIState(int a1)
{
  return *(_WORD *)(a1 + 32);
}

//----- (6F77C64F) --------------------------------------------------------
int __stdcall CCDrawEdge(HDC hdc, RECT *lprcSrc, int a3, int a4, int a5)
{
  int v5; // eax@2
  char v6; // dl@3
  int v7; // eax@4
  int v8; // eax@5
  COLORREF v9; // edi@6
  COLORREF v10; // esi@8
  COLORREF v11; // eax@11
  int v13; // eax@39
  COLORREF v14; // eax@55
  RECT rect; // [sp+0h] [bp-20h]@16
  struct tagRECT rcDst; // [sp+10h] [bp-10h]@2

  if ( a4 & 0x8000 )
    a4 |= 0x4000u;
  CopyRect(&rcDst, lprcSrc);
  v5 = a3 & 3;
  if ( !(a3 & 3) )
    goto LABEL_21;
  while ( 1 )
  {
    v6 = a4;
    if ( a4 & 0x4000 )
    {
      if ( a4 & 0x8000 )
      {
        if ( v5 & 3 )
          v10 = g_clrWindowFrame;
        else
          v10 = g_clrWindow;
      }
      else
      {
        v10 = g_clrBtnShadow;
        if ( !(v5 & 3) )
          v10 = g_clrBtnFace;
      }
      v9 = v10;
      goto LABEL_13;
    }
    v7 = v5 - 1;
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( !v8 )
      {
        v9 = g_clr3DDkShadow;
        if ( !(a4 & 0x1000) )
          v9 = g_clrBtnShadow;
        v10 = g_clrBtnHighlight;
        goto LABEL_9;
      }
      v13 = v8 - 2;
      if ( v13 )
      {
        if ( v13 != 4 )
          return 0;
        v9 = g_clrBtnShadow;
        if ( !(a4 & 0x1000) )
          v9 = g_clr3DDkShadow;
        v10 = g_clr3DLight;
LABEL_9:
        if ( a5 )
        {
          if ( *(_DWORD *)(a5 + 8) != -16777216 )
            v9 = *(_DWORD *)(a5 + 8);
          v11 = *(_DWORD *)(a5 + 4);
LABEL_12:
          if ( v11 != -16777216 )
            v10 = v11;
          goto LABEL_13;
        }
        goto LABEL_13;
      }
      v9 = g_clr3DLight;
      if ( !(a4 & 0x1000) )
        v9 = g_clrBtnHighlight;
      v10 = g_clrBtnShadow;
    }
    else
    {
      v9 = g_clrBtnHighlight;
      if ( !(a4 & 0x1000) )
        v9 = g_clr3DLight;
      v10 = g_clr3DDkShadow;
    }
    if ( a5 )
    {
      if ( *(_DWORD *)(a5 + 4) != -16777216 )
        v9 = *(_DWORD *)(a5 + 4);
      v11 = *(_DWORD *)(a5 + 8);
      goto LABEL_12;
    }
LABEL_13:
    if ( a4 & 0xC )
    {
      if ( a4 & 4 )
      {
        rect.right = rcDst.right;
        rect.top = rcDst.top;
        rect.bottom = rcDst.bottom;
        rcDst.right -= g_cxBorder;
        rect.left = rcDst.right;
        FillRectClr(hdc, &rect, v10);
        v6 = a4;
      }
      if ( v6 & 8 )
      {
        rect.bottom = rcDst.bottom;
        rect.left = rcDst.left;
        rcDst.bottom -= g_cyBorder;
        rect.right = rcDst.right;
        rect.top = rcDst.bottom;
        FillRectClr(hdc, &rect, v10);
        v6 = a4;
      }
    }
    if ( v6 & 3 )
    {
      if ( a4 & 1 )
      {
        rcDst.left += g_cxBorder;
        rect.right = rcDst.left;
        rect.top = rcDst.top;
        rect.bottom = rcDst.bottom;
        rect.left = rcDst.left - g_cxBorder;
        FillRectClr(hdc, &rect, v9);
      }
      if ( a4 & 2 )
      {
        rcDst.top += g_cyBorder;
        rect.left = rcDst.left;
        rect.right = rcDst.right;
        rect.bottom = rcDst.top;
        rect.top = rcDst.top - g_cyBorder;
        FillRectClr(hdc, &rect, v9);
      }
    }
LABEL_21:
    v5 = a3 & 0xC;
    if ( !(a3 & 0xC) )
      break;
    a3 &= 0xFFFFFFF3;
  }
  if ( a4 & 0x800 )
  {
    v14 = g_clrWindow;
    if ( !(a4 & 0x8000) )
      v14 = g_clrBtnFace;
    FillRectClr(hdc, &rcDst, v14);
  }
  if ( a4 & 0x2000 )
    CopyRect(lprcSrc, &rcDst);
  return 1;
}
// 6F7E6934: using guessed type int g_clr3DLight;
// 6F7E6960: using guessed type int g_clrWindowFrame;

//----- (6F77C796) --------------------------------------------------------
HRESULT __stdcall StringCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPWSTR v4; // eax@4
  HRESULT v5; // ebx@4
  size_t v6; // esi@4
  wchar_t v7; // cx@6

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cchDest;
    if ( !cchDest )
      goto LABEL_15;
    do
    {
      if ( !(2147483646 - cchDest + v6) )
        break;
      v7 = *(STRSAFE_LPWSTR)((char *)v4 + (char *)pszSrc - (char *)pszDest);
      if ( !v7 )
        break;
      *v4 = v7;
      ++v4;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_15:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (6F77C80D) --------------------------------------------------------
HLOCAL __stdcall FreeProducedString(HLOCAL hMem)
{
  HLOCAL result; // eax@3

  if ( hMem )
  {
    if ( hMem != (HLOCAL)-1 )
      result = LocalFree(hMem);
  }
  return result;
}

//----- (6F77C832) --------------------------------------------------------
LPCSTR __stdcall ProduceWFromA(UINT CodePage, LPCSTR lpMultiByteStr)
{
  LPCSTR result; // eax@1
  signed int v3; // edi@3
  WCHAR *v4; // eax@4
  void *v5; // ebx@4

  result = lpMultiByteStr;
  if ( lpMultiByteStr && lpMultiByteStr != (LPCSTR)-1 )
  {
    v3 = MultiByteToWideChar(CodePage, 0, lpMultiByteStr, -1, 0, 0);
    if ( !v3 )
      v3 = 1;
    v4 = (WCHAR *)LocalAlloc(0, 2 * v3);
    v5 = v4;
    if ( v4 )
    {
      if ( !MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, -1, v4, v3) )
      {
        LocalFree(v5);
        v5 = 0;
      }
    }
    result = (LPCSTR)v5;
  }
  return result;
}

//----- (6F77C898) --------------------------------------------------------
int __stdcall TBOutputStruct(int a1, int a2, void *Dst)
{
  int result; // eax@1

  memset(Dst, 0, *(_DWORD *)(a1 + 100));
  result = a2;
  *(_DWORD *)Dst = *(_DWORD *)a2;
  *((_DWORD *)Dst + 1) = *(_DWORD *)(a2 + 4);
  *((_BYTE *)Dst + 8) = *(_BYTE *)(a2 + 8);
  *((_BYTE *)Dst + 9) = *(_BYTE *)(a2 + 9);
  *((_WORD *)Dst + 5) = *(_WORD *)(a2 + 10);
  if ( *(_DWORD *)(a1 + 100) >= 0x14u )
  {
    *((_DWORD *)Dst + 3) = *(_DWORD *)(a2 + 12);
    result = *(_DWORD *)(a2 + 16);
    *((_DWORD *)Dst + 4) = result;
  }
  return result;
}

//----- (6F77C903) --------------------------------------------------------
#error "6F78BDD3: switch analysis failed (funcsize=788)"

//----- (6F77CA5A) --------------------------------------------------------
int __stdcall SBSetText(int a1, int a2, LPCWSTR lpString)
{
  int v3; // esi@2
  int v4; // edi@2
  int v6; // ebx@10
  int v7; // [sp+10h] [bp+8h]@3

  if ( (_BYTE)a2 == -1 )
  {
    if ( a2 & 0x1000 )
      return 0;
    v3 = a1;
    v6 = *(_DWORD *)(a1 + 84);
    if ( *(_DWORD *)(a1 + 28) < 5 )
      *(_DWORD *)(a1 + 84) &= 0xFF00u;
    v7 = SetStatusText(a1, a1 + 80, a2, lpString);
    if ( *(_DWORD *)(v3 + 28) < 5 )
      *(_DWORD *)(v3 + 84) |= (unsigned __int8)v6;
    v4 = 0;
  }
  else
  {
    v3 = a1;
    v4 = (unsigned __int8)a2;
    if ( *(_DWORD *)(a1 + 112) <= (unsigned int)(unsigned __int8)a2 )
      v7 = 0;
    else
      v7 = SetStatusText(a1, *(_DWORD *)(a1 + 120) + 32 * (unsigned __int8)a2, a2, lpString);
  }
  if ( v7 )
    MyNotifyWinEvent(32780, *(_DWORD *)v3, -4, v4 + 1);
  return v7;
}

//----- (6F77CAB5) --------------------------------------------------------
int __stdcall SetStatusText(int a1, int a2, int a3, LPCWSTR lpString)
{
  int v4; // edi@1
  int v5; // eax@3
  int v6; // eax@10
  wchar_t *v7; // edi@11
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@4
  int v10; // [sp+2Ch] [bp+10h]@10

  v4 = (unsigned __int8)a3;
  if ( (*(_DWORD *)(a2 + 4) & 0xF000) == 61440 )
    LocalFree(*(HLOCAL *)a2);
  v5 = a3 & 0xFF00;
  if ( (unsigned __int8)a3 == 255 )
  {
    v5 |= *(_BYTE *)(a2 + 4);
    v4 = 0;
  }
  *(_DWORD *)(a2 + 4) = v5;
  *(_DWORD *)(a2 + 4) &= 0xFFFF0FFF;
  GetClientRect(*(HWND *)a1, &Rect);
  if ( v4 )
    Rect.left = *(_DWORD *)(a2 - 24);
  if ( *(_DWORD *)(a2 + 8) > 0 )
    Rect.right = *(_DWORD *)(a2 + 8);
  InvalidateRect(*(HWND *)a1, &Rect, 0);
  if ( a3 & 0xF000 )
  {
    if ( (unsigned __int16)(a3 & 0xF000) != 4096 )
      return 0;
    *(_DWORD *)(a2 + 4) |= 0x1000u;
    *(_DWORD *)a2 = lpString;
    goto LABEL_17;
  }
  if ( !HIWORD(lpString) )
  {
    if ( (_WORD)lpString )
      return 0;
LABEL_17:
    UpdateWindow(*(HWND *)a1);
    return 1;
  }
  v6 = lstrlenW(lpString);
  v10 = v6;
  if ( !v6 )
    goto LABEL_17;
  v7 = (wchar_t *)LocalAlloc(0x40u, 2 * v6 + 2);
  *(_DWORD *)a2 = v7;
  if ( v7 )
  {
    *(_DWORD *)(a2 + 4) |= 0xF000u;
    StringCchCopyW(v7, v10 + 1, lpString);
    while ( *v7 )
    {
      if ( *v7 < 0x20u && *v7 != 9 )
        *v7 = 32;
      ++v7;
    }
    goto LABEL_17;
  }
  return 0;
}

//----- (6F77CBB7) --------------------------------------------------------
int __stdcall PaintStatusWnd(int a1, HDC a2, int a3, int a4, int a5)
{
  HWND v5; // ST10_4@1
  COLORREF v6; // edi@6
  LONG v7; // eax@6
  int result; // eax@6
  LONG v9; // eax@9
  LONG v10; // ecx@10
  LONG v11; // edx@10
  int v12; // edx@18
  LONG v13; // eax@19
  COLORREF v14; // edi@19
  LONG v15; // eax@20
  int v16; // esi@26
  int v17; // [sp-4h] [bp-CCh]@26
  LPARAM lParam; // [sp+Ch] [bp-BCh]@29
  WPARAM wParam; // [sp+10h] [bp-B8h]@29
  int v20; // [sp+14h] [bp-B4h]@29
  HWND v21; // [sp+20h] [bp-A8h]@29
  int v22; // [sp+24h] [bp-A4h]@29
  struct tagRECT rc; // [sp+28h] [bp-A0h]@29
  int v24; // [sp+38h] [bp-90h]@29
  RECT rect; // [sp+3Ch] [bp-8Ch]@20
  int v26; // [sp+4Ch] [bp-7Ch]@5
  HDC v27; // [sp+50h] [bp-78h]@1
  struct tagRECT v28; // [sp+54h] [bp-74h]@5
  HGDIOBJ h; // [sp+64h] [bp-64h]@1
  COLORREF color; // [sp+68h] [bp-60h]@6
  struct tagRECT Rect; // [sp+6Ch] [bp-5Ch]@1
  int i; // [sp+7Ch] [bp-4Ch]@8
  int v33; // [sp+80h] [bp-48h]@1
  struct tagPAINTSTRUCT Paint; // [sp+84h] [bp-44h]@2

  h = 0;
  v33 = a3;
  v5 = *(HWND *)a1;
  v27 = a2;
  GetClientRect(v5, &Rect);
  if ( a2 )
  {
    Paint.rcPaint = Rect;
    Paint.hdc = v27;
  }
  else
  {
    BeginPaint(*(HWND *)a1, &Paint);
  }
  Rect.top += *(_DWORD *)(a1 + 60);
  if ( !*(_DWORD *)(a1 + 72) || IsZoomed(*(HWND *)(a1 + 4)) )
  {
    v26 = 0;
  }
  else
  {
    v28 = Rect;
    v26 = 1;
  }
  v6 = Rect.right - a5;
  v7 = a5 - *(_DWORD *)(a1 + 64);
  color = Rect.right - a5;
  Rect.right = v7;
  result = *(_DWORD *)(a1 + 40);
  if ( result )
  {
    result = (int)SelectObject(Paint.hdc, *(HGDIOBJ *)(a1 + 40));
    h = (HGDIOBJ)result;
  }
  for ( i = 0; i < a4; v33 += 32 )
  {
    v9 = *(_DWORD *)(v33 + 8);
    if ( v9 )
    {
      v10 = *(_DWORD *)(a1 + 64);
      v11 = v10 + Rect.right;
      Rect.left = v10 + Rect.right;
      Rect.right = v9;
      if ( v9 < 0 || v9 > (signed int)v6 )
        Rect.right = v6;
      if ( g_fMEEnabled && Rect.right > (signed int)(v6 - *(_DWORD *)(a1 + 72)) )
        Rect.right = v6 - *(_DWORD *)(a1 + 72);
      if ( Rect.right - v11 >= v10 && RectVisible(Paint.hdc, &Rect) )
      {
        v16 = *(_DWORD *)(v33 + 4);
        v17 = *(_DWORD *)(v33 + 4);
        if ( (*(_DWORD *)(v33 + 4) & 0xF000) == 61440 )
        {
          DrawStatusTextEx(a1, Paint.hdc, (int)&Rect, *(_DWORD *)v33, v33, v17);
        }
        else
        {
          DrawStatusTextEx(a1, Paint.hdc, (int)&Rect, (int)&c_szNULL, v33, v17);
          if ( v16 & 0x1000 )
          {
            wParam = GetDlgCtrlID(*(HWND *)a1);
            v20 = i;
            v21 = *(HWND *)a1;
            v22 = (signed int)Paint.hdc;
            rc = Rect;
            InflateRect(&rc, -g_cxBorder, -g_cyBorder);
            v24 = *(_DWORD *)v33;
            SaveDC(Paint.hdc);
            IntersectClipRect(Paint.hdc, rc.left, rc.top, rc.right, rc.bottom);
            SendMessageW(*(HWND *)(a1 + 4), 0x2Bu, wParam, (LPARAM)&lParam);
            RestoreDC(Paint.hdc, -1);
            v6 = color;
          }
        }
      }
    }
    ++i;
    result = i;
  }
  if ( v26 )
  {
    v12 = *(_DWORD *)(a1 + 48);
    if ( *(_DWORD *)(a1 + 72) < v12 )
      v12 = *(_DWORD *)(a1 + 72);
    v13 = v28.right;
    *(_DWORD *)(a1 + 72) = v12;
    v28.bottom -= g_cyBorder;
    v28.top += g_cyBorder;
    v14 = g_clrBtnFace;
    v28.right = v13 - g_cxBorder;
    v28.left = v13 - g_cxBorder - v12;
    if ( *(_DWORD *)(a1 + 116) != -16777216 )
      v14 = *(_DWORD *)(a1 + 116);
    color = SetBkColor(Paint.hdc, v14);
    DrawFrameControl(Paint.hdc, &v28, 3u, 8u);
    v15 = v28.bottom - *(_DWORD *)(a1 + 72);
    rect.bottom = v28.bottom;
    rect.top = g_cyBorder + g_cyEdge + v15;
    rect.left = v28.right;
    rect.right = g_cxBorder + v28.right;
    FillRectClr(Paint.hdc, &rect, v14);
    rect.top = v28.bottom;
    rect.bottom = g_cyBorder + v28.bottom;
    rect.left = g_cyBorder + g_cxEdge + v28.left;
    rect.right = g_cxBorder + v28.right;
    FillRectClr(Paint.hdc, &rect, v14);
    result = SetBkColor(Paint.hdc, color);
  }
  if ( h )
    result = (int)SelectObject(Paint.hdc, h);
  if ( !v27 )
    result = EndPaint(*(HWND *)a1, &Paint);
  return result;
}
// 6F7E68D8: using guessed type int g_fMEEnabled;

//----- (6F77CE27) --------------------------------------------------------
int __stdcall DrawStatusTextEx(int a1, HDC hdc, int a3, int a4, int a5, int a6)
{
  int v6; // eax@5
  COLORREF v7; // eax@7
  COLORREF v8; // eax@8
  __int16 v9; // di@11
  wchar_t *v10; // esi@12
  int v11; // ecx@25
  int v12; // edi@26
  int result; // eax@32
  HGDIOBJ v14; // edi@42
  __int64 v15; // rax@52
  HICON v16; // eax@54
  unsigned int v17; // eax@57
  UINT align; // [sp+Ch] [bp-160h]@0
  COLORREF color; // [sp+10h] [bp-15Ch]@6
  int c; // [sp+18h] [bp-154h]@22
  int v21; // [sp+1Ch] [bp-150h]@1
  int v22; // [sp+20h] [bp-14Ch]@12
  int v23; // [sp+24h] [bp-148h]@12
  int mode; // [sp+28h] [bp-144h]@6
  int v25; // [sp+2Ch] [bp-140h]@1
  int v26; // [sp+30h] [bp-13Ch]@1
  struct tagRECT qrc; // [sp+34h] [bp-138h]@1
  COLORREF v28; // [sp+44h] [bp-128h]@1
  int v29; // [sp+48h] [bp-124h]@1
  int v30; // [sp+4Ch] [bp-120h]@1
  HGDIOBJ h; // [sp+50h] [bp-11Ch]@1
  LPCWSTR lpString; // [sp+54h] [bp-118h]@12
  int v33; // [sp+58h] [bp-114h]@12
  STRSAFE_LPCWSTR pszSrc; // [sp+5Ch] [bp-110h]@1
  int v35; // [sp+60h] [bp-10Ch]@13
  unsigned int v36; // [sp+64h] [bp-108h]@15
  wchar_t pszDest; // [sp+68h] [bp-104h]@3
  char v38; // [sp+166h] [bp-6h]@47
  int v39; // [sp+168h] [bp-4h]@15

  v30 = a3;
  qrc.left = *(_DWORD *)a3;
  qrc.top = *(_DWORD *)(a3 + 4);
  qrc.right = *(_DWORD *)(a3 + 8);
  v28 = a1;
  pszSrc = (STRSAFE_LPCWSTR)a4;
  qrc.bottom = *(_DWORD *)(a3 + 12);
  v26 = a6 & 0x400;
  v29 = 0;
  v21 = 0;
  h = 0;
  v25 = 0;
  if ( a6 & 0x400 )
  {
    align = GetTextAlign(hdc);
    SetTextAlign(hdc, align | 0x100);
  }
  if ( pszSrc )
    StringCchCopyW(&pszDest, 0x80u, pszSrc);
  else
    pszDest = 0;
  if ( GetNearestColor(hdc, g_clrBtnFace) != g_clrBtnFace && (h = CreateSolidBrush(g_clrBtnFace)) != 0 )
  {
    pszSrc = (STRSAFE_LPCWSTR)4;
    v6 = SetBkMode(hdc, 1);
  }
  else
  {
    pszSrc = (STRSAFE_LPCWSTR)6;
    v6 = SetBkMode(hdc, 2);
  }
  mode = v6;
  color = SetTextColor(hdc, g_clrBtnText);
  if ( v28 && (v7 = *(_DWORD *)(v28 + 116), v7 != -16777216) )
    v8 = SetBkColor(hdc, v7);
  else
    v8 = SetBkColor(hdc, g_clrBtnFace);
  v28 = v8;
  if ( a6 & 0x100 )
    InflateRect(&qrc, -g_cxBorder, -g_cyBorder);
  else
    DrawEdge(hdc, &qrc, (a6 & 0x200) != 0 ? 4 : 2, 0x200Fu);
  v9 = 0;
  if ( h )
  {
    v14 = SelectObject(hdc, h);
    if ( v14 )
    {
      PatBlt(hdc, qrc.left, qrc.top, qrc.right - qrc.left, qrc.bottom - qrc.top, 0xF00021u);
      SelectObject(hdc, v14);
    }
    v9 = 0;
  }
  v10 = &pszDest;
  v33 = 0;
  lpString = &pszDest;
  v22 = 0;
  v23 = a6 & 0x800;
  while ( 1 )
  {
    v35 = 0;
    if ( v23 || *v10 != 9 || v33 > 1 )
      break;
    ++v10;
    lpString = v10;
LABEL_58:
    ++v33;
    if ( v33 >= 3 )
      goto LABEL_31;
  }
  v36 = (unsigned int)v10;
  if ( (unsigned int)v10 >= (unsigned int)&v39 )
  {
LABEL_47:
    v36 = (unsigned int)&v38;
  }
  else
  {
    while ( *(_WORD *)v36 != v9 )
    {
      if ( !v23 && *(_WORD *)v36 == 9 )
        goto LABEL_22;
      v36 += 2;
      if ( v36 >= (unsigned int)&v39 )
        goto LABEL_47;
    }
    v22 = 1;
  }
LABEL_22:
  *(_WORD *)v36 = 0;
  c = lstrlenW(v10);
  MGetTextExtent(hdc, v10, c, (int)&v29, (int)&v21);
  if ( a5 && *(_DWORD *)(a5 + 12) && !v25 )
  {
    v35 = *(_DWORD *)(a5 + 16) + 2 * g_cxEdge;
    v25 = 1;
  }
  if ( v33 )
  {
    if ( v33 == 1 )
    {
      v15 = *(_DWORD *)v30 + *(_DWORD *)(v30 + 8) - v35 - v29;
      v11 = ((signed int)v15 - HIDWORD(v15)) >> 1;
    }
    else
    {
      v11 = *(_DWORD *)(v30 + 8) - v35 - g_cxEdge - v29;
    }
  }
  else
  {
    v11 = g_cxEdge + *(_DWORD *)v30;
  }
  v12 = v11 + v35;
  if ( a5 )
  {
    if ( v35 )
    {
      if ( v11 > *(_DWORD *)v30 )
      {
        v16 = *(HICON *)(a5 + 12);
        if ( v16 )
          DrawIconEx(
            hdc,
            v11,
            qrc.top + (qrc.bottom - *(_DWORD *)(a5 + 20) - qrc.top) / 2,
            v16,
            *(_DWORD *)(a5 + 16),
            *(_DWORD *)(a5 + 20),
            0,
            0,
            3u);
      }
      qrc.left = v12;
    }
    if ( *lpString || !v35 )
      *(_DWORD *)(a5 + 28) = v29 >= qrc.right - qrc.left;
    else
      *(_DWORD *)(a5 + 28) = 1;
  }
  ExtTextOutW(hdc, v12, (qrc.bottom + qrc.top - v21) / 2, (UINT)pszSrc, &qrc, lpString, c, 0);
  pszSrc = (STRSAFE_LPCWSTR)4;
  if ( !v22 )
  {
    v17 = v36;
    *(_WORD *)v36 = 9;
    lpString = (LPCWSTR)(v17 + 2);
    v10 = (wchar_t *)(v17 + 2);
    v9 = 0;
    goto LABEL_58;
  }
LABEL_31:
  if ( v26 )
    SetTextAlign(hdc, align);
  SetTextColor(hdc, color);
  SetBkColor(hdc, v28);
  result = SetBkMode(hdc, mode);
  if ( h )
    result = DeleteObject(h);
  return result;
}

//----- (6F77D148) --------------------------------------------------------
int __stdcall MGetTextExtent(HDC hdc, LPCWSTR lpString, int c, int a4, int a5)
{
  int v5; // eax@1
  int result; // eax@2
  struct tagSIZE sz; // [sp+0h] [bp-8h]@1

  v5 = c;
  sz.cx = 0;
  sz.cy = 0;
  if ( c == -1 )
    v5 = lstrlenW(lpString);
  result = GetTextExtentPointW(hdc, lpString, v5, &sz);
  if ( a4 )
    *(_DWORD *)a4 = sz.cx;
  if ( a5 )
    *(_DWORD *)a5 = sz.cy;
  return result;
}

//----- (6F77D1D6) --------------------------------------------------------
UINT __stdcall GetCodePageForFont(HANDLE h)
{
  UINT result; // eax@9
  BOOL v2; // eax@14
  struct tagCHARSETINFO v3; // [sp+0h] [bp-CCh]@14
  DWORD Type; // [sp+20h] [bp-ACh]@3
  DWORD cbData; // [sp+24h] [bp-A8h]@3
  HKEY phkResult; // [sp+28h] [bp-A4h]@2
  char pv; // [sp+2Ch] [bp-A0h]@1
  unsigned __int8 v8; // [sp+43h] [bp-89h]@4
  wchar_t pszSrc; // [sp+48h] [bp-84h]@2
  wchar_t pszDest; // [sp+88h] [bp-44h]@2

  if ( !GetObjectW(h, 92, &pv) )
    goto LABEL_20;
  StringCchCopyW(&pszDest, 0x20u, &pszSrc);
  if ( !RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes",
          0,
          0x20019u,
          &phkResult) )
  {
    cbData = 64;
    RegQueryValueExW(phkResult, &pszSrc, 0, &Type, (LPBYTE)&pszDest, &cbData);
    RegCloseKey(phkResult);
  }
  if ( (v8
     || StrCmpICW((int)L"Helv", (int)&pszDest)
     && StrCmpICW((int)L"Ms Sans Serif", (int)&pszDest)
     && StrCmpICW((int)L"Ms Serif", (int)&pszDest)
     && StrCmpICW((int)L"Tahoma", (int)&pszDest))
    && (v8 != -128 || StrCmpICW((int)nullsub_1, (int)&pszSrc))
    && StrCmpICW((int)&loc_6F78456C, (int)&pszSrc)
    && StrCmpICW((int)sub_6F784564, (int)&pszSrc) )
  {
    v2 = TranslateCharsetInfo((DWORD *)v8, &v3, 1u);
    result = v2 != 0 ? v3.ciACP : 0;
  }
  else
  {
LABEL_20:
    result = 0;
  }
  return result;
}
// 6F77D2E0: using guessed type wchar_t aTahoma[7];
// 6F77D2F0: using guessed type wchar_t aMsSerif[9];
// 6F77D304: using guessed type wchar_t aMsSansSerif[14];
// 6F77D320: using guessed type wchar_t aHelv[5];
// 6F78B474: using guessed type int __far nullsub_1();

//----- (6F77D3B6) --------------------------------------------------------
signed int __stdcall TV_Init(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+4h] [bp-28h]@1

  WndClass.lpfnWndProc = (WNDPROC)TV_WndProc;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.lpszClassName = L"SysTreeView32";
  WndClass.hbrBackground = 0;
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  WndClass.cbClsExtra = 0;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F77D410: using guessed type wchar_t c_szTreeViewClass[14];

//----- (6F77D431) --------------------------------------------------------
signed int __stdcall Tab_Init(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = (WNDPROC)Tab_WndProc;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"SysTabControl32";
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 16395;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F77D490: using guessed type wchar_t c_szTabControlClass[16];

//----- (6F77D4BA) --------------------------------------------------------
int __stdcall StrCmpICW(int a1, int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@3

  v2 = a2;
  v3 = a1;
  do
  {
    v4 = *(_WORD *)v3;
    v3 += 2;
    if ( (unsigned int)(v4 - 65) <= 0x19 )
      v4 += 32;
    v5 = *(_WORD *)v2;
    v2 += 2;
    if ( (unsigned int)(v5 - 65) <= 0x19 )
      v5 += 32;
  }
  while ( v4 && v4 == v5 );
  return v4 - v5;
}

//----- (6F77D4FB) --------------------------------------------------------
LPWSTR __stdcall StrChrW(LPCWSTR lpStart, WORD wMatch)
{
  LPWSTR result; // eax@1

  for ( result = (LPWSTR)lpStart; *result; ++result )
  {
    if ( *result == wMatch )
      return result;
  }
  return 0;
}

//----- (6F77D72B) --------------------------------------------------------
LRESULT __stdcall NewFont(HDC hDC, HGDIOBJ h, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  HGDIOBJ v5; // edi@1
  LRESULT result; // eax@4
  HGDIOBJ ho; // [sp+Ch] [bp-4h]@1
  HDC hDCa; // [sp+18h] [bp+8h]@1

  v3 = (int)hDC;
  v4 = *((_DWORD *)hDC + 11);
  ho = (HGDIOBJ)*((_DWORD *)hDC + 10);
  v5 = h;
  hDCa = GetDC(*(HWND *)hDC);
  if ( h )
  {
    *(_DWORD *)(v3 + 44) = 0;
    *(_DWORD *)(v3 + 40) = h;
    *(_DWORD *)(v3 + 76) = GetCodePageForFont(h);
  }
  else
  {
    if ( v4 )
    {
      v5 = *(HGDIOBJ *)(v3 + 40);
      goto LABEL_4;
    }
    v5 = CCCreateStatusFont();
    if ( !v5 )
      v5 = g_hfontSystem;
    *(_DWORD *)(v3 + 40) = v5;
    *(_DWORD *)(v3 + 44) = v5;
  }
  if ( v4 )
    DeleteObject(ho);
LABEL_4:
  GetNewMetrics(v3, hDCa, v5);
  ReleaseDC(*(HWND *)v3, hDCa);
  result = 0;
  if ( a3 )
    result = SendMessageW(*(HWND *)v3, 5u, 0, 0);
  return result;
}

//----- (6F77D79A) --------------------------------------------------------
void __stdcall GetNewMetrics(int a1, HDC hdc, HGDIOBJ h)
{
  HGDIOBJ v3; // edi@2
  LONG v4; // edx@6
  LONG v5; // eax@6
  struct tagTEXTMETRICW tm; // [sp+0h] [bp-3Ch]@4

  if ( h != (HGDIOBJ)-1 )
  {
    v3 = 0;
    if ( h )
      v3 = SelectObject(hdc, h);
    GetTextMetricsW(hdc, &tm);
    if ( v3 )
      SelectObject(hdc, v3);
    v4 = tm.tmInternalLeading;
    v5 = tm.tmInternalLeading + tm.tmHeight;
    *(_DWORD *)(a1 + 48) = tm.tmInternalLeading + tm.tmHeight;
    if ( !v4 )
      *(_DWORD *)(a1 + 48) = v5 + 2 * g_cyBorder;
  }
}

//----- (6F77D8C8) --------------------------------------------------------
BOOL __stdcall ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy)
{
  BOOL v3; // esi@1

  v3 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v3 = (*(int (__stdcall **)(HIMAGELIST, int *, int *))(*(_DWORD *)himl + 64))(himl, cx, cy) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v3;
}

//----- (6F77D910) --------------------------------------------------------
int __stdcall ImageList_GetImageCount(HIMAGELIST himl)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, int *))(*(_DWORD *)himl + 72))(himl, &v2);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F77D951) --------------------------------------------------------
__int32 __stdcall CImageList::GetImageCount(CImageList *this, int *a2)
{
  *a2 = *((_DWORD *)this + 7);
  return 0;
}

//----- (6F77D96C) --------------------------------------------------------
BOOL __stdcall ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO *pImageInfo)
{
  BOOL v3; // esi@1

  v3 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v3 = (*(int (__stdcall **)(HIMAGELIST, int, IMAGEINFO *))(*(_DWORD *)himl + 44))(himl, i, pImageInfo) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v3;
}

//----- (6F77D9B4) --------------------------------------------------------
BOOL __stdcall ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
{
  HIMAGELIST v10; // edi@1
  BOOL v11; // esi@1
  int v13; // [sp+8h] [bp-44h]@2
  HIMAGELIST Dst; // [sp+Ch] [bp-40h]@2
  int v15; // [sp+10h] [bp-3Ch]@2
  HDC v16; // [sp+14h] [bp-38h]@2
  int v17; // [sp+18h] [bp-34h]@2
  int v18; // [sp+1Ch] [bp-30h]@2
  int v19; // [sp+20h] [bp-2Ch]@2
  int v20; // [sp+24h] [bp-28h]@2
  COLORREF v21; // [sp+30h] [bp-1Ch]@2
  COLORREF v22; // [sp+34h] [bp-18h]@2
  UINT v23; // [sp+38h] [bp-14h]@2

  v10 = himl;
  v11 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    memset(&Dst, 0, 0x40u);
    v15 = i;
    v16 = hdcDst;
    v17 = x;
    v18 = y;
    v19 = dx;
    v20 = dy;
    v21 = rgbBk;
    v22 = rgbFg;
    v23 = fStyle;
    v13 = 68;
    Dst = v10;
    v11 = (*(int (__stdcall **)(HIMAGELIST, int *))(*(_DWORD *)himl + 32))(himl, &v13) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v11;
}

//----- (6F77DAF9) --------------------------------------------------------
signed int __stdcall CImageList::GetIconSize(CImageList *this, int *a2, int *a3)
{
  signed int result; // eax@3

  if ( a2 && a3 )
  {
    *a2 = *((_DWORD *)this + 10);
    *a3 = *((_DWORD *)this + 11);
    result = 0;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6F77DB2D) --------------------------------------------------------
signed int __thiscall CImageList::_SetOverlayImage(CImageList *this, SIZE_T uBytes, int a3)
{
  CImageList *v3; // esi@1
  SIZE_T v4; // edx@2
  char *v5; // eax@5
  int v6; // edi@6
  int v7; // ebx@6
  LPVOID v8; // edx@10
  signed int v9; // eax@12
  int v10; // ecx@12
  LONG v11; // edi@20
  int v12; // eax@22
  int v13; // esi@22
  signed int result; // eax@28
  int v15; // edi@33
  LONG j; // eax@34
  LONG v17; // eax@48
  bool v18; // zf@49
  int v19; // [sp+0h] [bp-4Ch]@0
  int v20; // [sp+4h] [bp-48h]@0
  int v21; // [sp+8h] [bp-44h]@0
  int x1; // [sp+Ch] [bp-40h]@6
  int y1; // [sp+10h] [bp-3Ch]@6
  int v24; // [sp+14h] [bp-38h]@6
  int v25; // [sp+18h] [bp-34h]@6
  struct tagRECT rc; // [sp+1Ch] [bp-30h]@6
  SIZE_T v27; // [sp+2Ch] [bp-20h]@31
  HGDIOBJ h; // [sp+30h] [bp-1Ch]@7
  HDC hdc; // [sp+34h] [bp-18h]@8
  int v30; // [sp+38h] [bp-14h]@1
  unsigned int v31; // [sp+3Ch] [bp-10h]@6
  LPVOID lpvBits; // [sp+40h] [bp-Ch]@9
  LONG i; // [sp+44h] [bp-8h]@12
  int v34; // [sp+48h] [bp-4h]@11

  --a3;
  v3 = this;
  v30 = 1;
  if ( *((_DWORD *)this + 22)
    && (v4 = uBytes, (uBytes & 0x80000000) == 0)
    && (signed int)uBytes < *((_DWORD *)this + 9)
    && (unsigned int)a3 <= 0xE )
  {
    v5 = (char *)this + 4 * a3 + 92;
    if ( *(_DWORD *)v5 == (signed __int16)uBytes )
    {
      result = 0;
    }
    else
    {
      *(_DWORD *)v5 = (signed __int16)uBytes;
      (*(void (__stdcall **)(char *, SIZE_T, int *, int, int, int))(*((_DWORD *)this + 2) + 60))(
        (char *)this + 8,
        v4,
        &x1,
        v19,
        v20,
        v21);
      SetRect(&rc, 0x7FFF, 0x7FFF, 0, 0);
      v6 = v24 - x1;
      v7 = v25 - y1;
      v31 = 2 * ((unsigned int)(v24 - x1 + 15) >> 4);
      if ( ULongLongToULong((unsigned int)(v25 - y1) * (unsigned __int64)v31, &uBytes) < 0 )
      {
        result = -2147467259;
      }
      else
      {
        h = CreateBitmap(v6, v7, 1u, 1u, 0);
        if ( h )
        {
          hdc = CreateCompatibleDC(*((HDC *)v3 + 22));
          if ( hdc )
          {
            lpvBits = LocalAlloc(0, uBytes);
            if ( lpvBits )
            {
              SelectObject(hdc, h);
              BitBlt(hdc, 0, 0, v6, v7, *((HDC *)v3 + 22), x1, y1, 0xCC0020u);
              GetBitmapBits((HBITMAP)h, uBytes, lpvBits);
              uBytes = 0;
              v8 = lpvBits;
              v30 = (int)lpvBits;
              if ( v7 > 0 )
              {
                v34 = v6 >> 3;
                do
                {
                  v9 = 0;
                  v10 = 0;
                  for ( i = 0; v10 < v34; i = v9 )
                  {
                    if ( *(_BYTE *)(v10 + v30) != -1 )
                      break;
                    v9 += 8;
                    ++v10;
                  }
                  if ( v9 < v6 )
                  {
                    v27 = v31 * uBytes;
                    do
                    {
                      v18 = ((unsigned __int8)(1 << (7 - (v9 & 7))) & *((_BYTE *)lpvBits + v27 + (v9 >> 3))) == 0;
                      v17 = i;
                      if ( v18 )
                      {
                        if ( rc.left >= i )
                          rc.left = i;
                        if ( rc.right <= i + 1 )
                          rc.right = i + 1;
                        if ( rc.top >= (signed int)uBytes )
                          rc.top = uBytes;
                        if ( rc.bottom <= (signed int)(uBytes + 1) )
                          rc.bottom = uBytes + 1;
                        if ( i >= rc.left && i < rc.right )
                          v17 = rc.right - 1;
                      }
                      v9 = v17 + 1;
                      i = v9;
                    }
                    while ( v9 < v6 );
                  }
                  ++uBytes;
                  v30 += v31;
                }
                while ( (signed int)uBytes < v7 );
                v8 = lpvBits;
              }
              if ( rc.left == 0x7FFF )
                rc.left = 0;
              v11 = rc.top;
              if ( rc.top == 0x7FFF )
              {
                v11 = 0;
                rc.top = 0;
              }
              uBytes = v11;
              v12 = a3;
              *((_DWORD *)v3 + a3 + 68) = (signed __int16)(LOWORD(rc.right) - rc.left);
              *((_DWORD *)v3 + v12 + 83) = (signed __int16)(LOWORD(rc.bottom) - v11);
              *((_DWORD *)v3 + v12 + 38) = (signed __int16)rc.left;
              *((_DWORD *)v3 + v12 + 53) = (signed __int16)v11;
              v13 = (int)((char *)v3 + 4 * v12 + 392);
              *(_DWORD *)v13 = 0;
              if ( v11 < rc.bottom )
              {
                v15 = v31 * v11;
                do
                {
                  for ( j = rc.left;
                        j < rc.right && !((unsigned __int8)(1 << (7 - (j & 7))) & *((_BYTE *)v8 + v15 + (j >> 3)));
                        ++j )
                    ;
                  if ( j != rc.right )
                    break;
                  ++uBytes;
                  v15 += v31;
                }
                while ( (signed int)uBytes < rc.bottom );
              }
              if ( uBytes == rc.bottom )
                *(_DWORD *)v13 = 32;
              LocalFree(v8);
              v30 = 0;
            }
            DeleteDC(hdc);
          }
          DeleteObject(h);
        }
        result = v30;
      }
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6F77DD39) --------------------------------------------------------
int __stdcall CImageList::GetImageInfo(CImageList *this, int a2, struct _IMAGEINFO *a3)
{
  int result; // eax@4

  if ( a3 && a2 >= 0 && a2 < *((_DWORD *)this + 7) )
  {
    a3->hbmImage = (HBITMAP)*((_DWORD *)this + 17);
    a3->hbmMask = (HBITMAP)*((_DWORD *)this + 18);
    result = (*(int (__stdcall **)(CImageList *, int, RECT *))(*(_DWORD *)this + 60))(this, a2, &a3->rcImage);
  }
  else
  {
    result = -2147467261;
  }
  return result;
}

//----- (6F77DD83) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_Duplicate(HIMAGELIST himl)
{
  struct _IMAGELIST *v2; // [sp+4h] [bp-4h]@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, GUID *, int *))(*(_DWORD *)himl + 56))(
      himl,
      &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950,
      &v2);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F77DDC8) --------------------------------------------------------
BOOL __stdcall ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask)
{
  BOOL v4; // esi@1

  v4 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v4 = (*(int (__stdcall **)(HIMAGELIST, int, HBITMAP, HBITMAP))(*(_DWORD *)himl + 24))(himl, i, hbmImage, hbmMask) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v4;
}

//----- (6F77DE13) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_Read(struct IStream *pstm)
{
  int v1; // eax@1
  int v2; // esi@2

  v1 = (int)operator new(0x608u);
  if ( v1 )
    v2 = CImageList::CImageList(v1);
  else
    v2 = 0;
  if ( v2 )
  {
    if ( (*(int (__stdcall **)(int, struct IStream *))(*(_DWORD *)(v2 + 16) + 20))(v2 + 16, pstm) >= 0 )
      return (HIMAGELIST)(v2 + 8);
    (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
  }
  return 0;
}

//----- (6F77DEC5) --------------------------------------------------------
int __stdcall Stream_ReadBitmap(struct IStream *a1, UINT start, HBITMAP *a3)
{
  struct IStreamVtbl *v3; // eax@1
  int v4; // ebx@1
  int v5; // edi@5
  ULONG v6; // ebx@5
  LONG v7; // esi@7
  HBITMAP v9; // eax@21
  int v10; // edi@23
  int v11; // esi@23
  BITMAPINFO bmi; // [sp+Ch] [bp-44Ch]@1
  __int16 v13; // [sp+434h] [bp-24h]@1
  int nWidth; // [sp+444h] [bp-14h]@5
  HDC hdc; // [sp+448h] [bp-10h]@9
  int nHeight; // [sp+44Ch] [bp-Ch]@5
  void *lpBits; // [sp+450h] [bp-8h]@1
  HBITMAP hbm; // [sp+454h] [bp-4h]@1
  int starta; // [sp+464h] [bp+Ch]@24

  bmi.bmiHeader.biSize = 0;
  memset(&bmi.bmiHeader.biWidth, 0, 0x424u);
  v3 = a1->lpVtbl;
  lpBits = 0;
  hbm = 0;
  v4 = v3->Read(a1, &v13, 14, 0);
  if ( v4 >= 0 )
  {
    v4 = -2147024809;
    if ( v13 == 19778 )
    {
      v4 = a1->lpVtbl->Read(a1, &bmi, 40, 0);
      if ( v4 >= 0 )
      {
        v4 = -2147024809;
        if ( bmi.bmiHeader.biSize == 40 )
        {
          nHeight = bmi.bmiHeader.biHeight;
          v5 = bmi.bmiHeader.biBitCount * bmi.bmiHeader.biPlanes;
          v6 = 0;
          nWidth = bmi.bmiHeader.biWidth;
          if ( v5 <= 8 )
            v6 = 4 * (1 << v5);
          v7 = bmi.bmiHeader.biWidth * v5;
          bmi.bmiHeader.biSizeImage = 4 * bmi.bmiHeader.biHeight * ((bmi.bmiHeader.biWidth * v5 + 31) / 32);
          if ( !v6 || (v4 = a1->lpVtbl->Read(a1, bmi.bmiColors, v6, 0), v4 >= 0) )
          {
            hdc = GetDC(0);
            if ( v5 <= 1 )
            {
              v9 = CreateMonoBitmap(nWidth, nHeight);
            }
            else
            {
              if ( start != 254 )
              {
                v4 = -2147024882;
                hbm = CreateDIBSection(hdc, &bmi, 0, &lpBits, 0, 0);
                if ( hbm )
                {
                  v4 = a1->lpVtbl->Read(a1, lpBits, bmi.bmiHeader.biSizeImage, 0);
                  if ( v4 >= 0 )
                  {
                    lpBits = 0;
LABEL_14:
                    v4 = 0;
                    goto LABEL_15;
                  }
                }
                goto LABEL_15;
              }
              v9 = CreateColorBitmap(nWidth, nHeight);
            }
            hbm = v9;
            v4 = -2147024882;
            if ( v9 )
            {
              v10 = (v7 + 31) / 32;
              v11 = 4096 / (4 * v10);
              lpBits = LocalAlloc(0x40u, 0x1000u);
              if ( lpBits )
              {
                starta = 0;
                if ( nHeight > 0 )
                {
                  while ( 1 )
                  {
                    if ( v11 > nHeight - starta )
                      v11 = nHeight - starta;
                    v4 = a1->lpVtbl->Read(a1, lpBits, 4 * v11 * v10, 0);
                    if ( v4 < 0 )
                      goto LABEL_15;
                    v4 = -2147024882;
                    if ( !SetDIBits(hdc, hbm, starta, v11, lpBits, &bmi, 0) )
                      goto LABEL_15;
                    starta += v11;
                    if ( starta >= nHeight )
                      goto LABEL_14;
                  }
                }
                goto LABEL_14;
              }
            }
LABEL_15:
            if ( hdc )
              ReleaseDC(0, hdc);
            goto LABEL_17;
          }
        }
      }
    }
  }
LABEL_17:
  if ( lpBits )
    LocalFree(lpBits);
  if ( v4 < 0 && hbm )
  {
    DeleteObject(hbm);
    hbm = 0;
  }
  *a3 = hbm;
  return v4;
}

//----- (6F77E0CE) --------------------------------------------------------
int __stdcall CImageList::Clone(HGDIOBJ h, const struct _GUID *a2, void **a3)
{
  int v3; // esi@1
  HGDIOBJ v4; // edi@1
  int v5; // eax@4
  HDC v6; // eax@5
  HBRUSH v8; // eax@17
  COLORREF v9; // ST10_4@17
  int v10; // [sp+Ch] [bp-8h]@1
  HBITMAP v11; // [sp+10h] [bp-4h]@1
  HBITMAP ha; // [sp+1Ch] [bp+8h]@1

  v3 = 0;
  v11 = 0;
  v10 = 0;
  *a3 = 0;
  EnterCriticalSection(&g_csDll);
  v4 = h;
  ha = CImageList::_CopyBitmap(*((HBITMAP *)h + 17), *((HDC *)h + 19));
  if ( ha )
  {
    if ( *((_DWORD *)v4 + 20) && (v11 = CImageList::_CopyBitmap(*((HBITMAP *)v4 + 18), *((HDC *)v4 + 20))) == 0 )
    {
      v10 = -2147024882;
    }
    else
    {
      v5 = CImageList::Create(*((_DWORD *)v4 + 10), *((_DWORD *)v4 + 11), *((_DWORD *)v4 + 13), 0, *((_DWORD *)v4 + 9));
      v3 = v5;
      if ( v5 )
      {
        SelectObject(*(HDC *)(v5 + 84), ha);
        CImageList::_DeleteBitmap(*(HBITMAP *)(v3 + 76));
        v6 = *(HDC *)(v3 + 88);
        if ( v6 )
        {
          SelectObject(v6, v11);
          CImageList::_DeleteBitmap(*(HBITMAP *)(v3 + 80));
        }
        *(_DWORD *)(v3 + 76) = ha;
        *(_DWORD *)(v3 + 80) = v11;
        *(_DWORD *)(v3 + 36) = *((_DWORD *)v4 + 7);
        *(_DWORD *)(v3 + 40) = *((_DWORD *)v4 + 8);
        *(_DWORD *)(v3 + 56) = *((_DWORD *)v4 + 12);
        *(_DWORD *)(v3 + 64) = *((_DWORD *)v4 + 14);
        *(_DWORD *)(v3 + 68) = *((_DWORD *)v4 + 15);
        if ( *(_DWORD *)(v3 + 72) )
          DeleteObject(*(HGDIOBJ *)(v3 + 72));
        if ( *(_DWORD *)(v3 + 68) == -1 )
        {
          *(_DWORD *)(v3 + 72) = GetStockObject(4);
          *(_DWORD *)(v3 + 28) = 1;
        }
        else
        {
          v8 = CreateSolidBrush(*(_DWORD *)(v3 + 68));
          v9 = *(_DWORD *)(v3 + 68);
          *(_DWORD *)(v3 + 72) = v8;
          *(_DWORD *)(v3 + 28) = GetNearestColor32(*(HDC *)(v3 + 84), v9) == *(_DWORD *)(v3 + 68);
        }
      }
    }
    LeaveCriticalSection(&g_csDll);
    if ( v10 < 0 )
    {
      CImageList::_DeleteBitmap(ha);
      if ( v11 )
        CImageList::_DeleteBitmap(v11);
    }
    if ( v3 )
    {
      v10 = (**(int (__stdcall ***)(_DWORD, _DWORD, _DWORD))v3)(v3, a2, a3);
      (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
    }
  }
  else
  {
    v10 = -2147024882;
  }
  return v10;
}

//----- (6F77E205) --------------------------------------------------------
HBITMAP __stdcall CImageList::_CopyBitmap(HBITMAP h, HDC hdc)
{
  HBITMAP v3; // ebx@1
  HBITMAP v4; // eax@2
  char pv; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@2
  int cy; // [sp+10h] [bp-10h]@2

  v3 = 0;
  if ( GetObjectW(h, 24, &pv) == 24 )
  {
    EnterCriticalSection(&g_csDll);
    v4 = CreateCompatibleBitmap(hdc, v7, cy);
    v3 = v4;
    if ( v4 )
    {
      CImageList::SelectDstBitmap(v4);
      BitBlt(g_hdcDst, 0, 0, v7, cy, hdc, 0, 0, 0xCC0020u);
      CImageList::SelectDstBitmap(0);
    }
    LeaveCriticalSection(&g_csDll);
  }
  return v3;
}

//----- (6F77E288) --------------------------------------------------------
signed int __stdcall CImageList::Load(CImageList *this, struct IStream *a2)
{
  int v2; // esi@2
  struct IStreamVtbl *v3; // eax@3
  int v5; // eax@30
  int v6; // eax@31
  HGDIOBJ v7; // [sp+Ch] [bp-4Ch]@26
  int v8; // [sp+10h] [bp-48h]@3
  HBITMAP v9; // [sp+14h] [bp-44h]@7
  HGDIOBJ ho; // [sp+18h] [bp-40h]@7
  HGDIOBJ v11; // [sp+1Ch] [bp-3Ch]@7
  __int16 v12; // [sp+20h] [bp-38h]@3
  __int16 Dst; // [sp+22h] [bp-36h]@3
  int v14; // [sp+32h] [bp-26h]@7
  char v15; // [sp+3Ch] [bp-1Ch]@24

  if ( a2 )
  {
    v2 = ImageList_InitGlobals();
    if ( v2 < 0 )
      return v2;
    EnterCriticalSection(&g_csDll);
    v12 = 0;
    memset(&Dst, 0, 0x30u);
    v3 = a2->lpVtbl;
    v8 = 0;
    v2 = v3->Read(a2, &v12, 28, 0);
    if ( v2 < 0 )
      goto LABEL_16;
    if ( v12 != 19529 || Dst != 257 )
      v2 = -2147467259;
    if ( v2 < 0 )
      goto LABEL_16;
    v11 = 0;
    v9 = 0;
    v2 = Stream_ReadBitmap(a2, v14 & 0xFE, (HBITMAP *)&ho);
    if ( v2 < 0 )
      goto LABEL_16;
    if ( v14 & 1 )
    {
      v2 = Stream_ReadBitmap(a2, 0, (HBITMAP *)&v11);
      if ( v2 >= 0 )
      {
LABEL_10:
        if ( v14 & 0x1000 )
        {
          v2 = a2->lpVtbl->Read(a2, &v15, 22, 0);
          if ( v2 < 0 )
            goto LABEL_16;
          LOWORD(v14) = v14 & 0xEFFF;
        }
        if ( v2 >= 0 )
        {
          if ( v14 & 0x2000 )
          {
            LOWORD(v14) = v14 & 0xDFFF;
            v8 = 1;
            v2 = Stream_ReadBitmap(a2, v14 & 0xFE, (HBITMAP *)&v7);
            if ( v2 < 0 )
              goto LABEL_16;
            if ( v14 & 1 )
            {
              v2 = Stream_ReadBitmap(a2, 0, &v9);
              if ( v2 >= 0 )
                goto LABEL_14;
              DeleteObject(v7);
            }
          }
          if ( v2 >= 0 )
          {
LABEL_14:
            v2 = CImageList::_Read(
                   (CImageList *)((char *)this - 16),
                   (const struct _ILFILEHEADER *)&v12,
                   (HBITMAP)ho,
                   (HBITMAP)v11);
            if ( v2 >= 0 && v8 )
            {
              v5 = (int)operator new(0x608u);
              if ( v5 )
                v6 = CImageList::CImageList(v5);
              else
                v6 = 0;
              *((_DWORD *)this + 109) = v6;
              if ( v6 )
              {
                CImageList::_Read((CImageList *)v6, (const struct _ILFILEHEADER *)&v12, (HBITMAP)v7, v9);
              }
              else
              {
                v2 = -2147024882;
                DeleteObject(ho);
                if ( v11 )
                  DeleteObject(v11);
              }
            }
            goto LABEL_16;
          }
        }
LABEL_16:
        LeaveCriticalSection(&g_csDll);
        return v2;
      }
      DeleteObject(ho);
    }
    if ( v2 < 0 )
      goto LABEL_16;
    goto LABEL_10;
  }
  return -2147024809;
}

//----- (6F77E3DA) --------------------------------------------------------
signed int __thiscall CImageList::_Read(CImageList *this, const struct _ILFILEHEADER *a2, HBITMAP h, HBITMAP ho)
{
  const struct _ILFILEHEADER *v4; // edi@1
  CImageList *v5; // esi@1
  HDC v6; // eax@2
  int v7; // eax@4
  int v8; // eax@4
  SIZE_T *v9; // edi@4
  int v10; // ebx@5
  signed int v12; // [sp+10h] [bp+8h]@1

  v4 = a2;
  v5 = this;
  v12 = CImageList::Initialize(this, *((_WORD *)a2 + 5), *((_WORD *)a2 + 6), *((_WORD *)a2 + 9), 1, *((_WORD *)a2 + 4));
  if ( v12 < 0 )
  {
    DeleteObject(h);
    DeleteObject(ho);
  }
  else
  {
    SelectObject(*((HDC *)v5 + 21), h);
    DeleteObject(*((HGDIOBJ *)v5 + 19));
    *((_DWORD *)v5 + 16) = -1;
    *((_DWORD *)v5 + 19) = h;
    v6 = (HDC)*((_DWORD *)v5 + 22);
    if ( v6 )
    {
      SelectObject(v6, ho);
      DeleteObject(*((HGDIOBJ *)v5 + 20));
      *((_DWORD *)v5 + 20) = ho;
    }
    v7 = *((_WORD *)v4 + 3);
    *((_DWORD *)v5 + 9) = 0;
    *((_DWORD *)v5 + 10) = v7;
    CImageList::_SetBkColor(v5, *(_DWORD *)((char *)v4 + 14));
    *((_DWORD *)v5 + 9) = *((_WORD *)v4 + 2);
    v8 = 0;
    v9 = (SIZE_T *)((char *)v4 + 20);
    do
    {
      v10 = v8 + 1;
      CImageList::_SetOverlayImage(v5, *(_WORD *)v9, v8 + 1);
      v8 = v10;
      v9 = (SIZE_T *)((char *)v9 + 2);
    }
    while ( v10 < 15 );
  }
  return v12;
}

//----- (6F77E494) --------------------------------------------------------
int __cdecl _VEC_memzero(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // edx@2
  unsigned int v6; // [sp+4h] [bp-Ch]@2

  result = a1;
  v4 = (unsigned __int8)((char)a1 % -16);
  if ( (char)a1 % -16 )
  {
    memset((void *)a1, 0, 16 - v4);
    sub_6F77E492((void *)(16 - v4 + a1), 0, a3 - (16 - v4));
    result = a1;
  }
  else
  {
    v5 = a3 & 0x7F;
    v6 = v5;
    if ( a3 != v5 )
    {
      sub_6F77E4FC(a1, a3 - v5);
      result = a1;
      v5 = v6;
    }
    if ( v5 )
    {
      memset((void *)(a3 + result - v5), 0, v6);
      result = a1;
    }
  }
  return result;
}

//----- (6F77E4FC) --------------------------------------------------------
void __cdecl sub_6F77E4FC(int a1, unsigned int a2)
{
  int v2; // edi@1
  unsigned int v3; // ecx@1

  v2 = a1;
  v3 = a2 >> 7;
  do
  {
    _mm_store_si128((__m128i *)v2, 0i64);
    _mm_store_si128((__m128i *)(v2 + 16), 0i64);
    _mm_store_si128((__m128i *)(v2 + 32), 0i64);
    _mm_store_si128((__m128i *)(v2 + 48), 0i64);
    _mm_store_si128((__m128i *)(v2 + 64), 0i64);
    _mm_store_si128((__m128i *)(v2 + 80), 0i64);
    _mm_store_si128((__m128i *)(v2 + 96), 0i64);
    _mm_store_si128((__m128i *)(v2 + 112), 0i64);
    v2 += 128;
    --v3;
  }
  while ( v3 );
}

//----- (6F77E550) --------------------------------------------------------
HLOCAL __stdcall PrivateLocalReAllocArray(HLOCAL hMem, int a2, int a3)
{
  HLOCAL v3; // esi@1
  SIZE_T uBytes; // [sp+4h] [bp-4h]@1

  v3 = 0;
  uBytes = 0;
  if ( ULongLongToULong((unsigned int)a3 * (unsigned __int64)(unsigned int)a2, &uBytes) >= 0 )
    v3 = CCLocalReAlloc(hMem, uBytes);
  return v3;
}

//----- (6F77E58A) --------------------------------------------------------
PVOID __stdcall DSA_GetItemPtr(HDSA hdsa, int i)
{
  PVOID result; // eax@3

  if ( i < 0 || i >= *(_DWORD *)hdsa )
    result = 0;
  else
    result = (PVOID)(*((_DWORD *)hdsa + 1) + i * *((_DWORD *)hdsa + 3));
  return result;
}

//----- (6F77E5CC) --------------------------------------------------------
HDSA __stdcall DSA_Create(int cbItem, int cItemGrow)
{
  HDSA result; // eax@1
  int v3; // ecx@3

  result = 0;
  if ( cbItem > 0 )
  {
    result = (HDSA)Alloc(0x14u);
    if ( result )
    {
      v3 = cItemGrow;
      *((_DWORD *)result + 3) = cbItem;
      if ( cItemGrow <= 0 )
        v3 = 1;
      *((_DWORD *)result + 4) = v3;
    }
  }
  return result;
}

//----- (6F77E601) --------------------------------------------------------
int __stdcall DSA_InsertItem(HDSA hdsa, int i, const void *pitem)
{
  int v3; // ebx@1
  int v4; // eax@2
  ULONG v5; // ecx@5
  HLOCAL v6; // eax@7
  int v7; // eax@9
  size_t v8; // eax@10
  unsigned int v10; // edi@14

  v3 = i;
  if ( i < 0 )
    return -1;
  v4 = *(_DWORD *)hdsa;
  if ( *(_DWORD *)hdsa == 0x7FFFFFFF )
    return -1;
  if ( i > v4 )
    v3 = *(_DWORD *)hdsa;
  v5 = *((_DWORD *)hdsa + 2);
  if ( v4 + 1 > (signed int)v5 )
  {
    i = 0;
    if ( ULongAdd(v5, *((_DWORD *)hdsa + 4), (ULONG *)&i) >= 0 )
    {
      v6 = PrivateLocalReAllocArray(*((HLOCAL *)hdsa + 1), i, *((_DWORD *)hdsa + 3));
      if ( v6 )
      {
        *((_DWORD *)hdsa + 1) = v6;
        *((_DWORD *)hdsa + 2) += *((_DWORD *)hdsa + 4);
        goto LABEL_9;
      }
    }
    return -1;
  }
LABEL_9:
  v7 = *(_DWORD *)hdsa;
  if ( v3 >= *(_DWORD *)hdsa )
  {
LABEL_10:
    v8 = *((_DWORD *)hdsa + 3);
    ++*(_DWORD *)hdsa;
    memmove((void *)(*((_DWORD *)hdsa + 1) + v3 * v8), pitem, v8);
    return v3;
  }
  v10 = *((_DWORD *)hdsa + 3);
  i = 0;
  if ( ULongLongToULong(v10 * (unsigned __int64)(unsigned int)(v7 - v3), (ULONG *)&i) >= 0 )
  {
    memmove((void *)(*((_DWORD *)hdsa + 1) + v10 * (v3 + 1)), (const void *)(*((_DWORD *)hdsa + 1) + v3 * v10), i);
    goto LABEL_10;
  }
  return -1;
}
// 6F77E601: could not find valid save-restore pair for esi

//----- (6F77E697) --------------------------------------------------------
BOOL __stdcall DSA_Destroy(HDSA hdsa)
{
  BOOL result; // eax@3

  if ( hdsa )
  {
    if ( !*((_DWORD *)hdsa + 1) || (result = Free(*((HLOCAL *)hdsa + 1))) != 0 )
      result = Free((HLOCAL)hdsa);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F77E6C9) --------------------------------------------------------
BOOL __stdcall Free(HLOCAL hMem)
{
  return LocalFree(hMem) == 0;
}

//----- (6F77E729) --------------------------------------------------------
HRESULT __stdcall StringCbCopyW(STRSAFE_LPWSTR pszDest, size_t cbDest, STRSAFE_LPCWSTR pszSrc)
{
  int v3; // edx@1
  HRESULT result; // eax@1

  v3 = cbDest >> 1;
  result = 0;
  if ( !(cbDest >> 1) || (unsigned int)v3 > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
    result = sub_6F77E766((int)pszSrc, v3, (int)pszDest, 0, 2147483646);
  return result;
}

//----- (6F77E766) --------------------------------------------------------
signed int __userpurge sub_6F77E766@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  signed int result; // eax@1
  int v8; // edi@1

  v5 = a1;
  v6 = a2;
  result = 0;
  v8 = 0;
  if ( !a2 )
    goto LABEL_12;
  do
  {
    if ( !a5 )
      break;
    if ( !*(_WORD *)v5 )
      break;
    *(_WORD *)a3 = *(_WORD *)v5;
    a3 += 2;
    v5 += 2;
    --v6;
    --a5;
    ++v8;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_12:
    a3 -= 2;
    --v8;
    result = -2147024774;
  }
  *(_WORD *)a3 = 0;
  if ( a4 )
    *(_DWORD *)a4 = v8;
  return result;
}

//----- (6F77E7E1) --------------------------------------------------------
int __stdcall RegisterClassNameW(LPCWSTR lpString2)
{
  int v1; // esi@5
  signed int v2; // ebx@1
  unsigned int v3; // esi@1
  LPCWSTR *v4; // edi@1

  v2 = 0;
  v3 = 0;
  v4 = (LPCWSTR *)&off_6F7E602C;
  while ( lstrcmpiW(*v4, lpString2) )
  {
    ++v3;
    v4 += 4;
    if ( v3 >= 0x13 )
      return v2;
  }
  v1 = 4 * v3;
  if ( (*(int (__stdcall **)(int))((char *)&icc + v1 * 4))((int)g_hinst) )
  {
    dword_6F7E6034[v1] = 1;
    v2 = 1;
  }
  return v2;
}
// 6F7E6028: using guessed type int (__stdcall *icc)(int);
// 6F7E602C: using guessed type wchar_t *off_6F7E602C;
// 6F7E6034: using guessed type int dword_6F7E6034[];

//----- (6F77E818) --------------------------------------------------------
void __cdecl sub_6F77E818(int a1, int a2, unsigned int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  unsigned int v5; // ecx@1
  __m128i v6; // xmm1@2
  __m128i v7; // xmm2@2
  __m128i v8; // xmm3@2
  __m128i v9; // xmm5@2
  __m128i v10; // xmm6@2
  __m128i v11; // xmm7@2

  v3 = a2;
  v4 = a1;
  v5 = a3 >> 7;
  do
  {
    v6 = _mm_load_si128((const __m128i *)(v3 + 16));
    v7 = _mm_load_si128((const __m128i *)(v3 + 32));
    v8 = _mm_load_si128((const __m128i *)(v3 + 48));
    _mm_store_si128((__m128i *)v4, _mm_load_si128((const __m128i *)v3));
    _mm_store_si128((__m128i *)(v4 + 16), v6);
    _mm_store_si128((__m128i *)(v4 + 32), v7);
    _mm_store_si128((__m128i *)(v4 + 48), v8);
    v9 = _mm_load_si128((const __m128i *)(v3 + 80));
    v10 = _mm_load_si128((const __m128i *)(v3 + 96));
    v11 = _mm_load_si128((const __m128i *)(v3 + 112));
    _mm_store_si128((__m128i *)(v4 + 64), _mm_load_si128((const __m128i *)(v3 + 64)));
    _mm_store_si128((__m128i *)(v4 + 80), v9);
    _mm_store_si128((__m128i *)(v4 + 96), v10);
    _mm_store_si128((__m128i *)(v4 + 112), v11);
    v3 += 128;
    v4 += 128;
    --v5;
  }
  while ( v5 );
}

//----- (6F77E8C2) --------------------------------------------------------
int __cdecl _VEC_memcpy(int a1, int a2, unsigned int a3)
{
  int v3; // ecx@1
  int result; // eax@1
  int v5; // edi@1
  int v6; // ecx@2
  int v7; // ecx@8
  unsigned int v8; // [sp+4h] [bp-18h]@2

  v3 = (unsigned __int8)((char)a2 % -16);
  result = a1;
  v5 = (unsigned __int8)((char)a1 % -16);
  if ( v5 | v3 )
  {
    if ( v3 == v5 )
    {
      v7 = -v3;
      qmemcpy((void *)a1, (const void *)a2, v7 + 16);
      sub_6F77E8C0((void *)(v7 + 16 + a1), (const void *)(v7 + 16 + a2), a3 - (v7 + 16));
      result = a1;
    }
    else
    {
      qmemcpy((void *)a1, (const void *)a2, a3);
      result = a1;
    }
  }
  else
  {
    v6 = a3 & 0x7F;
    v8 = v6;
    if ( a3 != v6 )
    {
      sub_6F77E818(a1, a2, a3 - v6);
      result = a1;
      v6 = v8;
    }
    if ( v6 )
    {
      qmemcpy((void *)(result + a3 - v6), (const void *)(a3 + a2 - v6), v8);
      result = a1;
    }
  }
  return result;
}

//----- (6F77E9AF) --------------------------------------------------------
LPARAM __stdcall ReBarWndProc(HWND a1, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LPARAM v4; // ebx@1
  int v5; // esi@1
  UINT v6; // eax@2
  LPARAM result; // eax@11
  HWND v8; // esi@37
  HWND v9; // eax@39
  int v10; // eax@46
  HDC v11; // edi@28
  HWND v12; // ST1C_4@62
  int v13; // eax@62
  int v14; // ebx@62
  int v15; // edi@63
  bool v16; // zf@68
  LONG v17; // eax@68
  int v18; // eax@69
  HWND v19; // ST2C_4@70
  int v20; // eax@73
  int v21; // edi@82
  int v22; // eax@82
  unsigned int i; // ebx@82
  const CHAR *v24; // ecx@87
  HWND v25; // eax@89
  signed int v26; // eax@95
  signed int v27; // esi@97
  LONG v28; // eax@101
  HWND v29; // eax@101
  HWND v30; // eax@106
  HWND v31; // ST2C_4@109
  WPARAM v32; // edi@122
  int v33; // eax@130
  POINT v34; // ST28_8@141
  WPARAM v35; // eax@144
  int v36; // esi@156
  int v37; // edi@189
  HWND v38; // ST24_4@195
  HLOCAL v39; // eax@223
  int v40; // esi@223
  HWND v41; // ST28_4@224
  int v42; // eax@224
  HWND v43; // ST24_4@225
  void *v44; // edi@227
  HFONT v45; // eax@227
  LPARAM v46; // [sp+Ch] [bp-23Ch]@101
  int v47; // [sp+10h] [bp-238h]@101
  HWND v48; // [sp+14h] [bp-234h]@101
  LPARAM v49; // [sp+18h] [bp-230h]@56
  int v50; // [sp+24h] [bp-224h]@56
  LONG v51; // [sp+2Ch] [bp-21Ch]@56
  LONG v52; // [sp+30h] [bp-218h]@56
  LONG v53; // [sp+34h] [bp-214h]@56
  LPSTR lpMultiByteStr; // [sp+38h] [bp-210h]@87
  struct tagRECT Rect; // [sp+3Ch] [bp-20Ch]@28
  HWND hWnd; // [sp+4Ch] [bp-1FCh]@1
  int pvParam; // [sp+50h] [bp-1F8h]@226
  LOGFONTW lf; // [sp+68h] [bp-1E0h]@227

  v4 = lParam;
  hWnd = a1;
  v5 = GetWindowLongW(a1, 0);
  if ( !v5 && Msg != 129 )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  v6 = Msg;
  if ( Msg > 0x406 )
  {
    if ( Msg > 0x42B )
    {
      if ( Msg == 8194 )
      {
        if ( lParam )
        {
          if ( *(_DWORD *)lParam == 12 )
          {
            v38 = hWnd;
            *(_DWORD *)(v5 + 128) = *(_DWORD *)(lParam + 4);
            *(_DWORD *)(v5 + 132) = *(_DWORD *)(lParam + 8);
            InvalidateRect(v38, 0, 0);
            if ( *(_DWORD *)(v5 + 8) & 0x800000 )
              CCInvalidateFrame(hWnd);
          }
        }
        return 0;
      }
      if ( Msg == 8195 )
      {
        if ( lParam && *(_DWORD *)lParam == 12 )
        {
          v36 = v5 + 124;
          *(_DWORD *)lParam = *(_DWORD *)v36;
          v36 += 4;
          *(_DWORD *)(lParam + 4) = *(_DWORD *)v36;
          *(_DWORD *)(lParam + 8) = *(_DWORD *)(v36 + 4);
        }
        return lParam;
      }
      if ( Msg == 8196 )
      {
        if ( !*(_DWORD *)(v5 + 44) )
          *(_DWORD *)(v5 + 44) = CreateDragProxy(*(_DWORD *)v5, (int)RebarDragCallback, 0);
        GetDragProxyTarget(*(_DWORD *)(v5 + 44), lParam);
        return 0;
      }
      goto LABEL_177;
    }
    if ( Msg == 1067 )
    {
      if ( wParam < *(_DWORD *)(v5 + 52) )
        RBOnPushChevron((int)hWnd, v5, *(_DWORD *)(v5 + 104) + 120 * wParam, lParam);
      return 0;
    }
    switch ( Msg )
    {
      case 0x425u:
        return (LPARAM)RBSetPalette(v5, (void *)lParam);
      case 0x426u:
        return *(_DWORD *)(v5 + 36);
      case 0x423u:
        return RBShowBand(v5, wParam, lParam);
      case 0x41Du:
        hWnd = 0;
        v16 = (*(_BYTE *)(lParam + 4) & 4) == 0;
        lpMultiByteStr = *(LPSTR *)(lParam + 20);
        if ( v16 )
          goto LABEL_108;
        v30 = (HWND)CCLocalAllocArray_WCHAR(*(_DWORD *)(lParam + 24));
        hWnd = v30;
        if ( !v30 )
          return 0;
        *(_DWORD *)(lParam + 20) = v30;
LABEL_108:
        Rect.bottom = RBGetBandInfo(v5, wParam, lParam);
        if ( hWnd )
        {
          WideCharToMultiByte(
            *(_DWORD *)(v5 + 20),
            0,
            *(LPCWSTR *)(lParam + 20),
            -1,
            lpMultiByteStr,
            *(_DWORD *)(lParam + 24),
            0,
            0);
          v31 = hWnd;
          *(_DWORD *)(lParam + 20) = lpMultiByteStr;
          LocalFree(v31);
        }
        return Rect.bottom;
      case 0x411u:
        return *(_DWORD *)(v5 + 48);
      case 0x412u:
        *(_DWORD *)(v5 + 48) = wParam;
        return 0;
      case 0x414u:
        return *(_DWORD *)(v5 + 108);
      case 0x415u:
        result = *(_DWORD *)(v5 + 112);
        *(_DWORD *)(v5 + 112) = lParam;
        return result;
      case 0x416u:
        return *(_DWORD *)(v5 + 112);
      case 0x40Du:
        return RBGetRowCount(v5);
      case 0x40Eu:
        return RBGetRowHeight(v5, wParam);
      case 0x422u:
        return RBGetBandBorders(v5, wParam, lParam);
      case 0x40Cu:
        return *(_DWORD *)(v5 + 52);
      case 0x407u:
        result = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v5 + 4) = wParam;
        return result;
      case 0x409u:
        if ( wParam >= *(_DWORD *)(v5 + 52) )
          return 0;
        v32 = *(_DWORD *)(v5 + 104) + 120 * wParam;
        *(_DWORD *)lParam = *(_DWORD *)(v32 + 48);
        *(_DWORD *)(lParam + 4) = *(_DWORD *)(v32 + 52);
        *(_DWORD *)(lParam + 8) = *(_DWORD *)(v32 + 48) + *(_DWORD *)(v32 + 56);
        *(_DWORD *)(lParam + 12) = *(_DWORD *)(v32 + 52) + *(_DWORD *)(v32 + 60);
        return 1;
      case 0x408u:
        return RBHitTest(v5, lParam);
      case 0x418u:
        if ( wParam < *(_DWORD *)(v5 + 52) )
        {
          if ( lParam != -2 )
          {
            if ( lParam == -1 )
            {
              GetMessagePosClient(*(HWND *)v5, (LPPOINT)(v5 + 92));
            }
            else
            {
              *(_DWORD *)(v5 + 92) = (signed __int16)lParam;
              *(_DWORD *)(v5 + 96) = SHIWORD(lParam);
            }
            if ( *(_BYTE *)(v5 + 8) & 0x80 )
            {
              v33 = *(_DWORD *)(v5 + 92);
              *(_DWORD *)(v5 + 92) = *(_DWORD *)(v5 + 96);
              *(_DWORD *)(v5 + 96) = v33;
            }
          }
          *(_DWORD *)(v5 + 100) = *(_DWORD *)(120 * wParam + *(_DWORD *)(v5 + 104) + 48);
          RBOnBeginDrag(v5, wParam);
        }
        return 0;
      case 0x41Bu:
        if ( !*(_DWORD *)(v5 + 52) || *(_DWORD *)(v5 + 84) )
          result = *(_DWORD *)(v5 + 84);
        else
          result = RBRecalc(v5);
        return result;
      case 0x419u:
        RBOnBeginDrag(v5, -1);
        return 0;
      case 0x41Au:
        if ( *(_DWORD *)(v5 + 88) != -1 )
        {
          if ( lParam == -1 )
            v4 = GetMessagePosClient(*(HWND *)v5, 0);
          v34.y = SHIWORD(v4);
          v34.x = (signed __int16)v4;
          RBDragBand(v5, v34);
        }
        return 0;
      case 0x41Eu:
        RBMinimizeBand(v5, wParam, 0);
        return 0;
      case 0x41Fu:
        RBMaximizeBand(v5, wParam, lParam, 0);
        return 0;
      case 0x427u:
        v35 = *(_DWORD *)(v5 + 52);
        if ( wParam >= v35 || lParam >= v35 )
          return 0;
        return RBMoveBand(v5, wParam, lParam);
      case 0x40Bu:
        return RBSetBandInfo(v5, wParam, lParam, 1);
      case 0x410u:
        return RBIDToIndex(v5, wParam);
      case 0x41Cu:
        return RBGetBandInfo(v5, wParam, lParam);
      case 0x417u:
        return RBSizeBarToRect(v5, lParam);
      default:
        goto LABEL_177;
      case 0x424u:
        if ( *(_DWORD *)(v5 + 8) & 0x1000 )
          *(_DWORD *)(v5 + 44) = CreateDragProxy(*(_DWORD *)v5, (int)RebarDragCallback, 1);
        if ( *(_DWORD *)(v5 + 8) & 0x100 )
        {
          v46 = 44;
          v47 = 1;
          v48 = hWnd;
          v49 = (LPARAM)hWnd;
          v52 = 0;
          v28 = GetWindowLongW(hWnd, -6);
          v29 = CreateWindowExW(
                  0,
                  L"tooltips_class32",
                  0,
                  0x80000000,
                  2147483648,
                  2147483648,
                  2147483648,
                  2147483648,
                  hWnd,
                  0,
                  (HINSTANCE)v28,
                  0);
          *(_DWORD *)(v5 + 48) = v29;
          SendMessageW(v29, 0x432u, 0, (LPARAM)&v46);
        }
        RBInitPaletteHack(v5);
        return 0;
      case 0x413u:
        v37 = *(_DWORD *)(v5 + 108);
        *(_DWORD *)(v5 + 108) = lParam;
        if ( v37 != lParam )
          InvalidateRect(*(HWND *)v5, 0, 1);
        return v37;
      case 0x40Au:
        return RBInsertBand(v5, wParam, lParam);
    }
    return RBInsertBand(v5, wParam, lParam);
  }
  if ( Msg != 1030 )
  {
    if ( Msg <= 0x83 )
    {
      if ( Msg == 131 )
      {
        if ( !(*(_DWORD *)(v5 + 8) & 0x800000) )
          return DefWindowProcW(hWnd, Msg, wParam, lParam);
        InflateRect((LPRECT)lParam, -g_cxEdge, -g_cyEdge);
        return 0;
      }
      if ( Msg <= 0x20 )
      {
        if ( Msg == 32 )
        {
          if ( !DefWindowProcW(hWnd, 0x20u, wParam, lParam) && hWnd == (HWND)wParam )
          {
            GetMessagePosClient(*(HWND *)v5, (LPPOINT)&Rect.right);
            v10 = HIWORD(lParam) == 513 || HIWORD(lParam) == 516;
            RBSetCursor(v5, Rect.right, Rect.bottom, v10);
          }
          return 1;
        }
        if ( Msg > 0xF )
        {
          if ( Msg == 20 )
          {
            if ( RBEraseBkgnd((HDC)v5, (HDC)wParam, -1) )
              return 1;
            return DefWindowProcW(hWnd, Msg, wParam, lParam);
          }
          if ( Msg == 21 )
          {
            RBInitPaletteHack(v5);
            v9 = *(HWND *)(v5 + 48);
            if ( v9 )
              SendMessageW(v9, 0x15u, wParam, lParam);
            InitGlobalColors();
            InvalidateRect(*(HWND *)v5, 0, 1);
            return 0;
          }
          if ( Msg == 26 )
          {
            InitGlobalMetrics(wParam);
            if ( *(_DWORD *)(v5 + 40) & 0x400 )
              RBSetFont(v5, wParam);
            v8 = *(HWND *)(v5 + 48);
            if ( v8 )
              SendMessageW(v8, 0x1Au, wParam, lParam);
            return 0;
          }
          goto LABEL_177;
        }
        if ( Msg != 15 )
        {
          if ( Msg == 1 )
          {
            PostMessageW(hWnd, 0x424u, 0, 0);
            return DefWindowProcW(hWnd, Msg, wParam, lParam);
          }
          if ( Msg == 2 )
          {
            CCDestroyWindow();
            RBDestroy((HLOCAL)v5);
            SetWindowLongW(hWnd, 0, 0);
          }
          else
          {
            if ( Msg != 5 )
            {
              if ( Msg == 11 )
              {
                if ( *(_DWORD *)(v5 + 28) >= 5 )
                  RBSetRecalc(v5, wParam);
                return RBSetRedraw(v5, wParam);
              }
              goto LABEL_177;
            }
            RBAutoSize(v5);
            RBResize(v5, 0);
          }
          return 0;
        }
LABEL_29:
        RBPaint(v5, (HDC)wParam);
        return 0;
      }
      if ( Msg > 0x4E )
      {
        if ( Msg == 85 )
          return CIHandleNotifyFormat(v5, lParam);
        if ( Msg == 125 )
        {
          RBOnStyleChanged(v5, wParam, lParam);
          return 0;
        }
        if ( Msg == 129 )
        {
          CCCreateWindow();
          InitGlobalColors();
          v39 = LocalAlloc(0x40u, 0x94u);
          v40 = (int)v39;
          if ( v39 )
          {
            SetWindowLongW(hWnd, 0, (LONG)v39);
            *(_DWORD *)(v40 + 88) = -1;
            *(_DWORD *)(v40 + 108) = -1;
            *(_DWORD *)(v40 + 112) = -1;
            *(_DWORD *)(v40 + 40) |= 0x28u;
            v41 = hWnd;
            *(_DWORD *)(v40 + 124) = 12;
            *(_DWORD *)(v40 + 132) = -16777216;
            *(_DWORD *)(v40 + 128) = -16777216;
            CIInitialize(v40, (WPARAM)v41, lParam);
            v42 = *(_DWORD *)(v40 + 8);
            if ( !(v42 & 3) )
            {
              v43 = hWnd;
              *(_DWORD *)(v40 + 8) = v42 | 1;
              SetWindowLongW(v43, -16, v42 | 1);
            }
            pvParam = 500;
            if ( SystemParametersInfoW(0x29u, 0x1F4u, &pvParam, 0) )
            {
              v44 = *(void **)(v40 + 76);
              lf.lfWeight = 400;
              v45 = CreateFontIndirectW(&lf);
              *(_DWORD *)(v40 + 76) = v45;
              if ( v45 )
              {
                *(_DWORD *)(v40 + 40) |= 0x400u;
                if ( v44 )
                  DeleteObject(v44);
                RBAfterSetFont(v40);
              }
              else
              {
                *(_DWORD *)(v40 + 76) = v44;
              }
            }
            if ( *(_DWORD *)lParam )
              RBSetBarInfo(v40, *(_DWORD *)lParam);
            return 1;
          }
          return 0;
        }
        goto LABEL_177;
      }
      if ( Msg == 78 )
        return (LPARAM)SendNotifyEx(
                         *(_DWORD *)(v5 + 4),
                         HWND_MESSAGE|0x2,
                         *(_DWORD *)(lParam + 8),
                         lParam,
                         *(_DWORD *)(v5 + 16) & 1);
      if ( Msg < 0x2B )
        goto LABEL_177;
      if ( Msg > 0x2C )
      {
        if ( Msg <= 0x2D )
          goto LABEL_177;
        if ( Msg > 0x2F )
        {
          if ( Msg == 48 )
          {
            RBOnSetFont(v5, wParam);
            return 0;
          }
          if ( Msg == 49 )
          {
            if ( v5 )
              return *(_DWORD *)(v5 + 76);
            return 0;
          }
          goto LABEL_177;
        }
      }
LABEL_208:
      SendMessageW(*(HWND *)(v5 + 4), Msg, wParam, lParam);
      return 0;
    }
    if ( Msg <= 0x205 )
    {
      if ( Msg == 517 )
      {
        v20 = *(_DWORD *)(v5 + 40);
        if ( !(v20 & 0x800) && !(v20 & 0x40) )
        {
          CCReleaseCapture(v5);
          RBOnBeginDrag(v5, -1);
          return DefWindowProcW(hWnd, Msg, wParam, lParam);
        }
      }
      else
      {
        if ( Msg <= 0x200 )
        {
          if ( Msg == 512 )
          {
            RBOnMouseMove(hWnd, 512, wParam, lParam, v5);
            return 0;
          }
          if ( Msg == 132 )
          {
            Rect.left = (signed __int16)lParam;
            Rect.top = SHIWORD(lParam);
            ScreenToClient(*(HWND *)v5, (LPPOINT)&Rect);
            v50 = RBHitTest(v5, (int)&Rect);
            v51 = Rect.left;
            v52 = Rect.top;
            v53 = Rect.right;
            result = (LPARAM)CCSendNotify(v5, -14, (LPARAM)&v49);
            if ( !result )
              return 1;
            return result;
          }
          if ( Msg == 133 )
          {
            if ( !(*(_DWORD *)(v5 + 8) & 0x800000) )
              return DefWindowProcW(hWnd, Msg, wParam, lParam);
            GetWindowRect(hWnd, &Rect);
            OffsetRect(&Rect, -Rect.left, -Rect.top);
            v11 = GetWindowDC(hWnd);
            CCDrawEdge(v11, &Rect, 6, 15, v5 + 124);
            ReleaseDC(hWnd, v11);
            return 0;
          }
          if ( Msg != 273 )
          {
            if ( Msg == 296 )
            {
              if ( CCOnUIState(v5, 296, wParam, lParam) )
                InvalidateRect(hWnd, 0, 1);
              return DefWindowProcW(hWnd, Msg, wParam, lParam);
            }
            goto LABEL_177;
          }
          goto LABEL_208;
        }
        if ( Msg == 513 )
        {
LABEL_62:
          Rect.left = (signed __int16)lParam;
          v12 = *(HWND *)(v5 + 48);
          Rect.top = SHIWORD(lParam);
          RelayToToolTips(v12, (int)hWnd, Msg, wParam, lParam);
          v13 = RBHitTest(v5, (int)&Rect);
          v14 = v13;
          if ( v13 != -1 )
          {
            v15 = *(_DWORD *)(v5 + 104) + 120 * v13;
            if ( v15 )
            {
              if ( Rect.right & 8 )
              {
                RBOnPushChevron((int)hWnd, v5, v15, 0);
              }
              else if ( Rect.right != 3 && RBShouldDrawGripper(v5, *(_DWORD *)(v5 + 104) + 120 * v13) )
              {
                v16 = (*(_BYTE *)(v5 + 8) & 0x80) == 0;
                *(_DWORD *)(v5 + 92) = Rect.left;
                v17 = Rect.top;
                *(_DWORD *)(v5 + 88) = v14;
                *(_DWORD *)(v5 + 96) = v17;
                if ( !v16 )
                {
                  v18 = *(_DWORD *)(v5 + 92);
                  *(_DWORD *)(v5 + 92) = *(_DWORD *)(v5 + 96);
                  *(_DWORD *)(v5 + 96) = v18;
                }
                v19 = hWnd;
                *(_DWORD *)(v5 + 100) = *(_DWORD *)(v15 + 48);
                SetCapture(v19);
                *(_DWORD *)(v5 + 40) &= 0xFFFFF7FF;
                if ( Msg == 515 && *(_DWORD *)(v5 + 8) & 0x8000 )
                  RBToggleBand(v5, 1);
              }
            }
          }
          return 0;
        }
        if ( Msg != 514 )
        {
          if ( Msg <= 0x202 || Msg > 0x204 )
            goto LABEL_177;
          goto LABEL_62;
        }
      }
      RelayToToolTips(*(HWND *)(v5 + 48), (int)hWnd, Msg, wParam, lParam);
      if ( *(_DWORD *)(v5 + 88) != -1 )
      {
        if ( !(*(_BYTE *)(v5 + 40) & 0x40) )
          CCReleaseCapture(v5);
        if ( !(*(_DWORD *)(v5 + 8) & 0x8000) && !(*(_DWORD *)(v5 + 40) & 0x800) )
          RBToggleBand(v5, 1);
        v21 = 0;
        v22 = *(_DWORD *)(v5 + 104) + 120 * *(_DWORD *)(v5 + 88);
        *(_DWORD *)v22 &= 0x7FFFFFFFu;
        CCSendNotify(v5, -833, 0);
        RBSendNotify(v5, *(_DWORD *)(v5 + 88), -836);
        RBOnBeginDrag(v5, -1);
        for ( i = 0; i < *(_DWORD *)(v5 + 52); v21 += 120 )
        {
          if ( !(*(_BYTE *)(v21 + *(_DWORD *)(v5 + 104)) & 8) )
            RBBCalcMinWidth(v5, v21 + *(_DWORD *)(v5 + 104));
          ++i;
        }
        RBSizeBandsToRect(v5, 0);
        RBInvalidateRect(v5, 0);
      }
      return 0;
    }
    if ( Msg > 0x402 )
    {
      if ( Msg == 1027 )
        return RBGetBarInfo(v5, lParam);
      if ( Msg == 1028 )
        return RBSetBarInfo(v5, lParam);
      if ( Msg == 1029 )
        return RBGetBandInfo(v5, wParam, lParam);
      goto LABEL_177;
    }
    if ( Msg == 1026 )
      return RBDeleteBand(v5, wParam);
    if ( Msg != 783 )
    {
      if ( Msg != 785 )
      {
        if ( Msg == 792 )
          goto LABEL_29;
        if ( Msg != 1025 )
        {
LABEL_177:
          if ( !CCWndProc(v5, Msg, wParam, lParam, (int)&Rect.bottom) )
            return DefWindowProcW(hWnd, Msg, wParam, lParam);
          return Rect.bottom;
        }
        goto LABEL_211;
      }
      if ( (HWND)wParam == hWnd )
        return 0;
    }
    RBRealize(v5, 0, Msg == 785, Msg == 785);
    return 1;
  }
LABEL_211:
  if ( !lParam )
    return RBInsertBand(v5, wParam, lParam);
  hWnd = 0;
  v16 = (*(_BYTE *)(lParam + 4) & 4) == 0;
  v24 = *(const CHAR **)(lParam + 20);
  lpMultiByteStr = *(LPSTR *)(lParam + 20);
  if ( !v16 && v24 )
  {
    v25 = (HWND)ProduceWFromA(*(_DWORD *)(v5 + 20), v24);
    hWnd = v25;
    if ( !v25 )
      return -1;
    *(_DWORD *)(lParam + 20) = v25;
    v6 = Msg;
  }
  if ( v6 == 1025 )
    v26 = RBInsertBand(v5, wParam, lParam);
  else
    v26 = RBSetBandInfo(v5, wParam, lParam, 1);
  v16 = hWnd == 0;
  v27 = v26;
  *(_DWORD *)(lParam + 20) = lpMultiByteStr;
  if ( !v16 )
    FreeProducedString(hWnd);
  return v27;
}
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F77EA84) --------------------------------------------------------
int __stdcall TB_GetItemRect(HDC hDC, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // eax@5
  int result; // eax@5

  if ( (unsigned int)a2 >= *((_DWORD *)hDC + 33) || (v3 = 28 * a2, *(_BYTE *)(28 * a2 + *((_DWORD *)hDC + 12) + 8) & 8) )
  {
    result = 0;
  }
  else
  {
    if ( !(*((_BYTE *)hDC + 238) & 1) )
    {
      TB_CalcItemRects(hDC);
      *((_DWORD *)hDC + 59) |= 0x10000u;
    }
    *(_DWORD *)a3 = *(_DWORD *)(v3 + *((_DWORD *)hDC + 12) + 20);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)a3 + TBWidthOfButton(v3, hDC, v3 + *((_DWORD *)hDC + 12), 0);
    v4 = *(_DWORD *)(v3 + *((_DWORD *)hDC + 12) + 24);
    *(_DWORD *)(a3 + 4) = v4;
    *(_DWORD *)(a3 + 12) = v4 + TBHeightOfButton((int)hDC, v3 + *((_DWORD *)hDC + 12));
    result = 1;
  }
  return result;
}

//----- (6F77EB10) --------------------------------------------------------
int __stdcall TBHeightOfButton(int a1, int a2)
{
  int result; // eax@2

  if ( *(_BYTE *)(a2 + 9) & 1 && (*(_BYTE *)(a2 + 8) & 0x20 || *(_BYTE *)(a1 + 36) & 4) )
  {
    if ( *(_BYTE *)(a1 + 8) & 0x80 || *(_BYTE *)(a1 + 36) & 4 )
      result = TBGetSepHeight(a1, (int *)a2);
    else
      result = *(_DWORD *)(a1 + 116) + TBGetSepHeight(a1, (int *)a2);
  }
  else
  {
    result = *(_DWORD *)(a1 + 116);
  }
  return result;
}

//----- (6F77EB33) --------------------------------------------------------
signed int __stdcall InitReBarClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.cbClsExtra = 0;
  WndClass.hIcon = 0;
  WndClass.hCursor = 0;
  WndClass.lpszMenuName = 0;
  WndClass.lpfnWndProc = ReBarWndProc;
  WndClass.lpszClassName = L"ReBarWindow32";
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = a1;
  WndClass.hbrBackground = (HBRUSH)16;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F77EB84: using guessed type wchar_t c_szReBarClass[14];

//----- (6F77EBA5) --------------------------------------------------------
signed int __stdcall InitComboExClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = (WNDPROC)ComboExWndProc;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"ComboBoxEx32";
  WndClass.hbrBackground = (HBRUSH)6;
  WndClass.style = 0x4000;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F77EC04: using guessed type wchar_t c_szComboBoxEx[13];

//----- (6F77EC23) --------------------------------------------------------
int __stdcall TB_CalcItemRects(HDC hDC)
{
  HDC v1; // esi@1
  int v2; // ebx@1
  int result; // eax@1
  int v4; // edi@3
  char v5; // al@3
  char v6; // cl@4
  HDC v7; // eax@5
  int v8; // eax@12
  int v9; // [sp+8h] [bp-8h]@1
  int v10; // [sp+Ch] [bp-4h]@2
  HDC hDCa; // [sp+18h] [bp+8h]@1

  v1 = hDC;
  v2 = *((_DWORD *)hDC + 32);
  hDCa = (HDC)*((_DWORD *)hDC + 36);
  result = 0;
  v9 = 0;
  if ( *((_DWORD *)v1 + 33) > 0 )
  {
    v10 = 0;
    do
    {
      v4 = v10 + *((_DWORD *)v1 + 12);
      v5 = *(_BYTE *)(v4 + 8);
      if ( !(v5 & 8) )
      {
        v6 = v5 & 0x20;
        if ( v5 & 0x20 && *(_BYTE *)(v4 + 9) & 1 )
          v7 = (HDC)*((_DWORD *)v1 + 36);
        else
          v7 = hDCa;
        *(_DWORD *)(v4 + 20) = v7;
        *(_DWORD *)(v4 + 24) = v2;
        if ( *((_BYTE *)v1 + 36) & 4 )
        {
          if ( v6 )
          {
            hDCa = (HDC)((char *)hDCa + g_cxEdge + *((_DWORD *)v1 + 28));
            v2 = 0;
          }
          else if ( *(_BYTE *)(v4 + 9) & 1 )
          {
            v2 += TBGetSepHeight((int)v1, (int *)v4);
          }
          else
          {
            v2 += *((_DWORD *)v1 + 29);
          }
        }
        else
        {
          hDCa = (HDC)((char *)hDCa + TBWidthOfButton(v2, v1, v4, 0));
          if ( *(_BYTE *)(v4 + 8) & 0x20 )
          {
            v8 = *((_DWORD *)v1 + 29);
            v2 += v8;
            if ( *(_BYTE *)(v4 + 9) & 1 )
            {
              if ( *((_BYTE *)v1 + 8) & 0x80 )
                v2 -= v8;
              v2 += TBGetSepHeight((int)v1, (int *)v4);
            }
            hDCa = (HDC)*((_DWORD *)v1 + 36);
          }
        }
      }
      ++v9;
      result = v9;
      v10 += 28;
    }
    while ( v9 < *((_DWORD *)v1 + 33) );
  }
  return result;
}

//----- (6F77EDE8) --------------------------------------------------------
signed int __stdcall PositionFromID(int a1, int a2)
{
  signed int v2; // edx@3
  signed int result; // eax@3
  int v4; // ecx@4

  if ( a1 && a2 != -1 && (v2 = *(_DWORD *)(a1 + 132), result = 0, v2 > 0) )
  {
    v4 = *(_DWORD *)(a1 + 48) + 4;
    while ( *(_DWORD *)v4 != a2 )
    {
      ++result;
      v4 += 28;
      if ( result >= v2 )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    result = -1;
  }
  return result;
}

//----- (6F77EFD2) --------------------------------------------------------
COLORREF __stdcall RBB_GetBkColor(int a1, int a2)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a2 + 8);
  if ( result == -16777216 )
  {
    result = g_clrBtnFace;
  }
  else if ( result == -1 )
  {
    result = RB_GetBkColor(a1);
  }
  return result;
}

//----- (6F77EFFD) --------------------------------------------------------
COLORREF __stdcall RBB_GetTextColor(int a1, int a2)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a2 + 4);
  if ( result == -16777216 )
  {
    result = g_clrBtnText;
  }
  else if ( result == -1 )
  {
    result = RB_GetTextColor(a1);
  }
  return result;
}

//----- (6F77F070) --------------------------------------------------------
int __stdcall RBEraseBkgnd(HDC hdcSrc, HDC hdc, int a3)
{
  HDC v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  unsigned int v6; // eax@1
  COLORREF v7; // eax@2
  int v8; // eax@9
  COLORREF v9; // eax@11
  int v11; // eax@22
  LPARAM lParam; // [sp+Ch] [bp-50h]@1
  HDC v13; // [sp+1Ch] [bp-40h]@1
  struct tagRECT rc; // [sp+20h] [bp-3Ch]@7
  int v15; // [sp+30h] [bp-2Ch]@9
  int v16; // [sp+34h] [bp-28h]@1
  int v17; // [sp+38h] [bp-24h]@1
  struct tagRECT Rect; // [sp+3Ch] [bp-20h]@2
  unsigned int v19; // [sp+4Ch] [bp-10h]@9
  int v20; // [sp+50h] [bp-Ch]@2
  COLORREF color; // [sp+54h] [bp-8h]@11
  int v22; // [sp+58h] [bp-4h]@1
  HDC hdcSrca; // [sp+64h] [bp+8h]@1
  HDC hdca; // [sp+68h] [bp+Ch]@4

  v3 = hdc;
  v4 = (int)hdcSrc;
  v22 = *((_DWORD *)hdcSrc + 2) & 0x80;
  v5 = *((_DWORD *)hdcSrc + 26);
  hdcSrca = 0;
  v16 = 0;
  v17 = 0;
  v13 = hdc;
  v6 = CICustomDrawNotify(v4, 3, (LPARAM)&lParam);
  *(_DWORD *)(v4 + 12) = v6;
  if ( !(v6 & 4) )
  {
    v20 = *(_DWORD *)(v4 + 8) & 0x400;
    GetClientRect(*(HWND *)v4, &Rect);
    v7 = RB_GetBkColor(v4);
    if ( v7 != -1 )
      FillRectClr(hdc, &Rect, v7);
    hdca = 0;
    if ( *(_DWORD *)(v4 + 52) )
    {
      while ( 1 )
      {
        if ( !(*(_BYTE *)v5 & 8) )
        {
          if ( v22 )
            SetRect(
              &rc,
              *(_DWORD *)(v5 + 52),
              *(_DWORD *)(v5 + 48),
              *(_DWORD *)(v5 + 52) + *(_DWORD *)(v5 + 60),
              *(_DWORD *)(v5 + 48) + *(_DWORD *)(v5 + 56));
          else
            SetRect(
              &rc,
              *(_DWORD *)(v5 + 48),
              *(_DWORD *)(v5 + 52),
              *(_DWORD *)(v5 + 48) + *(_DWORD *)(v5 + 56),
              *(_DWORD *)(v5 + 52) + *(_DWORD *)(v5 + 60));
          if ( v20 )
          {
            if ( *(_DWORD *)(v5 + 48) )
            {
              if ( v22 )
              {
                rc.right += g_cxEdge / 2;
                rc.top -= g_cyEdge;
                CCDrawEdge(v3, &rc, 6, 2, v4 + 124);
                rc.right += g_cxEdge / -2;
                rc.top += g_cyEdge;
              }
              else
              {
                rc.bottom += g_cyEdge / 2;
                rc.left -= g_cxEdge;
                CCDrawEdge(v3, &rc, 6, 1, v4 + 124);
                rc.bottom += g_cyEdge / -2;
                rc.left += g_cxEdge;
              }
            }
            else
            {
              v11 = *(_DWORD *)(v5 + 52);
              if ( v22 )
              {
                Rect.right = *(_DWORD *)(v5 + 60) + g_cxEdge + v11;
                CCDrawEdge(v3, &Rect, 6, 4, v4 + 124);
              }
              else
              {
                Rect.bottom = *(_DWORD *)(v5 + 60) + g_cyEdge + v11;
                CCDrawEdge(v3, &Rect, 6, 8, v4 + 124);
              }
            }
          }
          v8 = *(_DWORD *)(v5 + 76);
          v16 = 0;
          v15 = v8;
          v19 = CICustomDrawNotify(v4, 65539, (LPARAM)&lParam);
          if ( v19 & 4 )
            goto LABEL_12;
          if ( !*(_DWORD *)(v5 + 44) )
          {
            color = RBB_GetBkColor(v4, v5);
            v9 = RB_GetBkColor(v4);
            if ( color != v9 )
              FillRectClr(v3, &rc, color);
            goto LABEL_12;
          }
          if ( hdcSrca )
            goto LABEL_29;
          hdcSrca = CreateCompatibleDC(v3);
          if ( hdcSrca )
          {
            RBRealize(v4, v3, 1, 0);
LABEL_29:
            SelectObject(hdcSrca, *(HGDIOBJ *)(v5 + 44));
            RBTileBlt(v4, v5, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, v3, hdcSrca);
LABEL_12:
            if ( v19 & 0x40 )
              CICustomDrawNotify(v4, 65540, (LPARAM)&lParam);
            goto LABEL_13;
          }
        }
LABEL_13:
        hdca = (HDC)((char *)hdca + 1);
        v5 += 120;
        if ( (unsigned int)hdca >= *(_DWORD *)(v4 + 52) )
        {
          if ( hdcSrca )
            DeleteDC(hdcSrca);
          break;
        }
      }
    }
  }
  if ( *(_BYTE *)(v4 + 12) & 0x40 )
  {
    v16 = 0;
    v15 = 0;
    v17 = 0;
    CICustomDrawNotify(v4, 4, (LPARAM)&lParam);
  }
  return 1;
}

//----- (6F77F1AD) --------------------------------------------------------
COLORREF __stdcall RB_GetBkColor(int a1)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a1 + 108);
  if ( result == -16777216 )
    result = g_clrBtnFace;
  return result;
}

//----- (6F77F1E1) --------------------------------------------------------
BOOL __stdcall CCForwardEraseBackground(HWND hWnd, HDC hdc)
{
  HWND v2; // edi@1
  LRESULT v3; // ebx@1
  struct tagPOINT Points; // [sp+8h] [bp-8h]@2

  v2 = GetParent(hWnd);
  v3 = 0;
  if ( v2 )
  {
    Points.x = 0;
    Points.y = 0;
    MapWindowPoints(hWnd, v2, &Points, 1u);
    OffsetWindowOrgEx(hdc, Points.x, Points.y, &Points);
    v3 = SendMessageW(v2, 0x14u, (WPARAM)hdc, 0);
    SetWindowOrgEx(hdc, Points.x, Points.y, 0);
  }
  return v3 != 0;
}

//----- (6F77F2AC) --------------------------------------------------------
int __stdcall TB_HasSplitDDArrow(int a1, int a2)
{
  int result; // eax@2
  char v3; // al@4

  result = 0;
  if ( *(_BYTE *)(a1 + 36) & 1 )
  {
    v3 = *(_BYTE *)(a2 + 9);
    if ( v3 & 8 )
    {
      if ( v3 >= 0 )
        result = 1;
    }
  }
  return result;
}

//----- (6F77F2D5) --------------------------------------------------------
int __stdcall RBPaint(int a1, HDC a2)
{
  int result; // eax@3
  int v3; // esi@4
  unsigned int v4; // edi@4
  LPARAM lParam; // [sp+4h] [bp-7Ch]@3
  HDC v6; // [sp+14h] [bp-6Ch]@3
  LONG v7; // [sp+18h] [bp-68h]@3
  LONG v8; // [sp+1Ch] [bp-64h]@3
  LONG v9; // [sp+20h] [bp-60h]@3
  LONG v10; // [sp+24h] [bp-5Ch]@3
  int v11; // [sp+2Ch] [bp-54h]@3
  int v12; // [sp+30h] [bp-50h]@3
  HDC v13; // [sp+34h] [bp-4Ch]@1
  HDC hdc; // [sp+38h] [bp-48h]@1
  struct tagPAINTSTRUCT Paint; // [sp+3Ch] [bp-44h]@2

  v13 = a2;
  hdc = a2;
  if ( a2 )
    GetClientRect(*(HWND *)a1, &Paint.rcPaint);
  else
    hdc = BeginPaint(*(HWND *)a1, &Paint);
  v11 = 0;
  v12 = 0;
  v6 = hdc;
  v7 = Paint.rcPaint.left;
  v8 = Paint.rcPaint.top;
  v9 = Paint.rcPaint.right;
  v10 = Paint.rcPaint.bottom;
  result = CICustomDrawNotify(a1, 1, (LPARAM)&lParam);
  *(_DWORD *)(a1 + 12) = result;
  if ( !(result & 4) )
  {
    v3 = 0;
    v4 = 0;
    if ( *(_DWORD *)(a1 + 52) )
    {
      do
      {
        result = v3 + *(_DWORD *)(a1 + 104);
        if ( !(*(_BYTE *)result & 8) )
          result = RBDrawBand(a1, result, hdc);
        ++v4;
        v3 += 120;
      }
      while ( v4 < *(_DWORD *)(a1 + 52) );
    }
  }
  if ( *(_BYTE *)(a1 + 12) & 0x10 )
    result = CICustomDrawNotify(a1, 2, (LPARAM)&lParam);
  if ( !v13 )
    result = EndPaint(*(HWND *)a1, &Paint);
  return result;
}

//----- (6F77F390) --------------------------------------------------------
COLORREF __stdcall RBDrawBand(int a1, int a2, HDC hdc)
{
  int v3; // ebx@1
  COLORREF result; // eax@1
  int v5; // esi@5
  COLORREF v6; // eax@6
  COLORREF v7; // eax@6
  COLORREF v8; // eax@6
  bool v9; // zf@6
  int v10; // eax@7
  int v11; // edx@7
  int v12; // ecx@7
  int v13; // eax@7
  int v14; // edx@7
  int v15; // eax@7
  int v16; // eax@8
  int v17; // eax@21
  int v18; // eax@23
  int v19; // ecx@26
  int v20; // eax@28
  int v21; // edi@30
  int v22; // ebx@31
  int v23; // edi@31
  int v24; // eax@32
  int v25; // eax@36
  int v26; // eax@38
  int v27; // edi@38
  unsigned int v28; // eax@40
  int v29; // eax@46
  int v30; // eax@50
  UINT v31; // edi@52
  LONG v32; // ecx@53
  LONG v33; // eax@56
  bool v34; // sf@60
  unsigned __int8 v35; // of@60
  int v36; // eax@63
  int v37; // eax@64
  IMAGELISTDRAWPARAMS pimldp; // [sp+8h] [bp-A0h]@39
  LPARAM lParam; // [sp+4Ch] [bp-5Ch]@11
  HDC v40; // [sp+5Ch] [bp-4Ch]@7
  int v41; // [sp+60h] [bp-48h]@7
  int v42; // [sp+64h] [bp-44h]@7
  int v43; // [sp+68h] [bp-40h]@9
  int v44; // [sp+6Ch] [bp-3Ch]@7
  int v45; // [sp+70h] [bp-38h]@7
  int v46; // [sp+74h] [bp-34h]@7
  int v47; // [sp+78h] [bp-30h]@7
  COLORREF v48; // [sp+7Ch] [bp-2Ch]@6
  COLORREF color; // [sp+80h] [bp-28h]@6
  unsigned int v50; // [sp+84h] [bp-24h]@11
  int mode; // [sp+88h] [bp-20h]@17
  struct tagRECT rc; // [sp+8Ch] [bp-1Ch]@31
  HGDIOBJ h; // [sp+9Ch] [bp-Ch]@28
  int v54; // [sp+A0h] [bp-8h]@1
  int v55; // [sp+A4h] [bp-4h]@4
  int v56; // [sp+B0h] [bp+8h]@38
  int v57; // [sp+B4h] [bp+Ch]@30

  v3 = a1;
  result = *(_DWORD *)(a1 + 8);
  v54 = *(_DWORD *)(a1 + 8) & 0x80;
  v55 = !v54 || v54 && result & 0x4000;
  v5 = a2;
  if ( !(*(_BYTE *)a2 & 8) )
  {
    v6 = RBB_GetTextColor(a1, a2);
    color = SetTextColor(hdc, v6);
    v7 = RBB_GetBkColor(a1, a2);
    v8 = SetBkColor(hdc, v7);
    v9 = *(_DWORD *)(a2 + 44) == 0;
    v48 = v8;
    if ( !v9 )
      mode = SetBkMode(hdc, 1);
    v10 = *(_DWORD *)(a2 + 76);
    v11 = *(_DWORD *)(a2 + 60);
    v46 = 0;
    v12 = *(_DWORD *)(a2 + 48);
    v45 = v10;
    v47 = *(_DWORD *)(a2 + 92);
    v13 = *(_DWORD *)(a2 + 52);
    v14 = v13 + v11;
    v40 = hdc;
    v42 = v13;
    v15 = *(_DWORD *)a2;
    v41 = v12;
    v44 = v14;
    if ( !(v15 & 0x200) || v15 & 2 || *(_DWORD *)(a2 + 72) <= *(_DWORD *)(a2 + 28) )
      v16 = 0;
    else
      v16 = 5 * g_cxEdge + 2;
    v9 = (*(_BYTE *)(a1 + 8) & 0x80) == 0;
    v43 = v12 + *(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 28) - v16;
    if ( !v9 )
      FlipRect((int)&v41);
    v50 = CICustomDrawNotify(a1, 65537, (LPARAM)&lParam);
    if ( !(v50 & 4) )
    {
      v17 = *(_DWORD *)(a1 + 8);
      if ( (char)v17 < 0 && v17 & 0x4000 )
      {
        v18 = *(_DWORD *)a2;
        if ( !(*(_DWORD *)a2 & 0x200) || v18 & 2 || *(_DWORD *)(a2 + 72) <= *(_DWORD *)(a2 + 28) )
          v19 = 0;
        else
          v19 = 5 * g_cxEdge + 2;
        h = (HGDIOBJ)(*(_DWORD *)(a2 + 68) - *(_DWORD *)(a2 + 28) - v19);
        v20 = *(_DWORD *)(a2 + 48) + (signed int)h / 2;
      }
      else
      {
        h = *(HGDIOBJ *)(a2 + 60);
        v20 = *(_DWORD *)(a2 + 52) + (signed int)h / 2;
      }
      v21 = *(_DWORD *)(a2 + 48);
      v57 = v20;
      if ( RBShouldDrawGripper(a1, v5) )
      {
        v22 = 3 * g_cyBorder;
        v23 = v21 + 2 * g_cxBorder;
        SetRect(
          &rc,
          v23,
          g_cxEdge + *(_DWORD *)(v5 + 52),
          v23 + 3 * g_cyBorder,
          (int)((char *)h + *(_DWORD *)(v5 + 52) - g_cxEdge));
        if ( v54 )
        {
          RBVertMungeGripperRect(a1, &rc);
          v24 = *(_DWORD *)(a1 + 8);
          if ( (char)v24 < 0 )
          {
            if ( v24 & 0x4000 )
              v23 = rc.left;
          }
        }
        CCDrawEdge(hdc, &rc, 4, 2063, a1 + 124);
        v21 = v22 + v23;
        v3 = a1;
      }
      v25 = g_cyEdge;
      if ( !v54 )
        v25 = g_cxEdge;
      v26 = v21 + 2 * v25;
      v27 = *(_DWORD *)(v5 + 20);
      v56 = v26;
      if ( v27 != -1 )
      {
        memset(&pimldp.himl, 0, 0x40u);
        if ( v55 )
          v28 = *(_DWORD *)(v3 + 72);
        else
          v28 = *(_DWORD *)(v3 + 68);
        pimldp.himl = *(HIMAGELIST *)(v3 + 64);
        pimldp.cbSize = 68;
        pimldp.i = v27;
        pimldp.hdcDst = hdc;
        if ( v55 )
        {
          pimldp.x = v56;
          pimldp.y = v57 - (v28 >> 1);
        }
        else
        {
          pimldp.x = v57 - (v28 >> 1);
          pimldp.y = v56;
        }
        pimldp.rgbBk = -16777216;
        pimldp.rgbFg = -16777216;
        pimldp.fStyle = 1;
        ImageList_DrawIndirect(&pimldp);
        if ( v55 )
          v29 = g_cxEdge + *(_DWORD *)(v3 + 68);
        else
          v29 = g_cyEdge + *(_DWORD *)(v3 + 72);
        v56 += v29;
      }
      if ( !(*(_DWORD *)v5 & 0x400) )
      {
        v30 = *(_DWORD *)(v5 + 12);
        if ( v30 )
        {
          if ( *(_WORD *)v30 )
          {
            v31 = 0;
            h = SelectObject(hdc, *(HGDIOBJ *)(v3 + 76));
            if ( v55 )
              v32 = v56;
            else
              v32 = v57 - (*(_DWORD *)(v5 + 16) >> 1);
            rc.left = v32;
            if ( v55 )
              v33 = v57 - (*(_DWORD *)(v3 + 80) >> 1);
            else
              v33 = v56;
            rc.top = v33;
            if ( v55 )
              --rc.top;
            rc.right = v32 + *(_DWORD *)(v5 + 16);
            v35 = __OFSUB__(*(_DWORD *)(v3 + 28), 5);
            v34 = *(_DWORD *)(v3 + 28) - 5 < 0;
            rc.bottom = rc.top + *(_DWORD *)(v3 + 80);
            if ( v34 ^ v35 )
            {
              v37 = lstrlenW(*(LPCWSTR *)(v5 + 12));
              TextOutW(hdc, rc.left, rc.top, *(LPCWSTR *)(v5 + 12), v37);
            }
            else
            {
              if ( CCGetUIState(v3) & 2 )
                v31 = 0x100000;
              v36 = lstrlenW(*(LPCWSTR *)(v5 + 12));
              DrawTextW(hdc, *(LPCWSTR *)(v5 + 12), v36, &rc, v31);
            }
            SelectObject(hdc, h);
          }
        }
      }
      if ( *(_DWORD *)v5 & 0x200
        && !(*(_DWORD *)v5 & 2)
        && *(_DWORD *)(v5 + 72) > *(_DWORD *)(v5 + 28)
        && *(_BYTE *)(v5 + 96) & 1 )
        RBDrawChevron(v3, v5, hdc);
    }
    if ( v50 & 0x10 )
      CICustomDrawNotify(v3, 65538, (LPARAM)&lParam);
    if ( *(_DWORD *)(v5 + 44) )
      SetBkMode(hdc, mode);
    SetTextColor(hdc, color);
    result = SetBkColor(hdc, v48);
  }
  return result;
}

//----- (6F77F4B8) --------------------------------------------------------
int __stdcall FlipRect(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // ecx@1

  result = a1;
  v2 = *(_DWORD *)a1;
  *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 4) = v2;
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
  return result;
}

//----- (6F77F4DF) --------------------------------------------------------
int __stdcall RBGetRowCount(int a1)
{
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@2

  v1 = *(_DWORD *)(a1 + 52);
  result = 0;
  if ( v1 )
  {
    v3 = *(_DWORD *)(a1 + 104);
    do
    {
      if ( !(*(_BYTE *)v3 & 8) && !*(_DWORD *)(v3 + 48) )
        ++result;
      v3 += 120;
      --v1;
    }
    while ( v1 );
  }
  return result;
}

//----- (6F77F50E) --------------------------------------------------------
unsigned int __stdcall RBGetFirstInRow(int a1, unsigned int a2)
{
  unsigned int result; // eax@1

  for ( result = a2; result > *(_DWORD *)(a1 + 104) && (*(_DWORD *)(result + 48) || *(_BYTE *)result & 8); result -= 120 )
    ;
  return result;
}

//----- (6F77F52D) --------------------------------------------------------
int __stdcall RBGetLastInRow(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int v5; // eax@3

  v3 = a2;
  v4 = *(_DWORD *)(a1 + 52);
  do
  {
    v3 += 120;
    if ( v4 )
      v5 = 120 * v4 + *(_DWORD *)(a1 + 104) - 120;
    else
      v5 = 0;
  }
  while ( v3 <= v5 && (*(_DWORD *)(v3 + 48) || *(_BYTE *)v3 & 8) && (!a3 || (*(_DWORD *)v3 & 0xA) == 2) );
  return v3 - 120;
}

//----- (6F77F56A) --------------------------------------------------------
int __stdcall RBSizeBandsToRect(int a1, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // edi@4
  int v4; // eax@6
  signed int v5; // esi@6
  int v6; // ecx@10
  int v7; // eax@10
  int v9; // eax@14
  struct tagRECT Rect; // [sp+Ch] [bp-1Ch]@2
  int v11; // [sp+1Ch] [bp-Ch]@3
  int v12; // [sp+20h] [bp-8h]@1
  int v13; // [sp+24h] [bp-4h]@1
  int v14; // [sp+30h] [bp+8h]@4
  signed int v15; // [sp+34h] [bp+Ch]@4

  v13 = 0;
  v12 = 0;
  v2 = a1;
  if ( a2 )
  {
    Rect.left = *(_DWORD *)a2;
    Rect.top = *(_DWORD *)(a2 + 4);
    Rect.right = *(_DWORD *)(a2 + 8);
    Rect.bottom = *(_DWORD *)(a2 + 12);
  }
  else
  {
    GetClientRect(*(HWND *)a1, &Rect);
  }
  v11 = RBSetRedraw(a1, 0);
  while ( 2 )
  {
    v3 = *(_DWORD *)(v2 + 52);
    v15 = 0;
    v14 = 1;
    if ( RBGetRowCount(v2) == 1 )
      v14 = 0;
    v4 = RBSizeDifference(v2, (int)&Rect);
    v5 = v4;
    if ( !v13 )
    {
      v13 = v4;
      goto LABEL_8;
    }
    if ( v13 * v4 >= 0 )
    {
LABEL_8:
      while ( v3 )
      {
        --v3;
        if ( !v5 )
          goto LABEL_16;
        v6 = *(_DWORD *)(v2 + 116);
        v7 = *(_DWORD *)(v2 + 104) + 120 * *(_DWORD *)(v2 + 116);
        if ( !v6 )
          v6 = *(_DWORD *)(v2 + 52);
        *(_DWORD *)(v2 + 116) = v6 - 1;
        if ( !(*(_DWORD *)v7 & 8) )
        {
          if ( *(_DWORD *)v7 & 0x40 )
          {
            v9 = RBGrowBand(v2, v7, v5, v14);
            v5 -= v9;
            if ( v9 )
            {
              v12 = 1;
              v15 = 1;
              break;
            }
          }
        }
      }
      if ( v5 < 0 )
      {
        if ( v15 )
          continue;
        if ( RBBandsAtMinHeight(v2) || Rect.bottom <= Rect.top )
          break;
        --Rect.bottom;
        v15 = 1;
      }
LABEL_16:
      if ( v15 )
        continue;
    }
    break;
  }
  RBSetRedraw(v2, v11);
  return v12;
}

//----- (6F77F627) --------------------------------------------------------
int __stdcall RBSetRedraw(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  int v5; // ebx@3

  v2 = (*(_DWORD *)(a1 + 40) >> 3) & 1;
  v3 = *(_DWORD *)(a1 + 40) ^ ((unsigned __int8)*(_DWORD *)(a1 + 40) ^ (unsigned __int8)(8 * (a2 != 0))) & 8;
  *(_DWORD *)(a1 + 40) = v3;
  if ( a2 )
  {
    v5 = ((unsigned int)v3 >> 7) & 1;
    if ( v3 & 2 )
      RBResizeNow(a1);
    if ( v5 )
      RBInvalidateRect(a1, 0);
  }
  return v2;
}

//----- (6F77F668) --------------------------------------------------------
int __stdcall RBSizeBarToRect(int a1, int a2)
{
  unsigned int v2; // esi@1
  int v3; // eax@5
  int v4; // eax@6
  signed int v5; // kr00_4@6
  int v6; // edi@6
  int v7; // eax@6
  int v8; // eax@8
  int v9; // ecx@9
  int v11; // eax@17
  int v12; // eax@21
  int v13; // eax@23
  int v14; // [sp+8h] [bp-6Ch]@6
  int v15; // [sp+Ch] [bp-68h]@6
  int v16; // [sp+10h] [bp-64h]@28
  struct tagRECT Rect; // [sp+58h] [bp-1Ch]@20
  int v18; // [sp+68h] [bp-Ch]@1
  int v19; // [sp+6Ch] [bp-8h]@3
  int v20; // [sp+70h] [bp-4h]@1
  unsigned int v21; // [sp+7Ch] [bp+8h]@3

  v2 = a1;
  v20 = 0;
  v18 = RBSetRedraw(a1, 0);
  if ( !a2 )
  {
    GetClientRect(*(HWND *)a1, &Rect);
    a2 = (int)&Rect;
  }
  if ( *(_DWORD *)(a1 + 52) )
  {
    v21 = *(_DWORD *)(a1 + 52);
    v19 = 1;
    if ( RBSizeDifference(v2, a2) >= 0 )
    {
      if ( *(_BYTE *)(v2 + 8) & 0x80 )
        v20 = RBSizeBandsToRect(v2, a2);
LABEL_5:
      while ( 1 )
      {
        v3 = *(_DWORD *)(v2 + 52);
        if ( !v3 )
          break;
        v4 = RBGetRowHeight(v2, v3 - 1);
        v5 = v4;
        v6 = v4 / 2;
        v14 = 80;
        v15 = 1;
        v7 = RBSizeDifference(v2, a2);
        if ( v7 >= v5 / -2 )
        {
          if ( v7 <= v6 )
            break;
          --v21;
          if ( !v21 )
            break;
          v13 = *(_DWORD *)(v2 + 104) + 120 * v21;
          while ( *(_BYTE *)v13 & 0xB )
          {
            --v21;
            v13 -= 120;
            if ( !v21 )
              goto LABEL_12;
          }
          v12 = *(_DWORD *)v13 | 1;
        }
        else
        {
          --v21;
          if ( !v21 )
            break;
          v8 = *(_DWORD *)(v2 + 104) + 120 * v21;
          while ( 1 )
          {
            v9 = *(_DWORD *)v8;
            if ( !(*(_DWORD *)v8 & 8) )
            {
              if ( v9 & 1 )
                break;
            }
            --v21;
            v8 -= 120;
            if ( !v21 )
              goto LABEL_12;
          }
          v12 = v9 & 0xFFFFFFFE;
        }
        v16 = v12;
        v20 = 1;
        RBSetBandInfo(v2, v21, (int)&v14, 1);
      }
LABEL_12:
      if ( !(v21 % *(_DWORD *)(v2 + 52)) && v19 )
      {
        v11 = RBSizeBandsToRect(v2, a2);
        v20 |= v11;
      }
    }
    else
    {
      v19 = 0;
      v20 = RBSizeBandsToRect(v2, a2);
      if ( RBBandsAtMinHeight(v2) )
        goto LABEL_5;
    }
  }
  RBSizeBandsToRowHeight(v2);
  RBSetRedraw(v2, v18);
  return v20;
}

//----- (6F77F75D) --------------------------------------------------------
int __stdcall RBSizeDifference(int a1, int a2)
{
  int v2; // eax@2

  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    v2 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  else
    v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  return v2 - *(_DWORD *)(a1 + 84);
}

//----- (6F77F787) --------------------------------------------------------
int __stdcall RBGetRowHeight(int a1, unsigned int a2)
{
  unsigned int v2; // edi@2
  int v3; // ebx@2
  int v4; // ST08_4@2
  unsigned int v5; // eax@2
  int result; // eax@2

  if ( a2 >= *(_DWORD *)(a1 + 52) )
  {
    result = -1;
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 104) + 120 * a2;
    v3 = *(_DWORD *)(a1 + 104);
    v4 = (RBGetLastInRow(a1, v2, 0) - v3) / 120;
    v5 = RBGetFirstInRow(a1, v2);
    result = RBGetLineHeight(a1, (signed int)(v5 - v3) / 120, v4);
  }
  return result;
}

//----- (6F77F7DE) --------------------------------------------------------
int __stdcall RBGetLineHeight(int a1, unsigned int a2, int a3)
{
  int v3; // eax@2
  unsigned int v4; // ecx@2
  int v5; // esi@3
  int v6; // ebx@4
  int v7; // eax@6
  int v9; // [sp+8h] [bp-4h]@1

  v9 = 0;
  if ( *(_DWORD *)(a1 + 8) & 0x200 )
  {
    v3 = a3;
    v4 = a2;
  }
  else
  {
    v4 = 0;
    v3 = *(_DWORD *)(a1 + 52) - 1;
  }
  v5 = *(_DWORD *)(a1 + 104) + 120 * v4;
  if ( v4 <= v3 )
  {
    v6 = v3 - v4 + 1;
    do
    {
      if ( !(*(_BYTE *)v5 & 8) )
      {
        v7 = RBBGetHeight(a1, v5);
        if ( v9 <= (unsigned int)v7 )
          v9 = v7;
      }
      v5 += 120;
      --v6;
    }
    while ( v6 );
  }
  return v9;
}

//----- (6F77F83B) --------------------------------------------------------
int __stdcall RBBGetHeight(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // edi@1
  int v4; // edx@1
  int v5; // ebx@2
  int v6; // ecx@6
  unsigned int v8; // eax@15

  v2 = g_cxEdge;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 8) & 0x80;
  if ( !v4 )
    v2 = g_cyEdge;
  v5 = 2 * v2;
  if ( *(_DWORD *)(a2 + 24) )
  {
    v3 = *(_DWORD *)(a2 + 88);
    if ( !(*(_BYTE *)a2 & 4) )
      v3 -= v5;
  }
  if ( !(*(_DWORD *)a2 & 0x400) )
  {
    v6 = *(_DWORD *)(a2 + 12);
    if ( v6 )
    {
      if ( *(_WORD *)v6 && !v4 && *(_DWORD *)(a1 + 80) > v3 )
        v3 = *(_DWORD *)(a1 + 80);
    }
  }
  if ( *(_DWORD *)(a2 + 20) != -1 )
  {
    if ( v4 )
      v8 = *(_DWORD *)(a1 + 68);
    else
      v8 = *(_DWORD *)(a1 + 72);
    if ( v8 > v3 )
      v3 = v8;
  }
  return v3 + v5;
}

//----- (6F77F8A7) --------------------------------------------------------
void __stdcall RBSizeBandsToRowHeight(int a1)
{
  int v1; // ebx@1
  unsigned int v2; // edi@1
  int v3; // eax@2
  signed int v4; // [sp+Ch] [bp-4h]@1

  v4 = -1;
  v1 = 0;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 52) )
  {
    do
    {
      v3 = v1 + *(_DWORD *)(a1 + 104);
      if ( !(*(_BYTE *)v3 & 8) )
      {
        if ( !*(_DWORD *)(v3 + 48) )
          v4 = RBGetRowHeight(a1, v2);
        RBSizeBandToRowHeight(a1, v2, v4);
      }
      ++v2;
      v1 += 120;
    }
    while ( v2 < *(_DWORD *)(a1 + 52) );
  }
}

//----- (6F77F8F9) --------------------------------------------------------
void __stdcall RBSizeBandToRowHeight(int a1, unsigned int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@4
  unsigned int v5; // ecx@6

  v3 = *(_DWORD *)(a1 + 104) + 120 * a2;
  if ( v3 && *(_BYTE *)v3 & 0x40 )
  {
    v4 = a3;
    if ( a3 == -1 )
      v4 = RBGetRowHeight(a1, a2);
    v5 = *(_DWORD *)(v3 + 88);
    if ( v4 > v5 )
      RBGrowBand(a1, v3, v4 - v5, 0);
  }
}

//----- (6F7801FA) --------------------------------------------------------
int __stdcall RBInvalidateRect(int a1, RECT *lprcSrc)
{
  int v2; // eax@1
  RECT *v3; // eax@2
  int result; // eax@5
  struct tagRECT rcDst; // [sp+4h] [bp-10h]@4

  v2 = *(_DWORD *)(a1 + 40);
  if ( v2 & 8 )
  {
    v3 = lprcSrc;
    if ( lprcSrc )
    {
      if ( *(_BYTE *)(a1 + 8) & 0x80 )
      {
        CopyRect(&rcDst, lprcSrc);
        FlipRect((int)&rcDst);
        v3 = &rcDst;
      }
    }
    *(_DWORD *)(a1 + 40) &= 0xFFFFFF7F;
    InvalidateRect(*(HWND *)a1, v3, 1);
    result = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = v2 | 0x80;
    result = 0;
  }
  return result;
}

//----- (6F780254) --------------------------------------------------------
HLOCAL __stdcall RBReallocBands(int a1, int a2)
{
  HLOCAL result; // eax@1

  result = PrivateLocalReAllocArray(*(HLOCAL *)(a1 + 104), a2, 120);
  if ( result || !a2 )
  {
    *(_DWORD *)(a1 + 104) = result;
    result = (HLOCAL)1;
  }
  return result;
}

//----- (6F780282) --------------------------------------------------------
unsigned int __stdcall RBGetNext(int a1, unsigned int a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // esi@1
  int v5; // ecx@3

  result = a2;
  v4 = *(_DWORD *)(a1 + 52);
  do
  {
    if ( v4 )
      v5 = 120 * v4 + *(_DWORD *)(a1 + 104) - 120;
    else
      v5 = 0;
    result += 120;
  }
  while ( result <= v5 && a3 & *(_DWORD *)result );
  return result;
}

//----- (6F7802BC) --------------------------------------------------------
unsigned int __stdcall RBEnumBand(int a1, int a2, int a3)
{
  int v3; // ecx@1
  unsigned int result; // eax@1
  int v5; // edx@3
  int v6; // edx@6

  v3 = *(_DWORD *)(a1 + 52);
  for ( result = *(_DWORD *)(a1 + 104); ; result += 120 )
  {
    v5 = v3 ? 120 * v3 + *(_DWORD *)(a1 + 104) - 120 : 0;
    if ( result <= v5 )
    {
      if ( a3 & *(_DWORD *)result )
        continue;
      v6 = a2--;
      if ( v6 )
        continue;
    }
    break;
  }
  return result;
}

//----- (6F780302) --------------------------------------------------------
void __stdcall RBResize(int a1, int a2)
{
  bool i; // zf@1
  int v3; // ebx@2
  int v4; // eax@5
  int v5; // eax@7
  unsigned int v6; // eax@11

  for ( i = (*(_DWORD *)(a1 + 40) & 0x100) == 0; ; i = (v6 & 0x100) == 0 )
  {
    v3 = *(_DWORD *)(a1 + 84);
    if ( !i )
      break;
    *(_DWORD *)(a1 + 40) |= 0x100u;
    RBRecalc(a1);
    if ( a2 || v3 != *(_DWORD *)(a1 + 84) )
      *(_DWORD *)(a1 + 40) |= 4u;
    v4 = *(_DWORD *)(a1 + 40);
    if ( v4 & 8 )
      RBResizeNow(a1);
    else
      *(_DWORD *)(a1 + 40) = v4 | 2;
    *(_DWORD *)(a1 + 40) &= 0xFFFFFEFF;
    v5 = *(_DWORD *)(a1 + 40);
    if ( !(v5 & 1) )
      return;
    a2 = 0;
    v6 = v5 & 0xFFFFFFFE;
    *(_DWORD *)(a1 + 40) = v6;
  }
  *(_DWORD *)(a1 + 40) |= 1u;
}

//----- (6F780369) --------------------------------------------------------
signed int __stdcall RBGetBandInfo(int a1, unsigned int a2, int a3)
{
  int v3; // edx@1
  int v4; // esi@4
  int v5; // ebx@4
  int v6; // ecx@10
  signed int result; // eax@17
  int v8; // eax@20
  int v9; // eax@24
  int v10; // eax@27
  int v11; // eax@30
  int v12; // eax@31
  int v13; // eax@37
  size_t v14; // edx@39
  wchar_t *v15; // ecx@40
  int v16; // eax@48
  int v17; // eax@49

  v3 = a1;
  if ( a1 && a2 < *(_DWORD *)(a1 + 52) && *(_DWORD *)a3 <= 0x50u )
  {
    v4 = *(_DWORD *)(a1 + 104) + 120 * a2;
    v5 = *(_DWORD *)(a3 + 4);
    if ( v5 & 0x40 )
    {
      if ( *(_BYTE *)v4 & 2 )
        v8 = *(_DWORD *)(v4 + 56);
      else
        v8 = *(_DWORD *)(v4 + 64);
      *(_DWORD *)(a3 + 44) = v8;
    }
    if ( v5 & 0x800 )
    {
      v9 = *(_DWORD *)v4;
      if ( !(*(_DWORD *)v4 & 0x200) || v9 & 2 || *(_DWORD *)(v4 + 72) <= *(_DWORD *)(v4 + 28) )
        v10 = 0;
      else
        v10 = 5 * g_cxEdge + 2;
      *(_DWORD *)(a3 + 76) = *(_DWORD *)(v4 + 68) - *(_DWORD *)(v4 + 28) - v10;
      v3 = a1;
    }
    if ( v5 & 0x200 )
    {
      v11 = *(_DWORD *)(v4 + 72);
      if ( v11 )
        v12 = v11 - 2 * g_cxEdge;
      else
        v12 = 0;
      *(_DWORD *)(a3 + 68) = v12;
    }
    if ( v5 & 1 )
      *(_DWORD *)(a3 + 8) = *(_DWORD *)v4;
    if ( v5 & 2 )
    {
      *(_DWORD *)(a3 + 12) = RBB_GetTextColor_External(v3, v4);
      *(_DWORD *)(a3 + 16) = RBB_GetBkColor_External(a1, v4);
    }
    if ( v5 & 4 )
    {
      if ( *(_DWORD *)(v4 + 12) )
        v13 = lstrlenW(*(LPCWSTR *)(v4 + 12));
      else
        v13 = 0;
      v14 = *(_DWORD *)(a3 + 24);
      if ( v14 && (v15 = *(wchar_t **)(a3 + 20)) != 0 && v14 > v13 )
      {
        if ( *(_DWORD *)(v4 + 12) )
          StringCchCopyW(v15, v14, *(STRSAFE_LPCWSTR *)(v4 + 12));
        else
          *v15 = 0;
      }
      else
      {
        *(_DWORD *)(a3 + 24) = v13 + 1;
      }
    }
    v6 = *(_DWORD *)(a3 + 4);
    if ( v6 & 8 )
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v4 + 20);
    if ( v6 & 0x10 )
      *(_DWORD *)(a3 + 32) = *(_DWORD *)(v4 + 24);
    if ( v6 & 0x20 )
    {
      v16 = *(_DWORD *)(v4 + 28);
      v17 = v16 ? v16 - 2 * g_cxEdge : 0;
      *(_DWORD *)(a3 + 36) = v17;
      *(_DWORD *)(a3 + 40) = *(_DWORD *)(v4 + 32);
      if ( *(_BYTE *)v4 & 0x40 )
      {
        *(_DWORD *)(a3 + 64) = *(_DWORD *)(v4 + 84);
        *(_DWORD *)(a3 + 60) = *(_DWORD *)(v4 + 80);
        *(_DWORD *)(a3 + 56) = *(_DWORD *)(v4 + 88);
      }
    }
    if ( (char)v6 < 0 )
      *(_DWORD *)(a3 + 48) = *(_DWORD *)(v4 + 44);
    if ( v6 & 0x100 )
      *(_DWORD *)(a3 + 52) = *(_DWORD *)(v4 + 76);
    if ( v6 & 0x400 )
      *(_DWORD *)(a3 + 72) = *(_DWORD *)(v4 + 92);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F780429) --------------------------------------------------------
void __stdcall RBAutoSize(int a1)
{
  LPARAM lParam; // [sp+4h] [bp-30h]@2
  int v2; // [sp+10h] [bp-24h]@2
  struct tagRECT Rect; // [sp+14h] [bp-20h]@2
  struct tagRECT v4; // [sp+24h] [bp-10h]@2

  if ( *(_DWORD *)(a1 + 8) & 0x2000 )
  {
    GetClientRect(*(HWND *)a1, &Rect);
    v2 = RBSizeBarToRect(a1, (int)&Rect);
    GetClientRect(*(HWND *)a1, &v4);
    CCSendNotify(a1, -834, (LPARAM)&lParam);
  }
}

//----- (6F780495) --------------------------------------------------------
int __stdcall RBRecalc(int a1)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // edi@1
  HWND v4; // ecx@3
  int v5; // eax@4
  LONG v6; // eax@6
  unsigned int v7; // ecx@9
  int v8; // edx@10
  unsigned int v9; // ebx@15
  int v10; // edi@15
  int v11; // ecx@15
  int v12; // eax@17
  int v13; // eax@20
  int v14; // eax@22
  unsigned int v15; // edx@27
  int i; // eax@27
  int v17; // ecx@33
  int v18; // eax@33
  unsigned int v19; // ecx@34
  int v20; // eax@36
  LONG v21; // edi@36
  int v22; // ebx@37
  LONG v23; // edx@37
  int v24; // ebx@37
  int v25; // ecx@37
  int v26; // ST08_4@42
  int result; // eax@46
  int v28; // ecx@63
  LONG v29; // ecx@71
  unsigned int v30; // eax@79
  int j; // eax@88
  struct tagRECT Rect; // [sp+Ch] [bp-38h]@5
  unsigned int v33; // [sp+1Ch] [bp-28h]@37
  LONG v34; // [sp+20h] [bp-24h]@14
  unsigned int v35; // [sp+24h] [bp-20h]@1
  int v36; // [sp+28h] [bp-1Ch]@15
  int v37; // [sp+2Ch] [bp-18h]@1
  int v38; // [sp+30h] [bp-14h]@9
  LONG v39; // [sp+34h] [bp-10h]@12
  unsigned int v40; // [sp+38h] [bp-Ch]@16
  LONG v41; // [sp+3Ch] [bp-8h]@7
  int v42; // [sp+40h] [bp-4h]@15
  int v43; // [sp+4Ch] [bp+8h]@12

  v1 = a1;
  v37 = *(_DWORD *)(a1 + 104);
  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a1 + 8) & 0x80;
  v35 = 0xFFFF;
  if ( !*(_DWORD *)(a1 + 52) )
    return 0;
  if ( v2 & 0xC )
  {
    v4 = *(HWND *)a1;
  }
  else
  {
    v4 = *(HWND *)(a1 + 4);
    if ( !v4 )
      return 0;
  }
  v5 = *(_DWORD *)(a1 + 40);
  if ( !(v5 & 0x20) )
  {
    *(_DWORD *)(a1 + 40) = v5 | 0x10;
    return 0;
  }
  *(_DWORD *)(a1 + 40) = v5 & 0xFFFFFFEF;
  GetClientRect(v4, &Rect);
  if ( v3 )
    v6 = Rect.bottom - Rect.top;
  else
    v6 = Rect.right - Rect.left;
  v41 = v6;
  if ( v6 <= 0 )
    v41 = 1;
  v7 = 0;
  v38 = *(_DWORD *)(a1 + 8) & 0x400;
  if ( *(_DWORD *)(a1 + 52) > 0u )
  {
    v8 = 0;
    do
    {
      ++v7;
      *(_DWORD *)(v8 + *(_DWORD *)(a1 + 104) + 56) = *(_DWORD *)(v8 + *(_DWORD *)(a1 + 104) + 64);
      v8 += 120;
    }
    while ( v7 < *(_DWORD *)(a1 + 52) );
  }
  v39 = 0;
  v43 = 0;
  if ( *(_DWORD *)(v1 + 52) > 0u )
  {
    do
    {
      if ( v38 && v39 > 0 )
        v39 += g_cyEdge;
      v34 = 0;
      while ( 1 )
      {
        v9 = v43;
        v10 = v37;
        v11 = 0;
        v42 = 0;
        v36 = 0;
        if ( (unsigned int)v43 < *(_DWORD *)(v1 + 52) )
        {
          v40 = v43;
          do
          {
            v12 = *(_DWORD *)v10;
            if ( *(_DWORD *)v10 & 8 )
            {
              ++v40;
            }
            else
            {
              if ( v9 > v40 )
              {
                if ( v12 & 1 && !(v12 & 2) )
                  break;
                if ( v38 )
                  v36 = g_cxEdge + v11;
              }
              if ( v12 & 2 )
              {
                v35 = v9;
                if ( v40 == v9 )
                {
                  v30 = RBBNextVisible(v1, v10);
                  v33 = v30;
                  if ( v30 )
                  {
                    if ( *(_BYTE *)v30 & 1 && *(_BYTE *)(v1 + 40) & 8 && IsWindowVisible(*(HWND *)v1) )
                      *(_DWORD *)v33 &= 0xFFFFFFFE;
                  }
                }
                *(_DWORD *)(v10 + 56) = *(_DWORD *)(v10 + 68);
              }
              v13 = *(_DWORD *)(v10 + 68);
              if ( *(_DWORD *)(v10 + 56) < v13 )
                *(_DWORD *)(v10 + 56) = v13;
              v11 = v13 + v36;
              v36 += v13;
              if ( v9 <= v40 )
                goto LABEL_101;
              if ( v11 > (unsigned int)v41 )
                break;
              if ( v38 )
                v14 = g_cxEdge + v42;
              else
LABEL_101:
                v14 = v42;
              v42 = *(_DWORD *)(v10 + 56) + v14;
            }
            ++v9;
            v10 += 120;
          }
          while ( v9 < *(_DWORD *)(v1 + 52) );
        }
        if ( v43 )
          break;
        if ( v35 != 0xFFFF )
        {
          RBMoveBand(v1, v35, v9 - 1);
          break;
        }
        v15 = *(_DWORD *)(v1 + 52);
        v40 = v9;
        for ( i = 120 * v9; ; i += 120 )
        {
          if ( v9 >= v15 )
          {
            v9 = v40;
            goto LABEL_30;
          }
          v28 = *(_DWORD *)(i + *(_DWORD *)(v1 + 104));
          if ( !(v28 & 8) )
          {
            if ( v28 & 2 )
              break;
          }
          ++v9;
        }
        RBMoveBand(v1, v9, v40);
      }
LABEL_30:
      if ( v42 <= (unsigned int)v41 )
      {
        if ( v42 < (unsigned int)v41 )
        {
          for ( j = v9 - 1; j >= (unsigned int)v43; --j )
          {
            v10 -= 120;
            if ( j == v43 || !(*(_BYTE *)v10 & 0xA) && *(_DWORD *)(v10 + 56) > *(_DWORD *)(v37 + 68) )
            {
              if ( !(*(_BYTE *)v10 & 8) || (v10 = RBBNextVisible(v1, v10)) != 0 )
                *(_DWORD *)(v10 + 56) += v41 - v42;
              break;
            }
          }
        }
      }
      else
      {
        v40 = v43;
        if ( v43 < v9 )
        {
          while ( 1 )
          {
            v10 -= 120;
            if ( !(*(_BYTE *)v10 & 8) )
            {
              v17 = *(_DWORD *)(v10 + 56);
              v18 = *(_DWORD *)(v10 + 68);
              if ( v17 > v18 )
              {
                v42 += v18 - v17;
                v19 = v41;
                *(_DWORD *)(v10 + 56) = v18;
                if ( v42 <= v19 )
                  break;
              }
            }
            ++v40;
            if ( v40 >= v9 )
              goto LABEL_36;
          }
          *(_DWORD *)(v10 + 56) = v19 + v18 - v42;
        }
      }
LABEL_36:
      v20 = RBGetLineHeight(v1, v43, v9 - 1);
      v21 = v39;
      v36 = v20;
      if ( v43 < v9 )
      {
        v22 = v9 - v43;
        v23 = v34;
        v43 += v22;
        v33 = v22;
        v24 = v37;
        v25 = v20;
        do
        {
          if ( !(*(_BYTE *)v24 & 8) )
          {
            if ( *(_DWORD *)(v24 + 52) != v21 || *(_DWORD *)(v24 + 48) != v23 || *(_DWORD *)(v24 + 60) != v25 )
            {
              Rect.left = *(_DWORD *)(v24 + 48);
              if ( Rect.left >= v23 )
                Rect.left = v23;
              Rect.top = *(_DWORD *)(v24 + 52);
              if ( Rect.top >= v21 )
                Rect.top = v21;
              Rect.right = v41;
              v29 = v21 + v25;
              Rect.bottom = *(_DWORD *)(v24 + 52) + *(_DWORD *)(v24 + 60);
              if ( Rect.bottom <= v29 )
                Rect.bottom = v29;
              if ( v38 )
              {
                Rect.left -= g_cxEdge;
                Rect.bottom += g_cyEdge / 2;
              }
              RBInvalidateRect(v1, &Rect);
              v23 = v34;
              v25 = v36;
            }
            v26 = *(_DWORD *)(v24 + 56);
            *(_DWORD *)(v24 + 48) = v23;
            *(_DWORD *)(v24 + 52) = v21;
            *(_DWORD *)(v24 + 60) = v25;
            v23 += _RBBandWidth(v1, v26);
            v34 = v23;
          }
          v24 += 120;
          --v33;
        }
        while ( v33 );
        v37 = v24;
      }
      v39 = v36 + v21;
    }
    while ( (unsigned int)v43 < *(_DWORD *)(v1 + 52) );
  }
  result = v39;
  *(_DWORD *)(v1 + 84) = v39;
  return result;
}

//----- (6F7806B3) --------------------------------------------------------
signed int __stdcall RBIDToIndex(int a1, unsigned __int16 a2)
{
  unsigned int v2; // edi@1
  signed int result; // eax@4
  int v4; // [sp+8h] [bp-50h]@1
  int v5; // [sp+Ch] [bp-4Ch]@1
  int v6; // [sp+3Ch] [bp-1Ch]@3

  v2 = 0;
  v4 = 80;
  v5 = 256;
  if ( *(_DWORD *)(a1 + 52) )
  {
    while ( !RBGetBandInfo(a1, v2, (int)&v4) || v6 != a2 )
    {
      ++v2;
      if ( v2 >= *(_DWORD *)(a1 + 52) )
        goto LABEL_7;
    }
    result = v2;
  }
  else
  {
LABEL_7:
    result = -1;
  }
  return result;
}

//----- (6F780726) --------------------------------------------------------
HWND __stdcall RBSendNotify(int a1, int a2, int a3)
{
  int v3; // eax@2
  LPARAM lParam; // [sp+4h] [bp-20h]@1
  char v6; // [sp+8h] [bp-1Ch]@1
  int v7; // [sp+10h] [bp-14h]@2
  int v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+18h] [bp-Ch]@2
  int v10; // [sp+1Ch] [bp-8h]@2
  int v11; // [sp+20h] [bp-4h]@2

  lParam = 0;
  memset(&v6, 0, 0x1Cu);
  v8 = a2;
  if ( a2 != -1 )
  {
    v7 = 7;
    v3 = *(_DWORD *)(a1 + 104) + 120 * a2;
    v10 = *(_DWORD *)(v3 + 76);
    v9 = *(_DWORD *)v3;
    v11 = *(_DWORD *)(v3 + 92);
  }
  return CCSendNotify(a1, a3, (LPARAM)&lParam);
}

//----- (6F7807E6) --------------------------------------------------------
int __stdcall RBSetRecalc(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@1

  result = a1;
  *(_DWORD *)(result + 40) ^= (*(_DWORD *)(a1 + 40) ^ 32 * a2) & 0x20;
  v3 = *(_DWORD *)(a1 + 40);
  if ( a2 )
  {
    if ( v3 & 0x10 )
      result = RBRecalc(a1);
  }
  return result;
}

//----- (6F78085B) --------------------------------------------------------
int __stdcall RBDestroy(HLOCAL hMem)
{
  int v1; // edi@1

  v1 = *((_DWORD *)hMem + 13);
  RBSetRedraw((int)hMem, 0);
  RBSetRecalc((int)hMem, 0);
  while ( v1 )
  {
    --v1;
    RBDeleteBand((int)hMem, v1);
  }
  *((_DWORD *)hMem + 2) &= 0xFFFFDFFF;
  RBSetPalette((int)hMem, 0);
  if ( *((_DWORD *)hMem + 19) && *((_DWORD *)hMem + 10) & 0x400 )
    DeleteObject(*((HGDIOBJ *)hMem + 19));
  if ( *((_DWORD *)hMem + 2) & 0x100 && IsWindow(*((HWND *)hMem + 12)) )
  {
    DestroyWindow(*((HWND *)hMem + 12));
    *((_DWORD *)hMem + 12) = 0;
  }
  SetWindowLongW(*(HWND *)hMem, 0, 0);
  if ( *((_DWORD *)hMem + 11) )
    DestroyDragProxy(*((CDragProxy **)hMem + 11));
  LocalFree(hMem);
  return 1;
}

//----- (6F7808E1) --------------------------------------------------------
void *__stdcall RBSetPalette(int a1, void *a2)
{
  void *v2; // ebx@1

  v2 = *(void **)(a1 + 36);
  if ( a2 != v2 )
  {
    if ( !(*(_DWORD *)(a1 + 40) & 0x200) && v2 )
    {
      DeleteObject(v2);
      *(_DWORD *)(a1 + 36) = 0;
    }
    if ( a2 )
    {
      *(_DWORD *)(a1 + 40) |= 0x200u;
      *(_DWORD *)(a1 + 36) = a2;
    }
    RBInvalidateRect(a1, 0);
  }
  return v2;
}

//----- (6F780904) --------------------------------------------------------
signed int __stdcall RBDeleteBand(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  unsigned int v4; // edi@3
  int v5; // eax@3
  int v6; // eax@5
  int v7; // eax@6
  unsigned int v8; // eax@8
  unsigned int v9; // eax@10
  signed int result; // eax@13
  LPARAM lParam; // [sp+8h] [bp-20h]@1
  char v12; // [sp+Ch] [bp-1Ch]@1
  int v13; // [sp+14h] [bp-14h]@3
  int v14; // [sp+20h] [bp-8h]@3
  int v15; // [sp+30h] [bp+8h]@3

  lParam = 0;
  v2 = a1;
  memset(&v12, 0, 0x1Cu);
  v3 = *(_DWORD *)(a1 + 88);
  if ( v3 != -1 )
  {
    RBSendNotify(a1, v3, -836);
    RBOnBeginDrag(a1, -1);
  }
  if ( (unsigned int)a2 >= *(_DWORD *)(a1 + 52) )
  {
    result = 0;
  }
  else
  {
    v4 = 120 * a2 + *(_DWORD *)(a1 + 104);
    RBSendNotify(a1, a2, -837);
    v5 = *(_DWORD *)(a1 + 104);
    v13 = 1;
    v14 = *(_DWORD *)(v5 + 120 * a2 + 76);
    Str_Set(v4 + 12, 0);
    v15 = RBRecalcFirst(0, a1, v4);
    if ( IsWindow(*(HWND *)(v4 + 24)) )
      ShowWindow(*(HWND *)(v4 + 24), 0);
    v6 = *(_DWORD *)(v2 + 52);
    if ( v6 )
      v7 = 120 * v6 + *(_DWORD *)(v2 + 104) - 120;
    else
      v7 = 0;
    if ( v4 < v7 )
      qmemcpy((void *)v4, (const void *)(v4 + 120), 4 * (120 * ((v7 - v4 - 1) / 0x78 + 1) >> 2));
    v8 = *(_DWORD *)(v2 + 52);
    if ( v8 > 0 )
      *(_DWORD *)(v2 + 52) = v8 - 1;
    v9 = *(_DWORD *)(v2 + 116);
    if ( v9 >= a2 && v9 > 0 )
      *(_DWORD *)(v2 + 116) = v9 - 1;
    CCSendNotify(v2, -838, (LPARAM)&lParam);
    if ( v15 )
      RBRecalcFirst(1, v2, 0);
    RBReallocBands(v2, *(_DWORD *)(v2 + 52));
    RBInvalidateRect(v2, 0);
    RBResize(v2, 0);
    RBAutoSize(v2);
    result = 1;
  }
  return result;
}

//----- (6F780A09) --------------------------------------------------------
signed int __stdcall RBRecalcFirst(int a1, int a2, unsigned int a3)
{
  int v3; // edi@1
  int v4; // eax@3
  unsigned int v5; // ebx@4
  int v7; // ebx@11
  int v8; // eax@12
  unsigned int v9; // eax@14

  v3 = 0;
  if ( a1 )
  {
    if ( a1 != 1 )
      return 0;
    v7 = RBEnumBand(a2, 0, 8);
    if ( *(_BYTE *)v7 & 2 )
    {
      v8 = *(_DWORD *)(a2 + 52);
      if ( v8 )
        v3 = 120 * v8 + *(_DWORD *)(a2 + 104) - 120;
      v9 = RBEnumBand(a2, 1, 8);
      if ( v9 <= v3 )
        *(_DWORD *)v9 &= 0xFFFFFFFE;
    }
    if ( *(_DWORD *)(a2 + 8) & 0x800 )
      RBBCalcMinWidth(a2, v7);
  }
  else
  {
    if ( RBEnumBand(a2, 0, 8) != a3 )
      return 0;
    v4 = *(_DWORD *)(a2 + 52);
    v5 = v4 ? 120 * v4 + *(_DWORD *)(a2 + 104) - 120 : 0;
    if ( RBGetNext(a2, a3, 8) > v5 )
      return 0;
  }
  return 1;
}

//----- (6F780B73) --------------------------------------------------------
void __stdcall RBInitPaletteHack(int a1)
{
  HDC v1; // eax@2
  HDC v2; // edi@2

  if ( !(*(_DWORD *)(a1 + 40) & 0x200) )
  {
    v1 = CreateCompatibleDC(0);
    v2 = v1;
    if ( v1 )
    {
      if ( GetDeviceCaps(v1, 12) <= 8 )
      {
        if ( *(_DWORD *)(a1 + 36) )
          DeleteObject(*(HGDIOBJ *)(a1 + 36));
        *(_DWORD *)(a1 + 36) = CreateHalftonePalette(v2);
      }
      DeleteDC(v2);
    }
  }
}

//----- (6F780C1D) --------------------------------------------------------
int __stdcall InvalidateButton(HDC hDC, int a2, BOOL bErase)
{
  int result; // eax@1
  RECT Rect; // [sp+4h] [bp-10h]@1

  result = TB_GetItemRect(hDC, (a2 - *((_DWORD *)hDC + 12)) / 28, (int)&Rect);
  if ( result )
    result = InvalidateRect(*(HWND *)hDC, &Rect, bErase);
  return result;
}

//----- (6F780E65) --------------------------------------------------------
HWND __stdcall SendNotifyEx(int a1, HWND hWnd, int a3, LPARAM lParam, int a5)
{
  HWND v5; // eax@1
  HWND result; // eax@2
  int v7; // [sp+4h] [bp-24h]@2
  HWND v8; // [sp+8h] [bp-20h]@2
  int v9; // [sp+14h] [bp-14h]@2
  int v10; // [sp+18h] [bp-10h]@2

  v5 = (HWND)a1;
  if ( a1 || IsWindow(hWnd) && (v5 = GetParent(hWnd)) != 0 )
  {
    v8 = v5;
    v7 = (int)hWnd;
    v10 = 0;
    v9 ^= ((unsigned __int8)v9 ^ (a5 != 0)) & 1;
    result = CCSendNotify((int)&v7, a3, lParam);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F780EB0) --------------------------------------------------------
int __stdcall _RBBandWidth(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  if ( *(_DWORD *)(a1 + 8) & 0x400 )
    result = g_cxEdge + a2;
  return result;
}

//----- (6F780ED1) --------------------------------------------------------
int __stdcall RBValidateBandInfo(int a1, void *Dst)
{
  size_t v2; // edx@1
  int result; // eax@1

  v2 = **(_DWORD **)a1;
  result = v2 == 80;
  if ( v2 != 80 && v2 < 0x50 )
  {
    memmove(Dst, *(const void **)a1, v2);
    *(_DWORD *)a1 = Dst;
    *(_DWORD *)Dst = 80;
    result = 1;
  }
  return result;
}

//----- (6F780FC4) --------------------------------------------------------
signed int __stdcall RBSetBarInfo(int a1, int a2)
{
  int v2; // esi@1
  signed int result; // eax@4
  int v4; // edi@7
  int v5; // ebx@7
  int *v6; // ST08_4@7
  int v7; // ecx@7
  struct _IMAGELIST *v8; // ST00_4@7
  int v9; // edi@10
  unsigned int v10; // ebx@10
  int v11; // [sp+4h] [bp-8h]@7
  int v12; // [sp+8h] [bp-4h]@7
  int v13; // [sp+14h] [bp+8h]@7

  v2 = a1;
  if ( a1 && *(_DWORD *)a2 == 12 )
  {
    if ( *(_BYTE *)(a2 + 4) & 1 )
    {
      v11 = *(_DWORD *)(a1 + 64);
      v4 = a1 + 68;
      v5 = a1 + 72;
      v6 = (int *)(a1 + 72);
      v13 = *(_DWORD *)(a1 + 68);
      v7 = *(_DWORD *)(v2 + 72);
      v8 = *(struct _IMAGELIST **)(a2 + 8);
      *(_DWORD *)(v2 + 64) = v8;
      v12 = v7;
      ImageList_GetIconSize(v8, (int *)(v2 + 68), v6);
      if ( *(_DWORD *)v4 != v13 || *(_DWORD *)v5 != v12 )
      {
        v9 = 0;
        v10 = 0;
        if ( *(_DWORD *)(v2 + 52) )
        {
          do
          {
            if ( !(*(_BYTE *)(v9 + *(_DWORD *)(v2 + 104)) & 8) )
              RBBCalcMinWidth(v2, v9 + *(_DWORD *)(v2 + 104));
            ++v10;
            v9 += 120;
          }
          while ( v10 < *(_DWORD *)(v2 + 52) );
        }
        RBResize(v2, 0);
      }
      else
      {
        RBInvalidateRect(v2, 0);
      }
      *(_DWORD *)(a2 + 8) = v11;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F781258) --------------------------------------------------------
int __stdcall WrapToolbar(HDC hDC, int a2, int a3, int a4)
{
  HDC v4; // esi@1
  int v5; // eax@1
  int v6; // ecx@5
  int v7; // eax@5
  int v8; // edi@6
  char v9; // al@7
  char v10; // bl@7
  int v11; // ebx@7
  int result; // eax@19
  unsigned int v13; // ecx@23
  int i; // ebx@23
  char v15; // al@24
  int v16; // eax@31
  char v17; // al@50
  int v18; // [sp+4h] [bp-28h]@7
  int v19; // [sp+8h] [bp-24h]@5
  int v20; // [sp+Ch] [bp-20h]@1
  signed int v21; // [sp+10h] [bp-1Ch]@1
  int v22; // [sp+14h] [bp-18h]@5
  int v23; // [sp+18h] [bp-14h]@1
  int v24; // [sp+1Ch] [bp-10h]@1
  signed int v25; // [sp+20h] [bp-Ch]@1
  int v26; // [sp+24h] [bp-8h]@4
  int v27; // [sp+28h] [bp-4h]@5
  HDC hDCa; // [sp+34h] [bp+8h]@5

  v4 = hDC;
  v5 = *((_DWORD *)hDC + 33);
  v21 = 0;
  v24 = 0;
  v20 = 0;
  v23 = 0;
  v25 = 0;
  if ( v5 )
  {
    if ( a2 < *((_DWORD *)hDC + 28) )
      a2 = *((_DWORD *)hDC + 28);
    v26 = *((_DWORD *)hDC + 29);
  }
  else
  {
    v26 = 0;
  }
  v6 = *((_DWORD *)hDC + 36);
  v7 = *((_DWORD *)hDC + 12) + 28 * v5;
  *((_DWORD *)hDC + 41) = -1;
  *((_DWORD *)hDC + 42) = -1;
  v19 = v7;
  v27 = v6;
  v22 = 0;
  hDCa = (HDC)*((_DWORD *)hDC + 32);
  if ( a4 )
    *(_DWORD *)a4 = 1;
  v8 = *((_DWORD *)v4 + 12);
  if ( v8 < (unsigned int)v7 )
  {
    do
    {
      v9 = *(_BYTE *)(v8 + 8);
      v10 = v9;
      v9 &= 0xDFu;
      v11 = v10 & 0x20;
      v18 = v8;
      *(_BYTE *)(v8 + 8) = v9;
      if ( !(v9 & 8) )
      {
        v27 += TBWidthOfButton(v11, v4, v8, 0);
        if ( *(_BYTE *)(v8 + 9) & 1 || v27 <= a2 )
        {
          if ( *(_BYTE *)(v8 + 9) & 1 )
          {
            if ( *((_BYTE *)v4 + 8) & 0x80 )
            {
              if ( v20 )
              {
                v17 = *(_BYTE *)(v20 + 8);
                if ( !(v17 & 0x20) )
                {
                  *(_BYTE *)(v20 + 8) = v17 | 0x20;
                  hDCa = (HDC)((char *)hDCa + v26);
                }
              }
              v27 = *((_DWORD *)v4 + 36);
              hDCa = (HDC)((char *)hDCa + TBGetSepHeight((int)v4, (int *)v8));
              *(_BYTE *)(v8 + 8) |= 0x20u;
              if ( a4 )
                ++*(_DWORD *)a4;
            }
            else if ( v25 )
            {
              *(_BYTE *)(v8 + 8) |= 0x20u;
              v25 = 0;
              v27 = *((_DWORD *)v4 + 36);
              hDCa = (HDC)((char *)hDCa + v26 + TBGetSepHeight((int)v4, (int *)v8));
              if ( a4 )
                *(_DWORD *)a4 += 2;
            }
          }
          if ( !(*(_BYTE *)(v8 + 8) & 8) )
          {
            if ( v24 && v23 && !(*(_BYTE *)(v24 + 8) & 0x20) )
              v21 = 1;
            v24 = v8;
            v23 = v11;
          }
        }
        else
        {
          v13 = *((_DWORD *)v4 + 12);
          for ( i = v8; i > v13; i -= 28 )
          {
            v15 = *(_BYTE *)(i + 8);
            if ( v15 & 0x20 )
              break;
            if ( *(_BYTE *)(i + 9) & 1 && !(v15 & 8) )
            {
              v25 = 0;
              hDCa = (HDC)((char *)hDCa + v26 + TBGetSepHeight((int)v4, (int *)i));
              v16 = a4;
              if ( a4 )
                ++*(_DWORD *)a4;
              goto LABEL_32;
            }
          }
          i = v8;
          if ( v8 != v13 )
          {
            do
              i -= 28;
            while ( i > v13 && *(_BYTE *)(i + 8) & 8 );
            if ( *(_BYTE *)(i + 8) & 0x20 )
              i = v8;
          }
          hDCa = (HDC)((char *)hDCa + v26);
          v16 = a4;
          v25 = 1;
LABEL_32:
          *(_BYTE *)(i + 8) |= 0x20u;
          if ( i != v24 || !v23 )
            v21 = 1;
          v27 = *((_DWORD *)v4 + 36);
          v8 = i;
          if ( v16 )
            ++*(_DWORD *)a4;
        }
        if ( !(*(_BYTE *)(v8 + 9) & 1) && v27 > v22 )
          v22 = v27;
        v20 = v18;
      }
      v8 += 28;
    }
    while ( v8 < (unsigned int)v19 );
  }
  result = a3;
  if ( a3 )
  {
    *(_DWORD *)(a3 + 8) = v22;
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)(a3 + 12) = (char *)hDCa + *((_DWORD *)v4 + 32) + v26;
  }
  if ( v21 )
    result = InvalidateRect(*(HWND *)v4, 0, 1);
  return result;
}

//----- (6F78142E) --------------------------------------------------------
signed int __stdcall RBBandsAtMinHeight(unsigned int a1)
{
  int v1; // edi@1
  unsigned int v2; // eax@1
  signed int v3; // esi@1
  int v4; // eax@6

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 104);
  v3 = 1;
LABEL_2:
  a1 = v2;
  while ( v2 )
  {
    if ( *(_BYTE *)v2 & 8 || *(_DWORD *)(v2 + 48) )
    {
      v2 = RBBNextVisible(v1, v2);
      goto LABEL_2;
    }
    v4 = RBGetRowHeightExtra(v1, &a1, 0);
    v3 = v4 == 0;
    if ( v4 )
      return v3;
    v2 = a1;
  }
  return v3;
}

//----- (6F781480) --------------------------------------------------------
int __stdcall RBResizeChildren(int a1)
{
  int result; // eax@1
  HDWP v2; // eax@3
  unsigned int v3; // esi@3
  int v4; // eax@3
  int v5; // eax@6
  int v6; // ecx@6
  unsigned int v7; // edx@9
  int v8; // ebx@9
  int v9; // edi@9
  int v10; // eax@9
  int v11; // eax@9
  int v12; // ecx@9
  int v13; // edi@9
  int v14; // eax@9
  unsigned int v15; // eax@13
  unsigned int v16; // edx@15
  int v17; // eax@15
  unsigned int v18; // ecx@15
  int v19; // eax@18
  int v20; // eax@28
  LPARAM lParam; // [sp+4h] [bp-54h]@21
  int v22; // [sp+10h] [bp-48h]@19
  int v23; // [sp+14h] [bp-44h]@19
  int x; // [sp+18h] [bp-40h]@17
  int y; // [sp+1Ch] [bp-3Ch]@17
  int v26; // [sp+20h] [bp-38h]@17
  unsigned int v27; // [sp+24h] [bp-34h]@17
  int v28; // [sp+28h] [bp-30h]@19
  int v29; // [sp+2Ch] [bp-2Ch]@19
  int v30; // [sp+30h] [bp-28h]@19
  int v31; // [sp+34h] [bp-24h]@19
  int v32; // [sp+38h] [bp-20h]@9
  int v33; // [sp+3Ch] [bp-1Ch]@9
  HDWP hWinPosInfo; // [sp+40h] [bp-18h]@3
  int v35; // [sp+44h] [bp-14h]@6
  int v36; // [sp+48h] [bp-10h]@1
  int v37; // [sp+4Ch] [bp-Ch]@6
  unsigned int v38; // [sp+50h] [bp-8h]@4
  int v39; // [sp+54h] [bp-4h]@8

  v36 = *(_DWORD *)(a1 + 8) & 0x80;
  result = *(_DWORD *)(a1 + 52);
  if ( result && *(_BYTE *)(a1 + 40) & 8 )
  {
    v2 = BeginDeferWindowPos(result);
    v3 = *(_DWORD *)(a1 + 104);
    hWinPosInfo = v2;
    v4 = *(_DWORD *)(a1 + 52);
    if ( v4 )
      v38 = 120 * v4 + v3 - 120;
    else
      v38 = 0;
    while ( v3 <= v38 )
    {
      v5 = *(_DWORD *)v3;
      v6 = 0;
      v35 = 0;
      v37 = v5;
      if ( v5 & 8 || !*(_DWORD *)(v3 + 24) )
        goto LABEL_23;
      v39 = v5 & 0x200;
      if ( v5 & 0x200 && !(v5 & 2) && *(_DWORD *)(v3 + 72) > *(_DWORD *)(v3 + 28) )
        v6 = 5 * g_cxEdge + 2;
      v7 = *(_DWORD *)(v3 + 28);
      v8 = *(_DWORD *)(v3 + 48);
      v9 = *(_DWORD *)(v3 + 56);
      v10 = *(_DWORD *)(v3 + 68) - v7;
      v32 = v10;
      v11 = v10 - v6;
      v12 = v8 + v11;
      v13 = v9 - v11;
      v14 = *(_DWORD *)(v3 + 72);
      v33 = v12;
      if ( v13 < v14 && v39 && !(v37 & 2) && v14 > v7 )
      {
        v35 = 1;
        v13 += -2 - 5 * g_cxEdge;
      }
      v37 &= 2u;
      if ( !v37 )
      {
        if ( v36 )
        {
          v15 = RBBNextVisible(a1, v3);
          if ( !v15 || !*(_DWORD *)(v15 + 48) && !(*(_BYTE *)v15 & 8) )
            goto LABEL_14;
          v20 = g_cyEdge;
        }
        else
        {
          v20 = g_cxEdge;
        }
        v13 += -2 * v20;
      }
LABEL_14:
      if ( v13 < 0 )
        v13 = 0;
      v16 = *(_DWORD *)(v3 + 88);
      v17 = *(_DWORD *)(v3 + 52);
      v18 = *(_DWORD *)(v3 + 60);
      if ( v16 && v16 < v18 )
      {
        v17 += (v18 - v16) >> 1;
        v18 = *(_DWORD *)(v3 + 88);
      }
      x = v33;
      y = v17;
      v26 = v33 + v13;
      v27 = v17 + v18;
      if ( !v39 || v37 || *(_DWORD *)(v3 + 72) <= *(_DWORD *)(v3 + 28) )
        v19 = 0;
      else
        v19 = 5 * g_cxEdge + 2;
      v30 = v8 + *(_DWORD *)(v3 + 56);
      v29 = *(_DWORD *)(v3 + 52);
      v28 = v32 + v8 - v19;
      v31 = *(_DWORD *)(v3 + 60) + v29;
      v22 = (signed int)(v3 - *(_DWORD *)(a1 + 104)) / 120;
      v23 = *(_DWORD *)(v3 + 76);
      if ( v36 )
      {
        FlipRect((int)&x);
        FlipRect((int)&v28);
      }
      CCSendNotify(a1, -839, (LPARAM)&lParam);
      if ( (unsigned int)((signed int)(v3 - *(_DWORD *)(a1 + 104)) / 120) >= *(_DWORD *)(a1 + 52) )
        break;
      RBRecalcChevron(a1, v3, v35);
      DeferWindowPos(hWinPosInfo, *(HWND *)(v3 + 24), 0, x, y, v26 - x, v27 - y, 4u);
LABEL_23:
      v3 += 120;
    }
    result = EndDeferWindowPos(hWinPosInfo);
  }
  return result;
}

//----- (6F7816E4) --------------------------------------------------------
signed int __stdcall RBSetBandInfo(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // eax@37
  int v5; // ecx@37
  bool v6; // zf@37
  int v7; // ebx@37
  int v8; // eax@47
  int v9; // eax@50
  int v10; // eax@52
  HWND v11; // eax@56
  int v12; // eax@59
  int v13; // ecx@64
  int v14; // eax@65
  unsigned int v15; // edx@66
  int v16; // esi@4
  int v17; // edi@4
  int v18; // eax@8
  int v19; // eax@9
  int v20; // eax@13
  int v22; // ecx@94
  int v23; // eax@94
  int v24; // ecx@97
  int v25; // eax@103
  int v26; // eax@105
  int v27; // eax@107
  unsigned int v28; // edx@109
  unsigned int v29; // eax@111
  unsigned int v30; // ebx@113
  int v31; // ebx@117
  int v32; // ebx@120
  int v33; // eax@122
  char pv; // [sp+Ch] [bp-C4h]@128
  int v35; // [sp+10h] [bp-C0h]@129
  int v36; // [sp+14h] [bp-BCh]@129
  int v37; // [sp+60h] [bp-70h]@1
  char Dst; // [sp+64h] [bp-6Ch]@1
  struct tagRECT rc; // [sp+B0h] [bp-20h]@29
  int v40; // [sp+C0h] [bp-10h]@1
  int v41; // [sp+C4h] [bp-Ch]@1
  int v42; // [sp+C8h] [bp-8h]@1
  int v43; // [sp+CCh] [bp-4h]@1
  int v44; // [sp+DCh] [bp+Ch]@59

  v41 = 0;
  v43 = 0;
  v42 = 0;
  v40 = 0;
  v37 = 0;
  memset(&Dst, 0, 0x4Cu);
  if ( !a1 || a2 >= *(_DWORD *)(a1 + 52) || !RBValidateBandInfo((int)&a3, &v37) )
    return 0;
  v16 = *(_DWORD *)(a1 + 104) + 120 * a2;
  v17 = a3;
  if ( *(_BYTE *)(a3 + 4) & 4
    && (!*(_DWORD *)(a3 + 20) || !*(_DWORD *)(v16 + 12) || lstrcmpW(*(LPCWSTR *)(a3 + 20), *(LPCWSTR *)(v16 + 12)))
    && *(_DWORD *)(v17 + 20) != *(_DWORD *)(v16 + 12) )
  {
    Str_Set(v16 + 12, *(LPCWSTR *)(v17 + 20));
    v40 = 1;
  }
  if ( *(_BYTE *)(v17 + 4) & 1 )
  {
    v4 = *(_DWORD *)(v17 + 8);
    v5 = *(_DWORD *)v16;
    v7 = *(_DWORD *)v16 ^ *(_DWORD *)(v17 + 8);
    v6 = *(_DWORD *)v16 == *(_DWORD *)(v17 + 8);
    *(_DWORD *)v16 = v4;
    if ( !v6 )
      v43 = 1;
    if ( !(v4 & 2) || v5 & 2 )
    {
      if ( v7 & 2 )
        v42 = 1;
    }
    else
    {
      *(_DWORD *)(v16 + 68) = *(_DWORD *)(v16 + 56);
    }
    if ( (char)v7 < 0 )
      v42 = 1;
    if ( v7 & 8 )
      RBShowBand(a1, a2, ~(unsigned __int8)(*(_DWORD *)v16 >> 3) & 1);
    if ( v7 & 0x400 )
      v40 = 1;
    if ( *(_DWORD *)v16 & 2 )
      *(_DWORD *)v16 &= 0xFFFFFFFE;
  }
  if ( v40 && !(*(_BYTE *)v16 & 8) )
  {
    if ( RBBCalcTextExtent(a1, (HGDIOBJ)v16, 0) )
      v43 = 1;
    else
      v41 = 1;
  }
  if ( *(_DWORD *)(v17 + 4) & 0x200 )
  {
    v18 = *(_DWORD *)(v17 + 68);
    v19 = v18 ? v18 + 2 * g_cxEdge : 0;
    if ( v19 != *(_DWORD *)(v16 + 72) )
    {
      *(_DWORD *)(v16 + 72) = v19;
      v42 = 1;
      v43 = 1;
    }
  }
  if ( *(_BYTE *)(v17 + 4) & 0x40 )
  {
    v20 = *(_DWORD *)(v17 + 44);
    if ( *(_DWORD *)(v16 + 64) != v20 )
    {
      v43 = 1;
      *(_DWORD *)(v16 + 64) = v20;
    }
    if ( *(_BYTE *)v16 & 2 )
      *(_DWORD *)(v16 + 68) = *(_DWORD *)(v16 + 64);
  }
  if ( !(*(_DWORD *)(v17 + 4) & 0x800) )
    goto LABEL_17;
  v8 = *(_DWORD *)(v17 + 76);
  if ( v8 == -1 )
    goto LABEL_93;
  if ( !(*(_DWORD *)v16 & 0x40000000) || *(_DWORD *)(v16 + 68) != v8 + *(_DWORD *)(v16 + 28) )
  {
    if ( v8 != -1 )
    {
      v9 = *(_DWORD *)(v16 + 28);
      *(_DWORD *)v16 |= 0x40000000u;
      *(_DWORD *)(v16 + 68) = *(_DWORD *)(v17 + 76) + v9;
LABEL_51:
      v43 = 1;
      v41 = 1;
      goto LABEL_17;
    }
LABEL_93:
    *(_DWORD *)v16 &= 0xBFFFFFFF;
    v42 = 1;
    goto LABEL_51;
  }
LABEL_17:
  if ( *(_BYTE *)(v17 + 4) & 2 )
  {
    *(_DWORD *)(v16 + 4) = *(_DWORD *)(v17 + 12);
    *(_DWORD *)(v16 + 8) = *(_DWORD *)(v17 + 16);
    v41 = 1;
  }
  if ( *(_BYTE *)(v17 + 4) & 8 )
  {
    v22 = *(_DWORD *)(v16 + 20);
    v23 = *(_DWORD *)(v17 + 28);
    if ( v22 != v23 )
    {
      v24 = v22 == -1 || v23 == -1;
      *(_DWORD *)(v16 + 20) = v23;
      if ( v24 )
      {
        v43 = 1;
        v42 = 1;
      }
      else
      {
        v41 = 1;
      }
    }
  }
  if ( *(_BYTE *)(v17 + 4) & 0x10 )
  {
    v10 = *(_DWORD *)(v17 + 32);
    if ( v10 != *(_DWORD *)(v16 + 24) && (!v10 || !IsChild(*(HWND *)(v17 + 32), *(HWND *)a1)) )
    {
      if ( IsWindow(*(HWND *)(v16 + 24)) )
        ShowWindow(*(HWND *)(v16 + 24), 0);
      v11 = *(HWND *)(v17 + 32);
      *(_DWORD *)(v16 + 24) = v11;
      if ( v11 )
      {
        SetParent(v11, *(HWND *)a1);
        ShowWindow(*(HWND *)(v16 + 24), 5);
      }
      v43 = 1;
    }
  }
  if ( *(_BYTE *)(v17 + 4) & 0x20 )
  {
    v44 = *(_DWORD *)(v16 + 88);
    v12 = *(_DWORD *)(v17 + 40);
    if ( v12 != -1 )
      *(_DWORD *)(v16 + 32) = v12;
    if ( *(_BYTE *)v16 & 0x40 )
    {
      v25 = *(_DWORD *)(v17 + 64);
      if ( v25 != -1 )
        *(_DWORD *)(v16 + 84) = v25;
      v26 = *(_DWORD *)(v17 + 60);
      if ( v26 != -1 )
        *(_DWORD *)(v16 + 80) = v26;
      v27 = *(_DWORD *)(v17 + 56);
      if ( v27 != -1 )
        *(_DWORD *)(v16 + 88) = v27;
      v28 = *(_DWORD *)(v16 + 32);
      if ( *(_DWORD *)(v16 + 88) < v28 )
        *(_DWORD *)(v16 + 88) = v28;
      v29 = *(_DWORD *)(v16 + 80);
      if ( *(_DWORD *)(v16 + 88) > v29 )
        *(_DWORD *)(v16 + 88) = v29;
      v30 = *(_DWORD *)(v16 + 84);
      if ( v30 )
        *(_DWORD *)(v16 + 88) -= (*(_DWORD *)(v16 + 88) - v28) % v30;
    }
    else
    {
      *(_DWORD *)(v16 + 88) = *(_DWORD *)(v17 + 40);
    }
    if ( *(_DWORD *)(v17 + 36) != -1 )
    {
      v13 = *(_DWORD *)(v17 + 36);
      if ( !v13 || *(_BYTE *)v16 & 2 )
      {
        v14 = g_cxEdge;
      }
      else
      {
        v14 = g_cxEdge;
        v13 += 2 * g_cxEdge;
      }
      v15 = *(_DWORD *)(v16 + 28);
      if ( v15 != v13 )
      {
        v31 = *(_DWORD *)v16;
        a3 = v31;
        if ( !(v31 & 0x200) || v31 & 2 || *(_DWORD *)(v16 + 72) <= v15 )
          v32 = 0;
        else
          v32 = 5 * v14 + 2;
        v33 = *(_DWORD *)(v16 + 68) - v15 - v32;
        if ( a3 & 2 )
          v43 = 1;
        v6 = (*(_DWORD *)v16 & 0x40000000) == 0;
        *(_DWORD *)(v16 + 28) = v13;
        if ( !v6 )
          *(_DWORD *)(v16 + 68) = v13 + v33;
        v42 = 1;
      }
      if ( v44 != *(_DWORD *)(v16 + 88) )
        v43 = 1;
    }
  }
  if ( !(*(_BYTE *)(v17 + 4) & 0x80) )
    goto LABEL_22;
  if ( *(_DWORD *)(v17 + 48) && !GetObjectW(*(HANDLE *)(v17 + 48), 84, &pv) )
    return 0;
  *(_DWORD *)(v16 + 44) = *(_DWORD *)(v17 + 48);
  *(_DWORD *)(v16 + 36) = v35;
  *(_DWORD *)(v16 + 40) = v36;
  v41 = 1;
LABEL_22:
  if ( *(_DWORD *)(v17 + 4) & 0x100 )
    *(_DWORD *)(v16 + 76) = *(_DWORD *)(v17 + 52);
  if ( *(_DWORD *)(v17 + 4) & 0x400 )
    *(_DWORD *)(v16 + 92) = *(_DWORD *)(v17 + 72);
  if ( v42 && !(*(_BYTE *)v16 & 8) )
    RBBCalcMinWidth(a1, v16);
  if ( a4 )
  {
    if ( v43 )
      RBResize(a1, 0);
    if ( v41 || v43 )
    {
      SetRect(
        &rc,
        *(_DWORD *)(v16 + 48),
        *(_DWORD *)(v16 + 52),
        *(_DWORD *)(v16 + 48) + *(_DWORD *)(v16 + 56),
        *(_DWORD *)(v16 + 52) + *(_DWORD *)(v16 + 60));
      RBInvalidateRect(a1, &rc);
    }
  }
  return 1;
}

//----- (6F78186E) --------------------------------------------------------
void __stdcall RBResizeNow(int a1)
{
  int v1; // edi@3
  struct tagRECT Rect; // [sp+4h] [bp-10h]@3

  if ( a1 && *(_DWORD *)(a1 + 4) )
  {
    v1 = *(_DWORD *)(a1 + 24) & 0x400000;
    GetWindowRect(*(HWND *)a1, &Rect);
    if ( v1 )
      MapRectInRTLMirroredWindow((int)&Rect, *(HWND *)(a1 + 4));
    else
      MapWindowPoints(0, *(HWND *)(a1 + 4), (LPPOINT)&Rect, 2u);
    RBResizeChildren(a1);
    NewSize(
      *(HWND *)a1,
      *(_DWORD *)(a1 + 84),
      *(_DWORD *)(a1 + 8),
      Rect.left,
      Rect.top,
      Rect.right - Rect.left,
      Rect.bottom - Rect.top);
    if ( *(_BYTE *)(a1 + 40) & 4 )
      CCSendNotify(a1, -831, 0);
    *(_DWORD *)(a1 + 40) &= 0xFFFFFFF9;
  }
}

//----- (6F7818FE) --------------------------------------------------------
HDC __stdcall RBOnSetFont(int a1, int a2)
{
  HDC result; // eax@4
  void *v3; // edi@7
  HFONT v4; // eax@7
  int pvParam; // [sp+8h] [bp-1F8h]@6
  LOGFONTW lf; // [sp+20h] [bp-1E0h]@7

  if ( *(_DWORD *)(a1 + 40) & 0x400 )
    DeleteObject(*(HGDIOBJ *)(a1 + 76));
  *(_DWORD *)(a1 + 40) &= 0xFFFFFBFF;
  *(_DWORD *)(a1 + 76) = a2;
  if ( a2 )
  {
    result = RBAfterSetFont(a1);
  }
  else
  {
    pvParam = 500;
    if ( SystemParametersInfoW(0x29u, 0x1F4u, &pvParam, 0) )
    {
      v3 = *(void **)(a1 + 76);
      lf.lfWeight = 400;
      v4 = CreateFontIndirectW(&lf);
      *(_DWORD *)(a1 + 76) = v4;
      if ( v4 )
      {
        *(_DWORD *)(a1 + 40) |= 0x400u;
        if ( v3 )
          DeleteObject(v3);
        RBAfterSetFont(a1);
      }
      else
      {
        *(_DWORD *)(a1 + 76) = v3;
      }
    }
    result = (HDC)1;
  }
  return result;
}

//----- (6F78195B) --------------------------------------------------------
HDC __stdcall RBAfterSetFont(int a1)
{
  int v1; // esi@1
  HDC result; // eax@1
  int v3; // ebx@1
  void *v4; // eax@6
  int v5; // eax@7
  struct tagTEXTMETRICW tm; // [sp+8h] [bp-48h]@2
  HGDIOBJ h; // [sp+44h] [bp-Ch]@2
  unsigned int v8; // [sp+48h] [bp-8h]@4
  int v9; // [sp+4Ch] [bp-4h]@1
  int v10; // [sp+58h] [bp+8h]@5

  v9 = 0;
  v1 = a1;
  result = GetDC(*(HWND *)a1);
  v3 = (int)result;
  if ( result )
  {
    h = SelectObject(result, *(HGDIOBJ *)(a1 + 76));
    GetTextMetricsW((HDC)v3, &tm);
    if ( *(_DWORD *)(a1 + 80) != tm.tmHeight )
    {
      *(_DWORD *)(a1 + 80) = tm.tmHeight;
      v9 = 1;
    }
    v8 = 0;
    if ( *(_DWORD *)(a1 + 52) )
    {
      v10 = 0;
      do
      {
        v4 = (void *)(v10 + *(_DWORD *)(v1 + 104));
        if ( !(*(_BYTE *)v4 & 8) )
        {
          v5 = RBBCalcTextExtent(v1, v4, v3);
          v9 |= v5;
        }
        ++v8;
        v10 += 120;
      }
      while ( v8 < *(_DWORD *)(v1 + 52) );
    }
    SelectObject((HDC)v3, h);
    ReleaseDC(*(HWND *)v1, (HDC)v3);
    if ( v9 )
    {
      RBResize(v1, 0);
      RBInvalidateRect(v1, 0);
    }
    result = (HDC)1;
  }
  return result;
}

//----- (6F781A12) --------------------------------------------------------
int __stdcall RBBCalcTextExtent(int a1, HGDIOBJ h, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // eax@8
  BOOL v7; // eax@8
  LONG v8; // esi@8
  int v10; // eax@17
  struct tagRECT rc; // [sp+4h] [bp-14h]@8
  HDC hdc; // [sp+14h] [bp-4h]@1
  HGDIOBJ ha; // [sp+24h] [bp+Ch]@7

  v3 = (int)h;
  v4 = *(_DWORD *)h;
  hdc = (HDC)a3;
  if ( !(v4 & 8) )
  {
    if ( !(v4 & 0x400) && (v5 = *((_DWORD *)h + 3)) != 0 && *(_WORD *)v5 )
    {
      if ( !a3 )
      {
        hdc = GetDC(*(HWND *)a1);
        if ( !hdc )
          return 0;
      }
      ha = SelectObject(hdc, *(HGDIOBJ *)(a1 + 76));
      if ( *(_DWORD *)(a1 + 28) >= 5 )
      {
        rc.left = 0;
        rc.top = 0;
        rc.right = 0;
        rc.bottom = 0;
        v10 = lstrlenW(*(LPCWSTR *)(v3 + 12));
        DrawTextW(hdc, *(LPCWSTR *)(v3 + 12), v10, &rc, 0x400u);
        v8 = rc.right - rc.left;
      }
      else
      {
        v6 = lstrlenW(*(LPCWSTR *)(v3 + 12));
        v7 = GetTextExtentPointW(hdc, *(LPCWSTR *)(v3 + 12), v6, (LPSIZE)&rc.right);
        v8 = v7 != 0 ? rc.right : 0;
      }
      SelectObject(hdc, ha);
      if ( !a3 )
        ReleaseDC(*(HWND *)a1, hdc);
    }
    else
    {
      v8 = 0;
    }
    if ( *(_DWORD *)(v3 + 16) != v8 )
    {
      *(_DWORD *)(v3 + 16) = v8;
      RBBCalcMinWidth(a1, v3);
      return 1;
    }
    return 0;
  }
  return 0;
}

//----- (6F781BA5) --------------------------------------------------------
signed int __stdcall RBInsertBand(int pulResult, unsigned int a2, unsigned int a3)
{
  int v3; // edi@1
  ULONG v4; // eax@3
  unsigned int v5; // ebx@7
  int v6; // esi@7
  int v7; // ST10_4@7
  unsigned int v8; // ST0C_4@7
  bool v9; // zf@7
  int v11; // [sp+Ch] [bp-50h]@1
  char Dst; // [sp+10h] [bp-4Ch]@1

  v11 = 0;
  memset(&Dst, 0, 0x4Cu);
  v3 = pulResult;
  if ( !pulResult || !RBValidateBandInfo((int)&a3, &v11) )
    return 0;
  v4 = *(_DWORD *)(v3 + 52);
  if ( a2 == -1 )
  {
    a2 = *(_DWORD *)(v3 + 52);
  }
  else if ( a2 > v4 )
  {
    return 0;
  }
  if ( ULongAdd(v4, 1u, (ULONG *)&pulResult) < 0 || !RBReallocBands(v3, pulResult) )
    return 0;
  v5 = a2;
  ++*(_DWORD *)(v3 + 52);
  v5 *= 120;
  memmove(
    (void *)(v5 + *(_DWORD *)(v3 + 104) + 120),
    (const void *)(v5 + *(_DWORD *)(v3 + 104)),
    120 * (*(_DWORD *)(v3 + 52) - a2 - 1));
  v6 = v5 + *(_DWORD *)(v3 + 104);
  memset((void *)v6, 0, 0x78u);
  v7 = a3;
  v8 = a2;
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(v3 + 112) != -1 ? -1 : -16777216;
  v9 = *(_DWORD *)(v3 + 108) == -1;
  *(_DWORD *)(v6 + 80) = 0x7FFFFFFF;
  *(_DWORD *)(v6 + 20) = -1;
  *(_DWORD *)(v6 + 116) = 128;
  *(_DWORD *)(v6 + 8) = !v9 ? -1 : -16777216;
  if ( !RBSetBandInfo(v3, v8, v7, 0) )
  {
    RBDeleteBand(v3, a2);
    return 0;
  }
  if ( !(*(_BYTE *)v6 & 8) )
  {
    a3 = RBEnumBand(v3, 0, 8);
    if ( !*(_DWORD *)(v6 + 68) )
      RBBCalcMinWidth(v3, v6);
    if ( a3 != v6 )
      RBBCalcMinWidth(v3, a3);
    RBResize(v3, 0);
  }
  RBSizeBandToRowHeight(v3, a2, -1);
  if ( RBCountBands(v3, 8) == 1 )
    RBAutoSize(v3);
  return 1;
}

//----- (6F781CFC) --------------------------------------------------------
int __stdcall RBCountBands(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  unsigned int i; // edx@2

  v2 = *(_DWORD *)(a1 + 52);
  result = 0;
  if ( v2 )
  {
    for ( i = *(_DWORD *)(a1 + 104); i <= 120 * v2 + *(_DWORD *)(a1 + 104) - 120; i += 120 )
    {
      if ( !(a2 & *(_DWORD *)i) )
        ++result;
    }
  }
  return result;
}

//----- (6F781D85) --------------------------------------------------------
int __stdcall RBRecalcChevron(int a1, int a2, int a3)
{
  int result; // eax@3
  int v4; // ecx@8
  struct tagRECT rc; // [sp+8h] [bp-10h]@2

  if ( a3 )
  {
    rc.right = *(_DWORD *)(a2 + 48) + *(_DWORD *)(a2 + 56);
    v4 = *(_DWORD *)(a2 + 60);
    rc.left = rc.right - 5 * g_cxEdge - 2;
    rc.top = *(_DWORD *)(a2 + 52);
    rc.bottom = rc.top + v4;
  }
  else
  {
    SetRect(&rc, -1, -1, -1, -1);
  }
  result = EqualRect(&rc, (const RECT *)(a2 + 100));
  if ( !result )
  {
    if ( *(_BYTE *)(a2 + 96) & 1 )
      RBInvalidateRect(a1, (RECT *)(a2 + 100));
    *(_DWORD *)(a2 + 96) ^= ((unsigned __int8)a3 ^ (unsigned __int8)*(_DWORD *)(a2 + 96)) & 1;
    result = CopyRect((LPRECT)(a2 + 100), &rc);
    if ( *(_BYTE *)(a2 + 96) & 1 )
      result = RBInvalidateRect(a1, (RECT *)(a2 + 100));
  }
  return result;
}

//----- (6F781F06) --------------------------------------------------------
LRESULT __stdcall CIHandleNotifyFormat(int a1, int a2)
{
  LRESULT result; // eax@2

  if ( a2 == 3 )
  {
    result = 2;
  }
  else if ( a2 == 4 )
  {
    result = SendMessageW(*(HWND *)(a1 + 4), 0x55u, *(_DWORD *)a1, 3);
    *(_DWORD *)(a1 + 16) ^= (*(_DWORD *)(a1 + 16) ^ (result == 2)) & 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F781FEE) --------------------------------------------------------
HFONT __stdcall TBSetFont(int a1, HFONT a2, int a3)
{
  HFONT result; // eax@1

  result = TBChangeFont(a1, 0, a2);
  if ( a3 )
    result = (HFONT)InvalidateRect(*(HWND *)a1, 0, 1);
  return result;
}

//----- (6F78204B) --------------------------------------------------------
int __stdcall BoxIt(HDC hDC, int a2, int a3, LPRECT lpRect)
{
  signed int v4; // esi@1
  HDC v5; // edi@2
  int result; // eax@3
  int v7; // ecx@6
  int v8; // eax@7
  int v9; // ebx@7
  bool v10; // sf@7
  unsigned __int8 v11; // of@7
  char *v12; // edi@17
  int v13; // [sp+8h] [bp-18h]@1
  LONG v14; // [sp+Ch] [bp-14h]@1
  int v15; // [sp+10h] [bp-10h]@1
  int v16; // [sp+14h] [bp-Ch]@1
  int v17; // [sp+18h] [bp-8h]@7
  int v18; // [sp+1Ch] [bp-4h]@7
  int hDCa; // [sp+28h] [bp+8h]@8
  int v20; // [sp+2Ch] [bp+Ch]@7

  v13 = 0;
  v4 = a2;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  if ( a2 < 1 )
    v4 = 1;
  v5 = hDC;
  if ( v4 != CountRows((int)hDC) && (v7 = *((_DWORD *)hDC + 33)) != 0 )
  {
    v8 = *((_DWORD *)hDC + 28);
    v9 = v7 + 1;
    v11 = __OFSUB__(v4 + 1, v4);
    v10 = 0;
    v17 = v8;
    v18 = v4 + 1;
    v20 = v8;
    if ( !(v11 | (v4 + 1 == v4)) )
    {
      hDCa = v8 / 4;
      do
      {
        WrapToolbar(v5, v20, (int)&v13, (int)&v18);
        if ( v18 < v9 && v18 > v4 )
        {
          v17 = v20;
          v9 = v18;
        }
        v20 += hDCa;
        v11 = __OFSUB__(v18, v4);
        v10 = v18 - v4 < 0;
      }
      while ( v18 > v4 );
    }
    if ( v10 ^ v11 && a3 )
      WrapToolbar(v5, v17, (int)&v13, 0);
    if ( lpRect )
    {
      lpRect->left = v13;
      lpRect->top = v14;
      v12 = (char *)&lpRect->right;
      *(_DWORD *)v12 = v15;
      *((_DWORD *)v12 + 1) = v16;
    }
    result = 1;
  }
  else
  {
    GetClientRect(*(HWND *)hDC, lpRect);
    result = 0;
  }
  return result;
}

//----- (6F7820A2) --------------------------------------------------------
signed int __stdcall TBGetMaxSize(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@3
  int v5; // edx@4
  int v6; // edx@9
  int v7; // eax@10
  signed int result; // eax@12

  v2 = 0;
  v3 = 0;
  if ( a2 )
  {
    if ( *(_BYTE *)(a1 + 36) & 2 )
    {
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 248) - *(_DWORD *)(a1 + 240);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 252) - *(_DWORD *)(a1 + 244);
    }
    else
    {
      v4 = *(_DWORD *)(a1 + 132);
      if ( v4 > 0 )
      {
        v5 = *(_DWORD *)(a1 + 48) + 9;
        do
        {
          if ( !(*(_BYTE *)(v5 - 1) & 8) )
          {
            if ( *(_BYTE *)v5 & 1 )
              ++v3;
            else
              ++v2;
          }
          v5 += 28;
          --v4;
        }
        while ( v4 );
      }
      v6 = *(_DWORD *)(a1 + 112);
      if ( *(_BYTE *)(a1 + 8) & 0x80 )
      {
        *(_DWORD *)a2 = v6;
        v7 = v2 * *(_DWORD *)(a1 + 116) + 8 * v3;
      }
      else
      {
        *(_DWORD *)a2 = v2 * v6 + 8 * v3;
        v7 = *(_DWORD *)(a1 + 116);
      }
      *(_DWORD *)(a2 + 4) = v7;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F782116) --------------------------------------------------------
int __stdcall RBGetRowHeightExtra(int a1, unsigned int *a2, int a3)
{
  unsigned int v3; // eax@1
  unsigned int v4; // ecx@3
  int v5; // edi@3
  int v6; // esi@3
  bool v7; // zf@4
  bool v8; // sf@4
  unsigned __int8 v9; // of@4
  int v11; // edx@9
  int i; // [sp+0h] [bp-4h]@1

  v3 = *a2;
  for ( i = 0; v3; v3 = RBBNextVisible(a1, v3) )
  {
    if ( v3 != a3 )
    {
      v4 = *(_DWORD *)(v3 + 88);
      v5 = 0;
      v6 = *(_DWORD *)(v3 + 88);
      if ( *(_BYTE *)v3 & 0x40 )
      {
        v11 = *(_DWORD *)(v3 + 32);
        if ( v4 > v11 + *(_DWORD *)(v3 + 84) )
        {
          v6 = *(_DWORD *)(v3 + 32);
          v5 = v4 - v11;
        }
      }
      v9 = 0;
      v7 = v6 == 0;
      v8 = v6 < 0;
      if ( !v6 )
      {
        v9 = __OFSUB__(v5, i);
        v7 = v5 == i;
        v8 = v5 - i < 0;
      }
      if ( !((unsigned __int8)(v8 ^ v9) | v7) )
        i = v5;
    }
  }
  *a2 = v3;
  return i;
}

//----- (6F78216F) --------------------------------------------------------
unsigned int __stdcall RBBNextVisible(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int v3; // eax@1
  int v4; // eax@2

  v2 = RBGetNext(a1, a2, 8);
  v3 = *(_DWORD *)(a1 + 52);
  if ( v3 )
    v4 = 120 * v3 + *(_DWORD *)(a1 + 104) - 120;
  else
    v4 = 0;
  return v4 >= v2 ? v2 : 0;
}

//----- (6F7821C3) --------------------------------------------------------
int __stdcall RBBCalcMinWidth(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int result; // eax@1
  int v5; // ecx@3
  int v6; // edx@6
  unsigned int v7; // ecx@8
  int v8; // ecx@10
  int v9; // ebx@12
  int v10; // eax@14
  int v11; // edx@16
  int v12; // [sp+10h] [bp+8h]@10
  int v13; // [sp+14h] [bp+Ch]@5

  v2 = a2;
  v3 = a1;
  result = RBShouldDrawGripper(a1, a2);
  v13 = *(_DWORD *)(a2 + 20) == -1 && (*(_DWORD *)a2 & 0x400 || (v5 = *(_DWORD *)(a2 + 12)) == 0 || !*(_WORD *)v5);
  v6 = *(_DWORD *)v2;
  if ( !(*(_DWORD *)v2 & 8) && !(v6 & 0x40000000) )
  {
    v7 = *(_DWORD *)(v2 + 28);
    *(_DWORD *)(v2 + 68) = v7;
    if ( v6 & 0x200 && !(v6 & 2) && *(_DWORD *)(v2 + 72) > v7 )
      *(_DWORD *)(v2 + 68) = 5 * g_cxEdge + v7 + 2;
    if ( result || !v13 )
    {
      v8 = *(_DWORD *)(a1 + 8) & 0x80;
      v12 = *(_DWORD *)(a1 + 8) & 0x80;
      if ( v12 && *(_DWORD *)(v3 + 8) & 0x4000 )
      {
        *(_DWORD *)(v2 + 68) += 4 * g_cyEdge;
        result = *(_DWORD *)(v3 + 72);
        if ( (unsigned int)result <= *(_DWORD *)(v3 + 80) )
          result = *(_DWORD *)(v3 + 80);
        *(_DWORD *)(v2 + 68) += result;
      }
      else
      {
        v9 = g_cyEdge;
        if ( !v8 )
          v9 = g_cxEdge;
        *(_DWORD *)(v2 + 68) += 2 * v9;
        if ( !result )
          goto LABEL_43;
        v10 = g_cyBorder;
        if ( !v12 )
          v10 = g_cxBorder;
        result = *(_DWORD *)(v2 + 68) + 5 * v10;
        *(_DWORD *)(v2 + 68) = result;
        if ( !v13 )
        {
LABEL_43:
          *(_DWORD *)(v2 + 68) += 2 * v9;
          v11 = *(_DWORD *)(v2 + 20);
          if ( v11 != -1 )
          {
            if ( v12 )
              result = *(_DWORD *)(v3 + 72);
            else
              result = *(_DWORD *)(v3 + 68);
            *(_DWORD *)(v2 + 68) += result;
          }
          if ( !(*(_DWORD *)v2 & 0x400) )
          {
            result = *(_DWORD *)(v2 + 12);
            if ( result )
            {
              if ( *(_WORD *)result )
              {
                if ( v12 )
                  result = *(_DWORD *)(v3 + 80);
                else
                  result = *(_DWORD *)(v2 + 16);
                *(_DWORD *)(v2 + 68) += result;
                if ( v11 != -1 )
                  *(_DWORD *)(v2 + 68) += v9;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (6F7822EB) --------------------------------------------------------
BOOL __stdcall RBShouldDrawGripper(int a1, int a2)
{
  return !(*(_DWORD *)a2 & 0x100) && ((char)*(_DWORD *)a2 < 0 || RBCanBandMove(a1, a2));
}

//----- (6F782321) --------------------------------------------------------
void __stdcall RBOnStyleChanged(int a1, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // edi@7
  unsigned int v5; // [sp+14h] [bp+Ch]@7

  if ( a2 == -16 )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 4);
    v3 = *(_DWORD *)a3 ^ *(_DWORD *)(a3 + 4);
    if ( (char)v3 < 0 )
    {
      v4 = 0;
      v5 = 0;
      if ( *(_DWORD *)(a1 + 52) )
      {
        do
        {
          if ( !(*(_BYTE *)(v4 + *(_DWORD *)(a1 + 104)) & 8) )
            RBBCalcMinWidth(a1, v4 + *(_DWORD *)(a1 + 104));
          ++v5;
          v4 += 120;
        }
        while ( v5 < *(_DWORD *)(a1 + 52) );
      }
      RBResize(a1, 1);
      RBInvalidateRect(a1, 0);
    }
    if ( v3 & 0x1000 )
    {
      if ( *(_DWORD *)(a1 + 8) & 0x1000 )
        *(_DWORD *)(a1 + 44) = CreateDragProxy(*(_DWORD *)a1, (int)RebarDragCallback, 1);
      else
        DestroyDragProxy(*(CDragProxy **)(a1 + 44));
    }
  }
  else if ( a2 == -20 )
  {
    if ( (*(_DWORD *)(a3 + 4) ^ *(_DWORD *)(a1 + 24)) & 0x400000 )
      RBInvalidateRect(a1, 0);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a3 + 4);
  }
}

//----- (6F78236D) --------------------------------------------------------
void __stdcall CalcTabHeight(int cy, HDC hdc)
{
  int v2; // esi@1
  bool v3; // zf@1
  LONG v4; // edx@6
  struct _IMAGELIST *v5; // eax@6
  int v6; // eax@7
  int v7; // eax@8
  int v8; // ecx@11
  int v9; // ecx@13
  HDC v10; // eax@15
  void *v11; // ST0C_4@15
  struct tagTEXTMETRICW tm; // [sp+8h] [bp-44h]@4
  int v13; // [sp+44h] [bp-8h]@16
  int v14; // [sp+48h] [bp-4h]@1

  v2 = cy;
  v3 = *(_DWORD *)(cy + 76) == 0x7FFFFFFF;
  v14 = 0;
  if ( v3 )
  {
    cy = 0;
    if ( !hdc )
    {
      v14 = 1;
      v10 = GetDC(0);
      v11 = *(void **)(v2 + 56);
      hdc = v10;
      SelectObject(v10, v11);
    }
    GetTextMetricsW(hdc, &tm);
    if ( !(*(_BYTE *)(v2 + 156) & 1) )
      *(_DWORD *)(v2 + 72) = 2 * (3 * tm.tmAveCharWidth + *(_DWORD *)(v2 + 96));
    v4 = tm.tmHeight;
    *(_DWORD *)(v2 + 84) = tm.tmHeight + 2 * g_cyEdge;
    v5 = *(struct _IMAGELIST **)(v2 + 128);
    if ( v5 )
    {
      VertImageList_GetIconSize(v5, &v13, &cy, *(_DWORD *)(v2 + 8) & 0x80);
      v4 = tm.tmHeight;
    }
    v6 = *(_DWORD *)(v2 + 108);
    if ( v6 )
    {
      v3 = (*(_DWORD *)(v2 + 8) & 0x100) == 0;
      *(_DWORD *)(v2 + 76) = v6;
      if ( v3 )
        v7 = 2 * g_cyEdge - 1;
      else
        v7 = 3 * g_cyEdge;
    }
    else
    {
      v7 = 2 * *(_DWORD *)(v2 + 100);
      if ( v7 < 2 * g_cyEdge )
        v7 = 2 * g_cyEdge;
      if ( !(*(_DWORD *)(v2 + 8) & 0x100) )
        v7 += -1 - g_cyEdge;
      v8 = v4 + g_cyEdge;
      if ( v4 + g_cyEdge <= cy )
        v8 = cy;
      *(_DWORD *)(v2 + 76) = v7 + v8;
    }
    v9 = *(_DWORD *)(v2 + 76) - v7;
    *(_DWORD *)(v2 + 152) = v4;
    *(_DWORD *)(v2 + 120) = (v9 - v4 + 1) / 2;
    *(_DWORD *)(v2 + 124) = (v9 - cy) / 2;
    if ( v14 )
      ReleaseDC(0, hdc);
  }
}

//----- (6F782397) --------------------------------------------------------
int __stdcall UpdateToolTipRects(int a1)
{
  int v1; // ebx@1
  int result; // eax@1
  int v3; // ecx@3
  int v4; // ecx@3
  int v5; // esi@6
  LPARAM lParam; // [sp+4h] [bp-30h]@3
  int v7; // [sp+8h] [bp-2Ch]@3
  int v8; // [sp+Ch] [bp-28h]@3
  int v9; // [sp+10h] [bp-24h]@6
  int v10; // [sp+14h] [bp-20h]@6
  int v11; // [sp+18h] [bp-1Ch]@6
  int v12; // [sp+1Ch] [bp-18h]@6
  int v13; // [sp+20h] [bp-14h]@6
  int v14; // [sp+28h] [bp-Ch]@3
  int v15; // [sp+30h] [bp-4h]@3
  int v16; // [sp+3Ch] [bp+8h]@3

  v1 = a1;
  result = 0;
  if ( *(_DWORD *)(a1 + 132) )
  {
    v3 = *(_DWORD *)a1;
    v14 = -1;
    v8 = v3;
    v4 = *(_DWORD *)(a1 + 40);
    lParam = 44;
    v7 = 0;
    v16 = 0;
    v15 = *(_DWORD *)v4;
    if ( v15 > 0 )
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * result);
        v9 = result;
        v10 = *(_DWORD *)v5;
        v5 += 4;
        v11 = *(_DWORD *)v5;
        v5 += 4;
        v12 = *(_DWORD *)v5;
        v13 = *(_DWORD *)(v5 + 4);
        Tab_VDFlipRect(v1, (int)&v10);
        SendMessageW(*(HWND *)(v1 + 132), 0x434u, 0, (LPARAM)&lParam);
        ++v16;
        result = v16;
        if ( v16 >= v15 )
          break;
        result = v16;
      }
    }
  }
  return result;
}

//----- (6F7823BB) --------------------------------------------------------
int __stdcall Tab_OnAdjustRect(int a1, int a2, LPRECT lprc)
{
  int v3; // eax@2
  int result; // eax@4
  int v5; // eax@7
  int v6; // eax@11
  int v7; // [sp+Ch] [bp-10h]@8
  int v8; // [sp+18h] [bp-4h]@8

  CalcPaintMetrics(a1, 0);
  if ( *(_DWORD *)(a1 + 8) & 0x100 )
  {
    v5 = *(_DWORD *)(a1 + 40);
    if ( *(_DWORD *)v5 )
    {
      Tab_OnGetItemRect(a1, *(_DWORD *)v5 - 1, (int)&v7);
      v3 = v8;
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 76) * (*(_DWORD *)(a1 + 112) + 1);
  }
  if ( a2 )
  {
    lprc->top -= v3;
    result = InflateRect(lprc, 2 * g_cxEdge, 2 * g_cyEdge);
  }
  else
  {
    lprc->top += v3;
    result = InflateRect(lprc, -2 * g_cxEdge, -2 * g_cyEdge);
  }
  if ( *(_BYTE *)(a1 + 8) & 1 )
  {
    v6 = *(_DWORD *)(a1 + 76) * (*(_DWORD *)(a1 + 112) - *(_DWORD *)(a1 + 116));
    if ( !a2 )
      v6 = -v6;
    result = OffsetRect(lprc, 0, v6);
  }
  return result;
}

//----- (6F782427) --------------------------------------------------------
void __stdcall TV_GetBackgroundBrush(int a1, WPARAM wParam)
{
  LRESULT v2; // eax@3
  LPARAM v3; // [sp-4h] [bp-8h]@2

  if ( *(_DWORD *)(a1 + 164) == -1 )
  {
    v3 = *(_DWORD *)a1;
    if ( *(_DWORD *)(a1 + 8) & 0x8000000 )
      v2 = SendMessageW(*(HWND *)(a1 + 4), 0x138u, wParam, v3);
    else
      v2 = SendMessageW(*(HWND *)(a1 + 4), 0x133u, wParam, v3);
    *(_DWORD *)(a1 + 112) = v2;
  }
}

//----- (6F782466) --------------------------------------------------------
signed int __stdcall TV_CalcScrollBars(int a1)
{
  int v1; // eax@1
  unsigned __int16 v2; // cx@3
  unsigned __int16 v3; // dx@3
  UINT v4; // ecx@5
  UINT v5; // edx@5
  signed int result; // eax@8
  int v7; // eax@10
  HWND v8; // ST04_4@11
  int v9; // eax@11
  int v10; // eax@16
  HWND v11; // ST00_4@18
  int v12; // eax@18
  SCROLLINFO v13; // [sp+8h] [bp-20h]@2
  int v14; // [sp+24h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 8);
  v14 = 0;
  if ( v1 & 0x2000 )
  {
    result = 0;
  }
  else
  {
    v13.cbSize = 28;
    if ( !(v1 & 0x8000) )
    {
      v2 = *(_WORD *)(a1 + 194);
      v3 = *(_WORD *)(a1 + 190);
      if ( (signed __int16)v2 > (signed __int16)v3 )
      {
        v7 = *(_DWORD *)(a1 + 36);
        if ( !(v7 & 1) )
        {
          v14 = 1;
          *(_DWORD *)(a1 + 36) = v7 | 1;
        }
        v13.nMax = v2 - 1;
        v13.nPage = (signed __int16)v3;
        v8 = *(HWND *)a1;
        v13.fMask = 3;
        v13.nMin = 0;
        v9 = SetScrollInfo(v8, 0, &v13, 1);
        TV_SetLeft(a1, v9);
      }
      else if ( *(_BYTE *)(a1 + 36) & 1 )
      {
        TV_SetLeft(a1, 0);
        SetScrollRange(*(HWND *)a1, 0, 0, 0, 1);
        *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
        v14 = 1;
      }
    }
    v4 = *(_WORD *)(a1 + 196);
    v5 = *(_DWORD *)(a1 + 200);
    if ( v5 > v4 )
    {
      v10 = *(_DWORD *)(a1 + 36);
      if ( !(v10 & 2) )
      {
        *(_DWORD *)(a1 + 36) = v10 | 2;
        v14 = 1;
      }
      v11 = *(HWND *)a1;
      v13.fMask = 3;
      v13.nMin = 0;
      v13.nMax = v5 - 1;
      v13.nPage = v4;
      v12 = SetScrollInfo(v11, 1, &v13, 1);
      TV_SmoothSetTopItem(a1, v12, 0);
    }
    else if ( *(_BYTE *)(a1 + 36) & 2 )
    {
      TV_SmoothSetTopItem(a1, 0, 0);
      SetScrollRange(*(HWND *)a1, 1, 0, 0, 1);
      *(_DWORD *)(a1 + 36) &= 0xFFFFFFFD;
      v14 = 1;
    }
    if ( v14 )
      TV_SizeWnd(a1, 0, 0);
    result = 1;
  }
  return result;
}

//----- (6F782EA7) --------------------------------------------------------
UINT __stdcall TV_WndProc(HWND hWnd, UINT Msg, HDC hdc, LPARAM lParam)
{
  int v4; // eax@29
  int v5; // eax@36
  int v6; // eax@39
  int v7; // eax@45
  unsigned int v8; // ecx@54
  int v9; // eax@68
  int v10; // eax@83
  int v11; // edi@104
  signed int v12; // eax@111
  UINT v13; // edi@112
  int v14; // eax@114
  int v15; // ecx@119
  const WCHAR *v16; // edi@126
  int v17; // esi@128
  int v18; // ecx@139
  unsigned __int16 v19; // di@140
  unsigned __int16 v20; // bx@140
  __int16 v21; // ax@140
  int v22; // eax@144
  int v23; // ecx@144
  int v24; // edi@152
  int v25; // ebx@152
  LONG v26; // eax@157
  int v27; // eax@159
  int v28; // eax@163
  signed int v29; // eax@166
  int v30; // eax@168
  int v31; // eax@170
  int v32; // eax@176
  int v33; // eax@176
  LONG v34; // eax@1
  unsigned int v35; // ebx@1
  LRESULT v36; // esi@1
  UINT result; // eax@17
  int v38; // [sp+Ch] [bp-30h]@111
  HDC v39; // [sp+10h] [bp-2Ch]@111
  int v40; // [sp+14h] [bp-28h]@111
  LPARAM v41; // [sp+18h] [bp-24h]@48
  int v42; // [sp+24h] [bp-18h]@46
  struct tagTRACKMOUSEEVENT EventTrack; // [sp+28h] [bp-14h]@30
  int v44; // [sp+38h] [bp-4h]@152

  v34 = GetWindowLongW(hWnd, 0);
  v35 = Msg;
  v36 = v34;
  if ( !v34 )
  {
    if ( Msg != 1 )
      return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
    CCCreateWindow();
    return TV_OnCreate(hWnd, lParam);
  }
  if ( Msg - 512 > 0xD || !(*(_DWORD *)(v34 + 8) & 0x200) || (v4 = *(_DWORD *)(v34 + 36), v4 & 0x200) )
  {
    if ( Msg == g_uDragImages )
      return TV_GenerateDragImage((HDC)v36, lParam);
  }
  else
  {
    *(_DWORD *)(v36 + 36) = v4 | 0x200;
    EventTrack.hwndTrack = *(HWND *)v36;
    EventTrack.cbSize = 16;
    EventTrack.dwFlags = 2;
    _TrackMouseEvent(&EventTrack);
  }
  if ( v35 > 0x1108 )
  {
    if ( v35 <= 0x1132 )
    {
      if ( v35 == 4402 )
      {
        result = TV_InsertItem(v36, lParam);
      }
      else
      {
        switch ( v35 )
        {
          case 0x1127u:
            v41 = lParam;
            v39 = hdc;
            v38 = 8;
            v12 = TV_OnGetItem(v36, (int)&v38);
            return v12 != 0 ? v40 : 0;
          case 0x111Du:
            v13 = *(_DWORD *)(v36 + 164);
            TV_OnSetBkColor((HDC)v36, lParam);
            goto LABEL_113;
          case 0x111Eu:
            v14 = v36 + 160;
            goto LABEL_115;
          case 0x111Fu:
            return *(_DWORD *)(v36 + 164);
          case 0x1120u:
            return *(_DWORD *)(v36 + 160);
          case 0x1122u:
            return *(_DWORD *)(v36 + 212);
          case 0x1121u:
            v15 = v36 + 212;
            goto LABEL_120;
          case 0x1114u:
            if ( !ValidateTreeItem(lParam, 0) )
              return 0;
            return TV_EnsureVisible(v36, lParam);
          case 0x1111u:
            return TV_OnHitTest(v36, lParam);
          case 0x1117u:
            if ( GetFocus() != *(HWND *)v36 )
              return 0;
            return GetIncrementSearchStringA(v36 + 236, *(_DWORD *)(v36 + 20), (LPSTR)lParam);
          case 0x110Eu:
            v16 = 0;
            if ( hdc )
              v16 = (const WCHAR *)ProduceWFromA(*(_DWORD *)(v36 + 20), (LPCSTR)hdc);
            v17 = TV_EditLabel(v36, lParam, v16);
            if ( v16 )
              FreeProducedString((HLOCAL)v16);
            return v17;
          case 0x1110u:
            return TV_GetVisCount(v36, (int)hdc);
          case 0x1112u:
            return (UINT)TV_CreateDragImage((HDC)v36, lParam);
          case 0x110Fu:
            return *(_DWORD *)(v36 + 216);
          case 0x1115u:
            return TV_SortChildrenCB(v36, lParam, (int)hdc);
          case 0x1116u:
            return TV_DismissEdit(v36, (signed int)hdc);
          case 0x1119u:
            return *(_DWORD *)(v36 + 224);
          case 0x1118u:
            v15 = v36 + 224;
LABEL_120:
            result = *(_DWORD *)v15;
            *(_DWORD *)v15 = hdc;
            return result;
          case 0x111Cu:
            return *(_WORD *)(v36 + 182);
          case 0x111Bu:
            v13 = *(_WORD *)(v36 + 182);
            v18 = (HDC)((char *)hdc + 1) != 0;
            *(_WORD *)(v36 + 182) = (_WORD)hdc;
            *(_DWORD *)(v36 + 36) ^= (*(_DWORD *)(v36 + 36) ^ (v18 << 11)) & 0x800;
            TV_SetItemHeight((HDC)v36);
            goto LABEL_113;
          case 0x1123u:
            v19 = *(_WORD *)(v36 + 186);
            v20 = *(_WORD *)(v36 + 184);
            v21 = lParam;
            if ( (unsigned __int8)hdc & 2 )
              *(_WORD *)(v36 + 186) = HIWORD(lParam);
            if ( (unsigned __int8)hdc & 1 )
              *(_WORD *)(v36 + 184) = v21;
            TV_CalcScrollBars(v36);
            v22 = v19;
            v23 = v20;
            return v23 | (v22 << 16);
          case 0x1124u:
            v22 = *(_WORD *)(v36 + 186);
            v23 = *(_WORD *)(v36 + 184);
            return v23 | (v22 << 16);
          case 0x111Au:
            return TV_SetInsertMark(v36, lParam, (int)hdc);
          case 0x1125u:
            v13 = *(_DWORD *)(v36 + 168);
            *(_DWORD *)(v36 + 168) = lParam;
            TV_InvalidateInsertMarkRect(v36, 0);
            goto LABEL_113;
          case 0x1126u:
            result = *(_DWORD *)(v36 + 168);
            break;
          case 0x1128u:
            v14 = v36 + 172;
LABEL_115:
            v13 = *(_DWORD *)v14;
            *(_DWORD *)v14 = lParam;
            TV_CreateIndentBmps((HDC)v36);
LABEL_113:
            result = v13;
            break;
          case 0x1129u:
            result = *(_DWORD *)(v36 + 172);
            break;
          case 0x110Au:
            result = TV_GetNextItem(v36, lParam, (int)hdc);
            break;
          case 0x110Cu:
            if ( !lParam )
              return 0;
            result = (UINT)TV_OnGetItemA(v36, lParam);
            break;
          case 0x110Bu:
            result = TV_SelectItem(v36, (int)hdc, lParam, 3, 0);
            break;
          case 0x1109u:
            result = TV_SetImageList((HDC)v36, (HIMAGELIST)lParam, (int)hdc);
            break;
          case 0x110Du:
            if ( !lParam )
              return 0;
            result = TV_SetItemA(v36, lParam);
            break;
          case 0x1113u:
            result = TV_SortChildren(v36, lParam, (int)hdc);
            break;
          default:
            goto LABEL_15;
        }
      }
      return result;
    }
    if ( v35 == 4414 )
      return TV_OnGetItem(v36, lParam);
    if ( v35 == 4415 )
      return TV_SetItem(v36, lParam);
    if ( v35 == 4416 )
    {
      if ( GetFocus() == *(HWND *)v36 )
        return GetIncrementSearchString(v36 + 236, (STRSAFE_LPWSTR)lParam);
    }
    else
    {
      if ( v35 == 4417 )
        return TV_EditLabel(v36, lParam, (const WCHAR *)hdc);
      if ( v35 == 8202 )
        return TV_TranslateAccelerator((int)hWnd, (MSG *)lParam);
      if ( v35 != 8448 )
        goto LABEL_15;
      TV_CalcScrollBars(v36);
    }
    return 0;
  }
  if ( v35 == 4360 )
  {
    if ( !hdc )
      return *(_DWORD *)(v36 + 84);
    if ( hdc == (HDC)2 )
      return *(_DWORD *)(v36 + 88);
    return 0;
  }
  if ( v35 > 0x104 )
  {
    if ( v35 <= 0x207 )
    {
      if ( v35 == 519 )
      {
        SetFocus(hWnd);
        return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
      }
      if ( v35 > 0x128 )
      {
        if ( v35 == 512 )
        {
          TV_OnMouseMove(v36, lParam, (int)hdc);
        }
        else if ( v35 == 513 || v35 == 515 )
        {
          TV_ButtonDown(v36, v35, (char)hdc, (signed __int16)lParam, SHIWORD(lParam), 0);
        }
        else
        {
          if ( v35 != 516 )
            goto LABEL_15;
          TV_SendRButtonDown((HWND)v36, (signed __int16)lParam, SHIWORD(lParam));
        }
      }
      else
      {
        if ( v35 == 296 )
        {
          if ( CCOnUIState(v36, 296, (unsigned int)hdc & 0x1FFFF, lParam) )
          {
            v10 = *(_DWORD *)(v36 + 44);
            if ( v10 )
              TV_InvalidateItem(v36, v10, 1u);
          }
          return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
        }
        switch ( v35 )
        {
          case 0x10Fu:
            if ( !g_fDBCSInputEnabled || ((unsigned int)GetKeyboardLayout(0) & 0xF000FFFF) != -536869870 )
              return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
            if ( TV_OnImeComposition(v36, (int)hdc, lParam) )
            {
              lParam &= 0xFFFFF7FF;
              return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
            }
            break;
          case 0x111u:
            TV_Command(v36, (__int16)hdc, (HWND)lParam, (unsigned int)hdc >> 16);
            break;
          case 0x113u:
            TV_Timer(v36, (int)hdc);
            break;
          case 0x114u:
            TV_HorzScroll(v36, (unsigned __int16)hdc, (unsigned int)hdc >> 16);
            break;
          default:
            if ( v35 != 277 )
              goto LABEL_15;
            TV_VertScroll(v36, (unsigned __int16)hdc, (unsigned int)hdc >> 16);
            break;
        }
      }
      return 0;
    }
    if ( v35 > 0x1102 )
    {
      if ( v35 == 4356 )
      {
        v11 = lParam;
        if ( lParam && ValidateTreeItem(*(_DWORD *)lParam, 0) )
          return TV_GetItemRect(v36, *(_DWORD *)v11, v11, (int)hdc);
      }
      else
      {
        if ( v35 == 4357 )
          return *(_DWORD *)(v36 + 204);
        if ( v35 == 4358 )
          return *(_WORD *)(v36 + 188);
        if ( v35 != 4359 )
          goto LABEL_15;
        TV_SetIndent((HDC)v36, (int)hdc);
        *(_DWORD *)(v36 + 36) |= 0x100u;
      }
      return 0;
    }
    if ( v35 == 4354 )
    {
      if ( ValidateTreeItem(lParam, 0) )
        return TV_Expand(v36, (unsigned int)hdc, lParam, 0);
      return 0;
    }
    if ( v35 == 675 )
    {
      *(_DWORD *)(v36 + 36) &= 0xFFFFFDFF;
      TV_InvalidateItem(v36, *(_DWORD *)(v36 + 60), 1u);
      *(_DWORD *)(v36 + 60) = 0;
      TV_PopBubble(v36);
      return 0;
    }
    if ( v35 != 792 )
    {
      if ( v35 != 4352 )
      {
        if ( v35 == 4353 )
        {
          TV_DismissEdit(v36, 1);
          return TV_DeleteItem(v36, (LPVOID)lParam, 0);
        }
        goto LABEL_15;
      }
      if ( lParam )
        return (UINT)TV_InsertItemA(v36, lParam);
      return 0;
    }
    goto LABEL_226;
  }
  if ( v35 == 260 )
  {
    TV_KeyDown(v36, (int)hdc, lParam);
    goto LABEL_15;
  }
  if ( v35 <= 0x20 )
  {
    if ( v35 == 32 )
    {
      EventTrack.dwHoverTime = lParam;
      v7 = TV_ItemAtCursor((HWND *)v36, 0);
      if ( v7 )
      {
        v42 = v7;
        EventTrack.cbSize = *(_DWORD *)(v7 + 16);
      }
      else
      {
        v42 = 0;
        EventTrack.cbSize = 0;
      }
      if ( CCSendNotify(v36, -17, (LPARAM)&v41) )
        return 0;
      if ( !(*(_DWORD *)(v36 + 8) & 0x200) || !*(_DWORD *)(v36 + 60) )
        return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
      if ( !*(_DWORD *)(v36 + 92) )
        *(_DWORD *)(v36 + 92) = LoadHandCursor(0);
      SetCursor(*(HCURSOR *)(v36 + 92));
      return 1;
    }
    if ( v35 <= 0xB )
    {
      if ( v35 == 11 )
      {
        TV_OnSetRedraw(v36, (int)hdc);
        return 0;
      }
      if ( v35 == 2 )
      {
        CCDestroyWindow();
        TV_DestroyTree((HLOCAL)v36);
        return 0;
      }
      if ( v35 == 5 )
      {
        TV_SizeWnd(v36, (signed __int16)lParam, SHIWORD(lParam));
        return 0;
      }
      if ( v35 == 7 )
      {
        v6 = *(_DWORD *)(v36 + 44);
        *(_DWORD *)(v36 + 36) |= 4u;
        if ( v6 )
        {
          TV_InvalidateItem(v36, v6, 1u);
          MyNotifyWinEvent(32773, (int)hWnd, -4, *(_DWORD *)(v36 + 44));
        }
        else
        {
          TV_SelectItem(v36, 9, *(_DWORD *)(v36 + 208), 3, 4096);
        }
        CCSendNotify(v36, -7, 0);
        return 0;
      }
      if ( v35 == 8 )
      {
        gcWheelDelta = 0;
        v5 = *(_DWORD *)(v36 + 44);
        *(_DWORD *)(v36 + 36) &= 0xFFFFFFFB;
        if ( v5 )
        {
          TV_InvalidateItem(v36, v5, 1u);
          UpdateWindow(*(HWND *)v36);
        }
        CCSendNotify(v36, -8, 0);
        IncrementSearchString(v36 + 236, 0, 0);
        return 0;
      }
      if ( v35 != 10 )
        goto LABEL_15;
      if ( hdc )
        *(_DWORD *)(v36 + 8) &= 0xF7FFFFFF;
      else
        *(_DWORD *)(v36 + 8) |= 0x8000000u;
      goto LABEL_35;
    }
    if ( v35 != 15 )
    {
      if ( v35 == 20 )
      {
        TV_GetBackgroundBrush(v36, (WPARAM)hdc);
        GetClipBox(hdc, (LPRECT)&EventTrack);
        FillRect(hdc, (const RECT *)&EventTrack, *(HBRUSH *)(v36 + 112));
        return 1;
      }
      if ( v35 != 21 )
      {
        if ( v35 != 26 )
          goto LABEL_15;
        TV_OnWinIniChange((HDC)v36, (int)hdc);
        return 0;
      }
      InitGlobalColors();
LABEL_35:
      TV_CreateIndentBmps((HDC)v36);
      return 0;
    }
LABEL_226:
    TV_Paint(v36, hdc);
    return 0;
  }
  if ( v35 > 0x55 )
  {
    if ( v35 == 125 )
    {
      TV_OnStyleChanged((HDC)v36, (int)hdc, lParam);
      return 0;
    }
    if ( v35 == 135 )
      return 129;
    if ( v35 == 256 )
    {
      if ( TV_KeyDown(v36, (int)hdc, lParam) )
        IncrementSearchString(v36 + 236, 0, 0);
      return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
    }
    if ( v35 != 258 )
      goto LABEL_15;
    v9 = *(_DWORD *)(v36 + 96);
    if ( v9 )
    {
      *(_DWORD *)(v36 + 96) = v9 - 1;
      return 1;
    }
    TV_OnChar(v36, (unsigned __int16)hdc, (signed __int16)lParam);
    return 0;
  }
  if ( v35 == 85 )
    return CIHandleNotifyFormat(v36, lParam);
  if ( v35 == 48 )
  {
    TV_OnSetFont((HDC)v36, (UINT)hdc, lParam);
    return 0;
  }
  if ( v35 == 49 )
    return *(_DWORD *)(v36 + 116);
  if ( v35 == 61 )
  {
    if ( lParam != -12 )
      return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
    return 65561;
  }
  if ( v35 == 78 )
  {
    v8 = *(_DWORD *)(lParam + 8);
    if ( v8 <= 0xFFFFFC7C && v8 >= 0xFFFFFC4A )
      return TV_OnPagerControlNotify(v36, lParam);
    if ( *(_DWORD *)lParam == *(_DWORD *)(v36 + 224) )
    {
      if ( v8 == -530 )
      {
        TV_HandleNeedText(v36, lParam);
      }
      else
      {
        if ( v8 == -521 )
          return TV_HandleTTNShow(v36, lParam);
        if ( v8 == -520 )
        {
          TV_HandleNeedTextA(v36, lParam);
        }
        else if ( v8 == -12 )
        {
          return TV_HandleTTCustomDraw(v36, lParam);
        }
      }
    }
    return 0;
  }
LABEL_15:
  if ( v35 == g_msgMSWheel )
  {
    v24 = SHIWORD(hdc);
    gcWheelDelta -= SHIWORD(hdc);
    v44 = ((unsigned __int8)hdc & 0xC) == 0;
    v25 = gcWheelDelta / 120;
    if ( gcWheelDelta / 120 )
      gcWheelDelta %= 120;
    if ( v44 )
    {
      if ( g_ucScrollLines )
      {
        if ( v25 )
        {
          v26 = GetWindowLongW(hWnd, -16);
          if ( v26 & 0x300000 )
          {
            if ( v26 & 0x200000 )
            {
              v27 = *(_WORD *)(v36 + 196) - 1;
              if ( v27 < 1 )
                v27 = 1;
              if ( g_ucScrollLines < (unsigned int)v27 )
                v27 = g_ucScrollLines;
              v28 = *(_WORD *)(*(_DWORD *)(v36 + 208) + 28) + v25 * v27;
              if ( v28 < 0 )
                v28 = 0;
              TV_VertScroll(v36, 4, v28);
            }
            else
            {
              v29 = *(_WORD *)(v36 + 190) - 5;
              if ( v29 < 5 )
                v29 = 5;
              v30 = v29 / 5;
              if ( v30 >= (unsigned int)g_ucScrollLines )
                v30 = g_ucScrollLines;
              v31 = *(_WORD *)(v36 + 198) + 5 * v25 * v30;
              if ( v31 < 0 )
                v31 = 0;
              TV_HorzScroll(v36, 4, v31);
            }
          }
        }
      }
    }
    else
    {
      if ( !((unsigned __int8)hdc & 4)
        || (EventTrack.hwndTrack = (HWND)(signed __int16)lParam,
            EventTrack.dwHoverTime = SHIWORD(lParam),
            ScreenToClient(hWnd, (LPPOINT)&EventTrack.hwndTrack),
            !TV_CheckHit(v36, (signed int)EventTrack.hwndTrack, EventTrack.dwHoverTime, (int)&v44))
        || !(v44 & 0x56)
        || (v32 = v24 < 0, LOBYTE(v32) = v24 <= 0, v33 = (2 * v32 + 2) | 1, !(v33 & 2)) && v44 != 16 )
      {
        v35 = Msg;
        return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
      }
      TV_ButtonDown(v36, 513, 0, (signed int)EventTrack.hwndTrack, EventTrack.dwHoverTime, v33);
    }
    return 1;
  }
  if ( !CCWndProc(v36, v35, (unsigned int)hdc, lParam, (int)&Msg) )
    return DefWindowProcW(hWnd, v35, (WPARAM)hdc, lParam);
  return Msg;
}
// 6F7E6870: using guessed type int g_uDragImages;
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;
// 6F7E6930: using guessed type int g_msgMSWheel;
// 6F7E6C08: using guessed type int g_ucScrollLines;
// 6F7E8E5C: using guessed type int gcWheelDelta;

//----- (6F782FC3) --------------------------------------------------------
int __stdcall Tab_VDFlipRect(int a1, int a2)
{
  Tab_VFlipRect(a1, a2);
  return Tab_DFlipRect(a1, a2);
}

//----- (6F782FD9) --------------------------------------------------------
int __stdcall Tab_DFlipRect(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    result = FlipRect(a2);
  return result;
}

//----- (6F783808) --------------------------------------------------------
int __stdcall Tab_WndProc(HWND hWnd, HGLOBAL hMem, INT_PTR i, SIZE_T dwBytes)
{
  int v4; // eax@29
  INT_PTR v5; // eax@32
  int v6; // esi@35
  int v7; // ST24_4@41
  LPARAM v8; // ST20_4@41
  int v9; // ST1C_4@41
  int v10; // eax@41
  int v11; // edi@55
  BOOL v12; // ebx@56
  SIZE_T v13; // ebx@71
  LONG v14; // ebx@79
  int v15; // eax@85
  void *v16; // edi@85
  int v17; // eax@86
  int v18; // edi@90
  int v19; // ebx@92
  SIZE_T v20; // esi@96
  INT_PTR v21; // ST08_4@99
  int v22; // edi@118
  int v23; // ebx@122
  SIZE_T v24; // edi@122
  struct _IMAGELIST *v25; // eax@122
  HGLOBAL v26; // eax@125
  int v27; // eax@129
  SIZE_T v28; // eax@131
  LONG v29; // ST04_4@134
  PVOID v30; // eax@139
  int v31; // ecx@140
  unsigned int v32; // ecx@142
  INT_PTR v33; // ST08_4@144
  int v34; // edi@146
  LONG v35; // esi@1
  int result; // eax@16
  int v37; // eax@162
  HLOCAL v38; // eax@166
  int v39; // esi@166
  struct tagMSG Msg; // [sp+Ch] [bp-1Ch]@15

  v35 = GetWindowLongW(hWnd, 0);
  if ( v35 )
  {
    if ( (unsigned int)((char *)hMem - 512) <= 0xD )
    {
      if ( *(_BYTE *)(v35 + 8) & 0x40 )
      {
        v4 = *(_DWORD *)(v35 + 156);
        if ( !(v4 & 2) )
        {
          *(_DWORD *)(v35 + 156) = v4 | 2;
          Msg.pt.x = *(_DWORD *)v35;
          Msg.lParam = 16;
          Msg.time = 2;
          _TrackMouseEvent((LPTRACKMOUSEEVENT)&Msg.lParam);
        }
      }
    }
  }
  else if ( hMem != (HGLOBAL)1 )
  {
    return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
  }
  if ( (unsigned int)hMem > 0x318 )
  {
    switch ( hMem )
    {
      case 0x130Eu:
        return Tab_OnSetItemExtra(v35, i);
      case 0x1304u:
        return **(_DWORD **)(v35 + 40);
      case 0x1306u:
        if ( !dwBytes )
          return 0;
        v15 = (int)ThunkItemAtoW(v35, dwBytes);
        v16 = (void *)v15;
        if ( !v15 )
          return 0;
        v17 = Tab_OnSetItem(v35, i, v15);
        goto LABEL_164;
      case 0x133Du:
        if ( !dwBytes )
          return 0;
        return Tab_OnSetItem(v35, i, dwBytes);
      case 0x1305u:
        hMem = 0;
        if ( !v35 )
          return 0;
        v18 = dwBytes;
        if ( !dwBytes )
          return 0;
        if ( ULongAdd(0x1Cu, *(_DWORD *)(v35 + 48), &dwBytes) < 0 )
          return 0;
        v19 = (int)GlobalAlloc(0x40u, dwBytes);
        if ( !v19 )
          return 0;
        if ( !(*(_BYTE *)v18 & 1) )
          goto LABEL_99;
        if ( ULongLongToULong(2i64 * *(_DWORD *)(v18 + 16), &dwBytes) >= 0 && (hMem = GlobalAlloc(0x40u, dwBytes)) != 0 )
        {
          *(_DWORD *)(v19 + 12) = hMem;
LABEL_99:
          *(_DWORD *)v19 = *(_DWORD *)v18;
          v21 = i;
          *(_DWORD *)(v19 + 16) = *(_DWORD *)(v18 + 16);
          *(_DWORD *)(v19 + 8) = *(_DWORD *)(v18 + 8);
          dwBytes = Tab_OnGetItem(v35, v21, v19);
          if ( !ThunkItemWtoA(v35, v19, v18) )
            dwBytes = 0;
          if ( hMem )
            GlobalFree(hMem);
          v20 = dwBytes;
        }
        else
        {
          v20 = 0;
        }
        GlobalFree((HGLOBAL)v19);
        goto LABEL_165;
      case 0x133Cu:
        if ( !v35 || !dwBytes )
          return 0;
        return Tab_OnGetItem(v35, i, dwBytes);
      case 0x133Eu:
        if ( !dwBytes )
          return 0;
        return Tab_OnInsertItem(v35, i, dwBytes);
      case 0x1308u:
        return Tab_OnDeleteItem(v35, i);
      case 0x1309u:
        return Tab_OnDeleteAllItems(v35);
      case 0x1330u:
        Tab_SetCurFocus((HWND)v35, i);
        return 0;
      case 0x132Fu:
        result = *(_DWORD *)(v35 + 64);
        if ( result == -1 )
          return *(_DWORD *)(v35 + 60);
        return result;
      case 0x130Bu:
        return *(_DWORD *)(v35 + 60);
      case 0x130Cu:
        return ChangeSel((HWND)v35, i, 0, 0);
      case 0x132Du:
        return *(_DWORD *)(v35 + 132);
      case 0x132Eu:
        *(_DWORD *)(v35 + 132) = i;
        return 0;
      case 0x130Au:
        return Tab_OnGetItemRect(v35, i, dwBytes);
      case 0x1303u:
        v22 = *(_DWORD *)(v35 + 128);
        *(_DWORD *)(v35 + 128) = dwBytes;
        *(_DWORD *)(v35 + 76) = 0x7FFFFFFF;
        *(_DWORD *)(v35 + 68) = 0x7FFFFFFF;
        RedrawAll(v35, 5u);
        return v22;
      case 0x1302u:
        return *(_DWORD *)(v35 + 128);
      case 0x132Au:
        Tab_OnRemoveImage(v35, i);
        return 0;
      case 0x1329u:
        v23 = *(_DWORD *)(v35 + 104);
        i = *(_DWORD *)(v35 + 108);
        v24 = (unsigned __int16)dwBytes;
        hMem = (HGLOBAL)(dwBytes >> 16);
        v25 = *(struct _IMAGELIST **)(v35 + 128);
        if ( v25 )
        {
          VertImageList_GetIconSize(v25, (int *)&dwBytes, (int *)&hWnd, *(_DWORD *)(v35 + 8) & 0x80);
          if ( (signed int)v24 < (signed int)(dwBytes + 2 * g_cxEdge) )
            v24 = dwBytes + 2 * g_cxEdge;
        }
        v26 = hMem;
        *(_DWORD *)(v35 + 104) = v24;
        *(_DWORD *)(v35 + 108) = v26;
        if ( v24 != v23 || v26 != (HGLOBAL)i )
        {
          *(_DWORD *)(v35 + 68) = 0x7FFFFFFF;
          *(_DWORD *)(v35 + 76) = 0x7FFFFFFF;
          RedrawAll(v35, 0x105u);
        }
        return (unsigned __int16)v23 | ((unsigned __int16)i << 16);
      case 0x132Bu:
        v27 = SHIWORD(dwBytes);
        *(_DWORD *)(v35 + 96) = (signed __int16)dwBytes;
        *(_DWORD *)(v35 + 100) = v27;
        return 0;
      case 0x132Cu:
        CalcPaintMetrics(v35, 0);
        return *(_DWORD *)(v35 + 112) + 1;
      case 0x1331u:
        v28 = dwBytes;
        v22 = *(_DWORD *)(v35 + 72);
        if ( (dwBytes & 0x80000000) != 0 )
        {
          *(_DWORD *)(v35 + 156) &= 0xFFFFFFFE;
        }
        else
        {
          *(_DWORD *)(v35 + 156) |= 1u;
          *(_DWORD *)(v35 + 72) = v28;
        }
        v29 = *(_DWORD *)v35;
        *(_DWORD *)(v35 + 76) = 0x7FFFFFFF;
        *(_DWORD *)(v35 + 68) = 0x7FFFFFFF;
        InvalidateRect((HWND)v29, 0, 1);
        return v22;
      case 0x1332u:
        Tab_DeselectAll(v35, i);
        return 0;
      case 0x1334u:
        return Tab_ExtendedStyleChange(v35, dwBytes, i);
      case 0x1335u:
        return *(_DWORD *)(v35 + 52);
      case 0x130Du:
        return Tab_OnHitTest(v35, *(_DWORD *)dwBytes, *(_DWORD *)(dwBytes + 4), dwBytes + 8);
      case 0x1333u:
        v30 = DPA_GetPtr(*(HDPA *)(v35 + 40), i);
        if ( !v30 )
          return 0;
        v31 = *((_DWORD *)v30 + 12);
        if ( ((_WORD)dwBytes != 0) == ((*((_DWORD *)v30 + 12) >> 1) & 1) )
          return 0;
        if ( (_WORD)dwBytes != 0 )
          v32 = v31 | 2;
        else
          v32 = v31 & 0xFFFFFFFD;
        v33 = i;
        *((_DWORD *)v30 + 12) = v32;
        Tab_InvalidateItem(v35, v33, 1);
        return 1;
      case 0x1328u:
        v34 = dwBytes;
        if ( !dwBytes )
          return -1;
        Tab_DVFlipRect(v35, dwBytes);
        Tab_OnAdjustRect(v35, i, (LPRECT)v34);
        Tab_VDFlipRect(v35, v34);
        return 0;
      default:
        goto LABEL_15;
      case 0x1307u:
        if ( !dwBytes )
          return 0;
        v37 = (int)ThunkItemAtoW(v35, dwBytes);
        v16 = (void *)v37;
        if ( !v37 )
          return 0;
        v17 = Tab_OnInsertItem(v35, i, v37);
LABEL_164:
        v20 = v17;
        FreeItemW(v16);
LABEL_165:
        result = v20;
        break;
    }
    return result;
  }
  if ( hMem == (HGLOBAL)792 )
  {
LABEL_26:
    Tab_Paint(v35, i);
    return 0;
  }
  if ( (unsigned int)hMem > 0x84 )
  {
    if ( (unsigned int)hMem > 0x202 )
    {
      if ( hMem == (HGLOBAL)515 )
      {
        if ( *(_DWORD *)(v35 + 8) & 0x100 )
        {
          SetCapture(*(HWND *)v35);
          do
            v14 = *(_DWORD *)v35;
          while ( GetCapture() == (HWND)v14 && !PeekMessageW(&Msg, (HWND)v14, 0x202u, 0x202u, 1u) );
          CCReleaseCapture(v35);
        }
        return 0;
      }
      if ( hMem == (HGLOBAL)516 )
      {
        Tab_OnRButtonDown(v35, (signed __int16)dwBytes, SHIWORD(dwBytes), i);
        return 0;
      }
      if ( hMem == (HGLOBAL)517 )
      {
        if ( !SendNotifyEx(0, *(HWND *)v35, -5, 0, *(_DWORD *)(v35 + 16) & 1) )
          return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
        return 0;
      }
      if ( hMem == (HGLOBAL)519 )
      {
        SetFocus(hWnd);
        return 0;
      }
      if ( hMem != (HGLOBAL)533 )
      {
        if ( (char *)hMem - 533 == (_BYTE *)142 )
        {
          Tab_InvalidateItem(v35, *(_DWORD *)(v35 + 160), 0);
          *(_DWORD *)(v35 + 160) = -1;
          *(_DWORD *)(v35 + 156) &= 0xFFFFFFFD;
          return 0;
        }
        goto LABEL_15;
      }
      v13 = -1;
    }
    else
    {
      if ( hMem != (HGLOBAL)514 )
      {
        if ( hMem == (HGLOBAL)135 )
          return 129;
        if ( hMem == (HGLOBAL)256 )
        {
          Tab_OnKeyDown((HWND)v35, i, 1, (signed __int16)dwBytes, dwBytes >> 16);
          return 0;
        }
        if ( hMem == (HGLOBAL)260 )
        {
          if ( (dwBytes >> 16) & 0x2000 )
            CCNotifyNavigationKeyUsage(v35, 3u);
          return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
        }
        if ( hMem == (HGLOBAL)276 )
        {
          Tab_OnHScroll(v35, dwBytes, (unsigned __int16)i, SHIWORD(i));
          return 0;
        }
        if ( hMem == (HGLOBAL)296 )
        {
          if ( CCOnUIState(v35, 296, i, dwBytes) )
          {
            if ( 1 == HIWORD(i) )
            {
              Tab_InvalidateItem(v35, *(_DWORD *)(v35 + 60), 2 == (_WORD)i);
            }
            else if ( ((unsigned int)i >> 16) & 3 )
            {
              v11 = *(_DWORD *)(v35 + 88);
              if ( v11 <= *(_DWORD *)(v35 + 92) )
              {
                v12 = 2 == (_WORD)i;
                do
                  Tab_InvalidateItem(v35, v11++, v12);
                while ( v11 <= *(_DWORD *)(v35 + 92) );
              }
            }
          }
          return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
        }
        if ( hMem == (HGLOBAL)512 )
        {
          RelayToToolTips(*(HWND *)(v35 + 132), (int)hWnd, 512, i, dwBytes);
          Tab_OnMouseMove(v35, i, (signed __int16)dwBytes, SHIWORD(dwBytes));
          return 0;
        }
        if ( (char *)hMem - 512 == (_BYTE *)1 )
        {
          RelayToToolTips(*(HWND *)(v35 + 132), (int)hWnd, 513, i, dwBytes);
          Tab_OnLButtonDown(v35, (signed __int16)dwBytes, SHIWORD(dwBytes), i);
          return 0;
        }
        goto LABEL_15;
      }
      v13 = dwBytes;
      RelayToToolTips(*(HWND *)(v35 + 132), (int)hWnd, 514, i, dwBytes);
    }
    Tab_OnButtonUp((HWND)v35, (signed __int16)v13, SHIWORD(v13), hMem == (HGLOBAL)514);
    return 0;
  }
  if ( hMem == (HGLOBAL)132 )
  {
    Msg.pt.x = (signed __int16)dwBytes;
    Msg.pt.y = SHIWORD(dwBytes);
    ScreenToClient(*(HWND *)v35, &Msg.pt);
    if ( Tab_OnHitTest(v35, Msg.pt.x, Msg.pt.y, 0) != -1 )
      return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
    return -1;
  }
  if ( (unsigned int)hMem > 0x15 )
  {
    if ( hMem != (HGLOBAL)26 )
    {
      if ( hMem == (HGLOBAL)48 )
      {
        Tab_OnSetFont(v35, (HANDLE)i, dwBytes);
      }
      else
      {
        if ( hMem == (HGLOBAL)49 )
          return *(_DWORD *)(v35 + 56);
        if ( hMem == (HGLOBAL)61 )
        {
          if ( dwBytes == -12 )
            return 65551;
        }
        else if ( hMem == (HGLOBAL)78 )
        {
          v7 = *(_DWORD *)(v35 + 16) & 1;
          v8 = dwBytes;
          v9 = *(_DWORD *)(dwBytes + 8);
          v10 = (int)GetParent(*(HWND *)v35);
          SendNotifyEx(v10, HWND_MESSAGE|0x2, v9, v8, v7);
        }
        else
        {
          if ( hMem == (HGLOBAL)85 )
            return CIHandleNotifyFormat(v35, dwBytes);
          if ( (char *)hMem - 85 != (_BYTE *)40 )
            goto LABEL_15;
          Tab_StyleChanged(v35, i, dwBytes);
        }
      }
      return 0;
    }
    InitGlobalMetrics(i);
    if ( i != 42 && (i || dwBytes) )
      return 0;
LABEL_40:
    RedrawAll(v35, 5u);
    return 0;
  }
  if ( hMem == (HGLOBAL)21 )
  {
    InitGlobalColors();
    if ( !(*(_BYTE *)(v35 + 44) & 0x40) )
      Tab_OnSetFont(v35, 0, 0);
    goto LABEL_40;
  }
  if ( hMem == (HGLOBAL)1 )
  {
    CCCreateWindow();
    InitGlobalColors();
    v38 = LocalAlloc(0x40u, 0xA4u);
    v39 = (int)v38;
    if ( v38 )
    {
      SetWindowLongW(hWnd, 0, (LONG)v38);
      CIInitialize(v39, (WPARAM)hWnd, dwBytes);
      if ( Tab_OnCreate(v39) )
        return 0;
    }
    return -1;
  }
  if ( hMem == (HGLOBAL)2 )
  {
    CCDestroyWindow();
    Tab_OnDestroy((HLOCAL)v35);
    return 0;
  }
  if ( hMem == (HGLOBAL)5 )
  {
    Tab_Size(v35);
    return 0;
  }
  if ( hMem == (HGLOBAL)7 )
  {
LABEL_34:
    Tab_InvalidateItem(v35, *(_DWORD *)(v35 + 60), *(_DWORD *)(v35 + 8) & 0x2000);
    if ( hMem == (HGLOBAL)7 )
    {
      v6 = *(_DWORD *)(v35 + 60);
      if ( v6 != -1 )
        MyNotifyWinEvent(32773, (int)hWnd, -4, v6 + 1);
    }
    return 0;
  }
  if ( hMem == (HGLOBAL)8 )
  {
    v5 = *(_DWORD *)(v35 + 64);
    if ( v5 != -1 )
    {
      *(_DWORD *)(v35 + 64) = -1;
      Tab_InvalidateItem(v35, v5, 0);
      *(_DWORD *)(v35 + 44) &= 0xFFFFFFFB;
    }
    goto LABEL_34;
  }
  if ( hMem == (HGLOBAL)11 )
  {
    Tab_OnSetRedraw(v35, i);
    return 0;
  }
  if ( (char *)hMem - 11 == (_BYTE *)4 )
    goto LABEL_26;
LABEL_15:
  if ( !CCWndProc(v35, (int)hMem, i, dwBytes, (int)&Msg.pt.y) )
    return DefWindowProcW(hWnd, (UINT)hMem, i, dwBytes);
  return Msg.pt.y;
}

//----- (6F783934) --------------------------------------------------------
int __stdcall Tab_Size(INT_PTR i)
{
  *(_DWORD *)(i + 68) = 0x7FFFFFFF;
  return Tab_UpdateArrows(i, 1);
}

//----- (6F783954) --------------------------------------------------------
int __stdcall Tab_UpdateArrows(INT_PTR i, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  bool v4; // zf@3
  int v5; // ebx@8
  LONG v6; // ecx@8
  bool v7; // sf@8
  unsigned __int8 v8; // of@8
  PVOID v9; // eax@9
  int v10; // ecx@10
  int v11; // eax@10
  int v12; // ecx@12
  RECT rc; // [sp+4h] [bp-14h]@1
  int v14; // [sp+14h] [bp-4h]@8
  int ia; // [sp+20h] [bp+8h]@8

  v2 = i;
  Tab_GetClientRect(i, &rc);
  result = IsRectEmpty(&rc);
  if ( result )
    return result;
  v4 = (*(_DWORD *)(i + 8) & 0x200) == 0;
  *(_DWORD *)(i + 80) = rc.right;
  if ( !v4 )
    goto LABEL_5;
  CalcPaintMetrics(i, 0);
  result = rc.right;
  if ( *(_DWORD *)(i + 68) < rc.right )
    goto LABEL_5;
  v5 = *(_DWORD *)(i + 84);
  v6 = rc.right - 2 * v5;
  v8 = __OFSUB__(v6, *(_DWORD *)(i + 68));
  v7 = v6 - *(_DWORD *)(i + 68) < 0;
  *(_DWORD *)(i + 80) = v6;
  v14 = 0;
  ia = 0;
  if ( v7 ^ v8 )
  {
    do
    {
      v9 = DPA_GetPtr(*(HDPA *)(v2 + 40), ia);
      if ( !v9 )
        break;
      v10 = *((_DWORD *)v9 + 2) - *(_DWORD *)v9;
      v11 = *(_DWORD *)(v2 + 80);
      v14 += v10;
      ++ia;
    }
    while ( v14 + v11 < *(_DWORD *)(v2 + 68) );
    result = rc.right;
  }
  v12 = **(_DWORD **)(v2 + 40);
  if ( ia >= v12 )
    ia = v12 - 1;
  if ( ia <= 0 )
  {
    *(_DWORD *)(v2 + 80) = result;
LABEL_5:
    result = *(_DWORD *)(v2 + 36);
    if ( result )
    {
      ShowWindow((HWND)result, 0);
      result = InvalidateRect(*(HWND *)v2, 0, 1);
    }
    if ( *(_DWORD *)(v2 + 88) > 0 )
    {
      Tab_OnHScroll(v2, 0, 4, 0);
      result = InvalidateRect(*(HWND *)v2, 0, 1);
    }
    return result;
  }
  if ( *(_DWORD *)(v2 + 36)
    || (InvalidateRect(*(HWND *)v2, 0, 1),
        *(_DWORD *)(v2 + 36) = CreateUpDownControl(
                                 (char)(*(_DWORD *)(v2 + 8) & 0x80) != 0 ? 1073741825 : 1073741888,
                                 0,
                                 0,
                                 0,
                                 0,
                                 *(HWND *)v2,
                                 1,
                                 g_hinst,
                                 0,
                                 ia,
                                 0,
                                 *(_DWORD *)(v2 + 88)),
        result = rc.right,
        *(_DWORD *)(v2 + 36)) )
  {
    rc.left = result - 2 * v5;
    rc.bottom = *(_DWORD *)(v2 + 76);
    rc.top = rc.bottom - v5;
    Tab_VDFlipRect(v2, (int)&rc);
    if ( a2 || !IsWindowVisible(*(HWND *)(v2 + 36)) )
      SetWindowPos(*(HWND *)(v2 + 36), 0, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 0x54u);
    result = SendMessageW(*(HWND *)(v2 + 36), 0x465u, 0, (unsigned __int16)ia);
  }
  return result;
}

//----- (6F783986) --------------------------------------------------------
int __stdcall Tab_GetClientRect(int a1, LPRECT lpRect)
{
  GetClientRect(*(HWND *)a1, lpRect);
  return Tab_DFlipRect(a1, (int)lpRect);
}

//----- (6F7839AD) --------------------------------------------------------
int __stdcall Tab_DVFlipRect(int a1, int a2)
{
  Tab_DFlipRect(a1, a2);
  return Tab_VFlipRect(a1, a2);
}

//----- (6F7839C3) --------------------------------------------------------
int __stdcall Tab_VFlipRect(int a1, int a2)
{
  int result; // eax@1
  struct tagRECT Rect; // [sp+0h] [bp-10h]@3

  result = a1;
  if ( *(_BYTE *)(a1 + 8) & 2 )
  {
    Tab_GetClientRect(a1, &Rect);
    result = VFlipRect((int)&Rect, a2);
  }
  return result;
}

//----- (6F783A12) --------------------------------------------------------
int __stdcall CalcPaintMetrics(int a1, HDC hDC)
{
  int v2; // esi@1
  int result; // eax@1
  bool v4; // zf@1
  int v5; // ebx@8
  int v6; // eax@9
  int v7; // edi@9
  const WCHAR *v8; // eax@9
  struct _IMAGELIST *v9; // eax@11
  LONG v10; // edx@12
  int v11; // ecx@13
  LONG v12; // edx@14
  LONG v13; // eax@14
  int v14; // eax@17
  LONG v15; // eax@18
  int v16; // eax@21
  int v17; // eax@24
  signed int v18; // eax@26
  int v19; // eax@27
  PVOID v20; // eax@29
  int v21; // edi@30
  int i; // ebx@30
  int v23; // eax@46
  int v24; // ecx@55
  __int64 v25; // rax@55
  int v26; // eax@66
  int v27; // ecx@67
  struct tagSIZE sz; // [sp+8h] [bp-28h]@10
  int cy; // [sp+10h] [bp-20h]@41
  LONG v30; // [sp+14h] [bp-1Ch]@13
  int v31; // [sp+18h] [bp-18h]@1
  int v32; // [sp+1Ch] [bp-14h]@7
  int v33; // [sp+20h] [bp-10h]@8
  int v34; // [sp+24h] [bp-Ch]@1
  int v35; // [sp+28h] [bp-8h]@1
  int v36; // [sp+2Ch] [bp-4h]@9
  int v37; // [sp+38h] [bp+8h]@7

  v2 = a1;
  result = **(_DWORD **)(a1 + 40);
  v4 = *(_DWORD *)(a1 + 68) == 0x7FFFFFFF;
  v35 = 0;
  v34 = result;
  v31 = 0;
  if ( !v4 )
    return result;
  if ( !*(_DWORD *)(a1 + 56) )
    Tab_OnSetFont(a1, 0, 0);
  if ( !hDC )
  {
    v31 = 1;
    hDC = GetDC(0);
    SelectObject(hDC, *(HGDIOBJ *)(a1 + 56));
  }
  CalcTabHeight(a1, hDC);
  if ( *(_DWORD *)(a1 + 8) & 0x100 )
  {
    v32 = 0;
    v37 = 0;
  }
  else
  {
    v32 = g_cxEdge;
    v37 = g_cyEdge;
  }
  v5 = v32;
  v33 = 0;
  if ( v34 > 0 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v2 + 40);
      v36 = 0;
      v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * v33);
      v8 = *(const WCHAR **)(v7 + 44);
      if ( v8 )
      {
        Tab_GetTextExtentPoint(v2, (int)hDC, v8, &sz);
      }
      else
      {
        sz.cx = 0;
        sz.cy = 0;
      }
      *(_DWORD *)(v7 + 28) = sz.cx;
      v9 = *(struct _IMAGELIST **)(v2 + 128);
      if ( v9 && *(_DWORD *)(v7 + 16) != -1 )
      {
        VertImageList_GetIconSize(v9, &v36, &cy, *(_DWORD *)(v2 + 8) & 0x80);
        v36 += *(_DWORD *)(v2 + 96);
        v10 = v36 + sz.cx;
      }
      else
      {
        v10 = sz.cx;
      }
      v11 = *(_DWORD *)(v2 + 8);
      v30 = v10;
      if ( v11 & 0x400 )
        break;
      v12 = v10 + 2 * *(_DWORD *)(v2 + 96);
      v13 = *(_DWORD *)(v2 + 72);
      sz.cx = v12;
      if ( v12 < v13 )
      {
        v12 = v13;
        goto LABEL_44;
      }
LABEL_15:
      if ( *(_BYTE *)(v7 + 48) & 4 )
      {
        v12 = 0;
        sz.cx = 0;
        sz.cy = 0;
      }
      if ( v11 & 0x200 )
      {
        v23 = *(_DWORD *)(v2 + 80) - g_cxEdge;
        if ( v5 > v23 || v12 + v5 >= v23 && v12 < v23 )
        {
          v37 += *(_DWORD *)(v2 + 76);
          ++v35;
          v5 = v32;
          if ( *(_DWORD *)(v2 + 8) & 0x100 )
            v37 += 3 * g_cyEdge / 2;
        }
        *(_DWORD *)(v7 + 40) = v35;
      }
      *(_DWORD *)v7 = v5;
      *(_DWORD *)(v7 + 8) = v5 + sz.cx;
      *(_DWORD *)(v7 + 4) = v37;
      *(_DWORD *)(v7 + 12) = v37 + *(_DWORD *)(v2 + 76);
      v14 = *(_DWORD *)(v2 + 8);
      if ( !(v14 & 0x400) || v14 & 0x30 )
        v15 = *(_DWORD *)(v2 + 96);
      else
        v15 = (sz.cx - v30) / 2;
      *(_DWORD *)(v7 + 32) = v15;
      if ( *(_DWORD *)(v7 + 32) < g_cxEdge )
        *(_DWORD *)(v7 + 32) = g_cxEdge;
      if ( *(_BYTE *)(v2 + 8) & 0x10 )
      {
        v24 = v36 + *(_DWORD *)(v7 + 32);
        v25 = sz.cx - *(_DWORD *)(v7 + 28) - v24;
        v16 = v24 + (((signed int)v25 - HIDWORD(v25)) >> 1);
      }
      else
      {
        v16 = v36 + *(_DWORD *)(v7 + 32);
      }
      *(_DWORD *)(v7 + 20) = v16;
      v5 = *(_DWORD *)(v7 + 8);
      *(_DWORD *)(v7 + 36) = *(_DWORD *)(v2 + 100) + *(_DWORD *)(v2 + 124) - g_cyEdge / 2;
      *(_DWORD *)(v7 + 24) = *(_DWORD *)(v2 + 120) + *(_DWORD *)(v2 + 100) - g_cyEdge / 2;
      if ( *(_DWORD *)(v2 + 8) & 0x100 )
        v5 += Tab_InterButtonGap(v2);
      ++v33;
      if ( v33 >= v34 )
        goto LABEL_24;
    }
    v12 = *(_DWORD *)(v2 + 104);
LABEL_44:
    sz.cx = v12;
    goto LABEL_15;
  }
LABEL_24:
  v17 = *(_DWORD *)(v2 + 112);
  *(_DWORD *)(v2 + 68) = v5;
  if ( v17 != -1 && v17 != v35 && !(*(_DWORD *)(v2 + 8) & 0x100) )
    InvalidateRect(*(HWND *)v2, 0, 1);
  v18 = v35;
  if ( v34 <= 0 )
    v18 = -1;
  *(_DWORD *)(v2 + 112) = v18;
  v19 = *(_DWORD *)(v2 + 8);
  if ( v19 & 0x200 )
  {
    if ( !(v19 & 0xC00) )
      RightJustify(v2);
    if ( *(_BYTE *)(v2 + 8) & 1 )
    {
      Tab_InvertRows(v2);
      if ( *(_DWORD *)(v2 + 60) == -1 )
        *(_DWORD *)(v2 + 116) = *(_DWORD *)(v2 + 112);
    }
    if ( !(*(_DWORD *)(v2 + 8) & 0x100) )
    {
      v26 = *(_DWORD *)(v2 + 60);
      if ( v26 != -1 )
      {
        v27 = *(_DWORD *)(v2 + 40);
        *(_DWORD *)(v2 + 116) = -1;
        PutzRowToBottom(v2, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v27 + 4) + 4 * v26) + 40));
      }
    }
  }
  else if ( v34 > 0 )
  {
    v20 = DPA_GetPtr(*(HDPA *)(v2 + 40), *(_DWORD *)(v2 + 88));
    if ( v20 )
    {
      v21 = g_cxEdge - *(_DWORD *)v20;
      for ( i = v34; ; OffsetRect(*(LPRECT *)(*(_DWORD *)(*(_DWORD *)(v2 + 40) + 4) + 4 * i), v21, 0) )
      {
        --i;
        if ( i < 0 )
          break;
      }
    }
  }
  if ( v31 )
    ReleaseDC(0, hDC);
  return UpdateToolTipRects(v2);
}

//----- (6F783C25) --------------------------------------------------------
signed int __stdcall TV_SizeWnd(int a1, LONG a2, unsigned int a3)
{
  LONG v3; // edi@1
  unsigned int v4; // ebx@2
  unsigned int v5; // ecx@3
  bool v6; // zf@3
  __int16 v7; // ax@4
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@6

  v3 = *(_WORD *)(a1 + 190);
  if ( !a2 || (v4 = a3) == 0 )
  {
    GetClientRect(*(HWND *)a1, &Rect);
    v4 = Rect.bottom;
    a2 = Rect.right;
  }
  v5 = *(_WORD *)(a1 + 182);
  *(_WORD *)(a1 + 190) = a2;
  v6 = (*(_DWORD *)(a1 + 8) & 0x2000) == 0;
  *(_WORD *)(a1 + 192) = v4;
  *(_WORD *)(a1 + 196) = v4 / v5;
  if ( !v6 )
    *(_WORD *)(a1 + 194) = a2;
  TV_CalcScrollBars(a1);
  v7 = *(_WORD *)(a1 + 184);
  if ( v7 )
  {
    Rect.top = 0;
    Rect.right = v3;
    Rect.bottom = v4;
    Rect.left = v3 - v7;
    if ( Rect.left < a2 )
      InvalidateRect(*(HWND *)a1, &Rect, 1);
  }
  TV_InvalidateInsertMarkRect(a1, 1);
  return 1;
}

//----- (6F783CAF) --------------------------------------------------------
int __stdcall TV_InvalidateInsertMarkRect(int a1, BOOL bErase)
{
  int result; // eax@1
  RECT Rect; // [sp+4h] [bp-10h]@1

  result = TV_GetInsertMarkRect(a1, (int)&Rect);
  if ( result )
    result = InvalidateRect(*(HWND *)a1, &Rect, bErase);
  return result;
}

//----- (6F783CD7) --------------------------------------------------------
signed int __stdcall TV_GetInsertMarkRect(int a1, int a2)
{
  int v2; // eax@1
  signed int result; // eax@2

  v2 = *(_DWORD *)(a1 + 68);
  if ( v2 && TV_GetItemRect(a1, v2, a2, 1) )
  {
    if ( *(_DWORD *)(a1 + 36) & 0x1000 )
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a2 + 12);
    else
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) -= 3;
    *(_DWORD *)(a2 + 12) += 4;
    *(_DWORD *)(a2 + 8) = *(_WORD *)(a1 + 190) - 6;
    *(_DWORD *)a2 -= *(_WORD *)(a1 + 176);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F783CF9) --------------------------------------------------------
int __stdcall Tab_GetTextExtentPoint(int a1, int a2, LPCWSTR lpString, LPSIZE lpsz)
{
  void *v4; // esi@1
  unsigned int v5; // eax@1
  int result; // eax@4
  WCHAR String; // [sp+10h] [bp-104h]@3

  v4 = (void *)lpString;
  v5 = lstrlenW(lpString);
  if ( v5 < 0x80 && !(*(_BYTE *)(a1 + 8) & 0x80) )
  {
    StripAccelerators((int)lpString, (int)&String, 1);
    v4 = &String;
    v5 = lstrlenW(&String);
  }
  result = GetTextExtentPointW((HDC)a2, (LPCWSTR)v4, v5, lpsz);
  if ( !result )
  {
    lpsz->cx = 0;
    lpsz->cy = 0;
  }
  return result;
}

//----- (6F783D80) --------------------------------------------------------
int __stdcall StripAccelerators(int a1, int a2, int a3)
{
  int result; // eax@1
  __int16 v4; // cx@1
  int v5; // edi@1
  __int16 v6; // cx@3
  __int16 v7; // cx@6
  int v8; // ecx@14
  signed int v9; // esi@14

  result = a1;
  v4 = *(_WORD *)a1;
  v5 = a2;
  *(_WORD *)a2 = *(_WORD *)a1;
  if ( v4 )
  {
    while ( a3 || !g_fDBCSInputEnabled || *(_WORD *)result != 40 || *(_WORD *)(result + 2) != 38 )
    {
LABEL_3:
      v6 = *(_WORD *)result;
      if ( *(_WORD *)result == 9 )
        goto LABEL_10;
      result += 2;
      if ( v6 != 38 || *(_WORD *)result == 38 )
        v5 += 2;
LABEL_6:
      v7 = *(_WORD *)result;
      *(_WORD *)v5 = *(_WORD *)result;
      if ( !v7 )
        return result;
    }
    v8 = result + 4;
    v9 = 0;
    while ( *(_WORD *)v8 )
    {
      ++v9;
      v8 += 2;
      if ( v9 >= 2 )
      {
        if ( !*(_WORD *)v8 )
          break;
        if ( v9 == 2 && *(_WORD *)v8 == 41 )
        {
          v5 -= 2;
          result = v8 + 2;
          goto LABEL_6;
        }
        goto LABEL_3;
      }
    }
LABEL_10:
    result = 0;
    *(_WORD *)v5 = 0;
  }
  return result;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F783E19) --------------------------------------------------------
signed int __stdcall TV_ScrollBarsAfterSetWidth(int a1, int a2)
{
  int v2; // edi@2

  if ( a2 )
  {
    v2 = *(_WORD *)(a2 + 26) + ITEM_OFFSET(a1, a2);
    TV_ComputeItemWidth(a1, a2, 0);
    if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
    {
      if ( *(_WORD *)(a1 + 194) != v2 )
        return 0;
      *(_WORD *)(a1 + 194) = TV_RecomputeMaxWidth(a1);
    }
  }
  else
  {
    TV_RecomputeItemWidths(a1);
    *(_WORD *)(a1 + 194) = TV_RecomputeMaxWidth(a1);
  }
  TV_CalcScrollBars(a1);
  return 1;
}

//----- (6F783E89) --------------------------------------------------------
int __stdcall TV_RecomputeMaxWidth(int a1)
{
  int v1; // esi@2
  unsigned __int16 v2; // bx@2
  int result; // eax@4

  if ( *(_DWORD *)(a1 + 8) & 0x2000 )
  {
    result = *(_WORD *)(a1 + 190);
  }
  else
  {
    v1 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8);
    v2 = 0;
    while ( v1 )
    {
      if ( v2 < *(_WORD *)(v1 + 26) + ITEM_OFFSET(a1, v1) )
        v2 = *(_WORD *)(v1 + 26) + ITEM_OFFSET(a1, v1);
      v1 = TV_GetNextVisItem(v1);
    }
    result = v2;
  }
  return result;
}

//----- (6F783EC5) --------------------------------------------------------
unsigned int __stdcall TreeView_BeginFakeCustomDraw(int a1, LPARAM lParam)
{
  HDC v2; // eax@1
  unsigned int result; // eax@1

  v2 = GetDC(*(HWND *)a1);
  *(_DWORD *)(lParam + 16) = v2;
  *(_DWORD *)(lParam + 40) = 0;
  *(_DWORD *)(lParam + 36) = 0;
  *(_DWORD *)(lParam + 44) = 0;
  *(_DWORD *)(lParam + 64) = GetCurrentObject(v2, 6u);
  SetRectEmpty((LPRECT)(lParam + 20));
  *(_DWORD *)(lParam + 60) = a1;
  *(_DWORD *)(lParam + 68) = *(_DWORD *)(a1 + 12);
  result = CIFakeCustomDrawNotify(a1, 1, lParam);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (6F783F1E) --------------------------------------------------------
unsigned int __stdcall CIFakeCustomDrawNotify(int a1, int a2, LPARAM lParam)
{
  unsigned int result; // eax@1
  int v4; // ecx@3

  result = 0;
  if ( *(_DWORD *)(a1 + 28) >= 5 )
  {
    v4 = *(_DWORD *)(a1 + 16);
    if ( !(v4 & 2) )
    {
      *(_DWORD *)(a1 + 16) = v4 | 2;
      result = CICustomDrawNotify(a1, a2, lParam);
      *(_DWORD *)(a1 + 16) &= 0xFFFFFFFD;
    }
  }
  return result;
}

//----- (6F783F3D) --------------------------------------------------------
int __stdcall TV_RecomputeItemWidths(int a1)
{
  int i; // esi@1
  LPARAM lParam; // [sp+8h] [bp-4Ch]@1
  HDC v4; // [sp+18h] [bp-3Ch]@4

  TreeView_BeginFakeCustomDraw(a1, (LPARAM)&lParam);
  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8); i; i = TV_GetNext(i) )
  {
    TreeView_BeginFakeItemDraw((LPARAM)&lParam, i);
    TV_ComputeItemWidth(a1, i, v4);
    TreeView_EndFakeItemDraw((LPARAM)&lParam);
  }
  return TreeView_EndFakeCustomDraw((LPARAM)&lParam);
}

//----- (6F783F76) --------------------------------------------------------
int __stdcall TreeView_EndFakeCustomDraw(LPARAM lParam)
{
  int v1; // edi@1
  int v2; // eax@1

  v1 = *(_DWORD *)(lParam + 60);
  v2 = *(_DWORD *)(v1 + 12);
  if ( !(v2 & 4) && v2 & 0x10 )
    CIFakeCustomDrawNotify(v1, 2, lParam);
  *(_DWORD *)(v1 + 12) = *(_DWORD *)(lParam + 68);
  SelectObject(*(HDC *)(lParam + 16), *(HGDIOBJ *)(lParam + 64));
  return ReleaseDC(*(HWND *)v1, *(HDC *)(lParam + 16));
}

//----- (6F784068) --------------------------------------------------------
__int32 __stdcall CImageList::GetBkColor(CImageList *this, unsigned __int32 *a2)
{
  *a2 = *((_DWORD *)this + 15);
  return 0;
}

//----- (6F784083) --------------------------------------------------------
int __stdcall TV_GetNextItem(int a1, int a2, int a3)
{
  int result; // eax@12

  if ( !a3 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8);
  if ( a3 == 4 )
  {
    if ( a2 && a2 != -65536 )
      goto LABEL_7;
    return *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8);
  }
  if ( a3 == 5 )
    return *(_DWORD *)(a1 + 208);
  if ( a3 == 8 )
    return *(_DWORD *)(a1 + 48);
  if ( a3 == 9 )
    return *(_DWORD *)(a1 + 44);
  if ( a3 == 10 )
    return TV_GetShownIndexItem(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 8), *(_DWORD *)(a1 + 200) - 1);
LABEL_7:
  if ( !ValidateTreeItem(a2, 0) )
    return 0;
  if ( a3 == 1 )
    return *(_DWORD *)(a2 + 4);
  if ( a3 == 2 )
  {
    result = *(_DWORD *)(*(_DWORD *)a2 + 8);
    if ( result == a2 )
      return 0;
    while ( *(_DWORD *)(result + 4) != a2 )
      result = *(_DWORD *)(result + 4);
  }
  else
  {
    if ( a3 == 3 )
    {
      if ( *(_BYTE *)(a2 + 30) )
        return *(_DWORD *)a2;
      return 0;
    }
    if ( a3 == 4 )
      return *(_DWORD *)(a2 + 8);
    if ( a3 != 6 )
    {
      if ( a3 == 7 )
        return TV_GetPrevVisItem(a2);
      return 0;
    }
    result = TV_GetNextVisItem(a2);
  }
  return result;
}

//----- (6F7840FD) --------------------------------------------------------
signed int __stdcall ValidateTreeItem(int a1, int a2)
{
  int v2; // et1@3
  signed int v4; // [sp+10h] [bp-1Ch]@1

  v4 = 1;
  if ( !a1 )
  {
    if ( a2 )
      return v4;
    return 0;
  }
  if ( HIWORD(a1) == -1 )
  {
    if ( (signed int)(unsigned __int16)a1 <= 3 )
      return v4;
    return 0;
  }
  v2 = *(_DWORD *)a1;
  return *(_WORD *)(a1 + 34) == -21555;
}

//----- (6F784191) --------------------------------------------------------
void *__stdcall TV_OnGetItemA(int a1, int a2)
{
  CHAR *v2; // ebx@1
  int v3; // esi@1
  signed int v4; // eax@4
  void *result; // eax@5
  int v6; // eax@7
  int v7; // eax@12
  HLOCAL hMem; // [sp+8h] [bp-4h]@1
  signed int v9; // [sp+18h] [bp+Ch]@4

  v2 = 0;
  hMem = 0;
  v3 = a2;
  if ( a2 )
  {
    if ( a2 != -1 )
    {
      if ( *(_BYTE *)a2 & 1 )
      {
        v6 = *(_DWORD *)(a2 + 16);
        if ( v6 )
        {
          if ( v6 != -1 )
          {
            v2 = *(CHAR **)(a2 + 16);
            result = (void *)CCLocalAllocArray_WCHAR(*(_DWORD *)(a2 + 20));
            hMem = result;
            if ( !result )
              return result;
            *(_DWORD *)(a2 + 16) = result;
          }
        }
      }
    }
  }
  v4 = TV_OnGetItem(a1, a2);
  v9 = v4;
  if ( v2 )
  {
    if ( v4 )
    {
      v7 = *(_DWORD *)(v3 + 20);
      if ( v7 )
        WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, *(LPCWSTR *)(v3 + 16), -1, v2, v7, 0, 0);
    }
    LocalFree(hMem);
    *(_DWORD *)(v3 + 16) = v2;
  }
  return (void *)v9;
}
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F7841DA) --------------------------------------------------------
signed int __stdcall TV_OnGetItem(int a1, int a2)
{
  signed int result; // eax@3

  if ( a2 && ValidateTreeItem(*(_DWORD *)(a2 + 4), 0) )
  {
    TV_GetItem(a1, *(_DWORD *)(a2 + 4), *(_DWORD *)a2, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F784214) --------------------------------------------------------
void __stdcall TV_GetItem(int a1, int a2, char a3, int a4)
{
  const WCHAR *v4; // ecx@4
  size_t v5; // eax@5
  bool v6; // zf@12
  char v7; // al@16
  unsigned __int16 v8; // ax@25
  unsigned __int16 v9; // ax@28
  STRSAFE_LPCWSTR v10; // eax@41
  int v11; // eax@44
  char v12; // al@50
  LPARAM lParam; // [sp+4h] [bp-34h]@16
  int v14; // [sp+10h] [bp-28h]@3
  int v15; // [sp+14h] [bp-24h]@16
  int v16; // [sp+18h] [bp-20h]@12
  int v17; // [sp+1Ch] [bp-1Ch]@44
  LPCWSTR lpString; // [sp+20h] [bp-18h]@31
  int v19; // [sp+24h] [bp-14h]@31
  int v20; // [sp+28h] [bp-10h]@18
  int v21; // [sp+2Ch] [bp-Ch]@20
  int v22; // [sp+30h] [bp-8h]@39
  int v23; // [sp+34h] [bp-4h]@12

  if ( a2 && a4 )
  {
    v14 = 0;
    if ( a3 & 1 )
    {
      v4 = *(const WCHAR **)(a4 + 16);
      if ( v4 )
      {
        v5 = *(_DWORD *)(a4 + 20);
        if ( v5 )
        {
          if ( *(_DWORD *)(a2 + 12) == -1 )
          {
            v19 = *(_DWORD *)(a4 + 20);
            v14 = 1;
            lpString = v4;
            *v4 = 0;
          }
          else
          {
            StringCchCopyW((STRSAFE_LPWSTR)v4, v5, *(STRSAFE_LPCWSTR *)(a2 + 12));
          }
        }
      }
    }
    if ( a3 & 2 )
    {
      v8 = *(_WORD *)(a2 + 22);
      if ( v8 == -1 )
        v14 |= 2u;
      else
        *(_DWORD *)(a4 + 24) = v8;
    }
    if ( a3 & 0x20 )
    {
      v9 = *(_WORD *)(a2 + 24);
      if ( v9 == -1 )
        v14 |= 0x20u;
      else
        *(_DWORD *)(a4 + 28) = v9;
    }
    if ( a3 & 0x80 )
      *(_DWORD *)(a4 + 40) = *(_WORD *)(a2 + 32);
    if ( a3 & 0x40 )
    {
      if ( *(_BYTE *)(a2 + 31) )
      {
        switch ( *(_BYTE *)(a2 + 31) )
        {
          case 1:
            *(_DWORD *)(a4 + 32) = 1;
            break;
          case 2:
            *(_DWORD *)(a4 + 32) = 0;
            break;
          case 3:
            v14 |= 0x40u;
            break;
        }
      }
      else
      {
        *(_DWORD *)(a4 + 32) = *(_DWORD *)(a2 + 8) != 0;
      }
    }
    v6 = (v14 & 0x63) == 0;
    v16 = *(_WORD *)(a2 + 20);
    *(_DWORD *)(a4 + 8) = v16;
    v23 = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a4 + 36) = v23;
    if ( !v6 )
    {
      v15 = a2;
      CCSendNotify(a1, -452, (LPARAM)&lParam);
      v7 = v14;
      if ( v14 & 0x40 )
        *(_DWORD *)(a4 + 32) = v22;
      if ( v7 & 2 )
        *(_DWORD *)(a4 + 24) = v20;
      if ( v7 & 0x20 )
        *(_DWORD *)(a4 + 28) = v21;
      if ( v7 & 1 )
      {
        if ( a3 & 1 )
          v10 = CCReturnDispInfoText(lpString, *(STRSAFE_LPWSTR *)(a4 + 16), *(_DWORD *)(a4 + 20));
        else
          v10 = lpString;
        *(_DWORD *)(a4 + 16) = v10;
      }
      if ( v14 & 8 )
      {
        v11 = v16 & v17 | *(_DWORD *)(a4 + 8) & ~v17;
        *(_DWORD *)(a4 + 8) = v11;
        if ( v11 & 0x10 )
        {
          if ( !*(_DWORD *)(a1 + 124) )
            TV_CreateBoldFont(a1);
        }
      }
      if ( v14 & 0x1000 )
      {
        if ( v14 & 1 && lpString )
          Str_Set(a2 + 12, lpString);
        v12 = v14;
        if ( v14 & 8 )
        {
          if ( (*(_BYTE *)(a4 + 8) ^ (unsigned __int8)*(_WORD *)(a2 + 20)) & 0x10 )
            *(_WORD *)(a2 + 26) = 0;
          *(_WORD *)(a2 + 20) = *(_WORD *)(a4 + 8);
        }
        if ( v12 & 2 )
          *(_WORD *)(a2 + 22) = *(_WORD *)(a4 + 24);
        if ( v12 & 0x20 )
          *(_WORD *)(a2 + 24) = *(_WORD *)(a4 + 28);
        if ( v12 & 0x40 )
        {
          if ( v22 == -1 )
            *(_BYTE *)(a2 + 31) = 3;
          else
            *(_BYTE *)(a2 + 31) = (v22 == 0) + 1;
        }
      }
    }
  }
}

//----- (6F7842CF) --------------------------------------------------------
signed int __stdcall TV_SelectItem(int a1, int a2, int a3, char a4, int a5)
{
  struct _IMAGELIST *v5; // eax@1
  int v6; // eax@8
  int v7; // eax@11
  int v8; // ebx@13
  int v10; // eax@26
  UINT v11; // eax@28
  int v12; // eax@36
  signed int flags; // [sp+Ch] [bp-4h]@1

  v5 = *(struct _IMAGELIST **)(a1 + 84);
  flags = 1;
  if ( v5 && ImageList_GetBkColor(v5) == -1 )
    flags = 5;
  if ( ValidateTreeItem(a3, 1) )
  {
    if ( a2 == 5 )
    {
      if ( a3 )
      {
        TV_EnsureVisible(a1, a3);
        if ( *(_BYTE *)(a1 + 36) & 2 )
          TV_SmoothSetTopItem(a1, *(_WORD *)(a3 + 28), 0);
        return 1;
      }
    }
    else
    {
      if ( a2 == 8 )
      {
        v10 = *(_DWORD *)(a1 + 48);
        if ( a3 != v10 )
        {
          if ( v10 )
          {
            *(_WORD *)(v10 + 20) &= 0xFFF7u;
            TV_InvalidateItem(a1, *(_DWORD *)(a1 + 48), flags);
          }
          if ( a3 )
          {
            *(_WORD *)(a3 + 20) |= 8u;
            TV_InvalidateItem(a1, a3, flags);
          }
          v12 = *(_DWORD *)(a1 + 44);
          *(_DWORD *)(a1 + 48) = a3;
          if ( v12 )
            TV_InvalidateItem(a1, v12, flags);
          if ( a4 & 2 )
            UpdateWindow(*(HWND *)a1);
        }
        return 1;
      }
      if ( a2 == 9 )
      {
        v6 = *(_DWORD *)(a1 + 44);
        if ( v6 == a3 )
          return 1;
        if ( !(a4 & 1) || !TV_SendSelChange(a1, -450, v6, a3, a5) )
        {
          v7 = *(_DWORD *)(a1 + 44);
          if ( v7 )
          {
            *(_WORD *)(v7 + 20) &= 0xFFFDu;
            TV_InvalidateItem(a1, *(_DWORD *)(a1 + 44), flags);
          }
          v8 = *(_DWORD *)(a1 + 44);
          *(_DWORD *)(a1 + 44) = a3;
          if ( a3 )
          {
            *(_WORD *)(a3 + 20) |= 2u;
            TV_ExpandParents(a1, a3, a4 & 1);
            TV_InvalidateItem(a1, a3, flags);
            if ( a5 == 1 )
            {
              v11 = GetDoubleClickTime();
              SetTimer(*(HWND *)a1, 0x2Bu, v11, 0);
              *(_DWORD *)(a1 + 36) |= 0x20u;
            }
            else if ( *(_BYTE *)(a1 + 36) & 0x10 )
            {
              TV_ScrollVertIntoView(a1, a3);
            }
          }
          if ( a4 & 1 )
            TV_SendSelChange(a1, -451, v8, a3, a5);
          if ( *(_DWORD *)(a1 + 8) & 0x400 && !(a4 & 4) && a5 != 2 )
            TV_ExpandOnSelChange(a1, *(_DWORD *)(a1 + 44), v8);
          if ( a4 & 2 )
            UpdateWindow(*(HWND *)a1);
          MyNotifyWinEvent(32773, *(_DWORD *)a1, -4, a3);
          MyNotifyWinEvent(32774, *(_DWORD *)a1, -4, a3);
          return 1;
        }
      }
    }
  }
  return 0;
}

//----- (6F784419) --------------------------------------------------------
COLORREF __stdcall ImageList_GetBkColor(HIMAGELIST himl)
{
  COLORREF v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, int *))(*(_DWORD *)himl + 84))(himl, &v2);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F784496) --------------------------------------------------------
int __stdcall TV_SetLeft(int a1, int nPos)
{
  int v2; // ecx@1
  int v3; // edx@3
  int v4; // ebx@3
  int v5; // eax@5
  int result; // eax@6
  int v7; // edx@11
  HWND v8; // ST00_4@12
  int dy; // [sp+Ch] [bp-38h]@11
  int v10; // [sp+10h] [bp-34h]@11
  int v11; // [sp+14h] [bp-30h]@11
  int v12; // [sp+18h] [bp-2Ch]@11
  int v13; // [sp+1Ch] [bp-28h]@11
  int v14; // [sp+20h] [bp-24h]@11
  int v15; // [sp+24h] [bp-20h]@11
  int v16; // [sp+28h] [bp-1Ch]@11
  int v17; // [sp+2Ch] [bp-18h]@11
  int v18; // [sp+30h] [bp-14h]@11
  int v19; // [sp+34h] [bp-10h]@11
  int v20; // [sp+38h] [bp-Ch]@11
  int v21; // [sp+3Ch] [bp-8h]@11
  int v22; // [sp+40h] [bp-4h]@11

  v2 = *(_DWORD *)(a1 + 36);
  if ( !(v2 & 1) || *(_DWORD *)(a1 + 8) & 0xA000 )
    goto LABEL_15;
  v3 = *(_WORD *)(a1 + 190);
  v4 = nPos;
  if ( nPos > *(_WORD *)(a1 + 194) - v3 )
    v4 = *(_WORD *)(a1 + 194) - v3;
  if ( v4 < 0 )
    v4 = 0;
  v5 = *(_WORD *)(a1 + 198);
  if ( v4 != v5 )
  {
    if ( v2 & 0x10 )
    {
      v7 = *(_DWORD *)a1;
      v12 = v5 - v4;
      v19 = *(_DWORD *)(a1 + 212);
      v20 = 1;
      v21 = 1;
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      dy = 56;
      v10 = 6;
      v11 = v7;
      v18 = 6;
      v22 = 0;
      SmoothScrollWindow((int)&dy);
    }
    v8 = *(HWND *)a1;
    *(_WORD *)(a1 + 198) = v4;
    SetScrollPos(v8, 0, v4, 1);
    TV_UpdateToolTip(a1);
    result = 1;
  }
  else
  {
LABEL_15:
    result = 0;
  }
  return result;
}

//----- (6F784564) --------------------------------------------------------
int __userpurge sub_6F784564@<eax>(int _EAX@<eax>, int a2@<ebx>, int a3@<ebp>, HDC a4, int a5)
{
  int v5; // ebx@1

  v5 = *(_DWORD *)(a2 + 83);
  *(_BYTE *)_EAX += _EAX;
  LOBYTE(_EAX) = 101;
  *(_BYTE *)(a3 + 14) ^= BYTE1(v5);
  __asm { aam     9Ah }
  *(_BYTE *)_EAX += _EAX;
  return TV_SetIndent(a4, a5);
}

//----- (6F78457B) --------------------------------------------------------
int __stdcall TV_SetIndent(HDC hdc, int a2)
{
  int v2; // eax@1
  signed __int16 v3; // cx@2
  signed __int16 v5; // cx@5

  v2 = a2;
  if ( *((_DWORD *)hdc + 21) )
  {
    v5 = *((_WORD *)hdc + 88);
    if ( (signed __int16)a2 < v5 )
      v2 = v5;
  }
  v3 = *((_WORD *)hdc + 90);
  if ( (signed __int16)v2 < v3 )
    v2 = v3;
  if ( (unsigned int)v2 < 5 )
    LOWORD(v2) = 5;
  *((_WORD *)hdc + 94) = v2;
  TV_CreateIndentBmps(hdc);
  return TV_ScrollBarsAfterSetWidth((int)hdc, 0);
}

//----- (6F7846A9) --------------------------------------------------------
HGLOBAL __stdcall ThunkItemAtoW(int a1, int a2)
{
  HGLOBAL result; // eax@2
  HGLOBAL v3; // edi@2
  int v4; // eax@5
  int v5; // esi@5
  WCHAR *v6; // eax@5
  SIZE_T dwBytes; // [sp+0h] [bp-4h]@1

  dwBytes = 0;
  if ( ULongAdd(*(_DWORD *)(a1 + 48), 0x1Cu, &dwBytes) < 0 )
    return 0;
  result = GlobalAlloc(0x40u, dwBytes);
  v3 = result;
  if ( !result )
    return result;
  *(_DWORD *)result = *(_DWORD *)a2;
  *((_DWORD *)result + 1) = *(_DWORD *)(a2 + 4);
  *((_DWORD *)result + 2) = *(_DWORD *)(a2 + 8);
  if ( *(_BYTE *)a2 & 1 && *(_DWORD *)(a2 + 12) )
  {
    v4 = lstrlenA(*(LPCSTR *)(a2 + 12));
    v5 = v4 + 1;
    v6 = (WCHAR *)GlobalAlloc(0x40u, 2 * (v4 + 1));
    *((_DWORD *)v3 + 3) = v6;
    if ( !v6 )
    {
      GlobalFree(v3);
      return 0;
    }
    if ( !MultiByteToWideChar(0, 0, *(LPCSTR *)(a2 + 12), -1, v6, v5) && GetLastError() )
    {
      GlobalFree(*((HGLOBAL *)v3 + 3));
      GlobalFree(v3);
      return 0;
    }
  }
  *((_DWORD *)v3 + 4) = *(_DWORD *)(a2 + 16);
  if ( *(_BYTE *)a2 & 2 )
    *((_DWORD *)v3 + 5) = *(_DWORD *)(a2 + 20);
  if ( *(_BYTE *)a2 & 8 )
    memmove((char *)v3 + 24, (const void *)(a2 + 24), *(_DWORD *)(a1 + 48));
  return v3;
}

//----- (6F784770) --------------------------------------------------------
BOOL __stdcall TV_DrawPlusMinus(HDC hdc, int x, int y, int a4, HGDIOBJ h, HGDIOBJ a6, HGDIOBJ a7, int a8)
{
  int v8; // esi@1
  int v10; // [sp+Ch] [bp-8h]@1
  int w; // [sp+10h] [bp-4h]@1

  v8 = 7 * a4 / 10;
  v10 = 7 * a4 / 10;
  w = 2 * v8 + 1;
  SelectObject(hdc, h);
  if ( v8 >= 5 )
  {
    PatBlt(hdc, x - v10, y - 1, w, 3, 0xF00021u);
    if ( a8 )
      PatBlt(hdc, x - 1, y - v10, 3, w, 0xF00021u);
    SelectObject(hdc, a7);
    --v10;
    w = 2 * v8 - 1;
  }
  PatBlt(hdc, x - v10, y, w, 1, 0xF00021u);
  if ( a8 )
    PatBlt(hdc, x, y - v10, 1, w, 0xF00021u);
  SelectObject(hdc, a6);
  PatBlt(hdc, x - a4, y - a4, 2 * a4 + 1, 1, 0xF00021u);
  PatBlt(hdc, x - a4, y - a4, 1, 2 * a4 + 1, 0xF00021u);
  PatBlt(hdc, x - a4, a4 + y, 2 * a4 + 1, 1, 0xF00021u);
  return PatBlt(hdc, a4 + x, y - a4, 1, 2 * a4 + 1, 0xF00021u);
}

//----- (6F784896) --------------------------------------------------------
BOOL __stdcall TV_DeleteHotFonts(int a1)
{
  BOOL result; // eax@2

  if ( *(_DWORD *)(a1 + 120) )
    DeleteObject(*(HGDIOBJ *)(a1 + 120));
  result = *(_DWORD *)(a1 + 128);
  if ( result )
    result = DeleteObject(*(HGDIOBJ *)(a1 + 128));
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  return result;
}

//----- (6F7848E0) --------------------------------------------------------
HBITMAP __stdcall CreateColorBitmap(int a1, int cy)
{
  HBITMAP v2; // eax@3
  HBITMAP v3; // esi@4
  BITMAPINFO bmi; // [sp+8h] [bp-30h]@6
  HDC hdc; // [sp+34h] [bp-4h]@1

  hdc = GetDC(0);
  if ( GetDeviceCaps(hdc, 38) & 0x100 || GetSystemMetrics(80) <= 1 || GetSystemMetrics(81) )
  {
    v2 = CreateCompatibleBitmap(hdc, a1, cy);
  }
  else
  {
    bmi.bmiHeader.biWidth = a1;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biSize = 40;
    memset(&bmi.bmiHeader.biCompression, 0, 0x1Cu);
    v2 = CreateDIBSection(hdc, &bmi, 0, (void **)&cy, 0, 0);
  }
  v3 = v2;
  ReleaseDC(0, hdc);
  return v3;
}

//----- (6F784993) --------------------------------------------------------
signed int __stdcall CImageList::SetOverlayImage(CImageList *this, SIZE_T uBytes, int a3)
{
  CImageList *v3; // ecx@1

  v3 = (CImageList *)*((_DWORD *)this + 111);
  if ( v3 )
    CImageList::_SetOverlayImage(v3, uBytes, a3);
  return CImageList::_SetOverlayImage((CImageList *)((char *)this - 8), uBytes, a3);
}

//----- (6F7849C2) --------------------------------------------------------
BOOL __stdcall ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay)
{
  BOOL v3; // esi@1

  v3 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v3 = (*(int (__stdcall **)(HIMAGELIST, int, int))(*(_DWORD *)himl + 20))(himl, iImage, iOverlay) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v3;
}

//----- (6F784A77) --------------------------------------------------------
HGDIOBJ __stdcall TV_CreateIndentBmps(HDC hdc)
{
  int v1; // esi@1
  HGDIOBJ result; // eax@3
  void *v3; // edi@8
  HBRUSH v4; // eax@11
  HBRUSH v5; // eax@13
  HGDIOBJ v6; // eax@14
  HBRUSH v7; // ST1C_4@14
  int v8; // edi@14
  __int64 v9; // rax@15
  signed int v10; // ecx@15
  int v11; // eax@16
  signed int v12; // kr00_4@18
  int v13; // ebx@18
  int v14; // edi@19
  int v15; // edi@19
  int v16; // edi@21
  int v17; // edi@29
  int v18; // edi@29
  HBITMAP v19; // [sp-Ch] [bp-3Ch]@8
  RECT rc; // [sp+4h] [bp-2Ch]@14
  HGDIOBJ v21; // [sp+14h] [bp-1Ch]@14
  int x; // [sp+18h] [bp-18h]@19
  int v23; // [sp+1Ch] [bp-14h]@21
  HGDIOBJ ho; // [sp+20h] [bp-10h]@14
  HGDIOBJ h; // [sp+24h] [bp-Ch]@12
  int y; // [sp+28h] [bp-8h]@4
  int v27; // [sp+2Ch] [bp-4h]@15
  HDC hdca; // [sp+38h] [bp+8h]@8

  v1 = (int)hdc;
  if ( *((_BYTE *)hdc + 36) & 0x10 )
    InvalidateRect(*(HWND *)hdc, 0, 1);
  result = (HGDIOBJ)*((_DWORD *)hdc + 2);
  if ( (unsigned __int8)result & 2 )
  {
    y = 4 * ((*((_DWORD *)hdc + 2) & 1) != 0) + 3;
    if ( (unsigned __int8)result & 4 )
    {
      if ( (unsigned __int8)result & 1 )
        y += 3;
      else
        ++y;
    }
  }
  else
  {
    if ( !((unsigned __int8)result & 1) )
      return result;
    y = 2;
  }
  if ( !*((_DWORD *)hdc + 35) )
    *((_DWORD *)hdc + 35) = CreateCompatibleDC(0);
  hdca = (HDC)*((_DWORD *)hdc + 35);
  TV_GetBackgroundBrush(v1, (WPARAM)hdca);
  v3 = *(void **)(v1 + 136);
  v19 = CreateColorBitmap(y * *(_WORD *)(v1 + 188), *(_WORD *)(v1 + 182));
  *(_DWORD *)(v1 + 136) = v19;
  if ( v3 )
  {
    SelectObject(hdca, v19);
    DeleteObject(v3);
  }
  else
  {
    *(_DWORD *)(v1 + 132) = SelectObject(hdca, v19);
  }
  if ( *(_DWORD *)(v1 + 172) == -16777216 )
    v4 = (HBRUSH)g_hbrGrayText;
  else
    v4 = CreateSolidBrush(*(_DWORD *)(v1 + 172));
  h = v4;
  if ( *(_DWORD *)(v1 + 160) == -1 )
    v5 = (HBRUSH)g_hbrWindowText;
  else
    v5 = CreateSolidBrush(*(_DWORD *)(v1 + 160));
  ho = v5;
  v6 = SelectObject(hdca, h);
  v7 = *(HBRUSH *)(v1 + 112);
  v21 = v6;
  rc.right = y * *(_WORD *)(v1 + 188);
  rc.bottom = *(_WORD *)(v1 + 182);
  v8 = 0;
  rc.top = 0;
  rc.left = 0;
  FillRect(hdca, &rc, v7);
  if ( *(_DWORD *)(v1 + 84) )
  {
    v9 = *(_WORD *)(v1 + 176) - 3;
    LODWORD(v9) = v9 - HIDWORD(v9);
    v10 = (signed int)v9 >> 1;
    v27 = (signed int)v9 >> 1;
  }
  else
  {
    v27 = *(_WORD *)(v1 + 188) / 2;
    v10 = v27;
  }
  y = (*(_WORD *)(v1 + 182) / 2 + 1) & 0xFFFFFFFE;
  v11 = y;
  if ( v10 < y )
    v11 = v10;
  v12 = v11;
  result = (HGDIOBJ)(v11 - ((unsigned __int64)v11 >> 32));
  v13 = v12 / 2;
  if ( *(_BYTE *)(v1 + 8) & 2 )
  {
    TV_DrawDottedLine(hdca, v10, 0, *(_WORD *)(v1 + 182), 1);
    v14 = *(_WORD *)(v1 + 188);
    TV_DrawDottedLine(hdca, v14 + v27, 0, *(_WORD *)(v1 + 182), 1);
    TV_DrawDottedLine(hdca, v14 + v27, y, *(_WORD *)(v1 + 188) - v27, 0);
    v15 = *(_WORD *)(v1 + 188) + v14;
    x = v15 + v27;
    TV_DrawDottedLine(hdca, v15 + v27, 0, y, 1);
    TV_DrawDottedLine(hdca, x, y, *(_WORD *)(v1 + 188) - v27, 0);
    result = (HGDIOBJ)*(_WORD *)(v1 + 188);
    v10 = v27;
    v8 = (int)((char *)result + v15);
  }
  if ( *(_BYTE *)(v1 + 8) & 1 )
  {
    v23 = 1;
    v16 = v10 + v8;
    while ( 1 )
    {
      TV_DrawPlusMinus(hdca, v16, y, v12 / 2, ho, h, *(HGDIOBJ *)(v1 + 112), v23);
      if ( *(_BYTE *)(v1 + 8) & 2 )
      {
        x = y - v13;
        TV_DrawDottedLine(hdca, v16, 0, y - v13, 1);
        TV_DrawDottedLine(hdca, v16 + v13, y, *(_WORD *)(v1 + 188) - v13 - v27, 0);
        TV_DrawDottedLine(hdca, v16, v13 + y, x, 1);
        v16 += *(_WORD *)(v1 + 188);
        TV_DrawPlusMinus(hdca, v16, y, v12 / 2, ho, h, *(HGDIOBJ *)(v1 + 112), v23);
        TV_DrawDottedLine(hdca, v16, 0, x, 1);
        TV_DrawDottedLine(hdca, v16 + v13, y, *(_WORD *)(v1 + 188) - v13 - v27, 0);
      }
      result = (HGDIOBJ)*(_WORD *)(v1 + 188);
      v16 += (int)result;
      if ( !v23 )
        break;
      v23 = 0;
    }
    v8 = v16 - v27;
    v10 = v27;
  }
  if ( *(_BYTE *)(v1 + 8) & 4 )
  {
    result = (HGDIOBJ)TV_DrawDottedLine(hdca, v8 + v10, y, *(_WORD *)(v1 + 188) - v10, 0);
    if ( *(_BYTE *)(v1 + 8) & 1 )
    {
      v17 = v27 + *(_WORD *)(v1 + 188) + v8;
      TV_DrawPlusMinus(hdca, v17, y, v12 / 2, ho, h, *(HGDIOBJ *)(v1 + 112), 1);
      TV_DrawDottedLine(hdca, v17 + v13, y, *(_WORD *)(v1 + 188) - v13 - v27, 0);
      v18 = *(_WORD *)(v1 + 188) + v17;
      TV_DrawPlusMinus(hdca, v18, y, v12 / 2, ho, h, *(HGDIOBJ *)(v1 + 112), 0);
      result = (HGDIOBJ)TV_DrawDottedLine(hdca, v18 + v13, y, *(_WORD *)(v1 + 188) - v13 - v27, 0);
    }
  }
  if ( v21 )
    result = SelectObject(*(HDC *)(v1 + 140), v21);
  if ( *(_DWORD *)(v1 + 172) != -16777216 )
    result = (HGDIOBJ)DeleteObject(h);
  if ( *(_DWORD *)(v1 + 160) != -1 )
    result = (HGDIOBJ)DeleteObject(ho);
  return result;
}
// 6F7E6884: using guessed type int g_hbrGrayText;
// 6F7E6894: using guessed type int g_hbrWindowText;

//----- (6F784E4B) --------------------------------------------------------
int __stdcall TV_DrawDottedLine(HDC hdc, int x, int y, int a4, int a5)
{
  int result; // eax@1
  unsigned int v6; // esi@2

  result = a4;
  if ( a4 > 0 )
  {
    v6 = ((unsigned int)(a4 - 1) >> 1) + 1;
    do
    {
      result = PatBlt(hdc, x, y, 1, 1, 0xF00021u);
      if ( a5 )
        y += 2;
      else
        x += 2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

//----- (6F784F32) --------------------------------------------------------
int __stdcall FreeItemW(HGLOBAL hMem)
{
  if ( *(_BYTE *)hMem & 1 && *((_DWORD *)hMem + 3) )
    GlobalFree(*((HGLOBAL *)hMem + 3));
  GlobalFree(hMem);
  return 1;
}

//----- (6F784F62) --------------------------------------------------------
int __stdcall Tab_OnInsertItem(INT_PTR a1, int i, int a3)
{
  int v3; // eax@1
  void *v4; // edi@1
  int v5; // ebx@2
  int v6; // eax@3
  int v7; // eax@5
  HWND v8; // eax@6
  int v9; // eax@8
  INT_PTR v10; // eax@9
  int result; // eax@11
  int v12; // ecx@18
  int v13; // ecx@18
  struct _DPA *v14; // eax@20
  PVOID v15; // edi@22
  bool v16; // zf@23
  LPARAM lParam; // [sp+8h] [bp-3Ch]@18
  int v18; // [sp+Ch] [bp-38h]@18
  HWND v19; // [sp+10h] [bp-34h]@18
  int v20; // [sp+14h] [bp-30h]@18
  int v21; // [sp+2Ch] [bp-18h]@18
  struct tagRECT Rect; // [sp+34h] [bp-10h]@22

  v3 = Tab_CreateItem(a1, a3);
  v4 = (void *)v3;
  if ( v3 )
  {
    v5 = DPA_InsertPtr(*(HDPA *)(a1 + 40), i, (void *)v3);
    if ( v5 != -1 )
    {
      v6 = *(_DWORD *)(a1 + 60);
      if ( v6 >= 0 )
      {
        if ( v6 >= v5 )
          *(_DWORD *)(a1 + 60) = v6 + 1;
      }
      else
      {
        *(_DWORD *)(a1 + 60) = v5;
      }
      v7 = *(_DWORD *)(a1 + 88);
      if ( v7 > v5 )
        *(_DWORD *)(a1 + 88) = v7 + 1;
      v8 = *(HWND *)(a1 + 132);
      *(_DWORD *)(a1 + 68) = 0x7FFFFFFF;
      if ( v8 )
      {
        v18 = *(_DWORD *)a3 & 4;
        v19 = *(HWND *)a1;
        v12 = *(_DWORD *)(a1 + 40);
        lParam = 44;
        v13 = *(_DWORD *)v12;
        v21 = -1;
        v20 = v13 - 1;
        SendMessageW(v8, 0x432u, 0, (LPARAM)&lParam);
      }
      if ( !(*(_BYTE *)(a1 + 44) & 0x10) )
        goto LABEL_11;
      v9 = *(_DWORD *)(a1 + 8);
      if ( v9 & 0x100 )
      {
        if ( v9 & 0x400 )
        {
          CalcPaintMetrics(a1, 0);
          v14 = *(struct _DPA **)(a1 + 40);
          if ( v5 == *(_DWORD *)v14 - 1 )
          {
            Tab_InvalidateItem(a1, v5, 0);
          }
          else
          {
            v15 = DPA_GetPtr(v14, v5);
            GetClientRect(*(HWND *)a1, &Rect);
            if ( v15 )
            {
              v16 = *(_DWORD *)(a1 + 112) == 0;
              Rect.top = *((_DWORD *)v15 + 1);
              if ( v16 )
                Rect.left = *(_DWORD *)v15;
              Tab_UpdateArrows(a1, 0);
              RedrawWindow(*(HWND *)a1, &Rect, 0, 0x41u);
            }
          }
          goto LABEL_11;
        }
      }
      else
      {
        v10 = *(_DWORD *)(a1 + 60);
        if ( v10 > v5 )
        {
          Tab_InvalidateItem(a1, v10, 1);
          UpdateWindow(*(HWND *)a1);
        }
      }
      RedrawAll(a1, 0x41u);
LABEL_11:
      MyNotifyWinEvent(0x8000, *(_DWORD *)a1, -4, v5 + 1);
      return v5;
    }
    Tab_FreeItem(a1, v4);
    result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7850A4) --------------------------------------------------------
void __stdcall Tab_StyleChanged(INT_PTR i, int a2, int a3)
{
  int v3; // eax@3
  int v4; // edi@3
  int v5; // ecx@3
  int v6; // edx@5
  int v7; // eax@11

  if ( !i || a2 != -16 )
    goto LABEL_7;
  v3 = *(_DWORD *)(a3 + 4);
  v4 = *(_DWORD *)(i + 8);
  v5 = (v4 ^ *(_DWORD *)(a3 + 4)) & 0x2FFA;
  if ( v4 != 1342193664 || v3 != 1409302531 )
  {
    if ( v5 )
    {
      v7 = v4 ^ (v4 ^ v3) & 0x2FFA;
      *(_DWORD *)(i + 8) = v7;
      if ( !(v7 & 0x400) )
        *(_DWORD *)(i + 8) = v7 & 0xFFFFFFCF;
      *(_DWORD *)(i + 68) = 0x7FFFFFFF;
      *(_DWORD *)(i + 76) = 0x7FFFFFFF;
      if ( ((char)v5 < 0 || v5 & 2 && *(_BYTE *)(i + 8) & 0x80) && !(*(_BYTE *)(i + 44) & 0x40) )
        Tab_OnSetFont(i, 0, 0);
      if ( *(_BYTE *)(i + 44) & 0x10 )
        Tab_UpdateArrows(i, 1);
      RedrawAll(i, 5u);
    }
    v6 = *(_DWORD *)(i + 8);
    if ( (v6 ^ *(_DWORD *)(a3 + 4)) & 0x9000 )
    {
      *(_DWORD *)(i + 8) = v6 ^ (v6 ^ *(_DWORD *)(a3 + 4)) & 0x9000;
LABEL_7:
      if ( a2 == -20 )
      {
        *(_DWORD *)(i + 24) &= 0xFFFFDFFF;
        *(_DWORD *)(i + 24) |= *(_DWORD *)(a3 + 4) & 0x2000;
      }
      return;
    }
  }
}

//----- (6F785121) --------------------------------------------------------
LRESULT __stdcall TV_OnSetFont(HDC hdc, UINT fWinIni, int a3)
{
  bool v3; // zf@1
  UINT v4; // edi@1
  HFONT v5; // eax@5
  HDC v6; // eax@6
  HDC v7; // ebx@6
  LRESULT result; // eax@15
  struct tagSIZE sz; // [sp+8h] [bp-70h]@8
  WCHAR String[2]; // [sp+10h] [bp-68h]@1
  HGDIOBJ h; // [sp+14h] [bp-64h]@7
  char pvParam; // [sp+18h] [bp-60h]@5

  v3 = (*((_BYTE *)hdc + 36) & 0x40) == 0;
  v4 = fWinIni;
  *(_DWORD *)String = 74;
  if ( !v3 && *((_DWORD *)hdc + 29) )
  {
    DeleteObject(*((HGDIOBJ *)hdc + 29));
    *((_DWORD *)hdc + 9) &= 0xFFFFFFBF;
  }
  if ( !fWinIni )
  {
    SystemParametersInfoW(0x1Fu, 0x5Cu, &pvParam, 0);
    v5 = CreateFontIndirectW((const LOGFONTW *)&pvParam);
    *((_DWORD *)hdc + 9) |= 0x40u;
    v4 = (UINT)v5;
  }
  v6 = GetDC(*(HWND *)hdc);
  v7 = v6;
  if ( v4 )
    h = SelectObject(v6, (HGDIOBJ)v4);
  else
    h = 0;
  sz.cy = 0;
  GetTextExtentPointW(v7, String, 1, &sz);
  v3 = h == 0;
  *((_WORD *)hdc + 90) = LOWORD(sz.cy) + 2 * g_cyBorder;
  if ( !v3 )
    SelectObject(v7, h);
  ReleaseDC(*(HWND *)hdc, v7);
  *((_DWORD *)hdc + 29) = v4;
  if ( *((_DWORD *)hdc + 31) )
    TV_CreateBoldFont((int)hdc);
  *((_DWORD *)hdc + 5) = GetCodePageForFont((HANDLE)v4);
  TV_DeleteHotFonts((int)hdc);
  if ( !*((_WORD *)hdc + 94) )
  {
    if ( !*((_WORD *)hdc + 91) )
      *((_WORD *)hdc + 91) = *((_WORD *)hdc + 90);
    TV_SetIndent(hdc, 19);
  }
  TV_ScrollBarsAfterSetWidth((int)hdc, 0);
  TV_SetItemHeight(hdc);
  result = *((_DWORD *)hdc + 56);
  if ( result )
    result = SendMessageW((HWND)result, 0x30u, *((_DWORD *)hdc + 29), 1);
  return result;
}

//----- (6F785258) --------------------------------------------------------
int __stdcall TV_SetItemHeight(HDC hdc)
{
  __int16 v1; // ax@2
  __int16 v2; // ax@5
  signed __int16 v3; // ax@7

  if ( !(*((_DWORD *)hdc + 9) & 0x800) )
  {
    v1 = *((_WORD *)hdc + 89);
    if ( v1 <= *((_WORD *)hdc + 90) )
      v1 = *((_WORD *)hdc + 90);
    *((_WORD *)hdc + 91) = v1 + 1;
  }
  v2 = *((_WORD *)hdc + 91);
  if ( v2 <= 1 )
  {
    v3 = 1;
    goto LABEL_8;
  }
  if ( !(*((_DWORD *)hdc + 2) & 0x4000) )
  {
    v3 = v2 & 0xFFFE;
LABEL_8:
    *((_WORD *)hdc + 91) = v3;
  }
  *((_WORD *)hdc + 98) = *((_WORD *)hdc + 96) / *((_WORD *)hdc + 91);
  TV_CreateIndentBmps(hdc);
  return TV_CalcScrollBars((int)hdc);
}

//----- (6F7852EC) --------------------------------------------------------
int __stdcall TV_SetImageList(HDC hdc, HIMAGELIST himl, int cy)
{
  int v3; // edi@1
  HIMAGELIST v4; // ebx@2
  __int16 v5; // cx@4
  __int16 v6; // ax@4
  bool v7; // sf@4
  unsigned __int8 v8; // of@4
  struct _IMAGELIST *v10; // eax@9

  v3 = 0;
  if ( cy )
  {
    if ( cy == 2 )
    {
      v10 = himl;
      v3 = *((_DWORD *)hdc + 22);
      *((_DWORD *)hdc + 22) = himl;
      if ( v10 )
        ImageList_GetIconSize(v10, (int *)hdc + 25, (int *)hdc + 26);
      else
        *((_DWORD *)hdc + 25) = 0;
    }
  }
  else
  {
    v3 = *((_DWORD *)hdc + 21);
    v4 = himl;
    if ( himl && ImageList_GetIconSize(himl, (int *)&himl, &cy) )
    {
      v5 = cy;
      v6 = (_WORD)himl + 3;
      v8 = __OFSUB__(*((_WORD *)hdc + 94), (_WORD)himl + 3);
      v7 = (signed __int16)(*((_WORD *)hdc + 94) - ((_WORD)himl + 3)) < 0;
      *((_WORD *)hdc + 88) = (_WORD)himl + 3;
      *((_WORD *)hdc + 89) = v5;
      if ( v7 ^ v8 )
        TV_SetIndent(hdc, v6);
      *((_DWORD *)hdc + 21) = v4;
      if ( !v3 && *((_DWORD *)hdc + 2) & 0x100 )
        TV_InitCheckBoxes(hdc);
    }
    else
    {
      *((_DWORD *)hdc + 21) = 0;
      *((_WORD *)hdc + 89) = 0;
      *((_WORD *)hdc + 88) = 0;
    }
  }
  TV_ScrollBarsAfterSetWidth((int)hdc, 0);
  TV_SetItemHeight(hdc);
  return v3;
}

//----- (6F78539B) --------------------------------------------------------
int __stdcall TV_OnCreate(HWND hWnd, int a2)
{
  LONG v2; // esi@1
  HDPA v3; // eax@3
  int v4; // eax@5

  v2 = (LONG)LocalAlloc(0x40u, 0x104u);
  if ( !v2 )
    return -1;
  *(_DWORD *)(v2 + 148) = GetProcessHeap();
  if ( !TV_CreateRoot(v2) )
  {
LABEL_11:
    LocalFree((HLOCAL)v2);
    return -1;
  }
  v3 = DPA_Create(8);
  *(_DWORD *)(v2 + 80) = v3;
  if ( !v3 )
  {
    HeapFree(*(HANDLE *)(v2 + 148), 0, *(LPVOID *)(v2 + 40));
    goto LABEL_11;
  }
  SetWindowLongW(hWnd, 0, v2);
  CIInitialize(v2, (WPARAM)hWnd, a2);
  if ( *(_DWORD *)(a2 + 44) & 0x2000 )
    *(_DWORD *)(v2 + 8) |= 0x40u;
  *(_DWORD *)(v2 + 36) |= 0x10u;
  *(_DWORD *)(v2 + 164) = -1;
  *(_DWORD *)(v2 + 160) = -1;
  *(_DWORD *)(v2 + 212) = -1;
  *(_DWORD *)(v2 + 168) = -16777216;
  *(_DWORD *)(v2 + 172) = -16777216;
  *(_WORD *)(v2 + 196) = 1;
  TV_OnSetFont((HDC)v2, 0, 1);
  v4 = *(_DWORD *)(v2 + 8);
  if ( v4 & 2 )
    *(_DWORD *)(v2 + 8) = v4 & 0xFFFFEFFF;
  if ( !(*(_BYTE *)(v2 + 8) & 0x80) )
    TV_CreateToolTips(v2);
  SetScrollRange(hWnd, 0, 0, 0, 1);
  SetScrollRange(hWnd, 1, 0, 0, 1);
  return 0;
}

//----- (6F78548A) --------------------------------------------------------
LPVOID __stdcall TV_CreateRoot(int a1)
{
  LPVOID result; // eax@1

  result = HeapAlloc(*(HANDLE *)(a1 + 148), 8u, 0x24u);
  if ( result )
  {
    *((_WORD *)result + 10) = 96;
    *((_WORD *)result + 14) = -1;
    *((_BYTE *)result + 30) = -1;
    *((_WORD *)result + 17) = -21555;
    *(_DWORD *)(a1 + 40) = result;
    Str_Set((int)((char *)result + 12), &c_szNULL);
    result = (LPVOID)1;
  }
  return result;
}

//----- (6F7854E2) --------------------------------------------------------
signed int __stdcall Tab_OnCreate(int a1)
{
  HDPA v1; // eax@1
  int v2; // eax@2
  int v3; // eax@4
  int v4; // eax@5
  int v5; // eax@6
  HDC v6; // ebx@7
  signed int result; // eax@10
  HWND v8; // eax@16
  HWND v9; // eax@16
  LPARAM lParam; // [sp+Ch] [bp-2Ch]@16
  int v11; // [sp+10h] [bp-28h]@16
  HWND v12; // [sp+14h] [bp-24h]@16
  HWND v13; // [sp+18h] [bp-20h]@16
  int v14; // [sp+30h] [bp-8h]@16

  v1 = DPA_Create(4);
  *(_DWORD *)(a1 + 40) = v1;
  if ( v1 )
  {
    v2 = *(_DWORD *)(a1 + 8);
    if ( !(v2 & 0x400) )
      *(_DWORD *)(a1 + 8) = v2 & 0xFFFFFFCF;
    v3 = *(_DWORD *)(a1 + 8);
    if ( (char)v3 < 0 )
      *(_DWORD *)(a1 + 8) = v3 | 0x200;
    v4 = *(_DWORD *)(a1 + 8);
    if ( v4 & 1 )
      *(_DWORD *)(a1 + 8) = v4 & 0xFFFFFEFF | 0x200;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 & 8 )
      *(_DWORD *)(a1 + 52) |= 1u;
    SetWindowLongW(*(HWND *)a1, -16, v5 | 0x4000000);
    *(_DWORD *)(a1 + 76) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 68) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 44) = 16;
    *(_DWORD *)(a1 + 48) = 4;
    *(_DWORD *)(a1 + 60) = -1;
    *(_DWORD *)(a1 + 160) = -1;
    *(_DWORD *)(a1 + 96) = 3 * g_cxEdge;
    *(_DWORD *)(a1 + 100) = 3 * g_cyEdge / 2;
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 112) = -1;
    *(_DWORD *)(a1 + 64) = -1;
    *(_DWORD *)(a1 + 116) = -1;
    v6 = GetDC(0);
    *(_DWORD *)(a1 + 104) = GetDeviceCaps(v6, 88);
    ReleaseDC(0, v6);
    InitDitherBrush();
    if ( *(_DWORD *)(a1 + 8) & 0x4000 )
    {
      v8 = *(HWND *)a1;
      v12 = v8;
      v13 = v8;
      lParam = 44;
      v11 = 1;
      v14 = 0;
      v9 = CreateWindowExW(
             0,
             L"tooltips_class32",
             &WindowName,
             0x80000000,
             2147483648,
             2147483648,
             2147483648,
             2147483648,
             v8,
             0,
             g_hinst,
             0);
      *(_DWORD *)(a1 + 132) = v9;
      if ( v9 )
        SendMessageW(v9, 0x432u, 0, (LPARAM)&lParam);
      else
        *(_DWORD *)(a1 + 8) &= 0xFFFFBFFF;
    }
    if ( g_fDBCSInputEnabled )
      *(_DWORD *)(a1 + 136) = ImmAssociateContext(*(HWND *)a1, 0);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7855EB) --------------------------------------------------------
HIMC __stdcall ImmAssociateContext(HWND a1, HIMC a2)
{
  HIMC result; // eax@1

  result = (HIMC)g_pfnImmAssociateContext;
  if ( g_pfnImmAssociateContext )
    result = (HIMC)g_pfnImmAssociateContext(a1, a2);
  return result;
}
// 6F7E6824: invalid function type has been ignored
// 6F7E6824: using guessed type int (__stdcall *g_pfnImmAssociateContext)(_DWORD, _DWORD);

//----- (6F785605) --------------------------------------------------------
int __stdcall Tab_CreateItem(int a1, int a2)
{
  ULONG v2; // ST1C_4@1
  int v3; // esi@1
  int v4; // eax@3
  SIZE_T uBytes; // [sp+Ch] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 48);
  v3 = 0;
  uBytes = 0;
  if ( ULongAdd(0x3Cu, v2, &uBytes) < 0 )
    return v3;
  if ( UIntSub(uBytes, 4u, (UINT *)&uBytes) < 0 )
    return v3;
  v4 = Alloc(uBytes);
  v3 = v4;
  if ( !v4 )
    return v3;
  *(_DWORD *)(v4 + 16) = *(_BYTE *)a2 & 2 ? *(_DWORD *)(a2 + 20) : -1;
  *(_DWORD *)(v4 + 24) = 0x7FFFFFFF;
  *(_DWORD *)(v4 + 20) = 0x7FFFFFFF;
  if ( *(_BYTE *)a2 & 8 )
  {
    if ( *(_DWORD *)(a1 + 48) )
      memmove((void *)(v4 + 56), (const void *)(a2 + 24), *(_DWORD *)(a1 + 48));
  }
  if ( !(*(_BYTE *)a2 & 1) )
    return v3;
  if ( Str_Set(v3 + 44, *(LPCWSTR *)(a2 + 12)) )
  {
    *(_DWORD *)(v3 + 52) = 32 * (*(_DWORD *)a2 & 4);
    return v3;
  }
  Tab_FreeItem(a1, (HLOCAL)v3);
  return 0;
}

//----- (6F7856A2) --------------------------------------------------------
HRESULT UIntSub(UINT uMinuend, UINT uSubtrahend, UINT *puResult)
{
  HRESULT result; // eax@2

  if ( uMinuend < uSubtrahend )
  {
    *puResult = -1;
    result = -2147024362;
  }
  else
  {
    *puResult = uMinuend - uSubtrahend;
    result = 0;
  }
  return result;
}

//----- (6F7856D7) --------------------------------------------------------
int __stdcall Tab_OnSetFont(int i, HANDLE h, int a3)
{
  int result; // eax@1
  bool v4; // zf@5
  HFONT v5; // eax@12
  char pv; // [sp+8h] [bp-60h]@12
  int v7; // [sp+10h] [bp-58h]@12
  char v8; // [sp+20h] [bp-48h]@12

  result = *(_DWORD *)(i + 56);
  if ( !result || h != (HANDLE)result )
  {
    if ( *(_BYTE *)(i + 44) & 0x80 )
    {
      DeleteObject(*(HGDIOBJ *)(i + 56));
      *(_DWORD *)(i + 44) &= 0xFFFFFF7F;
      *(_DWORD *)(i + 56) = 0;
    }
    if ( h )
    {
      *(_DWORD *)(i + 44) |= 0x40u;
      *(_DWORD *)(i + 56) = h;
      *(_DWORD *)(i + 20) = GetCodePageForFont(h);
    }
    else
    {
      *(_DWORD *)(i + 56) = g_hfontSystem;
    }
    v4 = (*(_BYTE *)(i + 8) & 0x80) == 0;
    *(_DWORD *)(i + 76) = 0x7FFFFFFF;
    *(_DWORD *)(i + 68) = 0x7FFFFFFF;
    if ( !v4 )
    {
      GetObjectW(*(HANDLE *)(i + 56), 92, &pv);
      v7 = (*(_BYTE *)(i + 8) & 2) != 0 ? 2700 : 900;
      v8 = 7;
      v5 = CreateFontIndirectW((const LOGFONTW *)&pv);
      *(_DWORD *)(i + 44) |= 0x80u;
      *(_DWORD *)(i + 56) = v5;
    }
    result = RedrawAll(i, 5u);
  }
  return result;
}

//----- (6F785752) --------------------------------------------------------
int __stdcall RedrawAll(INT_PTR i, UINT flags)
{
  int result; // eax@3

  if ( i && *(_BYTE *)(i + 44) & 0x10 )
  {
    Tab_UpdateArrows(i, 0);
    RedrawWindow(*(HWND *)i, 0, 0, flags);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F78578D) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
  void *v7; // esi@1
  struct _IMAGELIST *v8; // ebx@2
  HIMAGELIST result; // eax@3

  v7 = (void *)lpbmp;
  if ( !((unsigned int)lpbmp >> 16) || (result = (HIMAGELIST)ProduceWFromA(0, lpbmp), (v7 = (void *)result) != 0) )
  {
    v8 = ImageList_LoadImageW(hi, (LPCWSTR)v7, cx, cGrow, crMask, uType, uFlags);
    if ( (unsigned int)lpbmp >> 16 )
      FreeProducedString(v7);
    result = v8;
  }
  return result;
}

//----- (6F7857DD) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
  struct _IMAGELIST *v7; // esi@1
  HANDLE v8; // eax@1
  signed int v9; // esi@3
  int v10; // edi@4
  UINT v11; // eax@4
  struct _IMAGELIST *v12; // eax@7
  int v13; // eax@9
  char pv; // [sp+4h] [bp-18h]@2
  int v16; // [sp+8h] [bp-14h]@4
  int v17; // [sp+Ch] [bp-10h]@3
  char v18; // [sp+16h] [bp-6h]@15
  int v19; // [sp+18h] [bp-4h]@6
  int uTypea; // [sp+38h] [bp+1Ch]@3
  HBITMAP uFlagsa; // [sp+3Ch] [bp+20h]@1

  v7 = 0;
  v8 = LoadImageW(hi, lpbmp, uType, 0, 0, uFlags);
  uFlagsa = (HBITMAP)v8;
  if ( v8 )
  {
    if ( GetObjectW(v8, 24, &pv) == 24 )
    {
      v9 = cx;
      uTypea = v17;
      if ( !cx )
        v9 = v17;
      v10 = v16 / v9;
      EnterCriticalSection(&g_csDll);
      v11 = 0;
      if ( crMask != -1 )
        v11 = 1;
      if ( v19 )
        v11 |= (unsigned __int8)(v18 & 0xFE);
      v12 = ImageList_Create(v9, uTypea, v11, v10, cGrow);
      v7 = v12;
      if ( v12 )
      {
        if ( crMask == -1 )
          v13 = ImageList_Add(v12, uFlagsa, 0);
        else
          v13 = ImageList_AddMasked(v12, uFlagsa, crMask);
        if ( v13 < 0 )
        {
          ImageList_Destroy(v7);
          v7 = 0;
        }
      }
      LeaveCriticalSection(&g_csDll);
    }
    DeleteObject(uFlagsa);
  }
  return v7;
}

//----- (6F7858A3) --------------------------------------------------------
int __stdcall PrivateLocalAllocArray(unsigned int a1, unsigned int a2)
{
  int v2; // esi@1
  SIZE_T uBytes; // [sp+4h] [bp-4h]@1

  v2 = 0;
  uBytes = 0;
  if ( ULongLongToULong(a2 * (unsigned __int64)a1, &uBytes) >= 0 )
    v2 = Alloc(uBytes);
  return v2;
}

//----- (6F7858DA) --------------------------------------------------------
int __stdcall SmoothScrollWindow(int dy)
{
  int v1; // ebx@1
  int v2; // ecx@1
  RECT *v3; // eax@1
  unsigned int v4; // ecx@1
  HRGN v5; // eax@1
  unsigned int v6; // ecx@1
  int v7; // esi@1
  struct tagRECT *v8; // eax@1
  int v9; // edi@1
  unsigned int v10; // ecx@1
  int v11; // eax@4
  int v12; // ecx@4
  int (__stdcall *v13)(HWND, int, int, const RECT *, const RECT *, HRGN, LPRECT, UINT); // eax@16
  HRGN v15; // eax@30
  int v16; // eax@33
  signed int v17; // ecx@34
  int v18; // ecx@46
  int v19; // edi@46
  int v20; // eax@48
  int v21; // ecx@52
  int v22; // esi@52
  int v23; // eax@54
  unsigned int v24; // esi@58
  DWORD v25; // eax@60
  int v26; // edx@60
  int v27; // ecx@64
  int v28; // edx@66
  int v29; // ecx@70
  int v30; // edx@72
  int v31; // edx@80
  int v32; // edx@84
  char v33; // [sp+Ch] [bp-A4h]@2
  LONG v34; // [sp+1Ch] [bp-94h]@29
  LONG v35; // [sp+20h] [bp-90h]@29
  LONG v36; // [sp+24h] [bp-8Ch]@29
  LONG v37; // [sp+28h] [bp-88h]@29
  RECT rcSrc1; // [sp+2Ch] [bp-84h]@88
  int v39; // [sp+3Ch] [bp-74h]@27
  int v40; // [sp+40h] [bp-70h]@27
  int v41; // [sp+44h] [bp-6Ch]@27
  int v42; // [sp+48h] [bp-68h]@27
  DWORD v43; // [sp+4Ch] [bp-64h]@32
  int v44; // [sp+50h] [bp-60h]@32
  int v45; // [sp+54h] [bp-5Ch]@1
  int (__stdcall *v46)(HWND, int, int, const RECT *, const RECT *, HRGN, LPRECT, UINT); // [sp+58h] [bp-58h]@17
  HRGN hrgnUpdate; // [sp+5Ch] [bp-54h]@1
  int v48; // [sp+60h] [bp-50h]@62
  int v49; // [sp+64h] [bp-4Ch]@1
  int v50; // [sp+68h] [bp-48h]@62
  int v51; // [sp+6Ch] [bp-44h]@62
  int v52; // [sp+70h] [bp-40h]@62
  int v53; // [sp+74h] [bp-3Ch]@62
  int v54; // [sp+78h] [bp-38h]@62
  HRGN v55; // [sp+7Ch] [bp-34h]@32
  unsigned int v56; // [sp+80h] [bp-30h]@1
  int v57; // [sp+84h] [bp-2Ch]@1
  unsigned int v58; // [sp+88h] [bp-28h]@1
  unsigned int v59; // [sp+8Ch] [bp-24h]@1
  DWORD v60; // [sp+90h] [bp-20h]@1
  int v61; // [sp+94h] [bp-1Ch]@33
  unsigned int v62; // [sp+98h] [bp-18h]@1
  RECT *prcClip; // [sp+9Ch] [bp-14h]@1
  LPRECT lprc; // [sp+A0h] [bp-10h]@1
  int v65; // [sp+A4h] [bp-Ch]@37
  int v66; // [sp+A8h] [bp-8h]@1
  int v67; // [sp+ACh] [bp-4h]@1
  signed int dya; // [sp+B8h] [bp+8h]@1

  v49 = 0;
  v60 = 0;
  v1 = dy;
  v2 = *(_DWORD *)(dy + 36);
  dya = *(_DWORD *)(dy + 16);
  v3 = *(RECT **)(v1 + 24);
  v67 = v2;
  v4 = *(_DWORD *)(v1 + 44);
  prcClip = v3;
  v5 = *(HRGN *)(v1 + 28);
  v56 = v4;
  v6 = *(_DWORD *)(v1 + 48);
  v7 = *(_DWORD *)(v1 + 12);
  hrgnUpdate = v5;
  v8 = *(struct tagRECT **)(v1 + 32);
  v9 = *(_DWORD *)(v1 + 20);
  v58 = v6;
  v10 = *(_DWORD *)(v1 + 40);
  v66 = v7;
  v57 = v9;
  lprc = v8;
  v45 = 2;
  v62 = v10;
  v59 = 100;
  if ( !v8 )
    lprc = (LPRECT)&v33;
  SetRectEmpty(lprc);
  if ( *(_DWORD *)v1 != 56 )
    return 0;
  v11 = *(_DWORD *)(v1 + 4);
  v12 = *(_DWORD *)(v1 + 4) & 4;
  if ( !v12 || v56 == -1 )
    v56 = 8;
  if ( !v12 || v58 == -1 )
    v58 = 8;
  if ( !(v11 & 2) || v62 == -1 )
    v62 = (GetDoubleClickTime() >> 1) + 1;
  if ( v62 < 0x64 )
    v62 = 100;
  if ( !(v67 & 0x40000) && !*(_DWORD *)&g_fSmoothScroll )
    v67 |= 0x20000u;
  if ( !(*(_BYTE *)(v1 + 4) & 1)
    || (v13 = *(int (__stdcall **)(HWND, int, int, const RECT *, const RECT *, HRGN, LPRECT, UINT))(v1 + 52)) == 0 )
    v13 = ScrollWindowEx;
  v46 = v13;
  if ( v67 & 0x20000 )
    return v13(*(HWND *)(v1 + 8), v7, dya, (const RECT *)v9, prcClip, hrgnUpdate, lprc, (unsigned __int16)v67);
  if ( v9 )
  {
    v39 = *(_DWORD *)v9;
    v40 = *(_DWORD *)(v9 + 4);
    v41 = *(_DWORD *)(v9 + 8);
    v42 = *(_DWORD *)(v9 + 12);
    v7 = v66;
    v57 = (int)&v39;
  }
  if ( prcClip )
  {
    v34 = prcClip->left;
    v35 = prcClip->top;
    v36 = prcClip->right;
    v37 = prcClip->bottom;
    v7 = v66;
    prcClip = (RECT *)&v34;
  }
  v15 = hrgnUpdate;
  if ( !hrgnUpdate )
    v15 = CreateRectRgn(0, 0, 0, 0);
  v55 = v15;
  v43 = GetTickCount();
  v44 = v67 & 0x10000;
  if ( v67 & 0x10000 )
  {
    v61 = v56 * (2 * (v7 >= 0) - 1);
    v16 = v58 * (2 * (dya >= 0) - 1);
  }
  else
  {
    v17 = 100 * (v62 / ((GetDoubleClickTime() >> 1) + 1));
    v59 = v17;
    if ( !v17 )
    {
      v17 = 100;
      v59 = 100;
    }
    v61 = v7 / v17;
    v16 = dya / v17;
  }
  v65 = v16;
  if ( !v61 && v7 )
    v61 = 2 * (v7 >= 0) - 1;
  if ( !v65 && dya )
    v65 = 2 * (dya >= 0) - 1;
  while ( 1 )
  {
    if ( !v7 && !dya )
      goto LABEL_91;
    if ( !v44 )
    {
      v24 = v62 / v59;
      if ( !(v62 / v59) )
        v24 = 1;
      v25 = (GetTickCount() - v43) / v24;
      v26 = v25 - v49;
      v60 = v25 - v49;
      if ( ((v25 - v49) & 0x80000000) != 0 )
      {
        v26 = 0;
        v60 = 0;
      }
      v53 = v26 * v65;
      v51 = -(v26 * v65);
      v48 = v26 * v61;
      v52 = -v61;
      v54 = v49 + v26;
      v50 = -(v26 * v61);
      while ( 1 )
      {
        v48 += v61;
        v50 += v52;
        ++v60;
        ++v54;
        v53 += v65;
        v51 -= v65;
        if ( v54 > (signed int)v59 )
        {
          v19 = v66;
        }
        else
        {
          v19 = v48;
          v27 = v48;
          if ( v48 <= 0 )
            v27 = v50;
          v28 = v66;
          if ( v66 <= 0 )
            v28 = -v66;
          if ( v27 > v28 )
            v19 = v66;
          v22 = v53;
          v29 = v53;
          if ( v53 <= 0 )
            v29 = v51;
          v30 = dya;
          if ( dya <= 0 )
            v30 = -dya;
          if ( v29 <= v30 )
            goto LABEL_78;
        }
        v22 = dya;
LABEL_78:
        if ( v19 != v66 || v22 != dya )
        {
          v31 = v19;
          if ( v19 <= 0 )
            v31 = -v19;
          if ( v31 < v56 && v19 )
            continue;
          v32 = v22;
          if ( v22 <= 0 )
            v32 = -v22;
          if ( v32 < v58 && v22 )
            continue;
        }
        goto LABEL_88;
      }
    }
    v18 = v61;
    v19 = v61;
    if ( v61 <= 0 )
      v18 = -v61;
    v20 = v7;
    if ( v7 <= 0 )
      v20 = -v7;
    if ( v18 > v20 )
      v19 = v7;
    v21 = v65;
    v22 = v65;
    if ( v65 <= 0 )
      v21 = -v65;
    v23 = dya;
    if ( dya <= 0 )
      v23 = -dya;
    if ( v21 > v23 )
      v22 = dya;
LABEL_88:
    if ( !v46(*(HWND *)(v1 + 8), v19, v22, (const RECT *)v57, prcClip, v55, &rcSrc1, (unsigned __int16)v67) )
      break;
    RedrawWindow(*(HWND *)(v1 + 8), 0, v55, 0x205u);
    UnionRect(lprc, &rcSrc1, lprc);
    ScrollShrinkRect(v19, v22, v57);
    ScrollShrinkRect(v19, v22, (int)prcClip);
    v66 -= v19;
    dya -= v22;
    v49 += v60;
    v7 = v66;
  }
  v45 = 0;
LABEL_91:
  if ( v67 & 1 )
    RedrawWindow(*(HWND *)(v1 + 8), lprc, 0, 1u);
  if ( v55 != hrgnUpdate )
    DeleteObject(v55);
  return v45;
}

//----- (6F785A28) --------------------------------------------------------
int __stdcall TV_GetPrevVisItem(int a1)
{
  int result; // eax@1
  int v2; // ecx@7

  result = *(_DWORD *)(*(_DWORD *)a1 + 8);
  if ( result == a1 )
  {
    result = *(_BYTE *)(a1 + 30) != 0 ? *(_DWORD *)a1 : 0;
  }
  else
  {
    while ( *(_DWORD *)(result + 4) != a1 )
      result = *(_DWORD *)(result + 4);
    while ( 1 )
    {
      v2 = *(_DWORD *)(result + 8);
      if ( !v2 || !(*(_BYTE *)(result + 20) & 0x20) )
        break;
      do
      {
        result = v2;
        v2 = *(_DWORD *)(v2 + 4);
      }
      while ( v2 );
    }
  }
  return result;
}

//----- (6F785A50) --------------------------------------------------------
int __stdcall ITEM_OFFSET(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  int v4; // ecx@4

  v2 = *(_WORD *)(a1 + 188);
  result = *(_WORD *)(a1 + 184) + v2 * *(_BYTE *)(a2 + 30);
  if ( *(_DWORD *)(a1 + 88) && *(_WORD *)(a2 + 20) & 0xF000 )
    result += *(_DWORD *)(a1 + 100);
  if ( *(_DWORD *)(a1 + 84) )
    result += *(_WORD *)(a1 + 176);
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 & 4 )
  {
    if ( v4 & 3 )
      result += v2;
  }
  return result;
}

//----- (6F785AA7) --------------------------------------------------------
BOOL __stdcall TV_StartWatch(int a1, void *p, int a3)
{
  *((_DWORD *)p + 1) = 0;
  *(_DWORD *)p = a3;
  return DPA_InsertPtr(*(HDPA *)(a1 + 80), 0x7FFFFFFF, p) != -1;
}

//----- (6F785B22) --------------------------------------------------------
int __stdcall RefreshArrows(int a1, HDC hdc)
{
  int result; // eax@1
  struct tagRECT rcDst; // [sp+4h] [bp-30h]@4
  struct tagRECT rect; // [sp+14h] [bp-20h]@4
  struct tagRECT Rect; // [sp+24h] [bp-10h]@4

  result = *(_DWORD *)(a1 + 36);
  if ( result )
  {
    result = IsWindowVisible(*(HWND *)(a1 + 36));
    if ( result )
    {
      GetClipBox(hdc, &rect);
      GetWindowRect(*(HWND *)(a1 + 36), &Rect);
      MapWindowPoints(0, *(HWND *)a1, (LPPOINT)&Rect, 2u);
      result = IntersectRect(&rcDst, &rect, &Rect);
      if ( result )
        result = RedrawWindow(*(HWND *)(a1 + 36), 0, 0, 1u);
    }
  }
  return result;
}

//----- (6F785C69) --------------------------------------------------------
int __stdcall TreeView_EndFakeItemDraw(LPARAM lParam)
{
  int result; // eax@1
  int v2; // ecx@1

  result = lParam;
  v2 = *(_DWORD *)(lParam + 72);
  if ( !(v2 & 4) )
  {
    if ( v2 & 0x10 )
      result = CIFakeCustomDrawNotify(*(_DWORD *)(lParam + 60), 65538, lParam);
  }
  return result;
}

//----- (6F785C8B) --------------------------------------------------------
LONG __stdcall TV_GetItemTextWidth(HDC hdc, int a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+4h] [bp-240h]@1
  LPCWSTR lpString; // [sp+14h] [bp-230h]@1
  int v7; // [sp+18h] [bp-22Ch]@1
  struct tagSIZE sz; // [sp+30h] [bp-214h]@1
  char v9; // [sp+38h] [bp-20Ch]@1

  sz.cx = 0;
  sz.cy = 0;
  lpString = (LPCWSTR)&v9;
  v7 = 260;
  TV_GetItem(a2, a3, 1, (int)&v5);
  v3 = lstrlenW(lpString);
  GetTextExtentPointW(hdc, lpString, v3, &sz);
  return sz.cx + 2 * g_cxLabelMargin;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F785D3C) --------------------------------------------------------
int __stdcall TV_HorzScroll(int a1, int a2, int nPos)
{
  int v3; // eax@8
  int v4; // edi@9
  int v6; // eax@15

  TV_DismissEdit(a1, 0);
  if ( !a2 )
  {
    v3 = *(_WORD *)(a1 + 198) - 5;
    goto LABEL_9;
  }
  if ( a2 == 1 )
  {
    v6 = *(_WORD *)(a1 + 198);
    goto LABEL_17;
  }
  if ( a2 == 2 )
  {
    v6 = *(_WORD *)(a1 + 198) - *(_WORD *)(a1 + 190);
LABEL_17:
    v3 = v6 + 5;
    goto LABEL_9;
  }
  switch ( a2 )
  {
    case 3:
      v3 = *(_WORD *)(a1 + 198) + *(_WORD *)(a1 + 190) - 5;
      break;
    case 6:
      v3 = 0;
      break;
    case 7:
      v3 = *(_WORD *)(a1 + 194) - *(_WORD *)(a1 + 190);
      break;
    case 8:
      v3 = *(_WORD *)(a1 + 198);
      break;
    default:
      v3 = nPos;
      break;
  }
LABEL_9:
  v4 = TV_SetLeft(a1, v3);
  if ( v4 )
    UpdateWindow(*(HWND *)a1);
  return v4;
}

//----- (6F785DA7) --------------------------------------------------------
int __stdcall TV_DefCompare(LPCWSTR *a1, LPCWSTR *a2, int a3)
{
  return lstrcmpiW(*a1, *a2);
}

//----- (6F785DE5) --------------------------------------------------------
int __stdcall TV_ScrollVertIntoView(int a1, int a2)
{
  int v2; // edx@3
  int v3; // eax@4
  unsigned __int16 v4; // si@5
  int v5; // edx@6

  if ( !a2 )
    return 0;
  if ( !a1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 208);
  if ( !v2 )
    return 0;
  LOWORD(v3) = *(_WORD *)(a2 + 28);
  if ( (_WORD)v3 == -1 )
    return 0;
  v4 = *(_WORD *)(v2 + 28);
  v3 = (unsigned __int16)v3;
  if ( (unsigned __int16)v3 >= v4 )
  {
    v5 = *(_WORD *)(a1 + 196);
    if ( v3 < v5 + v4 )
      return 0;
    v3 = v3 - v5 + 1;
  }
  return TV_SmoothSetTopItem(a1, v3, 0);
}

//----- (6F785F62) --------------------------------------------------------
BOOL __stdcall ImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle)
{
  HIMAGELIST v6; // edi@1
  BOOL v7; // esi@1
  int v9; // [sp+8h] [bp-44h]@2
  HIMAGELIST Dst; // [sp+Ch] [bp-40h]@2
  int v11; // [sp+10h] [bp-3Ch]@2
  HDC v12; // [sp+14h] [bp-38h]@2
  int v13; // [sp+18h] [bp-34h]@2
  int v14; // [sp+1Ch] [bp-30h]@2
  int v15; // [sp+30h] [bp-1Ch]@2
  int v16; // [sp+34h] [bp-18h]@2
  UINT v17; // [sp+38h] [bp-14h]@2

  v6 = himl;
  v7 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    memset(&Dst, 0, 0x40u);
    v11 = i;
    v12 = hdcDst;
    v13 = x;
    v14 = y;
    v15 = -16777216;
    v16 = -16777216;
    v17 = fStyle;
    v9 = 68;
    Dst = v6;
    v7 = (*(int (__stdcall **)(HIMAGELIST, int *))(*(_DWORD *)himl + 32))(himl, &v9) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v7;
}

//----- (6F7869E6) --------------------------------------------------------
int __stdcall TV_ScrollBelow(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // ecx@3
  int v9; // eax@4
  int result; // eax@9
  int v11; // [sp+10h] [bp+Ch]@3

  v4 = a2;
  if ( *(_WORD *)(a2 + 28) == -1 )
  {
    result = 0;
  }
  else
  {
    v5 = *(_WORD *)(a2 + 32);
    if ( *(_BYTE *)(a1 + 36) & 0x10 )
    {
      v6 = *(_WORD *)(*(_DWORD *)(a1 + 208) + 28);
      v7 = TV_CountVisibleDescendants(a2);
      v11 = v7;
      if ( a4 )
      {
        v9 = v8 < 0;
        LOBYTE(v9) = v8 >= 0;
      }
      else
      {
        v9 = v8 + v7 >= 0;
      }
      if ( v9 )
        TV_ScrollItems(a1, v11, v8, a4);
      TV_InvalidateItem(a1, v4, 1u);
      if ( a3 )
        v5 = v11;
    }
    else if ( a3 )
    {
      v5 = TV_CountVisibleDescendants(a2);
    }
    result = v5;
  }
  return result;
}

//----- (6F786A7A) --------------------------------------------------------
void __stdcall TV_InvalidateItem(int a1, int a2, UINT flags)
{
  RECT rcUpdate; // [sp+0h] [bp-10h]@3

  if ( a2 && *(_BYTE *)(a1 + 36) & 0x10 )
  {
    if ( TV_GetItemRect(a1, a2, (int)&rcUpdate, 0) )
      RedrawWindow(*(HWND *)a1, &rcUpdate, 0, flags);
  }
}

//----- (6F786AC0) --------------------------------------------------------
signed int __stdcall TV_GetItemRect(int a1, int a2, int a3, int a4)
{
  unsigned __int16 v4; // ax@2
  int v5; // edi@3
  int v6; // eax@3
  signed int result; // eax@3

  if ( a2 && (v4 = *(_WORD *)(a2 + 28), v4 != -1) )
  {
    v5 = v4 - *(_WORD *)(*(_DWORD *)(a1 + 208) + 28);
    JUMPOUT(a4, 0, sub_6F78E7ED);
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 8) = *(_WORD *)(a1 + 190);
    v6 = v5 * *(_WORD *)(a1 + 182);
    *(_DWORD *)(a3 + 4) = v6;
    *(_DWORD *)(a3 + 12) = v6 + *(_WORD *)(a1 + 182) * *(_WORD *)(a2 + 32);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F786B4F) --------------------------------------------------------
int __stdcall TV_SortCB(int a1, LPARAM a2, int a3, int (__stdcall *a4)(void *p1, void *p2, LPARAM lParam))
{
  int v4; // esi@38
  int (__stdcall *v5)(void *, void *, LPARAM); // ecx@38
  int v6; // eax@38
  int v7; // edi@1
  int result; // eax@3
  int v9; // esi@4
  LONG v10; // esi@7
  LONG v11; // eax@10
  int v12; // eax@11
  PVOID v13; // eax@12
  void *v14; // eax@15
  HDPA v15; // edx@17
  int v16; // eax@17
  int (__stdcall *v17)(void *, void *, LPARAM); // ecx@17
  int v18; // edx@19
  int v19; // esi@24
  int v20; // eax@26
  int v21; // esi@29
  int v22; // esi@31
  int v23; // eax@53
  bool v24; // zf@56
  HWND v25; // ST04_4@58
  char v26; // [sp+8h] [bp-25Ch]@43
  struct tagSCROLLINFO v27; // [sp+18h] [bp-24Ch]@43
  LPARAM lParam; // [sp+34h] [bp-230h]@1
  RECT pitem; // [sp+38h] [bp-22Ch]@10
  HDPA hdpa; // [sp+48h] [bp-21Ch]@6
  HDSA hdsa; // [sp+4Ch] [bp-218h]@5
  int v32; // [sp+50h] [bp-214h]@1
  PFNDACOMPARE pfnCompare; // [sp+54h] [bp-210h]@1
  char v34; // [sp+58h] [bp-20Ch]@43

  v7 = *(_DWORD *)a2;
  lParam = a2;
  pfnCompare = a4;
  v32 = v7;
  if ( !v7 || v7 == -65536 )
  {
    v32 = *(_DWORD *)(a1 + 40);
    v7 = v32;
  }
  result = ValidateTreeItem(v7, 0);
  if ( result )
  {
    result = TV_CountKids(v7);
    v9 = result;
    if ( result )
    {
      hdsa = DSA_Create(12, result);
      if ( hdsa )
      {
        hdpa = DPA_Create(v9);
        if ( hdpa )
        {
          v10 = *(_DWORD *)(v7 + 8);
          if ( v10 )
          {
            while ( 1 )
            {
              if ( pfnCompare || *(_DWORD *)(v10 + 12) != -1 )
              {
                v11 = *(_DWORD *)(v10 + 12);
                pitem.right = 0;
                pitem.top = v11;
              }
              else
              {
                v27.cbSize = (UINT)&v34;
                v27.fMask = 260;
                TV_GetItem(a1, v10, 1, (int)&v26);
                pitem.top = 0;
                pitem.right = 1;
                Str_Set((int)&pitem.top, (LPCWSTR)v27.cbSize);
                if ( !pitem.top )
                  goto LABEL_42;
              }
              pitem.bottom = v10;
              v12 = DSA_InsertItem(hdsa, 0x7FFFFFFF, &pitem.top);
              if ( v12 < 0 )
                break;
              v13 = DSA_GetItemPtr(hdsa, v12);
              if ( DPA_InsertPtr(hdpa, 0x7FFFFFFF, v13) < 0 )
                goto LABEL_42;
              v10 = *(_DWORD *)(v10 + 4);
              if ( !v10 )
              {
                v7 = v32;
                goto LABEL_15;
              }
            }
            if ( pitem.right )
              Str_Set((int)&pitem.top, 0);
LABEL_42:
            v7 = v32;
          }
          else
          {
LABEL_15:
            v14 = pfnCompare;
            if ( !pfnCompare )
              v14 = TV_DefCompare;
            DPA_Sort(hdpa, (PFNDACOMPARE)v14, lParam);
            v15 = hdpa;
            v16 = *((_DWORD *)hdpa + 1);
            v17 = *(int (__stdcall **)(void *, void *, LPARAM))(*(_DWORD *)v16 + 8);
            if ( *(int (__stdcall **)(void *, void *, LPARAM))(v7 + 8) == v17 )
            {
              pfnCompare = 0;
            }
            else
            {
              *(_DWORD *)(v7 + 8) = v17;
              pfnCompare = v17;
            }
            v18 = *(_DWORD *)v15;
            while ( 1 )
            {
              --v18;
              if ( v18 <= 0 )
                break;
              v4 = v16 + 4;
              v5 = *(int (__stdcall **)(void *, void *, LPARAM))(*(_DWORD *)(v16 + 4) + 8);
              v6 = *(_DWORD *)(*(_DWORD *)v16 + 8);
              if ( *(int (__stdcall **)(void *, void *, LPARAM))(v6 + 4) != v5 )
              {
                v7 = v32;
                if ( !pfnCompare )
                  pfnCompare = v5;
              }
              *(_DWORD *)(v6 + 4) = v5;
              v16 = v4;
            }
            *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v16 + 8) + 4) = 0;
            TV_UpdateShownIndexes(a1, v7);
            if ( *(_DWORD *)lParam == -65536 && *(_DWORD *)(a1 + 200) < (unsigned int)*(_WORD *)(a1 + 196) )
              *(_DWORD *)(a1 + 208) = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8);
            if ( pfnCompare && *(_BYTE *)(v7 + 20) & 0x20 )
            {
              TV_GetItemRect(a1, (int)pfnCompare, (int)&pitem, 0);
              v23 = *(_DWORD *)(v7 + 4);
              if ( v23 )
                TV_GetItemRect(a1, v23, (int)&v27.nMax, 0);
              else
                GetClientRect(*(HWND *)a1, (LPRECT)&v27.nMax);
              v24 = (*(_BYTE *)(a1 + 36) & 0x10) == 0;
              pitem.bottom = v27.nTrackPos;
              if ( !v24 )
                InvalidateRect(*(HWND *)a1, &pitem, 1);
            }
          }
          DPA_Destroy(hdpa);
        }
        v19 = *(_DWORD *)hdsa;
        while ( 1 )
        {
          --v19;
          if ( v19 < 0 )
            break;
          v20 = (int)DSA_GetItemPtr(hdsa, v19);
          if ( *(_DWORD *)(v20 + 4) )
            Str_Set(v20, 0);
        }
        DSA_Destroy(hdsa);
      }
      v21 = 0;
      if ( GetWindowLongW(*(HWND *)a1, -16) & 0x200000 )
      {
        v25 = *(HWND *)a1;
        v27.cbSize = 28;
        v27.fMask = 4;
        if ( GetScrollInfo(v25, 1, &v27) )
          v21 = v27.nPos;
      }
      if ( TV_SmoothSetTopItem(a1, v21, 0) )
        UpdateWindow(*(HWND *)a1);
      v22 = *(_DWORD *)(a1 + 44);
      if ( v22 )
      {
        do
        {
          v22 = *(_DWORD *)v22;
          if ( v7 == v22 )
            TV_EnsureVisible(a1, *(_DWORD *)(a1 + 44));
        }
        while ( v22 && v22 != *(_DWORD *)(a1 + 40) );
      }
      MyNotifyWinEvent(32772, *(_DWORD *)a1, -4, 0);
      result = 1;
    }
  }
  return result;
}

//----- (6F786D7C) --------------------------------------------------------
int __stdcall TV_EnsureVisible(int a1, signed int a2)
{
  TV_ExpandParents(a1, a2, 1);
  return TV_ScrollIntoView(a1, a2);
}

//----- (6F786D94) --------------------------------------------------------
int __stdcall TV_ScrollIntoView(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // eax@2
  int v5; // edx@2
  int v6; // ecx@3
  int v8; // [sp+18h] [bp+Ch]@1

  v2 = a2;
  v8 = TV_ScrollVertIntoView(a1, a2);
  v3 = *(_DWORD *)(a1 + 100) + *(_WORD *)(v2 + 26) + *(_WORD *)(a1 + 176);
  if ( v3 > (unsigned int)*(_WORD *)(a1 + 190) )
    v3 = *(_WORD *)(a1 + 190);
  v4 = ITEM_OFFSET(a1, v2);
  v5 = *(_WORD *)(a1 + 198);
  if ( v4 < v5 )
    goto LABEL_6;
  v6 = *(_WORD *)(a1 + 190);
  if ( v4 + v3 > (unsigned int)(v6 + v5) )
  {
    v4 = v3 + v4 - v6;
LABEL_6:
    v8 |= TV_SetLeft(a1, v4);
  }
  return v8;
}

//----- (6F786E0C) --------------------------------------------------------
int __stdcall TV_CountKids(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 + 8);
  result = 0;
  while ( v1 )
  {
    v1 = *(_DWORD *)(v1 + 4);
    ++result;
  }
  return result;
}

//----- (6F786E34) --------------------------------------------------------
int __stdcall TV_GetNextVisItem(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = a1;
  result = *(_DWORD *)(a1 + 8);
  if ( !result || !(*(_BYTE *)(a1 + 20) & 0x20) )
  {
    while ( !*(_DWORD *)(v1 + 4) )
    {
      v1 = *(_DWORD *)v1;
      if ( !v1 )
        return 0;
    }
    result = *(_DWORD *)(v1 + 4);
  }
  return result;
}

//----- (6F786E5F) --------------------------------------------------------
signed int __stdcall TV_IsShowing(int a1)
{
  int v1; // eax@1

  v1 = a1;
  while ( 1 )
  {
    v1 = *(_DWORD *)v1;
    if ( !v1 )
      break;
    if ( !(*(_BYTE *)(v1 + 20) & 0x20) )
      return 0;
  }
  return 1;
}

//----- (6F786EBA) --------------------------------------------------------
int __stdcall TV_DrawItem(int a1, int a2, int a3, int a4, int y, int a6)
{
  int v6; // eax@1
  bool v7; // zf@1
  LONG v8; // ecx@3
  LONG v9; // eax@3
  int v10; // ecx@7
  int v11; // edi@7
  DWORD v12; // eax@8
  COLORREF v13; // eax@11
  void *v14; // eax@16
  int result; // eax@22
  int v16; // eax@29
  int v17; // edi@31
  int v18; // ecx@32
  int v19; // esi@32
  int v20; // edi@32
  struct _IMAGELIST *v21; // eax@36
  int v22; // ecx@37
  int v23; // esi@40
  int v24; // ecx@41
  int v25; // edx@41
  signed int v26; // edx@43
  int v27; // eax@47
  int v28; // esi@47
  int v29; // eax@49
  int v30; // edx@49
  LONG v31; // ecx@49
  LONG v32; // edx@49
  __int64 v33; // rax@51
  int v34; // edi@57
  int v35; // ecx@57
  int v36; // esi@59
  int v37; // ecx@62
  int v38; // edx@71
  int v39; // ecx@74
  COLORREF v40; // eax@114
  int v41; // eax@119
  int v42; // esi@121
  int v43; // eax@121
  int v44; // ecx@123
  signed int v45; // ecx@139
  int v46; // eax@143
  int v47; // ecx@151
  int v48; // eax@153
  int v49; // edi@162
  int v50; // ecx@162
  int v51; // edx@164
  signed int v52; // [sp-4h] [bp-2D8h]@90
  signed int v53; // [sp-4h] [bp-2D8h]@146
  HGDIOBJ h; // [sp+Ch] [bp-2C8h]@17
  COLORREF v55; // [sp+10h] [bp-2C4h]@14
  COLORREF v56; // [sp+14h] [bp-2C0h]@14
  LPARAM lParam; // [sp+18h] [bp-2BCh]@22
  HDC v58; // [sp+28h] [bp-2ACh]@17
  RECT v59; // [sp+2Ch] [bp-2A8h]@17
  int v60; // [sp+3Ch] [bp-298h]@17
  int v61; // [sp+40h] [bp-294h]@17
  int v62; // [sp+44h] [bp-290h]@22
  COLORREF v63; // [sp+48h] [bp-28Ch]@13
  COLORREF color; // [sp+4Ch] [bp-288h]@10
  int v65; // [sp+50h] [bp-284h]@18
  char v66; // [sp+54h] [bp-280h]@4
  char v67[4]; // [sp+5Ch] [bp-278h]@15
  int v68; // [sp+60h] [bp-274h]@4
  LPCWSTR lpString; // [sp+64h] [bp-270h]@4
  int v70; // [sp+68h] [bp-26Ch]@4
  int v71; // [sp+6Ch] [bp-268h]@38
  int v72; // [sp+70h] [bp-264h]@37
  int v73; // [sp+74h] [bp-260h]@59
  int v74; // [sp+78h] [bp-25Ch]@22
  int v75; // [sp+80h] [bp-254h]@1
  RECT rect; // [sp+84h] [bp-250h]@3
  COLORREF v77; // [sp+94h] [bp-240h]@1
  int v78; // [sp+98h] [bp-23Ch]@1
  int v79; // [sp+9Ch] [bp-238h]@17
  DWORD v80; // [sp+A0h] [bp-234h]@22
  int v81; // [sp+A4h] [bp-230h]@2
  int i; // [sp+A8h] [bp-22Ch]@3
  COLORREF rgbFg; // [sp+ACh] [bp-228h]@13
  UINT options; // [sp+B0h] [bp-224h]@1
  int v85; // [sp+B4h] [bp-220h]@10
  COLORREF rgbBk; // [sp+B8h] [bp-21Ch]@13
  int v87; // [sp+BCh] [bp-218h]@1
  int wDest; // [sp+C0h] [bp-214h]@1
  HDC hdc; // [sp+C4h] [bp-210h]@1
  char v90; // [sp+C8h] [bp-20Ch]@4
  int ya; // [sp+2ECh] [bp+18h]@32

  hdc = (HDC)a3;
  v6 = *(_WORD *)(a1 + 188);
  v7 = (*(_BYTE *)(a1 + 36) & 4) == 0;
  v87 = a2;
  wDest = v6;
  v77 = -16777216;
  v75 = a2;
  options = 6;
  v78 = 0;
  if ( v7 || (v81 = 1, a2 != *(_DWORD *)(a1 + 44)) )
    v81 = 0;
  v8 = y + *(_WORD *)(a2 + 32) * *(_WORD *)(a1 + 182);
  rect.top = y;
  v9 = *(_WORD *)(a1 + 190);
  i = 0;
  rect.bottom = v8;
  rect.left = 0;
  rect.right = v9;
  if ( a6 & 8 )
    FillRect(hdc, &rect, *(HBRUSH *)(a1 + 112));
  lpString = (LPCWSTR)&v90;
  *(_DWORD *)(a1 + 144) = a2;
  v70 = 260;
  v68 = 3860;
  TV_GetItem(a1, a2, 111, (int)&v66);
  *(_DWORD *)(a1 + 144) = 0;
  if ( TV_ShouldItemDrawBlue(a1, (int)&v66, a6) )
    goto LABEL_90;
  if ( a6 & 0x20 )
  {
    v10 = 15;
    v52 = 17;
    goto LABEL_98;
  }
  if ( TV_ShouldItemDrawGray(a1, (int)&v66, a6) )
  {
    v80 = GetSysColor(15);
    if ( GetSysColor(5) != v80 )
    {
      v10 = 15;
      v52 = 18;
      goto LABEL_98;
    }
LABEL_90:
    v10 = 13;
    v52 = 14;
LABEL_98:
    v11 = v52;
LABEL_9:
    v12 = GetSysColor(v10);
    goto LABEL_10;
  }
  v10 = 5;
  v11 = 8;
  if ( a2 == *(_DWORD *)(a1 + 60) )
    v11 = 26;
  v12 = *(_DWORD *)(a1 + 164);
  if ( v12 == -1 )
    goto LABEL_9;
LABEL_10:
  color = v12;
  v85 = v12;
  if ( v11 != 8 || (v13 = *(_DWORD *)(a1 + 160), v13 == -1) )
    v13 = GetSysColor(v11);
  v63 = v13;
  rgbFg = v13;
  rgbBk = a6 & 4;
  if ( a6 & 4 )
  {
    rgbFg = 0;
    v63 = 0;
    options = 0;
  }
  v56 = SetBkColor(hdc, color);
  v55 = SetTextColor(hdc, v63);
  if ( *(_BYTE *)(a1 + 8) & 0x40 )
    options |= 0x80u;
  if ( v67[0] & 0x10 )
  {
    v14 = *(void **)(a1 + 124);
    if ( a2 != *(_DWORD *)(a1 + 60) )
      goto LABEL_17;
    v39 = a1 + 128;
  }
  else
  {
    v14 = *(void **)(a1 + 116);
    if ( a2 != *(_DWORD *)(a1 + 60) )
      goto LABEL_17;
    v39 = a1 + 120;
  }
  v14 = (void *)CCGetHotFont(v14, v39);
LABEL_17:
  v61 = 0;
  v58 = hdc;
  h = SelectObject(hdc, v14);
  v60 = v87;
  v59 = rect;
  v79 = a6 & 2;
  if ( a6 & 2 )
    v65 = 0;
  else
    v65 = *(_BYTE *)(v87 + 30);
  if ( v67[0] & 2 )
  {
    v7 = (*(_BYTE *)(a1 + 36) & 4) == 0;
    i = 1;
    if ( !v7 || *(_BYTE *)(a1 + 8) & 0x20 )
      v61 = 1;
  }
  if ( v81 )
    v61 |= 0x10u;
  if ( v87 == *(_DWORD *)(a1 + 60) )
    v61 |= 0x40u;
  v62 = v74;
  result = CICustomDrawNotify(a1, 65537, (LPARAM)&lParam);
  v80 = result;
  if ( !(result & 4) )
  {
    v81 = v61 & 0x10;
    if ( v61 & 1 )
      *(_DWORD *)v67 |= 2u;
    else
      *(_DWORD *)v67 &= 0xFFFFFFFD;
    if ( color != v85 )
      SetBkColor(hdc, color);
    if ( v63 != rgbFg )
      SetTextColor(hdc, v63);
    if ( *(_DWORD *)(a1 + 8) & 0x1000 && !rgbBk )
    {
      v40 = GetBkColor(hdc);
      FillRectClr(hdc, &v59, v40);
      options |= 2u;
      v77 = -1;
    }
    if ( !v79 && (v16 = *(_DWORD *)(a1 + 8), v16 & 3) && v16 & 4 )
      v17 = wDest + a4;
    else
      v17 = a4;
    v18 = *(_WORD *)(a1 + 184);
    v19 = *(_WORD *)(a1 + 186);
    ya = v19 + y;
    v20 = v18 + wDest * v65 + v17;
    if ( !v79 && !(v80 & 0x10000) || a6 & 0x40 )
    {
      rgbFg = -16777216;
      rgbBk = v77;
      if ( a6 & 0x80 )
        rgbBk = -1;
      if ( *(_DWORD *)(a1 + 88) )
      {
        v78 = (unsigned __int16)(*(_WORD *)v67 >> 12);
        if ( *(_WORD *)v67 >> 12 )
        {
          v41 = *(_WORD *)(a1 + 194) - v18 - v20;
          v85 = *(_DWORD *)(a1 + 100);
          if ( v85 >= v41 )
            v85 = v41;
          v42 = *(_WORD *)(a1 + 182) - 2 * v19;
          v43 = *(_DWORD *)(a1 + 104);
          if ( v43 < v42 )
            v42 = *(_DWORD *)(a1 + 104);
          v44 = *(_WORD *)(a1 + 182) - v43;
          if ( v44 <= 0 )
            v44 = 0;
          ImageList_DrawEx(*(HIMAGELIST *)(a1 + 88), v78, hdc, v20, ya + v44, v85, v42, v77, 0xFF000000, 0);
          v20 += *(_DWORD *)(a1 + 100);
        }
      }
      v21 = *(struct _IMAGELIST **)(a1 + 84);
      if ( v21 )
      {
        v85 = 0;
        v22 = v72;
        if ( !i )
          v22 = v71;
        i = v22;
        if ( v67[0] & 4 )
        {
          v85 = 4;
          rgbFg = ImageList_GetBkColor(v21);
        }
        v23 = *(_WORD *)(a1 + 176) - 3;
        if ( v23 >= *(_WORD *)(a1 + 194) - (signed int)*(_WORD *)(a1 + 184) - v20 )
          v23 = *(_WORD *)(a1 + 194) - *(_WORD *)(a1 + 184) - v20;
        v24 = *(_WORD *)(a1 + 182) - 2 * *(_WORD *)(a1 + 186);
        v25 = *(_WORD *)(a1 + 178);
        if ( v25 < v24 )
          v24 = *(_WORD *)(a1 + 178);
        if ( *(_WORD *)(a1 + 182) - v25 > 0 )
          v26 = *(_WORD *)(a1 + 182) - v25;
        else
          v26 = 0;
        ImageList_DrawEx(
          *(HIMAGELIST *)(a1 + 84),
          i,
          hdc,
          v20,
          ya + v26 / 2,
          v23,
          v24,
          rgbBk,
          rgbFg,
          v85 | *(_WORD *)v67 & 0xF00);
      }
    }
    if ( *(_DWORD *)(a1 + 84) )
      v20 += *(_WORD *)(a1 + 176);
    v27 = lstrlenW(lpString);
    v28 = v87;
    v7 = *(_WORD *)(v87 + 26) == 0;
    rgbBk = v27;
    if ( v7 || *(_DWORD *)(v87 + 12) == -1 )
      TV_ComputeItemWidth(a1, v87, hdc);
    v29 = *(_WORD *)(a1 + 186);
    v30 = *(_WORD *)(a1 + 184);
    rect.top = v29 + ya;
    v31 = *(_WORD *)(a1 + 194) - v30;
    v32 = v20 + *(_WORD *)(v28 + 26);
    rect.left = v20;
    rect.right = v32;
    if ( v32 >= v31 )
      rect.right = v31;
    rect.bottom -= v29;
    if ( *(_DWORD *)(a1 + 56) != v28 || !IsWindow(*(HWND *)(a1 + 216)) || !IsWindowVisible(*(HWND *)(a1 + 216)) )
    {
      v33 = *(_WORD *)(a1 + 182) - (signed int)*(_WORD *)(a1 + 180);
      ExtTextOutW(
        hdc,
        v20 + g_cxLabelMargin,
        ya + g_cyBorder + (((signed int)v33 - HIDWORD(v33)) >> 1),
        options,
        &rect,
        lpString,
        rgbBk,
        0);
      if ( *(_BYTE *)(a1 + 36) & 4 )
      {
        if ( v81 && !(*(_DWORD *)(a1 + 8) & 0x1000) && !(a6 & 0x24) && !(CCGetUIState(a1) & 1) )
          DrawFocusRect(hdc, &rect);
      }
    }
    SetBkColor(hdc, v56);
    SetTextColor(hdc, v55);
    result = (int)SelectObject(hdc, h);
    if ( v79 )
      goto LABEL_69;
    if ( *(_DWORD *)(a1 + 84) )
      v20 -= *(_WORD *)(a1 + 176);
    if ( v78 )
      v20 -= *(_DWORD *)(a1 + 100);
    result = *(_DWORD *)(a1 + 8);
    if ( !(result & 2) )
    {
      if ( result & 1 && (v65 || result & 4) && v73 )
      {
        v49 = v20 - wDest;
        v50 = *(_WORD *)(a1 + 194) - *(_WORD *)(a1 + 184) - v49;
        result = (v67[0] & 0x20) != 0 ? wDest : 0;
        if ( wDest < v50 )
          v50 = wDest;
        v51 = *(_WORD *)(a1 + 192) - *(_WORD *)(a1 + 186) - ya;
        if ( *(_WORD *)(a1 + 182) < v51 )
          v51 = *(_WORD *)(a1 + 182);
        if ( v50 > 0 && v51 > 0 )
          result = BitBlt(hdc, v49, ya, v50, v51, *(HDC *)(a1 + 140), (v67[0] & 0x20) != 0 ? wDest : 0, 0, 0xCC0020u);
      }
      goto LABEL_69;
    }
    v34 = v20 - wDest;
    v35 = v65--;
    if ( !v35 && !(result & 4) )
    {
LABEL_69:
      if ( v80 & 0x10 )
      {
        v60 = v75;
        result = CICustomDrawNotify(a1, 65538, (LPARAM)&lParam);
      }
      return result;
    }
    if ( v65 != -1 || v28 != *(_DWORD *)(*(_DWORD *)v28 + 8) )
    {
      v36 = (*(_DWORD *)(v28 + 4) == 0) + 1;
      if ( v73 )
      {
        if ( result & 1 )
        {
          v36 += 2;
          if ( (v67[0] & 0xA0) == 32 )
            v36 += 2;
        }
      }
      goto LABEL_60;
    }
    if ( *(_DWORD *)(v28 + 4) )
    {
      v45 = 2;
      if ( v73 )
      {
        if ( result & 1 )
        {
          v45 = 4;
          if ( (v67[0] & 0xA0) == 32 )
            v45 = 6;
        }
      }
      v46 = *(_WORD *)(a1 + 194) - *(_WORD *)(a1 + 184) - v34;
      rgbBk = wDest;
      if ( wDest >= v46 )
        rgbBk = v46;
      StretchBlt(
        hdc,
        v34,
        ya + *(_WORD *)(a1 + 182),
        wDest,
        -*(_WORD *)(a1 + 182),
        *(HDC *)(a1 + 140),
        wDest * v45,
        0,
        rgbBk,
        *(_WORD *)(a1 + 182) - 2 * *(_WORD *)(a1 + 186),
        0xCC0020u);
      v36 = -1;
      goto LABEL_60;
    }
    if ( result & 1 )
    {
      if ( v73 )
      {
        v36 = ((v67[0] & 0xA0) == 32) + 8;
LABEL_60:
        result = v87;
        if ( *(_WORD *)(v87 + 32) > 1u )
          result = TV_DrawKinDescender(a1, hdc, v34, ya, v87, v67[0]);
        if ( v36 != -1 )
        {
          v37 = wDest;
          if ( wDest >= *(_WORD *)(a1 + 194) - (signed int)*(_WORD *)(a1 + 184) - v34 )
            v37 = *(_WORD *)(a1 + 194) - *(_WORD *)(a1 + 184) - v34;
          result = *(_WORD *)(a1 + 182) - 2 * *(_WORD *)(a1 + 186);
          if ( v37 > 0 && result > 0 )
            result = BitBlt(hdc, v34, ya, v37, result, *(HDC *)(a1 + 140), wDest * v36, 0, 0xCC0020u);
        }
        while ( 1 )
        {
          --v65;
          if ( v65 < 0 && (!(*(_BYTE *)(a1 + 8) & 4) || v65 < -1) )
            break;
          result = *(_DWORD *)v87;
          v38 = wDest;
          v34 -= wDest;
          v7 = *(_DWORD *)(*(_DWORD *)v87 + 4) == 0;
          v87 = *(_DWORD *)v87;
          if ( !v7 )
          {
            v47 = *(_WORD *)(a1 + 184);
            if ( wDest >= *(_WORD *)(a1 + 194) - v47 - v34 )
              v38 = *(_WORD *)(a1 + 194) - v47 - v34;
            v48 = *(_WORD *)(a1 + 192) - *(_WORD *)(a1 + 186) - ya;
            if ( *(_WORD *)(a1 + 182) < v48 )
              v48 = *(_WORD *)(a1 + 182);
            if ( v38 > 0 && v48 > 0 )
              BitBlt(hdc, v34, ya, v38, v48, *(HDC *)(a1 + 140), 0, 0, 0xCC0020u);
            result = TV_DrawDescender(a1, hdc, v34, ya, v75);
          }
        }
        goto LABEL_69;
      }
      v53 = 7;
    }
    else
    {
      v53 = 3;
    }
    v36 = v53;
    goto LABEL_60;
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7876C3) --------------------------------------------------------
LPCSTR __stdcall TV_InsertItemA(LRESULT a1, int a2)
{
  int v2; // edi@1
  int v3; // ebx@4
  LPCSTR result; // eax@5
  int v5; // eax@7

  v2 = 0;
  if ( a2
    && a2 != -1
    && *(_BYTE *)(a2 + 8) & 1
    && (v5 = *(_DWORD *)(a2 + 24)) != 0
    && v5 != -1
    && (v2 = *(_DWORD *)(a2 + 24),
        result = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a2 + 24)),
        (*(_DWORD *)(a2 + 24) = result) == 0) )
  {
    *(_DWORD *)(a2 + 24) = v2;
  }
  else
  {
    v3 = TV_InsertItem(a1, a2);
    if ( v2 )
    {
      FreeProducedString(*(HLOCAL *)(a2 + 24));
      *(_DWORD *)(a2 + 24) = v2;
    }
    result = (LPCSTR)v3;
  }
  return result;
}

//----- (6F787705) --------------------------------------------------------
int __stdcall TreeView_BeginFakeItemDraw(LPARAM lParam, int a2)
{
  int v2; // edi@1

  *(_DWORD *)(lParam + 36) = a2;
  *(_DWORD *)(lParam + 44) = *(_DWORD *)(a2 + 16);
  v2 = *(_DWORD *)(lParam + 60);
  if ( *(_BYTE *)(a2 + 20) & 0x10 )
    SelectObject(*(HDC *)(lParam + 16), *(HGDIOBJ *)(v2 + 124));
  else
    SelectObject(*(HDC *)(lParam + 16), *(HGDIOBJ *)(v2 + 116));
  if ( *(_BYTE *)(v2 + 12) & 4 )
  {
    *(_DWORD *)(lParam + 72) = 0;
  }
  else
  {
    *(_DWORD *)(lParam + 48) = *(_DWORD *)(v2 + 160);
    *(_DWORD *)(lParam + 52) = *(_DWORD *)(v2 + 164);
    *(_DWORD *)(lParam + 56) = *(_BYTE *)(a2 + 30);
    *(_DWORD *)(lParam + 72) = CIFakeCustomDrawNotify(v2, 65537, lParam);
  }
  return *(_DWORD *)(lParam + 72);
}

//----- (6F787783) --------------------------------------------------------
signed int __stdcall TV_UpdateShownIndexes(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@1
  unsigned __int16 v4; // si@4
  signed int result; // eax@6

  v2 = *(_DWORD *)(a1 + 40);
  v3 = a2;
  if ( a2 == v2 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ( !v3 )
      return -1;
    *(_WORD *)(v3 + 28) = 0;
  }
  v4 = *(_WORD *)(v3 + 28) + *(_WORD *)(v3 + 32);
  if ( v4 )
  {
    while ( 1 )
    {
      v3 = TV_GetNextVisItem(v3);
      if ( !v3 )
        break;
      *(_WORD *)(v3 + 28) = v4;
      v4 += *(_WORD *)(v3 + 32);
    }
    result = v4;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7877DA) --------------------------------------------------------
signed int __stdcall TV_ScrollBarsAfterAdd(int a1, int a2)
{
  signed int result; // eax@2
  int v3; // eax@4
  __int16 v4; // cx@5

  if ( TV_IsShowing(a2) )
  {
    v3 = TV_GetPrevVisItem(a2);
    if ( v3 )
      v4 = *(_WORD *)(v3 + 28) + *(_WORD *)(v3 + 32);
    else
      v4 = 0;
    *(_WORD *)(a2 + 28) = v4;
    TV_UpdateShownIndexes(a1, a2);
    *(_DWORD *)(a1 + 200) += *(_WORD *)(a2 + 32);
    TV_ComputeItemWidth(a1, a2, 0);
    TV_CalcScrollBars(a1);
    result = 1;
  }
  else
  {
    *(_WORD *)(a2 + 28) = -1;
    result = 0;
  }
  return result;
}

//----- (6F787840) --------------------------------------------------------
__int16 __stdcall TV_ComputeItemWidth(int a1, int a2, HDC a3)
{
  int v3; // ebx@1
  int v4; // eax@3
  LPARAM lParam; // [sp+Ch] [bp-4Ch]@2
  HDC hdc; // [sp+1Ch] [bp-3Ch]@3

  v3 = *(_WORD *)(a2 + 26);
  if ( a3 )
  {
    hdc = a3;
  }
  else
  {
    TreeView_BeginFakeCustomDraw(a1, (LPARAM)&lParam);
    TreeView_BeginFakeItemDraw((LPARAM)&lParam, a2);
  }
  LOWORD(v4) = TV_GetItemTextWidth(hdc, a1, a2);
  *(_WORD *)(a2 + 26) = v4;
  if ( !(*(_DWORD *)(a1 + 8) & 0x2000) && v3 != (unsigned __int16)v4 )
  {
    v4 = *(_WORD *)(a2 + 26) + ITEM_OFFSET(a1, a2);
    if ( *(_WORD *)(a1 + 194) < v4 )
    {
      PostMessageW(*(HWND *)a1, 0x2100u, 0, 0);
      LOWORD(v4) = *(_WORD *)(a2 + 26) + ITEM_OFFSET(a1, a2);
      *(_WORD *)(a1 + 194) = v4;
    }
  }
  if ( !a3 )
  {
    TreeView_EndFakeItemDraw((LPARAM)&lParam);
    LOWORD(v4) = TreeView_EndFakeCustomDraw((LPARAM)&lParam);
  }
  return v4;
}

//----- (6F787904) --------------------------------------------------------
void __stdcall TV_Paint(int y, HDC hdc)
{
  struct tagPAINTSTRUCT Paint; // [sp+8h] [bp-44h]@2

  if ( hdc )
  {
    SetRect(&Paint.rcPaint, 0, 0, *(_WORD *)(y + 190), *(_WORD *)(y + 192));
    TV_DrawTree(y, hdc, 1, (int)&Paint.rcPaint);
  }
  else
  {
    BeginPaint(*(HWND *)y, &Paint);
    TV_DrawTree(y, Paint.hdc, Paint.fErase, (int)&Paint.rcPaint);
    EndPaint(*(HWND *)y, &Paint);
  }
}

//----- (6F787963) --------------------------------------------------------
void __stdcall TV_DrawTree(int y, HDC hdc, int a3, int a4)
{
  int v4; // ebx@1
  signed int v5; // eax@3
  int v6; // eax@4
  unsigned int v7; // eax@6
  HGDIOBJ v8; // edi@7
  int i; // esi@8
  int v10; // edi@13
  int v11; // eax@28
  COLORREF v12; // eax@30
  LPARAM lParam; // [sp+4h] [bp-58h]@6
  HDC v14; // [sp+14h] [bp-48h]@6
  LONG v15; // [sp+18h] [bp-44h]@6
  int v16; // [sp+1Ch] [bp-40h]@6
  int v17; // [sp+20h] [bp-3Ch]@6
  int v18; // [sp+24h] [bp-38h]@6
  int v19; // [sp+2Ch] [bp-30h]@6
  int v20; // [sp+30h] [bp-2Ch]@6
  int v21; // [sp+34h] [bp-28h]@17
  RECT rc; // [sp+44h] [bp-18h]@3
  int v23; // [sp+54h] [bp-8h]@3
  HGDIOBJ h; // [sp+58h] [bp-4h]@3
  int ya; // [sp+64h] [bp+8h]@5
  int yb; // [sp+64h] [bp+8h]@8

  v4 = y;
  if ( *(_BYTE *)(y + 36) & 0x10 )
  {
    if ( *(_DWORD *)(y + 8) & 0x100 && !*(_DWORD *)(y + 88) )
      TV_InitCheckBoxes((HDC)y);
    v23 = -*(_WORD *)(y + 198);
    TV_GetBackgroundBrush(y, (WPARAM)hdc);
    v5 = *(_DWORD *)(a4 + 4);
    rc.left = *(_DWORD *)a4;
    rc.top = *(_DWORD *)(a4 + 4);
    rc.right = *(_DWORD *)(a4 + 8);
    rc.bottom = *(_DWORD *)(a4 + 12);
    h = (HGDIOBJ)(v5 / *(_WORD *)(y + 182));
    if ( *(_DWORD *)(y + 204) && (v6 = *(_DWORD *)(y + 208)) != 0 )
      ya = *(_DWORD *)(y + 200) - *(_WORD *)(v6 + 28);
    else
      ya = 0;
    v14 = hdc;
    v19 = 0;
    v20 = 0;
    v15 = *(_DWORD *)a4;
    v16 = *(_DWORD *)(a4 + 4);
    v17 = *(_DWORD *)(a4 + 8);
    v18 = *(_DWORD *)(a4 + 12);
    v7 = CICustomDrawNotify(v4, 1, (LPARAM)&lParam);
    *(_DWORD *)(v4 + 12) = v7;
    if ( !(v7 & 4) )
    {
      v8 = h;
      if ( (signed int)h < ya )
      {
        yb = 0;
        for ( i = *(_DWORD *)(v4 + 208); i && (signed int)v8 > *(_WORD *)(i + 32); i = TV_GetNextVisItem(i) )
        {
          v11 = *(_WORD *)(i + 32);
          yb += v11 * *(_WORD *)(v4 + 182);
          v8 = (char *)v8 - v11;
        }
        if ( *(_DWORD *)(v4 + 116) )
          h = SelectObject(hdc, *(HGDIOBJ *)(v4 + 116));
        else
          h = 0;
        v10 = (*(_DWORD *)(v4 + 8) >> 22) & 0x20;
        if ( a3 )
          v10 |= 8u;
        while ( i && yb < *(_DWORD *)(a4 + 12) )
        {
          TV_DrawItem(v4, i, (int)hdc, v23, yb, v10);
          yb += *(_WORD *)(v4 + 182) * *(_WORD *)(i + 32);
          i = TV_GetNextVisItem(i);
        }
        if ( TV_GetInsertMarkRect(v4, (int)&v21) )
        {
          v12 = TV_GetInsertMarkColor(v4);
          DrawInsertMark(hdc, (int)&v21, 0, v12);
        }
        if ( h )
          SelectObject(hdc, h);
        rc.top = yb;
      }
      if ( a3 )
        FillRect(hdc, &rc, *(HBRUSH *)(v4 + 112));
      if ( *(_BYTE *)(v4 + 12) & 0x10 )
        CICustomDrawNotify(v4, 2, (LPARAM)&lParam);
    }
  }
}

//----- (6F787AFA) --------------------------------------------------------
HWND __stdcall TV_SendSelChange(int a1, int a2, int a3, int a4, int a5)
{
  LPARAM lParam; // [sp+0h] [bp-68h]@9
  int v7; // [sp+Ch] [bp-5Ch]@1
  int v8; // [sp+10h] [bp-58h]@9
  int v9; // [sp+14h] [bp-54h]@5
  int v10; // [sp+18h] [bp-50h]@6
  int v11; // [sp+34h] [bp-34h]@8
  int v12; // [sp+38h] [bp-30h]@5
  int v13; // [sp+3Ch] [bp-2Ch]@1
  int v14; // [sp+40h] [bp-28h]@2
  int v15; // [sp+5Ch] [bp-Ch]@4

  v7 = a5;
  v13 = a4;
  if ( a4 )
    v14 = *(_WORD *)(a4 + 20);
  else
    v14 = 0;
  if ( a4 )
    v15 = *(_DWORD *)(a4 + 16);
  else
    v15 = 0;
  v12 = 28;
  v9 = a3;
  if ( a3 )
    v10 = *(_WORD *)(a3 + 20);
  else
    v10 = 0;
  if ( a3 )
    v11 = *(_DWORD *)(a3 + 16);
  else
    v11 = 0;
  v8 = 28;
  return CCSendNotify(a1, a2, (LPARAM)&lParam);
}

//----- (6F787B8D) --------------------------------------------------------
signed int __stdcall TV_ScrollBarsAfterExpandCollapse(int a1, int a2, int a3)
{
  unsigned __int16 v3; // bx@1
  int i; // esi@2
  signed int v5; // eax@11
  bool v6; // zf@11
  signed int result; // eax@14
  LPARAM lParam; // [sp+8h] [bp-4Ch]@2
  HDC v9; // [sp+18h] [bp-3Ch]@7

  v3 = 0;
  if ( *(_WORD *)(a2 + 28) == -1 )
  {
    result = 0;
  }
  else
  {
    TreeView_BeginFakeCustomDraw(a1, (LPARAM)&lParam);
    for ( i = *(_DWORD *)(a2 + 8); i && *(_BYTE *)(i + 30) > *(_BYTE *)(a2 + 30); i = TV_GetNextVisItem(i) )
    {
      if ( !a3 )
        *(_WORD *)(i + 28) = -1;
      if ( !*(_WORD *)(i + 26) )
      {
        TreeView_BeginFakeItemDraw((LPARAM)&lParam, i);
        TV_ComputeItemWidth(a1, i, v9);
        TreeView_EndFakeItemDraw((LPARAM)&lParam);
      }
      if ( v3 < *(_WORD *)(i + 26) + ITEM_OFFSET(a1, i) )
        v3 = *(_WORD *)(i + 26) + ITEM_OFFSET(a1, i);
    }
    TreeView_EndFakeCustomDraw((LPARAM)&lParam);
    v5 = TV_UpdateShownIndexes(a1, a2);
    v6 = (*(_DWORD *)(a1 + 8) & 0x2000) == 0;
    *(_DWORD *)(a1 + 200) = v5;
    if ( v6 )
    {
      if ( a3 )
      {
        if ( v3 > *(_WORD *)(a1 + 194) )
          *(_WORD *)(a1 + 194) = v3;
      }
      else if ( v3 == *(_WORD *)(a1 + 194) )
      {
        *(_WORD *)(a1 + 194) = TV_RecomputeMaxWidth(a1);
      }
    }
    TV_CalcScrollBars(a1);
    result = 1;
  }
  return result;
}

//----- (6F787C74) --------------------------------------------------------
signed int __stdcall TV_ExpandParents(int a1, signed int a2, signed int a3)
{
  signed int result; // eax@1
  int v4; // esi@1
  char p; // [sp+4h] [bp-8h]@2
  int v6; // [sp+8h] [bp-4h]@3

  result = a2;
  v4 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 )
  {
    result = TV_StartWatch(a1, &p, v4);
    if ( result )
    {
      TV_ExpandParents(a1, v4, a3);
      if ( !v6 && !(*(_BYTE *)(v4 + 20) & 0x20) )
        TV_Expand(a1, 2u, v4, a3);
      result = TV_EndWatch(a1, (int)&p);
    }
  }
  return result;
}

//----- (6F787CD1) --------------------------------------------------------
signed int __stdcall TV_Expand(int a1, unsigned int a2, int a3, signed int a4)
{
  int v4; // esi@1
  unsigned int v5; // ebx@3
  __int16 v6; // ax@12
  __int16 v7; // dx@12
  __int16 v8; // ax@14
  __int16 v9; // ax@20
  __int16 v10; // cx@19
  int v11; // ebx@20
  int v12; // ecx@21
  int v13; // eax@21
  int v14; // edx@21
  unsigned int v15; // ebx@21
  __int16 v17; // ax@33
  signed int v18; // eax@35
  int v19; // edx@42
  int v20; // eax@46
  char v21; // [sp+Ch] [bp-30h]@3
  int v22; // [sp+2Ch] [bp-10h]@4
  int v23; // [sp+38h] [bp-4h]@1

  v4 = a3;
  v23 = a3;
  if ( !a3 || a3 == -65536 )
    v4 = *(_DWORD *)(a1 + 40);
  TV_GetItem(a1, v4, 64, (int)&v21);
  LOWORD(v5) = a2;
  if ( !(a2 & 3) || !v22 )
    return 0;
  if ( (a2 & 3) == 3 )
  {
    v17 = *(_WORD *)(v4 + 20);
    if ( v17 & 0x20 && (char)v17 >= 0 )
      v18 = 1;
    else
      v18 = 2;
    v5 = v18 | a2 & 0xFFFFFFFC;
    a2 = v18 | a2 & 0xFFFFFFFC;
  }
  if ( (v5 & 3) == 2 && !(*(_BYTE *)(v4 + 20) & 0x40) )
    a4 = 1;
  if ( a4 && TV_SendItemExpand(a1, -454, v23, v5) )
    return 0;
  if ( !*(_DWORD *)(v4 + 8) )
  {
    TV_InvalidateItem(a1, v4, 1u);
    return 0;
  }
  v6 = *(_WORD *)(v4 + 20);
  v7 = *(_WORD *)(v4 + 20);
  if ( *(_DWORD *)v4 )
  {
    if ( (v5 & 3) == 2 )
      v8 = v6 | 0x20;
    else
      v8 = v6 & 0xFF5F;
    *(_WORD *)(v4 + 20) = v8;
    if ( v5 & 0x4000 )
      *(_WORD *)(v4 + 20) |= 0x80u;
    else
      *(_WORD *)(v4 + 20) &= 0xFF7Fu;
  }
  if ( !(v7 & 0x20) && !(*(_BYTE *)(v4 + 20) & 0x20) )
  {
    if ( (unsigned __int16)(v5 & 0x8003) == 32769 )
      TV_ResetItem(a1, (LPVOID)v4);
    return 0;
  }
  v10 = v7 ^ *(_WORD *)(v4 + 20);
  if ( v10 & 0x20 )
  {
    v9 = *(_WORD *)(v4 + 20);
    v11 = TV_ScrollBelow(a1, v4, 1, v9 & 0x20);
    if ( *(_BYTE *)(v4 + 20) & 0x20 )
    {
      TV_ScrollBarsAfterExpand(a1, v4);
      v12 = *(_WORD *)(*(_DWORD *)(a1 + 208) + 28);
      v13 = *(_WORD *)(v4 + 28) - v12;
      v14 = v13 + v11 + 1;
      v15 = *(_WORD *)(a1 + 196);
      if ( v14 > v15 )
      {
        v19 = v14 - v15;
        if ( v19 < (unsigned int)v13 )
          v13 = v19;
        TV_SmoothSetTopItem(a1, v12 + v13, 0);
      }
    }
    else
    {
      TV_ScrollBarsAfterCollapse(a1, v4);
      TV_ScrollVertIntoView(a1, v4);
      v20 = *(_DWORD *)(a1 + 44);
      if ( v20 && TV_WalkToLevel(v20, *(_BYTE *)(v4 + 30)) == v4 )
        TV_SelectItem(a1, 9, v4, (a4 != 0) | 6, 0);
    }
    LOWORD(v5) = a2;
  }
  else if ( (char)v10 < 0 )
  {
    TV_InvalidateItem(a1, v4, 1u);
  }
  if ( a4 && TV_SendItemExpand(a1, -455, v4, v5) )
    return 0;
  *(_WORD *)(v4 + 20) |= 0x40u;
  if ( (unsigned __int16)(v5 & 0x8003) == 32769 )
    TV_ResetItem(a1, (LPVOID)v4);
  MyNotifyWinEvent(32778, *(_DWORD *)a1, -4, v4);
  return 1;
}
// 6F787B72: using guessed type _DWORD __stdcall TV_ScrollBarsAfterExpand(_DWORD, _DWORD);

//----- (6F787E6C) --------------------------------------------------------
HWND __stdcall TV_SendItemExpand(int a1, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@5
  HWND v6; // esi@5
  LPARAM lParam; // [sp+8h] [bp-70h]@5
  int v9; // [sp+14h] [bp-64h]@5
  int v10; // [sp+18h] [bp-60h]@5
  int v11; // [sp+40h] [bp-38h]@1
  int v12; // [sp+44h] [bp-34h]@1
  int v13; // [sp+48h] [bp-30h]@2
  int v14; // [sp+58h] [bp-20h]@2
  int v15; // [sp+5Ch] [bp-1Ch]@2
  int v16; // [sp+60h] [bp-18h]@12
  int v17; // [sp+64h] [bp-14h]@2
  char p; // [sp+70h] [bp-8h]@5
  int v19; // [sp+74h] [bp-4h]@8

  v4 = a3;
  v11 = 0;
  v12 = a3;
  if ( a3 == -65536 )
    v4 = *(_DWORD *)(a1 + 40);
  v13 = *(_WORD *)(v4 + 20);
  v17 = *(_DWORD *)(v4 + 16);
  v14 = *(_WORD *)(v4 + 22);
  v15 = *(_WORD *)(v4 + 24);
  if ( *(_BYTE *)(v4 + 31) != 1 )
  {
    if ( *(_BYTE *)(v4 + 31) == 2 )
    {
      v16 = 0;
      goto LABEL_13;
    }
    if ( *(_BYTE *)(v4 + 31) != 3 )
      goto LABEL_5;
  }
  v16 = 1;
LABEL_13:
  v11 = 64;
LABEL_5:
  v11 |= 0x3Eu;
  v10 = 0;
  v9 = a4 & 3;
  v5 = TV_StartWatch(a1, &p, v4);
  v6 = CCSendNotify(a1, a2, (LPARAM)&lParam);
  if ( a2 == -455 )
    v6 = 0;
  if ( v5 )
  {
    if ( v19 )
      v6 = (HWND)1;
    TV_EndWatch(a1, (int)&p);
  }
  return v6;
}

//----- (6F787F21) --------------------------------------------------------
signed int __stdcall TV_EndWatch(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@1
  int v4; // edx@2
  signed int result; // eax@4

  v2 = *(_DWORD *)(a1 + 80);
  v3 = *(_DWORD *)v2 - 1;
  if ( v3 < 0 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 4) + 4 * v3;
    while ( a2 != *(_DWORD *)v4 )
    {
      --v3;
      v4 -= 4;
      if ( v3 < 0 )
        goto LABEL_6;
    }
    DPA_DeletePtr((HDPA)v2, v3);
    result = 1;
  }
  return result;
}

//----- (6F787F66) --------------------------------------------------------
int __stdcall TV_CountVisibleDescendants(int a1)
{
  int v1; // esi@1
  int v2; // edi@1

  v1 = *(_DWORD *)(a1 + 8);
  v2 = 0;
  while ( v1 )
  {
    v2 += *(_WORD *)(v1 + 32);
    if ( *(_DWORD *)(v1 + 8) )
    {
      if ( *(_BYTE *)(v1 + 20) & 0x20 )
        v2 += TV_CountVisibleDescendants(v1);
    }
    v1 = *(_DWORD *)(v1 + 4);
  }
  return v2;
}

//----- (6F787FDB) --------------------------------------------------------
int __stdcall TV_InsertItem(LRESULT a1, int a2)
{
  int v2; // ebx@50
  int v3; // eax@52
  unsigned __int16 v4; // ax@54
  int v5; // eax@55
  int v6; // eax@2
  int v7; // esi@2
  int v8; // esi@4
  bool v9; // zf@5
  int v10; // edx@7
  char v11; // cl@13
  signed __int16 v12; // ax@14
  signed __int16 v13; // ax@16
  int v14; // eax@29
  unsigned int v15; // eax@32
  int v16; // ebx@33
  int v18; // eax@68
  int v19; // ecx@69
  int v20; // ebx@79
  int v21; // eax@43
  void *v22; // [sp-8h] [bp-198h]@65
  char v23; // [sp+8h] [bp-188h]@50
  LPCWSTR lpString1; // [sp+18h] [bp-178h]@50
  int v25; // [sp+1Ch] [bp-174h]@50
  char v26; // [sp+34h] [bp-15Ch]@51
  LPCWSTR lpString2; // [sp+44h] [bp-14Ch]@51
  int v28; // [sp+48h] [bp-148h]@51
  char v29; // [sp+60h] [bp-130h]@46
  LONG v30; // [sp+64h] [bp-12Ch]@86
  RECT rcUpdate; // [sp+70h] [bp-120h]@34
  int v32; // [sp+80h] [bp-110h]@2
  int v33; // [sp+84h] [bp-10Ch]@2
  int v34; // [sp+88h] [bp-108h]@2
  char v35; // [sp+8Ch] [bp-104h]@51
  char v36; // [sp+10Ch] [bp-84h]@50

  if ( !a2 )
    return 0;
  v33 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)a2;
  v34 = *(_DWORD *)a2;
  v32 = v6;
  if ( v6 & 0xFFFFF800 )
    v32 &= 0x7Fu;
  TV_DismissEdit(a1, 0);
  if ( !ValidateTreeItem(v7, 1) )
    return 0;
  v8 = (int)HeapAlloc(*(HANDLE *)(a1 + 148), 8u, 0x24u);
  if ( !v8 )
    return 0;
  v9 = (v32 & 1) == 0;
  *(_WORD *)(v8 + 34) = -21555;
  if ( v9 )
  {
    Str_Set(v8 + 12, &c_szNULL);
  }
  else if ( *(_DWORD *)(a2 + 24) )
  {
    if ( !Str_Set(v8 + 12, *(LPCWSTR *)(a2 + 24)) )
    {
      v22 = (void *)v8;
LABEL_67:
      *(_WORD *)(v8 + 34) = 0;
      HeapFree(*(HANDLE *)(a1 + 148), 0, v22);
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(v8 + 12) = -1;
  }
  v10 = v34;
  if ( !v34 || v34 == -65536 )
  {
    v34 = *(_DWORD *)(a1 + 40);
    v10 = v34;
    if ( !*(_DWORD *)(a1 + 208) )
      *(_DWORD *)(a1 + 208) = v8;
    goto LABEL_10;
  }
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 40) + 8) )
  {
    v22 = (void *)v8;
    goto LABEL_67;
  }
LABEL_10:
  if ( v33 != -65535 && v33 != -65533 && (v18 = *(_DWORD *)(v10 + 8)) != 0 )
  {
    v19 = *(_DWORD *)(v18 + 4);
    if ( v33 == -65534 )
    {
      while ( v19 )
      {
        v18 = v19;
        v19 = *(_DWORD *)(v19 + 4);
      }
    }
    else if ( v19 )
    {
      do
      {
        if ( v18 == v33 )
          break;
        v18 = v19;
        v19 = *(_DWORD *)(v19 + 4);
      }
      while ( v19 );
      v10 = v34;
    }
    *(_DWORD *)(v8 + 4) = *(_DWORD *)(v18 + 4);
    *(_DWORD *)(v18 + 4) = v8;
  }
  else
  {
    *(_DWORD *)(v8 + 4) = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = v8;
  }
  v11 = v32;
  *(_DWORD *)v8 = v10;
  *(_BYTE *)(v8 + 30) = *(_BYTE *)(v10 + 30) + 1;
  if ( v11 >= 0 || (v12 = *(_WORD *)(a2 + 48)) == 0 )
    v12 = 1;
  *(_WORD *)(v8 + 32) = v12;
  if ( *(_DWORD *)(a1 + 208) == v8 )
    v13 = 0;
  else
    v13 = -1;
  *(_WORD *)(v8 + 28) = v13;
  if ( v11 & 2 )
    *(_WORD *)(v8 + 22) = *(_WORD *)(a2 + 32);
  if ( v11 & 0x20 )
    *(_WORD *)(v8 + 24) = *(_WORD *)(a2 + 36);
  if ( v11 & 4 )
    *(_DWORD *)(v8 + 16) = *(_DWORD *)(a2 + 44);
  if ( v11 & 8 )
    *(_WORD *)(v8 + 20) = *(_WORD *)(a2 + 16) & *(_WORD *)(a2 + 20);
  if ( *(_DWORD *)(a1 + 8) & 0x100 && !(*(_WORD *)(v8 + 20) & 0xF000) )
    *(_WORD *)(v8 + 20) |= 0x1000u;
  if ( *(_BYTE *)(v8 + 20) & 0x10 && !*(_DWORD *)(a1 + 124) )
  {
    TV_CreateBoldFont(a1);
    v10 = v34;
  }
  if ( v32 & 0x40 )
  {
    v20 = *(_DWORD *)(a2 + 40);
    if ( v20 == -1 )
      *(_BYTE *)(v8 + 31) = 3;
    else
      *(_BYTE *)(v8 + 31) = (v20 == 0) + 1;
  }
  ++*(_DWORD *)(a1 + 204);
  if ( v33 == -65533 )
  {
    v14 = *(_DWORD *)(v10 + 8);
    if ( v14 )
    {
      if ( *(_DWORD *)(v14 + 4) )
      {
        lpString1 = (LPCWSTR)&v36;
        v25 = 64;
        TV_GetItem(a1, v8, 1, (int)&v23);
        v2 = *(_DWORD *)(v8 + 4);
        if ( v2 )
        {
          do
          {
            lpString2 = (LPCWSTR)&v35;
            v28 = 64;
            TV_GetItem(a1, v2, 1, (int)&v26);
            if ( lstrcmpiW(lpString1, lpString2) < 0 )
              break;
            v33 = v2;
            v2 = *(_DWORD *)(v2 + 4);
          }
          while ( v2 );
          v3 = v33;
          if ( v33 != -65533 )
          {
            *(_DWORD *)(v34 + 8) = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v8 + 4) = *(_DWORD *)(v3 + 4);
            *(_DWORD *)(v3 + 4) = v8;
          }
        }
      }
    }
  }
  if ( *(_DWORD *)(v8 + 4) == *(_DWORD *)(a1 + 208) && !(*(_BYTE *)(a1 + 36) & 2) )
  {
    *(_WORD *)(v8 + 28) = 0;
    *(_DWORD *)(a1 + 208) = v8;
  }
  v15 = *(_DWORD *)(a1 + 36);
  if ( v15 & 0x10 )
  {
    v16 = (v15 >> 1) & 1;
    if ( TV_ScrollBarsAfterAdd(a1, v8) )
    {
      v4 = *(_WORD *)(v8 + 28);
      if ( v4 != -1 )
      {
        v5 = v4 - *(_WORD *)(*(_DWORD *)(a1 + 208) + 28);
        if ( v5 > 0 || !v16 )
          TV_ScrollItems(a1, *(_WORD *)(v8 + 32), v5 + *(_WORD *)(v8 + 32) - 1, 1);
      }
    }
    if ( TV_GetItemRect(a1, v8, (int)&rcUpdate, 0) )
    {
      v21 = *(_DWORD *)(v34 + 8);
      if ( v21 == v8 )
      {
        v21 = v34;
      }
      else
      {
        while ( *(_DWORD *)(v21 + 4) != v8 )
          v21 = *(_DWORD *)(v21 + 4);
      }
      if ( TV_GetItemRect(a1, v21, (int)&v29, 0) )
        rcUpdate.top = v30;
      RedrawWindow(*(HWND *)a1, &rcUpdate, 0, 5u);
    }
  }
  MyNotifyWinEvent(0x8000, *(_DWORD *)a1, -4, v8);
  if ( *(_DWORD *)(a1 + 64) )
    TV_PopBubble(a1);
  return v8;
}

//----- (6F788276) --------------------------------------------------------
signed int __stdcall TV_SetItem(int a1, int a2)
{
  struct _IMAGELIST *v2; // eax@36
  signed int result; // eax@1
  int v4; // edi@1
  int v5; // esi@2
  const WCHAR *v6; // eax@5
  int v7; // eax@45
  __int16 v8; // ax@52
  int v9; // ebx@54
  int v10; // [sp+8h] [bp-1Ch]@1
  int v11; // [sp+Ch] [bp-18h]@1
  signed int v12; // [sp+10h] [bp-14h]@1
  signed int v13; // [sp+14h] [bp-10h]@1
  signed int v14; // [sp+18h] [bp-Ch]@1
  signed int v15; // [sp+1Ch] [bp-8h]@1
  signed int flags; // [sp+20h] [bp-4h]@1
  int v17; // [sp+30h] [bp+Ch]@4

  result = 0;
  v4 = a2;
  flags = 1;
  v13 = 0;
  v15 = 0;
  v12 = 0;
  v11 = 0;
  v14 = 0;
  v10 = 0;
  if ( a2 )
  {
    v5 = *(_DWORD *)(a2 + 4);
    if ( v5 == -65536 )
      v5 = *(_DWORD *)(a1 + 40);
    result = ValidateTreeItem(v5, 0);
    if ( result )
    {
      v17 = *(_WORD *)(v5 + 32);
      if ( *(_BYTE *)v4 & 1 )
      {
        v6 = *(const WCHAR **)(v4 + 16);
        flags = 5;
        v15 = 1;
        if ( v6 )
        {
          if ( !Str_Set(v5 + 12, v6) )
            *(_DWORD *)(v5 + 12) = -1;
        }
        else
        {
          Str_Set(v5 + 12, (LPCWSTR)0xFFFFFFFF);
        }
        v14 = 1;
        v12 = 1;
      }
      if ( *(_BYTE *)v4 & 4 )
      {
        v15 = 1;
        *(_DWORD *)(v5 + 16) = *(_DWORD *)(v4 + 36);
      }
      if ( *(_BYTE *)v4 & 2 )
      {
        if ( *(_WORD *)(v5 + 22) != -1 )
        {
          v15 = 1;
          v13 = 1;
          if ( *(_DWORD *)(a1 + 84) )
          {
            if ( ImageList_GetBkColor(*(HIMAGELIST *)(a1 + 84)) == -1 )
              flags |= 4u;
          }
        }
        *(_WORD *)(v5 + 22) = *(_WORD *)(v4 + 24);
      }
      if ( *(_BYTE *)v4 & 0x20 )
      {
        if ( *(_WORD *)(v5 + 24) != -1 )
          v15 = 1;
        *(_WORD *)(v5 + 24) = *(_WORD *)(v4 + 28);
      }
      if ( *(_BYTE *)v4 & 0x40 )
      {
        if ( *(_BYTE *)(v5 + 31) != 3 )
          v15 = 1;
        v7 = *(_DWORD *)(v4 + 32);
        if ( v7 == -1 )
          *(_BYTE *)(v5 + 31) = 3;
        else
          *(_BYTE *)(v5 + 31) = (v7 == 0) + 1;
        if ( *(_DWORD *)(v4 + 32) == -1 && !*(_DWORD *)(v5 + 8) )
        {
          *(_WORD *)(v5 + 20) &= 0xFFBFu;
          if ( *(_DWORD *)v5 )
            *(_WORD *)(v5 + 20) &= 0xFFDFu;
        }
      }
      if ( *(_BYTE *)v4 & 0x80 )
      {
        v8 = *(_WORD *)(v4 + 40);
        if ( v8 )
          *(_WORD *)(v5 + 32) = v8;
      }
      if ( *(_BYTE *)v4 & 8 )
      {
        v9 = *(_DWORD *)(v4 + 12) & (*(_DWORD *)(v4 + 8) ^ *(_WORD *)(v5 + 20));
        if ( v9 )
        {
          *(_WORD *)(v5 + 20) ^= v9;
          v15 = 1;
          v13 = 1;
          if ( *(_WORD *)(v5 + 20) & 0x10 && !*(_DWORD *)(a1 + 124) )
            TV_CreateBoldFont(a1);
          if ( v9 & 0x10 )
          {
            flags |= 4u;
            v14 = 1;
          }
          v10 = v9 & 0xF000;
          if ( v9 & 0xF000 )
          {
            flags |= 4u;
            if ( !(*(_WORD *)(v5 + 20) & 0xF000) || !(((unsigned __int16)v9 ^ *(_WORD *)(v5 + 20)) & 0xF000) )
              v14 = 1;
          }
          v11 = ((unsigned int)v9 >> 1) & 1;
        }
      }
      if ( v14 )
      {
        *(_WORD *)(v5 + 26) = 0;
        if ( TV_IsShowing(v5) )
          TV_ScrollBarsAfterSetWidth(a1, v5);
      }
      if ( v15 )
      {
        if ( *(_DWORD *)(a1 + 144) != v5 )
        {
          if ( v13 )
          {
            v2 = *(struct _IMAGELIST **)(a1 + 84);
            if ( v2 )
            {
              if ( ImageList_GetBkColor(v2) == -1 )
                flags |= 4u;
            }
          }
          if ( *(_WORD *)(v5 + 32) == v17 )
            TV_InvalidateItem(a1, v5, flags);
          else
            TV_ScrollBarsAfterResize(a1, v5, v17, flags);
        }
        if ( v12 )
          MyNotifyWinEvent(32780, *(_DWORD *)a1, -4, v5);
        if ( v11 )
        {
          MyNotifyWinEvent(32773, *(_DWORD *)a1, -4, v5);
          MyNotifyWinEvent(32776 - ((*(_BYTE *)(v5 + 20) & 2) != 0), *(_DWORD *)a1, -4, v5);
        }
        if ( v10 )
          MyNotifyWinEvent(32778, *(_DWORD *)a1, -4, v5);
      }
      result = 1;
    }
  }
  return result;
}

//----- (6F7883E5) --------------------------------------------------------
HWND __stdcall Tab_Paint(int cy, int a2)
{
  HWND v2; // eax@1
  HWND result; // eax@1
  HDC v4; // edi@5
  signed int v5; // esi@7
  HGDIOBJ v6; // edi@10
  int v7; // eax@11
  int v8; // esi@11
  bool v9; // zf@11
  int v10; // eax@12
  PVOID v11; // eax@20
  UINT v12; // eax@26
  int v13; // eax@33
  int v14; // ecx@33
  int v15; // esi@33
  int v16; // edi@33
  int v17; // esi@34
  struct tagRECT rcDst; // [sp+Ch] [bp-B4h]@23
  struct tagRECT rect; // [sp+1Ch] [bp-A4h]@10
  int v20; // [sp+2Ch] [bp-94h]@1
  int v21; // [sp+30h] [bp-90h]@33
  HGDIOBJ h; // [sp+34h] [bp-8Ch]@1
  int v23; // [sp+38h] [bp-88h]@7
  struct tagRECT Rect; // [sp+3Ch] [bp-84h]@1
  int v25; // [sp+4Ch] [bp-74h]@33
  UINT options; // [sp+50h] [bp-70h]@33
  HWND hWnd; // [sp+54h] [bp-6Ch]@1
  int v28; // [sp+58h] [bp-68h]@33
  int v29; // [sp+5Ch] [bp-64h]@1
  struct tagRECT rc; // [sp+60h] [bp-60h]@22
  HGDIOBJ ho; // [sp+70h] [bp-50h]@10
  HGDIOBJ v32; // [sp+74h] [bp-4Ch]@11
  HDC hdc; // [sp+78h] [bp-48h]@3
  struct tagPAINTSTRUCT Paint; // [sp+7Ch] [bp-44h]@3

  v2 = *(HWND *)cy;
  v20 = a2;
  v29 = 2;
  hWnd = v2;
  h = 0;
  result = (HWND)GetClientRect(v2, &Rect);
  if ( Rect.right )
  {
    if ( a2 )
    {
      hdc = (HDC)a2;
      Paint.rcPaint = Rect;
    }
    else
    {
      hdc = BeginPaint(hWnd, &Paint);
    }
    if ( !*(_DWORD *)(cy + 56) )
      Tab_OnSetFont(cy, 0, 0);
    SelectObject(hdc, *(HGDIOBJ *)(cy + 56));
    v4 = hdc;
    CalcPaintMetrics(cy, hdc);
    Tab_DFlipRect(cy, (int)&Rect);
    Tab_OnAdjustRect(cy, 0, &Rect);
    InflateRect(&Rect, 2 * g_cxEdge, 2 * g_cyEdge);
    Rect.top += g_cyEdge;
    if ( !(*(_DWORD *)(cy + 8) & 0x100) )
      Tab_DrawEdge(v4, (int)&Rect, 5u, 0x100Fu, cy);
    result = *(HWND *)(cy + 40);
    v5 = *(_DWORD *)result;
    v23 = v5;
    if ( !v5 )
      goto LABEL_29;
    RefreshArrows(cy, v4);
    SetBkColor(v4, g_clrBtnFace);
    SetTextColor(v4, g_clrBtnText);
    if ( !(*(_DWORD *)(cy + 8) & 0x200) )
      IntersectClipRect(v4, 0, 0, *(_DWORD *)(cy + 80), Rect.bottom);
    GetClipBox(v4, &rect);
    Tab_DVFlipRect(cy, (int)&rect);
    ho = *(HGDIOBJ *)(cy + 88);
    v6 = ho;
    if ( (signed int)ho < v5 )
    {
      while ( 1 )
      {
        v7 = *(_DWORD *)(*(_DWORD *)(cy + 40) + 4);
        v8 = *(_DWORD *)(v7 + 4 * (_DWORD)v6);
        v9 = (*(_BYTE *)(v8 + 48) & 4) == 0;
        v32 = *(HGDIOBJ *)(v7 + 4 * (_DWORD)v6);
        if ( v9 )
        {
          v10 = *(_DWORD *)(cy + 8);
          if ( !(v10 & 0x200) && *(_DWORD *)v8 > *(_DWORD *)(cy + 80) )
          {
LABEL_17:
            v5 = v23;
            goto LABEL_18;
          }
          if ( (v6 != *(HGDIOBJ *)(cy + 60) || v10 & 0x100) && IntersectRect(&rcDst, &rect, (const RECT *)v8) )
            break;
        }
LABEL_16:
        v6 = (char *)v6 + 1;
        ho = v6;
        if ( (signed int)v6 >= v23 )
          goto LABEL_17;
      }
      v13 = *(_DWORD *)(cy + 8);
      options = 0;
      v25 = 0;
      v14 = g_cxEdge;
      rc.left = *(_DWORD *)v8;
      v15 = v8 + 4;
      rc.top = *(_DWORD *)v15;
      v15 += 4;
      rc.right = *(_DWORD *)v15;
      v28 = v13 & 0x100;
      rc.bottom = *(_DWORD *)(v15 + 4);
      v16 = g_cyEdge;
      v21 = v13;
      if ( !(v13 & 0x100) )
      {
        v17 = (int)v32;
LABEL_35:
        v32 = (HGDIOBJ)5;
LABEL_36:
        if ( v28 && !(v21 & 0x2000) && *(HGDIOBJ *)(cy + 60) == ho )
        {
          v29 = 1;
          SetBkMode(hdc, 1);
          h = SelectObject(hdc, g_hbrMonoDither);
          SetTextColor(hdc, g_clrBtnHighlight);
          Tab_PatBlt(
            hdc,
            *(_DWORD *)v17,
            *(_DWORD *)(v17 + 4),
            *(_DWORD *)(v17 + 8) - *(_DWORD *)v17,
            *(_DWORD *)(v17 + 12) - *(_DWORD *)(v17 + 4),
            0xF00021u,
            cy);
          SetTextColor(hdc, g_clrBtnText);
          v16 = g_cyEdge;
          v14 = g_cxEdge;
        }
        InflateRect(&rc, -v14, -v16);
        if ( !(*(_DWORD *)(cy + 8) & 0x100) )
        {
          if ( *(_DWORD *)(v17 + 40) <= *(_DWORD *)(cy + 116) )
            rc.bottom += g_cyEdge;
          else
            rc.top -= g_cyEdge;
        }
        DrawBody(hdc, cy, v17, (int)&rc, (int)ho, v29 == 1, options, v25);
        Tab_DrawItemFrame(cy, hdc, v32, (RECT *)v17, ho);
        if ( v29 == 1 )
        {
          v29 = 2;
          SelectObject(hdc, h);
          SetBkMode(hdc, 2);
        }
        v6 = ho;
        goto LABEL_16;
      }
      if ( *(HGDIOBJ *)(cy + 64) == ho && *(_BYTE *)(cy + 44) & 4 || *(HGDIOBJ *)(cy + 60) == ho )
      {
        v17 = (int)v32;
      }
      else
      {
        v17 = (int)v32;
        if ( !(*((_BYTE *)v32 + 48) & 1) )
          goto LABEL_35;
      }
      options = g_cxEdge / 2;
      v25 = g_cyEdge / 2;
      if ( v21 & 8 && *(HGDIOBJ *)(cy + 64) == ho && *(_BYTE *)(cy + 44) & 4 )
        v32 = (HGDIOBJ)4;
      else
        v32 = (HGDIOBJ)10;
      goto LABEL_36;
    }
LABEL_18:
    if ( *(_DWORD *)(cy + 8) & 0x200 )
      *(_DWORD *)(cy + 92) = v5 - 1;
    else
      *(_DWORD *)(cy + 92) = (char *)v6 - 1;
    v11 = DPA_GetPtr(*(HDPA *)(cy + 40), *(_DWORD *)(cy + 60));
    v32 = v11;
    if ( v11 )
    {
      if ( *(_DWORD *)v11 <= *(_DWORD *)(cy + 80) )
      {
        v9 = (*(_DWORD *)(cy + 8) & 0x100) == 0;
        rc.left = *(_DWORD *)v11;
        rc.top = *((_DWORD *)v11 + 1);
        rc.right = *((_DWORD *)v11 + 2);
        rc.bottom = *((_DWORD *)v11 + 3);
        if ( v9 )
        {
          InflateRect(&rc, g_cxEdge, g_cyEdge);
          if ( IntersectRect(&rcDst, &rect, &rc) )
          {
            DrawBody(hdc, cy, (int)v32, (int)&rc, *(_DWORD *)(cy + 60), 0, 0, -g_cyEdge);
            --rc.bottom;
            Tab_DrawEdge(hdc, (int)&rc, 5u, 0x1007u, cy);
            DoCorners(hdc, (int)&rc, cy, 0);
            ++rc.bottom;
            rc.top = rc.bottom - 1;
            if ( rc.right == Rect.right )
            {
              v12 = 4100;
            }
            else
            {
              if ( rc.left != Rect.left )
                goto LABEL_28;
              v12 = 4097;
            }
            Tab_DrawEdge(hdc, (int)&rc, 5u, v12, cy);
          }
        }
      }
    }
LABEL_28:
    result = GetFocus();
    if ( result == hWnd )
    {
      if ( v32
        || (result = *(HWND *)(cy + 64), result != HWND_MESSAGE|0x2)
        && (result = (HWND)DPA_GetPtr(*(HDPA *)(cy + 40), *(_DWORD *)(cy + 64)), (v32 = result) != 0) )
      {
        result = (HWND)CCGetUIState(cy);
        if ( !((unsigned __int8)result & 1) )
        {
          v9 = (*(_DWORD *)(cy + 8) & 0x100) == 0;
          rc.left = *(_DWORD *)v32;
          rc.top = *((_DWORD *)v32 + 1);
          rc.right = *((_DWORD *)v32 + 2);
          rc.bottom = *((_DWORD *)v32 + 3);
          if ( v9 )
            InflateRect(&rc, g_cxEdge / -2, g_cyEdge / -2);
          else
            InflateRect(&rc, -g_cxEdge, -g_cyEdge);
          result = (HWND)Tab_DrawFocusRect(hdc, (int)&rc, cy);
        }
      }
    }
LABEL_29:
    if ( !v20 )
      result = (HWND)EndPaint(hWnd, &Paint);
  }
  return result;
}

//----- (6F788793) --------------------------------------------------------
int __stdcall Tab_DrawItemFrame(int a1, HDC hdc, HGDIOBJ h, RECT *lprcSrc, HGDIOBJ ho)
{
  int v5; // esi@1
  int v6; // eax@1
  UINT v7; // ecx@2
  int result; // eax@4
  COLORREF v9; // eax@16
  COLORREF v10; // eax@16
  struct tagRECT rcDst; // [sp+8h] [bp-14h]@16
  int v12; // [sp+18h] [bp-4h]@1
  HGDIOBJ ha; // [sp+2Ch] [bp+10h]@16
  HGDIOBJ hb; // [sp+2Ch] [bp+10h]@16
  HPEN hoa; // [sp+34h] [bp+18h]@16
  HPEN hob; // [sp+34h] [bp+18h]@16

  v5 = a1;
  v6 = *(_DWORD *)(a1 + 8);
  v12 = 0;
  if ( !(v6 & 0x100) )
  {
    v7 = 4103;
    if ( v6 & 1 && lprcSrc[2].right > *(_DWORD *)(a1 + 116) )
    {
      v12 = 1;
      v7 = 4109;
    }
    goto LABEL_3;
  }
  if ( !(v6 & 8) )
  {
    v7 = 4111;
    goto LABEL_3;
  }
  if ( h == (HGDIOBJ)10 || h == (HGDIOBJ)4 )
  {
LABEL_15:
    v7 = 15;
LABEL_3:
    Tab_DrawEdge(hdc, (int)lprcSrc, (UINT)h, v7, a1);
    goto LABEL_4;
  }
  if ( v6 & 0x40 && ho == *(HGDIOBJ *)(a1 + 160) )
  {
    h = (HGDIOBJ)4;
    goto LABEL_15;
  }
  CopyRect(&rcDst, lprcSrc);
  v9 = GetSysColor(15);
  hoa = CreatePen(0, 2 * g_cyEdge, v9);
  ha = SelectObject(hdc, hoa);
  MoveToEx(hdc, rcDst.left, rcDst.top, 0);
  LineTo(hdc, rcDst.right, rcDst.top);
  MoveToEx(hdc, rcDst.left, rcDst.bottom, 0);
  LineTo(hdc, rcDst.right, rcDst.bottom);
  SelectObject(hdc, ha);
  DeleteObject(hoa);
  v10 = GetSysColor(15);
  hob = CreatePen(0, 2 * g_cxEdge, v10);
  hb = SelectObject(hdc, hob);
  MoveToEx(hdc, rcDst.left, rcDst.top, 0);
  LineTo(hdc, rcDst.left, rcDst.bottom);
  MoveToEx(hdc, rcDst.right, rcDst.top, 0);
  LineTo(hdc, rcDst.right, rcDst.bottom);
  SelectObject(hdc, hb);
  DeleteObject(hob);
  v5 = a1;
LABEL_4:
  result = *(_DWORD *)(v5 + 8);
  if ( result & 0x100 )
  {
    if ( result & 8 )
    {
      if ( *(_BYTE *)(v5 + 52) & 1 )
      {
        CopyRect(&rcDst, lprcSrc);
        rcDst.right += 3 * g_cxEdge;
        result = DrawEdge(hdc, &rcDst, 6u, 4u);
      }
    }
  }
  else
  {
    result = DoCorners(hdc, (int)lprcSrc, v5, v12);
  }
  return result;
}

//----- (6F7887FE) --------------------------------------------------------
int __stdcall DoCorners(HDC hdc, int a2, int a3, int a4)
{
  int result; // eax@2
  int v5; // [sp+Ch] [bp-10h]@1
  int v6; // [sp+10h] [bp-Ch]@1
  int v7; // [sp+14h] [bp-8h]@1
  int v8; // [sp+18h] [bp-4h]@1

  SetBkColor(hdc, g_clrBtnFace);
  v5 = *(_DWORD *)a2;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = *(_DWORD *)(a2 + 8);
  v8 = *(_DWORD *)(a2 + 12);
  v5 = v7 - 2;
  if ( a4 )
  {
    v6 = v8 - 3;
    Tab_ExtTextOut(hdc, 0, 0, 2u, (int)&v5, 0, 0, 0, a3);
    --v8;
    Tab_DrawEdge(hdc, (int)&v5, 5u, 0x1019u, a3);
    v5 = *(_DWORD *)a2;
    v6 = *(_DWORD *)(a2 + 4);
    v7 = *(_DWORD *)(a2 + 8);
    v8 = *(_DWORD *)(a2 + 12);
    v7 = v5 + 2;
    v6 = v8 - 3;
    Tab_ExtTextOut(hdc, 0, 0, 2u, (int)&v5, 0, 0, 0, a3);
    --v8;
    result = Tab_DrawEdge(hdc, (int)&v5, 5u, 0x1013u, a3);
  }
  else
  {
    v8 = v6 + 3;
    Tab_ExtTextOut(hdc, 0, 0, 2u, (int)&v5, 0, 0, 0, a3);
    ++v6;
    Tab_DrawEdge(hdc, (int)&v5, 5u, 0x101Cu, a3);
    v5 = *(_DWORD *)a2;
    v6 = *(_DWORD *)(a2 + 4);
    v7 = *(_DWORD *)(a2 + 8);
    v8 = *(_DWORD *)(a2 + 12);
    v7 = v5 + 2;
    v8 = v6 + 3;
    Tab_ExtTextOut(hdc, 0, 0, 2u, (int)&v5, 0, 0, 0, a3);
    ++v6;
    result = Tab_DrawEdge(hdc, (int)&v5, 5u, 0x1016u, a3);
  }
  return result;
}

//----- (6F7888C5) --------------------------------------------------------
int __stdcall Tab_DrawEdge(HDC hdc, int a2, UINT edge, UINT grfFlags, int a5)
{
  int v5; // edx@1
  UINT v7; // eax@4
  int v8; // [sp+8h] [bp-10h]@1
  int v9; // [sp+Ch] [bp-Ch]@1
  int v10; // [sp+10h] [bp-8h]@1
  int v11; // [sp+14h] [bp-4h]@1

  v8 = *(_DWORD *)a2;
  v9 = *(_DWORD *)(a2 + 4);
  v10 = *(_DWORD *)(a2 + 8);
  v11 = *(_DWORD *)(a2 + 12);
  Tab_VFlipRect(a5, (int)&v8);
  v5 = *(_DWORD *)(a5 + 8);
  if ( v5 & 2 )
  {
    if ( grfFlags & 0x10 )
    {
      v7 = grfFlags & 0xFFFFFFFA;
      if ( grfFlags & 1 )
        v7 |= 4u;
      if ( grfFlags & 4 )
        v7 |= 1u;
    }
    else
    {
      v7 = grfFlags & 0xFFFFFFF5;
      if ( grfFlags & 2 )
        v7 |= 8u;
      if ( grfFlags & 8 )
        v7 |= 2u;
    }
    grfFlags = v7;
  }
  return VertDrawEdge(hdc, (int)&v8, edge, grfFlags, v5 & 0x80);
}

//----- (6F788916) --------------------------------------------------------
BOOL __stdcall VertDrawEdge(HDC hdc, int a2, UINT edge, UINT grfFlags, int a5)
{
  UINT v6; // eax@5
  unsigned int v7; // eax@8
  unsigned int v8; // eax@11
  UINT v9; // eax@14
  struct tagRECT qrc; // [sp+Ch] [bp-10h]@1

  qrc.left = *(_DWORD *)a2;
  qrc.top = *(_DWORD *)(a2 + 4);
  qrc.right = *(_DWORD *)(a2 + 8);
  qrc.bottom = *(_DWORD *)(a2 + 12);
  if ( a5 )
  {
    FlipRect((int)&qrc);
    if ( grfFlags & 0x10 )
    {
      if ( (grfFlags & 0xC) == 12 )
      {
        edge = edge != 5 ? 5 : 10;
        grfFlags = (grfFlags & 0xFFFFFFF3 | 3) ^ 0x1000;
      }
    }
    else
    {
      if ( grfFlags & 2 )
        v6 = grfFlags | 1;
      else
        v6 = grfFlags & 0xFFFFFFFE;
      if ( grfFlags & 1 )
        v7 = v6 | 2;
      else
        v7 = v6 & 0xFFFFFFFD;
      if ( grfFlags & 8 )
        v8 = v7 | 4;
      else
        v8 = v7 & 0xFFFFFFFB;
      if ( grfFlags & 4 )
        v9 = v8 | 8;
      else
        v9 = v8 & 0xFFFFFFF7;
      grfFlags = v9;
    }
  }
  return DrawEdge(hdc, &qrc, edge, grfFlags);
}

//----- (6F78896B) --------------------------------------------------------
BOOL __stdcall TV_ShouldItemDrawGray(int a1, int a2, char a3)
{
  return a3 & 0x20
      || !*(_DWORD *)(a1 + 48) && *(_BYTE *)(a2 + 8) & 2 && !(*(_BYTE *)(a1 + 36) & 4) && *(_BYTE *)(a1 + 8) & 0x20;
}

//----- (6F788993) --------------------------------------------------------
BOOL __stdcall TV_ShouldItemDrawBlue(int a1, int a2, char a3)
{
  int v3; // ecx@1

  v3 = *(_DWORD *)(a2 + 8);
  return v3 & 8 || !*(_DWORD *)(a1 + 48) && !(a3 & 0x20) && v3 & 2 && *(_BYTE *)(a1 + 36) & 4;
}

//----- (6F7889CD) --------------------------------------------------------
BOOL __stdcall DPA_Sort(HDPA hdpa, PFNDACOMPARE pfnCompare, LPARAM lParam)
{
  int v3; // ecx@1
  int v5; // [sp+0h] [bp-14h]@1
  PFNDACOMPARE v6; // [sp+4h] [bp-10h]@1
  LPARAM v7; // [sp+8h] [bp-Ch]@1
  int v8; // [sp+Ch] [bp-8h]@1

  v3 = *(_DWORD *)hdpa;
  v5 = *((_DWORD *)hdpa + 1);
  v6 = pfnCompare;
  v7 = lParam;
  v8 = v3;
  return DPA_MergeSort((int)&v5);
}

//----- (6F788A01) --------------------------------------------------------
int __stdcall DPA_MergeSort(int a1)
{
  signed int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 + 12);
  if ( v1 )
  {
    result = PrivateLocalAllocArray(v1 / 2, 4u);
    *(_DWORD *)(a1 + 16) = result;
    if ( !result )
      return result;
    DPA_MergeSort2(a1, 0, *(_DWORD *)(a1 + 12));
    LocalFree(*(HLOCAL *)(a1 + 16));
  }
  return 1;
}

//----- (6F788A46) --------------------------------------------------------
int __stdcall DPA_MergeSort2(int a1, int a2, signed int a3)
{
  int result; // eax@1
  int v4; // edi@4

  result = a3 - 1;
  if ( a3 != 1 )
  {
    if ( a3 == 2 )
    {
      v4 = 4 * a2;
      result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(a1 + 4))(
                 *(_DWORD *)(4 * a2 + *(_DWORD *)a1),
                 *(_DWORD *)(4 * a2 + *(_DWORD *)a1 + 4),
                 *(_DWORD *)(a1 + 8));
      if ( result > 0 )
      {
        **(_DWORD **)(a1 + 16) = *(_DWORD *)(v4 + *(_DWORD *)a1);
        *(_DWORD *)(v4 + *(_DWORD *)a1) = *(_DWORD *)(v4 + *(_DWORD *)a1 + 4);
        result = **(_DWORD **)(a1 + 16);
        *(_DWORD *)(*(_DWORD *)a1 + v4 + 4) = result;
      }
    }
    else
    {
      DPA_MergeSort2(a1, a2, a3 / 2);
      DPA_MergeSort2(a1, a2 + a3 / 2, a3 - a3 / 2);
      result = (int)DPA_MergeThem(a1, a2, a3);
    }
  }
  return result;
}

//----- (6F788C1C) --------------------------------------------------------
void __stdcall TV_OnStyleChanged(HDC hdc, int a2, int a3)
{
  int v3; // eax@2
  int v4; // ebx@4
  unsigned int v5; // eax@4
  int v6; // eax@19
  int v7; // eax@21

  if ( a2 == -16 )
  {
    TV_DismissEdit((int)hdc, 0);
    v3 = *(_DWORD *)(a3 + 4);
    if ( v3 & 2 )
      v3 &= 0xFFFFEFFF;
    v4 = v3 ^ *((_DWORD *)hdc + 2);
    v5 = v3 & 0xFFFFFFBF;
    *((_DWORD *)hdc + 2) = v5;
    *((_DWORD *)hdc + 2) = v5 | *(_DWORD *)(a3 + 4) & 0x40;
    if ( v4 & 7 )
      TV_CreateIndentBmps(hdc);
    if ( v4 & 0x100 && *((_DWORD *)hdc + 2) & 0x100 )
      TV_InitCheckBoxes(hdc);
    if ( (char)v4 < 0 )
    {
      if ( *((_BYTE *)hdc + 8) & 0x80 )
      {
        DestroyWindow(*((HWND *)hdc + 56));
        *((_DWORD *)hdc + 56) = 0;
      }
      else
      {
        TV_CreateToolTips((int)hdc);
      }
    }
    if ( v4 & 0x200 && !(*((_DWORD *)hdc + 2) & 0x200) )
    {
      v6 = *((_DWORD *)hdc + 15);
      if ( v6 )
      {
        TV_InvalidateItem((int)hdc, v6, 5u);
        *((_DWORD *)hdc + 15) = 0;
      }
    }
    TV_ScrollBarsAfterSetWidth((int)hdc, 0);
  }
  else if ( a2 == -20 )
  {
    v7 = *((_DWORD *)hdc + 2);
    if ( ((unsigned __int8)v7 ^ (unsigned __int8)(*(_DWORD *)(a3 + 4) >> 7)) & 0x40 )
    {
      *((_DWORD *)hdc + 2) = v7 ^ 0x40;
      TV_DismissEdit((int)hdc, 0);
      DestroyWindow(*((HWND *)hdc + 56));
      *((_DWORD *)hdc + 56) = 0;
      TV_CreateToolTips((int)hdc);
    }
  }
}

//----- (6F788CA3) --------------------------------------------------------
signed int __stdcall TV_DismissEdit(int a1, signed int a2)
{
  bool v2; // zf@1
  HWND v3; // ebx@2
  int v5; // eax@9
  int v6; // eax@10
  int v7; // edi@15
  WCHAR *v8; // eax@15
  int v9; // ecx@16
  LPARAM lParam; // [sp+8h] [bp-248h]@18
  int v11; // [sp+14h] [bp-23Ch]@16
  int v12; // [sp+18h] [bp-238h]@16
  WCHAR *v13; // [sp+24h] [bp-22Ch]@18
  int v14; // [sp+28h] [bp-228h]@17
  int v15; // [sp+38h] [bp-218h]@16
  HWND hWnd; // [sp+3Ch] [bp-214h]@2
  HWND v17; // [sp+40h] [bp-210h]@1
  WCHAR String; // [sp+44h] [bp-20Ch]@17

  v2 = (*(_BYTE *)(a1 + 36) & 0x80) == 0;
  v17 = (HWND)1;
  if ( !v2 )
    return 0;
  v3 = *(HWND *)(a1 + 216);
  hWnd = v3;
  if ( !v3 )
  {
    TV_CancelEditTimer(a1);
    return 1;
  }
  if ( !IsWindowVisible(*(HWND *)a1) )
    a2 = 1;
  v5 = GetDlgCtrlID(v3);
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      if ( v6 == 1 )
        return 1;
      goto LABEL_15;
    }
  }
  else
  {
    a2 = 1;
  }
  SetWindowLongW(v3, -12, 2);
LABEL_15:
  v7 = *(_DWORD *)(a1 + 56);
  v8 = 0;
  if ( v7 )
  {
    v9 = *(_DWORD *)(v7 + 16);
    v12 = *(_DWORD *)(a1 + 56);
    v15 = v9;
    v11 = 0;
    if ( !a2 )
    {
      GetWindowTextW(hWnd, &String, 260);
      v11 |= 1u;
      v14 = 260;
      v3 = hWnd;
      v8 = &String;
    }
    v13 = v8;
    TV_InvalidateItem(a1, v7, 5u);
    *(_DWORD *)(a1 + 36) |= 0x80u;
    ShowWindow(v3, 0);
    *(_DWORD *)(a1 + 36) &= 0xFFFFFF7F;
    v17 = CCSendNotify(a1, -460, (LPARAM)&lParam);
    if ( v17 && !a2 && v12 )
    {
      if ( *(_DWORD *)(v7 + 12) == -1 )
      {
        CCSendNotify(a1, -453, (LPARAM)&lParam);
      }
      else
      {
        v11 = 1;
        TV_SetItem(a1, (int)&v11);
      }
    }
  }
  if ( v3 == *(HWND *)(a1 + 216) )
  {
    *(_DWORD *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 216) = 0;
  }
  DestroyWindow(v3);
  return (signed int)v17;
}

//----- (6F788D03) --------------------------------------------------------
BOOL __stdcall TV_CancelEditTimer(int a1)
{
  BOOL result; // eax@3

  if ( *(_BYTE *)(a1 + 36) & 8 )
  {
    result = KillTimer(*(HWND *)a1, 0x2Au);
    *(_DWORD *)(a1 + 36) &= 0xFFFFFFF7;
  }
  return result;
}

//----- (6F788D38) --------------------------------------------------------
signed int __stdcall TV_SetItemA(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@4
  LPCSTR v4; // eax@6
  signed int v5; // ebx@7
  signed int result; // eax@9

  v2 = 0;
  if ( a2
    && a2 != -1
    && *(_BYTE *)a2 & 1
    && (v3 = *(_DWORD *)(a2 + 16)) != 0
    && v3 != -1
    && (v2 = *(_DWORD *)(a2 + 16),
        v4 = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a2 + 16)),
        (*(_DWORD *)(a2 + 16) = v4) == 0) )
  {
    *(_DWORD *)(a2 + 16) = v2;
    result = -1;
  }
  else
  {
    v5 = TV_SetItem(a1, a2);
    if ( v2 )
    {
      FreeProducedString(*(HLOCAL *)(a2 + 16));
      *(_DWORD *)(a2 + 16) = v2;
    }
    result = v5;
  }
  return result;
}

//----- (6F788DAF) --------------------------------------------------------
int __stdcall TV_SortChildren(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-Ch]@1

  v4 = a2;
  return TV_SortCB(a1, (LPARAM)&v4, a3, 0);
}

//----- (6F788DD7) --------------------------------------------------------
int __stdcall DrawBody(HDC hdc, int cy, int a3, int a4, int a5, WPARAM wParam, UINT options, int a8)
{
  int v8; // ebx@1
  int v9; // edi@1
  int v10; // ecx@2
  int v11; // esi@3
  const WCHAR *v12; // eax@3
  int v13; // eax@7
  int v14; // edi@7
  int v15; // ecx@9
  unsigned int v16; // eax@11
  int v17; // eax@13
  int result; // eax@17
  COLORREF v19; // eax@22
  unsigned __int16 v20; // ax@23
  int v21; // eax@24
  struct _IMAGELIST *v22; // eax@31
  int v23; // eax@33
  COLORREF v24; // eax@34
  int v25; // ecx@35
  int v26; // edi@35
  WCHAR *v27; // ST0C_4@35
  int v28; // edi@37
  UINT v29; // ecx@38
  LPARAM lParam; // [sp+Ch] [bp-54h]@23
  int v31; // [sp+10h] [bp-50h]@23
  int v32; // [sp+14h] [bp-4Ch]@23
  int v33; // [sp+18h] [bp-48h]@23
  int v34; // [sp+1Ch] [bp-44h]@23
  HWND v35; // [sp+20h] [bp-40h]@23
  HDC v36; // [sp+24h] [bp-3Ch]@23
  int v37; // [sp+28h] [bp-38h]@23
  int v38; // [sp+2Ch] [bp-34h]@23
  int v39; // [sp+30h] [bp-30h]@23
  int v40; // [sp+34h] [bp-2Ch]@23
  int v41; // [sp+38h] [bp-28h]@26
  struct tagDRAWTEXTPARAMS dtp; // [sp+3Ch] [bp-24h]@35
  COLORREF v43; // [sp+50h] [bp-10h]@33
  COLORREF color; // [sp+54h] [bp-Ch]@34
  int mode; // [sp+58h] [bp-8h]@34
  int v46; // [sp+5Ch] [bp-4h]@9
  int cya; // [sp+6Ch] [bp+Ch]@3
  int v48; // [sp+70h] [bp+10h]@7
  WPARAM wParama; // [sp+7Ch] [bp+1Ch]@23

  v8 = cy;
  v9 = a5 == *(_DWORD *)(cy + 60);
  if ( a5 == *(_DWORD *)(cy + 160) && !(*(_BYTE *)(cy + 8) & 8) )
  {
    v19 = GetSysColor(26);
    SetTextColor(hdc, v19);
  }
  v10 = *(_DWORD *)(cy + 8);
  if ( v10 & 0x2000 )
  {
    v20 = GetDlgCtrlID(*(HWND *)cy);
    v31 = v20;
    wParama = v20;
    v32 = a5;
    lParam = 101;
    v33 = 1;
    v34 = v9 != 0;
    v35 = *(HWND *)cy;
    v36 = hdc;
    v37 = *(_DWORD *)a4;
    v38 = *(_DWORD *)(a4 + 4);
    v39 = *(_DWORD *)(a4 + 8);
    v40 = *(_DWORD *)(a4 + 12);
    Tab_VDFlipRect(cy, (int)&v37);
    if ( *(_DWORD *)(cy + 48) > 4u )
      v21 = a3 + 56;
    else
      v21 = *(_DWORD *)(a3 + 56);
    v41 = v21;
    SendMessageW(*(HWND *)(cy + 4), 0x2Bu, wParama, (LPARAM)&lParam);
    goto LABEL_17;
  }
  v11 = a3;
  v12 = *(const WCHAR **)(a3 + 44);
  cya = 0;
  if ( v12 && (char)v10 >= 0 && StrChrW(v12, 0x26u) )
  {
    cya = 1;
LABEL_28:
    if ( !wParam )
      Tab_ExtTextOut(hdc, 0, 0, 2u, a4, 0, 0, 0, v8);
    goto LABEL_7;
  }
  if ( !*(_DWORD *)(a3 + 44) )
    goto LABEL_28;
LABEL_7:
  v13 = options + *(_DWORD *)a3 + *(_DWORD *)(a3 + 32);
  v14 = options + *(_DWORD *)a3 + *(_DWORD *)(a3 + 20);
  v48 = options + *(_DWORD *)a3 + *(_DWORD *)(a3 + 32);
  if ( *(_DWORD *)(v11 + 44) )
  {
    if ( *(_DWORD *)(v8 + 8) & 0x80 )
    {
      if ( !(*(_DWORD *)(v8 + 8) & 2) )
      {
        v22 = *(struct _IMAGELIST **)(v8 + 128);
        v14 += *(_DWORD *)(v11 + 28);
        if ( v22 )
        {
          if ( *(_DWORD *)(v11 + 16) != -1 )
          {
            VertImageList_GetIconSize(v22, (int *)&options, (int *)&v43, *(_DWORD *)(v8 + 8) & 0x80);
            v23 = v48 + *(_DWORD *)(v11 + 28);
            v48 = v14 - options;
            v14 = v23;
          }
        }
      }
    }
    v15 = *(_DWORD *)(v11 + 48) & 2;
    v46 = *(_DWORD *)(v11 + 48) & 2;
    if ( v46 )
    {
      mode = SetBkMode(hdc, 2);
      color = SetBkColor(hdc, g_clrHighlight);
      v24 = SetTextColor(hdc, g_clrHighlightText);
      v15 = v46;
      v43 = v24;
    }
    if ( cya )
    {
      v25 = *(_DWORD *)(v11 + 4) + *(_DWORD *)(v11 + 24);
      dtp.iLeftMargin = v14 - *(_DWORD *)a4;
      v26 = *(_DWORD *)(a4 + 4);
      *(_DWORD *)(a4 + 4) = a8 + v25;
      v27 = *(WCHAR **)(v11 + 44);
      dtp.cbSize = 20;
      dtp.iRightMargin = 0;
      Tab_DrawTextEx(hdc, v27, -1, a4, 0x20u, &dtp, v8);
      *(_DWORD *)(a4 + 4) = v26;
    }
    else
    {
      v16 = *(_DWORD *)(v11 + 52) | ((*(_DWORD *)(v8 + 24) & 0x2000 | 0x100u) >> 6);
      options = *(_DWORD *)(v11 + 52) | ((*(_DWORD *)(v8 + 24) & 0x2000 | 0x100u) >> 6);
      if ( !wParam || v15 )
        options = v16 | 2;
      v17 = lstrlenW(*(LPCWSTR *)(v11 + 44));
      Tab_ExtTextOut(
        hdc,
        v14,
        a8 + *(_DWORD *)(v11 + 4) + *(_DWORD *)(v11 + 24),
        options,
        a4,
        *(LPCWSTR *)(v11 + 44),
        v17,
        0,
        v8);
    }
    if ( v46 )
    {
      SetBkMode(hdc, mode);
      SetBkColor(hdc, color);
      SetTextColor(hdc, v43);
    }
    v13 = v48;
  }
  if ( *(_DWORD *)(v8 + 128) )
  {
    v28 = *(_DWORD *)(v11 + 16);
    if ( v28 != -1 )
    {
      v29 = wParam != 0;
      if ( *(_BYTE *)(v11 + 48) & 2 )
        v29 |= 4u;
      Tab_ImageList_Draw(v8, v28, hdc, v13, a8 + *(_DWORD *)(v11 + 4) + *(_DWORD *)(v11 + 36), v29);
    }
  }
LABEL_17:
  result = a5;
  if ( a5 == *(_DWORD *)(v8 + 160) && !(*(_BYTE *)(v8 + 8) & 8) )
    result = SetTextColor(hdc, g_clrBtnText);
  return result;
}

//----- (6F788F07) --------------------------------------------------------
BOOL __stdcall Tab_ExtTextOut(HDC hdc, int x, int y, UINT options, int a5, LPCWSTR lpString, UINT c, INT *lpDx, int a9)
{
  int v9; // eax@1
  int v10; // eax@2
  RECT rect; // [sp+Ch] [bp-10h]@1
  LONG xa; // [sp+28h] [bp+Ch]@3
  LONG ya; // [sp+2Ch] [bp+10h]@3

  rect.right = x;
  rect.left = x;
  v9 = *(_DWORD *)(a9 + 8);
  if ( v9 & 2 && (char)v9 >= 0 )
    v10 = *(_DWORD *)(a9 + 152) + y;
  else
    v10 = y;
  rect.bottom = v10;
  rect.top = v10;
  Tab_VDFlipRect(a9, (int)&rect);
  xa = rect.left;
  rect.left = *(_DWORD *)a5;
  rect.top = *(_DWORD *)(a5 + 4);
  ya = rect.bottom;
  rect.right = *(_DWORD *)(a5 + 8);
  rect.bottom = *(_DWORD *)(a5 + 12);
  Tab_VDFlipRect(a9, (int)&rect);
  return ExtTextOutW(hdc, xa, ya, options, &rect, lpString, c, lpDx);
}

//----- (6F788F87) --------------------------------------------------------
signed int __stdcall TV_ScrollItems(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int dy; // [sp+8h] [bp-48h]@1
  int v7; // [sp+Ch] [bp-44h]@1
  int v8; // [sp+10h] [bp-40h]@1
  int v9; // [sp+14h] [bp-3Ch]@1
  int v10; // [sp+18h] [bp-38h]@1
  int *v11; // [sp+1Ch] [bp-34h]@1
  int *v12; // [sp+20h] [bp-30h]@1
  int v13; // [sp+24h] [bp-2Ch]@1
  int v14; // [sp+28h] [bp-28h]@1
  int v15; // [sp+2Ch] [bp-24h]@1
  int v16; // [sp+30h] [bp-20h]@1
  int v17; // [sp+34h] [bp-1Ch]@1
  int v18; // [sp+38h] [bp-18h]@1
  int v19; // [sp+3Ch] [bp-14h]@1
  int v20; // [sp+40h] [bp-10h]@1
  int v21; // [sp+44h] [bp-Ch]@1
  int v22; // [sp+48h] [bp-8h]@1
  int v23; // [sp+4Ch] [bp-4h]@1

  v4 = *(_WORD *)(a1 + 182);
  v8 = *(_DWORD *)a1;
  v21 = v4 * (a3 + 1);
  v22 = *(_WORD *)(a1 + 190);
  v23 = *(_WORD *)(a1 + 192);
  v7 = 6;
  v15 = 6;
  v16 = *(_DWORD *)(a1 + 212);
  v17 = 1;
  v18 = 1;
  v20 = 0;
  v9 = 0;
  v13 = 0;
  v14 = 0;
  dy = 56;
  v10 = a2 * v4 * (2 * (a4 != 0) - 1);
  v11 = &v20;
  v12 = &v20;
  v19 = 0;
  SmoothScrollWindow((int)&dy);
  return TV_UpdateToolTip(a1);
}

//----- (6F78902D) --------------------------------------------------------
signed int __stdcall TV_UpdateToolTip(int a1)
{
  signed int result; // eax@2

  if ( *(_DWORD *)(a1 + 224) && *(_BYTE *)(a1 + 36) & 0x10 )
    result = TV_UpdateToolTipTarget(a1);
  else
    result = 1;
  return result;
}

//----- (6F78904E) --------------------------------------------------------
int __stdcall TV_SmoothSetTopItem(int a1, int nPos, int a3)
{
  int v3; // edi@1
  int v4; // eax@3
  unsigned int v5; // ecx@4
  unsigned int v6; // edx@4
  int v7; // eax@7
  int v8; // ecx@8
  int result; // eax@9
  int v10; // edx@11
  unsigned int v11; // ecx@13
  int v12; // edi@15
  int v13; // ecx@15
  bool v14; // zf@15
  HWND v15; // edx@16
  int v16; // edx@16
  int dy; // [sp+8h] [bp-38h]@16
  int v18; // [sp+Ch] [bp-34h]@16
  HWND v19; // [sp+10h] [bp-30h]@16
  int v20; // [sp+14h] [bp-2Ch]@16
  int v21; // [sp+18h] [bp-28h]@16
  int v22; // [sp+1Ch] [bp-24h]@16
  int v23; // [sp+20h] [bp-20h]@16
  int v24; // [sp+24h] [bp-1Ch]@16
  int v25; // [sp+28h] [bp-18h]@16
  int v26; // [sp+2Ch] [bp-14h]@16
  int v27; // [sp+30h] [bp-10h]@16
  int v28; // [sp+34h] [bp-Ch]@16
  int v29; // [sp+38h] [bp-8h]@16
  int v30; // [sp+3Ch] [bp-4h]@16
  int nPosa; // [sp+4Ch] [bp+Ch]@15

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8);
  if ( !v3 )
    goto LABEL_20;
  if ( *(_DWORD *)(a1 + 8) & 0x2000
    || (v4 = nPos, nPos == -1)
    || (v5 = *(_WORD *)(a1 + 196), v6 = *(_DWORD *)(a1 + 200), v6 <= v5) )
  {
    v4 = 0;
  }
  else
  {
    v10 = v6 - v5;
    if ( nPos > (unsigned int)v10 )
      v4 = v10;
  }
  if ( v4 )
  {
    v11 = *(_DWORD *)(a1 + 200);
    if ( v4 >= v11 )
      v4 = v11 - 1;
  }
  v7 = TV_GetShownIndexItem(v3, v4);
  if ( v7 && (v8 = *(_DWORD *)(a1 + 208), v8 != v7) )
  {
    v12 = *(_WORD *)(v7 + 28);
    v13 = *(_WORD *)(v8 + 28);
    v14 = (*(_BYTE *)(a1 + 36) & 0x10) == 0;
    nPosa = *(_WORD *)(v7 + 28);
    *(_DWORD *)(a1 + 208) = v7;
    if ( !v14 )
    {
      v15 = *(HWND *)a1;
      v20 = 0;
      v19 = v15;
      v16 = (v13 - v12) * *(_WORD *)(a1 + 182);
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v25 = 0;
      v18 = 6;
      v27 = *(_DWORD *)(a1 + 212);
      dy = 56;
      v21 = v16;
      v26 = a3 | 6;
      v28 = 1;
      v29 = 1;
      v30 = 0;
      SmoothScrollWindow((int)&dy);
    }
    SetScrollPos(*(HWND *)a1, 1, nPosa, 1);
    TV_UpdateToolTip(a1);
    result = 1;
  }
  else
  {
LABEL_20:
    result = 0;
  }
  return result;
}

//----- (6F7890BD) --------------------------------------------------------
int __stdcall TV_GetShownIndexItem(int a1, unsigned int a2)
{
  int i; // ecx@1
  int result; // eax@3
  unsigned int v4; // edx@4

  for ( i = a1; i; i = *(_DWORD *)(i + 8) )
  {
    for ( result = i; result; result = *(_DWORD *)(result + 4) )
    {
      v4 = *(_WORD *)(result + 28);
      if ( v4 > a2 )
        break;
      i = result;
      if ( v4 + *(_WORD *)(result + 32) > a2 )
        return result;
    }
  }
  return 0;
}

//----- (6F789118) --------------------------------------------------------
HFONT __stdcall TV_CreateBoldFont(int a1)
{
  HFONT result; // eax@2
  char pv; // [sp+4h] [bp-60h]@2
  int v3; // [sp+14h] [bp-50h]@2

  if ( *(_DWORD *)(a1 + 124) )
    DeleteObject(*(HGDIOBJ *)(a1 + 124));
  GetObjectW(*(HANDLE *)(a1 + 116), 92, &pv);
  v3 = 700;
  result = CreateFontIndirectW((const LOGFONTW *)&pv);
  *(_DWORD *)(a1 + 124) = result;
  return result;
}

//----- (6F789193) --------------------------------------------------------
void __stdcall RecalcTooltipRects(int a1)
{
  int v1; // esi@1
  HWND v2; // eax@3
  HWND v3; // ST04_4@6
  HWND v4; // ST04_4@7
  LPARAM lParam; // [sp+8h] [bp-2Ch]@3
  HWND v6; // [sp+10h] [bp-24h]@3
  int v7; // [sp+14h] [bp-20h]@5
  struct tagRECT rc; // [sp+18h] [bp-1Ch]@5
  int v9; // [sp+2Ch] [bp-8h]@3
  int v10; // [sp+3Ch] [bp+8h]@4
  int v11; // [sp+3Ch] [bp+8h]@7

  v1 = a1;
  if ( *(_DWORD *)(a1 + 36) )
  {
    v2 = *(HWND *)a1;
    v9 = -1;
    lParam = 44;
    v6 = v2;
    if ( *(_BYTE *)(a1 + 84) )
    {
      v10 = 0;
      if ( *(_DWORD *)(v1 + 112) > 0u )
      {
        do
        {
          v7 = v10;
          Status_GetRect(v1, v10, (int)&rc);
          SendMessageW(*(HWND *)(v1 + 36), 0x434u, 0, (LPARAM)&lParam);
          ++v10;
        }
        while ( (unsigned int)v10 < *(_DWORD *)(v1 + 112) );
      }
      SetRect(&rc, 0, 0, 0, 0);
      v3 = *(HWND *)(v1 + 36);
      v7 = 255;
      SendMessageW(v3, 0x434u, 0, (LPARAM)&lParam);
    }
    else
    {
      GetClientRect(v2, &rc);
      InflateRect(&rc, -g_cxBorder, -g_cyBorder);
      v4 = *(HWND *)(a1 + 36);
      v7 = 255;
      SendMessageW(v4, 0x434u, 0, (LPARAM)&lParam);
      SetRect(&rc, 0, 0, 0, 0);
      v11 = 0;
      if ( *(_DWORD *)(v1 + 112) > 0u )
      {
        do
        {
          v7 = v11;
          SendMessageW(*(HWND *)(v1 + 36), 0x434u, 0, (LPARAM)&lParam);
          ++v11;
        }
        while ( (unsigned int)v11 < *(_DWORD *)(v1 + 112) );
      }
    }
  }
}

//----- (6F789224) --------------------------------------------------------
int __stdcall CreateMask(int a1, int yTop, int w, int h, int a5, LPCWSTR lpchText)
{
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int result; // eax@4
  int v10; // edx@4
  int v11; // eax@6
  int v12; // ecx@9
  int v13; // edx@9
  int v14; // ecx@10
  int v15; // ecx@11
  int v16; // edx@11
  IMAGELISTDRAWPARAMS pimldp; // [sp+Ch] [bp-48h]@3
  int v18; // [sp+50h] [bp-4h]@1
  int yTopa; // [sp+60h] [bp+Ch]@6
  struct _IMAGELIST *lpchTexta; // [sp+70h] [bp+1Ch]@1
  const WCHAR *lpchTextb; // [sp+70h] [bp+1Ch]@4

  v6 = (int)lpchText;
  v7 = *(_DWORD *)lpchText;
  v18 = *((_DWORD *)lpchText + 1);
  PatBlt(*(HDC *)(v7 + 40), 0, 0, w, h, 0xFF0062u);
  v8 = TBGetImageList(v7, 0, *((_DWORD *)lpchText + 4));
  lpchTexta = (struct _IMAGELIST *)v8;
  if ( a5 && v8 )
  {
    memset(&pimldp.himl, 0, 0x40u);
    pimldp.himl = lpchTexta;
    pimldp.i = *(_DWORD *)(v6 + 20);
    pimldp.hdcDst = *(HDC *)(v7 + 40);
    pimldp.x = a1;
    pimldp.y = yTop;
    pimldp.rgbBk = g_clrBtnFace;
    pimldp.cbSize = 68;
    pimldp.cx = 0;
    pimldp.cy = 0;
    pimldp.xBitmap = 0;
    pimldp.yBitmap = 0;
    pimldp.rgbFg = -16777216;
    pimldp.fStyle = 80;
    pimldp.dwRop = 13369376;
    ImageList_DrawIndirect(&pimldp);
    pimldp.rgbBk = g_clrBtnHighlight;
    pimldp.fStyle = 96;
    pimldp.dwRop = 15597702;
    ImageList_DrawIndirect(&pimldp);
  }
  result = TB_StrForButton(v7, v18);
  lpchTextb = (const WCHAR *)result;
  if ( result )
  {
    v11 = 1;
    yTopa = 1;
    if ( *(_DWORD *)(v7 + 8) & 0x1000 )
    {
      if ( *(_DWORD *)v10 != -2 || !(*(_BYTE *)(v10 + 9) & 0x10) )
      {
        v12 = *(_DWORD *)(v7 + 156);
        v13 = *(_DWORD *)(v7 + 104);
        v11 = v13 + v12 + 1;
        w -= v12 + v13;
      }
    }
    else
    {
      v14 = *(_DWORD *)(v7 + 108);
      yTopa = v14 + 2;
      h += -1 - v14;
    }
    v15 = w;
    v16 = h;
    if ( !(*(_BYTE *)(v7 + 36) & 4) )
    {
      v15 = w - g_cxEdge;
      v16 = h - g_cyEdge;
    }
    result = DrawString(*(HDC *)(v7 + 40), v11, yTopa, v15, v16, lpchTextb, 0, v6);
  }
  return result;
}

//----- (6F789533) --------------------------------------------------------
signed int __stdcall InitAnimateClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.cbClsExtra = 0;
  WndClass.hIcon = 0;
  WndClass.lpfnWndProc = (WNDPROC)AnimateWndProc;
  WndClass.lpszClassName = c_szAnimateClass;
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = a1;
  WndClass.lpszMenuName = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = (HBRUSH)16;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F7E6F48: using guessed type wchar_t c_szAnimateClass[13];

//----- (6F789596) --------------------------------------------------------
signed int __stdcall InitHotKeyClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.hInstance = a1;
  WndClass.hIcon = 0;
  WndClass.hCursor = 0;
  WndClass.hbrBackground = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.lpfnWndProc = (WNDPROC)HotKeyWndProc;
  WndClass.lpszClassName = L"msctls_hotkey32";
  WndClass.style = 0x4000;
  WndClass.cbWndExtra = 24;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F7895E4: using guessed type wchar_t s_szHOTKEY_CLASS[16];

//----- (6F789609) --------------------------------------------------------
signed int __stdcall ListView_Init(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = ListView_WndProc;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"SysListView32";
  WndClass.hbrBackground = (HBRUSH)6;
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}
// 6F789668: using guessed type wchar_t c_szListViewClass[14];

//----- (6F7896FE) --------------------------------------------------------
signed int __stdcall CCDllGetVersion(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@2
  int v3; // edi@3
  int v4; // eax@8
  unsigned int v5; // ecx@8
  int v6; // eax@8
  char Dst; // [sp+4h] [bp-DCh]@8
  unsigned __int16 v8; // [sp+Ah] [bp-D6h]@8

  result = -2147024809;
  if ( a1 )
  {
    v2 = *(_DWORD *)a1;
    if ( *(_DWORD *)a1 == 20 || v2 == 32 )
    {
      v3 = a1 + 4;
      memcpy((void *)(a1 + 4), dword_6F789764, v2 - 4);
      if ( *(_DWORD *)a1 == 32 )
      {
        memset(&Dst, 0, 0xD8u);
        RtlGetVersionResourceFromSelf((struct _RTL_VERSION_RESOURCE *)&Dst);
        v4 = *(_DWORD *)(a1 + 8) | (*(_DWORD *)v3 << 16);
        v5 = __PAIR__((unsigned __int64)*(_DWORD *)v3 >> 16, v4) >> 16;
        v6 = *(_DWORD *)(a1 + 12) | (v4 << 16);
        *(_DWORD *)(a1 + 24) = v8 | (v6 << 16);
        *(_DWORD *)(a1 + 28) = __PAIR__(v5, v6) >> 16;
      }
      result = 0;
    }
  }
  return result;
}
// 6F789764: using guessed type int dword_6F789764[5];

//----- (6F789793) --------------------------------------------------------
int __stdcall DeleteButton(HDC hDC, int a2)
{
  int v2; // esi@2
  int v3; // eax@3
  int v4; // eax@4
  int v5; // eax@4
  HWND v6; // eax@5
  int v7; // eax@6
  unsigned int v8; // ecx@6
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  char v12; // cl@7
  int v13; // ecx@9
  int result; // eax@12
  int v15; // ecx@25
  HWND v16; // eax@26
  LPARAM lParam; // [sp+8h] [bp-84h]@25
  int v18; // [sp+10h] [bp-7Ch]@25
  int v19; // [sp+14h] [bp-78h]@25
  struct tagRECT Rect; // [sp+34h] [bp-58h]@28
  int v21; // [sp+44h] [bp-48h]@6
  int v22; // [sp+48h] [bp-44h]@1
  LPARAM v23; // [sp+4Ch] [bp-40h]@1
  char Dst; // [sp+50h] [bp-3Ch]@1
  int v25; // [sp+58h] [bp-34h]@4
  char v26; // [sp+5Ch] [bp-30h]@4

  v23 = 0;
  memset(&Dst, 0, 0x38u);
  v22 = -1;
  if ( (unsigned int)a2 >= *((_DWORD *)hDC + 33) )
    return 0;
  v2 = 28 * a2;
  if ( 28 * a2 + *((_DWORD *)hDC + 12) != *((_DWORD *)hDC + 13) )
    goto LABEL_3;
  if ( *((_DWORD *)hDC + 25) == 20 )
    *((_DWORD *)hDC + 59) |= 0x4000u;
  result = CCReleaseCapture((int)hDC);
  if ( result )
  {
    *((_DWORD *)hDC + 13) = 0;
LABEL_3:
    v3 = *((_DWORD *)hDC + 51);
    if ( v3 >= 0 && v3 < *((_DWORD *)hDC + 33) )
      v22 = *(_DWORD *)(*((_DWORD *)hDC + 12) + 28 * v3 + 4);
    MyNotifyWinEvent(32769, *(_DWORD *)hDC, -4, a2 + 1);
    v4 = v2 + *((_DWORD *)hDC + 12);
    v25 = *(_DWORD *)(v4 + 4);
    TBOutputStruct((int)hDC, v4, &v26);
    CCSendNotify((int)hDC, -715, (LPARAM)&v23);
    v5 = v2 + *((_DWORD *)hDC + 12) + 16;
    if ( *(_DWORD *)v5 != -1 && *(_DWORD *)v5 & 0xFFFF0000 )
      Str_Set(v5, 0);
    v6 = (HWND)*((_DWORD *)hDC + 16);
    if ( v6 )
    {
      v18 = *(_DWORD *)hDC;
      v15 = *((_DWORD *)hDC + 12);
      lParam = 44;
      v19 = *(_DWORD *)(v2 + v15 + 4);
      SendMessageW(v6, 0x433u, 0, (LPARAM)&lParam);
    }
    v7 = *((_DWORD *)hDC + 12);
    --*((_DWORD *)hDC + 33);
    v8 = *((_DWORD *)hDC + 33);
    v9 = v2 + v7;
    v10 = *(_BYTE *)(v9 + 8) & 0x20;
    v11 = v9 + 28;
    v21 = v9 + 28;
    if ( a2 < v8 )
    {
      while ( 1 )
      {
        v12 = *(_BYTE *)(v11 + 8);
        v21 += 28;
        v10 |= v12 & 0x20;
        ++a2;
        qmemcpy((void *)v9, (const void *)v11, 0x1Cu);
        v9 += 28;
        if ( (unsigned int)a2 >= *((_DWORD *)hDC + 33) )
          break;
        v11 = v21;
      }
    }
    v13 = *((_DWORD *)hDC + 2);
    if ( (v13 & 0x200 || *((_BYTE *)hDC + 36) & 2) && v10 )
    {
      v16 = *(HWND *)hDC;
      if ( !(v13 & 0xC) )
        v16 = GetParent(*(HWND *)hDC);
      GetWindowRect(v16, &Rect);
      if ( *((_DWORD *)hDC + 2) & 0x200 )
        WrapToolbar(hDC, Rect.right - Rect.left, (int)&Rect, 0);
      else
        WrapToolbarCol((int)hDC, *((_DWORD *)hDC + 65), &Rect, 0);
    }
    if ( v22 != -1 )
      *((_DWORD *)hDC + 51) = PositionFromID((int)hDC, v22);
    InvalidateRect(*(HWND *)hDC, 0, 1);
    TBInvalidateItemRects((int)hDC);
    result = 1;
  }
  return result;
}

//----- (6F7898FD) --------------------------------------------------------
int __stdcall SetStatusParts(SIZE_T uBytes, int a2, size_t cchDest)
{
  int v3; // esi@1
  int v4; // edx@1
  int v5; // ebx@2
  int v6; // edx@2
  size_t v7; // edi@3
  int v8; // ecx@3
  int v9; // eax@4
  int result; // eax@9
  int v11; // ebx@13
  int v12; // edi@13
  int v13; // ecx@16
  int v14; // edx@16
  int v15; // ecx@16
  int v16; // eax@17
  int v17; // eax@23
  int v18; // edi@23
  HWND v19; // ST04_4@24
  LPARAM lParam; // [sp+Ch] [bp-30h]@12
  char v21; // [sp+10h] [bp-2Ch]@12
  int v22; // [sp+14h] [bp-28h]@23
  int v23; // [sp+18h] [bp-24h]@24
  int v24; // [sp+30h] [bp-Ch]@23
  int v25; // [sp+38h] [bp-4h]@1
  signed int savedregs; // [sp+3Ch] [bp+0h]@20
  int uBytesa; // [sp+44h] [bp+8h]@2

  v3 = uBytes;
  v4 = *(_DWORD *)(uBytes + 112);
  v25 = 0;
  if ( a2 == v4 )
  {
LABEL_2:
    v5 = a2;
    v6 = 0;
    uBytesa = 0;
    if ( a2 > 0 )
    {
      v7 = cchDest;
      v8 = *(_DWORD *)(v3 + 120) + 8;
      do
      {
        v9 = *(_DWORD *)v7;
        if ( (*(_DWORD *)v7 != -1 || uBytesa != v5 - 1) && v9 < v6 )
          v9 = v6;
        if ( *(_DWORD *)v8 != v9 )
        {
          v25 = 1;
          *(_DWORD *)v8 = v9;
        }
        ++uBytesa;
        v5 = a2;
        v8 += 32;
        v7 += 4;
        v6 = v9;
      }
      while ( uBytesa < a2 );
    }
    if ( v25 )
    {
      savedregs = 1;
      v25 = 0;
      InvalidateRect(*(HWND *)v3, 0, 1);
    }
    RecalcTooltipRects(v3);
    return 1;
  }
  lParam = 0;
  memset(&v21, 0, 0x28u);
  if ( *(_DWORD *)(uBytes + 36) )
  {
    v17 = *(_DWORD *)uBytes;
    v24 = -1;
    v18 = 0;
    lParam = 44;
    v22 = v17;
    if ( v4 > 0 )
    {
      do
      {
        v19 = *(HWND *)(uBytes + 36);
        v23 = v18;
        SendMessageW(v19, 0x433u, 0, (LPARAM)&lParam);
        ++v18;
      }
      while ( v18 < *(_DWORD *)(uBytes + 112) );
    }
  }
  v11 = *(_DWORD *)(uBytes + 112) - a2;
  v12 = 32 * a2 + *(_DWORD *)(uBytes + 120);
  v25 = 1;
  while ( v11 > 0 )
  {
    if ( (*(_DWORD *)(v12 + 4) & 0xF000) == 61440 )
      LocalFree(*(HLOCAL *)v12);
    *(_DWORD *)(v12 + 4) = 0;
    --v11;
    v12 += 32;
  }
  result = (int)CCLocalReAlloc(*(HLOCAL *)(uBytes + 120), 32 * a2);
  if ( result )
  {
    v13 = *(_DWORD *)(uBytes + 112);
    v14 = a2 - v13;
    v15 = result + 32 * v13;
    *(_DWORD *)(uBytes + 120) = result;
    if ( v14 > 0 )
    {
      v16 = v15 + 8;
      do
      {
        *(_DWORD *)(v16 - 4) = 0;
        *(_DWORD *)v16 = 0;
        --v14;
        v16 += 32;
      }
      while ( v14 > 0 );
    }
    *(_DWORD *)(uBytes + 112) = a2;
    StatusUpdateToolTips(uBytes);
    goto LABEL_2;
  }
  return result;
}

//----- (6F789A31) --------------------------------------------------------
LRESULT __stdcall StatusUpdateToolTips(int a1)
{
  LRESULT result; // eax@3
  int v2; // edi@3
  bool v3; // zf@3
  bool v4; // sf@3
  HWND v5; // ST00_4@4
  LPARAM lParam; // [sp+4h] [bp-2Ch]@3
  char v7; // [sp+8h] [bp-28h]@3
  LRESULT v8; // [sp+Ch] [bp-24h]@3
  int v9; // [sp+10h] [bp-20h]@4
  int v10; // [sp+28h] [bp-8h]@3

  if ( *(_DWORD *)(a1 + 36) )
  {
    memset(&v7, 0, 0x28u);
    result = *(_DWORD *)a1;
    v10 = -1;
    v2 = 0;
    v3 = *(_DWORD *)(a1 + 112) == 0;
    v4 = *(_DWORD *)(a1 + 112) < 0;
    lParam = 44;
    v8 = result;
    if ( !v4 && !v3 )
    {
      do
      {
        v5 = *(HWND *)(a1 + 36);
        v9 = v2;
        result = SendMessageW(v5, 0x432u, 0, (LPARAM)&lParam);
        ++v2;
      }
      while ( v2 < *(_DWORD *)(a1 + 112) );
    }
  }
  return result;
}

//----- (6F789F00) --------------------------------------------------------
void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
{
  char *v3; // esi@23
  char *v4; // edi@23
  size_t v5; // ecx@24
  const void *v6; // esi@1
  void *v7; // edi@1
  size_t v8; // ecx@4
  void *result; // eax@10

  v6 = Src;
  v7 = Dst;
  if ( Dst <= Src || Dst >= (char *)Src + Size )
  {
    if ( Size >= 0x100
      && __sse2_available
      && (v6 = Src, v7 = Dst, ((unsigned __int8)Dst & 0xF) == ((unsigned __int8)Src & 0xF)) )
    {
      result = sub_6F77E8C0(Dst, Src, Size);
    }
    else
    {
      if ( (unsigned __int8)v7 & 3 )
      {
        if ( Size >= 4 )
          JUMPOUT(__CS__, *((_DWORD *)&loc_6F789C4C + ((unsigned __int8)v7 & 3) + 1));
        JUMPOUT(__CS__, dword_6F789D28[Size - 4]);
      }
      v8 = Size >> 2;
      if ( Size >> 2 >= 8 )
      {
        qmemcpy(v7, v6, 4 * v8);
        switch ( Size & 3 )
        {
          case 0u:
            break;
        }
      }
      else
      {
        switch ( v8 )
        {
          case 0u:
            goto LABEL_10;
          case 1u:
            goto LABEL_9;
          case 2u:
            goto LABEL_8;
          case 3u:
            goto LABEL_7;
          case 4u:
            goto LABEL_6;
          case 5u:
            goto LABEL_22;
          case 6u:
            break;
          case 7u:
            *((_DWORD *)v7 + v8 - 7) = *((_DWORD *)v6 + v8 - 7);
            break;
        }
        *((_DWORD *)v7 + v8 - 6) = *((_DWORD *)v6 + v8 - 6);
LABEL_22:
        *((_DWORD *)v7 + v8 - 5) = *((_DWORD *)v6 + v8 - 5);
LABEL_6:
        *((_DWORD *)v7 + v8 - 4) = *((_DWORD *)v6 + v8 - 4);
LABEL_7:
        *((_DWORD *)v7 + v8 - 3) = *((_DWORD *)v6 + v8 - 3);
LABEL_8:
        *((_DWORD *)v7 + v8 - 2) = *((_DWORD *)v6 + v8 - 2);
LABEL_9:
        *((_DWORD *)v7 + v8 - 1) = *((_DWORD *)v6 + v8 - 1);
      }
LABEL_10:
      result = Dst;
    }
  }
  else
  {
    v3 = (char *)Src + Size - 4;
    v4 = (char *)Dst + Size - 4;
    if ( (unsigned __int8)v4 & 3 )
    {
      if ( Size >= 4 )
        JUMPOUT(__CS__, dword_6F789DAC[(unsigned __int8)v4 & 3]);
      switch ( Size )
      {
        case 0u:
LABEL_31:
          result = Dst;
          break;
        case 1u:
LABEL_32:
          v4[3] = v3[3];
          result = Dst;
          break;
        case 2u:
LABEL_33:
          v4[3] = v3[3];
          v4[2] = v3[2];
          result = Dst;
          break;
        case 3u:
          goto LABEL_34;
      }
    }
    else
    {
      v5 = Size >> 2;
      if ( Size >> 2 < 8 )
      {
        switch ( -v5 )
        {
          case 0u:
            break;
        }
      }
      else
      {
        qmemcpy(v4, v3, 4 * v5);
        v3 += 4 * v5;
        v4 += 4 * v5;
      }
      switch ( Size & 3 )
      {
        case 0u:
          goto LABEL_31;
        case 1u:
          goto LABEL_32;
        case 2u:
          goto LABEL_33;
        case 3u:
          break;
      }
LABEL_34:
      v4[3] = v3[3];
      v4[2] = v3[2];
      v4[1] = v3[1];
      result = Dst;
    }
  }
  return result;
}
// 6F789D28: using guessed type int dword_6F789D28[];
// 6F789DAC: using guessed type int dword_6F789DAC[];
// 6F7E69C0: using guessed type int __sse2_available;

//----- (6F789FAA) --------------------------------------------------------
HFONT __stdcall CCCreateStatusFont()
{
  int pvParam; // [sp+0h] [bp-1F8h]@1
  LOGFONTW lf; // [sp+13Ch] [bp-BCh]@1

  pvParam = 500;
  SystemParametersInfoW(0x29u, 0x1F4u, &pvParam, 0);
  return CreateFontIndirectW(&lf);
}

//----- (6F78A06B) --------------------------------------------------------
int __stdcall InitStatusWnd(HWND hWnd, int a2)
{
  LONG v2; // esi@1
  HLOCAL v3; // eax@2
  int v4; // eax@3
  char v6; // [sp+Ch] [bp-Ch]@3

  v2 = (LONG)LocalAlloc(0x40u, 0x7Cu);
  if ( !v2 )
    return -1;
  v3 = LocalAlloc(0x40u, 0x20u);
  *(_DWORD *)(v2 + 120) = v3;
  if ( !v3 )
  {
    LocalFree((HLOCAL)v2);
    return -1;
  }
  SetWindowLongW(hWnd, 0, v2);
  CIInitialize(v2, (WPARAM)hWnd, a2);
  v4 = *(_DWORD *)(v2 + 120);
  *(_DWORD *)(v2 + 88) = -1;
  *(_DWORD *)(v2 + 84) = 255;
  *(_DWORD *)(v2 + 76) = 0;
  *(_DWORD *)(v2 + 112) = 1;
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(*(_DWORD *)(v2 + 120) + 8) = -1;
  *(_DWORD *)(v2 + 116) = -16777216;
  SBSetText(v2, 0, *(LPCWSTR *)(a2 + 36));
  *(_DWORD *)(a2 + 36) = &c_szNULL;
  NewFont((HDC)v2, 0, 0);
  SBSetBorders(v2, (int)&v6);
  if ( *(_DWORD *)(a2 + 32) & 0x100 || GetWindowLongW(*(HWND *)(a2 + 12), -16) & 0x40000 && !(*(_BYTE *)(a2 + 32) & 0xB) )
    *(_DWORD *)(v2 + 72) = g_cxVScroll + g_cxBorder;
  return 0;
}
// 6F7E69A8: using guessed type int g_cxVScroll;

//----- (6F78A136) --------------------------------------------------------
int __stdcall SBSetBorders(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = g_cyEdge;
  *(_DWORD *)(a1 + 64) = g_cxEdge;
  return result;
}

//----- (6F78A179) --------------------------------------------------------
int __stdcall SBSetFont(HDC hDC, HGDIOBJ h, int a3)
{
  int result; // eax@1

  NewFont(hDC, h, 1);
  result = 0;
  if ( a3 )
    result = RedrawWindow(*(HWND *)hDC, 0, 0, 0x101u);
  return result;
}

//----- (6F78A1AD) --------------------------------------------------------
signed int __stdcall InitUpDownClass(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.lpfnWndProc = UpDownWndProc;
  WndClass.lpszClassName = L"msctls_updown32";
  WndClass.hInstance = a1;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 16387;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}

//----- (6F78A231) --------------------------------------------------------
signed int __stdcall InitDateClasses(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+8h] [bp-28h]@1

  WndClass.style = 0x4000;
  WndClass.lpfnWndProc = (WNDPROC)MonthCalWndProc;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 4;
  WndClass.hInstance = a1;
  WndClass.hIcon = 0;
  WndClass.hCursor = LoadCursorW(0, (LPCWSTR)0x7F00);
  WndClass.lpszMenuName = 0;
  WndClass.hbrBackground = (HBRUSH)6;
  WndClass.lpszClassName = L"SysMonthCal32";
  RegisterClassW(&WndClass);
  WndClass.lpfnWndProc = (WNDPROC)DatePickWndProc;
  WndClass.hbrBackground = (HBRUSH)6;
  WndClass.lpszClassName = L"SysDateTimePick32";
  RegisterClassW(&WndClass);
  return 1;
}
// 6F78A2AC: using guessed type wchar_t aSysdatetimep_0[18];

//----- (6F78A2F1) --------------------------------------------------------
signed int __stdcall Header_Init(HINSTANCE a1)
{
  WNDCLASSW WndClass; // [sp+0h] [bp-28h]@1

  WndClass.hCursor = 0;
  WndClass.hIcon = 0;
  WndClass.lpszMenuName = 0;
  WndClass.cbClsExtra = 0;
  WndClass.lpfnWndProc = (WNDPROC)Header_WndProc;
  WndClass.hInstance = a1;
  WndClass.lpszClassName = L"SysHeader32";
  WndClass.hbrBackground = (HBRUSH)16;
  WndClass.style = 16392;
  WndClass.cbWndExtra = 4;
  RegisterClassW(&WndClass);
  return 1;
}

//----- (6F78A361) --------------------------------------------------------
HANDLE __stdcall FastGetSubclassHeader(HWND hWnd)
{
  HANDLE result; // eax@2

  if ( g_aCC32Subclass )
    result = GetPropW(hWnd, (LPCWSTR)(unsigned __int16)g_aCC32Subclass);
  else
    result = 0;
  return result;
}
// 6F7E6860: using guessed type __int16 g_aCC32Subclass;

//----- (6F78A38B) --------------------------------------------------------
HANDLE __thiscall GetSubclassHeader(DWORD this, HWND hWnd)
{
  ATOM v2; // ax@4
  HANDLE result; // eax@6
  DWORD dwProcessId; // [sp+0h] [bp-4h]@1

  dwProcessId = this;
  if ( !GetWindowThreadProcessId(hWnd, &dwProcessId) )
    dwProcessId = 0;
  if ( dwProcessId == GetCurrentProcessId() )
  {
    if ( !g_aCC32Subclass )
    {
      v2 = GlobalAddAtomW(L"CC32SubclassInfo");
      if ( v2 )
        g_aCC32Subclass = v2;
    }
    result = FastGetSubclassHeader(hWnd);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E6860: using guessed type __int16 g_aCC32Subclass;

//----- (6F78A3E9) --------------------------------------------------------
int __stdcall SetSubclassHeader(HWND hWnd, HANDLE hData, int a3)
{
  int v3; // eax@1
  signed int v4; // esi@1

  v3 = a3;
  v4 = 1;
  while ( v3 )
  {
    *(_DWORD *)(v3 + 12) = hData;
    v3 = *(_DWORD *)(v3 + 8);
  }
  if ( hWnd )
  {
    if ( hData )
    {
      if ( !SetPropW(hWnd, L"CC32SubclassInfo", hData) )
        v4 = 0;
    }
    else
    {
      RemovePropW(hWnd, (LPCWSTR)(unsigned __int16)g_aCC32Subclass);
    }
  }
  return v4;
}
// 6F7E6860: using guessed type __int16 g_aCC32Subclass;

//----- (6F78A42A) --------------------------------------------------------
int __stdcall FindCallRecord(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@1

  v3 = *(_DWORD *)a1;
  result = 12 * *(_DWORD *)a1 + a1 + 20;
  while ( 1 )
  {
    result -= 12;
    --v3;
    if ( *(_DWORD *)result == a2 && *(_DWORD *)(result + 4) == a3 )
      break;
    if ( v3 == -1 )
      return 0;
  }
  return result;
}

//----- (6F78A45C) --------------------------------------------------------
BOOL __stdcall DPA_SetPtr(HDPA hdpa, int i, void *p)
{
  BOOL result; // eax@4

  if ( hdpa )
  {
    if ( i < 0 )
    {
      result = 0;
    }
    else
    {
      if ( i < *(_DWORD *)hdpa )
      {
LABEL_4:
        *(_DWORD *)(*((_DWORD *)hdpa + 1) + 4 * i) = p;
        return 1;
      }
      result = DPA_Grow(hdpa, i + 1);
      if ( result )
      {
        memset((void *)(*((_DWORD *)hdpa + 1) + 4 * *(_DWORD *)hdpa), 0, 4 * (i - *(_DWORD *)hdpa));
        *(_DWORD *)hdpa = i + 1;
        goto LABEL_4;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F78A49A) --------------------------------------------------------
BOOL __stdcall Str_SetPtrW(LPWSTR *ppsz, LPCWSTR psz)
{
  BOOL v2; // edi@1
  LONG v3; // eax@2
  BOOL result; // eax@3
  int v5; // eax@5
  int v6; // esi@5

  v2 = 0;
  if ( psz )
  {
    v5 = lstrlenW(psz);
    v6 = v5;
    result = Alloc(2 * v5 + 2);
    v2 = result;
    if ( !result )
      return result;
    StringCchCopyW((STRSAFE_LPWSTR)result, v6 + 1, psz);
  }
  v3 = InterlockedExchange((volatile LONG *)ppsz, v2);
  if ( v3 )
    Free((HLOCAL)v3);
  return 1;
}

//----- (6F78A4CC) --------------------------------------------------------
LONG __stdcall GetWindowProc(HWND hWnd)
{
  return GetWindowLongW(hWnd, -4);
}

//----- (6F78A4E5) --------------------------------------------------------
unsigned int __stdcall PurgeSingleCallNode(int a1, int a2)
{
  unsigned int result; // eax@1
  int v3; // edx@2
  void *v4; // edi@3
  unsigned int v5; // ecx@3
  int i; // eax@3
  int v7; // eax@5
  unsigned int v8; // edx@14

  result = *(_DWORD *)(a2 + 8);
  if ( result )
  {
    v3 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 == result )
    {
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      v4 = (void *)(12 * result + a2 + 20);
      memmove(v4, (const void *)(12 * result + a2 + 32), 12 * (*(_DWORD *)a2 - result));
      v5 = *(_DWORD *)(a2 + 8);
      for ( i = *(_DWORD *)(a2 + 16); i; i = *(_DWORD *)(i + 8) )
      {
        if ( *(_DWORD *)i >= v5 )
        {
          --*(_DWORD *)i;
          v8 = *(_DWORD *)(i + 4);
          if ( v8 >= v5 )
            *(_DWORD *)(i + 4) = v8 - 1;
        }
      }
      v3 = *(_DWORD *)a2;
      v7 = *(_DWORD *)a2 - 1;
      while ( v5 < v7 && *(_DWORD *)v4 )
      {
        v4 = (char *)v4 + 12;
        ++v5;
      }
      result = v5 < v7 ? v5 : 0;
      *(_DWORD *)(a2 + 8) = result;
    }
    *(_DWORD *)a2 = v3 - 1;
  }
  return result;
}

//----- (6F78A566) --------------------------------------------------------
BOOL __stdcall RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass)
{
  BOOL result; // eax@1
  DWORD v4; // ecx@1
  BOOL v5; // edi@2
  int v6; // eax@3
  int v7; // esi@3
  int v8; // eax@4
  int v9; // eax@5
  unsigned int v10; // ecx@5

  result = IsWindow(hWnd);
  if ( result )
  {
    v5 = 0;
    if ( pfnSubclass )
    {
      v6 = (int)GetSubclassHeader(v4, hWnd);
      v7 = v6;
      if ( v6 )
      {
        v8 = FindCallRecord(v6, (int)pfnSubclass, uIdSubclass);
        if ( v8 )
        {
          *(_DWORD *)v8 = 0;
          v9 = (v8 - v7 - 20) / 12;
          v10 = *(_DWORD *)(v7 + 8);
          if ( !v10 || v9 < v10 )
            *(_DWORD *)(v7 + 8) = v9;
          CompactSubclassHeader(hWnd, (HLOCAL)v7);
          v5 = 1;
        }
      }
      result = v5;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (6F78A5D9) --------------------------------------------------------
void __stdcall CompactSubclassHeader(HWND hWnd, HLOCAL hMem)
{
  unsigned int v2; // eax@2
  int v3; // ecx@3

  if ( !hWnd )
    goto LABEL_13;
  while ( 1 )
  {
    v2 = *((_DWORD *)hMem + 2);
    if ( !v2 )
      break;
    v3 = *((_DWORD *)hMem + 4);
    if ( v3 )
    {
      if ( v2 >= *(_DWORD *)(v3 + 4) )
        break;
    }
    PurgeSingleCallNode((int)hWnd, (int)hMem);
  }
  if ( *(_DWORD *)hMem > 1u )
    ReAllocSubclassHeader(hWnd, hMem, *(_DWORD *)hMem + 1);
  else
LABEL_13:
    DetachSubclassHeader(hWnd, hMem, 0);
}

//----- (6F78A627) --------------------------------------------------------
void __stdcall DetachSubclassHeader(HWND hWnd, HLOCAL hMem, int a3)
{
  LONG v3; // edi@6

  if ( a3 || !hWnd )
    goto LABEL_8;
  if ( *(_DWORD *)hMem <= 1u && !*((_DWORD *)hMem + 4) )
  {
    if ( *((_DWORD *)hMem + 3) == GetCurrentThreadId() )
    {
      v3 = *((_DWORD *)hMem + 7);
      if ( (LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM))GetWindowProc(hWnd) == MasterSubclassProc
        && SetWindowLongW(hWnd, -4, v3) )
      {
LABEL_8:
        FreeSubclassHeader(hWnd, hMem);
        return;
      }
    }
    else
    {
      SendNotifyMessageW(hWnd, 0, 0, 0);
    }
  }
}

//----- (6F78A68A) --------------------------------------------------------
HLOCAL __stdcall FreeSubclassHeader(HWND hWnd, HLOCAL hMem)
{
  HLOCAL result; // eax@2

  if ( hMem )
  {
    SetSubclassHeader(hWnd, 0, *((_DWORD *)hMem + 4));
    result = LocalFree(hMem);
  }
  return result;
}

//----- (6F78A6B5) --------------------------------------------------------
BOOL __stdcall DSA_DeleteItem(HDSA hdsa, int i)
{
  int v2; // ebx@1
  int v3; // eax@2
  unsigned int v5; // edi@4
  UINT v6; // eax@10
  UINT v7; // ecx@10
  HLOCAL v8; // eax@12

  v2 = i;
  if ( i < 0 )
    return 0;
  v3 = *(_DWORD *)hdsa;
  if ( i >= *(_DWORD *)hdsa )
    return 0;
  if ( i < v3 - 1 )
  {
    i = 0;
    v5 = *((_DWORD *)hdsa + 3);
    if ( ULongLongToULong(v5 * (unsigned __int64)(unsigned int)(v3 - v2 - 1), (ULONG *)&i) >= 0 )
    {
      memmove((void *)(*((_DWORD *)hdsa + 1) + v2 * v5), (const void *)(*((_DWORD *)hdsa + 1) + v5 * (v2 + 1)), i);
      goto LABEL_10;
    }
    return 0;
  }
LABEL_10:
  --*(_DWORD *)hdsa;
  v6 = *((_DWORD *)hdsa + 2);
  v7 = *((_DWORD *)hdsa + 4);
  if ( *((_DWORD *)hdsa + 2) - *(_DWORD *)hdsa > (signed int)v7 )
  {
    i = 0;
    if ( UIntSub(v6, v7, (UINT *)&i) >= 0 )
    {
      v8 = PrivateLocalReAllocArray(*((HLOCAL *)hdsa + 1), i, *((_DWORD *)hdsa + 3));
      if ( v8 )
        *((_DWORD *)hdsa + 1) = v8;
    }
    *((_DWORD *)hdsa + 2) -= *((_DWORD *)hdsa + 4);
  }
  return 1;
}

//----- (6F78A6F0) --------------------------------------------------------
void __stdcall DSA_DestroyCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData)
{
  DSA_EnumCallback(hdsa, pfnCB, pData);
  DSA_Destroy(hdsa);
}

//----- (6F78A714) --------------------------------------------------------
void __stdcall DSA_EnumCallback(HDSA hdsa, PFNDAENUMCALLBACK pfnCB, void *pData)
{
  int v3; // edi@1
  PVOID v4; // eax@3

  v3 = 0;
  if ( hdsa && *(_DWORD *)hdsa > 0 )
  {
    do
    {
      v4 = DSA_GetItemPtr(hdsa, v3);
      if ( !pfnCB(v4, pData) )
        break;
      ++v3;
    }
    while ( v3 < *(_DWORD *)hdsa );
  }
}

//----- (6F78A74A) --------------------------------------------------------
HDPA __stdcall DPA_Clone(const HDPA hdpa, HDPA hdpaNew)
{
  HDPA v2; // edi@1
  signed int v3; // ebx@1

  v2 = hdpaNew;
  v3 = 0;
  if ( !hdpaNew )
  {
    v2 = DPA_CreateEx(*((_DWORD *)hdpa + 4), *((HANDLE *)hdpa + 2));
    if ( !v2 )
      return 0;
    v3 = 1;
  }
  if ( DPA_Grow(v2, *((_DWORD *)hdpa + 3)) )
  {
    *(_DWORD *)v2 = *(_DWORD *)hdpa;
    memmove(*((void **)v2 + 1), *((const void **)hdpa + 1), 4 * *(_DWORD *)hdpa);
    return v2;
  }
  if ( v3 )
    DPA_Destroy(v2);
  return 0;
}

//----- (6F78A799) --------------------------------------------------------
LRESULT __stdcall CallOriginalWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, int a5, WNDPROC lpPrevWndFunc)
{
  return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
}

//----- (6F78A7BC) --------------------------------------------------------
int __stdcall LeaveSubclassFrame(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 12);
  if ( result )
    *(_DWORD *)(result + 16) = *(_DWORD *)(a1 + 8);
  return result;
}

//----- (6F78A7DA) --------------------------------------------------------
int __stdcall EnterSubclassCallback(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1

  v3 = a1 + 12 * *(_DWORD *)a2 + 20;
  v4 = 0;
  do
  {
    v3 -= 12;
    ++v4;
  }
  while ( !*(_DWORD *)v3 );
  *(_DWORD *)a3 = *(_DWORD *)v3;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(v3 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(v3 + 8);
  *(_DWORD *)a2 -= v4;
  UpdateDeepestCall(a2);
  return v4;
}

//----- (6F78A823) --------------------------------------------------------
int __stdcall EnterSubclassFrame(int a1, int a2)
{
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 12) = a1;
  *(_DWORD *)(a1 + 16) = a2;
  return UpdateDeepestCall(a2);
}

//----- (6F78A84D) --------------------------------------------------------
int __stdcall UpdateDeepestCall(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  unsigned int v3; // ecx@2

  result = a1;
  v2 = *(_DWORD *)(a1 + 8);
  if ( !v2 || (v3 = *(_DWORD *)(v2 + 4), v3 >= *(_DWORD *)a1) )
    v3 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 4) = v3;
  return result;
}

//----- (6F78A873) --------------------------------------------------------
LRESULT __stdcall MasterSubclassProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // edi@1
  int v5; // esi@1
  int v6; // esi@2
  LRESULT result; // eax@7
  char v8; // [sp+10h] [bp-2Ch]@2
  int v9; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@2

  v9 = 0;
  v4 = hWnd;
  v5 = (int)FastGetSubclassHeader(hWnd);
  if ( v5 )
  {
    EnterSubclassFrame(v5, (int)&v8);
    ms_exc.registration.TryLevel = 0;
    v9 = CallNextSubclassProc(v5, (int)hWnd, Msg, wParam, lParam);
    ms_exc.registration.TryLevel = -2;
    v6 = LeaveSubclassFrame((int)&v8);
    if ( v6 )
    {
      if ( !IsWindow(hWnd) )
      {
        v4 = 0;
        Msg = 130;
      }
      if ( Msg == 130 )
      {
        FreeSubclassHeader(v4, (HLOCAL)v6);
      }
      else if ( *(_DWORD *)(v6 + 8) || !*(_DWORD *)(v6 + 16) && *(_DWORD *)v6 <= 1u )
      {
        CompactSubclassHeader(v4, (HLOCAL)v6);
      }
    }
    result = v9;
  }
  else
  {
    result = SubclassDeath(hWnd, Msg, wParam, lParam);
  }
  return result;
}

//----- (6F78A92F) --------------------------------------------------------
LRESULT __stdcall DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  int v4; // edi@1
  int v5; // esi@2

  v4 = 0;
  if ( IsWindow(hWnd) )
  {
    v5 = (int)FastGetSubclassHeader(hWnd);
    if ( v5 )
    {
      if ( GetCurrentThreadId() == *(_DWORD *)(v5 + 12) && *(_DWORD *)(v5 + 16) )
        v4 = CallNextSubclassProc(v5, (int)hWnd, uMsg, wParam, lParam);
    }
  }
  return v4;
}

//----- (6F78A984) --------------------------------------------------------
int __stdcall CallNextSubclassProc(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [sp+0h] [bp-3Ch]@0
  int v7; // [sp+4h] [bp-38h]@0
  int v8; // [sp+8h] [bp-34h]@0
  int v9; // [sp+Ch] [bp-30h]@0
  int v10; // [sp+10h] [bp-2Ch]@1
  int v11; // [sp+14h] [bp-28h]@1
  int v12; // [sp+18h] [bp-24h]@1
  int v13; // [sp+1Ch] [bp-20h]@1
  int v14; // [sp+20h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+24h] [bp-18h]@1
  int savedregs; // [sp+3Ch] [bp+0h]@1
  int v17; // [sp+44h] [bp+8h]@1

  v14 = *(_DWORD *)(a1 + 16);
  v17 = EnterSubclassCallback(a1, v14, (int)&v10);
  v13 = ((int (__stdcall *)(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, DWORD, EXCEPTION_POINTERS *, struct _EH3_EXCEPTION_REGISTRATION *, PVOID, PSCOPETABLE_ENTRY, _DWORD, int))v10)(
          a2,
          a3,
          a4,
          a5,
          v11,
          v12,
          v6,
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14,
          ms_exc.old_esp,
          ms_exc.exc_ptr,
          ms_exc.registration.Next,
          ms_exc.registration.ExceptionHandler,
          ms_exc.registration.ScopeTable,
          0,
          savedregs);
  LeaveSubclassCallback(v14, v17);
  return v13;
}

//----- (6F78AA01) --------------------------------------------------------
int __stdcall LeaveSubclassCallback(int a1, int a2)
{
  *(_DWORD *)a1 += a2;
  return UpdateDeepestCall(a1);
}

//----- (6F78AA1D) --------------------------------------------------------
BOOL __stdcall SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  int v4; // eax@3
  void *v5; // esi@3
  UINT_PTR v6; // ebx@4
  int v7; // eax@4
  UINT_PTR v8; // edi@6
  HLOCAL v9; // eax@6
  HLOCAL v10; // ecx@6
  DWORD_PTR v11; // ecx@8
  HANDLE v13; // eax@12
  BOOL v14; // [sp+0h] [bp-4h]@3

  if ( IsWindow(hWnd) && pfnSubclass )
  {
    v14 = 0;
    v4 = (int)AttachSubclassHeader(hWnd);
    v5 = (void *)v4;
    if ( v4 )
    {
      v6 = uIdSubclass;
      v7 = FindCallRecord(v4, (int)pfnSubclass, uIdSubclass);
      if ( v7 )
      {
LABEL_8:
        *(_DWORD *)v7 = pfnSubclass;
        v11 = dwRefData;
        *(_DWORD *)(v7 + 4) = v6;
        *(_DWORD *)(v7 + 8) = v11;
        return 1;
      }
      if ( ULongAdd(*(_DWORD *)v5, 1u, &uIdSubclass) >= 0 )
      {
        v8 = uIdSubclass;
        v9 = ReAllocSubclassHeader(hWnd, v5, uIdSubclass);
        v10 = v9;
        if ( !v9 )
        {
          v13 = FastGetSubclassHeader(hWnd);
          if ( v13 )
            CompactSubclassHeader(hWnd, v13);
          return v14;
        }
        v7 = (int)((char *)v9 + 12 * *(_DWORD *)v9 + 20);
        *(_DWORD *)v10 = v8;
        goto LABEL_8;
      }
    }
    return v14;
  }
  return 0;
}
// 6F78AA1D: could not find valid save-restore pair for ebx
// 6F78AA1D: could not find valid save-restore pair for edi
// 6F78AA1D: could not find valid save-restore pair for esi

//----- (6F78AAB7) --------------------------------------------------------
HANDLE __stdcall AttachSubclassHeader(HWND hWnd)
{
  DWORD v1; // ebx@1
  DWORD v2; // ecx@1
  HANDLE v3; // esi@2
  HLOCAL v4; // eax@3
  LONG v5; // eax@4
  HANDLE result; // eax@6

  v1 = GetWindowThreadProcessId(hWnd, 0);
  if ( v1 == GetCurrentThreadId() )
  {
    v3 = GetSubclassHeader(v2, hWnd);
    if ( v3 )
      return v3;
    v4 = ReAllocSubclassHeader(hWnd, 0, 2);
    v3 = v4;
    if ( v4 )
    {
      *((_DWORD *)v4 + 3) = v1;
      v5 = SetWindowLongW(hWnd, -4, (LONG)MasterSubclassProc);
      if ( v5 )
      {
        *((_DWORD *)v3 + 6) = 0;
        *((_DWORD *)v3 + 5) = CallOriginalWndProc;
        *((_DWORD *)v3 + 7) = v5;
        *(_DWORD *)v3 = 1;
        return v3;
      }
      FreeSubclassHeader(hWnd, v3);
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F78AB35) --------------------------------------------------------
HLOCAL __stdcall ReAllocSubclassHeader(HWND hWnd, HLOCAL hMem, int a3)
{
  HLOCAL v3; // esi@1
  unsigned int v4; // edi@1
  HLOCAL v6; // eax@4
  int v7; // ST08_4@5

  v3 = hMem;
  v4 = 3 * ((a3 + 2) / 3u);
  if ( !hMem || v4 != *((_DWORD *)hMem + 1) )
  {
    v6 = CCLocalReAlloc(hMem, 36 * ((a3 + 2) / 3u) + 32);
    v3 = v6;
    if ( v6 )
    {
      v7 = *((_DWORD *)v6 + 4);
      *((_DWORD *)v6 + 1) = v4;
      if ( !SetSubclassHeader(hWnd, v6, v7) )
      {
        FreeSubclassHeader(hWnd, v3);
        v3 = 0;
      }
    }
  }
  return v3;
}

//----- (6F78ABFB) --------------------------------------------------------
int __cdecl _local_unwind4(int a1, int a2, unsigned int a3)
{
  int result; // eax@2
  unsigned int v4; // esi@2
  int v5; // esi@5
  int v6; // ebx@5
  int v7; // eax@6
  int v8; // eax@6
  int v9; // [sp-8h] [bp-28h]@1
  signed int (__cdecl *v10)(int, int, int, int); // [sp-4h] [bp-24h]@1
  unsigned int v11; // [sp+0h] [bp-20h]@1
  unsigned int v12; // [sp+4h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-18h]@1
  int v14; // [sp+Ch] [bp-14h]@1

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v10 = sub_6F78AC8B;
  v11 = (unsigned int)&v9 ^ __security_cookie;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 12);
    if ( v4 == -2 || a3 != -2 && v4 <= a3 )
      break;
    v5 = 3 * v4;
    v6 = (*(_DWORD *)a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 16;
    *(_DWORD *)(a2 + 12) = *(_DWORD *)((*(_DWORD *)a1 ^ *(_DWORD *)(a2 + 8)) + 4 * v5 + 0x10);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      v7 = *(_DWORD *)(v6 + 8);
      _NLG_Notify(257);
      v8 = *(_DWORD *)(v6 + 8);
      _NLG_Call(1);
    }
  }
  return result;
}
// 6F78ADC7: using guessed type _DWORD __cdecl _NLG_Notify(_DWORD);
// 6F78ADE6: using guessed type int __thiscall _NLG_Call(_DWORD);

//----- (6F78AC8B) --------------------------------------------------------
signed int __cdecl sub_6F78AC8B(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@1
  int v5; // ecx@2
  int v6; // ebp@2

  result = 1;
  if ( *(_DWORD *)(a1 + 4) & 6 )
  {
    v5 = a2 ^ *(_DWORD *)(a2 + 8);
    v6 = *(_DWORD *)(a2 + 24);
    _local_unwind4(*(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 12));
    *(_DWORD *)a4 = a2;
    result = 3;
  }
  return result;
}

//----- (6F78ACD1) --------------------------------------------------------
int __thiscall _EH4_CallFilterFunc(void *this)
{
  return ((int (__fastcall *)(_DWORD, _DWORD))this)(this, 0);
}

//----- (6F78ACE8) --------------------------------------------------------
int __thiscall _EH4_TransferToHandler(void *this)
{
  void *v1; // esi@1

  v1 = this;
  _NLG_Notify(1);
  return ((int (__fastcall *)(_DWORD, _DWORD))v1)(0, 0);
}
// 6F78ADC7: using guessed type _DWORD __cdecl _NLG_Notify(_DWORD);

//----- (6F78AD01) --------------------------------------------------------
void __thiscall _EH4_GlobalUnwind(PVOID TargetFrame)
{
  RtlUnwind(TargetFrame, &loc_6F78AD16, 0, 0);
}

//----- (6F78AD1B) --------------------------------------------------------
int __fastcall _EH4_LocalUnwind(int a1, unsigned int a2, int a3, int a4)
{
  return _local_unwind4(a4, a1, a2);
}

//----- (6F78ADC7) --------------------------------------------------------
#error "6F78ADDD: positive sp value has been found (funcsize=10)"

//----- (6F78ADDE) --------------------------------------------------------
#error "6F78ADDF: positive sp value has been found (funcsize=0)"

//----- (6F78E7ED) --------------------------------------------------------
void __userpurge sub_6F78E7ED(int a1@<ebx>, int a2@<ebp>, int a3@<esi>, int a4, int a5, int a6, int a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // [sp+0h] [bp-8h]@0
  int v10; // [sp+4h] [bp-4h]@0

  v7 = ITEM_OFFSET(v9, v10) - *(_WORD *)(a3 + 198);
  v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)v8 = v7;
  *(_DWORD *)(v8 + 8) = v7 + *(_WORD *)(a1 + 26);
  JUMPOUT(&loc_6F786B09);
}

//----- (6F79151D) --------------------------------------------------------
int __usercall sub_6F79151D@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F79152E) --------------------------------------------------------
void __userpurge sub_6F79152E(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6F791512);
}

//----- (6F791538) --------------------------------------------------------
int __usercall sub_6F791538@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F791549) --------------------------------------------------------
void __userpurge sub_6F791549(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6F771A17);
}

//----- (6F791559) --------------------------------------------------------
int __usercall sub_6F791559@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F79156A) --------------------------------------------------------
void __userpurge sub_6F79156A(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6F771A3B);
}

//----- (6F791590) --------------------------------------------------------
int __usercall sub_6F791590@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F7915A1) --------------------------------------------------------
void __usercall sub_6F7915A1(int a1@<ebp>)
{
  int v1; // et1@1

  v1 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(loc_6F7915AC);
}

//----- (6F7915C2) --------------------------------------------------------
int __usercall sub_6F7915C2@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F7915D3) --------------------------------------------------------
void __usercall sub_6F7915D3(int a1@<ebp>)
{
  int v1; // et1@1

  v1 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(loc_6F7915DE);
}

//----- (6F791601) --------------------------------------------------------
int __usercall sub_6F791601@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F791612) --------------------------------------------------------
void __userpurge sub_6F791612(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(&loc_6F771A4D);
}

//----- (6F791622) --------------------------------------------------------
int __usercall sub_6F791622@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F791633) --------------------------------------------------------
void __userpurge sub_6F791633(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  JUMPOUT(&loc_6F772E94);
}

//----- (6F79166C) --------------------------------------------------------
int __usercall sub_6F79166C@<eax>(int a1@<ebp>)
{
  return __CppXcptFilter(***(_DWORD ***)(a1 - 20), *(_DWORD *)(a1 - 20));
}
// 6F7DC33B: using guessed type _DWORD __cdecl __CppXcptFilter(_DWORD, _DWORD);

//----- (6F79167D) --------------------------------------------------------
void __userpurge sub_6F79167D(int a1@<ebp>, int a2, int a3, int a4)
{
  int v4; // et1@1

  v4 = *(_DWORD *)(a1 - 24);
  *(_DWORD *)(a1 - 28) = 0;
  *(_DWORD *)(a1 - 4) = -2;
  JUMPOUT(&loc_6F771A60);
}

//----- (6F7932BD) --------------------------------------------------------
int _purecall()
{
  return v0;
}

//----- (6F7932C8) --------------------------------------------------------
HINSTANCE __stdcall PrivLoadOleLibrary()
{
  HINSTANCE result; // eax@2

  if ( GetModuleHandleW(L"OLE32.DLL") )
    result = LoadLibraryW(L"OLE32.DLL");
  else
    result = 0;
  return result;
}

//----- (6F793301) --------------------------------------------------------
BOOL __stdcall PrivFreeOleLibrary(HINSTANCE hLibModule)
{
  return FreeLibrary(hLibModule);
}

//----- (6F793312) --------------------------------------------------------
int __stdcall PrivCoInitialize(HINSTANCE hModule)
{
  FARPROC v1; // eax@1

  v1 = GetProcAddress(hModule, "CoInitialize");
  return ((int (__stdcall *)(_DWORD))v1)(0);
}

//----- (6F793342) --------------------------------------------------------
void __stdcall PrivCoUninitialize(HINSTANCE hModule)
{
  void (*v1)(void); // eax@1

  v1 = (void (*)(void))GetProcAddress(hModule, "CoUninitialize");
  v1();
}

//----- (6F793370) --------------------------------------------------------
int __stdcall PrivRegisterDragDrop(HINSTANCE hModule, HWND a2, struct IDropTarget *a3)
{
  FARPROC v3; // eax@1

  v3 = GetProcAddress(hModule, "RegisterDragDrop");
  return ((int (__stdcall *)(_DWORD, _DWORD))v3)(a2, a3);
}

//----- (6F7933A6) --------------------------------------------------------
int __stdcall PrivRevokeDragDrop(HINSTANCE hModule, HWND a2)
{
  FARPROC v2; // eax@1

  v2 = GetProcAddress(hModule, "RevokeDragDrop");
  return ((int (__stdcall *)(_DWORD))v2)(a2);
}

//----- (6F7933D8) --------------------------------------------------------
int __stdcall _mymemcmp(const char *a1, const char *a2, int a3)
{
  return memcmp(a1, a2, a3);
}

//----- (6F7933FE) --------------------------------------------------------
int __stdcall MRUIsSameData(int a1, int a2, const char *a3, int a4)
{
  int (__stdcall *v4)(const char *, const char *, int); // edx@1
  int v5; // ecx@2

  v4 = *(int (__stdcall **)(const char *, const char *, int))(a1 + 8);
  if ( v4 == _mymemcmp )
  {
    v5 = a4;
    if ( *(_DWORD *)a2 != a4 )
      return 0;
  }
  else
  {
    v5 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 >= (unsigned int)a4 )
      v5 = a4;
  }
  return v4(a3, (const char *)(a2 + 4), v5) == 0;
}

//----- (6F793441) --------------------------------------------------------
int __stdcall CreateMRUListLazyW(DWORD cbData, int a2, int a3, int a4)
{
  DWORD v4; // ebx@1
  const WCHAR *v5; // ecx@1
  void *v6; // eax@1
  HKEY v7; // edx@1
  signed int v8; // edi@1
  int v9; // esi@1
  int result; // eax@2
  int v11; // eax@4
  bool v12; // zf@6
  void *v13; // eax@6
  int v14; // eax@16
  LPBYTE v15; // eax@18
  int v16; // edi@18
  int v17; // edx@19
  int v18; // eax@24
  int v19; // eax@26
  void *v20; // ecx@29
  void *v21; // eax@34
  DWORD dwDisposition; // [sp+Ch] [bp-20h]@11
  HLOCAL hMem; // [sp+10h] [bp-1Ch]@24
  unsigned int v24; // [sp+14h] [bp-18h]@1
  void *i; // [sp+18h] [bp-14h]@1
  LPBYTE lpData; // [sp+1Ch] [bp-10h]@12
  DWORD Type; // [sp+20h] [bp-Ch]@13
  HKEY phkResult; // [sp+24h] [bp-8h]@1
  WCHAR ValueName; // [sp+28h] [bp-4h]@22
  __int16 v30; // [sp+2Ah] [bp-2h]@18

  v4 = cbData;
  v5 = *(const WCHAR **)(cbData + 16);
  v6 = *(void **)(cbData + 20);
  v7 = *(HKEY *)(cbData + 12);
  v8 = *(_DWORD *)(cbData + 4);
  v9 = 0;
  phkResult = 0;
  v24 = v8;
  i = v6;
  if ( v5 )
  {
    if ( !v6 )
    {
      v11 = *(_DWORD *)(cbData + 8);
      if ( v11 & 1 )
      {
        i = _mymemcmp;
      }
      else
      {
        v12 = (v11 & 4) == 0;
        v13 = lstrcmpiA;
        if ( v12 )
          v13 = lstrcmpiW;
        i = v13;
      }
    }
    if ( (unsigned int)v8 > 0x1D )
    {
      v24 = 29;
      v8 = 29;
    }
    if ( RegCreateKeyExW(v7, v5, 0, L"Shell", 0, 0x2001Fu, 0, &phkResult, &dwDisposition) )
      goto LABEL_54;
    lpData = (LPBYTE)Alloc(2 * v8 + 2);
    if ( !lpData )
      goto LABEL_54;
    cbData = 2 * v8 + 2;
    if ( RegQueryValueExW(phkResult, L"MRUList", 0, &Type, lpData, &cbData) )
      *(_WORD *)lpData = 0;
    CharLowerW((LPWSTR)lpData);
    v9 = Alloc(4 * v8 + 20);
    if ( v9 )
    {
      v14 = Alloc(2 * v8 + 2);
      *(_DWORD *)(v9 + 16) = v14;
      if ( v14 )
      {
        *(_DWORD *)v9 = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v9 + 8) = i;
        *(_DWORD *)(v9 + 4) = v8;
        *(_DWORD *)(v9 + 12) = phkResult;
        v30 = 0;
        v15 = lpData;
        v16 = *(_DWORD *)(v9 + 16);
        for ( i = lpData; ; v15 = (LPBYTE)i )
        {
          LOWORD(v15) = *(_WORD *)v15;
          ValueName = (unsigned __int16)v15;
          if ( !(_WORD)v15 )
            break;
          v15 = (LPBYTE)(unsigned __int16)v15;
          v17 = (unsigned __int16)v15 - 97;
          if ( *(_BYTE *)(v4 + 8) & 1 )
          {
            if ( v17 < v24 && !*(_DWORD *)(v9 + 4 * (_DWORD)v15 - 368) )
            {
              cbData = 0;
              if ( !RegQueryValueExW(phkResult, &ValueName, 0, &Type, 0, &cbData) && Type == 3 )
              {
                v18 = Alloc(cbData + 4);
                hMem = (HLOCAL)v18;
                if ( v18 )
                {
                  *(_DWORD *)v18 = cbData;
                  if ( !RegQueryValueExW(phkResult, &ValueName, 0, &Type, (LPBYTE)(v18 + 4), (LPDWORD)v18) )
                  {
                    v19 = (int)hMem;
                    *(_DWORD *)(v9 + 4 * ValueName - 368) = hMem;
                    *(_WORD *)v16 = ValueName;
                    v16 += 2;
                    if ( a2 )
                    {
                      if ( a4 && MRUIsSameData(v9, v19, (const char *)a2, a3) )
                      {
                        *(_DWORD *)a4 = (v16 - *(_DWORD *)(v9 + 16)) >> 1;
                        *(_DWORD *)v9 |= 0x8000u;
                        v20 = i;
                        while ( 1 )
                        {
                          v20 = (char *)v20 + 2;
                          if ( !*(_WORD *)v20 )
                            break;
                          *(_WORD *)v16 = *(_WORD *)v20;
                          v16 += 2;
                        }
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          else if ( v17 < v24 && !*(_DWORD *)(v9 + 4 * (_DWORD)v15 - 368) )
          {
            cbData = 0;
            if ( !RegQueryValueExW(phkResult, &ValueName, 0, &Type, 0, &cbData) && Type == 1 )
            {
              cbData *= 2;
              v21 = (void *)Alloc(cbData);
              hMem = v21;
              if ( v21 )
              {
                if ( !RegQueryValueExW(phkResult, &ValueName, 0, &Type, (LPBYTE)v21, &cbData) )
                {
                  if ( *(_WORD *)hMem )
                  {
                    *(_DWORD *)(v9 + 4 * ValueName - 368) = hMem;
                    *(_WORD *)v16 = ValueName;
                    v16 += 2;
                  }
                  else
                  {
                    Free(hMem);
                  }
                }
              }
            }
          }
          i = (char *)i + 2;
        }
        *(_WORD *)v16 = 0;
        if ( a2 && a4 && !(*(_DWORD *)v9 & 0x8000) )
          *(_DWORD *)a4 = -1;
      }
      else
      {
        Free((HLOCAL)v9);
      }
    }
    Free(lpData);
    if ( !v9 )
    {
LABEL_54:
      if ( phkResult )
        RegCloseKey(phkResult);
    }
    result = v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F793761) --------------------------------------------------------
int __stdcall CreateMRUListW(DWORD cbData)
{
  return CreateMRUListLazyW(cbData, 0, 0, 0);
}

//----- (6F79377C) --------------------------------------------------------
void __stdcall FreeMRUList(HLOCAL hMem)
{
  HLOCAL *v1; // edi@2
  int v2; // eax@3
  int i; // ebx@4

  if ( hMem )
  {
    v1 = (HLOCAL *)((char *)hMem + 20);
    if ( *(_DWORD *)hMem & 0x1000 )
    {
      v2 = lstrlenW(*((LPCWSTR *)hMem + 4));
      RegSetValueExW(*((HKEY *)hMem + 3), L"MRUList", 0, 1u, *((const BYTE **)hMem + 4), 2 * v2 + 2);
    }
    for ( i = *((_DWORD *)hMem + 1) - 1; i >= 0; ++v1 )
    {
      if ( *v1 )
      {
        if ( *(_BYTE *)hMem & 1 )
        {
          Free(*v1);
          *v1 = 0;
        }
        else
        {
          Str_SetPtrW((LPWSTR *)v1, 0);
        }
      }
      --i;
    }
    RegCloseKey(*((HKEY *)hMem + 3));
    Free(*((HLOCAL *)hMem + 4));
    Free(hMem);
  }
}

//----- (6F793809) --------------------------------------------------------
int __stdcall FindMRUData(int a1, const char *a2, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  unsigned int v6; // ebx@4
  int *v7; // edi@4
  LPWSTR v8; // eax@12
  unsigned int v9; // [sp+Ch] [bp+8h]@4

  v4 = a1;
  if ( !a1 || *(_DWORD *)a1 & 0x8000 )
  {
    result = -1;
  }
  else
  {
    v6 = 0;
    v9 = *(_DWORD *)(a1 + 4);
    v7 = (int *)(v4 + 20);
    if ( !v9 )
      goto LABEL_8;
    while ( !*v7 || !MRUIsSameData(v4, *v7, a2, a3) )
    {
      ++v6;
      ++v7;
      if ( v6 >= v9 )
        goto LABEL_8;
    }
    if ( a4 )
      *(_DWORD *)a4 = v6;
    v8 = StrChrW(*(LPCWSTR *)(v4 + 16), v6 + 97);
    if ( v8 )
      result = (signed int)((char *)v8 - *(_DWORD *)(v4 + 16)) >> 1;
    else
LABEL_8:
      result = -1;
  }
  return result;
}

//----- (6F793883) --------------------------------------------------------
int __stdcall CreateMRUListLazyA(int a1, int a2, int a3, int a4)
{
  const CHAR *v4; // ST0C_4@1
  int v5; // edi@1
  int v6; // eax@1
  LPCSTR v7; // eax@1
  int v8; // ecx@1
  int v9; // esi@2
  DWORD cbData; // [sp+8h] [bp-18h]@1
  int v12; // [sp+Ch] [bp-14h]@1
  int v13; // [sp+10h] [bp-10h]@1
  int v14; // [sp+14h] [bp-Ch]@1
  void *v15; // [sp+18h] [bp-8h]@1
  int v16; // [sp+1Ch] [bp-4h]@1

  v4 = *(const CHAR **)(a1 + 16);
  v5 = *(_DWORD *)(a1 + 8);
  v12 = *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)(a1 + 12);
  cbData = 24;
  v14 = v6;
  v7 = ProduceWFromA(0, v4);
  v8 = *(_DWORD *)(a1 + 20);
  v15 = (void *)v7;
  v16 = v8;
  v13 = v5 | 4;
  if ( v7 )
  {
    v9 = CreateMRUListLazyW((DWORD)&cbData, a2, a3, a4);
    FreeProducedString(v15);
  }
  else
  {
    v9 = 0;
  }
  return v9;
}

//----- (6F7938F0) --------------------------------------------------------
int __stdcall CreateMRUListA(int a1)
{
  return CreateMRUListLazyA(a1, 0, 0, 0);
}

//----- (6F79390B) --------------------------------------------------------
int __stdcall FindMRUStringW(int a1, LPCWSTR lpWideCharStr, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  unsigned int v5; // eax@3
  int (__stdcall *v6)(_DWORD, _DWORD); // ecx@3
  LPCWSTR *v7; // edi@3
  LPCWSTR v8; // ebx@6
  LPCWSTR v9; // ST18_4@6
  LPWSTR v10; // eax@14
  unsigned int v11; // [sp+4h] [bp-10h]@3
  int v12; // [sp+Ch] [bp-8h]@6
  int (__stdcall *v13)(_DWORD, _DWORD); // [sp+10h] [bp-4h]@3
  int v14; // [sp+1Ch] [bp+8h]@3

  v3 = a1;
  if ( a1 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    v6 = *(int (__stdcall **)(_DWORD, _DWORD))(a1 + 8);
    v14 = 0;
    v11 = v5;
    v13 = v6;
    v7 = (LPCWSTR *)(v3 + 20);
    if ( !v5 )
      goto LABEL_10;
    while ( 1 )
    {
      if ( *v7 )
      {
        if ( *(_BYTE *)v3 & 4 )
        {
          v8 = ProduceAFromW(0, lpWideCharStr);
          v9 = ProduceAFromW(0, *v7);
          v12 = v13(v8, v9);
          FreeProducedString((HLOCAL)v8);
          FreeProducedString((HLOCAL)v9);
        }
        else
        {
          v12 = v13(lpWideCharStr, *v7);
        }
        if ( !v12 )
          break;
      }
      ++v14;
      ++v7;
      if ( v14 >= v11 )
        goto LABEL_10;
    }
    if ( a3 )
      *(_DWORD *)a3 = v14;
    v10 = StrChrW(*(LPCWSTR *)(v3 + 16), v14 + 97);
    if ( v10 )
      result = (signed int)((char *)v10 - *(_DWORD *)(v3 + 16)) >> 1;
    else
LABEL_10:
      result = -1;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7939C7) --------------------------------------------------------
int __stdcall FindMRUStringA(int a1, LPCSTR lpMultiByteStr, int a3)
{
  int v3; // edi@1
  const WCHAR *v4; // eax@1
  void *v5; // esi@1

  v3 = -1;
  v4 = (const WCHAR *)ProduceWFromA(0, lpMultiByteStr);
  v5 = (void *)v4;
  if ( v4 )
  {
    v3 = FindMRUStringW(a1, v4, a3);
    FreeProducedString(v5);
  }
  return v3;
}

//----- (6F793A02) --------------------------------------------------------
int __stdcall AddMRUStringW(int ValueName, LPCWSTR psz)
{
  int v2; // esi@1
  int result; // eax@1
  int (__stdcall *v4)(_DWORD, _DWORD); // eax@2
  unsigned int v5; // ebx@2
  int v6; // edi@2
  LPCWSTR v7; // ST30_4@5
  LPCWSTR v8; // ST24_4@5
  unsigned int v9; // ecx@9
  int v10; // eax@9
  WORD v11; // bx@12
  int v12; // eax@16
  const WCHAR *v13; // eax@17
  const wchar_t *v14; // ST14_4@18
  int v15; // eax@18
  int v16; // eax@22
  int v17; // [sp+8h] [bp-14h]@5
  int (__stdcall *v18)(_DWORD, _DWORD); // [sp+Ch] [bp-10h]@2
  int v19; // [sp+14h] [bp-8h]@1
  LPCWSTR *v20; // [sp+18h] [bp-4h]@2

  v2 = ValueName;
  result = -1;
  v19 = -1;
  if ( ValueName )
  {
    v4 = *(int (__stdcall **)(_DWORD, _DWORD))(ValueName + 8);
    ValueName = 0;
    v5 = *(_DWORD *)(v2 + 4);
    v18 = v4;
    v6 = ~(unsigned __int8)(*(_DWORD *)v2 >> 1) & 1;
    v20 = (LPCWSTR *)(v2 + 20);
    if ( v5 )
    {
      while ( 1 )
      {
        if ( *v20 )
        {
          if ( *(_BYTE *)v2 & 4 )
          {
            v7 = ProduceAFromW(0, psz);
            v8 = ProduceAFromW(0, *v20);
            v17 = v18(v7, v8);
            FreeProducedString((HLOCAL)v7);
            FreeProducedString((HLOCAL)v8);
          }
          else
          {
            v17 = v18(psz, *v20);
          }
          if ( !v17 )
            break;
        }
        ++ValueName;
        ++v20;
        if ( ValueName >= v5 )
          goto LABEL_9;
      }
      v11 = ValueName + 97;
      v19 = ValueName;
    }
    else
    {
LABEL_9:
      v9 = 0;
      v10 = v2 + 20;
      if ( v5 )
      {
        while ( *(_DWORD *)v10 )
        {
          ++v9;
          v10 += 4;
          if ( v9 >= v5 )
            goto LABEL_12;
        }
        v11 = v9 + 97;
      }
      else
      {
LABEL_12:
        v11 = *(_WORD *)(*(_DWORD *)(v2 + 16) + 2 * v5 - 2);
        v10 = v2 + 4 * v11 - 368;
      }
      if ( Str_SetPtrW((LPWSTR *)v10, psz) )
      {
        v19 = v11 - 97;
        ValueName = v11;
        v12 = lstrlenW(psz);
        v6 = 1;
        RegSetValueExW(*(HKEY *)(v2 + 12), (LPCWSTR)&ValueName, 0, 1u, (const BYTE *)psz, 2 * v12 + 2);
      }
    }
    v13 = StrChrW(*(LPCWSTR *)(v2 + 16), v11);
    psz = v13;
    if ( v13 )
    {
      v14 = v13 + 1;
      v15 = lstrlenW(v13);
      StringCchCopyW((STRSAFE_LPWSTR)psz, v15, v14);
    }
    if ( v19 != -1 )
    {
      memmove((void *)(*(_DWORD *)(v2 + 16) + 2), *(const void **)(v2 + 16), 2 * *(_DWORD *)(v2 + 4));
      **(_WORD **)(v2 + 16) = v11;
    }
    if ( v6 )
    {
      v16 = lstrlenW(*(LPCWSTR *)(v2 + 16));
      RegSetValueExW(*(HKEY *)(v2 + 12), L"MRUList", 0, 1u, *(const BYTE **)(v2 + 16), 2 * v16 + 2);
      *(_DWORD *)v2 &= 0xFFFFEFFF;
    }
    else
    {
      *(_DWORD *)v2 |= 0x1000u;
    }
    result = v19;
  }
  return result;
}

//----- (6F793BAF) --------------------------------------------------------
int __stdcall AddMRUStringA(int ValueName, LPCSTR lpMultiByteStr)
{
  const WCHAR *v2; // esi@1
  int v3; // edi@1

  v2 = (const WCHAR *)ProduceWFromA(0, lpMultiByteStr);
  v3 = AddMRUStringW(ValueName, v2);
  FreeProducedString((HLOCAL)v2);
  return v3;
}

//----- (6F793BE0) --------------------------------------------------------
signed int __stdcall DelMRUString(int a1, int a2)
{
  int v2; // edi@5
  int v3; // eax@6
  int v4; // eax@8
  int v5; // eax@9
  signed int v7; // [sp+Ch] [bp-4h]@1

  v7 = 0;
  if ( !a1 )
    return v7;
  if ( (unsigned int)a2 <= *(_DWORD *)(a1 + 4) && a2 < lstrlenW(*(LPCWSTR *)(a1 + 16)) && a2 >= 0 )
  {
    v2 = *(_DWORD *)(a1 + 16) + 2 * a2;
    if ( v2 )
    {
      v3 = *(_WORD *)v2 - 97;
      if ( (unsigned int)v3 <= 0x1C )
        Str_SetPtrW((LPWSTR *)(a1 + 4 * v3 + 20), 0);
      v4 = lstrlenW((LPCWSTR)v2);
      StringCchCopyW((STRSAFE_LPWSTR)v2, v4, (STRSAFE_LPCWSTR)(v2 + 2));
      if ( *(_DWORD *)a1 & 2 )
      {
        *(_DWORD *)a1 |= 0x1000u;
      }
      else
      {
        v5 = lstrlenW(*(LPCWSTR *)(a1 + 16));
        RegSetValueExW(*(HKEY *)(a1 + 12), L"MRUList", 0, 1u, *(const BYTE **)(a1 + 16), 2 * v5 + 2);
        *(_DWORD *)a1 &= 0xFFFFEFFF;
      }
      v7 = 1;
    }
    return v7;
  }
  return 0;
}

//----- (6F793C92) --------------------------------------------------------
int __stdcall AddMRUData(int wMatch, void *Src, size_t Size)
{
  int v3; // esi@1
  unsigned int v5; // ebx@3
  int v6; // edi@3
  unsigned int v7; // eax@8
  int v8; // edi@8
  int v9; // ebx@12
  int v10; // eax@15
  const WCHAR *v11; // eax@17
  const wchar_t *v12; // ST14_4@18
  int v13; // eax@18
  int v14; // eax@22
  WCHAR ValueName[2]; // [sp+4h] [bp-4h]@3
  int wMatcha; // [sp+10h] [bp+8h]@3
  int wMatchb; // [sp+10h] [bp+8h]@11
  size_t Sizea; // [sp+18h] [bp+10h]@17

  v3 = wMatch;
  if ( !wMatch )
    return -1;
  wMatcha = 0;
  v5 = *(_DWORD *)(v3 + 4);
  v6 = ~(unsigned __int8)(*(_DWORD *)v3 >> 1) & 1;
  *(_DWORD *)ValueName = v3 + 20;
  if ( v5 )
  {
    while ( !**(_DWORD **)ValueName || !MRUIsSameData(v3, **(_DWORD **)ValueName, (const char *)Src, Size) )
    {
      ++wMatcha;
      *(_DWORD *)ValueName += 4;
      if ( wMatcha >= v5 )
        goto LABEL_7;
    }
    v9 = wMatcha;
    wMatchb = (unsigned __int16)(wMatcha + 97);
  }
  else
  {
LABEL_7:
    if ( *(_DWORD *)v3 & 0x8000 )
      return -1;
    v7 = 0;
    v8 = v3 + 20;
    if ( v5 )
    {
      while ( *(_DWORD *)v8 )
      {
        ++v7;
        v8 += 4;
        if ( v7 >= v5 )
          goto LABEL_11;
      }
      wMatchb = (unsigned __int16)(v7 + 97);
    }
    else
    {
LABEL_11:
      wMatchb = *(_WORD *)(*(_DWORD *)(v3 + 16) + 2 * v5 - 2);
      v8 = v3 + 4 * (unsigned __int16)wMatchb - 368;
    }
    if ( ULongAdd(Size, 4u, (ULONG *)ValueName) < 0 )
      return -1;
    v10 = ReAlloc(*(HLOCAL *)v8, *(SIZE_T *)ValueName);
    if ( !v10 )
      return -1;
    *(_DWORD *)v8 = v10;
    *(_DWORD *)v10 = Size;
    memmove((void *)(*(_DWORD *)v8 + 4), Src, Size);
    ValueName[0] = wMatchb;
    ValueName[1] = 0;
    v9 = (unsigned __int16)wMatchb - 97;
    RegSetValueExW(*(HKEY *)(v3 + 12), ValueName, 0, 3u, (const BYTE *)Src, Size);
    v6 = 1;
  }
  v11 = StrChrW(*(LPCWSTR *)(v3 + 16), wMatchb);
  Sizea = (size_t)v11;
  if ( v11 )
  {
    v12 = v11 + 1;
    v13 = lstrlenW(v11);
    StringCchCopyW((STRSAFE_LPWSTR)Sizea, v13, v12);
  }
  if ( v9 != -1 )
  {
    memmove((void *)(*(_DWORD *)(v3 + 16) + 2), *(const void **)(v3 + 16), 2 * *(_DWORD *)(v3 + 4));
    **(_WORD **)(v3 + 16) = wMatchb;
  }
  if ( v6 )
  {
    v14 = lstrlenW(*(LPCWSTR *)(v3 + 16));
    RegSetValueExW(*(HKEY *)(v3 + 12), L"MRUList", 0, 1u, *(const BYTE **)(v3 + 16), 2 * v14 + 2);
    *(_DWORD *)v3 &= 0xFFFFEFFF;
  }
  else
  {
    *(_DWORD *)v3 |= 0x1000u;
  }
  return v9;
}

//----- (6F793E3A) --------------------------------------------------------
size_t __stdcall EnumMRUListW(int a1, int a2, void *Dst, size_t Size)
{
  size_t result; // eax@1
  int v5; // esi@5
  size_t v6; // edi@7

  result = -1;
  if ( !a1 )
    return result;
  result = lstrlenW(*(LPCWSTR *)(a1 + 16));
  if ( a2 < 0 || !Dst )
    return result;
  if ( a2 >= (signed int)result )
    return -1;
  v5 = *(_DWORD *)(a1 + 4 * *(_WORD *)(*(_DWORD *)(a1 + 16) + 2 * a2) - 368);
  if ( !(*(_BYTE *)a1 & 1) )
  {
    if ( v5 )
    {
      StringCchCopyW((STRSAFE_LPWSTR)Dst, Size, (STRSAFE_LPCWSTR)v5);
      return lstrlenW((LPCWSTR)v5);
    }
    return -1;
  }
  if ( !v5 )
    return -1;
  v6 = Size;
  if ( *(_DWORD *)v5 < Size )
    v6 = *(_DWORD *)v5;
  memmove(Dst, (const void *)(v5 + 4), v6);
  return v6;
}

//----- (6F793EC0) --------------------------------------------------------
int __stdcall EnumMRUListA(SIZE_T uBytes, int a2, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int v4; // esi@1
  bool v5; // zf@2
  void *v6; // edi@6
  size_t v7; // eax@10
  signed int v9; // [sp+8h] [bp-4h]@1

  v9 = -1;
  v4 = uBytes;
  if ( !uBytes )
    return v9;
  v5 = (*(_BYTE *)uBytes & 1) == 0;
  uBytes = 0;
  if ( v5 && cbMultiByte && lpMultiByteStr )
  {
    if ( ULongLongToULong(2i64 * (unsigned int)cbMultiByte, &uBytes) < 0 )
      return -1;
    v6 = LocalAlloc(0x40u, uBytes);
    if ( !v6 )
      return -1;
    uBytes = 1;
  }
  else
  {
    v6 = lpMultiByteStr;
  }
  if ( !v6 )
    return -1;
  v7 = EnumMRUListW(v4, a2, v6, cbMultiByte);
  v9 = v7;
  if ( !(*(_BYTE *)v4 & 1)
    && lpMultiByteStr
    && cbMultiByte
    && v7 != -1
    && !WideCharToMultiByte(0, 0, (LPCWSTR)v6, -1, lpMultiByteStr, cbMultiByte, 0, 0) )
    v9 = -1;
  if ( uBytes )
    LocalFree(v6);
  return v9;
}
// 6F793EC0: could not find valid save-restore pair for edi

//----- (6F793F83) --------------------------------------------------------
int __stdcall ReAlloc(HLOCAL hMem, SIZE_T uBytes)
{
  int result; // eax@2

  if ( hMem )
    result = (int)LocalReAlloc(hMem, uBytes, 0x42u);
  else
    result = Alloc(uBytes);
  return result;
}

//----- (6F793FAF) --------------------------------------------------------
SIZE_T __stdcall GetSize(HLOCAL hMem)
{
  return LocalSize(hMem);
}

//----- (6F793FD8) --------------------------------------------------------
HLOCAL __stdcall CCLocalReAllocArray_TCHAR(HLOCAL hMem, int a2)
{
  return PrivateLocalReAllocArray(hMem, a2, 2);
}

//----- (6F793FF3) --------------------------------------------------------
HLOCAL __stdcall CCLocalReAllocArray_TOOLINFO(HLOCAL hMem, int a2)
{
  return PrivateLocalReAllocArray(hMem, a2, 44);
}

//----- (6F79400E) --------------------------------------------------------
int __stdcall CheckForDragBegin(HWND hWndFrom, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  signed int v5; // esi@14
  struct tagMSG Msg; // [sp+Ch] [bp-2Ch]@4
  struct tagRECT rc; // [sp+28h] [bp-10h]@3

  v3 = GetSystemMetrics(68);
  v4 = GetSystemMetrics(69);
  if ( v3 < 4 )
  {
    v4 = 4;
    v3 = 4;
  }
  SetRect(&rc, a2 - v3, a3 - v4, v3 + a2, v4 + a3);
  MapWindowPoints(hWndFrom, 0, (LPPOINT)&rc, 2u);
  SetCapture(hWndFrom);
  while ( 1 )
  {
    if ( !PeekMessageW(&Msg, 0, 0, 0, 1u) )
    {
      WaitMessage();
      goto LABEL_16;
    }
    if ( CallMsgFilterW(&Msg, 16896) )
      goto LABEL_16;
    if ( Msg.message != 512 )
      break;
    if ( IsWindow(hWndFrom) && !PtInRect(&rc, Msg.pt) )
    {
      v5 = 1;
      goto LABEL_21;
    }
LABEL_16:
    if ( !IsWindow(hWndFrom) || GetCapture() != hWndFrom )
      return 0;
  }
  if ( Msg.message <= 0x200 || Msg.message > 0x202 && (Msg.message <= 0x203 || Msg.message > 0x205) )
  {
    TranslateMessage(&Msg);
    DispatchMessageW(&Msg);
    goto LABEL_16;
  }
  v5 = 0;
LABEL_21:
  ReleaseCapture();
  return v5;
}

//----- (6F794126) --------------------------------------------------------
int __stdcall StrToIntW(LPCWSTR lpSrc)
{
  LPCWSTR v1; // eax@1
  int v2; // edx@1
  signed int v3; // esi@1
  const WCHAR v4; // cx@6

  v1 = lpSrc;
  v2 = 0;
  v3 = 0;
  if ( *lpSrc != 45 )
    goto LABEL_6;
  v3 = 1;
  while ( 1 )
  {
    ++v1;
LABEL_6:
    v4 = *v1;
    if ( *v1 < 0x30u || v4 > 0x39u )
      break;
    v2 = 10 * v2 + v4 - 48;
  }
  if ( v3 )
    v2 = -v2;
  return v2;
}

//----- (6F794169) --------------------------------------------------------
LRESULT __stdcall RelayToToolTips(HWND hWnd, int a2, int a3, int a4, int a5)
{
  LRESULT result; // eax@2
  LPARAM lParam; // [sp+0h] [bp-1Ch]@2
  int v7; // [sp+4h] [bp-18h]@2
  int v8; // [sp+8h] [bp-14h]@2
  int v9; // [sp+Ch] [bp-10h]@2

  if ( hWnd )
  {
    v9 = a5;
    v8 = a4;
    v7 = a3;
    lParam = a2;
    result = SendMessageW(hWnd, 0x407u, 0, (LPARAM)&lParam);
  }
  return result;
}

//----- (6F7941AC) --------------------------------------------------------
BOOL __stdcall IsISearchTimedOut(int a1)
{
  return (unsigned int)(GetMessageTime() - *(_DWORD *)(a1 + 16)) > 0x3E8;
}

//----- (6F7941D1) --------------------------------------------------------
int __stdcall GetIncrementSearchStringA(int a1, UINT CodePage, LPSTR lpMultiByteStr)
{
  int v3; // eax@3

  if ( IsISearchTimedOut(a1) )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 && lpMultiByteStr )
  {
    WideCharToMultiByte(CodePage, 0, *(LPCWSTR *)(a1 + 4), v3, lpMultiByteStr, v3, 0, 0);
    lpMultiByteStr[*(_DWORD *)(a1 + 12)] = 0;
  }
  return *(_DWORD *)(a1 + 12);
}

//----- (6F794222) --------------------------------------------------------
BOOL __stdcall IncrementSearchBeep(int a1)
{
  BOOL result; // eax@1

  result = a1;
  if ( !*(_DWORD *)a1 )
  {
    *(_DWORD *)a1 = 1;
    result = MessageBeep(0);
  }
  return result;
}

//----- (6F794246) --------------------------------------------------------
int __stdcall ScrollShrinkRect(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  if ( a3 )
  {
    if ( a1 <= 0 )
      *(_DWORD *)(a3 + 8) += a1;
    else
      *(_DWORD *)a3 += a1;
    if ( a2 <= 0 )
      *(_DWORD *)(a3 + 12) += a2;
    else
      *(_DWORD *)(a3 + 4) += a2;
  }
  return result;
}

//----- (6F794278) --------------------------------------------------------
int __stdcall CCSwapKeys(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else if ( a1 == a3 )
  {
    result = a2;
  }
  return result;
}

//----- (6F79429B) --------------------------------------------------------
int __stdcall RTLSwapLeftRightArrows(int a1, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 24) & 0x400000 )
    result = CCSwapKeys(a2, 37, 39);
  else
    result = a2;
  return result;
}

//----- (6F7942C6) --------------------------------------------------------
int __stdcall CCGetHotFont(HANDLE h, int a2)
{
  char pv; // [sp+4h] [bp-60h]@2
  char v4; // [sp+19h] [bp-4Bh]@2

  if ( !*(_DWORD *)a2 )
  {
    GetObjectW(h, 92, &pv);
    v4 = 1;
    *(_DWORD *)a2 = CreateFontIndirectW((const LOGFONTW *)&pv);
  }
  return *(_DWORD *)a2;
}

//----- (6F794317) --------------------------------------------------------
int __stdcall GetMessagePosClient(HWND hWnd, LPPOINT lpPoint)
{
  LPPOINT v2; // esi@1
  DWORD v3; // eax@3
  char v5; // [sp+4h] [bp-8h]@2

  v2 = lpPoint;
  if ( !lpPoint )
    v2 = (LPPOINT)&v5;
  v3 = GetMessagePos();
  v2->x = (signed __int16)v3;
  v2->y = SHIWORD(v3);
  ScreenToClient(hWnd, v2);
  return LOWORD(v2->x) | (LOWORD(v2->y) << 16);
}

//----- (6F79435B) --------------------------------------------------------
HWND __stdcall GetDlgItemRect(HWND hDlg, int nIDDlgItem, LPRECT lpRect)
{
  HWND v3; // esi@1
  HWND v4; // eax@2

  v3 = 0;
  if ( lpRect )
  {
    v4 = GetDlgItem(hDlg, nIDDlgItem);
    v3 = v4;
    if ( v4 )
    {
      GetWindowRect(v4, lpRect);
      MapWindowPoints(0, hDlg, (LPPOINT)lpRect, 2u);
    }
    else
    {
      SetRectEmpty(lpRect);
    }
  }
  return v3;
}

//----- (6F7943A8) --------------------------------------------------------
LONG __stdcall SetWindowBits(HWND hWnd, int nIndex, int a3, int a4)
{
  LONG result; // eax@1

  result = GetWindowLongW(hWnd, nIndex);
  if ( result != (a4 & a3 | result & ~a3) )
    result = SetWindowLongW(hWnd, nIndex, a4 & a3 | result & ~a3);
  return result;
}

//----- (6F7943E1) --------------------------------------------------------
BOOL __stdcall CCInvalidateFrame(HWND hWnd)
{
  return SetWindowPos(hWnd, 0, 0, 0, 0, 0, 0x37u);
}

//----- (6F794401) --------------------------------------------------------
int __stdcall FlipPoint(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  result = a1;
  v2 = *(_DWORD *)a1;
  *(_DWORD *)a1 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v2;
  return result;
}

//----- (6F79441C) --------------------------------------------------------
int __stdcall CCSetInfoTipWidth(HWND hWnd, HWND a2)
{
  HDC v2; // eax@1
  HDC v3; // edi@1
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // eax@1

  v2 = GetDC(hWnd);
  v3 = v2;
  v4 = GetDeviceCaps(v2, 88);
  v5 = MulDiv(v4, 300, 72);
  v6 = 3 * GetDeviceCaps(v3, 8) / 4;
  if ( v5 < v6 )
    v6 = v5;
  SendMessageW(a2, 0x418u, 0, v6);
  return ReleaseDC(hWnd, v3);
}

//----- (6F794488) --------------------------------------------------------
HDC __stdcall MirrorBitmapInDC(HDC hdc, HANDLE h)
{
  HDC result; // eax@1
  HDC v3; // ebx@2
  HBITMAP v4; // eax@3
  char pv; // [sp+0h] [bp-1Ch]@1
  int v6; // [sp+4h] [bp-18h]@3
  int cy; // [sp+8h] [bp-14h]@3
  HGDIOBJ ho; // [sp+18h] [bp-4h]@3
  HDC ha; // [sp+28h] [bp+Ch]@2

  result = (HDC)GetObjectW(h, 24, &pv);
  if ( result )
  {
    result = CreateCompatibleDC(hdc);
    v3 = result;
    ha = result;
    if ( result )
    {
      v4 = CreateCompatibleBitmap(hdc, v6, cy);
      ho = v4;
      if ( v4 )
      {
        SelectObject(v3, v4);
        SetLayout(v3, 1u);
        BitBlt(v3, 0, 0, v6, cy, hdc, 0, 0, 0xCC0020u);
        SetLayout(ha, 0);
        BitBlt(hdc, 0, 0, v6, cy, ha, 0, 0, 0xCC0020u);
        DeleteObject(ho);
      }
      result = (HDC)DeleteDC(ha);
    }
  }
  return result;
}

//----- (6F79453D) --------------------------------------------------------
BOOL __stdcall CCOnUIState(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // edx@1
  __int16 v5; // di@1
  int v6; // eax@4

  v4 = *(_WORD *)(a1 + 32);
  v5 = *(_WORD *)(a1 + 32);
  if ( a2 == 296 )
  {
    if ( (unsigned __int16)a3 == 1 )
    {
      v6 = v4 | (a3 >> 16);
      goto LABEL_6;
    }
    if ( (unsigned __int16)a3 == 2 )
    {
      v6 = v4 & ~(a3 >> 16);
LABEL_6:
      *(_WORD *)(a1 + 32) = v6;
      return v5 != *(_WORD *)(a1 + 32);
    }
  }
  return v5 != *(_WORD *)(a1 + 32);
}

//----- (6F794589) --------------------------------------------------------
HDWP __stdcall SafeDeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int a6, int cy, UINT uFlags)
{
  HDWP v8; // esi@1

  v8 = 0;
  if ( hWinPosInfo )
    v8 = DeferWindowPos(hWinPosInfo, hWnd, hWndInsertAfter, x, y, a6, cy, uFlags);
  else
    SetWindowPos(hWnd, hWndInsertAfter, x, y, a6, cy, uFlags);
  return v8;
}

//----- (6F7945CA) --------------------------------------------------------
int __stdcall StrToIntA(LPCSTR lpSrc)
{
  int result; // eax@1
  int v2; // esi@1
  int v3; // edi@2

  result = (int)ProduceWFromA(0, lpSrc);
  v2 = result;
  if ( result )
  {
    v3 = StrToIntW((LPCWSTR)result);
    FreeProducedString((HLOCAL)v2);
    result = v3;
  }
  return result;
}

//----- (6F7945FC) --------------------------------------------------------
int __stdcall IncrementSearchImeCompStr(SIZE_T uBytes, int a2, int a3, int a4)
{
  SIZE_T v4; // esi@1
  ULONG v5; // eax@7
  int v6; // eax@10
  int v7; // eax@12
  int v8; // eax@19
  signed int v10; // [sp+8h] [bp-4h]@1

  v4 = uBytes;
  v10 = 0;
  if ( !*(_DWORD *)(uBytes + 20) && IsISearchTimedOut(uBytes) )
  {
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 12) = 0;
  }
  if ( !*(_DWORD *)(v4 + 12) )
  {
    v10 = 1;
    *(_DWORD *)(v4 + 20) = 0;
  }
  *(_DWORD *)(v4 + 16) = GetMessageTime();
  if ( !*(_DWORD *)(v4 + 20) )
  {
    v5 = *(_DWORD *)(v4 + 8);
    if ( *(_DWORD *)(v4 + 12) + 2 > (signed int)v5 )
    {
      if ( ULongAdd(v5, 0x10u, &uBytes) < 0 )
        return v10;
      if ( ULongLongToULong(2i64 * uBytes, &uBytes) < 0 )
        return v10;
      v6 = ReAlloc(*(HLOCAL *)(v4 + 4), uBytes);
      if ( !v6 )
        return v10;
      *(_DWORD *)(v4 + 8) += 16;
      *(_DWORD *)(v4 + 4) = v6;
    }
  }
  v7 = a3;
  if ( *(_DWORD *)(v4 + 20) )
  {
    if ( *(_WORD *)a3 )
      *(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 12) - 2) = *(_WORD *)a3;
    else
      --*(_DWORD *)(v4 + 12);
  }
  else
  {
    *(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * (*(_DWORD *)(v4 + 12))++) = *(_WORD *)a3;
  }
  *(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 12)) = 0;
  v8 = a2 && *(_WORD *)v7;
  *(_DWORD *)(v4 + 20) = v8;
  if ( *(_DWORD *)(v4 + 12) == 1 && v8 )
    v10 = 1;
  *(_DWORD *)a4 = *(_DWORD *)(v4 + 4);
  return v10;
}

//----- (6F794707) --------------------------------------------------------
signed int __stdcall IncrementSearchString(int pulResult, int a2, int a3)
{
  int v3; // eax@2
  int v5; // esi@3
  LONG v6; // eax@7
  int v7; // ecx@7
  ULONG v8; // eax@7
  int v9; // edi@9
  HLOCAL v10; // eax@9
  signed int v11; // [sp+4h] [bp-4h]@1

  v11 = 0;
  if ( !a2 )
  {
    v3 = pulResult;
    *(_DWORD *)(pulResult + 12) = 0;
    *(_DWORD *)v3 = 0;
    return 0;
  }
  v5 = pulResult;
  if ( IsISearchTimedOut(pulResult) )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 12) = 0;
  }
  if ( !*(_DWORD *)(v5 + 12) )
    v11 = 1;
  v6 = GetMessageTime();
  v7 = *(_DWORD *)(v5 + 12) + 1;
  *(_DWORD *)(v5 + 16) = v6;
  v8 = *(_DWORD *)(v5 + 8);
  if ( v7 + 1 > (signed int)v8 )
  {
    if ( ULongAdd(v8, 0x10u, (ULONG *)&pulResult) < 0 )
      return v11;
    v9 = pulResult;
    v10 = CCLocalReAllocArray_TCHAR(*(HLOCAL *)(v5 + 4), pulResult);
    if ( !v10 )
      return v11;
    *(_DWORD *)(v5 + 8) = v9;
    *(_DWORD *)(v5 + 4) = v10;
  }
  *(_WORD *)(*(_DWORD *)(v5 + 4) + 2 * (*(_DWORD *)(v5 + 12))++) = a2;
  *(_WORD *)(*(_DWORD *)(v5 + 4) + 2 * *(_DWORD *)(v5 + 12)) = 0;
  *(_DWORD *)a3 = *(_DWORD *)(v5 + 4);
  return v11;
}
// 6F794707: could not find valid save-restore pair for edi
// 6F794707: could not find valid save-restore pair for esi

//----- (6F7947B6) --------------------------------------------------------
signed int __stdcall CCNotifyNavigationKeyUsage(int a1, unsigned __int16 a2)
{
  signed int result; // eax@1

  result = 0;
  if ( (*(_WORD *)(a1 + 32) & 3) != a2 )
  {
    SendMessageW(*(HWND *)(a1 + 4), 0x127u, (a2 << 16) | 2, 0);
    result = 1;
  }
  return result;
}

//----- (6F7947F4) --------------------------------------------------------
HRESULT __stdcall StringCchCopyA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszSrc)
{
  HRESULT result; // eax@1
  STRSAFE_LPSTR v4; // eax@5
  HRESULT v5; // ebx@5
  size_t v6; // esi@5
  char v7; // cl@7

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = pszDest;
    v5 = 0;
    v6 = cchDest;
    if ( !cchDest )
      goto LABEL_14;
    do
    {
      if ( !(2147483646 - cchDest + v6) )
        break;
      v7 = v4[pszSrc - pszDest];
      if ( !v7 )
        break;
      *v4++ = v7;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
    {
LABEL_14:
      --v4;
      v5 = -2147024774;
    }
    *v4 = 0;
    result = v5;
  }
  return result;
}

//----- (6F79485C) --------------------------------------------------------
HRESULT StringCchPrintfW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszFormat, ...)
{
  HRESULT result; // eax@1
  size_t v4; // esi@5
  HRESULT v5; // ebx@5
  int v6; // eax@5
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, pszFormat);
  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = cchDest - 1;
    v5 = 0;
    v6 = _vsnwprintf(pszDest, cchDest - 1, pszFormat, va);
    if ( v6 < 0 || v6 > v4 )
    {
      v5 = -2147024774;
    }
    else if ( v6 != v4 )
    {
      goto LABEL_11;
    }
    pszDest[v4] = 0;
LABEL_11:
    result = v5;
  }
  return result;
}

//----- (6F7948BA) --------------------------------------------------------
int __stdcall GetIncrementSearchString(int a1, STRSAFE_LPWSTR pszDest)
{
  int v2; // eax@3

  if ( IsISearchTimedOut(a1) )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 12) = 0;
  }
  v2 = *(_DWORD *)(a1 + 12);
  if ( v2 && pszDest )
    StringCchCopyW(pszDest, v2 + 1, *(STRSAFE_LPCWSTR *)(a1 + 4));
  return *(_DWORD *)(a1 + 12);
}

//----- (6F7948FA) --------------------------------------------------------
STRSAFE_LPCWSTR __stdcall CCReturnDispInfoText(STRSAFE_LPCWSTR pszSrc, STRSAFE_LPWSTR pszDest, size_t cchDest)
{
  if ( pszSrc != pszDest && pszSrc && pszSrc != (STRSAFE_LPCWSTR)-1 && pszDest && pszDest != (STRSAFE_LPWSTR)-1 )
    StringCchCopyW(pszDest, cchDest, pszSrc);
  return pszSrc;
}

//----- (6F794932) --------------------------------------------------------
void __stdcall CCPlaySound(LPCWSTR lpString)
{
  int v1; // edi@2
  HMODULE v2; // eax@5
  FARPROC v3; // eax@7
  LONG cbData; // [sp+4h] [bp-470h]@2
  WCHAR Data; // [sp+8h] [bp-46Ch]@3
  wchar_t pszDest; // [sp+210h] [bp-264h]@3
  WCHAR String; // [sp+418h] [bp-5Ch]@2

  if ( !g_fNeverPlaySound )
  {
    qmemcpy(&String, L"AppEvents\\Schemes\\Apps\\.Default\\%s\\.current", 0x58u);
    cbData = 520;
    v1 = lstrlenW(lpString);
    if ( (unsigned int)(lstrlenW(&String) + v1) < 0x104 )
    {
      StringCchPrintfW(&pszDest, 0x104u, &String, lpString);
      if ( !RegQueryValueW(HKEY_CURRENT_USER, &pszDest, &Data, &cbData) && (unsigned int)cbData > 2 )
      {
        v2 = GetModuleHandleW(L"winmm.dll");
        if ( v2 || (v2 = LoadLibraryW(L"winmm.dll")) != 0 )
        {
          v3 = GetProcAddress(v2, "PlaySoundW");
          if ( v3 )
            ((void (__stdcall *)(_DWORD, _DWORD, _DWORD))v3)(&Data, 0, 2228227);
          else
            g_fNeverPlaySound = 1;
        }
      }
    }
  }
}
// 6F794A50: using guessed type wchar_t aAppeventsSchem[44];
// 6F7E8A90: using guessed type int g_fNeverPlaySound;

//----- (6F794AAD) --------------------------------------------------------
LPWSTR __stdcall StrDupW(LPCWSTR lpSrch)
{
  int v1; // eax@1
  size_t v2; // esi@1
  wchar_t *v3; // eax@1
  WCHAR *v4; // edi@1

  v1 = lstrlenW(lpSrch);
  v2 = v1 + 1;
  v3 = (wchar_t *)LocalAlloc(0x40u, 2 * (v1 + 1));
  v4 = v3;
  if ( v3 )
    StringCchCopyW(v3, v2, lpSrch);
  return v4;
}

//----- (6F794AE9) --------------------------------------------------------
LPSTR __stdcall StrDupA(LPCSTR lpSrch)
{
  int v1; // eax@1
  size_t v2; // esi@1
  char *v3; // eax@1
  CHAR *v4; // edi@1

  v1 = lstrlenA(lpSrch);
  v2 = v1 + 1;
  v3 = (char *)LocalAlloc(0x40u, v1 + 1);
  v4 = v3;
  if ( v3 )
    StringCchCopyA(v3, v2, lpSrch);
  return v4;
}

//----- (6F794B22) --------------------------------------------------------
int __stdcall CallPropertyPageCallback(int a1, int a2)
{
  int result; // eax@1
  int (__stdcall *v3)(_DWORD, _DWORD, _DWORD); // esi@2
  int v4; // ecx@6

  result = 1;
  if ( *(_BYTE *)(a1 + 48) & 0x80 )
  {
    v3 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(a1 + 76);
    if ( v3 )
    {
      if ( *(_DWORD *)(a1 + 44) > 0x28u || a2 == 2 || a2 == 1 )
      {
        v4 = *(_DWORD *)(a1 + 40);
        if ( v4 )
          result = v3(0, a2, v4 + 44);
        else
          result = v3(0, a2, a1 + 44);
      }
    }
  }
  return result;
}

//----- (6F794B6E) --------------------------------------------------------
BOOL __stdcall DestroyPropertySheetPage(HPROPSHEETPAGE a1)
{
  int v1; // esi@1
  int v2; // eax@4

  v1 = *(_DWORD *)a1;
  CallPropertyPageCallback(*(_DWORD *)a1, 1);
  if ( *(_BYTE *)(v1 + 48) & 0x40 && *(_DWORD *)(v1 + 80) )
    InterlockedDecrement(*(volatile LONG **)(v1 + 80));
  v2 = *(_DWORD *)(v1 + 40);
  if ( v2 )
  {
    FreePropertyPageStrings(v2 + 44);
    LocalFree(*(HLOCAL *)(v1 + 40));
  }
  FreePropertyPageStrings(v1 + 44);
  LocalFree((HLOCAL)v1);
  return 1;
}

//----- (6F794BCB) --------------------------------------------------------
int __stdcall EditPropSheetTemplate(int a1, int a2, char a3)
{
  int result; // eax@1
  int v4; // ecx@3
  int v5; // ecx@3

  result = a1;
  if ( *(_WORD *)(a1 + 2) == -1 )
    result = a1 + 12;
  v4 = *(_DWORD *)result;
  *(_DWORD *)a2 = *(_DWORD *)result;
  v5 = v4 & 0x2000068 | 0x40010404;
  if ( !(a3 & 0x20) && (v5 & 0x48) == 72 )
    v5 &= 0xFFFFFFF7;
  if ( *(_DWORD *)result != v5 )
    *(_DWORD *)result = v5;
  return result;
}

//----- (6F794C69) --------------------------------------------------------
HWND __stdcall CreatePage(void *Src, HWND hWndParent)
{
  LPARAM v2; // esi@1
  HRSRC v3; // eax@1
  HRSRC v4; // edi@1
  DWORD v5; // eax@3
  size_t v6; // ebx@3
  void *v7; // eax@3
  int v8; // edi@3
  HWND v10; // [sp+8h] [bp-4h]@1

  v10 = 0;
  v2 = (LPARAM)Src;
  v3 = FindResourceW(*((HMODULE *)Src + 4), *((LPCWSTR *)Src + 5), (LPCWSTR)5);
  v4 = v3;
  if ( v3 )
  {
    Src = LoadResource(*(HMODULE *)(v2 + 16), v3);
    if ( Src )
    {
      v5 = SizeofResource(*(HMODULE *)(v2 + 16), v4);
      v6 = v5;
      v7 = (void *)Alloc(v5);
      v8 = (int)v7;
      if ( v7 )
      {
        memmove(v7, Src, v6);
        if ( EditPropSheetTemplate(v8, (int)&Src, 32) )
          v10 = CreateDialogIndirectParamW(
                  *(HINSTANCE *)(v2 + 16),
                  (LPCDLGTEMPLATEW)v8,
                  hWndParent,
                  *(DLGPROC *)(v2 + 32),
                  v2);
        Free((HLOCAL)v8);
      }
    }
  }
  return v10;
}

//----- (6F794D14) --------------------------------------------------------
signed int __stdcall RethunkShadowStrings(int a1)
{
  size_t v1; // ebx@1

  v1 = 48;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 40) + 44) <= 0x30u )
    v1 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 44);
  if ( v1 >= *(_WORD *)(a1 + 6) )
    v1 = *(_WORD *)(a1 + 6);
  FreePropertyPageStrings(a1 + 44);
  memmove((void *)(a1 + 44), (const void *)(*(_DWORD *)(a1 + 40) + 44), v1);
  return CopyPropertyPageStrings(a1 + 44, (int (__stdcall *)(_DWORD))StrDup_AtoW);
}

//----- (6F794D69) --------------------------------------------------------
LPCDLGTEMPLATEA __stdcall _CreatePageDialog(int a1, int a2, HWND hWndParent, LPCDLGTEMPLATEA lpTemplate)
{
  LPCDLGTEMPLATEA result; // eax@1
  LPCDLGTEMPLATEA v5; // edi@1
  int v6; // esi@2
  BOOL (__stdcall *v7)(HWND, UINT, WPARAM, LPARAM); // edx@2
  int v8; // ecx@2
  LPARAM v9; // eax@3
  HINSTANCE v10; // [sp-14h] [bp-3Ch]@6

  result = (LPCDLGTEMPLATEA)EditPropSheetTemplate((int)lpTemplate, (int)&a1, *(_DWORD *)(a1 + 96));
  v5 = result;
  if ( result )
  {
    v6 = a2;
    v7 = *(BOOL (__stdcall **)(HWND, UINT, WPARAM, LPARAM))(a2 + 68);
    v8 = *(_DWORD *)(a2 + 40);
    if ( v8 )
    {
      v9 = v8 + 44;
    }
    else
    {
      v9 = a2 + 36;
      if ( !(*(_DWORD *)(a2 + 48) & 0x200) )
        v9 = a2 + 44;
    }
    v10 = *(HINSTANCE *)(a2 + 52);
    if ( v8 )
    {
      lpTemplate = (LPCDLGTEMPLATEA)CreateDialogIndirectParamA(v10, lpTemplate, hWndParent, v7, v9);
      RethunkShadowStrings(v6);
    }
    else
    {
      lpTemplate = (LPCDLGTEMPLATEA)CreateDialogIndirectParamW(v10, lpTemplate, hWndParent, v7, v9);
    }
    hWndParent = (HWND)1;
    if ( v5->style != a1 )
      v5->style = a1;
    hWndParent = 0;
    if ( hWndParent )
    {
      if ( lpTemplate )
        DestroyWindow((HWND)lpTemplate);
    }
    result = lpTemplate;
  }
  return result;
}

//----- (6F794E6D) --------------------------------------------------------
LPCDLGTEMPLATEA __stdcall _CreatePage(int a1, void *Src, HWND hWndParent, HGLOBAL hResData)
{
  int v4; // esi@1
  LPCDLGTEMPLATEA result; // eax@1
  HRSRC v6; // eax@6
  HRSRC v7; // edi@6
  HGLOBAL v8; // eax@7
  DWORD v9; // eax@9
  size_t v10; // ebx@9
  void *v11; // eax@9
  const DLGTEMPLATE *v12; // edi@9
  LPCDLGTEMPLATEA v13; // [sp+4h] [bp-4h]@1
  const void *Srca; // [sp+14h] [bp+Ch]@8
  HGLOBAL hResDataa; // [sp+1Ch] [bp+14h]@7

  v13 = 0;
  v4 = (int)Src;
  result = (LPCDLGTEMPLATEA)CallPropertyPageCallback((int)Src, 2);
  if ( result )
  {
    if ( *((_DWORD *)Src + 10) )
      RethunkShadowStrings((int)Src);
    if ( *((_BYTE *)Src + 48) & 1 )
    {
      v13 = _CreatePageDialog(a1, (int)Src, hWndParent, *((LPCDLGTEMPLATEA *)Src + 14));
    }
    else
    {
      v6 = FindResourceExRetry(*((HMODULE *)Src + 13), (LPCWSTR)5, *((LPCWSTR *)Src + 14), (WORD)hResData);
      v7 = v6;
      if ( v6 )
      {
        v8 = LoadResource(*((HMODULE *)Src + 13), v6);
        hResDataa = v8;
        if ( v8 )
        {
          Srca = LockResource(v8);
          if ( Srca )
          {
            v9 = SizeofResource(*(HMODULE *)(v4 + 52), v7);
            v10 = v9;
            v11 = (void *)Alloc(v9);
            v12 = (const DLGTEMPLATE *)v11;
            if ( v11 )
            {
              memmove(v11, Srca, v10);
              v13 = _CreatePageDialog(a1, v4, hWndParent, v12);
              Free((HLOCAL)v12);
            }
          }
          FreeResource(hResDataa);
        }
      }
    }
    result = v13;
  }
  return result;
}

//----- (6F794F3B) --------------------------------------------------------
int __stdcall AllocPropertySheetPage(SIZE_T uBytes)
{
  int v1; // esi@1

  v1 = 0;
  if ( ULongAdd(uBytes, 0x2Cu, &uBytes) >= 0 )
  {
    v1 = Alloc(uBytes);
    if ( v1 )
    {
      *(_DWORD *)(v1 + 36) = v1;
      *(_DWORD *)v1 = v1 + 36;
    }
  }
  return v1;
}

//----- (6F794F76) --------------------------------------------------------
int __stdcall _CreatePropertySheetPage(void *Src, int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // eax@6
  int v5; // esi@6
  size_t v6; // eax@7
  LPWSTR (__stdcall *v7)(LPCWSTR); // eax@9
  int v8; // edi@13
  int v9; // eax@14

  v3 = *(_DWORD *)Src;
  if ( *(_DWORD *)Src < 0x28u || (unsigned int)v3 > 0x1000 || *((_DWORD *)Src + 1) & 0xFFF80000 )
    return 0;
  if ( a2 )
    v3 = 48;
  v4 = AllocPropertySheetPage(v3);
  v5 = v4;
  if ( !v4 )
    return 0;
  *(_DWORD *)(v4 + 4) |= v3 << 16;
  v6 = *(_DWORD *)Src;
  if ( (unsigned int)v3 < *(_DWORD *)Src )
    v6 = v3;
  memmove((void *)(v5 + 44), Src, v6);
  *(_DWORD *)(v5 + 48) &= 0x3FFFu;
  v7 = (LPWSTR (__stdcall *)(LPCWSTR))StrDup_AtoW;
  if ( !a2 )
    v7 = StrDupW;
  if ( !CopyPropertyPageStrings(v5 + 44, (int (__stdcall *)(_DWORD))v7) )
    goto LABEL_16;
  if ( !a2 )
    goto LABEL_19;
  v8 = AllocPropertySheetPage(*(_DWORD *)Src);
  if ( !v8 )
  {
LABEL_16:
    FreePropertyPageStrings(v5 + 44);
    LocalFree((HLOCAL)v5);
    return 0;
  }
  memmove((void *)(v8 + 44), Src, *(_DWORD *)Src);
  *(_DWORD *)(v5 + 40) = v8;
  v9 = *(_DWORD *)v8;
  *(_DWORD *)(v8 + 40) = v8;
  *(_DWORD *)(v8 + 36) = v5;
  *(_DWORD *)v5 = v9;
  if ( !CopyPropertyPageStrings(v8 + 44, (int (__stdcall *)(_DWORD))StrDupA) )
  {
    FreePropertyPageStrings(*(_DWORD *)(v5 + 40) + 44);
    LocalFree(*(HLOCAL *)(v5 + 40));
    goto LABEL_16;
  }
LABEL_19:
  if ( *(_BYTE *)(v5 + 48) & 0x40 )
  {
    if ( *(_DWORD *)(v5 + 80) )
      InterlockedIncrement(*(volatile LONG **)(v5 + 80));
  }
  CallPropertyPageCallback(v5, 0);
  return *(_DWORD *)v5;
}

//----- (6F795094) --------------------------------------------------------
HPROPSHEETPAGE __stdcall CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer)
{
  return (HPROPSHEETPAGE)_CreatePropertySheetPage((void *)constPropSheetPagePointer, 0, 0);
}

//----- (6F7950AE) --------------------------------------------------------
HPROPSHEETPAGE __stdcall CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer)
{
  return (HPROPSHEETPAGE)_CreatePropertySheetPage((void *)constPropSheetPagePointer, 1, 0);
}

//----- (6F7950C8) --------------------------------------------------------
void *__stdcall _Hijaak95Hack(int a1, void *Src)
{
  void *v2; // esi@1

  v2 = Src;
  if ( Src && !LocalSize((char *)Src - 36) )
    v2 = (void *)_CreatePropertySheetPage(Src, *(_DWORD *)(a1 + 96) & 0x40, *(_DWORD *)(a1 + 96) & 8);
  return v2;
}

//----- (6F795107) --------------------------------------------------------
int __stdcall GetPageInfoEx(int a1, int a2, void *Dst, WORD wLanguage, char a5)
{
  void *v5; // esi@1
  int v6; // eax@2
  HANDLE v7; // eax@3
  LPVOID v8; // edi@8
  HRSRC v9; // eax@9
  HGLOBAL v10; // eax@10
  int v11; // eax@15
  int v12; // ecx@20
  int v13; // edx@25
  int v14; // eax@26
  int v15; // edi@31
  int v16; // edi@34
  const wchar_t *v17; // edi@36
  int v18; // eax@40
  __int16 v19; // cx@40
  int v20; // eax@40
  bool v21; // zf@40
  int v22; // eax@41
  int v23; // ecx@41
  signed int v25; // [sp+Ch] [bp-8h]@1
  HGLOBAL hResData; // [sp+10h] [bp-4h]@1
  int Dsta; // [sp+24h] [bp+10h]@20
  int wLanguagea; // [sp+28h] [bp+14h]@26

  v5 = Dst;
  v25 = 0;
  hResData = 0;
  memset(Dst, 0, 0x1CCu);
  if ( a5 & 1 )
  {
    v6 = *(_DWORD *)(a2 + 48);
    if ( v6 & 2 )
    {
      v7 = *(HANDLE *)(a2 + 60);
    }
    else
    {
      if ( !(v6 & 4) )
        goto LABEL_7;
      v7 = LoadImageW(*(HINSTANCE *)(a2 + 52), *(LPCWSTR *)(a2 + 60), 1u, g_cxSmIcon, g_cySmIcon, 0);
    }
    *((_DWORD *)Dst + 2) = v7;
  }
LABEL_7:
  if ( *(_BYTE *)(a2 + 48) & 1 )
  {
    v8 = *(LPVOID *)(a2 + 56);
LABEL_12:
    if ( *((_WORD *)v8 + 1) == -1 )
    {
      *((_DWORD *)Dst + 24) = 1;
      *((_DWORD *)Dst + 25) = *((_DWORD *)v8 + 3);
      *(_DWORD *)Dst = *((_WORD *)v8 + 11);
      *((_DWORD *)Dst + 1) = *((_WORD *)v8 + 12);
      v11 = *((_DWORD *)v8 + 2) & 0x2000 || *(_BYTE *)(a2 + 48) & 0x10;
      *((_DWORD *)Dst + 22) = v11;
      *((_DWORD *)Dst + 23) = (*((_DWORD *)v8 + 2) >> 22) & 1;
    }
    else
    {
      *((_DWORD *)Dst + 25) = *(_DWORD *)v8;
      *(_DWORD *)Dst = *((_WORD *)v8 + 7);
      *((_DWORD *)Dst + 1) = *((_WORD *)v8 + 8);
      *((_DWORD *)Dst + 22) = (*(_DWORD *)(a2 + 48) >> 4) & 1;
    }
    v25 = 1;
    if ( a5 & 6 )
    {
      v12 = *(_DWORD *)(a2 + 48) & 8;
      Dsta = *(_DWORD *)(a2 + 48) & 8;
      if ( Dsta )
      {
        if ( *(_DWORD *)(a2 + 64) & 0xFFFF0000 )
          StringCchCopyW((STRSAFE_LPWSTR)v5 + 52, 0xB2u, *(STRSAFE_LPCWSTR *)(a2 + 64));
        else
          CCLoadStringExInternal(*(HMODULE *)(a2 + 52), *(_WORD *)(a2 + 64), (char *)v5 + 104, 178, wLanguage);
        v12 = Dsta;
      }
      v13 = *((_DWORD *)v5 + 24);
      if ( v13 )
      {
        v14 = (*((_DWORD *)v8 + 3) >> 6) & 1;
        wLanguagea = (*((_DWORD *)v8 + 3) >> 6) & 1;
      }
      else
      {
        v14 = (*(_DWORD *)v8 >> 6) & 1;
        wLanguagea = (*(_DWORD *)v8 >> 6) & 1;
      }
      if ( v14 || !v12 )
      {
        if ( v13 )
          v15 = (int)((char *)v8 + 26);
        else
          v15 = (int)((char *)v8 + 18);
        if ( *(_WORD *)v15 == -1 )
          v16 = v15 + 4;
        else
          v16 = v15 + 2 * lstrlenW((LPCWSTR)v15) + 2;
        v17 = (const wchar_t *)(v16 + 2 * lstrlenW((LPCWSTR)v16) + 2);
        if ( !Dsta )
          StringCchCopyW((STRSAFE_LPWSTR)v5 + 52, 0xB2u, v17);
        if ( wLanguagea && a5 & 2 )
        {
          v18 = (int)&v17[lstrlenW(v17) + 1];
          v19 = *(_WORD *)v18;
          v20 = v18 + 2;
          v21 = *((_DWORD *)v5 + 24) == 0;
          *((_WORD *)v5 + 6) = v19;
          if ( v21 )
          {
            *((_DWORD *)v5 + 20) = 0;
            *((_DWORD *)v5 + 21) = 1;
          }
          else
          {
            v22 = v20 + 2;
            v23 = *(_BYTE *)v22++;
            *((_DWORD *)v5 + 20) = v23;
            *((_DWORD *)v5 + 21) = *(_BYTE *)v22;
            v20 = v22 + 1;
          }
          StringCchCopyW((STRSAFE_LPWSTR)v5 + 7, 0x20u, (STRSAFE_LPCWSTR)v20);
          if ( *(_BYTE *)(a1 + 96) & 0x20
            && *((_DWORD *)v5 + 24)
            && (*((_BYTE *)v5 + 100) & 0x48) == 72
            && !StrCmpICW((int)((char *)v5 + 14), (int)L"MS Shell Dlg") )
            StringCchCopyW((STRSAFE_LPWSTR)v5 + 7, 0x20u, L"MS Shell Dlg 2");
        }
      }
    }
    if ( *(_BYTE *)(a2 + 48) & 1 )
      return 1;
    goto LABEL_50;
  }
  v9 = FindResourceExRetry(*(HMODULE *)(a2 + 52), (LPCWSTR)5, *(LPCWSTR *)(a2 + 56), wLanguage);
  if ( !v9 )
    return v25;
  v10 = LoadResource(*(HMODULE *)(a2 + 52), v9);
  hResData = v10;
  if ( !v10 )
    return v25;
  v8 = LockResource(v10);
  if ( v8 )
    goto LABEL_12;
LABEL_50:
  FreeResource(hResData);
  return v25;
}
// 6F7928A8: using guessed type wchar_t aMsShellDlg[13];

//----- (6F79539F) --------------------------------------------------------
int __stdcall _SetHeaderFonts(HWND hWnd, int a2)
{
  LRESULT v2; // eax@1
  int result; // eax@1
  char pv; // [sp+4h] [bp-60h]@1
  int v5; // [sp+14h] [bp-50h]@1

  v2 = SendMessageW(hWnd, 0x31u, 0, 0);
  GetObjectW((HANDLE)v2, 92, &pv);
  v5 = 700;
  result = (int)CreateFontIndirectW((const LOGFONTW *)&pv);
  if ( result )
  {
    *(_DWORD *)(a2 + 120) = result;
    result = 1;
  }
  else
  {
    *(_DWORD *)(a2 + 120) = 0;
  }
  return result;
}

//----- (6F795406) --------------------------------------------------------
int __stdcall _WriteHeaderTitle(int a1, HDC hdc, int a3, LPCWSTR lpString, int a5, UINT format)
{
  void *v6; // eax@1
  LRESULT v7; // eax@4
  struct tagRECT rcDst; // [sp+Ch] [bp-848h]@8
  RECT *lprect; // [sp+1Ch] [bp-838h]@1
  UINT c; // [sp+20h] [bp-834h]@3
  int v12; // [sp+24h] [bp-830h]@1
  HGDIOBJ h; // [sp+28h] [bp-82Ch]@6
  LPCWSTR lpchText; // [sp+2Ch] [bp-828h]@3
  WCHAR Buffer; // [sp+30h] [bp-824h]@2

  lprect = (RECT *)a3;
  v6 = (void *)lpString;
  v12 = 0;
  if ( !((unsigned int)lpString & 0xFFFF0000) )
  {
    LoadStringW(
      *(HINSTANCE *)(*(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * *(_DWORD *)(a1 + 64)) + 52),
      (unsigned __int16)lpString,
      &Buffer,
      1040);
    v6 = &Buffer;
  }
  lpchText = (LPCWSTR)v6;
  c = lstrlenW((LPCWSTR)v6);
  if ( !a5 || (v7 = *(_DWORD *)(a1 + 120)) == 0 )
    v7 = SendMessageW(*(HWND *)a1, 0x31u, 0, 0);
  h = SelectObject(hdc, (HGDIOBJ)v7);
  if ( a5 )
  {
    ExtTextOutW(hdc, 22, 10, 0, lprect, lpchText, c, 0);
  }
  else
  {
    CopyRect(&rcDst, lprect);
    rcDst.top = *(_DWORD *)(a1 + 132);
    rcDst.left = 44;
    v12 = DrawTextW(hdc, lpchText, c, &rcDst, format);
  }
  if ( h )
    SelectObject(hdc, h);
  return v12;
}

//----- (6F795544) --------------------------------------------------------
int __stdcall _ComputeHeaderHeight(HGDIOBJ h, int a2)
{
  int v2; // esi@1
  HWND v3; // ST14_4@1
  HDC v4; // ebx@1
  LRESULT v5; // eax@1
  LONG v6; // eax@4
  int v7; // eax@10
  unsigned int v8; // edi@12
  int v9; // eax@13
  int v10; // ecx@13
  int v11; // eax@13
  int v12; // eax@15
  int v13; // edi@18
  struct tagTEXTMETRICW tm; // [sp+Ch] [bp-58h]@3
  int v16; // [sp+48h] [bp-1Ch]@15
  int v17; // [sp+50h] [bp-14h]@12
  HDC hDC; // [sp+58h] [bp-Ch]@1
  LONG v19; // [sp+5Ch] [bp-8h]@4
  int v20; // [sp+60h] [bp-4h]@1
  HGDIOBJ ha; // [sp+6Ch] [bp+8h]@3

  v2 = (int)h;
  v3 = *(HWND *)h;
  v20 = 58;
  v4 = GetDC(v3);
  v5 = *((_DWORD *)h + 30);
  hDC = v4;
  if ( !v5 )
    v5 = SendMessageW(*(HWND *)h, 0x31u, 0, 0);
  ha = SelectObject(v4, (HGDIOBJ)v5);
  if ( GetTextMetricsW(v4, &tm) )
  {
    v19 = tm.tmExternalLeading;
    v6 = tm.tmHeight + tm.tmExternalLeading + 10;
    if ( v6 <= 25 )
      v6 = 25;
    *(_DWORD *)(v2 + 132) = v6;
  }
  else
  {
    v19 = 5;
    *(_DWORD *)(v2 + 132) = 25;
  }
  if ( ha )
    SelectObject(v4, ha);
  v7 = a2;
  if ( !(*(_DWORD *)(v2 + 8) & 0x2000) )
    v7 = a2 - 64;
  v8 = 0;
  v17 = v7;
  if ( *(_DWORD *)(v2 + 28) )
  {
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(v2 + 36) + 4 * v8);
      v10 = *(_DWORD *)(v9 + 48);
      v11 = v9 + 44;
      if ( !(v10 & 0x800) )
      {
        if ( v10 & 0x2000 )
        {
          v12 = *(_DWORD *)(v2 + 132) + _WriteHeaderTitle(v2, hDC, (int)&v16, *(LPCWSTR *)(v11 + 44), 0, 0x2C10u);
          if ( v12 > v20 )
            v20 = v12;
        }
      }
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v2 + 28) );
    v13 = v20;
    if ( v20 != 58 )
      v13 = v19 + v20;
  }
  else
  {
    v13 = v20;
  }
  ReleaseDC(*(HWND *)v2, hDC);
  return v13;
}

//----- (6F795657) --------------------------------------------------------
int __stdcall MoveAllButtons(HWND hDlg, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  HWND v6; // ebx@2
  int result; // eax@4
  struct tagRECT Rect; // [sp+8h] [bp-10h]@2

  v5 = a2;
  do
  {
    v6 = GetDlgItem(hDlg, *(_DWORD *)v5);
    GetWindowRect(v6, &Rect);
    if ( GetWindowLongW(hDlg, -20) & 0x400000 )
      Rect.left = Rect.right;
    ScreenToClient(hDlg, (LPPOINT)&Rect);
    SetWindowPos(v6, 0, a4 + Rect.left, a5 + Rect.top, 0, 0, 0x15u);
    result = *(_DWORD *)v5;
    v5 += 4;
  }
  while ( result != a3 );
  return result;
}

//----- (6F7956D7) --------------------------------------------------------
int __stdcall RemoveButton(HWND hDlg, int nIDDlgItem, HWND hWnd)
{
  int v3; // edi@1
  int v4; // eax@1
  HWND v5; // ebx@1
  int v6; // ecx@1
  HWND v7; // edx@1
  int result; // eax@7
  struct tagRECT v9; // [sp+8h] [bp-20h]@4
  struct tagRECT Rect; // [sp+18h] [bp-10h]@4
  int hWnda; // [sp+38h] [bp+10h]@2
  HWND hWndb; // [sp+38h] [bp+10h]@4

  v3 = (int)hWnd;
  v4 = *(_DWORD *)hWnd;
  v5 = 0;
  v6 = 0;
  v7 = hWnd;
  if ( *(_DWORD *)hWnd != nIDDlgItem )
  {
    do
    {
      ++v7;
      hWnda = v4;
      v4 = *(_DWORD *)v7;
    }
    while ( *(_DWORD *)v7 != nIDDlgItem );
    if ( hWnda )
    {
      v5 = GetDlgItem(hDlg, nIDDlgItem);
      hWndb = GetDlgItem(hDlg, hWnda);
      GetWindowRect(v5, &Rect);
      GetWindowRect(hWndb, &v9);
      if ( GetWindowLongW(hDlg, -20) & 0x400000 )
        v6 = v9.right - Rect.right;
      else
        v6 = Rect.right - v9.right;
    }
  }
  result = MoveAllButtons(hDlg, v3, nIDDlgItem, v6, 0);
  if ( v5 )
    result = ShowWindow(v5, 0);
  return result;
}

//----- (6F79577D) --------------------------------------------------------
HPALETTE __stdcall PaletteFromBmp(HGDIOBJ h)
{
  HPALETTE v1; // esi@1
  HDC v2; // eax@1
  HDC v3; // edi@1
  UINT v4; // eax@2
  UINT v5; // esi@2
  signed int v6; // edx@3
  char *v7; // ecx@5
  char v8; // al@5
  char *v9; // ecx@5
  HPALETTE v10; // eax@6
  LOGPALETTE plpal; // [sp+8h] [bp-404h]@2
  HGDIOBJ ha; // [sp+414h] [bp+8h]@4

  v1 = 0;
  v2 = CreateCompatibleDC(0);
  v3 = v2;
  if ( v2 )
  {
    SelectObject(v2, h);
    v4 = GetDIBColorTable(v3, 0, 0x100u, (RGBQUAD *)plpal.palPalEntry);
    v5 = v4;
    if ( v4 )
    {
      v6 = 0;
      if ( (signed int)v4 > 0 )
      {
        BYTE3(ha) = 0;
        do
        {
          v7 = (char *)&plpal.palPalEntry[v6].peGreen;
          LOBYTE(ha) = v7[1];
          v8 = *v7;
          v9 = (char *)&plpal.palPalEntry[v6];
          BYTE1(ha) = v8;
          BYTE2(ha) = *v9;
          ++v6;
          *(_DWORD *)v9 = ha;
        }
        while ( v6 < (signed int)v5 );
      }
      plpal.palVersion = 768;
      plpal.palNumEntries = v5;
      v10 = CreatePalette(&plpal);
    }
    else
    {
      v10 = CreateHalftonePalette(v3);
    }
    v1 = v10;
    DeleteDC(v3);
  }
  return v1;
}

//----- (6F795831) --------------------------------------------------------
LONG __stdcall GetCharDimensions(HDC hdc, LPSIZE psizl)
{
  LONG v2; // eax@3
  LONG result; // eax@5
  struct tagTEXTMETRICW tm; // [sp+4h] [bp-3Ch]@1

  GetTextMetricsW(hdc, &tm);
  if ( tm.tmPitchAndFamily & 1
    && GetTextExtentPoint32W(hdc, L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 52, psizl) == 1 )
    v2 = (psizl->cx / 26 + 1) / 2;
  else
    v2 = tm.tmAveCharWidth;
  psizl->cx = v2;
  result = tm.tmHeight;
  psizl->cy = tm.tmHeight;
  return result;
}

//----- (6F79588B) --------------------------------------------------------
LRESULT __stdcall Prsht_ButtonSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  LRESULT v6; // esi@4

  if ( uMsg == 130 )
  {
    RemoveWindowSubclass(hWnd, Prsht_ButtonSubclassProc, 0);
    return DefSubclassProc(hWnd, 0x82u, wParam, lParam);
  }
  if ( uMsg != 135 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  v6 = DefSubclassProc(hWnd, 0x87u, wParam, lParam);
  if ( !IsWindowVisible(hWnd) && !lParam )
    v6 |= 0x80u;
  return v6;
}

//----- (6F795902) --------------------------------------------------------
BOOL __stdcall Prsht_SubclassButton(HWND hDlg, int nIDDlgItem)
{
  HWND v2; // eax@1

  v2 = GetDlgItem(hDlg, nIDDlgItem);
  return SetWindowSubclass(v2, Prsht_ButtonSubclassProc, 0, 0);
}

//----- (6F79592B) --------------------------------------------------------
int __stdcall Prsht_GetIdealPageSize(int a1, int a2, char a3)
{
  int result; // eax@1
  unsigned int v4; // edx@1
  int v5; // esi@2
  int v6; // edi@2
  bool v7; // zf@4
  int v8; // esi@9

  result = a1;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 236);
  v4 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    do
    {
      v5 = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v4);
      v6 = *(_DWORD *)(v5 + 12);
      if ( !(*(_DWORD *)(a1 + 8) & 0x1002000)
        || (!(*(_DWORD *)(v5 + 48) & 0x800) ? (v7 = (a3 & 1) == 0) : (v7 = (a3 & 2) == 0), v7) )
      {
        if ( *(_DWORD *)(a2 + 4) < v6 )
          *(_DWORD *)(a2 + 4) = v6;
      }
      v8 = *(_DWORD *)(v5 + 8);
      if ( *(_DWORD *)a2 < v8 )
        *(_DWORD *)a2 = v8;
      ++v4;
    }
    while ( v4 < *(_DWORD *)(a1 + 28) );
  }
  return result;
}

//----- (6F795999) --------------------------------------------------------
int __stdcall _Ppd_GetPage(int a1, WPARAM wParam)
{
  HWND v2; // eax@1
  int result; // eax@2
  LPARAM lParam; // [sp+0h] [bp-20h]@2
  int v5; // [sp+18h] [bp-8h]@2

  v2 = *(HWND *)(a1 + 60);
  if ( v2 )
  {
    lParam = 8;
    SendMessageW(v2, 0x133Cu, wParam, (LPARAM)&lParam);
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7959D5) --------------------------------------------------------
int __stdcall _Ppd_IsPageHidden(int a1, WPARAM wParam)
{
  HWND v2; // eax@1
  int result; // eax@3
  LPARAM lParam; // [sp+0h] [bp-1Ch]@2
  int v5; // [sp+4h] [bp-18h]@3
  int v6; // [sp+8h] [bp-14h]@2

  v2 = *(HWND *)(a1 + 60);
  if ( v2 && (lParam = 16, v6 = 4, SendMessageW(v2, 0x133Cu, wParam, (LPARAM)&lParam)) )
    result = v5;
  else
    result = 0;
  return result;
}

//----- (6F795A1C) --------------------------------------------------------
HWND __stdcall _Ppd_SendNotify(int a1, WPARAM wParam, int a3, int a4)
{
  HWND v4; // ST08_4@1
  int v5; // eax@1
  LPARAM lParam; // [sp+0h] [bp-10h]@1
  int v8; // [sp+Ch] [bp-4h]@1

  v8 = a4;
  v4 = *(HWND *)a1;
  v5 = _Ppd_GetPage(a1, wParam);
  return SendNotifyEx(v5, v4, a3, (LPARAM)&lParam, 0);
}

//----- (6F795A50) --------------------------------------------------------
int __stdcall FindPageIndex(int a1, int a2, int a3, int a4)
{
  int result; // eax@2
  unsigned int v5; // edx@4
  int v6; // ecx@5

  if ( !a3 )
  {
    result = a2 + a4;
    if ( (unsigned int)(a2 + a4) <= *(_DWORD *)(a1 + 28) )
      return result;
    return -1;
  }
  v5 = *(_DWORD *)(a1 + 28);
  result = 0;
  if ( !v5 )
    return -1;
  v6 = *(_DWORD *)(a1 + 36);
  while ( *(_DWORD *)(*(_DWORD *)v6 + 56) != a3 )
  {
    ++result;
    v6 += 4;
    if ( result >= v5 )
      return -1;
  }
  return result;
}

//----- (6F795A9C) --------------------------------------------------------
int __stdcall FindPageIndexByHpage(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@2

  result = *(_DWORD *)(a1 + 28) - 1;
  if ( result >= 0 )
  {
    v3 = *(_DWORD *)(a1 + 36) + 4 * result;
    do
    {
      if ( a2 == **(_DWORD **)v3 )
        break;
      --result;
      v3 -= 4;
    }
    while ( result >= 0 );
  }
  return result;
}

//----- (6F795ACC) --------------------------------------------------------
HWND __stdcall PageChanging(int a1)
{
  HWND result; // eax@1

  result = 0;
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 56) )
      result = _Ppd_SendNotify(a1, *(_DWORD *)(a1 + 64), -201, 0);
  }
  return result;
}

//----- (6F795AF7) --------------------------------------------------------
LRESULT __stdcall SendLastChanceApply(int a1)
{
  LRESULT result; // eax@1
  WPARAM v2; // ebx@1
  LPARAM lParam; // [sp+Ch] [bp-20h]@1
  int v4; // [sp+24h] [bp-8h]@2

  result = SendMessageW(*(HWND *)(a1 + 60), 0x1304u, 0, 0);
  v2 = result - 1;
  for ( lParam = 8; (v2 & 0x80000000) == 0; --v2 )
  {
    result = SendMessageW(*(HWND *)(a1 + 60), 0x133Cu, v2, (LPARAM)&lParam);
    if ( v4 )
      result = (LRESULT)_Ppd_SendNotify(a1, v2, -211, 1);
  }
  return result;
}

//----- (6F795B59) --------------------------------------------------------
LRESULT __stdcall ResetWizButtons(int a1)
{
  unsigned int v1; // esi@2
  LRESULT result; // eax@3

  if ( *(_DWORD *)(a1 + 8) & 0x1402020 )
  {
    v1 = 0;
    do
    {
      result = SendDlgItemMessageW(*(HWND *)a1, dword_6F7928D8[v1], 0xF4u, 0, 1);
      ++v1;
    }
    while ( v1 < 5 );
  }
  return result;
}
// 6F7928D8: using guessed type int dword_6F7928D8[];

//----- (6F795B98) --------------------------------------------------------
LRESULT __stdcall SetWizButtons(int a1, unsigned int a2)
{
  HWND v2; // eax@1
  HWND v3; // eax@1
  HWND v4; // eax@2
  HWND v5; // eax@4
  HWND v6; // eax@4
  unsigned int v7; // edi@11
  HWND v8; // ebx@12
  HWND v9; // eax@21
  LRESULT result; // eax@25
  HWND hWnd; // [sp+Ch] [bp-10h]@1
  signed int v12; // [sp+10h] [bp-Ch]@1
  signed int nIDDlgItem; // [sp+14h] [bp-8h]@1
  HWND hDlg; // [sp+18h] [bp-4h]@1
  int v15; // [sp+28h] [bp+Ch]@9

  v12 = 12324;
  nIDDlgItem = 12325;
  hWnd = GetFocus();
  hDlg = *(HWND *)a1;
  v2 = GetDlgItem(*(HWND *)a1, 12323);
  EnableWindow(v2, a2 & 1);
  v3 = GetDlgItem(hDlg, 12324);
  EnableWindow(v3, (a2 >> 1) & 1);
  if ( a2 & 0xC )
  {
    v12 = 12325;
    nIDDlgItem = 12324;
    v4 = GetDlgItem(hDlg, 12325);
    EnableWindow(v4, (a2 >> 2) & 1);
  }
  if ( !(*(_BYTE *)(a1 + 8) & 0x10) )
  {
    v5 = GetDlgItem(hDlg, nIDDlgItem);
    ShowWindow(v5, 0);
    v6 = GetDlgItem(hDlg, v12);
    ShowWindow(v6, 5);
  }
  v15 = !hWnd || SendMessageW(hWnd, 0x87u, 0, 0) & 0x30 || !IsWindowVisible(hWnd) || !IsWindowEnabled(hWnd);
  v7 = 0;
  do
  {
    v8 = GetDlgItem(hDlg, *(&wParam + v7));
    if ( GetWindowLongW(v8, -16) & 0x10000000 && IsWindowEnabled(v8) )
      break;
    ++v7;
  }
  while ( v7 < 4 );
  if ( v7 == 4 )
    v8 = 0;
  else
    *(_DWORD *)(a1 + 68) = *(&wParam + v7);
  if ( v15 )
  {
    if ( !v8 )
      v8 = hDlg;
    v9 = GetFocus();
    if ( !v9 || *(HWND *)a1 == v9 || IsChild(*(HWND *)a1, v9) )
      SetFocus(v8);
  }
  result = ResetWizButtons(a1);
  if ( v7 != 4 )
    result = SendMessageW(hDlg, 0x401u, *(&wParam + v7), 0);
  return result;
}

//----- (6F795D35) --------------------------------------------------------
LRESULT __stdcall FindItem(HWND hWnd, int a2, LPARAM lParam)
{
  LPARAM v3; // ebx@1
  LRESULT v4; // esi@3
  int v6; // [sp+Ch] [bp-20h]@2

  v3 = lParam;
  if ( !lParam )
  {
    v6 = 8;
    v3 = (LPARAM)&v6;
  }
  v4 = SendMessageW(hWnd, 0x1304u, 0, 0);
  do
  {
    --v4;
    if ( v4 < 0 )
      break;
    SendMessageW(hWnd, 0x133Cu, v4, v3);
  }
  while ( *(_DWORD *)(v3 + 24) != a2 );
  return v4;
}

//----- (6F795D8E) --------------------------------------------------------
WPARAM __stdcall PageInfoChange(int a1, int a2)
{
  WPARAM result; // eax@1
  HWND v3; // eax@5
  LPARAM lParam; // [sp+4h] [bp-20h]@1
  int v5; // [sp+20h] [bp-4h]@2

  lParam = 8;
  result = FindItem(*(HWND *)(a1 + 60), a2, (LPARAM)&lParam);
  if ( result != -1 )
  {
    if ( !(v5 & 1) )
    {
      v5 |= 1u;
      result = SendMessageW(*(HWND *)(a1 + 60), 0x133Du, result, (LPARAM)&lParam);
    }
    if ( *(_DWORD *)(a1 + 136) )
    {
      v3 = GetDlgItem(*(HWND *)a1, 12321);
      result = EnableWindow(v3, 1);
    }
  }
  return result;
}

//----- (6F795DFB) --------------------------------------------------------
WPARAM __stdcall PageInfoUnChange(int a1, int a2)
{
  WPARAM result; // eax@1
  WPARAM v3; // edi@4
  HWND v4; // eax@9
  LPARAM lParam; // [sp+4h] [bp-20h]@1
  int v6; // [sp+20h] [bp-4h]@2

  lParam = 8;
  result = FindItem(*(HWND *)(a1 + 60), a2, (LPARAM)&lParam);
  if ( result != -1 )
  {
    if ( v6 & 1 )
    {
      v6 &= 0xFFFFFFFE;
      SendMessageW(*(HWND *)(a1 + 60), 0x133Du, result, (LPARAM)&lParam);
    }
    v3 = *(_DWORD *)(a1 + 28) - 1;
    if ( (v3 & 0x80000000) != 0 )
      goto LABEL_12;
    do
    {
      result = SendMessageW(*(HWND *)(a1 + 60), 0x133Cu, v3, (LPARAM)&lParam);
      if ( !result )
        break;
      if ( v6 & 1 )
        break;
      --v3;
    }
    while ( (v3 & 0x80000000) == 0 );
    if ( (v3 & 0x80000000) != 0 )
    {
LABEL_12:
      v4 = GetDlgItem(*(HWND *)a1, 12321);
      result = EnableWindow(v4, 0);
    }
  }
  return result;
}

//----- (6F795E8B) --------------------------------------------------------
HDWP __stdcall Prsht_RepositionControl(int a1, HWND hWnd, HDWP hWinPosInfo, int a4, int a5, int a6, int a7)
{
  struct tagRECT Rect; // [sp+0h] [bp-10h]@2

  if ( hWnd )
  {
    GetWindowRect(hWnd, &Rect);
    MapWindowPoints(0, *(HWND *)a1, (LPPOINT)&Rect, 2u);
    hWinPosInfo = SafeDeferWindowPos(
                    hWinPosInfo,
                    hWnd,
                    0,
                    a4 + Rect.left,
                    a5 + Rect.top,
                    a6 + Rect.right - Rect.left,
                    a7 + Rect.bottom - Rect.top,
                    0x14u);
  }
  return hWinPosInfo;
}

//----- (6F795EFB) --------------------------------------------------------
int __stdcall Prsht_ResizeDialog(int a1, int a2, int a3, HDWP hWinPosInfo)
{
  HDWP v4; // eax@5
  int v5; // esi@5
  HWND v6; // eax@5
  HWND v7; // eax@8
  HWND v8; // eax@8
  HWND v9; // eax@11
  struct tagRECT Rect; // [sp+4h] [bp-1Ch]@14
  int v12; // [sp+14h] [bp-Ch]@4
  int v13; // [sp+18h] [bp-8h]@8
  int v14; // [sp+1Ch] [bp-4h]@5
  int v15; // [sp+28h] [bp+8h]@8
  int i; // [sp+30h] [bp+10h]@10
  HDWP hWinPosInfoa; // [sp+34h] [bp+14h]@5
  HDWP hWinPosInfob; // [sp+34h] [bp+14h]@8

  if ( a2 || a3 || hWinPosInfo )
  {
    v12 = 1;
    v14 = (int)((char *)hWinPosInfo + a3);
    v4 = BeginDeferWindowPos(9);
    v5 = a1;
    hWinPosInfoa = Prsht_RepositionControl(a1, *(HWND *)(a1 + 60), v4, 0, 0, a2, (int)((char *)hWinPosInfo + a3));
    v6 = *(HWND *)(a1 + 56);
    if ( v6 )
      hWinPosInfoa = SafeDeferWindowPos(
                       hWinPosInfoa,
                       v6,
                       0,
                       *(_DWORD *)(a1 + 80),
                       *(_DWORD *)(a1 + 84),
                       *(_DWORD *)(a1 + 88),
                       *(_DWORD *)(a1 + 92),
                       0x14u);
    if ( *(_DWORD *)(a1 + 8) & 0x1402020 )
    {
      v7 = GetDlgItem(*(HWND *)a1, 12326);
      hWinPosInfob = Prsht_RepositionControl(a1, v7, hWinPosInfoa, 0, v14, a2, 0);
      v8 = GetDlgItem(*(HWND *)a1, 12327);
      hWinPosInfoa = Prsht_RepositionControl(a1, v8, hWinPosInfob, 0, 0, a2, 0);
      v13 = (int)dword_6F7928D8;
      v15 = 5;
    }
    else
    {
      v13 = (int)dword_6F7928C8;
      v15 = 4;
    }
    for ( i = 0; i < (unsigned int)v15; hWinPosInfoa = Prsht_RepositionControl(v5, v9, hWinPosInfoa, a2, v14, 0, 0) )
      v9 = GetDlgItem(*(HWND *)v5, *(_DWORD *)(v13 + 4 * i++));
    if ( hWinPosInfoa )
      EndDeferWindowPos(hWinPosInfoa);
    GetWindowRect(*(HWND *)v5, &Rect);
    SetWindowPos(*(HWND *)v5, 0, 0, 0, a2 + Rect.right - Rect.left, v14 + Rect.bottom - Rect.top, 0x16u);
  }
  else
  {
    v12 = 0;
  }
  return v12;
}
// 6F7928C8: using guessed type int dword_6F7928C8[4];
// 6F7928D8: using guessed type int dword_6F7928D8[];

//----- (6F796056) --------------------------------------------------------
int __stdcall Prsht_RecalcPageSizes(int a1)
{
  LONG v1; // edi@1
  LONG v2; // ebx@3
  int v3; // ST08_4@3
  int v4; // ST04_4@3
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@2

  v1 = 0;
  if ( !(*(_DWORD *)(a1 + 8) & 0x1402020) )
  {
    GetClientRect(*(HWND *)(a1 + 60), &Rect);
    MapWindowPoints(*(HWND *)(a1 + 60), *(HWND *)a1, (LPPOINT)&Rect, 2u);
    SendMessageW(*(HWND *)(a1 + 60), 0x1328u, 0, (LPARAM)&Rect);
    v1 = Rect.top - *(_DWORD *)(a1 + 84);
    *(_DWORD *)(a1 + 84) = Rect.top;
  }
  Prsht_GetIdealPageSize(a1, (int)&Rect.right, 2);
  v2 = Rect.bottom;
  v3 = Rect.bottom - *(_DWORD *)(a1 + 92);
  v4 = Rect.right - *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 88) = Rect.right;
  *(_DWORD *)(a1 + 92) = v2;
  return Prsht_ResizeDialog(a1, v4, v3, (HDWP)v1);
}

//----- (6F7960E2) --------------------------------------------------------
void *__stdcall RemovePropPageData(int a1, WPARAM wParam)
{
  int v2; // esi@1

  v2 = a1;
  SendMessageW(*(HWND *)(a1 + 60), 0x1308u, wParam, 0);
  DestroyPropertySheetPage(**(HPROPSHEETPAGE **)(*(_DWORD *)(a1 + 36) + 4 * wParam));
  --*(_DWORD *)(v2 + 28);
  return memmove(
           (void *)(*(_DWORD *)(v2 + 36) + 4 * wParam),
           (const void *)(*(_DWORD *)(v2 + 36) + 4 * wParam + 4),
           4 * (*(_DWORD *)(v2 + 28) - wParam));
}

//----- (6F796137) --------------------------------------------------------
LRESULT __stdcall QuerySiblings(int a1, WPARAM wParam, LPARAM lParam)
{
  WPARAM v3; // edi@1
  HWND v4; // eax@2
  LRESULT result; // eax@3

  v3 = 0;
  if ( *(_DWORD *)(a1 + 28) )
  {
    while ( 1 )
    {
      v4 = (HWND)_Ppd_GetPage(a1, v3);
      if ( v4 )
      {
        result = SendMessageW(v4, 0x46Cu, wParam, lParam);
        if ( result )
          break;
      }
      ++v3;
      if ( v3 >= *(_DWORD *)(a1 + 28) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (6F79617C) --------------------------------------------------------
int __stdcall Prsht_GetObject(void *Src, HWND hWndParent, WPARAM wParam, int a4, int a5)
{
  int v5; // esi@1
  HWND v6; // ST04_4@1
  LANGID v7; // ax@2
  int result; // eax@3
  HWND v9; // ST04_4@4
  int v10; // eax@4
  LPARAM lParam; // [sp+Ch] [bp-40h]@1
  int v12; // [sp+24h] [bp-28h]@1
  LPARAM v13; // [sp+2Ch] [bp-20h]@4
  int v14; // [sp+38h] [bp-14h]@4
  int v15; // [sp+3Ch] [bp-10h]@4
  int v16; // [sp+40h] [bp-Ch]@4
  int v17; // [sp+44h] [bp-8h]@4
  int v18; // [sp+48h] [bp-4h]@4
  void *Srca; // [sp+54h] [bp+8h]@1

  v5 = (int)Src;
  Srca = *(void **)(*((_DWORD *)Src + 9) + 4 * wParam);
  *(_DWORD *)a5 = 0;
  v6 = *(HWND *)(v5 + 60);
  lParam = 8;
  SendMessageW(v6, 0x133Cu, wParam, (LPARAM)&lParam);
  if ( v12 || (v7 = GetMUILanguage(), (v12 = (int)_CreatePage(v5, Srca, hWndParent, (HGLOBAL)v7)) != 0) )
  {
    SendMessageW(*(HWND *)(v5 + 60), 0x133Du, wParam, (LPARAM)&lParam);
    v14 = -1;
    v15 = a4;
    v9 = *(HWND *)(v5 + 60);
    v16 = 0;
    v17 = -2147467262;
    v18 = 0;
    SendNotifyEx(v12, v9, -210, (LPARAM)&v13, 1);
    v10 = v16;
    if ( v17 < 0 )
    {
      if ( v16 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v16 + 8))(v16);
    }
    else
    {
      *(_DWORD *)a5 = v16;
      if ( !v10 )
        v17 = -2147418113;
    }
    result = v17;
  }
  else
  {
    RemovePropPageData(v5, wParam);
    result = -2147418113;
  }
  return result;
}

//----- (6F796259) --------------------------------------------------------
int __stdcall HandlePaletteChange(int a1, int a2, HWND hWnd)
{
  HDC v3; // esi@1

  v3 = GetDC(hWnd);
  if ( v3 )
  {
    SelectPalette(v3, *(HPALETTE *)(a1 + 112), a2 == 785);
    if ( RealizePalette(v3) )
      InvalidateRect(hWnd, 0, 1);
  }
  return ReleaseDC(hWnd, v3);
}

//----- (6F7962B4) --------------------------------------------------------
HGDIOBJ __stdcall PaintWithPaletteBrush(HDC hdc, RECT *lprc, HPALETTE hPal, HGDIOBJ h)
{
  HGDIOBJ v4; // ebx@1

  v4 = SelectObject(hdc, h);
  UnrealizeObject(h);
  if ( hPal )
  {
    SelectPalette(hdc, hPal, 0);
    RealizePalette(hdc);
  }
  FillRect(hdc, lprc, (HBRUSH)h);
  return SelectObject(hdc, v4);
}

//----- (6F79630C) --------------------------------------------------------
BOOL __stdcall PaintWithPaletteBitmap(HDC hdc, int wDest, HPALETTE hPal, HANDLE h)
{
  int v4; // esi@3
  int v5; // ecx@3
  int v6; // edx@3
  int v7; // ebx@3
  char pv; // [sp+0h] [bp-1Ch]@1
  int v10; // [sp+4h] [bp-18h]@3
  int v11; // [sp+8h] [bp-14h]@5
  HDC hdcSrc; // [sp+18h] [bp-4h]@1
  int wDesta; // [sp+28h] [bp+Ch]@3
  int hPala; // [sp+2Ch] [bp+10h]@3
  int ha; // [sp+30h] [bp+14h]@5

  GetObjectW(h, 24, &pv);
  hdcSrc = CreateCompatibleDC(hdc);
  SelectObject(hdcSrc, h);
  if ( hPal )
  {
    SelectPalette(hdc, hPal, 0);
    RealizePalette(hdc);
  }
  v4 = wDest;
  v5 = *(_DWORD *)wDest;
  v6 = *(_DWORD *)(wDest + 4);
  v7 = *(_DWORD *)(wDest + 12) - v6;
  wDesta = *(_DWORD *)(wDest + 8) - *(_DWORD *)wDest;
  hPala = v10;
  if ( v10 >= wDesta )
    hPala = wDesta;
  ha = v11;
  if ( v11 >= v7 )
    ha = v7;
  BitBlt(hdc, v5, v6, hPala, ha, hdcSrc, 0, 0, 0xCC0020u);
  if ( hPala < wDesta )
    StretchBlt(hdc, hPala + *(_DWORD *)v4, *(_DWORD *)(v4 + 4), wDesta - hPala, ha, hdcSrc, 0, 0, 1, 1, 0xCC0020u);
  if ( ha < v7 )
    StretchBlt(hdc, *(_DWORD *)v4, ha, wDesta, v7 - ha, hdcSrc, 0, 0, 1, 1, 0xCC0020u);
  return DeleteDC(hdcSrc);
}

//----- (6F79640F) --------------------------------------------------------
void __stdcall _SetHeaderTitles(HWND hWnd, int a2, int a3, HLOCAL hMem, int a5)
{
  int v5; // eax@2
  int v6; // edi@3
  void *v7; // ecx@5
  struct tagRECT Rect; // [sp+8h] [bp-10h]@13

  if ( !(*(_DWORD *)(a2 + 8) & 0x1002000) )
    goto LABEL_14;
  v5 = a3;
  if ( (unsigned int)a3 >= *(_DWORD *)(a2 + 28) )
    goto LABEL_14;
  v6 = *(_DWORD *)(*(_DWORD *)(a2 + 36) + 4 * a3);
  if ( *(_DWORD *)(v6 + 48) & 0x800 )
    goto LABEL_14;
  if ( a5 )
    v7 = *(void **)(v6 + 84);
  else
    v7 = *(void **)(v6 + 88);
  if ( (unsigned int)v7 & 0xFFFF0000 )
  {
    LocalFree(v7);
    v5 = a3;
  }
  if ( a5 )
    *(_DWORD *)(v6 + 84) = hMem;
  else
    *(_DWORD *)(v6 + 88) = hMem;
  hMem = 0;
  *(_DWORD *)(v6 + 48) |= a5 != 0 ? 4096 : 0x2000;
  if ( v5 == *(_DWORD *)(a2 + 64) )
  {
    GetClientRect(hWnd, &Rect);
    Rect.bottom = *(_DWORD *)(a2 + 116);
    InvalidateRect(hWnd, &Rect, 0);
LABEL_14:
    if ( hMem )
      LocalFree(hMem);
  }
}

//----- (6F7964CA) --------------------------------------------------------
int __stdcall PropSheetPaintHeader(int a1, int a2, HWND hWnd, HDC hdc)
{
  int v4; // eax@1
  int result; // eax@5
  int v6; // esi@8
  const WCHAR *v7; // ebx@16
  struct tagRECT rc; // [sp+Ch] [bp-20h]@8
  struct tagRECT Rect; // [sp+1Ch] [bp-10h]@1

  GetClientRect(hWnd, &Rect);
  Rect.bottom = *(_DWORD *)(a1 + 116);
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 & 0x2000 )
  {
    if ( v4 & 0x8000 && *(_DWORD *)(a1 + 108) )
      PaintWithPaletteBrush(hdc, &Rect, *(HPALETTE *)(a1 + 112), *(HGDIOBJ *)(a1 + 128));
    result = SetBkMode(hdc, 1);
  }
  else if ( v4 & 0x80000 && *(_DWORD *)(a1 + 124) )
  {
    v6 = Rect.right - Rect.left - 54;
    FillRect(hdc, &Rect, g_hbrWindow);
    SetRect(&rc, v6, 5, v6 + 49, 54);
    PaintWithPaletteBitmap(hdc, (int)&rc, *(HPALETTE *)(a1 + 112), *(HANDLE *)(a1 + 124));
    SetBkColor(hdc, g_clrWindow);
    result = SetTextColor(hdc, g_clrWindowText);
  }
  else
  {
    result = SendMessageW(hWnd, 0x138u, (WPARAM)hdc, (LPARAM)hWnd);
  }
  if ( !(*(_DWORD *)(a1 + 8) & 0x2000) )
    Rect.right -= 64;
  if ( *(_DWORD *)(a2 + 48) & 0x1000 )
  {
    result = *(_DWORD *)(a2 + 84);
    if ( result )
      result = _WriteHeaderTitle(a1, hdc, (int)&Rect, (LPCWSTR)result, 1, 0x2810u);
  }
  if ( *(_DWORD *)(a2 + 48) & 0x2000 )
  {
    v7 = *(const WCHAR **)(a2 + 88);
    if ( v7 )
      result = _WriteHeaderTitle(a1, hdc, (int)&Rect, v7, 0, 0x2810u);
  }
  return result;
}

//----- (6F796604) --------------------------------------------------------
HLOCAL __stdcall Prsht_FreeTitle(int a1)
{
  HLOCAL result; // eax@1
  void *v2; // ecx@2

  result = *(HLOCAL *)(a1 + 96);
  if ( (unsigned __int8)result & 0x10 )
  {
    result = (HLOCAL)((unsigned int)result & 0xFFFFFFEF);
    *(_DWORD *)(a1 + 96) = result;
    v2 = *(void **)(a1 + 24);
    if ( (unsigned int)v2 & 0xFFFF0000 )
      result = LocalFree(v2);
  }
  return result;
}

//----- (6F796634) --------------------------------------------------------
int __stdcall Prsht_EraseWizBkgnd(int a1, HDC hDC)
{
  int v2; // edi@1
  void *v3; // ST0C_4@5
  HPALETTE v4; // ST08_4@5
  struct tagRECT Rect; // [sp+8h] [bp-10h]@1

  v2 = 0;
  GetClientRect(*(HWND *)a1, &Rect);
  if ( *(_DWORD *)(a1 + 8) & 0x2000 )
  {
    if ( *(_DWORD *)(a1 + 108) )
    {
      PaintWithPaletteBrush(hDC, &Rect, *(HPALETTE *)(a1 + 112), *(HGDIOBJ *)(a1 + 108));
      return 1;
    }
  }
  else if ( *(_DWORD *)(a1 + 104) )
  {
    Rect.left = 164;
    FillRect(hDC, &Rect, g_hbrWindow);
    v3 = *(void **)(a1 + 104);
    v4 = *(HPALETTE *)(a1 + 112);
    Rect.right = Rect.left;
    Rect.left = 0;
    PaintWithPaletteBitmap(hDC, (int)&Rect, v4, v3);
    return 1;
  }
  return v2;
}

//----- (6F7966BB) --------------------------------------------------------
LRESULT __stdcall WizardWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  LRESULT result; // eax@8
  HPALETTE v7; // eax@24
  HWND v8; // eax@26
  LRESULT v9; // esi@28
  COLORREF v10; // eax@29
  COLORREF v11; // eax@29
  struct tagPOINT pt; // [sp+Ch] [bp-8h]@26

  if ( uMsg > 0x135 )
  {
    if ( uMsg == 310 )
    {
LABEL_21:
      if ( !(*(_DWORD *)(dwRefData + 8) & 0x2000) )
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      goto LABEL_22;
    }
    if ( uMsg <= 0x136 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    if ( uMsg <= 0x138 )
      goto LABEL_22;
    if ( uMsg != 783 )
    {
      if ( uMsg != 785 )
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      if ( (HWND)wParam == hWnd )
        return 0;
    }
    HandlePaletteChange(dwRefData, uMsg, hWnd);
    return 1;
  }
  if ( uMsg >= 0x134 )
    goto LABEL_22;
  if ( uMsg == 2 )
  {
    RemoveWindowSubclass(hWnd, WizardWndProc, 0);
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  if ( uMsg == 20 )
  {
    if ( !Prsht_EraseWizBkgnd(dwRefData, (HDC)wParam) )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    return 1;
  }
  if ( uMsg != 25 && uMsg != 306 )
  {
    if ( uMsg != 307 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    goto LABEL_21;
  }
LABEL_22:
  if ( *(_DWORD *)(dwRefData + 8) & 0x2000 )
  {
    if ( !*(_DWORD *)(dwRefData + 108) )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    SetBkMode((HDC)wParam, 1);
    v7 = *(HPALETTE *)(dwRefData + 112);
    if ( v7 )
    {
      SelectPalette((HDC)wParam, v7, 0);
      RealizePalette((HDC)wParam);
    }
    UnrealizeObject(*(HGDIOBJ *)(dwRefData + 108));
    GetDCOrgEx((HDC)wParam, &pt);
    v8 = GetParent((HWND)lParam);
    ScreenToClient(v8, &pt);
    SetBrushOrgEx((HDC)wParam, -pt.x, -pt.y, 0);
    result = *(_DWORD *)(dwRefData + 108);
  }
  else
  {
    if ( !*(_DWORD *)(dwRefData + 104) )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    v9 = DefWindowProcW(hWnd, uMsg, wParam, lParam);
    if ( v9 == DefSubclassProc(hWnd, uMsg, wParam, lParam) )
    {
      v10 = GetSysColor(8);
      SetTextColor((HDC)wParam, v10);
      v11 = GetSysColor(5);
      SetBkColor((HDC)wParam, v11);
      result = (LRESULT)g_hbrWindow;
    }
    else
    {
      result = v9;
    }
  }
  return result;
}

//----- (6F796855) --------------------------------------------------------
BOOL __stdcall EnumResLangProc(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam)
{
  BOOL result; // eax@1

  result = 1;
  if ( lpType == *(LPCWSTR *)(lParam + 8) && (!*(_WORD *)lParam || *(_WORD *)lParam == wLanguage) )
  {
    *(_DWORD *)(lParam + 4) = 1;
    *(_WORD *)lParam = wLanguage;
    result = 0;
  }
  return result;
}

//----- (6F79688C) --------------------------------------------------------
signed int __stdcall GetPageLanguage(int a1, int a2)
{
  __int16 v2; // ax@4
  const WCHAR *v3; // ST08_4@4
  signed int result; // eax@6
  LONG_PTR lParam; // [sp+4h] [bp-Ch]@4
  int v6; // [sp+8h] [bp-8h]@4
  int v7; // [sp+Ch] [bp-4h]@4

  if ( a1 && a2 && !(*(_BYTE *)(a1 + 48) & 1) )
  {
    v2 = *(_WORD *)a2;
    v6 = 0;
    LOWORD(lParam) = v2;
    v3 = *(const WCHAR **)(a1 + 56);
    v7 = 5;
    EnumResourceLanguagesW(*(HMODULE *)(a1 + 52), (LPCWSTR)5, v3, EnumResLangProc, (LONG_PTR)&lParam);
    if ( !v6 )
    {
      LOWORD(lParam) = 0;
      EnumResourceLanguagesW(
        *(HMODULE *)(a1 + 52),
        (LPCWSTR)5,
        *(LPCWSTR *)(a1 + 56),
        EnumResLangProc,
        (LONG_PTR)&lParam);
    }
    *(_WORD *)a2 = lParam;
    result = 0;
  }
  else
  {
    result = -2147467259;
  }
  return result;
}

//----- (6F79690F) --------------------------------------------------------
HRSRC __stdcall FindResourceExRetry(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
{
  HRSRC result; // eax@1

  result = FindResourceExW(hModule, lpType, lpName, wLanguage);
  if ( !result )
    result = FindResourceW(hModule, lpName, lpType);
  return result;
}

//----- (6F79695F) --------------------------------------------------------
UINT __stdcall GetDefaultCharsetFromLang(signed int a1)
{
  UINT v1; // esi@1
  int v2; // eax@4
  struct tagCHARSETINFO v4; // [sp+4h] [bp-34h]@4
  WCHAR LCData; // [sp+24h] [bp-14h]@3

  v1 = 1;
  if ( (a1 & 0x3FF) == 17 )
    a1 = 17;
  if ( GetLocaleInfoW((unsigned __int16)a1, 0x1004u, &LCData, 7) > 0 )
  {
    v2 = StrToIntW(&LCData);
    if ( TranslateCharsetInfo((DWORD *)v2, &v4, 2u) )
      v1 = v4.ciCharset;
  }
  return v1;
}

//----- (6F7969D6) --------------------------------------------------------
__int16 __stdcall GetShellResourceLangID()
{
  __int16 result; // ax@1
  HMODULE v1; // edi@2
  LONG_PTR lParam; // [sp+0h] [bp-Ch]@2
  int v3; // [sp+4h] [bp-8h]@2
  int v4; // [sp+8h] [bp-4h]@2

  result = word_6F7E8A94;
  if ( !word_6F7E8A94 )
  {
    v3 = 0;
    LOWORD(lParam) = 0;
    v4 = 5;
    v1 = LoadLibraryW(L"shell32.dll");
    if ( v1 )
    {
      EnumResourceLanguagesW(v1, (LPCWSTR)5, (LPCWSTR)0x428, EnumResLangProc, (LONG_PTR)&lParam);
      FreeLibrary(v1);
    }
    result = lParam & 0x3FF;
    if ( (lParam & 0x3FF) == 4 || result == 22 )
      result = lParam;
    word_6F7E8A94 = result;
  }
  return result;
}
// 6F7E8A94: using guessed type __int16 word_6F7E8A94;

//----- (6F796A69) --------------------------------------------------------
int __stdcall CCLoadStringExInternal(HMODULE hModule, int a2, void *Dst, int a4, WORD wLanguage)
{
  int v5; // esi@1
  int result; // eax@4
  HRSRC v7; // eax@5
  HGLOBAL v8; // eax@6
  bool v9; // zf@8
  int v10; // [sp+18h] [bp+Ch]@7

  v5 = 0;
  if ( Dst )
    *(_WORD *)Dst = 0;
  if ( a4 > 0 )
  {
    v7 = FindResourceExRetry(hModule, (LPCWSTR)6, (LPCWSTR)(((unsigned int)(unsigned __int16)a2 >> 4) + 1), wLanguage);
    if ( v7 )
    {
      v8 = LoadResource(hModule, v7);
      if ( v8 )
      {
        v10 = a2 & 0xF;
        if ( v10 )
        {
          do
          {
            v9 = v10-- == 1;
            v8 = (char *)v8 + 2 * *(_WORD *)v8 + 2;
          }
          while ( !v9 );
        }
        v5 = *(_WORD *)v8;
        if ( v5 >= a4 - 1 )
          v5 = a4 - 1;
        memcpy(Dst, (char *)v8 + 2, 2 * v5);
      }
    }
    *((_WORD *)Dst + v5) = 0;
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F796AF7) --------------------------------------------------------
signed int __stdcall ShouldUseMSShellDlg2Font(int a1)
{
  unsigned int v1; // edi@1
  LANGID v2; // bx@1
  signed int result; // eax@6
  char Dst; // [sp+Ch] [bp-1D0h]@2
  int v5; // [sp+6Ch] [bp-170h]@3
  int v6; // [sp+70h] [bp-16Ch]@4

  v1 = 0;
  v2 = GetMUILanguage();
  if ( *(_DWORD *)(a1 + 28) )
  {
    while ( !GetPageInfoEx(a1, *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v1), &Dst, v2, 0) || v5 && (v6 & 0x48) == 72 )
    {
      ++v1;
      if ( v1 >= *(_DWORD *)(a1 + 28) )
        goto LABEL_6;
    }
    result = 0;
  }
  else
  {
LABEL_6:
    result = 1;
  }
  return result;
}

//----- (6F796B74) --------------------------------------------------------
int __stdcall Prsht_GetOverrideState(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    result = (*(_DWORD *)(a1 + 8) >> 21) & 1;
  return result;
}

//----- (6F796B92) --------------------------------------------------------
int __stdcall Prsht_GetType(int a1, WORD wLanguage)
{
  int v3; // edi@3
  int v4; // [sp+4h] [bp-1D0h]@4
  char Dst; // [sp+8h] [bp-1CCh]@4
  int v6; // [sp+60h] [bp-174h]@6

  if ( !a1 )
    return 2;
  v3 = **(_DWORD **)(a1 + 36);
  if ( v3 )
  {
    v4 = 0;
    memset(&Dst, 0, 0x1C8u);
    if ( Mirror_IsProcessRTL() || GetPageInfoEx(a1, v3, &v4, wLanguage, 0) && v6 )
      return 0;
    GetPageLanguage(v3, (int)&wLanguage);
    if ( (wLanguage & 0x3FF) == 1 || (wLanguage & 0x3FF) == 13 )
      return 1;
  }
  return 2;
}

//----- (6F796C42) --------------------------------------------------------
int __stdcall Prsht_GetAction(unsigned int a1, unsigned int a2, unsigned int a3)
{
  int result; // eax@4

  if ( a1 > 2 || a2 > 4 || a3 > 1 )
    result = 0;
  else
    result = g_PSPT_Action[a3 + 2 * (a2 + 5 * a1)];
  return result;
}
// 6F796C78: using guessed type int g_PSPT_Action[];

//----- (6F796CF5) --------------------------------------------------------
void __stdcall Prsht_PrepareTemplate(void *Src, HMODULE hModule, int a3, int a4, LPCSTR lpName, int a6, int a7)
{
  LPVOID v7; // edi@1
  int v8; // ST0C_4@4
  unsigned int v9; // eax@4
  int v10; // eax@4
  int v11; // eax@5
  int v12; // eax@6
  int v13; // eax@7
  HRSRC v14; // eax@11
  HRSRC v15; // edi@11
  DWORD v16; // eax@13
  size_t v17; // ebx@13
  HLOCAL v18; // eax@13
  struct DLGTEMPLATE *v19; // esi@13
  HGLOBAL Srca; // [sp+Ch] [bp+8h]@12

  v7 = LockResource(*(HGLOBAL *)a3);
  if ( !v7 || *((_WORD *)v7 + 1) != -1 && *((_DWORD *)v7 + 1) & 0x500000 )
  {
    v8 = Prsht_GetOverrideState((int)Src);
    v9 = Prsht_GetType((int)Src, *(_WORD *)a7);
    v10 = Prsht_GetAction(v9, 3u, v8);
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        v12 = v11 - 1;
        if ( v12 )
        {
          v13 = v12 - 1;
          if ( v13 )
          {
            if ( v13 == 1 )
            {
              if ( v7 )
                *(_DWORD *)v7 |= 0x8000u;
            }
          }
          else
          {
            *(_WORD *)a7 = 1033;
            v14 = FindResourceExA(hModule, (LPCSTR)5, lpName, 0x409u);
            v15 = v14;
            if ( v14 )
            {
              Srca = LoadResource(hModule, v14);
              if ( Srca )
              {
                v16 = SizeofResource(hModule, v15);
                v17 = v16;
                v18 = LocalAlloc(0x40u, 2 * v16);
                v19 = (struct DLGTEMPLATE *)v18;
                if ( v18 )
                {
                  memmove(v18, Srca, v17);
                  EditBiDiDLGTemplate(v19, 1, 0, 0);
                  LocalFree(*(HLOCAL *)a3);
                  *(_DWORD *)a4 = v15;
                  *(_DWORD *)a3 = v19;
                }
              }
            }
          }
        }
        else if ( v7 )
        {
          EditBiDiDLGTemplate((struct DLGTEMPLATE *)v7, 1, 0, 0);
          EditBiDiDLGTemplate((struct DLGTEMPLATE *)v7, 2, (int)sub_6F796E38, 3);
          *((_DWORD *)Src + 25) = 1;
        }
      }
      else if ( v7 )
      {
        EditBiDiDLGTemplate((struct DLGTEMPLATE *)v7, 1, 0, 0);
      }
    }
  }
}

//----- (6F796E38) --------------------------------------------------------
int __userpurge sub_6F796E38@<eax>(int a1@<eax>, __int16 a2@<dx>, int a3@<edi>, int a4, int a5)
{
  *(_BYTE *)a1 &= HIBYTE(a2);
  *(_BYTE *)a3 ^= BYTE1(a1);
  *(_BYTE *)a1 ^= a1;
  *(_BYTE *)a1 += a1;
  *(_BYTE *)a1 += a1;
  *(_BYTE *)(a1 - 1869574000) += a2;
  return CreateProxyPage(a4, a5);
}

//----- (6F796E49) --------------------------------------------------------
int __stdcall CreateProxyPage(int a1, int a2)
{
  SetLastErrorEx(0x78u, 3u);
  return 0;
}

//----- (6F796E5D) --------------------------------------------------------
BOOL __stdcall DestroyPropsheetPageArray(int a1)
{
  int i; // esi@2
  BOOL result; // eax@3

  if ( !(*(_BYTE *)(a1 + 4) & 8) )
  {
    for ( i = *(_DWORD *)(a1 + 24); ; result = DestroyPropertySheetPage(*(HPROPSHEETPAGE *)(*(_DWORD *)(a1 + 32) + 4 * i)) )
    {
      --i;
      if ( i < 0 )
        break;
    }
  }
  return result;
}

//----- (6F796E8B) --------------------------------------------------------
signed int __stdcall CopyPropertyPageStrings(int a1, int (__stdcall *a2)(_DWORD))
{
  int v2; // eax@3
  int v3; // eax@7
  int v4; // eax@11
  int v5; // eax@15
  int v6; // eax@19
  signed int v8; // [sp+Ch] [bp-4h]@1

  v8 = 1;
  if ( !(*(_BYTE *)(a1 + 4) & 1) )
  {
    if ( *(_DWORD *)(a1 + 12) & 0xFFFF0000 )
    {
      v2 = a2(*(_DWORD *)(a1 + 12));
      *(_DWORD *)(a1 + 12) = v2;
      if ( !v2 )
        v8 = 0;
    }
  }
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    if ( *(_DWORD *)(a1 + 16) & 0xFFFF0000 )
    {
      v3 = a2(*(_DWORD *)(a1 + 16));
      *(_DWORD *)(a1 + 16) = v3;
      if ( !v3 )
        v8 = 0;
    }
  }
  if ( *(_BYTE *)(a1 + 4) & 8 )
  {
    if ( *(_DWORD *)(a1 + 20) & 0xFFFF0000 )
    {
      v4 = a2(*(_DWORD *)(a1 + 20));
      *(_DWORD *)(a1 + 20) = v4;
      if ( !v4 )
        v8 = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 4) & 0x1000 )
  {
    if ( *(_DWORD *)(a1 + 40) & 0xFFFF0000 )
    {
      v5 = a2(*(_DWORD *)(a1 + 40));
      *(_DWORD *)(a1 + 40) = v5;
      if ( !v5 )
        v8 = 0;
    }
  }
  if ( *(_DWORD *)(a1 + 4) & 0x2000 )
  {
    if ( *(_DWORD *)(a1 + 44) & 0xFFFF0000 )
    {
      v6 = a2(*(_DWORD *)(a1 + 44));
      *(_DWORD *)(a1 + 44) = v6;
      if ( !v6 )
        v8 = 0;
    }
  }
  return v8;
}

//----- (6F796F3B) --------------------------------------------------------
HLOCAL __stdcall FreePropertyPageStrings(int a1)
{
  HLOCAL result; // eax@2
  void *v2; // esi@14

  if ( !(*(_BYTE *)(a1 + 4) & 1) )
  {
    result = *(HLOCAL *)(a1 + 12);
    if ( (unsigned int)result & 0xFFFF0000 )
      result = LocalFree(*(HLOCAL *)(a1 + 12));
  }
  if ( *(_BYTE *)(a1 + 4) & 4 )
  {
    result = *(HLOCAL *)(a1 + 16);
    if ( (unsigned int)result & 0xFFFF0000 )
      result = LocalFree(*(HLOCAL *)(a1 + 16));
  }
  if ( *(_BYTE *)(a1 + 4) & 8 )
  {
    result = *(HLOCAL *)(a1 + 20);
    if ( (unsigned int)result & 0xFFFF0000 )
      result = LocalFree(*(HLOCAL *)(a1 + 20));
  }
  if ( *(_DWORD *)(a1 + 4) & 0x1000 )
  {
    result = *(HLOCAL *)(a1 + 40);
    if ( (unsigned int)result & 0xFFFF0000 )
      result = LocalFree(*(HLOCAL *)(a1 + 40));
  }
  if ( *(_DWORD *)(a1 + 4) & 0x2000 )
  {
    v2 = *(void **)(a1 + 44);
    if ( (unsigned int)v2 & 0xFFFF0000 )
      result = LocalFree(v2);
  }
  return result;
}

//----- (6F796FB3) --------------------------------------------------------
int __stdcall ThunkPropSheetHeaderAtoW(void *Src, void *Dst)
{
  size_t v2; // eax@1
  int v3; // eax@12
  void *v4; // ebx@16
  int v5; // eax@19
  int v6; // eax@22
  HLOCAL v8; // [sp+Ch] [bp-14h]@1
  HLOCAL v9; // [sp+10h] [bp-10h]@1
  HLOCAL hMem; // [sp+14h] [bp-Ch]@1

  v8 = 0;
  v9 = 0;
  hMem = 0;
  v2 = *(_DWORD *)Src;
  if ( *(_DWORD *)Src > 0x34u )
    v2 = 52;
  memmove(Dst, Src, v2);
  *((_DWORD *)Dst + 1) |= 0x800000u;
  if ( *((_DWORD *)Dst + 1) & 4 )
  {
    if ( *((_DWORD *)Dst + 4) & 0xFFFF0000 )
    {
      v8 = (HLOCAL)StrDup_AtoW(*((LPCSTR *)Dst + 4));
      *((_DWORD *)Dst + 4) = v8;
      if ( !v8 )
        return 0;
    }
  }
  if ( !(*((_DWORD *)Dst + 1) & 0x1402020) )
  {
    if ( *((_DWORD *)Dst + 5) & 0xFFFF0000 )
    {
      v9 = (HLOCAL)StrDup_AtoW(*((LPCSTR *)Dst + 5));
      *((_DWORD *)Dst + 5) = v9;
      if ( !v9 )
      {
LABEL_29:
        if ( v8 )
          LocalFree(v8);
        return 0;
      }
    }
  }
  if ( *((_BYTE *)Dst + 4) & 0x40 )
  {
    if ( *((_DWORD *)Dst + 7) & 0xFFFF0000 )
    {
      hMem = (HLOCAL)StrDup_AtoW(*((LPCSTR *)Dst + 7));
      *((_DWORD *)Dst + 7) = hMem;
      if ( !hMem )
      {
LABEL_27:
        if ( v9 )
          LocalFree(v9);
        goto LABEL_29;
      }
    }
  }
  v3 = *((_DWORD *)Dst + 1);
  if ( v3 & 0x1002000 )
  {
    if ( v3 & 0x8000 && !(v3 & 0x10000) && *((_DWORD *)Dst + 10) & 0xFFFF0000 )
    {
      v4 = (void *)StrDup_AtoW(*((LPCSTR *)Dst + 10));
      *((_DWORD *)Dst + 10) = v4;
      if ( !v4 )
      {
LABEL_25:
        if ( hMem )
          LocalFree(hMem);
        goto LABEL_27;
      }
    }
    else
    {
      v4 = 0;
    }
    v5 = *((_DWORD *)Dst + 1);
    if ( v5 & 0x80000 )
    {
      if ( !(v5 & 0x100000) )
      {
        if ( *((_DWORD *)Dst + 12) & 0xFFFF0000 )
        {
          v6 = StrDup_AtoW(*((LPCSTR *)Dst + 12));
          *((_DWORD *)Dst + 12) = v6;
          if ( !v6 )
          {
            if ( v4 )
              LocalFree(v4);
            goto LABEL_25;
          }
        }
      }
    }
  }
  return 1;
}

//----- (6F7970FC) --------------------------------------------------------
HLOCAL __stdcall FreePropSheetHeaderW(int a1)
{
  HLOCAL result; // eax@10
  void *v2; // esi@17

  if ( *(_BYTE *)(a1 + 4) & 4 && *(_DWORD *)(a1 + 16) & 0xFFFF0000 )
    LocalFree(*(HLOCAL *)(a1 + 16));
  if ( !(*(_DWORD *)(a1 + 4) & 0x1402020) && *(_DWORD *)(a1 + 20) & 0xFFFF0000 )
    LocalFree(*(HLOCAL *)(a1 + 20));
  if ( *(_BYTE *)(a1 + 4) & 0x40 && *(_DWORD *)(a1 + 28) & 0xFFFF0000 )
    LocalFree(*(HLOCAL *)(a1 + 28));
  result = *(HLOCAL *)(a1 + 4);
  if ( (unsigned int)result & 0x1002000 )
  {
    if ( (unsigned __int16)result & 0x8000 && !((unsigned int)result & 0x10000) && *(_DWORD *)(a1 + 40) & 0xFFFF0000 )
      LocalFree(*(HLOCAL *)(a1 + 40));
    result = *(HLOCAL *)(a1 + 4);
    if ( (unsigned int)result & 0x80000 && !((unsigned int)result & 0x100000) )
    {
      v2 = *(void **)(a1 + 48);
      if ( (unsigned int)v2 & 0xFFFF0000 )
        result = LocalFree(v2);
    }
  }
  return result;
}

//----- (6F79718E) --------------------------------------------------------
int __stdcall SetNewDefID(HWND hWnd)
{
  int v1; // esi@1
  int result; // eax@1
  int v3; // ebx@1
  HWND v4; // eax@5
  HWND v5; // [sp-10h] [bp-24h]@13
  WPARAM v6; // [sp-8h] [bp-1Ch]@13
  HWND hDlg; // [sp+Ch] [bp-8h]@1
  int nIDDlgItem; // [sp+10h] [bp-4h]@4
  HWND hWnda; // [sp+1Ch] [bp+8h]@5

  v1 = (int)hWnd;
  hDlg = *(HWND *)hWnd;
  result = (int)GetNextDlgTabItem(*((HWND *)hWnd + 14), 0, 0);
  v3 = result;
  if ( result )
  {
    if ( SendMessageW((HWND)result, 0x87u, 0, 0) & 8 )
      SendMessageW((HWND)v3, 0xB1u, 0, -1);
    nIDDlgItem = GetDlgCtrlID((HWND)v3);
    if ( (GetWindowLongW((HWND)v3, -16) & 0x18010000) == 268500992 )
    {
      v4 = _Ppd_SendNotify((int)hWnd, *((_DWORD *)hWnd + 16), -213, v3);
      hWnda = v4;
      if ( v4 && IsWindow(v4) && IsChild(*(HWND *)(v1 + 56), hWnda) )
        v3 = (int)hWnda;
    }
    else if ( *((_DWORD *)hWnd + 2) & 0x1402020 )
    {
      v3 = (int)GetDlgItem(hDlg, *((_DWORD *)hWnd + 17));
    }
    else
    {
      v3 = *((_DWORD *)hWnd + 15);
    }
    SetFocus((HWND)v3);
    ResetWizButtons(v1);
    if ( SendDlgItemMessageW(*(HWND *)(v1 + 56), nIDDlgItem, 0x87u, 0, 0) & 0x20 )
    {
      v6 = nIDDlgItem;
      v5 = *(HWND *)(v1 + 56);
    }
    else
    {
      v6 = *(_DWORD *)(v1 + 68);
      v5 = hDlg;
    }
    result = SendMessageW(v5, 0x401u, v6, 0);
  }
  return result;
}

//----- (6F797295) --------------------------------------------------------
void __stdcall PageChange(DWORD_PTR dwRefData, int a2)
{
  LRESULT v2; // eax@3
  LANGID v3; // ax@5
  HWND v4; // eax@5
  HWND v5; // eax@11
  bool v6; // zf@11
  HWND v7; // eax@12
  HWND v8; // eax@20
  int v9; // eax@21
  LRESULT v10; // eax@23
  int v11; // ST18_4@30
  HWND v12; // eax@30
  LONG v13; // eax@34
  HWND v14; // eax@38
  HWND v15; // eax@41
  WPARAM v16; // ebx@41
  HWND v17; // eax@41
  int v18; // [sp-1Ch] [bp-218h]@15
  int v19; // [sp-18h] [bp-214h]@15
  int v20; // [sp-14h] [bp-210h]@15
  int v21; // [sp-10h] [bp-20Ch]@15
  LPARAM lParam; // [sp+4h] [bp-1F8h]@4
  HWND v23; // [sp+1Ch] [bp-1E0h]@4
  struct tagRECT v24; // [sp+24h] [bp-1D8h]@12
  LPARAM v25; // [sp+34h] [bp-1C8h]@32
  WCHAR *v26; // [sp+40h] [bp-1BCh]@32
  struct tagRECT v27; // [sp+44h] [bp-1B8h]@15
  HWND v28; // [sp+54h] [bp-1A8h]@2
  HWND v29; // [sp+58h] [bp-1A4h]@20
  struct tagRECT v30; // [sp+5Ch] [bp-1A0h]@19
  struct tagRECT Rect; // [sp+6Ch] [bp-190h]@12
  unsigned int i; // [sp+7Ch] [bp-180h]@2
  HWND v33; // [sp+80h] [bp-17Ch]@11
  HWND hWnd; // [sp+84h] [bp-178h]@2
  HWND v35; // [sp+88h] [bp-174h]@4
  WPARAM wParam; // [sp+8Ch] [bp-170h]@3
  HWND hDlg; // [sp+90h] [bp-16Ch]@2
  WCHAR String; // [sp+94h] [bp-168h]@32

  if ( dwRefData )
  {
    hDlg = *(HWND *)dwRefData;
    hWnd = *(HWND *)(dwRefData + 60);
    v28 = GetFocus();
    for ( i = 1; i <= *(_DWORD *)(dwRefData + 28); ++i )
    {
      v2 = SendMessageW(hWnd, 0x130Bu, 0, 0);
      wParam = v2;
      if ( v2 < 0 )
        return;
      lParam = 8;
      SendMessageW(hWnd, 0x133Cu, v2, (LPARAM)&lParam);
      v35 = v23;
      if ( !v23 )
      {
        v3 = GetMUILanguage();
        v4 = (HWND)_CreatePage(dwRefData, *(void **)(*(_DWORD *)(dwRefData + 36) + 4 * wParam), hDlg, (HGLOBAL)v3);
        v35 = v4;
        if ( !v4 )
        {
          RemovePropPageData(dwRefData, wParam);
          SendMessageW(hWnd, 0x130Cu, 0, 0);
          continue;
        }
        v23 = v4;
        SendMessageW(hWnd, 0x133Du, wParam, (LPARAM)&lParam);
        if ( *(_DWORD *)(dwRefData + 8) & 0x1002000
          && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dwRefData + 36) + 4 * wParam) + 48) & 0x800 )
          SetWindowSubclass(v35, WizardWndProc, 0, dwRefData);
      }
      if ( *(_DWORD *)(dwRefData + 8) & 0x1402020 )
      {
        v5 = GetDlgItem(hDlg, 12327);
        v6 = (*(_DWORD *)(dwRefData + 8) & 0x1002000) == 0;
        v33 = v5;
        if ( v6 )
        {
          ShowWindow(v5, 0);
        }
        else
        {
          GetClientRect(hDlg, &Rect);
          v7 = GetDlgItemRect(hDlg, 12326, &v24);
          if ( v7 )
            SetWindowPos(v7, 0, Rect.left, v24.top, Rect.right - Rect.left, v24.bottom - v24.top, 0x14u);
          if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dwRefData + 36) + 4 * wParam) + 48) & 0x800 )
          {
            ShowWindow(v33, 0);
            ShowWindow(*(HWND *)(dwRefData + 60), 0);
            GetDlgItemRect(hDlg, 12326, &v27);
            v21 = v27.top - Rect.top;
            v20 = Rect.right - Rect.left;
            v19 = Rect.top;
            v18 = Rect.left;
            goto LABEL_20;
          }
          ShowWindow(v33, 5);
          ShowWindow(*(HWND *)(dwRefData + 60), 5);
        }
        v21 = *(_DWORD *)(dwRefData + 92);
        v20 = *(_DWORD *)(dwRefData + 88);
        v19 = *(_DWORD *)(dwRefData + 84);
        v18 = *(_DWORD *)(dwRefData + 80);
      }
      else
      {
        GetClientRect(*(HWND *)(dwRefData + 60), &v30);
        SendMessageW(*(HWND *)(dwRefData + 60), 0x1328u, 0, (LPARAM)&v30);
        MapWindowPoints(*(HWND *)(dwRefData + 60), hDlg, (LPPOINT)&v30, 2u);
        v21 = v30.bottom - v30.top;
        v20 = v30.right - v30.left;
        v19 = v30.top;
        v18 = v30.left;
      }
LABEL_20:
      SetWindowPos(v35, 0, v18, v19, v20, v21, 0);
      v8 = _Ppd_SendNotify(dwRefData, wParam, -200, 0);
      v29 = v8;
      if ( !v8 )
        goto LABEL_49;
      v9 = FindPageIndex(dwRefData, wParam, (HWND)((char *)v8 + 1) != 0 ? (unsigned int)v8 : 0, a2);
      v33 = (HWND)v9;
      if ( v29 == HWND_MESSAGE|0x2 )
      {
        if ( wParam == v9 || (v10 = SendMessageW(hWnd, 0x1304u, 0, 0), (signed int)v33 >= v10) )
          v33 = *(HWND *)(dwRefData + 64);
      }
      if ( v33 == HWND_MESSAGE|0x2 )
      {
LABEL_49:
        if ( *(_DWORD *)(dwRefData + 8) & 0x200 )
        {
          v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dwRefData + 36) + 4 * wParam) + 48) & 0x20;
          v12 = GetDlgItem(hDlg, 9);
          EnableWindow(v12, v11);
        }
        if ( *(_DWORD *)(dwRefData + 8) & 0x1402020 )
        {
          v26 = &String;
          v25 = 1;
          v27.left = 178;
          SendMessageW(hWnd, 0x133Cu, wParam, (LPARAM)&v25);
          v27.left = 0;
          v25 = 4;
          SendMessageW(hWnd, 0x133Cu, wParam, (LPARAM)&v25);
          if ( *(_DWORD *)(dwRefData + 8) & 0x800 || v27.left )
            v13 = GetWindowLongW(hDlg, -20) | 0x2000;
          else
            v13 = GetWindowLongW(hDlg, -20) & 0xFFFFDFFF;
          SetWindowLongW(hDlg, -20, v13);
          if ( String )
            SetWindowTextW(hDlg, &String);
        }
        *(_DWORD *)(dwRefData + 96) |= 1u;
        ShowWindow(v35, 5);
        v14 = *(HWND *)(dwRefData + 56);
        if ( v14 && v14 != v35 )
          ShowWindow(v14, 0);
        v15 = v35;
        *(_DWORD *)(dwRefData + 96) &= 0xFFFFFFFE;
        v16 = wParam;
        *(_DWORD *)(dwRefData + 56) = v15;
        v17 = hWnd;
        *(_DWORD *)(dwRefData + 64) = v16;
        if ( v28 == v17 )
          SendMessageW(hDlg, 0x28u, (WPARAM)v17, 1);
        else
          SetNewDefID((HWND)dwRefData);
        if ( *(_DWORD *)(dwRefData + 8) & 0x1002000 )
        {
          if ( !(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dwRefData + 36) + 4 * v16) + 48) & 0x800) )
            InvalidateRect(hDlg, 0, 1);
        }
        return;
      }
      SendMessageW(hWnd, 0x130Cu, (WPARAM)v33, 0);
      ShowWindow(v35, 0);
    }
  }
}

//----- (6F7977CB) --------------------------------------------------------
void *__stdcall RemovePropPage(DWORD_PTR dwRefData, int a2, WPARAM wParam)
{
  void *result; // eax@3
  LRESULT v4; // ebx@4
  WPARAM v5; // ebx@6
  HWND v6; // eax@11
  LPARAM lParam; // [sp+8h] [bp-20h]@1
  HWND hWnd; // [sp+20h] [bp-8h]@11
  int wParama; // [sp+38h] [bp+10h]@2

  lParam = 8;
  if ( wParam && (wParama = FindPageIndexByHpage(dwRefData, wParam), wParama != -1)
    || (result = (void *)a2, wParama = a2, (unsigned int)a2 < *(_DWORD *)(dwRefData + 28)) )
  {
    v4 = SendMessageW(*(HWND *)(dwRefData + 60), 0x130Bu, 0, 0);
    if ( wParama == v4 )
    {
      PageChanging(dwRefData);
      if ( v4 )
        v5 = v4 - 1;
      else
        v5 = 1;
      if ( SendMessageW(*(HWND *)(dwRefData + 60), 0x130Cu, v5, 0) == -1 )
        SendMessageW(*(HWND *)(dwRefData + 60), 0x130Cu, 0, 0);
      PageChange(dwRefData, 1);
    }
    lParam = 8;
    SendMessageW(*(HWND *)(dwRefData + 60), 0x133Cu, wParama, (LPARAM)&lParam);
    v6 = hWnd;
    if ( hWnd )
    {
      if ( *(HWND *)(dwRefData + 56) == hWnd )
        *(_DWORD *)(dwRefData + 56) = 0;
      DestroyWindow(v6);
    }
    result = RemovePropPageData(dwRefData, wParama);
  }
  return result;
}

//----- (6F797897) --------------------------------------------------------
int __stdcall PageSetSelection(DWORD_PTR dwRefData, WPARAM wParam, int a3, int a4)
{
  int v4; // ebx@2
  int v5; // eax@3
  int result; // eax@8
  LRESULT wParama; // [sp+14h] [bp+Ch]@11
  int v8; // [sp+18h] [bp+10h]@10

  if ( !a3 )
    goto LABEL_17;
  v4 = *(_DWORD *)(dwRefData + 28) - 1;
  if ( v4 >= 0 )
  {
    v5 = *(_DWORD *)(dwRefData + 36) + 4 * v4;
    do
    {
      if ( a3 == **(_DWORD **)v5 )
        break;
      --v4;
      v5 -= 4;
    }
    while ( v4 >= 0 );
  }
  if ( v4 == -1 )
  {
LABEL_17:
    v4 = wParam;
    if ( wParam == -1 )
      goto LABEL_16;
  }
  if ( v4 < 100 )
  {
    result = PageChanging(dwRefData) == 0;
    v8 = result;
    if ( result )
    {
      wParama = SendMessageW(*(HWND *)(dwRefData + 60), 0x130Bu, 0, 0);
      if ( SendMessageW(*(HWND *)(dwRefData + 60), 0x130Cu, v4, 0) == -1 )
      {
        SendMessageW(*(HWND *)(dwRefData + 60), 0x130Cu, wParama, 0);
        v8 = 0;
      }
      PageChange(dwRefData, a4);
      result = v8;
    }
  }
  else
  {
LABEL_16:
    result = 0;
  }
  return result;
}

//----- (6F79793A) --------------------------------------------------------
int __stdcall WizNextBack(DWORD_PTR dwRefData, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  int result; // eax@2
  int v5; // eax@3

  v2 = 2 * (a2 == -207) - 1;
  v3 = (int)_Ppd_SendNotify(dwRefData, *(_DWORD *)(dwRefData + 64), a2, 0);
  if ( v3 == -1 || (v5 = FindPageIndex(dwRefData, *(_DWORD *)(dwRefData + 64), v3, v2), v5 == -1) )
    result = 0;
  else
    result = PageSetSelection(dwRefData, v5, 0, v2);
  return result;
}

//----- (6F797992) --------------------------------------------------------
int __stdcall Prop_IsDialogMessage(DWORD_PTR dwRefData, LPMSG lpMsg)
{
  WPARAM v2; // eax@3
  struct tagMSG *v3; // ecx@5
  DWORD_PTR v4; // esi@7
  int v5; // ebx@9
  int v6; // eax@9
  HWND v7; // edi@11
  WPARAM v8; // edi@14
  unsigned int v9; // edi@16
  UINT v11; // eax@22
  DWORD_PTR dwRefDataa; // [sp+14h] [bp+8h]@14
  LPMSG lpMsga; // [sp+18h] [bp+Ch]@7

  if ( lpMsg->message == 256 && GetKeyState(17) < 0 )
  {
    v2 = lpMsg->wParam;
    if ( v2 == 9 )
    {
      v3 = (struct tagMSG *)(GetKeyState(16) < 0);
LABEL_7:
      v4 = dwRefData;
      lpMsga = v3;
      SendMessageW(*(HWND *)dwRefData, 0x127u, 0x30002u, 0);
      if ( *(_DWORD *)(dwRefData + 8) & 0x1402020 )
      {
        if ( lpMsga )
        {
          v5 = -206;
          v6 = 12323;
        }
        else
        {
          v5 = -207;
          v6 = 12324;
        }
        v7 = GetDlgItem(*(HWND *)dwRefData, v6);
        if ( IsWindowVisible(v7) )
        {
          if ( IsWindowEnabled(v7) )
            WizNextBack(dwRefData, v5);
        }
      }
      else
      {
        v8 = SendMessageW(*(HWND *)(dwRefData + 60), 0x130Bu, 0, 0);
        dwRefDataa = v8;
        do
        {
          if ( lpMsga )
            v9 = v8 + *(_DWORD *)(v4 + 28) - 1;
          else
            v9 = v8 + 1;
          v8 = v9 % *(_DWORD *)(v4 + 28);
        }
        while ( _Ppd_IsPageHidden(v4, v8) && v8 != dwRefDataa );
        PageSetSelection(v4, v8, 0, 1);
      }
      return 1;
    }
    if ( v2 - 33 <= 1 )
    {
      v3 = (struct tagMSG *)(v2 == 33);
      goto LABEL_7;
    }
  }
  v11 = lpMsg->message;
  if ( v11 >= 0x100
    && v11 <= 0x108
    && lpMsg->hwnd
    && (!IsChild(*(HWND *)dwRefData, lpMsg->hwnd) || IsChild(*(HWND *)(dwRefData + 56), lpMsg->hwnd))
    && _Ppd_SendNotify(dwRefData, *(_DWORD *)(dwRefData + 64), -212, (int)lpMsg) == (HWND)3 )
    return 1;
  return IsDialogMessageW(*(HWND *)dwRefData, lpMsg) != 0;
}

//----- (6F797AFB) --------------------------------------------------------
int __stdcall NT5_GetUserDefaultUILanguage()
{
  void *v0; // eax@1
  HMODULE v1; // eax@2

  v0 = (void *)_GetUserDefaultUILanguage;
  if ( !_GetUserDefaultUILanguage )
  {
    v1 = GetModuleHandleW(L"KERNEL32");
    if ( !v1 || (v0 = GetProcAddress(v1, "GetUserDefaultUILanguage")) == 0 )
      v0 = GetShellResourceLangID;
    _GetUserDefaultUILanguage = (int)v0;
  }
  return ((int (*)(void))v0)();
}
// 6F7E8E58: using guessed type int _GetUserDefaultUILanguage;

//----- (6F797B4E) --------------------------------------------------------
int __stdcall CCGetSystemDefaultThreadLocale(int a1)
{
  int result; // eax@1

  LOWORD(result) = NT5_GetUserDefaultUILanguage();
  if ( (unsigned __int16)result == (unsigned __int16)a1 )
    result = a1;
  else
    result = (unsigned __int16)result;
  return result;
}

//----- (6F797B76) --------------------------------------------------------
int __stdcall CCLoadStringEx(int a1, void *Dst, int a3, WORD wLanguage)
{
  return CCLoadStringExInternal(g_hinst, a1, Dst, a3, wLanguage);
}

//----- (6F797B9B) --------------------------------------------------------
HGDIOBJ __stdcall GetPageFontMetrics(int a1, int a2)
{
  HDC v2; // eax@9
  HDC v3; // edi@9
  int v4; // eax@10
  HFONT v5; // eax@10
  HGDIOBJ ho; // [sp+Ch] [bp-6Ch]@10
  HDC hdc; // [sp+10h] [bp-68h]@9
  HGDIOBJ h; // [sp+14h] [bp-64h]@1
  HGDIOBJ ha; // [sp+14h] [bp-64h]@11
  LOGFONTW lf; // [sp+18h] [bp-60h]@1

  lf.lfHeight = 0;
  memset(&lf.lfWidth, 0, 0x58u);
  h = 0;
  if ( a2 && *(_WORD *)a2 > 0 && *(_WORD *)(a2 + 2) )
  {
    StringCchCopyW(lf.lfFaceName, 0x20u, (STRSAFE_LPCWSTR)(a2 + 2));
    if ( *(_DWORD *)(a2 + 72) != *(_DWORD *)(a1 + 220)
      || *(_DWORD *)(a2 + 68) != *(_DWORD *)(a1 + 216)
      || *(_WORD *)a2 != *(_WORD *)(a1 + 148)
      || lstrcmpiW((LPCWSTR)(a2 + 2), (LPCWSTR)(a1 + 150)) )
    {
      v2 = GetDC(*(HWND *)a1);
      v3 = v2;
      hdc = v2;
      if ( v2 )
      {
        v4 = GetDeviceCaps(v2, 90);
        lf.lfHeight = -MulDiv(*(_WORD *)a2, v4, 72);
        lf.lfCharSet = *(_BYTE *)(a2 + 72);
        lf.lfItalic = *(_BYTE *)(a2 + 68);
        lf.lfWeight = 400;
        v5 = CreateFontIndirectW(&lf);
        ho = v5;
        if ( v5 )
        {
          ha = SelectObject(v3, v5);
          GetCharDimensions(hdc, (LPSIZE)(a1 + 224));
          if ( ha )
            SelectObject(hdc, ha);
          DeleteObject(ho);
          qmemcpy((void *)(a1 + 148), (const void *)a2, 0x4Cu);
          h = (HGDIOBJ)1;
        }
        ReleaseDC(*(HWND *)a1, hdc);
      }
    }
    else
    {
      h = (HGDIOBJ)1;
    }
  }
  return h;
}

//----- (6F797CF4) --------------------------------------------------------
LONG __stdcall Prsht_ComputeIdealPageSize(int a1, int a2, int a3)
{
  int v3; // edi@1
  UINT v4; // eax@4
  int v5; // ecx@12
  int v6; // eax@14
  LONG result; // eax@17
  LONG v8; // eax@18
  bool v9; // zf@18
  int v10; // eax@21
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@18
  int v12; // [sp+1Ch] [bp-4h]@1
  signed int v13; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v12 = *(_WORD *)(a1 + 140);
  v13 = 1;
  if ( GetPageLanguage(a2, (int)&v12) >= 0 )
  {
    if ( *(_DWORD *)(v3 + 8) & 0x200000 || (_WORD)v12 == *(_WORD *)(v3 + 140) )
      v4 = *(_DWORD *)(v3 + 144);
    else
      v4 = GetDefaultCharsetFromLang(v12);
    v13 = v4;
  }
  if ( *(_DWORD *)(a3 + 96) && (*(_BYTE *)(a3 + 100) & 0x48) == 72
    || (v12 & 0x3FF) == 1
    || *(_DWORD *)(v3 + 8) & 0x200000 && (NT5_GetUserDefaultUILanguage() & 0x3FF) == 17
    || (v5 = *(_DWORD *)(v3 + 144), v5 != v13) && (v13 != 1 || (v6 = *(_DWORD *)(a3 + 84), v6 != 1) && v6 != v5) )
  {
    if ( GetPageFontMetrics(v3, a3 + 12) )
    {
      *(_DWORD *)(a2 + 8) = MulDiv(*(_DWORD *)a3, *(_DWORD *)(v3 + 224), 4);
      result = MulDiv(*(_DWORD *)(a3 + 4), *(_DWORD *)(v3 + 228), 8);
LABEL_24:
      *(_DWORD *)(a2 + 12) = result;
      return result;
    }
  }
  v8 = *(_DWORD *)a3;
  Rect.left = 0;
  Rect.top = 0;
  Rect.right = v8;
  Rect.bottom = *(_DWORD *)(a3 + 4);
  MapDialogRect(*(HWND *)v3, &Rect);
  v9 = (*(_BYTE *)(a2 + 48) & 1) == 0;
  *(_DWORD *)(a2 + 8) = Rect.right;
  result = Rect.bottom;
  *(_DWORD *)(a2 + 12) = Rect.bottom;
  if ( !v9 && *(_DWORD *)(a3 + 84) == 1 )
  {
    result = StrCmpICW(a3 + 14, (int)L"MS Shell Dlg");
    if ( !result )
    {
      GetPageFontMetrics(v3, a3 + 12);
      v10 = MulDiv(*(_DWORD *)a3, *(_DWORD *)(v3 + 224), 4);
      if ( *(_DWORD *)(a2 + 8) < v10 )
        *(_DWORD *)(a2 + 8) = v10;
      result = MulDiv(*(_DWORD *)(a3 + 4), *(_DWORD *)(v3 + 228), 8);
      if ( *(_DWORD *)(a2 + 12) < result )
        goto LABEL_24;
    }
  }
  return result;
}
// 6F7928A8: using guessed type wchar_t aMsShellDlg[13];

//----- (6F797E6B) --------------------------------------------------------
int __stdcall InsertPropPage(int a1, int a2, void *Src)
{
  int v4; // edx@3
  int v5; // ebx@7
  int v6; // ecx@8
  WPARAM v7; // eax@13
  int v8; // edi@16
  LANGID v9; // ax@16
  LANGID v10; // ax@23
  WPARAM i; // ecx@25
  signed int v12; // eax@31
  LPARAM lParam; // [sp+8h] [bp-1F8h]@17
  char *v14; // [sp+14h] [bp-1ECh]@17
  int v15; // [sp+1Ch] [bp-1E4h]@19
  LPCDLGTEMPLATEA v16; // [sp+20h] [bp-1E0h]@17
  int v17; // [sp+24h] [bp-1DCh]@17
  HIMAGELIST himl; // [sp+28h] [bp-1D8h]@1
  WPARAM wParam; // [sp+2Ch] [bp-1D4h]@5
  char Dst; // [sp+30h] [bp-1D0h]@16
  HICON hicon; // [sp+38h] [bp-1C8h]@17
  int v22; // [sp+88h] [bp-178h]@17
  char v23; // [sp+98h] [bp-168h]@17

  himl = (HIMAGELIST)_Hijaak95Hack(a1, Src);
  if ( !himl )
    return 0;
  v4 = *(_DWORD *)(a1 + 28);
  if ( (unsigned int)v4 >= 0x64 )
    return 0;
  if ( a2 & 0xFFFF0000 )
  {
    v5 = 0;
    if ( v4 > 0 )
    {
      v6 = *(_DWORD *)(a1 + 36);
      do
      {
        if ( a2 == **(_DWORD **)v6 )
          break;
        ++v5;
        v6 += 4;
      }
      while ( v5 < v4 );
    }
    if ( v5 >= v4 )
      return 0;
    wParam = v5 + 1;
  }
  else
  {
    wParam = a2;
    if ( a2 > v4 )
      wParam = v4;
  }
  v7 = wParam;
  while ( 1 )
  {
    --v4;
    if ( v4 < (signed int)v7 )
      break;
    *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v4 + 4) = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v4);
  }
  v8 = *(_DWORD *)himl;
  *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v7) = *(_DWORD *)himl;
  ++*(_DWORD *)(a1 + 28);
  himl = (HIMAGELIST)SendMessageW(*(HWND *)(a1 + 60), 0x1302u, 0, 0);
  v9 = GetMUILanguage();
  if ( !GetPageInfoEx(a1, v8, &Dst, v9, 7) )
  {
LABEL_25:
    for ( i = wParam; (signed int)i < *(_DWORD *)(a1 + 28) - 1; ++i )
      *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * i) = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * i + 4);
    --*(_DWORD *)(a1 + 28);
    return 0;
  }
  Prsht_ComputeIdealPageSize(a1, v8, (int)&Dst);
  lParam = (v22 != 0 ? 4 : 0) | 0xB;
  v16 = 0;
  v14 = &v23;
  v17 = 0;
  if ( hicon )
  {
    if ( himl )
      v15 = ImageList_ReplaceIcon(himl, -1, hicon);
    DestroyIcon(hicon);
  }
  else
  {
    v15 = -1;
  }
  SendMessageW(*(HWND *)(a1 + 60), 0x133Eu, wParam, (LPARAM)&lParam);
  if ( *(_DWORD *)(v8 + 48) & 0x400 )
  {
    v10 = GetMUILanguage();
    v16 = _CreatePage(a1, (void *)v8, *(HWND *)a1, (HGLOBAL)v10);
    if ( !v16 )
    {
      SendMessageW(*(HWND *)(a1 + 60), 0x1308u, wParam, 0);
      goto LABEL_25;
    }
    lParam = 8;
    SendMessageW(*(HWND *)(a1 + 60), 0x133Du, wParam, (LPARAM)&lParam);
  }
  v12 = *(_DWORD *)(a1 + 64);
  if ( v12 >= (signed int)wParam )
    *(_DWORD *)(a1 + 64) = v12 + 1;
  return 1;
}

//----- (6F798085) --------------------------------------------------------
LPARAM __stdcall IsFontInstalled(int a1, STRSAFE_LPCWSTR pszSrc)
{
  HDC v2; // edi@1
  LPARAM lParam; // [sp+8h] [bp-64h]@1
  struct tagLOGFONTW Logfont; // [sp+Ch] [bp-60h]@1

  lParam = 0;
  Logfont.lfHeight = 0;
  memset(&Logfont.lfWidth, 0, 0x58u);
  StringCchCopyW(Logfont.lfFaceName, 0x20u, pszSrc);
  Logfont.lfCharSet = GetDefaultCharsetFromLang(a1);
  v2 = GetDC(0);
  if ( v2 )
  {
    EnumFontFamiliesExW(v2, &Logfont, FontEnumProc, (LPARAM)&lParam, 0);
    ReleaseDC(0, v2);
  }
  return lParam;
}

//----- (6F79810B) --------------------------------------------------------
__int16 __stdcall GetAltFontLangId(int a1)
{
  __int16 v1; // si@1
  LPARAM v2; // eax@2

  v1 = a1;
  if ( (a1 & 0x3FF) == 17 )
  {
    v2 = dword_6F7E84DC;
    if ( dword_6F7E84DC < 0 )
    {
      v2 = IsFontInstalled(a1, L"MS UI Gothic");
      dword_6F7E84DC = v2;
    }
    if ( v2 == 1 )
      v1 = a1 | 0xFC00;
  }
  return v1;
}
// 6F7E84DC: using guessed type int dword_6F7E84DC;

//----- (6F79816F) --------------------------------------------------------
unsigned int __stdcall CCGetProperThreadLocale(int a1)
{
  int v1; // esi@1
  LANGID v2; // ax@3
  unsigned int v3; // esi@4
  __int16 v4; // ax@6

  v1 = GetThreadLocale();
  if ( a1 )
    *(_DWORD *)a1 = v1;
  v2 = GetMUILanguage();
  if ( v2 )
    v3 = v2;
  else
    v3 = CCGetSystemDefaultThreadLocale(v1);
  v4 = GetAltFontLangId(v3);
  if ( v4 != (_WORD)v3 )
    v3 = (unsigned __int16)v4 | (((v3 >> 16) & 0xF) << 16);
  return v3;
}

//----- (6F7981C8) --------------------------------------------------------
int __stdcall LocalizedLoadString(int a1, void *Dst, int a3)
{
  WORD v3; // ax@1

  v3 = CCGetProperThreadLocale(0);
  return CCLoadStringEx(a1, Dst, a3, v3);
}

//----- (6F7981EC) --------------------------------------------------------
BOOL __stdcall _SetTitle(HWND a1, int a2)
{
  WCHAR *v2; // esi@1
  int v3; // ST18_4@6
  LONG v4; // eax@10
  WCHAR Buffer; // [sp+10h] [bp-2CCh]@2
  wchar_t pszDest; // [sp+110h] [bp-1CCh]@5
  WCHAR String; // [sp+274h] [bp-68h]@6

  v2 = *(WCHAR **)(a2 + 24);
  if ( !((unsigned int)v2 & 0xFFFF0000) )
  {
    LoadStringW(*(HINSTANCE *)(a2 + 16), (unsigned __int16)v2, &Buffer, 128);
    v2 = &Buffer;
  }
  if ( *(_BYTE *)(a2 + 8) & 1 )
  {
    if ( *v2 )
    {
      LocalizedLoadString(4162, &String, 50);
      v3 = lstrlenW(v2);
      if ( (unsigned int)(v3 + lstrlenW(&String) + 2) >= 0xB2 )
        goto LABEL_9;
      StringCchPrintfW(&pszDest, 0xB2u, &String, v2);
    }
    else
    {
      LocalizedLoadString(4177, &pszDest, 178);
    }
    v2 = &pszDest;
  }
LABEL_9:
  if ( *(_DWORD *)(a2 + 8) & 0x800 )
  {
    v4 = GetWindowLongW(a1, -20);
    SetWindowLongW(a1, -20, v4 | 0x2000);
  }
  return SetWindowTextW(a1, v2);
}

//----- (6F7982FF) --------------------------------------------------------
void __stdcall InitPropSheetDlg(HWND hWnd, LONG dwNewLong)
{
  bool v2; // zf@1
  HWND v3; // ST28_4@9
  HWND v4; // eax@9
  const WCHAR *v5; // eax@9
  HWND v6; // ST20_4@12
  signed int v7; // eax@12
  HWND v8; // ST28_4@16
  struct _IMAGELIST *v9; // eax@18
  HWND v10; // ST20_4@18
  void (__stdcall *v11)(_DWORD, _DWORD, _DWORD); // eax@27
  int v12; // eax@29
  HWND v13; // eax@30
  int v14; // eax@33
  LONG v15; // eax@41
  int v16; // eax@48
  LONG v17; // eax@49
  HWND v18; // ST2C_4@52
  HWND v19; // edi@53
  LONG v20; // eax@56
  HMONITOR v21; // eax@60
  int v22; // ecx@69
  LPARAM v23; // edx@69
  int v24; // eax@69
  HWND v25; // eax@70
  HWND v26; // eax@73
  HWND v27; // eax@75
  int v28; // eax@79
  int v29; // eax@82
  HWND v30; // eax@84
  int v31; // ST28_4@84
  int v32; // ST24_4@84
  int v33; // ST20_4@84
  int v34; // ST1C_4@84
  HWND v35; // eax@84
  int v36; // eax@85
  int v37; // eax@90
  int v38; // edi@91
  HANDLE v39; // eax@97
  int v40; // eax@101
  int v41; // edi@105
  void *v42; // edx@106
  int v43; // eax@107
  int v44; // ecx@107
  HBITMAP v45; // eax@111
  HBRUSH v46; // eax@115
  WPARAM v47; // eax@118
  WPARAM v48; // esi@121
  bool v49; // sf@121
  struct tagMONITORINFO mi; // [sp+Ch] [bp-3A4h]@60
  struct tagRECT v51; // [sp+34h] [bp-37Ch]@35
  LPARAM lParam; // [sp+44h] [bp-36Ch]@14
  WCHAR *v53; // [sp+50h] [bp-360h]@12
  int v54; // [sp+58h] [bp-358h]@14
  LPCDLGTEMPLATEA v55; // [sp+5Ch] [bp-354h]@12
  int v56; // [sp+60h] [bp-350h]@12
  struct tagRECT rc; // [sp+64h] [bp-34Ch]@36
  HGLOBAL hResData; // [sp+74h] [bp-33Ch]@12
  struct tagRECT rcDst; // [sp+78h] [bp-338h]@30
  WPARAM wParam; // [sp+88h] [bp-328h]@9
  LPARAM v61; // [sp+8Ch] [bp-324h]@35
  int v62; // [sp+90h] [bp-320h]@35
  int v63; // [sp+94h] [bp-31Ch]@35
  LONG v64; // [sp+98h] [bp-318h]@36
  void *Src; // [sp+9Ch] [bp-314h]@1
  int pvParam; // [sp+A0h] [bp-310h]@87
  char v67; // [sp+A4h] [bp-30Ch]@36
  int cy; // [sp+A8h] [bp-308h]@13
  struct tagRECT Rect; // [sp+ACh] [bp-304h]@29
  UINT flags; // [sp+BCh] [bp-2F4h]@16
  LPCWSTR lpString1; // [sp+C0h] [bp-2F0h]@1
  HIMAGELIST himl; // [sp+C4h] [bp-2ECh]@1
  WPARAM i; // [sp+C8h] [bp-2E8h]@12
  HWND hDlg; // [sp+CCh] [bp-2E4h]@1
  char Dst; // [sp+D0h] [bp-2E0h]@13
  HICON hicon; // [sp+D8h] [bp-2D8h]@14
  int v77; // [sp+128h] [bp-288h]@14
  WCHAR String2; // [sp+138h] [bp-278h]@12
  WCHAR Buffer; // [sp+29Ch] [bp-114h]@11
  struct tagRECT v80; // [sp+39Ch] [bp-14h]@32

  hDlg = hWnd;
  himl = 0;
  lpString1 = 0;
  Src = 0;
  SetWindowLongW(hWnd, 8, dwNewLong);
  v2 = (*(_DWORD *)(dwNewLong + 8) & 0x1402020) == 0;
  *(_DWORD *)(dwNewLong + 64) = 0;
  *(_DWORD *)(dwNewLong + 136) = 1;
  if ( v2 )
  {
    _SetTitle(hWnd, dwNewLong);
  }
  else
  {
    Prsht_SubclassButton(hWnd, 12323);
    Prsht_SubclassButton(hWnd, 12324);
    Prsht_SubclassButton(hWnd, 12325);
  }
  if ( *(_BYTE *)(dwNewLong + 8) & 4 )
    *(_DWORD *)(dwNewLong + 20) = LoadImageW(
                                    *(HINSTANCE *)(dwNewLong + 16),
                                    *(LPCWSTR *)(dwNewLong + 20),
                                    1u,
                                    g_cxSmIcon,
                                    g_cySmIcon,
                                    0);
  if ( *(_BYTE *)(dwNewLong + 8) & 6 && *(_DWORD *)(dwNewLong + 20) )
    SendMessageW(hDlg, 0x80u, 0, *(_DWORD *)(dwNewLong + 20));
  v3 = hDlg;
  *(_DWORD *)dwNewLong = hDlg;
  v4 = GetDlgItem(v3, 12320);
  *(_DWORD *)(dwNewLong + 60) = v4;
  SendMessageW(v4, 0x130Eu, 8u, 0);
  v2 = (*(_BYTE *)(dwNewLong + 8) & 0x40) == 0;
  v5 = *(const WCHAR **)(dwNewLong + 32);
  wParam = *(_DWORD *)(dwNewLong + 32);
  if ( !v2 )
  {
    wParam = 0;
    lpString1 = v5;
    if ( !((unsigned int)v5 & 0xFFFF0000) )
    {
      Buffer = 0;
      LoadStringW(*(HINSTANCE *)(dwNewLong + 16), (unsigned __int16)lpString1, &Buffer, 128);
      lpString1 = &Buffer;
    }
  }
  v6 = *(HWND *)(dwNewLong + 60);
  v55 = 0;
  v53 = &String2;
  v56 = 0;
  SendMessageW(v6, 0xBu, 0, 0);
  v7 = CCGetProperThreadLocale(0);
  *(_WORD *)(dwNewLong + 140) = v7;
  *(_DWORD *)(dwNewLong + 144) = GetDefaultCharsetFromLang(v7);
  hResData = (HGLOBAL)GetMUILanguage();
  for ( i = 0; i < *(_DWORD *)(dwNewLong + 28); ++i )
  {
    cy = *(_DWORD *)(*(_DWORD *)(dwNewLong + 36) + 4 * i);
    if ( GetPageInfoEx(dwNewLong, cy, &Dst, (WORD)hResData, 7) )
    {
      Prsht_ComputeIdealPageSize(dwNewLong, cy, (int)&Dst);
      v54 = -1;
      lParam = (v77 != 0 ? 4 : 0) | 0xB;
      if ( hicon )
      {
        if ( !himl )
        {
          v8 = *(HWND *)(dwNewLong + 60);
          flags = 1;
          if ( GetWindowLongW(v8, -20) & 0x400000 )
            flags = 8193;
          v9 = ImageList_Create(g_cxSmIcon, g_cySmIcon, flags, 8, 4);
          v10 = *(HWND *)(dwNewLong + 60);
          himl = v9;
          SendMessageW(v10, 0x1303u, 0, (LPARAM)v9);
        }
        v54 = ImageList_ReplaceIcon(himl, -1, hicon);
        DestroyIcon(hicon);
      }
      SendMessageW(*(HWND *)(dwNewLong + 60), 0x133Eu, 0x3E8u, (LPARAM)&lParam);
      if ( *(_DWORD *)(cy + 48) & 0x400 )
        Src = (void *)1;
      if ( *(_BYTE *)(dwNewLong + 8) & 0x40 && !lstrcmpiW(lpString1, &String2) )
        wParam = i;
    }
    else
    {
      RemovePropPageData(dwNewLong, i--);
    }
  }
  SendMessageW(*(HWND *)(dwNewLong + 60), 0xBu, 1u, 0);
  v11 = *(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(dwNewLong + 40);
  if ( v11 )
    v11(hDlg, 1, 0);
  GetWindowRect(hDlg, &Rect);
  v12 = *(_DWORD *)(dwNewLong + 8);
  if ( v12 & 0x400000 )
  {
    *(_DWORD *)(dwNewLong + 8) = v12 & 0xFEFFDFFF;
    v13 = GetDlgItemRect(hDlg, 12326, &rcDst);
    if ( v13 )
      SetWindowPos(v13, 0, 0, rcDst.top, Rect.right - Rect.left, rcDst.bottom - rcDst.top, 0x14u);
    GetClientRect(hDlg, &v80);
    SetWindowPos(*(HWND *)(dwNewLong + 60), 0, 0, 0, v80.right - v80.left, rcDst.top, 0x14u);
  }
  v14 = *(_DWORD *)(dwNewLong + 8);
  if ( v14 & 0x2000 )
    *(_DWORD *)(dwNewLong + 8) = v14 & 0xFEFFFFFF;
  GetClientRect(*(HWND *)(dwNewLong + 60), &v51);
  *(_DWORD *)(dwNewLong + 232) = v51.right;
  *(_DWORD *)(dwNewLong + 236) = v51.bottom;
  v62 = 0;
  v61 = 0;
  Prsht_GetIdealPageSize(dwNewLong, (int)&v63, 2);
  if ( *(_DWORD *)(dwNewLong + 8) & 0x2000 )
  {
    SetRect(&rc, 0, 0, 0, 58);
    MapDialogRect(hDlg, &rc);
    Prsht_GetIdealPageSize(dwNewLong, (int)&v67, 1);
    if ( v64 < cy - rc.bottom )
      v64 = cy - rc.bottom;
  }
  v2 = (*(_DWORD *)(dwNewLong + 8) & 0x1402020) == 0;
  rc = *(struct tagRECT *)&v61;
  if ( v2 )
  {
    cy = 2;
    do
    {
      v80 = rc;
      SendMessageW(*(HWND *)(dwNewLong + 60), 0x1328u, 1u, (LPARAM)&v80);
      v15 = v80.right - v80.left;
      v80.bottom -= v80.top;
      v80.top = 0;
      v80.left = 0;
      v80.right = v15;
      if ( v15 < rc.right )
        v80.right = rc.right;
      if ( v80.bottom < rc.bottom )
        v80.bottom = rc.bottom;
      SetWindowPos(*(HWND *)(dwNewLong + 60), 0, 0, 0, v80.right, v80.bottom, 0x16u);
      --cy;
    }
    while ( cy );
    rc = v80;
    *(_OWORD *)&v61 = v80;
    SendMessageW(*(HWND *)(dwNewLong + 60), 0x1328u, 0, (LPARAM)&v61);
  }
  else
  {
    *(_OWORD *)&v61 = rc;
  }
  i = 0;
  if ( *(_DWORD *)(dwNewLong + 8) & 0x1002000 )
  {
    CopyRect(&rcDst, (const RECT *)&v61);
    MapWindowPoints(*(HWND *)(dwNewLong + 60), hDlg, (LPPOINT)&rcDst, 2u);
    GetWindowRect(*(HWND *)(dwNewLong + 60), &v80);
    MapWindowPoints(0, hDlg, (LPPOINT)&v80, 2u);
    _SetHeaderFonts(hDlg, dwNewLong);
    v16 = _ComputeHeaderHeight((HGDIOBJ)dwNewLong, rcDst.right);
    v2 = (*(_DWORD *)(dwNewLong + 8) & 0x2000) == 0;
    *(_DWORD *)(dwNewLong + 116) = v16;
    if ( v2 )
    {
      SetRect(&rcDst, 0, 0, 0, 14);
      MapDialogRect(hDlg, &rcDst);
      Prsht_GetIdealPageSize(dwNewLong, (int)&v67, 1);
      v17 = v62 + cy - rcDst.bottom - v64;
      if ( *(_DWORD *)(dwNewLong + 116) < v17 )
        *(_DWORD *)(dwNewLong + 116) = v17;
    }
    i = *(_DWORD *)(dwNewLong + 116);
    SetWindowPos(*(HWND *)(dwNewLong + 60), 0, v80.left, i + v80.top, v80.right - v80.left, v80.bottom - v80.top, 0x14u);
  }
  v18 = *(HWND *)(dwNewLong + 12);
  flags = rc.right - v51.right;
  lpString1 = (LPCWSTR)(Rect.right + rc.right - v51.right - Rect.left);
  v80.left = *(_DWORD *)L"Static";
  i += rc.bottom - v51.bottom;
  v80.top = *(_DWORD *)L"\u7400\u6100\u7400\u6900\u6300";
  v80.right = *(_DWORD *)L"tatic";
  cy = i + Rect.bottom - Rect.top;
  LOWORD(v80.bottom) = aStatic[6];
  himl = (HIMAGELIST)22;
  if ( IsWindow(v18) )
  {
    GetWindowRect(*(HWND *)(dwNewLong + 12), &Rect);
    if ( IsWindowVisible(*(HWND *)(dwNewLong + 12)) )
    {
      v20 = GetWindowLongW(*(HWND *)(dwNewLong + 12), -20);
      Rect.top += g_cySmIcon;
      if ( v20 & 0x400000 )
        Rect.left = Rect.right - (_DWORD)lpString1 - g_cxSmIcon;
      else
        Rect.left += g_cxSmIcon;
    }
    himl = (HIMAGELIST)20;
  }
  else
  {
    v19 = CreateWindowExW(0, (LPCWSTR)&v80, 0, 0, 2147483648, 2147483648, 0, 0, 0, 0, g_hinst, 0);
    if ( v19 )
    {
      GetWindowRect(v19, &Rect);
      himl = (HIMAGELIST)20;
      DestroyWindow(v19);
    }
  }
  v21 = MonitorFromWindow(hDlg, 2u);
  mi.cbSize = 40;
  if ( GetMonitorInfoW(v21, &mi) )
  {
    if ( mi.rcMonitor.right < (signed int)((char *)lpString1 + Rect.left) )
      Rect.left = mi.rcMonitor.right - (_DWORD)lpString1;
    if ( mi.rcMonitor.left > Rect.left )
      Rect.left = mi.rcMonitor.left;
    if ( mi.rcMonitor.bottom < Rect.top + cy )
      Rect.top = mi.rcMonitor.bottom - cy;
    if ( mi.rcMonitor.top > Rect.top )
      Rect.top = mi.rcMonitor.top;
  }
  SetWindowPos(hDlg, 0, Rect.left, Rect.top, (int)lpString1, cy, (UINT)himl);
  MapWindowPoints(*(HWND *)(dwNewLong + 60), hDlg, (LPPOINT)&v61, 2u);
  v22 = v62;
  v23 = v63 - v61;
  *(_DWORD *)(dwNewLong + 80) = v61;
  v24 = v64 - v22;
  v2 = (*(_DWORD *)(dwNewLong + 8) & 0x1002000) == 0;
  *(_DWORD *)(dwNewLong + 84) = v22;
  *(_DWORD *)(dwNewLong + 88) = v23;
  *(_DWORD *)(dwNewLong + 92) = v24;
  if ( !v2 )
  {
    v25 = GetDlgItemRect(hDlg, 12327, &v80);
    if ( v25 )
      SetWindowPos(
        v25,
        0,
        v80.left,
        *(_DWORD *)(dwNewLong + 116),
        flags + v80.right - v80.left,
        v80.bottom - v80.top,
        0x14u);
  }
  if ( *(_DWORD *)(dwNewLong + 8) & 0x1402020 )
  {
    himl = (HIMAGELIST)dword_6F7928D8;
    v26 = GetDlgItemRect(hDlg, 12326, &v80);
    if ( v26 )
      SetWindowPos(v26, 0, v80.left, i + v80.top, flags + v80.right - v80.left, v80.bottom - v80.top, 0x14u);
    v27 = GetDlgItem(hDlg, 12323);
    EnableWindow(v27, 1);
    *(_DWORD *)(dwNewLong + 68) = 12324;
  }
  else
  {
    himl = (HIMAGELIST)dword_6F7928C8;
    *(_DWORD *)(dwNewLong + 68) = 1;
  }
  MoveAllButtons(hDlg, (int)himl, 9, *(_DWORD *)(dwNewLong + 100) == 0 ? flags : 0, i);
  if ( !(*(_DWORD *)(dwNewLong + 8) & 0x200) )
    RemoveButton(hDlg, 9, (HWND)himl);
  v28 = *(_DWORD *)(dwNewLong + 8);
  if ( (char)v28 < 0 && !(v28 & 0x1402020) )
    RemoveButton(hDlg, 12321, (HWND)himl);
  v29 = *(_DWORD *)(dwNewLong + 8);
  if ( v29 & 0x1402020 && !(v29 & 0x10) )
  {
    RemoveButton(hDlg, 12325, (HWND)himl);
    v30 = GetDlgItem(hDlg, 12324);
    GetWindowRect(v30, &v80);
    MapWindowPoints(0, hDlg, (LPPOINT)&v80, 2u);
    v31 = v80.bottom - v80.top;
    v32 = v80.right - v80.left;
    v33 = v80.top;
    v34 = v80.left;
    v35 = GetDlgItem(hDlg, 12325);
    SetWindowPos(v35, 0, v34, v33, v32, v31, 0x14u);
  }
  v36 = *(_DWORD *)(dwNewLong + 8);
  if ( v36 & 0x1002000 )
  {
    if ( v36 & 0x2000 )
    {
      pvParam = 12;
      *(_DWORD *)&v67 = 0;
      cy = 0;
      if ( SystemParametersInfoW(0x42u, 0xCu, &pvParam, 0) )
      {
        if ( v67 & 1 )
          *(_DWORD *)(dwNewLong + 8) &= 0xFFE47FFF;
      }
    }
    v37 = *(_DWORD *)(dwNewLong + 8);
    if ( v37 & 0x8000 )
    {
      v38 = 0;
      if ( *(_DWORD *)(dwNewLong + 44) )
      {
        flags = 0;
        if ( v37 & 0x40000 && v37 & 0x2000 && GetDlgItemRect(hDlg, 12326, &rcDst) )
        {
          v38 = rcDst.top;
          flags = (UINT)lpString1;
        }
        if ( *(_DWORD *)(dwNewLong + 8) & 0x10000 )
          v39 = CopyImage(*(HANDLE *)(dwNewLong + 44), 0, flags, v38, 4u);
        else
          v39 = LoadImageW(*(HINSTANCE *)(dwNewLong + 16), *(LPCWSTR *)(dwNewLong + 44), 0, flags, v38, 0x2000u);
        *(_DWORD *)(dwNewLong + 104) = v39;
        if ( v39 )
        {
          v40 = *(_DWORD *)(dwNewLong + 8) & 0x20000 ? *(_DWORD *)(dwNewLong + 48) : PaletteFromBmp(v39);
          *(_DWORD *)(dwNewLong + 112) = v40;
          if ( *(_DWORD *)(dwNewLong + 8) & 0x2000 )
            *(_DWORD *)(dwNewLong + 108) = CreatePatternBrush(*(HBITMAP *)(dwNewLong + 104));
        }
      }
    }
    v41 = *(_DWORD *)(dwNewLong + 8);
    if ( !(v41 & 0x80000) || (v42 = *(void **)(dwNewLong + 52)) == 0 )
    {
      *(_DWORD *)(dwNewLong + 124) = *(_DWORD *)(dwNewLong + 104);
      v46 = *(HBRUSH *)(dwNewLong + 108);
      goto LABEL_117;
    }
    v43 = 0;
    v44 = 0;
    if ( v41 & 0x40000 && v41 & 0x2000 )
    {
      v44 = (int)lpString1;
      v43 = *(_DWORD *)(dwNewLong + 116);
    }
    if ( v41 & 0x100000 )
      v45 = (HBITMAP)CopyImage(v42, 0, v44, v43, 4u);
    else
      v45 = (HBITMAP)LoadImageW(*(HINSTANCE *)(dwNewLong + 16), (LPCWSTR)v42, 0, v44, v43, 0x2000u);
    *(_DWORD *)(dwNewLong + 124) = v45;
    if ( v45 && *(_DWORD *)(dwNewLong + 8) & 0x2000 )
    {
      v46 = CreatePatternBrush(v45);
LABEL_117:
      *(_DWORD *)(dwNewLong + 128) = v46;
      goto LABEL_118;
    }
  }
LABEL_118:
  SendMessageW(hDlg, 0x402u, 0, 0);
  SetForegroundWindow(hDlg);
  v47 = wParam;
  *(_DWORD *)(dwNewLong + 72) = 0;
  if ( v47 >= *(_DWORD *)(dwNewLong + 28) )
    v47 = 0;
  SendMessageW(*(HWND *)(dwNewLong + 60), 0x130Cu, v47, 0);
  PageChange(dwNewLong, 1);
  if ( Src )
  {
    v48 = 0;
    v2 = *(_DWORD *)(dwNewLong + 28) == 0;
    v49 = *(_DWORD *)(dwNewLong + 28) < 0;
    lParam = 8;
    if ( !v49 && !v2 )
    {
      do
      {
        v2 = (*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(dwNewLong + 36) + 4 * v48) + 48) & 0x400) == 0;
        Src = *(void **)(*(_DWORD *)(dwNewLong + 36) + 4 * v48);
        if ( !v2 )
        {
          SendMessageW(*(HWND *)(dwNewLong + 60), 0x133Cu, v48, (LPARAM)&lParam);
          if ( !v55 )
          {
            v55 = _CreatePage(dwNewLong, Src, hDlg, hResData);
            if ( v55 )
              SendMessageW(*(HWND *)(dwNewLong + 60), 0x133Du, v48, (LPARAM)&lParam);
            else
              RemovePropPageData(dwNewLong, v48--);
          }
        }
        ++v48;
      }
      while ( (signed int)v48 < *(_DWORD *)(dwNewLong + 28) );
    }
  }
}
// 6F7928C8: using guessed type int dword_6F7928C8[4];
// 6F7928D8: using guessed type int dword_6F7928D8[];
// 6F7928EC: using guessed type wchar_t aStatic[7];

//----- (6F798F84) --------------------------------------------------------
int __stdcall ButtonPushed(DWORD_PTR dwRefData, int a2)
{
  HCURSOR v3; // eax@12
  HCURSOR v4; // eax@12
  HWND v5; // ebx@12
  HWND v6; // ST00_4@12
  HWND v7; // eax@14
  bool v8; // zf@21
  int v9; // eax@24
  HWND v10; // eax@25
  LPARAM lParam; // [sp+Ch] [bp-84h]@12
  int v12; // [sp+24h] [bp-6Ch]@13
  int v13; // [sp+28h] [bp-68h]@19
  HCURSOR hCursor; // [sp+2Ch] [bp-64h]@12
  int v15; // [sp+30h] [bp-60h]@1
  int v16; // [sp+34h] [bp-5Ch]@1
  HWND v17; // [sp+38h] [bp-58h]@1
  HWND hWnd; // [sp+3Ch] [bp-54h]@12
  int v19; // [sp+40h] [bp-50h]@7
  int v20; // [sp+44h] [bp-4Ch]@1
  int v21; // [sp+48h] [bp-48h]@1
  WPARAM wParam; // [sp+4Ch] [bp-44h]@12
  WCHAR String; // [sp+50h] [bp-40h]@25

  v15 = *(_DWORD *)(dwRefData + 72);
  v21 = 0;
  v16 = 1;
  v17 = 0;
  v20 = 0;
  if ( a2 != 1 )
  {
    if ( a2 != 2 )
    {
      if ( a2 != 8 )
      {
        if ( a2 != 12321 )
          return 0;
        goto LABEL_9;
      }
      v20 = 1;
    }
    v21 = 1;
    v19 = -203;
    goto LABEL_12;
  }
  v20 = 1;
  v21 = 1;
LABEL_9:
  if ( _Ppd_SendNotify(dwRefData, *(_DWORD *)(dwRefData + 64), -201, 0) )
    return 0;
  v15 = 1;
  v19 = -202;
LABEL_12:
  v3 = LoadCursorW(0, (LPCWSTR)0x7F02);
  v4 = SetCursor(v3);
  v5 = *(HWND *)(dwRefData + 60);
  v6 = *(HWND *)(dwRefData + 60);
  hCursor = v4;
  lParam = 8;
  wParam = 0;
  hWnd = (HWND)SendMessageW(v6, 0x1304u, 0, 0);
  if ( (signed int)hWnd > 0 )
  {
    do
    {
      SendMessageW(v5, 0x133Cu, wParam, (LPARAM)&lParam);
      if ( v12 )
      {
        v7 = _Ppd_SendNotify(dwRefData, wParam, v19, v20);
        v17 = v7;
        if ( v7 )
        {
          v16 = 0;
          if ( v7 != (HWND)2 )
          {
            SendMessageW(v5, 0x130Cu, wParam, 0);
LABEL_26:
            if ( v17 != (HWND)2 )
              goto LABEL_27;
          }
          goto LABEL_28;
        }
        if ( v19 == -202 && !v21 && *(_DWORD *)(dwRefData + 76) )
          v21 = 1;
        v13 &= 0xFFFFFFFE;
        SendMessageW(v5, 0x133Du, wParam, (LPARAM)&lParam);
      }
      ++wParam;
    }
    while ( (signed int)wParam < (signed int)hWnd );
  }
  *(_DWORD *)(dwRefData + 56) = 0;
  v8 = v21 == 0;
  *(_DWORD *)(dwRefData + 72) = v15;
  if ( v8 )
  {
    if ( !(*(_DWORD *)(dwRefData + 8) & 0x1402020) )
    {
      hWnd = GetDlgItem(*(HWND *)dwRefData, 12321);
      SendMessageW(hWnd, 0xF4u, 0, 1);
      EnableWindow(hWnd, 0);
      ResetWizButtons(dwRefData);
      SendMessageW(*(HWND *)dwRefData, 0x401u, 1u, 0);
      *(_DWORD *)(dwRefData + 68) = 1;
    }
    v9 = *(_DWORD *)(dwRefData + 96);
    if ( v9 & 2 )
    {
      *(_DWORD *)(dwRefData + 96) = v9 & 0xFFFFFFFD;
      LocalizedLoadString(4161, &String, 30);
      SetDlgItemTextW(*(HWND *)dwRefData, 1, &String);
      v10 = GetDlgItem(*(HWND *)dwRefData, 2);
      EnableWindow(v10, 1);
      goto LABEL_26;
    }
LABEL_27:
    PageChange(dwRefData, 1);
  }
LABEL_28:
  SetCursor(hCursor);
  return v16;
}

//----- (6F799193) --------------------------------------------------------
int __stdcall Prsht_OnCommand(DWORD_PTR dwRefData, int nIDDlgItem, HWND hWnd, __int16 a4)
{
  HWND v4; // ebx@1
  DWORD_PTR v5; // esi@2
  HWND v6; // eax@3
  HWND v7; // ebx@18

  v4 = hWnd;
  if ( hWnd )
  {
    v5 = dwRefData;
    if ( GetParent(hWnd) != *(HWND *)dwRefData )
    {
LABEL_3:
      v6 = (HWND)_Ppd_GetPage(v5, *(_DWORD *)(v5 + 64));
      SendMessageW(v6, 0x111u, (unsigned __int16)nIDDlgItem | ((unsigned __int16)a4 << 16), (LPARAM)v4);
      return 1;
    }
  }
  else
  {
    v5 = dwRefData;
    v4 = GetDlgItem(*(HWND *)dwRefData, nIDDlgItem);
  }
  if ( nIDDlgItem > 9 )
  {
    if ( nIDDlgItem != 12321 )
    {
      if ( nIDDlgItem <= 12322 )
        goto LABEL_3;
      if ( nIDDlgItem <= 12324 )
      {
        *(_DWORD *)(v5 + 68) = nIDDlgItem;
        WizNextBack(v5, (nIDDlgItem != 12324) - 207);
        return 1;
      }
      if ( nIDDlgItem != 12325 )
        goto LABEL_3;
      EnableWindow(*(HWND *)v5, 0);
      v7 = _Ppd_SendNotify(v5, *(_DWORD *)(v5 + 64), -208, 0);
      if ( v7 )
      {
        EnableWindow(*(HWND *)v5, 1);
        if ( IsWindow(v7) && IsChild(*(HWND *)v5, v7) )
          SetFocus(v7);
      }
      else
      {
        *(_DWORD *)(v5 + 56) = 0;
        *(_DWORD *)(v5 + 72) = 1;
      }
      return 1;
    }
LABEL_24:
    if ( !(*(_DWORD *)(v5 + 8) & 0x1402020) && ButtonPushed(v5, nIDDlgItem) )
      SendLastChanceApply(v5);
    return 1;
  }
  if ( nIDDlgItem == 9 )
  {
    if ( IsWindowEnabled(v4) )
      _Ppd_SendNotify(v5, *(_DWORD *)(v5 + 64), -205, 0);
    return 1;
  }
  if ( nIDDlgItem == 1 )
    goto LABEL_24;
  if ( nIDDlgItem != 2 && nIDDlgItem != 8 )
    goto LABEL_3;
  if ( !_Ppd_SendNotify(v5, *(_DWORD *)(v5 + 64), -209, 0) )
    ButtonPushed(v5, nIDDlgItem);
  return 1;
}

//----- (6F79930D) --------------------------------------------------------
void __stdcall Prsht_OnSetTitle(int a1, char a2, int a3, int (__stdcall *a4)(_DWORD))
{
  int v4; // edi@1
  int v5; // esi@4
  char v6; // al@4
  HWND v7; // ST00_4@4

  v4 = a3;
  if ( a3 & 0xFFFF0000 )
    v4 = a4(a3);
  if ( v4 )
  {
    v5 = a1;
    Prsht_FreeTitle(a1);
    v6 = a2 ^ *(_DWORD *)(a1 + 8);
    *(_DWORD *)(v5 + 96) |= 0x10u;
    v7 = *(HWND *)a1;
    *(_DWORD *)(v5 + 8) ^= v6 & 1;
    *(_DWORD *)(a1 + 24) = v4;
    _SetTitle(v7, a1);
  }
}

//----- (6F799358) --------------------------------------------------------
BOOL __stdcall PropSheetDlgProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // esi@1
  bool v5; // zf@15
  BOOL result; // eax@17
  HDC v7; // ebx@20
  int v8; // eax@21
  LRESULT v9; // eax@26
  int v10; // eax@28
  int v11; // ecx@39
  int v12; // eax@40
  int v13; // eax@59
  LONG v14; // edi@63
  HWND v15; // eax@68
  int i; // edi@72
  int v17; // eax@86
  HWND v18; // eax@90
  HWND v19; // eax@92
  HWND v20; // esi@92
  int v21; // eax@94
  int v22; // eax@101
  int v23; // eax@117
  HWND v24; // eax@129
  HWND v25; // eax@132
  void *v26; // eax@145
  void *v27; // eax@154
  HWND v28; // eax@118
  int v29; // esi@163
  int v30; // eax@165
  LONG v31; // esi@188
  WPARAM v32; // [sp-Ch] [bp-70h]@109
  int v33; // [sp-8h] [bp-6Ch]@109
  signed int v34; // [sp+Ch] [bp-58h]@128
  LRESULT v35; // [sp+14h] [bp-50h]@67
  HWND v36; // [sp+14h] [bp-50h]@128
  HWND v37; // [sp+18h] [bp-4Ch]@67
  HWND v38; // [sp+18h] [bp-4Ch]@128
  struct tagPAINTSTRUCT Paint; // [sp+20h] [bp-44h]@20

  v4 = GetWindowLongW(hWnd, 8);
  if ( !v4 && Msg != 272 )
    return 0;
  if ( Msg > 0x46C )
  {
    switch ( Msg )
    {
      default:
        return 0;
      case 0x470u:
        SetWizButtons(v4, lParam);
        return 1;
      case 0x473u:
      case 0x479u:
        v38 = GetDlgItem(hWnd, 12325);
        v34 = 0;
        v36 = GetFocus();
        if ( !(*(_BYTE *)(v4 + 8) & 0x10) )
        {
          v24 = GetDlgItem(hWnd, 12324);
          if ( v24 == v36 )
            v34 = 1;
          ShowWindow(v24, 0);
        }
        v25 = GetDlgItem(hWnd, 12323);
        if ( v25 == v36 )
          v34 = 1;
        ShowWindow(v25, 0);
        if ( lParam )
        {
          if ( Msg == 1139 )
            SetWindowTextA(v38, (LPCSTR)lParam);
          else
            SetWindowTextW(v38, (LPCWSTR)lParam);
        }
        ShowWindow(v38, 5);
        EnableWindow(v38, 1);
        ResetWizButtons(v4);
        SendMessageW(hWnd, 0x401u, 0x3025u, 0);
        *(_DWORD *)(v4 + 68) = 12325;
        if ( v34 )
          SetFocus(v38);
        return 1;
      case 0x46Fu:
        Prsht_OnSetTitle(v4, wParam, lParam, (int (__stdcall *)(_DWORD))StrDup_AtoW);
        return 1;
      case 0x478u:
        Prsht_OnSetTitle(v4, wParam, lParam, (int (__stdcall *)(_DWORD))StrDupW);
        return 1;
      case 0x47Du:
        if ( !lParam || !HIWORD(lParam) )
          goto LABEL_146;
        v26 = (void *)ProduceWFromA(0, (LPCSTR)lParam);
        goto LABEL_147;
      case 0x47Eu:
        if ( lParam )
        {
LABEL_146:
          v26 = StrDupW((LPCWSTR)lParam);
LABEL_147:
          if ( v26 )
            _SetHeaderTitles(hWnd, v4, wParam, v26, 1);
        }
        return 1;
      case 0x47Fu:
        if ( !lParam || !HIWORD(lParam) )
          goto LABEL_155;
        v27 = (void *)ProduceWFromA(0, (LPCSTR)lParam);
        goto LABEL_156;
      case 0x480u:
        if ( lParam )
        {
LABEL_155:
          v27 = StrDupW((LPCWSTR)lParam);
LABEL_156:
          if ( v27 )
            _SetHeaderTitles(hWnd, v4, wParam, v27, 0);
        }
        return 1;
      case 0x47Au:
        if ( !*(_DWORD *)(v4 + 136) )
          return 1;
        *(_DWORD *)(v4 + 136) = 0;
        v28 = GetDlgItem(*(HWND *)v4, 12321);
        goto LABEL_162;
      case 0x47Bu:
        v29 = v4 + 136;
        if ( !*(_DWORD *)v29 )
          *(_DWORD *)v29 = 1;
        return 1;
      case 0x472u:
        v30 = FindPageIndex(v4, *(_DWORD *)(v4 + 64), lParam, 1);
        if ( v30 == -1 )
          goto LABEL_183;
        v33 = 0;
        v32 = v30;
        goto LABEL_110;
      case 0x477u:
        v21 = InsertPropPage(v4, wParam, (void *)lParam);
        goto LABEL_191;
      case 0x46Du:
        PageInfoUnChange(v4, wParam);
        return 1;
      case 0x46Eu:
        v21 = ButtonPushed(v4, 12321);
        goto LABEL_191;
      case 0x474u:
        v14 = *(_DWORD *)(v4 + 60);
        goto LABEL_192;
      case 0x476u:
        v14 = *(_DWORD *)(v4 + 56);
        goto LABEL_192;
      case 0x471u:
        if ( wParam <= 6 )
          Prsht_OnCommand(v4, *(&nIDDlgItem + wParam), 0, 0);
        return 1;
      case 0x475u:
        v21 = Prop_IsDialogMessage(v4, (LPMSG)lParam);
        goto LABEL_191;
      case 0x481u:
        v21 = FindItem(*(HWND *)(v4 + 60), wParam, 0);
        goto LABEL_191;
      case 0x482u:
        if ( wParam >= *(_DWORD *)(v4 + 28) )
          goto LABEL_183;
        v21 = _Ppd_GetPage(v4, wParam);
        goto LABEL_191;
      case 0x483u:
        v21 = FindPageIndexByHpage(v4, lParam);
        goto LABEL_191;
      case 0x484u:
        if ( wParam >= *(_DWORD *)(v4 + 28) )
          goto LABEL_183;
        v14 = **(_DWORD **)(*(_DWORD *)(v4 + 36) + 4 * wParam);
        goto LABEL_192;
      case 0x486u:
        if ( wParam >= *(_DWORD *)(v4 + 28)
          || (v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * wParam) + 56), v14 & 0xFFFF0000) )
LABEL_183:
          v14 = 0;
        goto LABEL_192;
      case 0x485u:
        v21 = FindPageIndex(v4, *(_DWORD *)(v4 + 64), lParam, 0);
        goto LABEL_191;
      case 0x487u:
        if ( *(_DWORD *)(v4 + 56) )
        {
          v14 = -1;
        }
        else
        {
          v14 = *(_DWORD *)(v4 + 72);
          if ( v14 > 0 )
          {
            v31 = *(_DWORD *)(v4 + 76);
            if ( v31 )
              v14 = v31;
          }
        }
        goto LABEL_192;
      case 0x488u:
        v21 = Prsht_RecalcPageSizes(v4);
        break;
    }
    goto LABEL_191;
  }
  if ( Msg == 1132 )
  {
    v21 = QuerySiblings(v4, wParam, lParam);
    goto LABEL_191;
  }
  if ( Msg <= 0x82 )
  {
    if ( Msg == 130 )
    {
      *(_DWORD *)(v4 + 60) = 0;
      for ( i = *(_DWORD *)(v4 + 28); ; DestroyPropertySheetPage(**(HPROPSHEETPAGE **)(*(_DWORD *)(v4 + 36) + 4 * i)) )
      {
        --i;
        if ( i < 0 )
          break;
      }
      *(_DWORD *)(v4 + 56) = 0;
      if ( *(_DWORD *)(v4 + 8) & 0x400 )
        LocalFree((HLOCAL)v4);
      return 0;
    }
    if ( Msg <= 0x16 )
    {
      if ( Msg != 22 )
      {
        if ( Msg == 2 )
        {
          v9 = SendMessageW(*(HWND *)(v4 + 60), 0x1302u, 0, 0);
          if ( v9 )
            ImageList_Destroy((HIMAGELIST)v9);
          v10 = *(_DWORD *)(v4 + 8);
          if ( v10 & 0x1002000 )
          {
            if ( v10 & 0x8000 )
            {
              if ( (!(v10 & 0x10000) || *(_DWORD *)(v4 + 104) != *(_DWORD *)(v4 + 44)) && *(_DWORD *)(v4 + 104) )
                DeleteObject(*(HGDIOBJ *)(v4 + 104));
              if ( !(*(_DWORD *)(v4 + 8) & 0x20000) && *(_DWORD *)(v4 + 112) )
                DeleteObject(*(HGDIOBJ *)(v4 + 112));
              if ( *(_DWORD *)(v4 + 108) )
                DeleteObject(*(HGDIOBJ *)(v4 + 108));
            }
            v11 = *(_DWORD *)(v4 + 8);
            if ( v11 & 0x80000 )
            {
              v12 = *(_DWORD *)(v4 + 52);
              if ( v12 )
              {
                if ( (!(v11 & 0x100000) || *(_DWORD *)(v4 + 124) != v12) && *(_DWORD *)(v4 + 124) )
                  DeleteObject(*(HGDIOBJ *)(v4 + 124));
                if ( *(_DWORD *)(v4 + 128) )
                  DeleteObject(*(HGDIOBJ *)(v4 + 128));
              }
            }
            if ( *(_DWORD *)(v4 + 120) )
              DeleteObject(*(HGDIOBJ *)(v4 + 120));
          }
          if ( *(_BYTE *)(v4 + 8) & 4 && *(_DWORD *)(v4 + 20) )
            DestroyIcon(*(HICON *)(v4 + 20));
          Prsht_FreeTitle(v4);
          return 1;
        }
        if ( Msg == 6 )
          goto LABEL_92;
        if ( Msg != 10 )
        {
          if ( Msg == 15 )
          {
            v7 = BeginPaint(hWnd, &Paint);
            if ( *(_DWORD *)(v4 + 8) & 0x1002000 )
            {
              v8 = *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * *(_DWORD *)(v4 + 64));
              if ( !(*(_DWORD *)(v8 + 48) & 0x800) )
                PropSheetPaintHeader(v4, v8, hWnd, v7);
            }
            if ( Paint.fErase )
              SendMessageW(hWnd, 0x14u, (WPARAM)v7, 0);
            EndPaint(hWnd, &Paint);
            return 1;
          }
          if ( Msg != 17 )
          {
            if ( Msg == 20 )
              return *(_DWORD *)(v4 + 96) & 1;
            v5 = Msg == 21;
            goto LABEL_16;
          }
        }
      }
LABEL_90:
      v18 = *(HWND *)(v4 + 60);
      if ( v18 )
        SendMessageW(v18, Msg, wParam, lParam);
LABEL_92:
      v19 = (HWND)_Ppd_GetPage(v4, *(_DWORD *)(v4 + 64));
      v20 = v19;
      if ( !v19 || !IsWindow(v19) )
      {
        if ( Msg != 785 && Msg != 783 )
          return 0;
        return 1;
      }
      v21 = SendMessageW(v20, Msg, wParam, lParam);
      goto LABEL_191;
    }
    if ( Msg == 26 )
    {
LABEL_67:
      v37 = 0;
      v35 = SendMessageW(*(HWND *)(v4 + 60), 0x1304u, 0, 0);
      if ( v35 > 0 )
      {
        do
        {
          v15 = (HWND)_Ppd_GetPage(v4, (WPARAM)v37);
          if ( v15 )
            SendMessageW(v15, Msg, wParam, lParam);
          v37 = (HWND)((char *)v37 + 1);
        }
        while ( (signed int)v37 < v35 );
      }
      SendMessageW(*(HWND *)(v4 + 60), Msg, wParam, lParam);
      return 1;
    }
    if ( Msg == 28 )
      goto LABEL_92;
    if ( Msg == 78 )
    {
      v13 = *(_DWORD *)(lParam + 8);
      if ( v13 != -553 )
      {
        if ( v13 != -552 )
        {
          if ( v13 != -551 )
            return 0;
          PageChange(v4, 1);
          return 1;
        }
        v14 = (LONG)PageChanging(v4);
        if ( !v14 )
          SetWindowPos(*(HWND *)(v4 + 56), (HWND)1, 0, 0, 0, 0, 0x13u);
        goto LABEL_192;
      }
      *(_DWORD *)(lParam + 24) = Prsht_GetObject(
                                   (void *)v4,
                                   hWnd,
                                   *(_DWORD *)(lParam + 12),
                                   *(_DWORD *)(lParam + 16),
                                   lParam + 20);
    }
    else if ( Msg != 83 && Msg != 123 )
    {
      v5 = Msg == 126;
LABEL_16:
      if ( !v5 )
        return 0;
      goto LABEL_67;
    }
    return 1;
  }
  if ( Msg > 0x465 )
  {
    if ( Msg == 1126 )
    {
      RemovePropPage(v4, wParam, lParam);
      return 1;
    }
    if ( Msg != 1127 )
    {
      switch ( Msg )
      {
        case 0x468u:
          PageInfoChange(v4, wParam);
          break;
        case 0x469u:
          *(_DWORD *)(v4 + 76) |= 2u;
          break;
        case 0x46Au:
          *(_DWORD *)(v4 + 76) |= 3u;
          break;
        default:
          if ( Msg != 1131 )
            return 0;
          v23 = *(_DWORD *)(v4 + 96);
          if ( !(v23 & 2) )
          {
            *(_DWORD *)(v4 + 96) = v23 | 2;
            LocalizedLoadString(4160, &Paint.fRestore, 20);
            SetDlgItemTextW(hWnd, 1, (LPCWSTR)&Paint.fRestore);
            v28 = GetDlgItem(hWnd, 2);
LABEL_162:
            EnableWindow(v28, 0);
          }
          break;
      }
      return 1;
    }
    v21 = InsertPropPage(v4, 0xFFFF, (void *)lParam);
LABEL_191:
    v14 = v21;
LABEL_192:
    SetWindowLongW(hWnd, 0, v14);
    return 1;
  }
  if ( Msg == 1125 )
  {
    v33 = lParam;
    v32 = wParam;
LABEL_110:
    v21 = PageSetSelection(v4, v32, v33, 1);
    goto LABEL_191;
  }
  if ( Msg == 272 )
  {
    InitPropSheetDlg(hWnd, lParam);
    return 0;
  }
  if ( Msg == 273 )
  {
    result = Prsht_OnCommand(v4, (unsigned __int16)wParam, (HWND)lParam, SHIWORD(wParam));
  }
  else
  {
    if ( Msg != 274 )
    {
      if ( Msg != 537 )
      {
        if ( Msg != 783 && (Msg != 785 || (HWND)wParam == hWnd) )
          return 0;
        v17 = *(_DWORD *)(v4 + 8);
        if ( v17 & 0x1002000 && v17 & 0x8000 && *(_DWORD *)(v4 + 48) )
          HandlePaletteChange(v4, Msg, hWnd);
      }
      goto LABEL_90;
    }
    if ( (unsigned __int16)(wParam & 0xFFF0) == 61776 )
    {
      result = HandleHotkey((HWND)lParam);
    }
    else
    {
      if ( (unsigned __int16)(wParam & 0xFFF0) != 61536 )
        return 0;
      v22 = 8;
      if ( *(_DWORD *)(v4 + 8) & 0x1402020 )
      {
        v22 = 2;
      }
      else if ( *(_BYTE *)(v4 + 96) & 2 )
      {
        v22 = 1;
      }
      result = Prsht_OnCommand(v4, v22, 0, 0);
    }
  }
  return result;
}

//----- (6F799B99) --------------------------------------------------------
int __stdcall _RealPropertySheet(HWND hWnd)
{
  DWORD_PTR v1; // esi@1
  HWND v2; // edi@2
  HWND v3; // eax@2
  bool v4; // zf@2
  LONG i; // eax@4
  const WCHAR *v6; // edi@15
  HRSRC v7; // eax@15
  HRSRC v8; // ebx@15
  DWORD v9; // eax@17
  size_t v10; // ebx@17
  HLOCAL v11; // eax@17
  HLOCAL v12; // edi@18
  int v13; // eax@25
  void (__stdcall *v14)(_DWORD, _DWORD, _DWORD); // eax@30
  int v15; // eax@35
  int result; // eax@41
  int j; // edi@45
  int v18; // edi@56
  struct tagMSG Msg; // [sp+Ch] [bp-3Ch]@50
  int v20; // [sp+28h] [bp-20h]@18
  HWND v21; // [sp+2Ch] [bp-1Ch]@2
  HLOCAL hMem; // [sp+30h] [bp-18h]@17
  int v23; // [sp+34h] [bp-14h]@10
  int v24; // [sp+38h] [bp-10h]@1
  HWND v25; // [sp+3Ch] [bp-Ch]@15
  void *Src; // [sp+40h] [bp-8h]@16
  WORD wLanguage[2]; // [sp+44h] [bp-4h]@10
  HWND hWnda; // [sp+50h] [bp+8h]@2

  v24 = -1;
  v1 = (DWORD_PTR)hWnd;
  if ( !*((_DWORD *)hWnd + 7) )
    goto LABEL_66;
  v2 = (HWND)*((_DWORD *)hWnd + 3);
  *((_DWORD *)hWnd + 18) = -1;
  *((_DWORD *)hWnd + 14) = 0;
  *((_DWORD *)hWnd + 19) = 0;
  hWnda = v2;
  v3 = GetFocus();
  v4 = (*(_DWORD *)(v1 + 8) & 0x400) == 0;
  v21 = v3;
  if ( v4 )
  {
    if ( v2 )
    {
      for ( i = GetWindowLongW(v2, -16); i & 0x40000000; i = GetWindowLongW(hWnda, -16) )
        hWnda = GetParent(hWnda);
      if ( hWnda == GetDesktopWindow() || EnableWindow(hWnda, 0) )
        hWnda = 0;
    }
  }
  v4 = (*(_DWORD *)(v1 + 8) & 0x200000) == 0;
  *(_DWORD *)wLanguage = 0;
  v23 = 0;
  if ( v4 )
  {
    *(_DWORD *)wLanguage = (unsigned __int16)CCGetProperThreadLocale(0);
  }
  else
  {
    if ( GetPageLanguage(**(_DWORD **)(v1 + 36), (int)wLanguage) < 0 )
      *(_DWORD *)wLanguage = 0;
    v23 = wLanguage[0];
  }
  v6 = (const WCHAR *)((*(_DWORD *)(v1 + 8) & 0x1402020) != 0 ? 1020 : 1006);
  v7 = FindResourceExRetry(g_hinst, (LPCWSTR)5, v6, wLanguage[0]);
  v25 = 0;
  v8 = v7;
  if ( !v7 )
    goto LABEL_42;
  Src = LoadResource(g_hinst, v7);
  if ( !Src )
    goto LABEL_42;
  v9 = SizeofResource(g_hinst, v8);
  v10 = v9;
  v11 = LocalAlloc(0x40u, 2 * v9);
  hMem = v11;
  if ( v11 )
  {
    memmove(v11, Src, v10);
    Prsht_PrepareTemplate((void *)v1, g_hinst, (int)&hMem, (int)&v20, (LPCSTR)v6, *(_DWORD *)(v1 + 12), (int)&v23);
    v12 = hMem;
  }
  else
  {
    v12 = Src;
  }
  if ( v12 != Src )
  {
    if ( *(_DWORD *)(v1 + 8) & 0x2000000 )
    {
      if ( *((_WORD *)v12 + 1) == -1 )
        *((_DWORD *)v12 + 3) &= 0xFFFFDFFF;
      else
        *(_DWORD *)v12 &= 0xFFFFDFFF;
    }
    v13 = *(_DWORD *)(v1 + 8);
    if ( v13 & 0x1402020 && v13 & 0x1000 )
    {
      if ( *((_WORD *)v12 + 1) == -1 )
        *((_DWORD *)v12 + 3) |= 0x2000u;
      else
        *(_DWORD *)v12 |= 0x2000u;
    }
    v14 = *(void (__stdcall **)(_DWORD, _DWORD, _DWORD))(v1 + 40);
    if ( v14 )
      v14(0, 2, v12);
  }
  if ( v12 )
  {
    if ( ShouldUseMSShellDlg2Font(v1) )
    {
      if ( *((_WORD *)v12 + 1) == -1 )
      {
LABEL_37:
        *((_DWORD *)v12 + 3) |= 0x48u;
        *(_DWORD *)(v1 + 96) |= 0x20u;
        goto LABEL_38;
      }
      v15 = GetDefaultCharsetFromLang(*(signed int *)wLanguage);
      if ( CvtDlgToDlgEx((struct DLGTEMPLATE *)v12, (struct tagDLGTEMPLATEEX **)&hMem, v15) >= 0 )
      {
        LocalFree(v12);
        v12 = hMem;
        goto LABEL_37;
      }
    }
LABEL_38:
    v25 = CreateDialogIndirectParamW(g_hinst, (LPCDLGTEMPLATEW)v12, *(HWND *)(v1 + 12), PropSheetDlgProc, v1);
    *(_DWORD *)v1 = v25;
  }
  if ( v12 != Src )
    LocalFree(v12);
  result = (int)v25;
  if ( !v25 )
  {
LABEL_42:
    if ( hWnda && !(*(_DWORD *)(v1 + 8) & 0x400) )
      EnableWindow(hWnda, 1);
    for ( j = *(_DWORD *)(v1 + 28); ; DestroyPropertySheetPage(**(HPROPSHEETPAGE **)(*(_DWORD *)(v1 + 36) + 4 * j)) )
    {
      --j;
      if ( j < 0 )
        break;
    }
    goto LABEL_66;
  }
  if ( *(_DWORD *)(v1 + 8) & 0x400 )
    return result;
  while ( *(_DWORD *)(v1 + 56) && GetMessageW(&Msg, 0, 0, 0) )
  {
    if ( !Prop_IsDialogMessage(v1, &Msg) )
    {
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
  }
  if ( *(_DWORD *)(v1 + 56) )
  {
    ButtonPushed(v1, 2);
    PostQuitMessage(Msg.wParam);
  }
  v18 = *(_DWORD *)(v1 + 72);
  v24 = *(_DWORD *)(v1 + 72);
  if ( *(_DWORD *)(v1 + 12) && GetActiveWindow() == v25 )
    SetActiveWindow(*(HWND *)(v1 + 12));
  if ( hWnda )
    EnableWindow(hWnda, 1);
  if ( IsWindow(v21) )
    SetFocus(v21);
  DestroyWindow(v25);
  if ( v18 > 0 && *(_DWORD *)(v1 + 76) )
    v24 = *(_DWORD *)(v1 + 76);
LABEL_66:
  LocalFree((HLOCAL)v1);
  return v24;
}

//----- (6F799ECD) --------------------------------------------------------
int __stdcall _PropertySheet(void *Src, int a2)
{
  HLOCAL v2; // eax@4
  int v3; // esi@4
  int result; // eax@5
  int v5; // eax@8
  int v6; // ebx@10
  void *v7; // edi@11
  int v8; // eax@17
  int v9; // edx@20
  int i; // ecx@20
  int v11; // eax@21
  int v12; // eax@22
  int v13; // edi@24

  if ( *(_DWORD *)Src >= 0x24u
    && !(*((_DWORD *)Src + 1) & 0xE0000000)
    && *((_DWORD *)Src + 6) < 0x64u
    && (v2 = LocalAlloc(0x40u, 0x280u), (v3 = (int)v2) != 0) )
  {
    *((_DWORD *)v2 + 24) = 0;
    if ( a2 )
      *((_DWORD *)v2 + 24) = 64;
    memmove((char *)v2 + 4, Src, *(_DWORD *)Src);
    v5 = *(_DWORD *)(v3 + 8);
    if ( !(v5 & 0x100) )
      *(_DWORD *)(v3 + 40) = 0;
    v6 = 0;
    *(_DWORD *)(v3 + 36) = v3 + 240;
    if ( v5 & 8 )
    {
      v7 = (void *)*((_DWORD *)Src + 8);
      if ( *(_DWORD *)(v3 + 28) > 0 )
      {
        do
        {
          *(_DWORD *)(*(_DWORD *)(v3 + 36) + 4 * v6) = _CreatePropertySheetPage(v7, a2, *(_DWORD *)(v3 + 96) & 8);
          if ( !*(_DWORD *)(*(_DWORD *)(v3 + 36) + 4 * v6) )
          {
            --v6;
            --*(_DWORD *)(v3 + 28);
          }
          v7 = (char *)v7 + *(_DWORD *)v7;
          ++v6;
        }
        while ( v6 < *(_DWORD *)(v3 + 28) );
      }
    }
    else
    {
      *(_DWORD *)(v3 + 28) = 0;
      if ( *((_DWORD *)Src + 6) > 0 )
      {
        do
        {
          *(_DWORD *)(*(_DWORD *)(v3 + 36) + 4 * *(_DWORD *)(v3 + 28)) = _Hijaak95Hack(
                                                                           v3,
                                                                           *(void **)(*((_DWORD *)Src + 8) + 4 * v6));
          v8 = *(_DWORD *)(v3 + 28);
          if ( *(_DWORD *)(*(_DWORD *)(v3 + 36) + 4 * v8) )
            *(_DWORD *)(v3 + 28) = v8 + 1;
          ++v6;
        }
        while ( v6 < *((_DWORD *)Src + 6) );
      }
    }
    v9 = 0;
    for ( i = 0; i < *(_DWORD *)(v3 + 28); *(_DWORD *)v11 = **(_DWORD **)v11 )
      v11 = *(_DWORD *)(v3 + 36) + 4 * i++;
    v12 = *(_DWORD *)(v3 + 8);
    if ( !(v12 & 0x200) && *(_DWORD *)(v3 + 28) > 0 )
    {
      v13 = *(_DWORD *)(v3 + 36);
      while ( !(*(_BYTE *)(*(_DWORD *)v13 + 48) & 0x20) )
      {
        ++v9;
        v13 += 4;
        if ( v9 >= *(_DWORD *)(v3 + 28) )
          goto LABEL_29;
      }
      *(_DWORD *)(v3 + 8) = v12 | 0x200;
    }
LABEL_29:
    result = _RealPropertySheet((HWND)v3);
  }
  else
  {
    DestroyPropsheetPageArray((int)Src);
    result = -1;
  }
  return result;
}

//----- (6F79A009) --------------------------------------------------------
INT_PTR __stdcall PropertySheetW(LPCPROPSHEETHEADERW a1)
{
  return _PropertySheet((void *)a1, 0);
}

//----- (6F79A021) --------------------------------------------------------
INT_PTR __stdcall PropertySheetA(LPCPROPSHEETHEADERA a1)
{
  INT_PTR result; // eax@3
  INT_PTR v2; // esi@4
  int Src; // [sp+4h] [bp-34h]@1
  char Dst; // [sp+8h] [bp-30h]@1

  Src = 0;
  memset(&Dst, 0, 0x30u);
  if ( a1->dwSize >= 0x24 && ThunkPropSheetHeaderAtoW((void *)a1, &Src) )
  {
    v2 = _PropertySheet(&Src, 1);
    FreePropSheetHeaderW((int)&Src);
    result = v2;
  }
  else
  {
    DestroyPropsheetPageArray((int)a1);
    result = -1;
  }
  return result;
}

//----- (6F79A081) --------------------------------------------------------
signed int __stdcall Status_GetRect(int a1, int a2, int a3)
{
  int v3; // edi@1
  LONG v4; // ecx@4
  int v5; // eax@6
  int v6; // edx@6
  int v7; // esi@6
  int v8; // ecx@6
  LONG v9; // eax@6
  int v10; // ecx@7
  LONG v11; // edi@8
  LONG v12; // ebx@9
  signed int result; // eax@16
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@2
  LONG v15; // [sp+1Ch] [bp-4h]@6
  int v16; // [sp+28h] [bp+8h]@6

  v3 = *(_DWORD *)(a1 + 120);
  if ( *(_BYTE *)(a1 + 84)
    && ((GetClientRect(*(HWND *)a1, &Rect), !*(_DWORD *)(a1 + 72)) || IsZoomed(*(HWND *)(a1 + 4)) ? (v4 = Rect.right) : (v4 = *(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 72) + Rect.right),
        Rect.top += *(_DWORD *)(a1 + 60),
        v5 = *(_DWORD *)(a1 + 56),
        v6 = *(_DWORD *)(a1 + 64),
        v7 = *(_DWORD *)(a1 + 112),
        v16 = 0,
        v8 = v4 - v5,
        v9 = v5 - v6,
        v15 = v8,
        v7 > 0) )
  {
    v10 = v3 + 8;
    while ( 1 )
    {
      v11 = *(_DWORD *)v10;
      if ( *(_DWORD *)v10 )
      {
        v12 = v6 + v9;
        v9 = *(_DWORD *)v10;
        Rect.left = v12;
        Rect.right = v11;
        if ( v11 < 0 || v11 > v15 )
        {
          v9 = v15;
          Rect.right = v15;
        }
        if ( v9 - v12 < v6 )
          Rect.left = v9;
        if ( v16 == a2 )
          break;
      }
      ++v16;
      v10 += 32;
      if ( v16 >= v7 )
        goto LABEL_16;
    }
    *(_OWORD *)a3 = Rect;
    result = 1;
  }
  else
  {
LABEL_16:
    result = 0;
  }
  return result;
}

//----- (6F79A147) --------------------------------------------------------
HWND __stdcall CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID)
{
  return CreateWindowExW(
           0,
           L"msctls_statusbar32",
           lpszText,
           style & 0xFF7FFFBF,
           -100,
           -100,
           10,
           10,
           hwndParent,
           (HMENU)wID,
           g_hinst,
           0);
}

//----- (6F79A184) --------------------------------------------------------
HWND __stdcall CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID)
{
  return CreateWindowExA(
           0,
           "msctls_statusbar32",
           lpszText,
           style & 0xFF7FFFBF,
           -100,
           -100,
           10,
           10,
           hwndParent,
           (HMENU)wID,
           g_hinst,
           0);
}

//----- (6F79A1D4) --------------------------------------------------------
int __stdcall GetStringInfo(int a1, int a2)
{
  int result; // eax@1

  result = 0;
  if ( a2 == 255 )
  {
    result = a1 + 80;
  }
  else if ( a2 >= 0 && a2 < *(_DWORD *)(a1 + 112) )
  {
    result = *(_DWORD *)(a1 + 120) + 32 * a2;
  }
  return result;
}

//----- (6F79A20B) --------------------------------------------------------
int __stdcall IndexFromPt(int a1, POINT pt)
{
  bool v2; // zf@2
  int result; // eax@4
  int v4; // edi@6
  RECT rc; // [sp+4h] [bp-10h]@7

  if ( *(_DWORD *)(a1 + 28) >= 5 )
    v2 = *(_BYTE *)(a1 + 84) == 0;
  else
    v2 = *(_DWORD *)(a1 + 84) == 0;
  if ( v2 )
  {
    result = 255;
  }
  else
  {
    v4 = 0;
    if ( *(_DWORD *)(a1 + 112) <= 0 )
    {
LABEL_9:
      result = -2;
    }
    else
    {
      while ( 1 )
      {
        Status_GetRect(a1, v4, (int)&rc);
        if ( PtInRect(&rc, pt) )
          break;
        ++v4;
        if ( v4 >= *(_DWORD *)(a1 + 112) )
          goto LABEL_9;
      }
      result = v4;
    }
  }
  return result;
}

//----- (6F79A26F) --------------------------------------------------------
void __stdcall StatusForceCreateTooltips(int a1)
{
  HWND v1; // ST20_4@3
  HWND v2; // eax@3
  int v3; // ecx@3
  LPARAM lParam; // [sp+4h] [bp-2Ch]@3
  char v5; // [sp+8h] [bp-28h]@3
  int v6; // [sp+Ch] [bp-24h]@3
  int v7; // [sp+10h] [bp-20h]@3
  int v8; // [sp+28h] [bp-8h]@3

  if ( *(_DWORD *)(a1 + 8) & 0x800 )
  {
    if ( !*(_DWORD *)(a1 + 36) )
    {
      v1 = *(HWND *)a1;
      lParam = 0;
      memset(&v5, 0, 0x28u);
      v2 = CreateWindowExW(
             0,
             L"tooltips_class32",
             0,
             0x80000001,
             2147483648,
             2147483648,
             2147483648,
             2147483648,
             v1,
             0,
             g_hinst,
             0);
      v3 = *(_DWORD *)a1;
      v8 = -1;
      v6 = v3;
      *(_DWORD *)(a1 + 36) = v2;
      lParam = 44;
      v7 = 255;
      SendMessageW(v2, 0x432u, 0, (LPARAM)&lParam);
      StatusUpdateToolTips(a1);
      RecalcTooltipRects(a1);
    }
  }
}

//----- (6F79A302) --------------------------------------------------------
int __stdcall SBGetText(int a1, int a2, int a3, size_t cchDest, char a5)
{
  int v5; // esi@1
  int v6; // edx@3
  int v7; // eax@4
  int v8; // ebx@4
  int result; // eax@4
  int v10; // esi@12
  const char *v11; // eax@13
  void *v12; // edi@13
  const WCHAR *v13; // [sp-4h] [bp-10h]@9
  const CHAR *v14; // [sp-4h] [bp-10h]@14

  v5 = 0;
  if ( a1 && *(_DWORD *)(a1 + 112) > (unsigned int)a2 )
  {
    v6 = *(_DWORD *)(a1 + 84);
    if ( (_BYTE)v6 )
    {
      v7 = *(_DWORD *)(a1 + 120) + 32 * a2;
      v8 = *(_DWORD *)(v7 + 4);
      result = *(_DWORD *)v7;
    }
    else
    {
      result = *(_DWORD *)(a1 + 80);
      LOWORD(v8) = *(_DWORD *)(a1 + 84);
    }
    if ( cchDest )
      v5 = a3;
    if ( (unsigned __int16)(v8 & 0xF000) == 61440 )
    {
      v13 = (const WCHAR *)result;
      if ( a5 & 1 )
      {
        if ( v5 )
        {
          StringCchCopyW((STRSAFE_LPWSTR)v5, cchDest, (STRSAFE_LPCWSTR)result);
          v13 = (const WCHAR *)v5;
        }
        v10 = lstrlenW(v13);
      }
      else
      {
        v11 = (const char *)ProduceAFromW(*(_DWORD *)(a1 + 20), (LPCWSTR)result);
        v12 = (void *)v11;
        if ( v11 )
        {
          v14 = v11;
          if ( v5 )
          {
            StringCchCopyA((STRSAFE_LPSTR)v5, cchDest, v11);
            v14 = (const CHAR *)v5;
          }
          v10 = lstrlenA(v14);
          FreeProducedString(v12);
        }
        else
        {
          if ( v5 )
            *(_BYTE *)v5 = 0;
          v10 = 0;
        }
      }
      LOWORD(v8) = v8 & 0xFFF;
      if ( (unsigned int)v10 >= 0xFFFE )
        LOWORD(v10) = -2;
      return (unsigned __int16)v10 | ((unsigned __int16)v8 << 16);
    }
    if ( v5 )
    {
      if ( a5 & 1 )
        *(_WORD *)v5 = 0;
      else
        *(_BYTE *)v5 = 0;
    }
    LOWORD(v10) = 0;
    if ( (unsigned __int16)(v8 & 0xF000) != 4096 || !(a5 & 2) )
      return (unsigned __int16)v10 | ((unsigned __int16)v8 << 16);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F79A3FA) --------------------------------------------------------
void __stdcall DrawStatusTextW(HDC hDC, LPCRECT lprc, LPCWSTR pszText, UINT uFlags)
{
  DrawStatusTextEx(0, hDC, (int)lprc, (int)pszText, 0, uFlags);
}

//----- (6F79A41D) --------------------------------------------------------
void __stdcall DrawStatusTextA(HDC hDC, LPCRECT lprc, LPCSTR pszText, UINT uFlags)
{
  int v4; // eax@1
  int v5; // esi@1
  WCHAR *v6; // eax@1
  const WCHAR *v7; // edi@1

  v4 = lstrlenA(pszText);
  v5 = v4;
  v6 = (WCHAR *)LocalAlloc(0x40u, 2 * v4 + 2);
  v7 = v6;
  if ( v6 )
  {
    MultiByteToWideChar(0, 1u, pszText, v5, v6, v5);
    DrawStatusTextW(hDC, lprc, v7, uFlags);
    LocalFree((HLOCAL)v7);
  }
}

//----- (6F79A473) --------------------------------------------------------
int __stdcall TBMixedButtonHeight(int a1, int a2)
{
  int result; // eax@2

  if ( *(_BYTE *)(*(_DWORD *)(a1 + 48) + 28 * a2 + 9) & 0x40 )
  {
    result = *(_DWORD *)(a1 + 136);
    if ( *(_DWORD *)(a1 + 108) > result )
      result = *(_DWORD *)(a1 + 108);
  }
  else
  {
    result = *(_DWORD *)(a1 + 108);
  }
  return result;
}

//----- (6F79A4A8) --------------------------------------------------------
int __stdcall TBMixedButtonsHeight(int a1)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // eax@2
  int i; // [sp+Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 132);
  v2 = 0;
  for ( i = 0; v2 < v1; ++v2 )
  {
    v3 = TBMixedButtonHeight(a1, v2);
    if ( i <= v3 )
      i = v3;
  }
  return i;
}

//----- (6F79A4E6) --------------------------------------------------------
int __stdcall TBGetSepHeight(int a1, int *a2)
{
  int result; // eax@1

  result = *a2;
  if ( !(*(_DWORD *)(a1 + 8) & 0x880) )
    result = 2 * result / 3;
  return result;
}

//----- (6F79A50D) --------------------------------------------------------
HWND __stdcall CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons, int dxButton, int dyButton, int dxBitmap, int dyBitmap, UINT uStructSize)
{
  HWND v13; // eax@1
  LPARAM lParam; // [sp+4h] [bp-8h]@9
  UINT_PTR v16; // [sp+8h] [bp-4h]@9
  HWND wIDa; // [sp+1Ch] [bp+10h]@1

  v13 = CreateWindowExW(0, L"ToolbarWindow32", 0, ws | 0x40000000, 0, 0, 100, 30, hwnd, (HMENU)wID, g_hinst, 0);
  wIDa = v13;
  if ( v13 )
  {
    SendMessageW(v13, 0x41Eu, uStructSize, 0);
    if ( dxBitmap
      && dyBitmap
      && !SendMessageW(wIDa, 0x420u, 0, (unsigned __int16)dxBitmap | ((unsigned __int16)dyBitmap << 16))
      || dxButton
      && dyButton
      && !SendMessageW(wIDa, 0x420u, 0, (unsigned __int16)dxButton | ((unsigned __int16)dyButton << 16)) )
    {
      DestroyWindow(wIDa);
      wIDa = 0;
    }
    else
    {
      lParam = (LPARAM)hBMInst;
      v16 = wBMID;
      SendMessageW(wIDa, 0x413u, nBitmaps, (LPARAM)&lParam);
      SendMessageW(wIDa, 0x444u, iNumButtons, (LPARAM)lpButtons);
    }
  }
  return wIDa;
}

//----- (6F79A5F4) --------------------------------------------------------
HWND __stdcall CreateToolbar(HWND hwnd, int a2, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons)
{
  return CreateToolbarEx(hwnd, a2 | 0x40, wID, nBitmaps, hBMInst, wBMID, lpButtons, iNumButtons, 0, 0, 0, 0, 0x10u);
}

//----- (6F79A62B) --------------------------------------------------------
COLORREF __stdcall TB_OnSysColorChange(int a1)
{
  COLORREF result; // eax@1
  int i; // edi@1
  int v3; // eax@2
  COLORREF v4; // ecx@4
  COLORREF v5; // ecx@9

  result = (COLORREF)InitGlobalColors();
  for ( i = 0; i < *(_DWORD *)(a1 + 200); ++i )
  {
    v3 = TBGetImageList(a1, 0, i);
    if ( v3 )
    {
      if ( *(_DWORD *)(a1 + 8) & 0x8000 )
        v4 = -1;
      else
        v4 = g_clrBtnFace;
      ImageList_SetBkColor((HIMAGELIST)v3, v4);
    }
    result = TBGetImageList(a1, 1, i);
    if ( result )
    {
      if ( *(_DWORD *)(a1 + 8) & 0x8000 )
        v5 = -1;
      else
        v5 = g_clrBtnFace;
      result = ImageList_SetBkColor((HIMAGELIST)result, v5);
    }
  }
  return result;
}

//----- (6F79A6A7) --------------------------------------------------------
BOOL __stdcall DrawInsertMark(HDC hdc, int a2, int a3, COLORREF color)
{
  __int64 v4; // rax@4
  int v5; // esi@4
  int v6; // ecx@4
  int v7; // edi@4
  int v8; // ecx@4
  __int64 v9; // rax@5
  int v10; // esi@5
  LONG v11; // ecx@5
  int v12; // ecx@5
  int v13; // edi@5
  POINT apt; // [sp+0h] [bp-24h]@4
  int v16; // [sp+8h] [bp-1Ch]@4
  int v17; // [sp+Ch] [bp-18h]@4
  int v18; // [sp+10h] [bp-14h]@4
  int v19; // [sp+14h] [bp-10h]@4
  int v20; // [sp+18h] [bp-Ch]@4
  LONG v21; // [sp+1Ch] [bp-8h]@4
  HGDIOBJ h; // [sp+20h] [bp-4h]@3
  void *colora; // [sp+38h] [bp+14h]@1

  colora = CreatePen(0, 1, color);
  if ( !colora )
    colora = GetStockObject(7);
  h = SelectObject(hdc, colora);
  if ( a3 )
  {
    v4 = *(_DWORD *)a2 + *(_DWORD *)(a2 + 8);
    v5 = ((signed int)v4 - HIDWORD(v4)) >> 1;
    v17 = *(_DWORD *)(a2 + 4);
    v19 = v17;
    v16 = v5 + 3;
    apt.x = v5 + 1;
    apt.y = v17 + 2;
    v18 = v5 - 2;
    v20 = ((signed int)v4 - HIDWORD(v4)) >> 1;
    v21 = v17 + 2;
    Polyline(hdc, &apt, 4);
    v6 = *(_DWORD *)(a2 + 12);
    apt.y = *(_DWORD *)(a2 + 4);
    v21 = apt.y;
    apt.x = v5;
    v16 = v5;
    v17 = v6 - 1;
    v18 = v5 + 1;
    v19 = v6 - 1;
    v20 = v5 + 1;
    Polyline(hdc, &apt, 4);
    v7 = *(_DWORD *)(a2 + 12);
    v16 = v5 + 3;
    v8 = v7 - 1;
    apt.x = v5 + 1;
    apt.y = v7 - 3;
    v17 = v7 - 1;
    v18 = v5 - 2;
    v20 = v5;
    v21 = v7 - 3;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a2 + 12);
    v10 = ((signed int)v9 - HIDWORD(v9)) >> 1;
    v11 = *(_DWORD *)a2 + 2;
    v16 = *(_DWORD *)a2;
    v18 = v16;
    v19 = v10 + 3;
    apt.x = v11;
    apt.y = ((signed int)v9 - HIDWORD(v9)) >> 1;
    v17 = v10 - 2;
    v20 = v11;
    v21 = v10 + 1;
    Polyline(hdc, &apt, 4);
    v12 = *(_DWORD *)(a2 + 8);
    apt.x = *(_DWORD *)a2;
    v20 = apt.x;
    apt.y = v10;
    v16 = v12 - 1;
    v17 = v10;
    v18 = v12 - 1;
    v19 = v10 + 1;
    v21 = v10 + 1;
    Polyline(hdc, &apt, 4);
    v13 = *(_DWORD *)(a2 + 8);
    v16 = v13 - 1;
    v18 = v13 - 1;
    v8 = v10 + 3;
    apt.x = v13 - 3;
    apt.y = v10;
    v17 = v10 - 2;
    v20 = v13 - 3;
    v21 = v10 + 1;
  }
  v19 = v8;
  Polyline(hdc, &apt, 4);
  SelectObject(hdc, h);
  return DeleteObject(colora);
}

//----- (6F79A856) --------------------------------------------------------
BOOL __stdcall TBIsRectClipped(int a1, RECT *lprcSrc2)
{
  RECT rc2; // [sp+0h] [bp-20h]@4
  struct tagRECT rcDst; // [sp+10h] [bp-10h]@2

  if ( *(_BYTE *)(a1 + 36) & 2 )
    CopyRect(&rcDst, (const RECT *)(a1 + 240));
  else
    GetClientRect(*(HWND *)a1, &rcDst);
  return !IntersectRect(&rc2, &rcDst, lprcSrc2) || !EqualRect(lprcSrc2, &rc2);
}

//----- (6F79A8BB) --------------------------------------------------------
COLORREF __stdcall TB_GetInsertMarkColor(int a1)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a1 + 216);
  if ( result == -16777216 )
    result = g_clrBtnText;
  return result;
}

//----- (6F79A8DE) --------------------------------------------------------
BOOL __stdcall WrapToolbarCol(int a1, int a2, LPRECT lprcDst, int a4)
{
  int v4; // esi@1
  int v5; // edx@1
  int v6; // ecx@3
  int v7; // ebx@3
  int v8; // edi@3
  int v9; // ecx@3
  int *v10; // eax@5
  int v11; // ebx@13
  int v12; // ecx@27
  int *v14; // [sp+4h] [bp-18h]@5
  int v15; // [sp+8h] [bp-14h]@3
  signed int v16; // [sp+Ch] [bp-10h]@1
  int v17; // [sp+10h] [bp-Ch]@1
  int *v18; // [sp+14h] [bp-8h]@5
  int v19; // [sp+18h] [bp-4h]@1
  char v20; // [sp+27h] [bp+Bh]@7

  v19 = 0;
  v4 = a1;
  v5 = *(_DWORD *)(a1 + 116);
  v16 = 1;
  v17 = *(_DWORD *)(a1 + 116);
  if ( a2 < v5 )
    a2 = *(_DWORD *)(a1 + 116);
  v6 = *(_DWORD *)(a1 + 144);
  *(_DWORD *)(a1 + 164) = -1;
  *(_DWORD *)(a1 + 168) = -1;
  v7 = *(_DWORD *)(a1 + 128);
  v8 = *(_DWORD *)(a1 + 48) + 28 * *(_DWORD *)(a1 + 132);
  v15 = v6;
  v9 = a4;
  if ( a4 )
    *(_DWORD *)a4 = 1;
  v10 = *(int **)(a1 + 48);
  v14 = v10;
  v18 = *(int **)(a1 + 48);
  if ( (unsigned int)v10 < v8 )
  {
    while ( 1 )
    {
      *((_BYTE *)v10 + 8) &= 0xDFu;
      if ( !(*((_BYTE *)v10 + 8) & 8) )
        break;
LABEL_22:
      v10 += 7;
      v18 = v10;
      if ( (unsigned int)v10 >= v8 )
      {
        if ( v19 )
          v7 = v19;
        goto LABEL_25;
      }
    }
    v20 = *((_BYTE *)v10 + 9) & 1;
    if ( v20 )
    {
      v7 += TBGetSepHeight(v4, v10);
      v10 = v18;
    }
    else
    {
      v7 += v5;
    }
    if ( v7 <= a2 )
    {
      v5 = v17;
LABEL_21:
      v9 = a4;
      v14 = v10;
      goto LABEL_22;
    }
    if ( v20 )
    {
      if ( v7 - TBGetSepHeight(v4, v10) > v19 )
      {
        v11 = v7 - TBGetSepHeight(v4, v18);
        v10 = v18;
        goto LABEL_16;
      }
      v10 = v18;
    }
    v11 = v7 - v17;
    if ( v11 <= v19 )
    {
LABEL_17:
      if ( v15 + *(_DWORD *)(v4 + 112) <= *(_DWORD *)(v4 + 256) )
        v15 += *(_DWORD *)(v4 + 112);
      v5 = v17;
      ++v16;
      *((_BYTE *)v14 + 8) |= 0x20u;
      v7 = v17;
      goto LABEL_21;
    }
LABEL_16:
    v19 = v11;
    goto LABEL_17;
  }
LABEL_25:
  if ( v9 )
    *(_DWORD *)v9 = v16;
  v12 = v15 + *(_DWORD *)(v4 + 112);
  *(_DWORD *)(v4 + 252) = v7;
  *(_DWORD *)(v4 + 240) = 0;
  *(_DWORD *)(v4 + 248) = v12;
  *(_DWORD *)(v4 + 244) = 0;
  if ( lprcDst )
    CopyRect(lprcDst, (const RECT *)(v4 + 240));
  return InvalidateRect(*(HWND *)v4, 0, 1);
}

//----- (6F79AA3F) --------------------------------------------------------
int __stdcall TBGetStringA(int a1, int a2, int cbMultiByte, LPSTR lpMultiByteStr)
{
  int v5; // [sp+8h] [bp-4h]@1

  v5 = -1;
  if ( lpMultiByteStr )
    *lpMultiByteStr = 0;
  if ( a2 < *(_DWORD *)(a1 + 92) && a2 >= 0 )
  {
    v5 = lstrlenW(*(LPCWSTR *)(*(_DWORD *)(a1 + 88) + 4 * a2));
    if ( lpMultiByteStr )
      WideCharToMultiByte(0, 0, *(LPCWSTR *)(*(_DWORD *)(a1 + 88) + 4 * a2), -1, lpMultiByteStr, cbMultiByte, 0, 0);
  }
  return v5;
}

//----- (6F79AAA6) --------------------------------------------------------
int __stdcall TBLoadImages(HANDLE h, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@1
  int result; // eax@4
  int v6; // [sp+8h] [bp-10h]@1
  int v7; // [sp+Ch] [bp-Ch]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v3 = 0;
  v9 = 0;
  MapToStandardBitmaps((unsigned int)&a3, (unsigned int *)&a2, (unsigned int)&v9);
  v7 = a3;
  v8 = a2;
  v6 = v9;
  v4 = TBGetImageList((int)h, 0, 0);
  if ( v4 )
    v3 = ImageList_GetImageCount((HIMAGELIST)v4);
  if ( TBAddBitmapToImageList(h, (int)&v6) )
  {
    *((_DWORD *)h + 59) |= 2u;
    result = v3;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F79AB16) --------------------------------------------------------
signed int __stdcall ReplaceBitmap(int a1, unsigned int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  int v4; // edi@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // eax@1
  signed int result; // eax@6
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+1Ch] [bp+8h]@2

  v10 = a2 + 4;
  MapToStandardBitmaps(a2, (unsigned int *)(a2 + 4), (unsigned int)&a2);
  v3 = v2 + 16;
  v4 = v2 + 12;
  v9 = v2 + 8;
  MapToStandardBitmaps(v2 + 8, (unsigned int *)(v2 + 12), v2 + 16);
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 84);
  a2 = *(_DWORD *)(a1 + 80);
  if ( (signed int)a2 <= 0 )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    v11 = *(_DWORD *)v5;
    while ( *(_DWORD *)(v7 + 4) != v11 || *(_DWORD *)(v7 + 8) != *(_DWORD *)v10 )
    {
      --a2;
      v7 += 12;
      if ( (signed int)a2 <= 0 )
        goto LABEL_6;
    }
    *(_DWORD *)(v7 + 4) = *(_DWORD *)v9;
    *(_DWORD *)(v7 + 8) = *(_DWORD *)v4;
    *(_DWORD *)v7 = *(_DWORD *)v3;
    *(_DWORD *)(v6 + 236) &= 0xFFFFFFFE;
    result = 1;
  }
  return result;
}

//----- (6F79ABA6) --------------------------------------------------------
LRESULT __stdcall TB_OnSetCmdID(int a1, int a2, int a3)
{
  int v3; // ecx@1
  LRESULT result; // eax@1
  int v5; // edx@2
  HWND v6; // ST00_4@2
  LPARAM lParam; // [sp+8h] [bp-2Ch]@2
  int v8; // [sp+10h] [bp-24h]@2
  int v9; // [sp+14h] [bp-20h]@2

  v3 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = a3;
  result = *(_DWORD *)(a1 + 64);
  if ( result )
  {
    v5 = *(_DWORD *)a1;
    v9 = v3;
    lParam = 44;
    v8 = v5;
    SendMessageW((HWND)result, 0x435u, 0, (LPARAM)&lParam);
    SendMessageW(*(HWND *)(a1 + 64), 0x433u, 0, (LPARAM)&lParam);
    v6 = *(HWND *)(a1 + 64);
    v9 = a3;
    result = SendMessageW(v6, 0x432u, 0, (LPARAM)&lParam);
  }
  return result;
}

//----- (6F79AC19) --------------------------------------------------------
int __stdcall GetAccelerator(LPCWSTR lpStart)
{
  const WCHAR *v1; // eax@1
  signed int v2; // esi@1
  LPWSTR v3; // eax@2

  v1 = lpStart;
  v2 = -1;
  do
  {
    v3 = StrChrW(v1, 0x26u);
    if ( !v3 )
      break;
    v1 = v3 + 1;
    if ( *v1 == 38 )
      ++v1;
    else
      v2 = *v1;
  }
  while ( v1 && v2 == -1 );
  return v2;
}

//----- (6F79AC58) --------------------------------------------------------
int __stdcall TBButtonAccelerator(int a1, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // esi@1

  v2 = TB_StrForButton(a1, a2);
  v4 = v2;
  if ( v2 )
  {
    if ( *(_WORD *)v2 )
    {
      if ( *(_DWORD *)(a1 + 176) & *(_DWORD *)(a1 + 180) & 0x800 || (v3 = GetAccelerator((LPCWSTR)v2), v3 == -1) )
        v3 = *(_WORD *)v4;
    }
  }
  return v3;
}

//----- (6F79ACAA) --------------------------------------------------------
int __stdcall TBHasAccelerator(int a1, int w2)
{
  int v2; // ebx@1
  int v3; // edi@1
  bool v4; // zf@1
  bool v5; // sf@1
  WORD v6; // ax@2
  LPARAM lParam; // [sp+Ch] [bp-1Ch]@6
  int v9; // [sp+10h] [bp-18h]@6
  int v10; // [sp+14h] [bp-14h]@6
  int v11; // [sp+18h] [bp-10h]@6
  int v12; // [sp+1Ch] [bp-Ch]@6
  int v13; // [sp+20h] [bp-8h]@6
  int v14; // [sp+24h] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 132) == 0;
  v5 = *(_DWORD *)(a1 + 132) < 0;
  v14 = 0;
  if ( v5 || v4 )
    goto LABEL_12;
  do
  {
    v6 = TBButtonAccelerator(a1, v2 + *(_DWORD *)(a1 + 48));
    if ( !ChrCmpIW(v6, w2) )
      ++v14;
    ++v3;
    v2 += 28;
  }
  while ( v3 < *(_DWORD *)(a1 + 132) );
  if ( !v14 )
  {
LABEL_12:
    lParam = 0;
    v9 = 0;
    v10 = 0;
    v12 = 0;
    v13 = -1;
    v11 = w2;
    if ( CCSendNotify(a1, -728, (LPARAM)&lParam) && v13 != -1 )
      v14 = 1;
  }
  return v14;
}

//----- (6F79AD40) --------------------------------------------------------
int __stdcall TBHasDupChar(int a1, int w2)
{
  signed int v2; // edi@1
  LPARAM lParam; // [sp+8h] [bp-14h]@1
  int v5; // [sp+14h] [bp-8h]@1
  int v6; // [sp+18h] [bp-4h]@2

  v2 = 0;
  v5 = w2;
  if ( CCSendNotify(a1, -725, (LPARAM)&lParam) )
  {
    v2 = v6;
  }
  else if ( TBHasAccelerator(a1, w2) > 1 )
  {
    v2 = 1;
  }
  return v2;
}

//----- (6F79AD8A) --------------------------------------------------------
int __stdcall TBItemFromAccelerator(int pulResult, WORD w2, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // ST18_4@1
  signed int v8; // eax@7
  signed int v9; // ebx@11
  int v10; // ecx@14
  bool v11; // zf@14
  WORD v12; // ax@15
  LPARAM lParam; // [sp+Ch] [bp-30h]@1
  int v14; // [sp+10h] [bp-2Ch]@1
  int v15; // [sp+14h] [bp-28h]@1
  int v16; // [sp+18h] [bp-24h]@1
  int v17; // [sp+1Ch] [bp-20h]@1
  int v18; // [sp+20h] [bp-1Ch]@1
  LPARAM v19; // [sp+24h] [bp-18h]@9
  int v20; // [sp+30h] [bp-Ch]@9
  int v21; // [sp+34h] [bp-8h]@18
  int v22; // [sp+38h] [bp-4h]@1

  lParam = 0;
  v3 = pulResult;
  v4 = *(_DWORD *)(pulResult + 204);
  v22 = -1;
  v14 = 0;
  v15 = 0;
  v5 = w2;
  v18 = -1;
  v6 = pulResult;
  pulResult = v4;
  v16 = w2;
  v17 = v4;
  if ( CCSendNotify(v6, -728, (LPARAM)&lParam) && v18 > v4 && v18 < *(_DWORD *)(v3 + 132) )
  {
    v22 = v18;
LABEL_5:
    *(_DWORD *)a3 = TBHasDupChar(v3, v5);
    return v22;
  }
  v8 = *(_DWORD *)(v3 + 132);
  *(_DWORD *)&w2 = 0;
  if ( v8 <= 0 )
    goto LABEL_5;
  while ( 1 )
  {
    if ( v4 >= v8 - 1 )
    {
      v20 = v5;
      if ( CCSendNotify(v3, -726, (LPARAM)&v19) )
        return v21;
    }
    if ( v4 == -1 )
    {
      v9 = *(_DWORD *)(v3 + 132);
      pulResult = *(_DWORD *)(v3 + 132);
      goto LABEL_14;
    }
    if ( ULongAdd(v4, 1u, (ULONG *)&pulResult) < 0 )
      return -1;
    v9 = *(_DWORD *)(v3 + 132);
    if ( ULongAdd(pulResult, *(_DWORD *)(v3 + 132), (ULONG *)&pulResult) < 0 )
      return -1;
LABEL_14:
    v10 = *(_DWORD *)(v3 + 48);
    v4 = pulResult % v9;
    v11 = (*(_BYTE *)(v10 + 28 * v4 + 8) & 4) == 0;
    pulResult = v4;
    if ( !v11 )
    {
      v12 = TBButtonAccelerator(v3, v10 + 28 * v4);
      if ( !ChrCmpIW(v12, v5) )
      {
        v22 = v4;
        goto LABEL_5;
      }
    }
    *(_DWORD *)&w2 = w2 + 1;
    v8 = *(_DWORD *)(v3 + 132);
    if ( w2 >= v8 )
      goto LABEL_5;
  }
}

//----- (6F79AEBC) --------------------------------------------------------
int __stdcall TBOnMapAccelerator(int a1, WORD w2, int a3)
{
  int v3; // eax@1
  int result; // eax@2

  v3 = TBItemFromAccelerator(a1, w2, (int)&w2);
  if ( v3 == -1 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a3 = *(_DWORD *)(*(_DWORD *)(a1 + 48) + 28 * v3 + 4);
    result = 1;
  }
  return result;
}

//----- (6F79AEF7) --------------------------------------------------------
BOOL __stdcall GetUpdateRectEnumProc(HWND hWnd, LPARAM a2)
{
  LPARAM v2; // edi@3
  struct tagRECT rcDst; // [sp+0h] [bp-20h]@3
  struct tagRECT Rect; // [sp+10h] [bp-10h]@2

  if ( IsWindowVisible(hWnd) && GetUpdateRect(hWnd, &Rect, 0) )
  {
    MapWindowPoints(hWnd, *(HWND *)a2, (LPPOINT)&Rect, 2u);
    UnionRect(&rcDst, &Rect, (const RECT *)(a2 + 220));
    *(_DWORD *)(a2 + 220) = rcDst.left;
    *(_DWORD *)(a2 + 224) = rcDst.top;
    v2 = a2 + 228;
    *(_DWORD *)v2 = rcDst.right;
    *(_DWORD *)(v2 + 4) = rcDst.bottom;
  }
  return 1;
}

//----- (6F79AF5F) --------------------------------------------------------
int __stdcall TB_TranslateAccelerator(int a1, MSG *lpMsg)
{
  UINT v2; // eax@3
  WPARAM v3; // eax@6
  WPARAM v5; // eax@11

  if ( !lpMsg )
    return 0;
  if ( GetFocus() != (HWND)a1 )
    return 0;
  v2 = lpMsg->message;
  if ( v2 < 0x100 )
    return 0;
  if ( v2 <= 0x101 )
  {
    v5 = lpMsg->wParam;
    if ( v5 != 13 && v5 != 27 && v5 != 32 && (v5 <= 0x24 || v5 > 0x28) )
      return 0;
  }
  else
  {
    if ( v2 != 258 )
      return 0;
    v3 = lpMsg->wParam;
    if ( v3 != 13 && v3 != 27 && v3 != 32 )
      return 0;
  }
  TranslateMessage(lpMsg);
  DispatchMessageW(lpMsg);
  return 1;
}

//----- (6F79AFDC) --------------------------------------------------------
int __stdcall TB_CalcHeight(int a1)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // edi@2
  int v5; // [sp+10h] [bp+8h]@2

  v1 = a1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 132) > 0 )
  {
    v3 = *(_DWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 132);
    do
    {
      if ( !(*(_BYTE *)(v3 + 8) & 8) )
      {
        if ( *(_BYTE *)(v3 + 9) & 1 )
          v2 += TBGetSepHeight(v1, (int *)v3);
        else
          v2 += *(_DWORD *)(v1 + 116);
      }
      v3 += 28;
      --v5;
    }
    while ( v5 );
  }
  return v2;
}

//----- (6F79B029) --------------------------------------------------------
int __stdcall TBGetItem(int a1, int a2, LPARAM lParam)
{
  int v3; // eax@1
  int result; // eax@1

  v3 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(lParam + 24) = -1;
  *(_DWORD *)(lParam + 16) = v3;
  *(_DWORD *)(lParam + 20) = *(_DWORD *)(a2 + 12);
  CCSendNotify(a1, -717, lParam);
  result = *(_DWORD *)(lParam + 12);
  if ( result & 0x10000000 )
  {
    if ( result & 1 )
    {
      result = *(_DWORD *)(lParam + 24);
      *(_DWORD *)a2 = result;
    }
  }
  return result;
}

//----- (6F79B072) --------------------------------------------------------
int __stdcall TBGetInfoTip(int a1, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // eax@3
  int result; // eax@5
  LPARAM lParam; // [sp+8h] [bp-820h]@1
  LPCWSTR lpString; // [sp+14h] [bp-814h]@1
  int v8; // [sp+18h] [bp-810h]@1
  int v9; // [sp+1Ch] [bp-80Ch]@1
  int v10; // [sp+20h] [bp-808h]@1
  __int16 v11; // [sp+24h] [bp-804h]@1

  v11 = 0;
  lpString = (LPCWSTR)&v11;
  v3 = *(_DWORD *)(a3 + 4);
  v10 = *(_DWORD *)(a3 + 12);
  v8 = 1024;
  v9 = v3;
  CCSendNotify(a1, -719, (LPARAM)&lParam);
  result = 0;
  if ( lpString )
  {
    if ( *lpString )
    {
      Str_Set(a1 + 68, lpString);
      v4 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 68);
      if ( v4 )
      {
        if ( *(_WORD *)v4 )
          result = 1;
      }
    }
  }
  return result;
}

//----- (6F79B11A) --------------------------------------------------------
LONG __stdcall TBWidthOfString(HDC hDC, int a2, HDC hdc)
{
  int v3; // edi@1
  LONG v4; // edx@1
  HDC v5; // ebx@2
  int v6; // eax@4
  struct tagRECT rc; // [sp+4h] [bp-18h]@2
  LPCWSTR lpchText; // [sp+14h] [bp-8h]@1
  LONG v10; // [sp+18h] [bp-4h]@1
  HDC hDCa; // [sp+24h] [bp+8h]@2
  HDC hdca; // [sp+2Ch] [bp+10h]@4

  v3 = (int)hDC;
  v10 = 0;
  lpchText = (LPCWSTR)TB_StrForButton((int)hDC, a2);
  if ( lpchText != (LPCWSTR)v4 )
  {
    v5 = hdc;
    hDCa = (HDC)v4;
    rc.left = v4;
    rc.top = v4;
    rc.right = 1000;
    rc.bottom = 10;
    if ( hdc == (HDC)v4 )
    {
      v5 = GetDC(*(HWND *)v3);
      hDCa = v5;
    }
    hdca = (HDC)SelectObject(v5, *(HGDIOBJ *)(v3 + 76));
    v6 = TBGetDrawTextFlags(v3, 0, a2);
    DrawTextW(v5, lpchText, -1, &rc, v6 | 0x400);
    v10 = rc.right;
    SelectObject(v5, hdca);
    if ( hDCa )
      ReleaseDC(*(HWND *)v3, hDCa);
  }
  return v10;
}

//----- (6F79B1C4) --------------------------------------------------------
int __stdcall TBToggleDropDown(HDC hDC, int a2, int a3)
{
  HDC v3; // esi@1
  int v4; // edi@1
  int result; // eax@1
  HWND v6; // eax@4
  struct tagMSG Msg; // [sp+8h] [bp-1Ch]@7
  HDC hDCa; // [sp+2Ch] [bp+8h]@4
  int v9; // [sp+30h] [bp+Ch]@4

  v3 = hDC;
  v4 = *((_DWORD *)hDC + 12) + 28 * a2;
  result = 0;
  if ( *(_BYTE *)(v4 + 8) & 4 )
  {
    *((_DWORD *)hDC + 52) = a2;
    if ( *(_BYTE *)(v4 + 9) & 0x80 )
      *(_BYTE *)(v4 + 8) |= 2u;
    InvalidateButton(hDC, v4, 1);
    UpdateWindow(*(HWND *)hDC);
    v9 = a2 + 1;
    MyNotifyWinEvent(32778, *(_DWORD *)hDC, -4, v9);
    v6 = SendItemNotify(hDC, *(_DWORD *)(v4 + 4), -710);
    hDCa = (HDC)v6;
    if ( !v6 || v6 == (HWND)2 )
    {
      if ( a3 )
        PeekMessageW(&Msg, *(HWND *)v3, 0x201u, 0x201u, 1u);
      *((_DWORD *)v3 + 52) = -1;
      if ( *(_BYTE *)(v4 + 9) & 0x80 )
        *(_BYTE *)(v4 + 8) &= 0xFDu;
      InvalidateButton(v3, v4, 1);
      UpdateWindow(*(HWND *)v3);
      MyNotifyWinEvent(32778, *(_DWORD *)v3, -4, v9);
    }
    result = hDCa == 0;
  }
  return result;
}

//----- (6F79B29A) --------------------------------------------------------
int __stdcall TBInvalidateButton(HDC hDC, int a2, BOOL bErase)
{
  int result; // eax@1

  result = a2;
  if ( a2 != -1 )
    result = InvalidateButton(hDC, *((_DWORD *)hDC + 12) + 28 * a2, bErase);
  return result;
}

//----- (6F79B2C3) --------------------------------------------------------
void __stdcall TBSetHotItem(HDC hDC, int a2, int a3)
{
  int v3; // ecx@2
  signed int v4; // ebx@2
  int v5; // edx@6
  HWND v6; // edi@22
  int v7; // edi@27
  LPARAM lParam; // [sp+4h] [bp-18h]@7
  int v9; // [sp+8h] [bp-14h]@7
  int v10; // [sp+Ch] [bp-10h]@7
  int v11; // [sp+10h] [bp-Ch]@7
  int v12; // [sp+14h] [bp-8h]@7
  int v13; // [sp+18h] [bp-4h]@7

  if ( *((_DWORD *)hDC + 2) & 0x800 )
  {
    v3 = *((_DWORD *)hDC + 51);
    v4 = a2;
    if ( (v3 != a2 || a3 & 0x40) && (v3 >= 0 || a2 >= 0) )
    {
      v5 = *((_DWORD *)hDC + 33);
      if ( a2 < v5 )
      {
        lParam = 0;
        v9 = 0;
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v13 = 0;
        if ( a2 >= 0 || !(*((_BYTE *)hDC + 236) & 0x80) || !(a3 & 1) )
        {
          if ( v3 >= 0 )
          {
            if ( a2 >= 0 )
            {
              if ( v3 < v5 )
                v11 = *(_DWORD *)(28 * v3 + *((_DWORD *)hDC + 12) + 4);
              v12 = *(_DWORD *)(*((_DWORD *)hDC + 12) + 28 * a2 + 4);
            }
            else
            {
              if ( v3 >= 0 && v3 < v5 )
                v11 = *(_DWORD *)(28 * v3 + *((_DWORD *)hDC + 12) + 4);
              v13 = 32;
            }
          }
          else
          {
            if ( a2 >= 0 )
              v12 = *(_DWORD *)(*((_DWORD *)hDC + 12) + 28 * a2 + 4);
            v13 = 16;
          }
          v13 |= a3;
          v6 = *(HWND *)hDC;
          if ( !CCSendNotify((int)hDC, -713, (LPARAM)&lParam) && IsWindow(v6) )
          {
            TBInvalidateButton(hDC, *((_DWORD *)hDC + 51), 1);
            if ( a2 < 0 || !(*(_BYTE *)(*((_DWORD *)hDC + 12) + 28 * a2 + 8) & 4) )
              v4 = -1;
            v7 = *(_DWORD *)hDC;
            *((_DWORD *)hDC + 51) = v4;
            if ( GetFocus() == (HWND)v7 )
              MyNotifyWinEvent(32773, v7, -4, v4 + 1);
            TBInvalidateButton(hDC, *((_DWORD *)hDC + 51), 1);
            if ( v4 >= 0 && v4 < *((_DWORD *)hDC + 33) && *(_BYTE *)(*((_DWORD *)hDC + 12) + 28 * v4 + 9) & 0x88 )
            {
              if ( a3 & 0x100 )
                TBToggleDropDown(hDC, v4, 0);
            }
          }
        }
      }
    }
  }
}

//----- (6F79B452) --------------------------------------------------------
int __stdcall GetInsertMarkRect(HDC hDC, int a2, int a3)
{
  int result; // eax@1

  result = TB_GetItemRect(hDC, *((_DWORD *)hDC + 53), a2);
  if ( result )
  {
    if ( a3 )
    {
      if ( *((_DWORD *)hDC + 59) & 0x400 )
        *(_DWORD *)a2 = *(_DWORD *)(a2 + 8);
      else
        *(_DWORD *)(a2 + 8) = *(_DWORD *)a2;
      *(_DWORD *)a2 -= 3;
      *(_DWORD *)(a2 + 8) += 4;
    }
    else
    {
      if ( *((_DWORD *)hDC + 59) & 0x400 )
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a2 + 12);
      else
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) -= 3;
      *(_DWORD *)(a2 + 12) += 4;
    }
  }
  return result;
}

//----- (6F79B4C4) --------------------------------------------------------
int __stdcall TBInvalidateMark(HDC hDC)
{
  int result; // eax@1
  RECT Rect; // [sp+4h] [bp-10h]@1

  result = GetInsertMarkRect(hDC, (int)&Rect, ~(unsigned __int8)(*((_DWORD *)hDC + 2) >> 7) & 1);
  if ( result )
    result = InvalidateRect(*(HWND *)hDC, &Rect, 1);
  return result;
}

//----- (6F79B502) --------------------------------------------------------
int __stdcall TBSetInsertMark(HDC hDC, int a2)
{
  int result; // eax@1

  result = *((_DWORD *)hDC + 53);
  if ( *(_DWORD *)a2 != result || (*(_BYTE *)(a2 + 4) ^ (unsigned __int8)(*((_DWORD *)hDC + 59) >> 10)) & 1 )
  {
    if ( result != -1 )
      TBInvalidateMark(hDC);
    *((_DWORD *)hDC + 53) = *(_DWORD *)a2;
    result = (int)(hDC + 59);
    *(_DWORD *)result ^= (*((_DWORD *)hDC + 59) ^ (*(_DWORD *)(a2 + 4) << 10)) & 0x400;
    if ( *((_DWORD *)hDC + 53) != -1 )
      result = TBInvalidateMark(hDC);
  }
  return result;
}

//----- (6F79B56D) --------------------------------------------------------
void __stdcall TBCycleHotItem(HDC hDC, int a2, int a3, int a4)
{
  int v4; // edi@1
  signed int v5; // ecx@5
  int v6; // eax@5
  bool v7; // sf@5
  unsigned __int8 v8; // of@5
  int v9; // eax@8
  char v10; // cl@8
  int v11; // eax@13
  LPARAM lParam; // [sp+8h] [bp-18h]@7
  int v13; // [sp+14h] [bp-Ch]@7
  int v14; // [sp+18h] [bp-8h]@1
  int v15; // [sp+1Ch] [bp-4h]@1
  int i; // [sp+2Ch] [bp+Ch]@4

  v4 = a2;
  v14 = a3;
  v15 = a4;
  if ( a2 == -1 && a3 == a2 )
    v4 = 0;
  for ( i = 0; i < *((_DWORD *)hDC + 33); ++i )
  {
    v5 = *((_DWORD *)hDC + 33);
    v6 = v4 + a3;
    v8 = __OFSUB__(v4 + a3, v5);
    v7 = v4 + a3 - v5 < 0;
    v4 = (a3 + v5 + v4) % v5;
    if ( !(v7 ^ v8) || v6 < 0 )
    {
      v13 = v4;
      if ( CCSendNotify((int)hDC, -724, (LPARAM)&lParam) )
        break;
    }
    v9 = *((_DWORD *)hDC + 12) + 28 * v4;
    v10 = *(_BYTE *)(v9 + 8);
    if ( v10 & 4 && !(v10 & 8) && !(*(_BYTE *)(v9 + 9) & 1) )
    {
      v11 = *((_DWORD *)hDC + 51);
      if ( v11 != -1 && v11 == *((_DWORD *)hDC + 52) )
        TBToggleDropDown(hDC, v11, 0);
      TBSetHotItem(hDC, v4, a4);
      return;
    }
  }
}

//----- (6F79B63B) --------------------------------------------------------
int __stdcall TBHitTest(HDC hDC, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // ebx@1
  int result; // eax@2
  RECT rcSrc2; // [sp+Ch] [bp-14h]@4
  int v8; // [sp+1Ch] [bp-4h]@1

  v3 = *((_DWORD *)hDC + 33);
  v4 = 0;
  v5 = 0;
  v8 = 0;
  if ( !v3 )
    return -1;
  if ( v3 > 0 )
  {
    while ( 1 )
    {
      if ( TB_GetItemRect(hDC, v4, (int)&rcSrc2)
        && (!(*((_BYTE *)hDC + 36) & 0x10) || !TBIsRectClipped((int)hDC, &rcSrc2)) )
      {
        if ( a3 < rcSrc2.top || a3 >= rcSrc2.bottom )
        {
          v8 = v4;
        }
        else
        {
          if ( a2 >= rcSrc2.left && a2 < rcSrc2.right )
          {
            if ( *(_BYTE *)(28 * v4 + *((_DWORD *)hDC + 12) + 9) & 1 )
              goto LABEL_17;
            return v4;
          }
          v5 = v4 + 1;
        }
      }
      ++v4;
      if ( v4 >= *((_DWORD *)hDC + 33) )
      {
        if ( !v5 )
          break;
        return -1 - v5;
      }
    }
  }
  if ( a3 > rcSrc2.bottom )
LABEL_17:
    result = -1 - v4;
  else
    result = v8 + 1;
  return result;
}

//----- (6F79B6EF) --------------------------------------------------------
int __stdcall TBInsertMarkHitTest(HDC hDC, int a2, int a3, int a4)
{
  HDC v4; // ebx@1
  int v5; // esi@1
  int v6; // edx@4
  int v7; // ecx@6
  signed int v8; // eax@14
  int result; // eax@17
  int v10; // ecx@18
  bool v11; // zf@18
  bool v12; // sf@18
  unsigned __int8 v13; // of@18
  int v14; // edx@22
  int v15; // [sp+Ch] [bp-20h]@2
  int v16; // [sp+10h] [bp-1Ch]@3
  int v17; // [sp+14h] [bp-18h]@6
  int v18; // [sp+18h] [bp-14h]@4
  int v19; // [sp+1Ch] [bp-10h]@1
  int v20; // [sp+24h] [bp-8h]@1
  int v21; // [sp+28h] [bp-4h]@1
  int hDCa; // [sp+34h] [bp+8h]@1

  v19 = -1;
  v20 = -1;
  v4 = hDC;
  hDCa = 0;
  v5 = ~(unsigned __int8)(*((_DWORD *)v4 + 2) >> 7) & 1;
  v11 = *((_DWORD *)v4 + 33) == 0;
  v12 = *((_DWORD *)v4 + 33) < 0;
  v21 = 3;
  if ( v12 || v11 )
  {
LABEL_25:
    *(_DWORD *)a4 = v20;
    v8 = v21;
    goto LABEL_26;
  }
  while ( !TB_GetItemRect(v4, hDCa, (int)&v15) )
  {
LABEL_12:
    ++hDCa;
    if ( hDCa >= *((_DWORD *)v4 + 33) )
    {
      if ( v19 == -1 )
        goto LABEL_25;
      *(_DWORD *)a4 = v19;
      v8 = 3;
LABEL_26:
      *(_DWORD *)(a4 + 4) = v8;
      return 0;
    }
  }
  if ( a3 < v16 )
  {
    if ( v19 == -1 )
    {
      *(_DWORD *)a4 = hDCa;
      *(_DWORD *)(a4 + 4) = 2;
    }
    else
    {
      *(_DWORD *)a4 = v19;
      *(_DWORD *)(a4 + 4) = 3;
    }
    goto LABEL_12;
  }
  v6 = v18;
  if ( a3 >= v18 )
  {
    v20 = hDCa;
    goto LABEL_12;
  }
  if ( a2 < v15 )
  {
    *(_DWORD *)a4 = hDCa;
    *(_DWORD *)(a4 + 4) = 2;
    return 0;
  }
  v7 = v17;
  if ( a2 >= v17 )
  {
    v19 = hDCa;
    goto LABEL_12;
  }
  *(_DWORD *)a4 = hDCa;
  if ( v5 )
  {
    if ( a2 < 4 * g_cxEdge + v15 )
    {
LABEL_17:
      *(_DWORD *)(a4 + 4) = 0;
      return 1;
    }
    v10 = v7 - 4 * g_cxEdge;
    v13 = __OFSUB__(a2, v10);
    v11 = a2 == v10;
    v12 = a2 - v10 < 0;
  }
  else
  {
    if ( a3 < 4 * g_cyEdge + v16 )
      goto LABEL_17;
    v14 = v6 - 4 * g_cyEdge;
    v13 = __OFSUB__(a3, v14);
    v11 = a3 == v14;
    v12 = a3 - v14 < 0;
  }
  if ( (unsigned __int8)(v12 ^ v13) | v11 )
  {
    *(_DWORD *)(a4 + 4) = 0;
    return 0;
  }
  result = 1;
  *(_DWORD *)(a4 + 4) = 1;
  return result;
}

//----- (6F79B81F) --------------------------------------------------------
int __stdcall MakeGroupConsistant(HDC hDC, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int result; // eax@1
  int v5; // edx@2
  int v6; // ecx@3
  int v7; // edi@4
  int v8; // ebx@9
  int v9; // edi@9
  int v10; // edx@10
  int v11; // edx@15
  int v12; // ecx@16
  int v13; // [sp+14h] [bp+Ch]@1

  v2 = *((_DWORD *)hDC + 33);
  v3 = *((_DWORD *)hDC + 12);
  result = PositionFromID((int)hDC, a2);
  v13 = result;
  if ( result >= 0 )
  {
    v5 = 28 * result + v3;
    if ( *(_BYTE *)(v5 + 8) & 1 )
    {
      v6 = result;
      if ( result > 0 )
      {
        v7 = v5 + 9;
        do
        {
          if ( !(*(_BYTE *)v7 & 4) )
            break;
          --v6;
          v7 -= 28;
        }
        while ( v6 > 0 );
      }
      if ( !(*(_BYTE *)(28 * v6 + v3 + 9) & 4) )
        ++v6;
      v8 = v2 - 1;
      v9 = result;
      if ( result < v8 )
      {
        v10 = v5 + 9;
        do
        {
          if ( !(*(_BYTE *)v10 & 4) )
            break;
          ++v9;
          v10 += 28;
        }
        while ( v9 < v8 );
      }
      result = 28 * v9;
      if ( !(*(_BYTE *)(28 * v9 + v3 + 9) & 4) )
        --v9;
      v11 = v6;
      if ( v6 <= v9 )
      {
        v12 = 28 * v6 + v3 + 8;
        while ( v11 == v13 || !(*(_BYTE *)v12 & 1) )
        {
          ++v11;
          v12 += 28;
          if ( v11 > v9 )
            return result;
        }
        *(_BYTE *)(28 * v11 + v3 + 8) &= 0xFEu;
        result = TBInvalidateButton(hDC, v11, 1);
      }
    }
  }
  return result;
}

//----- (6F79B8E4) --------------------------------------------------------
int __stdcall TB_OnSetImage(HDC hDC, int a2, int a3)
{
  int v3; // eax@1
  int v4; // eax@4
  int v5; // eax@4
  bool v6; // sf@4
  unsigned __int8 v7; // of@4
  int v9; // edx@7
  int v10; // eax@7
  int v11; // ecx@7

  v3 = *((_DWORD *)hDC + 59);
  if ( !(v3 & 2) )
  {
    if ( v3 & 1 )
    {
      if ( !TBGetImageList((int)hDC, 0, 0) )
        return 0;
      v4 = TBGetImageList((int)hDC, 0, 0);
      v5 = ImageList_GetImageCount((HIMAGELIST)v4);
      v7 = __OFSUB__(a3, v5);
      v6 = a3 - v5 < 0;
    }
    else
    {
      v9 = *((_DWORD *)hDC + 20);
      v10 = *((_DWORD *)hDC + 21);
      v11 = 0;
      if ( v9 > 0 )
      {
        do
        {
          v11 += *(_DWORD *)v10;
          v10 += 12;
          --v9;
        }
        while ( v9 );
      }
      v7 = __OFSUB__(a3, v11);
      v6 = a3 - v11 < 0;
    }
    if ( !(v6 ^ v7) )
      return 0;
  }
  *(_DWORD *)a2 = a3;
  InvalidateButton(hDC, a2, 0);
  UpdateWindow(*(HWND *)hDC);
  return 1;
}

//----- (6F79B960) --------------------------------------------------------
signed int __stdcall TB_OnGetButtonInfo(int a1, int a2, int a3)
{
  signed int result; // eax@2
  signed int v4; // eax@4
  signed int v5; // esi@6
  int v6; // eax@8
  int v7; // esi@8
  int v8; // eax@17
  int v9; // eax@20
  signed int v10; // [sp+10h] [bp+Ch]@6

  if ( *(_DWORD *)a3 == 32 )
  {
    if ( *(_DWORD *)(a3 + 4) & 0x80000000 )
      v4 = a2;
    else
      v4 = PositionFromID(a1, a2);
    v5 = v4;
    v10 = v4;
    if ( v4 < 0 || v4 >= *(_DWORD *)(a1 + 132) )
    {
      v10 = -1;
    }
    else
    {
      v6 = *(_DWORD *)(a3 + 4);
      v7 = *(_DWORD *)(a1 + 48) + 28 * v5;
      if ( v6 & 8 )
        *(_BYTE *)(a3 + 17) = *(_BYTE *)(v7 + 9);
      if ( v6 & 4 )
        *(_BYTE *)(a3 + 16) = *(_BYTE *)(v7 + 8);
      if ( v6 & 1 )
        *(_DWORD *)(a3 + 12) = *(_DWORD *)v7;
      if ( v6 & 0x40 )
        *(_WORD *)(a3 + 18) = *(_WORD *)(v7 + 10);
      if ( v6 & 2 )
      {
        v8 = *(_DWORD *)(v7 + 16);
        if ( v8 != -1 )
        {
          if ( v8 & 0xFFFF0000 )
            StringCchCopyW(*(STRSAFE_LPWSTR *)(a3 + 24), *(_DWORD *)(a3 + 28), *(STRSAFE_LPCWSTR *)(v7 + 16));
        }
      }
      v9 = *(_DWORD *)(a3 + 4);
      if ( v9 & 0x10 )
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(v7 + 12);
      if ( v9 & 0x20 )
        *(_DWORD *)(a3 + 8) = *(_DWORD *)(v7 + 4);
    }
    result = v10;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F79BA20) --------------------------------------------------------
int __stdcall TBOnChar(HDC hDC, WORD w2)
{
  int v2; // ebx@1
  HDC v3; // esi@1
  int v4; // eax@1
  int v5; // ecx@1
  int v7; // edi@9
  int v8; // eax@10
  LPARAM lParam; // [sp+Ch] [bp-18h]@1
  int v10; // [sp+10h] [bp-14h]@1
  int v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+18h] [bp-Ch]@1
  int v13; // [sp+1Ch] [bp-8h]@1
  int v14; // [sp+20h] [bp-4h]@1

  lParam = 0;
  v2 = w2;
  v3 = hDC;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v4 = TBItemFromAccelerator((int)hDC, w2, (int)&hDC);
  v5 = *((_DWORD *)v3 + 51);
  *(_DWORD *)&w2 = 0;
  v12 = v2;
  if ( v5 < 0 )
    v13 = -1;
  else
    v13 = *(_DWORD *)(28 * v5 + *((_DWORD *)v3 + 12) + 4);
  if ( v4 < 0 )
    v14 = -1;
  else
    v14 = *(_DWORD *)(*((_DWORD *)v3 + 12) + 28 * v4 + 4);
  if ( CCSendNotify((int)v3, -18, (LPARAM)&lParam) )
    return 1;
  v7 = PositionFromID((int)v3, v14);
  if ( v7 == -1 )
  {
    if ( v2 != 13 && v2 != 32 )
      goto LABEL_24;
    v7 = *((_DWORD *)v3 + 51);
    if ( v7 == -1
      || !(*(_BYTE *)(*((_DWORD *)v3 + 12) + 28 * v7 + 9) & 0x88)
      || TB_HasSplitDDArrow((int)v3, *((_DWORD *)v3 + 12) + 28 * v7) )
      goto LABEL_24;
  }
  else
  {
    v8 = 4;
    if ( *((_DWORD *)v3 + 51) == v7 )
      v8 = 68;
    if ( hDC )
      v8 |= 8u;
    TBSetHotItem(v3, v7, v8);
    if ( hDC )
      v7 = -1;
  }
  *(_DWORD *)&w2 = 1;
  if ( v7 != -1 )
  {
    if ( *(_BYTE *)(*((_DWORD *)v3 + 12) + 28 * v7 + 9) & 0x88 )
      TBToggleDropDown(v3, v7, 0);
  }
LABEL_24:
  CCNotifyNavigationKeyUsage((int)v3, 3u);
  return w2;
}

//----- (6F79BB40) --------------------------------------------------------
int __stdcall TBOnKey(HDC hDC, int a2, int a3)
{
  int v3; // eax@2
  int v4; // ecx@2
  int v6; // [sp-8h] [bp-24h]@16
  LPARAM lParam; // [sp+8h] [bp-14h]@1
  int v8; // [sp+14h] [bp-8h]@1
  int v9; // [sp+18h] [bp-4h]@1

  v9 = a3;
  v8 = a2;
  if ( CCSendNotify((int)hDC, -15, (LPARAM)&lParam) )
    return 1;
  v3 = RTLSwapLeftRightArrows((int)hDC, a2);
  v4 = *((_DWORD *)hDC + 51);
  if ( v4 == -1 || !(*(_BYTE *)(28 * v4 + *((_DWORD *)hDC + 12) + 9) & 0x88) )
    goto LABEL_11;
  if ( v3 == 27 )
  {
    if ( v4 != *((_DWORD *)hDC + 52) )
      return 0;
    goto LABEL_21;
  }
  if ( v3 == 37 )
    goto LABEL_30;
  if ( v3 == 38 )
  {
LABEL_9:
    if ( *((_BYTE *)hDC + 8) & 0x80 || *((_BYTE *)hDC + 36) & 4 )
      goto LABEL_11;
LABEL_21:
    TBToggleDropDown(hDC, v4, 0);
    goto LABEL_26;
  }
  if ( v3 == 39 )
  {
LABEL_30:
    if ( *((_BYTE *)hDC + 8) & 0x80 )
      goto LABEL_21;
  }
  else if ( v3 == 40 )
  {
    goto LABEL_9;
  }
LABEL_11:
  if ( v3 == 13 || v3 == 32 )
  {
    if ( v4 != -1 )
      SendMessageW(*((HWND *)hDC + 1), 0x111u, *(_WORD *)(28 * v4 + *((_DWORD *)hDC + 12) + 4), *(_DWORD *)hDC);
    goto LABEL_26;
  }
  if ( v3 <= 36 )
    return 0;
  if ( v3 <= 38 )
  {
    v6 = -1;
    goto LABEL_17;
  }
  if ( v3 > 40 )
    return 0;
  v6 = 1;
LABEL_17:
  TBCycleHotItem(hDC, v4, v6, 2);
LABEL_26:
  CCNotifyNavigationKeyUsage((int)hDC, 3u);
  return 1;
}

//----- (6F79BC31) --------------------------------------------------------
signed int __stdcall TB_OnGetButtonInfoA(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  signed int v5; // eax@1
  int v6; // eax@2
  const WCHAR *v7; // eax@3
  signed int v9; // [sp+1Ch] [bp+10h]@1

  v3 = a3;
  v4 = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(v3 + 4) &= 0xFFFFFFFD;
  v5 = TB_OnGetButtonInfo(a1, a2, a3);
  v9 = v5;
  if ( v5 != -1 )
  {
    v6 = *(_DWORD *)(a1 + 48) + 28 * v5;
    *(_DWORD *)(v3 + 4) = v4;
    if ( v4 & 2 )
    {
      v7 = *(const WCHAR **)(v6 + 16);
      if ( v7 != (const WCHAR *)-1 && (unsigned int)v7 & 0xFFFF0000 )
        WideCharToMultiByte(0, 0, v7, -1, *(LPSTR *)(v3 + 24), *(_DWORD *)(v3 + 28), 0, 0);
      else
        **(_BYTE **)(v3 + 24) = 0;
    }
  }
  return v9;
}

//----- (6F79BCA1) --------------------------------------------------------
int __stdcall TB_CalcWidth(HDC hDC, int a2)
{
  HDC v2; // edi@1
  int v3; // eax@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@3
  signed int v8; // ecx@8
  int v9; // esi@12
  int v11; // [sp+Ch] [bp-14h]@10
  int v12; // [sp+10h] [bp-10h]@10
  int v13; // [sp+14h] [bp-Ch]@20
  int v14; // [sp+18h] [bp-8h]@10
  int v15; // [sp+1Ch] [bp-4h]@1
  HDC hDCa; // [sp+28h] [bp+8h]@6
  HDC hDCb; // [sp+28h] [bp+8h]@11
  int v18; // [sp+2Ch] [bp+Ch]@8

  v2 = hDC;
  v3 = *((_DWORD *)hDC + 12);
  v4 = 28 * *((_DWORD *)hDC + 33);
  v5 = 0;
  v15 = 0;
  v6 = v3 + v4;
  while ( 1 )
  {
    hDCa = (HDC)v3;
    if ( v3 >= (unsigned int)v6 )
      break;
    if ( !(*(_BYTE *)(v3 + 8) & 8) )
    {
      v7 = TBWidthOfButton(v5, v2, v3, 0);
      v5 += v7;
      if ( v15 <= v7 )
        v15 = v7;
    }
    v3 = (int)(hDCa + 7);
  }
  if ( *((_DWORD *)v2 + 2) & 0x200 )
  {
    v8 = *((_DWORD *)v2 + 29);
    v18 = a2 - a2 % v8;
    if ( v18 < v8 )
      v18 = *((_DWORD *)v2 + 29);
    WrapToolbar(v2, v5, (int)&v11, 0);
    if ( v18 > v14 - v12 )
    {
      hDCb = (HDC)1;
      while ( v15 < v5 )
      {
        v9 = v5;
        if ( hDCb )
          v5 = 2 * v5 / 3;
        else
          v5 -= *((_DWORD *)v2 + 28);
        if ( v5 == v9 )
          break;
        WrapToolbar(v2, v5, (int)&v11, 0);
        if ( v18 < v14 - v12 )
        {
          v5 = v9;
          if ( !hDCb )
            break;
          hDCb = 0;
        }
      }
      WrapToolbar(v2, v5, (int)&v11, 0);
      v5 = v15;
      if ( v13 - v11 > v15 )
        v5 = v13 - v11;
    }
    TBAutoSize((HWND)v2);
  }
  return v5;
}

//----- (6F79BDA3) --------------------------------------------------------
int __stdcall TB_OnScroll(HDC hDC, int a2)
{
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // edx@1
  HDC v5; // edi@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // eax@7
  int v9; // esi@9
  int v10; // edx@14
  int v11; // ecx@16
  int v12; // eax@16
  int v13; // eax@23
  int v14; // edx@26
  int v15; // ecx@26
  int v16; // esi@35
  int v17; // eax@39
  int v18; // eax@43
  struct tagRECT Rect; // [sp+Ch] [bp-48h]@13
  int v21; // [sp+1Ch] [bp-38h]@1
  int v22; // [sp+20h] [bp-34h]@1
  int v23; // [sp+24h] [bp-30h]@1
  int v24; // [sp+28h] [bp-2Ch]@1
  int v25; // [sp+2Ch] [bp-28h]@1
  int v26; // [sp+30h] [bp-24h]@1
  int v27; // [sp+34h] [bp-20h]@1
  int v28; // [sp+38h] [bp-1Ch]@1
  int v29; // [sp+3Ch] [bp-18h]@1
  int v30; // [sp+40h] [bp-14h]@1
  int v31; // [sp+44h] [bp-10h]@1
  int v32; // [sp+48h] [bp-Ch]@1
  int v33; // [sp+4Ch] [bp-8h]@1
  int v34; // [sp+50h] [bp-4h]@1
  int hDCa; // [sp+5Ch] [bp+8h]@3
  int v36; // [sp+60h] [bp+Ch]@7

  v25 = 0;
  v2 = a2;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v3 = *(_DWORD *)(a2 + 34);
  v4 = *(_DWORD *)(a2 + 30);
  v21 = *(_DWORD *)(a2 + 14);
  v22 = *(_DWORD *)(a2 + 18);
  v23 = *(_DWORD *)(a2 + 22);
  v24 = *(_DWORD *)(a2 + 26);
  v5 = hDC;
  v6 = *((_DWORD *)hDC + 36) + v3;
  v7 = *((_DWORD *)hDC + 32) + *(_DWORD *)(a2 + 38);
  v33 = *((_DWORD *)hDC + 29);
  v34 = v4;
  v29 = v6;
  v30 = v7;
  v31 = v6;
  v32 = v7;
  if ( (v4 == 1 || v4 == 2) && *((_DWORD *)hDC + 28) )
  {
    hDCa = (v23 - v21) / *((_DWORD *)hDC + 28);
    if ( !hDCa )
      hDCa = 1;
  }
  else
  {
    hDCa = 1;
  }
  v8 = TBHitTest(v5, v6 + 1, v7 + 1);
  v36 = v8;
  if ( v8 < 0 )
    v36 = -1 - v8;
  v9 = v34;
  if ( v34 == 1 )
    goto LABEL_33;
  if ( v34 != 2 )
  {
    if ( v34 != 4 )
    {
      if ( v34 != 8 )
        return 0;
      goto LABEL_13;
    }
LABEL_33:
    if ( v34 == 4 )
    {
      FlipRect((int)&v21);
      FlipPoint((int)&v29);
      FlipPoint((int)&v31);
      v33 = *((_DWORD *)v5 + 28);
    }
    v16 = v30;
    TB_GetItemRect(v5, v36, (int)&v25);
    if ( v34 == 4 )
      FlipRect((int)&v25);
    if ( v26 < v16 - 1 )
      v36 += hDCa;
    v17 = v24 - v22;
    if ( !(*(_BYTE *)(v2 + 12) & 2) )
      v17 = v33;
    if ( v16 - v17 > 0 )
    {
      v32 -= v17;
      if ( v34 == 4 )
        FlipPoint((int)&v31);
      v18 = TBHitTest(v5, v31, v32);
      if ( v18 < 0 )
        v18 = -1 - v18;
      if ( v18 == v36 && v18 >= hDCa )
      {
        v18 -= hDCa;
        if ( *(_BYTE *)(28 * v18 + *((_DWORD *)v5 + 12) + 9) & 1 )
        {
          if ( v18 >= hDCa )
            v18 -= hDCa;
        }
      }
      if ( v18 == v36 - hDCa )
        v18 -= hDCa;
      TB_GetItemRect(v5, v18, (int)&v25);
      if ( v34 == 4 )
        FlipRect((int)&v25);
      v12 = v30 - v28;
      goto LABEL_55;
    }
    return 0;
  }
LABEL_13:
  GetWindowRect(*(HWND *)v5, &Rect);
  if ( v9 == 8 )
  {
    FlipRect((int)&Rect);
    FlipRect((int)&v21);
    FlipPoint((int)&v29);
    FlipPoint((int)&v31);
    v10 = *((_DWORD *)v5 + 28);
  }
  else
  {
    v10 = v33;
  }
  v11 = v24 - v22;
  v12 = Rect.bottom - Rect.top - v30 - (v24 - v22);
  if ( !(*(_BYTE *)(v2 + 12) & 2) )
  {
    if ( v12 <= v10 )
    {
LABEL_55:
      *(_DWORD *)(v2 + 42) = v12;
      return 0;
    }
    v11 = v10;
LABEL_21:
    v32 += v11;
    if ( v9 == 8 )
      FlipPoint((int)&v31);
    v13 = TBHitTest(v5, v31, v32);
    if ( v13 < 0 )
      v13 = -1 - v13;
    if ( v13 == v36 )
    {
      v14 = *((_DWORD *)v5 + 33);
      v15 = v13 + hDCa;
      if ( v13 + hDCa < v14 )
      {
        v13 += hDCa;
        if ( *(_BYTE *)(28 * v15 + *((_DWORD *)v5 + 12) + 9) & 1 )
        {
          if ( v13 + hDCa < v14 )
            v13 += hDCa;
        }
      }
    }
    TB_GetItemRect(v5, v13, (int)&v25);
    if ( v34 == 8 )
      FlipRect((int)&v25);
    v12 = v26 - v30;
    goto LABEL_55;
  }
  if ( v12 > v11 )
    goto LABEL_21;
  return 0;
}

//----- (6F79C03A) --------------------------------------------------------
int __stdcall TB_OnCalcSize(HDC hDC, int a2)
{
  int v2; // eax@3
  int v3; // eax@4
  int v4; // ecx@5
  int v5; // eax@13
  struct tagRECT rcDst; // [sp+8h] [bp-10h]@6

  if ( *(_DWORD *)(a2 + 12) == 1 )
  {
    if ( *((_DWORD *)hDC + 42) == *(_DWORD *)(a2 + 20) )
      v5 = *((_DWORD *)hDC + 41);
    else
      v5 = TB_CalcWidth(hDC, *(_DWORD *)(a2 + 20));
    *(_DWORD *)(a2 + 16) = v5;
  }
  else if ( *(_DWORD *)(a2 + 12) == 2 )
  {
    v2 = *(_DWORD *)(a2 + 16);
    if ( *((_DWORD *)hDC + 41) == v2 )
    {
      v3 = *((_DWORD *)hDC + 42);
LABEL_11:
      *(_DWORD *)(a2 + 20) = v3;
      goto LABEL_16;
    }
    v4 = *((_DWORD *)hDC + 9);
    if ( v4 & 2 )
    {
      WrapToolbarCol((int)hDC, *((_DWORD *)hDC + 65), &rcDst, 0);
      *(_DWORD *)(a2 + 16) = rcDst.right - rcDst.left;
    }
    else
    {
      if ( v4 & 4 )
      {
        v3 = TB_CalcHeight((int)hDC);
        goto LABEL_11;
      }
      WrapToolbar(hDC, v2, (int)&rcDst, 0);
    }
    v3 = rcDst.bottom - rcDst.top;
    goto LABEL_11;
  }
LABEL_16:
  *((_DWORD *)hDC + 41) = *(_DWORD *)(a2 + 16);
  *((_DWORD *)hDC + 42) = *(_DWORD *)(a2 + 20);
  return 0;
}

//----- (6F79C0EC) --------------------------------------------------------
int __stdcall TB_OnPagerControlNotify(HDC hDC, int a2)
{
  int v2; // eax@1
  int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  if ( v2 == -902 )
  {
    result = TB_OnCalcSize(hDC, a2);
  }
  else if ( v2 == -901 )
  {
    result = TB_OnScroll(hDC, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F79C126) --------------------------------------------------------
void __stdcall TB_ForceCreateTooltips(HDC hDC)
{
  HDC v1; // esi@1
  HWND v2; // eax@3
  HWND v3; // eax@3
  bool v4; // zf@4
  bool v5; // sf@4
  int v6; // eax@6
  LPARAM lParam; // [sp+4h] [bp-40h]@3
  int v8; // [sp+8h] [bp-3Ch]@3
  HWND v9; // [sp+Ch] [bp-38h]@3
  HWND v10; // [sp+10h] [bp-34h]@3
  int v11; // [sp+28h] [bp-1Ch]@3
  LPARAM v12; // [sp+30h] [bp-14h]@4
  int v13; // [sp+3Ch] [bp-8h]@4
  int v14; // [sp+40h] [bp-4h]@4
  HDC hDCa; // [sp+4Ch] [bp+8h]@5

  v1 = hDC;
  if ( *((_DWORD *)hDC + 2) & 0x100 )
  {
    if ( !*((_DWORD *)hDC + 16) )
    {
      v2 = *(HWND *)hDC;
      v9 = v2;
      v10 = v2;
      lParam = 44;
      v8 = 1;
      v11 = 0;
      v3 = CreateWindowExW(
             0,
             L"tooltips_class32",
             0,
             0x80000000,
             2147483648,
             2147483648,
             2147483648,
             2147483648,
             v2,
             0,
             g_hinst,
             0);
      *((_DWORD *)hDC + 16) = v3;
      if ( v3 )
      {
        CCSetInfoTipWidth(*(HWND *)hDC, v3);
        SendMessageW(*((HWND *)hDC + 16), 0x432u, 0, (LPARAM)&lParam);
        v13 = *((_DWORD *)hDC + 16);
        CCSendNotify((int)hDC, -19, (LPARAM)&v12);
        v11 = -1;
        v4 = *((_DWORD *)hDC + 33) == 0;
        v5 = *((_DWORD *)hDC + 33) < 0;
        v8 = 0;
        v14 = 0;
        if ( !v5 && !v4 )
        {
          hDCa = 0;
          do
          {
            v6 = (int)((char *)hDCa + *((_DWORD *)v1 + 12));
            if ( !(*(_BYTE *)(v6 + 9) & 1) )
            {
              v10 = *(HWND *)(v6 + 4);
              SendMessageW(*((HWND *)v1 + 16), 0x432u, 0, (LPARAM)&lParam);
            }
            ++v14;
            hDCa += 7;
          }
          while ( v14 < *((_DWORD *)v1 + 33) );
        }
        FlushToolTipsMgrNow(v1);
      }
    }
  }
}

//----- (6F79C21B) --------------------------------------------------------
LRESULT __stdcall TBRelayToToolTips(HDC hDC, int a2, int a3, int a4)
{
  LRESULT result; // eax@1

  TB_ForceCreateTooltips(hDC);
  result = *((_DWORD *)hDC + 16);
  if ( result )
    result = RelayToToolTips((HWND)result, *(_DWORD *)hDC, a2, a3, a4);
  return result;
}

//----- (6F79C24C) --------------------------------------------------------
int __stdcall ToolbarDragCallback(HWND hWnd, int a2, WPARAM wParam, LPARAM a4)
{
  int v4; // esi@1
  LONG v6; // ecx@10
  HWND v7; // ST08_4@10
  int v8; // eax@10
  LPARAM lParam; // [sp+4h] [bp-20h]@5
  WPARAM v10; // [sp+14h] [bp-10h]@5
  struct tagPOINT Points; // [sp+1Ch] [bp-8h]@10

  v4 = GetWindowLongW(hWnd, 0);
  if ( !a2 )
  {
    if ( a4 )
    {
      v6 = *(_DWORD *)a4;
      Points.y = *(_DWORD *)(a4 + 4);
      v7 = *(HWND *)v4;
      Points.x = v6;
      MapWindowPoints(0, v7, &Points, 1u);
      v8 = TBHitTest((HDC)v4, Points.x, Points.y);
      if ( v8 >= 0 && v8 < *(_DWORD *)(v4 + 132) )
        return *(_DWORD *)(*(_DWORD *)(v4 + 48) + 28 * v8 + 4);
    }
    return -1;
  }
  if ( a2 == 1 )
    return GetItemObject(v4, -712, (int)&IID_IDropTarget, a4);
  if ( a2 != 2 )
    return -1;
  if ( (wParam & 0x80000000) == 0 )
  {
    v10 = wParam;
    if ( !CCSendNotify(v4, -727, (LPARAM)&lParam) )
      SendMessageW(*(HWND *)v4, 0x406u, wParam, a4 != 0);
  }
  return 0;
}

//----- (6F79C314) --------------------------------------------------------
LONG __stdcall DrawToolbarV(int xLeft, HDC hdc, RECT *lprcSrc)
{
  int v3; // esi@1
  LONG result; // eax@1
  int v5; // ecx@1
  RECT *v6; // edi@1
  int v7; // ebx@1
  bool v8; // zf@1
  bool v9; // sf@1
  int v10; // eax@6
  LONG v11; // ecx@16
  int v12; // eax@17
  unsigned __int8 v13; // of@18
  LPARAM lParam; // [sp+Ch] [bp-84h]@10
  char Dst; // [sp+10h] [bp-80h]@10
  HDC v16; // [sp+1Ch] [bp-74h]@10
  struct tagRECT rcDst; // [sp+20h] [bp-70h]@10
  int v18; // [sp+30h] [bp-60h]@10
  RECT rcSrc; // [sp+78h] [bp-18h]@16
  int v20; // [sp+88h] [bp-8h]@8
  int v21; // [sp+8Ch] [bp-4h]@1
  int xLefta; // [sp+98h] [bp+8h]@1
  LONG lprcSrca; // [sp+A0h] [bp+10h]@1

  v3 = xLeft;
  result = *(_DWORD *)(xLeft + 144);
  v5 = *(_DWORD *)(xLeft + 48);
  v6 = lprcSrc;
  lprcSrc->left = result;
  v7 = 0;
  lprcSrc->right = result + *(_DWORD *)(xLeft + 112);
  v8 = *(_DWORD *)(xLeft + 132) == 0;
  v9 = *(_DWORD *)(xLeft + 132) < 0;
  v21 = v5;
  xLefta = result;
  lprcSrca = 0;
  if ( !v9 && !v8 )
  {
    do
    {
      if ( !(*(_BYTE *)(v5 + 8) & 8) )
      {
        if ( !(*(_BYTE *)(v5 + 9) & 1) || *(_DWORD *)(v3 + 8) & 0x800 )
        {
          if ( *(_BYTE *)(v5 + 9) & 1 )
            v10 = TBGetSepHeight(v3, (int *)v5);
          else
            v10 = *(_DWORD *)(v3 + 116);
          v6->top = v7;
          v20 = v7 + v10;
          v6->bottom = v7 + v10;
          if ( TBShouldDrawButton(v3, v6, hdc) )
          {
            if ( *(_BYTE *)(v21 + 9) & 1 )
            {
              lParam = 0;
              memset(&Dst, 0, 0x68u);
              v18 = -1;
              v16 = hdc;
              CopyRect(&rcDst, v6);
              if ( !(CICustomDrawNotify(v3, 65537, (LPARAM)&lParam) & 4) )
              {
                InflateRect(v6, -g_cxEdge, 0);
                CCDrawEdge(hdc, v6, 6, 2, v3 + 184);
                InflateRect(v6, g_cxEdge, 0);
              }
            }
            else
            {
              DrawButton(v7, hdc, xLefta, v7, (HDC)v3, v21, (*(_DWORD *)(v3 + 236) >> 6) & 1);
            }
          }
          v7 = v20;
          v5 = v21;
        }
        if ( *(_BYTE *)(v5 + 8) & 0x20 )
        {
          if ( *(_DWORD *)(v3 + 8) & 0x800 )
          {
            rcSrc.top = g_cxEdge + *(_DWORD *)(v3 + 244);
            rcSrc.bottom = *(_DWORD *)(v3 + 252) - g_cxEdge;
            v11 = xLefta + *(_DWORD *)(v3 + 112);
            rcSrc.right = v11 + g_cxEdge;
            rcSrc.left = v11;
            CCDrawEdge(hdc, &rcSrc, 6, 1, v3 + 184);
            v5 = v21;
          }
          v12 = g_cxEdge + *(_DWORD *)(v3 + 112);
          v7 = 0;
          xLefta += v12;
          v6->left += v12;
          v6->right += v12;
        }
      }
      ++lprcSrca;
      result = lprcSrca;
      v5 += 28;
      v13 = __OFSUB__(lprcSrca, *(_DWORD *)(v3 + 132));
      v9 = lprcSrca - *(_DWORD *)(v3 + 132) < 0;
      v21 = v5;
    }
    while ( v9 ^ v13 );
  }
  return result;
}

//----- (6F79C4C5) --------------------------------------------------------
int __stdcall TB_GetItemDropDownRect(HDC hDC, int a2, int a3)
{
  int result; // eax@1

  TB_GetItemRect(hDC, a2, a3);
  result = *(_DWORD *)(a3 + 8) - *((_DWORD *)hDC + 35);
  *(_DWORD *)a3 = result;
  return result;
}

//----- (6F79C4F2) --------------------------------------------------------
int __stdcall TBGetString(int a1, int a2, size_t cchDest, STRSAFE_LPWSTR pszDest)
{
  int v5; // [sp+8h] [bp-4h]@1

  v5 = -1;
  if ( pszDest )
    *pszDest = 0;
  if ( a2 < *(_DWORD *)(a1 + 92) && a2 >= 0 )
  {
    v5 = lstrlenW(*(LPCWSTR *)(*(_DWORD *)(a1 + 88) + 4 * a2));
    if ( pszDest )
      StringCchCopyW(pszDest, cchDest, *(STRSAFE_LPCWSTR *)(*(_DWORD *)(a1 + 88) + 4 * a2));
  }
  return v5;
}

//----- (6F79C550) --------------------------------------------------------
int __stdcall TBMoveButton(HWND hWndTo, int a2, int a3)
{
  HWND v3; // ebx@1
  unsigned int v4; // eax@1
  int v6; // eax@3
  int v7; // ecx@6
  const void *v8; // eax@6
  void *v9; // edx@6
  unsigned int v10; // ecx@7
  signed int v11; // edi@7
  int v12; // ecx@9
  int v13; // esi@10
  unsigned int v14; // ecx@10
  char v15; // [sp+8h] [bp-20h]@6
  int v16; // [sp+24h] [bp-4h]@14
  int hWndToa; // [sp+30h] [bp+8h]@7
  int v18; // [sp+34h] [bp+Ch]@7
  int v19; // [sp+38h] [bp+10h]@7

  v3 = hWndTo;
  v4 = *((_DWORD *)hWndTo + 33);
  if ( a2 >= v4 )
    return 0;
  v6 = v4 - 1;
  if ( a3 > (unsigned int)v6 )
    a3 = v6;
  if ( a2 == a3 )
    return 0;
  TBInvalidateItemRects((int)hWndTo);
  v7 = *((_DWORD *)hWndTo + 12);
  v8 = (const void *)(v7 + 28 * a2);
  v9 = (void *)(v7 + 28 * a3);
  qmemcpy(&v15, v8, 0x1Cu);
  if ( a2 >= (unsigned int)a3 )
  {
    hWndToa = a2 - a3;
    v13 = (int)((char *)v9 + 28 * (a2 - a3) - 28);
    v19 = (int)((char *)v9 + 28 * (a2 - a3));
    v14 = *((_DWORD *)v3 + 13);
    v11 = -1;
    v18 = v13;
    if ( v14 < (unsigned int)v9 || v14 >= (unsigned int)v8 )
      goto LABEL_14;
    v12 = v14 + 28;
  }
  else
  {
    hWndToa = a3 - a2;
    v18 = (int)((char *)v8 + 28);
    v10 = *((_DWORD *)v3 + 13);
    v11 = 1;
    v19 = (int)v8;
    if ( v10 <= (unsigned int)v8 || v10 > (unsigned int)v9 )
      goto LABEL_14;
    v12 = v10 - 28;
  }
  *((_DWORD *)v3 + 13) = v12;
LABEL_14:
  v16 = 28 * v11;
  do
  {
    qmemcpy((void *)v19, (const void *)v18, 0x1Cu);
    v19 += v16;
    v18 += v16;
    --hWndToa;
  }
  while ( hWndToa );
  qmemcpy(v9, &v15, 0x1Cu);
  if ( *((const void **)v3 + 13) == v8 )
    *((_DWORD *)v3 + 13) = v9;
  TBAutoSize(v3);
  InvalidateRect(*(HWND *)v3, 0, 1);
  return 1;
}

//----- (6F79C649) --------------------------------------------------------
void __stdcall TBSetStyleEx(HWND hWndTo, int a2, int a3)
{
  int v3; // eax@1
  unsigned int v4; // ebx@2
  int v5; // edx@7
  int v6; // ecx@8
  signed int v7; // [sp+Ch] [bp-4h]@1
  int i; // [sp+20h] [bp+10h]@12

  v3 = 0;
  v7 = 0;
  if ( a3 )
    v4 = a3 & a2 | ~a3 & *((_DWORD *)hWndTo + 9);
  else
    v4 = a2;
  if ( v4 & 2 )
    v4 = v4 & 0xFFFFFFEF | 4;
  if ( ((unsigned __int8)v4 ^ *((_BYTE *)hWndTo + 36)) & 2 )
  {
    v5 = 0;
    if ( *((_DWORD *)hWndTo + 33) > 0 )
    {
      v6 = 0;
      do
      {
        *(_BYTE *)(v6 + *((_DWORD *)hWndTo + 12) + 8) &= 0xDFu;
        ++v5;
        v6 += 28;
      }
      while ( v5 < *((_DWORD *)hWndTo + 33) );
    }
    v7 = 1;
    v3 = 0;
  }
  if ( ((unsigned __int8)v4 ^ *((_BYTE *)hWndTo + 36)) & 8 )
  {
    for ( i = 0; i < *((_DWORD *)hWndTo + 33); v3 += 28 )
    {
      ++i;
      *(_WORD *)(v3 + *((_DWORD *)hWndTo + 12) + 10) = 0;
    }
    v7 = 1;
    InvalidateRect(*(HWND *)hWndTo, 0, 1);
  }
  if ( ((unsigned __int8)v4 ^ *((_BYTE *)hWndTo + 36)) & 0x10 )
    InvalidateRect(*(HWND *)hWndTo, 0, 1);
  *((_DWORD *)hWndTo + 9) = v4;
  if ( v4 & 4 )
    TBSetStyle(hWndTo, 128);
  if ( v7 )
  {
    TBRecalc((int)hWndTo);
    TBAutoSize(hWndTo);
  }
}

//----- (6F79C73B) --------------------------------------------------------
char __stdcall TB_OnSetState(HDC hDC, int a2, char a3, int a4)
{
  int v4; // eax@1
  bool v5; // zf@1
  char v6; // cl@1
  int v7; // eax@2

  LOBYTE(v4) = a3;
  v6 = a3 ^ *(_BYTE *)(a2 + 8);
  v5 = a3 == *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a2 + 8) = a3;
  if ( !v5 )
  {
    v7 = *((_DWORD *)hDC + 59);
    if ( v7 & 0x800 )
    {
      v4 = v7 | 0x3000;
      *((_DWORD *)hDC + 59) = v4;
    }
    else
    {
      if ( v6 & 8 )
      {
        InvalidateRect(*(HWND *)hDC, 0, 1);
        TBRecalc((int)hDC);
      }
      else
      {
        InvalidateButton(hDC, a2, 1);
      }
      LOBYTE(v4) = MyNotifyWinEvent(32778, *(_DWORD *)hDC, -4, a4 + 1);
    }
  }
  return v4;
}

//----- (6F79C7AB) --------------------------------------------------------
int __stdcall TB_OnSetButtonInfo(HDC hDC, int a2, int a3)
{
  int result; // eax@2
  int v4; // eax@4
  int v5; // esi@7
  char v6; // cl@8
  char v7; // al@20
  int v8; // ecx@25
  signed int v9; // [sp+4h] [bp-4h]@1
  int v10; // [sp+14h] [bp+Ch]@7

  v9 = 0;
  if ( *(_DWORD *)a3 == 32 )
  {
    if ( *(_DWORD *)(a3 + 4) & 0x80000000 )
      v4 = a2;
    else
      v4 = PositionFromID((int)hDC, a2);
    if ( v4 == -1 )
    {
      result = 0;
    }
    else
    {
      v10 = 0;
      v5 = *((_DWORD *)hDC + 12) + 28 * v4;
      if ( *(_BYTE *)(a3 + 4) & 8 )
      {
        v6 = *(_BYTE *)(v5 + 9) ^ *(_BYTE *)(a3 + 17);
        if ( v6 & 0x88 )
          v9 = 1;
        if ( v6 & 0x10 )
          *(_WORD *)(v5 + 10) = 0;
        *(_BYTE *)(v5 + 9) = *(_BYTE *)(a3 + 17);
        v10 = 1;
      }
      if ( *(_BYTE *)(a3 + 4) & 4 )
        TB_OnSetState(hDC, v5, *(_BYTE *)(a3 + 16), v4);
      if ( *(_BYTE *)(a3 + 4) & 1 )
        TB_OnSetImage(hDC, v5, *(_DWORD *)(a3 + 12));
      if ( *(_BYTE *)(a3 + 4) & 0x40 )
      {
        *(_WORD *)(v5 + 10) = *(_WORD *)(a3 + 18);
        v10 = 1;
        v9 = 1;
      }
      if ( *(_BYTE *)(a3 + 4) & 2 )
      {
        v7 = *(_BYTE *)(v5 + 9);
        if ( v7 & 0x10 || *((_BYTE *)hDC + 36) & 8 && *((_DWORD *)hDC + 2) & 0x1000 && !(v7 & 1) )
        {
          v9 = 1;
          *(_WORD *)(v5 + 10) = 0;
        }
        *((_DWORD *)hDC + 59) |= 8u;
        v8 = *(_DWORD *)(v5 + 16);
        if ( v8 == -1 || !(v8 & 0xFFFF0000) )
          *(_DWORD *)(v5 + 16) = 0;
        Str_Set(v5 + 16, *(LPCWSTR *)(a3 + 24));
        v10 = 1;
      }
      if ( *(_BYTE *)(a3 + 4) & 0x10 )
        *(_DWORD *)(v5 + 12) = *(_DWORD *)(a3 + 20);
      if ( *(_BYTE *)(a3 + 4) & 0x20 )
        TB_OnSetCmdID((int)hDC, v5, *(_DWORD *)(a3 + 8));
      if ( v9 || v10 )
      {
        TBInvalidateItemRects((int)hDC);
        if ( v9 )
          InvalidateRect(*(HWND *)hDC, 0, 1);
        else
          InvalidateButton(hDC, v5, 1);
      }
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F79C90F) --------------------------------------------------------
int __stdcall TB_OnSetButtonInfoA(HDC hDC, int a2, int a3)
{
  bool v3; // zf@1
  const CHAR *v4; // eax@2
  int v6; // [sp+Ch] [bp-224h]@1
  WCHAR *v7; // [sp+24h] [bp-20Ch]@3
  int v8; // [sp+28h] [bp-208h]@3
  WCHAR WideCharStr; // [sp+2Ch] [bp-204h]@3

  v3 = (*(_BYTE *)(a3 + 4) & 2) == 0;
  qmemcpy(&v6, (const void *)a3, 0x20u);
  if ( !v3 )
  {
    v4 = *(const CHAR **)(a3 + 24);
    if ( v4 )
    {
      v7 = &WideCharStr;
      v8 = 256;
      MultiByteToWideChar(0, 0, v4, -1, &WideCharStr, 256);
    }
  }
  return TB_OnSetButtonInfo(hDC, a2, (int)&v6);
}

//----- (6F79C999) --------------------------------------------------------
void __stdcall TBOnMouseMove(HDC hDC, HWND hWnd, int a3, int a4, int a5)
{
  HDC v5; // esi@1
  signed int v6; // edi@2
  int v7; // eax@5
  int v8; // eax@9
  int v9; // eax@12
  int v10; // eax@14
  unsigned __int8 v11; // cl@15
  int v12; // eax@21
  int v13; // eax@21
  struct tagTRACKMOUSEEVENT EventTrack; // [sp+4h] [bp-10h]@22
  HDC hDCa; // [sp+1Ch] [bp+8h]@2

  v5 = hDC;
  if ( !(*((_BYTE *)hDC + 236) & 0x40) )
    return;
  v6 = 0;
  hDCa = 0;
  if ( !*((_DWORD *)v5 + 13) )
    goto LABEL_20;
  if ( hWnd != GetCapture() )
  {
    SendItemNotify(v5, *(_DWORD *)(*((_DWORD *)v5 + 13) + 4), -702);
    if ( !IsWindow(hWnd) )
      return;
    v7 = *((_DWORD *)v5 + 13);
    if ( v7 && *(_BYTE *)(v7 + 8) & 2 )
      SendMessageW(hWnd, 0x403u, *(_DWORD *)(v7 + 4), 0);
    *((_DWORD *)v5 + 59) &= 0xFFFFFEFF;
    *((_DWORD *)v5 + 13) = 0;
LABEL_20:
    TBRelayToToolTips(v5, a3, a4, a5);
    if ( *((_DWORD *)v5 + 2) & 0x800 )
    {
      v12 = TBHitTest(v5, (signed __int16)a5, SHIWORD(a5));
      TBSetHotItem(v5, v12, 1);
      v13 = *((_DWORD *)v5 + 59);
      if ( !(v13 & 0xA0) )
      {
        *((_DWORD *)v5 + 59) = v13 | 0x20;
        EventTrack.cbSize = 16;
        EventTrack.dwFlags = 2;
        EventTrack.hwndTrack = hWnd;
        _TrackMouseEvent(&EventTrack);
      }
    }
    return;
  }
  v8 = TBHitTest(v5, (signed __int16)a5, SHIWORD(a5));
  if ( v8 < 0 || *((_DWORD *)v5 + 13) != *((_DWORD *)v5 + 12) + 28 * v8 )
  {
    v9 = *((_DWORD *)v5 + 59);
    if ( !(v9 & 0x200) )
    {
      *((_DWORD *)v5 + 59) = v9 | 0x200;
      hDCa = (HDC)SendItemNotify(v5, *(_DWORD *)(*((_DWORD *)v5 + 13) + 4), -714);
      if ( !IsWindow(hWnd) )
        return;
    }
  }
  else
  {
    v6 = 1;
  }
  v10 = *((_DWORD *)v5 + 13);
  if ( v10 )
  {
    v11 = *(_BYTE *)(v10 + 8);
    if ( v11 & 4 )
    {
      if ( v6 == (~(v11 >> 1) & 1) && !(*((_DWORD *)v5 + 59) & 0x100) )
      {
        *(_BYTE *)(v10 + 8) ^= 2u;
        InvalidateButton(v5, *((_DWORD *)v5 + 13), 1);
        MyNotifyWinEvent(32778, (int)hWnd, -4, (*((_DWORD *)v5 + 13) - *((_DWORD *)v5 + 12)) / 28 + 1);
      }
    }
  }
  if ( !hDCa )
    goto LABEL_20;
}

//----- (6F79CB45) --------------------------------------------------------
int __stdcall TBHandleLButtonDown(HWND hWnd, int a2, int a3)
{
  int v3; // edi@1
  int result; // eax@1
  int v5; // esi@3
  bool v6; // zf@3
  int v7; // eax@8
  char v8; // al@9
  RECT rc; // [sp+8h] [bp-18h]@4
  POINT pt; // [sp+18h] [bp-8h]@3
  int hWnda; // [sp+28h] [bp+8h]@1

  v3 = (int)hWnd;
  result = *(_DWORD *)hWnd;
  hWnda = *(_DWORD *)hWnd;
  if ( a3 >= 0 && a3 < *(_DWORD *)(v3 + 132) )
  {
    v5 = *(_DWORD *)(v3 + 48) + 28 * a3;
    v6 = (*(_BYTE *)(v5 + 9) & 0x88) == 0;
    pt.x = (unsigned __int16)a2;
    pt.y = (unsigned int)a2 >> 16;
    if ( v6
      || (TB_GetItemDropDownRect((HDC)v3, a3, (int)&rc), !(*(_BYTE *)(v5 + 9) & 0x88))
      || TB_HasSplitDDArrow(v3, v5) && !PtInRect(&rc, pt) )
    {
      *(_DWORD *)(v3 + 52) = v5;
      SetCapture((HWND)hWnda);
      v8 = *(_BYTE *)(v5 + 8);
      if ( v8 & 4 )
      {
        *(_BYTE *)(v5 + 8) = v8 | 2;
        InvalidateButton((HDC)v3, v5, 1);
        UpdateWindow((HWND)hWnda);
        MyNotifyWinEvent(32778, hWnda, -4, a3 + 1);
      }
      v7 = *(_DWORD *)(v3 + 52);
      *(_DWORD *)(v3 + 236) &= 0xFFFFFDFF;
      if ( !v7 )
        goto LABEL_13;
    }
    else
    {
      result = TBToggleDropDown((HDC)v3, a3, 1);
      if ( result )
        return result;
      *(_DWORD *)(v3 + 52) = v5;
      SetCapture((HWND)hWnda);
      *(_DWORD *)(v3 + 236) &= 0xFFFFFDFF;
      v7 = *(_DWORD *)(v3 + 52);
    }
    SendItemNotify((HDC)v3, *(_DWORD *)(v7 + 4), -701);
LABEL_13:
    result = GetMessagePosClient(*(HWND *)v3, (LPPOINT)(v3 + 56));
  }
  return result;
}

//----- (6F79CC59) --------------------------------------------------------
HWND __stdcall TBOnLButtonDown(HDC hDC, int a2, int a3, int a4, int a5)
{
  HDC v5; // esi@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // eax@10
  LPARAM lParam; // [sp+Ch] [bp-20h]@1
  char v11; // [sp+10h] [bp-1Ch]@1
  int v12; // [sp+18h] [bp-14h]@10
  int v13; // [sp+1Ch] [bp-10h]@10
  int v14; // [sp+20h] [bp-Ch]@12
  int v15; // [sp+24h] [bp-8h]@12
  unsigned int hDCa; // [sp+34h] [bp+8h]@1

  lParam = 0;
  v5 = hDC;
  *((_DWORD *)v5 + 59) &= 0xFFFFBFFF;
  memset(&v11, 0, 0x1Cu);
  TBRelayToToolTips(hDC, a3, a4, a5);
  hDCa = (unsigned int)a5 >> 16;
  v6 = TBHitTest(v5, (signed __int16)a5, SHIWORD(a5));
  v7 = *((_DWORD *)v5 + 2);
  if ( v7 & 0x20 && (a4 & 4 && !(v7 & 0x400) || GetKeyState(18) & 0xFFFE && *((_DWORD *)v5 + 2) & 0x400) )
    MoveButton(v5, v6);
  else
    TBHandleLButtonDown((HWND)v5, a5, v6);
  if ( v6 < 0 || v6 >= *((_DWORD *)v5 + 33) )
  {
    v12 = -1;
  }
  else
  {
    v8 = 28 * v6 + *((_DWORD *)v5 + 12);
    v12 = *(_DWORD *)(v8 + 4);
    v13 = *(_DWORD *)(v8 + 12);
  }
  v14 = (unsigned __int16)a5;
  v15 = (unsigned __int16)hDCa;
  return CCSendNotify((int)v5, -20, (LPARAM)&lParam);
}

//----- (6F79CD2F) --------------------------------------------------------
int __stdcall TBOnLButtonUp(HDC hDC, HWND hWnd, int a3, int a4, int a5)
{
  int v5; // edi@1
  int v6; // ebx@1
  int v7; // eax@6
  int v8; // edi@7
  int result; // eax@7
  char v10; // cl@13
  int v11; // eax@22
  LPARAM lParam; // [sp+Ch] [bp-20h]@1
  char v13; // [sp+10h] [bp-1Ch]@1
  int v14; // [sp+18h] [bp-14h]@22
  int v15; // [sp+1Ch] [bp-10h]@22
  int v16; // [sp+20h] [bp-Ch]@25
  unsigned int v17; // [sp+24h] [bp-8h]@25
  int v18; // [sp+40h] [bp+14h]@7

  lParam = 0;
  memset(&v13, 0, 0x1Cu);
  v5 = a5;
  v6 = -1;
  TBRelayToToolTips(hDC, a3, a4, a5);
  if ( a5 != -1 )
    v6 = TBHitTest(hDC, (signed __int16)a5, SHIWORD(a5));
  if ( *((_DWORD *)hDC + 59) & 0x4000 && v6 >= 0 )
    *((_DWORD *)hDC + 13) = *((_DWORD *)hDC + 12) + 28 * v6;
  v7 = *((_DWORD *)hDC + 13);
  if ( v7 )
  {
    v8 = *(_DWORD *)(v7 + 4);
    v18 = *(_DWORD *)(v7 + 4);
    result = CCReleaseCapture((int)hDC);
    if ( !result )
      return result;
    SendItemNotify(hDC, v8, -702);
    result = IsWindow(hWnd);
    if ( !result )
      return result;
    result = *((_DWORD *)hDC + 13);
    if ( result && *(_BYTE *)(result + 8) & 4 && v6 >= 0 && result == *((_DWORD *)hDC + 12) + 28 * v6 )
    {
      *(_BYTE *)(result + 8) &= 0xFDu;
      result = *((_DWORD *)hDC + 13);
      v10 = *(_BYTE *)(result + 9);
      if ( !(v10 & 2) )
      {
LABEL_18:
        InvalidateButton(hDC, *((_DWORD *)hDC + 13), 1);
        *((_DWORD *)hDC + 13) = 0;
        MyNotifyWinEvent(32778, (int)hWnd, -4, v6 + 1);
        SendMessageW(*((HWND *)hDC + 1), 0x111u, (unsigned __int16)v18, (LPARAM)hWnd);
        result = IsWindow(hWnd);
        if ( !result )
          return result;
        v5 = a5;
        goto LABEL_20;
      }
      if ( !(v10 & 4) )
      {
        *(_BYTE *)(result + 8) ^= 1u;
        goto LABEL_18;
      }
      if ( !(*(_BYTE *)(result + 8) & 1) )
      {
        *(_BYTE *)(result + 8) |= 1u;
        MakeGroupConsistant(hDC, v18);
        goto LABEL_18;
      }
    }
    *((_DWORD *)hDC + 13) = 0;
    return result;
  }
LABEL_20:
  if ( v6 < 0 || v6 >= *((_DWORD *)hDC + 33) )
  {
    v14 = -1;
  }
  else
  {
    v11 = 28 * v6 + *((_DWORD *)hDC + 12);
    v14 = *(_DWORD *)(v11 + 4);
    v15 = *(_DWORD *)(v11 + 12);
  }
  v16 = (unsigned __int16)v5;
  v17 = (unsigned int)v5 >> 16;
  return (int)CCSendNotify((int)hDC, -2, (LPARAM)&lParam);
}

//----- (6F79CEC0) --------------------------------------------------------
int __stdcall TBGenerateDragImage(HDC hDC, HGDIOBJ h)
{
  HDC v2; // esi@1
  int result; // eax@2
  HDC v4; // eax@3
  int v5; // ebx@3
  HGDIOBJ v6; // edi@6
  int v7; // ST10_4@6
  int v8; // eax@6
  HBITMAP v9; // eax@6
  LONG v10; // ecx@7
  int v11; // eax@7
  LONG v12; // eax@9
  LPARAM lParam; // [sp+8h] [bp-7Ch]@1
  char Dst; // [sp+Ch] [bp-78h]@1
  int v15; // [sp+18h] [bp-6Ch]@6
  RECT rc; // [sp+74h] [bp-10h]@7
  HDC hDCa; // [sp+8Ch] [bp+8h]@7
  HGDIOBJ ha; // [sp+90h] [bp+Ch]@7

  lParam = 0;
  memset(&Dst, 0, 0x68u);
  v2 = hDC;
  if ( *((_DWORD *)hDC + 51) == -1 )
  {
    result = 0;
  }
  else
  {
    v4 = CreateCompatibleDC(0);
    v5 = (int)v4;
    if ( !v4 )
      goto LABEL_16;
    if ( *((_DWORD *)hDC + 6) & 0x400000 )
      SetLayout(v4, 1u);
    v15 = v5;
    *((_DWORD *)hDC + 3) = CICustomDrawNotify((int)hDC, 1, (LPARAM)&lParam);
    v6 = h;
    *(_DWORD *)h = TBWidthOfButton(v5, hDC, *((_DWORD *)hDC + 12) + 28 * *((_DWORD *)hDC + 51), (HDC)v5);
    *((_DWORD *)h + 1) = *((_DWORD *)hDC + 29);
    v7 = GetDeviceCaps((HDC)v5, 12);
    v8 = GetDeviceCaps((HDC)v5, 14);
    v9 = CreateBitmap(*(_DWORD *)v6, *((_DWORD *)v6 + 1), v8, v7, 0);
    *((_DWORD *)h + 4) = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)h;
      rc.left = 0;
      rc.top = 0;
      rc.right = v10;
      rc.bottom = *((_DWORD *)h + 1);
      ha = SelectObject((HDC)v5, v9);
      *((_DWORD *)v6 + 5) = 5570815;
      FillRectClr((HDC)v5, &rc, 0x5500FFu);
      hDCa = (HDC)*((_DWORD *)hDC + 2);
      v11 = *((_DWORD *)v2 + 2);
      *((_DWORD *)v2 + 59) &= 0xFFFDFFFF;
      *((_DWORD *)v2 + 2) = v11 | 0x8000;
      DrawButton(v5, (HDC)v5, 0, 0, v2, *((_DWORD *)v2 + 12) + 28 * *((_DWORD *)v2 + 51), 1);
      *((_DWORD *)v2 + 59) |= 0x20000u;
      *((_DWORD *)v2 + 2) = hDCa;
      TB_GetItemRect(v2, *((_DWORD *)v2 + 51), (int)&rc);
      if ( PtInRect(&rc, *((POINT *)v2 + 7)) )
      {
        if ( *((_DWORD *)v2 + 6) & 0x400000 )
          v12 = rc.right - *((_DWORD *)v2 + 14);
        else
          v12 = *((_DWORD *)v2 + 14) - rc.left;
        *((_DWORD *)v6 + 2) = v12;
        *((_DWORD *)v6 + 3) = *((_DWORD *)v2 + 15) - rc.top;
      }
      SelectObject((HDC)v5, ha);
      DeleteDC((HDC)v5);
      result = 1;
    }
    else
    {
LABEL_16:
      result = 0;
    }
  }
  return result;
}

//----- (6F79D050) --------------------------------------------------------
HWND __stdcall isgoodbuddy(int a1)
{
  HWND result; // eax@1

  result = *(HWND *)(a1 + 36);
  if ( result )
  {
    if ( !IsWindow(*(HWND *)(a1 + 36)) )
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 60) = 0;
    }
    result = GetParent(*(HWND *)(a1 + 36));
    if ( result != *(HWND *)(a1 + 4) )
    {
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 60) = 0;
    }
  }
  return result;
}

//----- (6F79D091) --------------------------------------------------------
void __stdcall pickbuddy(int a1)
{
  if ( *(_BYTE *)(a1 + 8) & 0x10 )
    *(_DWORD *)(a1 + 36) = GetWindow(*(HWND *)a1, 3u);
}

//----- (6F79D0B7) --------------------------------------------------------
BOOL __stdcall unachor(int a1)
{
  BOOL result; // eax@1
  RECT rcSrc1; // [sp+4h] [bp-30h]@3
  struct tagRECT Rect; // [sp+14h] [bp-20h]@3
  struct tagRECT rcDst; // [sp+24h] [bp-10h]@3

  result = *(_DWORD *)(a1 + 36);
  if ( result )
  {
    if ( *(_BYTE *)(a1 + 8) & 0xC )
    {
      GetWindowRect((HWND)result, &Rect);
      GetWindowRect(*(HWND *)a1, &rcSrc1);
      UnionRect(&rcDst, &rcSrc1, &Rect);
      MapWindowPoints(0, *(HWND *)(a1 + 4), (LPPOINT)&rcDst, 2u);
      result = MoveWindow(
                 *(HWND *)(a1 + 36),
                 rcDst.left,
                 rcDst.top,
                 rcDst.right - rcDst.left,
                 rcDst.bottom - rcDst.top,
                 0);
    }
  }
  return result;
}

//----- (6F79D133) --------------------------------------------------------
BOOL __stdcall anchor(int a1)
{
  int v1; // ebx@1
  HWND v2; // ecx@1
  int v3; // esi@1
  int v4; // eax@8
  int v5; // ecx@8
  LONG v6; // ST18_4@8
  HWND v7; // ST10_4@8
  LONG v8; // eax@8
  int v9; // edi@10
  HWND v10; // ST14_4@10
  int v11; // edx@12
  int v12; // eax@13
  int v13; // eax@15
  int v14; // ecx@16
  LONG v15; // edx@16
  LONG v16; // eax@16
  LONG v17; // ecx@17
  LONG v19; // [sp+Ch] [bp-28h]@15
  struct tagRECT Rect; // [sp+1Ch] [bp-18h]@6
  int nHeight; // [sp+2Ch] [bp-8h]@10
  int v22; // [sp+30h] [bp-4h]@1
  int v23; // [sp+3Ch] [bp+8h]@3
  int v24; // [sp+3Ch] [bp+8h]@15

  v22 = 0;
  v1 = a1;
  *(_DWORD *)(v1 + 40) &= 0xFFFFFFF7;
  isgoodbuddy(a1);
  v2 = *(HWND *)(a1 + 36);
  v3 = (*(_DWORD *)(a1 + 8) & 0x800000) == 0x800000;
  if ( v2 && *(_DWORD *)(a1 + 8) & 0xC )
  {
    v23 = 1;
    if ( *(_DWORD *)(v1 + 60) == 1 || GetWindowLongW(v2, -20) & 0x200 )
      *(_DWORD *)(v1 + 40) |= 0x10u;
    GetWindowRect(*(HWND *)(v1 + 36), &Rect);
    if ( *(_DWORD *)(v1 + 60) == 1 || GetWindowLongW(*(HWND *)(v1 + 36), -16) & 0x800000 )
    {
      v4 = *(_DWORD *)(v1 + 40);
      v5 = g_cxBorder * (((v4 & 0x10) != 0) + 1);
      *(_DWORD *)(v1 + 8) &= 0xFF7FFFFF;
      v6 = *(_DWORD *)(v1 + 8);
      v22 = v5;
      v7 = *(HWND *)v1;
      *(_DWORD *)(v1 + 40) = v4 | 8;
      SetWindowLongW(v7, -16, v6);
      v8 = GetWindowLongW(*(HWND *)v1, -20);
      SetWindowLongW(*(HWND *)v1, -20, v8 & 0xFFFFFDFF);
    }
  }
  else
  {
    v23 = 0;
    GetWindowRect(*(HWND *)v1, &Rect);
  }
  v9 = Rect.right - Rect.left;
  v10 = *(HWND *)(v1 + 4);
  nHeight = Rect.bottom - Rect.top;
  if ( GetWindowLongW(v10, -20) & 0x400000 )
    Rect.left = Rect.right;
  ScreenToClient(*(HWND *)(v1 + 4), (LPPOINT)&Rect);
  v11 = Rect.left;
  Rect.right = Rect.left + v9;
  if ( v23 )
  {
    v12 = g_cxVScroll - g_cxBorder;
    if ( g_cxVScroll - g_cxBorder > nHeight )
      v12 = nHeight;
    v13 = v22 + v12;
    v19 = Rect.left;
    v24 = v13;
    if ( *(_BYTE *)(v1 + 8) & 8 )
    {
      v14 = v13 + Rect.left - v22;
      v15 = v13 + Rect.left;
      v16 = Rect.right;
      Rect.right = v15;
    }
    else
    {
      v17 = Rect.left + v9 - v13;
      v16 = v17 + v22;
      Rect.left = v17;
      v14 = v19;
    }
    MoveWindow(*(HWND *)(v1 + 36), v14, Rect.top, v16 - v14, nHeight, 1);
    v11 = Rect.left;
    v9 = v24;
  }
  else if ( !(*(_BYTE *)(v1 + 8) & 0x40) )
  {
    v9 = g_cxVScroll + 2 * v3;
  }
  return SetWindowPos(*(HWND *)v1, 0, v11, Rect.top, v9, nHeight, 0x34u);
}
// 6F7E69A8: using guessed type int g_cxVScroll;

//----- (6F79D2E8) --------------------------------------------------------
signed int __stdcall compare(int a1, unsigned int a2, unsigned int a3, int a4)
{
  signed int result; // eax@1

  result = 1;
  if ( a4 == 2 || *(_BYTE *)(a1 + 40) & 4 && a4 != 1 )
  {
    if ( a2 > a3 )
      return result;
    if ( a2 >= a3 )
      return 0;
  }
  else
  {
    if ( (signed int)a2 > (signed int)a3 )
      return result;
    if ( (signed int)a2 >= (signed int)a3 )
      return 0;
  }
  return -1;
}

//----- (6F79D328) --------------------------------------------------------
signed int __stdcall nudge(int a1)
{
  unsigned int v1; // esi@1
  unsigned int v2; // edi@1
  int v3; // edx@1
  unsigned int v4; // eax@2
  unsigned int v5; // ebx@3
  int v6; // edx@4
  int v7; // edx@5
  unsigned int v9; // [sp-Ch] [bp-1Ch]@3
  signed int v10; // [sp+Ch] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 48);
  v2 = *(_DWORD *)(a1 + 52);
  v10 = 1;
  if ( compare(a1, *(_DWORD *)(a1 + 52), *(_DWORD *)(a1 + 48), 0) < 0 )
  {
    v4 = v1;
    v1 = v2;
    v2 = v4;
  }
  v5 = *(_DWORD *)(v3 + 56);
  v9 = *(_DWORD *)(v3 + 56);
  if ( !(*(_BYTE *)(v3 + 8) & 1) )
  {
    if ( compare(v3, v9, v1, 0) < 0 )
      goto LABEL_9;
    if ( compare(v7, v5, v2, 0) <= 0 )
      return 0;
LABEL_11:
    *(_DWORD *)(v6 + 56) = v2;
    return v10;
  }
  if ( compare(v3, v9, v1, 0) < 0 )
    goto LABEL_11;
  if ( compare(v6, v5, v2, 0) > 0 )
  {
LABEL_9:
    *(_DWORD *)(v7 + 56) = v1;
    return v10;
  }
  return 0;
}

//----- (6F79D3AC) --------------------------------------------------------
int __stdcall squish(int a1, int a2, int a3)
{
  int v3; // ecx@3
  int v4; // eax@5
  HWND v5; // ST04_4@6
  int result; // eax@7
  HWND v7; // ST04_4@8
  DWORD v8; // eax@10
  HWND v9; // ST08_4@10
  signed int v10; // [sp+8h] [bp-4h]@1
  int v11; // [sp+1Ch] [bp+10h]@3

  v10 = 0;
  if ( *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 52) && IsWindowEnabled(*(HWND *)a1) )
  {
    v3 = a2 != 0;
    v11 = a3 != 0;
  }
  else
  {
    v3 = 0;
    v11 = 0;
  }
  v4 = *(_DWORD *)(a1 + 40);
  if ( (v4 & 1) != v3 )
  {
    v5 = *(HWND *)a1;
    *(_DWORD *)(a1 + 40) = v4 ^ (v3 ^ v4) & 1;
    v10 = 1;
    MyNotifyWinEvent(32778, (int)v5, -4, 1);
  }
  result = *(_DWORD *)(a1 + 40);
  if ( ((*(_DWORD *)(a1 + 40) >> 1) & 1) != v11 )
  {
    v7 = *(HWND *)a1;
    *(_DWORD *)(a1 + 40) = result ^ ((unsigned __int8)result ^ (unsigned __int8)(2 * v11)) & 2;
    v10 = 1;
    result = MyNotifyWinEvent(32778, (int)v7, -4, 2);
  }
  if ( v10 )
  {
    v8 = GetTickCount();
    v9 = *(HWND *)a1;
    *(_DWORD *)(a1 + 68) = v8;
    result = InvalidateRect(v9, 0, 0);
  }
  return result;
}

//----- (6F79D468) --------------------------------------------------------
int __stdcall getthousands(LPWSTR lpLCData)
{
  int result; // eax@1

  result = GetLocaleInfoW(0x400u, 0xFu, lpLCData, 2);
  if ( !result )
  {
    *lpLCData = 44;
    result = 0;
    lpLCData[1] = 0;
  }
  return result;
}

//----- (6F79D49B) --------------------------------------------------------
int __stdcall getgrouping()
{
  int result; // eax@2
  WCHAR *v1; // edx@3
  WCHAR v2; // cx@4
  WCHAR LCData; // [sp+0h] [bp-44h]@1

  if ( !GetLocaleInfoW(0x400u, 0x10u, &LCData, 32) )
    return 3;
  result = 0;
  v1 = &LCData;
  if ( LCData != 48 )
  {
    v2 = LCData;
    do
    {
      if ( (unsigned int)v2 - 48 >= 0xA )
      {
        if ( !v2 )
        {
          result *= 10;
          return result;
        }
      }
      else
      {
        result = 10 * result + v2 - 48;
      }
      ++v1;
      v2 = *v1;
    }
    while ( *v1 != 48 );
  }
  return result;
}

//----- (6F79D517) --------------------------------------------------------
int __stdcall getint(int a1, int a2)
{
  signed int v2; // ebx@1
  WCHAR *v3; // esi@1
  HWND v4; // eax@1
  int v5; // ecx@9
  unsigned __int16 v6; // ax@11
  WCHAR v7; // ax@14
  int v8; // ecx@15
  unsigned __int16 v9; // ax@26
  WCHAR v10; // ax@34
  WCHAR LCData; // [sp+10h] [bp-30h]@6
  int v13; // [sp+14h] [bp-2Ch]@1
  WCHAR String; // [sp+18h] [bp-28h]@1
  __int16 v15; // [sp+1Ah] [bp-26h]@8
  char v16; // [sp+1Ch] [bp-24h]@21

  v2 = 1;
  v3 = &String;
  v13 = 1;
  isgoodbuddy(a1);
  v4 = *(HWND *)(a1 + 36);
  if ( v4 && *(_BYTE *)(a1 + 8) & 2 )
  {
    if ( *(_DWORD *)(a1 + 60) == 2 )
    {
      *(_DWORD *)(a1 + 56) = SendMessageW(v4, 0x188u, 0, 0);
    }
    else
    {
      GetWindowTextW(v4, &String, 18);
      if ( *(_DWORD *)(a1 + 44) == 16 )
      {
        if ( String == 120 || String == 88 )
        {
          v3 = (WCHAR *)&v15;
        }
        else if ( String == 48 && (v15 == 120 || v15 == 88) )
        {
          v3 = (WCHAR *)&v16;
        }
        v8 = 0;
        while ( 1 )
        {
          v10 = *v3;
          if ( !*v3 )
            break;
          if ( v10 < 0x41u || v10 > 0x46u )
          {
            if ( v10 < 0x61u || v10 > 0x66u )
            {
              if ( v10 < 0x30u || v10 > 0x39u )
                goto LABEL_37;
              v9 = v10 - 48;
            }
            else
            {
              v9 = v10 - 87;
            }
          }
          else
          {
            v9 = v10 - 55;
          }
          v8 = v9 + 16 * v8;
          ++v3;
        }
      }
      else
      {
        getthousands(&LCData);
        if ( String == 45 && !(*(_BYTE *)(a1 + 40) & 4) )
        {
          v2 = -1;
          v3 = (WCHAR *)&v15;
        }
        v5 = 0;
        while ( 1 )
        {
          v7 = *v3;
          if ( !*v3 )
            break;
          if ( v7 != LCData )
          {
            v6 = v7 - 48;
            if ( v6 > 9u )
              goto LABEL_37;
            v5 = v6 + 10 * v5;
          }
          ++v3;
        }
        v8 = v2 * v5;
      }
      *(_DWORD *)(a1 + 56) = v8;
    }
    v13 = nudge(a1);
  }
LABEL_37:
  if ( a2 )
    *(_DWORD *)a2 = v13;
  return *(_DWORD *)(a1 + 56);
}

//----- (6F79D67F) --------------------------------------------------------
BOOL __stdcall PaintUpDownControl(int a1, HDC a2)
{
  int v2; // eax@13
  bool v3; // zf@16
  UINT v4; // ecx@17
  BOOL (__stdcall *v5)(HDC, LPRECT, UINT, UINT); // esi@24
  UINT v6; // ecx@24
  LONG v7; // edx@31
  UINT v8; // ecx@32
  LONG v9; // edx@46
  BOOL result; // eax@47
  struct tagRECT Rect; // [sp+10h] [bp-68h]@13
  struct tagRECT v12; // [sp+20h] [bp-58h]@16
  int v13; // [sp+30h] [bp-48h]@3
  struct tagPAINTSTRUCT Paint; // [sp+34h] [bp-44h]@11

  v13 = *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 52) && IsWindowEnabled(*(HWND *)a1);
  if ( *(_DWORD *)(a1 + 36) )
    v13 = v13 && IsWindowEnabled(*(HWND *)(a1 + 36));
  if ( a2 )
    Paint.hdc = a2;
  else
    BeginPaint(*(HWND *)a1, &Paint);
  GetClientRect(*(HWND *)a1, &Rect);
  v2 = *(_DWORD *)(a1 + 40);
  if ( v2 & 8 && v2 & 0x10 )
    DrawEdge(Paint.hdc, &Rect, 0xAu, *(_DWORD *)(a1 + 8) & 4 | ((*(_DWORD *)(a1 + 8) & 8 | 0x10050u) >> 3));
  v3 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
  v12 = Rect;
  if ( v3 )
  {
    v8 = 0;
    if ( *(_BYTE *)(a1 + 40) & 1 )
      v8 = 512;
    if ( !v13 )
      v8 |= 0x100u;
    if ( g_bRunOnNT5 && *(_DWORD *)(a1 + 100) == 2 )
      v8 |= 0x1000u;
    v5 = DrawFrameControl;
    v12.bottom = (Rect.top + Rect.bottom) / 2;
    DrawFrameControl(Paint.hdc, &v12, 3u, v8);
    v6 = 1;
    if ( *(_BYTE *)(a1 + 40) & 2 )
      v6 = 513;
    if ( !v13 )
      v6 |= 0x100u;
    if ( g_bRunOnNT5 && *(_DWORD *)(a1 + 100) == 1 )
      v6 |= 0x1000u;
    v9 = Rect.bottom - v12.bottom;
    v12.bottom = Rect.bottom;
    v12.top += v9;
  }
  else
  {
    v4 = 2;
    if ( *(_BYTE *)(a1 + 40) & 2 )
      v4 = 514;
    if ( !v13 )
      v4 |= 0x100u;
    if ( g_bRunOnNT5 && *(_DWORD *)(a1 + 100) == 1 )
      v4 |= 0x1000u;
    v5 = DrawFrameControl;
    v12.right = (Rect.right + Rect.left) / 2;
    DrawFrameControl(Paint.hdc, &v12, 3u, v4);
    v6 = 3;
    if ( *(_BYTE *)(a1 + 40) & 1 )
      v6 = 515;
    if ( !v13 )
      v6 |= 0x100u;
    if ( g_bRunOnNT5 && *(_DWORD *)(a1 + 100) == 2 )
      v6 |= 0x1000u;
    v7 = Rect.right - v12.right;
    v12.right = Rect.right;
    v12.left += v7;
  }
  result = v5(Paint.hdc, &v12, 3u, v6);
  if ( !a2 )
    result = EndPaint(*(HWND *)a1, &Paint);
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F79D894) --------------------------------------------------------
HWND __stdcall CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy, HWND hParent, int nID, HINSTANCE hInst, HWND hBuddy, int nUpper, int nLower, int nPos)
{
  HWND v12; // eax@1
  HWND v13; // ebx@1

  v12 = CreateWindowExW(0, L"msctls_updown32", 0, dwStyle, x, y, cx, cy, hParent, (HMENU)nID, hInst, 0);
  v13 = v12;
  if ( v12 )
  {
    SendMessageW(v12, 0x469u, (WPARAM)hBuddy, 0);
    SendMessageW(v13, 0x465u, 0, (unsigned __int16)nUpper | ((unsigned __int16)nLower << 16));
    SendMessageW(v13, 0x467u, 0, (unsigned __int16)nPos);
  }
  return v13;
}

//----- (6F79D90F) --------------------------------------------------------
signed int __stdcall UD_HitTest(int a1, LONG a2, LONG a3)
{
  struct tagRECT Rect; // [sp+4h] [bp-10h]@1

  GetClientRect(*(HWND *)a1, &Rect);
  if ( *(_BYTE *)(a1 + 8) & 0x40 )
  {
    if ( a2 < Rect.right / 2 )
      return 1;
    if ( a2 > Rect.right / 2 )
      return 2;
  }
  else
  {
    if ( a3 > Rect.bottom / 2 )
      return 1;
    if ( a3 < Rect.bottom / 2 )
      return 2;
  }
  return 0;
}

//----- (6F79D961) --------------------------------------------------------
LONG __stdcall UD_Invalidate(int a1, int a2, BOOL bErase)
{
  LONG result; // eax@2
  struct tagRECT Rect; // [sp+4h] [bp-10h]@1

  GetClientRect(*(HWND *)a1, &Rect);
  if ( *(_BYTE *)(a1 + 8) & 0x40 )
  {
    result = Rect.right / 2;
    if ( a2 == 1 )
    {
      Rect.right /= 2;
    }
    else
    {
      if ( a2 != 2 )
        return result;
      Rect.left = Rect.right / 2;
    }
  }
  else
  {
    result = Rect.bottom / 2;
    if ( a2 == 1 )
    {
      Rect.top = Rect.bottom / 2;
    }
    else
    {
      if ( a2 != 2 )
        return result;
      Rect.bottom /= 2;
    }
  }
  return InvalidateRect(*(HWND *)a1, &Rect, bErase);
}

//----- (6F79D9D2) --------------------------------------------------------
void __stdcall UD_OnMouseMove(int a1, int a2)
{
  int v2; // edi@2
  int v3; // eax@2

  if ( *(_DWORD *)(a1 + 8) & 0x100 )
  {
    v2 = UD_HitTest(a1, (signed __int16)a2, SHIWORD(a2));
    v3 = *(_DWORD *)(a1 + 100);
    if ( v2 != v3 )
    {
      UD_Invalidate(a1, v3, 0);
      UD_Invalidate(a1, v2, 0);
      *(_DWORD *)(a1 + 100) = v2;
    }
  }
}

//----- (6F79DA21) --------------------------------------------------------
LRESULT __stdcall setint(int a1)
{
  WPARAM v1; // edi@1
  LRESULT result; // eax@1
  bool v3; // zf@6
  LPARAM v4; // ST14_4@7
  int v5; // ST10_4@7
  HWND v6; // eax@7
  WCHAR *v7; // ebx@9
  const wchar_t *v8; // [sp-8h] [bp-80h]@17
  NUMBERFMTW Format; // [sp+Ch] [bp-6Ch]@14
  int v10; // [sp+24h] [bp-54h]@4
  WCHAR LCData; // [sp+28h] [bp-50h]@14
  wchar_t pszDest; // [sp+2Ch] [bp-4Ch]@14
  WCHAR NumberStr; // [sp+50h] [bp-28h]@9
  char v14; // [sp+52h] [bp-26h]@11

  v1 = *(_DWORD *)(a1 + 56);
  result = (LRESULT)isgoodbuddy(a1);
  if ( *(_DWORD *)(a1 + 36) )
  {
    if ( *(_BYTE *)(a1 + 8) & 2 )
    {
      if ( !*(_DWORD *)(a1 + 104) || (result = getint(a1, (int)&v10), v1 != result) || v10 )
      {
        ++*(_DWORD *)(a1 + 104);
        v3 = *(_DWORD *)(a1 + 60) == 2;
        *(_DWORD *)(a1 + 56) = v1;
        if ( v3 )
        {
          SendMessageW(*(HWND *)(a1 + 36), 0x186u, v1, 0);
          v4 = *(_DWORD *)(a1 + 36);
          v5 = (unsigned __int16)GetDlgCtrlID(*(HWND *)(a1 + 36)) | 0x10000;
          v6 = GetParent(*(HWND *)(a1 + 36));
          result = SendMessageW(v6, 0x111u, v5, v4);
        }
        else
        {
          if ( *(_DWORD *)(a1 + 44) == 16 )
          {
            if ( (*(_DWORD *)(a1 + 48) | *(_DWORD *)(a1 + 52)) < 0x10000 )
              v8 = L"0x%04X";
            else
              v8 = L"0x%08X";
            StringCchPrintfW(&NumberStr, 0x12u, v8, v1);
          }
          else
          {
            v7 = &NumberStr;
            if ( (v1 & 0x80000000) != 0 && !(*(_BYTE *)(a1 + 40) & 4) )
            {
              NumberStr = 45;
              v7 = (WCHAR *)&v14;
              v1 = -v1;
            }
            if ( (signed int)v1 < 1000 || *(_BYTE *)(a1 + 8) & 0x80 )
            {
              StringCchPrintfW(v7, 18 - (v7 != &NumberStr), L"%u", v1);
            }
            else
            {
              Format.NumDigits = 0;
              Format.LeadingZero = 0;
              Format.NegativeOrder = 0;
              Format.Grouping = getgrouping();
              Format.lpDecimalSep = (LPWSTR)&WindowName;
              Format.lpThousandSep = &LCData;
              getthousands(&LCData);
              StringCchPrintfW(&pszDest, 0x12u, L"%u", v1);
              GetNumberFormatW(0x400u, 0, &pszDest, &Format, v7, 18 - (v7 != &NumberStr));
            }
          }
          result = SetWindowTextW(*(HWND *)(a1 + 36), &NumberStr);
        }
      }
    }
  }
  return result;
}
// 6F79DBC0: using guessed type wchar_t a0x08x[7];

//----- (6F79DBDB) --------------------------------------------------------
unsigned int __stdcall bump(int a1)
{
  DWORD v1; // eax@1
  signed int v2; // edi@1
  unsigned int result; // eax@1
  int v4; // ecx@1
  int v5; // edx@2
  bool v6; // sf@8
  int v7; // ebx@8
  int v8; // ebx@8
  int v9; // [sp-Ch] [bp-2Ch]@17
  LPARAM v10; // [sp-8h] [bp-28h]@17
  LPARAM lParam; // [sp+8h] [bp-18h]@13
  int v12; // [sp+14h] [bp-Ch]@13
  int v13; // [sp+18h] [bp-8h]@13
  int v14; // [sp+1Ch] [bp-4h]@1

  v14 = 0;
  v1 = GetTickCount();
  v2 = *(_DWORD *)(a1 + 80);
  result = (v1 - *(_DWORD *)(a1 + 68)) >> 10;
  v4 = *(_DWORD *)(a1 + 72) - 1;
  if ( v4 >= 0 )
  {
    v5 = a1 + 8 * v4 + 76;
    while ( *(_DWORD *)v5 > result )
    {
      --v4;
      v5 -= 8;
      if ( v4 < 0 )
        goto LABEL_7;
    }
    v2 = *(_DWORD *)(a1 + 8 * v4 + 80);
  }
LABEL_7:
  if ( v2 )
  {
    v6 = compare(a1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), 0) < 0;
    result = *(_DWORD *)(a1 + 40);
    v7 = v6;
    LOBYTE(v7) = !v6;
    v8 = 2 * v7 - 1;
    if ( result & 1 )
      v14 = 1;
    if ( result & 2 )
    {
      v8 = -v8;
      v14 = 1;
    }
    if ( v14 )
    {
      v12 = *(_DWORD *)(a1 + 56);
      v13 = v2 * v8;
      result = (unsigned int)CCSendNotify(a1, -722, (LPARAM)&lParam);
      if ( !result )
      {
        for ( *(_DWORD *)(a1 + 56) += v13; *(_DWORD *)(a1 + 56) % v2; *(_DWORD *)(a1 + 56) += v8 )
          ;
        nudge(a1);
        setint(a1);
        v10 = *(_DWORD *)a1;
        v9 = (*(_WORD *)(a1 + 56) << 16) | 4;
        if ( *(_BYTE *)(a1 + 8) & 0x40 )
          SendMessageW(*(HWND *)(a1 + 4), 0x114u, v9, v10);
        else
          SendMessageW(*(HWND *)(a1 + 4), 0x115u, v9, v10);
        result = MyNotifyWinEvent(32782, *(_DWORD *)a1, -4, 0);
      }
    }
  }
  return result;
}

//----- (6F79DCDB) --------------------------------------------------------
signed int __stdcall ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  int v6; // esi@9
  int v7; // esi@11
  int v9; // ecx@28

  if ( uMsg != 7 )
  {
    if ( uMsg == 8 )
    {
      gcWheelDelta = 0;
    }
    else if ( uMsg == 130 )
    {
      RemoveWindowSubclass(hWnd, ArrowKeyProc, 0);
      *(_DWORD *)(dwRefData + 40) &= 0xFFFFFF7F;
      v9 = *(_DWORD *)(dwRefData + 40);
      *(_DWORD *)(dwRefData + 36) = 0;
      if ( v9 & 0x20 )
        LocalFree((HLOCAL)dwRefData);
    }
    else
    {
      if ( uMsg == 135 )
        return DefSubclassProc(hWnd, 0x87u, wParam, lParam) | 1;
      if ( uMsg == 256 )
      {
        if ( wParam == 38 || wParam == 40 )
        {
          if ( GetCapture() != *(HWND *)dwRefData )
          {
            if ( !(lParam & 0x40000000) )
              getint(dwRefData, 0);
            *(_DWORD *)(dwRefData + 64) = wParam == 40;
            squish(dwRefData, wParam != 40, wParam == 40);
            bump(dwRefData);
            CCNotifyNavigationKeyUsage(dwRefData, 1u);
          }
          return 0;
        }
      }
      else
      {
        if ( uMsg != 257 )
        {
          if ( uMsg == g_msgMSWheel && GetCapture() != *(HWND *)dwRefData )
          {
            gcWheelDelta -= SHIWORD(wParam);
            v6 = gcWheelDelta / 120;
            if ( !(gcWheelDelta / 120) )
              return 1;
            gcWheelDelta %= 120;
            if ( !(wParam & 0xC) )
            {
              getint(dwRefData, 0);
              *(_DWORD *)(dwRefData + 64) = v6 > 0;
              v7 = abs(v6);
              while ( v7 > 0 )
              {
                --v7;
                squish(dwRefData, *(_DWORD *)(dwRefData + 64) == 0, *(_DWORD *)(dwRefData + 64));
                bump(dwRefData);
              }
              squish(dwRefData, 0, 0);
              return 1;
            }
          }
          return DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }
        if ( wParam == 38 || wParam == 40 )
        {
          if ( GetCapture() != *(HWND *)dwRefData )
            squish(dwRefData, 0, 0);
          return 0;
        }
      }
    }
  }
  return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}
// 6F7E6930: using guessed type int g_msgMSWheel;
// 6F7E8E5C: using guessed type int gcWheelDelta;

//----- (6F79DE9B) --------------------------------------------------------
int __stdcall setbase(int a1, int a2)
{
  int result; // eax@3
  int v3; // esi@4

  if ( a2 == 10 || a2 == 16 )
  {
    v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = a2;
    *(_DWORD *)(a1 + 40) ^= (*(_DWORD *)(a1 + 40) ^ 4 * (a2 != 10)) & 4;
    setint(a1);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F79DEE1) --------------------------------------------------------
HWND __stdcall setbuddy(DWORD_PTR dwRefData, HWND a2)
{
  HWND v2; // edi@1
  HWND hWnd; // [sp+Ch] [bp-1Ch]@1
  WCHAR ClassName; // [sp+10h] [bp-18h]@9

  v2 = a2;
  hWnd = *(HWND *)(dwRefData + 36);
  *(_DWORD *)(dwRefData + 36) = a2;
  if ( !a2 )
  {
    pickbuddy(dwRefData);
    v2 = *(HWND *)(dwRefData + 36);
  }
  if ( hWnd != v2 && *(_BYTE *)(dwRefData + 40) & 0x80 )
  {
    RemoveWindowSubclass(hWnd, (SUBCLASSPROC)ArrowKeyProc, 0);
    *(_DWORD *)(dwRefData + 40) &= 0xFFFFFF7F;
  }
  *(_DWORD *)(dwRefData + 60) = 0;
  if ( v2 )
  {
    if ( *(_BYTE *)(dwRefData + 8) & 0x20 )
    {
      *(_DWORD *)(dwRefData + 40) |= 0x80u;
      SetWindowSubclass(v2, (SUBCLASSPROC)ArrowKeyProc, 0, dwRefData);
    }
    GetClassNameW(v2, &ClassName, 10);
    if ( lstrcmpiW(&ClassName, L"EDIT") )
    {
      if ( !lstrcmpiW(&ClassName, L"listbox") )
        *(_DWORD *)(dwRefData + 60) = 2;
    }
    else
    {
      *(_DWORD *)(dwRefData + 60) = 1;
    }
  }
  anchor(dwRefData);
  return hWnd;
}

//----- (6F79DFC5) --------------------------------------------------------
LPARAM __stdcall UpDownWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // esi@1
  int v5; // eax@4
  HLOCAL v7; // eax@32
  DWORD_PTR v8; // esi@32
  LPARAM v9; // ebx@34
  signed int v10; // eax@71
  int v11; // eax@72
  signed int v12; // eax@77
  int v13; // eax@85
  int v14; // eax@92
  int v15; // ecx@92
  unsigned int v16; // ebx@97
  unsigned int v17; // edx@97
  unsigned int v18; // edx@98
  unsigned int v19; // edx@100
  unsigned int v20; // edx@102
  WPARAM v21; // ebx@111
  HLOCAL v22; // eax@114
  HWND v23; // eax@116
  LPARAM v24; // eax@119
  int v25; // ecx@119
  WPARAM v26; // edx@122
  LPARAM v27; // ecx@125
  int v28; // eax@125
  int v29; // [sp-8h] [bp-38h]@63
  HWND v30; // [sp-4h] [bp-34h]@63
  struct tagRECT Rect; // [sp+Ch] [bp-24h]@40
  struct tagTRACKMOUSEEVENT EventTrack; // [sp+1Ch] [bp-14h]@5
  int v33; // [sp+2Ch] [bp-4h]@128

  v4 = GetWindowLongW(hWnd, 0);
  if ( v4 )
  {
    if ( Msg - 512 <= 0xD )
    {
      if ( *(_DWORD *)(v4 + 8) & 0x100 )
      {
        v5 = *(_DWORD *)(v4 + 40);
        if ( !(v5 & 0x40) )
        {
          *(_DWORD *)(v4 + 40) = v5 | 0x40;
          EventTrack.hwndTrack = *(HWND *)v4;
          EventTrack.cbSize = 16;
          EventTrack.dwFlags = 2;
          _TrackMouseEvent(&EventTrack);
        }
      }
    }
  }
  else if ( Msg != 1 )
  {
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
  if ( Msg > 0x465 )
  {
    switch ( Msg )
    {
      case 0x46Fu:
        *(_DWORD *)(v4 + 48) = lParam;
        *(_DWORD *)(v4 + 52) = wParam;
        return 0;
      case 0x470u:
        if ( lParam )
          *(_DWORD *)lParam = *(_DWORD *)(v4 + 48);
        if ( wParam )
          *(_DWORD *)wParam = *(_DWORD *)(v4 + 52);
        return 0;
      case 0x466u:
        v14 = *(_WORD *)(v4 + 52);
        v15 = *(_WORD *)(v4 + 48);
        return v15 | (v14 << 16);
      case 0x46Du:
        return setbase(v4, wParam);
      case 0x46Eu:
        return *(_DWORD *)(v4 + 44);
      case 0x467u:
        lParam = (signed __int16)lParam;
        goto LABEL_97;
      case 0x471u:
LABEL_97:
        v16 = lParam;
        if ( compare(v4, *(_DWORD *)(v4 + 52), *(_DWORD *)(v4 + 48), 0) >= 0 )
        {
          if ( compare(v4, v16, v17, 0) < 0 )
            v16 = v20;
          if ( compare(v4, v16, *(_DWORD *)(v4 + 52), 0) <= 0 )
            goto LABEL_106;
        }
        else
        {
          if ( compare(v4, v16, v17, 0) > 0 )
            v16 = v18;
          if ( compare(v4, v16, *(_DWORD *)(v4 + 52), 0) >= 0 )
          {
LABEL_106:
            lParam = *(_DWORD *)(v4 + 56);
            *(_DWORD *)(v4 + 56) = v16;
            setint(v4);
            MyNotifyWinEvent(32782, *(_DWORD *)v4, -4, 0);
            return lParam;
          }
        }
        v16 = v19;
        goto LABEL_106;
      case 0x468u:
        LOWORD(v15) = getint(v4, (int)&lParam);
        v14 = (unsigned __int16)lParam;
        v15 = (unsigned __int16)v15;
        return v15 | (v14 << 16);
      case 0x472u:
        return getint(v4, lParam);
      case 0x469u:
        return (LPARAM)setbuddy(v4, (HWND)wParam);
      case 0x46Au:
        return *(_DWORD *)(v4 + 36);
      case 0x46Bu:
        v21 = wParam;
        if ( !wParam )
          return 0;
        if ( wParam < 3 )
          goto LABEL_118;
        v22 = LocalReAlloc((HLOCAL)v4, 8 * wParam + 84, 2u);
        v4 = (LONG)v22;
        if ( !v22 )
          return 0;
        SetWindowLongW(hWnd, 0, (LONG)v22);
        if ( *(_BYTE *)(v4 + 8) & 0x20 )
        {
          v23 = *(HWND *)(v4 + 36);
          if ( v23 )
          {
            *(_DWORD *)(v4 + 40) |= 0x80u;
            SetWindowSubclass(v23, (SUBCLASSPROC)ArrowKeyProc, 0, v4);
          }
        }
LABEL_118:
        *(_DWORD *)(v4 + 72) = wParam;
        if ( (signed int)wParam > 0 )
        {
          v24 = lParam;
          v25 = v4 + 76;
          do
          {
            *(_DWORD *)v25 = *(_DWORD *)v24;
            *(_DWORD *)(v25 + 4) = *(_DWORD *)(v24 + 4);
            v24 += 8;
            v25 += 8;
            --v21;
          }
          while ( v21 );
        }
        return 1;
      case 0x46Cu:
        v26 = wParam;
        if ( wParam > *(_DWORD *)(v4 + 72) )
          v26 = *(_DWORD *)(v4 + 72);
        if ( (signed int)v26 > 0 )
        {
          v27 = lParam;
          v28 = v4 + 76;
          do
          {
            *(_DWORD *)v27 = *(_DWORD *)v28;
            *(_DWORD *)(v27 + 4) = *(_DWORD *)(v28 + 4);
            v28 += 8;
            v27 += 8;
            --v26;
          }
          while ( v26 );
        }
        return *(_DWORD *)(v4 + 72);
      default:
        goto LABEL_128;
    }
  }
  if ( Msg == 1125 )
  {
    v13 = SHIWORD(lParam);
    *(_DWORD *)(v4 + 48) = (signed __int16)lParam;
    *(_DWORD *)(v4 + 52) = v13;
    nudge(v4);
    return 0;
  }
  if ( Msg > 0x113 )
  {
    if ( Msg != 296 )
    {
      if ( Msg == 512 )
      {
        UD_OnMouseMove(v4, lParam);
        return 0;
      }
      if ( Msg == 513 )
      {
        if ( *(_DWORD *)(v4 + 36) && !IsWindowEnabled(*(HWND *)(v4 + 36)) )
          return 0;
        SetCapture(hWnd);
        getint(v4, 0);
        if ( (unsigned int)(*(_DWORD *)(v4 + 60) - 1) <= 1 )
          SetFocus(*(HWND *)(v4 + 36));
        v10 = UD_HitTest(v4, (signed __int16)lParam, SHIWORD(lParam));
        if ( !v10 )
          return 0;
        v11 = v10 - 1;
        if ( v11 )
        {
          if ( v11 == 1 )
          {
            *(_DWORD *)(v4 + 64) = 0;
            squish(v4, 1, 0);
          }
        }
        else
        {
          *(_DWORD *)(v4 + 64) = 1;
          squish(v4, 0, 1);
        }
        if ( GetCaretBlinkTime() >= 0x514 )
          v12 = 1300;
        else
          v12 = GetCaretBlinkTime();
        SetTimer(hWnd, 1u, v12, 0);
        goto LABEL_80;
      }
      if ( Msg != 514 )
      {
        if ( Msg == 675 )
        {
          *(_DWORD *)(v4 + 40) &= 0xFFFFFFBF;
          UD_Invalidate(v4, *(_DWORD *)(v4 + 100), 0);
          *(_DWORD *)(v4 + 100) = 0;
          return 0;
        }
        if ( Msg != 792 )
          goto LABEL_128;
        goto LABEL_56;
      }
      if ( *(_DWORD *)(v4 + 36) && !IsWindowEnabled(*(HWND *)(v4 + 36)) || GetCapture() != hWnd )
        return 0;
LABEL_61:
      squish(v4, 0, 0);
      ReleaseCapture();
      KillTimer(hWnd, 1u);
      if ( *(_DWORD *)(v4 + 60) == 1 )
        SendMessageW(*(HWND *)(v4 + 36), 0xB1u, 0, -1);
      v30 = *(HWND *)v4;
      v29 = (*(_WORD *)(v4 + 56) << 16) | 8;
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
        SendMessageW(*(HWND *)(v4 + 4), 0x114u, v29, (LPARAM)v30);
      else
        SendMessageW(*(HWND *)(v4 + 4), 0x115u, v29, (LPARAM)v30);
      return 0;
    }
    CCOnUIState(v4, 296, wParam, lParam);
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
  if ( Msg == 275 )
  {
    if ( GetCapture() == hWnd )
    {
      SetTimer(hWnd, 1u, 0x64u, 0);
      GetWindowRect(hWnd, &Rect);
      if ( *(_BYTE *)(v4 + 8) & 0x40 )
      {
        if ( *(_DWORD *)(v4 + 64) )
          Rect.right = (Rect.right + Rect.left) / 2;
        else
          Rect.left = (Rect.right + Rect.left) / 2;
      }
      else if ( *(_DWORD *)(v4 + 64) )
      {
        Rect.top = (Rect.top + Rect.bottom) / 2;
      }
      else
      {
        Rect.bottom = (Rect.top + Rect.bottom) / 2;
      }
      InflateRect(&Rect, (g_cxFrame + 1) / 2, (g_cyFrame + 1) / 2);
      GetCursorPos((LPPOINT)&EventTrack.hwndTrack);
      if ( !PtInRect(&Rect, *(POINT *)&EventTrack.hwndTrack) )
      {
        squish(v4, 0, 0);
        return 0;
      }
      squish(v4, *(_DWORD *)(v4 + 64) == 0, *(_DWORD *)(v4 + 64));
LABEL_80:
      bump(v4);
      return 0;
    }
    goto LABEL_61;
  }
  if ( Msg == 1 )
  {
    CCCreateWindow();
    v7 = LocalAlloc(0x40u, 0x6Cu);
    v8 = (DWORD_PTR)v7;
    if ( !v7 )
      return -1;
    SetWindowLongW(hWnd, 0, (LONG)v7);
    v9 = lParam;
    CIInitialize(v8, (WPARAM)hWnd, lParam);
    if ( *(_DWORD *)(v9 + 32) & 0x200 )
      *(_DWORD *)(v8 + 40) |= 4u;
    if ( *(_DWORD *)(v9 + 44) & 0x200 )
      *(_DWORD *)(v8 + 40) |= 0x10u;
    *(_DWORD *)(v8 + 44) = 10;
    *(_DWORD *)(v8 + 48) = 0;
    *(_DWORD *)(v8 + 52) = 100;
    *(_DWORD *)(v8 + 56) = 0;
    *(_DWORD *)(v8 + 36) = 0;
    *(_DWORD *)(v8 + 60) = 0;
    *(_DWORD *)(v8 + 72) = 3;
    *(_DWORD *)(v8 + 76) = 0;
    *(_DWORD *)(v8 + 80) = 1;
    *(_DWORD *)(v8 + 84) = 2;
    *(_DWORD *)(v8 + 88) = 5;
    *(_DWORD *)(v8 + 92) = 5;
    *(_DWORD *)(v8 + 96) = 20;
    setbuddy(v8, 0);
    setint(v8);
    return 0;
  }
  if ( Msg == 2 )
  {
    CCDestroyWindow();
    if ( v4 )
    {
      if ( *(_DWORD *)(v4 + 36) )
        *(_DWORD *)(v4 + 40) |= 0x20u;
      else
        LocalFree((HLOCAL)v4);
      SetWindowLongW(hWnd, 0, 0);
    }
    return 0;
  }
  if ( Msg == 10 )
  {
    InvalidateRect(hWnd, 0, 1);
    return 0;
  }
  if ( Msg == 15 )
  {
LABEL_56:
    PaintUpDownControl(v4, (HDC)wParam);
    return 0;
  }
  if ( Msg == 26 )
  {
    if ( v4 && (!wParam || wParam == 42 || wParam == 34) )
    {
      InitGlobalMetrics(wParam);
      unachor(v4);
      anchor(v4);
    }
    return 0;
  }
  if ( Msg == 61 )
  {
    if ( lParam == -12 )
      return 65558;
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
  if ( Msg == 85 )
    return CIHandleNotifyFormat(v4, lParam);
LABEL_128:
  if ( !CCWndProc(v4, Msg, wParam, lParam, (int)&v33) )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  return v33;
}
// 6F7E6820: using guessed type int g_cyFrame;
// 6F7E6854: using guessed type int g_cxFrame;

//----- (6F79E67A) --------------------------------------------------------
BOOL __stdcall DSA_GetItem(HDSA hdsa, int i, void *pitem)
{
  BOOL result; // eax@3

  if ( i < 0 || i >= *(_DWORD *)hdsa )
  {
    result = 0;
  }
  else
  {
    memmove(pitem, (const void *)(*((_DWORD *)hdsa + 1) + i * *((_DWORD *)hdsa + 3)), *((_DWORD *)hdsa + 3));
    result = 1;
  }
  return result;
}

//----- (6F79E6B3) --------------------------------------------------------
BOOL __stdcall DSA_DeleteAllItems(HDSA hdsa)
{
  BOOL result; // eax@2

  if ( !*((_DWORD *)hdsa + 1) || (result = Free(*((HLOCAL *)hdsa + 1))) != 0 )
  {
    *((_DWORD *)hdsa + 1) = 0;
    *((_DWORD *)hdsa + 2) = 0;
    *(_DWORD *)hdsa = 0;
    result = 1;
  }
  return result;
}

//----- (6F79E6E5) --------------------------------------------------------
int __stdcall DPA_GetPtrIndex(HDPA hdpa, const void *p)
{
  int v2; // edx@2
  unsigned int i; // eax@3

  if ( hdpa )
  {
    v2 = *((_DWORD *)hdpa + 1);
    if ( v2 )
    {
      for ( i = *((_DWORD *)hdpa + 1); i < v2 + 4 * *(_DWORD *)hdpa; i += 4 )
      {
        if ( *(const void **)i == p )
          return (signed int)(i - v2) >> 2;
      }
    }
  }
  return -1;
}

//----- (6F79E724) --------------------------------------------------------
HRESULT __stdcall DPA_SaveStream(HDPA hdpa, PFNDPASTREAM pfn, struct IStream *pstream, void *pvInstData)
{
  HRESULT v4; // edi@1
  struct IStream *v5; // esi@2
  struct IStreamVtbl *v6; // eax@5
  bool v7; // zf@6
  bool v8; // sf@6
  HRESULT v9; // eax@7
  int v10; // eax@14
  int v11; // ecx@14
  struct IStream v12; // ecx@16
  int v14; // [sp+4h] [bp-24h]@5
  int v15; // [sp+8h] [bp-20h]@5
  int v16; // [sp+Ch] [bp-1Ch]@5
  int v17; // [sp+10h] [bp-18h]@4
  int v18; // [sp+14h] [bp-14h]@14
  DPASTREAMINFO pinfo; // [sp+18h] [bp-10h]@6
  int v20; // [sp+20h] [bp-8h]@4
  int v21; // [sp+24h] [bp-4h]@4
  void **hdpaa; // [sp+30h] [bp+8h]@6
  struct IStream *pstreama; // [sp+38h] [bp+10h]@6

  v4 = -2147024809;
  if ( !IsValidHDPA((int)hdpa) )
    return v4;
  v5 = pstream;
  if ( !pstream )
    return v4;
  if ( !pfn )
    return v4;
  v20 = 0;
  v21 = 0;
  v4 = ((int (__stdcall *)(struct IStream *, _DWORD, _DWORD, signed int, int *))pstream->lpVtbl->Seek)(
         pstream,
         0,
         0,
         1,
         &v17);
  if ( v4 < 0 )
    return v4;
  v6 = pstream->lpVtbl;
  v14 = 0;
  v15 = 1;
  v16 = 0;
  v4 = v6->Write(pstream, &v14, 12, 0);
  if ( v4 < 0 )
    return v4;
  v7 = *(_DWORD *)hdpa == 0;
  v8 = *(_DWORD *)hdpa < 0;
  pstreama = *(struct IStream **)hdpa;
  hdpaa = (void **)*((_DWORD *)hdpa + 1);
  pinfo.iPos = 0;
  if ( v8 || v7 )
    goto LABEL_13;
  while ( 1 )
  {
    pinfo.pvItem = *hdpaa;
    v9 = pfn(&pinfo, v5, pvInstData);
    v4 = v9;
    if ( v9 )
      break;
    ++pinfo.iPos;
LABEL_10:
    pstreama = (struct IStream *)((char *)pstreama - 1);
    ++hdpaa;
    if ( (signed int)pstreama <= 0 )
      goto LABEL_13;
  }
  if ( v9 >= 0 )
    goto LABEL_10;
  v4 = 1;
LABEL_13:
  if ( v4 < 0 )
  {
    v10 = v17;
    v11 = v18;
    goto LABEL_17;
  }
  v4 = ((int (__stdcall *)(struct IStream *, int, int, signed int, int *))v5->lpVtbl->Seek)(v5, v20, v21, 1, &v20);
  if ( v4 >= 0 )
  {
    v12.lpVtbl = v5->lpVtbl;
    v16 = pinfo.iPos;
    v14 = v20 - v17;
    ((void (__stdcall *)(struct IStream *, int, int, _DWORD, _DWORD))v12.lpVtbl->Seek)(v5, v17, v18, 0, 0);
    v5->lpVtbl->Write(v5, &v14, 12, 0);
    v10 = v20;
    v11 = v21;
LABEL_17:
    ((void (__stdcall *)(struct IStream *, int, int, _DWORD, _DWORD))v5->lpVtbl->Seek)(v5, v10, v11, 0, 0);
  }
  return v4;
}

//----- (6F79E856) --------------------------------------------------------
void *__stdcall DPA_MergeThem(int a1, int a2, signed int a3)
{
  int v3; // esi@1
  const void *v4; // edi@1
  void *result; // eax@3
  int v6; // ecx@3
  int v7; // edx@5
  int v8; // [sp+Ch] [bp-4h]@1
  int v9; // [sp+18h] [bp+8h]@1
  int v10; // [sp+1Ch] [bp+Ch]@1

  v3 = a1;
  v4 = (const void *)(*(_DWORD *)a1 + 4 * a2);
  memmove(*(void **)(a1 + 16), v4, 4 * (a3 / 2));
  v10 = 0;
  v9 = 0;
  v8 = a3 / 2;
  do
  {
    while ( (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(v3 + 4))(
              *(_DWORD *)(*(_DWORD *)(v3 + 16) + 4 * v10),
              *((_DWORD *)v4 + v8),
              *(_DWORD *)(v3 + 8)) <= 0 )
    {
      result = *(void **)(*(_DWORD *)(v3 + 16) + 4 * v10);
      v6 = v9++;
      ++v10;
      *((_DWORD *)v4 + v6) = result;
      if ( v10 == a3 / 2 )
        return result;
    }
    v7 = v9++;
    *((_DWORD *)v4 + v7) = *((_DWORD *)v4 + v8++);
  }
  while ( v8 != a3 );
  return memmove((char *)v4 + 4 * v9, (const void *)(*(_DWORD *)(v3 + 16) + 4 * v10), 4 * (a3 - v9));
}

//----- (6F79E90C) --------------------------------------------------------
int __stdcall Str_GetPtrW(LPCWSTR lpString, void *Dst, int a3)
{
  int v4; // eax@8
  int v5; // esi@8

  if ( Dst )
    *(_WORD *)Dst = 0;
  if ( a3 < 0 )
    return 0;
  if ( !lpString )
  {
    if ( Dst )
      *(_WORD *)Dst = 0;
    return 0;
  }
  v4 = lstrlenW(lpString);
  v5 = v4;
  if ( Dst && a3 )
  {
    if ( v4 >= a3 )
      v5 = a3 - 1;
    memmove(Dst, lpString, 2 * v5);
    *((_WORD *)Dst + v5) = 0;
  }
  return v5 + 1;
}

//----- (6F79E97B) --------------------------------------------------------
size_t __stdcall Str_GetPtrA(LPCSTR lpString, void *Dst, int a3)
{
  int v4; // eax@8
  size_t v5; // esi@8

  if ( Dst )
    *(_BYTE *)Dst = 0;
  if ( a3 < 0 )
    return 0;
  if ( !lpString )
  {
    if ( Dst )
      *(_BYTE *)Dst = 0;
    return 0;
  }
  v4 = lstrlenA(lpString);
  v5 = v4;
  if ( Dst && a3 )
  {
    if ( v4 >= a3 )
      v5 = a3 - 1;
    memmove(Dst, lpString, v5);
    *((_BYTE *)Dst + v5) = 0;
  }
  return v5 + 1;
}

//----- (6F79E9E1) --------------------------------------------------------
BOOL __stdcall DSA_SetItem(HDSA hdsa, int i, const void *pitem)
{
  int v3; // ecx@1
  HDSA v4; // esi@3
  int v5; // ebx@4
  HDSA v6; // edi@6
  HLOCAL v7; // eax@7

  v3 = i;
  if ( i >= 0 && i != 0x7FFFFFFF )
  {
    v4 = hdsa;
    if ( i < *(_DWORD *)hdsa )
    {
LABEL_10:
      memmove((void *)(*((_DWORD *)v4 + 1) + v3 * *((_DWORD *)v4 + 3)), pitem, *((_DWORD *)v4 + 3));
      return 1;
    }
    v5 = i + 1;
    if ( i + 1 <= *((_DWORD *)hdsa + 2) )
    {
LABEL_9:
      *(_DWORD *)v4 = v5;
      goto LABEL_10;
    }
    if ( DXA_RoundUp(i + 1, *((_DWORD *)hdsa + 4), (INT *)&hdsa) )
    {
      v6 = hdsa;
      if ( (unsigned int)hdsa < 0x7FFFFFFFu / *((_DWORD *)v4 + 3) )
      {
        v7 = PrivateLocalReAllocArray(*((HLOCAL *)v4 + 1), (int)hdsa, *((_DWORD *)v4 + 3));
        if ( v7 )
        {
          v3 = i;
          *((_DWORD *)v4 + 1) = v7;
          *((_DWORD *)v4 + 2) = v6;
          goto LABEL_9;
        }
      }
    }
  }
  return 0;
}

//----- (6F79EA6B) --------------------------------------------------------
HRESULT __stdcall DPA_LoadStream(HDPA *phdpa, PFNDPASTREAM pfn, struct IStream *pstream, void *pvInstData)
{
  struct IStream *v4; // ebx@2
  struct _DPA *v5; // eax@10
  struct _DPA *v6; // esi@10
  int v7; // edi@12
  HRESULT v8; // eax@13
  int v9; // ecx@21
  unsigned int v11; // [sp+4h] [bp-20h]@5
  int v12; // [sp+8h] [bp-1Ch]@8
  int cItemGrow; // [sp+Ch] [bp-18h]@9
  int v14; // [sp+10h] [bp-14h]@4
  int v15; // [sp+14h] [bp-10h]@22
  DPASTREAMINFO pinfo; // [sp+18h] [bp-Ch]@4
  HRESULT v17; // [sp+20h] [bp-4h]@1

  v17 = -2147024809;
  if ( !phdpa )
    return v17;
  v4 = pstream;
  if ( !pstream )
    return v17;
  if ( !pfn )
    return v17;
  *phdpa = 0;
  pinfo.iPos = 0;
  pinfo.pvItem = 0;
  v17 = ((int (__stdcall *)(struct IStream *, _DWORD, _DWORD, signed int, int *))v4->lpVtbl->Seek)(v4, 0, 0, 1, &v14);
  if ( v17 < 0 )
    return v17;
  v17 = v4->lpVtbl->Read(v4, &v11, 12, (ULONG *)&pstream);
  if ( v17 < 0 )
    return v17;
  if ( (unsigned int)pstream < 0xC || v11 < 0xC || v12 != 1 || cItemGrow < 0 )
  {
    v17 = -2147467259;
    goto LABEL_25;
  }
  v5 = DPA_Create(cItemGrow);
  v6 = v5;
  if ( !v5 || !DPA_Grow(v5, cItemGrow) )
  {
    v17 = -2147024882;
    goto LABEL_21;
  }
  pinfo.iPos = 0;
  v7 = *((_DWORD *)v6 + 1);
  if ( cItemGrow <= 0 )
    goto LABEL_19;
  while ( 1 )
  {
    pinfo.pvItem = 0;
    v8 = pfn(&pinfo, v4, pvInstData);
    v17 = v8;
    if ( v8 )
      break;
    *(_DWORD *)v7 = pinfo.pvItem;
    ++pinfo.iPos;
    v7 += 4;
LABEL_16:
    if ( pinfo.iPos >= cItemGrow )
      goto LABEL_19;
  }
  if ( v8 >= 0 )
    goto LABEL_16;
  v17 = 1;
LABEL_19:
  *(_DWORD *)v6 = pinfo.iPos;
  *phdpa = v6;
LABEL_25:
  if ( !v17 )
    return v17;
  if ( v17 != 1 )
  {
LABEL_21:
    v9 = v14;
    goto LABEL_22;
  }
  v9 = v14 + v11;
LABEL_22:
  ((void (__stdcall *)(struct IStream *, int, int, _DWORD, _DWORD))v4->lpVtbl->Seek)(v4, v9, v15, 0, 0);
  return v17;
}

//----- (6F79EBB8) --------------------------------------------------------
BOOL __stdcall DPA_Merge(HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam)
{
  int v6; // ebx@7
  int v7; // esi@7
  void **v8; // edi@7
  int v9; // eax@9
  void *v10; // eax@10
  PVOID v11; // eax@14
  void *v12; // eax@17
  void *v13; // eax@25
  BOOL v15; // [sp+8h] [bp-4h]@1
  void **hdpaSrca; // [sp+18h] [bp+Ch]@7

  v15 = 0;
  if ( !IsValidHDPA((int)hdpaSrc) || !IsValidHDPA((int)hdpaDest) || !pfnCompare || !pfnMerge )
    return v15;
  v15 = 1;
  if ( !(dwFlags & 1) )
  {
    DPA_Sort(hdpaSrc, pfnCompare, lParam);
    DPA_Sort(hdpaDest, pfnCompare, lParam);
  }
  v6 = *(_DWORD *)hdpaSrc - 1;
  hdpaSrca = (void **)(*((_DWORD *)hdpaSrc + 1) + 4 * v6);
  v7 = *(_DWORD *)hdpaDest - 1;
  v8 = (void **)(*((_DWORD *)hdpaDest + 1) + 4 * v7);
  while ( v6 >= 0 && v7 >= 0 )
  {
    v9 = pfnCompare(*v8, *hdpaSrca, lParam);
    if ( v9 )
    {
      if ( v9 > 0 )
      {
        if ( dwFlags & 8 )
        {
          v11 = DPA_DeletePtr(hdpaDest, v7);
          pfnMerge(2, v11, 0, lParam);
          v8 = (void **)(*((_DWORD *)hdpaDest + 1) + 4 * v7);
        }
        goto LABEL_15;
      }
      if ( dwFlags & 4 )
      {
        v12 = pfnMerge(3, *hdpaSrca, 0, lParam);
        if ( !v12 )
        {
LABEL_22:
          v15 = 0;
          break;
        }
        DPA_InsertPtr(hdpaDest, v7 + 1, v12);
        v8 = (void **)(*((_DWORD *)hdpaDest + 1) + 4 * v7);
      }
      --v6;
      --hdpaSrca;
    }
    else
    {
      v10 = pfnMerge(1, *v8, *hdpaSrca, lParam);
      if ( !v10 )
        goto LABEL_22;
      --v6;
      --hdpaSrca;
      *v8 = v10;
LABEL_15:
      --v7;
      --v8;
    }
  }
  if ( dwFlags & 4 )
  {
    while ( v6 >= 0 )
    {
      v13 = pfnMerge(3, *hdpaSrca, 0, lParam);
      if ( !v13 )
        return 0;
      DPA_InsertPtr(hdpaDest, 0, v13);
      --v6;
      --hdpaSrca;
    }
  }
  return v15;
}

//----- (6F79ED1D) --------------------------------------------------------
LONG __stdcall Str_SetPtrA(volatile LONG *Target, LPCSTR lpString)
{
  LONG v2; // edi@1
  int v3; // eax@2
  size_t v4; // esi@2
  LONG result; // eax@2
  LONG v6; // eax@4

  v2 = 0;
  if ( lpString )
  {
    v3 = lstrlenA(lpString);
    v4 = v3 + 1;
    result = Alloc(v3 + 1);
    v2 = result;
    if ( !result )
      return result;
    StringCchCopyA((STRSAFE_LPSTR)result, v4, lpString);
  }
  v6 = InterlockedExchange(Target, v2);
  if ( v6 )
    Free((HLOCAL)v6);
  return 1;
}

//----- (6F79ED6F) --------------------------------------------------------
LRESULT __stdcall SubclassDeath(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  InvalidateRect(hWnd, 0, 1);
  SetWindowLongW(hWnd, -4, (LONG)DefWindowProcW);
  return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (6F79EDAC) --------------------------------------------------------
BOOL __stdcall GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass, DWORD_PTR *pdwRefData)
{
  BOOL v4; // edi@1
  DWORD_PTR v5; // esi@1
  DWORD v6; // ecx@1
  int v7; // eax@3
  int v8; // eax@4

  v4 = 0;
  v5 = 0;
  if ( IsWindow(hWnd) )
  {
    if ( pfnSubclass )
    {
      v7 = (int)GetSubclassHeader(v6, hWnd);
      if ( v7 )
      {
        v8 = FindCallRecord(v7, (int)pfnSubclass, uIdSubclass);
        if ( v8 )
        {
          v5 = *(_DWORD *)(v8 + 8);
          v4 = 1;
        }
      }
    }
  }
  if ( pdwRefData )
    *pdwRefData = v5;
  return v4;
}

//----- (6F79EDFF) --------------------------------------------------------
BOOL __stdcall RM_HandleKeyDown(int a1, int a2, int a3)
{
  signed int v3; // eax@1
  BOOL result; // eax@6
  LONG v5; // esi@7
  LONG v6; // edx@7
  int v7; // eax@9
  LONG v8; // ebx@12
  LONG v9; // eax@12
  LONG v10; // ecx@13
  int v11; // edx@14
  int v12; // edx@17
  int v13; // ecx@17
  int v14; // esi@17
  int v15; // eax@17
  __int64 v16; // rax@19
  struct tagPOINT Point; // [sp+0h] [bp-Ch]@1
  int v18; // [sp+8h] [bp-4h]@1

  GetCursorPos(&Point);
  v18 = 8;
  v3 = (signed int)dword_6F7E8564;
  do
  {
    if ( a2 == *(_DWORD *)(v3 - 4) )
      break;
    if ( a2 == *(_DWORD *)v3 )
      break;
    --v18;
    v3 -= 16;
  }
  while ( v3 >= (signed int)&dword_6F7E84E4 );
  if ( v18 == -1 )
  {
    result = ReleaseCapture();
  }
  else
  {
    v5 = Point.x;
    v6 = *(_DWORD *)(a1 + 8);
    if ( Point.x < v6 && Point.x >= *(_DWORD *)a1 )
    {
      v7 = dword_6F7E84E8[4 * v18];
      if ( v7 )
      {
        v5 = v6 - 2;
        if ( v7 <= 0 )
          v5 = *(_DWORD *)a1 + 1;
      }
    }
    v8 = *(_DWORD *)(a1 + 12);
    v9 = Point.y;
    if ( Point.y < v8 )
    {
      v10 = *(_DWORD *)(a1 + 4);
      if ( Point.y >= v10 )
      {
        v11 = dword_6F7E84EC[4 * v18];
        if ( v11 )
        {
          v9 = v8 - 2;
          if ( v11 <= 0 )
            v9 = v10 + 1;
        }
      }
    }
    v12 = dword_6F7E84E8[4 * v18];
    v13 = dword_6F7E84EC[4 * v18];
    v14 = v12 + v5;
    v15 = v13 + v9;
    Point.x = v14;
    Point.y = v15;
    if ( !v12 && !v13 )
    {
      v16 = *(_DWORD *)(a1 + 8) + *(_DWORD *)a1;
      v14 = ((signed int)v16 - HIDWORD(v16)) >> 1;
      v15 = (v8 + *(_DWORD *)(a1 + 4)) / 2;
      Point.x = v14;
      Point.y = v15;
    }
    result = SetCursorPos(v14, v15);
  }
  return result;
}
// 6F7E84E4: using guessed type int dword_6F7E84E4;
// 6F7E84E8: using guessed type int dword_6F7E84E8[];
// 6F7E84EC: using guessed type int dword_6F7E84EC[];
// 6F7E8564: using guessed type int dword_6F7E8564[3];

//----- (6F79EEF2) --------------------------------------------------------
int __stdcall RM_GetScrollXY(int a1, int a2, int a3, int a4)
{
  LONG v4; // eax@2
  LONG v5; // edx@3
  int v6; // edx@6
  LONG v7; // eax@7
  LONG v8; // ecx@8
  int result; // eax@11
  struct tagPOINT Point; // [sp+Ch] [bp-8h]@1

  GetCursorPos(&Point);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)a4 = 0;
  if ( Point.x > *(_DWORD *)a2 )
  {
    v5 = *(_DWORD *)(a2 + 8);
    if ( Point.x < v5 )
      goto LABEL_6;
    v4 = (Point.x - v5) / 20 + 1;
  }
  else
  {
    v4 = (Point.x - *(_DWORD *)a2) / 20 - 1;
  }
  *(_DWORD *)a3 = v4;
LABEL_6:
  v6 = *(_DWORD *)(a2 + 4);
  if ( Point.y > v6 )
  {
    v8 = *(_DWORD *)(a2 + 12);
    if ( Point.y < v8 )
      goto LABEL_11;
    v7 = (Point.y - v8) / 20 + 1;
  }
  else
  {
    v7 = (Point.y - v6) / 20 - 1;
  }
  *(_DWORD *)a4 = v7;
LABEL_11:
  result = a1;
  if ( *(_BYTE *)(a1 + 8) & 2 )
    *(_DWORD *)a3 = 0;
  if ( *(_BYTE *)(a1 + 8) & 4 )
    *(_DWORD *)a4 = 0;
  return result;
}

//----- (6F79EF83) --------------------------------------------------------
int __stdcall RM_CheckScroll(int a1, int a2)
{
  int v2; // esi@1

  v2 = a1;
  RM_GetScrollXY(a1, a2, (int)&a1, (int)&a2);
  return (*(int (__stdcall **)(int, int, int))(v2 + 16))(v2, a1, a2);
}

//----- (6F79EFB1) --------------------------------------------------------
HCURSOR __stdcall RM_SetCursor(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  unsigned int v4; // eax@2
  int v5; // eax@5
  HCURSOR v6; // eax@17
  signed int v8; // [sp-4h] [bp-4h]@9

  v2 = a1;
  RM_GetScrollXY(a1, a2, (int)&a2, (int)&a1);
  v3 = *(_DWORD *)(v2 + 8);
  if ( v3 & 2 )
    v4 = 109;
  else
    v4 = ((unsigned int)(unsigned __int8)~(_BYTE)v3 >> 2) & 1 | 0x6E;
  if ( !(a1 * a2) )
  {
    if ( a1 <= 0 )
    {
      if ( a1 >= 0 )
      {
        if ( a2 >= 0 )
        {
          if ( a2 <= 0 )
            goto LABEL_17;
          v8 = 114;
        }
        else
        {
          v8 = 115;
        }
      }
      else
      {
        v8 = 112;
      }
    }
    else
    {
      v8 = 113;
    }
    v4 = v8;
    goto LABEL_17;
  }
  v5 = 0;
  if ( a1 <= 0 )
  {
    LOBYTE(v5) = a2 <= 0;
    v4 = v5 + 116;
  }
  else
  {
    LOBYTE(v5) = a2 <= 0;
    v4 = v5 + 118;
  }
LABEL_17:
  v6 = LoadCursorW(g_hinst, (LPCWSTR)v4);
  return SetCursor(v6);
}

//----- (6F79F047) --------------------------------------------------------
HWND __stdcall DoReaderMode(int a1)
{
  HWND result; // eax@1
  LONG *v2; // esi@3
  int v3; // esi@5
  HWND v4; // ST04_4@5
  int (__stdcall *v5)(_DWORD); // eax@12
  struct tagMSG Msg; // [sp+4h] [bp-2Ch]@9
  struct tagRECT Rect; // [sp+20h] [bp-10h]@4

  result = *(HWND *)(a1 + 4);
  if ( result && *(_DWORD *)a1 == 28 )
  {
    SetCapture(result);
    v2 = *(LONG **)(a1 + 12);
    if ( v2 )
    {
      Rect.left = *v2;
      v3 = (int)(v2 + 1);
      Rect.top = *(_DWORD *)v3;
      v3 += 4;
      Rect.right = *(_DWORD *)v3;
      v4 = *(HWND *)(a1 + 4);
      Rect.bottom = *(_DWORD *)(v3 + 4);
      MapWindowPoints(v4, 0, (LPPOINT)&Rect, 2u);
    }
    else
    {
      GetWindowRect(*(HWND *)(a1 + 4), &Rect);
    }
    if ( *(_BYTE *)(a1 + 8) & 1 )
      SetCursorPos((Rect.left + Rect.right) / 2, (Rect.top + Rect.bottom) / 2);
    for ( result = GetCapture(); result == *(HWND *)(a1 + 4); result = GetCapture() )
    {
      RM_CheckScroll(a1, (int)&Rect);
      if ( !PeekMessageW(&Msg, 0, 0x100u, 0x108u, 1u)
        && !PeekMessageW(&Msg, 0, 0x200u, 0x20Du, 1u)
        && !PeekMessageW(&Msg, 0, 0, 0, 1u) )
      {
        WaitMessage();
        continue;
      }
      v5 = *(int (__stdcall **)(_DWORD))(a1 + 20);
      if ( v5 && v5(&Msg) )
        continue;
      if ( Msg.message == g_msgMSWheel )
      {
LABEL_29:
        ReleaseCapture();
        continue;
      }
      if ( Msg.message > 0x200 )
      {
        if ( Msg.message >= 0x201
          && (Msg.message <= 0x202
           || Msg.message > 0x203 && (Msg.message <= 0x205 || Msg.message > 0x206 && Msg.message <= 0x208)) )
          goto LABEL_29;
      }
      else
      {
        if ( Msg.message == 512 || Msg.message == 32 )
        {
          RM_SetCursor(a1, (int)&Rect);
          continue;
        }
        if ( Msg.message == 256 )
        {
          RM_HandleKeyDown((int)&Rect, Msg.wParam, Msg.lParam);
          continue;
        }
        if ( Msg.message == 260 )
          goto LABEL_29;
      }
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
  }
  return result;
}
// 6F7E6930: using guessed type int g_msgMSWheel;

//----- (6F79F1E2) --------------------------------------------------------
int __stdcall PtInLBItem(HWND hWnd, WPARAM wParam, POINT pt, int a4, int dy)
{
  WPARAM v5; // eax@1
  int result; // eax@4
  const RECT lParam; // [sp+4h] [bp-10h]@3

  v5 = wParam;
  if ( (wParam & 0x80000000) != 0 )
    v5 = SendMessageW(hWnd, 0x188u, 0, 0);
  if ( SendMessageW(hWnd, 0x198u, v5, (LPARAM)&lParam) == -1 )
  {
    result = 0;
  }
  else
  {
    InflateRect((LPRECT)&lParam, a4, dy);
    result = PtInRect(&lParam, pt);
  }
  return result;
}

//----- (6F79F248) --------------------------------------------------------
int __stdcall LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
  signed int v4; // eax@10
  unsigned __int16 v5; // di@13
  DWORD v6; // eax@13
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@1
  WPARAM wParam; // [sp+1Ch] [bp-4h]@1

  ScreenToClient(hLB, &pt);
  GetClientRect(hLB, &Rect);
  wParam = SendMessageW(hLB, 0x18Eu, 0, 0);
  if ( PtInRect(&Rect, pt) )
  {
    while ( SendMessageW(hLB, 0x198u, wParam, (LPARAM)&Rect) != -1 )
    {
      if ( PtInRect(&Rect, pt) )
        return wParam;
      ++wParam;
    }
  }
  else if ( bAutoScroll && (unsigned int)pt.x < Rect.right )
  {
    v4 = pt.y;
    if ( pt.y > 0 )
    {
      ++wParam;
      v4 = Rect.bottom - pt.y;
      pt.y = Rect.bottom - pt.y;
    }
    else
    {
      --wParam;
    }
    v5 = 1000 / (6 - v4 / 25);
    v6 = GetTickCount();
    if ( (unsigned __int16)(v6 - dword_6F7E8AA4) > v5 )
    {
      if ( (unsigned __int16)(v6 - dword_6F7E8AA4) <= 2 * v5 )
        dword_6F7E8AA4 += v5;
      else
        dword_6F7E8AA4 = v6;
      SendMessageW(hLB, 0x197u, wParam, 0);
    }
  }
  return -1;
}
// 6F7E8AA4: using guessed type int dword_6F7E8AA4;

//----- (6F79F35B) --------------------------------------------------------
void __stdcall DrawInsert(HWND handParent, HWND hLB, int nItem)
{
  signed int v3; // eax@1
  int v4; // edi@1
  HDC v5; // esi@7
  RECT Rect; // [sp+4h] [bp-10h]@3
  HICON nItema; // [sp+24h] [bp+10h]@6

  v3 = dword_6F7E8570;
  v4 = nItem;
  if ( dword_6F7E8570 >= 0 )
  {
    if ( nItem == dword_6F7E8570 )
      return;
    *(_QWORD *)&Rect.left = X;
    Rect.right = X.x + 16;
    Rect.bottom = X.y + 16;
    InvalidateRect(handParent, &Rect, 1);
    UpdateWindow(handParent);
    v3 = -1;
    dword_6F7E8570 = -1;
  }
  if ( nItem != v3 && nItem >= 0 )
  {
    nItema = LoadIconW(g_hinst, (LPCWSTR)0x96);
    if ( nItema )
    {
      GetWindowRect(hLB, &Rect);
      ScreenToClient(hLB, (LPPOINT)&Rect);
      X.x = Rect.left - 16;
      SendMessageW(hLB, 0x198u, v4, (LPARAM)&Rect);
      dword_6F7E8570 = v4;
      X.y = Rect.top - 8;
      ClientToScreen(hLB, &X);
      ScreenToClient(handParent, &X);
      v5 = GetDC(handParent);
      DrawIcon(v5, X.x, X.y, nItema);
      ReleaseDC(handParent, v5);
    }
  }
}
// 6F7E8570: using guessed type int dword_6F7E8570;

//----- (6F79F475) --------------------------------------------------------
LRESULT __stdcall DragListSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  HWND v6; // esi@1
  int v7; // edx@1
  int v9; // eax@22
  HCURSOR v10; // eax@29
  HWND v11; // edi@29
  int v12; // eax@29
  int v13; // eax@32
  int v14; // ST10_4@34
  HWND v15; // eax@34
  POINT v16; // ST08_8@37
  int v17; // eax@40
  LRESULT v18; // eax@40
  int v19; // eax@45
  int v20; // eax@46
  HCURSOR v21; // eax@49
  signed int v22; // [sp-4h] [bp-28h]@48
  LPARAM v23; // [sp+Ch] [bp-18h]@29
  HWND v24; // [sp+10h] [bp-14h]@29
  struct tagPOINT Point; // [sp+14h] [bp-10h]@29
  POINT pt; // [sp+1Ch] [bp-8h]@20
  HWND hWnda; // [sp+2Ch] [bp+8h]@1
  HWND wParama; // [sp+34h] [bp+10h]@40

  v6 = hWnd;
  v7 = *(_DWORD *)dwRefData == (_DWORD)hWnd;
  hWnda = (HWND)(*(_DWORD *)dwRefData == (_DWORD)hWnd);
  if ( uMsg > 0x113 )
  {
    if ( uMsg != 512 )
    {
      if ( uMsg != 513 )
      {
        if ( uMsg != 514 && uMsg != 516 || !v7 )
          return DefSubclassProc(v6, uMsg, wParam, lParam);
        *(_DWORD *)dwRefData = 0;
        KillTimer(v6, 0xEEu);
        ReleaseCapture();
        v10 = LoadCursorW(0, (LPCWSTR)0x7F00);
        SetCursor(v10);
        v11 = GetParent(v6);
        v24 = v6;
        v23 = (uMsg != 514) + 1159;
        Point.y = SHIWORD(lParam);
        Point.x = (signed __int16)lParam;
        ClientToScreen(v6, &Point);
        v12 = GetDlgCtrlID(v6);
        SendMessageW(v11, uDragListMsg, v12, (LPARAM)&v23);
        return 0;
      }
      if ( v7 )
        SendMessageW(v6, 0x204u, 0, 0);
      SetFocus(v6);
      pt.x = (signed __int16)lParam;
      pt.y = SHIWORD(lParam);
      ClientToScreen(v6, &pt);
      v13 = LBItemFromPt(v6, pt, 0);
      if ( v13 < 0 )
        goto LABEL_43;
      SendMessageW(v6, 0x186u, v13, 0);
      if ( GetWindowLongW(v6, -16) & 1 )
      {
        v14 = (unsigned __int16)GetDlgCtrlID(v6) | 0x10000;
        v15 = GetParent(v6);
        SendMessageW(v15, 0x111u, v14, (LPARAM)v6);
      }
      v23 = 1157;
LABEL_40:
      wParama = GetParent(v6);
      Point.y = SHIWORD(lParam);
      v24 = v6;
      Point.x = (signed __int16)lParam;
      ClientToScreen(v6, &Point);
      v17 = GetDlgCtrlID(v6);
      v18 = SendMessageW(wParama, uDragListMsg, v17, (LPARAM)&v23);
      if ( uMsg != 513 )
      {
        v19 = v18 - 1;
        if ( v19 )
        {
          v20 = v19 - 1;
          if ( v20 )
          {
            if ( v20 != 1 )
              return 0;
            v22 = 105;
          }
          else
          {
            v22 = 104;
          }
          v21 = LoadCursorW(g_hinst, (LPCWSTR)v22);
        }
        else
        {
          v21 = LoadCursorW(0, (LPCWSTR)0x7F88);
        }
        SetCursor(v21);
        return 0;
      }
      if ( v18 )
      {
        SetTimer(v6, 0xEEu, 0x32u, 0);
        *(_DWORD *)(dwRefData + 4) = 3;
LABEL_44:
        *(_DWORD *)dwRefData = v6;
        SetCapture(v6);
        return 0;
      }
LABEL_43:
      *(_DWORD *)(dwRefData + 4) = 0;
      goto LABEL_44;
    }
LABEL_21:
    if ( !hWnda )
      return DefSubclassProc(v6, uMsg, wParam, lParam);
    v9 = *(_DWORD *)(dwRefData + 4);
    if ( !(v9 & 1) )
      return 0;
    if ( v9 & 2 )
    {
      v16.y = SHIWORD(lParam);
      v16.x = (signed __int16)lParam;
      pt.x = (signed __int16)lParam;
      pt.y = SHIWORD(lParam);
      if ( PtInLBItem(v6, 0xFFFFFFFF, v16, 0, 4) )
        return 0;
      *(_DWORD *)(dwRefData + 4) &= 0xFFFFFFFD;
    }
    v23 = 1158;
    goto LABEL_40;
  }
  if ( uMsg == 275 )
  {
    if ( wParam != 238 )
      return DefSubclassProc(v6, uMsg, wParam, lParam);
    lParam = GetMessagePosClient(v6, &pt);
    goto LABEL_21;
  }
  if ( uMsg == 130 )
  {
    if ( v7 )
      SendMessageW(v6, 0x204u, 0, 0);
    RemoveWindowSubclass(v6, DragListSubclassProc, 0);
    LocalFree((HLOCAL)dwRefData);
    return DefSubclassProc(v6, uMsg, wParam, lParam);
  }
  if ( uMsg != 135 )
  {
    if ( uMsg == 256 )
    {
      if ( wParam == 27 )
        SendMessageW(v6, 0x204u, 0, 0);
    }
    else if ( uMsg <= 0x100 || uMsg > 0x102 )
    {
      return DefSubclassProc(v6, uMsg, wParam, lParam);
    }
    if ( !hWnda )
      return DefSubclassProc(v6, uMsg, wParam, lParam);
    return 0;
  }
  if ( !v7 )
    return DefSubclassProc(v6, uMsg, wParam, lParam);
  return DefSubclassProc(v6, 0x87u, wParam, lParam) | 4;
}

//----- (6F79F78A) --------------------------------------------------------
BOOL __stdcall MakeDragList(HWND hLB)
{
  DWORD_PTR v2; // eax@5
  void *v3; // ebx@5

  if ( !uDragListMsg )
    uDragListMsg = RegisterWindowMessageW(L"commctrl_DragListMsg");
  if ( GetWindowSubclass(hLB, DragListSubclassProc, 0, 0) )
    return 1;
  v2 = (DWORD_PTR)LocalAlloc(0x40u, 8u);
  v3 = (void *)v2;
  if ( !v2 )
    return 0;
  if ( !SetWindowSubclass(hLB, DragListSubclassProc, 0, v2) )
  {
    LocalFree(v3);
    return 0;
  }
  return 1;
}

//----- (6F79F82B) --------------------------------------------------------
int __stdcall FlatSB_Internal_NotifyWinEvent(int a1, int a2, int a3)
{
  return MyNotifyWinEvent(a2, *(_DWORD *)(a1 + 220), (*(_DWORD *)(a1 + 96) != 0) - 6, a3);
}

//----- (6F79F859) --------------------------------------------------------
LRESULT __stdcall FlatSB_NCDestroyProc(HLOCAL hMem, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  if ( hMem != (HLOCAL)-1 )
  {
    DeleteObject(*((HGDIOBJ *)hMem + 53));
    DeleteObject(*((HGDIOBJ *)hMem + 52));
    LocalFree(hMem);
  }
  RemoveWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0);
  return DefSubclassProc(hWnd, 0x82u, wParam, lParam);
}

//----- (6F79F8B2) --------------------------------------------------------
LRESULT __stdcall FlatSB_NCCalcProc(int a1, HWND hWnd, WPARAM wParam, RECT *lprcSrc)
{
  int v4; // eax@1
  LONG v5; // edx@2
  int v6; // ecx@2
  int v7; // eax@4
  LONG v8; // edx@5
  int v9; // ecx@5
  struct tagRECT rcDst; // [sp+8h] [bp-28h]@1
  RECT rcSrc; // [sp+18h] [bp-18h]@1
  LRESULT v13; // [sp+28h] [bp-8h]@1
  int v14; // [sp+2Ch] [bp-4h]@1

  CopyRect(&rcDst, lprcSrc);
  v14 = SetWindowBits(hWnd, -16, 3145728, 0);
  CopyRect(&rcSrc, lprcSrc);
  v13 = DefSubclassProc(hWnd, 0x83u, wParam, (LPARAM)lprcSrc);
  SetWindowBits(hWnd, -16, 3145728, v14);
  DefSubclassProc(hWnd, 0x83u, 0, (LPARAM)&rcSrc);
  CopyRect(&rcSrc, lprcSrc);
  *(_DWORD *)(a1 + 4) &= 0xFFFFFFF9;
  v4 = *(_DWORD *)(a1 + 4);
  if ( v4 & 0x200000 )
  {
    v5 = rcSrc.right;
    v6 = *(_DWORD *)a1;
    if ( rcSrc.right - rcSrc.left >= **(_DWORD **)a1 )
    {
      *(_DWORD *)(a1 + 4) = v4 | 2;
      rcSrc.right = v5 - *(_DWORD *)v6;
    }
  }
  v7 = *(_DWORD *)(a1 + 4);
  if ( v7 & 0x100000 )
  {
    v8 = rcSrc.bottom;
    v9 = *(_DWORD *)a1;
    if ( rcSrc.bottom - rcSrc.top > *(_DWORD *)(*(_DWORD *)a1 + 16) )
    {
      *(_DWORD *)(a1 + 4) = v7 | 4;
      rcSrc.bottom = v8 - *(_DWORD *)(v9 + 16);
    }
  }
  CopyRect(lprcSrc, &rcSrc);
  *(_DWORD *)(a1 + 144) = rcSrc.top - rcDst.top;
  *(_DWORD *)(a1 + 152) = rcSrc.bottom - rcDst.top;
  *(_DWORD *)(a1 + 140) = rcSrc.left - rcDst.left;
  *(_DWORD *)(a1 + 148) = rcSrc.right - rcDst.left;
  return v13;
}

//----- (6F79F9BE) --------------------------------------------------------
void __stdcall TimerMouseLeave(HWND hWnd, UINT a2, UINT pdwRefData, DWORD a4)
{
  if ( pdwRefData == -14 )
  {
    GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&pdwRefData);
    if ( pdwRefData && pdwRefData != -1 )
    {
      if ( !*(_DWORD *)(pdwRefData + 100) )
        FlatSB_NCHitTestProc((HGDIOBJ)pdwRefData, hWnd, 0, 0, 1);
    }
    else
    {
      KillTimer(hWnd, 0xFFFFFFF2);
    }
  }
}

//----- (6F79FA13) --------------------------------------------------------
BOOL __stdcall FlatSB_InitWSBMetrics(int a1)
{
  int v1; // ebx@1
  BOOL result; // eax@1
  int pvParam; // [sp+Ch] [bp-4h]@1

  *(_DWORD *)(a1 + 296) = GetSystemMetrics(10);
  *(_DWORD *)(a1 + 308) = GetSystemMetrics(9);
  v1 = a1 + 288;
  *(_DWORD *)(a1 + 288) = GetSystemMetrics(2);
  *(_DWORD *)(a1 + 300) = GetSystemMetrics(20);
  *(_DWORD *)(a1 + 292) = GetSystemMetrics(21);
  *(_DWORD *)(a1 + 304) = GetSystemMetrics(3);
  pvParam = 0;
  result = SystemParametersInfoW(0x46u, 0, &pvParam, 0);
  if ( !pvParam )
    v1 = a1 + 264;
  *(_DWORD *)a1 = v1;
  return result;
}

//----- (6F79FA8F) --------------------------------------------------------
LRESULT __stdcall FlatSB_OnSettingChangeProc(int a1, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  FlatSB_InitWSBMetrics(a1);
  CCInvalidateFrame(hWnd);
  return DefSubclassProc(hWnd, 0x1Au, wParam, lParam);
}

//----- (6F79FABD) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawBox(HDC hdc, int x, HGDIOBJ a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // esi@3
  HBRUSH v8; // eax@6
  HBRUSH v9; // edi@8
  void *v10; // eax@8
  HGDIOBJ v11; // ST24_4@12
  int y; // [sp+8h] [bp-Ch]@3
  int w; // [sp+Ch] [bp-8h]@3
  int h; // [sp+10h] [bp-4h]@3
  int xa; // [sp+20h] [bp+Ch]@1
  HGDIOBJ v16; // [sp+24h] [bp+10h]@10

  v3 = x;
  v4 = *(_DWORD *)(x + 8);
  v5 = *(_DWORD *)x;
  xa = *(_DWORD *)x;
  if ( xa <= v4 )
  {
    v6 = *(_DWORD *)(v3 + 12);
    if ( *(_DWORD *)(v3 + 4) <= v6 )
    {
      v7 = *(_DWORD *)(v3 + 4);
      h = v6 - v7;
      y = *(_DWORD *)(v3 + 4);
      w = v4 - v5;
      if ( a3 == (HGDIOBJ)1 )
      {
        v9 = GetSysColorBrush(16);
        v16 = v9;
      }
      else
      {
        if ( a3 == (HGDIOBJ)2 )
        {
          v9 = GetSysColorBrush(16);
          v10 = GetStockObject(4);
        }
        else
        {
          if ( (char *)a3 - 2 == (_BYTE *)1 )
            v8 = GetSysColorBrush(20);
          else
            v8 = GetSysColorBrush(16);
          v9 = v8;
          v10 = GetSysColorBrush(15);
        }
        v16 = v10;
      }
      v11 = SelectObject(hdc, v9);
      PatBlt(hdc, xa, v7, w, 1, 0xF00021u);
      PatBlt(hdc, xa, y, 1, h, 0xF00021u);
      PatBlt(hdc, xa, h + y - 1, w, 1, 0xF00021u);
      PatBlt(hdc, w + xa - 1, y, 1, h, 0xF00021u);
      SelectObject(hdc, v16);
      PatBlt(hdc, xa + 1, y + 1, w - 2, h - 2, 0xF00021u);
      SelectObject(hdc, v11);
    }
  }
}

//----- (6F79FBE3) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawEncartaBox(HDC hdc, int x, HGDIOBJ a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // esi@3
  HBRUSH v8; // eax@6
  HBRUSH v9; // ebx@8
  HBRUSH v10; // ST28_4@11
  HGDIOBJ v11; // ST24_4@11
  int y; // [sp+Ch] [bp-Ch]@3
  int w; // [sp+10h] [bp-8h]@3
  int h; // [sp+14h] [bp-4h]@3
  int xa; // [sp+24h] [bp+Ch]@1
  HBRUSH v16; // [sp+28h] [bp+10h]@8

  v3 = x;
  v4 = *(_DWORD *)(x + 8);
  v5 = *(_DWORD *)x;
  xa = *(_DWORD *)x;
  if ( xa <= v4 )
  {
    v6 = *(_DWORD *)(v3 + 12);
    if ( *(_DWORD *)(v3 + 4) <= v6 )
    {
      v7 = *(_DWORD *)(v3 + 4);
      h = v6 - v7;
      y = *(_DWORD *)(v3 + 4);
      w = v4 - v5;
      if ( a3 == (HGDIOBJ)1 )
      {
        v9 = GetSysColorBrush(20);
        v16 = GetSysColorBrush(16);
      }
      else if ( a3 == (HGDIOBJ)2 )
      {
        v16 = GetSysColorBrush(20);
        v9 = GetSysColorBrush(16);
      }
      else
      {
        if ( (char *)a3 - 2 == (_BYTE *)1 )
          v8 = GetSysColorBrush(20);
        else
          v8 = GetSysColorBrush(16);
        v9 = v8;
        v16 = v8;
      }
      v10 = GetSysColorBrush(15);
      v11 = SelectObject(hdc, v9);
      PatBlt(hdc, xa, v7, w, 1, 0xF00021u);
      PatBlt(hdc, xa, y, 1, h, 0xF00021u);
      SelectObject(hdc, v16);
      PatBlt(hdc, xa, h + y - 1, w, 1, 0xF00021u);
      PatBlt(hdc, w + xa - 1, y, 1, h, 0xF00021u);
      SelectObject(hdc, v10);
      PatBlt(hdc, xa + 1, y + 1, w - 2, h - 2, 0xF00021u);
      SelectObject(hdc, v11);
    }
  }
}

//----- (6F79FD0F) --------------------------------------------------------
LONG __stdcall FlatSB_Internal_DrawArrow(HGDIOBJ h, HDC hdc, RECT *lprcSrc, int y, int mode)
{
  int v5; // edi@1
  LONG result; // eax@1
  int v7; // edx@1
  bool v8; // sf@1
  unsigned __int8 v9; // of@1
  int v10; // ebx@3
  int v11; // ecx@5
  int v12; // ecx@10
  bool v13; // zf@11
  HDC v14; // ebx@30
  int v15; // ecx@33
  int v16; // edi@33
  int v17; // eax@36
  int v18; // edi@36
  struct tagRECT rcDst; // [sp+4h] [bp-18h]@20
  int x; // [sp+14h] [bp-8h]@1
  HGDIOBJ v21; // [sp+18h] [bp-4h]@1
  HGDIOBJ ha; // [sp+24h] [bp+8h]@26
  HFONT hb; // [sp+24h] [bp+8h]@42
  HDC hdca; // [sp+28h] [bp+Ch]@33
  COLORREF hdcb; // [sp+28h] [bp+Ch]@41
  const WCHAR *lprcSrca; // [sp+2Ch] [bp+10h]@11
  int ya; // [sp+30h] [bp+14h]@33
  int yb; // [sp+30h] [bp+14h]@36
  int modea; // [sp+34h] [bp+18h]@7
  int modeb; // [sp+34h] [bp+18h]@42

  v5 = (int)lprcSrc;
  v21 = (HGDIOBJ)(mode & 0x200);
  result = lprcSrc->left;
  v7 = mode & 0x100;
  v9 = __OFSUB__(lprcSrc->left, lprcSrc->right);
  v8 = lprcSrc->left - lprcSrc->right < 0;
  x = mode & 0x100;
  if ( !(v8 ^ v9) )
    return result;
  result = lprcSrc->top;
  if ( result >= lprcSrc->bottom )
    return result;
  v10 = y;
  if ( y == 2 || y == 3 )
  {
    result = (LONG)h;
    v11 = *((_DWORD *)h + 44);
  }
  else
  {
    result = (LONG)h;
    v11 = *((_DWORD *)h + 43);
  }
  modea = v11;
  if ( y )
  {
    if ( y == 1 )
    {
      v12 = 0;
      v13 = *(_DWORD *)(result + 188) == 2;
      lprcSrca = L"6";
    }
    else if ( y == 2 )
    {
      v12 = 0;
      v13 = *(_DWORD *)(result + 188) == 5;
      lprcSrca = L"3";
    }
    else
    {
      v12 = y - 3;
      if ( y != 3 )
        return result;
      v13 = *(_DWORD *)(result + 188) == 6;
      lprcSrca = L"4";
    }
  }
  else
  {
    v12 = 0;
    v13 = *(_DWORD *)(result + 188) == 1;
    lprcSrca = L"5";
  }
  LOBYTE(v12) = v13;
  if ( !v7 && v12 && *(_DWORD *)(result + 92) )
    v21 = (HGDIOBJ)1;
  if ( !modea )
  {
    CopyRect(&rcDst, (const RECT *)v5);
    if ( x )
    {
      v10 = y | 0x100;
    }
    else if ( v21 )
    {
      v10 = y | 0x4000;
    }
    return DrawFrameControl(hdc, &rcDst, 3u, v10);
  }
  if ( v7 )
  {
    ha = (HGDIOBJ)3;
  }
  else if ( v21 )
  {
    ha = (HGDIOBJ)2;
  }
  else
  {
    ha = (HGDIOBJ)(v12 != 0);
  }
  v14 = hdc;
  if ( modea == 1 )
    FlatSB_Internal_DrawEncartaBox(hdc, v5, ha);
  else
    FlatSB_Internal_DrawBox(hdc, v5, ha);
  hdca = *(HDC *)v5;
  v15 = *(_DWORD *)(v5 + 12) - *(_DWORD *)(v5 + 4);
  ya = *(_DWORD *)(v5 + 4);
  v16 = *(_DWORD *)(v5 + 8) - *(_DWORD *)v5;
  result = v16;
  if ( v16 >= v15 )
    v16 = v15;
  if ( v16 >= 4 )
  {
    x = (int)((char *)hdca + (result - v16) / 2 + 2);
    v17 = (v15 - v16) / 2 + ya + 2;
    v18 = v16 - 4;
    yb = v17;
    if ( modea == 2 )
    {
      if ( ha && (signed int)ha > 0 )
      {
        if ( (signed int)ha <= 2 )
        {
          hdcb = 0xFFFFFF;
          goto LABEL_42;
        }
        if ( ha == (HGDIOBJ)3 )
        {
LABEL_41:
          hdcb = GetSysColor(16);
LABEL_42:
          hb = CreateFontW(v18, 0, 0, 0, 400, 0, 0, 0, 2u, 0, 0, 0, 0, L"MARLETT");
          modeb = SetBkMode(v14, 1);
          v21 = SelectObject(v14, hb);
          SetTextColor(v14, hdcb);
          TextOutW(v14, x, yb, lprcSrca, 1);
          SetBkMode(v14, modeb);
          SelectObject(v14, v21);
          return DeleteObject(hb);
        }
      }
    }
    else if ( ha == (HGDIOBJ)3 )
    {
      goto LABEL_41;
    }
    hdcb = 0;
    goto LABEL_42;
  }
  return result;
}
// 6F79FF70: using guessed type wchar_t a5[2];
// 6F79FF74: using guessed type wchar_t a6[2];
// 6F79FF78: using guessed type wchar_t a3[2];
// 6F79FF7C: using guessed type wchar_t a4[2];

//----- (6F79FF85) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawElevator(int a1, HDC hdc, RECT *lprcSrc, int a4)
{
  int v4; // ecx@1
  bool v5; // zf@2
  int v6; // esi@4
  signed int v7; // ecx@5
  void *v8; // eax@11
  struct tagRECT rcDst; // [sp+4h] [bp-10h]@16

  v4 = 0;
  if ( a4 )
    v5 = *(_DWORD *)(a1 + 188) == 3;
  else
    v5 = *(_DWORD *)(a1 + 188) == 7;
  LOBYTE(v4) = v5;
  v6 = v4;
  if ( a4 )
    v7 = *(_DWORD *)(a1 + 172);
  else
    v7 = *(_DWORD *)(a1 + 176);
  if ( v7 <= 0 || v7 > 2 )
  {
    CopyRect(&rcDst, lprcSrc);
    DrawFrameControl(hdc, &rcDst, 4u, 0x10u);
  }
  else
  {
    if ( *(_DWORD *)(a1 + 68) != 4 || a4 != *(_DWORD *)(a1 + 96) )
      v8 = (void *)(v6 != 0);
    else
      v8 = (void *)1;
    if ( v7 == 2 )
      FlatSB_Internal_DrawBox(hdc, (int)lprcSrc, v8);
    else
      FlatSB_Internal_DrawEncartaBox(hdc, (int)lprcSrc, v8);
  }
}

//----- (6F7A0023) --------------------------------------------------------
int __stdcall FlatSB_Internal_DrawGroove(HBRUSH hbr, HDC hDC, RECT *lprc, COLORREF color)
{
  HBRUSH v4; // eax@1
  HBRUSH v5; // edx@2
  COLORREF v6; // edi@2
  HBRUSH v7; // eax@5
  int result; // eax@5
  HPALETTE v9; // eax@6
  HDC v10; // ebx@6
  COLORREF v11; // eax@8
  HPALETTE hPal; // [sp+4h] [bp-4h]@1
  HBRUSH hbra; // [sp+10h] [bp+8h]@4
  COLORREF hDCa; // [sp+14h] [bp+Ch]@8
  COLORREF colora; // [sp+1Ch] [bp+14h]@8

  v4 = hbr;
  hPal = 0;
  if ( color )
  {
    v5 = (HBRUSH)*((_DWORD *)hbr + 50);
    v6 = *((_DWORD *)hbr + 48);
  }
  else
  {
    v5 = (HBRUSH)*((_DWORD *)hbr + 51);
    v6 = *((_DWORD *)hbr + 49);
  }
  hbra = v5;
  if ( v5 )
  {
    v9 = (HPALETTE)*((_DWORD *)v4 + 54);
    v10 = hDC;
    if ( v9 )
    {
      hPal = SelectPalette(hDC, v9, 1);
      RealizePalette(hDC);
    }
    v11 = GetSysColor(15);
    hDCa = SetTextColor(hDC, v11);
    colora = SetBkColor(v10, v6);
    FillRect(v10, lprc, hbra);
    if ( hPal )
      SelectPalette(v10, hPal, 1);
    SetTextColor(v10, hDCa);
    result = SetBkColor(v10, colora);
  }
  else
  {
    v7 = GetSysColorBrush(22);
    result = FillRect(hDC, lprc, v7);
  }
  return result;
}

//----- (6F7A00EB) --------------------------------------------------------
int __stdcall FlatSB_Internal_SBPosFromPx(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@3
  int result; // eax@4
  int v5; // eax@6
  int v6; // ecx@7
  int v7; // eax@10
  int v8; // eax@11
  int v9; // eax@12
  int v10; // ecx@14
  int v11; // edx@15
  int v12; // edx@16

  v2 = a1 + 244;
  if ( !*(_DWORD *)(a1 + 96) )
    v2 = a1 + 228;
  v3 = *(_DWORD *)(a1 + 52);
  if ( a2 >= v3 )
  {
    if ( a2 < *(_DWORD *)(a1 + 24) )
    {
      v7 = *(_DWORD *)(a1 + 64);
      if ( v7 )
      {
        v11 = *(_DWORD *)(v2 + 8);
        if ( v11 )
          v12 = v11 - 1;
        else
          v12 = 0;
        v10 = MulDiv(*(_DWORD *)(v2 + 4) - *(_DWORD *)v2 - v12, a2 - v3, v7);
      }
      else
      {
        v8 = *(_DWORD *)(v2 + 8);
        if ( v8 )
          v9 = v8 - 1;
        else
          v9 = 0;
        v10 = *(_DWORD *)(v2 + 4) - *(_DWORD *)v2 - v9;
      }
      result = v10 + *(_DWORD *)v2;
    }
    else
    {
      v5 = *(_DWORD *)(v2 + 8);
      if ( v5 )
        v6 = v5 - 1;
      else
        v6 = 0;
      result = *(_DWORD *)(v2 + 4) - v6;
    }
  }
  else
  {
    result = *(_DWORD *)v2;
  }
  return result;
}

//----- (6F7A017A) --------------------------------------------------------
int __stdcall FlatSB_Internal_InvertScrollHilite(int a1)
{
  HWND v1; // esi@1
  int result; // eax@1
  HDC v3; // ebx@2

  v1 = *(HWND *)(a1 + 220);
  result = IsRectEmpty((const RECT *)(a1 + 156));
  if ( !result )
  {
    v3 = GetWindowDC(v1);
    InvertRect(v3, (const RECT *)(a1 + 156));
    result = ReleaseDC(v1, v3);
  }
  return result;
}

//----- (6F7A01C1) --------------------------------------------------------
int __stdcall FlatSB_Internal_DrawInvertScrollArea(HGDIOBJ h, int a2, int a3)
{
  HWND v3; // ebx@1
  int result; // eax@3
  HDC v5; // edi@4

  v3 = (HWND)*((_DWORD *)h + 55);
  if ( a3 && a3 != 1 )
  {
    FlatSB_Internal_InvertScrollHilite((int)h);
    result = FlatSB_Internal_NotifyWinEvent((int)h, 32778, 2 * (a3 != 2) + 2);
  }
  else
  {
    v5 = GetWindowDC(v3);
    if ( a3 )
    {
      if ( *((_DWORD *)h + 24) )
        FlatSB_Internal_DrawArrow(h, v5, (RECT *)((char *)h + 156), 1, a2 != 0 ? 0x200 : 0);
      else
        FlatSB_Internal_DrawArrow(h, v5, (RECT *)((char *)h + 156), 3, a2 != 0 ? 0x200 : 0);
    }
    else if ( *((_DWORD *)h + 24) )
    {
      FlatSB_Internal_DrawArrow(h, v5, (RECT *)((char *)h + 156), 0, a2 != 0 ? 0x200 : 0);
    }
    else
    {
      FlatSB_Internal_DrawArrow(h, v5, (RECT *)((char *)h + 156), 2, a2 != 0 ? 0x200 : 0);
    }
    FlatSB_Internal_NotifyWinEvent((int)h, 32778, 4 * (a3 != 0) + 1);
    result = ReleaseDC(v3, v5);
  }
  return result;
}

//----- (6F7A0298) --------------------------------------------------------
LRESULT __stdcall FlatSB_Internal_DoScroll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4)
{
  LRESULT result; // eax@1

  result = *(_DWORD *)(a1 + 220);
  if ( result )
  {
    ++*(_DWORD *)(a1 + 112);
    result = SendMessageW((HWND)result, (a4 != 0) + 276, a2 | (a3 << 16), 0);
    --*(_DWORD *)(a1 + 112);
  }
  return result;
}

//----- (6F7A02E1) --------------------------------------------------------
void __stdcall TimerScroll(HWND hWnd, UINT a2, UINT a3, DWORD a4)
{
  DWORD v4; // kr00_4@3
  unsigned int v5; // ebx@3
  struct tagRECT Rect; // [sp+8h] [bp-14h]@3
  DWORD_PTR pdwRefData; // [sp+18h] [bp-4h]@1

  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, &pdwRefData);
  if ( pdwRefData && pdwRefData != -1 )
  {
    v4 = GetMessagePos();
    v5 = 4 * GetDoubleClickTime() / 5;
    GetWindowRect(hWnd, &Rect);
    FlatSB_Internal_TrackBox(
      (HGDIOBJ)pdwRefData,
      0,
      0,
      (unsigned __int16)(v4 - Rect.left) | ((unsigned __int16)(HIWORD(v4) - LOWORD(Rect.top)) << 16));
    if ( *(_DWORD *)(pdwRefData + 92) )
    {
      *(_DWORD *)(pdwRefData + 116) = SetTimer(hWnd, 0xFFFEu, v5 >> 3, TimerScroll);
      FlatSB_Internal_DoScroll(pdwRefData, *(_DWORD *)(pdwRefData + 68), 0, *(_DWORD *)(pdwRefData + 96));
    }
  }
  else
  {
    KillTimer(hWnd, 0xFFFEu);
  }
}

//----- (6F7A03B0) --------------------------------------------------------
void __stdcall FlatSB_Internal_SBTrackLoop(int a1, int a2)
{
  HWND v2; // edi@1
  UINT v3; // edx@5
  struct tagMSG Msg; // [sp+Ch] [bp-1Ch]@3

  v2 = *(HWND *)(a1 + 220);
  if ( *(_DWORD *)(a1 + 100) )
  {
    FlatSB_Internal_NotifyWinEvent(a1, 18, 0);
    (*(void (__stdcall **)(int, signed int, _DWORD, int))(a1 + 84))(a1, 513, 0, a2);
    while ( GetCapture() == v2 && GetMessageW(&Msg, 0, 0, 0) )
    {
      if ( !CallMsgFilterW(&Msg, 5) )
      {
        v3 = Msg.message;
        if ( Msg.hwnd != v2
          || ((signed int)Msg.message < 512 || (signed int)Msg.message > 525)
          && ((signed int)Msg.message < 256 || (signed int)Msg.message > 264) )
        {
          TranslateMessage(&Msg);
          DispatchMessageW(&Msg);
        }
        else
        {
          if ( (signed int)Msg.message >= 260 && (signed int)Msg.message <= 263 )
          {
            if ( Msg.lParam & 0x20000000 )
              v3 = Msg.message - 4;
          }
          if ( !*(_DWORD *)(a1 + 100) )
            return;
          (*(void (__stdcall **)(int, UINT, WPARAM, int))(a1 + 84))(
            a1,
            v3,
            Msg.wParam,
            (unsigned __int16)(*(_WORD *)(a1 + 140) + LOWORD(Msg.lParam)) | ((unsigned __int16)(*(_WORD *)(a1 + 144)
                                                                                              + HIWORD(Msg.lParam)) << 16));
        }
      }
    }
  }
}

//----- (6F7A04B8) --------------------------------------------------------
int __stdcall FlatSB_Internal_InitPwSB(int a1)
{
  int result; // eax@1
  int v2; // ebx@1
  HBITMAP v3; // eax@2
  void *v4; // esi@2
  HBRUSH v5; // eax@3
  int Bits; // [sp+4h] [bp-10h]@2
  int v7; // [sp+8h] [bp-Ch]@2
  int v8; // [sp+Ch] [bp-8h]@2
  int v9; // [sp+10h] [bp-4h]@2

  result = (int)LocalAlloc(0x40u, 0x138u);
  v2 = result;
  if ( result )
  {
    Bits = 5570730;
    v7 = 5570730;
    v8 = 5570730;
    v9 = 5570730;
    *(_DWORD *)(result + 232) = 100;
    *(_DWORD *)(result + 248) = 100;
    *(_DWORD *)(result + 220) = a1;
    FlatSB_InitWSBMetrics(result);
    qmemcpy((void *)(v2 + 264), (const void *)(v2 + 288), 0x18u);
    *(_DWORD *)(v2 + 260) = g_bRunOnNT5 != 0 ? 8 : 2;
    v3 = CreateBitmap(8, 8, 1u, 1u, &Bits);
    v4 = v3;
    if ( !v3 )
    {
LABEL_5:
      LocalFree((HLOCAL)v2);
      return 0;
    }
    v5 = CreatePatternBrush(v3);
    *(_DWORD *)(v2 + 200) = v5;
    if ( !v5 )
    {
      DeleteObject(v4);
      goto LABEL_5;
    }
    *(_DWORD *)(v2 + 180) = -1;
    *(_DWORD *)(v2 + 184) = -1;
    *(_DWORD *)(v2 + 204) = v5;
    *(_DWORD *)(v2 + 208) = v5;
    *(_DWORD *)(v2 + 196) = 0xFFFFFF;
    *(_DWORD *)(v2 + 192) = 0xFFFFFF;
    *(_DWORD *)(v2 + 212) = v4;
    *(_DWORD *)(v2 + 172) = 2;
    *(_DWORD *)(v2 + 176) = 2;
    result = v2;
  }
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7A05B7) --------------------------------------------------------
int __stdcall FlatSB_Internal_GetSBFlags(int a1, int a2)
{
  int result; // eax@1
  signed int v3; // eax@2

  result = a1;
  if ( a1 )
  {
    v3 = *(_DWORD *)(a1 + 224);
    if ( a2 )
      v3 >>= 2;
    result = v3 & 3;
  }
  return result;
}

//----- (6F7A05DE) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawThumb2(HBRUSH hbr, HDC hDC, COLORREF color, char a4)
{
  int v4; // ecx@2
  HBRUSH v5; // edi@3
  HBRUSH v6; // eax@4
  int v7; // eax@8
  int v8; // eax@12
  int v9; // ecx@14
  HBRUSH v10; // eax@17

  if ( *((_DWORD *)hbr + 12) < *((_DWORD *)hbr + 5) )
  {
    v4 = *((_DWORD *)hbr + 7);
    if ( v4 < *((_DWORD *)hbr + 9) )
    {
      v5 = hbr + 31;
      if ( color )
      {
        v6 = hbr + 31;
        v5 = hbr + 32;
      }
      else
      {
        v6 = hbr + 32;
      }
      *(_DWORD *)v6 = v4;
      *((_DWORD *)v6 + 2) = *((_DWORD *)hbr + 9);
      if ( a4 & 1 && a4 & 2 || (v7 = *((_DWORD *)hbr + 13), *((_DWORD *)hbr + 6) - v7 < *((_DWORD *)hbr + 14)) )
      {
        *(_DWORD *)v5 = *((_DWORD *)hbr + 13);
        *((_DWORD *)v5 + 2) = *((_DWORD *)hbr + 6);
        FlatSB_Internal_DrawGroove(hbr, hDC, (RECT *)(hbr + 31), color);
      }
      else
      {
        if ( v7 <= *((_DWORD *)hbr + 11) )
        {
          *(_DWORD *)v5 = v7;
          *((_DWORD *)v5 + 2) = *((_DWORD *)hbr + 11);
          FlatSB_Internal_DrawGroove(hbr, hDC, (RECT *)(hbr + 31), color);
        }
        v8 = *((_DWORD *)hbr + 10);
        if ( v8 <= *((_DWORD *)hbr + 6) )
        {
          *(_DWORD *)v5 = v8;
          *((_DWORD *)v5 + 2) = *((_DWORD *)hbr + 6);
          FlatSB_Internal_DrawGroove(hbr, hDC, (RECT *)(hbr + 31), color);
        }
        *(_DWORD *)v5 = *((_DWORD *)hbr + 11);
        *((_DWORD *)v5 + 2) = *((_DWORD *)hbr + 10);
        FlatSB_Internal_DrawElevator((int)hbr, hDC, (RECT *)(hbr + 31), color);
        v9 = *((_DWORD *)hbr + 17);
        if ( (v9 == 2 || v9 == 3) && *((_DWORD *)hbr + 24) == color )
        {
          v10 = hbr + 39;
          if ( color )
            v10 = hbr + 40;
          if ( v9 == 2 )
            *((_DWORD *)v10 + 2) = *((_DWORD *)hbr + 11);
          else
            *(_DWORD *)v10 = *((_DWORD *)hbr + 10);
          if ( *(_DWORD *)v10 < *((_DWORD *)v10 + 2) )
            InvertRect(hDC, (const RECT *)(hbr + 39));
        }
      }
    }
  }
}

//----- (6F7A06F6) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawSB2(HGDIOBJ a1, HDC hdc, COLORREF color, int a4, int a5)
{
  HBRUSH v5; // esi@1
  __int64 v6; // rax@1
  int v7; // edi@1
  int v8; // eax@3
  int v9; // eax@4
  int v10; // ecx@8
  int v11; // eax@8
  HBRUSH v12; // eax@10
  struct tagRECT rcDst; // [sp+8h] [bp-18h]@10
  HGDIOBJ h; // [sp+18h] [bp-8h]@10
  int v15; // [sp+1Ch] [bp-4h]@1
  int v16; // [sp+28h] [bp+8h]@1

  v5 = (HBRUSH)a1;
  v15 = *((_DWORD *)a1 + 47);
  v16 = FlatSB_Internal_GetSBFlags((int)a1, color);
  v6 = *((_DWORD *)v5 + 5) - *((_DWORD *)v5 + 12);
  v7 = ((signed int)v6 - HIDWORD(v6)) >> 1;
  if ( v7 > 0 && *((_DWORD *)v5 + 9) - *((_DWORD *)v5 + 7) > 0 )
  {
    v8 = *(_DWORD *)v5;
    if ( color )
      v9 = *(_DWORD *)(v8 + 12);
    else
      v9 = *(_DWORD *)(v8 + 4);
    if ( v7 > v9 )
      v7 = v9;
    v10 = (int)(v5 + 31);
    v11 = (int)(v5 + 32);
    if ( !color )
    {
      v10 = (int)(v5 + 32);
      v11 = (int)(v5 + 31);
    }
    *(_DWORD *)v10 = *((_DWORD *)v5 + 7);
    *(_DWORD *)v11 = *((_DWORD *)v5 + 12);
    *(_DWORD *)(v10 + 8) = *((_DWORD *)v5 + 9);
    *(_DWORD *)(v11 + 8) = *((_DWORD *)v5 + 5);
    v12 = GetSysColorBrush(18);
    h = SelectObject(hdc, v12);
    CopyRect(&rcDst, (const RECT *)(v5 + 31));
    if ( color )
    {
      rcDst.bottom = v7 + rcDst.top;
      if ( !a4 || v15 == 1 || a5 == 1 )
        FlatSB_Internal_DrawArrow(v5, hdc, &rcDst, 0, (v16 & 1) << 8);
      rcDst.bottom = *((_DWORD *)v5 + 34);
      rcDst.top = rcDst.bottom - v7;
      if ( !a4 || v15 == 2 || a5 == 2 )
        FlatSB_Internal_DrawArrow(v5, hdc, &rcDst, 1, (v16 & 2) << 7);
    }
    else
    {
      rcDst.right = v7 + rcDst.left;
      if ( !a4 || v15 == 5 || a5 == 5 )
        FlatSB_Internal_DrawArrow(v5, hdc, &rcDst, 2, (v16 & 1) << 8);
      rcDst.right = *((_DWORD *)v5 + 33);
      rcDst.left = rcDst.right - v7;
      if ( !a4 || v15 == 6 || a5 == 6 )
        FlatSB_Internal_DrawArrow(v5, hdc, &rcDst, 3, (v16 & 2) << 7);
    }
    SelectObject(hdc, h);
    FlatSB_Internal_DrawThumb2(v5, hdc, color, v16);
  }
}

//----- (6F7A088E) --------------------------------------------------------
int __stdcall FlatSB_Internal_CalcSBStuff2(int nNumber, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // eax@2
  int v6; // ebx@2
  int v7; // edi@2
  int v8; // eax@2
  int v9; // eax@3
  int v10; // edi@4
  int v11; // ecx@6
  int v12; // eax@6
  signed int v13; // ecx@9
  int v14; // eax@13
  signed int v15; // eax@19
  int v16; // eax@22
  signed int v17; // eax@24
  int result; // eax@27
  bool v19; // zf@27
  signed int v20; // [sp-4h] [bp-3Ch]@36
  int v21; // [sp+Ch] [bp-2Ch]@6
  int v22; // [sp+10h] [bp-28h]@6
  int v23; // [sp+14h] [bp-24h]@2
  int v24; // [sp+18h] [bp-20h]@4
  int v25; // [sp+1Ch] [bp-1Ch]@6
  int v26; // [sp+20h] [bp-18h]@2
  int v27; // [sp+24h] [bp-14h]@2
  int v28; // [sp+28h] [bp-10h]@2
  int v29; // [sp+2Ch] [bp-Ch]@2
  int v30; // [sp+30h] [bp-8h]@2
  int nNumerator; // [sp+34h] [bp-4h]@2
  int nNumbera; // [sp+40h] [bp+8h]@6
  int nNumberb; // [sp+40h] [bp+8h]@18
  int v34; // [sp+44h] [bp+Ch]@2

  v3 = nNumber;
  if ( a3 )
  {
    v4 = *(_DWORD *)(a2 + 4);
    v29 = *(_DWORD *)(a2 + 12);
    v26 = *(_DWORD *)(a2 + 8);
    v27 = *(_DWORD *)a2;
    v34 = *(_DWORD *)(*(_DWORD *)nNumber + 20);
    v5 = *(_DWORD *)(nNumber + 244);
    v6 = *(_DWORD *)(nNumber + 256) - v5;
    v7 = *(_DWORD *)(nNumber + 248) - v5;
    v30 = *(_DWORD *)(*(_DWORD *)nNumber + 12);
    v23 = *(_DWORD *)(nNumber + 184);
    v8 = *(_DWORD *)(nNumber + 104);
    v28 = v4;
    nNumerator = *(_DWORD *)(nNumber + 252);
  }
  else
  {
    v28 = *(_DWORD *)a2;
    v29 = *(_DWORD *)(a2 + 8);
    v26 = *(_DWORD *)(a2 + 12);
    v27 = *(_DWORD *)(a2 + 4);
    v34 = *(_DWORD *)(*(_DWORD *)nNumber + 8);
    v9 = *(_DWORD *)(nNumber + 228);
    v6 = *(_DWORD *)(nNumber + 240) - v9;
    v30 = *(_DWORD *)(*(_DWORD *)nNumber + 4);
    v7 = *(_DWORD *)(nNumber + 232) - v9;
    nNumerator = *(_DWORD *)(nNumber + 236);
    v4 = v28;
    v23 = *(_DWORD *)(nNumber + 180);
    v8 = *(_DWORD *)(nNumber + 108);
  }
  v24 = v8;
  v10 = v7 + 1;
  if ( (v29 - v4) >> 1 < v30 )
    v30 = (v29 - v4) >> 1;
  v11 = v30 + v4;
  v22 = v29 - v30;
  v12 = v29 - v30 - v11;
  v25 = v11;
  v21 = v29 - v30 - v11;
  nNumbera = v29 - v30 - v11;
  if ( nNumerator )
  {
    if ( v10 )
      v12 = MulDiv(v29 - v30 - v11, nNumerator, v10);
    v13 = v34;
    if ( v34 >= 10 )
      v13 = 10;
    if ( v12 <= v13 )
    {
      if ( v34 >= 10 )
        v34 = 10;
    }
    else
    {
      if ( v10 )
        v14 = MulDiv(nNumbera, nNumerator, v10);
      else
        v14 = nNumbera;
      v34 = v14;
    }
  }
  nNumberb = nNumbera - v34;
  if ( nNumerator )
    v15 = nNumerator;
  else
    v15 = 1;
  if ( v10 == v15 )
  {
    v16 = v6;
  }
  else
  {
    if ( nNumerator )
      v17 = nNumerator;
    else
      v17 = 1;
    v16 = MulDiv(v6, nNumberb, v10 - v17);
  }
  *(_DWORD *)(v3 + 24) = v22;
  *(_DWORD *)(v3 + 60) = v30;
  result = v25 + v16;
  *(_DWORD *)(v3 + 28) = v27;
  *(_DWORD *)(v3 + 56) = v34;
  v19 = *(_DWORD *)(v3 + 100) == 0;
  *(_DWORD *)(v3 + 36) = v26;
  *(_DWORD *)(v3 + 20) = v29;
  *(_DWORD *)(v3 + 64) = nNumberb;
  *(_DWORD *)(v3 + 48) = v28;
  *(_DWORD *)(v3 + 52) = v25;
  *(_DWORD *)(v3 + 44) = result;
  *(_DWORD *)(v3 + 40) = result + v34;
  *(_DWORD *)(v3 + 88) = a3;
  if ( v19 )
  {
    if ( !v24 || v23 < v28 )
      goto LABEL_34;
    if ( v23 < v25 )
    {
      result = 1;
LABEL_41:
      if ( !a3 )
      {
        if ( result )
          result += 4;
      }
      *(_DWORD *)(v3 + 188) = result;
      return result;
    }
    if ( v23 >= result )
    {
      if ( v23 >= v29 )
      {
LABEL_34:
        result = 0;
        goto LABEL_41;
      }
      if ( v23 >= v22 )
      {
        v20 = 2;
LABEL_39:
        result = v20;
        goto LABEL_41;
      }
      if ( v23 < result + v34 )
      {
        result = (v21 <= v34) + 3;
        goto LABEL_41;
      }
    }
    v20 = 4;
    goto LABEL_39;
  }
  return result;
}

//----- (6F7A0AA7) --------------------------------------------------------
int __stdcall FlatSB_Internal_CalcSBStuff(int nNumber, int a2)
{
  int result; // eax@1
  bool v3; // zf@3
  int v4; // ecx@3
  int v5; // ecx@6
  int v6; // [sp+0h] [bp-10h]@3
  int v7; // [sp+4h] [bp-Ch]@5
  int v8; // [sp+8h] [bp-8h]@3
  int v9; // [sp+Ch] [bp-4h]@5

  result = nNumber;
  if ( nNumber )
  {
    if ( a2 )
    {
      v3 = (*(_BYTE *)(nNumber + 4) & 2) == 0;
      v4 = *(_DWORD *)(nNumber + 148);
      v6 = v4;
      v8 = v4;
      if ( !v3 )
        v8 = v4 + **(_DWORD **)nNumber;
      v7 = *(_DWORD *)(nNumber + 144);
      v9 = *(_DWORD *)(nNumber + 152);
    }
    else
    {
      v3 = (*(_BYTE *)(nNumber + 4) & 4) == 0;
      v5 = *(_DWORD *)(nNumber + 152);
      v7 = v5;
      v9 = v5;
      if ( !v3 )
        v9 = v5 + *(_DWORD *)(*(_DWORD *)nNumber + 16);
      v6 = *(_DWORD *)(nNumber + 140);
      v8 = *(_DWORD *)(nNumber + 148);
    }
    result = FlatSB_Internal_CalcSBStuff2(nNumber, (int)&v6, a2);
  }
  return result;
}

//----- (6F7A0B2F) --------------------------------------------------------
int __stdcall FlatSB_Internal_DrawThumb(HBRUSH hbr, COLORREF color)
{
  HWND v2; // edi@1
  HDC v3; // ebx@1
  char v4; // al@1

  v2 = (HWND)*((_DWORD *)hbr + 55);
  v3 = GetWindowDC(*((HWND *)hbr + 55));
  FlatSB_Internal_CalcSBStuff((int)hbr, color);
  v4 = FlatSB_Internal_GetSBFlags((int)hbr, color);
  FlatSB_Internal_DrawThumb2(hbr, v3, color, v4);
  return ReleaseDC(v2, v3);
}

//----- (6F7A0B7A) --------------------------------------------------------
signed int __stdcall FlatSB_Internal_SBSetParms(int a1, int a2, char a3, int a4, int a5, unsigned int a6, int a7, int a8, int a9, int a10, int a11)
{
  char v11; // bl@3
  int v12; // eax@4
  unsigned int v13; // edi@9
  int v14; // esi@12
  __int64 v15; // rax@17
  unsigned int v16; // eax@17
  int v17; // eax@24
  int v18; // edx@25
  int v19; // eax@36
  signed int v21; // [sp+0h] [bp-4h]@1

  v21 = 0;
  if ( a11 )
    *(_DWORD *)a10 = *(_DWORD *)(a1 + 12);
  v11 = a3;
  if ( !(a3 & 1) )
    goto LABEL_43;
  v12 = a5;
  if ( a5 < a4 )
    v12 = a4;
  if ( *(_DWORD *)a1 != a4 || *(_DWORD *)(a1 + 4) != v12 )
  {
    *(_DWORD *)a1 = a4;
    *(_DWORD *)(a1 + 4) = v12;
    if ( a3 & 2 )
    {
      v13 = a6;
    }
    else
    {
      v13 = *(_DWORD *)(a1 + 8);
      v11 = a3 | 2;
    }
    if ( v11 & 4 )
    {
      v14 = a7;
    }
    else
    {
      v14 = *(_DWORD *)(a1 + 12);
      v11 |= 4u;
    }
    v21 = 1;
  }
  else
  {
LABEL_43:
    v14 = a7;
    v13 = a6;
  }
  if ( v11 & 2 )
  {
    v15 = *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
    v16 = (HIDWORD(v15) ^ v15) - HIDWORD(v15) + 1;
    if ( v13 > v16 )
      v13 = v16;
    if ( *(_DWORD *)(a1 + 8) != v13 )
    {
      *(_DWORD *)(a1 + 8) = v13;
      if ( !(v11 & 4) )
      {
        v14 = *(_DWORD *)(a1 + 12);
        v11 |= 4u;
      }
      v21 = 1;
    }
  }
  if ( v11 & 4 )
  {
    v17 = *(_DWORD *)(a1 + 8);
    if ( v17 )
      v18 = v17 - 1;
    else
      v18 = 0;
    if ( v14 >= *(_DWORD *)a1 )
    {
      if ( v14 > *(_DWORD *)(a1 + 4) - v18 )
        v14 = *(_DWORD *)(a1 + 4) - v18;
    }
    else
    {
      v14 = *(_DWORD *)a1;
    }
    if ( *(_DWORD *)(a1 + 12) != v14 )
    {
      *(_DWORD *)(a1 + 12) = v14;
      v21 = 1;
    }
  }
  if ( !a11 )
    *(_DWORD *)a10 = *(_DWORD *)(a1 + 12);
  if ( v11 & 1 )
  {
    v19 = *(_DWORD *)a1 != *(_DWORD *)(a1 + 4);
    *(_DWORD *)a9 = v19;
    if ( v19 )
      goto LABEL_39;
  }
  else if ( v11 & 2 )
  {
LABEL_39:
    *(_DWORD *)a9 = *(_DWORD *)(a1 + 8) <= *(_DWORD *)(a1 + 4) - *(_DWORD *)a1;
    return v21;
  }
  return v21;
}

//----- (6F7A0C9D) --------------------------------------------------------
void __stdcall FlatSB_Internal_DrawScrollBar(HGDIOBJ a1, HDC hdc, COLORREF color, int a4)
{
  int v4; // edi@1

  v4 = *((_DWORD *)a1 + 47);
  FlatSB_Internal_CalcSBStuff((int)a1, color);
  if ( !a4 || v4 != *((_DWORD *)a1 + 47) )
    FlatSB_Internal_DrawSB2(a1, hdc, color, a4, v4);
}

//----- (6F7A0CDF) --------------------------------------------------------
int __stdcall FlatSB_Internal_IsSizeBox(HWND hWnd)
{
  HWND v1; // edi@1
  int v2; // ebx@1
  int v3; // esi@1
  HWND v4; // eax@3
  int result; // eax@5
  struct tagRECT Rect; // [sp+Ch] [bp-28h]@1
  struct tagRECT v7; // [sp+1Ch] [bp-18h]@8
  struct tagPOINT Point; // [sp+2Ch] [bp-8h]@8
  HWND hWnda; // [sp+3Ch] [bp+8h]@1

  v1 = hWnd;
  hWnda = GetDesktopWindow();
  v2 = GetSystemMetrics(45);
  v3 = GetSystemMetrics(46);
  if ( !GetWindowRect(v1, &Rect) )
    goto LABEL_5;
  while ( !(GetWindowLongW(v1, -16) & 0x40000) )
  {
    v4 = GetParent(v1);
    v1 = v4;
    if ( !v4 || v4 == hWnda )
      goto LABEL_5;
  }
  if ( IsZoomed(v1)
    || (GetClientRect(v1, &v7),
        Point = *(struct tagPOINT *)&v7.right,
        ClientToScreen(v1, &Point),
        v2 + Rect.right < Point.x) )
LABEL_5:
    result = 0;
  else
    result = v3 + Rect.bottom >= Point.y;
  return result;
}

//----- (6F7A0D8E) --------------------------------------------------------
HGDIOBJ __stdcall FlatSB_Internal_DrawSize(int a1, HDC hdc, int x, int y)
{
  HBRUSH v4; // eax@2
  HGDIOBJ v5; // ebx@2
  HGDIOBJ result; // eax@2
  int *v7; // eax@3
  struct tagRECT v8; // [sp+4h] [bp-10h]@3

  if ( FlatSB_Internal_IsSizeBox(*(HWND *)(a1 + 220)) )
  {
    v7 = *(int **)a1;
    v8.left = x;
    v8.right = x + *v7;
    v8.top = y;
    v8.bottom = y + v7[4];
    result = (HGDIOBJ)DrawFrameControl(hdc, &v8, 3u, 8u);
  }
  else
  {
    v4 = GetSysColorBrush(15);
    v5 = SelectObject(hdc, v4);
    PatBlt(hdc, x, y, **(_DWORD **)a1, *(_DWORD *)(*(_DWORD *)a1 + 16), 0xF00021u);
    result = SelectObject(hdc, v5);
  }
  return result;
}

//----- (6F7A0E1E) --------------------------------------------------------
void __stdcall FlatSB_Internal_MoveThumb(HWND hWnd, int a2)
{
  int v2; // esi@1
  HWND v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@8
  HDC v6; // eax@9
  COLORREF v7; // ST08_4@9
  HDC v8; // ebx@9
  int v9; // eax@9
  HWND hWnda; // [sp+14h] [bp+8h]@1

  v2 = (int)hWnd;
  v3 = (HWND)*((_DWORD *)hWnd + 55);
  v4 = a2;
  hWnda = (HWND)*((_DWORD *)hWnd + 55);
  if ( a2 != *(_DWORD *)(v2 + 32) )
  {
    while ( 1 )
    {
      v5 = FlatSB_Internal_SBPosFromPx(v2, v4);
      *(_DWORD *)(v2 + 76) = v5;
      if ( v5 == *(_DWORD *)(v2 + 72) )
        break;
      FlatSB_Internal_DoScroll(v2, 5u, *(_DWORD *)(v2 + 76), *(_DWORD *)(v2 + 96));
      if ( !*(_DWORD *)(v2 + 100) )
        return;
      *(_DWORD *)(v2 + 72) = *(_DWORD *)(v2 + 76);
      if ( *(_DWORD *)(v2 + 96) != *(_DWORD *)(v2 + 88) )
        FlatSB_Internal_CalcSBStuff(v2, *(_DWORD *)(v2 + 96));
      if ( v4 < *(_DWORD *)(v2 + 24) - *(_DWORD *)(v2 + 56) )
        break;
      v4 = *(_DWORD *)(v2 + 24) - *(_DWORD *)(v2 + 56);
    }
    v6 = GetWindowDC(v3);
    v7 = *(_DWORD *)(v2 + 96);
    v8 = v6;
    v9 = v4 + *(_DWORD *)(v2 + 56);
    *(_DWORD *)(v2 + 44) = v4;
    *(_DWORD *)(v2 + 40) = v9;
    FlatSB_Internal_DrawThumb2((HBRUSH)v2, v8, v7, 0);
    ReleaseDC(hWnda, v8);
    *(_DWORD *)(v2 + 32) = v4;
  }
}

//----- (6F7A0EB9) --------------------------------------------------------
void __stdcall FlatSB_Internal_TrackThumb(int nNumber, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  int v6; // edi@4
  POINT v7; // ST04_8@4
  int v8; // eax@5
  int v9; // ecx@8
  int nNumbera; // [sp+Ch] [bp+8h]@1

  v4 = nNumber;
  v5 = *(_DWORD *)(nNumber + 96);
  nNumbera = *(_DWORD *)(nNumber + 96);
  if ( (unsigned int)(a2 - 512) <= 0xD )
  {
    if ( v5 != *(_DWORD *)(v4 + 88) )
      FlatSB_Internal_CalcSBStuff(v4, v5);
    v6 = (signed __int16)a4;
    v7.y = SHIWORD(a4);
    v7.x = (signed __int16)a4;
    if ( PtInRect((const RECT *)(v4 + 156), v7) )
    {
      if ( nNumbera )
        v6 = SHIWORD(a4);
      v9 = v6 + *(_DWORD *)(v4 + 16);
      v8 = *(_DWORD *)(v4 + 52);
      *(_DWORD *)(v4 + 8) = v9;
      if ( v9 >= v8 )
      {
        v8 = *(_DWORD *)(v4 + 24) - *(_DWORD *)(v4 + 56);
        if ( v9 < v8 )
          goto LABEL_11;
      }
    }
    else
    {
      v8 = *(_DWORD *)(v4 + 12);
    }
    *(_DWORD *)(v4 + 8) = v8;
LABEL_11:
    FlatSB_Internal_MoveThumb((HWND)v4, *(_DWORD *)(v4 + 8));
    if ( a2 == 514 )
      FlatSB_Internal_EndScroll((HGDIOBJ)v4, 0);
  }
}

//----- (6F7A0F53) --------------------------------------------------------
int __stdcall FlatSB_Internal_RedrawScrollBar(HGDIOBJ a1, COLORREF color)
{
  HDC v2; // ebx@1

  v2 = GetWindowDC(*((HWND *)a1 + 55));
  FlatSB_Internal_DrawScrollBar(a1, v2, color, 1);
  return ReleaseDC(*((HWND *)a1 + 55), v2);
}

//----- (6F7A0F8F) --------------------------------------------------------
int __stdcall FlatSB_Internal_EnableScrollBar(HDC hDC, UINT wSBflags, UINT wArrows)
{
  HDC v3; // esi@1
  HWND v4; // ebx@1
  int v5; // edi@1
  int v7; // edi@24
  HDC v8; // eax@24
  int v9; // ebx@25
  HWND hWnd; // [sp+Ch] [bp-10h]@1
  signed int v11; // [sp+10h] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-8h]@1
  signed int v13; // [sp+18h] [bp-4h]@1
  HDC hDCa; // [sp+24h] [bp+8h]@1
  HDC hDCb; // [sp+24h] [bp+8h]@24

  v3 = hDC;
  v4 = (HWND)*((_DWORD *)hDC + 55);
  v5 = *((_DWORD *)hDC + 56);
  v13 = 0;
  v12 = 0;
  v11 = 0;
  hWnd = (HWND)*((_DWORD *)hDC + 55);
  hDCa = (HDC)GetWindowLongW(v4, -16);
  if ( wSBflags )
  {
    if ( wSBflags == 1 )
      goto LABEL_15;
    if ( wSBflags != 3 )
      return 0;
  }
  if ( wArrows )
    *((_DWORD *)v3 + 56) |= wArrows;
  else
    *((_DWORD *)v3 + 56) &= 0xFFFFFFFC;
  if ( v5 != *((_DWORD *)v3 + 56) )
  {
    v13 = 1;
    if ( *((_BYTE *)v3 + 4) & 4 )
    {
      if ( !((unsigned int)hDCa & 0x20000000) && IsWindowVisible(v4) )
        v12 = 1;
    }
  }
  if ( !wSBflags )
  {
LABEL_23:
    if ( !v12 )
      goto LABEL_32;
    goto LABEL_24;
  }
  v5 = *((_DWORD *)v3 + 56);
LABEL_15:
  if ( wArrows )
    *((_DWORD *)v3 + 56) |= 4 * wArrows;
  else
    *((_DWORD *)v3 + 56) &= 0xFFFFFFF3;
  if ( v5 == *((_DWORD *)v3 + 56) )
    goto LABEL_23;
  v13 = 1;
  if ( !(*((_BYTE *)v3 + 4) & 2) || (unsigned int)hDCa & 0x20000000 || !IsWindowVisible(v4) )
    goto LABEL_23;
  v11 = 1;
LABEL_24:
  v7 = *((_DWORD *)v3 + 47);
  v8 = GetWindowDC(v4);
  hDCb = v8;
  if ( !v8 )
    return 0;
  v9 = v7;
  if ( v12 )
  {
    FlatSB_Internal_DrawScrollBar(v3, v8, 0, 0);
    if ( *((_DWORD *)v3 + 27) )
      v9 = *((_DWORD *)v3 + 47);
  }
  if ( v11 )
  {
    *((_DWORD *)v3 + 47) = v7;
    FlatSB_Internal_DrawScrollBar(v3, hDCb, 1u, 0);
    if ( *((_DWORD *)v3 + 26) )
      v9 = *((_DWORD *)v3 + 47);
  }
  *((_DWORD *)v3 + 47) = v9;
  ReleaseDC(hWnd, hDCb);
  v4 = hWnd;
LABEL_32:
  if ( v13 )
    EnableScrollBar(v4, wSBflags, wArrows);
  return v13;
}

//----- (6F7A1104) --------------------------------------------------------
int __stdcall FlatSB_Internal_SetScrollBar(int nNumber, int nBar, LPCSCROLLINFO lpsi, int a4)
{
  int v4; // ebx@1
  HWND v5; // eax@1
  LPCSCROLLINFO v6; // esi@3
  UINT v7; // edx@3
  int v8; // ebx@3
  int v9; // edi@3
  int v10; // ebx@3
  int v12; // esi@6
  int v13; // eax@18
  int v14; // eax@19
  bool v15; // zf@24
  int v16; // [sp-28h] [bp-44h]@6
  char v17; // [sp-24h] [bp-40h]@6
  int v18; // [sp-20h] [bp-3Ch]@6
  int v19; // [sp-1Ch] [bp-38h]@6
  unsigned int v20; // [sp-18h] [bp-34h]@6
  int v21; // [sp-14h] [bp-30h]@6
  int v22; // [sp-10h] [bp-2Ch]@6
  int v23; // [sp-8h] [bp-24h]@24
  COLORREF v24; // [sp-4h] [bp-20h]@24
  COLORREF v25; // [sp+Ch] [bp-10h]@3
  COLORREF color; // [sp+10h] [bp-Ch]@3
  HWND hwnd; // [sp+14h] [bp-8h]@1
  int v28; // [sp+18h] [bp-4h]@3

  v4 = nNumber;
  v5 = *(HWND *)(nNumber + 220);
  hwnd = *(HWND *)(nNumber + 220);
  if ( a4 )
    a4 = IsWindowVisible(v5);
  v6 = lpsi;
  v7 = lpsi->fMask;
  v8 = *(_DWORD *)(v4 + 4);
  color = nBar != 0;
  v9 = v7 == 4;
  v10 = (((-color & 0x100000) + 0x100000) & v8) != 0;
  v25 = (-color & 0x100000) + 0x100000;
  v28 = v10;
  if ( !(v7 & 1) && !v10 )
    return 0;
  SetScrollInfo(hwnd, nBar, lpsi, 0);
  qmemcpy(&v16, v6, 0x1Cu);
  v12 = nNumber;
  if ( !FlatSB_Internal_SBSetParms(
          nNumber + 4 * (4 * (color != 0) + 1) + 224,
          v16,
          v17,
          v18,
          v19,
          v20,
          v21,
          v22,
          (int)&v28,
          (int)&nNumber,
          v9) )
  {
    if ( !v10 || !a4 )
      return nNumber;
    goto LABEL_24;
  }
  if ( v28 )
    *(_DWORD *)(v12 + 4) |= v25;
  else
    *(_DWORD *)(v12 + 4) &= ~v25;
  SetWindowBits(hwnd, -16, 3145728, *(_DWORD *)(v12 + 4));
  if ( lpsi->fMask & 8 )
  {
    if ( v10 )
    {
      *(_DWORD *)(v12 + 4) |= v25;
      SetWindowBits(hwnd, -16, 3145728, *(_DWORD *)(v12 + 4));
      FlatSB_Internal_EnableScrollBar((HDC)v12, nBar, v28 != 0 ? 0 : 3);
    }
LABEL_16:
    if ( !v28 || !a4 )
      return nNumber;
    v13 = *(_DWORD *)(v12 + 4);
    v14 = color ? v13 & 2 : v13 & 4;
    if ( !v14 )
      return nNumber;
LABEL_24:
    v15 = *(_DWORD *)(v12 + 84) == (_DWORD)FlatSB_Internal_TrackThumb;
    v24 = color;
    v23 = v12;
    if ( v15 )
      FlatSB_Internal_CalcSBStuff(v23, v24);
    else
      FlatSB_Internal_DrawThumb((HBRUSH)v23, v24);
    return nNumber;
  }
  if ( !(v28 ^ v10) )
    goto LABEL_16;
  CCInvalidateFrame(hwnd);
  return nNumber;
}

//----- (6F7A1285) --------------------------------------------------------
LRESULT __stdcall FlatSB_NCPaintProc(HGDIOBJ a1, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // ebx@1
  HDC v5; // eax@1
  int v6; // edi@1
  int v7; // eax@1
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@1
  int v10; // [sp+1Ch] [bp-4h]@1
  HWND hWnda; // [sp+2Ch] [bp+Ch]@1
  LRESULT wParama; // [sp+30h] [bp+10h]@1
  LPARAM lParama; // [sp+34h] [bp+14h]@1

  v10 = SetWindowBits(hWnd, -16, 3145728, 0);
  GetWindowRect(hWnd, &Rect);
  DefSubclassProc(hWnd, 0x83u, 0, (LPARAM)&Rect);
  wParama = DefSubclassProc(hWnd, 0x85u, wParam, lParam);
  v4 = hWnd;
  SetWindowBits(hWnd, -16, 3145728, v10);
  GetWindowRect(hWnd, &Rect);
  DefSubclassProc(hWnd, 0x83u, 0, (LPARAM)&Rect);
  v5 = GetWindowDC(hWnd);
  lParama = 0;
  v6 = *((_DWORD *)a1 + 47);
  hWnda = (HWND)v5;
  v7 = *((_DWORD *)a1 + 1);
  if ( v7 & 4 && v7 & 2 )
    FlatSB_Internal_DrawSize((int)a1, (HDC)hWnda, *((_DWORD *)a1 + 37), *((_DWORD *)a1 + 38));
  if ( *((_BYTE *)a1 + 4) & 4 )
  {
    FlatSB_Internal_DrawScrollBar(a1, (HDC)hWnda, 0, 0);
    if ( *((_DWORD *)a1 + 27) )
      lParama = *((_DWORD *)a1 + 47);
  }
  if ( *((_BYTE *)a1 + 4) & 2 )
  {
    *((_DWORD *)a1 + 47) = v6;
    FlatSB_Internal_DrawScrollBar(a1, (HDC)hWnda, 1u, 0);
    if ( *((_DWORD *)a1 + 26) )
      lParama = *((_DWORD *)a1 + 47);
  }
  *((_DWORD *)a1 + 47) = lParama;
  ReleaseDC(v4, (HDC)hWnda);
  return wParama;
}

//----- (6F7A13A4) --------------------------------------------------------
LPARAM __stdcall FlatSB_NCHitTestProc(HGDIOBJ a1, HWND hWnd, WPARAM wParam, LPARAM lParam, int a5)
{
  LONG v5; // eax@4
  LPARAM v6; // esi@5
  LONG v7; // edx@8
  LONG v8; // ecx@10
  int v9; // ebx@16
  LONG v10; // ebx@16
  int v11; // edx@20
  int v12; // eax@22
  int v13; // eax@24
  LONG v14; // ecx@24
  signed int v15; // edi@31
  signed int v16; // eax@34
  int v17; // eax@38
  int v18; // eax@43
  unsigned int v19; // eax@52
  struct tagRECT Rect; // [sp+Ch] [bp-30h]@1
  RECT rc; // [sp+1Ch] [bp-20h]@16
  struct tagPOINT Point; // [sp+2Ch] [bp-10h]@3
  LPARAM v24; // [sp+34h] [bp-8h]@1
  int v25; // [sp+38h] [bp-4h]@1
  WPARAM wParama; // [sp+4Ch] [bp+10h]@37
  LPARAM lParama; // [sp+50h] [bp+14h]@2
  int v28; // [sp+54h] [bp+18h]@37

  v24 = 17;
  v25 = ChildOfActiveWindow(hWnd);
  GetWindowRect(hWnd, &Rect);
  if ( a5 )
  {
    lParama = 0;
    if ( v25 )
    {
      GetCursorPos(&Point);
      goto LABEL_7;
    }
    Point.x = Rect.left - 1;
    v5 = Rect.top - 1;
  }
  else
  {
    v6 = lParam;
    lParama = DefSubclassProc(hWnd, 0x84u, wParam, lParam);
    Point.x = (signed __int16)v6;
    v5 = SHIWORD(v6);
  }
  Point.y = v5;
LABEL_7:
  if ( GetWindowLongW(hWnd, -20) & 0x400000 )
  {
    v7 = Rect.right - Point.x;
    v24 = 16;
  }
  else
  {
    v7 = Point.x - Rect.left;
  }
  v8 = Point.y - Rect.top;
  Point.x = v7;
  Point.y -= Rect.top;
  if ( a5 && v25 && v7 == *((_DWORD *)a1 + 45) && v8 == *((_DWORD *)a1 + 46) )
    return lParama;
  if ( !lParama )
  {
    if ( *((_BYTE *)a1 + 4) & 2 )
    {
      v9 = *(_DWORD *)a1;
      rc.left = *((_DWORD *)a1 + 37);
      v10 = rc.left + *(_DWORD *)v9;
      rc.top = *((_DWORD *)a1 + 36);
      rc.bottom = *((_DWORD *)a1 + 38);
      rc.right = v10;
      if ( PtInRect(&rc, (POINT)__PAIR__(v8, v7)) )
      {
        lParama = 7;
        goto LABEL_29;
      }
      v8 = Point.y;
    }
    if ( *((_BYTE *)a1 + 4) & 4
      && (v11 = *(_DWORD *)a1,
          rc.left = *((_DWORD *)a1 + 35),
          rc.right = *((_DWORD *)a1 + 37),
          rc.top = *((_DWORD *)a1 + 38),
          rc.bottom = rc.top + *(_DWORD *)(v11 + 16),
          PtInRect(&rc, (POINT)__PAIR__(v8, Point.x))) )
    {
      lParama = 6;
    }
    else
    {
      v12 = *((_DWORD *)a1 + 1);
      if ( v12 & 4
        && v12 & 2
        && (v13 = *(_DWORD *)a1,
            rc.left = *((_DWORD *)a1 + 37),
            v14 = *((_DWORD *)a1 + 38),
            rc.right = rc.left + *(_DWORD *)v13,
            rc.top = v14,
            rc.bottom = v14 + *(_DWORD *)(v13 + 16),
            PtInRect(&rc, Point)) )
      {
        if ( FlatSB_Internal_IsSizeBox(hWnd) )
          lParama = v24;
        else
          lParama = 4;
      }
      else
      {
        lParama = 0;
      }
    }
  }
LABEL_29:
  if ( *((_DWORD *)a1 + 25) )
    return lParama;
  if ( !v25 )
  {
    v15 = *((_DWORD *)a1 + 27);
    *((_DWORD *)a1 + 27) = 0;
    goto LABEL_36;
  }
  if ( lParama == 6 )
  {
    v15 = 1;
    *((_DWORD *)a1 + 27) = 1;
    goto LABEL_36;
  }
  v15 = *((_DWORD *)a1 + 27);
  *((_DWORD *)a1 + 27) = 0;
  if ( lParama != 7 )
  {
LABEL_36:
    v16 = *((_DWORD *)a1 + 26);
    *((_DWORD *)a1 + 26) = 0;
    goto LABEL_37;
  }
  v16 = 1;
  *((_DWORD *)a1 + 26) = 1;
LABEL_37:
  *(_QWORD *)((char *)a1 + 180) = Point;
  v28 = 0;
  wParama = *((_DWORD *)a1 + 47);
  if ( v16 )
  {
    v17 = *((_DWORD *)a1 + 43);
    if ( v17 == 2 || v17 == 1 )
    {
      FlatSB_Internal_RedrawScrollBar(a1, 1u);
      if ( *((_DWORD *)a1 + 26) )
        v28 = *((_DWORD *)a1 + 47);
    }
  }
  if ( v15 )
  {
    v18 = *((_DWORD *)a1 + 44);
    if ( v18 == 2 || v18 == 1 )
    {
      *((_DWORD *)a1 + 47) = wParama;
      FlatSB_Internal_RedrawScrollBar(a1, 0);
      if ( *((_DWORD *)a1 + 27) )
        v28 = *((_DWORD *)a1 + 47);
    }
  }
  *((_DWORD *)a1 + 47) = v28;
  if ( *((_DWORD *)a1 + 26) || *((_DWORD *)a1 + 27) )
  {
    if ( !*((_DWORD *)a1 + 30) )
    {
      v19 = GetDoubleClickTime();
      *((_DWORD *)a1 + 30) = SetTimer(hWnd, 0xFFFFFFF2, v19 >> 1, TimerMouseLeave);
    }
  }
  else if ( *((_DWORD *)a1 + 30) )
  {
    KillTimer(hWnd, 0xFFFFFFF2);
    *((_DWORD *)a1 + 30) = 0;
  }
  return lParama;
}

//----- (6F7A1671) --------------------------------------------------------
LRESULT __stdcall FlatSB_OnScrollProc(HGDIOBJ a1, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  if ( !lParam && !*((_DWORD *)a1 + 28) && (_WORD)wParam == 8 )
    FlatSB_NCPaintProc(a1, hWnd, 1u, 0);
  return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

//----- (6F7A16B2) --------------------------------------------------------
LPARAM __stdcall FlatSB_Internal_EndScroll(HGDIOBJ h, int a2)
{
  HBRUSH v2; // esi@1
  LPARAM result; // eax@1
  HWND v4; // edi@1
  UINT (__stdcall *v5)(HGDIOBJ, int, int, int); // eax@4
  DWORD v6; // edi@11
  POINT v7; // ST0C_8@11
  int v8; // ST10_4@12
  struct tagRECT Rect; // [sp+Ch] [bp-18h]@11
  int v10; // [sp+1Ch] [bp-8h]@2
  HWND hWnd; // [sp+20h] [bp-4h]@1
  LPARAM ha; // [sp+2Ch] [bp+8h]@1

  v2 = (HBRUSH)h;
  result = *((_DWORD *)h + 24);
  v4 = (HWND)*((_DWORD *)h + 55);
  hWnd = (HWND)*((_DWORD *)h + 55);
  ha = result;
  if ( *((_DWORD *)v2 + 25) )
  {
    v10 = *((_DWORD *)v2 + 17);
    *((_DWORD *)v2 + 17) = 0;
    if ( GetCapture() == v4 )
      ReleaseCapture();
    v5 = (UINT (__stdcall *)(HGDIOBJ, int, int, int))*((_DWORD *)v2 + 21);
    if ( (char *)v5 == (char *)FlatSB_Internal_TrackThumb )
    {
      if ( a2 )
        *((_DWORD *)v2 + 18) = *((_DWORD *)v2 + 20);
      FlatSB_Internal_DoScroll((int)v2, 4u, *((_DWORD *)v2 + 18), ha);
      FlatSB_Internal_DrawThumb(v2, ha);
    }
    else if ( v5 == FlatSB_Internal_TrackBox )
    {
      if ( *((_DWORD *)v2 + 29) )
        KillTimer(v4, 0xFFFEu);
      v6 = GetMessagePos();
      GetWindowRect(hWnd, &Rect);
      v7.y = SHIWORD(v6) - Rect.top;
      v7.x = (signed __int16)v6 - Rect.left;
      if ( PtInRect((const RECT *)(v2 + 39), v7) )
      {
        v8 = v10;
        *((_DWORD *)v2 + 23) = 0;
        FlatSB_Internal_DrawInvertScrollArea(v2, 0, v8);
      }
    }
    *((_DWORD *)v2 + 21) = 0;
    FlatSB_Internal_DoScroll((int)v2, 8u, 0, ha);
    *((_DWORD *)v2 + 25) = 0;
    *((_DWORD *)v2 + 23) = 0;
    FlatSB_Internal_NotifyWinEvent((int)v2, 19, 0);
    result = FlatSB_NCHitTestProc(v2, hWnd, 0, 0, 1);
  }
  return result;
}

//----- (6F7A17B4) --------------------------------------------------------
UINT __stdcall FlatSB_Internal_TrackBox(HGDIOBJ h, int a2, int a3, int a4)
{
  int v4; // esi@1
  UINT result; // eax@1
  POINT v6; // ST08_8@4
  int v7; // eax@4
  int v8; // ebx@4
  int v9; // ST0C_4@5
  int v10; // [sp+8h] [bp-Ch]@1
  HWND hWnd; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1
  unsigned int ha; // [sp+1Ch] [bp+8h]@4

  v4 = (int)h;
  hWnd = (HWND)*((_DWORD *)h + 55);
  v10 = *((_DWORD *)h + 24);
  result = *((_DWORD *)h + 23);
  v12 = *((_DWORD *)h + 23);
  if ( !a2 || a2 >= 512 && a2 <= 525 )
  {
    ha = 4 * GetDoubleClickTime() / 5;
    v6.y = SHIWORD(a4);
    v6.x = (signed __int16)a4;
    v7 = PtInRect((const RECT *)(v4 + 156), v6);
    v8 = v7;
    if ( v7 != v12 )
    {
      v9 = *(_DWORD *)(v4 + 68);
      *(_DWORD *)(v4 + 92) = v7;
      FlatSB_Internal_DrawInvertScrollArea((HGDIOBJ)v4, v7, v9);
    }
    result = ha >> 3;
    if ( a2 != 512 )
    {
      if ( a2 != 513 )
      {
        if ( a2 == 514 )
          result = FlatSB_Internal_EndScroll((HGDIOBJ)v4, 0);
        return result;
      }
      *(_DWORD *)(v4 + 116) = 0;
      result = ha;
    }
    if ( v8 && v8 != v12 )
    {
      *(_DWORD *)(v4 + 116) = SetTimer(hWnd, 0xFFFEu, result, TimerScroll);
      result = FlatSB_Internal_DoScroll(v4, *(_DWORD *)(v4 + 68), 0, v10);
    }
  }
  return result;
}

//----- (6F7A1895) --------------------------------------------------------
void __stdcall FlatSB_Internal_SBTrackInit(int nNumber, HWND hWnd, int a3, COLORREF color, int a5)
{
  int v5; // esi@5
  LONG v6; // edi@5
  LONG v7; // ebx@5
  int v8; // ecx@9
  int v9; // eax@9
  LONG v10; // edx@13
  LONG v11; // ecx@17
  int v12; // ecx@21
  LONG v13; // edx@22
  int v14; // eax@27
  int v15; // edi@31
  int v16; // eax@31
  int v17; // eax@36
  int v18; // ecx@37
  int v19; // eax@39
  struct tagRECT Rect; // [sp+0h] [bp-10h]@5
  int nNumbera; // [sp+18h] [bp+8h]@5
  int v22; // [sp+20h] [bp+10h]@5
  signed int colora; // [sp+24h] [bp+14h]@2

  if ( color == 6 )
  {
    colora = 0;
  }
  else
  {
    if ( color != 7 )
      return;
    colora = 1;
  }
  GetWindowRect(hWnd, &Rect);
  v5 = nNumber;
  v6 = (signed __int16)a3 - Rect.left;
  v7 = SHIWORD(a3) - Rect.top;
  v22 = (unsigned __int16)(a3 - Rect.left) | ((unsigned __int16)(HIWORD(a3) - LOWORD(Rect.top)) << 16);
  nNumbera = FlatSB_Internal_GetSBFlags(nNumber, colora);
  if ( (nNumbera & 3) == 3 )
    goto LABEL_40;
  *(_DWORD *)(v5 + 116) = 0;
  *(_DWORD *)(v5 + 92) = 0;
  *(_DWORD *)(v5 + 100) = 0;
  if ( colora )
  {
    *(_DWORD *)(v5 + 104) = 1;
    *(_DWORD *)(v5 + 108) = 0;
  }
  else
  {
    *(_DWORD *)(v5 + 108) = 1;
    *(_DWORD *)(v5 + 104) = 0;
  }
  FlatSB_Internal_CalcSBStuff(v5, colora);
  v8 = v5 + 124;
  *(_DWORD *)(v5 + 84) = FlatSB_Internal_TrackBox;
  *(_DWORD *)(v5 + 100) = 1;
  v9 = v5 + 128;
  if ( !colora )
  {
    v8 = v5 + 128;
    v9 = v5 + 124;
  }
  *(_DWORD *)v8 = *(_DWORD *)(v5 + 28);
  *(_DWORD *)v9 = *(_DWORD *)(v5 + 48);
  *(_DWORD *)(v8 + 8) = *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v9 + 8) = *(_DWORD *)(v5 + 20);
  if ( colora )
    v6 = v7;
  v10 = *(_DWORD *)(v5 + 52);
  *(_DWORD *)(v5 + 8) = v6;
  if ( v6 < v10 )
  {
    if ( !(nNumbera & 1) )
    {
      *(_DWORD *)(v5 + 68) = 0;
      *(_DWORD *)(v9 + 8) = v10;
      goto LABEL_25;
    }
    *(_DWORD *)(v5 + 84) = 0;
    *(_DWORD *)(v5 + 100) = 0;
    return;
  }
  v11 = *(_DWORD *)(v5 + 24);
  if ( v6 >= v11 )
  {
    if ( !(nNumbera & 2) )
    {
      *(_DWORD *)(v5 + 68) = 1;
      *(_DWORD *)v9 = v11;
      goto LABEL_25;
    }
LABEL_40:
    *(_DWORD *)(v5 + 84) = 0;
    *(_DWORD *)(v5 + 100) = 0;
    return;
  }
  if ( v6 >= *(_DWORD *)(v5 + 44) )
  {
    v13 = *(_DWORD *)(v5 + 40);
    if ( v6 < v13 )
      goto LABEL_30;
    *(_DWORD *)(v5 + 68) = 3;
    *(_DWORD *)v9 = v13;
    v12 = *(_DWORD *)(v5 + 24);
  }
  else
  {
    *(_DWORD *)(v5 + 68) = 2;
    *(_DWORD *)v9 = v10;
    v12 = *(_DWORD *)(v5 + 44);
  }
  *(_DWORD *)(v9 + 8) = v12;
LABEL_25:
  while ( g_bRunOnNT5 )
  {
    if ( !a5 )
      break;
    v14 = *(_DWORD *)(v5 + 68);
    if ( !v14 || v14 == 1 )
      break;
    if ( v14 == 4 )
    {
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v5 + 56) / -2;
      break;
    }
LABEL_30:
    if ( *(_DWORD *)(v5 + 24) - *(_DWORD *)(v5 + 52) <= *(_DWORD *)(v5 + 56) )
      goto LABEL_40;
    *(_DWORD *)(v5 + 96) = colora;
    v15 = v5 + 156;
    *(_DWORD *)(v5 + 68) = 4;
    CopyRect((LPRECT)(v5 + 156), (const RECT *)(v5 + 124));
    v16 = *(_DWORD *)(v5 + 260);
    if ( v16 >= 0 )
    {
      if ( colora )
        InflateRect(
          (LPRECT)(v5 + 156),
          v16 * (*(_DWORD *)(v5 + 164) - *(_DWORD *)v15),
          v16 * *(_DWORD *)(*(_DWORD *)v5 + 20));
      else
        InflateRect(
          (LPRECT)(v5 + 156),
          v16 * *(_DWORD *)(*(_DWORD *)v5 + 8),
          v16 * (*(_DWORD *)(v5 + 168) - *(_DWORD *)(v5 + 160)));
    }
    else
    {
      *(_DWORD *)(v5 + 160) = 2147483648;
      *(_DWORD *)v15 = 2147483648;
      *(_DWORD *)(v5 + 164) = 0x7FFFFFFF;
      *(_DWORD *)(v5 + 168) = 0x7FFFFFFF;
    }
    v17 = *(_DWORD *)(v5 + 44);
    *(_DWORD *)(v5 + 84) = FlatSB_Internal_TrackThumb;
    *(_DWORD *)(v5 + 12) = v17;
    *(_DWORD *)(v5 + 32) = v17;
    if ( colora )
      v18 = *(_DWORD *)(v5 + 256);
    else
      v18 = *(_DWORD *)(v5 + 240);
    v19 = v17 - *(_DWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 80) = v18;
    *(_DWORD *)(v5 + 76) = v18;
    *(_DWORD *)(v5 + 72) = v18;
    *(_DWORD *)(v5 + 16) = v19;
    SetCapture(hWnd);
    FlatSB_Internal_DoScroll(v5, 5u, *(_DWORD *)(v5 + 72), colora);
    FlatSB_Internal_DrawThumb((HBRUSH)v5, colora);
  }
  if ( *(_DWORD *)(v5 + 68) != 4 )
  {
    *(_DWORD *)(v5 + 96) = colora;
    SetCapture(hWnd);
    CopyRect((LPRECT)(v5 + 156), (const RECT *)(v5 + 124));
  }
  FlatSB_Internal_SBTrackLoop(v5, v22);
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7A1B41) --------------------------------------------------------
LRESULT __stdcall FlatSB_SysCommandProc(int nNumber, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  WPARAM v4; // eax@1
  LRESULT result; // eax@3
  SHORT v6; // ax@4

  v4 = wParam & 0xFFF0;
  if ( v4 == 61568 || v4 == 61552 )
  {
    DefSubclassProc(hWnd, 0x112u, 0, lParam);
    v6 = GetKeyState(16);
    FlatSB_Internal_SBTrackInit(nNumber, hWnd, lParam, wParam & 0xF, v6 < 0);
    result = 0;
  }
  else
  {
    result = DefSubclassProc(hWnd, 0x112u, wParam, lParam);
  }
  return result;
}

//----- (6F7A1BB6) --------------------------------------------------------
LRESULT __stdcall FlatSB_CancelModeProc(HGDIOBJ h, HWND hWnd, WPARAM wParam, LPARAM lParam)
{
  LRESULT v4; // esi@1

  v4 = DefSubclassProc(hWnd, 0x1Fu, wParam, lParam);
  if ( *((_DWORD *)h + 21) )
    FlatSB_Internal_EndScroll(h, 1);
  return v4;
}

//----- (6F7A1BEB) --------------------------------------------------------
LRESULT __stdcall FlatSB_SubclassWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  LRESULT result; // eax@2

  if ( dwRefData )
  {
    if ( dwRefData != -1 || uMsg == 130 )
    {
      if ( uMsg > 0x84 )
      {
        if ( uMsg == 133 )
          return FlatSB_NCPaintProc((HGDIOBJ)dwRefData, hWnd, wParam, lParam);
        if ( uMsg == 274 )
          return FlatSB_SysCommandProc(dwRefData, hWnd, wParam, lParam);
        if ( uMsg > 0x113 && uMsg <= 0x115 )
          return FlatSB_OnScrollProc((HGDIOBJ)dwRefData, hWnd, uMsg, wParam, lParam);
      }
      else
      {
        if ( uMsg == 132 )
          return FlatSB_NCHitTestProc((HGDIOBJ)dwRefData, hWnd, wParam, lParam, 0);
        if ( uMsg == 26 )
          return FlatSB_OnSettingChangeProc(dwRefData, hWnd, wParam, lParam);
        if ( uMsg == 31 )
          return FlatSB_CancelModeProc((HGDIOBJ)dwRefData, hWnd, wParam, lParam);
        if ( uMsg == 130 )
          return FlatSB_NCDestroyProc((HLOCAL)dwRefData, hWnd, wParam, lParam);
        if ( uMsg == 131 )
          return FlatSB_NCCalcProc(dwRefData, hWnd, wParam, (RECT *)lParam);
      }
    }
    result = DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  else
  {
    result = DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  return result;
}

//----- (6F7A1D05) --------------------------------------------------------
int __stdcall FlatSB_GetScrollPos(HWND hWnd, int code)
{
  HWND v2; // esi@1
  int result; // eax@2

  v2 = hWnd;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( hWnd )
  {
    if ( hWnd == HWND_MESSAGE|0x2 || *((HWND *)hWnd + 55) != v2 )
    {
      result = 0;
    }
    else if ( code == 1 )
    {
      result = *((_DWORD *)hWnd + 64);
    }
    else
    {
      result = *((_DWORD *)hWnd + 60);
    }
  }
  else
  {
    result = GetScrollPos(v2, code);
  }
  return result;
}

//----- (6F7A1D61) --------------------------------------------------------
BOOL __stdcall FlatSB_GetScrollProp(HWND hWnd, int propIndex, LPINT a3)
{
  LPINT v3; // esi@1
  LPINT v5; // eax@3
  int v6; // eax@5
  bool v7; // zf@6
  int v8; // eax@17

  v3 = a3;
  if ( !a3 )
    return 0;
  *a3 = 0;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&a3);
  v5 = a3;
  if ( !a3 )
    return 0;
  if ( a3 == (LPINT)-1 )
  {
    v6 = FlatSB_Internal_InitPwSB((int)hWnd);
    a3 = (LPINT)v6;
    if ( !v6 )
      return 0;
    v7 = SetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, v6) == 0;
    v5 = a3;
    if ( v7 )
    {
      DeleteObject((HGDIOBJ)a3[53]);
      DeleteObject((HGDIOBJ)a3[52]);
      LocalFree(a3);
      return 0;
    }
  }
  else if ( (HWND)a3[55] != hWnd )
  {
    return 0;
  }
  if ( propIndex > 64 )
  {
    switch ( propIndex )
    {
      case 128:
        v8 = v5[49];
        break;
      case 256:
        v8 = v5[43];
        break;
      case 512:
        v8 = v5[44];
        break;
      case 1024:
        v8 = v5[1];
        break;
      case 2048:
        v8 = v5[54];
        break;
      default:
        if ( propIndex != 4096 )
          return 0;
        v8 = v5[65];
        break;
    }
  }
  else
  {
    switch ( propIndex )
    {
      case 64:
        v8 = v5[48];
        break;
      case 1:
        v8 = v5[69];
        break;
      case 2:
        v8 = v5[67];
        break;
      case 4:
        v8 = v5[70];
        break;
      case 8:
        v8 = v5[66];
        break;
      case 16:
        v8 = v5[68];
        break;
      default:
        if ( propIndex != 32 )
          return 0;
        v8 = v5[71];
        break;
    }
  }
  *v3 = v8;
  return 1;
}

//----- (6F7A1EC5) --------------------------------------------------------
BOOL __stdcall FlatSB_GetScrollRange(HWND hWnd, int code, LPINT lpMinPos, LPINT lpMaxPos)
{
  int *v4; // ebx@1
  int *v5; // esi@2
  LPINT v7; // eax@9

  v4 = lpMinPos;
  if ( lpMinPos )
  {
    v5 = lpMaxPos;
    if ( lpMaxPos )
    {
      GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&lpMinPos);
      if ( !lpMinPos )
        return GetScrollRange(hWnd, code, v4, v5);
      if ( lpMinPos == (LPINT)-1 )
      {
        *v4 = 0;
        *v5 = 0;
        return 1;
      }
      if ( (HWND)lpMinPos[55] == hWnd )
      {
        if ( code == 1 )
          v7 = lpMinPos + 61;
        else
          v7 = lpMinPos + 57;
        *v4 = *v7;
        *v5 = v7[1];
        return 1;
      }
    }
  }
  return 0;
}

//----- (6F7A1F47) --------------------------------------------------------
BOOL __stdcall FlatSB_GetScrollInfo(HWND hWnd, int code, LPSCROLLINFO lpsi)
{
  LPSCROLLINFO v3; // esi@1
  LPSCROLLINFO v5; // edx@4
  char *v6; // ecx@9
  UINT v7; // eax@12
  int v8; // eax@22

  v3 = lpsi;
  if ( !lpsi || lpsi->cbSize < 0x1C )
    return 0;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&lpsi);
  v5 = lpsi;
  if ( !lpsi )
    return GetScrollInfo(hWnd, code, v3);
  if ( lpsi != (LPSCROLLINFO)-1 && (HWND)lpsi[7].nTrackPos == hWnd )
  {
    if ( code == 1 )
    {
      v6 = (char *)&lpsi[8].nPos;
      goto LABEL_12;
    }
    if ( !code )
    {
      v6 = (char *)&lpsi[8].fMask;
LABEL_12:
      v7 = v3->fMask;
      if ( v7 & 1 )
      {
        v3->nMin = *(_DWORD *)v6;
        v3->nMax = *((_DWORD *)v6 + 1);
      }
      if ( v7 & 4 )
        v3->nPos = *((_DWORD *)v6 + 3);
      if ( v7 & 2 )
        v3->nPage = *((_DWORD *)v6 + 2);
      if ( !(v7 & 0x10) )
        return 1;
      if ( v5[3].cbSize )
      {
        if ( code == 1 )
        {
          if ( v5[3].nMax )
          {
LABEL_22:
            v8 = v5[2].nPos;
LABEL_26:
            v3->nTrackPos = v8;
            return 1;
          }
        }
        else if ( !code && !v5[3].nMax )
        {
          goto LABEL_22;
        }
      }
      v8 = *((_DWORD *)v6 + 3);
      goto LABEL_26;
    }
  }
  return 0;
}

//----- (6F7A2013) --------------------------------------------------------
BOOL __stdcall FlatSB_ShowScrollBar(HWND hWnd, int code, BOOL bShow)
{
  DWORD_PTR v3; // eax@1
  signed int v5; // esi@6
  int v6; // eax@11
  bool v7; // zf@12
  DWORD_PTR pdwRefData; // [sp+8h] [bp-4h]@1

  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, &pdwRefData);
  v3 = pdwRefData;
  if ( !pdwRefData )
    return ShowScrollBar(hWnd, code, bShow);
  if ( code )
  {
    if ( code == 1 )
    {
      v5 = 0x200000;
    }
    else
    {
      if ( code != 3 )
        return 0;
      v5 = 3145728;
    }
  }
  else
  {
    v5 = 0x100000;
  }
  if ( pdwRefData == -1 )
  {
    if ( !bShow )
      return 0;
    v6 = FlatSB_Internal_InitPwSB((int)hWnd);
    pdwRefData = v6;
    if ( !v6 )
      return 0;
    v7 = SetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, v6) == 0;
    v3 = pdwRefData;
    if ( v7 )
    {
      DeleteObject(*(HGDIOBJ *)(pdwRefData + 212));
      DeleteObject(*(HGDIOBJ *)(pdwRefData + 208));
      LocalFree((HLOCAL)pdwRefData);
      return 0;
    }
  }
  if ( bShow )
  {
    if ( (v5 & *(_DWORD *)(v3 + 4)) != v5 )
    {
      *(_DWORD *)(v3 + 4) |= v5;
      goto LABEL_20;
    }
  }
  else if ( v5 & *(_DWORD *)(v3 + 4) )
  {
    *(_DWORD *)(v3 + 4) &= ~v5;
LABEL_20:
    ShowScrollBar(hWnd, code, bShow);
    CCInvalidateFrame(hWnd);
    return 1;
  }
  return 1;
}

//----- (6F7A2101) --------------------------------------------------------
BOOL __stdcall FlatSB_EnableScrollBar(HWND hWnd, int wSBflags, UINT wArrows)
{
  HWND v3; // edi@1
  int v5; // eax@6

  v3 = hWnd;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( !hWnd )
    return EnableScrollBar(v3, wSBflags, wArrows);
  if ( hWnd == HWND_MESSAGE|0x2 )
  {
    if ( !wArrows )
      return 0;
    v5 = FlatSB_Internal_InitPwSB((int)v3);
    hWnd = (HWND)v5;
    if ( !v5 )
      return 0;
    if ( !SetWindowSubclass(v3, FlatSB_SubclassWndProc, 0, v5) )
    {
      DeleteObject(*((HGDIOBJ *)hWnd + 53));
      DeleteObject(*((HGDIOBJ *)hWnd + 52));
      LocalFree(hWnd);
      return 0;
    }
  }
  else if ( v3 != *((HWND *)hWnd + 55) )
  {
    return 0;
  }
  return FlatSB_Internal_EnableScrollBar((HDC)hWnd, wSBflags, wArrows);
}

//----- (6F7A21A5) --------------------------------------------------------
int __stdcall FlatSB_SetScrollPos(HWND hWnd, int code, int pos, BOOL fRedraw)
{
  HWND v4; // esi@1
  int result; // eax@2
  SCROLLINFO v6; // [sp+4h] [bp-1Ch]@6

  v4 = hWnd;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( hWnd )
  {
    if ( hWnd == HWND_MESSAGE|0x2 || v4 != *((HWND *)hWnd + 55) )
    {
      result = 0;
    }
    else
    {
      v6.nPos = pos;
      v6.cbSize = 28;
      v6.fMask = 4;
      result = FlatSB_Internal_SetScrollBar((int)hWnd, code, &v6, fRedraw);
    }
  }
  else
  {
    result = SetScrollPos(v4, code, pos, fRedraw);
  }
  return result;
}

//----- (6F7A221A) --------------------------------------------------------
int __stdcall FlatSB_SetScrollRange(HWND hWnd, int code, int min, int max, BOOL fRedraw)
{
  HWND v5; // edi@1
  int v7; // eax@4
  SCROLLINFO v8; // [sp+8h] [bp-1Ch]@11

  v5 = hWnd;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( !hWnd )
    return SetScrollRange(v5, code, min, max, fRedraw);
  if ( hWnd == HWND_MESSAGE|0x2 )
  {
    v7 = FlatSB_Internal_InitPwSB((int)v5);
    hWnd = (HWND)v7;
    if ( !v7 )
      return 0;
    if ( !SetWindowSubclass(v5, FlatSB_SubclassWndProc, 0, v7) )
    {
      DeleteObject(*((HGDIOBJ *)hWnd + 53));
      DeleteObject(*((HGDIOBJ *)hWnd + 52));
      LocalFree(hWnd);
      return 0;
    }
    fRedraw = 1;
  }
  else if ( v5 != *((HWND *)hWnd + 55) )
  {
    return 0;
  }
  if ( (unsigned int)(max - min) > 0x7FFF )
    return 0;
  v8.nMax = max;
  v8.cbSize = 28;
  v8.fMask = 1;
  v8.nMin = min;
  FlatSB_Internal_SetScrollBar((int)hWnd, code, &v8, fRedraw);
  return 1;
}

//----- (6F7A22F6) --------------------------------------------------------
int __stdcall FlatSB_SetScrollInfo(HWND hWnd, int code, LPSCROLLINFO psi, BOOL fRedraw)
{
  LPSCROLLINFO v4; // ebx@1
  int v6; // eax@8

  v4 = psi;
  if ( !psi || psi->cbSize < 0x1C )
    return 0;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&psi);
  if ( !psi )
    return SetScrollInfo(hWnd, code, v4, fRedraw);
  if ( psi == (LPSCROLLINFO)-1 )
  {
    if ( !(v4->fMask & 1) )
      return 0;
    v6 = FlatSB_Internal_InitPwSB((int)hWnd);
    psi = (LPSCROLLINFO)v6;
    if ( !v6 )
      return 0;
    if ( !SetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, v6) )
    {
      DeleteObject((HGDIOBJ)psi[7].nPage);
      DeleteObject((HGDIOBJ)psi[7].nMax);
      LocalFree(psi);
      return 0;
    }
    fRedraw = 1;
  }
  else if ( hWnd != (HWND)psi[7].nTrackPos )
  {
    return 0;
  }
  if ( v4->fMask == 4 )
    v4->fMask = 20;
  return FlatSB_Internal_SetScrollBar((int)psi, code, v4, fRedraw);
}

//----- (6F7A23C5) --------------------------------------------------------
BOOL __stdcall FlatSB_SetScrollProp(HWND hWnd, UINT index, INT_PTR newValue, BOOL a4)
{
  DWORD_PTR v4; // eax@1
  int v6; // eax@4
  bool v7; // zf@5
  int v8; // eax@17
  int v9; // eax@25
  int v10; // ebx@29
  int v11; // esi@30
  int v12; // eax@36
  HDC v13; // edi@44
  signed int color; // [sp+Ch] [bp-8h]@1
  DWORD_PTR pdwRefData; // [sp+10h] [bp-4h]@1

  color = 0;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, &pdwRefData);
  v4 = pdwRefData;
  if ( !pdwRefData )
    return 0;
  if ( pdwRefData == -1 )
  {
    v6 = FlatSB_Internal_InitPwSB((int)hWnd);
    pdwRefData = v6;
    if ( !v6 )
      return 0;
    v7 = SetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, v6) == 0;
    v4 = pdwRefData;
    if ( v7 )
    {
      DeleteObject(*(HGDIOBJ *)(pdwRefData + 212));
      DeleteObject(*(HGDIOBJ *)(pdwRefData + 208));
      LocalFree((HLOCAL)pdwRefData);
      return 0;
    }
    a4 = 0;
  }
  if ( *(_DWORD *)(v4 + 100) )
    return 0;
  if ( index > 0x40 )
  {
    if ( index == 128 )
    {
      v12 = v4 + 196;
    }
    else
    {
      if ( index == 256 )
      {
        v9 = v4 + 172;
        goto LABEL_26;
      }
      if ( index == 512 )
      {
        v12 = v4 + 176;
      }
      else if ( index == 2048 )
      {
        v12 = v4 + 216;
      }
      else
      {
        if ( index != 4096 )
          return 0;
        v12 = v4 + 260;
      }
    }
    if ( newValue == *(_DWORD *)v12 )
      return 1;
    *(_DWORD *)v12 = newValue;
    goto LABEL_28;
  }
  if ( index == 64 )
  {
    v9 = v4 + 192;
LABEL_26:
    if ( newValue == *(_DWORD *)v9 )
      return 1;
    *(_DWORD *)v9 = newValue;
    color = 1;
LABEL_28:
    if ( a4 )
    {
      v10 = *(_DWORD *)(pdwRefData + 188);
      if ( color )
        v11 = *(_DWORD *)(pdwRefData + 104);
      else
        v11 = *(_DWORD *)(pdwRefData + 108);
      v13 = GetWindowDC(hWnd);
      FlatSB_Internal_DrawScrollBar((HGDIOBJ)pdwRefData, v13, color, 0);
      if ( !v11 )
        *(_DWORD *)(pdwRefData + 188) = v10;
      ReleaseDC(hWnd, v13);
    }
    return 1;
  }
  switch ( index )
  {
    case 1u:
      v8 = v4 + 276;
      break;
    case 2u:
      v8 = v4 + 268;
      break;
    case 4u:
      v8 = v4 + 280;
      break;
    case 8u:
      v8 = v4 + 264;
      break;
    case 0x10u:
      v8 = v4 + 272;
      break;
    default:
      if ( index != 32 )
        return 0;
      v8 = v4 + 284;
      break;
  }
  if ( newValue != *(_DWORD *)v8 )
  {
    *(_DWORD *)v8 = newValue;
    CCInvalidateFrame(hWnd);
  }
  return 1;
}

//----- (6F7A257A) --------------------------------------------------------
HRESULT __stdcall UninitializeFlatSB(HWND hWnd)
{
  HWND v1; // ebx@1
  HRESULT result; // eax@2
  int v3; // eax@7
  int v4; // ecx@7
  void *v5; // ST0C_4@7
  SCROLLINFO v6; // [sp+Ch] [bp-4Ch]@7
  SCROLLINFO v7; // [sp+28h] [bp-30h]@7
  int v8; // [sp+44h] [bp-14h]@7
  UINT v9; // [sp+48h] [bp-10h]@7
  int v10; // [sp+4Ch] [bp-Ch]@7
  UINT wArrows; // [sp+50h] [bp-8h]@7
  int v12; // [sp+54h] [bp-4h]@7

  v1 = hWnd;
  GetWindowSubclass(hWnd, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( !hWnd )
    return 1;
  if ( hWnd == HWND_MESSAGE|0x2 )
  {
    RemoveWindowSubclass(v1, FlatSB_SubclassWndProc, 0);
    return 1;
  }
  if ( *((_DWORD *)hWnd + 25) )
  {
    result = -2147467259;
  }
  else
  {
    v8 = *((_DWORD *)hWnd + 1);
    v6.cbSize = 28;
    v7.cbSize = 28;
    v6.fMask = 31;
    v7.fMask = 31;
    v10 = FlatSB_GetScrollInfo(v1, 0, &v6);
    v9 = FlatSB_Internal_GetSBFlags((int)hWnd, 0);
    v12 = FlatSB_GetScrollInfo(v1, 1, &v7);
    v3 = FlatSB_Internal_GetSBFlags((int)hWnd, 1);
    v5 = *(void **)(v4 + 212);
    wArrows = v3;
    DeleteObject(v5);
    DeleteObject(*((HGDIOBJ *)hWnd + 52));
    LocalFree(hWnd);
    RemoveWindowSubclass(v1, FlatSB_SubclassWndProc, 0);
    if ( v12 )
    {
      SetScrollInfo(v1, 1, &v7, 0);
      EnableScrollBar(v1, 1u, wArrows);
    }
    if ( v10 )
    {
      SetScrollInfo(v1, 0, &v6, 0);
      EnableScrollBar(v1, 0, v9);
    }
    SetWindowBits(v1, -16, 3145728, v8 & 0x300000);
    CCInvalidateFrame(v1);
    result = 0;
  }
  return result;
}

//----- (6F7A26A7) --------------------------------------------------------
BOOL __stdcall InitializeFlatSB(HWND hWnd)
{
  HWND v1; // ebx@1
  LONG v2; // esi@1
  int v4; // eax@12
  SCROLLINFO v5; // [sp+Ch] [bp-44h]@1
  SCROLLINFO v6; // [sp+28h] [bp-28h]@1
  LONG v7; // [sp+44h] [bp-Ch]@5
  int v8; // [sp+48h] [bp-8h]@1
  int v9; // [sp+4Ch] [bp-4h]@1

  v9 = 0;
  v8 = 0;
  v1 = hWnd;
  v2 = GetWindowLongW(hWnd, -16);
  v6.cbSize = 28;
  v5.cbSize = 28;
  v6.fMask = 31;
  v5.fMask = 31;
  if ( v2 & 0x100000 )
    v9 = GetScrollInfo(v1, 0, &v6);
  if ( v2 & 0x200000 )
    v8 = GetScrollInfo(v1, 1, &v5);
  v7 = v2 & 0x300000;
  GetWindowSubclass(v1, FlatSB_SubclassWndProc, 0, (DWORD_PTR *)&hWnd);
  if ( v8 || v9 )
  {
    if ( !hWnd || hWnd == HWND_MESSAGE|0x2 )
    {
      v4 = FlatSB_Internal_InitPwSB((int)v1);
      hWnd = (HWND)v4;
      if ( !v4 )
        return 0;
      if ( !SetWindowSubclass(v1, FlatSB_SubclassWndProc, 0, v4) )
      {
        DeleteObject(*((HGDIOBJ *)hWnd + 53));
        DeleteObject(*((HGDIOBJ *)hWnd + 52));
        LocalFree(hWnd);
        return 0;
      }
    }
    *((_DWORD *)hWnd + 1) = v7;
    if ( v9 )
      FlatSB_Internal_SetScrollBar((int)hWnd, 0, &v6, 0);
    if ( v8 )
      FlatSB_Internal_SetScrollBar((int)hWnd, 1, &v5, 0);
    CCInvalidateFrame(v1);
    return 1;
  }
  if ( !hWnd && !SetWindowSubclass(v1, FlatSB_SubclassWndProc, 0, 0xFFFFFFFF) )
    return 0;
  return 1;
}

//----- (6F7A27E1) --------------------------------------------------------
BOOL __stdcall IsMaxedMDI(HMENU hMenu)
{
  int v1; // eax@1

  v1 = GetMenuItemCount(hMenu);
  return GetMenuItemID(hMenu, v1 - 1) == 61728;
}

//----- (6F7A280D) --------------------------------------------------------
void __stdcall MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT *lpwIDs)
{
  int v7; // esi@5
  unsigned int v8; // ecx@6
  UINT *i; // eax@10
  int v10; // eax@17
  UINT v11; // eax@20
  int Dst; // [sp+4h] [bp-24Ch]@5
  int v13; // [sp+8h] [bp-248h]@5
  unsigned int v14; // [sp+Ch] [bp-244h]@6
  unsigned int v15; // [sp+10h] [bp-240h]@6
  int v16; // [sp+2Ch] [bp-224h]@5
  HMENU hMenu; // [sp+34h] [bp-21Ch]@1
  HINSTANCE hInstance; // [sp+38h] [bp-218h]@1
  HMENU hmenu; // [sp+3Ch] [bp-214h]@1
  int v20; // [sp+40h] [bp-210h]@1
  WPARAM v21; // [sp+44h] [bp-20Ch]@2
  HWND hWnd; // [sp+48h] [bp-208h]@1
  WCHAR Buffer; // [sp+4Ch] [bp-204h]@5

  hMenu = hMainMenu;
  hInstance = hInst;
  hmenu = (HMENU)lParam;
  hWnd = hwndStatus;
  v20 = 1;
  if ( uMsg == 287 )
  {
    v21 = wParam >> 16;
    if ( HIWORD(wParam) == -1 && !lParam )
    {
      SendMessageW(hwndStatus, 0x409u, 0, 0);
      return;
    }
    Buffer = 0;
    memset(&Dst, 0, 0x30u);
    v16 = 0;
    Dst = 48;
    v7 = (unsigned __int16)wParam;
    v13 = 16;
    if ( GetMenuItemInfoW(hmenu, (unsigned __int16)wParam, 1, (LPMENUITEMINFOW)&Dst) )
    {
      v8 = (v14 >> 3) & 0x400;
      v15 = (v14 >> 3) & 0x400;
    }
    else
    {
      v8 = v15;
    }
    if ( v21 & 0x800 )
      goto LABEL_31;
    if ( v21 & 0x10 )
    {
      v20 = 0;
      for ( i = lpwIDs + 2; *i; i += 2 )
      {
        if ( i[1] == (unsigned __int16)wParam )
        {
          v10 = *i;
          goto LABEL_27;
        }
      }
      if ( hmenu != hMenu )
      {
        if ( v21 & 0x2000 )
          goto LABEL_17;
        goto LABEL_31;
      }
      if ( IsMaxedMDI(hMenu) )
      {
        if ( !(_WORD)wParam )
        {
LABEL_17:
          v10 = -28688;
          goto LABEL_28;
        }
        v7 = (unsigned __int16)wParam - 1;
      }
      v11 = lpwIDs[1];
    }
    else
    {
      if ( (unsigned __int16)wParam >= 0xF000u )
      {
        v10 = (unsigned __int16)wParam - 28672;
        goto LABEL_28;
      }
      v11 = *lpwIDs;
    }
    v10 = v7 + v11;
LABEL_27:
    if ( hInstance != g_hinst )
    {
      LoadStringW(hInstance, v10, &Buffer, 256);
      goto LABEL_30;
    }
LABEL_28:
    LocalizedLoadString(v10, &Buffer, 256);
LABEL_30:
    v8 = v15;
LABEL_31:
    SendMessageW(hWnd, 0x40Bu, v8 | 0x1FF, (LPARAM)&Buffer);
    SendMessageW(hWnd, 0x409u, 1u, 0);
    if ( v20 )
      UpdateWindow(hWnd);
  }
}

//----- (6F7A2A1A) --------------------------------------------------------
BOOL __stdcall ShowHideMenuCtl(HWND hWnd, UINT_PTR uFlags, LPINT lpInfo)
{
  LPINT v3; // esi@1
  UINT v4; // ebx@1
  HMENU v5; // edi@1
  HWND v6; // eax@8
  HMENU v7; // eax@12
  HMENU v8; // eax@12
  signed int v10; // [sp+Ch] [bp-4h]@1
  LPINT lpInfoa; // [sp+20h] [bp+10h]@1

  v3 = lpInfo;
  v4 = 0;
  v5 = (HMENU)lpInfo[1];
  v10 = 0;
  lpInfoa = 0;
  while ( *v3 != uFlags )
  {
    if ( !*v3 )
      goto LABEL_12;
    lpInfoa = (LPINT)((char *)lpInfoa + 1);
    v3 += 2;
  }
  if ( !(GetMenuState(v5, uFlags, 0) & 8) )
    v4 = 8;
  if ( lpInfoa )
  {
    v6 = GetDlgItem(hWnd, v3[1]);
    if ( v6 )
    {
      ShowWindow(v6, (v4 & 8) != 0 ? 5 : 0);
      v10 = 1;
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v10 = SetMenu(hWnd, (HMENU)((v4 & 8) != 0 ? (unsigned int)v5 : 0));
  }
LABEL_12:
  CheckMenuItem(v5, uFlags, v4);
  v7 = GetSystemMenu(hWnd, 0);
  v8 = GetSubMenu(v7, 0);
  if ( v8 )
    CheckMenuItem(v8, uFlags, v4);
  return v10;
}

//----- (6F7A2AE5) --------------------------------------------------------
void __stdcall GetEffectiveClientRect(HWND hWnd, LPRECT lprc, const INT *lpInfo)
{
  const INT *i; // esi@1
  HWND v4; // eax@2
  HWND v5; // edi@2
  struct tagRECT Rect; // [sp+4h] [bp-10h]@4

  GetClientRect(hWnd, lprc);
  for ( i = lpInfo + 2; *i; i += 2 )
  {
    v4 = GetDlgItem(hWnd, i[1]);
    v5 = v4;
    if ( v4 )
    {
      if ( GetWindowLongW(v4, -16) & 0x10000000 )
      {
        GetWindowRect(v5, &Rect);
        MapWindowPoints(0, hWnd, (LPPOINT)&Rect, 2u);
        SubtractRect(lprc, lprc, &Rect);
      }
    }
  }
}

//----- (6F7A2B67) --------------------------------------------------------
BOOL __stdcall ImmNotifyIME(HIMC a1, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
{
  BOOL result; // eax@1

  result = (BOOL)g_pfnImmNotifyIME;
  if ( g_pfnImmNotifyIME )
    result = g_pfnImmNotifyIME(a1, dwAction, dwIndex, dwValue);
  return result;
}
// 6F7E6830: invalid function type has been ignored
// 6F7E6830: using guessed type int (__stdcall *g_pfnImmNotifyIME)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (6F7A2B9B) --------------------------------------------------------
HIMC __stdcall ImmGetContext(HWND a1)
{
  HIMC result; // eax@1

  result = (HIMC)g_pfnImmGetContext;
  if ( g_pfnImmGetContext )
    result = (HIMC)g_pfnImmGetContext(a1);
  return result;
}
// 6F7E683C: invalid function type has been ignored
// 6F7E683C: using guessed type int (__stdcall *g_pfnImmGetContext)(_DWORD);

//----- (6F7A2BB5) --------------------------------------------------------
LONG __stdcall ImmGetCompositionStringW(HIMC a1, DWORD a2, LPVOID lpBuf, DWORD dwBufLen)
{
  LONG result; // eax@1

  result = (LONG)g_pfnImmGetCompositionStringW;
  if ( g_pfnImmGetCompositionStringW )
    result = g_pfnImmGetCompositionStringW(a1, a2, lpBuf, dwBufLen);
  return result;
}
// 6F7E682C: invalid function type has been ignored
// 6F7E682C: using guessed type int (__stdcall *g_pfnImmGetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (6F7A2BCF) --------------------------------------------------------
BOOL __stdcall ImmSetCompositionStringW(HIMC a1, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
  BOOL result; // eax@1

  result = (BOOL)g_pfnImmSetCompositionStringW;
  if ( g_pfnImmSetCompositionStringW )
    result = g_pfnImmSetCompositionStringW(a1, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
  return result;
}
// 6F7E6850: invalid function type has been ignored
// 6F7E6850: using guessed type int (__stdcall *g_pfnImmSetCompositionStringW)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (6F7A2C03) --------------------------------------------------------
void __stdcall InitMUILanguage(LANGID uiLang)
{
  EnterCriticalSection(&g_csDll);
  g_PUILangId = uiLang;
  LeaveCriticalSection(&g_csDll);
}
// 6F7E8AA8: using guessed type __int16 g_PUILangId;

//----- (6F7A2C30) --------------------------------------------------------
LANGID __stdcall GetMUILanguage()
{
  return g_PUILangId;
}
// 6F7E8AA8: using guessed type __int16 g_PUILangId;

//----- (6F7A2C3C) --------------------------------------------------------
signed int __stdcall MirrorIcon(HICON *a1, HICON *a2)
{
  HICON *v2; // edi@7
  HDC v3; // eax@11
  HICON v4; // eax@15
  HICON v5; // eax@18
  HGDIOBJ v6; // ST20_4@18
  HICON v7; // ST20_4@23
  HICON v8; // ecx@24
  char pv; // [sp+8h] [bp-54h]@17
  int nWidth; // [sp+Ch] [bp-50h]@18
  int cy; // [sp+10h] [bp-4Ch]@18
  ICONINFO piconinfo; // [sp+20h] [bp-3Ch]@16
  HICON v14; // [sp+34h] [bp-28h]@1
  HICON v15; // [sp+38h] [bp-24h]@1
  HICON hIcon; // [sp+3Ch] [bp-20h]@1
  HICON v17; // [sp+40h] [bp-1Ch]@1
  HGDIOBJ v18; // [sp+44h] [bp-18h]@18
  HGDIOBJ v19; // [sp+48h] [bp-14h]@18
  HDC hdc; // [sp+4Ch] [bp-10h]@11
  HGDIOBJ ho; // [sp+50h] [bp-Ch]@18
  HGDIOBJ h; // [sp+54h] [bp-8h]@18
  unsigned int v23; // [sp+58h] [bp-4h]@14

  hIcon = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  EnterCriticalSection(&g_csDll);
  if ( !g_hdc && !g_hdcMask )
  {
    g_hdc = CreateCompatibleDC(0);
    if ( g_hdc )
    {
      g_hdcMask = CreateCompatibleDC(0);
      if ( g_hdcMask )
      {
        SetLayout(g_hdc, 1u);
        SetLayout(g_hdcMask, 1u);
      }
      else
      {
        DeleteDC(g_hdc);
        g_hdc = 0;
      }
    }
  }
  v2 = a1;
  if ( a1 )
    hIcon = *a1;
  if ( a2 )
    v17 = *a2;
  v3 = GetDC(0);
  hdc = v3;
  if ( g_hdc && g_hdcMask && v3 )
  {
    v23 = 0;
    do
    {
      v4 = *(HICON *)((char *)&hIcon + v23);
      if ( v4 && GetIconInfo(v4, &piconinfo) && GetObjectW(piconinfo.hbmColor, 24, &pv) )
      {
        DeleteObject(piconinfo.hbmMask);
        DeleteObject(piconinfo.hbmColor);
        piconinfo.hbmColor = 0;
        piconinfo.hbmMask = 0;
        h = CreateCompatibleBitmap(hdc, nWidth, cy);
        ho = CreateBitmap(nWidth, cy, 1u, 1u, 0);
        v19 = SelectObject(g_hdc, h);
        v18 = SelectObject(g_hdcMask, ho);
        DrawIconEx(g_hdc, 0, 0, *(HICON *)((char *)&hIcon + v23), nWidth, cy, 0, 0, 2u);
        DrawIconEx(g_hdcMask, 0, 0, *(HICON *)((char *)&hIcon + v23), nWidth, cy, 0, 0, 1u);
        SelectObject(g_hdc, v19);
        SelectObject(g_hdcMask, v18);
        piconinfo.hbmMask = (HBITMAP)ho;
        piconinfo.hbmColor = (HBITMAP)h;
        v5 = CreateIconIndirect(&piconinfo);
        v6 = h;
        *(HICON *)((char *)&v14 + v23) = v5;
        DeleteObject(v6);
        DeleteObject(ho);
      }
      v23 += 4;
    }
    while ( v23 < 8 );
    v2 = a1;
  }
  ReleaseDC(0, hdc);
  LeaveCriticalSection(&g_csDll);
  if ( hIcon && v14 )
  {
    v7 = hIcon;
    *v2 = v14;
    DestroyIcon(v7);
  }
  v8 = v17;
  if ( v17 )
  {
    if ( v15 )
    {
      *a2 = v15;
      if ( v8 != hIcon )
        DestroyIcon(v8);
    }
  }
  return 1;
}

//----- (6F7A2E7C) --------------------------------------------------------
unsigned __int32 __stdcall CNativeFont::v_OnStyleChanged(unsigned int a2, __int32 a3)
{
  return 0;
}

//----- (6F7A2E86) --------------------------------------------------------
void *__stdcall StringBufferAtoW(UINT CodePage, STRSAFE_LPWSTR pszDest, size_t cchDest, int a4)
{
  void *result; // eax@1
  void *v5; // edi@3

  result = *(void **)a4;
  if ( pszDest == *(STRSAFE_LPWSTR *)a4 )
  {
    if ( cchDest )
    {
      result = (void *)ProduceWFromA(CodePage, (LPCSTR)pszDest);
      v5 = result;
      if ( result )
      {
        StringCchCopyW(pszDest, cchDest, (STRSAFE_LPCWSTR)result);
        result = FreeProducedString(v5);
      }
    }
  }
  else
  {
    result = (void *)MultiByteToWideChar(CodePage, 1u, (LPCSTR)result, -1, pszDest, cchDest);
    *(_DWORD *)a4 = pszDest;
  }
  return result;
}

//----- (6F7A2EDF) --------------------------------------------------------
signed int __stdcall InOutWtoA(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // eax@1
  int v5; // eax@3
  char *v6; // eax@5
  signed int v8; // [sp+Ch] [bp-4h]@1

  v4 = *(_DWORD *)a3;
  v8 = 1;
  *(_DWORD *)a2 = *(_DWORD *)a3;
  *(_DWORD *)(a2 + 8) = a4;
  if ( v4 )
  {
    if ( v4 != -1 )
    {
      v8 = 0;
      v5 = PrivateLocalAllocArray(a4, 2u);
      *(_DWORD *)(a2 + 4) = v5;
      if ( v5 )
      {
        if ( WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, *(LPCWSTR *)a2, -1, (LPSTR)v5, *(_DWORD *)(a2 + 8), 0, 0) )
        {
          v6 = (char *)(a4 + *(_DWORD *)(a2 + 4));
          *(_DWORD *)a3 = v6;
          StringCchCopyA(v6, *(_DWORD *)(a2 + 8), *(STRSAFE_LPCSTR *)(a2 + 4));
          v8 = 1;
        }
        else
        {
          LocalFree(*(HLOCAL *)(a2 + 4));
        }
      }
    }
  }
  return v8;
}

//----- (6F7A2F6C) --------------------------------------------------------
STRSAFE_LPWSTR __stdcall InOutAtoW(int a1, int a2, int a3)
{
  STRSAFE_LPWSTR result; // eax@8

  if ( *(_DWORD *)a2 && *(_DWORD *)a2 != -1 )
  {
    if ( *(_DWORD *)a3 && *(_DWORD *)a3 != -1 && lstrcmpA(*(LPCSTR *)(a2 + 4), *(LPCSTR *)a3) )
      StringBufferAtoW(*(_DWORD *)(a1 + 20), *(STRSAFE_LPWSTR *)a2, *(_DWORD *)(a2 + 8), a3);
    LocalFree(*(HLOCAL *)(a2 + 4));
  }
  result = *(STRSAFE_LPWSTR *)a2;
  *(_DWORD *)a3 = *(_DWORD *)a2;
  return result;
}

//----- (6F7A2FC6) --------------------------------------------------------
HWND __stdcall SendNotify(int a1, int a2, int a3, LPARAM lParam)
{
  int v5; // [sp+0h] [bp-24h]@1
  int v6; // [sp+4h] [bp-20h]@1
  int v7; // [sp+10h] [bp-14h]@1
  int v8; // [sp+14h] [bp-10h]@1

  v7 &= 0xFFFFFFFE;
  v8 = 0;
  v6 = a1;
  v5 = a2;
  return CCSendNotify((int)&v5, a3, lParam);
}

//----- (6F7A2FFA) --------------------------------------------------------
BOOL __stdcall CCReleaseCapture(int a1)
{
  HWND v1; // ebx@1
  LPARAM lParam; // [sp+Ch] [bp-Ch]@1
  int v4; // [sp+10h] [bp-8h]@1
  int v5; // [sp+14h] [bp-4h]@1

  lParam = 0;
  v1 = *(HWND *)a1;
  v4 = 0;
  v5 = 0;
  ReleaseCapture();
  CCSendNotify(a1, -16, (LPARAM)&lParam);
  return IsWindow(v1);
}

//----- (6F7A303A) --------------------------------------------------------
int __stdcall ComboEx_GetComboClientRect(int a1, LPRECT lpRect)
{
  int result; // eax@1

  GetClientRect(*(HWND *)(a1 + 36), lpRect);
  InflateRect(lpRect, -g_cxEdge, -g_cyEdge);
  result = g_cxScrollbar;
  lpRect->right -= g_cxScrollbar;
  return result;
}
// 6F7E6970: using guessed type int g_cxScrollbar;

//----- (6F7A3079) --------------------------------------------------------
COLORREF __stdcall EraseWindow(HWND hWnd, HDC hdc, COLORREF color)
{
  struct tagRECT Rect; // [sp+0h] [bp-10h]@1

  GetClientRect(hWnd, &Rect);
  return FillRectClr(hdc, &Rect, color);
}

//----- (6F7A30A6) --------------------------------------------------------
wchar_t *__stdcall ComboEx_ISetItem(int a1, int a2, int a3)
{
  wchar_t *result; // eax@2

  if ( *(_BYTE *)a3 & 0x10 )
  {
    result = *(wchar_t **)(a3 + 28);
    *(_DWORD *)(a2 + 16) = result;
  }
  if ( *(_BYTE *)a3 & 2 )
  {
    result = *(wchar_t **)(a3 + 16);
    *(_DWORD *)(a2 + 4) = result;
  }
  if ( *(_BYTE *)a3 & 4 )
  {
    result = *(wchar_t **)(a3 + 20);
    *(_DWORD *)(a2 + 8) = result;
  }
  if ( *(_BYTE *)a3 & 8 )
  {
    result = *(wchar_t **)(a3 + 24);
    *(_DWORD *)(a2 + 12) = result;
  }
  if ( *(_BYTE *)a3 & 1 )
    result = Str_Set(a2, *(LPCWSTR *)(a3 + 8));
  if ( *(_BYTE *)a3 & 0x20 )
  {
    result = *(wchar_t **)(a3 + 32);
    *(_DWORD *)(a2 + 20) = result;
  }
  return result;
}

//----- (6F7A3103) --------------------------------------------------------
signed int __stdcall ComboEx_OnGetItem(int a1, int a2)
{
  int v2; // ebx@1
  WPARAM v3; // eax@1
  LRESULT v4; // esi@2
  int v5; // ecx@12
  int v6; // eax@25
  int v7; // eax@30
  char v8; // al@34
  STRSAFE_LPCWSTR v9; // eax@44
  signed int result; // eax@49
  LPARAM lParam; // [sp+Ch] [bp-30h]@34
  int v12; // [sp+18h] [bp-24h]@6
  STRSAFE_LPCWSTR pszSrc; // [sp+20h] [bp-1Ch]@33
  int v14; // [sp+24h] [bp-18h]@32
  int v15; // [sp+28h] [bp-14h]@37
  int v16; // [sp+2Ch] [bp-10h]@39
  int v17; // [sp+30h] [bp-Ch]@41
  int v18; // [sp+34h] [bp-8h]@35
  int v19; // [sp+38h] [bp-4h]@31
  int v20; // [sp+48h] [bp+Ch]@2

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 == -1 )
  {
    v20 = a1 + 64;
    v4 = a1 + 64;
  }
  else
  {
    v4 = SendMessageW(*(HWND *)(a1 + 36), 0x150u, v3, 0);
    v20 = v4;
  }
  if ( v4 && v4 != -1 )
  {
    v12 = 0;
    if ( *(_BYTE *)v2 & 1 )
    {
      if ( *(_DWORD *)v4 == -1 )
      {
        v12 = 1;
      }
      else if ( *(_DWORD *)(v2 + 4) == -1 )
      {
        SendMessageW(*(HWND *)(a1 + 40), 0xDu, *(_DWORD *)(v2 + 12), *(_DWORD *)(v2 + 8));
      }
      else
      {
        Str_GetPtrW(*(LPCWSTR *)v4, *(void **)(v2 + 8), *(_DWORD *)(v2 + 12));
      }
    }
    v5 = *(_DWORD *)v2;
    if ( *(_DWORD *)v2 & 2 )
    {
      if ( *(_DWORD *)(v4 + 4) == -1 )
        v12 |= 2u;
      *(_DWORD *)(v2 + 16) = *(_DWORD *)(v4 + 4);
    }
    if ( v5 & 4 )
    {
      if ( *(_DWORD *)(v4 + 8) == -1 )
        v12 |= 4u;
      *(_DWORD *)(v2 + 20) = *(_DWORD *)(v4 + 8);
    }
    if ( v5 & 8 )
    {
      if ( *(_DWORD *)(v4 + 12) == -1 )
        v12 |= 8u;
      *(_DWORD *)(v2 + 24) = *(_DWORD *)(v4 + 12);
    }
    if ( v5 & 0x10 )
    {
      v6 = *(_DWORD *)(v4 + 16);
      if ( v6 == -1 )
      {
        v12 |= 0x10u;
        *(_DWORD *)(v2 + 28) = 0;
      }
      else
      {
        *(_DWORD *)(v2 + 28) = v6;
      }
    }
    if ( v5 & 0x20 )
      *(_DWORD *)(v2 + 32) = *(_DWORD *)(v4 + 20);
    v7 = v12;
    if ( v12 )
    {
      qmemcpy(&v12, (const void *)v2, 0x24u);
      v19 = *(_DWORD *)(v20 + 20);
      v12 = v7;
      if ( v7 & 1 && v14 )
        *pszSrc = 0;
      CCSendNotify(a1, -807, (LPARAM)&lParam);
      v8 = v12;
      if ( v12 & 0x10 )
        *(_DWORD *)(v2 + 28) = v18;
      if ( v8 & 2 )
        *(_DWORD *)(v2 + 16) = v15;
      if ( v8 & 4 )
        *(_DWORD *)(v2 + 20) = v16;
      if ( v8 & 8 )
        *(_DWORD *)(v2 + 24) = v17;
      if ( v8 & 1 )
      {
        if ( *(_BYTE *)v2 & 1 )
          v9 = CCReturnDispInfoText(pszSrc, *(STRSAFE_LPWSTR *)(v2 + 8), *(_DWORD *)(v2 + 12));
        else
          v9 = pszSrc;
        *(_DWORD *)(v2 + 8) = v9;
      }
      if ( v12 & 0x10000000 )
        ComboEx_ISetItem(a1, v20, (int)&v12);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A32AC) --------------------------------------------------------
HLOCAL __stdcall ComboEx_HandleDeleteItem(int a1, int a2)
{
  int v2; // esi@1
  HLOCAL result; // eax@2
  LPARAM lParam; // [sp+8h] [bp-30h]@2
  int v5; // [sp+14h] [bp-24h]@2
  int v6; // [sp+18h] [bp-20h]@2
  int v7; // [sp+34h] [bp-4h]@2

  v2 = *(_DWORD *)(a2 + 16);
  if ( v2 )
  {
    Str_Set(v2, 0);
    v6 = *(_DWORD *)(a2 + 8);
    v7 = *(_DWORD *)(v2 + 20);
    v5 = 32;
    CCSendNotify(a1, -802, (LPARAM)&lParam);
    result = LocalFree((HLOCAL)v2);
  }
  return result;
}

//----- (6F7A32FE) --------------------------------------------------------
signed int __stdcall ComboEx_OnInsertItem(int a1, int a2)
{
  int v2; // eax@1
  LPARAM v3; // edi@1
  signed int result; // eax@2
  const void *v5; // esi@3
  LPARAM lParam; // [sp+4h] [bp-30h]@4
  char v7; // [sp+10h] [bp-24h]@4
  LRESULT v8; // [sp+40h] [bp+Ch]@3

  v2 = (int)LocalAlloc(0x40u, 0x18u);
  v3 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 4) = -1;
    *(_DWORD *)(v2 + 8) = -1;
    v5 = (const void *)a2;
    ComboEx_ISetItem(a1, v2, a2);
    v8 = SendMessageW(*(HWND *)(a1 + 36), 0x14Au, *(_DWORD *)(a2 + 4), v3);
    if ( v8 != -1 )
    {
      qmemcpy(&v7, v5, 0x24u);
      CCSendNotify(a1, -801, (LPARAM)&lParam);
    }
    result = v8;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7A3374) --------------------------------------------------------
int __stdcall ComboEx_OnGetItemData(int a1, WPARAM wParam)
{
  LRESULT v2; // eax@1
  int result; // eax@3

  v2 = SendMessageW(*(HWND *)(a1 + 36), 0x150u, wParam, 0);
  if ( v2 && v2 != -1 )
    result = *(_DWORD *)(v2 + 20);
  else
    result = -1;
  return result;
}

//----- (6F7A33A9) --------------------------------------------------------
int __stdcall ComboEx_OnSetItemData(int a1, WPARAM wParam, int a3)
{
  LRESULT v3; // eax@1
  int result; // eax@3

  v3 = SendMessageW(*(HWND *)(a1 + 36), 0x150u, wParam, 0);
  if ( v3 && v3 != -1 )
  {
    *(_DWORD *)(v3 + 20) = a3;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7A33E3) --------------------------------------------------------
int __stdcall ComboEx_StrCmp(int a1, LPCWSTR lpString1, LPCWSTR lpString2)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 44) & 0x10 )
    result = lstrcmpW(lpString1, lpString2);
  else
    result = lstrcmpiW(lpString1, lpString2);
  return result;
}

//----- (6F7A340E) --------------------------------------------------------
LRESULT __stdcall ComboEx_GetFont(int a1)
{
  HWND v1; // eax@1
  LRESULT result; // eax@2

  v1 = *(HWND *)(a1 + 36);
  if ( v1 )
    result = SendMessageW(v1, 0x31u, 0, 0);
  else
    result = 0;
  return result;
}

//----- (6F7A3437) --------------------------------------------------------
BOOL __stdcall IsDelimiter(__int16 a1)
{
  return a1 == 32 || a1 == 9 || a1 == 46 || a1 == 47 || a1 == 92;
}

//----- (6F7A346E) --------------------------------------------------------
int __stdcall ShellEditWordBreakProc(LPCWSTR lpszStart, int a2, int a3, int a4)
{
  LPWSTR v4; // ecx@1
  signed int v5; // ebx@1
  int result; // eax@1
  __int16 v7; // ST04_2@4
  __int16 v8; // ST04_2@5
  const WCHAR *v9; // edi@5
  int v10; // edx@5
  __int16 *v11; // ecx@5
  bool v12; // zf@5
  int v13; // edx@6
  int v14; // ecx@18

  v4 = (LPWSTR)&lpszStart[a2];
  v5 = 0;
  result = 0;
  if ( a4 )
  {
    if ( a4 == 1 )
    {
      v8 = *v4;
      dword_6F7E8AAC = 0;
      v9 = &lpszStart[a3];
      v10 = IsDelimiter(v8) == 0;
      v12 = (const WCHAR *)v11 == v9;
LABEL_8:
      if ( !v12 )
      {
        while ( 1 )
        {
          ++v11;
          if ( (const WCHAR *)v11 == v9 )
            break;
          if ( !IsDelimiter(*v11) )
          {
            v12 = v13 == 0;
            goto LABEL_8;
          }
        }
      }
      result = ((char *)v11 - (char *)lpszStart) >> 1;
    }
    else if ( a4 == 2 )
    {
      v7 = *v4;
      dword_6F7E8AAC = 1;
      result = IsDelimiter(v7);
    }
  }
  else
  {
    while ( 1 )
    {
      v4 = CharPrevW(lpszStart, v4);
      if ( v4 == lpszStart )
        break;
      if ( IsDelimiter(*v4) )
      {
        if ( dword_6F7E8AAC || v5 )
          break;
      }
      else
      {
        v5 = 1;
        dword_6F7E8AAC = 0;
      }
    }
    v14 = v4 - lpszStart;
    result = v14;
    if ( v14 > 0 && v14 < a3 )
      result = v14 + 1;
  }
  return result;
}
// 6F7E8AAC: using guessed type int dword_6F7E8AAC;

//----- (6F7A3543) --------------------------------------------------------
signed int __stdcall ComboEx_GetCurSelText(int a1, int a2, int a3)
{
  signed int v3; // ebx@1
  HWND v4; // ST00_4@1
  int v6; // [sp+Ch] [bp-24h]@1
  LRESULT v7; // [sp+10h] [bp-20h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1

  v3 = 1;
  *(_WORD *)a2 = 0;
  v4 = *(HWND *)(a1 + 36);
  v6 = 1;
  v8 = a2;
  v9 = a3;
  v7 = SendMessageW(v4, 0x147u, 0, 0);
  if ( v7 == -1 )
  {
    *(_WORD *)a2 = 0;
    v3 = 0;
  }
  else
  {
    ComboEx_OnGetItem(a1, (int)&v6);
  }
  return v3;
}

//----- (6F7A35A3) --------------------------------------------------------
LRESULT __stdcall ComboEx_UpdateEditText(int a1, int a2)
{
  LRESULT result; // eax@1
  HWND v3; // ebx@3
  LPARAM lParam; // [sp+0h] [bp-20Ch]@5

  result = a1;
  if ( !(*(_BYTE *)(a1 + 88) & 8) )
  {
    if ( (*(_DWORD *)(a1 + 8) & 3) == 2 )
      v3 = *(HWND *)(a1 + 40);
    else
      v3 = *(HWND *)(a1 + 36);
    result = ComboEx_GetCurSelText(a1, (int)&lParam, 260);
    if ( result || a2 )
    {
      SendMessageW(v3, 0xCu, 0, (LPARAM)&lParam);
      SendMessageW(v3, 0xB1u, 0, 0);
      result = SendMessageW(v3, 0xB1u, 0, -1);
    }
  }
  return result;
}

//----- (6F7A3630) --------------------------------------------------------
int __stdcall ComboEx_OnDrawItem(int a1, int a2)
{
  HDC v2; // eax@1
  HWND v3; // ST1C_4@1
  int v4; // esi@1
  BOOL v5; // eax@1
  HWND v6; // ST18_4@1
  int v7; // edi@4
  int v8; // eax@4
  struct _IMAGELIST *v9; // eax@11
  LONG v10; // eax@21
  bool v11; // zf@21
  LONG v12; // esi@22
  int v13; // eax@22
  signed int v14; // edi@22
  COLORREF v15; // eax@28
  COLORREF v16; // eax@27
  int result; // eax@34
  signed int v18; // edx@39
  int v19; // edi@45
  int v20; // [sp+Ch] [bp-27Ch]@4
  int v21; // [sp+10h] [bp-278h]@4
  WCHAR *v22; // [sp+14h] [bp-274h]@4
  int v23; // [sp+18h] [bp-270h]@4
  int v24; // [sp+1Ch] [bp-26Ch]@46
  int i; // [sp+20h] [bp-268h]@45
  int v26; // [sp+24h] [bp-264h]@47
  int v27; // [sp+28h] [bp-260h]@16
  UINT c; // [sp+30h] [bp-258h]@21
  LONG v29; // [sp+34h] [bp-254h]@1
  UINT align; // [sp+38h] [bp-250h]@2
  int v31; // [sp+3Ch] [bp-24Ch]@21
  int y; // [sp+40h] [bp-248h]@22
  struct tagSIZE sz; // [sp+44h] [bp-244h]@1
  int cy; // [sp+4Ch] [bp-23Ch]@1
  int v35; // [sp+50h] [bp-238h]@1
  int v36; // [sp+54h] [bp-234h]@1
  RECT rect; // [sp+58h] [bp-230h]@1
  int x; // [sp+68h] [bp-220h]@21
  int v39; // [sp+6Ch] [bp-21Ch]@1
  int v40; // [sp+70h] [bp-218h]@1
  HDC hdc; // [sp+74h] [bp-214h]@1
  int v42; // [sp+78h] [bp-210h]@1
  WCHAR String; // [sp+7Ch] [bp-20Ch]@3

  v2 = *(HDC *)(a2 + 24);
  v3 = *(HWND *)(a1 + 36);
  rect.left = *(_DWORD *)(a2 + 28);
  rect.top = *(_DWORD *)(a2 + 32);
  rect.right = *(_DWORD *)(a2 + 36);
  rect.bottom = *(_DWORD *)(a2 + 40);
  v4 = 0;
  hdc = v2;
  sz.cx = 0;
  v42 = a1;
  v40 = 0;
  cy = 0;
  v36 = 0;
  sz.cy = 0;
  v39 = 0;
  v5 = IsWindowEnabled(v3);
  v6 = *(HWND *)(a2 + 20);
  v35 = v5;
  v29 = GetWindowLongW(v6, -20) & 0x2000;
  if ( v29 )
  {
    align = GetTextAlign(hdc);
    SetTextAlign(hdc, align | 0x100);
  }
  rect.top += g_cyBorder;
  String = 0;
  if ( *(_DWORD *)(a2 + 8) == -1 )
  {
    if ( *(_BYTE *)(v42 + 88) & 1 )
    {
      v21 = -1;
      v22 = &String;
      v20 = 31;
      v23 = 260;
      ComboEx_OnGetItem(v42, (int)&v20);
      v7 = v42;
    }
    else
    {
      v7 = v42;
    }
  }
  else
  {
    v7 = v42;
    v21 = *(_DWORD *)(a2 + 8);
    v20 = 31;
    v22 = &String;
    v23 = 260;
    ComboEx_OnGetItem(v42, (int)&v20);
    v8 = *(_DWORD *)(v7 + 60);
    if ( v8 == *(_DWORD *)(a2 + 8) || v8 == -1 && *(_DWORD *)(a2 + 8) == SendMessageW(*(HWND *)(v7 + 36), 0x147u, 0, 0) )
      v36 = 1;
  }
  v9 = *(struct _IMAGELIST **)(v7 + 48);
  if ( v9 )
  {
    if ( !(*(_BYTE *)(v7 + 44) & 2) )
    {
      ImageList_GetIconSize(v9, &v40, &cy);
      if ( v40 )
        v40 += 4;
    }
  }
  if ( *(_DWORD *)(a2 + 16) & 0x1000 )
  {
    if ( *(_DWORD *)(v7 + 40) )
      v39 = 1;
    if ( *(_BYTE *)(v7 + 44) & 2 )
      v40 = 0;
  }
  else
  {
    v4 = v27 * *(_DWORD *)(v7 + 56) + 3;
  }
  v31 = v4 + rect.left;
  x = v40 + v4 + rect.left;
  rect.left += v40 + v4;
  c = lstrlenW(&String);
  GetTextExtentPointW(hdc, &String, c, &sz);
  v10 = rect.left + sz.cx;
  --rect.left;
  v11 = *(_DWORD *)(a2 + 12) == 4;
  rect.right = v10 + 1;
  if ( v11 )
    goto LABEL_57;
  v12 = (rect.bottom + rect.top) / 2;
  y = v12 - sz.cy / 2;
  v13 = *(_DWORD *)(a2 + 16);
  v14 = 0;
  if ( v13 & 1 && (!(v13 & 0x1000) || (*(_DWORD *)(v42 + 8) & 3) != 2) )
    v14 = 1;
  if ( v35 )
  {
    v15 = GetSysColor(8 * (v14 != 0) + 5);
    SetBkColor(hdc, v15);
    v16 = GetSysColor(v14 != 0 ? 14 : 8);
  }
  else
  {
    SetBkColor(hdc, g_clrBtnFace);
    v16 = GetSysColor(17);
  }
  SetTextColor(hdc, v16);
  if ( *(_DWORD *)(a2 + 16) & 0x1000 && rect.right > *(_DWORD *)(a2 + 36) )
    rect.right = *(_DWORD *)(a2 + 36);
  if ( !v39 )
    ExtTextOutW(hdc, x, y, 6u, &rect, &String, c, 0);
  result = *(_DWORD *)(v42 + 48);
  x = result;
  if ( result )
  {
    if ( *(_DWORD *)(a2 + 8) != -1 || (result = v42, *(_BYTE *)(v42 + 88) & 1) )
    {
      result = v42;
      if ( !(*(_DWORD *)(v42 + 44) & 3) || !(*(_DWORD *)(a2 + 16) & 0x1000) )
      {
        result = *(_DWORD *)(a2 + 16);
        v18 = 0;
        if ( result & 0x1000 && !v35 )
          v18 = 1;
        if ( (*(_DWORD *)(a2 + 8) != -1 || *(_BYTE *)(v42 + 88) & 1) && !(*(_DWORD *)(v42 + 44) & 3) )
        {
          v19 = i;
          if ( !v36 )
            v19 = v24;
          result = ImageList_Draw(
                     (HIMAGELIST)x,
                     v19,
                     hdc,
                     v31,
                     v12 - cy / 2,
                     v18 | (v26 << 8) | ((*(_DWORD *)(a2 + 16) & 1) != 0 ? 6 : 0));
        }
      }
    }
  }
  v7 = v42;
  if ( *(_DWORD *)(a2 + 12) == 4 || *(_BYTE *)(a2 + 16) & 0x10 )
  {
LABEL_57:
    result = CCGetUIState(v7);
    if ( !(result & 1) && !v39 )
      result = DrawFocusRect(hdc, &rect);
  }
  if ( v29 )
    result = SetTextAlign(hdc, align);
  return result;
}

//----- (6F7A3AB0) --------------------------------------------------------
int __stdcall ComboEx_ComputeItemHeight(int cy, int a2)
{
  LRESULT v2; // eax@1
  HGDIOBJ v3; // esi@1
  int v4; // ebx@3
  struct _IMAGELIST *v5; // eax@6
  struct tagSIZE sz; // [sp+Ch] [bp-Ch]@1
  HDC hdc; // [sp+14h] [bp-4h]@1

  sz.cx = 0;
  sz.cy = 0;
  hdc = GetDC(0);
  v2 = ComboEx_GetFont(cy);
  v3 = (HGDIOBJ)v2;
  if ( v2 )
    v3 = SelectObject(hdc, (HGDIOBJ)v2);
  GetTextExtentPointW(hdc, L"W", 1, &sz);
  v4 = sz.cy;
  if ( v3 )
    SelectObject(hdc, v3);
  ReleaseDC(0, hdc);
  if ( !a2 )
  {
    v5 = *(struct _IMAGELIST **)(cy + 48);
    v4 += 3;
    if ( v5 )
    {
      a2 = 0;
      cy = 0;
      ImageList_GetIconSize(v5, &a2, &cy);
      if ( v4 < cy )
        v4 = cy;
    }
  }
  return v4;
}

//----- (6F7A3B59) --------------------------------------------------------
int __stdcall ComboEx_OnMeasureItem(int cy, int a2)
{
  int result; // eax@1

  result = ComboEx_ComputeItemHeight(cy, 0);
  *(_DWORD *)(a2 + 16) = result;
  return result;
}

//----- (6F7A3B77) --------------------------------------------------------
signed int __stdcall ComboEx_OnGetItemA(int a1, int pulResult)
{
  int v2; // esi@1
  signed int result; // eax@2
  const WCHAR *v4; // eax@4
  const WCHAR *v5; // ebx@4
  CHAR *v6; // edi@6
  signed int v7; // [sp+Ch] [bp+8h]@6

  v2 = pulResult;
  if ( *(_BYTE *)pulResult & 1 )
  {
    if ( ULongAdd(*(_DWORD *)(pulResult + 12), 1u, (ULONG *)&pulResult) >= 0
      && (v4 = (const WCHAR *)CCLocalAllocArray_WCHAR(pulResult), (v5 = v4) != 0) )
    {
      v6 = *(CHAR **)(v2 + 8);
      *(_DWORD *)(v2 + 8) = v4;
      v7 = ComboEx_OnGetItem(a1, v2);
      *(_DWORD *)(v2 + 8) = v6;
      if ( v7 )
        WideCharToMultiByte(0, 0, v5, -1, v6, *(_DWORD *)(v2 + 12), 0, 0);
      LocalFree((HLOCAL)v5);
      result = v7;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = ComboEx_OnGetItem(a1, pulResult);
  }
  return result;
}
// 6F7A3B77: could not find valid save-restore pair for ebx
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F7A3BF9) --------------------------------------------------------
signed int __stdcall ComboEx_OnSetItem(int a1, int a2)
{
  WPARAM v2; // eax@1
  int v3; // eax@2
  HWND v5; // eax@6
  LPARAM v6; // edi@8

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 == -1 )
  {
    *(_DWORD *)(a1 + 68) = -1;
    *(_DWORD *)(a1 + 72) = -1;
    ComboEx_ISetItem(a1, a1 + 64, a2);
    v5 = *(HWND *)(a1 + 40);
    *(_DWORD *)(a1 + 88) |= 1u;
    if ( !v5 )
    {
      Str_Set(a1 + 64, 0);
      *(_DWORD *)(a1 + 88) &= 0xFFFFFFFE;
      return -1;
    }
    v6 = *(_DWORD *)(a1 + 64);
    if ( v6 )
    {
      SendMessageW(v5, 0xCu, 0, v6);
      SendMessageW(*(HWND *)(a1 + 40), 0xB1u, 0, 0);
      SendMessageW(*(HWND *)(a1 + 40), 0xB1u, 0, -1);
    }
    RedrawWindow(*(HWND *)(a1 + 36), 0, 0, 5u);
  }
  else
  {
    v3 = SendMessageW(*(HWND *)(a1 + 36), 0x150u, v2, 0);
    if ( v3 == -1 )
      return 0;
    ComboEx_ISetItem(a1, v3, a2);
    if ( *(_DWORD *)(a2 + 4) == SendMessageW(*(HWND *)(a1 + 36), 0x147u, 0, 0) )
      ComboEx_UpdateEditText(a1, 0);
  }
  return 1;
}

//----- (6F7A3CCE) --------------------------------------------------------
signed int __stdcall ComboEx_OnFindStringExact(int a1, signed int a2, const WCHAR *a3)
{
  HWND v3; // ST00_4@1
  LRESULT v4; // eax@1
  signed int v5; // ebx@1
  int v6; // edi@3
  int v8; // [sp+Ch] [bp-238h]@3
  int v9; // [sp+10h] [bp-234h]@4
  WCHAR *v10; // [sp+14h] [bp-230h]@3
  int v11; // [sp+18h] [bp-22Ch]@3
  int v12; // [sp+30h] [bp-214h]@1
  LPCWSTR lpString1; // [sp+34h] [bp-210h]@1
  WCHAR String2; // [sp+38h] [bp-20Ch]@3

  v3 = *(HWND *)(a1 + 36);
  lpString1 = a3;
  v4 = SendMessageW(v3, 0x146u, 0, 0);
  v5 = a2;
  v12 = v4;
  if ( a2 < 0 )
    v5 = -1;
  v6 = v5 + 1;
  v8 = 1;
  v10 = &String2;
  v11 = 260;
  if ( v5 + 1 >= v4 )
  {
LABEL_7:
    v6 = 0;
    if ( v5 < 0 )
      return -1;
    while ( 1 )
    {
      v9 = v6;
      if ( ComboEx_OnGetItem(a1, (int)&v8) )
      {
        if ( !ComboEx_StrCmp(a1, lpString1, &String2) )
          break;
      }
      ++v6;
      if ( v6 > v5 )
        return -1;
    }
  }
  else
  {
    while ( 1 )
    {
      v9 = v6;
      if ( ComboEx_OnGetItem(a1, (int)&v8) )
      {
        if ( !ComboEx_StrCmp(a1, lpString1, &String2) )
          break;
      }
      ++v6;
      if ( v6 >= v12 )
        goto LABEL_7;
    }
  }
  return v6;
}

//----- (6F7A3DC8) --------------------------------------------------------
LRESULT __stdcall SetPathWordBreakProc(HWND hWnd, int a2)
{
  LRESULT result; // eax@1

  result = SendMessageW(hWnd, 0xD1u, 0, 0);
  if ( a2 )
  {
    if ( !result )
      result = SendMessageW(hWnd, 0xD0u, 0, (LPARAM)ShellEditWordBreakProc);
  }
  else if ( (int (__stdcall *)(LPCWSTR, int, int, int))result == ShellEditWordBreakProc )
  {
    result = SendMessageW(hWnd, 0xD0u, 0, 0);
  }
  return result;
}

//----- (6F7A3E11) --------------------------------------------------------
int __stdcall ComboEx_OnSetFont(int cy, UINT fWinIni, LPARAM lParam)
{
  UINT v3; // ebx@1
  HFONT v4; // eax@4
  UINT v5; // eax@6
  HWND v6; // ST00_4@6
  HWND v7; // eax@6
  int v8; // ST1C_4@8
  int result; // eax@8
  HGDIOBJ ho; // [sp+10h] [bp-64h]@1
  char pvParam; // [sp+14h] [bp-60h]@4

  ho = 0;
  v3 = fWinIni;
  if ( *(_BYTE *)(cy + 88) & 4 )
    ho = (HGDIOBJ)ComboEx_GetFont(cy);
  if ( fWinIni )
  {
    *(_DWORD *)(cy + 88) &= 0xFFFFFFFB;
  }
  else
  {
    SystemParametersInfoW(0x1Fu, 0x5Cu, &pvParam, 0);
    v4 = CreateFontIndirectW((const LOGFONTW *)&pvParam);
    *(_DWORD *)(cy + 88) |= 4u;
    v3 = (UINT)v4;
  }
  v5 = GetCodePageForFont((HANDLE)v3);
  v6 = *(HWND *)(cy + 36);
  *(_DWORD *)(cy + 20) = v5;
  SendMessageW(v6, 0x30u, v3, lParam);
  v7 = *(HWND *)(cy + 40);
  if ( v7 )
  {
    SendMessageW(v7, 0x30u, v3, lParam);
    SendMessageW(*(HWND *)(cy + 40), 0xD3u, 0xFFFFu, 0);
  }
  v8 = ComboEx_ComputeItemHeight(cy, 0);
  SendMessageW(*(HWND *)cy, 0x153u, 0xFFFFFFFF, v8);
  result = SendMessageW(*(HWND *)(cy + 36), 0x153u, 0, v8);
  if ( ho )
    result = DeleteObject(ho);
  return result;
}

//----- (6F7A3EEB) --------------------------------------------------------
int __stdcall ComboEx_EndEdit(DWORD dwStyle, int a2)
{
  int result; // eax@1
  LRESULT v3; // eax@2
  HWND v4; // eax@2
  LRESULT v5; // eax@3
  HWND v6; // [sp-18h] [bp-244h]@5
  WPARAM v7; // [sp-10h] [bp-23Ch]@5
  int v8; // [sp+4h] [bp-228h]@2
  LPARAM lParam; // [sp+8h] [bp-224h]@2
  int v10; // [sp+14h] [bp-218h]@2
  int v11; // [sp+18h] [bp-214h]@2
  WCHAR String; // [sp+1Ch] [bp-210h]@2
  int v13; // [sp+224h] [bp-8h]@2

  result = ComboEx_GetEditBox(dwStyle);
  if ( result )
  {
    *(_DWORD *)(dwStyle + 88) |= 8u;
    GetWindowTextW(*(HWND *)(dwStyle + 40), &String, 260);
    v10 = *(_DWORD *)(dwStyle + 88) << 30 >> 31;
    v13 = a2;
    v3 = SendMessageW(*(HWND *)(dwStyle + 36), 0x147u, 0, 0);
    v11 = ComboEx_OnFindStringExact(dwStyle, v3 - 1, &String);
    v4 = CCSendNotify(dwStyle, -806, (LPARAM)&lParam);
    *(_DWORD *)(dwStyle + 88) &= 0xFFFFFFF7;
    v8 = (int)v4;
    if ( !v4 )
    {
      v5 = SendMessageW(*(HWND *)(dwStyle + 36), 0x147u, 0, 0);
      if ( v11 != v5 )
      {
        if ( v11 == -1 )
        {
          v7 = -1;
          v6 = *(HWND *)(dwStyle + 36);
        }
        else
        {
          v7 = v11;
          v6 = *(HWND *)dwStyle;
        }
        SendMessageW(v6, 0x14Eu, v7, 0);
      }
      *(_DWORD *)(dwStyle + 88) &= 0xFFFFFFFD;
    }
    InvalidateRect(*(HWND *)(dwStyle + 36), 0, 0);
    result = v8;
  }
  return result;
}

//----- (6F7A3FEF) --------------------------------------------------------
BOOL __stdcall ComboEx_SizeEditBox(int a1)
{
  struct _IMAGELIST *v1; // eax@1
  int v2; // eax@5
  RECT Rect; // [sp+4h] [bp-18h]@1
  int cy; // [sp+14h] [bp-8h]@1
  int v6; // [sp+18h] [bp-4h]@1

  v6 = 0;
  cy = 0;
  ComboEx_GetComboClientRect(a1, &Rect);
  InvalidateRect(*(HWND *)(a1 + 36), &Rect, 1);
  v1 = *(struct _IMAGELIST **)(a1 + 48);
  if ( v1 )
  {
    if ( !(*(_BYTE *)(a1 + 44) & 2) )
    {
      ImageList_GetIconSize(v1, &v6, &cy);
      if ( v6 )
        v6 += 4;
    }
  }
  Rect.left += v6 + g_cxBorder;
  Rect.bottom -= g_cyBorder;
  v2 = ComboEx_ComputeItemHeight(a1, 1);
  Rect.top = Rect.bottom - g_cyBorder - v2;
  return SetWindowPos(*(HWND *)(a1 + 40), 0, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, 0x54u);
}

//----- (6F7A4093) --------------------------------------------------------
BOOL __stdcall ComboSubclass_HandleCommand(DWORD dwStyle, int a2, int a3)
{
  unsigned int v3; // eax@1
  const WCHAR *v4; // eax@6
  int v5; // eax@10
  LPARAM v6; // ST0C_4@10
  HWND v7; // ST00_4@10
  HWND v8; // edi@11
  WCHAR String; // [sp+10h] [bp-414h]@10
  __int16 Dst; // [sp+218h] [bp-20Ch]@7

  v3 = (unsigned int)a2 >> 16;
  if ( (unsigned int)a2 >> 16 == 256 )
  {
    if ( !(*(_BYTE *)(dwStyle + 88) & 0x10) )
    {
      SendMessageW(*(HWND *)(dwStyle + 40), 0xB1u, 0, 0);
      SendMessageW(*(HWND *)(dwStyle + 40), 0xB1u, 0, -1);
      CCSendNotify(dwStyle, -804, 0);
      *(_DWORD *)(dwStyle + 88) &= 0xFFFFFFFD;
    }
  }
  else if ( v3 == 512 )
  {
    v8 = GetFocus();
    if ( v8 != *(HWND *)(dwStyle + 36) )
    {
      ComboEx_EndEdit(dwStyle, 1);
      SendMessageW(*(HWND *)(dwStyle + 36), 8u, (WPARAM)v8, 0);
    }
  }
  else if ( v3 == 768 )
  {
    if ( SendMessageW(*(HWND *)(dwStyle + 36), 0x147u, 0, 0) == -1 )
    {
      if ( *(_BYTE *)(dwStyle + 88) & 1 && (v4 = *(const WCHAR **)(dwStyle + 64)) != 0 )
        Str_GetPtrW(v4, &Dst, 260);
      else
        Dst = 0;
    }
    else
    {
      ComboEx_GetCurSelText(dwStyle, (int)&Dst, 260);
    }
    GetWindowTextW(*(HWND *)(dwStyle + 40), &String, 260);
    v5 = ComboEx_StrCmp(dwStyle, (LPCWSTR)&Dst, &String);
    v6 = *(_DWORD *)dwStyle;
    v7 = *(HWND *)(dwStyle + 4);
    *(_DWORD *)(dwStyle + 88) ^= (*(_DWORD *)(dwStyle + 88) ^ 2 * (v5 != 0)) & 2;
    SendMessageW(v7, 0x111u, (unsigned __int16)a2 | 0x50000, v6);
  }
  return a3 == *(_DWORD *)(dwStyle + 40);
}

//----- (6F7A4200) --------------------------------------------------------
LRESULT __stdcall EditSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  HWND v6; // esi@10
  HWND v7; // eax@14
  LRESULT v8; // edi@15
  DWORD v10; // esi@26
  LPARAM v11; // eax@28
  HWND v12; // eax@39
  COLORREF v13; // eax@41

  if ( uMsg != 48 && uMsg != 26 )
  {
    if ( uMsg == 2 )
    {
      RemoveWindowSubclass(hWnd, EditSubclassProc, 0);
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( uMsg == 5 )
    {
      if ( GetFocus() != hWnd )
        SendMessageW(*(HWND *)(dwRefData + 40), 0xB1u, 0, 0);
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( uMsg == 20 )
    {
      v13 = GetSysColor(5);
      EraseWindow(hWnd, (HDC)wParam, v13);
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( uMsg != 256 )
    {
      switch ( uMsg )
      {
        case 0x102u:
          if ( (unsigned __int16)wParam == 10 || (unsigned __int16)wParam == 13 )
            return 0;
          break;
        case 0x104u:
          if ( wParam == 38 || wParam == 40 )
          {
            v7 = *(HWND *)(dwRefData + 36);
            if ( v7 )
            {
              v8 = SendMessageW(v7, 0x104u, wParam, lParam);
              CCNotifyNavigationKeyUsage(dwRefData, 1u);
              return v8;
            }
          }
          break;
        case 0x201u:
          v6 = *(HWND *)(dwRefData + 40);
          if ( GetFocus() != v6 )
          {
            SetFocus(v6);
            return 0;
          }
          break;
      }
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( wParam <= 0x24 )
    {
      if ( wParam >= 0x23 )
      {
        if ( *(_BYTE *)(dwRefData + 88) & 0x10 )
          goto LABEL_39;
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      if ( wParam == 13 )
      {
        v10 = dwRefData;
        if ( ComboEx_EndEdit(dwRefData, 2) )
          return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      else
      {
        if ( wParam != 27 )
        {
          if ( wParam > 0x20 && wParam <= 0x22 )
            goto LABEL_39;
          return DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }
        v10 = dwRefData;
        *(_DWORD *)(v10 + 88) &= 0xFFFFFFFD;
        if ( ComboEx_EndEdit(dwRefData, 3) )
          return DefSubclassProc(hWnd, uMsg, wParam, lParam);
        if ( *(_BYTE *)(dwRefData + 88) & 1 )
        {
          v11 = *(_DWORD *)(dwRefData + 64);
          if ( v11 )
          {
            SendMessageW(*(HWND *)(dwRefData + 40), 0xCu, 0, v11);
            SendMessageW(*(HWND *)(dwRefData + 40), 0xB1u, 0, 0);
            SendMessageW(*(HWND *)(dwRefData + 40), 0xB1u, 0, -1);
          }
          RedrawWindow(*(HWND *)(dwRefData + 36), 0, 0, 5u);
          return DefSubclassProc(hWnd, uMsg, wParam, lParam);
        }
      }
      if ( ComboEx_GetEditBox(v10) )
        SetFocus(*(HWND *)(v10 + 40));
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( wParam == 38 || wParam == 40 || wParam == 115 )
    {
LABEL_39:
      v12 = *(HWND *)(dwRefData + 36);
      if ( v12 )
        return SendMessageW(v12, 0x100u, wParam, lParam);
    }
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

//----- (6F7A442F) --------------------------------------------------------
int __stdcall ComboEx_GetLBText(int a1, int a2, int a3, STRSAFE_LPWSTR pszDest)
{
  int v4; // ebx@1
  int v6; // [sp+Ch] [bp-230h]@1
  int v7; // [sp+10h] [bp-22Ch]@1
  WCHAR *v8; // [sp+14h] [bp-228h]@1
  int v9; // [sp+18h] [bp-224h]@1
  WCHAR String; // [sp+30h] [bp-20Ch]@1
  char Dst; // [sp+32h] [bp-20Ah]@1

  String = 0;
  v4 = -1;
  memset(&Dst, 0, 0x206u);
  v8 = &String;
  v7 = a3;
  v6 = 1;
  v9 = 260;
  if ( ComboEx_OnGetItem(a1, (int)&v6) )
  {
    v4 = lstrlenW(&String);
    if ( pszDest )
    {
      if ( a2 == 328 )
        StringCchCopyW(pszDest, v4 + 1, &String);
    }
  }
  return v4;
}

//----- (6F7A44ED) --------------------------------------------------------
int __stdcall ComboEx_OnSetImageList(LPARAM lParam, int a2)
{
  int v2; // esi@1
  int v4; // [sp+Ch] [bp-4h]@1
  int lParama; // [sp+18h] [bp+8h]@1

  v2 = lParam;
  v4 = *(_DWORD *)(lParam + 48);
  *(_DWORD *)(lParam + 48) = a2;
  lParama = ComboEx_ComputeItemHeight(lParam, 0);
  SendMessageW(*(HWND *)v2, 0x153u, 0xFFFFFFFF, lParama);
  SendMessageW(*(HWND *)(v2 + 36), 0x153u, 0, lParama);
  InvalidateRect(*(HWND *)(v2 + 36), 0, 1);
  if ( *(_DWORD *)(v2 + 40) )
    ComboEx_SizeEditBox(v2);
  return v4;
}

//----- (6F7A4556) --------------------------------------------------------
LONG __stdcall ComboEx_OnWindowPosChanging(int a1, int a2)
{
  HWND v2; // eax@2
  LONG result; // eax@2
  int v4; // ebx@4
  int v5; // eax@9
  struct tagRECT rc; // [sp+8h] [bp-40h]@2
  struct tagRECT v7; // [sp+18h] [bp-30h]@6
  struct tagRECT v8; // [sp+28h] [bp-20h]@3
  struct tagRECT Rect; // [sp+38h] [bp-10h]@1

  GetWindowRect(*(HWND *)a1, &Rect);
  if ( !a2
    || (SetRect(
          &rc,
          *(_DWORD *)(a2 + 8),
          *(_DWORD *)(a2 + 12),
          *(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 16),
          *(_DWORD *)(a2 + 12) + *(_DWORD *)(a2 + 20)),
        v2 = GetParent(*(HWND *)a1),
        MapWindowPoints(v2, 0, (LPPOINT)&rc, 2u),
        (result = EqualRect(&rc, &Rect)) == 0) )
  {
    GetClientRect(*(HWND *)a1, &v8);
    if ( a2 )
      v4 = Rect.right + v8.left + *(_DWORD *)(a2 + 16) - v8.right - Rect.left;
    else
      v4 = v8.right - v8.left;
    GetWindowRect(*(HWND *)(a1 + 36), &v7);
    if ( v4 )
    {
      if ( a2 && (*(_DWORD *)(a1 + 8) & 3) == 1 )
        v5 = *(_DWORD *)(a2 + 20);
      else
        v5 = v7.bottom - v7.top;
      SetWindowPos(*(HWND *)(a1 + 36), 0, 0, 0, v4, v5, (*(_DWORD *)(a1 + 40) != 0 ? 8 : 0) | 0x10);
    }
    GetWindowRect(*(HWND *)(a1 + 36), &v7);
    result = v7.bottom + Rect.bottom + v8.top - v8.bottom - Rect.top - v7.top;
    if ( a2 )
    {
      if ( result < *(_DWORD *)(a2 + 20) || !(*(_BYTE *)(a1 + 44) & 8) )
        *(_DWORD *)(a2 + 20) = result;
    }
    else if ( result < Rect.bottom - Rect.top || !(*(_BYTE *)(a1 + 44) & 8) )
    {
      result = SetWindowPos(
                 *(HWND *)a1,
                 0,
                 0,
                 0,
                 Rect.right - Rect.left,
                 v7.bottom + Rect.bottom + v8.top - v8.bottom - Rect.top - v7.top,
                 0x16u);
    }
    if ( *(_DWORD *)(a1 + 40) )
    {
      ComboEx_SizeEditBox(a1);
      result = InvalidateRect(*(HWND *)(a1 + 36), 0, 1);
    }
  }
  return result;
}

//----- (6F7A46AC) --------------------------------------------------------
int __stdcall ComboEx_OnSetExStyle(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // ebx@4
  char v5; // bl@4
  int v7; // [sp+14h] [bp+10h]@4

  if ( a3 )
    v3 = a3 & a2 | ~a3 & *(_DWORD *)(a1 + 44);
  else
    v3 = a2;
  v4 = *(_DWORD *)(a1 + 44);
  v7 = v4;
  v5 = v3 ^ v4;
  *(_DWORD *)(a1 + 44) = v3;
  if ( v5 & 3 )
  {
    InvalidateRect(*(HWND *)a1, 0, 1);
    if ( *(_DWORD *)(a1 + 40) )
    {
      ComboEx_SizeEditBox(a1);
      InvalidateRect(*(HWND *)(a1 + 40), 0, 1);
    }
  }
  if ( v5 & 4 )
    SetPathWordBreakProc(*(HWND *)(a1 + 40), *(_DWORD *)(a1 + 44) & 4);
  return v7;
}

//----- (6F7A472A) --------------------------------------------------------
int __stdcall ComboEx_GetEditBox(DWORD dwStyle)
{
  DWORD v1; // esi@1
  int result; // eax@1
  int v3; // eax@2
  HINSTANCE v4; // ST28_4@7
  int v5; // edi@7
  int v6; // eax@7
  HWND v7; // eax@7
  LRESULT v8; // eax@9
  signed int dwStylea; // [sp+10h] [bp+8h]@3

  v1 = dwStyle;
  result = *(_DWORD *)(dwStyle + 40);
  if ( !result )
  {
    v3 = *(_DWORD *)(dwStyle + 8);
    if ( (*(_DWORD *)(dwStyle + 8) & 3) != 2 )
      goto LABEL_15;
    dwStylea = 1409286144;
    if ( v3 & 0x40 )
      dwStylea = 1409286272;
    if ( (char)v3 < 0 )
      dwStylea |= 0x400u;
    v4 = g_hinst;
    v5 = *(_DWORD *)(v1 + 24) & 0x7000;
    v6 = GetDlgCtrlID(*(HWND *)v1);
    v7 = CreateWindowExW(v5, L"EDIT", &c_szNULL, dwStylea, 0, 0, 0, 0, *(HWND *)(v1 + 36), (HMENU)v6, v4, 0);
    *(_DWORD *)(v1 + 40) = v7;
    if ( v7 && SetWindowSubclass(v7, EditSubclassProc, 0, v1) )
    {
      v8 = ComboEx_GetFont(v1);
      if ( v8 )
        SendMessageW(*(HWND *)(v1 + 40), 0x30u, v8, 0);
      result = *(_DWORD *)(v1 + 40);
    }
    else
    {
LABEL_15:
      result = 0;
    }
  }
  return result;
}

//----- (6F7A47E6) --------------------------------------------------------
int __stdcall ComboEx_BeginEdit(DWORD dwStyle)
{
  int result; // eax@1

  result = ComboEx_GetEditBox(dwStyle);
  if ( result )
  {
    SetFocus(*(HWND *)(dwStyle + 40));
    result = 1;
  }
  return result;
}

//----- (6F7A480F) --------------------------------------------------------
int __stdcall ComboSubclass_HandleButton(DWORD dwStyle, int a2, int a3)
{
  HWND v3; // edi@2
  struct tagRECT rc; // [sp+Ch] [bp-230h]@1
  unsigned int v6; // [sp+1Ch] [bp-220h]@1
  LPARAM lParam; // [sp+20h] [bp-21Ch]@3
  int v8; // [sp+2Ch] [bp-210h]@3
  WCHAR String; // [sp+30h] [bp-20Ch]@3

  v6 = (unsigned int)a3 >> 16;
  ComboEx_GetComboClientRect(dwStyle, &rc);
  InflateRect(&rc, g_cxEdge, g_cyEdge);
  if ( PtInRect(&rc, (POINT)__PAIR__(SHIWORD(a3), (signed __int16)a3)) )
  {
    v3 = *(HWND *)(dwStyle + 36);
    if ( CheckForDragBegin(*(HWND *)(dwStyle + 36), (unsigned __int16)a3, (unsigned __int16)v6) )
    {
      v8 = -1;
      GetWindowTextW(*(HWND *)(dwStyle + 40), &String, 260);
      CCSendNotify(dwStyle, -809, (LPARAM)&lParam);
      return 1;
    }
    if ( IsWindow(v3) && (*(_DWORD *)(dwStyle + 8) & 3) == 2 )
    {
      if ( !ComboEx_BeginEdit(dwStyle) )
        SetFocus(*(HWND *)(dwStyle + 36));
      return 1;
    }
  }
  return 0;
}

//----- (6F7A4904) --------------------------------------------------------
int __stdcall ComboSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  int v6; // eax@7
  COLORREF v7; // eax@8
  LPARAM v9; // [sp+8h] [bp-20h]@7
  char v10; // [sp+Ch] [bp-1Ch]@7
  LPARAM v11; // [sp+24h] [bp-4h]@7

  if ( uMsg <= 0x111 )
  {
    if ( uMsg == 273 )
    {
      v6 = ComboSubclass_HandleCommand(dwRefData, wParam, lParam);
    }
    else
    {
      if ( uMsg == 2 )
      {
        RemoveWindowSubclass(hWnd, ComboSubclassProc, 0);
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      if ( uMsg == 20 )
      {
        v7 = GetSysColor(5);
        EraseWindow(hWnd, (HDC)wParam, v7);
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      }
      if ( uMsg != 32 || !dwRefData )
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
      v9 = 0;
      memset(&v10, 0, 0x1Cu);
      v11 = lParam;
      v6 = (int)CCSendNotify(dwRefData, -17, (LPARAM)&v9);
    }
LABEL_18:
    if ( v6 )
      return 0;
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  if ( uMsg < 0x148 )
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
  if ( uMsg > 0x149 )
  {
    if ( uMsg != 513 && uMsg != 516 )
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    v6 = ComboSubclass_HandleButton(dwRefData, wParam, lParam);
    goto LABEL_18;
  }
  return ComboEx_GetLBText(dwRefData, uMsg, wParam, (STRSAFE_LPWSTR)lParam);
}

//----- (6F7A49E2) --------------------------------------------------------
int __stdcall ComboEx_HandleCommand(DWORD dwStyle, int a2, int a3)
{
  unsigned int v3; // ebx@1
  int result; // eax@2
  int v5; // [sp+18h] [bp+Ch]@5

  v3 = (unsigned int)a2 >> 16;
  if ( dwStyle )
  {
    if ( v3 == 1 )
      ComboEx_UpdateEditText(dwStyle, 0);
    v5 = SendMessageW(*(HWND *)(dwStyle + 4), 0x111u, (unsigned __int16)a2 | (HIWORD(a2) << 16), *(_DWORD *)dwStyle);
    switch ( v3 )
    {
      case 3u:
        ComboEx_BeginEdit(dwStyle);
        break;
      case 4u:
        ComboEx_EndEdit(dwStyle, 1);
        break;
      case 7u:
        *(_DWORD *)(dwStyle + 60) = SendMessageW(*(HWND *)(dwStyle + 36), 0x147u, 0, 0);
        ComboEx_EndEdit(dwStyle, 4);
        if ( GetFocus() == *(HWND *)(dwStyle + 40) )
          SetFocus(*(HWND *)(dwStyle + 36));
        *(_DWORD *)(dwStyle + 88) |= 0x10u;
        break;
      case 8u:
        *(_DWORD *)(dwStyle + 60) = -1;
        ComboEx_BeginEdit(dwStyle);
        *(_DWORD *)(dwStyle + 88) &= 0xFFFFFFEF;
        break;
    }
    result = v5;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A4AA5) --------------------------------------------------------
HLOCAL __stdcall ComboEx_OnDestroy(HLOCAL hMem)
{
  LRESULT v1; // eax@4
  HWND v2; // eax@5
  HWND v3; // eax@7

  SendMessageW(*((HWND *)hMem + 9), 0x14Bu, 0, 0);
  if ( *((_DWORD *)hMem + 16) )
    Str_Set((int)((char *)hMem + 64), 0);
  if ( *((_BYTE *)hMem + 88) & 4 )
  {
    v1 = ComboEx_GetFont((int)hMem);
    DeleteObject((HGDIOBJ)v1);
  }
  v2 = (HWND)*((_DWORD *)hMem + 10);
  if ( v2 )
    RemoveWindowSubclass(v2, EditSubclassProc, 0);
  v3 = (HWND)*((_DWORD *)hMem + 9);
  if ( v3 )
    RemoveWindowSubclass(v3, (SUBCLASSPROC)ComboSubclassProc, 0);
  SetWindowLongW(*(HWND *)hMem, 0, 0);
  return LocalFree(hMem);
}

//----- (6F7A4B24) --------------------------------------------------------
LONG __stdcall ComboEx_OnCreate(HWND hWnd, int a2)
{
  LONG result; // eax@1
  int v3; // ebx@1
  int v4; // eax@2
  HWND v5; // eax@4

  result = (LONG)LocalAlloc(0x40u, 0x5Cu);
  v3 = result;
  if ( result )
  {
    SetWindowLongW(hWnd, 0, result);
    *(_DWORD *)(a2 + 32) &= 0xFF4F9FFF;
    SetWindowLongW(hWnd, -16, *(_DWORD *)(a2 + 32));
    CIInitialize(v3, (WPARAM)hWnd, a2);
    v4 = *(_DWORD *)(a2 + 32) & 0x40000202 | 0x16200411;
    if ( (*(_DWORD *)(a2 + 32) & 3) == 1 )
      v4 |= *(_DWORD *)(a2 + 32) & 0x60C0;
    v5 = CreateWindowExW(
           *(_DWORD *)(a2 + 44) & 0x7000,
           L"combobox",
           *(LPCWSTR *)(a2 + 36),
           v4,
           0,
           0,
           *(_DWORD *)(a2 + 20),
           *(_DWORD *)(a2 + 16),
           hWnd,
           *(HMENU *)(a2 + 8),
           *(HINSTANCE *)(a2 + 4),
           0);
    *(_DWORD *)(v3 + 36) = v5;
    if ( v5
      && SetWindowSubclass(v5, (SUBCLASSPROC)ComboSubclassProc, 0, v3)
      && (ComboEx_GetEditBox(v3) || (*(_BYTE *)(v3 + 8) & 3) != 2) )
    {
      ComboEx_OnSetFont(v3, 0, 0);
      *(_DWORD *)(v3 + 60) = -1;
      *(_DWORD *)(v3 + 56) = 10;
      ComboEx_OnWindowPosChanging(v3, 0);
      result = 1;
    }
    else
    {
      ComboEx_OnDestroy((HLOCAL)v3);
      result = 0;
    }
  }
  return result;
}

//----- (6F7A4C2D) --------------------------------------------------------
int __stdcall ComboExWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG v4; // esi@1
  HWND v5; // eax@16
  int result; // eax@18
  HWND v7; // esi@19
  HWND v8; // eax@21
  HWND v9; // esi@23
  HWND v10; // esi@25
  HWND v11; // eax@63
  LONG v12; // edi@76
  int v13; // ebx@89
  const CHAR *v14; // eax@89
  int v15; // eax@91
  int v16; // edi@91
  WCHAR *v17; // eax@91
  signed int v18; // esi@92
  HWND v19; // esi@95
  int v20; // edi@104
  bool v21; // zf@104
  const CHAR *v22; // eax@104
  int v23; // eax@106
  int v24; // ebx@106
  WCHAR *v25; // eax@106
  struct tagRECT v26; // [sp+Ch] [bp-24h]@76
  struct tagRECT Rect; // [sp+1Ch] [bp-14h]@76
  LRESULT v28; // [sp+2Ch] [bp-4h]@1
  WPARAM wParama; // [sp+40h] [bp+10h]@91
  WPARAM wParamb; // [sp+40h] [bp+10h]@106
  LPARAM lParama; // [sp+44h] [bp+14h]@89
  LPARAM lParamb; // [sp+44h] [bp+14h]@104

  v28 = 0;
  v4 = GetWindowLongW(hWnd, 0);
  if ( !v4 && Msg != 129 && Msg != 1 )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  if ( Msg <= 0x14A )
  {
    if ( Msg == 330 )
      return v28;
    if ( Msg <= 0x31 )
    {
      if ( Msg == 49 )
        return ComboEx_GetFont(v4);
      if ( Msg <= 0xE )
      {
        if ( Msg < 0xD )
        {
          if ( Msg == 1 )
          {
            CCCreateWindow();
            if ( !ComboEx_OnCreate(hWnd, lParam) )
              v28 = -1;
            return v28;
          }
          if ( Msg == 2 )
          {
            CCDestroyWindow();
            ComboEx_OnDestroy((HLOCAL)v4);
            return v28;
          }
          if ( Msg == 7 )
          {
            v10 = *(HWND *)(v4 + 36);
            if ( v10 )
              SetFocus(v10);
            return v28;
          }
          if ( Msg == 10 )
          {
            v8 = *(HWND *)(v4 + 36);
            if ( v8 )
              EnableWindow(v8, wParam);
            v9 = *(HWND *)(v4 + 40);
            if ( v9 )
              EnableWindow(v9, wParam);
            return v28;
          }
          if ( Msg == 11 )
          {
            v7 = *(HWND *)(v4 + 40);
            if ( v7 )
              SendMessageW(v7, 0xBu, wParam, lParam);
            return v28;
          }
          if ( Msg == 12 )
          {
            v5 = *(HWND *)(v4 + 40);
            if ( v5 )
            {
              v28 = SendMessageW(v5, 0xCu, wParam, lParam);
              SendMessageW(*(HWND *)(v4 + 40), 0xB1u, 0, 0);
              SendMessageW(*(HWND *)(v4 + 40), 0xB1u, 0, -1);
              RedrawWindow(*(HWND *)(v4 + 36), 0, 0, 5u);
              return v28;
            }
            return -1;
          }
          goto LABEL_121;
        }
LABEL_95:
        v19 = *(HWND *)(v4 + 40);
        if ( v19 )
          return SendMessageW(v19, Msg, wParam, lParam);
        return 0;
      }
      if ( Msg == 21 )
      {
        InitGlobalColors();
        return v28;
      }
      if ( Msg == 26 )
      {
        InitGlobalMetrics(wParam);
        if ( v4 && *(_BYTE *)(v4 + 88) & 4 && (!wParam && !lParam || wParam == 34 || wParam == 42) )
          ComboEx_OnSetFont(v4, 0, 1);
        return v28;
      }
      if ( Msg == 43 )
      {
        ComboEx_OnDrawItem(v4, lParam);
        return v28;
      }
      if ( Msg == 44 )
      {
        ComboEx_OnMeasureItem(v4, lParam);
        return v28;
      }
      if ( Msg == 45 )
      {
        ComboEx_HandleDeleteItem(v4, lParam);
        return 1;
      }
      if ( Msg == 48 )
      {
        ComboEx_OnSetFont(v4, wParam, lParam);
        return 0;
      }
LABEL_121:
      if ( CCWndProc(v4, Msg, wParam, lParam, (int)&v28) )
        return v28;
      return DefWindowProcW(hWnd, Msg, wParam, lParam);
    }
    if ( Msg > 0x140 )
    {
      switch ( Msg )
      {
        case 0x142u:
        case 0x143u:
        case 0x145u:
          return v28;
        case 0x141u:
          if ( ComboEx_GetEditBox(v4) )
            SendMessageW(*(HWND *)(v4 + 40), 0xC5u, wParam, 0);
          return v28;
        case 0x148u:
        case 0x149u:
          return ComboEx_GetLBText(v4, Msg, wParam, (STRSAFE_LPWSTR)lParam);
        case 0x144u:
          goto LABEL_77;
        case 0x146u:
        case 0x147u:
          return SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
        default:
          goto LABEL_121;
      }
      goto LABEL_121;
    }
    if ( Msg == 320 )
    {
      v11 = *(HWND *)(v4 + 40);
      if ( v11 )
        return SendMessageW(v11, 0xB0u, wParam, lParam);
    }
    else
    {
      if ( Msg == 70 )
      {
        ComboEx_OnWindowPosChanging(v4, lParam);
        return v28;
      }
      if ( Msg == 85 )
        return CIHandleNotifyFormat(v4, lParam);
      if ( Msg == 129 )
      {
        SetWindowBits(hWnd, -16, 11534336, 0);
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      }
      if ( Msg != 135 )
      {
        if ( Msg == 273 )
          return ComboEx_HandleCommand(v4, wParam, lParam);
        if ( Msg != 296 )
          goto LABEL_121;
        CCOnUIState(v4, 296, wParam, lParam);
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      }
    }
    return SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
  }
  if ( Msg <= 0x158 )
  {
    if ( Msg == 344 )
      return ComboEx_OnFindStringExact(v4, wParam, (const WCHAR *)lParam);
    switch ( Msg )
    {
      case 0x14Cu:
        return v28;
      case 0x150u:
        return ComboEx_OnGetItemData(v4, wParam);
      case 0x151u:
        return ComboEx_OnSetItemData(v4, wParam, lParam);
      case 0x153u:
        v28 = SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
        if ( wParam == -1 )
        {
          GetWindowRect(*(HWND *)(v4 + 36), &Rect);
          v12 = Rect.bottom - Rect.top;
          GetWindowRect(*(HWND *)v4, &Rect);
          GetClientRect(*(HWND *)v4, &v26);
          SetWindowPos(
            *(HWND *)v4,
            0,
            0,
            0,
            Rect.right - Rect.left,
            v12 + Rect.bottom + v26.top - v26.bottom - Rect.top,
            0x16u);
        }
        return v28;
      case 0x14Bu:
      case 0x14Eu:
LABEL_77:
        v28 = SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
        ComboEx_UpdateEditText(v4, Msg == 334);
        return v28;
      case 0x14Du:
      case 0x14Fu:
      case 0x152u:
      case 0x154u:
      case 0x155u:
      case 0x156u:
      case 0x157u:
        return SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
      default:
        goto LABEL_121;
    }
    goto LABEL_121;
  }
  if ( Msg > 0x407 )
  {
    if ( Msg == 1032 )
      return ComboEx_OnSetExStyle(v4, wParam, 0);
    if ( Msg == 1033 )
      return *(_DWORD *)(v4 + 44);
    if ( Msg == 1034 )
      return *(_DWORD *)(v4 + 88) << 30 >> 31;
    if ( Msg == 1035 )
      return ComboEx_OnInsertItem(v4, lParam);
    if ( Msg != 1036 )
    {
      if ( Msg == 1037 )
        return ComboEx_OnGetItem(v4, lParam);
      if ( Msg == 1038 )
        return ComboEx_OnSetExStyle(v4, lParam, wParam);
      goto LABEL_121;
    }
    result = ComboEx_OnSetItem(v4, lParam);
  }
  else
  {
    if ( Msg == 1031 )
      return *(_DWORD *)(v4 + 40);
    if ( Msg <= 0x403 )
    {
      if ( Msg == 1027 )
        return *(_DWORD *)(v4 + 48);
      if ( Msg == 352 )
        return SendMessageW(*(HWND *)(v4 + 36), Msg, wParam, lParam);
      if ( Msg <= 0x2FF )
        goto LABEL_121;
      if ( Msg <= 0x302 )
        goto LABEL_95;
      if ( Msg != 1025 )
      {
        if ( Msg == 1026 )
          return ComboEx_OnSetImageList(v4, lParam);
        goto LABEL_121;
      }
      v13 = lParam;
      v14 = *(const CHAR **)(lParam + 8);
      lParama = (LPARAM)v14;
      if ( !v14 || v14 == (const CHAR *)-1 )
        return ComboEx_OnInsertItem(v4, v13);
      v15 = lstrlenA(v14);
      v16 = v15 + 1;
      v17 = (WCHAR *)LocalAlloc(0x40u, 2 * (v15 + 1));
      wParama = (WPARAM)v17;
      if ( v17 )
      {
        MultiByteToWideChar(0, 0, (LPCSTR)lParama, v16, v17, v16);
        *(_DWORD *)(v13 + 8) = wParama;
        v18 = ComboEx_OnInsertItem(v4, v13);
        *(_DWORD *)(v13 + 8) = lParama;
        LocalFree((HLOCAL)wParama);
        return v18;
      }
      return -1;
    }
    if ( Msg == 1028 )
      return ComboEx_OnGetItemA(v4, lParam);
    if ( Msg != 1029 )
    {
      if ( Msg == 1030 )
        return *(_DWORD *)(v4 + 36);
      goto LABEL_121;
    }
    v20 = lParam;
    v21 = (*(_BYTE *)lParam & 1) == 0;
    v22 = *(const CHAR **)(lParam + 8);
    lParamb = *(_DWORD *)(lParam + 8);
    if ( !v21 && v22 != (const CHAR *)-1 )
    {
      v23 = lstrlenA(v22);
      v24 = v23 + 1;
      v25 = (WCHAR *)LocalAlloc(0x40u, 2 * (v23 + 1));
      wParamb = (WPARAM)v25;
      if ( v25 )
      {
        MultiByteToWideChar(0, 0, (LPCSTR)lParamb, v24, v25, v24);
        *(_DWORD *)(v20 + 8) = wParamb;
        v18 = ComboEx_OnSetItem(v4, v20);
        *(_DWORD *)(v20 + 8) = lParamb;
        LocalFree((HLOCAL)wParamb);
        return v18;
      }
      return -1;
    }
    result = ComboEx_OnSetItem(v4, v20);
  }
  return result;
}

//----- (6F7A52B0) --------------------------------------------------------
BOOL __stdcall TME_PostMouseLeave(HWND hWnd)
{
  return PostMessageW(hWnd, 0x2A3u, 0, 0);
}

//----- (6F7A52D0) --------------------------------------------------------
int __stdcall TME_CancelMouseLeave(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 4);
  if ( result & 2 )
  {
    result &= 0xFFFFFFFD;
    *(_DWORD *)(a1 + 4) = result;
  }
  return result;
}

//----- (6F7A52EE) --------------------------------------------------------
BOOL __stdcall TME_CancelMouseHover(int a1)
{
  BOOL result; // eax@1
  HWND v2; // ST00_4@2

  result = *(_DWORD *)(a1 + 4);
  if ( result )
  {
    v2 = *(HWND *)(a1 + 8);
    *(_DWORD *)(a1 + 4) = result & 0xFFFFFFFE;
    result = KillTimer(v2, 0xFFFFFFF0);
  }
  return result;
}

//----- (6F7A5317) --------------------------------------------------------
HLOCAL __stdcall TME_CancelTracking(HLOCAL hMem)
{
  HWND v1; // edi@2
  HLOCAL result; // eax@2

  if ( !(*((_BYTE *)hMem + 4) & 3) )
  {
    v1 = (HWND)*((_DWORD *)hMem + 2);
    RemoveWindowSubclass(*((HWND *)hMem + 2), TME_SubclassProc, 0);
    KillTimer(v1, 0xFFFFFFF1);
    result = LocalFree(hMem);
  }
  return result;
}

//----- (6F7A5352) --------------------------------------------------------
HLOCAL __stdcall TME_RemoveAllTracking(int a1)
{
  TME_CancelMouseLeave(a1);
  TME_CancelMouseHover(a1);
  return TME_CancelTracking((HLOCAL)a1);
}

//----- (6F7A536F) --------------------------------------------------------
HLOCAL __stdcall TME_MouseHasLeft(int a1)
{
  if ( *(_BYTE *)(a1 + 4) & 2 )
    TME_PostMouseLeave(*(HWND *)(a1 + 8));
  return TME_RemoveAllTracking(a1);
}

//----- (6F7A5396) --------------------------------------------------------
LRESULT __stdcall TME_SubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  struct tagPOINT Point; // [sp+4h] [bp-8h]@15

  if ( uMsg > 0xA8 )
  {
    switch ( uMsg )
    {
      case 0x201u:
      case 0x202u:
      case 0x204u:
      case 0x205u:
      case 0x207u:
      case 0x208u:
        goto LABEL_10;
      case 0x211u:
        goto LABEL_14;
      case 0x200u:
        Point.x = (signed __int16)lParam;
        Point.y = SHIWORD(lParam);
        ClientToScreen(hWnd, &Point);
        if ( *(_BYTE *)(dwRefData + 4) & 1 && !PtInRect((const RECT *)(dwRefData + 16), Point) )
          TME_ResetMouseHover(dwRefData, dwRefData);
        break;
      default:
        return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
  }
  else
  {
    if ( uMsg >= 0xA7 )
      goto LABEL_10;
    if ( uMsg == 2 || uMsg == 130 )
    {
      TME_RemoveAllTracking(dwRefData);
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( uMsg == 160 )
    {
LABEL_14:
      TME_MouseHasLeft(dwRefData);
      return DefSubclassProc(hWnd, uMsg, wParam, lParam);
    }
    if ( uMsg > 0xA0 && (uMsg <= 0xA2 || uMsg > 0xA3 && uMsg <= 0xA5) )
    {
LABEL_10:
      if ( *(_BYTE *)(dwRefData + 4) & 1 )
        TME_ResetMouseHover(dwRefData, dwRefData);
    }
  }
  return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

//----- (6F7A54AB) --------------------------------------------------------
signed int __stdcall TME_CheckInWindow(int a1, int a2)
{
  HWND v2; // edi@1
  HWND v3; // eax@1
  HWND v4; // esi@1
  signed int result; // eax@4
  HWND v6; // eax@6
  HWND v7; // esi@6
  struct tagPOINT Point; // [sp+Ch] [bp-8h]@5

  v2 = *(HWND *)(a1 + 8);
  v3 = GetCapture();
  v4 = v3;
  if ( (!v3 || !IsWindow(v3) || v4 == v2)
    && ((GetCursorPos(&Point), v4)
     || (v6 = WindowFromPoint(Point), (v7 = v6) != 0)
     && IsWindow(v6)
     && v2 == v7
     && SendMessageW(v2, 0x84u, 0, (unsigned __int16)Point.x | (LOWORD(Point.y) << 16)) == 1) )
  {
    if ( a2 )
      *(_QWORD *)a2 = Point;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A5549) --------------------------------------------------------
signed int __stdcall GetMouseKeyFlags()
{
  signed int v0; // ebx@1

  v0 = 0;
  if ( GetKeyState(1) & 0x8000 )
    v0 = 1;
  if ( GetKeyState(2) & 0x8000 )
    v0 |= 2u;
  if ( GetKeyState(4) & 0x8000 )
    v0 |= 0x10u;
  if ( GetKeyState(16) & 0x8000 )
    v0 |= 4u;
  if ( GetKeyState(17) & 0x8000 )
    v0 |= 8u;
  return v0;
}

//----- (6F7A55A8) --------------------------------------------------------
BOOL __stdcall TME_SubclassWnd(DWORD_PTR dwRefData)
{
  return SetWindowSubclass(*(HWND *)(dwRefData + 8), TME_SubclassProc, 0, dwRefData);
}

//----- (6F7A55C9) --------------------------------------------------------
HWND __stdcall GetTMEdata(HWND hWnd)
{
  GetWindowSubclass(hWnd, TME_SubclassProc, 0, (DWORD_PTR *)&hWnd);
  return hWnd;
}

//----- (6F7A55ED) --------------------------------------------------------
void __stdcall TME_MouseLeaveTimer(HWND hWnd, UINT a2, UINT a3, DWORD a4)
{
  int v4; // eax@1
  int v5; // esi@1

  v4 = (int)GetTMEdata(hWnd);
  v5 = v4;
  if ( v4 && !TME_CheckInWindow(v4, 0) )
  {
    if ( IsWindow(hWnd) )
      TME_MouseHasLeft(v5);
  }
}

//----- (6F7A562A) --------------------------------------------------------
void __stdcall TME_MouseHoverTimer(HWND hWnd, UINT a2, UINT a3, DWORD a4)
{
  int v4; // esi@1
  signed int v5; // ebx@7
  POINT pt; // [sp+8h] [bp-8h]@2

  v4 = (int)GetTMEdata(hWnd);
  if ( v4 )
  {
    if ( TME_CheckInWindow(v4, (int)&pt) )
    {
      if ( IsWindow(hWnd) )
      {
        if ( PtInRect((const RECT *)(v4 + 16), pt) )
        {
          v5 = GetMouseKeyFlags();
          ScreenToClient(hWnd, &pt);
          PostMessageW(hWnd, 0x2A1u, v5, (unsigned __int16)pt.x | (LOWORD(pt.y) << 16));
          TME_CancelMouseHover(v4);
          TME_CancelTracking((HLOCAL)v4);
        }
        else
        {
          TME_ResetMouseHover(v4, v4);
        }
      }
    }
    else
    {
      TME_MouseHasLeft(v4);
    }
  }
}

//----- (6F7A56C6) --------------------------------------------------------
UINT_PTR __stdcall TME_ResetMouseLeave(int a1, int a2)
{
  UINT_PTR result; // eax@1
  unsigned int v3; // eax@2

  result = *(_DWORD *)(a2 + 4);
  if ( !(result & 2) )
  {
    *(_DWORD *)(a2 + 4) = result | 2;
    v3 = GetDoubleClickTime();
    result = SetTimer(*(HWND *)(a1 + 8), 0xFFFFFFF1, v3 / 5, TME_MouseLeaveTimer);
  }
  return result;
}

//----- (6F7A5705) --------------------------------------------------------
UINT_PTR __stdcall TME_ResetMouseHover(int a1, int a2)
{
  int v2; // edi@1
  LONG v3; // eax@5
  LONG v4; // edx@5
  int v5; // ecx@5
  struct tagPOINT Point; // [sp+Ch] [bp-8h]@5

  *(_DWORD *)(a2 + 4) |= 1u;
  v2 = *(_DWORD *)(a1 + 12);
  if ( !v2 || v2 == -1 )
  {
    v2 = g_dwHoverSelectTimeout;
    if ( !g_dwHoverSelectTimeout )
      v2 = 4 * GetDoubleClickTime() / 5;
  }
  GetCursorPos(&Point);
  v3 = Point.x;
  v4 = Point.y;
  *(_DWORD *)(a2 + 24) = Point.x;
  v5 = a2 + 16;
  *(_DWORD *)v5 = v3;
  *(_DWORD *)(a2 + 28) = v4;
  *(_DWORD *)(v5 + 4) = v4;
  InflateRect((LPRECT)(a2 + 16), g_cxDoubleClk / 2, g_cyDoubleClk / 2);
  *(_DWORD *)(a1 + 12) = v2;
  *(_DWORD *)(a2 + 12) = v2;
  return SetTimer(*(HWND *)(a1 + 8), 0xFFFFFFF0, v2, TME_MouseHoverTimer);
}
// 6F7E6974: using guessed type int g_cyDoubleClk;
// 6F7E6978: using guessed type int g_cxDoubleClk;
// 6F7E6C0C: using guessed type int g_dwHoverSelectTimeout;

//----- (6F7A579F) --------------------------------------------------------
signed int __stdcall QueryTrackMouseEvent(int a1)
{
  HWND v1; // edi@1
  HWND v2; // eax@3

  v1 = *(HWND *)(a1 + 8);
  if ( !v1 || !IsWindow(*(HWND *)(a1 + 8)) || (v2 = GetTMEdata(v1)) == 0 || !(*((_BYTE *)v2 + 4) & 3) )
  {
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    goto LABEL_8;
  }
  *(_DWORD *)(a1 + 4) = *((_DWORD *)v2 + 1);
  if ( !(*((_BYTE *)v2 + 4) & 1) )
  {
LABEL_8:
    *(_DWORD *)(a1 + 12) = 0;
    return 1;
  }
  *(_DWORD *)(a1 + 12) = *((_DWORD *)v2 + 3);
  return 1;
}

//----- (6F7A57F9) --------------------------------------------------------
signed int __stdcall EmulateTrackMouseEvent(int a1)
{
  int v1; // ebx@1
  int v2; // eax@1
  HWND v4; // edi@6
  DWORD_PTR v5; // esi@12
  signed int v6; // edi@17
  int v7; // [sp+Ch] [bp+8h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 4);
  v7 = v2;
  if ( v2 & 0x3FFFFFEC || v2 & 0x10 )
    return 0;
  if ( v2 & 0x40000000 )
    return QueryTrackMouseEvent(v1);
  v4 = *(HWND *)(v1 + 8);
  if ( !IsWindow(*(HWND *)(v1 + 8)) )
    return 0;
  if ( !TME_CheckInWindow(v1, 0) )
  {
    if ( v7 & 2 )
    {
      if ( !(v7 & 0x80000000) )
        TME_PostMouseLeave(v4);
    }
    return 1;
  }
  if ( !IsWindow(v4) )
    return 0;
  v5 = (DWORD_PTR)GetTMEdata(v4);
  if ( v5 )
    goto LABEL_19;
  if ( !(v7 & 0x80000000) )
  {
    v5 = (DWORD_PTR)LocalAlloc(0x40u, 0x20u);
    if ( !v5 )
      return 0;
    *(_DWORD *)(v5 + 8) = *(_DWORD *)(v1 + 8);
    if ( !TME_SubclassWnd(v5) )
    {
      v6 = 0;
      goto LABEL_18;
    }
LABEL_19:
    if ( !(v7 & 0x80000000) )
    {
      if ( v7 & 1 )
        TME_ResetMouseHover(v1, v5);
      if ( v7 & 2 )
        TME_ResetMouseLeave(v1, v5);
      return 1;
    }
    if ( v7 & 1 )
      TME_CancelMouseHover(v5);
    if ( v7 & 2 )
      TME_CancelMouseLeave(v5);
    v6 = 1;
LABEL_18:
    TME_CancelTracking((HLOCAL)v5);
    return v6;
  }
  return 1;
}

//----- (6F7A5904) --------------------------------------------------------
BOOL __stdcall _TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
{
  HMODULE v1; // eax@2

  if ( !g_pfnTME )
  {
    v1 = GetModuleHandleW(L"USER32");
    if ( v1 )
      g_pfnTME = (int (__stdcall *)(_DWORD))GetProcAddress(v1, "TrackMouseEvent");
    if ( !g_pfnTME )
      g_pfnTME = EmulateTrackMouseEvent;
  }
  return g_pfnTME(lpEventTrack);
}
// 6F7E8AB0: using guessed type int (__stdcall *g_pfnTME)(_DWORD);

//----- (6F7A5961) --------------------------------------------------------
BOOL __stdcall ChrCmpIW(WORD w1, WORD w2)
{
  WCHAR String1; // [sp+0h] [bp-4h]@1
  __int16 v4; // [sp+2h] [bp-2h]@1

  String1 = w1;
  v4 = 0;
  w1 = w2;
  *(&w1 + 1) = 0;
  return lstrcmpiW(&String1, &w1);
}

//----- (6F7A599A) --------------------------------------------------------
int __stdcall StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
  int *v3; // eax@1
  unsigned int v4; // esi@1
  LPCWSTR *v5; // ecx@2

  v3 = (int *)lpStr1;
  v4 = (unsigned int)&lpStr1[nChar];
  if ( v4 > (unsigned int)lpStr1 )
  {
    v5 = (LPCWSTR *)lpStr2;
    while ( *(_WORD *)v3 || *(_WORD *)v5 )
    {
      if ( *(_WORD *)v3 != *(_WORD *)v5 )
      {
        nChar = *(_WORD *)v3;
        lpStr1 = (LPCWSTR)*(_WORD *)v5;
        return lstrcmpW((LPCWSTR)&nChar, (LPCWSTR)&lpStr1);
      }
      v3 = (int *)((char *)v3 + 2);
      v5 = (LPCWSTR *)((char *)v5 + 2);
      if ( v4 <= (unsigned int)v3 )
        return 0;
    }
  }
  return 0;
}

//----- (6F7A59FE) --------------------------------------------------------
int __stdcall StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
  LCID v3; // eax@1
  int v4; // eax@1

  v3 = GetThreadLocale();
  v4 = CompareStringW(v3, 0x10000001u, lpStr1, nChar, lpStr2, nChar);
  if ( !v4 )
    v4 = CompareStringW(0x800u, 0x10000001u, lpStr1, nChar, lpStr2, nChar);
  return v4 - 2;
}

//----- (6F7A5A49) --------------------------------------------------------
BOOL __stdcall IntlStrEqWorkerW(int a1, PCNZWCH lpString1, PCNZWCH lpString2, int cchCount1)
{
  LCID v4; // eax@1
  int v5; // eax@1
  LCID v6; // eax@2
  int v7; // eax@6

  v4 = GetThreadLocale();
  v5 = CompareStringW(v4, (a1 == 0) | 0x10000000, lpString1, cchCount1, lpString2, cchCount1);
  if ( !v5 )
  {
    v6 = GetSystemDefaultLCID();
    v5 = CompareStringW(v6, (a1 == 0) | 0x10000000, lpString1, cchCount1, lpString2, cchCount1);
    if ( !v5 )
    {
      if ( lpString1 && lpString2 )
      {
        if ( a1 )
          v7 = StrCmpNW(lpString1, lpString2, cchCount1);
        else
          v7 = StrCmpNIW(lpString1, lpString2, cchCount1);
        v5 = v7 + 2;
      }
      else
      {
        v5 = 2;
      }
    }
  }
  return v5 == 2;
}

//----- (6F7A5AD5) --------------------------------------------------------
LPCWSTR __stdcall ProduceAFromW(UINT CodePage, LPCWSTR lpWideCharStr)
{
  LPCWSTR result; // eax@1
  int v3; // ebx@3
  CHAR *v4; // eax@5
  HLOCAL hMem; // [sp+4h] [bp-4h]@5

  result = lpWideCharStr;
  if ( lpWideCharStr && lpWideCharStr != (LPCWSTR)-1 )
  {
    v3 = WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, 0, 0, 0, 0);
    if ( !v3 )
      v3 = 1;
    v4 = (CHAR *)LocalAlloc(0, v3);
    hMem = v4;
    if ( v4 )
    {
      if ( !WideCharToMultiByte(CodePage, 0, lpWideCharStr, -1, v4, v3, 0, 0) )
      {
        LocalFree(hMem);
        hMem = 0;
      }
    }
    result = (LPCWSTR)hMem;
  }
  return result;
}

//----- (6F7A5B45) --------------------------------------------------------
COLORREF __stdcall RB_GetTextColor(int a1)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a1 + 112);
  if ( result == -16777216 )
    result = g_clrBtnText;
  return result;
}

//----- (6F7A5B65) --------------------------------------------------------
COLORREF __stdcall RBB_GetTextColor_External(int a1, int a2)
{
  COLORREF result; // eax@2

  if ( *(_DWORD *)(a2 + 4) == -1 )
    result = -1;
  else
    result = RBB_GetTextColor(a1, a2);
  return result;
}

//----- (6F7A5B8A) --------------------------------------------------------
COLORREF __stdcall RBB_GetBkColor_External(int a1, int a2)
{
  COLORREF result; // eax@2

  if ( *(_DWORD *)(a2 + 8) == -1 )
    result = -1;
  else
    result = RBB_GetBkColor(a1, a2);
  return result;
}

//----- (6F7A5BAF) --------------------------------------------------------
int __stdcall TrueMapWindowPoints(HWND hWnd, HWND hWndFrom, int a3, int a4)
{
  LONG v4; // ecx@5
  LONG v5; // edx@5
  int v6; // eax@6
  struct tagRECT v8; // [sp+Ch] [bp-20h]@1
  struct tagRECT Rect; // [sp+1Ch] [bp-10h]@1

  Rect.left = 0;
  Rect.top = 0;
  Rect.right = 0;
  Rect.bottom = 0;
  v8.left = 0;
  v8.top = 0;
  v8.right = 0;
  v8.bottom = 0;
  if ( hWnd )
  {
    GetClientRect(hWnd, &Rect);
    MapWindowPoints(hWnd, 0, (LPPOINT)&Rect, 2u);
  }
  if ( hWndFrom )
  {
    GetClientRect(hWndFrom, &v8);
    MapWindowPoints(hWndFrom, 0, (LPPOINT)&v8, 2u);
  }
  v4 = Rect.left - v8.left;
  v5 = Rect.top - v8.top;
  if ( a4 )
  {
    v6 = a3;
    do
    {
      *(_DWORD *)v6 += v4;
      *(_DWORD *)(v6 + 4) += v5;
      --a4;
      v6 += 8;
    }
    while ( a4 );
  }
  return (unsigned __int16)v4 | ((unsigned __int16)v5 << 16);
}

//----- (6F7A5C4F) --------------------------------------------------------
int __stdcall MapRectInRTLMirroredWindow(int a1, HWND hWnd)
{
  int v2; // ebx@1
  int v3; // edi@1
  LONG v4; // eax@3
  int v5; // ecx@3
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@1

  v2 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a1 + 8) - *(_DWORD *)a1;
  Rect.left = 0;
  Rect.top = 0;
  Rect.right = 0;
  Rect.bottom = 0;
  if ( hWnd )
  {
    GetClientRect(hWnd, &Rect);
    MapWindowPoints(hWnd, 0, (LPPOINT)&Rect, 2u);
  }
  v4 = Rect.right - *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) -= Rect.top;
  v5 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = v4;
  *(_DWORD *)(a1 + 8) = v3 + v4;
  *(_DWORD *)(a1 + 12) = v2 + v5;
  return 1;
}

//----- (6F7A5CC3) --------------------------------------------------------
void __stdcall RBRealize(int a1, HDC hdc, BOOL bForceBkgd, int a4)
{
  signed int v4; // ebx@1
  HDC v5; // edi@2

  v4 = 0;
  if ( *(_DWORD *)(a1 + 36) )
  {
    v5 = hdc;
    if ( hdc || (v5 = GetDC(*(HWND *)a1)) != 0 )
    {
      SelectPalette(v5, *(HPALETTE *)(a1 + 36), bForceBkgd);
      if ( RealizePalette(v5) || a4 )
        v4 = 1;
      if ( !hdc )
        ReleaseDC(*(HWND *)a1, v5);
      if ( v4 )
        InvalidateRect(*(HWND *)a1, 0, 1);
    }
  }
}

//----- (6F7A5D35) --------------------------------------------------------
signed int __stdcall RBMoveBand(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // eax@1
  signed int v5; // eax@4
  int v6; // esi@4
  int v7; // ebx@4
  int v8; // ecx@9
  signed int result; // eax@10
  char v10; // [sp+4h] [bp-84h]@2
  int v11; // [sp+7Ch] [bp-Ch]@4
  int v12; // [sp+80h] [bp-8h]@4
  unsigned int v13; // [sp+84h] [bp-4h]@4
  signed int v14; // [sp+90h] [bp+8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 88);
  v14 = v4 == -1;
  if ( a2 == a3 )
  {
    result = 0;
  }
  else
  {
    qmemcpy(&v10, (const void *)(120 * a2 + *(_DWORD *)(v3 + 104)), 0x78u);
    if ( v4 == a2 )
    {
      *(_DWORD *)(v3 + 88) = a3;
      v14 = 1;
    }
    v13 = 120 * a2;
    v5 = a3 < a2 ? -1 : 1;
    v6 = a2 + v5;
    v12 = a2 + v5;
    v7 = 120 * (a2 + v5);
    v11 = 120 * v5;
    while ( 1 )
    {
      if ( !v14 && *(_DWORD *)(v3 + 88) == v6 )
      {
        *(_DWORD *)(v3 + 88) = a2;
        v14 = 1;
      }
      v8 = *(_DWORD *)(v3 + 104);
      a2 += v5;
      v12 += v5;
      qmemcpy((void *)(v8 + v13), (const void *)(v7 + v8), 0x78u);
      v13 += v11;
      v7 += v11;
      if ( a2 == a3 )
        break;
      v6 = v12;
    }
    qmemcpy((void *)(*(_DWORD *)(v3 + 104) + 120 * a3), &v10, 0x78u);
    result = 1;
  }
  return result;
}

//----- (6F7A5E10) --------------------------------------------------------
int __stdcall RBVertMungeGripperRect(int a1, LPRECT lprc)
{
  int v2; // eax@1
  int result; // eax@3

  v2 = *(_DWORD *)(a1 + 8);
  if ( (char)v2 < 0 && v2 & 0x4000 )
  {
    OffsetRect(lprc, lprc->top - lprc->left, lprc->left - lprc->top);
    result = g_cyEdge;
    lprc->bottom -= g_cyEdge;
  }
  else
  {
    result = FlipRect((int)lprc);
  }
  return result;
}

//----- (6F7A5E5A) --------------------------------------------------------
HGDIOBJ __stdcall RBDrawChevron(int a1, int a2, HDC hdc)
{
  int v3; // esi@1
  struct tagRECT rcDst; // [sp+4h] [bp-10h]@1

  v3 = *(_DWORD *)(a2 + 116) | 0x44;
  CopyRect(&rcDst, (const RECT *)(a2 + 100));
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    FlipRect((int)&rcDst);
  else
    v3 |= 2u;
  return DrawChevron(hdc, &rcDst, v3);
}

//----- (6F7A5EA8) --------------------------------------------------------
void __stdcall RBUpdateChevronState(int a1, int a2, unsigned __int16 a3)
{
  if ( a1 && a2 && a3 != *(_DWORD *)(a2 + 116) )
  {
    *(_DWORD *)(a2 + 116) = a3;
    if ( a3 & 0x80 )
    {
      if ( a2 == *(_DWORD *)(a1 + 144) )
        *(_DWORD *)(a1 + 144) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 144) = a2;
    }
    RBInvalidateRect(a1, (RECT *)(a2 + 100));
    UpdateWindow(*(HWND *)a1);
  }
}

//----- (6F7A5F01) --------------------------------------------------------
BOOL __stdcall SHHasTimeoutElapsed(int a1, DWORD a2)
{
  return a2 < GetTickCount() - a1;
}

//----- (6F7A5F1F) --------------------------------------------------------
BOOL __stdcall RBTileBlt(int a1, int a2, int x, int y, int a5, int cy, HDC hdc, HDC hdcSrc)
{
  int v8; // ecx@1
  int v9; // edi@1
  int v10; // esi@1
  int v11; // edi@3
  int v12; // esi@3
  int v13; // edi@6
  unsigned int v14; // ebx@6
  int v15; // esi@8
  unsigned int v16; // ebx@8
  unsigned int v17; // ecx@10
  unsigned int v18; // eax@10
  int v19; // ST30_4@12
  int v20; // ST30_4@16
  int v21; // esi@17

  v8 = a2;
  v9 = 0;
  v10 = 0;
  if ( !(*(_BYTE *)a2 & 0x20) )
  {
    if ( *(_BYTE *)(a1 + 8) & 0x80 )
    {
      v11 = *(_DWORD *)(a2 + 52);
      v12 = *(_DWORD *)(a2 + 48);
    }
    else
    {
      v11 = *(_DWORD *)(a2 + 48);
      v12 = *(_DWORD *)(a2 + 52);
    }
    v9 = -v11;
    v10 = -v12;
  }
  v13 = x + v9;
  v14 = *(_DWORD *)(a2 + 36);
  if ( v13 >= v14 )
    v13 %= v14;
  v15 = y + v10;
  v16 = *(_DWORD *)(a2 + 40);
  if ( v15 >= v16 )
    v15 %= v16;
  while ( 1 )
  {
    v17 = *(_DWORD *)(v8 + 36);
    v18 = *(_DWORD *)(a2 + 40);
    if ( v17 >= v13 + a5 )
      break;
    if ( v18 < v15 + cy )
    {
      v21 = v18 - v15;
      RBTileBlt(a1, a2, x, y, a5, v21, hdc, hdcSrc);
      y += v21;
      cy -= v21;
      goto LABEL_13;
    }
    v20 = v17 - v13;
    BitBlt(hdc, x, y, v17 - v13, cy, hdcSrc, v13, v15, 0xCC0020u);
    x += v20;
    a5 -= v20;
    v13 = 0;
LABEL_14:
    v8 = a2;
  }
  if ( v18 < v15 + cy )
  {
    v19 = v18 - v15;
    BitBlt(hdc, x, y, a5, v18 - v15, hdcSrc, v13, v15, 0xCC0020u);
    y += v19;
    cy -= v19;
LABEL_13:
    v15 = 0;
    goto LABEL_14;
  }
  return BitBlt(hdc, x, y, a5, cy, hdcSrc, v13, v15, 0xCC0020u);
}

//----- (6F7A604C) --------------------------------------------------------
signed int __stdcall RBGetBarInfo(int a1, int a2)
{
  signed int result; // eax@5

  if ( a1 && *(_DWORD *)a2 == 12 )
  {
    if ( *(_BYTE *)(a2 + 4) & 1 )
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 64);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A607C) --------------------------------------------------------
unsigned int __stdcall RBGetPrev(int a1, unsigned int a2, int a3)
{
  unsigned int result; // eax@1

  result = a2;
  do
    result -= 120;
  while ( result >= *(_DWORD *)(a1 + 104) && a3 & *(_DWORD *)result );
  return result;
}

//----- (6F7A60A1) --------------------------------------------------------
int __stdcall RBMinX(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // esi@1
  int v4; // edx@1

  v2 = a2;
  v3 = 0;
  v4 = *(_DWORD *)a2 & 8;
  while ( *(_DWORD *)(v2 + 48) || v4 )
  {
    v2 -= 120;
    v4 = *(_DWORD *)v2 & 8;
    if ( !v4 )
      v3 += _RBBandWidth(a1, *(_DWORD *)(v2 + 68));
  }
  return v3;
}

//----- (6F7A60E0) --------------------------------------------------------
int __stdcall minmax(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  if ( a1 <= a2 )
    result = a2;
  if ( result >= a3 )
    result = a3;
  return result;
}

//----- (6F7A6101) --------------------------------------------------------
int __stdcall RBPassBreak(int a1, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 & 1 )
  {
    *(_DWORD *)a2 = result & 0xFFFFFFFE;
    result = a3;
    if ( a3 )
      *(_DWORD *)a3 |= 1u;
  }
  return result;
}

//----- (6F7A6127) --------------------------------------------------------
int __stdcall RBGetClientRect(int a1, LPRECT lpRect)
{
  int result; // eax@1

  result = GetClientRect(*(HWND *)a1, lpRect);
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    result = FlipRect((int)lpRect);
  return result;
}

//----- (6F7A6153) --------------------------------------------------------
int __stdcall RBGetBandBorders(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edx@1
  int v6; // esi@4
  int v7; // ecx@6
  int v8; // eax@7

  v3 = *(_DWORD *)(a1 + 104) + 120 * a2;
  v4 = *(_DWORD *)v3;
  v5 = *(_DWORD *)(a1 + 8) & 0x400;
  if ( !(*(_DWORD *)v3 & 0x200) || v4 & 2 || *(_DWORD *)(v3 + 72) <= *(_DWORD *)(v3 + 28) )
    v6 = 0;
  else
    v6 = 5 * g_cxEdge + 2;
  v7 = *(_DWORD *)(v3 + 68) - *(_DWORD *)(v3 + 28) - v6;
  *(_DWORD *)a3 = v7;
  if ( v5 )
  {
    v8 = g_cxEdge;
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)a3 = v7 + 2 * v8;
    *(_DWORD *)(a3 + 4) = g_cyEdge / 2;
    *(_DWORD *)(a3 + 12) = g_cyEdge / 2;
  }
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    FlipRect(a3);
  return 0;
}

//----- (6F7A61E7) --------------------------------------------------------
void __stdcall RBOnPushChevron(int a1, int a2, int a3, int a4)
{
  LPARAM lParam; // [sp+8h] [bp-2Ch]@3
  int v5; // [sp+14h] [bp-20h]@1
  int v6; // [sp+18h] [bp-1Ch]@1
  int v7; // [sp+1Ch] [bp-18h]@1
  struct tagRECT rcDst; // [sp+20h] [bp-14h]@1
  int v9; // [sp+30h] [bp-4h]@1

  v5 = (a3 - *(_DWORD *)(a2 + 104)) / 120;
  v6 = *(_DWORD *)(a3 + 76);
  v7 = *(_DWORD *)(a3 + 92);
  v9 = a4;
  CopyRect(&rcDst, (const RECT *)(a3 + 100));
  if ( *(_BYTE *)(a2 + 8) & 0x80 )
    FlipRect((int)&rcDst);
  RBUpdateChevronState(a2, a3, 0x10u);
  CCReleaseCapture(a2);
  CCSendNotify(a2, -841, (LPARAM)&lParam);
  RBUpdateChevronState(a2, *(_DWORD *)(a2 + 144), 0x80u);
}

//----- (6F7A626E) --------------------------------------------------------
int __stdcall RBCanBandMove(int a1, int a2)
{
  int v2; // eax@1
  unsigned int v3; // edi@2
  int result; // eax@5

  v2 = *(_DWORD *)(a1 + 52);
  if ( v2 )
    v3 = 120 * v2 + *(_DWORD *)(a1 + 104) - 120;
  else
    v3 = 0;
  if ( RBEnumBand(a1, 1, 8) > v3 || *(_DWORD *)(a1 + 8) & 0x800 && a2 == RBEnumBand(a1, 0, 8) )
    result = 0;
  else
    result = ~(unsigned __int8)(*(_DWORD *)a2 >> 1) & 1;
  return result;
}

//----- (6F7A62CD) --------------------------------------------------------
int __stdcall _RBHitTest(int a1, int a2, POINT pt)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  LONG v6; // edx@5
  LONG v7; // eax@6
  int v8; // ecx@10
  int result; // eax@10
  int v10; // eax@12
  int v11; // eax@15
  unsigned int v12; // edx@17
  int v13; // eax@18
  int v14; // edi@22
  char v15; // [sp+Ch] [bp-18h]@2
  int v16; // [sp+1Ch] [bp-8h]@1
  int v17; // [sp+20h] [bp-4h]@12
  int v18; // [sp+2Ch] [bp+8h]@3

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 104);
  v16 = *(_DWORD *)(a1 + 8) & 0x80;
  if ( !a2 )
    a2 = (int)&v15;
  v5 = *(_DWORD *)(a1 + 52);
  v18 = 0;
  if ( v5 <= 0 )
  {
LABEL_10:
    v8 = a2;
    *(_DWORD *)(a2 + 8) = 1;
    result = -1;
  }
  else
  {
    while ( 1 )
    {
      if ( !(*(_BYTE *)v4 & 8) )
      {
        v6 = *(_DWORD *)(v4 + 48);
        if ( pt.x >= v6 )
        {
          v7 = *(_DWORD *)(v4 + 52);
          if ( pt.y >= v7 && pt.x <= v6 + *(_DWORD *)(v4 + 56) && pt.y <= v7 + *(_DWORD *)(v4 + 60) )
            break;
        }
      }
      ++v18;
      v4 += 120;
      if ( v18 >= v5 )
        goto LABEL_10;
    }
    v10 = *(_DWORD *)v4;
    v17 = *(_DWORD *)v4;
    v17 &= 0x200u;
    if ( !v17 || v10 & 2 || *(_DWORD *)(v4 + 72) <= *(_DWORD *)(v4 + 28) )
      v11 = 0;
    else
      v11 = 5 * g_cxEdge + 2;
    v12 = *(_DWORD *)(v4 + 28);
    if ( pt.x > (signed int)(*(_DWORD *)(v4 + 48) + *(_DWORD *)(v4 + 68) - v12 - v11) )
    {
      if ( v17
        && !(*(_BYTE *)v4 & 2)
        && *(_DWORD *)(v4 + 72) > v12
        && *(_BYTE *)(v4 + 96) & 1
        && PtInRect((const RECT *)(v4 + 100), pt) )
        *(_DWORD *)(a2 + 8) = 8;
      else
        *(_DWORD *)(a2 + 8) = 3;
    }
    else
    {
      *(_DWORD *)(a2 + 8) = 2;
      v13 = *(_DWORD *)(v3 + 8);
      if ( (char)v13 < 0 && v13 & 0x4000 )
      {
        if ( pt.y - *(_DWORD *)(v4 + 52) < 5 )
          *(_DWORD *)(a2 + 8) = 4;
      }
      else
      {
        v14 = g_cyBorder;
        if ( !v16 )
          v14 = g_cxBorder;
        if ( RBShouldDrawGripper(v3, *(_DWORD *)(v3 + 104) + 120 * v18) && pt.x <= *(_DWORD *)(v4 + 48) + 5 * v14 )
          *(_DWORD *)(a2 + 8) = 4;
      }
    }
    result = v18;
    v8 = a2;
  }
  *(_DWORD *)(v8 + 12) = result;
  return result;
}

//----- (6F7A6440) --------------------------------------------------------
int __stdcall RBHitTest(int a1, int a2)
{
  unsigned int v2; // ecx@2
  unsigned int v3; // edx@2

  if ( *(_BYTE *)(a1 + 8) & 0x80 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    v3 = *(_DWORD *)a2;
  }
  else
  {
    v2 = *(_DWORD *)a2;
    v3 = *(_DWORD *)(a2 + 4);
  }
  return _RBHitTest(a1, a2, (POINT)__PAIR__(v3, v2));
}

//----- (6F7A6471) --------------------------------------------------------
unsigned int __stdcall RBBPrevVisible(int a1, unsigned int a2)
{
  unsigned int v2; // eax@1

  v2 = RBGetPrev(a1, a2, 8);
  return v2 >= *(_DWORD *)(a1 + 104) ? v2 : 0;
}

//----- (6F7A649A) --------------------------------------------------------
int __stdcall RBMaxX(int a1, unsigned int a2)
{
  unsigned int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  unsigned int v5; // eax@9

  v2 = a2;
  v3 = *(_DWORD *)(a1 + 104) + 120 * *(_DWORD *)(a1 + 52);
  v4 = 0;
  while ( v2 < v3 )
  {
    if ( !(*(_BYTE *)v2 & 8) )
    {
      if ( !*(_DWORD *)(v2 + 48) )
        break;
      if ( v2 == a2 )
        v4 += *(_DWORD *)(v2 + 68);
      else
        v4 += _RBBandWidth(a1, *(_DWORD *)(v2 + 68));
    }
    v2 += 120;
  }
  v5 = RBGetPrev(a1, v2, 8);
  return *(_DWORD *)(v5 + 48) + *(_DWORD *)(v5 + 56) - v4;
}

//----- (6F7A64F9) --------------------------------------------------------
HCURSOR __stdcall RBSetCursor(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  HCURSOR v5; // eax@3
  unsigned int v7; // [sp-4h] [bp-18h]@4
  int v8; // [sp+4h] [bp-10h]@1
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1

  v8 = a2;
  v9 = a3;
  v4 = RBHitTest(a1, (int)&v8);
  if ( v10 != 4 )
  {
    if ( a4 && v10 == 2 && RBShouldDrawGripper(a1, *(_DWORD *)(a1 + 104) + 120 * v4) )
      v7 = 32646;
    else
      v7 = 32512;
    goto LABEL_10;
  }
  if ( !a4 )
  {
    v7 = (*(_DWORD *)(a1 + 8) & 0x80 | 0x3FC200u) >> 7;
LABEL_10:
    v5 = LoadCursorW(0, (LPCWSTR)v7);
    return SetCursor(v5);
  }
  v5 = LoadCursorW(g_hinst, (LPCWSTR)((*(_DWORD *)(a1 + 8) & 0x80) != 0 ? 135 : 107));
  return SetCursor(v5);
}

//----- (6F7A6594) --------------------------------------------------------
int __stdcall RebarDragCallback(HWND hWnd, int a2, int a3, LPARAM lParam)
{
  int v4; // esi@1
  LONG v6; // ecx@5
  HWND v7; // ST04_4@5
  int v8; // eax@5
  struct tagPOINT Points; // [sp+4h] [bp-10h]@5
  int v10; // [sp+Ch] [bp-8h]@5

  v4 = GetWindowLongW(hWnd, 0);
  if ( a2 )
  {
    if ( a2 == 1 )
      return GetItemObject(v4, -832, (int)&IID_IDropTarget, lParam);
  }
  else if ( lParam )
  {
    v6 = *(_DWORD *)lParam;
    Points.y = *(_DWORD *)(lParam + 4);
    v7 = *(HWND *)v4;
    Points.x = v6;
    MapWindowPoints(0, v7, &Points, 1u);
    v8 = RBHitTest(v4, (int)&Points);
    *(_DWORD *)a3 = v10;
    if ( v8 != -1 )
      return *(_DWORD *)(120 * v8 + *(_DWORD *)(v4 + 104) + 76);
  }
  return -1;
}

//----- (6F7A661C) --------------------------------------------------------
void *__stdcall RBSetFont(int a1, int a2)
{
  void *result; // eax@3
  void *v3; // edi@5
  int pvParam; // [sp+4h] [bp-1F8h]@4
  LOGFONTW lf; // [sp+1Ch] [bp-1E0h]@5

  if ( a2 && a2 != 42 || (pvParam = 500, !SystemParametersInfoW(0x29u, 0x1F4u, &pvParam, 0)) )
  {
    result = 0;
  }
  else
  {
    v3 = *(void **)(a1 + 76);
    lf.lfWeight = 400;
    result = CreateFontIndirectW(&lf);
    *(_DWORD *)(a1 + 76) = result;
    if ( result )
    {
      *(_DWORD *)(a1 + 40) |= 0x400u;
      if ( v3 )
        DeleteObject(v3);
      result = RBAfterSetFont(a1);
    }
    else
    {
      *(_DWORD *)(a1 + 76) = v3;
    }
  }
  return result;
}

//----- (6F7A66BA) --------------------------------------------------------
signed int __stdcall RBSetBandPos(int a1, unsigned int a2, LONG a3)
{
  LONG v3; // ebx@1
  unsigned int v4; // esi@1
  signed int result; // eax@2
  unsigned int v6; // eax@3
  LONG v7; // ecx@3
  unsigned int v8; // edi@3
  int v9; // eax@3
  int v10; // eax@3
  int v11; // eax@4
  bool v12; // zf@4
  int i; // eax@6
  int v14; // ST10_4@7
  unsigned int v15; // eax@7
  int v16; // eax@7
  bool v17; // sf@8
  unsigned __int8 v18; // of@8
  int v19; // eax@8
  int v20; // eax@12
  int v21; // ecx@12
  struct tagRECT rc; // [sp+8h] [bp-14h]@3
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+28h] [bp+Ch]@3

  v3 = a3;
  v4 = a2;
  v23 = *(_DWORD *)(a1 + 8) & 0x400;
  if ( *(_DWORD *)(a2 + 48) == a3 )
  {
    result = 0;
  }
  else
  {
    v6 = RBGetPrev(a1, a2, 8);
    v7 = *(_DWORD *)(a2 + 48);
    v8 = v6;
    v24 = v7 < a3;
    SetRect(
      &rc,
      *(_DWORD *)(v4 + 48),
      *(_DWORD *)(v4 + 52),
      v7 + *(_DWORD *)(v4 + 68),
      *(_DWORD *)(v4 + 52) + *(_DWORD *)(v4 + 60));
    v9 = *(_DWORD *)(v4 + 48) + *(_DWORD *)(v4 + 56);
    *(_DWORD *)(v4 + 48) = a3;
    v10 = v9 - a3;
    *(_DWORD *)(v4 + 56) = v10;
    *(_DWORD *)(v4 + 64) = v10;
    if ( v24 )
    {
      v11 = a3 - *(_DWORD *)(v8 + 48);
      v12 = v23 == 0;
      *(_DWORD *)(v8 + 56) = v11;
      if ( !v12 )
      {
        *(_DWORD *)(v8 + 56) = v11 - g_cxEdge;
        rc.left -= g_cxEdge;
      }
      *(_DWORD *)(v8 + 64) = *(_DWORD *)(v8 + 56);
      for ( i = *(_DWORD *)(v4 + 56); ; *(_DWORD *)(v4 + 64) = i )
      {
        v18 = __OFSUB__(i, *(_DWORD *)(v4 + 68));
        v17 = i - *(_DWORD *)(v4 + 68) < 0;
        v19 = *(_DWORD *)(v4 + 68);
        if ( !(v17 ^ v18) )
          break;
        v14 = *(_DWORD *)(v4 + 68);
        *(_DWORD *)(v4 + 56) = v19;
        *(_DWORD *)(v4 + 64) = v19;
        v3 += _RBBandWidth(a1, v14);
        v15 = RBGetNext(a1, v4, 8);
        v4 = v15;
        v16 = *(_DWORD *)(v15 + 48) + *(_DWORD *)(v15 + 56);
        *(_DWORD *)(v4 + 48) = v3;
        i = v16 - v3;
        *(_DWORD *)(v4 + 56) = i;
      }
      rc.right = v3 + v19;
    }
    else
    {
      while ( 1 )
      {
        if ( v23 )
          v3 -= g_cxEdge;
        v20 = *(_DWORD *)(v8 + 68);
        v21 = v3 - *(_DWORD *)(v8 + 48);
        *(_DWORD *)(v8 + 56) = v21;
        *(_DWORD *)(v8 + 64) = v21;
        if ( v21 >= v20 )
          break;
        v3 -= v20;
        *(_DWORD *)(v8 + 48) = v3;
        *(_DWORD *)(v8 + 56) = v20;
        *(_DWORD *)(v8 + 64) = v20;
        v8 = RBGetPrev(a1, v8, 8);
      }
      rc.left = v3;
    }
    if ( v23 )
      rc.bottom += g_cyEdge / 2;
    RBResizeChildren(a1);
    if ( RBInvalidateRect(a1, &rc) )
      UpdateWindow(*(HWND *)a1);
    result = 1;
  }
  return result;
}

//----- (6F7A6815) --------------------------------------------------------
signed int __stdcall RBSetBandPosAnim(int a1, unsigned int a2, LONG a3)
{
  LONG v3; // ebx@1
  LONG v4; // esi@1
  signed int result; // eax@2
  int v6; // edi@3
  int v7; // eax@4
  signed int v8; // [sp+8h] [bp-4h]@1
  int v9; // [sp+1Ch] [bp+10h]@3

  v8 = 0;
  v3 = a3;
  v4 = *(_DWORD *)(a2 + 48);
  if ( v4 == a3 )
  {
    result = 0;
  }
  else
  {
    v9 = GetTickCount();
    v6 = (v3 - v4) / 10;
    if ( v6 )
    {
      v7 = v3 - v6;
      if ( v4 < v3 )
      {
        while ( v4 < v7 )
        {
          RBSetBandPos(a1, a2, v4);
          if ( SHHasTimeoutElapsed(v9, 0x1F4u) )
            break;
          Sleep(5u);
          if ( v8 >= 8 && v6 >= 4 )
            v6 = 2 * v6 / 3;
          ++v8;
          v4 += v6;
          v7 = v3 - v6;
        }
      }
      else
      {
        while ( v4 > v7 )
        {
          RBSetBandPos(a1, a2, v4);
          if ( SHHasTimeoutElapsed(v9, 0x1F4u) )
            break;
          Sleep(5u);
          if ( v8 >= 8 && v6 <= -4 )
            v6 = 2 * v6 / 3;
          ++v8;
          v4 += v6;
          v7 = v3 - v6;
        }
      }
    }
    RBSetBandPos(a1, a2, v3);
    result = 1;
  }
  return result;
}

//----- (6F7A690D) --------------------------------------------------------
signed int __stdcall RBDragSize(int a1, LONG a2)
{
  return RBSetBandPos(a1, *(_DWORD *)(a1 + 104) + 120 * *(_DWORD *)(a1 + 88), a2);
}

//----- (6F7A6931) --------------------------------------------------------
signed int __stdcall RBRoomForBandVert(int a1, int a2)
{
  int v2; // ebx@1
  bool v3; // zf@1
  signed int result; // eax@1
  int v5; // edi@1
  int v6; // [sp+Ch] [bp-4h]@1

  v6 = 0;
  v2 = a2;
  v3 = (*(_DWORD *)(a1 + 8) & 0x400) == 0;
  result = *(_DWORD *)(a1 + 104);
  v5 = *(_DWORD *)(a2 + 32);
  a2 = *(_DWORD *)(a1 + 104);
  if ( !v3 )
    v5 += g_cyEdge;
  while ( result )
  {
    if ( *(_BYTE *)result & 8 || *(_DWORD *)(result + 48) )
    {
      result = RBBNextVisible(a1, result);
      a2 = result;
    }
    else
    {
      v6 += RBGetRowHeightExtra(a1, (unsigned int *)&a2, v2);
      if ( v6 >= v5 )
        return 1;
      result = a2;
    }
  }
  return result;
}

//----- (6F7A69A0) --------------------------------------------------------
int __stdcall RBMakeNewRow(int a1, unsigned int a2, int a3)
{
  int v3; // edi@1
  int v4; // ebx@2
  unsigned int v5; // esi@2
  int v6; // eax@3
  signed int v7; // eax@14
  int v8; // eax@18
  int v9; // eax@20
  struct tagRECT rc; // [sp+Ch] [bp-14h]@1
  int v12; // [sp+1Ch] [bp-4h]@1
  int v13; // [sp+28h] [bp+8h]@2
  unsigned int v14; // [sp+2Ch] [bp+Ch]@6

  v3 = a1;
  v12 = 0;
  RBGetClientRect(a1, &rc);
  InflateRect(&rc, 0, -g_cyEdge);
  if ( *(_DWORD *)(a1 + 8) & 0x800 )
  {
    if ( (*(_DWORD *)(a2 + 48) || *(_BYTE *)a2 & 8) && a3 > *(_DWORD *)(a2 + 52) + *(_DWORD *)(a2 + 60) )
    {
      *(_DWORD *)a2 |= 1u;
      goto LABEL_25;
    }
  }
  else
  {
    v4 = g_cyEdge;
    v5 = a2;
    v13 = 4 * g_cyEdge;
    if ( RBRoomForBandVert(v3, a2) )
      v6 = -v4;
    else
      v6 = v13;
    if ( a3 < rc.top - v6 )
    {
      v14 = RBEnumBand(v3, 0, 8);
      if ( v14 == v5 )
        v14 = RBBNextVisible(v3, v5);
      v12 = RBMoveBand(v3, (signed int)(v5 - *(_DWORD *)(v3 + 104)) / 120, 0);
      if ( !v14 || *(_DWORD *)v14 & 1 )
        goto LABEL_26;
      *(_DWORD *)v14 |= 1u;
LABEL_25:
      v12 = 1;
LABEL_26:
      if ( v12 )
        RBResize(v3, 0);
      return v12;
    }
    if ( a3 >= v6 + rc.bottom )
    {
      if ( !(*(_DWORD *)a2 & 1) )
      {
        *(_DWORD *)a2 |= 1u;
        v12 = 1;
      }
      v7 = RBMoveBand(v3, (signed int)(a2 - *(_DWORD *)(v3 + 104)) / 120, *(_DWORD *)(v3 + 52) - 1);
      v12 |= v7;
      goto LABEL_26;
    }
    if ( (*(_DWORD *)(a2 + 48) || *(_BYTE *)a2 & 8) && GetAsyncKeyState(17) < 0 )
    {
      v8 = *(_DWORD *)(a2 + 52) + *(_DWORD *)(a2 + 60);
      if ( a3 > v8 && a3 < g_cyEdge + v8 )
      {
        v9 = RBGetLastInRow(v3, a2, 0);
        *(_DWORD *)a2 |= 1u;
        RBMoveBand(v3, (signed int)(a2 - *(_DWORD *)(v3 + 104)) / 120, (v9 - *(_DWORD *)(v3 + 104)) / 120);
        goto LABEL_25;
      }
    }
  }
  return v12;
}

//----- (6F7A6B31) --------------------------------------------------------
void __stdcall RBDragBand(int a1, POINT pt)
{
  LONG v2; // ecx@1
  int v3; // esi@1
  int v4; // edx@1
  int v5; // edi@1
  bool v6; // zf@2
  int v7; // eax@13
  unsigned int v8; // eax@14
  unsigned int v9; // ecx@14
  int v10; // ebx@14
  int v11; // ST0C_4@24
  int v12; // eax@24
  int v13; // eax@24
  int v14; // eax@26
  int v15; // eax@29
  int v16; // eax@31
  unsigned int v17; // [sp+14h] [bp+8h]@15

  v2 = pt.x;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 88);
  v5 = *(_DWORD *)(a1 + 104) + 120 * *(_DWORD *)(a1 + 88);
  if ( pt == *(_QWORD *)(a1 + 136) )
    return;
  v6 = (*(_BYTE *)(a1 + 8) & 0x80) == 0;
  *(_QWORD *)(a1 + 136) = pt;
  if ( !v6 )
  {
    pt.x = pt.y;
    pt.y = v2;
  }
  if ( !(*(_DWORD *)(a1 + 40) & 0x800) )
  {
    if ( pt.y >= *(_DWORD *)(a1 + 96) - g_cyEdge
      && pt.y <= g_cyEdge + *(_DWORD *)(a1 + 96)
      && pt.x >= *(_DWORD *)(a1 + 92) - g_cxEdge
      && pt.x <= g_cxEdge + *(_DWORD *)(a1 + 92)
      || RBSendNotify(a1, v4, -835)
      || (unsigned int)((v5 - *(_DWORD *)(a1 + 104)) / 120) >= *(_DWORD *)(a1 + 52) )
      return;
    *(_DWORD *)(a1 + 40) |= 0x800u;
  }
  if ( !RBCanBandMove(a1, v5) )
    return;
  v7 = _RBHitTest(a1, 0, pt);
  if ( v7 == -1 )
  {
    RBMakeNewRow(a1, v5, pt.y);
    return;
  }
  v8 = RBGetPrev(a1, *(_DWORD *)(a1 + 104) + 120 * (v7 + 1), 2);
  v9 = *(_DWORD *)(a1 + 104);
  v10 = v8;
  if ( v8 < v9 )
    return;
  v17 = (signed int)(v8 - v9) / 120;
  if ( *(_DWORD *)(v8 + 52) != *(_DWORD *)(v5 + 52) || v8 != v5 && v8 != RBBPrevVisible(v3, v5) )
  {
    if ( RBMakeNewRow(v3, v5, pt.y) )
      return;
    v14 = (v5 - *(_DWORD *)(v3 + 104)) / 120;
    if ( *(_DWORD *)(v3 + 8) & 0x800 )
    {
      if ( (signed int)v17 < v14 )
      {
        v16 = RBBNextVisible(v3, v5);
        RBPassBreak(v3, v5, v16);
      }
    }
    else
    {
      if ( (signed int)v17 < v14 )
        ++v17;
      v15 = RBBNextVisible(v3, v5);
      RBPassBreak(v3, v5, v15);
      RBMoveBand(v3, *(_DWORD *)(v3 + 88), v17);
    }
    goto LABEL_32;
  }
  if ( pt.x < 5 && !(*(_DWORD *)(v3 + 8) & 0x800) )
  {
    RBPassBreak(v3, v10, v5);
    if ( !RBMoveBand(v3, *(_DWORD *)(v3 + 88), v17) )
      return;
LABEL_32:
    RBResize(v3, 0);
    return;
  }
  if ( *(_DWORD *)(v5 + 48) || *(_BYTE *)v5 & 8 )
  {
    v11 = RBMaxX(v3, v5);
    v12 = RBMinX(v3, v5);
    v13 = minmax(pt.x + *(_DWORD *)(v3 + 100) - *(_DWORD *)(v3 + 92), v12, v11);
    RBDragSize(v3, v13);
  }
}

//----- (6F7A6D31) --------------------------------------------------------
int __stdcall RBGrowBand(int a1, int a2, signed int a3, int a4)
{
  signed int v4; // edi@1
  signed int v5; // ecx@1
  signed int v6; // esi@3
  int v7; // ebx@3
  int v8; // edx@4
  int v9; // eax@10
  int v10; // eax@15

  v4 = a3;
  v5 = a3;
  if ( a3 < 0 )
    v5 = -a3;
  v6 = *(_DWORD *)(a2 + 84);
  v7 = 0;
  if ( v6 )
  {
    v8 = a3;
    if ( a3 < 0 )
      v8 = -a3;
    if ( v6 <= (unsigned int)v8 )
    {
      if ( a4 )
      {
        v7 = a3 / v5 * v6;
LABEL_15:
        v10 = v7 + *(_DWORD *)(a2 + 88);
        if ( *(_DWORD *)(a2 + 32) > v10 || (unsigned int)v10 > *(_DWORD *)(a2 + 80) )
        {
          v7 = 0;
        }
        else
        {
          *(_DWORD *)(a2 + 88) = v10;
          RBResize(a1, 1);
        }
        return v7;
      }
      if ( a3 < 0 )
      {
        v9 = *(_DWORD *)(a2 + 32) - *(_DWORD *)(a2 + 88);
        if ( v9 <= a3 )
        {
LABEL_14:
          v7 = v6 * (v4 / v6);
          goto LABEL_15;
        }
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 80) - *(_DWORD *)(a2 + 88);
        if ( v9 >= a3 )
          goto LABEL_14;
      }
      v4 = v9;
      goto LABEL_14;
    }
  }
  return v7;
}

//----- (6F7A6DC1) --------------------------------------------------------
signed int __stdcall RBShowBand(int a1, unsigned int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@3
  HWND v5; // esi@6
  HWND v6; // esi@8
  signed int result; // eax@12
  int v8; // [sp+10h] [bp+8h]@3

  v3 = a1;
  if ( a1 && a2 < *(_DWORD *)(a1 + 52) )
  {
    v4 = *(_DWORD *)(a1 + 104) + 120 * a2;
    v8 = RBRecalcFirst(0, a1, v4);
    if ( a3 )
    {
      *(_DWORD *)v4 &= 0xFFFFFFF7;
      if ( !RBBCalcTextExtent(v3, (HGDIOBJ)v4, 0) )
        RBBCalcMinWidth(v3, v4);
      v5 = *(HWND *)(v4 + 24);
      if ( v5 )
        ShowWindow(v5, 5);
    }
    else
    {
      *(_DWORD *)v4 |= 8u;
      v6 = *(HWND *)(v4 + 24);
      if ( v6 )
        ShowWindow(v6, 0);
    }
    if ( v8 )
      RBRecalcFirst(1, v3, 0);
    RBInvalidateRect(v3, 0);
    RBResize(v3, 0);
    RBAutoSize(v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A6E5A) --------------------------------------------------------
int __stdcall RBMaximizeBand(int a1, unsigned int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v6; // edi@3
  int v7; // eax@6
  int v8; // esi@8
  unsigned int v9; // eax@10
  int v10; // ebx@13
  int v11; // eax@13
  int v12; // ebx@13
  signed int v13; // eax@16
  int v14; // eax@20
  signed int v15; // eax@24
  unsigned int v16; // eax@26
  unsigned int v17; // esi@26
  signed int v18; // eax@31
  unsigned int v19; // [sp-Ch] [bp-18h]@22
  LONG v20; // [sp-8h] [bp-14h]@15
  int v21; // [sp-8h] [bp-14h]@22
  int v22; // [sp-8h] [bp-14h]@23
  signed int v23; // [sp+8h] [bp-4h]@1
  unsigned int v24; // [sp+18h] [bp+Ch]@10

  v23 = 0;
  v4 = a1;
  if ( a2 >= *(_DWORD *)(a1 + 52) )
    return 0;
  v6 = *(_DWORD *)(a1 + 104) + 120 * a2;
  if ( *(_DWORD *)v6 & 2 )
    return 0;
  if ( *(_DWORD *)v6 & 0x200 && *(_DWORD *)(v6 + 72) > *(_DWORD *)(v6 + 28) )
    v7 = 5 * g_cxEdge + 2;
  else
    v7 = 0;
  v8 = *(_DWORD *)(v6 + 68) + *(_DWORD *)(v6 + 72) - *(_DWORD *)(v6 + 56) - *(_DWORD *)(v6 + 28) - v7;
  if ( a3 && v8 > 0 )
  {
    v9 = RBBNextVisible(a1, v6);
    v24 = v9;
    if ( v9 && (*(_DWORD *)(v9 + 48) || *(_BYTE *)v9 & 8) )
    {
      v10 = RBMaxX(a1, v9);
      v11 = *(_DWORD *)(v24 + 48);
      v12 = v10 - v11;
      if ( v12 > v8 )
        v12 = v8;
      v20 = v12 + v11;
      if ( a4 )
        v13 = RBSetBandPosAnim(a1, v24, v20);
      else
        v13 = RBSetBandPos(a1, v24, v20);
      v8 -= v12;
      v4 = a1;
      v23 = v13;
    }
    if ( !v8 )
      return v23;
    v14 = RBMinX(v4, v6);
    if ( *(_DWORD *)(v6 + 48) - v14 > v8 )
      v14 = *(_DWORD *)(v6 + 48) - v8;
    v21 = v14;
    v19 = v6;
  }
  else
  {
    v22 = RBMinX(a1, v6);
    if ( a4 )
      v15 = RBSetBandPosAnim(a1, v6, v22);
    else
      v15 = RBSetBandPos(a1, v6, v22);
    v23 = v15;
    v16 = RBBNextVisible(a1, v6);
    v17 = v16;
    if ( !v16 || !*(_DWORD *)(v16 + 48) && !(*(_BYTE *)v16 & 8) )
      return v23;
    v21 = RBMaxX(a1, v16);
    v19 = v17;
  }
  if ( a4 )
    v18 = RBSetBandPosAnim(v4, v19, v21);
  else
    v18 = RBSetBandPos(v4, v19, v21);
  return v18 | v23;
}

//----- (6F7A6F90) --------------------------------------------------------
void __stdcall RBOnBeginDrag(int a1, int a2)
{
  *(_DWORD *)(a1 + 136) = -1;
  *(_DWORD *)(a1 + 140) = -1;
  *(_DWORD *)(a1 + 88) = a2;
  if ( a2 == -1 )
  {
    *(_DWORD *)(a1 + 40) &= 0xFFFFF7BF;
    if ( *(_DWORD *)(a1 + 8) & 0x2000 )
    {
      RBSizeBandsToRect(a1, 0);
      RBSizeBandsToRowHeight(a1);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 40) |= 0x840u;
  }
}

//----- (6F7A6FE3) --------------------------------------------------------
void __stdcall RBOnMouseMove(HWND hWnd, int a2, int a3, int a4, int a5)
{
  POINT v5; // ST0C_8@5
  int v6; // ebx@6
  int v7; // eax@6
  int v8; // edi@7
  int v9; // [sp+8h] [bp-10h]@6
  int v10; // [sp+Ch] [bp-Ch]@6
  char v11; // [sp+10h] [bp-8h]@12

  RelayToToolTips(*(HWND *)(a5 + 48), (int)hWnd, a2, a3, a4);
  if ( *(_DWORD *)(a5 + 88) == -1 )
  {
    v9 = (signed __int16)a4;
    v6 = *(_DWORD *)(a5 + 144);
    v10 = SHIWORD(a4);
    v7 = RBHitTest(a5, (int)&v9);
    if ( v7 == -1 )
      v8 = 0;
    else
      v8 = *(_DWORD *)(a5 + 104) + 120 * v7;
    if ( !v6 || !(*(_BYTE *)(v6 + 116) & 0x10) )
    {
      if ( v8 )
      {
        if ( v11 & 8 )
        {
          SetCapture(hWnd);
          RBUpdateChevronState(a5, v8, 8u);
          if ( v8 == v6 )
            v6 = 0;
        }
      }
      if ( v6 )
      {
        CCReleaseCapture(a5);
        RBUpdateChevronState(a5, v6, 0x80u);
      }
    }
  }
  else if ( hWnd == GetCapture() || *(_BYTE *)(a5 + 40) & 0x40 )
  {
    v5.y = SHIWORD(a4);
    v5.x = (signed __int16)a4;
    RBDragBand(a5, v5);
  }
  else
  {
    RBSendNotify(a5, *(_DWORD *)(a5 + 88), -836);
    RBOnBeginDrag(a5, -1);
  }
}

//----- (6F7A70CE) --------------------------------------------------------
int __stdcall RBMinimizeBand(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // esi@1
  int result; // eax@2
  int v5; // ebx@3
  unsigned int v6; // eax@3
  int v7; // edx@4
  unsigned int v8; // eax@6
  int v9; // esi@7
  LONG v10; // [sp-8h] [bp-10h]@14

  v3 = *(_DWORD *)(a1 + 52);
  if ( a2 >= v3 )
    return 0;
  v5 = *(_DWORD *)(a1 + 104);
  v6 = v5 + 120 * a2;
  if ( *(_DWORD *)v6 & 2 )
    return 0;
  v7 = *(_DWORD *)(v6 + 48);
  if ( !v7 && !(*(_DWORD *)v6 & 8) )
  {
    v8 = RBGetNext(a1, v6, 8);
    if ( v3 )
      v9 = 120 * v3 + v5 - 120;
    else
      v9 = 0;
    if ( v8 <= v9 && (*(_DWORD *)(v8 + 48) || *(_BYTE *)v8 & 8) )
      return RBMaximizeBand(a1, (signed int)(v8 - v5) / 120, 0, a3);
    return 0;
  }
  v10 = v7 + *(_DWORD *)(v6 + 56) - *(_DWORD *)(v6 + 68);
  if ( a3 )
    result = RBSetBandPosAnim(a1, v6, v10);
  else
    result = RBSetBandPos(a1, v6, v10);
  return result;
}

//----- (6F7A716C) --------------------------------------------------------
void __stdcall RBToggleBand(int a1, int a2)
{
  if ( !CCSendNotify(a1, -852, 0)
    && (RBMaximizeBand(a1, *(_DWORD *)(a1 + 88), 1, a2) || RBMinimizeBand(a1, *(_DWORD *)(a1 + 88), a2)) )
    CCPlaySound(L"ShowBand");
}

//----- (6F7A71CF) --------------------------------------------------------
unsigned int __stdcall MCInsertMarkers(unsigned int a1, signed int *a2)
{
  unsigned int result; // eax@1
  signed int *v3; // esi@2
  __int16 v4; // cx@3
  signed int v5; // edx@3
  signed int v6; // edx@10
  int v7; // [sp+8h] [bp-8h]@1
  int v8; // [sp+Ch] [bp-4h]@1
  int v9; // [sp+18h] [bp+8h]@1

  result = a1;
  v7 = 0;
  v8 = 0;
  v9 = a1 + 38;
  if ( result < v9 )
  {
    v3 = a2;
    while ( 1 )
    {
      v4 = *(_WORD *)v3;
      v5 = *(_WORD *)v3;
      if ( !*(_WORD *)v3 )
        goto LABEL_24;
      if ( v5 <= 0 )
        goto LABEL_21;
      if ( v5 <= 4 )
        goto LABEL_22;
      if ( v5 == 39 )
        break;
      if ( v5 == 77 || v5 == 109 )
      {
        v6 = 1;
      }
      else
      {
        if ( v5 != 121 )
          goto LABEL_21;
        v6 = 2;
      }
      if ( v7 || v6 & v8 )
        goto LABEL_21;
      v8 |= v6;
      *(_WORD *)result = v6;
      result += 2;
      while ( *(_WORD *)v3 == v4 )
      {
        if ( result >= v9 )
          goto LABEL_24;
        *(_WORD *)result = v4;
        result += 2;
        v3 = (signed int *)((char *)v3 + 2);
      }
      if ( result >= v9 )
        goto LABEL_24;
      *(_WORD *)result = v6 + 2;
      result += 2;
LABEL_23:
      if ( result >= v9 )
        goto LABEL_24;
    }
    v7 ^= 1u;
LABEL_21:
    *(_WORD *)result = v4;
    result += 2;
LABEL_22:
    v3 = (signed int *)((char *)v3 + 2);
    goto LABEL_23;
  }
LABEL_24:
  *(_WORD *)result = 0;
  return result;
}

//----- (6F7A7274) --------------------------------------------------------
int __stdcall MCRemoveMarkers(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  __int16 v4; // ax@3
  int v5; // ecx@3
  int result; // eax@10
  int v7; // [sp+14h] [bp+Ch]@4

  v2 = a2;
  v3 = 0;
  if ( a2 )
  {
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 16) = 0;
  }
  v4 = *(_WORD *)a1;
  v5 = *(_WORD *)a1;
  if ( *(_WORD *)a1 )
  {
    v7 = a1;
    do
    {
      if ( (unsigned int)(v5 - 1) > 3 )
      {
        *(_WORD *)(a1 + 2 * v3++) = v4;
      }
      else if ( v2 )
      {
        *(_DWORD *)(v2 + 4 * v5) = v3;
      }
      v7 += 2;
      v4 = *(_WORD *)v7;
      v5 = *(_WORD *)v7;
    }
    while ( *(_WORD *)v7 );
  }
  result = 0;
  *(_WORD *)(a1 + 2 * v3) = 0;
  return result;
}

//----- (6F7A72DA) --------------------------------------------------------
int __stdcall MCLoadString(int a1, void *Dst, int a3)
{
  LANGID v3; // ax@1

  v3 = GetUserDefaultLangID();
  return CCLoadStringEx(a1, Dst, a3, v3);
}

//----- (6F7A7300) --------------------------------------------------------
HMENU __stdcall MCReloadMenus(LPCWSTR lpNewItem)
{
  LPCWSTR v1; // esi@1
  HMENU v2; // eax@5
  HMENU result; // eax@7
  int v4; // edi@9
  const WCHAR *lpNewItema; // [sp+14h] [bp+8h]@8

  v1 = lpNewItem;
  if ( *((_DWORD *)lpNewItem + 406) )
    DestroyMenu(*((HMENU *)lpNewItem + 406));
  if ( *((_DWORD *)lpNewItem + 407) )
    DestroyMenu(*((HMENU *)lpNewItem + 407));
  v2 = CreatePopupMenu();
  *((_DWORD *)lpNewItem + 406) = v2;
  if ( v2 )
    AppendMenuW(v2, 0, 1u, lpNewItem + 50);
  result = CreatePopupMenu();
  *((_DWORD *)lpNewItem + 407) = result;
  if ( result )
  {
    result = 0;
    lpNewItema = lpNewItem + 142;
    do
    {
      v4 = (int)((char *)result + 1);
      AppendMenuW(*((HMENU *)v1 + 407), 0, (UINT_PTR)((char *)result + 1), lpNewItema);
      lpNewItema += 42;
      result = (HMENU)v4;
    }
    while ( v4 < 12 );
  }
  return result;
}

//----- (6F7A738D) --------------------------------------------------------
int __stdcall MCHandleEraseBkgnd(int a1, HDC hdc)
{
  struct tagRECT rect; // [sp+0h] [bp-10h]@1

  GetClipBox(hdc, &rect);
  FillRectClr(hdc, &rect, *(_DWORD *)(a1 + 1560));
  return 1;
}

//----- (6F7A73C3) --------------------------------------------------------
int __stdcall MCGetDateFormatWithTempYear(int a1, SYSTEMTIME *lpDate, LPCWSTR lpFormat, __int16 a4, LPWSTR lpDateStr, int cchDate)
{
  SYSTEMTIME *v6; // esi@1
  int result; // eax@1
  WORD v8; // bx@2
  SYSTEMTIME *lpDatea; // [sp+14h] [bp+Ch]@1

  v6 = lpDate;
  lpDatea = (SYSTEMTIME *)lpDate->wYear;
  v6->wYear = a4;
  result = GetDateFormatW(*(_DWORD *)(a1 + 4), 0, v6, lpFormat, lpDateStr, cchDate);
  if ( !result )
  {
    v8 = v6->wDay;
    v6->wDay = 28;
    result = GetDateFormatW(*(_DWORD *)(a1 + 4), 0, v6, lpFormat, lpDateStr, cchDate);
    v6->wDay = v8;
  }
  v6->wYear = (unsigned __int16)lpDatea;
  return result;
}

//----- (6F7A742F) --------------------------------------------------------
LRESULT __stdcall MCUpdateEditYear(int a1)
{
  LPARAM lParam; // [sp+4h] [bp-84h]@1

  MCGetDateFormatWithTempYear(a1 + 2212, (SYSTEMTIME *)(a1 + 1684), L"yyyy", *(_WORD *)(a1 + 1684), (LPWSTR)&lParam, 64);
  return SendMessageW(*(HWND *)(a1 + 1536), 0xCu, 0, (LPARAM)&lParam);
}

//----- (6F7A7498) --------------------------------------------------------
COLORREF __stdcall MCInitColorArray(int a1)
{
  COLORREF result; // eax@1

  *(_DWORD *)a1 = g_clrWindow;
  *(_DWORD *)(a1 + 16) = g_clrWindow;
  *(_DWORD *)(a1 + 4) = g_clrWindowText;
  *(_DWORD *)(a1 + 8) = GetSysColor(2);
  *(_DWORD *)(a1 + 12) = GetSysColor(9);
  result = g_clrGrayText;
  *(_DWORD *)(a1 + 20) = g_clrGrayText;
  return result;
}

//----- (6F7A74E0) --------------------------------------------------------
int __stdcall MCOnStyleChanging(int a1, int a2, int a3)
{
  if ( a2 == -16 )
    *(_DWORD *)(a3 + 4) ^= (unsigned __int16)((*(_DWORD *)(a3 + 4) ^ *(_DWORD *)(a1 + 8)) & 0xFE03);
  return 0;
}

//----- (6F7A750F) --------------------------------------------------------
HGDIOBJ __stdcall MCDrawTodayCircle(HGDIOBJ h, HDC hdc, int y1)
{
  int v3; // esi@1
  __int64 v4; // rax@1
  int v5; // ebx@1
  int v6; // ecx@1
  int v7; // edi@1
  HGDIOBJ ha; // [sp+14h] [bp+8h]@1
  int y1a; // [sp+1Ch] [bp+10h]@1

  v3 = y1;
  v4 = *(_DWORD *)(y1 + 8) - *(_DWORD *)y1;
  v5 = *(_DWORD *)y1 + (((signed int)v4 - HIDWORD(v4)) >> 1);
  v6 = *(_DWORD *)(y1 + 4);
  y1a = v6 + 4;
  v7 = v6 + (*(_DWORD *)(v3 + 12) - v6) / 2;
  ha = SelectObject(hdc, *((HGDIOBJ *)h + 387));
  Arc(hdc, *(_DWORD *)v3 + 1, y1a, *(_DWORD *)(v3 + 8), *(_DWORD *)(v3 + 12), v5, y1a, *(_DWORD *)(v3 + 8), v7);
  Arc(
    hdc,
    *(_DWORD *)v3 - 10,
    *(_DWORD *)(v3 + 4) + 1,
    *(_DWORD *)(v3 + 8),
    *(_DWORD *)(v3 + 12),
    *(_DWORD *)(v3 + 8),
    v7,
    *(_DWORD *)v3 + 3,
    y1a);
  return SelectObject(hdc, ha);
}

//----- (6F7A75AD) --------------------------------------------------------
BOOL __stdcall MCInvalidateMonthDays(int a1)
{
  return InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 2004), 0);
}

//----- (6F7A75CF) --------------------------------------------------------
int __stdcall MCGetTodayBtnRect(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int result; // eax@4
  int v5; // edx@5
  __int64 v6; // rax@6

  v2 = *(_DWORD *)(a1 + 2004);
  if ( *(_DWORD *)(a1 + 1608) <= *(_DWORD *)(a1 + 2012) - v2 )
  {
    *(_DWORD *)a2 = v2 + 1;
    v3 = *(_DWORD *)(a1 + 2012);
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 1988) + 1;
    v3 = *(_DWORD *)(a1 + 1996);
  }
  *(_DWORD *)(a2 + 8) = v3 - 1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 2016) - *(_DWORD *)(a1 + 1604);
  result = *(_DWORD *)(a1 + 2016);
  *(_DWORD *)(a2 + 12) = result;
  if ( *(_DWORD *)(a1 + 1844) == 1 )
  {
    result = *(_DWORD *)(a1 + 1996) - *(_DWORD *)(a1 + 1988);
    v5 = *(_DWORD *)(a1 + 1608);
    if ( v5 <= result )
    {
      v6 = *(_DWORD *)(a1 + 2012) - *(_DWORD *)(a1 + 2004) - v5;
      result = (((signed int)v6 - HIDWORD(v6)) >> 1) - 1;
      *(_DWORD *)a2 += result;
      *(_DWORD *)(a2 + 8) -= result;
    }
  }
  return result;
}

//----- (6F7A7667) --------------------------------------------------------
BOOL __stdcall MCPaintArrowBtn(int a1, HDC a2, int a3, int a4)
{
  int v4; // ecx@2
  int v5; // edx@4
  signed int v7; // [sp-4h] [bp-4h]@2

  if ( a3 )
  {
    v7 = 2;
    v4 = a1 + 1848;
  }
  else
  {
    v7 = 3;
    v4 = a1 + 1864;
  }
  v5 = v7;
  if ( *(_BYTE *)(a1 + 2232) & 2 )
  {
    if ( a4 )
      v5 = v7 | 0x4200;
  }
  else
  {
    v5 = v7 | 0x100;
  }
  return DrawFrameControl(a2, (LPRECT)v4, 3u, v5);
}

//----- (6F7A76BB) --------------------------------------------------------
int __stdcall MCGetMonthFormat(int a1, SYSTEMTIME *lpDate, LPWSTR lpDateStr, int cchDate, int a5)
{
  lpDate->wDay = 1;
  *lpDateStr = 0;
  GetDateFormatW(*(_DWORD *)(a1 + 2216), 0, lpDate, (LPCWSTR)(a1 + 244), lpDateStr, cchDate);
  return MCRemoveMarkers((int)lpDateStr, a5);
}

//----- (6F7A7703) --------------------------------------------------------
signed int __stdcall MCIsSelectedDayMoYr(int a1, __int16 a2, __int16 a3, __int16 a4)
{
  signed int v4; // ebx@1
  signed int v5; // eax@1
  signed int v6; // edi@1
  signed int v7; // eax@2
  bool v8; // zf@2
  __int16 v11; // [sp+Ch] [bp-10h]@1
  __int16 v12; // [sp+Eh] [bp-Eh]@1
  __int16 v13; // [sp+12h] [bp-Ah]@1

  v11 = a4;
  v12 = a3;
  v13 = a2;
  v4 = 0;
  v5 = CmpDate((int)&v11, a1 + 1684);
  v6 = v5;
  if ( *(_BYTE *)(a1 + 8) & 2 )
  {
    v7 = CmpDate((int)&v11, a1 + 1700);
    v8 = v6 == 0;
    if ( v6 > 0 )
    {
      if ( v7 < 0 )
        return 4;
      v8 = v6 == 0;
    }
    if ( v8 )
      v4 = 1;
    if ( !v7 )
      v4 |= 2u;
  }
  else if ( !v5 )
  {
    return 3;
  }
  return v4;
}

//----- (6F7A7784) --------------------------------------------------------
BOOL __stdcall MCIsBoldOffsetDay(int a1, char a2, int a3)
{
  return a1 != -2144 && (1 << (a2 - 1)) & *(_DWORD *)(a1 + 4 * a3 + 2144);
}

//----- (6F7A77BB) --------------------------------------------------------
int __stdcall MCRecomputeSizing(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // ebx@1
  int v9; // eax@1
  int v10; // edx@1
  int v11; // ebx@1
  int v12; // eax@1
  int v13; // eax@5
  int v14; // edx@5
  int v15; // ebx@9
  int v16; // eax@9
  int v17; // edx@11
  int v18; // ebx@11
  int v19; // edx@11
  int v20; // esi@13
  int v21; // edi@13
  int v22; // eax@13
  int v23; // ebx@13
  __int64 v24; // rax@13
  int v25; // edi@13
  int v26; // ST10_4@13
  int v27; // ST0C_4@13
  int v28; // ST14_4@13
  int v29; // ST14_4@13
  int result; // eax@13
  int v31; // [sp+1Ch] [bp-4h]@1
  int v32; // [sp+28h] [bp+8h]@1
  signed int v33; // [sp+2Ch] [bp+Ch]@1

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 1592);
  *(_DWORD *)(a1 + 1988) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 1992) = *(_DWORD *)(a2 + 4);
  v5 = a1 + 1996;
  *(_DWORD *)v5 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(v3 + 8) - *(_DWORD *)v3;
  v7 = *(_DWORD *)(v3 + 12) - *(_DWORD *)(v3 + 4);
  v8 = v4 + 6;
  v9 = (v6 - v4) / (v4 + 6);
  v10 = *(_DWORD *)(a1 + 1596);
  v31 = v8;
  v11 = *(_DWORD *)(a1 + 1604);
  ++v9;
  v33 = v9;
  *(_DWORD *)(a1 + 1844) = v9;
  v32 = v10 + 6;
  v12 = (v7 - v10 - v11) / (v10 + 6) + 1;
  *(_DWORD *)(v2 + 1840) = v12;
  if ( v33 < 1 )
    *(_DWORD *)(v2 + 1844) = 1;
  if ( v12 < 1 )
    *(_DWORD *)(v2 + 1840) = 1;
  while ( *(_DWORD *)(v2 + 1844) * *(_DWORD *)(v2 + 1840) > 12 )
  {
    v13 = *(_DWORD *)(v2 + 1840);
    v14 = *(_DWORD *)(v2 + 1844);
    if ( v13 <= v14 )
      *(_DWORD *)(v2 + 1844) = v14 - 1;
    else
      *(_DWORD *)(v2 + 1840) = v13 - 1;
  }
  v15 = v31 * *(_DWORD *)(v2 + 1844) - 6;
  v16 = (v6 - v15) / 2;
  *(_DWORD *)(v2 + 2004) = v16;
  if ( v16 < 0 )
    *(_DWORD *)(v2 + 2004) = 0;
  v17 = v32 * *(_DWORD *)(v2 + 1840);
  *(_DWORD *)(v2 + 2012) = v15 + *(_DWORD *)(v2 + 2004);
  v18 = v17 + *(_DWORD *)(v2 + 1604) - 6;
  v19 = v2 + 2008;
  *(_DWORD *)(v2 + 2008) = (v7 - v18) / 2;
  if ( (v7 - v18) / 2 < 0 )
    *(_DWORD *)v19 = 0;
  v20 = *(_DWORD *)v19;
  v21 = *(_DWORD *)(v2 + 1620);
  v22 = *(_DWORD *)v19 + v18;
  v23 = *(_DWORD *)(v2 + 1612);
  *(_DWORD *)(v2 + 2016) = v22;
  v24 = 2 * *(_DWORD *)(v2 + 1588) - v21;
  LODWORD(v24) = v24 - HIDWORD(v24);
  HIDWORD(v24) = *(_DWORD *)(v2 + 1616);
  LODWORD(v24) = v20 + ((signed int)v24 >> 1);
  v25 = v24 + v21;
  v26 = v24;
  LODWORD(v24) = v23 + *(_DWORD *)(v2 + 2004);
  v27 = v24;
  v28 = HIDWORD(v24) + v24;
  LODWORD(v24) = *(_DWORD *)(v2 + 2012);
  *(_DWORD *)(v2 + 1848) = v27;
  *(_DWORD *)(v2 + 1852) = v26;
  *(_DWORD *)(v2 + 1856) = v28;
  *(_DWORD *)(v2 + 1860) = v25;
  LODWORD(v24) = v24 - v23;
  v29 = v24;
  result = v24 - HIDWORD(v24);
  *(_DWORD *)(v2 + 1864) = result;
  *(_DWORD *)(v2 + 1868) = v26;
  *(_DWORD *)(v2 + 1872) = v29;
  *(_DWORD *)(v2 + 1876) = v25;
  return result;
}

//----- (6F7A7948) --------------------------------------------------------
int __stdcall MCUpdateMonthNamePos(int a1)
{
  HDC v1; // eax@1
  void *v2; // ST10_4@1
  HGDIOBJ v3; // eax@1
  bool v4; // zf@1
  bool v5; // sf@1
  int v6; // esi@2
  int v7; // eax@3
  signed int v8; // edi@3
  int v9; // eax@7
  LONG v10; // ecx@7
  LONG v11; // eax@7
  struct tagSIZE v13; // [sp+Ch] [bp-B4h]@4
  int v14; // [sp+14h] [bp-ACh]@7
  SYSTEMTIME Date; // [sp+18h] [bp-A8h]@1
  HGDIOBJ h; // [sp+28h] [bp-98h]@1
  struct tagSIZE psizl; // [sp+2Ch] [bp-94h]@3
  int v18; // [sp+34h] [bp-8Ch]@1
  HDC hdc; // [sp+38h] [bp-88h]@1
  WCHAR String; // [sp+3Ch] [bp-84h]@3

  v1 = GetDC(*(HWND *)a1);
  v2 = *(void **)(a1 + 1556);
  hdc = v1;
  v3 = SelectObject(v1, v2);
  v18 = 0;
  v4 = *(_DWORD *)(a1 + 1828) == 0;
  v5 = *(_DWORD *)(a1 + 1828) < 0;
  *(_DWORD *)&Date.wYear = *(_DWORD *)(a1 + 1796);
  *(_DWORD *)&Date.wDayOfWeek = *(_DWORD *)(a1 + 1800);
  *(_DWORD *)&Date.wHour = *(_DWORD *)(a1 + 1804);
  h = v3;
  *(_DWORD *)&Date.wSecond = *(_DWORD *)(a1 + 1808);
  if ( !v5 && !v4 )
  {
    v6 = a1 + 2236;
    do
    {
      MCGetMonthFormat(a1, &Date, &String, 64, v6);
      v7 = lstrlenW(&String);
      GetTextExtentPoint32W(hdc, &String, v7, &psizl);
      *(_DWORD *)v6 = (*(_DWORD *)(a1 + 1592) - psizl.cx) / 2;
      v8 = 1;
      do
      {
        v13.cx = 0;
        GetTextExtentPoint32W(hdc, &String, *(_DWORD *)(v6 + 4 * v8), &v13);
        *(_DWORD *)(v6 + 4 * v8++) = v13.cx + *(_DWORD *)v6;
      }
      while ( v8 <= 4 );
      if ( *(_WORD *)(a1 + 2232) & 0x4000 || GetWindowLongW(*(HWND *)a1, -20) & 0x400000 )
      {
        v9 = *(_DWORD *)v6;
        v14 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
        v10 = psizl.cx + 2 * v9 - *(_DWORD *)(v6 + 16);
        *(_DWORD *)(v6 + 4) = psizl.cx + 2 * v9 - *(_DWORD *)(v6 + 12);
        *(_DWORD *)(v6 + 12) = psizl.cx + v9 - v14;
        v11 = psizl.cx + v9 - (*(_DWORD *)(v6 + 8) - v9);
        *(_DWORD *)(v6 + 8) = v10;
        *(_DWORD *)(v6 + 16) = v11;
      }
      ++Date.wMonth;
      if ( Date.wMonth > 0xCu )
      {
        ++Date.wYear;
        Date.wMonth = 1;
      }
      ++v18;
      v6 += 20;
    }
    while ( v18 < *(_DWORD *)(a1 + 1828) );
  }
  SelectObject(hdc, h);
  return ReleaseDC(*(HWND *)a1, hdc);
}

//----- (6F7A7B15) --------------------------------------------------------
void __stdcall MCUpdateDayState(int a1)
{
  int v1; // esi@1
  int v2; // edx@3
  int v3; // eax@3
  int v4; // ebx@3
  int v5; // eax@6
  int v6; // ecx@7
  int v7; // eax@9
  char v8; // [sp+4h] [bp-60h]@6
  LPARAM lParam; // [sp+3Ch] [bp-28h]@6
  __int16 v10; // [sp+48h] [bp-1Ch]@6
  __int16 v11; // [sp+4Ah] [bp-1Ah]@6
  __int16 v12; // [sp+4Eh] [bp-16h]@6
  int v13; // [sp+58h] [bp-Ch]@6
  char *v14; // [sp+5Ch] [bp-8h]@6
  int v15; // [sp+60h] [bp-4h]@3
  int v16; // [sp+6Ch] [bp+8h]@3

  v1 = a1;
  if ( *(_BYTE *)(a1 + 8) & 1 )
  {
    if ( GetParent(*(HWND *)a1) )
    {
      v2 = *(_WORD *)(a1 + 1764);
      v3 = *(_WORD *)(a1 + 1766);
      v4 = *(_DWORD *)(a1 + 1828) + 2;
      v15 = *(_WORD *)(a1 + 1764);
      v16 = v3;
      if ( v4 != *(_DWORD *)(v1 + 2140) || v3 != *(_DWORD *)(v1 + 2132) || v2 != *(_DWORD *)(v1 + 2136) )
      {
        memset(&lParam, 0, 0x24u);
        v11 = v3;
        v12 = 1;
        v14 = &v8;
        v10 = v2;
        v13 = v4;
        CCSendNotify(v1, -747, (LPARAM)&lParam);
        v5 = 0;
        if ( v4 > 0 )
        {
          v6 = v1 + 2144;
          do
          {
            *(_DWORD *)v6 = *(_DWORD *)&v14[4 * v5++];
            v6 += 4;
          }
          while ( v5 < v4 );
        }
        *(_DWORD *)(v1 + 2132) = v16;
        v7 = v15;
        *(_DWORD *)(v1 + 2140) = v4;
        *(_DWORD *)(v1 + 2136) = v7;
      }
    }
  }
}

//----- (6F7A7BE6) --------------------------------------------------------
void __stdcall MCNotifySelChange(int a1, int a2)
{
  bool v2; // zf@3
  char Dst; // [sp+4h] [bp-2Ch]@3
  __int16 v4; // [sp+10h] [bp-20h]@3
  __int16 v5; // [sp+12h] [bp-1Eh]@3
  __int16 v6; // [sp+16h] [bp-1Ah]@3
  __int16 v7; // [sp+20h] [bp-10h]@4
  __int16 v8; // [sp+22h] [bp-Eh]@4
  __int16 v9; // [sp+26h] [bp-Ah]@4

  if ( !(*(_BYTE *)(a1 + 2232) & 0x40) && GetParent(*(HWND *)a1) )
  {
    memset(&Dst, 0, 0x2Cu);
    v4 = *(_WORD *)(a1 + 1684);
    v5 = *(_WORD *)(a1 + 1686);
    v2 = (*(_BYTE *)(a1 + 8) & 2) == 0;
    v6 = *(_WORD *)(a1 + 1690);
    if ( !v2 )
    {
      v7 = *(_WORD *)(a1 + 1700);
      v8 = *(_WORD *)(a1 + 1702);
      v9 = *(_WORD *)(a1 + 1706);
    }
    CCSendNotify(a1, a2, (LPARAM)&Dst);
  }
}

//----- (6F7A7C76) --------------------------------------------------------
int __stdcall MCGetOffsetForYrMo(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a3 + 12 * (a2 - *(_WORD *)(a1 + 1796)) - *(_WORD *)(a1 + 1798);
  if ( result < 0 || result >= *(_DWORD *)(a1 + 1828) )
    result = -1;
  return result;
}

//----- (6F7A7CAF) --------------------------------------------------------
int __stdcall MCGetRcForMonth(int a1, signed int a2, int a3)
{
  signed int v3; // ecx@1
  int result; // eax@1
  int v5; // edi@1
  int v6; // edi@1
  int v7; // edi@2
  int v8; // esi@4

  v3 = *(_DWORD *)(a1 + 1844);
  result = a2 / v3;
  v5 = *(_DWORD *)(a1 + 2004);
  *(_DWORD *)a3 = v5;
  *(_DWORD *)(a3 + 8) = v5 + *(_DWORD *)(a1 + 1592);
  v6 = *(_DWORD *)(a1 + 2008);
  *(_DWORD *)(a3 + 4) = v6;
  *(_DWORD *)(a3 + 12) = v6 + *(_DWORD *)(a1 + 1596);
  if ( a2 % v3 )
  {
    v7 = a2 % v3 * (*(_DWORD *)(a1 + 1592) + 6);
    *(_DWORD *)a3 += v7;
    *(_DWORD *)(a3 + 8) += v7;
  }
  if ( result )
  {
    v8 = result * (*(_DWORD *)(a1 + 1596) + 6);
    *(_DWORD *)(a3 + 4) += v8;
    *(_DWORD *)(a3 + 12) += v8;
  }
  return result;
}

//----- (6F7A7D27) --------------------------------------------------------
int __stdcall FGetOffsetForPt(int a1, POINT pt, int a3)
{
  int result; // eax@2
  LONG v4; // ecx@3

  if ( PtInRect((const RECT *)(a1 + 2004), pt)
    && (v4 = (pt.x - *(_DWORD *)(a1 + 2004)) / (*(_DWORD *)(a1 + 1592) + 6)
           + *(_DWORD *)(a1 + 1844) * ((pt.y - *(_DWORD *)(a1 + 2008)) / (*(_DWORD *)(a1 + 1596) + 6)),
        v4 < *(_DWORD *)(a1 + 1828)) )
  {
    *(_DWORD *)a3 = v4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A7D9A) --------------------------------------------------------
int __stdcall FGetRowColForRelPt(int a1, POINT pt, int a3, int a4)
{
  int result; // eax@1
  signed int v5; // ecx@2

  result = PtInRect((const RECT *)(a1 + 1928), pt);
  if ( result )
  {
    v5 = pt.y - *(_DWORD *)(a1 + 1932);
    *(_DWORD *)a4 = (pt.x - *(_DWORD *)(a1 + 1928)) / *(_DWORD *)(a1 + 1584);
    *(_DWORD *)a3 = v5 / *(_DWORD *)(a1 + 1588);
    result = 1;
  }
  return result;
}

//----- (6F7A7DF1) --------------------------------------------------------
int __stdcall GetYrMoForOffset(int a1, int a2, int a3, int a4)
{
  unsigned __int16 v4; // cx@1
  int result; // eax@1
  unsigned __int16 v6; // [sp+0h] [bp-10h]@1
  unsigned __int16 v7; // [sp+2h] [bp-Eh]@1
  __int16 v8; // [sp+6h] [bp-Ah]@1

  v8 = 1;
  v4 = *(_WORD *)(a1 + 1798);
  v6 = *(_WORD *)(a1 + 1796);
  v7 = v4;
  IncrSystemTime((int)&v6, (int)&v6, a2, 2);
  *(_DWORD *)a3 = v6;
  result = v7;
  *(_DWORD *)a4 = v7;
  return result;
}

//----- (6F7A7E43) --------------------------------------------------------
int __stdcall FGetDateForPt(int a1, POINT pt, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // edi@1
  int result; // eax@1
  int v9; // ebx@2
  POINT v10; // ST04_8@2
  int v11; // esi@3
  int v12; // eax@12
  __int16 v13; // cx@12
  int v14; // edi@16
  int v15; // edi@17
  int v16; // [sp+4h] [bp-18h]@2
  int v17; // [sp+8h] [bp-14h]@2
  int v18; // [sp+Ch] [bp-10h]@17
  int v19; // [sp+10h] [bp-Ch]@17
  __int16 v20; // [sp+14h] [bp-8h]@12
  int v21; // [sp+18h] [bp-4h]@2

  v7 = a1;
  result = FGetOffsetForPt(a1, pt, (int)&a1);
  if ( !result )
    return result;
  v9 = a1;
  MCGetRcForMonth(v7, a1, (int)&v16);
  pt.x -= v16;
  v10.x = pt.x;
  pt.y -= v17;
  v10.y = pt.y;
  result = FGetRowColForRelPt(v7, v10, (int)&v21, (int)&a1);
  if ( !result )
    return result;
  v11 = 7 * v21 + a1 + *(_DWORD *)(v7 + 4 * v9 + 2076) - *(_DWORD *)(v7 + 4 * v9 + 2020) + 1;
  if ( a4 )
    *(_DWORD *)a4 = v11;
  if ( v11 > 0 )
  {
    if ( v11 <= *(_DWORD *)(v7 + 4 * v9 + 2024) )
      goto LABEL_12;
    if ( v9 >= *(_DWORD *)(v7 + 1828) - 1 )
    {
      ++v9;
      v11 -= *(_DWORD *)(v7 + 4 * v9 + 2020);
      goto LABEL_12;
    }
    return 0;
  }
  if ( v9 )
    return 0;
  v11 += *(_DWORD *)(v7 + 2020);
  v9 = -1;
LABEL_12:
  GetYrMoForOffset(v7, v9, (int)&v20, (int)&a4);
  v12 = a3;
  *(_WORD *)(a3 + 2) = a4;
  v13 = v20;
  *(_WORD *)(v12 + 6) = v11;
  *(_WORD *)v12 = v13;
  if ( a5 )
    *(_DWORD *)a5 = a1;
  if ( a6 )
    *(_DWORD *)a6 = v21;
  v14 = a7;
  if ( a7 )
  {
    *(_DWORD *)a7 = v16;
    v15 = v14 + 4;
    *(_DWORD *)v15 = v17;
    v15 += 4;
    *(_DWORD *)v15 = v18;
    *(_DWORD *)(v15 + 4) = v19;
  }
  return 1;
}

//----- (6F7A7F52) --------------------------------------------------------
signed int __stdcall MCInvalidateDates(int a1, int a2, int a3)
{
  int v3; // ebx@1
  signed int result; // eax@1
  unsigned __int16 v5; // ax@4
  __int16 v6; // ax@7
  int v7; // eax@9
  signed int v8; // ebx@11
  int v9; // ecx@12
  int v10; // ecx@12
  int v11; // edx@16
  LONG v12; // edi@16
  LONG v13; // ecx@16
  HWND v14; // ST04_4@16
  int v15; // [sp+8h] [bp-40h]@15
  int v16; // [sp+Ch] [bp-3Ch]@16
  RECT Rect; // [sp+18h] [bp-30h]@16
  __int16 v18; // [sp+28h] [bp-20h]@7
  __int16 v19; // [sp+2Ah] [bp-1Eh]@7
  __int16 v20; // [sp+2Eh] [bp-1Ah]@9
  unsigned __int16 v21; // [sp+38h] [bp-10h]@4
  unsigned __int16 v22; // [sp+3Ah] [bp-Eh]@4
  unsigned __int16 v23; // [sp+3Eh] [bp-Ah]@6
  signed int v24; // [sp+54h] [bp+Ch]@9

  v3 = a1 + 1780;
  result = CmpDate(a2, a1 + 1780);
  if ( result > 0 )
    return result;
  result = CmpDate(a3, a1 + 1764);
  if ( result < 0 )
    return result;
  if ( CmpDate(a2, a1 + 1764) >= 0 )
  {
    v21 = *(_WORD *)a2;
    v5 = *(_WORD *)(a2 + 6);
    v22 = *(_WORD *)(a2 + 2);
  }
  else
  {
    v21 = *(_WORD *)(a1 + 1764);
    v22 = *(_WORD *)(a1 + 1766);
    v5 = *(_WORD *)(a1 + 1770);
  }
  v23 = v5;
  if ( CmpDate(a3, v3) <= 0 )
  {
    v18 = *(_WORD *)a3;
    v19 = *(_WORD *)(a3 + 2);
    v6 = *(_WORD *)(a3 + 6);
  }
  else
  {
    v18 = *(_WORD *)v3;
    v19 = *(_WORD *)(a1 + 1782);
    v6 = *(_WORD *)(a1 + 1786);
  }
  v20 = v6;
  v7 = MCGetOffsetForYrMo(a1, v21, v22);
  v24 = v7;
  if ( v7 == -1 )
  {
    if ( v22 == *(_WORD *)(a1 + 1766) )
    {
      v24 = 0;
      v8 = v23 - *(_DWORD *)(a1 + 2076) - 1;
      goto LABEL_15;
    }
    v9 = *(_DWORD *)(a1 + 1828);
    v24 = v9 - 1;
    v10 = *(_DWORD *)(a1 + 4 * (v9 - 1) + 2020)
        + *(_DWORD *)(a1 + 4 * v9 + 2020)
        - *(_DWORD *)(a1 + 4 * (v9 - 1) + 2076);
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 4 * v7 + 2020) - *(_DWORD *)(a1 + 4 * v7 + 2076);
  }
  v8 = v10 + v23 - 1;
LABEL_15:
  MCGetRcForMonth(a1, v24, (int)&v15);
  while ( 1 )
  {
    result = CmpDate((int)&v21, (int)&v18);
    if ( result > 0 )
      break;
    v11 = *(_DWORD *)(a1 + 1588);
    v12 = *(_DWORD *)(a1 + 1928) + v15 + v8 % 7 * *(_DWORD *)(a1 + 1584);
    v13 = v16 + *(_DWORD *)(a1 + 1932) + v8 / 7 * *(_DWORD *)(a1 + 1588);
    Rect.right = v12 + *(_DWORD *)(a1 + 1584);
    v14 = *(HWND *)a1;
    Rect.left = v12;
    Rect.top = v13;
    Rect.bottom = v13 + v11;
    InvalidateRect(v14, &Rect, 0);
    IncrSystemTime((int)&v21, (int)&v21, 1, 8);
    ++v8;
    if ( v23 == 1 && v22 != *(_WORD *)(a1 + 1798) && v22 != *(_WORD *)(a1 + 1782) )
    {
      ++v24;
      MCGetRcForMonth(a1, v24, (int)&v15);
      v8 %= 7;
    }
  }
  return result;
}

//----- (6F7A8149) --------------------------------------------------------
int __stdcall MCHandleMultiSelect(int a1, int a2)
{
  __int16 v2; // ax@1
  __int16 v3; // dx@2
  __int16 v4; // di@2
  __int16 v5; // cx@2
  __int16 v6; // ax@2
  int v7; // ebx@4
  __int16 v8; // ax@5
  int v9; // ebx@7
  int v10; // eax@11
  unsigned int v11; // ecx@11
  int result; // eax@16
  __int16 v13; // [sp+Ch] [bp-20h]@2
  __int16 v14; // [sp+Eh] [bp-1Eh]@2
  __int16 v15; // [sp+12h] [bp-1Ah]@2
  __int16 v16; // [sp+1Ch] [bp-10h]@2
  __int16 v17; // [sp+1Eh] [bp-Eh]@2
  __int16 v18; // [sp+22h] [bp-Ah]@2

  v2 = *(_WORD *)(a1 + 2232);
  if ( (char)v2 >= 0 )
  {
    v3 = *(_WORD *)a2;
    v4 = *(_WORD *)(a2 + 2);
    v5 = *(_WORD *)(a2 + 6);
    *(_WORD *)(a1 + 2232) = v2 | 0x180;
    *(_WORD *)(a1 + 1716) = *(_WORD *)(a1 + 1684);
    *(_WORD *)(a1 + 1718) = *(_WORD *)(a1 + 1686);
    *(_WORD *)(a1 + 1722) = *(_WORD *)(a1 + 1690);
    *(_WORD *)(a1 + 1732) = *(_WORD *)(a1 + 1700);
    *(_WORD *)(a1 + 1734) = *(_WORD *)(a1 + 1702);
    v6 = *(_WORD *)(a1 + 1706);
    v16 = v3;
    v17 = v4;
    v18 = v5;
    v13 = v3;
    v14 = v4;
    v15 = v5;
    *(_WORD *)(a1 + 1738) = v6;
    goto LABEL_11;
  }
  if ( *(_WORD *)(a1 + 2232) & 0x100 )
  {
    v7 = a1 + 1684;
    if ( CmpDate(a2, a1 + 1684) < 0 )
    {
      v16 = *(_WORD *)a2;
      v17 = *(_WORD *)(a2 + 2);
      v18 = *(_WORD *)(a2 + 6);
      v13 = *(_WORD *)v7;
      v14 = *(_WORD *)(a1 + 1686);
      v15 = *(_WORD *)(a1 + 1690);
      *(_WORD *)(a1 + 2232) &= 0xFEFFu;
      goto LABEL_11;
    }
    v16 = *(_WORD *)v7;
    v17 = *(_WORD *)(a1 + 1686);
    v18 = *(_WORD *)(a1 + 1690);
    v13 = *(_WORD *)a2;
    v14 = *(_WORD *)(a2 + 2);
    v8 = *(_WORD *)(a2 + 6);
    goto LABEL_9;
  }
  v9 = a1 + 1700;
  if ( CmpDate(a2, a1 + 1700) < 0 )
  {
    v16 = *(_WORD *)a2;
    v17 = *(_WORD *)(a2 + 2);
    v18 = *(_WORD *)(a2 + 6);
    v13 = *(_WORD *)v9;
    v14 = *(_WORD *)(a1 + 1702);
    v8 = *(_WORD *)(a1 + 1706);
LABEL_9:
    v15 = v8;
    goto LABEL_11;
  }
  v16 = *(_WORD *)v9;
  v17 = *(_WORD *)(a1 + 1702);
  v18 = *(_WORD *)(a1 + 1706);
  v13 = *(_WORD *)a2;
  v14 = *(_WORD *)(a2 + 2);
  v15 = *(_WORD *)(a2 + 6);
  *(_WORD *)(a1 + 2232) |= 0x100u;
LABEL_11:
  v10 = DaysBetweenDates((int)&v16, (int)&v13);
  v11 = *(_DWORD *)(a1 + 1664);
  if ( v10 + 1 > v11 )
  {
    if ( *(_BYTE *)(a1 + 2233) & 1 )
      IncrSystemTime((int)&v16, (int)&v13, v11 - 1, 8);
    else
      IncrSystemTime((int)&v13, (int)&v16, 1 - v11, 8);
  }
  if ( CmpDate((int)&v16, a1 + 1684) || (result = CmpDate((int)&v13, a1 + 1700)) != 0 )
  {
    MCInvalidateDates(a1, a1 + 1684, a1 + 1700);
    MCInvalidateDates(a1, (int)&v16, (int)&v13);
    *(_WORD *)(a1 + 1684) = v16;
    *(_WORD *)(a1 + 1686) = v17;
    *(_WORD *)(a1 + 1690) = v18;
    *(_WORD *)(a1 + 1700) = v13;
    *(_WORD *)(a1 + 1702) = v14;
    *(_WORD *)(a1 + 1706) = v15;
    MCNotifySelChange(a1, -749);
    result = UpdateWindow(*(HWND *)a1);
  }
  return result;
}

//----- (6F7A83EF) --------------------------------------------------------
int __stdcall MCGetTitleRcsForOffset(int a1, signed int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // edx@1
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // ecx@1
  int v10; // eax@1
  int v11; // edi@1
  int v12; // ecx@1
  int v13; // ebx@1
  int result; // eax@1
  int v15; // [sp+Ch] [bp-20h]@1
  int v16; // [sp+10h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-10h]@1
  int v18; // [sp+20h] [bp-Ch]@1
  int v19; // [sp+24h] [bp-8h]@1
  int v20; // [sp+28h] [bp-4h]@1

  MCGetRcForMonth(a1, a2, (int)&v15);
  v4 = *(_DWORD *)(a1 + 1588);
  v5 = v15;
  v6 = v16 + v4 / 2;
  v18 = v6;
  v7 = v6 + v4;
  v8 = *(_DWORD *)(20 * (a2 + 112) + a1);
  v20 = v7;
  v9 = *(_DWORD *)(a1 + 1880);
  v17 = v15 + v9 + v8;
  v10 = 20 * a2 + a1;
  v19 = v15 + v9 + *(_DWORD *)(v10 + 2248);
  *(_DWORD *)a3 = v17;
  *(_DWORD *)(a3 + 4) = v18;
  v11 = a3 + 8;
  *(_DWORD *)v11 = v19;
  *(_DWORD *)(v11 + 4) = v20;
  v12 = *(_DWORD *)(v10 + 2244);
  v13 = *(_DWORD *)(a1 + 1880);
  result = v5 + v13 + *(_DWORD *)(v10 + 2252);
  v19 = result;
  *(_DWORD *)a4 = v5 + v13 + v12;
  *(_DWORD *)(a4 + 4) = v18;
  *(_DWORD *)(a4 + 8) = v19;
  *(_DWORD *)(a4 + 12) = v20;
  return result;
}

//----- (6F7A848F) --------------------------------------------------------
int __stdcall MCDPAEnumCallback(void *p, void *pData)
{
  if ( p )
    LocalFree(p);
  return 1;
}

//----- (6F7A84AF) --------------------------------------------------------
void __stdcall MCDPADestroy(HDPA hdpa)
{
  if ( hdpa )
    DPA_DestroyCallback(hdpa, MCDPAEnumCallback, 0);
}

//----- (6F7A84D2) --------------------------------------------------------
BOOL __stdcall MCEnumCalInfoProc(LPWSTR lpSrch)
{
  LPWSTR v1; // eax@1
  void *v2; // esi@1

  v1 = StrDupW(lpSrch);
  v2 = v1;
  if ( v1 )
  {
    if ( DPA_InsertPtr(g_hdpaCal, 0x7FFFFFFF, v1) >= 0 )
      return 1;
    LocalFree(v2);
  }
  MCDPADestroy(g_hdpaCal);
  g_hdpaCal = 0;
  return 0;
}

//----- (6F7A8525) --------------------------------------------------------
HDPA __stdcall MCGetCalInfoDPA(CALID Calendar, CALTYPE CalType)
{
  struct _DPA *v2; // edi@1
  HDPA v3; // edi@1

  v2 = DPA_Create(4);
  EnterCriticalSection(&g_csDll);
  g_hdpaCal = v2;
  EnumCalendarInfoW(MCEnumCalInfoProc, 0x400u, Calendar, CalType);
  v3 = g_hdpaCal;
  g_hdpaCal = 0;
  LeaveCriticalSection(&g_csDll);
  return v3;
}

//----- (6F7A857E) --------------------------------------------------------
void __stdcall MCFreeCalendarInfo(int a1)
{
  MCDPADestroy(*(HDPA *)(a1 + 12));
  MCDPADestroy(*(HDPA *)(a1 + 16));
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
}

//----- (6F7A85A9) --------------------------------------------------------
signed int __stdcall MCGetEraInfo(int a1)
{
  HDPA v1; // eax@1
  HDPA v2; // eax@2
  int v3; // eax@3
  signed int v4; // ecx@4
  signed int v5; // edi@5
  int v6; // ebx@6

  v1 = MCGetCalInfoDPA(*(_DWORD *)a1, 3u);
  *(_DWORD *)(a1 + 12) = v1;
  if ( v1 )
  {
    v2 = MCGetCalInfoDPA(*(_DWORD *)a1, 4u);
    *(_DWORD *)(a1 + 16) = v2;
    if ( v2 )
    {
      v3 = *(_DWORD *)v2;
      if ( v3 )
      {
        v4 = **(_DWORD **)(a1 + 12);
        if ( v3 == v4 )
        {
          v5 = 1;
          if ( v4 <= 1 )
            return 1;
          while ( 1 )
          {
            v6 = StrToIntW(*(LPCWSTR *)(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) + 4 * v5 - 4));
            if ( StrToIntW(*(LPCWSTR *)(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 4) + 4 * v5)) > v6 )
              break;
            ++v5;
            if ( v5 >= **(_DWORD **)(a1 + 12) )
              return 1;
          }
        }
      }
    }
  }
  MCFreeCalendarInfo(a1);
  return 0;
}

//----- (6F7A862E) --------------------------------------------------------
signed int __stdcall MCGetCalendarInfo(int a1)
{
  int v1; // ebx@1
  signed int result; // eax@3
  WCHAR LCData; // [sp+8h] [bp-44h]@1

  v1 = 1;
  if ( GetLocaleInfoW(0x400u, 0x1009u, &LCData, 32) )
    v1 = StrToIntW(&LCData);
  MCFreeCalendarInfo(a1);
  result = 0;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)a1 = v1;
  *(_DWORD *)(a1 + 4) = 1024;
  if ( (unsigned int)v1 > 5 )
  {
    if ( v1 == 7 )
    {
      *(_DWORD *)(a1 + 8) = 543;
    }
    else if ( (unsigned int)v1 <= 8 || (unsigned int)v1 > 0xC )
    {
LABEL_14:
      *(_DWORD *)a1 = 1;
      *(_DWORD *)(a1 + 4) = 1033;
      return result;
    }
  }
  else
  {
    if ( v1 == 5 )
    {
      *(_DWORD *)(a1 + 8) = 2333;
      return result;
    }
    if ( !v1 )
      goto LABEL_14;
    if ( (unsigned int)v1 > 2 )
    {
      if ( (unsigned int)v1 > 4 )
        goto LABEL_14;
      result = MCGetEraInfo(a1);
      if ( !result )
        goto LABEL_14;
    }
  }
  return result;
}

//----- (6F7A86E7) --------------------------------------------------------
int __stdcall MCIsDateStringRTL(WCHAR SrcStr)
{
  signed int v1; // esi@1
  LCID v2; // eax@1
  WORD CharType[2]; // [sp+4h] [bp-4h]@1

  v1 = 0;
  *(_DWORD *)CharType = 0;
  v2 = GetUserDefaultLCID();
  if ( v2 && GetStringTypeExW(v2, 2u, &SrcStr, 1, CharType) && 2 == CharType[0] )
    v1 = 1;
  return v1;
}

//----- (6F7A872A) --------------------------------------------------------
LONG __stdcall SECGetMaxEraLength(int a1, HDC hdc, LPSIZE psizl)
{
  int v3; // eax@1
  int v4; // edi@1
  const WCHAR *v5; // esi@2
  int v6; // eax@2
  LONG i; // [sp+4h] [bp-4h]@1

  v3 = *(_DWORD *)(a1 + 16);
  v4 = 0;
  for ( i = 0; v4 < *(_DWORD *)v3; ++v4 )
  {
    v5 = *(const WCHAR **)(*(_DWORD *)(v3 + 4) + 4 * v4);
    v6 = lstrlenW(*(LPCWSTR *)(*(_DWORD *)(v3 + 4) + 4 * v4));
    if ( GetTextExtentPoint32W(hdc, v5, v6, psizl) && psizl->cx > i )
      i = psizl->cx;
    v3 = *(_DWORD *)(a1 + 16);
  }
  return i;
}

//----- (6F7A8786) --------------------------------------------------------
HLOCAL __stdcall SECDestroy(int a1)
{
  HLOCAL result; // eax@1

  result = *(HLOCAL *)(a1 + 56);
  if ( result )
  {
    result = LocalFree(*(HLOCAL *)(a1 + 56));
    *(_DWORD *)(a1 + 56) = 0;
  }
  return result;
}

//----- (6F7A87AB) --------------------------------------------------------
HGDIOBJ __stdcall SECSetFont(int a1, void *a2)
{
  HGDIOBJ result; // eax@1

  result = a2;
  if ( !a2 )
    result = GetStockObject(17);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (6F7A87CE) --------------------------------------------------------
BOOL __stdcall InvalidateScrollRect(HWND hWnd, int a2, int a3)
{
  const RECT *v3; // eax@2
  struct tagRECT rc; // [sp+0h] [bp-10h]@2

  if ( a3 )
  {
    rc.left = *(_DWORD *)a2;
    rc.top = *(_DWORD *)(a2 + 4);
    rc.right = *(_DWORD *)(a2 + 8);
    rc.bottom = *(_DWORD *)(a2 + 12);
    OffsetRect(&rc, -a3, 0);
    v3 = &rc;
  }
  else
  {
    v3 = (const RECT *)a2;
  }
  return InvalidateRect(hWnd, v3, 1);
}

//----- (6F7A8817) --------------------------------------------------------
int __stdcall SECGetYearValue(int a1, __int16 a2)
{
  int v2; // esi@1
  WCHAR Src; // [sp+4h] [bp-84h]@1

  v2 = 0;
  if ( MCGetDateFormatWithTempYear(a1 + 216, (SYSTEMTIME *)(a1 + 160), L"yyyy", a2, &Src, 64) )
    v2 = StrToIntW(&Src);
  return v2;
}

//----- (6F7A887D) --------------------------------------------------------
int __stdcall SECAdjustByEra(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1

  v2 = *(_WORD *)(a1 + 160);
  v3 = a2 + v2 - SECGetYearValue(a1, *(_WORD *)(a1 + 160));
  if ( SECGetYearValue(a1, v3) == a2 )
    v2 = v3;
  return v2;
}

//----- (6F7A88BC) --------------------------------------------------------
int __stdcall SECAdjustByType(int a1, int a2, unsigned int a3)
{
  int v3; // ecx@1
  int v4; // edi@6
  unsigned int v5; // edi@8
  int v6; // ecx@10

  v3 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 == 2 || v3 == 3 )
  {
    v5 = a3;
    if ( a3 < 0x64 )
    {
      if ( NT5_GetCalendarInfoA(*(_DWORD *)(a1 + 220), *(_DWORD *)(a1 + 216), 536870960, 0, 0, (int)&a3) )
      {
        v6 = a3;
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 224) + 2029;
        if ( (unsigned int)v6 < 0x63 )
          v6 = 99;
      }
      v5 += v6 - v6 % 0x64u;
      if ( v5 > v6 )
        v5 -= 100;
    }
    v4 = v5 - *(_DWORD *)(a1 + 224);
    if ( *(_DWORD *)(a1 + 232) )
      v4 = SECAdjustByEra(a1, v4);
  }
  else if ( v3 != 8 || **(_WORD **)(a2 + 52) != 104 || **(_WORD **)(a2 + 20) < 0xCu )
  {
    v4 = a3;
  }
  else
  {
    v4 = a3;
    if ( a3 < 0xC )
      v4 = a3 + 12;
  }
  return v4;
}

//----- (6F7A898E) --------------------------------------------------------
int __stdcall SECInvalidate(int a1, signed int a2)
{
  signed int v2; // ebx@1
  int result; // eax@9
  int v4; // edi@12
  int v5; // eax@13
  signed int v6; // eax@23
  int v7; // ecx@23
  int v8; // [sp+Ch] [bp-4h]@7
  int i; // [sp+1Ch] [bp+Ch]@12

  v2 = a2;
  v8 = a2 == 4 || a2 == 5 || a2 == 2 || a2 == 3 || a2 == 12 || a2 == 1;
  result = 0;
  if ( *(_DWORD *)(a1 + 112) && (unsigned int)(a2 - 1) <= 5 )
    v2 = 12;
  v4 = *(_DWORD *)(a1 + 60);
  for ( i = 0; i < *(_DWORD *)(a1 + 36); result = i )
  {
    v5 = *(_DWORD *)v4;
    if ( v2 == *(_DWORD *)v4 || v5 == 12 || v2 == 12 || v2 == 7 && v5 == 8 || v2 == 8 && v5 == 7 )
      InvalidateScrollRect(**(HWND **)a1, v4 + 4, *(_DWORD *)(a1 + 28));
    if ( v8 && *(_DWORD *)v4 == 6 )
    {
      v6 = GetDaysForMonth(*(_WORD *)(a1 + 40), *(_WORD *)(a1 + 42));
      v7 = *(_DWORD *)(v4 + 20);
      *(_DWORD *)(v4 + 28) = v6;
      if ( *(_WORD *)v7 > (unsigned int)v6 )
        *(_WORD *)v7 = v6;
      SECInvalidate(a1, 6);
    }
    v4 += 60;
    ++i;
  }
  return result;
}

//----- (6F7A8A63) --------------------------------------------------------
int __stdcall SECGetEraName(int a1, int a2, __int16 a3, LPWSTR lpDateStr, int cchDate)
{
  return MCGetDateFormatWithTempYear(a1 + 96, (SYSTEMTIME *)(a1 + 40), *(LPCWSTR *)(a2 + 52), a3, lpDateStr, cchDate);
}

//----- (6F7A8A90) --------------------------------------------------------
int __stdcall SECIncrementEra(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v6; // [sp+10h] [bp-108h]@1
  WCHAR String2; // [sp+14h] [bp-104h]@10
  WCHAR String1; // [sp+94h] [bp-84h]@1

  v3 = **(_DWORD **)(a1 + 112);
  v4 = *(_WORD *)(a1 + 40);
  v6 = **(_DWORD **)(a1 + 112);
  SECGetEraName(a1, a2, *(_WORD *)(a1 + 40), &String1, 64);
  if ( String1 )
  {
    v3 = 0;
    if ( v6 <= 0 )
    {
LABEL_11:
      v4 += a3;
      goto LABEL_12;
    }
    while ( lstrcmpW(&String1, *(LPCWSTR *)(*(_DWORD *)(*(_DWORD *)(a1 + 112) + 4) + 4 * v3)) )
    {
      ++v3;
      if ( v3 >= v6 )
        goto LABEL_11;
    }
  }
  if ( a3 <= 0 )
  {
    if ( v3 >= v6 )
      goto LABEL_12;
LABEL_10:
    v4 = StrToIntW(*(LPCWSTR *)(*(_DWORD *)(*(_DWORD *)(a1 + 108) + 4) + 4 * v3));
    SECGetEraName(a1, a2, v4, &String2, 64);
    if ( lstrcmpW(&String1, &String2) )
      goto LABEL_12;
    goto LABEL_11;
  }
  --v3;
  if ( v3 >= 0 )
    goto LABEL_10;
LABEL_12:
  if ( (unsigned int)v4 < *(_DWORD *)(a2 + 24) )
    v4 = *(_DWORD *)(a2 + 24);
  if ( (unsigned int)v4 > *(_DWORD *)(a2 + 28) )
    v4 = *(_DWORD *)(a2 + 28);
  return v4;
}

//----- (6F7A8B91) --------------------------------------------------------
signed int __stdcall SECIncrementSubedit(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // esi@3
  signed int v6; // edi@3
  int v7; // ecx@4
  bool v8; // zf@5
  bool v9; // sf@5
  int v10; // eax@10
  int v11; // eax@11
  int v12; // eax@13
  int v13; // ecx@14
  unsigned int v14; // edx@19
  int v15; // ecx@25

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 32);
  if ( v3 < 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 60) + 60 * v3;
  v6 = *(_DWORD *)v5;
  if ( *(_DWORD *)v5 == 12 )
    return 0;
  v7 = a2;
  if ( *(_BYTE *)(v5 + 48) & 1 )
  {
    v8 = a2 == 0;
    v9 = a2 < 0;
    if ( a2 < 0 )
    {
      v7 = -1;
      v8 = 0;
      v9 = 1;
    }
    if ( !v9 && !v8 )
      v7 = 1;
  }
  if ( v6 == 1 )
  {
    v10 = SECIncrementEra(a1, v5, v7);
  }
  else
  {
    v11 = *(_DWORD *)(v5 + 32);
    if ( v11 > 0 )
      v7 *= v11;
    v12 = *(_DWORD *)(v5 + 20);
    if ( !v12 )
      return 0;
    v10 = v7 + *(_WORD *)v12;
    v13 = *(_DWORD *)(v5 + 24);
    while ( 1 )
    {
      while ( v10 < v13 )
      {
        if ( v6 == 2 || v6 == 3 )
        {
          v10 = *(_DWORD *)(v5 + 24);
          goto LABEL_25;
        }
        v10 += *(_DWORD *)(v5 + 28) - v13 + 1;
      }
      v14 = *(_DWORD *)(v5 + 28);
      if ( v10 <= v14 )
        goto LABEL_25;
      if ( v6 == 2 || v6 == 3 )
        break;
      v10 = v10 + v13 - v14 - 1;
      v2 = a1;
    }
    v10 = *(_DWORD *)(v5 + 28);
  }
LABEL_25:
  v15 = *(_DWORD *)(v5 + 20);
  if ( *(_WORD *)v15 != v10 )
  {
    *(_WORD *)v15 = v10;
    SECInvalidate(v2, *(_DWORD *)v5);
    return 1;
  }
  return 0;
}

//----- (6F7A8C61) --------------------------------------------------------
signed int __stdcall SECIsNumeric(int a1)
{
  signed int result; // eax@2
  int v2; // eax@3
  signed int v3; // ecx@3
  bool v4; // zf@3
  bool v5; // sf@3
  unsigned __int8 v6; // of@3
  int v7; // eax@5

  switch ( *(_DWORD *)a1 )
  {
    case 2:
    case 3:
    case 6:
    case 8:
    case 9:
    case 0xA:
      result = 1;
      break;
    case 4:
      v2 = lstrlenW(*(LPCWSTR *)(a1 + 52));
      v3 = 0;
      v6 = __OFSUB__(v2, 2);
      v4 = v2 == 2;
      v5 = v2 - 2 < 0;
      goto LABEL_4;
    case 5:
      v7 = lstrlenW(*(LPCWSTR *)(a1 + 52));
      v3 = 0;
      v6 = __OFSUB__(v7, 4);
      v4 = v7 == 4;
      v5 = v7 - 4 < 0;
LABEL_4:
      LOBYTE(v3) = v5 ^ v6 | v4;
      result = v3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (6F7A8CDD) --------------------------------------------------------
int __stdcall SECSubeditFromPt(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@2

  result = *(_DWORD *)(a1 + 36) - 1;
  if ( result >= 0 )
  {
    v4 = 60 * result + *(_DWORD *)(a1 + 60) + 4;
    do
    {
      if ( !*(_DWORD *)(v4 + 52) && a2 >= *(_DWORD *)v4 )
        break;
      --result;
      v4 -= 60;
    }
    while ( result >= 0 );
  }
  return result;
}

//----- (6F7A8D15) --------------------------------------------------------
int __stdcall SECGetSystemtime(int a1, int a2)
{
  signed __int64 v2; // rax@1
  int result; // eax@1
  signed __int64 v4; // rt2@1

  *(_DWORD *)a2 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 52);
  v2 = DowFromDate(a2) + 1;
  v4 = v2 % 7;
  result = v2 / 7;
  *(_WORD *)(a2 + 4) = v4;
  return result;
}

//----- (6F7A8D49) --------------------------------------------------------
signed int __stdcall SECSetSystemtime(int a1, int a2)
{
  *(_DWORD *)(a1 + 160) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 164) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a2 + 12);
  return 1;
}

//----- (6F7A8D6E) --------------------------------------------------------
HLOCAL __stdcall DPNcCreateHandler(HWND hWnd)
{
  HLOCAL v1; // eax@1
  HLOCAL v2; // esi@1

  SetWindowBits(hWnd, -20, 512, 512);
  v1 = LocalAlloc(0x40u, 0x12Cu);
  v2 = v1;
  if ( v1 )
    SetWindowLongW(hWnd, 0, (LONG)v1);
  return v2;
}

//----- (6F7A8DB0) --------------------------------------------------------
LONG __stdcall DPDestroyHandler(HWND hWnd, HLOCAL hMem, int a3, int a4)
{
  if ( hMem )
  {
    SECDestroy((int)((char *)hMem + 120));
    MCFreeCalendarInfo((int)((char *)hMem + 216));
    LocalFree(hMem);
  }
  return SetWindowLongW(hWnd, 0, 0);
}

//----- (6F7A8DF0) --------------------------------------------------------
int __stdcall DPOnStyleChanging(int a1, int a2, int a3)
{
  if ( a2 == -16 )
    *(_DWORD *)(a3 + 4) ^= (unsigned __int16)((*(_DWORD *)(a3 + 4) ^ *(_DWORD *)(a1 + 8)) & 0xFFC3);
  return 0;
}

//----- (6F7A8E1F) --------------------------------------------------------
LONG __stdcall _RecomputeMonthCalRect(int a1, int a2, int a3)
{
  bool v3; // zf@1
  HMONITOR v4; // eax@4
  char *v5; // esi@4
  int v6; // esi@6
  LONG v7; // eax@9
  LONG result; // eax@10
  LONG v9; // esi@11
  struct tagMONITORINFO mi; // [sp+Ch] [bp-48h]@1
  struct tagPOINT Points; // [sp+34h] [bp-20h]@1
  LONG v12; // [sp+3Ch] [bp-18h]@1
  LONG v13; // [sp+40h] [bp-14h]@1
  RECT rc; // [sp+44h] [bp-10h]@1

  rc.left = *(_DWORD *)a2;
  rc.top = *(_DWORD *)(a2 + 4);
  mi.cbSize = 0;
  rc.right = *(_DWORD *)(a2 + 8);
  rc.bottom = *(_DWORD *)(a2 + 12);
  Points.x = *(_DWORD *)a3;
  Points.y = *(_DWORD *)(a3 + 4);
  v12 = *(_DWORD *)(a3 + 8);
  v13 = *(_DWORD *)(a3 + 12);
  v3 = (*(_BYTE *)(a1 + 8) & 0x20) == 0;
  memset(&mi.rcMonitor, 0, 0x24u);
  if ( v3 )
    rc.right = v12 + rc.left - Points.x;
  else
    rc.left = rc.right + Points.x - v12;
  rc.bottom = rc.top + v13 - Points.y;
  v4 = MonitorFromRect(&rc, 2u);
  mi.cbSize = 40;
  GetMonitorInfoW(v4, &mi);
  v5 = (char *)&mi.rcMonitor;
  if ( !(GetWindowLongW(*(HWND *)a1, -20) & 8) )
    v5 = (char *)&mi.rcWork;
  Points.x = *(_DWORD *)v5;
  v6 = (int)(v5 + 4);
  Points.y = *(_DWORD *)v6;
  v6 += 4;
  v12 = *(_DWORD *)v6;
  v13 = *(_DWORD *)(v6 + 4);
  if ( rc.right > v12 )
  {
    rc.left -= rc.right - v12;
    rc.right -= rc.right - v12;
  }
  if ( rc.left < Points.x )
  {
    v7 = Points.x - rc.left;
    rc.left = Points.x;
    rc.right += v7;
  }
  result = rc.bottom;
  if ( rc.bottom > v13 )
  {
    Points.x = *(_DWORD *)(a1 + 256);
    Points.y = *(_DWORD *)(a1 + 260);
    v12 = *(_DWORD *)(a1 + 264);
    v13 = *(_DWORD *)(a1 + 268);
    v9 = rc.bottom - rc.top;
    MapWindowPoints(*(HWND *)a1, 0, &Points, 2u);
    rc.bottom = Points.y;
    result = Points.y - v9;
    rc.top = Points.y - v9;
  }
  *(_OWORD *)a2 = rc;
  return result;
}

//----- (6F7A8F23) --------------------------------------------------------
HWND __stdcall DPNotifyDateChange(int a1)
{
  HWND result; // eax@1
  int v2; // esi@4
  int v3; // esi@6
  int v4; // ST04_4@6
  LPARAM lParam; // [sp+8h] [bp-20h]@1
  char v6; // [sp+Ch] [bp-1Ch]@1
  int v7; // [sp+14h] [bp-14h]@3
  char v8; // [sp+18h] [bp-10h]@7
  int v9; // [sp+1Ch] [bp-Ch]@11
  int v10; // [sp+20h] [bp-8h]@11
  int v11; // [sp+24h] [bp-4h]@11

  lParam = 0;
  memset(&v6, 0, 0x1Cu);
  result = *(HWND *)(a1 + 296);
  if ( !((unsigned __int8)result & 8) )
  {
    if ( (unsigned __int8)result & 0x40 )
    {
      v2 = a1 + 72;
      if ( CmpSystemtime(a1 + 160, a1 + 72) < 0 || (v2 = a1 + 88, CmpSystemtime(a1 + 160, a1 + 88) > 0) )
      {
        *(_DWORD *)(a1 + 160) = *(_DWORD *)v2;
        v3 = v2 + 4;
        *(_DWORD *)(a1 + 164) = *(_DWORD *)v3;
        v3 += 4;
        *(_DWORD *)(a1 + 168) = *(_DWORD *)v3;
        v4 = *(_DWORD *)a1;
        *(_DWORD *)(a1 + 172) = *(_DWORD *)(v3 + 4);
        InvalidateRect((HWND)v4, 0, 1);
        SECInvalidate(a1 + 120, 12);
      }
      v7 = 0;
      SECGetSystemtime(a1 + 120, (int)&v8);
    }
    else
    {
      v7 = 1;
    }
    result = (HWND)CmpSystemtime(a1 + 104, (int)&v8);
    if ( result )
    {
      MyNotifyWinEvent(32780, *(_DWORD *)a1, 0, 0);
    }
    else if ( *(_DWORD *)(a1 + 28) >= 5 )
    {
      return result;
    }
    *(_DWORD *)(a1 + 104) = *(_DWORD *)&v8;
    *(_DWORD *)(a1 + 108) = v9;
    *(_DWORD *)(a1 + 112) = v10;
    *(_DWORD *)(a1 + 116) = v11;
    result = CCSendNotify(a1, -759, (LPARAM)&lParam);
  }
  return result;
}

//----- (6F7A8FF3) --------------------------------------------------------
signed int __stdcall DPSetDate(int a1, int a2, int a3)
{
  int v3; // edi@1

  v3 = a2;
  if ( CmpSystemtime(a2, a1 + 72) < 0 )
  {
    if ( !a3 )
      return 0;
    v3 = a1 + 72;
  }
  if ( CmpSystemtime(a1 + 88, v3) < 0 )
  {
    if ( !a3 )
      return 0;
    v3 = a1 + 88;
  }
  if ( a3 )
  {
    *(_WORD *)(a1 + 160) = *(_WORD *)v3;
    *(_WORD *)(a1 + 162) = *(_WORD *)(v3 + 2);
    *(_WORD *)(a1 + 166) = *(_WORD *)(v3 + 6);
LABEL_11:
    SECInvalidate(a1 + 120, 12);
    DPNotifyDateChange(a1);
    return 1;
  }
  if ( SECSetSystemtime(a1, v3) )
    goto LABEL_11;
  return 1;
}

//----- (6F7A9084) --------------------------------------------------------
BOOL __stdcall DPDrawDropdownButton(int a1, HDC a2, int a3)
{
  UINT v3; // ecx@1

  v3 = 1;
  if ( a3 )
    v3 = 16897;
  if ( !(*(_BYTE *)(a1 + 296) & 1) )
    v3 |= 0x100u;
  return DrawFrameControl(a2, (LPRECT)(a1 + 272), 3u, v3);
}

//----- (6F7A90C4) --------------------------------------------------------
signed int __stdcall MCHandleHitTest(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@3
  POINT v4; // ST10_8@15
  int v5; // eax@18
  int v6; // eax@19
  RECT rc; // [sp+4h] [bp-34h]@3
  RECT v9; // [sp+14h] [bp-24h]@11
  RECT v10; // [sp+24h] [bp-14h]@11
  __int16 v11; // [sp+34h] [bp-4h]@11

  v2 = a2;
  if ( a2 && *(_DWORD *)a2 == 32 )
  {
    *(_DWORD *)(a2 + 12) = 0;
    v3 = a1;
    MCGetTodayBtnRect(a1, (int)&rc);
    if ( !PtInRect(&rc, *(POINT *)(v2 + 4)) || *(_BYTE *)(v3 + 8) & 0x10 )
    {
      *(_WORD *)(v3 + 2232) ^= (*(_WORD *)(v3 + 2232) ^ 8 * PtInRect((const RECT *)(v3 + 1848), *(POINT *)(v2 + 4))) & 8;
      if ( *(_WORD *)(v3 + 2232) & 8 )
      {
        *(_DWORD *)(v2 + 12) = 33619971;
      }
      else if ( PtInRect((const RECT *)(v3 + 1864), *(POINT *)(v2 + 4)) )
      {
        *(_DWORD *)(v2 + 12) = 16842755;
      }
      else if ( FGetOffsetForPt(v3, *(POINT *)(v2 + 4), (int)&a2) )
      {
        MCGetRcForMonth(v3, a2, (int)&v9);
        v10.right = *(_DWORD *)(v2 + 4) - v9.left;
        v10.bottom = *(_DWORD *)(v2 + 8) - v9.top;
        GetYrMoForOffset(v3, a2, (int)&v11, (int)&a1);
        *(_WORD *)(v2 + 18) = a1;
        *(_WORD *)(v2 + 16) = v11;
        if ( *(_BYTE *)(v3 + 8) & 4 && PtInRect((const RECT *)(v3 + 1912), *(POINT *)&v10.right) )
        {
          *(_DWORD *)(v2 + 12) |= 0x20003u;
          *(_DWORD *)(v2 + 4) += *(_DWORD *)(v3 + 1928);
          FGetDateForPt(v3, *(POINT *)(v2 + 4), v2 + 16, 0, 0, 0, 0);
        }
        else if ( PtInRect((const RECT *)(v3 + 1896), *(POINT *)&v10.right) )
        {
          *(_DWORD *)(v2 + 12) |= 0x20002u;
          v4.y = *(_DWORD *)(v3 + 1932);
          v4.x = v10.right;
          FGetRowColForRelPt(v3, v4, (int)&a1, (int)&a2);
          *(_WORD *)(v2 + 20) = a2;
        }
        else
        {
          if ( !PtInRect((const RECT *)(v3 + 1928), *(POINT *)&v10.right) )
          {
            *(_DWORD *)(v2 + 12) |= 0x10000u;
            MCGetTitleRcsForOffset(v3, a2, (int)&v9, (int)&v10);
            if ( PtInRect(&v9, *(POINT *)(v2 + 4)) )
            {
              *(_DWORD *)(v2 + 12) |= 0x10001u;
            }
            else if ( PtInRect(&v10, *(POINT *)(v2 + 4)) )
            {
              *(_DWORD *)(v2 + 12) |= 0x10002u;
            }
            return *(_DWORD *)(v2 + 12);
          }
          *(_DWORD *)(v2 + 12) |= 0x20000u;
          if ( FGetDateForPt(v3, *(POINT *)(v2 + 4), v2 + 16, (int)&a1, 0, 0, 0) )
          {
            *(_DWORD *)(v2 + 12) |= 0x20001u;
            v5 = *(_DWORD *)(v2 + 12);
            if ( a1 > 0 )
            {
              if ( a1 <= *(_DWORD *)(v3 + 4 * a2 + 2024) )
                return *(_DWORD *)(v2 + 12);
              v6 = v5 | 0x1000000;
            }
            else
            {
              v6 = v5 | 0x2000000;
            }
            *(_DWORD *)(v2 + 12) = v6;
            return *(_DWORD *)(v2 + 12);
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(v2 + 12) = 196608;
    }
    return *(_DWORD *)(v2 + 12);
  }
  return -1;
}

//----- (6F7A930C) --------------------------------------------------------
LONG __stdcall MCNcCreateHandler(HWND hWnd)
{
  LONG result; // eax@1

  result = (LONG)LocalAlloc(0x40u, 0x9ACu);
  if ( result )
  {
    SetWindowLongW(hWnd, 0, result);
    result = 1;
  }
  return result;
}

//----- (6F7A933A) --------------------------------------------------------
LRESULT __stdcall MCNcDestroyHandler(HWND hWnd, HLOCAL hMem, WPARAM wParam, LPARAM lParam)
{
  void *v4; // eax@2

  if ( hMem )
  {
    v4 = (void *)*((_DWORD *)hMem + 387);
    if ( v4 )
      DeleteObject(v4);
    if ( *((_DWORD *)hMem + 389) )
      DeleteObject(*((HGDIOBJ *)hMem + 389));
    if ( *((_DWORD *)hMem + 406) )
      DestroyMenu(*((HMENU *)hMem + 406));
    if ( *((_DWORD *)hMem + 407) )
      DestroyMenu(*((HMENU *)hMem + 407));
    if ( *((_DWORD *)hMem + 458) )
      KillTimer(*(HWND *)hMem, *((_DWORD *)hMem + 458));
    if ( *((_DWORD *)hMem + 459) )
      KillTimer(*(HWND *)hMem, *((_DWORD *)hMem + 459));
    MCFreeCalendarInfo((int)((char *)hMem + 2212));
    LocalFree(hMem);
  }
  SetWindowLongW(hWnd, 0, 0);
  return DefWindowProcW(hWnd, 0x82u, wParam, lParam);
}

//----- (6F7A93EB) --------------------------------------------------------
void __stdcall MCUpdateToday(int a1)
{
  int v1; // eax@2
  signed int v2; // ecx@4

  if ( !(*(_BYTE *)(a1 + 8) & 8) )
  {
    v1 = MCGetOffsetForYrMo(a1, *(_WORD *)(a1 + 1668), *(_WORD *)(a1 + 1670));
    if ( v1 >= 0 )
    {
      *(_WORD *)(a1 + 2232) |= 0x20u;
      v2 = *(_DWORD *)(a1 + 4 * v1 + 2020) - *(_DWORD *)(a1 + 4 * v1 + 2076) + *(_WORD *)(a1 + 1674) - 1;
      *(_DWORD *)(a1 + 1944) = v1;
      *(_DWORD *)(a1 + 1948) = v2 / 7;
      *(_DWORD *)(a1 + 1952) = v2 % 7;
    }
    else
    {
      *(_WORD *)(a1 + 2232) &= 0xFFDFu;
    }
  }
}

//----- (6F7A9467) --------------------------------------------------------
int __stdcall FUpdateRcDayCur(int a1, POINT pt)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edx@5
  int v5; // ebx@5
  int v6; // eax@5
  int v7; // edi@5
  int v8; // ecx@5
  int v9; // ecx@5
  int v10; // [sp+4h] [bp-24h]@1
  int v11; // [sp+8h] [bp-20h]@5
  int v12; // [sp+14h] [bp-14h]@1
  int v13; // [sp+24h] [bp-4h]@1

  v2 = a1;
  if ( FGetDateForPt(a1, pt, (int)&v12, 0, (int)&a1, (int)&v13, (int)&v10)
    && CmpDate((int)&v12, v2 + 1632) >= 0
    && CmpDate((int)&v12, v2 + 1648) <= 0 )
  {
    v4 = *(_DWORD *)(v2 + 1584);
    v5 = v11;
    v6 = v10 + *(_DWORD *)(v2 + 1928) + a1 * *(_DWORD *)(v2 + 1584);
    v7 = *(_DWORD *)(v2 + 1588);
    v8 = *(_DWORD *)(v2 + 1932) + v13 * *(_DWORD *)(v2 + 1588);
    *(_DWORD *)(v2 + 1956) = v6;
    v9 = v5 + v8;
    *(_DWORD *)(v2 + 1960) = v9;
    *(_DWORD *)(v2 + 1964) = v4 + v6;
    *(_DWORD *)(v2 + 1968) = v7 + v9;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7A951C) --------------------------------------------------------
int __stdcall MCGetRcForDay(int a1, signed int a2, int a3, int a4)
{
  int v4; // esi@1
  signed int v5; // edi@1
  int v6; // eax@1
  int v7; // edi@1
  int v8; // edx@1
  int result; // eax@1
  int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1

  v4 = a1;
  v5 = a2;
  MCGetRcForMonth(a1, a2, (int)&v10);
  v6 = (*(_DWORD *)(v4 + 4 * v5 + 2020) - *(_DWORD *)(v4 + 4 * v5 + 2076) + a3 - 1) / 7;
  v7 = v10
     + *(_DWORD *)(v4 + 1928)
     + (*(_DWORD *)(v4 + 4 * v5 + 2020) - *(_DWORD *)(v4 + 4 * v5 + 2076) + a3 - 1) % 7 * *(_DWORD *)(v4 + 1584);
  *(_DWORD *)a4 = v7;
  v8 = v11 + *(_DWORD *)(v4 + 1932) + v6 * *(_DWORD *)(v4 + 1588);
  *(_DWORD *)(a4 + 4) = v8;
  *(_DWORD *)(a4 + 8) = v7 + *(_DWORD *)(a1 + 1584);
  result = *(_DWORD *)(a1 + 1588) + v8;
  *(_DWORD *)(a4 + 12) = result;
  return result;
}

//----- (6F7A959F) --------------------------------------------------------
signed int __stdcall MCSetToday(int a1, int a2)
{
  int v2; // ebx@2
  signed int result; // eax@4
  struct _SYSTEMTIME SystemTime; // [sp+Ch] [bp-20h]@2
  RECT Rect; // [sp+1Ch] [bp-10h]@5

  if ( a2 )
  {
    v2 = a1;
    *(_DWORD *)&SystemTime.wYear = *(_DWORD *)a2;
    *(_DWORD *)&SystemTime.wDayOfWeek = *(_DWORD *)(a2 + 4);
    *(_DWORD *)&SystemTime.wHour = *(_DWORD *)(a2 + 8);
    *(_DWORD *)&SystemTime.wSecond = *(_DWORD *)(a2 + 12);
    *(_WORD *)(v2 + 2232) |= 0x400u;
  }
  else
  {
    GetLocalTime(&SystemTime);
    v2 = a1;
    *(_WORD *)(v2 + 2232) &= 0xFBFFu;
  }
  result = CmpDate((int)&SystemTime, v2 + 1668);
  if ( result )
  {
    MCGetRcForDay(v2, *(_DWORD *)(v2 + 1944), *(_WORD *)(v2 + 1674), (int)&Rect);
    InvalidateRect(*(HWND *)v2, &Rect, 0);
    *(_OWORD *)(v2 + 1668) = SystemTime;
    MCUpdateToday(v2);
    MCGetRcForDay(v2, *(_DWORD *)(v2 + 1944), *(_WORD *)(v2 + 1674), (int)&Rect);
    InvalidateRect(*(HWND *)v2, &Rect, 0);
    if ( !(*(_BYTE *)(v2 + 8) & 0x10) )
    {
      MCGetTodayBtnRect(v2, (int)&Rect);
      InvalidateRect(*(HWND *)v2, &Rect, 0);
    }
    result = UpdateWindow(*(HWND *)v2);
  }
  return result;
}

//----- (6F7A967F) --------------------------------------------------------
char *__stdcall SEGetTimeDateFormat(int a1, int a2, STRSAFE_LPWSTR pszDest, size_t cchDest)
{
  int v4; // ecx@1
  char *result; // eax@2
  int v6; // eax@3
  int v7; // eax@5
  wchar_t pszSrc; // [sp+Ah] [bp-10Eh]@3
  WCHAR DateStr; // [sp+Ch] [bp-10Ch]@2
  LPARAM lParam; // [sp+6Ch] [bp-ACh]@15
  char Dst; // [sp+70h] [bp-A8h]@15
  int v12; // [sp+78h] [bp-A0h]@15
  char v13; // [sp+7Ch] [bp-9Ch]@15
  STRSAFE_LPCWSTR v14; // [sp+8Ch] [bp-8Ch]@15
  char v15; // [sp+90h] [bp-88h]@15

  *pszDest = 0;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 5 )
  {
    result = (char *)GetDateFormatW(
                       *(_DWORD *)(a2 + 100),
                       0,
                       (const SYSTEMTIME *)(a2 + 40),
                       *(LPCWSTR *)(a1 + 52),
                       &DateStr,
                       131);
    if ( (signed int)result >= 2 )
    {
      v6 = GetDateFormatW(*(_DWORD *)(a2 + 100), 0, (const SYSTEMTIME *)(a2 + 40), L"dd", 0, 0);
      result = (char *)StringCchCopyW(pszDest, cchDest, &pszSrc + v6);
    }
  }
  else if ( v4 != 3 || (v7 = *(_DWORD *)(a2 + 32), v7 != -2) && a1 != *(_DWORD *)(a2 + 60) + 60 * v7 )
  {
    if ( (unsigned int)(v4 - 1) > 5 )
    {
      if ( v4 == 12 )
      {
        lParam = 0;
        memset(&Dst, 0, 0xA0u);
        v12 = *(_DWORD *)(a1 + 52);
        SECGetSystemtime(a2, (int)&v13);
        v14 = (STRSAFE_LPCWSTR)&v15;
        CCSendNotify(*(_DWORD *)a2, -743, (LPARAM)&lParam);
        StringCchCopyW(pszDest, cchDest, v14);
        result = *(char **)a2;
        if ( !(*(_BYTE *)(*(_DWORD *)a2 + 16) & 1) )
        {
          if ( v14 )
          {
            result = &v15;
            if ( (char *)v14 != &v15 )
              result = (char *)LocalFree((HLOCAL)v14);
          }
        }
      }
      else
      {
        result = (char *)GetTimeFormatW(
                           0x400u,
                           0,
                           (const SYSTEMTIME *)(a2 + 40),
                           *(LPCWSTR *)(a1 + 52),
                           pszDest,
                           cchDest);
      }
    }
    else
    {
      result = (char *)GetDateFormatW(
                         *(_DWORD *)(a2 + 100),
                         0,
                         (const SYSTEMTIME *)(a2 + 40),
                         *(LPCWSTR *)(a1 + 52),
                         pszDest,
                         cchDest);
      if ( *(_DWORD *)a1 == 1 && cchDest >= 2 && !*pszDest )
      {
        *pszDest = 32;
        result = 0;
        pszDest[1] = 0;
      }
    }
  }
  else
  {
    result = (char *)GetDateFormatW(*(_DWORD *)(a2 + 100), 0, (const SYSTEMTIME *)(a2 + 40), L"yyyy", pszDest, cchDest);
  }
  return result;
}

//----- (6F7A984B) --------------------------------------------------------
int __stdcall SECRecomputeSizing(int a1, int a2)
{
  int v2; // eax@1
  int v3; // eax@1
  HDC v4; // eax@1
  void *v5; // ST0C_4@1
  HGDIOBJ v6; // eax@1
  int v7; // esi@1
  bool v8; // zf@1
  bool v9; // sf@1
  signed int v10; // ecx@2
  signed int v11; // eax@2
  LONG v12; // eax@15
  int v13; // ecx@21
  unsigned __int8 v14; // of@21
  int v15; // eax@24
  int v16; // eax@26
  LONG v17; // eax@26
  LONG v18; // ecx@33
  int v19; // eax@33
  int v20; // eax@33
  int v21; // ecx@33
  int v22; // eax@33
  int v23; // eax@33
  int v25; // [sp+Ch] [bp-158h]@21
  int v26; // [sp+10h] [bp-154h]@21
  int v27; // [sp+14h] [bp-150h]@21
  int v28; // [sp+18h] [bp-14Ch]@21
  LPARAM lParam; // [sp+1Ch] [bp-148h]@20
  int v30; // [sp+20h] [bp-144h]@20
  int v31; // [sp+24h] [bp-140h]@20
  int v32; // [sp+28h] [bp-13Ch]@20
  struct tagSIZE v33; // [sp+2Ch] [bp-138h]@20
  HGDIOBJ h; // [sp+34h] [bp-130h]@1
  int v35; // [sp+38h] [bp-12Ch]@1
  LPCWSTR lpString; // [sp+3Ch] [bp-128h]@3
  int v37; // [sp+40h] [bp-124h]@1
  int v38; // [sp+44h] [bp-120h]@1
  struct tagSIZE psizl; // [sp+48h] [bp-11Ch]@2
  HDC hdc; // [sp+50h] [bp-114h]@1
  int v41; // [sp+54h] [bp-110h]@16
  int v42; // [sp+58h] [bp-10Ch]@2
  int v43; // [sp+5Ch] [bp-108h]@2
  wchar_t pszDest; // [sp+60h] [bp-104h]@4

  v2 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 8);
  v35 = v2;
  v3 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 12);
  v4 = GetDC(*(HWND *)v3);
  v5 = *(void **)(a1 + 8);
  hdc = v4;
  v6 = SelectObject(v4, v5);
  v7 = *(_DWORD *)(a1 + 60);
  v8 = *(_DWORD *)(a1 + 36) == 0;
  v9 = *(_DWORD *)(a1 + 36) < 0;
  h = v6;
  v38 = 0;
  v37 = v7;
  if ( !v9 && !v8 )
  {
    do
    {
      v10 = *(_DWORD *)v7;
      psizl.cx = 0;
      psizl.cy = 0;
      v43 = *(_DWORD *)(v7 + 24);
      v42 = *(_DWORD *)(v7 + 28);
      v11 = 11;
      if ( v10 == 11 )
      {
        lpString = *(LPCWSTR *)(v7 + 52);
      }
      else
      {
        lpString = &pszDest;
        if ( v10 == 1 )
        {
          if ( *(_DWORD *)(a1 + 112) )
          {
            v12 = SECGetMaxEraLength(a1 + 96, hdc, &psizl);
            goto LABEL_16;
          }
          v11 = **(_WORD **)(v7 + 20);
          v42 = **(_WORD **)(v7 + 20);
          goto LABEL_18;
        }
        if ( v10 > 1 )
        {
          if ( v10 <= 3 )
            goto LABEL_11;
          if ( v10 != 6 )
          {
            if ( v10 == 7 )
            {
              v42 = 12;
            }
            else
            {
              if ( v10 <= 7 || v10 > 10 )
                goto LABEL_19;
LABEL_11:
              v11 = v42;
            }
LABEL_18:
            v43 = v11;
            goto LABEL_19;
          }
          v43 = 10;
          v42 = 17;
        }
      }
LABEL_19:
      if ( v10 != 12 )
      {
        v13 = v43;
        v41 = 0;
        v25 = *(_DWORD *)(a1 + 40);
        v26 = *(_DWORD *)(a1 + 44);
        v27 = *(_DWORD *)(a1 + 48);
        v28 = *(_DWORD *)(a1 + 52);
        *(_WORD *)(a1 + 46) = 1;
        v14 = __OFSUB__(v13, v42);
        v8 = v13 == v42;
        v9 = v13 - v42 < 0;
        *(_WORD *)(a1 + 42) = 1;
        if ( (unsigned __int8)(v9 ^ v14) | v8 )
        {
          while ( 1 )
          {
            v15 = v37;
            if ( *(_DWORD *)v37 != 11 )
            {
              **(_WORD **)(v37 + 20) = v13;
              SEGetTimeDateFormat(v15, a1, &pszDest, 0x80u);
            }
            v16 = lstrlenW(lpString);
            v17 = GetTextExtentPoint32W(hdc, lpString, v16, &psizl);
            if ( v17 )
              v17 = psizl.cx;
            else
              psizl.cx = 0;
            if ( v17 > v41 )
              v41 = v17;
            ++v43;
            if ( v43 > v42 )
              break;
            LOWORD(v13) = v43;
          }
        }
        *(_DWORD *)(a1 + 40) = v25;
        *(_DWORD *)(a1 + 44) = v26;
        *(_DWORD *)(a1 + 48) = v27;
        *(_DWORD *)(a1 + 52) = v28;
        v7 = v37;
        goto LABEL_33;
      }
      lParam = 0;
      v30 = 0;
      v31 = 0;
      v32 = 0;
      v33 = 0i64;
      *(_QWORD *)&v32 = *(_DWORD *)(v7 + 52);
      CCSendNotify(*(_DWORD *)a1, -742, (LPARAM)&lParam);
      v12 = v33.cx;
      psizl = v33;
LABEL_16:
      v41 = v12;
LABEL_33:
      v18 = psizl.cy;
      v19 = *(_DWORD *)(a2 + 4) + 2;
      *(_DWORD *)(v7 + 8) = v19;
      v20 = v18 + v19;
      v21 = v41;
      *(_DWORD *)(v7 + 16) = v20;
      v22 = v35;
      *(_DWORD *)(v7 + 4) = v35;
      v23 = v21 + v22;
      ++v38;
      *(_DWORD *)(v7 + 12) = v23;
      v35 = v23;
      v7 += 60;
      v14 = __OFSUB__(v38, *(_DWORD *)(a1 + 36));
      v9 = v38 - *(_DWORD *)(a1 + 36) < 0;
      v37 = v7;
    }
    while ( v9 ^ v14 );
  }
  SelectObject(hdc, h);
  return ReleaseDC(**(HWND **)a1, hdc);
}

//----- (6F7A9B1B) --------------------------------------------------------
int __stdcall SECParseFormat(int a1, int a2, STRSAFE_LPCWSTR pszSrc)
{
  bool v3; // zf@1
  void *v4; // edi@1
  WORD *v5; // esi@6
  WORD v6; // ax@7
  WORD v7; // ax@12
  size_t v8; // ebx@24
  unsigned int v9; // esi@24
  int result; // eax@24
  int v11; // edi@24
  int v12; // eax@27
  int v13; // ecx@27
  int v14; // esi@27
  LPCWSTR v15; // ebx@27
  int v16; // ecx@28
  const WCHAR *v17; // edx@29
  const WCHAR *v18; // eax@30
  int v19; // eax@31
  int v20; // edx@32
  int v21; // edi@36
  int v22; // eax@44
  int v23; // edx@44
  WORD v24; // dx@77
  signed int v25; // edx@100
  int v26; // edi@110
  const WCHAR *v27; // edx@111
  const WCHAR *v28; // eax@112
  const WCHAR v29; // si@112
  signed int v30; // edx@114
  int v31; // eax@114
  HWND **v32; // esi@119
  char v33; // [sp+Ch] [bp-164h]@116
  int v34; // [sp+48h] [bp-128h]@30
  int v35; // [sp+4Ch] [bp-124h]@28
  int v36; // [sp+50h] [bp-120h]@1
  int v37; // [sp+54h] [bp-11Ch]@1
  int v38; // [sp+58h] [bp-118h]@1
  LPCWSTR lpString; // [sp+5Ch] [bp-114h]@1
  int v40; // [sp+60h] [bp-110h]@6
  int v41; // [sp+64h] [bp-10Ch]@6
  int v42; // [sp+68h] [bp-108h]@1
  wchar_t pszDest; // [sp+6Ch] [bp-104h]@5

  v37 = 0;
  v36 = 0;
  v3 = (*(_DWORD *)(a1 + 296) & 0x100) == 0;
  v4 = (void *)pszSrc;
  v38 = a1;
  v42 = a2;
  lpString = pszSrc;
  if ( !v3 && (*(_BYTE *)(a1 + 8) & 0xC) == 12 )
    v36 = 1;
  if ( *(_BYTE *)(a2 + 116) & 1 )
  {
    StringCchCopyW(&pszDest, 0x80u, pszSrc);
    v4 = &pszDest;
    lpString = &pszDest;
  }
  v5 = (WORD *)v4;
  v41 = 0;
  v40 = 0;
  if ( *(_WORD *)v4 )
  {
    do
    {
      v3 = StrChrW(L"gyMdthHmsX", *v5) == 0;
      v6 = *v5;
      if ( v3 )
      {
        if ( v6 == 39 )
        {
          do
          {
            ++v5;
            v7 = *v5;
            if ( !*v5 )
              break;
            do
            {
              if ( v7 == 39 )
                break;
              ++v5;
              v7 = *v5;
            }
            while ( *v5 );
            if ( !*v5 )
              break;
            ++v5;
          }
          while ( *v5 == 39 );
        }
        else
        {
          while ( v6 && v6 != 39 && !StrChrW(L"gyMdthHmsX", v6) )
          {
            ++v5;
            v6 = *v5;
          }
        }
        ++v41;
      }
      else
      {
        do
          ++v5;
        while ( v6 == *v5 );
        ++v41;
        if ( v6 == 77 )
          v40 += 2;
      }
    }
    while ( *v5 );
  }
  v8 = 60 * v41;
  v9 = 4 * ((unsigned int)(2 * (v41 + v40 + lstrlenW((LPCWSTR)v4)) + 5) >> 2);
  result = (int)LocalAlloc(0x40u, v9 + 60 * v41);
  v11 = result;
  if ( result )
  {
    if ( *(_DWORD *)(v42 + 56) )
      LocalFree(*(HLOCAL *)(v42 + 56));
    v12 = v42;
    *(_DWORD *)(v42 + 32) = -1;
    *(_WORD *)(v12 + 64) = 0;
    v13 = v41;
    v14 = v11 + v9;
    *(_DWORD *)(v12 + 56) = v11;
    *(_DWORD *)(v12 + 60) = v14;
    *(_DWORD *)(v12 + 36) = v13;
    memset((void *)v14, 0, v8);
    *(_DWORD *)(v38 + 296) &= 0xFFFFFDFF;
    v15 = lpString;
    if ( *(_BYTE *)(v42 + 116) & 1 )
    {
      v35 = lstrlenW(lpString);
      v16 = 0;
      v41 = 0;
      v40 = v35 / 2;
      if ( v35 / 2 > 0 )
      {
        v17 = &lpString[v35 - 1];
        do
        {
          v18 = &lpString[v16];
          v34 = *v18;
          *v18 = *v17;
          v16 = v41 + 1;
          *v17 = v34;
          --v17;
          v41 = v16;
        }
        while ( v16 < v40 );
      }
    }
    v19 = v42;
    if ( *lpString )
    {
      do
      {
        *(_DWORD *)(v14 + 48) = 1;
        LOWORD(v20) = *v15;
        if ( *v15 == 121 || (_WORD)v20 == 103 )
        {
          v20 = (unsigned __int16)v20;
          v40 = v20;
          if ( (_WORD)v20 == 103 && !*(_DWORD *)(v19 + 112) )
            *(_DWORD *)(v14 + 56) = 1;
          *(_DWORD *)(v14 + 24) = 1752;
          *(_DWORD *)(v14 + 28) = 9999;
          *(_DWORD *)(v14 + 52) = v11;
          *(_DWORD *)(v14 + 36) = 0;
          *(_DWORD *)v14 = ((_WORD)v20 == 121) + 1;
          v19 = v42;
          *(_DWORD *)(v14 + 20) = v42 + 40;
          while ( *v15 == (_WORD)v40 )
          {
            ++*(_DWORD *)(v14 + 36);
            *(_WORD *)v11 = *v15;
            v11 += 2;
            ++v15;
          }
          if ( *(_DWORD *)v14 != 2 )
            goto LABEL_106;
          v3 = v36 == 0;
          *(_DWORD *)(v14 + 48) = 2;
          if ( !v3 )
          {
            *(_DWORD *)(v14 + 52) = L"yyyy";
LABEL_105:
            *(_DWORD *)(v14 + 36) = 4;
            goto LABEL_106;
          }
          v25 = *(_DWORD *)(v14 + 36);
          if ( v25 > 0 )
          {
            if ( v25 <= 2 )
            {
              *(_DWORD *)v14 = 3;
            }
            else if ( v25 != 3 )
            {
              goto LABEL_106;
            }
            goto LABEL_105;
          }
        }
        else if ( (_WORD)v20 == 77 )
        {
          v3 = v37 == 0;
          *(_DWORD *)(v14 + 52) = v11;
          if ( v3 )
          {
            *(_DWORD *)v14 = 4;
          }
          else
          {
            *(_DWORD *)v14 = 5;
            *(_WORD *)v11 = 100;
            v21 = v11 + 2;
            *(_WORD *)v21 = 100;
            v11 = v21 + 2;
          }
          *(_DWORD *)(v14 + 20) = v19 + 42;
          *(_DWORD *)(v14 + 24) = 1;
          *(_DWORD *)(v14 + 28) = 12;
          *(_DWORD *)(v14 + 36) = 2;
          while ( *v15 == 77 )
          {
            *(_WORD *)v11 = 77;
            v11 += 2;
            ++v15;
          }
          if ( (signed int)((v11 - *(_DWORD *)(v14 + 52)) & 0xFFFFFFFE) <= 4 )
            *(_DWORD *)(v14 + 48) = 2;
        }
        else
        {
          if ( (_WORD)v20 == 100 )
          {
            v22 = v42;
            v23 = v42 + 46;
            *(_DWORD *)v14 = 6;
            *(_DWORD *)(v14 + 20) = v23;
            *(_DWORD *)(v14 + 24) = 1;
            v37 = 1;
            *(_DWORD *)(v14 + 28) = GetDaysForMonth(*(_WORD *)(v22 + 40), *(_WORD *)(v22 + 42));
            *(_DWORD *)(v14 + 36) = 2;
            *(_DWORD *)(v14 + 52) = v11;
            while ( *v15 == 100 )
            {
              *(_WORD *)v11 = 100;
              v11 += 2;
              ++v15;
            }
            if ( (signed int)((v11 - *(_DWORD *)(v14 + 52)) & 0xFFFFFFFE) > 4 )
              *(_DWORD *)(v14 + 56) = 1;
            else
              *(_DWORD *)(v14 + 48) = 2;
            *(_WORD *)v11 = 0;
            v19 = v42;
            v11 += 2;
            goto LABEL_108;
          }
          switch ( (_WORD)v20 )
          {
            case 0x74:
              *(_DWORD *)(v38 + 296) |= 0x200u;
              *(_DWORD *)(v14 + 24) = 0;
              *(_DWORD *)v14 = 7;
              *(_DWORD *)(v14 + 20) = v19 + 48;
              *(_DWORD *)(v14 + 28) = 23;
              *(_DWORD *)(v14 + 32) = 12;
              *(_DWORD *)(v14 + 36) = 2;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 116 )
              {
                *(_WORD *)v11 = 116;
                v11 += 2;
                ++v15;
              }
              break;
            case 0x68:
              *(_DWORD *)(v14 + 24) = 0;
              *(_DWORD *)v14 = 8;
              *(_DWORD *)(v14 + 20) = v19 + 48;
              *(_DWORD *)(v14 + 28) = 23;
              *(_DWORD *)(v14 + 36) = 2;
              *(_DWORD *)(v14 + 48) = 2;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 104 )
              {
                *(_WORD *)v11 = 104;
                v11 += 2;
                ++v15;
              }
              break;
            case 0x48:
              *(_DWORD *)(v14 + 24) = 0;
              *(_DWORD *)v14 = 8;
              *(_DWORD *)(v14 + 20) = v19 + 48;
              *(_DWORD *)(v14 + 28) = 23;
              *(_DWORD *)(v14 + 36) = 2;
              *(_DWORD *)(v14 + 48) = 2;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 72 )
              {
                *(_WORD *)v11 = 72;
                v11 += 2;
                ++v15;
              }
              break;
            case 0x6D:
              *(_DWORD *)(v14 + 24) = 0;
              *(_DWORD *)v14 = 9;
              *(_DWORD *)(v14 + 20) = v19 + 50;
              *(_DWORD *)(v14 + 28) = 59;
              *(_DWORD *)(v14 + 36) = 2;
              *(_DWORD *)(v14 + 48) = 2;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 109 )
              {
                *(_WORD *)v11 = 109;
                v11 += 2;
                ++v15;
              }
              break;
            case 0x73:
              *(_DWORD *)(v14 + 24) = 0;
              *(_DWORD *)v14 = 10;
              *(_DWORD *)(v14 + 20) = v19 + 52;
              *(_DWORD *)(v14 + 28) = 59;
              *(_DWORD *)(v14 + 36) = 2;
              *(_DWORD *)(v14 + 48) = 2;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 115 )
              {
                *(_WORD *)v11 = 115;
                v11 += 2;
                ++v15;
              }
              break;
            case 0x58:
              *(_DWORD *)v14 = 12;
              *(_DWORD *)(v14 + 52) = v11;
              while ( *v15 == 88 )
              {
                *(_WORD *)v11 = 88;
                v11 += 2;
                ++v15;
              }
              break;
            default:
              *(_DWORD *)v14 = 11;
              *(_DWORD *)(v14 + 56) = 1;
              if ( (_WORD)v20 != 39 )
              {
                if ( !*(_WORD *)(v19 + 64) )
                  *(_WORD *)(v19 + 64) = *v15;
                *(_DWORD *)(v14 + 52) = v11;
                while ( *v15 && *v15 != 39 && !StrChrW(L"gyMdthHmsX", *v15) )
                {
                  *(_WORD *)v11 = *v15;
                  v11 += 2;
                  ++v15;
                }
                *(_WORD *)v11 = 0;
                v19 = v42;
                goto LABEL_107;
              }
              *(_DWORD *)(v14 + 52) = v11;
              while ( 1 )
              {
                ++v15;
                v24 = *v15;
                if ( !*v15 )
                  break;
                do
                {
                  if ( v24 == 39 )
                    break;
                  ++v15;
                  *(_WORD *)v11 = v24;
                  v24 = *v15;
                  v11 += 2;
                }
                while ( *v15 );
                if ( !*v15 )
                  break;
                ++v15;
                if ( *v15 != 39 )
                  break;
                *(_WORD *)v11 = 39;
                v11 += 2;
              }
              break;
          }
        }
LABEL_106:
        *(_WORD *)v11 = 0;
LABEL_107:
        v11 += 2;
LABEL_108:
        v14 += 60;
      }
      while ( *v15 );
    }
    if ( *(_BYTE *)(v19 + 116) & 1 )
    {
      v26 = 0;
      v40 = v35 / 2;
      if ( v35 / 2 > 0 )
      {
        v27 = &lpString[v35 - 1];
        do
        {
          v28 = &lpString[v26];
          v29 = *v28;
          *v28 = *v27;
          *v27 = v29;
          ++v26;
          --v27;
        }
        while ( v26 < v40 );
      }
    }
    if ( *(_BYTE *)(v42 + 116) & 2 )
    {
      v30 = *(_DWORD *)(v42 + 36);
      v31 = *(_DWORD *)(v42 + 60);
      if ( v30 > 1 && *(_DWORD *)v31 == 7 )
      {
        qmemcpy(&v33, (const void *)v31, 0x3Cu);
        if ( v30 - 1 > 0 )
          qmemcpy((void *)v31, (const void *)(v31 + 60), 4 * ((unsigned int)(60 * (v30 - 1)) >> 2));
        qmemcpy((void *)(60 * *(_DWORD *)(v42 + 36) + v31 - 60), &v33, 0x3Cu);
      }
    }
    v32 = (HWND **)v42;
    SECRecomputeSizing(v42, v42 + 12);
    InvalidateRect(**v32, 0, 1);
    MyNotifyWinEvent(32780, *(_DWORD *)v38, 0, 0);
    result = 1;
  }
  return result;
}

//----- (6F7AA22F) --------------------------------------------------------
HWND __stdcall SECSetSubeditValue(int a1, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // ecx@1
  HWND result; // eax@4
  int v9; // [sp+14h] [bp+8h]@1

  v4 = a1;
  v5 = SECAdjustByType(a1, a2, a3);
  v6 = *(_DWORD *)(a2 + 20);
  v7 = *(_WORD *)v6;
  *(_WORD *)v6 = v5;
  v9 = v7;
  if ( (unsigned int)v5 < *(_DWORD *)(a2 + 24)
    || (unsigned int)v5 > *(_DWORD *)(a2 + 28)
    || CmpSystemtime(v4 + 160, v4 + 72) < 0
    || (result = (HWND)CmpSystemtime(v4 + 160, v4 + 88), (signed int)result > 0) )
  {
    result = *(HWND *)(a2 + 20);
    *(_WORD *)result = v9;
  }
  else if ( a4 || v5 != v9 )
  {
    SECInvalidate(v4 + 120, 12);
    InvalidateScrollRect(**(HWND **)(v4 + 120), a2 + 4, *(_DWORD *)(v4 + 148));
    result = DPNotifyDateChange(v4);
  }
  return result;
}

//----- (6F7AA2CB) --------------------------------------------------------
int __stdcall SECSaveResetSubeditEdit(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@2

  result = *(_DWORD *)(a1 + 152);
  if ( result >= 0 )
  {
    result = *(_DWORD *)(a1 + 180) + 60 * result;
    v3 = result;
    if ( *(_DWORD *)(result + 40) )
      result = (int)SECSetSubeditValue(a1, result, *(_DWORD *)(result + 44), 0);
    if ( a2 )
      *(_DWORD *)(v3 + 40) = 0;
  }
  return result;
}

//----- (6F7AA30C) --------------------------------------------------------
STRSAFE_LPWSTR __stdcall SECFormatSubed(int a1, int a2, STRSAFE_LPWSTR pszDest, size_t cchDest)
{
  STRSAFE_LPWSTR v4; // esi@2

  if ( *(_DWORD *)a2 == 11 )
  {
    v4 = *(STRSAFE_LPWSTR *)(a2 + 52);
  }
  else
  {
    v4 = pszDest;
    SEGetTimeDateFormat(a2, a1, pszDest, cchDest);
  }
  return v4;
}

//----- (6F7AA33B) --------------------------------------------------------
HGDIOBJ __stdcall SECDrawSubedits(HDC hdc, int a2, int a3, int a4)
{
  void *v4; // ST20_4@1
  HDC v5; // esi@1
  HGDIOBJ v6; // eax@1
  int v7; // ST20_4@1
  bool v8; // zf@3
  bool v9; // sf@3
  int v10; // ecx@3
  int v11; // eax@4
  int v12; // esi@11
  wchar_t *v13; // eax@14
  __int16 v14; // di@15
  unsigned __int8 v15; // of@19
  struct tagRECT rc; // [sp+8h] [bp-13Ch]@4
  HGDIOBJ h; // [sp+18h] [bp-12Ch]@1
  int v19; // [sp+1Ch] [bp-128h]@1
  int v20; // [sp+20h] [bp-124h]@3
  int v21; // [sp+24h] [bp-120h]@3
  HDC v22; // [sp+28h] [bp-11Ch]@1
  wchar_t chText; // [sp+2Ch] [bp-118h]@14
  wchar_t pszDest; // [sp+12Ch] [bp-18h]@14

  v4 = *(void **)(a2 + 8);
  v5 = hdc;
  v22 = hdc;
  v6 = SelectObject(hdc, v4);
  v7 = *(_DWORD *)(a2 + 24);
  h = v6;
  IntersectClipRect(hdc, *(_DWORD *)(a2 + 12), *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20), v7);
  SetBkColor(hdc, g_clrHighlight);
  v19 = *(_DWORD *)(a2 + 32);
  if ( !a3 )
    v19 = -1;
  v8 = *(_DWORD *)(a2 + 36) == 0;
  v9 = *(_DWORD *)(a2 + 36) < 0;
  v10 = *(_DWORD *)(a2 + 60);
  v20 = 0;
  v21 = v10;
  if ( !v9 && !v8 )
  {
    do
    {
      v11 = *(_DWORD *)(a2 + 28);
      rc.left = *(_DWORD *)(v21 + 4);
      rc.top = *(_DWORD *)(v21 + 8);
      rc.right = *(_DWORD *)(v21 + 12);
      rc.bottom = *(_DWORD *)(v21 + 16);
      if ( v11 )
        OffsetRect(&rc, -v11, 0);
      if ( a4 )
      {
        if ( v19 == v20 )
        {
          SetBkMode(v22, 2);
          SetTextColor(v22, g_clrHighlightText);
        }
        else
        {
          SetBkMode(v22, 1);
          SetTextColor(v22, g_clrWindowText);
        }
      }
      else
      {
        SetBkMode(v22, 1);
        SetTextColor(v22, g_clrGrayText);
      }
      v12 = v21;
      if ( v20 == *(_DWORD *)(a2 + 32) && *(_DWORD *)(v21 + 40) )
      {
        if ( SECIsNumeric(v21) )
        {
          StringCchPrintfW(&pszDest, 0xAu, L"%%0%dd", *(_DWORD *)(v12 + 40));
          StringCchPrintfW(&chText, 0x80u, &pszDest, *(_DWORD *)(v12 + 44));
          v13 = &chText;
        }
        else
        {
          v14 = **(_WORD **)(v12 + 20);
          v21 = *(_WORD *)(a2 + 46);
          *(_WORD *)(a2 + 46) = 1;
          if ( *(_DWORD *)(v12 + 44) )
            **(_WORD **)(v12 + 20) = *(_WORD *)(v12 + 44);
          v13 = SECFormatSubed(a2, v12, &chText, 0x80u);
          *(_WORD *)(a2 + 46) = v21;
          **(_WORD **)(v12 + 20) = v14;
        }
      }
      else
      {
        v13 = SECFormatSubed(a2, v21, &chText, 0x80u);
      }
      DrawTextW(v22, v13, -1, &rc, *(_DWORD *)(v12 + 48) | 0x820);
      ++v20;
      v15 = __OFSUB__(v20, *(_DWORD *)(a2 + 36));
      v9 = v20 - *(_DWORD *)(a2 + 36) < 0;
      v21 = v12 + 60;
    }
    while ( v9 ^ v15 );
    v5 = v22;
  }
  SelectClipRgn(v5, 0);
  return SelectObject(v5, h);
}

//----- (6F7AA587) --------------------------------------------------------
signed int __stdcall DPHandleLocaleChange(int a1)
{
  signed int result; // eax@1
  int v2; // eax@2
  LCTYPE v3; // [sp-Ch] [bp-114h]@6
  WCHAR *v4; // [sp-8h] [bp-110h]@6
  WCHAR LCData; // [sp+4h] [bp-104h]@6

  result = MCGetCalendarInfo(a1 + 216);
  if ( *(_DWORD *)(a1 + 296) & 0x100 )
  {
    v2 = *(_DWORD *)(a1 + 8) & 0xC;
    if ( v2 )
    {
      if ( v2 == 4 )
      {
        v4 = &LCData;
        v3 = 32;
        goto LABEL_7;
      }
      if ( v2 == 8 )
      {
        v4 = &LCData;
        v3 = 4099;
        goto LABEL_7;
      }
      if ( v2 != 12 )
        return SECParseFormat(a1, a1 + 120, &LCData);
    }
    v4 = &LCData;
    v3 = 31;
LABEL_7:
    GetLocaleInfoW(*(_DWORD *)(a1 + 220), v3, v4, 128);
    return SECParseFormat(a1, a1 + 120, &LCData);
  }
  return result;
}

//----- (6F7AA631) --------------------------------------------------------
int __stdcall DPHandleSetFont(int a1, HANDLE h, int a3)
{
  int result; // eax@1

  SECSetFont(a1 + 120, h);
  SECRecomputeSizing(a1 + 120, a1 + 256);
  result = GetCodePageForFont(h);
  *(_DWORD *)(a1 + 20) = result;
  if ( a3 )
  {
    InvalidateRect(*(HWND *)a1, 0, 1);
    result = UpdateWindow(*(HWND *)a1);
  }
  return result;
}

//----- (6F7AA684) --------------------------------------------------------
unsigned int __stdcall DPPaint(int a1, HDC hdc)
{
  bool v2; // zf@3
  int v3; // eax@5
  UINT v4; // ecx@5
  unsigned int result; // eax@10
  int v6; // ecx@12
  RECT rc; // [sp+4h] [bp-10h]@3

  if ( *(_BYTE *)(a1 + 8) & 2 && RectVisible(hdc, (const RECT *)(a1 + 240)) )
  {
    v2 = (*(_BYTE *)(a1 + 296) & 0x80) == 0;
    rc.left = *(_DWORD *)(a1 + 240);
    rc.top = *(_DWORD *)(a1 + 244);
    rc.right = *(_DWORD *)(a1 + 248);
    rc.bottom = *(_DWORD *)(a1 + 252);
    if ( !v2 )
      DrawFocusRect(hdc, &rc);
    InflateRect(&rc, -1, -1);
    v3 = *(_DWORD *)(a1 + 296);
    v4 = 0;
    if ( v3 & 0x40 )
      v4 = 1024;
    if ( !(v3 & 1) )
      v4 |= 0x100u;
    DrawFrameControl(hdc, &rc, 4u, v4);
  }
  result = *(_DWORD *)(a1 + 296);
  if ( !(result & 0x400) )
  {
    if ( result & 0x40 )
      v6 = result & 1;
    else
      v6 = 0;
    result = (unsigned int)SECDrawSubedits(hdc, a1 + 120, (result >> 2) & 1, v6);
  }
  if ( !(*(_BYTE *)(a1 + 296) & 2) )
  {
    result = RectVisible(hdc, (const RECT *)(a1 + 272));
    if ( result )
      result = DPDrawDropdownButton(a1, hdc, 0);
  }
  return result;
}

//----- (6F7AA764) --------------------------------------------------------
int __stdcall DPRecomputeSizing(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ecx@2
  __int64 v4; // rax@2
  int v5; // eax@2
  int v6; // edi@6
  int v7; // ecx@6
  int v8; // eax@6
  int *v9; // esi@6
  int v10; // ecx@10

  if ( !(*(_BYTE *)(a1 + 8) & 2) )
  {
    *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 252) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 240) = *(_DWORD *)a2;
    v5 = *(_DWORD *)a2 + 1;
    goto LABEL_5;
  }
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 4) + 1;
  *(_DWORD *)(a1 + 252) = *(_DWORD *)(a2 + 12) - 1;
  v2 = *(_DWORD *)(a1 + 252) - *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 240) = *(_DWORD *)a2 + 1;
  v3 = v2 + *(_DWORD *)a2;
  *(_DWORD *)(a1 + 248) = v3;
  v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
  v5 = *(_DWORD *)a2 + (((signed int)v4 - HIDWORD(v4)) >> 1);
  if ( v3 > v5 )
LABEL_5:
    *(_DWORD *)(a1 + 248) = v5;
  *(_DWORD *)(a1 + 272) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 276) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 280) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 284) = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a1 + 280);
  v7 = v6 - GetSystemMetrics(2);
  v8 = *(_DWORD *)(a1 + 248);
  v9 = (int *)(a1 + 272);
  *(_DWORD *)(a1 + 272) = v7;
  if ( v7 < v8 )
    *v9 = v8;
  if ( *(_DWORD *)(a1 + 36) )
    MoveWindow(
      *(HWND *)(a1 + 36),
      *v9,
      *(_DWORD *)(a1 + 276),
      v6 - *v9 + 1,
      *(_DWORD *)(a1 + 284) - *(_DWORD *)(a1 + 276) + 1,
      0);
  *(_DWORD *)(a1 + 260) = *(_DWORD *)(a2 + 4);
  v10 = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 256) = v10 + 1;
  *(_DWORD *)(a1 + 264) = *v9 - 1;
  return SECRecomputeSizing(a1 + 120, a1 + 256);
}

//----- (6F7AA880) --------------------------------------------------------
int __stdcall MCCalcSizes(int a1)
{
  int v1; // esi@1
  HDC v2; // eax@1
  void *v3; // ST14_4@1
  HDC v4; // edi@1
  int v5; // edi@1
  int v6; // edi@1
  HDC v7; // ebx@5
  int v8; // eax@13
  int v9; // edx@13
  int v10; // ecx@13
  int v11; // edi@13
  int v12; // edi@13
  bool v13; // zf@13
  bool v14; // sf@13
  unsigned __int8 v15; // of@13
  int v16; // edi@15
  int v17; // edx@15
  int v18; // ecx@16
  int v19; // ecx@17
  HWND v20; // ST10_4@17
  struct tagRECT Rect; // [sp+Ch] [bp-1B4h]@17
  HGDIOBJ h; // [sp+1Ch] [bp-1A4h]@1
  int v24; // [sp+20h] [bp-1A0h]@6
  int v25; // [sp+24h] [bp-19Ch]@2
  STRSAFE_LPCWSTR pszFormat; // [sp+28h] [bp-198h]@1
  int v27; // [sp+2Ch] [bp-194h]@1
  int v28; // [sp+30h] [bp-190h]@1
  HDC hdc; // [sp+34h] [bp-18Ch]@1
  int v30; // [sp+38h] [bp-188h]@1
  WCHAR DateStr; // [sp+3Ch] [bp-184h]@1
  wchar_t pszDest; // [sp+BCh] [bp-104h]@1

  v1 = a1;
  v2 = GetDC(*(HWND *)a1);
  v3 = *(void **)(a1 + 1556);
  v4 = v2;
  hdc = v2;
  h = SelectObject(v2, v3);
  MGetTextExtent(v4, L"0000", 2, (int)&v27, (int)&v28);
  MGetTextExtent(v4, L"0000", 4, a1 + 1600, 0);
  GetDateFormatW(*(_DWORD *)(v1 + 2216), 1u, (const SYSTEMTIME *)(v1 + 1668), 0, &DateStr, 64);
  StringCchPrintfW(&pszDest, 0x80u, L"%s %s", a1 + 36, &DateStr);
  MGetTextExtent(hdc, &pszDest, -1, v1 + 1608, v1 + 1604);
  *(_DWORD *)(a1 + 1604) += 4;
  *(_DWORD *)(a1 + 1612) = 5 * g_cxBorder;
  v30 = 12;
  *(_DWORD *)(a1 + 1616) = 4 * g_cyHScroll / 3;
  *(_DWORD *)(a1 + 1620) = g_cyHScroll;
  v5 = g_cxVScroll + *(_DWORD *)(v1 + 1612) + *(_DWORD *)(v1 + 1616) + 2 * g_cxBorder;
  pszFormat = (STRSAFE_LPCWSTR)(a1 + 284);
  v6 = 2 * v5;
  do
  {
    StringCchPrintfW(&pszDest, 0x80u, pszFormat, L"0000");
    MGetTextExtent(hdc, &pszDest, -1, (int)&v25, 0);
    v25 = (v6 + v25) / (((*(_DWORD *)(a1 + 8) >> 2) & 1) + 7);
    if ( v25 > v27 )
      v27 = v25;
    pszFormat += 42;
    --v30;
  }
  while ( v30 );
  v7 = hdc;
  SelectObject(hdc, *(HGDIOBJ *)(a1 + 1552));
  hdc = (HDC)(a1 + 1292);
  v30 = 7;
  do
  {
    MGetTextExtent(v7, (LPCWSTR)hdc, -1, (int)&v24, (int)&v25);
    if ( v24 > v27 )
      v27 = v24;
    if ( v25 > v28 )
      v28 = v25;
    hdc = (HDC)((char *)hdc + 22);
    --v30;
  }
  while ( v30 );
  if ( v28 < *(_DWORD *)(a1 + 1620) / 2 )
    v28 = *(_DWORD *)(a1 + 1620) / 2;
  SelectObject(v7, h);
  ReleaseDC(*(HWND *)a1, v7);
  v8 = v27 + 2;
  v9 = v28 + 2;
  v10 = (v27 + 2) * (((*(_DWORD *)(a1 + 8) >> 2) & 1) + 7) + 1;
  v11 = 9 * (v28 + 2) + 1;
  v30 = v11;
  *(_DWORD *)(a1 + 1596) = v11;
  v12 = a1 + 1608;
  *(_DWORD *)v12 += v8 + 12;
  v15 = __OFSUB__(v10, *(_DWORD *)(a1 + 1608));
  v13 = v10 == *(_DWORD *)(a1 + 1608);
  v14 = v10 - *(_DWORD *)(a1 + 1608) < 0;
  *(_DWORD *)(a1 + 1584) = v8;
  *(_DWORD *)(a1 + 1588) = v9;
  *(_DWORD *)(a1 + 1592) = v10;
  if ( !((unsigned __int8)(v14 ^ v15) | v13) )
    *(_DWORD *)v12 = v10;
  v16 = 2 * v9;
  v17 = 3 * v9;
  v13 = (*(_BYTE *)(a1 + 8) & 4) == 0;
  *(_DWORD *)(a1 + 1880) = 0;
  *(_DWORD *)(a1 + 1884) = 0;
  *(_DWORD *)(a1 + 1888) = v10;
  *(_DWORD *)(a1 + 1892) = v16;
  *(_DWORD *)(a1 + 1896) = 0;
  *(_DWORD *)(a1 + 1900) = v16;
  *(_DWORD *)(a1 + 1904) = v10;
  *(_DWORD *)(a1 + 1908) = v17;
  if ( !v13 )
  {
    v18 = v30;
    *(_DWORD *)(a1 + 1912) = 0;
    *(_DWORD *)(a1 + 1916) = v17;
    *(_DWORD *)(a1 + 1920) = v8;
    *(_DWORD *)(a1 + 1924) = v18;
    *(_DWORD *)(a1 + 1896) = v8;
  }
  v19 = *(_DWORD *)(a1 + 1896);
  *(_DWORD *)(a1 + 1936) = v19 + 7 * v8;
  *(_DWORD *)(a1 + 1940) = v30;
  v20 = *(HWND *)a1;
  *(_DWORD *)(a1 + 1928) = v19;
  *(_DWORD *)(a1 + 1932) = v17;
  GetClientRect(v20, &Rect);
  return MCRecomputeSizing(a1, (int)&Rect);
}
// 6F7E69A4: using guessed type int g_cyHScroll;
// 6F7E69A8: using guessed type int g_cxVScroll;

//----- (6F7AABEF) --------------------------------------------------------
HFONT __stdcall MCHandleSetFont(int a1, HANDLE h, int a3)
{
  HANDLE v3; // ebx@1
  HFONT result; // eax@3
  HFONT v5; // [sp+8h] [bp-64h]@3
  char pv; // [sp+Ch] [bp-60h]@3
  int v7; // [sp+1Ch] [bp-50h]@3

  v3 = h;
  if ( !h )
    v3 = GetStockObject(13);
  GetObjectW(v3, 92, &pv);
  v7 = (unsigned __int8)(v7 < 700 ? 0 : 0xC8) + 800;
  result = CreateFontIndirectW((const LOGFONTW *)&pv);
  v5 = result;
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 1556) )
      DeleteObject(*(HGDIOBJ *)(a1 + 1556));
    *(_DWORD *)(a1 + 1552) = v3;
    *(_DWORD *)(a1 + 1556) = v5;
    *(_DWORD *)(a1 + 20) = GetCodePageForFont(v3);
    result = (HFONT)MCCalcSizes(a1);
    if ( a3 )
    {
      InvalidateRect(*(HWND *)a1, 0, 1);
      result = (HFONT)UpdateWindow(*(HWND *)a1);
    }
  }
  return result;
}

//----- (6F7AACAD) --------------------------------------------------------
HGDIOBJ __stdcall MCPaintMonth(HGDIOBJ a1, HDC hdc, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  void *v9; // ST10_4@1
  COLORREF v10; // eax@1
  int v11; // eax@1
  int v12; // eax@1
  int v13; // eax@2
  int v14; // eax@3
  int v15; // eax@3
  signed int v16; // edi@4
  const WCHAR *v17; // esi@5
  int v18; // eax@5
  int v19; // eax@5
  int v20; // eax@6
  int v21; // esi@6
  int v22; // ecx@13
  int v23; // ecx@13
  int v24; // ecx@15
  LONG v25; // ecx@15
  int v26; // ST10_4@16
  int v27; // ST0C_4@16
  signed int v28; // esi@16
  int v29; // edi@17
  int v30; // eax@18
  LONG v31; // ecx@22
  LONG v32; // edx@22
  LONG v33; // eax@22
  HDC v34; // edi@26
  signed int v35; // esi@27
  HGDIOBJ v36; // eax@34
  int v37; // ecx@36
  LONG v38; // eax@38
  int v39; // eax@54
  int v40; // edx@57
  int v41; // eax@59
  bool v42; // zf@59
  COLORREF v43; // eax@59
  int v44; // eax@63
  COLORREF v46; // [sp+Ch] [bp-100h]@1
  COLORREF v47; // [sp+10h] [bp-FCh]@0
  HGDIOBJ v48; // [sp+18h] [bp-F4h]@0
  HGDIOBJ v49; // [sp+1Ch] [bp-F0h]@1
  COLORREF v50; // [sp+20h] [bp-ECh]@1
  SYSTEMTIME Date; // [sp+24h] [bp-E8h]@1
  COLORREF color; // [sp+34h] [bp-D8h]@1
  int v53; // [sp+38h] [bp-D4h]@1
  int v54; // [sp+3Ch] [bp-D0h]@22
  int v55; // [sp+40h] [bp-CCh]@6
  int v56; // [sp+44h] [bp-C8h]@33
  char *v57; // [sp+48h] [bp-C4h]@23
  int v58; // [sp+4Ch] [bp-C0h]@23
  int v59; // [sp+50h] [bp-BCh]@22
  RECT rc; // [sp+54h] [bp-B8h]@23
  int v61; // [sp+64h] [bp-A8h]@12
  int v62; // [sp+68h] [bp-A4h]@7
  int v63; // [sp+6Ch] [bp-A0h]@1
  int v64; // [sp+70h] [bp-9Ch]@6
  HDC v65; // [sp+74h] [bp-98h]@1
  RECT rect; // [sp+78h] [bp-94h]@1
  WCHAR String; // [sp+88h] [bp-84h]@2

  v63 = a3;
  v9 = (void *)*((_DWORD *)a1 + 388);
  Date.wYear = 0;
  *(_DWORD *)&Date.wMonth = 0;
  *(_DWORD *)&Date.wDay = 0;
  *(_DWORD *)&Date.wMinute = 0;
  Date.wMilliseconds = 0;
  v53 = a6;
  color = *((_DWORD *)a1 + 391);
  v50 = *((_DWORD *)a1 + 395);
  v10 = *((_DWORD *)a1 + 393);
  v65 = hdc;
  v46 = v10;
  v49 = SelectObject(hdc, v9);
  SelectObject(hdc, *((HGDIOBJ *)a1 + 386));
  v11 = *(_DWORD *)a3;
  rect.left = *((_DWORD *)a1 + 470);
  rect.top = *((_DWORD *)a1 + 471);
  rect.right = *((_DWORD *)a1 + 472);
  rect.bottom = *((_DWORD *)a1 + 473);
  rect.left += v11;
  rect.right += v11;
  v12 = *(_DWORD *)(a3 + 4);
  rect.top += v12;
  rect.bottom += v12;
  if ( RectVisible(hdc, &rect) )
  {
    FillRectClr(hdc, &rect, *((_DWORD *)a1 + 392));
    SetTextColor(hdc, *((_DWORD *)a1 + 393));
    SelectObject(hdc, *((HGDIOBJ *)a1 + 389));
    Date.wYear = a5;
    Date.wMonth = a4;
    MCGetMonthFormat((int)a1, &Date, &String, 64, 0);
    v13 = lstrlenW(&String);
    DrawTextW(hdc, &String, v13, &rect, 0x925u);
    SelectObject(hdc, *((HGDIOBJ *)a1 + 388));
  }
  SetTextColor(hdc, *((_DWORD *)a1 + 392));
  v14 = *(_DWORD *)v63;
  rect.left = *((_DWORD *)a1 + 474);
  rect.top = *((_DWORD *)a1 + 475);
  rect.right = *((_DWORD *)a1 + 476);
  rect.bottom = *((_DWORD *)a1 + 477);
  rect.left += v14;
  rect.right += v14;
  v15 = *(_DWORD *)(v63 + 4);
  rect.top += v15;
  rect.bottom += v15;
  if ( RectVisible(v65, &rect) )
  {
    v16 = 0;
    MoveToEx(v65, rect.left + 4, rect.bottom - 1, 0);
    LineTo(v65, rect.right - 4, rect.bottom - 1);
    rect.right = rect.left + *((_DWORD *)a1 + 396);
    do
    {
      v17 = (const WCHAR *)((char *)a1 + 22 * ((v16 + *((_DWORD *)a1 + 362)) % 7) + 1292);
      v18 = lstrlenW(v17);
      DrawTextW(v65, v17, v18, &rect, 0x825u);
      v19 = *((_DWORD *)a1 + 396);
      rect.left += v19;
      rect.right += v19;
      ++v16;
    }
    while ( v16 < 7 );
  }
  v20 = *((_DWORD *)a1 + a6 + 519);
  v21 = *((_DWORD *)a1 + a6 + 505);
  v64 = *((_DWORD *)a1 + a6 + 519);
  v55 = v21;
  if ( a8 )
    v62 = 6;
  else
    v62 = (*((_DWORD *)a1 + a6 + 506) - v20 + v21 + 6) / 7;
  if ( v64 == v21 )
  {
    v22 = a6 + 1;
    a6 = v22;
    v23 = *((_DWORD *)a1 + v22 + 505);
    v64 = 1;
    v55 = v23;
    v61 = 1;
  }
  else
  {
    --a4;
    if ( a4 <= 0 )
    {
      --a5;
      a4 = 12;
    }
    ++v64;
    v61 = 0;
  }
  if ( *((_BYTE *)a1 + 8) & 4 )
  {
    v24 = *(_DWORD *)v63;
    rect.left = *((_DWORD *)a1 + 478);
    rect.top = *((_DWORD *)a1 + 479);
    rect.right = *((_DWORD *)a1 + 480);
    rect.bottom = *((_DWORD *)a1 + 481);
    rect.left += v24;
    rect.right += v24;
    v25 = *(_DWORD *)(v63 + 4) + rect.top + v62 * *((_DWORD *)a1 + 397);
    rect.top += *(_DWORD *)(v63 + 4);
    rect.bottom = v25;
    if ( RectVisible(v65, &rect) )
    {
      MoveToEx(v65, rect.right - 1, rect.top + 4, 0);
      LineTo(v65, rect.right - 1, rect.bottom - 4);
      v26 = *((_DWORD *)a1 + 363);
      Date.wYear = a5;
      v27 = *((_DWORD *)a1 + 362);
      Date.wMonth = a4;
      Date.wDay = v64;
      v28 = GetWeekNumber((int)&Date, v27, v26);
      rect.bottom = rect.top + *((_DWORD *)a1 + 397);
      if ( v62 > 0 )
      {
        v29 = v62;
        do
        {
          StringCchPrintfW(&String, 0x40u, L"%d", v28);
          DrawTextW(v65, &String, (v28 > 9) + 1, &rect, 0x925u);
          v30 = *((_DWORD *)a1 + 397);
          rect.top += v30;
          rect.bottom += v30;
          IncrSystemTime((int)&Date, (int)&Date, 1, 4);
          --v29;
          v28 = GetWeekNumber((int)&Date, *((_DWORD *)a1 + 362), *((_DWORD *)a1 + 363));
        }
        while ( v29 );
      }
    }
  }
  if ( v61 )
    SetTextColor(v65, color);
  else
    SetTextColor(v65, v50);
  rect.left = *((_DWORD *)a1 + 482);
  rect.top = *((_DWORD *)a1 + 483);
  rect.right = *((_DWORD *)a1 + 484);
  rect.bottom = *((_DWORD *)a1 + 485);
  v31 = *(_DWORD *)(v63 + 4) + rect.top;
  v32 = *(_DWORD *)v63 + rect.left + *((_DWORD *)a1 + 396);
  rect.left += *(_DWORD *)v63;
  v33 = v31 + *((_DWORD *)a1 + 397);
  rect.top = v31;
  rect.right = v32;
  rect.bottom = v33;
  v54 = 0;
  v63 = 0;
  v59 = 0;
  if ( v62 <= 0 )
    goto LABEL_64;
  do
  {
    rc = rect;
    v58 = 0;
    v57 = (char *)a1 + 4 * a6 + 2020;
    do
    {
      if ( !v61 && !a7 )
      {
        v34 = v65;
        goto LABEL_54;
      }
      v34 = v65;
      if ( RectVisible(v65, &rc) )
      {
        v35 = v64;
        StringCchPrintfW(&String, 0x40u, L"%d", v64);
        if ( *((_BYTE *)a1 + 8) & 1 )
        {
          if ( MCIsBoldOffsetDay((int)a1, v35, a6) )
          {
            if ( !v63 )
            {
              SelectObject(v34, *((HGDIOBJ *)a1 + 389));
              v63 = 1;
            }
          }
          else if ( v63 )
          {
            SelectObject(v34, *((HGDIOBJ *)a1 + 388));
            v63 = 0;
          }
        }
        v56 = MCIsSelectedDayMoYr((int)a1, v35, a4, a5);
        if ( v56 )
        {
          v47 = SetTextColor(v34, v46);
          v48 = SelectObject(v34, (HGDIOBJ)a9);
          v54 = 1;
          v36 = GetStockObject(8);
          SelectObject(v34, v36);
          if ( v56 & 3 )
          {
            Ellipse(v34, rc.left + 2, rc.top + 2, rc.right - 1, rc.bottom - 1);
            if ( v56 == 1 )
            {
              v37 = rc.left + (rc.right - rc.left) / 2;
              goto LABEL_40;
            }
            if ( v56 == 2 )
            {
              v37 = rc.left;
              v38 = rc.left + (rc.right - rc.left) / 2;
              goto LABEL_41;
            }
          }
          else
          {
            v37 = rc.left;
LABEL_40:
            v38 = rc.right;
LABEL_41:
            if ( v37 && v38 )
              Rectangle(v34, v37, rc.top + 2, v38 + 1, rc.bottom - 1);
          }
        }
        DrawTextW(v34, &String, (v35 > 9) + 1, &rc, 0x925u);
        if ( !(*((_BYTE *)a1 + 8) & 8)
          && *((_BYTE *)a1 + 2232) & 0x20
          && v53 == *((_DWORD *)a1 + 486)
          && v58 == *((_DWORD *)a1 + 488)
          && v59 == *((_DWORD *)a1 + 487) )
          MCDrawTodayCircle(a1, v34, (int)&rc);
        if ( v54 )
        {
          SetTextColor(v34, v47);
          SelectObject(v34, v48);
          v54 = 0;
        }
      }
LABEL_54:
      v39 = *((_DWORD *)a1 + 396);
      rc.left += v39;
      rc.right += v39;
      ++v64;
      if ( v64 > v55 )
      {
        if ( !a8 && a6 > v53 )
          return SelectObject(v34, v49);
        v57 += 4;
        v40 = *(_DWORD *)v57;
        ++a6;
        ++a4;
        v64 = 1;
        v55 = v40;
        if ( a4 > 12 )
        {
          ++a5;
          a4 = 1;
        }
        v41 = v61 == 0;
        v61 = v41;
        v42 = v41 == 0;
        v43 = color;
        if ( v42 )
          v43 = v50;
        SetTextColor(v34, v43);
        a7 = a8;
      }
      ++v58;
    }
    while ( v58 < 7 );
    v44 = *((_DWORD *)a1 + 397);
    rect.top += v44;
    rect.bottom += v44;
    ++v59;
  }
  while ( v59 < v62 );
LABEL_64:
  v34 = v65;
  return SelectObject(v34, v49);
}

//----- (6F7AB533) --------------------------------------------------------
int __stdcall MCUpdateRcDayCur(int a1, int a2)
{
  int result; // eax@1

  result = MCGetOffsetForYrMo(a1, *(_WORD *)a2, *(_WORD *)(a2 + 2));
  if ( result >= 0 )
    result = MCGetRcForDay(a1, result, *(_WORD *)(a2 + 6), a1 + 1956);
  return result;
}

//----- (6F7AB571) --------------------------------------------------------
BOOL __stdcall SECSetCurSubed(int a1, int a2)
{
  HWND **v2; // ebx@1
  BOOL result; // eax@1
  int v4; // eax@4
  int v5; // esi@12
  int v6; // eax@12
  LONG v7; // ecx@12
  LONG v8; // eax@12
  struct tagRECT rc; // [sp+8h] [bp-10h]@12

  v2 = (HWND **)(a1 + 120);
  result = *(_DWORD *)(a1 + 152);
  if ( a2 != result )
  {
    if ( result >= 0 )
    {
      SECSaveResetSubeditEdit(a1, 1);
      InvalidateScrollRect(
        **(HWND **)(a1 + 120),
        60 * *(_DWORD *)(a1 + 152) + *(_DWORD *)(a1 + 180) + 4,
        *(_DWORD *)(a1 + 148));
    }
    v4 = *(_DWORD *)(a1 + 152);
    *(_DWORD *)(a1 + 152) = a2;
    if ( v4 == -2
      || v4 >= 0 && *(_DWORD *)(60 * v4 + *(_DWORD *)(a1 + 180)) == 3
      || a2 == -2
      || a2 >= 0 && *(_DWORD *)(60 * a2 + *(_DWORD *)(a1 + 180)) == 3 )
    {
      SECRecomputeSizing(a1 + 120, a1 + 132);
      InvalidateRect(**v2, 0, 1);
    }
    result = *(_DWORD *)(a1 + 152);
    if ( result >= 0 )
    {
      v5 = 60 * result + *(_DWORD *)(a1 + 180) + 4;
      v6 = *(_DWORD *)(a1 + 148);
      rc.left = *(_DWORD *)v5;
      v5 += 4;
      rc.top = *(_DWORD *)v5;
      v5 += 4;
      rc.right = *(_DWORD *)v5;
      rc.bottom = *(_DWORD *)(v5 + 4);
      OffsetRect(&rc, -v6, 0);
      v7 = *(_DWORD *)(a1 + 132);
      v8 = rc.left;
      if ( rc.left < v7 || (v7 = *(_DWORD *)(a1 + 140), v8 = rc.right, rc.right > v7) )
      {
        *(_DWORD *)(a1 + 148) += v8 - v7;
        result = InvalidateRect(**v2, 0, 1);
      }
      else
      {
        result = InvalidateRect(**v2, &rc, 1);
      }
    }
  }
  return result;
}

//----- (6F7AB661) --------------------------------------------------------
signed int __stdcall SECIncrFocus(int a1, int a2)
{
  int v2; // ecx@1
  signed int v3; // esi@1
  signed int v4; // ebx@5
  int v5; // edi@6
  signed int v7; // [sp+18h] [bp+8h]@4

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 152);
  if ( v3 < 0 && a2 < 0 )
    v3 = *(_DWORD *)(a1 + 156);
  v7 = 0;
  if ( *(_DWORD *)(v2 + 156) > 0 )
  {
    v4 = *(_DWORD *)(v2 + 156);
    do
    {
      v5 = a2 + v3;
      v3 = (a2 + v3 + v4) % v4;
      if ( v3 != v5 && *(_DWORD *)(v2 + 124) )
        break;
      if ( !*(_DWORD *)(60 * v3 + *(_DWORD *)(v2 + 180) + 56) )
        goto LABEL_11;
      ++v7;
    }
    while ( v7 < v4 );
  }
  v3 = -1;
LABEL_11:
  SECSetCurSubed(v2, v3);
  return v3;
}

//----- (6F7AB6E5) --------------------------------------------------------
signed int __stdcall SECHandleKeydown(int a1, UINT a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@3
  int v5; // edx@4
  int v7; // eax@20
  int v8; // edx@20
  int v9; // ecx@21
  LPARAM lParam; // [sp+Ch] [bp-28h]@5
  char v11; // [sp+10h] [bp-24h]@5
  struct tagMSG Msg; // [sp+14h] [bp-20h]@5
  int v13; // [sp+30h] [bp-4h]@1

  v13 = 1;
  v3 = a1 + 120;
  if ( a2 == 37 )
  {
    v13 = -1;
    goto LABEL_26;
  }
  if ( a2 == 39 )
  {
LABEL_26:
    SECSaveResetSubeditEdit(a1, 1);
    SECIncrFocus(a1, v13);
    return 0;
  }
  v4 = *(_DWORD *)(a1 + 152);
  if ( v4 >= 0 )
  {
    v5 = 60 * v4 + *(_DWORD *)(a1 + 180);
    if ( *(_DWORD *)v5 == 12 )
    {
      lParam = 0;
      memset(&v11, 0, 0x20u);
      Msg.message = a2;
      Msg.wParam = *(_DWORD *)(v5 + 52);
      SECGetSystemtime(v3, (int)&Msg.lParam);
      CCSendNotify(*(_DWORD *)v3, -744, (LPARAM)&lParam);
      if ( __PAIR__(*(_WORD *)(a1 + 162), *(_WORD *)(a1 + 160)) != Msg.lParam
        || *(_WORD *)(a1 + 166) != HIWORD(Msg.time)
        || __PAIR__(*(_WORD *)(a1 + 170), *(_WORD *)(a1 + 168)) != Msg.pt.x
        || *(_WORD *)(a1 + 172) != LOWORD(Msg.pt.y) )
      {
        *(_DWORD *)(a1 + 160) = Msg.lParam;
        *(_DWORD *)(a1 + 164) = Msg.time;
        *(_DWORD *)(a1 + 168) = Msg.pt.x;
        *(_DWORD *)(a1 + 172) = Msg.pt.y;
        SECInvalidate(v3, 12);
        return 1;
      }
      return 0;
    }
  }
  if ( a2 >= 0x23 )
  {
    if ( a2 <= 0x24 )
    {
      if ( v4 >= 0 )
      {
        SECSaveResetSubeditEdit(a1, 1);
        v7 = *(_DWORD *)(a1 + 180) + 60 * *(_DWORD *)(a1 + 152);
        v8 = **(_WORD **)(v7 + 20);
        v9 = a2 == 36 ? *(_DWORD *)(v7 + 24) : *(_DWORD *)(v7 + 28);
        **(_WORD **)(v7 + 20) = v9;
        if ( **(_WORD **)(v7 + 20) != v8 )
        {
          SECInvalidate(v3, *(_DWORD *)v7);
          return 1;
        }
      }
      return 0;
    }
    if ( a2 == 38 )
      goto LABEL_18;
    if ( a2 == 40 )
    {
LABEL_17:
      v13 = -1;
      goto LABEL_18;
    }
    if ( a2 == 107 )
    {
LABEL_18:
      PeekMessageW(&Msg, 0, 0x102u, 0x102u, 1u);
      SECSaveResetSubeditEdit(a1, 1);
      return SECIncrementSubedit(v3, v13);
    }
    if ( a2 == 109 )
      goto LABEL_17;
  }
  return 0;
}

//----- (6F7AB869) --------------------------------------------------------
int __stdcall SECHandleChar(int a1, WORD wMatch)
{
  int v2; // esi@1
  int v4; // esi@3
  WORD v5; // di@4
  unsigned __int16 v6; // ax@9
  signed int v7; // eax@10
  unsigned __int16 v8; // ax@13
  int v9; // ebx@18
  unsigned int v10; // edi@19
  int v11; // eax@25

  v2 = *(_DWORD *)(a1 + 152);
  if ( v2 < 0 )
    return 0;
  v4 = *(_DWORD *)(a1 + 180) + 60 * v2;
  if ( !*(_DWORD *)(v4 + 36) )
    return 0;
  v5 = wMatch;
  if ( wMatch == *(_WORD *)(a1 + 184) || StrChrW((LPCWSTR)(a1 + 186), wMatch) )
  {
    SECSaveResetSubeditEdit(a1, 1);
    SECIncrFocus(a1, 1);
    return 0;
  }
  if ( *(_DWORD *)v4 == 7 )
  {
    if ( wMatch != 112 && wMatch != 80 || (v6 = **(_WORD **)(v4 + 20), v6 >= 0xCu) )
    {
      if ( wMatch != 97 && wMatch != 65 )
        return 0;
      v8 = **(_WORD **)(v4 + 20);
      if ( v8 < 0xCu )
        return 0;
      v7 = v8 - 12;
    }
    else
    {
      v7 = v6 + 12;
    }
    *(_DWORD *)(v4 + 40) = 1;
    v5 = v7 % 10 + 48;
    *(_DWORD *)(v4 + 44) = v7 / 10;
LABEL_18:
    v9 = v5 - 48;
    if ( *(_DWORD *)(v4 + 40) )
      v10 = v9 + 10 * *(_DWORD *)(v4 + 44);
    else
      v10 = v5 - 48;
    if ( (unsigned int)SECAdjustByType(a1, v4, v10) > *(_DWORD *)(v4 + 28) && *(_DWORD *)v4 != 2 && *(_DWORD *)v4 != 3 )
    {
      *(_DWORD *)(v4 + 40) = 0;
      v10 = v9;
    }
    SECInvalidate(a1 + 120, *(_DWORD *)v4);
    ++*(_DWORD *)(v4 + 40);
    v11 = *(_DWORD *)(v4 + 40);
    *(_DWORD *)(v4 + 44) = v10;
    if ( v11 == *(_DWORD *)(v4 + 36) )
      *(_DWORD *)(v4 + 40) = 0;
    if ( !*(_DWORD *)(v4 + 40) )
    {
      SECSetSubeditValue(a1, v4, v10, 1);
      return 1;
    }
    if ( v10 != **(_WORD **)(v4 + 20) )
      InvalidateRect(*(HWND *)a1, 0, 1);
    return 0;
  }
  if ( (unsigned __int16)(wMatch - 48) > 9u )
  {
    MessageBeep(0x10u);
    return 0;
  }
  if ( *(_DWORD *)v4 != 1 )
    goto LABEL_18;
  return 0;
}

//----- (6F7AB9DD) --------------------------------------------------------
int __stdcall SECEdit(int a1, int a2, int nMaxCount)
{
  int v3; // ebx@1
  int v4; // eax@1
  bool v5; // zf@1
  wchar_t *v6; // esi@1
  HWND v7; // eax@2
  bool v8; // sf@4
  int v9; // eax@10
  struct tagPOINT Points; // [sp+Ch] [bp-14Ch]@15
  int v12; // [sp+14h] [bp-144h]@15
  int v13; // [sp+18h] [bp-140h]@15
  struct tagMSG Msg; // [sp+1Ch] [bp-13Ch]@17
  int v15; // [sp+38h] [bp-120h]@1
  LPWSTR lpString; // [sp+3Ch] [bp-11Ch]@1
  int v17; // [sp+40h] [bp-118h]@1
  size_t cchDest; // [sp+44h] [bp-114h]@1
  int v19; // [sp+48h] [bp-110h]@4
  int v20; // [sp+4Ch] [bp-10Ch]@1
  HWND hWnd; // [sp+50h] [bp-108h]@4
  wchar_t pszDest; // [sp+54h] [bp-104h]@1

  v20 = 0;
  lpString = (LPWSTR)a2;
  v3 = a1 + 120;
  v4 = *(_DWORD *)(a1 + 152);
  v17 = a1;
  v15 = v4;
  SECSetCurSubed(a1, -2);
  v5 = (*(_BYTE *)(a1 + 236) & 1) == 0;
  v6 = &pszDest;
  cchDest = 128;
  if ( v5 )
    v7 = *(HWND *)(a1 + 180);
  else
    v7 = (HWND)(60 * *(_DWORD *)(a1 + 156) + *(_DWORD *)(a1 + 180) - 60);
  v19 = 0;
  v5 = *(_DWORD *)(a1 + 156) == 0;
  v8 = *(_DWORD *)(a1 + 156) < 0;
  hWnd = v7;
  if ( !v8 && !v5 )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)v7 == 11 )
        StringCchCopyW(v6, cchDest, *((STRSAFE_LPCWSTR *)v7 + 13));
      else
        SEGetTimeDateFormat((int)v7, v3, v6, cchDest);
      v9 = lstrlenW(v6);
      cchDest -= v9;
      v6 += v9;
      if ( *(_BYTE *)(a1 + 236) & 1 )
        hWnd -= 15;
      else
        hWnd += 15;
      ++v19;
      if ( v19 >= *(_DWORD *)(a1 + 156) )
        break;
      v7 = hWnd;
    }
  }
  SECSetCurSubed(a1, v15);
  hWnd = CreateWindowExW(
           0,
           L"EDIT",
           &pszDest,
           0x40000080u,
           *(_DWORD *)(a1 + 132) + 2,
           *(_DWORD *)(a1 + 136) + 2,
           *(_DWORD *)(a1 + 140) - *(_DWORD *)(a1 + 132),
           *(_DWORD *)(a1 + 144) - *(_DWORD *)(a1 + 136),
           **(HWND **)(a1 + 120),
           0,
           g_hinst,
           0);
  if ( hWnd )
  {
    Points.x = *(_DWORD *)(a1 + 132);
    Points.y = *(_DWORD *)(a1 + 136);
    v12 = *(_DWORD *)(a1 + 140);
    v13 = *(_DWORD *)(a1 + 144);
    MapWindowPoints(**(HWND **)v3, 0, &Points, 2u);
    *(_DWORD *)(v17 + 296) |= 0x400u;
    InvalidateRect(**(HWND **)v3, 0, 1);
    SendMessageW(hWnd, 0xC5u, 0x7Fu, 0);
    SendMessageW(hWnd, 0x30u, *(_DWORD *)(a1 + 128), 0);
    SetFocus(hWnd);
    RescrollEditWindow(hWnd);
    ShowWindow(hWnd, 1);
    while ( 1 )
    {
      while ( 1 )
      {
        v19 = PeekMessageW(&Msg, 0, 0, 0, 0);
        if ( GetFocus() != hWnd )
        {
LABEL_35:
          v20 = 1;
          GetWindowTextW(hWnd, lpString, nMaxCount);
          goto LABEL_36;
        }
        if ( v19 )
          break;
        WaitMessage();
      }
      if ( Msg.message == 274
        || Msg.message == 262
        || Msg.message == 263
        || Msg.message == 259
        || Msg.message == 260
        || Msg.message == 18 )
        break;
      if ( (Msg.message == 513 || Msg.message == 161 || Msg.message == 516 || Msg.message == 164 || Msg.message == 515)
        && !PtInRect((const RECT *)&Points, Msg.pt) )
        goto LABEL_35;
      GetMessageW(&Msg, 0, 0, 0);
      if ( Msg.message == 256 )
      {
        if ( Msg.wParam == 27 )
          break;
        if ( Msg.wParam == 13 )
          goto LABEL_35;
      }
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
    v20 = 0;
LABEL_36:
    DestroyWindow(hWnd);
    *(_DWORD *)(v17 + 296) &= 0xFFFFFBFF;
    InvalidateRect(**(HWND **)v3, 0, 1);
  }
  return v20;
}

//----- (6F7ABD24) --------------------------------------------------------
signed int __stdcall SECSafeSetCurSubed(int a1, int a2)
{
  signed int result; // eax@4

  if ( a2 >= *(_DWORD *)(a1 + 156) || a2 >= 0 && *(_DWORD *)(*(_DWORD *)(a1 + 180) + 60 * a2 + 56) )
  {
    SECSetCurSubed(a1, -1);
    result = SECIncrFocus(a1, 1);
  }
  else
  {
    result = SECSetCurSubed(a1, a2);
  }
  return result;
}

//----- (6F7ABD71) --------------------------------------------------------
int __stdcall DTM_OnSetFormat(int a1, STRSAFE_LPCWSTR pszSrc)
{
  int v2; // edi@1

  v2 = *(_DWORD *)(a1 + 152);
  if ( pszSrc && *pszSrc )
  {
    *(_DWORD *)(a1 + 296) &= 0xFFFFFEFF;
    SECParseFormat(a1, a1 + 120, pszSrc);
  }
  else
  {
    *(_DWORD *)(a1 + 296) |= 0x100u;
    DPHandleLocaleChange(a1);
  }
  SECSafeSetCurSubed(a1, v2);
  return 1;
}

//----- (6F7ABDCA) --------------------------------------------------------
int __stdcall DPOnStyleChanged(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // esi@2

  if ( a2 == -16 )
  {
    v3 = *(_DWORD *)(a3 + 4);
    v4 = v3 ^ *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v4 & 0xFFCD )
      DPHandleLocaleChange(a1);
    if ( v4 & 0xC40000 )
      PostMessageW(*(HWND *)a1, 0xFFFu, 0, 0);
  }
  return 0;
}

//----- (6F7ABE1C) --------------------------------------------------------
HWND __stdcall DPLBD_MonthCal(HDC hDC, int a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  HWND v4; // ST24_4@2
  int v5; // eax@3
  HWND v6; // ST20_4@7
  HWND v7; // ST20_4@7
  HWND v8; // ST20_4@7
  HWND result; // eax@7
  HWND v10; // edi@7
  LPARAM *v11; // esi@8
  WPARAM v12; // eax@10
  LRESULT v13; // eax@12
  LONG v14; // eax@14
  int v15; // ecx@14
  UINT v16; // eax@15
  HWND v17; // ST2C_4@51
  int v18; // [sp+Ch] [bp-84h]@14
  int v19; // [sp+10h] [bp-80h]@14
  int v20; // [sp+14h] [bp-7Ch]@14
  int v21; // [sp+18h] [bp-78h]@14
  LPARAM v22; // [sp+1Ch] [bp-74h]@14
  struct tagPOINT v23; // [sp+2Ch] [bp-64h]@7
  int v24; // [sp+34h] [bp-5Ch]@7
  int v25; // [sp+38h] [bp-58h]@7
  struct tagPOINT Points; // [sp+3Ch] [bp-54h]@7
  int v27; // [sp+44h] [bp-4Ch]@7
  int v28; // [sp+48h] [bp-48h]@7
  LPARAM lParam; // [sp+4Ch] [bp-44h]@12
  unsigned int v30; // [sp+54h] [bp-3Ch]@12
  struct tagMSG Msg; // [sp+5Ch] [bp-34h]@15
  HWND hWnd; // [sp+78h] [bp-18h]@7
  struct tagPOINT X; // [sp+7Ch] [bp-14h]@7
  int v34; // [sp+84h] [bp-Ch]@7
  int v35; // [sp+88h] [bp-8h]@7
  WPARAM wParam; // [sp+8Ch] [bp-4h]@8
  HDC hDCa; // [sp+98h] [bp+8h]@1

  v2 = (int)hDC;
  hDCa = GetDC(*(HWND *)hDC);
  v3 = *(_DWORD *)(v2 + 296);
  if ( !(v3 & 0x40) )
  {
    v4 = *(HWND *)v2;
    *(_DWORD *)(v2 + 296) = v3 | 0x40;
    InvalidateRect(v4, 0, 1);
    DPNotifyDateChange(v2);
  }
  v5 = *(_DWORD *)(v2 + 296);
  if ( (char)v5 < 0 )
  {
    *(_DWORD *)(v2 + 296) = v5 & 0xFFFFFF7F;
    InvalidateRect(*(HWND *)v2, (const RECT *)(v2 + 240), 1);
  }
  SECSetCurSubed(v2, -1);
  if ( a2 )
    DPDrawDropdownButton(v2, hDCa, 1);
  Points = *(struct tagPOINT *)(v2 + 256);
  v27 = *(_DWORD *)(v2 + 264);
  v6 = *(HWND *)v2;
  v28 = *(_DWORD *)(v2 + 268);
  MapWindowPoints(v6, 0, &Points, 2u);
  v23.x = *(_DWORD *)(v2 + 272);
  v23.y = *(_DWORD *)(v2 + 276);
  v24 = *(_DWORD *)(v2 + 280);
  v7 = *(HWND *)v2;
  v25 = *(_DWORD *)(v2 + 284);
  MapWindowPoints(v7, 0, &v23, 2u);
  X = Points;
  v34 = v27;
  v35 = v28;
  v8 = *(HWND *)v2;
  v35 = v28 + 2;
  X.y = v28 + 1;
  result = CreateWindowExW(0, L"SysMonthCal32", 0, 0x80800000, Points.x, v28 + 1, v27 - Points.x, 1, v8, 0, g_hinst, 0);
  v10 = result;
  hWnd = result;
  if ( result )
  {
    wParam = 0;
    *(_DWORD *)(v2 + 40) = result;
    v11 = (LPARAM *)(v2 + 48);
    do
    {
      SendMessageW(v10, 0x100Au, wParam++, *v11);
      ++v11;
    }
    while ( (signed int)wParam < 6 );
    v12 = *(_DWORD *)(v2 + 44);
    if ( v12 )
      SendMessageW(v10, 0x30u, v12, 0);
    SendMessageW(v10, 0x1012u, 3u, v2 + 72);
    SendMessageW(v10, 0x1009u, 0, (LPARAM)&lParam);
    v13 = SendMessageW(v10, 0x1015u, 0, 0);
    if ( v13 > v30 )
      v30 = v13;
    SECGetSystemtime(v2 + 120, (int)&v22);
    SendMessageW(v10, 0x1002u, 0, (LPARAM)&v22);
    _RecomputeMonthCalRect(v2, (int)&X, (int)&lParam);
    MoveWindow(v10, X.x, X.y, v34 - X.x, v35 - X.y, 0);
    CCSendNotify(v2, -754, 0);
    v14 = GetWindowLongW(v10, 0);
    _RecomputeMonthCalRect(v2, (int)&X, v14 + 1988);
    MoveWindow(v10, X.x, X.y, v34 - X.x, v35 - X.y, 0);
    ShowWindow(v10, 8);
    *(_DWORD *)(v2 + 296) |= 0x20u;
    v15 = *(_DWORD *)(v2 + 296);
    v18 = *(_DWORD *)(v2 + 160);
    v19 = *(_DWORD *)(v2 + 164);
    v20 = *(_DWORD *)(v2 + 168);
    wParam = a2;
    v21 = *(_DWORD *)(v2 + 172);
    if ( v15 & 0x20 )
    {
      do
      {
        *(_DWORD *)(v2 + 296) ^= (*(_DWORD *)(v2 + 296) ^ 32 * (unsigned __int16)GetMessageW(&Msg, 0, 0, 0)) & 0x20;
        v16 = Msg.message;
        if ( wParam )
        {
          if ( Msg.message == 512 )
          {
            if ( PtInRect((const RECT *)&v23, Msg.pt) )
            {
              if ( !a2 )
              {
                DPDrawDropdownButton(v2, hDCa, 1);
                a2 = 1;
              }
            }
            else
            {
              if ( a2 )
              {
                DPDrawDropdownButton(v2, hDCa, 0);
                a2 = 0;
              }
              if ( PtInRect((const RECT *)&X, Msg.pt) )
              {
                wParam = 0;
                SendMessageW(
                  hWnd,
                  0x201u,
                  0,
                  (unsigned __int16)(v34 / 2 + X.x / 2) | ((unsigned __int16)(v35 / 2 + X.y / 2) << 16));
              }
            }
            continue;
          }
          if ( Msg.message == 514 )
          {
            if ( a2 )
            {
              DPDrawDropdownButton(v2, hDCa, 0);
              a2 = 0;
            }
            wParam = 0;
            continue;
          }
        }
        if ( Msg.message == 513 || Msg.message == 161 || Msg.message == 515 )
        {
          if ( !PtInRect((const RECT *)&X, Msg.pt) )
            goto LABEL_49;
          v16 = Msg.message;
        }
        if ( v16 == 274 || v16 == 273 || v16 == 260 && Msg.wParam == 38 || v16 == 256 && Msg.wParam == 13 || v16 == 8 )
        {
LABEL_49:
          *(_DWORD *)(v2 + 296) &= 0xFFFFFFDF;
          continue;
        }
        if ( v16 == 516 || v16 == 164 || v16 == 518 )
        {
          if ( !PtInRect((const RECT *)&X, Msg.pt) )
            goto LABEL_48;
          v16 = Msg.message;
        }
        if ( v16 == 256 && Msg.wParam == 27 )
        {
LABEL_48:
          *(_DWORD *)(v2 + 296) &= 0xFFFFFFDF;
          *(_DWORD *)(v2 + 160) = v18;
          *(_DWORD *)(v2 + 164) = v19;
          *(_DWORD *)(v2 + 168) = v20;
          *(_DWORD *)(v2 + 172) = v21;
          DPNotifyDateChange(v2);
          InvalidateRect(*(HWND *)v2, 0, 1);
          continue;
        }
        TranslateMessage(&Msg);
        DispatchMessageW(&Msg);
      }
      while ( *(_BYTE *)(v2 + 296) & 0x20 );
    }
    CCSendNotify(v2, -753, 0);
    v17 = hWnd;
    *(_DWORD *)(v2 + 40) = 0;
    DestroyWindow(v17);
    result = (HWND)ReleaseDC(*(HWND *)v2, hDCa);
  }
  return result;
}

//----- (6F7AC27B) --------------------------------------------------------
HWND __stdcall DPHandleSECEdit(int a1)
{
  HWND result; // eax@1
  int v2; // eax@2
  LPARAM lParam; // [sp+4h] [bp-128h]@2
  char v4; // [sp+8h] [bp-124h]@2
  int *v5; // [sp+10h] [bp-11Ch]@2
  int v6; // [sp+14h] [bp-118h]@2
  int v7; // [sp+18h] [bp-114h]@2
  int v8; // [sp+1Ch] [bp-110h]@2
  int v9; // [sp+20h] [bp-10Ch]@2
  int v10; // [sp+24h] [bp-108h]@2
  int v11; // [sp+28h] [bp-104h]@1

  result = (HWND)SECEdit(a1, (int)&v11, 128);
  if ( result )
  {
    lParam = 0;
    memset(&v4, 0, 0x20u);
    v5 = &v11;
    v2 = *(_DWORD *)(a1 + 296);
    v6 = *(_DWORD *)(a1 + 160);
    v7 = *(_DWORD *)(a1 + 164);
    v8 = *(_DWORD *)(a1 + 168);
    v9 = *(_DWORD *)(a1 + 172);
    v10 = (v2 & 0x40) != 64;
    result = CCSendNotify(a1, -745, (LPARAM)&lParam);
    if ( !v10 )
    {
      result = (HWND)IsValidSystemtime((int)&v6);
      if ( !result )
      {
        v6 = *(_DWORD *)(a1 + 160);
        v7 = *(_DWORD *)(a1 + 164);
        v8 = *(_DWORD *)(a1 + 168);
        v9 = *(_DWORD *)(a1 + 172);
      }
    }
    if ( v10 == 1 )
    {
      if ( *(_BYTE *)(a1 + 8) & 2 )
      {
        *(_DWORD *)(a1 + 296) = *(_DWORD *)(a1 + 296) & 0xFFFFFFBF | 0x80;
        SECSetCurSubed(a1, -1);
        InvalidateRect(*(HWND *)a1, 0, 1);
        result = DPNotifyDateChange(a1);
      }
    }
    else if ( !v10 )
    {
      result = (HWND)DPSetDate(a1, (int)&v6, 0);
    }
  }
  return result;
}

//----- (6F7AC39D) --------------------------------------------------------
int __stdcall DPLButtonDown(HDC hDC, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // eax@16

  if ( *((_BYTE *)hDC + 296) & 1 )
  {
    SECSaveResetSubeditEdit((int)hDC, 1);
    v3 = (*((_DWORD *)hDC + 74) >> 2) & 1;
    if ( !v3 )
      SetFocus(*(HWND *)hDC);
    if ( !(*((_BYTE *)hDC + 296) & 2)
      && PtInRect((const RECT *)hDC + 17, (POINT)__PAIR__(SHIWORD(a3), (signed __int16)a3))
      && IsWindowVisible(*(HWND *)hDC) )
    {
      DPLBD_MonthCal(hDC, 1);
    }
    else if ( !(*((_BYTE *)hDC + 296) & 0x10) )
    {
      if ( *((_BYTE *)hDC + 8) & 2 && PtInRect((const RECT *)hDC + 15, (POINT)__PAIR__(SHIWORD(a3), (signed __int16)a3)) )
      {
        *((_DWORD *)hDC + 74) = *((_DWORD *)hDC + 74) & 0xFFFFFFBF | ~(unsigned __int8)*((_DWORD *)hDC + 74) & 0x40 | 0x80;
        SECSetCurSubed((int)hDC, -1);
        InvalidateRect(*(HWND *)hDC, 0, 1);
        DPNotifyDateChange((int)hDC);
      }
      else if ( *((_BYTE *)hDC + 296) & 0x40 )
      {
        if ( *((_BYTE *)hDC + 8) & 0x10 && v3 )
        {
          DPHandleSECEdit((int)hDC);
        }
        else
        {
          v4 = SECSubeditFromPt((int)(hDC + 30), *((_DWORD *)hDC + 37) + (signed __int16)a3, SHIWORD(a3));
          if ( v4 >= 0 )
          {
            SECSetCurSubed((int)hDC, v4);
            if ( *((_BYTE *)hDC + 8) & 2 )
            {
              *((_DWORD *)hDC + 74) &= 0xFFFFFF7F;
              InvalidateRect(*(HWND *)hDC, (const RECT *)hDC + 15, 1);
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (6F7AC4E3) --------------------------------------------------------
int __stdcall DPHandleKeydown(HDC hDC, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@7
  struct _SYSTEMTIME SystemTime; // [sp+8h] [bp-10h]@17

  v3 = 1;
  if ( a2 == 115 && !(*((_BYTE *)hDC + 296) & 2) )
  {
    DPLBD_MonthCal(hDC, 0);
    return 0;
  }
  if ( *((_BYTE *)hDC + 8) & 0x10 && a2 == 113 )
  {
    DPHandleSECEdit((int)hDC);
    return 0;
  }
  v4 = *((_DWORD *)hDC + 74);
  if ( (char)v4 >= 0 )
  {
    if ( a2 == 36 && GetKeyState(17) < 0 )
    {
      GetLocalTime(&SystemTime);
      DPSetDate((int)hDC, (int)&SystemTime, 1);
      return 0;
    }
    if ( SECHandleKeydown((int)hDC, a2, a3) )
    {
      DPNotifyDateChange((int)hDC);
      return 0;
    }
    if ( *((_BYTE *)hDC + 8) & 2 && *((_DWORD *)hDC + 38) < 0 )
    {
      *((_DWORD *)hDC + 74) |= 0x80u;
      goto LABEL_23;
    }
  }
  else
  {
    if ( a2 == 37 )
    {
      v3 = -1;
    }
    else if ( a2 != 39 )
    {
      return 0;
    }
    if ( v4 & 0x40 && SECIncrFocus((int)hDC, v3) != -1 )
    {
      *((_DWORD *)hDC + 74) &= 0xFFFFFF7F;
LABEL_23:
      InvalidateRect(*(HWND *)hDC, (const RECT *)hDC + 15, 1);
      return 0;
    }
  }
  return 0;
}

//----- (6F7AC5DD) --------------------------------------------------------
int __stdcall DPHandleChar(int a1, WORD wMatch, int a3)
{
  unsigned int v3; // eax@1
  HWND v4; // ST00_4@3

  v3 = *(_DWORD *)(a1 + 296);
  if ( (v3 & 0x80u) == 0 )
  {
    SECHandleChar(a1, wMatch);
  }
  else if ( wMatch == 32 )
  {
    v4 = *(HWND *)a1;
    *(_DWORD *)(a1 + 296) = v3 ^ ((unsigned __int8)v3 ^ (unsigned __int8)((-1 - ((v3 >> 6) & 1)) << 6)) & 0x40;
    InvalidateRect(v4, 0, 1);
    DPNotifyDateChange(a1);
  }
  else
  {
    MessageBeep(0x10u);
  }
  return 0;
}

//----- (6F7AC647) --------------------------------------------------------
int __stdcall MCOnStyleChanged(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // ebx@2

  if ( a2 == -16 )
  {
    v3 = *(_DWORD *)(a3 + 4);
    v4 = v3 ^ *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v3;
    if ( v4 & 4 )
    {
      MCCalcSizes(a1);
      MCUpdateRcDayCur(a1, a1 + 1684);
    }
    if ( v4 & 0x1C )
      MCUpdateToday(a1);
    if ( v4 & 0xC40000 )
      PostMessageW(*(HWND *)a1, 0xFFFu, 0, 0);
    if ( v4 )
      InvalidateRect(*(HWND *)a1, 0, 1);
  }
  else if ( a2 == -20 && (*(_DWORD *)a3 ^ *(_DWORD *)(a3 + 4)) & 0x400000 )
  {
    MCUpdateMonthNamePos(a1);
  }
  return 0;
}

//----- (6F7AC6DE) --------------------------------------------------------
BOOL __stdcall MCPaint(HGDIOBJ a1, HDC hdc)
{
  COLORREF v2; // ST20_4@1
  HPEN v3; // eax@1
  COLORREF v4; // ST20_4@1
  HGDIOBJ v5; // eax@1
  HGDIOBJ v6; // eax@1
  COLORREF v7; // ST20_4@1
  HDC v8; // edi@1
  HGDIOBJ (__stdcall *v9)(HDC, HGDIOBJ); // esi@1
  int v10; // eax@1
  LONG v11; // edx@1
  int v12; // ecx@1
  bool v13; // zf@1
  bool v14; // sf@1
  int i; // esi@2
  LONG v16; // eax@12
  int v17; // ecx@13
  void *v18; // ST20_4@14
  HGDIOBJ v19; // ST3C_4@14
  int v20; // eax@14
  int v21; // eax@16
  int v22; // eax@23
  HGDIOBJ v24; // [sp+Ch] [bp-108h]@1
  int v25; // [sp+10h] [bp-104h]@1
  HBRUSH ho; // [sp+14h] [bp-100h]@1
  HGDIOBJ h; // [sp+18h] [bp-FCh]@1
  int v28; // [sp+1Ch] [bp-F8h]@1
  int v29; // [sp+20h] [bp-F4h]@1
  RECT rect; // [sp+24h] [bp-F0h]@2
  RECT v31; // [sp+34h] [bp-E0h]@1
  HDC v32; // [sp+44h] [bp-D0h]@1
  int v33; // [sp+48h] [bp-CCh]@1
  int v34; // [sp+4Ch] [bp-C8h]@1
  wchar_t pszDest; // [sp+50h] [bp-C4h]@14
  WCHAR DateStr; // [sp+D0h] [bp-44h]@14

  v2 = *((_DWORD *)a1 + 391);
  v32 = hdc;
  v3 = CreatePen(0, 0, v2);
  v4 = *((_DWORD *)a1 + 392);
  *((_DWORD *)a1 + 386) = v3;
  ho = CreateSolidBrush(v4);
  SetBkMode(hdc, 1);
  SetTextColor(hdc, *((_DWORD *)a1 + 391));
  v5 = GetStockObject(7);
  v6 = SelectObject(hdc, v5);
  v7 = *((_DWORD *)a1 + 394);
  v31.left = *((_DWORD *)a1 + 501);
  v31.top = *((_DWORD *)a1 + 502);
  v31.right = *((_DWORD *)a1 + 503);
  v24 = v6;
  v31.bottom = *((_DWORD *)a1 + 504);
  v8 = v32;
  FillRectClr(v32, &v31, v7);
  v9 = SelectObject;
  SelectObject(v8, *((HGDIOBJ *)a1 + 386));
  v10 = *((_DWORD *)a1 + 398);
  v11 = *((_DWORD *)a1 + 502);
  v31.left = *((_DWORD *)a1 + 501);
  v31.right = v10 + v31.left;
  v12 = *((_DWORD *)a1 + 399);
  v31.top = v11;
  v31.bottom = v12 + v11;
  v33 = *((_WORD *)a1 + 899);
  v25 = v10 + 6;
  v13 = *((_DWORD *)a1 + 460) == 0;
  v14 = *((_DWORD *)a1 + 460) < 0;
  v28 = *((_WORD *)a1 + 898);
  h = (HGDIOBJ)(v12 + 6);
  v34 = 0;
  v29 = 0;
  if ( !v14 && !v13 )
  {
    do
    {
      rect = v31;
      for ( i = 0; i < *((_DWORD *)a1 + 461); ++i )
      {
        if ( RectVisible(v32, &rect) )
          MCPaintMonth(a1, v32, (int)&rect, v33, v28, v34, v34 == 0, v34 == *((_DWORD *)a1 + 457) - 1, (int)ho);
        rect.left += v25;
        rect.right += v25;
        ++v33;
        if ( v33 > 12 )
        {
          ++v28;
          v33 = 1;
        }
        ++v34;
      }
      v31.top += (LONG)h;
      v31.bottom += (LONG)h;
      ++v29;
    }
    while ( v29 < *((_DWORD *)a1 + 460) );
    v9 = SelectObject;
    v8 = v32;
  }
  if ( !(*((_BYTE *)a1 + 8) & 0x10) )
  {
    MCGetTodayBtnRect((int)a1, (int)&v31);
    if ( RectVisible(v8, &v31) )
    {
      v16 = v31.left + 2;
      if ( !(*((_BYTE *)a1 + 8) & 8) )
      {
        v17 = *((_DWORD *)a1 + 396);
        rect.left = v31.left + 4;
        rect.right = v17 + v31.left + 4 - 2;
        rect.top = v31.top + 2;
        rect.bottom = v31.bottom - 2;
        MCDrawTodayCircle(a1, v8, (int)&rect);
        v16 = rect.right;
      }
      v18 = (void *)*((_DWORD *)a1 + 389);
      rect.left = v16 + 2;
      rect.right = v31.right - 2;
      rect.top = v31.top;
      rect.bottom = v31.bottom;
      v19 = v9(v8, v18);
      SetTextColor(v8, *((_DWORD *)a1 + 391));
      GetDateFormatW(*((_DWORD *)a1 + 554), 1u, (const SYSTEMTIME *)((char *)a1 + 1668), 0, &DateStr, 32);
      StringCchPrintfW(&pszDest, 0x40u, L"%s %s", (char *)a1 + 36, &DateStr);
      v20 = lstrlenW(&pszDest);
      DrawTextW(v8, &pszDest, v20, &rect, 0x924u);
      v9(v8, v19);
    }
  }
  if ( RectVisible(v8, (const RECT *)((char *)a1 + 1848)) )
  {
    v21 = 0;
    if ( *((_DWORD *)a1 + 458) && *((_BYTE *)a1 + 2232) & 8 )
      v21 = 1;
    MCPaintArrowBtn((int)a1, v8, 1, v21);
  }
  if ( RectVisible(v8, (const RECT *)((char *)a1 + 1864)) )
  {
    v22 = *((_DWORD *)a1 + 458) && !(*((_BYTE *)a1 + 2232) & 8);
    MCPaintArrowBtn((int)a1, v8, 0, v22);
  }
  v9(v8, v24);
  DeleteObject(ho);
  return DeleteObject(*((HGDIOBJ *)a1 + 386));
}

//----- (6F7ACADA) --------------------------------------------------------
int __stdcall MCUpdateStartEndDates(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // eax@5
  signed int v6; // edi@9
  signed int v7; // ebx@13
  int v8; // eax@15
  int v9; // ebx@15
  int v10; // eax@15
  int v11; // eax@16
  __int16 v12; // ax@21
  __int16 v13; // dx@21
  __int16 v14; // dx@23
  __int16 v15; // ax@23
  int v17; // [sp+Ch] [bp-4h]@11
  signed int v18; // [sp+18h] [bp+8h]@9
  int v19; // [sp+1Ch] [bp+Ch]@12

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 1840) * *(_DWORD *)(a1 + 1844);
  *(_DWORD *)(a1 + 1828) = v3;
  v4 = 12 * (*(_WORD *)(a1 + 1648) - *(_WORD *)a2) - *(_WORD *)(a2 + 2) + *(_WORD *)(a1 + 1650) + 1;
  if ( v4 < v3 )
    IncrSystemTime(a2, a2, v4 - v3, 2);
  if ( CmpDate(a2, a1 + 1632) < 0 )
  {
    *(_WORD *)a2 = *(_WORD *)(a1 + 1632);
    *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 1634);
    *(_WORD *)(a2 + 6) = *(_WORD *)(a1 + 1638);
  }
  v5 = 12 * (*(_WORD *)(a1 + 1648) - *(_WORD *)a2) - *(_WORD *)(a2 + 2) + *(_WORD *)(a1 + 1650) + 1;
  if ( v5 < *(_DWORD *)(a1 + 1828) )
    *(_DWORD *)(a1 + 1828) = v5;
  *(_WORD *)(a1 + 1796) = *(_WORD *)a2;
  *(_WORD *)(a1 + 1798) = *(_WORD *)(a2 + 2);
  *(_WORD *)(a1 + 1802) = 1;
  if ( CmpDate(a1 + 1796, a1 + 1632) < 0 )
    *(_WORD *)(a1 + 1802) = *(_WORD *)(a1 + 1638);
  v6 = *(_WORD *)(a1 + 1798) - 1;
  v18 = *(_WORD *)(a1 + 1796);
  if ( *(_WORD *)(v2 + 1798) == 1 )
  {
    --v18;
    v6 = 12;
  }
  v17 = 0;
  if ( *(_DWORD *)(v2 + 1828) + 1 >= 0 )
  {
    v19 = v2 + 2076;
    do
    {
      v7 = GetDaysForMonth(v18, v6++);
      *(_DWORD *)(v19 - 56) = v7;
      if ( v6 > 12 )
      {
        v6 = 1;
        ++v18;
      }
      v8 = GetStartDowForMonth(v18, v6) - *(_DWORD *)(v2 + 1448);
      v9 = v7 - (v8 + (v8 < 0 ? 7 : 0));
      v10 = v19;
      ++v17;
      v19 += 4;
      *(_DWORD *)v10 = v9;
    }
    while ( v17 <= *(_DWORD *)(v2 + 1828) + 1 );
  }
  v11 = *(_DWORD *)(v2 + 2076);
  if ( v11 == *(_DWORD *)(v2 + 2020) )
    *(_DWORD *)(v2 + 2076) = v11 - 7;
  IncrSystemTime(v2 + 1796, v2 + 1812, *(_DWORD *)(v2 + 1828) - 1, 2);
  *(_WORD *)(v2 + 1818) = *(_WORD *)(v2 + 4 * *(_DWORD *)(v2 + 1828) + 2020);
  if ( *(_WORD *)(v2 + 2232) & 0x1000 && CmpDate(v2 + 1812, v2 + 1648) > 0 )
    *(_WORD *)(v2 + 1818) = *(_WORD *)(v2 + 1654);
  v12 = *(_WORD *)(v2 + 1796);
  v13 = *(_WORD *)(v2 + 1798) - 1;
  *(_WORD *)(v2 + 1764) = v12;
  *(_WORD *)(v2 + 1766) = v13;
  if ( !v13 )
  {
    *(_WORD *)(v2 + 1766) = 12;
    *(_WORD *)(v2 + 1764) = v12 - 1;
  }
  v14 = *(_WORD *)(v2 + 1814);
  *(_WORD *)(v2 + 1770) = *(_WORD *)(v2 + 2076) + 1;
  v15 = *(_WORD *)(v2 + 1812);
  ++v14;
  *(_WORD *)(v2 + 1780) = v15;
  *(_WORD *)(v2 + 1782) = v14;
  if ( v14 == 13 )
  {
    *(_WORD *)(v2 + 1782) = 1;
    *(_WORD *)(v2 + 1780) = v15 + 1;
  }
  *(_WORD *)(v2 + 1786) = *(_WORD *)(v2 + 4 * *(_DWORD *)(v2 + 1828) + 2072)
                        - *(_WORD *)(v2 + 4 * *(_DWORD *)(v2 + 1828) + 2020)
                        - *(_WORD *)(v2 + 4 * *(_DWORD *)(v2 + 1828) + 2016)
                        + 42;
  MCUpdateDayState(v2);
  MCUpdateRcDayCur(v2, v2 + 1684);
  MCUpdateToday(v2);
  return MCUpdateMonthNamePos(v2);
}

//----- (6F7ACD74) --------------------------------------------------------
int __stdcall FIncrStartMonth(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  char v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+18h] [bp-8h]@1
  int v8; // [sp+1Ch] [bp-4h]@1
  signed int v9; // [sp+28h] [bp+8h]@2

  v3 = a1;
  v4 = a1 + 1796;
  v8 = *(_WORD *)(a1 + 1796);
  v7 = *(_WORD *)(a1 + 1798);
  IncrSystemTime(a1 + 1796, (int)&v6, a2, 2);
  MCUpdateStartEndDates(a1, (int)&v6);
  if ( !a3 )
  {
    v9 = 1;
    if ( *(_BYTE *)(v3 + 8) & 2 )
      v9 = DaysBetweenDates(v3 + 1684, v3 + 1700);
    *(_WORD *)(v3 + 1686) = *(_WORD *)(v3 + 1798);
    *(_WORD *)(v3 + 1684) = *(_WORD *)v4;
    if ( (signed int)*(_WORD *)(v3 + 1690) > *(_DWORD *)(v3 + 2024) )
      *(_WORD *)(v3 + 1690) = *(_WORD *)(v3 + 2024);
    if ( *(_BYTE *)(v3 + 8) & 2 )
      IncrSystemTime(v3 + 1684, v3 + 1700, v9, 8);
    MCNotifySelChange(v3, -749);
    MCUpdateRcDayCur(v3, v3 + 1684);
  }
  MCInvalidateMonthDays(v3);
  return *(_WORD *)(v3 + 1798) + 12 * (*(_WORD *)v4 - v8) - v7;
}

//----- (6F7ACE62) --------------------------------------------------------
int __stdcall MCIncrStartMonth(int a1, int a2, int a3)
{
  int v3; // esi@1

  v3 = FIncrStartMonth(a1, a2, a3);
  if ( !v3 )
    MessageBeep(0);
  return v3;
}

//----- (6F7ACE8F) --------------------------------------------------------
signed int __stdcall MCHandleTimer(int a1, int a2)
{
  int v2; // eax@3
  HWND v3; // ST0C_4@9

  if ( a2 == 1 )
  {
    if ( *(_WORD *)(a1 + 2232) & 0x2000 )
      v2 = *(_DWORD *)(a1 + 2200);
    else
      v2 = *(_DWORD *)(a1 + 1828);
    if ( *(_WORD *)(a1 + 2232) & 8 )
      v2 = -v2;
    MCIncrStartMonth(a1, v2, 0);
    if ( !*(_DWORD *)(a1 + 1832) )
      *(_DWORD *)(a1 + 1832) = SetTimer(*(HWND *)a1, 1u, 0x15Eu, 0);
    v3 = *(HWND *)a1;
    *(_DWORD *)(a1 + 1972) = *(_DWORD *)(a1 + 1956);
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 1960);
    *(_DWORD *)(a1 + 1980) = *(_DWORD *)(a1 + 1964);
    *(_DWORD *)(a1 + 1984) = *(_DWORD *)(a1 + 1968);
    UpdateWindow(v3);
  }
  else if ( a2 == 2 && !(*(_WORD *)(a1 + 2232) & 0x400) )
  {
    MCSetToday(a1, 0);
  }
  MCNotifySelChange(a1, -749);
  return 1;
}

//----- (6F7ACF3A) --------------------------------------------------------
int __stdcall MCMouseMove(HDC hDC, int a2, int a3)
{
  int v3; // ebx@1
  POINT v4; // ST18_8@2
  unsigned int v5; // eax@5
  __int16 v6; // ax@9
  int v8; // [sp+Ch] [bp-18h]@11
  POINT pt; // [sp+1Ch] [bp-8h]@2
  BOOL hDCa; // [sp+2Ch] [bp+8h]@2
  HDC hDCb; // [sp+2Ch] [bp+8h]@4

  v3 = (int)hDC;
  if ( *((_BYTE *)hDC + 2232) & 4 )
  {
    v4.y = SHIWORD(a3);
    pt.y = SHIWORD(a3);
    v4.x = (signed __int16)a3;
    pt.x = (signed __int16)a3;
    hDCa = PtInRect((const RECT *)(hDC + 462), v4);
    if ( hDCa || PtInRect((const RECT *)(v3 + 1864), (POINT)__PAIR__(pt.y, (signed __int16)a3)) )
    {
      if ( !*(_DWORD *)(v3 + 1832) )
      {
        *(_WORD *)(v3 + 2232) ^= (*(_WORD *)(v3 + 2232) ^ 8 * hDCa) & 8;
        MCHandleTimer(v3, 1);
      }
    }
    else
    {
      hDCb = GetDC(*(HWND *)v3);
      if ( *(_DWORD *)(v3 + 1832) )
      {
        KillTimer(*(HWND *)v3, *(_DWORD *)(v3 + 1832));
        v5 = *(_WORD *)(v3 + 2232);
        *(_DWORD *)(v3 + 1832) = 0;
        MCPaintArrowBtn(v3, hDCb, (v5 >> 3) & 1, 0);
      }
      if ( PtInRect((const RECT *)(v3 + 1956), pt) )
      {
        if ( !(*(_BYTE *)(v3 + 2232) & 0x10) )
        {
          DrawFocusRect(hDCb, (const RECT *)(v3 + 1956));
          *(_WORD *)(v3 + 2232) |= 0x10u;
        }
      }
      else
      {
        if ( *(_BYTE *)(v3 + 2232) & 0x10 )
          DrawFocusRect(hDCb, (const RECT *)(v3 + 1956));
        *(_WORD *)(v3 + 2232) ^= (*(_WORD *)(v3 + 2232) ^ 16 * FUpdateRcDayCur(v3, pt)) & 0x10;
        v6 = *(_WORD *)(v3 + 2232);
        if ( v6 & 0x10 )
        {
          if ( (char)v6 < 0 && FGetDateForPt(v3, pt, (int)&v8, 0, 0, 0, 0) )
            MCHandleMultiSelect(v3, (int)&v8);
          DrawFocusRect(hDCb, (const RECT *)(v3 + 1956));
        }
        else
        {
          *(_DWORD *)(v3 + 1956) = *(_DWORD *)(v3 + 1972);
          *(_DWORD *)(v3 + 1960) = *(_DWORD *)(v3 + 1976);
          *(_DWORD *)(v3 + 1964) = *(_DWORD *)(v3 + 1980);
          *(_DWORD *)(v3 + 1968) = *(_DWORD *)(v3 + 1984);
        }
      }
      ReleaseDC(*(HWND *)v3, hDCb);
    }
  }
  return 0;
}

//----- (6F7AD0C1) --------------------------------------------------------
int __stdcall FScrollIntoView(int a1)
{
  unsigned __int16 v1; // ax@2
  int v2; // edx@2
  unsigned __int16 v3; // si@4
  unsigned __int16 v4; // ax@7
  unsigned __int16 v5; // dx@7
  int v6; // eax@10
  int v7; // eax@12

  if ( *(_BYTE *)(a1 + 8) & 2 )
  {
    v1 = *(_WORD *)(a1 + 1700);
    LOWORD(v2) = *(_WORD *)(a1 + 1702);
  }
  else
  {
    v1 = *(_WORD *)(a1 + 1684);
    LOWORD(v2) = *(_WORD *)(a1 + 1686);
  }
  v3 = *(_WORD *)(a1 + 1796);
  if ( v1 < v3 || v1 == v3 && (unsigned __int16)v2 < *(_WORD *)(a1 + 1798) )
  {
    v6 = 12 * (v1 - v3) - *(_WORD *)(a1 + 1798);
    v2 = (unsigned __int16)v2;
  }
  else
  {
    v4 = *(_WORD *)(a1 + 1684);
    v5 = *(_WORD *)(a1 + 1812);
    if ( v4 <= v5 && (v4 != v5 || *(_WORD *)(a1 + 1686) <= *(_WORD *)(a1 + 1814)) )
      return 0;
    v6 = 12 * (v4 - v5) - *(_WORD *)(a1 + 1814);
    v2 = *(_WORD *)(a1 + 1686);
  }
  v7 = v2 + v6;
  if ( v7 )
    return FIncrStartMonth(a1, v7, 1);
  return 0;
}

//----- (6F7AD17B) --------------------------------------------------------
int __stdcall DatePickWndProc(HWND hWnd, UINT Msg, int a3, LPARAM lParam)
{
  int v5; // eax@3
  int v6; // ebx@3
  BOOL v7; // edx@15
  HWND v8; // eax@16
  unsigned int v9; // eax@20
  int v10; // ecx@20
  int v12; // esi@44
  bool v13; // sf@44
  int v14; // edi@45
  HWND v15; // ebx@64
  int v16; // eax@67
  HWND v17; // esi@101
  HDC v18; // eax@101
  bool v19; // zf@114
  HWND v20; // ST08_4@120
  int v21; // eax@125
  LPARAM v22; // edi@126
  int v23; // edi@128
  int v24; // edi@136
  STRSAFE_LPWSTR v25; // esi@137
  void *v26; // esi@137
  HWND v27; // esi@138
  int v28; // esi@139
  int v29; // esi@139
  const wchar_t *v30; // esi@140
  WPARAM v31; // eax@145
  int v32; // esi@146
  HWND v33; // ebx@146
  WPARAM v34; // eax@153
  HWND v35; // ebx@153
  LPARAM v36; // [sp+8h] [bp-178h]@26
  struct tagRECT rect; // [sp+14h] [bp-16Ch]@39
  STRSAFE_LPCWSTR pszSrc; // [sp+24h] [bp-15Ch]@45
  LPARAM v39; // [sp+28h] [bp-158h]@1
  STRSAFE_LPWSTR pszDest; // [sp+2Ch] [bp-154h]@44
  HWND hWndParent; // [sp+30h] [bp-150h]@1
  int v42; // [sp+34h] [bp-14Ch]@1
  WPARAM wParam; // [sp+38h] [bp-148h]@1
  struct tagPAINTSTRUCT Paint; // [sp+3Ch] [bp-144h]@101
  wchar_t v45; // [sp+7Ch] [bp-104h]@45

  v42 = 0;
  hWndParent = hWnd;
  wParam = a3;
  v39 = lParam;
  if ( Msg == 129 )
    return (int)DPNcCreateHandler(hWnd);
  v5 = GetWindowLongW(hWnd, 0);
  v6 = v5;
  if ( !v5 )
    return DefWindowProcW(hWndParent, Msg, wParam, lParam);
  if ( Msg <= 0x1A )
  {
    if ( Msg == 26 )
    {
      if ( !lParam || !StrCmpICW(lParam, (int)L"Intl") )
        DPHandleLocaleChange(v6);
      return v42;
    }
    if ( Msg <= 0xC )
    {
      if ( Msg == 12 )
        return -1;
      if ( Msg != 1 )
      {
        if ( Msg == 2 )
        {
          CCDestroyWindow();
          DPDestroyHandler(hWndParent, (HLOCAL)v6, wParam, lParam);
          return v42;
        }
        if ( Msg == 5 )
        {
LABEL_105:
          if ( Msg == 4095 )
          {
            GetClientRect(*(HWND *)v5, &rect);
          }
          else
          {
            rect.left = 0;
            rect.top = 0;
            rect.right = (signed __int16)lParam;
            rect.bottom = SHIWORD(lParam);
          }
          DPRecomputeSizing(v6, (int)&rect);
          InvalidateRect(*(HWND *)v6, 0, 1);
          UpdateWindow(*(HWND *)v6);
          return v42;
        }
        if ( Msg > 6 )
        {
          if ( Msg <= 8 )
          {
            if ( (Msg == 7) != ((*(_DWORD *)(v5 + 296) >> 2) & 1) )
            {
              v9 = *(_DWORD *)(v5 + 296) & 0xFFFFFFFB | 4 * (Msg == 7);
              v10 = *(_DWORD *)(v6 + 152);
              *(_DWORD *)(v6 + 296) = v9;
              if ( v10 < 0 )
              {
                if ( *(_BYTE *)(v6 + 8) & 2 )
                {
                  *(_DWORD *)(v6 + 296) = ((Msg == 7) << 7) | v9 & 0xFFFFFF7F;
                  InvalidateRect(*(HWND *)v6, (const RECT *)(v6 + 240), 1);
                }
                else if ( Msg == 7 )
                {
                  SECIncrFocus(v6, 1);
                }
              }
              else
              {
                InvalidateScrollRect(*(HWND *)v6, *(_DWORD *)(v6 + 180) + 60 * v10 + 4, *(_DWORD *)(v6 + 148));
              }
              CCSendNotify(v6, (Msg == 7) - 8, (LPARAM)&v36);
            }
            if ( Msg == 7 )
            {
              SECSafeSetCurSubed(v6, *(_DWORD *)(v6 + 288));
            }
            else
            {
              *(_DWORD *)(v6 + 288) = *(_DWORD *)(v6 + 152);
              SECSetCurSubed(v6, -1);
            }
            return v42;
          }
          if ( Msg == 10 )
          {
            v7 = wParam != 0;
            if ( (*(_DWORD *)(v5 + 296) & 1) != v7 )
            {
              *(_DWORD *)(v5 + 296) ^= ((unsigned __int8)*(_DWORD *)(v5 + 296) ^ (unsigned __int8)v7) & 1;
              v8 = *(HWND *)(v5 + 36);
              if ( v8 )
                EnableWindow(v8, v7);
              InvalidateRect(*(HWND *)v6, 0, 1);
            }
            return v42;
          }
        }
        goto LABEL_157;
      }
      CCCreateWindow();
      return DPCreateHandler(v6, hWndParent, lParam);
    }
    if ( Msg == 13 )
    {
      if ( lParam && wParam )
        *(_WORD *)lParam = 0;
      else
        Msg = 14;
    }
    else if ( Msg != 14 )
    {
      if ( Msg != 15 )
      {
        if ( Msg != 20 )
        {
          if ( Msg == 21 )
          {
            InitGlobalColors();
            return v42;
          }
          goto LABEL_157;
        }
        if ( !(*(_BYTE *)(v5 + 296) & 1) )
        {
          GetClipBox((HDC)wParam, &rect);
          FillRectClr((HDC)wParam, &rect, g_clrBtnFace);
          return v42;
        }
        return DefWindowProcW(hWndParent, Msg, wParam, lParam);
      }
LABEL_99:
      if ( wParam )
      {
        DPPaint(v5, (HDC)wParam);
      }
      else
      {
        v17 = *(HWND *)v5;
        v18 = BeginPaint(*(HWND *)v5, &Paint);
        DPPaint(v6, v18);
        EndPaint(v17, &Paint);
      }
      return v42;
    }
    v12 = *(_DWORD *)(v5 + 180);
    v19 = *(_DWORD *)(v5 + 156) == 0;
    v13 = *(_DWORD *)(v5 + 156) < 0;
    pszDest = (STRSAFE_LPWSTR)lParam;
    hWndParent = 0;
    v39 = 0;
    if ( !v13 && !v19 )
    {
      do
      {
        pszSrc = SECFormatSubed(v6 + 120, v12, &v45, 0x80u);
        v14 = lstrlenW(pszSrc);
        if ( Msg == 13 )
        {
          if ( (unsigned int)((char *)hWndParent + v14) >= wParam )
            return (int)hWndParent;
          StringCchCopyW(pszDest, wParam - (_DWORD)hWndParent, pszSrc);
          pszDest += v14;
        }
        hWndParent = (HWND)((char *)hWndParent + v14);
        ++v39;
        v12 += 60;
      }
      while ( v39 < *(_DWORD *)(v6 + 156) );
    }
    return (int)hWndParent;
  }
  if ( Msg > 0x318 )
  {
    if ( Msg <= 0x1032 )
    {
      if ( Msg != 4146 )
      {
        switch ( Msg )
        {
          case 0xFFFu:
            goto LABEL_105;
          case 0x1001u:
            if ( *(_BYTE *)(v5 + 296) & 0x40 )
            {
              SECSaveResetSubeditEdit(v5, 0);
              SECGetSystemtime(v6 + 120, lParam);
              v42 = 0;
            }
            else
            {
              v42 = 1;
            }
            return v42;
          case 0x1002u:
            if ( wParam == 1 )
            {
              v19 = (*(_BYTE *)(v5 + 8) & 2) == 0;
            }
            else
            {
              if ( wParam )
                return v42;
              v19 = IsValidSystemtime(lParam) == 0;
            }
            if ( !v19 )
            {
              SECSaveResetSubeditEdit(v6, 1);
              *(_DWORD *)(v6 + 296) |= 8u;
              if ( *(_BYTE *)(v6 + 8) & 2 )
              {
                if ( wParam == 1 || *(_DWORD *)(v6 + 296) & 0x40 )
                {
                  SECSetCurSubed(v6, -1);
                  *(_DWORD *)(v6 + 296) |= 0x80u;
                }
                v20 = *(HWND *)v6;
                *(_DWORD *)(v6 + 296) ^= (*(_DWORD *)(v6 + 296) ^ ((wParam != 1) << 6)) & 0x40;
                InvalidateRect(v20, 0, 1);
              }
              if ( !wParam )
              {
                *(_DWORD *)(v6 + 296) |= 8u;
                DPSetDate(v6, lParam, 0);
                *(_DWORD *)(v6 + 296) &= 0xFFFFFFF7;
              }
              v42 = 1;
              *(_DWORD *)(v6 + 296) &= 0xFFFFFFF7;
            }
            break;
          case 0x1003u:
            memset((void *)lParam, 0, 0x20u);
            v21 = *(_DWORD *)(v5 + 292);
            v42 = v21;
            if ( v21 & 1 )
            {
              v22 = v39;
              *(_DWORD *)v39 = *(_DWORD *)(v6 + 72);
              v22 += 4;
              *(_DWORD *)v22 = *(_DWORD *)(v6 + 76);
              v22 += 4;
              *(_DWORD *)v22 = *(_DWORD *)(v6 + 80);
              *(_DWORD *)(v22 + 4) = *(_DWORD *)(v6 + 84);
            }
            if ( v21 & 2 )
            {
              v23 = v39 + 16;
              *(_DWORD *)v23 = *(_DWORD *)(v6 + 88);
              v23 += 4;
              *(_DWORD *)v23 = *(_DWORD *)(v6 + 92);
              v23 += 4;
              *(_DWORD *)v23 = *(_DWORD *)(v6 + 96);
              *(_DWORD *)(v23 + 4) = *(_DWORD *)(v6 + 100);
            }
            return v42;
          case 0x1004u:
            pszDest = (STRSAFE_LPWSTR)lParam;
            if ( !(wParam & 1) )
              pszDest = (STRSAFE_LPWSTR)c_stEpoch;
            if ( wParam & 2 )
              hWndParent = (HWND)(lParam + 16);
            else
              hWndParent = (HWND)c_stArmageddon;
            if ( IsValidDate((int)pszDest) && IsValidDate((int)hWndParent) )
            {
              *(_DWORD *)(v6 + 292) = wParam & 3;
              v24 = v6 + 72;
              if ( CmpDate(v6 + 72, v6 + 88) > 0 )
              {
                v27 = hWndParent;
                *(_DWORD *)v24 = *(_DWORD *)hWndParent;
                ++v27;
                *(_DWORD *)(v6 + 76) = *(_DWORD *)v27;
                ++v27;
                *(_DWORD *)(v6 + 80) = *(_DWORD *)v27;
                *(_DWORD *)(v6 + 84) = *((_DWORD *)v27 + 1);
                v26 = pszDest;
              }
              else
              {
                v25 = pszDest;
                *(_DWORD *)v24 = *(_DWORD *)pszDest;
                v25 += 2;
                *(_DWORD *)(v6 + 76) = *(_DWORD *)v25;
                v25 += 2;
                *(_DWORD *)(v6 + 80) = *(_DWORD *)v25;
                *(_DWORD *)(v6 + 84) = *((_DWORD *)v25 + 1);
                v26 = hWndParent;
              }
              *(_DWORD *)(v6 + 88) = *(_DWORD *)v26;
              v28 = (int)((char *)v26 + 4);
              *(_DWORD *)(v6 + 92) = *(_DWORD *)v28;
              v28 += 4;
              *(_DWORD *)(v6 + 96) = *(_DWORD *)v28;
              *(_DWORD *)(v6 + 100) = *(_DWORD *)(v28 + 4);
              v29 = v6 + 296;
              *(_DWORD *)v29 |= 8u;
              DPSetDate(v6, v6 + 160, 1);
              *(_DWORD *)v29 &= 0xFFFFFFF7;
              v42 = 1;
            }
            return v42;
          case 0x1005u:
            v30 = 0;
            if ( lParam && *(_BYTE *)lParam )
              v30 = (const wchar_t *)ProduceWFromA(*(_DWORD *)(v5 + 20), (LPCSTR)lParam);
            v42 = DTM_OnSetFormat(v6, v30);
            if ( v30 )
              FreeProducedString((HLOCAL)v30);
            return v42;
          case 0x1006u:
            v31 = wParam;
            if ( wParam >= 6 )
              return -1;
            v32 = *(_DWORD *)(v6 + 4 * wParam + 48);
            *(_DWORD *)(v6 + 4 * wParam + 48) = lParam;
            v33 = *(HWND *)(v6 + 40);
            if ( v33 )
              SendMessageW(v33, 0x100Au, v31, lParam);
            return v32;
          case 0x1007u:
            if ( wParam >= 6 )
              return -1;
            return *(_DWORD *)(v5 + 4 * wParam + 48);
          case 0x1008u:
            return *(_DWORD *)(v5 + 40);
          case 0x1009u:
            v34 = wParam;
            *(_DWORD *)(v6 + 44) = wParam;
            v35 = *(HWND *)(v6 + 40);
            if ( v35 )
              SendMessageW(v35, 0x30u, v34, lParam);
            return v42;
          case 0x100Au:
            return *(_DWORD *)(v5 + 44);
          default:
            goto LABEL_157;
        }
        return v42;
      }
      return DTM_OnSetFormat(v5, (STRSAFE_LPCWSTR)lParam);
    }
  }
  else
  {
    if ( Msg == 792 )
      goto LABEL_99;
    if ( Msg > 0x7D )
    {
      if ( Msg == 135 )
        return 129;
      if ( Msg == 256 )
      {
        if ( *(_BYTE *)(v5 + 296) & 0x20 )
        {
          SendMessageW(*(HWND *)(v5 + 40), 0x100u, wParam, lParam);
          return 0;
        }
        return DPHandleKeydown((HDC)v5, wParam, lParam);
      }
      if ( Msg == 257 )
      {
        if ( *(_BYTE *)(v5 + 296) & 0x20 )
          SendMessageW(*(HWND *)(v5 + 40), 0x101u, wParam, lParam);
        return v42;
      }
      if ( Msg == 258 )
        return DPHandleChar(v5, wParam, lParam);
      if ( Msg == 260 )
      {
        if ( wParam != 40 || *(_BYTE *)(v5 + 296) & 2 )
          return DefWindowProcW(hWndParent, Msg, wParam, lParam);
        DPLBD_MonthCal((HDC)v5, 0);
        return v42;
      }
      if ( Msg == 513 )
      {
        DPLButtonDown((HDC)v5, wParam, lParam);
        return v42;
      }
    }
    else
    {
      if ( Msg == 125 )
        return DPOnStyleChanged(v5, wParam, lParam);
      if ( Msg == 48 )
      {
        DPHandleSetFont(v5, (HANDLE)wParam, (unsigned __int16)lParam);
        return v42;
      }
      if ( Msg == 49 )
        return *(_DWORD *)(v5 + 128);
      if ( Msg == 78 )
      {
        v16 = *(_DWORD *)(lParam + 8);
        if ( v16 == -749 || v16 == -746 )
        {
          if ( !DPSetDate(v6, lParam + 12, 1) )
            MessageBeep(0x10u);
          *(_DWORD *)(v6 + 296) ^= (*(_DWORD *)(v6 + 296) ^ 32 * (*(_DWORD *)(lParam + 8) == -749)) & 0x20;
        }
        else if ( v16 == -722 && wParam == 1000 )
        {
          if ( !(*(_BYTE *)(v6 + 296) & 4) )
            SetFocus(*(HWND *)v6);
          SECSaveResetSubeditEdit(v6, 1);
          if ( SECIncrementSubedit(v6 + 120, -*(_DWORD *)(lParam + 16)) )
            DPNotifyDateChange(v6);
        }
        return v42;
      }
      if ( Msg == 85 )
        return CIHandleNotifyFormat(v5, lParam);
      if ( Msg == 123 )
      {
        v15 = *(HWND *)(v5 + 40);
        if ( v15 )
          return SendMessageW(v15, 0x7Bu, wParam, lParam);
        return DefWindowProcW(hWndParent, Msg, wParam, lParam);
      }
      if ( Msg == 124 )
        return DPOnStyleChanging(v5, wParam, lParam);
    }
  }
LABEL_157:
  if ( !CCWndProc(v5, Msg, wParam, lParam, (int)&v42) )
    return DefWindowProcW(hWndParent, Msg, wParam, lParam);
  return v42;
}
// 6F792938: using guessed type int c_stEpoch[4];
// 6F792948: using guessed type int c_stArmageddon[4];
// 6F792984: using guessed type wchar_t aIntl[5];

//----- (6F7ADB2C) --------------------------------------------------------
int __stdcall UpdateLocaleInfo(int a1, void *Dst)
{
  char *v2; // eax@14
  char *v3; // ecx@14
  signed int v4; // edx@14
  char *v5; // eax@16
  char *v6; // ecx@16
  signed int v7; // edx@16
  __int16 v9; // [sp+Ch] [bp-9Ch]@19
  __int16 v10; // [sp+Eh] [bp-9Ah]@19
  __int16 v11; // [sp+12h] [bp-96h]@19
  LPWSTR lpLCData; // [sp+1Ch] [bp-8Ch]@3
  int v13; // [sp+20h] [bp-88h]@3
  signed int DateStr[32]; // [sp+24h] [bp-84h]@1

  MCGetCalendarInfo(a1 + 2212);
  GetDateFormatW(*(_DWORD *)(a1 + 2216), 0, 0, L"MMMM", (LPWSTR)DateStr, 64);
  *(_WORD *)(a1 + 2232) ^= (*(_WORD *)(a1 + 2232) ^ ((unsigned __int16)MCIsDateStringRTL(LOWORD(DateStr[0])) << 14)) & 0x4000;
  MCLoadString(4166, (char *)Dst + 192, 8);
  LOWORD(DateStr[0]) = 0;
  GetLocaleInfoW(*(_DWORD *)(a1 + 2216), 0x1006u, (LPWSTR)DateStr, 16);
  if ( !LOWORD(DateStr[0]) )
    MCLoadString(4167, DateStr, 16);
  MCInsertMarkers((unsigned int)((char *)Dst + 208), DateStr);
  v13 = 0;
  lpLCData = (LPWSTR)((char *)Dst + 248);
  while ( GetLocaleInfoW(*(_DWORD *)(a1 + 2216), v13 + 56, lpLCData, 42) )
  {
    ++v13;
    lpLCData += 42;
    if ( v13 >= 12 )
    {
      v13 = 0;
      lpLCData = (LPWSTR)((char *)Dst + 1256);
      while ( GetLocaleInfoW(0x400u, v13 + 49, lpLCData, 11) )
      {
        ++v13;
        lpLCData += 11;
        if ( v13 >= 7 )
        {
          if ( !(*(_WORD *)(a1 + 2232) & 0x200)
            && GetLocaleInfoW(*(_DWORD *)(a1 + 2216), 0x100Cu, (LPWSTR)DateStr, 64) > 0 )
            *((_DWORD *)Dst + 353) = LOWORD(DateStr[0]) - 48;
          if ( GetLocaleInfoW(*(_DWORD *)(a1 + 2216), 0x100Du, (LPWSTR)DateStr, 64) > 0 )
            *((_DWORD *)Dst + 354) = LOWORD(DateStr[0]) - 48;
          v2 = (char *)Dst + 1420;
          v3 = (char *)Dst + 248;
          v4 = 12;
          do
          {
            *(_DWORD *)v2 = v3;
            v2 += 4;
            v3 += 84;
            --v4;
          }
          while ( v4 );
          v5 = (char *)Dst + 1468;
          v6 = (char *)Dst + 1256;
          v7 = 7;
          do
          {
            *(_DWORD *)v5 = v6;
            v5 += 4;
            v6 += 22;
            --v7;
          }
          while ( v7 );
          MCLoadString(4163, Dst, 32);
          MCLoadString(4164, (char *)Dst + 64, 64);
          if ( *(_DWORD *)(a1 + 1532) )
          {
            v9 = *(_WORD *)(a1 + 1796);
            v10 = *(_WORD *)(a1 + 1798);
            v11 = *(_WORD *)(a1 + 1802);
            MCUpdateStartEndDates(a1, (int)&v9);
          }
          return 1;
        }
      }
      return 0;
    }
  }
  return 0;
}

//----- (6F7ADDAF) --------------------------------------------------------
int __stdcall MonthCal_OnPaint(HGDIOBJ a1, HDC hdc)
{
  int result; // eax@2
  HDC v3; // eax@3
  struct tagPAINTSTRUCT Paint; // [sp+4h] [bp-44h]@3

  if ( hdc )
  {
    result = MCPaint(a1, hdc);
  }
  else
  {
    v3 = BeginPaint(*(HWND *)a1, &Paint);
    MCPaint(a1, v3);
    result = EndPaint(*(HWND *)a1, &Paint);
  }
  return result;
}

//----- (6F7ADE08) --------------------------------------------------------
int __stdcall MCCreateHandler(LPCWSTR lpNewItem, WPARAM wParam, int a3)
{
  int result; // eax@2
  int v4; // ebx@3
  int v5; // ecx@3
  bool v6; // zf@3
  HWND v7; // eax@5
  LRESULT v8; // eax@6
  const WCHAR v9; // ax@8
  int v10; // ecx@8
  const WCHAR v11; // [sp+4h] [bp-10h]@8
  unsigned __int16 v12; // [sp+6h] [bp-Eh]@8
  const WCHAR v13; // [sp+Ah] [bp-Ah]@8

  if ( *(_DWORD *)(a3 + 32) & 0xFE00 )
  {
    result = -1;
  }
  else
  {
    v4 = (int)lpNewItem;
    CIInitialize((int)lpNewItem, wParam, a3);
    UpdateLocaleInfo(v4, (void *)(v4 + 36));
    v5 = 2 * (*((_DWORD *)lpNewItem + 2) >> 27);
    *((_DWORD *)lpNewItem + 383) = *(_DWORD *)(a3 + 4);
    *(_WORD *)(v4 + 2232) ^= (*(_WORD *)(v4 + 2232) ^ ~(_WORD)v5) & 2;
    *((_DWORD *)lpNewItem + 387) = CreatePen(0, 2, 0xFFu);
    MCReloadMenus(lpNewItem);
    *((_DWORD *)lpNewItem + 408) = c_stEpoch[0];
    *((_DWORD *)lpNewItem + 409) = c_stEpoch[1];
    *((_DWORD *)lpNewItem + 410) = c_stEpoch[2];
    *((_DWORD *)lpNewItem + 411) = c_stEpoch[3];
    *((_DWORD *)lpNewItem + 412) = c_stArmageddon[0];
    *((_DWORD *)lpNewItem + 413) = c_stArmageddon[1];
    *((_DWORD *)lpNewItem + 414) = c_stArmageddon[2];
    *((_DWORD *)lpNewItem + 415) = c_stArmageddon[3];
    GetLocalTime((LPSYSTEMTIME)(lpNewItem + 834));
    v6 = (*((_BYTE *)lpNewItem + 8) & 2) == 0;
    *((_DWORD *)lpNewItem + 421) = *((_DWORD *)lpNewItem + 417);
    *(_DWORD *)(v4 + 1688) = *(_DWORD *)(v4 + 1672);
    *(_DWORD *)(v4 + 1692) = *(_DWORD *)(v4 + 1676);
    *(_DWORD *)(v4 + 1696) = *(_DWORD *)(v4 + 1680);
    if ( !v6 )
    {
      *((_DWORD *)lpNewItem + 425) = *((_DWORD *)lpNewItem + 417);
      *((_DWORD *)lpNewItem + 426) = *((_DWORD *)lpNewItem + 418);
      *((_DWORD *)lpNewItem + 427) = *((_DWORD *)lpNewItem + 419);
      *((_DWORD *)lpNewItem + 428) = *((_DWORD *)lpNewItem + 420);
    }
    *((_DWORD *)lpNewItem + 449) = *((_DWORD *)lpNewItem + 417);
    *((_DWORD *)lpNewItem + 450) = *((_DWORD *)lpNewItem + 418);
    *((_DWORD *)lpNewItem + 451) = *((_DWORD *)lpNewItem + 419);
    *((_DWORD *)lpNewItem + 452) = *((_DWORD *)lpNewItem + 420);
    *((_DWORD *)lpNewItem + 453) = *((_DWORD *)lpNewItem + 417);
    *((_DWORD *)lpNewItem + 454) = *((_DWORD *)lpNewItem + 418);
    *((_DWORD *)lpNewItem + 455) = *((_DWORD *)lpNewItem + 419);
    *((_DWORD *)lpNewItem + 456) = *((_DWORD *)lpNewItem + 420);
    *((_DWORD *)lpNewItem + 441) = *((_DWORD *)lpNewItem + 417);
    *((_DWORD *)lpNewItem + 442) = *((_DWORD *)lpNewItem + 418);
    *((_DWORD *)lpNewItem + 443) = *((_DWORD *)lpNewItem + 419);
    *((_DWORD *)lpNewItem + 444) = *((_DWORD *)lpNewItem + 420);
    *((_DWORD *)lpNewItem + 445) = *((_DWORD *)lpNewItem + 417);
    *((_DWORD *)lpNewItem + 446) = *((_DWORD *)lpNewItem + 418);
    *((_DWORD *)lpNewItem + 447) = *((_DWORD *)lpNewItem + 419);
    *((_DWORD *)lpNewItem + 448) = *((_DWORD *)lpNewItem + 420);
    *((_DWORD *)lpNewItem + 416) = 7;
    v7 = *(HWND *)(a3 + 12);
    if ( !v7 || (v8 = SendMessageW(v7, 0x31u, 0, 0)) == 0 )
      v8 = (LRESULT)GetStockObject(17);
    MCHandleSetFont((int)lpNewItem, (HANDLE)v8, 0);
    v9 = lpNewItem[842];
    v13 = lpNewItem[845];
    v10 = *((_DWORD *)lpNewItem + 460) * *((_DWORD *)lpNewItem + 461);
    v11 = v9;
    v12 = lpNewItem[843];
    if ( v12 <= v10 )
      v12 = 1;
    MCUpdateStartEndDates((int)lpNewItem, (int)&v11);
    *((_DWORD *)lpNewItem + 459) = SetTimer(*(HWND *)lpNewItem, 2u, 0x1D4C0u, 0);
    MCInitColorArray((int)(lpNewItem + 780));
    result = 0;
  }
  return result;
}
// 6F792938: using guessed type int c_stEpoch[4];
// 6F792948: using guessed type int c_stArmageddon[4];

//----- (6F7ADFA8) --------------------------------------------------------
int __stdcall MCSizeHandler(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // edi@1
  int v6; // eax@1
  __int16 v8; // [sp+8h] [bp-10h]@1
  __int16 v9; // [sp+Ah] [bp-Eh]@1
  __int16 v10; // [sp+Eh] [bp-Ah]@1

  v2 = a1;
  MCRecomputeSizing(a1, a2);
  v3 = *(_WORD *)(a1 + 1684);
  v4 = *(_DWORD *)(v2 + 1840) * *(_DWORD *)(v2 + 1844);
  v8 = *(_WORD *)(a1 + 1796);
  v5 = v4 - *(_DWORD *)(a1 + 1828);
  v9 = *(_WORD *)(a1 + 1798);
  v10 = *(_WORD *)(a1 + 1802);
  v6 = *(_WORD *)(v2 + 1814) + 12 * (*(_WORD *)(v2 + 1812) - v3) - *(_WORD *)(v2 + 1686);
  if ( -v5 > v6 )
  {
    IncrSystemTime((int)&v8, (int)&v8, -(v5 + v6), 2);
    v6 = 0;
  }
  if ( v5 && v6 + v5 >= *(_WORD *)(a1 + 1798) - 1 )
    v9 = 1;
  MCUpdateStartEndDates(a1, (int)&v8);
  InvalidateRect(*(HWND *)a1, 0, 1);
  UpdateWindow(*(HWND *)a1);
  return 0;
}

//----- (6F7AE076) --------------------------------------------------------
signed int __stdcall MCSetDate(int a1, int a2)
{
  signed int result; // eax@2
  bool v3; // zf@4

  if ( CmpDate(a2, a1 + 1632) < 0 || CmpDate(a2, a1 + 1648) > 0 )
  {
    result = 0;
  }
  else
  {
    v3 = (*(_BYTE *)(a1 + 8) & 2) == 0;
    *(_DWORD *)(a1 + 1684) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 1688) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 1692) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 1696) = *(_DWORD *)(a2 + 12);
    if ( !v3 )
    {
      *(_DWORD *)(a1 + 1700) = *(_DWORD *)a2;
      *(_DWORD *)(a1 + 1704) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 1708) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 1712) = *(_DWORD *)(a2 + 12);
    }
    FScrollIntoView(a1);
    MCNotifySelChange(a1, -749);
    MCUpdateRcDayCur(a1, a2);
    result = 1;
  }
  return result;
}

//----- (6F7AE0F0) --------------------------------------------------------
BOOL __stdcall MCGotoToday(int a1)
{
  bool v1; // zf@1

  v1 = (*(_BYTE *)(a1 + 8) & 2) == 0;
  *(_DWORD *)(a1 + 1972) = *(_DWORD *)(a1 + 1956);
  *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 1960);
  *(_DWORD *)(a1 + 1980) = *(_DWORD *)(a1 + 1964);
  *(_DWORD *)(a1 + 1984) = *(_DWORD *)(a1 + 1968);
  if ( v1 )
    InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1972), 0);
  else
    MCInvalidateDates(a1, a1 + 1684, a1 + 1700);
  MCSetDate(a1, a1 + 1668);
  MCNotifySelChange(a1, -746);
  InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1956), 0);
  return UpdateWindow(*(HWND *)a1);
}

//----- (6F7AE16F) --------------------------------------------------------
int __stdcall MCContextMenu(int a1, int a2, int a3)
{
  __int16 v3; // ax@1
  __int64 v4; // rax@6
  __int64 v5; // rax@6
  struct tagPOINT Point; // [sp+4h] [bp-8h]@4

  v3 = *(_WORD *)(a1 + 2232);
  if ( v3 & 2 && !(*(_BYTE *)(a1 + 8) & 0x10) && !(v3 & 4) )
  {
    Point.x = (signed __int16)a3;
    Point.y = SHIWORD(a3);
    if ( (signed __int16)a3 == -1 && SHIWORD(a3) == (signed __int16)a3 )
    {
      v4 = *(_DWORD *)(a1 + 1956) + *(_DWORD *)(a1 + 1964);
      Point.x = ((signed int)v4 - HIDWORD(v4)) >> 1;
      v5 = *(_DWORD *)(a1 + 1960) + *(_DWORD *)(a1 + 1968);
      Point.y = ((signed int)v5 - HIDWORD(v5)) >> 1;
      ClientToScreen(*(HWND *)a1, &Point);
    }
    if ( TrackPopupMenu(*(HMENU *)(a1 + 1624), 0x182u, Point.x, Point.y, 0, *(HWND *)a1, 0) >= 1 )
      MCGotoToday(a1);
  }
  return 0;
}

//----- (6F7AE210) --------------------------------------------------------
int __stdcall MCLButtonDown(DWORD dwExStyle, int a2, int nPos)
{
  int v3; // ebx@1
  bool v4; // zf@2
  POINT v5; // ST28_8@4
  signed int v6; // eax@5
  HWND v7; // ST2C_4@5
  HDC v8; // edi@5
  POINT v9; // ST28_8@7
  HDC v10; // esi@15
  BOOL v11; // eax@21
  unsigned int v12; // eax@24
  int v13; // ecx@25
  HWND v14; // eax@34
  HWND v15; // edi@34
  WPARAM v16; // ST28_4@35
  int v17; // eax@35
  int v18; // ecx@35
  __int16 v19; // si@35
  int v20; // eax@35
  int v21; // edx@35
  int v22; // esi@38
  HWND v23; // eax@40
  UINT v24; // eax@48
  LRESULT v25; // eax@70
  HWND v26; // ST2C_4@72
  struct tagMSG Msg; // [sp+4h] [bp-80h]@47
  RECT v29; // [sp+20h] [bp-64h]@20
  RECT rc; // [sp+30h] [bp-54h]@17
  struct tagPOINT Points; // [sp+40h] [bp-44h]@45
  int v32; // [sp+48h] [bp-3Ch]@45
  int v33; // [sp+4Ch] [bp-38h]@45
  int v34; // [sp+50h] [bp-34h]@13
  __int16 v35; // [sp+56h] [bp-2Eh]@15
  RECT v36; // [sp+60h] [bp-24h]@20
  POINT pt; // [sp+70h] [bp-14h]@2
  HWND v38; // [sp+78h] [bp-Ch]@42
  HWND v39; // [sp+7Ch] [bp-8h]@34
  HWND hWnd; // [sp+80h] [bp-4h]@40

  v3 = dwExStyle;
  if ( !(*(_BYTE *)(dwExStyle + 2232) & 2) )
    return 0;
  v4 = (*(_BYTE *)(dwExStyle + 8) & 2) == 0;
  pt.x = (signed __int16)nPos;
  pt.y = SHIWORD(nPos);
  if ( !v4 )
  {
    if ( a2 & 4 )
    {
      v5.y = SHIWORD(nPos);
      v5.x = (signed __int16)nPos;
      if ( !PtInRect((const RECT *)(dwExStyle + 1956), v5) )
      {
        SetCapture(*(HWND *)v3);
        *(_WORD *)(v3 + 2232) |= 4u;
        v6 = CmpDate(v3 + 1748, v3 + 1684);
        v7 = *(HWND *)v3;
        *(_WORD *)(v3 + 2232) = *(_WORD *)(v3 + 2232) ^ (*(_WORD *)(v3 + 2232) ^ ((v6 == 0) << 8)) & 0x100 | 0x80;
        v8 = GetDC(v7);
        DrawFocusRect(v8, (const RECT *)(v3 + 1956));
        *(_WORD *)(v3 + 2232) |= 0x10u;
        ReleaseDC(*(HWND *)v3, v8);
        MCMouseMove((HDC)v3, a2, nPos);
        return 0;
      }
    }
  }
  if ( *(_BYTE *)(v3 + 2232) & 4 )
    return 0;
  SetCapture(*(HWND *)v3);
  v9 = pt;
  *(_WORD *)(v3 + 2232) |= 4u;
  *(_WORD *)(v3 + 2232) ^= (*(_WORD *)(v3 + 2232) ^ 8 * PtInRect((const RECT *)(v3 + 1848), v9)) & 8;
  if ( *(_WORD *)(v3 + 2232) & 8 || PtInRect((const RECT *)(v3 + 1864), pt) )
  {
    MCHandleTimer(v3, 1);
    return 0;
  }
  v4 = (*(_BYTE *)(v3 + 8) & 2) == 0;
  *(_DWORD *)(v3 + 1972) = *(_DWORD *)(v3 + 1956);
  *(_DWORD *)(v3 + 1976) = *(_DWORD *)(v3 + 1960);
  *(_DWORD *)(v3 + 1980) = *(_DWORD *)(v3 + 1964);
  *(_DWORD *)(v3 + 1984) = *(_DWORD *)(v3 + 1968);
  if ( !v4 )
  {
    *(_WORD *)(v3 + 1716) = *(_WORD *)(v3 + 1684);
    *(_WORD *)(v3 + 1718) = *(_WORD *)(v3 + 1686);
    *(_WORD *)(v3 + 1722) = *(_WORD *)(v3 + 1690);
    *(_WORD *)(v3 + 1732) = *(_WORD *)(v3 + 1700);
    *(_WORD *)(v3 + 1734) = *(_WORD *)(v3 + 1702);
    *(_WORD *)(v3 + 1738) = *(_WORD *)(v3 + 1706);
  }
  if ( FUpdateRcDayCur(v3, pt) )
  {
    if ( *(_BYTE *)(v3 + 8) & 2 && FGetDateForPt(v3, pt, (int)&v34, 0, 0, 0, 0) )
      MCHandleMultiSelect(v3, (int)&v34);
    v10 = GetDC(*(HWND *)v3);
    DrawFocusRect(v10, (const RECT *)(v3 + 1956));
    *(_WORD *)(v3 + 2232) |= 0x10u;
    ReleaseDC(*(HWND *)v3, v10);
    *(_WORD *)(v3 + 1748) = v34;
    *(_WORD *)(v3 + 1750) = HIWORD(v34);
    *(_WORD *)(v3 + 1754) = v35;
    return 0;
  }
  if ( !(*(_BYTE *)(v3 + 8) & 0x10) )
  {
    MCGetTodayBtnRect(v3, (int)&rc);
    if ( PtInRect(&rc, pt) )
    {
      CCReleaseCapture(v3);
      *(_WORD *)(v3 + 2232) &= 0xFFFBu;
      MCGotoToday(v3);
      return 0;
    }
  }
  if ( !FGetOffsetForPt(v3, pt, (int)&a2) )
    return 0;
  GetYrMoForOffset(v3, a2, (int)&nPos, (int)&dwExStyle);
  MCGetTitleRcsForOffset(v3, a2, (int)&v29, (int)&v36);
  a2 = 0;
  if ( PtInRect(&v29, pt) )
  {
    CCReleaseCapture(v3);
    *(_WORD *)(v3 + 2232) &= 0xFFFBu;
    ClientToScreen(*(HWND *)v3, &pt);
    v11 = TrackPopupMenu(*(HMENU *)(v3 + 1628), 0x182u, pt.x, pt.y, 0, *(HWND *)v3, 0);
    if ( v11 < 1 )
      return 0;
    a2 = v11 - dwExStyle;
    goto LABEL_74;
  }
  if ( !PtInRect(&v36, pt) )
    return 0;
  dwExStyle = 0;
  CCReleaseCapture(v3);
  *(_WORD *)(v3 + 2232) &= 0xFFFBu;
  v12 = ((unsigned int)*(_WORD *)(v3 + 2232) >> 14) & 1;
  if ( v12 )
  {
    v13 = v36.right - *(_DWORD *)(v3 + 1600) - 6;
    v36.left = v36.right - *(_DWORD *)(v3 + 1600) - 6;
  }
  else
  {
    v13 = v36.left;
    v36.right = *(_DWORD *)(v3 + 1600) + v36.left + 6;
  }
  --v36.top;
  ++v36.bottom;
  if ( (_WORD)v12 )
  {
    if ( !(GetWindowLongW(*(HWND *)v3, -20) & 0x400000) )
      goto LABEL_32;
    v13 = v36.left;
  }
  if ( !(*(_WORD *)(v3 + 2232) & 0x4000) )
  {
    if ( !(GetWindowLongW(*(HWND *)v3, -20) & 0x400000) )
    {
LABEL_33:
      v13 = v36.left;
      goto LABEL_34;
    }
LABEL_32:
    dwExStyle = 0x2000;
    goto LABEL_33;
  }
LABEL_34:
  v14 = CreateWindowExW(
          dwExStyle,
          L"EDIT",
          0,
          0x50800880u,
          v13,
          v36.top,
          v36.right - v13,
          v36.bottom - v36.top,
          *(HWND *)v3,
          0,
          *(HINSTANCE *)(v3 + 1532),
          0);
  v15 = v14;
  v39 = v14;
  if ( !v14 )
    return 0;
  v16 = *(_DWORD *)(v3 + 1556);
  *(_DWORD *)(v3 + 1536) = v14;
  SendMessageW(v14, 0x30u, v16, 0);
  SendMessageW(v15, 0xD3u, 3u, 65537);
  MCUpdateEditYear(v3);
  v17 = *(_WORD *)(v3 + 1632);
  v18 = *(_DWORD *)(v3 + 2220);
  v19 = *(_WORD *)(v3 + 2232);
  nPos += v18;
  v20 = v18 + v17;
  v21 = 9999;
  if ( v19 & 0x1000 )
    v21 = v18 + *(_WORD *)(v3 + 1648);
  if ( v19 & 0x4000 )
    v22 = v36.top - v36.bottom + v36.left - 1;
  else
    v22 = v36.right + 1;
  v23 = CreateUpDownControl(
          0x508000A0u,
          v22,
          v36.top,
          v36.bottom - v36.top,
          v36.bottom - v36.top,
          *(HWND *)v3,
          1,
          *(HINSTANCE *)(v3 + 1532),
          v15,
          v21,
          v20,
          nPos);
  hWnd = v23;
  if ( !v23 )
  {
    DestroyWindow(v15);
    return 0;
  }
  *(_DWORD *)(v3 + 1540) = v23;
  v38 = SetFocus(v15);
  if ( *(_WORD *)(v3 + 2232) & 0x4000 )
    v36.left = v36.top - v36.bottom + v36.left - 1;
  else
    v36.right += v36.bottom - v36.top + 1;
  MapWindowPoints(*(HWND *)v3, 0, (LPPOINT)&v36, 2u);
  Points.x = *(_DWORD *)(v3 + 1988);
  Points.y = *(_DWORD *)(v3 + 1992);
  v32 = *(_DWORD *)(v3 + 1996);
  v33 = *(_DWORD *)(v3 + 2000);
  MapWindowPoints(*(HWND *)v3, 0, &Points, 2u);
  dwExStyle = 1;
  while ( GetFocus() == v39 )
  {
    if ( PeekMessageW(&Msg, 0, 0, 0, 0) )
    {
      v24 = Msg.message;
      if ( Msg.message == 8 || Msg.message >= 0x104 && Msg.message <= 0x107 )
        goto LABEL_80;
      if ( Msg.message == 513
        || Msg.message == 161
        || Msg.message == 516
        || Msg.message == 164
        || Msg.message == 519
        || Msg.message == 167 )
      {
        if ( !PtInRect(&v36, Msg.pt) )
        {
          if ( PtInRect((const RECT *)&Points, Msg.pt) )
            GetMessageW(&Msg, 0, 0, 0);
          break;
        }
        v24 = Msg.message;
      }
      if ( v24 == 18 )
        break;
      if ( v24 == 258 )
      {
        if ( Msg.wParam == 27 )
          goto LABEL_72;
        if ( Msg.wParam == 13 )
LABEL_80:
          dwExStyle = 0;
      }
      GetMessageW(&Msg, 0, 0, 0);
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
    else
    {
      WaitMessage();
    }
    if ( !dwExStyle )
      break;
  }
  v25 = SendMessageW(hWnd, 0x468u, 0, 0);
  if ( !HIWORD(v25) )
    a2 = 12 * ((unsigned __int16)v25 - nPos);
LABEL_72:
  DestroyWindow(hWnd);
  DestroyWindow(v39);
  v26 = *(HWND *)v3;
  *(_DWORD *)(v3 + 1540) = 0;
  *(_DWORD *)(v3 + 1536) = 0;
  UpdateWindow(v26);
  if ( v38 )
    SetFocus(v38);
LABEL_74:
  if ( a2 )
  {
    MCIncrStartMonth(v3, a2, 0);
    MCNotifySelChange(v3, -749);
  }
  return 0;
}

//----- (6F7AE8A6) --------------------------------------------------------
int __stdcall MCLButtonUp(int a1, int a2, int a3)
{
  HWND v3; // ST1C_4@3
  HDC v4; // edi@3
  HDC v5; // edi@5
  HWND v6; // ST18_4@5
  bool v7; // zf@6
  POINT v9; // [sp-8h] [bp-2Ch]@6
  int v10; // [sp+Ch] [bp-18h]@8
  unsigned int v11; // [sp+20h] [bp-4h]@6

  if ( *(_BYTE *)(a1 + 2232) & 4 )
  {
    CCReleaseCapture(a1);
    *(_WORD *)(a1 + 2232) &= 0xFFFBu;
    if ( !*(_DWORD *)(a1 + 1832) )
    {
      if ( *(_WORD *)(a1 + 2232) & 0x10 )
      {
        v5 = GetDC(*(HWND *)a1);
        DrawFocusRect(v5, (const RECT *)(a1 + 1956));
        v6 = *(HWND *)a1;
        *(_WORD *)(a1 + 2232) &= 0xFFEFu;
        ReleaseDC(v6, v5);
      }
      v7 = (*(_BYTE *)(a1 + 8) & 2) == 0;
      v9.y = SHIWORD(a3);
      v9.x = (signed __int16)a3;
      v11 = SHIWORD(a3);
      if ( v7 )
      {
        if ( !FUpdateRcDayCur(a1, v9) )
          return 0;
        if ( !EqualRect((const RECT *)(a1 + 1972), (const RECT *)(a1 + 1956))
          && FGetDateForPt(a1, (POINT)__PAIR__(v11, (signed __int16)a3), (int)&v10, 0, 0, 0, 0) )
        {
          InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1972), 0);
          InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1956), 0);
          MCSetDate(a1, (int)&v10);
        }
      }
      else
      {
        FUpdateRcDayCur(a1, v9);
        if ( !EqualRect((const RECT *)(a1 + 1972), (const RECT *)(a1 + 1956))
          && FGetDateForPt(a1, (POINT)__PAIR__(v11, (signed __int16)a3), (int)&v10, 0, 0, 0, 0) )
          MCHandleMultiSelect(a1, (int)&v10);
        *(_WORD *)(a1 + 2232) &= 0xFF7Fu;
        if ( CmpDate(a1 + 1716, a1 + 1684) || CmpDate(a1 + 1732, a1 + 1700) )
          FScrollIntoView(a1);
      }
      MCNotifySelChange(a1, -746);
      return 0;
    }
    KillTimer(*(HWND *)a1, *(_DWORD *)(a1 + 1832));
    v3 = *(HWND *)a1;
    *(_DWORD *)(a1 + 1832) = 0;
    v4 = GetDC(v3);
    MCPaintArrowBtn(a1, v4, ((unsigned int)*(_WORD *)(a1 + 2232) >> 3) & 1, 0);
    ReleaseDC(*(HWND *)a1, v4);
  }
  return 0;
}

//----- (6F7AEA60) --------------------------------------------------------
signed int __stdcall MCHandleKeydown(int a1, unsigned int a2, int a3)
{
  signed __int16 v3; // ax@9
  __int16 v4; // ax@10
  __int16 v5; // dx@10
  int v6; // ecx@11
  int v7; // edx@12
  signed int result; // eax@14
  __int16 v9; // ax@34
  int v10; // esi@42
  HDC v11; // edi@42
  int v12; // edi@42
  bool v13; // zf@44
  int v14; // edi@44
  int v15; // esi@44
  HWND v16; // ST0C_4@49
  HDC v17; // esi@49
  signed int v18; // [sp-4h] [bp-34h]@26
  char v19; // [sp+Ch] [bp-24h]@42
  int v20; // [sp+10h] [bp-20h]@49
  int v21; // [sp+14h] [bp-1Ch]@49
  int v22; // [sp+18h] [bp-18h]@49
  __int16 v23; // [sp+1Ch] [bp-14h]@9
  unsigned __int16 v24; // [sp+1Eh] [bp-12h]@9
  __int16 v25; // [sp+22h] [bp-Eh]@10
  int v26; // [sp+2Ch] [bp-4h]@1

  v26 = 0;
  if ( a2 > 0x24 )
  {
    if ( a2 == 37 )
    {
      v6 = -1;
    }
    else
    {
      if ( a2 == 38 )
      {
        v6 = -1;
LABEL_26:
        v18 = 4;
LABEL_31:
        v7 = v18;
LABEL_32:
        if ( (char)*(_WORD *)(a1 + 2232) < 0 && *(_WORD *)(a1 + 2232) & 0x100 )
        {
          v23 = *(_WORD *)(a1 + 1700);
          v24 = *(_WORD *)(a1 + 1702);
          v9 = *(_WORD *)(a1 + 1706);
        }
        else
        {
          v23 = *(_WORD *)(a1 + 1684);
          v24 = *(_WORD *)(a1 + 1686);
          v9 = *(_WORD *)(a1 + 1690);
        }
        v25 = v9;
        IncrSystemTime((int)&v23, (int)&v23, v6, v7);
        goto LABEL_37;
      }
      if ( a2 != 39 )
      {
        if ( a2 != 40 )
          return 0;
        v6 = 1;
        goto LABEL_26;
      }
      v6 = 1;
    }
    v18 = 8;
    goto LABEL_31;
  }
  if ( a2 == 36 )
  {
    if ( *(_DWORD *)(a1 + 2204) )
    {
      v23 = *(_WORD *)(a1 + 1796);
      v24 = *(_WORD *)(a1 + 1798);
      v3 = *(_WORD *)(a1 + 1802);
    }
    else
    {
      v23 = *(_WORD *)(a1 + 1684);
      v24 = *(_WORD *)(a1 + 1686);
      v3 = 1;
    }
    goto LABEL_19;
  }
  if ( a2 == 16 )
  {
    result = 1;
    *(_DWORD *)(a1 + 2208) = 1;
    return result;
  }
  if ( a2 == 17 )
  {
    result = 1;
    *(_DWORD *)(a1 + 2204) = 1;
    return result;
  }
  if ( a2 == 33 )
  {
    v6 = -1;
    goto LABEL_12;
  }
  if ( a2 == 34 )
  {
    v6 = 1;
LABEL_12:
    v7 = (*(_DWORD *)(a1 + 2204) == 0) + 1;
    goto LABEL_32;
  }
  if ( a2 != 35 )
    return 0;
  if ( *(_DWORD *)(a1 + 2204) )
  {
    v23 = *(_WORD *)(a1 + 1812);
    v24 = *(_WORD *)(a1 + 1814);
    v3 = *(_WORD *)(a1 + 1818);
  }
  else
  {
    v4 = *(_WORD *)(a1 + 1684);
    v5 = *(_WORD *)(a1 + 1690);
    v24 = *(_WORD *)(a1 + 1686);
    v23 = v4;
    v25 = v5;
    v3 = GetDaysForMonth((unsigned __int16)v4, v24);
  }
LABEL_19:
  v25 = v3;
LABEL_37:
  if ( *(_BYTE *)(a1 + 8) & 2 && *(_DWORD *)(a1 + 2208) )
  {
    *(_WORD *)(a1 + 2232) = *(_WORD *)(a1 + 2232) ^ (*(_WORD *)(a1 + 2232) ^ ((CmpDate(a1 + 1684, a1 + 1748) >= 0) << 8)) & 0x100 | 0x80;
  }
  else
  {
    *(_WORD *)(a1 + 2232) &= 0xFF7Fu;
    *(_WORD *)(a1 + 1748) = v23;
    *(_WORD *)(a1 + 1750) = v24;
    *(_WORD *)(a1 + 1754) = v25;
  }
  if ( *(_BYTE *)(a1 + 2232) & 0x10 )
  {
    v10 = a1 + 1956;
    v11 = GetDC(*(HWND *)a1);
    DrawFocusRect(v11, (const RECT *)(a1 + 1956));
    ReleaseDC(*(HWND *)a1, v11);
    v12 = (int)&v19;
  }
  else
  {
    v10 = a1 + 1956;
    v12 = a1 + 1972;
  }
  v13 = (*(_BYTE *)(a1 + 8) & 2) == 0;
  *(_DWORD *)v12 = *(_DWORD *)v10;
  v15 = v10 + 4;
  v14 = v12 + 4;
  *(_DWORD *)v14 = *(_DWORD *)v15;
  v15 += 4;
  v14 += 4;
  *(_DWORD *)v14 = *(_DWORD *)v15;
  *(_DWORD *)(v14 + 4) = *(_DWORD *)(v15 + 4);
  if ( v13 )
  {
    v26 = MCSetDate(a1, (int)&v23);
    if ( v26 )
    {
      InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1972), 0);
      InvalidateRect(*(HWND *)a1, (const RECT *)(a1 + 1956), 0);
      UpdateWindow(*(HWND *)a1);
    }
  }
  else
  {
    MCHandleMultiSelect(a1, (int)&v23);
    FScrollIntoView(a1);
  }
  if ( *(_BYTE *)(a1 + 2232) & 0x10 )
  {
    *(_DWORD *)(a1 + 1972) = *(_DWORD *)(a1 + 1956);
    *(_DWORD *)(a1 + 1976) = *(_DWORD *)(a1 + 1960);
    v16 = *(HWND *)a1;
    *(_DWORD *)(a1 + 1980) = *(_DWORD *)(a1 + 1964);
    *(_DWORD *)(a1 + 1984) = *(_DWORD *)(a1 + 1968);
    *(_DWORD *)(a1 + 1956) = *(_DWORD *)&v19;
    *(_DWORD *)(a1 + 1960) = v20;
    *(_DWORD *)(a1 + 1964) = v21;
    *(_DWORD *)(a1 + 1968) = v22;
    v17 = GetDC(v16);
    DrawFocusRect(v17, (const RECT *)(a1 + 1956));
    ReleaseDC(*(HWND *)a1, v17);
  }
  return v26;
}

//----- (6F7AED68) --------------------------------------------------------
int __stdcall MonthCalWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax@2
  LONG v5; // ebx@3
  int v6; // ecx@17
  int v7; // eax@20
  int v8; // edx@29
  int v9; // eax@29
  WPARAM v10; // edi@39
  LPARAM v11; // edi@80
  LPARAM v12; // edi@80
  int v13; // esi@80
  int v14; // edi@81
  int v15; // esi@81
  int v16; // esi@86
  int v17; // eax@96
  int v18; // edi@97
  signed __int16 v19; // ax@113
  int v20; // esi@117
  int v21; // esi@120
  LPARAM v22; // ecx@123
  WPARAM v23; // edx@124
  int v24; // eax@126
  int v25; // eax@129
  DWORD v26; // ST0C_4@132
  WPARAM v27; // ebx@135
  int v28; // edi@135
  LPARAM v29; // edi@147
  WPARAM v30; // esi@154
  int v31; // edi@164
  bool v32; // zf@167
  int v33; // edi@167
  int v34; // edi@173
  HWND v35; // [sp-10h] [bp-3Ch]@18
  UINT v36; // [sp-10h] [bp-3Ch]@37
  BOOL v37; // [sp-8h] [bp-34h]@18
  LPARAM v38; // [sp-8h] [bp-34h]@37
  int v39; // [sp-8h] [bp-34h]@80
  int v40; // [sp+8h] [bp-24h]@105
  int v41; // [sp+Ch] [bp-20h]@105
  int v42; // [sp+10h] [bp-1Ch]@105
  int v43; // [sp+14h] [bp-18h]@105
  struct tagRECT Rect; // [sp+18h] [bp-14h]@75
  int v45; // [sp+28h] [bp-4h]@1
  HWND hWnda; // [sp+34h] [bp+8h]@156
  int hWndb; // [sp+34h] [bp+8h]@167
  int wParama; // [sp+3Ch] [bp+10h]@97
  int wParamb; // [sp+3Ch] [bp+10h]@164

  v45 = 0;
  if ( Msg == 129 )
    return MCNcCreateHandler(hWnd);
  v5 = GetWindowLongW(hWnd, 0);
  if ( !v5 )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  if ( Msg > 0x318 )
  {
    switch ( Msg )
    {
      case 0xFFFu:
        goto LABEL_74;
      case 0x1001u:
        if ( *(_BYTE *)(v5 + 8) & 2 || !lParam )
          return v45;
        *(_DWORD *)lParam = 0;
        *(_DWORD *)(lParam + 4) = 0;
        v11 = lParam + 8;
        *(_DWORD *)v11 = 0;
        *(_DWORD *)(v11 + 4) = 0;
        v12 = lParam;
        v13 = v5 + 1684;
        v39 = lParam;
        goto LABEL_81;
      case 0x1002u:
        if ( *(_BYTE *)(v5 + 8) & 2 || !IsValidDate(lParam) )
          return v45;
        if ( !CmpDate(lParam, v5 + 1684) )
          goto LABEL_82;
        *(_DWORD *)(v5 + 1972) = *(_DWORD *)(v5 + 1956);
        *(_DWORD *)(v5 + 1976) = *(_DWORD *)(v5 + 1960);
        *(_DWORD *)(v5 + 1980) = *(_DWORD *)(v5 + 1964);
        *(_DWORD *)(v5 + 1984) = *(_DWORD *)(v5 + 1968);
        v16 = v5 + 2232;
        *(_WORD *)v16 |= 0x40u;
        v45 = MCSetDate(v5, lParam);
        *(_WORD *)v16 &= 0xFFBFu;
        if ( v45 )
        {
          InvalidateRect(*(HWND *)v5, (const RECT *)(v5 + 1972), 0);
          InvalidateRect(*(HWND *)v5, (const RECT *)(v5 + 1956), 0);
        }
        UpdateWindow(*(HWND *)v5);
        return v45;
      case 0x1003u:
        if ( !(*(_BYTE *)(v5 + 8) & 2) )
          goto LABEL_82;
        return *(_DWORD *)(v5 + 1664);
      case 0x1004u:
        if ( *(_BYTE *)(v5 + 8) & 2 && (signed int)wParam >= 1 )
        {
          *(_DWORD *)(v5 + 1664) = wParam;
          v45 = 1;
        }
        return v45;
      case 0x1005u:
        if ( !lParam )
          return v45;
        memset((void *)lParam, 0, 0x20u);
        if ( !(*(_BYTE *)(v5 + 8) & 2) )
          return v45;
        *(_DWORD *)lParam = *(_DWORD *)(v5 + 1684);
        *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 1688);
        *(_DWORD *)(lParam + 8) = *(_DWORD *)(v5 + 1692);
        *(_DWORD *)(lParam + 12) = *(_DWORD *)(v5 + 1696);
        v17 = DowFromDate(lParam);
        lParam += 16;
        v13 = v5 + 1700;
        v12 = lParam;
        v39 = lParam;
        *(_WORD *)(lParam - 12) = (v17 + 1) % 7;
LABEL_81:
        *(_DWORD *)v12 = *(_DWORD *)v13;
        v15 = v13 + 4;
        v14 = v12 + 4;
        *(_DWORD *)v14 = *(_DWORD *)v15;
        v15 += 4;
        v14 += 4;
        *(_DWORD *)v14 = *(_DWORD *)v15;
        *(_DWORD *)(v14 + 4) = *(_DWORD *)(v15 + 4);
        *(_WORD *)(lParam + 4) = (DowFromDate(v39) + 1) % 7;
        goto LABEL_82;
      case 0x1006u:
        v18 = lParam + 16;
        wParama = lParam + 16;
        if ( !(*(_BYTE *)(v5 + 8) & 2) || !IsValidDate(lParam) || !IsValidDate(v18) )
          return v45;
        if ( !IsValidTime(lParam) )
        {
          *(_WORD *)(lParam + 8) = *(_WORD *)(v5 + 1692);
          *(_WORD *)(lParam + 10) = *(_WORD *)(v5 + 1694);
          *(_WORD *)(lParam + 12) = *(_WORD *)(v5 + 1696);
        }
        if ( !IsValidTime(v18) )
        {
          *(_WORD *)(lParam + 24) = *(_WORD *)(v5 + 1708);
          *(_WORD *)(lParam + 26) = *(_WORD *)(v5 + 1710);
          *(_WORD *)(lParam + 28) = *(_WORD *)(v5 + 1712);
        }
        if ( CmpDate(lParam, v18) > 0 )
        {
          v40 = *(_DWORD *)lParam;
          v41 = *(_DWORD *)(lParam + 4);
          v42 = *(_DWORD *)(lParam + 8);
          v43 = *(_DWORD *)(lParam + 12);
          Rect.left = *(_DWORD *)wParama;
          Rect.top = *(_DWORD *)(lParam + 20);
          Rect.right = *(_DWORD *)(lParam + 24);
          lParam = (LPARAM)&Rect;
          Rect.bottom = *(_DWORD *)(wParama + 12);
          wParama = (int)&v40;
          v18 = (int)&v40;
        }
        if ( CmpDate(lParam, v5 + 1632) < 0
          || CmpDate(v18, v5 + 1648) > 0
          || (unsigned int)DaysBetweenDates(lParam, v18) >= *(_DWORD *)(v5 + 1664) )
          return v45;
        if ( !CmpDate(lParam, v5 + 1684) && !CmpDate(v18, v5 + 1700) )
          goto LABEL_82;
        *(_DWORD *)(v5 + 1716) = *(_DWORD *)(v5 + 1684);
        *(_DWORD *)(v5 + 1720) = *(_DWORD *)(v5 + 1688);
        *(_WORD *)(v5 + 2232) |= 0x40u;
        *(_DWORD *)(v5 + 1724) = *(_DWORD *)(v5 + 1692);
        *(_DWORD *)(v5 + 1728) = *(_DWORD *)(v5 + 1696);
        *(_DWORD *)(v5 + 1732) = *(_DWORD *)(v5 + 1700);
        *(_DWORD *)(v5 + 1736) = *(_DWORD *)(v5 + 1704);
        *(_DWORD *)(v5 + 1740) = *(_DWORD *)(v5 + 1708);
        *(_DWORD *)(v5 + 1744) = *(_DWORD *)(v5 + 1712);
        v45 = MCSetDate(v5, wParama);
        if ( v45 )
        {
          *(_DWORD *)(v5 + 1684) = *(_DWORD *)lParam;
          *(_DWORD *)(v5 + 1688) = *(_DWORD *)(lParam + 4);
          *(_DWORD *)(v5 + 1692) = *(_DWORD *)(lParam + 8);
          *(_DWORD *)(v5 + 1696) = *(_DWORD *)(lParam + 12);
          *(_DWORD *)(v5 + 1700) = *(_DWORD *)wParama;
          *(_DWORD *)(v5 + 1704) = *(_DWORD *)(wParama + 4);
          *(_DWORD *)(v5 + 1708) = *(_DWORD *)(wParama + 8);
          *(_DWORD *)(v5 + 1712) = *(_DWORD *)(wParama + 12);
          MCInvalidateDates(v5, v5 + 1716, v5 + 1732);
          MCInvalidateDates(v5, v5 + 1684, v5 + 1700);
          UpdateWindow(*(HWND *)v5);
        }
        v19 = -65;
        goto LABEL_114;
      case 0x1007u:
        if ( !lParam )
          goto LABEL_121;
        memset((void *)lParam, 0, 0x20u);
        if ( wParam )
        {
          if ( wParam != 1 )
            goto LABEL_121;
          *(_DWORD *)lParam = *(_DWORD *)(v5 + 1764);
          *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 1768);
          *(_DWORD *)(lParam + 8) = *(_DWORD *)(v5 + 1772);
          *(_DWORD *)(lParam + 12) = *(_DWORD *)(v5 + 1776);
          v20 = v5 + 1780;
        }
        else
        {
          *(_DWORD *)lParam = *(_DWORD *)(v5 + 1796);
          *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 1800);
          *(_DWORD *)(lParam + 8) = *(_DWORD *)(v5 + 1804);
          *(_DWORD *)(lParam + 12) = *(_DWORD *)(v5 + 1808);
          v20 = v5 + 1812;
        }
        *(_DWORD *)(lParam + 16) = *(_DWORD *)v20;
        v21 = v20 + 4;
        *(_DWORD *)(lParam + 20) = *(_DWORD *)v21;
        v21 += 4;
        *(_DWORD *)(lParam + 24) = *(_DWORD *)v21;
        *(_DWORD *)(lParam + 28) = *(_DWORD *)(v21 + 4);
LABEL_121:
        v45 = *(_DWORD *)(v5 + 1828);
        if ( wParam == 1 )
          v45 += 2;
        break;
      case 0x1008u:
        v22 = lParam;
        if ( !(*(_BYTE *)(v5 + 8) & 1) )
          return v45;
        v23 = wParam;
        if ( wParam != *(_DWORD *)(v5 + 1828) + 2 )
          return v45;
        if ( (signed int)wParam > 0 )
        {
          v24 = v5 + 2144;
          do
          {
            *(_DWORD *)v24 = *(_DWORD *)v22;
            v22 += 4;
            v24 += 4;
            --v23;
          }
          while ( v23 );
        }
        MCInvalidateMonthDays(v5);
        goto LABEL_82;
      case 0x1009u:
        *(_DWORD *)lParam = 0;
        *(_DWORD *)(lParam + 4) = 0;
        *(_DWORD *)(lParam + 8) = *(_DWORD *)(v5 + 1592);
        v25 = *(_DWORD *)(v5 + 1596);
        *(_DWORD *)(lParam + 12) = v25;
        if ( !(*(_BYTE *)(v5 + 8) & 0x10) )
          *(_DWORD *)(lParam + 12) = v25 + *(_DWORD *)(v5 + 1604);
        AdjustWindowRect((LPRECT)lParam, *(_DWORD *)(v5 + 8), 0);
        *(_DWORD *)(lParam + 8) -= *(_DWORD *)lParam;
        *(_DWORD *)(lParam + 12) -= *(_DWORD *)(lParam + 4);
        *(_DWORD *)lParam = 0;
        *(_DWORD *)(lParam + 4) = 0;
        goto LABEL_82;
      case 0x1015u:
        Rect.right = *(_DWORD *)(v5 + 1608);
        v26 = *(_DWORD *)(v5 + 8);
        Rect.bottom = *(_DWORD *)(v5 + 1604);
        Rect.left = 0;
        Rect.top = 0;
        AdjustWindowRect(&Rect, v26, 0);
        return Rect.right - Rect.left;
      case 0x100Eu:
        return MCHandleHitTest(v5, lParam);
      case 0x100Au:
        if ( wParam >= 6 )
          goto LABEL_138;
        v27 = v5 + 4 * wParam + 1560;
        v28 = *(_DWORD *)v27;
        *(_DWORD *)v27 = lParam;
        InvalidateRect(hWnd, 0, wParam == 0);
        return v28;
      case 0x100Bu:
        if ( wParam >= 6 )
LABEL_138:
          result = -1;
        else
          result = *(_DWORD *)(v5 + 4 * wParam + 1560);
        return result;
      case 0x100Fu:
        v45 = *(_WORD *)(v5 + 1448) | ((((unsigned int)*(_WORD *)(v5 + 2232) >> 9) & 1) << 16);
        if ( lParam == -1 )
        {
          *(_WORD *)(v5 + 2232) &= 0xFDFFu;
        }
        else if ( lParam < 7 )
        {
          *(_WORD *)(v5 + 2232) |= 0x200u;
          *(_DWORD *)(v5 + 1448) = (unsigned __int16)lParam;
        }
        UpdateLocaleInfo(v5, (void *)(v5 + 36));
        v37 = 0;
        v35 = hWnd;
        goto LABEL_19;
      case 0x1010u:
        return *(_WORD *)(v5 + 1448) | ((*(_WORD *)(v5 + 2232) & 0x200) << 7);
      case 0x100Cu:
        MCSetToday(v5, lParam);
        return v45;
      case 0x100Du:
        result = 0;
        if ( lParam )
        {
          *(_DWORD *)lParam = *(_DWORD *)(v5 + 1668);
          *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 1672);
          v29 = lParam + 8;
          *(_DWORD *)v29 = *(_DWORD *)(v5 + 1676);
          *(_DWORD *)(v29 + 4) = *(_DWORD *)(v5 + 1680);
          result = 1;
        }
        return result;
      case 0x1011u:
        if ( lParam )
        {
          memset((void *)lParam, 0, 0x20u);
          if ( *(_WORD *)(v5 + 2232) & 0x800 )
          {
            *(_DWORD *)lParam = *(_DWORD *)(v5 + 1632);
            *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 1636);
            *(_DWORD *)(lParam + 8) = *(_DWORD *)(v5 + 1640);
            *(_DWORD *)(lParam + 12) = *(_DWORD *)(v5 + 1644);
            v45 = 1;
          }
          if ( *(_WORD *)(v5 + 2232) & 0x1000 )
          {
            *(_DWORD *)(lParam + 16) = *(_DWORD *)(v5 + 1648);
            *(_DWORD *)(lParam + 20) = *(_DWORD *)(v5 + 1652);
            *(_DWORD *)(lParam + 24) = *(_DWORD *)(v5 + 1656);
            *(_DWORD *)(lParam + 28) = *(_DWORD *)(v5 + 1660);
            v45 |= 2u;
          }
        }
        return v45;
      case 0x1012u:
        if ( lParam )
        {
          v30 = wParam & 1;
          if ( !(wParam & 1) || IsValidDate(lParam) )
          {
            hWnda = (HWND)(wParam & 2);
            if ( !(wParam & 2) || IsValidDate(lParam + 16) )
            {
              if ( wParam & 1 && !IsValidTime(lParam) )
              {
                *(_WORD *)(lParam + 8) = *(_WORD *)(v5 + 1676);
                *(_WORD *)(lParam + 10) = *(_WORD *)(v5 + 1678);
                *(_WORD *)(lParam + 12) = *(_WORD *)(v5 + 1680);
              }
              if ( wParam & 2 && !IsValidTime(lParam + 16) )
              {
                *(_WORD *)(lParam + 24) = *(_WORD *)(v5 + 1676);
                *(_WORD *)(lParam + 26) = *(_WORD *)(v5 + 1678);
                *(_WORD *)(lParam + 28) = *(_WORD *)(v5 + 1680);
              }
              v31 = v5 + 1632;
              wParamb = v5 + 1632;
              if ( v30 )
              {
                *(_DWORD *)v31 = *(_DWORD *)lParam;
                *(_DWORD *)(v5 + 1636) = *(_DWORD *)(lParam + 4);
                *(_DWORD *)(v5 + 1640) = *(_DWORD *)(lParam + 8);
                *(_DWORD *)(v5 + 1644) = *(_DWORD *)(lParam + 12);
                *(_WORD *)(v5 + 2232) |= 0x800u;
              }
              else
              {
                *(_DWORD *)v31 = c_stEpoch[0];
                *(_DWORD *)(v5 + 1636) = c_stEpoch[1];
                *(_DWORD *)(v5 + 1640) = c_stEpoch[2];
                *(_DWORD *)(v5 + 1644) = c_stEpoch[3];
                *(_WORD *)(v5 + 2232) &= 0xF7FFu;
              }
              v32 = hWnda == 0;
              v33 = v5 + 1648;
              hWndb = v5 + 1648;
              if ( v32 )
              {
                *(_DWORD *)v33 = c_stArmageddon[0];
                *(_DWORD *)(v5 + 1652) = c_stArmageddon[1];
                *(_DWORD *)(v5 + 1656) = c_stArmageddon[2];
                *(_DWORD *)(v5 + 1660) = c_stArmageddon[3];
                *(_WORD *)(v5 + 2232) &= 0xEFFFu;
              }
              else
              {
                *(_DWORD *)v33 = *(_DWORD *)(lParam + 16);
                *(_DWORD *)(v5 + 1652) = *(_DWORD *)(lParam + 20);
                *(_DWORD *)(v5 + 1656) = *(_DWORD *)(lParam + 24);
                *(_DWORD *)(v5 + 1660) = *(_DWORD *)(lParam + 28);
                *(_WORD *)(v5 + 2232) |= 0x1000u;
              }
              if ( *(_WORD *)(v5 + 2232) & 0x1000 && *(_WORD *)(v5 + 2232) & 0x800 && CmpDate(wParamb, hWndb) > 0 )
              {
                v40 = *(_DWORD *)wParamb;
                v41 = *(_DWORD *)(v5 + 1636);
                v42 = *(_DWORD *)(v5 + 1640);
                v43 = *(_DWORD *)(v5 + 1644);
                *(_DWORD *)wParamb = *(_DWORD *)hWndb;
                *(_DWORD *)(v5 + 1636) = *(_DWORD *)(v5 + 1652);
                v34 = v5 + 1640;
                *(_DWORD *)v34 = *(_DWORD *)(v5 + 1656);
                *(_DWORD *)(v34 + 4) = *(_DWORD *)(v5 + 1660);
                *(_DWORD *)hWndb = v40;
                *(_DWORD *)(v5 + 1652) = v41;
                *(_DWORD *)(v5 + 1656) = v42;
                *(_DWORD *)(v5 + 1660) = v43;
              }
LABEL_82:
              v45 = 1;
            }
          }
        }
        return v45;
      case 0x1013u:
        if ( *(_WORD *)(v5 + 2232) & 0x2000 )
          v7 = *(_DWORD *)(v5 + 2200);
        else
          v7 = *(_DWORD *)(v5 + 1828);
        return v7;
      case 0x1014u:
        if ( *(_WORD *)(v5 + 2232) & 0x2000 )
          v45 = *(_DWORD *)(v5 + 2200);
        else
          v45 = 0;
        if ( wParam )
        {
          *(_WORD *)(v5 + 2232) |= 0x2000u;
          *(_DWORD *)(v5 + 2200) = wParam;
        }
        else
        {
          v19 = -8193;
LABEL_114:
          *(_WORD *)(v5 + 2232) &= v19;
        }
        return v45;
      default:
        goto LABEL_183;
    }
    return v45;
  }
  if ( Msg == 792 )
    goto LABEL_72;
  if ( Msg > 0x55 )
  {
    if ( Msg > 0x101 )
    {
      if ( Msg == 275 )
      {
        MCHandleTimer(v5, wParam);
        return v45;
      }
      if ( Msg == 277 )
      {
        MCUpdateEditYear(v5);
        return v45;
      }
      if ( Msg == 512 )
      {
        MCMouseMove((HDC)v5, wParam, lParam);
        return v45;
      }
      if ( Msg == 513 )
      {
        MCLButtonDown(v5, wParam, lParam);
        return v45;
      }
      if ( Msg == 514 )
      {
        MCLButtonUp(v5, wParam, lParam);
        return v45;
      }
      goto LABEL_183;
    }
    if ( Msg == 257 )
    {
      if ( wParam == 16 )
      {
        *(_DWORD *)(v5 + 2208) = 0;
      }
      else if ( wParam == 17 )
      {
        *(_DWORD *)(v5 + 2204) = 0;
      }
      return v45;
    }
    if ( Msg == 123 )
    {
      MCContextMenu(v5, wParam, lParam);
      return v45;
    }
    if ( Msg == 124 )
    {
      v7 = MCOnStyleChanging(v5, wParam, lParam);
    }
    else
    {
      if ( Msg != 125 )
      {
        if ( Msg == 130 )
        {
          CCDestroyWindow();
          MCNcDestroyHandler(hWnd, (HLOCAL)v5, wParam, lParam);
          return v45;
        }
        if ( Msg == 256 )
        {
          MCHandleKeydown(v5, wParam, lParam);
          return v45;
        }
        goto LABEL_183;
      }
      v7 = MCOnStyleChanged(v5, wParam, lParam);
    }
    return v7;
  }
  if ( Msg == 85 )
    return CIHandleNotifyFormat(v5, lParam);
  if ( Msg <= 0x15 )
  {
    if ( Msg == 21 )
    {
      InitGlobalColors();
      return v45;
    }
    if ( Msg != 1 )
    {
      if ( Msg == 5 )
      {
LABEL_74:
        if ( Msg == 4095 )
        {
          GetClientRect(*(HWND *)v5, &Rect);
        }
        else
        {
          Rect.left = 0;
          Rect.top = 0;
          Rect.right = (signed __int16)lParam;
          Rect.bottom = SHIWORD(lParam);
        }
        return MCSizeHandler(v5, (int)&Rect);
      }
      if ( Msg == 10 )
      {
        v6 = wParam != 0;
        if ( (((unsigned int)*(_WORD *)(v5 + 2232) >> 1) & 1) != v6 )
        {
          v37 = 1;
          v35 = *(HWND *)v5;
          *(_WORD *)(v5 + 2232) ^= ((unsigned __int8)*(_WORD *)(v5 + 2232) ^ (unsigned __int8)(2 * v6)) & 2;
LABEL_19:
          InvalidateRect(v35, 0, v37);
        }
        return v45;
      }
      if ( Msg != 15 )
      {
        if ( Msg == 20 )
          return MCHandleEraseBkgnd(v5, (HDC)wParam);
        goto LABEL_183;
      }
LABEL_72:
      MonthCal_OnPaint((HGDIOBJ)v5, (HDC)wParam);
      return 0;
    }
    CCCreateWindow();
    return MCCreateHandler((LPCWSTR)v5, (WPARAM)hWnd, lParam);
  }
  if ( Msg == 26 )
  {
    v10 = wParam;
    InitGlobalMetrics(wParam);
    if ( !lParam || !StrCmpICW(lParam, (int)L"Intl") )
    {
      UpdateLocaleInfo(v5, (void *)(v5 + 36));
      MCReloadMenus((LPCWSTR)v5);
      InvalidateRect(hWnd, 0, 1);
      v10 = 0;
    }
    if ( v10 && v10 != 42 )
      return v45;
    MCCalcSizes(v5);
    v38 = 0;
    v36 = 4095;
    goto LABEL_38;
  }
  if ( Msg == 31 )
  {
    v38 = -1;
    v36 = 514;
LABEL_38:
    PostMessageW(*(HWND *)v5, v36, 0, v38);
    return v45;
  }
  if ( Msg == 48 )
  {
    MCHandleSetFont(v5, (HANDLE)wParam, (unsigned __int16)lParam);
    MCSizeHandler(v5, v5 + 1988);
    MCUpdateMonthNamePos(v5);
    return v45;
  }
  if ( Msg == 49 )
    return *(_DWORD *)(v5 + 1552);
  if ( Msg == 78 )
  {
    if ( *(_DWORD *)(lParam + 8) == -722 && *(_DWORD *)lParam == *(_DWORD *)(v5 + 1540) )
    {
      v8 = *(_WORD *)(v5 + 1684);
      v9 = v8 + *(_DWORD *)(lParam + 16);
      if ( v9 < (unsigned int)*(_WORD *)(v5 + 1632) )
        v9 = *(_WORD *)(v5 + 1632);
      if ( v9 > (unsigned int)*(_WORD *)(v5 + 1648) )
        v9 = *(_WORD *)(v5 + 1648);
      *(_WORD *)(v5 + 1684) = v9;
      if ( v9 != v8 )
      {
        MCIncrStartMonth(v5, 12 * (v9 - v8), 0);
        MCNotifySelChange(v5, -749);
      }
    }
    return v45;
  }
LABEL_183:
  if ( !CCWndProc(v5, Msg, wParam, lParam, (int)&v45) )
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  return v45;
}
// 6F792938: using guessed type int c_stEpoch[4];
// 6F792948: using guessed type int c_stArmageddon[4];
// 6F792984: using guessed type wchar_t aIntl[5];

//----- (6F7AF91A) --------------------------------------------------------
int __stdcall GetPrevButton(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@2

  result = a2 - 1;
  if ( a2 - 1 >= 0 )
  {
    v3 = *(_DWORD *)(a1 + 48) + 28 * result + 8;
    do
    {
      if ( !(*(_BYTE *)v3 & 8) )
        break;
      --result;
      v3 -= 28;
    }
    while ( result >= 0 );
  }
  return result;
}

//----- (6F7AF94A) --------------------------------------------------------
signed int __stdcall GetAdjustInfo(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@4
  LPARAM lParam; // [sp+8h] [bp-40h]@3
  int v7; // [sp+14h] [bp-34h]@1
  char v8; // [sp+18h] [bp-30h]@4
  int v9; // [sp+2Ch] [bp-1Ch]@1
  int v10; // [sp+30h] [bp-18h]@1

  v9 = a5;
  v10 = a4;
  v7 = a2;
  if ( a4 )
    *(_WORD *)a4 = 0;
  if ( CCSendNotify(a1, -720, (LPARAM)&lParam) )
  {
    TBInputStruct(a1, a3, (int)&v8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7AF9B9) --------------------------------------------------------
HWND __stdcall SendItemNotify(HDC hDC, int a2, int a3)
{
  int v3; // eax@7
  LPARAM lParam; // [sp+4h] [bp-40h]@1
  char Dst; // [sp+8h] [bp-3Ch]@1
  int v7; // [sp+10h] [bp-34h]@1
  char v8; // [sp+14h] [bp-30h]@6
  int v9; // [sp+30h] [bp-14h]@7

  lParam = 0;
  memset(&Dst, 0, 0x38u);
  v7 = a2;
  if ( a3 == -710 )
  {
    v3 = PositionFromID((int)hDC, a2);
    TB_GetItemRect(hDC, v3, (int)&v9);
  }
  else if ( a3 > -708 && a3 <= -706 && a2 >= 0 && a2 < *((_DWORD *)hDC + 33) )
  {
    qmemcpy(&v8, (const void *)(28 * a2 + *((_DWORD *)hDC + 12)), 0x14u);
  }
  return CCSendNotify((int)hDC, a3, (LPARAM)&lParam);
}

//----- (6F7AFA59) --------------------------------------------------------
int __stdcall GetNearestInsert(HDC hDC, int a2, int a3, int a4)
{
  int v4; // ebx@1
  signed int v5; // edi@2

  v4 = a2;
  while ( 1 )
  {
    v5 = 0;
    if ( a4 & 1 )
    {
      if ( v4 <= a3 )
      {
        v5 = 1;
        if ( SendItemNotify(hDC, v4, -706) )
          return v4;
      }
    }
    if ( a4 & 2 )
    {
      if ( a2 >= 0 )
      {
        v5 = 1;
        if ( SendItemNotify(hDC, a2, -706) )
          return a2;
      }
    }
    if ( !v5 )
      break;
    ++v4;
    --a2;
  }
  return -1;
}

//----- (6F7AFACF) --------------------------------------------------------
int __stdcall PaintAdjustLine(HDC hDC, HDC hdc)
{
  int v2; // ebx@1
  HDC v3; // eax@1
  HWND v4; // ecx@1
  HDC v5; // esi@1
  int result; // eax@1
  WPARAM v7; // esi@1
  int v8; // eax@3
  COLORREF v9; // eax@13
  COLORREF v10; // eax@16
  int v11; // edi@18
  int v12; // ecx@19
  LRESULT v13; // eax@28
  LONG v14; // eax@28
  int v15; // [sp+Ch] [bp-DCh]@22
  char Dst; // [sp+10h] [bp-D8h]@22
  int v17; // [sp+94h] [bp-54h]@22
  char v18; // [sp+98h] [bp-50h]@22
  unsigned __int8 v19; // [sp+9Ch] [bp-4Ch]@22
  char v20; // [sp+9Dh] [bp-4Bh]@22
  int v21; // [sp+A4h] [bp-44h]@22
  COLORREF color; // [sp+B0h] [bp-38h]@18
  COLORREF v23; // [sp+B4h] [bp-34h]@16
  UINT c; // [sp+B8h] [bp-30h]@5
  int v25; // [sp+BCh] [bp-2Ch]@8
  int v26; // [sp+C0h] [bp-28h]@18
  LPCWSTR lpString; // [sp+C4h] [bp-24h]@6
  WCHAR String; // [sp+C8h] [bp-20h]@18
  __int16 v29; // [sp+CAh] [bp-1Eh]@18
  RECT rect; // [sp+CCh] [bp-1Ch]@1
  int v31; // [sp+DCh] [bp-Ch]@3
  HWND hWnd; // [sp+E0h] [bp-8h]@1
  int v33; // [sp+E4h] [bp-4h]@10
  HDC hdca; // [sp+F4h] [bp+Ch]@1

  v2 = (int)hdc;
  v3 = (HDC)*((_DWORD *)hdc + 6);
  v4 = (HWND)*((_DWORD *)hdc + 5);
  rect.left = *((_DWORD *)hdc + 7);
  rect.top = *((_DWORD *)hdc + 8);
  v5 = hdc + 9;
  rect.right = *((_DWORD *)hdc + 9);
  hdca = v3;
  result = *(_DWORD *)(v2 + 4);
  rect.bottom = *((_DWORD *)v5 + 1);
  v7 = *(_DWORD *)(v2 + 8);
  hWnd = v4;
  if ( result == 201 || result == 203 )
  {
    v8 = *(_WORD *)(v2 + 44);
    v31 = v8;
    if ( v8 != 0xFFFF )
      v31 = v8 & 0xFFF | 16 * (unsigned __int16)(v8 & 0xF000);
    result = SendMessageW(v4, 0x18Au, v7, 0);
    c = result;
    if ( result >= 0 )
    {
      result = (int)LocalAlloc(0x40u, 2 * result + 2);
      lpString = (LPCWSTR)result;
      if ( result )
      {
        SendMessageW(hWnd, 0x189u, v7, result);
        if ( *(_DWORD *)(v2 + 12) == 4 )
        {
          v11 = (int)hDC;
        }
        else
        {
          v25 = *(_DWORD *)(v2 + 16) & 1;
          v33 = v25 && GetFocus() == hWnd;
          if ( *(_WORD *)(v2 + 46) & 0xC000 )
          {
            v9 = g_clrGrayText;
          }
          else
          {
            v9 = g_clrHighlightText;
            if ( !v33 )
              v9 = g_clrWindowText;
          }
          v23 = SetTextColor(hdca, v9);
          v10 = g_clrHighlight;
          if ( !v33 )
            v10 = g_clrWindow;
          color = SetBkColor(hdca, v10);
          String = 87;
          v29 = 0;
          MGetTextExtent(hdca, &String, 1, 0, (int)&v26);
          v11 = (int)hDC;
          if ( *((_DWORD *)hDC + 2) & 0x800 )
            v12 = g_cxEdge + *((_DWORD *)hDC + 26);
          else
            v12 = *((_DWORD *)hDC + 28);
          ExtTextOutW(hdca, rect.left + v12 + 2, (rect.top + rect.bottom - v26) / 2, 6u, &rect, lpString, c, 0);
          if ( v31 >= 0 )
          {
            memset(&v18, 0, 0x18u);
            v15 = 0;
            memset(&Dst, 0, 0x84u);
            v21 = -1;
            v17 = v31;
            v19 = ~(unsigned __int8)(*(_WORD *)(v2 + 46) >> 12) & 4;
            v11 = (int)hDC;
            v20 = 0;
            InitTBDrawItem((int)&v15, (int)hDC, (int)&v17, v19, 0, 0, 0);
            if ( *((_DWORD *)hDC + 2) & 0x800 )
              DrawFace(hdca, rect.left + 1, rect.top + 1, 0, 0, 0, 0, (int)&v15);
            else
              DrawButton(v2, hdca, rect.left + 1, rect.top + 1, hDC, (int)&v17, 1);
            ReleaseMonoDC((int)hDC);
          }
          SetBkColor(hdca, color);
          SetTextColor(hdca, v23);
          if ( v25 && !v33 )
          {
            v13 = SendMessageW(hWnd, 0x193u, 0, 0);
            v14 = rect.left + v13;
            if ( rect.right < v14 )
              rect.right = v14;
            FrameRect(hdca, &rect, g_hbrHighlight);
          }
        }
        if ( (*(_DWORD *)(v2 + 12) == 4 || *(_BYTE *)(v2 + 16) & 0x10) && !(CCGetUIState(v11) & 1) )
          DrawFocusRect(hdca, &rect);
        result = (int)LocalFree((HLOCAL)lpString);
      }
    }
  }
  return result;
}

//----- (6F7AFD8E) --------------------------------------------------------
BOOL __stdcall SafeEnableWindow(HWND hDlg, int nIDDlgItem, WPARAM wParam, BOOL bEnable)
{
  HWND v4; // esi@1

  v4 = GetDlgItem(hDlg, nIDDlgItem);
  if ( !bEnable && GetFocus() == v4 )
    SendMessageW(hDlg, 0x28u, wParam, 1);
  return EnableWindow(v4, bEnable);
}

//----- (6F7AFDD6) --------------------------------------------------------
int __stdcall InsertIndex(int a1, POINT pt, BOOL bAutoScroll)
{
  HWND v3; // eax@1
  HWND v4; // ebx@1
  int v5; // eax@1
  signed int v6; // edi@1
  int v7; // eax@5

  v3 = GetDlgItem(*(HWND *)a1, 203);
  v4 = v3;
  v5 = LBItemFromPt(v3, pt, bAutoScroll);
  v6 = v5;
  if ( v5 >= 0 && !SendItemNotify(*(HDC *)(a1 + 4), v5, -706) )
    v6 = -1;
  if ( bAutoScroll )
    v7 = v6;
  else
    v7 = -1;
  DrawInsert(*(HWND *)a1, v4, v7);
  return v6;
}

//----- (6F7AFE3E) --------------------------------------------------------
BOOL __stdcall IsInButtonList(HWND hWnd, struct tagPOINT Point)
{
  HWND v2; // esi@1

  ScreenToClient(hWnd, &Point);
  v2 = ChildWindowFromPoint(hWnd, Point);
  return v2 == GetDlgItem(hWnd, 201);
}

//----- (6F7AFE83) --------------------------------------------------------
int __stdcall SaveRestoreFromReg(SIZE_T a1, int a2, HKEY a3, LPCWSTR a4, LPCWSTR a5)
{
  int v5; // eax@2
  BYTE *v6; // eax@2
  int v7; // esi@8
  DWORD v8; // edx@10
  DWORD v9; // eax@10
  int v10; // ecx@10
  int v11; // ST10_4@13
  unsigned int v12; // esi@21
  BYTE *v13; // eax@22
  bool v14; // zf@28
  bool v15; // sf@28
  HWND v16; // eax@28
  int v17; // esi@29
  int v18; // eax@30
  int v19; // eax@34
  int v20; // esi@37
  int v21; // eax@38
  int v22; // eax@39
  signed int v23; // eax@51
  int v24; // edx@56
  int v25; // esi@57
  int v26; // eax@58
  HWND v27; // ecx@60
  int v28; // edx@63
  SIZE_T v29; // eax@63
  int i; // [sp-10h] [bp-1A4h]@48
  int v32; // [sp-Ch] [bp-1A0h]@48
  int v33; // [sp-8h] [bp-19Ch]@48
  signed int v34; // [sp+Ch] [bp-188h]@1
  int lpSubKey; // [sp+10h] [bp-184h]@22
  LPCWSTR lpValueName; // [sp+14h] [bp-180h]@1
  HKEY hKey; // [sp+18h] [bp-17Ch]@1
  DWORD cbData; // [sp+1Ch] [bp-178h]@9
  int v39; // [sp+20h] [bp-174h]@2
  LPARAM v40; // [sp+24h] [bp-170h]@26
  int v41; // [sp+30h] [bp-164h]@26
  int v42; // [sp+34h] [bp-160h]@26
  unsigned int v43; // [sp+38h] [bp-15Ch]@26
  int v44; // [sp+3Ch] [bp-158h]@26
  int v45; // [sp+40h] [bp-154h]@26
  int v46; // [sp+44h] [bp-150h]@26
  char v47; // [sp+48h] [bp-14Ch]@43
  int v48; // [sp+58h] [bp-13Ch]@43
  LPARAM v49; // [sp+5Ch] [bp-138h]@2
  LPARAM lParam; // [sp+64h] [bp-130h]@28
  BYTE *lpData; // [sp+68h] [bp-12Ch]@2
  void *v52; // [sp+6Ch] [bp-128h]@2
  SIZE_T uBytes; // [sp+70h] [bp-124h]@2
  int v54; // [sp+74h] [bp-120h]@2
  int v55; // [sp+78h] [bp-11Ch]@2
  char Dst; // [sp+7Ch] [bp-118h]@13
  char v57; // [sp+7Dh] [bp-117h]@49
  int v58; // [sp+88h] [bp-10Ch]@63
  char v59; // [sp+90h] [bp-104h]@48

  hKey = a3;
  lpValueName = a5;
  v34 = 0;
  if ( !a2 )
  {
    if ( RegOpenKeyExW(a3, a4, 0, 0x20019u, &hKey) )
      return v34;
    cbData = 0;
    if ( !RegQueryValueExW(hKey, a5, 0, 0, 0, &cbData) )
    {
      v12 = cbData;
      if ( cbData > 4 )
      {
        v13 = (BYTE *)LocalAlloc(0x40u, cbData);
        lpSubKey = (int)v13;
        if ( v13 )
        {
          cbData = v12;
          if ( !RegQueryValueExW(hKey, lpValueName, 0, (LPDWORD)&lpValueName, v13, &cbData)
            && lpValueName == (LPCWSTR)3
            && cbData == v12 )
          {
            v44 = -1;
            v41 = lpSubKey;
            v42 = lpSubKey;
            v45 = v12 >> 2;
            v46 = 4;
            v43 = v12;
            if ( !CCSendNotify(a1, -721, (LPARAM)&v40) )
            {
              if ( *(_DWORD *)(a1 + 64) )
              {
                v14 = *(_DWORD *)(a1 + 132) == 0;
                v15 = *(_DWORD *)(a1 + 132) < 0;
                v16 = *(HWND *)a1;
                lParam = 44;
                v52 = v16;
                v39 = 0;
                if ( !v15 && !v14 )
                {
                  v17 = 0;
                  do
                  {
                    v18 = v17 + *(_DWORD *)(a1 + 48);
                    if ( !(*(_BYTE *)(v18 + 9) & 1) )
                    {
                      uBytes = *(_DWORD *)(v18 + 4);
                      SendMessageW(*(HWND *)(a1 + 64), 0x433u, 0, (LPARAM)&lParam);
                    }
                    ++v39;
                    v17 += 28;
                  }
                  while ( v39 < *(_DWORD *)(a1 + 132) );
                }
              }
              if ( TBReallocButtons(a1, v45) )
              {
                v19 = *(_DWORD *)(a1 + 132);
                if ( v19 < v45 )
                  memset((void *)(*(_DWORD *)(a1 + 48) + 28 * v19), 0, 20 * (v45 - v19));
                v14 = v45 == 0;
                v15 = v45 < 0;
                *(_DWORD *)(a1 + 132) = v45;
                v39 = 0;
                if ( !v15 && !v14 )
                {
                  v20 = 0;
                  do
                  {
                    v44 = v39;
                    v21 = *(_DWORD *)(a1 + 48);
                    if ( *(_DWORD *)v42 >= 0 )
                    {
                      *(_BYTE *)(v20 + v21 + 9) = 0;
                      *(_DWORD *)(v20 + *(_DWORD *)(a1 + 48) + 4) = *(_DWORD *)v42;
                      *(_DWORD *)(v20 + *(_DWORD *)(a1 + 48)) = -1;
                    }
                    else
                    {
                      *(_BYTE *)(v20 + v21 + 9) = 1;
                      *(_DWORD *)(v20 + *(_DWORD *)(a1 + 48)) = g_dxButtonSep;
                      *(_DWORD *)(v20 + *(_DWORD *)(a1 + 48) + 4) = 0;
                      v22 = *(_DWORD *)(a1 + 48);
                      if ( *(_DWORD *)v42 == -1 )
                        *(_BYTE *)(v20 + v22 + 8) = 0;
                      else
                        *(_BYTE *)(v20 + v22 + 8) = 8;
                    }
                    v42 += 4;
                    TBOutputStruct(a1, v20 + *(_DWORD *)(a1 + 48), &v47);
                    CCSendNotify(a1, -721, (LPARAM)&v40);
                    if ( HIWORD(v48) )
                      v48 = 0;
                    TBInputStruct(a1, v20 + *(_DWORD *)(a1 + 48), (int)&v47);
                    ++v39;
                    v20 += 28;
                  }
                  while ( v39 < *(_DWORD *)(a1 + 132) );
                }
                if ( !CCSendNotify(a1, -703, 0) || *(_DWORD *)(a1 + 28) < 5 )
                {
                  v33 = (int)&v59;
                  v32 = (int)&v54;
                  v39 = 0;
                  for ( i = 0; ; i = v39 )
                  {
                    v55 = 0;
                    if ( !GetAdjustInfo(a1, i, v32, v33, 128) )
                      break;
                    if ( !(v57 & 1) || v55 )
                    {
                      v23 = PositionFromID(a1, v55);
                      if ( v23 >= 0 )
                        qmemcpy((void *)(28 * v23 + *(_DWORD *)(a1 + 48)), &v54, 0x1Cu);
                    }
                    ++v39;
                    v33 = (int)&v59;
                    v32 = (int)&v54;
                  }
                  CCSendNotify(a1, -704, 0);
                }
                v24 = *(_DWORD *)(a1 + 132) - 1;
                v39 = v24;
                if ( v24 >= 0 )
                {
                  v25 = 28 * v24;
                  do
                  {
                    v26 = v25 + *(_DWORD *)(a1 + 48);
                    if ( *(_DWORD *)v26 >= 0 )
                    {
                      v27 = *(HWND *)(a1 + 64);
                      if ( !v27 || *(_BYTE *)(v26 + 9) & 1 || !*(_DWORD *)(v26 + 4) )
                        goto LABEL_65;
                      v28 = *(_DWORD *)a1;
                      lParam = 44;
                      lpData = 0;
                      v52 = (void *)v28;
                      v29 = *(_DWORD *)(v26 + 4);
                      v58 = -1;
                      uBytes = v29;
                      SendMessageW(v27, 0x432u, 0, (LPARAM)&lParam);
                    }
                    else
                    {
                      DeleteButton((HDC)a1, v24);
                    }
                    v24 = v39;
LABEL_65:
                    --v24;
                    v25 -= 28;
                    v39 = v24;
                  }
                  while ( v24 >= 0 );
                }
                v34 = *(_DWORD *)(a1 + 132) != 0;
                SendMessageW(*(HWND *)a1, 0x421u, 0, 0);
                InvalidateRect(*(HWND *)a1, 0, 1);
                TBInvalidateItemRects(a1);
              }
            }
          }
          LocalFree((HLOCAL)lpSubKey);
        }
      }
    }
    RegCloseKey(hKey);
    return v34;
  }
  v5 = *(_DWORD *)(a1 + 132);
  v54 = -1;
  v55 = v5;
  v39 = 0;
  lpData = 0;
  uBytes = 4 * v5;
  v52 = 0;
  CCSendNotify(a1, -722, (LPARAM)&v49);
  v6 = lpData;
  if ( !lpData )
  {
    v6 = (BYTE *)LocalAlloc(0x40u, uBytes);
    lpData = v6;
    v39 = 1;
  }
  if ( !v52 )
    v52 = v6;
  if ( v6 )
  {
    if ( !RegCreateKeyW(hKey, a4, &hKey) )
    {
      v7 = 0;
      if ( *(_DWORD *)(a1 + 132) > 0 )
      {
        cbData = 0;
        do
        {
          v8 = cbData;
          v9 = cbData + *(_DWORD *)(a1 + 48);
          v10 = *(_DWORD *)(v9 + 4);
          if ( v10 )
            *(_DWORD *)v52 = v10;
          else
            *(_DWORD *)v52 = ((unsigned int)(unsigned __int8)~*(_BYTE *)(v9 + 8) >> 3) | 0xFFFFFFFE;
          v52 = (char *)v52 + 4;
          v11 = v8 + *(_DWORD *)(a1 + 48);
          v54 = v7;
          TBOutputStruct(a1, v11, &Dst);
          CCSendNotify(a1, -722, (LPARAM)&v49);
          cbData += 28;
          ++v7;
        }
        while ( v7 < *(_DWORD *)(a1 + 132) );
      }
      if ( !RegSetValueExW(hKey, lpValueName, 0, 3u, lpData, uBytes) )
        v34 = 1;
      RegCloseKey(hKey);
    }
    if ( v39 )
      LocalFree(lpData);
  }
  return v34;
}
// 6F7B0470: using guessed type int g_dxButtonSep;

//----- (6F7B0479) --------------------------------------------------------
LONG __stdcall FixPTB(HWND hWnd)
{
  LONG v1; // eax@1
  LONG v2; // edi@1
  HWND v3; // eax@1

  v1 = GetWindowLongW(hWnd, 0);
  v2 = v1;
  v3 = *(HWND *)(v1 + 72);
  if ( v3 )
    *(_DWORD *)(GetWindowLongW(v3, 8) + 4) = v2;
  return v2;
}

//----- (6F7B04AB) --------------------------------------------------------
void __stdcall MoveButton(HDC hDC, int a2)
{
  int v2; // ebx@1
  HCURSOR v3; // eax@3
  HCURSOR v4; // eax@3
  HWND v5; // ST10_4@3
  __int16 v6; // ax@13
  signed int v7; // eax@15
  int v8; // edx@15
  int v9; // eax@18
  int v10; // eax@31
  int v11; // ecx@32
  int v12; // eax@43
  HWND v13; // esi@45
  struct tagRECT Rect; // [sp+8h] [bp-68h]@3
  int v15; // [sp+18h] [bp-58h]@26
  int v16; // [sp+1Ch] [bp-54h]@41
  char v17; // [sp+20h] [bp-50h]@41
  char v18; // [sp+21h] [bp-4Fh]@41
  int v19; // [sp+28h] [bp-48h]@41
  struct tagMSG Msg; // [sp+34h] [bp-3Ch]@4
  HCURSOR hCursor; // [sp+50h] [bp-20h]@3
  int v22; // [sp+54h] [bp-1Ch]@20
  char Dst; // [sp+58h] [bp-18h]@45

  v2 = (int)hDC;
  if ( a2 < 0 || !SendItemNotify(hDC, a2, -707) )
    return;
  v3 = LoadCursorW(g_hinst, (LPCWSTR)0x66);
  v4 = SetCursor(v3);
  v5 = *(HWND *)hDC;
  hCursor = v4;
  SetCapture(v5);
  GetClientRect(*(HWND *)hDC, &Rect);
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        while ( !PeekMessageW(&Msg, 0, 0, 0, 1u) )
          ;
        if ( GetCapture() != *(HWND *)hDC )
          goto LABEL_37;
      }
      while ( CallMsgFilterW(&Msg, 16899) );
      if ( Msg.message >= 0x100 )
        break;
LABEL_11:
      TranslateMessage(&Msg);
      DispatchMessageW(&Msg);
    }
    if ( Msg.message > 0x102 )
      break;
    CCNotifyNavigationKeyUsage((int)hDC, 1u);
  }
  if ( Msg.message != 514 )
  {
    if ( Msg.message == 516 )
      goto LABEL_37;
    goto LABEL_11;
  }
  RelayToToolTips(*((HWND *)hDC + 16), *(_DWORD *)hDC, 514, Msg.wParam, Msg.lParam);
  v6 = *((_WORD *)hDC + 56);
  if ( SHIWORD(Msg.lParam) > (signed __int16)(v6 + LOWORD(Rect.bottom))
    || SLOWORD(Msg.lParam) > (signed __int16)(LOWORD(Rect.right) + v6)
    || (v7 = *((_DWORD *)hDC + 28), v8 = -*((_DWORD *)hDC + 28), SHIWORD(Msg.lParam) < v8)
    || SLOWORD(Msg.lParam) < v8 )
  {
LABEL_35:
    DeleteButton(hDC, a2);
    goto LABEL_36;
  }
  if ( Rect.right == v7 )
    v9 = TBHitTest(hDC, SLOWORD(Msg.lParam), SHIWORD(Msg.lParam) + *((_DWORD *)hDC + 29) / 2);
  else
    v9 = TBHitTest(hDC, SLOWORD(Msg.lParam) + v7 / 2, SHIWORD(Msg.lParam));
  v22 = v9;
  if ( v9 < 0 )
    v22 = -1 - v22;
  if ( v22 > 0 )
  {
    if ( *(_BYTE *)(28 * v22 + *((_DWORD *)hDC + 12) - 20) & 0x20 )
    {
      if ( (signed int)SLOWORD(Msg.lParam) > *((_DWORD *)hDC + 28) )
      {
        --v22;
        if ( SendItemNotify(hDC, v22, -706) )
        {
          qmemcpy(&v15, (const void *)(*((_DWORD *)hDC + 12) + 28 * a2), 0x1Cu);
          DeleteButton(hDC, a2);
          if ( v22 > a2 )
            --v22;
          if ( !(*(_BYTE *)(28 * v22 + *((_DWORD *)hDC + 12) + 9) & 1) )
            ++v22;
          goto LABEL_45;
        }
      }
    }
  }
  if ( v22 != a2 )
  {
    if ( v22 == a2 + 1 )
    {
      --v22;
      if ( SendItemNotify(hDC, v22, -706) )
      {
        v15 = 0;
        v16 = 0;
        v19 = -1;
        v17 = 0;
        v18 = 1;
        goto LABEL_45;
      }
      goto LABEL_37;
    }
    if ( !SendItemNotify(hDC, v22, -706) )
      goto LABEL_37;
    v12 = 28 * a2 + *((_DWORD *)hDC + 12);
    qmemcpy(&v15, (const void *)v12, 0x1Cu);
    *(_DWORD *)(v12 + 16) = -1;
    DeleteButton(hDC, a2);
    if ( v22 > a2 )
      --v22;
LABEL_45:
    v13 = *(HWND *)hDC;
    TBOutputStruct((int)hDC, (int)&v15, &Dst);
    TBInsertButtons((SIZE_T)hDC, v22, 1, (LPCWSTR)&Dst, 1);
    v2 = FixPTB(v13);
LABEL_36:
    CCSendNotify(v2, -708, 0);
    TBInvalidateItemRects(v2);
    goto LABEL_37;
  }
  v10 = GetPrevButton((int)hDC, a2);
  a2 = v10;
  if ( v10 >= 0 )
  {
    v11 = *((_DWORD *)hDC + 12) + 28 * v10;
    if ( *(_BYTE *)(v11 + 9) & 1 )
    {
      if ( !*(_DWORD *)(v11 + 4) && SendItemNotify(hDC, v10, -707) )
        goto LABEL_35;
    }
  }
LABEL_37:
  SetCursor(hCursor);
  CCReleaseCapture(v2);
}

//----- (6F7B0793) --------------------------------------------------------
LPARAM __stdcall LBMoveButton(int a1, int nIDDlgItem, WPARAM wParam, int a4, WPARAM a5, int a6)
{
  HWND v6; // ST0C_4@1
  signed int v7; // edi@1
  LPARAM result; // eax@1
  LRESULT v9; // eax@5
  int v10; // edi@9
  HWND v11; // edi@18
  LRESULT v12; // eax@41
  signed int i; // [sp-8h] [bp-164h]@9
  int v14; // [sp+Ch] [bp-150h]@1
  int v15; // [sp+10h] [bp-14Ch]@1
  char v16; // [sp+14h] [bp-148h]@16
  char v17; // [sp+15h] [bp-147h]@16
  LPARAM v18; // [sp+28h] [bp-134h]@1
  LPARAM lParam; // [sp+2Ch] [bp-130h]@5
  LPARAM v20; // [sp+30h] [bp-12Ch]@2
  WPARAM v21; // [sp+34h] [bp-128h]@6
  int v22; // [sp+38h] [bp-124h]@1
  HWND hWnd; // [sp+3Ch] [bp-120h]@1
  HWND v24; // [sp+40h] [bp-11Ch]@1
  char Dst; // [sp+44h] [bp-118h]@18
  char v26; // [sp+58h] [bp-104h]@17

  v6 = *(HWND *)a1;
  v14 = 0;
  memset(&v15, 0, 0x18u);
  v22 = a1;
  hWnd = GetDlgItem(v6, nIDDlgItem);
  v7 = wParam;
  v24 = GetDlgItem(*(HWND *)a1, a4);
  result = SendMessageW(hWnd, 0x199u, wParam, 0);
  v18 = result;
  if ( (wParam & 0x80000000) == 0 )
  {
    result = (unsigned int)result >> 16;
    v20 = result;
    if ( !(result & 0x8000) )
    {
      if ( a4 != 203 || (result = (LPARAM)SendItemNotify(*(HDC *)(v22 + 4), a5, -706)) != 0 )
      {
        v9 = SendMessageW(hWnd, 0x18Au, wParam, 0);
        result = (LPARAM)LocalAlloc(0x40u, 2 * v9 + 2);
        lParam = result;
        if ( result )
        {
          SendMessageW(hWnd, 0x189u, wParam, result);
          SendMessageW(hWnd, 0xBu, 0, 0);
          SendMessageW(v24, 0xBu, 0, 0);
          v21 = SendMessageW(v24, 0x18Eu, 0, 0);
          if ( a4 == 201 )
          {
            if ( v20 & 0x6000 )
            {
              a5 = 0;
              goto LABEL_24;
            }
            v10 = v20 & 0x1FFF;
            a5 = 1;
            for ( i = 1; (unsigned int)SendMessageW(v24, 0x199u, i, 0) >> 16 < v10; i = a5 )
              ++a5;
          }
          else if ( (a5 & 0x80000000) != 0 )
          {
            goto LABEL_40;
          }
          if ( SendMessageW(v24, 0x181u, a5, lParam) == a5 )
          {
            if ( a4 == 203 )
            {
              if ( v20 & 0x2000 )
              {
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 1;
              }
              else if ( !GetAdjustInfo(*(_DWORD *)(v22 + 4), v20 & 0x1FFF, (int)&v14, (int)&v26, 128) )
              {
LABEL_19:
                SendMessageW(v24, 0x182u, a5, 0);
                goto LABEL_40;
              }
              v11 = (HWND)**(_DWORD **)(v22 + 4);
              TBOutputStruct(*(_DWORD *)(v22 + 4), (int)&v14, &Dst);
              if ( !TBInsertButtons(*(_DWORD *)(v22 + 4), a5, 1, (LPCWSTR)&Dst, 1) )
                goto LABEL_19;
              *(_DWORD *)(v22 + 4) = FixPTB(v11);
              if ( nIDDlgItem == 203 && (signed int)wParam >= (signed int)a5 )
                ++wParam;
            }
            SendMessageW(v24, 0x19Au, a5, v18);
            v7 = wParam;
LABEL_24:
            if ( nIDDlgItem != 201 || v7 )
            {
              SendMessageW(hWnd, 0x182u, v7, 0);
              if ( nIDDlgItem == a4 )
              {
                if ( v7 < (signed int)a5 )
                  --a5;
                if ( v7 < (signed int)v21 )
                  --v21;
              }
              if ( nIDDlgItem == 203 )
                DeleteButton(*(HDC *)(v22 + 4), v7);
            }
            if ( nIDDlgItem != a4 )
            {
              if ( (signed int)wParam >= SendMessageW(hWnd, 0x18Bu, 0, 0) )
                SendMessageW(hWnd, 0x186u, 0, 0);
              if ( SendMessageW(hWnd, 0x186u, wParam, 0) == -1 )
                SendMessageW(hWnd, 0x186u, wParam - 1, 0);
              SendMessageW(*(HWND *)v22, 0x111u, (unsigned __int16)nIDDlgItem | 0x10000, (LPARAM)hWnd);
            }
            SendMessageW(v24, 0x186u, a6 + a5, 0);
            SendMessageW(*(HWND *)v22, 0x111u, (unsigned __int16)a4 | 0x10000, (LPARAM)v24);
          }
LABEL_40:
          LocalFree((HLOCAL)lParam);
          if ( nIDDlgItem == a4 )
          {
            SendMessageW(v24, 0x197u, v21, 0);
            v12 = SendMessageW(v24, 0x188u, 0, 0);
            SendMessageW(v24, 0x186u, v12, 0);
          }
          SendMessageW(hWnd, 0xBu, 1u, 0);
          SendMessageW(v24, 0xBu, 1u, 0);
          InvalidateRect(v24, 0, 1);
          return (LPARAM)CCSendNotify(*(_DWORD *)(v22 + 4), -708, 0);
        }
      }
    }
  }
  return result;
}

//----- (6F7B0BAD) --------------------------------------------------------
int __stdcall HandleDragMsg(int a1, HWND hWnd, int a3, int a4)
{
  int v4; // esi@3
  int v5; // eax@5
  LRESULT v6; // eax@13
  int v7; // eax@20
  HCURSOR v9; // eax@26
  int v10; // [sp-14h] [bp-20h]@10
  LRESULT v11; // [sp-10h] [bp-1Ch]@10
  int v12; // [sp-Ch] [bp-18h]@10
  WPARAM v13; // [sp-8h] [bp-14h]@10
  LONG v14; // [sp-4h] [bp-10h]@14
  int v15; // [sp+1Ch] [bp+10h]@8
  int v16; // [sp+20h] [bp+14h]@8

  if ( a3 == 201 )
  {
    v4 = a4;
    if ( *(_DWORD *)a4 == 1157 )
      goto LABEL_27;
    if ( *(_DWORD *)a4 != 1158 )
    {
      v5 = *(_DWORD *)a4 - 1159;
      if ( *(_DWORD *)a4 != 1159 )
      {
LABEL_6:
        if ( v5 == 1 )
          InsertIndex(a1, *(POINT *)(v4 + 8), 0);
        return 0;
      }
      v7 = InsertIndex(a1, *(POINT *)(a4 + 8), 0);
      if ( v7 >= 0 )
      {
        v13 = v7;
        v12 = 203;
        v11 = SendMessageW(*(HWND *)(a4 + 4), 0x188u, 0, 0);
        v10 = 201;
        goto LABEL_22;
      }
      return 0;
    }
LABEL_24:
    if ( InsertIndex(a1, *(POINT *)(v4 + 8), 1) >= 0 || IsInButtonList(hWnd, *(struct tagPOINT *)(v4 + 8)) )
    {
      v9 = LoadCursorW(g_hinst, (LPCWSTR)0x66);
      SetCursor(v9);
      goto LABEL_14;
    }
LABEL_27:
    SetWindowLongW(hWnd, 0, 1);
    return 1;
  }
  if ( a3 != 203 )
    return 0;
  v4 = a4;
  if ( *(_DWORD *)a4 != 1157 )
  {
    if ( *(_DWORD *)a4 != 1158 )
    {
      v5 = *(_DWORD *)a4 - 1159;
      if ( *(_DWORD *)a4 != 1159 )
        goto LABEL_6;
      v16 = InsertIndex(a1, *(POINT *)(a4 + 8), 0);
      v15 = SendMessageW(*(HWND *)(v4 + 4), 0x188u, 0, 0);
      if ( v16 < 0 )
      {
        if ( IsInButtonList(hWnd, *(struct tagPOINT *)(v4 + 8)) )
        {
          v13 = 0;
          v12 = 201;
          v11 = v15;
          v10 = 203;
          goto LABEL_22;
        }
      }
      else if ( (unsigned int)(v16 - v15) > 1 )
      {
        v13 = v16;
        v12 = 203;
        v11 = v15;
        v10 = 203;
LABEL_22:
        LBMoveButton(a1, v10, v11, v12, v13, 0);
        return 0;
      }
      return 0;
    }
    goto LABEL_24;
  }
  v6 = SendMessageW(*(HWND *)(a4 + 4), 0x188u, 0, 0);
  if ( !(((unsigned int)SendMessageW(*(HWND *)(a4 + 4), 0x199u, v6, 0) >> 16) & 0x8000) )
  {
    v14 = 1;
    goto LABEL_15;
  }
LABEL_14:
  v14 = 0;
LABEL_15:
  SetWindowLongW(hWnd, 0, v14);
  return 1;
}

//----- (6F7B0D5A) --------------------------------------------------------
int __stdcall InitAdjustDlg(HWND hDlg, int a2)
{
  int v2; // eax@1
  HWND v3; // eax@3
  int v4; // eax@4
  bool v5; // zf@4
  bool v6; // sf@4
  WPARAM v7; // ecx@4
  LPARAM *v8; // eax@12
  int v9; // ST0C_4@13
  LRESULT v10; // eax@15
  int v11; // eax@16
  LRESULT v12; // eax@17
  LRESULT v13; // eax@20
  int v14; // eax@24
  int v15; // eax@28
  signed int v16; // eax@30
  LRESULT v17; // eax@32
  int v18; // ecx@34
  LRESULT v19; // eax@38
  int i; // [sp-10h] [bp-380h]@22
  HWND v22; // [sp-10h] [bp-380h]@35
  int v23; // [sp-Ch] [bp-37Ch]@22
  int v24; // [sp-8h] [bp-378h]@22
  WPARAM v25; // [sp-8h] [bp-378h]@35
  unsigned int v26; // [sp-4h] [bp-374h]@35
  LPARAM v27; // [sp+Ch] [bp-364h]@2
  HWND v28; // [sp+18h] [bp-358h]@2
  int v29; // [sp+1Ch] [bp-354h]@22
  int v30; // [sp+20h] [bp-350h]@27
  char v31; // [sp+24h] [bp-34Ch]@31
  char v32; // [sp+25h] [bp-34Bh]@26
  int v33; // [sp+38h] [bp-338h]@28
  WPARAM v34; // [sp+3Ch] [bp-334h]@1
  LRESULT v35; // [sp+40h] [bp-330h]@37
  HWND v36; // [sp+44h] [bp-32Ch]@1
  HDC hdc; // [sp+48h] [bp-328h]@20
  HGDIOBJ h; // [sp+4Ch] [bp-324h]@12
  HWND v39; // [sp+50h] [bp-320h]@2
  WPARAM v40; // [sp+54h] [bp-31Ch]@4
  WPARAM v41; // [sp+58h] [bp-318h]@5
  WPARAM wParam; // [sp+5Ch] [bp-314h]@4
  HWND hWnd; // [sp+60h] [bp-310h]@2
  LPARAM lParam; // [sp+64h] [bp-30Ch]@1
  wchar_t pszDest; // [sp+26Ch] [bp-104h]@22

  LOWORD(lParam) = 0;
  v36 = hDlg;
  LocalizedLoadString(1024, &lParam, 260);
  v2 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)a2 = hDlg;
  *(_DWORD *)(v2 + 72) = hDlg;
  v34 = GetNearestInsert(*(HDC *)(a2 + 4), *(_DWORD *)(a2 + 8), *(_DWORD *)(*(_DWORD *)(a2 + 4) + 132), 3);
  if ( (v34 & 0x80000000) != 0 )
    return 0;
  hWnd = GetDlgItem(hDlg, 203);
  SendMessageW(hWnd, 0x184u, 0, 0);
  v39 = GetDlgItem(v36, 201);
  SendMessageW(v39, 0x184u, 0, 0);
  v28 = v36;
  if ( CCSendNotify(*(_DWORD *)(a2 + 4), -723, (LPARAM)&v27) == (HWND)1 )
  {
    v3 = GetDlgItem(v36, 205);
    ShowWindow(v3, 0);
  }
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(v4 + 132) == 0;
  v6 = *(_DWORD *)(v4 + 132) < 0;
  v7 = *(_DWORD *)(v4 + 48);
  wParam = 0;
  v40 = v7;
  if ( !v6 && !v5 )
  {
    do
    {
      v41 = 0;
      if ( !SendItemNotify(*(HDC *)(a2 + 4), wParam, -707) )
        v41 = 0x8000;
      if ( *(_BYTE *)(v40 + 8) & 8 )
        v41 |= 0x4000u;
      if ( *(_BYTE *)(v40 + 9) & 1 )
      {
        if ( !*(_DWORD *)(v40 + 4) )
          v41 |= 0x2000u;
        h = (HGDIOBJ)-1;
        v8 = &lParam;
      }
      else
      {
        v9 = *(_DWORD *)(a2 + 4);
        h = (HGDIOBJ)((unsigned __int16)*(_DWORD *)v40 | (*(_DWORD *)v40 >> 16 << 12));
        v8 = (LPARAM *)TB_StrForButton(v9, v40);
        if ( !v8 )
          v8 = (LPARAM *)&c_szNULL;
      }
      v10 = SendMessageW(hWnd, 0x180u, 0, (LPARAM)v8);
      if ( v10 != wParam )
        return 0;
      SendMessageW(hWnd, 0x19Au, wParam++, (unsigned __int16)h | ((unsigned __int16)v41 << 16));
      v11 = *(_DWORD *)(a2 + 4);
      v40 += 28;
    }
    while ( (signed int)wParam < *(_DWORD *)(v11 + 132) );
  }
  v12 = SendMessageW(hWnd, 0x180u, 0, (LPARAM)&lParam);
  if ( v12 == wParam )
    SendMessageW(hWnd, 0x19Au, wParam, -1610547201);
  if ( SendMessageW(v39, 0x180u, 0, (LPARAM)&lParam) == -1 )
    return 0;
  SendMessageW(v39, 0x19Au, 0, 536936447);
  hdc = GetDC(hWnd);
  v13 = SendMessageW(hWnd, 0x31u, 0, 0);
  h = (HGDIOBJ)v13;
  if ( v13 )
    h = SelectObject(hdc, (HGDIOBJ)v13);
  v24 = (int)&pszDest;
  v23 = (int)&v29;
  v41 = 0;
  wParam = 0;
  for ( i = 0; GetAdjustInfo(*(_DWORD *)(a2 + 4), i, v23, v24, 128); i = wParam )
  {
    if ( !pszDest )
    {
      v14 = TB_StrForButton(*(_DWORD *)(a2 + 4), (int)&v29);
      if ( v14 )
        StringCchCopyW(&pszDest, 0x80u, (STRSAFE_LPCWSTR)v14);
    }
    if ( !(v32 & 1) || v30 )
    {
      v15 = lstrlenW(&pszDest);
      MGetTextExtent(hdc, &pszDest, v15, (int)&v33, 0);
      if ( (signed int)v41 < v33 )
        v41 = v33;
      v16 = PositionFromID(*(_DWORD *)(a2 + 4), v30);
      v40 = v16;
      if ( v16 >= 0 )
      {
        v35 = SendMessageW(hWnd, 0x199u, v16, 0);
        if ( pszDest )
        {
          SendMessageW(hWnd, 0x182u, v40, 0);
          v19 = SendMessageW(hWnd, 0x181u, v40, (LPARAM)&pszDest);
          if ( v19 != v40 )
          {
            ReleaseDC(hWnd, hdc);
            return 0;
          }
        }
        v26 = (unsigned __int16)v35 | (((unsigned __int16)wParam | ((unsigned int)v35 >> 16)) << 16);
        v25 = v40;
        v22 = hWnd;
        goto LABEL_40;
      }
      if ( !(v31 & 8) )
      {
        v17 = SendMessageW(v39, 0x180u, 0, (LPARAM)&pszDest);
        if ( v17 != -1 )
        {
          if ( v32 & 1 )
            v18 = ((unsigned __int16)wParam << 16) | 0xFFFF;
          else
            v18 = ((unsigned __int16)wParam << 16) | (unsigned __int16)v29 | (unsigned __int16)(HIWORD(v29) << 12);
          v26 = v18;
          v25 = v17;
          v22 = v39;
LABEL_40:
          SendMessageW(v22, 0x19Au, v25, v26);
          goto LABEL_41;
        }
      }
    }
LABEL_41:
    ++wParam;
    v24 = (int)&pszDest;
    v23 = (int)&v29;
  }
  if ( h )
    SelectObject(hdc, h);
  ReleaseDC(hWnd, hdc);
  v41 += *(_DWORD *)(*(_DWORD *)(a2 + 4) + 112) + 3;
  SendMessageW(v39, 0x194u, v41, 0);
  SendMessageW(hWnd, 0x194u, v41, 0);
  SendMessageW(v39, 0x186u, 0, 0);
  SendMessageW(hWnd, 0x186u, v34, 0);
  SendMessageW(v36, 0x111u, 0x100CBu, (LPARAM)hWnd);
  return 1;
}

//----- (6F7B12AD) --------------------------------------------------------
BOOL __stdcall AdjustDlgProc(HWND hWnd, UINT a2, WPARAM wParam, LPARAM a4)
{
  HWND v4; // edi@1
  int v5; // ebx@1
  int v7; // eax@13
  HWND v8; // esi@13
  WPARAM v9; // eax@19
  LRESULT v10; // eax@21
  LRESULT v11; // eax@27
  BOOL v12; // edi@31
  LRESULT v13; // eax@31
  HDC v14; // ST0C_4@31
  HWND v15; // eax@31
  unsigned int v16; // esi@31
  BOOL v17; // eax@33
  LPARAM v18; // eax@42
  int v19; // eax@43
  LRESULT v20; // eax@49
  HWND v21; // eax@52
  HWND v22; // eax@52
  HWND v23; // eax@52
  LPARAM v24; // ebx@54
  int v25; // eax@54
  HWND v26; // esi@56
  HDC v27; // edi@56
  LPARAM v28; // [sp-10h] [bp-2Ch]@45
  int v29; // [sp-Ch] [bp-28h]@45
  WPARAM v30; // [sp-8h] [bp-24h]@20
  WPARAM v31; // [sp-8h] [bp-24h]@45
  int v32; // [sp-4h] [bp-20h]@45
  LPARAM lParam; // [sp+Ch] [bp-10h]@13
  HWND v34; // [sp+18h] [bp-4h]@13

  v4 = hWnd;
  v5 = GetWindowLongW(hWnd, 8);
  if ( a2 == 43 )
  {
    PaintAdjustLine(*(HDC *)(v5 + 4), (HDC)a4);
    return 1;
  }
  if ( a2 == 44 )
  {
    v24 = a4;
    v25 = *(_DWORD *)(a4 + 4);
    if ( v25 == 201 || v25 == 203 )
    {
      v26 = GetDlgItem(v4, *(_DWORD *)(a4 + 4));
      v27 = GetDC(v26);
      hWnd = (HWND)87;
      MGetTextExtent(v27, (LPCWSTR)&hWnd, 1, 0, (int)&a4);
      if ( a4 < g_dyButtonHack + 2 )
        a4 = g_dyButtonHack + 2;
      *(_DWORD *)(v24 + 16) = a4;
      ReleaseDC(v26, v27);
    }
    return 1;
  }
  if ( a2 == 272 )
  {
    SetWindowLongW(v4, 8, a4);
    if ( !InitAdjustDlg(v4, a4) )
      EndDialog(v4, 0);
    ShowWindow(v4, 5);
    UpdateWindow(v4);
    v21 = GetDlgItem(v4, 203);
    SetFocus(v21);
    v22 = GetDlgItem(v4, 203);
    MakeDragList(v22);
    v23 = GetDlgItem(v4, 201);
    MakeDragList(v23);
    return 0;
  }
  if ( a2 != 273 )
  {
    if ( a2 == uDragListMsg )
      return HandleDragMsg(v5, v4, wParam, a4);
    return 0;
  }
  if ( (signed int)(unsigned __int16)wParam > 203 )
  {
    if ( (unsigned __int16)wParam == 204 )
    {
      v20 = SendDlgItemMessageW(hWnd, 203, 0x188u, 0, 0);
      v32 = 0;
      v31 = 0;
      v29 = 201;
      v28 = v20;
    }
    else
    {
      if ( (unsigned __int16)wParam == 205 )
      {
        CCSendNotify(*(_DWORD *)(v5 + 4), -709, 0);
        return 1;
      }
      if ( (unsigned int)(unsigned __int16)wParam - 206 > 1 )
        return 0;
      v18 = SendDlgItemMessageW(hWnd, 203, 0x188u, 0, 0);
      a4 = v18;
      if ( wParam == 206 )
        v19 = GetNearestInsert(*(HDC *)(v5 + 4), v18 - 1, 0, 2);
      else
        v19 = GetNearestInsert(*(HDC *)(v5 + 4), v18 + 2, *(_DWORD *)(*(_DWORD *)(v5 + 4) + 132), 1);
      v32 = 0;
      v31 = v19;
      v29 = 203;
      v28 = a4;
    }
    LBMoveButton(v5, 203, v28, v29, v31, v32);
    return 1;
  }
  if ( (unsigned __int16)wParam == 203 )
  {
    v9 = wParam >> 16;
    if ( wParam >> 16 == 1 )
    {
      v12 = 0;
      v13 = SendMessageW((HWND)a4, 0x188u, 0, 0);
      v14 = *(HDC *)(v5 + 4);
      wParam = v13;
      v15 = SendItemNotify(v14, v13, -706);
      SafeEnableWindow(hWnd, 1, a4, (BOOL)v15);
      v16 = ~((unsigned int)SendMessageW((HWND)a4, 0x199u, wParam, 0) >> 31) & 1;
      SafeEnableWindow(hWnd, 204, a4, v16);
      v17 = v16 && GetNearestInsert(*(HDC *)(v5 + 4), wParam - 1, 0, 2) >= 0;
      SafeEnableWindow(hWnd, 206, a4, v17);
      if ( v16 && GetNearestInsert(*(HDC *)(v5 + 4), wParam + 2, *(_DWORD *)(*(_DWORD *)(v5 + 4) + 132), 1) >= 0 )
        v12 = 1;
      SafeEnableWindow(hWnd, 207, a4, v12);
      return 1;
    }
    if ( v9 == 2 )
    {
      v30 = 204;
      goto LABEL_30;
    }
LABEL_26:
    if ( v9 - 4 <= 1 )
    {
      v11 = SendMessageW((HWND)a4, 0x188u, 0, 0);
      if ( SendMessageW((HWND)a4, 0x198u, v11, (LPARAM)&lParam) != -1 )
        InvalidateRect((HWND)a4, (const RECT *)&lParam, 0);
    }
    return 1;
  }
  if ( (unsigned __int16)wParam == 1 )
  {
    a4 = SendDlgItemMessageW(hWnd, 201, 0x188u, 0, 0);
    v10 = SendDlgItemMessageW(hWnd, 203, 0x188u, 0, 0);
    if ( v10 == -1 )
      v10 = 0;
    LBMoveButton(v5, 201, a4, 203, v10, 1);
    return 1;
  }
  if ( (unsigned __int16)wParam != 2 )
  {
    if ( (unsigned __int16)wParam != 201 )
    {
      if ( (unsigned __int16)wParam == 202 )
      {
        v7 = *(_DWORD *)(v5 + 4);
        v8 = *(HWND *)v7;
        v34 = hWnd;
        a4 = 0;
        if ( CCSendNotify(v7, -705, (LPARAM)&lParam) == (HWND)2 )
          a4 = 1;
        *(_DWORD *)(v5 + 4) = FixPTB(v8);
        *(_DWORD *)(v5 + 8) = 0;
        if ( !a4 && InitAdjustDlg(hWnd, v5) )
          return 1;
        v4 = hWnd;
        goto LABEL_18;
      }
      return 0;
    }
    v9 = wParam >> 16;
    if ( wParam >> 16 == 2 )
    {
      v30 = 1;
LABEL_30:
      SendMessageW(v4, 0x111u, v30, 0);
      return 1;
    }
    goto LABEL_26;
  }
LABEL_18:
  EndDialog(v4, 1);
  return 1;
}
// 6F7E8AB4: using guessed type int g_dyButtonHack;

//----- (6F7B16A6) --------------------------------------------------------
void __stdcall CustomizeTB(int a1, int a2)
{
  HWND v2; // ebx@1
  bool v3; // zf@2
  int v4; // eax@3
  WORD v5; // ax@5
  HRSRC v6; // eax@5
  const DLGTEMPLATE *v7; // eax@6
  int v8; // eax@8
  LPARAM dwInitParam; // [sp+Ch] [bp-Ch]@7
  int v10; // [sp+10h] [bp-8h]@2
  int v11; // [sp+14h] [bp-4h]@2

  v2 = *(HWND *)a1;
  if ( !*(_DWORD *)(a1 + 72) )
  {
    v3 = (*(_DWORD *)(a1 + 8) & 0x800) == 0;
    v10 = a1;
    v11 = a2;
    if ( v3 )
      v4 = *(_DWORD *)(a1 + 116);
    else
      v4 = *(_DWORD *)(a1 + 108);
    g_dyButtonHack = v4;
    CCSendNotify(a1, -703, 0);
    v5 = CCGetProperThreadLocale(0);
    v6 = FindResourceExRetry(g_hinst, (LPCWSTR)5, (LPCWSTR)0xC8, v5);
    if ( v6 )
    {
      v7 = (const DLGTEMPLATE *)LoadResource(g_hinst, v6);
      if ( v7 )
        DialogBoxIndirectParamW(g_hinst, v7, *(HWND *)(a1 + 4), AdjustDlgProc, (LPARAM)&dwInitParam);
    }
    v8 = GetWindowLongW(v2, 0);
    *(_DWORD *)(v8 + 72) = 0;
    CCSendNotify(v8, -704, 0);
  }
}
// 6F7E8AB4: using guessed type int g_dyButtonHack;

//----- (6F7B1759) --------------------------------------------------------
DWORD __stdcall _GetHcursorPdy3(int a1, int a2)
{
  HCURSOR v2; // eax@1
  DWORD result; // eax@1
  signed int v4; // eax@4
  int v5; // edi@5
  __int16 v6; // cx@13
  char pv; // [sp+Ch] [bp-134h]@2
  unsigned int v8; // [sp+10h] [bp-130h]@4
  unsigned int v9; // [sp+14h] [bp-12Ch]@4
  ICONINFO piconinfo; // [sp+24h] [bp-11Ch]@1
  int v11; // [sp+38h] [bp-108h]@1
  __int16 vBits[128]; // [sp+3Ch] [bp-104h]@3

  piconinfo.fIcon = 0;
  v11 = 0;
  piconinfo.xHotspot = 0;
  piconinfo.yHotspot = 0;
  piconinfo.hbmMask = 0;
  piconinfo.hbmColor = 0;
  v2 = GetCursor();
  *(_DWORD *)a2 = 16;
  *(_DWORD *)a1 = 16;
  result = GetIconInfo(v2, &piconinfo);
  if ( result )
  {
    result = GetObjectW(piconinfo.hbmMask, 24, &pv);
    if ( result )
    {
      result = GetBitmapBits(piconinfo.hbmMask, 256, vBits);
      if ( result )
      {
        v4 = v8 * v9 >> 4;
        if ( piconinfo.hbmColor )
        {
          v5 = v11;
        }
        else
        {
          v5 = v4 - 1;
          v4 /= 2;
        }
        if ( (unsigned int)v4 >= 0x80 )
          v4 = 127;
        if ( (unsigned int)v5 >= 0x80 )
        {
          v11 = 0;
          v5 = 0;
        }
        while ( 1 )
        {
          --v4;
          if ( v4 < 0 )
            break;
          if ( vBits[v4] != -1 )
            break;
          if ( v5 > 0 )
          {
            v6 = vBits[v5--];
            if ( v6 )
              break;
          }
        }
        *(_DWORD *)a2 = 16 * (v4 + 1) / v8 - piconinfo.yHotspot;
        result = 16 * (v4 + 1) / v9 - piconinfo.xHotspot;
        *(_DWORD *)a1 = result;
      }
    }
    if ( piconinfo.hbmColor )
      result = DeleteObject(piconinfo.hbmColor);
    if ( piconinfo.hbmMask )
      result = DeleteObject(piconinfo.hbmMask);
  }
  return result;
}
// 6F7B1759: using guessed type __int16 vBits[128];

//----- (6F7B18C5) --------------------------------------------------------
int __stdcall _GetCursorLowerLeft(int a1, int a2, int a3, int a4)
{
  DWORD v4; // esi@1
  int result; // eax@1

  v4 = GetMessagePos();
  _GetHcursorPdy3(a3, a4);
  *(_DWORD *)a1 = (signed __int16)v4;
  result = *(_DWORD *)a4 + SHIWORD(v4);
  *(_DWORD *)a2 = result;
  return result;
}

//----- (6F7B1900) --------------------------------------------------------
UINT __stdcall ToolTips_NewFont(int a1, HANDLE h)
{
  HGDIOBJ v2; // eax@4
  UINT result; // eax@7

  if ( *(_DWORD *)(a1 + 60) && *(_DWORD *)(a1 + 64) )
  {
    DeleteObject(*(HGDIOBJ *)(a1 + 64));
    *(_DWORD *)(a1 + 60) = 0;
  }
  v2 = h;
  if ( !h )
  {
    v2 = CCCreateStatusFont();
    *(_DWORD *)(a1 + 60) = 1;
    if ( !v2 )
    {
      v2 = g_hfontSystem;
      *(_DWORD *)(a1 + 60) = 0;
    }
  }
  *(_DWORD *)(a1 + 64) = v2;
  result = GetCodePageForFont(v2);
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

//----- (6F7B1957) --------------------------------------------------------
int __stdcall ChildOfActiveWindow(HWND hWnd)
{
  HWND v1; // esi@1
  HWND v2; // edi@1

  v1 = hWnd;
  v2 = GetForegroundWindow();
  while ( 1 )
  {
    if ( !v1 )
      return 0;
    if ( v1 == v2 )
      break;
    v1 = GetParent(v1);
  }
  return 1;
}

//----- (6F7B198E) --------------------------------------------------------
BOOL __stdcall PopBubble(int a1)
{
  int v1; // eax@6
  BOOL result; // eax@8
  LPARAM lParam; // [sp+8h] [bp-Ch]@7
  int v4; // [sp+Ch] [bp-8h]@7
  int v5; // [sp+10h] [bp-4h]@7

  if ( *(_DWORD *)(a1 + 72) )
  {
    KillTimer(*(HWND *)a1, *(_DWORD *)(a1 + 72));
    *(_DWORD *)(a1 + 72) = 0;
  }
  if ( *(_DWORD *)(a1 + 84) )
  {
    KillTimer(*(HWND *)a1, *(_DWORD *)(a1 + 84));
    *(_DWORD *)(a1 + 84) = 0;
  }
  if ( IsWindowVisible(*(HWND *)a1) )
  {
    v1 = *(_DWORD *)(a1 + 56);
    if ( v1 )
    {
      lParam = *(_DWORD *)a1;
      v4 = *(_DWORD *)(v1 + 12);
      v5 = -522;
      SendNotifyEx(*(_DWORD *)(v1 + 8), HWND_MESSAGE|0x2, -522, (LPARAM)&lParam, (*(_DWORD *)(v1 + 4) >> 6) & 1);
    }
  }
  KillTimer(*(HWND *)a1, 3u);
  result = ShowWindow(*(HWND *)a1, 0);
  *(_DWORD *)(a1 + 68) &= 0xFFFFFF3F;
  *(_DWORD *)(a1 + 56) = 0;
  return result;
}

//----- (6F7B1A26) --------------------------------------------------------
int __stdcall TTSetTimer(int a1, UINT_PTR nIDEvent)
{
  UINT v2; // edi@1
  UINT v3; // eax@7
  int result; // eax@9
  UINT v5; // eax@11

  v2 = 0;
  if ( *(_DWORD *)(a1 + 72) )
    KillTimer(*(HWND *)a1, *(_DWORD *)(a1 + 72));
  if ( nIDEvent == 1 )
  {
    v2 = *(_DWORD *)(a1 + 40);
    if ( (v2 & 0x80000000) == 0 )
      goto LABEL_15;
    v5 = GetDoubleClickTime();
    goto LABEL_14;
  }
  if ( (signed int)nIDEvent <= 1 )
    goto LABEL_15;
  if ( (signed int)nIDEvent <= 3 )
  {
    v2 = *(_DWORD *)(a1 + 44);
    if ( (v2 & 0x80000000) == 0 )
      goto LABEL_15;
    v5 = GetDoubleClickTime() / 5;
LABEL_14:
    v2 = v5;
    goto LABEL_15;
  }
  if ( nIDEvent == 4 )
  {
    v3 = *(_DWORD *)(a1 + 48);
    if ( (v3 & 0x80000000) != 0 )
      v3 = 10 * GetDoubleClickTime();
    result = SetTimer(*(HWND *)a1, 4u, v3, 0);
    *(_DWORD *)(a1 + 84) = result;
    return result;
  }
LABEL_15:
  result = SetTimer(*(HWND *)a1, nIDEvent, v2, 0);
  if ( result && nIDEvent != 3 )
  {
    *(_DWORD *)(a1 + 72) = nIDEvent;
    result = GetCursorPos((LPPOINT)(a1 + 76));
  }
  return result;
}

//----- (6F7B1ACC) --------------------------------------------------------
int __stdcall TTWindowFromPoint(int a1, LPARAM lParam)
{
  int v2; // esi@1
  LONG v3; // eax@1
  int v4; // ebx@1
  LRESULT v5; // eax@1
  int v7; // [sp+14h] [bp+8h]@1

  v2 = a1;
  v3 = SetWindowBits(*(HWND *)a1, -16, 0x8000000, 0);
  *(_DWORD *)(v2 + 124) |= 8u;
  v4 = v3;
  v5 = SendMessageW(*(HWND *)a1, 0x410u, 0, lParam);
  *(_DWORD *)(v2 + 124) &= 0xFFFFFFF7;
  v7 = v5;
  SetWindowBits(*(HWND *)v2, -16, 0x8000000, v4);
  return v7;
}

//----- (6F7B1B21) --------------------------------------------------------
signed int __stdcall ToolHasMoved(int a1)
{
  int v1; // eax@1
  signed int result; // eax@2
  HWND v3; // edi@4
  struct tagRECT Rect; // [sp+4h] [bp-10h]@10

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 )
  {
    if ( *(_BYTE *)(v1 + 4) & 1 )
      v3 = *(HWND *)(v1 + 12);
    else
      v3 = *(HWND *)(v1 + 8);
    result = 1;
    if ( IsWindowVisible(v3)
      && (*(_BYTE *)(a1 + 8) & 1 || ChildOfActiveWindow(v3))
      && v3 == (HWND)TTWindowFromPoint(a1, a1 + 76) )
    {
      GetWindowRect(v3, &Rect);
      if ( PtInRect(&Rect, *(POINT *)(a1 + 76)) )
        result = 0;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F7B1BA1) --------------------------------------------------------
int __stdcall FindTool(int a1, int a2)
{
  int v3; // esi@7
  int v4; // edi@7
  int v5; // ecx@8

  if ( !a1 || !a2 || *(_DWORD *)a2 > 0x2Cu )
    return 0;
  if ( !(a2 & 0xFFFF0000) )
  {
    if ( a2 < *(_DWORD *)(a1 + 36) )
      return *(_DWORD *)(a1 + 52) + 44 * a2;
    return 0;
  }
  v3 = *(_DWORD *)(a1 + 36);
  v4 = 0;
  if ( v3 <= 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 52);
  while ( *(_DWORD *)(v5 + 8) != *(_DWORD *)(a2 + 8) || *(_DWORD *)(v5 + 12) != *(_DWORD *)(a2 + 12) )
  {
    ++v4;
    v5 += 44;
    if ( v4 >= v3 )
      return 0;
  }
  return v5;
}

//----- (6F7B1C06) --------------------------------------------------------
int __stdcall TTUnsubclassHwnd(HWND hWnd, UINT_PTR uIdSubclass, int a3)
{
  HWND v3; // edi@1
  int result; // eax@1

  v3 = hWnd;
  result = IsWindow(hWnd);
  if ( result )
  {
    result = GetWindowSubclass(v3, TTSubclassProc, uIdSubclass, (DWORD_PTR *)&hWnd);
    if ( result )
    {
      if ( a3 || (unsigned int)hWnd <= 1 )
        result = RemoveWindowSubclass(v3, TTSubclassProc, uIdSubclass);
      else
        result = SetWindowSubclass(v3, TTSubclassProc, uIdSubclass, (DWORD_PTR)((char *)hWnd - 1));
    }
  }
  return result;
}

//----- (6F7B1C63) --------------------------------------------------------
LRESULT __stdcall TTSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  if ( (uMsg < 0x200 || uMsg > 0x20D) && uMsg != 160 )
  {
    if ( uMsg == 130 )
      TTUnsubclassHwnd(hWnd, uIdSubclass, 1);
  }
  else
  {
    RelayToToolTips((HWND)uIdSubclass, (int)hWnd, uMsg, wParam, lParam);
  }
  return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

//----- (6F7B1CC6) --------------------------------------------------------
int __stdcall TTSubclassHwnd(DWORD_PTR pdwRefData, UINT_PTR uIdSubclass)
{
  HWND v2; // edi@2
  int result; // eax@4

  if ( *(_BYTE *)(pdwRefData + 4) & 1 )
    v2 = *(HWND *)(pdwRefData + 12);
  else
    v2 = *(HWND *)(pdwRefData + 8);
  result = IsWindow(v2);
  if ( result )
  {
    GetWindowSubclass(v2, TTSubclassProc, uIdSubclass, &pdwRefData);
    result = SetWindowSubclass(v2, TTSubclassProc, uIdSubclass, pdwRefData + 1);
  }
  return result;
}

//----- (6F7B1D16) --------------------------------------------------------
wchar_t *__stdcall TTSetTipText(int a1, LPCWSTR lpString)
{
  int v2; // esi@1
  int v3; // eax@1
  wchar_t *result; // eax@6

  v2 = a1 + 36;
  v3 = *(_DWORD *)(a1 + 36);
  if ( v3 == -1 || !(v3 & 0xFFFF0000) )
    *(_DWORD *)v2 = 0;
  if ( lpString != (LPCWSTR)-1 && (unsigned int)lpString & 0xFFFF0000 )
  {
    result = Str_Set(v2, lpString);
  }
  else
  {
    result = Str_Set(v2, 0);
    *(_DWORD *)v2 = lpString;
  }
  return result;
}

//----- (6F7B1D60) --------------------------------------------------------
wchar_t *__stdcall TTBeforeFreeTool(UINT_PTR *a1, int a2)
{
  int v2; // eax@1
  HWND v3; // eax@3

  v2 = *(_DWORD *)(a2 + 4);
  if ( v2 & 0x10 )
  {
    if ( v2 & 1 )
      v3 = *(HWND *)(a2 + 12);
    else
      v3 = *(HWND *)(a2 + 8);
    TTUnsubclassHwnd(v3, *a1, 0);
  }
  return TTSetTipText(a2, 0);
}

//----- (6F7B1D9B) --------------------------------------------------------
int __stdcall DeleteTool(int a1, int a2)
{
  int result; // eax@1
  int v3; // edi@2
  int v4; // [sp+Ch] [bp+Ch]@2

  result = a2;
  if ( *(_DWORD *)a2 <= 0x2Cu )
  {
    result = FindTool(a1, a2);
    v3 = result;
    v4 = result;
    if ( result )
    {
      if ( *(_DWORD *)(a1 + 56) == result )
        PopBubble(a1);
      TTBeforeFreeTool((UINT_PTR *)a1, v3);
      --*(_DWORD *)(a1 + 36);
      qmemcpy((void *)v3, (const void *)(*(_DWORD *)(a1 + 52) + 44 * *(_DWORD *)(a1 + 36)), 0x2Cu);
      result = *(_DWORD *)(a1 + 52) + 44 * *(_DWORD *)(a1 + 36);
      if ( *(_DWORD *)(a1 + 56) == result )
      {
        result = v4;
        *(_DWORD *)(a1 + 56) = v4;
      }
    }
  }
  return result;
}

//----- (6F7B1E01) --------------------------------------------------------
int __stdcall StripAccels(int a1)
{
  int result; // eax@1

  result = a1;
  if ( !(*(_BYTE *)(a1 + 8) & 2) )
    result = StripAccelerators(*(_DWORD *)(a1 + 88), *(_DWORD *)(a1 + 88), 0);
  return result;
}

//----- (6F7B1E24) --------------------------------------------------------
int __stdcall GetToolRect(int a1, LPRECT lpRect)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 4) & 1 )
  {
    result = GetWindowRect(*(HWND *)(a1 + 12), lpRect);
  }
  else
  {
    lpRect->left = *(_DWORD *)(a1 + 16);
    lpRect->top = *(_DWORD *)(a1 + 20);
    lpRect->right = *(_DWORD *)(a1 + 24);
    lpRect->bottom = *(_DWORD *)(a1 + 28);
    result = MapWindowPoints(*(HWND *)(a1 + 8), 0, (LPPOINT)lpRect, 2u);
  }
  return result;
}

//----- (6F7B1E67) --------------------------------------------------------
int __stdcall PointInTool(int a1, int a2, POINT pt)
{
  int v3; // ecx@1

  v3 = *(_DWORD *)(a1 + 4);
  if ( !(v3 & 0x420) )
  {
    if ( v3 & 1 )
    {
      if ( a2 == *(_DWORD *)(a1 + 12) )
        return 1;
    }
    else if ( a2 == *(_DWORD *)(a1 + 8) && PtInRect((const RECT *)(a1 + 16), pt) )
    {
      return 1;
    }
  }
  return 0;
}

//----- (6F7B1EB1) --------------------------------------------------------
BOOL __stdcall ShowVirtualBubble(int a1)
{
  int v1; // edi@1
  BOOL result; // eax@1

  v1 = *(_DWORD *)(a1 + 56);
  result = PopBubble(a1);
  *(_DWORD *)(a1 + 68) |= 0x80u;
  *(_DWORD *)(a1 + 56) = v1;
  return result;
}

//----- (6F7B1ED9) --------------------------------------------------------
int __stdcall TTGetTipPosition(int a1, POINT pt, int a3, int a4, int a5)
{
  int v5; // esi@1
  LONG v6; // edi@1
  signed int v7; // ebx@1
  int v8; // eax@1
  int v9; // eax@8
  LONG v10; // edi@9
  int v11; // ecx@9
  int v12; // ebx@9
  LONG v13; // ecx@18
  LONG v14; // eax@18
  LONG v15; // eax@23
  LONG v16; // ecx@31
  signed int v17; // eax@31
  bool v18; // zf@31
  int v19; // ebx@34
  POINT v20; // ST04_8@34
  HMONITOR v21; // eax@43
  char *v22; // eax@43
  LONG v23; // eax@47
  int v24; // eax@51
  LONG v25; // eax@53
  LONG v26; // eax@57
  LONG v27; // ecx@57
  LONG v28; // eax@60
  int v29; // ecx@64
  LONG v30; // eax@66
  int result; // eax@71
  struct tagMONITORINFO mi; // [sp+Ch] [bp-5Ch]@35
  struct tagRECT rcDst; // [sp+34h] [bp-34h]@45
  struct tagRECT Rect; // [sp+44h] [bp-24h]@8
  int v35; // [sp+54h] [bp-14h]@1
  HMONITOR hMonitor; // [sp+58h] [bp-10h]@34
  int v37; // [sp+5Ch] [bp-Ch]@1
  LONG v38; // [sp+60h] [bp-8h]@10
  int v39; // [sp+64h] [bp-4h]@1
  int v40; // [sp+70h] [bp+8h]@1
  int v41; // [sp+7Ch] [bp+14h]@1

  v5 = a1;
  v6 = pt.y + *(_DWORD *)(a1 + 140) + *(_DWORD *)(a1 + 148) + 4 * g_cxBorder;
  v7 = a3 + *(_DWORD *)(a1 + 144) + *(_DWORD *)(a1 + 152) + 2 * g_cyBorder;
  v41 = -1;
  v8 = *(_DWORD *)(a1 + 8) & 0x40;
  pt.y += *(_DWORD *)(a1 + 140) + *(_DWORD *)(a1 + 148) + 4 * g_cxBorder;
  v40 = v7;
  v39 = v8;
  v37 = 0;
  v35 = 0;
  if ( v8 || *(_DWORD *)(v5 + 100) )
  {
    v6 += 20;
    v7 += 16;
    pt.y = v6;
    v40 = v7;
    if ( v8 )
    {
      if ( v6 >= 30 )
      {
        *(_DWORD *)(v5 + 156) = 20;
        if ( v7 / 3 < 20 )
          *(_DWORD *)(v5 + 156) = v7 / 3;
      }
      else
      {
        *(_DWORD *)(v5 + 156) = 0;
      }
    }
  }
  GetToolRect(*(_DWORD *)(v5 + 56), &Rect);
  v9 = *(_DWORD *)(*(_DWORD *)(v5 + 56) + 4);
  if ( v9 & 0x20 )
  {
    v10 = pt.x;
    v11 = v39;
    *(_QWORD *)*(_DWORD *)&pt = *(_QWORD *)(v5 + 116);
    v12 = pt.x + 4;
    if ( v11 )
    {
      pt.x = *(_DWORD *)(v5 + 116);
      v38 = *(_DWORD *)(v5 + 120);
    }
    if ( *(_BYTE *)(*(_DWORD *)(v5 + 56) + 4) & 2 )
    {
      *(_DWORD *)v10 += pt.y / -2;
      if ( !v11 )
        *(_DWORD *)v12 += v40 / -2;
    }
    if ( *(_BYTE *)(*(_DWORD *)(v5 + 56) + 4) & 0x80 )
    {
      if ( v11 )
        v40 += *(_DWORD *)(v5 + 156);
      goto LABEL_71;
    }
    if ( !v11 )
    {
      v13 = *(_DWORD *)(v5 + 120);
      v14 = Rect.bottom;
      if ( v13 > Rect.bottom )
      {
        v41 = 2;
        if ( *(_DWORD *)v12 >= Rect.bottom )
          goto LABEL_43;
LABEL_27:
        *(_DWORD *)v12 = v14;
        goto LABEL_43;
      }
      if ( *(_DWORD *)(v5 + 116) >= Rect.left )
      {
        if ( v13 < Rect.top )
        {
          v41 = 0;
          if ( v40 + *(_DWORD *)v12 <= Rect.top )
            goto LABEL_43;
          v14 = Rect.top - v40;
          goto LABEL_27;
        }
        v15 = Rect.right;
        v41 = 3;
        if ( *(_DWORD *)v10 >= Rect.right )
          goto LABEL_43;
      }
      else
      {
        v41 = 1;
        if ( pt.y + *(_DWORD *)v10 <= Rect.left )
          goto LABEL_43;
        v15 = Rect.left - pt.y;
      }
      *(_DWORD *)v10 = v15;
      goto LABEL_43;
    }
  }
  else
  {
    if ( v9 & 2 )
    {
      v16 = Rect.bottom;
      v17 = Rect.left + Rect.right - v6;
      v10 = pt.x;
      v18 = v39 == 0;
      *(_DWORD *)pt.x = v17 / 2;
      *(_DWORD *)(pt.x + 4) = v16;
      if ( v18 )
        goto LABEL_43;
      pt.x = (Rect.left + Rect.right) / 2;
      v38 = v16;
      goto LABEL_39;
    }
    v10 = pt.x;
    _GetCursorLowerLeft(pt.x, pt.x + 4, (int)&v35, (int)&v37);
    if ( !v39 )
      goto LABEL_43;
    v19 = *(_DWORD *)(pt.x + 4) - *(_DWORD *)(v5 + 156) - v37 - v40;
    pt.x = *(_DWORD *)pt.x;
    v20.x = pt.x;
    v38 = *(_DWORD *)(v10 + 4);
    v20.y = v38;
    hMonitor = MonitorFromPoint(v20, 2u);
    if ( hMonitor == MonitorFromPoint((POINT)__PAIR__(v19, pt.x), 2u)
      && (mi.cbSize = 40, GetMonitorInfoW(hMonitor, &mi), PtInRect(&mi.rcMonitor, (POINT)__PAIR__(v19, pt.x))) )
    {
      v38 -= v37;
      *(_DWORD *)(v10 + 4) = v19;
    }
    else
    {
      pt.x += v35 / 2;
    }
  }
  v7 = v40;
LABEL_39:
  if ( !(*(_BYTE *)(*(_DWORD *)(v5 + 56) + 4) & 2) && pt.y > *(_DWORD *)(v5 + 156) + 16 )
    *(_DWORD *)v10 -= 16;
  v40 = *(_DWORD *)(v5 + 156) + v7;
LABEL_43:
  v12 = v10 + 4;
  v21 = MonitorFromPoint(*(POINT *)v10, 2u);
  mi.cbSize = 40;
  GetMonitorInfoW(v21, &mi);
  v18 = (GetWindowLongW(*(HWND *)v5, -20) & 8) == 0;
  v22 = (char *)&mi.rcMonitor;
  if ( v18 )
    v22 = (char *)&mi.rcWork;
  CopyRect(&rcDst, (const RECT *)v22);
  if ( v40 + *(_DWORD *)v12 >= rcDst.bottom )
  {
    if ( v41 == 2 )
    {
      v23 = Rect.top;
LABEL_48:
      *(_DWORD *)v12 = v23 - v40;
      goto LABEL_53;
    }
    if ( *(_BYTE *)(*(_DWORD *)(v5 + 56) + 4) & 0x20 )
    {
      v23 = *(_DWORD *)(v5 + 120);
      goto LABEL_48;
    }
    v24 = (signed __int16)(GetMessagePos() >> 16);
    v18 = v39 == 0;
    *(_DWORD *)v12 = v24 - v40;
    if ( !v18 )
      v38 = v24;
  }
LABEL_53:
  v25 = rcDst.top;
  if ( *(_DWORD *)v12 < rcDst.top )
  {
    if ( !v41 )
      v25 = Rect.bottom;
    *(_DWORD *)v12 = v25;
  }
  v26 = pt.y;
  v27 = rcDst.right;
  if ( pt.y + *(_DWORD *)v10 < rcDst.right )
    goto LABEL_66;
  if ( v39 )
  {
    if ( pt.y >= 30 )
    {
      v28 = (pt.y - *(_DWORD *)(v5 + 156)) / 2;
      if ( v28 > 16 )
        v28 = 16;
      *(_DWORD *)v10 = pt.x + v28 - pt.y;
      v26 = pt.y;
    }
    if ( v26 + *(_DWORD *)v10 < v27 )
      goto LABEL_66;
  }
  else if ( v41 == 3 )
  {
    v29 = Rect.left - pt.y;
    goto LABEL_65;
  }
  v29 = v27 - v26 - 1;
LABEL_65:
  *(_DWORD *)v10 = v29;
LABEL_66:
  v30 = rcDst.left;
  if ( *(_DWORD *)v10 < rcDst.left )
  {
    if ( v41 == 1 && !v39 )
      v30 = Rect.right;
    *(_DWORD *)v10 = v30;
  }
LABEL_71:
  *(_DWORD *)(v10 + 8) = pt.y + *(_DWORD *)v10;
  result = v40 + *(_DWORD *)v12;
  v18 = v39 == 0;
  *(_DWORD *)(v10 + 12) = result;
  if ( !v18 && a4 )
  {
    result = a5;
    if ( a5 )
    {
      *(_DWORD *)a4 = pt.x;
      *(_DWORD *)a5 = v38;
    }
  }
  return result;
}

//----- (6F7B22A0) --------------------------------------------------------
int __stdcall TTCreateTitleBitmaps(HICON hIcon)
{
  HICON v1; // ebx@1
  int result; // eax@2
  HIMAGELIST v3; // eax@3
  HICON v4; // edi@4
  HICON v5; // esi@4
  HICON hIcona; // [sp+Ch] [bp+8h]@4

  v1 = hIcon;
  if ( *((_DWORD *)hIcon + 28) )
  {
    result = 1;
  }
  else
  {
    v3 = ImageList_Create(16, 16, 0x19u, 3, 1);
    *((_DWORD *)hIcon + 28) = v3;
    if ( v3 )
    {
      v4 = (HICON)LoadImageW(g_hinst, (LPCWSTR)0x5001, 1u, 16, 16, 0);
      ImageList_ReplaceIcon(*((HIMAGELIST *)hIcon + 28), -1, v4);
      DestroyIcon(v4);
      hIcona = (HICON)LoadImageW(g_hinst, (LPCWSTR)0x5002, 1u, 16, 16, 0);
      ImageList_ReplaceIcon(*((HIMAGELIST *)v1 + 28), -1, hIcona);
      DestroyIcon(hIcona);
      v5 = (HICON)LoadImageW(g_hinst, (LPCWSTR)0x5000, 1u, 16, 16, 0);
      ImageList_ReplaceIcon(*((HIMAGELIST *)v1 + 28), -1, v5);
      DestroyIcon(v5);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (6F7B2363) --------------------------------------------------------
int __stdcall TTRenderTitledTip(int a1, HDC hdcDst, int a3, RECT *lprcSrc, int a5)
{
  int result; // eax@1
  RECT *v6; // edi@1
  int v7; // eax@2
  struct _IMAGELIST *v8; // ecx@4
  int v9; // edi@10
  HGDIOBJ v10; // eax@10
  signed int v11; // eax@12
  int v12; // eax@16
  int v13; // eax@18
  int v14; // eax@21
  COLORREF color; // [sp+10h] [bp-8Ch]@0
  HGDIOBJ h; // [sp+14h] [bp-88h]@10
  int mode; // [sp+18h] [bp-84h]@0
  HFONT ho; // [sp+1Ch] [bp-80h]@10
  struct tagRECT rcDst; // [sp+20h] [bp-7Ch]@2
  int v20; // [sp+30h] [bp-6Ch]@1
  HDC hdc; // [sp+34h] [bp-68h]@1
  int v22; // [sp+38h] [bp-64h]@1
  char pv; // [sp+3Ch] [bp-60h]@10
  int v24; // [sp+4Ch] [bp-50h]@10

  result = 0;
  v6 = lprcSrc;
  hdc = hdcDst;
  v20 = 0;
  v22 = 0;
  if ( *(_DWORD *)(a1 + 100) )
  {
    CopyRect(&rcDst, lprcSrc);
    v7 = *(_DWORD *)(a1 + 104);
    if ( v7 )
    {
      v20 = 24;
      v22 = 16;
      if ( !a3 )
      {
        v8 = *(struct _IMAGELIST **)(a1 + 112);
        if ( v8 )
          ImageList_Draw(v8, v7 - 1, hdcDst, rcDst.left, rcDst.top, 1u);
      }
      rcDst.left += 24;
    }
    if ( !a3 )
    {
      color = SetTextColor(hdcDst, *(_DWORD *)(a1 + 132));
      mode = SetBkMode(hdcDst, 1);
    }
    if ( **(_WORD **)(a1 + 96) )
    {
      v9 = a5 | 0x20;
      v10 = GetCurrentObject(hdc, 6u);
      GetObjectW(v10, 92, &pv);
      v24 = 700;
      ho = CreateFontIndirectW((const LOGFONTW *)&pv);
      h = SelectObject(hdc, ho);
      if ( !a3 )
        v9 = a5 | 0x28;
      v11 = *(_DWORD *)(a1 + 108);
      if ( v11 <= 16 )
        v11 = 16;
      rcDst.bottom = rcDst.top + v11;
      if ( a3 )
        rcDst.right = rcDst.left + 300;
      v12 = lstrlenW(*(LPCWSTR *)(a1 + 96));
      DrawTextW(hdc, *(LPCWSTR *)(a1 + 96), v12, &rcDst, v9);
      if ( !*(_DWORD *)(a1 + 108) )
        *(_DWORD *)(a1 + 108) = rcDst.bottom - rcDst.top;
      v13 = *(_DWORD *)(a1 + 108);
      if ( v22 > v13 )
        v13 = v22;
      v22 = v13 + 6;
      v20 += rcDst.right - rcDst.left;
      SelectObject(hdc, h);
      DeleteObject(ho);
      v6 = lprcSrc;
    }
    CopyRect(&rcDst, v6);
    rcDst.top += v22;
    v14 = lstrlenW(*(LPCWSTR *)(a1 + 88));
    DrawTextW(hdc, *(LPCWSTR *)(a1 + 88), v14, &rcDst, a5 & 0xFFFFFFDF);
    v22 += rcDst.bottom - rcDst.top;
    if ( v20 <= rcDst.right - rcDst.left )
      v20 = rcDst.right - rcDst.left;
    if ( a3 )
    {
      v6->right = v20 + v6->left;
      v6->bottom = v22 + v6->top;
    }
    else
    {
      SetTextColor(hdc, color);
      SetBkMode(hdc, mode);
    }
    result = 1;
  }
  return result;
}

//----- (6F7B257E) --------------------------------------------------------
int __stdcall TTGetTipSize(UINT format, int a2, LPCWSTR lpString, int a4, int a5)
{
  int v5; // ebx@1
  HDC v6; // esi@1
  void *v7; // eax@1
  bool v8; // zf@3
  int v9; // edi@6
  int v10; // esi@6
  int v11; // eax@7
  unsigned int v12; // eax@11
  int v13; // ST00_4@13
  LONG v14; // ecx@19
  UINT v15; // ST10_4@20
  int v16; // eax@20
  int v17; // ST10_4@24
  int v18; // ST00_4@24
  int result; // eax@27
  LPARAM lParam; // [sp+Ch] [bp-3Ch]@3
  int v21; // [sp+10h] [bp-38h]@3
  int v22; // [sp+14h] [bp-34h]@3
  int v23; // [sp+18h] [bp-30h]@3
  HDC v24; // [sp+1Ch] [bp-2Ch]@3
  struct tagRECT rc; // [sp+20h] [bp-28h]@3
  UINT v26; // [sp+3Ch] [bp-Ch]@13
  HGDIOBJ h; // [sp+40h] [bp-8h]@2
  HDC hdc; // [sp+44h] [bp-4h]@1
  UINT formata; // [sp+50h] [bp+8h]@3
  int formatb; // [sp+50h] [bp+8h]@6
  int v31; // [sp+5Ch] [bp+14h]@13

  v5 = format;
  v6 = GetDC(*(HWND *)format);
  v7 = *(void **)(format + 64);
  hdc = v6;
  if ( v7 )
    h = SelectObject(v6, v7);
  v8 = (*(_BYTE *)(format + 8) & 2) == 0;
  lParam = *(_DWORD *)format;
  formata = 0;
  v21 = *(_DWORD *)(a2 + 12);
  v22 = -12;
  v24 = v6;
  v23 = 1;
  rc.top = 0;
  rc.left = 0;
  if ( !v8 )
    formata = 2048;
  if ( *(_DWORD *)(v5 + 136) == -1 )
  {
    v9 = a5;
    v10 = a4;
    formatb = formata | 0x420;
    MGetTextExtent(hdc, lpString, -1, a4, a5);
    rc.right = *(_DWORD *)a4;
    rc.bottom = *(_DWORD *)a5;
  }
  else
  {
    formatb = formata | 0x650;
    rc.right = *(_DWORD *)(v5 + 136);
    rc.bottom = 0;
    v11 = lstrlenW(lpString);
    DrawTextW(v6, lpString, v11, &rc, formatb);
    v10 = a4;
    v9 = a5;
    *(_DWORD *)a4 = rc.right;
    *(_DWORD *)a5 = rc.bottom;
  }
  if ( *(_BYTE *)(*(_DWORD *)(v5 + 56) + 4) & 4 || *(_DWORD *)(v5 + 24) & 0x2000 )
    formatb |= 0x20000u;
  v12 = *(_DWORD *)(a2 + 4);
  if ( v12 & 0x800 )
    formatb |= 2u;
  v13 = *(_DWORD *)(a2 + 8);
  v26 = formatb;
  v31 = (int)SendNotifyEx(v13, HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, (v12 >> 6) & 1);
  if ( TTRenderTitledTip(v5, hdc, 1, &rc, formatb) )
    goto LABEL_21;
  if ( v31 & 2 || v26 != formatb )
  {
    v15 = v26;
    v16 = lstrlenW(lpString);
    DrawTextW(hdc, lpString, v16, &rc, v15);
LABEL_21:
    *(_DWORD *)v10 = rc.right - rc.left;
    *(_DWORD *)v9 = rc.bottom - rc.top;
    goto LABEL_22;
  }
  if ( *(_DWORD *)(v5 + 28) >= 5 && (rc.right - rc.left != *(_DWORD *)v10 || rc.bottom - rc.top != *(_DWORD *)v9) )
  {
    v14 = rc.bottom - rc.top;
    *(_DWORD *)v10 = rc.right - rc.left;
    *(_DWORD *)v9 = v14;
  }
LABEL_22:
  if ( !(v31 & 4) && v31 & 0x10 )
  {
    v17 = (*(_DWORD *)(a2 + 4) >> 6) & 1;
    v18 = *(_DWORD *)(a2 + 8);
    v23 = 2;
    SendNotifyEx(v18, HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, v17);
  }
  if ( *(_DWORD *)(v5 + 64) )
    SelectObject(hdc, h);
  ReleaseDC(*(HWND *)v5, hdc);
  *(_DWORD *)v10 += g_cxEdge;
  result = g_cyEdge;
  *(_DWORD *)v9 += g_cyEdge;
  return result;
}

//----- (6F7B2771) --------------------------------------------------------
signed int __stdcall TTAdjustRect(int a1, int a2, int a3)
{
  signed int result; // eax@2
  int v4; // edx@3
  int v5; // ecx@3
  bool v6; // zf@3
  DWORD v7; // ST0C_4@6
  HMENU v8; // eax@6
  struct tagRECT rc; // [sp+4h] [bp-10h]@3

  if ( a3 )
  {
    v4 = *(_DWORD *)(a1 + 144);
    rc.left = -2 * g_cxBorder - *(_DWORD *)(a1 + 140);
    v5 = *(_DWORD *)(a1 + 148) + 2 * g_cxBorder;
    rc.top = -(g_cyBorder + v4);
    v6 = (*(_BYTE *)(a1 + 8) & 0x40) == 0;
    rc.bottom = *(_DWORD *)(a1 + 152) + g_cyBorder - 1;
    rc.right = v5 - 1;
    if ( !v6 || *(_DWORD *)(a1 + 100) )
      InflateRect(&rc, 10, 8);
    v7 = GetWindowLongW(*(HWND *)a1, -20);
    v8 = GetMenu(*(HWND *)a1);
    AdjustWindowRectEx(&rc, *(_DWORD *)(a1 + 8), (BOOL)v8, v7);
    if ( a2 )
    {
      *(_DWORD *)a3 += rc.left;
      *(_DWORD *)(a3 + 8) += rc.right;
      *(_DWORD *)(a3 + 4) += rc.top;
      *(_DWORD *)(a3 + 12) += rc.bottom;
    }
    else
    {
      *(_DWORD *)a3 -= rc.left;
      *(_DWORD *)(a3 + 8) -= rc.right;
      *(_DWORD *)(a3 + 4) -= rc.top;
      *(_DWORD *)(a3 + 12) -= rc.bottom;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B2848) --------------------------------------------------------
HRGN __stdcall CreateBalloonRgn(int a1, int a2, int x2, int a4, int a5, int a6, int a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // edi@4
  int v10; // ebx@6
  int v11; // eax@8
  int v12; // ecx@17
  int v13; // ecx@21
  LONG v14; // edx@26
  int v15; // eax@29
  int v16; // ecx@32
  int v17; // ecx@36
  int v18; // ecx@41
  HRGN v19; // eax@43
  void *v20; // esi@43
  POINT pptl; // [sp+0h] [bp-18h]@28
  int v23; // [sp+8h] [bp-10h]@40
  LONG v24; // [sp+Ch] [bp-Ch]@40
  int v25; // [sp+10h] [bp-8h]@43
  int v26; // [sp+14h] [bp-4h]@43
  HRGN x2a; // [sp+28h] [bp+10h]@4

  v7 = a4;
  v8 = 0;
  if ( a6 )
    v7 = a4 - a5;
  else
    v8 = a5;
  v9 = x2;
  x2a = CreateRoundRectRgn(0, v8, x2, v7, 13, 13);
  if ( x2a && v9 >= 30 )
  {
    v10 = a5 + 1;
    if ( a1 != v9 / 2 && v9 >= a5 + 33 )
    {
      if ( a1 <= v9 / 2 )
      {
        if ( a7 )
          v11 = v9 - 16;
        else
          v11 = 16;
      }
      else if ( a7 )
      {
        v11 = a5 + 17;
      }
      else
      {
        v11 = v9 - v10 - 16;
      }
    }
    else
    {
      v11 = (v9 - v10) / 2;
    }
    if ( a7 )
    {
      v12 = a1 + v11 - v9;
      if ( v12 < 0 )
        v12 = v9 - v11 - a1;
      if ( v12 <= 2 )
        v11 = v9 - a1;
    }
    else
    {
      v13 = v11 - a1;
      if ( v11 - a1 < 0 )
        v13 = a1 - v11;
      if ( v13 <= 2 )
        v11 = a1;
    }
    if ( a6 )
      v14 = a4 - a5 - 2;
    else
      v14 = a5 + 2;
    pptl.x = v11;
    pptl.y = v14;
    if ( a7 )
      v15 = v11 - v10;
    else
      v15 = v10 + v11;
    if ( a7 )
    {
      v16 = a1 + v15 - v9;
      if ( v16 < 0 )
        v16 = v9 - v15 - a1;
      if ( v16 <= 2 )
        v15 = v9 - a1;
    }
    else
    {
      v17 = v15 - a1;
      if ( v15 - a1 < 0 )
        v17 = a1 - v15;
      if ( v17 <= 2 )
        v15 = a1;
    }
    v23 = v15;
    v24 = v14;
    if ( a7 )
      v18 = v9 - a1;
    else
      v18 = a1;
    v26 = a2;
    v25 = v18;
    v19 = CreatePolygonRgn(&pptl, 3, 1);
    v20 = v19;
    if ( v19 )
    {
      CombineRgn(x2a, x2a, v19, 2);
      DeleteObject(v20);
    }
  }
  return x2a;
}

//----- (6F7B29AF) --------------------------------------------------------
int __stdcall TTSetDelayTime(int a1, int a2, __int16 a3)
{
  int result; // eax@4

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = a1;
      *(_DWORD *)(a1 + 44) = a3;
    }
    else if ( a2 == 2 )
    {
      result = a1;
      *(_DWORD *)(a1 + 48) = a3;
    }
    else
    {
      result = a2 - 3;
      if ( a2 == 3 )
      {
        result = a1;
        *(_DWORD *)(a1 + 40) = a3;
      }
    }
  }
  else if ( a3 <= 0 )
  {
    result = a1;
    *(_DWORD *)(a1 + 40) = -1;
    *(_DWORD *)(a1 + 44) = -1;
    *(_DWORD *)(a1 + 48) = -1;
  }
  else
  {
    result = a3 / 5;
    *(_DWORD *)(a1 + 40) = a3;
    *(_DWORD *)(a1 + 48) = 10 * a3;
    *(_DWORD *)(a1 + 44) = result;
  }
  return result;
}

//----- (6F7B2A1A) --------------------------------------------------------
UINT __stdcall TTGetDelayTime(int a1, int a2)
{
  UINT result; // eax@5

  if ( !a2 )
  {
LABEL_10:
    result = *(_DWORD *)(a1 + 40);
    if ( (result & 0x80000000) != 0 )
      result = GetDoubleClickTime();
    return result;
  }
  if ( a2 == 1 )
  {
    result = *(_DWORD *)(a1 + 44);
    if ( (result & 0x80000000) != 0 )
      result = GetDoubleClickTime() / 5;
  }
  else
  {
    if ( a2 != 2 )
    {
      if ( a2 != 3 )
        return -1;
      goto LABEL_10;
    }
    result = *(_DWORD *)(a1 + 48);
    if ( (result & 0x80000000) != 0 )
      result = 10 * GetDoubleClickTime();
  }
  return result;
}

//----- (6F7B2A7C) --------------------------------------------------------
int __stdcall CopyToolInfoA(int a1, int a2, UINT CodePage)
{
  int v3; // eax@1
  const WCHAR *v4; // ecx@4
  CHAR *v5; // esi@6
  unsigned int v6; // ecx@9
  int result; // eax@11

  v3 = a1;
  if ( a1 && a2 )
  {
    if ( *(_DWORD *)a2 >= 0x28u )
    {
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
      v4 = *(const WCHAR **)(a1 + 36);
      if ( v4 != (const WCHAR *)-1 && (unsigned int)v4 & 0xFFFF0000 )
      {
        v5 = *(CHAR **)(a2 + 36);
        if ( v5 )
        {
          WideCharToMultiByte(CodePage, 0, v4, -1, v5, 80, 0, 0);
          v3 = a1;
        }
      }
      else
      {
        *(_DWORD *)(a2 + 36) = v4;
      }
    }
    v6 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 > 0x28u )
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(v3 + 40);
    result = v6 <= 0x2C;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B2B11) --------------------------------------------------------
int __stdcall ThunkToolInfoAtoW(int a1, int a2, int a3, UINT CodePage)
{
  int v4; // eax@5
  int v5; // eax@8
  int v6; // ebx@8
  WCHAR *v7; // eax@8

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  if ( *(_DWORD *)a1 > 0x28u )
  {
    *(_DWORD *)a2 = 44;
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 40);
  }
  else
  {
    *(_DWORD *)a2 = 40;
  }
  if ( a3 )
  {
    v4 = *(_DWORD *)(a1 + 36);
    if ( v4 == -1 )
    {
      *(_DWORD *)(a2 + 36) = -1;
    }
    else if ( v4 & 0xFFFF0000 )
    {
      v5 = lstrlenA(*(LPCSTR *)(a1 + 36));
      v6 = v5 + 1;
      v7 = (WCHAR *)LocalAlloc(0x40u, 2 * (v5 + 1));
      *(_DWORD *)(a2 + 36) = v7;
      if ( !v7 || !MultiByteToWideChar(CodePage, 0, *(LPCSTR *)(a1 + 36), -1, v7, v6) && GetLastError() )
        return 0;
      *(_DWORD *)(a2 + 4) |= 0x200u;
    }
    else
    {
      *(_DWORD *)(a2 + 36) = v4;
    }
  }
  return 1;
}

//----- (6F7B2BDC) --------------------------------------------------------
int __stdcall ThunkToolInfoWtoA(int a1, int a2, UINT CodePage)
{
  int v3; // eax@1
  const WCHAR *v4; // edx@1

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
  v3 = 1;
  *(_DWORD *)a2 = *(_DWORD *)a1 > 0x28u ? 44 : 40;
  v4 = *(const WCHAR **)(a1 + 36);
  if ( v4 == (const WCHAR *)-1 )
  {
    *(_DWORD *)(a2 + 36) = -1;
    return 1;
  }
  if ( (unsigned int)v4 & 0xFFFF0000 )
    v3 = WideCharToMultiByte(CodePage, 0, v4, -1, *(LPSTR *)(a2 + 36), 80, 0, 0);
  else
    *(_DWORD *)(a2 + 36) = v4;
  if ( v3 || !GetLastError() )
    return 1;
  return 0;
}

//----- (6F7B2C77) --------------------------------------------------------
int __stdcall ThunkToolTipTextAtoW(int a1, int a2, UINT CodePage)
{
  LPCSTR v3; // eax@3

  if ( a1 && a2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)a1;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a2 + 8) = -530;
    *(_DWORD *)(a2 + 176) = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a2 + 180) = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a2 + 184) = *(_DWORD *)(a1 + 104);
    v3 = *(LPCSTR *)(a1 + 12);
    if ( v3 == (LPCSTR)-1 )
    {
      *(_DWORD *)(a2 + 12) = -1;
      return 1;
    }
    if ( (unsigned int)v3 & 0xFFFF0000 )
    {
      *(_DWORD *)(a2 + 12) = a2 + 16;
      if ( MultiByteToWideChar(CodePage, 0, *(LPCSTR *)(a1 + 12), -1, (LPWSTR)(a2 + 16), 80) )
        return 1;
      v3 = ProduceWFromA(CodePage, *(LPCSTR *)(a1 + 12));
      *(_DWORD *)(a2 + 180) |= 0x200u;
    }
    *(_DWORD *)(a2 + 12) = v3;
    return 1;
  }
  return 0;
}

//----- (6F7B2D17) --------------------------------------------------------
int __stdcall ToolTipsMgrCreate(WPARAM wParam, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  HLOCAL v4; // eax@2

  v2 = (int)LocalAlloc(0x40u, 0xA4u);
  v3 = v2;
  if ( v2 )
  {
    CIInitialize(v2, wParam, a2);
    TTSetDelayTime(v3, 0, -1);
    *(_DWORD *)(v3 + 136) = -1;
    *(_DWORD *)(v3 + 68) = 16;
    *(_DWORD *)(v3 + 128) = g_clrInfoBk;
    *(_DWORD *)(v3 + 132) = g_clrInfoText;
    v4 = LocalAlloc(0x40u, 0xA0u);
    *(_DWORD *)(v3 + 88) = v4;
    if ( v4 )
    {
      *(_DWORD *)(v3 + 92) = 80;
    }
    else
    {
      LocalFree((HLOCAL)v3);
      v3 = 0;
    }
  }
  return v3;
}
// 6F7E693C: using guessed type int g_clrInfoBk;
// 6F7E6940: using guessed type int g_clrInfoText;

//----- (6F7B2D9C) --------------------------------------------------------
int __stdcall AddTool(int a1, void *Src)
{
  HLOCAL v3; // ecx@4
  int v4; // edx@6
  int v5; // eax@7
  int v6; // esi@9
  int v7; // eax@9
  HWND v8; // ebx@14
  LRESULT v9; // eax@17
  ULONG pulResult; // [sp+4h] [bp-4h]@1

  pulResult = 0;
  if ( *(_DWORD *)Src > 0x2Cu )
    return 0;
  if ( ULongAdd(*(_DWORD *)(a1 + 36), 1u, &pulResult) < 0 )
    return 0;
  v3 = CCLocalReAllocArray_TOOLINFO(*(HLOCAL *)(a1 + 52), pulResult);
  if ( !v3 )
    return 0;
  v4 = *(_DWORD *)(a1 + 52);
  if ( v4 )
  {
    v5 = *(_DWORD *)(a1 + 56);
    if ( v5 )
      *(_DWORD *)(a1 + 56) = (char *)v3 + 44 * ((v5 - v4) / 44);
  }
  v6 = (int)((char *)v3 + 44 * *(_DWORD *)(a1 + 36));
  v7 = *(_DWORD *)(a1 + 36) + 1;
  *(_DWORD *)(a1 + 52) = v3;
  *(_DWORD *)(a1 + 36) = v7;
  memmove((void *)v6, Src, *(_DWORD *)Src);
  *(_DWORD *)(v6 + 36) = 0;
  if ( GetWindowLongW(*((HWND *)Src + 2), -20) & 0x400000 && !(*(_DWORD *)(a1 + 24) & 0x400000) )
    *(_DWORD *)(v6 + 4) ^= 0x804u;
  TTSetTipText(v6, *((LPCWSTR *)Src + 9));
  if ( *(_BYTE *)(v6 + 4) & 0x10 )
    TTSubclassHwnd(v6, *(_DWORD *)a1);
  v8 = (HWND)*((_DWORD *)Src + 2);
  if ( v8 && IsWindow(v8) )
  {
    if ( *(_BYTE *)(v6 + 4) & 0x40 )
    {
LABEL_20:
      *(_DWORD *)(v6 + 4) |= 0x40u;
      return 1;
    }
    v9 = SendMessageW(*(HWND *)(v6 + 8), 0x55u, *(_DWORD *)a1, 3);
  }
  else
  {
    v9 = 2;
  }
  if ( v9 == 2 )
    goto LABEL_20;
  return 1;
}
// 6F7B2D9C: could not find valid save-restore pair for edi

//----- (6F7B2E9F) --------------------------------------------------------
int __stdcall GetToolText(int a1, int a2)
{
  int v3; // eax@3
  const WCHAR *v4; // eax@6
  int v5; // ecx@7
  int v6; // ST00_4@7
  HINSTANCE v7; // ecx@16
  HINSTANCE v8; // edi@25
  int v9; // edi@27
  HLOCAL v10; // eax@28
  wchar_t *v11; // eax@30
  WCHAR *v12; // ecx@38
  int v13; // ebx@43
  HLOCAL v14; // eax@44
  wchar_t *v15; // eax@46
  LPARAM lParam; // [sp+Ch] [bp-C0h]@7
  int v17; // [sp+10h] [bp-BCh]@7
  int v18; // [sp+14h] [bp-B8h]@7
  LPCWSTR lpString; // [sp+18h] [bp-B4h]@7
  __int16 v20; // [sp+1Ch] [bp-B0h]@7
  HINSTANCE hInstance; // [sp+BCh] [bp-10h]@7
  unsigned int v22; // [sp+C0h] [bp-Ch]@7
  int v23; // [sp+C4h] [bp-8h]@7

  if ( !a2 )
    return 0;
  v3 = *(_DWORD *)(a1 + 88);
  if ( v3 )
  {
    *(_WORD *)v3 = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 88) = LocalAlloc(0x40u, 0xA0u);
    *(_DWORD *)(a1 + 92) = 80;
  }
  v4 = *(const WCHAR **)(a2 + 36);
  if ( v4 == (const WCHAR *)-1 )
  {
    v17 = *(_DWORD *)(a2 + 12);
    v5 = *(_DWORD *)(a2 + 40);
    lParam = *(_DWORD *)a1;
    v20 = 0;
    lpString = (LPCWSTR)&v20;
    v22 = *(_DWORD *)(a2 + 4);
    v6 = *(_DWORD *)(a2 + 8);
    v18 = -530;
    v23 = v5;
    hInstance = 0;
    SendNotifyEx(v6, HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, (v22 >> 6) & 1);
    v4 = lpString;
    if ( (__int16 *)lpString == &v20 && !v20 && *(_BYTE *)(a2 + 4) & 0x40 && *(_DWORD *)(a1 + 28) < 5 )
    {
      if ( SendMessageW(*(HWND *)(a2 + 8), 0x3Du, 0, -12) == 65548 )
        SendNotifyEx(*(_DWORD *)(a2 + 8), HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, 0);
      v4 = lpString;
    }
    if ( v22 & 0x8000 )
    {
      if ( (unsigned int)v4 & 0xFFFF0000 )
      {
        if ( v4 != (const WCHAR *)-1 )
        {
          TTSetTipText(a2, v4);
          v4 = lpString;
        }
      }
      else
      {
        v7 = hInstance;
        *(_DWORD *)(a2 + 36) = v4;
        *(_DWORD *)(a2 + 32) = v7;
      }
    }
    if ( !v4 || v4 == (const WCHAR *)-1 )
      return 0;
    if ( v22 & 4 )
      *(_DWORD *)(a2 + 4) |= 4u;
    else
      *(_DWORD *)(a2 + 4) &= 0xFFFFFFFB;
    if ( (unsigned int)v4 & 0xFFFF0000 )
    {
      if ( *v4 )
      {
        v9 = lstrlenW(v4) + 1;
        if ( *(_DWORD *)(a1 + 92) < (unsigned int)v9 )
        {
          v10 = LocalReAlloc(*(HLOCAL *)(a1 + 88), 2 * v9, 2u);
          if ( v10 )
          {
            *(_DWORD *)(a1 + 88) = v10;
            *(_DWORD *)(a1 + 92) = v9;
          }
        }
        v11 = *(wchar_t **)(a1 + 88);
        if ( v11 )
          StringCchCopyW(v11, *(_DWORD *)(a1 + 92), lpString);
        if ( (__int16 *)lpString != &v20 )
        {
          if ( v22 & 0x200 )
            LocalFree((HLOCAL)lpString);
        }
        goto LABEL_48;
      }
      return 0;
    }
    v8 = hInstance;
    lpString = (LPCWSTR)&v20;
  }
  else
  {
    if ( !v4 )
      return *(_DWORD *)(a1 + 88);
    if ( (unsigned int)v4 & 0xFFFF0000 )
    {
      if ( !v4 || !*v4 )
        return *(_DWORD *)(a1 + 88);
      v13 = lstrlenW(*(LPCWSTR *)(a2 + 36)) + 1;
      if ( *(_DWORD *)(a1 + 92) < (unsigned int)v13 )
      {
        v14 = LocalReAlloc(*(HLOCAL *)(a1 + 88), 2 * v13, 2u);
        if ( v14 )
        {
          *(_DWORD *)(a1 + 88) = v14;
          *(_DWORD *)(a1 + 92) = v13;
        }
      }
      v15 = *(wchar_t **)(a1 + 88);
      if ( !v15 )
        return *(_DWORD *)(a1 + 88);
      StringCchCopyW(v15, *(_DWORD *)(a1 + 92), *(STRSAFE_LPCWSTR *)(a2 + 36));
      goto LABEL_48;
    }
    v8 = *(HINSTANCE *)(a2 + 32);
  }
  v12 = *(WCHAR **)(a1 + 88);
  if ( v12 )
  {
    if ( LoadStringW(v8, (UINT)v4, v12, *(_DWORD *)(a1 + 92)) )
    {
LABEL_48:
      StripAccels(a1);
      return *(_DWORD *)(a1 + 88);
    }
    return 0;
  }
  return *(_DWORD *)(a1 + 88);
}

//----- (6F7B310C) --------------------------------------------------------
int __stdcall GetCurToolText(int a1)
{
  int result; // eax@1

  result = 0;
  if ( *(_DWORD *)(a1 + 56) )
    result = GetToolText(a1, *(_DWORD *)(a1 + 56));
  if ( !*(_DWORD *)(a1 + 56) )
    result = 0;
  return result;
}

//----- (6F7B3137) --------------------------------------------------------
int __stdcall GetToolAtPoint(int a1, int a2, POINT pt, int a4, int a5)
{
  int v5; // eax@2
  int v7; // eax@8
  unsigned int v8; // ecx@9
  int v9; // esi@9
  int v10; // [sp+8h] [bp-4h]@1

  v10 = 0;
  if ( *(_BYTE *)(a1 + 68) & 0x40 )
  {
    v5 = *(_DWORD *)(a1 + 56);
    if ( v5 )
    {
      if ( *(_DWORD *)(v5 + 4) & 0x400 && *(_DWORD *)(v5 + 8) == a2 && a4 == *(_DWORD *)(v5 + 16)
        || PointInTool(v5, a2, pt) )
        return *(_DWORD *)(a1 + 56);
    }
  }
  v7 = *(_DWORD *)(a1 + 36);
  if ( !v7 )
    return v10;
  v8 = *(_DWORD *)(a1 + 52);
  v9 = 44 * v7 + v8 - 44;
  if ( v9 < v8 )
    return v10;
  while ( 1 )
  {
    if ( (!(*(_DWORD *)(v9 + 4) & 0x400) || *(_DWORD *)(v9 + 8) != a2 || a4 != *(_DWORD *)(v9 + 16))
      && !PointInTool(v9, a2, pt) )
      goto LABEL_18;
    if ( !a5 || GetToolText(a1, v9) )
      return v9;
    if ( *(_BYTE *)(a1 + 68) & 0xC0 )
      v10 = v9;
LABEL_18:
    v9 -= 44;
    if ( (unsigned int)v9 < *(_DWORD *)(a1 + 52) )
      return v10;
  }
}

//----- (6F7B31F4) --------------------------------------------------------
int __stdcall DoShowBubble(UINT uFlags)
{
  UINT v1; // esi@1
  int v2; // eax@1
  bool v3; // zf@1
  int v4; // edi@1
  int result; // eax@4
  POINT v6; // ST08_8@8
  UINT v7; // eax@8
  int v8; // eax@10
  int v9; // eax@16
  int v10; // ecx@20
  int v11; // edx@20
  int v12; // eax@20
  int v13; // ebx@21
  int v14; // ST10_4@23
  HRGN v15; // eax@23
  void *v16; // edi@23
  int v17; // edi@27
  DWORD v18; // eax@28
  DWORD v19; // eax@32
  bool v20; // sf@32
  unsigned __int8 v21; // of@32
  LPARAM lParam; // [sp+8h] [bp-38h]@10
  int v23; // [sp+Ch] [bp-34h]@10
  int v24; // [sp+10h] [bp-30h]@10
  unsigned int v25; // [sp+14h] [bp-2Ch]@10
  int X; // [sp+18h] [bp-28h]@8
  int Y; // [sp+1Ch] [bp-24h]@10
  int v28; // [sp+20h] [bp-20h]@10
  int v29; // [sp+24h] [bp-1Ch]@10
  int v30; // [sp+28h] [bp-18h]@8
  int v31; // [sp+2Ch] [bp-14h]@10
  int v32; // [sp+30h] [bp-10h]@8
  int v33; // [sp+34h] [bp-Ch]@8
  LPCWSTR lpString; // [sp+38h] [bp-8h]@1
  int v35; // [sp+3Ch] [bp-4h]@8
  signed int uFlagsa; // [sp+48h] [bp+8h]@11
  int uFlagsb; // [sp+48h] [bp+8h]@16
  UINT uFlagsc; // [sp+48h] [bp+8h]@27

  v1 = uFlags;
  v2 = GetCurToolText(uFlags);
  v3 = (*(_BYTE *)(uFlags + 68) & 1) == 0;
  v4 = v2;
  lpString = (LPCWSTR)v2;
  if ( v3 )
  {
    TTSetTimer(uFlags, 3u);
    if ( !v4 || !*(_WORD *)v4 )
      return ShowVirtualBubble(uFlags);
    TTSetTimer(uFlags, 4u);
  }
  else if ( !v2 || !*(_WORD *)v2 )
  {
    result = PopBubble(uFlags);
    *(_DWORD *)(uFlags + 68) &= 0xFFFFFFFE;
    return result;
  }
  do
  {
    TTGetTipSize(v1, *(_DWORD *)(v1 + 56), lpString, (int)&v32, (int)&v33);
    v6.y = v32;
    v6.x = (LONG)&X;
    TTGetTipPosition(v1, v6, v33, (int)&v35, (int)&v30);
    v7 = 20;
    if ( *(_BYTE *)(v1 + 8) & 0x40 )
      v7 = 148;
    SetWindowPos(*(HWND *)v1, 0, X, Y, v28 - X, v29 - Y, v7);
    lParam = *(_DWORD *)v1;
    v8 = *(_DWORD *)(v1 + 56);
    v23 = *(_DWORD *)(v8 + 12);
    v25 = *(_DWORD *)(v1 + 8);
    v31 = *(_DWORD *)(v1 + 64);
    v24 = -521;
    if ( !SendNotifyEx(*(_DWORD *)(v8 + 8), HWND_MESSAGE|0x2, -521, (LPARAM)&lParam, (*(_DWORD *)(v8 + 4) >> 6) & 1) )
    {
      uFlagsa = 17;
      if ( GetWindow(*(HWND *)v1, 4u) )
        uFlagsa = 21;
      SetWindowPos(*(HWND *)v1, 0, X, Y, 0, 0, uFlagsa);
    }
  }
  while ( v31 != *(_DWORD *)(v1 + 64) );
  if ( *(_BYTE *)(v1 + 8) & 0x40 )
  {
    v9 = *(_DWORD *)(v1 + 56);
    uFlagsb = 0;
    if ( v9 )
    {
      if ( !(GetWindowLongW(*(HWND *)(v9 + 8), -20) & 0x400000) || (uFlagsb = 1, *(_DWORD *)(v1 + 24) & 0x400000) )
        uFlagsb = 0;
    }
    v10 = v29;
    v11 = v30;
    *(_DWORD *)(v1 + 124) ^= (*(_DWORD *)(v1 + 124) ^ 4 * (v30 >= v29 - 1)) & 4;
    v12 = *(_DWORD *)(v1 + 124);
    if ( uFlagsb )
      v13 = v28 - v35;
    else
      v13 = v35 - X;
    v14 = *(_DWORD *)(v1 + 156);
    v35 = v13;
    v15 = CreateBalloonRgn(v13, v11 - Y, v28 - X, v10 - Y, v14, v12 << 29 >> 31, uFlagsb);
    v16 = v15;
    if ( v15 )
    {
      if ( !SetWindowRgn(*(HWND *)v1, v15, 0) )
        DeleteObject(v16);
    }
    SetWindowPos(*(HWND *)v1, 0, 0, 0, 0, 0, 0x53u);
  }
  else
  {
    v17 = ~(unsigned __int8)(v25 >> 5) & 1;
    uFlagsc = ~(unsigned __int8)(v25 >> 4) & 1;
    if ( *(_DWORD *)(v1 + 160) )
      v18 = GetTickCount();
    else
      v18 = 2000;
    if ( v18 - *(_DWORD *)(v1 + 160) < 0x7D0 )
    {
      v17 = 0;
      uFlagsc = 0;
    }
    CoolTooltipBubble(*(HWND *)v1, (int)&X, v17, uFlagsc);
    v19 = GetTickCount();
    v21 = __OFSUB__(*(_DWORD *)(v1 + 28), 4);
    v20 = *(_DWORD *)(v1 + 28) - 4 < 0;
    *(_DWORD *)(v1 + 160) = v19;
    if ( v20 ^ v21 )
    {
      if ( !(*(_BYTE *)(v1 + 124) & 0x10) && !(v25 & 0x30) )
      {
        InvalidateRect(*(HWND *)v1, 0, 1);
        UpdateWindow(*(HWND *)v1);
        if ( !(*(_BYTE *)(v1 + 124) & 0x10) )
        {
          SetWindowBits(*(HWND *)v1, -16, 48, 48);
          *(_DWORD *)(v1 + 124) |= 0x10u;
        }
      }
    }
  }
  *(_DWORD *)(v1 + 68) |= 0x40u;
  return RedrawWindow(*(HWND *)v1, 0, 0, 0x105u);
}

//----- (6F7B34A4) --------------------------------------------------------
int __stdcall ShowBubbleForTool(UINT uFlags, int a2)
{
  int result; // eax@3

  if ( a2 != *(_DWORD *)(uFlags + 56) )
  {
    if ( *(_BYTE *)(uFlags + 68) & 0x40 )
      result = PopBubble(uFlags);
    if ( a2 != *(_DWORD *)(uFlags + 56) )
      goto LABEL_9;
  }
  if ( !(*(_BYTE *)(uFlags + 68) & 0xC0) )
  {
LABEL_9:
    *(_DWORD *)(uFlags + 56) = a2;
    result = DoShowBubble(uFlags);
  }
  return result;
}

//----- (6F7B34E1) --------------------------------------------------------
int __stdcall HandleRelayedMessage(int a1, HWND hWnd, int a3, int a4, int a5)
{
  int result; // eax@1
  signed int v6; // ebx@1
  bool v7; // zf@10
  int v8; // eax@10
  int v9; // edi@11
  POINT v10; // ST08_8@17
  int v11; // edi@17
  UINT_PTR v12; // edi@20
  int v13; // eax@31
  int v14; // eax@33
  struct tagPOINT Point; // [sp+8h] [bp-8h]@11

  result = *(_DWORD *)(a1 + 68);
  v6 = -2;
  if ( !(result & 1) )
  {
    if ( result & 0x20 && GetKeyState(1) >= 0 && GetKeyState(2) >= 0 && GetKeyState(4) >= 0 )
      *(_DWORD *)(a1 + 68) &= 0xFFFFFFDF;
    if ( (unsigned int)a3 > 0x200 )
    {
      v8 = a3 - 513;
      v7 = a3 == 513;
LABEL_29:
      if ( !v7 )
      {
        result = v8 - 1;
        if ( !result )
          goto LABEL_35;
        v13 = result - 2;
        if ( v13 )
        {
          result = v13 - 1;
          if ( result )
          {
            v14 = result - 2;
            if ( v14 )
            {
              result = v14 - 1;
              if ( result )
                return result;
              goto LABEL_35;
            }
            goto LABEL_36;
          }
LABEL_35:
          *(_DWORD *)(a1 + 68) &= 0xFFFFFFDF;
          return result;
        }
      }
LABEL_36:
      *(_DWORD *)(a1 + 68) |= 0x20u;
      return ShowVirtualBubble(a1);
    }
    if ( a3 == 512 )
    {
      v9 = a5;
    }
    else
    {
      if ( a3 != 160 )
      {
        v8 = a3 - 161;
        v7 = a3 == 161;
        goto LABEL_29;
      }
      Point.y = SHIWORD(a5);
      Point.x = (signed __int16)a5;
      ScreenToClient(hWnd, &Point);
      v6 = a4;
      v9 = (unsigned __int16)Point.x | (LOWORD(Point.y) << 16);
    }
    if ( *(_BYTE *)(a1 + 8) & 1 || (result = ChildOfActiveWindow(hWnd)) != 0 )
    {
      result = *(_DWORD *)(a1 + 68);
      if ( result & 0x10 )
      {
        if ( !(result & 0x20) )
        {
          v10.y = SHIWORD(v9);
          v10.x = (signed __int16)v9;
          result = GetToolAtPoint(a1, (int)hWnd, v10, v6, 0);
          v11 = result;
          if ( result )
          {
            if ( *(_BYTE *)(a1 + 68) & 0xC0 )
            {
              if ( result == *(_DWORD *)(a1 + 56) )
              {
                v12 = *(_DWORD *)(a1 + 72) != 2 ? 3 : 0;
              }
              else
              {
                PopBubble(a1);
                *(_DWORD *)(a1 + 56) = v11;
                result = ShowVirtualBubble(a1);
                v12 = 2;
              }
              if ( *(_DWORD *)(a1 + 84) )
                result = TTSetTimer(a1, 4u);
            }
            else
            {
              *(_DWORD *)(a1 + 56) = result;
              v12 = 1;
            }
            if ( v12 )
              result = TTSetTimer(a1, v12);
          }
          else
          {
            result = PopBubble(a1);
          }
        }
      }
    }
  }
  return result;
}

//----- (6F7B364A) --------------------------------------------------------
int __stdcall TTUpdateTipText(UINT uFlags, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  bool v4; // zf@3

  result = FindTool(uFlags, a2);
  v3 = result;
  if ( result )
  {
    *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
    result = (int)TTSetTipText(result, *(LPCWSTR *)(a2 + 36));
    if ( *(_BYTE *)(uFlags + 68) & 1 )
    {
      v4 = *(_DWORD *)(uFlags + 56) == 0;
    }
    else
    {
      if ( v3 != *(_DWORD *)(uFlags + 56) )
        return result;
      GetCursorPos((LPPOINT)(uFlags + 76));
      result = ToolHasMoved(uFlags);
      if ( result )
        return PopBubble(uFlags);
      v4 = (*(_BYTE *)(uFlags + 68) & 0xC0) == 0;
    }
    if ( !v4 )
      result = DoShowBubble(uFlags);
  }
  return result;
}

//----- (6F7B36B9) --------------------------------------------------------
int __stdcall TTSetFont(UINT uFlags, HANDLE h, int a3)
{
  int result; // eax@1
  int v4; // edi@3

  ToolTips_NewFont(uFlags, h);
  result = 0;
  if ( a3 )
  {
    if ( *(_BYTE *)(uFlags + 68) & 0x10 && (v4 = *(_DWORD *)(uFlags + 56)) != 0 && *(_BYTE *)(v4 + 4) & 0x20 )
    {
      PopBubble(uFlags);
      result = ShowBubbleForTool(uFlags, v4);
    }
    else
    {
      result = InvalidateRect(*(HWND *)uFlags, 0, 0);
    }
  }
  return result;
}

//----- (6F7B370A) --------------------------------------------------------
int __stdcall CopyToolInfo(int a1, int a2)
{
  int v2; // eax@1
  const WCHAR *v3; // ecx@5
  const wchar_t *v4; // ST08_4@8
  int v5; // eax@8
  unsigned int v6; // ecx@10
  int result; // eax@12

  v2 = a1;
  if ( a1 && a2 && *(_DWORD *)a2 <= 0x2Cu )
  {
    if ( *(_DWORD *)a2 >= 0x28u )
    {
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 32);
      v3 = *(const WCHAR **)(a1 + 36);
      if ( v3 != (const WCHAR *)-1 && (unsigned int)v3 & 0xFFFF0000 )
      {
        if ( *(_DWORD *)(a2 + 36) )
        {
          v4 = *(const wchar_t **)(a1 + 36);
          v5 = lstrlenW(v3);
          StringCchCopyW(*(STRSAFE_LPWSTR *)(a2 + 36), v5 + 1, v4);
          v2 = a1;
        }
      }
      else
      {
        *(_DWORD *)(a2 + 36) = v3;
      }
    }
    v6 = *(_DWORD *)a2;
    if ( *(_DWORD *)a2 > 0x28u )
      *(_DWORD *)(a2 + 40) = *(_DWORD *)(v2 + 40);
    result = v6 <= 0x2C;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B37A9) --------------------------------------------------------
int __stdcall TTToolAtMessagePos(int a1)
{
  DWORD v1; // eax@1
  int v2; // esi@1
  struct tagPOINT Point; // [sp+4h] [bp-8h]@1

  v1 = GetMessagePos();
  Point.y = SHIWORD(v1);
  Point.x = (signed __int16)v1;
  v2 = TTWindowFromPoint(a1, (LPARAM)&Point);
  ScreenToClient((HWND)v2, &Point);
  return GetToolAtPoint(a1, v2, Point, -2, 1);
}

//----- (6F7B37FA) --------------------------------------------------------
int __stdcall TTCheckCursorPos(int a1)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 56) != TTToolAtMessagePos(a1) || (result = ToolHasMoved(a1)) != 0 )
    result = PopBubble(a1);
  return result;
}

//----- (6F7B3828) --------------------------------------------------------
void __stdcall TTHandleTimer(UINT uFlags, int a2)
{
  int v2; // ecx@1
  int v3; // eax@12
  int v4; // ecx@15

  v2 = *(_DWORD *)(uFlags + 68);
  if ( v2 & 1 )
    return;
  if ( a2 == 1 )
  {
    if ( ToolHasMoved(uFlags) )
    {
LABEL_14:
      PopBubble(uFlags);
      return;
    }
  }
  else if ( a2 != 2 )
  {
    if ( a2 == 3 )
    {
      if ( (char)v2 < 0 )
        KillTimer(*(HWND *)uFlags, 3u);
      TTCheckCursorPos(uFlags);
    }
    else if ( a2 == 4 )
    {
      TTCheckCursorPos(uFlags);
      if ( *(_DWORD *)(uFlags + 56) )
        ShowVirtualBubble(uFlags);
    }
    return;
  }
  v3 = TTToolAtMessagePos(uFlags);
  if ( !v3 )
  {
    if ( !*(_DWORD *)(uFlags + 56) )
      return;
    goto LABEL_14;
  }
  v4 = *(_DWORD *)(uFlags + 68);
  if ( v4 & 0x10 )
  {
    if ( a2 == 2 )
      *(_DWORD *)(uFlags + 68) = v4 & 0xFFFFFF3F;
    ShowBubbleForTool(uFlags, v3);
  }
}

//----- (6F7B38BB) --------------------------------------------------------
int __stdcall TTRender(UINT options, HDC hdc)
{
  int v2; // esi@1
  signed int v3; // edi@1
  int v4; // eax@2
  int v5; // ecx@7
  int v6; // eax@7
  int v7; // ecx@7
  LONG v8; // ecx@7
  bool v9; // zf@7
  signed int v10; // ebx@10
  int v11; // eax@12
  int v12; // ecx@12
  HWND v13; // eax@17
  bool v14; // sf@17
  unsigned __int8 v15; // of@17
  COLORREF v16; // edi@25
  int v17; // edi@28
  int v18; // ST1C_4@30
  HRGN v19; // eax@31
  HBRUSH v20; // edi@35
  UINT v21; // ST1C_4@40
  int v22; // eax@40
  int v23; // eax@44
  HRGN v24; // eax@46
  HRGN v25; // edi@46
  int v26; // esi@52
  LPARAM lParam; // [sp+Ch] [bp-5Ch]@7
  int v29; // [sp+10h] [bp-58h]@7
  int v30; // [sp+14h] [bp-54h]@7
  int v31; // [sp+18h] [bp-50h]@7
  HDC v32; // [sp+1Ch] [bp-4Ch]@7
  struct tagRECT rc; // [sp+20h] [bp-48h]@7
  UINT format; // [sp+3Ch] [bp-2Ch]@17
  struct tagRECT Rect; // [sp+40h] [bp-28h]@7
  HGDIOBJ ho; // [sp+50h] [bp-18h]@33
  HWND v37; // [sp+54h] [bp-14h]@17
  HRGN hrgn; // [sp+58h] [bp-10h]@31
  int x; // [sp+5Ch] [bp-Ch]@23
  LPCWSTR lpString; // [sp+60h] [bp-8h]@2
  int v41; // [sp+64h] [bp-4h]@10
  UINT optionsa; // [sp+70h] [bp+8h]@4
  int optionsb; // [sp+70h] [bp+8h]@27
  HBRUSH optionsc; // [sp+70h] [bp+8h]@48

  v2 = options;
  v3 = 0;
  if ( *(_DWORD *)(options + 56) )
  {
    v4 = GetCurToolText(options);
    lpString = (LPCWSTR)v4;
    if ( v4 )
    {
      if ( *(_WORD *)v4 )
      {
        optionsa = 0;
        if ( *(_BYTE *)(*(_DWORD *)(v2 + 56) + 4) & 4 || *(_DWORD *)(v2 + 24) & 0x2000 )
          optionsa = 128;
        SelectObject(hdc, *(HGDIOBJ *)(v2 + 64));
        GetClientRect(*(HWND *)v2, &Rect);
        SetTextColor(hdc, *(_DWORD *)(v2 + 132));
        v5 = *(_DWORD *)(v2 + 140);
        lParam = *(_DWORD *)v2;
        v29 = *(_DWORD *)(*(_DWORD *)(v2 + 56) + 12);
        v6 = -2 * g_cxBorder - *(_DWORD *)(v2 + 148);
        rc.left = Rect.left + v5 + 2 * g_cxBorder;
        v7 = *(_DWORD *)(v2 + 144);
        rc.right = Rect.right + v6;
        rc.top = Rect.top + g_cyBorder + v7;
        v3 = 1;
        v8 = Rect.bottom - *(_DWORD *)(v2 + 152) - g_cyBorder;
        v9 = (*(_BYTE *)(v2 + 8) & 0x40) == 0;
        v30 = -12;
        v32 = hdc;
        v31 = 1;
        rc.bottom = v8;
        if ( !v9 )
        {
          InflateRect(&rc, -10, -8);
          if ( !(*(_BYTE *)(v2 + 124) & 4) )
            OffsetRect(&rc, 0, *(_DWORD *)(v2 + 156));
        }
        v10 = *(_DWORD *)(v2 + 136) != -1 ? 592 : 32;
        v9 = (*(_BYTE *)(v2 + 8) & 2) == 0;
        v41 = *(_DWORD *)(v2 + 136) != -1 ? 592 : 32;
        if ( !v9 )
        {
          v10 |= 0x800u;
          v41 = v10;
        }
        v11 = *(_DWORD *)(v2 + 56);
        v12 = *(_DWORD *)(v11 + 4);
        if ( v12 & 4 || *(_DWORD *)(v2 + 24) & 0x2000 )
        {
          v10 |= 0x20000u;
          v41 = v10;
        }
        if ( v12 & 0x800 )
        {
          v10 |= 2u;
          v41 = v10;
        }
        format = v10;
        v13 = SendNotifyEx(*(_DWORD *)(v11 + 8), HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, (*(_DWORD *)(v11 + 4) >> 6) & 1);
        v15 = __OFSUB__(*(_DWORD *)(v2 + 28), 5);
        v14 = *(_DWORD *)(v2 + 28) - 5 < 0;
        v37 = v13;
        if ( v14 ^ v15 || v13 != (HWND)4 )
        {
          x = format != v10 || !(v10 & 0x20) || v10 & 0x20002 || *(_DWORD *)(v2 + 100);
          v16 = *(_DWORD *)(v2 + 128);
          if ( v16 != GetNearestColor(hdc, *(_DWORD *)(v2 + 128)) || x )
          {
            v20 = CreateSolidBrush(v16);
            FillRect(hdc, &Rect, v20);
            DeleteObject(v20);
            SetBkMode(hdc, 1);
            optionsb = optionsa | 4;
            if ( x )
            {
              ++rc.bottom;
              ++rc.right;
              if ( *(_DWORD *)(v2 + 100) && !(*(_BYTE *)(v2 + 8) & 0x40) )
                InflateRect(&rc, -10, -8);
              if ( !TTRenderTitledTip(v2, hdc, 0, &rc, v41) )
              {
                v21 = format;
                v22 = lstrlenW(lpString);
                DrawTextW(hdc, lpString, v22, &rc, v21);
              }
              goto LABEL_45;
            }
          }
          else
          {
            optionsb = optionsa | 2;
            SetBkColor(hdc, v16);
          }
          v17 = g_cyBorder + *(_DWORD *)(v2 + 144);
          v9 = (*(_BYTE *)(v2 + 8) & 0x40) == 0;
          x = *(_DWORD *)(v2 + 140) + 2 * g_cxBorder;
          if ( v9 )
          {
            if ( *(_DWORD *)(v2 + 100) )
              InflateRect(&Rect, -10, -8);
          }
          else
          {
            x += 10;
            v17 += 8;
            InflateRect(&Rect, -10, -8);
            if ( !(*(_BYTE *)(v2 + 124) & 4) )
            {
              v18 = *(_DWORD *)(v2 + 156);
              v17 += v18;
              OffsetRect(&Rect, 0, v18);
            }
            v19 = CreateRectRgn(1, 1, 2, 2);
            hrgn = v19;
            if ( v19 )
            {
              if ( GetWindowRgn(*(HWND *)v2, v19) )
              {
                ho = CreateSolidBrush(*(_DWORD *)(v2 + 128));
                FillRgn(hdc, hrgn, (HBRUSH)ho);
                DeleteObject(ho);
              }
              DeleteObject(hrgn);
            }
          }
          if ( !TTRenderTitledTip(v2, hdc, 0, &Rect, v41) )
          {
            v23 = lstrlenW(lpString);
            ExtTextOutW(hdc, x, v17, optionsb, &Rect, lpString, v23, 0);
          }
LABEL_45:
          if ( *(_BYTE *)(v2 + 8) & 0x40 )
          {
            v24 = CreateRectRgn(1, 1, 2, 2);
            v25 = v24;
            if ( v24 )
            {
              if ( GetWindowRgn(*(HWND *)v2, v24) )
              {
                optionsc = CreateSolidBrush(*(_DWORD *)(v2 + 132));
                FrameRgn(hdc, v25, optionsc, 1, 1);
                DeleteObject(optionsc);
              }
              DeleteObject(v25);
            }
          }
          if ( !((unsigned __int8)v37 & 4) && (unsigned __int8)v37 & 0x10 )
          {
            v26 = *(_DWORD *)(v2 + 56);
            ++v31;
            SendNotifyEx(*(_DWORD *)(v26 + 8), HWND_MESSAGE|0x2, 0, (LPARAM)&lParam, (*(_DWORD *)(v26 + 4) >> 6) & 1);
          }
          return 1;
        }
      }
    }
  }
  return v3;
}

//----- (6F7B3C9E) --------------------------------------------------------
int __stdcall TTOnPaint(UINT options)
{
  HDC v1; // eax@1
  int result; // eax@3
  struct tagPAINTSTRUCT Paint; // [sp+4h] [bp-44h]@1

  v1 = BeginPaint(*(HWND *)options, &Paint);
  if ( !TTRender(options, v1) )
    PopBubble(options);
  result = EndPaint(*(HWND *)options, &Paint);
  *(_DWORD *)(options + 124) |= 0x10u;
  return result;
}

//----- (6F7B3CF5) --------------------------------------------------------
int __stdcall ToolTipsWndProc(HWND hWnd, UINT Msg, size_t cchDest, LPARAM lParam)
{
  LONG v4; // esi@1
  wchar_t *v5; // ebx@15
  int v6; // eax@19
  int result; // eax@22
  int v8; // edi@26
  LONG v9; // eax@33
  int v10; // eax@35
  int v11; // eax@46
  int v12; // eax@59
  int v13; // eax@62
  int v14; // esi@69
  int v15; // ebx@82
  bool v16; // sf@82
  int v17; // edi@83
  int v18; // esi@108
  int v19; // eax@119
  LPARAM v20; // esi@121
  LPARAM v21; // edi@121
  int v22; // edi@122
  int v23; // esi@122
  int v24; // eax@135
  int v25; // eax@135
  int v26; // eax@138
  int v27; // eax@143
  int v28; // edi@143
  int v29; // eax@151
  int v30; // eax@170
  int v31; // eax@177
  int v32; // edi@177
  bool v33; // zf@178
  const void *v34; // eax@182
  int v35; // eax@189
  int v36; // eax@190
  int v37; // eax@190
  const wchar_t *v38; // ST1C_4@191
  int v39; // eax@191
  int v40; // eax@205
  signed int v41; // edi@208
  int v42; // eax@212
  HWND v43; // ST14_4@215
  int v44; // eax@229
  int v45; // edi@229
  int v46; // eax@230
  LONG v47; // ecx@230
  char *v48; // eax@230
  int v49; // eax@235
  int v50; // eax@240
  signed int v51; // [sp-4h] [bp-114h]@184
  size_t Src; // [sp+Ch] [bp-104h]@102
  int v53; // [sp+10h] [bp-100h]@108
  HLOCAL hMem; // [sp+30h] [bp-E0h]@109
  HWND v55; // [sp+38h] [bp-D8h]@1
  struct tagPOINT Points; // [sp+3Ch] [bp-D4h]@27
  WCHAR WideCharStr; // [sp+44h] [bp-CCh]@234
  char Dst; // [sp+46h] [bp-CAh]@234

  v55 = hWnd;
  v4 = GetWindowLongW(hWnd, 0);
  if ( !v4 && Msg != 1 )
    return DefWindowProcW(v55, Msg, cchDest, lParam);
  if ( Msg > 0x40D )
  {
    switch ( Msg )
    {
      case 0x415u:
        return TTGetDelayTime(v4, cchDest);
      case 0x432u:
        if ( !lParam )
          return 0;
        return AddTool(v4, (void *)lParam);
      case 0x433u:
        if ( lParam )
          DeleteTool(v4, lParam);
        return 0;
      case 0x434u:
        if ( !lParam )
          return 0;
        v19 = FindTool(v4, lParam);
        goto LABEL_120;
      case 0x40Fu:
        if ( !lParam )
          goto LABEL_166;
        return CopyToolInfoA(*(_DWORD *)(v4 + 56), lParam, *(_DWORD *)(v4 + 20));
      case 0x40Eu:
        if ( cchDest >= *(_DWORD *)(v4 + 36) )
          return 0;
        return CopyToolInfoA(*(_DWORD *)(v4 + 52) + 44 * cchDest, lParam, *(_DWORD *)(v4 + 20));
      case 0x435u:
        if ( !lParam )
          return 0;
        v30 = FindTool(v4, lParam);
        return CopyToolInfo(v30, lParam);
      case 0x43Bu:
        if ( lParam )
          result = CopyToolInfo(*(_DWORD *)(v4 + 56), lParam);
        else
LABEL_166:
          result = *(_DWORD *)(v4 + 56);
        return result;
      case 0x43Au:
        if ( cchDest >= *(_DWORD *)(v4 + 36) )
          return 0;
        return CopyToolInfo(*(_DWORD *)(v4 + 52) + 44 * cchDest, lParam);
      case 0x436u:
        if ( !lParam )
          return 0;
        v31 = FindTool(v4, lParam);
        v32 = v31;
        if ( !v31 )
          return 0;
        TTSetTipText(v31, 0);
        memmove((void *)v32, (const void *)lParam, *(_DWORD *)lParam);
        *(_DWORD *)(v32 + 36) = 0;
        TTSetTipText(v32, *(LPCWSTR *)(lParam + 36));
        v33 = v32 == *(_DWORD *)(v4 + 56);
        goto LABEL_179;
      case 0x437u:
        if ( !lParam )
          return 0;
        v34 = (const void *)GetToolAtPoint(v4, *(_DWORD *)lParam, *(POINT *)(lParam + 4), -2, 1);
        if ( !v34 )
          return 0;
        if ( *(_DWORD *)(lParam + 12) == 44 )
          v51 = 11;
        else
          v51 = 10;
        qmemcpy((void *)(lParam + 12), v34, 4 * v51);
        return 1;
      case 0x438u:
        if ( lParam )
        {
          if ( v4 )
          {
            v35 = *(_DWORD *)(lParam + 36);
            if ( v35 )
            {
              *(_WORD *)v35 = 0;
              v36 = FindTool(v4, lParam);
              v37 = GetToolText(v4, v36);
              if ( v37 )
              {
                v38 = (const wchar_t *)v37;
                v39 = lstrlenW((LPCWSTR)v37);
                StringCchCopyW(*(STRSAFE_LPWSTR *)(lParam + 36), v39 + 1, v38);
              }
            }
          }
        }
        return 0;
      case 0x410u:
        return (int)WindowFromPoint(*(POINT *)lParam);
      case 0x439u:
        if ( lParam )
          TTUpdateTipText(v4, lParam);
        return 0;
      case 0x41Cu:
        if ( *(_BYTE *)(v4 + 68) & 0x40 )
          PopBubble(v4);
        *(_DWORD *)(v4 + 68) &= 0xFFFFFF7F;
        return 0;
      case 0x412u:
        if ( (signed __int16)lParam == *(_DWORD *)(v4 + 116) && SHIWORD(lParam) == *(_DWORD *)(v4 + 120) )
          return 0;
        v33 = (*(_BYTE *)(v4 + 68) & 1) == 0;
        *(_DWORD *)(v4 + 116) = (signed __int16)lParam;
        *(_DWORD *)(v4 + 120) = SHIWORD(lParam);
        if ( v33 || !*(_DWORD *)(v4 + 56) )
          return 0;
        goto LABEL_180;
      case 0x41Du:
        if ( !lParam )
          goto LABEL_180;
        v33 = lParam == *(_DWORD *)(v4 + 56);
LABEL_179:
        if ( v33 )
LABEL_180:
          DoShowBubble(v4);
        return 0;
      case 0x411u:
        v40 = *(_DWORD *)(v4 + 68);
        if ( v40 & 0x10 )
        {
          v41 = cchDest && lParam ? 1 : 0;
          if ( ((unsigned __int8)v40 ^ (unsigned __int8)v41) & 1 )
          {
            PopBubble(v4);
            *(_DWORD *)(v4 + 68) ^= 1u;
            if ( v41 )
            {
              v42 = FindTool(v4, lParam);
              if ( v42 )
                ShowBubbleForTool(v4, v42);
            }
          }
        }
        return 1;
      case 0x413u:
        if ( *(_DWORD *)(v4 + 128) != cchDest )
        {
          v43 = *(HWND *)v4;
          *(_DWORD *)(v4 + 128) = cchDest;
          InvalidateRgn(v43, 0, 1);
        }
        *(_DWORD *)(v4 + 124) |= 1u;
        return 0;
      case 0x416u:
        return *(_DWORD *)(v4 + 128);
      case 0x414u:
        if ( *(_DWORD *)(v4 + 132) != cchDest )
        {
          InvalidateRgn(*(HWND *)v4, 0, 1);
          *(_DWORD *)(v4 + 132) = cchDest;
        }
        *(_DWORD *)(v4 + 124) |= 2u;
        return 0;
      case 0x417u:
        return *(_DWORD *)(v4 + 132);
      case 0x418u:
        result = *(_DWORD *)(v4 + 136);
        *(_DWORD *)(v4 + 136) = lParam;
        return result;
      case 0x419u:
        return *(_DWORD *)(v4 + 136);
      case 0x41Au:
        if ( !lParam )
          return 0;
        v21 = v4 + 140;
        v20 = lParam;
        goto LABEL_122;
      case 0x41Bu:
        if ( !lParam )
          return 0;
        v20 = v4 + 140;
        v21 = lParam;
        goto LABEL_122;
      case 0x41Eu:
        if ( !lParam )
          return 0;
        v44 = FindTool(v4, lParam);
        v45 = v44;
        if ( !v44 )
          return 0;
        v46 = GetToolText(v4, v44);
        TTGetTipSize(v4, v45, (LPCWSTR)v46, (int)&Points.y, (int)&v55);
        v47 = Points.y + *(_DWORD *)(v4 + 140) + *(_DWORD *)(v4 + 148) + 4 * g_cxBorder;
        v48 = (char *)v55 + 2 * g_cyBorder + *(_DWORD *)(v4 + 144) + *(_DWORD *)(v4 + 152);
        if ( *(_BYTE *)(v4 + 8) & 0x40 )
        {
          LOWORD(v47) = v47 + 20;
          LOWORD(v48) = (_WORD)v48 + 16;
        }
        return (unsigned __int16)v47 | ((unsigned __int16)v48 << 16);
      case 0x41Fu:
        return TTAdjustRect(v4, cchDest, lParam);
      case 0x420u:
        WideCharStr = 0;
        memset(&Dst, 0, 0xC6u);
        *(_DWORD *)(v4 + 104) = cchDest;
        Str_Set(v4 + 96, 0);
        *(_DWORD *)(v4 + 108) = 0;
        TTCreateTitleBitmaps((HICON)v4);
        if ( !lParam )
          goto LABEL_238;
        v49 = lstrlenA((LPCSTR)lParam);
        *(_DWORD *)(v4 + 100) = v49;
        if ( (unsigned int)v49 >= 0x64 )
          goto LABEL_238;
        MultiByteToWideChar(*(_DWORD *)(v4 + 20), 1u, (LPCSTR)lParam, -1, &WideCharStr, 100);
        Str_Set(v4 + 96, &WideCharStr);
        return 1;
      case 0x421u:
        *(_DWORD *)(v4 + 104) = cchDest;
        Str_Set(v4 + 96, 0);
        *(_DWORD *)(v4 + 108) = 0;
        TTCreateTitleBitmaps((HICON)v4);
        if ( !lParam || (v50 = lstrlenW((LPCWSTR)lParam), *(_DWORD *)(v4 + 100) = v50, (unsigned int)v50 >= 0x64) )
        {
LABEL_238:
          *(_DWORD *)(v4 + 100) = 0;
          return 0;
        }
        Str_Set(v4 + 96, (LPCWSTR)lParam);
        break;
      default:
        goto LABEL_242;
    }
    return 1;
  }
  if ( Msg == 1037 )
    return *(_DWORD *)(v4 + 36);
  if ( Msg > 0x201 )
  {
    if ( Msg > 0x406 )
    {
      if ( Msg == 1031 )
      {
        if ( lParam )
          HandleRelayedMessage(
            v4,
            *(HWND *)lParam,
            *(_DWORD *)(lParam + 4),
            *(_DWORD *)(lParam + 8),
            *(_DWORD *)(lParam + 12));
        return 0;
      }
      if ( Msg == 1032 )
      {
        if ( lParam && ThunkToolInfoAtoW(lParam, (int)&Src, 0, *(_DWORD *)(v4 + 20)) )
        {
          v29 = FindTool(v4, (int)&Src);
          return CopyToolInfoA(v29, lParam, *(_DWORD *)(v4 + 20));
        }
        return 0;
      }
      if ( Msg == 1033 )
      {
        if ( !lParam || !ThunkToolInfoAtoW(lParam, (int)&Src, 1, *(_DWORD *)(v4 + 20)) )
          return 0;
        v27 = FindTool(v4, (int)&Src);
        v28 = v27;
        if ( v27 )
        {
          TTSetTipText(v27, 0);
          memmove((void *)v28, &Src, Src);
          *(_DWORD *)(v28 + 36) = 0;
          TTSetTipText(v28, (LPCWSTR)hMem);
          if ( v28 == *(_DWORD *)(v4 + 56) )
            DoShowBubble(v4);
        }
      }
      else
      {
        if ( Msg == 1034 )
        {
          if ( !lParam )
            return 0;
          v26 = GetToolAtPoint(v4, *(_DWORD *)lParam, *(POINT *)(lParam + 4), -2, 1);
          if ( !v26 )
            return 0;
          ThunkToolInfoWtoA(v26, lParam + 12, *(_DWORD *)(v4 + 20));
          return 1;
        }
        if ( Msg == 1035 )
        {
          if ( lParam )
          {
            if ( *(_DWORD *)(lParam + 36) )
            {
              if ( ThunkToolInfoAtoW(lParam, (int)&Src, 0, *(_DWORD *)(v4 + 20)) )
              {
                **(_BYTE **)(lParam + 36) = 0;
                v24 = FindTool(v4, (int)&Src);
                v25 = GetToolText(v4, v24);
                if ( v25 )
                  WideCharToMultiByte(*(_DWORD *)(v4 + 20), 0, (LPCWSTR)v25, -1, *(LPSTR *)(lParam + 36), 80, 0, 0);
              }
            }
          }
          return 0;
        }
        if ( Msg != 1036 )
          goto LABEL_242;
        if ( !lParam || !ThunkToolInfoAtoW(lParam, (int)&Src, 1, *(_DWORD *)(v4 + 20)) )
          return 0;
        TTUpdateTipText(v4, (int)&Src);
      }
      if ( v53 & 0x200 && hMem != (HLOCAL)-1 )
        LocalFree(hMem);
      return 0;
    }
    if ( Msg == 1030 )
    {
      if ( lParam && ThunkToolInfoAtoW(lParam, (int)&Src, 0, *(_DWORD *)(v4 + 20)) )
      {
        v19 = FindTool(v4, (int)&Src);
LABEL_120:
        if ( v19 )
        {
          v20 = lParam + 16;
          v21 = v19 + 16;
LABEL_122:
          *(_DWORD *)v21 = *(_DWORD *)v20;
          v23 = v20 + 4;
          v22 = v21 + 4;
          *(_DWORD *)v22 = *(_DWORD *)v23;
          v23 += 4;
          v22 += 4;
          *(_DWORD *)v22 = *(_DWORD *)v23;
          *(_DWORD *)(v22 + 4) = *(_DWORD *)(v23 + 4);
        }
      }
      return 0;
    }
    if ( Msg == 516 || Msg == 519 )
    {
LABEL_62:
      v13 = *(_DWORD *)(v4 + 56);
      if ( v13 && *(_DWORD *)(v13 + 4) & 0x100 )
      {
        Points.x = (signed __int16)lParam;
        Points.y = SHIWORD(lParam);
        MapWindowPoints(*(HWND *)v4, *(HWND *)(v13 + 8), &Points, 1u);
        SendMessageW(
          *(HWND *)(*(_DWORD *)(v4 + 56) + 8),
          Msg,
          cchDest,
          (unsigned __int16)Points.x | (LOWORD(Points.y) << 16));
      }
      return 0;
    }
    if ( Msg == 792 )
    {
      TTRender(v4, (HDC)cchDest);
      return 0;
    }
    if ( Msg == 1025 )
    {
      if ( cchDest )
      {
        *(_DWORD *)(v4 + 68) |= 0x10u;
      }
      else
      {
        PopBubble(v4);
        *(_DWORD *)(v4 + 68) &= 0xFFFFFFEE;
      }
      return 0;
    }
    if ( Msg == 1027 )
    {
      TTSetDelayTime(v4, cchDest, lParam);
      return 0;
    }
    if ( Msg != 1028 )
    {
      if ( Msg == 1029 )
      {
        if ( lParam && ThunkToolInfoAtoW(lParam, (int)&Src, 0, *(_DWORD *)(v4 + 20)) )
          DeleteTool(v4, (int)&Src);
        return 0;
      }
      goto LABEL_242;
    }
    if ( !lParam || !ThunkToolInfoAtoW(lParam, (int)&Src, 1, *(_DWORD *)(v4 + 20)) )
      return 0;
    v18 = AddTool(v4, &Src);
    if ( v53 & 0x200 && hMem != (HLOCAL)-1 )
      LocalFree(hMem);
    result = v18;
  }
  else
  {
    if ( Msg == 513 )
      goto LABEL_62;
    if ( Msg <= 0x30 )
    {
      if ( Msg != 48 )
      {
        if ( Msg <= 0xF )
        {
          if ( Msg == 15 )
          {
            TTOnPaint(v4);
            return 0;
          }
          if ( Msg != 1 )
          {
            if ( Msg == 2 )
            {
              CCDestroyWindow();
              if ( *(_DWORD *)(v4 + 52) )
              {
                v8 = 0;
                if ( *(_DWORD *)(v4 + 36) > 0 )
                {
                  Points.y = 0;
                  do
                  {
                    TTBeforeFreeTool((UINT_PTR *)v4, Points.y + *(_DWORD *)(v4 + 52));
                    Points.y += 44;
                    ++v8;
                  }
                  while ( v8 < *(_DWORD *)(v4 + 36) );
                }
                LocalFree(*(HLOCAL *)(v4 + 52));
              }
              ToolTips_NewFont(v4, HANDLE_FLAG_INHERIT);
              Str_Set(v4 + 88, 0);
              Str_Set(v4 + 96, 0);
              if ( *(_DWORD *)(v4 + 112) )
                ImageList_Destroy(*(HIMAGELIST *)(v4 + 112));
              LocalFree((HLOCAL)v4);
              SetWindowLongW(v55, 0, 0);
              return 0;
            }
            if ( Msg > 0xC && Msg <= 0xE )
            {
              v5 = (wchar_t *)(Msg == 13 ? lParam : 0);
              if ( v5 && cchDest )
                *v5 = 0;
              if ( v4 )
              {
                v6 = GetCurToolText(v4);
                if ( v6 )
                {
                  if ( v5 && cchDest )
                  {
                    StringCchCopyW(v5, cchDest, (STRSAFE_LPCWSTR)v6);
                    result = lstrlenW(v5);
                  }
                  else
                  {
                    result = lstrlenW((LPCWSTR)v6);
                  }
                  return result;
                }
              }
              return 0;
            }
            goto LABEL_242;
          }
          CCCreateWindow();
          v9 = ToolTipsMgrCreate((WPARAM)v55, lParam);
          v4 = v9;
          if ( !v9 )
            return -1;
          SetWindowLongW(v55, 0, v9);
          SetWindowBits(v55, -20, 128, 128);
          v10 = -2139095040;
          if ( *(_BYTE *)(v4 + 8) & 0x40 )
            v10 = 2147483648;
          SetWindowBits(v55, -16, -1061158912, v10);
LABEL_38:
          ToolTips_NewFont(v4, 0);
          return 0;
        }
        if ( Msg == 20 )
          return 0;
        if ( Msg == 21 )
        {
          InitGlobalColors();
          if ( v4 )
          {
            v11 = *(_DWORD *)(v4 + 124);
            if ( !(v11 & 1) )
              *(_DWORD *)(v4 + 128) = g_clrInfoBk;
            if ( !(v11 & 2) )
              *(_DWORD *)(v4 + 132) = g_clrInfoText;
          }
          return 0;
        }
        if ( Msg == 26 )
        {
          InitGlobalMetrics(cchDest);
          if ( !*(_DWORD *)(v4 + 60) )
            return 0;
          goto LABEL_38;
        }
LABEL_242:
        if ( CCWndProc(v4, Msg, cchDest, lParam, (int)&Points.y) )
          return Points.y;
        return DefWindowProcW(v55, Msg, cchDest, lParam);
      }
      TTSetFont(v4, (HANDLE)cchDest, lParam);
      return 1;
    }
    if ( Msg == 49 )
    {
      if ( v4 )
        return *(_DWORD *)(v4 + 64);
      return 0;
    }
    if ( Msg == 61 )
    {
      if ( lParam == -12 )
        return 65560;
      return DefWindowProcW(v55, Msg, cchDest, lParam);
    }
    if ( Msg != 85 )
    {
      if ( Msg == 125 )
      {
        if ( cchDest == -16 && v4 )
        {
          if ( *(_BYTE *)(v4 + 8) & 0x40 && !(*(_BYTE *)(lParam + 4) & 0x40) )
            SetWindowRgn(*(HWND *)v4, 0, 0);
          *(_DWORD *)(v4 + 8) = *(_DWORD *)(lParam + 4);
        }
        return 0;
      }
      if ( Msg == 132 )
      {
        if ( !v4 || *(_DWORD *)(v4 + 28) >= 5 && !(*(_BYTE *)(v4 + 124) & 8) )
          return DefWindowProcW(v55, Msg, cchDest, lParam);
        v14 = *(_DWORD *)(v4 + 56);
        if ( !v14 || !(*(_DWORD *)(v14 + 4) & 0x100) )
          return DefWindowProcW(v55, Msg, cchDest, lParam);
        return -1;
      }
      if ( Msg == 275 )
      {
        TTHandleTimer(v4, cchDest);
        return 0;
      }
      if ( Msg != 512 )
        goto LABEL_242;
      if ( !(*(_BYTE *)(v4 + 68) & 1) )
      {
        v12 = *(_DWORD *)(v4 + 56);
        if ( v12 )
        {
          if ( !(*(_DWORD *)(v12 + 4) & 0x100) )
            PopBubble(v4);
        }
      }
      goto LABEL_62;
    }
    if ( lParam == 3 )
      return 2;
    if ( lParam != 4 )
      return 0;
    v15 = 0;
    v33 = *(_DWORD *)(v4 + 36) == 0;
    v16 = *(_DWORD *)(v4 + 36) < 0;
    Points.y = 0;
    if ( !v16 && !v33 )
    {
      do
      {
        v17 = v15 + *(_DWORD *)(v4 + 52);
        if ( SendMessageW(*(HWND *)(v17 + 8), 0x55u, (WPARAM)v55, 3) == 2 )
          *(_DWORD *)(v17 + 4) |= 0x40u;
        else
          *(_DWORD *)(v17 + 4) &= 0xFFFFFFBF;
        ++Points.y;
        v15 += 44;
      }
      while ( Points.y < *(_DWORD *)(v4 + 36) );
    }
    result = CIHandleNotifyFormat(v4, 4);
  }
  return result;
}
// 6F7E693C: using guessed type int g_clrInfoBk;
// 6F7E6940: using guessed type int g_clrInfoText;

//----- (6F7B497B) --------------------------------------------------------
int __stdcall FormatIPAddress(int a1, int a2)
{
  int v2; // edx@1
  int v3; // esi@2
  int v4; // eax@5
  int result; // eax@5
  int v6; // [sp+4h] [bp-4h]@1

  v2 = a1;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  v6 = 0;
  if ( *(_WORD *)a1 )
  {
    v3 = 0;
    do
    {
      if ( *(_WORD *)v2 < 0x30u || *(_WORD *)v2 > 0x39u )
      {
        ++v3;
        result = v3 == 4;
        v6 = v3 == 4;
      }
      else
      {
        v4 = 10 * *(_DWORD *)(a2 + 4 * v3);
        *(_DWORD *)(a2 + 4 * v3) = v4;
        result = *(_WORD *)v2 + v4 - 48;
        *(_DWORD *)(a2 + 4 * v3) = result;
      }
      v2 += 2;
    }
    while ( !v6 );
  }
  return result;
}

//----- (6F7B49E4) --------------------------------------------------------
int __stdcall IP_OnSetFont(HDC hdc, HGDIOBJ h, LPARAM lParam)
{
  HDC v3; // esi@1
  LONG v4; // ecx@4
  HWND *v5; // ebx@4
  HWND v6; // eax@5
  int result; // eax@7
  struct tagRECT Rect; // [sp+Ch] [bp-1Ch]@4
  HWND hWnd; // [sp+1Ch] [bp-Ch]@5
  HGDIOBJ v10; // [sp+20h] [bp-8h]@4
  int v11; // [sp+24h] [bp-4h]@1
  HDC hdcb; // [sp+30h] [bp+8h]@4
  int hdca; // [sp+30h] [bp+8h]@4

  v3 = hdc;
  v11 = 0;
  if ( h )
    v11 = 1;
  else
    h = (HGDIOBJ)SendMessageW(*((HWND *)hdc + 1), 0x31u, 0, 0);
  hdcb = GetDC(*((HWND *)hdc + 1));
  v10 = SelectObject(hdcb, h);
  GetCharWidthW(hdcb, 0x2Eu, 0x2Eu, (LPINT)v3 + 3);
  SelectObject(hdcb, v10);
  ReleaseDC(*((HWND *)v3 + 1), hdcb);
  GetClientRect(*((HWND *)v3 + 1), &Rect);
  v4 = Rect.right;
  *((_DWORD *)v3 + 5) = h;
  *((_DWORD *)v3 + 2) = (unsigned int)(v4 - 3 * *((_DWORD *)v3 + 3) - Rect.left - 3) >> 2;
  hdca = 3;
  v5 = (HWND *)(v3 + 6);
  v10 = (HGDIOBJ)4;
  do
  {
    v6 = *v5;
    hWnd = *v5;
    if ( v11 )
      SendMessageW(v6, 0x30u, (WPARAM)h, lParam);
    SetWindowPos(hWnd, 0, hdca, 1, *((_DWORD *)v3 + 2), Rect.bottom - Rect.top, 0x10u);
    result = *((_DWORD *)v3 + 3) + *((_DWORD *)v3 + 2);
    v5 += 3;
    hdca += result;
    v10 = (char *)v10 - 1;
  }
  while ( v10 );
  return result;
}

//----- (6F7B4ADF) --------------------------------------------------------
LRESULT __stdcall EnterField(HWND *a1, unsigned __int16 a2, unsigned __int16 a3)
{
  SetFocus(*a1);
  return SendMessageW(*a1, 0xB1u, a2, a3);
}

//----- (6F7B4B11) --------------------------------------------------------
int __stdcall GetFieldValue(HWND *a1)
{
  unsigned __int16 v1; // ax@1
  int result; // eax@2
  WCHAR lParam[4]; // [sp+0h] [bp-Ch]@1

  lParam[0] = 3;
  v1 = SendMessageW(*a1, 0xC4u, 0, (LPARAM)lParam);
  if ( v1 )
  {
    lParam[v1] = 0;
    result = StrToIntW(lParam);
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7B4B73) --------------------------------------------------------
LRESULT __stdcall SetFieldValue(int a1, int a2, int a3)
{
  wchar_t pszDest; // [sp+4h] [bp-Ch]@1

  StringCchPrintfW(&pszDest, 4u, L"%d", a3);
  return SendMessageW(*(HWND *)(12 * (a2 + 2) + a1), 0xCu, 0, (LPARAM)&pszDest);
}

//----- (6F7B4BCD) --------------------------------------------------------
signed int __stdcall ExitField(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  HWND v4; // ST04_4@1
  int v5; // ecx@2
  LPARAM lParam; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+18h] [bp-8h]@1
  int v9; // [sp+1Ch] [bp-4h]@1
  int v10; // [sp+2Ch] [bp+Ch]@1

  v2 = a2;
  v3 = a1 + 12 * (a2 + 2);
  v10 = GetFieldValue((HWND *)(a1 + 12 * (a2 + 2)));
  v9 = v10;
  v4 = *(HWND *)(a1 + 4);
  v8 = v2;
  SendNotifyEx(*(_DWORD *)a1, v4, -860, (LPARAM)&lParam, 0);
  if ( v9 != -1 )
  {
    v5 = *(_BYTE *)(v3 + 8);
    if ( v9 < v5 )
    {
LABEL_6:
      SetFieldValue(a1, v2, v5);
      return 0;
    }
    if ( v9 > *(_BYTE *)(v3 + 9) )
    {
      if ( v9 >= v5 )
        v5 = *(_BYTE *)(v3 + 9);
      goto LABEL_6;
    }
  }
  if ( v10 != v9 )
    SetFieldValue(a1, v2, v9);
  return 1;
}

//----- (6F7B4C52) --------------------------------------------------------
signed int __stdcall SwitchFields(int a1, int a2, int a3, unsigned __int16 a4, unsigned __int16 a5)
{
  signed int result; // eax@1

  result = ExitField(a1, a2);
  if ( result )
  {
    EnterField((HWND *)(a1 + 12 * (a3 + 2)), a4, a5);
    result = 1;
  }
  return result;
}

//----- (6F7B4C8A) --------------------------------------------------------
LRESULT __stdcall IPAddressFieldProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax@1
  int v6; // edi@3
  unsigned __int16 v7; // cx@4
  int v8; // esi@4
  HWND *v9; // edi@21
  LRESULT v10; // eax@25
  int v11; // eax@39
  LRESULT v12; // eax@47
  LRESULT v13; // eax@64
  unsigned __int16 v14; // [sp-10h] [bp-1Ch]@38
  unsigned __int16 v15; // [sp-Ch] [bp-18h]@38
  unsigned __int16 v16; // [sp+8h] [bp-4h]@4
  HWND hWnda; // [sp+14h] [bp+8h]@10

  v4 = GetParent(hWnd);
  if ( !v4 )
    return 0;
  v6 = GetWindowLongW(v4, -21);
  if ( !v6 )
    return 0;
  v7 = GetWindowLongW(hWnd, -21);
  v8 = v7;
  v16 = v7;
  if ( *(HWND *)(12 * (v7 + 2) + v6) != hWnd )
    return 0;
  if ( Msg == 2 )
  {
    v13 = SendMessageW(hWnd, 0x31u, 0, 0);
    DeleteObject((HGDIOBJ)v13);
    return 0;
  }
  if ( Msg == 8 )
  {
    if ( ExitField(v6, v7) )
      return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
    return 0;
  }
  if ( Msg == 256 )
  {
    if ( wParam == 35 )
    {
      if ( v7 >= 3u )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      SwitchFields(v6, v7, 3, 3u, 3u);
      return 0;
    }
    if ( wParam == 36 )
    {
      if ( v7 <= 0u )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      SwitchFields(v6, v7, 0, 0, 0);
      return 0;
    }
    if ( wParam <= 0x24 || wParam > 0x28 )
      return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
    if ( GetKeyState(17) >= 0 )
    {
      v12 = SendMessageW(hWnd, 0xB0u, 0, 0);
      if ( (_WORD)v12 != HIWORD(v12) )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      if ( (wParam == 37 || wParam == 38) && !(_WORD)v12 && v16 > 0u )
      {
        v15 = 3;
        v14 = 3;
        goto LABEL_39;
      }
      if ( wParam != 39 && wParam != 40
        || v16 >= 3u
        || (unsigned __int16)v12 < (unsigned int)SendMessageW(hWnd, 0xC1u, 0, 0) )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      v15 = 0;
    }
    else
    {
      if ( (wParam == 37 || wParam == 38) && v16 > 0u )
      {
        v15 = 3;
        v14 = 0;
LABEL_39:
        v11 = v8 - 1;
LABEL_40:
        SwitchFields(v6, v8, v11, v14, v15);
        return 0;
      }
      if ( wParam != 39 && wParam != 40 || v16 >= 3u )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      v15 = 3;
    }
    v14 = 0;
    v11 = v8 + 1;
    goto LABEL_40;
  }
  if ( Msg != 258 )
    return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
  if ( wParam - 48 > 9 )
  {
    if ( wParam == 46 || wParam == 32 )
    {
      v10 = SendMessageW(hWnd, 0xB0u, 0, 0);
      if ( !v10 || HIWORD(v10) != (_WORD)v10 || !ExitField(v6, v8) )
        return 0;
      if ( v16 < 3u )
      {
        EnterField((HWND *)(v6 + 12 * (v8 + 3)), 0, 3u);
        return 0;
      }
    }
    else
    {
      if ( wParam == 8 )
      {
        if ( v7 > 0u && !SendMessageW(hWnd, 0xB0u, 0, 0) )
        {
          if ( SwitchFields(v6, v8, v8 - 1, 3u, 3u) )
          {
            v9 = (HWND *)(12 * (v8 + 1) + v6);
            if ( SendMessageW(*v9, 0xC1u, 0, 0) )
              SendMessageW(*v9, 0x102u, 8u, lParam);
          }
          return 0;
        }
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
      }
      if ( wParam <= 0x20 )
        return CallWindowProcW(*(WNDPROC *)(12 * v8 + v6 + 28), hWnd, Msg, wParam, lParam);
    }
    MessageBeep(0xFFFFFFFF);
    return 0;
  }
  CallWindowProcW(*(WNDPROC *)(12 * v7 + v6 + 28), hWnd, 0x102u, wParam, lParam);
  hWnda = (HWND)SendMessageW(hWnd, 0xB0u, 0, 0);
  if ( hWnda == (HWND)196611 && ExitField(v6, v8) && v16 < 3u )
    EnterField((HWND *)(v6 + 12 * (v8 + 3)), 0, 3u);
  return (LRESULT)hWnda;
}

//----- (6F7B4F9D) --------------------------------------------------------
HMENU __stdcall IPAddressWndFn(HWND hWnd, UINT Msg, BOOL bEnable, int a4)
{
  unsigned int v4; // ebx@1
  LONG v5; // eax@1
  int v6; // esi@1
  HWND *v7; // edi@9
  int v8; // ebx@15
  signed int v9; // edi@15
  HLOCAL v10; // eax@18
  LONG v11; // ebx@18
  HWND v12; // ST2C_4@19
  int v13; // esi@19
  COLORREF v14; // ecx@20
  HWND v15; // eax@20
  LONG v16; // ST2C_4@20
  LONG v17; // eax@20
  HWND v18; // ST24_4@20
  HWND *v19; // esi@21
  signed int v20; // edi@21
  HWND *v22; // ebx@27
  HWND v23; // ST2C_4@32
  unsigned __int16 v24; // ax@32
  COLORREF v25; // eax@41
  COLORREF v26; // ebx@43
  signed int v27; // ebx@43
  int v28; // eax@44
  HGDIOBJ v29; // ST2C_4@45
  signed int v30; // edi@46
  HWND *v31; // esi@46
  int v32; // eax@47
  int v34; // ebx@61
  unsigned __int16 v35; // ax@68
  HWND *v36; // edi@69
  HWND v37; // ST2C_4@71
  unsigned __int16 v38; // ax@71
  unsigned int v39; // ebx@73
  HWND v40; // eax@79
  signed int v41; // edx@79
  int v42; // ecx@79
  unsigned __int16 v43; // ax@83
  int v44; // edx@84
  signed int v45; // ecx@85
  int v46; // eax@85
  unsigned __int16 v47; // ax@90
  int v48; // edi@91
  HWND *v49; // esi@91
  signed int v50; // ebx@91
  int v51; // eax@92
  signed int v52; // edi@101
  HWND *v53; // esi@101
  HWND *v54; // edi@106
  __int16 v55; // ax@113
  int v56; // esi@114
  int v57; // [sp-4h] [bp-7Ch]@41
  COLORREF v58; // [sp-4h] [bp-7Ch]@50
  struct tagRECT Rect; // [sp+Ch] [bp-6Ch]@27
  LONG dwNewLong; // [sp+1Ch] [bp-5Ch]@19
  HMENU hMenu; // [sp+20h] [bp-58h]@1
  HWND hWndParent; // [sp+24h] [bp-54h]@1
  COLORREF color; // [sp+28h] [bp-50h]@1
  struct tagPAINTSTRUCT Paint; // [sp+2Ch] [bp-4Ch]@40
  wchar_t pszDest; // [sp+6Ch] [bp-Ch]@29
  HGDIOBJ h; // [sp+70h] [bp-8h]@19

  v4 = bEnable;
  hWndParent = hWnd;
  color = a4;
  v5 = GetWindowLongW(hWnd, -21);
  v6 = v5;
  hMenu = (HMENU)1;
  if ( Msg > 0x87 )
  {
    if ( Msg <= 0x466 )
    {
      if ( Msg == 1126 )
      {
        v48 = 0;
        hMenu = 0;
        v49 = (HWND *)(v5 + 24);
        v50 = 4;
        do
        {
          v51 = GetFieldValue(v49);
          if ( v51 == -1 )
            v51 = 0;
          else
            hMenu = (HMENU)((char *)hMenu + 1);
          v48 = v51 + (v48 << 8);
          v49 += 3;
          --v50;
        }
        while ( v50 );
        *(_DWORD *)color = v48;
        return hMenu;
      }
      if ( Msg == 273 )
      {
        v39 = (unsigned int)bEnable >> 16;
        if ( (unsigned int)bEnable >> 16 == 256 )
        {
          v44 = *(_DWORD *)(v5 + 16);
          if ( !(v44 & 0x10) )
          {
            v45 = 0;
            v46 = v5 + 24;
            do
            {
              if ( *(_DWORD *)v46 == color )
                break;
              ++v45;
              v46 += 12;
            }
            while ( v45 < 4 );
            if ( v45 < 4 && !(v44 & 4) )
            {
              v47 = GetDlgCtrlID(hWndParent);
              SendMessageW(*(HWND *)v6, 0x111u, v47 | 0x1000000, (LPARAM)hWndParent);
              *(_DWORD *)(v6 + 16) |= 4u;
            }
          }
          return hMenu;
        }
        if ( v39 == 512 )
        {
          if ( !(*(_BYTE *)(v5 + 16) & 0x10) )
          {
            v40 = GetFocus();
            v41 = 0;
            v42 = v6 + 24;
            do
            {
              if ( *(HWND *)v42 == v40 )
                break;
              ++v41;
              v42 += 12;
            }
            while ( v41 < 4 );
            if ( v41 >= 4 )
            {
              v43 = GetDlgCtrlID(hWndParent);
              SendMessageW(*(HWND *)v6, 0x111u, v43 | 0x2000000, (LPARAM)hWndParent);
              *(_DWORD *)(v6 + 16) &= 0xFFFFFFFB;
            }
          }
          return hMenu;
        }
        if ( v39 != 768 || *(_BYTE *)(v5 + 16) & 8 )
          return hMenu;
      }
      else
      {
        if ( Msg == 513 )
        {
          SetFocus(hWndParent);
          return hMenu;
        }
        if ( Msg == 1124 )
        {
          *(_DWORD *)(v5 + 16) |= 8u;
          v36 = (HWND *)(v5 + 24);
          color = 4;
          do
          {
            SendMessageW(*v36, 0xCu, 0, (LPARAM)&WindowName);
            v36 += 3;
            --color;
          }
          while ( color );
          v37 = hWndParent;
          *(_DWORD *)(v6 + 16) &= 0xFFFFFFF7;
          v38 = GetDlgCtrlID(hWndParent);
          SendMessageW(*(HWND *)v6, 0x111u, v38 | 0x3000000, (LPARAM)v37);
          return hMenu;
        }
        if ( Msg != 1125 )
          return (HMENU)DefWindowProcW(hWndParent, Msg, bEnable, color);
        *(_DWORD *)(v5 + 16) |= 8u;
        dwNewLong = 0;
        v34 = v5 + 33;
        do
        {
          if ( *(_BYTE *)(v34 - 1) > BYTE3(color) || BYTE3(color) > *(_BYTE *)v34 )
            hMenu = 0;
          else
            SetFieldValue(v6, dwNewLong, BYTE3(color));
          color <<= 8;
          ++dwNewLong;
          v34 += 12;
        }
        while ( dwNewLong < 4 );
        *(_DWORD *)(v6 + 16) &= 0xFFFFFFF7;
      }
      v35 = GetDlgCtrlID(hWndParent);
      SendMessageW(*(HWND *)v6, 0x111u, v35 | 0x3000000, (LPARAM)hWndParent);
      return hMenu;
    }
    if ( Msg == 1127 )
    {
      if ( (unsigned int)bEnable < 4 )
      {
        v55 = (unsigned __int16)color >> 8;
        if ( (unsigned __int8)color <= BYTE1(color) )
        {
          v56 = 12 * bEnable + v6;
          hMenu = (HMENU)(unsigned __int16)(*(_BYTE *)(v56 + 32) + (*(_BYTE *)(v56 + 33) << 8));
          *(_BYTE *)(v56 + 32) = color;
          *(_BYTE *)(v56 + 33) = v55;
          return hMenu;
        }
      }
    }
    else
    {
      if ( Msg == 1128 )
      {
        if ( (unsigned int)bEnable >= 4 )
        {
          v4 = 0;
          v54 = (HWND *)(v5 + 24);
          do
          {
            if ( GetFieldValue(v54) == -1 )
              break;
            ++v4;
            v54 += 3;
          }
          while ( v4 < 4 );
          if ( v4 >= 4 )
            v4 = 0;
        }
        EnterField((HWND *)(v6 + 12 * (v4 + 2)), 0, 3u);
        return hMenu;
      }
      if ( Msg != 1129 )
        return (HMENU)DefWindowProcW(hWndParent, Msg, bEnable, color);
      hMenu = (HMENU)1;
      v52 = 0;
      v53 = (HWND *)(v5 + 24);
      while ( GetFieldValue(v53) == -1 )
      {
        ++v52;
        v53 += 3;
        if ( v52 >= 4 )
          return hMenu;
      }
    }
    return 0;
  }
  if ( Msg == 135 )
    return (HMENU)128;
  if ( Msg <= 0xC )
  {
    if ( Msg == 12 )
    {
      FormatIPAddress(color, (int)&Rect);
      *(_DWORD *)(v6 + 16) |= 8u;
      dwNewLong = 0;
      v22 = (HWND *)(v6 + 24);
      do
      {
        if ( *(_WORD *)color )
          StringCchPrintfW(&pszDest, 4u, L"%d", *(&Rect.left + dwNewLong));
        else
          pszDest = 0;
        SendMessageW(*v22, 0xCu, 0, (LPARAM)&pszDest);
        ++dwNewLong;
        v22 += 3;
      }
      while ( dwNewLong < 4 );
      v23 = hWndParent;
      *(_DWORD *)(v6 + 16) &= 0xFFFFFFF7;
      v24 = GetDlgCtrlID(hWndParent);
      SendMessageW(*(HWND *)v6, 0x111u, v24 | 0x3000000, (LPARAM)v23);
      return hMenu;
    }
    if ( Msg != 1 )
    {
      if ( Msg == 2 )
      {
        CCDestroyWindow();
        v8 = v6 + 24;
        v9 = 4;
        do
        {
          SendMessageW(*(HWND *)v8, 2u, 0, 0);
          SetWindowLongW(*(HWND *)v8, -4, *(_DWORD *)(v8 + 4));
          v8 += 12;
          --v9;
        }
        while ( v9 );
        LocalFree((HLOCAL)v6);
        return hMenu;
      }
      if ( Msg == 7 )
      {
        EnterField((HWND *)(v5 + 24), 0, 3u);
        return hMenu;
      }
      if ( Msg == 10 )
      {
        *(_DWORD *)(v5 + 16) ^= (bEnable ^ *(_DWORD *)(v5 + 16)) & 1;
        v7 = (HWND *)(v5 + 24);
        color = 4;
        do
        {
          EnableWindow(*v7, bEnable);
          v7 += 3;
          --color;
        }
        while ( color );
        if ( *(_BYTE *)(v6 + 16) & 2 )
          InvalidateRect(hWndParent, 0, 0);
        return hMenu;
      }
      return (HMENU)DefWindowProcW(hWndParent, Msg, bEnable, color);
    }
    CCCreateWindow();
    v10 = LocalAlloc(0x40u, 0x48u);
    v11 = (LONG)v10;
    if ( v10 )
    {
      *((_DWORD *)v10 + 4) |= 1u;
      *(_DWORD *)v10 = *(_DWORD *)(color + 12);
      v12 = hWndParent;
      *((_DWORD *)v10 + 1) = hWndParent;
      dwNewLong = 0;
      v13 = (int)((char *)v10 + 24);
      hMenu = (HMENU)GetDlgCtrlID(v12);
      h = (HGDIOBJ)(v11 + 24);
      do
      {
        v14 = color;
        *(_BYTE *)(v13 + 8) = 0;
        *(_BYTE *)(v13 + 9) = -1;
        v15 = CreateWindowExW(
                0,
                L"Edit",
                0,
                0x40000001u,
                0,
                10,
                100,
                100,
                hWndParent,
                hMenu,
                *(HINSTANCE *)(v14 + 4),
                0);
        v16 = dwNewLong;
        *(_DWORD *)v13 = v15;
        SetWindowLongW(v15, -21, v16);
        SendMessageW(*(HWND *)v13, 0xC5u, 3u, 0);
        v17 = GetWindowLongW(*(HWND *)v13, -4);
        v18 = *(HWND *)v13;
        *(_DWORD *)(v13 + 4) = v17;
        SetWindowLongW(v18, -4, (LONG)IPAddressFieldProc);
        ++dwNewLong;
        v13 += 12;
      }
      while ( dwNewLong < 4 );
      SetWindowLongW(hWndParent, -21, v11);
      IP_OnSetFont((HDC)v11, 0, 0);
      v19 = (HWND *)h;
      v20 = 4;
      do
      {
        ShowWindow(*v19, 5);
        v19 += 3;
        --v20;
      }
      while ( v20 );
    }
    else
    {
      DestroyWindow(hWndParent);
    }
    return 0;
  }
  if ( Msg < 0xD )
    return (HMENU)DefWindowProcW(hWndParent, Msg, bEnable, color);
  if ( Msg <= 0xE )
  {
    v30 = 0;
    LOWORD(Paint.fErase) = 0;
    Rect.left = 0;
    Rect.top = 0;
    Rect.right = 0;
    Rect.bottom = 0;
    v31 = (HWND *)(v5 + 24);
    do
    {
      v32 = GetFieldValue(v31);
      if ( v32 == -1 )
        v32 = 0;
      *(&Rect.left + v30++) = v32;
      v31 += 3;
    }
    while ( v30 < 4 );
    StringCchPrintfW((STRSAFE_LPWSTR)&Paint.fErase, 0x1Eu, L"%d.%d.%d.%d", Rect.left, Rect.top, Rect.right, Rect.bottom);
    v58 = (COLORREF)&Paint.fErase;
    if ( Msg == 13 )
    {
      StringCchCopyW((STRSAFE_LPWSTR)color, bEnable, (STRSAFE_LPCWSTR)&Paint.fErase);
      v58 = color;
    }
    return (HMENU)lstrlenW((LPCWSTR)v58);
  }
  if ( Msg == 15 )
  {
    BeginPaint(hWndParent, &Paint);
    h = SelectObject(Paint.hdc, *(HGDIOBJ *)(v6 + 20));
    GetClientRect(hWndParent, &Rect);
    if ( *(_BYTE *)(v6 + 16) & 1 )
    {
      v25 = GetSysColor(8);
      v57 = 5;
    }
    else
    {
      v25 = GetSysColor(17);
      v57 = 15;
    }
    color = v25;
    v26 = GetSysColor(v57);
    FillRectClr(Paint.hdc, &Rect, v26);
    SetRect(&Rect, 0, 1, *(_DWORD *)(v6 + 12), Rect.bottom - Rect.top);
    SetBkColor(Paint.hdc, v26);
    SetTextColor(Paint.hdc, color);
    v27 = 3;
    do
    {
      v28 = *(_DWORD *)(v6 + 12);
      Rect.left += v28 + *(_DWORD *)(v6 + 8);
      Rect.right += Rect.left + v28;
      ExtTextOutW(Paint.hdc, Rect.left, 1, 2u, &Rect, L".", 1u, 0);
      --v27;
    }
    while ( v27 );
    v29 = h;
    *(_DWORD *)(v6 + 16) |= 2u;
    SelectObject(Paint.hdc, v29);
    EndPaint(hWndParent, &Paint);
    return hMenu;
  }
  if ( Msg != 48 )
  {
    if ( Msg == 129 )
    {
      SetWindowBits(hWndParent, -20, 512, 512);
      return (HMENU)1;
    }
    return (HMENU)DefWindowProcW(hWndParent, Msg, bEnable, color);
  }
  IP_OnSetFont((HDC)v5, (HGDIOBJ)bEnable, color);
  return 0;
}

//----- (6F7B56C1) --------------------------------------------------------
BOOL __stdcall DoNotify(int a1, unsigned __int16 a2)
{
  BOOL result; // eax@1
  HWND v3; // ecx@1

  result = a1;
  v3 = *(HWND *)(a1 + 8);
  if ( v3 )
    result = PostMessageW(v3, 0x111u, *(_WORD *)(a1 + 4) | (a2 << 16), *(_DWORD *)a1);
  return result;
}

//----- (6F7B56F5) --------------------------------------------------------
signed int __stdcall HandleStop(int a1)
{
  void *v1; // eax@6
  signed int result; // eax@10

  if ( a1 && *(_DWORD *)(a1 + 88) )
  {
    if ( *(_BYTE *)(a1 + 12) & 8 )
    {
      KillTimer(*(HWND *)a1, *(_DWORD *)(a1 + 88));
      *(_DWORD *)(a1 + 88) = 0;
      DoNotify(a1, 2u);
    }
    else
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 24));
      *(_DWORD *)(a1 + 76) = 0;
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 24));
      if ( *(_DWORD *)(a1 + 92) )
        SetEvent(*(HANDLE *)(a1 + 92));
      WaitForSingleObject(*(HANDLE *)(a1 + 88), 0xFFFFFFFF);
      CloseHandle(*(HANDLE *)(a1 + 88));
      v1 = *(void **)(a1 + 92);
      *(_DWORD *)(a1 + 88) = 0;
      if ( v1 )
        CloseHandle(v1);
      *(_DWORD *)(a1 + 92) = 0;
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B5784) --------------------------------------------------------
void __stdcall HandlePaint(int a1, HDC hdc)
{
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 20) )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 24));
      RleFile_Paint(
        *(struct _RLEFILE **)(a1 + 20),
        hdc,
        *(_DWORD *)(a1 + 72),
        *(_DWORD *)(a1 + 48),
        *(_DWORD *)(a1 + 52));
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 24));
    }
  }
}

//----- (6F7B57C8) --------------------------------------------------------
int __stdcall HandleErase(int a1, WPARAM wParam)
{
  LRESULT v2; // edi@1
  struct tagRECT Rect; // [sp+8h] [bp-10h]@1

  v2 = SendMessageW(*(HWND *)(a1 + 8), 0x138u, wParam, *(_DWORD *)a1);
  GetClientRect(*(HWND *)a1, &Rect);
  return FillRect((HDC)wParam, &Rect, (HBRUSH)v2);
}

//----- (6F7B580F) --------------------------------------------------------
int __stdcall HandleTick(LPCRITICAL_SECTION lpCriticalSection)
{
  int v1; // esi@1
  int v2; // edi@1
  HDC v3; // ebx@3
  int v4; // eax@4
  int v5; // eax@7
  int v6; // eax@8
  int v7; // eax@11
  int v8; // eax@14
  struct tagRECT rect; // [sp+8h] [bp-10h]@3
  struct _RTL_CRITICAL_SECTION *lpCriticalSectiona; // [sp+20h] [bp+8h]@3

  v1 = (int)lpCriticalSection;
  v2 = 0;
  if ( lpCriticalSection && lpCriticalSection->SpinCount )
  {
    lpCriticalSectiona = lpCriticalSection + 1;
    EnterCriticalSection(lpCriticalSectiona);
    v3 = GetDC(*(HWND *)v1);
    if ( GetClipBox(v3, &rect) == 1 )
    {
      *(_DWORD *)(v1 + 72) = *(_DWORD *)(v1 + 80);
      v8 = -(*(_DWORD *)(v1 + 76) != 0);
      goto LABEL_16;
    }
    v4 = *(_DWORD *)(v1 + 72);
    if ( v4 == *(_DWORD *)(v1 + 80) )
      HandlePaint(v1, v3);
    else
      RleFile_Draw(*(struct _RLEFILE **)(v1 + 20), v3, v4, *(_DWORD *)(v1 + 48), *(_DWORD *)(v1 + 52));
    v5 = *(_DWORD *)(v1 + 72);
    if ( v5 < *(_DWORD *)(v1 + 84) )
    {
      v7 = v5 + 1;
    }
    else
    {
      v6 = *(_DWORD *)(v1 + 76);
      if ( v6 > 0 )
        *(_DWORD *)(v1 + 76) = v6 - 1;
      if ( !*(_DWORD *)(v1 + 76) )
        goto LABEL_14;
      v7 = *(_DWORD *)(v1 + 80);
    }
    *(_DWORD *)(v1 + 72) = v7;
LABEL_14:
    v8 = *(_DWORD *)(v1 + 76) != 0;
LABEL_16:
    v2 = v8;
    ReleaseDC(*(HWND *)v1, v3);
    LeaveCriticalSection(lpCriticalSectiona);
  }
  return v2;
}

//----- (6F7B58D5) --------------------------------------------------------
int __stdcall Ani_OnStyleChanged(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a2 == -16 )
  {
    result = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a1 + 12) = result;
  }
  return result;
}

//----- (6F7B58F5) --------------------------------------------------------
int __stdcall HandleOpen(int a1, int a2, LPCWSTR lpFileName, int a4)
{
  void *v4; // edi@1
  struct _RLEFILE *v5; // eax@10
  int v7; // eax@16
  HDC v8; // edi@18
  HDC v9; // esi@18
  unsigned int v10; // ST28_4@18
  unsigned int v11; // esi@18
  HWND v12; // ST14_4@21
  DWORD v13; // ST18_4@21
  DWORD v14; // eax@21
  struct tagRECT Rect; // [sp+10h] [bp-220h]@20
  HGDIOBJ ho; // [sp+20h] [bp-210h]@1
  WCHAR String; // [sp+24h] [bp-20Ch]@2

  v4 = (void *)lpFileName;
  ho = (HGDIOBJ)a2;
  if ( a4 == 42 )
  {
    GetWindowTextW(*(HWND *)a1, &String, 260);
    v4 = &String;
  }
  if ( !ho )
    ho = (HGDIOBJ)GetWindowLongW(*(HWND *)a1, -6);
  HandleStop(a1);
  if ( *(_DWORD *)(a1 + 20) )
  {
    RleFile_Close(*(_DWORD *)(a1 + 20));
    LocalFree(*(HLOCAL *)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
  }
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  if ( !v4 || (unsigned int)v4 & 0xFFFF0000 && !*(_WORD *)v4 )
    return 0;
  v5 = (struct _RLEFILE *)LocalAlloc(0x40u, 0x47Cu);
  *(_DWORD *)(a1 + 20) = v5;
  if ( !v5 )
    return 0;
  if ( !RleFile_OpenFromResource(v5, (HMODULE)ho, (LPCWSTR)v4, L"AVI")
    && !RleFile_OpenFromFile(*(struct _RLEFILE **)(a1 + 20), (LPCWSTR)v4) )
  {
    RleFile_Close(*(_DWORD *)(a1 + 20));
    LocalFree(*(HLOCAL *)(a1 + 20));
    *(_DWORD *)(a1 + 20) = 0;
    return 0;
  }
  v7 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)v7;
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(v7 + 12);
  SetRect((LPRECT)(a1 + 48), 0, 0, *(_DWORD *)(v7 + 4), *(_DWORD *)(v7 + 8));
  if ( *(_BYTE *)(a1 + 12) & 2 && *(_DWORD *)(a1 + 8) )
  {
    v8 = GetDC(*(HWND *)a1);
    v9 = CreateCompatibleDC(v8);
    ho = CreateCompatibleBitmap(v8, 1, 1);
    SelectObject(v9, ho);
    HandlePaint(a1, v9);
    v10 = GetPixel(v9, 0, 0);
    DeleteDC(v9);
    DeleteObject(ho);
    SendMessageW(*(HWND *)(a1 + 8), 0x138u, (WPARAM)v8, *(_DWORD *)a1);
    v11 = GetBkColor(v8);
    ReleaseDC(*(HWND *)a1, v8);
    RleFile_ChangeColor(*(_DWORD *)(a1 + 20), v10, v11);
  }
  if ( *(_BYTE *)(a1 + 12) & 1 )
  {
    GetClientRect(*(HWND *)a1, &Rect);
    OffsetRect((LPRECT)(a1 + 48), (Rect.right - *(_DWORD *)(a1 + 56)) / 2, (Rect.bottom - *(_DWORD *)(a1 + 60)) / 2);
  }
  else
  {
    Rect.left = *(_DWORD *)(a1 + 48);
    Rect.top = *(_DWORD *)(a1 + 52);
    Rect.right = *(_DWORD *)(a1 + 56);
    v12 = *(HWND *)a1;
    Rect.bottom = *(_DWORD *)(a1 + 60);
    v13 = GetWindowLongW(v12, -20);
    v14 = GetWindowLongW(*(HWND *)a1, -16);
    AdjustWindowRectEx(&Rect, v14, 0, v13);
    SetWindowPos(*(HWND *)a1, 0, 0, 0, Rect.right - Rect.left, Rect.bottom - Rect.top, 0x16u);
  }
  if ( *(_BYTE *)(a1 + 12) & 4 )
    PostMessageW(*(HWND *)a1, 0x465u, 0xFFFFFFFF, -65536);
  else
    InvalidateRect(*(HWND *)a1, 0, 1);
  return 1;
}

//----- (6F7B5B7D) --------------------------------------------------------
DWORD __stdcall PlayThread(LPVOID lpThreadParameter)
{
  int i; // eax@1
  void *v2; // ecx@2
  bool v3; // sf@3
  DWORD v4; // eax@3
  DWORD v5; // eax@6

  DoNotify((int)lpThreadParameter, 1u);
  for ( i = HandleTick((LPCRITICAL_SECTION)lpThreadParameter); i; i = HandleTick((LPCRITICAL_SECTION)lpThreadParameter) )
  {
    v2 = (void *)*((_DWORD *)lpThreadParameter + 23);
    if ( v2 )
    {
      v3 = i < 0;
      v4 = *((_DWORD *)lpThreadParameter + 17);
      if ( v3 )
        v4 += 4000;
      WaitForSingleObject(v2, v4);
    }
    else
    {
      v3 = i < 0;
      v5 = *((_DWORD *)lpThreadParameter + 17);
      if ( v3 )
        v5 += 4000;
      Sleep(v5);
    }
  }
  DoNotify((int)lpThreadParameter, 2u);
  return 0;
}

//----- (6F7B5BE7) --------------------------------------------------------
int __stdcall HandlePlay(LPVOID lpParameter, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@3
  int v6; // edx@3
  int v7; // eax@5
  int v8; // ecx@11
  UINT_PTR v9; // eax@17
  int result; // eax@21

  v4 = (int)lpParameter;
  if ( lpParameter && *((_DWORD *)lpParameter + 5) )
  {
    HandleStop((int)lpParameter);
    v5 = *(_DWORD *)(v4 + 64);
    v6 = a2;
    if ( a2 >= v5 )
      v6 = v5 - 1;
    v7 = a3;
    if ( a3 == -1 )
      v7 = v5 - 1;
    if ( v7 < 0 )
      v7 = 0;
    if ( v7 >= v5 )
      v7 = v5 - 1;
    v8 = a4;
    *(_DWORD *)(v4 + 76) = a4;
    *(_DWORD *)(v4 + 84) = v7;
    if ( v6 < 0 )
    {
      v6 = *(_DWORD *)(v4 + 80);
    }
    else
    {
      *(_DWORD *)(v4 + 72) = v6;
      *(_DWORD *)(v4 + 80) = v6;
    }
    if ( v6 != v7 && v8 )
    {
      InvalidateRect(*(HWND *)v4, 0, 0);
      UpdateWindow(*(HWND *)v4);
      if ( *(_BYTE *)(v4 + 12) & 8 )
      {
        DoNotify(v4, 1u);
        v9 = SetTimer(*(HWND *)v4, 0x2Au, *(_DWORD *)(v4 + 68), 0);
      }
      else
      {
        *(_DWORD *)(v4 + 92) = CreateEventW(0, 0, 0, 0);
        v9 = (UINT_PTR)CreateThread(0, 0, PlayThread, (LPVOID)v4, 0, (LPDWORD)&lpParameter);
      }
      *(_DWORD *)(v4 + 88) = v9;
    }
    else
    {
      InvalidateRect(*(HWND *)v4, 0, 1);
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B5CC1) --------------------------------------------------------
int __stdcall HandleFirstPaint(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)(a1 + 16) )
  {
    *(_DWORD *)(a1 + 16) = 0;
    if ( !*(_DWORD *)(a1 + 64) )
    {
      if ( *(_DWORD *)(a1 + 12) & 0x40000000 )
        result = HandleOpen(a1, 0, 0, 42);
    }
  }
  return result;
}

//----- (6F7B5D0C) --------------------------------------------------------
int __stdcall AnimateWndProc(HWND hWnd, UINT Msg, int a3, LPCSTR lpMultiByteStr)
{
  HWND v4; // ebx@1
  int v5; // esi@1
  HDC v7; // eax@15
  int v8; // ebx@17
  __int64 v9; // rax@17
  int v10; // eax@19
  UINT_PTR v11; // eax@22
  void *v12; // ebx@33
  HLOCAL v13; // eax@40
  LONG v14; // esi@40
  struct tagPAINTSTRUCT Paint; // [sp+14h] [bp-24Ch]@15
  WCHAR WideCharStr; // [sp+54h] [bp-20Ch]@33

  v4 = hWnd;
  v5 = GetWindowLongW(hWnd, 0);
  if ( Msg == 16 )
  {
    SendMessageW(hWnd, 0x466u, 0, 0);
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  }
  if ( Msg == 61 )
  {
    if ( lpMultiByteStr == (LPCSTR)-12 )
      return 65550;
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  }
  if ( Msg == 129 )
  {
    v13 = LocalAlloc(0x40u, 0x60u);
    v14 = (LONG)v13;
    if ( !v13 )
      return 0;
    *(_DWORD *)v13 = hWnd;
    *((_DWORD *)v13 + 2) = *((_DWORD *)lpMultiByteStr + 3);
    *((_DWORD *)v13 + 1) = *((_DWORD *)lpMultiByteStr + 2);
    *((_DWORD *)v13 + 4) = 1;
    *((_DWORD *)v13 + 3) = *((_DWORD *)lpMultiByteStr + 8);
    InitializeCriticalSection((LPCRITICAL_SECTION)v13 + 1);
    SetWindowLongW(hWnd, 0, v14);
    SetWindowBits(hWnd, -20, 0x400000, 0);
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  }
  if ( Msg == 132 )
    return -1;
  if ( !v5 )
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  if ( Msg <= 0x113 )
  {
    switch ( Msg )
    {
      case 0x113u:
        v10 = HandleTick((LPCRITICAL_SECTION)v5);
        if ( v10 )
        {
          if ( v10 >= 0 )
            v11 = SetTimer(*(HWND *)v5, 0x2Au, *(_DWORD *)(v5 + 68), 0);
          else
            v11 = SetTimer(*(HWND *)v5, 0x2Au, *(_DWORD *)(v5 + 68) + 4000, 0);
          *(_DWORD *)(v5 + 88) = v11;
        }
        else
        {
          HandleStop(v5);
        }
        break;
      case 2u:
        SendMessageW(hWnd, 0x467u, 0, 0);
        DeleteCriticalSection((LPCRITICAL_SECTION)(v5 + 24));
        LocalFree((HLOCAL)v5);
        SetWindowLongW(hWnd, 0, 0);
        break;
      case 5u:
        if ( *(_BYTE *)(v5 + 12) & 1 )
        {
          v8 = *(_DWORD *)(v5 + 52);
          v9 = (signed int)(v8 + ((unsigned int)lpMultiByteStr >> 16) - *(_DWORD *)(v5 + 60));
          OffsetRect(
            (LPRECT)(v5 + 48),
            (*(_DWORD *)(v5 + 48) + (unsigned __int16)lpMultiByteStr - *(_DWORD *)(v5 + 56)) / 2 - *(_DWORD *)(v5 + 48),
            (((signed int)v9 - HIDWORD(v9)) >> 1) - v8);
          InvalidateRect(hWnd, 0, 1);
          v4 = hWnd;
        }
        break;
      default:
        if ( Msg == 15 )
        {
          HandleFirstPaint(v5);
          v7 = BeginPaint(hWnd, &Paint);
          HandlePaint(v5, v7);
          EndPaint(hWnd, &Paint);
          return 0;
        }
        if ( Msg == 20 )
        {
          HandleErase(v5, a3);
          return 1;
        }
        if ( Msg == 125 )
        {
          Ani_OnStyleChanged(v5, a3, (int)lpMultiByteStr);
          return 0;
        }
        break;
    }
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  }
  if ( Msg == 792 )
  {
    HandlePrint(v5, a3);
    return 0;
  }
  if ( Msg != 1124 )
  {
    if ( Msg == 1125 )
      return HandlePlay((LPVOID)v5, (signed __int16)lpMultiByteStr, SHIWORD(lpMultiByteStr), a3);
    if ( Msg == 1126 )
      return HandleStop(v5);
    if ( Msg == 1127 )
      return HandleOpen(v5, a3, (LPCWSTR)lpMultiByteStr, 0);
    return DefWindowProcW(v4, Msg, a3, (LPARAM)lpMultiByteStr);
  }
  v12 = &WideCharStr;
  if ( (unsigned int)lpMultiByteStr & 0xFFFF0000 )
    MultiByteToWideChar(0, 0, lpMultiByteStr, -1, &WideCharStr, 260);
  else
    v12 = (void *)lpMultiByteStr;
  return HandleOpen(v5, a3, (LPCWSTR)v12, 0);
}
// 6F7B5CF4: using guessed type _DWORD __stdcall HandlePrint(_DWORD, _DWORD);

//----- (6F7B5FED) --------------------------------------------------------
int __stdcall SetHotKey(HWND hWnd, __int16 a2, __int16 a3, int a4)
{
  int result; // eax@2
  int v5; // ST08_4@4
  HWND v6; // eax@4

  if ( (unsigned __int16)a2 != GetWindowLongW(hWnd, 0)
    || (result = GetWindowLongW(hWnd, 4), (unsigned __int16)a3 != result) )
  {
    SetWindowLongW(hWnd, 0, (unsigned __int16)a2);
    SetWindowLongW(hWnd, 4, (unsigned __int16)a3);
    InvalidateRect(hWnd, 0, 1);
    if ( a4 )
    {
      v5 = (unsigned __int16)GetDlgCtrlID(hWnd) | 0x3000000;
      v6 = GetParent(hWnd);
      SendMessageW(v6, 0x111u, v5, (LPARAM)hWnd);
    }
    result = MyNotifyWinEvent(32782, (int)hWnd, -4, 0);
  }
  return result;
}

//----- (6F7B607C) --------------------------------------------------------
int __stdcall GetKeyName(UINT uCode, LPWSTR lpString, int cchSize, int a4)
{
  LONG v4; // eax@1
  int result; // eax@4

  v4 = MapVirtualKeyW(uCode, 0) << 16;
  if ( a4 )
    v4 |= 0x1000000u;
  if ( cchSize )
    result = GetKeyNameTextW(v4, lpString, cchSize);
  else
    result = 0;
  return result;
}

//----- (6F7B60BA) --------------------------------------------------------
LONG __stdcall HKMSetRules(HWND hWnd, LONG dwNewLong, LONG a3)
{
  SetWindowLongW(hWnd, 8, dwNewLong);
  return SetWindowLongW(hWnd, 12, a3);
}

//----- (6F7B60E4) --------------------------------------------------------
LONG __stdcall HKMSetFont(HWND hWnd, LONG dwNewLong)
{
  HWND v2; // edi@1
  LONG v3; // ebx@1
  HDC v4; // eax@1
  LONG v6; // [sp+Ch] [bp-8h]@1
  LONG v7; // [sp+10h] [bp-4h]@3
  HWND hWnda; // [sp+1Ch] [bp+8h]@1

  v2 = hWnd;
  v3 = dwNewLong;
  v6 = GetWindowLongW(hWnd, 16);
  SetWindowLongW(hWnd, 16, dwNewLong);
  v4 = GetDC(hWnd);
  hWnda = (HWND)v4;
  if ( dwNewLong )
    v3 = (LONG)SelectObject(v4, (HGDIOBJ)dwNewLong);
  MGetTextExtent((HDC)hWnda, L"C", 1, 0, (int)&v7);
  SetWindowLongW(v2, 20, v7);
  if ( v3 )
    SelectObject((HDC)hWnda, (HGDIOBJ)v3);
  ReleaseDC(v2, (HDC)hWnda);
  InvalidateRect(v2, 0, 1);
  return v6;
}

//----- (6F7B6179) --------------------------------------------------------
HRESULT __stdcall StringCchCatW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_LPCWSTR pszSrc)
{
  size_t v3; // ecx@1
  HRESULT result; // eax@1
  HRESULT v5; // ebx@5
  size_t v6; // edx@5
  STRSAFE_LPWSTR v7; // eax@5
  size_t v8; // edx@13
  wchar_t *v9; // eax@13
  HRESULT v10; // ebx@13
  size_t v11; // edi@14
  char *v12; // esi@14
  wchar_t v13; // cx@16

  v3 = 0;
  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v5 = 0;
    v6 = cchDest;
    v7 = pszDest;
    if ( !cchDest )
      goto LABEL_23;
    do
    {
      if ( !*v7 )
        break;
      ++v7;
      --v6;
    }
    while ( v6 );
    if ( v6 )
      v3 = cchDest - v6;
    else
LABEL_23:
      v5 = -2147024809;
    result = v5;
  }
  if ( result >= 0 )
  {
    v8 = cchDest - v3;
    v9 = &pszDest[v3];
    v10 = 0;
    if ( cchDest == v3 )
      goto LABEL_24;
    v11 = v8 - cchDest + v3 + 0x7FFFFFFF;
    v12 = (char *)((char *)pszSrc - (char *)v9);
    do
    {
      if ( !v11 )
        break;
      v13 = *(wchar_t *)((char *)v9 + (_DWORD)v12);
      if ( !v13 )
        break;
      *v9 = v13;
      ++v9;
      --v8;
      --v11;
    }
    while ( v8 );
    if ( !v8 )
    {
LABEL_24:
      --v9;
      v10 = -2147024774;
    }
    *v9 = 0;
    result = v10;
  }
  return result;
}

//----- (6F7B621B) --------------------------------------------------------
BOOL __stdcall PaintHotKey(HWND hWnd)
{
  HWND v1; // esi@1
  int v2; // eax@1
  int v3; // eax@7
  int v4; // eax@9
  int v5; // eax@10
  HDC v6; // ebx@11
  LONG v7; // eax@11
  int v8; // edi@11
  LONG uCode; // [sp+10h] [bp-164h]@1
  int x; // [sp+14h] [bp-160h]@11
  int c; // [sp+18h] [bp-15Ch]@1
  struct tagPAINTSTRUCT Paint; // [sp+1Ch] [bp-158h]@11
  wchar_t pszDest[128]; // [sp+5Ch] [bp-118h]@3
  wchar_t pszSrc; // [sp+15Ch] [bp-18h]@1

  v1 = hWnd;
  LocalizedLoadString(1025, &pszSrc, 10);
  uCode = GetWindowLongW(hWnd, 0);
  v2 = GetWindowLongW(hWnd, 4);
  c = v2;
  if ( uCode || v2 )
  {
    pszDest[0] = 0;
    if ( v2 & 2 )
    {
      GetKeyName(0x11u, pszDest, 128, 0);
      StringCchCatW(pszDest, 0x80u, &pszSrc);
    }
    if ( c & 1 )
    {
      v3 = lstrlenW(pszDest);
      GetKeyName(0x10u, &pszDest[v3], 128 - v3, 0);
      StringCchCatW(pszDest, 0x80u, &pszSrc);
    }
    if ( c & 4 )
    {
      v4 = lstrlenW(pszDest);
      GetKeyName(0x12u, &pszDest[v4], 128 - v4, 0);
      StringCchCatW(pszDest, 0x80u, &pszSrc);
    }
    v5 = lstrlenW(pszDest);
    GetKeyName(uCode, &pszDest[v5], 128 - v5, c & 8);
    v1 = hWnd;
  }
  else
  {
    LocalizedLoadString(1026, pszDest, 128);
  }
  c = lstrlenW(pszDest);
  HideCaret(v1);
  InvalidateRect(v1, 0, 1);
  v6 = BeginPaint(v1, &Paint);
  v7 = GetWindowLongW(v1, 16);
  SelectObject(v6, (HGDIOBJ)v7);
  v8 = g_cyBorder;
  x = g_cxBorder;
  if ( IsWindowEnabled(v1) )
  {
    SetBkColor(v6, g_clrWindow);
    SetTextColor(v6, g_clrWindowText);
LABEL_15:
    TextOutW(v6, x, v8, pszDest, c);
    goto LABEL_17;
  }
  SetBkColor(v6, g_clrBtnFace);
  if ( g_clrGrayText )
  {
    SetTextColor(v6, g_clrGrayText);
    goto LABEL_15;
  }
  GrayStringW(v6, 0, 0, (LPARAM)pszDest, c, x, v8, 0, 0);
LABEL_17:
  MGetTextExtent(v6, pszDest, c, (int)&x, 0);
  if ( GetFocus() == v1 )
    SetCaretPos(x + g_cxBorder, g_cyBorder);
  ShowCaret(v1);
  return EndPaint(v1, &Paint);
}
// 6F7B621B: using guessed type wchar_t pszDest[128];

//----- (6F7B64A1) --------------------------------------------------------
int __stdcall HotKeyWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax@1
  int v5; // eax@14
  HDC v6; // edi@26
  __int16 v7; // di@39
  __int16 v8; // bx@46
  int v9; // edi@77
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@26

  result = 129;
  if ( Msg <= 0x81 )
  {
    if ( Msg == 129 )
    {
      SetWindowBits(hWnd, -20, 512, 512);
      CCCreateWindow();
      InitGlobalColors();
    }
    else
    {
      if ( Msg <= 0xF )
      {
        switch ( Msg )
        {
          case 0xFu:
            PaintHotKey(hWnd);
            break;
          case 1u:
            SetHotKey(hWnd, 0, 0, 0);
            HKMSetRules(hWnd, 0, 0);
            HKMSetFont(hWnd, (LONG)g_hfontSystem);
            break;
          case 2u:
            CCDestroyWindow();
            break;
          case 7u:
            InvalidateRect(hWnd, 0, 1);
            v5 = GetWindowLongW(hWnd, 20);
            CreateCaret(hWnd, 0, 0, v5);
            ShowCaret(hWnd);
            break;
          default:
            if ( Msg != 8 )
            {
              if ( Msg == 10 )
                InvalidateRect(hWnd, 0, 1);
              return DefWindowProcW(hWnd, Msg, wParam, lParam);
            }
            if ( !GetWindowLongW(hWnd, 0) )
              SetHotKey(hWnd, 0, 0, 1);
            DestroyCaret();
            break;
        }
        return 0;
      }
      if ( Msg != 20 )
      {
        if ( Msg == 48 )
          return HKMSetFont(hWnd, wParam);
        if ( Msg == 49 )
          return GetWindowLongW(hWnd, 16);
        if ( Msg == 61 && lParam == -12 )
          return 65552;
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      }
      HideCaret(hWnd);
      v6 = GetDC(hWnd);
      GetClientRect(hWnd, &Rect);
      if ( IsWindowEnabled(hWnd) )
        FillRect(v6, &Rect, g_hbrWindow);
      else
        FillRect(v6, &Rect, g_hbrBtnFace);
      ReleaseDC(hWnd, v6);
      ShowCaret(hWnd);
    }
    return 1;
  }
  if ( Msg > 0x106 )
  {
    if ( Msg == 513 )
    {
      SetFocus(hWnd);
    }
    else if ( Msg == 1025 )
    {
      SetHotKey(hWnd, (unsigned __int8)wParam, BYTE1(wParam), 0);
    }
    else
    {
      if ( Msg == 1026 )
      {
        v9 = (unsigned __int8)GetWindowLongW(hWnd, 4) << 8;
        return v9 + (unsigned __int8)GetWindowLongW(hWnd, 0);
      }
      if ( Msg != 1027 )
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
      HKMSetRules(hWnd, wParam, (unsigned __int16)lParam);
    }
    return 0;
  }
  if ( Msg >= 0x105 )
    goto LABEL_69;
  if ( Msg == 135 )
    return result;
  if ( Msg == 256 )
  {
LABEL_39:
    v7 = 0;
    if ( wParam > 0x1B )
    {
      if ( wParam != 32 && wParam != 46 && (wParam <= 0x5A || wParam > 0x5D) )
        goto LABEL_51;
    }
    else if ( wParam != 27 )
    {
      if ( wParam < 8 )
        goto LABEL_51;
      if ( wParam > 9 && wParam != 13 )
      {
        if ( wParam > 0xF && wParam <= 0x12 )
        {
          v8 = 0;
LABEL_52:
          if ( GetKeyState(17) < 0 )
            v7 = 2;
          if ( GetKeyState(16) < 0 )
            v7 |= 1u;
          if ( GetKeyState(18) < 0 )
            v7 |= 4u;
          if ( ((unsigned __int16)v8 < 0x70u || (unsigned __int16)v8 > 0x87u)
            && ((unsigned __int16)v8 < 0x60u || (unsigned __int16)v8 > 0x6Fu)
            && GetWindowLongW(hWnd, 8) & s_Combos[(unsigned __int16)v7] )
            v7 = GetWindowLongW(hWnd, 12);
          if ( lParam & 0x1000000 )
            v7 |= 8u;
          SetHotKey(hWnd, v8, v7, 1);
          return 0;
        }
LABEL_51:
        v8 = wParam;
        goto LABEL_52;
      }
    }
    SetHotKey(hWnd, 0, 0, 1);
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
  if ( Msg > 0x100 )
  {
    if ( Msg > 0x102 )
    {
      if ( Msg == 260 )
        goto LABEL_39;
      return DefWindowProcW(hWnd, Msg, wParam, lParam);
    }
LABEL_69:
    if ( !GetWindowLongW(hWnd, 0) )
      SetHotKey(hWnd, 0, 0, 1);
    return 0;
  }
  return DefWindowProcW(hWnd, Msg, wParam, lParam);
}
// 6F7B6838: using guessed type int s_Combos[];

//----- (6F7B685D) --------------------------------------------------------
int __stdcall UpdatePosition(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // ecx@1
  int v5; // edi@1
  UINT v6; // eax@1
  int v7; // edx@1
  bool v8; // zf@12
  int v9; // ST00_4@15
  int v11; // [sp+14h] [bp+8h]@1

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a1 + 8);
  v11 = *(_DWORD *)(a1 + 16);
  v6 = 257;
  v7 = v5;
  if ( v5 != v4 )
    v7 = a2;
  if ( v7 >= v5 )
  {
    if ( v7 <= v4 )
      goto LABEL_12;
    if ( !a3 )
    {
      v7 = v4;
      goto LABEL_12;
    }
    v7 = v5 + (v7 - v4) % (v4 - v5);
  }
  else
  {
    if ( !a3 )
    {
      v7 = v5;
      goto LABEL_12;
    }
    v7 = v4 - (v5 - v7) % (v4 - v5);
  }
  v6 = 261;
LABEL_12:
  v8 = v7 == v11;
  if ( v7 < v11 )
  {
    v6 |= 4u;
    v8 = v7 == v11;
  }
  if ( !v8 )
  {
    v9 = *(_DWORD *)v3;
    *(_DWORD *)(v3 + 16) = v7;
    RedrawWindow((HWND)v9, 0, 0, v6);
    MyNotifyWinEvent(32782, *(_DWORD *)v3, -4, 0);
  }
  return v11;
}

//----- (6F7B6906) --------------------------------------------------------
LONG __stdcall ProPaint(int a1, HDC a2)
{
  HDC v2; // eax@1
  bool v3; // zf@3
  LONG v4; // edi@4
  LONG v5; // ecx@4
  LONG v6; // eax@4
  int v7; // esi@6
  int v8; // eax@6
  signed int v9; // edi@6
  LONG result; // eax@10
  int v11; // [sp+4h] [bp-74h]@10
  struct tagRECT Rect; // [sp+Ch] [bp-6Ch]@3
  RECT rect; // [sp+1Ch] [bp-5Ch]@3
  int v14; // [sp+2Ch] [bp-4Ch]@10
  HDC hdc; // [sp+30h] [bp-48h]@3
  struct tagPAINTSTRUCT Paint; // [sp+34h] [bp-44h]@2

  v2 = a2;
  if ( !a2 )
    v2 = BeginPaint(*(HWND *)a1, &Paint);
  hdc = v2;
  GetClientRect(*(HWND *)a1, &Rect);
  InflateRect(&Rect, -1, -1);
  v3 = (*(_BYTE *)(a1 + 4) & 4) == 0;
  rect = Rect;
  if ( v3 )
  {
    v4 = Rect.left;
    v5 = Rect.right;
    v6 = Rect.bottom - Rect.top;
  }
  else
  {
    v4 = Rect.top;
    v5 = Rect.bottom;
    v6 = Rect.right - Rect.left;
  }
  v7 = 2 * v6 / 3;
  v8 = MulDiv(v5 - v4, *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8));
  v9 = 2;
  if ( !v7 )
    v7 = 1;
  if ( *(_BYTE *)(a1 + 4) & 1 )
  {
    v7 = 1;
    v9 = 0;
  }
  result = (v9 + v8 + v7 - 1) / (v9 + v7);
  v14 = 0;
  v11 = result;
  if ( result > 0 )
  {
    result = rect.bottom;
    do
    {
      if ( *(_BYTE *)(a1 + 4) & 4 )
      {
        rect.top = result - v7;
        if ( result <= Rect.top )
          break;
        if ( result - v7 <= Rect.top )
          rect.top = Rect.top + 1;
      }
      else
      {
        result = rect.left + v7;
        rect.right = rect.left + v7;
        if ( rect.left >= Rect.right )
          break;
        if ( result >= Rect.right )
          rect.right = Rect.right - 1;
      }
      if ( *(_DWORD *)(a1 + 32) == -16777216 )
        FillRectClr(hdc, &rect, g_clrHighlight);
      else
        FillRectClr(hdc, &rect, *(_DWORD *)(a1 + 32));
      if ( *(_BYTE *)(a1 + 4) & 4 )
      {
        result = rect.top - v9;
        rect.bottom = rect.top - v9;
      }
      else
      {
        rect.left = v9 + rect.right;
        result = rect.bottom;
      }
      ++v14;
    }
    while ( v14 < v11 );
  }
  if ( !a2 )
    result = EndPaint(*(HWND *)a1, &Paint);
  return result;
}

//----- (6F7B6A6D) --------------------------------------------------------
int __stdcall TBLogToPhys(int a1, int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // esi@3
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(_DWORD *)(a1 + 44);
  if ( v2 == v3 )
  {
    result = *(_DWORD *)(a1 + 76);
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 76);
    result = v4 + MulDiv(a2 - v3, *(_DWORD *)(a1 + 72) - 1, v2 - v3);
  }
  return result;
}

//----- (6F7B6AA7) --------------------------------------------------------
int __stdcall TBPhysToLog(int a1, int a2)
{
  signed int v2; // ecx@1
  int v3; // edx@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 72);
  v3 = *(_DWORD *)(a1 + 76);
  if ( v2 <= 1 || a2 <= v3 )
  {
    result = *(_DWORD *)(a1 + 44);
  }
  else if ( a2 < *(_DWORD *)(a1 + 84) )
  {
    result = *(_DWORD *)(a1 + 44) + MulDiv(a2 - v3, *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 44), v2 - 1);
  }
  else
  {
    result = *(_DWORD *)(a1 + 48);
  }
  return result;
}

//----- (6F7B6AF0) --------------------------------------------------------
int __stdcall TBFlipPoint(int a1, int a2)
{
  int result; // eax@1

  result = a1;
  if ( *(_BYTE *)(a1 + 8) & 2 )
    result = FlipPoint(a2);
  return result;
}

//----- (6F7B6B0F) --------------------------------------------------------
BOOL __stdcall PatRect(HDC hdc, int a2, int a3, int a4, int a5, int a6)
{
  bool v6; // zf@1
  RECT rect; // [sp+0h] [bp-10h]@1

  rect.left = a2;
  rect.right = a4 + a2;
  rect.top = a3;
  v6 = (*(_BYTE *)(a6 + 8) & 2) == 0;
  rect.bottom = a5 + a3;
  if ( !v6 )
    FlipRect((int)&rect);
  return ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
}

//----- (6F7B6B64) --------------------------------------------------------
BOOL __stdcall VertInvalidateRect(HWND hWnd, int a2, BOOL bErase, int a4)
{
  RECT Rect; // [sp+8h] [bp-10h]@1

  Rect.left = *(_DWORD *)a2;
  Rect.top = *(_DWORD *)(a2 + 4);
  Rect.right = *(_DWORD *)(a2 + 8);
  Rect.bottom = *(_DWORD *)(a2 + 12);
  if ( a4 )
    FlipRect((int)&Rect);
  return InvalidateRect(hWnd, &Rect, bErase);
}

//----- (6F7B6BA2) --------------------------------------------------------
int __stdcall VertPatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop, int a7)
{
  int result; // eax@2

  if ( a7 )
    result = PatBlt(hdc, y, x, h, w, rop);
  else
    result = PatBlt(hdc, x, y, w, h, rop);
  return result;
}

//----- (6F7B6BDC) --------------------------------------------------------
int __stdcall DrawTic(int a1, int a2, int a3, int a4)
{
  if ( a4 == -1 )
    a3 -= 3;
  SetBkColor(*(HDC *)(a1 + 36), g_clrBtnText);
  return PatRect(*(HDC *)(a1 + 36), a2, a3, 1, 3, a1);
}

//----- (6F7B6C1B) --------------------------------------------------------
int __stdcall DrawTicsOneLine(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@1
  int result; // eax@1
  int v7; // ecx@1
  int v8; // eax@5
  int v9; // eax@10
  int v10; // ebx@10
  signed int v11; // eax@12
  signed int v12; // ebx@15
  signed int v13; // eax@17
  int v14; // [sp+14h] [bp+8h]@1
  int v15; // [sp+14h] [bp+8h]@10
  int v16; // [sp+14h] [bp+8h]@15
  int v17; // [sp+1Ch] [bp+10h]@4
  int v18; // [sp+1Ch] [bp+10h]@10
  int v19; // [sp+1Ch] [bp+10h]@15

  v3 = a2;
  v4 = a1;
  v5 = a3;
  DrawTic(a1, *(_DWORD *)(a1 + 76), a3, a2);
  DrawTic(v4, *(_DWORD *)(v4 + 76), a3 + v3, v3);
  DrawTic(v4, *(_DWORD *)(v4 + 84) - 1, a3, a2);
  DrawTic(v4, *(_DWORD *)(v4 + 84) - 1, a3 + v3, v3);
  result = *(_DWORD *)(a1 + 120);
  v7 = 0;
  v14 = *(_DWORD *)(a1 + 120);
  if ( *(_DWORD *)(v4 + 124) && result && *(_DWORD *)(v4 + 116) > 0 )
  {
    do
    {
      v17 = v7 + 1;
      result = (v7 + 1) / *(_DWORD *)(v4 + 124);
      if ( !((v7 + 1) % *(_DWORD *)(v4 + 124)) )
      {
        v8 = TBLogToPhys(v4, *(_DWORD *)(v14 + 4 * v7));
        result = DrawTic(v4, v8, v5, a2);
      }
      v7 = v17;
    }
    while ( v17 < *(_DWORD *)(v4 + 116) );
  }
  if ( *(_BYTE *)(v4 + 148) & 2 )
  {
    result = *(_DWORD *)(v4 + 60);
    if ( *(_DWORD *)(v4 + 56) <= result && result >= *(_DWORD *)(v4 + 44) )
    {
      SetBkColor(*(HDC *)(v4 + 36), g_clrBtnText);
      v9 = TBLogToPhys(v4, *(_DWORD *)(v4 + 56));
      v15 = 0;
      v18 = 3 - v9;
      v10 = v9;
      do
      {
        if ( a2 == 1 )
          v11 = v15;
        else
          v11 = -3;
        PatRect(*(HDC *)(v4 + 36), v10, v5 + v11, 1, v10 + v18, v4);
        ++v15;
        --v10;
      }
      while ( v15 < 3 );
      v19 = TBLogToPhys(v4, *(_DWORD *)(v4 + 60));
      v12 = 0;
      v16 = 3;
      do
      {
        if ( a2 == 1 )
          v13 = v12;
        else
          v13 = -3;
        result = PatRect(*(HDC *)(v4 + 36), v12++ + v19, v5 + v13, 1, v16--, v4);
      }
      while ( v16 > 0 );
    }
  }
  return result;
}

//----- (6F7B6D69) --------------------------------------------------------
int __stdcall DrawTics(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 8);
  if ( !(result & 0x10) )
  {
    if ( result & 8 || !(result & 4) )
      result = DrawTicsOneLine(a1, 1, *(_DWORD *)(a1 + 88) + 1);
    if ( *(_BYTE *)(a1 + 8) & 0xC )
      result = DrawTicsOneLine(a1, -1, *(_DWORD *)(a1 + 80) - 1);
  }
  return result;
}

//----- (6F7B6DAB) --------------------------------------------------------
void __stdcall GetChannelRect(int a1, int a2)
{
  int v2; // eax@2
  int v3; // edi@3
  __int64 v4; // rax@5
  int v5; // eax@5
  int v6; // ecx@5
  int v7; // eax@7

  if ( a2 )
  {
    v2 = *(_DWORD *)(a1 + 76) - *(_DWORD *)(a1 + 64) / 2;
    *(_DWORD *)a2 = v2;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 64) + *(_DWORD *)(a1 + 72) + v2 - 1;
    if ( *(_BYTE *)(a1 + 8) & 0x20 )
      v3 = 3 * (*(_DWORD *)(a1 + 68) / 4);
    else
      v3 = 4;
    v4 = *(_DWORD *)(a1 + 80) + *(_DWORD *)(a1 + 88) - v3;
    v5 = ((signed int)v4 - HIDWORD(v4)) >> 1;
    *(_DWORD *)(a2 + 4) = v5;
    v6 = *(_DWORD *)(a1 + 8);
    if ( !(v6 & 8) )
    {
      if ( v6 & 4 )
        v7 = v5 + 1;
      else
        v7 = v5 - 1;
      *(_DWORD *)(a2 + 4) = v7;
    }
    *(_DWORD *)(a2 + 12) = v3 + *(_DWORD *)(a2 + 4);
  }
}

//----- (6F7B6E2D) --------------------------------------------------------
int __stdcall DrawChannel(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  int v4; // ecx@2
  int v5; // ebx@4
  int v6; // [sp+10h] [bp+8h]@4

  v2 = a1;
  VertDrawEdge(*(HDC *)(a1 + 36), a2, 0xAu, 0xFu, *(_DWORD *)(a1 + 8) & 2);
  SetBkColor(*(HDC *)(a1 + 36), g_clrBtnHighlight);
  result = PatRect(
             *(HDC *)(v2 + 36),
             *(_DWORD *)a2 + 2,
             *(_DWORD *)(a2 + 4) + 2,
             *(_DWORD *)(a2 + 8) - *(_DWORD *)a2 - 4,
             *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4) - 4,
             v2);
  if ( *(_BYTE *)(a1 + 148) & 2 )
  {
    v4 = *(_DWORD *)(a1 + 56);
    result = *(_DWORD *)(a1 + 60);
    if ( v4 <= result && result > *(_DWORD *)(a1 + 44) )
    {
      v6 = TBLogToPhys(a1, v4);
      v5 = TBLogToPhys(v2, *(_DWORD *)(v2 + 60));
      result = v6 + 2;
      if ( v6 + 2 <= v5 )
      {
        SetBkColor(*(HDC *)(v2 + 36), g_clrHighlight);
        result = PatRect(
                   *(HDC *)(v2 + 36),
                   v6 + 1,
                   *(_DWORD *)(a2 + 4) + 3,
                   v5 - v6 - 1,
                   *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4) - 6,
                   v2);
      }
    }
  }
  return result;
}

//----- (6F7B6EFA) --------------------------------------------------------
void __stdcall DrawThumb(int y, UINT a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  bool v5; // zf@1
  int v6; // ecx@2
  int v7; // eax@4
  LONG v8; // edx@4
  signed int v9; // edi@12
  int v10; // ecx@22
  UINT v11; // eax@24
  HDC v12; // ST08_4@26
  struct tagRECT rc; // [sp+Ch] [bp-24h]@1
  HGDIOBJ h; // [sp+1Ch] [bp-14h]@16
  UINT grfFlags; // [sp+20h] [bp-10h]@5
  LONG v16; // [sp+24h] [bp-Ch]@1
  int x; // [sp+28h] [bp-8h]@1
  int v18; // [sp+2Ch] [bp-4h]@1
  int ya; // [sp+38h] [bp+8h]@13
  int yb; // [sp+38h] [bp+8h]@19
  int v21; // [sp+3Ch] [bp+Ch]@13
  UINT v22; // [sp+3Ch] [bp+Ch]@18
  signed int v23; // [sp+3Ch] [bp+Ch]@24

  rc.left = *(_DWORD *)a2;
  rc.top = *(_DWORD *)(a2 + 4);
  rc.right = *(_DWORD *)(a2 + 8);
  v3 = 0;
  rc.bottom = *(_DWORD *)(a2 + 12);
  v4 = y;
  v5 = (*(_BYTE *)(y + 148) & 1) == 0;
  v18 = 0;
  v16 = 0;
  x = 0;
  if ( v5 )
  {
    v6 = *(_DWORD *)(y + 8);
    if ( (char)v6 >= 0 )
    {
      if ( v6 & 8 )
      {
        grfFlags = 4111;
      }
      else
      {
        v7 = *(_DWORD *)(y + 68) / 2;
        v3 = (*(_DWORD *)(y + 64) - 3) / 2;
        v8 = v7 + rc.top;
        if ( v6 & 4 )
        {
          ++v8;
          v18 = -1;
          rc.top += v3 + 1;
          grfFlags = 4109;
        }
        else
        {
          rc.bottom += -1 - v3;
          v18 = 1;
          grfFlags = 4103;
        }
        v16 = v8 + v18 * v7;
        x = v3 + rc.left;
      }
      if ( a3 || !IsWindowEnabled(*(HWND *)y) )
      {
        h = SelectObject(*(HDC *)(y + 36), g_hbrMonoDither);
        if ( h )
        {
          SetTextColor(*(HDC *)(y + 36), g_clrBtnHighlight);
          SetBkColor(*(HDC *)(y + 36), g_clrBtnFace);
          VertPatBlt(
            *(HDC *)(y + 36),
            rc.left + 2,
            rc.top,
            rc.right - rc.left - 4,
            rc.bottom - rc.top,
            0xF00021u,
            *(_DWORD *)(y + 8) & 2);
          if ( !(*(_BYTE *)(y + 8) & 8) )
          {
            v22 = 1;
            if ( v3 >= 1 )
            {
              yb = v16 - v18;
              do
              {
                VertPatBlt(*(HDC *)(v4 + 36), x, yb, 2 * v22++, 1, 0xF00021u, *(_DWORD *)(v4 + 8) & 2);
                yb -= v18;
                --x;
              }
              while ( (signed int)v22 <= v3 );
            }
          }
          SelectObject(*(HDC *)(v4 + 36), h);
        }
      }
      else
      {
        SetBkColor(*(HDC *)(y + 36), g_clrBtnFace);
        PatRect(*(HDC *)(y + 36), rc.left + 2, rc.top, rc.right - rc.left - 4, rc.bottom - rc.top, y);
        if ( !(*(_BYTE *)(y + 8) & 8) )
        {
          v9 = 1;
          if ( v3 >= 1 )
          {
            ya = x;
            v21 = v16 - v18;
            do
            {
              PatRect(*(HDC *)(v4 + 36), ya, v21, 2 * v9, 1, v4);
              v21 -= v18;
              ++v9;
              --ya;
            }
            while ( v9 <= v3 );
          }
        }
      }
      VertDrawEdge(*(HDC *)(v4 + 36), (int)&rc, 5u, grfFlags, *(_DWORD *)(v4 + 8) & 2);
      v10 = *(_DWORD *)(v4 + 8);
      if ( !(v10 & 8) )
      {
        if ( v10 & 4 )
        {
          rc.bottom = rc.top + 1;
          rc.top = rc.top + 1 - v3 - 2;
          v11 = 4118;
          v23 = 28;
        }
        else
        {
          rc.top = rc.bottom - 1;
          rc.bottom = rc.bottom - 1 + v3 + 2;
          v11 = 4115;
          v23 = 25;
        }
        v12 = *(HDC *)(v4 + 36);
        rc.right = rc.left + v3 + 2;
        VertDrawEdge(v12, (int)&rc, 5u, v11, v10 & 2);
        OffsetRect(&rc, v3 + 1, 0);
        VertDrawEdge(*(HDC *)(v4 + 36), (int)&rc, 5u, v23, *(_DWORD *)(v4 + 8) & 2);
      }
    }
  }
}

//----- (6F7B71B3) --------------------------------------------------------
BOOL __stdcall TBInvalidateAll(int a1)
{
  BOOL result; // eax@1

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a1 + 140) |= 0xFu;
    result = InvalidateRect(*(HWND *)a1, 0, 0);
  }
  return result;
}

//----- (6F7B71DB) --------------------------------------------------------
int __stdcall MoveThumb(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // eax@3
  signed int v6; // edi@6
  int v7; // ecx@6
  int v8; // ST0C_4@6
  HWND v9; // ST00_4@6
  HWND v10; // ST0C_4@6
  int result; // eax@6
  int v12; // [sp+14h] [bp+8h]@1

  v2 = a1;
  v12 = *(_DWORD *)(a1 + 52);
  VertInvalidateRect(*(HWND *)v2, v2 + 92, 0, *(_DWORD *)(v2 + 8) & 2);
  v3 = *(_DWORD *)(v2 + 48);
  v4 = a2;
  if ( a2 >= v3 )
    v4 = *(_DWORD *)(v2 + 48);
  v5 = *(_DWORD *)(v2 + 44);
  if ( v4 > v5 )
  {
    v5 = a2;
    if ( a2 >= v3 )
      v5 = *(_DWORD *)(v2 + 48);
  }
  v6 = *(_DWORD *)(v2 + 64);
  *(_DWORD *)(v2 + 52) = v5;
  v7 = TBLogToPhys(v2, v5) - v6 / 2;
  v8 = *(_DWORD *)(v2 + 8) & 2;
  v9 = *(HWND *)v2;
  *(_DWORD *)(v2 + 92) = v7;
  *(_DWORD *)(v2 + 100) = v6 + v7;
  VertInvalidateRect(v9, v2 + 92, 0, v8);
  v10 = *(HWND *)v2;
  *(_DWORD *)(v2 + 140) |= 2u;
  UpdateWindow(v10);
  result = v12;
  if ( v12 != *(_DWORD *)(v2 + 52) )
    result = MyNotifyWinEvent(32782, *(_DWORD *)v2, -4, 0);
  return result;
}

//----- (6F7B7280) --------------------------------------------------------
HWND __stdcall DrawFocus(int a1, HBRUSH hbr)
{
  HWND result; // eax@1
  struct tagRECT Rect; // [sp+4h] [bp-10h]@3

  result = GetFocus();
  if ( *(HWND *)a1 == result )
  {
    result = (HWND)CCGetUIState(a1);
    if ( !((unsigned __int8)result & 1) )
    {
      SetBkColor(*(HDC *)(a1 + 36), g_clrBtnHighlight);
      GetClientRect(*(HWND *)a1, &Rect);
      if ( hbr )
        FrameRect(*(HDC *)(a1 + 36), &Rect, hbr);
      result = (HWND)DrawFocusRect(*(HDC *)(a1 + 36), &Rect);
    }
  }
  return result;
}

//----- (6F7B72E8) --------------------------------------------------------
void __stdcall DoAutoTics(int a1)
{
  int v1; // eax@4
  int v2; // ecx@7
  int v3; // eax@9

  if ( *(_BYTE *)(a1 + 8) & 1 )
  {
    if ( *(_DWORD *)(a1 + 120) )
      LocalFree(*(HLOCAL *)(a1 + 120));
    v1 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 44) - 1;
    *(_DWORD *)(a1 + 116) = v1;
    if ( v1 <= 0 )
      *(_DWORD *)(a1 + 120) = 0;
    else
      *(_DWORD *)(a1 + 120) = LocalAlloc(0x40u, 4 * v1);
    v2 = *(_DWORD *)(a1 + 120);
    if ( v2 )
    {
      v3 = *(_DWORD *)(a1 + 44);
      while ( 1 )
      {
        ++v3;
        if ( v3 >= *(_DWORD *)(a1 + 48) )
          break;
        *(_DWORD *)v2 = v3;
        v2 += 4;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 116) = 0;
    }
  }
}

//----- (6F7B734E) --------------------------------------------------------
int __stdcall ValidateThumbHeight(int a1)
{
  int v1; // esi@3
  int v2; // edx@3
  int result; // eax@3

  if ( *(_DWORD *)(a1 + 68) < 2 * g_cxEdge )
    *(_DWORD *)(a1 + 68) = 2 * g_cxEdge;
  v1 = *(_DWORD *)(a1 + 68);
  v2 = *(_DWORD *)(a1 + 8);
  result = *(_DWORD *)(a1 + 68) / 2 | 1;
  *(_DWORD *)(a1 + 64) = result;
  if ( v2 & 0x20 )
  {
    if ( v2 & 0x40 )
    {
      result = 9 * v1 / 20 | 1;
      *(_DWORD *)(a1 + 64) = result;
    }
    else
    {
      result = v1 + 2 * result / 9;
      *(_DWORD *)(a1 + 68) = result;
    }
  }
  return result;
}

//----- (6F7B73AF) --------------------------------------------------------
int __stdcall TBPositionBuddies(HWND hWndTo)
{
  int v1; // esi@1
  LONG v2; // edi@1
  HWND v3; // eax@3
  HWND v4; // ST18_4@6
  int result; // eax@7
  HWND v6; // ST18_4@10
  HWND v7; // edi@10
  struct tagRECT Rect; // [sp+Ch] [bp-28h]@1
  struct tagRECT v9; // [sp+1Ch] [bp-18h]@4
  struct tagPOINT Points; // [sp+2Ch] [bp-8h]@6
  HWND hWndToa; // [sp+3Ch] [bp+8h]@6

  v1 = (int)hWndTo;
  GetChannelRect((int)hWndTo, (int)&Rect);
  v2 = (Rect.bottom + Rect.top) / 2;
  GetClientRect(*(HWND *)hWndTo, &Rect);
  if ( *((_BYTE *)hWndTo + 8) & 2 )
    FlipRect((int)&Rect);
  v3 = (HWND)*((_DWORD *)hWndTo + 40);
  if ( v3 )
  {
    GetClientRect(v3, &v9);
    if ( *((_BYTE *)hWndTo + 8) & 2 )
      FlipRect((int)&v9);
    v4 = (HWND)*((_DWORD *)hWndTo + 40);
    Points.y = v2 - (v9.bottom - v9.top) / 2;
    Points.x = Rect.left + v9.left - g_cxEdge - v9.right;
    hWndToa = GetParent(v4);
    TBFlipPoint(v1, (int)&Points);
    MapWindowPoints(*(HWND *)v1, hWndToa, &Points, 1u);
    SetWindowPos(*(HWND *)(v1 + 160), 0, Points.x, Points.y, 0, 0, 0x15u);
  }
  result = *(_DWORD *)(v1 + 164);
  if ( result )
  {
    GetClientRect((HWND)result, &v9);
    if ( *(_BYTE *)(v1 + 8) & 2 )
      FlipRect((int)&v9);
    v6 = *(HWND *)(v1 + 164);
    Points.y = v2 - (v9.bottom - v9.top) / 2;
    Points.x = Rect.right + g_cxEdge;
    v7 = GetParent(v6);
    TBFlipPoint(v1, (int)&Points);
    MapWindowPoints(*(HWND *)v1, v7, &Points, 1u);
    result = SetWindowPos(*(HWND *)(v1 + 164), 0, Points.x, Points.y, 0, 0, 0x15u);
  }
  return result;
}

//----- (6F7B7508) --------------------------------------------------------
BOOL __stdcall TBNukeBuffer(int a1)
{
  BOOL result; // eax@1

  result = *(_DWORD *)(a1 + 40);
  if ( result )
  {
    result = DeleteObject(*(HGDIOBJ *)(a1 + 40));
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 140) |= 0xFu;
  }
  return result;
}

//----- (6F7B7534) --------------------------------------------------------
int __stdcall TBResize(HWND hWndTo)
{
  int v1; // edi@1
  int v2; // eax@4
  int v3; // ecx@5
  int v4; // eax@6
  bool v5; // zf@6
  int v6; // eax@9
  int v7; // eax@12
  int v8; // ecx@12
  int v9; // edi@12
  int v10; // ecx@12

  v1 = (int)(hWndTo + 19);
  GetClientRect(*(HWND *)hWndTo, (LPRECT)(hWndTo + 19));
  if ( *((_BYTE *)hWndTo + 8) & 2 )
    FlipRect(v1);
  if ( *((_BYTE *)hWndTo + 8) & 0x40 )
    goto LABEL_8;
  *((_DWORD *)hWndTo + 17) = 4 * g_cyHScroll / 3;
  ValidateThumbHeight((int)hWndTo);
  v2 = *((_DWORD *)hWndTo + 17);
  if ( v2 > 2 * g_cxEdge )
  {
    v3 = *((_DWORD *)hWndTo + 22);
    if ( v3 < v2 )
    {
      v4 = v3 - 3 * g_cyEdge;
      v5 = (*((_BYTE *)hWndTo + 8) & 0x20) == 0;
      *((_DWORD *)hWndTo + 17) = v4;
      if ( !v5 )
        *((_DWORD *)hWndTo + 17) = 3 * v4 / 4;
LABEL_8:
      ValidateThumbHeight((int)hWndTo);
      goto LABEL_9;
    }
  }
LABEL_9:
  v6 = *((_DWORD *)hWndTo + 2);
  if ( v6 & 0xC && !(v6 & 0x10) )
    *((_DWORD *)hWndTo + 20) += 8;
  *((_DWORD *)hWndTo + 20) += 2;
  v7 = *((_DWORD *)hWndTo + 20);
  *((_DWORD *)hWndTo + 22) = v7 + *((_DWORD *)hWndTo + 17);
  v8 = *((_DWORD *)hWndTo + 16);
  *(_DWORD *)v1 += v8 + 2;
  v9 = *(_DWORD *)v1;
  *((_DWORD *)hWndTo + 21) += -2 - v8;
  v10 = *((_DWORD *)hWndTo + 21);
  *((_DWORD *)hWndTo + 24) = v7;
  *((_DWORD *)hWndTo + 26) = *((_DWORD *)hWndTo + 22);
  *((_DWORD *)hWndTo + 18) = v10 - v9;
  if ( v10 == v9 )
  {
    *((_DWORD *)hWndTo + 37) |= 1u;
    *((_DWORD *)hWndTo + 18) = 1;
  }
  else
  {
    *((_DWORD *)hWndTo + 37) &= 0xFFFFFFFE;
  }
  TBNukeBuffer((int)hWndTo);
  MoveThumb((int)hWndTo, *((_DWORD *)hWndTo + 13));
  TBInvalidateAll((int)hWndTo);
  return TBPositionBuddies(hWndTo);
}
// 6F7E69A4: using guessed type int g_cyHScroll;

//----- (6F7B7634) --------------------------------------------------------
int __stdcall TBSetBuddy(HWND hWndTo, int a2, int a3)
{
  HWND v3; // eax@1
  int v4; // esi@3

  v3 = hWndTo + 40;
  if ( !a2 )
    v3 = hWndTo + 41;
  v4 = *(_DWORD *)v3;
  *(_DWORD *)v3 = a3;
  TBResize(hWndTo);
  return v4;
}

//----- (6F7B7668) --------------------------------------------------------
LRESULT __stdcall DoTrack(int a1, signed int a2, unsigned __int16 a3)
{
  int v3; // eax@7
  int v4; // eax@10
  LRESULT result; // eax@20
  int v6; // [sp-8h] [bp-10h]@19
  LPARAM v7; // [sp-4h] [bp-Ch]@19

  if ( !a2 )
  {
    v4 = *(_DWORD *)(a1 + 132);
LABEL_17:
    v4 = -v4;
    goto LABEL_18;
  }
  if ( a2 == 1 )
  {
    v4 = *(_DWORD *)(a1 + 132);
LABEL_18:
    MoveThumb(a1, v4 + *(_DWORD *)(a1 + 52));
    goto LABEL_19;
  }
  if ( a2 <= 1 )
    goto LABEL_19;
  if ( a2 <= 3 )
  {
    v4 = *(_DWORD *)(a1 + 128);
    if ( v4 == -1 )
    {
      v4 = (*(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 44)) / 5;
      if ( !v4 )
        v4 = 1;
    }
    if ( a2 != 2 )
      goto LABEL_18;
    goto LABEL_17;
  }
  if ( a2 == 6 )
  {
    v3 = *(_DWORD *)(a1 + 44);
  }
  else
  {
    if ( a2 != 7 )
      goto LABEL_19;
    v3 = *(_DWORD *)(a1 + 48);
  }
  MoveThumb(a1, v3);
LABEL_19:
  v7 = *(_DWORD *)a1;
  v6 = (unsigned __int16)a2 | (a3 << 16);
  if ( *(_BYTE *)(a1 + 8) & 2 )
    result = SendMessageW(*(HWND *)(a1 + 4), 0x115u, v6, v7);
  else
    result = SendMessageW(*(HWND *)(a1 + 4), 0x114u, v6, v7);
  return result;
}

//----- (6F7B770E) --------------------------------------------------------
signed int __stdcall WTrackType(int a1, int a2)
{
  unsigned int v2; // ebx@1
  int v3; // eax@2
  signed int v5; // [sp-4h] [bp-18h]@6
  unsigned int v6; // [sp+10h] [bp-4h]@1
  int v7; // [sp+20h] [bp+Ch]@5

  v2 = (signed __int16)a2;
  v6 = SHIWORD(a2);
  if ( !(*(_BYTE *)(a1 + 148) & 1) )
  {
    v3 = *(_DWORD *)(a1 + 8);
    if ( (char)v3 >= 0 )
    {
      if ( v3 & 2 )
      {
        v2 = SHIWORD(a2);
        v6 = (signed __int16)a2;
      }
      v7 = a1 + 92;
      if ( PtInRect((const RECT *)(a1 + 92), (POINT)__PAIR__(v6, v2)) )
        return 5;
      if ( PtInRect((const RECT *)(a1 + 76), (POINT)__PAIR__(v6, v2)) )
      {
        if ( (signed int)v2 < *(_DWORD *)v7 )
          v5 = 2;
        else
          v5 = 3;
        return v5;
      }
    }
  }
  return 0;
}

//----- (6F7B778C) --------------------------------------------------------
int __stdcall TBTrackEnd(int a1)
{
  HWND v1; // eax@2

  if ( *(_DWORD *)(a1 + 152) == 5 )
  {
    v1 = *(HWND *)(a1 + 136);
    if ( v1 )
      SendMessageW(v1, 0x411u, 0, 0);
    DoTrack(a1, 4, *(_DWORD *)(a1 + 108));
  }
  KillTimer(*(HWND *)a1, 1u);
  if ( *(_DWORD *)(a1 + 152) != -1 )
  {
    DoTrack(a1, 8, 0);
    *(_DWORD *)(a1 + 152) = -1;
  }
  return MoveThumb(a1, *(_DWORD *)(a1 + 52));
}

//----- (6F7B77FA) --------------------------------------------------------
int __stdcall TBTrack(int a1, int a2)
{
  unsigned int v2; // eax@3
  int result; // eax@5
  int v4; // edi@5
  int v5; // ebx@8
  int v6; // eax@8
  unsigned int v7; // ebx@9
  int v8; // ebx@12
  int v9; // ebx@13
  signed int v10; // edi@20
  struct tagRECT Rect; // [sp+8h] [bp-18h]@8
  struct tagPOINT Points; // [sp+18h] [bp-8h]@8

  if ( *(_DWORD *)(a1 + 152) == 5 )
  {
    if ( *(_BYTE *)(a1 + 8) & 2 )
      v2 = (unsigned int)a2 >> 16;
    else
      LOWORD(v2) = a2;
    result = TBPhysToLog(a1, (signed __int16)(v2 - *(_WORD *)(a1 + 112)));
    v4 = result;
    if ( result != *(_DWORD *)(a1 + 108) )
    {
      *(_DWORD *)(a1 + 108) = result;
      MoveThumb(a1, result);
      result = DoTrack(a1, 5, v4);
    }
    if ( *(_DWORD *)(a1 + 136) )
    {
      v5 = *(_DWORD *)(a1 + 144);
      GetClientRect(*(HWND *)a1, &Rect);
      Points.x = Rect.right / 2;
      Points.y = Rect.bottom / 2;
      v6 = TBLogToPhys(a1, v4);
      if ( *(_BYTE *)(a1 + 8) & 2 )
      {
        Points.y = v6;
        v7 = v5 | 1;
      }
      else
      {
        Points.x = v6;
        v7 = v5 & 0xFFFFFFFE;
      }
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          v9 = v8 - 1;
          if ( v9 )
          {
            if ( v9 == 1 )
              Points.x = Rect.right + 1;
          }
          else
          {
            Points.y = Rect.bottom + 1;
          }
        }
        else
        {
          Points.x = -1;
        }
      }
      else
      {
        Points.y = -1;
      }
      MapWindowPoints(*(HWND *)a1, 0, &Points, 1u);
      result = SendMessageW(*(HWND *)(a1 + 136), 0x412u, 0, (unsigned __int16)Points.x | (LOWORD(Points.y) << 16));
    }
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 152);
    result = (unsigned __int16)WTrackType(a1, a2);
    if ( v10 == (unsigned __int16)result )
      result = DoTrack(a1, v10, 0);
  }
  return result;
}

//----- (6F7B7927) --------------------------------------------------------
void __stdcall FlushChanges(HBRUSH hbr)
{
  int v1; // ebx@1
  int v2; // eax@2
  int v3; // eax@5
  unsigned int v4; // eax@11
  bool v5; // zf@28
  LPARAM lParam; // [sp+Ch] [bp-40h]@11
  int v7; // [sp+1Ch] [bp-30h]@8
  UINT v8; // [sp+20h] [bp-2Ch]@19
  int v9; // [sp+24h] [bp-28h]@28
  int v10; // [sp+28h] [bp-24h]@28
  int v11; // [sp+2Ch] [bp-20h]@28
  int v12; // [sp+30h] [bp-1Ch]@15
  int v13; // [sp+34h] [bp-18h]@9
  int v14; // [sp+38h] [bp-14h]@11
  struct tagRECT Rect; // [sp+3Ch] [bp-10h]@3
  HBRUSH hbra; // [sp+54h] [bp+8h]@1
  unsigned int hbrb; // [sp+54h] [bp+8h]@15
  unsigned int hbrc; // [sp+54h] [bp+8h]@21
  unsigned int hbrd; // [sp+54h] [bp+8h]@32

  v1 = (int)hbr;
  hbra = (HBRUSH)SendMessageW(*((HWND *)hbr + 1), 0x138u, *((_DWORD *)hbr + 9), *(_DWORD *)hbr);
  if ( !hbra )
    goto LABEL_8;
  v2 = *(_DWORD *)(v1 + 140);
  if ( v2 == 15 )
  {
    GetClientRect(*(HWND *)v1, &Rect);
  }
  else
  {
    if ( !(v2 & 2) )
      goto LABEL_8;
    v3 = *(_DWORD *)(v1 + 64);
    Rect.left = *(_DWORD *)(v1 + 76);
    Rect.top = *(_DWORD *)(v1 + 80);
    Rect.right = *(_DWORD *)(v1 + 84);
    Rect.bottom = *(_DWORD *)(v1 + 88);
    Rect.left = 0;
    Rect.right += v3;
    if ( *(_BYTE *)(v1 + 8) & 2 )
      FlipRect((int)&Rect);
  }
  FillRect(*(HDC *)(v1 + 36), &Rect, hbra);
LABEL_8:
  v7 = *(_DWORD *)(v1 + 36);
  if ( *(HWND *)v1 == GetFocus() )
    v13 = 16;
  else
    v13 = 0;
  v14 = 0;
  v4 = CICustomDrawNotify(v1, 1, (LPARAM)&lParam);
  *(_DWORD *)(v1 + 12) = v4;
  if ( v4 != 4 )
  {
    if ( v13 & 0x10 )
      DrawFocus(v1, hbra);
    v13 = 0;
    if ( *(_BYTE *)(v1 + 140) & 1 )
    {
      v12 = 1;
      hbrb = CICustomDrawNotify(v1, 65537, (LPARAM)&lParam);
      if ( hbrb != 4 )
      {
        DrawTics(v1);
        if ( hbrb & 0x10 )
        {
          v12 = 1;
          CICustomDrawNotify(v1, 65538, (LPARAM)&lParam);
        }
      }
    }
    if ( *(_BYTE *)(v1 + 140) & 2 )
    {
      GetChannelRect(v1, (int)&v8);
      if ( *(_BYTE *)(v1 + 8) & 2 )
        FlipRect((int)&v8);
      v12 = 3;
      hbrc = CICustomDrawNotify(v1, 65537, (LPARAM)&lParam);
      if ( hbrc != 4 )
      {
        if ( *(_BYTE *)(v1 + 8) & 2 )
          FlipRect((int)&v8);
        DrawChannel(v1, (int)&v8);
        if ( hbrc & 0x10 )
        {
          if ( *(_BYTE *)(v1 + 8) & 2 )
            FlipRect((int)&v8);
          v12 = 3;
          CICustomDrawNotify(v1, 65538, (LPARAM)&lParam);
        }
      }
      v5 = *(_DWORD *)(v1 + 152) == 5;
      v8 = *(_DWORD *)(v1 + 92);
      v9 = *(_DWORD *)(v1 + 96);
      v10 = *(_DWORD *)(v1 + 100);
      v11 = *(_DWORD *)(v1 + 104);
      if ( v5 )
        v13 = 1;
      if ( *(_BYTE *)(v1 + 8) & 2 )
        FlipRect((int)&v8);
      v12 = 2;
      hbrd = CICustomDrawNotify(v1, 65537, (LPARAM)&lParam);
      if ( hbrd != 4 )
      {
        if ( *(_BYTE *)(v1 + 8) & 2 )
          FlipRect((int)&v8);
        DrawThumb(v1, (UINT)&v8, v13 & 1);
        if ( hbrd & 0x10 )
        {
          if ( *(_BYTE *)(v1 + 8) & 2 )
            FlipRect((int)&v8);
          v12 = 2;
          CICustomDrawNotify(v1, 65538, (LPARAM)&lParam);
        }
      }
    }
    *(_DWORD *)(v1 + 140) = 0;
    if ( *(_BYTE *)(v1 + 12) & 0x10 )
      CICustomDrawNotify(v1, 2, (LPARAM)&lParam);
  }
}

//----- (6F7B7B67) --------------------------------------------------------
int __stdcall TrackOnCreate(HWND hWnd, int a2)
{
  HLOCAL v2; // eax@1
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@5
  unsigned int v6; // ecx@6
  HWND v7; // eax@9
  int v8; // ecx@10
  LPARAM lParam; // [sp+8h] [bp-2Ch]@10
  int v10; // [sp+Ch] [bp-28h]@10
  int v11; // [sp+10h] [bp-24h]@10
  int v12; // [sp+14h] [bp-20h]@10
  int v13; // [sp+18h] [bp-1Ch]@10
  int v14; // [sp+1Ch] [bp-18h]@10
  int v15; // [sp+20h] [bp-14h]@10
  int v16; // [sp+24h] [bp-10h]@10
  int v17; // [sp+2Ch] [bp-8h]@10

  InitDitherBrush();
  InitGlobalColors();
  v2 = LocalAlloc(0x40u, 0xA8u);
  v3 = (int)v2;
  if ( v2 )
  {
    SetWindowLongW(hWnd, 0, (LONG)v2);
    CIInitialize(v3, (WPARAM)hWnd, a2);
    *(_DWORD *)(v3 + 152) = -1;
    *(_DWORD *)(v3 + 128) = -1;
    *(_DWORD *)(v3 + 124) = 1;
    *(_DWORD *)(v3 + 132) = 1;
    *(_DWORD *)(v3 + 48) = 100;
    *(_DWORD *)(v3 + 68) = 4 * g_cyHScroll / 3;
    if ( g_fDBCSInputEnabled )
      *(_DWORD *)(v3 + 156) = ImmAssociateContext(hWnd, 0);
    v5 = *(_DWORD *)(v3 + 8);
    if ( v5 & 2 )
      v6 = (*(_DWORD *)(v3 + 8) & 4 | 2u) >> 1;
    else
      v6 = ((unsigned int)(unsigned __int8)v5 >> 1) & 2;
    *(_DWORD *)(v3 + 144) = v6;
    if ( v5 & 0x100 )
    {
      v7 = CreateWindowExW(
             0,
             L"tooltips_class32",
             &WindowName,
             0x80000000,
             2147483648,
             2147483648,
             2147483648,
             2147483648,
             *(HWND *)v3,
             0,
             g_hinst,
             0);
      *(_DWORD *)(v3 + 136) = v7;
      if ( v7 )
      {
        v8 = *(_DWORD *)v3;
        v17 = -1;
        v11 = v8;
        v12 = v8;
        lParam = 44;
        v10 = 35;
        v15 = 0;
        v16 = 0;
        v14 = 0;
        v13 = 0;
        SendMessageW(v7, 0x432u, 0, (LPARAM)&lParam);
      }
      else
      {
        *(_DWORD *)(v3 + 8) &= 0xFFFFFEFF;
      }
    }
    TBResize((HWND)v3);
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;
// 6F7E69A4: using guessed type int g_cyHScroll;

//----- (6F7B7CA0) --------------------------------------------------------
void __stdcall TBTrackInit(int a1, int a2)
{
  unsigned __int16 v2; // di@3
  int v3; // eax@6
  unsigned int v4; // ecx@7
  HWND v5; // ecx@9
  LPARAM lParam; // [sp+4h] [bp-2Ch]@10
  int v7; // [sp+8h] [bp-28h]@10
  HWND v8; // [sp+Ch] [bp-24h]@10
  HWND v9; // [sp+10h] [bp-20h]@10

  if ( !(*(_BYTE *)(a1 + 148) & 1) && !(*(_BYTE *)(a1 + 8) & 0x80) )
  {
    v2 = WTrackType(a1, a2);
    if ( v2 )
    {
      SetCapture(*(HWND *)a1);
      *(_DWORD *)(a1 + 108) = -1;
      *(_DWORD *)(a1 + 152) = v2;
      if ( v2 == 5 )
      {
        v3 = TBLogToPhys(a1, *(_DWORD *)(a1 + 52));
        if ( *(_BYTE *)(a1 + 8) & 2 )
          v4 = (unsigned int)a2 >> 16;
        else
          v4 = (unsigned __int16)a2;
        *(_DWORD *)(a1 + 112) = v4 - v3;
        v5 = *(HWND *)(a1 + 136);
        if ( v5 )
        {
          v8 = *(HWND *)a1;
          v9 = v8;
          lParam = 44;
          v7 = 34;
          SendMessageW(v5, 0x411u, 1u, (LPARAM)&lParam);
        }
      }
      else
      {
        SetTimer(*(HWND *)a1, 1u, 0x1F4u, 0);
      }
      TBTrack(a1, a2);
    }
  }
}

//----- (6F7B7D6C) --------------------------------------------------------
HWND __stdcall TrackOnNotify(int a1, LPARAM lParam)
{
  HWND result; // eax@1

  result = *(HWND *)lParam;
  if ( *(_DWORD *)lParam == *(_DWORD *)(a1 + 136) )
  {
    if ( *(_DWORD *)(lParam + 8) == -530 )
      StringCchPrintfW((STRSAFE_LPWSTR)(lParam + 16), 0x50u, L"%d", *(_DWORD *)(a1 + 52));
    result = SendNotifyEx(
               *(_DWORD *)(a1 + 4),
               HWND_MESSAGE|0x2,
               *(_DWORD *)(lParam + 8),
               lParam,
               *(_DWORD *)(a1 + 16) & 1);
  }
  return result;
}

//----- (6F7B7DC2) --------------------------------------------------------
int __stdcall TrackBarWndProc(HWND hWnd, UINT Msg, int a3, LPARAM lParam)
{
  int v4; // edi@1
  int v5; // ebx@1
  int result; // eax@3
  int v7; // eax@38
  int v8; // eax@48
  int v9; // ecx@48
  int v10; // eax@51
  signed int v11; // eax@54
  int v12; // eax@93
  WPARAM v13; // esi@100
  HDC v14; // eax@102
  bool v15; // zf@102
  HLOCAL v16; // eax@112
  int v17; // ecx@113
  int v18; // eax@122
  signed int v19; // ecx@127
  int v20; // esi@132
  LPARAM v21; // ecx@134
  LPARAM v22; // edx@134
  LPARAM v23; // eax@136
  signed int v24; // ecx@141
  signed int v25; // ecx@144
  int v26; // eax@147
  LPARAM v27; // eax@150
  int v28; // ecx@153
  LPARAM v29; // eax@157
  int v30; // ecx@160
  int v31; // eax@160
  bool v32; // sf@163
  unsigned __int8 v33; // of@163
  int v34; // eax@172
  int v35; // edx@172
  int v36; // esi@172
  int v37; // ebx@189
  LPARAM v38; // edi@192
  int v39; // eax@203
  signed int v40; // ecx@206
  signed int v41; // esi@207
  int v42; // eax@208
  int v43; // ecx@208
  int v44; // edi@208
  signed int v45; // edx@214
  signed int v46; // [sp-4h] [bp-70h]@53
  struct tagRECT Rect; // [sp+Ch] [bp-60h]@103
  HGDIOBJ h; // [sp+1Ch] [bp-50h]@1
  HWND v49; // [sp+20h] [bp-4Ch]@1
  WPARAM wParam; // [sp+24h] [bp-48h]@1
  struct tagPAINTSTRUCT Paint; // [sp+28h] [bp-44h]@101

  v4 = lParam;
  v49 = hWnd;
  wParam = a3;
  h = (HGDIOBJ)lParam;
  v5 = GetWindowLongW(hWnd, 0);
  if ( !v5 )
  {
    if ( Msg == 1 )
      return TrackOnCreate(v49, lParam);
    return DefWindowProcW(v49, Msg, wParam, lParam);
  }
  if ( Msg <= 0x404 )
  {
    if ( Msg == 1028 )
    {
      if ( lParam < *(_DWORD *)(v5 + 44) )
        return 0;
      if ( lParam > *(_DWORD *)(v5 + 48) )
        return 0;
      v16 = CCLocalReAlloc(*(HLOCAL *)(v5 + 120), 4 * *(_DWORD *)(v5 + 116) + 4);
      if ( !v16 )
        return 0;
      v17 = *(_DWORD *)(v5 + 116);
      *(_DWORD *)(v5 + 120) = v16;
      *((_DWORD *)v16 + v17) = lParam;
      ++*(_DWORD *)(v5 + 116);
      TBInvalidateAll(v5);
      goto LABEL_38;
    }
    if ( Msg > 0x100 )
    {
      if ( Msg <= 0x207 )
      {
        if ( Msg == 519 )
        {
          SetFocus(v49);
          return 0;
        }
        if ( Msg == 257 )
        {
          if ( !(*(_DWORD *)(v5 + 8) & 0x8000000) && wParam >= 0x21 && wParam <= 0x28 )
            DoTrack(v5, 8, 0);
          return 0;
        }
        if ( Msg == 275 )
        {
          h = (HGDIOBJ)GetMessagePosClient(*(HWND *)v5, 0);
          v4 = (int)h;
        }
        else
        {
          if ( Msg == 296 )
          {
            if ( CCOnUIState(v5, 296, wParam & 0x1FFFF, lParam) )
              InvalidateRect(v49, 0, 1);
            return DefWindowProcW(v49, Msg, wParam, lParam);
          }
          if ( Msg != 512 )
          {
            if ( Msg == 513 )
            {
              if ( !(*(_DWORD *)(v5 + 8) & 0x8000000) )
              {
                SetFocus(v49);
                TBTrackInit(v5, lParam);
              }
              return 0;
            }
            if ( Msg == 514 )
            {
              if ( !(*(_DWORD *)(v5 + 8) & 0x8000000) )
              {
                TBTrackEnd(v5);
                if ( GetCapture() == v49 )
                  CCReleaseCapture(v5);
              }
              return 0;
            }
            goto LABEL_202;
          }
        }
        if ( *(_DWORD *)(v5 + 152) != -1 && !(*(_DWORD *)(v5 + 8) & 0x8000000) )
          TBTrack(v5, v4);
        return 0;
      }
      if ( Msg == 533 )
      {
        TBTrackEnd(v5);
        return 0;
      }
      if ( Msg == 792 )
        goto LABEL_100;
      if ( Msg == 1024 )
        return *(_DWORD *)(v5 + 52);
      if ( Msg == 1025 )
        return *(_DWORD *)(v5 + 44);
      if ( Msg == 1026 )
        return *(_DWORD *)(v5 + 48);
      if ( Msg == 1027 )
      {
        v12 = *(_DWORD *)(v5 + 120);
        if ( v12 && (signed int)wParam < *(_DWORD *)(v5 + 116) )
          result = *(_DWORD *)(v12 + 4 * wParam);
        else
LABEL_96:
          result = -1;
        return result;
      }
    }
    else
    {
      if ( Msg == 256 )
      {
        if ( !(*(_DWORD *)(v5 + 8) & 0x8000000) )
        {
          v8 = RTLSwapLeftRightArrows(v5, wParam);
          v9 = *(_DWORD *)(v5 + 8);
          if ( v9 & 0x400 )
          {
            if ( v9 & 2 )
            {
              v8 = CCSwapKeys(v8, 37, 39);
            }
            else
            {
              v10 = CCSwapKeys(v8, 38, 40);
              v8 = CCSwapKeys(v10, 33, 34);
            }
          }
          switch ( v8 )
          {
            case 36:
              v46 = 6;
              goto LABEL_54;
            case 35:
              v46 = 7;
              goto LABEL_54;
            case 33:
              v46 = 2;
              goto LABEL_54;
            case 34:
              v46 = 3;
LABEL_54:
              v11 = v46;
              goto LABEL_60;
            case 37:
            case 38:
              v11 = 0;
              goto LABEL_60;
            case 39:
            case 40:
              v11 = 1;
LABEL_60:
              DoTrack(v5, v11, 0);
              CCNotifyNavigationKeyUsage(v5, 1u);
              break;
            default:
              return 0;
          }
        }
        return 0;
      }
      if ( Msg <= 0x1A )
      {
        if ( Msg == 26 )
        {
          InitGlobalMetrics(wParam);
        }
        else
        {
          if ( Msg == 2 )
          {
            TerminateDitherBrush();
            if ( g_fDBCSInputEnabled )
              ImmAssociateContext(v49, *(HIMC *)(v5 + 156));
            if ( *(_DWORD *)(v5 + 8) & 0x100 && IsWindow(*(HWND *)(v5 + 136)) )
              DestroyWindow(*(HWND *)(v5 + 136));
            TBNukeBuffer(v5);
            LocalFree(*(HLOCAL *)(v5 + 120));
            LocalFree((HLOCAL)v5);
            SetWindowLongW(v49, 0, 0);
            return 0;
          }
          if ( Msg != 5 )
          {
            if ( Msg == 7 )
            {
LABEL_18:
              TBInvalidateAll(v5);
              return 0;
            }
            if ( Msg == 8 )
            {
              gcWheelDelta = 0;
              goto LABEL_18;
            }
            if ( Msg == 10 )
            {
              if ( wParam )
                *(_DWORD *)(v5 + 8) &= 0xF7FFFFFF;
              else
                *(_DWORD *)(v5 + 8) |= 0x8000000u;
              *(_DWORD *)(v5 + 140) |= 2u;
              InvalidateRect(v49, 0, 0);
              return 0;
            }
            if ( Msg != 15 )
            {
              if ( Msg == 21 )
              {
                InitGlobalColors();
                goto LABEL_18;
              }
              goto LABEL_202;
            }
LABEL_100:
            v13 = wParam;
            if ( !wParam )
              v13 = (WPARAM)BeginPaint(v49, &Paint);
            v14 = CreateCompatibleDC((HDC)v13);
            v15 = *(_DWORD *)(v5 + 40) == 0;
            *(_DWORD *)(v5 + 36) = v14;
            if ( v15 )
            {
              GetClientRect(v49, &Rect);
              *(_DWORD *)(v5 + 40) = CreateColorBitmap(Rect.right, Rect.bottom);
            }
            h = SelectObject(*(HDC *)(v5 + 36), *(HGDIOBJ *)(v5 + 40));
            FlushChanges((HBRUSH)v5);
            if ( (unsigned int)GetClipBox((HDC)v13, &Rect) <= 1 )
              GetClientRect(*(HWND *)v5, &Rect);
            BitBlt(
              (HDC)v13,
              Rect.left,
              Rect.top,
              Rect.right - Rect.left,
              Rect.bottom - Rect.top,
              *(HDC *)(v5 + 36),
              Rect.left,
              Rect.top,
              0xCC0020u);
            SelectObject(*(HDC *)(v5 + 36), h);
            DeleteDC(*(HDC *)(v5 + 36));
            if ( !wParam )
              EndPaint(v49, &Paint);
            *(_DWORD *)(v5 + 36) = 0;
            return 0;
          }
        }
LABEL_31:
        TBResize((HWND)v5);
        return 0;
      }
      if ( Msg == 61 )
      {
        if ( lParam == -12 )
          return 65554;
        return DefWindowProcW(v49, Msg, wParam, lParam);
      }
      if ( Msg == 78 )
      {
        TrackOnNotify(v5, lParam);
        return 0;
      }
      if ( Msg == 85 )
        return CIHandleNotifyFormat(v5, lParam);
      if ( Msg == 125 )
      {
        if ( wParam != -16 )
          return 0;
        *(_DWORD *)(v5 + 8) = *(_DWORD *)(lParam + 4);
        goto LABEL_31;
      }
      if ( Msg == 126 )
      {
        TBNukeBuffer(v5);
        return 0;
      }
      if ( Msg == 135 )
        goto LABEL_38;
    }
LABEL_202:
    if ( Msg == g_msgMSWheel )
    {
      gcWheelDelta -= SHIWORD(wParam);
      v39 = gcWheelDelta / 120;
      if ( gcWheelDelta / 120 )
        gcWheelDelta %= 120;
      if ( !(wParam & 0xC) )
      {
        v40 = *(_DWORD *)(v5 + 52);
        if ( v40 >= -32768 )
        {
          v41 = 0x7FFF;
          if ( v40 <= 0x7FFF )
          {
            v42 = v40 + v39;
            v43 = *(_DWORD *)(v5 + 48);
            v44 = v42;
            if ( v42 >= v43 )
              v44 = *(_DWORD *)(v5 + 48);
            if ( v44 <= *(_DWORD *)(v5 + 44) )
            {
              v42 = *(_DWORD *)(v5 + 44);
            }
            else if ( v42 >= v43 )
            {
              v42 = *(_DWORD *)(v5 + 48);
            }
            v45 = v42;
            if ( v42 >= 0x7FFF )
              v45 = 0x7FFF;
            if ( v45 <= -32768 )
            {
              v41 = -32768;
            }
            else if ( v42 < 0x7FFF )
            {
              v41 = v42;
            }
            if ( v41 != *(_DWORD *)(v5 + 52) )
            {
              MoveThumb(v5, v41);
              DoTrack(v5, 4, v41);
            }
          }
        }
LABEL_38:
        v7 = 0;
        return v7 + 1;
      }
    }
    else if ( CCWndProc(v5, Msg, wParam, lParam, (int)&h) )
    {
      return (int)h;
    }
    return DefWindowProcW(v49, Msg, wParam, lParam);
  }
  switch ( Msg )
  {
    case 0x411u:
      return *(_DWORD *)(v5 + 56);
    case 0x412u:
      return *(_DWORD *)(v5 + 60);
    case 0x40Eu:
      return *(_DWORD *)(v5 + 120);
    case 0x413u:
      *(_DWORD *)(v5 + 148) &= 0xFFFFFFFD;
      *(_DWORD *)(v5 + 56) = -1;
      *(_DWORD *)(v5 + 60) = -1;
      goto LABEL_172;
    case 0x409u:
      if ( *(_DWORD *)(v5 + 120) )
        LocalFree(*(HLOCAL *)(v5 + 120));
      *(_DWORD *)(v5 + 120) = 0;
      *(_DWORD *)(v5 + 116) = 0;
      goto LABEL_172;
    case 0x40Fu:
      v18 = *(_DWORD *)(v5 + 120);
      if ( !v18 || (signed int)wParam >= *(_DWORD *)(v5 + 116) )
        goto LABEL_96;
      return TBLogToPhys(v5, *(_DWORD *)(v18 + 4 * wParam));
    case 0x410u:
      if ( *(_BYTE *)(v5 + 8) & 0x10 )
        return 0;
      v19 = *(_DWORD *)(v5 + 124);
      if ( v19 )
      {
        v7 = *(_DWORD *)(v5 + 116) / v19 + 1;
        return v7 + 1;
      }
      result = 2;
      break;
    case 0x414u:
      *(_DWORD *)(v5 + 124) = wParam;
      goto LABEL_171;
    case 0x405u:
      if ( wParam && (v20 = TBLogToPhys(v5, *(_DWORD *)(v5 + 52)), TBLogToPhys(v5, lParam) != v20) )
      {
        MoveThumb(v5, lParam);
      }
      else
      {
        v21 = *(_DWORD *)(v5 + 48);
        v22 = lParam;
        if ( lParam >= v21 )
          v22 = *(_DWORD *)(v5 + 48);
        v23 = *(_DWORD *)(v5 + 44);
        if ( v22 > v23 )
        {
          v23 = lParam;
          if ( lParam >= v21 )
            v23 = *(_DWORD *)(v5 + 48);
        }
        *(_DWORD *)(v5 + 52) = v23;
      }
      return 0;
    case 0x40Au:
      if ( !(*(_BYTE *)(v5 + 8) & 0x20) )
        return 0;
      v24 = *(_DWORD *)(v5 + 44);
      *(_DWORD *)(v5 + 148) |= 2u;
      if ( (signed __int16)lParam >= v24 )
        *(_DWORD *)(v5 + 56) = (signed __int16)lParam;
      else
        *(_DWORD *)(v5 + 56) = v24;
      v25 = *(_DWORD *)(v5 + 48);
      if ( SHIWORD(lParam) <= v25 )
        *(_DWORD *)(v5 + 60) = SHIWORD(lParam);
      else
        *(_DWORD *)(v5 + 60) = v25;
      v26 = *(_DWORD *)(v5 + 56);
      if ( *(_DWORD *)(v5 + 60) < v26 )
        goto LABEL_148;
      goto LABEL_172;
    case 0x40Bu:
      if ( !(*(_BYTE *)(v5 + 8) & 0x20) )
        return 0;
      v27 = *(_DWORD *)(v5 + 44);
      *(_DWORD *)(v5 + 148) |= 2u;
      if ( lParam >= v27 )
        *(_DWORD *)(v5 + 56) = lParam;
      else
        *(_DWORD *)(v5 + 56) = v27;
      v28 = *(_DWORD *)(v5 + 60);
      v26 = *(_DWORD *)(v5 + 56);
      if ( v28 < v26 || v28 == -1 )
LABEL_148:
        *(_DWORD *)(v5 + 60) = v26;
      goto LABEL_172;
    case 0x40Cu:
      if ( !(*(_BYTE *)(v5 + 8) & 0x20) )
        return 0;
      v29 = *(_DWORD *)(v5 + 48);
      *(_DWORD *)(v5 + 148) |= 2u;
      if ( lParam <= v29 )
        *(_DWORD *)(v5 + 60) = lParam;
      else
        *(_DWORD *)(v5 + 60) = v29;
      v30 = *(_DWORD *)(v5 + 56);
      v31 = *(_DWORD *)(v5 + 60);
      if ( v30 > v31 || v30 == -1 )
        *(_DWORD *)(v5 + 56) = v31;
      goto LABEL_172;
    case 0x406u:
      v33 = __OFSUB__(*(_DWORD *)(v5 + 56), (signed __int16)lParam);
      v32 = *(_DWORD *)(v5 + 56) - (signed int)(signed __int16)lParam < 0;
      *(_DWORD *)(v5 + 44) = (signed __int16)lParam;
      *(_DWORD *)(v5 + 48) = SHIWORD(lParam);
      if ( v32 ^ v33 )
        *(_DWORD *)(v5 + 56) = (signed __int16)lParam;
      if ( *(_DWORD *)(v5 + 60) > (signed int)SHIWORD(lParam) )
        *(_DWORD *)(v5 + 60) = SHIWORD(lParam);
      goto LABEL_171;
    case 0x407u:
      v33 = __OFSUB__(*(_DWORD *)(v5 + 56), lParam);
      v32 = *(_DWORD *)(v5 + 56) - lParam < 0;
      *(_DWORD *)(v5 + 44) = lParam;
      if ( v32 ^ v33 )
        *(_DWORD *)(v5 + 56) = lParam;
      goto LABEL_171;
    case 0x408u:
      v33 = __OFSUB__(*(_DWORD *)(v5 + 60), lParam);
      v15 = *(_DWORD *)(v5 + 60) == lParam;
      v32 = *(_DWORD *)(v5 + 60) - lParam < 0;
      *(_DWORD *)(v5 + 48) = lParam;
      if ( !((unsigned __int8)(v32 ^ v33) | v15) )
        *(_DWORD *)(v5 + 60) = lParam;
LABEL_171:
      DoAutoTics(v5);
LABEL_172:
      v34 = *(_DWORD *)(v5 + 52);
      v35 = *(_DWORD *)(v5 + 48);
      v36 = *(_DWORD *)(v5 + 52);
      if ( v34 >= v35 )
        v36 = *(_DWORD *)(v5 + 48);
      if ( v36 <= *(_DWORD *)(v5 + 44) )
      {
        v34 = *(_DWORD *)(v5 + 44);
      }
      else if ( v34 >= v35 )
      {
        v34 = *(_DWORD *)(v5 + 48);
      }
      *(_DWORD *)(v5 + 140) |= 0xFu;
      *(_DWORD *)(v5 + 52) = v34;
      if ( wParam )
      {
        InvalidateRect(v49, 0, 0);
        MoveThumb(v5, *(_DWORD *)(v5 + 52));
      }
      return 0;
    case 0x41Bu:
      if ( !(*(_BYTE *)(v5 + 8) & 0x40) )
        return 0;
      *(_DWORD *)(v5 + 68) = wParam;
      goto LABEL_31;
    case 0x41Cu:
      return *(_DWORD *)(v5 + 68);
    case 0x415u:
      result = *(_DWORD *)(v5 + 128);
      if ( result == -1 )
        result = (*(_DWORD *)(v5 + 48) - *(_DWORD *)(v5 + 44)) / 5;
      *(_DWORD *)(v5 + 128) = lParam;
      return result;
    case 0x416u:
      result = *(_DWORD *)(v5 + 128);
      if ( result == -1 )
        result = (*(_DWORD *)(v5 + 48) - *(_DWORD *)(v5 + 44)) / 5;
      return result;
    case 0x417u:
      v37 = v5 + 132;
      result = *(_DWORD *)v37;
      *(_DWORD *)v37 = lParam;
      return result;
    case 0x418u:
      return *(_DWORD *)(v5 + 132);
    case 0x419u:
      if ( lParam )
      {
        *(_DWORD *)lParam = *(_DWORD *)(v5 + 92);
        *(_DWORD *)(lParam + 4) = *(_DWORD *)(v5 + 96);
        v38 = lParam + 8;
        *(_DWORD *)v38 = *(_DWORD *)(v5 + 100);
        *(_DWORD *)(v38 + 4) = *(_DWORD *)(v5 + 104);
        if ( *(_BYTE *)(v5 + 8) & 2 )
          FlipRect((int)h);
      }
      return 0;
    case 0x41Eu:
      return *(_DWORD *)(v5 + 136);
    case 0x41Du:
      *(_DWORD *)(v5 + 136) = wParam;
      return 0;
    case 0x41Fu:
      result = *(_DWORD *)(v5 + 144);
      *(_DWORD *)(v5 + 144) = wParam;
      return result;
    case 0x41Au:
      GetChannelRect(v5, lParam);
      return 0;
    case 0x420u:
      return TBSetBuddy((HWND)v5, wParam, lParam);
    case 0x421u:
      if ( wParam )
        result = *(_DWORD *)(v5 + 160);
      else
        result = *(_DWORD *)(v5 + 164);
      return result;
    default:
      goto LABEL_202;
  }
  return result;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;
// 6F7E6930: using guessed type int g_msgMSWheel;
// 6F7E8E5C: using guessed type int gcWheelDelta;

//----- (6F7B877F) --------------------------------------------------------
LRESULT __stdcall TV_PopBubble(LRESULT a1)
{
  LRESULT result; // eax@1
  HWND v2; // ecx@1

  result = a1;
  v2 = *(HWND *)(a1 + 224);
  if ( v2 )
  {
    if ( *(_DWORD *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 64) = 0;
      result = SendMessageW(v2, 0x41Cu, 0, 0);
    }
  }
  return result;
}

//----- (6F7B87B2) --------------------------------------------------------
HWND __stdcall TV_SendBeginDrag(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@1
  LPARAM lParam; // [sp+0h] [bp-68h]@1
  int v8; // [sp+10h] [bp-58h]@1
  int v9; // [sp+38h] [bp-30h]@1
  int v10; // [sp+3Ch] [bp-2Ch]@1
  int v11; // [sp+40h] [bp-28h]@1
  int v12; // [sp+5Ch] [bp-Ch]@1
  int v13; // [sp+60h] [bp-8h]@1
  int v14; // [sp+64h] [bp-4h]@1

  TV_PopBubble(a1);
  v5 = *(_WORD *)(a3 + 20);
  v8 = 0;
  v10 = a3;
  v12 = *(_DWORD *)(a3 + 16);
  v13 = a4;
  v14 = a5;
  v11 = v5;
  v9 = 28;
  return CCSendNotify(a1, a2, (LPARAM)&lParam);
}

//----- (6F7B8804) --------------------------------------------------------
int __stdcall TV_CheckHit(int a1, signed int a2, signed int a3, int a4)
{
  int v4; // edi@1
  int v6; // edx@11
  int v7; // ecx@16
  int v8; // eax@16
  int v9; // ecx@20
  int v10; // eax@22
  char v11; // [sp+Ch] [bp-2Ch]@19
  int v12; // [sp+14h] [bp-24h]@19
  int v13; // [sp+2Ch] [bp-Ch]@32
  int v14; // [sp+44h] [bp+Ch]@16

  v4 = *(_DWORD *)(a1 + 208);
  *(_DWORD *)a4 = 0;
  if ( a2 >= 0 )
  {
    if ( a2 > *(_WORD *)(a1 + 190) )
      *(_DWORD *)a4 = 1024;
  }
  else
  {
    *(_DWORD *)a4 = 2048;
  }
  if ( a3 >= 0 )
  {
    if ( a3 > *(_WORD *)(a1 + 192) )
      *(_DWORD *)a4 |= 0x200u;
  }
  else
  {
    *(_DWORD *)a4 |= 0x100u;
  }
  if ( *(_DWORD *)a4 )
    return 0;
  v6 = a3 / *(_WORD *)(a1 + 182);
  if ( !v4 )
    goto LABEL_40;
  do
  {
    if ( v6 < *(_WORD *)(v4 + 32) )
      break;
    v4 = TV_GetNextVisItem(v4);
  }
  while ( v4 );
  if ( !v4 )
  {
LABEL_40:
    *(_DWORD *)a4 = 1;
    return 0;
  }
  v7 = *(_WORD *)(a1 + 188);
  v8 = *(_DWORD *)(a1 + 8);
  v14 = *(_WORD *)(a1 + 198) - v7 * *(_BYTE *)(v4 + 30) - *(_WORD *)(a1 + 184) + a2;
  if ( v8 & 3 && v8 & 4 )
    v14 -= v7;
  TV_GetItem(a1, v4, 64, (int)&v11);
  if ( v12 & 0xF000 )
    v9 = *(_DWORD *)(a1 + 100);
  else
    v9 = 0;
  v10 = *(_WORD *)(a1 + 176);
  if ( v14 > v9 + v10 + *(_WORD *)(v4 + 26) )
  {
    *(_DWORD *)a4 = 32;
  }
  else if ( v14 < 0 )
  {
    if ( v14 >= -*(_WORD *)(a1 + 188) && v13 && *(_BYTE *)(a1 + 8) & 1 )
      *(_DWORD *)a4 = 16;
    else
      *(_DWORD *)a4 = 8;
  }
  else if ( *(_DWORD *)(a1 + 88) && v14 < v9 )
  {
    *(_DWORD *)a4 = 64;
  }
  else if ( *(_DWORD *)(a1 + 84) && v14 < v9 + v10 )
  {
    *(_DWORD *)a4 = 2;
  }
  else
  {
    *(_DWORD *)a4 = 4;
  }
  return v4;
}

//----- (6F7B896F) --------------------------------------------------------
int __stdcall TV_OnSetRedraw(int a1, int a2)
{
  int result; // eax@1

  result = (*(_DWORD *)(a1 + 36) ^ 16 * (a2 != 0)) & 0x10;
  *(_DWORD *)(a1 + 36) ^= result;
  if ( *(_BYTE *)(a1 + 36) & 0x10 )
  {
    if ( *(_DWORD *)(a1 + 40) )
      *(_DWORD *)(a1 + 200) = TV_UpdateShownIndexes(a1, *(_DWORD *)(a1 + 40));
    TV_ScrollBarsAfterSetWidth(a1, 0);
    result = InvalidateRect(*(HWND *)a1, 0, 1);
  }
  return result;
}

//----- (6F7B89C4) --------------------------------------------------------
int __stdcall TV_WalkToLevel(int a1, int a2)
{
  int result; // eax@1
  int i; // ecx@1

  result = a1;
  for ( i = *(_BYTE *)(a1 + 30) - a2; i > 0; --i )
    result = *(_DWORD *)result;
  return result;
}

//----- (6F7B89E5) --------------------------------------------------------
signed int __stdcall TV_ExpandOnSelChange(int a1, int a2, int a3)
{
  int v3; // esi@1
  signed int result; // eax@1
  int v5; // edi@3
  int v6; // edi@15
  char v7; // cl@16
  int i; // eax@18
  int v9; // edx@18
  LPARAM lParam; // [sp+4h] [bp-78h]@9
  int v11; // [sp+14h] [bp-68h]@7
  int v12; // [sp+18h] [bp-64h]@5
  int v13; // [sp+38h] [bp-44h]@6
  int v14; // [sp+3Ch] [bp-40h]@9
  int v15; // [sp+40h] [bp-3Ch]@7
  int v16; // [sp+60h] [bp-1Ch]@8
  char v17; // [sp+6Ch] [bp-10h]@4
  int v18; // [sp+70h] [bp-Ch]@10
  int p; // [sp+74h] [bp-8h]@3
  int v20; // [sp+78h] [bp-4h]@9
  int v21; // [sp+8Ch] [bp+10h]@9

  v3 = a3;
  result = ValidateTreeItem(a3, 1);
  if ( result )
  {
    result = ValidateTreeItem(a2, 1);
    if ( result )
    {
      v5 = a1;
      result = TV_StartWatch(a1, &p, a3);
      if ( result )
      {
        if ( TV_StartWatch(a1, &v17, a2) )
        {
          v12 = a3;
          if ( a3 )
            v13 = *(_DWORD *)(a3 + 16);
          v11 = 20;
          v15 = a2;
          if ( a2 )
            v16 = *(_DWORD *)(a2 + 16);
          v14 = 20;
          v21 = (int)CCSendNotify(a1, -415, (LPARAM)&lParam);
          UpdateWindow(*(HWND *)a1);
          if ( !v20 && !v18 )
          {
            if ( !(v21 & 1) && v3 && GetKeyState(17) >= 0 )
            {
              if ( a2 )
              {
                v7 = *(_BYTE *)(a2 + 30);
                v6 = *(_BYTE *)(v3 + 30);
                if ( *(_BYTE *)(v3 + 30) >= v7 )
                  v6 = v7;
                TV_WalkToLevel(v3, v6);
                for ( i = TV_WalkToLevel(a2, v6); v6 >= 0; i = *(_DWORD *)i )
                {
                  if ( v9 == i )
                    break;
                  --v6;
                  v9 = *(_DWORD *)v9;
                }
              }
              else
              {
                v6 = -1;
              }
              while ( *(_BYTE *)(v3 + 30) > v6 )
              {
                TV_Expand(a1, 1u, v3, 1);
                if ( v20 )
                  break;
                v3 = *(_DWORD *)v3;
                v20 = 0;
                p = v3;
              }
              v5 = a1;
            }
            if ( !(v21 & 2) && a2 && !v18 )
            {
              TV_Expand(v5, 3u, a2, 1);
              UpdateWindow(*(HWND *)v5);
            }
          }
          TV_EndWatch(v5, (int)&v17);
        }
        result = TV_EndWatch(v5, (int)&p);
      }
    }
  }
  return result;
}

//----- (6F7B8B4B) --------------------------------------------------------
signed int __stdcall TV_ResetItem(int a1, LPVOID lpMem)
{
  signed int result; // eax@1

  TV_DeleteItem(a1, lpMem, 2);
  *((_WORD *)lpMem + 10) &= 0xFFBFu;
  result = 1;
  *((_BYTE *)lpMem + 31) = 1;
  return result;
}

//----- (6F7B8B78) --------------------------------------------------------
signed int __stdcall BetweenItems(int a1, int a2, int a3, int a4)
{
  int i; // eax@2

  if ( a3 )
  {
    for ( i = TV_GetNextVisItem(a3); i && a4 != i; i = TV_GetNextVisItem(i) )
    {
      if ( a2 == i )
        return 1;
    }
  }
  return 0;
}

//----- (6F7B8BAC) --------------------------------------------------------
int __stdcall TV_GetVisCount(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
  {
    result = *(_WORD *)(a1 + 196);
    if ( *(_WORD *)(a1 + 192) != result * *(_WORD *)(a1 + 182) )
      ++result;
  }
  else
  {
    result = *(_WORD *)(a1 + 196);
  }
  return result;
}

//----- (6F7B8BEC) --------------------------------------------------------
int __stdcall TV_OnHitTest(int a1, int a2)
{
  int result; // eax@2

  if ( a2 )
  {
    result = TV_CheckHit(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), a2 + 8);
    *(_DWORD *)(a2 + 12) = result;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B8C1B) --------------------------------------------------------
int __stdcall TV_IsItemTruncated(int a1, int a2, int a3)
{
  int result; // eax@3

  result = 0;
  if ( TV_GetItemRect(a1, a2, a3, 1) )
  {
    *(_DWORD *)a3 -= g_cxEdge;
    *(_DWORD *)(a3 + 4) -= g_cyBorder;
    if ( *(_DWORD *)a3 + *(_WORD *)(a2 + 26) > *(_WORD *)(a1 + 190) )
      result = 1;
  }
  return result;
}

//----- (6F7B8C6D) --------------------------------------------------------
signed int __stdcall TV_HandleTTNShow(int a1, int a2)
{
  int v2; // eax@1
  WPARAM v3; // eax@4
  signed int result; // eax@6
  char v5; // [sp+8h] [bp-3Ch]@3
  char v6; // [sp+10h] [bp-34h]@3
  int v7; // [sp+14h] [bp-30h]@3
  struct tagPOINT Points; // [sp+34h] [bp-10h]@6

  v2 = *(_DWORD *)(a1 + 64);
  if ( v2 && *(_DWORD *)(a1 + 36) & 0x400 )
  {
    v7 = 16;
    TV_GetItem(a1, v2, 8, (int)&v5);
    if ( v6 & 0x10 )
      v3 = *(_DWORD *)(a1 + 124);
    else
      v3 = *(_DWORD *)(a1 + 116);
    SendMessageW(*(HWND *)(a1 + 224), 0x30u, v3, 0);
    TV_GetItemRect(a1, *(_DWORD *)(a1 + 64), (int)&Points, 1);
    MapWindowPoints(*(HWND *)a1, 0, &Points, 2u);
    Points.y += g_cyBorder;
    Points.x += g_cxLabelMargin;
    SendMessageW(*(HWND *)(a1 + 224), 0x41Fu, 1u, (LPARAM)&Points);
    SetWindowPos(*(HWND *)(a1 + 224), 0, Points.x, Points.y, 0, 0, 0x15u);
    *(_DWORD *)(a2 + 12) |= 0x10u;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7B8D3B) --------------------------------------------------------
int __stdcall TV_HandleTTCustomDraw(int a1, int a2)
{
  int v2; // eax@3
  char v3; // al@5
  int v4; // esi@5
  HGDIOBJ v5; // eax@6
  int result; // eax@7
  LPARAM lParam; // [sp+8h] [bp-4Ch]@5
  HDC hdc; // [sp+18h] [bp-3Ch]@6

  if ( *(_DWORD *)(a1 + 64) && *(_DWORD *)(a1 + 36) & 0x400 && ((v2 = *(_DWORD *)(a2 + 12), v2 == 1) || v2 == 65537) )
  {
    TreeView_BeginFakeCustomDraw(a1, (LPARAM)&lParam);
    v3 = TreeView_BeginFakeItemDraw((LPARAM)&lParam, *(_DWORD *)(a1 + 64));
    v4 = v3 & 2;
    if ( v3 & 2 )
    {
      v5 = GetCurrentObject(hdc, 6u);
      SelectObject(*(HDC *)(a2 + 16), v5);
    }
    TreeView_EndFakeItemDraw((LPARAM)&lParam);
    TreeView_EndFakeCustomDraw((LPARAM)&lParam);
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B8DBE) --------------------------------------------------------
signed int __stdcall TV_SetToolTipTarget(int a1, int a2)
{
  HWND v2; // ST00_4@2
  signed int result; // eax@2

  if ( *(_DWORD *)(a1 + 64) == a2 )
  {
    result = 0;
  }
  else
  {
    ShowWindow(*(HWND *)(a1 + 224), 0);
    UpdateWindow(*(HWND *)(a1 + 224));
    v2 = *(HWND *)(a1 + 224);
    *(_DWORD *)(a1 + 64) = a2;
    SendMessageW(v2, 0x41Du, 0, 0);
    result = 1;
  }
  return result;
}

//----- (6F7B8E14) --------------------------------------------------------
int __stdcall TV_ItemAtCursor(HWND *a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  int v4; // edi@1
  int v5; // edi@2
  struct tagPOINT Point; // [sp+8h] [bp-10h]@1
  int v7; // [sp+10h] [bp-8h]@2
  int v8; // [sp+14h] [bp-4h]@2

  GetCursorPos(&Point);
  v2 = (int)a1;
  ScreenToClient(*a1, &Point);
  result = TV_CheckHit(v2, Point.x, Point.y, (int)&a1);
  v4 = a2;
  if ( a2 )
  {
    *(_DWORD *)a2 = Point.x;
    v5 = v4 + 4;
    *(_DWORD *)v5 = Point.y;
    v5 += 4;
    *(_DWORD *)v5 = v7;
    *(_DWORD *)(v5 + 4) = v8;
  }
  if ( !((unsigned __int8)a1 & 0x46) )
    result = 0;
  return result;
}

//----- (6F7B8E68) --------------------------------------------------------
signed int __stdcall TV_UpdateToolTipTarget(int a1)
{
  int v1; // eax@1
  int v2; // ebx@1
  int v3; // edi@1
  char v5; // [sp+Ch] [bp-10h]@1

  v1 = TV_ItemAtCursor((HWND *)a1, (int)&v5);
  v2 = *(_DWORD *)(a1 + 8);
  v3 = v1;
  if ( (char)v2 >= 0 && !TV_IsItemTruncated(a1, v1, (int)&v5) && !(v2 & 0x800) )
    v3 = 0;
  return TV_SetToolTipTarget(a1, v3);
}

//----- (6F7B8EB5) --------------------------------------------------------
signed int __stdcall TV_SetInsertMark(int a1, int a2, int a3)
{
  signed int result; // eax@1

  result = ValidateTreeItem(a2, 1);
  if ( result )
  {
    TV_InvalidateInsertMarkRect(a1, 1);
    *(_DWORD *)(a1 + 68) = a2;
    *(_DWORD *)(a1 + 36) ^= (*(_DWORD *)(a1 + 36) ^ ((a3 != 0) << 12)) & 0x1000;
    TV_InvalidateInsertMarkRect(a1, 0);
    result = 1;
  }
  return result;
}

//----- (6F7B8F05) --------------------------------------------------------
BOOL __stdcall TV_GetInfoTip(int a1, int a2, int a3, const WCHAR *a4, int a5)
{
  int v5; // ecx@1
  LPARAM lParam; // [sp+8h] [bp-1Ch]@1
  LPCWSTR lpString; // [sp+14h] [bp-10h]@1
  int v9; // [sp+18h] [bp-Ch]@1
  int v10; // [sp+1Ch] [bp-8h]@1
  int v11; // [sp+20h] [bp-4h]@1

  lpString = a4;
  *a4 = 0;
  v9 = a5;
  v10 = a3;
  v11 = *(_DWORD *)(a3 + 16);
  CCSendNotify(a1, -414, (LPARAM)&lParam);
  CCSetInfoTipWidth(*(HWND *)a1, *(HWND *)(a1 + 224));
  Str_Set(a1 + 228, lpString);
  v5 = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 228);
  if ( *(_BYTE *)(a1 + 8) & 0x40 )
    *(_DWORD *)(a2 + 180) |= 4u;
  return v5 && *(_WORD *)v5;
}

//----- (6F7B8F8D) --------------------------------------------------------
int __stdcall TV_HandleNeedText(int a1, int a2)
{
  int result; // eax@1
  bool v3; // zf@1
  int v4; // edi@2
  char v5; // [sp+4h] [bp-844h]@2
  int v6; // [sp+14h] [bp-834h]@7
  int v7; // [sp+18h] [bp-830h]@7
  int v8; // [sp+20h] [bp-828h]@7
  LPCWSTR lpString; // [sp+24h] [bp-824h]@7
  int v10; // [sp+28h] [bp-820h]@7
  int v11; // [sp+40h] [bp-808h]@1
  char v12; // [sp+44h] [bp-804h]@4

  result = a2;
  v3 = *(_DWORD *)(a1 + 56) == 0;
  v11 = a2;
  if ( v3 )
  {
    result = TV_ItemAtCursor((HWND *)a1, (int)&v5);
    v4 = result;
    if ( result )
    {
      if ( *(_DWORD *)(a1 + 8) & 0x800 && (result = TV_GetInfoTip(a1, v11, result, (const WCHAR *)&v12, 1024)) != 0 )
      {
        *(_DWORD *)(a1 + 36) &= 0xFFFFFBFF;
        *(_DWORD *)(a1 + 64) = v4;
      }
      else
      {
        SendMessageW(*(HWND *)(a1 + 224), 0x418u, 0, -1);
        result = TV_IsItemTruncated(a1, v4, (int)&v5);
        if ( result )
        {
          *(_DWORD *)(a1 + 36) |= 0x400u;
          lpString = (LPCWSTR)&v12;
          *(_DWORD *)(a1 + 64) = v4;
          v7 = v4;
          v6 = 9;
          v8 = 10;
          v10 = 260;
          TV_OnGetItem(a1, (int)&v6);
          Str_Set(a1 + 228, lpString);
          result = *(_DWORD *)(a1 + 228);
          *(_DWORD *)(v11 + 12) = *(_DWORD *)(a1 + 228);
        }
      }
    }
  }
  return result;
}

//----- (6F7B90A5) --------------------------------------------------------
int __stdcall TV_HandleNeedTextA(int a1, int a2)
{
  LPCWSTR v2; // eax@3
  int result; // eax@3
  int v4; // [sp+10h] [bp-C0h]@1
  int v5; // [sp+14h] [bp-BCh]@1
  int v6; // [sp+18h] [bp-B8h]@1
  LPCWSTR lpWideCharStr; // [sp+1Ch] [bp-B4h]@1
  __int16 v8; // [sp+20h] [bp-B0h]@1
  int v9; // [sp+C0h] [bp-10h]@1
  int v10; // [sp+C4h] [bp-Ch]@1
  int v11; // [sp+C8h] [bp-8h]@1

  v8 = 0;
  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  lpWideCharStr = (LPCWSTR)&v8;
  v9 = *(_DWORD *)(a2 + 96);
  v10 = *(_DWORD *)(a2 + 100);
  v11 = *(_DWORD *)(a2 + 104);
  TV_HandleNeedText(a1, (int)&v4);
  if ( *(_DWORD *)(a1 + 232) )
    LocalFree(*(HLOCAL *)(a1 + 232));
  v2 = ProduceAFromW(*(_DWORD *)(a1 + 20), lpWideCharStr);
  *(_DWORD *)(a1 + 232) = v2;
  *(_DWORD *)(a2 + 12) = v2;
  result = v10;
  *(_DWORD *)(a2 + 100) = v10;
  return result;
}

//----- (6F7B9150) --------------------------------------------------------
HGDIOBJ __stdcall TV_OnSetBkColor(HDC hdc, COLORREF color)
{
  if ( *((_DWORD *)hdc + 41) != -1 )
    DeleteObject(*((HGDIOBJ *)hdc + 28));
  *((_DWORD *)hdc + 41) = color;
  if ( color != -1 )
    *((_DWORD *)hdc + 28) = CreateSolidBrush(color);
  return TV_CreateIndentBmps(hdc);
}

//----- (6F7B9193) --------------------------------------------------------
int __stdcall TV_TranslateAccelerator(int a1, MSG *lpMsg)
{
  bool v2; // sf@4
  WPARAM v3; // eax@4

  if ( lpMsg && GetFocus() == (HWND)a1 && lpMsg->message - 256 <= 1 )
  {
    v2 = GetKeyState(17) < 0;
    v3 = lpMsg->wParam;
    if ( v2 )
    {
      if ( v3 - 33 <= 7 )
      {
LABEL_6:
        TranslateMessage(lpMsg);
        DispatchMessageW(lpMsg);
        return 1;
      }
    }
    else if ( v3 == 8 || v3 == 13 || v3 > 0x1F && (v3 <= 0x28 || v3 > 0x69 && (v3 <= 0x6B || v3 == 109)) )
    {
      goto LABEL_6;
    }
  }
  return 0;
}

//----- (6F7B9212) --------------------------------------------------------
int __stdcall TV_SetEditSize(int a1)
{
  int result; // eax@1
  int v2; // eax@2
  struct tagRECT rc; // [sp+4h] [bp-10h]@2

  result = *(_DWORD *)(a1 + 56);
  if ( result )
  {
    TV_GetItemRect(a1, result, (int)&rc, 1);
    InflateRect(&rc, -g_cxLabelMargin, -g_cyBorder);
    v2 = SendMessageW(*(HWND *)(a1 + 216), 0x31u, 0, 0);
    result = SetEditInPlaceSize(*(HWND *)(a1 + 216), &rc, v2, 0);
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7B9278) --------------------------------------------------------
int __stdcall TV_OnCalcSize(int a1, int a2)
{
  if ( *(_DWORD *)(a2 + 12) == 2 )
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 200) * *(_WORD *)(a1 + 182);
  return 0;
}

//----- (6F7B92A6) --------------------------------------------------------
int __stdcall TV_OnScroll(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // eax@1
  int v4; // esi@1
  int v5; // edi@1
  LONG v6; // eax@3
  int v7; // edx@3
  int v8; // edi@6
  int v9; // eax@6
  int v10; // eax@8
  int v11; // eax@11
  int v12; // edi@24
  signed int v13; // eax@24
  struct tagRECT Rect; // [sp+Ch] [bp-40h]@3
  int v16; // [sp+1Ch] [bp-30h]@1
  int v17; // [sp+20h] [bp-2Ch]@1
  int v18; // [sp+24h] [bp-28h]@1
  int v19; // [sp+28h] [bp-24h]@1
  char v20; // [sp+2Ch] [bp-20h]@13
  int v21; // [sp+30h] [bp-1Ch]@13
  int v22; // [sp+38h] [bp-14h]@32
  int v23; // [sp+3Ch] [bp-10h]@1
  int v24; // [sp+40h] [bp-Ch]@1
  int v25; // [sp+44h] [bp-8h]@1
  int v26; // [sp+48h] [bp-4h]@1

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 30);
  v16 = *(_DWORD *)(a2 + 14);
  v17 = *(_DWORD *)(a2 + 18);
  v18 = *(_DWORD *)(a2 + 22);
  v19 = *(_DWORD *)(a2 + 26);
  v4 = *(_DWORD *)(a2 + 38);
  v5 = *(_DWORD *)(a2 + 42);
  v25 = v3;
  v23 = *(_DWORD *)(a2 + 34);
  v24 = v4;
  v26 = TV_CheckHit(a1, v23 + 1, v4 + 1, (int)&a2);
  if ( v25 == 1 )
  {
    TV_GetItemRect(a1, v26, (int)&v20, 1);
    if ( v21 < v4 - 1 )
    {
      if ( ValidateTreeItem(v26, 0) )
        v26 = TV_GetNextVisItem(v26);
      else
        v26 = 0;
    }
    if ( *(_BYTE *)(v2 + 12) & 2 && v4 - (v19 - v17) > 0 )
    {
      v5 = v19 - v17;
    }
    else
    {
      v5 = *(_WORD *)(a1 + 182);
      if ( v4 - v5 <= 0 )
      {
        *(_DWORD *)(v2 + 42) = v4;
        return 0;
      }
    }
    a2 = TV_CheckHit(a1, v23, v4 - v5, (int)&a2);
    if ( a2 )
    {
      v12 = v26;
      v13 = ValidateTreeItem(v26, 0);
      if ( v13 )
        v13 = TV_GetPrevVisItem(v12);
      if ( a2 == v12 && v13 )
        a2 = v13;
      if ( a2 != v13 || ValidateTreeItem(a2, 0) && (a2 = TV_GetPrevVisItem(a2)) != 0 )
      {
        TV_GetItemRect(a1, a2, (int)&v20, 1);
        v4 -= v22;
      }
      v5 = v4;
    }
    goto LABEL_34;
  }
  if ( v25 != 2 )
  {
LABEL_34:
    *(_DWORD *)(v2 + 42) = v5;
    return 0;
  }
  GetWindowRect(*(HWND *)a1, &Rect);
  v6 = Rect.bottom - Rect.top;
  v7 = v19 - v17;
  if ( *(_BYTE *)(v2 + 12) & 2 && v6 - v7 - v4 > v7 )
  {
    v5 = v19 - v17;
    goto LABEL_8;
  }
  v8 = *(_WORD *)(a1 + 182);
  v9 = v6 - v7 - v4;
  if ( v9 > v8 * *(_WORD *)(v26 + 32) )
  {
    v5 = v8 * *(_WORD *)(v26 + 32);
LABEL_8:
    v10 = TV_CheckHit(a1, v23, v4 + v5, (int)&a2);
    a2 = v10;
    if ( v10 )
    {
      if ( v10 == v26 )
      {
        if ( ValidateTreeItem(v10, 0) )
        {
          v11 = TV_GetNextVisItem(a2);
          if ( v11 )
            a2 = v11;
        }
      }
      TV_GetItemRect(a1, a2, (int)&v20, 1);
      v5 = v21 - v4;
    }
    goto LABEL_34;
  }
  *(_DWORD *)(v2 + 42) = v9;
  return 0;
}

//----- (6F7B948D) --------------------------------------------------------
void __stdcall TV_OnMouseMove(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@2
  int v5; // eax@5
  int v6; // ST0C_4@6

  v3 = a1;
  if ( *(_DWORD *)(a1 + 8) & 0x200 )
  {
    v4 = TV_CheckHit(a1, (signed __int16)a2, SHIWORD(a2), (int)&a1);
    if ( !(*(_DWORD *)(v3 + 8) & 0x1000) && !(a1 & 0x46) )
      v4 = 0;
    v5 = *(_DWORD *)(v3 + 60);
    if ( v4 != v5 )
    {
      TV_InvalidateItem(v3, v5, 1u);
      TV_InvalidateItem(v3, v4, 1u);
      v6 = *(_DWORD *)v3;
      *(_DWORD *)(v3 + 60) = v4;
      UpdateWindow((HWND)v6);
    }
  }
  if ( *(_DWORD *)(v3 + 224) )
  {
    if ( !TV_UpdateToolTip(v3) )
      RelayToToolTips(*(HWND *)(v3 + 224), *(_DWORD *)v3, 512, a3, a2);
  }
}

//----- (6F7B9525) --------------------------------------------------------
LRESULT __stdcall TV_OnWinIniChange(HDC hdc, int a2)
{
  LRESULT result; // eax@5

  if ( !a2 || a2 == 42 || a2 == 34 )
  {
    if ( *((_BYTE *)hdc + 36) & 0x40 )
      result = TV_OnSetFont(hdc, 0, 1);
    if ( !(*((_DWORD *)hdc + 9) & 0x100) )
      result = TV_SetIndent(hdc, 0);
  }
  return result;
}

//----- (6F7B956B) --------------------------------------------------------
int __stdcall TV_OnPagerControlNotify(int a1, int a2)
{
  int v2; // eax@1
  int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  if ( v2 == -902 )
  {
    result = TV_OnCalcSize(a1, a2);
  }
  else if ( v2 == -901 )
  {
    result = TV_OnScroll(a1, a2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7B95A5) --------------------------------------------------------
void __stdcall TV_SetItemRecurse(int a1, int a2, int a3)
{
  int i; // esi@1
  int v4; // eax@2

  for ( i = a2; i; i = *(_DWORD *)(i + 4) )
  {
    *(_DWORD *)(a3 + 4) = i;
    TV_SetItem(a1, a3);
    v4 = *(_DWORD *)(i + 8);
    if ( v4 )
      TV_SetItemRecurse(a1, v4, a3);
  }
}

//----- (6F7B95E5) --------------------------------------------------------
signed int __stdcall TV_HandleStateIconClick(int a1, int a2)
{
  int v2; // esi@1
  int v3; // eax@1
  int v5; // [sp+Ch] [bp-2Ch]@1
  int v6; // [sp+10h] [bp-28h]@1
  int v7; // [sp+14h] [bp-24h]@1
  unsigned int v8; // [sp+18h] [bp-20h]@1

  v8 = 61440;
  TV_GetItem(a1, a2, 8, (int)&v5);
  v2 = (unsigned __int8)(v8 >> 12) & (unsigned __int8)((unsigned int)v7 >> 12) & 0xF;
  v3 = ImageList_GetImageCount(*(HIMAGELIST *)(a1 + 88));
  v5 = 8;
  v6 = a2;
  v7 = (v2 % (v3 - 1) + 1) << 12;
  return TV_SetItem(a1, (int)&v5);
}

//----- (6F7B9652) --------------------------------------------------------
void __stdcall TV_Command(int a1, __int16 a2, HWND hWnd, int a4)
{
  HWND v4; // ecx@2

  if ( a1 )
  {
    v4 = *(HWND *)(a1 + 216);
    if ( hWnd == v4 )
    {
      switch ( a4 )
      {
        case 40:
          *(_DWORD *)(a1 + 36) |= 0x80u;
          break;
        case 41:
          *(_DWORD *)(a1 + 36) &= 0xFFFFFF7F;
          break;
        case 512:
          if ( !TV_DismissEdit(a1, 0) )
            return;
          break;
        case 1024:
          SetWindowLongW(v4, -12, 1);
          TV_SetEditSize(a1);
          break;
      }
      if ( IsWindow(hWnd) )
        SendMessageW(*(HWND *)(a1 + 4), 0x111u, (unsigned __int16)a2 | ((unsigned __int16)a4 << 16), (LPARAM)hWnd);
    }
  }
}

//----- (6F7B96EE) --------------------------------------------------------
void __stdcall TV_InitCheckBoxes(HDC hdc)
{
  LONG v1; // eax@1
  struct _IMAGELIST *v2; // edi@1
  COLORREF v3; // eax@2
  int v4; // ST08_4@3
  int v5; // [sp+8h] [bp-2Ch]@3
  int v6; // [sp+10h] [bp-24h]@3
  int v7; // [sp+14h] [bp-20h]@3

  v1 = GetWindowLongW(*(HWND *)hdc, -20);
  v2 = CreateCheckBoxImagelist(*((HIMAGELIST *)hdc + 21), 1, (HICON)1, v1 & 0x400000);
  if ( *((_DWORD *)hdc + 21) )
  {
    v3 = ImageList_GetBkColor(*((HIMAGELIST *)hdc + 21));
    ImageList_SetBkColor(v2, v3);
  }
  TV_SetImageList(hdc, v2, 2);
  v4 = *((_DWORD *)hdc + 10);
  v5 = 8;
  v6 = 4096;
  v7 = 61440;
  TV_SetItemRecurse((int)hdc, v4, (int)&v5);
}

//----- (6F7B9763) --------------------------------------------------------
LRESULT __stdcall TV_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax@1
  int v5; // eax@1

  v4 = GetParent(hWnd);
  v5 = GetWindowLongW(v4, 0);
  if ( v5 )
  {
    if ( Msg == 256 )
    {
      if ( wParam == 13 )
      {
        TV_DismissEdit(v5, 0);
      }
      else
      {
        if ( wParam != 27 )
          return CallWindowProcW(*(WNDPROC *)(v5 + 220), hWnd, Msg, wParam, lParam);
        TV_DismissEdit(v5, 1);
      }
    }
    else if ( Msg != 258 || wParam != 13 )
    {
      return CallWindowProcW(*(WNDPROC *)(v5 + 220), hWnd, Msg, wParam, lParam);
    }
  }
  return 0;
}

//----- (6F7B97D0) --------------------------------------------------------
int __stdcall TV_EditLabel(int a1, int a2, const WCHAR *a3)
{
  bool v3; // zf@1
  WPARAM v5; // eax@5
  const WCHAR *v6; // ecx@7
  HWND v7; // eax@9
  LPARAM lParam; // [sp+8h] [bp-244h]@12
  int v9; // [sp+14h] [bp-238h]@4
  int v10; // [sp+18h] [bp-234h]@12
  int v11; // [sp+1Ch] [bp-230h]@4
  int v12; // [sp+20h] [bp-22Ch]@4
  char *v13; // [sp+24h] [bp-228h]@4
  int v14; // [sp+28h] [bp-224h]@4
  int v15; // [sp+38h] [bp-214h]@12
  LPCWSTR lpWindowName; // [sp+3Ch] [bp-210h]@1
  char v17; // [sp+40h] [bp-20Ch]@4

  v3 = (*(_BYTE *)(a1 + 8) & 8) == 0;
  lpWindowName = a3;
  if ( v3 || !ValidateTreeItem(a2, 0) )
    return 0;
  TV_DismissEdit(a1, 0);
  v13 = &v17;
  v14 = 260;
  v12 = 16;
  TV_GetItem(a1, a2, 9, (int)&v9);
  if ( v11 & 0x10 )
    v5 = *(_DWORD *)(a1 + 124);
  else
    v5 = *(_DWORD *)(a1 + 116);
  v6 = lpWindowName;
  if ( !lpWindowName )
    v6 = (const WCHAR *)v13;
  v7 = CreateEditInPlaceWindow(*(HWND *)a1, v6, 0x103u, 0x44800080u, v5);
  *(_DWORD *)(a1 + 216) = v7;
  if ( v7 )
  {
    if ( lpWindowName )
      SetWindowLongW(v7, -12, 1);
    v11 = *(_WORD *)(a2 + 20);
    v15 = *(_DWORD *)(a2 + 16);
    v10 = a2;
    v9 = 29;
    if ( CCSendNotify(a1, -459, (LPARAM)&lParam) )
    {
      DestroyWindow(*(HWND *)(a1 + 216));
      *(_DWORD *)(a1 + 216) = 0;
      return 0;
    }
    TV_PopBubble(a1);
    TV_ScrollIntoView(a1, a2);
    *(_DWORD *)(a1 + 220) = SetWindowLongW(*(HWND *)(a1 + 216), -4, (LONG)TV_EditWndProc);
    *(_DWORD *)(a1 + 56) = a2;
    TV_SetEditSize(a1);
    SetFocus(*(HWND *)(a1 + 216));
    ShowWindow(*(HWND *)(a1 + 216), 5);
    TV_InvalidateItem(a1, a2, 5u);
    RescrollEditWindow(*(HWND *)(a1 + 216));
  }
  return *(_DWORD *)(a1 + 216);
}

//----- (6F7B9968) --------------------------------------------------------
int __stdcall TV_Timer(int a1, int a2)
{
  if ( a2 == 42 )
  {
    KillTimer(*(HWND *)a1, 0x2Au);
    if ( *(_BYTE *)(a1 + 36) & 8 )
    {
      if ( !TV_EditLabel(a1, *(_DWORD *)(a1 + 44), 0) )
        TV_DismissEdit(a1, 0);
      *(_DWORD *)(a1 + 36) &= 0xFFFFFFF7;
    }
  }
  else if ( a2 == 43 )
  {
    KillTimer(*(HWND *)a1, 0x2Bu);
    if ( *(_BYTE *)(a1 + 36) & 0x20 )
    {
      if ( *(_DWORD *)(a1 + 44) )
        TV_ScrollVertIntoView(a1, *(_DWORD *)(a1 + 44));
      *(_DWORD *)(a1 + 36) &= 0xFFFFFFDF;
    }
  }
  return 0;
}

//----- (6F7B99D9) --------------------------------------------------------
int __stdcall TV_OnImeComposition(int a1, int a2, int a3)
{
  HWND v3; // ST10_4@1
  int v4; // eax@3
  void *v5; // edi@3
  int v6; // eax@8
  int v7; // eax@9
  int v8; // eax@14
  int v9; // edi@16
  signed int v10; // ebx@16
  int v11; // eax@20
  int v12; // eax@23
  char v14; // [sp+Ch] [bp-250h]@21
  PCNZWCH lpString2; // [sp+1Ch] [bp-240h]@19
  int v16; // [sp+20h] [bp-23Ch]@16
  HLOCAL hMem; // [sp+38h] [bp-224h]@6
  int v18; // [sp+3Ch] [bp-220h]@1
  int v19; // [sp+40h] [bp-21Ch]@1
  HIMC v20; // [sp+44h] [bp-218h]@1
  PCNZWCH lpString1; // [sp+48h] [bp-214h]@1
  LPCWSTR lpString; // [sp+4Ch] [bp-210h]@4
  char v23; // [sp+50h] [bp-20Ch]@19

  v3 = *(HWND *)a1;
  v19 = 0;
  lpString1 = 0;
  v18 = 1;
  v20 = ImmGetContext(v3);
  if ( v20 )
  {
    if ( a3 & 0x800 )
    {
      v18 = 0;
      v4 = (int)GET_COMP_STRING(v20, 0x800u);
      v5 = (void *)v4;
      if ( v4 )
      {
        IncrementSearchImeCompStr(a1 + 236, 0, v4, (int)&lpString);
        LocalFree(v5);
      }
    }
    if ( a3 & 8 )
    {
      v18 = 1;
      hMem = GET_COMP_STRING(v20, 8u);
      if ( hMem )
      {
        if ( IncrementSearchImeCompStr(a1 + 236, 1, (int)hMem, (int)&lpString) )
        {
          v6 = *(_DWORD *)(a1 + 44);
          if ( !v6 )
          {
            v7 = *(_DWORD *)(a1 + 40);
            if ( !v7 )
              return 1;
            v6 = *(_DWORD *)(v7 + 8);
            if ( !v6 )
              return 1;
          }
          *(_DWORD *)(a1 + 72) = v6;
        }
        if ( lpString )
        {
          if ( *lpString )
          {
            v8 = *(_DWORD *)(a1 + 40);
            if ( v8 )
            {
              if ( *(_DWORD *)(v8 + 8) )
              {
                v9 = *(_DWORD *)(a1 + 72);
                v16 = 260;
                v10 = lstrlenW(lpString);
                if ( v10 > 1 && SameChars((int)lpString, *lpString) )
                  lpString1 = &lpString[v10 - 1];
                while ( 1 )
                {
                  lpString2 = (PCNZWCH)&v23;
                  v9 = TV_GetNextVisItem(v9);
                  if ( !v9 )
                  {
                    v11 = *(_DWORD *)(a1 + 40);
                    ++v19;
                    v9 = *(_DWORD *)(v11 + 8);
                  }
                  TV_GetItem(a1, v9, 1, (int)&v14);
                  if ( lpString2 != (PCNZWCH)-1 && HIWORD(lpString2) )
                  {
                    v12 = IntlStrEqWorkerW(0, lpString, lpString2, v10);
                    if ( v12 )
                      goto LABEL_32;
                    if ( !lpString1 )
                      goto LABEL_28;
                    if ( IntlStrEqWorkerW(0, lpString1, lpString2, 1)
                      && BetweenItems(a1, v9, *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 72)) )
                    {
LABEL_32:
                      TV_SelectItem(a1, 9, v9, 3, 2);
                      CCNotifyNavigationKeyUsage(a1, 1u);
                      return 1;
                    }
                  }
                  v12 = 0;
LABEL_28:
                  if ( v19 >= 2 )
                  {
                    if ( lpString1 == (PCNZWCH)v12 )
                    {
                      IncrementSearchBeep(a1 + 236);
                    }
                    else
                    {
                      IncrementSearchString(a1 + 236, v12, v12);
                      TV_OnImeComposition(a1, a2, a3);
                    }
                    CCNotifyNavigationKeyUsage(a1, 1u);
                    LocalFree(hMem);
                    goto LABEL_35;
                  }
                }
              }
            }
          }
        }
        return 1;
      }
    }
LABEL_35:
    ImmReleaseContext(*(HWND *)a1, v20);
  }
  return v18;
}

//----- (6F7B9C63) --------------------------------------------------------
signed int __stdcall TV_OnChar(int a1, int a2, int a3)
{
  signed int result; // eax@1
  int v4; // edi@11
  signed int v5; // ebx@11
  int v6; // eax@15
  int v7; // eax@18
  char v8; // [sp+8h] [bp-244h]@16
  PCNZWCH lpString2; // [sp+18h] [bp-234h]@14
  int v10; // [sp+1Ch] [bp-230h]@11
  int v11; // [sp+34h] [bp-218h]@1
  PCNZWCH lpString1; // [sp+38h] [bp-214h]@1
  LPCWSTR lpString; // [sp+3Ch] [bp-210h]@1
  char v14; // [sp+40h] [bp-20Ch]@14

  lpString = 0;
  v11 = 0;
  lpString1 = 0;
  result = IncrementSearchString(a1 + 236, a2, (int)&lpString);
  if ( result || !*(_DWORD *)(a1 + 72) )
  {
    result = *(_DWORD *)(a1 + 44);
    if ( !result )
    {
      result = *(_DWORD *)(a1 + 40);
      if ( !result )
        return result;
      result = *(_DWORD *)(result + 8);
      if ( !result )
        return result;
    }
    *(_DWORD *)(a1 + 72) = result;
  }
  if ( !lpString )
    return result;
  if ( !*lpString )
    return result;
  result = *(_DWORD *)(a1 + 40);
  if ( !result || !*(_DWORD *)(result + 8) )
    return result;
  v4 = *(_DWORD *)(a1 + 72);
  v10 = 260;
  v5 = lstrlenW(lpString);
  if ( v5 > 1 && SameChars((int)lpString, *lpString) )
    lpString1 = &lpString[v5 - 1];
  do
  {
    lpString2 = (PCNZWCH)&v14;
    v4 = TV_GetNextVisItem(v4);
    if ( !v4 )
    {
      v6 = *(_DWORD *)(a1 + 40);
      ++v11;
      v4 = *(_DWORD *)(v6 + 8);
    }
    TV_GetItem(a1, v4, 1, (int)&v8);
    if ( lpString2 == (PCNZWCH)-1 || !HIWORD(lpString2) )
      goto LABEL_22;
    v7 = IntlStrEqWorkerW(0, lpString, lpString2, v5);
    if ( v7 )
      goto LABEL_26;
    if ( lpString1 )
    {
      if ( IntlStrEqWorkerW(0, lpString1, lpString2, 1)
        && BetweenItems(a1, v4, *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 72)) )
      {
LABEL_26:
        TV_SelectItem(a1, 9, v4, 3, 2);
        return CCNotifyNavigationKeyUsage(a1, 1u);
      }
LABEL_22:
      v7 = 0;
    }
  }
  while ( v11 < 2 );
  if ( lpString1 == (PCNZWCH)v7 )
  {
    IncrementSearchBeep(a1 + 236);
  }
  else
  {
    IncrementSearchString(a1 + 236, v7, v7);
    TV_OnChar(a1, a2, a3);
  }
  return CCNotifyNavigationKeyUsage(a1, 1u);
}

//----- (6F7B9E3B) --------------------------------------------------------
BOOL __stdcall TV_CheckForDragBegin(int a1, int a2, int a3, int a4)
{
  int v4; // eax@3

  if ( a2 == *(_DWORD *)(a1 + 44) )
  {
    *(_DWORD *)(a1 + 52) = 0;
    *(_DWORD *)(a1 + 36) &= 0xFFFFDFFF;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 36) |= 0x2000u;
    *(_DWORD *)(a1 + 52) = v4;
    TV_SelectItem(a1, 8, a2, 0, 1);
  }
  return CheckForDragBegin(*(HWND *)a1, a3, a4) && (a2 == *(_DWORD *)(a1 + 48) || a2 == *(_DWORD *)(a1 + 44));
}

//----- (6F7B9EA1) --------------------------------------------------------
signed int __stdcall TV_FinishCheckDrag(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@2

  result = a1;
  v2 = *(_DWORD *)(a1 + 36);
  if ( v2 & 0x2000 )
  {
    v3 = *(_DWORD *)(a1 + 52);
    *(_DWORD *)(a1 + 52) = 0;
    *(_DWORD *)(a1 + 36) = v2 & 0xFFFFDFFF;
    result = TV_SelectItem(a1, 8, v3, 0, 1);
  }
  return result;
}

//----- (6F7B9EDA) --------------------------------------------------------
int __stdcall TV_SendRButtonDown(HWND hWnd, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // ebx@1
  int result; // eax@1
  int v7; // ST10_4@4
  DWORD v8; // eax@8

  v3 = (int)hWnd;
  v4 = 0;
  v5 = TV_CheckHit((int)hWnd, a2, a3, (int)&hWnd);
  hWnd = *(HWND *)v3;
  result = TV_DismissEdit(v3, 0);
  if ( result )
  {
    GetMessagePosClient(*(HWND *)v3, (LPPOINT)(v3 + 152));
    if ( TV_CheckForDragBegin(v3, v5, a2, a3) )
    {
      if ( v5 )
      {
        v7 = a3;
        *(_DWORD *)(v3 + 76) = v5;
        TV_SendBeginDrag(v3, -457, v5, a2, v7);
      }
    }
    else
    {
      result = IsWindow(hWnd);
      if ( !result )
        return result;
      SetFocus(*(HWND *)v3);
      v4 = CCSendNotify(v3, -5, 0) == 0;
    }
    result = TV_FinishCheckDrag(v3);
    if ( v4 )
    {
      v8 = GetMessagePos();
      result = SendMessageW(*(HWND *)(v3 + 4), 0x7Bu, *(_DWORD *)v3, v8);
    }
  }
  return result;
}

//----- (6F7B9F93) --------------------------------------------------------
int __stdcall TV_DoExpandRecurse(int a1, int a2, signed int a3)
{
  int v3; // esi@5
  int v4; // esi@10
  int p; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@4
  int v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  if ( TV_StartWatch(a1, &p, a2) )
  {
    while ( 1 )
    {
      v4 = p;
      if ( !p )
        break;
      if ( GetAsyncKeyState(27) & 1 )
        goto LABEL_12;
      TV_Expand(a1, 2u, v4, a3);
      if ( !v7 )
      {
        v3 = *(_DWORD *)(v4 + 8);
        if ( !v3 )
          goto LABEL_16;
        if ( !TV_DoExpandRecurse(a1, v3, a3) )
          goto LABEL_12;
        if ( !v7 )
LABEL_16:
          p = *(_DWORD *)(p + 4);
      }
      v7 = 0;
    }
    v8 = 1;
LABEL_12:
    TV_EndWatch(a1, (int)&p);
  }
  return v8;
}

//----- (6F7BA023) --------------------------------------------------------
int __stdcall TV_ExpandRecurse(int a1, int a2, signed int a3)
{
  int v3; // esi@1

  v3 = (*(_DWORD *)(a1 + 36) >> 4) & 1;
  TV_OnSetRedraw(a1, 0);
  GetAsyncKeyState(27);
  TV_Expand(a1, 2u, a2, a3);
  TV_DoExpandRecurse(a1, *(_DWORD *)(a2 + 8), a3);
  return TV_OnSetRedraw(a1, v3);
}

//----- (6F7BA075) --------------------------------------------------------
int __stdcall TV_KeyDown(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // eax@7
  unsigned int v6; // eax@23
  int v7; // eax@24
  int v8; // eax@25
  int v9; // eax@28
  int v10; // ecx@29
  int v11; // eax@29
  int v12; // eax@35
  int v13; // eax@54
  int v14; // eax@57
  unsigned int v16; // [sp-Ch] [bp-4Ch]@52
  int v17; // [sp-8h] [bp-48h]@3
  int v18; // [sp-8h] [bp-48h]@52
  signed int v19; // [sp-4h] [bp-44h]@6
  struct tagMSG Msg; // [sp+Ch] [bp-34h]@71
  LPARAM lParam; // [sp+28h] [bp-18h]@1
  __int16 v22; // [sp+34h] [bp-Ch]@1
  int v23; // [sp+3Ch] [bp-4h]@1
  int v24; // [sp+48h] [bp+8h]@1

  v3 = a1;
  v23 = 1;
  v22 = a2;
  v24 = (int)CCSendNotify(a1, -412, (LPARAM)&lParam);
  v4 = RTLSwapLeftRightArrows(v3, a2);
  if ( GetKeyState(17) < 0 )
  {
    switch ( v4 )
    {
      case 37:
        v17 = 0;
        goto LABEL_4;
      case 39:
        v17 = 1;
LABEL_4:
        TV_HorzScroll(v3, v17, 0);
        goto LABEL_68;
      case 33:
        v19 = 2;
        goto LABEL_7;
      case 36:
        v19 = 6;
        goto LABEL_7;
      case 34:
        v19 = 3;
        goto LABEL_7;
      case 35:
        v19 = 7;
LABEL_7:
        v5 = v19;
        break;
      case 38:
        v5 = 0;
        break;
      case 40:
        v5 = 1;
        break;
      default:
        goto LABEL_49;
    }
    TV_VertScroll(v3, v5, 0);
    goto LABEL_68;
  }
  if ( (unsigned int)v4 > 0x25 )
  {
    if ( v4 == 38 )
    {
      if ( *(_DWORD *)(v3 + 44) )
      {
        v7 = TV_GetPrevVisItem(*(_DWORD *)(v3 + 44));
        goto LABEL_66;
      }
    }
    else
    {
      if ( v4 == 39 )
      {
        v13 = *(_DWORD *)(v3 + 44);
        if ( v13 && !(*(_BYTE *)(v13 + 20) & 0x20) )
          goto LABEL_56;
      }
      else if ( v4 != 40 )
      {
        if ( v4 == 106 )
        {
          v14 = *(_DWORD *)(v3 + 44);
          if ( v14 )
          {
            v24 = 1;
            TV_ExpandRecurse(v3, v14, 1);
          }
          goto LABEL_68;
        }
        if ( v4 != 107 )
        {
          if ( v4 != 109 )
            goto LABEL_49;
          v12 = *(_DWORD *)(v3 + 44);
          if ( !v12 )
            goto LABEL_68;
          v24 = 1;
LABEL_52:
          v18 = v12;
          v16 = 1;
LABEL_53:
          TV_Expand(v3, v16, v18, 1);
          goto LABEL_68;
        }
        v13 = *(_DWORD *)(v3 + 44);
        if ( !v13 )
          goto LABEL_68;
        v24 = 1;
LABEL_56:
        v18 = v13;
        v16 = 2;
        goto LABEL_53;
      }
      if ( *(_DWORD *)(v3 + 44) )
      {
        v7 = TV_GetNextVisItem(*(_DWORD *)(v3 + 44));
        goto LABEL_66;
      }
    }
    v7 = *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8);
LABEL_66:
    if ( v7 )
      TV_SelectItem(v3, 9, v7, 3, 2);
    goto LABEL_68;
  }
  if ( v4 == 37 )
  {
    v12 = *(_DWORD *)(v3 + 44);
    if ( !v12 )
      goto LABEL_68;
    if ( !(*(_BYTE *)(v12 + 20) & 0x20) )
    {
      if ( !v12 || !*(_BYTE *)(v12 + 30) )
        goto LABEL_68;
      goto LABEL_42;
    }
    goto LABEL_52;
  }
  if ( v4 == 8 )
  {
    v12 = *(_DWORD *)(v3 + 44);
    v24 = 1;
    if ( !v12 || !*(_BYTE *)(v12 + 30) )
      goto LABEL_69;
LABEL_42:
    v7 = *(_DWORD *)v12;
    goto LABEL_66;
  }
  if ( v4 == 13 )
  {
    v24 = (int)CCSendNotify(v3, -4, 0);
    goto LABEL_68;
  }
  if ( v4 != 32 )
  {
    if ( v4 == 33 )
    {
      v9 = *(_DWORD *)(v3 + 44);
      if ( v9 )
      {
        v10 = *(_WORD *)(v3 + 196);
        v11 = *(_WORD *)(v9 + 28);
        if ( v11 > v10 - 1 )
        {
          v6 = v11 - v10 + 1;
          goto LABEL_24;
        }
      }
      goto LABEL_23;
    }
    if ( v4 == 34 )
    {
      v8 = *(_DWORD *)(v3 + 44);
      if ( !v8 )
        goto LABEL_23;
      v6 = *(_WORD *)(v8 + 28) + *(_WORD *)(v3 + 196) - 1;
      if ( v6 < *(_DWORD *)(v3 + 200) )
        goto LABEL_24;
    }
    else if ( v4 != 35 )
    {
      if ( v4 == 36 )
      {
LABEL_23:
        v6 = 0;
LABEL_24:
        v7 = TV_GetShownIndexItem(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 8), v6);
        goto LABEL_66;
      }
LABEL_49:
      v23 = 0;
      goto LABEL_68;
    }
    v6 = *(_DWORD *)(v3 + 200) - 1;
    goto LABEL_24;
  }
  if ( *(_DWORD *)(v3 + 8) & 0x100 && *(_DWORD *)(v3 + 44) )
  {
    TV_HandleStateIconClick(v3, *(_DWORD *)(v3 + 44));
    v24 = 1;
  }
LABEL_68:
  if ( v24 )
  {
LABEL_69:
    ++*(_DWORD *)(v3 + 96);
    goto LABEL_73;
  }
  for ( ; *(_DWORD *)(v3 + 96) > 0; --*(_DWORD *)(v3 + 96) )
  {
    if ( !PeekMessageW(&Msg, *(HWND *)v3, 0x102u, 0x102u, 1u) )
      break;
  }
LABEL_73:
  if ( v4 != 18 )
    CCNotifyNavigationKeyUsage(v3, 1u);
  return v23;
}

//----- (6F7BA31E) --------------------------------------------------------
int __stdcall TV_ButtonDown(int a1, int a2, char a3, signed int a4, signed int a5, char a6)
{
  HWND v6; // ST10_4@1
  int result; // eax@1
  int v8; // edi@2
  unsigned int v9; // ecx@4
  signed int v10; // ebx@6
  int v11; // ecx@7
  int v12; // eax@8
  HWND v13; // ebx@10
  BOOL v14; // ebx@25
  UINT v15; // eax@34
  int v16; // [sp-Ch] [bp-64h]@17
  signed int v17; // [sp-8h] [bp-60h]@17
  HWND hWnd; // [sp+Ch] [bp-4Ch]@2
  HWND hWnda; // [sp+Ch] [bp-4Ch]@23
  int v20; // [sp+10h] [bp-48h]@2
  LPARAM lParam; // [sp+14h] [bp-44h]@10
  int v22; // [sp+50h] [bp-8h]@1

  v6 = *(HWND *)a1;
  v22 = 1;
  GetMessagePosClient(v6, (LPPOINT)(a1 + 152));
  result = TV_DismissEdit(a1, 0);
  if ( result )
  {
    v8 = TV_CheckHit(a1, a4, a5, (int)&v20);
    hWnd = *(HWND *)a1;
    if ( a2 == 515 )
    {
      result = TV_CancelEditTimer(a1);
      if ( !(v20 & 0x56) )
      {
        v9 = *(_DWORD *)(a1 + 8);
        if ( !(v9 & 2)
          || !(v20 & 8)
          || (v10 = *(_WORD *)(a1 + 188), v20 = a4 % v10, result = abs(a4 % v10 - v10 / 2), result > g_cxDoubleClk) )
        {
LABEL_14:
          *(_DWORD *)(a1 + 36) &= 0xFFFFFFDF;
          goto LABEL_38;
        }
        v11 = *(_BYTE *)(v8 + 30) + ((v9 >> 2) & 1) - a4 / v10;
        if ( v11 > 1 )
        {
          v12 = v11 - 1;
          do
          {
            --v12;
            v8 = *(_DWORD *)v8;
          }
          while ( v12 );
        }
      }
      v13 = CCSendNotify(a1, (a3 & 2) != 0 ? -6 : -3, (LPARAM)&lParam);
      result = IsWindow(hWnd);
      if ( !result )
        return result;
      if ( !v13 && !(*(_DWORD *)(a1 + 8) & 0x400) )
        result = TV_Expand(a1, 3u, v8, 1);
      goto LABEL_14;
    }
    if ( v20 == 16 )
    {
      result = (int)CCSendNotify(a1, -2, 0);
      if ( result )
        goto LABEL_38;
      v17 = 1;
      v16 = v8;
      if ( a6 & 1 )
      {
        LOBYTE(result) = (a6 & 2) != 0;
        result = TV_Expand(a1, result + 1, v8, 1);
        goto LABEL_38;
      }
    }
    else
    {
      if ( !(v20 & 0x46) && (!(*(_DWORD *)(a1 + 8) & 0x1000) || !(v20 & 0x28)) )
      {
        result = (int)CCSendNotify(a1, -2, 0);
        goto LABEL_38;
      }
      hWnda = (HWND)(v8 == *(_DWORD *)(a1 + 44));
      if ( !(a6 & 1) && !(*(_BYTE *)(a1 + 8) & 0x10) )
      {
        v14 = TV_CheckForDragBegin(a1, v8, a4, a5);
        TV_FinishCheckDrag(a1);
        if ( v14 )
        {
          *(_DWORD *)(a1 + 76) = v8;
          return (int)TV_SendBeginDrag(a1, -456, v8, a4, a5);
        }
      }
      result = (int)CCSendNotify(a1, -2, 0);
      if ( result )
        goto LABEL_38;
      if ( v20 == 64 && *(_DWORD *)(a1 + 8) & 0x100 )
      {
        result = TV_HandleStateIconClick(a1, v8);
        goto LABEL_38;
      }
      result = TV_SelectItem(a1, 9, v8, 3, 1);
      if ( !hWnda )
        goto LABEL_38;
      if ( v20 & 4 && *(_BYTE *)(a1 + 36) & 4 )
      {
        v15 = GetDoubleClickTime();
        result = SetTimer(*(HWND *)a1, 0x2Au, v15, 0);
        *(_DWORD *)(a1 + 36) |= 8u;
      }
      if ( !(*(_DWORD *)(a1 + 8) & 0x400) )
        goto LABEL_38;
      v17 = 1;
      v16 = *(_DWORD *)(a1 + 44);
    }
    result = TV_Expand(a1, 3u, v16, v17);
LABEL_38:
    if ( !(*(_BYTE *)(a1 + 36) & 4) )
      result = (int)SetFocus(*(HWND *)a1);
  }
  return result;
}
// 6F7E6978: using guessed type int g_cxDoubleClk;

//----- (6F7BA572) --------------------------------------------------------
int __stdcall VertSmoothScrollWindow(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ebx@2
  int *v11; // esi@4
  int result; // eax@7
  int dy; // [sp+Ch] [bp-58h]@7
  int v14; // [sp+10h] [bp-54h]@7
  int v15; // [sp+14h] [bp-50h]@7
  int v16; // [sp+18h] [bp-4Ch]@7
  int v17; // [sp+1Ch] [bp-48h]@7
  int *v18; // [sp+20h] [bp-44h]@7
  int *v19; // [sp+24h] [bp-40h]@7
  int v20; // [sp+28h] [bp-3Ch]@7
  int v21; // [sp+2Ch] [bp-38h]@7
  int v22; // [sp+30h] [bp-34h]@7
  int v23; // [sp+34h] [bp-30h]@7
  int v24; // [sp+38h] [bp-2Ch]@7
  int v25; // [sp+3Ch] [bp-28h]@7
  int v26; // [sp+40h] [bp-24h]@7
  int v27; // [sp+44h] [bp-20h]@5
  int v28; // [sp+48h] [bp-1Ch]@5
  int v29; // [sp+4Ch] [bp-18h]@5
  int v30; // [sp+50h] [bp-14h]@5
  int v31; // [sp+54h] [bp-10h]@3
  int v32; // [sp+58h] [bp-Ch]@3
  int v33; // [sp+5Ch] [bp-8h]@3
  int v34; // [sp+60h] [bp-4h]@3

  if ( a9 )
  {
    v10 = a3;
    a3 = a2;
    if ( a4 )
    {
      v31 = *a4;
      v32 = a4[1];
      v33 = a4[2];
      v34 = a4[3];
      a4 = &v31;
      FlipRect((int)&v31);
    }
    v11 = (int *)a5;
    if ( a5 )
    {
      v27 = *(_DWORD *)a5;
      v28 = *(_DWORD *)(a5 + 4);
      v29 = *(_DWORD *)(a5 + 8);
      v30 = *(_DWORD *)(a5 + 12);
      v11 = &v27;
      FlipRect((int)&v27);
    }
  }
  else
  {
    v11 = (int *)a5;
    v10 = a2;
  }
  v23 = -1;
  v15 = a1;
  v17 = a3;
  v18 = a4;
  v20 = a6;
  v22 = a8;
  v19 = v11;
  v24 = a10;
  v25 = a10;
  dy = 56;
  v14 = 4;
  v16 = v10;
  v21 = a7;
  v26 = 0;
  result = SmoothScrollWindow((int)&dy);
  if ( a9 )
  {
    if ( a7 )
      result = FlipRect(a7);
  }
  return result;
}

//----- (6F7BA637) --------------------------------------------------------
int __stdcall VFlipRect(int a1, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12) - *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12) - v3;
  return result;
}

//----- (6F7BA667) --------------------------------------------------------
int __stdcall VertImageList_GetIconSize(HIMAGELIST himl, int *a2, int *cy, int a4)
{
  int result; // eax@1

  result = ImageList_GetIconSize(himl, a2, cy);
  if ( a4 )
  {
    result = *cy;
    *cy = *a2;
    *a2 = result;
  }
  return result;
}

//----- (6F7BA697) --------------------------------------------------------
BOOL __stdcall VertImageList_Draw(HIMAGELIST himl, int i, HDC hdcDst, int x, int a5, UINT fStyle, int a7)
{
  int v7; // ecx@2

  if ( a7 )
  {
    v7 = x;
    x = a5;
  }
  else
  {
    v7 = a5;
  }
  return ImageList_Draw(himl, i, hdcDst, x, v7, fStyle);
}

//----- (6F7BA6CE) --------------------------------------------------------
int __stdcall Tab_ImageList_Draw(int cy, int i, HDC hdcDst, int x, int a5, UINT fStyle)
{
  int v6; // esi@1
  int v7; // eax@1
  char v9; // [sp+8h] [bp-14h]@3
  int v10; // [sp+Ch] [bp-10h]@3
  int v11; // [sp+14h] [bp-8h]@3
  int v12; // [sp+18h] [bp-4h]@1

  v6 = cy;
  VertImageList_GetIconSize(*(HIMAGELIST *)(cy + 128), &v12, &cy, *(_DWORD *)(cy + 8) & 0x80);
  v7 = a5;
  if ( *(_BYTE *)(v6 + 8) & 2 )
    v7 = cy + a5;
  v11 = v7;
  v10 = v7;
  Tab_VFlipRect(v6, (int)&v9);
  return VertImageList_Draw(*(HIMAGELIST *)(v6 + 128), i, hdcDst, x, v10, fStyle, *(_DWORD *)(v6 + 8) & 0x80);
}

//----- (6F7BA740) --------------------------------------------------------
int __stdcall Tab_DrawTextEx(HDC hdc, LPWSTR lpchText, int cchText, int a4, UINT format, LPDRAWTEXTPARAMS lpdtp, int a7)
{
  struct tagRECT rc; // [sp+8h] [bp-10h]@1

  rc.left = *(_DWORD *)a4;
  rc.top = *(_DWORD *)(a4 + 4);
  rc.right = *(_DWORD *)(a4 + 8);
  rc.bottom = *(_DWORD *)(a4 + 12);
  Tab_VDFlipRect(a7, (int)&rc);
  if ( *(_BYTE *)(a7 + 8) & 0x80 )
    format |= 8u;
  if ( CCGetUIState(a7) & 2 )
    format |= 0x100000u;
  return DrawTextExW(hdc, lpchText, cchText, &rc, format, lpdtp);
}

//----- (6F7BA7A0) --------------------------------------------------------
BOOL __stdcall VertDrawFocusRect(HDC hDC, int a2, int a3)
{
  RECT rc; // [sp+8h] [bp-10h]@1

  rc.left = *(_DWORD *)a2;
  rc.top = *(_DWORD *)(a2 + 4);
  rc.right = *(_DWORD *)(a2 + 8);
  rc.bottom = *(_DWORD *)(a2 + 12);
  if ( a3 )
    FlipRect((int)&rc);
  return DrawFocusRect(hDC, &rc);
}

//----- (6F7BA7DB) --------------------------------------------------------
int __stdcall Tab_DrawFocusRect(HDC hDC, int a2, int a3)
{
  int v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+Ch] [bp-Ch]@1
  int v6; // [sp+10h] [bp-8h]@1
  int v7; // [sp+14h] [bp-4h]@1

  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)(a2 + 12);
  Tab_VFlipRect(a3, (int)&v4);
  return VertDrawFocusRect(hDC, (int)&v4, *(_DWORD *)(a3 + 8) & 0x80);
}

//----- (6F7BA81C) --------------------------------------------------------
int __stdcall Tab_InterButtonGap(int a1)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 + 8) & 8 )
    result = 5 * g_cxEdge;
  else
    result = 3 * g_cxEdge / 2;
  return result;
}

//----- (6F7BA845) --------------------------------------------------------
signed int __stdcall BorrowOne(int a1, int a2, signed int a3, int a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // eax@2
  int v8; // ecx@5
  int v9; // edx@5
  int v10; // eax@5
  int v11; // eax@5
  signed int v12; // edx@5
  int i; // ecx@5
  signed int v14; // esi@9
  int v15; // esi@11
  int v16; // eax@11
  int v18; // [sp+Ch] [bp-4h]@4

  while ( 1 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
    v5 = *(_DWORD *)(v4 + 4 * a3);
    v6 = *(_DWORD *)(v4 + 4 * a2);
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
      v7 = Tab_InterButtonGap(a1);
    else
      v7 = 2 * g_cxEdge;
    v18 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
    if ( *(_DWORD *)(a1 + 80) - *(_DWORD *)(*(_DWORD *)(v18 + 4 * a2) + 8) < v7 + *(_DWORD *)(v5 + 8) - *(_DWORD *)v5 )
      return 0;
    v8 = *(_DWORD *)v5 - **(_DWORD **)(4 * a3 + v18 + 4);
    *(_DWORD *)v5 -= v8;
    *(_DWORD *)(v5 + 8) -= v8;
    v9 = *(_DWORD *)v5;
    v10 = *(_DWORD *)(v5 + 8);
    *(_DWORD *)(v5 + 4) = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v5 + 12) = *(_DWORD *)(v6 + 12);
    v11 = v10 - v9;
    v12 = a3;
    *(_DWORD *)(v5 + 40) = *(_DWORD *)(v6 + 40);
    for ( i = a3 + 1; i <= a2; ++i )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * i);
      *(_DWORD *)v5 += v11;
      *(_DWORD *)(v5 + 8) += v11;
    }
    if ( !a4 )
      break;
    v14 = *(_DWORD *)(v5 + 40);
    if ( v14 <= 1 )
      return 0;
    a2 = a3 - 1;
    if ( a3 )
    {
      v15 = v14 - 1;
      v16 = 4 * a3 + *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
      while ( 1 )
      {
        v16 -= 4;
        --v12;
        a3 = v12;
        if ( *(_DWORD *)(*(_DWORD *)v16 + 40) != v15 )
          break;
        if ( v12 <= 0 )
          return 0;
      }
    }
    else
    {
      a3 = -1;
    }
    --a4;
  }
  return 1;
}

//----- (6F7BA948) --------------------------------------------------------
signed int __stdcall FillLastRow(int a1)
{
  int v1; // esi@1
  signed int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@2
  int v5; // ecx@2
  int v6; // edx@7
  int v7; // ecx@7
  int v8; // [sp+8h] [bp-4h]@1
  int v9; // [sp+14h] [bp+8h]@1

  v1 = a1;
  result = *(_DWORD *)(a1 + 40);
  v3 = *(_DWORD *)result;
  v9 = 0;
  v8 = *(_DWORD *)result;
  if ( *(_DWORD *)result >= 2 )
  {
    v4 = v3 - 2;
    v5 = *(_DWORD *)(result + 4) + 4 * (v3 - 2);
    result = *(_DWORD *)(v1 + 112);
    while ( *(_DWORD *)(*(_DWORD *)v5 + 40) == result )
    {
      if ( v4 <= 0 )
        return result;
      --v4;
      v5 -= 4;
    }
    for ( ; v4; --v4 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(v1 + 40) + 4);
      result = *(_DWORD *)(v6 + 4 * v3 - 4);
      v7 = *(_DWORD *)(v1 + 80) - *(_DWORD *)(result + 8);
      if ( *(_DWORD *)(v1 + 80) == *(_DWORD *)(result + 8) )
        break;
      result = *(_DWORD *)(v1 + 80) + *(_DWORD *)(v1 + 80) / 8 - *(_DWORD *)(*(_DWORD *)(v6 + 4 * v4) + 8);
      if ( v7 <= result )
        break;
      v3 = v8;
      result = BorrowOne(v1, v8 - 1, v4, v9++);
      if ( !result )
        break;
    }
  }
  return result;
}

//----- (6F7BA9D8) --------------------------------------------------------
signed int __stdcall RightJustify(int a1)
{
  int v1; // ebx@1
  signed int result; // eax@1
  int v3; // edi@1
  int v4; // esi@2
  int v5; // eax@3
  int v6; // edi@3
  int v7; // edx@8
  int v8; // ecx@12
  int v9; // edx@12
  int v10; // ecx@14
  signed int v11; // [sp+8h] [bp-10h]@13
  signed int v12; // [sp+Ch] [bp-Ch]@12
  int v13; // [sp+10h] [bp-8h]@1
  signed int v14; // [sp+14h] [bp-4h]@7
  int v15; // [sp+14h] [bp-4h]@12
  int v16; // [sp+20h] [bp+8h]@4
  int v17; // [sp+20h] [bp+8h]@8
  int v18; // [sp+20h] [bp+8h]@12

  v1 = a1;
  result = *(_DWORD *)(a1 + 40);
  v3 = *(_DWORD *)result;
  v13 = *(_DWORD *)result;
  if ( *(_DWORD *)(a1 + 112) >= 1 )
  {
    result = FillLastRow(a1);
    v4 = 0;
    if ( v3 > 0 )
    {
      do
      {
        v5 = *(_DWORD *)(*(_DWORD *)(v1 + 40) + 4);
        v6 = v4;
        if ( v4 < v13 )
        {
          v16 = v5 + 4 * v4;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)v16 + 40) != *(_DWORD *)(*(_DWORD *)(v5 + 4 * v4) + 40) )
              break;
            v16 += 4;
            ++v6;
          }
          while ( v6 < v13 );
        }
        v14 = 0;
        if ( v4 < v6 )
        {
          v17 = v5 + 4 * v4;
          v7 = v6 - v4;
          do
          {
            if ( !(*(_BYTE *)(*(_DWORD *)v17 + 48) & 4) )
              ++v14;
            v17 += 4;
            --v7;
          }
          while ( v7 );
        }
        v8 = *(_DWORD *)(v5 + 4 * v6 - 4);
        result = (*(_DWORD *)(v1 + 80) - *(_DWORD *)(v8 + 8) - g_cxEdge) / v14;
        v9 = (*(_DWORD *)(v1 + 80) - *(_DWORD *)(v8 + 8) - g_cxEdge) % v14;
        v15 = 0;
        v12 = result;
        v18 = v9;
        if ( v4 < v6 )
        {
          result /= 2;
          v11 = result;
          do
          {
            v10 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * v4);
            if ( !(*(_BYTE *)(v10 + 48) & 4) )
            {
              *(_DWORD *)(v10 + 20) += result;
              *(_DWORD *)(v10 + 32) += result;
              *(_DWORD *)v10 += v15;
              v15 += v12 + (v18 != 0);
              if ( v18 )
                --v18;
              *(_DWORD *)(v10 + 8) += v15;
              result = v11;
            }
            ++v4;
          }
          while ( v4 < v6 );
        }
      }
      while ( v4 < v13 );
    }
  }
  return result;
}

//----- (6F7BAAD9) --------------------------------------------------------
signed int __stdcall Tab_OnSetItemExtra(int a1, int a2)
{
  signed int result; // eax@3

  if ( **(_DWORD **)(a1 + 40) > 0 || a2 < 0 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 48) = a2;
    result = 1;
  }
  return result;
}

//----- (6F7BAB03) --------------------------------------------------------
int __stdcall Tab_OnHitTest(int a1, int a2, int cy, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  int v7; // edi@4
  int result; // eax@6
  int v9; // esi@8
  int v10; // eax@8
  int v11; // ecx@9
  struct _IMAGELIST *v12; // ebx@12
  int v13; // edi@14
  POINT v14; // [sp+Ch] [bp-1Ch]@1
  int v15; // [sp+14h] [bp-14h]@1
  int v16; // [sp+18h] [bp-10h]@1
  POINT pt; // [sp+1Ch] [bp-Ch]@1
  int v18; // [sp+24h] [bp-4h]@1
  int v19; // [sp+30h] [bp+8h]@3

  v4 = a1;
  v5 = a2;
  v6 = **(_DWORD **)(a1 + 40);
  v16 = cy;
  v18 = v6;
  v15 = a2;
  v14 = (POINT)__PAIR__(cy, a2);
  Tab_DVFlipRect(a1, (int)&v14);
  pt = v14;
  if ( !a4 )
    a4 = (int)&a2;
  v19 = 0;
  if ( v6 <= 0 )
  {
LABEL_6:
    *(_DWORD *)a4 = 1;
    result = -1;
  }
  else
  {
    while ( 1 )
    {
      v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4) + 4 * v19);
      if ( PtInRect((const RECT *)v7, pt) )
        break;
      ++v19;
      if ( v19 >= v18 )
        goto LABEL_6;
    }
    v9 = v5 - *(_DWORD *)v7;
    *(_DWORD *)a4 = 6;
    v10 = *(_DWORD *)(v4 + 8);
    if ( !(v10 & 0x2000) )
    {
      v11 = *(_DWORD *)(v7 + 20);
      if ( v9 <= v11 || v9 >= v11 + *(_DWORD *)(v7 + 28) )
      {
        v12 = *(struct _IMAGELIST **)(v4 + 128);
        if ( v12 )
        {
          if ( *(_DWORD *)(v7 + 16) != -1 )
          {
            VertImageList_GetIconSize(v12, &a2, &cy, v10 & 0x80);
            v13 = *(_DWORD *)(v7 + 32);
            if ( v9 > v13 && v9 < a2 + v13 )
              *(_DWORD *)a4 = 2;
          }
        }
      }
      else
      {
        *(_DWORD *)a4 = 4;
      }
    }
    result = v19;
  }
  return result;
}

//----- (6F7BAC07) --------------------------------------------------------
int __stdcall Tab_FreeItem(int a1, HLOCAL hMem)
{
  if ( hMem )
  {
    Str_Set((int)((char *)hMem + 44), 0);
    Free(hMem);
  }
  return 0;
}

//----- (6F7BAC31) --------------------------------------------------------
BOOL __stdcall Tab_InvertRows(int a1)
{
  int v1; // ebx@1
  BOOL result; // eax@1
  int v3; // edi@1
  int v4; // ecx@2
  int v5; // edx@2
  int v6; // eax@2

  v1 = g_cyEdge;
  result = *(_DWORD *)(a1 + 40);
  v3 = *(_DWORD *)result;
  while ( 1 )
  {
    --v3;
    if ( v3 < 0 )
      break;
    v4 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v3);
    v5 = *(_DWORD *)(a1 + 112) - *(_DWORD *)(v4 + 40);
    v6 = v1 + v5 * *(_DWORD *)(a1 + 76) - *(_DWORD *)(v4 + 4);
    *(_DWORD *)(v4 + 40) = v5;
    result = OffsetRect((LPRECT)v4, 0, v6);
  }
  return result;
}

//----- (6F7BAC7F) --------------------------------------------------------
INT_PTR __stdcall Tab_FindTab(int a1, INT_PTR i, int a3)
{
  PVOID v3; // ecx@1
  INT_PTR result; // eax@1
  int v5; // edi@2
  __int64 v6; // rax@2
  int v7; // edx@2
  int v8; // esi@4
  int v9; // esi@5

  v3 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
  result = 0;
  if ( v3 )
  {
    LOBYTE(result) = a3 != 38;
    v5 = *((_DWORD *)v3 + 10) + 2 * result - 1;
    v6 = *(_DWORD *)v3 + *((_DWORD *)v3 + 2);
    v7 = ((signed int)v6 - HIDWORD(v6)) >> 1;
    if ( v5 > *(_DWORD *)(a1 + 112) || v5 < 0 || (v8 = *(_DWORD *)(a1 + 40), result = *(_DWORD *)v8 - 1, result < 0) )
    {
LABEL_9:
      result = i;
    }
    else
    {
      v9 = *(_DWORD *)(v8 + 4) + 4 * result;
      while ( *(_DWORD *)(*(_DWORD *)v9 + 40) != v5 || **(_DWORD **)v9 >= v7 )
      {
        --result;
        v9 -= 4;
        if ( result < 0 )
          goto LABEL_9;
      }
    }
  }
  return result;
}

//----- (6F7BACF0) --------------------------------------------------------
signed int __stdcall ThunkItemWtoA(int a1, int a2, int a3)
{
  signed int result; // eax@2
  const WCHAR *v4; // ecx@4
  int v5; // eax@5

  if ( a3 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
    if ( *(_BYTE *)a2 & 1
      && (v4 = *(const WCHAR **)(a2 + 12)) != 0
      && (v5 = *(_DWORD *)(a2 + 16)) != 0
      && !WideCharToMultiByte(0, 0, v4, -1, *(LPSTR *)(a3 + 12), v5, 0, 0)
      && GetLastError() )
    {
      result = 0;
    }
    else
    {
      *(_DWORD *)(a3 + 16) = *(_DWORD *)(a2 + 16);
      if ( *(_BYTE *)a2 & 2 )
        *(_DWORD *)(a3 + 20) = *(_DWORD *)(a2 + 20);
      if ( *(_BYTE *)a2 & 8 )
        memmove((void *)(a3 + 24), (const void *)(a2 + 24), *(_DWORD *)(a1 + 48));
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BAD87) --------------------------------------------------------
int __stdcall Tab_SmoothScrollWindow(int a1, int a2, int a3, int *a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // esi@4
  int result; // eax@7
  int v11; // [sp+Ch] [bp-20h]@5
  int v12; // [sp+10h] [bp-1Ch]@5
  int v13; // [sp+14h] [bp-18h]@5
  int v14; // [sp+18h] [bp-14h]@5
  int v15; // [sp+1Ch] [bp-10h]@3
  int v16; // [sp+20h] [bp-Ch]@3
  int v17; // [sp+24h] [bp-8h]@3
  int v18; // [sp+28h] [bp-4h]@3

  if ( *(_BYTE *)(a1 + 8) & 2 )
  {
    a3 = -a3;
    if ( a4 )
    {
      v15 = *a4;
      v16 = a4[1];
      v17 = a4[2];
      v18 = a4[3];
      a4 = &v15;
      Tab_VFlipRect(a1, (int)&v15);
    }
    v9 = a5;
    if ( a5 )
    {
      v11 = *(_DWORD *)a5;
      v12 = *(_DWORD *)(a5 + 4);
      v13 = *(_DWORD *)(a5 + 8);
      v14 = *(_DWORD *)(a5 + 12);
      v9 = (int)&v11;
      Tab_VFlipRect(a1, (int)&v11);
    }
  }
  else
  {
    v9 = a5;
  }
  result = VertSmoothScrollWindow(*(_DWORD *)a1, a2, a3, a4, v9, a6, a7, a8, *(_DWORD *)(a1 + 8) & 0x80, a9);
  if ( a7 )
    result = Tab_VFlipRect(a1, v9);
  return result;
}

//----- (6F7BAE17) --------------------------------------------------------
int __stdcall Tab_InvalidateRect(int a1, int a2, BOOL bErase)
{
  int v4; // [sp+8h] [bp-10h]@1
  int v5; // [sp+Ch] [bp-Ch]@1
  int v6; // [sp+10h] [bp-8h]@1
  int v7; // [sp+14h] [bp-4h]@1

  v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(a2 + 4);
  v6 = *(_DWORD *)(a2 + 8);
  v7 = *(_DWORD *)(a2 + 12);
  Tab_VFlipRect(a1, (int)&v4);
  return VertInvalidateRect(*(HWND *)a1, (int)&v4, bErase, *(_DWORD *)(a1 + 8) & 0x80);
}

//----- (6F7BAE5A) --------------------------------------------------------
int __stdcall Tab_PatBlt(HDC hdc, int a2, int a3, int a4, int a5, DWORD rop, int a7)
{
  int x; // [sp+4h] [bp-10h]@1
  int y; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+Ch] [bp-8h]@1
  int v11; // [sp+10h] [bp-4h]@1

  x = a2;
  v10 = a4 + a2;
  y = a3;
  v11 = a5 + a3;
  Tab_VFlipRect(a7, (int)&x);
  return VertPatBlt(hdc, x, y, v10 - x, v11 - y, rop, *(_DWORD *)(a7 + 8) & 0x80);
}

//----- (6F7BAEBE) --------------------------------------------------------
BOOL __stdcall Tab_OnDestroy(HLOCAL hMem)
{
  int v1; // eax@6
  int i; // edi@6

  if ( g_fDBCSInputEnabled )
    ImmAssociateContext(*(HWND *)hMem, *((HIMC *)hMem + 34));
  if ( *((_DWORD *)hMem + 2) & 0x4000 && IsWindow(*((HWND *)hMem + 33)) )
    DestroyWindow(*((HWND *)hMem + 33));
  v1 = *((_DWORD *)hMem + 10);
  for ( i = 0; i < *(_DWORD *)v1; ++i )
  {
    Tab_FreeItem((int)hMem, *(HLOCAL *)(*(_DWORD *)(v1 + 4) + 4 * i));
    v1 = *((_DWORD *)hMem + 10);
  }
  DPA_Destroy(*((HDPA *)hMem + 10));
  if ( *((_DWORD *)hMem + 35) )
    DestroyDragProxy(*((CDragProxy **)hMem + 35));
  if ( *((_BYTE *)hMem + 44) & 0x80 )
    DeleteObject(*((HGDIOBJ *)hMem + 14));
  SetWindowLongW(*(HWND *)hMem, 0, 0);
  LocalFree(hMem);
  return TerminateDitherBrush();
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7BAF68) --------------------------------------------------------
int __stdcall PutzRowToBottom(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  LONG v4; // ecx@2
  LONG v5; // edi@2
  int v6; // edx@5
  int v7; // ebx@8
  int v8; // eax@8
  int v9; // edi@9
  int v10; // ecx@9
  int v11; // edi@31
  int v12; // eax@32
  int v13; // ecx@32
  int v14; // ecx@33
  int v15; // edx@35
  struct tagRECT rc; // [sp+Ch] [bp-1Ch]@1
  LONG v17; // [sp+1Ch] [bp-Ch]@2
  LONG v18; // [sp+20h] [bp-8h]@2
  int v19; // [sp+24h] [bp-4h]@8
  int v20; // [sp+30h] [bp+8h]@3

  v2 = a1;
  result = Tab_GetClientRect(a1, &rc);
  if ( !(*(_BYTE *)(a1 + 8) & 1) )
  {
    if ( a2 == *(_DWORD *)(a1 + 112) )
      return result;
    v11 = **(_DWORD **)(a1 + 40);
    while ( 1 )
    {
      --v11;
      if ( v11 < 0 )
      {
        rc.bottom = *(_DWORD *)(a1 + 76) * (*(_DWORD *)(a1 + 112) + 1);
        Tab_SmoothScrollWindow(a1, 0, rc.bottom - rc.top, 0, (int)&rc, 0, 0, 6, 1);
        UpdateWindow(*(HWND *)a1);
        rc.bottom += 2 * g_cyEdge;
        rc.top = rc.bottom - 3 * g_cyEdge;
        Tab_InvalidateRect(a1, (int)&rc, 1);
        return UpdateToolTipRects(v2);
      }
      v12 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v11);
      v13 = *(_DWORD *)(v12 + 40);
      if ( v13 > a2 )
        break;
      if ( v13 == a2 )
      {
        v15 = *(_DWORD *)(a1 + 112);
        rc.top = *(_DWORD *)(v12 + 4);
        v14 = *(_DWORD *)(a1 + 76) * (v15 - a2);
        *(_DWORD *)(v12 + 40) = v15;
LABEL_36:
        *(_DWORD *)(v12 + 4) += v14;
        *(_DWORD *)(v12 + 12) += v14;
      }
    }
    *(_DWORD *)(v12 + 40) = v13 - 1;
    v14 = -*(_DWORD *)(a1 + 76);
    goto LABEL_36;
  }
  result = *(_DWORD *)(a1 + 116);
  v4 = 0;
  v5 = 0;
  v18 = 0;
  v17 = 0;
  if ( result == -1 )
    v20 = *(_DWORD *)(a1 + 112);
  else
    v20 = result;
  v6 = a2;
  if ( a2 == v20 )
  {
    if ( result == -1 )
      *(_DWORD *)(v2 + 116) = a2;
    return result;
  }
  v7 = rc.bottom - *(_DWORD *)(v2 + 76) * (*(_DWORD *)(v2 + 112) + 1) - g_cyEdge - rc.top;
  v8 = **(_DWORD **)(v2 + 40) - 1;
  v19 = v8;
  if ( v8 < 0 )
    goto LABEL_24;
  do
  {
    v9 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 40) + 4) + 4 * v8);
    v10 = *(_DWORD *)(v9 + 40);
    if ( v10 == v6 )
    {
      v17 = *(_DWORD *)(v9 + 12);
    }
    else if ( v10 == v20 )
    {
      v18 = *(_DWORD *)(v9 + 12);
    }
    if ( v10 <= a2 )
    {
      if ( v10 > v20 )
      {
        OffsetRect((LPRECT)v9, 0, -v7);
        goto LABEL_18;
      }
    }
    else if ( v10 <= v20 )
    {
      OffsetRect((LPRECT)v9, 0, v7);
LABEL_18:
      v8 = v19;
      goto LABEL_19;
    }
LABEL_19:
    v6 = a2;
    if ( *(_DWORD *)(v9 + 40) == v20 && v20 > a2 )
      v18 = *(_DWORD *)(v9 + 12);
    --v8;
    v19 = v8;
  }
  while ( v8 >= 0 );
  v5 = v17;
  v4 = v18;
LABEL_24:
  if ( *(_DWORD *)(v2 + 116) != -1 )
  {
    if ( v5 <= v4 )
    {
      rc.top = v5;
      rc.bottom = v4;
    }
    else
    {
      rc.top = v4;
      rc.bottom = v5;
    }
    Tab_SmoothScrollWindow(v2, 0, v4 - v5, 0, (int)&rc, 0, 0, 6, 1);
    InflateRect(&rc, g_cxEdge, g_cyEdge);
    Tab_InvalidateRect(v2, (int)&rc, 0);
  }
  *(_DWORD *)(v2 + 116) = a2;
  return UpdateToolTipRects(v2);
}

//----- (6F7BB152) --------------------------------------------------------
void __stdcall Tab_InvalidateItem(int a1, INT_PTR i, BOOL bErase)
{
  PVOID v3; // eax@2
  PVOID v4; // esi@3
  LONG v5; // eax@3
  struct tagRECT rc; // [sp+0h] [bp-10h]@3

  if ( i != -1 )
  {
    v3 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
    if ( v3 )
    {
      v4 = v3;
      v5 = *(_DWORD *)(a1 + 80);
      rc.left = *(_DWORD *)v4;
      v4 = (char *)v4 + 4;
      rc.top = *(_DWORD *)v4;
      v4 = (char *)v4 + 4;
      rc.right = *(_DWORD *)v4;
      rc.bottom = *((_DWORD *)v4 + 1);
      if ( rc.right > v5 )
        rc.right = v5;
      InflateRect(&rc, g_cxEdge, g_cyEdge);
      if ( *(_BYTE *)(a1 + 8) & 8 )
        rc.right += 2 * g_cxEdge;
      Tab_InvalidateRect(a1, (int)&rc, bErase);
    }
  }
}

//----- (6F7BB1CD) --------------------------------------------------------
int __stdcall Tab_Scroll(int a1, int a2, int a3)
{
  int v3; // esi@1
  PVOID v4; // ebx@1
  int v5; // eax@1
  int v6; // edi@1
  INT_PTR j; // edi@5
  PVOID v8; // eax@6
  HWND v9; // eax@13
  int v11; // [sp+Ch] [bp-10h]@1
  int v12; // [sp+10h] [bp-Ch]@1
  int v13; // [sp+14h] [bp-8h]@1
  int v14; // [sp+18h] [bp-4h]@1
  int i; // [sp+24h] [bp+8h]@1

  v3 = a1;
  v11 = g_cxEdge;
  v13 = *(_DWORD *)(a1 + 80);
  v4 = 0;
  v14 = *(_DWORD *)(a1 + 76) + 2 * g_cyEdge;
  v12 = 0;
  Tab_SmoothScrollWindow(a1, a2, 0, 0, (int)&v11, 0, 0, 6, -1);
  v5 = *(_DWORD *)(a1 + 40);
  v6 = *(_DWORD *)v5 - 1;
  for ( i = *(_DWORD *)v5 - 1; i >= 0; --i )
  {
    v4 = *(PVOID *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * i);
    OffsetRect(*(LPRECT *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * i), a2, 0);
  }
  if ( *(_DWORD *)(v3 + 92) > v6 )
    *(_DWORD *)(v3 + 92) = v6;
  for ( j = *(_DWORD *)(v3 + 92); j >= 0; --j )
  {
    v8 = DPA_GetPtr(*(HDPA *)(v3 + 40), j);
    v4 = v8;
    if ( v8 )
    {
      if ( *((_DWORD *)v8 + 2) <= *(_DWORD *)(v3 + 80) )
        break;
      Tab_InvalidateItem(v3, *(_DWORD *)(v3 + 92), 1);
    }
  }
  if ( j == *(_DWORD *)(v3 + 92) && v4 )
  {
    v11 = *((_DWORD *)v4 + 2);
    Tab_InvalidateRect(v3, (int)&v11, 1);
  }
  v9 = *(HWND *)(v3 + 36);
  *(_DWORD *)(v3 + 88) = a3;
  if ( v9 )
    SendMessageW(v9, 0x467u, 0, (unsigned __int16)a3);
  return UpdateToolTipRects(v3);
}

//----- (6F7BB2BA) --------------------------------------------------------
void __stdcall Tab_OnHScroll(int a1, int a2, int a3, INT_PTR i)
{
  PVOID v4; // eax@2
  int v5; // ecx@2

  if ( a3 == 4 )
  {
    v4 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
    v5 = 0;
    if ( !v4 || (v5 = g_cxEdge - *(_DWORD *)v4, g_cxEdge != *(_DWORD *)v4) )
    {
      Tab_Scroll(a1, v5, i);
      UpdateWindow(*(HWND *)a1);
    }
  }
}

//----- (6F7BB300) --------------------------------------------------------
void __stdcall Tab_OnMouseMove(int a1, char a2, int a3, int cy)
{
  INT_PTR v4; // eax@1
  INT_PTR v5; // edi@1
  int v6; // ecx@5
  INT_PTR v7; // ebx@6
  signed int v8; // edx@8

  v4 = Tab_OnHitTest(a1, a3, cy, 0);
  v5 = v4;
  if ( *(_BYTE *)(a1 + 8) & 0x40 && v4 != *(_DWORD *)(a1 + 160) )
  {
    Tab_InvalidateItem(a1, v4, 0);
    Tab_InvalidateItem(a1, *(_DWORD *)(a1 + 160), 0);
    *(_DWORD *)(a1 + 160) = v5;
  }
  if ( a2 & 1 )
  {
    v6 = *(_DWORD *)(a1 + 8);
    if ( v6 & 0x100 )
    {
      v7 = *(_DWORD *)(a1 + 64);
      if ( v7 != -1 )
      {
        if ( v5 == v7 )
          v8 = 4;
        else
          v8 = 0;
        if ( (*(_DWORD *)(a1 + 44) & 4) != v8 )
        {
          *(_DWORD *)(a1 + 44) ^= 4u;
          Tab_InvalidateItem(a1, v7, v6 & 8);
        }
      }
    }
  }
}

//----- (6F7BB392) --------------------------------------------------------
void __stdcall Tab_OnRemoveImage(int a1, int i)
{
  struct _IMAGELIST *v2; // eax@1
  INT_PTR v3; // esi@3
  int v4; // eax@4
  int v5; // ecx@4

  v2 = *(struct _IMAGELIST **)(a1 + 128);
  if ( v2 && i >= 0 )
  {
    ImageList_Remove(v2, i);
    v3 = **(_DWORD **)(a1 + 40);
    while ( 1 )
    {
      --v3;
      if ( v3 < 0 )
        break;
      v4 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v3);
      v5 = *(_DWORD *)(v4 + 16);
      if ( v5 <= i )
      {
        if ( v5 == i )
        {
          *(_DWORD *)(v4 + 16) = -1;
          Tab_InvalidateItem(a1, v3, 0);
        }
      }
      else
      {
        *(_DWORD *)(v4 + 16) = v5 - 1;
      }
    }
  }
}

//----- (6F7BB3F0) --------------------------------------------------------
int __stdcall Tab_OnGetItem(int a1, INT_PTR i, int a3)
{
  int v3; // esi@1
  PVOID v4; // edi@1
  int result; // eax@8
  int v6; // ecx@14
  int v7; // eax@14
  size_t v8; // ebx@20
  int v9; // [sp+1Ch] [bp+10h]@1

  v3 = a3;
  v9 = *(_DWORD *)a3;
  v4 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
  if ( v4 )
  {
    if ( v9 & 1 )
    {
      if ( *((_DWORD *)v4 + 11) )
        StringCchCopyW(*(STRSAFE_LPWSTR *)(v3 + 12), *(_DWORD *)(v3 + 16), *((STRSAFE_LPCWSTR *)v4 + 11));
      else
        *(_DWORD *)(v3 + 12) = 0;
    }
    if ( v9 & 0x10 )
    {
      v6 = *(_DWORD *)(v3 + 8);
      v7 = v6 & *((_DWORD *)v4 + 12);
      *(_DWORD *)(v3 + 4) = v7;
      if ( v6 & 1 )
      {
        if ( *(_DWORD *)(a1 + 60) == i || *(_DWORD *)(a1 + 64) == i && *(_BYTE *)(a1 + 44) & 4 )
          *(_DWORD *)(v3 + 4) = v7 | 1;
      }
    }
    if ( v9 & 8 )
    {
      v8 = *(_DWORD *)(a1 + 48);
      if ( v8 )
        memmove((void *)(v3 + 24), (char *)v4 + 56, v8);
    }
    if ( v9 & 2 )
      *(_DWORD *)(v3 + 20) = *((_DWORD *)v4 + 4);
    if ( v9 & 4 && !(v9 & 1) && *((_DWORD *)v4 + 13) )
      *(_DWORD *)(v3 + 16) = 1;
    result = 1;
  }
  else
  {
    if ( v9 & 8 )
    {
      *(_DWORD *)(v3 + 24) = 0;
    }
    else if ( v9 & 1 )
    {
      *(_DWORD *)(v3 + 12) = 0;
    }
    else if ( v9 & 2 )
    {
      *(_DWORD *)(v3 + 20) = 0;
    }
    result = 0;
  }
  return result;
}

//----- (6F7BB4E0) --------------------------------------------------------
INT_PTR __stdcall Tab_OnSetRedraw(INT_PTR i, int a2)
{
  INT_PTR result; // eax@1

  result = i;
  if ( a2 )
  {
    *(_DWORD *)(i + 44) |= 0x10u;
    result = RedrawAll(i, 1u);
  }
  else
  {
    *(_DWORD *)(i + 44) &= 0xFFFFFFEF;
  }
  return result;
}

//----- (6F7BB509) --------------------------------------------------------
int __stdcall Tab_OnDeleteAllItems(INT_PTR i)
{
  int j; // edi@1
  HWND v2; // eax@2
  LPARAM lParam; // [sp+8h] [bp-2Ch]@3
  int v5; // [sp+10h] [bp-24h]@3
  int v6; // [sp+14h] [bp-20h]@3

  for ( j = **(_DWORD **)(i + 40); j > 0; Tab_FreeItem(i, *(HLOCAL *)(*(_DWORD *)(*(_DWORD *)(i + 40) + 4) + 4 * j)) )
  {
    v2 = *(HWND *)(i + 132);
    --j;
    if ( v2 )
    {
      v5 = *(_DWORD *)i;
      lParam = 44;
      v6 = j;
      SendMessageW(v2, 0x433u, 0, (LPARAM)&lParam);
    }
  }
  DPA_DeleteAllPtrs(*(HDPA *)(i + 40));
  *(_DWORD *)(i + 60) = -1;
  *(_DWORD *)(i + 88) = 0;
  *(_DWORD *)(i + 68) = 0x7FFFFFFF;
  RedrawAll(i, 5u);
  return 1;
}

//----- (6F7BB589) --------------------------------------------------------
int __stdcall Tab_OnSetItem(INT_PTR a1, INT_PTR i, int a3)
{
  int v3; // edi@1
  INT_PTR v5; // ebx@3
  PVOID v6; // esi@3
  int v7; // ecx@17
  int v8; // eax@17
  signed int v9; // [sp+4h] [bp-8h]@1
  signed int v10; // [sp+8h] [bp-4h]@1
  int v11; // [sp+1Ch] [bp+10h]@1

  v10 = 0;
  v9 = 0;
  v3 = a3;
  v11 = *(_DWORD *)a3;
  if ( !v11 )
    return 1;
  v5 = a1;
  v6 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
  if ( !v6 )
    return 0;
  if ( v11 & 1 )
  {
    if ( !Str_Set((int)((char *)v6 + 44), *(LPCWSTR *)(v3 + 12)) )
      return 0;
    v9 = 1;
    v10 = 1;
    *((_DWORD *)v6 + 13) = 32 * (v11 & 4);
  }
  if ( v11 & 2 )
  {
    if ( *((_DWORD *)v6 + 4) == -1 || *(_DWORD *)(v3 + 20) == -1 )
      v9 = 1;
    *((_DWORD *)v6 + 4) = *(_DWORD *)(v3 + 20);
    v10 = 1;
  }
  if ( v11 & 8 && *(_DWORD *)(a1 + 48) )
    memmove((char *)v6 + 56, (const void *)(v3 + 24), *(_DWORD *)(a1 + 48));
  if ( v11 & 0x10 )
  {
    v7 = *((_DWORD *)v6 + 12);
    v8 = *(_DWORD *)(v3 + 8) & *(_DWORD *)(v3 + 4) | v7 & ~*(_DWORD *)(v3 + 8);
    *((_DWORD *)v6 + 12) = v8;
    if ( v7 != v8 )
      v10 = 1;
    if ( ((unsigned __int8)v7 ^ (unsigned __int8)v8) & 4 )
      v9 = 1;
    if ( !(*(_BYTE *)(v3 + 8) & 1) || *(_BYTE *)(v3 + 4) & 1 )
    {
      v5 = a1;
    }
    else
    {
      v5 = a1;
      if ( *(_DWORD *)(a1 + 64) == i )
      {
        *(_DWORD *)(a1 + 64) = -1;
        v10 = 1;
      }
      if ( *(_DWORD *)(a1 + 60) == i )
      {
        ChangeSel((HWND)a1, -1, 1, 0);
        v10 = 1;
      }
    }
  }
  if ( v10 )
  {
    if ( *(_DWORD *)(v5 + 8) & 0x400 || !v9 )
    {
      Tab_InvalidateItem(v5, i, 0);
    }
    else
    {
      *(_DWORD *)(v5 + 76) = 0x7FFFFFFF;
      *(_DWORD *)(v5 + 68) = 0x7FFFFFFF;
      RedrawAll(v5, 0x45u);
    }
  }
  return 1;
}

//----- (6F7BB6DF) --------------------------------------------------------
int __stdcall Tab_DeselectAll(INT_PTR a1, int a2)
{
  int result; // eax@2
  INT_PTR v3; // esi@2
  int v4; // [sp+4h] [bp-1Ch]@5
  int v5; // [sp+8h] [bp-18h]@5
  int v6; // [sp+Ch] [bp-14h]@5

  if ( *(_DWORD *)(a1 + 8) & 0x100 )
  {
    result = *(_DWORD *)(a1 + 40);
    v3 = *(_DWORD *)result;
    while ( 1 )
    {
      --v3;
      if ( v3 < 0 )
        break;
      if ( a2 )
      {
        result = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v3);
        if ( !(*(_BYTE *)(result + 48) & 1) )
          continue;
      }
      v5 = 0;
      v4 = 16;
      v6 = 1;
      result = Tab_OnSetItem(a1, v3, (int)&v4);
    }
  }
  return result;
}

//----- (6F7BB73C) --------------------------------------------------------
int __stdcall Tab_OnRButtonDown(INT_PTR a1, int a2, int cy, int a4)
{
  int result; // eax@1
  bool v5; // zf@2
  bool v6; // sf@2
  unsigned __int8 v7; // of@2
  INT_PTR v8; // edi@5
  int v9; // [sp+4h] [bp-1Ch]@8
  int v10; // [sp+8h] [bp-18h]@8
  int v11; // [sp+Ch] [bp-14h]@8

  result = a2;
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
  {
    v7 = __OFSUB__(cy, *(_DWORD *)(a1 + 80));
    v5 = cy == *(_DWORD *)(a1 + 80);
    v6 = cy - *(_DWORD *)(a1 + 80) < 0;
  }
  else
  {
    v7 = __OFSUB__(a2, *(_DWORD *)(a1 + 80));
    v5 = a2 == *(_DWORD *)(a1 + 80);
    v6 = a2 - *(_DWORD *)(a1 + 80) < 0;
  }
  if ( (unsigned __int8)(v6 ^ v7) | v5 )
  {
    result = Tab_OnHitTest(a1, a2, cy, 0);
    v8 = result;
    if ( result != -1 )
    {
      result = *(_DWORD *)(a1 + 8);
      if ( result & 0x100 )
      {
        if ( result & 4 )
        {
          v9 = 16;
          v11 = 1;
          result = Tab_OnGetItem(a1, v8, (int)&v9);
          if ( !(v10 & 1) )
          {
            if ( GetAsyncKeyState(17) >= 0 )
              Tab_DeselectAll(a1, 0);
            v10 = 1;
            result = Tab_OnSetItem(a1, v8, (int)&v9);
          }
        }
      }
    }
  }
  return result;
}

//----- (6F7BB7CB) --------------------------------------------------------
int __stdcall Tab_OnDeleteItem(UINT flags, INT_PTR i)
{
  UINT v2; // esi@1
  int result; // eax@2
  struct _DPA *v4; // eax@9
  PVOID v5; // ebx@11
  bool v6; // zf@12
  PVOID v7; // eax@15
  INT_PTR v8; // eax@17
  INT_PTR v9; // eax@21
  HWND v10; // eax@23
  int v11; // ecx@24
  LPARAM lParam; // [sp+8h] [bp-3Ch]@24
  HWND v13; // [sp+10h] [bp-34h]@24
  int v14; // [sp+14h] [bp-30h]@24
  struct tagRECT Rect; // [sp+34h] [bp-10h]@1
  signed int flagsa; // [sp+4Ch] [bp+8h]@8

  Rect.left = -1;
  v2 = flags;
  if ( i < **(_DWORD **)(flags + 40) )
  {
    MyNotifyWinEvent(32769, *(_DWORD *)flags, -4, i + 1);
    if ( !(*(_DWORD *)(flags + 8) & 0x100) && (*(_BYTE *)(flags + 44) & 0x10 || *(_DWORD *)(flags + 60) >= i) )
      Tab_InvalidateItem(flags, *(_DWORD *)(flags + 60), 1);
    if ( *(_DWORD *)(flags + 8) & 0x400 )
    {
      flagsa = 65;
      Tab_InvalidateItem(v2, **(_DWORD **)(v2 + 40) - 1, 1);
      if ( *(_DWORD *)(v2 + 8) & 0x100 )
      {
        v4 = *(struct _DPA **)(v2 + 40);
        if ( i == *(_DWORD *)v4 - 1 )
        {
          Rect.left = 0;
          flagsa = 0;
        }
        else
        {
          v5 = DPA_GetPtr(v4, i);
          GetClientRect(*(HWND *)v2, &Rect);
          if ( v5 )
          {
            v6 = *(_DWORD *)(v2 + 112) == 0;
            Rect.top = *((_DWORD *)v5 + 1);
            if ( v6 )
              Rect.left = *(_DWORD *)v5;
          }
        }
      }
    }
    else
    {
      flagsa = 69;
    }
    v7 = DPA_DeletePtr(*(HDPA *)(v2 + 40), i);
    if ( v7 )
    {
      Tab_FreeItem(v2, v7);
      v8 = *(_DWORD *)(v2 + 60);
      if ( v8 == i )
      {
        *(_DWORD *)(v2 + 60) = -1;
      }
      else if ( v8 > i )
      {
        *(_DWORD *)(v2 + 60) = v8 - 1;
      }
      v9 = *(_DWORD *)(v2 + 88);
      if ( v9 > i )
        *(_DWORD *)(v2 + 88) = v9 - 1;
      v10 = *(HWND *)(v2 + 132);
      *(_DWORD *)(v2 + 116) = -1;
      *(_DWORD *)(v2 + 68) = 0x7FFFFFFF;
      if ( v10 )
      {
        v13 = *(HWND *)v2;
        v11 = *(_DWORD *)(v2 + 40);
        lParam = 44;
        v14 = *(_DWORD *)v11;
        SendMessageW(v10, 0x433u, 0, (LPARAM)&lParam);
      }
      if ( *(_BYTE *)(v2 + 44) & 0x10 )
      {
        if ( Rect.left == -1 )
        {
          RedrawAll(v2, flagsa);
        }
        else
        {
          Tab_UpdateArrows(v2, 0);
          if ( flagsa )
            RedrawWindow(*(HWND *)v2, &Rect, 0, flagsa);
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BB942) --------------------------------------------------------
int __stdcall Tab_OnGetItemRect(int a1, INT_PTR i, int a3)
{
  int v3; // edi@1
  signed int v5; // [sp+Ch] [bp-4h]@1
  INT_PTR ia; // [sp+1Ch] [bp+Ch]@1

  v3 = a1;
  ia = (INT_PTR)DPA_GetPtr(*(HDPA *)(a1 + 40), i);
  v5 = 0;
  if ( a3 )
  {
    CalcPaintMetrics(a1, 0);
    if ( ia )
    {
      *(_DWORD *)a3 = *(_DWORD *)ia;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(ia + 4);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(ia + 8);
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(ia + 12);
      v3 = a1;
      v5 = 1;
    }
    else
    {
      *(_DWORD *)(a3 + 4) = 0;
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a3 + 8) = 0;
      *(_DWORD *)a3 = 0;
    }
    Tab_VDFlipRect(v3, a3);
  }
  return v5;
}

//----- (6F7BB9AD) --------------------------------------------------------
INT_PTR __stdcall ChangeSel(HWND hWnd, INT_PTR i, int a3, int a4)
{
  INT_PTR v4; // esi@1
  INT_PTR result; // eax@1
  INT_PTR v6; // eax@7
  struct _DPA *v7; // eax@8
  PVOID v8; // edi@9
  int v9; // eax@14
  int v10; // ebx@19
  int v11; // ecx@19
  int v12; // eax@20
  int v13; // ecx@20
  int v14; // edi@22
  bool v15; // sf@22
  unsigned __int8 v16; // of@22
  bool v17; // zf@23
  int v18; // edx@24
  BOOL v19; // ebx@33
  int v20; // eax@33
  LONG v21; // edi@39
  LONG v22; // ebx@39
  struct tagRECT Rect; // [sp+8h] [bp-38h]@19
  int v24; // [sp+18h] [bp-28h]@3
  int v25; // [sp+1Ch] [bp-24h]@39
  struct tagPOINT Point; // [sp+28h] [bp-18h]@4
  int v27; // [sp+30h] [bp-10h]@19
  int v28; // [sp+34h] [bp-Ch]@22
  INT_PTR v29; // [sp+38h] [bp-8h]@7
  INT_PTR v30; // [sp+3Ch] [bp-4h]@23
  HWND hWnda; // [sp+48h] [bp+8h]@6

  v4 = (INT_PTR)hWnd;
  result = *((_DWORD *)hWnd + 15);
  if ( i == result )
    return result;
  if ( a4 && Tab_OnGetItemRect((int)hWnd, i, (int)&v24) )
  {
    Point = *(struct tagPOINT *)&v24;
  }
  else
  {
    Point.y = 0;
    Point.x = 0;
    a4 = 0;
  }
  hWnda = *(HWND *)hWnd;
  if ( i >= 0 )
  {
    v7 = *(struct _DPA **)(v4 + 40);
    if ( i >= *(_DWORD *)v7 )
      return -1;
    v8 = DPA_GetPtr(v7, i);
    if ( !v8 || *((_BYTE *)v8 + 48) & 4 )
      return -1;
    if ( a3 && SendNotifyEx(0, hWnda, -552, 0, *(_DWORD *)(v4 + 16) & 1) )
      return *(_DWORD *)(v4 + 60);
    v29 = *(_DWORD *)(v4 + 60);
    v9 = *(_DWORD *)(v4 + 8);
    *(_DWORD *)(v4 + 60) = i;
    if ( v9 & 0x200 )
    {
      if ( !(v9 & 0x100) && *(_DWORD *)(v4 + 112) > 0 && i != -1 )
        PutzRowToBottom(v4, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4) + 4 * i) + 40));
      goto LABEL_33;
    }
    v10 = 0;
    GetClientRect(*(HWND *)v4, &Rect);
    v11 = *(_DWORD *)v8;
    v27 = *(_DWORD *)v8;
    if ( v27 >= g_cxEdge )
    {
      v13 = *(_DWORD *)(v4 + 88);
      if ( i == v13 )
        goto LABEL_33;
      v14 = *((_DWORD *)v8 + 2);
      v16 = __OFSUB__(v14, *(_DWORD *)(v4 + 80));
      v17 = v14 == *(_DWORD *)(v4 + 80);
      v15 = v14 - *(_DWORD *)(v4 + 80) < 0;
      v28 = v14;
      if ( (unsigned __int8)(v15 ^ v16) | v17 )
        goto LABEL_33;
      v17 = v13 == i;
      v30 = v13;
      if ( v13 < i )
      {
        v18 = *(_DWORD *)(*(_DWORD *)(v4 + 40) + 4) + 4 * v13;
        do
        {
          v10 += **(_DWORD **)v18 - *(_DWORD *)(*(_DWORD *)v18 + 8);
          ++v30;
          v18 += 4;
          v13 = v30;
        }
        while ( v10 + v28 >= *(_DWORD *)(v4 + 80) && v30 < i );
        v17 = v30 == i;
      }
      if ( !v17 )
      {
LABEL_31:
        if ( v10 )
          Tab_Scroll(v4, v10, v13);
        goto LABEL_33;
      }
      v12 = g_cxEdge - v27;
    }
    else
    {
      v12 = g_cxEdge - v11;
      v13 = i;
    }
    v10 = v12;
    goto LABEL_31;
  }
  v6 = *(_DWORD *)(v4 + 60);
  *(_DWORD *)(v4 + 60) = -1;
  v29 = v6;
LABEL_33:
  v19 = 1;
  Tab_DeselectAll(v4, 1);
  v20 = *(_DWORD *)(v4 + 8);
  if ( !(v20 & 0x100) || v20 & 8 )
    UpdateWindow(hWnda);
  else
    v19 = 0;
  Tab_InvalidateItem(v4, v29, v19);
  Tab_InvalidateItem(v4, i, v19);
  UpdateWindow(hWnda);
  if ( a4 && Tab_OnGetItemRect(v4, i, (int)&v24) )
  {
    v21 = v24 - Point.x;
    v22 = v25 - Point.y;
    GetCursorPos(&Point);
    SetCursorPos(v21 + Point.x, v22 + Point.y);
  }
  if ( a3 )
    SendNotifyEx(0, hWnda, -551, 0, *(_DWORD *)(v4 + 16) & 1);
  MyNotifyWinEvent(32774, (int)hWnda, -4, *(_DWORD *)(v4 + 60) + 1);
  if ( GetFocus() == hWnda )
    MyNotifyWinEvent(32773, (int)hWnda, -4, *(_DWORD *)(v4 + 60) + 1);
  return v29;
}

//----- (6F7BBC03) --------------------------------------------------------
void __stdcall Tab_SetCurFocus(HWND hWnd, INT_PTR i)
{
  INT_PTR v2; // eax@4
  bool v3; // zf@7
  int v4; // edi@14
  HWND v5; // edi@15
  int v6; // [sp-Ch] [bp-28h]@13
  int v7; // [sp-4h] [bp-20h]@13
  int v8; // [sp+Ch] [bp-10h]@10
  int v9; // [sp+14h] [bp-8h]@10

  if ( *((_DWORD *)hWnd + 2) & 0x100 )
  {
    if ( i >= 0 && i < **((_DWORD **)hWnd + 10) )
    {
      v2 = *((_DWORD *)hWnd + 16);
      if ( v2 != i )
      {
        if ( v2 != -1 )
          Tab_InvalidateItem((int)hWnd, v2, 0);
        Tab_InvalidateItem((int)hWnd, i, 0);
        *((_DWORD *)hWnd + 11) |= 4u;
        v3 = (*((_DWORD *)hWnd + 2) & 0x200) == 0;
        *((_DWORD *)hWnd + 16) = i;
        if ( v3 )
        {
          while ( 1 )
          {
            Tab_OnGetItemRect((int)hWnd, i, (int)&v8);
            if ( v9 <= *((_DWORD *)hWnd + 20) )
              break;
            Tab_OnHScroll((int)hWnd, 0, 4, *((_DWORD *)hWnd + 22) + 1);
          }
          if ( v8 < 0 )
            Tab_OnHScroll((int)hWnd, 0, 4, i);
        }
        CCSendNotify((int)hWnd, -554, 0);
        v7 = i + 1;
        v6 = *(_DWORD *)hWnd;
        goto LABEL_17;
      }
    }
  }
  else
  {
    v4 = *((_DWORD *)hWnd + 15);
    ChangeSel(hWnd, i, 1, 0);
    if ( v4 != *((_DWORD *)hWnd + 15) )
    {
      v5 = *(HWND *)hWnd;
      if ( GetFocus() == v5 )
      {
        v7 = *((_DWORD *)hWnd + 15) + 1;
        v6 = (int)v5;
LABEL_17:
        MyNotifyWinEvent(32773, v6, -4, v7);
        return;
      }
    }
  }
}

//----- (6F7BBCEB) --------------------------------------------------------
int __stdcall Tab_OnKeyDown(HWND hWnd, int a2, int a3, int a4, int a5)
{
  int v5; // ST10_4@1
  HWND v6; // ST04_4@1
  INT_PTR v7; // edi@2
  int result; // eax@4
  int v9; // ecx@4
  int v10; // edi@15
  int v11; // eax@20
  int v12; // eax@22
  signed int v13; // [sp-4h] [bp-24h]@9
  LPARAM lParam; // [sp+Ch] [bp-14h]@1
  __int16 v15; // [sp+18h] [bp-8h]@1
  int v16; // [sp+1Ah] [bp-6h]@1

  v16 = a5;
  v5 = *((_DWORD *)hWnd + 4) & 1;
  v6 = *(HWND *)hWnd;
  v15 = a2;
  SendNotifyEx(0, v6, -550, (LPARAM)&lParam, v5);
  if ( !(*((_DWORD *)hWnd + 2) & 0x100) || (v7 = *((_DWORD *)hWnd + 16), *((_DWORD *)hWnd + 11) |= 6u, v7 == -1) )
    v7 = *((_DWORD *)hWnd + 15);
  result = RTLSwapLeftRightArrows((int)hWnd, a2);
  v9 = *((_DWORD *)hWnd + 2);
  if ( (char)v9 < 0 )
  {
    if ( result == 37 )
    {
      result = 40;
    }
    else
    {
      if ( result == 38 )
        goto LABEL_31;
      if ( result == 39 )
      {
        v13 = 38;
        goto LABEL_10;
      }
      if ( result == 40 )
      {
        v13 = 39;
LABEL_10:
        result = v13;
        goto LABEL_11;
      }
    }
  }
  if ( (unsigned int)result > 0x25 )
  {
LABEL_11:
    if ( result != 38 )
    {
      if ( result == 39 )
      {
        v10 = v7 + 1;
        goto LABEL_25;
      }
      if ( result != 40 )
        return result;
    }
    if ( v7 != -1 )
    {
      v10 = Tab_FindTab((int)hWnd, v7, result);
LABEL_25:
      if ( v10 < 0 )
        v10 = 0;
      Tab_SetCurFocus(hWnd, v10);
      goto LABEL_28;
    }
LABEL_24:
    v10 = 0;
    goto LABEL_25;
  }
  if ( result == 37 )
  {
LABEL_31:
    v10 = v7 - 1;
    goto LABEL_25;
  }
  v11 = result - 13;
  if ( !v11 )
    goto LABEL_37;
  result = v11 - 19;
  if ( result )
  {
    v12 = result - 3;
    if ( v12 )
    {
      result = v12 - 1;
      if ( result )
        return result;
      goto LABEL_24;
    }
    v7 = **((_DWORD **)hWnd + 10);
    goto LABEL_31;
  }
  if ( v9 & 0x100 )
  {
LABEL_37:
    ChangeSel(hWnd, v7, 1, 0);
    *((_DWORD *)hWnd + 16) = -1;
    *((_DWORD *)hWnd + 11) &= 0xFFFFFFFB;
LABEL_28:
    result = CCNotifyNavigationKeyUsage((int)hWnd, 3u);
  }
  return result;
}

//----- (6F7BBDE1) --------------------------------------------------------
int __stdcall TabDragCallback(HWND hWnd, int a2, WPARAM wParam, LPARAM lParam)
{
  int v4; // esi@1
  LONG v6; // edx@12
  HWND v7; // ST04_4@12
  int v8; // eax@12
  INT_PTR v9; // edi@12
  DWORD v10; // eax@14
  DWORD v11; // ecx@14
  struct tagPOINT Points; // [sp+8h] [bp-8h]@12
  LPARAM lParama; // [sp+24h] [bp+14h]@12

  v4 = GetWindowLongW(hWnd, 0);
  if ( !a2 )
  {
    if ( !lParam )
      return -1;
    v6 = *(_DWORD *)lParam;
    Points.y = *(_DWORD *)(lParam + 4);
    v7 = *(HWND *)v4;
    lParama = 1;
    Points.x = v6;
    MapWindowPoints(0, v7, &Points, 1u);
    v8 = Tab_OnHitTest(v4, Points.x, Points.y, 0);
    v9 = v8;
    if ( v8 == *(_DWORD *)(v4 + 60) )
      goto LABEL_22;
    if ( v8 >= 0 )
    {
      v10 = GetTickCount();
      v11 = *(_DWORD *)(v4 + 144);
      if ( v10 < v11 )
      {
        if ( v9 != *(_DWORD *)(v4 + 148) )
          goto LABEL_21;
      }
      else
      {
        if ( v11 )
        {
          ChangeSel((HWND)v4, v9, 1, 1);
          if ( *(_DWORD *)(v4 + 60) != v9 )
            v9 = -1;
          goto LABEL_21;
        }
        *(_DWORD *)(v4 + 144) = v10 + 500;
      }
      lParama = 0;
    }
LABEL_21:
    *(_DWORD *)(v4 + 148) = v9;
    if ( !lParama )
      return v9;
LABEL_22:
    *(_DWORD *)(v4 + 144) = 0;
    return v9;
  }
  if ( a2 == 1 )
    return GetItemObject(v4, -553, (int)&IID_IDropTarget, lParam);
  if ( a2 != 2 )
  {
    if ( (unsigned int)a2 > 2 && (unsigned int)a2 <= 4 )
    {
      *(_DWORD *)(v4 + 148) = -1;
      *(_DWORD *)(v4 + 144) = 0;
      return 1;
    }
    return -1;
  }
  if ( (wParam & 0x80000000) == 0 )
    SendMessageW(*(HWND *)v4, 0x1333u, wParam, lParam != 0);
  return 0;
}

//----- (6F7BBF12) --------------------------------------------------------
int __stdcall Tab_OnButtonUp(HWND hWnd, int a2, int cy, INT_PTR i)
{
  signed int v4; // edi@1
  int result; // eax@11
  INT_PTR v6; // ecx@12
  INT_PTR v7; // [sp-8h] [bp-14h]@8
  INT_PTR ia; // [sp+20h] [bp+14h]@5

  v4 = 1;
  if ( i )
    v4 = SendNotifyEx(0, *(HWND *)hWnd, -2, 0, *((_DWORD *)hWnd + 4) & 1) == 0;
  if ( *((_BYTE *)hWnd + 44) & 4 && *((_DWORD *)hWnd + 16) != -1 )
  {
    ia = *((_DWORD *)hWnd + 16);
    if ( Tab_OnHitTest((int)hWnd, a2, cy, 0) == ia )
    {
      if ( v4 )
        ChangeSel(hWnd, ia, 1, 0);
      v7 = ia;
    }
    else
    {
      Tab_InvalidateItem((int)hWnd, ia, 0);
      v7 = *((_DWORD *)hWnd + 16);
    }
    Tab_InvalidateItem((int)hWnd, v7, 0);
    *((_DWORD *)hWnd + 11) &= 0xFFFFFFFB;
    *((_DWORD *)hWnd + 16) = -1;
  }
  result = *((_DWORD *)hWnd + 11);
  if ( result & 2 )
  {
    v6 = *((_DWORD *)hWnd + 16);
    *((_DWORD *)hWnd + 16) = -1;
    *((_DWORD *)hWnd + 11) = result & 0xFFFFFFFD;
    Tab_InvalidateItem((int)hWnd, v6, 0);
    result = CCReleaseCapture((int)hWnd);
  }
  return result;
}

//----- (6F7BBFC3) --------------------------------------------------------
void __stdcall Tab_OnLButtonDown(INT_PTR a1, int a2, int cy, int a4)
{
  bool v4; // zf@2
  bool v5; // sf@2
  unsigned __int8 v6; // of@2
  INT_PTR v7; // edi@5
  int v8; // eax@10
  HWND v9; // ST0C_4@14
  int v10; // [sp+4h] [bp-20h]@9
  int v11; // [sp+8h] [bp-1Ch]@9
  int v12; // [sp+Ch] [bp-18h]@9
  INT_PTR v13; // [sp+20h] [bp-4h]@1

  v13 = -1;
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
  {
    v6 = __OFSUB__(cy, *(_DWORD *)(a1 + 80));
    v4 = cy == *(_DWORD *)(a1 + 80);
    v5 = cy - *(_DWORD *)(a1 + 80) < 0;
  }
  else
  {
    v6 = __OFSUB__(a2, *(_DWORD *)(a1 + 80));
    v4 = a2 == *(_DWORD *)(a1 + 80);
    v5 = a2 - *(_DWORD *)(a1 + 80) < 0;
  }
  if ( (unsigned __int8)(v5 ^ v6) | v4 )
  {
    v7 = Tab_OnHitTest(a1, a2, cy, 0);
    if ( v7 != -1 )
    {
      if ( *(_BYTE *)(a1 + 8) & 4 && GetAsyncKeyState(17) < 0 && *(_DWORD *)(a1 + 8) & 0x100 )
      {
        v10 = 16;
        v12 = 1;
        Tab_OnGetItem(a1, v7, (int)&v10);
        v11 ^= 1u;
        Tab_OnSetItem(a1, v7, (int)&v10);
      }
      else
      {
        v13 = *(_DWORD *)(a1 + 60);
        v8 = *(_DWORD *)(a1 + 8);
        if ( !(v8 & 0x8000) && v8 & 0x1000 )
          SetFocus(*(HWND *)a1);
        if ( *(_DWORD *)(a1 + 8) & 0x100 )
        {
          v9 = *(HWND *)a1;
          *(_DWORD *)(a1 + 44) |= 6u;
          *(_DWORD *)(a1 + 64) = v7;
          SetCapture(v9);
          Tab_InvalidateItem(a1, v7, *(_DWORD *)(a1 + 8) & 8);
        }
        else
        {
          v13 = ChangeSel((HWND)a1, v7, 1, 0);
        }
      }
    }
    if ( !(*(_DWORD *)(a1 + 8) & 0x8000) && v13 == v7 )
    {
      SetFocus(*(HWND *)a1);
      UpdateWindow(*(HWND *)a1);
    }
  }
}

//----- (6F7BC0C4) --------------------------------------------------------
int __stdcall Tab_ExtendedStyleChange(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@4

  v3 = *(_DWORD *)(a1 + 52);
  if ( *(_DWORD *)(a1 + 140) )
  {
    DestroyDragProxy(*(CDragProxy **)(a1 + 140));
    *(_DWORD *)(a1 + 140) = 0;
  }
  if ( a3 )
    v4 = a3 & a2 | *(_DWORD *)(a1 + 52) & ~a3;
  else
    v4 = a2;
  *(_DWORD *)(a1 + 52) = v4;
  if ( ((unsigned __int8)v4 ^ (unsigned __int8)v3) & 1 )
    InvalidateRect(*(HWND *)a1, 0, 1);
  if ( *(_BYTE *)(a1 + 52) & 2 )
    *(_DWORD *)(a1 + 140) = CreateDragProxy(*(_DWORD *)a1, (int)TabDragCallback, 1);
  return v3;
}

//----- (6F7BC142) --------------------------------------------------------
int __stdcall Header_OnGetItemOrder(int pitem, int a2)
{
  int v2; // edi@1
  struct _DSA *v3; // eax@1
  int v4; // esi@1
  int v5; // ebx@2

  v2 = pitem;
  v3 = *(struct _DSA **)(pitem + 96);
  v4 = 0;
  if ( v3 )
  {
    v5 = -1;
    if ( *(_DWORD *)v3 > 0 )
    {
      while ( !DSA_GetItem(v3, v4, &pitem) || pitem != a2 )
      {
        v3 = *(struct _DSA **)(v2 + 96);
        ++v4;
        if ( v4 >= *(_DWORD *)v3 )
          return v5;
      }
      v5 = v4;
    }
  }
  else
  {
    v5 = a2;
  }
  return v5;
}

//----- (6F7BC193) --------------------------------------------------------
int __stdcall Header_ItemOrderToIndex(int a1, int i)
{
  struct _DSA *v2; // eax@1

  v2 = *(struct _DSA **)(a1 + 96);
  if ( v2 )
    DSA_GetItem(v2, i, &i);
  return i;
}

//----- (6F7BC1BB) --------------------------------------------------------
PVOID __stdcall Header_GetItemPtrByOrder(int a1, int i)
{
  int v2; // eax@1

  v2 = Header_ItemOrderToIndex(a1, i);
  return DSA_GetItemPtr(*(HDSA *)(a1 + 60), v2);
}

//----- (6F7BC1E0) --------------------------------------------------------
int __stdcall Header_InitOrderArray(int i)
{
  int v1; // esi@1
  HDSA v2; // eax@3
  int v3; // eax@4

  v1 = i;
  if ( !*(_DWORD *)(i + 96) && !(*(_BYTE *)(i + 8) & 0x20) )
  {
    v2 = DSA_Create(4, 4);
    *(_DWORD *)(v1 + 96) = v2;
    if ( v2 )
    {
      v3 = *(_DWORD *)(v1 + 60);
      i = 0;
      if ( *(_DWORD *)v3 > 0 )
      {
        do
        {
          if ( DSA_InsertItem(*(HDSA *)(v1 + 96), i, &i) == -1 )
          {
            DSA_Destroy(*(HDSA *)(v1 + 96));
            *(_DWORD *)(v1 + 96) = 0;
          }
          ++i;
        }
        while ( i < **(_DWORD **)(v1 + 60) );
      }
    }
  }
  return *(_DWORD *)(v1 + 96);
}

//----- (6F7BC24B) --------------------------------------------------------
int __stdcall Header_ShiftItems(int a1, int i, int a3)
{
  int j; // esi@1
  PVOID v4; // eax@2
  int result; // eax@3

  for ( j = i; ; ++j )
  {
    result = *(_DWORD *)(a1 + 60);
    if ( j >= *(_DWORD *)result )
      break;
    v4 = Header_GetItemPtrByOrder(a1, j);
    *(_DWORD *)v4 += a3;
  }
  return result;
}

//----- (6F7BC279) --------------------------------------------------------
int __stdcall Header_OnSetItemOrder(int pitem, int i, int a3)
{
  int v3; // esi@1
  int result; // eax@1
  int v5; // ebx@2
  PVOID v6; // edi@5
  int v7; // eax@6
  PVOID v8; // eax@7
  int pitema; // [sp+Ch] [bp+8h]@4

  v3 = pitem;
  result = **(_DWORD **)(pitem + 60);
  if ( i < result )
  {
    v5 = a3;
    if ( a3 < result )
    {
      result = Header_InitOrderArray(pitem);
      if ( result )
      {
        result = Header_OnGetItemOrder(pitem, i);
        pitema = result;
        if ( v5 != result )
        {
          v6 = DSA_GetItemPtr(*(HDSA *)(v3 + 60), i);
          Header_StopFilterEdit(v3, 0);
          Header_ShiftItems(v3, pitema + 1, -*((_DWORD *)v6 + 1));
          DSA_DeleteItem(*(HDSA *)(v3 + 96), pitema);
          DSA_InsertItem(*(HDSA *)(v3 + 96), v5, &i);
          Header_ShiftItems(v3, v5 + 1, *((_DWORD *)v6 + 1));
          if ( v5 )
          {
            v8 = Header_GetItemPtrByOrder(v3, v5 - 1);
            if ( !v8 )
              return RedrawWindow(*(HWND *)v3, 0, 0, 5u);
            v7 = *((_DWORD *)v6 + 1) + *(_DWORD *)v8;
          }
          else
          {
            v7 = *((_DWORD *)v6 + 1);
          }
          *(_DWORD *)v6 = v7;
          return RedrawWindow(*(HWND *)v3, 0, 0, 5u);
        }
      }
    }
  }
  return result;
}

//----- (6F7BC33C) --------------------------------------------------------
signed int __stdcall Header_OnGetOrderArray(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int result; // eax@2
  int v5; // esi@3

  v3 = **(_DWORD **)(a1 + 60);
  if ( v3 == a2 )
  {
    v5 = 0;
    if ( v3 > 0 )
    {
      do
      {
        *(_DWORD *)(a3 + 4 * v5) = Header_ItemOrderToIndex(a1, v5);
        ++v5;
      }
      while ( v5 < **(_DWORD **)(a1 + 60) );
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BC37D) --------------------------------------------------------
int __stdcall Header_OnSetOrderArray(int pitem, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@2
  int v5; // esi@3

  v3 = **(_DWORD **)(pitem + 60);
  if ( v3 == a2 )
  {
    v5 = 0;
    if ( v3 > 0 )
    {
      do
      {
        Header_OnSetItemOrder(pitem, *(_DWORD *)(a3 + 4 * v5), v5);
        ++v5;
      }
      while ( v5 < **(_DWORD **)(pitem + 60) );
    }
    MyNotifyWinEvent(32772, *(_DWORD *)pitem, -4, 0);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BC3CE) --------------------------------------------------------
signed int __stdcall HDDragFullWindows(int a1)
{
  signed int result; // eax@1

  result = 0;
  if ( g_fDragFullWindows )
  {
    if ( *(_BYTE *)(a1 + 8) & 0x80 )
      result = 1;
  }
  return result;
}
// 6F7E68A0: using guessed type int g_fDragFullWindows;

//----- (6F7BC3F0) --------------------------------------------------------
BOOL __stdcall Header_SendChange(int a1, int a2, int a3, int a4)
{
  LPARAM lParam; // [sp+0h] [bp-18h]@1
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v7 = 0;
  v6 = a2;
  v8 = a4;
  return CCSendNotify(a1, a3, (LPARAM)&lParam) == 0;
}

//----- (6F7BC425) --------------------------------------------------------
BOOL __stdcall Header_Notify(int a1, int a2, int a3, int a4)
{
  LPARAM lParam; // [sp+0h] [bp-18h]@1
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@1
  int v8; // [sp+14h] [bp-4h]@1

  v8 = 0;
  v6 = a2;
  v7 = a3;
  return CCSendNotify(a1, a4, (LPARAM)&lParam) == 0;
}

//----- (6F7BC45A) --------------------------------------------------------
int __stdcall Header_NewFont(int a1, HGDIOBJ h)
{
  HDC v2; // eax@1
  HDC v3; // ebx@1
  struct tagSIZE sz; // [sp+Ch] [bp-8h]@1

  sz.cx = 0;
  sz.cy = 0;
  v2 = GetDC(0);
  v3 = v2;
  if ( h )
    SelectObject(v2, h);
  GetTextExtentPointW(v3, L"...", 3, &sz);
  *(_DWORD *)(a1 + 40) = sz.cx;
  *(_DWORD *)(a1 + 48) = sz.cy;
  *(_DWORD *)(a1 + 52) = h;
  *(_DWORD *)(a1 + 20) = GetCodePageForFont(h);
  return ReleaseDC(0, v3);
}

//----- (6F7BC4C8) --------------------------------------------------------
signed int __stdcall Header_OnCreate(int a1, int a2)
{
  HDSA v2; // eax@1
  signed int result; // eax@2

  CIInitialize(a1, *(_DWORD *)a1, a2);
  *(_DWORD *)(a1 + 108) = -1;
  *(_DWORD *)(a1 + 100) = -1;
  *(_DWORD *)(a1 + 124) = -1;
  *(_DWORD *)(a1 + 128) = -1;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 132) = 2 * GetDoubleClickTime();
  *(_DWORD *)(a1 + 136) = 0;
  v2 = DSA_Create(60, 4);
  *(_DWORD *)(a1 + 60) = v2;
  if ( v2 )
  {
    *(_DWORD *)(a1 + 44) = 8 * g_cxBorder;
    *(_DWORD *)(a1 + 112) = 3 * g_cxLabelMargin;
    *(_DWORD *)(a1 + 116) = 3 * g_cxLabelMargin;
    Header_NewFont(a1, 0);
    result = 1;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7BC55D) --------------------------------------------------------
int __stdcall Header_DestroyItemCallback(void *p, void *pData)
{
  if ( p )
  {
    Str_Set((int)((char *)p + 12), 0);
    if ( !(*((_BYTE *)p + 44) & 0xF) )
      Str_Set((int)((char *)p + 48), 0);
  }
  return 1;
}

//----- (6F7BC593) --------------------------------------------------------
int __stdcall Header_DrawDivider(HWND *a1, LONG a2)
{
  HDC v2; // edi@1
  struct tagRECT Rect; // [sp+8h] [bp-10h]@1

  v2 = GetDC(*a1);
  GetClientRect(*a1, &Rect);
  Rect.left = a2;
  Rect.right = a2 + g_cxBorder;
  InvertRect(v2, &Rect);
  return ReleaseDC(*a1, v2);
}

//----- (6F7BC5E6) --------------------------------------------------------
int __stdcall Header_PinDividerPos(int a1, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 76) + a2;
  if ( result < *(_DWORD *)(a1 + 84) )
    result = *(_DWORD *)(a1 + 84);
  return result;
}

//----- (6F7BC606) --------------------------------------------------------
signed int __stdcall Header_IsTracking(int a1)
{
  if ( !*(_DWORD *)(a1 + 72) )
    return 0;
  if ( GetCapture() != *(HWND *)a1 )
  {
    *(_DWORD *)(a1 + 72) = 0;
    return 0;
  }
  return 1;
}

//----- (6F7BC636) --------------------------------------------------------
HGDIOBJ __stdcall Header_OnSetFont(int a1, HGDIOBJ h, int a3)
{
  HGDIOBJ result; // eax@2

  if ( a1 )
  {
    result = h;
    if ( h != *(HGDIOBJ *)(a1 + 52) )
    {
      result = (HGDIOBJ)Header_NewFont(a1, h);
      if ( a3 )
        result = (HGDIOBJ)RedrawWindow(*(HWND *)a1, 0, 0, 5u);
    }
  }
  return result;
}

//----- (6F7BC670) --------------------------------------------------------
int __stdcall Header_OnGetFont(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    result = *(_DWORD *)(a1 + 52);
  return result;
}

//----- (6F7BC688) --------------------------------------------------------
int __stdcall Header_OnGetItem(int pitem, int i, int a3)
{
  int v3; // esi@1
  int v4; // ebx@5
  struct _DSA *v5; // ST04_4@5
  PVOID v6; // eax@5
  PVOID v7; // edi@5
  const WCHAR *v8; // eax@15
  int v9; // eax@21
  int v10; // ebx@25
  int v11; // eax@26
  int v12; // eax@35
  int v13; // ecx@35
  STRSAFE_LPCWSTR v14; // eax@41
  LPARAM lParam; // [sp+Ch] [bp-24h]@37
  int v17; // [sp+1Ch] [bp-14h]@5
  LPCWSTR lpString; // [sp+20h] [bp-10h]@35
  int v19; // [sp+24h] [bp-Ch]@35
  int v20; // [sp+28h] [bp-8h]@34
  int v21; // [sp+2Ch] [bp-4h]@34
  int ia; // [sp+3Ch] [bp+Ch]@14
  int v23; // [sp+40h] [bp+10h]@5

  v3 = a3;
  if ( !a3 || !pitem )
    return 0;
  if ( *(_DWORD *)a3 & 0xFFFFFC00 )
    *(_DWORD *)a3 &= 0x1Fu;
  v4 = *(_DWORD *)a3;
  v5 = *(struct _DSA **)(pitem + 60);
  v17 = 0;
  v23 = v4;
  v6 = DSA_GetItemPtr(v5, i);
  v7 = v6;
  if ( !v6 )
    return 0;
  if ( v4 & 1 )
    *(_DWORD *)(v3 + 4) = *((_DWORD *)v6 + 1);
  if ( v4 & 4 )
    *(_DWORD *)(v3 + 20) = *((_DWORD *)v6 + 2);
  if ( (char)v4 < 0 )
    *(_DWORD *)(v3 + 32) = Header_OnGetItemOrder(pitem, i);
  if ( v4 & 8 )
    *(_DWORD *)(v3 + 24) = *((_DWORD *)v7 + 6);
  ia = v4 & 2;
  if ( v4 & 2 )
  {
    v8 = (const WCHAR *)*((_DWORD *)v7 + 3);
    if ( v8 == (const WCHAR *)-1 )
    {
      *((_DWORD *)v7 + 8) = 0x7FFFFFFF;
      v17 |= 2u;
    }
    else
    {
      Str_GetPtrW(v8, *(void **)(v3 + 8), *(_DWORD *)(v3 + 16));
    }
  }
  if ( v4 & 0x10 )
    *(_DWORD *)(v3 + 12) = *((_DWORD *)v7 + 4);
  if ( v4 & 0x20 )
  {
    v9 = *((_DWORD *)v7 + 5);
    if ( v9 == -1 )
      v17 |= 0x20u;
    else
      *(_DWORD *)(v3 + 28) = v9;
  }
  if ( !(v4 & 0x100) )
    goto LABEL_33;
  v10 = *(_DWORD *)(v3 + 40);
  if ( v10 )
  {
    v11 = *((_DWORD *)v7 + 11) & 0xF;
    if ( v11 == (*(_DWORD *)(v3 + 36) & 0xF) )
    {
      if ( v11 )
      {
        if ( v11 == 1 )
        {
          *(_DWORD *)v10 = *((_DWORD *)v7 + 14);
          goto LABEL_32;
        }
      }
      else if ( Str_GetPtrW(*((LPCWSTR *)v7 + 12), *(void **)v10, *(_DWORD *)(v10 + 4)) )
      {
        *(_DWORD *)(v10 + 4) = *((_DWORD *)v7 + 13);
        goto LABEL_32;
      }
    }
    return 0;
  }
LABEL_32:
  v4 = v23;
  *(_DWORD *)(v3 + 36) = *((_DWORD *)v7 + 11);
LABEL_33:
  if ( v17 )
  {
    v20 = -1;
    v21 = *((_DWORD *)v7 + 6);
    if ( v17 & 2 )
    {
      v12 = *(_DWORD *)(v3 + 16);
      v13 = *(_DWORD *)(v3 + 8);
      lpString = *(LPCWSTR *)(v3 + 8);
      v19 = v12;
      if ( v12 )
        *(_WORD *)v13 = 0;
    }
    CCSendNotify(pitem, -329, (LPARAM)&lParam);
    if ( v17 & 0x20 )
      *(_DWORD *)(v3 + 28) = v20;
    if ( v17 & 2 )
    {
      if ( ia )
        v14 = CCReturnDispInfoText(lpString, *(STRSAFE_LPWSTR *)(v3 + 8), *(_DWORD *)(v3 + 16));
      else
        v14 = lpString;
      *(_DWORD *)(v3 + 8) = v14;
    }
  }
  if ( v17 & 0x40 )
  {
    if ( v17 & 0x20 )
      *((_DWORD *)v7 + 5) = v20;
    if ( v17 & 2 )
    {
      if ( lpString )
        Str_Set((int)((char *)v7 + 12), lpString);
    }
  }
  *(_DWORD *)v3 = v4;
  return 1;
}

//----- (6F7BC856) --------------------------------------------------------
signed int __stdcall Header_OnLayout(int a1, int a2)
{
  int v2; // ecx@3
  int v3; // eax@4
  int v4; // esi@5
  int v5; // edx@5
  int v6; // edx@9
  signed int result; // eax@9

  if ( a2 && a1 && (v2 = *(_DWORD *)(a2 + 4)) != 0 && (v3 = *(_DWORD *)a2) != 0 )
  {
    v4 = *(_DWORD *)(a1 + 48) + 2 * g_cyEdge;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 & 0x100 )
      v4 = 2 * v4 + 1;
    if ( v5 & 8 )
      v4 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 24) = 20;
    *(_DWORD *)(v2 + 8) = *(_DWORD *)v3;
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(v3 + 8) - *(_DWORD *)v3;
    v6 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v2 + 20) = v4;
    *(_DWORD *)(v2 + 12) = v6;
    *(_DWORD *)(v3 + 4) += v4;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BC8D0) --------------------------------------------------------
int __stdcall Header_OnGetItemRect(int a1, int i, LPRECT lpRect)
{
  int result; // eax@1
  int v4; // edi@1
  LONG v5; // eax@2

  result = (int)DSA_GetItemPtr(*(HDSA *)(a1 + 60), i);
  v4 = result;
  if ( result )
  {
    GetClientRect(*(HWND *)a1, lpRect);
    v5 = *(_DWORD *)v4;
    lpRect->right = *(_DWORD *)v4;
    lpRect->left = v5 - *(_DWORD *)(v4 + 4);
    result = 1;
  }
  return result;
}

//----- (6F7BC911) --------------------------------------------------------
int __stdcall Header_InvalidateItem(int a1, int i, UINT flags)
{
  int result; // eax@2
  struct tagRECT rc; // [sp+0h] [bp-10h]@2

  if ( i != -1 )
  {
    Header_OnGetItemRect(a1, i, &rc);
    InflateRect(&rc, g_cxBorder, g_cyBorder);
    result = RedrawWindow(*(HWND *)a1, &rc, 0, flags);
  }
  return result;
}

//----- (6F7BC961) --------------------------------------------------------
LONG __stdcall _Header_DrawBitmap(HDC hdc, HIMAGELIST himl, int a3, HDC hdcSrc, int a5, char a6, LPRECT lprc, int a8)
{
  int v8; // ebx@1
  LONG result; // eax@2
  int v10; // edx@5
  HDC v11; // eax@7
  LONG v12; // ecx@12
  LONG v13; // eax@18
  int v14; // esi@24
  LONG v15; // ecx@24
  signed int v16; // eax@25
  int v17; // edi@25
  int v18; // eax@30
  LONG v19; // ecx@30
  LONG v20; // ecx@30
  int v21; // eax@30
  LONG v22; // ecx@30
  IMAGELISTDRAWPARAMS pimldp; // [sp+8h] [bp-7Ch]@28
  char pv; // [sp+4Ch] [bp-38h]@6
  int v25; // [sp+50h] [bp-34h]@9
  int v26; // [sp+54h] [bp-30h]@9
  struct tagRECT rc; // [sp+64h] [bp-20h]@3
  HGDIOBJ h; // [sp+74h] [bp-10h]@8
  int v29; // [sp+78h] [bp-Ch]@1
  int cy; // [sp+7Ch] [bp-8h]@5
  int v31; // [sp+80h] [bp-4h]@5
  int v32; // [sp+A8h] [bp+24h]@4

  v8 = 0;
  v29 = 0;
  SetRectEmpty(lprc);
  if ( IsRectEmpty((const RECT *)hdcSrc) )
    return *(_DWORD *)hdcSrc;
  rc.left = *(_DWORD *)hdcSrc;
  rc.top = *((_DWORD *)hdcSrc + 1);
  rc.right = *((_DWORD *)hdcSrc + 2);
  rc.bottom = *((_DWORD *)hdcSrc + 3);
  rc.left += a8;
  rc.right -= a8;
  if ( rc.left >= rc.right )
    return rc.left;
  v32 = *(_DWORD *)(a3 + 20) & 0x800;
  if ( v32 )
  {
    ImageList_GetIconSize(himl, &v31, &cy);
    v10 = v31;
    goto LABEL_10;
  }
  if ( GetObjectW(*(HANDLE *)(a3 + 12), 24, &pv) != 24 )
    return rc.left;
  v11 = CreateCompatibleDC(hdc);
  hdcSrc = v11;
  if ( !v11 )
    return rc.left;
  h = SelectObject(v11, *(HGDIOBJ *)(a3 + 12));
  if ( !h )
    return rc.left;
  v10 = v25;
  v31 = v25;
  cy = v26;
LABEL_10:
  if ( a6 & 0x20 )
  {
    OffsetRect(&rc, g_cxBorder, g_cyBorder);
    v10 = v31;
  }
  v12 = rc.right - rc.left;
  if ( !a5 )
  {
    if ( v10 <= v12 )
      goto LABEL_24;
    goto LABEL_21;
  }
  if ( a5 != 2 )
  {
    if ( v10 > v12 )
    {
      v8 = v10 - v12;
      goto LABEL_21;
    }
    v13 = rc.right - v10;
LABEL_23:
    rc.left = v13;
    goto LABEL_24;
  }
  if ( v10 <= v12 )
  {
    v13 = (rc.left + rc.right - v10) / 2;
    goto LABEL_23;
  }
  v8 = (v10 - v12) / 2;
LABEL_21:
  v31 = rc.right - rc.left;
LABEL_24:
  v14 = rc.top;
  v15 = rc.bottom - rc.top;
  if ( cy <= rc.bottom - rc.top )
  {
    v17 = v29;
    v14 = (v15 - cy) / 2;
    rc.top = (v15 - cy) / 2;
  }
  else
  {
    v16 = cy + rc.top - rc.bottom;
    cy = rc.bottom - rc.top;
    v17 = v16 / 2;
  }
  if ( v32 )
  {
    memset(&pimldp.himl, 0, 0x40u);
    pimldp.himl = himl;
    pimldp.fStyle = 0;
    pimldp.hdcDst = hdc;
    pimldp.i = *(_DWORD *)(a3 + 28);
    pimldp.x = rc.left;
    pimldp.cx = v31;
    pimldp.cy = cy;
    pimldp.rgbBk = -16777216;
    pimldp.rgbFg = -16777216;
    pimldp.cbSize = 68;
    pimldp.y = v14;
    pimldp.xBitmap = v8;
    pimldp.yBitmap = v17;
    ImageList_DrawIndirect(&pimldp);
  }
  else
  {
    BitBlt(hdc, rc.left, v14, v31, cy, hdcSrc, v8, v17, 0xCC0020u);
    SelectObject(hdcSrc, h);
    DeleteDC(hdcSrc);
  }
  v18 = cy;
  v19 = rc.top;
  *lprc = rc;
  v20 = v18 + v19;
  v21 = v31;
  lprc->bottom = v20;
  v22 = rc.left;
  result = rc.left + v21;
  lprc->right = result;
  if ( *(_BYTE *)(a3 + 20) & 1 )
    result = v22;
  return result;
}

//----- (6F7BCB8E) --------------------------------------------------------
int __stdcall Header_DrawButtonEdges(int a1, HDC hdc, LPRECT qrc, int a4)
{
  unsigned int v4; // eax@1
  int result; // eax@3

  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 & 2 )
  {
    if ( a4 )
      result = DrawEdge(hdc, qrc, 0xAu, 0x500Fu);
    else
      result = DrawEdge(hdc, qrc, 5u, 0x100Fu);
  }
  else
  {
    result = DrawEdge(hdc, qrc, 6u, ~(unsigned __int8)(v4 >> 20) & 8 | 4);
  }
  return result;
}

//----- (6F7BCBDA) --------------------------------------------------------
HIMAGELIST __stdcall Header_DrawFilterGlyph(int a1, HDC hdc, int a3, int a4)
{
  signed int v4; // ebx@1
  HIMAGELIST result; // eax@4
  struct tagRECT qrc; // [sp+Ch] [bp-14h]@1
  UINT edge; // [sp+1Ch] [bp-4h]@1

  qrc.left = *(_DWORD *)a3;
  qrc.top = *(_DWORD *)(a3 + 4);
  qrc.right = *(_DWORD *)(a3 + 8);
  qrc.bottom = *(_DWORD *)(a3 + 12);
  edge = 5;
  v4 = 15;
  if ( a4 )
  {
    edge = 10;
    v4 = 20495;
  }
  if ( *(_DWORD *)(a1 + 56)
    || (result = ImageList_LoadImageW(g_hinst, (LPCWSTR)0x8C, 13, 0, 0x80u, 0, 0), (*(_DWORD *)(a1 + 56) = result) != 0) )
  {
    DrawEdge(hdc, &qrc, edge, v4 | 0x800);
    if ( a4 )
      OffsetRect(&qrc, g_cxBorder, g_cyBorder);
    result = (HIMAGELIST)ImageList_Draw(
                           *(HIMAGELIST *)(a1 + 56),
                           0,
                           hdc,
                           qrc.left + (qrc.right - qrc.left - 13) / 2,
                           qrc.top + (qrc.bottom - qrc.top - 12) / 2,
                           0);
  }
  return result;
}

//----- (6F7BCCA4) --------------------------------------------------------
int __stdcall Header_GetFilterRects(int a1, int a2, int a3, int a4)
{
  __int64 v4; // rax@1
  int v5; // edi@1
  int result; // eax@1

  v4 = *(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 4) - 1;
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  v5 = a2 + 8;
  *(_DWORD *)v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)a3 = *(_DWORD *)a2;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)a4 = *(_DWORD *)a3;
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a4 + 12) = *(_DWORD *)(a3 + 12);
  result = ((signed int)v4 - HIDWORD(v4)) >> 1;
  *(_DWORD *)(a2 + 12) = result + *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a3 + 8) += -13 - 4 * g_cxBorder;
  *(_DWORD *)a4 = *(_DWORD *)(a3 + 8);
  HIDWORD(v4) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 4) = HIDWORD(v4);
  *(_DWORD *)(a4 + 4) = HIDWORD(v4);
  *(_DWORD *)(a3 + 12) = result + *(_DWORD *)(a3 + 4);
  return result;
}

//----- (6F7BCD15) --------------------------------------------------------
int __stdcall Header_SetHotItem(int a1, int i)
{
  int result; // eax@2

  if ( i != *(_DWORD *)(a1 + 100) )
  {
    Header_InvalidateItem(a1, i, 1u);
    result = Header_InvalidateItem(a1, *(_DWORD *)(a1 + 100), 1u);
    *(_DWORD *)(a1 + 100) = i;
  }
  return result;
}

//----- (6F7BCD49) --------------------------------------------------------
int __stdcall Header_HitTest(int a1, LONG a2, LONG a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int result; // eax@1
  LONG v7; // esi@12
  PVOID v8; // eax@13
  int v9; // ecx@16
  char v10; // [sp+8h] [bp-64h]@24
  char v11; // [sp+18h] [bp-54h]@24
  LONG v12; // [sp+24h] [bp-48h]@28
  char v13; // [sp+28h] [bp-44h]@24
  LONG v14; // [sp+2Ch] [bp-40h]@24
  LONG v15; // [sp+30h] [bp-3Ch]@25
  int v16; // [sp+38h] [bp-34h]@24
  LONG v17; // [sp+3Ch] [bp-30h]@24
  LONG v18; // [sp+40h] [bp-2Ch]@24
  LONG v19; // [sp+44h] [bp-28h]@24
  struct tagRECT Rect; // [sp+48h] [bp-24h]@1
  PVOID v21; // [sp+58h] [bp-14h]@13
  int v22; // [sp+5Ch] [bp-10h]@10
  int v23; // [sp+60h] [bp-Ch]@16
  int v24; // [sp+64h] [bp-8h]@10
  int i; // [sp+68h] [bp-4h]@10
  int v26; // [sp+74h] [bp+8h]@1

  v4 = a1;
  GetClientRect(*(HWND *)a1, &Rect);
  v5 = 0;
  result = -1;
  v26 = 0;
  if ( a2 >= Rect.left )
  {
    if ( a2 >= Rect.right )
      v26 = 1024;
  }
  else
  {
    v26 = 2048;
  }
  if ( a3 >= Rect.top )
  {
    if ( a3 >= Rect.bottom )
      v26 |= 0x200u;
  }
  else
  {
    v26 |= 0x100u;
  }
  if ( v26 )
    goto LABEL_40;
  v22 = **(_DWORD **)(v4 + 60);
  v24 = 0;
  i = 0;
  if ( v22 < 0 )
    goto LABEL_37;
  while ( 1 )
  {
    if ( i == v22 )
    {
      v7 = Rect.right;
    }
    else
    {
      v8 = Header_GetItemPtrByOrder(v4, i);
      v7 = *(_DWORD *)v8;
      v21 = v8;
    }
    if ( v7 != v5 )
      break;
    v24 = 1;
LABEL_21:
    ++i;
    v21 = (char *)v21 + 60;
    v5 = v7;
    if ( i > v22 )
      goto LABEL_37;
  }
  v9 = *(_DWORD *)(v4 + 44);
  v23 = (v7 - v5) / 4;
  if ( v23 >= v9 )
    v23 = v9;
  if ( a2 < v5 || a2 >= v7 )
  {
    v24 = 0;
    goto LABEL_21;
  }
  if ( !(*(_DWORD *)(v4 + 8) & 0x100) )
  {
LABEL_29:
    v26 = 2;
    goto LABEL_30;
  }
  v17 = Rect.top;
  v19 = Rect.bottom;
  v16 = v5;
  v18 = v7;
  Header_GetFilterRects((int)&v16, (int)&v11, (int)&v13, (int)&v10);
  if ( a3 < v14 )
  {
    if ( a3 >= v12 )
      goto LABEL_30;
    goto LABEL_29;
  }
  if ( a2 >= v15 )
  {
    v26 = 32;
    goto LABEL_37;
  }
  v26 = 16;
LABEL_30:
  if ( i <= 0 || a2 >= v5 + v23 )
  {
    if ( a2 >= v7 - v23 )
      v26 = 4;
  }
  else
  {
    --i;
    v26 = 4;
    if ( v24 && a2 > v5 )
      v26 = 8;
  }
LABEL_37:
  if ( i == v22 )
  {
    result = -1;
    v26 = 1;
  }
  else
  {
    result = Header_ItemOrderToIndex(v4, i);
  }
LABEL_40:
  *(_DWORD *)a4 = v26;
  return result;
}

//----- (6F7BCEF3) --------------------------------------------------------
int __stdcall Header_OnHitTest(int a1, int a2)
{
  int result; // eax@3

  if ( a2 && a1 )
  {
    result = Header_HitTest(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), a2 + 8);
    *(_DWORD *)(a2 + 12) = result;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7BCF29) --------------------------------------------------------
int __stdcall Header_OnSetCursor(int a1, HWND hWnd, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@4
  HINSTANCE v6; // ecx@4
  signed int v7; // edx@7
  PVOID v8; // eax@8
  HCURSOR v9; // eax@13
  signed int v11; // [sp-4h] [bp-10h]@10
  struct tagPOINT Point; // [sp+4h] [bp-8h]@4

  v4 = a1;
  if ( a1 && *(HWND *)a1 == hWnd && (unsigned int)a3 < 0x8000 )
  {
    GetMessagePosClient(hWnd, &Point);
    v5 = Header_HitTest(v4, Point.x, Point.y, (int)&a1);
    v6 = g_hinst;
    if ( a1 == 4 )
    {
      v11 = 106;
    }
    else
    {
      if ( a1 != 8 )
      {
        if ( a1 == 16 )
        {
          v8 = Header_GetItemPtrByOrder(v4, v5);
          v6 = 0;
          v7 = 32512;
          if ( (*((_DWORD *)v8 + 11) & 0xFu) <= 1 )
            v7 = 32513;
        }
        else
        {
          v7 = 32512;
          v6 = 0;
        }
        goto LABEL_13;
      }
      v11 = 107;
    }
    v7 = v11;
LABEL_13:
    v9 = LoadCursorW(v6, (LPCWSTR)v7);
    SetCursor(v9);
    return 1;
  }
  return 0;
}

//----- (6F7BCFC8) --------------------------------------------------------
int __stdcall Header_GetDividerRect(int a1, int i, LPRECT lprc)
{
  int v3; // eax@1
  int result; // eax@2
  signed int v5; // ebx@3
  int v6; // eax@6

  v3 = i;
  if ( i == -1 )
  {
    result = SetRectEmpty(lprc);
  }
  else
  {
    v5 = 0;
    if ( i >= **(_DWORD **)(a1 + 60) )
      v3 = i - 1;
    else
      v5 = 1;
    v6 = Header_ItemOrderToIndex(a1, v3);
    Header_OnGetItemRect(a1, v6, lprc);
    if ( v5 )
      lprc->right = lprc->left;
    else
      lprc->left = lprc->right;
    result = InflateRect(lprc, g_cxBorder, 0);
  }
  return result;
}

//----- (6F7BD030) --------------------------------------------------------
int __stdcall Header_OnGetItemA(int pitem, int i, int a3)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // eax@4
  int v6; // ST1C_4@6
  void *v7; // eax@6
  int v8; // eax@10
  HLOCAL v10; // ST1C_4@18
  LPCWSTR lpWideCharStr; // [sp+Ch] [bp-10h]@11
  int v12; // [sp+10h] [bp-Ch]@11
  LPSTR lpMultiByteStr; // [sp+14h] [bp-8h]@1
  HLOCAL hMem; // [sp+18h] [bp-4h]@1
  int v15; // [sp+2Ch] [bp+10h]@17

  v3 = a3;
  v4 = 0;
  hMem = 0;
  lpMultiByteStr = 0;
  if ( !a3 || !pitem )
    return 0;
  if ( *(_BYTE *)a3 & 2 )
  {
    v5 = *(_DWORD *)(a3 + 8);
    if ( v5 != -1 )
    {
      if ( v5 )
      {
        v6 = *(_DWORD *)(a3 + 16);
        lpMultiByteStr = *(LPSTR *)(a3 + 8);
        v7 = (void *)CCLocalAllocArray_WCHAR(v6);
        hMem = v7;
        if ( !v7 )
          return 0;
        *(_DWORD *)(a3 + 8) = v7;
      }
    }
  }
  if ( *(_DWORD *)a3 & 0x100 )
  {
    if ( !(*(_BYTE *)(a3 + 36) & 0xF) )
    {
      v8 = *(_DWORD *)(a3 + 40);
      if ( v8 )
      {
        v4 = *(_DWORD *)(a3 + 40);
        lpWideCharStr = (LPCWSTR)CCLocalAllocArray_WCHAR(*(_DWORD *)(v8 + 4));
        v12 = *(_DWORD *)(v4 + 4);
        if ( !lpWideCharStr )
        {
          if ( hMem )
            LocalFree(hMem);
          return 0;
        }
        *(_DWORD *)(a3 + 40) = &lpWideCharStr;
      }
    }
  }
  v15 = Header_OnGetItem(pitem, i, a3);
  if ( hMem )
  {
    WideCharToMultiByte(*(_DWORD *)(pitem + 20), 0, (LPCWSTR)hMem, -1, lpMultiByteStr, *(_DWORD *)(v3 + 16), 0, 0);
    v10 = hMem;
    *(_DWORD *)(v3 + 8) = lpMultiByteStr;
    LocalFree(v10);
  }
  if ( v4 )
  {
    WideCharToMultiByte(*(_DWORD *)(pitem + 20), 0, lpWideCharStr, -1, *(LPSTR *)v4, *(_DWORD *)(v4 + 4), 0, 0);
    *(_DWORD *)(v3 + 40) = v4;
  }
  return v15;
}
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F7BD129) --------------------------------------------------------
int __stdcall Header_OnSetItem(int pitem, int i, int a3)
{
  int v3; // edi@1
  int v4; // ebx@2
  PVOID v5; // esi@3
  int v7; // eax@8
  int v8; // edi@10
  int v9; // eax@12
  int v10; // eax@25
  int v11; // eax@31
  int v12; // eax@31
  int v13; // eax@34
  int v14; // eax@36
  int dy; // [sp+Ch] [bp-50h]@12
  int v16; // [sp+10h] [bp-4Ch]@12
  HWND v17; // [sp+14h] [bp-48h]@12
  int v18; // [sp+18h] [bp-44h]@12
  int v19; // [sp+1Ch] [bp-40h]@12
  int v20; // [sp+20h] [bp-3Ch]@12
  struct tagRECT *v21; // [sp+24h] [bp-38h]@12
  int v22; // [sp+28h] [bp-34h]@12
  int v23; // [sp+2Ch] [bp-30h]@12
  int v24; // [sp+30h] [bp-2Ch]@12
  int v25; // [sp+34h] [bp-28h]@12
  int v26; // [sp+38h] [bp-24h]@12
  int v27; // [sp+3Ch] [bp-20h]@12
  int v28; // [sp+40h] [bp-1Ch]@12
  struct tagRECT Rect; // [sp+44h] [bp-18h]@10
  LONG v30; // [sp+54h] [bp-8h]@7
  int v31; // [sp+58h] [bp-4h]@1
  int pitema; // [sp+64h] [bp+8h]@4
  int pitemb; // [sp+64h] [bp+8h]@28
  int v34; // [sp+6Ch] [bp+10h]@36

  v31 = 0;
  v3 = a3;
  if ( a3 )
  {
    v4 = pitem;
    if ( pitem )
    {
      v5 = DSA_GetItemPtr(*(HDSA *)(pitem + 60), i);
      if ( v5 )
      {
        pitema = *(_DWORD *)a3;
        if ( !*(_DWORD *)a3 )
          return 1;
        if ( Header_SendChange(v4, i, -320, a3) )
        {
          v30 = *(_DWORD *)v5;
          if ( pitema & 1 )
          {
            v7 = *(_DWORD *)(a3 + 4);
            if ( v7 < 0 )
              v7 = 0;
            v8 = v7 - *((_DWORD *)v5 + 1);
            *((_DWORD *)v5 + 1) = v7;
            GetClientRect(*(HWND *)v4, &Rect);
            Rect.left = *(_DWORD *)v5;
            if ( v8 < 0 )
              Rect.left += v8;
            v9 = Header_OnGetItemOrder(v4, i);
            Header_ShiftItems(v4, v9, v8);
            *((_DWORD *)v5 + 7) = 0x7FFFFFFF;
            *((_DWORD *)v5 + 8) = 0x7FFFFFFF;
            v17 = *(HWND *)v4;
            v18 = v8;
            v16 = 0;
            v19 = 0;
            v20 = 0;
            v22 = 0;
            v23 = 0;
            dy = 56;
            v24 = 6;
            v21 = &Rect;
            v25 = 0;
            v26 = 0;
            v27 = 0;
            v28 = 0;
            SmoothScrollWindow((int)&dy);
            UpdateWindow(*(HWND *)v4);
            Header_OnGetItemRect(v4, i, &Rect);
            InvalidateRect(*(HWND *)v4, &Rect, 0);
            v3 = a3;
          }
          if ( pitema & 4 )
          {
            *((_DWORD *)v5 + 2) = *(_DWORD *)(v3 + 20);
            *((_DWORD *)v5 + 7) = 0x7FFFFFFF;
            *((_DWORD *)v5 + 8) = 0x7FFFFFFF;
            v31 = 1;
          }
          if ( pitema & 8 )
            *((_DWORD *)v5 + 6) = *(_DWORD *)(v3 + 24);
          if ( !(pitema & 2) )
            goto LABEL_20;
          if ( Str_Set((int)((char *)v5 + 12), *(LPCWSTR *)(v3 + 8)) )
          {
            *((_DWORD *)v5 + 8) = 0x7FFFFFFF;
            v31 = 1;
LABEL_20:
            if ( pitema & 0x10 )
            {
              *((_DWORD *)v5 + 4) = *(_DWORD *)(v3 + 12);
              *((_DWORD *)v5 + 7) = 0x7FFFFFFF;
              v31 = 1;
            }
            if ( pitema & 0x20 )
            {
              *((_DWORD *)v5 + 5) = *(_DWORD *)(v3 + 28);
              *((_DWORD *)v5 + 7) = 0x7FFFFFFF;
              v31 = 1;
            }
            if ( pitema & 0x80 )
            {
              v10 = *(_DWORD *)(v3 + 32);
              if ( v10 >= 0 && v10 < **(_DWORD **)(v4 + 60) )
              {
                Header_OnSetItemOrder(v4, i, *(_DWORD *)(v3 + 32));
                MyNotifyWinEvent(32772, *(_DWORD *)v4, -4, 0);
              }
            }
            pitemb = pitema & 0x100;
            if ( pitemb )
            {
              if ( !(*((_BYTE *)v5 + 44) & 0xF) )
                Str_Set((int)((char *)v5 + 48), 0);
              v11 = *(_DWORD *)(v3 + 36);
              *((_DWORD *)v5 + 11) = v11;
              v12 = v11 & 0xF;
              if ( v12 )
              {
                if ( v12 == 1 && !(*(_DWORD *)(v3 + 36) & 0x8000) )
                {
                  v13 = *(_DWORD *)(v3 + 40);
                  if ( v13 )
                    *((_DWORD *)v5 + 14) = *(_DWORD *)v13;
                }
              }
              else
              {
                v14 = *(_DWORD *)(v3 + 40);
                v34 = v14;
                if ( v14 )
                {
                  if ( !(*(_DWORD *)(v3 + 36) & 0x8000) )
                  {
                    Str_Set((int)((char *)v5 + 48), *(LPCWSTR *)v14);
                    v14 = v34;
                  }
                  *((_DWORD *)v5 + 13) = *(_DWORD *)(v14 + 4);
                }
              }
              v31 = 1;
            }
            Header_SendChange(v4, i, -321, v3);
            if ( pitemb )
              Header_Notify(v4, i, 0, -312);
            if ( v31 )
            {
              if ( v30 == *(_DWORD *)v5 )
              {
                Header_InvalidateItem(v4, i, 5u);
              }
              else
              {
                GetClientRect(*(HWND *)v4, &Rect);
                if ( i > 0 )
                {
                  if ( Header_GetItemPtrByOrder(v4, i - 1) )
                    Rect.left = *(_DWORD *)v5;
                }
                RedrawWindow(*(HWND *)v4, &Rect, 0, 5u);
              }
            }
            return 1;
          }
        }
      }
    }
  }
  return 0;
}

//----- (6F7BD3F1) --------------------------------------------------------
int __stdcall Header_FilterChanged(int pitem, int a2)
{
  int result; // eax@1
  int v3; // ebx@4
  HWND v4; // ST00_4@5
  int v5; // eax@7
  int *v6; // eax@9
  int v7; // [sp+4h] [bp-244h]@5
  unsigned int v8; // [sp+28h] [bp-220h]@5
  int *v9; // [sp+2Ch] [bp-21Ch]@11
  WCHAR *v10; // [sp+30h] [bp-218h]@10
  int v11; // [sp+34h] [bp-214h]@10
  int v12; // [sp+38h] [bp-210h]@9
  WCHAR String; // [sp+3Ch] [bp-20Ch]@5

  result = *(_DWORD *)(pitem + 124);
  if ( result >= 0 )
  {
    if ( a2 )
    {
      KillTimer(*(HWND *)pitem, 0x100u);
      result = SetTimer(*(HWND *)pitem, 0x100u, *(_DWORD *)(pitem + 132), 0);
      *(_DWORD *)(pitem + 68) |= 0x10u;
      return result;
    }
    result = (int)Header_GetItemPtrByOrder(pitem, result);
    v3 = result;
    if ( *(_BYTE *)(pitem + 68) & 0x10 )
    {
      KillTimer(*(HWND *)pitem, 0x100u);
      *(_DWORD *)(pitem + 68) &= 0xFFFFFFEF;
      v8 = *(_DWORD *)(v3 + 44) & 0xFFFF7FFF;
      v4 = *(HWND *)(pitem + 136);
      v7 = 256;
      if ( !GetWindowTextW(v4, &String, 260) )
        v8 |= 0x8000u;
      v5 = *(_DWORD *)(v3 + 44) & 0xF;
      if ( v5 )
      {
        if ( v5 != 1 )
          return Header_OnSetItem(pitem, *(_DWORD *)(pitem + 124), (int)&v7);
        v12 = StrToIntW(&String);
        v6 = &v12;
      }
      else
      {
        v10 = &String;
        v11 = *(_DWORD *)(v3 + 52);
        v6 = (int *)&v10;
      }
      v9 = v6;
      return Header_OnSetItem(pitem, *(_DWORD *)(pitem + 124), (int)&v7);
    }
  }
  return result;
}

//----- (6F7BD513) --------------------------------------------------------
BOOL __stdcall Header_InvalidateDivider(int a1, int i)
{
  RECT Rect; // [sp+4h] [bp-10h]@1

  Header_GetDividerRect(a1, i, &Rect);
  return InvalidateRect(*(HWND *)a1, &Rect, 0);
}

//----- (6F7BD544) --------------------------------------------------------
int __stdcall _Header_SetHotDivider(int a1, int i)
{
  HWND v2; // ST04_4@4
  int result; // eax@4

  if ( i != *(_DWORD *)(a1 + 108) )
  {
    if ( *(_DWORD *)(a1 + 104) )
      ImageList_DragShowNolock(0);
    Header_InvalidateDivider(a1, *(_DWORD *)(a1 + 108));
    Header_InvalidateDivider(a1, i);
    v2 = *(HWND *)a1;
    *(_DWORD *)(a1 + 108) = i;
    result = UpdateWindow(v2);
    if ( *(_DWORD *)(a1 + 104) )
      result = ImageList_DragShowNolock(1);
  }
  return result;
}

//----- (6F7BD596) --------------------------------------------------------
int __stdcall Header_OnSetHotDivider(int pitem, int a2, int a3)
{
  int v3; // eax@1
  LONG v4; // edi@2
  LONG v5; // ebx@2
  int v6; // ebx@6
  int v7; // eax@7
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@2
  int i; // [sp+1Ch] [bp-4h]@1

  i = -1;
  v3 = a3;
  if ( !a2 )
    goto LABEL_10;
  v4 = (signed __int16)a3;
  v5 = SHIWORD(a3);
  GetClientRect(*(HWND *)pitem, &Rect);
  InflateRect(&Rect, 0, 2 * g_cyHScroll);
  if ( v5 >= Rect.top && v5 <= Rect.bottom )
  {
    if ( v4 <= 0 )
    {
      i = 0;
      goto LABEL_11;
    }
    v6 = Header_HitTest(pitem, v4, (Rect.bottom + Rect.top) / 2, (int)&a3);
    if ( v6 == -1 )
    {
      v7 = Header_ItemOrderToIndex(pitem, **(_DWORD **)(pitem + 60) - 1);
      if ( Header_OnGetItemRect(pitem, v7, &Rect) && v4 >= Rect.right )
      {
        v3 = **(_DWORD **)(pitem + 60);
LABEL_10:
        i = v3;
        goto LABEL_11;
      }
    }
    else
    {
      Header_OnGetItemRect(pitem, v6, &Rect);
      i = Header_OnGetItemOrder(pitem, v6);
      if ( v4 > (Rect.left + Rect.right) / 2 )
        ++i;
    }
  }
LABEL_11:
  _Header_SetHotDivider(pitem, i);
  return i;
}
// 6F7E69A4: using guessed type int g_cyHScroll;

//----- (6F7BD67D) --------------------------------------------------------
int __stdcall Header_MoveDrag(int pitem, int a2, __int16 a3)
{
  int result; // eax@2

  if ( Header_OnSetHotDivider(pitem, 1, (unsigned __int16)a2 | ((unsigned __int16)a3 << 16)) == -1 )
  {
    result = ImageList_DragShowNolock(0);
  }
  else
  {
    ImageList_DragShowNolock(1);
    result = ImageList_DragMove(a2 + *(_DWORD *)(pitem + 76), 0);
  }
  return result;
}

//----- (6F7BD6C9) --------------------------------------------------------
int __stdcall Header_EndDrag(int a1)
{
  ImageList_EndDrag();
  ImageList_Destroy(*(HIMAGELIST *)(a1 + 104));
  *(_DWORD *)(a1 + 104) = 0;
  return _Header_SetHotDivider(a1, -1);
}

//----- (6F7BD6F5) --------------------------------------------------------
void __stdcall Header_OnLButtonUp(int pitem, int a2, int a3, int a4)
{
  int v4; // eax@3
  int v5; // eax@6
  int v6; // ST0C_4@13
  int v7; // eax@13
  int v8; // [sp+8h] [bp-2Ch]@6
  int v9; // [sp+Ch] [bp-28h]@6
  int v10; // [sp+28h] [bp-Ch]@13

  if ( pitem && Header_IsTracking(pitem) )
  {
    v4 = *(_DWORD *)(pitem + 72);
    if ( v4 & 0xC )
    {
      if ( !HDDragFullWindows(pitem) )
        Header_DrawDivider((HWND *)pitem, *(_DWORD *)(pitem + 80));
      v5 = *(_DWORD *)(pitem + 80) - *(_DWORD *)(pitem + 84);
      v8 = 1;
      v9 = v5;
      if ( Header_SendChange(pitem, *(_DWORD *)(pitem + 64), -327, (int)&v8) )
        Header_OnSetItem(pitem, *(_DWORD *)(pitem + 64), (int)&v8);
      RedrawWindow(*(HWND *)pitem, 0, 0, 5u);
    }
    else if ( v4 & 2 && (*(_BYTE *)(pitem + 68) & 1 || *(_DWORD *)(pitem + 104)) )
    {
      if ( *(_DWORD *)(pitem + 104) )
      {
        v6 = *(_DWORD *)(pitem + 64);
        v7 = *(_DWORD *)(pitem + 108);
        v8 = 128;
        v10 = v7;
        if ( v7 > Header_OnGetItemOrder(pitem, v6) )
          --v10;
        Header_EndDrag(pitem);
        if ( Header_SendChange(pitem, *(_DWORD *)(pitem + 64), -311, (int)&v8) && v10 != -1 )
        {
          Header_OnSetItemOrder(pitem, *(_DWORD *)(pitem + 64), v10);
          MyNotifyWinEvent(32772, *(_DWORD *)pitem, -4, 0);
        }
      }
      else
      {
        Header_Notify(pitem, *(_DWORD *)(pitem + 64), 0, -322);
      }
      *(_DWORD *)(pitem + 68) &= 0xFFFFFFFE;
      Header_InvalidateItem(pitem, *(_DWORD *)(pitem + 64), 5u);
    }
    *(_DWORD *)(pitem + 72) = 0;
    CCReleaseCapture(pitem);
    KillTimer(*(HWND *)pitem, 1u);
  }
}

//----- (6F7BD82D) --------------------------------------------------------
int __stdcall Header_OnSetItemA(int pitem, int i, int a3)
{
  int v3; // ebx@1
  int v4; // eax@4
  UINT v5; // ST04_4@6
  LPCSTR v6; // eax@6
  int v7; // ecx@9
  int v8; // eax@10
  int v10; // edi@18
  void *v11; // ST08_4@19
  void *v12; // ST08_4@21
  LPCSTR v13; // [sp+Ch] [bp-10h]@11
  int v14; // [sp+10h] [bp-Ch]@11
  const CHAR *v15; // [sp+14h] [bp-8h]@1
  void *v16; // [sp+18h] [bp-4h]@1

  v3 = 0;
  v16 = 0;
  v15 = 0;
  if ( !a3 || !pitem )
    return 0;
  if ( *(_BYTE *)a3 & 2 )
  {
    v4 = *(_DWORD *)(a3 + 8);
    if ( v4 != -1 )
    {
      if ( v4 )
      {
        v5 = *(_DWORD *)(pitem + 20);
        v15 = *(const CHAR **)(a3 + 8);
        v6 = ProduceWFromA(v5, v15);
        v16 = (void *)v6;
        if ( !v6 )
          return 0;
        *(_DWORD *)(a3 + 8) = v6;
      }
    }
  }
  if ( *(_DWORD *)a3 & 0x100 )
  {
    v7 = *(_DWORD *)(a3 + 36);
    if ( !(v7 & 0xF) )
    {
      v8 = *(_DWORD *)(a3 + 40);
      if ( v8 )
      {
        v13 = 0;
        v3 = v8;
        v14 = *(_DWORD *)(v8 + 4);
        if ( !(v7 & 0x8000) )
        {
          v13 = ProduceWFromA(*(_DWORD *)(pitem + 20), *(LPCSTR *)v8);
          if ( !v13 )
          {
            if ( v16 )
              FreeProducedString(v16);
            return 0;
          }
        }
        *(_DWORD *)(a3 + 40) = &v13;
      }
    }
  }
  v10 = Header_OnSetItem(pitem, i, a3);
  if ( v16 )
  {
    v11 = v16;
    *(_DWORD *)(a3 + 8) = v15;
    FreeProducedString(v11);
  }
  if ( v3 )
  {
    v12 = (void *)v13;
    *(_DWORD *)(a3 + 40) = v3;
    FreeProducedString(v12);
  }
  return v10;
}

//----- (6F7BD905) --------------------------------------------------------
int __stdcall Header_DrawItem(int pitem, int a2, int i, int a4, int a5, int a6)
{
  signed int v6; // eax@1
  int v7; // ST20_4@10
  int v8; // eax@10
  int result; // eax@10
  COLORREF v10; // eax@15
  bool v11; // zf@15
  int v12; // ecx@19
  int v13; // eax@23
  PVOID v14; // edi@23
  int v15; // eax@24
  int v16; // esi@26
  LONG v17; // eax@26
  LONG v18; // edx@26
  signed int v19; // ecx@26
  int v20; // eax@28
  int v21; // eax@29
  int v22; // eax@30
  LONG v23; // eax@32
  int v24; // eax@42
  int v25; // eax@43
  LONG v26; // eax@45
  LONG v27; // eax@49
  LONG v28; // edx@52
  LONG v29; // ecx@52
  int v30; // ecx@55
  int v31; // esi@55
  LONG v32; // esi@61
  HRGN v33; // eax@76
  HRGN v34; // esi@89
  int v35; // eax@93
  int v36; // eax@95
  LPARAM v37; // [sp+Ch] [bp-34Ch]@14
  HDC v38; // [sp+1Ch] [bp-33Ch]@12
  int v39; // [sp+20h] [bp-338h]@12
  int v40; // [sp+24h] [bp-334h]@12
  int v41; // [sp+28h] [bp-330h]@12
  int v42; // [sp+2Ch] [bp-32Ch]@12
  int v43; // [sp+30h] [bp-328h]@12
  int v44; // [sp+34h] [bp-324h]@12
  int v45; // [sp+38h] [bp-320h]@12
  char pv; // [sp+3Ch] [bp-31Ch]@25
  int v47; // [sp+40h] [bp-318h]@25
  RECT rect; // [sp+44h] [bp-314h]@61
  int v49; // [sp+54h] [bp-304h]@16
  int y1; // [sp+58h] [bp-300h]@100
  int x2; // [sp+5Ch] [bp-2FCh]@100
  int y2; // [sp+60h] [bp-2F8h]@100
  RECT rc; // [sp+64h] [bp-2F4h]@17
  int x; // [sp+74h] [bp-2E4h]@1
  int v55; // [sp+78h] [bp-2E0h]@1
  int v56; // [sp+7Ch] [bp-2DCh]@1
  int y; // [sp+80h] [bp-2D8h]@1
  LPARAM lParam; // [sp+84h] [bp-2D4h]@10
  WPARAM wParam; // [sp+88h] [bp-2D0h]@10
  int v60; // [sp+8Ch] [bp-2CCh]@10
  LPCWSTR lpString; // [sp+90h] [bp-2C8h]@10
  int v62; // [sp+94h] [bp-2C4h]@10
  int v63; // [sp+98h] [bp-2C0h]@10
  HDC v64; // [sp+9Ch] [bp-2BCh]@10
  int v65; // [sp+A0h] [bp-2B8h]@10
  int v66; // [sp+A4h] [bp-2B4h]@10
  int v67; // [sp+A8h] [bp-2B0h]@10
  int v68; // [sp+ACh] [bp-2ACh]@10
  int v69; // [sp+B0h] [bp-2A8h]@10
  int v70; // [sp+B4h] [bp-2A4h]@1
  RECT hdcSrc; // [sp+B8h] [bp-2A0h]@17
  int v72; // [sp+C8h] [bp-290h]@24
  int cy; // [sp+CCh] [bp-28Ch]@24
  HGDIOBJ ho; // [sp+D0h] [bp-288h]@15
  HRGN hrgnSrc1; // [sp+D4h] [bp-284h]@57
  int v76; // [sp+D8h] [bp-280h]@15
  int v77; // [sp+DCh] [bp-27Ch]@5
  RECT qrc; // [sp+E0h] [bp-278h]@1
  struct tagSIZE sz; // [sp+F0h] [bp-268h]@1
  char v80[4]; // [sp+F8h] [bp-260h]@7
  PVOID v81; // [sp+FCh] [bp-25Ch]@1
  HRGN hrgnSrc2; // [sp+100h] [bp-258h]@1
  HRGN hrgnDst; // [sp+104h] [bp-254h]@1
  HDC hdc; // [sp+108h] [bp-250h]@1
  char v85; // [sp+10Ch] [bp-24Ch]@18
  wchar_t pszDest; // [sp+314h] [bp-44h]@91
  char Dst; // [sp+316h] [bp-42h]@91

  v70 = 0;
  hdc = (HDC)a2;
  hrgnSrc2 = (HRGN)a5;
  v6 = Header_IsTracking(pitem);
  x = *(_DWORD *)a5;
  v55 = *(_DWORD *)(a5 + 4);
  hrgnDst = 0;
  v56 = *(_DWORD *)(a5 + 8);
  y = *(_DWORD *)(a5 + 12);
  qrc.left = *(_DWORD *)a5;
  qrc.top = *(_DWORD *)(a5 + 4);
  qrc.right = *(_DWORD *)(a5 + 8);
  sz.cy = v6;
  qrc.bottom = *(_DWORD *)(a5 + 12);
  v81 = Header_GetItemPtrByOrder(pitem, i);
  v77 = sz.cy && *(_BYTE *)(pitem + 72) & 2 && *(_DWORD *)(pitem + 64) == a4 && *(_BYTE *)(pitem + 68) & 1;
  *(_DWORD *)v80 = 70;
  if ( v77 )
    *(_DWORD *)v80 = 102;
  if ( *((_DWORD *)v81 + 2) & 0x8000 )
  {
    v7 = *(_DWORD *)pitem;
    *(_DWORD *)(pitem + 68) |= 4u;
    lParam = 100;
    wParam = GetDlgCtrlID((HWND)v7);
    v60 = a4;
    lpString = (LPCWSTR)1;
    v62 = v77 != 0;
    v63 = *(_DWORD *)pitem;
    v64 = hdc;
    v8 = *((_DWORD *)v81 + 6);
    v65 = *(_DWORD *)hrgnSrc2;
    v66 = *((_DWORD *)hrgnSrc2 + 1);
    v67 = *((_DWORD *)hrgnSrc2 + 2);
    v68 = *((_DWORD *)hrgnSrc2 + 3);
    v69 = v8;
    result = SendMessageW(*(HWND *)(pitem + 4), 0x2Bu, wParam, (LPARAM)&lParam);
    if ( result )
    {
LABEL_107:
      if ( !(a6 & 2) )
        result = Header_DrawButtonEdges(pitem, hdc, &qrc, v77);
      if ( v70 & 0x10 )
        result = CICustomDrawNotify(pitem, 65538, (LPARAM)&v37);
      return result;
    }
LABEL_15:
    v76 = GetTextColor(hdc);
    v10 = GetBkColor(hdc);
    v11 = (*(_DWORD *)(pitem + 8) & 0x100) == 0;
    ho = (HGDIOBJ)v10;
    if ( !v11 )
      Header_GetFilterRects((int)hrgnSrc2, (int)&qrc, (int)&x, (int)&v49);
    hdcSrc = qrc;
    result = (int)v81;
    rc = qrc;
    if ( *((_DWORD *)v81 + 2) & 0x6800 )
    {
      lpString = (LPCWSTR)&v85;
      wParam = 54;
      v63 = 260;
      Header_OnGetItem(pitem, a4, (int)&wParam);
      result = (int)v81;
    }
    v12 = *(_DWORD *)(result + 8);
    if ( !(v12 & 0x4000) || !(v12 & 0x2800) )
    {
LABEL_55:
      v30 = *(_DWORD *)(result + 8);
      v31 = *(_DWORD *)(result + 8) & 0x800;
      if ( !v31 && !(v30 & 0x2000) )
      {
LABEL_85:
        if ( *(_DWORD *)(result + 8) & 0x4000 )
        {
          if ( (unsigned __int8)v64 & 4 )
            *(_DWORD *)v80 |= 0x800u;
          result = SHDrawText(
                     hdc,
                     (int)lpString,
                     &rc,
                     (unsigned __int8)v64 & 3,
                     *(int *)v80,
                     *(_DWORD *)(pitem + 48),
                     *(_DWORD *)(pitem + 40),
                     v76,
                     (COLORREF)ho);
          if ( hrgnDst )
          {
            v34 = CreateRectRgnIndirect(&rc);
            CombineRgn(hrgnDst, v34, hrgnDst, 2);
            result = DeleteObject(v34);
          }
        }
        if ( *(_DWORD *)(pitem + 8) & 0x100 )
        {
          pszDest = 0;
          memset(&Dst, 0, 0x3Eu);
          sz.cy = (LONG)&pszDest;
          *(_DWORD *)v80 = 70;
          if ( (unsigned __int8)v64 & 4 )
            *(_DWORD *)v80 = 2118;
          v35 = *((_DWORD *)v81 + 11);
          if ( v35 & 0x8000 )
          {
            LocalizedLoadString(4176, &pszDest, 32);
            v76 = g_clrGrayText;
          }
          else
          {
            v36 = v35 & 0xF;
            v76 = g_clrWindowText;
            if ( v36 )
            {
              if ( v36 == 1 )
                StringCchPrintfW(&pszDest, 0x20u, L"%d", *((_DWORD *)v81 + 14));
            }
            else
            {
              sz.cy = *((_DWORD *)v81 + 12);
            }
          }
          SHDrawText(
            hdc,
            sz.cy,
            (RECT *)&x,
            0,
            *(int *)v80,
            *(_DWORD *)(pitem + 48),
            *(_DWORD *)(pitem + 40),
            v76,
            g_clrWindow);
          PatBlt(hdc, x, y, v56 - x, 1, 0x42u);
          result = (int)Header_DrawFilterGlyph(pitem, hdc, (int)&v49, i == *(_DWORD *)(pitem + 128));
          if ( hrgnDst )
          {
            ho = CreateRectRgn(x, y1, x2, y2);
            CombineRgn(hrgnDst, (HRGN)ho, hrgnDst, 2);
            result = DeleteObject(ho);
          }
          if ( *(_BYTE *)(pitem + 68) & 8 )
          {
            result = i;
            if ( *(_DWORD *)(pitem + 120) == i )
            {
              result = CCGetUIState(pitem);
              if ( !(result & 1) )
              {
                InflateRect((LPRECT)&x, g_cxEdge / -2, g_cyEdge / -2);
                SetTextColor(hdc, g_clrWindowText);
                result = DrawFocusRect(hdc, (const RECT *)&x);
              }
            }
          }
        }
        if ( hrgnDst )
        {
          cy = (int)CreateRectRgnIndirect(&qrc);
          sz.cy = (LONG)CreateRectRgn(0, 0, 0, 0);
          CombineRgn((HRGN)sz.cy, (HRGN)cy, hrgnDst, 3);
          SelectClipRgn(hdc, (HRGN)sz.cy);
          ExtTextOutW(hdc, 0, 0, 2u, &qrc, 0, 0, 0);
          RestoreDC(hdc, -1);
          DeleteObject(hrgnDst);
          DeleteObject((HGDIOBJ)sz.cy);
          result = DeleteObject((HGDIOBJ)cy);
        }
        goto LABEL_107;
      }
      cy = 0;
      hrgnSrc1 = 0;
      hrgnSrc2 = 0;
      if ( v31 && v30 & 0x2000 )
      {
        v64 = (HDC)((unsigned int)v64 ^ 0x2000);
        cy = 1;
      }
      sz.cy = a6 & 1;
      if ( a6 & 1 )
      {
        v32 = (LONG)ho;
      }
      else
      {
        v32 = _Header_DrawBitmap(
                hdc,
                *(HIMAGELIST *)(pitem + 92),
                (int)&wParam,
                (HDC)&hdcSrc,
                (unsigned __int8)v64 & 3,
                v80[0],
                &rect,
                *(_DWORD *)(pitem + 116));
        hrgnSrc1 = CreateRectRgnIndirect(&rect);
      }
      if ( cy )
      {
        v64 = (HDC)((unsigned int)v64 ^ 0x2800);
        if ( (unsigned __int8)v64 & 1 )
        {
          hdcSrc.right = v32;
          if ( (unsigned __int16)v64 & 0x4000 )
          {
            hdcSrc.right = hdcSrc.left;
            if ( hdcSrc.left >= rc.left )
              hdcSrc.right = rc.left;
          }
          hdcSrc.left = qrc.left;
        }
        else
        {
          hdcSrc.left = v32;
          if ( (unsigned __int16)v64 & 0x4000 )
          {
            hdcSrc.left = hdcSrc.right;
            if ( hdcSrc.right <= rc.right )
              hdcSrc.left = rc.right;
          }
          hdcSrc.right = qrc.right;
        }
        if ( !sz.cy )
        {
          _Header_DrawBitmap(
            hdc,
            *(HIMAGELIST *)(pitem + 92),
            (int)&wParam,
            (HDC)&hdcSrc,
            (unsigned __int8)v64 & 1,
            v80[0],
            &rect,
            *(_DWORD *)(pitem + 116));
          hrgnSrc2 = CreateRectRgnIndirect(&rect);
        }
        v64 = (HDC)((unsigned int)v64 ^ 0x800);
      }
      v33 = hrgnSrc1;
      if ( hrgnSrc1 )
      {
        if ( hrgnSrc2 )
        {
          hrgnDst = CreateRectRgn(0, 0, 0, 0);
          CombineRgn(hrgnDst, hrgnSrc1, hrgnSrc2, 2);
          DeleteObject(hrgnSrc1);
          DeleteObject(hrgnSrc2);
          goto LABEL_81;
        }
      }
      else
      {
        v33 = hrgnSrc2;
        if ( !hrgnSrc2 )
          goto LABEL_81;
      }
      hrgnDst = v33;
LABEL_81:
      if ( sz.cy && !hrgnDst )
        hrgnDst = CreateRectRgn(0, 0, 0, 0);
      SaveDC(hdc);
      result = (int)v81;
      goto LABEL_85;
    }
    if ( *(_DWORD *)(result + 32) != 0x7FFFFFFF && *(_DWORD *)(result + 28) != 0x7FFFFFFF )
    {
LABEL_52:
      v28 = qrc.left + *(_DWORD *)(result + 28);
      hdcSrc.left = qrc.left + *(_DWORD *)(result + 28);
      v29 = qrc.left + *(_DWORD *)(result + 32);
      rc.left = qrc.left + *(_DWORD *)(result + 32);
      if ( *(_DWORD *)(result + 8) & 0x1000 )
      {
        hdcSrc.right = v29 + *(_DWORD *)(result + 36);
        rc.right = v28;
      }
      else
      {
        hdcSrc.right = v29;
        rc.right = v28 + *(_DWORD *)(result + 36);
      }
      goto LABEL_55;
    }
    sz.cx = 0;
    sz.cy = 0;
    v13 = lstrlenW(lpString);
    GetTextExtentPointW(hdc, lpString, v13, &sz);
    v14 = v81;
    v11 = (*((_DWORD *)v81 + 2) & 0x800) == 0;
    sz.cx += 2 * *(_DWORD *)(pitem + 112);
    if ( v11 )
    {
      GetObjectW(*((HANDLE *)v81 + 4), 24, &pv);
      v15 = v47;
    }
    else
    {
      ImageList_GetIconSize(*(HIMAGELIST *)(pitem + 92), &v72, &cy);
      v15 = v72;
    }
    v16 = v15 + 2 * *(_DWORD *)(pitem + 116);
    v17 = v16 + sz.cx;
    *((_DWORD *)v14 + 9) = v16 + sz.cx;
    v18 = qrc.right;
    v19 = qrc.right - v17 - qrc.left;
    if ( v19 < 0 )
    {
      v19 = 0;
      *((_DWORD *)v14 + 9) = qrc.right - qrc.left;
      v18 = qrc.right;
    }
    v20 = *((_DWORD *)v14 + 2);
    if ( v20 & 0x1000 )
    {
      v21 = v20 & 3;
      if ( v21 )
      {
        v22 = v21 - 1;
        if ( !v22 )
        {
          *((_DWORD *)v14 + 8) = v18 - *((_DWORD *)v14 + 9);
LABEL_36:
          v18 = qrc.right;
LABEL_37:
          if ( v19 )
            *((_DWORD *)v14 + 7) = sz.cx + *((_DWORD *)v14 + 8);
          else
            *((_DWORD *)v14 + 7) = v18 - v16;
          if ( *((_DWORD *)v14 + 7) < qrc.left )
            *((_DWORD *)v14 + 7) = qrc.left;
LABEL_51:
          *((_DWORD *)v14 + 7) -= qrc.left;
          *((_DWORD *)v14 + 8) -= qrc.left;
          result = (int)v14;
          goto LABEL_52;
        }
        if ( v22 != 1 )
          goto LABEL_37;
        v23 = qrc.left + v19 / 2;
      }
      else
      {
        v23 = qrc.left;
      }
      *((_DWORD *)v14 + 8) = v23;
      goto LABEL_36;
    }
    v24 = v20 & 3;
    if ( v24 )
    {
      v25 = v24 - 1;
      if ( !v25 )
      {
        *((_DWORD *)v14 + 7) = v18 - *((_DWORD *)v14 + 9);
        goto LABEL_49;
      }
      if ( v25 != 1 )
        goto LABEL_49;
      v26 = qrc.left + v19 / 2;
    }
    else
    {
      v26 = qrc.left;
    }
    *((_DWORD *)v14 + 7) = v26;
LABEL_49:
    v27 = v16 + *((_DWORD *)v14 + 7);
    *((_DWORD *)v14 + 8) = v27;
    if ( v27 > qrc.right )
      *((_DWORD *)v14 + 8) = qrc.right;
    goto LABEL_51;
  }
  v43 = a4;
  v38 = hdc;
  v39 = *(_DWORD *)hrgnSrc2;
  v40 = *((_DWORD *)hrgnSrc2 + 1);
  v41 = *((_DWORD *)hrgnSrc2 + 2);
  v42 = *((_DWORD *)hrgnSrc2 + 3);
  v44 = v77 != 0;
  v45 = *((_DWORD *)v81 + 6);
  if ( !(CCGetUIState(pitem) & 1) )
    v44 |= 0x200u;
  result = CICustomDrawNotify(pitem, 65537, (LPARAM)&v37);
  v70 = result;
  if ( !(result & 4) )
    goto LABEL_15;
  return result;
}

//----- (6F7BE2F7) --------------------------------------------------------
int __stdcall Header_Draw(int pitem, HDC hdc, int a3)
{
  int v3; // ebx@1
  int v4; // eax@3
  unsigned int v5; // eax@3
  int v6; // edi@3
  bool v7; // zf@3
  int v8; // esi@4
  COLORREF v9; // eax@7
  int result; // eax@14
  COLORREF v11; // esi@19
  LPARAM lParam; // [sp+Ch] [bp-48h]@3
  HDC v13; // [sp+1Ch] [bp-38h]@3
  int v14; // [sp+20h] [bp-34h]@3
  int v15; // [sp+24h] [bp-30h]@3
  int v16; // [sp+28h] [bp-2Ch]@3
  int v17; // [sp+2Ch] [bp-28h]@3
  int v18; // [sp+34h] [bp-20h]@3
  int v19; // [sp+38h] [bp-1Ch]@3
  RECT rect; // [sp+3Ch] [bp-18h]@1
  int v21; // [sp+4Ch] [bp-8h]@1
  HGDIOBJ h; // [sp+50h] [bp-4h]@1
  int pitema; // [sp+5Ch] [bp+8h]@3

  v3 = pitem;
  rect.left = 0;
  rect.top = 0;
  rect.right = 0;
  rect.bottom = 0;
  h = 0;
  v21 = Header_IsTracking(pitem);
  if ( *(_DWORD *)(pitem + 52) )
    h = SelectObject(hdc, *(HGDIOBJ *)(pitem + 52));
  v4 = **(_DWORD **)(pitem + 60);
  v18 = 0;
  v19 = 0;
  pitema = v4;
  v13 = hdc;
  v14 = *(_DWORD *)a3;
  v15 = *(_DWORD *)(a3 + 4);
  v16 = *(_DWORD *)(a3 + 8);
  v17 = *(_DWORD *)(a3 + 12);
  v5 = CICustomDrawNotify(v3, 1, (LPARAM)&lParam);
  v6 = 0;
  v7 = pitema == 0;
  *(_DWORD *)(v3 + 12) = v5;
  if ( pitema > 0 )
  {
    do
    {
      v8 = Header_ItemOrderToIndex(v3, v6);
      Header_OnGetItemRect(v3, v8, &rect);
      if ( rect.right >= *(_DWORD *)a3 )
      {
        if ( rect.left >= *(_DWORD *)(a3 + 8) )
          break;
        if ( v8 == *(_DWORD *)(v3 + 100) )
          v9 = GetSysColor(26);
        else
          v9 = g_clrBtnText;
        SetTextColor(hdc, v9);
        SetBkColor(hdc, g_clrBtnFace);
        Header_DrawItem(v3, (int)hdc, v6, v8, (int)&rect, 0);
      }
      ++v6;
    }
    while ( v6 < pitema );
    v7 = v6 == pitema;
  }
  if ( v7 )
  {
    rect.left = rect.right;
    rect.right = 32000;
    Header_DrawButtonEdges(v3, hdc, &rect, 0);
  }
  result = HDDragFullWindows(v3);
  if ( !result && v21 && *(_BYTE *)(v3 + 72) & 0xC )
    result = Header_DrawDivider((HWND *)v3, *(_DWORD *)(v3 + 80));
  if ( *(_DWORD *)(v3 + 108) != -1 )
  {
    v11 = GetSysColor(26);
    Header_GetDividerRect(v3, *(_DWORD *)(v3 + 108), &rect);
    result = FillRectClr(hdc, &rect, v11);
  }
  if ( *(_BYTE *)(v3 + 12) & 0x10 )
    result = CICustomDrawNotify(v3, 2, (LPARAM)&lParam);
  if ( h )
    result = (int)SelectObject(hdc, h);
  return result;
}

//----- (6F7BE469) --------------------------------------------------------
HIMAGELIST __stdcall Header_OnCreateDragImage(int pitem, int i)
{
  int v2; // esi@1
  HDC v3; // edi@2
  void *v4; // ebx@7
  void *v5; // ecx@15
  struct tagRECT rc; // [sp+Ch] [bp-30h]@1
  int v8; // [sp+1Ch] [bp-20h]@1
  int v9; // [sp+20h] [bp-1Ch]@1
  HGDIOBJ v10; // [sp+24h] [bp-18h]@1
  HIMAGELIST v11; // [sp+28h] [bp-14h]@1
  HIMAGELIST himl; // [sp+2Ch] [bp-10h]@9
  HGDIOBJ ho; // [sp+30h] [bp-Ch]@1
  HGDIOBJ v14; // [sp+34h] [bp-8h]@1
  HGDIOBJ h; // [sp+38h] [bp-4h]@3

  v2 = *(_DWORD *)(pitem + 24) & 0x400000;
  ho = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  v8 = v2;
  v9 = Header_ItemOrderToIndex(pitem, i);
  if ( Header_OnGetItemRect(pitem, v9, &rc) )
  {
    OffsetRect(&rc, -rc.left, -rc.top);
    v3 = CreateCompatibleDC(0);
    if ( v3 )
    {
      h = CreateColorBitmap(rc.right, rc.bottom);
      if ( h )
      {
        ho = CreateMonoBitmap(rc.right, rc.bottom);
        if ( ho )
        {
          if ( v2 )
            SetLayout(v3, 1u);
          v4 = *(void **)(pitem + 52);
          if ( v4 )
            v10 = SelectObject(v3, v4);
          himl = ImageList_Create(rc.right, rc.bottom, 1u, 1, 0);
          if ( himl )
          {
            v11 = ImageList_Create(rc.right, rc.bottom, 1u, 1, 0);
            if ( v11 )
            {
              SetTextColor(v3, g_clrBtnText);
              SetBkColor(v3, g_clrBtnShadow);
              v14 = SelectObject(v3, h);
              Header_DrawItem(pitem, (int)v3, i, v9, (int)&rc, 2);
              if ( v8 )
                MirrorBitmapInDC(v3, h);
              SelectObject(v3, ho);
              PatBlt(v3, 0, 0, rc.right, rc.bottom, 0x42u);
              SelectObject(v3, v14);
              ImageList_SetBkColor(himl, 0xFFFFFFFF);
              ImageList_Add(himl, (HBITMAP)h, (HBITMAP)ho);
              SetTextColor(v3, g_clrBtnText);
              SetBkColor(v3, g_clrBtnShadow);
              v14 = SelectObject(v3, h);
              Header_DrawItem(pitem, (int)v3, i, v9, (int)&rc, 3);
              DrawEdge(v3, &rc, 9u, 0x400Fu);
              if ( v8 )
                MirrorBitmapInDC(v3, h);
              SelectObject(v3, v14);
              ImageList_AddMasked(v11, (HBITMAP)h, g_clrBtnShadow);
              ImageList_CopyDitherImage(v5, v11, 0, 0, 0, himl, 0, 0);
            }
            ImageList_Destroy(himl);
            if ( v14 )
              SelectObject(v3, v14);
          }
          if ( v10 )
            SelectObject(v3, v10);
        }
      }
      DeleteObject(v3);
      if ( h )
        DeleteObject(h);
      if ( ho )
        DeleteObject(ho);
    }
  }
  return v11;
}

//----- (6F7BE6A6) --------------------------------------------------------
int __stdcall Header_StopFilterEdit(int pitem, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  PVOID v4; // eax@2
  int v5; // ecx@3
  int *v6; // eax@5
  HWND *v7; // edi@10
  int v8; // [sp+8h] [bp-34h]@3
  int v9; // [sp+2Ch] [bp-10h]@3
  int *v10; // [sp+30h] [bp-Ch]@7
  int v11; // [sp+34h] [bp-8h]@6
  int v12; // [sp+38h] [bp-4h]@6

  v2 = pitem;
  result = *(_DWORD *)(pitem + 124);
  if ( result < 0 )
    return result;
  v4 = DSA_GetItemPtr(*(HDSA *)(pitem + 60), *(_DWORD *)(pitem + 124));
  if ( !a2 )
  {
    Header_FilterChanged(v2, 0);
    goto LABEL_10;
  }
  v9 = *(_DWORD *)(v2 + 144);
  v8 = 256;
  v5 = *((_DWORD *)v4 + 11) & 0xF;
  if ( !v5 )
  {
    v11 = *(_DWORD *)(v2 + 148);
    v12 = *((_DWORD *)v4 + 13);
    v6 = &v11;
    goto LABEL_7;
  }
  if ( v5 == 1 )
  {
    pitem = *(_DWORD *)(v2 + 152);
    v6 = &pitem;
LABEL_7:
    v10 = v6;
  }
  Header_OnSetItem(v2, *(_DWORD *)(v2 + 124), (int)&v8);
LABEL_10:
  v7 = (HWND *)(v2 + 136);
  result = *(_DWORD *)(v2 + 136);
  if ( result )
  {
    SetWindowLongW((HWND)result, -4, *(_DWORD *)(v2 + 140));
    result = DestroyWindow(*v7);
    *v7 = 0;
  }
  *(_DWORD *)(v2 + 124) = -1;
  *(_DWORD *)(v2 + 148) = 0;
  return result;
}

//----- (6F7BE760) --------------------------------------------------------
BOOL __stdcall Header_OnFilterButton(int pitem, int i)
{
  LPARAM lParam; // [sp+Ch] [bp-50h]@1
  int v4; // [sp+18h] [bp-44h]@1
  char v5; // [sp+1Ch] [bp-40h]@1
  char v6; // [sp+2Ch] [bp-30h]@1
  char v7; // [sp+3Ch] [bp-20h]@1
  struct tagRECT Rect; // [sp+4Ch] [bp-10h]@1

  Header_StopFilterEdit(pitem, 0);
  *(_DWORD *)(pitem + 128) = i;
  Header_InvalidateItem(pitem, i, 1u);
  UpdateWindow(*(HWND *)pitem);
  memset(&lParam, 0, 0x20u);
  v4 = i;
  Header_OnGetItemRect(pitem, i, &Rect);
  Header_GetFilterRects((int)&Rect, (int)&v6, (int)&v7, (int)&v5);
  if ( CCSendNotify(pitem, -313, (LPARAM)&lParam) )
    Header_Notify(pitem, i, 0, -312);
  *(_DWORD *)(pitem + 128) = -1;
  Header_InvalidateItem(pitem, i, 1u);
  return UpdateWindow(*(HWND *)pitem);
}

//----- (6F7BE802) --------------------------------------------------------
int __stdcall Header_OnClearFilter(int pitem, int i)
{
  PVOID v2; // eax@3
  PVOID v3; // edi@3
  int v4; // eax@4
  PVOID v5; // eax@13
  int v6; // eax@14
  int v8; // [sp+Ch] [bp-30h]@4
  int v9; // [sp+30h] [bp-Ch]@4
  int v10; // [sp+34h] [bp-8h]@4
  int v11; // [sp+38h] [bp-4h]@1
  int ia; // [sp+48h] [bp+Ch]@2

  v11 = 0;
  Header_StopFilterEdit(pitem, 0);
  if ( i == -1 )
  {
    ia = 0;
    if ( **(_DWORD **)(pitem + 60) > 0 )
    {
      do
      {
        v2 = Header_GetItemPtrByOrder(pitem, ia);
        v3 = v2;
        if ( !(*((_DWORD *)v2 + 11) & 0x8000) )
        {
          v8 = 256;
          v4 = *((_DWORD *)v2 + 11);
          v10 = 0;
          v9 = v4 | 0x8000;
          if ( Header_SendChange(pitem, ia, -320, (int)&v8) )
          {
            if ( !(*((_BYTE *)v3 + 44) & 0xF) )
              Str_Set((int)((char *)v3 + 48), 0);
            *((_DWORD *)v3 + 11) |= 0x8000u;
            Header_SendChange(pitem, ia, -321, (int)&v8);
            ++v11;
          }
        }
        ++ia;
      }
      while ( ia < **(_DWORD **)(pitem + 60) );
      if ( v11 )
      {
        Header_Notify(pitem, -1, 0, -312);
        RedrawWindow(*(HWND *)pitem, 0, 0, 5u);
      }
    }
    return 1;
  }
  if ( i >= 0 && i <= **(_DWORD **)(pitem + 60) )
  {
    v5 = Header_GetItemPtrByOrder(pitem, i);
    if ( !(*((_DWORD *)v5 + 11) & 0x8000) )
    {
      v8 = 256;
      v6 = *((_DWORD *)v5 + 11);
      v10 = 0;
      v9 = v6 | 0x8000;
      Header_OnSetItem(pitem, i, (int)&v8);
    }
    return 1;
  }
  return 0;
}

//----- (6F7BE91A) --------------------------------------------------------
int __stdcall Header_OnNCDestroy(int pitem)
{
  int result; // eax@3

  if ( *(_DWORD *)(pitem + 56) )
    ImageList_Destroy(*(HIMAGELIST *)(pitem + 56));
  Header_StopFilterEdit(pitem, 1);
  DSA_DestroyCallback(*(HDSA *)(pitem + 60), Header_DestroyItemCallback, 0);
  result = *(_DWORD *)(pitem + 96);
  *(_DWORD *)(pitem + 60) = 0;
  if ( result )
  {
    result = DSA_Destroy((HDSA)result);
    *(_DWORD *)(pitem + 96) = 0;
  }
  return result;
}

//----- (6F7BE966) --------------------------------------------------------
void __stdcall Header_OnPaint(int pitem, HDC hdc)
{
  HDC v2; // ebx@3
  struct tagPAINTSTRUCT Paint; // [sp+8h] [bp-44h]@3

  if ( pitem )
  {
    if ( hdc )
    {
      v2 = hdc;
      GetClientRect(*(HWND *)pitem, &Paint.rcPaint);
    }
    else
    {
      v2 = BeginPaint(*(HWND *)pitem, &Paint);
    }
    Header_Draw(pitem, v2, (int)&Paint.rcPaint);
    if ( !hdc )
      EndPaint(*(HWND *)pitem, &Paint);
  }
}

//----- (6F7BE9D8) --------------------------------------------------------
void __stdcall Header_StartDrag(int pitem, int i, int x, int a4)
{
  int v4; // eax@3
  HIMAGELIST v5; // eax@3
  struct _IMAGELIST *v6; // ST00_4@4
  struct tagRECT Rect; // [sp+4h] [bp-10h]@4

  if ( *(_BYTE *)(pitem + 8) & 0x40 && Header_Notify(pitem, i, 1, -310) )
  {
    Header_SetHotItem(pitem, -1);
    UpdateWindow(*(HWND *)pitem);
    v4 = Header_OnGetItemOrder(pitem, i);
    v5 = Header_OnCreateDragImage(pitem, v4);
    *(_DWORD *)(pitem + 104) = v5;
    if ( v5 )
    {
      Header_OnGetItemRect(pitem, i, &Rect);
      v6 = *(struct _IMAGELIST **)(pitem + 104);
      *(_DWORD *)(pitem + 76) = Rect.left - x;
      ImageList_BeginDrag(v6, 0, 0, 0);
      ImageList_DragEnter(*(HWND *)pitem, x, 0);
    }
  }
}

//----- (6F7BEA5F) --------------------------------------------------------
void __stdcall Header_OnMouseMove(int pitem, int i, __int16 a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int v7; // eax@6
  int v8; // eax@8
  int v9; // edx@9
  LONG v10; // edi@13
  int v11; // edx@13
  int v12; // ST08_4@14
  int v13; // eax@18
  int v14; // ebx@19
  int v15; // eax@28
  unsigned int v16; // eax@30
  int v17; // eax@31
  int v18; // [sp-10h] [bp-6Ch]@30
  int v19; // [sp+4h] [bp-58h]@14
  int v20; // [sp+8h] [bp-54h]@14
  int v21; // [sp+30h] [bp-2Ch]@9
  int v22; // [sp+34h] [bp-28h]@9

  v4 = pitem;
  if ( !pitem )
    return;
  v5 = *(_DWORD *)(pitem + 8);
  v6 = i;
  if ( v5 & 4 && !(*(_BYTE *)(pitem + 68) & 4) && !*(_DWORD *)(pitem + 104) && v5 & 2 )
  {
    v7 = Header_HitTest(pitem, i, a3, (int)&pitem);
    Header_SetHotItem(v4, v7);
  }
  if ( !Header_IsTracking(v4) )
    return;
  v8 = *(_DWORD *)(v4 + 72);
  if ( !(v8 & 0xC) )
  {
    if ( !(v8 & 2) )
      return;
    i = Header_HitTest(v4, v6, a3, (int)&pitem);
    v13 = *(_DWORD *)(v4 + 80);
    if ( v6 - v13 >= 0 )
      v14 = v6 - v13;
    else
      v14 = v13 - v6;
    if ( v14 > GetSystemMetrics(68) )
    {
      if ( *(_DWORD *)(v4 + 104) )
        goto LABEL_25;
      Header_StartDrag(v4, i, *(_DWORD *)(v4 + 80), a3);
    }
    if ( !*(_DWORD *)(v4 + 104) )
    {
      if ( pitem & 2 && i == *(_DWORD *)(v4 + 64) )
      {
        v15 = *(_DWORD *)(v4 + 68);
        if ( v15 & 1 || !(*(_BYTE *)(v4 + 8) & 2) )
          return;
        v16 = v15 | 1;
        v18 = *(_DWORD *)(v4 + 64);
      }
      else
      {
        v17 = *(_DWORD *)(v4 + 68);
        if ( !(v17 & 1) || !(*(_BYTE *)(v4 + 8) & 2) )
          return;
        v18 = *(_DWORD *)(v4 + 64);
        v16 = v17 & 0xFFFFFFFE;
      }
      *(_DWORD *)(v4 + 68) = v16;
      Header_InvalidateItem(v4, v18, 5u);
      return;
    }
LABEL_25:
    Header_MoveDrag(v4, v6, a3);
    return;
  }
  v21 = 1;
  v22 = Header_PinDividerPos(v4, v6) - *(_DWORD *)(v4 + 84);
  if ( !HDDragFullWindows(v4) )
  {
    if ( !Header_SendChange(v4, *(_DWORD *)(v4 + 64), -328, (int)&v21) )
    {
      *(_DWORD *)(v4 + 72) = 0;
      CCReleaseCapture(v4);
      KillTimer(*(HWND *)v4, 1u);
      Header_DrawDivider((HWND *)v4, *(_DWORD *)(v4 + 80));
      return;
    }
    v9 = v22;
  }
  v10 = v9 + *(_DWORD *)(v4 + 84);
  if ( HDDragFullWindows(v4) )
  {
    v12 = *(_DWORD *)(v4 + 64);
    v19 = 1;
    v20 = v11;
    Header_OnSetItem(v4, v12, (int)&v19);
    UpdateWindow(*(HWND *)v4);
  }
  else
  {
    Header_DrawDivider((HWND *)v4, *(_DWORD *)(v4 + 80));
    Header_DrawDivider((HWND *)v4, v10);
  }
  *(_DWORD *)(v4 + 80) = v10;
}

//----- (6F7BEC05) --------------------------------------------------------
int __stdcall Header_OnInsertItem(int i, int a2, int pitem)
{
  int v3; // esi@1
  int v4; // edi@2
  int v5; // ebx@4
  int v6; // eax@6
  int v7; // eax@10
  PVOID v8; // eax@15
  struct _DSA *v9; // eax@17
  int j; // ebx@18
  int v11; // eax@23
  int v12; // ecx@38
  int v13; // eax@38
  int v14; // eax@38
  int v15; // esi@41
  int v16; // esi@43
  int v18; // [sp+Ch] [bp-54h]@1
  int Dst; // [sp+10h] [bp-50h]@1
  int v20; // [sp+14h] [bp-4Ch]@23
  int v21; // [sp+18h] [bp-48h]@25
  int v22; // [sp+1Ch] [bp-44h]@31
  int v23; // [sp+20h] [bp-40h]@35
  int v24; // [sp+24h] [bp-3Ch]@23
  int v25; // [sp+28h] [bp-38h]@23
  int v26; // [sp+2Ch] [bp-34h]@23
  int v27; // [sp+38h] [bp-28h]@23
  int v28; // [sp+3Ch] [bp-24h]@45
  int v29; // [sp+40h] [bp-20h]@23
  int v30; // [sp+44h] [bp-1Ch]@42
  struct tagRECT Rect; // [sp+48h] [bp-18h]@50
  int v32; // [sp+58h] [bp-8h]@6
  int v33; // [sp+5Ch] [bp-4h]@4
  int ia; // [sp+68h] [bp+8h]@8

  v18 = 0;
  memset(&Dst, 0, 0x38u);
  v3 = pitem;
  if ( !pitem )
    return -1;
  v4 = i;
  if ( !i || !*(_DWORD *)pitem )
    return -1;
  v5 = *(_DWORD *)(pitem + 4);
  v33 = v5;
  if ( v5 < 0 )
  {
    v33 = 0;
    v5 = 0;
  }
  v6 = **(_DWORD **)(i + 60);
  v32 = v5;
  if ( a2 > v6 )
    a2 = v6;
  Header_StopFilterEdit(i, 0);
  ia = a2;
  if ( !(*(_BYTE *)(v4 + 8) & 0x20) )
  {
    if ( *(_BYTE *)v3 & 0x80 )
    {
      v7 = *(_DWORD *)(v3 + 32);
      if ( v7 != a2 && v7 <= **(_DWORD **)(v4 + 60) && Header_InitOrderArray(v4) )
        ia = *(_DWORD *)(v3 + 32);
    }
  }
  if ( ia > 0 )
  {
    v8 = Header_GetItemPtrByOrder(v4, ia - 1);
    if ( v8 )
      v32 = v5 + *(_DWORD *)v8;
  }
  Header_ShiftItems(v4, ia, v5);
  v9 = *(struct _DSA **)(v4 + 96);
  if ( v9 )
  {
    pitem = 0;
    for ( j = 0; j < *(_DWORD *)v9; ++j )
    {
      DSA_GetItem(v9, j, &pitem);
      if ( pitem >= a2 )
      {
        ++pitem;
        DSA_SetItem(*(HDSA *)(v4 + 96), j, &pitem);
      }
      v9 = *(struct _DSA **)(v4 + 96);
    }
    DSA_InsertItem(*(HDSA *)(v4 + 96), ia, &a2);
    v5 = v33;
  }
  v18 = v32;
  v24 = *(_DWORD *)(v3 + 24);
  v20 = *(_DWORD *)(v3 + 20);
  v25 = 0x7FFFFFFF;
  v26 = 0x7FFFFFFF;
  v11 = *(_DWORD *)v3;
  Dst = v5;
  v27 = 0x8000;
  v29 = 260;
  if ( v11 & 2 && *(_DWORD *)(v3 + 8) )
  {
    if ( Str_Set((int)&v21, *(LPCWSTR *)(v3 + 8)) )
    {
      v11 = *(_DWORD *)v3;
      if ( !(*(_DWORD *)v3 & 0x8000) )
        v20 |= 0x4000u;
      goto LABEL_29;
    }
    return -1;
  }
  v20 &= 0xFFFFBFFF;
LABEL_29:
  if ( v11 & 0x10 && *(_DWORD *)(v3 + 12) )
  {
    v22 = *(_DWORD *)(v3 + 12);
    if ( !(v11 & 0x8000) )
      v20 |= 0x2000u;
  }
  else
  {
    v22 = 0;
    v20 &= 0xFFFFDFFF;
  }
  if ( v11 & 0x20 )
  {
    v23 = *(_DWORD *)(v3 + 28);
    if ( !(v11 & 0x8000) )
      v20 |= 0x800u;
  }
  if ( v11 & 0x100 )
  {
    v12 = *(_DWORD *)(v3 + 36);
    v13 = *(_DWORD *)(v3 + 36);
    v27 = v13;
    v14 = v13 & 0xF;
    if ( v14 )
    {
      if ( v14 == 1 && !(v12 & 0x8000) )
      {
        v15 = *(_DWORD *)(v3 + 40);
        if ( v15 )
          v30 = *(_DWORD *)v15;
      }
    }
    else
    {
      v16 = *(_DWORD *)(v3 + 40);
      if ( v16 )
      {
        if ( !(v12 & 0x8000) )
          Str_Set((int)&v28, *(LPCWSTR *)v16);
        v29 = *(_DWORD *)(v16 + 4);
      }
    }
  }
  a2 = DSA_InsertItem(*(HDSA *)(v4 + 60), a2, &v18);
  if ( a2 == -1 )
  {
    Str_Set((int)&v21, 0);
    if ( !(v27 & 0xF) )
      Str_Set((int)&v28, 0);
  }
  else
  {
    GetClientRect(*(HWND *)v4, &Rect);
    Rect.left = v32 - v33;
    RedrawWindow(*(HWND *)v4, &Rect, 0, 5u);
    MyNotifyWinEvent(0x8000, *(_DWORD *)v4, -4, a2 + 1);
  }
  return a2;
}

//----- (6F7BEE70) --------------------------------------------------------
int __stdcall Header_OnDeleteItem(int a1, int i)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edi@3
  int v5; // ebx@4
  struct _DSA *v6; // eax@5
  int j; // ebx@6
  char pitem; // [sp+4h] [bp-4Ch]@3
  int v9; // [sp+8h] [bp-48h]@4
  struct tagRECT Rect; // [sp+40h] [bp-10h]@4

  v2 = a1;
  if ( a1 )
  {
    v4 = i;
    result = DSA_GetItem(*(HDSA *)(a1 + 60), i, &pitem);
    if ( result )
    {
      MyNotifyWinEvent(32769, *(_DWORD *)v2, -4, v4 + 1);
      Header_StopFilterEdit(v2, 0);
      *(_DWORD *)(v2 + 120) = 0;
      GetClientRect(*(HWND *)v2, &Rect);
      i = Rect.right;
      Header_OnGetItemRect(v2, v4, &Rect);
      InflateRect(&Rect, g_cxBorder, g_cyBorder);
      v5 = Header_OnGetItemOrder(v2, v4);
      Header_ShiftItems(v2, v5, -v9);
      result = DSA_DeleteItem(*(HDSA *)(v2 + 60), v4);
      if ( result )
      {
        v6 = *(struct _DSA **)(v2 + 96);
        if ( v6 )
        {
          DSA_DeleteItem(v6, v5);
          for ( j = 0; j < **(_DWORD **)(v2 + 96); ++j )
          {
            if ( DSA_GetItem(*(HDSA *)(v2 + 96), j, &a1) )
            {
              if ( a1 > v4 )
              {
                --a1;
                DSA_SetItem(*(HDSA *)(v2 + 96), j, &a1);
              }
            }
          }
        }
        Header_DestroyItemCallback(&pitem, 0);
        Rect.right = i;
        InvalidateRect(*(HWND *)v2, &Rect, 1);
        result = 1;
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7BEF88) --------------------------------------------------------
int __stdcall Header_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax@1
  int v5; // esi@1

  v4 = GetParent(hWnd);
  v5 = GetWindowLongW(v4, 0);
  if ( Msg == 8 )
    goto LABEL_23;
  if ( Msg == 135 )
    return 12;
  if ( Msg != 256 )
  {
    if ( Msg != 258 )
    {
      if ( Msg == 296 )
      {
        if ( CCOnUIState(v5, 296, wParam & 0x1FFFF, lParam) )
          InvalidateRect(hWnd, 0, 1);
      }
      return CallWindowProcW(*(WNDPROC *)(v5 + 140), hWnd, Msg, wParam, lParam);
    }
    if ( wParam != 9 && wParam != 13 && wParam != 27 )
    {
      CCNotifyNavigationKeyUsage(v5, 1u);
      return CallWindowProcW(*(WNDPROC *)(v5 + 140), hWnd, Msg, wParam, lParam);
    }
    return 0;
  }
  if ( wParam == 13 )
  {
LABEL_23:
    Header_StopFilterEdit(v5, 0);
  }
  else if ( wParam == 27 )
  {
    Header_StopFilterEdit(v5, 1);
  }
  else
  {
    if ( wParam != 115 )
      return CallWindowProcW(*(WNDPROC *)(v5 + 140), hWnd, Msg, wParam, lParam);
    Header_OnFilterButton(v5, *(_DWORD *)(v5 + 124));
  }
  return 0;
}

//----- (6F7BF059) --------------------------------------------------------
int __stdcall Header_BeginFilterEdit(int pitem, int i)
{
  struct _DSA *v2; // ST2C_4@1
  PVOID v3; // edi@1
  int v4; // eax@3
  bool v5; // zf@7
  const WCHAR *v6; // edi@7
  HWND v7; // eax@9
  int v8; // edi@10
  int v9; // eax@10
  LONG v10; // eax@10
  WPARAM v11; // ST28_4@10
  char v13; // [sp+8h] [bp-25Ch]@3
  char v14; // [sp+18h] [bp-24Ch]@3
  struct tagRECT Rect; // [sp+28h] [bp-23Ch]@3
  int nWidth; // [sp+38h] [bp-22Ch]@7
  RECT rcUpdate; // [sp+3Ch] [bp-228h]@3
  LPCWSTR lpWindowName; // [sp+4Ch] [bp-218h]@1
  WPARAM wParam; // [sp+50h] [bp-214h]@5
  DWORD dwStyle; // [sp+54h] [bp-210h]@1
  wchar_t pszDest; // [sp+58h] [bp-20Ch]@1

  v2 = *(struct _DSA **)(pitem + 60);
  lpWindowName = &pszDest;
  dwStyle = 1409286272;
  v3 = DSA_GetItemPtr(v2, i);
  if ( !v3 || i < 0 )
    return 0;
  Header_OnGetItemRect(pitem, i, &Rect);
  Header_GetFilterRects((int)&Rect, (int)&v13, (int)&rcUpdate, (int)&v14);
  *(_DWORD *)(pitem + 144) = *((_DWORD *)v3 + 11);
  v4 = *((_DWORD *)v3 + 11) & 0xF;
  if ( !v4 )
  {
    Str_Set(pitem + 148, *((LPCWSTR *)v3 + 12));
    lpWindowName = (LPCWSTR)*((_DWORD *)v3 + 12);
    wParam = *((_DWORD *)v3 + 13);
    goto LABEL_7;
  }
  if ( v4 != 1 )
    return 0;
  *(_DWORD *)(pitem + 152) = *((_DWORD *)v3 + 14);
  StringCchPrintfW(&pszDest, 0x104u, L"%d", *((_DWORD *)v3 + 14));
  wParam = 11;
  dwStyle = 1409294464;
LABEL_7:
  nWidth = rcUpdate.right - 6 * g_cxLabelMargin - rcUpdate.left;
  v5 = (*((_DWORD *)v3 + 11) & 0x8000) == 0;
  v6 = lpWindowName;
  if ( !v5 )
    v6 = &WindowName;
  v7 = CreateWindowExW(
         0,
         L"EDIT",
         v6,
         dwStyle,
         rcUpdate.left + 3 * g_cxLabelMargin,
         rcUpdate.top + g_cyEdge,
         nWidth,
         rcUpdate.bottom - 2 * g_cyEdge - rcUpdate.top,
         *(HWND *)pitem,
         0,
         g_hinst,
         0);
  *(_DWORD *)(pitem + 136) = v7;
  if ( v7 )
  {
    v8 = *(_DWORD *)(pitem + 120);
    *(_DWORD *)(pitem + 124) = i;
    *(_DWORD *)(pitem + 120) = Header_OnGetItemOrder(pitem, i);
    v9 = Header_ItemOrderToIndex(pitem, v8);
    Header_OnGetItemRect(pitem, v9, &Rect);
    Header_GetFilterRects((int)&Rect, (int)&v13, (int)&rcUpdate, (int)&v14);
    RedrawWindow(*(HWND *)pitem, &rcUpdate, 0, 5u);
    v10 = SetWindowLongW(*(HWND *)(pitem + 136), -4, (LONG)Header_EditWndProc);
    v11 = wParam;
    *(_DWORD *)(pitem + 140) = v10;
    SendMessageW(*(HWND *)(pitem + 136), 0xC5u, v11, 0);
    SendMessageW(*(HWND *)(pitem + 136), 0xB1u, 0, -1);
    SendMessageW(*(HWND *)(pitem + 136), 0x30u, *(_DWORD *)(pitem + 52), 0);
    SetFocus(*(HWND *)(pitem + 136));
  }
  return *(_DWORD *)(pitem + 136) != 0;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7BF2C0) --------------------------------------------------------
void __stdcall Header_OnLButtonDown(int pitem, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@2
  int v7; // eax@2
  int v8; // edi@2
  int v9; // eax@5
  HWND v10; // ST0C_4@7
  PVOID v11; // eax@10
  int v12; // ecx@10
  int v13; // eax@10
  int v14; // eax@13
  int v15; // [sp+4h] [bp-2Ch]@10
  int v16; // [sp+8h] [bp-28h]@10

  v5 = pitem;
  if ( pitem )
  {
    Header_StopFilterEdit(pitem, 0);
    v6 = a3;
    v7 = Header_HitTest(v5, a3, a4, (int)&pitem);
    v8 = v7;
    if ( pitem & 4 && a2 )
      Header_SendChange(v5, v7, -325, 0);
    v9 = pitem;
    if ( pitem & 0xE && !a2 )
    {
      v10 = *(HWND *)v5;
      *(_DWORD *)(v5 + 64) = v8;
      *(_DWORD *)(v5 + 72) = v9;
      *(_DWORD *)(v5 + 80) = v6;
      SetCapture(v10);
      SetTimer(*(HWND *)v5, 1u, 0x64u, 0);
      GetAsyncKeyState(27);
    }
    if ( !(pitem & 0xC) || a2 )
    {
      if ( pitem & 2 && *(_BYTE *)(v5 + 8) & 2 )
      {
        if ( a2 )
        {
          Header_SendChange(v5, v8, -323, 0);
        }
        else
        {
          *(_DWORD *)(v5 + 68) |= 1u;
          Header_InvalidateItem(v5, *(_DWORD *)(v5 + 64), 5u);
        }
      }
    }
    else
    {
      v11 = DSA_GetItemPtr(*(HDSA *)(v5 + 60), v8);
      *(_DWORD *)(v5 + 84) = *(_DWORD *)v11 - *((_DWORD *)v11 + 1);
      v12 = *(_DWORD *)v11;
      *(_DWORD *)(v5 + 80) = *(_DWORD *)v11;
      *(_DWORD *)(v5 + 76) = v12 - v6;
      v13 = *((_DWORD *)v11 + 1);
      *(_DWORD *)(v5 + 88) = v13;
      v16 = v13;
      v15 = 1;
      if ( !Header_SendChange(v5, v8, -326, (int)&v15) )
      {
        *(_DWORD *)(v5 + 72) = 0;
        CCReleaseCapture(v5);
        KillTimer(*(HWND *)v5, 1u);
        return;
      }
      if ( !HDDragFullWindows(v5) )
      {
        v14 = Header_PinDividerPos(v5, v6);
        Header_DrawDivider((HWND *)v5, v14);
      }
    }
    if ( pitem & 0x10 )
      Header_BeginFilterEdit(v5, v8);
    if ( pitem & 0x20 )
      Header_OnFilterButton(v5, v8);
  }
}

//----- (6F7BF40F) --------------------------------------------------------
int __stdcall Header_OnInsertItemA(int i, int a2, int pitem)
{
  int v3; // ebx@1
  int v4; // eax@4
  UINT v5; // ST04_4@6
  LPCSTR v6; // eax@6
  int v7; // ecx@9
  int v8; // eax@10
  int v10; // edi@18
  void *v11; // ST08_4@19
  void *v12; // ST08_4@21
  LPCSTR v13; // [sp+Ch] [bp-10h]@11
  int v14; // [sp+10h] [bp-Ch]@11
  const CHAR *v15; // [sp+14h] [bp-8h]@1
  void *v16; // [sp+18h] [bp-4h]@1

  v3 = 0;
  v16 = 0;
  v15 = 0;
  if ( !pitem || !i )
    return -1;
  if ( *(_BYTE *)pitem & 2 )
  {
    v4 = *(_DWORD *)(pitem + 8);
    if ( v4 != -1 )
    {
      if ( v4 )
      {
        v5 = *(_DWORD *)(i + 20);
        v15 = *(const CHAR **)(pitem + 8);
        v6 = ProduceWFromA(v5, v15);
        v16 = (void *)v6;
        if ( !v6 )
          return -1;
        *(_DWORD *)(pitem + 8) = v6;
      }
    }
  }
  if ( *(_DWORD *)pitem & 0x100 )
  {
    v7 = *(_DWORD *)(pitem + 36);
    if ( !(v7 & 0xF) )
    {
      v8 = *(_DWORD *)(pitem + 40);
      if ( v8 )
      {
        v13 = 0;
        v3 = v8;
        v14 = *(_DWORD *)(v8 + 4);
        if ( !(v7 & 0x8000) )
        {
          v13 = ProduceWFromA(*(_DWORD *)(i + 20), *(LPCSTR *)v8);
          if ( !v13 )
          {
            if ( v16 )
              FreeProducedString(v16);
            return -1;
          }
        }
        *(_DWORD *)(pitem + 40) = &v13;
      }
    }
  }
  v10 = Header_OnInsertItem(i, a2, pitem);
  if ( v16 )
  {
    v11 = v16;
    *(_DWORD *)(pitem + 8) = v15;
    FreeProducedString(v11);
  }
  if ( v3 )
  {
    v12 = (void *)v13;
    *(_DWORD *)(pitem + 40) = v3;
    FreeProducedString(v12);
  }
  return v10;
}

//----- (6F7BF4E8) --------------------------------------------------------
int __stdcall Header_WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int v4; // eax@1
  int v5; // esi@1
  LPARAM v6; // esi@2
  int result; // eax@3
  unsigned int v8; // edi@6
  int v9; // eax@14
  HWND v10; // ST0C_4@14
  int v11; // ST0C_4@15
  int v12; // eax@19
  int v13; // ST0C_4@36
  int v14; // eax@36
  LPARAM v15; // eax@45
  int v16; // eax@53
  int v17; // eax@55
  int v18; // ecx@58
  int v19; // eax@61
  int v20; // eax@65
  int v21; // eax@65
  int v22; // eax@111
  int v23; // [sp+8h] [bp-3Ch]@12
  int v24; // [sp+Ch] [bp-38h]@14
  int v25; // [sp+28h] [bp-1Ch]@12
  struct tagTRACKMOUSEEVENT EventTrack; // [sp+34h] [bp-10h]@20

  v4 = GetWindowLongW(hWnd, 0);
  v5 = v4;
  if ( v4 )
  {
    v8 = Msg;
    if ( Msg == 130 )
    {
      Header_OnNCDestroy(v4);
      LocalFree((HLOCAL)v5);
      SetWindowLongW(hWnd, 0, 0);
      return 0;
    }
    if ( Msg == 533 || Msg == 516 || GetAsyncKeyState(27) & 1 )
    {
      if ( *(_DWORD *)(v5 + 104) )
      {
        v25 = -1;
        v23 = 128;
        Header_EndDrag(v5);
        Header_SendChange(v5, *(_DWORD *)(v5 + 64), -311, (int)&v23);
      }
      else if ( *(_BYTE *)(v5 + 72) & 0xC )
      {
        v9 = *(_DWORD *)(v5 + 88);
        *(_DWORD *)(v5 + 72) = 0;
        v10 = *(HWND *)v5;
        v23 = 1;
        v24 = v9;
        KillTimer(v10, 1u);
        CCReleaseCapture(v5);
        Header_SendChange(v5, *(_DWORD *)(v5 + 64), -327, (int)&v23);
        if ( HDDragFullWindows(v5) )
        {
          v24 = *(_DWORD *)(v5 + 88);
          v11 = *(_DWORD *)(v5 + 64);
          v23 = 1;
          Header_OnSetItem(v5, v11, (int)&v23);
          RedrawWindow(*(HWND *)v5, 0, 0, 5u);
        }
        else
        {
          Header_DrawDivider((HWND *)v5, *(_DWORD *)(v5 + 80));
        }
      }
    }
    if ( v8 - 512 <= 0xD )
    {
      if ( *(_BYTE *)(v5 + 8) & 4 )
      {
        v12 = *(_DWORD *)(v5 + 68);
        if ( !(v12 & 2) )
        {
          *(_DWORD *)(v5 + 68) = v12 | 2;
          EventTrack.hwndTrack = *(HWND *)v5;
          EventTrack.cbSize = 16;
          EventTrack.dwFlags = 2;
          _TrackMouseEvent(&EventTrack);
        }
      }
    }
    if ( v8 > 0x1201 )
    {
      switch ( v8 )
      {
        case 0x120Au:
          result = Header_OnInsertItem(v5, wParam, lParam);
          break;
        case 0x1202u:
          result = Header_OnDeleteItem(v5, wParam);
          break;
        case 0x120Bu:
          result = Header_OnGetItem(v5, wParam, lParam);
          break;
        case 0x120Cu:
          result = Header_OnSetItem(v5, wParam, lParam);
          break;
        case 0x1205u:
          result = Header_OnLayout(v5, lParam);
          break;
        case 0x1206u:
          result = Header_OnHitTest(v5, lParam);
          break;
        case 0x1207u:
          result = Header_OnGetItemRect(v5, wParam, (LPRECT)lParam);
          break;
        case 0x1208u:
          result = *(_DWORD *)(v5 + 92);
          *(_DWORD *)(v5 + 92) = lParam;
          break;
        case 0x1209u:
          result = *(_DWORD *)(v5 + 92);
          break;
        case 0x1203u:
          result = Header_OnGetItemA(v5, wParam, lParam);
          break;
        case 0x1204u:
          result = Header_OnSetItemA(v5, wParam, lParam);
          break;
        case 0x120Fu:
          result = Header_ItemOrderToIndex(v5, wParam);
          break;
        case 0x1210u:
          v22 = Header_OnGetItemOrder(v5, wParam);
          result = (int)Header_OnCreateDragImage(v5, v22);
          break;
        case 0x1212u:
          result = Header_OnSetOrderArray(v5, wParam, lParam);
          break;
        case 0x1211u:
          result = Header_OnGetOrderArray(v5, wParam, lParam);
          break;
        case 0x1213u:
          result = Header_OnSetHotDivider(v5, wParam, lParam);
          break;
        case 0x1214u:
          *(_DWORD *)(v5 + 116) = wParam;
          result = 1;
          break;
        case 0x1215u:
          result = *(_DWORD *)(v5 + 116);
          break;
        case 0x1217u:
          Header_StopFilterEdit(v5, (unsigned __int16)lParam);
          result = Header_BeginFilterEdit(v5, wParam);
          break;
        case 0x1216u:
          if ( lParam )
          {
            result = *(_DWORD *)(v5 + 132);
            *(_DWORD *)(v5 + 132) = lParam;
          }
          else
          {
            result = *(_DWORD *)(v5 + 132);
          }
          break;
        case 0x1218u:
          result = Header_OnClearFilter(v5, wParam);
          break;
        default:
          goto LABEL_122;
      }
      return result;
    }
    if ( v8 == 4609 )
      return Header_OnInsertItemA(v5, wParam, lParam);
    if ( v8 > 0x100 )
    {
      if ( v8 > 0x203 )
      {
        if ( v8 == 517 )
        {
          if ( CCSendNotify(v5, -5, 0) )
            return 0;
          return DefWindowProcW(hWnd, v8, wParam, lParam);
        }
        if ( v8 == 675 )
        {
          Header_SetHotItem(v5, -1);
          *(_DWORD *)(v5 + 68) &= 0xFFFFFFFD;
          return DefWindowProcW(hWnd, v8, wParam, lParam);
        }
        if ( v8 == 792 )
          goto LABEL_91;
        if ( v8 == 4608 )
          return **(_DWORD **)(v5 + 60);
      }
      else
      {
        if ( v8 == 515 )
        {
          Header_OnLButtonDown(v5, 1, (signed __int16)lParam, SHIWORD(lParam), wParam);
          return 0;
        }
        if ( v8 == 273 )
        {
          if ( *(_DWORD *)(v5 + 124) >= 0 && lParam == *(_DWORD *)(v5 + 136) && HIWORD(wParam) == 768 )
          {
            Header_FilterChanged(v5, 1);
            return 0;
          }
          return DefWindowProcW(hWnd, v8, wParam, lParam);
        }
        if ( v8 == 275 )
        {
          if ( wParam == 256 )
          {
            Header_FilterChanged(v5, 0);
            return 0;
          }
          return DefWindowProcW(hWnd, v8, wParam, lParam);
        }
        if ( v8 == 512 )
        {
          Header_OnMouseMove(v5, (signed __int16)lParam, SHIWORD(lParam), wParam);
          return 0;
        }
        if ( v8 == 513 )
        {
          Header_OnLButtonDown(v5, 0, (signed __int16)lParam, SHIWORD(lParam), wParam);
          return 0;
        }
        if ( v8 == 514 )
        {
          Header_OnLButtonUp(v5, (signed __int16)lParam, SHIWORD(lParam), wParam);
          return 0;
        }
      }
    }
    else
    {
      if ( v8 == 256 )
      {
        if ( *(_BYTE *)(v5 + 68) & 8 )
        {
          if ( wParam == 113 )
          {
            v16 = Header_ItemOrderToIndex(v5, *(_DWORD *)(v5 + 120));
            Header_BeginFilterEdit(v5, v16);
          }
          else if ( wParam == 115 )
          {
            v17 = Header_ItemOrderToIndex(v5, *(_DWORD *)(v5 + 120));
            Header_OnFilterButton(v5, v17);
          }
          else
          {
            if ( wParam != 37 && wParam != 39 )
              return DefWindowProcW(hWnd, v8, wParam, lParam);
            v18 = *(_DWORD *)(v5 + 120);
            if ( wParam == 39 )
            {
              *(_DWORD *)(v5 + 120) = (v18 + 1) % **(_DWORD **)(v5 + 60);
            }
            else
            {
              *(_DWORD *)(v5 + 120) = v18 - 1;
              if ( v18 - 1 < 0 )
              {
                v19 = **(_DWORD **)(v5 + 60) - 1;
                if ( v19 <= 0 )
                  v19 = 0;
                *(_DWORD *)(v5 + 120) = v19;
              }
            }
            if ( v18 != *(_DWORD *)(v5 + 120) )
            {
              v20 = Header_ItemOrderToIndex(v5, v18);
              Header_InvalidateItem(v5, v20, 1u);
              v21 = Header_ItemOrderToIndex(v5, *(_DWORD *)(v5 + 120));
              Header_InvalidateItem(v5, v21, 1u);
              UpdateWindow(*(HWND *)v5);
            }
          }
          CCNotifyNavigationKeyUsage(v5, 1u);
          return 0;
        }
        return DefWindowProcW(hWnd, v8, wParam, lParam);
      }
      if ( v8 > 0x31 )
      {
        if ( v8 == 61 )
        {
          if ( lParam == -12 )
            return 65553;
          return DefWindowProcW(hWnd, v8, wParam, lParam);
        }
        if ( v8 == 85 )
          return CIHandleNotifyFormat(v5, lParam);
        if ( v8 == 125 )
        {
          if ( wParam == -16 )
          {
            v15 = lParam;
            *(_DWORD *)(v5 + 8) = *(_DWORD *)(lParam + 4);
            if ( (*(_DWORD *)(v15 + 4) ^ *(_DWORD *)v15) & 0x100 )
              Header_StopFilterEdit(v5, 1);
            InvalidateRect(*(HWND *)v5, 0, 1);
          }
          return 0;
        }
        if ( v8 == 135 )
          return 3;
        goto LABEL_122;
      }
      if ( v8 == 49 )
        return Header_OnGetFont(v5);
      if ( v8 == 1 )
        return (Header_OnCreate(v5, lParam) != 0) - 1;
      if ( v8 > 6 )
      {
        if ( v8 > 8 )
        {
          if ( v8 != 15 )
          {
            if ( v8 == 32 )
              return Header_OnSetCursor(v5, (HWND)wParam, (unsigned __int16)lParam, (unsigned int)lParam >> 16);
            if ( v8 == 48 )
            {
              Header_OnSetFont(v5, (HGDIOBJ)wParam, lParam);
              return 0;
            }
            goto LABEL_122;
          }
LABEL_91:
          Header_OnPaint(v5, (HDC)wParam);
          return 0;
        }
        if ( *(_DWORD *)(v5 + 8) & 0x100 )
        {
          v13 = *(_DWORD *)(v5 + 120);
          *(_DWORD *)(v5 + 68) ^= (*(_DWORD *)(v5 + 68) ^ 8 * (v8 == 7)) & 8;
          v14 = Header_ItemOrderToIndex(v5, v13);
          Header_InvalidateItem(v5, v14, 1u);
          UpdateWindow(*(HWND *)v5);
          return 0;
        }
        return DefWindowProcW(hWnd, v8, wParam, lParam);
      }
    }
LABEL_122:
    if ( CCWndProc(v5, v8, wParam, lParam, (int)&Msg) )
      return Msg;
    return DefWindowProcW(hWnd, v8, wParam, lParam);
  }
  v6 = lParam;
  if ( Msg == 129 )
  {
    result = (int)LocalAlloc(0x40u, 0x9Cu);
    if ( !result )
      return result;
    *(_DWORD *)result = hWnd;
    *(_DWORD *)(result + 4) = *(_DWORD *)(v6 + 12);
    SetWindowLongW(hWnd, 0, result);
  }
  return DefWindowProcW(hWnd, Msg, wParam, v6);
}

//----- (6F7BFBA5) --------------------------------------------------------
int __stdcall ListView_SetSRecompute(int a1)
{
  int result; // eax@1

  result = a1;
  *(_WORD *)(a1 + 14) = 0x7FFF;
  *(_WORD *)(a1 + 16) = 0x7FFF;
  *(_WORD *)(a1 + 18) = 0x7FFF;
  *(_WORD *)(a1 + 20) = 0x7FFF;
  return result;
}

//----- (6F7BFBCD) --------------------------------------------------------
signed int __stdcall ListView_GetRegIASetting(int a1)
{
  signed int v1; // edi@1
  signed int v2; // esi@1
  DWORD Type; // [sp+8h] [bp-10h]@2
  BYTE Data[4]; // [sp+Ch] [bp-Ch]@2
  DWORD cbData; // [sp+10h] [bp-8h]@2
  HKEY phkResult; // [sp+14h] [bp-4h]@1

  v1 = 0;
  v2 = 1;
  if ( !RegOpenKeyExW(
          HKEY_CURRENT_USER,
          L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced",
          0,
          0x20019u,
          &phkResult) )
  {
    cbData = 4;
    if ( !RegQueryValueExW(phkResult, L"UseDoubleClickTimer", 0, &Type, Data, &cbData) )
    {
      v2 = *(_DWORD *)Data;
      v1 = 1;
    }
    RegCloseKey(phkResult);
  }
  *(_DWORD *)a1 = v2;
  return v1;
}

//----- (6F7BFCE5) --------------------------------------------------------
int __stdcall ListView_NotifyCacheHint(int a1, int a2, int a3)
{
  int result; // eax@2
  LPARAM lParam; // [sp+0h] [bp-14h]@2
  int v5; // [sp+Ch] [bp-8h]@2
  int v6; // [sp+10h] [bp-4h]@2

  if ( a2 > a3 )
  {
    result = 0;
  }
  else
  {
    v5 = a2;
    v6 = a3;
    result = CCSendNotify(a1, -113, (LPARAM)&lParam) == 0;
  }
  return result;
}

//----- (6F7BFD1D) --------------------------------------------------------
int __stdcall ListView_LazyCreateObjects(int *a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@2

  result = a2;
  if ( a2 < a3 )
  {
    do
    {
      v4 = result + 1;
      MyNotifyWinEvent(0x8000, *a1, -4, result + 1);
      result = v4;
    }
    while ( v4 < a3 );
  }
  return result;
}

//----- (6F7BFD51) --------------------------------------------------------
int __stdcall ListView_LazyCreateWinEvents(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int result; // eax@1
  int v5; // edi@1

  v3 = a2;
  result = *(_DWORD *)(a1 + 380);
  v5 = a3 + 1;
  if ( a2 < result )
    goto LABEL_13;
  if ( v5 <= *(_DWORD *)(a1 + 384) )
    return result;
  if ( a2 <= result )
  {
LABEL_13:
    if ( v5 >= result )
    {
      ListView_LazyCreateObjects((int *)a1, a2, *(_DWORD *)(a1 + 380));
      *(_DWORD *)(a1 + 380) = a2;
      v3 = *(_DWORD *)(a1 + 384);
    }
  }
  result = *(_DWORD *)(a1 + 384);
  if ( v5 >= result && v3 <= result )
  {
    result = ListView_LazyCreateObjects((int *)a1, result, v5);
    *(_DWORD *)(a1 + 384) = v5;
    v5 = *(_DWORD *)(a1 + 380);
  }
  if ( v3 < v5 )
  {
    *(_DWORD *)(a1 + 380) = v3;
    *(_DWORD *)(a1 + 384) = v5;
    result = ListView_LazyCreateObjects((int *)a1, v3, v5);
  }
  return result;
}

//----- (6F7BFDD7) --------------------------------------------------------
HWND __stdcall ListView_RequestFindItem(int a1, const void *a2, int a3)
{
  LPARAM lParam; // [sp+8h] [bp-28h]@1
  int v5; // [sp+14h] [bp-1Ch]@1
  char v6; // [sp+18h] [bp-18h]@1

  qmemcpy(&v6, a2, 0x18u);
  v5 = a3;
  return CCSendNotify(a1, -179, (LPARAM)&lParam);
}

//----- (6F7BFE0E) --------------------------------------------------------
BOOL __stdcall ListView_SendChange(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  LPARAM lParam; // [sp+0h] [bp-2Ch]@1
  int v10; // [sp+Ch] [bp-20h]@1
  int v11; // [sp+10h] [bp-1Ch]@1
  int v12; // [sp+14h] [bp-18h]@1
  int v13; // [sp+18h] [bp-14h]@1
  int v14; // [sp+1Ch] [bp-10h]@1
  int v15; // [sp+20h] [bp-Ch]@1
  int v16; // [sp+24h] [bp-8h]@1
  int v17; // [sp+28h] [bp-4h]@1

  v15 = 0;
  v16 = 0;
  v10 = a2;
  v11 = a3;
  v12 = a6;
  v13 = a5;
  v14 = a7;
  v17 = a8;
  return CCSendNotify(a1, a4, (LPARAM)&lParam) == 0;
}

//----- (6F7BFE5F) --------------------------------------------------------
HWND __stdcall ListView_Notify(int a1, INT_PTR i, int a3, int a4)
{
  bool v4; // zf@1
  PVOID v5; // eax@3
  LPARAM lParam; // [sp+4h] [bp-2Ch]@5
  INT_PTR v8; // [sp+10h] [bp-20h]@1
  int v9; // [sp+14h] [bp-1Ch]@1
  int v10; // [sp+18h] [bp-18h]@1
  int v11; // [sp+1Ch] [bp-14h]@1
  int v12; // [sp+20h] [bp-10h]@1
  int v13; // [sp+2Ch] [bp-4h]@1

  v11 = 0;
  v10 = 0;
  v12 = 0;
  v13 = 0;
  v4 = (*(_DWORD *)(a1 + 8) & 0x1000) == 0;
  v8 = i;
  v9 = a3;
  if ( v4 && a4 == -103 )
  {
    v5 = DPA_GetPtr(*(HDPA *)(a1 + 40), i);
    if ( v5 )
      v13 = *((_DWORD *)v5 + 7);
  }
  return CCSendNotify(a1, a4, (LPARAM)&lParam);
}

//----- (6F7BFEC0) --------------------------------------------------------
signed int __stdcall ListView_GetEmptyText(int a1)
{
  signed int result; // eax@2
  HWND v2; // ebx@5
  char Dst; // [sp+4h] [bp-D8h]@5
  int v4; // [sp+10h] [bp-CCh]@5
  WCHAR *v5; // [sp+24h] [bp-B8h]@5
  int v6; // [sp+28h] [bp-B4h]@5
  WCHAR String; // [sp+38h] [bp-A4h]@5

  if ( *(_BYTE *)(a1 + 36) & 0x40 )
  {
    result = 0;
  }
  else if ( *(_DWORD *)(a1 + 440) )
  {
    result = 1;
  }
  else
  {
    memset(&Dst, 0, 0x34u);
    v5 = &String;
    String = 0;
    v4 = 1;
    v6 = 80;
    v2 = CCSendNotify(a1, -161, (LPARAM)&Dst);
    if ( v2 )
      Str_Set(a1 + 440, &String);
    else
      *(_DWORD *)(a1 + 36) |= 0x40u;
    result = (signed int)v2;
  }
  return result;
}

//----- (6F7BFF74) --------------------------------------------------------
void __stdcall ListView_NotifyFocusEvent(int a1)
{
  HWND v1; // edi@3

  if ( *(_DWORD *)(a1 + 100) != -1 && IsWindowVisible(*(HWND *)a1) )
  {
    v1 = *(HWND *)a1;
    if ( GetFocus() == v1 )
      MyNotifyWinEvent(32773, (int)v1, -4, *(_DWORD *)(a1 + 100) + 1);
  }
}

//----- (6F7BFFB9) --------------------------------------------------------
int __stdcall ListView_NotifyRecreate(int a1)
{
  int result; // eax@1

  MyNotifyWinEvent(32769, *(_DWORD *)a1, -4, 0);
  result = MyNotifyWinEvent(0x8000, *(_DWORD *)a1, -4, 0);
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 380) = 0;
  return result;
}

//----- (6F7BFFFA) --------------------------------------------------------
int __stdcall ListView_SortCallback(void *p1, void *p2, LPARAM lParam)
{
  PVOID v3; // edi@2
  PVOID v4; // eax@2
  int (__stdcall *v5)(_DWORD, _DWORD, _DWORD); // ecx@4
  const WCHAR *v6; // edi@5
  const WCHAR *v7; // ecx@5
  const WCHAR *v8; // edx@5
  const WCHAR *v9; // eax@7
  int result; // eax@11

  if ( *(_DWORD *)(lParam + 4) )
  {
    v3 = DPA_GetPtr(*(HDPA *)(*(_DWORD *)lParam + 40), (INT_PTR)p1);
    v4 = DPA_GetPtr(*(HDPA *)(*(_DWORD *)lParam + 40), (INT_PTR)p2);
  }
  else
  {
    v3 = p1;
    v4 = p2;
  }
  v5 = *(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(lParam + 8);
  if ( !v5 )
  {
    v6 = *(const WCHAR **)v3;
    v7 = &c_szNULL;
    v8 = v6;
    if ( !v6 )
      v8 = &c_szNULL;
    v9 = *(const WCHAR **)v4;
    if ( v9 )
      v7 = v9;
    if ( v8 != (const WCHAR *)-1 && v7 != (const WCHAR *)-1 )
      return lstrcmpiW(v6, v9);
    return -1;
  }
  if ( *(_DWORD *)(lParam + 16) )
  {
    result = v5(*((_DWORD *)v3 + 7), *((_DWORD *)v4 + 7), *(_DWORD *)(lParam + 12));
  }
  else
  {
    if ( !*(_DWORD *)(lParam + 4) )
      return -1;
    result = v5(p1, p2, *(_DWORD *)(lParam + 12));
  }
  return result;
}

//----- (6F7C0092) --------------------------------------------------------
int __stdcall ListView_InvalidateTTLastHit(int a1, int a2)
{
  int result; // eax@1

  result = a1 + 156;
  if ( *(_DWORD *)(a1 + 156) == a2 )
  {
    *(_DWORD *)result = -1;
    result = *(_DWORD *)(a1 + 164);
    if ( result )
    {
      if ( result != -1 )
        *(_WORD *)result = 0;
    }
  }
  return result;
}

//----- (6F7C00C7) --------------------------------------------------------
int __stdcall ListView_SortAllColumns(void *Src, LPARAM lParam)
{
  void *v2; // ebx@1
  int v3; // eax@2
  int result; // eax@4
  HDPA v5; // eax@5
  HDPA v6; // edx@5
  int v7; // esi@6
  int v8; // ecx@6
  int v9; // eax@6
  int v10; // eax@10
  int v11; // eax@11
  PVOID v12; // edi@13
  void *v13; // edi@17
  HLOCAL v14; // eax@18
  void *v15; // edx@22
  HLOCAL v16; // eax@23
  struct _DPA *hdpa; // [sp+Ch] [bp-14h]@5
  signed int v18; // [sp+10h] [bp-10h]@5
  int Size; // [sp+14h] [bp-Ch]@9
  int i; // [sp+18h] [bp-8h]@6
  int v21; // [sp+1Ch] [bp-4h]@18
  HLOCAL Srca; // [sp+28h] [bp+8h]@9
  INT_PTR lParama; // [sp+2Ch] [bp+Ch]@12

  v2 = Src;
  ListView_InvalidateTTLastHit((int)Src, *((_DWORD *)Src + 39));
  if ( !*(_DWORD *)(lParam + 16) || (v3 = *((_DWORD *)Src + 79)) != 0 && *(_DWORD *)v3 )
  {
    v18 = 0;
    v5 = DPA_Clone(*((const HDPA *)Src + 10), 0);
    v6 = v5;
    hdpa = v5;
    if ( v5 )
    {
      v7 = *(_DWORD *)v5;
      v8 = *((_DWORD *)v5 + 1);
      v9 = 0;
      for ( i = *((_DWORD *)v6 + 1); v9 < v7; ++v9 )
      {
        *(_DWORD *)v8 = v9;
        v8 += 4;
      }
      *(_DWORD *)(lParam + 4) = 1;
      if ( DPA_Sort(v6, ListView_SortCallback, lParam) )
      {
        Size = 4 * v7;
        Srca = LocalAlloc(0x40u, 4 * v7);
        if ( Srca )
        {
          v10 = *((_DWORD *)v2 + 79);
          if ( v10 )
          {
            v11 = *(_DWORD *)v10;
            if ( v11 )
            {
              for ( lParama = v11 - 1; lParama >= 0; --lParama )
              {
                v12 = DPA_GetPtr(*((HDPA *)v2 + 79), lParama);
                if ( v12 )
                {
                  while ( *(_DWORD *)v12 < v7 )
                  {
                    if ( DPA_InsertPtr((HDPA)v12, v7, 0) == -1 )
                      goto LABEL_26;
                  }
                  v13 = (void *)*((_DWORD *)v12 + 1);
                  if ( v7 > 0 )
                  {
                    v14 = Srca;
                    v21 = v7;
                    do
                    {
                      *(_DWORD *)v14 = *((_DWORD *)v13 + *(_DWORD *)((char *)v14 + i - (_DWORD)Srca));
                      v14 = (char *)v14 + 4;
                      --v21;
                    }
                    while ( v21 );
                  }
                  memmove(v13, Srca, Size);
                }
              }
            }
          }
          v15 = *(void **)(*((_DWORD *)v2 + 10) + 4);
          if ( v7 > 0 )
          {
            v16 = Srca;
            do
            {
              *(_DWORD *)v16 = *((_DWORD *)v15 + *(_DWORD *)((char *)v16 + i - (_DWORD)Srca));
              v16 = (char *)v16 + 4;
              --v7;
            }
            while ( v7 );
          }
          memmove(v15, Srca, Size);
          v18 = 1;
LABEL_26:
          LocalFree(Srca);
        }
      }
      DPA_Destroy(hdpa);
    }
    result = v18;
  }
  else
  {
    *(_DWORD *)(lParam + 4) = 0;
    result = DPA_Sort(*((HDPA *)Src + 10), ListView_SortCallback, lParam);
  }
  return result;
}

//----- (6F7C0241) --------------------------------------------------------
int __stdcall ListView_OnApproximateViewRect(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // edx@3
  int v6; // ecx@5

  v4 = a2;
  if ( a2 == -1 )
    v4 = *(_DWORD *)(a1 + 372);
  v5 = a3;
  if ( a3 == -1 )
    v5 = *(_DWORD *)(a1 + 120);
  v6 = a4;
  if ( a4 == -1 )
    v6 = *(_DWORD *)(a1 + 124);
  return pfnListView_ApproximateViewRect[*(_DWORD *)(a1 + 8) & 3](a1, v4, v5, v6);
}
// 6F7C0288: using guessed type int (__stdcall *pfnListView_ApproximateViewRect[4])(int, int, int, int);

//----- (6F7C029D) --------------------------------------------------------
signed int __stdcall ListView_OnSetLVRangeObject(int a1, int a2, int a3)
{
  int v4; // esi@4

  if ( a2 )
  {
    if ( a2 != 1 )
      return 0;
    v4 = a1 + 368;
  }
  else
  {
    v4 = a1 + 364;
  }
  if ( *(_DWORD *)v4 )
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)v4 + 8))(*(_DWORD *)v4);
  *(_DWORD *)v4 = a3;
  if ( a3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)a3 + 4))(a3);
  return 1;
}

//----- (6F7C02EE) --------------------------------------------------------
int __stdcall ListView_OnSortItems(void *Src, int a2, int a3, int a4)
{
  bool v4; // zf@1
  int result; // eax@2
  PVOID v6; // ebx@4
  INT_PTR v7; // edi@8
  int v8; // eax@12
  LPARAM lParam; // [sp+4h] [bp-14h]@1
  int v10; // [sp+Ch] [bp-Ch]@1
  int v11; // [sp+10h] [bp-8h]@1
  int v12; // [sp+14h] [bp-4h]@1

  v10 = a3;
  v4 = (*((_DWORD *)Src + 2) & 0x1000) == 0;
  v11 = a2;
  lParam = (LPARAM)Src;
  v12 = a4;
  if ( v4 )
  {
    ListView_DismissEdit((int)Src, 1);
    if ( *((_DWORD *)Src + 25) == -1 )
      v6 = 0;
    else
      v6 = DPA_GetPtr(*((HDPA *)Src + 10), *((_DWORD *)Src + 25));
    if ( ListView_SortAllColumns(Src, (LPARAM)&lParam) )
    {
      if ( v6 )
      {
        v7 = *((_DWORD *)Src + 93);
        while ( 1 )
        {
          --v7;
          if ( v7 < 0 )
            break;
          if ( DPA_GetPtr(*((HDPA *)Src + 10), v7) == v6 )
          {
            *((_DWORD *)Src + 25) = v7;
            *((_DWORD *)Src + 26) = v7;
          }
        }
      }
      v8 = *((_DWORD *)Src + 2) & 3;
      if ( v8 != 2 && v8 )
      {
        if ( v8 == 1 || v8 == 3 )
          InvalidateRect(*(HWND *)Src, 0, 1);
      }
      else
      {
        ListView_CommonArrange((HDC)Src, 0, *((HDPA *)Src + 10));
      }
      MyNotifyWinEvent(32772, *(_DWORD *)Src, -4, 0);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C03C5) --------------------------------------------------------
struct _IMAGELIST *__stdcall CreateCheckBoxImagelist(HIMAGELIST himl, int a2, HICON hicon, int a4)
{
  HDC v4; // edi@1
  struct _IMAGELIST *result; // eax@2
  HDC v6; // ebx@3
  signed int v7; // esi@14
  int v8; // esi@20
  struct tagRECT rc; // [sp+8h] [bp-2Ch]@12
  HGDIOBJ v10; // [sp+18h] [bp-1Ch]@12
  HDC hdc; // [sp+1Ch] [bp-18h]@3
  HGDIOBJ h; // [sp+20h] [bp-14h]@8
  int cGrow; // [sp+24h] [bp-10h]@1
  COLORREF crMask; // [sp+28h] [bp-Ch]@9
  int cy; // [sp+2Ch] [bp-8h]@6
  int v16; // [sp+30h] [bp-4h]@6
  struct _IMAGELIST *himla; // [sp+3Ch] [bp+8h]@8

  v4 = GetDC(0);
  cGrow = (a2 != 0) + 2;
  if ( v4 )
  {
    v6 = CreateCompatibleDC(v4);
    hdc = v6;
    ReleaseDC(0, v4);
    if ( v6 )
    {
      if ( !himl || !ImageList_GetIconSize(himl, &v16, &cy) )
      {
        v16 = g_cxSmIcon;
        cy = g_cySmIcon;
      }
      himla = ImageList_Create(v16, cy, 1u, 0, cGrow);
      h = CreateColorBitmap(cGrow * v16, cy);
      if ( hicon )
      {
        crMask = 16711935;
        if ( g_clrWindow == 16711935 )
          crMask = 16711680;
      }
      else
      {
        crMask = g_clrWindow;
      }
      v10 = SelectObject(v6, h);
      rc.bottom = cy;
      rc.right = cGrow * v16;
      rc.top = 0;
      rc.left = 0;
      FillRectClr(v6, &rc, crMask);
      rc.right = v16;
      InflateRect(&rc, -g_cxEdge, -g_cyEdge);
      ++rc.right;
      ++rc.bottom;
      if ( a2 )
        OffsetRect(&rc, v16, 0);
      v7 = hicon != 0 ? 0 : 2048;
      DrawFrameControl(v6, &rc, 4u, v7 | 0x4000);
      OffsetRect(&rc, v16, 0);
      if ( a4 )
        OffsetRect(&rc, -1, 0);
      DrawFrameControl(hdc, &rc, 4u, v7 | 0x4400);
      SelectObject(hdc, v10);
      if ( hicon )
        ImageList_AddMasked(himla, (HBITMAP)h, crMask);
      else
        ImageList_Add(himla, (HBITMAP)h, 0);
      if ( a4 )
      {
        v8 = cGrow - 1;
        hicon = ImageList_GetIcon(himla, cGrow - 1, 0);
        MirrorIcon(&hicon, 0);
        ImageList_ReplaceIcon(himla, v8, hicon);
      }
      DeleteDC(hdc);
      DeleteObject(h);
      result = himla;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C05CA) --------------------------------------------------------
LRESULT __stdcall ListView_PopBubble(int a1)
{
  LRESULT result; // eax@1

  result = *(_DWORD *)(a1 + 152);
  if ( result )
    result = SendMessageW((HWND)result, 0x41Cu, 0, 0);
  return result;
}

//----- (6F7C05F5) --------------------------------------------------------
LRESULT __stdcall ListView_OnHelp(int a1, LPARAM lParam)
{
  if ( lParam && (*(_DWORD *)(a1 + 8) & 3) == 1 && !*(_DWORD *)(lParam + 8) )
  {
    *(_DWORD *)(lParam + 12) = *(_DWORD *)a1;
    *(_DWORD *)(lParam + 8) = GetDlgCtrlID(*(HWND *)a1);
  }
  return DefWindowProcW(*(HWND *)a1, 0x53u, 0, lParam);
}

//----- (6F7C063D) --------------------------------------------------------
int __stdcall ListView_OnSetIconSpacing(int a1, int a2)
{
  int result; // eax@1

  result = *(_WORD *)(a1 + 196) | (*(_WORD *)(a1 + 200) << 16);
  if ( a2 == -1 )
  {
    *(_DWORD *)(a1 + 44) &= 0xFFFFEFFF;
    *(_DWORD *)(a1 + 196) = g_cxIconSpacing + *(_DWORD *)(a1 + 208) - g_cxIcon;
    *(_DWORD *)(a1 + 200) = g_cyIconSpacing + *(_DWORD *)(a1 + 212) - g_cyIcon;
  }
  else
  {
    if ( (_WORD)a2 )
      *(_DWORD *)(a1 + 196) = (unsigned __int16)a2;
    if ( HIWORD(a2) )
      *(_DWORD *)(a1 + 200) = HIWORD(a2);
    *(_DWORD *)(a1 + 44) |= 0x1000u;
  }
  *(_DWORD *)(a1 + 244) = -1;
  return result;
}
// 6F7E698C: using guessed type int g_cyIconSpacing;
// 6F7E6990: using guessed type int g_cxIconSpacing;
// 6F7E699C: using guessed type int g_cyIcon;
// 6F7E69A0: using guessed type int g_cxIcon;

//----- (6F7C06D1) --------------------------------------------------------
int __thiscall fShouldFirstClickActivate(LONG this)
{
  LONG cbData; // [sp+0h] [bp-4h]@1

  cbData = this;
  if ( !dword_6F7E8AB8 )
  {
    cbData = 0;
    if ( !RegQueryValueW(
            HKEY_CURRENT_USER,
            L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NoFirstClickActivate",
            0,
            &cbData) )
      dword_6F7E859C[0] = 0;
    dword_6F7E8AB8 = 1;
  }
  return dword_6F7E859C[0];
}
// 6F7E859C: using guessed type int dword_6F7E859C[];
// 6F7E8AB8: using guessed type int dword_6F7E8AB8;

//----- (6F7C07CB) --------------------------------------------------------
BOOL __stdcall EditBoxHasFocus()
{
  HWND v0; // eax@1

  v0 = GetFocus();
  return v0 && SendMessageW(v0, 0x87u, 0, 0) & 8;
}

//----- (6F7C07F5) --------------------------------------------------------
int __stdcall EqualRects(RECT *lprc1, int a2, int a3)
{
  int v3; // ebx@1
  RECT *v4; // esi@2
  int result; // eax@5

  v3 = 0;
  if ( a3 <= 0 )
  {
LABEL_5:
    result = 1;
  }
  else
  {
    v4 = lprc1;
    while ( EqualRect(v4, (RECT *)((char *)v4 + a2 - (_DWORD)lprc1)) )
    {
      ++v3;
      ++v4;
      if ( v3 >= a3 )
        goto LABEL_5;
    }
    result = 0;
  }
  return result;
}

//----- (6F7C0837) --------------------------------------------------------
int __stdcall ListView_FindWorkArea(int a1, POINT pt, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int result; // eax@4

  v3 = 0;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 128) <= 0 )
  {
LABEL_4:
    result = 0;
    *(_WORD *)a3 = 0;
  }
  else
  {
    while ( !PtInRect((const RECT *)(v3 + *(_DWORD *)(a1 + 132)), pt) )
    {
      ++v4;
      v3 += 16;
      if ( v4 >= *(_DWORD *)(a1 + 128) )
        goto LABEL_4;
    }
    *(_WORD *)a3 = v4;
    result = 1;
  }
  return result;
}

//----- (6F7C0892) --------------------------------------------------------
HRESULT IntToUInt(INT iOperand, UINT *puResult)
{
  HRESULT result; // eax@2

  if ( iOperand < 0 )
  {
    *puResult = -1;
    result = -2147024362;
  }
  else
  {
    *puResult = iOperand;
    result = 0;
  }
  return result;
}

//----- (6F7C08BB) --------------------------------------------------------
int __stdcall ListView_OnGetNumberOfWorkAreas(int a1, int a2)
{
  int result; // eax@1

  result = a2;
  if ( a2 )
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 128);
  return result;
}

//----- (6F7C08DB) --------------------------------------------------------
int __stdcall ListView_OnGetWorkAreas(int a1, int a2, LPRECT lprcDst)
{
  int v3; // ebx@1
  LPRECT i; // esi@1
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+Ch] [bp-4h]@1
  int v8; // [sp+18h] [bp+8h]@1

  v7 = 0;
  v3 = a1;
  v8 = 0;
  for ( i = lprcDst; ; ++i )
  {
    result = *(_DWORD *)(v3 + 128);
    v6 = a2;
    if ( result < a2 )
      v6 = *(_DWORD *)(v3 + 128);
    if ( v7 >= v6 )
      break;
    if ( v7 >= result )
    {
      i->left = 0;
      i->top = 0;
      i->right = 0;
      i->bottom = 0;
    }
    else
    {
      CopyRect(i, (const RECT *)(v8 + *(_DWORD *)(v3 + 132)));
    }
    ++v7;
    v8 += 16;
  }
  return result;
}

//----- (6F7C093E) --------------------------------------------------------
BOOL __stdcall ListView_IsItemUnfolded(int a1, int a2)
{
  return a1 && a2 >= 0 && !(*(_BYTE *)(a1 + 8) & 3) && *(_BYTE *)(a1 + 44) & 0x80 && *(_DWORD *)(a1 + 100) == a2;
}

//----- (6F7C0972) --------------------------------------------------------
BOOL __stdcall ListView_IsItemUnfoldedPtr(int a1, int a2)
{
  return a1 && a2 && !(*(_BYTE *)(a1 + 8) & 3) && *(_BYTE *)(a1 + 44) & 0x80 && *(_BYTE *)(a2 + 24) & 1;
}

//----- (6F7C09A7) --------------------------------------------------------
BOOL __stdcall ListView_SetFocus(HWND hWnd)
{
  SetFocus(hWnd);
  return IsWindow(hWnd);
}

//----- (6F7C09C1) --------------------------------------------------------
void __stdcall ListView_Realize(int a1, HDC hdc, BOOL bForceBkgd, int a4)
{
  signed int v4; // ebx@1
  HDC v5; // edi@2

  v4 = 0;
  if ( *(_DWORD *)(a1 + 436) )
  {
    v5 = hdc;
    if ( hdc || (v5 = GetDC(*(HWND *)a1)) != 0 )
    {
      SelectPalette(v5, *(HPALETTE *)(a1 + 436), bForceBkgd);
      if ( RealizePalette(v5) || a4 )
        v4 = 1;
      if ( !hdc )
        ReleaseDC(*(HWND *)a1, v5);
      if ( v4 )
        InvalidateRect(*(HWND *)a1, 0, 1);
    }
  }
}

//----- (6F7C0A39) --------------------------------------------------------
BOOL __stdcall RectInRect(RECT *lprcSrc1, RECT *lprcSrc2)
{
  struct tagRECT rcDst; // [sp+0h] [bp-10h]@1

  return IntersectRect(&rcDst, lprcSrc1, lprcSrc2);
}

//----- (6F7C0A5A) --------------------------------------------------------
BOOL __stdcall ListView_DeleteHrgnInval(int a1)
{
  BOOL result; // eax@1

  result = *(_DWORD *)(a1 + 148);
  if ( result && result != 1 )
    result = DeleteObject(*(HGDIOBJ *)(a1 + 148));
  *(_DWORD *)(a1 + 148) = 0;
  return result;
}

//----- (6F7C0A88) --------------------------------------------------------
int __stdcall ListView_OnSetBkColor(int a1, COLORREF color)
{
  int result; // eax@5
  struct _IMAGELIST *v3; // eax@7
  struct _IMAGELIST *v4; // eax@9
  struct _IMAGELIST *v5; // eax@11

  if ( *(_DWORD *)(a1 + 60) == color )
    return 1;
  if ( *(_DWORD *)(a1 + 76) )
  {
    DeleteObject(*(HGDIOBJ *)(a1 + 76));
    *(_DWORD *)(a1 + 76) = 0;
  }
  if ( color == -1 || (result = (int)CreateSolidBrush(color), (*(_DWORD *)(a1 + 76) = result) != 0) )
  {
    if ( !(*(_BYTE *)(a1 + 8) & 0x40) )
    {
      v3 = *(struct _IMAGELIST **)(a1 + 204);
      if ( v3 )
        ImageList_SetBkColor(v3, color);
      v4 = *(struct _IMAGELIST **)(a1 + 168);
      if ( v4 )
        ImageList_SetBkColor(v4, color);
      v5 = *(struct _IMAGELIST **)(a1 + 352);
      if ( v5 )
        ImageList_SetBkColor(v5, color);
    }
    *(_DWORD *)(a1 + 60) = color;
    return 1;
  }
  return result;
}

//----- (6F7C0B09) --------------------------------------------------------
BOOL __stdcall InitBrushOrg(int a1, HDC hdc)
{
  int v2; // ecx@1
  int v3; // eax@4

  v2 = *(_DWORD *)(a1 + 8) & 3;
  if ( v2 != 2 && v2 )
  {
    if ( v2 == 3 )
      v3 = *(_DWORD *)(a1 + 180);
    else
      v3 = *(_DWORD *)(a1 + 332);
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 220);
  }
  return SetBrushOrgEx(hdc, -v3, 0, 0);
}

//----- (6F7C0B54) --------------------------------------------------------
void __stdcall ListView_InvalidateRegion(int a1, HRGN hrgnSrc2)
{
  HRGN v2; // ecx@2

  if ( hrgnSrc2 )
  {
    v2 = *(HRGN *)(a1 + 148);
    if ( v2 )
    {
      if ( v2 != (HRGN)1 )
        CombineRgn(v2, v2, hrgnSrc2, 2);
      DeleteObject(hrgnSrc2);
    }
    else
    {
      *(_DWORD *)(a1 + 148) = hrgnSrc2;
    }
  }
}

//----- (6F7C0B94) --------------------------------------------------------
BOOL __stdcall LVSeeThruScroll(HDC hdc, HDC hdcSrc)
{
  HDC v2; // esi@1
  int v3; // edi@2
  int v4; // ebx@2
  HBITMAP ho; // ST30_4@4
  int x; // [sp+10h] [bp-8h]@2
  int y; // [sp+14h] [bp-4h]@2
  HDC hdca; // [sp+20h] [bp+8h]@1
  HDC hdcSrca; // [sp+24h] [bp+Ch]@4

  v2 = hdc;
  hdca = GetDC(*(HWND *)hdc);
  if ( hdcSrc )
  {
    v3 = *((_DWORD *)hdcSrc + 2) - *(_DWORD *)hdcSrc;
    x = *(_DWORD *)hdcSrc;
    y = *((_DWORD *)hdcSrc + 1);
    v4 = *((_DWORD *)hdcSrc + 3) - y;
  }
  else
  {
    y = 0;
    x = 0;
    v3 = *((_DWORD *)v2 + 30);
    v4 = *((_DWORD *)v2 + 31);
  }
  hdcSrca = CreateCompatibleDC(hdca);
  ho = CreateCompatibleBitmap(hdca, *((_DWORD *)v2 + 30), *((_DWORD *)v2 + 31));
  SelectObject(hdcSrca, ho);
  SendMessageW(*(HWND *)v2, 0x317u, (WPARAM)hdcSrca, 12);
  BitBlt(hdca, x, y, v3, v4, hdcSrca, x, y, 0xCC0020u);
  ReleaseDC(*(HWND *)v2, hdca);
  DeleteDC(hdcSrca);
  return DeleteObject(ho);
}

//----- (6F7C0C59) --------------------------------------------------------
int __stdcall ListView_DrawSimpleBackground(int a1, HDC hDC, RECT *lprc)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 60) == -1 )
    result = SendMessageW(*(HWND *)(a1 + 4), 0x14u, (WPARAM)hDC, 0);
  else
    result = FillRect(hDC, lprc, *(HBRUSH *)(a1 + 76));
  return result;
}

//----- (6F7C0C91) --------------------------------------------------------
int __stdcall ListView_DrawBackground(int a1, HDC hdc, RECT *lprect)
{
  RECT *v3; // edi@3
  HRGN v4; // eax@3
  HDC v5; // ebx@3
  int v6; // eax@12
  int v7; // ecx@19
  LONG v8; // eax@20
  int v9; // ecx@21
  LONG v10; // eax@22
  int result; // eax@27
  struct tagRECT rect; // [sp+4h] [bp-40h]@8
  struct tagRECT Rect; // [sp+14h] [bp-30h]@19
  RECT v14; // [sp+24h] [bp-20h]@19
  LONG v15; // [sp+34h] [bp-10h]@19
  LONG v16; // [sp+38h] [bp-Ch]@19
  int v17; // [sp+3Ch] [bp-8h]@12
  int v18; // [sp+40h] [bp-4h]@13

  if ( !*(_DWORD *)(a1 + 412) || !(*(_BYTE *)(a1 + 36) & 0x20) )
    return ListView_DrawSimpleBackground(a1, hdc, lprect);
  v3 = lprect;
  v4 = CreateRectRgnIndirect(lprect);
  v5 = hdc;
  lprect = (RECT *)v4;
  if ( v4 && GetClipRgn(hdc, v4) <= 0 )
  {
    DeleteObject(lprect);
    lprect = 0;
  }
  if ( v3 )
    IntersectClipRect(v5, v3->left, v3->top, v3->right, v3->bottom);
  GetClipBox(v5, &rect);
  if ( *(_DWORD *)(a1 + 412) && *(_BYTE *)(a1 + 36) & 0x20 )
  {
    if ( (*(_DWORD *)(a1 + 8) & 3) == 1 )
    {
      v17 = -*(_DWORD *)(a1 + 332);
      v6 = *(_DWORD *)(a1 + 324) - *(_DWORD *)(a1 + 336);
    }
    else
    {
      if ( (*(_DWORD *)(a1 + 8) & 3) == 3 )
      {
        v17 = -*(_DWORD *)(a1 + 180);
        v18 = 0;
        goto LABEL_16;
      }
      v17 = -*(_DWORD *)(a1 + 220);
      v6 = -*(_DWORD *)(a1 + 224);
    }
    v18 = v6;
LABEL_16:
    ListView_Realize(a1, v5, 1, 0);
    if ( *(_DWORD *)(a1 + 416) & 0x10 )
    {
      if ( (*(_DWORD *)(a1 + 416) & 0x10) == 16 )
      {
        (*(void (__stdcall **)(_DWORD, HDC, int *, RECT *, _DWORD))(**(_DWORD **)(a1 + 412) + 44))(
          *(_DWORD *)(a1 + 412),
          v5,
          &v17,
          v3,
          0);
        ExcludeClipRect(v5, v3->left, v3->top, v3->right, v3->bottom);
      }
    }
    else
    {
      (*(void (__stdcall **)(_DWORD, HDC *, int *, _DWORD))(**(_DWORD **)(a1 + 412) + 32))(
        *(_DWORD *)(a1 + 412),
        &hdc,
        &v15,
        0);
      v14.left = 0;
      v14.top = 0;
      v14.right = v15;
      v14.bottom = v16;
      GetClientRect(*(HWND *)a1, &Rect);
      v7 = *(_DWORD *)(a1 + 428);
      if ( v7 )
      {
        v8 = v7 * (Rect.right - v15) / 100;
        v14.left += v8;
        v14.right += v8;
      }
      v9 = *(_DWORD *)(a1 + 432);
      if ( v9 )
      {
        v10 = v9 * (Rect.bottom - v16) / 100;
        v14.top += v10;
        v14.bottom += v10;
      }
      v14.top += v18;
      v14.bottom += v18;
      v14.left += v17;
      v14.right += v17;
      if ( RectVisible(v5, &v14) )
      {
        (*(void (__stdcall **)(_DWORD, HDC, RECT *))(**(_DWORD **)(a1 + 412) + 40))(*(_DWORD *)(a1 + 412), v5, &v14);
        ExcludeClipRect(v5, v14.left, v14.top, v14.right, v14.bottom);
      }
    }
  }
  if ( RectVisible(v5, v3) )
    ListView_DrawSimpleBackground(a1, v5, v3);
  result = SelectClipRgn(v5, (HRGN)lprect);
  if ( lprect )
    result = DeleteObject(lprect);
  return result;
}

//----- (6F7C0EAA) --------------------------------------------------------
int __stdcall ListView_OnEraseBkgnd(int a1, HDC hdc)
{
  struct tagRECT rect; // [sp+4h] [bp-10h]@3

  if ( !(*(_DWORD *)(a1 + 48) & 0x200) || g_fSlowMachine )
  {
    GetClipBox(hdc, &rect);
    ListView_DrawBackground(a1, hdc, &rect);
  }
  return 1;
}
// 6F7E8598: using guessed type int g_fSlowMachine;

//----- (6F7C0EEF) --------------------------------------------------------
void __stdcall ListView_OnCommand(int a1, __int16 a2, HWND hWnd, int a4)
{
  if ( hWnd == *(HWND *)(a1 + 248) )
  {
    switch ( a4 )
    {
      case 40:
        *(_DWORD *)(a1 + 36) |= 1u;
        break;
      case 41:
        *(_DWORD *)(a1 + 36) &= 0xFFFFFFFE;
        break;
      case 512:
        if ( !ListView_DismissEdit(a1, 0) )
          return;
        break;
      default:
        if ( a4 == 1024 && (!g_fDBCSInputEnabled || !(*(_DWORD *)(a1 + 44) & 0x8000)) )
        {
          if ( IsWindowVisible(*(HWND *)(a1 + 248)) )
          {
            SetWindowLongW(*(HWND *)(a1 + 248), -12, 1);
            ListView_SetEditSize(a1);
          }
        }
        break;
    }
    if ( IsWindow(hWnd) )
      SendMessageW(*(HWND *)(a1 + 4), 0x111u, (unsigned __int16)a2 | ((unsigned __int16)a4 << 16), (LPARAM)hWnd);
  }
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7C0FA2) --------------------------------------------------------
signed int __stdcall GetLVKeyFlags()
{
  signed int v0; // edi@1

  v0 = 0;
  if ( GetKeyState(18) < 0 )
    v0 = 1;
  if ( GetKeyState(17) < 0 )
    v0 |= 2u;
  if ( GetKeyState(16) < 0 )
    v0 |= 4u;
  return v0;
}

//----- (6F7C0FDA) --------------------------------------------------------
BOOL __stdcall ListView_IncrementalSearch(int a1, int a2, LPARAM lParam, int a4)
{
  HWND v4; // eax@1

  *(_DWORD *)(lParam + 24) = -1;
  v4 = CCSendNotify(a1, -163, lParam);
  *(_DWORD *)a4 = *(_DWORD *)(lParam + 24);
  return v4 == (HWND)2;
}

//----- (6F7C1011) --------------------------------------------------------
HLOCAL __stdcall GET_COMP_STRING(HIMC a1, DWORD a2)
{
  LONG v2; // eax@1
  LONG v3; // esi@1
  int v4; // edi@1
  HLOCAL v5; // eax@1
  HLOCAL v6; // ebx@1

  v2 = ImmGetCompositionStringW(a1, a2, 0, 0);
  v3 = v2;
  v4 = 2 * v2;
  v5 = LocalAlloc(0x40u, 2 * v2 + 2);
  v6 = v5;
  if ( v5 )
  {
    if ( v3 )
      ImmGetCompositionStringW(a1, a2, v5, v3 + 1);
    *(_WORD *)((char *)v6 + v4) = 0;
  }
  return v6;
}

//----- (6F7C1065) --------------------------------------------------------
signed int __stdcall SameChars(int a1, __int16 a2)
{
  int v2; // ecx@1
  __int16 v3; // ax@3

  v2 = a1;
  do
  {
    v3 = *(_WORD *)v2;
    if ( !*(_WORD *)v2 )
      return 1;
    v2 += 2;
  }
  while ( v3 == a2 );
  return 0;
}

//----- (6F7C108F) --------------------------------------------------------
int __stdcall ListView_ComputeCYItemSize(int a1)
{
  int v1; // ecx@1

  v1 = *(_DWORD *)(a1 + 84);
  if ( v1 <= *(_DWORD *)(a1 + 176) )
    v1 = *(_DWORD *)(a1 + 176);
  if ( *(_DWORD *)(a1 + 352) && v1 <= *(_DWORD *)(a1 + 360) )
    v1 = *(_DWORD *)(a1 + 360);
  return v1 + g_cyBorder;
}

//----- (6F7C10CB) --------------------------------------------------------
int __stdcall ListView_InvalidateCachedLabelSizes(int a1)
{
  int i; // edi@2
  int v2; // eax@5
  int result; // eax@7

  ListView_InvalidateTTLastHit(a1, *(_DWORD *)(a1 + 156));
  if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
  {
    for ( i = *(_DWORD *)(a1 + 372); ; ListView_SetSRecompute(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * i)) )
    {
      --i;
      if ( i < 0 )
        break;
    }
  }
  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 228) = 0x7FFFFFFF;
  if ( v2 & 0x400 && (v2 & 3) == 1 )
  {
    result = ListView_ComputeCYItemSize(a1);
    *(_DWORD *)(a1 + 348) = result;
  }
  else
  {
    result = ListView_ComputeCYItemSize(a1);
    *(_DWORD *)(a1 + 188) = result;
  }
  return result;
}

//----- (6F7C1142) --------------------------------------------------------
int __stdcall ListView_OnStyleChanging(int a1, int a2, int a3)
{
  signed int v3; // edx@2
  int result; // eax@4

  if ( a2 == -16 )
  {
    v3 = 4096;
    if ( *(_DWORD *)(a1 + 48) & 0x200 )
      v3 = 4099;
    result = a3;
    *(_DWORD *)(a3 + 4) ^= v3 & (*(_DWORD *)(a3 + 4) ^ *(_DWORD *)a3);
  }
  return result;
}

//----- (6F7C117D) --------------------------------------------------------
LONG __stdcall ListView_TypeChange(HDC hdc, __int16 a2)
{
  int i; // ebx@3
  int v3; // edx@7
  int v4; // eax@8
  int v5; // eax@9
  int v6; // eax@10
  LONG result; // eax@18
  struct tagRECT Rect; // [sp+Ch] [bp-10h]@18

  if ( *((_DWORD *)hdc + 7) >= 5 && !(*((_DWORD *)hdc + 2) & 0x1000) )
  {
    for ( i = 0; i < *((_DWORD *)hdc + 93); ++i )
      ListView_SetSRecompute(*(_DWORD *)(*(_DWORD *)(*((_DWORD *)hdc + 10) + 4) + 4 * i));
  }
  if ( (a2 & 3) == 1 )
  {
    ShowWindow(*((HWND *)hdc + 80), 0);
    if ( a2 & 0x400 )
    {
      v3 = *((_DWORD *)hdc + 47);
      *((_DWORD *)hdc + 47) = *((_DWORD *)hdc + 87);
      *((_DWORD *)hdc + 87) = v3;
    }
  }
  v4 = *((_DWORD *)hdc + 2) & 3;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 == 1 )
          ListView_MaybeResizeListColumns((int)hdc, 0, *((_DWORD *)hdc + 93) - 1);
      }
      else
      {
        ListView_ScaleIconPositions(hdc, 1);
      }
    }
    else
    {
      if ( (a2 & 3) != 1 )
        *((_DWORD *)hdc + 87) = *((_DWORD *)hdc + 47);
      ListView_RInitialize((int)hdc, 0);
    }
  }
  else
  {
    ListView_ScaleIconPositions(hdc, 0);
  }
  ListView_InvalidateTTLastHit((int)hdc, *((_DWORD *)hdc + 39));
  GetClientRect(*(HWND *)hdc, &Rect);
  *((_DWORD *)hdc + 30) = Rect.right;
  result = Rect.bottom;
  *((_DWORD *)hdc + 31) = Rect.bottom;
  return result;
}

//----- (6F7C1269) --------------------------------------------------------
int __stdcall ListView_OnHitTest(HDC hdc, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // eax@3
  int v5; // ecx@3

  v2 = a2;
  if ( a2 )
  {
    v4 = *(_DWORD *)a2;
    *(_DWORD *)(a2 + 12) = -1;
    v5 = *(_DWORD *)(v2 + 4);
    a2 = 0;
    if ( v4 >= 0 )
    {
      if ( v4 >= *((_DWORD *)hdc + 30) )
        a2 = 32;
    }
    else
    {
      a2 = 64;
    }
    if ( v5 >= 0 )
    {
      if ( v5 >= *((_DWORD *)hdc + 31) )
        a2 |= 0x10u;
    }
    else
    {
      a2 |= 8u;
    }
    if ( !a2 )
      *(_DWORD *)(v2 + 12) = ((int (__stdcall *)(HDC, int, int, int))*(&pfnListView_ItemHitTest
                                                                     + (*((_DWORD *)hdc + 2) & 3)))(
                               hdc,
                               v4,
                               v5,
                               (int)&a2);
    *(_DWORD *)(v2 + 8) = a2;
    if ( *(_DWORD *)(v2 + 12) >= *((_DWORD *)hdc + 93) )
    {
      *(_DWORD *)(v2 + 12) = -1;
      *(_DWORD *)(v2 + 8) = 1;
    }
    result = *(_DWORD *)(v2 + 12);
  }
  else
  {
    result = -1;
  }
  return result;
}
// 6F79299C: using guessed type int (__stdcall *pfnListView_ItemHitTest)(int, POINT pt, int, int);

//----- (6F7C1302) --------------------------------------------------------
int __stdcall ScrollAmount(int a1, int a2, signed int a3)
{
  return a3 * ((a1 - a2 + a3 - 1) / a3);
}

//----- (6F7C1323) --------------------------------------------------------
bool __stdcall CanScroll(int a1, int code, int a3)
{
  bool v3; // zf@1
  BOOL v4; // eax@2
  bool result; // al@8
  HWND v6; // [sp-Ch] [bp-28h]@1
  struct tagSCROLLINFO v7; // [sp+0h] [bp-1Ch]@1

  v3 = (*(_DWORD *)(a1 + 48) & 0x100) == 0;
  v7.cbSize = 28;
  v6 = *(HWND *)a1;
  v7.fMask = 7;
  if ( v3 )
    v4 = GetScrollInfo(v6, code, &v7);
  else
    v4 = FlatSB_GetScrollInfo(v6, code, &v7);
  if ( v4 )
  {
    if ( a3 )
    {
      if ( v7.nPage )
        v7.nMax += 1 - v7.nPage;
      result = v7.nPos < v7.nMax;
    }
    else
    {
      result = v7.nPos > v7.nMin;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C1399) --------------------------------------------------------
int __stdcall OrderRect(int a1)
{
  int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // ecx@3
  int v5; // edx@3

  result = a1;
  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)a1 > v3 )
  {
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 8) = v2;
  }
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a1 + 4);
  if ( v4 < v5 )
  {
    *(_DWORD *)(a1 + 12) = v5;
    *(_DWORD *)(a1 + 4) = v4;
  }
  return result;
}

//----- (6F7C13C8) --------------------------------------------------------
signed int __stdcall ShouldScroll(int a1, int a2, int a3)
{
  int v3; // eax@2
  int v4; // eax@3
  int v6; // eax@10

  if ( *(_DWORD *)(a1 + 8) & 0x200000 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    if ( v3 < *(_DWORD *)(a3 + 12) )
    {
      if ( v3 > *(_DWORD *)(a3 + 4) )
        goto LABEL_8;
      LOBYTE(v4) = CanScroll(a1, 1, 0);
    }
    else
    {
      LOBYTE(v4) = CanScroll(a1, 1, 1);
    }
    if ( v4 )
      return 1;
  }
LABEL_8:
  if ( *(_DWORD *)(a1 + 8) & 0x100000 )
  {
    if ( *(_DWORD *)a2 < *(_DWORD *)(a3 + 8) )
    {
      if ( *(_DWORD *)a2 > *(_DWORD *)a3 )
        return 0;
      LOBYTE(v6) = CanScroll(a1, 0, 0);
    }
    else
    {
      LOBYTE(v6) = CanScroll(a1, 0, 1);
    }
    if ( v6 )
      return 1;
  }
  return 0;
}

//----- (6F7C143A) --------------------------------------------------------
int __stdcall ListView_RBeginMarquee(int a1, int a2, int a3, int a4)
{
  int v4; // eax@2
  int result; // eax@7

  result = 0;
  if ( *(_BYTE *)(a1 + 48) & 0x20 )
  {
    v4 = *(_DWORD *)(a1 + 8);
    if ( (v4 & 3) == 1 && !(v4 & 4) && !(v4 & 0x400) && !*(_DWORD *)(a4 + 16) && *(_DWORD *)(a4 + 8) == 14 )
      result = 1;
  }
  return result;
}

//----- (6F7C147F) --------------------------------------------------------
int __stdcall ListView_CancelPendingTimer(int a1, int a2, UINT_PTR uIDEvent)
{
  int result; // eax@2

  if ( a2 & *(_DWORD *)(a1 + 44) )
  {
    KillTimer(*(HWND *)a1, uIDEvent);
    *(_DWORD *)(a1 + 44) &= ~a2;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C14B3) --------------------------------------------------------
UINT_PTR __stdcall ListView_SetupPendingNameEdit(int a1)
{
  UINT v1; // eax@1
  UINT_PTR result; // eax@1

  v1 = GetDoubleClickTime();
  result = SetTimer(*(HWND *)a1, 0x2Au, v1, 0);
  *(_DWORD *)(a1 + 44) |= 8u;
  return result;
}

//----- (6F7C14DD) --------------------------------------------------------
int __stdcall ListView_OnHVScroll(int hdc, int a2, int a3, int code)
{
  bool v4; // zf@1
  BOOL v5; // eax@2
  int v6; // edi@4
  int result; // eax@6
  signed int v8; // ecx@10
  int v9; // ecx@11
  signed int v10; // ecx@12
  HWND v11; // [sp-Ch] [bp-30h]@1
  struct tagSCROLLINFO v12; // [sp+8h] [bp-1Ch]@1

  v4 = (*(_DWORD *)(hdc + 48) & 0x100) == 0;
  v12.cbSize = 28;
  v11 = *(HWND *)hdc;
  v12.fMask = 16;
  if ( v4 )
    v5 = GetScrollInfo(v11, code, &v12);
  else
    v5 = FlatSB_GetScrollInfo(v11, code, &v12);
  v6 = v12.nTrackPos;
  if ( !v5 )
    v6 = a3;
  ListView_DismissEdit(hdc, 0);
  result = pfnListView_OnScroll[*(_DWORD *)(hdc + 8) & 3]((HDC)hdc, a2, v6, code);
  if ( (unsigned int)a2 <= 1 )
  {
    result = hdc + 308;
    v10 = *(_DWORD *)(hdc + 308);
    if ( v10 >= 10 )
      return result;
    v9 = v10 + 1;
    goto LABEL_14;
  }
  if ( (unsigned int)a2 <= 3 )
  {
    result = hdc + 308;
    v8 = *(_DWORD *)(hdc + 308);
    if ( v8 >= 10 )
      return result;
    v9 = v8 + 3;
LABEL_14:
    *(_DWORD *)result = v9;
    return result;
  }
  if ( a2 == 8 )
    *(_DWORD *)(hdc + 308) = 0;
  return result;
}
// 6F7C1580: using guessed type int (__stdcall *pfnListView_OnScroll[4])(HDC hdc, int, int, int code);

//----- (6F7C1595) --------------------------------------------------------
int __stdcall ListView_OnVScroll(int a1, int a2, int a3, int a4)
{
  return ListView_OnHVScroll(a1, a3, a4, 1);
}

//----- (6F7C15B3) --------------------------------------------------------
int __stdcall ListView_OnHScroll(int a1, int a2, int a3, int a4)
{
  return ListView_OnHVScroll(a1, a3, a4, 0);
}

//----- (6F7C15D1) --------------------------------------------------------
int __stdcall ListView_ValidateOneScrollParam(int a1, int code, int a3)
{
  bool v3; // zf@1
  int result; // eax@2
  UINT v5; // ecx@5
  int v6; // esi@5
  HWND v7; // [sp-Ch] [bp-28h]@1
  struct tagSCROLLINFO v8; // [sp+0h] [bp-1Ch]@1

  v3 = (*(_DWORD *)(a1 + 48) & 0x100) == 0;
  v8.cbSize = 28;
  v7 = *(HWND *)a1;
  v8.fMask = 7;
  if ( v3 )
    result = GetScrollInfo(v7, code, &v8);
  else
    result = FlatSB_GetScrollInfo(v7, code, &v8);
  if ( result )
  {
    v5 = 1 - v8.nPage + v8.nMax;
    result = a3;
    v6 = a3 + v8.nPos;
    if ( a3 + v8.nPos >= v8.nMin )
    {
      if ( v6 > (signed int)v5 )
        result = v5 - v6 + a3;
    }
    else
    {
      result = v8.nMin - v6 + a3;
    }
  }
  return result;
}

//----- (6F7C1640) --------------------------------------------------------
signed int __stdcall ListView_ValidateScrollParams(int a1, int *a2, int *a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@1
  int v7; // eax@3
  signed int v8; // ecx@4
  signed int v9; // eax@5
  signed int v10; // eax@11
  int v11; // eax@15
  int v12; // eax@19

  v3 = *a2;
  v4 = *a3;
  v5 = *(_DWORD *)(a1 + 8);
  if ( v5 & 0x2000 )
    return 0;
  v7 = v5 & 3;
  if ( v7 == 3 )
  {
    ListView_MaybeResizeListColumns(a1, 0, *(_DWORD *)(a1 + 372) - 1);
    v8 = *(_DWORD *)(a1 + 184);
    if ( v3 >= 0 )
      v9 = v8 + v3 - 1;
    else
      v9 = v3 - v8 - 1;
    v3 = v9 / v8;
    if ( v4 )
      return 0;
  }
  else
  {
    if ( v7 == 1 )
    {
      if ( v4 <= 0 )
        v10 = v4 - *(_DWORD *)(a1 + 188) / 2;
      else
        v10 = v4 + *(_DWORD *)(a1 + 188) / 2;
      v4 = v10 / *(_DWORD *)(a1 + 188);
    }
    if ( v4 )
    {
      v11 = ListView_ValidateOneScrollParam(a1, 1, v4);
      if ( (*(_DWORD *)(a1 + 8) & 3) == 1 )
        v11 *= *(_DWORD *)(a1 + 188);
      *a3 = v11;
    }
  }
  if ( v3 )
  {
    v12 = ListView_ValidateOneScrollParam(a1, 0, v3);
    if ( (*(_BYTE *)(a1 + 8) & 3) == 3 )
      v12 *= *(_DWORD *)(a1 + 184);
    *a2 = v12;
  }
  return 1;
}

//----- (6F7C1720) --------------------------------------------------------
int __stdcall ListView_OnGetImageList(int a1, int a2)
{
  int result; // eax@4

  if ( a2 )
  {
    if ( a2 == 1 )
    {
      result = *(_DWORD *)(a1 + 168);
    }
    else if ( a2 == 2 )
    {
      result = *(_DWORD *)(a1 + 352);
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = *(_DWORD *)(a1 + 204);
  }
  return result;
}

//----- (6F7C175F) --------------------------------------------------------
int __stdcall ListView_OnSetImageList(int a1, HIMAGELIST himl, int a3)
{
  int v3; // ebx@1
  HWND v4; // eax@10

  v3 = 0;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v3 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)(a1 + 168) = himl;
      if ( himl )
        ImageList_GetIconSize(himl, (int *)(a1 + 172), (int *)(a1 + 176));
      *(_DWORD *)(a1 + 184) = *(_DWORD *)(a1 + 172) + 16 * *(_DWORD *)(a1 + 88);
      *(_DWORD *)(a1 + 188) = ListView_ComputeCYItemSize(a1);
      v4 = *(HWND *)(a1 + 320);
      if ( v4 )
        SendMessageW(v4, 0x1208u, 0, (LPARAM)himl);
    }
    else if ( a3 == 2 )
    {
      if ( himl )
        ImageList_GetIconSize(himl, (int *)(a1 + 356), (int *)(a1 + 360));
      else
        *(_DWORD *)(a1 + 356) = 0;
      v3 = *(_DWORD *)(a1 + 352);
      *(_DWORD *)(a1 + 352) = himl;
      *(_DWORD *)(a1 + 188) = ListView_ComputeCYItemSize(a1);
    }
  }
  else
  {
    v3 = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 204) = himl;
    if ( !himl )
      goto LABEL_18;
    ImageList_GetIconSize(himl, (int *)(a1 + 208), (int *)(a1 + 212));
    if ( !(*(_DWORD *)(a1 + 44) & 0x1000) )
      ListView_OnSetIconSpacing(a1, -1);
  }
  if ( himl && !(*(_BYTE *)(a1 + 8) & 0x40) )
    ImageList_SetBkColor(himl, *(_DWORD *)(a1 + 60));
LABEL_18:
  if ( *(_DWORD *)(a1 + 372) > 0 )
    InvalidateRect(*(HWND *)a1, 0, 1);
  return v3;
}

//----- (6F7C1883) --------------------------------------------------------
signed int __userpurge ListView_OnGetItem@<eax>(int a1@<edi>, HDPA hdpa, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  INT_PTR v6; // ecx@3
  bool v7; // zf@4
  int v8; // edx@4
  int v9; // eax@5
  int v10; // eax@17
  int v11; // ecx@30
  int v12; // eax@30
  int v13; // eax@35
  int v14; // ST10_4@48
  int v15; // eax@53
  int v16; // ecx@66
  int v17; // eax@66
  char v18; // cl@69
  STRSAFE_LPCWSTR v19; // eax@77
  LPARAM lParam; // [sp+8h] [bp-3Ch]@69
  INT_PTR i; // [sp+14h] [bp-30h]@4
  int v22; // [sp+18h] [bp-2Ch]@61
  int v23; // [sp+1Ch] [bp-28h]@61
  int v24; // [sp+20h] [bp-24h]@32
  int v25; // [sp+24h] [bp-20h]@31
  LPCWSTR lpString; // [sp+28h] [bp-1Ch]@66
  int v27; // [sp+2Ch] [bp-18h]@66
  int v28; // [sp+30h] [bp-14h]@64
  int v29; // [sp+34h] [bp-10h]@62
  int v30; // [sp+38h] [bp-Ch]@64
  LPCWSTR v31; // [sp+3Ch] [bp-8h]@6
  __int16 v32; // [sp+40h] [bp-4h]@12
  unsigned __int16 v33; // [sp+42h] [bp-2h]@16
  int v34; // [sp+50h] [bp+Ch]@4

  v3 = a3;
  v4 = 0;
  if ( !a3 )
    return 0;
  v6 = *(_DWORD *)(a3 + 4);
  if ( (unsigned int)v6 >= *((_DWORD *)hdpa + 93) )
    return 0;
  v7 = (*((_DWORD *)hdpa + 2) & 0x1000) == 0;
  v8 = *(_DWORD *)a3;
  i = 0;
  v34 = v8;
  if ( v7 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)hdpa + 10) + 4) + 4 * v6);
    v9 = *(_DWORD *)(v3 + 8);
    if ( v9 )
    {
      ListView_GetSubItem((int)hdpa, v6, v9, (int)&v31);
      if ( v34 & 1 )
      {
        if ( v31 == (LPCWSTR)-1 )
          i |= 1u;
        else
          Str_GetPtrW(v31, *(void **)(v3 + 20), *(_DWORD *)(v3 + 24));
      }
      if ( v34 & 2 )
      {
        if ( *((_BYTE *)hdpa + 48) & 2 )
        {
          v7 = v32 == -1;
          *(_DWORD *)(v3 + 28) = v32;
          if ( v7 )
            i |= 2u;
        }
      }
      if ( !(v34 & 8) )
        goto LABEL_33;
      if ( *((_BYTE *)hdpa + 48) & 0x20 )
        v33 |= *(_WORD *)(v4 + 24) & 0xB;
      v10 = v33;
    }
    else
    {
      if ( v8 & 1 )
      {
        if ( *(_DWORD *)v4 == -1 )
          i = 1;
        else
          Str_GetPtrW(*(LPCWSTR *)v4, *(void **)(v3 + 20), *(_DWORD *)(v3 + 24));
      }
      if ( v34 & 2 )
      {
        *(_DWORD *)(v3 + 28) = *(_WORD *)(v4 + 12);
        if ( *(_WORD *)(v4 + 12) == -1 )
          i |= 2u;
      }
      if ( v34 & 0x10 )
      {
        *(_DWORD *)(v3 + 36) = *(_WORD *)(v4 + 26);
        if ( *(_WORD *)(v4 + 26) == -1 )
          i |= 0x10u;
      }
      if ( !(v34 & 8) )
        goto LABEL_33;
      v10 = *(_WORD *)(v4 + 24);
    }
    v11 = *(_DWORD *)(v3 + 16);
    *(_DWORD *)(v3 + 12) = v11 & v10;
    v12 = *((_DWORD *)hdpa + 29);
    if ( v12 )
    {
      v25 = v11 & v12;
      if ( v11 & v12 )
      {
        i |= 8u;
        v24 = 0;
      }
    }
LABEL_33:
    if ( v34 & 4 )
      *(_DWORD *)(v3 + 32) = *(_DWORD *)(v4 + 28);
    goto LABEL_57;
  }
  v13 = *(_DWORD *)(v3 + 8);
  if ( v13 )
  {
    if ( !(*((_BYTE *)hdpa + 48) & 2) )
      v8 &= 0xFFFFFFFD;
    v8 &= 0xFFFFFFEF;
    v34 = v8;
  }
  if ( v8 & 4 )
    *(_DWORD *)(v3 + 32) = 0;
  if ( v8 & 8 )
  {
    *(_DWORD *)(v3 + 12) = 0;
    if ( !v13 || *((_BYTE *)hdpa + 48) & 0x20 )
    {
      if ( v6 == *((_DWORD *)hdpa + 25) )
        *(_DWORD *)(v3 + 12) = 1;
      if ( !(*(int (__stdcall **)(_DWORD, INT_PTR, int))(**((_DWORD **)hdpa + 91) + 36))(*((_DWORD *)hdpa + 91), v6, a1) )
        *(_DWORD *)(v3 + 12) |= 2u;
      v14 = *(_DWORD *)(v3 + 4);
      if ( !(*(int (__stdcall **)(_DWORD))(**((_DWORD **)hdpa + 92) + 36))(*((_DWORD *)hdpa + 92)) )
        *(_DWORD *)(v3 + 12) |= 4u;
      if ( *(_DWORD *)(v3 + 4) == *((_DWORD *)hdpa + 94) )
        *(_DWORD *)(v3 + 12) |= 8u;
      *(_DWORD *)(v3 + 12) &= *(_DWORD *)(v3 + 16);
    }
    v15 = *((_DWORD *)hdpa + 29);
    if ( v15 )
    {
      v25 = v15 & *(_DWORD *)(v3 + 16);
      if ( v25 )
      {
        i |= 8u;
        v24 = 0;
      }
    }
  }
  i |= v34 & 0x13;
LABEL_57:
  if ( !(v34 & 0x800) )
  {
    if ( !i )
      return 1;
    v7 = (*((_DWORD *)hdpa + 2) & 0x1000) == 0;
    v22 = *(_DWORD *)(v3 + 4);
    v23 = *(_DWORD *)(v3 + 8);
    if ( v7 )
      v29 = *(_DWORD *)(v4 + 28);
    else
      v29 = 0;
    v28 = -1;
    v30 = 0;
    if ( i & 1 )
    {
      if ( *(_DWORD *)(v3 + 20) )
      {
        v16 = *(_DWORD *)(v3 + 20);
        v17 = *(_DWORD *)(v3 + 24);
        lpString = *(LPCWSTR *)(v3 + 20);
        v27 = v17;
        if ( v17 )
          *(_WORD *)v16 = 0;
      }
      else
      {
        i &= 0xFFFFFFFE;
      }
    }
    CCSendNotify((int)hdpa, -177, (LPARAM)&lParam);
    v18 = i;
    if ( i & 0x10 )
      *(_DWORD *)(v3 + 36) = v30;
    if ( v18 & 8 )
      *(_DWORD *)(v3 + 12) ^= v25 & (v24 ^ *(_DWORD *)(v3 + 12));
    if ( v18 & 2 )
      *(_DWORD *)(v3 + 28) = v28;
    if ( v18 & 1 )
    {
      if ( v34 & 1 )
        v19 = CCReturnDispInfoText(lpString, *(STRSAFE_LPWSTR *)(v3 + 20), *(_DWORD *)(v3 + 24));
      else
        v19 = lpString;
      *(_DWORD *)(v3 + 20) = v19;
    }
    if ( !v4 || !(i & 0x1000) )
      return 1;
    if ( (PVOID)v4 == DPA_GetPtr(*((HDPA *)hdpa + 10), *(_DWORD *)(v3 + 4)) )
    {
      if ( v23 )
      {
        ListView_SetSubItem(hdpa, (INT_PTR)&i);
      }
      else
      {
        if ( i & 2 )
          *(_WORD *)(v4 + 12) = v28;
        if ( i & 0x10 )
          *(_WORD *)(v4 + 26) = v30;
        if ( i & 1 && lpString )
          Str_Set(v4, lpString);
        if ( i & 8 )
          *(_WORD *)(v4 + 24) ^= (unsigned __int16)v25 & (unsigned __int16)(v24 ^ *(_WORD *)(v4 + 24));
      }
      return 1;
    }
    return 0;
  }
  if ( i & 1 )
    *(_DWORD *)(v3 + 20) = -1;
  return 1;
}
// 6F7C1883: could not find valid save-restore pair for edi

//----- (6F7C1BCB) --------------------------------------------------------
int __userpurge ListView_OnGetItemState@<eax>(int a1@<edi>, struct _DPA *a2, int a3, int a4)
{
  signed int v4; // eax@1
  int v6; // [sp+0h] [bp-28h]@1
  int v7; // [sp+4h] [bp-24h]@1
  int v8; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@1

  v8 = 0;
  v10 = a4;
  v7 = a3;
  v6 = 8;
  v4 = ListView_OnGetItem(a1, a2, (int)&v6);
  return v4 != 0 ? v9 : 0;
}

//----- (6F7C1C06) --------------------------------------------------------
int __userpurge ListView_OnGetItemText@<eax>(int a1@<edi>, struct _DPA *a2, int a3, int a4)
{
  int result; // eax@2

  if ( a4 && (*(_DWORD *)a4 = 1, *(_DWORD *)(a4 + 4) = a3, ListView_OnGetItem(a1, a2, a4)) )
    result = lstrlenW(*(LPCWSTR *)(a4 + 20));
  else
    result = 0;
  return result;
}

//----- (6F7C1C43) --------------------------------------------------------
int __stdcall ImgCtxCallback(int a1, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  char v4; // [sp+4h] [bp-8h]@1

  v2 = a2;
  result = (*(int (__stdcall **)(_DWORD, int *, char *, signed int))(**(_DWORD **)(a2 + 412) + 32))(
             *(_DWORD *)(a2 + 412),
             &a2,
             &v4,
             1);
  if ( a2 & 0xC00000 )
  {
    *(_DWORD *)(v2 + 36) &= 0xFFFFFFDF;
  }
  else if ( a2 & 4 )
  {
    *(_DWORD *)(v2 + 36) |= 0x20u;
    result = InvalidateRect(*(HWND *)v2, 0, 1);
  }
  return result;
}

//----- (6F7C1C93) --------------------------------------------------------
HLOCAL __stdcall ListView_ReleaseBkImage(int a1)
{
  int v1; // eax@1
  HLOCAL *v2; // esi@6
  HLOCAL result; // eax@6

  v1 = *(_DWORD *)(a1 + 412);
  if ( v1 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v1 + 8))(*(_DWORD *)(a1 + 412));
    *(_DWORD *)(a1 + 412) = 0;
    if ( *(_DWORD *)(a1 + 436) )
      *(_DWORD *)(a1 + 436) = 0;
  }
  if ( *(_DWORD *)(a1 + 420) )
  {
    DeleteObject(*(HGDIOBJ *)(a1 + 420));
    *(_DWORD *)(a1 + 420) = 0;
  }
  v2 = (HLOCAL *)(a1 + 424);
  result = *(HLOCAL *)(a1 + 424);
  if ( *(_DWORD *)(a1 + 424) )
  {
    result = LocalFree(*v2);
    *v2 = 0;
  }
  return result;
}

//----- (6F7C1CF6) --------------------------------------------------------
signed int __stdcall ListView_OnGetBkImageA(int a1, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@2
  int v4; // ecx@3
  CHAR *v5; // ecx@5

  result = 0;
  if ( a2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 416);
    v3 = *(_DWORD *)(a1 + 416) & 3;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          goto LABEL_9;
        v5 = *(CHAR **)(a2 + 8);
        if ( !v5 )
          goto LABEL_9;
        WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, *(LPCWSTR *)(a1 + 424), -1, v5, *(_DWORD *)(a2 + 12), 0, 0);
      }
      else
      {
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 420);
      }
    }
    result = 1;
LABEL_9:
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 428);
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 432);
  }
  return result;
}

//----- (6F7C1D6C) --------------------------------------------------------
HLOCAL __stdcall ListView_FreeSubItem(HLOCAL hMem)
{
  HLOCAL result; // eax@2

  if ( hMem )
  {
    Str_Set((int)hMem, 0);
    result = LocalFree(hMem);
  }
  return result;
}

//----- (6F7C1D91) --------------------------------------------------------
int __stdcall ListView_GetCxScrollbar(int a1)
{
  int result; // eax@3

  if ( *(_DWORD *)(a1 + 48) & 0x100 && FlatSB_GetScrollProp(*(HWND *)a1, 8, &a1) )
    result = a1;
  else
    result = g_cxScrollbar;
  return result;
}
// 6F7E6970: using guessed type int g_cxScrollbar;

//----- (6F7C1DC6) --------------------------------------------------------
int __stdcall ListView_GetCyScrollbar(int a1)
{
  int result; // eax@3

  if ( *(_DWORD *)(a1 + 48) & 0x100 && FlatSB_GetScrollProp(*(HWND *)a1, 4, &a1) )
    result = a1;
  else
    result = g_cyScrollbar;
  return result;
}
// 6F7E696C: using guessed type int g_cyScrollbar;

//----- (6F7C1DFB) --------------------------------------------------------
int __stdcall ListView_GetWindowStyle(int a1)
{
  HWND *v1; // esi@1

  v1 = (HWND *)a1;
  if ( !(*(_DWORD *)(a1 + 48) & 0x100) || !FlatSB_GetScrollProp(*(HWND *)a1, 1024, &a1) )
    a1 = GetWindowLongW(*v1, -16);
  return a1;
}

//----- (6F7C1E3B) --------------------------------------------------------
BOOL __stdcall ListView_SetScrollInfo(int a1, int code, LPSCROLLINFO psi, BOOL fRedraw)
{
  int v4; // eax@2
  int v5; // eax@5
  BOOL v6; // eax@7
  HWND v8; // [sp-10h] [bp-1Ch]@1
  HWND v9; // [sp-Ch] [bp-18h]@9
  BOOL fRedrawa; // [sp+20h] [bp+14h]@4

  v8 = *(HWND *)a1;
  if ( *(_DWORD *)(a1 + 48) & 0x100 )
    v4 = FlatSB_SetScrollInfo(v8, code, psi, fRedraw);
  else
    v4 = SetScrollInfo(v8, code, psi, fRedraw);
  fRedrawa = v4;
  if ( (psi->fMask & 3) == 3 )
  {
    v5 = psi->nMax;
    v6 = v5 && (signed int)psi->nPage <= v5;
    v9 = *(HWND *)a1;
    if ( *(_DWORD *)(a1 + 48) & 0x100 )
      FlatSB_ShowScrollBar(v9, code, v6);
    else
      ShowScrollBar(v9, code, v6);
  }
  return fRedrawa;
}

//----- (6F7C1EB0) --------------------------------------------------------
int __stdcall ListView_FreeItem(int a1, LPVOID lpMem)
{
  int v2; // eax@2

  if ( lpMem )
  {
    Str_Set((int)lpMem, 0);
    v2 = *((_DWORD *)lpMem + 8);
    if ( v2 && v2 != -1 )
      DeleteObject(*((HGDIOBJ *)lpMem + 8));
    HeapFree(*(HANDLE *)(a1 + 80), 0, lpMem);
  }
  return 0;
}

//----- (6F7C1EF3) --------------------------------------------------------
int __stdcall ListView_CompareString(int a1, int a2, LPCWSTR lpString2, char a4, int a5)
{
  int result; // eax@2
  int v6; // eax@3
  int v7; // [sp+8h] [bp-234h]@1
  int v8; // [sp+Ch] [bp-230h]@1
  int v9; // [sp+10h] [bp-22Ch]@1
  LPCWSTR lpString1; // [sp+1Ch] [bp-220h]@1
  int v11; // [sp+20h] [bp-21Ch]@1
  __int16 v12; // [sp+30h] [bp-20Ch]@1
  char Dst; // [sp+32h] [bp-20Ah]@1

  v12 = 0;
  memset(&Dst, 0, 0x206u);
  v9 = 0;
  v8 = a2;
  lpString1 = (LPCWSTR)&v12;
  v7 = 1;
  v11 = 260;
  ListView_OnGetItem(a1, (HDPA)a1, (int)&v7);
  if ( a4 & 0xC )
  {
    v6 = lstrlenW(lpString2);
    if ( a5 && v6 > a5 )
      v6 = a5;
    if ( IntlStrEqWorkerW(0, lpString1, lpString2, v6) )
      result = 0;
    else
      result = lstrcmpW(lpString1, lpString2);
  }
  else
  {
    result = lstrcmpiW(lpString1, lpString2);
  }
  return result;
}

//----- (6F7C1FCD) --------------------------------------------------------
int __stdcall ListView_GetRects(int a1, int a2, int lprcSrc1, int lprcSrc2, LPRECT lprcDst, LPRECT a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int result; // eax@2
  int v9; // edi@11
  int v10; // edi@13
  int v11; // edi@20
  char v12; // [sp+4h] [bp-5Ch]@7
  RECT rcSrc1; // [sp+40h] [bp-20h]@6
  RECT rcSrc2; // [sp+50h] [bp-10h]@6

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 8) & 3;
  if ( v7 == 1 )
  {
    result = ListView_RGetRects(a1, a2, lprcSrc1, lprcSrc2, (int)lprcDst, (int)a6);
  }
  else if ( v7 == 3 )
  {
    result = ListView_LGetRects((HDC)a1, a2, lprcSrc1, lprcSrc2, (int)lprcDst, (int)a6);
  }
  else if ( v6 & 0x1000 )
  {
    rcSrc1.left = 0;
    rcSrc1.top = 0;
    rcSrc1.right = 0;
    rcSrc1.bottom = 0;
    result = 0;
    rcSrc2.left = 0;
    rcSrc2.top = 0;
    rcSrc2.right = 0;
    rcSrc2.bottom = 0;
    if ( v7 )
    {
      if ( v7 == 2 )
        result = ListView_SGetRectsOwnerData(a1, a2, (int)&rcSrc1, (int)&rcSrc2, (int)&v12, 0);
    }
    else
    {
      result = ListView_IGetRectsOwnerData(a1, a2, (int)&rcSrc1, (int)&rcSrc2, (int)&v12, 0);
    }
    if ( lprcSrc1 )
    {
      *(_DWORD *)lprcSrc1 = rcSrc1.left;
      *(_DWORD *)(lprcSrc1 + 4) = rcSrc1.top;
      v9 = lprcSrc1 + 8;
      *(_DWORD *)v9 = rcSrc1.right;
      *(_DWORD *)(v9 + 4) = rcSrc1.bottom;
    }
    if ( lprcSrc2 )
    {
      *(_DWORD *)lprcSrc2 = rcSrc2.left;
      *(_DWORD *)(lprcSrc2 + 4) = rcSrc2.top;
      v10 = lprcSrc2 + 8;
      *(_DWORD *)v10 = rcSrc2.right;
      *(_DWORD *)(v10 + 4) = rcSrc2.bottom;
    }
    if ( lprcDst )
      result = UnionRect(lprcDst, &rcSrc1, &rcSrc2);
    if ( a6 )
      result = UnionRect(a6, &rcSrc1, &rcSrc2);
  }
  else
  {
    result = a2;
    if ( a2 >= 0 && a2 < *(_DWORD *)(a1 + 372) )
    {
      v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * a2);
      if ( *(_WORD *)(v11 + 18) == 0x7FFF )
        ListView_RecomputeLabelSize(a1, v11, a2, 0, 0);
      result = _ListView_GetRectsFromItem(
                 a1,
                 (*(_DWORD *)(a1 + 8) & 3) == 2,
                 v11,
                 (RECT *)lprcSrc1,
                 (RECT *)lprcSrc2,
                 lprcDst,
                 a6);
    }
  }
  return result;
}

//----- (6F7C211C) --------------------------------------------------------
int __stdcall ListView_GetRectsOwnerData(int a1, int a2, int a3, int a4, LPRECT lprcDst, LPRECT a6, int a7)
{
  int v7; // ecx@1
  int result; // eax@2
  int v9; // edi@10
  int v10; // edi@12
  RECT rcSrc1; // [sp+0h] [bp-20h]@5
  RECT rcSrc2; // [sp+10h] [bp-10h]@5

  v7 = *(_DWORD *)(a1 + 8) & 3;
  if ( v7 == 1 )
  {
    result = ListView_RGetRects(a1, a2, a3, a4, (int)lprcDst, (int)a6);
  }
  else if ( v7 == 3 )
  {
    result = ListView_LGetRects((HDC)a1, a2, a3, a4, (int)lprcDst, (int)a6);
  }
  else
  {
    rcSrc1.left = 0;
    rcSrc2.left = 0;
    rcSrc1.top = 0;
    rcSrc1.right = 0;
    rcSrc1.bottom = 0;
    result = 0;
    rcSrc2.top = 0;
    rcSrc2.right = 0;
    rcSrc2.bottom = 0;
    if ( v7 )
    {
      if ( v7 == 2 )
        result = ListView_SGetRectsOwnerData(a1, a2, (int)&rcSrc1, (int)&rcSrc2, a7, 1);
    }
    else
    {
      result = ListView_IGetRectsOwnerData(a1, a2, (int)&rcSrc1, (int)&rcSrc2, a7, 1);
    }
    if ( a3 )
    {
      *(_DWORD *)a3 = rcSrc1.left;
      *(_DWORD *)(a3 + 4) = rcSrc1.top;
      v9 = a3 + 8;
      *(_DWORD *)v9 = rcSrc1.right;
      *(_DWORD *)(v9 + 4) = rcSrc1.bottom;
    }
    if ( a4 )
    {
      *(_DWORD *)a4 = rcSrc2.left;
      *(_DWORD *)(a4 + 4) = rcSrc2.top;
      v10 = a4 + 8;
      *(_DWORD *)v10 = rcSrc2.right;
      *(_DWORD *)(v10 + 4) = rcSrc2.bottom;
    }
    if ( lprcDst )
      result = UnionRect(lprcDst, &rcSrc1, &rcSrc2);
    if ( a6 )
      result = UnionRect(a6, &rcSrc1, &rcSrc2);
  }
  return result;
}

//----- (6F7C220F) --------------------------------------------------------
void __stdcall ListView_InvalidateItemEx(int a1, int a2, int a3, UINT flags, int a5)
{
  int v5; // eax@2
  int v6; // edi@2
  struct tagRECT *v7; // edx@2
  int v8; // ecx@2
  int v9; // eax@17
  int v10; // eax@26
  HRGN v11; // eax@32
  struct tagRECT rc; // [sp+0h] [bp-14h]@11
  LPRECT v13; // [sp+10h] [bp-4h]@2

  if ( a2 == -1 )
    return;
  v5 = *(_DWORD *)(a1 + 8);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v13 = 0;
  if ( v5 & 0x1000 && *(_DWORD *)(a1 + 44) & 0x2000 && !(*(_BYTE *)(a1 + 48) & 0x20) )
    a3 = 0;
  if ( v5 & 0x400 )
    a3 = 0;
  if ( a3 )
  {
    if ( (v5 & 3) != 1 || *(_BYTE *)(a1 + 48) & 0x20 )
    {
      v13 = &rc;
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  if ( a5 == 1 )
  {
LABEL_16:
    v8 = (int)&rc;
    goto LABEL_17;
  }
  if ( a5 == 2 )
    v6 = (int)&rc;
  else
    v7 = &rc;
LABEL_17:
  v9 = *(_DWORD *)(a1 + 44);
  if ( (v9 & 0x12) == 18 )
  {
    ListView_GetRects(a1, a2, v6, v8, v7, v13);
    if ( *(_DWORD *)(a1 + 120) > rc.left && rc.right > 0 && *(_DWORD *)(a1 + 124) > rc.top && rc.bottom > 0 )
    {
      if ( *(_DWORD *)(a1 + 48) & 0x8000 )
        InflateRect(&rc, g_cxIconMargin + 4, g_cyIconMargin + 4);
      RedrawWindow(*(HWND *)a1, &rc, 0, flags);
    }
  }
  else if ( !(v9 & 0x10) )
  {
    v10 = *(_DWORD *)(a1 + 112);
    if ( v10 == -1 || a2 < v10 )
    {
      ListView_GetRects(a1, a2, v6, v8, v7, v13);
      if ( *(_DWORD *)(a1 + 120) > rc.left && rc.right > 0 && *(_DWORD *)(a1 + 124) > rc.top && rc.bottom > 0 )
      {
        v11 = CreateRectRgnIndirect(&rc);
        ListView_InvalidateRegion(a1, v11);
        if ( flags & 4 )
          *(_DWORD *)(a1 + 44) |= 4u;
      }
    }
  }
}
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7C2367) --------------------------------------------------------
signed int __stdcall LV_IsItemOnViewEdge(int a1, int a2)
{
  int v2; // ebx@1
  LONG v3; // edi@1
  LONG v4; // esi@1
  signed int result; // eax@2
  LONG v6; // [sp+Ch] [bp-20h]@1
  LONG v7; // [sp+10h] [bp-1Ch]@1
  struct tagRECT rc; // [sp+1Ch] [bp-10h]@1

  v2 = a1;
  v6 = *(_DWORD *)(a1 + 228);
  v7 = *(_DWORD *)(a1 + 232);
  v3 = *(_DWORD *)(a1 + 240) - g_cyEdge;
  v4 = *(_DWORD *)(a1 + 236) - g_cxEdge;
  _ListView_GetRectsFromItem(v2, (*(_DWORD *)(v2 + 8) & 3) == 2, a2, 0, 0, &rc, 0);
  OffsetRect(&rc, *(_DWORD *)(v2 + 220), *(_DWORD *)(v2 + 224));
  if ( rc.right < v4 )
    result = 0;
  else
    result = 4;
  if ( rc.left <= v6 )
    result |= 1u;
  if ( rc.top <= v7 )
    result |= 2u;
  if ( rc.bottom >= v3 )
    result |= 8u;
  return result;
}

//----- (6F7C2403) --------------------------------------------------------
int __stdcall LV_AdjustViewRectOnMove(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  signed int v5; // esi@7
  int v7; // edi@12
  struct tagRECT rc; // [sp+4h] [bp-20h]@12
  struct tagRECT rcDst; // [sp+14h] [bp-10h]@6

  v4 = a1;
  *(_DWORD *)(a1 + 244) = -1;
  if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
  {
    if ( *(_DWORD *)(a1 + 228) == 0x7FFFFFFF || a3 == 0x7FFFFFFF || a4 == 0x7FFFFFFF || *(_WORD *)(a2 + 18) == 0x7FFF )
      goto LABEL_9;
    rcDst.left = *(_DWORD *)(a1 + 228);
    rcDst.top = *(_DWORD *)(a1 + 232);
    rcDst.right = *(_DWORD *)(a1 + 236);
    rcDst.bottom = *(_DWORD *)(a1 + 240) - g_cyEdge;
    rcDst.right -= g_cxEdge;
    if ( *(_DWORD *)(a2 + 4) == 0x7FFFFFFF )
    {
      *(_DWORD *)(a2 + 4) = a3;
      *(_DWORD *)(a2 + 8) = a4;
    }
    else
    {
      v5 = LV_IsItemOnViewEdge(a1, a2);
      *(_DWORD *)(a2 + 4) = a3;
      *(_DWORD *)(a2 + 8) = a4;
      if ( v5 != LV_IsItemOnViewEdge(a1, a2) )
      {
        v4 = a1;
LABEL_9:
        *(_DWORD *)(v4 + 228) = 0x7FFFFFFF;
        goto LABEL_10;
      }
    }
    _ListView_GetRectsFromItem(a1, (*(_DWORD *)(a1 + 8) & 3) == 2, a2, 0, 0, &rc, 0);
    OffsetRect(&rc, *(_DWORD *)(a1 + 220), *(_DWORD *)(a1 + 224));
    UnionRect(&rcDst, &rcDst, &rc);
    rcDst.right += g_cxEdge;
    rcDst.bottom += g_cyEdge;
    v4 = a1;
    *(_DWORD *)(a1 + 228) = rcDst.left;
    *(_DWORD *)(a1 + 232) = rcDst.top;
    v7 = a1 + 236;
    *(_DWORD *)v7 = rcDst.right;
    *(_DWORD *)(v7 + 4) = rcDst.bottom;
  }
LABEL_10:
  *(_DWORD *)(a2 + 4) = a3;
  *(_DWORD *)(a2 + 8) = a4;
  return ListView_FindWorkArea(v4, *(POINT *)(a2 + 4), a2 + 22);
}

//----- (6F7C2536) --------------------------------------------------------
int __stdcall ListView_OnGetItemPosition(int a1, INT_PTR i, int a3)
{
  int result; // eax@2
  int v4; // ecx@3
  int v5; // edi@6
  int v6; // eax@9
  int v7; // [sp+4h] [bp-10h]@10
  int v8; // [sp+8h] [bp-Ch]@10

  if ( !a3 )
    return 0;
  v4 = *(_DWORD *)(a1 + 8) & 3;
  if ( v4 == 3 || v4 == 1 || *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    ListView_GetRects(a1, i, (int)&v7, 0, 0, 0);
    *(_DWORD *)a3 = v7;
    v6 = v8;
  }
  else
  {
    result = (int)DPA_GetPtr(*(HDPA *)(a1 + 40), i);
    v5 = result;
    if ( !result )
      return result;
    if ( *(_DWORD *)(result + 4) == 0x7FFFFFFF )
      ListView_Recompute(a1);
    *(_DWORD *)a3 = *(_DWORD *)(v5 + 4);
    v6 = *(_DWORD *)(v5 + 8);
  }
  *(_DWORD *)(a3 + 4) = v6;
  return 1;
}

//----- (6F7C25BE) --------------------------------------------------------
signed int __stdcall ListView_OnGetOrigin(int a1, int a2)
{
  int v2; // ecx@2
  signed int result; // eax@4

  if ( a2 && (v2 = *(_DWORD *)(a1 + 8) & 3, v2 != 3) && v2 != 1 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 220);
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 224);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C25FE) --------------------------------------------------------
LONG __stdcall ListView_OnGetStringWidth(int a1, LPCWSTR lpString, HDC hdc)
{
  HDC v3; // ebx@3
  HDC v4; // eax@4
  void *v5; // ST0C_4@4
  int v6; // eax@5
  LONG result; // eax@7
  struct tagSIZE sz; // [sp+4h] [bp-Ch]@1
  HDC hDC; // [sp+Ch] [bp-4h]@1

  sz.cx = 0;
  sz.cy = 0;
  hDC = 0;
  if ( lpString && lpString != (LPCWSTR)-1 )
  {
    v3 = hdc;
    if ( !hdc )
    {
      v4 = GetDC(*(HWND *)a1);
      v5 = *(void **)(a1 + 56);
      v3 = v4;
      hDC = v4;
      hdc = (HDC)SelectObject(v4, v5);
    }
    v6 = lstrlenW(lpString);
    GetTextExtentPointW(v3, lpString, v6, &sz);
    if ( hDC )
    {
      SelectObject(v3, hdc);
      ReleaseDC(*(HWND *)a1, hDC);
    }
    result = sz.cx;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C268A) --------------------------------------------------------
int __stdcall ListView_OnGetColumnWidth(int a1, WPARAM wParam)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = *(_DWORD *)(a1 + 8) & 3;
  if ( v2 == 1 )
  {
    result = ListView_RGetColumnWidth(a1, wParam);
  }
  else if ( v2 == 3 )
  {
    result = *(_DWORD *)(a1 + 184);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C26C0) --------------------------------------------------------
signed int __stdcall ListView_DrawItem(int a1)
{
  int v1; // eax@1
  int v2; // edx@3
  int v3; // ecx@4
  bool v4; // zf@6
  __int16 v5; // ax@10
  int v6; // eax@20
  int v7; // ecx@21
  int v8; // ecx@23
  DWORD v9; // eax@24
  int v10; // ecx@30
  int v11; // eax@33
  int v12; // edx@38
  int v13; // eax@41
  unsigned int v14; // eax@43
  int v15; // edx@43
  int v16; // ecx@43
  struct _DPA *v17; // ecx@46
  signed int v19; // [sp+Ch] [bp-4h]@1

  v1 = *(_DWORD *)a1;
  v19 = 1;
  if ( !(*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x1000) )
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * *(_DWORD *)(a1 + 60));
  v2 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 64) = 0;
  if ( v2 )
    v3 = *(_DWORD *)(v2 + 28);
  else
    v3 = 0;
  v4 = (*(_BYTE *)(a1 + 12) & 4) == 0;
  *(_DWORD *)(a1 + 68) = v3;
  if ( v4 )
  {
    if ( *(_BYTE *)(v1 + 44) & 1 )
    {
      if ( !v2 || *(_BYTE *)(v1 + 116) & 3 )
        v5 = ListView_OnGetItemState(4096, (struct _DPA *)v1, *(_DWORD *)(a1 + 60), 3);
      else
        v5 = *(_WORD *)(v2 + 24);
      if ( v5 & 1 )
        *(_DWORD *)(a1 + 64) |= 0x10u;
      if ( v5 & 2 )
        *(_DWORD *)(a1 + 64) |= 1u;
    }
    v1 = *(_DWORD *)a1;
    if ( *(_BYTE *)(*(_DWORD *)a1 + 8) & 8 )
      *(_DWORD *)(a1 + 64) |= 1u;
  }
  if ( !(CCGetUIState(v1) & 1) )
    *(_DWORD *)(a1 + 64) |= 0x200u;
  v6 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_DWORD *)a1 + 68);
  if ( *(_DWORD *)(v6 + 8) & 0x8000000 )
    v7 = *(_DWORD *)(v6 + 60);
  else
    v7 = *(_DWORD *)(v6 + 72);
  *(_DWORD *)(a1 + 76) = v7;
  v8 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)(v6 + 392) != v8 )
  {
    v12 = *(_DWORD *)(v6 + 48);
    if ( v12 & 0x40 || (char)v12 < 0 && ListView_OnGetItemState(4096, (struct _DPA *)v6, v8, 2) )
    {
      v13 = *(_DWORD *)a1;
      if ( *(_DWORD *)(*(_DWORD *)a1 + 48) & 0x1000 && *(_DWORD *)(v13 + 396) )
      {
        SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(v13 + 396));
        goto LABEL_43;
      }
    }
    else
    {
      v13 = *(_DWORD *)a1;
    }
    SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(v13 + 56));
    goto LABEL_43;
  }
  v9 = *(_DWORD *)(v6 + 444);
  if ( v9 == -16777216 )
    v9 = GetSysColor(26);
  *(_DWORD *)(a1 + 72) = v9;
  if ( v9 == *(_DWORD *)(a1 + 76) )
  {
    if ( *(_BYTE *)(a1 + 78) + 5 * *(_BYTE *)(a1 + 77) + 2 * *(_BYTE *)(a1 + 76) <= 1024 )
      *(_DWORD *)(a1 + 72) = 0xFFFFFF;
    else
      *(_DWORD *)(a1 + 72) = 0;
  }
  v10 = *(_DWORD *)(*(_DWORD *)a1 + 48);
  if ( v10 & 0x40 || (char)v10 < 0 && ListView_OnGetItemState(4096, *(struct _DPA **)a1, *(_DWORD *)(a1 + 60), 2) )
  {
    v11 = *(_DWORD *)a1;
    if ( *(_DWORD *)(*(_DWORD *)a1 + 48) & 0x800 && *(_DWORD *)(v11 + 396) )
      SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(v11 + 396));
    else
      SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(v11 + 56));
    *(_DWORD *)(a1 + 64) |= 0x40u;
  }
LABEL_43:
  v14 = CICustomDrawNotify(*(_DWORD *)a1, 65537, a1 + 24);
  *(_DWORD *)(a1 + 12) &= 0xFFFFFFE7;
  v15 = *(_DWORD *)(a1 + 64);
  v16 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 20) = v14;
  if ( v15 & 0x10 )
    *(_DWORD *)(a1 + 12) = v16 | 8;
  if ( v15 & 1 )
  {
    v17 = *(struct _DPA **)a1;
    *(_DWORD *)(a1 + 12) |= *(_BYTE *)(*(_DWORD *)a1 + 44) & 1 ? 0x10u : 0x20u;
    if ( *((_DWORD *)v17 + 98) == *(_DWORD *)(a1 + 60) )
      *(_DWORD *)(a1 + 12) |= 0x40u;
  }
  if ( !(v14 & 4) )
  {
    if ( !(*(_DWORD *)(*(_DWORD *)a1 + 8) & 0x1000) && v14 & 2 )
      ListView_RecomputeLabelSize(*(_DWORD *)a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 60), *(HDC *)(a1 + 40), 0);
    v19 = pfnListView_DrawItem[*(_DWORD *)(*(_DWORD *)a1 + 8) & 3](a1);
    if ( *(_BYTE *)(a1 + 20) & 0x10 )
    {
      *(_DWORD *)(a1 + 80) = 0;
      CICustomDrawNotify(*(_DWORD *)a1, 65538, a1 + 24);
    }
    if ( *(_BYTE *)(a1 + 20) & 2 )
    {
      SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(*(_DWORD *)a1 + 56));
      *(_DWORD *)(*(_DWORD *)a1 + 44) |= 0x2000u;
    }
  }
  return v19;
}
// 6F7C2908: using guessed type int (__stdcall *pfnListView_DrawItem[4])(int);

//----- (6F7C291D) --------------------------------------------------------
int __stdcall ListView_OnGetTopIndex(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 + 8) & 3;
  if ( v1 == 1 )
  {
    result = *(_DWORD *)(a1 + 336) / *(_DWORD *)(a1 + 188);
  }
  else if ( v1 == 3 )
  {
    result = *(_DWORD *)(a1 + 192) * (*(_DWORD *)(a1 + 180) / *(_DWORD *)(a1 + 184));
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C2965) --------------------------------------------------------
int __stdcall ListView_OnGetCountPerPage(int a1)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 + 8) & 3;
  if ( v1 == 1 )
  {
    result = (*(_DWORD *)(a1 + 124) - *(_DWORD *)(a1 + 324)) / *(_DWORD *)(a1 + 188);
  }
  else if ( v1 == 3 )
  {
    result = *(_DWORD *)(a1 + 192) * (*(_DWORD *)(a1 + 120) / *(_DWORD *)(a1 + 184));
  }
  else
  {
    result = *(_DWORD *)(a1 + 372);
  }
  return result;
}

//----- (6F7C29B1) --------------------------------------------------------
int __stdcall ListView_UnfoldRects(int a1, INT_PTR i, RECT *lprcSrc1, LPRECT lprc, LPRECT lprcDst, LPRECT a6)
{
  int v6; // ecx@1
  char *v7; // esi@1
  signed __int16 v9; // dx@8
  int v10; // eax@8
  LONG v11; // ecx@11
  char v12; // [sp+4h] [bp-40h]@1
  int v13; // [sp+40h] [bp-4h]@1

  v6 = *(_DWORD *)(a1 + 8);
  v7 = &v12;
  v13 = 0;
  if ( v6 & 3 )
    return 0;
  if ( lprc )
  {
    if ( v6 & 0x1000 )
    {
      ListView_RecomputeLabelSize(a1, (int)&v12, i, 0, 0);
    }
    else
    {
      v7 = (char *)DPA_GetPtr(*(HDPA *)(a1 + 40), i);
      if ( !v7 )
      {
        SetRectEmpty(lprc);
        goto LABEL_14;
      }
    }
    v9 = *((_WORD *)v7 + 10);
    LOWORD(v10) = *((_WORD *)v7 + 9);
    if ( v9 <= (signed __int16)v10 )
      v10 = (signed __int16)v10;
    else
      v10 = v9;
    v11 = lprc->top;
    if ( lprc->bottom != v11 + v10 )
      v13 = 1;
    lprc->bottom = v11 + v9;
  }
LABEL_14:
  if ( lprcDst && lprcSrc1 && lprc )
    UnionRect(lprcDst, lprcSrc1, lprc);
  if ( a6 && lprcSrc1 )
  {
    if ( lprc )
      UnionRect(a6, lprcSrc1, lprc);
  }
  return v13;
}

//----- (6F7C2A7C) --------------------------------------------------------
void __stdcall ListView_SendODChangeAndInvalidate(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  LPARAM lParam; // [sp+Ch] [bp-1Ch]@1
  int v7; // [sp+18h] [bp-10h]@1
  int v8; // [sp+1Ch] [bp-Ch]@1
  int v9; // [sp+20h] [bp-8h]@1
  int v10; // [sp+24h] [bp-4h]@1

  v5 = a2;
  v9 = a5;
  v10 = a4;
  v7 = a2;
  v8 = a3;
  CCSendNotify(a1, -115, (LPARAM)&lParam);
  MyNotifyWinEvent(32777, *(_DWORD *)a1, -4, 0);
  if ( a3 - a2 <= 100 )
  {
    while ( v5 <= a3 )
      ListView_InvalidateItemEx(a1, v5++, 1, 1u, 0);
  }
  else
  {
    InvalidateRect(*(HWND *)a1, 0, 0);
  }
}

//----- (6F7C2AF3) --------------------------------------------------------
BOOL __stdcall ListView_EnableWindow(int a1, int a2)
{
  int v2; // eax@1
  COLORREF v3; // ST0C_4@3

  v2 = *(_DWORD *)(a1 + 8);
  if ( a2 )
  {
    if ( v2 & 0x8000000 )
    {
      v3 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 8) = v2 & 0xF7FFFFFF;
      ListView_OnSetBkColor(a1, v3);
    }
  }
  else if ( !(v2 & 0x8000000) )
  {
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a1 + 8) = v2 | 0x8000000;
    ListView_OnSetBkColor(a1, g_clrBtnFace);
  }
  return RedrawWindow(*(HWND *)a1, 0, 0, 5u);
}

//----- (6F7C2B51) --------------------------------------------------------
BOOL __stdcall ListView_IsItemVisible(int a1, int a2)
{
  struct tagRECT rcDst; // [sp+8h] [bp-30h]@1
  RECT rcSrc2; // [sp+18h] [bp-20h]@1
  RECT rcSrc1; // [sp+28h] [bp-10h]@1

  ListView_GetRects(a1, a2, 0, 0, &rcSrc2, 0);
  rcSrc1.right = *(_DWORD *)(a1 + 120);
  rcSrc1.bottom = *(_DWORD *)(a1 + 124);
  rcSrc1.left = 0;
  rcSrc1.top = 0;
  return IntersectRect(&rcDst, &rcSrc1, &rcSrc2);
}

//----- (6F7C2B9F) --------------------------------------------------------
void __stdcall ListView_RecalcRegion(int a1, int puResult, BOOL bRedraw)
{
  int v3; // edi@1
  bool v4; // zf@1
  int v5; // eax@2
  int v6; // eax@4
  int v7; // esi@7
  int v8; // ecx@8
  void *v9; // ST30_4@10
  HBITMAP v10; // esi@18
  bool v11; // sf@24
  int v12; // esi@25
  int v13; // ecx@27
  void *v14; // ST14_4@29
  RECT *v15; // eax@30
  HRGN v16; // eax@32
  HRGN v17; // eax@36
  int v18; // edi@44
  int v19; // eax@46
  LONG v20; // edx@52
  LONG v21; // edi@52
  int v22; // edi@57
  int v23; // eax@65
  HRGN v24; // eax@68
  int v25; // ecx@68
  HRGN v26; // [sp-2Ch] [bp-D0h]@38
  HRGN v27; // [sp-28h] [bp-CCh]@38
  int v28; // [sp+8h] [bp-9Ch]@42
  int v29; // [sp+Ch] [bp-98h]@42
  int v30; // [sp+10h] [bp-94h]@42
  int v31; // [sp+18h] [bp-8Ch]@42
  int v32; // [sp+1Ch] [bp-88h]@42
  int v33; // [sp+20h] [bp-84h]@42
  char pv; // [sp+30h] [bp-74h]@19
  INT v35; // [sp+38h] [bp-6Ch]@20
  INT iOperand; // [sp+3Ch] [bp-68h]@19
  HGDIOBJ h; // [sp+48h] [bp-5Ch]@1
  LONG v38; // [sp+4Ch] [bp-58h]@17
  HBITMAP hbit; // [sp+50h] [bp-54h]@18
  struct tagRECT rc; // [sp+54h] [bp-50h]@17
  RECT rc2; // [sp+64h] [bp-40h]@11
  int v42; // [sp+74h] [bp-30h]@25
  LONG v43; // [sp+78h] [bp-2Ch]@17
  SIZE_T dwBytes; // [sp+7Ch] [bp-28h]@19
  HGDIOBJ ho; // [sp+80h] [bp-24h]@32
  LPVOID lpvBits; // [sp+84h] [bp-20h]@22
  HDC hdc; // [sp+88h] [bp-1Ch]@17
  int cy; // [sp+8Ch] [bp-18h]@17
  int nWidth; // [sp+90h] [bp-14h]@17
  int v50; // [sp+94h] [bp-10h]@33
  HRGN hrgnSrc2; // [sp+98h] [bp-Ch]@39
  LONG i; // [sp+9Ch] [bp-8h]@45
  HRGN hrgnDst; // [sp+A0h] [bp-4h]@1

  v3 = a1;
  v4 = (*(_DWORD *)(a1 + 48) & 0x200) == 0;
  hrgnDst = 0;
  h = 0;
  if ( !v4 )
  {
    v5 = *(_DWORD *)(a1 + 44);
    if ( (*(_BYTE *)(a1 + 44) & 0x12) == 18 && !(v5 & 0x10000) )
    {
      *(_DWORD *)(a1 + 44) = v5 | 0x10000;
      v6 = *(_DWORD *)(a1 + 372);
      if ( v6 <= 0 )
        goto LABEL_79;
      if ( !puResult )
      {
        puResult = 0;
        if ( v6 > 0 )
        {
          while ( 1 )
          {
            v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * puResult);
            if ( !ListView_IsItemVisible(a1, puResult) )
            {
              v8 = *(_DWORD *)(v7 + 32);
              if ( v8 == -1 || !v8 )
                goto LABEL_15;
              v9 = *(void **)(v7 + 32);
              *(_DWORD *)(v7 + 36) = 0x7FFFFFFF;
              *(_DWORD *)(v7 + 40) = 0x7FFFFFFF;
              DeleteObject(v9);
              *(_DWORD *)(v7 + 32) = 0;
            }
            ListView_GetRects(a1, puResult, 0, (int)&rc2, 0, 0);
            if ( *(_DWORD *)(v7 + 4) != *(_DWORD *)(v7 + 36)
              || *(_DWORD *)(v7 + 8) != *(_DWORD *)(v7 + 40)
              || !*(_DWORD *)(v7 + 32)
              || !EqualRect((const RECT *)(v7 + 44), &rc2) )
              goto LABEL_17;
LABEL_15:
            ++puResult;
            if ( puResult >= *(_DWORD *)(a1 + 372) )
              goto LABEL_80;
          }
        }
        goto LABEL_80;
      }
LABEL_17:
      ListView_GetRects(a1, 0, (int)&rc, 0, 0, 0);
      ImageList_GetIconSize(*(HIMAGELIST *)(a1 + 204), &nWidth, &cy);
      v43 = (rc.right - rc.left - nWidth) / 2;
      nWidth = rc.right - rc.left;
      v38 = (rc.bottom - rc.top - cy) / 2;
      cy = rc.bottom - rc.top;
      hdc = CreateCompatibleDC(0);
      if ( !hdc )
      {
LABEL_79:
        SetWindowRgn(*(HWND *)v3, hrgnDst, bRedraw);
LABEL_80:
        *(_DWORD *)(v3 + 44) &= 0xFFFEFFFF;
        return;
      }
      v10 = CreateBitmap(nWidth, cy, 1u, 1u, 0);
      hbit = v10;
      if ( !v10 )
      {
LABEL_78:
        DeleteDC(hdc);
        goto LABEL_79;
      }
      GetObjectW(v10, 24, &pv);
      if ( IntToUInt(iOperand, (UINT *)&dwBytes) < 0
        || IntToUInt(v35, (UINT *)&puResult) < 0
        || ULongLongToULong(dwBytes * (unsigned __int64)(unsigned int)puResult, &dwBytes) < 0
        || (lpvBits = GlobalAlloc(0x40u, dwBytes)) == 0 )
      {
LABEL_77:
        SelectObject(hdc, h);
        DeleteObject(hbit);
        goto LABEL_78;
      }
      h = SelectObject(hdc, v10);
      PatBlt(hdc, 0, 0, nWidth, cy, 0xFF0062u);
      hrgnDst = CreateRectRgn(0, 0, 0, 0);
      if ( !hrgnDst || (v4 = *(_DWORD *)(a1 + 372) == 0, v11 = *(_DWORD *)(a1 + 372) < 0, puResult = 0, v11 || v4) )
      {
LABEL_76:
        GlobalFree(lpvBits);
        goto LABEL_77;
      }
      while ( 1 )
      {
        v12 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * puResult);
        v4 = *(_DWORD *)(v12 + 8) == 0x7FFFFFFF;
        v42 = 0;
        if ( v4 )
          goto LABEL_70;
        if ( !ListView_IsItemVisible(v3, puResult) )
        {
          v13 = *(_DWORD *)(v12 + 32);
          if ( v13 )
          {
            if ( v13 != -1 )
            {
              v14 = *(void **)(v12 + 32);
              *(_DWORD *)(v12 + 36) = 0x7FFFFFFF;
              *(_DWORD *)(v12 + 40) = 0x7FFFFFFF;
              DeleteObject(v14);
              *(_DWORD *)(v12 + 32) = -1;
            }
          }
          goto LABEL_70;
        }
        ListView_GetRects(v3, puResult, (int)&rc, (int)&rc2, 0, 0);
        v15 = (RECT *)(v12 + 44);
        if ( puResult != *(_DWORD *)(v3 + 252) )
          v15 = &rc2;
        v16 = CreateRectRgnIndirect(v15);
        ho = v16;
        if ( !v16 || (v50 = CombineRgn(hrgnDst, v16, hrgnDst, 2), DeleteObject(ho), !v50) )
        {
LABEL_75:
          DeleteObject(hrgnDst);
          hrgnDst = 0;
          goto LABEL_76;
        }
        if ( *(_DWORD *)(v3 + 252) != puResult )
          CopyRect((LPRECT)(v12 + 44), &rc2);
        v17 = *(HRGN *)(v12 + 32);
        if ( v17 && v17 != (HRGN)-1 )
        {
          OffsetRgn(v17, *(_DWORD *)(v12 + 4) - *(_DWORD *)(v12 + 36), *(_DWORD *)(v12 + 8) - *(_DWORD *)(v12 + 40));
          v27 = hrgnDst;
          *(_DWORD *)(v12 + 36) = *(_DWORD *)(v12 + 4);
          v26 = *(HRGN *)(v12 + 32);
          *(_DWORD *)(v12 + 40) = *(_DWORD *)(v12 + 8);
          goto LABEL_69;
        }
        hrgnSrc2 = 0;
        if ( g_fSlowMachine )
        {
          rc.bottom = rc2.top;
          InflateRect(&rc, -v43, 0);
          hrgnSrc2 = CreateRectRgnIndirect(&rc);
          goto LABEL_64;
        }
        if ( *(_WORD *)(v12 + 12) == -1 )
        {
          v29 = puResult;
          v30 = 0;
          v28 = 2;
          v31 = 0xFFFF;
          v32 = 0;
          v33 = 0;
          ListView_OnGetItem(v3, (HDPA)v3, (int)&v28);
        }
        ImageList_Draw(*(HIMAGELIST *)(v3 + 204), *(_WORD *)(v12 + 12), hdc, 0, 0, *(_WORD *)(v12 + 24) & 0xF00 | 0x10);
        GetBitmapBits(hbit, dwBytes, lpvBits);
        v50 = 0;
        if ( cy <= 0 )
          goto LABEL_70;
        v18 = nWidth;
        do
        {
          for ( i = 0; i < v18; ++i )
          {
            v19 = i / 8;
            if ( v42 )
            {
              if ( !((unsigned __int8)(128 >> i % 8) & *((_BYTE *)lpvBits + iOperand * v50 + v19)) )
                continue;
            }
            else
            {
              if ( (unsigned __int8)(128 >> i % 8) & *((_BYTE *)lpvBits + iOperand * v50 + v19) )
                continue;
              rc2.top = v50;
              rc2.bottom = v50 + 1;
              rc2.left = i;
              v42 = 1;
              if ( i != v18 - 1 )
                continue;
              ++i;
            }
            v4 = (*(_DWORD *)(a1 + 24) & 0x400000) == 0;
            rc2.right = i;
            if ( v4 )
            {
              OffsetRect(&rc2, v43 + rc.left, v38 + rc.top);
            }
            else
            {
              v20 = v18 - i - 1;
              v21 = v18 - rc2.left - 1;
              rc2.left = v20;
              rc2.right = v21;
              OffsetRect(&rc2, rc.left - v43, v38 + rc.top);
            }
            ho = CreateRectRgnIndirect(&rc2);
            if ( !ho
              || (hrgnSrc2 || (hrgnSrc2 = CreateRectRgn(0, 0, 0, 0)) != 0 ? (v22 = CombineRgn(
                                                                                     hrgnSrc2,
                                                                                     (HRGN)ho,
                                                                                     hrgnSrc2,
                                                                                     2)) : (v22 = 0),
                  DeleteObject(ho),
                  !v22) )
            {
              if ( hrgnSrc2 )
                DeleteObject(hrgnSrc2);
              v3 = a1;
              goto LABEL_75;
            }
            v18 = nWidth;
            v42 = 0;
          }
          ++v50;
        }
        while ( v50 < cy );
        v3 = a1;
LABEL_64:
        if ( hrgnSrc2 )
        {
          v23 = *(_DWORD *)(v12 + 32);
          if ( v23 && v23 != -1 )
            DeleteObject(*(HGDIOBJ *)(v12 + 32));
          v24 = hrgnSrc2;
          v27 = hrgnDst;
          *(_DWORD *)(v12 + 36) = *(_DWORD *)(v12 + 4);
          v25 = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(v12 + 32) = v24;
          *(_DWORD *)(v12 + 40) = v25;
          v26 = v24;
LABEL_69:
          if ( !CombineRgn(hrgnDst, v26, v27, 2) )
            goto LABEL_75;
        }
LABEL_70:
        ++puResult;
        if ( puResult >= *(_DWORD *)(v3 + 372) )
          goto LABEL_76;
      }
    }
  }
}
// 6F7C2B9F: could not find valid save-restore pair for esi
// 6F7E8598: using guessed type int g_fSlowMachine;

//----- (6F7C3180) --------------------------------------------------------
signed int __userpurge ListView_OnSetCursorMsg@<eax>(int a1@<edi>, int a2)
{
  int v2; // ecx@1
  int v3; // eax@2
  HCURSOR *v4; // esi@6
  signed int result; // eax@8

  v2 = *(_DWORD *)(a2 + 48);
  if ( v2 & 0xC0
    && (v3 = *(_DWORD *)(a2 + 392), v3 != -1)
    && (v2 & 0x40 && *(_BYTE *)(a2 + 36) & 4 || ListView_OnGetItemState(a1, (struct _DPA *)a2, v3, 2)) )
  {
    v4 = (HCURSOR *)(a2 + 408);
    if ( !*(_DWORD *)(a2 + 408) )
      *v4 = LoadHandCursor(0);
    SetCursor(*v4);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C31E1) --------------------------------------------------------
void __stdcall ListView_OnSetHotItem(int a1, int a2)
{
  int v2; // esi@1
  int v3; // ecx@1
  UINT v4; // edx@2
  int v5; // edi@4
  int v6; // ST08_4@4
  int v7; // ST00_4@4
  unsigned int v8; // [sp+10h] [bp+8h]@4

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 392);
  if ( a2 != v3 )
  {
    v4 = 1;
    if ( *(_DWORD *)(a1 + 72) == -1 )
      v4 = 5;
    v5 = *(_DWORD *)(a1 + 48) & 0x20;
    v6 = *(_DWORD *)(a1 + 48) & 0x20;
    v7 = a1;
    v8 = (*(_DWORD *)(a1 + 48) & 0x8000 | 0x4000u) >> 14;
    ListView_InvalidateItemEx(v7, v3, v6, v4, v8);
    ListView_InvalidateItemEx(v2, a2, v5, 1u, v8);
    *(_DWORD *)(v2 + 392) = a2;
  }
}

//----- (6F7C3246) --------------------------------------------------------
void __stdcall ListView_OnMouseMove(HDC hdc, int a2, int a3, int a4)
{
  LONG v4; // ecx@2
  int v5; // edi@5
  LPARAM lParam; // [sp+4h] [bp-40h]@11
  int v7; // [sp+10h] [bp-34h]@11
  int v8; // [sp+14h] [bp-30h]@11
  int v9; // [sp+20h] [bp-24h]@11
  int v10; // [sp+24h] [bp-20h]@11
  int v11; // [sp+28h] [bp-1Ch]@11
  int v12; // [sp+30h] [bp-14h]@5
  int v13; // [sp+34h] [bp-10h]@5
  int v14; // [sp+38h] [bp-Ch]@8
  int v15; // [sp+40h] [bp-4h]@5

  if ( *((_BYTE *)hdc + 48) & 0xC8
    && (ChildOfActiveWindow(*(HWND *)hdc) || fShouldFirstClickActivate(v4) || ChildOfDesktop(*(HWND *)hdc)) )
  {
    v13 = a3;
    v12 = a2;
    v5 = ListView_OnSubItemHitTest(hdc, (int)&v12);
    if ( v15 && !(*((_BYTE *)hdc + 48) & 0x20) && !(*((_DWORD *)hdc + 2) & 0x400) )
    {
      v5 = -1;
      v14 = 1;
    }
    if ( v14 & 9 )
      v5 = -1;
    v9 = 0;
    v8 = v15;
    v11 = a3;
    v7 = v5;
    v10 = a2;
    if ( !CCSendNotify((int)hdc, -121, (LPARAM)&lParam) )
    {
      ListView_OnSetHotItem((int)hdc, v7);
      ListView_OnSetCursorMsg(v5, (int)hdc);
      if ( v5 != *((_DWORD *)hdc + 100) )
        *((_DWORD *)hdc + 100) = -1;
    }
  }
}

//----- (6F7C330D) --------------------------------------------------------
int __stdcall ListView_GetUnfoldedRect(int a1, INT_PTR i, LPRECT lprc)
{
  ListView_GetRects(a1, i, 0, (int)lprc, 0, 0);
  return ListView_UnfoldRects(a1, i, 0, lprc, 0, 0);
}

//----- (6F7C3341) --------------------------------------------------------
HLOCAL __stdcall ListView_OnNCDestroy(HLOCAL hMem)
{
  int v1; // eax@3

  CCDestroyWindow();
  if ( !(*((_BYTE *)hMem + 8) & 0x40) || *((_BYTE *)hMem + 48) & 4 )
  {
    v1 = *((_DWORD *)hMem + 88);
    if ( v1 )
    {
      if ( v1 != *((_DWORD *)hMem + 51) && v1 != *((_DWORD *)hMem + 42) )
        ImageList_Destroy(*((HIMAGELIST *)hMem + 88));
    }
  }
  if ( !(*((_BYTE *)hMem + 8) & 0x40) )
  {
    if ( *((_DWORD *)hMem + 51) )
      ImageList_Destroy(*((HIMAGELIST *)hMem + 51));
    if ( *((_DWORD *)hMem + 42) )
      ImageList_Destroy(*((HIMAGELIST *)hMem + 42));
  }
  if ( *((_DWORD *)hMem + 2) & 0x1000 )
  {
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)hMem + 91) + 8))(*((_DWORD *)hMem + 91));
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)hMem + 92) + 8))(*((_DWORD *)hMem + 92));
    *((_DWORD *)hMem + 93) = 0;
  }
  ListView_ReleaseBkImage((int)hMem);
  if ( *((_DWORD *)hMem + 19) )
    DeleteObject(*((HGDIOBJ *)hMem + 19));
  if ( *((_DWORD *)hMem + 10) )
    DPA_Destroy(*((HDPA *)hMem + 10));
  if ( *((_DWORD *)hMem + 54) )
    DPA_Destroy(*((HDPA *)hMem + 54));
  ListView_RDestroy((int)hMem);
  if ( *((_DWORD *)hMem + 115) )
    Free(*((HLOCAL *)hMem + 115));
  SetWindowLongW(*(HWND *)hMem, 0, 0);
  return LocalFree(hMem);
}

//----- (6F7C342D) --------------------------------------------------------
int __stdcall ListView_InvalidateSelectedOrCutOwnerData(int a1, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  UINT v4; // ebx@1
  int v5; // edi@1
  int v6; // edi@5
  int result; // eax@7
  LONG v8; // eax@8
  int v9; // ecx@9
  signed int v10; // edi@9
  int v11; // edi@17
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@1
  int v13; // [sp+1Ch] [bp-4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8);
  v13 = *(_DWORD *)(a1 + 372);
  v4 = 1;
  v5 = v3 & 3;
  GetClientRect(*(HWND *)a1, &Rect);
  if ( *(_DWORD *)(v2 + 72) == -1
    || *(_DWORD *)(v2 + 204) && *(_DWORD *)(v2 + 60) != ImageList_GetBkColor(*(HIMAGELIST *)(v2 + 204)) )
    v4 = 5;
  v6 = v5 - 1;
  if ( v6 )
  {
    if ( v6 != 2 )
    {
      ListView_CalcMinMaxIndex(v2, (int)&Rect, (int)&a1, (int)&v13);
      result = v13;
      goto LABEL_11;
    }
    a1 = ListView_LCalcViewItem(v2, Rect.left, Rect.top);
    v8 = ListView_LCalcViewItem(v2, Rect.right, Rect.bottom);
  }
  else
  {
    v9 = *(_DWORD *)(v2 + 336) - *(_DWORD *)(v2 + 324);
    v10 = *(_DWORD *)(v2 + 188);
    a1 = (v9 + Rect.top) / v10;
    v8 = (v9 + Rect.bottom) / v10;
  }
  result = v8 + 1;
LABEL_11:
  if ( a1 <= 0 )
    a1 = 0;
  if ( *(_DWORD *)(v2 + 372) < result )
    result = *(_DWORD *)(v2 + 372);
  v13 = result;
  if ( result > a1 )
  {
    ListView_NotifyCacheHint(v2, a1, result - 1);
    result = a1;
    if ( a1 < v13 )
    {
      v11 = a2;
      do
      {
        if ( !(*(int (__stdcall **)(int, int))(*(_DWORD *)v11 + 36))(v11, a1) )
          ListView_InvalidateItemEx(v2, a1, 0, v4, 0);
        ++a1;
        result = a1;
      }
      while ( a1 < v13 );
    }
  }
  return result;
}

//----- (6F7C353C) --------------------------------------------------------
signed int __stdcall ScrollDetect(int a1, int a2, int a3, int *a4, int *a5)
{
  signed int result; // eax@1
  int v6; // ecx@1
  int v7; // edi@2
  int v8; // eax@2
  int v9; // ebx@2
  int v10; // eax@13
  int v11; // eax@14
  int v12; // eax@16
  int v13; // eax@21
  int v14; // eax@22
  int v15; // eax@24

  *a5 = 0;
  result = (signed int)a4;
  *a4 = 0;
  v6 = *(_DWORD *)(a1 + 8);
  if ( !(v6 & 0x300000) )
    return result;
  v7 = *(_DWORD *)(a1 + 212) / 16;
  v8 = *(_DWORD *)(a1 + 8) & 3;
  v9 = *(_DWORD *)(a1 + 212) / 16;
  if ( v8 == 1 )
  {
    v7 = *(_DWORD *)(a1 + 188);
    if ( !v9 )
      v9 = *(_DWORD *)(a1 + 172);
  }
  if ( v8 == 3 )
    v9 = *(_DWORD *)(a1 + 184);
  if ( !v9 )
    v9 = 1;
  if ( !v7 )
    v7 = 1;
  if ( v6 & 0x200000 )
  {
    if ( a3 >= *(_DWORD *)(a1 + 124) )
    {
      LOBYTE(v10) = CanScroll(a1, 1, 1);
      if ( !v10 )
        goto LABEL_19;
      v11 = ScrollAmount(a3, *(_DWORD *)(a1 + 124), v7);
      goto LABEL_18;
    }
    if ( a3 <= 0 )
    {
      LOBYTE(v12) = CanScroll(a1, 1, 0);
      if ( v12 )
      {
        v11 = -(v7 * ((v7 - a3 - 1) / v7));
LABEL_18:
        *a5 = v11;
        goto LABEL_19;
      }
    }
  }
LABEL_19:
  if ( *(_DWORD *)(a1 + 8) & 0x100000 )
  {
    if ( a2 < *(_DWORD *)(a1 + 120) )
    {
      if ( a2 <= 0 )
      {
        LOBYTE(v15) = CanScroll(a1, 0, 0);
        if ( v15 )
        {
          v14 = -(v9 * ((v9 - a2 - 1) / v9));
          goto LABEL_26;
        }
      }
    }
    else
    {
      LOBYTE(v13) = CanScroll(a1, 0, 1);
      if ( v13 )
      {
        v14 = ScrollAmount(a2, *(_DWORD *)(a1 + 120), v9);
LABEL_26:
        *a4 = v14;
        goto LABEL_27;
      }
    }
  }
LABEL_27:
  result = (signed int)a4;
  if ( *a4 || *a5 )
    result = ListView_ValidateScrollParams(a1, a4, a5);
  return result;
}

//----- (6F7C366E) --------------------------------------------------------
unsigned int __stdcall ListView_UpdateScrollBars(HDC hdc)
{
  unsigned int result; // eax@1
  struct tagRECT Rect; // [sp+4h] [bp-10h]@3

  result = *((_DWORD *)hdc + 2);
  if ( !(result & 0x2000) && (*((_BYTE *)hdc + 44) & 0x12) == 18 )
  {
    (*(&pfnListView_UpdateScrollBars + (result & 3)))(hdc);
    GetClientRect(*(HWND *)hdc, &Rect);
    *((_DWORD *)hdc + 30) = Rect.right;
    *((_DWORD *)hdc + 31) = Rect.bottom;
    result = *((_DWORD *)hdc + 2) & 0xFFEFFFFF | ListView_GetWindowStyle((int)hdc) & 0x100000 | 0x200000;
    *((_DWORD *)hdc + 2) = result;
  }
  return result;
}
// 6F7C36D8: using guessed type int (__stdcall *pfnListView_UpdateScrollBars)(HDC hdc);

//----- (6F7C36ED) --------------------------------------------------------
int __stdcall ListView_OnSetFont(int a1, void *a2, int a3)
{
  HFONT v3; // eax@5
  HGDIOBJ v4; // ST1C_4@6
  HDC v5; // ST08_4@6
  HGDIOBJ v6; // ST0C_4@6
  HWND v7; // eax@6
  HWND v8; // eax@8
  int result; // eax@12
  struct tagSIZE sz; // [sp+10h] [bp-70h]@1
  HGDIOBJ h; // [sp+18h] [bp-68h]@1
  HDC hdc; // [sp+1Ch] [bp-64h]@6
  char pvParam; // [sp+20h] [bp-60h]@5

  h = a2;
  sz.cx = 0;
  sz.cy = 0;
  if ( *(_DWORD *)(a1 + 44) & 0x100 && *(_DWORD *)(a1 + 56) )
  {
    DeleteObject(*(HGDIOBJ *)(a1 + 56));
    *(_DWORD *)(a1 + 44) &= 0xFFFFFEFF;
  }
  if ( !h )
  {
    SystemParametersInfoW(0x1Fu, 0x5Cu, &pvParam, 0);
    v3 = CreateFontIndirectW((const LOGFONTW *)&pvParam);
    *(_DWORD *)(a1 + 44) |= 0x100u;
    h = v3;
  }
  hdc = GetDC(0);
  v4 = SelectObject(hdc, h);
  GetTextExtentPointW(hdc, L"0", 1, &sz);
  *(_DWORD *)(a1 + 84) = sz.cy;
  *(_DWORD *)(a1 + 88) = sz.cx;
  sz.cx = 0;
  sz.cy = 0;
  GetTextExtentPointW(hdc, L"...", 3, &sz);
  v5 = hdc;
  *(_DWORD *)(a1 + 92) = sz.cx;
  SelectObject(v5, v4);
  ReleaseDC(0, hdc);
  v6 = h;
  *(_DWORD *)(a1 + 56) = h;
  *(_DWORD *)(a1 + 20) = GetCodePageForFont(v6);
  ListView_InvalidateCachedLabelSizes(a1);
  v7 = *(HWND *)(a1 + 152);
  if ( v7 )
    SendMessageW(v7, 0x30u, *(_DWORD *)(a1 + 56), 0);
  v8 = *(HWND *)(a1 + 320);
  if ( v8 )
  {
    SendMessageW(v8, 0x30u, *(_DWORD *)(a1 + 56), 0);
    ListView_UpdateScrollBars((HDC)a1);
  }
  if ( *(_DWORD *)(a1 + 396) )
  {
    DeleteObject(*(HGDIOBJ *)(a1 + 396));
    *(_DWORD *)(a1 + 396) = 0;
  }
  result = CCGetHotFont(*(HANDLE *)(a1 + 56), a1 + 396);
  *(_DWORD *)(a1 + 244) = -1;
  if ( a3 )
    result = RedrawWindow(*(HWND *)a1, 0, 0, 5u);
  return result;
}

//----- (6F7C3861) --------------------------------------------------------
signed int __stdcall ListView_OnGetItemA(int a1, int a2)
{
  int v2; // esi@1
  void *v4; // eax@5
  signed int v5; // eax@7
  const WCHAR *v6; // ecx@8
  int v7; // eax@10
  HLOCAL hMem; // [sp+8h] [bp-8h]@1
  CHAR *lpMultiByteStr; // [sp+Ch] [bp-4h]@1
  signed int v10; // [sp+1Ch] [bp+Ch]@7

  v2 = a2;
  hMem = 0;
  lpMultiByteStr = 0;
  if ( !a2 )
    return 0;
  if ( *(_BYTE *)a2 & 1 && *(_DWORD *)(a2 + 20) )
  {
    lpMultiByteStr = *(CHAR **)(a2 + 20);
    v4 = (void *)CCLocalAllocArray_WCHAR(*(_DWORD *)(a2 + 24));
    hMem = v4;
    if ( !v4 )
      return 0;
    *(_DWORD *)(a2 + 20) = v4;
  }
  v5 = ListView_OnGetItem(a1, (HDPA)a1, a2);
  v10 = v5;
  if ( hMem )
  {
    v6 = *(const WCHAR **)(v2 + 20);
    if ( v6 != (const WCHAR *)-1 )
    {
      if ( v5 )
      {
        v7 = *(_DWORD *)(v2 + 24);
        if ( v7 )
          WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, v6, -1, lpMultiByteStr, v7, 0, 0);
      }
      *(_DWORD *)(v2 + 20) = lpMultiByteStr;
    }
    LocalFree(hMem);
  }
  return v10;
}
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F7C38F5) --------------------------------------------------------
int __stdcall ListView_OnGetItemTextA(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a3 && (*(_DWORD *)a3 = 1, *(_DWORD *)(a3 + 4) = a2, ListView_OnGetItemA(a1, a3)) )
    result = lstrlenA(*(LPCSTR *)(a3 + 20));
  else
    result = 0;
  return result;
}

//----- (6F7C3932) --------------------------------------------------------
int __stdcall ListView_OnSetBkImage(int a1, STRSAFE_LPCWSTR pszSrc)
{
  STRSAFE_LPCWSTR v2; // edi@1
  const WCHAR *v3; // ebx@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // esi@4
  int v7; // eax@6
  size_t v8; // ebx@6
  wchar_t *v9; // eax@6
  HMODULE v11; // eax@8
  FARPROC v12; // eax@9
  int v13; // ebx@10
  unsigned int v14; // eax@11
  int v15; // eax@14
  int v16; // eax@18
  int v17; // eax@21
  signed int v18; // [sp+Ch] [bp-4h]@1
  const wchar_t *pszSrca; // [sp+1Ch] [bp+Ch]@1

  v18 = 0;
  v2 = pszSrc;
  v3 = (const WCHAR *)*((_DWORD *)pszSrc + 2);
  v4 = *(_DWORD *)pszSrc & 3;
  pszSrca = (const wchar_t *)*((_DWORD *)pszSrc + 2);
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      if ( v5 != 1 )
        return 0;
      v6 = a1;
      ListView_ReleaseBkImage(a1);
      if ( v3 && *v3 )
      {
        v7 = lstrlenW(v3);
        v8 = v7 + 1;
        v9 = (wchar_t *)LocalAlloc(0x40u, 2 * (v7 + 1));
        *(_DWORD *)(a1 + 424) = v9;
        if ( !v9 )
          return 0;
        StringCchCopyW(v9, v8, pszSrca);
        v11 = GetModuleHandleW(L"OLE32");
        if ( !v11 )
          return 0;
        v12 = GetProcAddress(v11, "CoCreateInstance");
        if ( !v12 )
          return 0;
        v13 = a1 + 412;
        if ( ((int (__stdcall *)(GUID *, _DWORD, signed int, GUID *, int))v12)(
               &CLSID_IImgCtx,
               0,
               1,
               &IID_IImgCtx,
               a1 + 412) < 0 )
          return 0;
        v14 = GetWindowLongW(*(HWND *)a1, -20);
        if ( (*(int (__stdcall **)(_DWORD, const wchar_t *, int))(**(_DWORD **)v13 + 12))(
               *(_DWORD *)v13,
               pszSrca,
               (v14 >> 13) & 0x200) < 0 )
        {
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)v13 + 8))(*(_DWORD *)v13);
          *(_DWORD *)v13 = 0;
          return 0;
        }
      }
      else
      {
        *(_DWORD *)v2 &= 0xFFFFFFFD;
      }
    }
    else
    {
      v6 = a1;
      ListView_ReleaseBkImage(a1);
      v15 = *((_DWORD *)v2 + 1);
      if ( v15 )
        *(_DWORD *)(a1 + 420) = v15;
      else
        *(_DWORD *)v2 &= 0xFFFFFFFE;
    }
  }
  else
  {
    v6 = a1;
    ListView_ReleaseBkImage(a1);
  }
  *(_DWORD *)(v6 + 416) = *(_DWORD *)v2;
  *(_DWORD *)(v6 + 428) = *((_DWORD *)v2 + 4);
  *(_DWORD *)(v6 + 432) = *((_DWORD *)v2 + 5);
  v16 = *(_DWORD *)(v6 + 412);
  if ( v16 )
  {
    if ( !*(_DWORD *)(v6 + 436) )
      (*(void (__stdcall **)(int, int))(*(_DWORD *)v16 + 36))(v16, v6 + 436);
    v17 = *(_DWORD *)(v6 + 412);
    *(_DWORD *)(v6 + 36) &= 0xFFFFFFDF;
    (*(void (__stdcall **)(int, int (__stdcall *)(int, int), int))(*(_DWORD *)v17 + 20))(v17, ImgCtxCallback, v6);
    (*(void (__stdcall **)(_DWORD, signed int, _DWORD, signed int))(**(_DWORD **)(v6 + 412) + 16))(
      *(_DWORD *)(v6 + 412),
      4,
      0,
      1);
    v18 = 1;
  }
  InvalidateRect(*(HWND *)v6, 0, 1);
  return v18;
}

//----- (6F7C3B01) --------------------------------------------------------
const CHAR *__stdcall ListView_OnSetBkImageA(int a1, const void *a2)
{
  signed int v2; // ebx@1
  const CHAR *result; // eax@3
  int v4; // esi@5
  wchar_t pszSrc[2]; // [sp+Ch] [bp-18h]@1
  LPCSTR lpMultiByteStr; // [sp+14h] [bp-10h]@2

  qmemcpy(pszSrc, a2, 0x18u);
  v2 = 0;
  if ( (pszSrc[0] & 3) == 2 && lpMultiByteStr )
  {
    result = ProduceWFromA(*(_DWORD *)(a1 + 20), lpMultiByteStr);
    lpMultiByteStr = result;
    if ( !result )
      return result;
    v2 = 1;
  }
  v4 = ListView_OnSetBkImage(a1, pszSrc);
  if ( v2 )
    FreeProducedString((HLOCAL)lpMultiByteStr);
  return (const CHAR *)v4;
}

//----- (6F7C3B66) --------------------------------------------------------
signed int __stdcall ListView_OnGetBkImage(int a1, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@2
  int v4; // ecx@3
  wchar_t *v5; // ecx@5

  result = 0;
  if ( a2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 416);
    v3 = *(_DWORD *)(a1 + 416) & 3;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          goto LABEL_9;
        v5 = *(wchar_t **)(a2 + 8);
        if ( !v5 )
          goto LABEL_9;
        StringCchCopyW(v5, *(_DWORD *)(a2 + 12), *(STRSAFE_LPCWSTR *)(a1 + 424));
      }
      else
      {
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 420);
      }
    }
    result = 1;
LABEL_9:
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 428);
    *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 432);
  }
  return result;
}

//----- (6F7C3BD3) --------------------------------------------------------
int __stdcall ListView_LRInvalidateBelow(HDC hdc, int a2, int a3)
{
  int result; // eax@1
  LONG v4; // eax@9
  int v5; // ecx@10
  HWND v6; // ecx@21
  HWND v7; // ST08_4@24
  int dy; // [sp+4h] [bp-58h]@21
  int v9; // [sp+8h] [bp-54h]@21
  HWND v10; // [sp+Ch] [bp-50h]@21
  int v11; // [sp+10h] [bp-4Ch]@21
  int v12; // [sp+14h] [bp-48h]@21
  RECT *v13; // [sp+18h] [bp-44h]@21
  RECT *v14; // [sp+1Ch] [bp-40h]@21
  int v15; // [sp+20h] [bp-3Ch]@21
  int v16; // [sp+24h] [bp-38h]@21
  int v17; // [sp+28h] [bp-34h]@21
  int v18; // [sp+2Ch] [bp-30h]@21
  int v19; // [sp+30h] [bp-2Ch]@21
  int v20; // [sp+34h] [bp-28h]@21
  int v21; // [sp+38h] [bp-24h]@21
  RECT v22; // [sp+3Ch] [bp-20h]@24
  RECT rcUpdate; // [sp+4Ch] [bp-10h]@8

  result = *((_DWORD *)hdc + 2) & 3;
  if ( result == 3 || result == 1 )
  {
    if ( (*((_BYTE *)hdc + 44) & 0x12) != 18 || result == 1 && *((_DWORD *)hdc + 103) )
      a3 = 0;
    if ( a2 < 0 )
    {
      rcUpdate.right = *((_DWORD *)hdc + 30);
      v4 = *((_DWORD *)hdc + 31);
      rcUpdate.top = 0;
      rcUpdate.left = 0;
      rcUpdate.bottom = v4;
    }
    else
    {
      ListView_GetRects((int)hdc, a2, 0, 0, &rcUpdate, 0);
    }
    v5 = *((_DWORD *)hdc + 2) & 3;
    if ( v5 == 1 && rcUpdate.top < *((_DWORD *)hdc + 81) )
      rcUpdate.top = *((_DWORD *)hdc + 81);
    result = *((_DWORD *)hdc + 31);
    if ( rcUpdate.top <= result && rcUpdate.left <= *((_DWORD *)hdc + 30) )
    {
      rcUpdate.bottom = *((_DWORD *)hdc + 31);
      if ( (*((_BYTE *)hdc + 44) & 0x12) != 18 )
        goto LABEL_27;
      if ( *((_DWORD *)hdc + 15) == -1 && !*((_DWORD *)hdc + 103) )
      {
        LVSeeThruScroll(hdc, (HDC)&rcUpdate);
        goto LABEL_23;
      }
      if ( v5 == 1 && a3 )
      {
        v6 = *(HWND *)hdc;
        v18 = -1;
        v10 = v6;
        v12 = -*((_DWORD *)hdc + 47);
        v19 = 1;
        v20 = 1;
        v11 = 0;
        v15 = 0;
        v16 = 0;
        dy = 56;
        v9 = 4;
        v13 = &rcUpdate;
        v14 = &rcUpdate;
        v17 = 6;
        v21 = 0;
        SmoothScrollWindow((int)&dy);
      }
      else
      {
LABEL_27:
        RedrawWindow(*(HWND *)hdc, &rcUpdate, 0, 5u);
      }
LABEL_23:
      result = *((_DWORD *)hdc + 2) & 3;
      if ( (_BYTE)result == 3 )
      {
        v22.left = rcUpdate.right;
        v22.bottom = *((_DWORD *)hdc + 31);
        v22.right = *((_DWORD *)hdc + 30);
        v7 = *(HWND *)hdc;
        v22.top = 0;
        result = RedrawWindow(v7, &v22, 0, 5u);
      }
      return result;
    }
  }
  return result;
}

//----- (6F7C3D3A) --------------------------------------------------------
LONG __stdcall ListView_IInvalidateBelow(int a1, int a2)
{
  LONG v2; // eax@3
  LONG result; // eax@4
  HWND v4; // ST04_4@6
  RECT rcUpdate; // [sp+8h] [bp-10h]@2

  if ( a2 < 0 )
  {
    rcUpdate.right = *(_DWORD *)(a1 + 120);
    v2 = *(_DWORD *)(a1 + 124);
    rcUpdate.top = 0;
    rcUpdate.left = 0;
    rcUpdate.bottom = v2;
  }
  else
  {
    ListView_GetRects(a1, a2, 0, 0, &rcUpdate, 0);
  }
  result = rcUpdate.top;
  if ( rcUpdate.top <= *(_DWORD *)(a1 + 124) )
  {
    result = *(_DWORD *)(a1 + 120);
    if ( rcUpdate.left <= result )
    {
      rcUpdate.right = *(_DWORD *)(a1 + 120);
      RedrawWindow(*(HWND *)a1, &rcUpdate, 0, 5u);
      rcUpdate.top = rcUpdate.bottom;
      rcUpdate.bottom = *(_DWORD *)(a1 + 124);
      v4 = *(HWND *)a1;
      rcUpdate.left = 0;
      result = RedrawWindow(v4, &rcUpdate, 0, 5u);
    }
  }
  return result;
}

//----- (6F7C3DBD) --------------------------------------------------------
unsigned int __stdcall ListView_OnUpdate(HDC hdc, int a2)
{
  int v2; // eax@1

  v2 = *((_DWORD *)hdc + 2);
  if ( *((_DWORD *)hdc + 2) & 3 && (*((_DWORD *)hdc + 2) & 3) != 2 )
  {
    ListView_LRInvalidateBelow(hdc, a2, 0);
  }
  else if ( v2 & 0x100 )
  {
    ListView_OnArrange(hdc, 0);
  }
  else
  {
    RedrawWindow(*(HWND *)hdc, 0, 0, 0x42u);
  }
  return ListView_UpdateScrollBars(hdc);
}

//----- (6F7C3E11) --------------------------------------------------------
int __stdcall ListView_OnDeleteAllItems(HDPA hdpa)
{
  int v1; // esi@1
  int v2; // edi@1
  INT_PTR v3; // ebx@3
  INT_PTR v4; // edi@12
  struct _DPA *v5; // eax@13
  bool v6; // zf@16
  HDPA hdpaa; // [sp+14h] [bp+8h]@1
  struct _DPA *hdpab; // [sp+14h] [bp+8h]@13

  v1 = (int)hdpa;
  v2 = ~(unsigned __int8)(*((_DWORD *)hdpa + 2) >> 12) & 1;
  ListView_DismissEdit((int)hdpa, 1);
  *((_DWORD *)hdpa + 25) = -1;
  *((_DWORD *)hdpa + 26) = -1;
  *((_DWORD *)hdpa + 61) = -1;
  hdpaa = (HDPA)ListView_Notify((int)hdpa, -1, 0, -104);
  ListView_InvalidateTTLastHit(v1, *(_DWORD *)(v1 + 156));
  if ( v2 || !hdpaa )
  {
    v3 = *(_DWORD *)(v1 + 372);
    while ( 1 )
    {
      --v3;
      if ( v3 < 0 )
        break;
      if ( !hdpaa )
        ListView_Notify(v1, v3, 0, -103);
      if ( v2 )
      {
        ListView_FreeItem(v1, *(LPVOID *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * v3));
        --**(_DWORD **)(v1 + 40);
        --*(_DWORD *)(v1 + 372);
      }
    }
  }
  if ( *(_DWORD *)(v1 + 8) & 0x1000 )
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(v1 + 364) + 32))(*(_DWORD *)(v1 + 364));
    *(_DWORD *)(v1 + 372) = 0;
  }
  else
  {
    DPA_DeleteAllPtrs(*(HDPA *)(v1 + 40));
    DPA_DeleteAllPtrs(*(HDPA *)(v1 + 216));
    *(_DWORD *)(v1 + 372) = 0;
    if ( *(_DWORD *)(v1 + 316) )
    {
      v4 = *(_DWORD *)(v1 + 312);
      while ( 1 )
      {
        --v4;
        if ( v4 < 0 )
          break;
        v5 = (struct _DPA *)DPA_GetPtr(*(HDPA *)(v1 + 316), v4);
        hdpab = v5;
        if ( v5 )
        {
          DPA_EnumCallback(v5, ListView_FreeColumnData, 0);
          DPA_DeleteAllPtrs(hdpab);
        }
      }
    }
  }
  v6 = (*(_DWORD *)(v1 + 44) & 0x400) == 0;
  *(_DWORD *)(v1 + 228) = 0x7FFFFFFF;
  *(_DWORD *)(v1 + 180) = 0;
  *(_DWORD *)(v1 + 136) = 0;
  *(_DWORD *)(v1 + 332) = 0;
  *(_DWORD *)(v1 + 336) = 0;
  if ( v6 )
    *(_DWORD *)(v1 + 184) = *(_DWORD *)(v1 + 172) + 16 * *(_DWORD *)(v1 + 88);
  RedrawWindow(*(HWND *)v1, 0, 0, 5u);
  ListView_UpdateScrollBars((HDC)v1);
  return 1;
}

//----- (6F7C3F6C) --------------------------------------------------------
int __stdcall ListView_IFindNearestItem(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // eax@1
  int v6; // esi@1
  signed int v7; // esi@2
  signed int v8; // edi@2
  int v9; // eax@23
  int v10; // ecx@25
  int v12; // edi@27
  int v13; // eax@28
  int v14; // edx@33
  int v15; // esi@36
  int v16; // eax@36
  bool v17; // sf@40
  bool v18; // zf@45
  bool v19; // sf@45
  int v20; // eax@56
  int v21; // edx@61
  int v22; // [sp+Ch] [bp-2Ch]@33
  int v23; // [sp+10h] [bp-28h]@36
  int v24; // [sp+14h] [bp-24h]@68
  int v25; // [sp+1Ch] [bp-1Ch]@25
  unsigned int v26; // [sp+20h] [bp-18h]@22
  int v27; // [sp+24h] [bp-14h]@25
  int v28; // [sp+28h] [bp-10h]@1
  int v29; // [sp+2Ch] [bp-Ch]@22
  int v30; // [sp+30h] [bp-8h]@22
  int v31; // [sp+34h] [bp-4h]@32
  int v32; // [sp+40h] [bp+8h]@22
  int v33; // [sp+44h] [bp+Ch]@2
  int v34; // [sp+4Ch] [bp+14h]@34

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 8);
  v6 = -1;
  v28 = -1;
  if ( !(v5 & 0x1000) )
  {
    v26 = 0;
    v29 = 0;
    v32 = 0;
    v30 = 0;
    if ( v5 & 3 )
      v9 = *(_DWORD *)(v4 + 188);
    else
      v9 = *(_DWORD *)(v4 + 212);
    v10 = *(_DWORD *)(v4 + 372);
    v27 = v9;
    v25 = v10;
    if ( v10 == 1 )
      return 0;
    v12 = a4;
    if ( a4 == 36 )
    {
      v32 = *(_DWORD *)(v4 + 240);
      v29 = *(_DWORD *)(v4 + 240);
      v13 = *(_DWORD *)(v4 + 236);
    }
    else
    {
      if ( a4 != 35 )
        goto LABEL_32;
      v32 = *(_DWORD *)(v4 + 232);
      v29 = *(_DWORD *)(v4 + 232);
      v13 = *(_DWORD *)(v4 + 228);
    }
    v30 = v13;
LABEL_32:
    v31 = 0;
    if ( v10 <= 0 )
      return v6;
    while ( 1 )
    {
      ListView_GetRects(v4, v31, (int)&v22, 0, 0, 0);
      v14 = v22 - a2;
      if ( v22 - a2 >= 0 )
        v34 = v22 - a2;
      else
        v34 = -v14;
      v15 = v23 - a3;
      v16 = v23 - a3;
      if ( v23 - a3 < 0 )
        v16 = -v16;
      if ( v12 == 37 )
      {
        if ( v34 < (unsigned int)v16 )
          goto LABEL_71;
        v17 = v14 < 0;
        goto LABEL_41;
      }
      if ( v12 == 39 )
        break;
      if ( v12 == 38 )
      {
        if ( v34 > (unsigned int)v16 )
          goto LABEL_71;
        v17 = v15 < 0;
LABEL_41:
        if ( v17 )
          goto LABEL_56;
        goto LABEL_71;
      }
      if ( v12 == 40 )
      {
        if ( v34 > (unsigned int)v16 )
          goto LABEL_71;
        v18 = v23 == a3;
        v19 = v15 < 0;
LABEL_46:
        if ( !v19 && !v18 )
          goto LABEL_56;
        goto LABEL_71;
      }
      if ( v12 != 36 )
      {
        if ( v12 == 35 )
        {
          if ( v23 > v29 || v23 + v27 > v32 && v24 > v30 )
          {
            v28 = v31;
            v30 = v24;
            v29 = v23;
            if ( v23 > v32 )
              v32 = v23;
          }
          goto LABEL_71;
        }
LABEL_56:
        v20 = v34 * v34 + v16 * v16;
        if ( v28 == -1 || v26 > v20 )
        {
          v26 = v20;
          v28 = v31;
        }
        goto LABEL_71;
      }
      if ( v23 + v27 < v29 )
      {
        v21 = v22;
LABEL_64:
        v28 = v31;
        v30 = v21;
        v29 = v23;
        if ( v23 + v27 < v32 )
          v32 = v23 + v27;
        goto LABEL_71;
      }
      if ( v23 < v32 )
      {
        v21 = v22;
        if ( v22 < v30 )
          goto LABEL_64;
      }
LABEL_71:
      ++v31;
      if ( v31 >= v25 )
        return v28;
    }
    if ( v34 < (unsigned int)v16 )
      goto LABEL_71;
    v18 = v22 == a2;
    v19 = v14 < 0;
    goto LABEL_46;
  }
  v7 = a2 + *(_DWORD *)(a1 + 220);
  v8 = a3 + *(_DWORD *)(a1 + 224);
  v33 = ListView_GetSlotCount(a1, 1);
  v6 = ListView_CalcHitSlot(a1, v7, v8, v33);
  if ( a4 == 35 )
  {
    v6 = *(_DWORD *)(a1 + 372);
    goto LABEL_17;
  }
  if ( a4 == 36 )
  {
LABEL_19:
    v6 = 0;
    goto LABEL_20;
  }
  if ( a4 == 37 )
  {
    if ( !(v6 % v33) )
      goto LABEL_18;
LABEL_17:
    --v6;
    goto LABEL_18;
  }
  if ( a4 == 38 )
  {
    if ( v6 >= v33 )
      v6 -= v33;
  }
  else if ( a4 == 39 )
  {
    if ( (v6 + 1) % v33 )
      ++v6;
  }
  else if ( a4 == 40 && v6 + v33 < *(_DWORD *)(a1 + 372) )
  {
    v6 += v33;
  }
LABEL_18:
  if ( v6 < 0 )
    goto LABEL_19;
LABEL_20:
  if ( *(_DWORD *)(a1 + 372) - 1 < v6 )
    v6 = *(_DWORD *)(a1 + 372) - 1;
  return v6;
}

//----- (6F7C41D2) --------------------------------------------------------
int __stdcall ListView_Arrow(HDC hdc, int a2, unsigned int a3)
{
  HDC v3; // esi@1
  int v4; // edx@1
  int v5; // eax@1
  int v6; // ecx@1
  int v7; // edi@3
  int result; // eax@14
  int v9; // eax@27
  signed int v10; // eax@37
  int v11; // eax@45
  int v12; // edi@49
  int v13; // ebx@49
  int v14; // eax@50
  int v15; // eax@56
  int v16; // edx@58
  signed int v17; // edi@63
  int v18; // eax@64
  int v19; // eax@69
  int v20; // edx@71
  int v21; // [sp-Ch] [bp-28h]@39
  int v22; // [sp+Ch] [bp-10h]@1
  int v23; // [sp+10h] [bp-Ch]@1
  int v24; // [sp+14h] [bp-8h]@1
  int v25; // [sp+18h] [bp-4h]@1
  HDC hdca; // [sp+24h] [bp+8h]@1

  v22 = 0;
  v3 = hdc;
  v4 = *((_DWORD *)hdc + 93);
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v5 = *((_DWORD *)hdc + 2);
  v6 = v5 & 3;
  hdca = (HDC)v4;
  if ( (v5 & 3) != 1 && v6 != 3 )
  {
    v7 = a3;
    if ( v5 & 0x1000 )
    {
      if ( a2 < 0 )
        a2 = 0;
      if ( a3 != 37 && a3 != 39 && a3 != 38 && a3 != 40 && a3 != 36 && a3 != 35 && a3 != 34 && a3 != 33 )
        return -1;
    }
    else if ( a2 == -1 )
    {
      goto LABEL_18;
    }
    ListView_GetRects((int)v3, a2, (int)&v22, 0, 0, 0);
LABEL_18:
    if ( a3 == 33 )
    {
      v9 = v23 - *((_DWORD *)v3 + 31);
      v7 = 40;
    }
    else
    {
      if ( a3 == 34 )
      {
        v9 = *((_DWORD *)v3 + 31) + v23;
        v23 += *((_DWORD *)v3 + 31);
        v7 = 38;
        return ListView_IFindNearestItem((int)v3, v22, v9, v7);
      }
      if ( a3 == 35 )
      {
        v22 = *((_DWORD *)v3 + 59);
        v9 = *((_DWORD *)v3 + 60);
      }
      else
      {
        if ( a3 != 36 )
        {
          if ( a3 <= 0x24 || a3 > 0x28 )
            return -1;
          if ( *((_DWORD *)v3 + 2) & 0x1000 || a2 != -1 )
          {
            v9 = v23;
            return ListView_IFindNearestItem((int)v3, v22, v9, v7);
          }
          v7 = 36;
        }
        v22 = -*((_DWORD *)v3 + 55);
        v9 = -*((_DWORD *)v3 + 56);
      }
    }
    v23 = v9;
    return ListView_IFindNearestItem((int)v3, v22, v9, v7);
  }
  switch ( a3 )
  {
    case 0x25u:
      if ( v6 != 1 )
      {
        result = a2 - *((_DWORD *)v3 + 48);
        goto LABEL_74;
      }
      if ( GetAsyncKeyState(17) >= 0 )
        v10 = 0;
      else
        v10 = 2;
      v21 = v10;
      goto LABEL_43;
    case 0x27u:
      if ( v6 == 1 )
      {
        v21 = 2 * (GetAsyncKeyState(17) < 0) + 1;
LABEL_43:
        ListView_ROnScroll(v3, v21, 0, 0);
        result = a2;
      }
      else
      {
        result = *((_DWORD *)v3 + 48) + a2;
      }
      goto LABEL_74;
    case 0x26u:
      v11 = a2;
      goto LABEL_55;
    case 0x28u:
      result = a2 + 1;
      goto LABEL_74;
    case 0x23u:
      result = v4 - 1;
      goto LABEL_74;
    case 0x22u:
      if ( v6 == 1 )
      {
        v12 = *((_DWORD *)v3 + 81);
        v13 = *((_DWORD *)v3 + 31);
        result = (v13 + *((_DWORD *)v3 + 84) - *((_DWORD *)v3 + 47) - v12) / *((_DWORD *)v3 + 47);
        if ( result <= a2 )
        {
          v14 = (v13 - v12) / *((_DWORD *)v3 + 47) - 1;
          if ( v14 <= 1 )
            v14 = 1;
          result = a2 + v14;
        }
        if ( result >= v4 )
        {
          v11 = v4;
LABEL_55:
          result = v11 - 1;
        }
      }
      else
      {
        v15 = (*((_DWORD *)v3 + 30) + 2 * *((_DWORD *)v3 + 46) / 3) / *((_DWORD *)v3 + 46);
        if ( !v15 )
          v15 = 1;
        v16 = *((_DWORD *)v3 + 48);
        result = v15 * *((_DWORD *)v3 + 48) + a2;
        if ( v16 && result >= (signed int)hdca )
        {
          do
            result -= v16;
          while ( result >= (signed int)hdca );
        }
      }
      goto LABEL_74;
    case 0x21u:
      if ( v6 == 1 )
      {
        v17 = *((_DWORD *)v3 + 47);
        result = *((_DWORD *)v3 + 84) / v17;
        if ( result >= a2 )
        {
          v18 = (*((_DWORD *)v3 + 31) - *((_DWORD *)v3 + 81)) / v17 - 1;
          if ( v18 <= 1 )
            v18 = 1;
          result = a2 - v18;
        }
        if ( result < 0 )
LABEL_68:
          result = 0;
      }
      else
      {
        v19 = (*((_DWORD *)v3 + 30) + 2 * *((_DWORD *)v3 + 46) / 3) / *((_DWORD *)v3 + 46);
        if ( !v19 )
          v19 = 1;
        v20 = *((_DWORD *)v3 + 48);
        result = a2 - v19 * *((_DWORD *)v3 + 48);
        if ( v20 )
        {
          if ( result >= 0 )
            goto LABEL_75;
          do
            result += v20;
          while ( result < 0 );
        }
LABEL_74:
        if ( result < 0 )
          goto LABEL_76;
      }
LABEL_75:
      if ( result < (signed int)hdca )
        return result;
LABEL_76:
      result = -(hdca != (HDC)1);
      break;
    case 0x24u:
      goto LABEL_68;
    default:
      return -1;
  }
  return result;
}

//----- (6F7C44CB) --------------------------------------------------------
int __stdcall ListView_OnGetNextItem(HDC a1, int a2, int a3)
{
  int result; // eax@1
  HDC v4; // esi@1
  int v5; // ebx@3
  int v6; // ecx@7
  int v7; // edi@9
  unsigned int v8; // ecx@15
  __int16 v9; // cx@23
  signed int v10; // [sp-4h] [bp-18h]@12
  int v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1
  int v13; // [sp+1Ch] [bp+8h]@5

  result = a2;
  v4 = a1;
  v11 = a2;
  v12 = *((_DWORD *)a1 + 93);
  if ( a2 < -1 )
    goto LABEL_32;
  if ( a2 >= *((_DWORD *)a1 + 93) )
    goto LABEL_32;
  v5 = a3;
  if ( *((_DWORD *)a1 + 2) & 0x1000 )
  {
    if ( a3 & 0x2C )
      goto LABEL_32;
  }
  v13 = a3 & 1;
  if ( a3 & 1 && !(a3 & 0xF00) )
  {
    v6 = *((_DWORD *)v4 + 25);
    if ( a2 >= v6 )
      goto LABEL_32;
    result = v6 - 1;
    a2 = v6 - 1;
  }
  v7 = a3 & 0xF00;
  while ( 1 )
  {
    if ( !v7 )
    {
      ++result;
      a2 = result;
      if ( result == v12 )
        goto LABEL_32;
      goto LABEL_21;
    }
    if ( v5 & 0x100 )
    {
      v10 = 38;
    }
    else
    {
      if ( !(v5 & 0x200) )
      {
        v8 = (v5 & 0x800 | 0x9400u) >> 10;
        goto LABEL_17;
      }
      v10 = 40;
    }
    v8 = v10;
LABEL_17:
    if ( result == -1 )
      return result;
    result = ListView_Arrow(v4, result, v8);
    a2 = result;
    if ( result == -1 )
      return result;
LABEL_21:
    if ( !(v5 & 0xFFFFF0FF) )
      return result;
    if ( *((_DWORD *)v4 + 2) & 0x1000 )
      break;
    v9 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 10) + 4) + 4 * result) + 24);
    if ( v13 && !(v9 & 1) )
      goto LABEL_32;
    if ( (!(v5 & 2) || v9 & 2) && (!(v5 & 4) || v9 & 4) && (!(v5 & 8) || v9 & 8) )
      return result;
    if ( result == v11 )
      goto LABEL_32;
  }
  if ( v13 )
  {
    if ( v5 & 2 )
    {
      if ( !(*(int (__stdcall **)(_DWORD, int))(**((_DWORD **)v4 + 91) + 36))(*((_DWORD *)v4 + 91), result) )
        goto LABEL_42;
LABEL_32:
      result = -1;
    }
  }
  else
  {
    if ( !(v5 & 2) )
      goto LABEL_32;
    if ( result <= 0 )
    {
      result = 0;
      a2 = 0;
    }
    (*(void (__stdcall **)(_DWORD, int, int *))(**((_DWORD **)v4 + 91) + 44))(*((_DWORD *)v4 + 91), result, &a2);
LABEL_42:
    result = a2;
  }
  return result;
}

//----- (6F7C4623) --------------------------------------------------------
int __stdcall ListView_OnFindItem(int a1, signed int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@2
  int v5; // ebx@3
  int v6; // edx@10
  int v7; // esi@12
  int v8; // eax@13
  int v9; // ecx@13
  const WCHAR *v10; // edi@21
  int v11; // ebx@24
  int v12; // [sp+4h] [bp-4h]@3
  int v13; // [sp+18h] [bp+10h]@9

  v3 = a3;
  if ( !a3 )
    return -1;
  v5 = *(_DWORD *)a3;
  v12 = *(_DWORD *)a3;
  if ( !(*(_DWORD *)a3 & 0x40) )
  {
    if ( a2 >= -1 )
    {
      v13 = *(_DWORD *)(a1 + 372);
      if ( a2 < *(_DWORD *)(a1 + 372) )
      {
        v6 = *(_DWORD *)(a1 + 8);
        if ( v6 & 0x1000 )
          return (int)ListView_RequestFindItem(a1, (const void *)v3, a2 + 1);
        v7 = a2;
        if ( v5 & 1 )
        {
          v8 = *(_DWORD *)(v3 + 8);
          v9 = *(_DWORD *)(a1 + 372);
          while ( v9 )
          {
            --v9;
            ++v7;
            if ( v7 == v13 )
            {
              if ( !(v5 & 0x20) )
                return -1;
              v7 = 0;
            }
            if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v7) + 28) == v8 )
              return v7;
          }
        }
        else
        {
          v10 = *(const WCHAR **)(v3 + 4);
          if ( v10 )
          {
            if ( v6 & 0x30 )
              return ListView_LookupString(a1, v10, v5, a2 + 1);
            v11 = *(_DWORD *)(a1 + 372);
            while ( v11 )
            {
              --v11;
              ++v7;
              if ( v7 == v13 )
              {
                if ( !(v12 & 0x20) )
                  return -1;
                v7 = 0;
              }
              if ( !ListView_CompareString(a1, v7, v10, v12 & 0xC, 0) )
                return v7;
            }
          }
        }
      }
    }
    return -1;
  }
  if ( *(_DWORD *)(a1 + 8) & 3 && (*(_DWORD *)(a1 + 8) & 3) != 2 )
    result = -1;
  else
    result = ListView_IFindNearestItem(a1, *(_DWORD *)(a3 + 12), *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
  return result;
}

//----- (6F7C4729) --------------------------------------------------------
signed int __stdcall ListView_OnGetItemRect(int a1, int a2, struct tagRECT *a3)
{
  LONG v3; // eax@3
  signed int result; // eax@5
  LPRECT lprcDst; // [sp+8h] [bp-10h]@5
  int v6; // [sp+Ch] [bp-Ch]@5
  int v7; // [sp+10h] [bp-8h]@5
  LPRECT v8; // [sp+14h] [bp-4h]@5

  if ( (unsigned int)a2 < *(_DWORD *)(a1 + 372) && a3 && (v3 = a3->left, a3->left < 4) && v3 >= 0 )
  {
    lprcDst = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    *(&lprcDst + v3) = a3;
    ListView_GetRects(a1, a2, v6, v7, lprcDst, v8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C478A) --------------------------------------------------------
signed int __stdcall ListView_OnRedrawItems(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@2

  v3 = *(_DWORD *)(a1 + 372);
  v4 = a2;
  if ( a2 < v3 )
  {
    v5 = a3;
    if ( a3 >= v3 )
      v5 = v3 - 1;
    while ( v4 <= v5 )
      ListView_InvalidateItemEx(a1, v4++, 0, 5u, 0);
  }
  return 1;
}

//----- (6F7C47CF) --------------------------------------------------------
int __stdcall ListView_OnSetItemPosition(int hdc, INT_PTR i, int a3, int a4)
{
  int result; // eax@2
  int v5; // ebx@4
  int v6; // eax@12
  int v7; // ecx@16
  int v8; // ecx@17
  struct tagMSG Msg; // [sp+4h] [bp-1Ch]@18

  if ( (*(_BYTE *)(hdc + 8) & 3) == 3 || *(_DWORD *)(hdc + 8) & 0x1000 )
  {
    result = 0;
  }
  else
  {
    v5 = (int)DPA_GetPtr(*(HDPA *)(hdc + 40), i);
    if ( v5 )
    {
      if ( (unsigned int)(a3 - 61440) <= 0xFFF )
        a3 -= 0x10000;
      if ( (unsigned int)(a4 - 61440) <= 0xFFF )
        a4 -= 0x10000;
      ListView_InvalidateTTLastHit(hdc, *(_DWORD *)(hdc + 156));
      if ( *(_WORD *)(v5 + 18) == 0x7FFF )
        ListView_RecomputeLabelSize(hdc, v5, i, 0, 0);
      v6 = *(_DWORD *)(v5 + 8);
      if ( a4 != v6 || a3 != *(_DWORD *)(v5 + 4) )
      {
        if ( v6 == 0x7FFFFFFF )
        {
          v7 = *(_DWORD *)(hdc + 388);
          if ( v7 )
          {
            v8 = v7 - 1;
            *(_DWORD *)(hdc + 388) = v8;
            if ( !v8 )
              PeekMessageW(&Msg, *(HWND *)hdc, 0x400u, 0x400u, 1u);
          }
        }
        else
        {
          ListView_InvalidateItemEx(hdc, i, 0, 5u, 0);
        }
        if ( a4 == 0x7FFFFFFF )
        {
          if ( !*(_DWORD *)(hdc + 388) )
            PostMessageW(*(HWND *)hdc, 0x400u, 0, 0);
          ++*(_DWORD *)(hdc + 388);
        }
      }
      LV_AdjustViewRectOnMove(hdc, v5, a3, a4);
      ListView_RecalcRegion(hdc, 0, 1);
      ListView_InvalidateItemEx(hdc, i, 0, 1u, 0);
      if ( (*(_BYTE *)(hdc + 44) & 0x12) == 18 )
      {
        if ( *(_DWORD *)(hdc + 8) & 0x100 )
          ListView_OnArrange((HDC)hdc, 0);
        else
          ListView_UpdateScrollBars((HDC)hdc);
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (6F7C492B) --------------------------------------------------------
const WCHAR *__stdcall ListView_OnGetStringWidthA(int a1, LPCSTR lpMultiByteStr, HDC hdc)
{
  const WCHAR *result; // eax@2
  void *v4; // edi@3
  LONG v5; // esi@4

  if ( lpMultiByteStr )
  {
    result = (const WCHAR *)ProduceWFromA(*(_DWORD *)(a1 + 20), lpMultiByteStr);
    v4 = (void *)result;
    if ( result )
    {
      v5 = ListView_OnGetStringWidth(a1, result, hdc);
      FreeProducedString(v4);
      result = (const WCHAR *)v5;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C496F) --------------------------------------------------------
LRESULT __stdcall ListView_ISetColumnWidth(int a1, WPARAM wParam, int a3, int a4)
{
  int v4; // eax@1

  v4 = *(_DWORD *)(a1 + 8) & 3;
  if ( v4 == 3 )
  {
    if ( !wParam && a3 > 0 )
    {
      if ( *(_DWORD *)(a1 + 184) != a3 && (a4 || !(*(_DWORD *)(a1 + 44) & 0x400)) )
      {
        *(_DWORD *)(a1 + 184) = a3;
        if ( a4 )
          *(_DWORD *)(a1 + 44) |= 0x400u;
        if ( *(_DWORD *)(a1 + 48) & 0x4000 )
          ListView_InvalidateTTLastHit(a1, *(_DWORD *)(a1 + 156));
        RedrawWindow(*(HWND *)a1, 0, 0, 5u);
        ListView_UpdateScrollBars((HDC)a1);
      }
      return 1;
    }
    return 0;
  }
  if ( v4 != 1 )
  {
    if ( a3 && *(_DWORD *)(a1 + 184) != a3 && (a4 || !(*(_DWORD *)(a1 + 44) & 0x400)) )
    {
      *(_DWORD *)(a1 + 184) = a3;
      if ( a4 )
        *(_DWORD *)(a1 + 44) |= 0x400u;
      RedrawWindow(*(HWND *)a1, 0, 0, 5u);
      ListView_UpdateScrollBars((HDC)a1);
    }
    return 0;
  }
  if ( *(_DWORD *)(a1 + 48) & 0x4000 )
    ListView_InvalidateTTLastHit(a1, *(_DWORD *)(a1 + 156));
  return ListView_RSetColumnWidth(a1, wParam, a3);
}

//----- (6F7C4A5C) --------------------------------------------------------
int __stdcall SHDrawText(HDC hdc, int a2, RECT *lprc, int a4, int a5, int a6, int a7, int a8, COLORREF color)
{
  int result; // eax@1
  HDC v10; // ebx@1
  int v11; // eax@5
  COLORREF v12; // edi@15
  COLORREF v13; // esi@18
  char v14; // cl@19
  HBRUSH v15; // ebx@19
  int v16; // esi@20
  DWORD v17; // eax@21
  void *v18; // eax@25
  COLORREF v19; // eax@41
  HBRUSH v20; // eax@41
  UINT v21; // eax@52
  LONG v22; // ecx@61
  UINT align; // [sp+Ch] [bp-24Ch]@0
  signed int v24; // [sp+14h] [bp-244h]@1
  struct tagSIZE sz; // [sp+18h] [bp-240h]@19
  UINT options; // [sp+20h] [bp-238h]@1
  struct tagRECT rc; // [sp+24h] [bp-234h]@5
  COLORREF v28; // [sp+34h] [bp-224h]@1
  HDC hDC; // [sp+38h] [bp-220h]@1
  void *Src; // [sp+3Ch] [bp-21Ch]@1
  int cchText; // [sp+40h] [bp-218h]@10
  char Dst[528]; // [sp+44h] [bp-214h]@13

  result = a2;
  v10 = hdc;
  hDC = hdc;
  Src = (void *)a2;
  v28 = 0;
  options = 0;
  v24 = 0;
  if ( a2 )
  {
    result = IsRectEmpty(lprc);
    if ( !result )
    {
      if ( a5 & 0x800 )
      {
        align = GetTextAlign(hdc);
        SetTextAlign(hdc, align | 0x100);
      }
      v11 = g_cxLabelMargin;
      rc.left = lprc->left;
      rc.top = lprc->top;
      rc.right = lprc->right;
      rc.bottom = lprc->bottom;
      if ( a5 & 0x40 )
        v11 = 3 * g_cxLabelMargin;
      rc.left += v11;
      rc.right -= v11;
      result = rc.right;
      if ( rc.left < rc.right || a5 & 0x118 )
      {
        if ( a5 & 2 && ListView_NeedsEllipses(hdc, (LPCWSTR)Src, (int)&rc, (int)&cchText, a7) )
        {
          if ( (unsigned int)cchText >= 0x104 )
            cchText = 259;
          memmove(Dst, Src, 2 * cchText);
          StringCchCopyW((STRSAFE_LPWSTR)&Dst[2 * cchText], 263 - cchText, L"...");
          a4 = 0;
          cchText += 3;
          Src = Dst;
        }
        else
        {
          cchText = lstrlenW((LPCWSTR)Src);
        }
        v12 = color;
        if ( color == -1 && !(a5 & 0x108) || a5 & 0x80 )
        {
          v24 = 1;
          v13 = SetTextColor(hdc, (unsigned __int8)(a5 & 0x80) == 0 ? a8 : 0);
LABEL_49:
          if ( a5 & 0x20 )
            OffsetRect(&rc, g_cxBorder, g_cyBorder);
          if ( a5 & 1 )
          {
            v21 = 43025;
            if ( a5 & 0x400 )
              v21 = 305169;
            if ( !(a5 & 4) )
              v21 |= 0x100u;
            if ( a5 & 0x1000 )
              v21 |= 0x80000u;
            result = DrawTextW(v10, (LPCWSTR)Src, cchText, &rc, v21);
          }
          else
          {
            if ( a4 )
            {
              sz.cx = 0;
              sz.cy = 0;
              GetTextExtentPointW(v10, (LPCWSTR)Src, cchText, &sz);
              if ( a4 == 2 )
                v22 = (rc.left + rc.right - sz.cx) / 2;
              else
                v22 = rc.right - sz.cx;
              rc.left = v22;
            }
            else
            {
              v22 = rc.left;
            }
            rc.top += (rc.bottom - rc.top - a6) / 2;
            if ( a5 & 4 )
              options |= 4u;
            result = ExtTextOutW(v10, v22, rc.top, options, lprc, (LPCWSTR)Src, cchText, 0);
          }
          if ( a5 & 0x98 )
          {
            result = SetTextColor(v10, v13);
            if ( !v24 )
              result = SetBkColor(v10, v28);
          }
          if ( a5 & 0x800 )
            result = SetTextAlign(v10, align);
          return result;
        }
        v14 = a5;
        v15 = 0;
        sz.cy = 0;
        options = 2;
        if ( a5 & 8 )
        {
          v16 = g_clrHighlightText;
          v28 = a5 & 0x200;
          if ( a5 & 0x200 )
          {
            v17 = GetSysColor(26);
            v14 = a5;
            v12 = v17;
          }
          else
          {
            v12 = g_clrHighlight;
          }
          if ( !(v14 & 1) )
            goto LABEL_45;
          if ( v28 )
          {
            v18 = GetSysColorBrush(26);
LABEL_44:
            v15 = (HBRUSH)v18;
            goto LABEL_45;
          }
LABEL_31:
          v15 = g_hbrHighlight;
          goto LABEL_45;
        }
        if ( a5 & 0x100 )
        {
          if ( color == -16777216 )
            v12 = g_clrWindow;
          if ( v12 != g_clrBtnFace )
          {
            v16 = g_clrBtnText;
            v12 = g_clrBtnFace;
            if ( a5 & 1 )
              v15 = g_hbrBtnFace;
            goto LABEL_45;
          }
          v16 = g_clrHighlightText;
          v12 = g_clrHighlight;
          if ( a5 & 1 )
            goto LABEL_31;
        }
        else
        {
          v16 = a8;
          if ( a8 == -16777216 )
          {
            v16 = g_clrWindowText;
            if ( color == -16777216 )
            {
              v12 = g_clrWindow;
              if ( (a5 & 0x11) == 17 )
                v15 = g_hbrWindow;
              goto LABEL_45;
            }
          }
          else if ( color == -16777216 )
          {
            v12 = g_clrWindow;
          }
          if ( (a5 & 0x11) == 17 )
          {
            v19 = GetNearestColor(hDC, v12);
            v20 = CreateSolidBrush(v19);
            v15 = v20;
            if ( v20 )
            {
              sz.cy = (LONG)v20;
              goto LABEL_45;
            }
            v18 = GetStockObject(0);
            goto LABEL_44;
          }
        }
LABEL_45:
        v13 = SetTextColor(hDC, v16);
        v28 = SetBkColor(hDC, v12);
        if ( v15 )
        {
          FillRect(hDC, lprc, v15);
          if ( sz.cy )
            DeleteObject((HGDIOBJ)sz.cy);
        }
        v10 = hDC;
        goto LABEL_49;
      }
    }
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;
// 6F7C4A5C: using guessed type char Dst[528];

//----- (6F7C4EFC) --------------------------------------------------------
HGDIOBJ __stdcall ListView_OnCreateDragImage(int nHeight, INT_PTR i, HGDIOBJ h)
{
  int v3; // edi@1
  HGDIOBJ result; // eax@2
  LONG v5; // edx@9
  int v6; // esi@9
  HDC v7; // ebx@9
  int v8; // eax@18
  HIMAGELIST v9; // eax@18
  struct _IMAGELIST *v10; // esi@18
  int v11; // [sp+8h] [bp-D4h]@14
  int *v12; // [sp+Ch] [bp-D0h]@14
  int v13; // [sp+10h] [bp-CCh]@14
  int v14; // [sp+14h] [bp-C8h]@14
  int v15; // [sp+18h] [bp-C4h]@14
  HDC v16; // [sp+30h] [bp-ACh]@14
  INT_PTR v17; // [sp+44h] [bp-98h]@14
  struct tagRECT v18; // [sp+5Ch] [bp-80h]@7
  int v19; // [sp+6Ch] [bp-70h]@20
  INT_PTR v20; // [sp+70h] [bp-6Ch]@20
  int v21; // [sp+74h] [bp-68h]@20
  int v22; // [sp+78h] [bp-64h]@20
  int v23; // [sp+7Ch] [bp-60h]@20
  int v24; // [sp+88h] [bp-54h]@20
  struct tagRECT rcDst; // [sp+94h] [bp-48h]@7
  struct tagRECT rc; // [sp+A4h] [bp-38h]@7
  LONG v27; // [sp+B4h] [bp-28h]@9
  LONG v28; // [sp+B8h] [bp-24h]@9
  struct tagRECT v29; // [sp+BCh] [bp-20h]@7
  int w; // [sp+CCh] [bp-10h]@9
  HGDIOBJ v31; // [sp+D0h] [bp-Ch]@1
  HGDIOBJ ho; // [sp+D4h] [bp-8h]@1
  struct _IMAGELIST *v33; // [sp+D8h] [bp-4h]@1
  LONG nHeighta; // [sp+E4h] [bp+8h]@9
  HBITMAP ha; // [sp+ECh] [bp+10h]@10

  ho = 0;
  v31 = 0;
  v3 = nHeight;
  v33 = (struct _IMAGELIST *)(*(_DWORD *)(nHeight + 24) & 0x400000);
  if ( h )
  {
    if ( i < 0 || i >= *(_DWORD *)(nHeight + 372) )
    {
      result = 0;
    }
    else
    {
      if ( *(_DWORD *)(nHeight + 392) == i )
      {
        ListView_OnSetHotItem(nHeight, -1);
        UpdateWindow(*(HWND *)nHeight);
      }
      ListView_GetRects(nHeight, i, (int)&rc, (int)&v18, &rcDst, &v29);
      if ( !(*(_BYTE *)(nHeight + 8) & 3) )
      {
        ListView_UnfoldRects(nHeight, i, &rc, &v18, &rcDst, &v29);
        InflateRect(&rc, -g_cxIconMargin, -g_cyIconMargin);
      }
      v5 = rc.top;
      v27 = rcDst.left - v29.left;
      v28 = rcDst.top - rc.top;
      v6 = v29.right - v29.left;
      w = v29.right - v29.left;
      nHeighta = v29.bottom - rc.top;
      *(_DWORD *)h = v29.left;
      *((_DWORD *)h + 1) = v5;
      v7 = CreateCompatibleDC(0);
      if ( v7 )
      {
        ha = CreateColorBitmap(v6, nHeighta);
        if ( ha )
        {
          ho = CreateMonoBitmap(v6, nHeighta);
          if ( ho )
          {
            if ( v33 )
              SetLayout(v7, 1u);
            SelectObject(v7, *(HGDIOBJ *)(v3 + 56));
            SetBkMode(v7, 1);
            v15 = 0;
            v13 = 0;
            v17 = i;
            v11 = v3;
            v16 = v7;
            v12 = (int *)&v27;
            v14 = 135;
            v31 = SelectObject(v7, ha);
            PatBlt(v7, 0, 0, w, nHeighta, 0x42u);
            ListView_DrawItem((int)&v11);
            if ( v33 )
              MirrorBitmapInDC(v7, ha);
            v14 = 135;
            SelectObject(v7, ho);
            PatBlt(v7, 0, 0, w, nHeighta, 0xFF0062u);
            ListView_DrawItem((int)&v11);
            if ( v33 )
              MirrorBitmapInDC(v7, ho);
            SelectObject(v7, v31);
            SelectObject(v7, g_hfontSystem);
            v8 = ListView_OnGetImageList(v3, (*(_BYTE *)(v3 + 8) & 3) != 0);
            v33 = (struct _IMAGELIST *)v8;
            v9 = ImageList_Clone((struct _IMAGELIST *)v8, w, nHeighta, 1u, 1, 0);
            v10 = v9;
            v31 = (HGDIOBJ)v9;
            if ( v9 )
            {
              ImageList_SetBkColor(v9, 0xFFFFFFFF);
              ImageList_Add(v10, ha, (HBITMAP)ho);
              if ( v33 )
              {
                v21 = 0;
                v20 = i;
                v19 = 10;
                v23 = 3840;
                ListView_OnGetItem(v3, (HDPA)v3, (int)&v19);
                ImageList_CopyDitherImage(
                  (void *)(v22 & 0xF00),
                  (struct _IMAGELIST *)v31,
                  0,
                  rc.left - v29.left,
                  0,
                  v33,
                  v24,
                  v22 & 0xF00 | (*(_DWORD *)(v3 + 24) >> 15) & 0x80);
              }
            }
          }
        }
        DeleteObject(v7);
        if ( ha )
          DeleteObject(ha);
        if ( ho )
          DeleteObject(ho);
      }
      result = v31;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7C51BB) --------------------------------------------------------
void __stdcall ListView_InvalidateFoldedItem(int a1, INT_PTR i, int a3, UINT flags)
{
  RECT rcUpdate; // [sp+8h] [bp-10h]@4

  ListView_InvalidateItemEx(a1, i, a3, flags, 0);
  if ( !(*(_BYTE *)(a1 + 8) & 3) && (!ListView_IsItemUnfolded(a1, i) || flags & 4) )
  {
    if ( ListView_GetUnfoldedRect(a1, i, &rcUpdate) )
      RedrawWindow(*(HWND *)a1, &rcUpdate, 0, flags | 4);
  }
}

//----- (6F7C5220) --------------------------------------------------------
unsigned int __stdcall LV_OnShowWindow(HDC a1, int a2)
{
  unsigned int result; // eax@2

  if ( a2 )
  {
    result = *((_DWORD *)a1 + 11);
    if ( !(result & 2) )
    {
      *((_DWORD *)a1 + 11) = result | 2;
      result = ListView_UpdateScrollBars(a1);
    }
  }
  else
  {
    result = (unsigned int)a1;
    *(_DWORD *)(result + 44) &= 0xFFFFFFFD;
  }
  return result;
}

//----- (6F7C5253) --------------------------------------------------------
int __stdcall ListView_BullyIconsOnWorkarea(int a1, HDPA hdpa)
{
  int v2; // edi@1
  bool v3; // zf@1
  bool v4; // sf@1
  PVOID v5; // eax@2
  int v6; // ecx@2
  INT_PTR v7; // edx@2
  int v8; // esi@2
  int v9; // eax@2
  int v10; // ebx@2
  int v11; // edx@2
  signed int v12; // ecx@2
  int v13; // eax@2
  int v14; // edx@2
  int v15; // ebx@8
  int v16; // eax@14
  int v17; // ebx@14
  int v18; // edx@14
  LONG v19; // eax@14
  int v20; // eax@15
  int v21; // eax@15
  LPARAM lParam; // [sp+4h] [bp-C4h]@1
  int v24; // [sp+14h] [bp-B4h]@14
  int v25; // [sp+58h] [bp-70h]@1
  INT_PTR v26; // [sp+5Ch] [bp-6Ch]@14
  int v27; // [sp+60h] [bp-68h]@1
  int v28; // [sp+78h] [bp-50h]@14
  int v29; // [sp+80h] [bp-48h]@14
  char v30; // [sp+84h] [bp-44h]@15
  struct tagRECT rcDst; // [sp+88h] [bp-40h]@2
  RECT rcSrc2; // [sp+98h] [bp-30h]@14
  int v33; // [sp+A8h] [bp-20h]@1
  int v34; // [sp+ACh] [bp-1Ch]@3
  int v35; // [sp+B4h] [bp-14h]@2
  INT_PTR v36; // [sp+B8h] [bp-10h]@2
  INT_PTR i; // [sp+BCh] [bp-Ch]@1
  int v38; // [sp+C0h] [bp-8h]@2
  int v39; // [sp+C4h] [bp-4h]@2

  v33 = -1;
  v2 = a1;
  ListView_BeginFakeCustomDraw(a1, (LPARAM)&lParam, (int)&v25);
  v3 = *(_DWORD *)hdpa == 0;
  v4 = *(_DWORD *)hdpa < 0;
  v25 = 4;
  v27 = 0;
  i = 0;
  if ( !v4 && !v3 )
  {
    do
    {
      v5 = DPA_GetPtr(hdpa, i);
      v6 = *(_DWORD *)(v2 + 132);
      v7 = (INT_PTR)v5;
      v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 40) + 4) + 4 * (_DWORD)v5);
      v38 = *(_DWORD *)(v8 + 4);
      v39 = *(_DWORD *)(v8 + 8);
      v9 = v6 + 16 * *(_WORD *)(v8 + 22);
      v10 = *(_DWORD *)(v9 + 8) - *(_DWORD *)v9;
      v35 = *(_DWORD *)(v9 + 12) - *(_DWORD *)(v9 + 4);
      v36 = v7;
      ListView_GetRects(v2, v7, 0, 0, &rcDst, 0);
      v11 = *(_DWORD *)(v2 + 132);
      v12 = rcDst.right - rcDst.left;
      a1 = rcDst.bottom - rcDst.top;
      v13 = v11 + 16 * *(_WORD *)(v8 + 22);
      v14 = *(_DWORD *)v13;
      v39 -= *(_DWORD *)(v13 + 4);
      v38 -= v14;
      if ( v38 >= (rcDst.right - rcDst.left) / -2 )
      {
        if ( v38 <= v10 - v12 / 2 )
          v34 = v38;
        else
          v34 = v10 - v12;
      }
      else
      {
        v34 = 0;
      }
      if ( v39 >= a1 / -2 )
      {
        if ( v39 <= v35 - a1 / 2 )
          v15 = v39;
        else
          v15 = v35 - a1;
      }
      else
      {
        v15 = 0;
      }
      if ( v34 != v38 || v15 != v39 )
      {
        v16 = *(_DWORD *)(v2 + 132) + 16 * *(_WORD *)(v8 + 22);
        v17 = *(_DWORD *)(v16 + 4) + v15;
        v18 = *(_DWORD *)v16 + v34;
        v19 = v18 - *(_DWORD *)(v2 + 220);
        v34 = v18;
        rcSrc2.left = v19;
        rcSrc2.right = v12 + v19;
        rcSrc2.top = v17 - *(_DWORD *)(v2 + 224);
        v26 = v36;
        v28 = *(_DWORD *)(v8 + 28);
        rcSrc2.bottom = a1 + rcSrc2.top;
        ListView_BeginFakeItemDraw((LPARAM)&lParam);
        if ( ListView_IsCleanRect(v2, &rcSrc2, v36, (int)&v29, v24)
          || (a1 = 0,
              v20 = ListView_GetSlotCountEx(v2, 0, *(_WORD *)(v8 + 22)),
              v35 = v20,
              v21 = ListView_FindFreeSlot(v2, v36, v33 + 1, v20, (int)&v30, (int)&a1, v24),
              v33 = v21,
              v21 == -1) )
        {
          ListView_EndFakeItemDraw((LPARAM)&lParam);
          ListView_OnSetItemPosition(v2, v36, v34, v17);
        }
        else
        {
          ListView_SetIconPos(v2, v8, v21, v35);
          ListView_EndFakeItemDraw((LPARAM)&lParam);
        }
      }
      ++i;
    }
    while ( i < *(_DWORD *)hdpa );
  }
  return ListView_EndFakeCustomDraw((LPARAM)&lParam);
}

//----- (6F7C5481) --------------------------------------------------------
int __stdcall ListView_OnSetWorkAreas(int hdc, void *p, RECT *lprc)
{
  int v3; // esi@1
  int v4; // edi@1
  int v5; // ebx@1
  int v6; // eax@1
  void *v7; // eax@7
  int result; // eax@10
  int v9; // edi@12
  int v10; // eax@17
  int v11; // edi@21
  int v12; // ebx@24
  unsigned int v13; // ebx@29
  POINT v14; // ST10_8@30
  bool v15; // zf@30
  int v16; // eax@38
  struct _DPA *v17; // edi@43
  int v18; // eax@49
  int v19; // eax@50
  int Dst; // [sp+Ch] [bp-118h]@2
  int v21[63]; // [sp+10h] [bp-114h]@30
  struct tagRECT rcDst; // [sp+10Ch] [bp-18h]@30
  int v23; // [sp+11Ch] [bp-8h]@1
  HDPA hdpa; // [sp+120h] [bp-4h]@1
  HDC hdca; // [sp+12Ch] [bp+8h]@1
  void *pa; // [sp+130h] [bp+Ch]@20

  v3 = hdc;
  v4 = *(_DWORD *)(hdc + 128);
  v5 = 0;
  v6 = *(_DWORD *)(hdc + 8) & 0x100;
  hdpa = 0;
  hdca = (HDC)v6;
  v23 = v4;
  if ( v4 > 0 )
    memmove(&Dst, *(const void **)(v3 + 132), 16 * v4);
  if ( p && lprc && (!IsRectEmpty(lprc) || *(_DWORD *)(v3 + 24) & 0x400000) )
  {
    v7 = (void *)16;
    if ( (signed int)p < 16 )
      v7 = p;
    *(_DWORD *)(v3 + 128) = v7;
    if ( !*(_DWORD *)(v3 + 132) )
    {
      result = (int)LocalAlloc(0x40u, 0x100u);
      *(_DWORD *)(v3 + 132) = result;
      if ( !result )
        return result;
    }
    if ( *(_DWORD *)(v3 + 128) > 0 )
    {
      v9 = 0;
      do
      {
        CopyRect((LPRECT)(v9 * 16 + *(_DWORD *)(v3 + 132)), &lprc[v9]);
        ++v5;
        ++v9;
      }
      while ( v5 < *(_DWORD *)(v3 + 128) );
      v4 = v23;
    }
  }
  else
  {
    *(_DWORD *)(v3 + 128) = 0;
  }
  if ( *(_DWORD *)(v3 + 8) & 0x1000 )
    return RedrawWindow(*(HWND *)v3, 0, 0, 5u);
  v10 = *(_DWORD *)(v3 + 128);
  if ( v10 <= 0 || v10 == v4 && EqualRects(*(RECT **)(v3 + 132), (int)&Dst, v4) )
    return RedrawWindow(*(HWND *)v3, 0, 0, 5u);
  ListView_Recompute(v3);
  pa = 0;
  if ( *(_DWORD *)(v3 + 372) <= 0 )
    goto LABEL_47;
  do
  {
    v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * (_DWORD)pa);
    if ( *(_DWORD *)(v11 + 4) == 0x7FFFFFFF || *(_DWORD *)(v11 + 8) == 0x7FFFFFFF )
      goto LABEL_42;
    if ( v23 <= 0 )
    {
      if ( ListView_FindWorkArea(v3, *(POINT *)(v11 + 4), v11 + 22) )
        goto LABEL_37;
      v15 = hdca == 0;
LABEL_33:
      if ( v15 )
        goto LABEL_34;
      goto LABEL_37;
    }
    v12 = *(_WORD *)(v11 + 22);
    if ( v12 < *(_DWORD *)(v3 + 128) )
    {
      if ( hdca )
        goto LABEL_37;
      v13 = 16 * v12;
      if ( EqualRect((const RECT *)(v13 + *(_DWORD *)(v3 + 132)), (const RECT *)((char *)&Dst + v13)) )
        goto LABEL_37;
      *(_DWORD *)(v11 + 4) += *(_DWORD *)(*(_DWORD *)(v3 + 132) + v13) - *(int *)((char *)&Dst + v13);
      *(_DWORD *)(v11 + 8) += *(_DWORD *)(v13 + *(_DWORD *)(v3 + 132) + 4) - v21[v13 / 4];
      ListView_GetRects(v3, (int)pa, 0, 0, &rcDst, 0);
      v14.y = *(_DWORD *)(v11 + 8) + (rcDst.bottom - rcDst.top) / 2;
      v14.x = *(_DWORD *)(v11 + 4) + (rcDst.right - rcDst.left) / 2;
      v15 = PtInRect((const RECT *)(v13 + *(_DWORD *)(v3 + 132)), v14) == 0;
      goto LABEL_33;
    }
    *(_WORD *)(v11 + 22) = 0;
    if ( !hdca )
    {
      if ( PtInRect(*(const RECT **)(v3 + 132), *(POINT *)(v11 + 4)) )
      {
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(*(_DWORD *)(v3 + 132) + 8) + 1;
        *(_DWORD *)(v3 + 244) = -1;
      }
LABEL_34:
      if ( hdpa || (hdpa = DPA_Create(4)) != 0 )
        DPA_InsertPtr(hdpa, 0x7FFFFFFF, pa);
    }
LABEL_37:
    if ( *(_DWORD *)(v3 + 48) & 0x200 )
    {
      v16 = *(_DWORD *)(v11 + 32);
      if ( v16 )
      {
        if ( v16 != -1 )
          DeleteObject(*(HGDIOBJ *)(v11 + 32));
        *(_DWORD *)(v11 + 32) = 0;
      }
    }
LABEL_42:
    pa = (char *)pa + 1;
  }
  while ( (signed int)pa < *(_DWORD *)(v3 + 372) );
  v17 = hdpa;
  if ( hdpa )
  {
    if ( *(_DWORD *)hdpa > 0 )
      ListView_BullyIconsOnWorkarea(v3, hdpa);
    DPA_Destroy(v17);
  }
LABEL_47:
  if ( *(_DWORD *)(v3 + 48) & 0x200 )
    ListView_RecalcRegion(v3, 1, 1);
  v18 = *(_DWORD *)(v3 + 8);
  if ( v18 & 0x100 )
  {
    v19 = v18 & 3;
    if ( v19 == 2 || !v19 )
      ListView_OnArrange((HDC)v3, 0);
  }
  return RedrawWindow(*(HWND *)v3, 0, 0, 5u);
}
// 6F7C5481: using guessed type int var_114[63];

//----- (6F7C578C) --------------------------------------------------------
signed int __stdcall LVGenerateDragImage(signed int a1, int a2)
{
  int v2; // esi@1
  bool v3; // zf@1
  signed int result; // eax@4
  int i; // edi@5
  int v6; // eax@6
  HWND v7; // ST08_4@7
  HDC v8; // eax@11
  LONG v9; // ebx@14
  LONG v10; // edi@14
  int v11; // eax@15
  LONG v12; // ecx@15
  LONG v13; // eax@23
  int v14; // ecx@24
  LONG v15; // edx@24
  int v16; // edi@32
  LONG v17; // eax@32
  HDC v18; // ST0C_4@32
  int v19; // ST10_4@32
  int v20; // eax@32
  HBITMAP v21; // eax@32
  int v22; // ecx@33
  HDC v23; // ebx@33
  LONG v24; // eax@34
  LONG v25; // eax@36
  LONG v26; // ecx@36
  int v27; // ebx@36
  int v28; // edx@39
  int v29; // edx@41
  int v30; // ST04_4@42
  struct tagRECT v31; // [sp+8h] [bp-BCh]@42
  int v32; // [sp+18h] [bp-ACh]@36
  int *v33; // [sp+1Ch] [bp-A8h]@43
  int v34; // [sp+20h] [bp-A4h]@36
  int v35; // [sp+24h] [bp-A0h]@43
  int v36; // [sp+28h] [bp-9Ch]@36
  HDC v37; // [sp+40h] [bp-84h]@36
  int v38; // [sp+54h] [bp-70h]@42
  int v39; // [sp+60h] [bp-64h]@43
  int v40; // [sp+64h] [bp-60h]@43
  struct tagRECT Rect; // [sp+6Ch] [bp-58h]@5
  RECT rcSrc2; // [sp+7Ch] [bp-48h]@42
  HGDIOBJ h; // [sp+8Ch] [bp-38h]@33
  LPARAM lParam; // [sp+90h] [bp-34h]@7
  int v45; // [sp+94h] [bp-30h]@33
  int v46; // [sp+98h] [bp-2Ch]@33
  int v47; // [sp+9Ch] [bp-28h]@33
  LONG v48; // [sp+A0h] [bp-24h]@42
  LONG v49; // [sp+A4h] [bp-20h]@42
  int v50; // [sp+A8h] [bp-1Ch]@1
  LONG v51; // [sp+ACh] [bp-18h]@24
  HDC hdc; // [sp+B0h] [bp-14h]@11
  struct tagRECT rcDst; // [sp+B4h] [bp-10h]@1

  v2 = a1;
  v3 = (*(_DWORD *)(a1 + 8) & 0x1000) == 0;
  v50 = *(_DWORD *)(a1 + 136);
  rcDst.left = 0;
  rcDst.top = 0;
  rcDst.right = 0;
  rcDst.bottom = 0;
  if ( !v3 )
    (*(void (__stdcall **)(_DWORD, int *))(**(_DWORD **)(a1 + 364) + 52))(*(_DWORD *)(a1 + 364), &v50);
  if ( v50 )
  {
    GetClientRect(*(HWND *)v2, &Rect);
    a1 = -1;
    for ( i = v50 - 1; i >= 0; --i )
    {
      v6 = ListView_OnGetNextItem((HDC)v2, a1, 2);
      a1 = v6;
      if ( v6 != -1 )
      {
        v7 = *(HWND *)v2;
        lParam = 3;
        if ( SendMessageW(v7, 0x100Eu, v6, (LPARAM)&lParam) )
        {
          if ( RectInRect(&Rect, (RECT *)&lParam) )
            UnionRect(&rcDst, &rcDst, (const RECT *)&lParam);
        }
      }
    }
    v8 = CreateCompatibleDC(0);
    hdc = v8;
    if ( !v8 )
      goto LABEL_50;
    if ( *(_DWORD *)(v2 + 24) & 0x400000 )
      SetLayout(v8, 1u);
    v9 = rcDst.right;
    v10 = rcDst.left;
    if ( rcDst.right - rcDst.left > 300 )
    {
      v11 = *(_DWORD *)(v2 + 448);
      v12 = 150;
      if ( rcDst.left >= v11 - 150 )
        v12 = rcDst.left - v11 + 300;
      else
        rcDst.left = v11 - 150;
      if ( rcDst.right <= v11 + v12 )
      {
        if ( rcDst.left > v10 )
        {
          rcDst.left += rcDst.right - v11 - v12;
          if ( rcDst.left < v10 )
            rcDst.left = v10;
        }
      }
      else
      {
        v9 = v11 + v12;
        rcDst.right = v11 + v12;
      }
    }
    v13 = rcDst.bottom;
    if ( rcDst.bottom - rcDst.top > 300 )
    {
      v51 = rcDst.top;
      v14 = *(_DWORD *)(v2 + 452);
      v15 = 150;
      if ( rcDst.top >= v14 - 150 )
        v15 = rcDst.top - v14 + 300;
      else
        rcDst.top = v14 - 150;
      if ( rcDst.bottom <= v14 + v15 )
      {
        if ( rcDst.top > v51 )
        {
          rcDst.top += rcDst.bottom - v14 - v15;
          if ( rcDst.top < v51 )
            rcDst.top = v51;
        }
      }
      else
      {
        v13 = v14 + v15;
        rcDst.bottom = v14 + v15;
      }
    }
    v16 = a2;
    v17 = v13 - rcDst.top;
    v18 = hdc;
    *(_DWORD *)a2 = v9 - rcDst.left;
    *(_DWORD *)(v16 + 4) = v17;
    v19 = GetDeviceCaps(v18, 12);
    v20 = GetDeviceCaps(hdc, 14);
    v21 = CreateBitmap(*(_DWORD *)v16, *(_DWORD *)(v16 + 4), v20, v19, 0);
    *(_DWORD *)(v16 + 16) = v21;
    if ( v21 )
    {
      v22 = *(_DWORD *)v16;
      v23 = hdc;
      lParam = 0;
      v45 = 0;
      v46 = v22;
      v47 = *(_DWORD *)(v16 + 4);
      h = SelectObject(hdc, v21);
      *(_DWORD *)(v16 + 20) = 5570815;
      FillRectClr(v23, (RECT *)&lParam, 0x5500FFu);
      *(_DWORD *)(v16 + 20) = GetPixel(v23, 0, 0);
      if ( *(_DWORD *)(v2 + 24) & 0x400000 )
        v24 = rcDst.right - *(_DWORD *)(v2 + 448);
      else
        v24 = *(_DWORD *)(v2 + 448) - rcDst.left;
      v34 = 0;
      *(_DWORD *)(v16 + 8) = v24;
      v25 = rcDst.top;
      v26 = *(_DWORD *)(v2 + 452) - rcDst.top;
      v36 = 0;
      *(_DWORD *)(v16 + 12) = v26;
      v37 = v23;
      v27 = *(_DWORD *)(v2 + 372);
      v32 = v2;
      a1 = -1;
      while ( 1 )
      {
        --v27;
        if ( v27 < 0 )
          break;
        if ( *(_DWORD *)(v2 + 8) & 0x1000 )
        {
          ++a1;
          (*(void (__stdcall **)(_DWORD, signed int, signed int *))(**(_DWORD **)(v2 + 364) + 44))(
            *(_DWORD *)(v2 + 364),
            a1,
            &a1);
          v25 = rcDst.top;
        }
        else
        {
          v28 = *(_DWORD *)(v2 + 40);
          a1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 216) + 4) + 4 * v27);
          if ( !(*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v28 + 4) + 4 * a1) + 24) & 2) )
            a1 = -1;
        }
        v29 = a1;
        if ( a1 != -1 )
        {
          v49 = -v25;
          v51 = *(_DWORD *)(v2 + 108);
          v48 = -rcDst.left;
          v30 = a1;
          *(_DWORD *)(v2 + 108) = a1;
          v38 = v29;
          ListView_GetRects(v2, v30, 0, 0, &rcSrc2, 0);
          if ( IntersectRect(&v31, &Rect, &rcSrc2) )
          {
            v48 += rcSrc2.left;
            v49 += rcSrc2.top;
            v35 = 0;
            v33 = (int *)&v48;
            v39 = *(_DWORD *)(v2 + 68);
            v40 = *(_DWORD *)(v2 + 72);
            a2 = *(_DWORD *)(v2 + 60);
            *(_DWORD *)(v2 + 60) = *(_DWORD *)(v16 + 20);
            ListView_DrawItem((int)&v32);
            *(_DWORD *)(v2 + 60) = a2;
          }
          *(_DWORD *)(v2 + 108) = v51;
          v25 = rcDst.top;
        }
      }
      SelectObject(hdc, h);
      DeleteDC(hdc);
      result = 1;
    }
    else
    {
LABEL_50:
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7C5B11) --------------------------------------------------------
HLOCAL __stdcall ListView_OnDestroy(HDPA hdpa)
{
  HLOCAL result; // eax@12
  void *v2; // esi@12

  if ( IsWindow(*((HWND *)hdpa + 38)) )
    DestroyWindow(*((HWND *)hdpa + 38));
  if ( *((_DWORD *)hdpa + 102) )
    DestroyCursor(*((HCURSOR *)hdpa + 102));
  *((_DWORD *)hdpa + 38) = 0;
  Str_Set((int)((char *)hdpa + 164), 0);
  Str_Set((int)((char *)hdpa + 440), 0);
  TerminateDitherBrush();
  if ( !(*((_DWORD *)hdpa + 2) & 0x1000) )
    ListView_OnDeleteAllItems(hdpa);
  if ( *((_DWORD *)hdpa + 11) & 0x100 && *((_DWORD *)hdpa + 14) )
    DeleteObject(*((HGDIOBJ *)hdpa + 14));
  if ( *((_DWORD *)hdpa + 99) )
    DeleteObject(*((HGDIOBJ *)hdpa + 99));
  result = (HLOCAL)ListView_DeleteHrgnInval((int)hdpa);
  v2 = (void *)*((_DWORD *)hdpa + 33);
  if ( v2 )
    result = LocalFree(v2);
  return result;
}

//----- (6F7C5BC7) --------------------------------------------------------
unsigned int __stdcall ListView_OnWindowPosChanged(HDC hdc, unsigned int a2)
{
  unsigned int result; // eax@1
  int v3; // eax@3
  int v4; // ebx@3
  int v5; // eax@4
  int v6; // eax@7
  int v7; // eax@8
  int v8; // eax@12
  int v9; // eax@14
  struct tagRECT Rect; // [sp+0h] [bp-10h]@7

  result = a2;
  if ( !a2 || !(*(_BYTE *)(a2 + 24) & 1) )
  {
    v3 = *((_DWORD *)hdc + 2);
    v4 = 0;
    if ( v3 & 0x1000 )
    {
      v5 = v3 & 3;
      if ( v5 == 2 || !v5 )
        v4 = ListView_GetSlotCount((int)hdc, 1);
    }
    GetClientRect(*(HWND *)hdc, &Rect);
    *((_DWORD *)hdc + 30) = Rect.right;
    *((_DWORD *)hdc + 31) = Rect.bottom;
    v6 = *((_DWORD *)hdc + 2);
    if ( v6 & 0x100 )
    {
      v7 = v6 & 3;
      if ( v7 == 2 || !v7 )
        ListView_OnArrange(hdc, 0);
    }
    if ( *((_DWORD *)hdc + 2) & 0x1000 )
    {
      *((_DWORD *)hdc + 57) = 0x7FFFFFFF;
      ListView_Recompute((int)hdc);
      ListView_DismissEdit((int)hdc, 0);
      v8 = *((_DWORD *)hdc + 2) & 3;
      if ( v8 == 2 || !v8 )
      {
        v9 = ListView_GetSlotCount((int)hdc, 1);
        if ( v9 != v4 )
        {
          if ( v9 >= v4 )
            v9 = v4;
          if ( *((_DWORD *)hdc + 93) > v9 )
            RedrawWindow(*(HWND *)hdc, 0, 0, 5u);
        }
      }
    }
    ListView_RInitialize((int)hdc, 1);
    result = ListView_UpdateScrollBars(hdc);
  }
  return result;
}

//----- (6F7C5CAB) --------------------------------------------------------
BOOL __stdcall ListView_RedrawSelection(int a1)
{
  int v1; // esi@1
  int i; // eax@3
  int v3; // edi@5
  signed int v4; // ecx@7
  signed int v5; // edi@7
  int v6; // edx@7
  int j; // edi@9
  int v9; // [sp+4h] [bp-8h]@11
  char v10; // [sp+Ah] [bp-2h]@11
  int v11; // [sp+14h] [bp+8h]@7

  v1 = a1;
  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    ListView_InvalidateSelectedOrCutOwnerData(a1, *(_DWORD *)(a1 + 364));
  }
  else
  {
    for ( i = ListView_OnGetNextItem((HDC)a1, -1, 2); ; i = ListView_OnGetNextItem((HDC)a1, v3, 2) )
    {
      v3 = i;
      if ( i == -1 )
        break;
      ListView_InvalidateItemEx(a1, i, 1, 1u, 0);
    }
    if ( (*(_DWORD *)(a1 + 8) & 3) == 1 )
    {
      v4 = *(_DWORD *)(a1 + 336) - *(_DWORD *)(a1 + 324);
      v5 = *(_DWORD *)(a1 + 188);
      v6 = *(_DWORD *)(a1 + 372);
      v11 = (v4 + *(_DWORD *)(a1 + 124)) / v5 + 1;
      if ( (v4 + *(_DWORD *)(v1 + 124)) / v5 + 1 >= v6 )
        v11 = v6;
      for ( j = v4 / v5; j < v11; ++j )
      {
        if ( *(_DWORD *)(v1 + 312) > 1 )
        {
          ListView_GetSubItem(v1, j, 1, (int)&v9);
          if ( v10 & 2 )
            ListView_InvalidateItemEx(v1, j, 0, 1u, 0);
        }
      }
    }
  }
  return UpdateWindow(*(HWND *)v1);
}

//----- (6F7C5D79) --------------------------------------------------------
void __stdcall ListView_OnSetFocus(int a1, int a2)
{
  HWND v2; // eax@1
  int v3; // eax@4

  v2 = *(HWND *)a1;
  if ( a2 == *(_DWORD *)a1 )
  {
    ListView_NotifyFocusEvent(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 44) |= 0x81u;
    if ( IsWindowVisible(v2) )
    {
      v3 = *(_DWORD *)(a1 + 100);
      if ( v3 != -1 )
      {
        ListView_InvalidateItemEx(a1, v3, 1, 1u, 0);
        ListView_NotifyFocusEvent(a1);
      }
      ListView_RedrawSelection(a1);
    }
    CCSendNotify(a1, -7, 0);
  }
}

//----- (6F7C5DD8) --------------------------------------------------------
void __stdcall ListView_OnKillFocus(int a1, int a2)
{
  HWND v2; // eax@2
  INT_PTR v3; // eax@4
  UINT v4; // ecx@5

  gcWheelDelta = 0;
  if ( a1 )
  {
    v2 = *(HWND *)a1;
    if ( a2 != *(_DWORD *)a1 )
    {
      *(_DWORD *)(a1 + 44) &= 0xFFFFFF7E;
      if ( IsWindowVisible(v2) )
      {
        v3 = *(_DWORD *)(a1 + 100);
        if ( v3 != -1 )
        {
          v4 = 1;
          if ( *(_DWORD *)(a1 + 72) == -1 )
            v4 = 5;
          ListView_InvalidateFoldedItem(a1, v3, 1, v4);
        }
        ListView_RedrawSelection(a1);
      }
      CCSendNotify(a1, -8, 0);
      IncrementSearchString(a1 + 456, 0, 0);
    }
  }
}
// 6F7E8E5C: using guessed type int gcWheelDelta;

//----- (6F7C5E4D) --------------------------------------------------------
int __stdcall ListView_DeselectAll(INT_PTR i, int a2)
{
  INT_PTR v2; // edi@5
  int result; // eax@5
  int v4; // eax@9
  int v5; // eax@12
  int v6; // [sp+Ch] [bp-Ch]@1
  int v7; // [sp+10h] [bp-8h]@1
  signed int v8; // [sp+14h] [bp-4h]@1

  v6 = -1;
  v7 = 0;
  v8 = 0;
  if ( a2 != -1 && ListView_OnGetItemState(0, (struct _DPA *)i, a2, 2) )
    v8 = 1;
  if ( !(*(_DWORD *)(i + 8) & 0x1000) )
  {
    v4 = *(_DWORD *)(i + 100);
    if ( a2 != v4 )
      ListView_OnSetItemState(i, v4, 0, 2);
    v2 = i + 136;
    if ( *(_DWORD *)(i + 136) )
    {
      do
      {
        v5 = ListView_OnGetNextItem((HDC)i, v6, 2);
        v6 = v5;
        if ( v5 == -1 )
          break;
        if ( v5 == a2 )
        {
          if ( v8 )
            ++v7;
        }
        else
        {
          ListView_OnSetItemState(i, v5, 0, 2);
        }
      }
      while ( *(_DWORD *)v2 != v7 );
    }
    goto LABEL_18;
  }
  v2 = i + 136;
  result = (*(int (__stdcall **)(_DWORD, INT_PTR))(**(_DWORD **)(i + 364) + 52))(*(_DWORD *)(i + 364), i + 136);
  if ( *(_DWORD *)(i + 136) != 1 || !v8 )
  {
    ListView_InvalidateSelectedOrCutOwnerData(i, *(_DWORD *)(i + 364));
    ListView_OnSetItemState(i, -1, 0, 2);
    if ( v8 )
    {
      ListView_OnSetItemState(i, a2, 2, 2);
      result = 1;
LABEL_19:
      *(_DWORD *)v2 = result;
      return result;
    }
LABEL_18:
    result = v7;
    goto LABEL_19;
  }
  return result;
}

//----- (6F7C5F3D) --------------------------------------------------------
int __stdcall ListView_OnScroll(HDC hdc, int a2, int a3)
{
  int v3; // eax@1
  int v5; // edi@3
  signed int v6; // ecx@4
  signed int v7; // eax@5
  signed int v8; // eax@11

  v3 = *((_DWORD *)hdc + 2);
  if ( v3 & 0x2000 )
    return 0;
  v5 = *((_DWORD *)hdc + 2) & 3;
  if ( v5 == 3 )
  {
    v6 = *((_DWORD *)hdc + 46);
    if ( a2 >= 0 )
      v7 = a2 + v6 - 1;
    else
      v7 = 1 - v6 + a2;
    a2 = v7 / v6;
    if ( a3 )
      return 0;
  }
  else if ( v5 == 1 )
  {
    if ( a3 <= 0 )
      v8 = a3 - *((_DWORD *)hdc + 47) / 2;
    else
      v8 = a3 + *((_DWORD *)hdc + 47) / 2;
    a3 = v8 / *((_DWORD *)hdc + 47);
  }
  (*(&pfnListView_Scroll2 + v5))(hdc, a2, a3, 0);
  ListView_UpdateScrollBars(hdc);
  return 1;
}
// 6F7929AC: using guessed type int (__stdcall *pfnListView_Scroll2)(HDC hdc, int, int, int);

//----- (6F7C5FD9) --------------------------------------------------------
int __stdcall ListView_OnEnsureVisible(HDC hdc, int a2, int a3)
{
  int result; // eax@4
  int v4; // eax@7
  int v5; // ecx@14
  struct tagRECT rcDst; // [sp+8h] [bp-20h]@5
  int v7; // [sp+18h] [bp-10h]@5
  int v8; // [sp+1Ch] [bp-Ch]@14
  int v9; // [sp+20h] [bp-8h]@8
  int v10; // [sp+24h] [bp-4h]@15

  if ( (unsigned int)a2 >= *((_DWORD *)hdc + 93) || *((_DWORD *)hdc + 2) & 0x2000 )
  {
    result = 0;
  }
  else
  {
    ListView_CancelPendingTimer((int)hdc, 512, 0x2Bu);
    if ( (*((_DWORD *)hdc + 2) & 3) == 1 )
    {
      result = ListView_ROnEnsureVisible((int)hdc, a2, a3);
    }
    else
    {
      ListView_GetRects((int)hdc, a2, (int)&v7, 0, &rcDst, 0);
      if ( !a3 )
        *(_OWORD *)&v7 = rcDst;
      v4 = 0;
      if ( v7 < 0 || v9 >= *((_DWORD *)hdc + 30) )
      {
        v4 = rcDst.left;
        if ( rcDst.left >= 0 )
        {
          v4 = rcDst.right - *((_DWORD *)hdc + 30);
          if ( v4 > 0 )
          {
            if ( rcDst.left - v4 < 0 )
              v4 = rcDst.left;
          }
          else
          {
            v4 = 0;
          }
        }
      }
      v5 = 0;
      if ( v8 < 0 || v10 >= *((_DWORD *)hdc + 31) )
      {
        v5 = rcDst.top;
        if ( rcDst.top >= 0 )
        {
          v5 = rcDst.bottom - *((_DWORD *)hdc + 31);
          if ( rcDst.bottom - *((_DWORD *)hdc + 31) < 0 )
            v5 = 0;
        }
      }
      if ( v4 | v5 )
        result = ListView_OnScroll(hdc, v4, v5);
      else
        result = 1;
    }
  }
  return result;
}

//----- (6F7C60BD) --------------------------------------------------------
int __stdcall ListView_OnSetRedraw(HDC hdc, int a2)
{
  signed int v2; // edi@1
  int result; // eax@2
  int v4; // ecx@3
  int v5; // eax@3
  int v6; // eax@4
  int v7; // eax@7
  int v8; // eax@7
  int v9; // eax@9
  int v10; // edi@10
  int v11; // ecx@18

  v2 = 0;
  if ( a2 )
  {
    result = *((_DWORD *)hdc + 11);
    if ( result & 0x10 )
      return result;
    v4 = *((_DWORD *)hdc + 37);
    v5 = result | 0x10;
    *((_DWORD *)hdc + 11) = v5;
    if ( v4 )
    {
      v6 = v5 & 4 | 0x101;
      if ( v4 == 1 )
        *((_DWORD *)hdc + 37) = 0;
      RedrawWindow(*(HWND *)hdc, 0, *((HRGN *)hdc + 37), v6);
      ListView_DeleteHrgnInval((int)hdc);
      v2 = 1;
    }
    v7 = *((_DWORD *)hdc + 2);
    *((_DWORD *)hdc + 11) &= 0xFFFFFFFB;
    v8 = v7 & 3;
    if ( v8 != 3 && v8 != 1 )
    {
      v9 = *((_DWORD *)hdc + 28);
      if ( v9 != -1 )
      {
        v10 = *((_DWORD *)hdc + 93);
        if ( v9 < v10 )
        {
          do
            ListView_InvalidateItemEx((int)hdc, (*((_DWORD *)hdc + 28))++, 0, 1u, 0);
          while ( *((_DWORD *)hdc + 28) < v10 );
        }
        v2 = 1;
      }
      if ( v2 )
        ListView_RecalcRegion((int)hdc, 1, 1);
      if ( !(*((_DWORD *)hdc + 2) & 0x100) || !v2 )
        return ListView_UpdateScrollBars(hdc);
      return ListView_OnUpdate(hdc, *((_DWORD *)hdc + 28));
    }
    v11 = *((_DWORD *)hdc + 28);
    if ( v11 == -1 )
      return ListView_UpdateScrollBars(hdc);
    result = ListView_MaybeResizeListColumns((int)hdc, v11, *((_DWORD *)hdc + 93) - 1);
    if ( !result )
      return ListView_OnUpdate(hdc, *((_DWORD *)hdc + 28));
  }
  else
  {
    result = (int)hdc;
    *((_DWORD *)hdc + 28) = -1;
    *(_DWORD *)(result + 44) &= 0xFFFFFFEF;
  }
  return result;
}

//----- (6F7C61B6) --------------------------------------------------------
int __stdcall ListView_OnSetItem(INT_PTR i, INT_PTR a2)
{
  INT_PTR v2; // edi@1
  bool v3; // zf@1
  INT_PTR v5; // ebx@3
  int v6; // esi@10
  int v7; // ecx@12
  int v8; // eax@19
  __int16 v9; // cx@20
  int v10; // edx@23
  INT_PTR v11; // ebx@26
  int v12; // eax@26
  int v13; // ecx@43
  int v14; // eax@60
  int v15; // ebx@67
  int v16; // ebx@70
  HWND v17; // [sp-10h] [bp-4Ch]@78
  int v18; // [sp-8h] [bp-44h]@78
  RECT rcUpdate; // [sp+8h] [bp-34h]@37
  int v20; // [sp+18h] [bp-24h]@1
  int v21; // [sp+1Ch] [bp-20h]@1
  int v22; // [sp+20h] [bp-1Ch]@11
  int v23; // [sp+24h] [bp-18h]@1
  int v24; // [sp+28h] [bp-14h]@11
  int v25; // [sp+2Ch] [bp-10h]@11
  int v26; // [sp+30h] [bp-Ch]@10
  int v27; // [sp+34h] [bp-8h]@7
  UINT flags; // [sp+38h] [bp-4h]@1
  int ia; // [sp+44h] [bp+8h]@18

  v2 = i;
  v3 = (*(_DWORD *)(i + 8) & 0x1000) == 0;
  flags = 1;
  v23 = 0;
  v21 = 0;
  v20 = 0;
  if ( !v3 )
    return 0;
  v5 = a2;
  if ( !a2 )
    return 0;
  if ( *(_DWORD *)(i + 204) && *(_DWORD *)(i + 60) != ImageList_GetBkColor(*(HIMAGELIST *)(i + 204)) )
    flags = 5;
  v27 = *(_DWORD *)a2;
  if ( !v27 )
    return 1;
  if ( *(_DWORD *)(a2 + 8) > 0 )
    return ListView_SetSubItem((HDPA)i, a2);
  v26 = *(_DWORD *)(a2 + 4);
  ListView_InvalidateTTLastHit(i, v26);
  v6 = (int)DPA_GetPtr(*(HDPA *)(i + 40), v26);
  if ( !v6 )
    return 0;
  v25 = 0;
  v24 = 0;
  v22 = v27 & 8;
  if ( v27 & 8 )
  {
    v7 = *(_DWORD *)(a2 + 16);
    v24 = (unsigned __int16)(v7 & *(_WORD *)(v6 + 24));
    v25 = v7 & *(_DWORD *)(a2 + 12);
  }
  if ( *(_BYTE *)(i + 8) & 4 && v22 && v25 & 2 )
  {
    ListView_DeselectAll(i, v26);
    v24 = *(_DWORD *)(a2 + 16) & *(_WORD *)(v6 + 24);
  }
  if ( !ListView_SendChange(i, v26, 0, -100, v24, v25, v27, *(_DWORD *)(v6 + 28)) )
    return 0;
  ia = 0;
  if ( v22 )
  {
    v8 = *(_DWORD *)(a2 + 16) & (*(_DWORD *)(a2 + 12) ^ *(_WORD *)(v6 + 24));
    v22 = *(_DWORD *)(a2 + 16) & (*(_DWORD *)(a2 + 12) ^ *(_WORD *)(v6 + 24));
    if ( v22 )
    {
      *(_WORD *)(v6 + 24) ^= v8;
      v9 = *(_WORD *)(v6 + 24);
      ia = 8;
      if ( v8 & 2 )
      {
        v21 = 1;
        if ( v9 & 2 )
        {
          ++*(_DWORD *)(v2 + 136);
        }
        else
        {
          v10 = *(_DWORD *)(v2 + 136);
          if ( v10 )
            *(_DWORD *)(v2 + 136) = v10 - 1;
        }
      }
      if ( !(v8 & 1) )
        goto LABEL_39;
      v11 = *(_DWORD *)(v2 + 100);
      v20 = ListView_IsItemUnfolded(v2, *(_DWORD *)(v2 + 100));
      v12 = v26;
      v23 = 1;
      if ( v11 != v26 )
      {
        if ( v11 != -1 )
        {
          if ( !ListView_OnSetItemState(v2, v11, 0, 1) )
          {
            v23 = 0;
            *(_WORD *)(v6 + 24) &= 0xFFFEu;
            goto LABEL_34;
          }
          v12 = v26;
        }
        v3 = *(_DWORD *)(v2 + 104) == -1;
        *(_DWORD *)(v2 + 100) = v12;
        if ( v3 )
          *(_DWORD *)(v2 + 104) = v12;
        goto LABEL_34;
      }
      *(_DWORD *)(v2 + 100) = -1;
LABEL_34:
      if ( v20 && !ListView_IsItemUnfolded(v2, v11) && *(_DWORD *)(v2 + 108) != v11 )
      {
        ListView_GetUnfoldedRect(v2, v11, &rcUpdate);
        RedrawWindow(*(HWND *)v2, &rcUpdate, 0, 5u);
      }
      ListView_PopBubble(v2);
      v5 = a2;
      LOWORD(v8) = v22;
LABEL_39:
      if ( v8 & 4 || *(_DWORD *)(v2 + 72) == -1 )
        flags |= 4u;
      if ( v8 & 0xF00 )
      {
        v13 = *(_DWORD *)(v6 + 32);
        if ( v13 )
        {
          if ( v13 != -1 )
          {
            DeleteObject(*(HGDIOBJ *)(v6 + 32));
            LOWORD(v8) = v22;
          }
          *(_DWORD *)(v6 + 32) = 0;
        }
      }
      v20 = v8 & 0xF000;
      goto LABEL_48;
    }
  }
LABEL_48:
  if ( v27 & 1 )
  {
    if ( *(_DWORD *)(v2 + 108) != v26 )
      ListView_InvalidateItemEx(v2, v26, 0, 5u, 1);
    if ( !Str_Set(v6, *(LPCWSTR *)(v5 + 20)) )
      return 0;
    *(_DWORD *)(v2 + 228) = 0x7FFFFFFF;
    ListView_SetSRecompute(v6);
    ia |= 1u;
  }
  if ( v27 & 0x10 )
  {
    if ( *(_WORD *)(v6 + 26) != *(_DWORD *)(v5 + 36) )
    {
      ia |= 0x10u;
      *(_WORD *)(v6 + 26) = *(_WORD *)(v5 + 36);
      if ( (*(_DWORD *)(v2 + 8) & 3) == 1 )
        flags |= 4u;
    }
  }
  if ( v27 & 2 && *(_WORD *)(v6 + 12) != *(_DWORD *)(v5 + 28) )
  {
    ia |= 2u;
    *(_WORD *)(v6 + 12) = *(_WORD *)(v5 + 28);
    v14 = *(_DWORD *)(v6 + 32);
    if ( v14 )
    {
      if ( v14 != -1 )
        DeleteObject(*(HGDIOBJ *)(v6 + 32));
      *(_DWORD *)(v6 + 32) = 0;
    }
    if ( *(_WORD *)(v6 + 12) != -1 )
      flags |= 4u;
  }
  if ( v27 & 4 )
  {
    v15 = *(_DWORD *)(v5 + 32);
    if ( *(_DWORD *)(v6 + 28) != v15 )
    {
      ia |= 4u;
      *(_DWORD *)(v6 + 28) = v15;
    }
  }
  if ( ia )
  {
    v16 = v26;
    if ( *(_DWORD *)(v2 + 108) != v26 )
      ListView_InvalidateItemEx(v2, v26, 0, flags, ia);
    ListView_SendChange(v2, v16, 0, -101, v24, v25, ia, *(_DWORD *)(v6 + 28));
    if ( ia & 1 )
      MyNotifyWinEvent(32780, *(_DWORD *)v2, -4, v16 + 1);
    if ( ia & 8 )
    {
      if ( v23 )
        ListView_NotifyFocusEvent(v2);
      if ( v21 )
      {
        v18 = v16 + 1;
        v17 = *(HWND *)v2;
        if ( v25 & 2 )
          MyNotifyWinEvent((*(_DWORD *)(v2 + 136) != 1) + 32774, (int)v17, -4, v18);
        else
          MyNotifyWinEvent(32776, (int)v17, -4, v18);
      }
      if ( v20 )
        MyNotifyWinEvent(32778, *(_DWORD *)v2, -4, v16 + 1);
    }
  }
  return 1;
}

//----- (6F7C6550) --------------------------------------------------------
int __stdcall ListView_OnSetItemState(INT_PTR i, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  int result; // eax@1
  int v7; // edi@1
  int v8; // ecx@12
  int v9; // ecx@22
  INT_PTR v10; // ebx@25
  INT_PTR v11; // ebx@32
  INT_PTR v12; // ebx@36
  int v13; // eax@47
  char v14; // di@49
  int v15; // ecx@55
  int v16; // eax@56
  int v17; // eax@62
  bool v18; // zf@64
  int v19; // eax@72
  int v20; // eax@84
  int v21; // ebx@90
  int j; // eax@99
  int v23; // [sp-10h] [bp-4Ch]@40
  HWND v24; // [sp-Ch] [bp-48h]@40
  int v25; // [sp-Ch] [bp-48h]@55
  int v26; // [sp-4h] [bp-40h]@40
  signed int v27; // [sp-4h] [bp-40h]@93
  int v28; // [sp+Ch] [bp-30h]@1
  int v29; // [sp+10h] [bp-2Ch]@1
  int v30; // [sp+14h] [bp-28h]@1
  int v31; // [sp+18h] [bp-24h]@1
  int v32; // [sp+1Ch] [bp-20h]@1
  int v33; // [sp+34h] [bp-8h]@42
  UINT flags; // [sp+38h] [bp-4h]@1
  INT_PTR ia; // [sp+44h] [bp+8h]@72
  int v36; // [sp+50h] [bp+14h]@2

  v4 = i;
  v32 = a4;
  v5 = *(_DWORD *)(i + 8);
  result = 1;
  v7 = 0;
  flags = 1;
  v28 = 8;
  v31 = a3;
  v29 = a2;
  v30 = 0;
  if ( !(v5 & 0x1000) )
  {
    if ( a2 != -1 )
      return ListView_OnSetItem(i, (INT_PTR)&v28);
    v21 = 0;
    if ( a3 )
    {
      if ( v5 & 4 && a4 == 2 || (unsigned __int8)a4 & (unsigned __int8)a3 & 1 )
        return 0;
    }
    else
    {
      if ( a4 == 2 )
      {
        v27 = 2;
      }
      else
      {
        if ( a4 != 4 )
          goto LABEL_99;
        v27 = 4;
      }
      v21 = v27;
    }
LABEL_99:
    for ( j = ListView_OnGetNextItem((HDC)i, -1, v21); ; j = ListView_OnGetNextItem((HDC)i, v29, v21) )
    {
      v29 = j;
      if ( j == -1 )
        break;
      ListView_OnSetItem(i, (INT_PTR)&v28);
    }
    return 1;
  }
  v36 = a4 & 0xF;
  if ( !v36 )
    return result;
  if ( *(_DWORD *)(i + 72) == -1
    || *(_DWORD *)(i + 204) && *(_DWORD *)(i + 60) != ImageList_GetBkColor(*(HIMAGELIST *)(i + 204)) )
    flags = 5;
  if ( a2 != -1 )
  {
    if ( (unsigned int)a2 >= *(_DWORD *)(i + 372) )
      return 0;
    v33 = v36 & 2;
    if ( v36 & 2 )
    {
      if ( a3 & 2 ^ ((*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(i + 364) + 36))(*(_DWORD *)(i + 364), a2) != 0 ? 0 : 2) )
      {
        if ( a3 & 2 )
        {
          if ( *(_BYTE *)(i + 8) & 4 && !ListView_OnSetItemState(i, -1, 0, 2) )
            return 0;
          v13 = (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(i + 364) + 12))(*(_DWORD *)(i + 364), a2, a2);
        }
        else
        {
          v13 = (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)(i + 364) + 16))(*(_DWORD *)(i + 364), a2, a2);
        }
        if ( v13 < 0 )
          return 0;
        v14 = v36 ^ a3;
      }
      else
      {
        v14 = v36 & a3;
      }
      v7 = v14 & 2;
      (*(void (__stdcall **)(_DWORD, INT_PTR))(**(_DWORD **)(i + 364) + 52))(*(_DWORD *)(i + 364), i + 136);
    }
    if ( v36 & 4 )
    {
      if ( a3 & 4 ^ ((*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(i + 368) + 36))(*(_DWORD *)(i + 368), a2) != 0 ? 0 : 4) )
      {
        v15 = **(_DWORD **)(i + 368);
        v25 = *(_DWORD *)(i + 368);
        if ( a3 & 4 )
          v16 = (*(int (__stdcall **)(int, int, int))(v15 + 12))(v25, a2, a2);
        else
          v16 = (*(int (__stdcall **)(int, int, int))(v15 + 16))(v25, a2, a2);
        if ( v16 < 0 )
          return 0;
        v7 |= ((unsigned __int8)v36 ^ (unsigned __int8)a3) & 4;
        flags |= 4u;
      }
      else
      {
        v7 |= (unsigned __int8)v36 & (unsigned __int8)a3 & 4;
      }
    }
    if ( v36 & 1 )
    {
      v17 = *(_DWORD *)(i + 100);
      if ( a3 & 1 )
      {
        if ( a2 != v17 )
        {
          v18 = *(_DWORD *)(i + 104) == -1;
          *(_DWORD *)(i + 100) = a2;
          if ( v18 )
            *(_DWORD *)(i + 104) = a2;
          if ( v17 != -1 )
            ListView_SendChange(i, v17, 0, -101, 1, 0, 8, 0);
          goto LABEL_71;
        }
      }
      else
      {
        if ( a2 != v17 )
          goto LABEL_71;
        *(_DWORD *)(i + 100) = -1;
      }
      v7 |= 1u;
    }
LABEL_71:
    if ( !(v36 & 8) )
      goto LABEL_79;
    v19 = *(_DWORD *)(i + 376);
    ia = *(_DWORD *)(i + 376);
    if ( a3 & 8 )
    {
      if ( a2 != v19 )
      {
        *(_DWORD *)(v4 + 376) = a2;
        if ( v19 != -1 )
        {
          ListView_SendChange(v4, ia, 0, -101, 8, 0, 8, 0);
          ListView_InvalidateFoldedItem(v4, ia, 1, 5u);
        }
        goto LABEL_79;
      }
    }
    else
    {
      if ( a2 != v19 )
        goto LABEL_79;
      *(_DWORD *)(v4 + 376) = -1;
    }
    v7 |= 8u;
LABEL_79:
    if ( v7 == (v36 & a3) )
      return 1;
    ListView_SendChange(v4, a2, 0, -101, v7, a3, 8, 0);
    ListView_InvalidateItemEx(v4, a2, 1, flags, 0);
    if ( ((unsigned __int8)v7 ^ (unsigned __int8)(v36 & a3)) & 1 )
    {
      ListView_PopBubble(v4);
      ListView_NotifyFocusEvent(v4);
    }
    if ( !v33 )
      return 1;
    if ( a3 & 2 )
      v20 = (*(_DWORD *)(v4 + 136) != 1) + 32774;
    else
      v20 = 32776;
    v26 = a2 + 1;
    v24 = *(HWND *)v4;
    v23 = v20;
    goto LABEL_87;
  }
  if ( v36 & 2 )
  {
    if ( a3 & 2 )
    {
      if ( *(_BYTE *)(i + 8) & 4 )
        return 0;
      v8 = *(_DWORD *)(i + 372);
      if ( v8 )
      {
        if ( (*(int (__stdcall **)(_DWORD, _DWORD, int))(**(_DWORD **)(i + 364) + 12))(*(_DWORD *)(i + 364), 0, v8 - 1) < 0 )
          return 0;
      }
      RedrawWindow(*(HWND *)i, 0, 0, flags);
    }
    else if ( *(_DWORD *)(i + 136) <= 0u )
    {
      v36 &= 0xFFFFFFFD;
    }
    else
    {
      ListView_InvalidateSelectedOrCutOwnerData(i, *(_DWORD *)(i + 364));
      if ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(i + 364) + 32))(*(_DWORD *)(i + 364)) < 0 )
        return 0;
    }
    v7 = ((unsigned __int8)v36 ^ (unsigned __int8)a3) & 2;
    (*(void (__stdcall **)(_DWORD, INT_PTR))(**(_DWORD **)(i + 364) + 52))(*(_DWORD *)(i + 364), i + 136);
  }
  if ( v36 & 4 )
  {
    if ( a3 & 4 )
    {
      v9 = *(_DWORD *)(i + 372);
      if ( v9
        && (*(int (__stdcall **)(_DWORD, _DWORD, int))(**(_DWORD **)(i + 368) + 12))(*(_DWORD *)(i + 368), 0, v9 - 1) < 0 )
        return 0;
      RedrawWindow(*(HWND *)i, 0, 0, flags);
    }
    else
    {
      v10 = i + 368;
      if ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(i + 368) + 40))(*(_DWORD *)(i + 368)) )
      {
        ListView_InvalidateSelectedOrCutOwnerData(i, *(_DWORD *)v10);
        if ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)v10 + 32))(*(_DWORD *)v10) < 0 )
          return 0;
      }
      else
      {
        v36 &= 0xFFFFFFFB;
      }
    }
    v7 |= ((unsigned __int8)v36 ^ (unsigned __int8)a3) & 4;
  }
  if ( v36 & 1 )
  {
    if ( a3 & 1 )
      return 0;
    v11 = *(_DWORD *)(i + 100);
    if ( v11 != -1 )
    {
      *(_DWORD *)(i + 100) = -1;
      v7 |= ((unsigned __int8)v36 ^ (unsigned __int8)a3) & 1;
      ListView_SendChange(i, v11, 0, -101, 1, 0, 8, 0);
      ListView_InvalidateFoldedItem(i, v11, 1, 5u);
    }
  }
  if ( v36 & 8 )
  {
    if ( !(a3 & 8) )
    {
      v12 = *(_DWORD *)(i + 376);
      if ( v12 != -1 )
      {
        *(_DWORD *)(i + 376) = -1;
        v7 |= ((unsigned __int8)v36 ^ (unsigned __int8)a3) & 1;
        ListView_SendChange(i, v12, 0, -101, 8, 0, 8, 0);
        ListView_InvalidateFoldedItem(i, v12, 1, 5u);
      }
      goto LABEL_38;
    }
    return 0;
  }
LABEL_38:
  if ( v7 == (v36 & a3) )
    return 1;
  ListView_SendChange(i, -1, 0, -101, v7, a3, 8, 0);
  if ( !(v36 & 2) )
    return 1;
  v26 = 0;
  v24 = *(HWND *)i;
  v23 = 32777;
LABEL_87:
  MyNotifyWinEvent(v23, (int)v24, -4, v26);
  return 1;
}

//----- (6F7C6A2B) --------------------------------------------------------
int __stdcall ListView_IsItemUnfolded2(int a1, int a2, int a3, STRSAFE_LPWSTR pszDest, int a5)
{
  BOOL v5; // eax@1
  int v6; // edx@1
  bool v7; // zf@4
  signed int v8; // eax@7
  LONG v9; // esi@14
  int v10; // eax@16
  LPARAM lParam; // [sp+8h] [bp-89Ch]@14
  HDC hdc; // [sp+18h] [bp-88Ch]@16
  struct tagSIZE psizl; // [sp+5Ch] [bp-848h]@16
  int v15; // [sp+64h] [bp-840h]@4
  int v16; // [sp+68h] [bp-83Ch]@4
  int v17; // [sp+6Ch] [bp-838h]@4
  LPCWSTR lpString; // [sp+78h] [bp-82Ch]@10
  size_t cchDest; // [sp+7Ch] [bp-828h]@10
  struct tagRECT rc; // [sp+8Ch] [bp-818h]@6
  int v21; // [sp+9Ch] [bp-808h]@1
  __int16 v22; // [sp+A0h] [bp-804h]@10
  char Dst; // [sp+A2h] [bp-802h]@10

  v5 = ListView_IsItemUnfolded(a1, a2);
  v21 = v5;
  if ( pszDest )
  {
    if ( a5 > 0 )
    {
      *pszDest = 0;
      if ( !v5 )
      {
        v7 = (*(_BYTE *)(a1 + 8) & 3) == 0;
        v16 = v6;
        v17 = a3;
        v15 = 5;
        if ( v7 )
        {
          if ( ListView_GetUnfoldedRect(a1, v6, &rc) )
          {
            lpString = pszDest;
            cchDest = a5;
            ListView_OnGetItem((int)pszDest, (HDPA)a1, (int)&v15);
          }
          else
          {
            v21 = 1;
          }
        }
        else if ( *(_DWORD *)(a1 + 48) & 0x4400 )
        {
          rc.left = 2;
          if ( a3 )
          {
            rc.top = a3;
            v8 = ListView_OnGetSubItemRect(a1, v6, &rc);
          }
          else
          {
            v8 = ListView_OnGetItemRect(a1, v6, &rc);
          }
          if ( v8 )
          {
            v22 = 0;
            memset(&Dst, 0, 0x7FEu);
            lpString = (LPCWSTR)&v22;
            cchDest = 1024;
            if ( (unsigned int)a5 <= 0x400 )
              cchDest = a5;
            if ( ListView_OnGetItem((int)pszDest, (HDPA)a1, (int)&v15) && lpString != (LPCWSTR)-1 )
            {
              ListView_BeginFakeCustomDraw(a1, (LPARAM)&lParam, (int)&v15);
              ListView_BeginFakeItemDraw((LPARAM)&lParam);
              v9 = *(_DWORD *)(a1 + 120);
              if ( rc.right - g_cxLabelMargin < v9 )
                v9 = rc.right - g_cxLabelMargin;
              v10 = lstrlenW(lpString);
              if ( GetTextExtentPoint32W(hdc, lpString, v10, &psizl) && rc.left + g_cxLabelMargin + psizl.cx > v9 )
                StringCchCopyW(pszDest, cchDest, lpString);
              else
                v21 = 1;
              ListView_EndFakeItemDraw((LPARAM)&lParam);
              ListView_EndFakeCustomDraw((LPARAM)&lParam);
            }
          }
        }
      }
    }
  }
  return v21;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7C6C45) --------------------------------------------------------
int __stdcall ListView_OnSetItemText(INT_PTR a1, int a2, int a3, int a4)
{
  int result; // eax@2
  int v5; // [sp+4h] [bp-28h]@3
  int v6; // [sp+8h] [bp-24h]@3
  int v7; // [sp+Ch] [bp-20h]@3
  int v8; // [sp+18h] [bp-14h]@3

  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    result = 0;
  }
  else
  {
    ListView_InvalidateTTLastHit(a1, a2);
    v8 = a4;
    v7 = a3;
    v5 = 1;
    v6 = a2;
    result = ListView_OnSetItem(a1, (INT_PTR)&v5);
  }
  return result;
}

//----- (6F7C6C94) --------------------------------------------------------
int __stdcall ListView_CreateItem(int a1, int a2)
{
  int v2; // edi@1
  int v3; // eax@3

  v2 = (int)HeapAlloc(*(HANDLE *)(a1 + 80), 8u, 0x3Cu);
  if ( v2 )
  {
    if ( *(_BYTE *)a2 & 8 )
    {
      v3 = *(_DWORD *)(a2 + 12);
      if ( v3 & 0xFFFF0000 )
        return 0;
      if ( *(_BYTE *)(a1 + 8) & 4 && v3 & 2 )
        ListView_DeselectAll(a1, -1);
      *(_WORD *)(v2 + 24) = *(_WORD *)(a2 + 12) & 0xFFFC;
    }
    if ( *(_BYTE *)a2 & 4 )
      *(_DWORD *)(v2 + 28) = *(_DWORD *)(a2 + 32);
    if ( *(_BYTE *)a2 & 2 )
      *(_WORD *)(v2 + 12) = *(_WORD *)(a2 + 28);
    if ( *(_BYTE *)a2 & 0x10 )
      *(_WORD *)(v2 + 26) = *(_WORD *)(a2 + 36);
    *(_DWORD *)(v2 + 8) = 0x7FFFFFFF;
    *(_DWORD *)(v2 + 4) = 0x7FFFFFFF;
    ListView_SetSRecompute(v2);
    *(_DWORD *)v2 = 0;
    if ( *(_BYTE *)a2 & 1 && !Str_Set(v2, *(LPCWSTR *)(a2 + 20)) )
    {
      ListView_FreeItem(a1, (LPVOID)v2);
      return 0;
    }
  }
  return v2;
}

//----- (6F7C6D50) --------------------------------------------------------
int __stdcall ListView_OnInsertItem(HDC hdc, int a2)
{
  INT_PTR v3; // esi@4
  int v4; // eax@4
  const WCHAR *v5; // eax@6
  int v6; // edi@7
  int v7; // eax@10
  INT_PTR v8; // ebx@16
  struct _DPA *v9; // eax@17
  int v10; // eax@22
  int v11; // ecx@26
  int v12; // ecx@28
  int i; // ebx@31
  int v14; // eax@32
  int v15; // ecx@32
  int v16; // eax@42
  int v17; // eax@45
  int v18; // eax@47
  int v19; // eax@55
  LPVOID lpMem; // [sp+4h] [bp-4h]@10
  int hdca; // [sp+10h] [bp+8h]@13
  int v22; // [sp+14h] [bp+Ch]@11

  if ( !a2 || *(_DWORD *)(a2 + 8) )
    return -1;
  v3 = (INT_PTR)hdc;
  v4 = *((_DWORD *)hdc + 2);
  if ( !(v4 & 0x30) || v4 & 0x1000 )
  {
    v6 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    v5 = *(const WCHAR **)(a2 + 20);
    if ( v5 == (const WCHAR *)-1 )
      return -1;
    v6 = ListView_LookupString((int)hdc, v5, 68, 0);
  }
  ListView_InvalidateTTLastHit((int)hdc, *((_DWORD *)hdc + 39));
  if ( *((_DWORD *)hdc + 2) & 0x1000 )
  {
    if ( (unsigned int)v6 <= 0x5F5E100 )
    {
      if ( (*(int (__stdcall **)(_DWORD, int))(**((_DWORD **)hdc + 91) + 24))(*((_DWORD *)hdc + 91), v6) < 0 )
        return -1;
      ++*((_DWORD *)hdc + 93);
      *((_DWORD *)hdc + 57) = 0x7FFFFFFF;
      ListView_Recompute((int)hdc);
      v16 = *((_DWORD *)hdc + 2) & 3;
      if ( v16 != 1 && v16 != 3 )
        InvalidateRect(*(HWND *)hdc, 0, 1);
      v17 = *((_DWORD *)hdc + 25);
      if ( v6 <= v17 )
        *((_DWORD *)hdc + 25) = v17 + 1;
      v18 = *((_DWORD *)hdc + 26);
      if ( v6 <= v18 )
        *((_DWORD *)hdc + 26) = v18 + 1;
    }
  }
  else
  {
    v7 = ListView_CreateItem((int)hdc, a2);
    lpMem = (LPVOID)v7;
    if ( *(_BYTE *)a2 & 8 )
      v22 = *(_DWORD *)(a2 + 12) & 3;
    else
      v22 = 0;
    hdca = v22;
    if ( !v7 )
      return -1;
    v6 = DPA_InsertPtr(*(HDPA *)(v3 + 40), v6, (void *)v7);
    if ( v6 == -1 )
      goto LABEL_25;
    ++*(_DWORD *)(v3 + 372);
    if ( *(_DWORD *)(v3 + 316) )
    {
      v8 = *(_DWORD *)(v3 + 312);
      while ( 1 )
      {
        --v8;
        if ( v8 < 0 )
          break;
        v9 = (struct _DPA *)DPA_GetPtr(*(HDPA *)(v3 + 316), v8);
        if ( v9 )
        {
          if ( v6 < *(_DWORD *)v9 )
          {
            if ( DPA_InsertPtr(v9, v6, 0) != v6 )
              goto LABEL_23;
          }
          else
          {
            DPA_SetPtr(v9, v6, 0);
          }
        }
      }
    }
    v10 = DPA_InsertPtr(*(HDPA *)(v3 + 216), *(_DWORD *)(v3 + 372), (void *)v6);
    if ( v10 == -1 )
    {
LABEL_23:
      if ( DPA_DeletePtr(*(HDPA *)(v3 + 40), v6) )
        --*(_DWORD *)(v3 + 372);
LABEL_25:
      ListView_FreeItem(v3, lpMem);
      return -1;
    }
    v11 = *(_DWORD *)(v3 + 100);
    if ( v6 <= v11 )
      *(_DWORD *)(v3 + 100) = v11 + 1;
    v12 = *(_DWORD *)(v3 + 104);
    if ( v6 <= v12 )
      *(_DWORD *)(v3 + 104) = v12 + 1;
    if ( v6 != *(_DWORD *)(v3 + 372) - 1 )
    {
      for ( i = v10 - 1; i >= 0; --i )
      {
        v14 = *(_DWORD *)(v3 + 216);
        v15 = *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4 * i);
        if ( v15 >= v6 )
          DPA_SetPtr((HDPA)v14, i, (void *)(v15 + 1));
      }
    }
    if ( *(_BYTE *)(v3 + 48) & 4 )
    {
      v22 |= 0xF000u;
      hdca |= 0x1000u;
    }
    if ( v22 )
      ListView_OnSetItemState(v3, v6, hdca, v22);
  }
  if ( (*(_BYTE *)(v3 + 44) & 0x12) == 18 )
  {
    ListView_RecalcRegion(v3, 1, 1);
    if ( !ListView_MaybeResizeListColumns(v3, v6, v6) )
      ListView_OnUpdate((HDC)v3, v6);
    if ( !*(_DWORD *)(v3 + 388) )
      PostMessageW(*(HWND *)v3, 0x400u, 0, 0);
    ++*(_DWORD *)(v3 + 388);
  }
  else
  {
    v19 = *(_DWORD *)(v3 + 112);
    if ( v19 == -1 || v6 < v19 )
      *(_DWORD *)(v3 + 112) = v6;
  }
  ListView_Notify(v3, v6, 0, -102);
  MyNotifyWinEvent(0x8000, *(_DWORD *)v3, -4, v6 + 1);
  return v6;
}

//----- (6F7C6FC4) --------------------------------------------------------
int __stdcall ListView_OnDeleteItem(LPVOID lpMem, int i)
{
  INT_PTR v2; // esi@1
  int v4; // edi@3
  int v5; // eax@7
  int v6; // eax@9
  struct _DPA *v7; // ST0C_4@16
  int v8; // eax@16
  int v9; // edi@16
  int v10; // eax@17
  int v11; // ecx@17
  INT_PTR v12; // edi@21
  struct _DPA *v13; // eax@22
  PVOID v14; // eax@23
  int v15; // eax@28
  int v16; // eax@31
  int v17; // ecx@31
  int v18; // eax@34
  int v19; // eax@36
  int v20; // eax@38
  int v21; // eax@42
  int v22; // eax@51
  LPVOID lpMema; // [sp+10h] [bp+8h]@1
  PVOID lpMemb; // [sp+10h] [bp+8h]@15

  v2 = (INT_PTR)lpMem;
  lpMema = (LPVOID)*((_DWORD *)lpMem + 93);
  if ( i >= (unsigned int)lpMema )
    return 0;
  v4 = i + 1;
  MyNotifyWinEvent(32769, *(_DWORD *)v2, -4, i + 1);
  ListView_DismissEdit(v2, 1);
  ListView_OnSetItemState(v2, i, 0, 2);
  if ( *(_DWORD *)(v2 + 100) == i )
  {
    if ( (_BYTE *)i == (char *)lpMema - 1 )
      v4 = i - 1;
    ListView_OnSetItemState(v2, v4, 1, 1);
  }
  ListView_InvalidateTTLastHit(v2, *(_DWORD *)(v2 + 156));
  v5 = *(_DWORD *)(v2 + 8);
  if ( v5 & 0x1000 )
  {
    if ( (unsigned int)i <= 0x5F5E100 )
    {
      ListView_Notify(v2, i, 0, -103);
      if ( (*(int (__stdcall **)(_DWORD, int))(**(_DWORD **)(v2 + 364) + 28))(*(_DWORD *)(v2 + 364), i) >= 0 )
      {
        --*(_DWORD *)(v2 + 372);
        *(_DWORD *)(v2 + 228) = 0x7FFFFFFF;
        ListView_Recompute(v2);
        v15 = *(_DWORD *)(v2 + 8) & 3;
        if ( v15 != 1 && v15 != 3 )
          InvalidateRect(*(HWND *)v2, 0, 1);
LABEL_31:
        v16 = *(_DWORD *)(v2 + 100);
        v17 = *(_DWORD *)(v2 + 372);
        if ( v16 == i && v16 >= v17 )
          *(_DWORD *)(v2 + 100) = v17 - 1;
        v18 = *(_DWORD *)(v2 + 100);
        if ( v18 > i )
          *(_DWORD *)(v2 + 100) = v18 - 1;
        v19 = *(_DWORD *)(v2 + 104);
        if ( v19 == i )
        {
          if ( v19 < v17 )
            goto LABEL_42;
          v20 = v17 - 1;
        }
        else
        {
          if ( v19 <= i )
            goto LABEL_42;
          v20 = v19 - 1;
        }
        *(_DWORD *)(v2 + 104) = v20;
LABEL_42:
        v21 = *(_DWORD *)(v2 + 8);
        *(_DWORD *)(v2 + 244) = -1;
        if ( (v21 & 3) == 1 )
        {
          if ( v17 )
            ListView_LRInvalidateBelow((HDC)v2, i, 1);
          else
            InvalidateRect(*(HWND *)v2, 0, 1);
          if ( (*(_BYTE *)(v2 + 44) & 0x12) == 18 )
          {
            ListView_UpdateScrollBars((HDC)v2);
LABEL_54:
            ListView_RecalcRegion(v2, 1, 1);
            return 1;
          }
        }
        else
        {
          if ( (*(_BYTE *)(v2 + 44) & 0x12) == 18 )
          {
            ListView_OnUpdate((HDC)v2, i);
            goto LABEL_54;
          }
          ListView_LRInvalidateBelow((HDC)v2, i, 0);
        }
        v22 = *(_DWORD *)(v2 + 112);
        if ( v22 != -1 && i < v22 )
          *(_DWORD *)(v2 + 112) = v22 - 1;
        goto LABEL_54;
      }
    }
  }
  else
  {
    if ( *(_DWORD *)(v2 + 228) != 0x7FFFFFFF )
    {
      v6 = v5 & 3;
      if ( !v6 || v6 == 2 )
      {
        if ( LV_IsItemOnViewEdge(v2, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 40) + 4) + 4 * i)) )
          *(_DWORD *)(v2 + 228) = 0x7FFFFFFF;
      }
    }
    if ( (*(_DWORD *)(v2 + 8) & 3) != 1 )
      ListView_InvalidateItemEx(v2, i, 0, 5u, 0);
    ListView_Notify(v2, i, 0, -103);
    lpMemb = DPA_DeletePtr(*(HDPA *)(v2 + 40), i);
    if ( lpMemb )
    {
      v7 = *(struct _DPA **)(v2 + 216);
      *(_DWORD *)(v2 + 372) = **(_DWORD **)(v2 + 40);
      v8 = DPA_GetPtrIndex(v7, (const void *)i);
      DPA_DeletePtr(*(HDPA *)(v2 + 216), v8);
      v9 = *(_DWORD *)(v2 + 372);
      while ( 1 )
      {
        --v9;
        if ( v9 < 0 )
          break;
        v10 = *(_DWORD *)(v2 + 216);
        v11 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * v9);
        if ( v11 > i )
          DPA_SetPtr((HDPA)v10, v9, (void *)(v11 - 1));
      }
      if ( *(_DWORD *)(v2 + 316) )
      {
        v12 = *(_DWORD *)(v2 + 312);
        while ( 1 )
        {
          --v12;
          if ( v12 < 0 )
            break;
          v13 = (struct _DPA *)DPA_GetPtr(*(HDPA *)(v2 + 316), v12);
          if ( v13 )
          {
            v14 = DPA_DeletePtr(v13, i);
            ListView_FreeSubItem(v14);
          }
        }
      }
      ListView_FreeItem(v2, lpMemb);
      goto LABEL_31;
    }
  }
  return 0;
}

//----- (6F7C7241) --------------------------------------------------------
signed int __stdcall ListView_OnFindItemA(int a1, signed int a2, int a3)
{
  void *v3; // edi@1
  int v4; // ebx@1
  LPCSTR v6; // eax@4
  int v7; // [sp+14h] [bp+8h]@6

  v3 = 0;
  v4 = 0;
  if ( !a3 )
    return -1;
  if ( !(*(_BYTE *)a3 & 0x41) )
  {
    v4 = *(_DWORD *)(a3 + 4);
    v6 = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a3 + 4));
    v3 = (void *)v6;
    if ( !v6 )
      return -1;
    *(_DWORD *)(a3 + 4) = v6;
  }
  v7 = ListView_OnFindItem(a1, a2, a3);
  if ( v3 )
  {
    *(_DWORD *)(a3 + 4) = v4;
    FreeProducedString(v3);
  }
  return v7;
}

//----- (6F7C72A1) --------------------------------------------------------
void __stdcall ListView_Redraw(WPARAM wParam, HDC hdc, int a3)
{
  int v3; // ebx@1
  HDC v4; // esi@1
  unsigned int v5; // eax@1
  int v6; // edi@4
  int v7; // eax@5
  int v8; // esi@7
  int v9; // eax@7
  signed int v10; // ST20_4@7
  int v11; // eax@7
  int v12; // ecx@8
  signed int v13; // edi@8
  bool v14; // zf@14
  WPARAM v15; // esi@21
  int v16; // ecx@21
  int v17; // eax@21
  int v18; // ecx@22
  int v19; // eax@25
  bool v20; // sf@25
  unsigned __int8 v21; // of@25
  int v22; // eax@27
  int v23; // ecx@27
  int v24; // ecx@28
  int v25; // eax@32
  int v26; // eax@38
  int v27; // esi@42
  int v28; // ecx@42
  COLORREF v29; // ST20_4@47
  int v30; // ST1C_4@47
  int v31; // ST18_4@47
  int v32; // ST14_4@47
  int v33; // eax@48
  LPARAM lParam; // [sp+Ch] [bp-9Ch]@1
  HDC v35; // [sp+1Ch] [bp-8Ch]@1
  int v36; // [sp+20h] [bp-88h]@1
  int v37; // [sp+24h] [bp-84h]@1
  int v38; // [sp+28h] [bp-80h]@1
  int v39; // [sp+2Ch] [bp-7Ch]@1
  int v40; // [sp+34h] [bp-74h]@1
  int v41; // [sp+38h] [bp-70h]@1
  int v42; // [sp+3Ch] [bp-6Ch]@17
  int v43; // [sp+40h] [bp-68h]@32
  int v44; // [sp+44h] [bp-64h]@17
  int v45; // [sp+48h] [bp-60h]@32
  int v46; // [sp+4Ch] [bp-5Ch]@17
  HDC v47; // [sp+64h] [bp-44h]@17
  WPARAM v48; // [sp+78h] [bp-30h]@32
  int v49; // [sp+84h] [bp-24h]@32
  int v50; // [sp+88h] [bp-20h]@32
  RECT rc; // [sp+90h] [bp-18h]@42
  int v52; // [sp+A0h] [bp-8h]@1
  int v53; // [sp+A4h] [bp-4h]@1

  v3 = wParam;
  v4 = hdc;
  v53 = *(_DWORD *)(wParam + 372);
  v52 = *(_DWORD *)(wParam + 8) & 3;
  SetBkMode(hdc, 1);
  SelectObject(v4, *(HGDIOBJ *)(v3 + 56));
  v40 = 0;
  v41 = 0;
  v35 = v4;
  v36 = *(_DWORD *)a3;
  v37 = *(_DWORD *)(a3 + 4);
  v38 = *(_DWORD *)(a3 + 8);
  v39 = *(_DWORD *)(a3 + 12);
  v5 = CICustomDrawNotify(v3, 1, (LPARAM)&lParam);
  *(_DWORD *)(v3 + 12) = v5;
  if ( v5 & 4 )
    return;
  ListView_RecalcRegion(v3, 0, 1);
  if ( v52 == 1 )
  {
    v12 = *(_DWORD *)(v3 + 336) - *(_DWORD *)(v3 + 324);
    v8 = a3;
    v13 = *(_DWORD *)(v3 + 188);
    wParam = (v12 + *(_DWORD *)(a3 + 4)) / v13;
    v11 = (v12 + *(_DWORD *)(a3 + 12)) / v13;
    goto LABEL_9;
  }
  if ( v52 == 3 )
  {
    v8 = a3;
    v9 = ListView_LCalcViewItem(v3, *(_DWORD *)a3, *(_DWORD *)(a3 + 4));
    v10 = *(_DWORD *)(v8 + 12);
    wParam = v9;
    v11 = ListView_LCalcViewItem(v3, *(_DWORD *)(v8 + 8), v10);
LABEL_9:
    v6 = v8;
    v7 = v11 + 1;
    goto LABEL_10;
  }
  v6 = a3;
  if ( !(*(_DWORD *)(v3 + 8) & 0x1000) )
  {
    v7 = v53;
LABEL_11:
    wParam = 0;
    goto LABEL_12;
  }
  ListView_CalcMinMaxIndex(v3, a3, (int)&wParam, (int)&v53);
  v7 = v53;
LABEL_10:
  if ( (wParam & 0x80000000) != 0 )
    goto LABEL_11;
LABEL_12:
  if ( *(_DWORD *)(v3 + 372) < v7 )
    v7 = *(_DWORD *)(v3 + 372);
  v14 = (*(_DWORD *)(v3 + 8) & 0x1000) == 0;
  v53 = v7;
  if ( !v14 && v7 > (signed int)wParam )
  {
    ListView_NotifyCacheHint(v3, wParam, v7 - 1);
    ListView_LazyCreateWinEvents(v3, wParam, v53 - 1);
  }
  v42 = v3;
  v47 = hdc;
  v44 = v6;
  v46 = 0;
  while ( (signed int)wParam < v53 )
  {
    if ( v52 && v52 != 2 || *(_DWORD *)(v3 + 8) & 0x1000 )
    {
      v15 = wParam;
    }
    else
    {
      v15 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 216) + 4) + 4 * (v53 - wParam) - 4);
      v16 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * v15);
      v17 = *(_DWORD *)(v16 + 4);
      if ( v17 != 0x7FFFFFFF )
      {
        v18 = *(_DWORD *)(v16 + 8) - *(_DWORD *)(v3 + 224);
        if ( v18 > *(_DWORD *)(v6 + 12) )
          goto LABEL_33;
        if ( v52 == 2 )
        {
          if ( v17 - *(_DWORD *)(v3 + 356) - *(_DWORD *)(v3 + 220) > *(_DWORD *)(v6 + 8) )
            goto LABEL_33;
          v19 = v18 + *(_DWORD *)(v3 + 188);
          v21 = __OFSUB__(v19, *(_DWORD *)(v6 + 4));
          v20 = v19 - *(_DWORD *)(v6 + 4) < 0;
          goto LABEL_29;
        }
        if ( !(*(_BYTE *)(v3 + 8) & 0x80) )
        {
          v22 = v17 - *(_DWORD *)(v3 + 220);
          v23 = *(_DWORD *)(v3 + 196);
          if ( v22 - v23 > *(_DWORD *)(v6 + 8) )
            goto LABEL_33;
          v24 = v22 + v23;
          v21 = __OFSUB__(v24, *(_DWORD *)v6);
          v20 = v24 - *(_DWORD *)v6 < 0;
LABEL_29:
          if ( v20 ^ v21 )
            goto LABEL_33;
          goto LABEL_32;
        }
      }
    }
LABEL_32:
    v25 = *(_DWORD *)(v3 + 68);
    v43 = 0;
    v45 = 0;
    v49 = v25;
    v50 = *(_DWORD *)(v3 + 72);
    *(_DWORD *)(v3 + 108) = v15;
    v48 = v15;
    if ( !ListView_DrawItem((int)&v42) )
      break;
LABEL_33:
    ++wParam;
  }
  if ( !v52 || v52 == 2 )
  {
    if ( *(_DWORD *)(v3 + 8) & 0x1000 )
    {
      v26 = *(_DWORD *)(v3 + 100);
      if ( v26 != -1 )
      {
        *(_DWORD *)(v3 + 108) = v26;
        v48 = v26;
        v49 = *(_DWORD *)(v3 + 68);
        v50 = *(_DWORD *)(v3 + 72);
        v43 = 0;
        v45 = 0;
        ListView_DrawItem((int)&v42);
      }
    }
  }
  if ( !*(_DWORD *)(v3 + 372) && ListView_GetEmptyText(v3) )
  {
    v27 = g_cyEdge;
    v28 = 0;
    v14 = (*(_DWORD *)(v3 + 52) & 0x2000) == 0;
    rc.top = g_cyEdge;
    if ( !v14 )
      v28 = 2048;
    if ( (*(_DWORD *)(v3 + 8) & 3) == 1 && !(*(_DWORD *)(v3 + 8) & 0x4000) )
    {
      v27 = *(_DWORD *)(v3 + 188) + g_cyEdge;
      rc.top = *(_DWORD *)(v3 + 188) + g_cyEdge;
    }
    v29 = *(_DWORD *)(v3 + 60);
    v30 = *(_DWORD *)(v3 + 68);
    rc.left = g_cxEdge - *(_DWORD *)(v3 + 332);
    v31 = *(_DWORD *)(v3 + 92);
    v32 = *(_DWORD *)(v3 + 84);
    rc.right = *(_DWORD *)(v3 + 120);
    rc.bottom = v27 + *(_DWORD *)(v3 + 188);
    SHDrawText(hdc, *(_DWORD *)(v3 + 440), &rc, 0, v28, v32, v31, v30, v29);
  }
  v33 = v52;
  *(_DWORD *)(v3 + 108) = -1;
  if ( v33 == 1 )
    ListView_RAfterRedraw(v3, hdc);
  if ( *(_BYTE *)(v3 + 12) & 0x10 )
    CICustomDrawNotify(v3, 2, (LPARAM)&lParam);
}

//----- (6F7C75B1) --------------------------------------------------------
int __stdcall ListView_OnSetItemCount(HDC hdc, int cp, int a3)
{
  HDC v3; // esi@1
  bool v4; // sf@3
  unsigned __int8 v5; // of@3
  int v7; // eax@11
  int v8; // edi@19
  int v9; // eax@24
  int v10; // edi@30
  INT_PTR v11; // edi@41
  struct _DPA *v12; // eax@42
  signed int v13; // [sp+Ch] [bp-8h]@1
  int v14; // [sp+10h] [bp-4h]@2
  int hdca; // [sp+1Ch] [bp+8h]@2

  v3 = hdc;
  v13 = 1;
  if ( !(*((_DWORD *)hdc + 2) & 0x1000) )
  {
    if ( *((_DWORD *)hdc + 79) )
    {
      v11 = *((_DWORD *)hdc + 78);
      while ( 1 )
      {
        --v11;
        if ( v11 < 0 )
          break;
        v12 = (struct _DPA *)DPA_GetPtr(*((HDPA *)hdc + 79), v11);
        if ( v12 )
          DPA_Grow(v12, cp);
      }
    }
    DPA_Grow(*((HDPA *)hdc + 10), cp);
    DPA_Grow(*((HDPA *)hdc + 54), cp);
    return v13;
  }
  hdca = *((_DWORD *)hdc + 93);
  v14 = ~a3 & 1;
  if ( (unsigned int)cp > 0x5F5E100 )
    return 0;
  v5 = __OFSUB__(*((_DWORD *)v3 + 25), cp);
  v4 = *((_DWORD *)v3 + 25) - cp < 0;
  *((_DWORD *)v3 + 93) = cp;
  if ( !(v4 ^ v5) )
    *((_DWORD *)v3 + 25) = -1;
  if ( *((_DWORD *)v3 + 94) >= cp )
    *((_DWORD *)v3 + 94) = -1;
  if ( *((_DWORD *)v3 + 26) >= cp )
    *((_DWORD *)v3 + 26) = -1;
  (*(void (__stdcall **)(_DWORD, int, signed int))(**((_DWORD **)v3 + 92) + 16))(*((_DWORD *)v3 + 92), cp, 2147483645);
  if ( (*(int (__stdcall **)(_DWORD, int, signed int))(**((_DWORD **)v3 + 91) + 16))(
         *((_DWORD *)v3 + 91),
         cp,
         2147483645) < 0 )
    return 0;
  v7 = *((_DWORD *)v3 + 2) & 3;
  *((_DWORD *)v3 + 57) = 0x7FFFFFFF;
  if ( v7 != 2 && v7 )
  {
    ListView_Recompute((int)v3);
    if ( *((_DWORD *)v3 + 110) && !hdca && cp > 0 )
      v14 = 1;
    if ( !v14 )
    {
      v8 = hdca >= cp ? cp - 1 : hdca;
      if ( v8 >= 0 )
        ListView_LRInvalidateBelow(v3, v8, 0);
    }
    ListView_MaybeResizeListColumns((int)v3, 0, *((_DWORD *)v3 + 93) - 1);
    if ( !(a3 & 2) )
    {
      v9 = *((_DWORD *)v3 + 25);
      if ( v9 < 0 )
      {
        v9 = ListView_OnGetNextItem(v3, -1, 2);
        if ( v9 < 0 )
          v9 = 0;
      }
      ListView_OnEnsureVisible(v3, v9, 0);
    }
  }
  else
  {
    ListView_OnArrange(v3, 0);
    if ( v14 )
    {
LABEL_37:
      InvalidateRect(*(HWND *)v3, 0, 1);
      goto LABEL_38;
    }
    if ( hdca >= cp )
      v10 = cp - 1;
    else
      v10 = hdca;
    if ( v10 >= 0 && hdca > 0 )
    {
      ListView_IInvalidateBelow((int)v3, v10);
      goto LABEL_38;
    }
    v14 = 1;
  }
  if ( v14 )
    goto LABEL_37;
LABEL_38:
  ListView_UpdateScrollBars(v3);
  ListView_NotifyRecreate((int)v3);
  ListView_NotifyFocusEvent((int)v3);
  return v13;
}

//----- (6F7C777F) --------------------------------------------------------
int __stdcall ListView_InitCheckBoxes(INT_PTR i, int a2)
{
  struct _IMAGELIST *v2; // edi@1
  LONG v3; // eax@3
  struct _IMAGELIST *v4; // edi@3
  int result; // eax@3

  v2 = *(struct _IMAGELIST **)(i + 168);
  if ( !v2 )
    v2 = *(struct _IMAGELIST **)(i + 204);
  v3 = GetWindowLongW(*(HWND *)i, -20);
  v4 = CreateCheckBoxImagelist(v2, 0, (HICON)1, v3 & 0x400000);
  ImageList_SetBkColor(v4, *(_DWORD *)(i + 60));
  result = ListView_OnSetImageList(i, v4, 2);
  if ( a2 )
    result = ListView_OnSetItemState(i, -1, 4096, 61440);
  return result;
}

//----- (6F7C77EC) --------------------------------------------------------
INT_PTR __stdcall ListView_ExtendedStyleChange(INT_PTR i, int a2, int a3)
{
  INT_PTR v3; // esi@1
  bool v4; // sf@1
  unsigned __int8 v5; // of@1
  char v6; // al@2
  int v7; // ebx@5
  int v8; // ecx@7
  struct _IMAGELIST *v9; // eax@19
  int j; // ebx@30
  int v11; // edi@31
  int v12; // eax@31
  HWND v14; // [sp-4h] [bp-10h]@22
  INT_PTR ia; // [sp+14h] [bp+8h]@1
  int v16; // [sp+1Ch] [bp+10h]@11

  v3 = i;
  v5 = __OFSUB__(*(_DWORD *)(i + 28), 3);
  v4 = *(_DWORD *)(i + 28) - 3 < 0;
  ia = *(_DWORD *)(i + 48);
  if ( v4 ^ v5 )
  {
    v6 = *(_DWORD *)(v3 + 8) & 3;
    *(_DWORD *)(v3 + 28) = 3;
    if ( v6 == 1 )
    {
      ListView_RUpdateScrollBars(v3);
      InvalidateRect(*(HWND *)v3, 0, 1);
    }
  }
  ListView_PopBubble(v3);
  if ( a3 )
    v7 = a3 & a2 | *(_DWORD *)(v3 + 48) & ~a3;
  else
    v7 = a2;
  v8 = *(_DWORD *)(v3 + 8) & 3;
  if ( v8 )
    v7 &= 0xFFFFDDFF;
  if ( *(_DWORD *)(v3 + 8) & 0x1000 )
    v7 &= 0xFFFFFDFF;
  *(_DWORD *)(v3 + 48) = v7;
  v16 = v7 ^ ia;
  if ( ((unsigned __int8)v7 ^ (unsigned __int8)ia) & 1 && v8 == 1 )
    InvalidateRect(*(HWND *)v3, 0, 1);
  if ( v16 & 0x18C2 )
    InvalidateRect(*(HWND *)v3, 0, 1);
  if ( v16 & 4 )
  {
    if ( v7 & 4 )
    {
      ListView_InitCheckBoxes(v3, 1);
    }
    else
    {
      v9 = (struct _IMAGELIST *)ListView_OnSetImageList(v3, 0, 2);
      if ( v9 )
        ImageList_Destroy(v9);
    }
  }
  if ( v16 & 0x100 )
  {
    v14 = *(HWND *)v3;
    if ( v7 & 0x100 )
      InitializeFlatSB(v14);
    else
      UninitializeFlatSB(v14);
  }
  if ( v16 & 0x200 )
  {
    if ( g_fSlowMachine == -1 )
      g_fSlowMachine = 0;
    if ( v7 & 0x200 )
    {
      ListView_RecalcRegion(v3, 1, 1);
    }
    else
    {
      for ( j = 0; j < *(_DWORD *)(v3 + 372); ++j )
      {
        v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 + 40) + 4) + 4 * j);
        v12 = *(_DWORD *)(v11 + 32);
        if ( v12 && v12 != -1 )
          DeleteObject(*(HGDIOBJ *)(v11 + 32));
        *(_DWORD *)(v11 + 32) = 0;
      }
      SetWindowRgn(*(HWND *)v3, 0, 1);
    }
    InvalidateRect(*(HWND *)v3, 0, 1);
  }
  return ia;
}
// 6F7E8598: using guessed type int g_fSlowMachine;

//----- (6F7C795D) --------------------------------------------------------
int __stdcall ListView_OnNotify(HDC a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v6; // eax@4
  int v7; // eax@6
  int v8; // eax@10
  int v9; // edi@12
  HGDIOBJ v10; // eax@14
  int v11; // edi@14
  unsigned int v12; // eax@19
  int v13; // ecx@22
  int v14; // eax@29
  __int64 v15; // rax@31
  int v16; // ebx@36
  int v17; // eax@38
  LPARAM v18; // [sp+8h] [bp-10A4h]@13
  HDC hdc; // [sp+18h] [bp-1094h]@14
  int v20; // [sp+5Ch] [bp-1050h]@36
  int v21; // [sp+60h] [bp-104Ch]@13
  LPARAM v22; // [sp+64h] [bp-1048h]@13
  int v23; // [sp+68h] [bp-1044h]@13
  int v24; // [sp+70h] [bp-103Ch]@42
  wchar_t *v25; // [sp+74h] [bp-1038h]@42
  int v26; // [sp+78h] [bp-1034h]@42
  int v27; // [sp+7Ch] [bp-1030h]@26
  int v28; // [sp+80h] [bp-102Ch]@42
  int v29; // [sp+84h] [bp-1028h]@42
  int v30; // [sp+88h] [bp-1024h]@40
  LPCWSTR lpString; // [sp+8Ch] [bp-1020h]@40
  int v32; // [sp+90h] [bp-101Ch]@1
  int v33; // [sp+94h] [bp-1018h]@12
  LPARAM lParam; // [sp+98h] [bp-1014h]@24
  int Y; // [sp+9Ch] [bp-1010h]@24
  struct tagPOINT Point; // [sp+A0h] [bp-100Ch]@26
  wchar_t pszDest; // [sp+A8h] [bp-1004h]@40
  wchar_t pszSrc; // [sp+8A8h] [bp-804h]@40

  v3 = *((_DWORD *)a1 + 80);
  v4 = a3;
  v32 = a3;
  if ( v3 && v3 == *(_DWORD *)a3 )
    return ListView_HeaderNotify(a1, a3);
  v6 = *((_DWORD *)a1 + 38);
  if ( !v6 || v6 != *(_DWORD *)a3 )
    return 0;
  v7 = *(_DWORD *)(a3 + 8);
  if ( v7 == -530 )
  {
    GetMessagePosClient(*(HWND *)a1, &Point);
    v16 = ((int (__stdcall *)(HDC, int, int, int))*(&pfnListView_ItemHitTest + (*((_DWORD *)a1 + 2) & 3)))(
            a1,
            Point.x,
            Point.y,
            (int)&v20);
    if ( v16 == *((_DWORD *)a1 + 39) && v33 == *((_DWORD *)a1 + 40) )
      goto LABEL_46;
    *((_DWORD *)a1 + 9) &= 0xFFFFFFEF;
    Str_Set((int)(a1 + 41), 0);
    v17 = v33;
    *((_DWORD *)a1 + 39) = v16;
    *((_DWORD *)a1 + 40) = v17;
    if ( v16 < 0 || *((_DWORD *)a1 + 63) != -1 )
      goto LABEL_46;
    lpString = &pszSrc;
    pszSrc = 0;
    pszDest = 0;
    v30 = ListView_IsItemUnfolded2((int)a1, v16, v17, &pszSrc, 1024);
    StringCchCopyW(&pszDest, 0x400u, &pszSrc);
    if ( *((_DWORD *)a1 + 12) & 0x400 && !v33 )
    {
      v26 = 1024;
      v28 = 0;
      v29 = 0;
      v24 = v30 != 0;
      v25 = &pszSrc;
      v27 = *((_DWORD *)a1 + 39);
      CCSendNotify((int)a1, -158, (LPARAM)&v22);
      if ( pszSrc )
      {
        if ( lstrcmpW(&pszSrc, &pszDest) )
        {
          SendMessageW(*((HWND *)a1 + 38), 0x41Au, 0, (LPARAM)dword_6F7C7E40);
          CCSetInfoTipWidth(*(HWND *)a1, *((HWND *)a1 + 38));
          goto LABEL_45;
        }
      }
      else
      {
        lpString = &pszDest;
      }
    }
    *((_DWORD *)a1 + 9) |= 0x10u;
    SendMessageW(*((HWND *)a1 + 38), 0x41Au, 0, (LPARAM)dword_6F7C7E50);
    SendMessageW(*((HWND *)a1 + 38), 0x418u, 0, -1);
LABEL_45:
    Str_Set((int)(a1 + 41), lpString);
    v4 = v32;
LABEL_46:
    *(_DWORD *)(v4 + 12) = *((_DWORD *)a1 + 41);
    return 0;
  }
  if ( v7 != -521 )
  {
    if ( v7 == -12 )
    {
      if ( *((_BYTE *)a1 + 36) & 0x10 )
      {
        v8 = *(_DWORD *)(a3 + 12);
        if ( v8 == 1 || v8 == 65537 )
        {
          v33 = 0;
          v9 = (int)(a1 + 39);
          if ( *((_DWORD *)a1 + 39) == -1 )
          {
            v11 = v32;
          }
          else
          {
            ListView_BeginFakeCustomDraw((int)a1, (LPARAM)&v18, (int)&v21);
            v22 = *(_DWORD *)v9;
            v23 = *((_DWORD *)a1 + 40);
            v21 = 4;
            ListView_OnGetItem(v9, (HDPA)a1, (int)&v21);
            v33 = ListView_BeginFakeItemDraw((LPARAM)&v18);
            if ( v33 & 2 )
            {
              v10 = GetCurrentObject(hdc, 6u);
              v11 = v32;
              SelectObject(*(HDC *)(v32 + 16), v10);
            }
            else
            {
              v11 = v32;
            }
            ListView_EndFakeItemDraw((LPARAM)&v18);
            ListView_EndFakeCustomDraw((LPARAM)&v18);
          }
          if ( !(*((_BYTE *)a1 + 8) & 3) )
          {
            v12 = *(_DWORD *)(v11 + 48) & 0xFFFFFFDF | 0x2811;
            *(_DWORD *)(v11 + 48) = v12;
            if ( v12 & 0x400 )
            {
              *(_DWORD *)(v11 + 28) = *(_DWORD *)(v11 + 20) + *((_DWORD *)a1 + 49) - 2 * g_cxLabelMargin;
              *(_DWORD *)(v11 + 32) = *(_DWORD *)(v11 + 24) + 0x10000;
            }
          }
          return v33 & 2;
        }
      }
    }
    return 0;
  }
  v13 = *((_DWORD *)a1 + 39);
  if ( v13 == -1 || !(*((_BYTE *)a1 + 36) & 0x10) )
    return 0;
  Y = *((_DWORD *)a1 + 40);
  lParam = 2;
  if ( Y && ListView_OnGetSubItemRect((int)a1, v13, (LPRECT)&lParam) )
  {
    v27 = -1;
    lParam += 3 * g_cxLabelMargin;
    Point.x -= 3 * g_cxLabelMargin;
    v22 = *((_DWORD *)a1 + 39);
    v23 = *((_DWORD *)a1 + 40);
    v21 = 2;
    ListView_OnGetItem(a3, (HDPA)a1, (int)&v21);
    if ( v27 != -1 )
      lParam += *((_DWORD *)a1 + 43);
  }
  else
  {
    ListView_GetUnfoldedRect((int)a1, *((_DWORD *)a1 + 39), (LPRECT)&lParam);
    lParam += g_cxLabelMargin;
    Point.x -= g_cxLabelMargin;
  }
  v14 = *((_DWORD *)a1 + 2) & 3;
  if ( v14 == 3 || v14 == 1 )
  {
    v15 = Point.y - *((_DWORD *)a1 + 21) - Y;
    Y += ((signed int)v15 - HIDWORD(v15)) >> 1;
  }
  SendMessageW(*((HWND *)a1 + 38), 0x41Fu, 1u, (LPARAM)&lParam);
  MapWindowPoints(*(HWND *)a1, 0, (LPPOINT)&lParam, 2u);
  if ( *((_BYTE *)a1 + 8) & 3 )
    SetWindowPos(*((HWND *)a1 + 38), 0, lParam, Y, 0, 0, 0x91u);
  else
    SetWindowPos(*((HWND *)a1 + 38), 0, lParam, Y, Point.x - lParam, Point.y - Y, 0x90u);
  *(_DWORD *)(a3 + 12) |= 0x10u;
  return 1;
}
// 6F79299C: using guessed type int (__stdcall *pfnListView_ItemHitTest)(int, POINT pt, int, int);
// 6F7C7E40: using guessed type int dword_6F7C7E40[4];
// 6F7C7E50: using guessed type int dword_6F7C7E50[4];
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7C7E65) --------------------------------------------------------
int __stdcall ListView_OnWinIniChange(INT_PTR i, int a2, int a3)
{
  bool v3; // zf@4
  int result; // eax@13

  InitGlobalMetrics(a2);
  if ( !a2 )
  {
    v3 = a3 == 0;
LABEL_6:
    if ( !v3 )
      goto LABEL_13;
    goto LABEL_7;
  }
  if ( a2 != 34 && a2 != 42 )
  {
    v3 = a2 == 46;
    goto LABEL_6;
  }
LABEL_7:
  if ( !(*(_DWORD *)(i + 44) & 0x1000) )
    ListView_OnSetIconSpacing(i, -1);
  if ( *(_DWORD *)(i + 44) & 0x100 )
    ListView_OnSetFont(i, 0, 1);
  if ( *(_DWORD *)(i + 48) & 0x200 )
  {
    ListView_ExtendedStyleChange(i, 0, 512);
    ListView_ExtendedStyleChange(i, 512, 512);
  }
LABEL_13:
  result = *(_DWORD *)(i + 8);
  if ( result & 0x1100 )
  {
    result &= 3u;
    if ( result == 2 || !result )
      result = ListView_OnArrange((HDC)i, 0);
  }
  return result;
}

//----- (6F7C7EF9) --------------------------------------------------------
void __stdcall ListView_OnPaint(WPARAM wParam, int a2)
{
  bool v2; // zf@1
  int v3; // eax@8
  HRGN v4; // eax@11
  HRGN v5; // ebx@11
  HDC v6; // edi@16
  struct tagRECT Rect; // [sp+Ch] [bp-58h]@7
  HDC hdc; // [sp+1Ch] [bp-48h]@1
  struct tagPAINTSTRUCT Paint; // [sp+20h] [bp-44h]@14

  v2 = *(_DWORD *)(wParam + 228) == 0x7FFFFFFF;
  hdc = (HDC)a2;
  if ( v2 )
    ListView_Recompute(wParam);
  if ( (*(_DWORD *)(wParam + 8) & 3) == 1 && *(_DWORD *)(wParam + 320) )
    UpdateWindow(*(HWND *)(wParam + 320));
  if ( a2 || GetUpdateRect(*(HWND *)wParam, &Rect, 0) )
  {
    v3 = *(_DWORD *)(wParam + 44);
    if ( !(v3 & 2) )
    {
      *(_DWORD *)(wParam + 44) = v3 | 2;
      ListView_MaybeResizeListColumns(wParam, 0, *(_DWORD *)(wParam + 372) - 1);
      ListView_UpdateScrollBars((HDC)wParam);
    }
    if ( !(*(_BYTE *)(wParam + 44) & 0x10) )
    {
      v4 = CreateRectRgn(0, 0, 0, 0);
      v5 = v4;
      if ( v4 )
      {
        GetUpdateRgn(*(HWND *)wParam, v4, 0);
        ListView_InvalidateRegion(wParam, v5);
      }
    }
    if ( hdc )
    {
      InitBrushOrg(wParam, hdc);
      SetRect(&Paint.rcPaint, 0, 0, *(_DWORD *)(wParam + 120), *(_DWORD *)(wParam + 124));
      if ( (*(_BYTE *)(wParam + 44) & 0x12) == 18 )
        ListView_Redraw(wParam, hdc, (int)&Paint.rcPaint);
    }
    else
    {
      v6 = BeginPaint(*(HWND *)wParam, &Paint);
      InitBrushOrg(wParam, v6);
      if ( (*(_BYTE *)(wParam + 44) & 0x12) == 18 )
        ListView_Redraw(wParam, v6, (int)&Paint.rcPaint);
      EndPaint(*(HWND *)wParam, &Paint);
    }
  }
}

//----- (6F7C802C) --------------------------------------------------------
void __userpurge ListView_ToggleSelection(int a1@<edi>, INT_PTR i, int a3)
{
  int v3; // eax@2

  if ( a3 != -1 )
  {
    v3 = ListView_OnGetItemState(a1, (struct _DPA *)i, a3, 2);
    ListView_OnSetItemState(i, a3, v3 ^ 2, 2);
  }
}

//----- (6F7C805E) --------------------------------------------------------
void *__stdcall ListView_SetFocusSel(INT_PTR i, void *p, int a3, int a4, int a5)
{
  INT_PTR v5; // edi@1
  int v6; // eax@4
  void *result; // eax@7
  int v8; // eax@8
  int v9; // eax@10
  int v10; // eax@12
  PVOID v11; // eax@13
  UINT v12; // eax@20
  int v13; // eax@24

  v5 = *(_DWORD *)(i + 100);
  if ( !(*(_BYTE *)(i + 8) & 4) && a4 )
    ListView_DeselectAll(i, -1);
  v6 = *(_DWORD *)(i + 100);
  if ( p == (void *)v6 || v6 == -1 || ListView_OnSetItemState(i, v6, 0, 1) )
  {
    v8 = *(_DWORD *)(i + 8);
    if ( !(v8 & 0x1000) )
    {
      if ( a3 )
      {
        v9 = v8 & 3;
        if ( !v9 || v9 == 2 )
        {
          v10 = DPA_GetPtrIndex(*(HDPA *)(i + 216), p);
          if ( v10 > 0 )
          {
            v11 = DPA_DeletePtr(*(HDPA *)(i + 216), v10);
            DPA_InsertPtr(*(HDPA *)(i + 216), 0, v11);
          }
        }
      }
    }
    if ( v5 != -1 && v5 != *(_DWORD *)(i + 100) && *(_BYTE *)(i + 44) & 0x80 )
      ListView_InvalidateFoldedItem(i, v5, 0, 1u);
    if ( *(_DWORD *)(i + 104) == -1 )
      *(_DWORD *)(i + 104) = p;
    v12 = GetDoubleClickTime();
    SetTimer(*(HWND *)i, 0x2Bu, v12, 0);
    *(_DWORD *)(i + 44) |= 0x200u;
    if ( a5 )
    {
      ListView_ToggleSelection(v5, i, (int)p);
      ListView_OnSetItemState(i, (int)p, 1, 1);
    }
    else
    {
      if ( a3 || *(_BYTE *)(i + 8) & 4 )
        v13 = 3;
      else
        v13 = 1;
      ListView_OnSetItemState(i, (int)p, v13, v13);
    }
    result = p;
  }
  else
  {
    result = *(void **)(i + 100);
  }
  return result;
}

//----- (6F7C8168) --------------------------------------------------------
int __stdcall ListView_OnImeComposition(LPCWSTR lpString, int a2, HLOCAL hMem)
{
  INT_PTR v3; // esi@1
  void *v4; // eax@1
  int v5; // eax@5
  void *v6; // ebx@5
  int v7; // ebx@10
  int v8; // edi@12
  int v9; // eax@14
  int result; // eax@17
  int v11; // edx@20
  int v12; // edi@22
  LPARAM lParam; // [sp+Ch] [bp-34h]@18
  int v14; // [sp+1Ch] [bp-24h]@12
  LPCWSTR v15; // [sp+20h] [bp-20h]@12
  void *p; // [sp+34h] [bp-Ch]@1
  int v17; // [sp+38h] [bp-8h]@1
  HIMC v18; // [sp+3Ch] [bp-4h]@3

  v3 = (INT_PTR)lpString;
  v4 = (void *)*((_DWORD *)lpString + 93);
  v17 = 1;
  p = v4;
  if ( v4 && *((_DWORD *)lpString + 25) != -1 )
  {
    v18 = ImmGetContext(*(HWND *)lpString);
    if ( v18 )
    {
      if ( (unsigned __int16)hMem & 0x800 )
      {
        v17 = 0;
        v5 = (int)GET_COMP_STRING(v18, 0x800u);
        v6 = (void *)v5;
        if ( v5 )
        {
          IncrementSearchImeCompStr(v3 + 456, 0, v5, (int)&lpString);
          LocalFree(v6);
        }
      }
      if ( (unsigned __int8)hMem & 8 )
      {
        v17 = 1;
        hMem = GET_COMP_STRING(v18, 8u);
        if ( hMem )
        {
          if ( IncrementSearchImeCompStr(v3 + 456, 1, (int)hMem, (int)&lpString) )
            v7 = *(_DWORD *)(v3 + 100);
          else
            v7 = (signed int)((char *)p + *(_DWORD *)(v3 + 100) - 1) % (signed int)p;
          v14 = 38;
          v15 = lpString;
          v8 = lstrlenW(lpString);
          if ( v8 == 1 && *lpString == 32 )
          {
            v9 = *(_DWORD *)(v3 + 100);
            if ( v9 != -1 )
            {
              ListView_OnSetItemState(v3, v9, 2, 2);
              IncrementSearchString(v3 + 456, 0, 0);
            }
            CCNotifyNavigationKeyUsage(v3, 1u);
            return 1;
          }
          if ( ListView_IncrementalSearch(v3, v7, (LPARAM)&lParam, (int)&p) )
            return 1;
          if ( v8 > 0 && SameChars((int)lpString, *lpString) )
          {
            v7 = *(_DWORD *)(v3 + 100);
            v15 = (LPCWSTR)(v11 + 2 * v8 - 2);
          }
          v12 = (int)p;
          if ( p == (void *)-1 )
            v12 = ListView_OnFindItem(v3, v7, (int)&v14);
          if ( (unsigned int)v12 >= *(_DWORD *)(v3 + 372) )
            v12 = -1;
          if ( v12 == -1 )
          {
            IncrementSearchBeep(v3 + 456);
          }
          else
          {
            ListView_SetFocusSel(v3, (void *)v12, 1, 1, 0);
            *(_DWORD *)(v3 + 104) = v12;
            if ( ListView_CancelPendingTimer(v3, 512, 0x2Bu) )
              ListView_OnEnsureVisible((HDC)v3, v12, 0);
          }
          CCNotifyNavigationKeyUsage(v3, 1u);
          LocalFree(hMem);
        }
      }
      ImmReleaseContext(*(HWND *)v3, v18);
    }
    result = v17;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F7C8342) --------------------------------------------------------
void __stdcall ListView_OnChar(LPCWSTR lpString, void *p, int a3)
{
  INT_PTR v3; // esi@1
  signed int v4; // ebx@1
  int v5; // ebx@6
  int v6; // edi@8
  int v7; // eax@10
  int v8; // edx@14
  int v9; // edi@16
  LPARAM lParam; // [sp+Ch] [bp-28h]@12
  int v11; // [sp+1Ch] [bp-18h]@8
  LPCWSTR v12; // [sp+20h] [bp-14h]@8

  v3 = (INT_PTR)lpString;
  v4 = *((_DWORD *)lpString + 93);
  if ( v4 && *((_DWORD *)lpString + 25) != -1 )
  {
    if ( (unsigned int)p < 0x20 || GetKeyState(17) < 0 )
    {
      IncrementSearchString(v3 + 456, 0, 0);
    }
    else
    {
      if ( IncrementSearchString(v3 + 456, (int)p, (int)&lpString) )
        v5 = *(_DWORD *)(v3 + 100);
      else
        v5 = (*(_DWORD *)(v3 + 100) + v4 - 1) % v4;
      v11 = 38;
      v12 = lpString;
      v6 = lstrlenW(lpString);
      if ( v6 != 1 || *lpString != 32 )
      {
        if ( ListView_IncrementalSearch(v3, v5, (LPARAM)&lParam, (int)&p) )
          return;
        if ( v6 > 0 && SameChars((int)lpString, *lpString) )
        {
          v5 = *(_DWORD *)(v3 + 100);
          v12 = (LPCWSTR)(v8 + 2 * v6 - 2);
        }
        v9 = (int)p;
        if ( p == (void *)-1 )
          v9 = ListView_OnFindItem(v3, v5, (int)&v11);
        if ( (unsigned int)v9 >= *(_DWORD *)(v3 + 372) )
          v9 = -1;
        if ( v9 == -1 )
        {
          IncrementSearchBeep(v3 + 456);
        }
        else
        {
          ListView_SetFocusSel(v3, (void *)v9, 1, 1, 0);
          *(_DWORD *)(v3 + 104) = v9;
          if ( ListView_CancelPendingTimer(v3, 512, 0x2Bu) )
            ListView_OnEnsureVisible((HDC)v3, v9, 0);
        }
      }
      else
      {
        v7 = *(_DWORD *)(v3 + 100);
        if ( v7 != -1 )
        {
          ListView_OnSetItemState(v3, v7, 2, 2);
          IncrementSearchString(v3 + 456, 0, 0);
        }
      }
      CCNotifyNavigationKeyUsage(v3, 1u);
    }
  }
}

//----- (6F7C84B4) --------------------------------------------------------
LRESULT __stdcall ListView_OnStyleChanged(HDC hdc, int a2, int a3)
{
  HDC v3; // esi@1
  int v4; // ST08_4@2
  int v5; // edi@2
  int v6; // eax@2
  int v7; // ebx@2
  bool v8; // zf@2
  int v9; // eax@4
  HWND v10; // eax@8
  int v11; // eax@18
  int v13; // [sp+8h] [bp-4h]@2
  HDC hdca; // [sp+14h] [bp+8h]@2
  int v15; // [sp+18h] [bp+Ch]@2
  int v16; // [sp+1Ch] [bp+10h]@2
  int v17; // [sp+1Ch] [bp+10h]@2

  v3 = hdc;
  if ( a2 == -16 )
  {
    v4 = (int)hdc;
    v15 = 0;
    hdca = 0;
    ListView_DismissEdit(v4, 0);
    v5 = a3;
    v6 = *((_DWORD *)v3 + 2);
    v7 = v6 ^ *(_DWORD *)(a3 + 4);
    v16 = v6 ^ *(_DWORD *)(a3 + 4);
    v8 = (v16 & 3) == 0;
    v17 = v16 & 3;
    v13 = *((_DWORD *)v3 + 2);
    if ( !v8 && !(v6 & 3) )
    {
      v9 = LV_GetNewColWidth((int)v3, 0, *((_DWORD *)v3 + 93) - 1);
      ListView_ISetColumnWidth((int)v3, 0, v9, 0);
    }
    *((_DWORD *)v3 + 2) = *(_DWORD *)(v5 + 4);
    if ( v7 & 0xC40000 )
      PostMessageW(*(HWND *)v3, 0x401u, 0, 0);
    if ( v7 & 0x4000 )
    {
      v10 = (HWND)*((_DWORD *)v3 + 80);
      if ( v10 )
      {
        SetWindowBits(v10, -16, 8, (*((_DWORD *)v3 + 2) >> 11) & 8);
        v15 = 1;
        hdca = (HDC)1;
      }
    }
    if ( (char)v7 < 0 )
    {
      ListView_InvalidateCachedLabelSizes((int)v3);
      hdca = (HDC)1;
      v15 = 1;
    }
    if ( v17 )
    {
      ListView_TypeChange(v3, v13);
      hdca = (HDC)1;
      v15 = 1;
    }
    if ( v7 & 0x100 && *((_DWORD *)v3 + 2) & 0x100 )
    {
      ListView_OnArrange(v3, 0);
      v15 = 1;
    }
    if ( !hdca )
      goto LABEL_24;
    ListView_UpdateScrollBars(v3);
    v11 = *((_DWORD *)v3 + 25);
    if ( v11 < 0 )
      v11 = ListView_OnGetNextItem(v3, -1, 2);
    if ( v11 == -1 )
    {
      if ( *((_DWORD *)v3 + 93) <= 0 )
        goto LABEL_24;
      v11 = 0;
    }
    ListView_OnEnsureVisible(v3, v11, 1);
LABEL_24:
    if ( v15 )
      RedrawWindow(*(HWND *)v3, 0, 0, 5u);
    return ListView_PopBubble((int)v3);
  }
  if ( a2 == -20 )
  {
    if ( (*((_DWORD *)hdc + 6) ^ *(_DWORD *)(a3 + 4)) & 0x400000 )
      RedrawWindow(*(HWND *)hdc, 0, 0, 5u);
    *((_DWORD *)hdc + 6) = *(_DWORD *)(a3 + 4);
  }
  return ListView_PopBubble((int)v3);
}

//----- (6F7C8621) --------------------------------------------------------
HRGN __stdcall ListView_DragSelect(HDC hdc, int a2, int a3)
{
  HDC v3; // ebx@1
  HWND v4; // ecx@1
  HRGN result; // eax@2
  HWND v6; // eax@4
  HDC v7; // eax@5
  int v8; // esi@21
  int v9; // edi@21
  int v10; // ecx@33
  int v11; // ecx@34
  signed int v12; // esi@34
  LONG v13; // eax@34
  int v14; // ecx@38
  signed int v15; // esi@38
  signed int v16; // edi@38
  int v17; // esi@54
  LONG v18; // ecx@56
  int v19; // esi@60
  BOOL v20; // eax@60
  int v21; // edi@60
  LONG v22; // ecx@67
  HRGN v23; // esi@71
  struct tagRECT v24; // [sp+Ch] [bp-BCh]@60
  RECT v25; // [sp+1Ch] [bp-ACh]@7
  struct tagRECT Rect; // [sp+2Ch] [bp-9Ch]@7
  struct tagRECT rcDst; // [sp+3Ch] [bp-8Ch]@33
  int v28; // [sp+4Ch] [bp-7Ch]@21
  RECT rc2; // [sp+50h] [bp-78h]@1
  int v30; // [sp+60h] [bp-68h]@21
  struct tagMSG Msg; // [sp+64h] [bp-64h]@8
  RECT rcSrc2; // [sp+80h] [bp-48h]@54
  int v33; // [sp+90h] [bp-38h]@21
  int v34; // [sp+94h] [bp-34h]@1
  int v35; // [sp+98h] [bp-30h]@1
  struct tagPOINT Point; // [sp+9Ch] [bp-2Ch]@21
  HRGN hRgn; // [sp+A4h] [bp-24h]@1
  RECT rc; // [sp+A8h] [bp-20h]@1
  HRGN hrgnSrc2; // [sp+B8h] [bp-10h]@1
  int v40; // [sp+BCh] [bp-Ch]@40
  HDC hDC; // [sp+C0h] [bp-8h]@7
  HWND hWnd; // [sp+C4h] [bp-4h]@1

  v3 = hdc;
  v4 = *(HWND *)hdc;
  v34 = 0;
  v35 = 0;
  hRgn = 0;
  hrgnSrc2 = 0;
  rc.right = a2;
  rc.left = a2;
  rc.bottom = a3;
  rc.top = a3;
  rc2.left = a2;
  rc2.top = a3;
  rc2.right = a2;
  hWnd = v4;
  rc2.bottom = a3;
  UpdateWindow(v4);
  if ( !(*((_DWORD *)v3 + 12) & 0x200) )
  {
    v7 = GetDC(hWnd);
    goto LABEL_7;
  }
  result = CreateRectRgn(0, 0, 0, 0);
  hRgn = result;
  if ( result )
  {
    result = CreateRectRgn(0, 0, 0, 0);
    hrgnSrc2 = result;
    if ( result )
    {
      v6 = GetParent(hWnd);
      result = (HRGN)LockWindowUpdate(v6);
      if ( result )
      {
        v7 = GetDCEx(hWnd, 0, 0x420u);
        v35 = 1;
LABEL_7:
        hDC = v7;
        SetCapture(hWnd);
        DrawFocusRect(hDC, &rc);
        GetClientRect(hWnd, &Rect);
        GetWindowRect(hWnd, &v25);
        while ( 1 )
        {
          do
          {
            while ( 1 )
            {
              while ( 1 )
              {
                while ( 1 )
                {
                  do
                  {
                    while ( 1 )
                    {
                      if ( GetCapture() != hWnd )
                      {
LABEL_86:
                        DrawFocusRect(hDC, &rc2);
                        result = (HRGN)ReleaseDC(hWnd, hDC);
                        goto LABEL_87;
                      }
                      if ( PeekMessageW(&Msg, 0, 0, 0, 1u) )
                        break;
                      if ( PtInRect(&v25, Msg.pt) )
                      {
                        WaitMessage();
                      }
                      else if ( ShouldScroll((int)v3, (int)&Msg.pt, (int)&v25) )
                      {
                        SetCursorPos(Msg.pt.x, Msg.pt.y);
                      }
                    }
                  }
                  while ( CallMsgFilterW(&Msg, 16898) );
                  if ( Msg.message > 0x200 )
                  {
                    if ( Msg.message >= 0x201
                      && (Msg.message <= 0x202
                       || Msg.message > 0x203 && (Msg.message <= 0x205 || Msg.message > 0x206 && Msg.message <= 0x208)) )
                    {
                      CCReleaseCapture((int)v3);
                      goto LABEL_86;
                    }
                    goto LABEL_83;
                  }
                  if ( Msg.message != 512 )
                    break;
LABEL_21:
                  v33 = -1;
                  Point = Msg.pt;
                  ScreenToClient(hWnd, &Point);
                  ScrollDetect((int)v3, Point.x, Point.y, &v30, &v28);
                  v8 = v30;
                  a2 -= v30;
                  v9 = v28;
                  a3 -= v28;
                  rc.left = a2;
                  rc.top = a3;
                  *(_QWORD *)&rc.right = Point;
                  if ( Point.x > Rect.right )
                    rc.right = Rect.right;
                  if ( rc.right < Rect.left )
                    rc.right = Rect.left;
                  if ( Point.y > Rect.bottom )
                    rc.bottom = Rect.bottom;
                  if ( rc.bottom < Rect.top )
                    rc.bottom = Rect.top;
                  OrderRect((int)&rc);
                  if ( !EqualRect(&rc, &rc2) )
                  {
                    DrawFocusRect(hDC, &rc2);
                    if ( v8 || v9 )
                      ListView_OnScroll(v3, v8, v9);
                    OffsetRect(&rc2, -v8, -v9);
                    UnionRect(&rcDst, &rc, &rc2);
                    v10 = *((_DWORD *)v3 + 2) & 3;
                    if ( v10 == 1 )
                    {
                      v11 = *((_DWORD *)v3 + 84) - *((_DWORD *)v3 + 81);
                      v12 = *((_DWORD *)v3 + 47);
                      hdc = (HDC)((v11 + rcDst.top) / v12);
                      v13 = (v11 + rcDst.bottom) / v12 + 1;
                    }
                    else if ( v10 == 3 )
                    {
                      v14 = *((_DWORD *)v3 + 45);
                      v15 = *((_DWORD *)v3 + 46);
                      v16 = *((_DWORD *)v3 + 47);
                      hdc = (HDC)(*((_DWORD *)v3 + 48) * ((v14 + rcDst.left) / v15));
                      hdc = (HDC)((char *)hdc + rcDst.top / v16);
                      v13 = rcDst.bottom / v16 + *((_DWORD *)v3 + 48) * ((v14 + rcDst.right) / v15) + 1;
                    }
                    else
                    {
                      if ( *((_DWORD *)v3 + 2) & 0x1000 )
                      {
                        ListView_CalcMinMaxIndex((int)v3, (int)&rcDst, (int)&hdc, (int)&v40);
                        v13 = v40;
                        goto LABEL_43;
                      }
                      hdc = 0;
                      v13 = *((_DWORD *)v3 + 93);
                    }
                    v40 = v13;
LABEL_43:
                    if ( v13 > *((_DWORD *)v3 + 93) )
                    {
                      v13 = *((_DWORD *)v3 + 93);
                      v40 = *((_DWORD *)v3 + 93);
                    }
                    if ( (signed int)hdc < 0 )
                      hdc = 0;
                    if ( *((_DWORD *)v3 + 2) & 0x1000 && (signed int)hdc < v13 )
                    {
                      ListView_NotifyCacheHint((int)v3, (int)hdc, v13 - 1);
                      v13 = v40;
                    }
                    if ( v34 && !(Msg.wParam & 0xC) )
                      *((_DWORD *)v3 + 26) = -1;
                    if ( (signed int)hdc < v13 )
                    {
                      do
                      {
                        ListView_GetRects((int)v3, (int)hdc, 0, 0, 0, &rcSrc2);
                        v17 = *((_DWORD *)v3 + 2) & 3;
                        if ( v17 != 1 || !(*((_BYTE *)v3 + 48) & 0x20) )
                        {
                          v18 = (rcSrc2.right - rcSrc2.left) / 4;
                          if ( v17 == 3 && v18 >= *((_DWORD *)v3 + 43) )
                            v18 = *((_DWORD *)v3 + 43);
                          InflateRect(&rcSrc2, -v18, (rcSrc2.bottom - rcSrc2.top) / -4);
                        }
                        v19 = IntersectRect(&v24, &rc2, &rcSrc2) != 0;
                        v20 = IntersectRect(&v24, &rc, &rcSrc2);
                        v21 = v20 != 0;
                        v34 = v20 != 0;
                        if ( Msg.wParam & 8 )
                        {
                          if ( v19 != v21 )
                            ListView_ToggleSelection(v21, (INT_PTR)v3, (int)hdc);
                        }
                        else
                        {
                          if ( v19 != v21 )
                            ListView_OnSetItemState((INT_PTR)v3, (int)hdc, v19 != 0 ? 0 : 2, 2);
                          if ( v21 )
                          {
                            if ( !(Msg.wParam & 0xC) )
                            {
                              v22 = rcSrc2.top - Point.y;
                              if ( v22 * v22 + (rcSrc2.left - Point.x) * (rcSrc2.left - Point.x) > v33 )
                              {
                                v33 = v22 * v22 + (rcSrc2.left - Point.x) * (rcSrc2.left - Point.x);
                                *((_DWORD *)v3 + 26) = hdc;
                              }
                            }
                          }
                        }
                        hdc = (HDC)((char *)hdc + 1);
                      }
                      while ( (signed int)hdc < v40 );
                    }
                    if ( v35 )
                    {
                      v23 = hRgn;
                      if ( GetUpdateRgn(*(HWND *)v3, hRgn, 0) > 1 )
                      {
                        ValidateRect(*(HWND *)v3, 0);
                        GetWindowRgn(*(HWND *)v3, hrgnSrc2);
                        CombineRgn(v23, v23, hrgnSrc2, 1);
                        SelectClipRgn(hDC, v23);
                        SendMessageW(*(HWND *)v3, 0x318u, (WPARAM)hDC, 0);
                        SelectClipRgn(hDC, 0);
                      }
                    }
                    else
                    {
                      UpdateWindow(*(HWND *)v3);
                    }
                    DrawFocusRect(hDC, &rc);
                    rc2 = rc;
                  }
                }
                if ( Msg.message != 256 )
                  break;
                if ( Msg.wParam == 27 )
                {
                  ListView_DeselectAll((INT_PTR)v3, -1);
                  goto LABEL_86;
                }
              }
              if ( Msg.message > 0x100 )
                break;
LABEL_83:
              if ( Msg.message != g_msgMSWheel )
                goto LABEL_84;
            }
          }
          while ( Msg.message <= 0x102 );
          if ( Msg.message != 275 )
            goto LABEL_83;
          if ( Msg.wParam == 44 )
            goto LABEL_21;
LABEL_84:
          TranslateMessage(&Msg);
          DispatchMessageW(&Msg);
        }
      }
    }
LABEL_87:
    if ( hRgn )
      result = (HRGN)DeleteObject(hRgn);
    if ( hrgnSrc2 )
      result = (HRGN)DeleteObject(hrgnSrc2);
    if ( v35 )
      result = (HRGN)LockWindowUpdate(0);
  }
  return result;
}
// 6F7E6930: using guessed type int g_msgMSWheel;

//----- (6F7C8C17) --------------------------------------------------------
int __stdcall ListView_HandleStateIconClick(INT_PTR i, int a2)
{
  int v2; // esi@1
  int v3; // eax@1

  v2 = (ListView_OnGetItemState(61440, (struct _DPA *)i, a2, 61440) >> 12) & 0xF;
  v3 = ImageList_GetImageCount(*(HIMAGELIST *)(i + 352));
  return ListView_OnSetItemState(i, a2, (v2 % v3 + 1) << 12, 61440);
}

//----- (6F7C8C66) --------------------------------------------------------
int __stdcall ListView_OnTimer(HDC hdc, UINT_PTR uIDEvent)
{
  int result; // eax@1

  result = KillTimer(*(HWND *)hdc, uIDEvent);
  switch ( uIDEvent )
  {
    case 0x2Au:
      result = ListView_CancelPendingTimer((int)hdc, 8, 0x2Au);
      if ( result )
      {
        result = ListView_OnEditLabel(hdc, *((_DWORD *)hdc + 25), 0);
        if ( !result )
        {
          ListView_DismissEdit((int)hdc, 0);
          result = (int)ListView_SetFocusSel((INT_PTR)hdc, *((void **)hdc + 25), 1, 1, 0);
        }
      }
      break;
    case 0x2Bu:
      result = ListView_CancelPendingTimer((int)hdc, 512, 0x2Bu);
      if ( result )
        result = ListView_OnEnsureVisible(hdc, *((_DWORD *)hdc + 25), 1);
      break;
    case 0x2Du:
      *((_DWORD *)hdc + 9) |= 4u;
      break;
    case 0x2Eu:
      result = *((_DWORD *)hdc + 9);
      if ( result & 8 )
      {
        *((_DWORD *)hdc + 9) = result & 0xFFFFFFF7;
        result = (int)CCSendNotify((int)hdc, -114, (LPARAM)(hdc + 65));
      }
      break;
  }
  return result;
}

//----- (6F7C8D0E) --------------------------------------------------------
LPCSTR __stdcall ListView_OnSetItemA(INT_PTR a1, INT_PTR a2)
{
  void *v2; // edi@1
  LPCSTR result; // eax@2
  int v4; // ebx@7
  int v5; // [sp+8h] [bp-4h]@1

  v2 = 0;
  v5 = 0;
  if ( !a2 )
    return 0;
  if ( *(_BYTE *)a2 & 1 && *(_DWORD *)(a2 + 20) )
  {
    v5 = *(_DWORD *)(a2 + 20);
    result = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a2 + 20));
    v2 = (void *)result;
    if ( !result )
      return result;
    *(_DWORD *)(a2 + 20) = result;
  }
  v4 = ListView_OnSetItem(a1, a2);
  if ( v2 )
  {
    *(_DWORD *)(a2 + 20) = v5;
    FreeProducedString(v2);
  }
  return (LPCSTR)v4;
}

//----- (6F7C8D72) --------------------------------------------------------
LPCSTR __stdcall ListView_OnSetItemTextA(int a1, int a2, int a3, LPCSTR lpMultiByteStr)
{
  int v4; // esi@1
  LPCSTR result; // eax@2
  int v6; // edi@3

  v4 = 0;
  if ( !lpMultiByteStr || (result = ProduceWFromA(*(_DWORD *)(a1 + 20), lpMultiByteStr), (v4 = (int)result) != 0) )
  {
    v6 = ListView_OnSetItemText(a1, a2, a3, v4);
    FreeProducedString((HLOCAL)v4);
    result = (LPCSTR)v6;
  }
  return result;
}

//----- (6F7C8DB6) --------------------------------------------------------
int __stdcall ListView_OnInsertItemA(HDC hdc, int a2)
{
  void *v2; // edi@1
  LPCSTR v4; // eax@5
  int v5; // ebx@8
  int v6; // [sp+8h] [bp-4h]@1

  v2 = 0;
  v6 = 0;
  if ( !a2 )
    return -1;
  if ( *(_BYTE *)a2 & 1 && *(_DWORD *)(a2 + 20) )
  {
    v6 = *(_DWORD *)(a2 + 20);
    v4 = ProduceWFromA(*((_DWORD *)hdc + 5), *(LPCSTR *)(a2 + 20));
    v2 = (void *)v4;
    if ( !v4 )
      return -1;
    *(_DWORD *)(a2 + 20) = v4;
  }
  v5 = ListView_OnInsertItem(hdc, a2);
  if ( v2 )
  {
    *(_DWORD *)(a2 + 20) = v6;
    FreeProducedString(v2);
  }
  return v5;
}

//----- (6F7C8E20) --------------------------------------------------------
void __userpurge ListView_SelectRangeTo(int a1@<edi>, void *p, void *a3, int a4)
{
  INT_PTR v4; // esi@1
  int v5; // eax@1
  int v6; // edx@5
  int v7; // eax@5
  signed int v8; // eax@10
  int v9; // edx@18
  int v10; // edi@19
  POINT v11; // ST10_8@20
  int v12; // eax@22
  PVOID v13; // eax@23
  signed int v14; // eax@30
  int v15; // ebx@38
  int v16; // eax@39
  signed int v17; // eax@50
  int v18; // edi@50
  int v19; // eax@51
  int v20; // [sp-14h] [bp-50h]@18
  void *v21; // [sp-10h] [bp-4Ch]@18
  int v22; // [sp-10h] [bp-4Ch]@24
  int i; // [sp-10h] [bp-4Ch]@45
  int v24; // [sp-Ch] [bp-48h]@18
  RECT rcSrc1; // [sp+4h] [bp-38h]@7
  struct tagRECT rcDst; // [sp+14h] [bp-28h]@7
  RECT rcSrc2; // [sp+24h] [bp-18h]@7
  int v28; // [sp+34h] [bp-8h]@1
  int v29; // [sp+38h] [bp-4h]@8

  v4 = (INT_PTR)p;
  v5 = *((_DWORD *)p + 26);
  v28 = 2;
  if ( v5 == -1 )
  {
    ListView_SetFocusSel((INT_PTR)p, a3, 1, 1, 0);
    return;
  }
  if ( !a4 )
    v28 = ListView_OnGetItemState(a1, (struct _DPA *)p, v5, 2);
  v6 = *(_DWORD *)(v4 + 8);
  v7 = *(_DWORD *)(v4 + 8) & 3;
  if ( v7 != 3 && v7 != 1 )
  {
    ListView_GetRects(v4, *(_DWORD *)(v4 + 104), 0, 0, 0, &rcSrc1);
    ListView_GetRects(v4, (int)a3, 0, 0, 0, &rcSrc2);
    UnionRect(&rcDst, &rcSrc1, &rcSrc2);
    if ( *(_DWORD *)(v4 + 8) & 0x1000 )
    {
      ListView_CalcMinMaxIndex(v4, (int)&rcDst, (int)&p, (int)&v29);
      if ( a4 )
        ListView_DeselectAll(v4, -1);
      v8 = *(_DWORD *)(v4 + 372);
      if ( v29 < v8 )
        v8 = v29;
      v29 = v8;
      if ( (signed int)p > 0 )
        goto LABEL_16;
    }
    else
    {
      v8 = *(_DWORD *)(v4 + 372);
      v29 = *(_DWORD *)(v4 + 372);
    }
    p = 0;
LABEL_16:
    if ( *(_DWORD *)(v4 + 8) & 0x1000 && v8 > (signed int)p )
    {
      v9 = **(_DWORD **)(v4 + 364);
      v24 = v8 - 1;
      v21 = p;
      v20 = *(_DWORD *)(v4 + 364);
LABEL_38:
      v15 = v28;
      if ( v28 & 2 )
        v16 = (*(int (__stdcall **)(int, void *, int))(v9 + 12))(v20, v21, v24);
      else
        v16 = (*(int (__stdcall **)(int, void *, int))(v9 + 16))(v20, v21, v24);
      if ( v16 >= 0 )
        ListView_SendODChangeAndInvalidate(v4, (int)p, v29, v15 ^ 2, v15);
      return;
    }
    v10 = (int)p;
    if ( (signed int)p >= v8 )
      return;
    while ( 1 )
    {
      ListView_GetRects(v4, v10, 0, 0, 0, &rcSrc2);
      v11.y = (rcSrc2.top + rcSrc2.bottom) / 2;
      v11.x = (rcSrc2.left + rcSrc2.right) / 2;
      if ( PtInRect(&rcDst, v11) )
        break;
      if ( a4 )
      {
        v22 = 0;
LABEL_27:
        ListView_OnSetItemState(v4, v10, v22, 2);
      }
      ++v10;
      if ( v10 >= v29 )
        return;
    }
    if ( !(*(_DWORD *)(v4 + 8) & 0x1000) )
    {
      v12 = DPA_GetPtrIndex(*(HDPA *)(v4 + 216), (const void *)v10);
      if ( v12 > 0 )
      {
        v13 = DPA_DeletePtr(*(HDPA *)(v4 + 216), v12);
        DPA_InsertPtr(*(HDPA *)(v4 + 216), 0, v13);
      }
    }
    v22 = v28;
    goto LABEL_27;
  }
  v14 = *(_DWORD *)(v4 + 104);
  p = a3;
  if ( (signed int)a3 < v14 || (p = (void *)v14, v29 = (int)a3, (signed int)a3 <= v14) )
    v29 = v14;
  if ( v6 & 0x1000 )
  {
    if ( a4 )
      ListView_DeselectAll(v4, -1);
    if ( v29 <= (signed int)p )
    {
      ListView_OnSetItemState(v4, (int)p, v28, 2);
      return;
    }
    v24 = v29;
    v9 = **(_DWORD **)(v4 + 364);
    v21 = p;
    v20 = *(_DWORD *)(v4 + 364);
    goto LABEL_38;
  }
  if ( a4 )
  {
    for ( i = -1; ; i = v18 )
    {
      v17 = ListView_OnGetNextItem((HDC)v4, i, 2);
      v18 = v17;
      if ( v17 == -1 )
        break;
      if ( v17 < (signed int)p || v17 > v29 )
        ListView_OnSetItemState(v4, v17, 0, 2);
    }
  }
  v19 = (int)p;
  while ( v19 <= v29 )
  {
    ListView_OnSetItemState(v4, v19, v28, 2);
    v19 = (int)((char *)p + 1);
    p = (char *)p + 1;
  }
}

//----- (6F7C9083) --------------------------------------------------------
__int16 __stdcall ListView_OnKey(HCURSOR hCursor, int wParam, int a3, int a4, int a5)
{
  INT_PTR v5; // esi@1
  HWND v6; // eax@1
  int v7; // edi@2
  HCURSOR v8; // eax@21
  int v9; // eax@27
  void *v10; // edi@27
  signed int v11; // eax@30
  int v12; // ST10_4@37
  int v13; // eax@44
  int v15; // [sp-14h] [bp-60h]@29
  int v16; // [sp-10h] [bp-5Ch]@29
  LPARAM v17; // [sp+4h] [bp-48h]@44
  int v18; // [sp+10h] [bp-3Ch]@44
  int v19; // [sp+14h] [bp-38h]@44
  struct tagMSG Msg; // [sp+18h] [bp-34h]@13
  LPARAM lParam; // [sp+34h] [bp-18h]@10
  __int16 v22; // [sp+40h] [bp-Ch]@10
  int v23; // [sp+42h] [bp-Ah]@10
  HWND hWnd; // [sp+48h] [bp-4h]@1
  HCURSOR hCursora; // [sp+54h] [bp+8h]@16
  HCURSOR hCursorb; // [sp+54h] [bp+8h]@21
  WPARAM wParama; // [sp+58h] [bp+Ch]@21
  int v28; // [sp+5Ch] [bp+10h]@16

  v5 = (INT_PTR)hCursor;
  v6 = *(HWND *)hCursor;
  hWnd = *(HWND *)hCursor;
  if ( a3 )
  {
    v7 = RTLSwapLeftRightArrows((int)hCursor, wParam);
    if ( !(*((_BYTE *)hCursor + 48) & 0x40)
      || (v6 = (HWND)*((_DWORD *)hCursor + 9), !((unsigned __int8)v6 & 8))
      || !((unsigned __int8)v6 & 4)
      || v7 != 16
      && v7 != 17
      && v7 != 18
      && v7 != 13
      && (KillTimer(*(HWND *)hCursor, 0x2Eu),
          *((_DWORD *)hCursor + 9) &= 0xFFFFFFF7,
          CCSendNotify((int)hCursor, -114, (LPARAM)(hCursor + 65)),
          (v6 = (HWND)IsWindow(hWnd)) != 0) )
    {
      v23 = a5;
      v22 = v7;
      v6 = CCSendNotify((int)hCursor, -155, (LPARAM)&lParam);
      if ( v6 )
      {
        ++*((_DWORD *)hCursor + 36);
        return (signed __int16)v6;
      }
      for ( ; *((_DWORD *)hCursor + 36); --*((_DWORD *)hCursor + 36) )
      {
        v6 = (HWND)PeekMessageW(&Msg, *(HWND *)hCursor, 0x102u, 0x102u, 1u);
        if ( !v6 )
          break;
      }
      if ( *((_DWORD *)hCursor + 93) )
      {
        hCursora = (HCURSOR)(GetKeyState(17) < 0);
        v28 = GetKeyState(16) < 0;
        if ( v7 != 13 )
        {
          if ( v7 == 32 )
          {
            if ( hCursora )
            {
              v12 = *(_DWORD *)(v5 + 100);
              *(_DWORD *)(v5 + 104) = v12;
              ListView_ToggleSelection((int)GetKeyState, v5, v12);
              ++*(_DWORD *)(v5 + 144);
            }
            if ( v28 )
              ListView_SelectRangeTo((int)GetKeyState, (void *)v5, *(void **)(v5 + 100), 1);
            if ( *(_BYTE *)(v5 + 48) & 4 && *(_DWORD *)(v5 + 100) != -1 )
              ListView_HandleStateIconClick(v5, *(_DWORD *)(v5 + 100));
          }
          else if ( v7 != 107 || (*(_DWORD *)(v5 + 8) & 3) != 1 || GetKeyState(17) >= 0 )
          {
            LOWORD(v6) = GetKeyState(18);
            if ( (signed __int16)v6 < 0 )
              return (signed __int16)v6;
            if ( *(_BYTE *)(v5 + 8) & 4 )
            {
              hCursora = 0;
              v28 = 0;
            }
            v9 = ListView_Arrow((HDC)v5, *(_DWORD *)(v5 + 100), v7);
            v10 = (void *)v9;
            if ( v9 != -1 )
            {
              if ( v28 )
              {
                ListView_SelectRangeTo(v9, (void *)v5, (void *)v9, 1);
                v16 = 0;
                v15 = 0;
              }
              else
              {
                v11 = 0;
                if ( !hCursora )
                {
                  *(_DWORD *)(v5 + 104) = v10;
                  v11 = 1;
                }
                v16 = v11;
                v15 = hCursora == 0;
              }
              ListView_SetFocusSel(v5, v10, v15, v16, 0);
              IncrementSearchString(v5 + 456, 0, 0);
              CCPlaySound(L"CCSelect");
            }
            if ( ListView_CancelPendingTimer(v5, 512, 0x2Bu) )
            {
              ListView_OnEnsureVisible((HDC)v5, *(_DWORD *)(v5 + 100), 0);
              UpdateWindow(*(HWND *)v5);
            }
          }
          else
          {
            v8 = LoadCursorW(0, (LPCWSTR)0x7F02);
            wParama = 0;
            hCursorb = SetCursor(v8);
            if ( *(_DWORD *)(v5 + 312) > 0 )
            {
              do
                ListView_RSetColumnWidth(v5, wParama++, -1);
              while ( (signed int)wParama < *(_DWORD *)(v5 + 312) );
            }
            SetCursor(hCursorb);
          }
LABEL_45:
          LOWORD(v6) = CCNotifyNavigationKeyUsage(v5, 1u);
          return (signed __int16)v6;
        }
        CCSendNotify(v5, -4, 0);
        v6 = (HWND)IsWindow(hWnd);
        if ( v6 )
        {
          v13 = *(_DWORD *)(v5 + 100);
          Msg.lParam = -1;
          Msg.time = -1;
          v18 = v13;
          v19 = 0;
          Msg.wParam = 0;
          Msg.pt.y = GetLVKeyFlags();
          CCSendNotify(v5, -114, (LPARAM)&v17);
          v6 = (HWND)IsWindow(hWnd);
          if ( v6 )
            goto LABEL_45;
        }
      }
    }
  }
  return (signed __int16)v6;
}

//----- (6F7C934C) --------------------------------------------------------
int __userpurge ListView_ButtonSelect@<eax>(int a1@<edi>, INT_PTR i, void *p, int a4, int a5)
{
  int result; // eax@1
  int v6; // [sp-8h] [bp-8h]@2

  result = a4;
  if ( a4 & 4 )
  {
    ListView_SelectRangeTo(a1, (void *)i, p, ~(unsigned __int8)((unsigned int)a4 >> 3) & 1);
    v6 = 0;
  }
  else
  {
    if ( a4 & 8 )
      return result;
    v6 = a5 == 0;
  }
  return (int)ListView_SetFocusSel(i, p, 1, v6, 0);
}

//----- (6F7C9397) --------------------------------------------------------
int __stdcall ListView_HandleMouse(HWND hWnd, int a2, int a3, int a4, int a5, int a6)
{
  INT_PTR v6; // ebx@1
  int result; // eax@1
  HWND v8; // ecx@1
  int v9; // eax@2
  bool v10; // zf@2
  HWND v11; // esi@6
  int v12; // edi@6
  LONG v13; // ecx@6
  int v14; // esi@15
  HWND v15; // eax@71
  LONG v16; // esi@71
  int v17; // ecx@72
  int v18; // eax@81
  UINT v19; // eax@89
  HWND v20; // eax@92
  int v21; // [sp-14h] [bp-74h]@56
  int v22; // [sp-Ch] [bp-6Ch]@56
  LPARAM lParam; // [sp+4h] [bp-5Ch]@27
  int v24; // [sp+10h] [bp-50h]@19
  int v25; // [sp+14h] [bp-4Ch]@19
  int v26; // [sp+18h] [bp-48h]@19
  int v27; // [sp+20h] [bp-40h]@19
  int v28; // [sp+24h] [bp-3Ch]@19
  int v29; // [sp+28h] [bp-38h]@19
  int v30; // [sp+30h] [bp-30h]@19
  int v31; // [sp+34h] [bp-2Ch]@15
  int v32; // [sp+38h] [bp-28h]@15
  int v33; // [sp+3Ch] [bp-24h]@18
  int v34; // [sp+44h] [bp-1Ch]@15
  struct tagPOINT Point; // [sp+48h] [bp-18h]@6
  int v36; // [sp+50h] [bp-10h]@9
  int v37; // [sp+54h] [bp-Ch]@15
  int v38; // [sp+58h] [bp-8h]@21
  int v39; // [sp+5Ch] [bp-4h]@6
  HWND hWnda; // [sp+68h] [bp+8h]@1
  int v41; // [sp+6Ch] [bp+Ch]@41

  v6 = (INT_PTR)hWnd;
  result = *((_DWORD *)hWnd + 9);
  v8 = *(HWND *)hWnd;
  hWnda = *(HWND *)hWnd;
  if ( result & 2 )
    return result;
  v9 = result | 2;
  v10 = (*(_BYTE *)(v6 + 48) & 0x40) == 0;
  *(_DWORD *)(v6 + 36) = v9;
  if ( !v10 )
  {
    if ( v9 & 8 )
    {
      if ( v9 & 4 )
      {
        KillTimer(v8, 0x2Eu);
        *(_DWORD *)(v6 + 36) &= 0xFFFFFFF7;
        CCSendNotify(v6, -114, v6 + 260);
        result = IsWindow(hWnda);
        if ( !result )
          return result;
      }
    }
  }
  v11 = *(HWND *)v6;
  v12 = GetFocus() == v11;
  v39 = (a5 & 2) != 0 ? -5 : -2;
  Point.y = ~(_BYTE)a5 & 2 | 0xFFFFFF91;
  v36 = ChildOfActiveWindow(v11) || fShouldFirstClickActivate(v13) || ChildOfDesktop(*(HWND *)v6);
  SetCapture(*(HWND *)v6);
  *(_DWORD *)(v6 + 448) = a3;
  *(_DWORD *)(v6 + 452) = a4;
  if ( !ListView_DismissEdit(v6, 0) && GetCapture() != *(HWND *)v6 )
    goto LABEL_113;
  CCReleaseCapture(v6);
  if ( *(_BYTE *)(v6 + 8) & 4 )
    a5 &= 0xFFFFFFF3;
  v31 = a3;
  v32 = a4;
  v14 = ListView_OnSubItemHitTest((HDC)v6, (int)&v31);
  v37 = v14;
  if ( v34 && !(*(_BYTE *)(v6 + 48) & 0x20) && !(*(_DWORD *)(v6 + 8) & 0x400) )
  {
    v14 = -1;
    v37 = -1;
    v33 = 1;
  }
  v27 = 0;
  v25 = v34;
  v28 = a3;
  v24 = v14;
  v29 = a4;
  v26 = 0;
  v30 = GetLVKeyFlags();
  *(_DWORD *)(v6 + 400) = v14;
  v38 = v14 >= 0 && ListView_OnGetItemState(v12, (struct _DPA *)v6, v14, 2);
  if ( a2 )
  {
    ListView_CancelPendingTimer(v6, 8, 0x2Au);
    KillTimer(*(HWND *)v6, 0x2Bu);
    if ( v33 & 1 && !(a5 & 0xC) )
      ListView_DeselectAll(v6, -1);
    if ( !CCSendNotify(v6, (a5 & 2) != 0 ? -6 : -3, (LPARAM)&lParam) )
    {
      result = IsWindow(hWnda);
      if ( !result )
        return result;
      if ( ((a5 & 2) != 0 ? 0xFFFFFFFD : 0) == 0 )
      {
        if ( v33 & 6 )
        {
          if ( !(*(_BYTE *)(v6 + 48) & 0x40) || !(*(_BYTE *)(v6 + 36) & 4) || a5 & 0xC )
            CCSendNotify(v6, -114, (LPARAM)&lParam);
        }
        else if ( v33 & 8 && *(_BYTE *)(v6 + 48) & 4 )
        {
          ListView_HandleStateIconClick(v6, v37);
        }
      }
      result = IsWindow(hWnda);
      if ( !result )
        return result;
    }
LABEL_113:
    result = IsWindow(hWnda);
    if ( result )
      *(_DWORD *)(v6 + 36) &= 0xFFFFFFFD;
    return result;
  }
  if ( !(v33 & 6) )
  {
    if ( v33 & 8 )
    {
      result = ListView_SetFocus(*(HWND *)v6);
      if ( !result )
        return result;
      v20 = CCSendNotify(v6, v39, (LPARAM)&lParam);
      v16 = v20 == 0;
      if ( v20 )
        goto LABEL_113;
      if ( *(_BYTE *)(v6 + 48) & 4 )
        ListView_HandleStateIconClick(v6, v37);
      goto LABEL_110;
    }
    if ( !(v33 & 1) )
      goto LABEL_113;
    result = ListView_SetFocus(*(HWND *)v6);
    if ( !result )
      return result;
    if ( *(_BYTE *)(v6 + 8) & 4 || !CheckForDragBegin(*(HWND *)v6, a3, a4) || CCSendNotify(v6, -156, (LPARAM)&lParam) )
    {
      result = IsWindow(hWnda);
      if ( !result )
        return result;
      if ( !v12 && !(*(_BYTE *)(v6 + 8) & 8) && !(a5 & 0xE) || !v36 )
        goto LABEL_113;
      if ( !(a5 & 0xC) )
        ListView_DeselectAll(v6, -1);
      goto LABEL_109;
    }
    if ( !(a5 & 0xC) )
      ListView_DeselectAll(v6, -1);
LABEL_48:
    ListView_DragSelect((HDC)v6, a3, a4);
LABEL_109:
    v16 = CCSendNotify(v6, v39, (LPARAM)&lParam) == 0;
    goto LABEL_110;
  }
  CCPlaySound(L"CCSelect");
  v41 = a5 & 2;
  if ( !(a5 & 2) || !(a5 & 0xC) )
    ListView_ButtonSelect(v12, v6, (void *)v14, a5, v38);
  if ( !a6 && CheckForDragBegin(*(HWND *)v6, a3, a4) )
  {
    if ( !ListView_RBeginMarquee(v6, a3, a4, (int)&v31) || CCSendNotify(v6, -156, (LPARAM)&lParam) )
    {
      ListView_SetFocusSel(v6, (void *)v14, 1, 0, 0);
      if ( !(a5 & 4) )
        *(_DWORD *)(v6 + 104) = v14;
      UpdateWindow(*(HWND *)v6);
      CCSendNotify(v6, Point.y, (LPARAM)&lParam);
      goto LABEL_113;
    }
    goto LABEL_48;
  }
  result = IsWindow(hWnda);
  if ( result )
  {
    if ( !v41 && a5 & 8 )
    {
      if ( a5 & 4 )
      {
        v22 = 0;
        v21 = 0;
      }
      else
      {
        v22 = 1;
        v21 = 1;
      }
      ListView_SetFocusSel(v6, (void *)v14, v21, 0, v22);
    }
    if ( !(a5 & 4) )
      *(_DWORD *)(v6 + 104) = v14;
    result = ListView_SetFocus(*(HWND *)v6);
    if ( result )
    {
      if ( !(a5 & 4) && !(a5 & 8) && !v41 )
      {
        ListView_DeselectAll(v6, v14);
        if ( v33 & 4 )
        {
          if ( v38 && !(*(_BYTE *)(v6 + 48) & 0xC0) && (v12 || *(_DWORD *)(v6 + 8) & 0x400) )
            ListView_SetupPendingNameEdit(v6);
        }
      }
      v15 = CCSendNotify(v6, v39, (LPARAM)&lParam);
      v16 = v15 == 0;
      Point.y = v15 == 0;
      result = IsWindow(hWnda);
      if ( result )
      {
        v17 = *(_DWORD *)(v6 + 48);
        if ( v17 & 0xC0 && !v41 && (v17 & 0x40 && *(_BYTE *)(v6 + 36) & 4 || v38) && v36 )
        {
          v18 = v17 & 0x40 && !(a5 & 8) && !(a5 & 4);
          if ( v38 && (char)v17 < 0 )
          {
LABEL_87:
            CCSendNotify(v6, -114, (LPARAM)&lParam);
            result = IsWindow(hWnda);
            if ( !result )
              return result;
            goto LABEL_110;
          }
          if ( v18 )
          {
            if ( !g_bUseDblClickTimer )
              goto LABEL_87;
            *(_DWORD *)(v6 + 36) |= 8u;
            qmemcpy((void *)(v6 + 260), &lParam, 0x30u);
            v19 = GetDoubleClickTime();
            SetTimer(*(HWND *)v6, 0x2Eu, v19, 0);
            v16 = Point.y;
          }
        }
LABEL_110:
        if ( v16 && v39 == -5 )
        {
          Point.x = a3;
          Point.y = a4;
          ClientToScreen(*(HWND *)v6, &Point);
          SendMessageW(*(HWND *)v6, 0x7Bu, *(_DWORD *)v6, (unsigned __int16)Point.x | (LOWORD(Point.y) << 16));
        }
        goto LABEL_113;
      }
    }
  }
  return result;
}
// 6F7E8E50: using guessed type int g_bUseDblClickTimer;

//----- (6F7C993A) --------------------------------------------------------
int __stdcall ListView_OnButtonDown(HWND hWnd, int a2, int a3, int a4, int a5)
{
  return ListView_HandleMouse(hWnd, a2, a3, a4, a5, 0);
}

//----- (6F7C995E) --------------------------------------------------------
HWND __stdcall ListView_OnMouseHover(HDC hdc, int a2, int a3, int a4)
{
  HWND result; // eax@1
  INT_PTR v5; // esi@2
  int v6; // edi@8
  int v7; // eax@11
  HWND v8; // ebx@13
  int v9; // ebx@15
  int v10; // [sp+0h] [bp-18h]@8
  int v11; // [sp+4h] [bp-14h]@8
  char v12; // [sp+8h] [bp-10h]@14
  int v13; // [sp+14h] [bp-4h]@6
  HDC hdca; // [sp+20h] [bp+8h]@6
  int v15; // [sp+24h] [bp+Ch]@14

  result = GetCapture();
  if ( !result )
  {
    v5 = (INT_PTR)hdc;
    result = (HWND)ChildOfActiveWindow(*(HWND *)hdc);
    if ( result )
    {
      result = (HWND)EditBoxHasFocus();
      if ( !result )
      {
        result = CCSendNotify((int)hdc, -13, 0);
        if ( !result )
        {
          if ( *((_BYTE *)hdc + 8) & 4 )
          {
            v13 = 0;
            hdca = 0;
          }
          else
          {
            v13 = GetAsyncKeyState(17) < 0;
            hdca = (HDC)(GetAsyncKeyState(16) < 0);
          }
          v10 = a2;
          v11 = a3;
          result = (HWND)ListView_OnHitTest((HDC)v5, (int)&v10);
          v6 = (int)result;
          if ( result != HWND_MESSAGE|0x2 && result != *(HWND *)(v5 + 400) )
          {
            if ( !(*(_BYTE *)(v5 + 48) & 0x40)
              || (v7 = *(_DWORD *)(v5 + 36), !(v7 & 8))
              || !(v7 & 4)
              || (v8 = *(HWND *)v5,
                  KillTimer(*(HWND *)v5, 0x2Eu),
                  *(_DWORD *)(v5 + 36) &= 0xFFFFFFF7,
                  CCSendNotify(v5, -114, v5 + 260),
                  (result = (HWND)IsWindow(v8)) != 0) )
            {
              *(_DWORD *)(v5 + 400) = v6;
              result = (HWND)ListView_OnGetItemState(v6, (struct _DPA *)v5, v6, 2);
              v15 = (int)result;
              if ( v12 & 6 )
              {
                v9 = 0;
                if ( hdca )
                  v9 = 4;
                if ( v13 )
                  v9 |= 8u;
                if ( !result )
                  CCPlaySound(L"CCSelect");
                ListView_ButtonSelect(v6, v5, (void *)v6, v9, v15);
                if ( v13 )
                  ListView_SetFocusSel(v5, (void *)v6, hdca == 0, 0, hdca == 0);
                if ( !hdca )
                  *(_DWORD *)(v5 + 104) = v6;
                ListView_OnSetCursorMsg(v6, v5);
                result = SetFocus(*(HWND *)v5);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (6F7C9AC1) --------------------------------------------------------
INT_PTR __stdcall ListView_WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LPARAM v4; // edi@1
  LONG v5; // esi@1
  HLOCAL v6; // eax@3
  LONG v7; // esi@3
  INT_PTR result; // eax@4
  HWND v9; // ST0C_4@5
  int v10; // eax@10
  bool v11; // zf@10
  int v12; // ecx@12
  HWND v13; // eax@34
  int v14; // ecx@95
  HWND v15; // eax@114
  int v16; // eax@120
  HWND v17; // eax@135
  HWND v18; // eax@138
  HWND v19; // esi@146
  HWND v20; // esi@149
  int v21; // esi@184
  int v22; // edi@187
  int v23; // eax@236
  int v24; // ecx@236
  int v25; // esi@250
  int v26; // esi@260
  int v27; // ebx@260
  int v28; // ecx@284
  int v29; // eax@289
  int v30; // eax@290
  int v31; // eax@308
  int v32; // eax@313
  int v33; // ebx@314
  int v34; // eax@314
  HWND v35; // eax@314
  BOOL v36; // eax@315
  signed int v37; // eax@318
  int v38; // ebx@320
  HWND v39; // [sp-Ch] [bp-170h]@314
  LPARAM v40; // [sp+Ch] [bp-158h]@34
  HWND v41; // [sp+14h] [bp-150h]@34
  int v42; // [sp+18h] [bp-14Ch]@34
  struct tagRECT Rect; // [sp+1Ch] [bp-148h]@34
  int v44; // [sp+2Ch] [bp-138h]@318
  int v45; // [sp+30h] [bp-134h]@322
  WPARAM v46; // [sp+38h] [bp-12Ch]@308
  int v47; // [sp+3Ch] [bp-128h]@115
  int code; // [sp+40h] [bp-124h]@308
  struct tagPOINT Point; // [sp+44h] [bp-120h]@10
  int v50; // [sp+4Ch] [bp-118h]@10
  HWND v51; // [sp+50h] [bp-114h]@10
  int v52; // [sp+54h] [bp-110h]@10
  int v53; // [sp+58h] [bp-10Ch]@116
  HWND v54; // [sp+5Ch] [bp-108h]@1
  BYTE KeyState; // [sp+60h] [bp-104h]@328
  char v56; // [sp+70h] [bp-F4h]@329

  v4 = lParam;
  v54 = hWnd;
  v5 = GetWindowLongW(hWnd, 0);
  if ( !v5 )
  {
    if ( Msg == 129 )
    {
      v6 = LocalAlloc(0x40u, 0x1E0u);
      v7 = (LONG)v6;
      if ( !v6 )
        return 0;
      *(_DWORD *)v6 = v54;
      *((_DWORD *)v6 + 25) = -1;
      *((_DWORD *)v6 + 26) = -1;
      *((_DWORD *)v6 + 85) = -1;
      *((_DWORD *)v6 + 94) = -1;
      *((_DWORD *)v6 + 11) = 16;
      *((_DWORD *)v6 + 87) = 1;
      *((_DWORD *)v6 + 47) = 1;
      v9 = v54;
      *((_DWORD *)v6 + 20) = GetProcessHeap();
      SetWindowLongW(v9, 0, v7);
    }
    return DefWindowProcW(v54, Msg, wParam, v4);
  }
  if ( Msg - 512 <= 0xD && *(_BYTE *)(v5 + 48) & 0xC8 )
  {
    v51 = *(HWND *)v5;
    v52 = *(_DWORD *)(v5 + 404);
    Point.y = 16;
    v50 = 1073741827;
    _TrackMouseEvent((LPTRACKMOUSEEVENT)&Point.y);
    v10 = ((unsigned __int8)v50 ^ 0xFE) & 3;
    v11 = (*(_BYTE *)(v5 + 48) & 8) == 0;
    v50 = ((unsigned __int8)v50 ^ 0xFE) & 3;
    if ( !v11 )
    {
      v10 ^= 1u;
      v50 = v10;
    }
    v51 = *(HWND *)v5;
    v12 = *(_DWORD *)(v5 + 404);
    Point.y = 16;
    v52 = v12;
    if ( v10 & 3 )
      _TrackMouseEvent((LPTRACKMOUSEEVENT)&Point.y);
  }
  if ( Msg == g_uDragImages )
    return LVGenerateDragImage(v5, lParam);
  if ( Msg > 0x1015 )
  {
    switch ( Msg )
    {
      default:
        goto LABEL_133;
      case 0x1019u:
        return ListView_OnGetColumnA(v5, wParam, lParam);
      case 0x101Au:
        return (INT_PTR)ListView_OnSetColumnA(v5, wParam, lParam);
      case 0x101Bu:
        return ListView_OnInsertColumnA(v5, wParam, lParam);
      case 0x102Du:
        return ListView_OnGetItemTextA(v5, wParam, lParam);
      case 0x102Eu:
        if ( !lParam )
          return 0;
        return (INT_PTR)ListView_OnSetItemTextA(v5, wParam, *(_DWORD *)(lParam + 8), *(LPCSTR *)(lParam + 20));
      case 0x1045u:
        return ListView_OnGetBkImageA(v5, lParam);
      case 0x1044u:
        return (INT_PTR)ListView_OnSetBkImageA(v5, (const void *)lParam);
      case 0x1023u:
        return *(_DWORD *)(v5 + 68);
      case 0x1024u:
        *(_DWORD *)(v5 + 68) = lParam;
        return 1;
      case 0x1025u:
        return *(_DWORD *)(v5 + 72);
      case 0x1026u:
        *(_DWORD *)(v5 + 72) = lParam;
        return 1;
      case 0x104Fu:
        return *(_DWORD *)(v5 + 444);
      case 0x1050u:
        *(_DWORD *)(v5 + 444) = lParam;
        return 1;
      case 0x104Bu:
        return ListView_OnGetItem(lParam, (HDPA)v5, lParam);
      case 0x102Cu:
        return ListView_OnGetItemState(lParam, (struct _DPA *)v5, wParam, lParam);
      case 0x102Bu:
        if ( !lParam )
          return 0;
        return ListView_OnSetItemState(v5, wParam, *(_DWORD *)(lParam + 12), *(_DWORD *)(lParam + 16));
      case 0x1074u:
        if ( !lParam )
          return 0;
        return ListView_OnSetItemText(v5, wParam, *(_DWORD *)(lParam + 8), *(_DWORD *)(lParam + 20));
      case 0x1073u:
        return ListView_OnGetItemText(lParam, (struct _DPA *)v5, wParam, lParam);
      case 0x108Bu:
        return ListView_OnGetBkImage(v5, lParam);
      case 0x108Au:
        return ListView_OnSetBkImage(v5, (STRSAFE_LPCWSTR)lParam);
      case 0x104Cu:
        return ListView_OnSetItem(v5, lParam);
      case 0x104Du:
        return ListView_OnInsertItem((HDC)v5, lParam);
      case 0x102Au:
        ListView_OnUpdate((HDC)v5, wParam);
        UpdateWindow(*(HWND *)v5);
        return 1;
      case 0x1038u:
        return ListView_OnGetSubItemRect(v5, wParam, (LPRECT)lParam);
      case 0x1039u:
        return ListView_OnSubItemHitTest((HDC)v5, lParam);
      case 0x1034u:
        if ( GetFocus() != *(HWND *)v5 )
          return 0;
        return GetIncrementSearchStringA(v5 + 456, *(_DWORD *)(v5 + 20), (LPSTR)lParam);
      case 0x1075u:
        if ( GetFocus() != *(HWND *)v5 )
          return 0;
        return GetIncrementSearchString(v5 + 456, (STRSAFE_LPWSTR)lParam);
      case 0x1033u:
        if ( wParam )
        {
          v23 = *(_WORD *)(v5 + 188);
          v24 = *(_WORD *)(v5 + 184);
        }
        else
        {
          v23 = *(_WORD *)(v5 + 200);
          v24 = *(_WORD *)(v5 + 196);
        }
        return v24 | (v23 << 16);
      case 0x1053u:
        return ListView_OnFindItem(v5, wParam, lParam);
      case 0x1043u:
        result = *(_DWORD *)(v5 + 104);
        if ( lParam == -1 || (unsigned int)lParam < *(_DWORD *)(v5 + 372) )
          *(_DWORD *)(v5 + 104) = lParam;
        return result;
      case 0x1042u:
        return *(_DWORD *)(v5 + 104);
      case 0x1031u:
        if ( !lParam )
          return 0;
        return ListView_OnSetItemPosition(v5, wParam, *(_DWORD *)lParam, *(_DWORD *)(lParam + 4));
      case 0x1016u:
        return ListView_OnArrange((HDC)v5, wParam);
      case 0x1018u:
        return *(_DWORD *)(v5 + 248);
      case 0x1017u:
        v54 = 0;
        if ( lParam )
          v54 = (HWND)ProduceWFromA(*(_DWORD *)(v5 + 20), (LPCSTR)lParam);
        v25 = ListView_OnEditLabel((HDC)v5, wParam, (int)v54);
        if ( v54 )
          FreeProducedString(v54);
        return v25;
      case 0x1076u:
        return ListView_OnEditLabel((HDC)v5, wParam, lParam);
      case 0x1057u:
        return ListView_OnGetStringWidth(v5, (LPCWSTR)lParam, 0);
      case 0x105Fu:
        return ListView_OnGetColumn(v5, wParam, lParam);
      case 0x1060u:
        return ListView_OnSetColumn(v5, wParam, lParam);
      case 0x103Au:
        return SendMessageW(*(HWND *)(v5 + 320), 0x1212u, wParam, lParam);
      case 0x103Bu:
        return SendMessageW(*(HWND *)(v5 + 320), 0x1211u, wParam, lParam);
      case 0x101Fu:
        v26 = v5 + 320;
        v27 = *(_DWORD *)v26;
        if ( lParam && IsWindow((HWND)lParam) )
          *(_DWORD *)v26 = lParam;
        return v27;
      case 0x1061u:
        return ListView_OnInsertColumn(v5, wParam, lParam);
      case 0x101Cu:
        return ListView_OnDeleteColumn(v5, wParam);
      case 0x1021u:
        return (INT_PTR)ListView_OnCreateDragImage(v5, wParam, (HGDIOBJ)lParam);
      case 0x1022u:
        if ( !lParam )
          return 0;
        ListView_GetViewRect2(v5, (LPRECT)lParam, *(_DWORD *)(v5 + 120), *(_DWORD *)(v5 + 124));
        return 1;
      case 0x101Du:
        return ListView_OnGetColumnWidth(v5, wParam);
      case 0x101Eu:
        return ListView_ISetColumnWidth(v5, wParam, (signed __int16)lParam, 1);
      case 0x1027u:
        return ListView_OnGetTopIndex(v5);
      case 0x1028u:
        return ListView_OnGetCountPerPage(v5);
      case 0x1029u:
        return ListView_OnGetOrigin(v5, lParam);
      case 0x102Fu:
        return ListView_OnSetItemCount((HDC)v5, wParam, lParam);
      case 0x1032u:
        if ( *(_DWORD *)(v5 + 8) & 0x1000 )
          (*(void (__stdcall **)(_DWORD, int))(**(_DWORD **)(v5 + 364) + 52))(*(_DWORD *)(v5 + 364), v5 + 136);
        return *(_DWORD *)(v5 + 136);
      case 0x1030u:
        return ListView_OnSortItems((void *)v5, wParam, lParam, 1);
      case 0x1051u:
        return ListView_OnSortItems((void *)v5, wParam, lParam, 0);
      case 0x1036u:
        return ListView_ExtendedStyleChange(v5, lParam, wParam);
      case 0x1037u:
        return *(_DWORD *)(v5 + 48);
      case 0x1048u:
        return *(_DWORD *)(v5 + 404);
      case 0x1047u:
        v28 = v5 + 404;
        goto LABEL_285;
      case 0x104Eu:
        return *(_DWORD *)(v5 + 152);
      case 0x104Au:
        result = *(_DWORD *)(v5 + 152);
        *(_DWORD *)(v5 + 152) = wParam;
        return result;
      case 0x1035u:
        v22 = ListView_OnSetIconSpacing(v5, lParam);
        if ( (*(_BYTE *)(v5 + 44) & 0x12) == 18 )
        {
          v29 = *(_DWORD *)(v5 + 8);
          if ( v29 & 0x100 )
          {
            v30 = v29 & 3;
            if ( v30 == 2 || !v30 )
              ListView_OnArrange((HDC)v5, 0);
          }
        }
        return v22;
      case 0x103Cu:
        v22 = *(_DWORD *)(v5 + 392);
        if ( wParam == -1 || wParam < *(_DWORD *)(v5 + 372) )
          ListView_OnSetHotItem(v5, wParam);
        return v22;
      case 0x103Du:
        return *(_DWORD *)(v5 + 392);
      case 0x103Eu:
        v28 = v5 + 408;
LABEL_285:
        result = *(_DWORD *)v28;
        *(_DWORD *)v28 = lParam;
        return result;
      case 0x103Fu:
        v21 = v5 + 408;
        if ( !*(_DWORD *)v21 )
          *(_DWORD *)v21 = LoadHandCursor(0);
        return *(_DWORD *)v21;
      case 0x1040u:
        return ListView_OnApproximateViewRect(v5, wParam, (signed __int16)lParam, SHIWORD(lParam));
      case 0x1052u:
        return ListView_OnSetLVRangeObject(v5, wParam, lParam);
      case 0x1041u:
        ListView_OnSetWorkAreas(v5, (void *)wParam, (RECT *)lParam);
        return 0;
      case 0x1046u:
        ListView_OnGetWorkAreas(v5, wParam, (LPRECT)lParam);
        return 0;
      case 0x1049u:
        ListView_OnGetNumberOfWorkAreas(v5, lParam);
        return 0;
      case 0x1054u:
        *(_DWORD *)(v5 + 36) &= 0xFFFFFFBF;
        Str_Set(v5 + 440, 0);
        if ( !*(_DWORD *)(v5 + 372) )
          InvalidateRect(*(HWND *)v5, 0, 1);
        break;
    }
    return 1;
  }
  if ( Msg == 4117 )
    return ListView_OnRedrawItems(v5, wParam, lParam);
  if ( Msg <= 0x201 )
  {
    if ( Msg != 513 )
    {
      if ( Msg <= 0x53 )
      {
        if ( Msg == 83 )
          return ListView_OnHelp(v5, lParam);
        if ( Msg <= 0x15 )
        {
          if ( Msg == 21 )
          {
            InitGlobalColors();
            if ( *(_DWORD *)(v5 + 8) & 0x8000000 )
            {
              if ( !(*(_DWORD *)(v5 + 44) & 0x800) )
                *(_DWORD *)(v5 + 64) = g_clrWindow;
              ListView_OnSetBkColor(v5, g_clrBtnFace);
            }
            else if ( !(*(_DWORD *)(v5 + 44) & 0x800) )
            {
              ListView_OnSetBkColor(v5, g_clrWindow);
            }
            if ( *(_BYTE *)(v5 + 48) & 4 )
              ListView_InitCheckBoxes(v5, 0);
            goto LABEL_57;
          }
          if ( Msg <= 8 )
          {
            if ( Msg == 8 )
            {
              ListView_OnKillFocus(v5, wParam);
              return 0;
            }
            if ( Msg == 1 )
              return (ListView_OnCreate(v5, lParam) != 0) - 1;
            if ( Msg == 2 )
            {
              ListView_OnDestroy((HDPA)v5);
              return 0;
            }
            if ( Msg != 5 )
            {
              if ( Msg == 7 )
              {
                ListView_OnSetFocus(v5, wParam);
                return 0;
              }
              goto LABEL_133;
            }
            if ( *(_DWORD *)(v5 + 152) )
            {
              if ( *(_DWORD *)(v5 + 48) & 0x4000 )
                ListView_InvalidateTTLastHit(v5, *(_DWORD *)(v5 + 156));
              v13 = *(HWND *)v5;
              v42 = 0;
              v40 = 44;
              v41 = v13;
              GetClientRect(v13, &Rect);
              SendMessageW(*(HWND *)(v5 + 152), 0x434u, 0, (LPARAM)&v40);
            }
            if ( !(*(_BYTE *)(v5 + 416) & 3) || !*(_DWORD *)(v5 + 428) && !*(_DWORD *)(v5 + 432) )
              return DefWindowProcW(v54, Msg, wParam, v4);
LABEL_57:
            InvalidateRect(*(HWND *)v5, 0, 1);
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg == 10 )
          {
            ListView_EnableWindow(v5, wParam);
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg == 11 )
          {
            ListView_OnSetRedraw((HDC)v5, wParam);
            return 0;
          }
          if ( Msg != 15 )
          {
            if ( Msg == 20 )
              return ListView_OnEraseBkgnd(v5, (HDC)wParam);
            goto LABEL_133;
          }
LABEL_161:
          ListView_OnPaint(v5, wParam);
          return 0;
        }
        if ( Msg <= 0x31 )
        {
          if ( Msg == 49 )
            return *(_DWORD *)(v5 + 56);
          if ( Msg == 24 )
          {
            LV_OnShowWindow((HDC)v5, wParam);
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg == 26 )
          {
            ListView_OnWinIniChange(v5, wParam, lParam);
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg != 32 )
          {
            if ( Msg == 48 )
            {
              ListView_OnSetFont(v5, (void *)wParam, lParam);
              return 0;
            }
            goto LABEL_133;
          }
          if ( !ListView_OnSetCursorMsg(lParam, v5) )
            return DefWindowProcW(v54, Msg, wParam, v4);
          return 1;
        }
        if ( Msg == 61 )
        {
          if ( lParam == -12 )
            return 65555;
          return DefWindowProcW(v54, Msg, wParam, v4);
        }
        if ( Msg != 71 )
        {
          if ( Msg == 78 )
            return ListView_OnNotify((HDC)v5, wParam, lParam);
          goto LABEL_133;
        }
LABEL_164:
        ListView_OnWindowPosChanged((HDC)v5, lParam);
        return DefWindowProcW(v54, Msg, wParam, v4);
      }
      if ( Msg > 0x102 )
      {
        if ( Msg > 0x114 )
        {
          if ( Msg == 277 )
          {
            ListView_OnVScroll(v5, lParam, (unsigned __int16)wParam, SHIWORD(wParam));
            return 0;
          }
          if ( Msg == 296 )
          {
            if ( CCOnUIState(v5, 296, wParam & 0x1FFFF, lParam) )
            {
              v16 = *(_DWORD *)(v5 + 100);
              if ( v16 >= 0 )
                ListView_InvalidateItemEx(v5, v16, 0, 5u, 0);
            }
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg == 512 )
          {
            v15 = *(HWND *)(v5 + 152);
            if ( v15 )
            {
              RelayToToolTips(v15, (int)v54, 512, wParam, lParam);
              if ( ((int (__stdcall *)(HDC, int, int, int))*(&pfnListView_ItemHitTest + (*(_DWORD *)(v5 + 8) & 3)))(
                     (HDC)v5,
                     (signed __int16)lParam,
                     SHIWORD(lParam),
                     (int)&v47) != *(_DWORD *)(v5 + 156)
                || v53 != *(_DWORD *)(v5 + 160) )
                ListView_PopBubble(v5);
            }
            ListView_OnMouseMove((HDC)v5, (signed __int16)lParam, SHIWORD(lParam), wParam);
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          goto LABEL_133;
        }
        if ( Msg == 276 )
        {
          ListView_OnHScroll(v5, lParam, (unsigned __int16)wParam, SHIWORD(wParam));
          return 0;
        }
        if ( Msg != 260 )
        {
          if ( Msg == 271 )
          {
            if ( g_fDBCSInputEnabled && ((unsigned int)GetKeyboardLayout(0) & 0xF000FFFF) == -536869870 )
            {
              if ( !ListView_OnImeComposition((LPCWSTR)v5, wParam, (HLOCAL)lParam) )
                return 0;
              v4 = lParam & 0xFFFFF7FF;
            }
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          if ( Msg == 273 )
          {
            ListView_OnCommand(v5, wParam, (HWND)lParam, wParam >> 16);
            return 0;
          }
          if ( Msg == 275 )
          {
            ListView_OnTimer((HDC)v5, wParam);
            return 0;
          }
          goto LABEL_133;
        }
        goto LABEL_94;
      }
      if ( Msg == 258 )
      {
        v14 = *(_DWORD *)(v5 + 144);
        if ( !v14 )
        {
          ListView_OnChar((LPCWSTR)v5, (void *)(unsigned __int16)wParam, (signed __int16)lParam);
          return 0;
        }
        *(_DWORD *)(v5 + 144) = v14 - 1;
        return 1;
      }
      if ( Msg <= 0x87 )
      {
        if ( Msg == 135 )
          return 129;
        if ( Msg == 85 )
          return CIHandleNotifyFormat(v5, lParam);
        if ( Msg == 124 )
        {
          ListView_OnStyleChanging(v5, wParam, lParam);
          return 0;
        }
        if ( Msg == 125 )
        {
          ListView_OnStyleChanged((HDC)v5, wParam, lParam);
          return 0;
        }
        if ( Msg == 130 )
        {
          ListView_OnNCDestroy((HLOCAL)v5);
          return 0;
        }
        goto LABEL_133;
      }
      if ( Msg != 160 )
      {
        if ( Msg != 256 )
        {
          if ( Msg == 257 )
          {
            *(_DWORD *)(v5 + 308) = 0;
            return DefWindowProcW(v54, Msg, wParam, v4);
          }
          goto LABEL_133;
        }
LABEL_94:
        ListView_OnKey((HCURSOR)v5, wParam, 1, (signed __int16)lParam, (unsigned int)lParam >> 16);
        return DefWindowProcW(v54, Msg, wParam, v4);
      }
LABEL_146:
      v19 = *(HWND *)(v5 + 152);
      if ( v19 )
        RelayToToolTips(v19, (int)v54, Msg, wParam, lParam);
      return DefWindowProcW(v54, Msg, wParam, v4);
    }
    goto LABEL_135;
  }
  if ( Msg > 0x1003 )
  {
    switch ( Msg )
    {
      case 0x1005u:
        return ListView_OnGetItemA(v5, lParam);
      case 0x1006u:
        return (INT_PTR)ListView_OnSetItemA(v5, lParam);
      case 0x1007u:
        return ListView_OnInsertItemA((HDC)v5, lParam);
      case 0x100Du:
        return ListView_OnFindItemA(v5, wParam, lParam);
      case 0x1011u:
        return (INT_PTR)ListView_OnGetStringWidthA(v5, (LPCSTR)lParam, 0);
      case 0x1004u:
        if ( *(_DWORD *)(v5 + 8) & 0x1000 )
          return *(_DWORD *)(v5 + 372);
        v21 = *(_DWORD *)(v5 + 40);
        if ( v21 )
          return *(_DWORD *)v21;
        break;
      case 0x1008u:
        return ListView_OnDeleteItem((LPVOID)v5, wParam);
      case 0x1009u:
        v22 = ListView_OnDeleteAllItems((HDPA)v5);
        MyNotifyWinEvent(32772, (int)v54, -4, 0);
        ListView_NotifyRecreate(v5);
        return v22;
      case 0x100Eu:
        return ListView_OnGetItemRect(v5, wParam, (struct tagRECT *)lParam);
      case 0x100Cu:
        return ListView_OnGetNextItem((HDC)v5, wParam, lParam);
      case 0x1010u:
        return ListView_OnGetItemPosition(v5, wParam, lParam);
      case 0x100Fu:
        return ListView_OnSetItemPosition(v5, wParam, (signed __int16)lParam, SHIWORD(lParam));
      case 0x1014u:
        v53 = wParam;
        v54 = (HWND)lParam;
        if ( !ListView_ValidateScrollParams(v5, &v53, (int *)&v54) || !ListView_OnScroll((HDC)v5, v53, (int)v54) )
          return 0;
        return 1;
      case 0x1013u:
        return ListView_OnEnsureVisible((HDC)v5, wParam, lParam);
      case 0x1012u:
        return ListView_OnHitTest((HDC)v5, lParam);
      case 0x100Bu:
        *(_DWORD *)(v5 + 116) = wParam;
        return 1;
      case 0x100Au:
        return *(_DWORD *)(v5 + 116);
      default:
        goto LABEL_133;
    }
    return 0;
  }
  if ( Msg == 4099 )
    return ListView_OnSetImageList(v5, (HIMAGELIST)lParam, wParam);
  if ( Msg <= 0x2A3 )
  {
    if ( Msg == 675 )
    {
      ListView_OnSetHotItem(v5, -1);
      *(_DWORD *)(v5 + 400) = -1;
      return DefWindowProcW(v54, Msg, wParam, v4);
    }
    if ( Msg > 0x206 )
    {
      if ( Msg == 519 )
      {
        if ( ListView_SetFocus(v54) )
        {
          v20 = *(HWND *)(v5 + 152);
          if ( v20 )
            RelayToToolTips(v20, (int)v54, 519, wParam, lParam);
        }
        return DefWindowProcW(v54, Msg, wParam, v4);
      }
      if ( Msg != 520 )
      {
        if ( Msg == 673 )
        {
          ListView_OnMouseHover((HDC)v5, (signed __int16)lParam, SHIWORD(lParam), wParam);
          return DefWindowProcW(v54, Msg, wParam, v4);
        }
        goto LABEL_133;
      }
      goto LABEL_146;
    }
    if ( Msg == 518 )
      goto LABEL_333;
    if ( Msg == 514 )
      goto LABEL_146;
    if ( Msg == 515 )
    {
LABEL_333:
      v18 = *(HWND *)(v5 + 152);
      if ( v18 )
        RelayToToolTips(v18, (int)v54, Msg, wParam, lParam);
      ListView_OnButtonDown((HWND)v5, 1, (signed __int16)lParam, SHIWORD(lParam), wParam);
      return DefWindowProcW(v54, Msg, wParam, v4);
    }
    if ( Msg != 516 )
    {
      if ( Msg != 517 )
        goto LABEL_133;
      goto LABEL_146;
    }
LABEL_135:
    v17 = *(HWND *)(v5 + 152);
    if ( v17 )
      RelayToToolTips(v17, (int)v54, Msg, wParam, lParam);
    ListView_OnButtonDown((HWND)v5, 0, (signed __int16)lParam, SHIWORD(lParam), wParam);
    return DefWindowProcW(v54, Msg, wParam, v4);
  }
  if ( Msg <= 0x401 )
  {
    if ( Msg == 1025 )
      goto LABEL_164;
    if ( Msg != 783 )
    {
      if ( Msg != 785 )
      {
        if ( Msg == 792 )
          goto LABEL_161;
        if ( Msg == 1024 )
        {
          if ( *(_DWORD *)(v5 + 388) )
          {
            ListView_Recompute(v5);
            ListView_UpdateScrollBars((HDC)v5);
          }
          return 0;
        }
        goto LABEL_133;
      }
      if ( (HWND)wParam == v54 )
        return DefWindowProcW(v54, Msg, wParam, v4);
    }
    ListView_Realize(v5, 0, Msg == 785, Msg == 785);
    return 1;
  }
  if ( Msg == 4096 )
  {
    if ( *(_DWORD *)(v5 + 8) & 0x8000000 )
      result = *(_DWORD *)(v5 + 64);
    else
      result = *(_DWORD *)(v5 + 60);
    return result;
  }
  if ( Msg == 4097 )
  {
    *(_DWORD *)(v5 + 44) |= 0x800u;
    if ( !(*(_DWORD *)(v5 + 8) & 0x8000000) )
      return ListView_OnSetBkColor(v5, lParam);
    *(_DWORD *)(v5 + 64) = lParam;
    return 1;
  }
  if ( Msg == 4098 )
    return ListView_OnGetImageList(v5, wParam);
LABEL_133:
  if ( CCWndProc(v5, Msg, wParam, lParam, (int)&v53) )
    return v53;
  if ( Msg != g_msgMSWheel )
    return DefWindowProcW(v54, Msg, wParam, v4);
  gcWheelDelta -= SHIWORD(wParam);
  v47 = SHIWORD(wParam);
  code = (wParam & 0xC) == 0;
  v46 = wParam & 4;
  v31 = gcWheelDelta / 120;
  v53 = gcWheelDelta / 120;
  if ( gcWheelDelta / 120 )
    gcWheelDelta %= 120;
  if ( code )
  {
    if ( (unsigned int)g_ucScrollLines > 0 )
    {
      if ( v31 )
      {
        v32 = ListView_GetWindowStyle(v5);
        if ( v32 & 0x300000 )
        {
          v33 = ((unsigned int)v32 >> 21) & 1;
          v34 = *(_DWORD *)(v5 + 8) & 3;
          code = v33;
          v35 = (HWND)pfnListView_GetScrollUnitsPerLine[v34](v5, v33);
          v11 = (*(_DWORD *)(v5 + 48) & 0x100) == 0;
          v54 = v35;
          v39 = *(HWND *)v5;
          Rect.left = 28;
          Rect.top = 6;
          v36 = v11 ? GetScrollInfo(v39, v33, (LPSCROLLINFO)&Rect) : FlatSB_GetScrollInfo(v39, v33, (LPSCROLLINFO)&Rect);
          if ( v36 )
          {
            v37 = v44 - (_DWORD)v54;
            if ( (signed int)v54 > v44 - (signed int)v54 )
              v37 = (signed int)v54;
            v38 = v37 / (signed int)v54;
            if ( (unsigned int)(v37 / (signed int)v54) >= g_ucScrollLines )
              v38 = g_ucScrollLines;
            ListView_DismissEdit(v5, 0);
            ListView_ComOnScroll((HDC)v5, 5, v45 + v53 * (_DWORD)v54 * v38, code, (int)v54, -1);
            ListView_UpdateScrollBars((HDC)v5);
            ListView_PopBubble(v5);
            RelayToToolTips(*(HWND *)(v5 + 152), *(_DWORD *)v5, 160, 1, lParam);
          }
        }
      }
    }
    return 1;
  }
  if ( !v46 )
    return DefWindowProcW(v54, Msg, wParam, v4);
  Point.x = (signed __int16)lParam;
  Point.y = SHIWORD(lParam);
  ScreenToClient(v54, &Point);
  if ( v47 <= 0 || ListView_OnSubItemHitTest((HDC)v5, (int)&Point) < 0 || !(v50 & 0xE) || !v53 )
    return DefWindowProcW(v54, Msg, wParam, v4);
  if ( GetKeyboardState(&KeyState) )
  {
    v56 &= 0x7Fu;
    SetKeyboardState(&KeyState);
  }
  v22 = 1;
  ListView_HandleMouse((HWND)v5, 0, Point.x, Point.y, 0, 1);
  ListView_HandleMouse((HWND)v5, 1, Point.x, Point.y, 0, 1);
  return v22;
}
// 6F79299C: using guessed type int (__stdcall *pfnListView_ItemHitTest)(int, POINT pt, int, int);
// 6F7CADD4: using guessed type int (__stdcall *pfnListView_GetScrollUnitsPerLine[4])(int, int);
// 6F7E6870: using guessed type int g_uDragImages;
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;
// 6F7E6930: using guessed type int g_msgMSWheel;
// 6F7E6C08: using guessed type int g_ucScrollLines;
// 6F7E8E5C: using guessed type int gcWheelDelta;

//----- (6F7CADE9) --------------------------------------------------------
int __stdcall LIncrWord(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int result; // eax@1

  v4 = a2 + *(_WORD *)a1;
  result = 0;
  if ( v4 < a4 )
    goto LABEL_10;
  do
  {
    v4 += a3 - a4;
    ++result;
  }
  while ( v4 >= a4 );
  if ( !result )
  {
LABEL_10:
    while ( v4 < a3 )
    {
      v4 += a4 - a3;
      --result;
    }
  }
  *(_WORD *)a1 = v4;
  return result;
}

//----- (6F7CAE31) --------------------------------------------------------
signed int __stdcall CmpDate(int a1, int a2)
{
  unsigned __int16 v2; // dx@3
  unsigned __int16 v3; // si@3
  signed int result; // eax@5
  unsigned __int16 v5; // ax@6
  unsigned __int16 v6; // cx@6

  if ( *(_WORD *)a1 < *(_WORD *)a2 )
    goto LABEL_11;
  if ( *(_WORD *)a1 > *(_WORD *)a2 )
    return 1;
  v2 = *(_WORD *)(a1 + 2);
  v3 = *(_WORD *)(a2 + 2);
  if ( v2 < v3 )
    goto LABEL_11;
  if ( v2 > v3 )
    return 1;
  v5 = *(_WORD *)(a1 + 6);
  v6 = *(_WORD *)(a2 + 6);
  if ( v6 <= v5 )
    result = v6 < v5;
  else
LABEL_11:
    result = -1;
  return result;
}

//----- (6F7CAE7E) --------------------------------------------------------
signed int __stdcall CmpSystemtime(int a1, int a2)
{
  unsigned __int16 v2; // dx@3
  unsigned __int16 v3; // si@3
  unsigned __int16 v4; // dx@5
  unsigned __int16 v5; // si@5
  unsigned __int16 v6; // dx@7
  unsigned __int16 v7; // si@7
  unsigned __int16 v8; // dx@9
  unsigned __int16 v9; // si@9
  unsigned __int16 v11; // ax@12
  unsigned __int16 v12; // cx@12

  if ( *(_WORD *)a1 < *(_WORD *)a2 )
    return -1;
  if ( *(_WORD *)a1 > *(_WORD *)a2 )
    return 1;
  v2 = *(_WORD *)(a1 + 2);
  v3 = *(_WORD *)(a2 + 2);
  if ( v2 < v3 )
    return -1;
  if ( v2 > v3 )
    return 1;
  v4 = *(_WORD *)(a1 + 6);
  v5 = *(_WORD *)(a2 + 6);
  if ( v4 < v5 )
    return -1;
  if ( v4 > v5 )
    return 1;
  v6 = *(_WORD *)(a1 + 8);
  v7 = *(_WORD *)(a2 + 8);
  if ( v6 < v7 )
    return -1;
  if ( v6 > v7 )
    return 1;
  v8 = *(_WORD *)(a1 + 10);
  v9 = *(_WORD *)(a2 + 10);
  if ( v8 < v9 )
    return -1;
  if ( v8 > v9 )
    return 1;
  v11 = *(_WORD *)(a1 + 12);
  v12 = *(_WORD *)(a2 + 12);
  if ( v12 > v11 )
    return -1;
  return v12 < v11;
}

//----- (6F7CAEF8) --------------------------------------------------------
int __stdcall DaysBetweenDates(int a1, int a2)
{
  unsigned __int16 v2; // di@1
  int v3; // ecx@1
  signed __int16 v4; // bx@1
  signed __int16 v5; // ax@1
  unsigned __int16 v6; // bx@16
  signed int v8; // [sp+14h] [bp+8h]@17

  v2 = *(_WORD *)(a1 + 2);
  v3 = *(_WORD *)(a2 + 6) + dword_6F7E859C[*(_WORD *)(a2 + 2)] - dword_6F7E859C[*(_WORD *)(a1 + 2)] - *(_WORD *)(a1 + 6);
  v4 = *(_WORD *)a1;
  v5 = *(_WORD *)a2;
  if ( (*(_WORD *)a1 < *(_WORD *)a2 || v2 <= 2u)
    && *(_WORD *)(a2 + 2) > 2u
    && !(v5 & 3)
    && ((unsigned __int16)v5 <= 0x6D6u || (unsigned __int16)v5 % 100 || !((unsigned __int16)v5 % 400)) )
    ++v3;
  if ( (unsigned __int16)v4 < (unsigned __int16)v5 )
  {
    if ( v2 <= 2u
      && !(v4 & 3)
      && ((unsigned __int16)v4 <= 0x6D6u || (unsigned __int16)v4 % 100 || !((unsigned __int16)v4 % 400)) )
      ++v3;
    v3 += 365;
    v6 = v4 + 1;
    if ( v6 < (unsigned __int16)v5 )
    {
      v8 = v6;
      do
      {
        v3 += 365;
        if ( !(v6 & 3) && (v6 <= 0x6D6u || v8 % 100 || !(v8 % 400)) )
          ++v3;
        ++v6;
        ++v8;
      }
      while ( v6 < (unsigned __int16)v5 );
    }
  }
  return v3;
}
// 6F7E859C: using guessed type int dword_6F7E859C[];

//----- (6F7CB009) --------------------------------------------------------
int __stdcall GetStartDowForMonth(signed int a1, signed int a2)
{
  int v2; // esi@1
  signed int v3; // esi@6

  v2 = ((a1 - 1) >> 2) + a1 + 4;
  if ( a1 <= 1752 )
  {
    if ( a1 == 1752 && a2 > 9 )
      v2 = 2182;
  }
  else
  {
    v2 = v2 + (a1 - 1601) / 400 - (a1 - 1701) / 100 - 11;
  }
  v3 = dword_6F7E859C[a2] + v2;
  if ( a2 > 2 && !(a1 & 3) && (a1 <= 1750 || a1 % 100 || !(a1 % 400)) )
    ++v3;
  return v3 % 7;
}
// 6F7E859C: using guessed type int dword_6F7E859C[];

//----- (6F7CB0A3) --------------------------------------------------------
int __stdcall DowFromDate(int a1)
{
  return (GetStartDowForMonth(*(_WORD *)a1, *(_WORD *)(a1 + 2)) + *(_WORD *)(a1 + 6) - 1) % 7;
}

//----- (6F7CB0D4) --------------------------------------------------------
signed int __stdcall GetDaysForMonth(signed int a1, int a2)
{
  signed int result; // eax@3
  int v3; // ecx@4

  if ( a1 != 1752 || a2 != 9 )
  {
    v3 = mpcdymoAccum[a2] - mpcdymoAccum[a2 - 1];
    if ( a2 == 2 && !(a1 & 3) && (a1 <= 1750 || a1 % 100 || !(a1 % 400)) )
      ++v3;
    result = v3;
  }
  else
  {
    result = 19;
  }
  return result;
}
// 6F7E85A0: using guessed type int mpcdymoAccum[];

//----- (6F7CB139) --------------------------------------------------------
signed int __stdcall GetWeekNumber(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // esi@1
  unsigned int v6; // ebx@3
  signed int result; // eax@12
  int v8; // esi@15
  __int16 v9; // [sp+Ch] [bp-14h]@1
  __int16 v10; // [sp+Eh] [bp-12h]@1
  __int16 v11; // [sp+12h] [bp-Eh]@1
  int v12; // [sp+1Ch] [bp-4h]@1
  int v13; // [sp+28h] [bp+8h]@1

  v3 = a1;
  v12 = *(_WORD *)a1;
  v9 = v12;
  v10 = 1;
  v11 = 1;
  v4 = GetStartDowForMonth((unsigned __int16)v12, 1) - a2;
  v5 = v4 + (v4 < 0 ? 7 : 0);
  v13 = *(_WORD *)(a1 + 2);
  if ( (_WORD)v13 != 1 || *(_WORD *)(v3 + 6) >= 8 - v5 )
  {
    if ( v5 )
      v11 = 8 - v5;
    v6 = DaysBetweenDates((int)&v9, v3) / 7u + 1;
  }
  else
  {
    v6 = 0;
  }
  if ( v5 && v5 <= 3 )
    ++v6;
  if ( v6 )
  {
    if ( (signed int)v6 >= 52 )
    {
      v8 = *(_WORD *)(v3 + 6);
      if ( v8 - (GetStartDowForMonth((unsigned __int16)v12, (unsigned __int16)v13) + v8 - a2 + 6) % 7 + 7 > 35 )
        v6 = 1;
    }
    result = v6;
  }
  else if ( v5 )
  {
    --v9;
    v10 = 12;
    v11 = 31;
    result = GetWeekNumber(&v9, a2, a3);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F7CB230) --------------------------------------------------------
int __stdcall IsValidDate(int a1)
{
  unsigned __int16 v1; // cx@2
  unsigned __int16 v2; // si@4
  int result; // eax@6

  result = 0;
  if ( a1 )
  {
    v1 = *(_WORD *)(a1 + 2);
    if ( v1 >= 1u && v1 <= 0xCu )
    {
      v2 = *(_WORD *)(a1 + 6);
      if ( v2 >= 1u && v2 <= GetDaysForMonth(*(_WORD *)a1, v1) )
        result = 1;
    }
  }
  return result;
}

//----- (6F7CB27C) --------------------------------------------------------
BOOL __stdcall IsValidTime(int a1)
{
  return *(_WORD *)(a1 + 8) <= 0x17u && *(_WORD *)(a1 + 10) <= 0x3Bu && *(_WORD *)(a1 + 12) <= 0x3Bu;
}

//----- (6F7CB2A9) --------------------------------------------------------
int __stdcall IsValidSystemtime(int a1)
{
  unsigned __int16 v1; // ax@2
  unsigned __int16 v2; // di@4
  int result; // eax@10

  result = 0;
  if ( a1 )
  {
    v1 = *(_WORD *)(a1 + 2);
    if ( v1 >= 1u && v1 <= 0xCu )
    {
      v2 = *(_WORD *)(a1 + 6);
      if ( v2 >= 1u
        && v2 <= GetDaysForMonth(*(_WORD *)a1, v1)
        && *(_WORD *)(a1 + 8) <= 0x17u
        && *(_WORD *)(a1 + 10) <= 0x3Bu
        && *(_WORD *)(a1 + 12) <= 0x3Bu
        && *(_WORD *)(a1 + 14) < 0x3E8u )
        result = 1;
    }
  }
  return result;
}

//----- (6F7CB317) --------------------------------------------------------
int __stdcall IncrSystemTime(int a1, int a2, int a3, int a4)
{
  int result; // eax@9
  int v5; // esi@12
  int v6; // eax@22

  if ( a1 != a2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)a1;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 12);
  }
  if ( a4 == 1 )
  {
    LOWORD(v6) = a3;
  }
  else
  {
    if ( a4 != 2 )
    {
      if ( a4 == 4 )
      {
        v5 = 7 * a3;
      }
      else if ( a4 == 8 )
      {
        v5 = a3;
      }
      else
      {
        if ( a4 != 16 )
        {
          if ( a4 != 32 )
          {
            result = a4 - 64;
            if ( a4 != 64 )
              return result;
            result = LIncrWord(a2 + 12, a3, 0, 60);
            a3 = result;
            if ( !result )
              return result;
          }
          result = LIncrWord(a2 + 10, a3, 0, 60);
          a3 = result;
          if ( !result )
            return result;
        }
        result = LIncrWord(a2 + 8, a3, 0, 24);
        v5 = result;
        if ( !result )
          return result;
      }
      if ( v5 < 0 )
      {
        while ( 1 )
        {
          result = *(_WORD *)(a2 + 6);
          if ( result > -v5 )
            break;
          v5 += *(_WORD *)(a2 + 6);
          IncrSystemTime(a2, a2, -1, 2);
          *(_WORD *)(a2 + 6) = GetDaysForMonth(*(_WORD *)a2, *(_WORD *)(a2 + 2));
        }
      }
      else
      {
        while ( 1 )
        {
          result = GetDaysForMonth(*(_WORD *)a2, *(_WORD *)(a2 + 2));
          if ( v5 + *(_WORD *)(a2 + 6) <= result )
            break;
          v5 = *(_WORD *)(a2 + 6) - result + v5 - 1;
          *(_WORD *)(a2 + 6) = 1;
          IncrSystemTime(a2, a2, 1, 2);
        }
      }
      *(_WORD *)(a2 + 6) += v5;
      return result;
    }
    v6 = LIncrWord(a2 + 2, a3, 1, 13);
    if ( !v6 )
    {
      result = GetDaysForMonth(*(_WORD *)a2, *(_WORD *)(a2 + 2));
      goto LABEL_26;
    }
  }
  *(_WORD *)a2 += v6;
  result = GetDaysForMonth(*(_WORD *)a2, *(_WORD *)(a2 + 2));
LABEL_26:
  if ( *(_WORD *)(a2 + 6) > result )
    *(_WORD *)(a2 + 6) = result;
  return result;
}

//----- (6F7CB474) --------------------------------------------------------
int __stdcall ListView_RefoldLabelRect(int a1, int a2, int a3)
{
  int result; // eax@1

  result = *(_WORD *)(a3 + 20);
  if ( result >= *(_WORD *)(a3 + 18) )
    result = *(_WORD *)(a3 + 18);
  if ( result >= g_cyEdge + 2 * *(_DWORD *)(a1 + 84) )
    result = g_cyEdge + 2 * *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a2 + 12) = result + *(_DWORD *)(a2 + 4);
  return result;
}

//----- (6F7CB4B3) --------------------------------------------------------
int __stdcall ListView_GetSlotCountEx(int a1, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@3
  signed int v5; // edi@3
  signed int v6; // ebx@3
  int v7; // eax@10
  int v8; // ecx@10
  signed int v9; // edx@11
  signed int v10; // ecx@14
  int v11; // eax@20
  int result; // eax@24
  int v13; // edx@27
  int v14; // [sp+Ch] [bp-4h]@1
  signed int v15; // [sp+18h] [bp+8h]@13

  v3 = a1;
  v14 = 0;
  if ( a3 < 0 || *(_DWORD *)(a1 + 128) <= 0 )
  {
    v5 = *(_DWORD *)(a1 + 120);
    v6 = *(_DWORD *)(a1 + 124);
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 132) + 16 * a3;
    v5 = *(_DWORD *)(v4 + 8) - *(_DWORD *)v4;
    v6 = *(_DWORD *)(v4 + 12) - *(_DWORD *)(v4 + 4);
  }
  if ( a2 )
  {
    v14 = ListView_GetWindowStyle(a1);
    if ( v14 & 0x200000 )
      v5 += ListView_GetCxScrollbar(a1);
    if ( v14 & 0x100000 )
      v6 += ListView_GetCyScrollbar(a1);
  }
  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(_DWORD *)(a1 + 8) & 3;
  if ( v8 == 2 )
    v9 = *(_DWORD *)(a1 + 184);
  else
    v9 = *(_DWORD *)(a1 + 196);
  v15 = v9;
  if ( v8 == 2 )
    v10 = *(_DWORD *)(v3 + 188);
  else
    v10 = *(_DWORD *)(v3 + 200);
  if ( !v9 )
    v15 = 1;
  if ( !v10 )
    v10 = 1;
  v11 = v7 & 0xC00;
  if ( v11 && v11 != 1024 )
  {
    if ( v11 != 2048 && v11 != 3072 )
      return 1;
    result = v6 / v10;
    if ( v6 / v10 < 1 )
      result = 1;
    v13 = v14 & 0x100000;
  }
  else
  {
    result = v5 / v15;
    if ( v5 / v15 < 1 )
      result = 1;
    v13 = v14 & 0x200000;
  }
  if ( a2 && v13 && v15 * v10 < *(_DWORD *)(v3 + 372) )
    result = ListView_GetSlotCountEx(v3, 0, a3);
  return result;
}

//----- (6F7CB5DF) --------------------------------------------------------
int __stdcall ListView_GetSlotCount(int a1, int a2)
{
  return ListView_GetSlotCountEx(a1, a2, -1);
}

//----- (6F7CB5FA) --------------------------------------------------------
int __stdcall LV_GetItemPixelRow(int a1, int a2)
{
  int result; // eax@2

  if ( (*(_DWORD *)(a1 + 8) & 0xC00) == 2048 )
    result = *(_DWORD *)(a2 + 4);
  else
    result = *(_DWORD *)(a2 + 8);
  return result;
}

//----- (6F7CB625) --------------------------------------------------------
int __stdcall LV_GetMaxPlacedItem(int a1)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int *v5; // edi@2
  int v6; // eax@4

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 372);
  v3 = 0;
  v4 = 0;
  if ( v2 > 0 )
  {
    v5 = *(int **)(*(_DWORD *)(a1 + 40) + 4);
    do
    {
      if ( *(_DWORD *)(*v5 + 8) != 0x7FFFFFFF )
      {
        v6 = LV_GetItemPixelRow(v1, *v5);
        if ( !v4 || v6 > v3 )
          v3 = v6;
      }
      ++v4;
      ++v5;
    }
    while ( v4 < v2 );
  }
  return v3;
}

//----- (6F7CB676) --------------------------------------------------------
int __stdcall NearestSlot(int a1, int a2, signed int a3, signed int a4, int a5)
{
  int v5; // ecx@3
  int v6; // eax@3
  int v7; // ecx@6
  int v8; // eax@6
  int result; // eax@9

  if ( a5 )
  {
    *(_DWORD *)a1 -= *(_DWORD *)a5;
    *(_DWORD *)a2 -= *(_DWORD *)(a5 + 4);
  }
  v5 = *(_DWORD *)a1;
  v6 = a3 / 2;
  if ( *(_DWORD *)a1 >= 0 )
    *(_DWORD *)a1 = v5 + v6;
  else
    *(_DWORD *)a1 = v5 - v6;
  v7 = *(_DWORD *)a2;
  v8 = a4 / 2;
  if ( *(_DWORD *)a2 >= 0 )
    *(_DWORD *)a2 = v7 + v8;
  else
    *(_DWORD *)a2 = v7 - v8;
  *(_DWORD *)a1 -= *(_DWORD *)a1 % a3;
  result = *(_DWORD *)a2 / a4;
  *(_DWORD *)a2 -= *(_DWORD *)a2 % a4;
  if ( a5 )
  {
    *(_DWORD *)a1 += *(_DWORD *)a5;
    result = *(_DWORD *)(a5 + 4);
    *(_DWORD *)a2 += result;
  }
  return result;
}

//----- (6F7CB6F5) --------------------------------------------------------
int __stdcall ListView_CalcHitSlot(int a1, signed int a2, signed int a3, signed int a4)
{
  int v4; // ecx@1
  int v5; // edx@3
  signed int v6; // esi@4
  signed int v7; // edi@4
  int v8; // edx@8
  int v9; // ecx@11
  int v10; // eax@11

  v4 = 0;
  if ( a4 < 1 )
    a4 = 1;
  v5 = *(_DWORD *)(a1 + 8);
  if ( (v5 & 3) == 2 )
  {
    v6 = *(_DWORD *)(a1 + 184);
    v7 = *(_DWORD *)(a1 + 188);
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 196);
    v7 = *(_DWORD *)(a1 + 200);
  }
  if ( v6 > 0 && v7 > 0 )
  {
    v8 = v5 & 0xC00;
    if ( !v8 || v8 == 1024 )
    {
      v9 = a3 / v7;
      v10 = a2 / v6;
      return v10 + a4 * v9;
    }
    if ( v8 == 2048 )
    {
      v9 = a2 / v6;
      v10 = a3 / v7;
      return v10 + a4 * v9;
    }
  }
  return v4;
}

//----- (6F7CB786) --------------------------------------------------------
int __stdcall _GetCurrentItemSize(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( (*(_DWORD *)(a1 + 8) & 3) == 2 )
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 184);
    result = *(_DWORD *)(a1 + 188);
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(a1 + 196);
    result = *(_DWORD *)(a1 + 200);
  }
  *(_DWORD *)a3 = result;
  return result;
}

//----- (6F7CB7C8) --------------------------------------------------------
int __stdcall ListView_IApproximateViewRect(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // eax@1
  bool v8; // sf@1
  unsigned __int8 v9; // of@1
  int v10; // ebx@5
  __int16 v11; // ax@6

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 120);
  a1 = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(v4 + 120) = a3;
  *(_DWORD *)(v4 + 124) = a4;
  v6 = ListView_GetSlotCount(v4, 1);
  *(_DWORD *)(v4 + 124) = a1;
  v7 = a2;
  v9 = __OFSUB__(v6, a2);
  v8 = v6 - a2 < 0;
  *(_DWORD *)(v4 + 120) = v5;
  if ( !(v8 ^ v9) )
    v6 = v7;
  if ( !v6 )
    v6 = 1;
  v10 = (v6 + v7 - 1) / v6;
  if ( *(_DWORD *)(v4 + 8) & 0xC00 )
  {
    v11 = v6;
    LOWORD(v6) = v10;
    LOWORD(v10) = v11;
  }
  _GetCurrentItemSize(v4, (int)&a3, (int)&a1);
  return (unsigned __int16)(g_cxEdge + a3 * v6) | ((unsigned __int16)(g_cyEdge + a1 * v10) << 16);
}

//----- (6F7CB85A) --------------------------------------------------------
LONG __stdcall _CalcSlotRect(int a1, int a2, int a3, int a4, int a5, LPRECT lprc)
{
  int v6; // edi@1
  int v7; // esi@3
  LPRECT v8; // ecx@3
  int v9; // eax@3
  int v10; // eax@7
  int v11; // eax@8
  LONG result; // eax@11
  int v13; // eax@12

  v6 = a4;
  if ( a4 < 1 )
    v6 = 1;
  v7 = a1;
  _GetCurrentItemSize(a1, (int)&a1, (int)&a4);
  v8 = lprc;
  v9 = *(_DWORD *)(v7 + 8) & 0xC00;
  if ( v9 && v9 != 1024 )
  {
    if ( v9 == 2048 || v9 == 3072 )
    {
      v10 = a1 * (a3 / v6);
      lprc->top = a4 * (a3 % v6);
      v8->left = v10;
    }
  }
  else
  {
    v11 = a4 * (a3 / v6);
    lprc->left = a1 * (a3 % v6);
    v8->top = v11;
  }
  if ( a5 )
  {
    v8->left -= *(_DWORD *)(v7 + 220);
    v8->top -= *(_DWORD *)(v7 + 224);
  }
  v8->bottom = a4 + v8->top;
  result = a1 + v8->left;
  v8->right = result;
  if ( *(_DWORD *)(v7 + 128) > 0 )
  {
    v13 = *(_DWORD *)(v7 + 132) + 16 * *(_WORD *)(a2 + 22);
    result = OffsetRect(v8, *(_DWORD *)v13, *(_DWORD *)(v13 + 4));
  }
  return result;
}

//----- (6F7CB920) --------------------------------------------------------
signed int __stdcall ListView_SetIconPos(int a1, int a2, int a3, int a4)
{
  __int64 v4; // rax@2
  int v5; // eax@2
  signed int result; // eax@6
  struct tagRECT rc; // [sp+8h] [bp-10h]@1

  _CalcSlotRect(a1, a2, a3, a4, 0, &rc);
  if ( *(_BYTE *)(a1 + 8) & 3 )
  {
    v5 = rc.top;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 196) - *(_DWORD *)(a1 + 208);
    rc.left += ((signed int)v4 - HIDWORD(v4)) >> 1;
    v5 = rc.top + 2 * g_cyBorder;
    rc.top += 2 * g_cyBorder;
  }
  if ( rc.left != *(_DWORD *)(a2 + 4) || v5 != *(_DWORD *)(a2 + 8) )
  {
    LV_AdjustViewRectOnMove(a1, a2, rc.left, v5);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7CB999) --------------------------------------------------------
int __stdcall ArrangeIconCompare(void *p1, void *p2, LPARAM lParam)
{
  int v3; // ebx@2
  int v4; // eax@2
  int v6; // esi@6
  int v7; // edi@6
  bool v8; // sf@6
  unsigned __int8 v9; // of@6
  int v10; // ebx@10
  int v11; // eax@10
  int v12; // ecx@12
  int v13; // esi@12

  if ( HIWORD(lParam) )
  {
    v3 = *((_DWORD *)p1 + 1) / (signed int)(signed __int16)lParam;
    v4 = *((_DWORD *)p2 + 1) / (signed int)(signed __int16)lParam;
    if ( v3 > v4 )
      return 1;
    if ( v3 < v4 )
      return -1;
    v6 = *((_DWORD *)p1 + 2);
    v7 = *((_DWORD *)p2 + 2);
    v9 = __OFSUB__(v6, v7);
    v8 = v6 - v7 < 0;
    if ( v6 > v7 )
      return 1;
  }
  else
  {
    v10 = *((_DWORD *)p1 + 2) / (signed int)(unsigned __int16)lParam;
    v11 = *((_DWORD *)p2 + 2) / (signed int)(unsigned __int16)lParam;
    if ( v10 > v11 )
      return 1;
    if ( v10 < v11 )
      return -1;
    v12 = *((_DWORD *)p1 + 1);
    v13 = *((_DWORD *)p2 + 1);
    v9 = __OFSUB__(v12, v13);
    v8 = v12 - v13 < 0;
    if ( v12 > v13 )
      return 1;
  }
  if ( v8 ^ v9 )
    return -1;
  return 0;
}

//----- (6F7CBA15) --------------------------------------------------------
int __stdcall ListView_ComOnScroll(HDC hdc, int a2, int a3, int code, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // eax@1
  bool v8; // zf@1
  int result; // eax@2
  int v10; // edi@9
  int v11; // eax@11
  UINT v12; // eax@12
  UINT v13; // eax@15
  int v14; // edx@23
  int v15; // eax@23
  int v16; // ecx@23
  HWND v17; // [sp-Ch] [bp-34h]@1
  struct tagSCROLLINFO psi; // [sp+8h] [bp-20h]@1
  int v19; // [sp+24h] [bp-4h]@1
  signed int codea; // [sp+3Ch] [bp+14h]@1

  v6 = code;
  v7 = code == 1;
  codea = 0;
  v8 = (*((_DWORD *)hdc + 12) & 0x100) == 0;
  psi.cbSize = 28;
  psi.fMask = 7;
  v19 = v7;
  v17 = *(HWND *)hdc;
  if ( v8 )
    result = GetScrollInfo(v17, v6, &psi);
  else
    result = FlatSB_GetScrollInfo(v17, v6, &psi);
  if ( result )
  {
    if ( a6 != -1 )
      psi.nPage = a6;
    psi.nMax += 1 - psi.nPage;
    if ( psi.nMax < psi.nMin )
      psi.nMax = psi.nMin;
    result = a2;
    v10 = psi.nPos;
    switch ( a2 )
    {
      case 6:
        psi.nPos = psi.nMin;
        goto LABEL_20;
      case 7:
        v11 = psi.nMax;
        goto LABEL_19;
      case 2:
        v12 = psi.nPage;
        goto LABEL_13;
      case 0:
        v12 = a5;
LABEL_13:
        psi.nPos -= v12;
        goto LABEL_20;
      case 3:
        v13 = psi.nPage;
        goto LABEL_16;
      case 1:
        v13 = a5;
LABEL_16:
        psi.nPos += v13;
        goto LABEL_20;
      case 5:
        v11 = a3;
        codea = 0x20000;
LABEL_19:
        psi.nPos = v11;
LABEL_20:
        if ( *((_DWORD *)hdc + 77) >= 10 )
          codea = 0x20000;
        psi.fMask = 4;
        result = ListView_SetScrollInfo((int)hdc, v6, &psi, 1);
        psi.nPos = result;
        if ( v10 != result )
        {
          v14 = 0;
          v15 = result - v10;
          v16 = 0;
          if ( v19 )
            v14 = v15;
          else
            v16 = v15;
          (*(&pfnListView_Scroll2 + (*((_DWORD *)hdc + 2) & 3)))(hdc, v16, v14, codea);
          result = UpdateWindow(*(HWND *)hdc);
        }
        break;
      case 8:
        result = ListView_UpdateScrollBars(hdc);
        break;
      default:
        return result;
    }
  }
  return result;
}
// 6F7929AC: using guessed type int (__stdcall *pfnListView_Scroll2)(HDC hdc, int, int, int);

//----- (6F7CBB5A) --------------------------------------------------------
int __stdcall ListView_IScroll2_SmoothScroll(HWND hWnd, int a2, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
{
  LONG v8; // eax@1

  v8 = GetWindowLongW(hWnd, 0);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 220) -= a2;
    *(_DWORD *)(v8 + 224) -= dy;
  }
  return ScrollWindowEx(hWnd, a2, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}

//----- (6F7CBBA3) --------------------------------------------------------
int __stdcall ListView_IScroll2(HDC hdc, int a2, int a3, int a4)
{
  int result; // eax@1
  int dy; // [sp+0h] [bp-38h]@5
  int v6; // [sp+4h] [bp-34h]@5
  int v7; // [sp+8h] [bp-30h]@5
  int v8; // [sp+Ch] [bp-2Ch]@5
  int v9; // [sp+10h] [bp-28h]@5
  int v10; // [sp+14h] [bp-24h]@5
  int v11; // [sp+18h] [bp-20h]@5
  int v12; // [sp+1Ch] [bp-1Ch]@5
  int v13; // [sp+20h] [bp-18h]@5
  int v14; // [sp+24h] [bp-14h]@5
  int (__stdcall *v15)(HWND, int, int, RECT *, RECT *, HRGN, LPRECT, UINT); // [sp+34h] [bp-4h]@5

  result = a3 | a2;
  if ( __PAIR__(a3, a2) )
  {
    if ( *((_DWORD *)hdc + 15) != -1 || *((_DWORD *)hdc + 103) )
    {
      v7 = *(_DWORD *)hdc;
      v14 = a4 | 6;
      dy = 56;
      v6 = 1;
      v8 = -a2;
      v9 = -a3;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v15 = ListView_IScroll2_SmoothScroll;
      result = SmoothScrollWindow((int)&dy);
    }
    else
    {
      *((_DWORD *)hdc + 55) += a2;
      *((_DWORD *)hdc + 56) += a3;
      result = LVSeeThruScroll(hdc, 0);
    }
  }
  return result;
}

//----- (6F7CBC2C) --------------------------------------------------------
int __stdcall ListView_IOnScroll(HDC hdc, int a2, int a3, int code)
{
  signed int v4; // eax@2

  if ( code == 1 )
    v4 = *((_DWORD *)hdc + 50);
  else
    v4 = *((_DWORD *)hdc + 49);
  return ListView_ComOnScroll(hdc, a2, a3, code, v4 / 2, -1);
}

//----- (6F7CBC68) --------------------------------------------------------
int __stdcall ListView_IGetScrollUnitsPerLine(int a1, int a2)
{
  signed int v2; // eax@2

  if ( a2 == 1 )
    v2 = *(_DWORD *)(a1 + 200);
  else
    v2 = *(_DWORD *)(a1 + 196);
  return v2 / 2;
}

//----- (6F7CBC92) --------------------------------------------------------
int __stdcall ListView_ChangeEditRectForRegion(int a1, RECT *lprc2)
{
  PVOID v2; // eax@1
  struct tagRECT *v3; // edi@1
  int result; // eax@1

  v2 = DPA_GetPtr(*(HDPA *)(a1 + 40), *(_DWORD *)(a1 + 252));
  v3 = (struct tagRECT *)((char *)v2 + 44);
  result = EqualRect((const RECT *)((char *)v2 + 44), lprc2);
  if ( !result )
  {
    CopyRect(v3, lprc2);
    ListView_RecalcRegion(a1, 1, 1);
    InvalidateRect(*(HWND *)(a1 + 248), 0, 1);
    result = UpdateWindow(*(HWND *)a1);
  }
  return result;
}

//----- (6F7CBCF2) --------------------------------------------------------
LRESULT __stdcall RescrollEditWindow(HWND hWnd)
{
  SendMessageW(hWnd, 0xB1u, 0xFFFFFFFF, -1);
  return SendMessageW(hWnd, 0xB1u, 0, -1);
}

//----- (6F7CBD23) --------------------------------------------------------
signed int __stdcall ListView_DismissEdit(int a1, signed int a2)
{
  HWND v2; // ebx@1
  HWND v3; // eax@1
  bool v4; // zf@1
  int v6; // eax@8
  int v7; // eax@9
  int v8; // eax@14
  PVOID v9; // eax@18
  HIMC v10; // eax@33
  HIMC v11; // edi@33
  HWND v12; // eax@36
  LPARAM lParam; // [sp+Ch] [bp-254h]@23
  int v14; // [sp+18h] [bp-248h]@20
  int v15; // [sp+1Ch] [bp-244h]@20
  int v16; // [sp+20h] [bp-240h]@20
  WCHAR *v17; // [sp+2Ch] [bp-234h]@21
  int v18; // [sp+30h] [bp-230h]@20
  int v19; // [sp+38h] [bp-228h]@17
  HWND v20; // [sp+40h] [bp-220h]@1
  int v21; // [sp+44h] [bp-21Ch]@14
  HWND v22; // [sp+48h] [bp-218h]@1
  int v23; // [sp+4Ch] [bp-214h]@1
  HWND hWnd; // [sp+50h] [bp-210h]@1
  WCHAR String; // [sp+54h] [bp-20Ch]@22

  v2 = *(HWND *)(a1 + 248);
  v3 = *(HWND *)a1;
  v4 = (*(_BYTE *)(a1 + 36) & 1) == 0;
  v23 = 0;
  v22 = (HWND)1;
  hWnd = v2;
  v20 = v3;
  if ( !v4 )
    return 0;
  if ( !v2 )
  {
    ListView_CancelPendingTimer(a1, 8, 0x2Au);
    return 1;
  }
  if ( !IsWindowVisible(v3) )
    a2 = 1;
  v6 = GetDlgCtrlID(v2);
  if ( !v6 )
  {
    a2 = 1;
    goto LABEL_13;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_13:
    SetWindowLongW(v2, -12, 2);
    goto LABEL_14;
  }
  if ( v7 == 1 )
    return 1;
LABEL_14:
  v8 = *(_DWORD *)(a1 + 252);
  v21 = *(_DWORD *)(a1 + 252);
  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    if ( v8 >= 0 && v8 < *(_DWORD *)(a1 + 372) )
    {
      v19 = 0;
LABEL_20:
      v15 = v8;
      v16 = 0;
      v18 = 0;
      v14 = 0;
      if ( a2 )
      {
        v17 = 0;
      }
      else
      {
        GetWindowTextW(hWnd, &String, 260);
        v14 |= 1u;
        v18 = 260;
        v17 = &String;
      }
      v22 = CCSendNotify(a1, -176, (LPARAM)&lParam);
      if ( !IsWindow(v20) )
        return 0;
      if ( v22 && !a2 )
      {
        if ( *(_DWORD *)(a1 + 8) & 0x1000 || *(_DWORD *)v23 == -1 )
        {
          CCSendNotify(a1, -178, (LPARAM)&lParam);
          *(_DWORD *)(a1 + 228) = 0x7FFFFFFF;
          if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
            ListView_SetSRecompute(v23);
        }
        else
        {
          v14 = 1;
          ListView_OnSetItem(a1, (INT_PTR)&v14);
        }
      }
      if ( g_fDBCSInputEnabled )
      {
        if ( (unsigned __int16)GetKeyboardLayout(0) == 1041 )
        {
          v10 = ImmGetContext(hWnd);
          v11 = v10;
          if ( v10 )
          {
            ImmNotifyIME(v10, 0x15u, 1u, 0);
            ImmReleaseContext(hWnd, v11);
          }
        }
      }
      ListView_InvalidateItemEx(a1, v21, 0, 5u, 0);
      goto LABEL_36;
    }
  }
  else
  {
    v9 = DPA_GetPtr(*(HDPA *)(a1 + 40), v8);
    v23 = (int)v9;
    if ( v9 )
    {
      v19 = *((_DWORD *)v9 + 7);
      v8 = v21;
      goto LABEL_20;
    }
  }
LABEL_36:
  v12 = hWnd;
  if ( hWnd == *(HWND *)(a1 + 248) )
  {
    *(_DWORD *)(a1 + 252) = -1;
    *(_DWORD *)(a1 + 248) = 0;
  }
  DestroyWindow(v12);
  ListView_RecalcRegion(a1, 1, 1);
  return (signed int)v22;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7CBF99) --------------------------------------------------------
HWND __stdcall CreateEditInPlaceWindow(HWND hWnd, LPCWSTR lpWindowName, WPARAM wParam, DWORD dwStyle, WPARAM a5)
{
  HINSTANCE v5; // ST2C_4@1
  __int16 v6; // ax@1
  HWND v7; // eax@1
  HWND v8; // ebx@1

  v5 = g_hinst;
  v6 = GetWindowLongW(hWnd, -20);
  v7 = CreateWindowExW(v6 & 0x2000, L"EDIT", lpWindowName, dwStyle, 0, 0, 0x4000, 20, hWnd, 0, v5, 0);
  v8 = v7;
  if ( v7 )
  {
    SendMessageW(v7, 0xC5u, wParam, 0);
    SendMessageW(v8, 0xB1u, 0, 0);
    SendMessageW(v8, 0x30u, a5, 0);
  }
  return v8;
}

//----- (6F7CC012) --------------------------------------------------------
COLORREF __stdcall ListView_DrawBorderSel(HIMAGELIST himl, int a2, HDC hdc, int a4, int a5, COLORREF color)
{
  LONG v6; // eax@1
  RECT rect; // [sp+Ch] [bp-18h]@1
  COLORREF v9; // [sp+1Ch] [bp-8h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v9 = SetBkColor(hdc, color);
  ImageList_GetIconSize(himl, &v10, (int *)&color);
  rect.right = a4 - 1;
  rect.left = a4 - 4;
  rect.bottom = color + a5 + 4;
  rect.top = a5 - 4;
  ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  rect.left = rect.right;
  rect.right += v10 + 2;
  rect.bottom = rect.top + 3;
  ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  v6 = rect.right;
  rect.right += 3;
  rect.left = v6;
  rect.bottom = rect.top + color + 8;
  ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  rect.top = rect.bottom - 3;
  rect.right = rect.left;
  rect.left += -2 - v10;
  ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
  return SetBkColor(hdc, v9);
}

//----- (6F7CC102) --------------------------------------------------------
int __stdcall ListView_DrawImageEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, char a6, int a7)
{
  HIMAGELIST v7; // esi@1
  int v8; // edx@1
  int v9; // edi@1
  int v10; // ecx@1
  int v11; // eax@1
  int v12; // ebx@2
  COLORREF v13; // edx@19
  int v14; // eax@32
  int v15; // edx@34
  int v16; // ecx@36
  int v17; // eax@36
  COLORREF v18; // eax@44
  int v20; // [sp+Ch] [bp-Ch]@1
  signed int rgbFg; // [sp+10h] [bp-8h]@1
  signed int v22; // [sp+14h] [bp-4h]@1
  struct _IMAGELIST *himla; // [sp+20h] [bp+8h]@2
  int ia; // [sp+24h] [bp+Ch]@4

  rgbFg = 0;
  v7 = himl;
  v8 = *((_DWORD *)himl + 12);
  v9 = i;
  v10 = *(_DWORD *)(i + 12);
  v20 = *((_DWORD *)himl + 12) & 0x8000;
  v11 = *(_DWORD *)(i + 12) & 0xF00;
  v22 = 16;
  if ( *((_BYTE *)himl + 8) & 3 )
  {
    himla = (struct _IMAGELIST *)*((_DWORD *)himl + 42);
    v12 = *((_DWORD *)v7 + 43);
  }
  else
  {
    himla = (struct _IMAGELIST *)*((_DWORD *)himl + 51);
    v12 = *((_DWORD *)v7 + 52);
  }
  ia = v12;
  if ( v10 & 8 || a6 & 0x10 && v10 & 2 )
  {
    v22 = 8;
    if ( !v20 )
    {
      v11 |= 4u;
      rgbFg = -16777216;
    }
  }
  if ( a6 & 0x20 && v10 & 2 )
    v22 = 256;
  if ( v10 & 4 )
  {
    v11 |= 4u;
    rgbFg = *((_DWORD *)v7 + 15);
  }
  if ( !(a6 & 1) )
  {
    if ( himla )
    {
      if ( *((_DWORD *)v7 + 103) || v8 & 0x200 && !g_fSlowMachine )
        v13 = -1;
      else
        v13 = *((_DWORD *)v7 + 15);
      if ( a7 >= 0 && v12 >= a7 - x )
        ia = a7 - x;
      if ( ia > 0 )
        ImageList_DrawEx(himla, *(_DWORD *)(v9 + 28), hdcDst, x, y, ia, 0, v13, rgbFg, v11);
    }
    if ( *((_DWORD *)v7 + 88)
      && (unsigned __int8)(*(_WORD *)(v9 + 12) >> 8) >> 4
      && (!*(_DWORD *)(v9 + 8) || *((_BYTE *)v7 + 48) & 2) )
    {
      if ( himla )
      {
        if ( *((_BYTE *)v7 + 8) & 3 )
          v14 = *((_DWORD *)v7 + 44);
        else
          v14 = *((_DWORD *)v7 + 53);
        v15 = v14 - *((_DWORD *)v7 + 90);
      }
      else
      {
        v15 = 0;
      }
      v16 = *((_DWORD *)v7 + 89);
      v17 = x - v16;
      if ( a7 >= 0 && v16 >= a7 - v17 )
        v16 = a7 - v17;
      if ( v16 > 0 )
        ImageList_DrawEx(
          *((HIMAGELIST *)v7 + 88),
          ((unsigned __int8)(*(_WORD *)(v9 + 12) >> 8) >> 4) - 1,
          hdcDst,
          v17,
          y + v15,
          v16,
          0,
          0xFF000000,
          0xFF000000,
          0);
    }
    if ( v20 )
    {
      if ( v22 & 0x10 )
      {
        ListView_DrawBorderSel(himla, *(_DWORD *)v7, hdcDst, x, y, *((_DWORD *)v7 + 15));
      }
      else
      {
        if ( a6 & 0x40 )
          v18 = GetSysColor(26);
        else
          v18 = g_clrHighlight;
        ListView_DrawBorderSel(himla, *(_DWORD *)v7, hdcDst, x, y, v18);
      }
    }
  }
  return v22;
}
// 6F7E8598: using guessed type int g_fSlowMachine;

//----- (6F7CC2E0) --------------------------------------------------------
HIMC __stdcall ListView_SizeIME(HWND hWnd)
{
  HIMC result; // eax@1
  HIMC v2; // esi@1
  struct tagCANDIDATEFORM Candidate; // [sp+8h] [bp-30h]@1
  struct tagRECT Rect; // [sp+28h] [bp-10h]@1

  GetClientRect(hWnd, &Rect);
  Candidate.dwIndex = 0;
  Candidate.ptCurrentPos.x = Rect.left;
  Candidate.dwStyle = 128;
  Candidate.ptCurrentPos.y = Rect.bottom;
  Candidate.rcArea = Rect;
  result = ImmGetContext(hWnd);
  v2 = result;
  if ( result )
  {
    ImmSetCandidateWindow(result, &Candidate);
    result = (HIMC)ImmReleaseContext(hWnd, v2);
  }
  return result;
}

//----- (6F7CC344) --------------------------------------------------------
unsigned int __stdcall sub_6F7CC344(HIMC a1, DWORD a2, int a3)
{
  LONG v3; // eax@1
  DWORD v4; // edi@2
  HLOCAL v5; // eax@2
  void *v6; // esi@2
  unsigned int v7; // eax@3

  *(_DWORD *)a3 = 0;
  v3 = ImmGetCompositionStringW(a1, a2, 0, 0);
  if ( v3 <= 0 )
    goto LABEL_6;
  v4 = v3 + 2;
  v5 = LocalAlloc(0x40u, v3 + 2);
  v6 = v5;
  if ( !v5 )
    goto LABEL_6;
  v7 = ImmGetCompositionStringW(a1, a2, v5, v4);
  if ( (signed int)v7 <= 0 )
  {
    LocalFree(v6);
LABEL_6:
    v7 = 0;
    return v7 >> 1;
  }
  *((_WORD *)v6 + (v7 >> 1)) = 0;
  *(_DWORD *)a3 = v6;
  return v7 >> 1;
}

//----- (6F7CC3AE) --------------------------------------------------------
signed int __stdcall ListView_IDrawItem(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  PVOID v3; // eax@10
  int v5; // eax@15
  LONG v6; // ecx@15
  int v7; // eax@16
  int v8; // edx@23
  int v9; // ecx@26
  int v10; // ecx@29
  int v11; // [sp-8h] [bp-2D0h]@14
  int v12; // [sp+Ch] [bp-2BCh]@2
  struct tagRECT rcDst; // [sp+48h] [bp-280h]@8
  int i; // [sp+58h] [bp-270h]@2
  int v15; // [sp+5Ch] [bp-26Ch]@2
  int v16; // [sp+60h] [bp-268h]@2
  char v17; // [sp+64h] [bp-264h]@39
  int v18; // [sp+68h] [bp-260h]@2
  int v19; // [sp+6Ch] [bp-25Ch]@2
  int v20; // [sp+70h] [bp-258h]@2
  RECT rcSrc1; // [sp+80h] [bp-248h]@2
  struct tagRECT rc; // [sp+90h] [bp-238h]@2
  RECT v23; // [sp+A0h] [bp-228h]@2
  PVOID v24; // [sp+B0h] [bp-218h]@2
  int v25; // [sp+B4h] [bp-214h]@4
  char v26; // [sp+B8h] [bp-210h]@2

  v1 = *(_DWORD *)(a1 + 60);
  v2 = *(_DWORD *)a1;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 8) & 0x1000 )
  {
    v16 = 0;
    v19 = (int)&v26;
    v15 = v1;
    i = 11;
    v18 = 0xFFFF;
    v20 = 260;
    ListView_OnGetItem(v2, (HDPA)v2, (int)&i);
    v12 = v19;
    ListView_GetRectsOwnerData(v2, v1, (int)&rc, (int)&v23, &rcSrc1, 0, (int)&v12);
    v24 = 0;
  }
  else
  {
    v24 = DPA_GetPtr(*(HDPA *)(v2 + 40), *(_DWORD *)(a1 + 60));
    ListView_GetRects(v2, v1, (int)&rc, (int)&v23, &rcSrc1, 0);
  }
  v25 = 0;
  if ( *(_BYTE *)(a1 + 12) & 0x80 || ListView_IsItemUnfolded(v2, v1) )
  {
    ListView_UnfoldRects(v2, v1, &rc, &v23, &rcSrc1, 0);
    v25 = 1;
  }
  if ( !*(_DWORD *)(a1 + 8) || IntersectRect(&rcDst, &rcSrc1, *(const RECT **)(a1 + 8)) )
  {
    if ( !(*(_DWORD *)(v2 + 8) & 0x1000) )
    {
      v16 = 0;
      v19 = (int)&v26;
      v15 = v1;
      i = 11;
      v18 = 0xFFFF;
      v20 = 260;
      ListView_OnGetItem(v2, (HDPA)v2, (int)&i);
      v3 = DPA_GetPtr(*(HDPA *)(v2 + 40), v1);
      if ( v24 != v3 )
        return 0;
    }
    if ( *(_DWORD *)(a1 + 4) )
    {
      OffsetRect(&rc, **(_DWORD **)(a1 + 4) - rcSrc1.left, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) - rcSrc1.top);
      OffsetRect(&v23, **(_DWORD **)(a1 + 4) - rcSrc1.left, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) - rcSrc1.top);
    }
    v11 = *(_DWORD *)(a1 + 12);
    if ( *(_BYTE *)(v2 + 8) & 3 )
    {
      v7 = ListView_DrawImageEx((HIMAGELIST)v2, (int)&i, *(HDC *)(a1 + 40), rc.left, rc.top, v11, -1);
      v6 = v23.bottom;
    }
    else
    {
      v5 = ListView_DrawImageEx(
             (HIMAGELIST)v2,
             (int)&i,
             *(HDC *)(a1 + 40),
             g_cxIconMargin + rc.left,
             rc.top + g_cyIconMargin,
             v11,
             -1);
      v6 = v23.bottom;
      if ( v23.bottom - v23.top <= *(_DWORD *)(v2 + 84) )
        v7 = v5 | 2;
      else
        v7 = v5 | 1;
      if ( g_uiACP == 949 && g_bRunOnNT5 )
        v7 |= 0x1000u;
    }
    if ( *(_DWORD *)(v2 + 252) != v1 )
    {
      v8 = *(_DWORD *)(v2 + 84);
      if ( v6 - v23.top <= v8 )
        goto LABEL_45;
      v7 |= 1u;
      if ( !v25 )
        v7 |= 0x404u;
      v9 = *(_DWORD *)(v2 + 8);
      if ( v9 & 0x1000 )
      {
        if ( (v9 & 3) == 2 )
LABEL_45:
          v7 |= 2u;
      }
      v10 = *(_DWORD *)(a1 + 12);
      if ( v10 & 2 )
        v7 |= 0x80u;
      if ( v7 & 8 && v10 & 0x40 )
        v7 |= 0x200u;
      if ( v19 && *(_WORD *)v19 )
      {
        if ( *(_DWORD *)(v2 + 52) & 0x2000 )
          v7 |= 0x800u;
        SHDrawText(
          *(HDC *)(a1 + 40),
          v19,
          &v23,
          0,
          v7,
          v8,
          *(_DWORD *)(v2 + 92),
          *(_DWORD *)(a1 + 72),
          *(_DWORD *)(a1 + 76));
        if ( *(_BYTE *)(a1 + 12) & 8 && v17 & 1 && !(CCGetUIState(*(_DWORD *)a1) & 1) )
          DrawFocusRect(*(HDC *)(a1 + 40), &v23);
      }
    }
  }
  return 1;
}
// 6F7E68C8: using guessed type int g_uiACP;
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7CC701) --------------------------------------------------------
int __stdcall ListView_CalcMinMaxIndex(int a1, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int result; // eax@1

  v4 = a1;
  v5 = ListView_GetSlotCount(a1, 1);
  *(_DWORD *)a3 = ListView_CalcHitSlot(
                    v4,
                    *(_DWORD *)(v4 + 220) + *(_DWORD *)a2,
                    *(_DWORD *)(v4 + 224) + *(_DWORD *)(a2 + 4),
                    v5);
  result = ListView_CalcHitSlot(
             v4,
             *(_DWORD *)(v4 + 220) + *(_DWORD *)(a2 + 8),
             *(_DWORD *)(v4 + 224) + *(_DWORD *)(a2 + 12),
             v5)
         + 1;
  *(_DWORD *)a4 = result;
  return result;
}

//----- (6F7CC765) --------------------------------------------------------
HWND __stdcall ListView_DoOnEditLabel(HDC hdc, INT_PTR i, int a3)
{
  HWND result; // eax@1
  const WCHAR *v4; // eax@4
  bool v5; // zf@9
  PVOID v6; // eax@10
  HWND v7; // ST10_4@15
  LPARAM lParam; // [sp+Ch] [bp-26Ch]@14
  int v9; // [sp+18h] [bp-260h]@9
  INT_PTR v10; // [sp+1Ch] [bp-25Ch]@9
  int v11; // [sp+20h] [bp-258h]@9
  int v12; // [sp+38h] [bp-240h]@12
  int v13; // [sp+40h] [bp-238h]@1
  INT_PTR v14; // [sp+44h] [bp-234h]@1
  int v15; // [sp+48h] [bp-230h]@1
  char *v16; // [sp+54h] [bp-224h]@1
  int v17; // [sp+58h] [bp-220h]@1
  LPCWSTR lpWindowName; // [sp+68h] [bp-210h]@1
  char v19; // [sp+6Ch] [bp-20Ch]@1

  lpWindowName = (LPCWSTR)a3;
  v16 = &v19;
  v13 = 1;
  v14 = i;
  v15 = 0;
  v17 = 260;
  result = (HWND)ListView_OnGetItem(i, (HDPA)hdc, (int)&v13);
  if ( v16 )
  {
    if ( *((_DWORD *)hdc + 25) != i )
      ListView_SetFocusSel((INT_PTR)hdc, (void *)i, 1, 1, 0);
    ListView_OnEnsureVisible(hdc, i, 0);
    v4 = lpWindowName;
    if ( !lpWindowName )
      v4 = (const WCHAR *)v16;
    result = CreateEditInPlaceWindow(
               *(HWND *)hdc,
               v4,
               0x103u,
               (*((_DWORD *)hdc + 2) & 3) != 0 ? 1149239424 : 1149239493,
               *((_DWORD *)hdc + 14));
    *((_DWORD *)hdc + 62) = result;
    if ( result )
    {
      if ( lpWindowName )
        SetWindowLongW(result, -12, 1);
      v5 = (*((_DWORD *)hdc + 2) & 0x1000) == 0;
      v9 = 4;
      v10 = i;
      v11 = 0;
      if ( v5 )
      {
        v6 = DPA_GetPtr(*((HDPA *)hdc + 10), i);
        if ( !v6 )
        {
          result = (HWND)DestroyWindow(*((HWND *)hdc + 62));
          *((_DWORD *)hdc + 62) = 0;
          return result;
        }
        v12 = *((_DWORD *)v6 + 7);
      }
      else
      {
        v12 = 0;
      }
      *((_DWORD *)hdc + 63) = i;
      result = CCSendNotify((int)hdc, -175, (LPARAM)&lParam);
      if ( result )
      {
        v7 = (HWND)*((_DWORD *)hdc + 62);
        *((_DWORD *)hdc + 63) = -1;
        result = (HWND)DestroyWindow(v7);
        *((_DWORD *)hdc + 62) = 0;
      }
    }
  }
  return result;
}

//----- (6F7CC8DF) --------------------------------------------------------
int __stdcall ListView_RecomputeLabelSize(int a1, int a2, int a3, HDC a4, int a5)
{
  int result; // eax@5
  int v6; // eax@8
  int v7; // esi@8
  UINT v8; // edi@12
  __int16 v9; // cx@23
  LPARAM lParam; // [sp+Ch] [bp-4F0h]@10
  HDC hdc; // [sp+1Ch] [bp-4E0h]@11
  int v12; // [sp+60h] [bp-49Ch]@4
  int v13; // [sp+64h] [bp-498h]@4
  int v14; // [sp+68h] [bp-494h]@4
  int v15; // [sp+70h] [bp-48Ch]@4
  STRSAFE_LPCWSTR pszSrc; // [sp+74h] [bp-488h]@4
  int v17; // [sp+78h] [bp-484h]@4
  int v18; // [sp+80h] [bp-47Ch]@3
  struct tagRECT rc; // [sp+88h] [bp-474h]@5
  struct tagRECT v20; // [sp+98h] [bp-464h]@5
  HDC v21; // [sp+A8h] [bp-454h]@1
  struct tagRECT v22; // [sp+ACh] [bp-450h]@5
  int cchText; // [sp+BCh] [bp-440h]@8
  int v24; // [sp+C0h] [bp-43Ch]@1
  wchar_t chText; // [sp+C4h] [bp-438h]@16
  wchar_t pszDest; // [sp+2E4h] [bp-218h]@3

  v24 = a1;
  v21 = a4;
  if ( a5 && *(_DWORD *)a2 != -1 )
  {
    Str_GetPtrW(*(LPCWSTR *)a2, &pszDest, 265);
    v18 = *(_DWORD *)(a2 + 28);
  }
  else
  {
    v13 = a3;
    pszSrc = &pszDest;
    pszDest = 0;
    v12 = 5;
    v14 = 0;
    v17 = 264;
    v15 = 0;
    ListView_OnGetItem(264, (HDPA)a1, (int)&v12);
    if ( !pszSrc )
    {
      result = SetRectEmpty(&rc);
      v20 = rc;
      v22 = rc;
      goto LABEL_22;
    }
    if ( pszSrc != &pszDest )
      StringCchCopyW(&pszDest, 0x108u, pszSrc);
  }
  v6 = lstrlenW(&pszDest);
  v7 = *(_DWORD *)(a1 + 196);
  v22.bottom = 0;
  v22.top = 0;
  v22.left = 0;
  v22.right = v7 - 2 * g_cxLabelMargin;
  rc.left = 0;
  rc.top = 0;
  rc.right = v7 - 2 * g_cxLabelMargin;
  rc.bottom = 0;
  v20.left = 0;
  v20.top = 0;
  v20.right = v7 - 2 * g_cxLabelMargin;
  cchText = v6;
  v20.bottom = 0;
  if ( v6 <= 0 )
  {
    result = *(_DWORD *)(v24 + 84);
    v22.bottom = result;
    v20.bottom = result;
  }
  else
  {
    if ( v21 )
    {
      hdc = v21;
    }
    else
    {
      ListView_BeginFakeCustomDraw(v24, (LPARAM)&lParam, (int)&v12);
      ListView_BeginFakeItemDraw((LPARAM)&lParam);
    }
    v8 = 11297;
    DrawTextW(hdc, &pszDest, cchText, &rc, 0x2C21u);
    if ( !(*(_BYTE *)(v24 + 8) & 0x80) )
    {
      v8 = 11281;
      if ( g_uiACP == 949 )
      {
        if ( g_bRunOnNT5 )
          v8 = 535569;
      }
    }
    DrawTextW(hdc, &pszDest, cchText, &v22, v8);
    StringCchCopyW(&chText, 0x10Fu, &pszDest);
    DrawTextW(hdc, &chText, cchText, &v20, v8 | 0x50000);
    result = v20.bottom;
    if ( v20.bottom == v22.bottom )
    {
      result = lstrcmpW(&pszDest, &chText);
      if ( result )
        ++v20.bottom;
    }
    if ( !v21 )
    {
      ListView_EndFakeItemDraw((LPARAM)&lParam);
      result = ListView_EndFakeCustomDraw((LPARAM)&lParam);
    }
  }
LABEL_22:
  if ( a2 )
  {
    v9 = LOWORD(v20.bottom);
    *(_WORD *)(a2 + 14) = LOWORD(rc.right) + 2 * g_cxLabelMargin - rc.left;
    *(_WORD *)(a2 + 16) = LOWORD(v22.right) + 2 * g_cxLabelMargin - v22.left;
    result = (*(_DWORD *)(v24 + 8) & 0x80) == 0 ? g_cyEdge : 0;
    *(_WORD *)(a2 + 18) = result + v9 - LOWORD(v20.top);
    *(_WORD *)(a2 + 20) = result + LOWORD(v22.bottom) - LOWORD(v22.top);
  }
  return result;
}
// 6F7E68C8: using guessed type int g_uiACP;
// 6F7E6978: using guessed type int g_cxDoubleClk;
// 6F7E697C: using guessed type int g_cxLabelMargin;
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7CCC0B) --------------------------------------------------------
BOOL __stdcall SetEditInPlaceSize(HWND hWnd, LPRECT lprcDst, int a3, int a4)
{
  UINT v4; // eax@4
  int v5; // ecx@11
  LONG v6; // esi@12
  __int64 v7; // rax@12
  __int64 v8; // rax@14
  int v9; // eax@14
  LONG v10; // eax@16
  DWORD v11; // ST18_4@18
  DWORD v12; // eax@18
  struct tagRECT Rect; // [sp+Ch] [bp-250h]@18
  LPARAM lParam; // [sp+1Ch] [bp-240h]@18
  int v16; // [sp+20h] [bp-23Ch]@18
  int cchText; // [sp+2Ch] [bp-230h]@1
  HDC hdc; // [sp+30h] [bp-22Ch]@3
  HWND v19; // [sp+34h] [bp-228h]@1
  HGDIOBJ h; // [sp+38h] [bp-224h]@1
  struct tagRECT rc; // [sp+3Ch] [bp-220h]@3
  WCHAR String; // [sp+4Ch] [bp-210h]@1

  h = (HGDIOBJ)a3;
  v19 = GetParent(hWnd);
  cchText = GetWindowTextW(hWnd, &String, 261);
  if ( !String )
  {
    StringCchCopyW(&String, 0x105u, &c_szSpace);
    cchText = 1;
  }
  hdc = GetDC(v19);
  SelectObject(hdc, h);
  rc.bottom = 0;
  rc.top = 0;
  rc.left = 0;
  rc.right = g_cxIconSpacing - 2 * g_cxLabelMargin;
  h = (HGDIOBJ)(a4 & 1);
  if ( a4 & 1 )
  {
    v4 = 11281;
    if ( g_uiACP == 949 && g_bRunOnNT5 )
      v4 = 535569;
  }
  else
  {
    v4 = 11297;
  }
  DrawTextW(hdc, &String, cchText, &rc, v4);
  if ( rc.right < g_cxIconSpacing / 4 )
    rc.right = g_cxIconSpacing / 4;
  if ( a4 & 1 )
  {
    v5 = lprcDst->top;
  }
  else
  {
    v6 = lprcDst->top;
    v7 = rc.top + lprcDst->bottom - v6 - rc.bottom;
    v5 = v6 + (((signed int)v7 - HIDWORD(v7)) >> 1);
  }
  if ( h )
  {
    v8 = rc.left + lprcDst->right - lprcDst->left - rc.right;
    v9 = lprcDst->left + (((signed int)v8 - HIDWORD(v8)) >> 1);
  }
  else
  {
    v9 = lprcDst->left;
  }
  OffsetRect(&rc, v9, v5);
  v10 = rc.right;
  if ( !h )
    v10 = rc.right + 4 * g_cxLabelMargin;
  rc.right = g_cyEdge + v10;
  ReleaseDC(v19, hdc);
  GetClientRect(v19, &Rect);
  IntersectRect(&rc, &rc, &Rect);
  SendMessageW(hWnd, 0xB2u, 0, (LPARAM)&lParam);
  v16 = -v16;
  lParam = -lParam;
  v11 = GetWindowLongW(hWnd, -20);
  v12 = GetWindowLongW(hWnd, -16);
  AdjustWindowRectEx((LPRECT)&lParam, v12, 0, v11);
  InflateRect(&rc, -lParam, -v16);
  HideCaret(hWnd);
  SetWindowPos(hWnd, 0, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, 0x114u);
  CopyRect(lprcDst, &rc);
  InvalidateRect(hWnd, 0, 1);
  return ShowCaret(hWnd);
}
// 6F7E68C8: using guessed type int g_uiACP;
// 6F7E697C: using guessed type int g_cxLabelMargin;
// 6F7E6990: using guessed type int g_cxIconSpacing;
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7CCEC9) --------------------------------------------------------
WPARAM __stdcall DrawCompositionLine(HWND hWnd, HDC hdc, HGDIOBJ h, int a4, int a5, WPARAM wParam, int a7, int a8)
{
  WPARAM result; // eax@1
  HDC v9; // ebx@2
  UINT v10; // edx@3
  int v11; // eax@8
  COLORREF v12; // eax@13
  LRESULT v13; // eax@18
  int v14; // esi@18
  HPEN v15; // eax@18
  int v16; // eax@19
  int v17; // edi@19
  struct tagSIZE sz; // [sp+0h] [bp-3Ch]@19
  COLORREF v19; // [sp+8h] [bp-34h]@18
  COLORREF v20; // [sp+Ch] [bp-30h]@18
  HGDIOBJ ho; // [sp+10h] [bp-2Ch]@18
  int mode; // [sp+14h] [bp-28h]@19
  int x; // [sp+18h] [bp-24h]@18
  HGDIOBJ v24; // [sp+1Ch] [bp-20h]@18
  size_t cchDest; // [sp+20h] [bp-1Ch]@7
  UINT v26; // [sp+24h] [bp-18h]@2
  LPCWSTR lpString; // [sp+28h] [bp-14h]@8
  int iStyle; // [sp+2Ch] [bp-10h]@13
  COLORREF v29; // [sp+30h] [bp-Ch]@17
  int c; // [sp+34h] [bp-8h]@6
  COLORREF color; // [sp+38h] [bp-4h]@13
  HDC hdca; // [sp+48h] [bp+Ch]@19
  char hdc_3; // [sp+4Bh] [bp+Fh]@3

  result = a7;
  if ( wParam < a7 )
  {
    v9 = hdc;
    v26 = a7 - a8;
    while ( 1 )
    {
      v10 = wParam - a8;
      for ( hdc_3 = *(_BYTE *)(wParam - a8 + a5); v10 < v26; ++v10 )
      {
        if ( *(_BYTE *)(wParam - a8 + a5) != *(_BYTE *)(v10 + a5) )
          break;
      }
      result = UIntSub(v10, wParam - a8, (UINT *)&c);
      if ( (result & 0x80000000) != 0 )
        return result;
      result = ULongAdd(c, 1u, (ULONG *)&cchDest);
      if ( (result & 0x80000000) != 0 )
        return result;
      v11 = PrivateLocalAllocArray(cchDest, 2u);
      lpString = (LPCWSTR)v11;
      if ( v11 )
        break;
LABEL_25:
      result = c + wParam;
      wParam = result;
      if ( result >= a7 )
        return result;
    }
    StringCchCopyW((STRSAFE_LPWSTR)v11, cchDest, (STRSAFE_LPCWSTR)(a4 + 2 * (wParam - a8)));
    if ( hdc_3 )
    {
      if ( hdc_3 == 1 )
      {
LABEL_13:
        color = g_clrHighlightText;
        v12 = g_clrHighlight;
        iStyle = 2;
LABEL_17:
        v29 = v12;
        goto LABEL_18;
      }
      if ( hdc_3 != 2 )
      {
        if ( hdc_3 != 3 )
        {
LABEL_18:
          v20 = SetTextColor(v9, color);
          v19 = SetBkColor(v9, v29);
          v24 = SelectObject(v9, h);
          v13 = SendMessageW(hWnd, 0xD6u, wParam, 0);
          v14 = SHIWORD(v13);
          x = (signed __int16)v13;
          TextOutW(v9, (signed __int16)v13, SHIWORD(v13), lpString, c);
          v15 = CreatePen(iStyle, 1, color);
          ho = v15;
          if ( v15 )
          {
            hdca = (HDC)SelectObject(v9, v15);
            v16 = SetBkMode(v9, 1);
            sz.cx = 0;
            mode = v16;
            sz.cy = 0;
            GetTextExtentPointW(v9, lpString, c, &sz);
            v17 = x;
            MoveToEx(v9, x, sz.cy + v14 - 1, 0);
            LineTo(v9, sz.cx + v17, sz.cy + v14 - 1);
            SetBkMode(v9, mode);
            if ( hdca )
              SelectObject(v9, hdca);
            DeleteObject(ho);
          }
          if ( v24 )
            SelectObject(v9, v24);
          SetTextColor(v9, v20);
          SetBkColor(v9, v19);
          LocalFree((HLOCAL)lpString);
          goto LABEL_25;
        }
        goto LABEL_13;
      }
      iStyle = 0;
    }
    else
    {
      iStyle = 2;
    }
    color = g_clrWindowText;
    v12 = g_clrWindow;
    goto LABEL_17;
  }
  return result;
}
// 6F7CCEC9: could not find valid save-restore pair for ebx
// 6F7CCEC9: could not find valid save-restore pair for edi
// 6F7CCEC9: could not find valid save-restore pair for esi

//----- (6F7CD0C8) --------------------------------------------------------
HIMC __stdcall ListView_PaintComposition(HWND a1, int a2)
{
  HIMC result; // eax@1
  HIMC v3; // esi@2
  unsigned int v4; // ebx@3
  unsigned int v5; // edi@5
  HDC v6; // ST34_4@5
  int v7; // edi@5
  unsigned int v8; // ebx@7
  int v9; // edi@7
  LRESULT v10; // eax@8
  LRESULT v11; // eax@8
  int v12; // ebx@8
  int v13; // [sp+4h] [bp-224h]@5
  HDC hDC; // [sp+8h] [bp-220h]@7
  WPARAM wParam; // [sp+Ch] [bp-21Ch]@7
  int v16; // [sp+14h] [bp-214h]@3
  __int16 Buf; // [sp+11Ch] [bp-10Ch]@3

  result = (HIMC)a2;
  if ( !(*(_DWORD *)(a2 + 44) & 0x8000) )
  {
    result = ImmGetContext(a1);
    v3 = result;
    if ( result )
    {
      v4 = ImmGetCompositionStringW(result, 8u, &Buf, 0x104u);
      ImmGetCompositionStringW(v3, 0x10u, &v16, 0x104u);
      result = (HIMC)ImmReleaseContext(a1, v3);
      if ( (signed int)v4 > 0 && v4 <= 0x104 )
      {
        v5 = (unsigned int)GetPropW(a1, L"IMECompPos");
        v6 = (HDC)SendMessageW(a1, 0xD5u, 0, 0);
        v13 = (unsigned __int16)v5;
        v7 = 2 * (_DWORD)((char *)v6 + (v5 >> 16) - (unsigned __int16)v5 - GetWindowTextLengthW(a1));
        if ( v4 >= v7 )
          v4 = v7;
        *(__int16 *)((char *)&Buf + v4) = 0;
        v8 = v4 >> 1;
        wParam = v13;
        v9 = v8 + v13;
        hDC = GetDC(a1);
        if ( v13 < (signed int)(v8 + v13) )
        {
          do
          {
            v10 = SendMessageW(a1, 0xC9u, wParam, 0);
            v11 = SendMessageW(a1, 0xBBu, v10, 0);
            v12 = SendMessageW(a1, 0xC1u, v11, 0) + v11;
            if ( v12 <= v9 )
            {
              if ( v12 <= (signed int)wParam )
                break;
            }
            else
            {
              v12 = v9;
            }
            DrawCompositionLine(a1, hDC, *(HGDIOBJ *)(a2 + 56), (int)&Buf, (int)&v16, wParam, v12, v13);
            wParam = v12;
          }
          while ( v12 < v9 );
        }
        ReleaseDC(a1, hDC);
        result = (HIMC)ValidateRect(a1, 0);
      }
    }
  }
  return result;
}

//----- (6F7CD2AA) --------------------------------------------------------
int __stdcall ListView_IGetRectsOwnerData(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int v7; // eax@1
  signed int v8; // eax@2
  int v9; // eax@4
  int v10; // eax@4
  int v11; // eax@4
  int v12; // eax@4
  int result; // eax@4
  signed int v14; // [sp+14h] [bp+8h]@4

  v6 = a1;
  v7 = ListView_GetSlotCount(a1, 1);
  *(_WORD *)(a5 + 22) = 0;
  ListView_SetIconPos(a1, a5, a2, v7);
  ListView_RecomputeLabelSize(a1, a5, a2, 0, a6);
  if ( *(_BYTE *)(a1 + 8) & 0x80 )
    v8 = *(_WORD *)(a5 + 14);
  else
    v8 = *(_WORD *)(a5 + 16);
  v14 = v8;
  v9 = *(_DWORD *)(a5 + 4) - *(_DWORD *)(v6 + 220) - g_cxIconMargin;
  *(_DWORD *)a3 = v9;
  *(_DWORD *)(a3 + 8) = v9 + *(_DWORD *)(v6 + 208) + 2 * g_cxIconMargin;
  v10 = *(_DWORD *)(a5 + 8) - *(_DWORD *)(v6 + 224) - g_cyIconMargin;
  *(_DWORD *)(a3 + 4) = v10;
  *(_DWORD *)(a3 + 12) = *(_DWORD *)(v6 + 212) + v10 + 2 * g_cyIconMargin;
  v11 = *(_DWORD *)(v6 + 208) / 2 - v14 / 2 - *(_DWORD *)(v6 + 220) + *(_DWORD *)(a5 + 4);
  *(_DWORD *)a4 = v11;
  *(_DWORD *)(a4 + 8) = v14 + v11;
  v12 = *(_DWORD *)(v6 + 212) + g_cyLabelSpace + *(_DWORD *)(a5 + 8) - *(_DWORD *)(v6 + 224);
  *(_DWORD *)(a4 + 4) = v12;
  *(_DWORD *)(a4 + 12) = v12 + *(_WORD *)(a5 + 20);
  result = ListView_IsItemUnfolded(v6, a2);
  if ( !result )
    result = ListView_RefoldLabelRect(v6, a4, a5);
  return result;
}
// 6F7E6980: using guessed type int g_cyLabelSpace;
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7CD3B1) --------------------------------------------------------
int __stdcall ListView_IsCleanRect(int a1, RECT *lprcSrc2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@3
  struct tagRECT rcDst; // [sp+Ch] [bp-10h]@7

  v5 = *(_DWORD *)(a1 + 372);
  while ( 1 )
  {
    if ( v5 <= 0 )
      return 1;
    --v5;
    if ( v5 != a3 )
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v5);
      if ( *(_DWORD *)(v6 + 8) != 0x7FFFFFFF )
      {
        if ( *(_WORD *)(v6 + 18) == 0x7FFF )
        {
          ListView_RecomputeLabelSize(a1, v6, v5, (HDC)a5, 0);
          ListView_InvalidateItemEx(a1, v5, 0, 5u, 0);
          if ( LV_IsItemOnViewEdge(a1, v6) )
            *(_DWORD *)a4 = 1;
        }
        ListView_GetRects(a1, v5, 0, 0, &rcDst, 0);
        if ( IntersectRect(&rcDst, &rcDst, lprcSrc2) )
          break;
      }
    }
  }
  return 0;
}

//----- (6F7CD451) --------------------------------------------------------
int __stdcall ListView_FindFreeSlot(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v7; // eax@1
  int v8; // edi@1
  int v9; // ecx@2
  int v10; // eax@4
  struct tagRECT rcDst; // [sp+Ch] [bp-30h]@11
  RECT rcSrc2; // [sp+1Ch] [bp-20h]@10
  struct tagRECT rc; // [sp+2Ch] [bp-10h]@8

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
  v8 = *(_DWORD *)(v7 + 4 * a2);
  if ( !*(_DWORD *)a6 )
    goto LABEL_10;
  v9 = a2 - 1;
  if ( *(_DWORD *)(a1 + 128) > 0 )
  {
    if ( v9 < 0 )
      goto LABEL_9;
    v10 = v7 + 4 * v9;
    do
    {
      if ( *(_WORD *)(*(_DWORD *)v10 + 22) == *(_WORD *)(v8 + 22) )
        break;
      --v9;
      v10 -= 4;
    }
    while ( v9 >= 0 );
  }
  if ( v9 >= 0 )
  {
    ListView_GetRects(a1, v9, 0, 0, &rc, 0);
    goto LABEL_10;
  }
LABEL_9:
  SetRect(&rc, 0, 0, 0, 0);
LABEL_10:
  while ( 1 )
  {
    _CalcSlotRect(a1, v8, a3, a4, 1, &rcSrc2);
    if ( *(_DWORD *)a6 )
    {
      if ( !IntersectRect(&rcDst, &rc, &rcSrc2) )
        break;
    }
    if ( ListView_IsCleanRect(a1, &rcSrc2, a2, a5, a7) )
      break;
    ++a3;
  }
  return a3;
}

//----- (6F7CD51B) --------------------------------------------------------
signed int __stdcall ListView_SetEditSize(int a1)
{
  int v1; // eax@1
  __int64 v2; // rax@5
  int v3; // eax@6
  signed int result; // eax@8
  struct tagRECT rc; // [sp+4h] [bp-10h]@3

  v1 = *(_DWORD *)(a1 + 252);
  if ( v1 < 0 || v1 >= *(_DWORD *)(a1 + 372) )
  {
    result = ListView_DismissEdit(a1, 1);
  }
  else
  {
    ListView_GetRects(a1, v1, 0, (int)&rc, 0, 0);
    if ( *(_BYTE *)(a1 + 8) & 3 )
    {
      v2 = rc.bottom - *(_DWORD *)(a1 + 84) - rc.top;
      InflateRect(&rc, -(g_cxLabelMargin + g_cxBorder), -g_cyBorder - (((signed int)v2 - HIDWORD(v2)) >> 1));
    }
    else
    {
      InflateRect(&rc, -g_cxLabelMargin, -g_cyBorder);
    }
    v3 = 0;
    if ( !(*(_BYTE *)(a1 + 8) & 0x83) )
      v3 = 1;
    result = SetEditInPlaceSize(*(HWND *)(a1 + 248), &rc, *(_DWORD *)(a1 + 56), v3);
    if ( *(_DWORD *)(a1 + 48) & 0x200 )
      result = ListView_ChangeEditRectForRegion(a1, &rc);
  }
  return result;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7CD5E0) --------------------------------------------------------
int __stdcall ListView_InsertComposition(HWND hWnd, int a2, int a3, int a4)
{
  int result; // eax@1
  HWND v5; // ebx@2
  HWND v6; // ST08_4@2
  LRESULT v7; // eax@11
  unsigned int v8; // edi@11
  int v9; // edi@11
  bool v10; // cf@11
  LPVOID v11; // ST08_4@14
  HIMC v12; // ST00_4@14
  int v13; // esi@19
  int v14; // [sp+4h] [bp-Ch]@11
  LPVOID lpComp; // [sp+8h] [bp-8h]@10
  HIMC v16; // [sp+Ch] [bp-4h]@2

  result = *(_DWORD *)(a4 + 44);
  if ( !(result & 0x8000) )
  {
    v5 = hWnd;
    v6 = hWnd;
    *(_DWORD *)(a4 + 44) = result | 0x8000;
    SendMessageW(v6, 0xBu, 0, 0);
    v16 = ImmGetContext(v5);
    if ( v16 )
    {
      hWnd = (HWND)GetPropW(v5, L"IMECompPos");
      if ( !hWnd )
        hWnd = (HWND)SendMessageW(v5, 0xB0u, 0, 0);
      SendMessageW(v5, 0xB1u, (signed __int16)hWnd, SHIWORD(hWnd));
      if ( a3 & 0x800 )
      {
        if ( sub_6F7CC344(v16, 0x800u, (int)&hWnd) )
        {
          SendMessageW(v5, 0xC2u, 0, (LPARAM)hWnd);
          LocalFree(hWnd);
        }
        RemovePropW(v5, L"IMECompPos");
        hWnd = (HWND)SendMessageW(v5, 0xB0u, 0, 0);
      }
      if ( a3 & 8 )
      {
        a3 = sub_6F7CC344(v16, 8u, (int)&lpComp);
        if ( !a3 )
          goto LABEL_22;
        v7 = SendMessageW(v5, 0xD5u, 0, 0);
        v8 = (unsigned int)hWnd;
        v14 = (unsigned __int16)hWnd;
        v9 = v7 + (v8 >> 16) - v14 - GetWindowTextLengthW(v5);
        v10 = v9 < (unsigned int)a3;
        if ( v9 > (unsigned int)a3 )
        {
          v9 = a3;
          v10 = 0;
        }
        if ( v10 )
        {
          v11 = lpComp;
          v12 = v16;
          *((_WORD *)lpComp + v9) = 0;
          ImmSetCompositionStringW(v12, 9u, v11, 2 * v9, 0, 0);
          a3 = v9;
        }
        SendMessageW(v5, 0xC2u, 0, (LPARAM)lpComp);
        LocalFree(lpComp);
        if ( a3 )
          SetPropW(v5, L"IMECompPos", (HANDLE)(v14 | ((unsigned __int16)((_WORD)hWnd + a3) << 16)));
        else
LABEL_22:
          RemovePropW(v5, L"IMECompPos");
      }
      ImmReleaseContext(v5, v16);
    }
    SendMessageW(v5, 0xBu, 1u, 0);
    RedrawWindow(v5, 0, 0, 3u);
    v13 = a4;
    SetWindowLongW(*(HWND *)(a4 + 248), -12, 1);
    result = ListView_SetEditSize(v13);
    *(_DWORD *)(v13 + 44) &= 0xFFFF7FFF;
  }
  return result;
}

//----- (6F7CD7AA) --------------------------------------------------------
void __stdcall ListView_Recompute(int a1)
{
  int v1; // esi@1
  int v2; // ebx@1
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // eax@3
  bool v6; // zf@7
  int v7; // ecx@10
  bool v8; // sf@10
  int v9; // eax@11
  int v10; // edx@12
  int v11; // eax@18
  int v12; // ebx@29
  int v13; // ebx@30
  int v14; // ecx@30
  INT_PTR i; // ebx@41
  int v16; // ST18_4@43
  int v17[16]; // [sp+Ch] [bp-118h]@6
  LPARAM lParam; // [sp+4Ch] [bp-D8h]@8
  int v19; // [sp+5Ch] [bp-C8h]@16
  int v20; // [sp+A0h] [bp-84h]@8
  int v21; // [sp+A4h] [bp-80h]@16
  int v22; // [sp+A8h] [bp-7Ch]@8
  int v23; // [sp+C0h] [bp-64h]@16
  RECT rcSrc1; // [sp+C8h] [bp-5Ch]@34
  struct tagRECT rc; // [sp+D8h] [bp-4Ch]@34
  struct tagRECT rcDst; // [sp+E8h] [bp-3Ch]@30
  RECT rcSrc2; // [sp+F8h] [bp-2Ch]@34
  int v28; // [sp+108h] [bp-1Ch]@1
  int v29; // [sp+10Ch] [bp-18h]@8
  int v30; // [sp+110h] [bp-14h]@4
  int v31; // [sp+114h] [bp-10h]@10
  int v32; // [sp+118h] [bp-Ch]@14
  int v33; // [sp+11Ch] [bp-8h]@11
  int v34; // [sp+120h] [bp-4h]@7
  int v35; // [sp+12Ch] [bp+8h]@5
  int v36; // [sp+12Ch] [bp+8h]@10
  int v37; // [sp+12Ch] [bp+8h]@30

  v1 = a1;
  v2 = -(*(_DWORD *)(a1 + 372) != *(_DWORD *)(a1 + 388));
  *(_DWORD *)(a1 + 388) = 0;
  v3 = v2 + 1;
  v4 = *(_DWORD *)(a1 + 8) & 3;
  v28 = v3;
  if ( !v4 || v4 == 2 )
  {
    v5 = *(_DWORD *)(a1 + 44);
    if ( !(v5 & 0x40) )
    {
      *(_DWORD *)(a1 + 44) = v5 | 0x40;
      v30 = ListView_GetSlotCount(a1, 0);
      if ( *(_DWORD *)(a1 + 128) > 0 )
      {
        v35 = 0;
        do
        {
          v17[v35] = ListView_GetSlotCountEx(v1, 0, v35);
          ++v35;
        }
        while ( v35 < *(_DWORD *)(v1 + 128) );
      }
      v6 = (*(_DWORD *)(v1 + 8) & 0x1000) == 0;
      v34 = *(_DWORD *)(v1 + 228) == 0x7FFFFFFF;
      if ( v6 )
      {
        v29 = 0x7FFFFFFF;
        v20 = 4;
        v22 = 0;
        ListView_BeginFakeCustomDraw(v1, (LPARAM)&lParam, (int)&v20);
        if ( !v3 )
          v29 = LV_GetMaxPlacedItem(v1);
        v7 = 0;
        v6 = *(_DWORD *)(v1 + 372) == 0;
        v8 = *(_DWORD *)(v1 + 372) < 0;
        v31 = *(_DWORD *)(v1 + 244);
        v36 = 0;
        if ( !v8 && !v6 )
        {
          do
          {
            v6 = *(_DWORD *)(v1 + 128) == 0;
            v8 = *(_DWORD *)(v1 + 128) < 0;
            v9 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * v7);
            v33 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 40) + 4) + 4 * v7);
            if ( v8 || v6 )
              v10 = v30;
            else
              v10 = v17[*(_WORD *)(v9 + 22)];
            v6 = *(_DWORD *)(v9 + 8) == 0x7FFFFFFF;
            v32 = v10;
            if ( v6 )
            {
              if ( *(_WORD *)(v9 + 18) == 0x7FFF )
              {
                v21 = v7;
                v23 = *(_DWORD *)(v9 + 28);
                ListView_BeginFakeItemDraw((LPARAM)&lParam);
                ListView_RecomputeLabelSize(v1, v33, v36, (HDC)v19, 0);
                ListView_EndFakeItemDraw((LPARAM)&lParam);
              }
              v31 = ListView_FindFreeSlot(v1, v36, v31 + 1, v32, (int)&v34, (int)&v28, v19);
              ListView_SetIconPos(v1, v33, v31, v32);
              if ( !v3 )
              {
                v11 = LV_GetItemPixelRow(v1, v33);
                if ( v11 > v29 )
                {
                  v3 = 1;
                  v28 = 1;
                }
              }
              if ( !v34 && LV_IsItemOnViewEdge(v1, v33) )
                v34 = 1;
              ListView_InvalidateItemEx(v1, v36, 0, 5u, 0);
            }
            v7 = v36++ + 1;
          }
          while ( v36 < *(_DWORD *)(v1 + 372) );
        }
        *(_DWORD *)(v1 + 244) = v31;
        ListView_EndFakeCustomDraw((LPARAM)&lParam);
      }
      if ( v34 || *(_DWORD *)(v1 + 228) == 0x7FFFFFFF )
      {
        SetRectEmpty((LPRECT)(v1 + 228));
        if ( *(_DWORD *)(v1 + 8) & 0x1000 )
        {
          v12 = *(_DWORD *)(v1 + 372);
          if ( v12 > 0 )
          {
            v13 = v12 - 1;
            ListView_GetRects(v1, 0, 0, 0, (LPRECT)(v1 + 228), 0);
            ListView_GetRects(v1, v13, 0, 0, &rcDst, 0);
            *(_DWORD *)(v1 + 236) = rcDst.right;
            *(_DWORD *)(v1 + 240) = rcDst.bottom;
            v14 = v13 - (v30 + 2);
            v37 = v30 + 2;
            if ( v13 - (v30 + 2) < 0 )
              v14 = 0;
            ListView_NotifyCacheHint(v1, v14, v13);
            while ( 1 )
            {
              --v13;
              if ( v37 <= 0 || v13 < 0 )
                break;
              ListView_GetRects(v1, v13, (int)&rcSrc1, (int)&rc, &rcSrc2, 0);
              ListView_UnfoldRects(v1, v13, &rcSrc1, &rc, &rcSrc2, 0);
              if ( rcSrc2.right > rcDst.right )
                *(_DWORD *)(v1 + 236) = rcSrc2.right;
              if ( rcSrc2.bottom > rcDst.bottom )
                *(_DWORD *)(v1 + 240) = rcSrc2.bottom;
              --v37;
            }
          }
        }
        else
        {
          for ( i = 0; i < *(_DWORD *)(v1 + 372); ++i )
          {
            ListView_GetRects(v1, i, (int)&rc, (int)&rcSrc1, &rcSrc2, 0);
            ListView_UnfoldRects(v1, i, &rc, &rcSrc1, &rcSrc2, 0);
            UnionRect((LPRECT)(v1 + 228), (const RECT *)(v1 + 228), &rcSrc2);
          }
        }
        *(_DWORD *)(v1 + 240) += g_cyEdge;
        v16 = *(_DWORD *)(v1 + 224);
        *(_DWORD *)(v1 + 236) += g_cxEdge;
        OffsetRect((LPRECT)(v1 + 228), *(_DWORD *)(v1 + 220), v16);
        ListView_UpdateScrollBars((HDC)v1);
      }
      ListView_RecalcRegion(v1, 0, 1);
      *(_DWORD *)(v1 + 44) &= 0xFFFFFFBF;
    }
  }
}
// 6F7CD7AA: using guessed type int var_118[16];

//----- (6F7CDB1E) --------------------------------------------------------
int __stdcall ListView_GetViewRect2(int a1, LPRECT lprc, int a3, int a4)
{
  int result; // eax@3
  int v5; // ebx@3
  RECT rcSrc2; // [sp+8h] [bp-10h]@5

  if ( *(_DWORD *)(a1 + 228) == 0x7FFFFFFF )
    ListView_Recompute(a1);
  lprc->left = *(_DWORD *)(a1 + 228);
  lprc->top = *(_DWORD *)(a1 + 232);
  lprc->right = *(_DWORD *)(a1 + 236);
  lprc->bottom = *(_DWORD *)(a1 + 240);
  result = OffsetRect(lprc, -*(_DWORD *)(a1 + 220), -*(_DWORD *)(a1 + 224));
  v5 = *(_DWORD *)(a1 + 8) & 3;
  if ( !v5 || v5 == 2 )
  {
    rcSrc2.left = 0;
    rcSrc2.top = 0;
    rcSrc2.right = a3;
    rcSrc2.bottom = a4;
    result = UnionRect(lprc, lprc, &rcSrc2);
  }
  return result;
}

//----- (6F7CDB9F) --------------------------------------------------------
int __stdcall ListView_GetClientRect(int a1, int a2, int a3, int a4)
{
  LONG v4; // eax@2
  LONG v5; // ecx@2
  LONG v6; // ecx@4
  int v7; // ebx@8
  LONG v8; // eax@9
  int v9; // eax@14
  int v10; // eax@18
  int v11; // edi@22
  struct tagRECT rc; // [sp+Ch] [bp-20h]@9
  struct tagRECT Rect; // [sp+1Ch] [bp-10h]@1

  GetWindowRect(*(HWND *)a1, &Rect);
  if ( GetWindowLongW(*(HWND *)a1, -20) & 0x20300 )
  {
    v4 = Rect.right + -2 * g_cxEdge;
    v5 = Rect.bottom + -2 * g_cyEdge;
  }
  else
  {
    v5 = Rect.bottom;
    v4 = Rect.right;
  }
  v6 = v5 - Rect.top;
  Rect.right = v4 - Rect.left;
  Rect.bottom = v6;
  if ( v4 - Rect.left < 0 )
    Rect.right = 0;
  if ( v6 < 0 )
    Rect.bottom = 0;
  v7 = 0;
  Rect.left = 0;
  Rect.top = 0;
  if ( a3 )
  {
    ListView_GetViewRect2(a1, &rc, 0, 0);
    v8 = Rect.right;
    if ( Rect.left < Rect.right && Rect.top < Rect.bottom )
    {
      do
      {
        if ( !(v7 & 0x100000) && (rc.left < Rect.left || rc.right > v8) )
        {
          v7 |= 0x100000u;
          v9 = ListView_GetCyScrollbar(a1);
          Rect.bottom -= v9;
        }
        if ( !(v7 & 0x200000) && (rc.top < Rect.top || rc.bottom > Rect.bottom) )
        {
          v7 |= 0x200000u;
          v10 = ListView_GetCxScrollbar(a1);
          Rect.right -= v10;
        }
        if ( v7 & 0x100000 )
          break;
        v8 = Rect.right;
      }
      while ( rc.right > Rect.right );
    }
    if ( a4 )
    {
      *(_DWORD *)a4 = rc.left;
      *(_DWORD *)(a4 + 4) = rc.top;
      v11 = a4 + 8;
      *(_DWORD *)v11 = rc.right;
      *(_DWORD *)(v11 + 4) = rc.bottom;
    }
  }
  *(_OWORD *)a2 = Rect;
  return v7;
}

//----- (6F7CDCB3) --------------------------------------------------------
UINT __stdcall ListView_IUpdateScrollBars(HDC hdc)
{
  HDC v1; // esi@1
  int v2; // eax@1
  int v3; // ecx@1
  UINT v4; // eax@10
  UINT result; // eax@18
  HWND v6; // [sp-14h] [bp-6Ch]@15
  HWND v7; // [sp-14h] [bp-6Ch]@28
  struct tagSCROLLINFO psi; // [sp+Ch] [bp-4Ch]@5
  int v9; // [sp+28h] [bp-30h]@1
  int v10; // [sp+2Ch] [bp-2Ch]@19
  int v11; // [sp+30h] [bp-28h]@6
  int v12; // [sp+34h] [bp-24h]@19
  int v13; // [sp+38h] [bp-20h]@1
  int v14; // [sp+3Ch] [bp-1Ch]@3
  int v15; // [sp+40h] [bp-18h]@6
  int v16; // [sp+44h] [bp-14h]@19
  int v17; // [sp+48h] [bp-10h]@1
  int v18; // [sp+4Ch] [bp-Ch]@1
  int v19; // [sp+50h] [bp-8h]@1
  int v20; // [sp+54h] [bp-4h]@1
  HDC hdca; // [sp+60h] [bp+8h]@1

  v1 = hdc;
  v17 = 0;
  v18 = 0;
  v20 = 0;
  v19 = ListView_GetWindowStyle((int)hdc);
  v2 = ListView_GetClientRect((int)hdc, (int)&v9, 1, (int)&v13);
  v3 = v13;
  hdca = (HDC)v2;
  if ( v13 > 0 )
    v3 = 0;
  if ( v14 > 0 )
    v14 = 0;
  psi.cbSize = 28;
  if ( (unsigned int)hdca & 0x100000 )
  {
    psi.nMax = v15 - v3 - 1;
    psi.fMask = 7;
    psi.nMin = 0;
    psi.nPage = v11 - v9;
    psi.nPos = v9 - v3;
    if ( v9 - v3 < 0 )
      psi.nPos = 0;
    ListView_SetScrollInfo((int)v1, 0, &psi, 1);
    if ( (signed int)(psi.nPos + psi.nPage - 1) > psi.nMax && psi.nPos > 0 )
    {
      v4 = psi.nMax - psi.nPage + 1;
      if ( (v4 & 0x80000000) != 0 )
        v4 = 0;
      if ( v4 != psi.nPos )
      {
        v17 = v4 - psi.nPos;
        v20 = 1;
      }
    }
  }
  else if ( v19 & 0x100000 )
  {
    v6 = *(HWND *)v1;
    if ( *((_DWORD *)v1 + 12) & 0x100 )
      FlatSB_SetScrollRange(v6, 0, 0, 0, 1);
    else
      SetScrollRange(v6, 0, 0, 0, 1);
  }
  result = 0x200000;
  if ( (unsigned int)hdca & 0x200000 )
  {
    psi.nMax = v16 - v14 - 1;
    psi.fMask = 7;
    psi.nMin = 0;
    psi.nPage = v12 - v10;
    psi.nPos = v10 - v14;
    if ( v10 - v14 < 0 )
      psi.nPos = 0;
    ListView_SetScrollInfo((int)v1, 1, &psi, 1);
    result = psi.nMax;
    if ( (signed int)(psi.nPos + psi.nPage - 1) > psi.nMax && psi.nPos > 0 )
    {
      result = psi.nMax - psi.nPage + 1;
      if ( (result & 0x80000000) != 0 )
        result = 0;
      if ( result != psi.nPos )
      {
        result -= psi.nPos;
        v18 = result;
        v20 = 1;
      }
    }
  }
  else if ( v19 & 0x200000 )
  {
    v7 = *(HWND *)v1;
    if ( *((_DWORD *)v1 + 12) & 0x100 )
      result = FlatSB_SetScrollRange(v7, 1, 0, 0, 1);
    else
      result = SetScrollRange(v7, 1, 0, 0, 1);
  }
  if ( v20 )
  {
    ListView_IScroll2(v1, v17, v18, 0);
    result = ListView_IUpdateScrollBars(v1);
  }
  return result;
}

//----- (6F7CDE46) --------------------------------------------------------
int __stdcall ListView_EditWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  HWND v4; // eax@1
  int v5; // esi@1
  int v6; // eax@22
  LRESULT v8; // edi@26

  v4 = GetParent(hWnd);
  v5 = GetWindowLongW(v4, 0);
  if ( g_fDBCSInputEnabled && (unsigned __int16)GetKeyboardLayout(0) == 1041 )
  {
    if ( Msg == 5 )
    {
      ListView_SizeIME(hWnd);
    }
    else if ( Msg == 197 )
    {
      if ( wParam >= 0xD )
        *(_DWORD *)(v5 + 44) &= 0xFFFFBFFF;
      else
        *(_DWORD *)(v5 + 44) |= 0x4000u;
    }
    else if ( !(*(_DWORD *)(v5 + 44) & 0x4000) )
    {
      if ( Msg == 15 )
      {
        v8 = CallWindowProcW(*(WNDPROC *)(v5 + 256), hWnd, 0xFu, wParam, lParam);
        ListView_PaintComposition(hWnd, v5);
        return v8;
      }
      if ( Msg > 0x10C )
      {
        if ( Msg <= 0x10E )
          return 0;
        if ( Msg == 271 )
        {
          v6 = lParam;
          if ( !lParam )
            v6 = 8;
          ListView_InsertComposition(hWnd, wParam, v6, v5);
          return 0;
        }
        if ( Msg == 641 )
          lParam &= 0x7FFFFFFFu;
      }
    }
  }
  if ( Msg == 12 )
  {
    SetWindowLongW(hWnd, -12, 1);
  }
  else
  {
    if ( Msg == 135 )
      return 12;
    if ( Msg != 256 )
    {
      if ( Msg != 258 || wParam != 13 )
        return CallWindowProcW(*(WNDPROC *)(v5 + 256), hWnd, Msg, wParam, lParam);
      return 0;
    }
    if ( wParam == 13 )
    {
      ListView_DismissEdit(v5, 0);
      return 0;
    }
    if ( wParam == 27 )
    {
      ListView_DismissEdit(v5, 1);
      return 0;
    }
  }
  return CallWindowProcW(*(WNDPROC *)(v5 + 256), hWnd, Msg, wParam, lParam);
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7CDF9B) --------------------------------------------------------
int __stdcall ListView_OnEditLabel(HDC hdc, INT_PTR i, int a3)
{
  HWND v3; // eax@4
  int result; // eax@10
  RECT Rect; // [sp+Ch] [bp-10h]@9

  ListView_DismissEdit((int)hdc, 0);
  if ( *((_DWORD *)hdc + 2) & 0x200 && GetFocus() == *(HWND *)hdc && i != -1 )
  {
    ListView_DoOnEditLabel(hdc, i, a3);
    v3 = (HWND)*((_DWORD *)hdc + 62);
    if ( v3 )
    {
      *((_DWORD *)hdc + 64) = SetWindowLongW(v3, -4, (LONG)ListView_EditWndProc);
      if ( g_fDBCSInputEnabled && SendMessageW(*((HWND *)hdc + 62), 0xD5u, 0, 0) < 13 )
        *((_DWORD *)hdc + 11) |= 0x4000u;
      ListView_SetEditSize((int)hdc);
      SetFocus(*((HWND *)hdc + 62));
      ShowWindow(*((HWND *)hdc + 62), 5);
      ListView_InvalidateItemEx((int)hdc, i, 1, 5u, 0);
      RescrollEditWindow(*((HWND *)hdc + 62));
      if ( !(*((_BYTE *)hdc + 8) & 3) )
      {
        ListView_GetRects((int)hdc, i, 0, (int)&Rect, 0, 0);
        ListView_UnfoldRects((int)hdc, i, 0, &Rect, 0, 0);
        InvalidateRect(*(HWND *)hdc, &Rect, 1);
        UpdateWindow(*(HWND *)hdc);
      }
    }
    result = *((_DWORD *)hdc + 62);
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E68DC: using guessed type int g_fDBCSInputEnabled;

//----- (6F7CE0B1) --------------------------------------------------------
int __stdcall ListView_IItemHitTest(int a1, POINT pt, int a3, int a4)
{
  int v4; // esi@3
  LONG v5; // ebx@3
  signed int v6; // edi@3
  bool v7; // zf@3
  int v8; // eax@6
  int v9; // eax@6
  int v11; // edi@15
  LONG v12; // ebx@15
  LONG v13; // ecx@15
  signed int v14; // ecx@19
  LONG v15; // eax@19
  LONG v16; // eax@19
  int v17; // eax@19
  char v18; // [sp+0h] [bp-7Ch]@7
  RECT v19; // [sp+3Ch] [bp-40h]@19
  RECT rc; // [sp+4Ch] [bp-30h]@7
  RECT v21; // [sp+5Ch] [bp-20h]@7
  int v22; // [sp+70h] [bp-Ch]@15
  POINT v23; // [sp+74h] [bp-8h]@3
  signed int v24; // [sp+84h] [bp+8h]@6
  int v25; // [sp+94h] [bp+18h]@5

  if ( a4 )
    *(_DWORD *)a4 = 0;
  v4 = a1;
  v5 = pt.y + *(_DWORD *)(a1 + 224);
  v6 = pt.x + *(_DWORD *)(a1 + 220);
  v7 = *(_DWORD *)(a1 + 228) == 0x7FFFFFFF;
  v23.x = pt.x + *(_DWORD *)(a1 + 220);
  v23.y = v5;
  if ( v7 )
    ListView_Recompute(a1);
  v25 = 0;
  if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
  {
    v24 = 0;
    if ( *(_DWORD *)(v4 + 372) > 0 )
    {
      do
      {
        v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4)
                        + 4 * *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 216) + 4) + 4 * v24));
        v12 = *(_DWORD *)(v11 + 4);
        v13 = *(_DWORD *)(v11 + 8) - g_cyIconMargin;
        v22 = *(_DWORD *)(v11 + 8);
        rc.top = v13;
        v21.top = *(_DWORD *)(v4 + 212) + g_cyLabelSpace + v22;
        v21.bottom = v21.top + *(_WORD *)(v11 + 20);
        if ( !ListView_IsItemUnfoldedPtr(v4, v11) )
          ListView_RefoldLabelRect(v4, (int)&v21, v11);
        if ( v23.y >= rc.top && v23.y < v21.bottom )
        {
          rc.left = v12 - g_cxIconMargin;
          v14 = *(_DWORD *)(v4 + 208);
          rc.right = v12 + v14 + g_cxIconMargin;
          rc.bottom = v21.top;
          v15 = v22 + *(_DWORD *)(v4 + 212);
          v19.bottom = v15;
          v16 = v15 - *(_DWORD *)(v4 + 360);
          v19.right = v12;
          v19.top = v16;
          v19.left = v12 - *(_DWORD *)(v4 + 356);
          v21.left = v12 + v14 / 2 - *(_WORD *)(v11 + 16) / 2;
          v17 = *(_DWORD *)(v4 + 356);
          v21.right = v21.left + *(_WORD *)(v11 + 16);
          if ( v17 && PtInRect(&v19, v23) )
          {
            v25 = 8;
            goto LABEL_9;
          }
          if ( PtInRect(&rc, v23) )
            goto LABEL_8;
          if ( PtInRect(&v21, v23) )
            v25 = 4;
          if ( v25 )
            goto LABEL_9;
        }
        ++v24;
      }
      while ( v24 < *(_DWORD *)(v4 + 372) );
      if ( v25 )
        goto LABEL_9;
    }
    goto LABEL_27;
  }
  v8 = ListView_GetSlotCount(a1, 1);
  v9 = ListView_CalcHitSlot(a1, v6, v5, v8);
  v24 = v9;
  if ( v9 >= *(_DWORD *)(v4 + 372) )
    goto LABEL_27;
  ListView_IGetRectsOwnerData(v4, v9, (int)&rc, (int)&v21, (int)&v18, 0);
  if ( PtInRect(&rc, pt) )
  {
LABEL_8:
    v25 = 2;
    goto LABEL_9;
  }
  if ( !PtInRect(&v21, pt) )
  {
LABEL_27:
    v24 = -1;
    v25 = 1;
    goto LABEL_11;
  }
  v25 = 4;
LABEL_9:
  if ( !(*(_DWORD *)(v4 + 8) & 0x1000) )
    v24 = DPA_GetPtrIndex(
            *(HDPA *)(v4 + 40),
            *(const void **)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4)
                           + 4 * *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 216) + 4) + 4 * v24)));
LABEL_11:
  *(_DWORD *)a3 = v25;
  return v24;
}
// 6F7E6980: using guessed type int g_cyLabelSpace;
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7CE330) --------------------------------------------------------
int __stdcall ListView_IGetRects(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // eax@4
  int v6; // eax@5
  int v7; // ecx@7
  int v8; // eax@7
  int v9; // eax@7
  int v10; // eax@7
  int result; // eax@7

  if ( *(_DWORD *)(a2 + 4) == 0x7FFFFFFF )
    ListView_Recompute(a1);
  if ( *(_BYTE *)(a1 + 8) & 3 || (v5 = *(_DWORD *)(a1 + 196) - *(_DWORD *)(a1 + 208), v5 >= 2 * g_cxIconMargin) )
    v6 = g_cxIconMargin;
  else
    v6 = v5 / 2;
  v7 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 220) - v6;
  *(_DWORD *)a3 = v7;
  *(_DWORD *)(a3 + 8) = v7 + *(_DWORD *)(a1 + 208) + 2 * v6;
  v8 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 224) - g_cyIconMargin;
  *(_DWORD *)(a3 + 4) = v8;
  *(_DWORD *)(a3 + 12) = v8 + *(_DWORD *)(a1 + 212) + 2 * g_cyIconMargin;
  v9 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a1 + 208) / 2 - *(_WORD *)(a2 + 16) / 2 - *(_DWORD *)(a1 + 220);
  *(_DWORD *)a4 = v9;
  *(_DWORD *)(a4 + 8) = v9 + *(_WORD *)(a2 + 16);
  v10 = *(_DWORD *)(a2 + 8) + g_cyLabelSpace + *(_DWORD *)(a1 + 212) - *(_DWORD *)(a1 + 224);
  *(_DWORD *)(a4 + 4) = v10;
  *(_DWORD *)(a4 + 12) = v10 + *(_WORD *)(a2 + 20);
  result = ListView_IsItemUnfoldedPtr(a1, a2);
  if ( !result )
    result = ListView_RefoldLabelRect(a1, a4, a2);
  return result;
}
// 6F7E6980: using guessed type int g_cyLabelSpace;
// 6F7E6984: using guessed type int g_cyIconMargin;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7CE42C) --------------------------------------------------------
int __stdcall _ListView_GetRectsFromItem(int a1, int a2, int a3, RECT *lprcSrc1, RECT *lprcSrc2, LPRECT lprcDst, LPRECT a7)
{
  int v7; // ebx@1
  int result; // eax@10
  char *v9; // edi@16
  char *v10; // edi@17
  char v11; // [sp+4h] [bp-20h]@4
  char v12; // [sp+14h] [bp-10h]@2

  v7 = (int)lprcSrc1;
  if ( !lprcSrc1 )
    v7 = (int)&v12;
  if ( !lprcSrc2 )
    lprcSrc2 = (RECT *)&v11;
  if ( a3 )
  {
    if ( *(_DWORD *)(a3 + 8) == 0x7FFFFFFF || *(_WORD *)(a3 + 18) == 0x7FFF )
      ListView_Recompute(a1);
    if ( a2 )
      result = ListView_SGetRects(a1, a3, v7, (int)lprcSrc2, (int)lprcDst);
    else
      result = ListView_IGetRects(a1, a3, v7, (int)lprcSrc2, (int)lprcDst);
    if ( lprcDst )
    {
      result = UnionRect(lprcDst, (const RECT *)v7, lprcSrc2);
      if ( *(_DWORD *)(a1 + 352) )
      {
        result = 61440;
        if ( *(_WORD *)(a3 + 24) & 0xF000 )
        {
          result = *(_DWORD *)(a1 + 356);
          lprcDst->left -= result;
        }
      }
    }
  }
  else
  {
    result = SetRectEmpty((LPRECT)v7);
    lprcSrc2->left = *(_DWORD *)v7;
    lprcSrc2->top = *(_DWORD *)(v7 + 4);
    v9 = (char *)&lprcSrc2->right;
    *(_DWORD *)v9 = *(_DWORD *)(v7 + 8);
    *((_DWORD *)v9 + 1) = *(_DWORD *)(v7 + 12);
    if ( lprcDst )
    {
      lprcDst->left = *(_DWORD *)v7;
      lprcDst->top = *(_DWORD *)(v7 + 4);
      v10 = (char *)&lprcDst->right;
      *(_DWORD *)v10 = *(_DWORD *)(v7 + 8);
      *((_DWORD *)v10 + 1) = *(_DWORD *)(v7 + 12);
    }
  }
  if ( a7 )
    result = UnionRect(a7, (const RECT *)v7, lprcSrc2);
  return result;
}

//----- (6F7CE4FB) --------------------------------------------------------
BOOL __stdcall _ListView_InvalidateItemPtr(int a1, int a2, int a3, UINT flags)
{
  RECT rcUpdate; // [sp+4h] [bp-10h]@1

  _ListView_GetRectsFromItem(a1, a2, a3, 0, 0, &rcUpdate, 0);
  return RedrawWindow(*(HWND *)a1, &rcUpdate, 0, flags);
}

//----- (6F7CE538) --------------------------------------------------------
int __stdcall ListView_IUnstackOverlaps(int a1, HDPA hdpa, int a3)
{
  int v3; // edi@1
  INT_PTR v4; // esi@1
  char v5; // al@1
  int v6; // eax@2
  int v7; // ebx@5
  int v8; // esi@10
  int v9; // ebx@12
  POINT v10; // ST14_8@13
  int v11; // ebx@19
  int v12; // ecx@20
  struct tagRECT rcDst; // [sp+8h] [bp-54h]@11
  RECT rcSrc2; // [sp+18h] [bp-44h]@11
  RECT rcSrc1; // [sp+28h] [bp-34h]@6
  int v17; // [sp+38h] [bp-24h]@10
  int v18; // [sp+3Ch] [bp-20h]@10
  INT_PTR v19; // [sp+40h] [bp-1Ch]@7
  int v20; // [sp+44h] [bp-18h]@5
  int v21; // [sp+48h] [bp-14h]@1
  int v22; // [sp+4Ch] [bp-10h]@4
  INT_PTR v23; // [sp+50h] [bp-Ch]@4
  INT_PTR i; // [sp+54h] [bp-8h]@7
  int v25; // [sp+58h] [bp-4h]@2
  int v26; // [sp+64h] [bp+8h]@1

  v3 = a1;
  v4 = 0;
  v5 = *(_DWORD *)(a1 + 8) & 3;
  v21 = 0;
  v26 = v5 == 2;
  if ( v5 == 2 )
  {
    v25 = *(_DWORD *)(v3 + 184);
    v6 = *(_DWORD *)(v3 + 188);
  }
  else
  {
    v25 = *(_DWORD *)(v3 + 196);
    v6 = *(_DWORD *)(v3 + 200);
  }
  v22 = v6;
  v23 = *(_DWORD *)(v3 + 372);
  if ( v23 > 0 )
  {
    do
    {
      v7 = (int)DPA_GetPtr(hdpa, v4);
      v20 = v7;
      if ( v26 )
        _ListView_GetRectsFromItem(v3, v26, v7, 0, 0, &rcSrc1, 0);
      v19 = v4 + 1;
      i = v4 + 1;
      if ( v4 + 1 < v23 )
      {
        while ( 1 )
        {
          v8 = (int)DPA_GetPtr(hdpa, i);
          v17 = *(_DWORD *)(v8 + 4);
          v18 = *(_DWORD *)(v8 + 8);
          if ( v26 )
          {
            _ListView_GetRectsFromItem(v3, v26, v8, 0, 0, &rcSrc2, 0);
            if ( !IntersectRect(&rcDst, &rcSrc1, &rcSrc2) )
              break;
            _ListView_InvalidateItemPtr(v3, v26, v8, 5u);
            v9 = a3 * v25;
            do
            {
              v10.y = *(_DWORD *)(v8 + 8);
              *(_DWORD *)(v8 + 4) += v9;
              v10.x = *(_DWORD *)(v8 + 4);
            }
            while ( PtInRect(&rcSrc1, v10) );
          }
          else
          {
            if ( *(_DWORD *)(v8 + 4) != *(_DWORD *)(v7 + 4) || *(_DWORD *)(v8 + 8) != *(_DWORD *)(v7 + 8) )
              break;
            _ListView_InvalidateItemPtr(v3, 0, v8, 5u);
            *(_DWORD *)(v8 + 4) += a3 * v25;
          }
          if ( *(_DWORD *)(v3 + 8) & 0x2000 )
          {
            v11 = *(_DWORD *)(v8 + 4);
            if ( v11 < 0
              || (v12 = *(_DWORD *)(v8 + 8), v12 < 0)
              || v11 > *(_DWORD *)(v3 + 120) - v25 / 2
              || v12 > *(_DWORD *)(v3 + 124) - v22 / 2 )
            {
              *(_DWORD *)(v8 + 4) = v17;
              *(_DWORD *)(v8 + 8) = v18;
              v21 = 1;
            }
          }
          _ListView_InvalidateItemPtr(v3, v26, v8, 5u);
          ++i;
          if ( i >= v23 )
            break;
          v7 = v20;
        }
      }
      v4 = v19;
    }
    while ( v19 < v23 );
  }
  return v21;
}

//----- (6F7CE6EE) --------------------------------------------------------
int __stdcall ListView_SnapToGrid(int a1, HDPA hdpa)
{
  int v2; // esi@1
  char v3; // al@1
  int v4; // eax@2
  PVOID v5; // eax@5
  int v6; // ebx@5
  int v7; // edi@5
  int v8; // ecx@5
  __int64 v9; // rax@6
  int v10; // eax@7
  __int64 v11; // rax@10
  int v12; // ebx@10
  int j; // ecx@16
  int v14; // ST08_4@26
  int v15; // eax@28
  int v16; // eax@31
  int v17; // eax@35
  INT_PTR v19; // [sp+4h] [bp-20h]@4
  int v20; // [sp+8h] [bp-1Ch]@5
  int v21; // [sp+Ch] [bp-18h]@5
  INT_PTR i; // [sp+10h] [bp-14h]@4
  int v23; // [sp+14h] [bp-10h]@5
  int v24; // [sp+18h] [bp-Ch]@4
  int v25; // [sp+1Ch] [bp-8h]@2
  int v26; // [sp+20h] [bp-4h]@1

  v2 = a1;
  v3 = *(_DWORD *)(a1 + 8) & 3;
  v26 = v3 == 2;
  if ( v3 == 2 )
  {
    v25 = *(_DWORD *)(a1 + 184);
    v4 = *(_DWORD *)(a1 + 188);
  }
  else
  {
    v25 = *(_DWORD *)(a1 + 196);
    v4 = *(_DWORD *)(a1 + 200);
  }
  i = 0;
  v24 = v4;
  v19 = *(_DWORD *)(a1 + 372);
  if ( v19 > 0 )
  {
    do
    {
      v5 = DPA_GetPtr(hdpa, i);
      v6 = g_cyBorder;
      v7 = (int)v5;
      v21 = *((_DWORD *)v5 + 1);
      a1 = *((_DWORD *)v5 + 1);
      v8 = *((_DWORD *)v5 + 2);
      v20 = *((_DWORD *)v5 + 2);
      v23 = *((_DWORD *)v5 + 2);
      if ( !v26 )
      {
        v9 = *(_DWORD *)(v2 + 196) - *(_DWORD *)(v2 + 208);
        a1 -= ((signed int)v9 - HIDWORD(v9)) >> 1;
        v23 = v8 + -2 * g_cyBorder;
      }
      v10 = 0;
      if ( *(_DWORD *)(v2 + 128) > 0 )
        v10 = *(_DWORD *)(v2 + 132) + 16 * *(_WORD *)(v7 + 22);
      NearestSlot((int)&a1, (int)&v23, v25, v24, v10);
      if ( v26 )
      {
        v12 = v23;
      }
      else
      {
        v11 = *(_DWORD *)(v2 + 196) - *(_DWORD *)(v2 + 208);
        a1 += ((signed int)v11 - HIDWORD(v11)) >> 1;
        v12 = v23 + 2 * v6;
      }
      if ( a1 != v21 || v12 != v20 )
      {
        _ListView_InvalidateItemPtr(v2, v26, v7, 5u);
        if ( !(*(_DWORD *)(v2 + 8) & 0x2000) || *(_DWORD *)(v2 + 128) )
        {
          j = a1;
        }
        else
        {
          for ( j = a1; j >= *(_DWORD *)(v2 + 120) - v25 / 2; j -= v25 )
            ;
          for ( ; j < 0; j += v25 )
            ;
          for ( ; v12 >= *(_DWORD *)(v2 + 124) - v24 / 2; v12 -= v24 )
            ;
          for ( ; v12 < 0; v12 += v24 )
            ;
        }
        v14 = v26;
        *(_DWORD *)(v7 + 4) = j;
        *(_DWORD *)(v7 + 8) = v12;
        *(_DWORD *)(v2 + 244) = -1;
        _ListView_InvalidateItemPtr(v2, v14, v7, 5u);
      }
      ++i;
    }
    while ( i < v19 );
  }
  v15 = *(_DWORD *)(v2 + 8) & 0xC00;
  if ( v15 == 2048 || v15 == 3072 )
  {
    if ( v26 )
      v17 = *(_DWORD *)(v2 + 184);
    else
      v17 = *(_DWORD *)(v2 + 196);
    v16 = (unsigned __int16)v17 | 0x10000;
  }
  else
  {
    if ( v26 )
      v16 = *(_DWORD *)(v2 + 188);
    else
      v16 = *(_DWORD *)(v2 + 200);
    v16 = (unsigned __int16)v16;
  }
  if ( DPA_Sort(hdpa, ArrangeIconCompare, v16) && ListView_IUnstackOverlaps(v2, hdpa, 1) )
    ListView_IUnstackOverlaps(v2, hdpa, -1);
  return 0;
}

//----- (6F7CE913) --------------------------------------------------------
int __stdcall ListView_CommonArrangeEx(HDC hdc, int a2, HDPA hdpa, int a4)
{
  HDC v4; // esi@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // eax@13
  int v8; // edi@14
  bool v9; // zf@18
  bool v10; // sf@18
  PVOID v11; // eax@19
  int v12; // edi@19
  int v13; // eax@19
  int v14; // ebx@21
  LONG v15; // eax@32
  int v16; // edx@37
  int k; // ecx@38
  int v18; // eax@39
  int v19; // eax@45
  RECT *j; // [sp-8h] [bp-B4h]@25
  int v22[16]; // [sp+8h] [bp-A4h]@15
  struct tagRECT rcDst; // [sp+48h] [bp-64h]@27
  RECT v24; // [sp+58h] [bp-54h]@28
  RECT rcSrc2; // [sp+68h] [bp-44h]@28
  RECT rcSrc1; // [sp+78h] [bp-34h]@25
  int v27; // [sp+88h] [bp-24h]@17
  struct tagRECT rc; // [sp+8Ch] [bp-20h]@18
  int v29; // [sp+9Ch] [bp-10h]@1
  int v30; // [sp+A0h] [bp-Ch]@1
  int v31; // [sp+A4h] [bp-8h]@1
  INT_PTR i; // [sp+A8h] [bp-4h]@18
  HDC hdca; // [sp+B4h] [bp+8h]@8
  int v34; // [sp+B8h] [bp+Ch]@18

  v4 = hdc;
  v5 = *((_DWORD *)hdc + 2);
  v6 = *((_DWORD *)hdc + 2) & 3;
  v31 = 0;
  v30 = v6 == 2;
  v29 = v6 == 0;
  if ( !a2 && v5 & 0x100 )
  {
    if ( *((_DWORD *)hdc + 55) < 0 )
      *((_DWORD *)hdc + 55) = 0;
    if ( *((_DWORD *)hdc + 56) < 0 )
      *((_DWORD *)hdc + 56) = 0;
  }
  if ( *((_DWORD *)hdc + 55) || (hdca = 0, *((_DWORD *)v4 + 56)) )
    hdca = (HDC)1;
  if ( !(v5 & 0x1000) )
  {
    if ( a2 == 5 )
    {
      hdca = (HDC)(ListView_SnapToGrid((int)v4, hdpa) | (unsigned int)hdca);
    }
    else
    {
      v7 = *((_DWORD *)v4 + 32);
      if ( v7 <= 0 )
      {
        v27 = ListView_GetSlotCount((int)v4, 1);
      }
      else
      {
        v8 = 0;
        if ( v7 > 0 )
        {
          do
          {
            v22[v8] = ListView_GetSlotCountEx((int)v4, 1, v8);
            ++v8;
          }
          while ( v8 < *((_DWORD *)v4 + 32) );
        }
      }
      SetRectEmpty(&rc);
      v9 = *((_DWORD *)v4 + 93) == 0;
      v10 = *((_DWORD *)v4 + 93) < 0;
      v34 = 0;
      i = 0;
      if ( !v10 && !v9 )
      {
        do
        {
          v11 = DPA_GetPtr(hdpa, i);
          v12 = (int)v11;
          v13 = *((_WORD *)v11 + 11);
          if ( v13 == a4 )
          {
            if ( *((_DWORD *)v4 + 32) <= 0 )
              v14 = v27;
            else
              v14 = v22[v13];
            if ( v30 || v29 )
            {
              for ( j = &rcSrc1; ; j = &rcSrc1 )
              {
                _CalcSlotRect((int)v4, v12, v34, v14, 0, j);
                if ( !IntersectRect(&rcDst, &rcSrc1, &rc) )
                  break;
                ++v34;
              }
            }
            hdca = (HDC)(ListView_SetIconPos((int)v4, v12, v34++, v14) | (unsigned int)hdca);
            _ListView_GetRectsFromItem((int)v4, v30, v12, &v24, &rcSrc2, &rc, 0);
            if ( v29
              && ListView_IsItemUnfoldedPtr((int)v4, v12)
              && (ListView_RefoldLabelRect((int)v4, (int)&rcSrc2, v12),
                  UnionRect(&rc, &v24, &rcSrc2),
                  *((_DWORD *)v4 + 88))
              && *(_WORD *)(v12 + 24) & 0xF000 )
            {
              v15 = rc.left - *((_DWORD *)v4 + 89);
              rc.left -= *((_DWORD *)v4 + 89);
            }
            else
            {
              v15 = rc.left;
            }
            if ( v15 < v31 )
              v31 = v15;
          }
          ++i;
        }
        while ( i < *((_DWORD *)v4 + 93) );
        v16 = v31;
        if ( v31 < 0 )
        {
          for ( k = 0; k < *((_DWORD *)v4 + 93); ++k )
          {
            v18 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 10) + 4) + 4 * k);
            *(_DWORD *)(v18 + 4) -= v16;
          }
          *((_DWORD *)v4 + 57) = 0x7FFFFFFF;
          hdca = (HDC)1;
        }
      }
    }
  }
  if ( hdca )
  {
    if ( (*((_BYTE *)v4 + 44) & 0x12) == 18 )
    {
      RedrawWindow(*(HWND *)v4, 0, 0, 5u);
    }
    else
    {
      ListView_DeleteHrgnInval((int)v4);
      *((_DWORD *)v4 + 11) |= 4u;
      *((_DWORD *)v4 + 37) = 1;
    }
    v19 = *((_DWORD *)v4 + 25);
    if ( v19 >= 0 || (v19 = ListView_OnGetNextItem(v4, -1, 2), v19 >= 0) )
      ListView_OnEnsureVisible(v4, v19, 0);
    if ( (*((_BYTE *)v4 + 44) & 0x12) == 18 )
      ListView_UpdateScrollBars(v4);
  }
  return 1;
}
// 6F7CE913: using guessed type int var_A4[16];

//----- (6F7CEBA0) --------------------------------------------------------
int __stdcall ListView_CommonArrange(HDC hdc, int a2, HDPA hdpa)
{
  signed int v3; // eax@1
  int v5; // edi@4

  v3 = *((_DWORD *)hdc + 32);
  if ( v3 >= 1 )
  {
    v5 = 0;
    if ( v3 > 0 )
    {
      do
        ListView_CommonArrangeEx(hdc, a2, hdpa, v5++);
      while ( v5 < *((_DWORD *)hdc + 32) );
    }
  }
  else if ( !(*((_DWORD *)hdc + 12) & 0x2000) )
  {
    return ListView_CommonArrangeEx(hdc, a2, hdpa, 0);
  }
  return 1;
}

//----- (6F7CEBF8) --------------------------------------------------------
int __stdcall ListView_OnArrange(HDC hdc, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v6; // eax@10
  int v7; // eax@13
  int v8; // eax@17
  struct _DPA *hdpa; // [sp+8h] [bp-4h]@1

  hdpa = 0;
  v2 = *((_DWORD *)hdc + 2);
  v3 = *((_DWORD *)hdc + 2) & 3;
  v4 = v3 == 2;
  if ( v3 != 2 && v3 )
    return 0;
  if ( v2 & 0x1000 && a2 & 0x305 )
    return 0;
  if ( *((_DWORD *)hdc + 57) == 0x7FFFFFFF )
    ListView_Recompute((int)hdc);
  if ( !(*((_DWORD *)hdc + 2) & 0x1000) )
  {
    hdpa = DPA_Clone(*((const HDPA *)hdc + 10), 0);
    if ( !hdpa )
      return 0;
  }
  v6 = *((_DWORD *)hdc + 2) & 0xC00;
  if ( v6 == 2048 || v6 == 3072 )
  {
    if ( v4 )
      v8 = *((_DWORD *)hdc + 46);
    else
      v8 = *((_DWORD *)hdc + 49);
    v7 = (unsigned __int16)v8 | 0x10000;
  }
  else
  {
    if ( v4 )
      v7 = *((_DWORD *)hdc + 47);
    else
      v7 = *((_DWORD *)hdc + 50);
    v7 = (unsigned __int16)v7;
  }
  if ( !(*((_DWORD *)hdc + 2) & 0x1000) )
  {
    if ( DPA_Sort(hdpa, ArrangeIconCompare, v7) )
    {
      ListView_CommonArrange(hdc, a2, hdpa);
      DPA_Destroy(hdpa);
      goto LABEL_25;
    }
    return 0;
  }
  ListView_CommonArrange(hdc, a2, 0);
LABEL_25:
  MyNotifyWinEvent(32772, *(_DWORD *)hdc, -4, 0);
  return 1;
}

//----- (6F7CED07) --------------------------------------------------------
int __stdcall ListView_ScaleIconPositions(HDC hdc, int a2)
{
  HDC v2; // esi@1
  int result; // eax@1
  bool v4; // zf@5
  int v5; // ebx@7
  int v6; // eax@9
  int v7; // ecx@9
  int v8; // eax@9
  int v9; // eax@14
  int *v10; // ebx@15
  int v11; // eax@16
  int v12; // eax@18
  HWND v13; // ST00_4@18
  int v14; // [sp-Ch] [bp-1Ch]@16
  int v15; // [sp-8h] [bp-18h]@16
  int nDenominator; // [sp+8h] [bp-8h]@5
  int nNumerator; // [sp+Ch] [bp-4h]@5
  HDC hdca; // [sp+18h] [bp+8h]@6

  v2 = hdc;
  result = *((_DWORD *)hdc + 11);
  if ( a2 )
  {
    if ( result & 0x20 )
      return result;
  }
  else if ( !(result & 0x20) )
  {
    return result;
  }
  v4 = (*((_DWORD *)hdc + 2) & 0x1000) == 0;
  *((_DWORD *)hdc + 11) = result ^ 0x20;
  nNumerator = *((_DWORD *)hdc + 46);
  nDenominator = *((_DWORD *)hdc + 47);
  if ( !v4 )
    goto LABEL_21;
  hdca = 0;
  if ( *((_DWORD *)v2 + 93) > 0 )
  {
    do
    {
      v5 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v2 + 10) + 4) + 4 * (_DWORD)hdca);
      if ( *(_DWORD *)(v5 + 8) != 0x7FFFFFFF )
      {
        if ( a2 )
        {
          v6 = MulDiv(*(_DWORD *)(v5 + 4) - (g_cxIconSpacing - g_cxIcon) / 2, nNumerator, *((_DWORD *)v2 + 49));
          v7 = *(_DWORD *)(v5 + 8);
          *(_DWORD *)(v5 + 4) = v6;
          v8 = MulDiv(v7 - 2 * g_cyBorder, nDenominator, *((_DWORD *)v2 + 50));
        }
        else
        {
          *(_DWORD *)(v5 + 4) = (g_cxIconSpacing - g_cxIcon) / 2
                              + MulDiv(*(_DWORD *)(v5 + 4), *((_DWORD *)v2 + 49), nNumerator);
          v8 = MulDiv(*(_DWORD *)(v5 + 8), *((_DWORD *)v2 + 50), nDenominator) + 2 * g_cyBorder;
        }
        *(_DWORD *)(v5 + 8) = v8;
      }
      hdca = (HDC)((char *)hdca + 1);
    }
    while ( (signed int)hdca < *((_DWORD *)v2 + 93) );
  }
  *((_DWORD *)v2 + 61) = -1;
  if ( *((_DWORD *)v2 + 2) & 0x100 )
  {
    v9 = LV_GetNewColWidth((int)v2, 0, *((_DWORD *)v2 + 93) - 1);
    ListView_ISetColumnWidth((int)v2, 0, v9, 0);
    result = ListView_OnArrange(v2, 0);
  }
  else
  {
LABEL_21:
    *((_DWORD *)v2 + 57) = 0x7FFFFFFF;
    v10 = (int *)(v2 + 55);
    if ( a2 )
    {
      v11 = MulDiv(*v10, nNumerator, *((_DWORD *)v2 + 49));
      v15 = *((_DWORD *)v2 + 50);
      v14 = nDenominator;
    }
    else
    {
      v11 = MulDiv(*v10, *((_DWORD *)v2 + 49), nNumerator);
      v15 = nDenominator;
      v14 = *((_DWORD *)v2 + 50);
    }
    *v10 = v11;
    v12 = MulDiv(*((_DWORD *)v2 + 56), v14, v15);
    v13 = *(HWND *)v2;
    *((_DWORD *)v2 + 56) = v12;
    result = RedrawWindow(v13, 0, 0, 5u);
  }
  return result;
}
// 6F7E6990: using guessed type int g_cxIconSpacing;
// 6F7E69A0: using guessed type int g_cxIcon;

//----- (6F7CEEB5) --------------------------------------------------------
int __stdcall TV_DrawDescender(int a1, HDC hdc, int x, int a4, int a5)
{
  signed int v5; // ebx@1
  int result; // eax@1

  v5 = 1;
  result = 1;
  if ( *(_WORD *)(a5 + 32) > 1u )
  {
    do
    {
      BitBlt(
        hdc,
        x,
        a4 + v5 * *(_WORD *)(a1 + 182),
        *(_WORD *)(a1 + 188),
        *(_WORD *)(a1 + 182),
        *(HDC *)(a1 + 140),
        0,
        0,
        0xCC0020u);
      result = *(_WORD *)(a5 + 32);
      ++v5;
    }
    while ( v5 < result );
  }
  return result;
}

//----- (6F7CEF15) --------------------------------------------------------
int __stdcall TV_EraseDescender(int a1, HDC hDC, int a3, int a4, int a5)
{
  int v5; // edx@1
  HBRUSH v6; // ST08_4@1
  int v7; // ecx@1
  RECT rc; // [sp+4h] [bp-10h]@1

  v5 = *(_WORD *)(a1 + 188);
  v6 = *(HBRUSH *)(a1 + 112);
  rc.left = a3;
  v7 = *(_WORD *)(a1 + 182);
  rc.right = a3 + v5;
  rc.top = v7 + a4;
  rc.bottom = a4 + v7 * *(_WORD *)(a5 + 32);
  return FillRect(hDC, &rc, v6);
}

//----- (6F7CEF6C) --------------------------------------------------------
int __stdcall TV_DrawKinDescender(int a1, HDC hdc, int x, int a4, int a5, char a6)
{
  int result; // eax@2
  int v7; // [sp-Ch] [bp-14h]@6

  if ( *(_DWORD *)(a5 + 4) )
    result = TV_DrawDescender(a1, hdc, x, a4, a5);
  else
    result = TV_EraseDescender(a1, hdc, x, a4, a5);
  if ( *(_DWORD *)(a1 + 88) || *(_DWORD *)(a1 + 84) )
  {
    v7 = x + *(_WORD *)(a1 + 188);
    if ( a6 & 0xA0 )
      result = TV_DrawDescender(a1, hdc, v7, a4, a5);
    else
      result = TV_EraseDescender(a1, hdc, v7, a4, a5);
  }
  return result;
}

//----- (6F7CEFD2) --------------------------------------------------------
COLORREF __stdcall TV_GetInsertMarkColor(int a1)
{
  COLORREF result; // eax@1

  result = *(_DWORD *)(a1 + 168);
  if ( result == -16777216 )
    result = g_clrWindowText;
  return result;
}

//----- (6F7CEFF5) --------------------------------------------------------
HGDIOBJ __stdcall TV_CreateDragImage(HDC hdc, int a2)
{
  int v2; // edi@1
  int v3; // eax@1
  HGDIOBJ result; // eax@2
  int v5; // esi@5
  int v6; // eax@5
  HIMAGELIST v7; // eax@16
  struct _IMAGELIST *v8; // esi@16
  void *v9; // ecx@17
  __int64 v10; // rax@17
  char v11; // [sp+8h] [bp-44h]@17
  int v12; // [sp+20h] [bp-2Ch]@17
  HGDIOBJ v13; // [sp+34h] [bp-18h]@1
  int w; // [sp+38h] [bp-14h]@5
  int v15; // [sp+3Ch] [bp-10h]@1
  HGDIOBJ h; // [sp+40h] [bp-Ch]@6
  int cy; // [sp+44h] [bp-8h]@5
  HGDIOBJ ho; // [sp+48h] [bp-4h]@1
  HDC hdca; // [sp+54h] [bp+8h]@5

  v2 = (int)hdc;
  v3 = *((_DWORD *)hdc + 6) & 0x400000;
  ho = 0;
  v13 = 0;
  v15 = v3;
  if ( *((_DWORD *)hdc + 21) && (a2 || (a2 = *((_DWORD *)hdc + 19)) != 0) )
  {
    v5 = *(_WORD *)(a2 + 26) + *((_WORD *)hdc + 88);
    v6 = *((_WORD *)hdc + 91);
    w = *(_WORD *)(a2 + 26) + *((_WORD *)hdc + 88);
    cy = v6;
    hdca = CreateCompatibleDC(0);
    if ( hdca )
    {
      h = CreateColorBitmap(v5, cy);
      if ( h )
      {
        ho = CreateMonoBitmap(v5, cy);
        if ( ho )
        {
          if ( v15 )
            SetLayout(hdca, 1u);
          if ( *(_DWORD *)(v2 + 116) )
            SelectObject(hdca, *(HGDIOBJ *)(v2 + 116));
          SetBkMode(hdca, 1);
          v13 = SelectObject(hdca, h);
          PatBlt(hdca, 0, 0, w, cy, 0x42u);
          TV_DrawItem(v2, a2, (int)hdca, 0, 0, 7);
          if ( v15 )
            MirrorBitmapInDC(hdca, h);
          SelectObject(hdca, ho);
          PatBlt(hdca, 0, 0, w, cy, 0xFF0062u);
          TV_DrawItem(v2, a2, (int)hdca, 0, 0, 7);
          if ( v15 )
            MirrorBitmapInDC(hdca, ho);
          SelectObject(hdca, v13);
          SelectObject(hdca, g_hfontSystem);
          v7 = ImageList_Create(w, cy, 1u, 1, 0);
          v8 = v7;
          v13 = (HGDIOBJ)v7;
          if ( v7 )
          {
            ImageList_SetBkColor(v7, 0xFFFFFFFF);
            ImageList_Add(v8, (HBITMAP)h, (HBITMAP)ho);
            TV_GetItem(v2, a2, 2, (int)&v11);
            v9 = (void *)*(_WORD *)(v2 + 178);
            v10 = *(_WORD *)(v2 + 182) - (signed int)v9;
            ImageList_CopyDitherImage(
              v9,
              (struct _IMAGELIST *)v13,
              0,
              0,
              ((signed int)v10 - HIDWORD(v10)) >> 1,
              *(struct _IMAGELIST **)(v2 + 84),
              v12,
              (*(_DWORD *)(v2 + 24) >> 15) & 0x80 | *(_WORD *)(a2 + 20) & 0xF00);
          }
        }
      }
      DeleteObject(hdca);
      if ( h )
        DeleteObject(h);
      if ( ho )
        DeleteObject(ho);
    }
    result = v13;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7CF1EE) --------------------------------------------------------
int __stdcall TV_GenerateDragImage(HDC hdc, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  HDC v5; // eax@3
  HDC v6; // ebx@3
  int v7; // ST10_4@6
  int v8; // eax@6
  HBITMAP v9; // eax@6
  LONG v10; // ecx@7
  int v11; // eax@8
  int v12; // ST04_4@10
  HGDIOBJ v13; // ST14_4@10
  RECT rect; // [sp+8h] [bp-28h]@7
  int v15; // [sp+18h] [bp-18h]@6
  int v16; // [sp+1Ch] [bp-14h]@6
  int v17; // [sp+20h] [bp-10h]@6
  int v18; // [sp+24h] [bp-Ch]@6
  HGDIOBJ h; // [sp+28h] [bp-8h]@7
  int v20; // [sp+2Ch] [bp-4h]@1
  HDC hdca; // [sp+38h] [bp+8h]@3
  int v22; // [sp+3Ch] [bp+Ch]@10

  v2 = (int)hdc;
  v3 = *((_DWORD *)hdc + 19);
  v20 = v3;
  if ( v3 )
  {
    v5 = CreateCompatibleDC(0);
    v6 = v5;
    hdca = v5;
    if ( !v5 )
      goto LABEL_14;
    if ( *(_DWORD *)(v2 + 24) & 0x400000 )
      SetLayout(v5, 1u);
    TV_GetItemRect(v2, v3, (int)&v15, 1);
    v15 -= *(_WORD *)(v2 + 176);
    *(_DWORD *)a2 = v17 - v15;
    *(_DWORD *)(a2 + 4) = v18 - v16;
    v7 = GetDeviceCaps(v6, 12);
    v8 = GetDeviceCaps(hdca, 14);
    v9 = CreateBitmap(*(_DWORD *)a2, *(_DWORD *)(a2 + 4), v8, v7, 0);
    *(_DWORD *)(a2 + 16) = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)a2;
      rect.left = 0;
      rect.top = 0;
      rect.right = v10;
      rect.bottom = *(_DWORD *)(a2 + 4);
      h = SelectObject(hdca, v9);
      *(_DWORD *)(a2 + 20) = 244;
      FillRectClr(hdca, &rect, 0xF4u);
      if ( *(_DWORD *)(v2 + 24) & 0x400000 )
        v11 = v17 - *(_DWORD *)(v2 + 152);
      else
        v11 = *(_DWORD *)(v2 + 152) - v15;
      *(_DWORD *)(a2 + 8) = v11;
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(v2 + 156) - v16;
      v12 = v20;
      v22 = *(_DWORD *)(v2 + 164);
      *(_DWORD *)(v2 + 164) = 244;
      TV_DrawItem(v2, v12, (int)hdca, 0, 0, 198);
      v13 = h;
      *(_DWORD *)(v2 + 164) = v22;
      SelectObject(hdca, v13);
      DeleteDC(hdca);
      result = 1;
    }
    else
    {
LABEL_14:
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7CF33B) --------------------------------------------------------
int __stdcall TV_GetNext(int a1)
{
  int v1; // ecx@1
  int result; // eax@1

  v1 = a1;
  result = *(_DWORD *)(a1 + 8);
  if ( !result )
  {
    while ( !*(_DWORD *)(v1 + 4) )
    {
      v1 = *(_DWORD *)v1;
      if ( !v1 )
        return 0;
    }
    result = *(_DWORD *)(v1 + 4);
  }
  return result;
}

//----- (6F7CF366) --------------------------------------------------------
int __stdcall TV_VertScroll(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int result; // eax@2
  int v6; // ebx@3
  int v7; // eax@10
  int v8; // esi@11

  v3 = *(_DWORD *)(a1 + 208);
  v4 = 0;
  if ( v3 )
  {
    v6 = *(_WORD *)(v3 + 28);
    TV_DismissEdit(a1, 0);
    switch ( a2 )
    {
      case 7:
        v4 = *(_DWORD *)(a1 + 200) - *(_WORD *)(a1 + 196);
        goto LABEL_10;
      case 8:
        v4 = v6;
        goto LABEL_10;
      case 1:
        v4 = v6 + *(_WORD *)(*(_DWORD *)(a1 + 208) + 32);
        goto LABEL_10;
      case 0:
        v4 = v6 - 1;
        goto LABEL_8;
      case 6:
        goto LABEL_9;
      case 3:
        v4 = *(_WORD *)(a1 + 196) + v6 - 1;
        goto LABEL_10;
      case 2:
        v4 = v6 - *(_WORD *)(a1 + 196) + 1;
LABEL_8:
        if ( v4 > (unsigned int)v6 )
LABEL_9:
          v4 = 0;
        goto LABEL_10;
      case 4:
      case 5:
        v7 = TV_SmoothSetTopItem(a1, a3, 0x20000);
        break;
      default:
LABEL_10:
        v7 = TV_SmoothSetTopItem(a1, v4, 0);
        break;
    }
    v8 = v7;
    if ( v7 )
      UpdateWindow(*(HWND *)a1);
    result = v8;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7CF43C) --------------------------------------------------------
int __stdcall TV_CompareItems(int a1, int a2, int a3)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(a3 + 4))(
           *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16),
           *(_DWORD *)(*(_DWORD *)(a2 + 8) + 16),
           *(_DWORD *)(a3 + 8));
}

//----- (6F7CF465) --------------------------------------------------------
int __stdcall TV_SortChildrenCB(int a1, LPARAM a2, int a3)
{
  return TV_SortCB(a1, a2, a3, (int (__stdcall *)(void *, void *, LPARAM))TV_CompareItems);
}

//----- (6F7CF486) --------------------------------------------------------
signed int __stdcall TV_ScrollBarsAfterRemove(int a1, int a2)
{
  signed int result; // eax@2
  int v3; // ebx@3

  if ( *(_WORD *)(a2 + 28) == -1 )
  {
    result = 0;
  }
  else
  {
    *(_WORD *)(a2 + 28) = -1;
    v3 = TV_GetNextVisItem(a2);
    if ( v3 )
    {
      *(_WORD *)(v3 + 28) -= *(_WORD *)(a2 + 32);
      TV_UpdateShownIndexes(a1, v3);
      if ( *(_DWORD *)(a1 + 208) == a2 )
        TV_SmoothSetTopItem(a1, *(_WORD *)(v3 + 28), 0);
    }
    *(_DWORD *)(a1 + 200) -= *(_WORD *)(a2 + 32);
    if ( *(_BYTE *)(a1 + 36) & 0x10 )
    {
      if ( !*(_WORD *)(a2 + 26) )
        TV_ComputeItemWidth(a1, a2, 0);
      if ( !(*(_DWORD *)(a1 + 8) & 0x2000) && *(_WORD *)(a1 + 194) == *(_WORD *)(a2 + 26) + ITEM_OFFSET(a1, a2) )
        *(_WORD *)(a1 + 194) = TV_RecomputeMaxWidth(a1);
      TV_CalcScrollBars(a1);
    }
    result = 1;
  }
  return result;
}

//----- (6F7CF53F) --------------------------------------------------------
signed int __stdcall TV_ScrollBarsAfterCollapse(int a1, int a2)
{
  return TV_ScrollBarsAfterExpandCollapse(a1, a2, 0);
}

//----- (6F7CF55A) --------------------------------------------------------
int __stdcall TV_ScrollBarsAfterResize(int a1, int a2, int a3, UINT flags)
{
  int v4; // ebx@1
  int v5; // eax@1
  int v6; // ecx@4
  int result; // eax@6
  RECT rcUpdate; // [sp+Ch] [bp-10h]@7

  v4 = a3;
  v5 = *(_WORD *)(a2 + 32);
  if ( v5 > a3 )
    v4 = *(_WORD *)(a2 + 32);
  if ( *(_BYTE *)(a1 + 36) & 0x10 )
  {
    v6 = *(_WORD *)(a2 + 28) - *(_WORD *)(*(_DWORD *)(a1 + 208) + 28) + v4 - 1;
    if ( v6 >= 0 )
      TV_ScrollItems(a1, abs(v5 - a3), v6, v5 - a3 > 0);
  }
  *(_DWORD *)(a1 + 200) = TV_UpdateShownIndexes(a1, a2);
  result = TV_CalcScrollBars(a1);
  if ( *(_BYTE *)(a1 + 36) & 0x10 )
  {
    result = TV_GetItemRect(a1, a2, (int)&rcUpdate, 0);
    if ( result )
    {
      rcUpdate.bottom = rcUpdate.top + v4 * *(_WORD *)(a1 + 182);
      result = RedrawWindow(*(HWND *)a1, &rcUpdate, 0, flags);
    }
  }
  return result;
}

//----- (6F7CF605) --------------------------------------------------------
int __stdcall TV_DeleteItemRecurse(int a1, LPVOID lpMem, int a3)
{
  int v3; // esi@1
  int v4; // ebx@1
  int result; // eax@3
  int v6; // ecx@9
  int v7; // eax@10
  int v8; // eax@29
  LPARAM lParam; // [sp+Ch] [bp-68h]@8
  int v10; // [sp+1Ch] [bp-58h]@8
  LPVOID v11; // [sp+20h] [bp-54h]@8
  int v12; // [sp+40h] [bp-34h]@8
  int v13; // [sp+44h] [bp-30h]@8
  int lpMema; // [sp+80h] [bp+Ch]@14

  v3 = (int)lpMem;
  MyNotifyWinEvent(32769, *(_DWORD *)a1, -4, (int)lpMem);
  v4 = 0;
  if ( lpMem == *(LPVOID *)(a1 + 68) )
    TV_SetInsertMark(a1, 0, 0);
  result = *((_DWORD *)lpMem + 2);
  if ( result )
  {
    do
    {
      v4 = *(_DWORD *)(result + 4);
      TV_DeleteItemRecurse(a1, (LPVOID)result, a3 & 0xFFFFFFFD);
      result = v4;
    }
    while ( v4 );
  }
  if ( !(a3 & 2) && *(_DWORD *)lpMem != v4 )
  {
    if ( !(a3 & 1) )
    {
      v12 = *((_DWORD *)lpMem + 4);
      v11 = lpMem;
      v13 = v4;
      v10 = 20;
      CCSendNotify(a1, -458, (LPARAM)&lParam);
    }
    v6 = **(_DWORD **)(a1 + 80);
    while ( 1 )
    {
      --v6;
      if ( v6 < 0 )
        break;
      v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 80) + 4) + 4 * v6);
      if ( *(LPVOID *)v7 == lpMem )
      {
        *(_DWORD *)v7 = *((_DWORD *)lpMem + 1);
        *(_DWORD *)(v7 + 4) = 1;
      }
    }
    if ( *(LPVOID *)(*(_DWORD *)lpMem + 8) == lpMem )
    {
      *(_DWORD *)(*(_DWORD *)lpMem + 8) = *((_DWORD *)lpMem + 1);
      lpMema = v4;
    }
    else
    {
      lpMema = TV_GetNextItem(a1, (int)lpMem, 2);
      *(_DWORD *)(lpMema + 4) = *(_DWORD *)(v3 + 4);
    }
    --*(_DWORD *)(a1 + 204);
    TV_ScrollBarsAfterRemove(a1, v3);
    if ( *(_DWORD *)(a1 + 64) == v3 )
      TV_SetToolTipTarget(a1, v4);
    Str_Set(v3 + 12, (LPCWSTR)v4);
    *(_WORD *)(v3 + 34) = 0;
    if ( v3 == *(_DWORD *)(a1 + 56) )
      *(_DWORD *)(a1 + 56) = v4;
    if ( v3 == *(_DWORD *)(a1 + 48) )
      *(_DWORD *)(a1 + 48) = v4;
    if ( v3 == *(_DWORD *)(a1 + 52) )
      *(_DWORD *)(a1 + 52) = v4;
    if ( v3 == *(_DWORD *)(a1 + 60) )
      *(_DWORD *)(a1 + 60) = v4;
    if ( v3 == *(_DWORD *)(a1 + 72) )
      *(_DWORD *)(a1 + 72) = v4;
    if ( *(_DWORD *)(a1 + 44) == v3 )
    {
      v8 = *(_DWORD *)(v3 + 4);
      if ( v8 == v4 )
      {
        if ( !*(_BYTE *)(v3 + 30) || (v8 = *(_DWORD *)v3, *(_DWORD *)v3 == v4) )
          v8 = lpMema;
      }
      *(_DWORD *)(a1 + 44) = v4;
      TV_SelectItem(a1, 9, v8, ~(unsigned __int8)((unsigned int)a3 >> 2) & 1, v4);
    }
    result = HeapFree(*(HANDLE *)(a1 + 148), v4, (LPVOID)v3);
  }
  return result;
}

//----- (6F7CF777) --------------------------------------------------------
int __stdcall TV_DeleteItem(int a1, LPVOID lpMem, int a3)
{
  int v3; // edi@1
  int result; // eax@4
  int i; // eax@7
  int v6; // eax@11
  int v7; // ecx@11
  int v8; // eax@19
  int lpMema; // [sp+18h] [bp+Ch]@10

  v3 = (int)lpMem;
  if ( lpMem == (LPVOID)-65536 || !lpMem )
    v3 = *(_DWORD *)(a1 + 40);
  result = ValidateTreeItem(v3, 0);
  if ( result )
  {
    if ( v3 == *(_DWORD *)(a1 + 40) )
    {
      for ( i = *(_DWORD *)(v3 + 8); ; i = *(_DWORD *)(lpMema + 4) )
      {
        lpMema = i;
        if ( i )
        {
          TV_Expand(a1, 1u, i, 0);
          if ( ValidateTreeItem(lpMema, 0) )
            continue;
        }
        break;
      }
    }
    else
    {
      TV_Expand(a1, 1u, v3, 0);
    }
    v6 = *(_DWORD *)v3;
    v7 = *(_DWORD *)(a1 + 40);
    if ( *(_DWORD *)v3 == v7 || v3 == v7 || *(_WORD *)(v6 + 28) != -1 )
    {
      if ( *(_BYTE *)(a1 + 36) & 0x10 )
        InvalidateRect(*(HWND *)a1, 0, 1);
    }
    else
    {
      TV_ScrollBelow(a1, v6, 0, 0);
    }
    if ( v3 == *(_DWORD *)(a1 + 40) )
      a3 |= 2u;
    TV_DeleteItemRecurse(a1, (LPVOID)v3, a3);
    v8 = *(_DWORD *)(a1 + 40);
    if ( !*(_DWORD *)(v8 + 8) )
    {
      *(_DWORD *)(a1 + 36) &= 0xFFFFFFF7;
      *(_DWORD *)(a1 + 204) = 0;
      *(_DWORD *)(a1 + 208) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      *(_WORD *)(a1 + 194) = 0;
      *(_WORD *)(a1 + 198) = 0;
      *(_DWORD *)(v8 + 4) = 0;
      **(_DWORD **)(a1 + 40) = 0;
      *(_DWORD *)(*(_DWORD *)(a1 + 40) + 8) = 0;
      *(_WORD *)(*(_DWORD *)(a1 + 40) + 20) |= 0x60u;
      *(_BYTE *)(*(_DWORD *)(a1 + 40) + 30) = -1;
      *(_WORD *)(*(_DWORD *)(a1 + 40) + 28) = -1;
    }
    result = 1;
  }
  return result;
}

//----- (6F7CF88B) --------------------------------------------------------
LONG __stdcall TV_DestroyTree(HLOCAL hMem)
{
  int v1; // esi@1
  HWND v2; // eax@1
  HDC v3; // ST08_4@1
  HWND *v4; // edi@3
  HWND *v5; // edi@5
  void *v6; // ST04_4@7
  int v7; // eax@7
  HDC v8; // eax@9
  HWND hMema; // [sp+10h] [bp+8h]@1

  v1 = (int)hMem;
  v2 = *(HWND *)hMem;
  *(_DWORD *)(v1 + 36) &= 0xFFFFFFEF;
  v3 = (HDC)hMem;
  hMema = v2;
  TV_OnSetBkColor(v3, 0xFFFFFFFF);
  if ( *(_DWORD *)(v1 + 92) )
    DestroyCursor(*(HCURSOR *)(v1 + 92));
  v4 = (HWND *)(v1 + 224);
  if ( IsWindow(*(HWND *)(v1 + 224)) )
    DestroyWindow(*v4);
  *v4 = 0;
  v5 = (HWND *)(v1 + 216);
  if ( IsWindow(*(HWND *)(v1 + 216)) )
    DestroyWindow(*v5);
  v6 = *(void **)(v1 + 40);
  *v5 = 0;
  TV_DeleteItem(v1, v6, 6);
  v7 = *(_DWORD *)(v1 + 40);
  if ( v7 )
  {
    Str_Set(v7 + 12, 0);
    HeapFree(*(HANDLE *)(v1 + 148), 0, *(LPVOID *)(v1 + 40));
  }
  v8 = *(HDC *)(v1 + 140);
  if ( v8 )
  {
    if ( *(_DWORD *)(v1 + 136) )
    {
      SelectObject(v8, *(HGDIOBJ *)(v1 + 132));
      DeleteObject(*(HGDIOBJ *)(v1 + 136));
    }
    DeleteDC(*(HDC *)(v1 + 140));
  }
  if ( *(_BYTE *)(v1 + 36) & 0x40 && *(_DWORD *)(v1 + 116) )
    DeleteObject(*(HGDIOBJ *)(v1 + 116));
  if ( *(_DWORD *)(v1 + 124) )
    DeleteObject(*(HGDIOBJ *)(v1 + 124));
  Str_Set(v1 + 228, 0);
  if ( *(_DWORD *)(v1 + 232) )
    LocalFree(*(HLOCAL *)(v1 + 232));
  TV_DeleteHotFonts(v1);
  if ( *(_DWORD *)(v1 + 80) )
    DPA_Destroy(*(HDPA *)(v1 + 80));
  if ( *(_DWORD *)(v1 + 240) )
    Free(*(HLOCAL *)(v1 + 240));
  LocalFree((HLOCAL)v1);
  return SetWindowLongW(hMema, 0, 0);
}

//----- (6F7CF9CC) --------------------------------------------------------
LRESULT __stdcall TV_CreateToolTips(int a1)
{
  DWORD v1; // ecx@1
  LRESULT result; // eax@3
  int v3; // ecx@4
  LPARAM lParam; // [sp+8h] [bp-2Ch]@4
  int v5; // [sp+Ch] [bp-28h]@4
  int v6; // [sp+10h] [bp-24h]@4
  int v7; // [sp+14h] [bp-20h]@4
  int v8; // [sp+2Ch] [bp-8h]@4
  int v9; // [sp+30h] [bp-4h]@4

  v1 = 0;
  if ( *(_BYTE *)(a1 + 8) & 0x40 )
    v1 = 0x2000;
  result = (LRESULT)CreateWindowExW(
                      v1,
                      L"tooltips_class32",
                      0,
                      0x80000002,
                      2147483648,
                      2147483648,
                      2147483648,
                      2147483648,
                      *(HWND *)a1,
                      0,
                      g_hinst,
                      0);
  *(_DWORD *)(a1 + 224) = result;
  if ( result )
  {
    v3 = *(_DWORD *)a1;
    v8 = -1;
    v6 = v3;
    v7 = v3;
    v9 = 0;
    lParam = 44;
    v5 = 257;
    SendMessageW((HWND)result, 0x432u, 0, (LPARAM)&lParam);
    SendMessageW(*(HWND *)(a1 + 224), 0x30u, *(_DWORD *)(a1 + 116), 1);
    result = SendMessageW(*(HWND *)(a1 + 224), 0x403u, 3u, 500);
  }
  else
  {
    *(_DWORD *)(a1 + 8) |= 0x80u;
  }
  return result;
}

//----- (6F7CFA7E) --------------------------------------------------------
int __stdcall ListView_LApproximateViewRect(int a1, int a2, int a3, signed int a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1

  v4 = *(_DWORD *)(a1 + 188);
  v5 = *(_DWORD *)(a1 + 184);
  v6 = a4 / v4;
  if ( a4 / v4 >= a2 )
    v6 = a2;
  if ( !v6 )
    v6 = 1;
  return ((unsigned __int16)(g_cyEdge + v6 * v4) << 16) | (unsigned __int16)(g_cxEdge + v5 * ((a2 + v6 - 1) / v6));
}

//----- (6F7CFAD9) --------------------------------------------------------
int __stdcall ListView_LItemHitTest(int a1, int a2, signed int a3, int a4, int a5)
{
  int v5; // eax@3
  int v6; // ebx@4
  int v7; // ecx@5
  signed int v8; // edi@5
  int v9; // eax@5
  int v10; // ebx@5
  int v11; // edx@5
  int v12; // edi@7
  int v13; // eax@7
  int v14; // ebx@7
  int v15; // eax@12
  int v16; // edi@13
  char v18; // [sp+0h] [bp-40h]@12
  __int16 v19; // [sp+Eh] [bp-32h]@12
  int v20; // [sp+3Ch] [bp-4h]@3
  int v21; // [sp+50h] [bp+10h]@3
  signed int v22; // [sp+58h] [bp+18h]@3

  if ( a5 )
    *(_DWORD *)a5 = 0;
  v5 = a3 / *(_DWORD *)(a1 + 188);
  v20 = -1;
  v22 = 1;
  v21 = v5;
  if ( v5 >= 0 )
  {
    v6 = *(_DWORD *)(a1 + 192);
    if ( v5 < v6 )
    {
      v7 = *(_DWORD *)(a1 + 180);
      v8 = *(_DWORD *)(a1 + 184);
      v9 = (v7 + a2) / v8;
      v10 = v9 * v6;
      v11 = v10 + v21;
      if ( v10 + v21 >= 0 && v11 < *(_DWORD *)(a1 + 372) )
      {
        v12 = v9 * v8;
        v13 = *(_DWORD *)(a1 + 356);
        v20 = v10 + v21;
        v14 = a2 + v7 - v12;
        if ( v14 >= v13 )
        {
          if ( v14 >= v13 + *(_DWORD *)(a1 + 172) )
          {
            if ( *(_DWORD *)(a1 + 8) & 0x1000 )
            {
              ListView_RecomputeLabelSize(a1, (int)&v18, v11, 0, 0);
              v15 = v19;
            }
            else
            {
              v16 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v11);
              if ( *(_WORD *)(v16 + 14) == 0x7FFF )
                ListView_RecomputeLabelSize(a1, v16, v11, 0, 0);
              v15 = *(_WORD *)(v16 + 14);
            }
            if ( v14 < *(_DWORD *)(a1 + 172) + v15 + *(_DWORD *)(a1 + 356) )
              v22 = 4;
          }
          else
          {
            v22 = 2;
          }
        }
        else
        {
          v22 = 8;
        }
      }
    }
  }
  *(_DWORD *)a4 = v22;
  return v20;
}

//----- (6F7CFBF4) --------------------------------------------------------
int __stdcall ListView_LGetRects(HDC a1, signed int a2, int a3, int a4, int a5, int a6)
{
  HDC v6; // esi@1
  signed int v7; // ecx@1
  int v8; // edx@4
  int v9; // ecx@4
  int v10; // eax@4
  int v11; // edx@4
  int v12; // edi@5
  int v13; // edi@7
  int result; // eax@10
  int v15; // [sp+14h] [bp-18h]@4
  int v16; // [sp+18h] [bp-14h]@4
  int v17; // [sp+20h] [bp-Ch]@6
  int v18; // [sp+24h] [bp-8h]@6

  v6 = a1 + 48;
  v7 = *((_DWORD *)a1 + 48);
  if ( !v7 )
  {
    ListView_UpdateScrollBars(a1);
    v7 = *(_DWORD *)v6;
    if ( !*(_DWORD *)v6 )
      v7 = 1;
  }
  v8 = a2 % v7;
  v9 = *((_DWORD *)a1 + 89) + a2 / v7 * *((_DWORD *)a1 + 46) - *((_DWORD *)a1 + 45);
  v10 = v8 * *((_DWORD *)a1 + 47);
  v11 = v9 + *((_DWORD *)a1 + 43);
  v15 = v9 + *((_DWORD *)a1 + 43);
  v16 = v10 + *((_DWORD *)a1 + 47);
  if ( a3 )
  {
    *(_DWORD *)a3 = v9;
    *(_DWORD *)(a3 + 4) = v10;
    v12 = a3 + 8;
    *(_DWORD *)v12 = v15;
    *(_DWORD *)(v12 + 4) = v16;
  }
  v17 = v10;
  v18 = v9 + *((_DWORD *)a1 + 46) - *((_DWORD *)a1 + 89);
  if ( a4 )
  {
    *(_DWORD *)a4 = v11;
    *(_DWORD *)(a4 + 4) = v10;
    v13 = a4 + 8;
    *(_DWORD *)v13 = v18;
    *(_DWORD *)(v13 + 4) = v16;
  }
  if ( a5 )
  {
    *(_DWORD *)a5 = v11;
    *(_DWORD *)(a5 + 4) = v10;
    *(_DWORD *)(a5 + 8) = v18;
    *(_DWORD *)(a5 + 12) = v16;
    *(_DWORD *)a5 = v9 - *((_DWORD *)a1 + 89);
  }
  result = a6;
  if ( a6 )
  {
    *(_DWORD *)a6 = v11;
    *(_DWORD *)(a6 + 4) = v17;
    *(_DWORD *)(a6 + 8) = v18;
    *(_DWORD *)(a6 + 12) = v16;
    *(_DWORD *)a6 = v9;
  }
  return result;
}

//----- (6F7CFCC8) --------------------------------------------------------
int __stdcall ListView_LOnScroll(HDC hdc, int a2, int a3, int a4)
{
  signed int v4; // eax@3
  int v6; // [sp+4h] [bp-10h]@3
  int v7; // [sp+Ch] [bp-8h]@3

  if ( *((_DWORD *)hdc + 62) )
    ListView_DismissEdit((int)hdc, 0);
  ListView_GetClientRect((int)hdc, (int)&v6, 1, 0);
  v4 = (v7 - v6) / *((_DWORD *)hdc + 46);
  if ( !v4 )
    v4 = 1;
  return ListView_ComOnScroll(hdc, a2, a3, 0, 1, v4);
}

//----- (6F7CFD20) --------------------------------------------------------
signed int __stdcall ListView_LGetScrollUnitsPerLine(int a1, int a2)
{
  return 1;
}

//----- (6F7CFD2B) --------------------------------------------------------
int __stdcall ListView_LCalcViewItem(int a1, int a2, signed int a3)
{
  int v3; // edi@1
  int v4; // esi@3
  int result; // eax@5

  v3 = a3 / *(_DWORD *)(a1 + 188);
  if ( v3 <= 0 )
    v3 = 0;
  v4 = *(_DWORD *)(a1 + 192);
  if ( v3 >= v4 - 1 )
    v3 = v4 - 1;
  result = v3 + v4 * ((a2 + *(_DWORD *)(a1 + 180)) / *(_DWORD *)(a1 + 184));
  if ( result <= 0 )
    result = 0;
  if ( result >= *(_DWORD *)(a1 + 372) - 1 )
    result = *(_DWORD *)(a1 + 372) - 1;
  return result;
}

//----- (6F7CFD89) --------------------------------------------------------
int __stdcall LV_GetNewColWidth(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@3
  int v5; // eax@3
  int v6; // eax@8
  int v7; // edi@17
  char v9; // [sp+8h] [bp-BCh]@17
  __int16 v10; // [sp+16h] [bp-AEh]@17
  int v11; // [sp+24h] [bp-A0h]@15
  LPARAM lParam; // [sp+44h] [bp-80h]@15
  HDC v13; // [sp+54h] [bp-70h]@20
  int v14; // [sp+98h] [bp-2Ch]@15
  int v15; // [sp+9Ch] [bp-28h]@20
  int v16; // [sp+A0h] [bp-24h]@15
  int v17; // [sp+B8h] [bp-Ch]@20
  int v18; // [sp+C0h] [bp-4h]@1

  v18 = 0;
  v3 = a2;
  if ( a2 <= a3 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x1000 )
    {
      v4 = ListView_LCalcViewItem(a1, 1, 1);
      v5 = ListView_LCalcViewItem(a1, *(_DWORD *)(a1 + 120) - 1, *(_DWORD *)(a1 + 124) - 1);
      if ( a3 - a2 > v5 - v4 )
      {
        if ( a2 <= v4 )
          v3 = v4;
        if ( a3 >= v5 )
          a3 = v5;
      }
      v6 = *(_DWORD *)(a1 + 372);
      if ( v6 >= a3 )
        v6 = a3;
      a3 = v6;
      if ( v3 < 0 )
        v3 = 0;
      if ( v6 <= v3 )
        a3 = v3;
      ListView_NotifyCacheHint(a1, v3, a3);
    }
    ListView_BeginFakeCustomDraw(a1, (LPARAM)&lParam, (int)&v14);
    v16 = 0;
    v11 = 0;
    v14 = 4;
    while ( v3 <= a3 )
    {
      if ( *(_DWORD *)(a1 + 8) & 0x1000 )
      {
        v7 = (int)&v9;
        v10 = 0x7FFF;
      }
      else
      {
        v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v3);
      }
      if ( *(_WORD *)(v7 + 14) == 0x7FFF )
      {
        v15 = v3;
        v17 = *(_DWORD *)(v7 + 28);
        ListView_BeginFakeItemDraw((LPARAM)&lParam);
        ListView_RecomputeLabelSize(a1, v7, v3, v13, 0);
        ListView_EndFakeItemDraw((LPARAM)&lParam);
      }
      if ( *(_WORD *)(v7 + 14) > v18 )
        v18 = *(_WORD *)(v7 + 14);
      ++v3;
    }
    ListView_EndFakeCustomDraw((LPARAM)&lParam);
  }
  v18 += g_cxIconMargin + *(_DWORD *)(a1 + 172) + *(_DWORD *)(a1 + 356);
  if ( v18 > g_cxScreen )
    v18 = g_cxScreen;
  return v18;
}
// 6F7E6888: using guessed type int g_cxScreen;
// 6F7E6988: using guessed type int g_cxIconMargin;

//----- (6F7CFED9) --------------------------------------------------------
signed int __stdcall ListView_MaybeResizeListColumns(int a1, int a2, int a3)
{
  int v3; // eax@3
  signed int v4; // ecx@3
  int v5; // ebx@4
  signed int result; // eax@4

  if ( (*(_BYTE *)(a1 + 8) & 3) != 3
    || *(_DWORD *)(a1 + 44) & 0x400
    || (v3 = LV_GetNewColWidth(a1, a2, a3), v4 = *(_DWORD *)(a1 + 184), v3 <= v4) )
  {
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 180) / v4;
    ListView_ISetColumnWidth(a1, 0, v3, 0);
    *(_DWORD *)(a1 + 180) = v5 * *(_DWORD *)(a1 + 184);
    result = 1;
  }
  return result;
}

//----- (6F7CFF47) --------------------------------------------------------
signed int __stdcall ListView_LDrawItem(int a1)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  HDC v3; // ST1C_4@7
  LONG v4; // eax@7
  int v5; // ecx@7
  int v6; // ecx@8
  bool v7; // zf@9
  int v8; // eax@15
  char *v10; // [sp+Ch] [bp-2B8h]@7
  __int16 v11; // [sp+1Ah] [bp-2AAh]@7
  struct tagRECT rcDst; // [sp+48h] [bp-27Ch]@2
  int i; // [sp+58h] [bp-26Ch]@1
  int v14; // [sp+5Ch] [bp-268h]@1
  int v15; // [sp+60h] [bp-264h]@1
  int v16; // [sp+64h] [bp-260h]@7
  int v17; // [sp+68h] [bp-25Ch]@1
  int v18; // [sp+6Ch] [bp-258h]@1
  int v19; // [sp+70h] [bp-254h]@1
  struct tagRECT rc; // [sp+80h] [bp-244h]@1
  RECT rcSrc1; // [sp+90h] [bp-234h]@1
  RECT v22; // [sp+A0h] [bp-224h]@1
  int v23; // [sp+B0h] [bp-214h]@9
  int v24; // [sp+B4h] [bp-210h]@5
  char v25; // [sp+B8h] [bp-20Ch]@1

  v15 = 0;
  v1 = *(_DWORD *)(a1 + 60);
  v2 = *(_DWORD *)a1;
  v18 = (int)&v25;
  v14 = v1;
  i = 11;
  v17 = 0xFFFF;
  v19 = 260;
  ListView_OnGetItem(v2, (HDPA)v2, (int)&i);
  ListView_LGetRects((HDC)v2, v1, (int)&rc, (int)&v22, (int)&rcSrc1, 0);
  if ( !*(_DWORD *)(a1 + 8) || IntersectRect(&rcDst, &rcSrc1, *(const RECT **)(a1 + 8)) )
  {
    if ( *(_DWORD *)(a1 + 4) )
    {
      OffsetRect(&rc, **(_DWORD **)(a1 + 4) - rcSrc1.left, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) - rcSrc1.top);
      OffsetRect(&v22, **(_DWORD **)(a1 + 4) - rcSrc1.left, *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4) - rcSrc1.top);
    }
    v24 = ListView_DrawImageEx((HIMAGELIST)v2, (int)&i, *(HDC *)(a1 + 40), rc.left, rc.top, *(_DWORD *)(a1 + 12), -1) | 2;
    if ( *(_DWORD *)(v2 + 252) != v1 )
    {
      if ( *(_DWORD *)(v2 + 8) & 0x1000 )
      {
        v3 = *(HDC *)(a1 + 40);
        v10 = &v25;
        ListView_RecomputeLabelSize(v2, (int)&v10, v1, v3, 1);
        v4 = v11;
        v5 = v16;
      }
      else
      {
        v6 = *(_DWORD *)(a1 + 16);
        v4 = *(_WORD *)(v6 + 14);
        v5 = *(_WORD *)(v6 + 24);
      }
      v7 = (*(_BYTE *)(a1 + 12) & 2) == 0;
      v23 = v5;
      if ( !v7 )
        v24 |= 0x80u;
      if ( v4 == 0x7FFF )
      {
        ListView_RecomputeLabelSize(v2, *(_DWORD *)(a1 + 16), v1, *(HDC *)(a1 + 40), 0);
        v4 = *(_WORD *)(*(_DWORD *)(a1 + 16) + 14);
      }
      if ( v4 < v22.right - v22.left )
        v22.right = v4 + v22.left;
      v8 = v24;
      if ( v24 & 8 && *(_BYTE *)(a1 + 12) & 0x40 )
        v8 = v24 | 0x200;
      if ( *(_DWORD *)(v2 + 52) & 0x2000 )
        v8 |= 0x800u;
      SHDrawText(
        *(HDC *)(a1 + 40),
        v18,
        &v22,
        0,
        v8,
        *(_DWORD *)(v2 + 84),
        *(_DWORD *)(v2 + 92),
        *(_DWORD *)(a1 + 72),
        *(_DWORD *)(a1 + 76));
      if ( *(_BYTE *)(a1 + 12) & 8 && v23 & 1 && !(CCGetUIState(*(_DWORD *)a1) & 1) )
        DrawFocusRect(*(HDC *)(a1 + 40), &v22);
    }
  }
  return 1;
}

//----- (6F7D0188) --------------------------------------------------------
int __stdcall ListView_LScroll2_SmoothScroll(HWND hWnd, int a2, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
{
  LONG v8; // eax@1

  v8 = GetWindowLongW(hWnd, 0);
  if ( v8 )
    *(_DWORD *)(v8 + 180) -= a2;
  return ScrollWindowEx(hWnd, a2, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}

//----- (6F7D01CA) --------------------------------------------------------
BOOL __stdcall ListView_LScroll2(int a1, int a2, int a3, int a4)
{
  BOOL result; // eax@1
  int v5; // ecx@2
  int dy; // [sp+0h] [bp-38h]@2
  int v7; // [sp+4h] [bp-34h]@2
  HWND v8; // [sp+8h] [bp-30h]@2
  int v9; // [sp+Ch] [bp-2Ch]@2
  int v10; // [sp+10h] [bp-28h]@2
  int v11; // [sp+14h] [bp-24h]@2
  int v12; // [sp+18h] [bp-20h]@2
  int v13; // [sp+1Ch] [bp-1Ch]@2
  int v14; // [sp+20h] [bp-18h]@2
  int v15; // [sp+24h] [bp-14h]@2
  int (__stdcall *v16)(HWND, int, int, RECT *, RECT *, HRGN, LPRECT, UINT); // [sp+34h] [bp-4h]@2

  result = 0;
  if ( a2 )
  {
    v8 = *(HWND *)a1;
    v5 = a2 * *(_DWORD *)(a1 + 184);
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    dy = 56;
    v7 = 1;
    v9 = -v5;
    v15 = 6;
    v16 = ListView_LScroll2_SmoothScroll;
    SmoothScrollWindow((int)&dy);
    result = UpdateWindow(*(HWND *)a1);
  }
  return result;
}

//----- (6F7D0237) --------------------------------------------------------
int __stdcall ListView_LUpdateScrollBars(int a1)
{
  int v1; // eax@1
  int v2; // eax@1
  int v3; // edi@2
  HWND v4; // ST08_4@5
  UINT v5; // eax@8
  int result; // eax@13
  HWND v7; // [sp-14h] [bp-4Ch]@12
  struct tagSCROLLINFO psi; // [sp+Ch] [bp-2Ch]@1
  int v9; // [sp+28h] [bp-10h]@1
  int v10; // [sp+2Ch] [bp-Ch]@1
  int v11; // [sp+30h] [bp-8h]@1
  int v12; // [sp+34h] [bp-4h]@1

  ListView_GetClientRect(a1, (int)&v9, 0, 0);
  v1 = (v11 - v9) / *(_DWORD *)(a1 + 184);
  psi.cbSize = 28;
  psi.fMask = 7;
  psi.nMin = 0;
  psi.nPage = v1;
  v2 = ListView_GetCyScrollbar(a1);
  v12 -= v2;
  if ( (v12 - v10) / *(_DWORD *)(a1 + 188) >= 1 )
    v3 = (v12 - v10) / *(_DWORD *)(a1 + 188);
  else
    v3 = 1;
  psi.nPos = *(_DWORD *)(a1 + 180) / *(_DWORD *)(a1 + 184);
  psi.nMax = (v3 + *(_DWORD *)(a1 + 372) - 1) / v3 - 1;
  ListView_SetScrollInfo(a1, 0, &psi, 1);
  if ( *(_DWORD *)(a1 + 192) != v3 )
  {
    v4 = *(HWND *)a1;
    *(_DWORD *)(a1 + 192) = v3;
    InvalidateRect(v4, 0, 1);
  }
  if ( (signed int)(psi.nPos + psi.nPage - 1) > psi.nMax && psi.nPos > 0 )
  {
    v5 = psi.nMax - psi.nPage + 1;
    if ( (v5 & 0x80000000) != 0 )
      v5 = 0;
    if ( v5 != psi.nPos )
    {
      ListView_LScroll2(a1, v5 - psi.nPos, 0, 0);
      ListView_LUpdateScrollBars(a1);
    }
  }
  v7 = *(HWND *)a1;
  if ( *(_DWORD *)(a1 + 48) & 0x100 )
    result = FlatSB_SetScrollRange(v7, 1, 0, 0, 1);
  else
    result = SetScrollRange(v7, 1, 0, 0, 1);
  return result;
}

//----- (6F7D0336) --------------------------------------------------------
void __stdcall ListView_RInitialize(int a1, int a2)
{
  HWND v2; // ST0C_4@3
  int v3; // edi@3
  int v4; // eax@3
  HWND v5; // ST00_4@3
  signed int v6; // eax@3
  LPARAM lParam; // [sp+4h] [bp-18h]@3
  int v8; // [sp+8h] [bp-14h]@3
  unsigned int v9; // [sp+14h] [bp-8h]@3

  if ( a1 && *(_DWORD *)(a1 + 8) & 0x400 )
  {
    v2 = *(HWND *)a1;
    v3 = *(_DWORD *)(a1 + 188);
    lParam = 102;
    v4 = GetDlgCtrlID(v2);
    v9 = *(_DWORD *)(a1 + 188);
    v5 = *(HWND *)(a1 + 4);
    v8 = v4;
    SendMessageW(v5, 0x2Cu, v4, (LPARAM)&lParam);
    v6 = v9;
    if ( v9 <= 1 )
      v6 = 1;
    *(_DWORD *)(a1 + 188) = v6;
    if ( a2 )
    {
      if ( v3 != v6 )
        RedrawWindow(*(HWND *)a1, 0, 0, 5u);
    }
  }
}

//----- (6F7D03B5) --------------------------------------------------------
BOOL __stdcall CCDrawRect(HDC hdc, int a2, int a3, int a4, int a5)
{
  RECT rect; // [sp+0h] [bp-10h]@1

  rect.left = a2;
  rect.right = a4 + a2;
  rect.top = a3;
  rect.bottom = a5 + a3;
  return ExtTextOutW(hdc, 0, 0, 2u, &rect, 0, 0, 0);
}

//----- (6F7D03F8) --------------------------------------------------------
void __stdcall ListView_RAfterRedraw(WPARAM wParam, HDC hdc)
{
  WPARAM v2; // esi@1
  COLORREF v3; // eax@2
  int v4; // edi@2
  bool v5; // zf@2
  bool v6; // sf@2
  HWND v7; // ST00_4@4
  LRESULT v8; // eax@4
  int i; // edi@7
  LPARAM lParam; // [sp+4h] [bp-30h]@4
  int v11; // [sp+8h] [bp-2Ch]@4
  COLORREF color; // [sp+30h] [bp-4h]@2
  WPARAM wParama; // [sp+3Ch] [bp+8h]@2

  v2 = wParam;
  if ( *(_BYTE *)(wParam + 48) & 1 )
  {
    v3 = SetBkColor(hdc, g_clrBtnFace);
    wParama = 0;
    v4 = -*(_DWORD *)(v2 + 332);
    v5 = *(_DWORD *)(v2 + 312) == 0;
    v6 = *(_DWORD *)(v2 + 312) < 0;
    color = v3;
    if ( !v6 && !v5 )
    {
      do
      {
        if ( v4 >= *(_DWORD *)(v2 + 120) )
          break;
        v7 = *(HWND *)(v2 + 320);
        lParam = 1;
        v8 = SendMessageW(v7, 0x120Fu, wParama, 0);
        SendMessageW(*(HWND *)(v2 + 320), 0x120Bu, v8, (LPARAM)&lParam);
        v4 += v11;
        if ( v4 > 0 )
          CCDrawRect(hdc, v4, 0, g_cxBorder, *(_DWORD *)(v2 + 124));
        ++wParama;
      }
      while ( (signed int)wParama < *(_DWORD *)(v2 + 312) );
    }
    for ( i = *(_DWORD *)(v2 + 324) - 1; i < *(_DWORD *)(v2 + 124); i += *(_DWORD *)(v2 + 188) )
      CCDrawRect(hdc, 0, i, *(_DWORD *)(v2 + 120), g_cxBorder);
    SetBkColor(hdc, color);
  }
}

//----- (6F7D04D6) --------------------------------------------------------
int __stdcall ListView_RGetCXLabel(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // eax@2
  char v8; // [sp+4h] [bp-3Ch]@4

  v5 = a3;
  if ( *(_DWORD *)(a1 + 8) & 0x1000 || (v6 = *(_WORD *)(a3 + 14), (_WORD)v6 == 0x7FFF) )
  {
    if ( !a3 )
    {
      a5 = 0;
      v5 = (int)&v8;
    }
    ListView_RecomputeLabelSize(a1, v5, a2, (HDC)a4, a5);
    v6 = *(_WORD *)(v5 + 14);
  }
  return v6 + 2 * g_cxLabelMargin;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7D052E) --------------------------------------------------------
int __stdcall ListView_CreateHeader(int a1)
{
  int v1; // eax@1
  signed int v2; // ebx@1
  LONG v3; // eax@5
  HWND v4; // eax@5

  v1 = *(_DWORD *)(a1 + 8);
  v2 = 1073741888;
  if ( v1 & 0x4000 )
    v2 = 1073741896;
  if ( !(v1 & 0x8000) )
    v2 |= 2u;
  v3 = GetWindowLongW(*(HWND *)a1, -6);
  v4 = CreateWindowExW(0, L"SysHeader32", 0, v2 | 0x80, 0, 0, 0, 0, *(HWND *)a1, 0, (HINSTANCE)v3, 0);
  *(_DWORD *)(a1 + 320) = v4;
  if ( v4 )
  {
    SendMessageW(v4, 0x30u, *(_DWORD *)(a1 + 56), 0);
    if ( *(_DWORD *)(a1 + 168) )
      SendMessageW(*(HWND *)(a1 + 320), 0x1208u, 0, *(_DWORD *)(a1 + 168));
  }
  return *(_DWORD *)(a1 + 320);
}

//----- (6F7D05C2) --------------------------------------------------------
LRESULT __stdcall ListView_OnInsertColumn(int a1, WPARAM wParam, int a3)
{
  LRESULT result; // eax@1
  int v4; // eax@6
  int v5; // ecx@9
  int v6; // ecx@11
  HDPA v7; // eax@24
  int v8; // eax@25
  LRESULT v9; // edi@28
  struct _DPA *v10; // esi@29
  LPARAM lParam; // [sp+Ch] [bp-30h]@6
  int v12; // [sp+10h] [bp-2Ch]@13
  int v13; // [sp+14h] [bp-28h]@9
  int v14; // [sp+18h] [bp-24h]@19
  int v15; // [sp+20h] [bp-1Ch]@17
  int v16; // [sp+24h] [bp-18h]@20
  int v17; // [sp+28h] [bp-14h]@7
  int v18; // [sp+2Ch] [bp-10h]@11
  int i; // [sp+38h] [bp-4h]@1

  result = -1;
  i = -1;
  if ( (wParam & 0x80000000) == 0 && a3 )
  {
    if ( !*(_DWORD *)(a1 + 320) && !ListView_CreateHeader(a1) )
      return -1;
    v4 = *(_DWORD *)a3;
    lParam = 13;
    if ( v4 & 0x10 )
    {
      v17 = *(_DWORD *)(a3 + 24);
      lParam = 45;
    }
    if ( v4 & 4 )
    {
      v5 = *(_DWORD *)(a3 + 12);
      lParam |= 2u;
      v13 = v5;
    }
    if ( v4 & 0x20 )
    {
      v6 = *(_DWORD *)(a3 + 28);
      lParam |= 0x80u;
      v18 = v6;
    }
    v12 = v4 & 2 ? *(_DWORD *)(a3 + 8) : 10;
    v15 = v4 & 1 && (signed int)wParam > 0 ? *(_DWORD *)(a3 + 4) : 0;
    v14 = 0;
    v16 = v4 & 8 ? *(_DWORD *)(a3 + 20) : 0;
    if ( *(_DWORD *)(a1 + 312) > 0 )
    {
      if ( !*(_DWORD *)(a1 + 316) )
      {
        v7 = DPA_CreateEx(8, *(HANDLE *)(a1 + 80));
        *(_DWORD *)(a1 + 316) = v7;
        if ( !v7 )
          return -1;
      }
      v8 = wParam - 1;
      if ( ((wParam - 1) & 0x80000000) != 0 )
        v8 = 0;
      i = DPA_InsertPtr(*(HDPA *)(a1 + 316), v8, 0);
      if ( i == -1 )
        return -1;
    }
    v9 = SendMessageW(*(HWND *)(a1 + 320), 0x120Au, wParam, (LPARAM)&lParam);
    if ( v9 == -1 )
    {
      v10 = *(struct _DPA **)(a1 + 316);
      if ( v10 )
      {
        if ( i != -1 )
          DPA_DeletePtr(v10, i);
      }
      return -1;
    }
    ++*(_DWORD *)(a1 + 312);
    *(_DWORD *)(a1 + 328) = 0x7FFFFFFF;
    ListView_UpdateScrollBars((HDC)a1);
    if ( (*(_DWORD *)(a1 + 8) & 3) == 1 && (*(_BYTE *)(a1 + 44) & 0x12) == 18 )
      RedrawWindow(*(HWND *)a1, 0, 0, 5u);
    result = v9;
  }
  return result;
}

//----- (6F7D074A) --------------------------------------------------------
int __stdcall ListView_FreeColumnData(void *p, void *pData)
{
  ListView_FreeSubItem(p);
  return 1;
}

//----- (6F7D0763) --------------------------------------------------------
int __stdcall ListView_RGetColumnWidth(int a1, WPARAM wParam)
{
  HWND v2; // ST00_4@1
  LPARAM lParam; // [sp+0h] [bp-2Ch]@1
  int v5; // [sp+4h] [bp-28h]@1

  v2 = *(HWND *)(a1 + 320);
  lParam = 1;
  SendMessageW(v2, 0x120Bu, wParam, (LPARAM)&lParam);
  return v5;
}

//----- (6F7D0799) --------------------------------------------------------
unsigned int __stdcall ListView_BeginFakeCustomDraw(int a1, LPARAM lParam, int a3)
{
  HDC v3; // eax@1
  unsigned int result; // eax@1

  v3 = GetDC(*(HWND *)a1);
  *(_DWORD *)(lParam + 16) = v3;
  *(_DWORD *)(lParam + 40) = 0;
  *(_DWORD *)(lParam + 36) = 0;
  *(_DWORD *)(lParam + 44) = 0;
  *(_DWORD *)(lParam + 80) = SelectObject(v3, *(HGDIOBJ *)(a1 + 56));
  SetRectEmpty((LPRECT)(lParam + 20));
  *(_DWORD *)(lParam + 60) = a1;
  *(_DWORD *)(lParam + 64) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(lParam + 76) = a3;
  result = CIFakeCustomDrawNotify(a1, 1, lParam);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (6F7D07F9) --------------------------------------------------------
int __stdcall ListView_BeginFakeItemDraw(LPARAM lParam)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // ebx@3

  v1 = *(_DWORD *)(lParam + 60);
  if ( *(_BYTE *)(v1 + 12) & 0x20 )
  {
    v3 = *(_DWORD *)(lParam + 76);
    *(_DWORD *)(lParam + 36) = *(_DWORD *)(v3 + 4);
    if ( !(*(_DWORD *)(v1 + 8) & 0x1000) )
      *(_DWORD *)(lParam + 44) = *(_DWORD *)(v3 + 32);
    if ( *(_BYTE *)(v1 + 12) & 4 )
    {
      *(_DWORD *)(lParam + 68) = 0;
    }
    else
    {
      *(_DWORD *)(lParam + 56) = 0;
      *(_DWORD *)(lParam + 68) = CIFakeCustomDrawNotify(v1, 65537, lParam);
    }
    if ( (*(_DWORD *)(v1 + 8) & 3) != 1 )
      *(_DWORD *)(lParam + 68) &= 0xFFFFFFDF;
    if ( *(_BYTE *)(lParam + 68) & 0x20 )
    {
      *(_DWORD *)(lParam + 56) = *(_DWORD *)(v3 + 8);
      *(_DWORD *)(lParam + 72) = CIFakeCustomDrawNotify(v1, 196609, lParam);
    }
    else
    {
      *(_DWORD *)(lParam + 72) = 0;
    }
    result = *(_DWORD *)(lParam + 72) | *(_DWORD *)(lParam + 68);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7D0888) --------------------------------------------------------
void __stdcall ListView_EndFakeItemDraw(LPARAM lParam)
{
  int v1; // edi@1
  int v2; // eax@2
  int v3; // eax@7

  v1 = *(_DWORD *)(lParam + 60);
  if ( *(_BYTE *)(v1 + 12) & 0x20 )
  {
    v2 = *(_DWORD *)(lParam + 72);
    if ( !(v2 & 4) && v2 & 0x10 )
      CIFakeCustomDrawNotify(v1, 196610, lParam);
    if ( (*(_BYTE *)(lParam + 72) | *(_BYTE *)(lParam + 68)) & 2 )
      SelectObject(*(HDC *)(lParam + 16), *(HGDIOBJ *)(v1 + 56));
    v3 = *(_DWORD *)(lParam + 68);
    if ( !(v3 & 4) )
    {
      if ( v3 & 0x10 )
      {
        *(_DWORD *)(lParam + 56) = 0;
        CIFakeCustomDrawNotify(v1, 65538, lParam);
      }
    }
  }
}

//----- (6F7D08EE) --------------------------------------------------------
int __stdcall ListView_EndFakeCustomDraw(LPARAM lParam)
{
  int v1; // edi@1
  int v2; // eax@1

  v1 = *(_DWORD *)(lParam + 60);
  v2 = *(_DWORD *)(v1 + 12);
  if ( !(v2 & 4) && v2 & 0x10 )
    CIFakeCustomDrawNotify(v1, 2, lParam);
  *(_DWORD *)(v1 + 12) = *(_DWORD *)(lParam + 64);
  SelectObject(*(HDC *)(lParam + 16), *(HGDIOBJ *)(lParam + 80));
  return ReleaseDC(*(HWND *)v1, *(HDC *)(lParam + 16));
}

//----- (6F7D0937) --------------------------------------------------------
LRESULT __stdcall ListView_OnGetColumn(int a1, WPARAM wParam, int a3)
{
  LRESULT result; // eax@2
  int v4; // ebx@3
  int v5; // eax@7
  LPARAM lParam; // [sp+4h] [bp-2Ch]@5
  int v7; // [sp+8h] [bp-28h]@18
  int v8; // [sp+Ch] [bp-24h]@7
  int v9; // [sp+14h] [bp-1Ch]@7
  int v10; // [sp+18h] [bp-18h]@16
  int v11; // [sp+1Ch] [bp-14h]@10
  int v12; // [sp+20h] [bp-10h]@14
  int v13; // [sp+24h] [bp-Ch]@12

  if ( a3 )
  {
    v4 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 )
    {
      lParam = 173;
      if ( v4 & 4 && *(_DWORD *)(a3 + 12) )
      {
        v8 = *(_DWORD *)(a3 + 12);
        v5 = *(_DWORD *)(a3 + 16);
        lParam = 175;
        v9 = v5;
      }
      result = SendMessageW(*(HWND *)(a1 + 320), 0x120Bu, wParam, (LPARAM)&lParam);
      if ( result )
      {
        if ( v4 & 8 )
          *(_DWORD *)(a3 + 20) = v11;
        if ( v4 & 0x20 )
          *(_DWORD *)(a3 + 28) = v13;
        if ( v4 & 0x10 )
          *(_DWORD *)(a3 + 24) = v12;
        result = 1;
        if ( v4 & 1 )
          *(_DWORD *)(a3 + 4) = v10;
        if ( v4 & 2 )
          *(_DWORD *)(a3 + 8) = v7;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7D09E0) --------------------------------------------------------
int __stdcall ListView_OnSetColumn(int a1, WPARAM wParam, int a3)
{
  int result; // eax@1
  int v4; // ecx@2
  int v5; // esi@7
  int v6; // esi@9
  int v7; // esi@11
  int v8; // esi@13
  int v9; // eax@15
  HWND v10; // ST00_4@16
  LPARAM lParam; // [sp+0h] [bp-2Ch]@4
  int v12; // [sp+4h] [bp-28h]@9
  int v13; // [sp+8h] [bp-24h]@11
  int v14; // [sp+10h] [bp-1Ch]@11
  int v15; // [sp+14h] [bp-18h]@7
  WPARAM v16; // [sp+18h] [bp-14h]@5
  int v17; // [sp+1Ch] [bp-10h]@13
  int v18; // [sp+20h] [bp-Ch]@15

  result = a3;
  if ( a3 )
  {
    v4 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 )
    {
      lParam = 0;
      if ( v4 & 8 )
      {
        lParam = 8;
        v16 = wParam;
      }
      if ( v4 & 1 )
      {
        v5 = *(_DWORD *)(a3 + 4);
        lParam |= 4u;
        v15 = v5 | 0x4000;
      }
      if ( v4 & 2 )
      {
        v6 = *(_DWORD *)(a3 + 8);
        lParam |= 1u;
        v12 = v6;
      }
      if ( v4 & 4 )
      {
        v7 = *(_DWORD *)(a3 + 12);
        lParam |= 2u;
        v14 = 0;
        v13 = v7;
      }
      if ( v4 & 0x10 )
      {
        v8 = *(_DWORD *)(a3 + 24);
        lParam |= 0x20u;
        v17 = v8;
      }
      if ( v4 & 0x20 )
      {
        v9 = *(_DWORD *)(a3 + 28);
        lParam |= 0x80u;
        v18 = v9;
      }
      v10 = *(HWND *)(a1 + 320);
      *(_DWORD *)(a1 + 328) = 0x7FFFFFFF;
      result = SendMessageW(v10, 0x120Cu, wParam, (LPARAM)&lParam);
    }
    else
    {
      result = 1;
    }
  }
  return result;
}

//----- (6F7D0A9D) --------------------------------------------------------
int __stdcall ListView_RDestroyColumn(void *p, void *pData)
{
  DPA_DestroyCallback((HDPA)p, ListView_FreeColumnData, 0);
  return 1;
}

//----- (6F7D0ABD) --------------------------------------------------------
void __stdcall ListView_RDestroy(int a1)
{
  DPA_DestroyCallback(*(HDPA *)(a1 + 316), ListView_RDestroyColumn, 0);
  *(_DWORD *)(a1 + 316) = 0;
}

//----- (6F7D0AE7) --------------------------------------------------------
HDC __stdcall ListView_RHeaderTrack(HDC hdc, int a2)
{
  int v2; // esi@1
  HDC result; // eax@1
  int v4; // ecx@8
  int v5; // ST10_4@8
  LPARAM lParam; // [sp+4h] [bp-20h]@6
  struct tagRECT rcDst; // [sp+14h] [bp-10h]@6
  HDC hdca; // [sp+2Ch] [bp+8h]@1

  v2 = (int)hdc;
  result = GetDC(*(HWND *)hdc);
  hdca = result;
  if ( result )
  {
    if ( x > 0 )
      PatBlt(result, x, *(_DWORD *)(v2 + 324), g_cxBorder, *(_DWORD *)(v2 + 124) - *(_DWORD *)(v2 + 324), 0x5A0049u);
    if ( *(_DWORD *)(a2 + 8) == -327 )
    {
      x = -32767;
    }
    else
    {
      ListView_GetRects(v2, 0, 0, 0, &rcDst, 0);
      if ( !SendMessageW(*(HWND *)(v2 + 320), 0x1207u, *(_DWORD *)(a2 + 12), (LPARAM)&lParam) )
        lParam = 0;
      rcDst.left += lParam;
      v4 = *(_DWORD *)(v2 + 324);
      v5 = *(_DWORD *)(v2 + 124) - v4;
      x = rcDst.left + *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4);
      PatBlt(hdca, x, v4, g_cxBorder, v5, 0x5A0049u);
    }
    result = (HDC)ReleaseDC(*(HWND *)v2, hdca);
  }
  return result;
}

//----- (6F7D0BC8) --------------------------------------------------------
BOOL __stdcall ListView_AdjustColumn(HDC a1, int a2)
{
  BOOL result; // eax@1
  int v3; // edi@1
  LRESULT v4; // eax@2
  LPARAM v5; // ebx@2
  int v6; // eax@5
  int dy; // [sp+8h] [bp-48h]@5
  int v8; // [sp+Ch] [bp-44h]@5
  HWND v9; // [sp+10h] [bp-40h]@5
  int v10; // [sp+14h] [bp-3Ch]@5
  int v11; // [sp+18h] [bp-38h]@5
  int v12; // [sp+1Ch] [bp-34h]@5
  LPARAM *v13; // [sp+20h] [bp-30h]@5
  int v14; // [sp+24h] [bp-2Ch]@5
  int v15; // [sp+28h] [bp-28h]@5
  int v16; // [sp+2Ch] [bp-24h]@5
  int v17; // [sp+30h] [bp-20h]@5
  int v18; // [sp+34h] [bp-1Ch]@5
  int v19; // [sp+38h] [bp-18h]@5
  int v20; // [sp+3Ch] [bp-14h]@5
  LPARAM lParam; // [sp+40h] [bp-10h]@2
  int v22; // [sp+44h] [bp-Ch]@2
  LPARAM v23; // [sp+48h] [bp-8h]@2
  int v24; // [sp+4Ch] [bp-4h]@2

  result = *((_DWORD *)a1 + 86);
  v3 = a2 - result;
  if ( a2 != result )
  {
    v4 = SendMessageW(*((HWND *)a1 + 80), 0x1207u, *((_DWORD *)a1 + 85), (LPARAM)&lParam);
    v5 = (v4 != 0 ? lParam : 0) - *((_DWORD *)a1 + 83);
    GetWindowRect(*((HWND *)a1 + 80), (LPRECT)&lParam);
    lParam = v5;
    v22 = v24 - v22;
    v23 = *((_DWORD *)a1 + 30);
    v24 = *((_DWORD *)a1 + 31);
    if ( *((_DWORD *)a1 + 103) || *((_DWORD *)a1 + 15) == -1 || *((_DWORD *)a1 + 18) == -1 )
    {
      *((_DWORD *)a1 + 82) = 0x7FFFFFFF;
      ListView_UpdateScrollBars(a1);
      lParam = v5;
      result = RedrawWindow(*(HWND *)a1, (const RECT *)&lParam, 0, 0x105u);
    }
    else
    {
      v9 = *(HWND *)a1;
      v10 = v3;
      v8 = 0;
      v11 = 0;
      v12 = 0;
      v14 = 0;
      v15 = 0;
      dy = 56;
      v16 = 6;
      v13 = &lParam;
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v6 = *((_DWORD *)a1 + 86);
      if ( v6 >= a2 )
        v6 = a2;
      lParam = v5 + v6;
      SmoothScrollWindow((int)&dy);
      if ( a2 < *((_DWORD *)a1 + 86) )
      {
        v23 = lParam + g_cxEdge;
        InvalidateRect(*(HWND *)a1, (const RECT *)&lParam, 1);
      }
      *((_DWORD *)a1 + 82) = 0x7FFFFFFF;
      lParam = v5;
      v23 = v5;
      if ( v5 <= a2 + v5 )
        v23 = a2 + v5;
      OffsetRect((LPRECT)&lParam, *((_DWORD *)a1 + 83), *((_DWORD *)a1 + 84));
      ListView_UpdateScrollBars(a1);
      OffsetRect((LPRECT)&lParam, -*((_DWORD *)a1 + 83), -*((_DWORD *)a1 + 84));
      UpdateWindow(*(HWND *)a1);
      result = RedrawWindow(*(HWND *)a1, (const RECT *)&lParam, 0, 0x101u);
    }
  }
  return result;
}

//----- (6F7D0D5F) --------------------------------------------------------
HWND __stdcall ListView_ForwardHeaderNotify(int a1, LPARAM lParam)
{
  return SendNotifyEx(*(_DWORD *)(a1 + 4), *(HWND *)lParam, *(_DWORD *)(lParam + 8), lParam, *(_DWORD *)(a1 + 16) & 1);
}

//----- (6F7D0D88) --------------------------------------------------------
int __stdcall ListView_GetSubItem(int a1, INT_PTR i, int a3, int a4)
{
  struct _DPA *v4; // eax@1
  PVOID v5; // eax@2
  int result; // eax@3

  v4 = (struct _DPA *)DPA_GetPtr(*(HDPA *)(a1 + 316), a3 - 1);
  if ( v4 && (v5 = DPA_GetPtr(v4, i)) != 0 )
  {
    *(_DWORD *)a4 = *(_DWORD *)v5;
    result = *((_DWORD *)v5 + 1);
    *(_DWORD *)(a4 + 4) = result;
  }
  else
  {
    result = a4;
    *(_DWORD *)a4 = -1;
    *(_WORD *)(a4 + 4) = -1;
    *(_WORD *)(a4 + 6) = 0;
  }
  return result;
}

//----- (6F7D0DDC) --------------------------------------------------------
int __stdcall ListView_RGetTotalColumnWidth(int a1)
{
  int v1; // eax@2
  LRESULT v2; // eax@3
  LPARAM lParam; // [sp+4h] [bp-10h]@3
  int v5; // [sp+Ch] [bp-8h]@3

  if ( *(_DWORD *)(a1 + 328) == 0x7FFFFFFF )
  {
    v1 = *(_DWORD *)(a1 + 312);
    *(_DWORD *)(a1 + 328) = 0;
    if ( v1 )
    {
      v2 = SendMessageW(*(HWND *)(a1 + 320), 0x120Fu, v1 - 1, 0);
      SendMessageW(*(HWND *)(a1 + 320), 0x1207u, v2, (LPARAM)&lParam);
      *(_DWORD *)(a1 + 328) = v5;
    }
  }
  return *(_DWORD *)(a1 + 328);
}

//----- (6F7D0E49) --------------------------------------------------------
int __stdcall ListView_RGetRects(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@5
  int v7; // ecx@5
  int v8; // eax@5
  int v9; // edi@5
  int v10; // eax@12
  int v11; // esi@12
  int v12; // esi@12
  int v13; // ecx@12
  int v14; // eax@12
  int result; // eax@12
  bool v16; // zf@12
  bool v17; // sf@12
  int v18; // edi@16
  int v19; // edi@18
  int v20; // edx@21
  int v21; // eax@22
  __int16 v22; // ax@24
  LPARAM v23; // ecx@24
  int v24; // edx@24
  int v25; // edi@24
  int v26; // eax@24
  int v27; // ecx@28
  int v28; // [sp+0h] [bp-60h]@10
  int v29; // [sp+4h] [bp-5Ch]@10
  int v30; // [sp+8h] [bp-58h]@10
  int v31; // [sp+24h] [bp-3Ch]@11
  LPARAM lParam; // [sp+28h] [bp-38h]@14
  int v33; // [sp+30h] [bp-30h]@14
  LPARAM v34; // [sp+38h] [bp-28h]@12
  int v35; // [sp+3Ch] [bp-24h]@12
  int v36; // [sp+40h] [bp-20h]@12
  int v37; // [sp+44h] [bp-1Ch]@12
  LPARAM v38; // [sp+48h] [bp-18h]@12
  int v39; // [sp+4Ch] [bp-14h]@12
  int v40; // [sp+50h] [bp-10h]@12
  int v41; // [sp+54h] [bp-Ch]@12
  int v42; // [sp+58h] [bp-8h]@3
  int v43; // [sp+5Ch] [bp-4h]@6
  int v44; // [sp+68h] [bp+8h]@5

  if ( a3 || a4 || (v42 = 0, a6) )
    v42 = 1;
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 188);
  v8 = *(_DWORD *)(a1 + 324) + a2 * *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 336);
  v9 = -*(_DWORD *)(a1 + 332);
  v44 = -*(_DWORD *)(a1 + 332);
  if ( v8 < 0x7FFFFFFF - v7 )
    v43 = v8;
  else
    v43 = 0x7FFFFFFF - v7;
  if ( *(_DWORD *)(v6 + 372) && v42 )
  {
    v30 = 0;
    v28 = 16;
    v29 = a2;
    ListView_OnGetItem(v9, (HDPA)v6, (int)&v28);
  }
  else
  {
    v31 = 0;
  }
  v10 = *(_DWORD *)(v6 + 172);
  v11 = *(_DWORD *)(v6 + 356) + v31 * *(_DWORD *)(v6 + 172);
  v39 = v43;
  v35 = v43;
  v12 = v9 + g_cxEdge + v11;
  v13 = v10 + v12;
  v14 = *(_DWORD *)(v6 + 188);
  v40 = v13;
  result = v43 + v14;
  v34 = v13;
  v16 = *(_DWORD *)(v6 + 312) == 0;
  v17 = *(_DWORD *)(v6 + 312) < 0;
  v38 = v12;
  v41 = result;
  v37 = result;
  v36 = v9;
  if ( !v17 && !v16 && v42 )
  {
    SendMessageW(*(HWND *)(v6 + 320), 0x1207u, 0, (LPARAM)&lParam);
    v36 = v9 + v33;
    v34 = lParam + v40;
    v40 += lParam;
    result = v41;
    v38 = lParam + v12;
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = v38;
    *(_DWORD *)(a3 + 4) = v39;
    v18 = a3 + 8;
    *(_DWORD *)v18 = v40;
    *(_DWORD *)(v18 + 4) = v41;
    v9 = v44;
  }
  if ( a4 )
  {
    *(_DWORD *)a4 = v34;
    *(_DWORD *)(a4 + 4) = v35;
    v19 = a4 + 8;
    *(_DWORD *)v19 = v36;
    *(_DWORD *)(v19 + 4) = v37;
    v9 = v44;
  }
  if ( a6 )
  {
    if ( *(_BYTE *)(v6 + 48) & 0x20 )
    {
      v20 = v43;
      *(_DWORD *)a6 = v9;
      *(_DWORD *)(a6 + 4) = v20;
      *(_DWORD *)(a6 + 12) = result;
      *(_DWORD *)(a6 + 8) = *(_DWORD *)a6 + ListView_RGetTotalColumnWidth(v6);
    }
    else
    {
      v21 = 0;
      if ( !(*(_DWORD *)(v6 + 8) & 0x1000) )
        v21 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 40) + 4) + 4 * a2);
      v22 = ListView_RGetCXLabel(v6, a2, v21, 0, 0);
      v23 = v34;
      v24 = v36;
      *(_DWORD *)a6 = v38;
      *(_DWORD *)(a6 + 4) = v39;
      v25 = a6 + 8;
      *(_DWORD *)v25 = v40;
      v26 = v23 + v22;
      *(_DWORD *)(v25 + 4) = v41;
      v9 = v44;
      *(_DWORD *)(a6 + 8) = v26;
      if ( v26 > v24 )
        *(_DWORD *)(a6 + 8) = v24;
    }
    result = v41;
  }
  if ( a5 )
  {
    v27 = v43;
    *(_DWORD *)a5 = v9;
    *(_DWORD *)(a5 + 4) = v27;
    *(_DWORD *)(a5 + 12) = result;
    result = *(_DWORD *)a5 + ListView_RGetTotalColumnWidth(v6);
    *(_DWORD *)(a5 + 8) = result;
  }
  return result;
}

//----- (6F7D1021) --------------------------------------------------------
signed int __stdcall ListView_RXHitTest(int a1, LPARAM a2)
{
  WPARAM v2; // edi@1
  signed int result; // eax@6
  LPARAM lParam; // [sp+Ch] [bp-10h]@2
  LPARAM v5; // [sp+14h] [bp-8h]@4

  v2 = *(_DWORD *)(a1 + 312) - 1;
  if ( (v2 & 0x80000000) != 0 )
  {
LABEL_6:
    result = v2;
  }
  else
  {
    while ( SendMessageW(*(HWND *)(a1 + 320), 0x1207u, v2, (LPARAM)&lParam) )
    {
      OffsetRect((LPRECT)&lParam, -*(_DWORD *)(a1 + 332), 0);
      if ( lParam > a2 || a2 >= v5 )
      {
        --v2;
        if ( (v2 & 0x80000000) == 0 )
          continue;
      }
      goto LABEL_6;
    }
    result = -1;
  }
  return result;
}

//----- (6F7D108A) --------------------------------------------------------
int __stdcall ListView_NeedsEllipses(HDC hdc, LPCWSTR lpString, int a3, int a4, int a5)
{
  LONG v5; // esi@1
  int v6; // edi@1
  int result; // eax@3
  LONG v8; // esi@6
  int v9; // ecx@7
  int v10; // ebx@8
  struct tagSIZE sz; // [sp+8h] [bp-8h]@1
  int v12; // [sp+20h] [bp+10h]@6
  int v13; // [sp+28h] [bp+18h]@7

  sz.cx = 0;
  sz.cy = 0;
  v5 = *(_DWORD *)(a3 + 8) - *(_DWORD *)a3;
  v6 = lstrlenW(lpString);
  if ( !v6 )
  {
    *(_DWORD *)a4 = 0;
    return 0;
  }
  GetTextExtentPointW(hdc, lpString, v6, &sz);
  if ( sz.cx <= v5 )
  {
    *(_DWORD *)a4 = v6;
    return 0;
  }
  v8 = v5 - a5;
  result = 1;
  v12 = 1;
  if ( v8 > 0 )
  {
    v9 = 0;
    v13 = 0;
    v12 = v6;
    if ( v6 > 0 )
    {
      while ( 1 )
      {
        sz.cx = 0;
        sz.cy = 0;
        v10 = (v12 + v9 + 1) / 2;
        GetTextExtentPointW(hdc, &lpString[v9], v10 - v9, &sz);
        if ( sz.cx >= v8 )
        {
          if ( sz.cx <= v8 )
          {
            v12 = v10;
            break;
          }
          v12 = v10 - 1;
        }
        else
        {
          v8 -= sz.cx;
          v13 = v10;
        }
        if ( v13 >= v12 )
          break;
        v9 = v13;
      }
    }
    result = 1;
    if ( v12 < 1 )
      v12 = 1;
  }
  *(_DWORD *)a4 = v12;
  return result;
}

//----- (6F7D1169) --------------------------------------------------------
int __stdcall ListView_RScroll2_SmoothScroll(HWND hWnd, int a2, int dy, RECT *prcScroll, RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
{
  LONG v8; // eax@1

  v8 = GetWindowLongW(hWnd, 0);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 332) -= a2;
    *(_DWORD *)(v8 + 336) -= dy;
  }
  return ScrollWindowEx(hWnd, a2, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
}

//----- (6F7D11B2) --------------------------------------------------------
int __stdcall ListView_RScroll2(int a1, __int64 a2, int a3)
{
  int result; // eax@1
  LONG v4; // edi@2
  int dy; // [sp+0h] [bp-58h]@4
  int v6; // [sp+4h] [bp-54h]@4
  HWND v7; // [sp+8h] [bp-50h]@4
  int v8; // [sp+Ch] [bp-4Ch]@4
  LONG v9; // [sp+10h] [bp-48h]@4
  int v10; // [sp+14h] [bp-44h]@4
  struct tagRECT *v11; // [sp+18h] [bp-40h]@4
  int v12; // [sp+1Ch] [bp-3Ch]@4
  int v13; // [sp+20h] [bp-38h]@4
  int v14; // [sp+24h] [bp-34h]@4
  int (__stdcall *v15)(HWND, int, int, RECT *, RECT *, HRGN, LPRECT, UINT); // [sp+34h] [bp-24h]@4
  struct tagRECT Rect; // [sp+38h] [bp-20h]@2
  struct tagRECT v17; // [sp+48h] [bp-10h]@7

  result = HIDWORD(a2) | a2;
  if ( a2 )
  {
    GetClientRect(*(HWND *)a1, &Rect);
    v4 = HIDWORD(a2) * *(_DWORD *)(a1 + 188);
    Rect.top = *(_DWORD *)(a1 + 324);
    if ( v4 > Rect.bottom || v4 < -Rect.bottom )
    {
      InvalidateRect(*(HWND *)a1, 0, 1);
      result = a2;
      *(_DWORD *)(a1 + 332) += a2;
      *(_DWORD *)(a1 + 336) += v4;
    }
    else
    {
      v7 = *(HWND *)a1;
      v8 = -(signed int)a2;
      v11 = &Rect;
      v14 = a3 | 6;
      dy = 56;
      v6 = 1;
      v9 = -v4;
      v10 = 0;
      v12 = 0;
      v13 = 0;
      v15 = ListView_RScroll2_SmoothScroll;
      result = SmoothScrollWindow((int)&dy);
    }
    if ( (_DWORD)a2 )
    {
      GetWindowRect(*(HWND *)(a1 + 320), &v17);
      MapWindowPoints(0, *(HWND *)a1, (LPPOINT)&v17, 2u);
      result = SetWindowPos(
                 *(HWND *)(a1 + 320),
                 0,
                 v17.left - a2,
                 v17.top,
                 a2 + v17.right - v17.left,
                 v17.bottom - v17.top,
                 0x14u);
    }
  }
  return result;
}

//----- (6F7D12B9) --------------------------------------------------------
signed int __stdcall ListView_ROnEnsureVisible(int a1, int a2, int a3)
{
  int v3; // edx@1
  signed int v4; // edi@1
  int v5; // eax@1
  int v6; // ecx@3
  __int64 v7; // ST04_8@7

  v3 = *(_DWORD *)(a1 + 324);
  v4 = *(_DWORD *)(a1 + 188);
  v5 = v3 + a2 * *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 336);
  if ( v5 < v3 || v4 + v5 > *(_DWORD *)(a1 + 124) )
  {
    v6 = a2 * *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 336);
    if ( v6 >= 0 )
    {
      v6 = v5 + v4 - *(_DWORD *)(a1 + 124);
      if ( v6 < 0 )
        v6 = 0;
    }
    if ( v6 )
    {
      HIDWORD(v7) = (v6 + (v4 - 1) * (2 * (v6 > 0) - 1)) / v4;
      LODWORD(v7) = 0;
      ListView_RScroll2(a1, v7, 0);
      if ( (*(_BYTE *)(a1 + 44) & 0x12) == 18 )
      {
        ListView_UpdateScrollBars((HDC)a1);
      }
      else
      {
        ListView_DeleteHrgnInval(a1);
        *(_DWORD *)(a1 + 44) |= 4u;
        *(_DWORD *)(a1 + 148) = 1;
      }
    }
  }
  return 1;
}

//----- (6F7D1352) --------------------------------------------------------
int __stdcall ListView_ROnScroll(HDC hdc, int a2, int a3, int code)
{
  int v4; // eax@1

  v4 = 1;
  if ( code != 1 )
    v4 = *((_DWORD *)hdc + 22);
  return ListView_ComOnScroll(hdc, a2, a3, code, v4, -1);
}

//----- (6F7D1380) --------------------------------------------------------
signed int __stdcall ListView_RGetScrollUnitsPerLine(int a1, int a2)
{
  signed int result; // eax@1

  result = 1;
  if ( a2 != 1 )
    result = *(_DWORD *)(a1 + 88);
  return result;
}

//----- (6F7D139C) --------------------------------------------------------
int __stdcall ListView_RApproximateViewRect(int a1, int a2, int a3, int a4)
{
  char v5; // [sp+4h] [bp-10h]@1
  int v6; // [sp+Ch] [bp-8h]@1
  int v7; // [sp+10h] [bp-4h]@1

  ListView_RGetRects(a1, a2, 0, 0, (int)&v5, 0);
  return (unsigned __int16)(*(_WORD *)(a1 + 332) + v6) | ((unsigned __int16)(*(_WORD *)(a1 + 336) + v7) << 16);
}

//----- (6F7D13E1) --------------------------------------------------------
LRESULT __stdcall ListView_OnInsertColumnA(int a1, WPARAM wParam, int a3)
{
  void *v3; // edi@1
  LPCSTR v5; // eax@5
  LRESULT v6; // ebx@8
  int v7; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v7 = 0;
  if ( !a3 )
    return -1;
  if ( *(_BYTE *)a3 & 4 && *(_DWORD *)(a3 + 12) )
  {
    v7 = *(_DWORD *)(a3 + 12);
    v5 = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a3 + 12));
    v3 = (void *)v5;
    if ( !v5 )
      return -1;
    *(_DWORD *)(a3 + 12) = v5;
  }
  v6 = ListView_OnInsertColumn(a1, wParam, a3);
  if ( v3 )
  {
    *(_DWORD *)(a3 + 12) = v7;
    FreeProducedString(v3);
  }
  return v6;
}

//----- (6F7D144E) --------------------------------------------------------
int __stdcall ListView_OnDeleteColumn(int a1, WPARAM wParam)
{
  INT_PTR v2; // edi@1
  signed int v3; // eax@2
  WPARAM v4; // eax@5
  INT_PTR v5; // ebx@9
  struct _DPA *v6; // eax@13
  int v8; // [sp+8h] [bp-30h]@10
  INT_PTR v9; // [sp+Ch] [bp-2Ch]@10
  int v10; // [sp+10h] [bp-28h]@10
  int v11; // [sp+14h] [bp-24h]@10
  int v12; // [sp+18h] [bp-20h]@10
  int v13; // [sp+1Ch] [bp-1Ch]@10
  int v14; // [sp+24h] [bp-14h]@10
  int v15; // [sp+30h] [bp-8h]@10
  __int16 v16; // [sp+34h] [bp-4h]@10
  unsigned __int16 v17; // [sp+36h] [bp-2h]@10

  v2 = 0;
  if ( (wParam & 0x80000000) != 0 )
    return 0;
  v3 = *(_DWORD *)(a1 + 312);
  if ( (signed int)wParam >= v3 )
    return 0;
  if ( !*(_DWORD *)(a1 + 316) )
    goto LABEL_14;
  if ( (signed int)wParam <= 0 )
  {
    if ( *(_DWORD *)(a1 + 28) < 5 || v3 <= 1 || *(_DWORD *)(a1 + 8) & 0x1000 )
      goto LABEL_14;
    v5 = *(_DWORD *)(a1 + 372);
    if ( v5 > 0 )
    {
      do
      {
        ListView_GetSubItem(a1, v2, 1, (int)&v15);
        v10 = 0;
        v12 = -1;
        v14 = v16;
        v13 = v15;
        v11 = v17;
        v9 = v2;
        v8 = 3;
        ListView_OnSetItem(a1, (INT_PTR)&v8);
        ++v2;
      }
      while ( v2 < v5 );
    }
    v4 = 1;
  }
  else
  {
    v4 = wParam;
  }
  if ( (signed int)v4 > 0 )
  {
    v6 = (struct _DPA *)DPA_DeletePtr(*(HDPA *)(a1 + 316), v4 - 1);
    DPA_DestroyCallback(v6, ListView_FreeColumnData, 0);
  }
LABEL_14:
  if ( !SendMessageW(*(HWND *)(a1 + 320), 0x1202u, wParam, 0) )
    return 0;
  --*(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 328) = 0x7FFFFFFF;
  ListView_UpdateScrollBars((HDC)a1);
  if ( (*(_DWORD *)(a1 + 8) & 3) == 1 && (*(_BYTE *)(a1 + 44) & 0x12) == 18 )
    RedrawWindow(*(HWND *)a1, 0, 0, 5u);
  return 1;
}

//----- (6F7D156E) --------------------------------------------------------
BOOL __stdcall hasVertScroll(int a1)
{
  int v1; // edi@1
  char v3; // [sp+8h] [bp-20h]@1
  int v4; // [sp+10h] [bp-18h]@1
  int v5; // [sp+14h] [bp-14h]@3
  int v6; // [sp+18h] [bp-10h]@1
  int v7; // [sp+20h] [bp-8h]@1

  v1 = 0;
  ListView_GetClientRect(a1, (int)&v3, 0, 0);
  ListView_RGetRects(a1, 0, 0, 0, (int)&v6, 0);
  if ( v7 - v6 > v4 )
    v1 = ListView_GetCyScrollbar(a1);
  return (v5 - *(_DWORD *)(a1 + 324) - v1) / *(_DWORD *)(a1 + 188) < *(_DWORD *)(a1 + 372);
}

//----- (6F7D15D4) --------------------------------------------------------
LRESULT __stdcall ListView_RSetColumnWidth(int a1, WPARAM wParam, int a3)
{
  int v3; // ebx@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // eax@4
  HWND v7; // ST00_4@13
  HDC v8; // ebx@14
  int v9; // eax@14
  int v10; // edi@20
  signed int v11; // edi@21
  int v12; // eax@21
  int v13; // eax@33
  int v14; // ecx@36
  LONG v15; // eax@36
  bool v16; // zf@36
  bool v17; // sf@36
  unsigned __int8 v18; // of@36
  int v19; // eax@41
  HWND v20; // ST00_4@45
  LPARAM v22; // [sp+Ch] [bp-31Ch]@28
  HDC hdc; // [sp+1Ch] [bp-30Ch]@33
  LPARAM v24; // [sp+60h] [bp-2C8h]@45
  LONG v25; // [sp+64h] [bp-2C4h]@43
  LPARAM v26; // [sp+8Ch] [bp-29Ch]@13
  LPCWSTR lpString; // [sp+94h] [bp-294h]@13
  int v28; // [sp+9Ch] [bp-28Ch]@13
  int v29; // [sp+A0h] [bp-288h]@14
  int v30; // [sp+B8h] [bp-270h]@6
  int v31; // [sp+C0h] [bp-268h]@8
  LPARAM lParam; // [sp+C8h] [bp-260h]@4
  int v33; // [sp+D0h] [bp-258h]@4
  int v34; // [sp+D8h] [bp-250h]@28
  int v35; // [sp+DCh] [bp-24Ch]@30
  WPARAM v36; // [sp+E0h] [bp-248h]@30
  int v37; // [sp+E8h] [bp-240h]@30
  LPCWSTR v38; // [sp+ECh] [bp-23Ch]@30
  int v39; // [sp+F0h] [bp-238h]@30
  int v40; // [sp+F4h] [bp-234h]@30
  int v41; // [sp+FCh] [bp-22Ch]@30
  HGDIOBJ h; // [sp+100h] [bp-228h]@14
  struct tagSIZE sz; // [sp+104h] [bp-224h]@1
  LONG v44; // [sp+10Ch] [bp-21Ch]@1
  LONG v45; // [sp+110h] [bp-218h]@1
  char v46; // [sp+114h] [bp-214h]@13

  v3 = 0;
  sz.cx = 0;
  sz.cy = 0;
  v4 = a3;
  v44 = 0;
  v45 = 0;
  if ( a3 > -1 )
  {
LABEL_44:
    v25 = v4;
    goto LABEL_45;
  }
  if ( a3 == -2 )
  {
    v5 = *(_DWORD *)(a1 + 312);
    if ( v5 == 1 )
    {
      ListView_GetClientRect(a1, (int)&lParam, 0, 0);
      v6 = v33 - lParam;
    }
    else
    {
      if ( wParam != v5 - 1 )
        goto LABEL_13;
      ListView_GetClientRect(a1, (int)&v30, 0, 0);
      if ( !SendMessageW(*(HWND *)(a1 + 320), 0x1207u, *(_DWORD *)(a1 + 312) - 2, (LPARAM)&lParam) )
        v33 = 0;
      if ( v33 >= v31 - v30 )
        goto LABEL_13;
      v6 = v31 - v30 - v33;
    }
    v45 = v6;
    if ( v6 && hasVertScroll(a1) )
      v45 -= g_cxVScroll;
LABEL_13:
    lpString = (LPCWSTR)&v46;
    v26 = 6;
    v7 = *(HWND *)(a1 + 320);
    v28 = 264;
    if ( SendMessageW(v7, 0x120Bu, wParam, (LPARAM)&v26) )
    {
      v8 = GetDC(*(HWND *)a1);
      h = SelectObject(v8, *(HGDIOBJ *)(a1 + 56));
      v9 = lstrlenW(lpString);
      GetTextExtentPointW(v8, lpString, v9, &sz);
      sz.cx += 6 * g_cxLabelMargin;
      if ( v29 & 0x800 )
        sz.cx += 6 * g_cxLabelMargin + *(_DWORD *)(a1 + 172);
      if ( v45 <= sz.cx )
        v45 = sz.cx;
      SelectObject(v8, h);
      ReleaseDC(*(HWND *)a1, v8);
    }
    v3 = 0;
  }
  v10 = *(_DWORD *)(a1 + 372);
  if ( *(_DWORD *)(a1 + 8) & 0x1000 )
  {
    v11 = *(_DWORD *)(a1 + 188);
    v3 = (*(_DWORD *)(a1 + 336) - *(_DWORD *)(a1 + 324)) / v11;
    v12 = (*(_DWORD *)(a1 + 336) - *(_DWORD *)(a1 + 324) + *(_DWORD *)(a1 + 124)) / v11 + 1;
    if ( v3 < 0 )
      v3 = 0;
    if ( v12 <= v3 + 1 )
      v12 = v3 + 1;
    if ( v12 >= *(_DWORD *)(a1 + 372) )
      v12 = *(_DWORD *)(a1 + 372);
    v10 = v12;
    ListView_NotifyCacheHint(a1, v3, v12 - 1);
  }
  ListView_BeginFakeCustomDraw(a1, (LPARAM)&v22, (int)&v34);
  v34 = 7;
  if ( !wParam )
    v34 = 23;
  while ( v3 < v10 )
  {
    v40 = -1;
    v41 = 0;
    v37 = 0;
    v36 = wParam;
    v38 = (LPCWSTR)&v46;
    v35 = v3;
    v39 = 264;
    ListView_OnGetItem(v10, (HDPA)a1, (int)&v34);
    if ( v38 || v40 != -1 )
    {
      sz.cx = 0;
      if ( v38 )
      {
        ListView_BeginFakeItemDraw((LPARAM)&v22);
        v13 = lstrlenW(v38);
        GetTextExtentPointW(hdc, v38, v13, &sz);
        ListView_EndFakeItemDraw((LPARAM)&v22);
      }
      if ( v40 != -1 )
        sz.cx += g_cxEdge + *(_DWORD *)(a1 + 172);
      v14 = v41 * *(_DWORD *)(a1 + 172);
      v15 = v14 + sz.cx;
      v18 = __OFSUB__(v44, v14 + sz.cx);
      v16 = v44 == v14 + sz.cx;
      v17 = v44 - (v14 + sz.cx) < 0;
      sz.cx += v14;
      if ( (unsigned __int8)(v17 ^ v18) | v16 )
        v44 = v15;
    }
    ++v3;
  }
  ListView_EndFakeCustomDraw((LPARAM)&v22);
  if ( wParam )
    v19 = 6 * g_cxLabelMargin;
  else
    v19 = g_cxEdge + *(_DWORD *)(a1 + 356) + 2 * g_cxLabelMargin;
  v44 += v19;
  v4 = v45;
  v25 = v44;
  if ( v45 > v44 )
    goto LABEL_44;
LABEL_45:
  *(_DWORD *)(a1 + 328) = 0x7FFFFFFF;
  v20 = *(HWND *)(a1 + 320);
  v24 = 1;
  return SendMessageW(v20, 0x120Cu, wParam, (LPARAM)&v24);
}
// 6F7E697C: using guessed type int g_cxLabelMargin;
// 6F7E69A8: using guessed type int g_cxVScroll;

//----- (6F7D19B1) --------------------------------------------------------
int __stdcall ListView_OnGetColumnA(int a1, WPARAM wParam, int a3)
{
  int v3; // esi@1
  const WCHAR *v4; // edi@1
  const WCHAR *v6; // eax@5
  LRESULT v7; // eax@7
  int v8; // eax@9
  CHAR *lpMultiByteStr; // [sp+8h] [bp-4h]@1
  int v10; // [sp+1Ch] [bp+10h]@7

  v3 = a3;
  v4 = 0;
  lpMultiByteStr = 0;
  if ( !a3 )
    return 0;
  if ( *(_BYTE *)a3 & 4 && *(_DWORD *)(a3 + 12) )
  {
    lpMultiByteStr = *(CHAR **)(a3 + 12);
    v6 = (const WCHAR *)CCLocalAllocArray_WCHAR(*(_DWORD *)(a3 + 16));
    v4 = v6;
    if ( !v6 )
      return 0;
    *(_DWORD *)(a3 + 12) = v6;
  }
  v7 = ListView_OnGetColumn(a1, wParam, a3);
  v10 = v7;
  if ( v4 )
  {
    if ( v7 )
    {
      v8 = *(_DWORD *)(v3 + 16);
      if ( v8 )
        WideCharToMultiByte(*(_DWORD *)(a1 + 20), 0, v4, -1, lpMultiByteStr, v8, 0, 0);
    }
    *(_DWORD *)(v3 + 12) = lpMultiByteStr;
    LocalFree((HLOCAL)v4);
  }
  return v10;
}
// 6F793FC0: using guessed type _DWORD __stdcall CCLocalAllocArray_WCHAR(_DWORD);

//----- (6F7D1A3A) --------------------------------------------------------
LPCSTR __stdcall ListView_OnSetColumnA(int a1, WPARAM wParam, int a3)
{
  void *v3; // edi@1
  LPCSTR result; // eax@2
  int v5; // ebx@7
  int v6; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v6 = 0;
  if ( !a3 )
    return 0;
  if ( *(_BYTE *)a3 & 4 && *(_DWORD *)(a3 + 12) )
  {
    v6 = *(_DWORD *)(a3 + 12);
    result = ProduceWFromA(*(_DWORD *)(a1 + 20), *(LPCSTR *)(a3 + 12));
    v3 = (void *)result;
    if ( !result )
      return result;
    *(_DWORD *)(a3 + 12) = result;
  }
  v5 = ListView_OnSetColumn(a1, wParam, a3);
  if ( v3 )
  {
    *(_DWORD *)(a3 + 12) = v6;
    FreeProducedString(v3);
  }
  return (LPCSTR)v5;
}

//----- (6F7D1AA1) --------------------------------------------------------
int __stdcall ListView_HeaderNotify(HDC hdc, LPARAM a2)
{
  unsigned int v2; // eax@1
  int v3; // eax@8
  int v4; // esi@9
  HWND v5; // ebx@15
  int result; // eax@17
  int v7; // eax@22
  int v8; // esi@23
  WPARAM v9; // ST0C_4@23
  LPARAM lParam; // [sp+Ch] [bp-2Ch]@23
  int v11; // [sp+10h] [bp-28h]@23

  v2 = *(_DWORD *)(a2 + 8);
  if ( v2 <= 0xFFFFFEC0 )
  {
    if ( v2 != -320 )
    {
      if ( v2 >= 0xFFFFFEB8 )
      {
        if ( v2 <= 0xFFFFFEB9 )
        {
          v4 = (int)hdc;
          ListView_DismissEdit((int)hdc, 0);
          ListView_RHeaderTrack(hdc, a2);
        }
        else if ( v2 == -325 )
        {
          v4 = (int)hdc;
          ListView_DismissEdit((int)hdc, 0);
          ListView_RSetColumnWidth((int)hdc, *(_DWORD *)(a2 + 12), -1);
        }
        else
        {
          if ( v2 != -322 )
          {
            if ( v2 == -321 )
            {
              v3 = **(_DWORD **)(a2 + 20);
              if ( v3 & 1 )
              {
                v4 = (int)hdc;
                ListView_DismissEdit((int)hdc, 0);
                if ( *(_DWORD *)(a2 + 12) == *((_DWORD *)hdc + 85) )
                  ListView_AdjustColumn(hdc, *(_DWORD *)(*(_DWORD *)(a2 + 20) + 4));
                else
                  RedrawWindow(*(HWND *)hdc, 0, 0, 5u);
                *((_DWORD *)hdc + 85) = -1;
                goto LABEL_15;
              }
              if ( v3 & 0x100 )
              {
                v4 = (int)hdc;
LABEL_15:
                v5 = ListView_ForwardHeaderNotify(v4, a2);
                goto LABEL_16;
              }
            }
            goto LABEL_39;
          }
          v4 = (int)hdc;
          ListView_DismissEdit((int)hdc, 0);
          ListView_Notify((int)hdc, -1, *(_DWORD *)(a2 + 12), -108);
        }
        v5 = ListView_ForwardHeaderNotify(v4, a2);
        SetFocus(*(HWND *)v4);
LABEL_16:
        if ( *(_DWORD *)(v4 + 28) >= 5 )
          return (int)v5;
        return 0;
      }
LABEL_39:
      v8 = (int)hdc;
      if ( *((_DWORD *)hdc + 7) < 5 )
        return 0;
      return (int)ListView_ForwardHeaderNotify(v8, a2);
    }
    v7 = **(_DWORD **)(a2 + 20);
    if ( v7 & 1 )
    {
      v8 = (int)hdc;
      v9 = *(_DWORD *)(a2 + 12);
      lParam = 1;
      SendMessageW(*((HWND *)hdc + 80), 0x120Bu, v9, (LPARAM)&lParam);
      *((_DWORD *)hdc + 85) = *(_DWORD *)(a2 + 12);
      *((_DWORD *)hdc + 86) = v11;
      return (int)ListView_ForwardHeaderNotify(v8, a2);
    }
    if ( !(v7 & 0x100) )
      goto LABEL_39;
    return (int)ListView_ForwardHeaderNotify((int)hdc, a2);
  }
  if ( v2 < 0xFFFFFEC7 )
    goto LABEL_39;
  if ( v2 <= 0xFFFFFEC8 )
    return (int)ListView_ForwardHeaderNotify((int)hdc, a2);
  if ( v2 == -311 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 20) + 32) == -1 )
      goto LABEL_39;
    v8 = (int)hdc;
    InvalidateRect(*(HWND *)hdc, 0, 1);
    return (int)ListView_ForwardHeaderNotify(v8, a2);
  }
  if ( v2 != -310 )
  {
    if ( v2 == -5 )
      return (int)SendNotifyEx(*((_DWORD *)hdc + 1), *((HWND *)hdc + 80), -5, 0, *((_DWORD *)hdc + 4) & 1);
    goto LABEL_39;
  }
  if ( *((_BYTE *)hdc + 48) & 0x10 )
    result = (int)ListView_ForwardHeaderNotify((int)hdc, a2);
  else
    result = 1;
  return result;
}

//----- (6F7D1C89) --------------------------------------------------------
int __stdcall ListView_RItemHitTest(int a1, LPARAM a2, int a3, int a4, int a5)
{
  int v5; // eax@3
  int v6; // eax@3
  int v7; // edi@3
  bool v8; // zf@14
  int v9; // eax@15
  __int16 v10; // ax@17
  int v11; // eax@17
  signed int v12; // eax@26
  struct tagRECT v14; // [sp+0h] [bp-38h]@6
  int v15; // [sp+10h] [bp-28h]@6
  int v16; // [sp+18h] [bp-20h]@17
  int v17; // [sp+20h] [bp-18h]@6
  LPARAM v18; // [sp+28h] [bp-10h]@10
  int v19; // [sp+30h] [bp-8h]@3
  int v20; // [sp+34h] [bp-4h]@3

  if ( a5 )
    *(_DWORD *)a5 = 0;
  v5 = *(_DWORD *)(a1 + 336) - *(_DWORD *)(a1 + 324);
  v19 = -1;
  v6 = (a3 + v5) / *(_DWORD *)(a1 + 188);
  v20 = 1;
  v7 = v6;
  if ( (unsigned int)v6 >= *(_DWORD *)(a1 + 372) )
    goto LABEL_29;
  if ( *(_DWORD *)(a1 + 8) & 0x400 )
  {
    v20 = 14;
    v19 = v6;
    goto LABEL_29;
  }
  ListView_GetRects(a1, v6, (int)&v17, (int)&v15, 0, &v14);
  if ( a2 < v17 - g_cxEdge && a2 > v17 - *(_DWORD *)(a1 + 356) )
  {
    v20 = 8;
    goto LABEL_28;
  }
  if ( a2 >= v17 && a2 < v18 )
  {
    v20 = 2;
    goto LABEL_28;
  }
  if ( a2 < v15 )
  {
    if ( a2 < v14.right && *(_BYTE *)(a1 + 48) & 0x20 )
    {
      v20 = 14;
      goto LABEL_28;
    }
    goto LABEL_25;
  }
  if ( a2 >= v14.right )
  {
LABEL_25:
    if ( !a5 )
      goto LABEL_29;
LABEL_26:
    v12 = ListView_RXHitTest(a1, a2);
    if ( v12 < 0 )
      goto LABEL_29;
    *(_DWORD *)a5 = v12;
LABEL_28:
    v19 = v7;
    goto LABEL_29;
  }
  v8 = (*(_BYTE *)(a1 + 48) & 0x20) == 0;
  v19 = v7;
  v20 = 4;
  if ( !v8 )
  {
    v9 = 0;
    if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
      v9 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v7);
    v10 = ListView_RGetCXLabel(a1, v7, v9, 0, 0);
    v11 = v15 + v10;
    if ( v11 >= v16 )
      v11 = v16;
    if ( a2 >= v11 )
    {
      if ( !a5 )
      {
        v20 = 14;
        goto LABEL_29;
      }
      goto LABEL_26;
    }
  }
LABEL_29:
  *(_DWORD *)a4 = v20;
  return v19;
}

//----- (6F7D1DDB) --------------------------------------------------------
int __stdcall ListView_RGetRectsEx(int a1, int a2, WPARAM wParam, int a4, int a5)
{
  int result; // eax@2
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // esi@3
  int v9; // edi@4
  int v10; // ecx@7
  int v11; // ecx@7
  int v12; // edi@8
  int v13; // edi@10
  LPARAM lParam; // [sp+0h] [bp-20h]@7
  int v15; // [sp+4h] [bp-1Ch]@7
  LPARAM v16; // [sp+8h] [bp-18h]@7
  int v17; // [sp+Ch] [bp-14h]@7
  LPARAM v18; // [sp+10h] [bp-10h]@7
  int v19; // [sp+14h] [bp-Ch]@7
  LPARAM v20; // [sp+18h] [bp-8h]@7
  int v21; // [sp+1Ch] [bp-4h]@7

  if ( wParam )
  {
    v6 = *(_DWORD *)(a1 + 188);
    v7 = *(_DWORD *)(a1 + 324) + a2 * *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 336);
    v8 = -*(_DWORD *)(a1 + 332);
    if ( v7 < 0x7FFFFFFF - v6 )
    {
      v9 = 2147483648;
      if ( v7 >= (signed int)2147483648 )
        v9 = *(_DWORD *)(a1 + 324) + a2 * *(_DWORD *)(a1 + 188) - *(_DWORD *)(a1 + 336);
    }
    else
    {
      v9 = 0x7FFFFFFF - v6;
    }
    SendMessageW(*(HWND *)(a1 + 320), 0x1207u, wParam, (LPARAM)&lParam);
    v20 = v8 + v16;
    v10 = v9 + *(_DWORD *)(a1 + 188);
    v19 = v9;
    v21 = v10;
    v11 = *(_DWORD *)(a1 + 172);
    v18 = v8 + lParam;
    lParam += v8;
    result = lParam;
    v15 = v9;
    v17 = v21;
    v16 = lParam + v11;
    if ( a4 )
    {
      *(_DWORD *)a4 = lParam;
      *(_DWORD *)(a4 + 4) = v15;
      v12 = a4 + 8;
      *(_DWORD *)v12 = v16;
      *(_DWORD *)(v12 + 4) = v17;
    }
    if ( a5 )
    {
      *(_DWORD *)a5 = v18;
      *(_DWORD *)(a5 + 4) = v19;
      v13 = a5 + 8;
      *(_DWORD *)v13 = v20;
      *(_DWORD *)(v13 + 4) = v21;
    }
  }
  else
  {
    result = ListView_RGetRects(a1, a2, a4, a5, 0, 0);
  }
  return result;
}

//----- (6F7D1EB7) --------------------------------------------------------
int __stdcall ListView_OnGetSubItemRect(int a1, int a2, LPRECT lprcDst)
{
  int result; // eax@2
  LONG v4; // eax@3
  LONG v5; // esi@3
  RECT rcSrc2; // [sp+4h] [bp-10h]@9

  if ( lprcDst )
  {
    v4 = lprcDst->top;
    v5 = lprcDst->left;
    if ( v4 )
    {
      if ( (*(_DWORD *)(a1 + 8) & 3) != 1 || v5 && v5 != 1 && v5 != 2 )
      {
        result = 0;
      }
      else
      {
        rcSrc2.top = (LONG)&rcSrc2;
        rcSrc2.right = (LONG)&rcSrc2;
        if ( v5 )
          *(&rcSrc2.left + v5) = (LONG)lprcDst;
        else
          rcSrc2.top = (LONG)lprcDst;
        ListView_RGetRectsEx(a1, a2, v4, rcSrc2.top, rcSrc2.right);
        if ( !v5 )
          UnionRect(lprcDst, lprcDst, &rcSrc2);
        result = 1;
      }
    }
    else
    {
      result = ListView_OnGetItemRect(a1, a2, lprcDst);
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7D1F47) --------------------------------------------------------
int __stdcall ListView_OnSubItemHitTest(HDC hdc, int a2)
{
  int v2; // esi@1
  int result; // eax@1
  signed int v4; // ebx@1
  signed int v5; // eax@3
  int v6; // eax@9
  int v7; // [sp+8h] [bp-24h]@9
  int v8; // [sp+10h] [bp-1Ch]@13
  int v9; // [sp+18h] [bp-14h]@9
  int v10; // [sp+20h] [bp-Ch]@10
  int v11; // [sp+28h] [bp-4h]@1
  int v12; // [sp+38h] [bp+Ch]@3

  v2 = a2;
  result = -1;
  v4 = -1;
  v11 = 1;
  if ( a2 )
  {
    if ( (*((_DWORD *)hdc + 2) & 3) != 1 )
    {
LABEL_5:
      ListView_OnHitTest(hdc, v2);
      *(_DWORD *)(v2 + 16) = 0;
      return *(_DWORD *)(v2 + 12);
    }
    v5 = ListView_RXHitTest((int)hdc, *(_DWORD *)a2);
    v12 = v5;
    if ( v5 != -1 )
    {
      if ( !v5 )
        goto LABEL_5;
      if ( (*((_DWORD *)hdc + 2) & 3) == 1 )
      {
        v4 = (*(_DWORD *)(v2 + 4) + *((_DWORD *)hdc + 84) - *((_DWORD *)hdc + 81)) / *((_DWORD *)hdc + 47);
        if ( v4 >= *((_DWORD *)hdc + 93) )
        {
          v4 = -1;
        }
        else if ( v4 != -1 )
        {
          ListView_RGetRectsEx((int)hdc, v4, v5, (int)&v9, (int)&v7);
          v6 = *(_DWORD *)v2;
          if ( *(_DWORD *)v2 < v9 || v6 > v10 )
          {
            if ( v6 < v7 || v6 > v8 )
              v11 = 14;
            else
              v11 = 4;
          }
          else
          {
            v11 = 2;
          }
        }
      }
    }
    *(_DWORD *)(v2 + 16) = v12;
    *(_DWORD *)(v2 + 8) = v11;
    *(_DWORD *)(v2 + 12) = v4;
    result = v4;
  }
  return result;
}

//----- (6F7D2030) --------------------------------------------------------
int __stdcall ListView_RUpdateScrollBars(int a1)
{
  int v1; // esi@1
  int v2; // eax@6
  signed int v3; // edi@8
  int v4; // eax@9
  int v5; // eax@11
  signed int v6; // ecx@14
  int v7; // eax@14
  int v8; // eax@14
  int result; // eax@20
  char v10; // [sp+8h] [bp-70h]@3
  HWND hWndInsertAfter; // [sp+Ch] [bp-6Ch]@3
  int X; // [sp+10h] [bp-68h]@3
  int Y; // [sp+14h] [bp-64h]@3
  int v14; // [sp+18h] [bp-60h]@3
  int cy; // [sp+1Ch] [bp-5Ch]@3
  int v16; // [sp+20h] [bp-58h]@3
  struct tagSCROLLINFO psi; // [sp+24h] [bp-54h]@14
  int v18; // [sp+40h] [bp-38h]@3
  int v19; // [sp+48h] [bp-30h]@5
  int v20; // [sp+50h] [bp-28h]@1
  int v21; // [sp+54h] [bp-24h]@4
  int v22; // [sp+58h] [bp-20h]@5
  int v23; // [sp+5Ch] [bp-1Ch]@8
  LPARAM lParam; // [sp+60h] [bp-18h]@3
  char *v25; // [sp+64h] [bp-14h]@3
  __int64 v26; // [sp+68h] [bp-10h]@1
  int v27; // [sp+70h] [bp-8h]@5
  int v28; // [sp+74h] [bp-4h]@1
  int v29; // [sp+80h] [bp+8h]@5

  v1 = a1;
  v26 = 0i64;
  v28 = 0;
  ListView_GetClientRect(a1, (int)&v20, 0, 0);
  if ( !*(_DWORD *)(a1 + 320) )
    ListView_CreateHeader(a1);
  v25 = &v10;
  v20 -= *(_DWORD *)(a1 + 332);
  lParam = (LPARAM)&v20;
  SendMessageW(*(HWND *)(a1 + 320), 0x1205u, 0, (LPARAM)&lParam);
  v20 += *(_DWORD *)(a1 + 332);
  SetWindowPos(*(HWND *)(a1 + 320), hWndInsertAfter, X, Y, v14, cy, v16 | 0x40);
  ListView_RGetRects(a1, 0, 0, 0, (int)&v18, 0);
  if ( *(_DWORD *)(a1 + 28) >= 3 )
    v21 += g_cyEdge;
  *(_DWORD *)(a1 + 324) = v21;
  v27 = v19 - v18;
  v29 = v19 - v18 > v22;
  if ( v19 - v18 > v22 )
    v2 = ListView_GetCyScrollbar(v1);
  else
    v2 = 0;
  v3 = v23 - v2 - v21;
  if ( v3 < *(_DWORD *)(v1 + 188) * *(_DWORD *)(v1 + 372) )
  {
    v4 = ListView_GetCxScrollbar(v1);
    v22 -= v4;
    if ( !v29 )
    {
      if ( v27 <= v22 )
        v5 = 0;
      else
        v5 = ListView_GetCyScrollbar(v1);
      v3 = v23 - v5 - v21;
    }
  }
  v6 = *(_DWORD *)(v1 + 188);
  v7 = *(_DWORD *)(v1 + 336) / v6;
  psi.cbSize = 28;
  psi.fMask = 7;
  psi.nMin = 0;
  psi.nPos = v7;
  psi.nPage = v3 / v6;
  psi.nMax = *(_DWORD *)(v1 + 372) - 1;
  ListView_SetScrollInfo(v1, 1, &psi, 1);
  v8 = psi.nMax - psi.nPage + 1;
  if ( psi.nPos > v8 && psi.nPos > 0 )
  {
    if ( v8 < 0 )
      v8 = 0;
    if ( v8 != psi.nPos )
    {
      HIDWORD(v26) = v8 - psi.nPos;
      v28 = 1;
    }
  }
  psi.nPos = *(_DWORD *)(v1 + 332);
  psi.nPage = v22 - v20;
  psi.nMax = v27 - 1;
  ListView_SetScrollInfo(v1, 0, &psi, 1);
  result = psi.nMax;
  if ( psi.nPage > psi.nMax && (*(_DWORD *)(v1 + 412) && *(_BYTE *)(v1 + 36) & 0x20 || *(_DWORD *)(v1 + 420)) )
  {
    SetWindowPos(*(HWND *)v1, 0, 0, 0, 0, 0, 0x27u);
    result = psi.nMax;
  }
  if ( (signed int)(psi.nPage + psi.nPos - 1) > result && psi.nPos > 0 )
  {
    result = result - psi.nPage + 1;
    if ( result < 0 )
      result = 0;
    if ( result != psi.nPos )
    {
      result -= psi.nPos;
      LODWORD(v26) = result;
      v28 = 1;
    }
  }
  if ( v28 )
  {
    ListView_RScroll2(v1, v26, 0);
    result = ListView_RUpdateScrollBars(v1);
  }
  return result;
}

//----- (6F7D2248) --------------------------------------------------------
signed int __stdcall ListView_RDrawItem(int a1)
{
  int v1; // esi@1
  int v2; // ST10_4@1
  int v3; // eax@2
  int v5; // ecx@7
  int v6; // ST20_4@8
  HWND v7; // ST14_4@12
  WPARAM v8; // edi@13
  int v9; // edi@16
  unsigned int v10; // eax@16
  bool v11; // zf@16
  int v12; // eax@16
  int v13; // eax@20
  LONG v14; // edi@31
  int v15; // edi@34
  int v16; // eax@42
  LONG v17; // eax@44
  LONG v18; // eax@46
  int v19; // edi@50
  int v20; // eax@51
  HGDIOBJ v21; // eax@57
  int v22; // edi@64
  COLORREF v23; // ST20_4@73
  HWND v24; // ST20_4@79
  int v25; // eax@79
  int v26; // ecx@79
  int v27; // ecx@79
  int v28; // ebx@79
  LPARAM lParam; // [sp+Ch] [bp-324h]@15
  int v30; // [sp+20h] [bp-310h]@66
  LPARAM v31; // [sp+38h] [bp-2F8h]@16
  int v32; // [sp+40h] [bp-2F0h]@16
  LPCWSTR v33; // [sp+48h] [bp-2E8h]@43
  LPARAM v34; // [sp+54h] [bp-2DCh]@79
  WPARAM Dst; // [sp+58h] [bp-2D8h]@79
  int v36; // [sp+5Ch] [bp-2D4h]@79
  int v37; // [sp+60h] [bp-2D0h]@79
  int v38; // [sp+64h] [bp-2CCh]@82
  int v39; // [sp+68h] [bp-2C8h]@79
  int v40; // [sp+6Ch] [bp-2C4h]@79
  RECT v41; // [sp+70h] [bp-2C0h]@79
  int v42; // [sp+80h] [bp-2B0h]@80
  struct tagRECT rcDst; // [sp+84h] [bp-2ACh]@5
  int i; // [sp+94h] [bp-29Ch]@13
  int v45; // [sp+98h] [bp-298h]@9
  WPARAM v46; // [sp+9Ch] [bp-294h]@13
  int v47; // [sp+A0h] [bp-290h]@9
  int v48; // [sp+A4h] [bp-28Ch]@9
  LPCWSTR lpString; // [sp+A8h] [bp-288h]@13
  int v50; // [sp+ACh] [bp-284h]@13
  int v51; // [sp+B0h] [bp-280h]@13
  struct tagSIZE sz; // [sp+BCh] [bp-274h]@64
  int v53; // [sp+C4h] [bp-26Ch]@1
  RECT rcSrc1; // [sp+C8h] [bp-268h]@1
  LONG v55; // [sp+D8h] [bp-258h]@38
  struct tagRECT rc; // [sp+DCh] [bp-254h]@15
  int v57; // [sp+ECh] [bp-244h]@1
  int v58; // [sp+F0h] [bp-240h]@1
  int dy; // [sp+F4h] [bp-23Ch]@1
  RECT rcSrc2; // [sp+F8h] [bp-238h]@15
  HGDIOBJ h; // [sp+108h] [bp-228h]@50
  WPARAM wParam; // [sp+10Ch] [bp-224h]@1
  unsigned int v63; // [sp+110h] [bp-220h]@12
  int v64; // [sp+114h] [bp-21Ch]@31
  int v65; // [sp+118h] [bp-218h]@38
  WPARAM v66; // [sp+11Ch] [bp-214h]@1
  char v67[4]; // [sp+120h] [bp-210h]@13
  char v68; // [sp+124h] [bp-20Ch]@13

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 60);
  v57 = 0;
  v53 = v1;
  wParam = 0;
  v66 = 0;
  v58 = 0;
  dy = 0;
  ListView_RGetRects(v1, v2, 0, 0, (int)&rcSrc1, 0);
  if ( rcSrc1.bottom <= *(_DWORD *)(v1 + 324) )
    return 1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( v3 )
  {
    if ( rcSrc1.top >= *(_DWORD *)(v3 + 12) )
      return 0;
    if ( !IntersectRect(&rcDst, &rcSrc1, *(const RECT **)(a1 + 8)) )
      return 1;
  }
  if ( rcSrc1.top >= *(_DWORD *)(v1 + 124) )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( v5 )
  {
    v6 = *(_DWORD *)(v5 + 4) - rcSrc1.top;
    v58 = *(_DWORD *)v5 - rcSrc1.left;
    dy = v6;
    OffsetRect(&rcSrc1, v58, v6);
  }
  v45 = *(_DWORD *)(a1 + 60);
  v48 = 0xFFFF;
  v47 = 0;
  if ( *(_DWORD *)(v1 + 8) & 0x400 )
    goto LABEL_13;
  SetRectEmpty(&rcDst);
  while ( (signed int)wParam < *(_DWORD *)(v1 + 312) )
  {
    v7 = *(HWND *)(v1 + 320);
    v63 = 0;
    v66 = SendMessageW(v7, 0x120Fu, wParam, 0);
LABEL_13:
    v8 = v66;
    v51 = -1;
    i = v66 != 0 ? 11 : 27;
    lpString = (LPCWSTR)&v68;
    v46 = v66;
    v50 = 260;
    ListView_OnGetItem(v66, (HDPA)v1, (int)&i);
    *(_DWORD *)v67 = *(_DWORD *)(a1 + 12);
    if ( !v8 && *(_DWORD *)(v1 + 8) & 0x400 )
    {
      memset(&Dst, 0, 0x2Cu);
      v24 = *(HWND *)v1;
      v34 = 102;
      v25 = GetDlgCtrlID(v24);
      v26 = *(_DWORD *)v1;
      Dst = v25;
      v36 = *(_DWORD *)(a1 + 60);
      v39 = v26;
      v27 = *(_DWORD *)(a1 + 40);
      v28 = *(_DWORD *)(a1 + 16);
      v37 = 1;
      v40 = v27;
      v41 = rcSrc1;
      if ( v28 )
        v42 = *(_DWORD *)(v28 + 28);
      if ( v47 & 1 )
        v38 |= 0x10u;
      if ( v47 & 2 )
        v38 |= 1u;
      SendMessageW(*(HWND *)(v53 + 4), 0x2Bu, Dst, (LPARAM)&v34);
      return 1;
    }
    lParam = 5;
    SendMessageW(*(HWND *)(v1 + 320), 0x120Bu, v8, (LPARAM)&lParam);
    ListView_RGetRectsEx(v1, *(_DWORD *)(a1 + 60), v8, (int)&rc, (int)&rcSrc2);
    OffsetRect(&rc, v58, dy);
    OffsetRect(&rcSrc2, v58, dy);
    if ( *(_BYTE *)(a1 + 20) & 0x20 )
    {
      v9 = *(_DWORD *)(a1 + 64);
      SendMessageW(*(HWND *)(v1 + 320), 0x1207u, v66, (LPARAM)&v31);
      *(_DWORD *)(a1 + 44) = v31;
      *(_DWORD *)(a1 + 52) = v32;
      *(_DWORD *)(a1 + 80) = v66;
      v10 = CICustomDrawNotify(*(_DWORD *)a1, 196609, a1 + 24);
      v63 = v10;
      v11 = (v10 & 4) == 0;
      v12 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a1 + 64) = v9;
      if ( !v11 )
        goto LABEL_78;
      *(_DWORD *)v67 &= 0xFFFFFF87;
      if ( v12 & 0x10 )
        *(_DWORD *)v67 |= 8u;
      if ( v12 & 1 )
      {
        v13 = *(_DWORD *)a1;
        *(_DWORD *)v67 |= *(_BYTE *)(*(_DWORD *)a1 + 44) & 1 ? 0x10u : 0x20u;
        if ( *(_DWORD *)(v13 + 392) == *(_DWORD *)(a1 + 60) )
          *(_DWORD *)v67 |= 0x40u;
      }
    }
    if ( !v66 )
      goto LABEL_28;
    if ( v51 != -1 )
    {
      rcSrc2.left += *(_DWORD *)(v1 + 172);
LABEL_28:
      if ( v51 != -1 && *(_BYTE *)(v1 + 48) & 0x20 && wParam )
      {
        v14 = rc.right;
        v64 = rc.left;
        if ( !v66 )
          rc.left -= g_cxEdge + *(_DWORD *)(v1 + 356);
        rc.right = rcSrc2.right;
        FillRect(*(HDC *)(a1 + 40), &rc, *(HBRUSH *)(v1 + 76));
        rc.left = v64;
        rc.right = v14;
      }
    }
    v15 = ListView_DrawImageEx((HIMAGELIST)v1, (int)&i, *(HDC *)(a1 + 40), rc.left, rc.top, v67[0], rcSrc2.right);
    if ( *(_BYTE *)(v1 + 48) & 0x20 && v67[0] & 8 )
      UnionRect(&rcDst, &rcDst, &rcSrc2);
    if ( lpString )
    {
      v55 = rcSrc2.right;
      v11 = (*(_BYTE *)(v1 + 48) & 0x20) == 0;
      v65 = v15 | (v66 != 0 ? 66 : 2);
      if ( v11 && (v15 & 0x108 || v47 & 1) )
      {
        if ( v66 )
        {
          v17 = 6 * g_cxLabelMargin + ListView_OnGetStringWidth(v1, lpString, *(HDC *)(a1 + 40));
        }
        else
        {
          v16 = *(_DWORD *)(a1 + 16);
          if ( !v16 )
          {
            v16 = (int)&v33;
            v33 = lpString;
          }
          v17 = (signed __int16)ListView_RGetCXLabel(v1, *(_DWORD *)(a1 + 60), v16, *(_DWORD *)(a1 + 40), 1);
        }
        v18 = rcSrc2.left + v17;
        if ( rcSrc2.right > v18 )
          rcSrc2.right = v18;
      }
      if ( v66 || *(_DWORD *)(v1 + 252) != *(_DWORD *)(a1 + 60) )
      {
        v19 = *(_DWORD *)(a1 + 72);
        h = 0;
        v64 = v19;
        if ( v19 == GetSysColor(26)
          || (v20 = *(_DWORD *)(v1 + 48), v20 & 0x800)
          && (v20 & 0x40
           || *(_BYTE *)(*(_DWORD *)a1 + 48) & 0x80
           && ListView_OnGetItemState(v19, *(struct _DPA **)a1, *(_DWORD *)(a1 + 60), 2)) )
        {
          if ( v66 && !(*(_BYTE *)(v1 + 48) & 0x20) )
          {
            v21 = SelectObject(*(HDC *)(a1 + 40), *(HGDIOBJ *)(v1 + 56));
            h = v21;
            if ( v21 != *(HGDIOBJ *)(v1 + 396) )
            {
              SelectObject(*(HDC *)(a1 + 40), v21);
              h = 0;
            }
            v64 = *(_DWORD *)(v1 + 68);
          }
        }
        if ( v65 & 8 && v67[0] & 0x40 )
          v65 |= 0x200u;
        if ( ((unsigned __int8)v63 | *(_BYTE *)(a1 + 20)) & 2 )
        {
          sz.cx = 0;
          sz.cy = 0;
          GetTextExtentPointW(*(HDC *)(a1 + 40), L"...", 3, &sz);
          v22 = sz.cx;
        }
        else
        {
          v22 = *(_DWORD *)(v1 + 92);
        }
        SHDrawText(
          *(HDC *)(a1 + 40),
          (int)lpString,
          &rcSrc2,
          v30 & 3,
          v65,
          *(_DWORD *)(v1 + 84),
          v22,
          v64,
          *(_DWORD *)(a1 + 76));
        if ( v67[0] & 8 && v47 & 1 && !(CCGetUIState(*(_DWORD *)a1) & 1) )
        {
          if ( *(_BYTE *)(v1 + 48) & 0x20 )
            v57 = 1;
          else
            DrawFocusRect(*(HDC *)(a1 + 40), &rcSrc2);
        }
        if ( rcSrc2.right < v55 )
        {
          v23 = *(_DWORD *)(a1 + 76);
          rcSrc2.left = rcSrc2.right;
          rcSrc2.right = v55;
          SHDrawText(*(HDC *)(a1 + 40), (int)&c_szNULL, &rcSrc2, 0, v65 & 0x80, *(_DWORD *)(v1 + 84), v22, v64, v23);
        }
        if ( h )
          SelectObject(*(HDC *)(a1 + 40), h);
      }
    }
    if ( v63 & 0x10 )
      CICustomDrawNotify(*(_DWORD *)a1, 196610, a1 + 24);
LABEL_78:
    ++wParam;
  }
  if ( v57 )
    DrawFocusRect(*(HDC *)(a1 + 40), &rcDst);
  return 1;
}
// 6F7E697C: using guessed type int g_cxLabelMargin;

//----- (6F7D2950) --------------------------------------------------------
int __stdcall ListView_SetSubItem(HDPA hdpa, INT_PTR i)
{
  INT_PTR v2; // esi@1
  int v4; // ebx@5
  int v5; // edi@7
  HDPA v6; // eax@10
  int v7; // eax@15
  int v8; // eax@19
  PVOID v9; // edi@22
  RECT rcUpdate; // [sp+4h] [bp-1Ch]@29
  int v11; // [sp+14h] [bp-Ch]@12
  int v12; // [sp+18h] [bp-8h]@16
  int v13; // [sp+1Ch] [bp-4h]@1
  struct _DPA *hdpaa; // [sp+28h] [bp+8h]@9
  INT_PTR ia; // [sp+2Ch] [bp+Ch]@5

  v13 = 0;
  v2 = i;
  if ( *(_DWORD *)i & 0xFFFFEFF4 )
    return 0;
  if ( !(*(_DWORD *)i & 0xB) )
    return 1;
  v4 = (int)hdpa;
  ia = *(_DWORD *)(i + 4);
  if ( (unsigned int)ia >= *((_DWORD *)hdpa + 93) )
    return 0;
  v5 = *(_DWORD *)(v2 + 8) - 1;
  if ( v5 < 0 || v5 >= *((_DWORD *)hdpa + 78) - 1 )
    return 0;
  hdpaa = (struct _DPA *)DPA_GetPtr(*((HDPA *)hdpa + 79), v5);
  if ( !hdpaa )
  {
    v6 = DPA_CreateEx(16, *(HANDLE *)(v4 + 80));
    hdpaa = v6;
    if ( !v6 )
      return 0;
    DPA_SetPtr(*(HDPA *)(v4 + 316), v5, (void *)v6);
  }
  ListView_GetSubItem(v4, ia, *(_DWORD *)(v2 + 8), (int)&v11);
  if ( *(_BYTE *)v2 & 1 && v11 != *(_DWORD *)(v2 + 20) )
  {
    Str_Set((int)&v11, *(LPCWSTR *)(v2 + 20));
    v13 = 1;
  }
  v7 = *(_DWORD *)v2;
  if ( *(_DWORD *)v2 & 2 && *(_DWORD *)(v2 + 28) != (signed __int16)v12 )
  {
    LOWORD(v12) = *(_WORD *)(v2 + 28);
    v13 = 1;
  }
  if ( v7 & 8 )
  {
    v8 = *(_DWORD *)(v2 + 16) & (*(_DWORD *)(v2 + 12) ^ HIWORD(v12));
    if ( v8 )
    {
      HIWORD(v12) ^= v8;
      v13 = 1;
    }
  }
  if ( v13 )
  {
    v9 = DPA_GetPtr(hdpaa, ia);
    if ( !v9 )
    {
      v9 = LocalAlloc(0x40u, 8u);
      if ( !v9 )
        return 0;
    }
    *(_DWORD *)v9 = v11;
    *((_DWORD *)v9 + 1) = v12;
    if ( !DPA_SetPtr(hdpaa, ia, v9) )
    {
      ListView_FreeSubItem(v9);
      return 0;
    }
  }
  if ( (*(_DWORD *)(v4 + 8) & 3) == 1 )
  {
    ListView_RGetRectsEx(v4, *(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 8), 0, (int)&rcUpdate);
    RedrawWindow(*(HWND *)v4, &rcUpdate, 0, 5u);
  }
  return 1;
}

//----- (6F7D2ACF) --------------------------------------------------------
int __stdcall ListView_SGetRectsOwnerData(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // eax@1
  int v10; // ST34_4@1
  int v11; // esi@1
  int v12; // ecx@1
  int result; // eax@4
  int v14; // [sp+Ch] [bp-20h]@1
  int v15; // [sp+14h] [bp-18h]@2
  int v16; // [sp+28h] [bp-4h]@1

  v6 = ListView_GetSlotCount(a1, 1);
  *(_WORD *)(a5 + 22) = 0;
  ListView_SetIconPos(a1, a5, a2, v6);
  ListView_RecomputeLabelSize(a1, a5, a2, 0, a6);
  v7 = *(_DWORD *)(a5 + 4) - *(_DWORD *)(a1 + 220);
  v8 = *(_DWORD *)(a5 + 8) - *(_DWORD *)(a1 + 224);
  v9 = v7 + *(_DWORD *)(a1 + 172);
  v16 = v8 + *(_DWORD *)(a1 + 188);
  v10 = *(_DWORD *)(a5 + 8) - *(_DWORD *)(a1 + 224);
  *(_DWORD *)a3 = v7;
  *(_DWORD *)(a3 + 4) = v10;
  *(_DWORD *)(a3 + 8) = v9;
  *(_DWORD *)(a3 + 12) = v16;
  v11 = *(_WORD *)(a5 + 14);
  v12 = *(_DWORD *)(a1 + 184) - *(_DWORD *)(a1 + 172);
  v14 = v9;
  if ( v11 >= v12 )
    v15 = v9 + v12;
  else
    v15 = v9 + v11;
  result = v16;
  *(_DWORD *)a4 = v14;
  *(_DWORD *)(a4 + 4) = v8;
  *(_DWORD *)(a4 + 8) = v15;
  *(_DWORD *)(a4 + 12) = v16;
  return result;
}

//----- (6F7D2B85) --------------------------------------------------------
int __stdcall ListView_SGetRects(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@3
  int v6; // ecx@3
  int v7; // edx@3
  int result; // eax@3

  if ( *(_DWORD *)(a2 + 4) == 0x7FFFFFFF )
    ListView_Recompute(a1);
  v5 = *(_DWORD *)(a2 + 4) - *(_DWORD *)(a1 + 220);
  *(_DWORD *)a3 = v5;
  *(_DWORD *)(a3 + 8) = v5 + *(_DWORD *)(a1 + 172);
  v6 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 224);
  *(_DWORD *)(a3 + 4) = v6;
  *(_DWORD *)(a3 + 12) = v6 + *(_DWORD *)(a1 + 188);
  v7 = *(_DWORD *)(a3 + 8);
  *(_DWORD *)a4 = v7;
  *(_DWORD *)(a4 + 8) = v7 + *(_WORD *)(a2 + 14);
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a3 + 4);
  result = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a4 + 12) = result;
  return result;
}

//----- (6F7D2BF9) --------------------------------------------------------
int __stdcall ListView_DoLookupString(int a1, LPCWSTR lpString2, char a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@3
  int v7; // eax@4
  int result; // eax@16
  signed int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v10 = 0;
  v9 = 0;
  v5 = a4;
  do
  {
    if ( v5 >= a5 )
      break;
    v6 = (v5 + a5) / 2;
    if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v6) == v10 )
      break;
    v10 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 40) + 4) + 4 * v6);
    v7 = ListView_CompareString(a1, v6, lpString2, a3, 0);
    if ( *(_BYTE *)(a1 + 8) & 0x20 )
      v7 = -v7;
    if ( v7 == -1 )
    {
      v5 = v6 + 1;
      continue;
    }
    if ( !v7 )
    {
      v9 = 1;
LABEL_11:
      a5 = (v5 + a5) / 2;
      continue;
    }
    if ( v7 == 1 )
      goto LABEL_11;
  }
  while ( v5 >= a4 );
  if ( a3 & 0xC || v9 )
  {
    if ( v5 < 0 )
      v5 = 0;
    if ( !(a3 & 0x40) )
    {
      if ( ListView_CompareString(a1, v5, lpString2, a3, 1) )
        v5 = -1;
    }
    result = v5;
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (6F7D2CAE) --------------------------------------------------------
int __stdcall ListView_LookupString(int a1, LPCWSTR lpString2, char a3, int a4)
{
  int result; // eax@2

  if ( lpString2 )
  {
    result = ListView_DoLookupString(a1, lpString2, a3, a4, *(_DWORD *)(a1 + 372));
    if ( result == -1 )
    {
      if ( a3 & 0x20 )
        result = ListView_DoLookupString(a1, lpString2, a3, 0, a4);
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7D2CFC) --------------------------------------------------------
int __stdcall ListView_SItemHitTest(int a1, POINT pt, int a3, int a4)
{
  int v4; // esi@3
  signed int v5; // ebx@3
  signed int v6; // edi@3
  bool v7; // zf@3
  int v8; // eax@6
  int v10; // edi@14
  LONG v11; // edx@14
  LONG v12; // ecx@14
  LONG v13; // eax@14
  LONG v14; // edx@16
  LONG v15; // eax@16
  LONG v16; // ecx@16
  char v17; // [sp+0h] [bp-74h]@6
  RECT v18; // [sp+3Ch] [bp-38h]@16
  RECT v19; // [sp+4Ch] [bp-28h]@6
  RECT rc; // [sp+5Ch] [bp-18h]@6
  unsigned int v21; // [sp+70h] [bp-4h]@3
  signed int v22; // [sp+7Ch] [bp+8h]@6
  int v23; // [sp+8Ch] [bp+18h]@5

  if ( a4 )
    *(_DWORD *)a4 = 0;
  v4 = a1;
  v5 = pt.x + *(_DWORD *)(a1 + 220);
  v6 = pt.y + *(_DWORD *)(a1 + 224);
  v7 = *(_DWORD *)(a1 + 228) == 0x7FFFFFFF;
  v21 = pt.y + *(_DWORD *)(a1 + 224);
  if ( v7 )
    ListView_Recompute(a1);
  v23 = 0;
  if ( !(*(_DWORD *)(a1 + 8) & 0x1000) )
  {
    v22 = 0;
    if ( *(_DWORD *)(v4 + 372) > 0 )
    {
      do
      {
        v10 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4)
                        + 4 * *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 216) + 4) + 4 * v22));
        v11 = *(_DWORD *)(v10 + 8);
        v12 = *(_DWORD *)(v10 + 4);
        v13 = v11 + *(_DWORD *)(v4 + 188);
        rc.top = *(_DWORD *)(v10 + 8);
        rc.bottom = v13;
        v19.top = v11;
        v19.bottom = v13;
        if ( (signed int)v21 >= v11 && (signed int)v21 < v13 )
        {
          v14 = v12 + *(_DWORD *)(v4 + 172);
          v18.bottom = v13;
          v15 = v13 - *(_DWORD *)(v4 + 360);
          rc.left = v12;
          v18.right = v12;
          v16 = v12 - *(_DWORD *)(v4 + 356);
          v18.top = v15;
          rc.right = v14;
          v18.left = v16;
          v19.left = v14;
          v19.right = v14 + *(_WORD *)(v10 + 14);
          if ( PtInRect(&rc, (POINT)__PAIR__(v21, v5)) )
            goto LABEL_7;
          if ( PtInRect(&v19, (POINT)__PAIR__(v21, v5)) )
            goto LABEL_12;
          if ( PtInRect(&v18, (POINT)__PAIR__(v21, v5)) )
            v23 = 8;
          if ( v23 )
            goto LABEL_8;
        }
        ++v22;
      }
      while ( v22 < *(_DWORD *)(v4 + 372) );
      if ( v23 )
        goto LABEL_8;
    }
    goto LABEL_23;
  }
  v8 = ListView_GetSlotCount(a1, 1);
  v22 = ListView_CalcHitSlot(a1, v5, v6, v8);
  ListView_SGetRectsOwnerData(v4, v22, (int)&rc, (int)&v19, (int)&v17, 0);
  if ( PtInRect(&rc, pt) )
  {
LABEL_7:
    v23 = 2;
    goto LABEL_8;
  }
  if ( !PtInRect(&v19, pt) )
  {
LABEL_23:
    v22 = -1;
    v23 = 1;
    goto LABEL_10;
  }
LABEL_12:
  v23 = 4;
LABEL_8:
  if ( !(*(_DWORD *)(v4 + 8) & 0x1000) )
    v22 = DPA_GetPtrIndex(
            *(HDPA *)(v4 + 40),
            *(const void **)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 4)
                           + 4 * *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 216) + 4) + 4 * v22)));
LABEL_10:
  *(_DWORD *)a3 = v23;
  return v22;
}

//----- (6F7D2EE7) --------------------------------------------------------
BOOL __stdcall LoadMLFontLink(struct IMLangFontLink **a1)
{
  HMODULE v1; // eax@2

  EnterCriticalSection(&g_csDll);
  *a1 = 0;
  if ( g_pfnGetGlobalFontLinkObject )
    goto LABEL_9;
  v1 = LoadLibraryW(L"MLANG.DLL");
  if ( v1 )
    g_pfnGetGlobalFontLinkObject = (__int32 (__stdcall *)(struct IMLangFontLink **))GetProcAddress(
                                                                                      v1,
                                                                                      "GetGlobalFontLinkObject");
  if ( g_pfnGetGlobalFontLinkObject )
LABEL_9:
    g_pfnGetGlobalFontLinkObject(a1);
  LeaveCriticalSection(&g_csDll);
  return *a1 != 0;
}
// 6F7E8ABC: using guessed type __int32 (__stdcall *g_pfnGetGlobalFontLinkObject)(struct IMLangFontLink **);

//----- (6F7D2F81) --------------------------------------------------------
signed int __stdcall FDoFontLink(HDC hdc, struct IMLangFontLink **a2, const unsigned __int16 *a3, int cchWideChar)
{
  int v4; // edi@1
  int v5; // eax@1
  WCHAR *v6; // edi@7
  signed int result; // eax@12
  int v8; // edx@15
  WCHAR *v9; // eax@16
  struct tagCHARSETINFO v10; // [sp+Ch] [bp-43Ch]@1
  struct IMLangFontLink **v11; // [sp+2Ch] [bp-41Ch]@1
  char *v12; // [sp+30h] [bp-418h]@1
  int cbMultiByte; // [sp+34h] [bp-414h]@5
  LPCWSTR lpWideCharStr; // [sp+38h] [bp-410h]@1
  LPSTR lpMultiByteStr; // [sp+3Ch] [bp-40Ch]@1
  BOOL UsedDefaultChar; // [sp+40h] [bp-408h]@1
  char v17; // [sp+44h] [bp-404h]@1
  char v18; // [sp+244h] [bp-204h]@1

  v11 = a2;
  lpWideCharStr = a3;
  lpMultiByteStr = &v17;
  UsedDefaultChar = 1;
  v4 = 2 * cchWideChar;
  v12 = &v18;
  v5 = GetTextCharsetInfo(hdc, 0, 0);
  TranslateCharsetInfo((DWORD *)v5, &v10, 1u);
  if ( cchWideChar <= 0 )
    goto LABEL_11;
  if ( g_uiACP != v10.ciACP )
    goto LABEL_11;
  if ( cchWideChar > 256 )
  {
    lpMultiByteStr = (LPSTR)LocalAlloc(0x40u, v4);
    if ( !lpMultiByteStr )
      goto LABEL_11;
  }
  cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, lpMultiByteStr, v4, 0, &UsedDefaultChar);
  if ( !UsedDefaultChar )
  {
    if ( cchWideChar <= 256 )
    {
      v6 = (WCHAR *)v12;
    }
    else
    {
      v6 = (WCHAR *)LocalAlloc(0x40u, v4);
      if ( !v6 )
      {
        UsedDefaultChar = 1;
        goto LABEL_9;
      }
    }
    if ( cchWideChar == MultiByteToWideChar(0, 0, lpMultiByteStr, cbMultiByte, v6, cchWideChar) )
    {
      v8 = 0;
      if ( cchWideChar <= 0 )
        goto LABEL_21;
      v9 = v6;
      while ( *v9 == *(WCHAR *)((char *)v9 + (char *)lpWideCharStr - (char *)v6) )
      {
        ++v8;
        ++v9;
        if ( v8 >= cchWideChar )
          goto LABEL_21;
      }
    }
    UsedDefaultChar = 1;
LABEL_21:
    if ( (char *)v6 != &v18 )
      LocalFree(v6);
  }
LABEL_9:
  if ( lpMultiByteStr != &v17 )
    LocalFree(lpMultiByteStr);
LABEL_11:
  if ( UsedDefaultChar )
    result = LoadMLFontLink(v11) != 0 ? 0 : -2147467259;
  else
    result = 1;
  return result;
}
// 6F7E68C8: using guessed type int g_uiACP;

//----- (6F7D3134) --------------------------------------------------------
signed int __stdcall FDoFontLink(HDC a1, struct IMLangFontLink **a2, unsigned __int16 a3, unsigned __int16 a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  char *v6; // edi@1
  signed int v8; // [sp+14h] [bp-208h]@1
  char hMem; // [sp+18h] [bp-204h]@1

  v4 = 0;
  v5 = a3 - a4 + 1;
  v6 = &hMem;
  v8 = -2147467259;
  if ( v5 <= 256 || (v6 = (char *)LocalAlloc(0x40u, 2 * v5)) != 0 )
  {
    if ( v5 > 0 )
    {
      do
      {
        *(_WORD *)&v6[2 * v4] = v4 + a3;
        ++v4;
      }
      while ( v4 < v5 );
    }
    v8 = FDoFontLink(a1, a2, (const unsigned __int16 *)v6, v5);
    if ( v6 != &hMem )
      LocalFree(v6);
  }
  return v8;
}

//----- (6F7D31ED) --------------------------------------------------------
int __stdcall _GetCharWidthWFontLink(HDC hdc, WCHAR WideCharStr, unsigned __int16 a3, LPINT lpBuffer)
{
  HDC v4; // ebx@1
  UINT v5; // esi@1
  signed int v6; // eax@1
  int v8; // edi@10
  HGDIOBJ v9; // [sp+Ch] [bp-18h]@17
  int v10; // [sp+10h] [bp-14h]@10
  CHAR MultiByteStr[4]; // [sp+14h] [bp-10h]@5
  HGDIOBJ h; // [sp+18h] [bp-Ch]@1
  int v13; // [sp+1Ch] [bp-8h]@1
  struct IMLangFontLink *v14; // [sp+20h] [bp-4h]@1

  v4 = hdc;
  v5 = WideCharStr;
  h = 0;
  v13 = 0;
  v14 = 0;
  v6 = FDoFontLink(hdc, &v14, WideCharStr, a3);
  if ( v6 )
  {
    if ( v6 != 1 )
      return 0;
    *(_DWORD *)&WideCharStr = v5;
    if ( v5 <= a3 )
    {
      do
      {
        *(_DWORD *)MultiByteStr = 0;
        if ( WideCharToMultiByte(0, 0, &WideCharStr, 1, MultiByteStr, 4, 0, 0) )
          v13 = GetCharWidthA(v4, *(UINT *)MultiByteStr, *(UINT *)MultiByteStr, &lpBuffer[WideCharStr - v5]);
        if ( !v13 )
          break;
        *(_DWORD *)&WideCharStr = WideCharStr + 1;
      }
      while ( WideCharStr <= a3 );
    }
  }
  else
  {
    *(_DWORD *)MultiByteStr = GetCurrentObject(v4, 6u);
    v14->lpVtbl->GetFontCodePages(v14, v4, *(HFONT *)MultiByteStr, (DWORD *)&v10);
    v8 = (unsigned __int16)v5;
    if ( (unsigned __int16)v5 <= a3 )
    {
      while ( 1 )
      {
        v14->lpVtbl->GetCharCodePages(v14, v8, (DWORD *)&hdc);
        if ( !((unsigned int)hdc & v10) )
          break;
        ++v8;
        if ( (unsigned __int16)v8 > a3 )
          goto LABEL_16;
      }
      if ( (unsigned __int16)v8 != v5 )
        v13 = GetCharWidthW(v4, v5, (unsigned __int16)v8 - 1, lpBuffer);
LABEL_16:
      if ( (unsigned __int16)v8 <= a3 )
      {
        do
        {
          v13 = (unsigned __int16)v8;
          v14->lpVtbl->MapFont(v14, v4, (DWORD)hdc, *(HFONT *)MultiByteStr, (HFONT *)&h);
          v9 = SelectObject(v4, h);
          v14->lpVtbl->GetFontCodePages(v14, v4, (HFONT)h, (DWORD *)&v10);
          do
          {
            ++v8;
            if ( (unsigned __int16)v8 > a3 )
              break;
            v14->lpVtbl->GetCharCodePages(v14, v8, (DWORD *)&hdc);
          }
          while ( (unsigned int)hdc & v10 );
          v13 = GetCharWidthW(
                  v4,
                  (unsigned __int16)v13,
                  (unsigned __int16)v8 - 1,
                  &lpBuffer[(unsigned __int16)v13 - WideCharStr]);
          SelectObject(v4, v9);
          v14->lpVtbl->ReleaseFont(v14, (HFONT)h);
        }
        while ( v13 && (unsigned __int16)v8 <= a3 );
      }
    }
    v14->lpVtbl->Release(v14);
  }
  return v13;
}

//----- (6F7D33A3) --------------------------------------------------------
int __stdcall GetCharWidthWrap(HDC hdc, int WideCharStr, int iLast, LPINT lpBuffer)
{
  int result; // eax@2

  if ( g_bRunOnNT5 )
  {
    result = GetCharWidthW(hdc, WideCharStr, iLast, lpBuffer);
  }
  else if ( (unsigned int)iLast <= 0x7F || (result = _GetCharWidthWFontLink(hdc, WideCharStr, iLast, lpBuffer)) == 0 )
  {
    result = GetCharWidthW(hdc, WideCharStr, iLast, lpBuffer);
  }
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7D33E3) --------------------------------------------------------
int __stdcall _OtherGetTextExtentPointW(HDC hdc, const unsigned __int16 *lpString, int c, LPSIZE lpsz)
{
  int result; // eax@2

  if ( c )
  {
    result = GetTextExtentPoint32W(hdc, lpString, c, lpsz);
  }
  else
  {
    result = GetTextExtentPointA(hdc, " ", 1, lpsz);
    lpsz->cx = 0;
  }
  return result;
}

//----- (6F7D3417) --------------------------------------------------------
int __stdcall _GetTextExtentPointWFontLink(HDC hdc, LPCWSTR lpWideCharStr, int cchWideChar, LPSIZE lpsz)
{
  __int32 v4; // esi@1
  HDC v5; // edi@1
  int v6; // ebx@1
  signed int v7; // eax@1
  int result; // eax@3
  int v9; // esi@5
  const CHAR *v10; // eax@5
  int v11; // eax@6
  char *v12; // ecx@15
  struct tagSIZE sz; // [sp+Ch] [bp-30h]@19
  int v14; // [sp+14h] [bp-28h]@15
  unsigned __int16 *v15; // [sp+18h] [bp-24h]@16
  HFONT v16; // [sp+1Ch] [bp-20h]@10
  int v17; // [sp+20h] [bp-1Ch]@10
  DWORD v18; // [sp+24h] [bp-18h]@10
  HGDIOBJ h; // [sp+28h] [bp-14h]@1
  DWORD v20; // [sp+2Ch] [bp-10h]@10
  LPCSTR lpString; // [sp+30h] [bp-Ch]@1
  int v22; // [sp+34h] [bp-8h]@1
  struct IMLangFontLink *v23; // [sp+38h] [bp-4h]@1

  v4 = cchWideChar;
  v5 = hdc;
  v6 = 0;
  lpString = 0;
  h = 0;
  v22 = 0;
  v23 = 0;
  v7 = FDoFontLink(hdc, &v23, lpWideCharStr, cchWideChar);
  if ( v7 )
  {
    if ( v7 != 1 )
      return 0;
    v9 = 2 * v4;
    v10 = (const CHAR *)LocalAlloc(0x40u, v9);
    lpString = v10;
    if ( v10 )
    {
      v11 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, (LPSTR)v10, v9, 0, 0);
      if ( v11 )
        v22 = GetTextExtentPointA(v5, lpString, v11, lpsz);
      LocalFree((HLOCAL)lpString);
    }
    result = v22;
  }
  else
  {
    v16 = (HFONT)GetCurrentObject(v5, 6u);
    v23->lpVtbl->GetFontCodePages(v23, v5, v16, (DWORD *)&v17);
    v23->lpVtbl->CodePageToCodePages(v23, g_uiACP, &v18);
    v23->lpVtbl->GetStrCodePages(v23, lpWideCharStr, v4, v18, &v20, (__int32 *)&hdc);
    if ( v20 & v17 && (HDC)v4 == hdc )
    {
      v23->lpVtbl->Release(v23);
      return 0;
    }
    v22 = GetTextExtentPointA(v5, " ", 1, lpsz);
    if ( v22 )
    {
      v12 = 0;
      lpsz->cx = 0;
      v14 = 0;
      if ( v4 > 0 )
      {
        do
        {
          v15 = (unsigned __int16 *)&lpWideCharStr[(_DWORD)v12];
          v23->lpVtbl->GetStrCodePages(
            v23,
            &lpWideCharStr[(_DWORD)v12],
            cchWideChar - (_DWORD)v12,
            v18,
            &v20,
            (__int32 *)&hdc);
          if ( !(v20 & v17) )
          {
            v23->lpVtbl->MapFont(v23, v5, v20, v16, (HFONT *)&h);
            lpString = (LPCSTR)SelectObject(v5, h);
          }
          if ( (signed int)hdc > 0 )
          {
            v22 = _OtherGetTextExtentPointW(v5, v15, (int)hdc, &sz);
            lpsz->cx += sz.cx;
          }
          if ( lpString )
          {
            SelectObject(v5, (HGDIOBJ)lpString);
            v23->lpVtbl->ReleaseFont(v23, (HFONT)h);
            lpString = 0;
          }
          v12 = (char *)hdc + v14;
          v14 += (int)hdc;
        }
        while ( v14 < cchWideChar );
      }
      v6 = v22;
    }
    v23->lpVtbl->Release(v23);
    result = v6;
  }
  return result;
}
// 6F7E68C8: using guessed type int g_uiACP;

//----- (6F7D35E2) --------------------------------------------------------
int __stdcall GetTextExtentPointWrap(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
{
  int result; // eax@2
  int v5; // eax@6
  const WCHAR v6; // cx@7
  CHAR String[256]; // [sp+Ch] [bp-104h]@8

  if ( g_bRunOnNT5 )
    return GetTextExtentPointW(hdc, lpString, c, lpsz);
  if ( c <= 0 )
    goto LABEL_14;
  if ( c < 256 && *lpString <= 0x7Fu )
  {
    v5 = 0;
    if ( c <= 0 )
      return GetTextExtentPointA(hdc, String, c, lpsz);
    while ( 1 )
    {
      v6 = lpString[v5];
      if ( v6 > 0x7Fu )
        break;
      String[v5++] = v6;
      if ( v5 >= c )
        return GetTextExtentPointA(hdc, String, c, lpsz);
    }
  }
  result = _GetTextExtentPointWFontLink(hdc, lpString, c, lpsz);
  if ( !result )
LABEL_14:
    result = _OtherGetTextExtentPointW(hdc, lpString, c, lpsz);
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;
// 6F7D35E2: using guessed type CHAR String[256];

//----- (6F7D369E) --------------------------------------------------------
int __stdcall GetTextExtentPoint32Wrap(HDC a1, const unsigned __int16 *a2, int a3, struct tagSIZE *a4)
{
  return GetTextExtentPointWrap(a1, a2, a3, a4);
}

//----- (6F7D36AE) --------------------------------------------------------
BOOL __stdcall _OtherExtTextOutW(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpString, UINT c, INT *lpDx)
{
  UINT v8; // ecx@4
  const WCHAR v9; // dx@5
  CHAR String[256]; // [sp+Ch] [bp-104h]@6

  if ( !(options & 0x10) && c < 0x100 && *lpString <= 0x7Fu )
  {
    v8 = 0;
    if ( !c )
      return ExtTextOutA(hdc, x, y, options, lprect, String, c, lpDx);
    while ( 1 )
    {
      v9 = lpString[v8];
      if ( v9 > 0x7Fu )
        break;
      String[v8++] = v9;
      if ( v8 >= c )
        return ExtTextOutA(hdc, x, y, options, lprect, String, c, lpDx);
    }
  }
  return ExtTextOutW(hdc, x, y, options, lprect, lpString, c, lpDx);
}
// 6F7D36AE: using guessed type CHAR String[256];

//----- (6F7D374F) --------------------------------------------------------
unsigned int __userpurge _ExtTextOutWFontLink@<eax>(int a1@<edi>, HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpWideCharStr, unsigned int cchWideChar, INT *lpDx)
{
  __int32 v9; // ebx@1
  unsigned int v10; // esi@1
  unsigned int result; // eax@2
  HDC v12; // edi@3
  signed int v13; // eax@3
  int v14; // esi@7
  CHAR *v15; // ebx@7
  int v16; // eax@8
  int v17; // eax@26
  int v18; // [sp-4h] [bp-40h]@3
  struct tagPOINT pt; // [sp+8h] [bp-34h]@22
  UINT align; // [sp+10h] [bp-2Ch]@21
  int v21; // [sp+14h] [bp-28h]@1
  HFONT v22; // [sp+18h] [bp-24h]@12
  int v23; // [sp+1Ch] [bp-20h]@12
  DWORD v24; // [sp+20h] [bp-1Ch]@12
  HGDIOBJ h; // [sp+24h] [bp-18h]@1
  DWORD v26; // [sp+28h] [bp-14h]@12
  int v27; // [sp+2Ch] [bp-10h]@1
  HGDIOBJ v28; // [sp+30h] [bp-Ch]@1
  unsigned int v29; // [sp+34h] [bp-8h]@1
  struct IMLangFontLink *v30; // [sp+38h] [bp-4h]@1

  v9 = cchWideChar;
  v10 = 0;
  v28 = 0;
  h = 0;
  v29 = 0;
  v27 = 0;
  v21 = 1;
  v30 = 0;
  if ( cchWideChar )
  {
    v18 = a1;
    v12 = hdc;
    v13 = FDoFontLink(hdc, &v30, lpWideCharStr, cchWideChar);
    if ( v13 )
    {
      if ( v13 == 1 )
      {
        v14 = 2 * v9;
        v15 = (CHAR *)LocalAlloc(0x40u, 2 * v9);
        if ( v15 )
        {
          v16 = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, v15, v14, 0, 0);
          if ( v16 )
            v29 = ExtTextOutA(v12, x, y, options, lprect, v15, v16, lpDx);
          LocalFree(v15);
        }
        result = v29;
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      v22 = (HFONT)GetCurrentObject(v12, 6u);
      ((void (__stdcall *)(struct IMLangFontLink *, HDC, HFONT, int *, int))v30->lpVtbl->GetFontCodePages)(
        v30,
        v12,
        v22,
        &v23,
        v18);
      v30->lpVtbl->CodePageToCodePages(v30, g_uiACP, &v24);
      v30->lpVtbl->GetStrCodePages(v30, lpWideCharStr, v9, v24, &v26, (__int32 *)&hdc);
      if ( !(v26 & v23) || (HDC)v9 != hdc )
      {
        if ( (unsigned int)v9 > 0 )
        {
          do
          {
            v30->lpVtbl->GetStrCodePages(v30, &lpWideCharStr[v10], cchWideChar - v10, v24, &v26, (__int32 *)&hdc);
            if ( !(v26 & v23) )
            {
              v30->lpVtbl->MapFont(v30, v12, v26, v22, (HFONT *)&h);
              v28 = SelectObject(v12, h);
            }
            if ( (signed int)hdc > 0 )
            {
              if ( hdc != (HDC)cchWideChar && v21 )
              {
                align = GetTextAlign(v12);
                if ( !(align & 1) )
                {
                  MoveToEx(v12, x, y, &pt);
                  v27 = 1;
                }
                v21 = 0;
              }
              if ( v27 )
                SetTextAlign(v12, align | 1);
              v17 = _OtherExtTextOutW(
                      v12,
                      x,
                      y,
                      options,
                      lprect,
                      &lpWideCharStr[v10],
                      (UINT)hdc,
                      (INT *)(lpDx != 0 ? (unsigned int)&lpDx[v10] : 0));
              options &= 0xFFFFFFFD;
              v29 = v17;
              if ( v27 )
                SetTextAlign(v12, align);
              if ( !v29 )
                break;
            }
            if ( v28 )
            {
              SelectObject(v12, v28);
              v30->lpVtbl->ReleaseFont(v30, (HFONT)h);
              v28 = 0;
            }
            v10 += (unsigned int)hdc;
          }
          while ( v10 < cchWideChar );
          if ( v27 )
            MoveToEx(v12, pt.x, pt.y, 0);
        }
        v10 = v29;
      }
      ((void (__cdecl *)(struct IMLangFontLink *))v30->lpVtbl->Release)(v30);
      result = v10;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7D374F: could not find valid save-restore pair for edi
// 6F7E68C8: using guessed type int g_uiACP;

//----- (6F7D3987) --------------------------------------------------------
unsigned int __stdcall ExtTextOutWrap(HDC hdc, int x, int y, UINT options, RECT *lprect, LPCWSTR lpString, UINT c, INT *lpDx)
{
  UINT v8; // eax@1
  unsigned int result; // eax@2
  const WCHAR v10; // cx@10
  CHAR String; // [sp+13h] [bp-105h]@4
  char v12[256]; // [sp+14h] [bp-104h]@11

  v8 = 0;
  if ( g_bRunOnNT5 )
    return ExtTextOutW(hdc, x, y, options, lprect, lpString, c, lpDx);
  if ( !c )
    return ExtTextOutA(hdc, x, y, options, lprect, &String, 0, lpDx);
  if ( !(options & 0x10) && c < 0x100 && *lpString <= 0x7Fu )
  {
    if ( c <= 0 )
      return ExtTextOutA(hdc, x, y, options, lprect, v12, c, lpDx);
    while ( 1 )
    {
      v10 = lpString[v8];
      if ( v10 > 0x7Fu )
        break;
      v12[v8++] = v10;
      if ( v8 >= c )
        return ExtTextOutA(hdc, x, y, options, lprect, v12, c, lpDx);
    }
  }
  result = _ExtTextOutWFontLink((int)hdc, hdc, x, y, options, lprect, lpString, c, lpDx);
  if ( !result )
    result = _OtherExtTextOutW(hdc, x, y, options, lprect, lpString, c, lpDx);
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;
// 6F7D3987: using guessed type char var_104[256];

//----- (6F7D3A7D) --------------------------------------------------------
unsigned int __stdcall TextOutWrap(HDC hdc, int x, int y, LPCWSTR lpString, UINT c)
{
  return ExtTextOutWrap(hdc, x, y, 0, 0, lpString, c, 0);
}

//----- (6F7D3AA4) --------------------------------------------------------
int __stdcall UserIsFELineBreakEnd(unsigned __int16 a1)
{
  unsigned int v1; // eax@1
  int v2; // eax@4
  int v3; // eax@5
  signed __int16 v4; // ax@7
  int result; // eax@9
  signed __int16 v6; // ax@11
  int v7; // eax@16
  int v8; // eax@17
  int v9; // eax@18

  v1 = (unsigned int)a1 >> 8;
  if ( (signed int)v1 <= 34 )
  {
    if ( v1 == 34 )
    {
      v4 = 8758;
      return a1 == v4;
    }
    if ( !v1 )
    {
      if ( (unsigned __int16)(a1 - 33) <= 0x96u )
        return *((_BYTE *)&loc_6F7D3BAF + a1);
      return 0;
    }
    v2 = v1 - 2;
    if ( v2 )
    {
      v3 = v2 - 30;
      if ( v3 )
      {
        if ( v3 == 1 )
        {
          v4 = 8451;
          return a1 == v4;
        }
      }
      else if ( (unsigned __int16)(a1 - 8211) <= 0x20u )
      {
        return *((_BYTE *)&loc_6F7D1C55 + a1);
      }
      return 0;
    }
    if ( a1 == 711 )
      return 1;
    v6 = 713;
LABEL_29:
    if ( a1 != v6 )
      return 0;
    return 1;
  }
  v7 = v1 - 37;
  if ( !v7 )
  {
    v4 = 9588;
    return a1 == v4;
  }
  v8 = v7 - 11;
  if ( !v8 )
  {
    if ( (unsigned __int16)(a1 - 12289) <= 0x1Du )
      return *((_BYTE *)&loc_6F7D0C89 + a1 + 2);
    if ( a1 == 12443 )
      return 1;
    v6 = 12444;
    goto LABEL_29;
  }
  v9 = v8 - 206;
  if ( !v9 )
  {
    if ( (unsigned __int16)(a1 + 464) <= 0x2Eu )
      return *((_BYTE *)&loc_6F7C3E7C + a1);
    return 0;
  }
  if ( v9 != 1 )
    return 0;
  if ( (unsigned __int16)(a1 + 255) > 0x9Eu )
    result = a1 >= 0xFFE0u;
  else
    result = *((_BYTE *)&loc_6F7C3DDB + a1 + 4);
  return result;
}

//----- (6F7D3D85) --------------------------------------------------------
int __stdcall UserIsFullWidth(unsigned __int16 a1)
{
  signed int v1; // eax@2
  int result; // eax@6

  if ( a1 < 0x80u )
  {
LABEL_6:
    result = 0;
  }
  else
  {
    v1 = (signed int)sub_6F7D3DC2;
    while ( a1 < *(_WORD *)(v1 - 2) || a1 > *(_WORD *)v1 )
    {
      v1 += 4;
      if ( v1 >= (signed int)((char *)&loc_6F7D3DCE + 4) )
        goto LABEL_6;
    }
    result = 1;
  }
  return result;
}
// 6F7D3DC2: using guessed type int sub_6F7D3DC2();

//----- (6F7D3DD5) --------------------------------------------------------
int __stdcall GetNextWordbreak(const unsigned __int16 *a1, const unsigned __int16 *a2, unsigned __int32 a3, struct DRAWTEXTDATA *a4)
{
  char v4; // bl@1
  char v5; // dl@1
  signed int v6; // edi@1
  const unsigned __int16 *v7; // esi@4
  int result; // eax@14

  v4 = 1;
  v5 = a3 & 0x10;
  v6 = 1;
  if ( !(a3 & 0x10) || a3 & 0x80000 )
    v4 = 0;
  v7 = a1;
  while ( 1 )
  {
    if ( v7 >= a2 )
      return (int)v7;
    if ( *v7 == 9 )
      goto LABEL_24;
    if ( *v7 == 10 || *v7 == 13 )
      return (int)v7;
    if ( *v7 == 32 )
    {
LABEL_24:
      if ( v5 )
        return (int)&v7[v6];
    }
    if ( v4 && UserIsFullWidth(*v7) )
      break;
    ++v7;
    v6 = 0;
  }
  if ( !v6 )
    return (int)v7;
  if ( v7 + 1 != a2 && UserIsFELineBreakEnd(v7[1]) )
    result = (int)(v7 + 2);
  else
    result = (int)(v7 + 1);
  return result;
}

//----- (6F7D3E62) --------------------------------------------------------
int __stdcall GetPrefixCount(const unsigned __int16 *a1, int a2, unsigned __int16 *a3, int a4)
{
  unsigned __int16 *v4; // ecx@1
  int v5; // edi@1
  int v6; // ebx@1
  const unsigned __int16 *v7; // edx@2
  unsigned __int16 v8; // ax@3
  signed __int16 v10; // [sp+8h] [bp-8h]@1
  int v11; // [sp+Ch] [bp-4h]@1

  v10 = -1;
  v4 = a3;
  v5 = a2;
  v6 = 0;
  v11 = 0;
  if ( a2 > 0 )
  {
    v7 = a1;
    do
    {
      v8 = *v7;
      --v5;
      if ( !*v7 || a4 <= 1 )
        break;
      ++v7;
      if ( v8 == 38 )
      {
        ++v11;
        if ( *v7 == 38 )
        {
          if ( v4 )
          {
            *v4 = 38;
            ++v4;
            --a4;
          }
          --v5;
          ++v7;
          ++v6;
          continue;
        }
      }
      else
      {
        if ( v8 != 30 )
        {
          if ( v8 == 31 )
          {
            ++v11;
            if ( !v5 )
              break;
            ++v11;
            ++v7;
            --v5;
          }
          else
          {
            ++v6;
            if ( v4 )
            {
              *v4 = v8;
              ++v4;
              --a4;
            }
          }
          continue;
        }
        ++v11;
      }
      v10 = v6;
    }
    while ( v5 > 0 );
  }
  if ( v4 )
    *v4 = 0;
  return (unsigned __int16)v10 | ((unsigned __int16)v11 << 16);
}

//----- (6F7D3F0F) --------------------------------------------------------
LONG __stdcall KKGetPrefixWidth(HDC hdc, LPCWSTR lpString, int a3)
{
  LONG v3; // edi@1
  LPCWSTR v4; // esi@2
  LONG v5; // edi@14
  struct tagSIZE v7; // [sp+8h] [bp-20h]@14
  struct tagSIZE v8; // [sp+10h] [bp-18h]@1
  struct tagSIZE v9; // [sp+18h] [bp-10h]@1
  struct tagSIZE sz; // [sp+20h] [bp-8h]@1

  v3 = 0;
  sz.cx = -1;
  sz.cy = -1;
  v8.cx = -1;
  v8.cy = -1;
  v9.cx = -1;
  v9.cy = -1;
  if ( a3 > 0 )
  {
    v4 = lpString;
    do
    {
      --a3;
      if ( !*v4 )
        break;
      switch ( *v4 )
      {
        case 0x1Eu:
          if ( v8.cx == -1 )
            GetTextExtentPointWrap(hdc, v4, 1, &v8);
          v3 += v8.cx;
          break;
        case 0x1Fu:
          if ( v9.cx == -1 )
            GetTextExtentPointWrap(hdc, v4, 1, &v9);
          v5 = v9.cx + v3;
          GetTextExtentPointWrap(hdc, v4, 1, &v7);
          v3 = v7.cx + v5;
          break;
        case 0x26u:
          if ( v4[1] == 38 )
          {
            --a3;
            ++v4;
          }
          else
          {
            if ( sz.cx == -1 )
              GetTextExtentPointWrap(hdc, v4, 1, &sz);
            v3 += sz.cx;
          }
          break;
      }
      ++v4;
    }
    while ( a3 > 0 );
  }
  return v3;
}

//----- (6F7D3FE1) --------------------------------------------------------
void __stdcall PSMTextOut(HDC hdc, int xLeft, int y, LPCWSTR lpString, UINT c, unsigned __int32 a6)
{
  HLOCAL v6; // ebx@1
  int v7; // eax@5
  int v8; // esi@13
  COLORREF v9; // eax@13
  struct tagTEXTMETRICW tm; // [sp+8h] [bp-260h]@9
  struct tagRECT rc; // [sp+44h] [bp-224h]@13
  struct tagSIZE sz; // [sp+54h] [bp-214h]@12
  HDC v13; // [sp+5Ch] [bp-20Ch]@1
  COLORREF color; // [sp+60h] [bp-208h]@1
  char hMem; // [sp+64h] [bp-204h]@1

  v13 = hdc;
  color = (COLORREF)lpString;
  v6 = &hMem;
  if ( a6 & 0x800 )
  {
    TextOutWrap(hdc, xLeft, y, lpString, c);
  }
  else if ( c <= 0xFF || (v6 = LocalAlloc(0x40u, 2 * c + 2)) != 0 )
  {
    v7 = GetPrefixCount((const unsigned __int16 *)color, c, (unsigned __int16 *)v6, c);
    color = v7;
    if ( !(a6 & 0x200000) )
      TextOutWrap(hdc, xLeft, y, (LPCWSTR)v6, c - ((unsigned int)v7 >> 16));
    if ( (_WORD)color != -1 && !(a6 & 0x100000) )
    {
      if ( !GetTextMetricsW(hdc, &tm) )
      {
        tm.tmOverhang = 0;
        tm.tmAscent = 0;
      }
      if ( (_WORD)color )
      {
        GetTextExtentPointWrap(hdc, (LPCWSTR)v6, (unsigned __int16)color, &sz);
        xLeft += sz.cx - tm.tmOverhang;
      }
      GetTextExtentPointWrap(hdc, (LPCWSTR)v6 + (unsigned __int16)color, 1, &sz);
      v8 = y + tm.tmAscent + 1;
      SetRect(&rc, xLeft, v8, xLeft + (unsigned __int16)sz.cx - tm.tmOverhang / 2, y + tm.tmAscent + 2);
      v9 = GetTextColor(hdc);
      color = SetBkColor(hdc, v9);
      ExtTextOutWrap(v13, xLeft, v8, 2u, &rc, &WindowName, 0, 0);
      SetBkColor(v13, color);
    }
    if ( v6 != &hMem )
      LocalFree(v6);
  }
}

//----- (6F7D41AE) --------------------------------------------------------
LONG __stdcall DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpString, int c, unsigned int a4, int a5)
{
  LONG v5; // esi@1
  unsigned int v6; // edi@2
  struct tagSIZE sz; // [sp+4h] [bp-Ch]@5
  WCHAR String[2]; // [sp+Ch] [bp-4h]@1

  v5 = 0;
  *(_DWORD *)String = 38;
  if ( !(a4 & 0x800) )
  {
    v6 = (unsigned int)GetPrefixCount(lpString, c, 0, 0) >> 16;
    if ( v6 )
    {
      if ( g_fDBCSEnabled )
      {
        v5 = KKGetPrefixWidth(hdc, lpString, c) - a5 * v6;
      }
      else
      {
        GetTextExtentPointWrap(hdc, String, 1, &sz);
        v5 = v6 * (sz.cx - a5);
      }
    }
  }
  GetTextExtentPointWrap(hdc, lpString, c, &sz);
  return sz.cx - v5;
}
// 6F7E68D4: using guessed type int g_fDBCSEnabled;

//----- (6F7D423D) --------------------------------------------------------
int __stdcall DT_DrawStr(HDC hdc, int xLeft, int y, LPCWSTR lpString, UINT c, int a6, unsigned __int32 a7, const struct DRAWTEXTDATA *a8)
{
  int v8; // ebx@1
  const struct DRAWTEXTDATA *v9; // esi@1
  LPCWSTR v10; // ecx@3
  signed int v11; // edi@3
  const WCHAR v12; // ax@4
  LONG v13; // eax@10
  bool v14; // zf@14
  int result; // eax@15
  int v16; // [sp+8h] [bp-8h]@1
  const WCHAR *v17; // [sp+Ch] [bp-4h]@4
  int xLefta; // [sp+1Ch] [bp+Ch]@1
  const struct DRAWTEXTDATA *v19; // [sp+34h] [bp+24h]@1

  v8 = xLeft;
  v9 = a8;
  xLefta = *((_DWORD *)a8 + 4);
  v16 = v8;
  v19 = *(const struct DRAWTEXTDATA **)a8;
  if ( a7 & 0x40 )
  {
    if ( c )
    {
      do
      {
        v10 = lpString;
        v11 = 0;
        if ( (signed int)c > 0 )
        {
          do
          {
            v12 = *v10;
            ++v10;
            v17 = v10;
            if ( v12 == 9 )
              break;
            ++v11;
          }
          while ( v11 < (signed int)c );
          if ( v11 )
          {
            if ( a6 && !(a7 & 0x400) )
              PSMTextOut(hdc, v8, y, lpString, v11, a7);
            v13 = DT_GetExtentMinusPrefixes(hdc, lpString, v11, a7, *((_DWORD *)v9 + 11));
            v10 = v17;
            v8 += v13 - *((_DWORD *)v9 + 11);
          }
          if ( v11 < (signed int)c )
          {
            ++v11;
            if ( xLefta )
              v8 = (int)((char *)v19 + xLefta * ((v8 - (signed int)v19) / xLefta + 1));
          }
        }
        v14 = c == v11;
        c -= v11;
        lpString = v10;
      }
      while ( !v14 );
    }
    result = v8 - v16;
  }
  else
  {
    if ( a6 && !(a7 & 0x400) )
      PSMTextOut(hdc, v8, y, lpString, c, a7);
    result = DT_GetExtentMinusPrefixes(hdc, lpString, c, a7, *((_DWORD *)v9 + 11)) - *((_DWORD *)v9 + 11);
  }
  return result;
}

//----- (6F7D4346) --------------------------------------------------------
void __stdcall DT_DrawJustifiedLine(HDC hdc, int y, LPCWSTR lpString, UINT c, unsigned __int32 a5, struct DRAWTEXTDATA *a6)
{
  int v6; // ecx@1
  int v7; // eax@2
  int v8; // ecx@2
  int v9; // eax@5

  v6 = *(_DWORD *)a6;
  if ( a5 & 3 )
  {
    v7 = *((_DWORD *)a6 + 11) + DT_DrawStr(hdc, v6, y, lpString, c, 0, a5, a6);
    v8 = *((_DWORD *)a6 + 2);
    if ( a5 & 1 )
      v6 = *(_DWORD *)a6 + ((v8 - *(_DWORD *)a6 - v7) >> 1);
    else
      v6 = v8 - v7;
  }
  v9 = *((_DWORD *)a6 + 11) + DT_DrawStr(hdc, v6, y, lpString, c, 1, a5, a6);
  if ( v9 > *((_DWORD *)a6 + 9) )
    *((_DWORD *)a6 + 9) = v9;
}

//----- (6F7D43B5) --------------------------------------------------------
int __stdcall DT_InitDrawTextInfo(HDC hdc, const struct tagRECT *a2, unsigned int a3, struct DRAWTEXTDATA *a4, const struct tagDRAWTEXTPARAMS *a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int result; // eax@6
  bool v8; // zf@7
  int v9; // eax@8
  int v10; // ecx@8
  int v11; // eax@8
  int v12; // eax@10
  struct tagTEXTMETRICW tm; // [sp+4h] [bp-50h]@7
  struct tagSIZE size; // [sp+40h] [bp-14h]@1
  struct tagSIZE v15; // [sp+48h] [bp-Ch]@1
  int v16; // [sp+50h] [bp-4h]@4
  const struct tagDRAWTEXTPARAMS *v17; // [sp+6Ch] [bp+18h]@6

  v5 = 0;
  size.cx = 0;
  size.cy = 0;
  v15.cx = 0;
  v15.cy = 0;
  v6 = 8;
  if ( a5 )
  {
    if ( a3 & 0x80 )
      v6 = a5->iTabLength;
    v5 = a5->iLeftMargin;
    v16 = a5->iRightMargin;
  }
  else
  {
    v16 = 0;
  }
  v17 = (const struct tagDRAWTEXTPARAMS *)v5;
  result = GetViewportExtEx(hdc, &size);
  if ( result )
  {
    GetWindowExtEx(hdc, &v15);
    *((_DWORD *)a4 + 5) = ((size.cx ^ v15.cx) & 0x80000000) != 0 ? -1 : 1;
    *((_DWORD *)a4 + 6) = ((size.cy ^ v15.cy) & 0x80000000) != 0 ? -1 : 1;
    GetTextMetricsW(hdc, &tm);
    *((_DWORD *)a4 + 7) = *((_DWORD *)a4 + 6) * (tm.tmHeight + ((a3 & 0x200) != 0 ? tm.tmExternalLeading : 0));
    *((_DWORD *)a4 + 4) = v6 * tm.tmAveCharWidth;
    *((_DWORD *)a4 + 11) = tm.tmOverhang;
    v8 = ((unsigned int)v17 | v16) == 0;
    *(_OWORD *)a4 = *a2;
    if ( v8 )
    {
      *((_DWORD *)a4 + 10) = 0;
    }
    else
    {
      v9 = *((_DWORD *)a4 + 5);
      v10 = v9;
      v11 = v16 * v9;
      *(_DWORD *)a4 += (_DWORD)v17 * v10;
      *((_DWORD *)a4 + 2) -= v11;
      *((_DWORD *)a4 + 10) = v11;
    }
    v12 = *((_DWORD *)a4 + 2) - *(_DWORD *)a4;
    *((_DWORD *)a4 + 9) = 0;
    *((_DWORD *)a4 + 8) = *((_DWORD *)a4 + 5) * v12;
    result = 1;
  }
  return result;
}

//----- (6F7D44C2) --------------------------------------------------------
const unsigned __int16 *__stdcall DT_AdjustWhiteSpaces(const unsigned __int16 *a1, int *a2, unsigned int a3)
{
  const unsigned __int16 *result; // eax@3
  __int16 v4; // cx@4
  __int16 v5; // cx@7

  if ( a3 & 3 )
  {
    if ( (a3 & 3) != 1 )
    {
      result = a1;
      if ( (a3 & 3) == 2 )
      {
        v4 = *(a1 - 1);
        if ( v4 == 32 || v4 == 9 )
          --*a2;
      }
      return result;
    }
    result = a1;
    v5 = *(a1 - 1);
    if ( v5 == 32 || v5 == 9 )
      --*a2;
  }
  else
  {
    result = a1;
  }
  if ( *result == 32 || *result == 9 )
    ++result;
  return result;
}

//----- (6F7D4529) --------------------------------------------------------
const unsigned __int16 *__stdcall DT_BreakAWord(HDC hdc, LPCWSTR lpString, int a3, int a4, unsigned int a5, int a6)
{
  int v6; // ebx@1
  signed int v7; // edi@1

  v6 = a3;
  v7 = 0;
  if ( a3 <= 1 )
    goto LABEL_12;
  do
  {
    if ( DT_GetExtentMinusPrefixes(hdc, lpString, v7 + (v6 - v7) / 2, a5, a6) <= a4 )
      v7 += (v6 - v7) / 2;
    else
      v6 = v7 + (v6 - v7) / 2;
  }
  while ( v6 - v7 > 1 );
  if ( !v7 )
  {
LABEL_12:
    if ( a3 )
      v7 = 1;
  }
  return &lpString[v7];
}

//----- (6F7D458D) --------------------------------------------------------
LPCWSTR __stdcall DT_GetLineBreak(HDC hdc, LPCWSTR lpString, int a3, unsigned __int32 a4, int *a5, struct DRAWTEXTDATA *a6)
{
  const unsigned __int16 *v6; // ebx@1
  struct DRAWTEXTDATA *v7; // edi@1
  int v8; // eax@2
  LPCWSTR v9; // esi@2
  int v10; // eax@2
  const unsigned __int16 v11; // cx@5
  const WCHAR v12; // ax@16
  bool v13; // zf@19
  int xLeft; // [sp+10h] [bp-Ch]@1
  int v16; // [sp+14h] [bp-8h]@1
  signed int v17; // [sp+18h] [bp-4h]@1
  const unsigned __int16 *v18; // [sp+38h] [bp+1Ch]@1

  v17 = 0;
  v16 = 0;
  v6 = lpString;
  v7 = a6;
  xLeft = *(_DWORD *)a6;
  v18 = &lpString[a3];
  if ( lpString >= v18 )
  {
    v9 = lpString;
  }
  else
  {
    while ( 1 )
    {
      v8 = GetNextWordbreak(v6, v18, a4, v7);
      v9 = (LPCWSTR)v8;
      a3 = v8;
      v10 = DT_DrawStr(hdc, xLeft, 0, lpString, (unsigned int)(v8 - (_DWORD)lpString) >> 1, 0, a4, v7);
      if ( a4 & 0x10 )
      {
        if ( v10 + *((_DWORD *)v7 + 11) > *((_DWORD *)v7 + 8) )
          break;
      }
      if ( v9 < v18 )
      {
        v11 = *v9;
        if ( *v9 == 13 || v11 == 10 )
        {
          ++v9;
          if ( v9 < v18 )
          {
            v13 = *v9 == (v11 ^ 7);
            goto LABEL_20;
          }
          goto LABEL_22;
        }
      }
      v6 = v9;
      v16 = v10;
      if ( v9 >= v18 )
        goto LABEL_26;
    }
    if ( v6 != lpString )
    {
      v9 = v6;
      a3 = (int)v6;
      v17 = 1;
      goto LABEL_26;
    }
    if ( a4 & 0x2000 && !(a4 & 0x40000) )
    {
      v9 = DT_BreakAWord(
             hdc,
             v6,
             (unsigned int)((char *)v9 - (char *)v6) >> 1,
             *((_DWORD *)v7 + 8) - v16,
             a4,
             *((_DWORD *)v7 + 11));
      a3 = (int)v9;
      goto LABEL_26;
    }
    v17 = 1;
    if ( a4 & 0x40000 )
    {
      if ( v9 < v18 )
      {
        v12 = *v9;
        if ( *v9 == 13 || v12 == 10 )
        {
          ++v9;
          if ( v9 < v18 )
          {
            v13 = *v9 == (v12 ^ 7);
LABEL_20:
            if ( v13 )
              ++v9;
          }
LABEL_22:
          v17 = 0;
          goto LABEL_26;
        }
      }
    }
  }
LABEL_26:
  *a5 = (unsigned int)(a3 - (_DWORD)lpString) >> 1;
  if ( v17 && v9 < v18 )
    v9 = DT_AdjustWhiteSpaces(v9, a5, a4);
  return v9;
}

//----- (6F7D46F0) --------------------------------------------------------
int __stdcall NeedsEndEllipsis(HDC hdc, LPCWSTR lpString, int *a3, const struct DRAWTEXTDATA *a4, unsigned int a5)
{
  int v5; // esi@1
  int result; // eax@2
  LONG v7; // ebx@3
  int v8; // edi@3
  LONG v9; // ebx@5
  int v10; // edi@5
  LONG v11; // eax@7
  struct tagSIZE sz; // [sp+4h] [bp-Ch]@5
  int v13; // [sp+Ch] [bp-4h]@3
  int v14; // [sp+24h] [bp+14h]@6

  v5 = *a3;
  if ( *a3 )
  {
    v7 = *((_DWORD *)a4 + 8);
    v13 = *((_DWORD *)a4 + 11);
    v8 = v13;
    if ( DT_GetExtentMinusPrefixes(hdc, lpString, v5, a5, v13) > v7 )
    {
      GetTextExtentPointWrap(hdc, L"...", 3, &sz);
      v9 = v8 - sz.cx + v7;
      result = 1;
      v10 = 1;
      if ( v9 > 0 )
      {
        v14 = 0;
        v10 = v5;
        while ( v14 < v10 )
        {
          v11 = DT_GetExtentMinusPrefixes(hdc, lpString, (v14 + v10 + 1) / 2, a5, v13);
          if ( v11 >= v9 )
          {
            if ( v11 <= v9 )
            {
              v10 = (v14 + v10 + 1) / 2;
              break;
            }
            v10 = (v14 + v10 + 1) / 2 - 1;
          }
          else
          {
            v14 = (v14 + v10 + 1) / 2;
          }
        }
        result = 1;
        if ( v10 < 1 )
          v10 = 1;
      }
      *a3 = v10;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7D47AB) --------------------------------------------------------
const unsigned __int16 *__stdcall PathFindFileNameW(const unsigned __int16 *a1, int a2)
{
  const unsigned __int16 *v2; // ecx@1
  const unsigned __int16 *result; // eax@1
  const unsigned __int16 v4; // dx@2

  v2 = a1;
  result = a1;
  while ( a2 > 0 )
  {
    v4 = *v2;
    if ( !*v2 )
      break;
    if ( v4 == 92 || v4 == 58 )
    {
      if ( v2[1] )
        result = v2 + 1;
    }
    ++v2;
    --a2;
  }
  return result;
}

//----- (6F7D47EA) --------------------------------------------------------
int __stdcall AddPathEllipsis(HDC hdc, LPCWSTR lpString, int a3, unsigned int a4, int a5, int a6)
{
  const unsigned __int16 *v6; // eax@1
  int v7; // eax@2
  unsigned int v8; // edi@2
  int v9; // ebx@2
  LONG v10; // esi@2
  LONG v11; // eax@3
  int v12; // eax@3
  LPCWSTR v13; // edi@10
  signed int v14; // eax@11
  int result; // eax@11
  struct tagSIZE sz; // [sp+4h] [bp-18h]@2
  LONG v17; // [sp+Ch] [bp-10h]@2
  void *Src; // [sp+10h] [bp-Ch]@2
  int v19; // [sp+14h] [bp-8h]@2
  LPCWSTR v20; // [sp+18h] [bp-4h]@2

  v6 = PathFindFileNameW(lpString, a3);
  if ( v6 == lpString )
  {
    result = a3;
  }
  else
  {
    v19 = 0;
    v7 = (int)(v6 - 1);
    v8 = v7 - (_DWORD)lpString;
    Src = (void *)v7;
    v9 = a3 - ((v7 - (signed int)lpString) >> 1);
    v20 = (LPCWSTR)v7;
    v17 = DT_GetExtentMinusPrefixes(hdc, (LPCWSTR)v7, v9, a4, a6);
    GetTextExtentPointWrap(hdc, L"...", 3, &sz);
    v10 = sz.cx - a6;
    v17 -= a6;
    while ( 1 )
    {
      v11 = DT_GetExtentMinusPrefixes(hdc, lpString, v8 >> 1, a4, a6);
      v12 = v17 + v11;
      if ( v19 )
        v12 += v10;
      if ( v12 <= a5 )
        break;
      v19 = 1;
      if ( v20 <= lpString )
      {
        v20 = lpString;
        break;
      }
      --v20;
      v8 -= 2;
    }
    if ( v19 && (v13 = v20, (unsigned int)(v20 + 3) < (unsigned int)Src) )
    {
      memmove((void *)(v20 + 3), Src, 2 * v9);
      v14 = (char *)v20 - (char *)lpString;
      *(_DWORD *)v13 = *(_DWORD *)L"...";
      result = (v14 >> 1) + v9 + 3;
      *((_WORD *)v13 + 2) = a___[2];
      lpString[result] = 0;
    }
    else
    {
      result = a3;
    }
  }
  return result;
}

//----- (6F7D48E8) --------------------------------------------------------
int __stdcall IsComplexScriptPresent(const unsigned __int16 *a1, int a2)
{
  int v2; // eax@1
  int result; // eax@5

  v2 = 0;
  if ( g_bComplexPlatform && a2 > 0 )
  {
    while ( (unsigned int)a1[v2] - 1424 > 0xA6F )
    {
      ++v2;
      if ( v2 >= a2 )
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}
// 6F7E6864: using guessed type int g_bComplexPlatform;

//----- (6F7D4927) --------------------------------------------------------
HRESULT __stdcall StringCchCopyNW(STRSAFE_LPWSTR pszDest, size_t cchDest, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy)
{
  HRESULT result; // eax@1
  STRSAFE_LPWSTR v5; // eax@7
  HRESULT v6; // ebx@7
  size_t v7; // esi@7
  wchar_t v8; // cx@9

  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    if ( cchToCopy <= 0x7FFFFFFE )
    {
      v5 = pszDest;
      v6 = 0;
      v7 = cchDest;
      if ( !cchDest )
        goto LABEL_16;
      do
      {
        if ( !(cchToCopy - cchDest + v7) )
          break;
        v8 = *(STRSAFE_LPWSTR)((char *)v5 + (char *)pszSrc - (char *)pszDest);
        if ( !v8 )
          break;
        *v5 = v8;
        ++v5;
        --v7;
      }
      while ( v7 );
      if ( !v7 )
      {
LABEL_16:
        --v5;
        v6 = -2147024774;
      }
      *v5 = 0;
      result = v6;
    }
    else
    {
      result = -2147024809;
      *pszDest = 0;
    }
  }
  return result;
}

//----- (6F7D49AA) --------------------------------------------------------
size_t __stdcall AddEllipsisAndDrawLine(HDC hdc, int y, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy, unsigned __int32 a5, struct DRAWTEXTDATA *const a6)
{
  size_t v6; // ebx@1
  const WCHAR *v7; // esi@1
  struct DRAWTEXTDATA *const v8; // edi@1
  char *v9; // eax@6
  int v10; // eax@15
  char *v11; // eax@20
  HRESULT v12; // eax@26
  HLOCAL hMem; // [sp+10h] [bp-118h]@1
  wchar_t *pszDest; // [sp+14h] [bp-114h]@0
  size_t cchDest; // [sp+18h] [bp-110h]@1
  SIZE_T uBytes; // [sp+1Ch] [bp-10Ch]@1
  HRESULT v18; // [sp+20h] [bp-108h]@1
  char v19; // [sp+24h] [bp-104h]@6

  v6 = cchToCopy;
  v7 = pszSrc;
  v8 = a6;
  hMem = 0;
  cchDest = cchToCopy;
  uBytes = 0;
  v18 = 0;
  if ( a5 & 0x4000 && DT_GetExtentMinusPrefixes(hdc, pszSrc, cchToCopy, a5, *((_DWORD *)a6 + 11)) > *((_DWORD *)v8 + 8) )
  {
    if ( a5 & 0x10000 )
    {
LABEL_13:
      v6 = AddPathEllipsis(hdc, v7, v6, a5, *((_DWORD *)v8 + 8), *((_DWORD *)v8 + 11));
      cchToCopy = v6;
      goto LABEL_14;
    }
    v18 = ULongAdd(v6, 3u, (ULONG *)&cchDest);
    if ( v18 < 0 )
      return 0;
    if ( cchDest > 0x80 )
    {
      if ( ULongLongToULong(2i64 * cchDest, &uBytes) < 0 || (v9 = (char *)LocalAlloc(0x40u, uBytes), (hMem = v9) == 0) )
      {
        v18 = -2147467259;
        goto LABEL_11;
      }
    }
    else
    {
      v9 = &v19;
    }
    pszDest = (wchar_t *)v9;
LABEL_11:
    if ( v18 < 0 )
      goto LABEL_33;
    v7 = pszDest;
    v18 = StringCchCopyNW(pszDest, cchDest, pszSrc, v6);
    uBytes = 1;
    if ( v18 < 0 )
      goto LABEL_33;
    goto LABEL_13;
  }
LABEL_14:
  if ( a5 & 0x48000 )
  {
    v10 = NeedsEndEllipsis(hdc, v7, (int *)&cchToCopy, v8, a5);
    v6 = cchToCopy;
    if ( v10 )
    {
      if ( a5 & 0x10000 || uBytes )
      {
LABEL_27:
        if ( v18 < 0 )
          goto LABEL_33;
        v18 = ULongAdd(v6, 3u, &uBytes);
        if ( v18 < 0 )
          goto LABEL_33;
        if ( uBytes <= cchDest )
        {
          v18 = StringCchCopyNW((STRSAFE_LPWSTR)&v7[v6], cchDest - v6, L"...", 3u);
          v6 += 3;
        }
        goto LABEL_31;
      }
      v18 = ULongAdd(cchToCopy, 3u, (ULONG *)&cchDest);
      if ( v18 < 0 )
        goto LABEL_33;
      if ( cchDest > 0x80 )
      {
        if ( ULongLongToULong(2i64 * cchDest, &uBytes) < 0
          || (v11 = (char *)LocalAlloc(0x40u, uBytes), (hMem = v11) == 0) )
        {
          v18 = -2147467259;
          goto LABEL_25;
        }
      }
      else
      {
        v11 = &v19;
      }
      pszDest = (wchar_t *)v11;
LABEL_25:
      if ( v18 < 0 )
        goto LABEL_33;
      v12 = StringCchCopyNW(pszDest, cchDest, v7, v6);
      v7 = pszDest;
      v18 = v12;
      goto LABEL_27;
    }
  }
LABEL_31:
  if ( v18 >= 0 )
    DT_DrawJustifiedLine(hdc, y, v7, v6, a5, v8);
LABEL_33:
  if ( hMem )
    LocalFree(hMem);
  if ( v18 >= 0 )
    return v6;
  return 0;
}

//----- (6F7D4C73) --------------------------------------------------------
LONG __stdcall DrawTextExPrivWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
{
  LONG result; // eax@2
  unsigned int v7; // ebx@3
  UINT v8; // eax@23
  HRGN v9; // eax@25
  void *v10; // esi@25
  LONG v11; // edi@31
  UINT v12; // eax@32
  __int64 v13; // rax@35
  int v14; // esi@37
  unsigned int v15; // eax@44
  unsigned int v16; // eax@49
  __int16 v17; // ax@54
  int v18; // ecx@58
  bool v19; // zf@58
  bool v20; // sf@58
  unsigned __int8 v21; // of@58
  LPRECT v22; // esi@58
  LONG v23; // ecx@71
  int v24; // [sp+4h] [bp-70h]@19
  int v25; // [sp+Ch] [bp-68h]@58
  int v26; // [sp+18h] [bp-5Ch]@58
  int v27; // [sp+1Ch] [bp-58h]@37
  int v28; // [sp+20h] [bp-54h]@34
  int v29; // [sp+24h] [bp-50h]@20
  int v30; // [sp+28h] [bp-4Ch]@58
  int v31; // [sp+2Ch] [bp-48h]@58
  int left; // [sp+34h] [bp-40h]@28
  int top; // [sp+38h] [bp-3Ch]@28
  int right; // [sp+3Ch] [bp-38h]@28
  int bottom; // [sp+40h] [bp-34h]@28
  UINT align; // [sp+44h] [bp-30h]@23
  UINT v37; // [sp+48h] [bp-2Ch]@22
  UINT v38; // [sp+4Ch] [bp-28h]@24
  UINT v39; // [sp+50h] [bp-24h]@30
  UINT v40; // [sp+54h] [bp-20h]@30
  unsigned int v41; // [sp+58h] [bp-1Ch]@44
  UINT c; // [sp+5Ch] [bp-18h]@44
  int v43; // [sp+60h] [bp-14h]@37
  int v44; // [sp+64h] [bp-10h]@37
  unsigned int v45; // [sp+68h] [bp-Ch]@30
  int v46; // [sp+6Ch] [bp-8h]@31
  unsigned int v47; // [sp+70h] [bp-4h]@30
  void *lpchTexta; // [sp+80h] [bp+Ch]@25

  if ( g_bRunOnNT5 )
    return DrawTextExW(hdc, lpchText, cchText, lprc, format, lpdtp);
  v7 = (unsigned int)lpchText;
  if ( cchText )
  {
    if ( cchText == -1 )
    {
      cchText = lstrlenW(lpchText);
      goto LABEL_11;
    }
  }
  else if ( lpchText && *lpchText )
  {
    return 1;
  }
  if ( !lpchText[cchText - 1] )
    --cchText;
LABEL_11:
  if ( IsComplexScriptPresent(lpchText, cchText) )
    return DrawTextExW(hdc, lpchText, cchText, lprc, format, lpdtp);
  if ( lpdtp && lpdtp->cbSize != 20 || format & 0x10000 && format & 0xC000 && !lpchText )
    return 0;
  result = DT_InitDrawTextInfo(hdc, lprc, format, (struct DRAWTEXTDATA *)&v24, lpdtp);
  if ( result )
  {
    if ( v29 <= 0 && format & 0x10 )
      goto LABEL_72;
    v37 = format & 0x20000;
    if ( format & 0x20000 )
    {
      v8 = GetTextAlign(hdc);
      align = SetTextAlign(hdc, v8 | 0x100);
    }
    v38 = format & 0x100;
    if ( format & 0x100 )
    {
      lpchTexta = 0;
    }
    else
    {
      v9 = CreateRectRgn(0, 0, 0, 0);
      v10 = v9;
      lpchTexta = v9;
      if ( v9 )
      {
        if ( GetClipRgn(hdc, v9) != 1 )
        {
          DeleteObject(v10);
          lpchTexta = (void *)-1;
        }
        left = lprc->left;
        top = lprc->top;
        right = lprc->right;
        bottom = lprc->bottom;
        IntersectClipRect(hdc, left, top, right, bottom);
      }
    }
    v47 = v7 + 2 * cchText;
    v39 = format & 0x20;
    v45 = v7;
    v40 = format & 0x400;
    while ( 1 )
    {
      v46 = 0;
      v11 = lprc->top;
      if ( (_WORD)v39 )
        break;
      v14 = (format & 0x2000) != 0 ? v28 : 0;
      v43 = 0;
      v44 = v27;
      while ( v7 < v47 && !v43 )
      {
        if ( (_WORD)v40 || (_WORD)v38 || v44 * (v11 + v14 + v28) <= v44 * lprc->bottom || (v43 = 1, !(format & 0xC000)) )
        {
          v15 = (unsigned int)DT_GetLineBreak(hdc, (LPCWSTR)v7, cchText, format, (int *)&c, (struct DRAWTEXTDATA *)&v24);
          v41 = v15;
          if ( format & 0x40000 || v15 >= v47 && format & 0xC000 )
            AddEllipsisAndDrawLine(hdc, v11, (STRSAFE_PCNZWCH)v7, c, format, (struct DRAWTEXTDATA *const )&v24);
          else
            DT_DrawJustifiedLine(hdc, v11, (LPCWSTR)v7, c, format, (struct DRAWTEXTDATA *)&v24);
          v16 = v41 - v7;
          v7 = v41;
          cchText -= v16 >> 1;
        }
        else
        {
          v7 += 2
              * AddEllipsisAndDrawLine(
                  hdc,
                  v11,
                  (STRSAFE_PCNZWCH)v7,
                  cchText,
                  format,
                  (struct DRAWTEXTDATA *const )&v24);
        }
        ++v46;
        v11 += v28;
      }
      if ( !(format & 0x2000) && v47 > v45 )
      {
        v17 = *(_WORD *)(v47 - 2);
        if ( v17 == 13 || v17 == 10 )
          goto LABEL_56;
      }
LABEL_57:
      if ( !(_WORD)v40 )
      {
        v22 = lprc;
LABEL_63:
        if ( lpchTexta )
        {
          if ( lpchTexta == (void *)-1 )
          {
            ExtSelectClipRgn(hdc, 0, 5);
          }
          else
          {
            ExtSelectClipRgn(hdc, (HRGN)lpchTexta, 5);
            DeleteObject(lpchTexta);
          }
        }
        if ( v37 )
          SetTextAlign(hdc, align);
        if ( lpdtp )
          lpdtp->uiLengthDrawn = (v7 - v45) >> 1;
        v23 = v22->top;
        if ( v11 == v23 )
LABEL_72:
          result = 1;
        else
          result = v11 - v23;
        return result;
      }
      v18 = v30;
      v25 = v24 + v30 * v26;
      v21 = __OFSUB__(v46, 1);
      v19 = v46 == 1;
      v20 = v46 - 1 < 0;
      v22 = lprc;
      lprc->right = v31 + v25;
      if ( (unsigned __int8)(v20 ^ v21) | v19 || v18 <= v29 )
      {
        lprc->bottom = v11;
        goto LABEL_63;
      }
      v7 = v45;
      v29 = v18;
      cchText = (v47 - v45) >> 1;
    }
    v12 = format & 0xC;
    v46 = 1;
    if ( v12 == 4 )
    {
      v13 = lprc->bottom - v11 - v28;
      v11 += ((signed int)v13 - HIDWORD(v13)) >> 1;
    }
    else if ( v12 == 8 )
    {
      v11 = lprc->bottom - v28;
    }
    v7 += 2 * AddEllipsisAndDrawLine(hdc, v11, (STRSAFE_PCNZWCH)v7, cchText, format, (struct DRAWTEXTDATA *const )&v24);
LABEL_56:
    v11 += v28;
    goto LABEL_57;
  }
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7D5024) --------------------------------------------------------
LONG __stdcall DrawTextWrap(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format)
{
  LONG result; // eax@1
  UINT v6; // ecx@2
  int v7; // [sp+0h] [bp-14h]@3
  int v8; // [sp+4h] [bp-10h]@3
  int v9; // [sp+8h] [bp-Ch]@3
  int v10; // [sp+Ch] [bp-8h]@3

  result = 0;
  if ( cchText >= -1 )
  {
    v6 = format;
    if ( (format & 0x80u) != 0 )
    {
      v10 = 0;
      v9 = 0;
      v8 = (unsigned __int16)format >> 8;
      v7 = 20;
      result = (LONG)&v7;
      v6 = format & 0xFFFF00FF;
    }
    result = DrawTextExPrivWrap(hdc, lpchText, cchText, lprc, v6, (LPDRAWTEXTPARAMS)result);
  }
  return result;
}

//----- (6F7D507A) --------------------------------------------------------
int __stdcall WimpyDrawEx(struct IImageList *a1, int a2, HDC a3, int a4, int a5, int a6, int a7, unsigned __int32 a8, unsigned __int32 a9, unsigned int a10)
{
  struct IImageListVtbl *v10; // ecx@1
  int v12; // [sp+0h] [bp-44h]@1
  struct IImageList *Dst; // [sp+4h] [bp-40h]@1
  int v14; // [sp+8h] [bp-3Ch]@1
  HDC v15; // [sp+Ch] [bp-38h]@1
  int v16; // [sp+10h] [bp-34h]@1
  int v17; // [sp+14h] [bp-30h]@1
  int v18; // [sp+18h] [bp-2Ch]@1
  int v19; // [sp+1Ch] [bp-28h]@1
  unsigned __int32 v20; // [sp+28h] [bp-1Ch]@1
  unsigned __int32 v21; // [sp+2Ch] [bp-18h]@1
  unsigned int v22; // [sp+30h] [bp-14h]@1
  int v23; // [sp+34h] [bp-10h]@1

  memset(&Dst, 0, 0x40u);
  v14 = a2;
  v15 = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v19 = a7;
  v20 = a8;
  v21 = a9;
  v22 = a10;
  v10 = a1->lpVtbl;
  v12 = 68;
  Dst = a1;
  v23 = 13369376;
  return v10->Draw(a1, (IMAGELISTDRAWPARAMS *)&v12);
}

//----- (6F7D50EF) --------------------------------------------------------
int __stdcall WimpyDraw(struct IImageList *a1, int a2, HDC a3, int a4, int a5, unsigned int a6)
{
  struct IImageListVtbl *v6; // ecx@1
  int v8; // [sp+0h] [bp-44h]@1
  struct IImageList *Dst; // [sp+4h] [bp-40h]@1
  int v10; // [sp+8h] [bp-3Ch]@1
  HDC v11; // [sp+Ch] [bp-38h]@1
  int v12; // [sp+10h] [bp-34h]@1
  int v13; // [sp+14h] [bp-30h]@1
  int v14; // [sp+28h] [bp-1Ch]@1
  int v15; // [sp+2Ch] [bp-18h]@1
  unsigned int v16; // [sp+30h] [bp-14h]@1
  int v17; // [sp+34h] [bp-10h]@1

  memset(&Dst, 0, 0x40u);
  v10 = a2;
  v11 = a3;
  v12 = a4;
  v13 = a5;
  v14 = -16777216;
  v15 = -16777216;
  v16 = a6;
  v6 = a1->lpVtbl;
  v8 = 68;
  Dst = a1;
  v17 = 13369376;
  return v6->Draw(a1, (IMAGELISTDRAWPARAMS *)&v8);
}

//----- (6F7D5157) --------------------------------------------------------
__int32 __stdcall CImageList::GetPrivateGoo(CImageList *this, HBITMAP *a2, HDC *a3, HBITMAP *a4, HDC *a5)
{
  if ( a2 )
    *a2 = (HBITMAP)*((_DWORD *)this + 16);
  if ( a3 )
    *a3 = (HDC)*((_DWORD *)this + 18);
  if ( a4 )
    *a4 = (HBITMAP)*((_DWORD *)this + 17);
  if ( a5 )
    *a5 = (HDC)*((_DWORD *)this + 19);
  return 0;
}

//----- (6F7D519A) --------------------------------------------------------
int __stdcall CImageList::GetMirror(CImageList *this, const struct _GUID *a2, void **a3)
{
  int result; // eax@2

  if ( *((_DWORD *)this + 110) )
    result = (***((int (__stdcall ****)(_DWORD, _DWORD, _DWORD))this + 110))(*((_DWORD *)this + 110), a2, a3);
  else
    result = -2147467262;
  return result;
}

//----- (6F7D51C9) --------------------------------------------------------
int __stdcall GetScreenDepth()
{
  HDC v0; // ebx@1
  int v1; // edi@1
  int v2; // edi@1

  v0 = GetDC(0);
  v1 = GetDeviceCaps(v0, 14);
  v2 = GetDeviceCaps(v0, 12) * v1;
  ReleaseDC(0, v0);
  return v2;
}

//----- (6F7D5201) --------------------------------------------------------
void __stdcall ImageList_ReleaseWorkDC(HDC hdc)
{
  HPALETTE v1; // eax@2

  if ( GetDeviceCaps(hdc, 38) & 0x100 )
  {
    v1 = (HPALETTE)GetStockObject(15);
    SelectPalette(hdc, v1, 1);
  }
}

//----- (6F7D5235) --------------------------------------------------------
int __thiscall CImageList::_SetIconSize(CImageList *this, int a2, int a3)
{
  int v3; // eax@1
  int result; // eax@3

  v3 = *((_DWORD *)this + 12);
  if ( v3 != a2 || *((_DWORD *)this + 13) != a3 )
  {
    if ( v3 < 0 || *((_DWORD *)this + 13) < 0 )
    {
      result = -2147024809;
    }
    else
    {
      *((_DWORD *)this + 12) = a2;
      *((_DWORD *)this + 13) = a3;
      result = (*(int (__stdcall **)(char *, signed int))(*((_DWORD *)this + 2) + 36))((char *)this + 8, -1);
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F7D527E) --------------------------------------------------------
int __stdcall CImageList::SetIconSize(CImageList *this, int a2, int a3)
{
  CImageList *v3; // ecx@1

  v3 = (CImageList *)*((_DWORD *)this + 111);
  if ( v3 )
    CImageList::_SetIconSize(v3, a2, a3);
  return CImageList::_SetIconSize((CImageList *)((char *)this - 8), a2, a3);
}

//----- (6F7D52B4) --------------------------------------------------------
signed int __stdcall CImageList::SetFlags(CImageList *this, unsigned int a2)
{
  int v2; // ecx@1
  signed int result; // eax@2
  void *v4; // esi@4

  v2 = *((_DWORD *)this + 12);
  if ( v2 & 0xFFFFD600 || ((unsigned __int16)a2 ^ (unsigned __int16)v2) & 0x100 )
  {
    result = -2147024809;
  }
  else
  {
    v4 = (void *)*((_DWORD *)this + 16);
    *((_DWORD *)this + 16) = 0;
    *((_DWORD *)this + 12) = a2;
    (*(void (__stdcall **)(char *, signed int))(*((_DWORD *)this - 1) + 36))((char *)this - 4, -1);
    if ( v4 )
      DeleteObject(v4);
    result = 0;
  }
  return result;
}

//----- (6F7D5308) --------------------------------------------------------
__int32 __stdcall CImageList::GetFlags(CImageList *this, unsigned int *a2)
{
  *a2 = *((_DWORD *)this + 12) & 0x29FF | (*((_DWORD *)this + 110) != 0 ? 0x2000 : 0);
  return 0;
}

//----- (6F7D533A) --------------------------------------------------------
HGDIOBJ __stdcall CImageList::_CreateMirroredBitmap(HBITMAP h)
{
  HDC v3; // eax@4
  HDC v4; // eax@4
  HDC v5; // ebx@4
  HDC v6; // [sp-Ch] [bp-38h]@4
  char pv; // [sp+4h] [bp-28h]@3
  int v8; // [sp+8h] [bp-24h]@9
  int cy; // [sp+Ch] [bp-20h]@9
  HGDIOBJ v10; // [sp+1Ch] [bp-10h]@12
  HGDIOBJ v11; // [sp+20h] [bp-Ch]@9
  HDC v12; // [sp+24h] [bp-8h]@5
  HDC hdc; // [sp+28h] [bp-4h]@4
  HGDIOBJ ha; // [sp+34h] [bp+8h]@10
  HGDIOBJ hb; // [sp+34h] [bp+8h]@12

  if ( !h || !GetObjectW(h, 24, &pv) )
    return 0;
  v3 = GetDC(0);
  hdc = v3;
  v4 = CreateCompatibleDC(v3);
  v6 = hdc;
  v5 = v4;
  if ( !v4 )
    goto LABEL_7;
  v12 = CreateCompatibleDC(hdc);
  if ( !v12 )
  {
    DeleteDC(v5);
    v6 = hdc;
LABEL_7:
    ReleaseDC(0, v6);
    return 0;
  }
  v11 = CreateColorBitmap(v8, cy);
  if ( v11 )
  {
    hb = SelectObject(v5, h);
    v10 = SelectObject(v12, v11);
    SetLayout(v12, 1u);
    BitBlt(v12, 0, 0, v8, cy, v5, 0, 0, 0xCC0020u);
    SelectObject(v5, hb);
    SelectObject(v5, v10);
    ha = v11;
  }
  else
  {
    ha = 0;
  }
  DeleteDC(v12);
  DeleteDC(v5);
  ReleaseDC(0, hdc);
  return ha;
}

//----- (6F7D542B) --------------------------------------------------------
signed int __stdcall CImageList::SetColorTable(CImageList *this, UINT iStart, UINT cEntries, RGBQUAD *prgbq, int *a5)
{
  HDC v5; // eax@1
  signed int result; // eax@2

  *((_DWORD *)this + 5) = 1;
  v5 = (HDC)*((_DWORD *)this + 18);
  if ( v5 )
  {
    *a5 = SetDIBColorTable(v5, iStart, cEntries, prgbq);
    result = 0;
  }
  else
  {
    result = -2147467259;
  }
  return result;
}

//----- (6F7D5468) --------------------------------------------------------
void __thiscall CImageList::_RemoveItemBitmap(CImageList *this, int y1)
{
  CImageList *v2; // esi@1
  char *v3; // edi@1
  int v4; // ecx@4
  int v5; // ecx@9
  char v6; // [sp+Ch] [bp-24h]@1
  int v7; // [sp+10h] [bp-20h]@4
  int x; // [sp+1Ch] [bp-14h]@1
  int y; // [sp+20h] [bp-10h]@2
  int x1; // [sp+24h] [bp-Ch]@1
  int v11; // [sp+2Ch] [bp-4h]@4
  int y1a; // [sp+38h] [bp+8h]@1
  int y1b; // [sp+38h] [bp+8h]@4

  v2 = this;
  v3 = (char *)this + 8;
  (*(void (__stdcall **)(char *, int, int *))(*((_DWORD *)this + 2) + 60))((char *)this + 8, y1, &x);
  (*(void (__stdcall **)(int, int, char *))(*(_DWORD *)v3 + 60))((char *)v2 + 8, *((_DWORD *)v2 + 9) - 1, &v6);
  y1a = *((_DWORD *)v2 + 14) * *((_DWORD *)v2 + 12) - x1;
  if ( *((_DWORD *)v2 + 14) * *((_DWORD *)v2 + 12) != x1 )
  {
    BitBlt(
      *((HDC *)v2 + 21),
      x,
      y,
      *((_DWORD *)v2 + 14) * *((_DWORD *)v2 + 12) - x1,
      *((_DWORD *)v2 + 13),
      *((HDC *)v2 + 21),
      x1,
      y,
      0xCC0020u);
    if ( *((_DWORD *)v2 + 22) )
      BitBlt(*((HDC *)v2 + 22), x, y, y1a, *((_DWORD *)v2 + 13), *((HDC *)v2 + 22), x1, y, 0xCC0020u);
  }
  v4 = *((_DWORD *)v2 + 12) * (*((_DWORD *)v2 + 14) - 1);
  y1b = y;
  v11 = *((_DWORD *)v2 + 12) * (*((_DWORD *)v2 + 14) - 1);
  if ( y < v7 )
  {
    while ( 1 )
    {
      BitBlt(
        *((HDC *)v2 + 21),
        v4,
        y1b,
        *((_DWORD *)v2 + 12),
        *((_DWORD *)v2 + 13),
        *((HDC *)v2 + 21),
        0,
        *((_DWORD *)v2 + 13) + y1b,
        0xCC0020u);
      if ( *((_DWORD *)v2 + 22) )
        BitBlt(
          *((HDC *)v2 + 22),
          v11,
          y1b,
          *((_DWORD *)v2 + 12),
          *((_DWORD *)v2 + 13),
          *((HDC *)v2 + 22),
          0,
          *((_DWORD *)v2 + 13) + y1b,
          0xCC0020u);
      v5 = *((_DWORD *)v2 + 13);
      y1b += v5;
      if ( y1b <= v7 )
      {
        BitBlt(*((HDC *)v2 + 21), 0, y1b, v11, v5, *((HDC *)v2 + 21), *((_DWORD *)v2 + 12), y1b, 0xCC0020u);
        if ( *((_DWORD *)v2 + 22) )
          BitBlt(
            *((HDC *)v2 + 22),
            0,
            y1b,
            v11,
            *((_DWORD *)v2 + 13),
            *((HDC *)v2 + 22),
            *((_DWORD *)v2 + 12),
            y1b,
            0xCC0020u);
      }
      if ( y1b >= v7 )
        break;
      v4 = v11;
    }
  }
}

//----- (6F7D559E) --------------------------------------------------------
void __stdcall BlendCT(unsigned __int32 *a1, unsigned __int32 a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax@1
  unsigned __int32 v5; // edx@2
  unsigned __int32 *v6; // ecx@3
  int v7; // ebx@3
  unsigned int v8; // [sp+0h] [bp-Ch]@1
  unsigned __int32 v9; // [sp+4h] [bp-8h]@2

  v4 = 0;
  v8 = 0;
  if ( a4 )
  {
    v5 = a2;
    HIWORD(a2) = (unsigned __int16)a2 >> 8;
    v9 = v5 >> 16;
    do
    {
      v6 = &a1[v4];
      v7 = (unsigned __int8)((a3 * (unsigned __int8)v9 + (100 - a3) * *(_BYTE *)v6) / 0x64) | ((((unsigned __int8)((a3 * (unsigned __int8)a2 + (100 - a3) * *((_BYTE *)v6 + 2)) / 0x64) << 8) | (unsigned __int8)((a3 * BYTE2(a2) + (100 - a3) * *((_BYTE *)v6 + 1)) / 0x64)) << 8);
      v4 = v8 + 1;
      *v6 = v7;
      v8 = v4;
    }
    while ( v4 < a4 );
  }
}

//----- (6F7D5658) --------------------------------------------------------
void __stdcall ImageList_BlendDither(HDC hdc, int x, int y, struct CImageList *a4, int x1, int y1, int w, int h, COLORREF color, unsigned int a10)
{
  HBRUSH v10; // eax@4
  HGDIOBJ v11; // [sp+Ch] [bp-8h]@1
  HGDIOBJ ho; // [sp+10h] [bp-4h]@1
  HGDIOBJ colora; // [sp+3Ch] [bp+28h]@7
  HGDIOBJ colorb; // [sp+3Ch] [bp+28h]@7

  ho = 0;
  v11 = g_hbrMonoDither;
  if ( color == -16777216 )
  {
    v10 = g_hbrHighlight;
  }
  else if ( color == -1 || color == *((_DWORD *)a4 + 17) )
  {
    v10 = (HBRUSH)*((_DWORD *)a4 + 18);
  }
  else
  {
    v10 = CreateSolidBrush(color);
    ho = v10;
  }
  colora = SelectObject(hdc, v10);
  PatBlt(hdc, x, y, w, h, 0xF00021u);
  SelectObject(hdc, colora);
  colorb = SelectObject(hdc, v11);
  BitBlt(hdc, x, y, w, h, *((HDC *)a4 + 21), x1, y1, 0xAC0744u);
  SelectObject(hdc, colorb);
  if ( ho )
    DeleteObject(ho);
}

//----- (6F7D5714) --------------------------------------------------------
void __stdcall ImageList_BlendCT(HDC hdc, int xDest, int yDest, struct CImageList *a4, int xSrc, int a6, int DestWidth, int DestHeight, unsigned __int32 a9, char a10)
{
  unsigned __int32 v10; // edi@1
  void *v11; // ST28_4@4
  unsigned int v12; // eax@4
  char pv; // [sp+Ch] [bp-18h]@1
  void *lpBits; // [sp+20h] [bp-4h]@5

  GetObjectW(*((HANDLE *)a4 + 19), 24, &pv);
  v10 = a9;
  if ( a9 == -16777216 )
    v10 = GetSysColor(13);
  if ( *((_DWORD *)a4 + 16) != v10 )
  {
    v11 = (void *)*((_DWORD *)a4 + 19);
    *((_DWORD *)a4 + 16) = v10;
    GetObjectW(v11, 84, (char *)a4 + 456);
    v12 = GetDIBColorTable(*((HDC *)a4 + 21), 0, 0x100u, (RGBQUAD *)a4 + 130);
    BlendCT((unsigned __int32 *)a4 + 130, v10, (a10 & 0xE) != 4 ? 25 : 50, v12);
  }
  StretchDIBits(
    hdc,
    xDest,
    yDest,
    DestWidth,
    DestHeight,
    xSrc,
    *((_DWORD *)a4 + 122) - a6 - DestHeight,
    DestWidth,
    DestHeight,
    lpBits,
    (const BITMAPINFO *)((char *)a4 + 480),
    0,
    0xCC0020u);
}

//----- (6F7D57DD) --------------------------------------------------------
void __stdcall Blend16(unsigned __int16 *a1, int a2, unsigned __int16 *a3, int a4, int a5, int a6, unsigned __int32 a7, int a8)
{
  unsigned __int16 *v8; // ecx@3
  unsigned __int16 *v9; // eax@3
  int v10; // edx@4
  __int16 v11; // ax@8
  int v12; // edx@8
  signed int v13; // ecx@8
  int v14; // esi@8
  int v15; // ebx@9
  int v16; // ecx@9
  unsigned __int16 *v17; // esi@10
  unsigned __int16 *v18; // edx@10
  int v19; // edi@11
  int v20; // eax@12
  unsigned __int16 v21; // ax@19
  int v22; // edi@19
  signed int v23; // ebx@19
  int v24; // ebx@19
  int v25; // edi@19
  unsigned __int16 *v26; // eax@19
  bool v27; // zf@19
  int v28; // [sp+Ch] [bp-4h]@8
  int v29; // [sp+1Ch] [bp+Ch]@1
  int v30; // [sp+24h] [bp+14h]@1
  int v31; // [sp+2Ch] [bp+1Ch]@18
  int v32; // [sp+30h] [bp+20h]@16
  int v33; // [sp+34h] [bp+24h]@8

  v29 = a2 - 2 * a5;
  v30 = a4 - 2 * a5;
  if ( a7 == -1 )
  {
    if ( a6 > 0 )
    {
      v8 = a3;
      v9 = a1;
      do
      {
        v10 = a5;
        if ( a5 > 0 )
        {
          do
          {
            *v9 = ((*v8 >> 1) & 0x3DEF) + ((*v9 >> 1) & 0x3DEF);
            ++v9;
            ++v8;
            --v10;
          }
          while ( v10 );
        }
        v9 = (unsigned __int16 *)((char *)v9 + v29);
        v8 = (unsigned __int16 *)((char *)v8 + v30);
        --a6;
      }
      while ( a6 );
    }
  }
  else
  {
    v11 = a8 * BYTE1(a7);
    v12 = a8 * (unsigned __int8)a7;
    v13 = a8 * (unsigned __int8)(a7 >> 16);
    v14 = 256 - a8;
    v28 = a8 * BYTE1(a7);
    v33 = v14;
    if ( v14 == 128 )
    {
      v15 = a6;
      v16 = ((unsigned __int16)(v12 & 0xF800) | (((unsigned __int16)(v11 & 0xF800) | (v13 >> 5) & 0x7C0) >> 5)) >> 1;
      if ( a6 > 0 )
      {
        v17 = a3;
        v18 = a1;
        do
        {
          v19 = a5;
          if ( a5 > 0 )
          {
            do
            {
              v20 = v16 + (((signed int)*v17 >> 1) & 0x3DEF);
              ++v17;
              *v18 = v20;
              ++v18;
              --v19;
            }
            while ( v19 );
          }
          v18 = (unsigned __int16 *)((char *)v18 + v29);
          v17 = (unsigned __int16 *)((char *)v17 + v30);
          --v15;
        }
        while ( v15 );
      }
    }
    else if ( a6 > 0 )
    {
      v32 = a6;
      do
      {
        if ( a5 > 0 )
        {
          v31 = a5;
          do
          {
            v21 = *a3;
            v22 = v14 * (((signed int)*a3 >> 7) & 0xF8);
            v23 = (signed int)*a3 >> 2;
            ++a3;
            v24 = v14 * (unsigned __int8)(v23 & 0xF8);
            v14 = v33;
            v25 = ((v13 + v33 * 8 * (v21 & 0x1F)) >> 11) & 0x1F | 32
                                                                * (((v28 + v24) >> 11) & 0x1F | 32
                                                                                              * (((v12 + v22) >> 11) & 0x1F));
            v26 = a1;
            ++a1;
            v27 = v31-- == 1;
            *v26 = v25;
          }
          while ( !v27 );
        }
        a1 = (unsigned __int16 *)((char *)a1 + v29);
        a3 = (unsigned __int16 *)((char *)a3 + v30);
        --v32;
      }
      while ( v32 );
    }
  }
}

//----- (6F7D5971) --------------------------------------------------------
int __thiscall CImageList::_MoreOverlaysUsed(CImageList *this)
{
  signed int v1; // edx@1
  char *v2; // eax@1

  v1 = 4;
  v2 = (char *)this + 108;
  while ( *(_DWORD *)v2 == -1 )
  {
    ++v1;
    v2 += 4;
    if ( v1 >= 15 )
      return 0;
  }
  return 1;
}

//----- (6F7D5991) --------------------------------------------------------
__int32 __stdcall Stream_WriteBitmap(struct IStream *a1, HBITMAP h, UINT start)
{
  UINT v3; // edi@2
  int v4; // ebx@4
  int v5; // ebx@14
  struct tagBITMAPINFO bmi; // [sp+4h] [bp-464h]@1
  int v8; // [sp+30h] [bp-438h]@8
  char pv; // [sp+42Ch] [bp-3Ch]@1
  LONG v10; // [sp+430h] [bp-38h]@2
  UINT cLines; // [sp+434h] [bp-34h]@2
  unsigned __int16 v12; // [sp+43Ch] [bp-2Ch]@3
  unsigned __int16 v13; // [sp+43Eh] [bp-2Ah]@3
  const void *v14; // [sp+440h] [bp-28h]@11
  __int16 v15; // [sp+444h] [bp-24h]@6
  int v16; // [sp+446h] [bp-22h]@6
  __int16 v17; // [sp+44Ah] [bp-1Eh]@6
  __int16 v18; // [sp+44Ch] [bp-1Ch]@6
  int v19; // [sp+44Eh] [bp-1Ah]@6
  LONG v20; // [sp+454h] [bp-14h]@2
  UINT v21; // [sp+458h] [bp-10h]@2
  HDC hdc; // [sp+45Ch] [bp-Ch]@2
  LPVOID lpvBits; // [sp+460h] [bp-8h]@1
  HRESULT v24; // [sp+464h] [bp-4h]@1
  int starta; // [sp+478h] [bp+10h]@15

  bmi.bmiHeader.biSize = 0;
  memset(&bmi.bmiHeader.biWidth, 0, 0x424u);
  v24 = -2147024809;
  lpvBits = 0;
  if ( GetObjectW(h, 24, &pv) != 24 )
    return v24;
  v3 = start;
  hdc = GetDC(0);
  v20 = v10;
  v21 = cLines;
  if ( !start )
    v3 = v12 * v13;
  v4 = 0;
  if ( (signed int)v3 <= 8 )
    v4 = 4 * (1 << v3);
  bmi.bmiHeader.biWidth = v10;
  bmi.bmiHeader.biPlanes = 1;
  v15 = 19778;
  v19 = v4 + 54;
  v16 = v4 + 54;
  v17 = 0;
  v18 = 0;
  bmi.bmiHeader.biSize = 40;
  bmi.bmiHeader.biHeight = cLines;
  bmi.bmiHeader.biBitCount = v3;
  bmi.bmiHeader.biCompression = 0;
  bmi.bmiHeader.biSizeImage = 0;
  bmi.bmiHeader.biXPelsPerMeter = 0;
  bmi.bmiHeader.biYPelsPerMeter = 0;
  bmi.bmiHeader.biClrUsed = 0;
  bmi.bmiHeader.biClrImportant = 0;
  v24 = -2147024882;
  if ( GetDIBits(hdc, h, 0, cLines, 0, &bmi, 0) )
  {
    if ( v3 == 1 )
    {
      bmi.bmiColors[0] = 0;
      v8 = 0xFFFFFF;
    }
    v20 = (signed int)(v3 * v20 + 31) / 32;
    bmi.bmiHeader.biSizeImage = 4 * v21 * v20;
    v24 = a1->lpVtbl->Write(a1, &v15, 14, 0);
    if ( v24 >= 0 )
    {
      v24 = a1->lpVtbl->Write(a1, &bmi, v4 + 40, 0);
      if ( v24 >= 0 )
      {
        if ( v14 )
        {
          v24 = a1->lpVtbl->Write(a1, v14, bmi.bmiHeader.biSizeImage, 0);
          if ( v24 < 0 )
            goto LABEL_22;
          goto LABEL_21;
        }
        v24 = -2147024882;
        v5 = 4096 / (4 * v20);
        lpvBits = LocalAlloc(0x40u, 0x1000u);
        if ( lpvBits )
        {
          for ( starta = 0; starta < (signed int)v21; starta += v5 )
          {
            v24 = -2147024882;
            if ( v5 > (signed int)(v21 - starta) )
              v5 = v21 - starta;
            if ( !GetDIBits(hdc, h, starta, v5, lpvBits, &bmi, 0) )
              goto LABEL_22;
            v24 = a1->lpVtbl->Write(a1, lpvBits, 4 * v5 * v20, 0);
            if ( v24 < 0 )
              goto LABEL_22;
          }
LABEL_21:
          v24 = 0;
          goto LABEL_22;
        }
      }
    }
  }
LABEL_22:
  if ( hdc )
    ReleaseDC(0, hdc);
  if ( lpvBits )
    LocalFree(lpvBits);
  return v24;
}

//----- (6F7D5BF0) --------------------------------------------------------
int __thiscall CImageList::GetSpareImageRect(CImageList *this, struct tagRECT *a2)
{
  CImageList *v2; // esi@1
  int result; // eax@1

  v2 = this;
  ++*((_DWORD *)v2 + 9);
  result = (*(int (__stdcall **)(char *, int, struct tagRECT *))(*((_DWORD *)this + 2) + 60))(
             (char *)this + 8,
             *((_DWORD *)this + 9) - 1,
             a2) == 0;
  --*((_DWORD *)v2 + 9);
  return result;
}

//----- (6F7D5C1E) --------------------------------------------------------
void __thiscall CImageList::_CopyOneImage(CImageList *this, int a2, int a3, int a4, struct CImageList *a5, int a6)
{
  CImageList *v6; // edi@1
  int v7; // ecx@1
  HDC v8; // eax@1
  HDC v9; // ecx@2
  int v10; // [sp+Ch] [bp-24h]@1
  int v11; // [sp+10h] [bp-20h]@3
  int x1; // [sp+1Ch] [bp-14h]@1
  int y1; // [sp+20h] [bp-10h]@3
  CImageList *v14; // [sp+2Ch] [bp-4h]@1

  v6 = this;
  v7 = *((_DWORD *)a5 + 2);
  v14 = v6;
  (*(void (__stdcall **)(char *, int, int *))(v7 + 60))((char *)a5 + 8, a6, &x1);
  (*(void (__stdcall **)(int, int, int *))(*((_DWORD *)v6 + 2) + 60))((char *)v6 + 8, a2, &v10);
  v8 = (HDC)*((_DWORD *)a5 + 22);
  if ( v8 )
  {
    v9 = (HDC)*((_DWORD *)v14 + 22);
    if ( v9 )
      BitBlt(v9, a3 + v10, a4 + v11, *((_DWORD *)a5 + 12), *((_DWORD *)a5 + 13), v8, x1, y1, 0xCC0020u);
  }
  BitBlt(
    *((HDC *)v14 + 21),
    a3 + v10,
    a4 + v11,
    *((_DWORD *)a5 + 12),
    *((_DWORD *)a5 + 13),
    *((HDC *)a5 + 21),
    x1,
    y1,
    0xCC0020u);
}

//----- (6F7D5CC6) --------------------------------------------------------
HDC __stdcall ImageList_GetDragDC()
{
  HDC v0; // edi@1

  v0 = GetDCEx(hWnd, 0, 0x403u);
  if ( GetLayout(v0) & 1 )
  {
    SetLayout(g_hdcDst, 1u);
    SetLayout(g_hdcDst, 1u);
  }
  return v0;
}

//----- (6F7D5D0E) --------------------------------------------------------
void __stdcall ImageList_ReleaseDragDC(HDC hdc)
{
  if ( GetLayout(hdc) & 1 )
  {
    SetLayout(g_hdcDst, 0);
    SetLayout(g_hdcSrc, 0);
  }
  ReleaseDC(hWnd, hdc);
}

//----- (6F7D5D54) --------------------------------------------------------
signed int __stdcall CImageList::DragShowNolock(CImageList *this, int a2)
{
  int v2; // esi@1
  int v3; // edi@1
  int v5; // eax@5
  struct IImageList *v6; // [sp-18h] [bp-28h]@7
  int v7; // [sp-14h] [bp-24h]@7
  HDC v8; // [sp-10h] [bp-20h]@7
  int v9; // [sp-Ch] [bp-1Ch]@7
  int v10; // [sp-8h] [bp-18h]@7
  HDC hdcSrc; // [sp+Ch] [bp-4h]@5

  v2 = dword_6F7E85EC - dword_6F7E85F4;
  v3 = dword_6F7E85F0 - dword_6F7E85F8;
  if ( !g_dctx )
    return -2147024891;
  EnterCriticalSection(&g_csDll);
  if ( a2 )
  {
    if ( !dword_6F7E8604 )
    {
      hdcSrc = ImageList_GetDragDC();
      CImageList::SelectSrcBitmap(h);
      BitBlt(g_hdcSrc, 0, 0, dword_6F7E69E0, cy, hdcSrc, v2, v3, 0xCC0020u);
      v5 = g_dctx + 8;
      if ( dword_6F7E8608 )
      {
        WimpyDrawEx((struct IImageList *)(g_dctx != 0 ? v5 : 0), 0, hdcSrc, v2, v3, 0, 0, 0xFFFFFFFF, 0xFFFFFFFF, 4u);
        if ( !dword_6F7E85DC )
        {
LABEL_12:
          ImageList_ReleaseDragDC(hdcSrc);
          goto LABEL_13;
        }
        v10 = v3 + dword_6F7E8600;
        v9 = v2 + dword_6F7E85FC;
        v8 = hdcSrc;
        v7 = dword_6F7E85E8;
        v6 = (struct IImageList *)dword_6F7E85DC;
      }
      else
      {
        v10 = v3;
        v9 = v2;
        v8 = hdcSrc;
        v7 = 0;
        v6 = (struct IImageList *)(g_dctx != 0 ? v5 : 0);
      }
      WimpyDraw(v6, v7, v8, v9, v10, 0);
      goto LABEL_12;
    }
  }
  else if ( dword_6F7E8604 )
  {
    hdcSrc = ImageList_GetDragDC();
    CImageList::SelectSrcBitmap(h);
    BitBlt(hdcSrc, v2, v3, dword_6F7E69E0, cy, g_hdcSrc, 0, 0, 0xCC0020u);
    goto LABEL_12;
  }
LABEL_13:
  dword_6F7E8604 = a2;
  LeaveCriticalSection(&g_csDll);
  return 0;
}
// 6F7E85DC: using guessed type int dword_6F7E85DC;
// 6F7E85EC: using guessed type int dword_6F7E85EC;
// 6F7E85F0: using guessed type int dword_6F7E85F0;
// 6F7E85F4: using guessed type int dword_6F7E85F4;
// 6F7E85F8: using guessed type int dword_6F7E85F8;
// 6F7E85FC: using guessed type int dword_6F7E85FC;
// 6F7E8600: using guessed type int dword_6F7E8600;
// 6F7E8604: using guessed type int dword_6F7E8604;
// 6F7E8608: using guessed type int dword_6F7E8608;

//----- (6F7D5EB1) --------------------------------------------------------
int __stdcall CImageList::GetDragImage(CImageList *this, struct tagPOINT *a2, struct tagPOINT *a3, const struct _GUID *a4, void **a5)
{
  int result; // eax@6

  if ( a2 )
  {
    a2->x = dword_6F7E85EC;
    a2->y = dword_6F7E85F0;
  }
  if ( a3 )
  {
    a3->x = dword_6F7E85F4;
    a3->y = dword_6F7E85F8;
  }
  if ( g_dctx )
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))*g_dctx)(g_dctx, a4, a5);
  else
    result = -2147024891;
  return result;
}
// 6F7E85EC: using guessed type int dword_6F7E85EC;
// 6F7E85F0: using guessed type int dword_6F7E85F0;
// 6F7E85F4: using guessed type int dword_6F7E85F4;
// 6F7E85F8: using guessed type int dword_6F7E85F8;

//----- (6F7D5F0A) --------------------------------------------------------
signed int __stdcall CImageList::GetOverlayImage(CImageList *this, int a2, int *a3)
{
  return -2147467263;
}

//----- (6F7D5F17) --------------------------------------------------------
void __stdcall ImageList_EndDrag()
{
  EnterCriticalSection(&g_csDll);
  if ( dword_6F7E85E4 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)dword_6F7E85E4 + 92))(dword_6F7E85E4);
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)dword_6F7E85E4 + 8))(dword_6F7E85E4);
    dword_6F7E85E4 = 0;
  }
  LeaveCriticalSection(&g_csDll);
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D5F55) --------------------------------------------------------
BOOL __stdcall ImageList_DragEnter(HWND hwndLock, int x, int y)
{
  BOOL result; // eax@1

  result = 0;
  if ( dword_6F7E85E4 )
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)dword_6F7E85E4 + 96))(
               dword_6F7E85E4,
               hwndLock,
               x,
               y) == 0;
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D5F83) --------------------------------------------------------
BOOL __stdcall ImageList_DragMove(int x, int y)
{
  BOOL result; // eax@1

  result = 0;
  if ( dword_6F7E85E4 )
    result = (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)dword_6F7E85E4 + 104))(dword_6F7E85E4, x, y) == 0;
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D5FAE) --------------------------------------------------------
BOOL __stdcall ImageList_DragLeave(HWND hwndLock)
{
  BOOL result; // eax@1

  result = 0;
  if ( dword_6F7E85E4 )
    result = (*(int (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)dword_6F7E85E4 + 100))(dword_6F7E85E4, hwndLock) == 0;
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D5FD6) --------------------------------------------------------
BOOL __stdcall ImageList_DragShowNolock(BOOL fShow)
{
  BOOL result; // eax@1

  result = 0;
  if ( dword_6F7E85E4 )
    result = (*(int (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)dword_6F7E85E4 + 112))(dword_6F7E85E4, fShow) == 0;
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D5FFE) --------------------------------------------------------
int __stdcall CControl::v_OnNCCalcSize(unsigned int a2, __int32 a3, __int32 *a4)
{
  return 0;
}

//----- (6F7D6008) --------------------------------------------------------
signed int __stdcall CImageList::GetIcon(CImageList *this, int a2, unsigned int a3, HICON *a4)
{
  int v4; // eax@3
  struct IImageList *v5; // esi@5
  HGDIOBJ v6; // esi@5
  signed int result; // eax@7
  ICONINFO piconinfo; // [sp+8h] [bp-2Ch]@5
  int w; // [sp+1Ch] [bp-18h]@3
  int v10; // [sp+20h] [bp-14h]@1
  HICON v11; // [sp+24h] [bp-10h]@1
  HGDIOBJ ho; // [sp+28h] [bp-Ch]@4
  HGDIOBJ v13; // [sp+2Ch] [bp-8h]@3
  int h; // [sp+30h] [bp-4h]@3

  v11 = 0;
  v10 = -2147024882;
  if ( a2 < 0 || a2 >= *((_DWORD *)this + 7) )
  {
    result = -2147024809;
  }
  else
  {
    v4 = *((_DWORD *)this + 11);
    w = *((_DWORD *)this + 10);
    h = v4;
    v13 = CreateColorBitmap(w, v4);
    if ( v13 )
    {
      ho = CreateMonoBitmap(w, h);
      if ( ho )
      {
        EnterCriticalSection(&g_csDll);
        CImageList::SelectDstBitmap((HBITMAP)ho);
        PatBlt(g_hdcDst, 0, 0, w, h, 0xFF0062u);
        v5 = (struct IImageList *)(this != (CImageList *)8 ? (unsigned int)this : 0);
        WimpyDraw(v5, a2, g_hdcDst, 0, 0, a3 | 0x10);
        CImageList::SelectDstBitmap((HBITMAP)v13);
        PatBlt(g_hdcDst, 0, 0, w, h, 0x42u);
        WimpyDraw(v5, a2, g_hdcDst, 0, 0, a3 | 1);
        CImageList::SelectDstBitmap(0);
        LeaveCriticalSection(&g_csDll);
        v6 = ho;
        piconinfo.hbmColor = (HBITMAP)v13;
        piconinfo.fIcon = 1;
        piconinfo.xHotspot = 0;
        piconinfo.yHotspot = 0;
        piconinfo.hbmMask = (HBITMAP)ho;
        v11 = CreateIconIndirect(&piconinfo);
        DeleteObject(v6);
        v10 = 0;
      }
      DeleteObject(v13);
    }
    *a4 = v11;
    result = v10;
  }
  return result;
}

//----- (6F7D614E) --------------------------------------------------------
signed int __thiscall CImageList::_Remove(CImageList *this, int a2)
{
  CImageList *v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@6
  signed int v6; // [sp+Ch] [bp-4h]@1

  v2 = this;
  v6 = 0;
  EnterCriticalSection(&g_csDll);
  if ( a2 == -1 )
  {
    *((_DWORD *)v2 + 9) = 0;
    *((_DWORD *)v2 + 10) = 0;
    memset((char *)v2 + 92, 0xFFu, 0x3Cu);
    v3 = -*((_DWORD *)v2 + 11);
LABEL_3:
    CImageList::_ReAllocBitmaps(v2, v3);
    goto LABEL_9;
  }
  if ( a2 < 0 || a2 >= *((_DWORD *)v2 + 9) )
  {
    v6 = -2147024809;
    goto LABEL_9;
  }
  CImageList::_RemoveItemBitmap(v2, a2);
  --*((_DWORD *)v2 + 9);
  v4 = *((_DWORD *)v2 + 11);
  if ( *((_DWORD *)v2 + 10) - *((_DWORD *)v2 + 9) - 1 > v4 )
  {
    v3 = *((_DWORD *)v2 + 10) - v4;
    goto LABEL_3;
  }
LABEL_9:
  LeaveCriticalSection(&g_csDll);
  return v6;
}

//----- (6F7D61D8) --------------------------------------------------------
signed int __stdcall CImageList::Remove(CImageList *this, int a2)
{
  CImageList *v2; // ecx@1

  v2 = (CImageList *)*((_DWORD *)this + 111);
  if ( v2 )
    CImageList::_Remove(v2, a2);
  return CImageList::_Remove((CImageList *)((char *)this - 8), a2);
}

//----- (6F7D6208) --------------------------------------------------------
int __userpurge CImageList::_IsSameObject@<eax>(CImageList *this@<ecx>, int a2@<esi>, struct IUnknown *a3)
{
  struct IUnknown *v3; // edi@1
  int v4; // ebx@1
  int result; // eax@2
  struct IUnknown *v6; // [sp+8h] [bp-4h]@4

  v3 = a3;
  v4 = 0;
  if ( a3 )
  {
    if ( (**(int (__stdcall ***)(CImageList *, GUID *, struct IUnknown **))this)(
           this,
           &_GUID_00000000_0000_0000_c000_000000000046,
           &a3) >= 0 )
    {
      if ( ((int (__stdcall *)(struct IUnknown *, GUID *, struct IUnknown **, int))v3->lpVtbl->QueryInterface)(
             v3,
             &_GUID_00000000_0000_0000_c000_000000000046,
             &v6,
             a2) >= 0 )
      {
        v4 = a3 == v6;
        v6->lpVtbl->Release(v6);
      }
      ((void (__cdecl *)(struct IUnknown *))a3->lpVtbl->Release)(a3);
    }
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7D6208: could not find valid save-restore pair for esi

//----- (6F7D6267) --------------------------------------------------------
signed int __stdcall CImageList::Copy(CImageList *this, int a2, struct IUnknown *a3, int a4, unsigned int cy)
{
  signed int result; // eax@2
  char *v6; // esi@3
  unsigned int v7; // ebx@5
  HDC v8; // eax@10
  HDC v9; // eax@12
  HDC v10; // eax@15
  int v11; // [sp+0h] [bp-38h]@6
  int v12; // [sp+4h] [bp-34h]@12
  int x; // [sp+10h] [bp-28h]@8
  int y; // [sp+14h] [bp-24h]@10
  int x1; // [sp+20h] [bp-18h]@5
  int y1; // [sp+24h] [bp-14h]@10
  int v17; // [sp+30h] [bp-8h]@1
  CImageList *v18; // [sp+34h] [bp-4h]@3
  int v19; // [sp+48h] [bp+10h]@9
  int cya; // [sp+50h] [bp+18h]@9

  v17 = -2147467259;
  if ( cy & 0xFFFFFFFE )
  {
    result = -2147024809;
  }
  else
  {
    v6 = (char *)this - 8;
    v18 = (CImageList *)((char *)this - 8);
    if ( CImageList::_IsSameObject((CImageList *)((char *)this - 8), (int)((char *)this - 8), a3) )
    {
      EnterCriticalSection(&g_csDll);
      v7 = (cy & 1) != 0 ? (unsigned int)v6 : 0;
      if ( (*(int (__stdcall **)(CImageList *, int, int *))(*(_DWORD *)this + 60))(this, a2, &x1) >= 0
        && (*(int (__stdcall **)(CImageList *, int, int *))(*(_DWORD *)this + 60))(this, a4, &v11) >= 0
        && (!v7 || CImageList::GetSpareImageRect((CImageList *)v7, (struct tagRECT *)&x)) )
      {
        v19 = *((_DWORD *)v6 + 12);
        cya = *((_DWORD *)v6 + 13);
        if ( v7 )
        {
          BitBlt(
            *(HDC *)(v7 + 84),
            x,
            y,
            *((_DWORD *)v6 + 12),
            *((_DWORD *)v6 + 13),
            *((HDC *)this + 19),
            x1,
            y1,
            0xCC0020u);
          v8 = *(HDC *)(v7 + 88);
          if ( v8 )
            BitBlt(v8, x, y, v19, cya, *((HDC *)this + 20), x1, y1, 0xCC0020u);
        }
        BitBlt(*((HDC *)this + 19), x1, y1, v19, cya, *((HDC *)v18 + 21), v11, v12, 0xCC0020u);
        v9 = (HDC)*((_DWORD *)v18 + 22);
        if ( v9 )
          BitBlt(*((HDC *)this + 20), x1, y1, v19, cya, v9, v11, v12, 0xCC0020u);
        if ( v7 )
        {
          BitBlt(*((HDC *)v18 + 21), v11, v12, v19, cya, *(HDC *)(v7 + 84), x, y, 0xCC0020u);
          v10 = (HDC)*((_DWORD *)v18 + 22);
          if ( v10 )
            BitBlt(v10, v11, v12, v19, cya, *(HDC *)(v7 + 88), x, y, 0xCC0020u);
        }
        v17 = 0;
      }
      LeaveCriticalSection(&g_csDll);
      result = v17;
    }
    else
    {
      result = -2147024809;
    }
  }
  return result;
}

//----- (6F7D640C) --------------------------------------------------------
void __stdcall ImageList_Blend16(HDC hdcSrc, int x1, int y1, struct CImageList *a4, int a5, int a6, int a7, int cy, unsigned __int32 a9, unsigned int a10)
{
  struct CImageList *v10; // ebx@1
  char pv; // [sp+Ch] [bp-28h]@1
  int v12; // [sp+10h] [bp-24h]@5
  int v13; // [sp+14h] [bp-20h]@6
  int v14; // [sp+18h] [bp-1Ch]@9
  int v15; // [sp+20h] [bp-14h]@9
  int x; // [sp+24h] [bp-10h]@3
  int y; // [sp+28h] [bp-Ch]@4
  int v18; // [sp+60h] [bp+2Ch]@3

  v10 = a4;
  GetObjectW(*((HANDLE *)a4 + 19), 24, &pv);
  if ( a9 == -16777216 )
    a9 = GetSysColor(13);
  v18 = (a10 & 0xE) != 4 ? 64 : 128;
  CImageList::GetSpareImageRect(a4, (struct tagRECT *)&x);
  if ( a9 == -1 )
    BitBlt(*((HDC *)a4 + 21), x, y, a7, cy, hdcSrc, x1, y1, 0xCC0020u);
  if ( a7 + x <= v12 && cy + y <= v13 && a7 + a5 <= v12 && cy + a6 <= v13 )
  {
    Blend16(
      (unsigned __int16 *)(v15 + v14 * (v13 - y - 1) + 2 * x),
      -v14,
      (unsigned __int16 *)(v15 + v14 * (v13 - a6 - 1) + 2 * a5),
      -v14,
      a7,
      cy,
      a9,
      v18);
    v10 = a4;
  }
  BitBlt(hdcSrc, x1, y1, a7, cy, *((HDC *)v10 + 21), x, y, 0xCC0020u);
}

//----- (6F7D6524) --------------------------------------------------------
void __stdcall ImageList_Blend(HDC hdc, int x, int y, struct CImageList *a4, int x1, int y1, int w, int h, COLORREF color, int a10)
{
  int v10; // edi@1
  char pv; // [sp+Ch] [bp-18h]@1
  unsigned __int16 v12; // [sp+1Eh] [bp-6h]@2
  int v13; // [sp+20h] [bp-4h]@1

  v10 = GetDeviceCaps(hdc, 12);
  GetObjectW(*((HANDLE *)a4 + 19), 24, &pv);
  if ( !v13 )
    goto LABEL_12;
  if ( v12 <= 8u && (v10 > 8 || v12 == 8) )
  {
    ImageList_BlendCT(hdc, x, y, a4, x1, y1, w, h, color, a10);
    return;
  }
  if ( v12 == 16 && v10 > 8 )
    ImageList_Blend16(hdc, x, y, a4, x1, y1, w, h, color, a10);
  else
LABEL_12:
    ImageList_BlendDither(hdc, x, y, a4, x1, y1, w, h, color, a10);
}

//----- (6F7D65E0) --------------------------------------------------------
__int32 __userpurge CImageList::CopyDitherImage@<eax>(int a1@<edi>, CImageList *this, unsigned __int16 a3, int a4, int a5, struct IUnknown *a6, int a7, unsigned int a8)
{
  __int32 result; // eax@1
  CImageList *v9; // esi@2
  unsigned int v10; // edi@2
  HDC v11; // [sp-24h] [bp-3Ch]@4
  int v12; // [sp-20h] [bp-38h]@4
  int v13; // [sp-1Ch] [bp-34h]@4
  int v14; // [sp-8h] [bp-20h]@4
  int v15; // [sp+4h] [bp-14h]@2
  int v16; // [sp+8h] [bp-10h]@2
  __int32 v17; // [sp+14h] [bp-4h]@1
  CImageList *thisa; // [sp+20h] [bp+8h]@2
  int v19; // [sp+28h] [bp+10h]@2

  result = a6->lpVtbl->QueryInterface(a6, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&a6);
  v17 = result;
  if ( result >= 0 )
  {
    v9 = this;
    (*(void (__stdcall **)(char *, _DWORD, int *, int))(*((_DWORD *)this - 1) + 60))((char *)this - 4, a3, &v15, a1);
    v10 = a8 & 0xF00;
    v19 = v15 + a4;
    thisa = (CImageList *)(v16 + a5);
    WimpyDrawEx((struct IImageList *)a6, a7, *((HDC *)v9 + 18), v19, v16 + a5, 0, 0, 0xFF000000, 0xFFFFFFFF, v10 | 0x20);
    if ( *((_DWORD *)v9 + 19) && GetScreenDepth() > 8 )
    {
      v14 = v10 | 0x10;
      v13 = (int)thisa;
      v12 = v19;
      v11 = (HDC)*((_DWORD *)v9 + 19);
    }
    else
    {
      if ( !*((_DWORD *)v9 + 19) )
      {
LABEL_8:
        CImageList::_ResetBkColor((CImageList *)((char *)v9 - 12), a3, a3 + 1, *((_DWORD *)v9 + 14));
        ((void (__cdecl *)(struct IUnknown *))a6->lpVtbl->Release)(a6);
        return v17;
      }
      v14 = v10 | 0x14;
      v13 = (int)thisa;
      v12 = v19;
      v11 = (HDC)*((_DWORD *)v9 + 19);
    }
    WimpyDrawEx((struct IImageList *)a6, a7, v11, v12, v13, 0, 0, 0xFFFFFFFF, 0xFFFFFFFF, v14);
    goto LABEL_8;
  }
  return result;
}
// 6F7D65E0: could not find valid save-restore pair for edi

//----- (6F7D66CF) --------------------------------------------------------
void __thiscall CImageList::_Merge(CImageList *this, HDC hdcSrc, int a3, int x, int y)
{
  CImageList *v5; // esi@1
  struct IImageList *v6; // edi@1
  int x1; // [sp+Ch] [bp-1Ch]@5
  int y1; // [sp+10h] [bp-18h]@5
  int v9; // [sp+1Ch] [bp-Ch]@5
  int cy; // [sp+20h] [bp-8h]@5
  int v11; // [sp+24h] [bp-4h]@2

  v5 = this;
  v6 = (struct IImageList *)hdcSrc;
  if ( *((_DWORD *)this + 22)
    && (**(int (__stdcall ***)(HDC, GUID *, int *))hdcSrc)(hdcSrc, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, &v11) >= 0 )
  {
    if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, _DWORD, HDC *))(*(_DWORD *)v11 + 24))(v11, 0, 0, 0, &hdcSrc) >= 0
      && hdcSrc )
    {
      v6->lpVtbl->GetIconSize(v6, &v9, &cy);
      v6->lpVtbl->GetImageRect(v6, a3, (RECT *)&x1);
      BitBlt(*((HDC *)v5 + 22), x, y, v9, cy, hdcSrc, x1, y1, 0x8800C6u);
    }
    (*(void (__stdcall **)(int))(*(_DWORD *)v11 + 8))(v11);
  }
  WimpyDraw(v6, a3, *((HDC *)v5 + 21), x, y, 1u);
}

//----- (6F7D6778) --------------------------------------------------------
__int32 __stdcall CImageList::Save(CImageList *this, struct IStream *a2, int a3)
{
  __int32 result; // eax@2
  signed int v4; // ecx@7
  char *v5; // eax@7
  int v6; // ecx@15
  int v7; // esi@16
  __int16 v8; // [sp+Ch] [bp-38h]@3
  __int16 v9; // [sp+Eh] [bp-36h]@3
  __int16 v10; // [sp+10h] [bp-34h]@3
  __int16 v11; // [sp+12h] [bp-32h]@3
  __int16 v12; // [sp+14h] [bp-30h]@3
  __int16 v13; // [sp+16h] [bp-2Eh]@3
  __int16 v14; // [sp+18h] [bp-2Ch]@3
  int v15; // [sp+1Ah] [bp-2Ah]@3
  int v16; // [sp+1Eh] [bp-26h]@3
  char v17; // [sp+28h] [bp-1Ch]@14

  if ( a2 )
  {
    v8 = 19529;
    v9 = 257;
    v10 = *((_WORD *)this + 10);
    v11 = *((_WORD *)this + 12);
    v12 = *((_WORD *)this + 14);
    v13 = *((_WORD *)this + 16);
    v14 = *((_WORD *)this + 18);
    v15 = *((_DWORD *)this + 13);
    LOWORD(v16) = *((_WORD *)this + 22);
    if ( *((_DWORD *)this + 109) )
      LOWORD(v16) = v16 | 0x2000;
    if ( CImageList::_MoreOverlaysUsed((CImageList *)((char *)this - 16)) )
      LOWORD(v16) = v16 | 0x1000;
    v4 = 0;
    v5 = (char *)this + 76;
    do
    {
      *((_WORD *)&v16 + v4++ + 1) = *(_WORD *)v5;
      v5 += 4;
    }
    while ( v4 < 15 );
    a2->lpVtbl->Write(a2, &v8, 28, 0);
    result = Stream_WriteBitmap(a2, *((HBITMAP *)this + 15), 0);
    if ( result >= 0 )
    {
      if ( *((_DWORD *)this + 18) )
        result = Stream_WriteBitmap(a2, *((HBITMAP *)this + 16), 1u);
      if ( result >= 0 )
      {
        if ( v16 & 0x1000 )
          result = a2->lpVtbl->Write(a2, &v17, 22, 0);
        v6 = *((_DWORD *)this + 109);
        if ( v6 )
        {
          result = Stream_WriteBitmap(a2, *(HBITMAP *)(v6 + 76), 0);
          v7 = *((_DWORD *)this + 109);
          if ( *(_DWORD *)(v7 + 88) )
            result = Stream_WriteBitmap(a2, *(HBITMAP *)(v7 + 80), 1u);
        }
      }
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6F7D68AC) --------------------------------------------------------
__int32 __stdcall CImageList::DragMove(CImageList *this, int a2, int a3)
{
  int v3; // edi@2
  int v4; // ebx@2
  HDC v5; // eax@4
  HDC v6; // esi@4
  LONG v7; // ecx@6
  int v8; // ebx@11
  int v10; // [sp-24h] [bp-6Ch]@13
  int v11; // [sp-20h] [bp-68h]@13
  HDC v12; // [sp-1Ch] [bp-64h]@13
  int v13; // [sp-18h] [bp-60h]@13
  int v14; // [sp-14h] [bp-5Ch]@13
  struct tagRECT Rect; // [sp+0h] [bp-48h]@6
  RECT rcSrc1; // [sp+10h] [bp-38h]@2
  struct tagRECT rc; // [sp+20h] [bp-28h]@2
  struct tagRECT rcDst; // [sp+30h] [bp-18h]@2
  HDC hdc; // [sp+40h] [bp-8h]@4
  int v20; // [sp+44h] [bp-4h]@11

  EnterCriticalSection(&g_csDll);
  if ( dword_6F7E8604 )
  {
    rcSrc1.left = dword_6F7E85EC - dword_6F7E85F4;
    rcSrc1.bottom = dword_6F7E85F0 - dword_6F7E85F8 + cy;
    rcSrc1.right = dword_6F7E85EC - dword_6F7E85F4 + dword_6F7E69E0;
    rcSrc1.top = dword_6F7E85F0 - dword_6F7E85F8;
    rc.left = dword_6F7E85EC - dword_6F7E85F4;
    rc.top = dword_6F7E85F0 - dword_6F7E85F8;
    rc.right = dword_6F7E85EC - dword_6F7E85F4 + dword_6F7E69E0;
    rc.bottom = dword_6F7E85F0 - dword_6F7E85F8 + cy;
    v3 = a3;
    v4 = a2;
    OffsetRect(&rc, a2 - dword_6F7E85EC, a3 - dword_6F7E85F0);
    if ( !IntersectRect(&rcDst, &rcSrc1, &rc) )
    {
      ImageList_DragShowNolock(0);
      dword_6F7E85EC = a2;
      dword_6F7E85F0 = a3;
      ImageList_DragShowNolock(1);
      goto LABEL_18;
    }
    UnionRect(&rcDst, &rcSrc1, &rc);
    v5 = ImageList_GetDragDC();
    v6 = v5;
    hdc = v5;
    if ( !v5 )
    {
LABEL_17:
      dword_6F7E85EC = v4;
      dword_6F7E85F0 = v3;
      goto LABEL_18;
    }
    if ( GetLayout(v5) & 1 )
    {
      GetWindowRect(hWnd, &Rect);
      v7 = rcDst.right;
      if ( rcDst.right > Rect.right - Rect.left )
      {
        v7 = Rect.right - Rect.left;
        rcDst.right = Rect.right - Rect.left;
      }
      if ( rcDst.left < 0 )
        rcDst.left = 0;
    }
    else
    {
      v7 = rcDst.right;
    }
    v8 = rcDst.bottom - rcDst.top;
    v20 = v7 - rcDst.left;
    CImageList::SelectDstBitmap(dword_6F7E69D8);
    BitBlt(g_hdcDst, 0, 0, v20, v8, v6, rcDst.left, rcDst.top, 0xCC0020u);
    CImageList::SelectSrcBitmap(h);
    BitBlt(g_hdcDst, rcSrc1.left - rcDst.left, rcSrc1.top - rcDst.top, dword_6F7E69E0, cy, g_hdcSrc, 0, 0, 0xCC0020u);
    BitBlt(g_hdcSrc, 0, 0, dword_6F7E69E0, cy, g_hdcDst, rc.left - rcDst.left, rc.top - rcDst.top, 0xCC0020u);
    if ( dword_6F7E8608 )
    {
      WimpyDrawEx(
        (struct IImageList *)(g_dctx != 0 ? g_dctx + 8 : 0),
        0,
        g_hdcDst,
        rc.left - rcDst.left,
        rc.top - rcDst.top,
        0,
        0,
        0xFFFFFFFF,
        0xFFFFFFFF,
        4u);
      if ( !dword_6F7E85DC )
      {
LABEL_16:
        BitBlt(hdc, rcDst.left, rcDst.top, v20, v8, g_hdcDst, 0, 0, 0xCC0020u);
        ImageList_ReleaseDragDC(hdc);
        v4 = a2;
        v3 = a3;
        goto LABEL_17;
      }
      v14 = rc.top + dword_6F7E8600 - rcDst.top;
      v13 = rc.left + dword_6F7E85FC - rcDst.left;
      v12 = g_hdcDst;
      v11 = dword_6F7E85E8;
      v10 = dword_6F7E85DC;
    }
    else
    {
      v14 = rc.top - rcDst.top;
      v13 = rc.left - rcDst.left;
      v12 = g_hdcDst;
      v11 = 0;
      v10 = g_dctx != 0 ? g_dctx + 8 : 0;
    }
    WimpyDraw((struct IImageList *)v10, v11, v12, v13, v14, 0);
    goto LABEL_16;
  }
LABEL_18:
  LeaveCriticalSection(&g_csDll);
  return 0;
}
// 6F7E85DC: using guessed type int dword_6F7E85DC;
// 6F7E85EC: using guessed type int dword_6F7E85EC;
// 6F7E85F0: using guessed type int dword_6F7E85F0;
// 6F7E85F4: using guessed type int dword_6F7E85F4;
// 6F7E85F8: using guessed type int dword_6F7E85F8;
// 6F7E85FC: using guessed type int dword_6F7E85FC;
// 6F7E8600: using guessed type int dword_6F7E8600;
// 6F7E8604: using guessed type int dword_6F7E8604;
// 6F7E8608: using guessed type int dword_6F7E8608;

//----- (6F7D6B41) --------------------------------------------------------
signed int __stdcall CImageList::DragEnter(CImageList *this, HWND a2, int a3, int a4)
{
  HWND v4; // esi@1
  signed int v5; // ebx@1

  v4 = a2;
  v5 = 1;
  if ( !a2 )
    v4 = GetDesktopWindow();
  EnterCriticalSection(&g_csDll);
  if ( !hWnd )
  {
    dword_6F7E85EC = a3;
    hWnd = v4;
    dword_6F7E85F0 = a4;
    ImageList_DragShowNolock(1);
    v5 = 0;
  }
  LeaveCriticalSection(&g_csDll);
  return v5;
}
// 6F7E85EC: using guessed type int dword_6F7E85EC;
// 6F7E85F0: using guessed type int dword_6F7E85F0;

//----- (6F7D6BA4) --------------------------------------------------------
signed int __stdcall CImageList::DragLeave(CImageList *this, HWND a2)
{
  HWND v2; // edi@1
  signed int v3; // ebx@1

  v2 = a2;
  v3 = 1;
  if ( !a2 )
    v2 = GetDesktopWindow();
  EnterCriticalSection(&g_csDll);
  if ( hWnd == v2 )
  {
    v3 = 0;
    ImageList_DragShowNolock(0);
    hWnd = 0;
  }
  LeaveCriticalSection(&g_csDll);
  return v3;
}

//----- (6F7D6BF5) --------------------------------------------------------
__int32 __stdcall CImageList::EndDrag(CImageList *this)
{
  EnterCriticalSection(&g_csDll);
  ImageList_DragShowNolock(0);
  if ( g_dctx && (CImageList *)g_dctx != dword_6F7E85E0 )
    (*(void (__stdcall **)(_DWORD))(*g_dctx + 8))(g_dctx);
  g_dctx = 0;
  if ( dword_6F7E85E0 )
  {
    (*(void (__stdcall **)(CImageList *))(*(_DWORD *)dword_6F7E85E0 + 8))(dword_6F7E85E0);
    dword_6F7E85E0 = 0;
  }
  if ( dword_6F7E85DC )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)dword_6F7E85DC + 8))(dword_6F7E85DC);
    dword_6F7E85DC = 0;
  }
  dword_6F7E85E8 = -1;
  hWnd = 0;
  LeaveCriticalSection(&g_csDll);
  return 0;
}
// 6F7E85DC: using guessed type int dword_6F7E85DC;

//----- (6F7D6C74) --------------------------------------------------------
BOOL __stdcall ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot)
{
  BOOL v4; // esi@1

  v4 = 0;
  if ( HIMAGELIST_QueryInterface(himlDrag, &_GUID_00000000_0000_0000_c000_000000000046, (void **)&himlDrag) >= 0 )
  {
    if ( dword_6F7E85E4 )
      v4 = (*(int (__stdcall **)(int, HIMAGELIST, int, int, int))(*(_DWORD *)dword_6F7E85E4 + 108))(
             dword_6F7E85E4,
             himlDrag,
             iDrag,
             dxHotspot,
             dyHotspot) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himlDrag + 8))(himlDrag);
  }
  return v4;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D6CC8) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_GetDragImage(POINT *ppt, POINT *pptHotspot)
{
  HIMAGELIST result; // eax@2

  if ( dword_6F7E85E4 )
  {
    (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)dword_6F7E85E4 + 116))(
      dword_6F7E85E4,
      ppt,
      pptHotspot,
      &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950,
      &pptHotspot);
    result = (HIMAGELIST)pptHotspot;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D6CFB) --------------------------------------------------------
BOOL __stdcall ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot)
{
  BOOL result; // eax@3

  if ( HIMAGELIST_QueryInterface(himlTrack, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himlTrack) < 0
    || (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)himlTrack + 88))(
         himlTrack,
         iTrack,
         dxHotspot,
         dyHotspot) < 0 )
  {
    result = 0;
  }
  else
  {
    dword_6F7E85E4 = (int)himlTrack;
    result = 1;
  }
  return result;
}
// 6F7E85E4: using guessed type int dword_6F7E85E4;

//----- (6F7D6D43) --------------------------------------------------------
int __thiscall ImageList_CopyDitherImage(void *this, struct _IMAGELIST *a2, int a3, int a4, int a5, struct _IMAGELIST *a6, int a7, int a8)
{
  int result; // eax@1
  void *v9; // [sp+0h] [bp-4h]@1

  v9 = this;
  result = HIMAGELIST_QueryInterface(a2, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, &v9);
  if ( result >= 0 )
  {
    if ( HIMAGELIST_QueryInterface(a6, &_GUID_00000000_0000_0000_c000_000000000046, (void **)&a2) >= 0 )
    {
      (*(void (__stdcall **)(void *, int, int, int, struct _IMAGELIST *, int, int))(*(_DWORD *)v9 + 32))(
        v9,
        a3,
        a4,
        a5,
        a2,
        a7,
        a8);
      (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a2 + 8))(a2);
    }
    result = (*(int (__stdcall **)(void *))(*(_DWORD *)v9 + 8))(v9);
  }
  return result;
}

//----- (6F7D6DA9) --------------------------------------------------------
BOOL __stdcall ImageList_Write(HIMAGELIST himl, struct IStream *pstm)
{
  BOOL v2; // esi@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_00000109_0000_0000_c000_000000000046, (void **)&himl) >= 0 )
  {
    if ( (*(int (__stdcall **)(HIMAGELIST, struct IStream *, signed int))(*(_DWORD *)himl + 24))(himl, pstm, 1) >= 0 )
      v2 = 1;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F7D6E01) --------------------------------------------------------
int __stdcall ImageList_GetImageRect(struct _IMAGELIST *a1, int a2, int a3)
{
  signed int v3; // esi@1

  v3 = 0;
  if ( HIMAGELIST_QueryInterface(a1, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&a1) >= 0 )
  {
    if ( (*(int (__stdcall **)(struct _IMAGELIST *, int, int))(*(_DWORD *)a1 + 60))(a1, a2, a3) >= 0 )
      v3 = 1;
    (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a1 + 8))(a1);
  }
  return v3;
}

//----- (6F7D6E47) --------------------------------------------------------
BOOL __stdcall ImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount)
{
  BOOL v2; // esi@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v2 = (*(int (__stdcall **)(HIMAGELIST, UINT))(*(_DWORD *)himl + 76))(himl, uNewCount) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F7D6E8C) --------------------------------------------------------
int __stdcall ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = -1;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, HBITMAP, HBITMAP, int *))(*(_DWORD *)himl + 12))(himl, hbmImage, hbmMask, &v4);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v4;
}

//----- (6F7D6ED3) --------------------------------------------------------
int __stdcall ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = -1;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, int, HICON, int *))(*(_DWORD *)himl + 16))(himl, i, hicon, &v4);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v4;
}

//----- (6F7D6F1A) --------------------------------------------------------
BOOL __stdcall ImageList_Remove(HIMAGELIST himl, int i)
{
  BOOL v2; // esi@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v2 = (*(int (__stdcall **)(HIMAGELIST, int))(*(_DWORD *)himl + 36))(himl, i) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v2;
}

//----- (6F7D6F5F) --------------------------------------------------------
HICON __stdcall ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags)
{
  HICON v4; // [sp+0h] [bp-4h]@1

  v4 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    (*(void (__stdcall **)(HIMAGELIST, int, UINT, int *))(*(_DWORD *)himl + 40))(himl, i, flags, &v4);
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v4;
}

//----- (6F7D6FA6) --------------------------------------------------------
BOOL __stdcall ImageList_Copy(HIMAGELIST himlDst, int iDst, HIMAGELIST himlSrc, int iSrc, UINT uFlags)
{
  BOOL v5; // esi@1

  v5 = 0;
  if ( himlDst == himlSrc
    && HIMAGELIST_QueryInterface(himlDst, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himlDst) >= 0 )
  {
    v5 = (*(int (__stdcall **)(HIMAGELIST, int, HIMAGELIST, int, UINT))(*(_DWORD *)himlDst + 48))(
           himlDst,
           iDst,
           himlDst,
           iSrc,
           uFlags) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himlDst + 8))(himlDst);
  }
  return v5;
}

//----- (6F7D6FF8) --------------------------------------------------------
BOOL __stdcall ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy)
{
  BOOL v3; // esi@1

  v3 = 0;
  if ( HIMAGELIST_QueryInterface(himl, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl) >= 0 )
  {
    v3 = (*(int (__stdcall **)(HIMAGELIST, int, int))(*(_DWORD *)himl + 68))(himl, cx, cy) == 0;
    (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl + 8))(himl);
  }
  return v3;
}

//----- (6F7D7040) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy)
{
  struct _IMAGELIST *v7; // [sp+4h] [bp-8h]@1
  void *v8; // [sp+8h] [bp-4h]@1

  v7 = 0;
  if ( HIMAGELIST_QueryInterface(himl1, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, &v8) >= 0 )
  {
    if ( HIMAGELIST_QueryInterface(himl2, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&himl1) >= 0 )
    {
      (*(void (__stdcall **)(void *, int, HIMAGELIST, int, int, int, GUID *, int *))(*(_DWORD *)v8 + 52))(
        v8,
        i1,
        himl1,
        i2,
        dx,
        dy,
        &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950,
        &v7);
      (*(void (__stdcall **)(HIMAGELIST))(*(_DWORD *)himl1 + 8))(himl1);
    }
    (*(void (__stdcall **)(void *))(*(_DWORD *)v8 + 8))(v8);
  }
  return v7;
}

//----- (6F7D70AF) --------------------------------------------------------
int __stdcall ImageList_SetFlags(struct _IMAGELIST *a1, int a2)
{
  int v2; // esi@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(a1, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, (void **)&a1) >= 0 )
  {
    v2 = (*(int (__stdcall **)(struct _IMAGELIST *, int))(*(_DWORD *)a1 + 12))(a1, a2) == 0;
    (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a1 + 8))(a1);
  }
  return v2;
}

//----- (6F7D70F4) --------------------------------------------------------
int __stdcall ImageList_SetColorTable(struct _IMAGELIST *a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-4h]@1

  v5 = -1;
  if ( HIMAGELIST_QueryInterface(a1, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, (void **)&a1) >= 0 )
  {
    (*(void (__stdcall **)(struct _IMAGELIST *, int, int, int, int *))(*(_DWORD *)a1 + 20))(a1, a2, a3, a4, &v5);
    (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a1 + 8))(a1);
  }
  return v5;
}

//----- (6F7D713E) --------------------------------------------------------
int __stdcall ImageList_GetFlags(struct _IMAGELIST *a1)
{
  int v2; // [sp+0h] [bp-4h]@1

  v2 = 0;
  if ( HIMAGELIST_QueryInterface(a1, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, (void **)&a1) >= 0 )
  {
    (*(void (__stdcall **)(struct _IMAGELIST *, int *))(*(_DWORD *)a1 + 16))(a1, &v2);
    (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a1 + 8))(a1);
  }
  return v2;
}

//----- (6F7D717F) --------------------------------------------------------
__int32 __stdcall CImageList::GetClassID(CImageList *this, struct _GUID *a2)
{
  a2->Data1 = CLSID_ImageList.Data1;
  *(_DWORD *)&a2->Data2 = *(_DWORD *)&CLSID_ImageList.Data2;
  *(_DWORD *)&a2->Data4[0] = *(_DWORD *)&CLSID_ImageList.Data4[0];
  *(_DWORD *)&a2->Data4[4] = *(_DWORD *)&CLSID_ImageList.Data4[4];
  return 0;
}

//----- (6F7D71B1) --------------------------------------------------------
signed int __stdcall CImageList::IsDirty(CImageList *this)
{
  return -2147467263;
}

//----- (6F7D71BE) --------------------------------------------------------
signed int __stdcall CImageList::GetSizeMax(CImageList *this, union _ULARGE_INTEGER *a2)
{
  return -2147467263;
}

//----- (6F7D71CB) --------------------------------------------------------
unsigned __int32 __stdcall CImageList::AddRef(int a1)
{
  return CImageList::AddRef((CImageList *)(a1 - 8));
}

//----- (6F7D71DA) --------------------------------------------------------
unsigned __int32 __stdcall CImageList::AddRef(int a1)
{
  return CImageList::AddRef((CImageList *)(a1 - 12));
}

//----- (6F7D71E9) --------------------------------------------------------
unsigned __int32 __stdcall CImageList::AddRef(int a1)
{
  return CImageList::AddRef((CImageList *)(a1 - 16));
}

//----- (6F7D71F8) --------------------------------------------------------
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3)
{
  return CImageList::QueryInterface((CImageList *)(a1 - 12), a2, a3);
}

//----- (6F7D7207) --------------------------------------------------------
signed int __stdcall CImageList::QueryInterface(int a1, const struct _GUID *a2, void **a3)
{
  return CImageList::QueryInterface((CImageList *)(a1 - 16), a2, a3);
}

//----- (6F7D7216) --------------------------------------------------------
HDC __stdcall ImageList_GetWorkDC(HDC hdc, int a2, int cy)
{
  HBITMAP v3; // eax@7
  HPALETTE v4; // eax@10
  HPALETTE v5; // eax@10

  if ( !g_hbmWork
    || GetDeviceCaps(hdc, 12) != (unsigned __int16)word_6F7E8AD2
    || dword_6F7E8AC4 < a2
    || dword_6F7E8AC8 < cy )
  {
    CImageList::_DeleteBitmap((HBITMAP)g_hbmWork);
    g_hbmWork = 0;
    if ( !a2 || !cy )
      return 0;
    v3 = CreateCompatibleBitmap(hdc, a2, cy);
    g_hbmWork = v3;
    if ( v3 )
      GetObjectW(v3, 24, &g_bmWork);
  }
  CImageList::SelectSrcBitmap((HBITMAP)g_hbmWork);
  if ( GetDeviceCaps(hdc, 38) & 0x100 )
  {
    v4 = (HPALETTE)GetStockObject(15);
    v5 = SelectPalette(hdc, v4, 1);
    SelectPalette(g_hdcSrc, v5, 1);
  }
  return g_hdcSrc;
}
// 6F7E8AC0: using guessed type struct tagBITMAP g_bmWork;
// 6F7E8AC4: using guessed type int dword_6F7E8AC4;
// 6F7E8AC8: using guessed type int dword_6F7E8AC8;
// 6F7E8AD2: using guessed type __int16 word_6F7E8AD2;

//----- (6F7D72DF) --------------------------------------------------------
signed int __stdcall CImageList::SetImageCount(CImageList *this, unsigned int a2)
{
  unsigned int v2; // ebx@1
  signed int v4; // [sp+18h] [bp+Ch]@1

  EnterCriticalSection(&g_csDll);
  v2 = a2;
  v4 = CImageList::_ReAllocBitmaps((CImageList *)((char *)this - 8), -1 - a2);
  if ( v4 >= 0 )
    *((_DWORD *)this + 7) = v2;
  LeaveCriticalSection(&g_csDll);
  return v4;
}

//----- (6F7D7327) --------------------------------------------------------
int __thiscall CImageList::_AddValidated(CImageList *this, HBITMAP h, HBITMAP a3, int *a4)
{
  CImageList *v4; // esi@1
  signed int v5; // ecx@2
  int result; // eax@3
  char pv; // [sp+4h] [bp-18h]@1
  int v8; // [sp+8h] [bp-14h]@2

  v4 = this;
  if ( GetObjectW(h, 24, &pv) != 24 || (v5 = *((_DWORD *)v4 + 12), v8 < v5) )
    result = -2147024809;
  else
    result = CImageList::_Add(v4, h, a3, v8 / v5, 0, 0, a4);
  return result;
}

//----- (6F7D7379) --------------------------------------------------------
int __stdcall CImageList::Add(HGDIOBJ ho, HBITMAP h, HBITMAP a3, int *a4)
{
  HGDIOBJ v4; // esi@1
  HBITMAP v5; // ebx@2
  HBITMAP hoa; // [sp+Ch] [bp+8h]@2

  v4 = ho;
  if ( *((_DWORD *)ho + 111) )
  {
    v5 = (HBITMAP)CImageList::_CreateMirroredBitmap(h);
    hoa = (HBITMAP)CImageList::_CreateMirroredBitmap(a3);
    CImageList::_AddValidated(*((CImageList **)v4 + 111), v5, hoa, a4);
    DeleteObject(v5);
    DeleteObject(hoa);
  }
  return CImageList::_AddValidated((CImageList *)((char *)v4 - 8), h, a3, a4);
}

//----- (6F7D73E4) --------------------------------------------------------
signed int __thiscall CImageList::_ReplaceValidated(CImageList *this, int a2, HBITMAP h, HBITMAP a4)
{
  CImageList *v4; // edi@1
  __int32 v5; // edi@3
  signed int result; // eax@3

  v4 = this;
  if ( a2 < 0 || a2 >= *((_DWORD *)this + 9) )
  {
    result = -2147024809;
  }
  else
  {
    EnterCriticalSection(&g_csDll);
    v5 = CImageList::_Replace(v4, a2, 1, h, a4, 0, 0);
    LeaveCriticalSection(&g_csDll);
    result = v5;
  }
  return result;
}

//----- (6F7D7438) --------------------------------------------------------
signed int __stdcall CImageList::Replace(HGDIOBJ ho, int a2, HBITMAP h, HBITMAP a4)
{
  HGDIOBJ v4; // esi@1
  HBITMAP v5; // eax@3
  void *v6; // ebx@3
  HBITMAP hoa; // [sp+Ch] [bp+8h]@2

  v4 = ho;
  if ( *((_DWORD *)ho + 111) )
  {
    hoa = (HBITMAP)CImageList::_CreateMirroredBitmap(h);
    if ( hoa )
    {
      v5 = (HBITMAP)CImageList::_CreateMirroredBitmap(a4);
      v6 = v5;
      if ( v5 )
      {
        CImageList::_ReplaceValidated(*((CImageList **)v4 + 111), a2, hoa, v5);
        DeleteObject(v6);
      }
      DeleteObject(hoa);
    }
  }
  return CImageList::_ReplaceValidated((CImageList *)((char *)v4 - 8), a2, h, a4);
}

//----- (6F7D74AD) --------------------------------------------------------
int __thiscall CImageList::_ReplaceIcon(CImageList *this, int a2, HICON h, int *a4)
{
  HICON v4; // eax@1
  bool v5; // sf@1
  unsigned __int8 v6; // of@1
  CImageList *v7; // esi@1
  int result; // eax@2
  HDC v9; // esi@8
  HICON v10; // edi@9
  RECT rc; // [sp+8h] [bp-14h]@7
  HICON v12; // [sp+18h] [bp-4h]@1

  v4 = h;
  v6 = __OFSUB__(a2, -1);
  v5 = a2 + 1 < 0;
  v7 = this;
  v12 = h;
  *a4 = -1;
  if ( v5 ^ v6 )
  {
    result = -2147024809;
  }
  else
  {
    h = (HICON)CopyImage(v4, 1u, *((_DWORD *)this + 12), *((_DWORD *)this + 13), 0x4004u);
    if ( h )
    {
      if ( a2 != -1 || (result = CImageList::_Add(v7, 0, 0, 1, 0, 0, &a2), a2 != -1) )
      {
        result = (*(int (__stdcall **)(int, int, RECT *))(*((_DWORD *)v7 + 2) + 60))((char *)v7 + 8, a2, &rc);
        if ( result >= 0 )
        {
          FillRect(*((HDC *)v7 + 21), &rc, *((HBRUSH *)v7 + 18));
          DrawIconEx(*((HDC *)v7 + 21), rc.left, rc.top, h, 0, 0, 0, 0, 3u);
          v9 = (HDC)*((_DWORD *)v7 + 22);
          if ( v9 )
          {
            v10 = h;
            DrawIconEx(v9, rc.left, rc.top, h, 0, 0, 0, 0, 1u);
          }
          else
          {
            v10 = h;
          }
          if ( v10 != v12 )
            DestroyIcon(v10);
          *a4 = a2;
          result = 0;
        }
      }
    }
    else
    {
      result = -2147024882;
    }
  }
  return result;
}

//----- (6F7D7598) --------------------------------------------------------
int __stdcall CImageList::ReplaceIcon(HICON h, int a2, HICON hIcon, int *a4)
{
  HICON v4; // esi@1

  v4 = h;
  if ( *((_DWORD *)h + 111) )
  {
    h = CopyIcon(hIcon);
    if ( h )
    {
      MirrorIcon(&h, 0);
      CImageList::_ReplaceIcon(*((CImageList **)v4 + 111), a2, h, a4);
      DestroyIcon(h);
    }
  }
  return CImageList::_ReplaceIcon((CImageList *)(v4 - 2), a2, hIcon, a4);
}

//----- (6F7D75FD) --------------------------------------------------------
int __thiscall CImageList::CreateDragBitmaps(CImageList *this)
{
  CImageList *v1; // esi@1
  HDC v2; // ebx@1
  HBITMAP v3; // eax@4
  int result; // eax@6

  v1 = this;
  v2 = GetDC(0);
  if ( *((_DWORD *)v1 + 12) == dword_6F7E69E0 && *((_DWORD *)v1 + 13) == cy && GetDeviceCaps(v2, 12) == g_drb
    || (ImageList_DeleteDragBitmaps(),
        g_drb = GetDeviceCaps(v2, 12),
        dword_6F7E69E0 = *((_DWORD *)v1 + 12),
        cy = *((_DWORD *)v1 + 13),
        h = CreateColorBitmap(dword_6F7E69E0, cy),
        v3 = CreateColorBitmap(2 * dword_6F7E69E0 - 1, 2 * cy - 1),
        dword_6F7E69D8 = v3,
        h)
    && v3 )
  {
    ReleaseDC(0, v2);
    result = 1;
  }
  else
  {
    ImageList_DeleteDragBitmaps();
    ReleaseDC(0, v2);
    result = 0;
  }
  return result;
}

//----- (6F7D76B5) --------------------------------------------------------
int __stdcall ImageList_AddIcon(HIMAGELIST himl, HICON hicon)
{
  return ImageList_ReplaceIcon(himl, -1, hicon);
}

//----- (6F7D76D0) --------------------------------------------------------
__int32 __userpurge CImageList::_Merge@<eax>(CImageList *this@<ecx>, int a2@<edi>, int a3, struct IUnknown *h, int a5, int xLeft, int yTop, struct CImageList **a8)
{
  CImageList *v8; // esi@1
  int v9; // ebx@1
  int v10; // ebx@3
  unsigned int v11; // ebx@3
  int v12; // eax@6
  int v13; // eax@8
  HDC v14; // eax@9
  RECT rcSrc2; // [sp+8h] [bp-44h]@3
  struct tagRECT rc; // [sp+18h] [bp-34h]@3
  struct tagRECT rcDst; // [sp+28h] [bp-24h]@3
  int v19; // [sp+38h] [bp-14h]@1
  int v20; // [sp+3Ch] [bp-10h]@3
  HRESULT v21; // [sp+40h] [bp-Ch]@1
  HDC hdcSrc; // [sp+44h] [bp-8h]@2
  int w; // [sp+48h] [bp-4h]@3

  v8 = this;
  v9 = 0;
  v21 = h->lpVtbl->QueryInterface(h, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, (void **)&v19);
  if ( v21 >= 0 )
  {
    v21 = h->lpVtbl->QueryInterface(h, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&hdcSrc);
    if ( v21 >= 0 )
    {
      (*(void (__stdcall **)(int, int *, int))(*(_DWORD *)v19 + 16))(v19, &v20, a2);
      (*(void (__stdcall **)(HDC, int *, struct IUnknown **))(*(_DWORD *)hdcSrc + 64))(hdcSrc, &w, &h);
      EnterCriticalSection(&g_csDll);
      SetRect(&rc, 0, 0, *((_DWORD *)v8 + 12), *((_DWORD *)v8 + 13));
      SetRect(&rcSrc2, xLeft, yTop, xLeft + w, (int)((char *)h + yTop));
      UnionRect(&rcDst, &rc, &rcSrc2);
      v10 = v20 | *((_DWORD *)v8 + 15);
      xLeft = *((_DWORD *)v8 + 15) & 0xFE;
      v11 = v10 & 0xFFFFFF01;
      w = rcDst.right - rcDst.left;
      h = (struct IUnknown *)(rcDst.bottom - rcDst.top);
      yTop = v20 & 0xFE;
      if ( xLeft == 16 && (unsigned __int8)(v20 & 0xFE) == 254 )
        yTop = 16;
      v12 = yTop;
      if ( xLeft > yTop )
        v12 = xLeft;
      v13 = CImageList::Create(rcDst.right - rcDst.left, rcDst.bottom - rcDst.top, v11 | v12 | 1, 1, 0);
      v9 = v13;
      if ( v13 )
      {
        v14 = *(HDC *)(v13 + 88);
        ++*(_DWORD *)(v9 + 36);
        if ( v14 )
          PatBlt(v14, 0, 0, w, (int)h, 0xFF0062u);
        PatBlt(*(HDC *)(v9 + 84), 0, 0, w, (int)h, 0x42u);
        CImageList::_Merge((CImageList *)v9, (HDC)v8 + 2, a3, rc.left - rcDst.left, rc.top - rcDst.top);
        CImageList::_Merge((CImageList *)v9, hdcSrc, a5, rcSrc2.left - rcDst.left, rcSrc2.top - rcDst.top);
      }
      else
      {
        v21 = -2147024882;
      }
      LeaveCriticalSection(&g_csDll);
      (*(void (__cdecl **)(HDC))(*(_DWORD *)hdcSrc + 8))(hdcSrc);
    }
    (*(void (__stdcall **)(int))(*(_DWORD *)v19 + 8))(v19);
  }
  *a8 = (struct CImageList *)v9;
  return v21;
}

//----- (6F7D7889) --------------------------------------------------------
int __userpurge CImageList::Merge@<eax>(int a1@<edi>, CImageList *this, int a3, struct IUnknown *h, int a5, int xLeft, int yTop, const struct _GUID *a8, void **a9)
{
  __int32 v9; // eax@1
  int v10; // esi@1
  int v11; // edi@1

  v9 = CImageList::_Merge((CImageList *)((char *)this - 8), a1, a3, h, a5, xLeft, yTop, (struct CImageList **)&yTop);
  v10 = yTop;
  v11 = v9;
  if ( yTop )
  {
    v11 = (**(int (__stdcall ***)(_DWORD, _DWORD, _DWORD))yTop)(yTop, a8, a9);
    (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
  }
  return v11;
}

//----- (6F7D78D7) --------------------------------------------------------
int __stdcall ImageList_MergeDragImages(int xLeft, CImageList *a2)
{
  signed int v2; // edi@1
  CImageList *v3; // esi@9
  int v5; // [sp+4h] [bp-8h]@3
  struct IUnknown *h; // [sp+8h] [bp-4h]@3

  v2 = 0;
  if ( !dword_6F7E85E0 )
    return 1;
  if ( !dword_6F7E85DC )
  {
    if ( !CImageList::CreateDragBitmaps(dword_6F7E85E0) )
      return v2;
    g_dctx = dword_6F7E85E0;
    return 1;
  }
  h = 0;
  if ( (**(int (__stdcall ***)(int, GUID *, int *))dword_6F7E85DC)(
         dword_6F7E85DC,
         &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8,
         &v5) >= 0 )
  {
    if ( (*(int (__stdcall **)(int, GUID *, struct IUnknown **))(*(_DWORD *)v5 + 28))(
           v5,
           &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950,
           &h) < 0 )
    {
      h = (struct IUnknown *)dword_6F7E85DC;
      if ( dword_6F7E85DC )
        (*(void (__stdcall **)(int))(*(_DWORD *)dword_6F7E85DC + 4))(dword_6F7E85DC);
    }
    (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  if ( h )
  {
    CImageList::_Merge(dword_6F7E85E0, 0, 0, h, dword_6F7E85E8, xLeft, (int)a2, &a2);
    v3 = a2;
    if ( a2 && CImageList::CreateDragBitmaps(a2) )
    {
      if ( g_dctx && (CImageList *)g_dctx != dword_6F7E85E0 )
        (*(void (__stdcall **)(_DWORD))(*g_dctx + 8))(g_dctx);
      g_dctx = v3;
      v2 = 1;
    }
    h->lpVtbl->Release(h);
  }
  return v2;
}
// 6F7E85DC: using guessed type int dword_6F7E85DC;

//----- (6F7D79C7) --------------------------------------------------------
int __stdcall ImageList_SetDragImage(struct _IMAGELIST *a1, int a2, int xLeft, CImageList *a4)
{
  int v4; // edi@1
  int v5; // ebx@3

  v4 = dword_6F7E8604;
  EnterCriticalSection(&g_csDll);
  if ( v4 )
    ImageList_DragShowNolock(0);
  v5 = ImageList_MergeDragImages(xLeft, a4);
  if ( v4 )
    ImageList_DragShowNolock(1);
  LeaveCriticalSection(&g_csDll);
  return v5;
}
// 6F7E8604: using guessed type int dword_6F7E8604;

//----- (6F7D7A19) --------------------------------------------------------
signed int __stdcall CImageList::SetDragCursorImage(CImageList *this, struct IUnknown *a2, int a3, int xLeft, CImageList *a5)
{
  signed int v5; // esi@1
  struct IUnknown *v6; // eax@2
  int v7; // edi@2
  int v8; // esi@6
  int v10; // [sp+4h] [bp-4h]@1

  v10 = dword_6F7E8604;
  v5 = -2147024809;
  if ( a2->lpVtbl->QueryInterface(a2, &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950, (void **)&a2) >= 0 )
  {
    EnterCriticalSection(&g_csDll);
    v6 = a2;
    v7 = a3;
    if ( (struct IUnknown *)dword_6F7E85DC != a2 || dword_6F7E85E8 != a3 )
    {
      if ( v10 )
      {
        ImageList_DragShowNolock(0);
        v6 = a2;
      }
      v8 = dword_6F7E85DC;
      dword_6F7E85DC = (int)v6;
      v6->lpVtbl->AddRef(v6);
      if ( v8 )
        (*(void (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8);
      dword_6F7E85E8 = v7;
      dword_6F7E85FC = xLeft;
      dword_6F7E8600 = (int)a5;
      v5 = ImageList_MergeDragImages(xLeft, a5) != 0 ? 0 : -2147467259;
      if ( v10 )
        ImageList_DragShowNolock(1);
    }
    LeaveCriticalSection(&g_csDll);
    a2->lpVtbl->Release(a2);
  }
  return v5;
}
// 6F7E85DC: using guessed type int dword_6F7E85DC;
// 6F7E85FC: using guessed type int dword_6F7E85FC;
// 6F7E8600: using guessed type int dword_6F7E8600;
// 6F7E8604: using guessed type int dword_6F7E8604;

//----- (6F7D7AF0) --------------------------------------------------------
signed int __stdcall CImageList::BeginDrag(CImageList *this, int a2, int xLeft, CImageList *a4)
{
  signed int v4; // esi@1
  unsigned int v5; // eax@2
  int v6; // eax@4

  v4 = -2147024891;
  EnterCriticalSection(&g_csDll);
  if ( !g_dctx )
  {
    dword_6F7E8604 = 0;
    hWnd = 0;
    dword_6F7E8608 = GetScreenDepth() > 8;
    v5 = *((_DWORD *)this + 13) | 0x100;
    if ( dword_6F7E8608 )
      v5 = v5 & 0xFFFFFF11 | 0x10;
    v6 = CImageList::Create(*((_DWORD *)this + 10), *((_DWORD *)this + 11), v5, 1, 0);
    dword_6F7E85E0 = (CImageList *)v6;
    if ( v6 )
    {
      ++*(_DWORD *)(v6 + 36);
      dword_6F7E85F4 = xLeft;
      dword_6F7E85F8 = (int)a4;
      CImageList::_CopyOneImage(dword_6F7E85E0, 0, 0, 0, (CImageList *)((char *)this - 8), a2);
      v4 = ImageList_SetDragImage(0, 0, xLeft, a4) != 0 ? 0 : -2147467259;
    }
  }
  LeaveCriticalSection(&g_csDll);
  return v4;
}
// 6F7E85F4: using guessed type int dword_6F7E85F4;
// 6F7E85F8: using guessed type int dword_6F7E85F8;
// 6F7E8604: using guessed type int dword_6F7E8604;
// 6F7E8608: using guessed type int dword_6F7E8608;

//----- (6F7D7BC3) --------------------------------------------------------
HIMAGELIST __stdcall ImageList_Clone(struct _IMAGELIST *a1, int a2, int cy, UINT flags, int cInitial, int cGrow)
{
  int v7; // [sp+0h] [bp-10h]@5
  int v8; // [sp+4h] [bp-Ch]@5
  int v9; // [sp+8h] [bp-8h]@2
  int v10; // [sp+Ch] [bp-4h]@4

  if ( HIMAGELIST_QueryInterface(a1, &_GUID_e94cc23b_0916_4ba6_93f4_aa52b5355ee8, (void **)&a1) >= 0 )
  {
    (*(void (__stdcall **)(struct _IMAGELIST *, UINT *))(*(_DWORD *)a1 + 16))(a1, &flags);
    flags &= 0x29FFu;
    if ( (*(int (__stdcall **)(struct _IMAGELIST *, GUID *, int *))(*(_DWORD *)a1 + 28))(
           a1,
           &_GUID_00000000_0000_0000_c000_000000000046,
           &v9) >= 0 )
    {
      flags |= 0x2000u;
      (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
    }
    if ( (**(int (__stdcall ***)(struct _IMAGELIST *, GUID *, int *))a1)(
           a1,
           &_GUID_46eb5926_582e_4017_9fdf_e8998daa0950,
           &v10) >= 0 )
    {
      (*(void (__stdcall **)(int, int *, int *))(*(_DWORD *)v10 + 64))(v10, &v8, &v7);
      if ( !a2 )
        a2 = v8;
      if ( !cy )
        cy = v7;
      (*(void (__stdcall **)(int))(*(_DWORD *)v10 + 8))(v10);
    }
    (*(void (__stdcall **)(struct _IMAGELIST *))(*(_DWORD *)a1 + 8))(a1);
  }
  return ImageList_Create(a2, cy, flags, cInitial, cGrow);
}

//----- (6F7D7C8B) --------------------------------------------------------
LONG __stdcall CImageList::Release(int a1)
{
  return CImageList::Release((CImageList *)(a1 - 12));
}

//----- (6F7D7C9A) --------------------------------------------------------
LONG __stdcall CImageList::Release(int a1)
{
  return CImageList::Release((CImageList *)(a1 - 16));
}

//----- (6F7D7CA9) --------------------------------------------------------
HLOCAL __thiscall CByteStream::~CByteStream(CByteStream *this)
{
  void *v1; // ecx@2
  HLOCAL result; // eax@3

  if ( *((_BYTE *)this + 22) )
  {
    v1 = (void *)*((_DWORD *)this + 1);
    if ( v1 )
      result = LocalFree(v1);
  }
  return result;
}

//----- (6F7D7CC3) --------------------------------------------------------
char __thiscall CByteStream::GrowBuffer(CByteStream *this, int a2)
{
  int v2; // eax@1
  CByteStream *v3; // esi@1
  int v4; // ecx@3
  size_t v5; // edi@3
  SIZE_T v6; // eax@3
  HLOCAL v7; // ebx@4
  const void *v8; // eax@5
  int v10; // [sp+8h] [bp-Ch]@3
  int v11; // [sp+Ch] [bp-8h]@3
  char v12; // [sp+13h] [bp-1h]@1
  int v13; // [sp+1Ch] [bp+8h]@3

  v2 = a2;
  v3 = this;
  v12 = 0;
  if ( a2 <= 0 )
    v2 = *(_DWORD *)this;
  v4 = *((_DWORD *)this + 1);
  v13 = v2;
  v11 = *((_DWORD *)v3 + 2) - v4;
  v10 = *((_DWORD *)v3 + 3) - v4;
  v5 = *((_DWORD *)v3 + 4) - v4;
  v6 = v5 + v2;
  if ( v5 >= v6 )
  {
    v7 = LocalAlloc(0x40u, v6);
    if ( v7 )
    {
      v8 = (const void *)*((_DWORD *)v3 + 1);
      if ( v8 )
      {
        memcpy(v7, v8, v5);
        LocalFree(*((HLOCAL *)v3 + 1));
      }
      *((_DWORD *)v3 + 2) = (char *)v7 + v11;
      *((_DWORD *)v3 + 1) = v7;
      *((_DWORD *)v3 + 3) = (char *)v7 + v10;
      *((_DWORD *)v3 + 4) = (char *)v7 + v5 + v13;
      v12 = 1;
    }
  }
  return v12;
}

//----- (6F7D7D59) --------------------------------------------------------
unsigned __int8 *__thiscall CByteStream::GetBuffer(CByteStream *this, bool a2)
{
  unsigned __int8 *result; // eax@1

  result = (unsigned __int8 *)*((_DWORD *)this + 1);
  if ( a2 )
  {
    *((_DWORD *)this + 4) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = 0;
    *((_DWORD *)this + 1) = 0;
    *((_BYTE *)this + 21) = 0;
    *((_BYTE *)this + 20) = 0;
    *((_BYTE *)this + 22) = 1;
  }
  else
  {
    *((_BYTE *)this + 22) = 0;
  }
  return result;
}

//----- (6F7D7D8C) --------------------------------------------------------
void __thiscall CByteStream::Reset(CByteStream *this)
{
  CByteStream *v1; // esi@1

  v1 = this;
  if ( *((_DWORD *)this + 1) )
    LocalFree(*((HLOCAL *)this + 1));
  *((_DWORD *)v1 + 4) = 0;
  *((_DWORD *)v1 + 2) = 0;
  *((_DWORD *)v1 + 3) = 0;
  *((_DWORD *)v1 + 1) = 0;
  *((_BYTE *)v1 + 21) = 0;
  *((_BYTE *)v1 + 20) = 0;
  *((_BYTE *)v1 + 22) = 1;
}

//----- (6F7D7DC0) --------------------------------------------------------
void *__thiscall CByteStream::CByteStream(void *this, signed int a2)
{
  void *result; // eax@1
  int *v3; // ecx@1
  int v4; // [sp+0h] [bp-4h]@1

  result = this;
  v4 = 1;
  v3 = &a2;
  if ( a2 <= 1 )
    v3 = &v4;
  *(_DWORD *)result = *v3;
  *((_DWORD *)result + 1) = 0;
  *((_DWORD *)result + 2) = 0;
  *((_DWORD *)result + 3) = 0;
  *((_DWORD *)result + 4) = 0;
  *((_BYTE *)result + 20) = 0;
  *((_BYTE *)result + 21) = 0;
  *((_BYTE *)result + 22) = 1;
  return result;
}

//----- (6F7D7DFD) --------------------------------------------------------
size_t __thiscall CByteStream::Write(CByteStream *this, const void *Src, size_t Size)
{
  CByteStream *v3; // esi@1
  size_t v4; // ebx@1
  size_t v5; // eax@2

  v3 = this;
  v4 = 0;
  if ( *((_BYTE *)this + 22) )
  {
    v5 = *((_DWORD *)this + 4);
    if ( Size + *((_DWORD *)this + 3) < v5
      || CByteStream::GrowBuffer(this, Size + *(_DWORD *)this + v5 - *((_DWORD *)this + 1)) )
    {
      memcpy(*((void **)v3 + 3), Src, Size);
      *((_DWORD *)v3 + 3) += Size;
      v4 = Size;
    }
    else
    {
      *((_BYTE *)v3 + 20) = 1;
    }
  }
  return v4;
}

//----- (6F7D7E58) --------------------------------------------------------
int __thiscall CByteStream::Align(int this, int a2, int a3)
{
  int result; // eax@3

  if ( *(_BYTE *)(this + 22) )
  {
    if ( a2 )
    {
      result = a2 - 1;
      if ( a2 == 1 )
      {
        result = ~(a3 - 1) & (a3 - 1 + *(_DWORD *)(this + 8));
        *(_DWORD *)(this + 8) = result;
        if ( (unsigned int)result >= *(_DWORD *)(this + 16) )
          *(_BYTE *)(this + 21) = 1;
      }
    }
    else
    {
      result = CByteStream::Write(
                 (CByteStream *)this,
                 dword_6F7D7EAC,
                 (~(a3 - 1) & (*(_DWORD *)(this + 12) + a3 - 1)) - *(_DWORD *)(this + 12));
    }
  }
  return result;
}
// 6F7D7EAC: using guessed type int dword_6F7D7EAC[2];

//----- (6F7D7EB9) --------------------------------------------------------
size_t __stdcall CDlgTemplateConverter::CopyStringW(struct CByteStream *a2, LPCWSTR lpString, int a4)
{
  int v4; // eax@1

  v4 = a4;
  if ( a4 == -1 )
    v4 = lstrlenW(lpString) + 1;
  return CByteStream::Write(a2, lpString, 2 * v4) >> 1;
}

//----- (6F7D7EE9) --------------------------------------------------------
CByteStream *__thiscall CByteStream::operator<<<unsigned long>(CByteStream *this, void *Src)
{
  CByteStream *v2; // esi@1

  v2 = this;
  CByteStream::Write(this, Src, 4u);
  return v2;
}

//----- (6F7D7F07) --------------------------------------------------------
CByteStream *__thiscall CByteStream::operator<<<short>(CByteStream *this, void *Src)
{
  CByteStream *v2; // esi@1

  v2 = this;
  CByteStream::Write(this, Src, 2u);
  return v2;
}

//----- (6F7D7F25) --------------------------------------------------------
CByteStream *__thiscall CByteStream::operator<<<unsigned char>(CByteStream *this, void *Src)
{
  CByteStream *v2; // esi@1

  v2 = this;
  CByteStream::Write(this, Src, 1u);
  return v2;
}

//----- (6F7D7F43) --------------------------------------------------------
int __thiscall CDlgTemplateConverter::CDlgTemplateConverter(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = a2;
  CByteStream::CByteStream((void *)(this + 4), 512);
  return v2;
}

//----- (6F7D7F69) --------------------------------------------------------
int __thiscall CDlgTemplateConverter::DlgHdrToDlgEx(CDlgTemplateConverter *this, struct CByteStream *a2, unsigned __int16 **a3)
{
  unsigned __int16 *v3; // esi@1
  int v4; // edi@1
  CByteStream *v5; // eax@1
  CByteStream *v6; // eax@1
  CByteStream *v7; // eax@1
  CByteStream *v8; // eax@1
  CByteStream *v9; // eax@1
  CByteStream *v10; // eax@1
  CByteStream *v11; // eax@1
  CByteStream *v12; // eax@1
  CByteStream *v13; // eax@1
  unsigned int v14; // esi@1
  int v15; // esi@3
  int v16; // esi@8
  int v17; // esi@12
  unsigned __int16 *v19; // [sp+Ch] [bp-14h]@1
  int v20; // [sp+10h] [bp-10h]@1
  int v21; // [sp+14h] [bp-Ch]@1
  int Src; // [sp+18h] [bp-8h]@1
  CDlgTemplateConverter *v23; // [sp+1Ch] [bp-4h]@1

  v23 = this;
  v3 = *a3;
  v4 = (int)a2;
  Src = 0;
  v19 = v3;
  v21 = 0xFFFF;
  v20 = 1;
  v5 = CByteStream::operator<<<short>(a2, &v20);
  v6 = CByteStream::operator<<<short>(v5, &v21);
  v7 = CByteStream::operator<<<unsigned long>(v6, &Src);
  v8 = CByteStream::operator<<<unsigned long>(v7, v3 + 2);
  v9 = CByteStream::operator<<<unsigned long>(v8, v3);
  v10 = CByteStream::operator<<<short>(v9, v3 + 4);
  v11 = CByteStream::operator<<<short>(v10, v3 + 5);
  v12 = CByteStream::operator<<<short>(v11, v3 + 6);
  v13 = CByteStream::operator<<<short>(v12, v3 + 7);
  CByteStream::operator<<<short>(v13, v3 + 8);
  v14 = (unsigned int)((char *)v3 + 19) & 0xFFFFFFFE;
  CByteStream::Align(v4, 0, 2);
  if ( *(_WORD *)v14 )
  {
    if ( *(_WORD *)v14 != 0xFFFF )
    {
      v15 = v14 + 2 * CDlgTemplateConverter::CopyStringW((struct CByteStream *)v4, (LPCWSTR)v14, -1);
      goto LABEL_6;
    }
    CByteStream::operator<<<short>((CByteStream *)v4, (void *)v14);
    v14 += 2;
  }
  CByteStream::operator<<<short>((CByteStream *)v4, (void *)v14);
  v15 = v14 + 2;
LABEL_6:
  if ( *(_WORD *)v15 )
  {
    if ( *(_WORD *)v15 != 0xFFFF )
    {
      v16 = v15 + 2 * CDlgTemplateConverter::CopyStringW((struct CByteStream *)v4, (LPCWSTR)v15, -1);
      goto LABEL_11;
    }
    CByteStream::operator<<<short>((CByteStream *)v4, (void *)v15);
    v15 += 2;
  }
  CByteStream::operator<<<short>((CByteStream *)v4, (void *)v15);
  v16 = v15 + 2;
LABEL_11:
  if ( *(_WORD *)v16 )
  {
    v17 = v16 + 2 * CDlgTemplateConverter::CopyStringW((struct CByteStream *)v4, (LPCWSTR)v16, -1);
  }
  else
  {
    CByteStream::operator<<<short>((CByteStream *)v4, (void *)v16);
    v17 = v16 + 2;
  }
  if ( *(_BYTE *)v19 & 0x40 )
  {
    CByteStream::operator<<<short>((CByteStream *)v4, (void *)v17);
    a2 = (struct CByteStream *)400;
    CByteStream::operator<<<short>((CByteStream *)v4, &a2);
    BYTE3(a2) = 0;
    CByteStream::operator<<<unsigned char>((CByteStream *)v4, (char *)&a2 + 3);
    BYTE3(a2) = *(_BYTE *)v23;
    CByteStream::operator<<<unsigned char>((CByteStream *)v4, (char *)&a2 + 3);
    v17 += 2 + 2 * CDlgTemplateConverter::CopyStringW((struct CByteStream *)v4, (LPCWSTR)(v17 + 2), -1);
  }
  *a3 = (unsigned __int16 *)v17;
  return *(_BYTE *)(v4 + 20) != 0 ? 0x8007000E : 0;
}

//----- (6F7D8104) --------------------------------------------------------
int __thiscall CDlgTemplateConverter::DlgItemToDlgEx(CDlgTemplateConverter *this, struct CByteStream *a2, unsigned __int16 **a3)
{
  unsigned __int16 *v3; // esi@1
  int v4; // eax@1
  CByteStream *v5; // eax@1
  CByteStream *v6; // eax@1
  CByteStream *v7; // eax@1
  CByteStream *v8; // eax@1
  CByteStream *v9; // eax@1
  CByteStream *v10; // eax@1
  CByteStream *v11; // eax@1
  unsigned int v12; // esi@1
  int v13; // esi@2
  void *v14; // esi@3
  int v15; // esi@5
  void *v16; // esi@6
  int v17; // esi@8
  int Src; // [sp+Ch] [bp-Ch]@1
  int v20; // [sp+10h] [bp-8h]@1
  CDlgTemplateConverter *v21; // [sp+14h] [bp-4h]@1

  v3 = *a3;
  v4 = (*a3)[8];
  Src = 0;
  v20 = v4;
  v21 = this;
  v5 = CByteStream::operator<<<unsigned long>(a2, &Src);
  v6 = CByteStream::operator<<<unsigned long>(v5, v3 + 2);
  v7 = CByteStream::operator<<<unsigned long>(v6, v3);
  v8 = CByteStream::operator<<<short>(v7, v3 + 4);
  v9 = CByteStream::operator<<<short>(v8, v3 + 5);
  v10 = CByteStream::operator<<<short>(v9, v3 + 6);
  v11 = CByteStream::operator<<<short>(v10, v3 + 7);
  CByteStream::operator<<<unsigned long>(v11, &v20);
  v12 = (unsigned int)((char *)v3 + 19) & 0xFFFFFFFE;
  CByteStream::Align((int)a2, 0, 2);
  if ( *(_WORD *)v12 == -1 )
  {
    CByteStream::operator<<<short>(a2, (void *)v12);
    v14 = (void *)(v12 + 2);
    CByteStream::operator<<<short>(a2, v14);
    v13 = (int)((char *)v14 + 2);
  }
  else
  {
    v13 = v12 + 2 * CDlgTemplateConverter::CopyStringW(a2, (LPCWSTR)v12, -1);
  }
  if ( *(_WORD *)v13 == -1 )
  {
    CByteStream::operator<<<short>(a2, (void *)v13);
    v16 = (void *)(v13 + 2);
    CByteStream::operator<<<short>(a2, v16);
    v15 = (int)((char *)v16 + 2);
  }
  else
  {
    v15 = v13 + 2 * CDlgTemplateConverter::CopyStringW(a2, (LPCWSTR)v13, -1);
  }
  if ( *(_WORD *)v15 )
  {
    v17 = v15 + 2 * (CByteStream::Write(a2, (const void *)v15, *(_WORD *)v15) >> 1);
  }
  else
  {
    CByteStream::operator<<<short>(a2, (void *)v15);
    v17 = v15 + 2;
  }
  *a3 = (unsigned __int16 *)v17;
  return *((_BYTE *)a2 + 20) != 0 ? 0x8007000E : 0;
}

//----- (6F7D8223) --------------------------------------------------------
int __thiscall CDlgTemplateConverter::DlgToDlgEx(CDlgTemplateConverter *this, struct DLGTEMPLATE *a2, struct tagDLGTEMPLATEEX **a3)
{
  struct DLGTEMPLATE *v3; // esi@1
  CDlgTemplateConverter *v4; // ebx@1
  int v5; // edi@1
  signed int v7; // [sp+Ch] [bp-8h]@1
  int v8; // [sp+10h] [bp-4h]@1

  *a3 = 0;
  v3 = a2;
  v4 = this;
  v5 = (int)((char *)this + 4);
  CByteStream::Reset((CDlgTemplateConverter *)((char *)this + 4));
  v7 = 0;
  v8 = CDlgTemplateConverter::DlgHdrToDlgEx(v4, (struct CByteStream *)v5, (unsigned __int16 **)&a2);
  if ( v3->cdit <= 0u )
  {
LABEL_4:
    if ( v8 >= 0 )
      *a3 = (struct tagDLGTEMPLATEEX *)CByteStream::GetBuffer((CByteStream *)v5, 1);
  }
  else
  {
    while ( v8 >= 0 )
    {
      a2 = (struct DLGTEMPLATE *)((unsigned int)((char *)&a2->style + 3) & 0xFFFFFFFC);
      CByteStream::Align(v5, 0, 4);
      ++v7;
      v8 = CDlgTemplateConverter::DlgItemToDlgEx(v4, (struct CByteStream *)v5, (unsigned __int16 **)&a2);
      if ( v7 >= v3->cdit )
        goto LABEL_4;
    }
  }
  return v8;
}

//----- (6F7D82BB) --------------------------------------------------------
int __stdcall CvtDlgToDlgEx(struct DLGTEMPLATE *a1, struct tagDLGTEMPLATEEX **a2, int a3)
{
  int v3; // esi@1
  char v5; // [sp+4h] [bp-1Ch]@1
  char v6; // [sp+8h] [bp-18h]@1

  CDlgTemplateConverter::CDlgTemplateConverter((int)&v5, a3);
  v3 = CDlgTemplateConverter::DlgToDlgEx((CDlgTemplateConverter *)&v5, a1, a2);
  CByteStream::~CByteStream((CByteStream *)&v6);
  return v3;
}

//----- (6F7D82F3) --------------------------------------------------------
int __stdcall GetItemObject(int a1, int a2, int a3, LPARAM lParam)
{
  *(_DWORD *)(lParam + 20) = 0;
  *(_DWORD *)(lParam + 16) = a3;
  *(_DWORD *)(lParam + 24) = -2147467262;
  CCSendNotify(a1, a2, lParam);
  return *(_DWORD *)(lParam + 24);
}

//----- (6F7D8326) --------------------------------------------------------
signed int __stdcall GetDragProxyTarget(int a1, int a2)
{
  signed int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a2 = a1;
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 4))(a1);
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = 0;
    result = -2147467259;
  }
  return result;
}

//----- (6F7D8355) --------------------------------------------------------
int __stdcall CDragProxy::Drop(CDragProxy *this, struct IDataObject *a2, unsigned __int32 a3, struct _POINTL a4, unsigned __int32 *a5)
{
  int v5; // edi@1
  int v6; // ebx@1

  (*(void (__stdcall **)(CDragProxy *))(*(_DWORD *)this + 4))(this);
  v5 = *((_DWORD *)this + 5);
  v6 = 0;
  if ( v5 )
  {
    *((_DWORD *)this + 5) = 0;
    v6 = (*(int (__stdcall **)(int, struct IDataObject *, unsigned __int32, LONG, LONG, unsigned __int32 *))(*(_DWORD *)v5 + 24))(
           v5,
           a2,
           a3,
           a4.x,
           a4.y,
           a5);
    (*(void (__stdcall **)(int))(*(_DWORD *)v5 + 8))(v5);
  }
  else
  {
    *a5 = 0;
  }
  (*(void (__stdcall **)(CDragProxy *))(*(_DWORD *)this + 20))(this);
  (*(void (__stdcall **)(CDragProxy *))(*(_DWORD *)this + 8))(this);
  return v6;
}

//----- (6F7D83B0) --------------------------------------------------------
int __thiscall CDragProxy::CallCB(CDragProxy *this, unsigned int a2, unsigned int a3, __int32 a4)
{
  int (__stdcall *v4)(_DWORD, _DWORD, _DWORD, _DWORD); // eax@1
  int result; // eax@2

  v4 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))*((_DWORD *)this + 3);
  if ( v4 )
    result = v4(*((_DWORD *)this + 2), a2, a3, a4);
  else
    result = -1;
  return result;
}

//----- (6F7D83D8) --------------------------------------------------------
int __thiscall CDragProxy::Register(struct IDropTarget *this)
{
  struct IDropTarget *v1; // esi@1
  HINSTANCE v2; // eax@1

  v1 = this;
  v2 = PrivLoadOleLibrary();
  v1[14].lpVtbl = (struct IDropTargetVtbl *)v2;
  if ( v2 )
  {
    if ( PrivCoInitialize(v2) >= 0 )
    {
      if ( PrivRegisterDragDrop((HINSTANCE)v1[14].lpVtbl, (HWND)v1[2].lpVtbl, v1) >= 0 )
        return 1;
      PrivCoUninitialize((HINSTANCE)v1[14].lpVtbl);
    }
    PrivFreeOleLibrary((HINSTANCE)v1[14].lpVtbl);
    v1[14].lpVtbl = 0;
  }
  return 0;
}

//----- (6F7D8425) --------------------------------------------------------
void __thiscall CDragProxy::RevokeAndFreeCB(CDragProxy *this)
{
  CDragProxy *v1; // esi@1
  HINSTANCE v2; // eax@1

  v1 = this;
  v2 = (HINSTANCE)*((_DWORD *)this + 14);
  if ( v2 )
  {
    PrivRevokeDragDrop(v2, *((HWND *)this + 2));
    PrivCoUninitialize(*((HINSTANCE *)v1 + 14));
    PrivFreeOleLibrary(*((HINSTANCE *)v1 + 14));
  }
  *((_DWORD *)v1 + 3) = 0;
}

//----- (6F7D8455) --------------------------------------------------------
int __stdcall DestroyDragProxy(CDragProxy *a1)
{
  int result; // eax@2

  if ( a1 )
  {
    CDragProxy::RevokeAndFreeCB(a1);
    result = (*(int (__stdcall **)(CDragProxy *))(*(_DWORD *)a1 + 8))(a1);
  }
  return result;
}

//----- (6F7D8479) --------------------------------------------------------
signed int __stdcall CDragProxy::QueryInterface(CDragProxy *this, const struct _GUID *a2, void **a3)
{
  signed int result; // eax@3

  if ( !memcmp(a2, &IID_IDropTarget, 0x10u) || !memcmp(a2, &IID_IUnknown, 0x10u) )
  {
    *a3 = (void *)this;
    ++*((_DWORD *)this + 1);
    result = 0;
  }
  else
  {
    *a3 = 0;
    result = -2147467262;
  }
  return result;
}

//----- (6F7D84C7) --------------------------------------------------------
signed int __stdcall CDragProxy::DragEnter(CDragProxy *this, struct IDataObject *a2, unsigned __int32 a3, struct _POINTL a4, unsigned __int32 *a5)
{
  signed int result; // eax@2
  int v6; // eax@5

  if ( a2 )
  {
    if ( CDragProxy::CallCB(this, 3u, 0, 0) )
    {
      a2->lpVtbl->AddRef(a2);
      v6 = *(_DWORD *)this;
      *((_DWORD *)this + 4) = a2;
      (*(void (__stdcall **)(CDragProxy *, unsigned __int32, LONG, LONG, unsigned __int32 *))(v6 + 16))(
        this,
        a3,
        a4.x,
        a4.y,
        a5);
      result = 0;
    }
    else
    {
      result = -2147467259;
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (6F7D851F) --------------------------------------------------------
void __thiscall CDragProxy::UpdateSelection(CDragProxy *this, unsigned __int32 a2)
{
  unsigned int v2; // ST04_4@2

  if ( a2 != *((_DWORD *)this + 9) )
  {
    v2 = *((_DWORD *)this + 6);
    *((_DWORD *)this + 9) = a2;
    CDragProxy::CallCB(this, 2u, v2, a2);
  }
}

//----- (6F7D8543) --------------------------------------------------------
int __thiscall CDragProxy::CDragProxy(int this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // eax@1

  v3 = this;
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a3;
  *(_DWORD *)this = &CDragProxy::`vftable';
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 56) = 0;
  v4 = CDragProxy::CallCB((CDragProxy *)this, 0, 0, 0);
  *(_DWORD *)(v3 + 24) = v4;
  *(_DWORD *)(v3 + 32) = v4;
  return v3;
}
// 6F792A04: using guessed type __int32 (__stdcall *CDragProxy::`vftable')(CDragProxy *this, const struct _GUID *, void **);

//----- (6F7D858C) --------------------------------------------------------
void __thiscall CDragProxy::SetDropTarget(CDragProxy *this, struct IDropTarget *a2)
{
  CDragProxy *v2; // esi@1
  int v3; // eax@1
  struct IDropTarget *v4; // eax@3
  int v5; // ST10_4@4

  v2 = this;
  CDragProxy::UpdateSelection(this, 0);
  v3 = *((_DWORD *)v2 + 5);
  if ( v3 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v3 + 20))(*((_DWORD *)v2 + 5));
    (*(void (__stdcall **)(_DWORD))(**((_DWORD **)v2 + 5) + 8))(*((_DWORD *)v2 + 5));
  }
  v4 = a2;
  *((_DWORD *)v2 + 5) = a2;
  if ( v4 )
  {
    v4->lpVtbl->AddRef(v4);
    v5 = *((_DWORD *)v2 + 12);
    a2 = (struct IDropTarget *)*((_DWORD *)v2 + 13);
    if ( (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, int, struct IDropTarget **))(**((_DWORD **)v2 + 5) + 12))(
           *((_DWORD *)v2 + 5),
           *((_DWORD *)v2 + 4),
           *((_DWORD *)v2 + 10),
           *((_DWORD *)v2 + 11),
           v5,
           &a2) < 0 )
      a2 = 0;
    CDragProxy::UpdateSelection(v2, (unsigned __int32)a2);
  }
}

//----- (6F7D85FC) --------------------------------------------------------
int __stdcall CreateDragProxy(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@2

  v3 = (int)operator new(0x3Cu);
  if ( v3 )
    v4 = CDragProxy::CDragProxy(v3, a1, a2);
  else
    v4 = 0;
  if ( v4 && a3 && !CDragProxy::Register((struct IDropTarget *)v4) )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
    v4 = 0;
  }
  return v4;
}

//----- (6F7D864A) --------------------------------------------------------
__int32 __stdcall CDragProxy::DragLeave(CDragProxy *this)
{
  int v1; // eax@2

  CDragProxy::SetDropTarget(this, 0);
  *((_DWORD *)this + 6) = *((_DWORD *)this + 8);
  if ( *((_DWORD *)this + 4) )
  {
    CDragProxy::CallCB(this, 4u, 0, 0);
    v1 = *((_DWORD *)this + 4);
    *((_DWORD *)this + 4) = 0;
    (*(void (__stdcall **)(int))(*(_DWORD *)v1 + 8))(v1);
  }
  return 0;
}

//----- (6F7D868D) --------------------------------------------------------
void __thiscall CDragProxy::SetTargetItem(CDragProxy *this, int a2, unsigned __int32 a3)
{
  CDragProxy *v3; // esi@1
  __int32 v4; // [sp+Ch] [bp-20h]@4
  int v5; // [sp+18h] [bp-14h]@3
  struct IDropTarget *v6; // [sp+20h] [bp-Ch]@5
  unsigned __int32 v7; // [sp+28h] [bp-4h]@3

  v3 = this;
  if ( a2 != *((_DWORD *)this + 6) || a3 != *((_DWORD *)this + 7) )
  {
    CDragProxy::UpdateSelection(this, 0);
    *((_DWORD *)v3 + 6) = a2;
    v5 = a2;
    *((_DWORD *)v3 + 7) = a3;
    v7 = a3;
    if ( !*((_DWORD *)v3 + 4) || CDragProxy::CallCB(v3, 1u, 0, (__int32)&v4) < 0 )
      v6 = 0;
    CDragProxy::SetDropTarget(v3, v6);
    if ( v6 )
      v6->lpVtbl->Release(v6);
  }
}

//----- (6F7D86FC) --------------------------------------------------------
__int32 __thiscall CDragProxy::~CDragProxy(CDragProxy *this)
{
  *(_DWORD *)this = &CDragProxy::`vftable';
  return CDragProxy::DragLeave(this);
}
// 6F792A04: using guessed type __int32 (__stdcall *CDragProxy::`vftable')(CDragProxy *this, const struct _GUID *, void **);

//----- (6F7D8710) --------------------------------------------------------
void *__thiscall CDragProxy::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CDragProxy::~CDragProxy((CDragProxy *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6F7D8736) --------------------------------------------------------
int __stdcall CDragProxy::DragOver(CDragProxy *this, unsigned __int32 a2, struct _POINTL a3, unsigned __int32 *a4)
{
  unsigned __int32 *v4; // edi@1
  int v5; // eax@1
  int v6; // eax@1
  int v7; // ebx@2
  unsigned __int32 v9; // [sp+Ch] [bp-4h]@1

  v9 = 0;
  *(_QWORD *)((char *)this + 44) = a3;
  v4 = a4;
  *((_DWORD *)this + 10) = a2;
  *((_DWORD *)this + 13) = *v4;
  v5 = CDragProxy::CallCB(this, 0, (unsigned int)&v9, (__int32)&a3);
  CDragProxy::SetTargetItem(this, v5, v9);
  v6 = *((_DWORD *)this + 5);
  if ( v6 )
  {
    v7 = (*(int (__stdcall **)(int, unsigned __int32, LONG, LONG, unsigned __int32 *))(*(_DWORD *)v6 + 16))(
           v6,
           a2,
           a3.x,
           a3.y,
           v4);
  }
  else
  {
    *v4 = 0;
    v7 = 0;
  }
  CDragProxy::UpdateSelection(this, *v4);
  return v7;
}

//----- (6F7D87B1) --------------------------------------------------------
unsigned __int32 __stdcall CDragProxy::Release(CDragProxy *this)
{
  bool v1; // zf@1
  unsigned __int32 result; // eax@1

  v1 = (*((_DWORD *)this + 1))-- == 1;
  result = *((_DWORD *)this + 1);
  if ( v1 )
  {
    CDragProxy::`scalar deleting destructor'((void *)this, 1);
    result = 0;
  }
  return result;
}

//----- (6F7D87D3) --------------------------------------------------------
int __thiscall CControl::v_OnStyleChanged(CControl *this, unsigned int a2, __int32 a3)
{
  int result; // eax@1
  int v4; // edx@4

  result = 0;
  if ( a2 == -16 )
  {
    *((_DWORD *)this + 3) = *(_DWORD *)(a3 + 4);
    result = *(_DWORD *)a3 ^ *(_DWORD *)(a3 + 4);
  }
  else if ( a2 == -20 )
  {
    v4 = *(_DWORD *)(a3 + 4);
    result = v4 ^ *(_DWORD *)a3;
    *((_DWORD *)this + 7) = v4;
  }
  return result;
}

//----- (6F7D880C) --------------------------------------------------------
void __thiscall CControl::_OnPaint(CControl *this, HDC a2)
{
  CControl *v2; // esi@1
  HDC v3; // eax@3
  struct tagPAINTSTRUCT Paint; // [sp+4h] [bp-44h]@3

  v2 = this;
  if ( a2 )
  {
    (*(void (__stdcall **)(HDC))(*(_DWORD *)this + 12))(a2);
  }
  else
  {
    v3 = BeginPaint(*((HWND *)this + 1), &Paint);
    (*(void (__thiscall **)(CControl *, HDC))(*(_DWORD *)v2 + 12))(v2, v3);
    EndPaint(*((HWND *)v2 + 1), &Paint);
  }
}

//----- (6F7D8866) --------------------------------------------------------
void __thiscall CPager::_DrawBlank(CPager *this, HDC hDC, int a3)
{
  HDC v3; // edi@1
  CPager *v4; // esi@1
  int v5; // eax@6
  struct tagRECT Rect; // [sp+Ch] [bp-14h]@3
  int v7; // [sp+1Ch] [bp-4h]@1

  v3 = hDC;
  v4 = this;
  v7 = 0;
  if ( !hDC )
  {
    v3 = GetWindowDC(*((HWND *)this + 1));
    v7 = 1;
  }
  GetWindowRect(*((HWND *)v4 + 1), &Rect);
  MapWindowPoints(0, *((HWND *)v4 + 1), (LPPOINT)&Rect, 2u);
  OffsetRect(&Rect, -Rect.left, -Rect.top);
  if ( *((_BYTE *)v4 + 12) & 1 )
    FlipRect((int)&Rect);
  if ( *((_DWORD *)v4 + a3 + 21) )
    v5 = *((_DWORD *)v4 + 27);
  else
    v5 = *((_DWORD *)v4 + 30);
  if ( a3 )
  {
    if ( a3 == 1 )
      Rect.top = Rect.bottom - v5;
  }
  else
  {
    Rect.bottom = Rect.top + v5;
  }
  if ( *((_BYTE *)v4 + 12) & 1 )
    FlipRect((int)&Rect);
  FillRectClr(v3, &Rect, *((_DWORD *)v4 + 29));
  if ( v7 )
    ReleaseDC(*((HWND *)v4 + 1), v3);
}

//----- (6F7D893C) --------------------------------------------------------
__int32 __thiscall CPager::v_OnCommand(CPager *this, WPARAM wParam, __int32 lParam)
{
  return SendMessageW(*((HWND *)this + 2), 0x111u, wParam, lParam);
}

//----- (6F7D895E) --------------------------------------------------------
HWND __thiscall CPager::v_OnNotify(CPager *this, unsigned int a2, __int32 lParam)
{
  return SendNotifyEx(
           *((_DWORD *)this + 2),
           HWND_MESSAGE|0x2,
           *(_DWORD *)(lParam + 8),
           lParam,
           *((_DWORD *)this + 5) & 1);
}

//----- (6F7D8984) --------------------------------------------------------
void __thiscall CPager::_GetChildSize(CPager *this)
{
  CPager *v1; // ebx@1
  bool v2; // zf@2
  LONG v3; // esi@3
  LONG v4; // edi@3
  LPARAM lParam; // [sp+4h] [bp-28h]@2
  int v6; // [sp+10h] [bp-1Ch]@2
  LONG v7; // [sp+14h] [bp-18h]@2
  LONG v8; // [sp+18h] [bp-14h]@2
  struct tagRECT Rect; // [sp+1Ch] [bp-10h]@2

  v1 = this;
  if ( *((_DWORD *)this + 10) )
  {
    v2 = (*((_BYTE *)this + 12) & 1) == 0;
    Rect.left = *((_DWORD *)this + 17);
    Rect.top = *((_DWORD *)this + 18);
    Rect.right = *((_DWORD *)this + 19);
    Rect.bottom = *((_DWORD *)this + 20);
    v6 = v2 + 1;
    v7 = Rect.right - Rect.left;
    v8 = Rect.bottom - Rect.top;
    CCSendNotify((int)((char *)this + 4), -902, (LPARAM)&lParam);
    if ( *((_BYTE *)v1 + 12) & 1 )
    {
      v3 = v7;
      v4 = Rect.bottom - Rect.top;
    }
    else
    {
      v3 = Rect.right - Rect.left;
      v4 = v8;
    }
    GetWindowRect(*((HWND *)v1 + 10), &Rect);
    MapWindowPoints(0, *((HWND *)v1 + 1), (LPPOINT)&Rect, 2u);
    if ( *((_BYTE *)v1 + 12) & 1 )
      Rect.top = *((_DWORD *)v1 + 30);
    else
      Rect.left = *((_DWORD *)v1 + 30);
    Rect.right = Rect.left + v3;
    Rect.bottom = Rect.top + v4;
    *(_OWORD *)((char *)v1 + 92) = Rect;
  }
}

//----- (6F7D8A44) --------------------------------------------------------
void __thiscall CPager::_SetChildPos(CPager *this, const struct tagRECT *a2, unsigned int uFlags)
{
  CPager *v3; // ebx@1
  bool v4; // zf@1
  int v5; // eax@1
  LONG v6; // esi@3
  int v7; // eax@9
  int v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+10h] [bp-24h]@1
  int v10; // [sp+14h] [bp-20h]@1
  int v11; // [sp+18h] [bp-1Ch]@1
  struct tagRECT rc; // [sp+1Ch] [bp-18h]@1
  int v13; // [sp+2Ch] [bp-8h]@1
  LONG v14; // [sp+30h] [bp-4h]@1

  rc.left = a2->left;
  rc.top = a2->top;
  rc.right = a2->right;
  rc.bottom = a2->bottom;
  v3 = this;
  v4 = (*((_BYTE *)this + 12) & 1) == 0;
  v5 = *((_DWORD *)this + 11);
  v8 = *((_DWORD *)this + 17);
  v9 = *((_DWORD *)this + 18);
  v10 = *((_DWORD *)this + 19);
  v13 = v5;
  v14 = *((_DWORD *)this + 12);
  v11 = *((_DWORD *)this + 20);
  if ( !v4 )
  {
    FlipPoint((int)&v13);
    FlipRect((int)&rc);
    FlipRect((int)&v8);
  }
  v6 = v14;
  if ( rc.bottom - rc.top < v11 - v9 )
  {
    rc.bottom = rc.top + v11 - v9;
    v6 = 0;
  }
  if ( v6 >= 0 )
  {
    if ( v6 > rc.bottom + v9 + *((_DWORD *)v3 + 27) - *((_DWORD *)v3 + 30) - v11 - rc.top )
      v6 = rc.bottom + v9 + *((_DWORD *)v3 + 27) - *((_DWORD *)v3 + 30) - v11 - rc.top;
  }
  else
  {
    v6 = 0;
  }
  v7 = v6;
  if ( *((_BYTE *)v3 + 84) & 2 )
    v7 = v6 + *((_DWORD *)v3 + 27) - *((_DWORD *)v3 + 30);
  OffsetRect(&rc, 0, -(rc.top + v7));
  v4 = (*((_BYTE *)v3 + 12) & 1) == 0;
  v14 = v6;
  if ( !v4 )
  {
    FlipPoint((int)&v13);
    FlipRect((int)&rc);
  }
  *((_DWORD *)v3 + 11) = v13;
  *((_DWORD *)v3 + 12) = v14;
  SetWindowPos(*((HWND *)v3 + 10), 0, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, uFlags);
}

//----- (6F7D8B40) --------------------------------------------------------
int __thiscall CPager::_PGFToPGNDirection(CPager *this, unsigned __int32 a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = 0;
  if ( *((_BYTE *)this + 12) & 1 )
  {
    LOBYTE(v2) = a2 != 0;
    result = 4 * v2 + 4;
  }
  else
  {
    LOBYTE(v2) = a2 != 0;
    result = v2 + 1;
  }
  return result;
}

//----- (6F7D8B6C) --------------------------------------------------------
struct tagRECT *__thiscall CPager::_GetButtonRect(CPager *this, LPRECT lpRect, int a3)
{
  CPager *v3; // esi@1

  v3 = this;
  GetWindowRect(*((HWND *)this + 1), lpRect);
  if ( *((_BYTE *)v3 + 12) & 1 )
    FlipRect((int)lpRect);
  if ( *((_DWORD *)v3 + 7) & 0x400000 && *((_BYTE *)v3 + 12) & 1 )
  {
    if ( a3 )
    {
      if ( a3 == 1 )
        a3 = 0;
    }
    else
    {
      a3 = 1;
    }
  }
  if ( a3 )
  {
    if ( a3 != 1 )
      goto LABEL_14;
    lpRect->top = lpRect->bottom - *((_DWORD *)v3 + 27);
  }
  else
  {
    lpRect->bottom = lpRect->top + *((_DWORD *)v3 + 27);
  }
  lpRect->left += *((_DWORD *)v3 + 30);
  lpRect->right -= *((_DWORD *)v3 + 30);
LABEL_14:
  if ( *((_BYTE *)v3 + 12) & 1 )
    FlipRect((int)lpRect);
  return lpRect;
}

//----- (6F7D8BF5) --------------------------------------------------------
void __thiscall CPager::_OnReCalcSize(CPager *this)
{
  CPager *v1; // ebx@1
  struct tagRECT v2; // [sp+Ch] [bp-10h]@1

  v1 = this;
  CCInvalidateFrame(*((HWND *)this + 1));
  *((_DWORD *)v1 + 15) &= 0xFFFFFFFE;
  v2.left = *((_DWORD *)v1 + 23);
  v2.top = *((_DWORD *)v1 + 24);
  v2.right = *((_DWORD *)v1 + 25);
  v2.bottom = *((_DWORD *)v1 + 26);
  CPager::_SetChildPos(v1, &v2, 0);
}

//----- (6F7D8C2F) --------------------------------------------------------
void __thiscall CPager::_OnSetPos(CPager *this, int a2)
{
  CPager *v2; // ebx@1
  bool v3; // zf@1
  int v4; // eax@3
  struct tagRECT v5; // [sp+Ch] [bp-10h]@1

  v2 = this;
  v3 = (*((_BYTE *)this + 12) & 1) == 0;
  v5.left = *((_DWORD *)this + 23);
  v5.top = *((_DWORD *)this + 24);
  v5.right = *((_DWORD *)this + 25);
  v5.bottom = *((_DWORD *)this + 26);
  if ( !v3 )
  {
    FlipRect((int)&v5);
    FlipPoint((int)((char *)v2 + 44));
  }
  v4 = a2;
  if ( a2 < 0 )
    v4 = 0;
  if ( v4 <= v5.bottom - v5.top && *((_DWORD *)v2 + 12) != v4 )
  {
    v3 = (*((_BYTE *)v2 + 12) & 1) == 0;
    *((_DWORD *)v2 + 12) = v4;
    if ( !v3 )
    {
      FlipRect((int)&v5);
      FlipPoint((int)((char *)v2 + 44));
    }
    CCInvalidateFrame(*((HWND *)v2 + 1));
    CPager::_SetChildPos(v2, &v5, 0);
  }
}

//----- (6F7D8CB2) --------------------------------------------------------
int __thiscall CPager::_OnGetPos(CPager *this)
{
  int result; // eax@2

  if ( *((_BYTE *)this + 12) & 1 )
    result = *((_DWORD *)this + 11);
  else
    result = *((_DWORD *)this + 12);
  return result;
}

//----- (6F7D8CC5) --------------------------------------------------------
unsigned __int32 __thiscall CPager::_GetButtonState(CPager *this, int a2)
{
  unsigned __int32 result; // eax@1

  result = 0;
  if ( !a2 || a2 == 1 )
    result = *((_DWORD *)this + a2 + 21);
  return result;
}

//----- (6F7D8CE5) --------------------------------------------------------
void __thiscall CPager::_KillTimer(CPager *this)
{
  CPager *v1; // esi@1

  v1 = this;
  KillTimer(*((HWND *)this + 1), 1u);
  *((_DWORD *)v1 + 15) &= 0xFFFFFFF7;
}

//----- (6F7D8D00) --------------------------------------------------------
int __thiscall CPager::_OnSetBorder(CPager *this, int a2)
{
  CPager *v2; // ebx@1
  int v3; // eax@1
  HWND v4; // ST04_4@5
  struct tagRECT v6; // [sp+Ch] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-4h]@1

  v2 = this;
  v7 = *((_DWORD *)this + 30);
  v3 = a2;
  if ( a2 < 0 )
    v3 = 0;
  if ( v3 > *((_DWORD *)this + 27) )
    v3 = *((_DWORD *)this + 27);
  v4 = (HWND)*((_DWORD *)this + 1);
  *((_DWORD *)this + 30) = v3;
  CCInvalidateFrame(v4);
  v6.left = *((_DWORD *)v2 + 23);
  v6.top = *((_DWORD *)v2 + 24);
  v6.right = *((_DWORD *)v2 + 25);
  v6.bottom = *((_DWORD *)v2 + 26);
  CPager::_SetChildPos(v2, &v6, 0);
  return v7;
}

//----- (6F7D8D56) --------------------------------------------------------
int __thiscall CPager::_OnSetButtonSize(CPager *this, int a2)
{
  CPager *v2; // ebx@1
  char *v3; // eax@1
  int v4; // eax@3
  struct tagRECT v6; // [sp+Ch] [bp-14h]@5
  int v7; // [sp+1Ch] [bp-4h]@1

  v2 = this;
  v3 = (char *)this + 108;
  v7 = *((_DWORD *)this + 27);
  *((_DWORD *)this + 27) = a2;
  if ( a2 < 12 )
    *(_DWORD *)v3 = 12;
  v4 = *(_DWORD *)v3;
  if ( *((_DWORD *)this + 30) > v4 )
    *((_DWORD *)this + 30) = v4;
  CCInvalidateFrame(*((HWND *)this + 1));
  v6.left = *((_DWORD *)v2 + 23);
  v6.top = *((_DWORD *)v2 + 24);
  v6.right = *((_DWORD *)v2 + 25);
  v6.bottom = *((_DWORD *)v2 + 26);
  CPager::_SetChildPos(v2, &v6, 0);
  return v7;
}

//----- (6F7D8DB1) --------------------------------------------------------
int __stdcall DrawChar(HDC hdc, COLORREF color, unsigned int a3, WCHAR chText, unsigned int a5, UINT format, int a7)
{
  char v7; // al@1
  COLORREF v8; // eax@5
  struct tagRECT rc; // [sp+Ch] [bp-14h]@4
  int v11; // [sp+1Ch] [bp-4h]@4
  COLORREF colora; // [sp+2Ch] [bp+Ch]@8
  unsigned int v13; // [sp+30h] [bp+10h]@2

  v7 = a3;
  if ( format || (v13 = 1, v7 >= 0) )
    v13 = 0;
  rc.left = *(_DWORD *)color;
  rc.top = *(_DWORD *)(color + 4);
  rc.right = *(_DWORD *)(color + 8);
  v11 = v7 & 0x10;
  rc.bottom = *(_DWORD *)(color + 12);
  if ( format )
  {
    v8 = g_clrBtnShadow;
  }
  else
  {
    v8 = g_clrBtnHighlight;
    if ( !v13 )
      v8 = g_clrBtnText;
  }
  colora = SetTextColor(hdc, v8);
  if ( a5 )
  {
    if ( !a7 )
      rc.top += (rc.bottom - rc.top - a5) >> 1;
    rc.bottom = a5 + rc.top;
    format = 41;
  }
  else
  {
    format = 37;
  }
  if ( v13 || v11 )
    OffsetRect(&rc, 1, 1);
  DrawTextW(hdc, &chText, 1, &rc, format);
  if ( v13 )
  {
    OffsetRect(&rc, -1, -1);
    SetTextColor(hdc, g_clrBtnShadow);
    DrawTextW(hdc, &chText, 1, &rc, format);
  }
  SetTextColor(hdc, colora);
  return 1;
}

//----- (6F7D8EB6) --------------------------------------------------------
void __stdcall DrawBlankButton(HDC hdc, LPRECT lprc, unsigned __int32 a3)
{
  signed int v3; // edi@3
  signed int v4; // eax@4
  COLORREF v5; // eax@9
  int v6; // [sp+Ch] [bp-Ch]@3
  int v7; // [sp+10h] [bp-8h]@4
  int v8; // [sp+14h] [bp-4h]@6

  if ( !(a3 & 0x18) || a3 & 0x100 )
  {
    v3 = 0;
  }
  else
  {
    v3 = 1;
    v6 = 1;
    if ( GetBkColor(hdc) == g_clrBtnShadow )
    {
      v7 = g_clrBtnHighlight;
      v4 = g_clrBtnText;
    }
    else
    {
      v4 = -16777216;
      v7 = -16777216;
    }
    v8 = v4;
    CCDrawEdge(hdc, lprc, 2 * ((a3 & 8) != 0) + 2, 8207, (int)&v6);
  }
  if ( !(a3 & 0x40) )
  {
    v5 = GetBkColor(hdc);
    FillRectClr(hdc, lprc, v5);
  }
  if ( !v3 )
    InflateRect(lprc, -g_cxBorder, -g_cyBorder);
}

//----- (6F7D8F65) --------------------------------------------------------
void __stdcall DrawCharButton(HDC hdc, RECT *lprcSrc, unsigned __int32 a3, WCHAR chText, unsigned int a5, UINT format, int a7)
{
  int v7; // ebx@3
  struct tagRECT rcDst; // [sp+4h] [bp-10h]@1

  CopyRect(&rcDst, lprcSrc);
  DrawBlankButton(hdc, &rcDst, a3);
  if ( rcDst.right - rcDst.left > 0 && rcDst.bottom - rcDst.top > 0 )
  {
    v7 = SetBkMode(hdc, 1);
    DrawChar(hdc, (COLORREF)&rcDst, a3, chText, a5, format, a7);
    SetBkMode(hdc, v7);
  }
}

//----- (6F7D8FD7) --------------------------------------------------------
BOOL __stdcall DrawScrollArrow(HDC hdc, HGDIOBJ h, unsigned __int32 a3)
{
  RECT *v3; // ebx@4
  int v4; // eax@4
  HFONT ho; // [sp+Ch] [bp-8h]@6
  WCHAR chText; // [sp+10h] [bp-4h]@1
  HGDIOBJ ha; // [sp+20h] [bp+Ch]@6

  chText = 2 * ((a3 & 4) == 0) + 51;
  if ( GetLayout(hdc) & 1 && a3 & 4 )
    a3 ^= 0x20u;
  v3 = (RECT *)h;
  v4 = *((_DWORD *)h + 3) - *((_DWORD *)h + 1);
  if ( *((_DWORD *)h + 2) - *(_DWORD *)h < v4 )
    v4 = *((_DWORD *)h + 2) - *(_DWORD *)h;
  ho = CreateFontW(v4 - 2 * g_cxBorder, 0, 0, 0, 400, 0, 0, 0, 2u, 0, 0, 0, 0, L"MARLETT");
  ha = SelectObject(hdc, ho);
  if ( a3 & 0x20 )
    ++chText;
  DrawCharButton(hdc, v3, a3, chText, 0, 0, 0);
  SelectObject(hdc, ha);
  return DeleteObject(ho);
}

//----- (6F7D9093) --------------------------------------------------------
HGDIOBJ __stdcall DrawChevron(HDC hdc, RECT *lprcSrc, int y)
{
  HBRUSH v3; // eax@3
  int v4; // edi@3
  int v5; // ecx@4
  LONG v6; // eax@5
  int v7; // ebx@11
  struct tagRECT rcDst; // [sp+Ch] [bp-18h]@1
  HGDIOBJ h; // [sp+1Ch] [bp-8h]@3
  int v11; // [sp+20h] [bp-4h]@7
  LONG lprcSrca; // [sp+30h] [bp+Ch]@4
  int lprcSrcb; // [sp+30h] [bp+Ch]@11
  int ya; // [sp+34h] [bp+10h]@8
  LONG yb; // [sp+34h] [bp+10h]@12

  CopyRect(&rcDst, lprcSrc);
  DrawBlankButton(hdc, &rcDst, y);
  if ( y & 0x10 )
    OffsetRect(&rcDst, 1, 1);
  v3 = GetSysColorBrush(18);
  h = SelectObject(hdc, v3);
  v4 = 2 * ((y & 1) != 0) + 2;
  if ( y & 4 )
  {
    v5 = (rcDst.left + rcDst.right - 4 * v4) / 2;
    lprcSrca = (rcDst.left + rcDst.right - 4 * v4) / 2;
    if ( y & 2 )
      v6 = rcDst.top + v4 + 4;
    else
      v6 = (rcDst.bottom + rcDst.top) / 2;
    v11 = -v4;
    if ( -v4 <= v4 )
    {
      ya = v6 - v4;
      while ( 1 )
      {
        PatBlt(hdc, v5, ya, v4, 1, 0xF00021u);
        PatBlt(hdc, lprcSrca + 2 * v4, ya, v4, 1, 0xF00021u);
        lprcSrca += 2 * (v11++ < 0) - 1;
        ++ya;
        if ( v11 > v4 )
          break;
        v5 = lprcSrca;
      }
    }
  }
  else
  {
    lprcSrcb = rcDst.top + 1;
    v7 = -v4;
    if ( -v4 <= v4 )
    {
      yb = (rcDst.right + rcDst.left) / 2 - v4;
      do
      {
        PatBlt(hdc, yb, lprcSrcb, 1, v4, 0xF00021u);
        PatBlt(hdc, yb, lprcSrcb + 2 * v4, 1, v4, 0xF00021u);
        lprcSrcb += 2 * (v7++ < 0) - 1;
        ++yb;
      }
      while ( v7 <= v4 );
    }
  }
  return SelectObject(hdc, h);
}

//----- (6F7D9208) --------------------------------------------------------
int __thiscall CPager::CPager(int this)
{
  int v1; // esi@1
  int v2; // eax@1

  v1 = this;
  *(_DWORD *)this = &CPager::`vftable';
  *(_DWORD *)(this + 116) = g_clrBtnFace;
  v2 = 3 * g_cxScrollbar / 4;
  *(_DWORD *)(this + 108) = v2;
  if ( v2 < 12 )
    *(_DWORD *)(this + 108) = 12;
  *(_DWORD *)(this + 52) = -1;
  *(_DWORD *)(this + 56) = -1;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 132) = GetDoubleClickTime() >> 3;
  return v1;
}
// 6F7D9260: using guessed type __int32 (__thiscall *CPager::`vftable')(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// 6F7E6970: using guessed type int g_cxScrollbar;

//----- (6F7D92DD) --------------------------------------------------------
__int32 __stdcall CPager::PagerWndProc(HWND hWnd, unsigned int Msg, unsigned int wParam, __int32 lParam)
{
  __int32 result; // eax@1
  int v5; // eax@2

  result = GetWindowLongW(hWnd, 0);
  if ( Msg != 1 )
  {
    if ( !result )
      return DefWindowProcW(hWnd, Msg, wParam, lParam);
    return (**(int (__thiscall ***)(__int32, HWND, unsigned int, unsigned int, __int32))result)(
             result,
             hWnd,
             Msg,
             wParam,
             lParam);
  }
  v5 = (int)operator new(0x88u);
  if ( v5 )
    result = CPager::CPager(v5);
  else
    result = 0;
  if ( result )
    return (**(int (__thiscall ***)(__int32, HWND, unsigned int, unsigned int, __int32))result)(
             result,
             hWnd,
             Msg,
             wParam,
             lParam);
  return result;
}

//----- (6F7D932C) --------------------------------------------------------
int __thiscall CControl::v_WndProc(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG v5; // esi@1
  int result; // eax@9
  signed int v7; // eax@21
  int v8; // [sp+8h] [bp-4h]@1

  v8 = 0;
  v5 = dwNewLong;
  if ( Msg <= 0x7D )
  {
    if ( Msg == 125 )
    {
      (*(void (__stdcall **)(WPARAM, LPARAM))(*(_DWORD *)dwNewLong + 32))(wParam, lParam);
    }
    else
    {
      if ( Msg == 1 )
      {
        CCCreateWindow();
        SetWindowLongW(hWnd, 0, v5);
        CIInitialize(v5 + 4, (WPARAM)hWnd, lParam);
        return (*(int (__thiscall **)(LONG))(*(_DWORD *)v5 + 16))(v5);
      }
      if ( Msg == 2 )
      {
        CCDestroyWindow();
        SetWindowLongW(hWnd, 0, 0);
        if ( v5 )
          (*(void (__thiscall **)(LONG, signed int))(*(_DWORD *)v5 + 4))(v5, 1);
        return v8;
      }
      if ( Msg != 5 )
      {
        if ( Msg != 15 )
        {
          if ( Msg == 78 )
            return (*(int (__stdcall **)(WPARAM, LPARAM))(*(_DWORD *)dwNewLong + 28))(wParam, lParam);
          if ( Msg == 85 )
            return CIHandleNotifyFormat(dwNewLong + 4, lParam);
LABEL_21:
          v7 = CCWndProc(dwNewLong + 4, Msg, wParam, lParam, (int)&v8);
          goto LABEL_22;
        }
        goto LABEL_25;
      }
      (*(void (__stdcall **)(_DWORD, _DWORD))(*(_DWORD *)dwNewLong + 20))((signed __int16)lParam, SHIWORD(lParam));
    }
    return v8;
  }
  if ( Msg == 131 )
  {
    v7 = (*(int (__stdcall **)(WPARAM, LPARAM, int *))(*(_DWORD *)dwNewLong + 36))(wParam, lParam, &v8);
LABEL_22:
    if ( v7 )
      return v8;
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
  }
  if ( Msg != 133 )
  {
    if ( Msg == 273 )
      return (*(int (__stdcall **)(WPARAM, LPARAM))(*(_DWORD *)dwNewLong + 24))(wParam, lParam);
    if ( Msg != 792 )
    {
      if ( Msg == 1061 )
      {
        result = *(_DWORD *)(dwNewLong + 8);
        *(_DWORD *)(dwNewLong + 8) = wParam;
        return result;
      }
      goto LABEL_21;
    }
LABEL_25:
    CControl::_OnPaint((CControl *)dwNewLong, (HDC)wParam);
    return v8;
  }
  (*(void (**)(void))(*(_DWORD *)dwNewLong + 8))();
  return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

//----- (6F7D949A) --------------------------------------------------------
int __thiscall CPager::_HitTestScreen(CPager *this, const struct tagPOINT *a2)
{
  CPager *v2; // esi@1
  HWND v3; // ST08_4@1
  struct tagRECT *v4; // eax@2
  struct tagRECT *v5; // eax@2
  const struct tagPOINT v6; // ST04_8@2
  int result; // eax@3
  struct tagRECT v8; // [sp+8h] [bp-34h]@2
  RECT rc; // [sp+18h] [bp-24h]@2
  struct tagRECT Rect; // [sp+28h] [bp-14h]@1
  CPager *v11; // [sp+38h] [bp-4h]@1

  v2 = this;
  v3 = (HWND)*((_DWORD *)this + 1);
  v11 = this;
  GetWindowRect(v3, &Rect);
  if ( !PtInRect(&Rect, *a2) )
    goto LABEL_9;
  v4 = CPager::_GetButtonRect(v2, &v8, 0);
  Rect.left = v4->left;
  Rect.top = v4->top;
  Rect.right = v4->right;
  Rect.bottom = v4->bottom;
  v5 = CPager::_GetButtonRect(v11, &v8, 1);
  v6 = *a2;
  rc.left = v5->left;
  rc.top = v5->top;
  rc.right = v5->right;
  rc.bottom = v5->bottom;
  if ( PtInRect(&Rect, v6) )
    return (*((_DWORD *)v11 + 21) != 0) - 1;
  if ( PtInRect(&rc, *a2) )
    result = 2 * (*((_DWORD *)v11 + 22) != 0) - 1;
  else
LABEL_9:
    result = -1;
  return result;
}

//----- (6F7D954C) --------------------------------------------------------
int __thiscall CPager::_HitTest(CPager *this, int a2, int a3)
{
  CPager *v3; // esi@1
  struct tagPOINT Point; // [sp+4h] [bp-8h]@1

  Point.x = a2;
  Point.y = a3;
  v3 = this;
  ClientToScreen(*((HWND *)this + 1), &Point);
  return CPager::_HitTestScreen(v3, &Point);
}

//----- (6F7D9584) --------------------------------------------------------
void __thiscall CPager::_DrawButton(CPager *this, HDC hdc, int a3)
{
  CPager *v3; // esi@1
  HWND v4; // ST08_4@1
  int v5; // ebx@1
  int v6; // ecx@12
  int v7; // eax@20
  struct tagRECT Rect; // [sp+Ch] [bp-18h]@1
  int v9; // [sp+1Ch] [bp-8h]@1
  unsigned __int32 v10; // [sp+20h] [bp-4h]@1

  v3 = this;
  v4 = (HWND)*((_DWORD *)this + 1);
  v10 = 0;
  v9 = 0;
  GetWindowRect(v4, &Rect);
  MapWindowPoints(0, *((HWND *)v3 + 1), (LPPOINT)&Rect, 2u);
  v5 = *((_DWORD *)v3 + a3 + 21);
  if ( !v5 )
    return;
  if ( !hdc )
  {
    hdc = GetWindowDC(*((HWND *)v3 + 1));
    v9 = 1;
  }
  if ( v5 & 2 )
  {
    v10 = 128;
  }
  else if ( v5 & 4 )
  {
    v10 = 16;
  }
  else if ( v5 & 8 )
  {
    v10 = 8;
  }
  OffsetRect(&Rect, -Rect.left, -Rect.top);
  if ( *((_BYTE *)v3 + 12) & 1 )
    FlipRect((int)&Rect);
  v6 = *((_DWORD *)v3 + 3) & 1;
  if ( v6 )
    v10 |= 4u;
  if ( a3 == 1 )
    v10 |= 0x20u;
  if ( !a3 )
  {
    Rect.bottom = Rect.top + *((_DWORD *)v3 + 27);
    goto LABEL_20;
  }
  if ( a3 == 1 )
  {
    Rect.top = Rect.bottom - *((_DWORD *)v3 + 27);
LABEL_20:
    v7 = *((_DWORD *)v3 + 30);
    Rect.left += v7;
    Rect.right -= v7;
  }
  if ( v6 )
    FlipRect((int)&Rect);
  SetBkColor(hdc, *((_DWORD *)v3 + 29));
  DrawScrollArrow(hdc, &Rect, v10);
  if ( v9 )
    ReleaseDC(*((HWND *)v3 + 1), hdc);
}

//----- (6F7D96AB) --------------------------------------------------------
void __thiscall CPager::v_OnNCPaint(CPager *this)
{
  CPager *v1; // esi@1
  HDC v2; // edi@1

  v1 = this;
  v2 = GetWindowDC(*((HWND *)this + 1));
  CPager::_DrawBlank(v1, v2, 0);
  CPager::_DrawButton(v1, v2, 0);
  CPager::_DrawBlank(v1, v2, 1);
  CPager::_DrawButton(v1, v2, 1);
  ReleaseDC(*((HWND *)v1 + 1), v2);
}

//----- (6F7D96F6) --------------------------------------------------------
int __thiscall CPager::_OnPrint(CPager *this, HDC hdc, LPARAM lParam)
{
  HDC v3; // edi@1
  CPager *v4; // esi@1
  int v5; // ebx@2
  struct tagRECT Rect; // [sp+8h] [bp-14h]@6
  int nSavedDC; // [sp+18h] [bp-4h]@1
  int hdca; // [sp+24h] [bp+8h]@2

  v3 = hdc;
  v4 = this;
  nSavedDC = SaveDC(hdc);
  if ( lParam & 2 )
  {
    v5 = 0;
    hdca = 0;
    CPager::_DrawBlank(v4, v3, 0);
    CPager::_DrawButton(v4, v3, 0);
    CPager::_DrawBlank(v4, v3, 1);
    CPager::_DrawButton(v4, v3, 1);
    if ( *((_DWORD *)v4 + 21) )
    {
      if ( *((_BYTE *)v4 + 12) & 1 )
        hdca = *((_DWORD *)v4 + 27);
      else
        v5 = *((_DWORD *)v4 + 27);
    }
    GetClientRect(*((HWND *)v4 + 1), &Rect);
    IntersectClipRect(v3, hdca, v5, hdca + Rect.right - Rect.left, v5 + Rect.bottom - Rect.top);
    lParam &= 0xFFFFFFFD;
  }
  DefWindowProcW(*((HWND *)v4 + 1), 0x317u, (WPARAM)v3, lParam);
  RestoreDC(v3, nSavedDC);
  return 1;
}

//----- (6F7D97B1) --------------------------------------------------------
void __thiscall CPager::v_OnSize(CPager *this, int a2, int a3)
{
  struct tagRECT v3; // [sp+0h] [bp-10h]@2

  if ( *((_DWORD *)this + 10) )
  {
    v3.left = *((_DWORD *)this + 23);
    v3.top = *((_DWORD *)this + 24);
    v3.right = *((_DWORD *)this + 25);
    v3.bottom = *((_DWORD *)this + 26);
    CPager::_SetChildPos(this, &v3, 0);
  }
}

//----- (6F7D97E1) --------------------------------------------------------
void __thiscall CPager::_Scroll(CPager *this, unsigned __int32 a2)
{
  CPager *v2; // ebx@1
  signed __int16 v3; // si@1
  bool v4; // zf@8
  int v5; // eax@8
  LONG v6; // eax@9
  int v7; // ecx@11
  int v8; // eax@17
  int v9; // eax@18
  int v10; // eax@19
  LPARAM lParam; // [sp+8h] [bp-40h]@13
  __int16 v12; // [sp+14h] [bp-34h]@8
  struct tagRECT v13; // [sp+16h] [bp-32h]@8
  int v14; // [sp+26h] [bp-22h]@8
  int v15; // [sp+2Ah] [bp-1Eh]@8
  int v16; // [sp+2Eh] [bp-1Ah]@8
  LONG v17; // [sp+32h] [bp-16h]@13
  struct tagRECT Rect; // [sp+38h] [bp-10h]@8
  int v19; // [sp+50h] [bp+8h]@8

  v2 = this;
  v3 = 0;
  if ( !(*((_BYTE *)this + 4 * a2 + 84) & 2) )
  {
    if ( GetKeyState(17) < 0 )
      v3 = 2;
    if ( GetKeyState(16) < 0 )
      v3 |= 1u;
    if ( GetKeyState(18) < 0 )
      v3 |= 4u;
    v19 = CPager::_PGFToPGNDirection(v2, a2);
    GetClientRect(*((HWND *)v2 + 1), &Rect);
    v4 = (*((_BYTE *)v2 + 12) & 1) == 0;
    v5 = *((_DWORD *)v2 + 11);
    v12 = v3;
    v13 = Rect;
    v15 = v5;
    v16 = *((_DWORD *)v2 + 12);
    v14 = v19;
    if ( v4 )
      v6 = Rect.bottom - Rect.top;
    else
      v6 = Rect.right - Rect.left;
    v7 = *((_DWORD *)v2 + 31);
    if ( v7 )
      v6 = v7 * *((_DWORD *)v2 + 32);
    v17 = v6;
    CCSendNotify((int)((char *)v2 + 4), -901, (LPARAM)&lParam);
    if ( v19 == 1 )
    {
      v9 = *((_DWORD *)v2 + 12);
    }
    else
    {
      if ( v19 == 2 )
      {
        v8 = *((_DWORD *)v2 + 12);
LABEL_21:
        v10 = v17 + v8;
        goto LABEL_24;
      }
      if ( v19 != 4 )
      {
        if ( v19 != 8 )
        {
          v10 = v19;
          goto LABEL_24;
        }
        v8 = *((_DWORD *)v2 + 11);
        goto LABEL_21;
      }
      v9 = *((_DWORD *)v2 + 11);
    }
    v10 = v9 - v17;
LABEL_24:
    CPager::_OnSetPos(v2, v10);
  }
}

//----- (6F7D98DD) --------------------------------------------------------
void __thiscall CPager::_OnMouseLeave(CPager *this)
{
  CPager *v1; // esi@1
  int v2; // ebx@1
  int v3; // eax@5
  int v4; // eax@7

  v1 = this;
  v2 = (int)((char *)this + 4);
  if ( GetCapture() == *((HWND *)this + 1) )
    CCReleaseCapture(v2);
  if ( *((_DWORD *)v1 + 16) >= 0 )
    *((_DWORD *)v1 + 16) = -1;
  v3 = *((_DWORD *)v1 + 21);
  if ( v3 & 0xC )
  {
    *((_DWORD *)v1 + 21) = v3 & 0xFFFFFFF3;
    CPager::_DrawButton(v1, 0, 0);
  }
  v4 = *((_DWORD *)v1 + 22);
  if ( v4 & 0xC )
  {
    *((_DWORD *)v1 + 22) = v4 & 0xFFFFFFF3;
    CPager::_DrawButton(v1, 0, 1);
  }
  CPager::_KillTimer(v1);
  *((_DWORD *)v1 + 15) &= 0xFFFFFFEF;
  if ( *((_BYTE *)v1 + 84) & 2 || *((_BYTE *)v1 + 88) & 2 )
    CCInvalidateFrame(*(HWND *)v2);
}

//----- (6F7D9956) --------------------------------------------------------
void __thiscall CPager::_OnMouseMove(CPager *this, char a2, __int32 a3)
{
  CPager *v3; // ebx@1
  int v4; // esi@3
  int v5; // eax@3
  struct tagRECT *v6; // esi@5
  int v7; // eax@5
  int v8; // esi@5
  bool v9; // zf@5
  int v10; // eax@5
  int v11; // eax@18
  UINT v12; // ST08_4@23
  struct tagRECT Rect; // [sp+4h] [bp-28h]@5
  RECT rc; // [sp+14h] [bp-18h]@5
  struct tagPOINT Point; // [sp+24h] [bp-8h]@1
  __int32 v16; // [sp+38h] [bp+Ch]@3

  v3 = this;
  Point.x = (signed __int16)a3;
  Point.y = SHIWORD(a3);
  if ( (signed __int16)a3 != *((_DWORD *)this + 13) || SHIWORD(a3) != *((_DWORD *)this + 14) )
  {
    *((_DWORD *)this + 14) = SHIWORD(a3);
    *((_DWORD *)this + 13) = (signed __int16)a3;
    v4 = CPager::_HitTest(this, (signed __int16)a3, SHIWORD(a3));
    v5 = *((_DWORD *)v3 + 16);
    v16 = v4;
    if ( v5 < 0 )
    {
      if ( v4 < 0 )
      {
LABEL_15:
        CPager::_OnMouseLeave(v3);
        return;
      }
      SetCapture(*((HWND *)v3 + 1));
      v11 = (int)((char *)v3 + 4 * v4 + 84);
      *(_DWORD *)v11 |= 8u;
      if ( *((_BYTE *)v3 + 12) & 2 )
        *(_DWORD *)v11 |= 4u;
      if ( a2 & 1 && *((_DWORD *)v3 + 16) < 0 || *((_BYTE *)v3 + 12) & 2 )
      {
        v12 = *((_DWORD *)v3 + 33);
        *((_DWORD *)v3 + 16) = v4;
        SetTimer(*((HWND *)v3 + 1), 1u, v12, 0);
      }
      CPager::_DrawButton(v3, 0, v4);
    }
    else
    {
      if ( *((_DWORD *)v3 + v5 + 21) )
      {
        ClientToScreen(*((HWND *)v3 + 1), &Point);
        v6 = CPager::_GetButtonRect(v3, &Rect, *((_DWORD *)v3 + 16));
        v7 = *((_DWORD *)v3 + 16);
        rc.left = v6->left;
        v6 = (struct tagRECT *)((char *)v6 + 4);
        rc.top = v6->left;
        v6 = (struct tagRECT *)((char *)v6 + 4);
        rc.right = v6->left;
        rc.bottom = v6->top;
        v8 = *((_DWORD *)v3 + v7 + 21);
        v9 = PtInRect(&rc, Point) == 0;
        v10 = (int)((char *)v3 + 4 * *((_DWORD *)v3 + 16) + 84);
        if ( v9 )
          *(_DWORD *)v10 &= 0xFFFFFFFB;
        else
          *(_DWORD *)v10 |= 4u;
        if ( v8 != *((_DWORD *)v3 + *((_DWORD *)v3 + 16) + 21) )
          CPager::_DrawButton(v3, 0, *((_DWORD *)v3 + 16));
        v4 = v16;
      }
      if ( GetCapture() == *((HWND *)v3 + 1) && !(a2 & 1) && !(*((_BYTE *)v3 + 12) & 2) && v4 != *((_DWORD *)v3 + 16) )
        goto LABEL_15;
    }
  }
}

//----- (6F7D9A8F) --------------------------------------------------------
void __thiscall CPager::_OnSetChild(CPager *this, HWND hWnd, HWND a3)
{
  CPager *v3; // esi@1
  int v4; // edi@1
  struct tagRECT Rect; // [sp+8h] [bp-10h]@3

  v3 = this;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)v3 + 15) &= 0xFFFFFFFE;
  *((_DWORD *)this + 10) = a3;
  v4 = (int)((char *)this + 4);
  if ( GetCapture() == *((HWND *)this + 1) )
    CCReleaseCapture(v4);
  *((_DWORD *)v3 + 16) = -1;
  GetClientRect(hWnd, &Rect);
  CPager::_OnReCalcSize(v3);
}

//----- (6F7D9AE3) --------------------------------------------------------
signed int __thiscall CPager::_DragCallback(CPager *this, HWND a2, unsigned int a3, unsigned int a4, __int32 a5)
{
  CPager *v5; // esi@1
  LONG v6; // ecx@5
  HWND v7; // ST04_4@5
  int v8; // eax@5
  int v9; // ecx@6
  UINT v10; // ST08_4@7
  HWND v11; // ST00_4@7
  struct tagPOINT Points; // [sp+4h] [bp-8h]@5

  v5 = this;
  if ( a3 )
  {
    if ( a3 != 4 )
      return -1;
    goto LABEL_9;
  }
  if ( a5 )
  {
    v6 = *(_DWORD *)a5;
    Points.y = *(_DWORD *)(a5 + 4);
    v7 = (HWND)*((_DWORD *)v5 + 1);
    Points.x = v6;
    MapWindowPoints(0, v7, &Points, 1u);
    v8 = CPager::_HitTest(v5, Points.x, Points.y);
    if ( v8 < 0 )
    {
      this = v5;
LABEL_9:
      CPager::_KillTimer(this);
      *((_DWORD *)v5 + 16) = -1;
      return -1;
    }
    v9 = *((_DWORD *)v5 + 15);
    if ( !(v9 & 8) )
    {
      v10 = *((_DWORD *)v5 + 33);
      v11 = (HWND)*((_DWORD *)v5 + 1);
      *((_DWORD *)v5 + 15) = v9 | 8;
      *((_DWORD *)v5 + 16) = v8;
      SetTimer(v11, 1u, v10, 0);
    }
  }
  return -1;
}

//----- (6F7D9B6D) --------------------------------------------------------
int __thiscall CPager::_HitTestCursor(CPager *this)
{
  CPager *v1; // esi@1
  struct tagPOINT Point; // [sp+4h] [bp-8h]@1

  v1 = this;
  GetCursorPos(&Point);
  return CPager::_HitTestScreen(v1, &Point);
}

//----- (6F7D9B94) --------------------------------------------------------
void __thiscall CPager::_OnLButtonChange(CPager *this, unsigned int a2, __int32 a3)
{
  CPager *v3; // esi@1
  int v4; // eax@1
  unsigned __int32 v5; // edi@1
  int v6; // eax@4

  v3 = this;
  v4 = CPager::_HitTest(this, (signed __int16)a3, SHIWORD(a3));
  v5 = v4;
  if ( a2 == 513 )
  {
    if ( v4 >= 0 )
    {
      SetCapture(*((HWND *)v3 + 1));
      *((_DWORD *)v3 + 15) |= 0x10u;
      *((_DWORD *)v3 + 16) = v5;
      *((_DWORD *)v3 + v5 + 21) |= 4u;
      CPager::_DrawButton(v3, 0, v5);
      CPager::_Scroll(v3, v5);
      SetTimer(*((HWND *)v3 + 1), 1u, 4 * *((_DWORD *)v3 + 33), 0);
    }
  }
  else
  {
    v6 = *((_DWORD *)v3 + 16);
    if ( v6 >= 0 )
    {
      *((_DWORD *)v3 + v6 + 21) &= 0xFFFFFFFB;
      CPager::_DrawButton(v3, 0, *((_DWORD *)v3 + 16));
      *((_DWORD *)v3 + 16) = -1;
    }
    CPager::_KillTimer(v3);
    if ( (v5 & 0x80000000) != 0 )
      CPager::_OnMouseLeave(v3);
  }
}

//----- (6F7D9C3A) --------------------------------------------------------
void __thiscall CPager::_OnTimer(CPager *this, unsigned int a2)
{
  CPager *v2; // esi@1
  unsigned __int32 v3; // edi@3

  v2 = this;
  if ( a2 == 1 && *((_DWORD *)this + 16) >= 0 )
  {
    SetTimer(*((HWND *)this + 1), 1u, *((_DWORD *)this + 33), 0);
    v3 = *((_DWORD *)v2 + 16);
    if ( CPager::_HitTestCursor(v2) == v3 )
    {
      CPager::_Scroll(v2, v3);
    }
    else if ( !(*((_BYTE *)v2 + 60) & 0x10) )
    {
      CPager::_OnMouseLeave(v2);
    }
  }
}

//----- (6F7D9C90) --------------------------------------------------------
signed int __stdcall CPager::PagerDragCallback(HWND hWnd, unsigned int a2, unsigned int a3, __int32 a4)
{
  LONG v4; // eax@1
  signed int result; // eax@2

  v4 = GetWindowLongW(hWnd, 0);
  if ( v4 )
    result = CPager::_DragCallback((CPager *)v4, hWnd, a2, a3, a4);
  else
    result = -1;
  return result;
}

//----- (6F7D9CB8) --------------------------------------------------------
void __thiscall CPager::_NeedScrollbars(CPager *this, struct tagRECT a2)
{
  CPager *v2; // ebx@1
  bool v3; // zf@1
  LONG v4; // eax@3
  LONG v5; // esi@5
  int v6; // eax@7
  int v7; // ecx@14
  int v8; // [sp+8h] [bp-Ch]@1
  int v9; // [sp+Ch] [bp-8h]@1
  LONG v10; // [sp+10h] [bp-4h]@3

  v2 = this;
  v3 = (*((_BYTE *)this + 12) & 1) == 0;
  v8 = *((_DWORD *)this + 11);
  v9 = *((_DWORD *)this + 12);
  if ( !v3 )
  {
    FlipRect((int)&a2);
    FlipPoint((int)&v8);
  }
  v4 = a2.bottom - a2.top;
  v3 = (*((_BYTE *)v2 + 12) & 1) == 0;
  a2.left = *((_DWORD *)v2 + 23);
  a2.top = *((_DWORD *)v2 + 24);
  a2.right = *((_DWORD *)v2 + 25);
  v10 = v4;
  a2.bottom = *((_DWORD *)v2 + 26);
  if ( !v3 )
  {
    FlipRect((int)&a2);
    v4 = v10;
  }
  v5 = a2.bottom - a2.top;
  if ( a2.bottom - a2.top < v4 )
    v9 = 0;
  v6 = CPager::_HitTestCursor(v2);
  if ( v9 <= 0 )
  {
    if ( *((_BYTE *)v2 + 12) & 2 || v6 && *((_DWORD *)v2 + 16) )
      *((_DWORD *)v2 + 21) = 0;
    else
      *((_DWORD *)v2 + 21) |= 2u;
  }
  else
  {
    *((_DWORD *)v2 + 21) = *((_DWORD *)v2 + 21) & 0xFFFFFFFD | 1;
  }
  v7 = v10;
  if ( *((_DWORD *)v2 + 21) )
    v7 = v10 - *((_DWORD *)v2 + 27);
  if ( v5 - v9 <= v7 )
  {
    if ( *((_BYTE *)v2 + 12) & 2 || v6 != 1 && *((_DWORD *)v2 + 16) != 1 )
      *((_DWORD *)v2 + 22) = 0;
    else
      *((_DWORD *)v2 + 22) |= 2u;
  }
  else
  {
    *((_DWORD *)v2 + 22) = *((_DWORD *)v2 + 22) & 0xFFFFFFFD | 1;
  }
}

//----- (6F7D9D95) --------------------------------------------------------
int __thiscall CPager::v_OnNCCalcSize(CPager *this, WPARAM wParam, LPARAM lParam, __int32 *a4)
{
  CPager *v4; // ebx@1
  int v5; // eax@6
  struct tagRECT v6; // ST00_16@6
  int v7; // eax@6
  int v8; // eax@9
  int v9; // eax@16
  int v10; // eax@21
  int v11; // eax@25
  int v13; // [sp+Ch] [bp-8h]@6
  int v14; // [sp+10h] [bp-4h]@6
  WPARAM wParama; // [sp+1Ch] [bp+8h]@4

  v4 = this;
  *a4 = DefWindowProcW(*((HWND *)this + 1), 0x83u, wParam, lParam);
  if ( !wParam )
    return 1;
  wParama = *((_DWORD *)v4 + 7) & 0x400000 && *((_BYTE *)v4 + 12) & 1;
  v5 = *((_DWORD *)v4 + 30);
  *((_DWORD *)v4 + 17) = *(_DWORD *)lParam;
  *((_DWORD *)v4 + 18) = *(_DWORD *)(lParam + 4);
  *((_DWORD *)v4 + 19) = *(_DWORD *)(lParam + 8);
  *((_DWORD *)v4 + 20) = *(_DWORD *)(lParam + 12);
  InflateRect((LPRECT)((char *)v4 + 68), -v5, -v5);
  CPager::_GetChildSize(v4);
  v6.left = *(_DWORD *)lParam;
  *(_QWORD *)&v6.top = *(_QWORD *)(lParam + 4);
  v13 = *((_DWORD *)v4 + 21);
  v14 = *((_DWORD *)v4 + 22);
  v6.bottom = *(_DWORD *)(lParam + 12);
  CPager::_NeedScrollbars(v4, v6);
  v7 = *((_DWORD *)v4 + 21);
  if ( v13 != v7 && (!v13 || !v7) || (v8 = *((_DWORD *)v4 + 22), v14 != v8) && (!v14 || !v8) )
    RedrawWindow(*((HWND *)v4 + 1), 0, 0, 5u);
  if ( *((_BYTE *)v4 + 12) & 1 )
    FlipRect(lParam);
  if ( *((_DWORD *)v4 + 21) )
  {
    v9 = *((_DWORD *)v4 + 27);
    if ( wParama )
    {
      *(_DWORD *)(lParam + 12) -= v9;
      goto LABEL_20;
    }
  }
  else
  {
    v9 = *((_DWORD *)v4 + 30);
  }
  *(_DWORD *)(lParam + 4) += v9;
LABEL_20:
  if ( !*((_DWORD *)v4 + 22) )
  {
    v10 = *((_DWORD *)v4 + 30);
    goto LABEL_24;
  }
  v10 = *((_DWORD *)v4 + 27);
  if ( !wParama )
  {
LABEL_24:
    *(_DWORD *)(lParam + 12) -= v10;
    goto LABEL_25;
  }
  *(_DWORD *)(lParam + 4) += v10;
LABEL_25:
  v11 = *(_DWORD *)(lParam + 4);
  if ( *(_DWORD *)(lParam + 12) < v11 )
    *(_DWORD *)(lParam + 12) = v11;
  if ( *((_BYTE *)v4 + 12) & 1 )
    FlipRect(lParam);
  return 1;
}

//----- (6F7D9EB4) --------------------------------------------------------
int __thiscall CPager::v_OnStyleChanged(CPager *this, unsigned int a2, __int32 a3)
{
  CPager *v3; // esi@1
  int v4; // ebx@1

  v3 = this;
  v4 = CControl::v_OnStyleChanged(this, a2, a3);
  if ( v4 & 4 )
  {
    if ( !(*((_DWORD *)v3 + 3) & 4) || *((_DWORD *)v3 + 28) )
    {
      if ( !(*((_DWORD *)v3 + 3) & 4) && *((_DWORD *)v3 + 28) )
        DestroyDragProxy(*((CDragProxy **)v3 + 28));
    }
    else
    {
      *((_DWORD *)v3 + 28) = CreateDragProxy(*((_DWORD *)v3 + 1), (int)CPager::PagerDragCallback, 1);
    }
  }
  if ( v4 )
    CCInvalidateFrame(*((HWND *)v3 + 1));
  return v4;
}

//----- (6F7D9F1B) --------------------------------------------------------
signed int __thiscall CPager::v_OnCreate(CPager *this)
{
  if ( *((_BYTE *)this + 12) & 4 )
    *((_DWORD *)this + 28) = CreateDragProxy(*((_DWORD *)this + 1), (int)CPager::PagerDragCallback, 1);
  return 1;
}

//----- (6F7D9F42) --------------------------------------------------------
signed int __thiscall CPager::v_WndProc(CPager *this, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  signed int v5; // esi@1
  LONG v6; // ebx@1
  int v8; // eax@12
  HWND v9; // ST0C_4@15
  bool v10; // zf@17
  POINT v11; // ST08_8@46
  int v12; // eax@51
  LPARAM v13; // eax@58
  int v14; // esi@58
  HWND v15; // ST0C_4@60
  struct tagRECT Rect; // [sp+Ch] [bp-20h]@17
  RECT rect; // [sp+1Ch] [bp-10h]@11

  v5 = Msg;
  v6 = (LONG)this;
  if ( Msg > 0x1402 )
  {
    if ( Msg <= 0x2004 )
    {
      if ( Msg == 8196 )
      {
        if ( !*((_DWORD *)this + 28) )
          *((_DWORD *)this + 28) = CreateDragProxy(*((_DWORD *)this + 1), (int)CPager::PagerDragCallback, 0);
        GetDragProxyTarget(*(_DWORD *)(v6 + 112), lParam);
      }
      else
      {
        switch ( Msg )
        {
          case 0x140Du:
            *((_DWORD *)this + 31) = (unsigned __int16)lParam;
            *((_DWORD *)this + 32) = (unsigned int)lParam >> 16;
            *((_DWORD *)this + 33) = wParam;
            return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
          case 0x1403u:
            *((_DWORD *)this + 15) ^= (*((_DWORD *)this + 15) ^ 2 * (wParam != 0)) & 2;
            return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
          case 0x1404u:
            v13 = lParam;
            v14 = *((_DWORD *)this + 29);
            if ( lParam == -16777216 )
              v13 = g_clrBtnFace;
            v15 = (HWND)*((_DWORD *)this + 1);
            *((_DWORD *)this + 15) |= 4u;
            *((_DWORD *)this + 29) = v13;
            CCInvalidateFrame(v15);
            RedrawWindow(*(HWND *)(v6 + 4), 0, 0, 5u);
            return v14;
          case 0x1405u:
            return *((_DWORD *)this + 29);
          case 0x1406u:
            return CPager::_OnSetBorder(this, lParam);
          case 0x1407u:
            return *((_DWORD *)this + 30);
          case 0x1408u:
            CPager::_OnSetPos(this, lParam);
            return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
          case 0x1409u:
            return CPager::_OnGetPos(this);
          case 0x140Au:
            return CPager::_OnSetButtonSize(this, lParam);
          case 0x140Bu:
            return *((_DWORD *)this + 27);
          case 0x140Cu:
            return CPager::_GetButtonState(this, lParam);
          default:
            return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
        }
      }
    }
    return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
  }
  if ( Msg == 5122 )
  {
    v12 = *((_DWORD *)this + 15);
    if ( !(v12 & 1) )
    {
      *((_DWORD *)this + 15) = v12 | 1;
      PostMessageW(hWnd, 0xC8u, wParam, lParam);
    }
    return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
  }
  if ( Msg > 0xC8 )
  {
    if ( Msg != 275 )
    {
      if ( Msg == 512 )
      {
        if ( *((_BYTE *)this + 60) & 2 && *((_DWORD *)this + 10) )
        {
          GetClientRect(*((HWND *)this + 1), &Rect);
          v11.y = SHIWORD(lParam);
          v11.x = (signed __int16)lParam;
          if ( PtInRect(&Rect, v11) )
            SendMessageW(
              *(HWND *)(v6 + 40),
              0x200u,
              wParam,
              (unsigned __int16)(*(_WORD *)(v6 + 44) + lParam) | ((unsigned __int16)(*(_WORD *)(v6 + 48) + HIWORD(lParam)) << 16));
          v5 = 512;
        }
        CPager::_OnMouseMove((CPager *)v6, wParam, lParam);
      }
      else if ( Msg > 0x200 )
      {
        if ( Msg <= 0x202 )
        {
          if ( !(*((_BYTE *)this + 12) & 2) )
            CPager::_OnLButtonChange(this, Msg, lParam);
        }
        else if ( Msg == 675 )
        {
          CPager::_OnMouseLeave(this);
        }
        else
        {
          if ( Msg == 791 )
            return CPager::_OnPrint(this, (HDC)wParam, lParam);
          if ( Msg == 5121 )
            CPager::_OnSetChild(this, hWnd, (HWND)lParam);
        }
      }
      return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
    }
    CPager::_OnTimer(this, wParam);
    return 0;
  }
  if ( Msg == 200 )
  {
    CPager::_OnReCalcSize(this);
    return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
  }
  if ( Msg == 2 )
  {
    if ( *((_DWORD *)this + 28) )
      DestroyDragProxy(*((CDragProxy **)this + 28));
    return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
  }
  if ( Msg == 7 )
  {
    SetFocus(*((HWND *)this + 10));
    return 0;
  }
  if ( Msg != 20 )
  {
    switch ( Msg )
    {
      case 0x15u:
        if ( !(*((_BYTE *)this + 60) & 4) )
        {
          InitGlobalColors();
          v9 = *(HWND *)(v6 + 4);
          *(_DWORD *)(v6 + 116) = g_clrBtnFace;
          CCInvalidateFrame(v9);
        }
        break;
      case 0x1Au:
        InitGlobalMetrics(wParam);
        v8 = 3 * g_cxScrollbar / 4;
        *(_DWORD *)(v6 + 108) = v8;
        if ( v8 < 12 )
          *(_DWORD *)(v6 + 108) = 12;
        break;
      case 0x84u:
        rect.bottom = SHIWORD(lParam);
        rect.right = (signed __int16)lParam;
        return CPager::_HitTestScreen(this, (const struct tagPOINT *)&rect.right) != -1 ? 1 : -1;
    }
    return CControl::v_WndProc(v6, hWnd, v5, wParam, lParam);
  }
  CCForwardEraseBackground(*((HWND *)this + 1), (HDC)wParam);
  if ( *(_DWORD *)(v6 + 120) )
  {
    GetClientRect(*(HWND *)(v6 + 4), &Rect);
    v10 = (*(_BYTE *)(v6 + 12) & 1) == 0;
    rect = Rect;
    if ( !v10 )
      FlipRect((int)&rect);
    v10 = (*(_BYTE *)(v6 + 12) & 1) == 0;
    rect.right = *(_DWORD *)(v6 + 120) + rect.left + 1;
    if ( !v10 )
      FlipRect((int)&rect);
    FillRectClr((HDC)wParam, &rect, *(_DWORD *)(v6 + 116));
    v10 = (*(_BYTE *)(v6 + 12) & 1) == 0;
    rect = Rect;
    if ( !v10 )
      FlipRect((int)&rect);
    v10 = (*(_BYTE *)(v6 + 12) & 1) == 0;
    rect.left = rect.right - *(_DWORD *)(v6 + 120) - 1;
    if ( !v10 )
      FlipRect((int)&rect);
    FillRectClr((HDC)wParam, &rect, *(_DWORD *)(v6 + 116));
  }
  return 1;
}
// 6F7E6970: using guessed type int g_cxScrollbar;

//----- (6F7DA366) --------------------------------------------------------
signed int CNativeFont::v_OnCreate()
{
  return 1;
}

//----- (6F7DA36F) --------------------------------------------------------
signed int __stdcall CNativeFont::_GetFontAssocStatus(enum FASTATUS *a1)
{
  int v1; // eax@1
  signed int v2; // ebx@1
  DWORD cbData; // [sp+8h] [bp-2Ch]@5
  HKEY phkResult; // [sp+Ch] [bp-28h]@4
  BYTE Data[2]; // [sp+10h] [bp-24h]@4
  char v7; // [sp+12h] [bp-22h]@4
  __int16 v8; // [sp+2Eh] [bp-6h]@4

  v1 = CNativeFont::_s_uiFontAssocStatus;
  v2 = 0;
  if ( !CNativeFont::_s_uiFontAssocStatus )
  {
    if ( g_bRunOnNT5 )
    {
      v1 = 2;
    }
    else
    {
      *(_WORD *)Data = 0;
      memset(&v7, 0, 0x1Cu);
      v8 = 0;
      if ( RegOpenKeyExW(
             HKEY_LOCAL_MACHINE,
             L"System\\CurrentControlSet\\Control\\FontAssoc\\Associated Charset",
             0,
             0x20019u,
             &phkResult) )
      {
        v2 = 1;
      }
      else
      {
        cbData = 32;
        RegQueryValueExW(phkResult, L"ANSI(00)", 0, 0, Data, &cbData);
        RegCloseKey(phkResult);
      }
      v1 = (StrCmpICW((int)Data, (int)L"yes") == 0) + 1;
    }
    CNativeFont::_s_uiFontAssocStatus = v1;
  }
  *(_DWORD *)a1 = v1;
  return v2;
}
// 6F7DA4AC: using guessed type wchar_t aYes[4];
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7DA4D3) --------------------------------------------------------
__int32 __stdcall CNativeFont::NativeFontWndProc(HWND hWnd, unsigned int Msg, unsigned int wParam, __int32 lParam)
{
  __int32 result; // eax@1

  result = GetWindowLongW(hWnd, 0);
  if ( Msg != 1 )
  {
    if ( !result )
      return DefWindowProcW(hWnd, Msg, wParam, lParam);
    return (**(int (__thiscall ***)(__int32, HWND, unsigned int, unsigned int, __int32))result)(
             result,
             hWnd,
             Msg,
             wParam,
             lParam);
  }
  result = (__int32)operator new(0x34u);
  if ( result )
  {
    *(_DWORD *)(result + 40) = 0;
    *(_DWORD *)(result + 44) = 0;
    *(_DWORD *)(result + 48) = 0;
    *(_DWORD *)result = &CNativeFont::`vftable';
  }
  else
  {
    result = 0;
  }
  if ( result )
    return (**(int (__thiscall ***)(__int32, HWND, unsigned int, unsigned int, __int32))result)(
             result,
             hWnd,
             Msg,
             wParam,
             lParam);
  return result;
}
// 6F7DA528: using guessed type __int32 (__thiscall *CNativeFont::`vftable')(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

//----- (6F7DA555) --------------------------------------------------------
BOOL __thiscall CNativeFont::_GetNativeDialogFont(CNativeFont *this, HWND hWnd)
{
  CNativeFont *v2; // esi@1
  LRESULT v3; // edi@2
  HFONT v4; // eax@5
  int v6; // [sp+8h] [bp-C0h]@2
  int pv; // [sp+Ch] [bp-BCh]@2
  char v8; // [sp+23h] [bp-A5h]@4
  int pvParam; // [sp+68h] [bp-60h]@2
  char v10; // [sp+7Fh] [bp-49h]@4

  v2 = this;
  if ( !*((_DWORD *)this + 11) )
  {
    v3 = SendMessageW(hWnd, 0x31u, 0, 0);
    v6 = 0;
    GetObjectW((HANDLE)v3, 92, &pv);
    SystemParametersInfoW(0x1Fu, 0x5Cu, &pvParam, 0);
    if ( *((_BYTE *)v2 + 12) & 0x20 && (CNativeFont::_GetFontAssocStatus((enum FASTATUS *)&v6), v6 == 2) || v10 == v8 )
    {
      *((_DWORD *)v2 + 11) = v3;
      *((_DWORD *)v2 + 10) = v3;
    }
    else
    {
      pvParam = pv;
      *((_DWORD *)v2 + 10) = v3;
      v4 = CreateFontIndirectW((const LOGFONTW *)&pvParam);
      if ( !v4 )
        v4 = (HFONT)v3;
      if ( v4 != (HFONT)v3 )
        *((_DWORD *)v2 + 12) = v3;
      *((_DWORD *)v2 + 11) = v4;
    }
  }
  return *((_DWORD *)v2 + 11) == *((_DWORD *)v2 + 10);
}

//----- (6F7DA624) --------------------------------------------------------
LRESULT __stdcall CNativeFont::_SubclassDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  LRESULT result; // eax@1
  void *v7; // ST08_4@7
  LPARAM lParama; // [sp+4h] [bp-8h]@5
  int v9; // [sp+8h] [bp-4h]@5

  result = 0;
  if ( dwRefData )
  {
    if ( uMsg == 2 )
    {
      if ( *(_DWORD *)(dwRefData + 48) )
      {
        lParama = *(_DWORD *)(dwRefData + 40);
        v9 = *(_DWORD *)(dwRefData + 12);
        EnumChildWindows(hWnd, CNativeFont::_SetFontEnumProc, (LPARAM)&lParama);
        DeleteObject(*(HGDIOBJ *)(dwRefData + 48));
        v7 = *(void **)(dwRefData + 44);
        *(_DWORD *)(dwRefData + 48) = 0;
        DeleteObject(v7);
        *(_DWORD *)(dwRefData + 44) = 0;
      }
      RemoveWindowSubclass(hWnd, CNativeFont::_SubclassDlgProc, 0);
    }
    else if ( uMsg == 272 && !CNativeFont::_GetNativeDialogFont((CNativeFont *)dwRefData, hWnd) )
    {
      lParama = *(_DWORD *)(dwRefData + 44);
      v9 = *(_DWORD *)(dwRefData + 12);
      EnumChildWindows(hWnd, CNativeFont::_SetFontEnumProc, (LPARAM)&lParama);
    }
    result = DefSubclassProc(hWnd, uMsg, wParam, lParam);
  }
  return result;
}

//----- (6F7DA6D8) --------------------------------------------------------
int __thiscall CNativeFont::v_WndProc(LONG dwNewLong, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  LONG v5; // esi@1
  HWND v6; // eax@2

  v5 = dwNewLong;
  if ( Msg == 1 )
  {
    v6 = GetParent(hWnd);
    if ( v6 )
      SetWindowSubclass(v6, CNativeFont::_SubclassDlgProc, 0, v5);
  }
  return CControl::v_WndProc(v5, hWnd, Msg, wParam, lParam);
}

//----- (6F7DA71E) --------------------------------------------------------
int __stdcall LoadFile(LPCWSTR lpFileName, unsigned __int32 *a2, void **a3, void **a4)
{
  HANDLE v4; // eax@1
  void *v5; // edi@1
  unsigned __int32 v7; // eax@3
  HANDLE v8; // eax@5
  void *v9; // ebx@5
  LPVOID lpFileNamea; // [sp+10h] [bp+8h]@7

  *a3 = 0;
  *a4 = 0;
  v4 = CreateFileW(lpFileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v5 = v4;
  if ( v4 == (HANDLE)-1 )
    return 0;
  v7 = GetFileSize(v4, 0);
  if ( a2 )
    *a2 = v7;
  v8 = CreateFileMappingW(v5, 0, 2u, 0, 0, 0);
  v9 = v8;
  if ( !v8 )
  {
    CloseHandle(v5);
    return 0;
  }
  lpFileNamea = MapViewOfFile(v8, 4u, 0, 0, 0);
  CloseHandle(v9);
  if ( !lpFileNamea )
  {
    CloseHandle(v5);
    return 0;
  }
  *a4 = v5;
  *a3 = lpFileNamea;
  return 1;
}

//----- (6F7DA7C2) --------------------------------------------------------
signed int __stdcall RleFile_Close(int a1)
{
  if ( *(_DWORD *)(a1 + 16) )
    DeleteObject(*(HGDIOBJ *)(a1 + 16));
  if ( *(_DWORD *)(a1 + 24) )
  {
    if ( *(_DWORD *)(a1 + 20) )
      FreeResource(*(HGLOBAL *)(a1 + 20));
    else
      UnmapViewOfFile(*(LPCVOID *)(a1 + 24));
  }
  if ( *(_DWORD *)(a1 + 1140) )
    CloseHandle(*(HANDLE *)(a1 + 1140));
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 1116) = 0;
  *(_DWORD *)(a1 + 1124) = 0;
  *(_DWORD *)(a1 + 1128) = 0;
  *(_DWORD *)(a1 + 1132) = 0;
  *(_DWORD *)(a1 + 1136) = 0;
  *(_DWORD *)(a1 + 1140) = 0;
  return 1;
}

//----- (6F7DA846) --------------------------------------------------------
bool __stdcall IsSafeFileAddress(struct _RLEFILE *a1, void *a2, unsigned int a3)
{
  int v3; // ecx@1
  bool result; // al@2
  unsigned int v5; // esi@3
  unsigned int v6; // eax@5

  v3 = *((_DWORD *)a1 + 286);
  if ( v3 )
  {
    v5 = a3;
    if ( !a3 )
      v5 = a3 + 1;
    v6 = *((_DWORD *)a1 + 6);
    result = (unsigned int)a2 >= v6 && (unsigned int)((char *)a2 + v5) <= v6 + v3;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (6F7DA888) --------------------------------------------------------
signed int __stdcall RleFile_ChangeColor(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // esi@1
  int v4; // edi@3
  signed int result; // eax@7

  v3 = 0;
  if ( a1 && *(_DWORD *)(a1 + 1128) )
  {
    v4 = *(_DWORD *)(a1 + 52) + a1 + 52;
    if ( *(_DWORD *)(a1 + 84) > 0 )
    {
      do
      {
        if ( *(_DWORD *)(v4 + 4 * v3) == ((unsigned __int8)(a2 >> 16) | ((((unsigned __int8)a2 << 8) | BYTE1(a2)) << 8)) )
          *(_DWORD *)(v4 + 4 * v3) = (unsigned __int8)(a3 >> 16) | ((((unsigned __int8)a3 << 8) | BYTE1(a3)) << 8);
        ++v3;
      }
      while ( v3 < *(_DWORD *)(a1 + 84) );
    }
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7DA908) --------------------------------------------------------
int __stdcall RleFile_Seek(struct _RLEFILE *a1, int a2)
{
  struct _RLEFILE *v2; // esi@1
  int v3; // eax@5
  int v5; // edi@12
  __int16 v6; // ax@14
  __int16 v7; // ax@15
  unsigned __int8 v8; // cl@17
  __int16 v9; // cx@18
  int v10; // edi@24
  void *v11; // ebx@24
  int v12; // eax@25
  bool v13; // zf@25
  struct _RLEFILE *v14; // [sp+14h] [bp+8h]@9

  v2 = a1;
  if ( a1 && *((_DWORD *)a1 + 283) && a2 < *(_DWORD *)a1 && a2 >= 0 )
  {
    v3 = *((_DWORD *)a1 + 7);
    if ( a2 == v3 )
      return 1;
    if ( v3 < 0 || v3 >= a2 )
    {
      v14 = (struct _RLEFILE *)-1;
      *((_DWORD *)v2 + 7) = -1;
      *((_DWORD *)v2 + 8) = 0;
    }
    else
    {
      v14 = (struct _RLEFILE *)*((_DWORD *)a1 + 9);
    }
    if ( *((_DWORD *)v2 + 7) >= a2 )
    {
LABEL_24:
      v10 = *((_DWORD *)v2 + 284) + 16 * (_DWORD)v14;
      v11 = (void *)(*(_DWORD *)(v10 + 8) + *((_DWORD *)v2 + 283) + 4);
      if ( IsSafeFileAddress(v2, v11, 1u) )
      {
        *((_DWORD *)v2 + 9) = v14;
        *((_DWORD *)v2 + 10) = v11;
        v12 = *(_DWORD *)(v10 + 12);
        v13 = v12 == *((_DWORD *)v2 + 12);
        *((_DWORD *)v2 + 11) = v12;
        *((_DWORD *)v2 + 18) = v12;
        *((_DWORD *)v2 + 17) = !v13;
        return 1;
      }
    }
    else
    {
      v5 = *((_DWORD *)v2 + 284) + 16 * (_DWORD)v14;
      while ( 1 )
      {
        v14 = (struct _RLEFILE *)((char *)v14 + 1);
        v5 += 16;
        if ( !IsSafeFileAddress(v2, (void *)v5, 0x10u) )
          break;
        v6 = *(_BYTE *)v5;
        if ( *(_BYTE *)v5 < 0x41u )
          v7 = v6 - 48;
        else
          v7 = v6 - 55;
        v8 = *(_BYTE *)(v5 + 1);
        if ( v8 < 0x41u )
          v9 = v8 - 48;
        else
          v9 = v8 - 55;
        if ( (unsigned __int16)(v9 + 16 * v7) == *((_DWORD *)v2 + 280) )
        {
          ++*((_DWORD *)v2 + 7);
          if ( *(_BYTE *)(v5 + 4) & 0x10 )
            *((_DWORD *)v2 + 8) = *((_DWORD *)v2 + 7);
        }
        if ( *((_DWORD *)v2 + 7) >= a2 )
          goto LABEL_24;
      }
    }
  }
  return 0;
}

//----- (6F7DAA31) --------------------------------------------------------
int __stdcall RleFile_Draw(struct _RLEFILE *a1, HDC hdc, int a3, int xDest, int yDest)
{
  HPALETTE v5; // eax@3
  int v6; // ebx@5
  int result; // eax@8

  if ( a1 && *((_DWORD *)a1 + 283) )
  {
    v5 = (HPALETTE)*((_DWORD *)a1 + 4);
    if ( v5 )
    {
      SelectPalette(hdc, v5, 0);
      RealizePalette(hdc);
    }
    v6 = RleFile_Seek(a1, a3);
    if ( v6 )
    {
      if ( *((_DWORD *)a1 + 11) > 0u )
        StretchDIBits(
          hdc,
          xDest,
          yDest,
          *((_DWORD *)a1 + 1),
          *((_DWORD *)a1 + 2),
          0,
          0,
          *((_DWORD *)a1 + 1),
          *((_DWORD *)a1 + 2),
          *((const void **)a1 + 10),
          (const BITMAPINFO *)((char *)a1 + 52),
          0,
          0xCC0020u);
    }
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7DAAB3) --------------------------------------------------------
int __stdcall RleFile_Init(struct _RLEFILE *a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  unsigned int v6; // eax@4
  int v7; // esi@4
  int v8; // edx@8
  int v9; // eax@11
  int v10; // esi@11
  int v11; // ebx@11
  int v12; // esi@11
  int v13; // eax@28
  int v14; // eax@32
  int v15; // eax@36
  int v16; // ecx@38
  int v17; // eax@38
  struct _RLEFILE *v18; // [sp+10h] [bp+8h]@9
  int v19; // [sp+14h] [bp+Ch]@8

  v4 = (int)a1;
  if ( *((_DWORD *)a1 + 6) == a2 )
    return 1;
  RleFile_Close((int)a1);
  *((_DWORD *)a1 + 6) = a2;
  *((_DWORD *)a1 + 5) = a3;
  *((_DWORD *)a1 + 286) = a4;
  if ( !a2 )
    return 0;
  v6 = *(_DWORD *)(a2 + 4);
  v7 = a2 + 12;
  if ( a4 && v6 > a4 || *(_DWORD *)a2 != 1179011410 || *(_DWORD *)(a2 + 8) != 541677121 )
    goto LABEL_19;
  v8 = v6 + v7 - 4;
  v19 = v8;
  if ( v7 < (unsigned int)v8 )
  {
    v18 = (struct _RLEFILE *)-1;
    do
    {
      if ( v7 > (unsigned int)(v7 + 8) )
      {
        v7 = v8;
      }
      else
      {
        v9 = *(_DWORD *)v7;
        v10 = v7 + 4;
        v11 = *(_DWORD *)v10;
        v12 = v10 + 4;
        switch ( v9 )
        {
          case 829973609:
            *(_DWORD *)(v4 + 1136) = v12;
            break;
          case 1414744396:
            if ( v12 > (unsigned int)(v12 + 4) )
            {
              v12 = v8;
            }
            else
            {
              v17 = *(_DWORD *)v12;
              v11 -= 4;
              v16 = v12 + 4;
              v12 += 4;
              if ( v17 == 1769369453 )
              {
                *(_DWORD *)(v4 + 1132) = v16;
              }
              else if ( v17 == 1819436136 || v17 == 1819440243 )
              {
                v11 = 0;
              }
            }
            break;
          case 1718776947:
            if ( !*(_DWORD *)(v4 + 1128) && *(_DWORD *)(v4 + 1124) )
            {
              *(_DWORD *)(v4 + 1128) = v12;
              if ( *(_DWORD *)v12 != 40 )
                goto LABEL_19;
              v13 = *(_DWORD *)(v12 + 16);
              if ( v13 )
              {
                if ( v13 != 1 )
                  goto LABEL_19;
              }
              if ( *(_DWORD *)(v12 + 4) != *(_DWORD *)(v4 + 4) || *(_DWORD *)(v12 + 8) != *(_DWORD *)(v4 + 8) )
                goto LABEL_19;
              v14 = (v8 - v12) >> 2;
              if ( (unsigned int)v14 > 0x428 )
                v14 = 1064;
              if ( v11 < (unsigned int)v14 )
                v14 = v11;
              memmove((void *)(v4 + 52), (const void *)v12, v14);
              v15 = *(_DWORD *)(v4 + 56) * *(_WORD *)(v4 + 66);
              *(_DWORD *)(v4 + 72) = 0;
              *(_DWORD *)(v4 + 48) = *(_DWORD *)(v4 + 60) * (((unsigned int)(v15 + 31) >> 3) & 0x1FFFFFFC);
            }
            break;
          case 1751742049:
            *(_DWORD *)(v4 + 1116) = v12;
            *(_DWORD *)v4 = *(_DWORD *)(v12 + 16);
            *(_DWORD *)(v4 + 4) = *(_DWORD *)(v12 + 32);
            *(_DWORD *)(v4 + 8) = *(_DWORD *)(v12 + 36);
            *(_DWORD *)(v4 + 12) = *(_DWORD *)v12 / 0x3E8u;
            if ( *(_DWORD *)(v12 + 20) || *(_DWORD *)(v12 + 24) > 2u )
              goto LABEL_19;
            break;
          case 1752331379:
            v18 = (struct _RLEFILE *)((char *)v18 + 1);
            if ( !*(_DWORD *)(v4 + 1124) && *(_DWORD *)v12 == 1935960438 )
            {
              *(_DWORD *)(v4 + 1120) = v18;
              *(_DWORD *)(v4 + 1124) = v12;
              if ( *(_DWORD *)(v12 + 8) & 0x10000 )
                goto LABEL_19;
            }
            break;
        }
        if ( v12 > v12 + ((v11 + 1) & 0xFFFFFFFE) )
          v7 = v19;
        else
          v7 = ((v11 + 1) & 0xFFFFFFFE) + v12;
      }
      v8 = v19;
    }
    while ( v7 < (unsigned int)v19 );
  }
  if ( !*(_DWORD *)v4
    || !*(_DWORD *)(v4 + 1116)
    || !*(_DWORD *)(v4 + 1124)
    || !*(_DWORD *)(v4 + 1128)
    || !*(_DWORD *)(v4 + 1132) )
  {
LABEL_19:
    RleFile_Close(v4);
    return 0;
  }
  *(_DWORD *)(v4 + 28) = -42;
  RleFile_Seek((struct _RLEFILE *)v4, 0);
  return 1;
}

//----- (6F7DAD36) --------------------------------------------------------
int __stdcall RleFile_Paint(struct _RLEFILE *a1, HDC hdc, int a3, int xDest, int yDest)
{
  struct _RLEFILE *v5; // esi@1
  int v6; // ebx@4
  int i; // edi@4
  int result; // eax@7
  int v9; // [sp+Ch] [bp+8h]@3

  v5 = a1;
  if ( a1 && *((_DWORD *)a1 + 283) )
  {
    v9 = RleFile_Seek(a1, a3);
    if ( v9 )
    {
      v6 = *((_DWORD *)v5 + 7);
      for ( i = *((_DWORD *)v5 + 8); i <= v6; ++i )
        RleFile_Draw(v5, hdc, i, xDest, yDest);
    }
    result = v9;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7DAD8E) --------------------------------------------------------
int __stdcall RleFile_OpenFromFile(struct _RLEFILE *a1, LPCWSTR lpFileName)
{
  int v2; // ST0C_4@3
  int v3; // ST04_4@3
  int result; // eax@3
  void *v5; // [sp+0h] [bp-8h]@2
  unsigned __int32 v6; // [sp+4h] [bp-4h]@2

  if ( (unsigned int)lpFileName & 0xFFFF0000 && LoadFile(lpFileName, &v6, &v5, (void **)&lpFileName) )
  {
    v2 = v6;
    v3 = (int)v5;
    *((_DWORD *)a1 + 285) = lpFileName;
    result = RleFile_Init(a1, v3, 0, v2);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7DADDD) --------------------------------------------------------
int __stdcall RleFile_OpenFromResource(struct _RLEFILE *a1, HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
{
  HRSRC v4; // eax@3
  HGLOBAL v5; // eax@4
  int v6; // ST08_4@5
  int v7; // eax@5
  int result; // eax@5

  if ( (!((unsigned int)lpName & 0xFFFF0000) || *lpName)
    && (v4 = FindResourceW(hModule, lpName, lpType)) != 0
    && (v5 = LoadResource(hModule, v4)) != 0 )
  {
    v6 = (int)v5;
    v7 = (int)LockResource(v5);
    result = RleFile_Init(a1, v7, v6, 0);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (6F7DAE31) --------------------------------------------------------
int __thiscall CLVRange::_FindValue(CLVRange *this, __int32 a2, __int32 *a3)
{
  int v3; // edi@1
  int v4; // ecx@1
  int v5; // ebx@1
  signed int v6; // edi@1
  __int32 v7; // esi@1
  signed int v9; // [sp+Ch] [bp-4h]@1

  v3 = *((_DWORD *)this + 4);
  v4 = *((_DWORD *)this + 2);
  v5 = 0;
  v6 = v3 - 1;
  v9 = 0;
  v7 = v6 / 2;
  while ( 1 )
  {
    while ( *(_DWORD *)(v4 + 8 * v7) > a2 )
    {
      v6 = v7;
      v7 = v5 + (v7 - v5) / 2;
      if ( v7 == v6 )
      {
        v7 = v5;
        goto LABEL_5;
      }
    }
    if ( *(_DWORD *)(v4 + 8 * v7 + 4) >= a2 )
      break;
    v5 = v7;
    v7 += (v6 - v7) / 2;
    if ( v7 == v5 )
      goto LABEL_5;
  }
  v9 = 1;
LABEL_5:
  *a3 = v7;
  return v9;
}

//----- (6F7DAEA2) --------------------------------------------------------
void __thiscall CLVRange::_InitNew(CLVRange *this)
{
  int v1; // edx@1

  v1 = *((_DWORD *)this + 2);
  *((_DWORD *)this + 3) = 6;
  *((_DWORD *)this + 4) = 2;
  *(_DWORD *)v1 = 2147483648;
  *(_DWORD *)(*((_DWORD *)this + 2) + 4) = -2;
  *(_DWORD *)(*((_DWORD *)this + 2) + 8) = 0x7FFFFFFF;
  *(_DWORD *)(*((_DWORD *)this + 2) + 12) = 0x7FFFFFFF;
  *((_DWORD *)this + 5) = 0;
}

//----- (6F7DAEDF) --------------------------------------------------------
HGLOBAL __thiscall CLVRange::~CLVRange(CLVRange *this)
{
  void *v1; // ecx@1
  HGLOBAL result; // eax@2

  *(_DWORD *)this = &CLVRange::`vftable';
  v1 = (void *)*((_DWORD *)this + 2);
  if ( v1 )
    result = GlobalFree(v1);
  return result;
}
// 6F792A20: using guessed type __int32 (__stdcall *CLVRange::`vftable')(CLVRange *this, const struct _GUID *, void **);

//----- (6F7DAEF9) --------------------------------------------------------
signed int __stdcall CLVRange::QueryInterface(CLVRange *this, const struct _GUID *a2, void **a3)
{
  signed int result; // eax@3

  if ( !memcmp(a2, &IID_ILVRange, 0x10u) || !memcmp(a2, &IID_IUnknown, 0x10u) )
  {
    *a3 = (void *)this;
    ++*((_DWORD *)this + 1);
    result = 0;
  }
  else
  {
    *a3 = 0;
    result = -2147467262;
  }
  return result;
}

//----- (6F7DAF59) --------------------------------------------------------
unsigned __int32 __stdcall CDragProxy::AddRef(CDragProxy *this)
{
  ++*((_DWORD *)this + 1);
  return *((_DWORD *)this + 1);
}

//----- (6F7DAF70) --------------------------------------------------------
signed int __stdcall CLVRange::Clear(CLVRange *this)
{
  signed int v1; // ebx@1
  HGLOBAL v2; // edi@1

  v1 = 0;
  v2 = GlobalAlloc(0x40u, 0x30u);
  if ( v2 )
  {
    GlobalFree(*((HGLOBAL *)this + 2));
    *((_DWORD *)this + 2) = v2;
    CLVRange::_InitNew(this);
  }
  else
  {
    v1 = -2147467259;
  }
  return v1;
}

//----- (6F7DAFB5) --------------------------------------------------------
BOOL __stdcall CLVRange::IsSelected(CLVRange *this, __int32 a2)
{
  return CLVRange::_FindValue(this, a2, &a2) == 0;
}

//----- (6F7DAFD7) --------------------------------------------------------
BOOL __stdcall CLVRange::IsEmpty(CLVRange *this)
{
  return *((_DWORD *)this + 4) != 2;
}

//----- (6F7DAFF1) --------------------------------------------------------
__int32 __stdcall CLVRange::CountIncluded(CLVRange *this, __int32 *a2)
{
  *a2 = *((_DWORD *)this + 5);
  return 0;
}

//----- (6F7DB00C) --------------------------------------------------------
__int32 __stdcall CLVRange::NextSelected(CLVRange *this, __int32 a2, __int32 *a3)
{
  signed int v3; // edi@1
  __int32 v4; // eax@2

  v3 = a2;
  if ( !CLVRange::_FindValue(this, a2, &a2) )
  {
    v4 = a2 + 1;
    if ( a2 + 1 < 0 || v4 >= *((_DWORD *)this + 4) - 1 )
      v3 = -1;
    else
      v3 = *(_DWORD *)(*((_DWORD *)this + 2) + 8 * v4);
  }
  *a3 = v3;
  return 0;
}

//----- (6F7DB054) --------------------------------------------------------
__int32 __stdcall CLVRange::NextUnSelected(CLVRange *this, __int32 a2, __int32 *a3)
{
  int v3; // esi@1

  v3 = a2;
  if ( CLVRange::_FindValue(this, a2, &a2) )
  {
    if ( a2 < 0
      || a2 >= *((_DWORD *)this + 4) - 1
      || (v3 = *(_DWORD *)(*((_DWORD *)this + 2) + 8 * a2 + 4) + 1, v3 > 2147483645) )
      v3 = -1;
  }
  *a3 = v3;
  return 0;
}

//----- (6F7DB0A5) --------------------------------------------------------
int __stdcall CLVRange::InvertRange(CLVRange *this, __int32 a2, __int32 a3)
{
  __int32 v3; // ebx@1
  CLVRange *v4; // edi@1
  int v5; // eax@1
  __int32 v6; // ecx@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ebx@2
  int v10; // eax@10
  int result; // eax@11

  v3 = a2;
  v4 = this;
  v5 = CLVRange::_FindValue(this, a2, (__int32 *)&this);
  v6 = v3 - 1;
  v7 = v5 == 0;
  a2 = v3 - 1;
  do
  {
    v8 = *(_DWORD *)v4;
    v9 = v6 + 1;
    if ( v7 )
      (*(void (__stdcall **)(CLVRange *, int, __int32 *))(v8 + 44))(v4, v9, &a2);
    else
      (*(void (__stdcall **)(CLVRange *, int, __int32 *))(v8 + 48))(v4, v9, &a2);
    if ( a2 == -1 )
      a2 = 2147483645;
    else
      --a2;
    if ( a2 >= a3 )
      a2 = a3;
    v10 = *(_DWORD *)v4;
    if ( v7 )
      result = (*(int (__stdcall **)(CLVRange *, int, __int32))(v10 + 12))(v4, v9, a2);
    else
      result = (*(int (__stdcall **)(CLVRange *, int, __int32))(v10 + 16))(v4, v9, a2);
    if ( result < 0 )
      break;
    v7 = v7 == 0;
    v6 = a2;
  }
  while ( a2 < a3 );
  return result;
}

//----- (6F7DB134) --------------------------------------------------------
int __thiscall CLVRange::_Enlarge(CLVRange *this)
{
  CLVRange *v1; // esi@1
  signed int v2; // ebx@1
  int v3; // edi@1
  HGLOBAL v4; // eax@2
  SIZE_T dwBytes; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v2 = 0;
  v3 = 150 * *((_DWORD *)this + 3) / 100;
  if ( ULongLongToULong(8i64 * (unsigned int)v3, &dwBytes) >= 0 )
  {
    v4 = GlobalReAlloc(*((HGLOBAL *)v1 + 2), dwBytes, 0x42u);
    if ( v4 )
    {
      *((_DWORD *)v1 + 2) = v4;
      *((_DWORD *)v1 + 3) = v3;
      v2 = 1;
    }
  }
  return v2;
}

//----- (6F7DB18D) --------------------------------------------------------
int __thiscall CLVRange::_Shrink(CLVRange *this)
{
  CLVRange *v1; // esi@1
  int v2; // edi@1
  signed __int64 v3; // rax@1
  signed int v4; // ebx@1
  HGLOBAL v5; // eax@4
  SIZE_T dwBytes; // [sp+Ch] [bp-8h]@3
  int v8; // [sp+10h] [bp-4h]@1

  v1 = this;
  v2 = *((_DWORD *)this + 3);
  v3 = 100 * *((_DWORD *)this + 3);
  v8 = 1;
  v4 = v3 / 150;
  if ( *((_DWORD *)this + 4) < 90 * v2 / 150 && v4 >= 6 )
  {
    if ( ULongLongToULong(8i64 * (unsigned int)v4, &dwBytes) >= 0
      && (v5 = GlobalReAlloc(*((HGLOBAL *)v1 + 2), dwBytes, 0x42u)) != 0 )
    {
      *((_DWORD *)v1 + 2) = v5;
      *((_DWORD *)v1 + 3) = v4;
    }
    else
    {
      v8 = 0;
    }
  }
  return v8;
}

//----- (6F7DB207) --------------------------------------------------------
int __thiscall CLVRange::_InsertRange(CLVRange *this, __int32 a2, __int32 a3, __int32 a4)
{
  __int32 v4; // esi@1
  int v5; // edx@2
  int v6; // eax@3
  __int32 v7; // edx@4
  int v9; // [sp+Ch] [bp-4h]@1

  v4 = *((_DWORD *)this + 4);
  v9 = 1;
  while ( 1 )
  {
    v6 = *((_DWORD *)this + 2);
    if ( v4 <= a2 + 1 )
      break;
    v5 = v6 + 8 * v4;
    *(_DWORD *)v5 = *(_DWORD *)(v5 - 8);
    *(_DWORD *)(v5 + 4) = *(_DWORD *)(v5 - 4);
    --v4;
  }
  ++*((_DWORD *)this + 4);
  v7 = 8 * a2;
  *(_DWORD *)(v6 + v7 + 8) = a3;
  *(_DWORD *)(*((_DWORD *)this + 2) + v7 + 12) = a4;
  if ( *((_DWORD *)this + 4) == *((_DWORD *)this + 3) )
    v9 = CLVRange::_Enlarge(this);
  return v9;
}

//----- (6F7DB270) --------------------------------------------------------
signed int __thiscall CLVRange::_RemoveRanges(CLVRange *this, __int32 a2, __int32 a3, __int32 *a4)
{
  __int32 v4; // esi@1
  __int32 v5; // ebx@1
  __int32 v6; // edi@1
  __int32 v7; // eax@2
  int v8; // edx@3
  bool v9; // zf@3
  __int32 v10; // edx@5
  int v11; // esi@6
  int v12; // eax@7
  signed int v14; // [sp+Ch] [bp-8h]@1
  __int32 v15; // [sp+10h] [bp-4h]@1
  __int32 v16; // [sp+1Ch] [bp+8h]@2

  v4 = a2;
  v5 = 0;
  v6 = a3 - a2 + 1;
  v15 = 0;
  v14 = 0;
  if ( a2 <= a3 )
  {
    v7 = *((_DWORD *)this + 2) + 8 * a2;
    v16 = a3 - a2 + 1;
    do
    {
      v8 = *(_DWORD *)(v7 + 4) - *(_DWORD *)v7;
      v7 += 8;
      v9 = v16-- == 1;
      v5 += v8 + 1;
    }
    while ( !v9 );
    v15 = v5;
  }
  v10 = a3 + 1;
  if ( a3 + 1 < *((_DWORD *)this + 4) )
  {
    v11 = 8 * v4;
    do
    {
      v12 = *((_DWORD *)this + 2);
      *(_DWORD *)(v11 + v12) = *(_DWORD *)(v12 + 8 * v10);
      *(_DWORD *)(v11 + v12 + 4) = *(_DWORD *)(v12 + 8 * v10++ + 4);
      v11 += 8;
    }
    while ( v10 < *((_DWORD *)this + 4) );
    v5 = v15;
  }
  *((_DWORD *)this + 4) -= v6;
  if ( CLVRange::_Shrink(this) )
  {
    if ( a4 )
      *a4 = v5;
  }
  else
  {
    v14 = -2147467259;
  }
  return v14;
}

//----- (6F7DB303) --------------------------------------------------------
void *__thiscall CLVRange::`scalar deleting destructor'(void *lpMem, char a2)
{
  void *v2; // esi@1

  v2 = lpMem;
  CLVRange::~CLVRange((CLVRange *)lpMem);
  if ( a2 & 1 )
    operator delete(v2);
  return v2;
}

//----- (6F7DB329) --------------------------------------------------------
unsigned __int32 __stdcall CLVRange::Release(CLVRange *this)
{
  bool v1; // zf@1
  unsigned __int32 result; // eax@1

  v1 = (*((_DWORD *)this + 1))-- == 1;
  result = *((_DWORD *)this + 1);
  if ( v1 )
  {
    CLVRange::`scalar deleting destructor'((void *)this, 1);
    result = 0;
  }
  return result;
}

//----- (6F7DB34B) --------------------------------------------------------
signed int __stdcall CLVRange::IncludeRange(CLVRange *this, __int32 a2, __int32 a3)
{
  __int32 v3; // ebx@1
  CLVRange *v4; // esi@1
  int v5; // eax@1
  __int32 v6; // edx@1
  int v7; // ecx@1
  __int32 v8; // edi@1
  __int32 v9; // ebx@3
  bool v10; // zf@5
  CLVRange *v11; // eax@5
  __int32 v12; // ebx@6
  int v13; // ecx@7
  signed int result; // eax@11
  __int32 v15; // eax@12
  int v16; // edi@15
  int v17; // ecx@15
  __int32 v18; // eax@15
  int v19; // eax@19
  int v20; // ecx@19
  int v21; // eax@19
  int v22; // [sp+Ch] [bp-14h]@1
  signed int v23; // [sp+Ch] [bp-14h]@3
  __int32 v24; // [sp+10h] [bp-10h]@1
  int v25; // [sp+14h] [bp-Ch]@1
  __int32 v26; // [sp+18h] [bp-8h]@5
  __int32 v27; // [sp+1Ch] [bp-4h]@1

  v27 = 0;
  v25 = 0;
  v3 = a2;
  v4 = this;
  v22 = CLVRange::_FindValue(this, a2, &v24);
  v5 = CLVRange::_FindValue(v4, a3, (__int32 *)&this);
  v6 = v24;
  v7 = *((_DWORD *)v4 + 2);
  v8 = 8 * v24;
  if ( *(_DWORD *)(v7 + 8 * v24 + 4) == v3 - 1 || v22 )
  {
    v23 = 1;
    v9 = v24 + 1;
  }
  else
  {
    v23 = 0;
    v9 = v24 + 2;
  }
  v10 = v5 == 0;
  v11 = this;
  v26 = v9;
  if ( v10 )
  {
    v13 = v7 + 8 * (_DWORD)this;
    if ( *(_DWORD *)(v13 + 8) == a3 + 1 )
    {
      v12 = *(_DWORD *)(v13 + 12);
      v11 = (CLVRange *)((char *)this + 1);
    }
    else
    {
      v12 = a3;
    }
  }
  else
  {
    v12 = *(_DWORD *)(v7 + 8 * (_DWORD)this + 4);
  }
  this = v11;
  if ( v26 > (signed int)v11 )
  {
    v15 = v27;
  }
  else
  {
    result = CLVRange::_RemoveRanges(v4, v26, (__int32)this, &v27);
    v25 = result;
    if ( result < 0 )
      return result;
    v6 = v24;
    v15 = -v27;
    v27 = -v27;
  }
  if ( v23 )
  {
    v16 = *((_DWORD *)v4 + 2) + v8 + 4;
    v17 = v12 - *(_DWORD *)v16;
    *(_DWORD *)v16 = v12;
    v18 = v17 + v15;
  }
  else if ( v26 <= (signed int)((char *)this + 1) )
  {
    v19 = v8 + *((_DWORD *)v4 + 2);
    v20 = *(_DWORD *)(v19 + 8) - *(_DWORD *)(v19 + 12);
    *(_DWORD *)(v19 + 12) = v12;
    v21 = *((_DWORD *)v4 + 2);
    v27 += v12 + v20 - a2;
    *(_DWORD *)(v21 + v8 + 8) = a2;
    v18 = v27;
  }
  else
  {
    v27 = v15 + a3 - a2 + 1;
    v10 = CLVRange::_InsertRange(v4, v6, a2, v12) == 0;
    v18 = v27;
    if ( v10 )
      v25 = -2147467259;
  }
  *((_DWORD *)v4 + 5) += v18;
  return v25;
}

//----- (6F7DB484) --------------------------------------------------------
__int32 __stdcall CLVRange::ExcludeRange(CLVRange *this, __int32 a2, __int32 a3)
{
  CLVRange *v3; // esi@1
  __int32 v4; // edi@1
  int v5; // eax@1
  CLVRange *v6; // ebx@1
  __int32 result; // eax@1
  int v8; // eax@2
  int v9; // ebx@2
  __int32 v10; // eax@7
  int v11; // eax@13
  int v12; // edx@13
  int v13; // edi@13
  __int32 v14; // [sp+Ch] [bp-1Ch]@2
  int v15; // [sp+10h] [bp-18h]@1
  __int32 v16; // [sp+14h] [bp-14h]@1
  int v17; // [sp+18h] [bp-10h]@1
  int v18; // [sp+1Ch] [bp-Ch]@1
  __int32 v19; // [sp+20h] [bp-8h]@2
  ULONG pulResult; // [sp+24h] [bp-4h]@1

  v3 = this;
  v4 = 0;
  v17 = CLVRange::_FindValue(this, a2, (__int32 *)&this);
  v5 = CLVRange::_FindValue(v3, a3, &v16);
  v6 = this;
  v15 = v5;
  result = ULongAdd((ULONG)this, 1u, &pulResult);
  v18 = result;
  if ( result >= 0 )
  {
    v8 = *((_DWORD *)v3 + 2);
    v9 = 8 * (_DWORD)v6;
    v14 = *(_DWORD *)(v8 + v9 + 4);
    v19 = *(_DWORD *)(v8 + v9 + 4);
    if ( v17 )
    {
      if ( *(_DWORD *)(v8 + v9) == a2 )
        pulResult = (ULONG)this;
      else
        v19 = a2 - 1;
    }
    a2 = v16;
    if ( v15 )
    {
      v10 = v8 + 8 * v16;
      if ( *(_DWORD *)(v10 + 4) != a3 )
      {
        if ( this == (CLVRange *)v16 )
        {
          if ( !CLVRange::_InsertRange(v3, (__int32)this, a3 + 1, v14) )
            return -2147467259;
          v4 = a3 - *(_DWORD *)(*((_DWORD *)v3 + 2) + v9 + 4);
        }
        else
        {
          v4 = a3 - *(_DWORD *)v10 + 1;
          a2 = v16 - 1;
          *(_DWORD *)v10 = a3 + 1;
        }
      }
    }
    v11 = *((_DWORD *)v3 + 2) + v9 + 4;
    v12 = *(_DWORD *)v11 - v19;
    *(_DWORD *)v11 = v19;
    v13 = v12 + v4;
    if ( (signed int)pulResult <= a2 )
    {
      v18 = CLVRange::_RemoveRanges(v3, pulResult, a2, &a3);
      if ( v18 >= 0 )
        v13 += a3;
    }
    *((_DWORD *)v3 + 5) -= v13;
    result = v18;
  }
  return result;
}

//----- (6F7DB58B) --------------------------------------------------------
signed int __stdcall CLVRange::InsertItem(CLVRange *this, __int32 a2)
{
  __int32 v2; // edi@1
  __int32 v3; // ebx@2
  __int32 v4; // eax@2
  __int32 i; // ecx@7
  int v7; // eax@8
  int v8; // edx@8
  int v9; // eax@8
  int v10; // edx@8
  int v11; // eax@10

  v2 = a2;
  if ( CLVRange::_FindValue(this, a2, &a2) )
  {
    v3 = 8 * a2;
    v4 = 8 * a2 + *((_DWORD *)this + 2);
    if ( *(_DWORD *)v4 == v2 )
    {
      --a2;
    }
    else
    {
      if ( !CLVRange::_InsertRange(this, a2, v2, *(_DWORD *)(v4 + 4)) )
        return -2147467259;
      *(_DWORD *)(*((_DWORD *)this + 2) + v3 + 4) = v2 - 1;
    }
  }
  for ( i = *((_DWORD *)this + 4) - 2; i > a2; --i )
  {
    v7 = *((_DWORD *)this + 2) + 8 * i;
    v8 = *(_DWORD *)v7;
    v9 = *(_DWORD *)(v7 + 4);
    v10 = v8 + 1;
    if ( v10 > 2147483645 )
      v10 = 2147483645;
    v11 = v9 + 1;
    if ( v11 > 2147483645 )
      v11 = 2147483645;
    *(_DWORD *)(*((_DWORD *)this + 2) + 8 * i) = v10;
    *(_DWORD *)(*((_DWORD *)this + 2) + 8 * i + 4) = v11;
  }
  return 0;
}

//----- (6F7DB627) --------------------------------------------------------
signed int __stdcall CLVRange::RemoveItem(CLVRange *this, __int32 a2)
{
  CLVRange *v2; // esi@1
  int v3; // eax@1
  CLVRange *v4; // ebx@1
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // eax@6
  signed int result; // eax@8
  int v9; // ecx@9
  int v10; // eax@10
  int v11; // edx@10
  int v12; // ebx@12
  signed int v13; // [sp+Ch] [bp-4h]@1

  v13 = 0;
  v2 = this;
  v3 = CLVRange::_FindValue(this, a2, (__int32 *)&this);
  v4 = this;
  if ( v3 )
  {
    v5 = *((_DWORD *)v2 + 2) + 8 * (_DWORD)this + 4;
    v6 = *(_DWORD *)v5 - 1;
    if ( v6 > 2147483645 )
      v6 = 2147483645;
    *(_DWORD *)v5 = v6;
    --*((_DWORD *)v2 + 5);
  }
  else if ( (signed int)this < *((_DWORD *)v2 + 4) - 1 )
  {
    v7 = *((_DWORD *)v2 + 2) + 8 * (_DWORD)this;
    if ( *(_DWORD *)(v7 + 4) == a2 - 1 && *(_DWORD *)(v7 + 8) == a2 + 1 )
    {
      *(_DWORD *)(v7 + 4) = *(_DWORD *)(v7 + 12) - 1;
      result = CLVRange::_RemoveRanges(v2, (__int32)((char *)v4 + 1), (__int32)((char *)v4 + 1), 0);
      v13 = result;
      if ( result < 0 )
        return result;
    }
  }
  v9 = *((_DWORD *)v2 + 4) - 2;
  if ( v9 > (signed int)v4 )
  {
    do
    {
      v10 = *((_DWORD *)v2 + 2) + 8 * v9;
      v11 = *(_DWORD *)v10 - 1;
      if ( v11 > 2147483645 )
        v11 = 2147483645;
      v12 = *(_DWORD *)(v10 + 4) - 1;
      if ( v12 > 2147483645 )
        v12 = 2147483645;
      *(_DWORD *)v10 = v11;
      *(_DWORD *)(*((_DWORD *)v2 + 2) + 8 * v9-- + 4) = v12;
    }
    while ( v9 > (signed int)this );
  }
  return v13;
}

//----- (6F7DB6E3) --------------------------------------------------------
void *__stdcall LVRange_Create()
{
  void *v0; // eax@1
  void *v1; // esi@2
  HGLOBAL v2; // eax@5

  v0 = operator new(0x18u);
  if ( v0 )
  {
    *(_DWORD *)v0 = &CLVRange::`vftable';
    *((_DWORD *)v0 + 1) = 1;
    v1 = v0;
  }
  else
  {
    v1 = 0;
  }
  if ( v1 )
  {
    v2 = GlobalAlloc(0x40u, 0x30u);
    *((_DWORD *)v1 + 2) = v2;
    if ( v2 )
    {
      CLVRange::_InitNew((CLVRange *)v1);
    }
    else
    {
      CLVRange::`scalar deleting destructor'(v1, 1);
      v1 = 0;
    }
  }
  return v1;
}
// 6F792A20: using guessed type __int32 (__stdcall *CLVRange::`vftable')(CLVRange *this, const struct _GUID *, void **);

//----- (6F7DB735) --------------------------------------------------------
bool __usercall sub_6F7DB735@<al>(unsigned int a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<ebx>, unsigned int a4@<edi>)
{
  int v4; // esi@1
  int v5; // edx@1

  v4 = a3 + a2;
  v5 = a1 + a4;
  return a2 >= a1 && a2 <= v5 && v4 >= a1 && v4 <= (unsigned int)v5 && a1 <= v5 && a2 <= v4 && a3 <= a4;
}

//----- (6F7DB767) --------------------------------------------------------
int __usercall sub_6F7DB767@<eax>(unsigned int a1@<edx>, unsigned int a2@<ecx>, unsigned int a3@<ebx>)
{
  int result; // eax@1
  int v4; // ecx@7
  unsigned int i; // edx@7

  result = 0;
  if ( a1 >= 2 && a3 && a2 && !(a3 & 1) && a3 >= a2 && a2 + a1 >= a2 )
  {
    v4 = a1 + a2 - (a1 & 1);
    for ( i = a3; i < v4; i += 2 )
    {
      if ( !*(_WORD *)i )
        break;
    }
    if ( i != v4 )
      result = (signed int)(i - a3) >> 1;
  }
  return result;
}

//----- (6F7DB7B2) --------------------------------------------------------
unsigned int __usercall sub_6F7DB7B2@<eax>(int a1@<eax>, unsigned int a2@<ecx>, unsigned int a3@<esi>)
{
  unsigned int v3; // ebx@1
  unsigned int v4; // edi@3
  int v6; // [sp+4h] [bp-4h]@3

  v3 = *(_WORD *)(a1 + 2);
  if ( *(_WORD *)(a1 + 4) && *(_WORD *)(a1 + 2) )
  {
    v6 = 0;
    v4 = *(_WORD *)a3;
    do
    {
      if ( !(v3 & 1) )
      {
        if ( !sub_6F7DB735(a3, a2, v3, v4) )
          break;
        if ( !*(_WORD *)(a2 + 2 * (v3 >> 1) - 2) )
          return v3;
      }
      v3 *= 2;
      ++v6;
    }
    while ( v6 != 2 );
    v3 = 0;
  }
  return v3;
}

//----- (6F7DB804) --------------------------------------------------------
unsigned int __stdcall sub_6F7DB804(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@2
  int v5; // eax@2
  unsigned int v6; // eax@3
  int v7; // ecx@3
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v9 = *(_WORD *)a1;
  v2 = 0;
  if ( sub_6F7DB735(a1, a2, 8u, v9) )
  {
    v4 = v3;
    v5 = sub_6F7DB767(v9, a1, v3 + 6);
    if ( v5 )
    {
      v6 = sub_6F7DB7B2(v4, (v4 + 2 * v5 + 11) & 0xFFFFFFFC, a1);
      v2 = (v6 + v7 + 3) & 0xFFFFFFFC;
      if ( !sub_6F7DB735(a1, v2, 8u, v9) )
        v2 = 0;
    }
  }
  return v2;
}

//----- (6F7DB877) --------------------------------------------------------
unsigned int __stdcall sub_6F7DB877(unsigned int a1, unsigned int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@1
  int v4; // ecx@1
  bool v5; // zf@2
  unsigned int v6; // ecx@2

  v2 = *(_WORD *)a1;
  v3 = 0;
  if ( sub_6F7DB735(a1, a2, 8u, v2) )
  {
    v3 = (v4 + *(_WORD *)v4 + 3) & 0xFFFFFFFC;
    v5 = v4 == a1;
    v6 = (v4 + *(_WORD *)v4 + 3) & 0xFFFFFFFC;
    if ( !v5 )
    {
      if ( sub_6F7DB735(a1, v6, 8u, v2) )
        return v3;
      return 0;
    }
    if ( sub_6F7DB735(a1, v6, 8u, v2) )
      return 0;
  }
  return v3;
}

//----- (6F7DB8D2) --------------------------------------------------------
unsigned int __userpurge sub_6F7DB8D2@<eax>(unsigned int a1@<edi>, int a2, wchar_t *Str1, int a4)
{
  unsigned int v4; // eax@3
  unsigned int v5; // esi@3
  unsigned int v6; // eax@7
  unsigned int v8; // [sp+0h] [bp-Ch]@1
  unsigned int v9; // [sp+4h] [bp-8h]@1
  unsigned int v10; // [sp+8h] [bp-4h]@2

  v9 = 0;
  v8 = *(_WORD *)a1;
  if ( a4 )
  {
    v10 = sub_6F7DB877(a1, a2);
    if ( v10 )
    {
      v4 = sub_6F7DB804(a1, a2);
      v5 = v4;
      if ( v4 )
      {
        if ( v4 < v10 )
        {
          while ( a4 != sub_6F7DB767(v8, a1, v5 + 6) || _wcsicmp(Str1, (const wchar_t *)(v5 + 6)) )
          {
            v6 = sub_6F7DB877(a1, v5);
            v5 = v6;
            if ( !v6 || v6 >= v10 )
              return v9;
          }
          v9 = v5;
        }
      }
    }
  }
  return v9;
}

//----- (6F7DB956) --------------------------------------------------------
unsigned int __userpurge sub_6F7DB956@<eax>(unsigned int a1@<eax>, unsigned int a2, int a3)
{
  unsigned int v3; // esi@1
  unsigned int v4; // edi@1
  unsigned int v5; // ecx@2
  unsigned int v6; // ebx@2
  unsigned int v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  v3 = a1;
  v4 = *(_WORD *)a1;
  if ( sub_6F7DB735(a1, a2, 8u, v4) )
  {
    v8 = (a2 + 2 * a3 + 11) & 0xFFFFFFFC;
    v6 = sub_6F7DB7B2(a2, v8, v3);
    if ( !v6 || !sub_6F7DB735(v3, v5, v6, v4) )
      v8 = 0;
  }
  return v8;
}

//----- (6F7DB9B0) --------------------------------------------------------
int __userpurge sub_6F7DB9B0@<eax>(int a1@<eax>, unsigned int a2, int a3, char a4, unsigned int a5)
{
  int v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@3
  unsigned int v8; // eax@4
  unsigned int v9; // edx@6
  int v10; // edi@7
  unsigned int v11; // eax@8

  v5 = 0;
  v6 = a1;
  if ( a4 & 2 )
  {
    v5 = a5 + a2;
  }
  else
  {
    v7 = *(_WORD *)(a1 + 20) + a1 + 24;
    if ( v7 > a2 )
    {
      v8 = (a3 + a2 - v7) / 0x28;
      if ( v8 > 0x10 )
        v8 = 16;
      v9 = *(_WORD *)(v6 + 6);
      if ( v9 <= v8 )
      {
        v10 = 0;
        if ( v9 )
        {
          do
          {
            v11 = *(_DWORD *)(v7 + 12);
            if ( a5 >= v11 && a5 < v11 + *(_DWORD *)(v7 + 16) )
              break;
            v7 += 40;
            ++v10;
          }
          while ( v10 != v9 );
          if ( v10 != v9 )
            v5 = a5 + a2 + *(_DWORD *)(v7 + 20) - v11;
        }
      }
    }
  }
  return v5;
}

//----- (6F7DBA32) --------------------------------------------------------
int __stdcall sub_6F7DBA32(unsigned int a1, unsigned int a2, char a3)
{
  int v3; // edi@1
  unsigned int v4; // ecx@3
  unsigned int v5; // eax@6
  int v6; // ecx@7
  unsigned int v7; // edx@9
  unsigned int v8; // ecx@10
  int v9; // ecx@12
  unsigned int v10; // eax@13
  int v11; // ecx@13
  int v12; // ecx@16
  unsigned int v13; // eax@19
  unsigned int v14; // ebx@19
  int v15; // esi@21
  unsigned int v16; // ecx@25
  int v17; // eax@30
  int v18; // ecx@31
  int v19; // eax@35
  int v20; // ecx@36
  unsigned int *v21; // ecx@40
  int v23; // [sp+Ch] [bp-10h]@1
  int v24; // [sp+10h] [bp-Ch]@7
  int v25; // [sp+18h] [bp-4h]@25

  v23 = 0;
  v3 = a2;
  if ( !a2 )
  {
    v3 = -1 - a1;
    a2 = -1 - a1;
  }
  if ( sub_6F7DB735(a1, a1, v3, v3) && sub_6F7DB735(a1, v4, 0x40u, v3) && *(_WORD *)a1 == 23117 )
  {
    v5 = *(_DWORD *)(a1 + 60);
    if ( v5 < v3 )
    {
      v24 = v5 + a1;
      if ( sub_6F7DB735(a1, v5 + a1, 0xF8u, v3) && *(_DWORD *)v6 == 17744 )
      {
        v7 = *(_WORD *)(v6 + 20);
        if ( v7 < v3 )
        {
          v8 = v6 + 24;
          if ( *(_WORD *)v8 == 267 )
          {
            if ( v7 < 0x60 || !sub_6F7DB735(a1, v8, 0xE0u, v3) )
              return v23;
            v10 = *(_DWORD *)(v9 + 92);
            v11 = v9 + 96;
          }
          else
          {
            if ( *(_WORD *)v8 != 523 || v7 < 0x70 || !sub_6F7DB735(a1, v8, 0xF0u, v3) )
              return v23;
            v10 = *(_DWORD *)(v12 + 108);
            v11 = v12 + 112;
          }
          if ( v10 > 2 )
          {
            v13 = *(_DWORD *)(v11 + 16);
            v14 = *(_DWORD *)(v11 + 20);
            if ( v13 )
            {
              if ( v14 )
              {
                v15 = sub_6F7DB9B0(v24, a1, v3, a3, v13);
                if ( v15 )
                {
                  if ( sub_6F7DB735(a1, v15, v14, v3) && v14 >= 0x10 && *(_WORD *)(v15 + 14) )
                  {
                    v25 = 0;
                    v16 = v15 + 8 * *(_WORD *)(v15 + 12) + 16;
                    while ( sub_6F7DB735(a1, v16, 8u, v3) )
                    {
                      if ( *(_WORD *)v16 != 16 )
                      {
                        v16 += 8;
                        ++v25;
                        if ( v25 != *(_WORD *)(v15 + 14) )
                          continue;
                      }
                      if ( v25 != *(_WORD *)(v15 + 14) )
                      {
                        v17 = *(_DWORD *)(v16 + 4);
                        if ( v17 >= 0
                          || sub_6F7DB735(a1, v15 + (v17 & 0x7FFFFFFF), 0x10u, v3)
                          && (*(_WORD *)(v18 + 14) || *(_WORD *)(v18 + 12))
                          && (v3 = a2, sub_6F7DB735(a1, v18 + 16, 8u, a2))
                          && ((v19 = *(_DWORD *)(v16 + 4), v19 >= 0)
                           || sub_6F7DB735(a1, v15 + (v19 & 0x7FFFFFFF), 0x10u, a2)
                           && (*(_WORD *)(v20 + 14) || *(_WORD *)(v20 + 12))
                           && sub_6F7DB735(a1, v20 + 16, 8u, a2)) )
                        {
                          if ( sub_6F7DB735(a1, v15 + *(_DWORD *)(v16 + 4), 0x10u, v3) )
                            v23 = sub_6F7DB9B0(v24, a1, v3, a3, *v21);
                        }
                      }
                      return v23;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v23;
}

//----- (6F7DBC8F) --------------------------------------------------------
void __stdcall RtlGetVersionResource(void *a1, unsigned int a2, unsigned __int32 a3, struct _RTL_VERSION_RESOURCE *Dst)
{
  int v4; // edi@7
  int v5; // esi@10
  unsigned int v6; // ecx@11
  unsigned __int16 v7; // ax@14
  unsigned int v8; // eax@17
  unsigned int v9; // ebx@18
  unsigned int v10; // eax@19
  unsigned int v11; // eax@21
  unsigned int v12; // eax@22
  int v13; // ebx@25
  unsigned int v14; // eax@26
  signed int v15; // edi@26
  __int16 v16; // cx@27
  int v17; // edx@28
  int v18; // ebx@31
  __int16 v19; // ax@35
  unsigned int v20; // edi@35
  signed int v21; // eax@40
  const void *v22; // edi@43
  unsigned int v23; // ecx@43
  __int16 v24; // ax@44
  signed int v25; // eax@49
  int i; // eax@52
  char *v27; // edi@56
  __int16 v28; // cx@58
  __int16 v29; // dx@59
  char *v30; // ecx@63
  __int16 v31; // di@63
  unsigned int v32; // eax@66
  unsigned int v33; // [sp+8h] [bp+8h]@17
  void *v34; // [sp+8h] [bp+8h]@19
  void *v35; // [sp+8h] [bp+8h]@43
  void *v36; // [sp+8h] [bp+8h]@56
  unsigned __int32 v37; // [sp+10h] [bp+10h]@10

  if ( Dst )
  {
    memset((void *)Dst, 0, 0xD8u);
    if ( !(a3 & 0xFFFFFFFC) && (!(a3 & 1) || !(a3 & 2)) && (a3 & 1 || a3 & 2) )
    {
      v4 = a2;
      if ( !a2 )
        v4 = -1 - (_DWORD)a1;
      if ( (char *)a1 + v4 > a1 )
      {
        v5 = sub_6F7DBA32((unsigned int)a1, v4, a3);
        v37 = v5;
        if ( v5 )
        {
          if ( sub_6F7DB735((unsigned int)a1, v5, 8u, v4)
            && sub_6F7DB735((unsigned int)a1, v6, *(_WORD *)v5, v4)
            && *(_WORD *)v5 > 0x5Cu )
          {
            v7 = *(_WORD *)(v5 + 2);
            if ( v7 < *(_WORD *)v5 && v7 == 52 && !memcmp((const void *)(v5 + 6), L"VS_VERSION_INFO", 0x20u) )
            {
              *(_WORD *)Dst = *(_WORD *)(v37 + 50);
              *((_WORD *)Dst + 1) = *(_WORD *)(v37 + 48);
              *((_WORD *)Dst + 2) = *(_WORD *)(v37 + 54);
              *((_WORD *)Dst + 3) = *(_WORD *)(v37 + 52);
              *((_WORD *)Dst + 4) = *(_WORD *)(v37 + 58);
              *((_WORD *)Dst + 5) = *(_WORD *)(v37 + 56);
              *((_WORD *)Dst + 6) = *(_WORD *)(v37 + 62);
              *((_WORD *)Dst + 7) = *(_WORD *)(v37 + 60);
              v8 = sub_6F7DB8D2(v37, v37, L"StringFileInfo", 14);
              v33 = v8;
              if ( v8 )
              {
                v9 = sub_6F7DB804(v37, v8);
                if ( v9 )
                {
                  v10 = sub_6F7DB877(v37, v33);
                  v34 = (void *)v10;
                  if ( v10 )
                  {
                    if ( v9 < v10 )
                    {
                      while ( 1 )
                      {
                        v11 = sub_6F7DB8D2(v37, v9, L"FileVersion", 11);
                        if ( v11 )
                          break;
                        v12 = sub_6F7DB877(v37, v9);
                        v9 = v12;
                        if ( !v12 || v12 >= (unsigned int)v34 )
                          return;
                      }
                      v13 = sub_6F7DB956(v37, v11, 11);
                      if ( sub_6F7DB767(*(_WORD *)v37, v37, v13) )
                      {
                        *((_DWORD *)Dst + 50) = v13;
                        v14 = 0;
                        v15 = 61;
                        while ( 1 )
                        {
                          do
                          {
                            v16 = *(_WORD *)(v13 + 2 * v14);
                            if ( (unsigned __int16)(*(_WORD *)(v13 + 2 * v14) - 48) > 9u )
                              break;
                            v17 = v14++ + v15;
                            *((_WORD *)Dst + v17) = v16;
                          }
                          while ( v14 < 6 );
                          if ( !v14 || v14 >= 6 )
                            break;
                          v18 = v13 + 2 * v14;
                          v14 = 0;
                          v15 += 6;
                          v13 = v18 + 2 * (*(_WORD *)v18 == 46);
                          if ( v15 == 85 )
                          {
                            while ( *(_WORD *)v13 == 32 || *(_WORD *)v13 == 40 )
                              v13 += 2;
                            v19 = *(_WORD *)v13;
                            v20 = 0;
                            if ( *(_WORD *)v13 )
                            {
                              do
                              {
                                if ( v19 == 40 )
                                  break;
                                if ( v19 == 46 )
                                  break;
                                ++v20;
                                v19 = *(_WORD *)(v13 + 2 * v20);
                              }
                              while ( v19 );
                              if ( v20 )
                              {
                                v21 = v20;
                                if ( v20 >= 0x10 )
                                  v21 = 15;
                                memcpy((char *)Dst + 90, (const void *)v13, 2 * v21);
                              }
                            }
                            v22 = (const void *)(v13 + 2 * v20);
                            v23 = 0;
                            v35 = 0;
                            if ( *(_WORD *)v22 == 40 )
                            {
                              v22 = (char *)v22 + 2;
                              v24 = *(_WORD *)v22;
                              if ( *(_WORD *)v22 )
                              {
                                do
                                {
                                  if ( v24 == 41 )
                                    break;
                                  if ( v24 == 46 )
                                    break;
                                  ++v23;
                                  v24 = *((_WORD *)v22 + v23);
                                  v35 = (void *)v23;
                                }
                                while ( v24 );
                                if ( v23 )
                                {
                                  v25 = v23;
                                  if ( v23 >= 0x10 )
                                    v25 = 15;
                                  memcpy((char *)Dst + 58, v22, 2 * v25);
                                  v23 = (unsigned int)v35;
                                }
                              }
                            }
                            for ( i = (int)((char *)v22 + 2 * v23); *(_WORD *)i == 41 || *(_WORD *)i == 46; i += 2 )
                              ;
                            v36 = 0;
                            v27 = (char *)Dst + 172;
                            while ( (unsigned __int16)(*(_WORD *)i - 48) <= 9u )
                            {
                              v28 = *(_WORD *)(i + 2);
                              if ( (unsigned __int16)(v28 - 48) > 9u )
                                break;
                              v29 = *(_WORD *)i;
                              *(_WORD *)v27 = v28;
                              *((_WORD *)v27 - 1) = v29;
                              v36 = (char *)v36 + 1;
                              v27 += 6;
                              i += 4 + 2 * (*(_WORD *)(i + 4) == 45);
                              if ( v36 == (void *)5 )
                              {
                                *((_WORD *)Dst + 8) = *((_WORD *)Dst + 94);
                                *((_WORD *)Dst + 9) = *((_WORD *)Dst + 95);
                                *((_WORD *)Dst + 10) = 58;
                                *((_WORD *)Dst + 11) = *((_WORD *)Dst + 97);
                                *((_WORD *)Dst + 12) = *((_WORD *)Dst + 98);
                                *((_WORD *)Dst + 13) = 58;
                                *((_WORD *)Dst + 14) = 48;
                                *((_WORD *)Dst + 15) = 48;
                                if ( (struct _RTL_VERSION_RESOURCE *)((char *)Dst + 32) != (struct _RTL_VERSION_RESOURCE *)((char *)Dst + 32) )
                                {
                                  *((_WORD *)Dst + 8) = 66;
                                  *((_WORD *)Dst + 9) = 79;
                                  *((_WORD *)Dst + 10) = 0;
                                }
                                if ( 10 * (*((_WORD *)Dst + 88) - 48) + (unsigned int)*((_WORD *)Dst + 89) - 49 > 0xB )
                                {
                                  *((_WORD *)Dst + 17) = 88;
                                  *((_WORD *)Dst + 18) = 0;
                                }
                                else
                                {
                                  v30 = &byte_6F7DC102[6
                                                     * (10 * (*((_WORD *)Dst + 88) - 48) + *((_WORD *)Dst + 89) - 48)];
                                  v31 = *(_WORD *)v30;
                                  v30 += 2;
                                  *((_WORD *)Dst + 17) = v31;
                                  *((_WORD *)Dst + 18) = *(_WORD *)v30;
                                  *((_WORD *)Dst + 19) = *((_WORD *)v30 + 1);
                                  *((_WORD *)Dst + 20) = 32;
                                  *((_WORD *)Dst + 21) = *((_WORD *)Dst + 91);
                                  *((_WORD *)Dst + 22) = *((_WORD *)Dst + 92);
                                  *((_WORD *)Dst + 23) = 32;
                                  *((_WORD *)Dst + 24) = 50;
                                  *((_WORD *)Dst + 25) = 48;
                                  *((_WORD *)Dst + 26) = *((_WORD *)Dst + 85);
                                  *((_WORD *)Dst + 27) = *((_WORD *)Dst + 86);
                                  if ( (struct _RTL_VERSION_RESOURCE *)((char *)Dst + 56) == (struct _RTL_VERSION_RESOURCE *)((char *)Dst + 56) )
                                  {
                                    if ( *((_WORD *)Dst + 10) )
                                    {
                                      *((_DWORD *)Dst + 51) = v37;
                                      v32 = *(_WORD *)v37;
                                      *((_DWORD *)Dst + 53) |= 1u;
                                      *((_DWORD *)Dst + 52) = v32;
                                    }
                                  }
                                  else
                                  {
                                    *((_WORD *)Dst + 17) = 66;
                                    *((_WORD *)Dst + 18) = 79;
                                    *((_WORD *)Dst + 19) = 0;
                                  }
                                }
                                return;
                              }
                            }
                            return;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
// 6F7DC18C: using guessed type wchar_t aVs_version_inf[16];

//----- (6F7DC1B1) --------------------------------------------------------
void __stdcall RtlGetVersionResourceFromSelf(struct _RTL_VERSION_RESOURCE *Dst)
{
  RtlGetVersionResource((void *)0x6F770000, 0, 2u, Dst);
}

//----- (6F7DC1D0) --------------------------------------------------------
signed int __stdcall Mirror_IsProcessRTL()
{
  signed int result; // eax@2
  DWORD pdwDefaultLayout; // [sp+0h] [bp-4h]@1

  pdwDefaultLayout = 0;
  if ( !GetProcessDefaultLayout(&pdwDefaultLayout) || (result = 1, !(pdwDefaultLayout & 1)) )
    result = 0;
  return result;
}

//----- (6F7DC1F9) --------------------------------------------------------
unsigned __int8 *__stdcall Skip_IDorString(void *a1)
{
  unsigned __int8 *result; // eax@1
  __int16 v2; // cx@3

  result = (unsigned __int8 *)a1;
  if ( *(_WORD *)a1 == -1 )
  {
    result = (unsigned __int8 *)((char *)a1 + 4);
  }
  else
  {
    do
    {
      v2 = *(_WORD *)result;
      result += 2;
    }
    while ( v2 );
  }
  return result;
}

//----- (6F7DC223) --------------------------------------------------------
unsigned int __stdcall Skip_DialogHeader(struct DLGTEMPLATE *a1)
{
  unsigned __int8 *v1; // eax@1
  unsigned __int8 *v2; // eax@1
  unsigned __int8 *v3; // eax@1
  int v4; // edx@1

  v1 = Skip_IDorString(&a1[1]);
  v2 = Skip_IDorString(v1);
  v3 = Skip_IDorString(v2);
  if ( *(_BYTE *)v4 & 0x40 )
    v3 = Skip_IDorString(v3 + 2);
  return (unsigned int)(v3 + 3) & 0xFFFFFFFC;
}

//----- (6F7DC25D) --------------------------------------------------------
void __stdcall EditBiDiDLGTemplate(struct DLGTEMPLATE *a1, int a2, int a3, int a4)
{
  struct DLGTEMPLATE *v4; // edi@1
  int v5; // esi@4
  unsigned int v6; // eax@4
  int v7; // ecx@6
  signed int v8; // esi@6
  unsigned __int8 *v9; // eax@18
  unsigned __int8 *v10; // eax@18
  int v11; // edx@18
  int v12; // ecx@18
  int v13; // [sp+4h] [bp-4h]@4
  int v14; // [sp+10h] [bp+8h]@2
  int v15; // [sp+14h] [bp+Ch]@5

  v4 = a1;
  if ( a1 )
  {
    v14 = a2 & 1;
    if ( a2 & 1 )
      v4->dwExtendedStyle &= 0xFFAFFFFF;
    v5 = v4->cdit;
    v13 = v4->cdit;
    v6 = Skip_DialogHeader(v4);
    if ( v5 )
    {
      v15 = a2 & 2;
      do
      {
        --v13;
        v7 = 0;
        v8 = 0;
        if ( a3 && a4 && a4 > 0 )
        {
          do
          {
            if ( *(_WORD *)(v6 + 16) == *(_WORD *)(a3 + 2 * v7) )
              v8 = 1;
            ++v7;
          }
          while ( v7 < a4 );
        }
        if ( v14 && !v8 )
          *(_DWORD *)(v6 + 4) &= 0xFFAFFFFF;
        if ( v15 && !v8 )
          *(_WORD *)(v6 + 8) = v4->cx - *(_WORD *)(v6 + 12) - *(_WORD *)(v6 + 8);
        v9 = Skip_IDorString((void *)(v6 + 18));
        v10 = Skip_IDorString(v9);
        v12 = *(_WORD *)v10;
        if ( v12 != v11 )
          v10 += v12;
        v6 = (unsigned int)(v10 + 5) & 0xFFFFFFFC;
      }
      while ( v13 != v11 );
    }
  }
}

//----- (6F7DC325) --------------------------------------------------------
BOOL __stdcall IsValidHDPA(int a1)
{
  return a1 != 0;
}

//----- (6F7DC45B) --------------------------------------------------------
int __cdecl _except_handler4(int a1, PVOID TargetFrame, int a3)
{
  unsigned int v3; // ebx@1
  uintptr_t v4; // esi@1
  int v5; // eax@1
  int v6; // edi@1
  int v7; // ecx@2
  int v8; // ecx@3
  void *v9; // ecx@5
  int v10; // eax@5
  int v11; // eax@5
  int v12; // eax@6
  int v13; // ecx@12
  int v14; // ecx@13
  PVOID v16; // eax@20
  int v17; // ecx@23
  int v18; // ecx@24
  int v19; // [sp+Ch] [bp-18h]@4
  int v20; // [sp+10h] [bp-14h]@4
  int v21; // [sp+14h] [bp-10h]@5
  int v22; // [sp+18h] [bp-Ch]@1
  int v23; // [sp+1Ch] [bp-8h]@5
  char v24; // [sp+23h] [bp-1h]@1

  v3 = (unsigned int)TargetFrame;
  v4 = __security_cookie ^ *((_DWORD *)TargetFrame + 2);
  v5 = *(_DWORD *)v4;
  v24 = 0;
  v22 = 1;
  v6 = (int)((char *)TargetFrame + 16);
  if ( v5 != -2 )
    v7 = *(_DWORD *)(v5 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
  if ( *(_BYTE *)(a1 + 4) & 0x66 )
  {
LABEL_25:
    if ( *(_DWORD *)(v3 + 12) == -2 )
      return v22;
    _EH4_LocalUnwind(v3, 0xFFFFFFFE, v6, (int)&__security_cookie);
  }
  else
  {
    *((_DWORD *)TargetFrame - 1) = &v19;
    v3 = *((_DWORD *)TargetFrame + 3);
    v19 = a1;
    v20 = a3;
    if ( v3 == -2 )
      return v22;
    do
    {
      v9 = *(void **)(v4 + 12 * v3 + 20);
      v10 = v4 + 12 * v3 + 16;
      v21 = v10;
      v11 = *(_DWORD *)v10;
      v23 = v11;
      if ( v9 )
      {
        v12 = _EH4_CallFilterFunc(v9);
        v24 = 1;
        if ( v12 < 0 )
        {
          v22 = 0;
          goto LABEL_11;
        }
        if ( v12 > 0 )
        {
          if ( *(_DWORD *)a1 == -529697949
            && _pDestructExceptionObject
            && _IsNonwritableInCurrentImage((int)&_pDestructExceptionObject) )
            _pDestructExceptionObject(a1, 1);
          _EH4_GlobalUnwind(TargetFrame);
          v16 = TargetFrame;
          if ( *((_DWORD *)TargetFrame + 3) != v3 )
          {
            _EH4_LocalUnwind((int)TargetFrame, v3, v6, (int)&__security_cookie);
            v16 = TargetFrame;
          }
          *((_DWORD *)v16 + 3) = v23;
          if ( *(_DWORD *)v4 != -2 )
            v17 = *(_DWORD *)(*(_DWORD *)v4 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
          v18 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
          _EH4_TransferToHandler(*(void **)(v21 + 8));
          goto LABEL_25;
        }
        v11 = v23;
      }
      v3 = v11;
    }
    while ( v11 != -2 );
    if ( !v24 )
      return v22;
  }
LABEL_11:
  if ( *(_DWORD *)v4 != -2 )
    v13 = *(_DWORD *)(*(_DWORD *)v4 + v6) ^ (v6 + *(_DWORD *)(v4 + 4));
  v14 = *(_DWORD *)(*(_DWORD *)(v4 + 8) + v6) ^ (v6 + *(_DWORD *)(v4 + 12));
  return v22;
}
// 6F7E8E78: using guessed type int (__cdecl *_pDestructExceptionObject)(_DWORD, _DWORD);

//----- (6F7DC9B1) --------------------------------------------------------
DWORD __stdcall __crtTlsAlloc(int a1)
{
  return TlsAlloc();
}

//----- (6F7DCA2D) --------------------------------------------------------
void __cdecl __noreturn __report_gsfailure()
{
  int v0; // eax@0
  int v1; // edx@0
  int v2; // ecx@0
  int v3; // ebx@0
  int v4; // edi@0
  int v5; // esi@0
  unsigned int v6; // et0@1
  HANDLE v7; // eax@1
  int vars0; // [sp+328h] [bp+0h]@0
  int retaddr; // [sp+32Ch] [bp+4h]@1
  char v10; // [sp+330h] [bp+8h]@0

  dword_6F7E6D18 = v0;
  dword_6F7E6D14 = v2;
  dword_6F7E6D10 = v1;
  dword_6F7E6D0C = v3;
  dword_6F7E6D08 = v5;
  dword_6F7E6D04 = v4;
  word_6F7E6D30 = __SS__;
  word_6F7E6D24 = __CS__;
  word_6F7E6D00 = __DS__;
  word_6F7E6CFC = __ES__;
  word_6F7E6CF8 = __FS__;
  word_6F7E6CF4 = __GS__;
  v6 = __readeflags();
  dword_6F7E6D28 = v6;
  dword_6F7E6D1C = vars0;
  dword_6F7E6D20 = retaddr;
  dword_6F7E6D2C = (int)&v10;
  dword_6F7E6C68 = 65537;
  dword_6F7E6C24 = retaddr;
  dword_6F7E6C18 = -1073740791;
  dword_6F7E6C1C = 1;
  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(&ExceptionInfo);
  v7 = GetCurrentProcess();
  TerminateProcess(v7, 0xC0000409);
}
// 6F7E62E0: using guessed type int __security_cookie_complement;
// 6F7E6C18: using guessed type int dword_6F7E6C18;
// 6F7E6C1C: using guessed type int dword_6F7E6C1C;
// 6F7E6C24: using guessed type int dword_6F7E6C24;
// 6F7E6C68: using guessed type int dword_6F7E6C68;
// 6F7E6CF4: using guessed type __int16 word_6F7E6CF4;
// 6F7E6CF8: using guessed type __int16 word_6F7E6CF8;
// 6F7E6CFC: using guessed type __int16 word_6F7E6CFC;
// 6F7E6D00: using guessed type __int16 word_6F7E6D00;
// 6F7E6D04: using guessed type int dword_6F7E6D04;
// 6F7E6D08: using guessed type int dword_6F7E6D08;
// 6F7E6D0C: using guessed type int dword_6F7E6D0C;
// 6F7E6D10: using guessed type int dword_6F7E6D10;
// 6F7E6D14: using guessed type int dword_6F7E6D14;
// 6F7E6D18: using guessed type int dword_6F7E6D18;
// 6F7E6D1C: using guessed type int dword_6F7E6D1C;
// 6F7E6D20: using guessed type int dword_6F7E6D20;
// 6F7E6D24: using guessed type __int16 word_6F7E6D24;
// 6F7E6D28: using guessed type int dword_6F7E6D28;
// 6F7E6D2C: using guessed type int dword_6F7E6D2C;
// 6F7E6D30: using guessed type __int16 word_6F7E6D30;

//----- (6F7DCB19) --------------------------------------------------------
int __cdecl _flsbuf(int Ch, FILE *File)
{
  int v2; // esi@1
  int v3; // eax@1
  int v5; // ebx@6
  unsigned int v6; // eax@9
  const void *v7; // eax@15
  int v8; // edi@15
  unsigned int v9; // edi@15
  int v10; // eax@20
  __int64 v11; // rax@23

  v2 = (int)File;
  File = (FILE *)_fileno(File);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return -1;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  v5 = 0;
  if ( v3 & 1 )
  {
    *(_DWORD *)(v2 + 4) = 0;
    if ( !(v3 & 0x10) )
    {
      *(_DWORD *)(v2 + 12) = v3 | 0x20;
      return -1;
    }
    *(_DWORD *)v2 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 12) = v3 & 0xFFFFFFFE;
  }
  v6 = *(_DWORD *)(v2 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v2 + 12) = v6;
  *(_DWORD *)(v2 + 4) = 0;
  if ( !(v6 & 0x10C) && ((int *)v2 != dword_6F7E6530 && (int *)v2 != dword_6F7E6550 || !_isatty((int)File)) )
    _getbuf(v2);
  if ( *(_DWORD *)(v2 + 12) & 0x108 )
  {
    v7 = *(const void **)(v2 + 8);
    v8 = *(_DWORD *)v2;
    *(_DWORD *)v2 = (char *)v7 + 1;
    v9 = v8 - (_DWORD)v7;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 24) - 1;
    if ( (signed int)v9 <= 0 )
    {
      if ( File == (FILE *)-1 || File == (FILE *)-2 )
        v10 = (int)__badioinfo;
      else
        v10 = __pioinfo[(signed int)File >> 5] + 36 * ((unsigned __int8)File & 0x1F);
      if ( *(_BYTE *)(v10 + 4) & 0x20 )
      {
        v11 = _lseeki64((int)File, 0i64, 2);
        if ( (HIDWORD(v11) & (unsigned int)v11) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v5 = _write((int)File, v7, v9);
    }
    **(_BYTE **)(v2 + 8) = Ch;
  }
  else
  {
    v9 = 1;
    v5 = _write((int)File, &Ch, 1u);
  }
  if ( v5 != v9 )
  {
LABEL_27:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return -1;
  }
  return (unsigned __int8)Ch;
}
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7E6530: using guessed type int dword_6F7E6530[3];
// 6F7E6550: using guessed type int dword_6F7E6550[3];
// 6F7E861C: using guessed type int __badioinfo[9];

//----- (6F7DCC6B) --------------------------------------------------------
void __usercall sub_6F7DCC6B(int a1@<edi>, int a2@<esi>, wchar_t a3)
{
  if ( (!(*(_BYTE *)(a2 + 12) & 0x40) || *(_DWORD *)(a2 + 8))
    && _fputwc_nolock(a3, (FILE *)a2) == -1
    && ferror((FILE *)a2) )
    *(_DWORD *)a1 = -1;
  else
    ++*(_DWORD *)a1;
}

//----- (6F7DCCAA) --------------------------------------------------------
void __usercall sub_6F7DCCAA(int a1@<eax>, wchar_t a2, int a3, int a4)
{
  int v4; // edi@1

  v4 = a1;
  if ( a3 > 0 )
  {
    do
    {
      --a3;
      sub_6F7DCC6B(v4, a4, a2);
    }
    while ( *(_DWORD *)v4 != -1 && a3 > 0 );
  }
}

//----- (6F7DCCDC) --------------------------------------------------------
void __usercall sub_6F7DCCDC(int a1@<eax>, wchar_t *a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi@1
  int v5; // edi@1
  wchar_t *v6; // ebx@1

  v4 = a3;
  v5 = a1;
  v6 = a2;
  if ( !(*(_BYTE *)(a3 + 12) & 0x40) || *(_DWORD *)(a3 + 8) )
  {
    while ( a4 > 0 )
    {
      --a4;
      sub_6F7DCC6B(v5, v4, *v6);
      ++v6;
      if ( *(_DWORD *)v5 == -1 )
      {
        if ( *_errno() != 42 )
          return;
        sub_6F7DCC6B(v5, v4, 0x3Fu);
      }
    }
  }
  else
  {
    *(_DWORD *)a1 += a4;
  }
}

//----- (6F7DCD33) --------------------------------------------------------
int __cdecl _woutput_l(int a1, int a2, struct localeinfo_struct *a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  char *v7; // edx@7
  int v8; // ecx@7
  int v9; // edi@8
  int v10; // eax@10
  __int16 v11; // ax@42
  wchar_t *v12; // edi@65
  signed int v13; // esi@71
  int v14; // ebx@73
  unsigned __int16 *v15; // ebx@73
  int *i; // edi@76
  int v17; // eax@86
  int v18; // eax@91
  unsigned __int16 *v19; // esi@92
  unsigned __int16 v20; // cx@93
  int v21; // eax@94
  char *v22; // eax@99
  int v23; // edx@99
  char v24; // cl@100
  int v25; // esi@111
  __int64 v26; // rax@119
  int v27; // ebx@119
  int v28; // esi@126
  void *v29; // eax@126
  int v30; // eax@129
  int v31; // ebx@129
  int v32; // ST18_4@129
  int v33; // ST14_4@129
  int v34; // ST10_4@129
  int v35; // ST0C_4@129
  int v36; // eax@129
  int v37; // esi@129
  int v38; // eax@131
  int v39; // eax@134
  char v40; // cl@138
  unsigned int v41; // ebx@161
  unsigned int v42; // esi@161
  int j; // edi@169
  int v44; // eax@170
  signed int v45; // ecx@172
  unsigned __int64 v46; // kr00_8@172
  char *v47; // eax@175
  int v48; // edi@175
  unsigned __int16 *v49; // eax@181
  int v50; // esi@196
  int v51; // ebx@196
  char *v52; // eax@214
  signed __int16 v53; // [sp-4h] [bp-488h]@190
  int v54; // [sp+10h] [bp-474h]@204
  int v55; // [sp+14h] [bp-470h]@129
  int v56; // [sp+18h] [bp-46Ch]@129
  int v57; // [sp+1Ch] [bp-468h]@12
  wchar_t v58[2]; // [sp+20h] [bp-464h]@86
  int v59; // [sp+24h] [bp-460h]@1
  int v60; // [sp+28h] [bp-45Ch]@1
  int v61; // [sp+2Ch] [bp-458h]@1
  void *Memory; // [sp+30h] [bp-454h]@7
  int v63; // [sp+34h] [bp-450h]@8
  struct localeinfo_struct Locale; // [sp+38h] [bp-44Ch]@1
  int v65; // [sp+40h] [bp-444h]@4
  char v66; // [sp+44h] [bp-440h]@3
  char SrcCh; // [sp+48h] [bp-43Ch]@87
  char v68; // [sp+49h] [bp-43Bh]@87
  __int16 v69; // [sp+4Ch] [bp-438h]@147
  __int16 v70; // [sp+4Eh] [bp-436h]@147
  int v71; // [sp+50h] [bp-434h]@65
  int v72; // [sp+54h] [bp-430h]@1
  int v73; // [sp+58h] [bp-42Ch]@1
  int v74; // [sp+5Ch] [bp-428h]@1
  int v75; // [sp+60h] [bp-424h]@1
  int v76; // [sp+64h] [bp-420h]@7
  int v77; // [sp+68h] [bp-41Ch]@7
  int v78; // [sp+6Ch] [bp-418h]@1
  char *v79; // [sp+70h] [bp-414h]@7
  unsigned __int16 *v80; // [sp+74h] [bp-410h]@65
  int v81; // [sp+78h] [bp-40Ch]@1
  int v82; // [sp+7Ch] [bp-408h]@1
  wchar_t DstCh; // [sp+80h] [bp-404h]@65
  char v84[513]; // [sp+27Fh] [bp-205h]@169

  v4 = a4;
  v5 = a2;
  v75 = a1;
  v78 = a4;
  v61 = 0;
  v82 = 0;
  v73 = 0;
  v81 = 0;
  v74 = 0;
  v59 = 0;
  v60 = 0;
  v72 = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  if ( !v75 || !a2 )
  {
    *_errno() = 22;
    goto LABEL_3;
  }
  v7 = (char *)*(_WORD *)a2;
  v8 = 0;
  v77 = 0;
  v76 = 0;
  Memory = 0;
  v79 = v7;
  if ( !(_WORD)v7 )
  {
LABEL_217:
    if ( v66 )
      *(_DWORD *)(v65 + 112) &= 0xFFFFFFFD;
    return v77;
  }
  while ( 2 )
  {
    v9 = v5 + 2;
    v63 = v9;
    if ( v77 < 0 )
      goto LABEL_217;
    if ( (unsigned __int16)((_WORD)v7 - 32) > 0x58u )
      v10 = 0;
    else
      v10 = *((_BYTE *)L"kernel32.dll" + (unsigned __int16)v7) & 0xF;
    v57 = (signed int)LOBYTE((&(&__lookuptable)[8 * v10])[v8]) >> 4;
    switch ( v57 )
    {
      case 1:
        v81 = -1;
        v59 = 0;
        v60 = 0;
        v73 = 0;
        v74 = 0;
        v82 = 0;
        v72 = 0;
        goto LABEL_214;
      case 2:
        switch ( (unsigned __int16)v7 )
        {
          case 0x20u:
            v82 |= 2u;
            break;
          case 0x23u:
            v82 |= 0x80u;
            break;
          case 0x2Bu:
            v82 |= 1u;
            break;
          case 0x2Du:
            v82 |= 4u;
            break;
          case 0x30u:
            v82 |= 8u;
            break;
        }
        goto LABEL_214;
      case 3:
        if ( (_WORD)v7 == 42 )
        {
          v78 = v4 + 4;
          v73 = *(_DWORD *)v4;
          if ( v73 < 0 )
          {
            v82 |= 4u;
            v73 = -v73;
          }
        }
        else
        {
          v73 = 10 * v73 + (unsigned __int16)v7 - 48;
        }
        goto LABEL_214;
      case 4:
        v81 = 0;
        goto LABEL_214;
      case 5:
        if ( (_WORD)v7 == 42 )
        {
          v78 = v4 + 4;
          v81 = *(_DWORD *)v4;
          if ( v81 < 0 )
            v81 = -1;
        }
        else
        {
          v81 = 10 * v81 + (unsigned __int16)v7 - 48;
        }
        goto LABEL_214;
      case 6:
        switch ( (unsigned __int16)v7 )
        {
          case 0x49u:
            v11 = *(_WORD *)v9;
            if ( *(_WORD *)v9 != 54 || *(_WORD *)(v9 + 2) != 52 )
            {
              if ( v11 != 51 || *(_WORD *)(v9 + 2) != 50 )
              {
                if ( v11 != 100 && v11 != 105 && v11 != 111 && v11 != 117 && v11 != 120 && v11 != 88 )
                {
                  v57 = 0;
LABEL_55:
                  v72 = 1;
                  sub_6F7DCC6B((int)&v77, v75, (wchar_t)v7);
                }
              }
              else
              {
                v82 &= 0xFFFF7FFF;
                v63 = v9 + 4;
              }
            }
            else
            {
              v82 |= 0x8000u;
              v63 = v9 + 4;
            }
            break;
          case 0x68u:
            v82 |= 0x20u;
            break;
          case 0x6Cu:
            if ( *(_WORD *)v9 == 108 )
            {
              v82 |= 0x1000u;
              v63 = v9 + 2;
            }
            else
            {
              v82 |= 0x10u;
            }
            break;
          case 0x77u:
            v82 |= 0x800u;
            break;
        }
        goto LABEL_214;
      case 0:
        goto LABEL_55;
      case 7:
        if ( (signed int)(unsigned __int16)v7 > 100 )
        {
          if ( (signed int)(unsigned __int16)v7 > 112 )
          {
            if ( (unsigned __int16)v7 != 115 )
            {
              if ( (unsigned __int16)v7 != 117 )
              {
                if ( (unsigned __int16)v7 != 120 )
                  goto LABEL_187;
                v61 = 39;
                goto LABEL_146;
              }
LABEL_117:
              v79 = (char *)10;
              goto LABEL_118;
            }
LABEL_71:
            v13 = v81;
            if ( v81 == -1 )
              v13 = 0x7FFFFFFF;
            v14 = v4 + 4;
            v78 = v14;
            v15 = *(unsigned __int16 **)(v14 - 4);
            v80 = v15;
            if ( v82 & 0x20 )
            {
              if ( !v15 )
                v80 = (unsigned __int16 *)__nullstring;
              v76 = 0;
              for ( i = (int *)v80; v76 < v13; ++v76 )
              {
                if ( !*(_BYTE *)i )
                  break;
                if ( _isleadbyte_l(*(_BYTE *)i, &Locale) )
                  i = (int *)((char *)i + 1);
                i = (int *)((char *)i + 1);
              }
            }
            else
            {
              if ( !v15 )
                v80 = __wnullstring;
              v49 = v80;
              v72 = 1;
              while ( v13 )
              {
                --v13;
                if ( !*v49 )
                  break;
                ++v49;
              }
              v21 = v49 - v80;
LABEL_186:
              v76 = v21;
            }
            goto LABEL_187;
          }
          if ( (unsigned __int16)v7 == 112 )
          {
            v81 = 8;
LABEL_141:
            v61 = 7;
LABEL_146:
            v79 = (char *)16;
            if ( v82 & 0x80 )
            {
              v69 = 48;
              v70 = v61 + 81;
              v74 = 2;
            }
            goto LABEL_118;
          }
          if ( (signed int)(unsigned __int16)v7 < 101 )
            goto LABEL_187;
          if ( (signed int)(unsigned __int16)v7 <= 103 )
            goto LABEL_65;
          if ( (unsigned __int16)v7 == 105 )
            goto LABEL_116;
          if ( (unsigned __int16)v7 != 110 )
          {
            if ( (unsigned __int16)v7 != 111 )
              goto LABEL_187;
            v79 = (char *)8;
            if ( v82 & 0x80 )
              v82 |= 0x200u;
LABEL_118:
            if ( v82 & 0x8000 || v82 & 0x1000 )
            {
              v26 = *(_QWORD *)v4;
              v27 = v4 + 8;
            }
            else
            {
              v27 = v4 + 4;
              if ( v82 & 0x20 )
              {
                v78 = v27;
                if ( v82 & 0x40 )
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                else
                  LODWORD(v26) = *(_WORD *)(v27 - 4);
                v26 = (signed int)v26;
LABEL_158:
                if ( v82 & 0x40 && v26 < 0 )
                {
                  v26 = -v26;
                  v82 |= 0x100u;
                }
                v41 = HIDWORD(v26);
                v42 = v26;
                if ( !(v82 & 0x9000) )
                  v41 = 0;
                if ( v81 >= 0 )
                {
                  v82 &= 0xFFFFFFF7;
                  if ( v81 > 512 )
                    v81 = 512;
                }
                else
                {
                  v81 = 1;
                }
                if ( !(v41 | (unsigned int)v26) )
                  v74 = 0;
                for ( j = (int)v84; ; --j )
                {
                  v44 = v81--;
                  if ( v44 <= 0 && !(v41 | v42) )
                    break;
                  v45 = __PAIR__(v41, v42) % (signed int)v79 + 48;
                  v46 = __PAIR__(v41, v42) / (signed int)v79;
                  v41 = __PAIR__(v41, v42) / (signed int)v79 >> 32;
                  v42 = v46;
                  if ( v45 > 57 )
                    LOBYTE(v45) = v61 + v45;
                  *(_BYTE *)j = v45;
                }
                v47 = &v84[-j];
                v48 = j + 1;
                v76 = (int)v47;
                v80 = (unsigned __int16 *)v48;
                if ( v82 & 0x200 && (!v47 || *(_BYTE *)v48 != 48) )
                {
                  v80 = (unsigned __int16 *)((char *)v80 - 1);
                  *(_BYTE *)v80 = 48;
                  v21 = (int)(v47 + 1);
                  goto LABEL_186;
                }
LABEL_187:
                if ( v60 )
                  goto LABEL_212;
                if ( v82 & 0x40 )
                {
                  if ( v82 & 0x100 )
                  {
                    v53 = 45;
                    goto LABEL_195;
                  }
                  if ( v82 & 1 )
                  {
                    v53 = 43;
                    goto LABEL_195;
                  }
                  if ( v82 & 2 )
                  {
                    v53 = 32;
LABEL_195:
                    v69 = v53;
                    v74 = 1;
                  }
                }
                v50 = v76;
                v51 = v73 - v76 - v74;
                if ( !(v82 & 0xC) )
                  sub_6F7DCCAA((int)&v77, 0x20u, v73 - v76 - v74, v75);
                sub_6F7DCCDC((int)&v77, (wchar_t *)&v69, v75, v74);
                if ( v82 & 8 && !(v82 & 4) )
                  sub_6F7DCCAA((int)&v77, 0x30u, v51, v75);
                if ( v72 || v50 <= 0 )
                {
                  sub_6F7DCCDC((int)&v77, v80, v75, v50);
                }
                else
                {
                  v79 = (char *)v80;
                  v71 = v50;
                  while ( 1 )
                  {
                    --v71;
                    v54 = _mbtowc_l(v58, v79, Locale.locinfo->mb_cur_max, &Locale);
                    if ( v54 <= 0 )
                      break;
                    sub_6F7DCC6B((int)&v77, v75, v58[0]);
                    v79 += v54;
                    if ( v71 <= 0 )
                      goto LABEL_209;
                  }
                  v77 = -1;
                }
LABEL_209:
                if ( v77 >= 0 && v82 & 4 )
                  sub_6F7DCCAA((int)&v77, 0x20u, v51, v75);
                goto LABEL_212;
              }
              LODWORD(v26) = *(_DWORD *)(v27 - 4);
              if ( v82 & 0x40 )
                v26 = (signed int)v26;
              else
                HIDWORD(v26) = 0;
            }
            v78 = v27;
            goto LABEL_158;
          }
          v25 = *(_DWORD *)v4;
          v78 = v4 + 4;
          if ( !_get_printf_count_output() )
            goto LABEL_216;
          if ( v82 & 0x20 )
            *(_WORD *)v25 = v77;
          else
            *(_DWORD *)v25 = v77;
          v60 = 1;
LABEL_212:
          if ( Memory )
          {
            free(Memory);
            Memory = 0;
          }
LABEL_214:
          v5 = v63;
          v52 = (char *)*(_WORD *)v63;
          v79 = v52;
          if ( !(_WORD)v52 )
            goto LABEL_217;
          v8 = v57;
          v4 = v78;
          v7 = v52;
          continue;
        }
        if ( (unsigned __int16)v7 == 100 )
        {
LABEL_116:
          v82 |= 0x40u;
          goto LABEL_117;
        }
        if ( (signed int)(unsigned __int16)v7 <= 83 )
        {
          if ( (unsigned __int16)v7 == 83 )
          {
            if ( !(v82 & 0x830) )
              v82 |= 0x20u;
            goto LABEL_71;
          }
          if ( (unsigned __int16)v7 != 65 )
          {
            if ( (unsigned __int16)v7 != 67 )
            {
              if ( (unsigned __int16)v7 != 69 && (unsigned __int16)v7 != 71 )
                goto LABEL_187;
              goto LABEL_64;
            }
            if ( !(v82 & 0x830) )
              v82 |= 0x20u;
LABEL_86:
            v17 = *(_WORD *)v4;
            v72 = 1;
            v78 = v4 + 4;
            *(_DWORD *)v58 = v17;
            if ( v82 & 0x20 )
            {
              SrcCh = v17;
              v68 = 0;
              if ( _mbtowc_l(&DstCh, &SrcCh, Locale.locinfo->mb_cur_max, &Locale) < 0 )
                v60 = 1;
            }
            else
            {
              DstCh = v17;
            }
            v80 = &DstCh;
            v76 = 1;
            goto LABEL_187;
          }
LABEL_64:
          v7 += 32;
          v59 = 1;
          v79 = v7;
          goto LABEL_65;
        }
        if ( (unsigned __int16)v7 == 88 )
          goto LABEL_141;
        if ( (unsigned __int16)v7 != 90 )
        {
          if ( (unsigned __int16)v7 != 97 )
          {
            if ( (unsigned __int16)v7 != 99 )
              goto LABEL_187;
            goto LABEL_86;
          }
LABEL_65:
          v82 |= 0x40u;
          v12 = &DstCh;
          v80 = &DstCh;
          v71 = 512;
          if ( v81 >= 0 )
          {
            if ( v81 )
            {
              if ( v81 > 512 )
                v81 = 512;
              if ( v81 > 163 )
              {
                v28 = v81 + 349;
                v29 = malloc(v81 + 349);
                LOBYTE(v7) = (_BYTE)v79;
                Memory = v29;
                if ( v29 )
                {
                  v80 = (unsigned __int16 *)v29;
                  v71 = v28;
                  v12 = (wchar_t *)v29;
                }
                else
                {
                  v81 = 163;
                }
              }
            }
            else if ( (_WORD)v7 == 103 )
            {
              v81 = 1;
            }
          }
          else
          {
            v81 = 6;
          }
          v30 = *(_DWORD *)v4;
          v31 = v4 + 8;
          v55 = v30;
          v56 = *(_DWORD *)(v31 - 4);
          v32 = v59;
          v33 = v81;
          v78 = v31;
          v34 = (char)v7;
          v35 = v71;
          v36 = _decode_pointer((int)off_6F7E6018[0]);
          ((void (__cdecl *)(int *, wchar_t *, int, int, int, int, struct localeinfo_struct *))v36)(
            &v55,
            v12,
            v35,
            v34,
            v33,
            v32,
            &Locale);
          v37 = v82 & 0x80;
          if ( v82 & 0x80 && !v81 )
          {
            v38 = _decode_pointer((int)off_6F7E6024);
            ((void (__cdecl *)(wchar_t *, struct localeinfo_struct *))v38)(v12, &Locale);
          }
          if ( (_WORD)v79 == 103 && !v37 )
          {
            v39 = _decode_pointer((int)off_6F7E6020[0]);
            ((void (__cdecl *)(wchar_t *, struct localeinfo_struct *))v39)(v12, &Locale);
          }
          if ( *(_BYTE *)v12 == 45 )
          {
            v82 |= 0x100u;
            v12 = (wchar_t *)((char *)v12 + 1);
            v80 = v12;
          }
          v22 = (char *)v12;
          v23 = (int)((char *)v12 + 1);
          do
            v40 = *v22++;
          while ( v40 );
LABEL_101:
          v21 = (int)&v22[-v23];
          goto LABEL_186;
        }
        v18 = *(_DWORD *)v4;
        v78 = v4 + 4;
        if ( !v18 || (v19 = *(unsigned __int16 **)(v18 + 4)) == 0 )
        {
          v22 = __nullstring;
          v80 = (unsigned __int16 *)__nullstring;
          v23 = (int)(__nullstring + 1);
          do
            v24 = *v22++;
          while ( v24 );
          goto LABEL_101;
        }
        v20 = *(_WORD *)v18;
        if ( *(_WORD *)(v18 + 2) < *(_WORD *)v18 )
          goto LABEL_216;
        v21 = v20;
        if ( !(v82 & 0x800) )
        {
          v72 = 0;
          v80 = v19;
          goto LABEL_186;
        }
        if ( ~(_BYTE)v20 & 1 && ~(_BYTE)v19 & 1 )
        {
          v80 = v19;
          v21 = (unsigned int)v20 >> 1;
          v72 = 1;
          goto LABEL_186;
        }
LABEL_216:
        *_errno() = 22;
LABEL_3:
        _invalid_parameter(0, 0, 0, 0, 0);
        if ( v66 )
          *(_DWORD *)(v65 + 112) &= 0xFFFFFFFD;
        return -1;
      default:
        goto LABEL_214;
    }
  }
}
// 6F792FF0: using guessed type const char *const __lookuptable;
// 6F7E6018: using guessed type int (*off_6F7E6018[4])();
// 6F7E6020: using guessed type int (*off_6F7E6020[2])();
// 6F7E6024: using guessed type int (*off_6F7E6024)();
// 6F7E6834: using guessed type char *__nullstring;
// 6F7E6848: using guessed type unsigned __int16 *__wnullstring;
// 6F7DCD33: using guessed type char var_205[513];

//----- (6F7DD932) --------------------------------------------------------
void __cdecl _invoke_watson(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5)
{
  unsigned int v5; // et0@1

  v5 = __readeflags();
  OutputDebugStringA("Invalid parameter passed to C runtime function.\n");
}

//----- (6F7DDA0A) --------------------------------------------------------
void __cdecl _invalid_parameter(const wchar_t *a1, const wchar_t *a2, const wchar_t *a3, unsigned int a4, uintptr_t a5)
{
  _invoke_watson(a1, a2, a3, a4, a5);
}

//----- (6F7DDB3C) --------------------------------------------------------
int __cdecl _IsNonwritableInCurrentImage(int a1)
{
  int v1; // eax@2
  int result; // eax@3

  if ( _ValidateImageBase(1870069760) && (v1 = _FindPESection(1870069760, a1 - 1870069760)) != 0 )
    result = ~(unsigned __int8)(*(_DWORD *)(v1 + 36) >> 31) & 1;
  else
    result = 0;
  return result;
}
// 6F7DDAB9: using guessed type _DWORD __cdecl _ValidateImageBase(_DWORD);
// 6F7DDAF3: using guessed type _DWORD __cdecl _FindPESection(_DWORD, _DWORD);

//----- (6F7DDDF7) --------------------------------------------------------
int __updatetlocinfo()
{
  int v0; // eax@1
  int v1; // ST04_4@4
  int v2; // ST18_4@4
  int v3; // esi@4

  v0 = _getptd();
  if ( (*(_BYTE *)(v0 + 112) & 2 || !(__globallocalestatus & 1)) && *(_DWORD *)(v0 + 108) )
  {
    v3 = *(_DWORD *)(_getptd() + 108);
  }
  else
  {
    _lock(12);
    v2 = _updatetlocinfoEx_nolock(v1);
    _unlock(12);
    v3 = v2;
  }
  if ( !v3 )
    _amsg_exit(32);
  return v3;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7DC8FE: using guessed type _DWORD __cdecl _amsg_exit(_DWORD);
// 6F7DDDB4: using guessed type int __thiscall _updatetlocinfoEx_nolock(_DWORD);
// 6F7E684C: using guessed type _DWORD ___ptlocinfo;
// 6F7E8460: using guessed type char __globallocalestatus;

//----- (6F7DDF53) --------------------------------------------------------
void __cdecl _NMSG_WRITE(int a1)
{
  unsigned int v1; // esi@1
  HANDLE v2; // eax@21
  DWORD NumberOfBytesWritten; // [sp+Ch] [bp-8h]@23
  unsigned int v4; // [sp+10h] [bp-4h]@1

  v1 = 0;
  v4 = 0;
  do
  {
    if ( a1 == dword_6F7E89C0[2 * v1] )
      break;
    ++v1;
    v4 = v1;
  }
  while ( v1 < 0x17 );
  if ( v1 < 0x17 )
  {
    if ( _set_error_mode(3) != 1 && (_set_error_mode(3) || __app_type != 1) )
    {
      if ( a1 != 252 )
      {
        if ( strcpy_s(Dst, 0x314u, "Runtime Error!\n\nProgram: ") )
          _invoke_watson(0, 0, 0, 0, 0);
        byte_6F7E8C25 = 0;
        if ( !GetModuleFileNameA(0, byte_6F7E8B21, 0x104u) && strcpy_s(byte_6F7E8B21, 0x2FBu, "<program name unknown>") )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, byte_6F7E8B21) )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, "\n\n") )
          _invoke_watson(0, 0, 0, 0, 0);
        if ( strcat_s(Dst, 0x314u, (const char *)*(&lpBuffer + 2 * v4)) )
          _invoke_watson(0, 0, 0, 0, 0);
        __crtMessageBoxA((int)Dst, (int)"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      v2 = GetStdHandle(0xFFFFFFF4);
      if ( v2 && v2 != (HANDLE)-1 )
        WriteFile(v2, *(&lpBuffer + 2 * v1), strlen((const char *)*(&lpBuffer + 2 * v1)), &NumberOfBytesWritten, 0);
    }
  }
}
// 6F7E89C0: using guessed type int dword_6F7E89C0[];
// 6F7E8AE4: using guessed type int __app_type;
// 6F7E8C25: using guessed type char byte_6F7E8C25;

//----- (6F7DE179) --------------------------------------------------------
signed int __cdecl _mtinitlocknum(int a1)
{
  LPCRITICAL_SECTION *v1; // esi@4
  signed int result; // eax@5
  void *v3; // edi@6
  signed int v4; // [sp+10h] [bp-1Ch]@1

  v4 = 1;
  if ( !_crtheap )
  {
    _FF_MSGBANNER();
    _NMSG_WRITE(30);
    __crtExitProcess(0xFFu);
  }
  v1 = &lpCriticalSection + 2 * a1;
  if ( *v1 )
  {
    result = 1;
  }
  else
  {
    v3 = malloc(0x18u);
    if ( v3 )
    {
      _lock(10);
      if ( *v1 )
      {
        free(v3);
      }
      else if ( __crtInitCritSecAndSpinCount((int)v3, 4000) )
      {
        *v1 = (LPCRITICAL_SECTION)v3;
      }
      else
      {
        free(v3);
        *_errno() = 12;
        v4 = 0;
      }
      _unlock(10);
      result = v4;
    }
    else
    {
      *_errno() = 12;
      result = 0;
    }
  }
  return result;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7DE13B: using guessed type int _FF_MSGBANNER(void);

//----- (6F7DE269) --------------------------------------------------------
void __cdecl __noreturn terminate()
{
  void (*v0)(void); // eax@1

  v0 = *(void (**)(void))(_getptd() + 120);
  if ( v0 )
    v0();
  abort();
}

//----- (6F7DE305) --------------------------------------------------------
int __get_sigabrt()
{
  return _decode_pointer(dword_6F7E6918);
}
// 6F7E6918: using guessed type int dword_6F7E6918;

//----- (6F7DE4F1) --------------------------------------------------------
int __stdcall sub_6F7DE4F1(LPCRITICAL_SECTION lpCriticalSection, int a2)
{
  InitializeCriticalSection(lpCriticalSection);
  return 1;
}

//----- (6F7DEE8B) --------------------------------------------------------
__int64 __cdecl _lseeki64(int Filehandle, __int64 a2, int dwMoveMethod)
{
  __int64 result; // rax@3
  int *v4; // ebx@7
  int v5; // esi@7
  int v6; // edx@10
  __int64 v7; // [sp+10h] [bp-24h]@10

  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1i64;
  }
  if ( Filehandle < 0 || Filehandle >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1i64;
  }
  v4 = &__pioinfo[Filehandle >> 5];
  v5 = 36 * (Filehandle & 0x1F);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    __lock_fhandle(Filehandle);
    if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
    {
      LODWORD(v7) = _lseeki64_nolock(Filehandle, a2, SHIDWORD(a2), dwMoveMethod);
      HIDWORD(v7) = v6;
    }
    else
    {
      *_errno() = 9;
      *__doserrno() = 0;
      v7 = -1i64;
    }
    _unlock_fhandle(Filehandle);
    result = v7;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1i64;
  }
  return result;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7DEFD1) --------------------------------------------------------
DWORD __cdecl _write_nolock(int a1, int a2, DWORD nNumberOfBytesToWrite)
{
  int v4; // ebx@5
  int *v5; // edi@5
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // esi@13
  UINT v9; // eax@16
  char *v10; // esi@16
  int v11; // ST1C_4@19
  int v12; // eax@25
  signed int v13; // esi@25
  int v14; // eax@29
  int v15; // ecx@34
  __int16 v16; // ax@37
  int v17; // eax@43
  unsigned int v18; // esi@46
  DWORD v19; // ecx@46
  char *v20; // eax@46
  int v21; // edx@48
  char v22; // dl@48
  int v23; // esi@51
  char *v24; // edi@56
  unsigned int v25; // esi@57
  DWORD v26; // ecx@57
  char *v27; // eax@57
  __int16 v28; // dx@59
  int v29; // esi@65
  unsigned int v30; // esi@71
  DWORD v31; // ecx@71
  WCHAR *v32; // eax@71
  DWORD v33; // edx@73
  WCHAR v34; // dx@73
  int v35; // esi@79
  int v36; // edi@79
  UINT CodePage; // [sp+4h] [bp-594h]@16
  int v38; // [sp+8h] [bp-590h]@16
  DWORD Mode; // [sp+Ch] [bp-58Ch]@13
  int v40; // [sp+10h] [bp-588h]@5
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-584h]@16
  int *v42; // [sp+18h] [bp-580h]@5
  DWORD v43; // [sp+1Ch] [bp-57Ch]@51
  int v44; // [sp+20h] [bp-578h]@1
  char *SrcCh; // [sp+24h] [bp-574h]@1
  DWORD v46; // [sp+28h] [bp-570h]@1
  wchar_t DstCh[2]; // [sp+2Ch] [bp-56Ch]@20
  DWORD v48; // [sp+30h] [bp-568h]@17
  char Buffer; // [sp+34h] [bp-564h]@46
  CHAR v50[688]; // [sp+188h] [bp-410h]@79
  WCHAR WideCharStr; // [sp+438h] [bp-160h]@71
  CHAR MultiByteStr; // [sp+58Ch] [bp-Ch]@25

  SrcCh = (char *)a2;
  v46 = 0;
  v44 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a2 )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v4 = 36 * (a1 & 0x1F);
  v5 = &__pioinfo[a1 >> 5];
  v6 = v4 + *v5;
  v7 = *(_DWORD *)(v6 + 8) & 3;
  v42 = &__pioinfo[a1 >> 5];
  v40 = v7;
  if ( (v7 == 2 || v7 == 1) && !(~(_BYTE)nNumberOfBytesToWrite & 1) )
  {
    *__doserrno() = 0;
    *_errno() = 22;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  if ( *(_BYTE *)(v6 + 4) & 0x20 )
    _lseeki64_nolock(a1, 0, 0, 2u);
  if ( _isatty(a1) )
  {
    if ( *(_BYTE *)(v4 + *v5 + 4) & 0x80 )
    {
      v8 = *(_DWORD *)(*(_DWORD *)(_getptd() + 108) + 20) == 0;
      if ( GetConsoleMode(*(HANDLE *)(v4 + *v5), &Mode) )
      {
        if ( !v8 || v40 )
        {
          v9 = GetConsoleCP();
          NumberOfBytesWritten = 0;
          v10 = SrcCh;
          CodePage = v9;
          v38 = (int)SrcCh;
          if ( nNumberOfBytesToWrite )
          {
            v48 = 0;
            while ( 1 )
            {
              if ( v40 )
              {
                if ( v40 == 1 || v40 == 2 )
                {
                  v15 = *(_WORD *)v10;
                  v48 += 2;
                  *(_DWORD *)DstCh = v15;
                  v38 = (int)(v10 + 2);
                  Mode = (_WORD)v15 == 10;
                }
                if ( v40 == 1 || v40 == 2 )
                {
                  v16 = _putwch_nolock(DstCh[0]);
                  if ( v16 != DstCh[0] )
                    goto LABEL_89;
                  ++v46;
                  if ( Mode )
                  {
                    *(_DWORD *)DstCh = 13;
                    if ( (unsigned __int16)_putwch_nolock(13) != 13 )
                      goto LABEL_89;
                    ++v46;
                    ++v44;
                  }
                }
              }
              else
              {
                v11 = *v10;
                Mode = *v10 == 10;
                if ( isleadbyte(v11) )
                {
                  if ( nNumberOfBytesToWrite + SrcCh - v10 <= 1 || mbtowc(DstCh, v10, 2u) == -1 )
                    goto LABEL_90;
                  ++v10;
                  ++v48;
                }
                else if ( mbtowc(DstCh, v10, 1u) == -1 )
                {
                  goto LABEL_90;
                }
                ++v48;
                v38 = (int)(v10 + 1);
                v12 = WideCharToMultiByte(CodePage, 0, DstCh, 1, &MultiByteStr, 5, 0, 0);
                v13 = v12;
                if ( !v12 )
                  goto LABEL_90;
                if ( !WriteFile(*(HANDLE *)(v4 + *v5), &MultiByteStr, v12, &NumberOfBytesWritten, 0) )
                  goto LABEL_89;
                v46 += NumberOfBytesWritten;
                if ( (signed int)NumberOfBytesWritten < v13 )
                  goto LABEL_90;
                if ( Mode )
                {
                  v14 = *v5;
                  MultiByteStr = 13;
                  if ( !WriteFile(*(HANDLE *)(v4 + v14), &MultiByteStr, 1u, &NumberOfBytesWritten, 0) )
                    goto LABEL_89;
                  if ( (signed int)NumberOfBytesWritten < 1 )
                    goto LABEL_90;
                  ++v44;
                  ++v46;
                }
              }
              if ( v48 >= nNumberOfBytesToWrite )
                goto LABEL_90;
              v10 = (char *)v38;
            }
          }
LABEL_91:
          if ( *(_DWORD *)DstCh )
          {
            if ( *(_DWORD *)DstCh == 5 )
            {
              *_errno() = 9;
              *__doserrno() = 5;
            }
            else
            {
              _dosmaperr(*(_DWORD *)DstCh);
            }
            return -1;
          }
LABEL_95:
          if ( *(_BYTE *)(v4 + *v42 + 4) & 0x40 && *SrcCh == 26 )
            return 0;
          *_errno() = 28;
          *__doserrno() = 0;
          return -1;
        }
      }
    }
  }
  v17 = v4 + *v5;
  if ( *(_BYTE *)(v17 + 4) & 0x80 )
  {
    *(_DWORD *)DstCh = 0;
    if ( v40 )
    {
      if ( v40 == 2 )
      {
        v24 = SrcCh;
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_95;
        while ( 1 )
        {
          v25 = 0;
          v26 = v24 - SrcCh;
          v27 = &Buffer;
          while ( v26 < nNumberOfBytesToWrite )
          {
            v28 = *(_WORD *)v24;
            v24 += 2;
            v26 += 2;
            if ( v28 == 10 )
            {
              if ( v25 > 0x3FD )
              {
                v24 -= 2;
                break;
              }
              v44 += 2;
              *(_WORD *)v27 = 13;
              v4 = 36 * (a1 & 0x1F);
              v27 += 2;
              v25 += 2;
            }
            *(_WORD *)v27 = v28;
            v27 += 2;
            v25 += 2;
            if ( v25 >= 0x3FF )
              break;
          }
          v29 = v27 - &Buffer;
          if ( !WriteFile(*(HANDLE *)(v4 + *v42), &Buffer, v27 - &Buffer, &v43, 0) )
            break;
          v46 += v43;
          if ( (signed int)v43 < v29 || !v43 || v24 - SrcCh >= nNumberOfBytesToWrite )
            goto LABEL_90;
        }
      }
      else
      {
        v48 = (DWORD)SrcCh;
        if ( nNumberOfBytesToWrite <= 0 )
          goto LABEL_95;
        while ( 1 )
        {
          v30 = 0;
          v31 = v48 - (_DWORD)SrcCh;
          v32 = &WideCharStr;
          while ( v31 < nNumberOfBytesToWrite )
          {
            v33 = v48;
            v48 += 2;
            v34 = *(_WORD *)v33;
            v31 += 2;
            if ( v34 == 10 )
            {
              if ( v30 > 0x150 )
              {
                v48 -= 2;
                break;
              }
              *v32 = 13;
              ++v32;
              v30 += 2;
            }
            *v32 = v34;
            ++v32;
            v30 += 2;
            if ( v30 >= 0x152 )
              break;
          }
          v35 = 0;
          v36 = WideCharToMultiByte(0xFDE9u, 0, &WideCharStr, v32 - &WideCharStr, v50, 683, 0, 0);
          if ( !v36 )
            break;
          while ( WriteFile(*(HANDLE *)(v4 + *v42), &v50[v35], v36 - v35, &v43, 0) )
          {
            v35 += v43;
            if ( v36 <= v35 )
              goto LABEL_84;
          }
          *(_DWORD *)DstCh = GetLastError();
LABEL_84:
          if ( v36 <= v35 )
          {
            v46 = v48 - (_DWORD)SrcCh;
            if ( v48 - (unsigned int)SrcCh < nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_90;
        }
      }
    }
    else
    {
      v48 = (DWORD)SrcCh;
      if ( nNumberOfBytesToWrite <= 0 )
        goto LABEL_95;
      while ( 1 )
      {
        v18 = 0;
        v19 = v48 - (_DWORD)SrcCh;
        v20 = &Buffer;
        do
        {
          if ( v19 >= nNumberOfBytesToWrite )
            break;
          v21 = v48++;
          v22 = *(_BYTE *)v21;
          ++v19;
          if ( v22 == 10 )
          {
            ++v44;
            *v20++ = 13;
            ++v18;
          }
          v5 = v42;
          *v20++ = v22;
          ++v18;
        }
        while ( v18 < 0x400 );
        v23 = v20 - &Buffer;
        if ( !WriteFile(*(HANDLE *)(v4 + *v5), &Buffer, v20 - &Buffer, &v43, 0) )
          break;
        v46 += v43;
        if ( (signed int)v43 < v23 || v48 - (unsigned int)SrcCh >= nNumberOfBytesToWrite )
          goto LABEL_90;
      }
    }
  }
  else if ( WriteFile(*(HANDLE *)v17, SrcCh, nNumberOfBytesToWrite, &v43, 0) )
  {
    *(_DWORD *)DstCh = 0;
    v46 = v43;
    goto LABEL_90;
  }
LABEL_89:
  *(_DWORD *)DstCh = GetLastError();
LABEL_90:
  if ( !v46 )
    goto LABEL_91;
  return v46 - v44;
}
// 6F7DDA91: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7DEFD1: using guessed type CHAR var_410[688];

//----- (6F7DF6B0) --------------------------------------------------------
int __cdecl _write(int Filehandle, const void *a2, unsigned int nNumberOfBytesToWrite)
{
  int *v4; // ebx@7
  int v5; // esi@7
  int v6; // [sp+14h] [bp-1Ch]@9

  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0
    || Filehandle >= _nhandle
    || (v4 = &__pioinfo[Filehandle >> 5], v5 = 36 * (Filehandle & 0x1F), !(*(_BYTE *)(*v4 + v5 + 4) & 1)) )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  __lock_fhandle(Filehandle);
  if ( *(_BYTE *)(*v4 + v5 + 4) & 1 )
  {
    v6 = _write_nolock(Filehandle, (int)a2, nNumberOfBytesToWrite);
  }
  else
  {
    *_errno() = 9;
    *__doserrno() = 0;
    v6 = -1;
  }
  _unlock_fhandle(Filehandle);
  return v6;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7DF7B9) --------------------------------------------------------
int __cdecl _getbuf(int a1)
{
  void *v1; // eax@1
  int result; // eax@4

  ++_cflush;
  v1 = calloc(1u, 0x1000u);
  *(_DWORD *)(a1 + 8) = v1;
  if ( v1 )
  {
    *(_DWORD *)(a1 + 12) |= 8u;
    *(_DWORD *)(a1 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 12) |= 4u;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
  }
  result = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = result;
  return result;
}
// 6F7E8E28: using guessed type int _cflush;

//----- (6F7DF876) --------------------------------------------------------
void __cdecl _lock_file(FILE *File)
{
  if ( File < _iob || (unsigned int)File > (unsigned int)dword_6F7E6770 )
    EnterCriticalSection((LPCRITICAL_SECTION)&File[1]);
  else
    _lock(File - _iob + 16);
}
// 6F7E6770: using guessed type int dword_6F7E6770[8];

//----- (6F7DF8B0) --------------------------------------------------------
void __cdecl _unlock_file(FILE *File)
{
  if ( File < _iob || (unsigned int)File > (unsigned int)dword_6F7E6770 )
    LeaveCriticalSection((LPCRITICAL_SECTION)&File[1]);
  else
    _unlock(File - _iob + 16);
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7E6770: using guessed type int dword_6F7E6770[8];

//----- (6F7DF95A) --------------------------------------------------------
wint_t __cdecl _fputwc_nolock(wchar_t Ch, FILE *File)
{
  int *v2; // ebx@4
  int v3; // eax@4
  int *v4; // ebx@9
  int v5; // eax@9
  bool v6; // sf@12
  int v7; // eax@13
  wint_t result; // ax@16
  int v9; // eax@18
  int *v10; // ebx@24
  int v11; // eax@24
  int i; // ebx@28
  int v13; // eax@30
  int SizeConverted; // [sp+Ch] [bp-10h]@27
  char MbCh[8]; // [sp+10h] [bp-Ch]@27

  if ( File->_flag & 0x40 )
    goto LABEL_40;
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v3 = (int)__badioinfo;
  }
  else
  {
    v2 = &__pioinfo[_fileno(File) >> 5];
    v3 = *v2 + 36 * (_fileno(File) & 0x1F);
  }
  if ( (*(_DWORD *)(v3 + 8) & 3) == 2 )
    goto LABEL_40;
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v5 = (int)__badioinfo;
  }
  else
  {
    v4 = &__pioinfo[_fileno(File) >> 5];
    v5 = *v4 + 36 * (_fileno(File) & 0x1F);
  }
  if ( (*(_DWORD *)(v5 + 8) & 3) == 1 )
  {
    v6 = File->_cnt-- - 1 < 0;
    if ( v6 )
    {
      v7 = _flsbuf((char)Ch, File);
    }
    else
    {
      *File->_ptr = Ch;
      v7 = *File->_ptr++;
    }
    if ( v7 != -1 )
    {
      v6 = File->_cnt-- - 1 < 0;
      if ( v6 )
      {
        v9 = _flsbuf(SHIBYTE(Ch), File);
      }
      else
      {
        *File->_ptr = HIBYTE(Ch);
        v9 = *File->_ptr++;
      }
      if ( v9 != -1 )
        return Ch;
    }
    return -1;
  }
  if ( _fileno(File) == -1 || _fileno(File) == -2 )
  {
    v11 = (int)__badioinfo;
  }
  else
  {
    v10 = &__pioinfo[_fileno(File) >> 5];
    v11 = *v10 + 36 * (_fileno(File) & 0x1F);
  }
  if ( !(*(_BYTE *)(v11 + 4) & 0x80) )
  {
LABEL_40:
    v6 = File->_cnt - 2 < 0;
    File->_cnt -= 2;
    if ( v6 )
    {
      result = _flswbuf(Ch, File);
    }
    else
    {
      result = Ch;
      *(_WORD *)File->_ptr = Ch;
      File->_ptr += 2;
    }
  }
  else
  {
    if ( wctomb_s(&SizeConverted, MbCh, 5u, Ch) )
      return -1;
    for ( i = 0; i < SizeConverted; ++i )
    {
      v6 = File->_cnt-- - 1 < 0;
      if ( v6 )
      {
        v13 = _flsbuf(MbCh[i], File);
      }
      else
      {
        *File->_ptr = MbCh[i];
        v13 = *File->_ptr++;
      }
      if ( v13 == -1 )
        return -1;
    }
    result = Ch;
  }
  return result;
}
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7E861C: using guessed type int __badioinfo[9];
// 6F7DF95A: using guessed type char MbCh[8];

//----- (6F7DFD9F) --------------------------------------------------------
int __cdecl _output_l(FILE *File, int a2, struct localeinfo_struct *a3, int a4)
{
  FILE *v4; // ebx@1
  int v5; // esi@1
  int v6; // edi@1
  int *v8; // esi@9
  int v9; // eax@9
  int *v10; // esi@14
  int v11; // eax@14
  char v12; // cl@18
  int v13; // edx@18
  int v14; // esi@19
  int v15; // eax@21
  char v16; // al@53
  char v17; // al@67
  signed int v18; // edx@84
  int v19; // edi@86
  char *v20; // edi@86
  char *v21; // eax@89
  int v22; // edi@94
  int v23; // eax@99
  char *v24; // esi@100
  unsigned __int16 v25; // cx@101
  int v26; // eax@102
  char *v27; // eax@107
  int v28; // edx@107
  char v29; // cl@108
  int v30; // esi@119
  __int64 v31; // rax@127
  int v32; // edi@127
  int v33; // esi@134
  void *v34; // eax@134
  int v35; // eax@137
  int v36; // edi@137
  int v37; // ST18_4@137
  int v38; // ST14_4@137
  char *v39; // edi@137
  int v40; // ST10_4@137
  int v41; // ST0C_4@137
  char *v42; // ST08_4@137
  int v43; // eax@137
  int v44; // esi@137
  int v45; // eax@139
  int v46; // eax@142
  char v47; // cl@146
  unsigned int v48; // ebx@169
  unsigned int v49; // edi@169
  char *i; // esi@177
  int v51; // eax@178
  unsigned __int64 v52; // ST10_8@180
  unsigned __int64 v53; // rcx@180
  signed int v54; // ecx@180
  int v55; // eax@183
  int v56; // esi@183
  char *j; // eax@193
  int v58; // ebx@208
  FILE *v59; // edi@210
  char *v60; // esi@215
  wchar_t v61; // ax@216
  char v62; // al@227
  int v63; // [sp+Ch] [bp-278h]@137
  int v64; // [sp+10h] [bp-274h]@137
  int v65; // [sp+14h] [bp-270h]@23
  int v66; // [sp+18h] [bp-26Ch]@216
  int v67; // [sp+20h] [bp-264h]@78
  int v68; // [sp+24h] [bp-260h]@1
  FILE *v69; // [sp+28h] [bp-25Ch]@1
  int v70; // [sp+2Ch] [bp-258h]@1
  void *Memory; // [sp+30h] [bp-254h]@18
  int v72; // [sp+34h] [bp-250h]@1
  struct localeinfo_struct Locale; // [sp+38h] [bp-24Ch]@1
  int v74; // [sp+40h] [bp-244h]@4
  char v75; // [sp+44h] [bp-240h]@3
  int v76; // [sp+48h] [bp-23Ch]@1
  int v77; // [sp+4Ch] [bp-238h]@1
  int v78; // [sp+50h] [bp-234h]@1
  int v79; // [sp+54h] [bp-230h]@1
  char v80; // [sp+58h] [bp-22Ch]@155
  char v81; // [sp+59h] [bp-22Bh]@155
  int v82; // [sp+5Ch] [bp-228h]@18
  int v83; // [sp+60h] [bp-224h]@1
  int SizeConverted; // [sp+64h] [bp-220h]@18
  char *v85; // [sp+68h] [bp-21Ch]@78
  int v86; // [sp+6Ch] [bp-218h]@1
  char v87; // [sp+73h] [bp-211h]@18
  int v88; // [sp+74h] [bp-210h]@1
  char MbCh; // [sp+78h] [bp-20Ch]@78
  char v90; // [sp+277h] [bp-Dh]@177
  char v91; // [sp+278h] [bp-Ch]@216

  v4 = File;
  v5 = a2;
  v6 = a4;
  v69 = File;
  v79 = a2;
  v83 = a4;
  v70 = 0;
  v88 = 0;
  v77 = 0;
  v86 = 0;
  v78 = 0;
  v68 = 0;
  v72 = 0;
  v76 = 0;
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&Locale, a3);
  if ( !File
    || !(File->_flag & 0x40)
    && (_fileno(File) == -1 || _fileno(File) == -2 ? (v9 = (int)__badioinfo) : (v8 = &__pioinfo[_fileno(File) >> 5],
                                                                                v9 = *v8 + 36 * (_fileno(File) & 0x1F),
                                                                                v5 = v79),
        *(_BYTE *)(v9 + 8) & 3
     || (_fileno(File) == -1 || _fileno(File) == -2 ? (v11 = (int)__badioinfo) : (v10 = &__pioinfo[_fileno(File) >> 5],
                                                                                  v11 = *v10
                                                                                      + 36 * (_fileno(File) & 0x1F),
                                                                                  v5 = v79),
         *(_BYTE *)(v11 + 8) & 8))
    || !v5 )
  {
LABEL_2:
    *_errno() = 22;
    goto LABEL_3;
  }
  v12 = *(_BYTE *)v5;
  v13 = 0;
  v82 = 0;
  SizeConverted = 0;
  Memory = 0;
  v87 = v12;
  if ( !v12 )
  {
LABEL_230:
    if ( v75 )
      *(_DWORD *)(v74 + 112) &= 0xFFFFFFFD;
    return v82;
  }
  while ( 2 )
  {
    v14 = v5 + 1;
    v79 = v14;
    if ( v82 < 0 )
      goto LABEL_230;
    if ( (unsigned __int8)(v12 - 32) > 0x58u )
      v15 = 0;
    else
      v15 = *((_BYTE *)L"kernel32.dll" + v12) & 0xF;
    v65 = (signed int)LOBYTE((&(&__lookuptable)[8 * v15])[v13]) >> 4;
    switch ( v65 )
    {
      case 1:
        v86 = -1;
        v68 = 0;
        v72 = 0;
        v77 = 0;
        v78 = 0;
        v88 = 0;
        v76 = 0;
        goto LABEL_227;
      case 2:
        switch ( v12 )
        {
          case 32:
            v88 |= 2u;
            break;
          case 35:
            v88 |= 0x80u;
            break;
          case 43:
            v88 |= 1u;
            break;
          case 45:
            v88 |= 4u;
            break;
          case 48:
            v88 |= 8u;
            break;
        }
        goto LABEL_227;
      case 3:
        if ( v12 == 42 )
        {
          v83 = v6 + 4;
          v77 = *(_DWORD *)v6;
          if ( v77 < 0 )
          {
            v88 |= 4u;
            v77 = -v77;
          }
        }
        else
        {
          v77 = 10 * v77 + v12 - 48;
        }
        goto LABEL_227;
      case 4:
        v86 = 0;
        goto LABEL_227;
      case 5:
        if ( v12 == 42 )
        {
          v83 = v6 + 4;
          v86 = *(_DWORD *)v6;
          if ( v86 < 0 )
            v86 = -1;
        }
        else
        {
          v86 = 10 * v86 + v12 - 48;
        }
        goto LABEL_227;
      case 6:
        switch ( v12 )
        {
          case 73:
            v16 = *(_BYTE *)v14;
            if ( *(_BYTE *)v14 != 54 || *(_BYTE *)(v14 + 1) != 52 )
            {
              if ( v16 != 51 || *(_BYTE *)(v14 + 1) != 50 )
              {
                if ( v16 != 100 && v16 != 105 && v16 != 111 && v16 != 117 && v16 != 120 && v16 != 88 )
                {
                  v65 = 0;
LABEL_66:
                  v76 = 0;
                  if ( _isleadbyte_l((unsigned __int8)v12, &Locale) )
                  {
                    write_char(v4);
                    v17 = *(_BYTE *)v79++;
                    if ( !v17 )
                      goto LABEL_2;
                  }
                  write_char(v4);
                }
              }
              else
              {
                v88 &= 0xFFFF7FFF;
                v79 = v14 + 2;
              }
            }
            else
            {
              v88 |= 0x8000u;
              v79 = v14 + 2;
            }
            break;
          case 104:
            v88 |= 0x20u;
            break;
          case 108:
            if ( *(_BYTE *)v14 == 108 )
            {
              v88 |= 0x1000u;
              v79 = v14 + 1;
            }
            else
            {
              v88 |= 0x10u;
            }
            break;
          case 119:
            v88 |= 0x800u;
            break;
        }
        goto LABEL_227;
      case 0:
        goto LABEL_66;
      case 7:
        if ( v12 > 100 )
        {
          if ( v12 > 112 )
          {
            if ( v12 == 115 )
              goto LABEL_84;
            if ( v12 != 117 )
            {
              if ( v12 != 120 )
                goto LABEL_199;
              v70 = 39;
              goto LABEL_154;
            }
          }
          else
          {
            if ( v12 == 112 )
            {
              v86 = 8;
              goto LABEL_149;
            }
            if ( v12 < 101 )
              goto LABEL_199;
            if ( v12 <= 103 )
              goto LABEL_78;
            if ( v12 != 105 )
            {
              if ( v12 == 110 )
              {
                v30 = *(_DWORD *)v6;
                v83 = v6 + 4;
                if ( !_get_printf_count_output() )
                  goto LABEL_2;
                if ( v88 & 0x20 )
                  *(_WORD *)v30 = v82;
                else
                  *(_DWORD *)v30 = v82;
                v72 = 1;
                goto LABEL_225;
              }
              if ( v12 != 111 )
                goto LABEL_199;
              SizeConverted = 8;
              if ( v88 & 0x80 )
                v88 |= 0x200u;
LABEL_126:
              if ( v88 & 0x8000 || v88 & 0x1000 )
              {
                v31 = *(_QWORD *)v6;
                v32 = v6 + 8;
              }
              else
              {
                v32 = v6 + 4;
                if ( v88 & 0x20 )
                {
                  v83 = v32;
                  if ( v88 & 0x40 )
                    LODWORD(v31) = *(_WORD *)(v32 - 4);
                  else
                    LODWORD(v31) = *(_WORD *)(v32 - 4);
                  v31 = (signed int)v31;
LABEL_166:
                  if ( v88 & 0x40 && v31 < 0 )
                  {
                    v31 = -v31;
                    v88 |= 0x100u;
                  }
                  v48 = HIDWORD(v31);
                  v49 = v31;
                  if ( !(v88 & 0x9000) )
                    v48 = 0;
                  if ( v86 >= 0 )
                  {
                    v88 &= 0xFFFFFFF7;
                    if ( v86 > 512 )
                      v86 = 512;
                  }
                  else
                  {
                    v86 = 1;
                  }
                  if ( !(v48 | (unsigned int)v31) )
                    v78 = 0;
                  for ( i = &v90; ; --i )
                  {
                    v51 = v86--;
                    if ( v51 <= 0 && !(v48 | v49) )
                      break;
                    v52 = __PAIR__(v48, v49);
                    v53 = __PAIR__(v48, v49) % SizeConverted;
                    v54 = v53 + 48;
                    v67 = HIDWORD(v53);
                    v48 = v52 / SizeConverted >> 32;
                    v49 = v52 / SizeConverted;
                    if ( v54 > 57 )
                      LOBYTE(v54) = v70 + v54;
                    *i = v54;
                  }
                  v55 = &v90 - i;
                  v56 = (int)(i + 1);
                  SizeConverted = v55;
                  v85 = (char *)v56;
                  if ( v88 & 0x200 && (!v55 || *(_BYTE *)v56 != 48) )
                  {
                    --v85;
                    *v85 = 48;
                    v26 = v55 + 1;
                    goto LABEL_198;
                  }
                  goto LABEL_199;
                }
                LODWORD(v31) = *(_DWORD *)(v32 - 4);
                if ( v88 & 0x40 )
                  v31 = (signed int)v31;
                else
                  HIDWORD(v31) = 0;
              }
              v83 = v32;
              goto LABEL_166;
            }
LABEL_124:
            v88 |= 0x40u;
          }
          SizeConverted = 10;
          goto LABEL_126;
        }
        if ( v12 == 100 )
          goto LABEL_124;
        if ( v12 <= 83 )
        {
          if ( v12 == 83 )
          {
            if ( !(v88 & 0x830) )
              v88 |= 0x800u;
LABEL_84:
            v18 = v86;
            if ( v86 == -1 )
              v18 = 0x7FFFFFFF;
            v19 = v6 + 4;
            v83 = v19;
            v20 = *(char **)(v19 - 4);
            v85 = v20;
            if ( v88 & 0x810 )
            {
              if ( !v20 )
                v85 = (char *)__wnullstring;
              v21 = v85;
              v76 = 1;
              while ( v18 )
              {
                --v18;
                if ( !*(_WORD *)v21 )
                  break;
                v21 += 2;
              }
              v26 = (v21 - v85) >> 1;
            }
            else
            {
              if ( !v20 )
                v85 = __nullstring;
              for ( j = v85; ; ++j )
              {
                if ( v18 )
                {
                  --v18;
                  if ( *j )
                    continue;
                }
                break;
              }
              v26 = j - v85;
            }
            goto LABEL_198;
          }
          if ( v12 == 65 )
            goto LABEL_77;
          if ( v12 == 67 )
          {
            if ( !(v88 & 0x830) )
              v88 |= 0x800u;
LABEL_94:
            v22 = v6 + 4;
            v83 = v22;
            if ( v88 & 0x810 )
            {
              if ( wctomb_s(&SizeConverted, &MbCh, 0x200u, *(_WORD *)(v22 - 4)) )
                v72 = 1;
            }
            else
            {
              MbCh = *(_BYTE *)(v22 - 4);
              SizeConverted = 1;
            }
            v85 = &MbCh;
            goto LABEL_199;
          }
          if ( v12 == 69 || v12 == 71 )
          {
LABEL_77:
            v12 += 32;
            v68 = 1;
            v87 = v12;
LABEL_78:
            v88 |= 0x40u;
            v85 = &MbCh;
            v67 = 512;
            if ( v86 >= 0 )
            {
              if ( v86 )
              {
                if ( v86 > 512 )
                  v86 = 512;
                if ( v86 > 163 )
                {
                  v33 = v86 + 349;
                  v34 = malloc(v86 + 349);
                  v12 = v87;
                  Memory = v34;
                  if ( v34 )
                  {
                    v85 = (char *)v34;
                    v67 = v33;
                  }
                  else
                  {
                    v86 = 163;
                  }
                }
              }
              else if ( v12 == 103 )
              {
                v86 = 1;
              }
            }
            else
            {
              v86 = 6;
            }
            v35 = *(_DWORD *)v6;
            v36 = v6 + 8;
            v63 = v35;
            v64 = *(_DWORD *)(v36 - 4);
            v37 = v68;
            v38 = v86;
            v83 = v36;
            v39 = v85;
            v40 = v12;
            v41 = v67;
            v42 = v85;
            v43 = _decode_pointer((int)off_6F7E6018[0]);
            ((void (__cdecl *)(int *, char *, int, int, int, int, struct localeinfo_struct *))v43)(
              &v63,
              v42,
              v41,
              v40,
              v38,
              v37,
              &Locale);
            v44 = v88 & 0x80;
            if ( v88 & 0x80 && !v86 )
            {
              v45 = _decode_pointer((int)off_6F7E6024);
              ((void (__cdecl *)(char *, struct localeinfo_struct *))v45)(v39, &Locale);
            }
            if ( v87 == 103 && !v44 )
            {
              v46 = _decode_pointer((int)off_6F7E6020[0]);
              ((void (__cdecl *)(char *, struct localeinfo_struct *))v46)(v39, &Locale);
            }
            if ( *v39 == 45 )
            {
              v88 |= 0x100u;
              ++v39;
              v85 = v39;
            }
            v27 = v39;
            v28 = (int)(v39 + 1);
            do
              v47 = *v27++;
            while ( v47 );
LABEL_109:
            v26 = (int)&v27[-v28];
LABEL_198:
            SizeConverted = v26;
          }
LABEL_199:
          if ( !v72 )
          {
            if ( v88 & 0x40 )
            {
              if ( v88 & 0x100 )
              {
                v80 = 45;
LABEL_207:
                v78 = 1;
                goto LABEL_208;
              }
              if ( v88 & 1 )
              {
                v80 = 43;
                goto LABEL_207;
              }
              if ( v88 & 2 )
              {
                v80 = 32;
                goto LABEL_207;
              }
            }
LABEL_208:
            v58 = v77 - SizeConverted - v78;
            if ( !(v88 & 0xC) )
              write_multi_char(32, v77 - SizeConverted - v78, v69);
            v59 = v69;
            write_string(v78);
            if ( v88 & 8 && !(v88 & 4) )
              write_multi_char(48, v58, v59);
            if ( v76 && SizeConverted > 0 )
            {
              v60 = v85;
              v67 = SizeConverted;
              while ( 1 )
              {
                v61 = *(_WORD *)v60;
                --v67;
                v60 += 2;
                if ( wctomb_s(&v66, &v91, 6u, v61) || !v66 )
                  break;
                write_string(v66);
                if ( !v67 )
                  goto LABEL_222;
              }
              v82 = -1;
            }
            else
            {
              write_string(SizeConverted);
            }
LABEL_222:
            if ( v82 >= 0 && v88 & 4 )
              write_multi_char(32, v58, v59);
          }
LABEL_225:
          if ( Memory )
          {
            free(Memory);
            Memory = 0;
          }
LABEL_227:
          v5 = v79;
          v62 = *(_BYTE *)v79;
          v87 = v62;
          if ( !v62 )
            goto LABEL_230;
          v13 = v65;
          v4 = v69;
          v6 = v83;
          v12 = v62;
          continue;
        }
        if ( v12 == 88 )
        {
LABEL_149:
          v70 = 7;
LABEL_154:
          SizeConverted = 16;
          if ( v88 & 0x80 )
          {
            v80 = 48;
            v81 = v70 + 81;
            v78 = 2;
          }
          goto LABEL_126;
        }
        if ( v12 != 90 )
        {
          if ( v12 == 97 )
            goto LABEL_78;
          if ( v12 != 99 )
            goto LABEL_199;
          goto LABEL_94;
        }
        v23 = *(_DWORD *)v6;
        v83 = v6 + 4;
        if ( !v23 || (v24 = *(char **)(v23 + 4)) == 0 )
        {
          v27 = __nullstring;
          v85 = __nullstring;
          v28 = (int)(__nullstring + 1);
          do
            v29 = *v27++;
          while ( v29 );
          goto LABEL_109;
        }
        v25 = *(_WORD *)v23;
        if ( *(_WORD *)(v23 + 2) < *(_WORD *)v23 )
          goto LABEL_229;
        v26 = v25;
        if ( !(v88 & 0x800) )
        {
          v76 = 0;
          v85 = v24;
          goto LABEL_198;
        }
        if ( ~(_BYTE)v25 & 1 && ~(_BYTE)v24 & 1 )
        {
          v85 = v24;
          v26 = (unsigned int)v25 >> 1;
          v76 = 1;
          goto LABEL_198;
        }
LABEL_229:
        *_errno() = 22;
LABEL_3:
        _invalid_parameter(0, 0, 0, 0, 0);
        if ( v75 )
          *(_DWORD *)(v74 + 112) &= 0xFFFFFFFD;
        return -1;
      default:
        goto LABEL_227;
    }
  }
}
// 6F792FF0: using guessed type const char *const __lookuptable;
// 6F7DFD4D: using guessed type int __cdecl write_string(_DWORD);
// 6F7E6018: using guessed type int (*off_6F7E6018[4])();
// 6F7E6020: using guessed type int (*off_6F7E6020[2])();
// 6F7E6024: using guessed type int (*off_6F7E6024)();
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7E6834: using guessed type char *__nullstring;
// 6F7E6848: using guessed type unsigned __int16 *__wnullstring;
// 6F7E861C: using guessed type int __badioinfo[9];

//----- (6F7E1000) --------------------------------------------------------
int __cdecl sub_6F7E1000(LCID Locale, DWORD dwMapFlags, wchar_t *Src, size_t MaxCount, LPWSTR lpDestStr, int cchDest, UINT CodePage)
{
  int v7; // ecx@0
  const char *v8; // ebx@1
  int v9; // edi@1
  UINT v11; // eax@16
  unsigned int v12; // eax@19
  int v13; // edi@19
  int v14; // eax@23
  void *v15; // esp@24
  CHAR *v16; // eax@24
  int v17; // eax@33
  int v18; // esi@33
  int v19; // eax@36
  void *v20; // esp@37
  void *v21; // eax@37
  int v22; // eax@52
  signed int v23; // [sp+0h] [bp-1Ch]@24
  int cchSrc; // [sp+Ch] [bp-10h]@19
  int v25; // [sp+10h] [bp-Ch]@12
  LPSTR lpMultiByteStr; // [sp+14h] [bp-8h]@29

  v8 = 0;
  v9 = v7;
  if ( !dword_6F7E8E30 )
  {
    if ( LCMapStringW(0, 0x100u, &SrcStr, 1, 0, 0) )
    {
      dword_6F7E8E30 = 1;
    }
    else if ( GetLastError() == 120 )
    {
      dword_6F7E8E30 = 2;
    }
  }
  if ( (signed int)MaxCount > 0 )
    MaxCount = wcsnlen(Src, MaxCount);
  if ( dword_6F7E8E30 == 1 )
    return LCMapStringW(Locale, dwMapFlags, Src, MaxCount, lpDestStr, cchDest);
  if ( dword_6F7E8E30 != 2 && dword_6F7E8E30 )
    return 0;
  v25 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)v9 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)v9 + 4);
  v11 = __ansicp(Locale);
  if ( CodePage != v11 && v11 != -1 )
    CodePage = v11;
  v12 = WideCharToMultiByte(CodePage, 0, Src, MaxCount, 0, 0, 0, 0);
  v13 = v12;
  cchSrc = v12;
  if ( !v12 )
    return 0;
  if ( (signed int)v12 > 0 && 0xFFFFFFE0 / v12 >= 1 )
  {
    v14 = v12 + 8;
    if ( (unsigned int)(v13 + 8) > 0x400 )
    {
      v16 = (CHAR *)malloc(v13 + 8);
      if ( v16 )
      {
        *(_DWORD *)v16 = 56797;
        goto LABEL_28;
      }
    }
    else
    {
      v15 = alloca(v14);
      v16 = (CHAR *)&v23;
      if ( &v23 )
      {
        v23 = 52428;
LABEL_28:
        v16 += 8;
        goto LABEL_29;
      }
    }
LABEL_29:
    lpMultiByteStr = v16;
    goto LABEL_31;
  }
  lpMultiByteStr = 0;
LABEL_31:
  if ( !lpMultiByteStr )
    return 0;
  if ( WideCharToMultiByte(CodePage, 0, Src, MaxCount, lpMultiByteStr, v13, 0, 0) )
  {
    v17 = LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, v13, 0, 0);
    v18 = v17;
    if ( v17 )
    {
      if ( v17 <= 0 || 0xFFFFFFE0 / v17 < 1 )
      {
LABEL_43:
        if ( v8 )
        {
          if ( LCMapStringA(Locale, dwMapFlags, lpMultiByteStr, cchSrc, (LPSTR)v8, v18) )
          {
            if ( dwMapFlags & 0x400 )
            {
              v25 = v18;
              if ( cchDest )
              {
                if ( cchDest <= v18 )
                  v18 = cchDest - 1;
                if ( strncpy_s((char *)lpDestStr, cchDest, v8, v18) )
                  _invoke_watson(0, 0, 0, 0, 0);
              }
            }
            else
            {
              if ( cchDest )
                v22 = MultiByteToWideChar(CodePage, 1u, v8, v18, lpDestStr, cchDest);
              else
                v22 = MultiByteToWideChar(CodePage, 1u, v8, v18, 0, 0);
              v25 = v22;
            }
          }
          _freea((void *)v8);
        }
        goto LABEL_56;
      }
      v19 = v17 + 8;
      if ( (unsigned int)(v18 + 8) > 0x400 )
      {
        v21 = malloc(v18 + 8);
        if ( v21 )
        {
          *(_DWORD *)v21 = 56797;
          goto LABEL_41;
        }
      }
      else
      {
        v20 = alloca(v19);
        v21 = &v23;
        if ( &v23 )
        {
          v23 = 52428;
LABEL_41:
          v21 = (char *)v21 + 8;
          goto LABEL_42;
        }
      }
LABEL_42:
      v8 = (const char *)v21;
      goto LABEL_43;
    }
  }
LABEL_56:
  _freea(lpMultiByteStr);
  return v25;
}
// 6F7E8E30: using guessed type int dword_6F7E8E30;

//----- (6F7E1332) --------------------------------------------------------
int __cdecl __crtMessageBoxA(int a1, int a2, int a3)
{
  HMODULE v3; // eax@2
  HMODULE v4; // edi@2
  int v6; // eax@4
  int v7; // eax@5
  int v8; // eax@5
  int v9; // eax@8
  int v10; // eax@9
  int v11; // esi@10
  int v12; // eax@12
  LPCSTR lpProcName; // ST14_4@12
  int v14; // eax@12
  int v15; // ST04_4@13
  int v16; // eax@13
  int v17; // ST00_4@13
  int v18; // eax@21
  LPCSTR v19; // ST14_4@21
  LPCSTR v20; // ST14_4@23
  int v21; // eax@23
  int v22; // ST10_4@23
  int v23; // ST08_4@24
  int v24; // eax@24
  int v25; // ST04_4@24
  char v26; // [sp+10h] [bp-20h]@13
  char v27; // [sp+18h] [bp-18h]@14
  char v28; // [sp+1Ch] [bp-14h]@13
  int v29; // [sp+20h] [bp-10h]@1
  unsigned int v30; // [sp+24h] [bp-Ch]@1
  int v31; // [sp+28h] [bp-8h]@1
  int v32; // [sp+2Ch] [bp-4h]@1

  v29 = _encoded_null();
  v32 = 0;
  v31 = 0;
  v30 = 0;
  if ( !dword_6F7E8E34 )
  {
    v3 = LoadLibraryExA("USER32.DLL", 0, 0);
    v4 = v3;
    if ( !v3 )
      return 0;
    v6 = (int)GetProcAddress(v3, "MessageBoxA");
    if ( !v6 )
      return 0;
    dword_6F7E8E34 = _encode_pointer(v6);
    v7 = (int)GetProcAddress(v4, "GetActiveWindow");
    dword_6F7E8E38 = _encode_pointer(v7);
    v8 = (int)GetProcAddress(v4, "GetLastActivePopup");
    dword_6F7E8E3C = _encode_pointer(v8);
    if ( _get_osplatform((int)&v31) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v31 == 2 )
    {
      v9 = (int)GetProcAddress(v4, "GetUserObjectInformationA");
      dword_6F7E8E44 = _encode_pointer(v9);
      if ( dword_6F7E8E44 )
      {
        v10 = (int)GetProcAddress(v4, "GetProcessWindowStation");
        dword_6F7E8E40 = _encode_pointer(v10);
      }
    }
  }
  v11 = v29;
  if ( dword_6F7E8E40 == v29
    || dword_6F7E8E44 == v29
    || (v12 = _decode_pointer(dword_6F7E8E40), (v14 = ((int (__thiscall *)(LPCSTR))v12)(lpProcName)) != 0)
    && (v15 = v14,
        v16 = _decode_pointer(dword_6F7E8E44),
        ((int (__thiscall *)(int, int, signed int, char *, signed int, char *))v16)(v17, v15, 1, &v26, 12, &v28))
    && v27 & 1 )
  {
    if ( dword_6F7E8E38 != v11 )
    {
      v18 = _decode_pointer(dword_6F7E8E38);
      v32 = ((int (__thiscall *)(LPCSTR))v18)(v19);
      if ( v32 )
      {
        if ( dword_6F7E8E3C != v11 )
        {
          v20 = (LPCSTR)v32;
          v21 = _decode_pointer(dword_6F7E8E3C);
          v32 = ((int (__thiscall *)(int, LPCSTR))v21)(v22, v20);
        }
      }
    }
  }
  else
  {
    if ( _get_winmajor((int)&v30) )
      _invoke_watson(0, 0, 0, 0, 0);
    if ( v30 < 4 )
      a3 |= 0x40000u;
    else
      a3 |= 0x200000u;
  }
  v23 = v32;
  v24 = _decode_pointer(dword_6F7E8E34);
  return ((int (__thiscall *)(int, int, int, int, int))v24)(v25, v23, a1, a2, a3);
}
// 6F774E45: using guessed type int _encoded_null(void);
// 6F7E8E34: using guessed type int dword_6F7E8E34;
// 6F7E8E38: using guessed type int dword_6F7E8E38;
// 6F7E8E3C: using guessed type int dword_6F7E8E3C;
// 6F7E8E40: using guessed type int dword_6F7E8E40;
// 6F7E8E44: using guessed type int dword_6F7E8E44;

//----- (6F7E1747) --------------------------------------------------------
__int32 __cdecl _get_osfhandle(int a1)
{
  int v2; // eax@7

  if ( a1 == -1 )
    goto LABEL_2;
  if ( a1 == -2 )
  {
    *__doserrno() = 0;
LABEL_2:
    *_errno() = 9;
    return -1;
  }
  if ( a1 < 0 || a1 >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    v2 = __pioinfo[a1 >> 5] + 36 * (a1 & 0x1F);
    if ( *(_BYTE *)(v2 + 4) & 1 )
      return *(_DWORD *)v2;
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
  }
  return -1;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E17DE) --------------------------------------------------------
int __cdecl __lock_fhandle(int Filehandle)
{
  int v1; // esi@1
  int v3; // [sp+10h] [bp-1Ch]@1

  v1 = __pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F);
  v3 = 1;
  if ( !(*(_BYTE *)(v1 + 8) & 4) )
  {
    _lock(10);
    if ( !(*(_BYTE *)(v1 + 8) & 4) )
    {
      if ( !__crtInitCritSecAndSpinCount(v1 + 12, 4000) )
        v3 = 0;
      *(_DWORD *)(v1 + 8) |= 4u;
    }
    _unlock(10);
  }
  if ( v3 )
    EnterCriticalSection((LPCRITICAL_SECTION)(__pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F) + 12));
  return v3;
}
// 6F7717B9: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E18A9) --------------------------------------------------------
void __cdecl _unlock_fhandle(int Filehandle)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(__pioinfo[Filehandle >> 5] + 36 * (Filehandle & 0x1F) + 12));
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E199F) --------------------------------------------------------
int __cdecl _flswbuf(int a1, FILE *File)
{
  int v2; // esi@1
  int v3; // eax@1
  unsigned int v5; // eax@9
  const void *v6; // eax@15
  int v7; // edi@15
  unsigned int v8; // edi@15
  int v9; // eax@20
  __int64 v10; // rax@23
  unsigned __int16 v11; // bx@24
  int v12; // [sp+4h] [bp-4h]@9
  signed int Filea; // [sp+14h] [bp+Ch]@1

  v2 = (int)File;
  Filea = _fileno(File);
  v3 = *(_DWORD *)(v2 + 12);
  if ( !(v3 & 0x82) )
  {
    *_errno() = 9;
LABEL_3:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return 0xFFFF;
  }
  if ( v3 & 0x40 )
  {
    *_errno() = 34;
    goto LABEL_3;
  }
  if ( v3 & 1 )
  {
    *(_DWORD *)(v2 + 4) = 0;
    if ( !(v3 & 0x10) )
    {
      *(_DWORD *)(v2 + 12) = v3 | 0x20;
      return 0xFFFF;
    }
    *(_DWORD *)v2 = *(_DWORD *)(v2 + 8);
    *(_DWORD *)(v2 + 12) = v3 & 0xFFFFFFFE;
  }
  v5 = *(_DWORD *)(v2 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v2 + 12) = v5;
  *(_DWORD *)(v2 + 4) = 0;
  v12 = 0;
  if ( !(v5 & 0x10C) && ((int *)v2 != dword_6F7E6530 && (int *)v2 != dword_6F7E6550 || !_isatty(Filea)) )
    _getbuf(v2);
  if ( *(_DWORD *)(v2 + 12) & 0x108 )
  {
    v6 = *(const void **)(v2 + 8);
    v7 = *(_DWORD *)v2;
    *(_DWORD *)v2 = (char *)v6 + 2;
    v8 = v7 - (_DWORD)v6;
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(v2 + 24) - 2;
    if ( (signed int)v8 <= 0 )
    {
      if ( Filea == -1 || Filea == -2 )
        v9 = (int)__badioinfo;
      else
        v9 = __pioinfo[Filea >> 5] + 36 * (Filea & 0x1F);
      if ( *(_BYTE *)(v9 + 4) & 0x20 )
      {
        v10 = _lseeki64(Filea, 0i64, 2);
        if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      v12 = _write(Filea, v6, v8);
    }
    v11 = a1;
    **(_WORD **)(v2 + 8) = a1;
  }
  else
  {
    v11 = a1;
    v8 = 2;
    LOWORD(v12) = a1;
    v12 = _write(Filea, &v12, 2u);
  }
  if ( v12 != v8 )
  {
LABEL_27:
    *(_DWORD *)(v2 + 12) |= 0x20u;
    return 0xFFFF;
  }
  return v11;
}
// 6F7E6400: using guessed type int __pioinfo[];
// 6F7E6530: using guessed type int dword_6F7E6530[3];
// 6F7E6550: using guessed type int dword_6F7E6550[3];
// 6F7E861C: using guessed type int __badioinfo[9];

//----- (6F7E1CF2) --------------------------------------------------------
void *__cdecl __convertcp(UINT CodePage, UINT a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@6
  bool v7; // zf@8
  bool v8; // sf@8
  int v9; // eax@11
  void *v10; // esp@12
  void *v11; // eax@12
  LPSTR v13; // edi@23
  void *v14; // eax@28
  int v15; // eax@29
  signed int v16; // [sp+0h] [bp-40h]@12
  LPSTR v17; // [sp+Ch] [bp-34h]@1
  int v18; // [sp+10h] [bp-30h]@1
  int v19; // [sp+14h] [bp-2Ch]@1
  LPCSTR lpMultiByteStr; // [sp+18h] [bp-28h]@1
  int cbMultiByte; // [sp+1Ch] [bp-24h]@1
  void *Memory; // [sp+20h] [bp-20h]@1
  void *Dst; // [sp+24h] [bp-1Ch]@19
  struct _cpinfo CPInfo; // [sp+28h] [bp-18h]@2

  lpMultiByteStr = (LPCSTR)a3;
  v18 = a4;
  cbMultiByte = *(_DWORD *)a4;
  v17 = (LPSTR)a5;
  Memory = 0;
  v19 = 0;
  if ( CodePage != a2 )
  {
    if ( GetCPInfo(CodePage, &CPInfo) && CPInfo.MaxCharSize == 1 && GetCPInfo(a2, &CPInfo) && CPInfo.MaxCharSize == 1 )
    {
      v6 = cbMultiByte;
      v19 = 1;
      if ( cbMultiByte == -1 )
        v6 = strlen(lpMultiByteStr) + 1;
      v7 = v6 == 0;
      v8 = v6 < 0;
    }
    else
    {
      v6 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, 0, 0);
      v7 = v6 == 0;
      v8 = v6 < 0;
      if ( !v6 )
        return 0;
    }
    if ( v8 || v7 || (unsigned int)v6 > 0x7FFFFFF0 )
    {
      Dst = 0;
LABEL_21:
      if ( Dst )
      {
        memset(Dst, 0, 2 * v6);
        if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)Dst, v6) )
        {
          v13 = v17;
          if ( v17 )
          {
            if ( WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, v17, a6, 0, 0) )
              Memory = v13;
          }
          else if ( v19 || (v6 = WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, 0, 0, 0, 0)) != 0 )
          {
            v14 = calloc(1u, v6);
            Memory = v14;
            if ( v14 )
            {
              v15 = WideCharToMultiByte(a2, 0, (LPCWSTR)Dst, v6, (LPSTR)v14, v6, 0, 0);
              if ( v15 )
              {
                if ( cbMultiByte != -1 )
                  *(_DWORD *)v18 = v15;
              }
              else
              {
                free(Memory);
                Memory = 0;
              }
            }
          }
        }
        _freea(Dst);
        return Memory;
      }
      return 0;
    }
    v9 = 2 * v6 + 8;
    if ( (unsigned int)v9 > 0x400 )
    {
      v11 = malloc(2 * v6 + 8);
      if ( v11 )
      {
        *(_DWORD *)v11 = 56797;
        goto LABEL_18;
      }
    }
    else
    {
      v10 = alloca(v9);
      v11 = &v16;
      if ( &v16 )
      {
        v16 = 52428;
LABEL_18:
        v11 = (char *)v11 + 8;
        goto LABEL_19;
      }
    }
LABEL_19:
    Dst = v11;
    goto LABEL_21;
  }
  return Memory;
}

//----- (6F7E1EB1) --------------------------------------------------------
int __cdecl _resetstkoflw()
{
  void *v0; // esp@3
  DWORD v1; // ebx@4
  DWORD v2; // edi@4
  HMODULE v3; // eax@5
  FARPROC v4; // eax@7
  ULONG v5; // esi@16
  int result; // eax@21
  int v7; // [sp-4h] [bp-6Ch]@3
  struct _SYSTEM_INFO SystemInfo; // [sp+Ch] [bp-5Ch]@4
  struct _MEMORY_BASIC_INFORMATION Buffer; // [sp+30h] [bp-38h]@3
  DWORD flOldProtect; // [sp+4Ch] [bp-1Ch]@20
  PVOID v11; // [sp+50h] [bp-18h]@4
  LPCVOID lpAddress; // [sp+54h] [bp-14h]@3
  ULONG v13; // [sp+58h] [bp-10h]@5
  int v14; // [sp+5Ch] [bp-Ch]@1
  ULONG ulAugend; // [sp+60h] [bp-8h]@4

  v14 = 0;
  if ( _get_osplatform((int)&v14) )
    _invoke_watson(0, 0, 0, 0, 0);
  v0 = alloca(4);
  lpAddress = &v7;
  if ( !VirtualQuery(&v7, &Buffer, 0x1Cu) )
    goto LABEL_25;
  v11 = Buffer.AllocationBase;
  GetSystemInfo(&SystemInfo);
  v1 = SystemInfo.dwPageSize;
  v2 = v14 != 1 ? 260 : 1;
  ulAugend = 0;
  if ( v14 == 2 )
  {
    v13 = 0;
    v3 = GetModuleHandleW(L"kernelbase.dll");
    if ( v3 || (v3 = GetModuleHandleW(L"kernel32.dll")) != 0 )
    {
      v4 = GetProcAddress(v3, "SetThreadStackGuarantee");
      if ( v4 )
      {
        v13 = 0;
        if ( ((int (__stdcall *)(ULONG *))v4)(&v13) == 1 )
        {
          if ( v13 )
            ulAugend = v13;
        }
      }
    }
  }
  if ( ULongAdd(ulAugend, v1 - 1, &ulAugend) < 0 )
    goto LABEL_25;
  ulAugend &= ~(v1 - 1);
  if ( ulAugend )
  {
    if ( ULongAdd(ulAugend, v1, &ulAugend) < 0 )
      goto LABEL_25;
  }
  if ( ulAugend < 2 * v1 )
    ulAugend = 2 * v1;
  v5 = ((unsigned int)lpAddress & ~(v1 - 1)) - ulAugend;
  if ( v14 == 1 )
    v1 = 17;
  if ( v5 >= (unsigned int)((char *)v11 + v1)
    && VirtualAlloc((LPVOID)v5, ulAugend, 0x1000u, 4u)
    && VirtualProtect((LPVOID)v5, ulAugend, v2, &flOldProtect) )
    result = 1;
  else
LABEL_25:
    result = 0;
  return result;
}

//----- (6F7E2035) --------------------------------------------------------
__int32 __cdecl atol(const char *Str)
{
  __int32 result; // eax@2

  if ( Str )
    result = strtolX((int)Str, 0, 10, 1);
  else
    result = 0;
  return result;
}

//----- (6F7E2080) --------------------------------------------------------
int __cdecl sub_6F7E2080(int a1, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale)
{
  signed int v8; // eax@3
  UINT v9; // eax@17
  unsigned int v10; // eax@20
  size_t v11; // esi@20
  int v12; // eax@23
  void *v13; // esp@24
  void *v14; // eax@24
  int v15; // eax@35
  void *v16; // esp@36
  WORD *v17; // eax@36
  WORD *v18; // ST1C_4@46
  int v19; // ST18_4@46
  const CHAR *v20; // ST14_4@46
  WORD *v21; // esi@46
  signed int v22; // [sp+0h] [bp-20h]@24
  int v23; // [sp+Ch] [bp-14h]@20
  int v24; // [sp+10h] [bp-10h]@13
  LPWORD v25; // [sp+14h] [bp-Ch]@41
  WORD CharType[2]; // [sp+18h] [bp-8h]@4

  if ( cchSrc < -1 )
    return 0;
  v8 = dword_6F7E8E48;
  if ( !dword_6F7E8E48 )
  {
    if ( GetStringTypeW(1u, &SrcStr, 1, CharType) )
    {
      dword_6F7E8E48 = 1;
      return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
    }
    if ( GetLastError() == 120 )
    {
      v8 = 2;
      dword_6F7E8E48 = 2;
    }
    else
    {
      v8 = dword_6F7E8E48;
    }
  }
  if ( v8 == 1 )
    return GetStringTypeW(dwInfoType, lpSrcStr, cchSrc, lpCharType);
  if ( v8 != 2 && v8 )
    return 0;
  v24 = 0;
  if ( !Locale )
    Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( !CodePage )
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
  v9 = __ansicp(Locale);
  if ( CodePage != v9 && v9 != -1 )
    CodePage = v9;
  v10 = WideCharToMultiByte(CodePage, 0, lpSrcStr, cchSrc, 0, 0, 0, 0);
  v11 = v10;
  v23 = v10;
  if ( !v10 )
    return 0;
  if ( (signed int)v10 > 0 && v10 <= 0xFFFFFFE0 )
  {
    v12 = v10 + 8;
    if ( v11 + 8 > 0x400 )
    {
      v14 = malloc(v11 + 8);
      if ( v14 )
      {
        *(_DWORD *)v14 = 56797;
        goto LABEL_28;
      }
    }
    else
    {
      v13 = alloca(v12);
      v14 = &v22;
      if ( &v22 )
      {
        v22 = 52428;
LABEL_28:
        v14 = (char *)v14 + 8;
        goto LABEL_29;
      }
    }
LABEL_29:
    *(_DWORD *)CharType = v14;
    goto LABEL_31;
  }
  *(_DWORD *)CharType = 0;
LABEL_31:
  if ( !*(_DWORD *)CharType )
    return 0;
  memset(*(void **)CharType, 0, v11);
  if ( !WideCharToMultiByte(CodePage, 0, lpSrcStr, cchSrc, *(LPSTR *)CharType, v11, 0, 0) )
    goto LABEL_51;
  if ( (signed int)(v11 + 1) > 0 && v11 + 1 <= 0x7FFFFFF0 )
  {
    v15 = 2 * v11 + 10;
    if ( (unsigned int)v15 > 0x400 )
    {
      v17 = (WORD *)malloc(2 * v11 + 10);
      if ( v17 )
      {
        *(_DWORD *)v17 = 56797;
        goto LABEL_40;
      }
    }
    else
    {
      v16 = alloca(v15);
      v17 = (WORD *)&v22;
      if ( &v22 )
      {
        v22 = 52428;
LABEL_40:
        v17 += 4;
        goto LABEL_41;
      }
    }
LABEL_41:
    v25 = v17;
    goto LABEL_43;
  }
  v25 = 0;
LABEL_43:
  if ( v25 )
  {
    if ( !Locale )
      Locale = *(_DWORD *)(*(_DWORD *)a1 + 20);
    v18 = v25;
    v19 = v23;
    v20 = *(const CHAR **)CharType;
    v21 = &v25[cchSrc];
    *v21 = -1;
    *(v21 - 1) = -1;
    v24 = GetStringTypeA(Locale, dwInfoType, v20, v19, v18);
    if ( *(v21 - 1) == -1 || *v21 != -1 )
      v24 = 0;
    else
      memmove(lpCharType, v25, 2 * cchSrc);
    _freea(v25);
  }
LABEL_51:
  _freea(*(void **)CharType);
  return v24;
}
// 6F7E8E48: using guessed type int dword_6F7E8E48;

//----- (6F7E22AE) --------------------------------------------------------
int __cdecl __crtGetStringTypeW(struct localeinfo_struct *a1, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale)
{
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@1
  int v9; // [sp+8h] [bp-8h]@2
  char v10; // [sp+Ch] [bp-4h]@1

  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v8, a1);
  result = sub_6F7E2080((int)&v8, dwInfoType, lpSrcStr, cchSrc, lpCharType, CodePage, Locale);
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFD;
  return result;
}

//----- (6F7E2441) --------------------------------------------------------
int __cdecl _commit(int Filehandle)
{
  int *v2; // edi@7
  int v3; // esi@7
  __int32 v4; // eax@9
  DWORD v5; // [sp+14h] [bp-1Ch]@10

  if ( Filehandle == -2 )
  {
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0
    || Filehandle >= _nhandle
    || (v2 = &__pioinfo[Filehandle >> 5], v3 = 36 * (Filehandle & 0x1F), !(*(_BYTE *)(*v2 + v3 + 4) & 1)) )
  {
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  __lock_fhandle(Filehandle);
  if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
  {
    v4 = _get_osfhandle(Filehandle);
    if ( FlushFileBuffers((HANDLE)v4) )
      v5 = 0;
    else
      v5 = GetLastError();
    if ( !v5 )
      goto LABEL_15;
    *__doserrno() = v5;
  }
  *_errno() = 9;
  v5 = -1;
LABEL_15:
  _unlock_fhandle(Filehandle);
  return v5;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E2789) --------------------------------------------------------
int __cdecl strtolX(int a1, int a2, int a3, int a4)
{
  int result; // eax@2

  if ( __locale_changed )
    result = strtoxl(0, a1, a2, a3, 0, a4);
  else
    result = strtoxl((struct localeinfo_struct *)&__initiallocalestructinfo, a1, a2, a3, 0, a4);
  return result;
}
// 6F7E67F8: using guessed type int (*__initiallocalestructinfo)[22];
// 6F7E8B00: using guessed type int __locale_changed;

//----- (6F7E27BC) --------------------------------------------------------
signed int __cdecl _close_nolock(signed int a1)
{
  __int32 v1; // edi@6
  __int32 v2; // eax@7
  DWORD v3; // edi@8
  signed int result; // eax@11

  if ( _get_osfhandle(a1) == -1
    || (a1 == 1 && *(_BYTE *)(__pioinfo[0] + 76) & 1 || a1 == 2 && *(_BYTE *)(__pioinfo[0] + 40) & 1)
    && (v1 = _get_osfhandle(2), _get_osfhandle(1) == v1)
    || (v2 = _get_osfhandle(a1), CloseHandle((HANDLE)v2)) )
    v3 = 0;
  else
    v3 = GetLastError();
  _free_osfhnd(a1);
  *(_BYTE *)(__pioinfo[a1 >> 5] + 36 * (a1 & 0x1F) + 4) = 0;
  if ( v3 )
  {
    _dosmaperr(v3);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 6F7DDA91: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 6F7E16BC: using guessed type _DWORD __cdecl _free_osfhnd(_DWORD);
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E285A) --------------------------------------------------------
int __cdecl _close(int Filehandle)
{
  int result; // eax@3
  int *v2; // ebx@9
  int v3; // esi@9
  int v4; // [sp+14h] [bp-1Ch]@12

  if ( Filehandle == -1 )
  {
    *_errno() = 9;
    *__doserrno() = 0;
    return -1;
  }
  if ( Filehandle == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    return -1;
  }
  if ( Filehandle < 0 || Filehandle >= _nhandle )
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    return -1;
  }
  v2 = &__pioinfo[Filehandle >> 5];
  v3 = 36 * (Filehandle & 0x1F);
  if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
  {
    __lock_fhandle(Filehandle);
    if ( *(_BYTE *)(*v2 + v3 + 4) & 1 )
    {
      v4 = _close_nolock(Filehandle);
    }
    else
    {
      *_errno() = 9;
      v4 = -1;
    }
    _unlock_fhandle(Filehandle);
    result = v4;
  }
  else
  {
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter(0, 0, 0, 0, 0);
    result = -1;
  }
  return result;
}
// 6F7E6400: using guessed type int __pioinfo[];

//----- (6F7E2A84) --------------------------------------------------------
int __stdcall NT5_AnimateWindow(int a1, int a2, int a3)
{
  int v3; // esi@1
  HMODULE v4; // eax@2

  v3 = 0;
  if ( dword_6F7E8E4C )
    goto LABEL_9;
  v4 = GetModuleHandleW(L"USER32");
  if ( v4 )
    dword_6F7E8E4C = (int (__stdcall *)(_DWORD, _DWORD, _DWORD))GetProcAddress(v4, "AnimateWindow");
  if ( dword_6F7E8E4C )
LABEL_9:
    v3 = dword_6F7E8E4C(a1, a2, a3);
  return v3;
}
// 6F7E8E4C: using guessed type int (__stdcall *dword_6F7E8E4C)(_DWORD, _DWORD, _DWORD);

//----- (6F7E2AE7) --------------------------------------------------------
int __stdcall SlideAnimate(int a1, int a2)
{
  DWORD v2; // eax@1

  v2 = GetMessagePos();
  return NT5_AnimateWindow(
           a1,
           135,
           (4 * (SHIWORD(v2) > *(_DWORD *)(a2 + 4) + (*(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4)) / 2) + 4) | 0x40000);
}

//----- (6F7E2B3A) --------------------------------------------------------
int __stdcall CoolTooltipBubble(HWND hWnd, int a2, int a3, int a4)
{
  int result; // eax@5
  int pvParam; // [sp+8h] [bp-4h]@2

  if ( !g_bRunOnNT5 )
    goto LABEL_11;
  pvParam = 1;
  SystemParametersInfoW(0x1016u, 0, &pvParam, 0);
  if ( !pvParam )
    goto LABEL_11;
  pvParam = 0;
  SystemParametersInfoW(0x1018u, 0, &pvParam, 0);
  if ( pvParam && a3 )
    return NT5_AnimateWindow((int)hWnd, 135, 0x80000);
  if ( a4 )
    result = SlideAnimate((int)hWnd, a2);
  else
LABEL_11:
    result = SetWindowPos(hWnd, 0, 0, 0, 0, 0, 0x57u);
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7E2BC6) --------------------------------------------------------
HCURSOR __stdcall LoadHandCursor(int a1)
{
  HCURSOR result; // eax@2

  if ( !g_bRunOnNT5 || (result = LoadCursorW(0, (LPCWSTR)0x7F89)) == 0 )
    result = LoadCursorW(g_hinst, (LPCWSTR)0x6C);
  return result;
}
// 6F7E8578: using guessed type int g_bRunOnNT5;

//----- (6F7E2BF6) --------------------------------------------------------
HRESULT StringCchPrintfA(STRSAFE_LPSTR pszDest, size_t cchDest, STRSAFE_LPCSTR pszFormat, ...)
{
  HRESULT result; // eax@1
  size_t v4; // esi@5
  HRESULT v5; // ebx@5
  int v6; // eax@5
  va_list va; // [sp+14h] [bp+14h]@1

  va_start(va, pszFormat);
  result = 0;
  if ( !cchDest || cchDest > 0x7FFFFFFF )
    result = -2147024809;
  if ( result >= 0 )
  {
    v4 = cchDest - 1;
    v5 = 0;
    v6 = _vsnprintf(pszDest, cchDest - 1, pszFormat, va);
    if ( v6 < 0 || v6 > v4 )
    {
      pszDest[v4] = 0;
      v5 = -2147024774;
    }
    else if ( v6 == v4 )
    {
      pszDest[v4] = 0;
    }
    result = v5;
  }
  return result;
}

//----- (6F7E2C54) --------------------------------------------------------
signed int __stdcall Emulate_GetCalendarInfoA(int a1, int a2, int a3, int a4, int a5, int a6)
{
  signed int v6; // edi@1
  DWORD cbData; // [sp+8h] [bp-5Ch]@3
  HKEY phkResult; // [sp+Ch] [bp-58h]@1
  BYTE Data; // [sp+10h] [bp-54h]@3
  char pszDest; // [sp+50h] [bp-14h]@2

  v6 = 0;
  if ( !RegOpenKeyExA(
          HKEY_CURRENT_USER,
          "Control Panel\\International\\Calendars\\TwoDigitYearMax",
          0,
          0x20019u,
          &phkResult) )
  {
    if ( StringCchPrintfA(&pszDest, 0x10u, "%d", a2) >= 0 )
    {
      cbData = 64;
      if ( !RegQueryValueExA(phkResult, &pszDest, 0, 0, &Data, &cbData) )
      {
        *(_DWORD *)a6 = StrToIntA((LPCSTR)&Data);
        v6 = 1;
      }
    }
    RegCloseKey(phkResult);
  }
  return v6;
}

//----- (6F7E2D2F) --------------------------------------------------------
int __stdcall NT5_GetCalendarInfoA(int a1, int a2, int a3, int a4, int a5, int a6)
{
  void *v6; // eax@1
  HMODULE v7; // eax@2

  v6 = (void *)_GetCalendarInfoA;
  if ( !_GetCalendarInfoA )
  {
    v7 = GetModuleHandleW(L"KERNEL32");
    if ( !v7 || (v6 = GetProcAddress(v7, "GetCalendarInfoA")) == 0 )
      v6 = Emulate_GetCalendarInfoA;
    _GetCalendarInfoA = (int)v6;
  }
  return ((int (__stdcall *)(int, int, int, int, int, int))v6)(a1, a2, a3, a4, a5, a6);
}
// 6F7E8E7C: using guessed type int _GetCalendarInfoA;

#error "There were 5 decompilation failure(s) on 1949 function(s)"
