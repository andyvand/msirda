/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

char __stdcall IsIrqlGreaterThanDispatch();
int __stdcall InitializeDmaUtil(int a1, int a2);
int __thiscall StartDmaTransfer(int this, int a2, PNDIS_BUFFER Buffer, ULONG Offset, ULONG Length, BOOLEAN WriteToDevice);
int __thiscall CompleteDmaTransfer(int this, int a2, char a3);
int __stdcall SyncSetInterruptMask(int a1, char a2);
void __stdcall DoClose(int a1);
void __stdcall SyncSetUARTSpeed(int a1);
void __stdcall SetUARTSpeed(int a1, unsigned int a2);
char __stdcall SetSpeed(int a1);
char __stdcall OpenCOM(int Value);
int __stdcall CloseCOM(int a1);
UCHAR __stdcall GetCOMPort(int a1, int a2);
void __stdcall SetCOMPort(int a1, int a2, UCHAR Value);
void __stdcall SetCOMInterrupts(int a1, UCHAR Value);
char __thiscall DoOpen(void *this, int Value);
char __stdcall StepSendFSM(int a1);
signed int __stdcall DoRcvDirect(int a1, int a2, unsigned int a3);
char __stdcall StepReceiveFSM(int a1);
UCHAR __stdcall COM_ISR(int a1, int a2, int a3);
signed int __stdcall EscapeSlowIrData(int a1, unsigned __int8 a2);
char __stdcall NdisToIrPacket(int a1, void *a2, size_t a3, int a4);
int __stdcall GetDongleCapabilities(int a1);
void __stdcall SetHpMuxDongle(int a1, int a2);
void __stdcall SetHpDongle(int a1, __int64 Value);
void __stdcall SetTemicDongle(int a1, int a2);
void __stdcall SetDellDongle(int a1, int a2);
void __stdcall SetIbmDongle(int a1, int a2);
signed int __stdcall SetReqMode(int a1, int a2);
signed int __stdcall SetDongleCapabilities(int a1);
int __stdcall ComputeFCS(int a1, int a2);
int __stdcall WPP_SF_(int a1, int a2, int a3, int a4);
void __stdcall NSC_WriteBankReg(int a1, int a2, int a3, UCHAR Value);
UCHAR __stdcall NSC_ReadBankReg(int a1, int a2, int a3);
void __stdcall ReadBankReg(int a1);
void __stdcall WriteBankReg(int a1);
int __stdcall SyncWriteBankReg(int a1, int a2, int a3, int a4, char a5);
char __stdcall SyncReadBankReg(int a1, int a2, int a3, int a4);
char __stdcall SyncGetDongleCapabilities(int a1, int a2, int a3);
int __stdcall SyncSetDongleCapabilities(int a1, int a2, int a3);
void __stdcall GetFifoStatus(int a1);
__int16 __stdcall SyncGetFifoStatus(int a1, int a2, int a3, int a4);
void __stdcall Ir108ConfigWrite(PUCHAR Port, UCHAR a2, UCHAR Value, UCHAR a4);
UCHAR __stdcall Ir108ConfigRead(PUCHAR Port, UCHAR Value, char a3);
char __stdcall NSC_DEMO_Init(int Value);
_DWORD __stdcall NSC_DEMO_Deinit(_DWORD, _DWORD); // weak
char __thiscall NSC_DEMO_SetSpeed(int this, int a2, int a3, int a4, int a5);
// int __userpurge sub_124DC@<eax>(int a1@<eax>, int a2);
int __stdcall WPP_SF_D(int a1, int a2, int a3, int a4, int a5);
int __stdcall WPP_INIT_CONTROL_ARRAY(int a1);
NTSTATUS __cdecl W2kTraceMessage(int a1, int a2, int a3, int a4, char a5, void *a6);
char __stdcall MiniportCheckForHang(PKSPIN_LOCK SpinLock);
int __stdcall MiniportHalt(int a1);
void __stdcall InterlockedInsertBufferSorted(int a1, int a2, PKSPIN_LOCK SpinLock);
int __stdcall DeliverFullBuffers(PNDIS_BUFFER Buffer); // idb
char __stdcall GetPnPResources(int a1, int a2);
char __stdcall Configure(int a1, NDIS_HANDLE WrapperConfigurationContext);
char __stdcall VerifyHardware(int a1);
int __stdcall QueueReceivePacket(int a1, int a2, int a3, char a4);
int __stdcall MiniportISR(int *a1, char *a2, int a3);
void __stdcall ReturnPacketHandler(PNDIS_BUFFER Buffer, PNDIS_PACKET Packet);
void __stdcall GivePacketToSirISR(int a1);
void __stdcall SendCurrentPacket(PKSPIN_LOCK SpinLock);
NDIS_TIMER_FUNCTION DelayedWrite; // idb
NTSTATUS __stdcall NscUloadHandler(PDEVICE_OBJECT DeviceObject);
int __stdcall GetPacketInfo(int a1);
int __stdcall SetupRecv(int a1);
int __stdcall MiniportInitialize(int, int, int, int, int, NDIS_HANDLE WrapperConfigurationContext); // idb
void __stdcall ProcessSendQueue(PKSPIN_LOCK SpinLock);
int __stdcall SendPacketsHandler(PKSPIN_LOCK SpinLock, int, int); // idb
int __stdcall MiniportHandleInterrupt(PNDIS_BUFFER Buffer); // idb
int __stdcall MiniportReset(int, PKSPIN_LOCK SpinLock); // idb
int __stdcall WPP_SF_dd(int a1, int a2, int a3, int a4, int a5, char a6);
int __stdcall WPP_SF_ddd(int a1, int a2, int a3, int a4, int a5, char a6, char a7);
int __stdcall NSC_FIR_ISR(int a1, int *a2, char *a3);
int __stdcall SkipNonDmaBuffers(int a1, int a2);
int __stdcall GetNextPacket(int a1, int a2, int a3);
bool __stdcall SynchronizedFindLargestSpace(int a1);
int __stdcall FindLargestSpace(int a1, int a2, int a3);
int __stdcall FIR_DeliverFrames(unsigned int a1);
char __stdcall NSC_Setup(int Status);
void __stdcall NSC_Shutdown(int a1);
char __stdcall NdisToFirPacket(int a1, unsigned int a2, unsigned int a3, int a4);
int __stdcall MiniportQueryInformation(int, int, void *, int, int, int); // idb
int __stdcall MiniportSetInformation(PKSPIN_LOCK SpinLock, int, int, int, int, int); // idb
PVOID __thiscall NscMemAlloc(void *this, UINT Length);
void __stdcall NscMemFree(PVOID VirtualAddress);
int __stdcall NscAllocateDmaBuffer(int, UINT Length, int); // idb
void __stdcall NscFreeDmaBuffer(int a1);
char *__stdcall InitDevice(PVOID FunctionContext);
void __stdcall CloseDevice(int a1);
PVOID __thiscall NewDevice(void *this);
// _DWORD __stdcall FreeDevice(_DWORD); weak
char __stdcall OpenDevice(int Status);
char __stdcall SynchronizedListFunc(int a1);
// void *__cdecl memcpy(void *, const void *, size_t);
// void *__cdecl memset(void *, int, size_t);
// void __fastcall KfReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
// UCHAR __stdcall READ_PORT_UCHAR(PUCHAR Port);
// void __stdcall KeStallExecutionProcessor(ULONG MicroSeconds);
// void __stdcall WRITE_PORT_UCHAR(PUCHAR Port, UCHAR Value);
// KIRQL __fastcall KfAcquireSpinLock(PKSPIN_LOCK SpinLock);
// void NdisMFreeSharedMemory(NDIS_HANDLE MiniportAdapterHandle, ULONG Length, BOOLEAN Cached, PVOID VirtualAddress, NDIS_PHYSICAL_ADDRESS PhysicalAddress);
// void __stdcall NdisFreeMemory(PVOID VirtualAddress, UINT Length, UINT MemoryFlags);
// NDIS_STATUS __stdcall NdisAllocateMemoryWithTag(PVOID *VirtualAddress, UINT Length, ULONG Tag);
// void __stdcall NdisFreeBufferPool(NDIS_HANDLE PoolHandle);
// void NdisMDeregisterDmaChannel(NDIS_HANDLE MiniportDmaHandle);
// void __stdcall NdisInitializeTimer(PNDIS_TIMER Timer, PNDIS_TIMER_FUNCTION TimerFunction, PVOID FunctionContext);
// void __stdcall NdisAllocateBufferPool(PNDIS_STATUS Status, PNDIS_HANDLE PoolHandle, UINT NumberOfDescriptors);
// void __stdcall NdisInitializeWrapper(PNDIS_HANDLE NdisWrapperHandle, PVOID SystemSpecific1, PVOID SystemSpecific2, PVOID SystemSpecific3);
// int __stdcall NdisMRegisterMiniport(_DWORD, _DWORD, _DWORD); weak
// int __stdcall NdisMRegisterUnloadHandler(_DWORD, _DWORD); weak
// int __stdcall NdisMIndicateStatus(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __stdcall NdisMIndicateStatusComplete(_DWORD); weak
// void __stdcall NdisFreePacketPool(NDIS_HANDLE PoolHandle);
// void __stdcall NdisFreePacket(PNDIS_PACKET Packet);
// void __stdcall NdisAllocatePacket(PNDIS_STATUS Status, PNDIS_PACKET *Packet, NDIS_HANDLE PoolHandle);
// void __stdcall NdisAllocatePacketPool(PNDIS_STATUS Status, PNDIS_HANDLE PoolHandle, UINT NumberOfDescriptors, UINT ProtocolReservedLength);
// NDIS_STATUS NdisMRegisterDmaChannel(PNDIS_HANDLE MiniportDmaHandle, NDIS_HANDLE MiniportAdapterHandle, UINT DmaChannel, BOOLEAN Dma32BitAddresses, PNDIS_DMA_DESCRIPTION DmaDescription, ULONG MaximumLength);
// BOOLEAN __stdcall NdisWaitEvent(PNDIS_EVENT Event, UINT msToWait);
// void __stdcall NdisSetupDmaTransfer(PNDIS_STATUS Status, NDIS_HANDLE NdisDmaHandle, PNDIS_BUFFER Buffer, ULONG Offset, ULONG Length, BOOLEAN WriteToDevice);
// void __stdcall NdisCompleteDmaTransfer(PNDIS_STATUS Status, NDIS_HANDLE NdisDmaHandle, PNDIS_BUFFER Buffer, ULONG Offset, ULONG Length, BOOLEAN WriteToDevice);
// int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD); weak
// void __stdcall NdisResetEvent(PNDIS_EVENT Event);
// void __stdcall NdisInitializeEvent(PNDIS_EVENT Event);
// void NdisMDeregisterIoPortRange(NDIS_HANDLE MiniportAdapterHandle, UINT InitialPort, UINT NumberOfPorts, PVOID PortOffset);
// int __stdcall NdisMDeregisterInterrupt(_DWORD); weak
// void __stdcall NdisUnchainBufferAtFront(PNDIS_PACKET Packet, PNDIS_BUFFER *Buffer);
// void __stdcall NdisAllocateBuffer(PNDIS_STATUS Status, PNDIS_BUFFER *Buffer, NDIS_HANDLE PoolHandle, PVOID VirtualAddress, UINT Length);
// int __stdcall NdisMQueryAdapterResources(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall NdisCloseConfiguration(NDIS_HANDLE ConfigurationHandle);
// void __stdcall NdisReadConfiguration(PNDIS_STATUS Status, PNDIS_CONFIGURATION_PARAMETER *ParameterValue, NDIS_HANDLE ConfigurationHandle, PNDIS_STRING Keyword, NDIS_PARAMETER_TYPE ParameterType);
// void __stdcall NdisOpenConfiguration(PNDIS_STATUS Status, PNDIS_HANDLE ConfigurationHandle, NDIS_HANDLE WrapperConfigurationContext);
// void NdisMSleep(ULONG MicrosecondsToSleep);
// void __stdcall NdisSetEvent(PNDIS_EVENT Event);
// int __stdcall NdisMRegisterInterrupt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// NDIS_STATUS NdisMRegisterIoPortRange(PVOID *PortOffset, NDIS_HANDLE MiniportAdapterHandle, UINT InitialPort, UINT NumberOfPorts);
// int __stdcall NdisMSetAttributesEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// void __stdcall NdisSetTimer(PNDIS_TIMER Timer, UINT MillisecondsToDelay);
// ULONG NdisMReadDmaCounter(NDIS_HANDLE MiniportDmaHandle);
// void __stdcall IoFreeMdl(PMDL Mdl);
// void __fastcall KefAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
// void __fastcall KefReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
// NTSTATUS __stdcall IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Action);
// SIZE_T __stdcall RtlCompareMemory(const void *Source1, const void *Source2, SIZE_T Length);
// PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// NTSTATUS __stdcall IoWMIWriteEvent(PVOID WnodeEventItem);
// void __stdcall ExFreePoolWithTag(PVOID P, ULONG Tag);
// PVOID __stdcall MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType, PVOID BaseAddress, ULONG BugCheckOnFailure, MM_PAGE_PRIORITY Priority);
// _DWORD __stdcall WppLoadTracingSupport(); idb
int __stdcall WppTraceCallback(int, int, size_t, void *, int, int); // idb
NTSTATUS __stdcall WppInitKm(PDEVICE_OBJECT DeviceObject);
NTSTATUS __stdcall WppCleanupKm(PDEVICE_OBJECT DeviceObject);
signed int __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);

//-------------------------------------------------------------------------
// Data declarations

// extern volatile KSYSTEM_TIME _KeTickCount;
__int16 fcsTable[] = { 0 }; // weak
int dword_15B30[4] = { 1616478832, 1134188498, 3430060156, 2414873151 }; // weak
char bankCode[] = { '\x03' }; // weak
int dword_15B48[4] = { 1428711713, 453279016, 1741540357, 3656446488 }; // weak
int dword_15B58[4] = { 3173175475, 2330636826, 3147362081, 3366011018 }; // weak
int NSCGlobalSupportedOids[30] =
{
  65793,
  65794,
  65795,
  65796,
  65797,
  65798,
  65813,
  65809,
  65811,
  65810,
  65799,
  65800,
  65801,
  65802,
  65803,
  65805,
  65814,
  65808,
  65806,
  65807,
  65812,
  167837952,
  167837954,
  167837955,
  167837956,
  167837953,
  167838212,
  167838208,
  167838213,
  0
}; // weak
int supportedBaudRateTable[] = { 0 }; // weak
int dword_15BE4[] = { 2400 }; // weak
int dword_15BE8 = 1; // weak
int dword_15BEC[24] =
{
  1,
  9600,
  2,
  2,
  19200,
  4,
  3,
  38400,
  8,
  4,
  57600,
  16,
  5,
  115200,
  32,
  6,
  576000,
  64,
  7,
  1152000,
  128,
  8,
  4000000,
  256
}; // weak
GUID stru_15C50 = { 2223316252u, 17966u, 18634u, { 134u, 96u, 130u, 34u, 78u, 33u, 52u, 77u } }; // weak
void *WPP_GLOBAL_Control = &WPP_GLOBAL_Control; // weak
ULONG_PTR __security_cookie = 3141592654u; // idb
ULONG_PTR __security_cookie_complement = 1153374641u; // idb
int (__stdcall *pfnWppQueryTraceInformation)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int (__cdecl *pfnWppTraceMessage)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = NULL; // weak
int WPPTraceSuite = 0; // weak
int dword_15E34 = 0; // weak
int dword_15E3C = 0; // weak
int dword_15E40 = 0; // weak
int dword_15E44 = 0; // weak
int dword_15E48 = 0; // weak
int dword_15E4C = 0; // weak
int dword_15E50 = 0; // weak
int dword_15E54 = 0; // weak
int dword_15E5C = 0; // weak
int DebugSpeed = 0; // weak
char AbortLoad = '\0'; // weak
int WPP_MAIN_CB[6] = { 0, 0, 0, 0, 0, 0 }; // weak
int dword_15E98 = 0; // weak


//----- (00010606) --------------------------------------------------------
char __stdcall IsIrqlGreaterThanDispatch()
{
  return 0;
}

//----- (0001060E) --------------------------------------------------------
int __stdcall InitializeDmaUtil(int a1, int a2)
{
  int result; // eax@1

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  result = a2;
  *(_DWORD *)a1 = a2;
  return result;
}

//----- (00010630) --------------------------------------------------------
int __thiscall StartDmaTransfer(int this, int a2, PNDIS_BUFFER Buffer, ULONG Offset, ULONG Length, BOOLEAN WriteToDevice)
{
  int result; // eax@2
  void *v7; // ST04_4@5
  int Status; // [sp+0h] [bp-4h]@1

  Status = this;
  if ( IsIrqlGreaterThanDispatch() )
  {
    result = -1073741823;
  }
  else if ( *(_DWORD *)(a2 + 4) )
  {
    result = -1073741823;
  }
  else
  {
    v7 = *(void **)a2;
    *(_DWORD *)(a2 + 4) = Buffer;
    *(_DWORD *)(a2 + 8) = Offset;
    *(_DWORD *)(a2 + 12) = Length;
    *(_BYTE *)(a2 + 16) = WriteToDevice;
    NdisSetupDmaTransfer(&Status, v7, Buffer, Offset, Length, WriteToDevice);
    result = Status;
    if ( Status )
      *(_DWORD *)(a2 + 4) = 0;
  }
  return result;
}

//----- (00010696) --------------------------------------------------------
int __thiscall CompleteDmaTransfer(int this, int a2, char a3)
{
  int result; // eax@2
  MDL *v4; // ecx@3
  BOOLEAN v5; // al@4
  int Status; // [sp+0h] [bp-4h]@1

  Status = this;
  if ( IsIrqlGreaterThanDispatch() )
  {
    result = -1073741823;
  }
  else
  {
    v4 = *(MDL **)(a2 + 4);
    if ( v4 && (v5 = *(_BYTE *)(a2 + 16), a3 == v5) )
    {
      NdisCompleteDmaTransfer(&Status, *(NDIS_HANDLE *)a2, v4, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), v5);
      *(_DWORD *)(a2 + 4) = 0;
      result = Status;
    }
    else
    {
      result = -1073741823;
    }
  }
  return result;
}

//----- (000106EC) --------------------------------------------------------
int __stdcall SyncSetInterruptMask(int a1, char a2)
{
  char v3; // [sp+Ch] [bp+Ch]@4

  if ( !a2 )
  {
    v3 = 0;
    return SyncWriteBankReg(a1 + 148, *(_DWORD *)(a1 + 372), 0, 1, v3);
  }
  if ( !*(_DWORD *)(a1 + 428) )
  {
    if ( *(_DWORD *)(a1 + 8) <= 0x1C200u )
    {
      v3 = 1;
      return SyncWriteBankReg(a1 + 148, *(_DWORD *)(a1 + 372), 0, 1, v3);
    }
    goto LABEL_6;
  }
  if ( *(_DWORD *)(a1 + 8) > 0x1C200u )
  {
LABEL_6:
    v3 = *(_BYTE *)(a1 + 339);
    return SyncWriteBankReg(a1 + 148, *(_DWORD *)(a1 + 372), 0, 1, v3);
  }
  v3 = 3;
  return SyncWriteBankReg(a1 + 148, *(_DWORD *)(a1 + 372), 0, 1, v3);
}

//----- (00010750) --------------------------------------------------------
void __stdcall DoClose(int a1)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(a1 + 400);
  if ( v1 )
  {
    NscMemFree((PVOID)(v1 - 8));
    *(_DWORD *)(a1 + 400) = 0;
  }
  if ( *(_DWORD *)(a1 + 416) )
  {
    NscMemFree(*(PVOID *)(a1 + 416));
    *(_DWORD *)(a1 + 416) = 0;
  }
}

//----- (00010792) --------------------------------------------------------
void __stdcall SyncSetUARTSpeed(int a1)
{
  int v1; // esi@1

  v1 = a1;
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), 0x83u);
  WRITE_PORT_UCHAR(*(PUCHAR *)v1, 0x1C200u / *(_DWORD *)(v1 + 4));
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)v1 + 1), 0x1C200u / *(_DWORD *)(v1 + 4) >> 8);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), 3u);
}

//----- (000107E8) --------------------------------------------------------
void __stdcall SetUARTSpeed(int a1, unsigned int a2)
{
  signed int v2; // ecx@1
  int v3; // edx@4
  int v4; // [sp+0h] [bp-8h]@4
  int v5; // [sp+4h] [bp-4h]@4

  v2 = a2;
  if ( a2 <= 0x1C200 )
  {
    if ( !a2 )
      v2 = 9600;
    v3 = *(_DWORD *)(a1 + 372);
    v5 = v2;
    v4 = v3;
    NdisMSynchronizeWithInterrupt(a1 + 148, SyncSetUARTSpeed, &v4);
    KeStallExecutionProcessor(0x1388u);
  }
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (0001083C) --------------------------------------------------------
char __stdcall SetSpeed(int a1)
{
  int v1; // edi@1
  char v2; // bl@1
  int v3; // ecx@1
  char v4; // al@1

  v1 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4);
  v2 = 1;
  SyncSetInterruptMask(a1, 0);
  SetUARTSpeed(a1, 0x2580u);
  v4 = NSC_DEMO_SetSpeed(v3, a1, *(_DWORD *)(a1 + 372), v1, *(_DWORD *)(a1 + 448));
  *(_DWORD *)(a1 + 412) = 0;
  if ( !v4 )
    v2 = 0;
  SetUARTSpeed(a1, v1);
  *(_DWORD *)(a1 + 8) = v1;
  DebugSpeed = v1;
  SyncSetInterruptMask(a1, 1);
  return v2;
}
// 15E68: using guessed type int DebugSpeed;

//----- (000108AC) --------------------------------------------------------
char __stdcall OpenCOM(int Value)
{
  int v1; // esi@1
  char result; // al@2
  char v3; // [sp+17h] [bp+Bh]@1

  v1 = Value;
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(Value + 372) + 3), 3u);
  SyncSetInterruptMask(Value, 0);
  SyncWriteBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 4, 10);
  *(_DWORD *)(Value + 436) = 63;
  *(_DWORD *)(Value + 440) = 1000;
  *(_DWORD *)(Value + 444) = 0;
  SetUARTSpeed(Value, 0x2580u);
  v3 = NSC_DEMO_Init(Value);
  SyncWriteBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 4, 10);
  if ( v3 )
  {
    *(_DWORD *)(v1 + 348) = dword_15BEC;
    SetSpeed(v1);
    SyncWriteBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 2, 0);
    SyncWriteBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 2, 7);
    *(_BYTE *)(v1 + 381) = (SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 2) & 0xC0) == -64;
    SyncSetInterruptMask(v1, 1);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 15BEC: using guessed type int dword_15BEC[24];

//----- (00010994) --------------------------------------------------------
int __stdcall CloseCOM(int a1)
{
  *(_DWORD *)(a1 + 348) = dword_15BEC;
  SetSpeed(a1);
  NSC_DEMO_Deinit(*(_DWORD *)(a1 + 372), *(_DWORD *)(a1 + 448));
  return SyncSetInterruptMask(a1, 0);
}
// 1230A: using guessed type _DWORD __stdcall NSC_DEMO_Deinit(_DWORD, _DWORD);
// 15BEC: using guessed type int dword_15BEC[24];

//----- (000109D0) --------------------------------------------------------
UCHAR __stdcall GetCOMPort(int a1, int a2)
{
  return READ_PORT_UCHAR((PUCHAR)(a2 + a1));
}

//----- (000109EE) --------------------------------------------------------
void __stdcall SetCOMPort(int a1, int a2, UCHAR Value)
{
  WRITE_PORT_UCHAR((PUCHAR)(a2 + a1), Value);
}

//----- (00010A0E) --------------------------------------------------------
void __stdcall SetCOMInterrupts(int a1, UCHAR Value)
{
  char v2; // cl@1
  char Valuea; // [sp+Ch] [bp+Ch]@5

  v2 = 0;
  if ( Value )
  {
    if ( *(_DWORD *)(a1 + 428) )
    {
      if ( *(_DWORD *)(a1 + 8) <= 0x1C200u )
      {
        Valuea = 3;
        goto LABEL_6;
      }
    }
    else if ( *(_DWORD *)(a1 + 8) <= 0x1C200u )
    {
      Valuea = 1;
      goto LABEL_6;
    }
    v2 = *(_BYTE *)(a1 + 339);
  }
  Valuea = v2;
LABEL_6:
  SetCOMPort(*(_DWORD *)(a1 + 372), 1, Valuea);
}

//----- (00010A66) --------------------------------------------------------
char __thiscall DoOpen(void *this, int Value)
{
  PVOID v2; // eax@1
  void *v3; // ecx@1
  char result; // al@2
  PVOID v5; // eax@3

  v2 = NscMemAlloc(this, 0x810u);
  *(_DWORD *)(Value + 400) = (char *)v2 + 8;
  if ( v2 != (PVOID)-8 && (v5 = NscMemAlloc(v3, 0x1036u), (*(_DWORD *)(Value + 416) = v5) != 0) )
  {
    *(_DWORD *)(Value + 408) = 0;
    *(_DWORD *)(Value + 428) = 0;
    *(_BYTE *)(Value + 282) = 1;
    NdisInitializeEvent((PNDIS_EVENT)(Value + 292));
    NdisResetEvent((PNDIS_EVENT)(Value + 292));
    NdisInitializeEvent((PNDIS_EVENT)(Value + 308));
    NdisResetEvent((PNDIS_EVENT)(Value + 308));
    result = OpenCOM(Value);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00010AF0) --------------------------------------------------------
char __stdcall StepSendFSM(int a1)
{
  int v1; // esi@1
  signed int v2; // edi@1
  unsigned int v3; // ebx@7
  UCHAR v4; // al@8
  int i; // ebx@11
  int v6; // eax@12
  UCHAR v7; // ST08_1@12
  int v8; // ST00_4@12
  unsigned int v9; // ebx@16
  unsigned int v10; // ebx@19
  char result; // al@22
  int v12; // [sp+14h] [bp+8h]@4

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8) > 0x1C200u ? 1000000 : 2;
  while ( *(_DWORD *)(v1 + 420) < *(_DWORD *)(v1 + 424) )
  {
    if ( *(_BYTE *)(v1 + 381) )
    {
      if ( (unsigned int)(*(_DWORD *)(v1 + 424) - *(_DWORD *)(v1 + 420)) < 0x10 )
        v12 = *(_DWORD *)(v1 + 424) - *(_DWORD *)(v1 + 420);
      else
        v12 = 16;
    }
    else
    {
      v12 = 1;
    }
    v3 = 0;
    while ( 1 )
    {
      v4 = GetCOMPort(*(_DWORD *)(v1 + 372), 5);
      if ( v4 & 0x20 )
        break;
      ++v3;
      if ( v3 >= v2 )
      {
        if ( !(v4 & 0x20) )
          goto LABEL_14;
        break;
      }
    }
    for ( i = v12; i; --i )
    {
      v6 = *(_DWORD *)(v1 + 420);
      v7 = *(_BYTE *)(v6 + *(_DWORD *)(v1 + 416));
      v8 = *(_DWORD *)(v1 + 372);
      *(_DWORD *)(v1 + 420) = v6 + 1;
      SetCOMPort(v8, 0, v7);
    }
  }
LABEL_14:
  if ( *(_DWORD *)(v1 + 420) < *(_DWORD *)(v1 + 424) )
  {
    result = 0;
  }
  else
  {
    if ( *(_BYTE *)(v1 + 356) )
    {
      v9 = 0;
      do
      {
        if ( GetCOMPort(*(_DWORD *)(v1 + 372), 5) & 0x20 )
          break;
        ++v9;
      }
      while ( v9 < 0xF4240 );
      v10 = 0;
      SetCOMPort(*(_DWORD *)(v1 + 372), 0, 0xC0u);
      do
      {
        if ( GetCOMPort(*(_DWORD *)(v1 + 372), 5) & 0x20 )
          break;
        ++v10;
      }
      while ( v10 < 0xF4240 );
    }
    result = 1;
  }
  return result;
}

//----- (00010C08) --------------------------------------------------------
signed int __stdcall DoRcvDirect(int a1, int a2, unsigned int a3)
{
  unsigned __int16 v3; // si@1
  unsigned int v4; // edi@2
  UCHAR v5; // al@3
  UCHAR v7; // al@8
  int v8; // ecx@8

  v3 = 0;
  if ( a3 )
  {
    while ( 2 )
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = GetCOMPort(a1, 5);
        if ( v5 & 0x18 )
        {
          GetCOMPort(a1, 0);
          return -1;
        }
        if ( v5 & 1 )
          break;
        ++v4;
        if ( v4 >= 2 )
          return v3;
      }
      v7 = GetCOMPort(a1, 0);
      v8 = v3++;
      *(_BYTE *)(v8 + a2) = v7;
      if ( v3 < a3 )
        continue;
      break;
    }
  }
  return v3;
}

//----- (00010C6C) --------------------------------------------------------
char __stdcall StepReceiveFSM(int a1)
{
  signed int v1; // eax@5
  unsigned int v2; // ecx@10
  int v3; // edx@11
  unsigned __int8 v4; // al@11
  int v5; // edx@12
  int v6; // edx@13
  char v7; // bl@43
  int v9; // edi@45
  int v10; // eax@46
  int v11; // ecx@46
  signed int v12; // [sp+Ch] [bp-8h]@1
  unsigned int i; // [sp+10h] [bp-4h]@1

  i = 0;
  v12 = 0;
  if ( *(_DWORD *)(a1 + 408) == 4 )
    goto LABEL_53;
  while ( 1 )
  {
    if ( *(_DWORD *)(a1 + 404) > 0x804u )
      goto LABEL_40;
    if ( *(_DWORD *)(a1 + 408) == 5 )
    {
      v12 = *(_DWORD *)(a1 + 404);
      *(_DWORD *)(a1 + 408) = 0;
      *(_DWORD *)(a1 + 404) = 0;
      goto LABEL_8;
    }
    v1 = DoRcvDirect(*(_DWORD *)(a1 + 372), a1 + 382, 0x10u);
    v12 = v1;
    if ( v1 != -1 )
      break;
    *(_DWORD *)(a1 + 408) = 0;
    *(_DWORD *)(a1 + 404) = 0;
LABEL_39:
    if ( *(_DWORD *)(a1 + 408) == 4 )
      goto LABEL_40;
  }
  if ( v1 )
  {
LABEL_8:
    for ( i = 0; ; ++i )
    {
      if ( *(_DWORD *)(a1 + 408) == 4 )
        goto LABEL_39;
      if ( i >= v12 )
        goto LABEL_39;
      v2 = *(_DWORD *)(a1 + 404);
      if ( v2 > 0x804 )
        goto LABEL_39;
      v3 = *(_DWORD *)(a1 + 408);
      v4 = *(_BYTE *)(i + a1 + 382);
      if ( v3 )
      {
        v5 = v3 - 1;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( v6 )
          {
            if ( v6 != 1 )
            {
              *(_DWORD *)(a1 + 404) = 0;
              *(_DWORD *)(a1 + 408) = 0;
              return 0;
            }
            if ( v4 != 93 && (v4 == 125 || v4 > 0xBFu && v4 <= 0xC1u) )
            {
LABEL_19:
              *(_DWORD *)(a1 + 408) = 0;
              *(_DWORD *)(a1 + 404) = 0;
              continue;
            }
            *(_BYTE *)(v2 + *(_DWORD *)(a1 + 400)) = v4 ^ 0x20;
            ++*(_DWORD *)(a1 + 404);
            goto LABEL_21;
          }
          if ( v4 == 125 )
            goto LABEL_34;
          if ( v4 == 192 )
            goto LABEL_19;
          if ( v4 == 193 )
          {
            if ( v2 < 4 )
              goto LABEL_19;
            *(_DWORD *)(a1 + 408) = 4;
          }
          else
          {
            *(_BYTE *)(v2 + *(_DWORD *)(a1 + 400)) = v4;
            ++*(_DWORD *)(a1 + 404);
          }
        }
        else
        {
          if ( v4 == 125 )
          {
            *(_DWORD *)(a1 + 404) = 0;
LABEL_34:
            *(_DWORD *)(a1 + 408) = 3;
            continue;
          }
          if ( v4 != 192 )
          {
            if ( v4 != 193 )
            {
              **(_BYTE **)(a1 + 400) = v4;
              *(_DWORD *)(a1 + 404) = 1;
LABEL_21:
              *(_DWORD *)(a1 + 408) = 2;
              continue;
            }
            *(_DWORD *)(a1 + 408) = 0;
          }
        }
      }
      else if ( v4 == -64 )
      {
        *(_DWORD *)(a1 + 408) = 1;
      }
    }
  }
LABEL_40:
  if ( *(_DWORD *)(a1 + 408) == 4 )
  {
LABEL_53:
    v9 = a1 + 228;
    if ( *(_DWORD *)v9 != v9 )
    {
      QueueReceivePacket(a1, *(_DWORD *)(a1 + 400), *(_DWORD *)(a1 + 404), 0);
      v10 = *(_DWORD *)v9;
      v11 = **(_DWORD **)v9;
      *(_DWORD *)v9 = v11;
      *(_DWORD *)(v11 + 4) = v9;
      *(_DWORD *)(a1 + 400) = v10 + 8;
    }
    v7 = 1;
    if ( i >= v12 )
    {
      *(_DWORD *)(a1 + 408) = 0;
    }
    else
    {
      memcpy((void *)(a1 + 382), (const void *)(i + a1 + 382), v12 - i);
      *(_DWORD *)(a1 + 404) = v12 - i;
      *(_DWORD *)(a1 + 408) = 5;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 404) > 0x804u )
    {
      *(_DWORD *)(a1 + 404) = 0;
      *(_DWORD *)(a1 + 408) = 0;
    }
    v7 = 0;
  }
  return v7;
}

//----- (00010EBE) --------------------------------------------------------
UCHAR __stdcall COM_ISR(int a1, int a2, int a3)
{
  int v3; // esi@1
  UCHAR result; // al@1
  unsigned int v5; // ecx@4
  int v6; // eax@5
  int v7; // eax@6
  signed __int32 v8; // ecx@8
  int v9; // [sp+Ch] [bp+8h]@3

  v3 = a1;
  result = GetCOMPort(*(_DWORD *)(a1 + 372), 2);
  if ( result & 1 )
  {
    *(_BYTE *)a3 = 0;
    result = a2;
    *(_BYTE *)a2 = 0;
  }
  else
  {
    v9 = 0;
    *(_BYTE *)a2 = 1;
    *(_BYTE *)a3 = 0;
    do
    {
      v5 = v9++;
      if ( v5 >= 0x10 )
        break;
      v6 = result & 6;
      if ( v6 )
      {
        v7 = v6 - 2;
        if ( v7 )
        {
          if ( v7 == 2 )
          {
            *(_BYTE *)(v3 + 338) = 1;
            v8 = _InterlockedIncrement((volatile signed __int32 *)(v3 + 332));
            if ( !*(_BYTE *)(v3 + 336) && v8 > 16 )
            {
              *(_BYTE *)(v3 + 336) = 1;
              *(_BYTE *)(v3 + 337) = 0;
              *(_BYTE *)a3 = 1;
            }
            if ( StepReceiveFSM(v3) )
            {
              *(_BYTE *)a3 = 1;
              *(_BYTE *)(v3 + 338) = 0;
            }
          }
        }
        else if ( *(_DWORD *)(v3 + 428) && StepSendFSM(v3) )
        {
          *(_DWORD *)(v3 + 428) = 0;
          _InterlockedExchange((volatile signed __int32 *)(v3 + 432), 1);
          SetCOMInterrupts(v3, 1u);
          *(_BYTE *)a3 = 1;
        }
      }
      else
      {
        GetCOMPort(*(_DWORD *)(v3 + 372), 6);
      }
      GetCOMPort(*(_DWORD *)(v3 + 372), 5);
      result = GetCOMPort(*(_DWORD *)(v3 + 372), 2);
    }
    while ( !(result & 1) );
  }
  return result;
}

//----- (00010FD6) --------------------------------------------------------
signed int __stdcall EscapeSlowIrData(int a1, unsigned __int8 a2)
{
  signed int result; // eax@4

  if ( a2 == 125 || a2 > 0xBFu && a2 <= 0xC1u )
  {
    *(_BYTE *)(a1 + 1) = a2 ^ 0x20;
    *(_BYTE *)a1 = 125;
    result = 2;
  }
  else
  {
    *(_BYTE *)a1 = a2;
    result = 1;
  }
  return result;
}

//----- (0001100C) --------------------------------------------------------
char __stdcall NdisToIrPacket(int a1, void *a2, size_t a3, int a4)
{
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // ecx@3
  unsigned int v8; // ecx@4
  unsigned int v9; // esi@9
  int v10; // eax@14
  signed int v11; // esi@19
  int v12; // esi@21
  unsigned __int8 v13; // al@22
  __int16 v14; // ST24_2@33
  int v15; // esi@33
  int v16; // esi@33
  signed __int16 v18; // [sp+Ch] [bp-14h]@17
  int v19; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@2
  int v21; // [sp+18h] [bp-8h]@16
  int v22; // [sp+1Ch] [bp-4h]@2
  unsigned int v23; // [sp+1Ch] [bp-4h]@9
  int v24; // [sp+28h] [bp+8h]@2
  int v25; // [sp+28h] [bp+8h]@16
  signed int v26; // [sp+30h] [bp+10h]@17
  size_t v27; // [sp+30h] [bp+10h]@21

  v4 = a1;
  v19 = GetPacketInfo(a1);
  *(_DWORD *)a4 = 0;
  v5 = *(_DWORD *)(a1 + 8);
  if ( !*(_BYTE *)(a1 + 28) )
  {
    v6 = *(_DWORD *)(a1 + 8);
    v22 = 0;
    v20 = 0;
    v24 = 0;
    while ( v6 )
    {
      v7 = *(_DWORD *)(v6 + 20);
      v22 += v7;
      if ( v7 )
        v8 = (*(_DWORD *)(v6 + 20) >> 12)
           + ((((*(_DWORD *)(v6 + 16) + *(_DWORD *)(v6 + 24)) & 0xFFF) + (*(_DWORD *)(v6 + 20) & 0xFFFu) + 4095) >> 12);
      else
        v8 = 1;
      v20 += v8;
      ++v24;
      v6 = *(_DWORD *)v6;
    }
    *(_DWORD *)(v4 + 20) = v24;
    *(_DWORD *)(v4 + 4) = v22;
    *(_DWORD *)v4 = v20;
    *(_BYTE *)(v4 + 28) = 1;
  }
  v9 = *(_DWORD *)(v4 + 4);
  v23 = v9;
  if ( v9 >= 2 )
  {
    if ( v9 > 0x1036 || 2 * v9 + 50 > a3 )
    {
      *(_DWORD *)a4 = v9;
    }
    else if ( v5 )
    {
      v10 = *(_BYTE *)(v5 + 6) & 5 ? *(_DWORD *)(v5 + 12) : MmMapLockedPagesSpecifyCache(
                                                              (PMDL)v5,
                                                              0,
                                                              MmCached,
                                                              0,
                                                              0,
                                                              NormalPagePriority);
      v25 = v10;
      v21 = *(_DWORD *)(v5 + 20);
      if ( v10 )
      {
        v18 = -1;
        v26 = *(_DWORD *)v19;
        if ( *(_DWORD *)v19 > 0x30u )
          v26 = 48;
        v11 = 0;
        if ( v26 )
        {
          memset(a2, 192, v26);
          v11 = v26;
        }
        v27 = 0;
        *((_BYTE *)a2 + v11) = -64;
        v12 = v11 + 1;
        if ( v23 )
        {
          do
          {
            v13 = *(_BYTE *)v25++;
            v18 = fcsTable[(unsigned __int8)(v18 ^ v13)] ^ HIBYTE(v18);
            v12 += EscapeSlowIrData((int)((char *)a2 + v12), v13);
            --v21;
            if ( !v21 )
            {
              v5 = *(_DWORD *)v5;
              if ( v5 )
              {
                if ( *(_BYTE *)(v5 + 6) & 5 )
                  v25 = *(_DWORD *)(v5 + 12);
                else
                  v25 = (int)MmMapLockedPagesSpecifyCache((PMDL)v5, 0, MmCached, 0, 0, NormalPagePriority);
                v21 = *(_DWORD *)(v5 + 20);
                if ( !v25 )
                  return 0;
              }
              else
              {
                v25 = 0;
              }
            }
            ++v27;
          }
          while ( v27 < v23 );
        }
        if ( !v25 )
        {
          v14 = ~v18;
          v15 = EscapeSlowIrData((int)((char *)a2 + v12), v14) + v12;
          v16 = EscapeSlowIrData((int)((char *)a2 + v15), HIBYTE(v14)) + v15;
          *((_BYTE *)a2 + v16) = -63;
          *(_DWORD *)a4 = v16 + 1;
          return 1;
        }
        *(_DWORD *)a4 = 0;
      }
    }
  }
  return 0;
}
// 15930: using guessed type __int16 fcsTable[];

//----- (0001120A) --------------------------------------------------------
int __stdcall GetDongleCapabilities(int a1)
{
  int *v1; // esi@1
  int v2; // edi@1
  int result; // eax@2
  int v4; // ecx@4
  int v5; // eax@5
  int v6; // eax@9
  int v7; // eax@9
  int v8; // eax@9
  int v9; // eax@9
  int v10; // eax@10
  unsigned int v11; // ecx@10
  int v12; // eax@14
  int v13; // ecx@17
  int v14; // ecx@17
  int v15; // ecx@17
  int v16; // ecx@17

  v1 = *(int **)a1;
  v2 = *(_DWORD *)(a1 + 4);
  if ( !**(_DWORD **)a1 )
    return 0;
  result = v2 + 52 * v1[2];
  if ( !(*(_BYTE *)result & 1) )
  {
    v4 = v1[1];
    *(_DWORD *)(52 * v1[2] + v2 + 48) = 0;
    *(_DWORD *)(v2 + 52 * v1[2]) &= 0xFFFFFF1F;
    if ( *((_WORD *)v1 + 2) & 0x8000 )
    {
      NSC_WriteBankReg(*v1, 7, 7, 0);
      KeStallExecutionProcessor(0x32u);
      v4 = NSC_ReadBankReg(*v1, 7, 4) & 0xF;
      v5 = 52 * v1[2];
      if ( v4 == 15 )
      {
        *(_DWORD *)(v2 + v5) = *(_DWORD *)(v2 + v5) & 0xFFFFFF5F | 0x40;
        *(_DWORD *)(v2 + 52 * v1[2]) &= 0xFFFFFFFE;
        return v2 + 52 * v1[2];
      }
      *(_DWORD *)(v5 + v2 + 48) = 1;
    }
    switch ( v4 & 0x1F )
    {
      case 4:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        *(_DWORD *)(v2 + 52 * v1[2]) = *(_DWORD *)(v2 + 52 * v1[2]) & 0xFFFF93FF | 0x1000;
        *(_DWORD *)(52 * v1[2] + v2 + 16) = 5;
        *(_DWORD *)(52 * v1[2] + v2 + 24) = 12;
        v6 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v6 |= 4u;
        v7 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v7 |= 2u;
        v8 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v8 |= 1u;
        v9 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v9 |= 8u;
        return v2 + 52 * v1[2];
      case 8:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFA3FF | 0x2000;
        goto LABEL_17;
      case 9:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFA7FF | 0x2400;
        goto LABEL_17;
      case 0xB:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFAFFF | 0x2C00;
        goto LABEL_17;
      case 0xC:
      case 0xD:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFB3FF | 0x3000;
        goto LABEL_17;
      case 0xE:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        *(_DWORD *)(v2 + 52 * v1[2]) = *(_DWORD *)(v2 + 52 * v1[2]) & 0xFFFFBBFF | 0x3800;
        *(_DWORD *)(52 * v1[2] + v2 + 16) = 5;
        *(_DWORD *)(52 * v1[2] + v2 + 24) = 8;
        v12 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v12 |= 1u;
        return v2 + 52 * v1[2];
      case 0x10:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFC3FF | 0x4000;
        goto LABEL_17;
      case 0x11:
        *(_DWORD *)(v2 + 52 * v1[2]) |= 1u;
        v10 = v2 + 52 * v1[2];
        v11 = *(_DWORD *)v10 & 0xFFFFC7FF | 0x4400;
LABEL_17:
        *(_DWORD *)v10 = v11;
        *(_DWORD *)(52 * v1[2] + v2 + 16) = 5;
        *(_DWORD *)(52 * v1[2] + v2 + 24) = 8;
        v13 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v13 |= 4u;
        v14 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v14 |= 2u;
        v15 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v15 |= 1u;
        v16 = 52 * v1[2] + v2 + 28;
        *(_DWORD *)v16 |= 8u;
        return v2 + 52 * v1[2];
      default:
        result = 0;
        break;
    }
  }
  return result;
}

//----- (00011510) --------------------------------------------------------
void __stdcall SetHpMuxDongle(int a1, int a2)
{
  if ( a2 == 1 )
    NSC_WriteBankReg(a1, 7, 4, 1u);
}

//----- (00011532) --------------------------------------------------------
void __stdcall SetHpDongle(int a1, __int64 Value)
{
  UCHAR v2; // al@1

  v2 = NSC_ReadBankReg(a1, 5, 4);
  if ( (_DWORD)Value )
  {
    NSC_WriteBankReg(a1, 5, 4, v2 & 0xEF);
    NSC_WriteBankReg(a1, 7, 7, 0x48u);
  }
  else
  {
    NSC_WriteBankReg(a1, 5, 4, v2 | 0x10);
  }
}

//----- (00011582) --------------------------------------------------------
void __stdcall SetTemicDongle(int a1, int a2)
{
  void (__stdcall *v2)(ULONG); // esi@5

  if ( !a2 )
  {
    NSC_WriteBankReg(a1, 7, 4, 0);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0xAu);
    NSC_WriteBankReg(a1, 7, 4, 1u);
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 0);
    goto LABEL_7;
  }
  if ( a2 == 1 )
  {
    NSC_WriteBankReg(a1, 7, 4, 1u);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 0x81u);
    KeStallExecutionProcessor(0xAu);
    NSC_WriteBankReg(a1, 7, 4, 0x80u);
LABEL_7:
    v2(0x3E8u);
    return;
  }
  if ( a2 == 2 )
    NSC_WriteBankReg(a1, 7, 4, 1u);
}

//----- (00011628) --------------------------------------------------------
void __stdcall SetDellDongle(int a1, int a2)
{
  void (__stdcall *v2)(ULONG); // esi@5

  if ( !a2 )
  {
    NSC_WriteBankReg(a1, 7, 4, 2u);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 0);
    goto LABEL_7;
  }
  if ( a2 == 1 )
  {
    NSC_WriteBankReg(a1, 7, 4, 2u);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 0x82u);
    KeStallExecutionProcessor(0xAu);
    NSC_WriteBankReg(a1, 7, 4, 0x80u);
LABEL_7:
    v2(0x3E8u);
    return;
  }
  if ( a2 == 2 )
    NSC_WriteBankReg(a1, 7, 4, 2u);
}

//----- (000116B8) --------------------------------------------------------
void __stdcall SetIbmDongle(int a1, int a2)
{
  void (__stdcall *v2)(ULONG); // esi@5

  if ( !a2 )
  {
    NSC_WriteBankReg(a1, 7, 4, 0);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0xAu);
    NSC_WriteBankReg(a1, 7, 4, 1u);
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 6u);
    goto LABEL_7;
  }
  if ( a2 == 1 )
  {
    NSC_WriteBankReg(a1, 7, 4, 1u);
    v2 = KeStallExecutionProcessor;
    KeStallExecutionProcessor(0x14u);
    NSC_WriteBankReg(a1, 7, 4, 0x81u);
    KeStallExecutionProcessor(0xAu);
    NSC_WriteBankReg(a1, 7, 4, 0x86u);
LABEL_7:
    v2(0x3E8u);
    return;
  }
  if ( a2 == 2 )
    NSC_WriteBankReg(a1, 7, 4, 1u);
}

//----- (0001175E) --------------------------------------------------------
signed int __stdcall SetReqMode(int a1, int a2)
{
  int v2; // eax@1
  signed int v3; // ebx@5
  unsigned int v4; // eax@5
  int v5; // eax@7
  int v6; // eax@8
  int v7; // edi@15
  int v8; // edi@16
  int v10; // edi@55
  __int64 v11; // [sp-4h] [bp-10h]@0

  v2 = (*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F;
  if ( v2 == 12 || v2 == 16 )
    NSC_WriteBankReg(*(_DWORD *)a1, 7, 7, 8u);
  else
    NSC_WriteBankReg(*(_DWORD *)a1, 7, 7, 0x28u);
  v3 = 4;
  NSC_WriteBankReg(*(_DWORD *)a1, 7, 4, 0);
  v4 = *(_DWORD *)(a1 + 12);
  if ( v4 > 3 )
    return v3;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 1 || !(*(_BYTE *)(52 * *(_DWORD *)(a1 + 8) + a2 + 28) & 8) )
          return v3;
        *(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2 + 4) = 3;
        *(_DWORD *)(a2 + 52 * *(_DWORD *)(a1 + 8)) |= 4u;
        if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 4 )
          return 1;
        if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) != 8 )
        {
          if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 9 )
          {
            SetTemicDongle(*(_DWORD *)a1, 0);
            return 1;
          }
          if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) != 11 )
          {
            v7 = ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) - 12;
            if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) != 12 )
            {
LABEL_16:
              v8 = v7 - 4;
              if ( v8 )
              {
                if ( v8 == 1 )
                {
                  v3 = 1;
LABEL_19:
                  SetIbmDongle(*(_DWORD *)a1, 1);
                }
                return v3;
              }
              v3 = 1;
LABEL_22:
              SetDellDongle(*(_DWORD *)a1, 1);
              return v3;
            }
            LODWORD(v11) = 0;
            SetHpDongle(*(_DWORD *)a1, v11);
            return 1;
          }
          goto LABEL_26;
        }
        goto LABEL_30;
      }
      if ( !(*(_BYTE *)(52 * *(_DWORD *)(a1 + 8) + a2 + 28) & 4) )
        return v3;
      *(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2 + 4) = 2;
      *(_DWORD *)(a2 + 52 * *(_DWORD *)(a1 + 8)) |= 4u;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 4 )
        return 1;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 8 )
      {
LABEL_30:
        v3 = 1;
LABEL_31:
        SetHpMuxDongle(*(_DWORD *)a1, 1);
        return v3;
      }
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 9
        || ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 11 )
      {
LABEL_26:
        v3 = 1;
LABEL_27:
        SetTemicDongle(*(_DWORD *)a1, 1);
        return v3;
      }
      v7 = ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) - 12;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) != 12 )
        goto LABEL_16;
      v3 = 1;
LABEL_39:
      LODWORD(v11) = 1;
      SetHpDongle(*(_DWORD *)a1, v11);
      return v3;
    }
    if ( !(*(_BYTE *)(52 * *(_DWORD *)(a1 + 8) + a2 + 28) & 2) )
      return v3;
    v3 = 1;
    *(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2 + 4) = 1;
    *(_DWORD *)(a2 + 52 * *(_DWORD *)(a1 + 8)) |= 4u;
    if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 4 )
      return v3;
    if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 8 )
      goto LABEL_31;
    if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) != 9 )
    {
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 11 )
        goto LABEL_27;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 12 )
        goto LABEL_39;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 16 )
        goto LABEL_22;
      if ( ((*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F) == 17 )
        goto LABEL_19;
      return 4;
    }
    goto LABEL_51;
  }
  v3 = 1;
  if ( *(_BYTE *)(52 * *(_DWORD *)(a1 + 8) + a2 + 28) & 1 )
  {
    NSC_WriteBankReg(*(_DWORD *)a1, 7, 4, 0);
    *(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2 + 4) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a2 + 52 * *(_DWORD *)(a1 + 8)) |= 4u;
    if ( (*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) & 0x7C00) == 14336 )
      return v3;
    v10 = (*(_DWORD *)(52 * *(_DWORD *)(a1 + 8) + a2) >> 10) & 0x1F;
    if ( v10 == 12 )
      goto LABEL_39;
    if ( v10 == 8 )
      return v3;
    if ( v10 != 9 && v10 != 11 )
    {
      if ( v10 == 4 )
        return v3;
      if ( v10 == 16 )
      {
        SetDellDongle(*(_DWORD *)a1, 0);
        return v3;
      }
      if ( v10 == 17 )
      {
        SetIbmDongle(*(_DWORD *)a1, 0);
        return v3;
      }
      return 4;
    }
LABEL_51:
    SetTemicDongle(*(_DWORD *)a1, 0);
    return v3;
  }
  return 4;
}

//----- (000119EA) --------------------------------------------------------
signed int __stdcall SetDongleCapabilities(int a1)
{
  int v1; // esi@1
  int v2; // edi@1
  signed int result; // eax@2

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  if ( !GetDongleCapabilities(a1) || *(_BYTE *)(52 * *(_DWORD *)(v1 + 8) + v2) & 0xE0 )
    result = 5;
  else
    result = SetReqMode(v1, v2);
  return result;
}

//----- (00011A26) --------------------------------------------------------
int __stdcall ComputeFCS(int a1, int a2)
{
  int v2; // esi@1
  signed int v3; // eax@1
  int v4; // ecx@2
  int v5; // edx@3

  v2 = a2;
  v3 = 0xFFFF;
  if ( a2 )
  {
    v4 = a1;
    do
    {
      v5 = (unsigned __int8)(v3 ^ *(_BYTE *)v4++);
      --v2;
      v3 = (unsigned __int16)(fcsTable[v5] ^ BYTE1(v3));
    }
    while ( v2 );
  }
  return ~v3;
}
// 15930: using guessed type __int16 fcsTable[];

//----- (00011A66) --------------------------------------------------------
int __stdcall WPP_SF_(int a1, int a2, int a3, int a4)
{
  return pfnWppTraceMessage(a1, a2, 43, a4, a3, 0);
}
// 15E24: using guessed type int (__cdecl *pfnWppTraceMessage)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00011A8E) --------------------------------------------------------
void __stdcall NSC_WriteBankReg(int a1, int a2, int a3, UCHAR Value)
{
  WRITE_PORT_UCHAR((PUCHAR)(a1 + 3), bankCode[a2]);
  WRITE_PORT_UCHAR((PUCHAR)(a3 + a1), Value);
  WRITE_PORT_UCHAR((PUCHAR)(a1 + 3), 3u);
}

//----- (00011ACC) --------------------------------------------------------
UCHAR __stdcall NSC_ReadBankReg(int a1, int a2, int a3)
{
  UCHAR *v3; // ebx@1
  UCHAR v5; // [sp+17h] [bp+Bh]@1

  v3 = (UCHAR *)(a1 + 3);
  WRITE_PORT_UCHAR((PUCHAR)(a1 + 3), bankCode[a2]);
  v5 = READ_PORT_UCHAR((PUCHAR)(a3 + a1));
  WRITE_PORT_UCHAR(v3, 3u);
  return v5;
}

//----- (00011B12) --------------------------------------------------------
void __stdcall ReadBankReg(int a1)
{
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), bankCode[*(_DWORD *)(a1 + 4)]);
  *(_BYTE *)(a1 + 12) = READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)));
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), 3u);
}

//----- (00011B5A) --------------------------------------------------------
void __stdcall WriteBankReg(int a1)
{
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), bankCode[*(_DWORD *)(a1 + 4)]);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + *(_DWORD *)(a1 + 8)), *(_BYTE *)(a1 + 12));
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), 3u);
}

//----- (00011BA0) --------------------------------------------------------
int __stdcall SyncWriteBankReg(int a1, int a2, int a3, int a4, char a5)
{
  int v6; // [sp+0h] [bp-10h]@1
  int v7; // [sp+4h] [bp-Ch]@1
  int v8; // [sp+8h] [bp-8h]@1
  char v9; // [sp+Ch] [bp-4h]@1

  v6 = a2;
  v7 = a3;
  v8 = a4;
  v9 = a5;
  return NdisMSynchronizeWithInterrupt(a1, WriteBankReg, &v6);
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (00011BDC) --------------------------------------------------------
char __stdcall SyncReadBankReg(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+4h] [bp-Ch]@1
  int v7; // [sp+8h] [bp-8h]@1
  char v8; // [sp+Ch] [bp-4h]@1

  v5 = a2;
  v6 = a3;
  v7 = a4;
  NdisMSynchronizeWithInterrupt(a1, ReadBankReg, &v5);
  return v8;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (00011C14) --------------------------------------------------------
char __stdcall SyncGetDongleCapabilities(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  NdisMSynchronizeWithInterrupt(a1, GetDongleCapabilities, &v4);
  return 1;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (00011C44) --------------------------------------------------------
int __stdcall SyncSetDongleCapabilities(int a1, int a2, int a3)
{
  int v4; // [sp+0h] [bp-8h]@1
  int v5; // [sp+4h] [bp-4h]@1

  v4 = a2;
  v5 = a3;
  NdisMSynchronizeWithInterrupt(a1, SetDongleCapabilities, &v4);
  return 0;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (00011C74) --------------------------------------------------------
void __stdcall GetFifoStatus(int a1)
{
  int v1; // esi@1
  UCHAR v2; // al@2
  unsigned __int16 v3; // dx@2
  UCHAR v4; // [sp+17h] [bp+Bh]@2

  v1 = a1;
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 3), 0xECu);
  **(_BYTE **)(a1 + 4) = READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 5));
  **(_DWORD **)(a1 + 8) = 0;
  if ( **(_BYTE **)(a1 + 4) & 0x80 )
  {
    v4 = READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)a1 + 6));
    v2 = READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)v1 + 7));
    **(_DWORD **)(v1 + 8) = v4;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = v2;
    **(_DWORD **)(v1 + 8) |= v3;
  }
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)v1 + 3), 3u);
}

//----- (00011CEE) --------------------------------------------------------
__int16 __stdcall SyncGetFifoStatus(int a1, int a2, int a3, int a4)
{
  int v5; // [sp+4h] [bp-Ch]@1
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v5 = a2;
  v7 = a4;
  v6 = a3;
  NdisMSynchronizeWithInterrupt(a1, GetFifoStatus, &v5);
  return *(_BYTE *)a3 & 0x80;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (00011D2C) --------------------------------------------------------
void __stdcall Ir108ConfigWrite(PUCHAR Port, UCHAR a2, UCHAR Value, UCHAR a4)
{
  UCHAR v4; // [sp+1Ch] [bp+14h]@3

  if ( a4 )
  {
    WRITE_PORT_UCHAR(&Port[a2], Value);
    WRITE_PORT_UCHAR(&Port[a2], Value);
  }
  else
  {
    v4 = READ_PORT_UCHAR(Port);
    WRITE_PORT_UCHAR(Port, a2);
    WRITE_PORT_UCHAR(Port + 1, Value);
    WRITE_PORT_UCHAR(Port + 1, Value);
    WRITE_PORT_UCHAR(Port, v4);
  }
}

//----- (00011D92) --------------------------------------------------------
UCHAR __stdcall Ir108ConfigRead(PUCHAR Port, UCHAR Value, char a3)
{
  PUCHAR v3; // ebx@3
  UCHAR Porta; // [sp+8h] [bp+8h]@3
  UCHAR v6; // [sp+13h] [bp+13h]@2

  if ( a3 )
  {
    v6 = READ_PORT_UCHAR(&Port[Value]);
  }
  else
  {
    v3 = Port;
    Porta = READ_PORT_UCHAR(Port);
    WRITE_PORT_UCHAR(v3, Value);
    v6 = READ_PORT_UCHAR(v3 + 1);
    WRITE_PORT_UCHAR(v3, Porta);
  }
  return v6;
}

//----- (00011DEC) --------------------------------------------------------
char __stdcall NSC_DEMO_Init(int Value)
{
  int v1; // esi@1
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char v5; // al@6
  UCHAR v6; // al@7
  UCHAR v7; // al@7
  UCHAR v8; // al@11
  UCHAR v9; // al@11
  UCHAR v10; // al@15
  UCHAR v11; // al@15
  UCHAR v12; // al@15
  UCHAR v13; // al@17
  char v15; // cl@34
  UCHAR v16; // cl@44
  UCHAR v17; // al@48
  char v18; // [sp+Ch] [bp-4h]@1
  UCHAR Valueb; // [sp+18h] [bp+8h]@7
  char Valuea; // [sp+18h] [bp+8h]@11
  char v21; // [sp+1Bh] [bp+Bh]@50

  v1 = Value;
  v2 = *(_DWORD *)(Value + 4);
  v18 = 0;
  if ( !v2 )
  {
    v13 = READ_PORT_UCHAR(*(PUCHAR *)(Value + 364));
    if ( v13 != 90 && v13 == -1 )
      return 0;
    if ( *(_DWORD *)(Value + 372) == 744 )
    {
      v5 = 1;
      goto LABEL_27;
    }
    if ( *(_DWORD *)(Value + 372) == 760 )
    {
      v5 = 3;
      goto LABEL_27;
    }
    if ( *(_DWORD *)(Value + 372) != 1000 )
    {
      if ( *(_DWORD *)(Value + 372) != 1016 )
        return 0;
      v5 = 2;
      goto LABEL_27;
    }
LABEL_6:
    v5 = 0;
LABEL_27:
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0, v5 | 0x14, v18);
    switch ( *(_DWORD *)(Value + 376) )
    {
      case 3:
        v15 = 1;
        break;
      case 4:
        v15 = 2;
        break;
      case 5:
        v15 = 3;
        break;
      case 7:
        v15 = 4;
        break;
      case 9:
        v15 = 5;
        break;
      case 0xB:
        v15 = 6;
        break;
      default:
        if ( *(_DWORD *)(Value + 376) != 15 )
          return 0;
        v15 = 7;
        break;
    }
    if ( !*(_BYTE *)(Value + 380) )
    {
      v16 = v15 | 8;
      goto LABEL_47;
    }
    if ( *(_BYTE *)(Value + 380) == 1 )
    {
      v16 = v15 | 0x10;
      goto LABEL_47;
    }
    if ( *(_BYTE *)(Value + 380) == 3 )
    {
      v16 = v15 | 0x18;
LABEL_47:
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 1u, v16, v18);
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 2u, 3u, v18);
      goto LABEL_48;
    }
    return 0;
  }
  v3 = v2 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 == 2 )
      {
        v18 = 1;
        *(_DWORD *)(Value + 364) = *(_DWORD *)(Value + 372) + 8;
        goto LABEL_6;
      }
    }
    else
    {
      v6 = Ir108ConfigRead(*(PUCHAR *)(Value + 364), 0x1Bu, 0);
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x1Bu, v6 | 8, 0);
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x46u, (*(_DWORD *)(Value + 368) >> 2) & 0xFE, 0);
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x47u, (*(_WORD *)(Value + 368) >> 8) & 0xFC, 0);
      Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x51u, 4u, 0);
      Valueb = 16 * *(_BYTE *)(Value + 376);
      v7 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0x1Cu, 0);
      Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x1Cu, v7 | Valueb, 0);
      if ( *(_BYTE *)(v1 + 380) )
      {
        if ( *(_BYTE *)(v1 + 380) == 1 )
        {
          Valuea = 2;
        }
        else if ( *(_BYTE *)(v1 + 380) == 2 )
        {
          Valuea = 3;
        }
        else
        {
          if ( *(_BYTE *)(v1 + 380) != 3 )
            return 0;
          v8 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0x50u, 0);
          Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x50u, v8 | 1, 0);
          v9 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0x4Cu, 0);
          Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x4Cu, v9 | 0x80, 0);
          Valuea = 4;
        }
      }
      else
      {
        Valuea = 1;
      }
      Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x4Fu, Valuea, 0);
      v10 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0x40u, 0);
      Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x40u, v10 | 0xE0, 0);
      v11 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0x50u, 0);
      Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0x50u, v11 | 0xC, 0);
      v12 = Ir108ConfigRead(*(PUCHAR *)(v1 + 364), 0, 0);
      Ir108ConfigWrite(*(PUCHAR *)(v1 + 364), 0, v12 | 4, 0);
    }
  }
  else
  {
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 7u, 5u, 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x31u, 0, 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x61u, *(_BYTE *)(Value + 368), 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x60u, *(_WORD *)(Value + 368) >> 8, 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x70u, *(_BYTE *)(Value + 376), 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x74u, *(_BYTE *)(Value + 380), 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x75u, 4u, 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0xF0u, 0x82u, 0);
    Ir108ConfigWrite(*(PUCHAR *)(Value + 364), 0x30u, 1u, 0);
  }
LABEL_48:
  v17 = NSC_ReadBankReg(*(_DWORD *)(v1 + 372), 3, 0);
  *(_DWORD *)(v1 + 456) = v17;
  if ( (signed int)v17 < 32 )
    *(_DWORD *)(v1 + 140) &= 0xFFFFFF7F;
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 2), 0);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 2), 7u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 6, 0, 0x20u);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 3), 0xECu);
  v21 = 8;
  do
  {
    READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 6));
    READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 7));
    --v21;
  }
  while ( (READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(v1 + 372) + 5)) & 0x80u) != 0 && (unsigned __int8)v21 > 0u );
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 5, 4, 0x40u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 4, 2, 0xCu);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 4, 4, 3u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 4, 5, 8u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 4, 6, 8u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 4, 7, 8u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 2, 2, 3u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 2, 4, 5u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 0, 2, 7u);
  NSC_WriteBankReg(*(_DWORD *)(v1 + 372), 2, 2, 2u);
  *(_DWORD *)(v1 + 436) = 447;
  *(_DWORD *)(v1 + 440) = 1000;
  *(_DWORD *)(v1 + 444) = 0;
  *(_BYTE *)(v1 + 13) = 1;
  *(_DWORD *)(v1 + 20) = *(_BYTE *)(v1 + 15);
  *(_DWORD *)(v1 + 16) = *(_DWORD *)(v1 + 372);
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(v1 + 24) = 1;
  SyncGetDongleCapabilities(v1 + 148, v1 + 16, v1 + 36);
  *(_BYTE *)(v1 + 13) = 0;
  *(_DWORD *)(v1 + 20) = *(_BYTE *)(v1 + 14);
  *(_DWORD *)(v1 + 16) = *(_DWORD *)(v1 + 372);
  *(_DWORD *)(v1 + 28) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  SyncGetDongleCapabilities(v1 + 148, v1 + 16, v1 + 36);
  SyncSetDongleCapabilities(v1 + 148, v1 + 16, v1 + 36);
  return 1;
}

//----- (00012312) --------------------------------------------------------
char __thiscall NSC_DEMO_SetSpeed(int this, int a2, int a3, int a4, int a5)
{
  int v5; // edi@6

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 10, (int)dword_15B30, a4);
  if ( *(_BYTE *)(a2 + 281) )
  {
    *(_BYTE *)(a2 + 281) = 0;
    CompleteDmaTransfer(this, a2 + 592, 0);
  }
  v5 = a2 + 148;
  while ( (SyncReadBankReg(a2 + 148, a3, 0, 5) & 0x60) != 96 )
    ;
  if ( (unsigned int)a4 <= 0x1C200 )
  {
    SyncWriteBankReg(a2 + 148, a3, 4, 2, 12);
    SyncWriteBankReg(a2 + 148, a3, 6, 2, 0);
    SyncWriteBankReg(a2 + 148, a3, 2, 2, 0);
    *(_DWORD *)(a2 + 28) = 0;
    SyncSetDongleCapabilities(v5, a2 + 16, a2 + 36);
    SyncReadBankReg(v5, a3, 0, 5);
    SyncReadBankReg(v5, a3, 0, 7);
  }
  else
  {
    *(_DWORD *)(a2 + 28) = ((unsigned int)a4 >= 0x3D0900) + 1;
    SyncSetDongleCapabilities(a2 + 148, a2 + 16, a2 + 36);
    SyncWriteBankReg(a2 + 148, a3, 2, 2, 3);
    if ( *(_DWORD *)(a2 + 456) >= 22 )
    {
      SyncWriteBankReg(a2 + 148, a3, 4, 0, 10);
      SyncWriteBankReg(a2 + 148, a3, 4, 1, 0);
    }
    else
    {
      SyncWriteBankReg(v5, a3, 4, 0, 2);
      SyncWriteBankReg(v5, a3, 4, 1, 0);
    }
    SyncWriteBankReg(v5, a3, 4, 6, (unsigned int)a4 < 0x3D0900 ? 6 : 8);
    SyncWriteBankReg(v5, a3, 4, 7, (unsigned __int16)((unsigned int)a4 < 0x3D0900 ? 2054 : 2056) >> 8);
    SyncWriteBankReg(v5, a3, 4, 2, 0);
    SyncWriteBankReg(v5, a3, 0, 4, (unsigned int)a4 < 0x3D0900 ? -124 : -92);
    SyncWriteBankReg(v5, a3, 2, 4, 5);
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 11, (int)dword_15B30);
  return 1;
}
// 15B30: using guessed type int dword_15B30[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000124DC) --------------------------------------------------------
int __userpurge sub_124DC@<eax>(int a1@<eax>, int a2)
{
  int v3; // [sp+0h] [bp-Ch]@1
  int v4; // [sp+4h] [bp-8h]@1
  int v5; // [sp+8h] [bp-4h]@1

  v3 = a1;
  v5 = 2;
  NdisMSynchronizeWithInterrupt(a2, SynchronizedListFunc, &v3);
  return v4;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (0001250C) --------------------------------------------------------
int __stdcall WPP_SF_D(int a1, int a2, int a3, int a4, int a5)
{
  return pfnWppTraceMessage(a1, a2, 43, a4, a3, &a5);
}
// 15E24: using guessed type int (__cdecl *pfnWppTraceMessage)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001253A) --------------------------------------------------------
int __stdcall WPP_INIT_CONTROL_ARRAY(int a1)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = "q+WuC@";
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 1;
  *(_BYTE *)(a1 + 29) = 1;
  *(_WORD *)(a1 + 30) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (0001256C) --------------------------------------------------------
NTSTATUS __cdecl W2kTraceMessage(int a1, int a2, int a3, int a4, char a5, void *a6)
{
  SIZE_T v6; // edi@1
  void *v7; // esi@1
  unsigned int v8; // ebx@1
  void **v9; // eax@2
  int *v10; // ecx@2
  int v11; // eax@3
  int v12; // edx@3
  PVOID v14; // ecx@9
  int v15; // ebx@9
  const void *v16; // eax@11
  void **v17; // esi@12
  size_t *v18; // esi@14
  size_t v19; // edi@14
  NTSTATUS v20; // esi@17
  __int16 WnodeEventItem; // [sp+Ch] [bp-B4h]@1
  char v22; // [sp+10h] [bp-B0h]@1
  int v23; // [sp+14h] [bp-ACh]@1
  int v24; // [sp+18h] [bp-A8h]@1
  int v25; // [sp+24h] [bp-9Ch]@1
  int v26; // [sp+28h] [bp-98h]@1
  int v27; // [sp+38h] [bp-88h]@1
  char *v28; // [sp+3Ch] [bp-84h]@1
  int v29; // [sp+40h] [bp-80h]@1
  int v30; // [sp+44h] [bp-7Ch]@1
  PVOID v31; // [sp+4Ch] [bp-74h]@11
  int v32; // [sp+50h] [bp-70h]@11
  SIZE_T v33; // [sp+54h] [bp-6Ch]@11
  PVOID P; // [sp+BCh] [bp-4h]@1

  v6 = 0;
  P = 0;
  memset(&WnodeEventItem, 0, 0x30u);
  v7 = a6;
  v23 = a1;
  v24 = a2;
  v25 = a4;
  v8 = 0;
  v26 = 0;
  v27 = 1703936;
  v22 = -1;
  v28 = &a5;
  v29 = 0;
  v30 = 2;
  if ( !a6 )
    goto LABEL_22;
  v9 = &a6;
  v10 = &v30;
  do
  {
    v11 = (int)(v9 + 1);
    v12 = *(_DWORD *)v11;
    v6 += *(_DWORD *)v11;
    ++v8;
    v10 += 4;
    if ( v8 <= 7 )
    {
      *(v10 - 1) = 0;
      *(v10 - 2) = (int)v7;
      *v10 = v12;
    }
    v9 = (void **)(v11 + 4);
    v7 = *v9;
  }
  while ( *v9 );
  if ( v6 > 0x2000 )
    return -1073741823;
  if ( v8 > 7 )
  {
    v14 = ExAllocatePoolWithTag(PagedPool, v6, 0x45435453u);
    v15 = 0;
    P = v14;
    if ( !v14 )
      return -1073741801;
    v16 = a6;
    v31 = v14;
    v32 = 0;
    v33 = v6;
    if ( a6 )
    {
      v17 = &a6;
      while ( 1 )
      {
        v18 = (size_t *)(v17 + 1);
        v19 = *v18;
        memcpy((char *)v14 + v15, v16, *v18);
        v17 = (void **)(v18 + 1);
        v16 = *v17;
        v15 += v19;
        if ( !*v17 )
          break;
        v14 = P;
      }
    }
    WnodeEventItem = 80;
  }
  else
  {
LABEL_22:
    WnodeEventItem = 16 * (v8 + 4);
  }
  v20 = IoWMIWriteEvent(&WnodeEventItem);
  if ( P )
    ExFreePoolWithTag(P, 0);
  return v20;
}

//----- (000126BC) --------------------------------------------------------
char __stdcall MiniportCheckForHang(PKSPIN_LOCK SpinLock)
{
  int v1; // esi@1
  int v2; // ST04_4@6
  KSPIN_LOCK *SpinLocka; // [sp+Ch] [bp+8h]@1

  v1 = (int)SpinLock;
  SpinLocka = SpinLock + 65;
  KefAcquireSpinLockAtDpcLevel(SpinLocka);
  if ( *(_BYTE *)(v1 + 280) )
  {
    if ( *(_DWORD *)(v1 + 584) )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
        WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 10, (int)dword_15B48);
      SyncWriteBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 2, 6);
      v2 = *(_DWORD *)(v1 + 372);
      *(_BYTE *)(v1 + 339) = -112;
      SyncWriteBankReg(v1 + 148, v2, 4, 2, 1);
      SyncSetInterruptMask(v1, 1);
    }
    ++*(_DWORD *)(v1 + 584);
  }
  KefReleaseSpinLockFromDpcLevel(SpinLocka);
  return 0;
}
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (00012760) --------------------------------------------------------
int __stdcall MiniportHalt(int a1)
{
  KIRQL v1; // al@4
  int v2; // ecx@4
  bool v3; // zf@4
  bool v4; // sf@4
  UINT v5; // eax@10
  int result; // eax@12

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 11, (int)dword_15B48);
  *(_DWORD *)(a1 + 452) = 3;
  v1 = KfAcquireSpinLock((PKSPIN_LOCK)(a1 + 260));
  v3 = *(_DWORD *)(a1 + 288) == 0;
  v4 = *(_DWORD *)(a1 + 288) < 0;
  *(_BYTE *)(a1 + 264) = v1;
  *(_BYTE *)(a1 + 283) = 1;
  if ( !v4 && !v3 )
  {
    KfReleaseSpinLock((PKSPIN_LOCK)(a1 + 260), v1);
    NdisWaitEvent((PNDIS_EVENT)(a1 + 292), 0xEA60u);
    *(_BYTE *)(a1 + 264) = KfAcquireSpinLock((PKSPIN_LOCK)(a1 + 260));
  }
  if ( !*(_BYTE *)(a1 + 282) )
  {
    KfReleaseSpinLock((PKSPIN_LOCK)(a1 + 260), *(_BYTE *)(a1 + 264));
    NdisWaitEvent((PNDIS_EVENT)(a1 + 308), 0xEA60u);
    *(_BYTE *)(a1 + 264) = KfAcquireSpinLock((PKSPIN_LOCK)(a1 + 260));
  }
  if ( *(_BYTE *)(a1 + 281) )
  {
    *(_BYTE *)(a1 + 281) = 0;
    CompleteDmaTransfer(v2, a1 + 592, 0);
  }
  CloseCOM(a1);
  SyncSetInterruptMask(a1, 0);
  KfReleaseSpinLock((PKSPIN_LOCK)(a1 + 260), *(_BYTE *)(a1 + 264));
  NdisMDeregisterInterrupt(a1 + 148);
  NSC_Shutdown(a1);
  DoClose(a1);
  v5 = *(_DWORD *)(a1 + 360);
  if ( v5 )
    NdisMDeregisterIoPortRange(*(NDIS_HANDLE *)a1, v5, 2u, *(PVOID *)(a1 + 364));
  NdisMDeregisterIoPortRange(
    *(NDIS_HANDLE *)a1,
    *(_DWORD *)(a1 + 368),
    8 * (*(_DWORD *)(a1 + 4) == 4) + 8,
    *(PVOID *)(a1 + 372));
  FreeDevice(a1);
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      result = WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 12, (int)dword_15B48);
  }
  return result;
}
// 12760: could not find valid save-restore pair for ebx
// 12760: could not find valid save-restore pair for edi
// 12760: could not find valid save-restore pair for esi
// 15432: using guessed type _DWORD __stdcall FreeDevice(_DWORD);
// 15878: using guessed type int __stdcall NdisMDeregisterInterrupt(_DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000128EA) --------------------------------------------------------
void __stdcall InterlockedInsertBufferSorted(int a1, int a2, PKSPIN_LOCK SpinLock)
{
  int v3; // edx@1
  int v4; // edx@5
  int v5; // ecx@7

  *((_BYTE *)SpinLock + 4) = KfAcquireSpinLock(SpinLock);
  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == a1 )
  {
    *(_DWORD *)a2 = v3;
    *(_DWORD *)(a2 + 4) = a1;
    *(_DWORD *)(v3 + 4) = a2;
    *(_DWORD *)a1 = a2;
  }
  else
  {
    while ( *(_DWORD *)(v3 + 20) <= *(_DWORD *)(a2 + 20) )
    {
      v3 = *(_DWORD *)v3;
      if ( v3 == a1 )
      {
        v4 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)a2 = a1;
        *(_DWORD *)(a2 + 4) = v4;
        *(_DWORD *)v4 = a2;
        *(_DWORD *)(a1 + 4) = a2;
        goto LABEL_6;
      }
    }
    v5 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)a2 = v3;
    *(_DWORD *)(a2 + 4) = v5;
    *(_DWORD *)v5 = a2;
    *(_DWORD *)(v3 + 4) = a2;
  }
LABEL_6:
  KfReleaseSpinLock(SpinLock, *((_BYTE *)SpinLock + 4));
}

//----- (00012958) --------------------------------------------------------
int __stdcall DeliverFullBuffers(PNDIS_BUFFER Buffer)
{
  PNDIS_BUFFER v1; // edi@4
  unsigned __int16 v2; // cx@6
  PNDIS_BUFFER i; // eax@15
  PNDIS_PACKET *v4; // ebx@18
  int v5; // ecx@18
  KIRQL v6; // al@20
  bool v7; // zf@20
  PNDIS_PACKET v8; // eax@25
  int v9; // eax@28
  int v10; // esi@28
  int result; // eax@30
  ULONG **v12; // [sp+0h] [bp-34h]@23
  int v13; // [sp+4h] [bp-30h]@23
  int v14; // [sp+8h] [bp-2Ch]@23
  __int16 *v15; // [sp+Ch] [bp-28h]@22
  int v16; // [sp+10h] [bp-24h]@22
  int v17; // [sp+14h] [bp-20h]@22
  ULONG **v18; // [sp+18h] [bp-1Ch]@12
  int v19; // [sp+1Ch] [bp-18h]@12
  int v20; // [sp+20h] [bp-14h]@12
  __int16 *v21; // [sp+24h] [bp-10h]@11
  int v22; // [sp+28h] [bp-Ch]@11
  int v23; // [sp+2Ch] [bp-8h]@11
  int Status; // [sp+30h] [bp-4h]@14

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 13, (int)dword_15B48);
  v1 = Buffer;
  while ( 1 )
  {
    while ( 1 )
    {
      v9 = sub_124DC((int)&v1[8].ByteCount, (int)&v1[5].Process);
      v10 = v9;
      if ( !v9 )
        goto LABEL_33;
      if ( v1->Process > (struct _MDL::_EPROCESS *)0x1C200 )
        break;
      v2 = ComputeFCS(*(_DWORD *)(v9 + 20), *(_DWORD *)(v9 + 16));
      if ( v2 == 3911 )
      {
        *(_DWORD *)(v10 + 16) -= 2;
        break;
      }
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
        WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 14, (int)dword_15B48, v2);
      *(_DWORD *)(v10 + 8) = 0;
      if ( !*(_BYTE *)(v10 + 24) )
      {
        v21 = &v1[8].MdlSize;
        v22 = *(_DWORD *)(v10 + 20) - 8;
        v23 = 1;
        NdisMSynchronizeWithInterrupt(&v1[5].Process, SynchronizedListFunc, &v21);
      }
      *(_DWORD *)(v10 + 20) = 0;
      v20 = 0;
      v18 = &v1[8].lpMappedSystemVa;
      *(_BYTE *)(v10 + 24) = 0;
      v19 = v10;
      NdisMSynchronizeWithInterrupt(&v1[5].Process, SynchronizedListFunc, &v18);
    }
    NdisAllocateBuffer(&Status, &Buffer, (NDIS_HANDLE)v1[11].ByteCount, *(PVOID *)(v10 + 20), *(_DWORD *)(v10 + 16));
    if ( Status )
      break;
    for ( i = Buffer; i->MdlNext; i = i->MdlNext )
      ;
    v4 = (PNDIS_PACKET *)(v10 + 12);
    v5 = *(_DWORD *)(v10 + 12);
    if ( !*(_DWORD *)(v5 + 8) )
      *(_DWORD *)(v5 + 12) = i;
    i->MdlNext = (*v4)->Private.Head;
    (*v4)->Private.Head = Buffer;
    (*v4)->Private.ValidCounts = 0;
    *(PNDIS_PACKET_POOL *)((char *)&(*v4)->Private.Pool + (*v4)->Private.NdisPacketOobOffset) = (PNDIS_PACKET_POOL)2;
    v6 = KfAcquireSpinLock((PKSPIN_LOCK)&v1[9].Process);
    v7 = BYTE3(v1[10].MdlNext) == 0;
    LOBYTE(v1[9].lpMappedSystemVa) = v6;
    if ( v7 )
    {
      _InterlockedExchangeAdd((volatile signed __int32 *)&v1[10].Process, 1u);
      KfReleaseSpinLock((PKSPIN_LOCK)&v1[9].Process, LOBYTE(v1[9].lpMappedSystemVa));
      v8 = *v4;
      *(_DWORD *)(v10 + 8) = 2;
      *(_DWORD *)&v8->MiniportReserved[0] = v10;
      InterlockedInsertBufferSorted((int)&v1[9], v10, (PKSPIN_LOCK)&v1[9].Process);
      *(_DWORD *)(&(*v4)->Private.ValidCounts + (*v4)->Private.NdisPacketOobOffset) = 0;
      ((void (__stdcall *)(struct _MDL *, int, signed int))v1->MdlNext[8].Process)(v1->MdlNext, v10 + 12, 1);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
        WPP_SF_D(
          *((_DWORD *)WPP_GLOBAL_Control + 4),
          *((_DWORD *)WPP_GLOBAL_Control + 5),
          17,
          (int)dword_15B48,
          *(_DWORD *)(v10 + 16));
    }
    else
    {
      KfReleaseSpinLock((PKSPIN_LOCK)&v1[9].Process, v6);
      if ( !*(_BYTE *)(v10 + 24) )
      {
        v15 = &v1[8].MdlSize;
        v16 = *(_DWORD *)(v10 + 20) - 8;
        v17 = 1;
        NdisMSynchronizeWithInterrupt(&v1[5].Process, SynchronizedListFunc, &v15);
      }
      *(_DWORD *)(v10 + 20) = 0;
      v14 = 0;
      v12 = &v1[8].lpMappedSystemVa;
      *(_BYTE *)(v10 + 24) = 0;
      v13 = v10;
      NdisMSynchronizeWithInterrupt(&v1[5].Process, SynchronizedListFunc, &v12);
      Buffer = 0;
      NdisUnchainBufferAtFront(*v4, &Buffer);
      if ( Buffer )
        IoFreeMdl(Buffer);
    }
  }
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control )
    return result;
  if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
  {
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 16, (int)dword_15B48);
LABEL_33:
    result = (int)WPP_GLOBAL_Control;
  }
  if ( (void **)result != &WPP_GLOBAL_Control )
  {
    if ( *(_BYTE *)(result + 32) & 2 )
      result = WPP_SF_(*(_DWORD *)(result + 16), *(_DWORD *)(result + 20), 18, (int)dword_15B48);
  }
  return result;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (00012C46) --------------------------------------------------------
char __stdcall GetPnPResources(int a1, int a2)
{
  char v2; // bl@1
  char *v3; // eax@3
  int v4; // edx@12
  int v5; // ecx@13
  int v7; // [sp+8h] [bp-C8h]@1
  int v8; // [sp+Ch] [bp-C4h]@1
  char v9; // [sp+11h] [bp-BFh]@2
  char v10; // [sp+12h] [bp-BEh]@2
  char v11; // [sp+13h] [bp-BDh]@2
  char v12; // [sp+14h] [bp-BCh]@1
  int v13; // [sp+18h] [bp-B8h]@2
  char v14; // [sp+20h] [bp-B0h]@3

  v2 = 0;
  v8 = 184;
  NdisMQueryAdapterResources(&v7, a2, &v12, &v8);
  if ( !v7 )
  {
    v10 = 0;
    v9 = 0;
    v11 = 0;
    if ( !v13 )
      goto LABEL_35;
    v3 = &v14;
    v8 = v13;
    do
    {
      if ( *(v3 - 4) == 1 )
      {
        v4 = *(_DWORD *)(a1 + 4);
        if ( (v4 || (v5 = *(_DWORD *)v3, *(_DWORD *)v3 != 234) && v5 != 920 && v5 != 336)
          && (v4 != 1 || (v5 = *(_DWORD *)v3, *(_DWORD *)v3 != 46) && v5 != 348)
          && (v4 != 2 || (v5 = *(_DWORD *)v3, *(_DWORD *)v3 != 46) && v5 != 920 && v5 != 348) )
        {
          if ( !v9 )
          {
            *(_DWORD *)(a1 + 368) = *(_DWORD *)v3;
            v9 = 1;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 360) = v5;
        }
      }
      else if ( *(v3 - 4) == 2 )
      {
        if ( !v10 )
        {
          *(_DWORD *)(a1 + 376) = *(_DWORD *)v3;
          v10 = 1;
        }
      }
      else if ( *(v3 - 4) == 4 && !v11 && (unsigned __int8)*v3 <= 3u )
      {
        *(_BYTE *)(a1 + 380) = *v3;
        v11 = 1;
      }
      v3 += 16;
      --v8;
    }
    while ( v8 );
    if ( v9 && v10 && v11 )
      v2 = 1;
    else
LABEL_35:
      v2 = 0;
  }
  return v2;
}
// 15884: using guessed type int __stdcall NdisMQueryAdapterResources(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00012DCA) --------------------------------------------------------
char __stdcall Configure(int a1, NDIS_HANDLE WrapperConfigurationContext)
{
  char v2; // bl@1
  char result; // al@2
  PNDIS_CONFIGURATION_PARAMETER v4; // eax@8
  char v5; // al@8
  PNDIS_CONFIGURATION_PARAMETER v6; // eax@10
  ULONG v7; // eax@10
  int v8; // [sp+4h] [bp-5Ch]@1
  int v9; // [sp+8h] [bp-58h]@1
  int v10; // [sp+Ch] [bp-54h]@1
  int v11; // [sp+10h] [bp-50h]@1
  int v12; // [sp+14h] [bp-4Ch]@1
  int v13; // [sp+18h] [bp-48h]@1
  int v14; // [sp+1Ch] [bp-44h]@1
  int v15; // [sp+20h] [bp-40h]@1
  int v16; // [sp+24h] [bp-3Ch]@1
  int v17; // [sp+28h] [bp-38h]@1
  int v18; // [sp+2Ch] [bp-34h]@1
  int v19; // [sp+30h] [bp-30h]@1
  UNICODE_STRING v20; // [sp+34h] [bp-2Ch]@1
  UNICODE_STRING v21; // [sp+3Ch] [bp-24h]@1
  UNICODE_STRING v22; // [sp+44h] [bp-1Ch]@1
  UNICODE_STRING Keyword; // [sp+4Ch] [bp-14h]@1
  PVOID ConfigurationHandle; // [sp+54h] [bp-Ch]@1
  PNDIS_CONFIGURATION_PARAMETER ParameterValue; // [sp+58h] [bp-8h]@3
  int Status; // [sp+5Ch] [bp-4h]@1

  v11 = 9;
  v14 = 9;
  v16 = 9;
  Keyword.Length = 18;
  Keyword.MaximumLength = 20;
  Keyword.Buffer = L"BoardType";
  v22.Length = 26;
  v22.MaximumLength = 28;
  v22.Buffer = L"Dongle_A_Type";
  v21.Length = 26;
  v21.MaximumLength = 28;
  v21.Buffer = L"Dongle_B_Type";
  v20.Length = 28;
  v20.MaximumLength = 30;
  v20.Buffer = L"MaxConnectRate";
  v8 = 14;
  v9 = 12;
  v10 = 8;
  v12 = 4;
  v13 = 12;
  v15 = 11;
  v17 = 12;
  v18 = 17;
  v19 = 16;
  NdisOpenConfiguration(&Status, &ConfigurationHandle, WrapperConfigurationContext);
  v2 = 0;
  if ( Status )
  {
    result = 0;
  }
  else
  {
    NdisReadConfiguration(&Status, &ParameterValue, ConfigurationHandle, &Keyword, NdisParameterHexInteger);
    if ( Status )
    {
      NdisCloseConfiguration(ConfigurationHandle);
      result = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = LOBYTE(ParameterValue->ParameterData.IntegerData);
      if ( GetPnPResources(a1, (int)WrapperConfigurationContext) )
      {
        NdisReadConfiguration(&Status, &ParameterValue, ConfigurationHandle, &v22, 0);
        v4 = ParameterValue;
        *(_BYTE *)(a1 + 12) = 1;
        *(_BYTE *)(a1 + 14) = *((_BYTE *)&v8 + 4 * LOBYTE(v4->ParameterData.IntegerData));
        NdisReadConfiguration(&Status, &ParameterValue, ConfigurationHandle, &v21, 0);
        v5 = *((_BYTE *)&v8 + 4 * LOBYTE(ParameterValue->ParameterData.IntegerData));
        ++*(_BYTE *)(a1 + 12);
        *(_BYTE *)(a1 + 15) = v5;
        NdisReadConfiguration(&Status, &ParameterValue, ConfigurationHandle, &v20, 0);
        if ( Status )
        {
          *(_DWORD *)(a1 + 140) = 447;
        }
        else
        {
          v6 = ParameterValue;
          *(_DWORD *)(a1 + 140) = 0;
          v7 = v6->ParameterData.IntegerData;
          if ( v7 != 9600 )
          {
            if ( v7 != 19200 )
            {
              if ( v7 != 38400 )
              {
                if ( v7 != 57600 )
                {
                  if ( v7 != 115200 )
                  {
                    if ( v7 != 1152000 )
                      *(_DWORD *)(a1 + 140) = 256;
                    *(_DWORD *)(a1 + 140) |= 0x80u;
                  }
                  *(_DWORD *)(a1 + 140) |= 0x20u;
                }
                *(_DWORD *)(a1 + 140) |= 0x10u;
              }
              *(_DWORD *)(a1 + 140) |= 8u;
            }
            *(_DWORD *)(a1 + 140) |= 4u;
          }
          *(_DWORD *)(a1 + 140) |= 3u;
        }
        v2 = 1;
      }
      NdisCloseConfiguration(ConfigurationHandle);
      result = v2;
    }
  }
  return result;
}
// 15648: using guessed type wchar_t aMaxconnectrate[15];
// 15666: using guessed type wchar_t aDongle_b_type[14];
// 15682: using guessed type wchar_t aDongle_a_type[14];
// 1569E: using guessed type wchar_t aBoardtype[10];

//----- (00012FBA) --------------------------------------------------------
char __stdcall VerifyHardware(int a1)
{
  char result; // al@2
  UCHAR *v2; // ST04_4@4
  signed int v3; // [sp+Ch] [bp-4h]@1

  v3 = 500;
  NdisMSleep(0x14u);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 3), 3u);
  WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 1), 0);
  if ( READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 1))
    || (WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 2), 7u),
        (READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 2)) & 0xC0) != -64) )
  {
    result = 0;
  }
  else
  {
    WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 4), 0xFu);
    v2 = (UCHAR *)(*(_DWORD *)(a1 + 372) + 1);
    *(_BYTE *)(a1 + 285) = 0;
    *(_BYTE *)(a1 + 284) = 1;
    WRITE_PORT_UCHAR(v2, 2u);
    while ( !*(_BYTE *)(a1 + 285) && v3 > 0 )
    {
      NdisMSleep(0x3E8u);
      --v3;
    }
    WRITE_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a1 + 372) + 1), 0);
    result = *(_BYTE *)(a1 + 285);
    *(_BYTE *)(a1 + 284) = 0;
  }
  return result;
}

//----- (00013098) --------------------------------------------------------
int __stdcall QueueReceivePacket(int a1, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // ecx@8
  int v6; // eax@9
  int v7; // edx@9
  int v8; // edx@13
  int v9; // [sp+Ch] [bp-Ch]@14
  int v10; // [sp+10h] [bp-8h]@14
  int v11; // [sp+14h] [bp-4h]@14

  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    {
      WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 27, (int)dword_15B48);
      result = (int)WPP_GLOBAL_Control;
    }
    if ( (void **)result != &WPP_GLOBAL_Control && *(_BYTE *)(result + 32) & 2 )
    {
      WPP_SF_D(*(_DWORD *)(result + 16), *(_DWORD *)(result + 20), 28, (int)dword_15B48, a3);
      result = (int)WPP_GLOBAL_Control;
    }
  }
  if ( a4 )
  {
    v6 = sub_124DC(a1 + 236, a1 + 148);
  }
  else
  {
    v5 = a1 + 236;
    if ( *(_DWORD *)v5 == v5 )
      goto LABEL_16;
    v6 = *(_DWORD *)v5;
    v7 = **(_DWORD **)v5;
    *(_DWORD *)v5 = v7;
    *(_DWORD *)(v7 + 4) = v5;
  }
  if ( v6 )
  {
    *(_DWORD *)(v6 + 20) = a2;
    *(_DWORD *)(v6 + 8) = 1;
    *(_DWORD *)(v6 + 16) = a3;
    if ( a4 )
    {
      *(_BYTE *)(v6 + 24) = 1;
      v10 = v6;
      v9 = a1 + 244;
      v11 = 1;
      NdisMSynchronizeWithInterrupt(a1 + 148, SynchronizedListFunc, &v9);
    }
    else
    {
      *(_BYTE *)(v6 + 24) = 0;
      v8 = *(_DWORD *)(a1 + 248);
      *(_DWORD *)v6 = a1 + 244;
      *(_DWORD *)(v6 + 4) = v8;
      *(_DWORD *)v8 = v6;
      *(_DWORD *)(a1 + 248) = v6;
    }
  }
  result = (int)WPP_GLOBAL_Control;
LABEL_16:
  if ( (void **)result != &WPP_GLOBAL_Control )
  {
    if ( *(_BYTE *)(result + 32) & 2 )
      result = WPP_SF_(*(_DWORD *)(result + 16), *(_DWORD *)(result + 20), 29, (int)dword_15B48);
  }
  return result;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000131AA) --------------------------------------------------------
int __stdcall MiniportISR(int *a1, char *a2, int a3)
{
  UCHAR *v3; // ST08_4@3
  int result; // eax@4

  if ( *(_BYTE *)(a3 + 284) )
  {
    if ( READ_PORT_UCHAR((PUCHAR)(*(_DWORD *)(a3 + 372) + 2)) & 1 )
    {
      *(_BYTE *)a1 = 0;
    }
    else
    {
      v3 = (UCHAR *)(*(_DWORD *)(a3 + 372) + 1);
      *(_BYTE *)(a3 + 285) = 1;
      *(_BYTE *)(a3 + 284) = 0;
      WRITE_PORT_UCHAR(v3, 0);
      *(_BYTE *)a1 = 1;
    }
    result = (int)a2;
    *a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a3 + 8) <= 0x1C200u )
      COM_ISR(a3, (int)a1, (int)a2);
    else
      NSC_FIR_ISR(a3, a1, a2);
    result = (int)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      result = WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 30, (int)dword_15B48);
  }
  return result;
}
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (0001324C) --------------------------------------------------------
void __stdcall ReturnPacketHandler(PNDIS_BUFFER Buffer, PNDIS_PACKET Packet)
{
  int v2; // esi@1
  PNDIS_BUFFER v3; // edi@1
  signed __int32 v4; // eax@10
  void *v5; // [sp+8h] [bp-Ch]@2
  int v6; // [sp+Ch] [bp-8h]@2
  int v7; // [sp+10h] [bp-4h]@2

  ++dword_15E50;
  v2 = *(_DWORD *)&Packet->MiniportReserved[0];
  v3 = Buffer;
  if ( *(_DWORD *)(v2 + 8) == 2 )
  {
    v6 = *(_DWORD *)&Packet->MiniportReserved[0];
    v7 = 4;
    NdisMSynchronizeWithInterrupt(&Buffer[5].Process, SynchronizedListFunc, &v5);
    NdisUnchainBufferAtFront(Packet, &Buffer);
    if ( Buffer )
      IoFreeMdl(Buffer);
    if ( !*(_BYTE *)(v2 + 24) )
    {
      v5 = &v3[8].MdlSize;
      v6 = *(_DWORD *)(v2 + 20) - 8;
      v7 = 1;
      NdisMSynchronizeWithInterrupt(&v3[5].Process, SynchronizedListFunc, &v5);
    }
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    v7 = 0;
    v5 = &v3[8].lpMappedSystemVa;
    v6 = v2;
    NdisMSynchronizeWithInterrupt(&v3[5].Process, SynchronizedListFunc, &v5);
  }
  else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
  {
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 31, (int)dword_15B48);
  }
  LOBYTE(v3[9].lpMappedSystemVa) = KfAcquireSpinLock((PKSPIN_LOCK)&v3[9].Process);
  v4 = _InterlockedDecrement((volatile signed __int32 *)&v3[10].Process);
  if ( BYTE3(v3[10].MdlNext) && !v4 )
    NdisSetEvent((PNDIS_EVENT)&v3[10].lpMappedSystemVa);
  KfReleaseSpinLock((PKSPIN_LOCK)&v3[9].Process, LOBYTE(v3[9].lpMappedSystemVa));
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E50: using guessed type int dword_15E50;

//----- (00013384) --------------------------------------------------------
void __stdcall GivePacketToSirISR(int a1)
{
  int v1; // ST00_4@1

  *(_DWORD *)(a1 + 420) = 0;
  v1 = *(_DWORD *)(a1 + 372);
  *(_DWORD *)(a1 + 428) = 1;
  *(_BYTE *)(a1 + 338) = 0;
  SetCOMPort(v1, 1, 3u);
}

//----- (000133BA) --------------------------------------------------------
void __stdcall SendCurrentPacket(PKSPIN_LOCK SpinLock)
{
  KSPIN_LOCK *v1; // esi@1
  int v2; // ecx@1
  int v3; // eax@1
  bool v4; // zf@1
  int v5; // ST04_4@6
  int *v6; // ebx@6
  int v7; // ecx@9
  KSPIN_LOCK v8; // [sp+Ch] [bp-4h]@1
  int SpinLocka; // [sp+18h] [bp+8h]@10

  v1 = SpinLock;
  v8 = 0;
  *((_BYTE *)SpinLock + 264) = KfAcquireSpinLock(SpinLock + 65);
  v3 = SpinLock[69];
  v4 = v3 == SpinLock[88];
  *((_BYTE *)SpinLock + 282) = 0;
  if ( v4 )
    *((_BYTE *)SpinLock + 356) = 1;
  if ( SpinLock[2] <= 0x1C200 )
  {
    if ( NdisToIrPacket(v3, (void *)SpinLock[104], 0x1036u, (int)(SpinLock + 106)) )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 8 )
        WPP_SF_D(
          *((_DWORD *)WPP_GLOBAL_Control + 4),
          *((_DWORD *)WPP_GLOBAL_Control + 5),
          35,
          (int)dword_15B48,
          SpinLock[106]);
      NdisMSynchronizeWithInterrupt(SpinLock + 37, GivePacketToSirISR, SpinLock);
    }
    else
    {
      v8 = SpinLock[69];
      SpinLock[69] = 0;
    }
  }
  else
  {
    if ( *((_BYTE *)SpinLock + 281) )
    {
      *((_BYTE *)SpinLock + 281) = 0;
      CompleteDmaTransfer(v2, (int)(SpinLock + 148), 0);
    }
    v5 = SpinLock[93];
    SpinLock[146] = 0;
    *((_BYTE *)SpinLock + 280) = 1;
    SyncWriteBankReg((int)(SpinLock + 37), v5, 2, 2, 11);
    *((_BYTE *)SpinLock + 339) = 20;
    SyncSetInterruptMask((int)SpinLock, 1);
    v6 = (int *)(SpinLock + 171);
    NdisToFirPacket(SpinLock[69], SpinLock[170], 0x1036u, (int)(SpinLock + 171));
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 4 )
      WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 32, (int)dword_15B48, *v6);
    if ( (SyncReadBankReg((int)(SpinLock + 37), SpinLock[93], 0, 5) & 0x60) != 96 )
    {
      SpinLocka = 0;
      do
      {
        if ( (unsigned int)SpinLocka >= 0x10 )
          break;
        ++SpinLocka;
      }
      while ( (SyncReadBankReg((int)(v1 + 37), v1[93], 0, 5) & 0x60) != 96 );
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
        WPP_SF_D(
          *((_DWORD *)WPP_GLOBAL_Control + 4),
          *((_DWORD *)WPP_GLOBAL_Control + 5),
          33,
          (int)dword_15B48,
          SpinLocka);
    }
    StartDmaTransfer(v7, (int)(v1 + 148), (PNDIS_BUFFER)v1[127], 0, *v6, 1u);
    SyncSetInterruptMask((int)v1, 1);
  }
  KfReleaseSpinLock(v1 + 65, *((_BYTE *)v1 + 264));
  if ( v8 )
  {
    (*(void (__stdcall **)(KSPIN_LOCK, KSPIN_LOCK, signed int))(*v1 + 236))(*v1, v8, -1073741823);
    ProcessSendQueue(v1);
  }
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000135BA) --------------------------------------------------------
void __stdcall DelayedWrite(PVOID SystemSpecific1, PVOID FunctionContext, PVOID SystemSpecific2, PVOID SystemSpecific3)
{
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 36, (int)dword_15B48);
  SendCurrentPacket((PKSPIN_LOCK)FunctionContext);
}
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000135F4) --------------------------------------------------------
NTSTATUS __stdcall NscUloadHandler(PDEVICE_OBJECT DeviceObject)
{
  return WppCleanupKm(DeviceObject);
}

//----- (00013604) --------------------------------------------------------
int __stdcall GetPacketInfo(int a1)
{
  char v1; // cl@1
  int v2; // eax@3

  v1 = *(_BYTE *)(a1 + 29);
  if ( v1 < 0 && v1 & 0x40 )
    v2 = *(_DWORD *)(*(_WORD *)(a1 + 30) + a1 + 24);
  else
    v2 = 0;
  return v2 + 12;
}

//----- (00013630) --------------------------------------------------------
int __stdcall SetupRecv(int a1)
{
  int v1; // esi@4
  int v2; // edi@4
  int *v3; // ebx@4
  char v4; // al@4
  signed int v5; // eax@5
  int v6; // ST24_4@6
  int v7; // ST08_4@11
  int v8; // ecx@11
  bool v9; // cf@11
  ULONG v10; // eax@15
  ULONG v11; // ST0C_4@15
  int result; // eax@15
  int v13; // ST14_4@17
  int v14; // edi@17
  char v15; // [sp+0h] [bp-8h]@6
  signed int v16; // [sp+4h] [bp-4h]@1
  int v17; // [sp+10h] [bp+8h]@15
  char v18; // [sp+13h] [bp+Bh]@10

  v16 = 8;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 42, (int)dword_15B48);
  v1 = a1;
  v2 = a1 + 496;
  v3 = (int *)(a1 + 492);
  FindLargestSpace(a1, a1 + 492, a1 + 496);
  v4 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 5);
  while ( 1 )
  {
    v18 = v4;
    if ( v4 >= 0 )
      break;
    v5 = v16--;
    if ( !v5 )
      break;
    v6 = (unsigned __int8)SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 6);
    v15 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 7) | v6;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
      WPP_SF_dd(
        *((_DWORD *)WPP_GLOBAL_Control + 4),
        *((_DWORD *)WPP_GLOBAL_Control + 5),
        43,
        (int)dword_15B48,
        (unsigned __int8)v18,
        v15);
    v4 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 5);
    *(_BYTE *)(v1 + 588) = 1;
  }
  v7 = *(_DWORD *)(v1 + 372);
  *(_DWORD *)(v1 + 500) = *v3;
  SyncWriteBankReg(v1 + 148, v7, 2, 2, 3);
  v8 = *(_DWORD *)v2;
  v9 = *(_DWORD *)v2 < 0x2000u;
  *(_BYTE *)(v1 + 281) = 1;
  if ( v9 && WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 44, (int)dword_15B48, v8);
  v10 = *(_DWORD *)v2;
  v11 = *v3;
  *(_DWORD *)(v1 + 504) = *(_DWORD *)v2;
  v17 = StartDmaTransfer(v8, v1 + 592, *(PNDIS_BUFFER *)(v1 + 484), v11, v10, 0);
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
  {
    v13 = *(_DWORD *)v2;
    v14 = (int)dword_15B48;
    WPP_SF_dd(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 45, (int)dword_15B48, *v3, v13);
    result = (int)WPP_GLOBAL_Control;
  }
  else
  {
    v14 = (int)dword_15B48;
  }
  if ( v17 )
  {
    *(_BYTE *)(v1 + 281) = 0;
    result = (int)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control )
      return result;
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    {
      WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 46, v14, v17);
      result = (int)WPP_GLOBAL_Control;
    }
  }
  if ( (void **)result != &WPP_GLOBAL_Control )
  {
    if ( *(_BYTE *)(result + 32) & 2 )
      result = WPP_SF_(*(_DWORD *)(result + 16), *(_DWORD *)(result + 20), 47, v14);
  }
  return result;
}
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (0001383A) --------------------------------------------------------
int __stdcall MiniportInitialize(int a1, int a2, int a3, int a4, int MiniportAdapterHandle, NDIS_HANDLE WrapperConfigurationContext)
{
  unsigned int v6; // eax@1
  int v7; // eax@5
  int v8; // esi@5
  int result; // eax@6
  int *v10; // edi@9
  UINT v11; // eax@18
  signed int v12; // edi@22
  void *v13; // ecx@23

  v6 = 0;
  if ( !a4 )
    goto LABEL_33;
  do
  {
    if ( *(_DWORD *)(a3 + 4 * v6) == 10 )
      break;
    ++v6;
  }
  while ( v6 < a4 );
  if ( v6 < a4 )
  {
    *(_DWORD *)a2 = v6;
    v7 = (int)NewDevice((void *)a2);
    v8 = v7;
    if ( !v7 )
      return 65539;
    *(_DWORD *)(v7 + 452) = 1;
    if ( OpenDevice(v7) )
    {
      *(_DWORD *)v8 = MiniportAdapterHandle;
      if ( Configure(v8, WrapperConfigurationContext) )
      {
        NdisMSetAttributesEx(MiniportAdapterHandle, v8, 0, 32, 0);
        v10 = (int *)(v8 + 372);
        if ( NdisMRegisterIoPortRange(
               (PVOID *)(v8 + 372),
               (NDIS_HANDLE)MiniportAdapterHandle,
               *(_DWORD *)(v8 + 368),
               8 * (*(_DWORD *)(v8 + 4) == 4) + 8) )
        {
          *v10 = 0;
        }
        else
        {
          v11 = *(_DWORD *)(v8 + 360);
          if ( v11 && NdisMRegisterIoPortRange((PVOID *)(v8 + 364), (NDIS_HANDLE)MiniportAdapterHandle, v11, 2u) )
          {
            *(_DWORD *)(v8 + 364) = 0;
          }
          else
          {
            NdisMSleep(0x14u);
            NSC_WriteBankReg(*v10, 2, 2, 2u);
            WRITE_PORT_UCHAR((PUCHAR)(*v10 + 3), 3u);
            WRITE_PORT_UCHAR((PUCHAR)(*v10 + 1), 0);
            if ( !NdisMRegisterInterrupt(
                    v8 + 148,
                    MiniportAdapterHandle,
                    *(_DWORD *)(v8 + 376),
                    *(_DWORD *)(v8 + 376),
                    1,
                    1,
                    1) )
            {
              *(_BYTE *)(v8 + 144) = 1;
              v12 = 5;
              do
              {
                if ( VerifyHardware(v8) )
                  break;
                --v12;
              }
              while ( v12 > 0 );
              if ( v12 && DoOpen(v13, v8) )
              {
                if ( NSC_Setup(v8) )
                {
                  *(_DWORD *)(v8 + 452) = 0;
                  return 0;
                }
                NSC_Shutdown(v8);
              }
            }
          }
        }
      }
    }
    if ( *(_BYTE *)(v8 + 144) )
    {
      NdisMDeregisterInterrupt(v8 + 148);
      *(_BYTE *)(v8 + 144) = 0;
    }
    if ( *(_DWORD *)(v8 + 372) )
    {
      NdisMDeregisterIoPortRange(
        *(NDIS_HANDLE *)v8,
        *(_DWORD *)(v8 + 368),
        8 * (*(_DWORD *)(v8 + 4) == 4) + 8,
        *(PVOID *)(v8 + 372));
      *(_DWORD *)(v8 + 372) = 0;
    }
    if ( *(_DWORD *)(v8 + 364) )
    {
      NdisMDeregisterIoPortRange(*(NDIS_HANDLE *)v8, *(_DWORD *)(v8 + 360), 2u, *(PVOID *)(v8 + 364));
      *(_DWORD *)(v8 + 364) = 0;
    }
    FreeDevice(v8);
    result = -1073741823;
  }
  else
  {
LABEL_33:
    result = -1073676263;
  }
  return result;
}
// 15432: using guessed type _DWORD __stdcall FreeDevice(_DWORD);
// 15878: using guessed type int __stdcall NdisMDeregisterInterrupt(_DWORD);
// 1589C: using guessed type int __stdcall NdisMRegisterInterrupt(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 158A4: using guessed type int __stdcall NdisMSetAttributesEx(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00013A38) --------------------------------------------------------
void __stdcall ProcessSendQueue(PKSPIN_LOCK SpinLock)
{
  int v1; // esi@1
  KIRQL v2; // al@1
  bool v3; // zf@1
  int v4; // eax@2
  int v5; // ecx@3
  int v6; // edx@3
  int v7; // edi@3
  unsigned int v8; // eax@3
  unsigned int v9; // eax@5
  KSPIN_LOCK *SpinLocka; // [sp+10h] [bp+8h]@1

  v1 = (int)SpinLock;
  SpinLocka = SpinLock + 65;
  v2 = KfAcquireSpinLock(SpinLocka);
  v3 = *(_DWORD *)(v1 + 276) == 0;
  *(_BYTE *)(v1 + 264) = v2;
  if ( !v3 )
  {
LABEL_16:
    KfReleaseSpinLock(SpinLocka, *(_BYTE *)(v1 + 264));
    return;
  }
  v4 = v1 + 268;
  if ( *(_DWORD *)v4 == v4 )
  {
LABEL_9:
    if ( !*(_DWORD *)(v1 + 276) && *(_DWORD *)(v1 + 268) == v1 + 268 && !*(_BYTE *)(v1 + 282) )
    {
      v3 = *(_BYTE *)(v1 + 283) == 0;
      *(_BYTE *)(v1 + 282) = 1;
      if ( !v3 )
        NdisSetEvent((PNDIS_EVENT)(v1 + 308));
      if ( *(_DWORD *)(v1 + 8) > 0x1C200u )
      {
        *(_BYTE *)(v1 + 339) = 4;
        SetupRecv(v1);
        SyncSetInterruptMask(v1, 1);
      }
    }
    goto LABEL_16;
  }
  v5 = *(_DWORD *)v4;
  v6 = **(_DWORD **)v4;
  *(_DWORD *)v4 = v6;
  *(_DWORD *)(v6 + 4) = v4;
  LOBYTE(v6) = *(_BYTE *)(v1 + 264);
  v7 = v5 - 32;
  *(_DWORD *)(v1 + 276) = v5 - 32;
  KfReleaseSpinLock(SpinLocka, v6);
  v8 = *(_DWORD *)(GetPacketInfo(v7) + 4);
  if ( !v8 )
  {
    SendCurrentPacket((PKSPIN_LOCK)v1);
    *(_BYTE *)(v1 + 264) = KfAcquireSpinLock(SpinLocka);
    goto LABEL_9;
  }
  if ( v8 >= 0x3E8 )
    v9 = (v8 + 500) / 0x3E8;
  else
    v9 = 1;
  NdisSetTimer((PNDIS_TIMER)(v1 + 512), v9);
  *(_BYTE *)(v1 + 344) = 0;
}

//----- (00013B4E) --------------------------------------------------------
int __stdcall SendPacketsHandler(PKSPIN_LOCK SpinLock, int a2, int a3)
{
  void *v3; // eax@1
  unsigned int v4; // edi@7
  KSPIN_LOCK v5; // edx@10
  int v6; // eax@10
  int result; // eax@12

  v3 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    {
      WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 37, (int)dword_15B48);
      v3 = WPP_GLOBAL_Control;
    }
    if ( v3 != &WPP_GLOBAL_Control && *((_BYTE *)v3 + 32) & 2 )
      WPP_SF_D(*((_DWORD *)v3 + 4), *((_DWORD *)v3 + 5), 38, (int)dword_15B48, a3);
  }
  v4 = 0;
  *((_BYTE *)SpinLock + 264) = KfAcquireSpinLock(SpinLock + 65);
  if ( a3 )
  {
    do
    {
      if ( *((_BYTE *)SpinLock + 283) )
      {
        KfReleaseSpinLock(SpinLock + 65, *((_BYTE *)SpinLock + 264));
        (*(void (__stdcall **)(KSPIN_LOCK, _DWORD, signed int))(*SpinLock + 236))(
          *SpinLock,
          *(_DWORD *)(a2 + 4 * v4),
          -1073741823);
        *((_BYTE *)SpinLock + 264) = KfAcquireSpinLock(SpinLock + 65);
      }
      else
      {
        v5 = SpinLock[68];
        v6 = *(_DWORD *)(a2 + 4 * v4) + 32;
        *(_DWORD *)v6 = SpinLock + 67;
        *(_DWORD *)(v6 + 4) = v5;
        *(_DWORD *)v5 = v6;
        SpinLock[68] = v6;
      }
      ++v4;
    }
    while ( v4 < a3 );
  }
  KfReleaseSpinLock(SpinLock + 65, *((_BYTE *)SpinLock + 264));
  ProcessSendQueue(SpinLock);
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      result = WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 39, (int)dword_15B48);
  }
  return result;
}
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (00013C68) --------------------------------------------------------
int __stdcall MiniportHandleInterrupt(PNDIS_BUFFER Buffer)
{
  int v1; // ebx@1
  void *v2; // eax@1
  int v3; // esi@4
  bool v4; // zf@12
  struct _MDL *v5; // ST18_4@13
  int v6; // eax@13
  int v7; // ecx@17
  unsigned __int8 v8; // bl@17
  int v9; // ebx@27
  char v10; // al@27
  __int16 v11; // cx@27
  unsigned __int16 v12; // bx@27
  int v13; // eax@30
  int result; // eax@44
  int v15; // [sp+8h] [bp-4h]@1
  PNDIS_BUFFER Buffera; // [sp+14h] [bp+8h]@13

  v1 = 0;
  v15 = 0;
  v2 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
  {
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 19, (int)dword_15B48);
    v2 = WPP_GLOBAL_Control;
  }
  v3 = (int)Buffer;
  if ( LOBYTE(Buffer[12].MdlNext) && !BYTE1(Buffer[12].MdlNext) )
  {
    if ( Buffer->Process > (struct _MDL::_EPROCESS *)0x1C200 && v2 != &WPP_GLOBAL_Control && *((_BYTE *)v2 + 32) & 2 )
      WPP_SF_D(*((_DWORD *)v2 + 4), *((_DWORD *)v2 + 5), 20, (int)dword_15B48, (int)Buffer->Process);
    NdisMIndicateStatus(Buffer->MdlNext, 1073807377, 0, 0);
    NdisMIndicateStatusComplete(Buffer->MdlNext);
    BYTE1(Buffer[12].MdlNext) = 1;
  }
  KefAcquireSpinLockAtDpcLevel((PKSPIN_LOCK)&Buffer[9].Process);
  if ( Buffer->Process <= (struct _MDL::_EPROCESS *)0x1C200 )
  {
    v13 = (int)&Buffer[9].ByteOffset;
    if ( Buffer[9].ByteOffset && _InterlockedExchange((volatile signed __int32 *)&Buffer[15].lpMappedSystemVa, 0) )
    {
LABEL_38:
      v1 = *(_DWORD *)v13;
      *(_DWORD *)v13 = 0;
      goto LABEL_39;
    }
  }
  else
  {
    v4 = LOBYTE(Buffer[10].MdlNext) == 0;
    BYTE3(Buffer[12].MdlNext) = 0;
    if ( !v4 )
    {
      v5 = Buffer[17].MdlNext;
      Buffera = 0;
      *(_BYTE *)(v3 + 280) = 0;
      v6 = NdisMReadDmaCounter(v5);
      if ( v6 && WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
        WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 21, (int)dword_15B48, v6);
      v8 = SyncReadBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 2, 6) & 0x3F;
      if ( v8 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
          WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 22, (int)dword_15B48, v8);
        do
        {
          if ( (unsigned int)Buffera >= 0x40 )
            break;
          v8 = SyncReadBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 2, 6) & 0x3F;
          Buffera = (PNDIS_BUFFER)((char *)Buffera + 1);
        }
        while ( v8 );
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
          WPP_SF_dd(
            *((_DWORD *)WPP_GLOBAL_Control + 4),
            *((_DWORD *)WPP_GLOBAL_Control + 5),
            23,
            (int)dword_15B48,
            v8,
            (char)Buffera);
      }
      v15 = CompleteDmaTransfer(v7, v3 + 592, 1);
      if ( SyncReadBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 0, 7) & 0x40 )
      {
        v9 = (unsigned __int8)SyncReadBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 4, 4);
        v10 = SyncReadBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 4, 4);
        LOBYTE(v11) = 0;
        HIBYTE(v11) = v10;
        v12 = v11 | v9;
        SyncWriteBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 0, 2, 7);
        SyncWriteBankReg(v3 + 148, *(_DWORD *)(v3 + 372), 0, 7, 64);
        ++dword_15E40;
        v15 = -1073741823;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
        {
          if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
            WPP_SF_D(
              *((_DWORD *)WPP_GLOBAL_Control + 4),
              *((_DWORD *)WPP_GLOBAL_Control + 5),
              24,
              (int)dword_15B48,
              v12);
        }
      }
      v13 = v3 + 276;
      goto LABEL_38;
    }
    if ( BYTE1(Buffer[10].MdlNext) )
    {
      FIR_DeliverFrames((unsigned int)Buffer);
    }
    else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
    {
      WPP_SF_D(
        *((_DWORD *)WPP_GLOBAL_Control + 4),
        *((_DWORD *)WPP_GLOBAL_Control + 5),
        25,
        (int)dword_15B48,
        LOBYTE(Buffer[12].MdlFlags));
    }
  }
LABEL_39:
  *(_BYTE *)(v3 + 356) = 0;
  if ( v1 && *(_DWORD *)(v3 + 352) == v1 )
  {
    *(_DWORD *)(v3 + 352) = 0;
    SetSpeed(v3);
  }
  KefReleaseSpinLockFromDpcLevel((PKSPIN_LOCK)(v3 + 260));
  if ( v1 )
  {
    ProcessSendQueue((PKSPIN_LOCK)v3);
    (*(void (__stdcall **)(_DWORD, int, int))(*(_DWORD *)v3 + 236))(*(_DWORD *)v3, v1, v15);
  }
  DeliverFullBuffers((PNDIS_BUFFER)v3);
  SyncSetInterruptMask(v3, 1);
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      result = WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 26, (int)dword_15B48);
  }
  return result;
}
// 15840: using guessed type int __stdcall NdisMIndicateStatus(_DWORD, _DWORD, _DWORD, _DWORD);
// 15844: using guessed type int __stdcall NdisMIndicateStatusComplete(_DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E40: using guessed type int dword_15E40;

//----- (00013F86) --------------------------------------------------------
int __stdcall MiniportReset(int a1, PKSPIN_LOCK SpinLock)
{
  PKSPIN_LOCK v2; // eax@1
  int *v3; // ecx@2
  KSPIN_LOCK v4; // edx@2
  int *v5; // edx@2
  bool v6; // zf@2
  KSPIN_LOCK v7; // eax@3
  int v8; // ecx@11
  int v10; // [sp+Ch] [bp-Ch]@1
  int *v11; // [sp+10h] [bp-8h]@1
  char v12; // [sp+17h] [bp-1h]@1

  v12 = 0;
  v11 = &v10;
  v10 = (int)&v10;
  *((_BYTE *)SpinLock + 264) = KfAcquireSpinLock(SpinLock + 65);
  v2 = SpinLock + 67;
  SpinLock[113] = 2;
  if ( (PKSPIN_LOCK)*v2 != v2 )
  {
    do
    {
      v3 = (int *)*v2;
      v4 = *(_DWORD *)*v2;
      *v2 = v4;
      *(_DWORD *)(v4 + 4) = v2;
      v5 = v11;
      *v3 = (int)&v10;
      v3[1] = (int)v5;
      *v5 = (int)v3;
      v6 = *v2 == (_DWORD)v2;
      v11 = v3;
    }
    while ( !v6 );
  }
  v7 = SpinLock[69];
  if ( v7 )
    SpinLock[88] = v7;
  else
    v12 = 1;
  v6 = v12 == 0;
  SpinLock[87] = (KSPIN_LOCK)dword_15BEC;
  if ( !v6 )
  {
    SetSpeed((int)SpinLock);
    *((_BYTE *)SpinLock + 282) = 0;
  }
  KfReleaseSpinLock(SpinLock + 65, *((_BYTE *)SpinLock + 264));
  if ( v12 )
    ProcessSendQueue(SpinLock);
  while ( 1 )
  {
    v8 = v10;
    if ( (int *)v10 == &v10 )
      break;
    v10 = *(_DWORD *)v10;
    *(_DWORD *)(v10 + 4) = &v10;
    (*(void (__stdcall **)(KSPIN_LOCK, int, signed int))(*SpinLock + 236))(*SpinLock, v8 - 32, -1073676275);
  }
  SpinLock[113] = 0;
  (*(void (__stdcall **)(KSPIN_LOCK, _DWORD, signed int))(*SpinLock + 244))(*SpinLock, 0, 1);
  *(_BYTE *)a1 = 1;
  return 259;
}
// 15BEC: using guessed type int dword_15BEC[24];

//----- (00014086) --------------------------------------------------------
int __stdcall WPP_SF_dd(int a1, int a2, int a3, int a4, int a5, char a6)
{
  return pfnWppTraceMessage(a1, a2, 43, a4, a3, &a5);
}
// 15E24: using guessed type int (__cdecl *pfnWppTraceMessage)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000140BA) --------------------------------------------------------
int __stdcall WPP_SF_ddd(int a1, int a2, int a3, int a4, int a5, char a6, char a7)
{
  return pfnWppTraceMessage(a1, a2, 43, a4, a3, &a5);
}
// 15E24: using guessed type int (__cdecl *pfnWppTraceMessage)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000140F4) --------------------------------------------------------
int __stdcall NSC_FIR_ISR(int a1, int *a2, char *a3)
{
  UCHAR v3; // al@4
  int v4; // ST0C_4@4
  UCHAR v5; // al@4
  int v6; // ST0C_4@4
  UCHAR v7; // al@4
  int v8; // ST0C_4@4
  void *v9; // eax@4
  char v10; // cl@10
  int *v11; // edi@18
  int result; // eax@25

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 4 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 10, (int)dword_15B58);
  v3 = NSC_ReadBankReg(*(_DWORD *)(a1 + 372), 0, 1);
  v4 = *(_DWORD *)(a1 + 372);
  *(_BYTE *)(a1 + 341) = v3;
  v5 = NSC_ReadBankReg(v4, 0, 2);
  v6 = *(_DWORD *)(a1 + 372);
  *(_BYTE *)(a1 + 342) = *(_BYTE *)(a1 + 339) & v5;
  v7 = NSC_ReadBankReg(v6, 0, 7);
  v8 = *(_DWORD *)(a1 + 372);
  *(_BYTE *)(a1 + 343) = v7;
  *(_BYTE *)(a1 + 340) = NSC_ReadBankReg(v8, 0, 5);
  v9 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 4 )
    {
      WPP_SF_dd(
        *((_DWORD *)WPP_GLOBAL_Control + 4),
        *((_DWORD *)WPP_GLOBAL_Control + 5),
        11,
        (int)dword_15B58,
        *(_BYTE *)(a1 + 341),
        *(_BYTE *)(a1 + 342));
      v9 = WPP_GLOBAL_Control;
    }
    if ( v9 != &WPP_GLOBAL_Control && *((_BYTE *)v9 + 32) & 4 )
    {
      WPP_SF_dd(
        *((_DWORD *)v9 + 4),
        *((_DWORD *)v9 + 5),
        12,
        (int)dword_15B58,
        *(_BYTE *)(a1 + 343),
        *(_BYTE *)(a1 + 340));
      v9 = WPP_GLOBAL_Control;
    }
  }
  v10 = *(_BYTE *)(a1 + 342);
  if ( v10 )
  {
    if ( v10 & 4 && *(_BYTE *)(a1 + 340) & 2 && v9 != &WPP_GLOBAL_Control && *((_BYTE *)v9 + 32) & 1 )
      WPP_SF_(*((_DWORD *)v9 + 4), *((_DWORD *)v9 + 5), 13, (int)dword_15B58);
    if ( *(_BYTE *)(a1 + 342) & 0x80 )
    {
      NSC_WriteBankReg(*(_DWORD *)(a1 + 372), 4, 2, 0);
      NSC_WriteBankReg(*(_DWORD *)(a1 + 372), 0, 7, 0x80u);
    }
    v11 = a2;
    *(_BYTE *)a2 = 1;
    *a3 = 1;
    SetCOMInterrupts(a1, 0);
    if ( *(_DWORD *)(a1 + 456) >= 22
      && *(_BYTE *)(a1 + 343) & 8
      && *(_BYTE *)(a1 + 342) & 4
      && *(_BYTE *)(a1 + 280) == 1
      && *(_BYTE *)(a1 + 340) & 0x40 )
      NSC_WriteBankReg(*(_DWORD *)(a1 + 372), 0, 7, 0x40u);
  }
  else
  {
    v11 = a2;
    *(_BYTE *)a2 = 0;
    *a3 = 0;
  }
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 4 )
      result = WPP_SF_dd(
                 *((_DWORD *)WPP_GLOBAL_Control + 4),
                 *((_DWORD *)WPP_GLOBAL_Control + 5),
                 14,
                 (int)dword_15B58,
                 *(_BYTE *)v11,
                 *a3);
  }
  return result;
}
// 15B58: using guessed type int dword_15B58[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (000142E0) --------------------------------------------------------
int __stdcall SkipNonDmaBuffers(int a1, int a2)
{
  int result; // eax@1
  int v3; // ecx@3

  result = a2;
  if ( a1 != *(_DWORD *)a2 )
  {
    do
    {
      if ( *(_BYTE *)(*(_DWORD *)a2 + 24) )
        break;
      v3 = **(_DWORD **)a2;
      *(_DWORD *)a2 = v3;
    }
    while ( a1 != v3 );
  }
  return result;
}

//----- (00014308) --------------------------------------------------------
int __stdcall GetNextPacket(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // eax@3
  int v6; // ecx@4
  int v8; // [sp+Ch] [bp-4h]@1

  v8 = 0;
  SkipNonDmaBuffers(*(_DWORD *)a1 + 244, a2);
  SkipNonDmaBuffers(*(_DWORD *)a1 + 252, a3);
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)a1 + 252;
  if ( *(_DWORD *)a2 == *(_DWORD *)a1 + 244 )
  {
    if ( *(_DWORD *)a3 != v4 )
    {
      v8 = *(_DWORD *)a3;
      v5 = **(_DWORD **)a3;
LABEL_8:
      *(_DWORD *)a3 = v5;
      return v8;
    }
  }
  else
  {
    v6 = *(_DWORD *)a3;
    if ( *(_DWORD *)a3 != v4 && *(_DWORD *)(v3 + 20) >= *(_DWORD *)(v6 + 20) )
    {
      v5 = *(_DWORD *)v6;
      v8 = *(_DWORD *)a3;
      goto LABEL_8;
    }
    v8 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)v3;
  }
  return v8;
}

//----- (00014388) --------------------------------------------------------
bool __stdcall SynchronizedFindLargestSpace(int a1)
{
  int v1; // esi@1
  int v2; // edi@1
  int v3; // eax@1
  unsigned int v4; // eax@3
  int v5; // eax@4
  int v6; // eax@4
  int v7; // ebx@4
  int v8; // ecx@6
  int v9; // eax@9
  int v10; // eax@10
  int v11; // eax@12
  int v13; // [sp+8h] [bp-4h]@4

  v1 = a1;
  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)a1 + 244;
  if ( *(_DWORD *)v3 != v3 || *(_DWORD *)(v2 + 252) != v2 + 252 )
  {
    v13 = *(_DWORD *)v3;
    v5 = *(_DWORD *)(v2 + 252);
    *(_DWORD *)(a1 + 8) = 0;
    a1 = v5;
    v6 = *(_DWORD *)(v2 + 488);
    *(_DWORD *)(v1 + 4) = v6;
    v7 = v6;
    while ( 1 )
    {
      v9 = GetNextPacket(v1, (int)&v13, (int)&a1);
      if ( !v9 )
        break;
      if ( *(_BYTE *)(v9 + 24) )
      {
        v8 = *(_DWORD *)(v9 + 20) - v7;
        if ( (unsigned int)v8 > *(_DWORD *)(v1 + 8) )
        {
          *(_DWORD *)(v1 + 4) = v7;
          *(_DWORD *)(v1 + 8) = v8;
        }
        v7 = *(_DWORD *)(v9 + 20) + *(_DWORD *)(v9 + 16);
      }
    }
    v10 = *(_DWORD *)(v2 + 488) - v7 + 24864;
    if ( (unsigned int)v10 > *(_DWORD *)(v1 + 8) )
    {
      *(_DWORD *)(v1 + 4) = v7;
      *(_DWORD *)(v1 + 8) = v10;
    }
    v11 = *(_DWORD *)(v1 + 4);
    *(_DWORD *)(v1 + 8) += (*(_DWORD *)(v1 + 4) & 3) - 4;
    v4 = (v11 + 3) & 0xFFFFFFFC;
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 488);
    *(_DWORD *)(a1 + 8) = 24864;
  }
  *(_DWORD *)(v1 + 4) = v4;
  *(_DWORD *)(v1 + 4) -= *(_DWORD *)(v2 + 488);
  return *(_DWORD *)(v1 + 8) >= 0x808u;
}

//----- (00014456) --------------------------------------------------------
int __stdcall FindLargestSpace(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // [sp+0h] [bp-Ch]@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v4 = a1;
  result = NdisMSynchronizeWithInterrupt(a1 + 148, SynchronizedFindLargestSpace, &v4);
  *(_DWORD *)a2 = v5;
  *(_DWORD *)a3 = v6;
  return result;
}
// 15868: using guessed type int __stdcall NdisMSynchronizeWithInterrupt(_DWORD, _DWORD, _DWORD);

//----- (0001449A) --------------------------------------------------------
int __stdcall FIR_DeliverFrames(unsigned int a1)
{
  int v1; // esi@1
  bool v2; // cf@1
  ULONG v3; // eax@4
  ULONG v4; // ebx@4
  int v5; // ecx@6
  int v6; // ST10_4@7
  int result; // eax@7
  char v8; // al@10
  int v9; // ebx@12
  int v10; // ST34_4@16
  ULONG v11; // eax@16
  int v12; // edx@18
  int v13; // ecx@18
  void *v14; // eax@22
  unsigned int v15; // edx@32
  unsigned __int8 v16; // cl@33
  int v17; // edx@57
  char v18; // al@63
  int v19; // ecx@69
  int v20; // eax@69
  char v21; // al@82
  bool v22; // zf@82
  unsigned int v23; // [sp+Ch] [bp-10h]@1
  int v24; // [sp+10h] [bp-Ch]@18
  int v25; // [sp+14h] [bp-8h]@21
  char v26; // [sp+1Ah] [bp-2h]@1
  unsigned __int8 v27; // [sp+1Bh] [bp-1h]@1

  v1 = a1;
  v2 = *(_DWORD *)(a1 + 8) < 0x3D0900u;
  v26 = *(_BYTE *)(a1 + 588);
  v27 = 0;
  v23 = v2 ? 2 : 4;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_D(
      *((_DWORD *)WPP_GLOBAL_Control + 4),
      *((_DWORD *)WPP_GLOBAL_Control + 5),
      15,
      (int)dword_15B58,
      *(_DWORD *)(a1 + 504));
  v3 = NdisMReadDmaCounter(*(NDIS_HANDLE *)(v1 + 476));
  v4 = v3;
  if ( v3 )
  {
    if ( v3 < *(_DWORD *)(v1 + 504) || (v27 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 2, 7) & 0x3F) != 0 )
    {
      v6 = *(_DWORD *)(v1 + 372);
      *(_DWORD *)(v1 + 504) = v4;
      *(_BYTE *)(v1 + 339) = -112;
      SyncWriteBankReg(v1 + 148, v6, 4, 2, 1);
      result = (int)WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
      {
        if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 4 )
          result = WPP_SF_dd(
                     *((_DWORD *)WPP_GLOBAL_Control + 4),
                     *((_DWORD *)WPP_GLOBAL_Control + 5),
                     16,
                     (int)dword_15B58,
                     v27,
                     v4);
      }
      return result;
    }
    v9 = (int)dword_15B58;
  }
  else
  {
    v8 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 2, 7);
    LOBYTE(v5) = v8 & 0x3F;
    v27 = v8 & 0x3F;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    {
      v9 = (int)dword_15B58;
      WPP_SF_D(
        *((_DWORD *)WPP_GLOBAL_Control + 4),
        *((_DWORD *)WPP_GLOBAL_Control + 5),
        17,
        (int)dword_15B58,
        (unsigned __int8)v5);
    }
    else
    {
      v9 = (int)dword_15B58;
    }
    *(_BYTE *)(v1 + 344) = 1;
  }
  ++dword_15E5C;
  v10 = CompleteDmaTransfer(v5, v1 + 592, 0);
  v11 = NdisMReadDmaCounter(*(NDIS_HANDLE *)(v1 + 476));
  if ( v10 )
    v11 = *(_DWORD *)(v1 + 496);
  v12 = *(_DWORD *)(v1 + 496);
  v13 = v12 + *(_DWORD *)(v1 + 492) - v11;
  *(_BYTE *)(v1 + 281) = 0;
  *(_BYTE *)(v1 + 588) = 0;
  v24 = v13;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_D(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 18, v9, v12 - v11);
  SyncGetFifoStatus(v1 + 148, *(_DWORD *)(v1 + 372), (int)((char *)&a1 + 3), (int)&v25);
  if ( BYTE3(a1) )
    goto LABEL_25;
  v14 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( !(*((_BYTE *)WPP_GLOBAL_Control + 32) & 1) )
    {
LABEL_26:
      if ( v14 != &WPP_GLOBAL_Control && *((_BYTE *)v14 + 32) & 2 )
      {
        WPP_SF_dd(*((_DWORD *)v14 + 4), *((_DWORD *)v14 + 5), 20, v9, BYTE3(a1), v25);
        v14 = WPP_GLOBAL_Control;
      }
      goto LABEL_29;
    }
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 19, v9);
LABEL_25:
    v14 = WPP_GLOBAL_Control;
    goto LABEL_26;
  }
LABEL_29:
  if ( BYTE3(a1) & 0x80 )
  {
    while ( 1 )
    {
      v15 = *(_DWORD *)(v1 + 500);
      if ( v15 >= v24 )
        break;
      v16 = BYTE3(a1) & 0x5F;
      BYTE3(a1) &= 0x5Fu;
      if ( v26 )
      {
        if ( v14 != &WPP_GLOBAL_Control && *((_BYTE *)v14 + 32) & 1 )
          WPP_SF_dd(*((_DWORD *)v14 + 4), *((_DWORD *)v14 + 5), 21, v9, v16, v25);
      }
      else if ( v16 )
      {
        if ( v14 != &WPP_GLOBAL_Control && *((_BYTE *)v14 + 32) & 1 )
        {
          WPP_SF_dd(*((_DWORD *)v14 + 4), *((_DWORD *)v14 + 5), 22, v9, v16, v25);
          v16 = BYTE3(a1);
          v14 = WPP_GLOBAL_Control;
        }
        if ( v16 & 0x40 )
        {
          if ( v16 & 1 )
            ++dword_15E3C;
          if ( v16 & 2 )
            ++dword_15E44;
          dword_15E48 += v25;
        }
        else
        {
          if ( v16 & 1 )
            ++dword_15E3C;
          if ( v16 & 2 )
            ++dword_15E44;
          if ( v16 & 4 )
            ++dword_15E4C;
          if ( v14 != &WPP_GLOBAL_Control && *((_BYTE *)v14 + 32) & 2 )
            WPP_SF_D(*((_DWORD *)v14 + 4), *((_DWORD *)v14 + 5), 23, v9, v25);
          *(_DWORD *)(v1 + 500) += v25;
        }
      }
      else
      {
        v17 = v25 + v15;
        if ( v17 <= (unsigned int)v24 )
        {
          v19 = v25 - v23;
          v20 = *(_DWORD *)(v1 + 500) + *(_DWORD *)(v1 + 488);
          *(_DWORD *)(v1 + 500) = v17;
          v25 = v19;
          if ( (unsigned int)(v19 - 2) > 0x800 )
          {
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
              WPP_SF_D(
                *((_DWORD *)WPP_GLOBAL_Control + 4),
                *((_DWORD *)WPP_GLOBAL_Control + 5),
                26,
                (int)dword_15B58,
                v19);
            while ( SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 5) < 0 )
            {
              SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 6);
              SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 5, 7);
            }
            *(_BYTE *)(v1 + 588) = 1;
          }
          else
          {
            ++dword_15E34;
            ++dword_15E54;
            QueueReceivePacket(v1, v20, v19, 1);
          }
        }
        else
        {
          if ( v14 != &WPP_GLOBAL_Control && *((_BYTE *)v14 + 32) & 1 )
            WPP_SF_ddd(
              *((_DWORD *)v14 + 4),
              *((_DWORD *)v14 + 5),
              24,
              (int)dword_15B58,
              *(_DWORD *)(v1 + 500),
              v25,
              v24);
          for ( ; v27; --v27 )
            SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 0);
          v18 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 2, 7);
          v27 = v18 & 0x3F;
          if ( v18 & 0x3F )
          {
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 1 )
              WPP_SF_D(
                *((_DWORD *)WPP_GLOBAL_Control + 4),
                *((_DWORD *)WPP_GLOBAL_Control + 5),
                25,
                (int)dword_15B58,
                v18 & 0x3F);
            v27 = 0;
            *(_BYTE *)(v1 + 588) = 1;
          }
          *(_DWORD *)(v1 + 500) += v25;
        }
        v9 = (int)dword_15B58;
      }
      SyncGetFifoStatus(v1 + 148, *(_DWORD *)(v1 + 372), (int)((char *)&a1 + 3), (int)&v25);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
        WPP_SF_dd(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 27, v9, BYTE3(a1), v25);
      v21 = SyncReadBankReg(v1 + 148, *(_DWORD *)(v1 + 372), 0, 5);
      v22 = (BYTE3(a1) & 0x80) == 0;
      *(_BYTE *)(v1 + 340) = v21;
      if ( v22 )
        break;
      v14 = WPP_GLOBAL_Control;
    }
  }
  *(_BYTE *)(v1 + 339) = 4;
  SetupRecv(v1);
  result = (int)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    result = WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 28, v9);
  return result;
}
// 15B58: using guessed type int dword_15B58[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E34: using guessed type int dword_15E34;
// 15E3C: using guessed type int dword_15E3C;
// 15E44: using guessed type int dword_15E44;
// 15E48: using guessed type int dword_15E48;
// 15E4C: using guessed type int dword_15E4C;
// 15E54: using guessed type int dword_15E54;
// 15E5C: using guessed type int dword_15E5C;

//----- (000149AE) --------------------------------------------------------
char __stdcall NSC_Setup(int Status)
{
  int v1; // esi@1
  ULONG v2; // eax@1
  void *v3; // ST18_4@1
  int v5; // ST08_4@3
  int v6; // eax@3
  struct _NDIS_DMA_DESCRIPTION DmaDescription; // [sp+Ch] [bp-14h]@1

  v1 = Status;
  *(_DWORD *)&DmaDescription.DemandMode = 0;
  DmaDescription.DmaWidth = 0;
  DmaDescription.DmaSpeed = 0;
  DmaDescription.DmaPort = 0;
  DmaDescription.DmaChannel = 0;
  v2 = *(_BYTE *)(Status + 380);
  v3 = *(void **)Status;
  DmaDescription.DemandMode = 1;
  DmaDescription.AutoInitialize = 0;
  DmaDescription.DmaChannelSpecified = 0;
  DmaDescription.DmaWidth = 0;
  DmaDescription.DmaSpeed = 0;
  DmaDescription.DmaPort = 0;
  DmaDescription.DmaChannel = v2;
  Status = NdisMRegisterDmaChannel((PNDIS_HANDLE)(Status + 476), v3, v2, 0, &DmaDescription, 0x6120u);
  if ( Status )
    return 0;
  InitializeDmaUtil(v1 + 592, *(_DWORD *)(v1 + 476));
  v5 = *(_DWORD *)v1;
  *(_DWORD *)(v1 + 492) = 0;
  v6 = NscAllocateDmaBuffer(v5, 0x6120u, v1 + 616);
  *(_DWORD *)(v1 + 488) = v6;
  if ( !v6 )
    return 0;
  *(_DWORD *)(v1 + 680) = NscAllocateDmaBuffer(*(_DWORD *)v1, 0x1036u, v1 + 648);
  NdisAllocateBufferPool(&Status, (PNDIS_HANDLE)(v1 + 480), 2u);
  if ( Status )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
    {
      if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
        WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 29, (int)dword_15B58);
    }
    return 0;
  }
  NdisAllocateBuffer(&Status, (PNDIS_BUFFER *)(v1 + 484), *(NDIS_HANDLE *)(v1 + 480), *(PVOID *)(v1 + 488), 0x6120u);
  if ( Status )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 30, (int)dword_15B58);
    return 0;
  }
  NdisAllocateBuffer(&Status, (PNDIS_BUFFER *)(v1 + 508), *(NDIS_HANDLE *)(v1 + 480), *(PVOID *)(v1 + 680), 0x1036u);
  if ( Status )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
      WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 31, (int)dword_15B58);
    return 0;
  }
  return 1;
}
// 15B58: using guessed type int dword_15B58[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (00014B38) --------------------------------------------------------
void __stdcall NSC_Shutdown(int a1)
{
  NDIS_HANDLE *v1; // esi@11

  if ( *(_DWORD *)(a1 + 508) )
  {
    IoFreeMdl(*(PMDL *)(a1 + 508));
    *(_DWORD *)(a1 + 508) = 0;
  }
  if ( *(_DWORD *)(a1 + 484) )
  {
    IoFreeMdl(*(PMDL *)(a1 + 484));
    *(_DWORD *)(a1 + 484) = 0;
  }
  if ( *(_DWORD *)(a1 + 480) )
  {
    NdisFreeBufferPool(*(NDIS_HANDLE *)(a1 + 480));
    *(_DWORD *)(a1 + 480) = 0;
  }
  if ( *(_DWORD *)(a1 + 488) )
  {
    NscFreeDmaBuffer(a1 + 616);
    *(_DWORD *)(a1 + 488) = 0;
  }
  if ( *(_DWORD *)(a1 + 680) )
  {
    NscFreeDmaBuffer(a1 + 648);
    *(_DWORD *)(a1 + 680) = 0;
  }
  v1 = (NDIS_HANDLE *)(a1 + 476);
  if ( *(_DWORD *)(a1 + 476) )
  {
    NdisMDeregisterDmaChannel(*v1);
    *v1 = 0;
  }
}

//----- (00014BDA) --------------------------------------------------------
char __stdcall NdisToFirPacket(int a1, unsigned int a2, unsigned int a3, int a4)
{
  void *v4; // eax@1
  int v5; // edi@1
  int v6; // ecx@4
  int v7; // esi@4
  int v8; // eax@5
  int v9; // edx@6
  unsigned int v10; // edx@7
  int v11; // ebx@11
  const void *v13; // eax@26
  unsigned int v14; // ebx@28
  unsigned int v15; // ecx@33
  unsigned __int8 v16; // bl@33
  char v17; // dl@33
  int v18; // [sp+Ch] [bp-Ch]@5
  int v19; // [sp+10h] [bp-8h]@5
  unsigned int v20; // [sp+14h] [bp-4h]@1
  int v21; // [sp+20h] [bp+8h]@5
  unsigned int v22; // [sp+20h] [bp+8h]@11
  unsigned __int8 v23; // [sp+27h] [bp+Fh]@33

  v20 = 0;
  v4 = WPP_GLOBAL_Control;
  v5 = (int)dword_15B58;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
  {
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 32, (int)dword_15B58);
    v4 = WPP_GLOBAL_Control;
  }
  v6 = a1;
  v7 = *(_DWORD *)(a1 + 8);
  if ( !*(_BYTE *)(a1 + 28) )
  {
    v8 = *(_DWORD *)(a1 + 8);
    v19 = 0;
    v18 = 0;
    v21 = 0;
    if ( v7 )
    {
      do
      {
        v9 = *(_DWORD *)(v8 + 20);
        v19 += v9;
        if ( v9 )
        {
          v10 = (*(_DWORD *)(v8 + 20) >> 12)
              + ((((*(_DWORD *)(v8 + 16) + *(_DWORD *)(v8 + 24)) & 0xFFF) + (*(_DWORD *)(v8 + 20) & 0xFFFu) + 4095) >> 12);
          v5 = (int)dword_15B58;
        }
        else
        {
          v10 = 1;
        }
        v18 += v10;
        v8 = *(_DWORD *)v8;
        ++v21;
      }
      while ( v8 );
    }
    *(_DWORD *)(v6 + 20) = v21;
    *(_DWORD *)(v6 + 4) = v19;
    *(_DWORD *)v6 = v18;
    *(_BYTE *)(v6 + 28) = 1;
    v4 = WPP_GLOBAL_Control;
  }
  v11 = *(_DWORD *)(v6 + 4);
  v22 = *(_DWORD *)(v6 + 4);
  if ( v4 != &WPP_GLOBAL_Control && *((_BYTE *)v4 + 32) & 2 )
  {
    WPP_SF_D(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 33, v5, v11);
    v4 = WPP_GLOBAL_Control;
  }
  if ( (unsigned int)v11 < 2 )
  {
    if ( v4 != &WPP_GLOBAL_Control )
    {
      if ( *((_BYTE *)v4 + 32) & 2 )
        WPP_SF_D(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 34, v5, v11);
    }
    return 0;
  }
  if ( v11 > a3 )
  {
    if ( v4 != &WPP_GLOBAL_Control && *((_BYTE *)v4 + 32) & 2 )
      WPP_SF_D(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 35, v5, v11);
    *(_DWORD *)a4 = v11;
    return 0;
  }
  if ( v7 )
  {
    while ( 1 )
    {
      v13 = (const void *)(*(_BYTE *)(v7 + 6) & 5 ? *(_DWORD *)(v7 + 12) : MmMapLockedPagesSpecifyCache(
                                                                             (PMDL)v7,
                                                                             0,
                                                                             MmCached,
                                                                             0,
                                                                             0,
                                                                             NormalPagePriority));
      v14 = *(_DWORD *)(v7 + 20);
      if ( !v13 || v20 + (unsigned __int64)v14 > v22 )
        goto LABEL_47;
      memcpy((void *)(a2 + v20), v13, *(_DWORD *)(v7 + 20));
      v7 = *(_DWORD *)v7;
      v20 += v14;
      if ( !v7 )
      {
        v4 = WPP_GLOBAL_Control;
        v5 = (int)dword_15B58;
        break;
      }
    }
  }
  if ( *((_BYTE *)v4 + 32) & 2 )
  {
    v15 = a2;
    LOBYTE(v15) = *(_BYTE *)(a2 + 1);
    v16 = *(_BYTE *)(a2 + 1) >> 5;
    v17 = (*(_BYTE *)(a2 + 1) >> 4) & 1;
    v23 = *(_BYTE *)(a2 + 1) >> 5;
    if ( v15 & 1 )
    {
      if ( (v15 & 3) == 1 )
      {
        if ( v4 == &WPP_GLOBAL_Control )
          goto LABEL_43;
        WPP_SF_ddd(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 37, v5, v23, ((unsigned __int8)v15 > 2u) & 3, v17);
      }
      else
      {
        if ( v4 == &WPP_GLOBAL_Control )
          goto LABEL_43;
        WPP_SF_D(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 38, v5, (unsigned __int8)v17);
      }
    }
    else
    {
      if ( v4 == &WPP_GLOBAL_Control )
        goto LABEL_43;
      WPP_SF_ddd(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 36, v5, v16, (v15 >> 1) & 7, v17);
    }
    v4 = WPP_GLOBAL_Control;
  }
LABEL_43:
  if ( v20 != v22 )
  {
    if ( v4 != &WPP_GLOBAL_Control && *((_BYTE *)v4 + 32) & 2 )
      WPP_SF_(*((_DWORD *)v4 + 4), *((_DWORD *)v4 + 5), 39, v5);
LABEL_47:
    *(_DWORD *)a4 = 0;
    return 0;
  }
  *(_DWORD *)a4 = v20;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 41, v5);
  return 1;
}
// 15B58: using guessed type int dword_15B58[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;

//----- (00014E66) --------------------------------------------------------
int __stdcall MiniportQueryInformation(int a1, int a2, void *a3, int a4, int a5, int a6)
{
  const void *v6; // ecx@1
  size_t v7; // edi@1
  int v8; // eax@6
  int v9; // eax@29
  char *v10; // edx@32
  int v11; // eax@32
  signed int v12; // esi@32
  int v13; // ecx@34
  void *v14; // ST00_4@42
  signed int v16; // [sp-4h] [bp-38h]@4
  char v17; // [sp+8h] [bp-2Ch]@32
  int v18; // [sp+2Ch] [bp-8h]@1
  int v19; // [sp+30h] [bp-4h]@1

  v19 = 0;
  v18 = 10;
  v6 = &a1;
  v7 = 4;
  if ( (unsigned int)a2 <= 0xA010100 )
  {
    if ( a2 != 167837952 )
    {
      switch ( a2 )
      {
        case 65793:
          v6 = NSCGlobalSupportedOids;
          v16 = 116;
          goto LABEL_5;
        case 65794:
          v8 = *(_DWORD *)(a1 + 452);
          goto LABEL_39;
        case 65795:
        case 65796:
          v6 = &v18;
          goto LABEL_40;
        case 65799:
          a1 = 40000;
          goto LABEL_40;
        case 65797:
        case 65798:
        case 65802:
        case 65803:
        case 65807:
        case 65809:
          a1 = 2048;
          goto LABEL_40;
        case 65800:
        case 65801:
          a1 = 33200;
          goto LABEL_40;
        case 65811:
        case 65812:
          a1 = 0;
          goto LABEL_40;
        case 65813:
          a1 = 16;
          goto LABEL_40;
        case 65806:
          a1 = 32;
          goto LABEL_40;
        case 65805:
          v6 = "NSC Infrared Port";
          v16 = 18;
          goto LABEL_5;
        case 65814:
          a1 = 68467;
          goto LABEL_40;
        case 65808:
          a1 = 1280;
          v16 = 2;
LABEL_5:
          v7 = v16;
          goto LABEL_40;
        default:
          return -1073741637;
      }
      return -1073741637;
    }
    v8 = *(_BYTE *)(a1 + 338);
    goto LABEL_39;
  }
  if ( a2 == 167837953 )
  {
    v8 = *(_DWORD *)(a1 + 440);
    goto LABEL_39;
  }
  if ( a2 == 167837954 )
  {
    v10 = &v17;
    v11 = *(_DWORD *)(a1 + 140) & *(_DWORD *)(a1 + 436) & 0x1BF;
    v7 = 0;
    v12 = (signed int)&dword_15BE8;
    do
    {
      if ( !v11 )
        break;
      v13 = *(_DWORD *)v12;
      if ( *(_DWORD *)v12 & v11 )
      {
        *(_DWORD *)v10 = *(_DWORD *)(v12 - 4);
        v10 += 4;
        v7 += 4;
        v11 &= ~v13;
      }
      v12 += 12;
    }
    while ( v12 < (signed int)&stru_15C50.Data2 );
    v6 = &v17;
    goto LABEL_40;
  }
  if ( a2 == 167837955 )
  {
    v9 = *(_DWORD *)(a1 + 348);
    if ( !v9 )
    {
      a1 = 9600;
      goto LABEL_40;
    }
    v8 = *(_DWORD *)(v9 + 4);
    goto LABEL_39;
  }
  if ( a2 == 167837956 )
  {
    v8 = *(_BYTE *)(a1 + 336);
    goto LABEL_39;
  }
  if ( a2 == 167838208 )
  {
    v8 = *(_DWORD *)(a1 + 444);
LABEL_39:
    a1 = v8;
    goto LABEL_40;
  }
  if ( a2 != 167838212 && a2 != 167838213 )
    return -1073741637;
  a1 = 7;
LABEL_40:
  if ( v7 <= a4 )
  {
    *(_DWORD *)a6 = 0;
    v14 = a3;
    *(_DWORD *)a5 = v7;
    memcpy(v14, v6, v7);
  }
  else
  {
    *(_DWORD *)a6 = v7;
    v19 = -1073676268;
  }
  return v19;
}
// 15B68: using guessed type int NSCGlobalSupportedOids[30];
// 15BE8: using guessed type int dword_15BE8;
// 15C50: using guessed type GUID;

//----- (00015098) --------------------------------------------------------
int __stdcall MiniportSetInformation(PKSPIN_LOCK SpinLock, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // ecx@2
  signed int v7; // edi@6
  int v8; // esi@9
  int v9; // eax@9
  unsigned int v10; // ebx@9
  int *v11; // eax@13
  char v12; // bl@14
  int v13; // eax@15
  PKSPIN_LOCK SpinLocka; // [sp+14h] [bp+8h]@9

  if ( (unsigned int)a4 < 4 )
  {
    *(_DWORD *)a5 = 0;
    *(_DWORD *)a6 = 4;
    return -1073676268;
  }
  v6 = *(_DWORD *)a3;
  *(_DWORD *)a5 = 4;
  *(_DWORD *)a6 = 0;
  if ( a2 == 65806 )
    return 0;
  if ( a2 == 65807 )
    return v6 > 0x800 ? 0xC0010014 : 0;
  if ( a2 != 167837955 )
  {
    if ( a2 != 167837956 )
    {
      *(_DWORD *)a5 = 0;
      *(_DWORD *)a6 = 0;
      return -1073741637;
    }
    *((_BYTE *)SpinLock + 336) = v6;
    _InterlockedExchange((volatile signed __int32 *)SpinLock + 83, 0);
    return 0;
  }
  v8 = (int)SpinLock;
  SpinLocka = (PKSPIN_LOCK)SpinLock[87];
  v9 = 0;
  v10 = 0;
  while ( dword_15BE4[v10] != v6 )
  {
    v10 += 3;
    ++v9;
    if ( v10 >= 27 )
    {
      *(_DWORD *)a5 = 0;
      *(_DWORD *)a6 = 0;
      return -1073676267;
    }
  }
  v11 = &supportedBaudRateTable[3 * v9];
  v7 = 0;
  *(_DWORD *)(v8 + 348) = v11;
  if ( (int *)SpinLocka != v11 )
  {
    v12 = 1;
    *(_BYTE *)(v8 + 264) = KfAcquireSpinLock((PKSPIN_LOCK)(v8 + 260));
    if ( *(_DWORD *)(v8 + 268) == v8 + 268 )
    {
      v13 = *(_DWORD *)(v8 + 276);
      if ( !v13 )
      {
        if ( !SetSpeed(v8) )
          v7 = -1073741823;
        *(_BYTE *)(v8 + 282) = 0;
        goto LABEL_22;
      }
      *(_BYTE *)(v8 + 356) = 1;
    }
    else
    {
      v13 = *(_DWORD *)(v8 + 272) - 32;
    }
    *(_DWORD *)(v8 + 352) = v13;
    v12 = 0;
LABEL_22:
    KfReleaseSpinLock((PKSPIN_LOCK)(v8 + 260), *(_BYTE *)(v8 + 264));
    if ( v12 )
      ProcessSendQueue((PKSPIN_LOCK)v8);
  }
  return v7;
}
// 15BE0: using guessed type int supportedBaudRateTable[];
// 15BE4: using guessed type int dword_15BE4[];

//----- (000151F6) --------------------------------------------------------
PVOID __thiscall NscMemAlloc(void *this, UINT Length)
{
  PVOID VirtualAddress; // [sp+0h] [bp-4h]@1

  VirtualAddress = this;
  if ( NdisAllocateMemoryWithTag(&VirtualAddress, Length, 0x7249734Eu) )
    VirtualAddress = 0;
  else
    memset(VirtualAddress, 0, Length);
  return VirtualAddress;
}

//----- (00015234) --------------------------------------------------------
void __stdcall NscMemFree(PVOID VirtualAddress)
{
  NdisFreeMemory(VirtualAddress, 0, 0);
}

//----- (00015250) --------------------------------------------------------
int __stdcall NscAllocateDmaBuffer(int a1, UINT Length, int a3)
{
  memset((void *)a3, 0, 0x20u);
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 4) = Length;
  *(_DWORD *)a3 = a1;
  if ( NdisAllocateMemoryWithTag((PVOID *)(a3 + 8), Length, 0x7249734Eu) )
    memset((void *)a3, 0, 0x20u);
  else
    *(_BYTE *)(a3 + 24) = 0;
  return *(_DWORD *)(a3 + 8);
}

//----- (000152A4) --------------------------------------------------------
void __stdcall NscFreeDmaBuffer(int a1)
{
  void *v1; // eax@2

  if ( *(_DWORD *)a1 )
  {
    v1 = *(void **)(a1 + 8);
    if ( v1 )
    {
      if ( *(_BYTE *)(a1 + 24) )
        NdisMFreeSharedMemory(*(NDIS_HANDLE *)a1, *(_DWORD *)(a1 + 4), 1u, v1, *(NDIS_PHYSICAL_ADDRESS *)(a1 + 16));
      else
        NdisFreeMemory(v1, *(_DWORD *)(a1 + 4), 0);
      memset((void *)a1, 0, 0x20u);
    }
  }
}

//----- (000152F2) --------------------------------------------------------
char *__stdcall InitDevice(PVOID FunctionContext)
{
  char *v1; // eax@1
  char *v2; // eax@1
  char *v3; // eax@1
  char *v4; // eax@1
  char *result; // eax@1

  memset(FunctionContext, 0, 0x2B0u);
  v1 = (char *)FunctionContext + 268;
  *((_DWORD *)v1 + 1) = v1;
  *(_DWORD *)v1 = v1;
  *((_DWORD *)FunctionContext + 65) = 0;
  NdisInitializeTimer((PNDIS_TIMER)((char *)FunctionContext + 512), DelayedWrite, FunctionContext);
  v2 = (char *)FunctionContext + 228;
  *((_DWORD *)v2 + 1) = v2;
  *(_DWORD *)v2 = v2;
  v3 = (char *)FunctionContext + 236;
  *((_DWORD *)v3 + 1) = v3;
  *(_DWORD *)v3 = v3;
  v4 = (char *)FunctionContext + 244;
  *((_DWORD *)v4 + 1) = v4;
  *(_DWORD *)v4 = v4;
  result = (char *)FunctionContext + 252;
  *((_DWORD *)result + 1) = result;
  *(_DWORD *)result = result;
  return result;
}

//----- (00015366) --------------------------------------------------------
void __stdcall CloseDevice(int a1)
{
  int v1; // esi@2
  int v2; // edi@3
  int v3; // eax@3
  int v4; // esi@6
  void *v5; // ecx@7
  int v6; // eax@7

  if ( a1 )
  {
    v1 = a1 + 236;
    while ( *(_DWORD *)v1 != v1 )
    {
      v2 = *(_DWORD *)v1;
      v3 = **(_DWORD **)v1;
      *(_DWORD *)v1 = v3;
      *(_DWORD *)(v3 + 4) = v1;
      if ( *(_DWORD *)(v2 + 12) )
      {
        NdisFreePacket(*(PNDIS_PACKET *)(v2 + 12));
        *(_DWORD *)(v2 + 12) = 0;
      }
      NscMemFree((PVOID)v2);
    }
    v4 = a1 + 228;
    while ( *(_DWORD *)v4 != v4 )
    {
      v5 = *(void **)v4;
      v6 = **(_DWORD **)v4;
      *(_DWORD *)v4 = v6;
      *(_DWORD *)(v6 + 4) = v4;
      NscMemFree(v5);
    }
    if ( *(_DWORD *)(a1 + 324) )
    {
      NdisFreePacketPool(*(NDIS_HANDLE *)(a1 + 324));
      *(_DWORD *)(a1 + 324) = 0;
    }
    if ( *(_DWORD *)(a1 + 328) )
    {
      NdisFreeBufferPool(*(NDIS_HANDLE *)(a1 + 328));
      *(_DWORD *)(a1 + 328) = 0;
    }
    *(_DWORD *)(a1 + 348) = 0;
    *(_BYTE *)(a1 + 336) = 0;
    *(_BYTE *)(a1 + 337) = 0;
  }
}

//----- (00015410) --------------------------------------------------------
PVOID __thiscall NewDevice(void *this)
{
  PVOID v1; // eax@1
  PVOID v2; // esi@1

  v1 = NscMemAlloc(this, 0x2B0u);
  v2 = v1;
  if ( v1 )
    InitDevice(v1);
  return v2;
}

//----- (0001544A) --------------------------------------------------------
char __stdcall OpenDevice(int Status)
{
  int v1; // edi@1
  char result; // al@2
  int v3; // ecx@4
  unsigned int v4; // esi@5
  PVOID v5; // eax@6
  int v6; // edx@7
  PVOID v7; // eax@9
  PVOID v8; // esi@9
  int v9; // ebx@10
  unsigned int v10; // [sp+8h] [bp-8h]@8
  char v11; // [sp+Fh] [bp-1h]@1

  v1 = Status;
  v11 = 0;
  if ( Status )
  {
    NdisAllocatePacketPool(&Status, (PNDIS_HANDLE)(Status + 324), 0x10u, 0x18u);
    if ( !Status )
    {
      NdisAllocateBufferPool(&Status, (PNDIS_HANDLE)(v1 + 328), 0x10u);
      if ( !Status )
      {
        v4 = 0;
        while ( 1 )
        {
          v5 = NscMemAlloc((void *)v3, 0x810u);
          if ( !v5 )
            break;
          v3 = v1 + 228;
          v6 = *(_DWORD *)(v1 + 228);
          *(_DWORD *)v5 = v6;
          *((_DWORD *)v5 + 1) = v1 + 228;
          ++v4;
          *(_DWORD *)(v6 + 4) = v5;
          *(_DWORD *)(v1 + 228) = v5;
          if ( v4 >= 0x10 )
          {
            v10 = 0;
            while ( 1 )
            {
              v7 = NscMemAlloc((void *)v3, 0x1Cu);
              v8 = v7;
              if ( !v7 )
                goto LABEL_14;
              *((_DWORD *)v7 + 2) = 0;
              *((_DWORD *)v7 + 5) = 0;
              *((_BYTE *)v7 + 24) = 0;
              v9 = (int)((char *)v7 + 12);
              NdisAllocatePacket(&Status, (PNDIS_PACKET *)v7 + 3, *(NDIS_HANDLE *)(v1 + 324));
              if ( Status )
              {
                NscMemFree(v8);
                goto LABEL_14;
              }
              *(_DWORD *)(*(_DWORD *)v9 + 32) = v8;
              *((_DWORD *)v8 + 4) = 0;
              ++v10;
              v3 = *(_DWORD *)(v1 + 236);
              *(_DWORD *)v8 = v3;
              *((_DWORD *)v8 + 1) = v1 + 236;
              *(_DWORD *)(v3 + 4) = v8;
              *(_DWORD *)(v1 + 236) = v8;
              if ( v10 >= 0x10 )
              {
                *(_DWORD *)(v1 + 352) = 0;
                *(_BYTE *)(v1 + 336) = 0;
                *(_BYTE *)(v1 + 337) = 1;
                *(_DWORD *)(v1 + 348) = dword_15BEC;
                *(_BYTE *)(v1 + 356) = 0;
                v11 = 1;
                goto LABEL_15;
              }
            }
          }
        }
      }
    }
LABEL_14:
    CloseDevice(v1);
LABEL_15:
    result = v11;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 15BEC: using guessed type int dword_15BEC[24];

//----- (00015572) --------------------------------------------------------
char __stdcall SynchronizedListFunc(int a1)
{
  int v1; // ecx@1
  int v2; // edx@1
  int v3; // ecx@2
  int v4; // ecx@3
  int v5; // ecx@4
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // eax@6
  int v9; // ecx@7
  int v10; // esi@8
  int v11; // ecx@9
  int v12; // esi@10
  int v13; // ecx@12
  int v14; // eax@12
  int v15; // edx@12
  int v16; // ecx@13
  int v17; // eax@13
  int v18; // edx@13

  v1 = *(_DWORD *)(a1 + 8);
  v2 = 0;
  if ( !v1 )
  {
    v16 = *(_DWORD *)(a1 + 4);
    v17 = *(_DWORD *)a1;
    v18 = **(_DWORD **)a1;
    *(_DWORD *)v16 = **(_DWORD **)a1;
    *(_DWORD *)(v16 + 4) = v17;
    *(_DWORD *)(v18 + 4) = v16;
    *(_DWORD *)v17 = v16;
    return 1;
  }
  v3 = v1 - 1;
  if ( !v3 )
  {
    v13 = *(_DWORD *)(a1 + 4);
    v14 = *(_DWORD *)a1;
    v15 = *(_DWORD *)(*(_DWORD *)a1 + 4);
    *(_DWORD *)v13 = *(_DWORD *)a1;
    *(_DWORD *)(v13 + 4) = v15;
    *(_DWORD *)v15 = v13;
    *(_DWORD *)(v14 + 4) = v13;
    return 1;
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v11 = *(_DWORD *)a1;
    if ( *(_DWORD *)v11 != v11 )
    {
      v2 = *(_DWORD *)v11;
      v12 = **(_DWORD **)v11;
      *(_DWORD *)v11 = v12;
      *(_DWORD *)(v12 + 4) = v11;
    }
    goto LABEL_11;
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v9 = *(_DWORD *)a1;
    if ( *(_DWORD *)v9 != v9 )
    {
      v2 = *(_DWORD *)(v9 + 4);
      v10 = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(v9 + 4) = v10;
      *(_DWORD *)v10 = v9;
    }
LABEL_11:
    *(_DWORD *)(a1 + 4) = v2;
    return 1;
  }
  if ( v5 == 1 )
  {
    v6 = *(_DWORD *)(a1 + 4);
    v7 = *(_DWORD *)v6;
    v8 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)v8 = v7;
    *(_DWORD *)(v7 + 4) = v8;
  }
  return 1;
}

//----- (00016074) --------------------------------------------------------
int __stdcall WppTraceCallback(int a1, int a2, size_t a3, void *a4, int a5, int a6)
{
  int v6; // eax@1
  void *v7; // edi@1
  int v8; // edx@2
  void *v9; // ebx@2
  int v10; // esi@2
  unsigned int v11; // ecx@3
  int v12; // ecx@4
  int v13; // esi@8
  char *v14; // edi@8
  int v15; // edx@9
  int v16; // esi@14
  size_t v17; // edi@14
  int v18; // esi@18
  void *v19; // ecx@19
  int v20; // eax@19
  int v21; // ebx@20
  int v22; // esi@21
  int v23; // esi@26
  void *v24; // ebx@28
  char *v25; // edi@28
  int v26; // edx@34
  int v27; // ecx@34
  int v29; // [sp+14h] [bp-4h]@1
  int v30; // [sp+14h] [bp-4h]@9
  int v31; // [sp+20h] [bp+8h]@14

  v6 = a6;
  v7 = 0;
  v29 = 0;
  *(_DWORD *)a6 = 0;
  switch ( (unsigned __int8)a1 )
  {
    case 8u:
      v8 = a5;
      v9 = a4;
      v10 = a5;
      if ( WPPTraceSuite != 1 || (v11 = *((_DWORD *)a4 + 4), v11 <= 1) )
      {
        v15 = *(_DWORD *)(a5 + 24);
        v30 = *(_DWORD *)(a5 + 24);
        do
        {
          v10 = *(_DWORD *)(v10 + 8);
          v7 = (char *)v7 + 1;
        }
        while ( v10 );
        a4 = v7;
        if ( (unsigned int)v7 <= 0x3F )
        {
          if ( v15 )
          {
            v16 = 28 * (_DWORD)v7 + 20;
            v31 = *(_WORD *)v15 + v16 + 2;
            v17 = *(_WORD *)v15 + v16 + 2;
          }
          else
          {
            v16 = 0;
            v17 = 28 * (_DWORD)v7 + 20;
            v31 = v17;
          }
          if ( v17 > a3 )
          {
            v29 = -1073741789;
            if ( a3 >= 4 )
            {
              *(_DWORD *)v9 = v17;
LABEL_7:
              *(_DWORD *)v6 = 4;
              return v29;
            }
          }
          else
          {
            memset(v9, 0, a3);
            *((_DWORD *)v9 + 4) = a4;
            *(_DWORD *)v9 = v17;
            *((_DWORD *)v9 + 2) = v16;
            if ( v30 )
            {
              v18 = (int)((char *)v9 + v16);
              *(_WORD *)v18 = *(_WORD *)v30;
              memcpy((void *)(v18 + 2), *(const void **)(v30 + 4), *(_WORD *)v30);
            }
            v19 = a4;
            v20 = a5;
            if ( a4 )
            {
              v21 = (int)((char *)v9 + 36);
              do
              {
                v22 = *(_DWORD *)(v20 + 4);
                *(_DWORD *)(v21 - 16) = *(_DWORD *)v22;
                v22 += 4;
                *(_DWORD *)(v21 - 16 + 4) = *(_DWORD *)v22;
                v22 += 4;
                *(_DWORD *)(v21 - 16 + 8) = *(_DWORD *)v22;
                *(_DWORD *)(v21 - 16 + 12) = *(_DWORD *)(v22 + 4);
                *(_DWORD *)v21 = 528384;
                *(_DWORD *)(v20 + 32) = 0;
                v21 += 28;
                v19 = (char *)v19 - 1;
                *(_BYTE *)(v20 + 29) = 0;
                v20 = *(_DWORD *)(v20 + 8);
              }
              while ( v19 );
              v17 = v31;
            }
            v29 = 0;
            *(_DWORD *)a6 = v17;
          }
        }
        else
        {
          v29 = -1073741811;
        }
      }
      else
      {
        v12 = 28 * v11;
        if ( v12 + 20 > a3 )
        {
          v29 = -1073741789;
          if ( a3 < 4 )
            return v29;
          *(_DWORD *)a4 = v12 + 20;
          goto LABEL_7;
        }
        v13 = *(_DWORD *)(a5 + 4);
        v14 = (char *)a4 + v12 - 8;
        *(_DWORD *)v14 = *(_DWORD *)v13;
        v13 += 4;
        v14 += 4;
        *(_DWORD *)v14 = *(_DWORD *)v13;
        v13 += 4;
        v14 += 4;
        *(_DWORD *)v14 = *(_DWORD *)v13;
        *((_DWORD *)v14 + 1) = *(_DWORD *)(v13 + 4);
        *((_DWORD *)v9 + 7 * *((_DWORD *)v9 + 4) + 2) = 528384;
        *(_DWORD *)(v8 + 32) = 0;
        *(_BYTE *)(v8 + 29) = 0;
      }
      return v29;
    case 4u:
    case 5u:
      v23 = a5;
      if ( !a5 )
        goto LABEL_44;
      v24 = a4;
      v25 = (char *)a4 + 24;
      do
      {
        if ( RtlCompareMemory(*(const void **)(v23 + 4), v25, 0x10u) == 16 )
          break;
        v23 = *(_DWORD *)(v23 + 8);
      }
      while ( v23 );
      if ( v23 )
      {
        v29 = 0;
        if ( (_BYTE)a1 == 5 )
        {
          *(_BYTE *)(v23 + 29) = 0;
          *(_DWORD *)(v23 + 32) = 0;
          *(_DWORD *)(v23 + 16) = 0;
          *(_DWORD *)(v23 + 20) = 0;
        }
        else
        {
          v26 = *((_DWORD *)v24 + 2);
          v27 = *((_DWORD *)v24 + 3);
          *(_DWORD *)(v23 + 16) = v26;
          *(_DWORD *)(v23 + 20) = v27;
          if ( WPPTraceSuite == 2 )
          {
            if ( !pfnWppQueryTraceInformation(3, &a3, 4, &a5, v24) )
              *(_BYTE *)(v23 + 29) = a3;
            v29 = pfnWppQueryTraceInformation(2, v23 + 32, 4, &a5, v24);
          }
          else
          {
            *(_DWORD *)(v23 + 32) = v27;
            *(_BYTE *)(v23 + 29) = BYTE2(v26);
          }
        }
      }
      else
      {
LABEL_44:
        v29 = -1073741163;
      }
      return v29;
    case 6u:
    case 7u:
      return 0;
    default:
      return -1073741808;
  }
}
// 15E20: using guessed type int (__stdcall *pfnWppQueryTraceInformation)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15E28: using guessed type int WPPTraceSuite;

//----- (000162C8) --------------------------------------------------------
NTSTATUS __stdcall WppInitKm(PDEVICE_OBJECT DeviceObject)
{
  struct _DEVICE_OBJECT *v1; // eax@1
  NTSTATUS result; // eax@2

  v1 = (struct _DEVICE_OBJECT *)WPP_GLOBAL_Control;
  if ( WPPTraceSuite == 2 )
  {
    *(_DWORD *)WPP_GLOBAL_Control = WppTraceCallback;
    result = IoWMIRegistrationControl(v1, 0x80010001);
  }
  else
  {
    *(_DWORD *)WPP_GLOBAL_Control = 0;
    result = IoWMIRegistrationControl(DeviceObject, 1u);
  }
  return result;
}
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E28: using guessed type int WPPTraceSuite;

//----- (00016300) --------------------------------------------------------
NTSTATUS __stdcall WppCleanupKm(PDEVICE_OBJECT DeviceObject)
{
  NTSTATUS result; // eax@1

  result = (NTSTATUS)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    if ( WPPTraceSuite == 2 )
      result = IoWMIRegistrationControl((PDEVICE_OBJECT)WPP_GLOBAL_Control, 0x80000002);
    else
      result = IoWMIRegistrationControl(DeviceObject, 2u);
    WPP_GLOBAL_Control = &WPP_GLOBAL_Control;
  }
  return result;
}
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E28: using guessed type int WPPTraceSuite;

//----- (00016406) --------------------------------------------------------
signed int __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  signed int result; // eax@5
  char v3; // [sp+Ch] [bp-68h]@6
  char v4; // [sp+Dh] [bp-67h]@6
  char (__stdcall *v5)(PKSPIN_LOCK); // [sp+14h] [bp-60h]@6
  int v6; // [sp+18h] [bp-5Ch]@6
  int v7; // [sp+1Ch] [bp-58h]@6
  int (__stdcall *v8)(int); // [sp+20h] [bp-54h]@6
  int (__stdcall *v9)(PNDIS_BUFFER); // [sp+24h] [bp-50h]@6
  int (__stdcall *v10)(int, int, int, int, int, NDIS_HANDLE); // [sp+28h] [bp-4Ch]@6
  int (__stdcall *v11)(int *, char *, int); // [sp+2Ch] [bp-48h]@6
  int (__stdcall *v12)(int, int, void *, int, int, int); // [sp+30h] [bp-44h]@6
  int v13; // [sp+34h] [bp-40h]@6
  int (__stdcall *v14)(int, PKSPIN_LOCK); // [sp+38h] [bp-3Ch]@6
  int v15; // [sp+3Ch] [bp-38h]@6
  int (__stdcall *v16)(PKSPIN_LOCK, int, int, int, int, int); // [sp+40h] [bp-34h]@6
  int v17; // [sp+44h] [bp-30h]@6
  void (__stdcall *v18)(PNDIS_BUFFER, PNDIS_PACKET); // [sp+48h] [bp-2Ch]@6
  int (__stdcall *v19)(PKSPIN_LOCK, int, int); // [sp+4Ch] [bp-28h]@6
  int v20; // [sp+50h] [bp-24h]@6
  int v21; // [sp+6Ch] [bp-8h]@1
  PVOID NdisWrapperHandle; // [sp+70h] [bp-4h]@6

  v21 = 0;
  WPP_INIT_CONTROL_ARRAY((int)WPP_MAIN_CB);
  WppLoadTracingSupport();
  WPP_GLOBAL_Control = WPP_MAIN_CB;
  dword_15E98 = 0;
  WppInitKm((PDEVICE_OBJECT)DriverObject);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
    WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 40, (int)dword_15B48);
  if ( AbortLoad )
  {
    result = -1073741536;
  }
  else
  {
    memset(&v3, 0, 0x60u);
    NdisInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, 0);
    v3 = 5;
    v4 = 0;
    v5 = MiniportCheckForHang;
    v8 = MiniportHalt;
    v10 = MiniportInitialize;
    v12 = MiniportQueryInformation;
    v13 = 0;
    v14 = MiniportReset;
    v15 = 0;
    v16 = MiniportSetInformation;
    v17 = 0;
    v9 = MiniportHandleInterrupt;
    v11 = MiniportISR;
    v6 = 0;
    v7 = 0;
    v18 = ReturnPacketHandler;
    v19 = SendPacketsHandler;
    v20 = 0;
    if ( NdisMRegisterMiniport(NdisWrapperHandle, &v3, 96) )
      v21 = -1073741823;
    else
      NdisMRegisterUnloadHandler(NdisWrapperHandle, NscUloadHandler);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
    {
      if ( *((_BYTE *)WPP_GLOBAL_Control + 32) & 2 )
        WPP_SF_(*((_DWORD *)WPP_GLOBAL_Control + 4), *((_DWORD *)WPP_GLOBAL_Control + 5), 41, (int)dword_15B48);
    }
    result = v21;
  }
  return result;
}
// 15838: using guessed type int __stdcall NdisMRegisterMiniport(_DWORD, _DWORD, _DWORD);
// 1583C: using guessed type int __stdcall NdisMRegisterUnloadHandler(_DWORD, _DWORD);
// 15B48: using guessed type int dword_15B48[4];
// 15E00: using guessed type void *WPP_GLOBAL_Control;
// 15E6C: using guessed type char AbortLoad;
// 15E80: using guessed type int WPP_MAIN_CB[6];
// 15E98: using guessed type int dword_15E98;

//----- (00016548) --------------------------------------------------------
NTSTATUS __stdcall GsDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  ULONG v2; // eax@1

  v2 = __security_cookie;
  if ( !__security_cookie || __security_cookie == -1153374642 )
  {
    v2 = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    __security_cookie = (unsigned int)&__security_cookie ^ _KeTickCount.LowPart;
    if ( &__security_cookie == (ULONG_PTR *)_KeTickCount.LowPart )
    {
      v2 = -1153374642;
      __security_cookie = -1153374642;
    }
  }
  __security_cookie_complement = ~v2;
  return DriverEntry(DriverObject, RegistryPath);
}

// ALL OK, 97 function(s) have been successfully decompiled
